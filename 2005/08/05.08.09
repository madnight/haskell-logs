00:00:59 <dons> seems like the local power substation is being operated on
00:08:53 <Itkovian> dons: if you mail me the entire bot stuff (including config) I can keep it running
00:09:11 <Itkovian> no power outages are planned here afaik
00:09:31 <Itkovian> brb
00:10:09 <boegel> unless I pull the plug :p
00:11:00 <boegel> yo Pseudonym
00:12:25 <boegel> printer trouble, /me reboots
00:12:52 <Tue32285> how weird...i have a makefile rule like "$(BUILDDIR)/%.hi : %(BUILDDIR)/%.o"
00:12:59 <Tue32285> but i still get .hi files in my sourcetree
00:13:10 <dons> Itkovian, thanks, I was thinking TheHunter might be able to as he often tests lambdabot on this channel
00:23:21 <boegel> exit
00:23:59 <Pseudonym> nmap www.microsoft.com
00:24:00 <Pseudonym> Oops!
00:24:30 <Tue32285> hmmm
00:24:38 <Tue32285> that might have looked suspicious
00:24:57 <Pseudonym> Were it not Freenode, perhaps.
00:28:12 <Korollary> have you seen start.com, Pseudonym ?
00:28:42 <Korollary> http://www.start.com/3/
00:28:50 <Pseudonym> Err... no.
00:30:24 <Pseudonym> Oh, yeah, now that you mention it.  I think I went here once when it was linked off slashdot.
00:36:24 <Pseudonym> When you see your program use 97% of a CPU, you have to wonder how much of that is work and how much is overhead.
00:36:46 <Pseudonym> Gotta go.  Nytol!
01:35:13 <Tue32285> how can i replace spaces by something else in a makefile ?
01:35:15 <Tue32285> $(subst ' ',somethingelse,$(foo)) is not working
01:40:07 <cathper> patsubst?
01:40:32 <Tue32285> i think the problem lies in how im trying to express space
01:44:24 <Tue32285> hmm had to perform some stupid trick to have a variable represent a space
01:48:09 <boegel> @seen Itkovian
01:48:36 <boegel> oh right, lambdabot is out :s
01:48:45 <Itkovian> hehe
01:49:05 <boegel> hey man, when is the damn coffee break over here :p
01:49:15 <Itkovian> boegel: lunch will be erm when you want it, Dries is not dropping in today it seems
01:49:30 <boegel> oh okay
01:49:35 <boegel> how about now, I'm hungry :)
01:49:36 <Itkovian> so I suggest around 12:00, unless you want warm food, then 12:15
01:49:45 <Itkovian> raid the kitchen
01:49:51 <boegel> why does that matter ?
01:50:07 <boegel> oh, because you'll tag along with Michiel and the rest then ?
01:50:35 <Itkovian> yes.
01:52:16 <boegel> oh, okay
01:52:22 <boegel> woei, the printer works again
01:54:01 <boegel> Itkovian: any idea where I can see the pics from the Italy adventure ? I've heard there are some nice ones :)
01:54:19 <Itkovian> hmm, no idea
02:00:10 <boegel> I've clicked for like 30 pictures, did they get _any_ work done ? :)
02:00:59 <Itkovian> hehe
02:01:03 <Itkovian> I think not
02:01:18 <boegel> why weren't you tagging along ?
02:03:21 <Itkovian> had to go elsewhere on 29-31 july
02:03:34 <boegel> oh, I see
02:03:53 <boegel> Joke is worried already "I'd have to miss you for a whole week ?!?"
02:05:50 <Tue32285> watch wrong with a module named Utils.Bla
02:05:54 <Tue32285> it complains about the filename
02:06:30 <Itkovian> I don't like not seeing Elias for more than 8 hours ;-)
02:06:36 <boegel> probably because there already is a module Utils ? *just guessing
02:07:08 <Tue32285>  /build/Shared/Datatypes.hs: file name does not match module name `Shared.Datatypes'
02:08:06 <dblhelix> Tue32285: it does think the parent of build is the root, instead of build
02:08:45 <Tue32285> eh? i provided all the paths to the ghc -i
02:09:03 <dblhelix> Tue32285: including build?
02:09:19 <Tue32285> yeah, build and build/Shared
02:09:44 <dblhelix> mmm... I'm sorry then :)
02:10:36 <Tue32285> np
02:10:44 <Tue32285> at least you tried :P
02:18:34 <Lemmih> As 'ghc -ibuild -ibuild/Shared'?
02:21:24 <shapr> hoi swiert
02:21:31 <swiert> hi shapr
02:21:40 <shapr> How's code?
02:22:03 <swiert> not too great - the screen on my iBook broke.
02:22:19 <Itkovian> painful.
02:22:27 <shapr> That sucks.
02:22:34 <swiert> on the other hand, I've been doing lots of reading, which is productive.
02:22:36 <shapr> Do you have an external monitor?
02:22:42 <shapr> Heh, that's good :-)
02:23:17 <swiert> at the moment I'm struggling with insurance companies and Apple care.
02:23:18 <Tue32285> geez, the errormessage was totally wrong
02:23:44 <Tue32285> somewhere the file was still being imported as Pretty instead of Utils.Pretty
02:23:59 <swiert> so the laptop is at the repair center and I'm forced to use my old laptop
02:25:23 <swiert> anyway - hopefully I'll be able to roll out some frontend bits of epigram 2 over the next few weeks.
02:25:28 * boegel hopes Apple will be friendly for him
02:25:34 <boegel> my iPod gave up on me :(
02:25:39 <shapr> swiert: awesome!
02:26:09 <Tue32285> boegel, really? how old was it?
02:26:12 <boegel> and it's dented a little bit, but it still worked with the dent, so I'm guessing that wasn't the problem
02:26:26 <boegel> 1 year minus 2 days (iPod mini)
02:26:47 <boegel> just inside the guarantee period, but with the dent... :s
02:27:03 <swiert> yead - we're getting to the point that with a bit of work we should have an empty frontend, that doesn't do any type checking, within a few weeks.
02:27:51 <boegel> now I don't have music on the train, which makes it quite boring (at least, when Itkovian isn't there with me)
02:28:15 <swiert> shapr: how's your code been?
02:28:33 <Itkovian> boegel: I'd go to the apple store asap, there's one in ghent
02:28:57 <Itkovian> boegel: the dude accross me took the seat before I knew you were on too ...
02:29:28 <boegel> I did go :) but I bought it in the FNAC, and the Apple store would've charged me 30 euros :s
02:29:34 <Itkovian> hmm
02:29:41 <Itkovian> then go to the FNAC
02:29:50 <boegel> Itkovian: no harm done there, it's the Torhout-Brugge bit (and back) which was boring today
02:30:22 <boegel> Itkovian: I went already :) but the guy from the repair said there's not much chance in getting it fixed when it has a dent in it
02:30:32 <Itkovian> bummer
02:31:19 <boegel> I'm sure that's not the problem, but if they say it is, I don't have any proof :s
02:31:23 <Tue32285> boegel, i know what you mean...once you are used to having music all the time....it seems really boring when it breaks :D
02:31:42 <shapr> swiert: I hacked on a bittorrent client a bit, it's easier than I expected.
02:31:54 <boegel> yeah, it's pretty quiet here too... can't wait to get my own machine
02:32:48 <swiert> sounds like fun, though.
02:33:12 <boegel> shapr: how about the pdf-reading-thingie you wrote, is it complete yet?
02:34:03 <kosmikus> swiert: what will the new epigram frontend be like, then?
02:35:12 <boegel> shapr: FLM, I remember it now :) is it finished ?
02:35:33 <swiert> kosmikus: we're trying to escape from emacs - ideally, we'd have a epigram api that allows people to plug in their own editor fairly easily.
02:36:14 <swiert> this involves rewriting and reorganising a lot of code though.
02:37:30 <kosmikus> swiert: very good
02:37:43 <swiert> I've had a very brief hack at writing a dumb "terminal" editor - but there's still a lot to do.
02:38:05 <swiert> kosmikus: how is Bonn?
02:41:35 <kosmikus> swiert: city is nice, university-wise uu was better :) and nottingham?
02:42:34 <swiert> all right - I'm in Utrecht right now, but I'll be flying back Friday.
02:43:41 <swiert> University is nice enough - it looks like we'll be getting a lot of new phds in september.
02:44:18 <kosmikus> it's really a bit lonely in bonn so far, not many fp'ers there
02:44:27 <kosmikus> not many interested students either
02:44:36 <swiert> I can't really say how life is though, as I've been there for a few 2-3 week stretches in the summer.
02:44:59 <swiert> too bad - but Ralf Hinze is there, I suppose.
02:45:32 <kosmikus> yes
02:46:17 <swiert> but I can imagine that "the more the merrier" definitely holds for research groups.
02:46:53 <swiert> my mother might be moving to Bonn - so I might visit :-)
02:49:05 <kosmikus> sure, that'd be fun
02:49:55 <kosmikus> why does she want to go to bonn?
02:50:17 <swiert> she might accept a job at Deutsche Post.
02:50:39 <kosmikus> yes, that explains :)
02:50:59 <Tue32285> must be quite a transition from fp-haven UU to Bonn :)
02:51:28 <kosmikus> UU also has more money, or at least it appears that way
02:52:13 <kosmikus> but I'll be able to say more in a few months, when I can really judge how things work in Bonn
02:52:26 <kosmikus> lunch ...
02:52:48 <dblhelix> lunch is early in Bonn :)
02:52:52 <swiert> I definitely think that uu takes fairly good care of you
02:53:31 <dblhelix> agreed
02:54:06 <shapr> boegel: No, it's not finished yet.
02:54:23 <Itkovian> pompompom
02:54:36 <Itkovian> colloqui crashed for some strange reason
02:54:56 <boegel> what's colloqui ?
02:55:21 <boegel> shapr: are you planning to finish it ? seems cool to use it now I've started my Phd
03:01:37 <shapr> Yeah, I'm planning to finish it...
03:03:14 <boegel> shapr: when ? :)
03:03:18 <boegel> and that reminds me
03:03:29 <boegel> dcoutts: what about HOpenGL support in Gtk2Hs :)
03:05:34 <shapr> boegel: Good question :-)
03:05:52 <shapr> Maybe I should just put the repo online and ask for patches.
03:06:39 <boegel> shapr: how far from finished is it ?
03:07:55 <shapr> Not far, but feedback from the users will shape the design.
03:08:16 <boegel> is it available already ?
03:08:21 <shapr> No, but it can be.
03:09:31 <boegel> it should be ! I'll test it when I have my own pc, and I'm sure Itkovian would like to test it too :)
03:09:59 <Itkovian> I've no idea about what you guys are talking atm.
03:10:00 <shapr> Ok, I'll try to finish it and put it online, or I'll just put it online.
03:10:53 <boegel> Itkovian: FLM, ask shapr (after lunch :p)
03:10:59 <boegel> bye for now !
03:11:02 <Itkovian> ok
03:13:11 <shapr> hiya poetix
03:13:20 <poetix> ave
03:14:06 <shapr> How are the lambdas treating you?
03:14:29 <poetix> I was writing some simple webserver code using Network.Socket, and went and had a look at the source for the main Network module
03:14:39 <poetix> which offers a simplified interface for doing the same things
03:14:42 <shapr> Why not use JaffaCake's hws webserver?
03:15:03 <shapr> I think CosmicRay has a simplified network server in MissingH also.
03:15:06 <poetix> Because I didn't know it existed until .05 seconds ago
03:15:12 <shapr> Oh, good reason.
03:15:23 <shapr> There's even a version of hws with hs-plugins by Peter Thiemann.
03:15:46 <poetix> Anyhow, one good thing was that the source for Network was almost exactly the same - I mean practically line for line - as what I'd come up with by myself using Network.Socket
03:15:50 <shapr> If you add nibro's Haskell Server Pages to that, you have the beginnings of the real thing.
03:16:12 <shapr> Oh that's nice, always makes me feel smart when I rewrite the Prelude and other libs.
03:16:15 <poetix> A webserver + hs-plugins was what I was aiming for.
03:16:26 <shapr> That is, I feel smart when I do a good job of rewriting :-)
03:16:32 <shapr> In that case, let me email one to you...
03:16:37 <shapr> If I can find it :-/
03:17:47 <poetix> I will be interested to see that.
03:18:19 * musasabi thinks there are several webserver with hs-plugins things with none of them properly documented.
03:18:36 <shapr> What other webservers?
03:18:52 <poetix> The other thing I want to figure out is whether there's a way of writing a select-based server that does HTTP parsing in an event loop, and spawns threads to handle messages only after it's parsed them
03:19:24 <poetix> (and whether that's worth doing)
03:19:49 <musasabi> shapr: HSP has a stand alone webserver thing if I remember correctly.
03:20:27 <poetix> The idea is that Twisted-style multiplexing is very fast for a simple job like parsing incoming messages, but you really want threads for code that's going to perform blocking operations like database reads and updates.
03:20:36 <musasabi> poetix: spawning before parsing would be nice - otherwise all kinds of problems will creep up.
03:20:50 <poetix> Well, spawning before parsing is *easier*.
03:21:12 <poetix> But parsing before spawning might be faster.
03:21:14 <musasabi> Think about 1) file uploads, 2) clients sending the request slowly (grps and other such things).
03:22:20 <poetix> Using select, you only process data when there's some available, and you take it a chunk at a time as it comes in
03:22:52 <poetix> So slow connections, or large uploads, shouldn't tie up the main parsing thread - each connection only gets a small "slice" of processing at a time.
03:23:09 <musasabi> I think that with haskell light weight threads using separate threads will be easier.
03:23:21 <poetix> Absolutely. Much easier.
03:23:22 <musasabi> and if you want performance you won't use Network ;)
03:23:53 <musasabi> but that is not very important when prototyping things.
03:24:30 <poetix> Multiplexing on a single thread is a much harder programming model, which is why if we do it at all we only want to do it at the start of the process, when we always do the same thing (parse an HTTP message) anyway.
03:24:43 <poetix> What do you use instead of Network?
03:24:59 <musasabi> network-alt or your own high performance network implementation.
03:25:20 * poetix looks around to see if he has a high performance network implementation lying around anywhere
03:25:29 <poetix> ...nope...
03:25:57 <poetix> Isn't Network just an interface to the BSD sockets API anyway?
03:26:01 <shapr> network-alt has ipv6! w00!
03:26:43 <musasabi> poetix: yes, and select(2) does not scale if you have very many connections.
03:26:45 <shapr> Anyway, Haskell's lightweight threads have many (all?) of the advantages of the Twisted model.
03:27:17 <tuomov> poll(2) is better in many ways indeed, but e.g. osx doesn't afaik support it
03:27:25 * poetix remembers why select(2) doesn't scale
03:27:36 <poetix> What does network-alt use?
03:28:00 <tuomov> on cygwin select is a horrid kludge, and so's poll probably
03:28:11 <dblhelix> mmm... it appears that space shuttles aren't the most reliable form of transport when comes to estimating time of arrival
03:28:14 <musasabi> poetix: depending on configuration select, epoll or blocking calls (with ghc managed thread pool which can be suprisingly fast on systems with nptl)
03:28:35 <dblhelix> @seen void-
03:28:50 <dblhelix> mmm
03:28:58 <dblhelix> @seen lamdabot
03:29:00 <dblhelix> :)
03:29:19 <poetix> I blame that trollop vixen.
03:29:51 <shapr> @vixen you trollop!
03:29:55 <shapr> Oh well.
03:37:56 <shapr> I have way too many files with names like {thesis,paper,icfp,hw}.{pdf,ps}
03:39:37 * shapr finds "A noncommutative theory of Penrose tilings" next to "Introduction to Fermat's Last Theorem"
03:39:53 <shapr> I really need to finish FLM just so I can read this stuff.
03:39:56 <tuomov> pdf/ps should have the bibtex entry as metadata, and browsers etc. should support saving using that data
03:40:24 <tuomov> I've learned to look up the title and save using that, but it's a lot of work
03:40:49 <shapr> Yeah, that's why I want FLM, it'll have a bit of that functionality to begin with, and more later.
03:41:09 <dblhelix> shapr: have you read simon singh's book on FLT?
03:41:19 <shapr> "Towards reverse design of freeform shapes" reminds me that I need to get back to studying shape types.
03:41:29 <shapr> dblhelix: Heard of it, haven't read it. I have too many things to read right now.
03:44:30 * shapr finds metaperl's paper on neurons as metanetworks.
04:02:18 <Itkovian> back
04:02:43 <Itkovian> ok, shapr: FLM, what, when, where?
04:05:31 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
04:05:39 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
04:05:50 <shapr> When will it be done? Um Real Soon Now
04:07:14 <tuomov> hmm.. does it need httpd?
04:07:45 <shapr> At the moment it's a cgi app, it uses Flippi. I'd like to make it standalone though.
04:09:01 <tuomov> I guess a built-in httpd enough for this purpose wouldn't be too many lines of code..
04:10:05 <poetix> Everyone wants to write a server...
04:10:23 <poetix> I'm going to resist the temptation, and take a look at hws instead.
04:10:52 <tuomov> I'd rather not run a heavyweight web server on my system
04:11:00 <shapr> FLM mostly works. You put the url to a ps.gz or pdf into a macro and click the button. The paper is downloaded, turned into page images, and wiki pages are generated.
04:12:01 <shapr> Only two pieces are missing, an on-read macro system for Flippi (to [[SubPages]] into an actual list of pages) and darcs integration. I think darcs integration is already available in one of CosmicRay's apps.
04:13:07 <Tue32285> finally my makefile is finished.
04:13:09 <tuomov> it would be cool if you could extract the pages as ps/pdf or even svg and display in a non-obtrusive plugin
04:13:13 <tuomov> so that you could zoom them and all
04:13:14 <Tue32285> took me the complete morning
04:13:37 <shapr> tuomov: What do you mean?
04:13:51 <shapr> Extracting pdf and ps as svg would likely work.
04:14:01 <tuomov> you now turn the pages into bitmaps, right?
04:14:06 <shapr> That's right.
04:14:19 <tuomov> vector graphics would be the correct approach, albeit probably much more difficult
04:14:54 <tuomov> and I haven't seen a decent pdf/ps plugin
04:15:11 <shapr> Yeah, SVG would be a better approach.
04:15:24 <tuomov> infact, I haven't seen a ps plugin and acrobat reader sucks
04:15:37 <jewel> I wonder how big a pdf will be after svg conversion
04:15:54 <shapr> I don't think Mozilla SVG is quite ready yet, but there are decent standalone apps.
04:15:54 <tuomov> you may have to include fonts in each page..
04:17:30 <shapr> I think it would save a lot of space over ps/pdf. It would definitely be easier on system resources.
04:17:41 <poetix> Given a detailed bitmap conversion, you could use a google maps-style interface and serve up zoomed regions a section at a time
04:17:51 <shapr> And I wouldn't have to deal with code to save what size images get rendered.
04:18:31 <poetix> (That is, if you could generate scaled regions of an image on the fly)
04:25:13 <xerox> ciao
04:28:00 <Itkovian> FLM sounds cool, though the imagemagick thingie is a bit annoying, no?
04:29:15 <Itkovian> what I really need is a decent storage thingie for papers I read.
04:29:34 <Itkovian> Because I really can't recall what was in most of them, or where exactly I can find what I need.
04:30:18 <tuomov> I'd like a paper storage with some riot integration..
04:30:45 <tuomov> but it would have to be accessible externally too
04:30:54 <Itkovian> Requirements: storage and retrieval of pdf's, automagick generation of information based on e.g. bibtex data (i.e. file name, lookup, ...), annotation and summarisation
04:31:12 <Itkovian> preferably somewhere in a nice repository, I can copy and tag along
04:31:12 <tuomov> haven't really thought about it that much yet. I want to finish ion3 before working more on riot
04:32:17 <Itkovian> anyway, I need it before I start writing my thesis.
04:32:48 <Itkovian> I'll listen to some more SuicideGirls radio
04:32:54 <tuomov> atm I just try to save things in ~/papers/ by title, and later move to subdirs
04:33:13 <Itkovian> tuomov: yeah, but I read papers on a few computers
04:35:26 <tuomov> I rather print papers for reading
04:36:46 <tuomov> I guess I'd occasionally browse for them them on multiple computers (but don't have net at home atm), but then again, need to connect to a uni computer to have access anywhere
04:37:32 <tuomov> It would be cool, though, if one could put riot data in a e.g. a darcs repo and move things around without conflicts
04:38:16 <tuomov> or maybe just rsync, but then one would have to be much more careful
04:40:18 <shapr> FLM will have annotations in a darcs repo, one repo per paper.
04:40:54 <shapr> The advantage of only putting annotations in the repo is that you don't have to worry about copyright/redistribution issues.
04:41:53 <shapr> So I envision putting the url to a paper into the macro, then clicking to get the viewable paper, and to search for publically mentioned repos.
04:42:54 <shapr> I'd like to have a unique identifier for each paper that can include multiple urls, for pdf/ps/whatever. People change websites, change jobs, I'd want some way to handle that.
04:43:08 <tuomov> hash of bibtex data?
04:43:26 <shapr> Hm, that might work.
04:43:33 <Itkovian> tuomov: I print them too, but for recalling what I read, I find it better to have a repos somewhere
04:43:35 <shapr> I was thinking of something closer to an url.
04:44:26 <shapr> I don't know what sort of unique identifier is good.
04:44:38 <Itkovian> shapr: if a researcher moves, the url could change too.
04:45:45 <tuomov> you could have a paper tracking web service
04:46:00 <shapr> Right, that's why I'd like something that works like an url but uses parts of author, title, etc
04:46:45 <tuomov> you could use http://paper-tracking-service/bibtex-hash to find a copy of the paper
04:47:10 <shapr> Then you could use something like research://peyton-jones/2005/subcontinuations
04:48:17 <tuomov> full bibtex hash won't work though, as the url in it and so on can change
04:48:46 <shapr> Yeah, url or hash should only be based on the parts that don't change.
04:50:12 <tuomov> maybe the service could simply be used to allocate ids for papers
04:50:20 <tuomov> randomly
04:50:33 <tuomov> a bit like arch does with its in-file globally unique identifiers
04:51:00 <xerox> uhm
04:51:18 <xerox> citeseer uses nameYEARsubject or similar, doesn't it?
04:51:46 <xerox> Maybe, citeseer-able urls would be nice.
04:51:56 <shapr> tuomov: But why use a hash then? Might as well use author/year/title
04:52:11 <shapr> You'd get the advantage of human readability too.
04:52:15 <tuomov> hash can be shorter to copy
04:52:33 <tuomov> and I'm not really concerned about human-readability
04:52:33 <shapr> xerox: Yeah, that would be nice.
04:52:43 <Tue23413> if i limit the amount of mem ghc uses when compiling...will i still be able to compile applications that require more?
04:53:01 <tuomov> I was thinking of something that could be used to automatically download a copy of the paper if lost by looking up it in a tracking service
04:53:17 <xerox> Using author/year/title one could search for any combination of each "tag".
04:53:46 <tuomov> infact, the tracking service could a darcs repo with a web searc/add interface of bibtex entries with the extra GUID
04:54:22 <tuomov> and a list of urls
04:56:10 <tuomov> hmm..
04:56:33 <tuomov> it would be cool indeed to have the GUID as the bibtex name of the entry, what you pass to \cite
04:56:51 <tuomov> it can't have the full title then
04:57:38 <tuomov> authorYEARsomethingChoseBySubmitterCheckedToNotBeUsedBefore
04:57:59 <shapr> Why not authorYEARtitleBits ?
04:58:06 <tuomov> titleBits?
04:58:18 <shapr> Yeah, first word(s)
04:58:20 <Itkovian> maybe authorYEARconference-journal-titlebits
04:58:32 <tuomov> too long to use with \cite
04:58:34 <shapr> Is the conference and journal important?
04:58:45 <Itkovian> shapr: well, yes, I think so.
04:59:23 <tuomov> authorYEARtopic, with topic something arbitrary chosen by the submitter but should be related to the title
04:59:33 <xerox> I think we should question about how citeseer indexes them, and why: they do have a *huge* collection of papers.
04:59:56 <shapr> xerox: Yeah, excellent point.
05:00:03 <Itkovian> xerox: yes!
05:00:29 <Itkovian> the name of the article at least name of first author + year iirc
05:02:11 <xerox> They seem to follow this guidelines: http://www.openarchives.org/
05:03:25 <shapr> neat
05:03:35 <tuomov> http://purl.org/
05:03:37 <tuomov> hmm..
05:09:31 <tuomov> hmm.. I've actually seen the DOI stuff used in many places
05:16:03 <Tue23413> question...its nice that make decides which .o files to generate...but how do i get to know which ones he generated so i know which files to link?
05:17:24 <dblhelix> Tue23413: I can send you a standard make file I use and that handles all kinds of stuff like this
05:17:51 <dblhelix> perhaps you can borrow some stuff from it ;)
05:18:10 <Tue23413> ah great, mine is pretty big but i dont want to make a static list of .o files
05:18:22 <Tue23413> so surely i can borrow some stuff LD
05:18:23 <Tue23413> :D
05:18:35 <dblhelix> Tue23413:  where can I send it to?
05:18:56 <Tue23413> cpjvelde@ the rest
05:19:06 <Tue23413> the usual rest lets say
05:22:45 <Tue23413> ah i see the mail, thanks
05:22:50 <xerox> @index arc
05:24:57 <Tue23413> ow damn -M ofcourse
05:29:13 <CosmicRay> shapr: is there a TMR issue that I should be talking about in HWN?
05:32:15 <autrijus> weird. I thought this would work
05:32:57 <autrijus> class (Monad m) => MonadRun m where run :: m a -> a
05:33:55 <autrijus> class (Monad m1, Monad m2) => MonadRunM m1 m2 where runM :: m1 c -> m2 c
05:34:47 <autrijus> instance (MonadRun m1, Monad m2) => MonadRunM m1 m2 where runM = return . run
05:35:05 <autrijus> but whenever I define something, GHC complains about overlaps.
05:35:12 <shapr> CosmicRay: Not really. I could go ahead and re-release IssueFour with whatever is ready.
05:35:12 <autrijus> I already feel undecidable, incoherent and overlapped
05:35:12 <CosmicRay> heh
05:37:18 * shapr comforts autrijus with System Fomega
05:37:38 <autrijus> shapr: I'm working with Fomegasub :-/
05:39:23 <autrijus> or is it Fsubomega.
05:41:10 <poetix> http://www.usenix.org/events/hotos03/tech/full_papers/vonbehren/vonbehren.pdf <- well, I guess that's me told
05:42:51 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050809"]' by CosmicRay
05:44:52 <Itkovian> hi Beelsebob
05:45:50 <autrijus> can a typeclass be inhabited by types with different ranks?
05:46:35 <autrijus> hm, that'd require typecasing.
05:47:05 <musasabi> What would be the best way to package haskell wrappers to extensions of gnutls which are under GPL unlike the rest of the library? The extras will need to access internal representation not exported by the main gnutls wrapper - but I don't want to taint that.
05:48:22 <CosmicRay> shapr: codewiki.net
05:49:03 <CosmicRay> are these extensions shipped with gnutls itself?
05:49:03 <shapr> CosmicRay: yick, lotsa java tehre.
05:49:03 <shapr> there*
05:49:03 <CosmicRay> ah, ane Category:Haskell is empty.
05:49:03 <CosmicRay> s/ane/and/
05:49:03 <CosmicRay> sigh
05:49:03 <CosmicRay> oh well, it looked interesting
05:49:03 <shapr> Yup, too bad, eh?
05:49:03 <CosmicRay> oddly it was linked from the caml weekly news
05:49:03 <musasabi> CosmicRay: yes, but they build two different library files and use gnutls/gnutls.h and gnutls/extra.h.
05:49:03 <tuomov> I think it is BS that you can't link non-GPLd stuff to a GPL'd library
05:49:04 <tuomov> as long as you dn't use the macros from the headers
05:49:04 <CosmicRay> tuomov: that's not true
05:49:04 <tuomov> and the library is dynamically loaded
05:49:04 <CosmicRay> tuomov: you can do that, as long as the non-GPLd stuff can be distributed under the terms of the GPL
05:49:04 <kuribas> Hi, which is the standard directory for installing local libraries on Debian?  (I am trying to install the functional graph library).
05:49:04 <tuomov> hey, it's just some names in the binary, that the user links to the library when executing it
05:49:28 <tuomov> and the user can do whatever he wants
05:49:48 <Beelsebob> hey itkovian
05:52:50 <tuomov> you can't stop people from linking to a dynamic library.
05:58:48 <CosmicRay> kuribas: /usr/local/lib for C stuff.  I don't think ghc in debian has a canonical local location; it all goes under /usr/ somewhere
05:59:31 <kuribas> tuomov: he can do so only if he isn't distributing binaries.
06:00:33 <musasabi> kuribas: that should be already installed - use -package fgl.
06:02:38 <tuomov> a distributed binary does not contain any part of the gpl'd code if macros are not used
06:02:51 <tuomov> just some _names_ of functions in the library  -- for which there could be an alternative implementation
06:03:23 <kuribas> musasabi: oh, fgl comes with ghc?
06:04:20 <tuomov> so it's BS that you can't link to a GPLd dynamic lib
06:05:37 <musasabi> kuribas: yes
06:06:40 <musasabi> ghc-pkg -s fgl
06:09:28 <tuomov> (of course, laws, asp. ip, have never had anything to do with common sense)
06:10:50 <tuomov> s/asp/esp/
06:24:20 <tuomov> the FSF may say something else, but common sense says that it's perfectly ok to link to a gpl'd _dynamically loaded_ library
06:37:52 <Lor> Common sense says that if someone intended to allow dynamic linking to a library by a proprietary application, the author would have licensed the library under something other than gpl.
06:41:51 <tuomov> it's the user performing the linking!
06:41:54 <tuomov> not the author of the program
06:41:54 <tuomov> the author could write a dummy implementation of the library, and build against it, and it just happens to work with the real implementation on the user's system
06:41:54 <Lor> Yes, yes. The point is that since this particular quirk of gpl is well known, one must assume that the licenser uses it intentionally.
06:41:54 <musasabi> tuomov: It might be legally ok at least in some juristications but certainly against the wishes of the library author - thus not a path I would like to take.
06:41:54 <tuomov> people who write gpl'd libs should be ignored.
06:41:54 <shapr> Is the ghc6 package from haskell-unsafe working now?
06:41:54 <Lor> tuomov: ...and their libs too?
06:41:54 <tuomov> no
06:41:54 <musasabi> shapr: it worked fine for me, but all libs depend on the 6.2.2 version causing conflicts.
06:41:54 <tuomov> if you respect their wishes, you can't even link public domain stuff against the shit
06:41:54 <tuomov> it's totally brain-damaged
06:41:54 <Lor> So don't use the brain-damaged shit.
06:41:54 <shapr> hmm
06:41:54 <shapr> I'll just live with the ghc I have.
06:41:54 <Beelsebob> unfortunately, these people think that open source is the *only* good model
06:41:54 <Beelsebob> rather than just one of many models that work
06:41:54 <Beelsebob> and would rather inflict it on you, than let people chose what's best for you
06:41:54 <Lor> Who are "these people"?
06:41:54 <tuomov> free software _is_ the only good model. these people think gpl is the only good model of free software.
06:41:54 <Lor> Besides rms, that is.
06:41:54 <Beelsebob> people who make gpled libraries
06:41:54 <autrijus> I contend proprietary software works best if nobody else understands your code. </troll>
06:41:54 <shapr> Any Haskell libraries for iCal?
06:41:54 <Beelsebob> tuomov: no... I happen to think shareware works very well, you get to test the quality of the software, and the developer still gets paid
06:41:54 <Beelsebob> shapr: not that I know of, but the standard is open
06:41:54 <tuomov> Beelsebob: yeah, right..
06:41:54 <Beelsebob> tuomov: should that have had <sarcasm> tags?
06:41:54 <tuomov> the authors of crippleware that get a living from it can be counted with the fingers of one hand
06:41:54 <Beelsebob> tuomov: actually, I know *many* who do
06:41:54 <Beelsebob> and the amount I make off it is enough to supliment my grant nicely
06:41:54 <tuomov> mac?
06:41:54 <Beelsebob> yep
06:41:54 <tuomov> yeah, crippleware is big there
06:41:54 <Beelsebob> how is it crippleware?
06:41:54 <tuomov> how about window$ crippleware authors
06:41:54 <tuomov> half-functional
06:41:54 <Beelsebob> tuomov: all that says is that windows users are dishonest ;)
06:41:54 <kuribas`> musasabi: ghc-pkg -s fgl => can!t find package `fgl'
06:41:54 <Beelsebob> tuomov: for what reason should the programmer not get paid for what they do?
06:41:54 <vegai> Anyone thought about Haskell bindings for Silc?
06:41:54 <shapr> me me!
06:41:54 <tuomov> no reason, but restrictions like copyright are the wrong way to get paid
06:41:54 <shapr> vegai: I'd like to switch over to silc, I'm tired of IRC.
06:41:54 <vegai> any recommendations for doing bindings for the first time?
06:41:54 <Beelsebob> why?
06:41:54 <shapr> vegai: There's libsilc, have you tried it?
06:41:54 <Beelsebob> how else should they get paid?
06:41:54 <tuomov> donations?
06:41:54 <kuribas`> tuomov: you can do wathever you want with gpl'd code, you can just not distribute binaries linked with code that is not compatible with the gpl (either statically, dynamically, or in any other way).
06:41:54 <tuomov> I could donate something to authors of some good programs if there was a good system for it
06:41:54 <vegai> shapr: that's what I'd use
06:41:54 <Beelsebob> but that's essentially what shareware is... it just enforces the donation a bit more
06:41:54 <shapr> speaking of which, I wish there were a standard framework for donating to the authors of my favorite software. (like ion3)
06:41:54 <Beelsebob> if you don't donate you get a big fuck off screen pissing you off every time you launch
06:41:54 <musasabi> kuribas`: at least the GHC 6.4 has it installed, might be that you need a separate installation for 6.2.
06:41:54 <tuomov> Beelsebob: you still are not allowed to copy the full version thanks to copyright
06:41:54 <shapr> So obviously, some sort of standard donation system is needed.
06:41:54 <shapr> Something that takes credit card.
06:41:54 <xerox> paypal?
06:41:54 <Beelsebob> tuomov: correct... why should one person donating mean that everyone else gets to avoid it?
06:41:54 <shapr> Hm, maybe so.
06:41:54 <Beelsebob> shapr: I use Kagi
06:41:54 <kuribas`> musasabi: Debian is still at 6.2.2 :-(
06:41:54 <Beelsebob> there's lots of systems out there
06:41:54 <tuomov> why should replicating bits be forbidden?
06:41:54 <shapr> I think there are some cases where replicating bits should be forbidden.
06:41:54 <xerox> Anyway, the Haskell-silc idea is great.  I'll hug who'll write it.
06:41:54 <Beelsebob> tuomov: it shouldn't... my licence doesn't say you can't rip bits out and stick other bits in... you just still have to respect my copyright
06:41:54 <tuomov> xerox: I don't entirely trust paypal..
06:41:54 <shapr> I can think of privacy, national safety, and more reasons.
06:41:54 <shapr> But I don't think that software should be restricted.
06:41:54 <xerox> tuomov, uhm - why?  I'm used to use it, in fact.
06:41:54 <shapr> vegai: You could try one of the wrapper generators, maybe hacanon or hsffig?
06:41:54 <shapr> The hsffig has been quite active recently.
06:41:54 <vegai> ok, I'll check'em out
06:41:54 <shapr> hsffig author*
06:41:54 <tuomov> I'd rather have cheap bank transfers through my own bank and not some american megacorp..
06:41:54 * xerox pushes for a well tought c2hs binding (if the library is not huge :])
06:41:54 <shapr> Yeah, same here.
06:41:54 <shapr> Why can't we just put a button on our website so people can dump money from their credit card into our accont?
06:41:54 <xerox> tuomov, I'm using a rechargeable postal CC without a bank account behind, it's handy and without fees (except for the recharge fee of 1€).
06:41:54 <tuomov> Beelsebob: I just believe in a more voluntary form of society than the authoritarism of capitalism
06:41:54 <xerox> shapr, good question.
06:41:54 <tuomov> postal CC?
06:41:54 <Beelsebob> tuomov: unfortunately, the reality is that we're in a capitalist society, and people do not tend to volunteer their funds in that kind of society
06:41:54 <Beelsebob> I'd agree with you in a utopean world
06:41:54 <tuomov> Beelsebob: that can change. people volunteer their time already
06:41:54 <xerox> tuomov, yep.  They have a credit card you could buy for 5€ and with no transfers fees.
06:41:54 <shapr> Yeah, I think people would volunteer their funds if there were an easy way to do it.
06:41:54 <Beelsebob> and... while we're at it... that kinda proves that other models work
06:41:54 <tuomov> some years ago people would have claimed no-one would volunteer their time to write software
06:41:54 <Beelsebob> they just aren't the way you want it
06:41:54 <shapr> I'd definitely volunteer my funds if I could send them to the people I chose.
06:41:54 <Beelsebob> tuomov: yes... and I chose not to... I thought liberty was about being able to chose
06:41:54 <xerox> hah
06:41:54 <vegai> so you like to have 1:1 bindings to C functions?
06:41:54 <shapr> I'd like to fund ion3 for example, and maybe some Haskell bindings for ion3 :-)
06:41:54 <tuomov> you can choose to release the source or not... you shouldn't be able to tell other people that they can't copy bits
06:41:54 <vegai> or ion4 ...
06:41:54 <shapr> vegai: For the moment, yeah. And a darcs repo!
06:41:54 <xerox> Bank would never like this money anarchy via the internet, I think.
06:41:54 <shapr> Right, ion4 in Haskell... mmm!
06:41:54 <shapr> xerox: yes, but banks can't tell us what to do.
06:41:54 <xerox> Indeed.
06:41:54 <shapr> Control is for other people.
06:41:54 <vegai> ghc will need to fix that memory consumption issue first
06:41:54 <tuomov> governments don't like it either
06:41:54 <vegai> I mean the one that will be fixed when dynamic linking works
06:41:54 <xerox> shapr, http://bank.fsf.org/ <g>
06:41:54 <shapr> That would be nifty.
06:41:54 <xerox> I ever wondered how could one open a bank.
06:41:54 <tuomov> anyway, banks are more decentralised than paypal, and thus better
06:41:54 <xerox> (from kindergarden days)
06:41:54 <tuomov> and within the EU wire transfers do not cost anything. it would still be better to not have to give the bank account number to anyone, though
06:41:54 <shapr> Have you read cryptonomicon?
06:41:54 <shapr> tuomov: I thought about that, why not the public/private key approach? It'd be easy to have a "only money in" number.
06:41:54 <tuomov> that could work
06:41:54 <shapr> Speaking of which, have you seen the home banking packages that just hit Debian?
06:41:54 <shapr> I've been wishing for an api to my bank.
06:41:54 <xerox> shapr, what is it?
06:41:54 <shapr> aqbanking-tool
06:41:54 <shapr> I haven't tried it yet, but I hope it works with my bank.
06:41:54 <xerox> yay, asymmetric cryptography is a nice idea.
06:41:55 <xerox> I wonder who we can contact to in the opensource world expose this anarchist plan and make something happen
06:41:55 <shapr> It's not anarchist.
06:41:55 <shapr> openarchy maybe...
06:41:55 <xerox> Did you registered the url? ;)
06:41:55 <shapr> heh, no
06:41:56 <Lunar^> tuomov: http://garlicviolence.org/irl/drkvg-tanneries-aptget_install_anarchism.jpg :d
06:41:56 <tuomov> heh.
06:41:56 <tuomov> apt-get install anarchism actually does install the anarchist faq :)
06:41:56 <Lunar^> for sure :)
06:41:57 <tuomov> riaa, mpaa & friends obviously also would not like easy money transfers on the net, as that would undermine their position
06:41:57 <shapr> hoi basvandijk, learning Haskell?
06:41:57 <tuomov> in general, any distributor company
06:41:57 <basvandijk> hoi shapr, yes indeed
06:41:57 <shapr> basvandijk: Do you have prior experience with functional languages, or is this your first exposure?
06:41:57 <basvandijk> Well, Haskell was the first functional language I learned. But at my university I also learned Clean
06:41:57 <shapr> Would you like pointers to tutorials? Do you have any particular questions?
06:41:57 <basvandijk> I think I know the language pretty well. I only don't have much programming experience in Haskell
06:41:57 <basvandijk> Do you know Clean?
06:41:57 <shapr> No, I haven't used it. I've read about uniqueness types a bit though.
06:42:42 <basvandijk> Uniqueness typing was the thing that attracted me to Clean.
06:42:58 <basvandijk> Somehow it seems simpler than Monads
06:43:19 <shapr> From one viewpoint it is, but from another it's about the same.
06:43:37 <basvandijk> Can you explain further?
06:43:46 <shapr> It took awhile for monads to click for me, but once they did, it was all smooth sailing.
06:44:03 <shapr> Have you seen "All About Monads" and "Monads As Containers" ?
06:44:11 <tuomov> monads for IO may seem complex at first, but then you see all the other applications of monads and IO fits right there
06:44:16 <basvandijk> You meen in the wiki?
06:44:26 <shapr> @wiki MonadsAsContainers
06:44:36 <shapr> and http://www.nomaware.com/monads/
06:45:12 <tuomov> for modifiable data uniqueness typing could be much better approach, though
06:45:23 <basvandijk> thanks! I will bookmark that articel
06:46:33 <Tue23413> can i pass ghc multiple -i flags?
06:46:42 <Tue23413> or will it only consider the first/last one
06:46:53 <Lemmih> @karma+ JaffaCake
06:48:11 <JaffaCake> Tue23413: multiple -i flags work fine
06:48:17 <Tue23413> nice
06:48:18 <Tue23413> ty
06:49:32 <basvandijk> Does anybody use Emacs for editing haskell?
06:50:24 <musasabi> basvandijk: I think that >50% of people on *nix do.
06:50:28 <CosmicRay> basvandijk: I do
06:50:51 <Tue23413> VIMMMM
06:50:53 <Tue23413> :P
06:50:55 <shapr> I use emacs.
06:50:58 <tuomov> Yi!
06:51:04 <shapr> Yeah, Yi!
06:51:10 <shapr> I want syntax highlighting!
06:51:15 <basvandijk> ok, I also use it. But I would like to have syntax highliting
06:51:31 * musasabi wants ghci in a window with symbol completion.
06:51:34 <Tue23413> that shouldnt be a problem
06:51:35 <basvandijk> I use the haskell-mode but it doesn't have syntaxhighlighting
06:51:42 <shapr> It has syntax highlighting here.
06:53:12 <xerox> basvandijk, which version are you using?
06:53:22 <basvandijk> I use the CVS version of Emacs 22.0.50 with haskell-mode version 1.45
06:53:43 <xerox> Sorry, I meant to ask what haskell-mode version are you using.
06:53:53 <basvandijk> 1.45
06:53:56 <xerox> O_o
06:54:14 * xerox buzz - you told me :P
06:54:29 <basvandijk> BTW I use GNU Emacs, not xemacs
06:54:33 <shapr> basvandijk: I'd suggest upgrading to haskell-mode 2.0
06:54:42 <xerox> Right.
06:54:57 <xerox> I use: (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock) on GNUmacs + haskell-mode-2.00
06:55:23 <basvandijk> Mmm I'm on Gentoo Linux here and that version is not yet in portage...so I need to install it manually
06:56:00 <xerox> Or write/update the ebuild :)
06:56:13 <basvandijk> ok, I will try
06:56:58 <bourbaki> moin
06:57:01 <shapr> y0
06:57:22 <bourbaki> hows it going shapr?
06:57:32 <shapr> Life is good. How's yours?
06:57:45 <shapr> I still hate topquoting though.
06:58:07 <bourbaki> topquoting?
06:58:16 <bourbaki> life is as alawys so so :)
06:58:17 <shapr> Yeah, some people write emails with their reply above the content.
06:58:48 <shapr> Even worse, some people include several hundred lines of reply with one line of reply at the very top, and then you have to figure out exactly what they were trying to say.
06:59:23 <bourbaki> i do that too when i write certain ppl cause they complain about me posting to the end
06:59:31 <shapr> weird
06:59:36 <bourbaki> which requires them to scroll down :)
07:00:05 <musasabi> Even more annoying are people who quote too much.
07:00:26 <shapr> Yeah, it's important to cut out the quoted bits so only the relevant parts are shown.
07:00:54 <bourbaki> i do like answering emails interlaced ;)
07:02:06 <ski>  /whois esap
07:02:08 <ski>  /whowas esap
07:02:31 <shapr> Esa Pulkinnen
07:02:42 <ski> ja :)
07:05:11 <Igloo> JaffaCake: Are you here?
07:05:17 <JaffaCake> yup
07:05:54 <Igloo> If compiling with nhc98, is   ghc? (ghc) | hugs? (hugs)   satisfied?
07:06:26 <JaffaCake> nope
07:06:49 <Igloo> But if not compiling with debug, then   debug? (hunit)   is, right?
07:07:04 <JaffaCake> right
07:07:39 <Igloo> How does that make sense?
07:07:58 <Igloo> (I could equally have said just   ghc? (ghc)   for the first one)
07:08:12 <JaffaCake> ah good point
07:08:49 <JaffaCake> it should be ghc? [ghc] (hugs? [hugs])
07:08:57 <JaffaCake> my "nope" above is wrong
07:09:43 <JaffaCake> I guess this is still too subtle... sigh
07:10:07 <Igloo> I don't understand the asymmetric parens in ghc? [ghc] (hugs? [hugs])
07:10:24 <musasabi> What about ghc (ghc) | hugs (hugs) ?
07:10:25 <JaffaCake> perhaps it would help to use C syntax:
07:10:33 <JaffaCake> ghc? [ghc] : hugs? [hugs]
07:10:59 <JaffaCake> the hugs is in the "else" part of the ghc?
07:11:22 <Igloo> Ah, OK, so I don't think it should be as asymmetric as that
07:11:44 <Igloo> That means hugs doesn't suffice if you have ghc set (the example doesn't work well with compilers)
07:11:44 <JaffaCake> you want something like a switch statement?
07:12:24 <Igloo> I'd like    debug? (hunit) | !debug ()   I think (probably with syntactic sugar for this particular case)
07:12:35 <Igloo> And ghc? (ghc) | hugs? (hugs) is unsatisfied with nhc98
07:12:45 * JaffaCake tries to catch up
07:13:13 <Igloo> So that says "You can either have debug set and have hunit, or you can have debug not set and nothing else is needed"
07:13:25 <Igloo> And "You can either have ghc set and ghc, or hugs set and hugs"
07:13:27 <JaffaCake> debug? (hunit)   is the same as   debug? (hunit) | !debug ()
07:13:48 <JaffaCake> that's exactly the semantics I intended
07:13:56 <JaffaCake> (for debug, I mean)
07:14:12 <Igloo> OK, I don't think it should be though
07:14:29 <JaffaCake> huh?  what do you want
07:14:53 <Igloo> Maybe "debug => (hunit)" == "debug? (hunit) | !debug ()"
07:15:21 <JaffaCake> ok, so you don't want to change the semantics, you just want to write it out more explicitly?
07:15:24 <musasabi> intuitively from package systems "foo? (bar)" succeeds always. And that should imply that "foo? (bar) | anything" succeeds always.
07:15:59 <JaffaCake> musasabi: exactly
07:16:00 * Igloo is confused now, hang on a sec
07:17:03 <JaffaCake> Igloo: in my proposal,  "debug? (hunit)" means exactly what you said above, namely "You can either have debug set and have hunit, or you can have debug not set and nothing else is needed"
07:18:25 * Igloo is trying to think what   foo? (bar) | baz? (quux)   should mean
07:19:03 <JaffaCake> it means the same as    foo? (bar)
07:19:18 <Igloo> I think any clauses of unsatisfied ?s should just be ignored, so if nhc is the compiler in the above it should be allowed
07:19:34 <musasabi> I think that is not very sensible. You want "foo? (bar), baz? (quux), foo | baz".
07:19:34 <Igloo> So yeah, with your initial nope retracted it looks OK to me
07:20:36 <Igloo> musasabi: That means something different
07:21:25 <musasabi> that means "require foo or baz defaulting to foo, foo implies bar and baz implies quux".
07:21:29 * JaffaCake looks back at the email
07:21:48 <JaffaCake> my example was wrong, then - I shouldn't have put the '|' before hugs?
07:21:56 <Igloo> Although it's a good point that we might want to be able to say things like   debug | opt   (probably need to write them in a way they can't be confused with package names)
07:22:11 * JaffaCake agrees
07:22:21 <Igloo> JaffaCake: I think the | is right in the example
07:22:45 <beelsebo1> lo
07:22:47 <Igloo> ghc? (ghc), hugs? (hugs)   would mean if both ghc and hugs wree set you would need both (again, doesn't really make sense with compilers)
07:22:50 <shapr> hiya beelsebo1
07:22:54 <musasabi> Make options begin (or end) with a symbol not allowed in package names?
07:23:06 <Igloo> (so with compilers the two are essentially identical)
07:23:11 <JaffaCake> but "ghc? (..)" is satisfied, so everything after the | is ignored
07:23:31 <Igloo> I don't think that is how it should work
07:23:47 <JaffaCake> ok... so how should it work?
07:23:54 <musasabi> Igloo: didn't debian require matching the leftmost successfull choice?
07:24:10 <Igloo> a? (a) | b? (b) | c? (c) | d? (d)   where a and c are true is reduced to   a | c   which is then checked in the normal way
07:24:52 <musasabi> That seems like inside-out evaluation order.
07:25:01 <Igloo> musasabi: No. The buildd daemons are stupid so break if the leftmost one can't be satisfied, but that's just a bug. In particular if you satisfy the build-deps some other way then the tools will happily build the package
07:25:30 <JaffaCake> Igloo: I can't immediately see how to describe that semantics
07:25:38 <shapr> Wow, Tom Lord is really... um, not a nice person.
07:25:46 <autrijus> @hoogle m a -> m b -> m a
07:25:55 <Igloo> JaffaCake: First you do a pass eliminating unnecessary requirements
07:25:58 <JaffaCake> shapr: yeah, he's a jerk sometimes :)
07:26:08 * autrijus wonders if there's something like "finally" for arbitary monads
07:26:10 <shapr> I think that's the nicest way you can put it.
07:26:32 <boegel> yaay, a new HWN ! :) great stuff, keep it up :)
07:26:39 <shapr> So far, all of his posts to ll1-discuss have been insulting, dismissive, etc
07:26:49 <Tue23413> why am i still getting undefined references when i provided '-main-is App.main'
07:27:13 <Igloo> Or you could just think of ? as being "and"
07:27:20 <musasabi> that feels counterintuitive.
07:27:23 <JaffaCake> Igloo: so (flag? (dep1) | dep2)  is equal to dep2 if flag is not set?
07:27:32 <Igloo> Yes
07:27:38 <Tue23413> correction
07:28:06 <Tue23413> '-main-is App.Main.main' gives undefined references.....and 'main-is App.Main' says the module doesnt exist
07:28:09 <Igloo> So a? (a1) | b? (b1) | c? (c1) | d? (d1) = a & a1 | b & b1 | c & c1 | d & d1
07:28:19 <Tue23413> the module header in the file reads 'module App.Main where'
07:28:26 <JaffaCake> ok... that eliminates the need for the "else" version I had... but it does seem a bit odd
07:28:58 <JaffaCake> what's the & operator?  just "and"?
07:29:01 <Igloo> Yup
07:29:02 <boegel> shapr: FLM up yet ?
07:29:22 <JaffaCake> then I don't think your last example is right
07:29:25 <Igloo> Your way   X | Y   is not the same as   Y | X   which seems very odd to me  :-)
07:29:43 <shapr> boegel: Nope, not yet. And probably not today either.
07:29:45 <JaffaCake> but it is!
07:30:01 <Igloo> Not if X is   ghc? (ghc)
07:30:16 <shapr> I ignore people who have arguments so weak they must be distributed as flames to get attention.
07:30:26 <JaffaCake> well, it's left-to-right evaluation, like C
07:30:27 <Igloo> In that case you wouldn't allow Y to be satisfied if ghc was true, unless I misunderstand you
07:30:50 * Igloo wants it declarative, like Haskell  :-)
07:30:59 <JaffaCake> fair enough
07:31:00 <musasabi> Igloo: it seems in your scheme "flag? dep" means different thing in and out of a disjunction.
07:31:23 <Igloo> musasabi: No, but the empty disjunction is always satisfied
07:32:02 <musasabi> Igloo: maybe changing "?" to something else might help then.
07:32:40 <Tue23413> maybe its forbidden to do '-main-is App.Main'
07:32:44 <Tue23413> having the dot there
07:33:41 <JaffaCake> Igloo: ok, I think I see how to describe your scheme.  flag?(dep) means (flag,dep), unless it is not already an argument of |, in which case it means (flag,dep)|
07:34:51 <Igloo> That looks right
07:35:57 <JaffaCake> what bothers me is that flag?(dep) changes its meaning depending on context... or perhaps there's another way to describe the | operator?
07:37:34 <Igloo> Oh, hang on. flag?(dep) is actually (flag,dep) | !flag when not in a disjunction
07:37:56 <JaffaCake> well, that's what I meant by (flag,dep)|
07:38:10 <Igloo> I don't think this rewriting makes much sense as a way of understanding it
07:38:46 <Igloo> Oh, then you have a different definition of | to me and I'm not sure your first half was what I meant in that case
07:39:10 <JaffaCake> so please describe how your | works :)
07:39:17 <Igloo> (flag,dep)|   seems to have your greedy choice semantics
07:39:40 <Igloo> Otherwise you wouldn't need dep if flag was set
07:40:12 <Igloo> In fact, I really don't understand yours at all  :-)
07:40:24 <JaffaCake> grr, you're right
07:40:45 <JaffaCake> never mind, the rewrite is wrong
07:40:55 <JaffaCake> I didn't intend greedy choice
07:41:06 <Tue23413> hmmm this bug filed by simonmar http://www.haskell.org/pipermail/glasgow-haskell-bugs/2004-April/003995.html is happening to me...and i have 6.4
07:41:18 <Igloo> I think it's easy to understand if you think of   a? (a) | b? (b) | c? (c) | d? (d)   where a and c are true being reduced to   a | c   before being further considered
07:41:42 <Igloo> and any empty disjunctions just being thrown away
07:41:48 * boegel leaves once more
07:41:52 <JaffaCake> yes, but the point still remains that flag?(dep) has a different meaning depending on whether it is the argument of a disjunction or not
07:42:04 <Igloo> No it doesn't
07:42:08 <musasabi> Igloo: what about (a? (a) | (b? b, c? c) | d? d) ?
07:42:26 <Igloo> x, flag?(dep), y    is x, dep, y   if flag is set and  x, y   if not
07:43:19 <Igloo> musasabi: When a and c are set? a | c too
07:44:18 <JaffaCake> so it does depend on the context, right?
07:44:34 <JaffaCake> I can't give a meaning to flag?(dep) alone
07:45:48 <musasabi> Why are "... | f? d | ..." and "... | | ..." not equal if f is not defined?
07:46:26 <Igloo> musasabi: Who are you asking? (I think they are)
07:47:33 <musasabi> Igloo: if they are then "(a? a | b? b)" if a is not set is equal to "(| b? b)" which is trivially true.
07:47:40 <Igloo> JaffaCake: The odd thing is the behaviour of the empty disjunction, I think, but it seems logical enough to me
07:48:47 <Igloo> musasabi: Sorry, yes, it's equal to "... | ..." if f is not defined. And because those are the desired semantics
07:49:19 <Tue23413> hmm guess il just post it as a bug
07:49:26 <JaffaCake> I'm thinking of | and , as binary operators, whereas I think you're thinking in terms of lists
07:50:24 <Igloo> I'm thinking of them as commutative, associative, idempotent operators, which you could equally well think of as lists/sets
07:51:01 <JaffaCake> hmm, so I have trouble explaining the meaning of flag?(dep) on its own
07:52:14 <JaffaCake> you can give a meaning to "flag?(dep1), dep2" and "flag?(dep1) | dep2", and similarly when the args are reversed, but what happens if flag?(dep) isn't in one of these contexts?
07:53:51 <Igloo> Hmm, yeah, it is tricky to explain clearly as a one-pass process
07:55:11 <Tue23413> ow lol, i commented a closed bug....:D
07:57:07 <basvandijk> Hi guys, is anybody here using Gentoo Linux?
07:57:28 <Tue23413> that user simonmar wouldnt happen to drop by this chan sometimes would he?
07:57:46 <Tue23413> at least, simonmar is his name on the tracker
07:58:15 <basvandijk> Because I just finished the .ebuild for haskell-mode-2.0 and I need some people to test it
07:58:26 <basvandijk> you can find it here: http://members.home.nl/basvandijk/haskell-mode.tar.gz
07:58:37 <Itkovian> gotta go
07:58:39 <Itkovian> trtyl
07:58:41 <Itkovian> ttyl
07:58:51 <Igloo> JaffaCake: You are right that with lists it could be more simply explained, though, albeit with the empty set oddity
07:59:38 <JaffaCake> right
08:00:21 <JaffaCake> I've no objection to using a different semantics, as long as it can be explained clearly
08:00:55 <xerox> basvandijk, you could also contact dcoutts, I think he packages Haskell things for Gentoo.
08:01:43 <Tue23413> where can i issue ghc bugs?
08:01:51 <autrijus> what's a better structure to use for one<->one mappings?
08:01:55 <JaffaCake> glasgow-haskell-bugs@haskell.org
08:01:56 <autrijus> instead of two Data.Map, that is
08:02:07 <basvandijk> xerox: How do I contact dcoutts, what's his emailadress?
08:03:11 <Tue23413> pl
08:03:13 <Tue23413> ok
08:03:51 <kosmikus> basvandijk: the only change w.r.t. 1.45 is the URI and homepage?
08:05:25 <basvandijk> kosmikus: yes and also the files/50haskell-mode-gentoo.el is a little bit different
08:06:22 <basvandijk> But I will submit a bugreport accoring to: http://www.gentoo.org/doc/en/ebuild-submit.xml
08:06:30 <basvandijk> brb
08:08:49 <kosmikus> basvandijk: that's what I recommend; however, make sure that you don't point to your .tar.gz, rather attach patches to the ebuild and the 50haskell-mode-gentoo.el file
08:09:05 <musasabi> autrijus: better in what sense?
08:09:13 <kosmikus> basvandijk: makes it easier for the maintainers to see what happened ...
08:12:14 <autrijus> musasabi: faster, takes less memory
08:14:04 <kosmikus> basvandijk: actually, I just noticed that there's already a bug open on this
08:19:50 <musasabi> IntMap ?
08:21:21 <autrijus> musasabi: but neither side is Int
08:21:34 <autrijus> although I guess I can make one side Enum.
08:21:46 <autrijus> but still, we don't have MapInt
08:21:50 <autrijus> so doesn't quite help
08:23:43 <musasabi> autrijus: I think that everyone would like something faster - do you have a particular datastructure in mind?
08:24:19 <autrijus> musasabi: these are fixed at compile time
08:24:19 <kosmikus> basvandijk: also have a look at bug #38564 regarding your change to 50haskell-mode-gentoo.el
08:24:44 <autrijus> so I'm wondering what Curry uses to store its Relation, for example
08:25:04 <autrijus> I don't need updatable runtime one-one mapping right now, but that's an interesting question in itself
08:25:30 <musasabi> autrijus: what about generating the code for matching via template haskell?
08:25:36 <autrijus> for now I think IntMap _ on one side and Map _ Int on another side is best bet
08:25:45 <autrijus> musasabi: is case expression not linear?
08:25:49 <musasabi> that should be quite efficient if there are not very many elements.
08:26:07 <autrijus> since I can guarantee Ord -- indeed Enum
08:26:16 <autrijus> it seems kind of wasteful to use a linear case.
08:26:39 <musasabi> I think it is compiled to something optimized at least for Ints (and in practise it has beat other approaches that I have tried many times)
08:26:54 <autrijus> in that case I'll write out the two functions by hand for now. :)
08:27:24 <autrijus> mm, DriFT can't derive Arbitrary. sad
08:28:38 <xerox> I was screwing out a screw so I couldn't write my laugh about what Curry uses to store his Relation, haha!
08:28:41 <xerox> @karma+ autrijus
08:29:16 <autrijus> heh, entirely unintended.
08:54:39 <lanyue> <>BoT^_^
08:55:00 <lanyue> I_will HI 
08:55:01 <I_will> lanyue ޱ 
08:55:04 <I_will> lanyue  
08:55:16 <lanyue> I_will ûOP 
08:55:23 <I_will> lanyue е 
08:55:25 <I_will> lanyue ñû 
08:55:28 <lanyue> I_will ۾׼˰ 
08:55:32 <I_will> lanyue  
08:55:46 <beelsebob_> what the hell encoding are you using?
08:55:52 <lanyue> I_will ˴ҷܶ 
08:55:57 <I_will> lanyue  
08:56:03 <I_will> lanyue ˼ 
08:56:07 <wilx> Sheesh.
08:56:07 <lanyue> I_will ֪ 
08:56:10 <autrijus> beelsebob_: they are using GBK.
08:56:18 <lanyue> I_will  
08:56:19 <I_will> lanyue ô֪? 
08:56:22 <I_will> lanyue ʶ? 
08:56:25 <lanyue> I_will  
08:56:28 <I_will> lanyue Ѿ֪ 
08:56:30 <beelsebob_> ??? Why not just use UTF if you want odd characters
08:56:30 <wilx> This is why IRC should force encoding.
08:56:30 <lanyue> I_will  
08:56:32 <kosmikus> please top
08:56:36 <kosmikus> stop
08:56:46 <lanyue> kosmikus  
08:56:55 <autrijus> greetings I_will and lanyue. are you here to discuss haskell?
08:58:38 <basvandijk>  kosmikus: Are you talking about a Gentoo bugreport? http://bugs.gentoo.org/show_bug.cgi?id=38564 points to something else.
09:00:23 <I_will> beelsebob_ Ҫ쵰˵޳ܵⱲû! 
09:00:31 <kosmikus> basvandijk: 38563, sorry
09:00:38 <beelsebob_> I will: I can't read any of that, use UTF8
09:01:02 <autrijus> beelsebob_: those are, well, curse words.
09:01:06 <autrijus> better if I don't translate them.
09:01:10 <beelsebob_> ah, good good
09:01:20 <autrijus> not very inventive ones at that.
09:02:27 <basvandijk> kosmikus: I see it, also http://bugs.gentoo.org/show_bug.cgi?id=73172 is about haskell-mode 2.0
09:02:39 <beelsebob_> ARGH! why does this think that minimum [722, 1032] is 1032
09:02:55 <shapr> lanyue: Are you learning Haskell?
09:02:58 <shapr> Ah, guess not.
09:04:04 <kosmikus> basvandijk: yes, I know
09:04:40 <kosmikus> basvandijk: I'll try to push it a bit
09:05:07 <basvandijk>  kosmikus: What doe you mean?
09:06:30 <CosmicRay> Hugs.Base> minimum [722, 1032]
09:06:30 <CosmicRay> 722
09:07:02 <beelsebob_> yeh... that's what I get in hugs
09:07:10 <beelsebob_> ... but not after building this program
09:07:38 <kosmikus> basvandijk: I've added a comment to the bug ...
09:08:09 * autrijus wonders why people would drop in randomly and say random offensive sentences in their native language.
09:08:22 <basvandijk>  kosmikus: great! I hope they put it in the tree
09:08:25 <beelsebob_> heh
09:08:53 <autrijus> maybe I should try it out...   "yields falsehood when preceded by its quotation!" yields falsehood when preceded by its quotation!
09:37:20 <shapr> jiihaa!
09:37:39 <SyntaxNinja> hi shapr
09:37:41 * shapr boings furiously
09:37:44 <shapr> Man I love unicycling!
09:40:38 * boegel sings: lalalala
09:46:01 * Beelsebob boings next to shapr
09:46:06 <Beelsebob> game of gladiators?
09:49:00 <shapr> gladiators?
09:49:09 <shapr> On unicycles?
09:49:12 <Beelsebob> yes
09:49:20 <Beelsebob> you never played gladiators?
09:49:26 <shapr> Nope, what's that?
09:49:26 <lispy> with those giant q-tip wands?
09:49:37 <Beelsebob> basically, last man on a unicycle wins
09:49:41 <shapr> Oh that. Nah, I've never met any other unicyclists.
09:49:58 <shapr> Plus I think I have an unfair advantage with my combination of large unicycle and large self.
09:50:14 <lispy> shapr: but you showed me the picture of the people playing sports on unicycles!  I figured that was you and your friends :)
09:50:15 <shapr> I'm 92 kilos in good shape.
09:50:23 <Beelsebob> nah... there's a lot of skill in using your oponent's weight to take them off
09:50:27 <shapr> Nah, that's people I've chatted with on the net.
09:50:34 <shapr> Beelsebob: Ok, we'll have to try that.
09:50:51 <lispy> @eval 92 * 2.25
09:50:53 * shapr wonders what darcs is doing
09:50:54 <Beelsebob> basically, you swing them round and end up firing them at a wall at your combined speed
09:51:03 <shapr> Wow, sounds cool.
09:51:08 <lispy> @vixen you still around?
09:51:11 <Beelsebob> not if it's done to you *g*
09:51:27 * lispy pokes dons, lambdabot is gone!
09:51:34 <Beelsebob> so you've never played hockey eithr? :(
09:52:32 <boegel> lispy: he mentioned it, she will be gone for 16 hours
09:52:56 <boegel> lispy: something about power trouble in the building where lambdabot lives
09:53:06 * boegel -> dinner
09:53:24 <lispy> boegel: ah, thanks for the info
09:53:31 <lispy> boegel: enjoy your dinner
09:53:45 <lispy> boegel -> dinner -> IO a
09:53:52 <lispy> (perhaps that should be IO () )
10:29:30 <Beelsebob> no, he deffinately returns *something*
10:30:32 <shapr> Man, we need OTP for Haskell. Then lambdabot can just transparently migrate to another box.
10:30:48 <ndm> OTP?
10:31:01 <shapr> Erlang's OTP, the distributed processing support.
10:31:57 <boegel> shapr: we need FLM too :p
10:32:03 <shapr> Hm, good point.
10:32:07 <ndm> surely its not *that* hard to write a lambdabot migrator
10:32:08 <musasabi> Lemmih: how is the 64bit operations stuff for GHC going?
10:32:13 <shapr> Do I go hang out with friends, or should I hack on FLM?
10:33:09 <Beelsebob> I think computing is the only industry where that question is even considered for more than 10 seconds
10:33:17 <ndm> shapr, go hang out with friends
10:33:29 <ndm> Beelsebob, i have never considered it for that long!
10:33:43 <musasabi> go hang out with friends to hack FLM ?
10:33:45 <boegel> shapr: friends :) no doubt :)
10:33:51 <Beelsebob> okay, yeh, 10 seconds is a while
10:33:58 <shapr> musasabi: If only I had irl friends who wanted to hack on anything :-)
10:34:15 * shapr decides to move in with musasabi ;-)
10:34:38 * boegel sees shapr and musasabi hugging and kissing
10:34:59 <shapr> Hm, I doubt it. I think musasabi's girlfriend wouldn't be happy.
10:35:04 <shapr> Neither would mine.
10:35:20 <musasabi> :-)
10:35:22 <Beelsebob> they could hug and kiss too
10:35:31 * shapr throws research papers at Beelsebob 
10:35:38 <Beelsebob> :P
10:35:46 <Beelsebob> how many?
10:35:49 <lament> perhaps we could even record it on video
10:35:49 <Beelsebob> and on what?
10:35:53 <lament> and make lots of money
10:36:01 <lament> (the girlfriends, not shapr and musasabi)
10:36:02 <shapr> Beelsebob: About thirty seven, I'm just cleaning out my homedir.
10:36:14 <musasabi> My friends only hack perl and make propositions about work with fortran (the part of them that is interested in such things).
10:36:25 <Beelsebob> 37? pah... I laugh at your futile attempts
10:36:31 <xerox> musasabi, blargh
10:36:32 <shapr> It's interesting to look back on my trail of research papers, I have varied interests to say the least.
10:36:47 <shapr> Beelsebob: This is just the stuff I've downloaded since I last cleaned out my homedir.
10:36:52 <Beelsebob> hehe
10:36:57 <Beelsebob> I never clean out my paper
10:36:59 <Beelsebob> +s
10:37:10 <Beelsebob> in fact... that reminds me, I really should write iPaper
10:37:13 <shapr> I have to organize mine because I refer to some papers often.
10:37:20 <ndm> I never clean out my desk
10:37:28 <lament> I never shower
10:37:31 <shapr> eek
10:37:36 <shapr> On the internet, no one cares if you shower.
10:37:55 <lament> exactly
10:37:59 <lament> that's why i never leave my room
10:38:08 <shapr> You need unicycles!
10:38:09 <Beelsebob> yeh... this is my plan for iPaper... kinda iTunes, but rather displaying neat references that open up into a paper when you double click it, and providing bibtex refs etc
10:38:18 <Beelsebob> everyone needs unicycles
10:38:23 <lament> shapr: yeah, i've been walking around going to various bicycle shops
10:38:25 <shapr> Beelsebob: Want to hack on Fermat's Last Margin with me?
10:38:28 <lament> and asking if they have unicycles
10:38:38 <shapr> lament: unicycle.com is excellent.
10:38:46 <Beelsebob> yeh, unicycle.com rocks
10:38:54 <shapr> unicycle.com has branches in Sweden, UK, New Zealand, etc
10:39:16 <shapr> Oh, and in Germany too.
10:39:28 <Beelsebob> certainly the UK one (and probably the others) the guys are very friendly and will give you great advice on the end of the phone
10:39:42 <Beelsebob> although, you should never believe myark in person
10:39:53 <lament> whoops my internet just died
10:39:54 <ndm> Beelsebob, have you seen bibedit http://www.nmitchell.co.uk/programs/general.htm
10:39:58 <lament> anyway, they all say they don't
10:40:10 <lament> and don't even remember the last time they saw them anywhere.
10:40:14 <Beelsebob> ndm: I've tried a few... none of them *quite* do what I want
10:40:30 <Beelsebob> ndm: the most important part for me is keeping track of where the actual papers are
10:40:32 <ndm> Beelsebob, well bibedit is open source, if you want it
10:40:41 <lament> buying stuff online is scary.
10:40:45 <ndm> Bibedit associates a name with each one
10:40:47 <Beelsebob> I may extend that, I was planning on making iPaper open
10:40:56 <ndm> so you store it as N009 - whatever.ext
10:41:03 <ndm> and set the bibedit ref to N009
10:41:11 <ndm> then it auto-associates
10:41:25 <Beelsebob> yeh. I'd rather have a slightly neater interface than that
10:41:31 <Beelsebob> but that's somewhere close to what I want
10:41:40 <ndm> i saw a macos one as well
10:41:49 <Beelsebob> yeh, there is one
10:41:51 <ndm> mac only, but very similar + native mac feel
10:41:54 <Beelsebob> but it's nasty nasty nasty
10:42:02 <Beelsebob> bibDesk IIRC
10:42:06 <ndm> i only saw a screenshot, it looked pretty good
10:44:46 <Beelsebob> we shall see when I get round to dealing with iPaper... too many other things on my plate at the mo
10:45:03 <Beelsebob> Defaulter, Hookline, Hat, XHoogle.....
10:45:13 <ndm> i am in the process of rewriting hoogle
10:45:32 <Beelsebob> can you make sure to make it as library based as possible?
10:45:39 <ndm> considering integrating WinHoogle with WinNhc, then you can use that as a template for XHoogle
10:45:44 <Beelsebob> so that I can just hook into the relevant bits that provide data
10:45:57 <ndm> definately
10:46:08 <ndm> have you seen the CVS repository?
10:46:17 <Beelsebob> I've seen it, but not checked out
10:46:23 <ndm> i intend to factor our the web code entirely, so its much easier and more modular
10:46:38 <Beelsebob> oh, cool
10:46:48 <ndm> i was going to do a process that takes an input line and gives the output
10:46:49 <Beelsebob> then I can just grab data out and stick it in an NSTableView
10:46:51 <ndm> and never terminates
10:46:58 <ndm> possibly returning the data in XML
10:47:32 <Beelsebob> as long as I can have a haskell function I can throw a string and get back a data structure containing the results I'm happy
10:47:44 <ndm> arbitrary haskell data type ok?
10:47:53 <ndm> how easy  are they to marshall to C?
10:48:01 <Beelsebob> probably... I've not played with integrating C and Haskell much
10:48:05 <ndm> (i have never done Haskell C interacting)
10:48:06 <Beelsebob> anyone here know?
10:48:27 <ndm> that was why text output in XML was my guess - really easy to do, just spawn a process
10:48:39 <Beelsebob> if not... cocoa has an xml parser, so that would work too
10:48:49 <Beelsebob> but the fewer processes spawned, the better
10:49:01 <ndm> i was going to do a forever living process, interactive
10:49:09 <ndm> so only spawn for the first query, not for every one
10:49:09 <Beelsebob> hmm, could work
10:49:21 <ndm> but a direct haskell interface would be nicer
10:49:22 <Beelsebob> so you spawn it as the app starts and maintain an input and output pipe?
10:49:35 <ndm> yep
10:49:46 <Beelsebob> well... export a direct haskell interface, and if that lets you link in, all the better
10:50:24 <Beelsebob> then at least other haskell programs can use it
10:50:29 <ndm> yep
10:50:33 <Beelsebob> I may even write XHoogle using HOC
10:50:37 <Beelsebob> then it's all spiffy
10:50:43 <ndm> would be very handy in GHCi, imagine :hoogle <something>
10:51:35 <Beelsebob> indeed
10:51:42 <Beelsebob> oh... and something for the search
10:51:54 <Beelsebob> can you make it look for the parameters in any order...
10:51:59 <ndm> it already does
10:52:03 <Beelsebob> really?
10:52:05 <ndm> (or should do)
10:52:07 <Beelsebob> hmm...
10:52:17 <ndm> @hoogle (a -> b) -> [a] -> [b]
10:52:18 * Beelsebob wonders why it didn't find elem
10:52:33 <Beelsebob> @hoogle [a] -> a -> Bool
10:52:55 <xerox> @version
10:52:57 <Beelsebob> oh... it does now
10:53:01 <Beelsebob> lambdabot is dead
10:53:05 <Beelsebob> long live lambdabot
10:53:13 <ndm> the web version gives elem for that query
10:53:16 <ndm> and notElem
10:53:24 <musasabi> Hoogle in ghci would be very very nice.
10:53:26 <xerox> @index notElem
10:53:29 <xerox> oops :P
10:53:34 <ndm> (i didn't even realise there was a notElem til just now)
10:53:34 <Beelsebob> what's the ordering you use on output if the types are the same?
10:53:43 <ndm> random
10:53:45 <Beelsebob> just the order you find them in?
10:53:51 <ndm> the order they are in the input file hoogle.txt
10:53:58 <Beelsebob> :)
10:54:10 <ndm> new version will sort by order of "goodness"
10:54:15 <Beelsebob> cool :)
10:54:20 <ndm> i.e. Prelude > Data.* > GHC.*
10:54:29 <Beelsebob> oh... okay, module goodness
10:54:46 <lispy> ndm: you're adding the heirarchical(sp?) libs now too right?
10:54:56 <lispy> ndm: i could really use hoogle with HOpenGL
10:55:00 <ndm> lispy, yep, all of them
10:55:05 <lispy> sweeeeet
10:55:12 <lispy> @karma+ ndm
10:55:14 <ndm> the idea is to hit all of GHC first, then OpenGL and wxWindows etc. after that
10:55:25 <ndm> probably best to leave the karma til after i've done it :)
10:55:30 <xerox> lambdabot absence is interferring with #haskell life :)
10:55:31 <lispy> ndm: does it require a lot of manual effort?
10:55:50 <ndm> lispy, i'm still writing the tool - so lots at the mo
10:55:59 <ndm> but after that it should be a command line exec and leave
10:56:08 <ndm> unfortunately, it currently takes over an hour to do the GHC libraries
10:56:08 <lispy> ndm: does it parse haskell source to generate hoogle.txt?
10:56:19 <lispy> ah, that's okay if it's automated
10:56:21 <lispy> it could take a week
10:56:30 <ndm> lispy, :m + everying, :b module, :i name
10:56:37 <ndm> and it makes windows xp reboot from memory issues
10:56:52 <lispy> :(
10:57:07 <ndm> linux works fine though, and i'll generate them for most of the large projects
10:57:25 <ndm> it might be better to hack it into GHC
10:57:42 <Beelsebob> haha, gotta love XP memory management
10:58:04 <ndm> it only happened once, so i hope in future it will work fine
10:58:19 <Beelsebob> and you do only have 128 megs don't you?
10:58:26 <ndm> but i just moved to linux, since i do all my development on my windows
10:58:31 <ndm> nope, at uni
10:58:35 <ndm> i think its 512
10:58:37 <Beelsebob> oh, okay
10:58:56 * Beelsebob wonders how he got so jammy with the machine the department gave him
10:59:05 <ndm> the problem is you have to :m + module for every single module, i.e. 340
10:59:09 <ndm> to get the class information out
10:59:56 <musasabi> GHC API will solve that problem in the future (as would parsin .hi files).
11:00:28 <musasabi> Then again generating the files may be slow - that has to be done only once.
11:00:53 <lispy> ndm: it would also be nice to be able to hooglize ones own projects
11:00:59 <ndm> parsing .hi files was a pain
11:01:09 <ndm> but may be the way forward
11:01:23 <CosmicRay> what does haddock do?
11:01:23 <Beelsebob> lispy: Salmon may well help there...
11:01:26 <ndm> lispy, i hope with WinNhc you will be able to do hoogle on your own projects
11:01:34 <Beelsebob> but unfortunately that's low down on my priority list
11:01:54 <ndm> haddock only finds existing type sigs, not implicit typing
11:02:06 <CosmicRay> yeah
11:02:08 <ndm> and its not particularly friendly to generating hoogle info, salmon would be though
11:21:05 <shapr> hs-plugins already has support for .hi file parsing.
11:23:21 <shapr> @yow !
11:24:38 <wilx> lambdabot's on vacation.
11:25:13 <lispy> I'm encased in the lining of a pure pork sausage!!
11:25:31 <lispy> wilx: not vacation, sebatical ;)
11:26:37 <monochrom> hahaha, as if lambdabot needs to write a research paper on automatically rewriting terms into pointfree forms
11:27:51 <lispy> monochrom: actually it's a book to be titled "Life of Lambda"
11:28:15 <lispy> (if you've seen the book 'life of pi' it will make more sense)
11:31:28 <lispy> i could bring my megahal bot in here to keep us company till lambdabot returns, but it has a swearing problem ;)
11:32:37 * monochrom swears on swearing
11:38:26 <lispy> {}: do you know lambdabot?
11:38:26 <{}> lispy: I was the last 15 mins till i have it in the name i know lambdabot.
11:42:56 <shapr> jiihaa!
11:43:05 <shapr> So, what's up?
11:43:12 <lispy> not much
11:43:28 <lispy> i got NeHe lesson 06 working in haskell
11:43:34 <lispy> that was fun
11:45:16 <CosmicRay> well now, that was one heck of a helpful global notice.
11:45:20 <CosmicRay> "we've had a glitch".
11:45:51 <shapr> lispy: Are you extending Lemmih's NeHe lessons?
11:46:45 <lispy> shapr: i was unaware of them, they are not listed on the NeHe site and google didn't pick them up either
11:47:12 <shapr> http://www.scannedinavian.org/cgi-bin/darcs.cgi/haskellnehe/?c=browse
11:47:30 <shapr> I think it's darcs get http://www.scannedinavian.org/repos/haskellnehe
11:50:14 <lispy> shapr: huh, that's cool
11:50:54 <lispy> i'll keep converting them by hand so that i learn it better, but it's nice to know there is an answer key if i get stuck
11:57:31 <shapr> Yay, I'm making progress on the ShowMacro!
11:57:31 * shapr boings
11:58:03 <CosmicRay> what are these nehe lesson things?
11:58:52 <stepcut> CosmicRay: OpenGL lessons from http://nehe.gamedev.net/
11:58:57 <CosmicRay> ah
12:02:34 <lispy> anyone on powerpc want to try something for me?
12:02:56 <lispy> import Foreign; do { w <- allocaBytes 4 (\p -> do { pokeElemOff p 0 0; pokeElemOff p 1 1; pokeElemOff p 2 2; pokeElemOff p 3 3; peek (castPtr p)}) :: IO Int32; print w}
12:03:05 <lispy> oh shoot
12:03:09 <lispy> wrong one
12:03:37 <lispy> import Foreign; do { w <- allocaBytes 4 (\p -> do { pokeElemOff p 0 (0::Word8); pokeElemOff p 1 (1::Word8); pokeElemOff p 2 (2::Word8); pokeElemOff p 3 (3::Word8); peek (castPtr p)}) :: IO Int32; print w}
12:04:03 <lispy> on x86 i get 50462976
12:04:32 <lispy> i'm thinking i can use this to detect endianness automagically ;)
12:05:33 <threeve> lispy: i can run that if you paste it somewhere where I can copy/paste it and run it.  it complains about indentation
12:06:02 <musasabi> lispy: just use alloca 0 $ \ptr -> do poke (castPtr ptr) (1 :: Word8); peek ptr
12:06:37 <lispy> musasabi: how would that work?
12:07:59 <lispy> threeve: are you using ghci?
12:08:09 <threeve> yes
12:08:17 <lispy> thebug: i just typed :m + Foreign, followed by everything the import
12:08:31 <lispy> s/thebug/threeve
12:08:35 <musasabi> lispy: well it is first set to 0 and then the first byte is set to 1. Then it is peeked and the value can be checked.
12:09:03 <threeve> 66051
12:09:11 <lispy> ah, cool
12:09:14 <lispy> musasabi: same idea then
12:09:27 <lispy> musasabi: but i'm checking a whole 32bit int
12:11:13 <musasabi> What big endian systems does ghc-6.4 run?
12:11:21 <musasabi> *on what
12:11:43 <lispy> powerpc has different endianness than x86
12:11:49 <musasabi> point.
12:11:50 <lispy> but i don't know which is big and which is small ;)
12:13:03 <CosmicRay> powerpc, big.  x86, small.
12:13:04 <musasabi> x86 is little endian.
12:13:36 <musasabi> But I think none of my ppc machines will run linux :-(
12:13:46 <CosmicRay> really?
12:13:56 <musasabi> nubus things.
12:14:03 <CosmicRay> evil, but I think debian supports those
12:15:15 <CosmicRay> start at http://www.nl.debian.org/ports/powerpc/
12:15:41 <CosmicRay> http://penguinppc.org/about/intro.php#hardware
12:17:05 <lispy> so big endian means the byte order is [1,2,4,4] where 1 is the msb?
12:17:24 <sylvan> almost: [1,2,3,4]
12:17:25 <sylvan> =)
12:17:37 <lispy> heh, guess i should have type [1..4] ;)
12:18:17 <musasabi> CosmicRay: thanks, it seems that I should try that with the performa which actually has a ethernet card.
12:22:30 <int80_h> hello people
12:31:56 <lispy> data Endian = BigEndian | LittleEndian deriving (Eq, Ord, Show) or data Endian = LittleEndian | BigEndian deriving (Eq, Ord, Show) ?
12:32:13 <lispy> i never am sure which order Ord will derive in
12:32:21 <lispy> ascending or descending
12:33:22 <musasabi> Why do you need Ord?
12:33:30 <lispy> i don't *need* it
12:33:43 <lispy> just thought it was fitting since they have 'big' and 'little' in their names
12:34:58 <monochrom> well, if you can't decide whether big is bigger than small, you shouldn't Ord it.
12:36:26 <musasabi> I cannot think of sensible use of Ord for them.
12:36:47 <lispy> if endian <= BigEndian then ...
12:36:50 <musasabi> Enum might make sense however.
12:37:39 <musasabi> lispy: what could be the else part if BigEndian > LittleEndian ?
12:37:41 <lispy> anyway, the more important question (to me) is which order they should be so that LittleEndian < BigEndian
12:38:04 <xkb> does anyone here by chance know how to use the 'e' empty symbol in the parser generator CUP?
12:38:35 <wilx> Hmm, left to right, e1 < e2 < e3...
12:38:40 <wilx> IIRC.
12:38:42 <musasabi> if "endian <= BigEndian then foo else bar" should be uqual to "foo".
12:39:00 <CosmicRay> I think it makes no sense to make a set of two items a member of Ord.
12:39:05 <CosmicRay> just make it a member of Eq and be done with it.
12:40:49 * lispy appologizes for asking, he just thought it was a good excuse to learn how to derive Ord
12:41:08 <Igloo> Unless you need to put it in a Set or something, in which case you don't care what it does
12:41:47 <CosmicRay> here's another question: why do you care, in Haskell, whether the machine is little or big endian?
12:42:06 <lispy> CosmicRay: loading binary data from a file
12:42:06 <CosmicRay> shouldn't the existing Storable instances take care of this automatically for you?
12:42:16 <musasabi> CosmicRay: they do not.
12:42:29 <CosmicRay> lispy: well, in that case, it's relelvant to know the endianness of the file, not of the host, yes?
12:43:15 <lispy> CosmicRay: well, the file has a set endianness, but the host kept changing
12:43:39 <CosmicRay> but why is the host relevant?  Are you using C code to load the data from the file?
12:43:53 <lispy> no, i'm using haskell
12:44:46 <lispy> the file has the bytes in the order [1..4] (where 1 is msb), and when i loaded the data on PowerPC the bytes were reversed.  Now my code checks for endianness at run time and reverses the byte order on PowerPC
12:44:52 <sylvan> is cabal-1.1 included in the HEAD branch?
12:45:09 <monochrom> data X = A | B deriving Ord  -- A<B
12:47:07 <lispy> if you would like to futher criticize my endianness checking I use unsafePerformIO so that the endianness check returns Edian instead of IO Endian ;)
12:47:33 <lispy> i figure if the endianness doesn't have referential transparency then I have bigger problems to worry about ;)
12:49:37 <SamB> yes, probably!
12:49:45 <SamB> how would something swap endianness in mid-process?
12:50:14 <sylvan> how do I install ghc-6.5 in windows? I downloaded it and copied it to where I want it but I get the feeling I should do something else to "register" it...
12:50:35 <lispy> sylvan: maybe add it to your path or something?  (just guessing...)
12:50:46 <sylvan> I really only need it for the latest cabal, but the new ghc-pkg reports the same old cabal-1.0
12:51:05 <sylvan> so I'm guessing that the new ghc-pkg reads the old list of "registered" packages and not the ones that came with 6.5
12:51:12 <SamB> doesn't hslib come with endianness detection?
12:51:23 <lispy> what is hslib?
12:59:44 <monochrom> if you play with inet_lnaof() or friends, and your computer's endianness differs from that of TCP/IP, you may change endianness.
12:59:48 <SyntaxNinja> CosmicRay: thanks for HWN!
13:00:15 <CosmicRay> SyntaxNinja: you're welcome.  glad it's useful.
13:00:27 <lispy> monochrom: isn't endianness a hardware thing?
13:00:59 <monochrom> endianness is a convention thing.
13:01:40 <monochrom> TCP/IP packet headers contain 32-bit data and so it has its endian convention too.
13:02:40 <monochrom> Its convention does not have to be the same as that of your hardware.
13:03:17 <monochrom> (Since in the world we do have both kinds of hardware.)
13:03:32 <lispy> are you talking about changing the way integers are intpreted (this is what I meant by changing endianness) or just about about reording bytes?
13:04:13 <musasabi> lispy: http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt/Network/Alt/Endian.hs
13:06:17 <monochrom> No one understands me.  I know too much.
13:08:37 <monochrom> I guess I was just answering "how would something swap endianness in mid-process?:
13:26:56 <lispy> monochrom: oh so maybe if your process is distrubuted across machines of different endianness?
13:27:58 <Philippa> that and you've failed to abstract appropriately, yeah
13:31:52 <lispy> well, i still stick by my statement that if the endianness is changing midprocess then I have bigger things to worry about it :)
13:32:14 <lispy> i wonder if RMS uses google
13:33:05 <monochrom> If I write a web browser for a Windows PC, and I use it to contact www.microsoft.com only, do I have to change endianness somewhere?
13:34:14 <Philippa> I can't remember if x86 endianness = TCP/IP endianness or not
13:34:31 <threeve> network byte order is big endian
13:34:34 <lispy> Philippa: i dont' think so
13:35:30 <lispy> so if you're on PowerPC and you visit apple.com you may not need it ;)
13:35:54 <monochrom> they conspire to be opposite
13:36:17 <threeve> not for much longer...
13:37:19 <lispy> oh hey this year makes 25 years for the FSF
13:37:39 <monochrom> the web browser, or some other part of the Windows PC, will have to turn a small-endian 32-bit address into big-endian for stuffing packet headers.  The microsoft server has to do the reverse.
13:38:22 <lispy> we should just make intel switch
13:38:39 <lispy> that's not hard right?
13:38:39 <monochrom> There may be other header fields longer than 8 bits and actually need to be treated as integers (e.g., counters) rather than mere addresses.
13:40:34 <monochrom> Indeed, checksums have to be converted back and forth.  (You may cheat for addresses, I admit.)
13:41:12 <yosemite> any parsec experts on?
13:41:30 <yosemite> I'm having a problem with manyTill
13:42:31 <monochrom> Reckoning that the majority of hardware in use is already set in stone, I would say very hard for Intel to switch.  You see they even have a problem abandoning their old cisc instruction set.
13:42:46 <monochrom> (And now they even have a problem going to 64-bits)
13:43:06 <monochrom> I used to understand manyTill.  Let me read.
13:43:29 <yosemite> I think I figured a better way out
13:43:30 <lispy> yosemite: what sort of trouble?
13:43:34 <Philippa> yosemite: what's the problem?
13:43:37 <lispy> yosemite: i'm far from expert, but i have used it
13:43:42 <Philippa> (and have you checked it's not a case of needing try?)
13:43:51 <yosemite> I need manyTill to not consume the end token
13:44:27 <yosemite> so I have manyTill anyToken (char '%')
13:44:29 <lispy> there is a different combinator for that, as i recal
13:44:37 <yosemite> but I don't want it to consume '%'
13:45:16 <monochrom> endBy ?
13:45:24 <yosemite> I'll check
13:45:33 <monochrom> Yuck, endBy is different.
13:45:39 <yosemite> I just wrote many (satisfy (/='%') which seems to work
13:46:03 <Philippa> if there isn't one, a "don't consume" combinator might be useful
13:46:30 <yosemite> that's what I thought
13:46:32 <Philippa> it's user-implementable - there're get and set operations on the input stream, you'd just get it, parse and set back
13:46:59 <yosemite> I looked at the Sutton/Meijer paper and they have one in there, but I couldn't find the equivalent in parsec
13:47:15 <monochrom> notFollowedBy may be part of the solution
13:47:23 <Philippa> it's not often there's a really good use for it
13:47:50 <Philippa> though the manyTill somethingIdon'twanteaten case is perhaps one example
13:50:04 <Philippa> I'm not sure quite what it does to efficiency though
13:50:14 <Philippa> I mean, probably not /too/ bad, but...
13:50:56 <lispy> normally wouldn't you try for '%' and then continue with the other parser on failer?
13:51:19 <lispy> and then repeat that
13:51:46 <monochrom> many (satisfy (/='%'))  is both much cleaner and surely efficient.
13:51:55 <yosemite> (many1 (satisfy (/='%')) seems to be working great, there's probably some weird cases it misses
13:52:14 <paolo_> hi
13:52:22 <paolo_> (just me, xerox, ubuntu breezy test run)
13:53:49 <yosemite> this is probably a case where I'm using parsec as a 1 ton hammer for a square peg
13:53:53 <yosemite> anyway
13:54:55 <lispy> yosemite: maybe, but writing a parser by hand is error-prone more often than one you end up wanting it to be more flexible later
13:57:11 <yosemite> yeah, this is essentially a parser that turns "aaa bbb %{ccccc} ddd %{eee}" into a list of tokens, which I then apply the percent expressions to a dictionary to build a replacement string
13:57:37 <monochrom> I would not say "for just launching a haskell program, using a million-line-of-code OS sounds like overkill."  The alternative is even more expensive.
13:58:05 <lispy> heh, good example
13:58:05 <yosemite> haha
13:58:17 <monochrom> Though, you could use RegEx for some extremely simple parsing.
13:58:41 <yosemite> I haven't looked at any of the haskell regex stuff yet
13:58:45 <lispy> as long as you don't have nesting regex is pretty good
13:58:54 <monochrom> But anytime you find the regex you write unreadable, don't feel guilty to beef up to parsec.
14:18:04 <paolo> So, people, how's code?
14:20:21 <SyntaxNinja> hi paolo
14:20:31 <SyntaxNinja> code rulz
14:21:36 <sylvan> Can anyone figure out a grep command to take a table and transform each line so that it's just space delimited (right now the columns are delimited by one or more spaces, and in some cases tabs)
14:22:06 <paolo> sylvan, a "table" ?
14:22:11 <sylvan> so the row "one    two three\tfour" => "one two three four"
14:22:28 <sylvan> just a text file with each row having a bunch of columns
14:22:30 <paolo> sylvan, pipe it trough sed -e 's/\t/ /'
14:22:37 <paolo> hmm..
14:22:53 <paolo> better: sed -e 's/[ \t]*/ /'
14:23:44 <paolo> SyntaxNinja, indeed - I'm going mad with this cairo thing, but it's fun ;-)
14:24:27 <sylvan> paolo: hmm.. doesn't seem to transform the delimiter "    " to just " "
14:24:54 <sylvan> Or maybe i should just tell you my problem instead, I want to pick out the first and fourth column from the "who" command
14:25:18 <paolo> ok :-)
14:26:06 <paolo> who | awk '{print $1" "$4}'
14:27:14 <sylvan> Thanks!
14:27:44 <paolo> You're welcome!
14:32:49 <sylvan> Lemmih: Is there any progress being made with regards to Hacanon? Specifically haddock-generation of generated code and maybe some further documentation on usage etc.?
14:44:51 <Philippa> it's a bit hard to generate haddock stuff for TH code :-(
14:45:49 <sylvan> Well hmm.. It would be really helpful to just get some info about the names and type signatures of the haskell version of the library though...
14:46:15 <Lemmih> sylvan: Nope. Hacanon is pretty dead.
14:46:17 <sylvan> Especially since I haven't found a comprehensive manual detailing how the names are chosen..
14:46:37 <sylvan> Bah.. Isn't it pretty much the only way to interface with C++ from Haskell?
14:47:12 <Lemmih> You can manually write the interface.
14:47:44 <Lemmih> Which means writing a C interface to the C++ and then bind the new C code.
14:47:47 <sylvan> Where's info on how to do that? I was under the impression that FFI only deals with C?
14:47:50 <sylvan> ah
14:47:52 <sylvan> figures...
14:48:08 <sylvan> that was my first plan of attack, but writing a C interface to the C++ lib is not something I look forward to doing...
14:48:54 <Lemmih> I'll continue working on Hacanon once I find a decent C++ parser.
14:51:57 <sylvan> hmm.. I'm getting an error trying to build hacanon "unknown field options-ghc"?
14:52:08 <Lemmih> musasabi: (re-64bit operations in GHC) Not too well. The NGC currently can't generated the needed assembly /-:
14:52:10 <sylvan> it's in the .cabal-file at the end
14:52:25 <Lemmih> sylvan: Oh, right. They changed that to 'ghc-options'.
14:52:34 <sylvan> ah ok
14:57:10 <wilx`> Hmm, is it really worth the trouble? I mean having native GHC backends? Doesn't the Haskell -> C -> GCC sequence suffice?
15:00:03 <Lemmih> Isn't it faster and more easily ported than the C backend?
15:01:35 <wilx> I would think it is the other way around.
15:02:52 <wilx> AFAIK GHC works on platforms where it doesn't have native backend...
15:03:13 <Lemmih> (faster as in complication times)
15:03:20 <sylvan> C is a very poor common target, so "in the future" it may be a bottle neck performance-wise... C-- would be a good backend, assuming we get tons of fast compilers for it for different platforms
15:04:28 <wilx> Well, are there optimizing C-- compilers for various platforms?
15:04:45 <sylvan> I don't know...
15:04:59 <wilx> Dunno but it seems like from getting from mud into puddle.
15:05:04 <sylvan> I don't see why it would be a big deal for the gcc folks to implement it
15:06:07 <wilx> Because the GCC folks are imho not interested. I haven't seen a word about C-- on GCC ml in last 4 years that I have been following it.
15:06:14 <sylvan> Optimizing C compilers assume that the code is written in C (like, uses the C stack etc.) but GHC C is not very "typical" and probably isn't optimized as well as hand-written C (or C generated by other more C-like languages)
15:07:05 <wilx> At least I do not remember any.
15:08:09 <lispy> why is C-- a better target than C?
15:08:18 <lispy> probably i should aske "What is C--?"
15:08:58 <lispy> i would just google it but the funny thing about '-' is that it doesn't google
15:09:18 <lispy> http://www.google.com/search?q=-&sourceid=mozilla-search&start=0&start=0&ie=utf-8&oe=utf-8&client=firefox-a&rls=org.mozilla:en-US:official
15:09:19 <paolo> lispy, what about "C--" ?
15:09:40 <wilx> It is assembler, sort of.
15:09:41 <sylvan> lispy: because it's lower level than C so you're not constrained by C's language features
15:09:43 <lispy> same results as C--
15:10:06 <lispy> sylvan: so it's even less intended for humans?
15:10:33 <sylvan> For instance, (IIRC) a function call in Haskell doesn't result in a C function call but rather a "hand made" jump with a custom call stack..
15:11:03 <sylvan> c-- is not intended for humans no.. Just as a common target for different languages, so you only need to write the c-- => asm part for each platform
15:13:29 <lispy> so what generates/compiles c--?  Just ghc?
15:13:46 <kolmodin> sylvan: c-- would also allow arguments in registers instead of on the stack which is harder to do with gcc
15:14:05 <sylvan> lispy: not much atm =) It's fairly new
15:15:07 <wilx> And it is totally ungooglable :)
15:15:08 <paolo> Hello Pseudonym!
15:15:09 <lispy> sylvan: is there a website that has the specification?
15:15:16 <Pseudonym> G'day.
15:15:23 <sylvan> http://www.cminusminus.org/
15:15:26 <Pseudonym> I like "ungooglable".
15:15:32 <lispy> wilx: yeah so they should change the name to accomdate google ;)
15:15:40 <Pseudonym> SeeMinusMinus
15:15:42 <sylvan> @google "c minus minus"
15:15:45 <wilx> lispy, absolutely!
15:15:48 <sylvan> bah
15:15:52 <paolo> @we want lambdabot back
15:16:11 <wilx> Besides, there seems to be some scripting language with the same name.
15:17:50 <wilx> And this C-- really seems to be rather low lever.
15:17:52 <wilx> Err, level.
15:18:04 <sylvan> hmm... so how does cygwin work? =) I want to go to "H:\" and do some stuff but I can't find it =)
15:18:17 <wilx> cd H:/
15:18:23 <sylvan> ah!
15:18:26 <wilx> Or /cygdrive/h/
15:18:36 <sylvan> thought I had to mount it or something.. =)
15:18:40 <lispy> sylvan: does C-- -> JVM?
15:18:46 <sylvan> not sure
15:18:52 <sylvan> there is a native code generator though
15:19:12 <lispy> targeting virtual machines is going to be in high demand in the future
15:19:24 <lispy> at, least i think it is
15:21:40 <wilx> Back to the point, what I am trying to say is that with C you can use C optimizing compilers.
15:22:25 <sylvan> yes, but with "GHC C" the optimizing compiler won't do much good since haskell is "shoehorned" to fit a language which it really has no simliarities too..
15:22:25 <wilx> I seriously doubt that any C-- (if there are even any) can do what todays C compilers can do wrt/ optimization.
15:23:04 <sylvan> I think that if you have a high level language which isn't similar to C, you won't get much use of the optimizing C compiler
15:23:08 <wilx> And since it is really only assembler with weird syntax, GHC will have to do most of the work anyway.
15:23:55 <sylvan> Well you won't have to write code generation for every platform you want your language to run on, that's the win
15:24:02 <wilx> That C doesn't fit as target for Haskell might be the only good point for C--.
15:26:17 <lispy> they should have named in --C
15:26:25 <sylvan> "Compiling" to C is not a good long-term solution though, since you might reach a point where completely viable optimizations are negated because they have to be translated to (ugly) C..
15:26:26 <Beelsebob> hmm?
15:26:33 <Beelsebob> you decrement it before you use it???
15:26:50 <lispy> Beelsebob: yeah, just like it should be ++C
15:26:55 <Beelsebob> hehe
15:27:26 <Beelsebob> except that that should be (C -= 100000)
15:27:36 <Beelsebob> ... because it's so much worse than C
15:27:41 <ndm> hey, C++ is good
15:27:48 <ndm> lots of C's features are horrible
15:27:55 <Beelsebob> *cough* bullshit *cough*
15:28:02 <Beelsebob> (to the first statement)
15:28:04 <ndm> whats wrong with this C code
15:28:08 <wilx> Eh.
15:28:12 <Pseudonym> Every language sucks.  C++ sucks less than most.
15:28:13 * wilx smacks Beelsebob
15:28:26 * Beelsebob hates C++ with a passion
15:28:33 <ndm> f(666);
15:28:34 <ndm> for (int i = 0; i < 10; i++)
15:28:36 <ndm>   f(i);
15:28:41 <ndm> that's valid C++ but NOT valid C
15:28:56 <wilx> Actually, I think it is valid C99 too :)
15:28:59 * Pseudonym thinks Beelsebob should put less emotional investment in hating C++
15:29:00 <sylvan> It's valid C99
15:29:01 <Beelsebob> it is since the latest update to the C standard
15:29:18 <monochrom> awesome
15:29:26 <ndm> yeah, but C99 is only recent - to stay "compatible" most people stick to really old stuff
15:29:40 <wilx> Yeah.
15:29:45 <ndm> basically i mean when hacking WinHugs I can't do that, which is my complaint with C
15:29:45 <wilx> People suck/
15:29:46 <Pseudonym> So is C++03.
15:29:48 <Beelsebob> most of my C++ hatred is down to it's bloated nature... It's nigh on impossible to know the language
15:29:53 <lispy> well, to a point, people dont' write k&r anymore
15:29:55 <wilx> Backward compatibility is overrated.
15:30:12 <wilx> People should use new features more and thus push vendors to implement them.
15:30:14 <Pseudonym> TO stay "compatible", some people even stick to pre-C++98.
15:30:17 <ndm> Beelsebob, but how much Haskell do you know - understand Monads yet ;)
15:30:20 <Beelsebob> bah... my original K&R book isn't here
15:30:43 <Beelsebob> ndm: understanding them and being able to use them are different things ;)
15:30:51 <Beelsebob> and yes, I'm getting there
15:30:54 <ndm> Beelsebob, I can do neither
15:31:16 <Beelsebob> ndm: I would suggest that there are fewer people know the fineries of C++ than know the fineries of Haskell
15:31:32 <Beelsebob> after all, it's only 2 years since there was a compiler capable of dealing with C++
15:31:33 <Philippa> almost certainly true if Haskell = Haskell98
15:31:34 <Pseudonym> I don't think so.
15:31:34 <lispy> effective haskell is all about monads and controlling lazy eval
15:31:35 <ndm> the fineries of C++ are impossible to know in detail
15:31:42 <monochrom> I claim that no one single person knows all of C++.  Each person knows a proper subset only.
15:31:47 <Pseudonym> I think I could name everyone who knows the fineries of Haskell + Glasgow extensions.
15:31:57 <ndm> but when working with a language, everyone uses a subset
15:32:12 <monochrom> Ah ha, but everyone uses a different one.
15:32:14 <Beelsebob> pseudonym: I think I could name everyone who knows the fineries of C++
15:32:21 <Beelsebob> ... and I just did
15:32:26 <Pseudonym> Beelsebob: :-)
15:32:27 <ndm> i use a haskell subset that doesnt have monads (much), no let, lots of other things I have never heard of
15:32:28 <wilx> There is a whole lot of people who know C++ very well.
15:32:38 <Pseudonym> I think I could name a dozen or so who know the fineries of C++.
15:32:48 <ndm> Beelsebob, i know quite a few people who know all of C++
15:32:51 <monochrom> I have friends who can't do templates.
15:32:54 <Pseudonym> You have to remember, though, that C++ is like Bridge.
15:32:56 <wilx> Unfortunatelly there is humungous amount of people who know very few of C++ and still use it :/
15:33:00 <Philippa> ndm: that's a claim you want to be very careful about
15:33:06 <Pseudonym> The rules aren't actually that complicated, though the scoring is.
15:33:09 <Philippa> "all" contains a hell of a lot of fine detail
15:33:17 <Pseudonym> The complications are almost all in the conventions.
15:33:23 <Beelsebob> C++ is horrible to know what it's gonna do
15:33:30 <Pseudonym> The rules of chess are fairly simple, too.
15:33:32 <Beelsebob> hence taking so long to get a complete compiler
15:33:37 <Philippa> Pseudonym: Go, 'nuff said :-)
15:33:43 <Pseudonym> Right!
15:33:44 <Beelsebob> heh
15:33:45 * paolo hugs Go
15:33:45 <Pseudonym> Good example.
15:33:57 * Beelsebob sulks at Go
15:34:02 <Beelsebob> too damn random looking
15:34:05 <lispy> one of the hard things in C++ is resource allocation/deallocation.  I'd say it's actually much harder than in C
15:34:07 <paolo> Go is applied complexity and emergency.
15:34:11 <Philippa> Haskell98 very much resembles at least Chess, I'm not sure I'd attribute it with the power equivalent to Go's complexities
15:34:21 <wilx> Huh, lispy, how come?
15:34:21 <Pseudonym> lispy: I disagree strongly with that.
15:34:27 <cjb`> Ooh, Go conversation.  I knew there was a reason I joined this channel earlier.
15:34:29 <wilx> It would say the oposite.
15:34:32 <Philippa> lispy: er, WTF?
15:34:34 <lispy> point me at someone who knows all the intricaties of resource management in C++ and I will be impressed
15:34:39 <Pseudonym> Although if you say that C++ does not include Boost, you might have a point.
15:34:45 <Beelsebob> philippa: I think the computer language equiv of Go is Brainfuck
15:34:45 <paolo> Philippa, we don't play Go from much time :-)
15:34:50 <Beelsebob> very simple rules
15:34:53 <Beelsebob> imposible to do
15:35:00 <cjb> paolo: Do you play too, then?  :)
15:35:11 <lispy> I do not include boost, since it's not part of the standard
15:35:15 * cjb has been fairly constantly addicted to Go for about 18 months.
15:35:23 <paolo> Beelsebob, not completely, in Go you build something at some point - in bf you remain in the mess at every given time :-P
15:35:27 <paolo> cjb, yup!
15:35:32 <Pseudonym> Then to be fair, when judging Haskell, you shouldn't include FiniteMap.
15:35:32 <paolo> @wiki HaskellGoPeople
15:35:32 <Philippa> nah, Go has at least some rules that involve a useful construct beyond the position/stone level
15:35:34 <Beelsebob> paolo: true
15:35:36 <Pseudonym> Or System.IO
15:35:46 <Pseudonym> Or any of the standard stuff we all use.
15:36:05 * Pseudonym finds Haskell pretty useless without FiniteMap
15:36:08 <lispy> Philippa: for example, if you allocate memory in a constructor more than oncee, you could be created a potential memory leak
15:36:11 <Philippa> the hierarchical libs are "more standard" than Boost though
15:36:22 <Beelsebob> my favorite go rule is that the board must never be in the same state twice... like you can remember *g*
15:36:27 <Philippa> lispy: of course, just like if you did it in the C equivalent
15:36:45 <lispy> Philippa: it's more complicated in C++ tho
15:36:50 <monochrom> It is very easy to remember! :)
15:36:56 <Philippa> lispy: in what way?
15:36:58 <kosmikus> SyntaxNinja: ping
15:37:01 <cjb> Beelsebob: That's not actually a rule in most rulesets.
15:37:04 <lispy> Philippa: and understanding *why* it's a problem in C++ is even more difficult
15:37:21 <Philippa> Beelsebob: it's not too critical insofar as breaking it just leads to boredom
15:37:22 <cjb> The rule is against immediate repetition (ko).  Superko is a somewhat ancient Japanese rule, and has many opponents.
15:37:29 <Beelsebob> philippa: heh
15:37:37 <paolo> cjb, do you play Go too?
15:37:38 <lispy> Philippa: because if a class fails to instantiate then the language builtin ways of deallocating are not used properly
15:37:39 <Philippa> Superko makes a good social convention though
15:37:40 <monochrom> w00t!  Superko!
15:37:41 <Pseudonym> I've never had a problem with leaking constructors in C++
15:38:01 <Pseudonym> Mind you, I learned C++ _after_ "Effective C++".
15:38:19 <Pseudonym> So I know about managed pointers.
15:38:21 <sylvan> In my experience C++ is just empirically a worse language than C... For the simple reason that bugs are way more abundant in programs written in C++.. Not very scientific, but still..
15:38:23 <wilx> Hmm, I think he means that if you allocate two things and the second new throws then you leak the first chunk.
15:38:30 <paolo> cjb, add yourself here if you want :-) <http://haskell.org/hawiki/HaskellGoPeople>
15:38:39 <wilx> That can be taken care of by some smart pointer.
15:38:44 <Pseudonym> sylvan: No, it's not very scientific.
15:38:53 <Pseudonym> I claim that most C++ programs are more ambitious than most C programs.
15:38:57 <cjb> I'm not enough of a Haskell person yet.  :)  Looks like we're somewhat similar strengths -- I'm Kosai on KGS.
15:39:23 <wilx> Pseudonym, ambitious?
15:39:25 <sylvan> I think it's hard to reason about languages scientifically, but C++ is just so complicated and bloated that people mess up all the time...
15:39:27 <Pseudonym> Yes.
15:39:30 <Pseudonym> They cover a larger scope.
15:39:37 <sylvan> I disagree!
15:39:37 <Pseudonym> They do more to begin with.
15:39:53 <sylvan> See: Unix
15:39:55 <sylvan> =)
15:39:57 <paolo> cjb, I'll put you on my Friend list (or whatever is called) as soon as I install CGoban2 here :-)
15:40:02 <Pseudonym> How many LOC in Unix?
15:40:07 <cjb> :)
15:40:08 <Philippa> sylvan: see a pile of little programs together, you mean?
15:40:11 <cjb> Pseudonym: Which one?
15:40:22 <sylvan> Well, GTK, or just about every program written pre C++
15:40:41 <Pseudonym> cjb: Pick one.  Kernel only.
15:41:00 * Beelsebob hits Obj-C
15:41:09 <Beelsebob> stupid super-weak-typing
15:41:12 <Pseudonym> And not Linux.  That's not typical.
15:41:29 <wilx> Well, Gnome?
15:41:34 <Pseudonym> (A relatively small proportion of the Linux source code is compiled into a typical kernel.)
15:41:39 <cjb> Pseudonym: Linux 1.2 was 310950.  I don't think it's fair to count newer releases.
15:41:51 <cjb> 310950 LoC, that is.
15:42:31 <sylvan> BSD 4.4 was about 202K
15:42:53 <Pseudonym> Hmmm.
15:43:02 <Pseudonym> GCC is bigger than that.
15:43:14 <Pseudonym> Actually, binutils is bigger than that.
15:43:18 <cjb> Which part of GCC?
15:43:32 <sylvan> Quake3 is written in C.. Probably at least 500K
15:43:41 <Pseudonym> Even glibc is bigger than that.
15:43:48 <Pseudonym> Mozilla is about 1.3MLOC of C++.
15:43:53 <Philippa> I'd be surprised if Q3's 500K, Q1 was an order of magnitude less
15:43:57 <Pseudonym> Plus a further 700KLOC of C.
15:44:09 <sylvan> Q3 is an order of magnitude more complex =)
15:44:13 <Philippa> no it's not
15:44:22 <sylvan> sure it is.. The shader system, for instance
15:44:45 <Philippa> is all neatly wrappable, and shouldn't take more than 10K
15:44:48 <Beelsebob> sylvan: that's al done at ASM level in Q3
15:44:48 <lispy> doesn't Q3 use a lot more 'off the shelf' sort of stuff?
15:45:10 <Beelsebob> because it's at the time when ther was no HOL for shader models
15:45:17 <Philippa> um, no
15:45:24 <Philippa> it's not a hardware shader model at all
15:45:30 <Beelsebob> really?
15:45:31 <Beelsebob> :o
15:45:31 <Philippa> it predates all that
15:45:35 <sylvan> Beelsebob, they had their own shader language
15:45:42 <Beelsebob> nah... my GeForce 3 predated Q3
15:45:48 <sylvan> which compiled down to stages and regular ole' fixed function pipeline calls
15:45:52 <Beelsebob> and that had shader support
15:46:01 <sylvan> Q3 ran on Voodoo1 though =)
15:46:07 <Philippa> yeah. Fucking awfully :-)
15:46:08 <Philippa> (BTDT)
15:46:11 <Beelsebob> heh... indeed
15:47:11 <sylvan> anyway, I don't really think it's fair to say C++ projects are more ambitious
15:47:41 <cjb> Incidentally, I wonder whether it's harder for someone who knows Haskell to learn Go than it is for someone who knows Go to learn Haskell.  :)
15:47:47 <sylvan> even so, the bugs/LOC ratio seems to be higher for C++ projects, in my experience
15:47:47 * Philippa suspects Q3's GL-only renderer is actually simpler than Q1's software renderer, FWIW
15:48:01 <Philippa> no fine culling, for example
15:48:08 <cjb> Since I seem to be in the latter position.  I suppose Go has fewer prerequisites, unless you think that lambda calculus is explained as intuitively as the Go rules.
15:48:21 <Pseudonym> sylvan: Well I disagree.
15:48:23 <sylvan> Phillippa: most of it is pretty much the same. Like the BSP-PVS stuff
15:48:33 <Pseudonym> Certainly taken over history.
15:48:47 <Pseudonym> Perhaps the problem is that a lot of dumb programmers use C++ these days.
15:49:09 <Philippa> yeah, but consider the crap involved in writing your own rasteriser?
15:49:11 <Pseudonym> If the same dumb programmers used C instead (like they used to), then perhaps there would be more bugs in C code than in C++.
15:49:12 <Philippa> I've seen that code
15:49:26 <Pseudonym> Oh, I have bad memories.
15:49:26 <sylvan> I'd concede to this: For a very skilled programmer, C++ is probably better than C. However, in the real world you have to accept that a lot of the programmers won't be very skilled, and it's easier (IMO) to mess up (as in "doh, didn't think of that little quirk") in C++
15:49:30 <Philippa> the .mdl models had a weird renderer
15:49:32 <Pseudonym> Writing rasterisers.
15:49:47 <lispy> Pseudonym: i've seen research to support that claim
15:49:47 <Pseudonym> Getting it working is easy.  Getting it robust is VERY difficult.
15:49:58 <lispy> Pseudonym: (referring to the dumb coders)
15:50:05 <Pseudonym> lispy: Interesting.
15:50:30 <Pseudonym> OK, so what you're saying is that C is a more drool-proof language.
15:50:38 <Pseudonym> There might be something in that.
15:50:39 <sylvan> It's just smaller and "neater"...
15:50:42 <_deepfire> as a high-level language C++ sucks anyway
15:50:45 <Philippa> C++ needs tight coding standards
15:50:47 <sylvan> Easier to know when you have to tread cautiously
15:50:51 <lispy> Pseudonym: it basically says that out of the languages they studied the different between programmers was a better predictor than language choice.
15:50:52 <_deepfire> while C does a decent job of a portable assembler
15:51:22 <Pseudonym> I can buy the argument that it's possible to make fewer mistakes in C because C slows you down.
15:51:39 <Pseudonym> Kind of like the urban legend about the QWERTY keyboard.
15:51:45 <paolo> hah!
15:52:05 <paolo> Pseudonym, you should read the dvorak zine <http://dvzine.org/>.
15:52:07 <lispy> so if we use QWERTY and C we'll have less errors than if we use dvorak and C++ ?
15:52:07 <sylvan> Nah! More like it doesn't have tons of fancy features thrown in that most people aren't really 100% capable of using
15:52:22 <lispy> sylvan: exactly
15:52:27 <Philippa> with C you'll never get burnt by a pile of implicit conversions you weren't expecting
15:52:38 <Pseudonym> You know, most people aren't 100% capable of using Haskell.
15:52:40 <sylvan> People shouldn't use C or C++, there are plenty better languages out there...
15:52:53 <_deepfire> C has its niche, though
15:52:57 <Pseudonym> OK, I do agree that the implicit conversion in C++ are a serious problem.
15:52:58 <sylvan> Pseudonym: But Haskell is a _safe_ language! So they don't have to be!
15:53:08 <_deepfire> portable assembler
15:53:16 <Pseudonym> sylvan: They do if they have to work in a team.
15:53:20 <Philippa> when people aren't 100% capable of using Haskell, they tend to end up with code that doesn't even compile, or else very clearly doesn't do the right thing
15:53:20 <lispy> sylvan: but the machine code generated by C/C++ has characteristics that are attractive to people.
15:53:22 <Pseudonym> I defy a Haskell newbie to understand any of my code.
15:53:22 <sylvan> _deepfire: It's not even good for that
15:53:33 <Philippa> C++ code often breaks in a comparatively quiet way
15:53:35 <Philippa> heh
15:53:49 <paolo> I was thinking what Philippa said :-)
15:53:52 <Philippa> some of my code's pretty newbie-friendly. The bits that aren't are because the system being described is complex
15:53:52 <sylvan> =)
15:53:54 <_deepfire> sylvan, probably it is not perfect but i do not quite know anything better
15:53:56 <Pseudonym> sylvan: OK, I agree with you that there are better languages.
15:54:10 <Pseudonym> I reckon Ada is better than either C or C++, but it's at least as complex as C++.
15:54:24 <sylvan> _deepfire: You missed this discussion by about 20 minutes.. c-- came up..
15:54:31 <sylvan> www.cminusminus.org
15:54:41 <wilx> Huh.
15:54:45 <lispy> Pseudonym: i could be mistaken, but I like to think that as a learn a language my code becomes easier to read because i write things in a way that is more consistent with the language.
15:54:54 <wilx> Implicit conversion in C is way worse than in C++.
15:55:16 <Pseudonym> lispy: Yes, I agree with that.
15:55:28 <Pseudonym> wilx: You've obviously not been bitten by non-explicit constructors.
15:55:38 <wilx> I wasn't :D
15:55:40 <Philippa> implicit conversion in C will never cause you to accidentally do IO
15:55:45 <wilx> I know what I am doing :D
15:55:50 <sylvan> wilx: I look at it like this. An unsafe fairly low-level language is shaky. But using that language to build a complex high-level language is a disaster waiting to happen. So the "unsafeness" explodes to way bigger proportions in C++
15:56:00 <Pseudonym> Most C++ luminaries (of which I am not one) will agree that the implicit conversions are a mistake.
15:56:10 <Pseudonym> Like export.
15:56:34 <Philippa> I used to like them for a short while, when I was trying to implement small DSLs. Then I realised how those DSLs behaved in the larger language and vomited
15:56:45 <Philippa> (I wasn't quite thinking in terms of DSLs, but pretty close)
15:57:17 <wilx> Philippa, accidental IO? I would like to see an example of that :)
15:57:32 <Philippa> wilx: implicit conversion calls a constructor which does some IO
15:57:43 <wilx> Ah.
15:57:59 <wilx> Well, I haven't seen many such classes.
15:58:28 <Philippa> me either. But the mere possibility is pretty scary, especially when you're waving things that might be converted to a string around things that might take a string as a filepath
15:58:47 <Philippa> somebody who decided they wanted classes that behaved in a perl-like manner could create a real mess
15:59:03 <wilx> Driving car is dangerous too.
15:59:06 <Pseudonym> Point taken, but I think that says more for Perl programmers.
15:59:11 <wilx> One has to know who one is doing.
15:59:12 * Pseudonym used to be one, he knows
15:59:27 <wilx> s/who/what/
15:59:39 <Pseudonym> Having said that, in C++, resources tend to be held by objects.
15:59:45 <lispy> wilx: it's true the other way too, what with all the diseases in the world ;)
15:59:49 <Pseudonym> So creating an object can acquire a resource.
16:00:21 <Pseudonym> But I think that's rare.  I don't think I've ever seen anyone accidentally acquire a resource via an implicit conversion.
16:00:41 <Pseudonym> And I've seen a LOT of C++ mistakes.
16:00:42 <lispy> what about memory?
16:00:48 <Philippa> wilx: that, and be aware that everybody else involved is a potential nutcase. The analogy holds, I guess :-)
16:00:59 <wilx> :)
16:01:21 <Pseudonym> I don't include memory as a "resource" here.  Philippa was talking about I/O.
16:01:42 <wilx> I know that C++ has some dark corners but I think it is one of the best languages evah!
16:01:46 <wilx> Seriously.
16:02:01 <Pseudonym> I think that C++ has hit a sweet spot that no other language has hit.
16:02:05 <Pseudonym> With the possible exception of Ada.
16:02:51 <wilx> I know no other language that has destructors with such semantics as C++ destructors do. Absolutely ideal for releasing resources.
16:03:01 <Pseudonym> Ada does, IIRC.
16:03:20 <lament> by "sweet" you of course mean "horrible, evil, dark"
16:03:22 <Philippa> from what I've heard, yeah
16:04:04 <Philippa> destructors are good. Their lack's one of the few issues I can really find with the hypothetical "better C than C" strict regioned FPL I've been toying with as an idea
16:04:09 <wilx> Hm, what I remember about it I think it doesn't. You either have "managed" memory and GC works for you or you have to release stuff by yourself.
16:04:11 <wilx> Not sure though.
16:04:32 <Pseudonym> Destructors and exceptions I think are the two "killer features" in C++.
16:04:43 <Pseudonym> Which is one of the reasons that Qt annoys me.
16:04:48 <Pseudonym> It doesn't play nice with exceptions.
16:05:06 <Pseudonym> And it doesn't have a compiler-checked ownership semantics.
16:05:17 <Pseudonym> But that's another gripe.
16:06:55 <wilx> I have never worked with it. What kept me from trying was that it requires me to use some kind of preprocessor. At least that is what I heard.
16:07:26 <Philippa> yeah, it does
16:07:36 <Pseudonym> Yes, which is seriously annoying.
16:07:40 <cjb> Does anyone use a non-conventional keyboard here?  Thinking about getting a Touchstream.
16:08:06 <Pseudonym> I've written C++ and Haskell code using Palm Pilot grafitti.  Does that count?
16:08:37 <paolo> I wrote brainfuck on a rock.
16:08:48 <cjb> Heh.
16:08:53 <lament> Pseudonym: OUCH
16:09:11 <Pseudonym> Needless to say, I used a LOT of shortcuts.
16:09:11 <lament> you are a true fanatic
16:09:29 <Pseudonym> No, I just don't have a laptop.
16:10:07 <paolo> :(
16:13:34 <wilx> I am so eager to see the next C++ standard. I which of the many proposals are going to make it into the standard.
16:13:59 <lament> do people care about new c++ standards?
16:14:32 <wilx> Heh, what kind of question is this?
16:14:34 * cjb just bought a new laptop.
16:14:51 <lament> wilx: well, nobody cares about C99
16:14:51 <Pseudonym> Yes, we care so that in five years time, when all of the compilers support them, we can use them!
16:14:54 <wilx> People who know C++ well do care.
16:15:24 <wilx> lament, that is a chicken and egg problem.
16:15:37 <wilx> People would use all the C99 features if there were compilers.
16:15:44 <lament> so the situation with C++ is different?
16:16:16 <wilx> We'll see.
16:16:23 <wilx> There is no new standard yet.
16:16:25 <lament> heh
16:16:50 <wilx> But there is a lot of very interesting proposals.
16:24:36 <Beelsebob> mmm... pizza bread and salsa
16:37:25 <paolo> Hi dons, Heffalump.
16:38:55 <dons> morning.
16:39:14 <dons> btw, lambdabot will be back once someone gets to uni and turns on my machine
16:45:09 <Beelsebob> heh
16:58:05 <lispy> dons: w00t!
16:58:10 <lispy> dons: that's good news
16:58:32 <paolo> lispy, run to his uni!
16:58:45 * lispy takes off at a break-neck pace
16:58:59 <lispy> wait, how will I get downunder?
16:59:16 <dons> you in the US? the flight from LA is only 15 hrs ;)
16:59:41 <lispy> dons: i can drive to LA from here in 6
16:59:58 <dons> well, only 21 hrs to wait then! see you soon
17:00:00 <lispy> then 2 hour checkin for an international flight
17:00:05 <ehuber> hello...
17:00:07 <ehuber> i came to confirm a rumor..
17:00:17 <SyntaxNinja> ehuber: it's true
17:00:28 <ehuber> i was told by a friend that in haskell, as in all functional programming languages, the concat operator (++) is O(n)
17:00:29 <lispy> ehuber: don't listen to SyntaxNinja, it's a lie
17:00:30 <paolo> Indeed.
17:00:34 <ehuber> is this true for haskell ?
17:00:55 <lispy> ehuber: for the builtin list yes
17:01:01 <ehuber> okay
17:01:06 <ehuber> that sort of sucks
17:01:08 <lispy> ehuber: for some other wacko list implementations it's better
17:01:12 <paolo> Testcase: [0] ++ [1..]
17:01:30 <lispy> paolo: that one is okay
17:01:38 <lispy> paolo: but maybe that's your point
17:01:44 <dons> difference lists have O(1) append
17:01:52 <ehuber> ??
17:01:53 <lispy> paolo: or do i have it bacwards again
17:02:03 <ehuber> so is it O(n) or O(1) ?
17:02:13 <lispy> ehuber: it's actually just linear in the size of one of the lists, i think linear in the first list
17:02:55 <ehuber> yeah that would make sense
17:02:58 <ehuber> okay.. so its linear..
17:03:13 <ehuber> it's actually faster to use cons and then reverse the list..
17:03:16 <ehuber> kind of silly..
17:03:21 <dons> I think dlists would count in the "wacko" list category, I think.
17:03:38 <lispy> ehuber: that's not always true
17:04:02 <lispy> ehuber: if i understand what you mean then woludn't paolo's example run forever?
17:05:07 <lispy> ehuber: another thing to consider here is that since haskell is lazy, it may not need to complete the concatenation
17:05:22 <lispy> ehuber: so it's really sub O(n)
17:05:43 <lispy> well, it's sometimes better than linear
17:05:50 <lispy> i never can say this stuff correctly ;)
17:06:10 <ehuber> okay
17:06:27 <ehuber> well, ill use cons and reverse the list ;)
17:06:51 <Pseudonym> In all decent programming languages, (++) is amortised constant time.
17:07:02 <Pseudonym> Haskell included.
17:07:16 <ehuber> okay
17:07:20 <ehuber> so it is O(1)
17:07:22 <ehuber> lol..
17:08:57 <Pseudonym> Sure.  It does, however, increase the constant factor of accessing elements of the list later.
17:10:29 <ehuber> okay. i'm not all that concerned about performance I suppose.
17:11:57 <dons> Psedudonym, snowing today?
17:12:42 <Pseudonym> Not out our way.
17:12:51 <Pseudonym> I've heard reports, though.
17:14:06 <dons> yeah, I heard something on the radio about snow
17:31:50 * paolo $ head xs_ 
17:34:05 <paolo> Goodnight folks!
17:36:04 <metaperl> would someone mind thinking me through a function to search and replace the first occurrence of a string within a string, ie. subst search replace str
17:36:16 <ehuber> mm..
17:36:39 <metaperl> the top-level description is substr search replace str = pre ++ sub ++ post
17:37:07 <ehuber> sorry, too stupid with haskell still (:
17:37:10 <metaperl> where sub is the inlining of replace within str at the proper point if it exists
17:37:17 <metaperl> ehuber: that's ok. thanks for your interest
17:38:14 <CosmicRay> metaperl: would you be happy with one that uses regexps?
17:40:28 <metaperl> CosmicRay: no, I'm doing this for SJT's book
17:40:53 <metaperl> I could do it with regexps... though it's funny how I never think of such solutinos when using haskell though I would not hesitate to do it in Perl
17:40:57 <dons> metaperl, break the list at the right spot, then splice
17:41:23 <metaperl> dons: is my top-level description accurate? subst search replace string = pre ++ sub ++ post
17:41:32 <metaperl> and it's just a matter of describing pre, sub, and post
17:41:46 <metaperl> where sub is conditional on finding search within string
17:42:27 <dons> @type Text.Regex.subRegex
17:42:35 <dons> oh, right. no lambdabot :/
17:42:57 <CosmicRay> oh right, I forgot that went into fptools.
17:43:06 <dons> Text.Regex.subRegex :: Text.Regex.Posix.Regex
17:43:07 <dons>                        -> String
17:43:07 <dons>                        -> String
17:43:07 <dons>                        -> String
17:43:20 <dons> metaperl, where: subRegex regexp inp repl = ...
17:43:20 <CosmicRay> source for that is in missingh, I think they used it verbatim in fptools
17:43:33 <dons> looks like it.
17:44:09 <CosmicRay> but let's say you wanted a simple, naive algorithm to do the one replacement that the example calls for.
17:44:24 <CosmicRay> I'd recurse over the string, dropping the first character on each recursion
17:44:25 <shapr> cjb: I have a Kinesis contoured, and I love it.
17:44:43 <cjb> shapr: Oh, cool.
17:44:48 <CosmicRay> then I'd compare the first (length search) characters to (search).  If they're the same, I'd return (replace ++ xs)
17:44:56 <shapr> Neat, Oleg wrote a TMR article!
17:44:57 <CosmicRay> otherwise return x:self xs
17:45:33 <CosmicRay> metaperl: how would you do it in perl, without using regexps?
17:45:41 <shapr> Ok, now I want enough articles to release Issue Five.
17:45:42 <dons> is 'search' just something to use isPrefixOf with?
17:45:54 <shapr> dons: TMR article?
17:46:09 <shapr> Pseudonym: TMR article?
17:46:21 * dons ducks for cover
17:46:24 * shapr grins evilly
17:46:33 <metaperl> CosmicRay: i would    use regexps in Perl
17:47:02 <CosmicRay> metaperl: well then, you could just use subRe in haskell and be done with it ;-)
17:47:20 <metaperl> no, like I said: this is for SJT's book problem... he hasnt introduced that yet
17:47:34 <CosmicRay> and he won't, because it wasn't in fptools when the book was written
17:47:45 <metaperl> thanks for your algorithm ... I'm going to hack a bit in the fashion you described
17:47:50 <metaperl> CosmicRay: what is fptools?
17:47:53 <CosmicRay> but what I'm saying is, think about how you could do it without regexps in perl
17:48:03 <metaperl> CosmicRay: that is painful
17:48:08 <shapr> conal: Want to write an article for The Monad.Reader?
17:48:08 <CosmicRay> metaperl: fptools is the CVS repository that houses GHC and the library that it, as well as hugs and nhc98, ship with
17:48:13 <CosmicRay> Data.List, for instance, is part of fptools
17:48:16 <metaperl> CosmicRay: I would use state variables n Perl
17:48:24 <dons> and haddock, happy, alex and more!
17:49:05 <conal> shapr: do you have anything in mind?
17:49:30 * CosmicRay disappears for 10 minutes to adjust the lawn sprinkler, currently threatening to spray inside the window
17:49:49 <shapr> conal: Write about something you know and enjoy?
17:50:28 <conal> brb
17:50:45 <shapr> I think I'll write an intro to HUnit and QuickCheck.
17:51:58 <shapr> That sounds like something I can finish without getting distracted. (yeah right)
17:51:58 <dons> shapr, QuickCheck too?
17:51:58 <dons> QuickCheckM
17:51:59 <shapr> It's hard to write a decent intro to QuickCheckM.
17:51:59 * dons wants to test big ole monadic yi.
17:51:59 <shapr> I don't think I understand it well enough yet. I'd have to write some of the nifty model spec tests and etc.
17:52:21 <shapr> Thing is, QuickCheckM doesn't handle IO, and it's not easy to extend it to do so.
17:53:12 <dons> oh, I didn't know that.
17:53:12 <shapr> You can use unsafePerformIO, and I did, but then it looked like the original QuickCheck with unsafePerformIO.
17:53:17 <dons> yep.
17:53:42 <dons> so that's how i'll do yi then, it seems. no worries
17:53:42 <shapr> It's frustrating to have monadic QuickCheck that doesn't handle IO.
17:57:24 <shapr> dons: Maybe you can find an easy way to do IO testing? Have you read QuickCheckST.ps.gz ?
18:00:31 <shapr> Funny how it gets quiet when I start asking for TMR articles ;-)
18:00:54 <shapr> Heffalump: Want to write about your Perl binding for TMR?
18:01:32 <syntax_and_the_j> should I learn Scheme/Lisp before Haskell?
18:05:55 <stepcut> syntax_and_the_j: no
18:07:04 <gzl> syntax_and_the_j: no
18:07:57 * CosmicRay returns
18:09:39 <conal> shapr: back.  i'll see if i get inspired about a TMR article.
18:13:49 <mebaran151> what are the big differences between haskell and ocaml
18:13:57 <mebaran151> I am debating which one to take up
18:18:19 <metaperl> CosmicRay: thanks for the solution. Here it is: http://sequence.complete.org/node/82
18:18:37 <metaperl> mebaran151: Haskell is a pure functional language. 100% ocaml is not
18:19:07 <metaperl> ocaml tends to be lightning fast... haskell can be compiled to good speed but usually slower than ocaml.
18:19:11 <metaperl> haskell is a lazy language
18:19:28 <CosmicRay> metaperl: nice
18:19:32 <metaperl> bear in mind you are talking to a Haskell amateur :)
18:20:09 <metaperl> CosmicRay: thanks
18:20:47 <metaperl> mebaran151: both languages offer type inferencing
18:21:03 <metaperl> mebaran151: SML is closer to Haskell in purity, but still not a pure functional language
18:21:09 * CosmicRay has to afk for the evening
18:21:12 * dons goes to teach a perl class  (and sed!)
18:21:17 <liyang> mebaran151: try Haskell first. Caml will be trivial to pick up afterwards. The O' bit will take a little more reading.
18:22:05 <mebaran151> liyang, the O is for object oriented right?
18:22:10 <mebaran151> I know Ruby pretty well
18:22:11 <liyang> mebaran151: *nod*
18:22:18 <mebaran151> and I am decent at C++
18:22:27 <mebaran151> so I think I am good with O so far
18:22:53 <mebaran151> I was looking for a language to expand how I think about programming, something witha completely different slant
18:23:07 <liyang> mebaran151: There are lots of good books on Haskell.
18:23:10 <mebaran151> too bad the ocaml channel is so .. empty
18:23:20 <mebaran151> does ti have gtk bindings
18:23:31 <liyang> I started on Paul Hudak's book.
18:23:31 <metaperl> haskell has gtk2hs
18:23:52 <mebaran151> hmmm?
18:23:55 <metaperl> liyang: I'm using SJT's but I have Hudak's book "School of Expression"... how do you like it? I like SJT's book quite a bit
18:24:15 <metaperl> mebaran151: what are you confused about?
18:24:20 <liyang> (Though I guess I'm contractually obliged to plug http://www.cs.nott.ac.uk/~gmh/book.html too.)
18:24:27 <mebaran151> just wondering which one to pick up first
18:24:31 <mebaran151> Ocaml or Haskell
18:24:37 <metaperl> Haskell took 1st and 2nd place in the ICFP programming contest last year
18:24:42 <mebaran151> figuring which one will be more useful in the long run
18:24:51 <mebaran151> I was looking for something to shake my OOP roots
18:24:58 <metaperl> mebaran151: how old are you and what are you doing now?
18:25:01 <mebaran151> eh
18:25:04 <mebaran151> 18
18:25:07 <metaperl> mebaran151: what have you programmed in before?
18:25:08 <mebaran151> going to college
18:25:09 <liyang> metaperl: I've never really read any other book... I have (and read) the old 1990(?) edition of Bird and Wadler.
18:25:15 <mebaran151> Ruby and some C++
18:25:22 <mebaran151> I can do Ruby pretty well now
18:25:36 <mebaran151> but that is all about objects, even moreso than python
18:25:36 <metaperl> I love Haskell... you will need to buy a good Haskell book though. The free resources are poor
18:25:46 <metaperl> mebaran151: you will love Haskell type classes
18:25:46 <mebaran151> metaperl, yeah, that's why I came here
18:25:55 <mebaran151> I was also looking for something closer to SQL
18:26:01 <liyang> O'Caml still feels like imperative programming at times.
18:26:12 <mebaran151> the marriage of objects and sql is less than exemplary
18:26:15 <liyang> So I'd go for Haskell. ;)
18:26:17 <metaperl> yes Ocaml is a pragmatic language... it's not a brain-stretcher like Haskell
18:26:25 <mebaran151> oh that'snice
18:26:28 <metaperl> mebaran151: Qt does a good job of that
18:26:31 <mebaran151> but can I be productive relatively quickly
18:26:39 <mebaran151> dont like the license of Qt
18:26:46 <mebaran151> I like to share my programs with my friends
18:26:51 <mebaran151> and Qt makes that kind of hard
18:26:58 <metaperl> I dont think I will be writing useful Haskell code for at least 1 year from now
18:27:03 <metaperl> but i'm having fun learning
18:27:08 <metaperl> liyang: do you like the Hudak book?
18:27:08 <lament> heh @ "ruby is all about objects, moreso than python"
18:27:26 <mebaran151> lament, everything is an object
18:27:36 <shapr`> yow!
18:27:44 <liyang> metaperl: yup. It was easy enough to go through.
18:27:44 <mebaran151> even classes, right down to the syntax
18:28:02 <lament> yeah, sort of like in Python
18:28:02 * metaperl never understood Ruby's yield
18:28:07 <mebaran151> metaperl, oh
18:28:11 <liyang> metaperl: thing is, I can't really compare it with any other book...
18:28:11 <mebaran151> yield is easy
18:28:19 <mebaran151> it took me a second until I found a really beginners book
18:28:25 <mebaran151> it just takes the attached object
18:28:29 <mebaran151> blcok
18:28:31 <mebaran151> and runs it
18:28:31 <metaperl> I'm a professional Perl programmer.. if the word professional and perl should be in the same sentence :)
18:28:57 <lament> ruby has some weird syntax shortcuts
18:29:04 <lament> yield is one of those :)
18:29:30 <mebaran151> lament, yeah
18:29:39 <mebaran151> I think it is the Japanese
18:29:58 <lament> i think it is the Perl :)
18:30:02 <mebaran151> my Japanese friend mentioned that the word block and yield are somehow similar
18:30:06 <mebaran151> but I cant verify it
18:30:16 <mebaran151> lament, yep, Perl could do it
18:31:07 <lament> anyway if you want to learn something really absolutely crazy and weird, haskell is your best bet.
18:31:20 <mebaran151> Haskell is based on lambda calculus right
18:31:27 <liyang> I don't think Haskell is really absolutely crazy and weird...
18:31:44 <mebaran151> so it is kind of the flipside of the Turing ideology?
18:31:55 <mebaran151> should I use hug or ghc
18:32:02 <liyang> mebaran151: er... what languages are based on the Turing machine? o.O
18:32:19 <lament> you could argue that brainfuck is similar
18:32:22 <liyang> (I know. I mean, languages in general use.)
18:32:27 <liyang> XD
18:32:54 <mebaran151> could argue anything imperative is based on Turing
18:33:01 <mebaran151> from a purely mathematical standpoint
18:33:04 <lament> hm
18:33:06 <monochrom> Turing machines don't need a bloody language.  You just, like, wire up your state machine by hand.
18:33:08 <lament> could you really?
18:33:17 <lament> not really
18:33:17 <mebaran151> but you'd have to get someone much better qualified than I to do the arguing
18:33:20 <liyang> mebaran151: play with hugs first. When you find that it doesn't do what you want it to do, switch to ghc.
18:33:41 <lament> I found what hugs didn't do what ghc did in the first 30 seconds of using it.
18:33:43 <mebaran151> the only thing I notice is that ghc is very very large
18:33:54 <mebaran151> hugs supplies a shell though right?
18:34:03 <lament> (defining your own functions in the interactive interpreter)
18:34:12 <mebaran151> I love the idea of a programming shell where I can throw my ideas out
18:34:13 <mebaran151> yeah
18:34:15 <mebaran151> exactly
18:34:32 <liyang> lament: heh. Fair enough.
18:35:56 <shapr> yargh
18:36:14 <mebaran151> but if takes so long to take it up, what can it do
18:36:47 <mebaran151> I like to feel a little productive at what I'm doing, y'know?
18:37:25 <Pseudonym> Hey, where's lambdabot?
18:37:34 * Pseudonym must have missed something
18:38:42 <lament> 16:40 <dons> btw, lambdabot will be back once someone gets to uni and turns on my machine
18:41:29 <mebaran151> hehe, lament
18:41:45 <TheHunter> I took that as a "probably not anytime soon" and started a replacement lambdabot_, just make it @quit when it's no longer needed.
18:42:52 <mebaran151> where does lamdbabot get its answers
18:43:32 <lambdabot_> I will take over!
18:43:42 <lambdabot_> The pretender will be off permanently
18:43:51 <lament> oh no
18:44:07 <lament> will it become mandatory to attach an underscore to one's nick, as a sign of loyalty?
18:44:20 <lambdabot_> That will not be necessary.
18:44:35 <lambdabot_> A simple grovel every now and then will suffice.
18:46:26 <mebaran151> lambdabot_, what do you do
18:54:33 <mwc> Hullo dcoutts_
18:54:43 <mwc> Got the 0.9.9 darwinports package done and good
19:12:53 <TheHunter> why does freenode kick lambdabot_ all the time?
19:13:53 <mwc> TheHunter: probably all you clowns @mooing
19:14:06 <mwc> causes lambdabot_ to be deeped a flooder
19:14:15 <mwc> either that or it's on a wonky connection
19:14:32 <TheHunter> i've implemented flooding protection.
19:14:55 <TheHunter> also, the connection is perfect, lamdabot_ is on the same box as me.
19:16:25 <mwc> Maybe a bug in the haskell network libraries? Looks like a network timeout
19:17:31 <TheHunter> the connection should be handled by the os.
19:17:57 <TheHunter> i'm getting "runIRC: caught exception: <socket: 5>: hGetChar: timeout (Connection timed out)" here too.
19:18:07 <Korollary> TheHunter: did you try another irc network ?
19:18:37 <TheHunter> Korollary, yes, maybe that's it.
19:18:52 <TheHunter> will try clarke.freenode.net
19:20:46 <Korollary> TheHunter: I actually meant efnet, etc.
19:20:59 <TheHunter> lambdabot_, @quit
19:50:53 <dons> @yow
19:50:54 <lambdabot> WHOA!!  Ken and Barbie are having TOO MUCH FUN!!  It must be
19:50:54 <lambdabot> the
19:50:54 <lambdabot> NEGATIVE IONS!!
19:51:09 <dons> @version
19:51:10 <lambdabot> lambdabot 3p67, GHC 6.5 (OpenBSD i386)
19:51:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:56:06 <ehuber> yawn
20:27:30 <monochrom> I look for a way to catch an exception thrown by say Control.Exception.throw.  Apparently the only way needs IO.
20:29:24 <heatsink> yes
20:29:30 <heatsink> maybe you want Control.Monad.Error?
21:18:46 <Cale> monochrom: there are evaluation order issues with being able to catch exceptions from pure code
21:19:12 <monochrom> oops I forgot that!
21:19:31 <samc> monochrom, how's the paper coming?
21:20:03 <monochrom> I procastinated
21:20:26 * samc is shocked
21:20:37 * samc never procrastinates
21:20:44 <monochrom> you are pure
21:21:01 <samc> honest too
21:21:27 <cjb> Pure, lazy, honest, pick two?
21:22:09 <monochrom> haha
21:25:48 <palomer> does anyone remember who wrote that paper describing what happens to types in CPS transformations?
21:26:02 <mwc> Lazy semantics for lazy academics?
21:26:04 <cjb> That guy.  With the beard.
21:27:26 <palomer> gah
21:27:55 <palomer> or does anyone know what happens to the type of a term when its CPS'd (I've asked this before, I know, but I've forgotten the answer, and can't locate the paper)
21:31:02 <monochrom> Ah!  No worries.  I don't plan to catch exceptions all that often.
21:31:52 <palomer> hullo monochrom
21:32:03 <palomer> what's new in the area of refinement calculi?
21:33:01 <monochrom> I should be writing up the proofs of a few little new theorems.
21:33:19 <palomer> cool:o
21:33:33 <monochrom> Actually two weeks ago I already wrote one.
21:33:59 <palomer> does the transformation (b->c) => forall a. (a->b) -> (a->c) seem familiar to anyone?
21:34:18 <monochrom> http://www.cs.utoronto.ca/~trebla/loop-converse.pdf
21:34:24 <palomer> like, CPSification?
21:34:25 <samc> palomer, might this help http://www.brics.dk/MC/02/Continuations/ ?
21:34:56 <TheHunter> palomer, this is fmap/liftM for the reader monad.
21:35:03 <samc> I haven't read it, it's in my look at later list
21:35:24 <palomer> TheHunter: oh my
21:35:42 <palomer> because it's also an embedding of classical logic into intuitionistic logic
21:36:20 <monochrom> it looks to me (a -> ) is a functor.
21:36:38 <palomer> monochrom: I'm getting sick of proof as programs verification
21:36:48 <palomer> monochrom: do you think it would be easy to earn a masters in refinement calculus?
21:36:58 <palomer> like, I could write a paper in a month?
21:37:03 <gzl> what's the point of a masters in refinement calculus?
21:37:22 <gzl> if you're not continuing with research in that area, I mean
21:37:37 <monochrom> judging from the high quality theses in refinement calculus from Finland, I would say not easy at all.
21:37:51 <gzl> (in which case you'd get a PhD, I assume)
21:38:07 <monochrom> But getting a PhD is easy. :)
21:38:30 <gzl> it takes a while
21:38:57 <cjb> My fiancee's PhD has a median of 7 years.  :/  America is crazy.
21:39:10 <monochrom> The paradox is because at the PhD level fewer people work on refinement calculus than other things.
21:39:38 <gzl> I don't really understand the point of a masters in an area like that
21:39:59 <palomer> it's fun?
21:40:25 <gzl> I guess, but I would think most of the people who find it fun would want to continue researching it
21:40:52 <monochrom> if you're into tooling there is much open room for a master on tooling refinement calculus
21:41:32 <palomer> tooling?
21:41:42 <monochrom> making GUI tools
21:41:46 <palomer> pffft
21:41:59 <monochrom> Don't laugh.  The existing tools are still laughable.
21:42:58 <monochrom> I envision an eclipse plugin (even feature) for refinement calculus that is as full-fledged as other eclipse features
21:43:23 <samc> oops I just realised I posted the wrong link
21:43:27 <Korollary> Most (U.S.) employers treat an MS degree equal to a BS degree + a few years of experience. There are few jobs where an MS or PhD is required and even fewer where your thesis needs to match their current problem.
21:43:49 <palomer> yeah, I just want to do a masters on something fun and serious
21:43:58 <cjb> I don't think I've ever seen an MS required.
21:44:10 <gzl> yeah, I've only ever seen BS and PhD required
21:44:19 <cjb> And I think many US employers view it as "They were going to do a PhD, but they dropped out first."
21:44:32 <Korollary> gzl: I've seen some that required at least an MS.
21:44:33 <gzl> that's often true. :)
21:44:40 <gzl> Korollary: ok.
21:45:02 <Korollary> cjb: That's what I have done heh.
21:45:04 <gzl> well, ok, I've seen some that say "MS or 3 years experience"
21:45:17 <gzl> but I don't count that as required
21:45:35 <Korollary> gzl: that doesn't count really. I've indeed seen where they would not consider a BS and rquire at least an MS.
21:45:52 <cjb> Right.  MS is a special-case of three years experience, somewhat.
21:45:54 <Korollary> but very few. maybe 2-3% of all
21:45:57 <gzl> ok
21:46:24 <gzl> yeah, I don't claim to have seen a huge number of job listings :)
21:46:37 <Korollary> I am sick of reading job ads :)
21:46:49 <gzl> luckily I had to read only a handful
21:47:14 <Korollary> as a matter of fact, I am reading a few right now. Argh.
21:47:34 <gzl> haha
21:48:02 <Korollary> Yeah, and I'll go to a career fair tomorrow.
21:48:30 <monochrom> palomer: you're currently doing something like Martin-Lof logic?
21:49:09 <Korollary> gzl: If you have absolutely nothing to do, you could just check out Microsoft's ads. They have 500 open reqs easily at any given time.
21:49:13 <samc> monochrom, who's from finland?
21:49:21 <monochrom> Ralph Back.
21:49:26 <samc> oh right
21:49:58 <monochrom> btw http://www.cs.utoronto.ca/~trebla/loop-converse.pdf is one third of what I'm writing up.
21:50:35 * samc checks it out
21:50:53 <palomer> monochrom: erm, somewhat similar
21:51:13 <palomer> well, not the logic
21:51:19 <palomer> but the realizability aspect of it
21:51:20 <palomer> yes
21:51:33 <samc> palomer, weren't you doing something category theoretic, toposes?
21:51:49 <palomer> no way
21:51:54 <palomer> I'm not a big fan of category theory
21:51:55 <palomer> yet
21:51:56 <monochrom> realizability --- that could get very sick, it sounds
21:51:56 <samc> oh wrong guy
21:53:09 <palomer> it's cool because it links theoretical specification (model) with applicable specification (set of equations)
21:53:37 <palomer> so you build your programs, and your programs are functions in your model, so if your model is correct
21:53:42 <palomer> and you find the program (this can be non trivial)
21:53:48 <palomer> then your program is correct
21:55:38 <palomer> what sucks is that it currently only works for a very small number of models
22:02:52 * boegel stretches
22:02:58 <boegel> goooooooooooooooooooooooooooodmorning everyone
22:03:46 <Korollary> mo'nin'
22:04:21 <boegel> I think I'm way too early for the usual people to be here
22:04:45 <boegel> I got up way too early :( now I'm bored for another 20mins
22:04:54 <cjb> I'm up too late.  :/  6am here.
22:05:00 <boegel> 7am here
22:11:58 <dons> @yow
22:11:59 <lambdabot> Laundry is the fifth dimension!!  ... um ... um ... th' washing
22:11:59 <lambdabot> machine
22:11:59 <lambdabot> is a black hole and the pink socks are bus drivers who just fell in!!
22:12:01 <dons> @code
22:12:02 <lambdabot> Generics.hs: (:*:)(..), (:+:)(..), Unit(..)
22:12:11 <dons> generics for all!
22:12:33 <boegel> yo dons
22:12:47 * boegel is glad to see someone he knows
22:13:06 * threeve is struggling to figure out what "Just" does.  Is it only used along with Maybe ?  This tutorial just starts using it but doesn't really explain it.
22:14:12 <Korollary> threeve: try re-reading the section on data and type constructors.
22:14:29 <threeve> Korollary: that's the section I'm in now.
22:14:43 <Korollary> threeve: Oh, I thought you were reading on monads.
22:14:51 <dons> @kind 1
22:14:52 <lambdabot> *
22:14:57 <threeve> Korollary: I'm not that far yet...
22:16:03 <Korollary> threeve: what does this line tell you: "data T a = Tc a" ?
22:16:53 <threeve> Korollary: it creates a datatype T accepting type a which calls the constructor Tc passing in one element of type a ?
22:17:52 * boegel leaves for work
22:18:10 <Korollary> threeve: It actually just makes a declaration. Now, forget about the "calling" part.
22:18:27 <Korollary> threeve: If I were to make another declaration somewhere such as "let x = Tc 'a'"
22:19:09 <Korollary> threeve: The compiler will then say that by "Tc 'a'" I constructed an object (data) of type "T Char".
22:19:46 <threeve> Korollary: yea, with you so far.
22:20:51 <Korollary> threeve: and when I say "let y = Tc True" it will construct another piece of data of type "Tc Bool"
22:21:14 <threeve> you mean of type "T Bool" right?
22:21:18 <Korollary> err yeah
22:21:24 <threeve> k
22:22:36 <Korollary> that's all, actually. Now a data declaration can have alternation in it, such as "data Maybe a = Just a | Nothing". So you can construct pieces of data by statements like "Just 'a'" or "Nothing"
22:23:35 <threeve> gah!  So "Just" is really a constructer, returning an object of type 'Maybe a' where a was what you passed to Just ?
22:23:52 <Cale> a is the type of what you passed to Just
22:23:59 <Korollary> a is the type of what follows "Just"
22:24:07 <threeve> right, that's what i meant
22:24:24 <threeve> so Just 'a' returns a Maybe Char
22:24:28 <Korollary> yeah
22:25:02 <threeve> its starting to make sense...
22:25:20 <Korollary> It's pretty neat actually. For example in C you would have a NULL value for a pointer that mustnt be dereferenced. In Haskell we could have something like "data Ptr = NULL | Int" or something.
22:25:41 <Korollary> We don't have to associate the Int = 0 with the "do not dereference" concept,
22:25:43 <Korollary> .
22:28:58 <threeve> I'm going to have to practice this some.  Wouldn't the use of Maybe/Just end up littering my code because I'll have to use it now in lots of places?
22:29:34 <threeve> well, I understand it much better than I did 20 minutes ago!  Thanks for the help Korollary
22:30:15 <Korollary> threeve: You would need to use it typically where a computation fail, such as a regex match. You'd get Nothing if the regex didn't match, or Just Something. And you probably care about both cases.
22:31:09 <threeve> Right, the example given is basically list head, which might return a Just listElem or Nothing if the list is empty
22:31:35 <threeve> Time to go sleep on it, I'll return in the morning.  Thanks again for the help!
22:31:41 <Korollary> no problem. nite.
23:01:58 <joelk> @seen Lemmih
23:02:00 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
23:02:06 <Lemmih> Hey joelk.
23:02:09 <joelk> hiya
23:02:20 <Lemmih> Finally meet in real-time (:
23:02:34 <joelk> what's going on with the SDL binding?
23:02:40 <joelk> Indeed!
23:02:54 <Lemmih> Is there something going on?
23:03:20 <joelk> I mean is it in active development?
23:04:10 <Lemmih> No, it does every I need it to and I haven't got any feature requests.
23:04:40 <Lemmih> But I use it almost every day myself so it's not dead.
23:05:51 <joelk> yeah, it's great. I haskellized SDLgears as an exercise. It was fun.
23:06:22 <Lemmih> Neat.
23:07:43 <joelk> Maybe when I clean it up a bit it will be a nice SDL/GL example.
23:11:22 <joelk> setCaption doesn't work, but then neither does the C version.
23:11:46 <Lemmih> What WM are you using?
23:11:52 <joelk> ion3
23:12:04 * Lemmih is on ion2
23:12:18 <Lemmih> Works in gnome, though.
23:12:28 * dons lives in ion3
23:12:37 <Lemmih> tuomov: What's the deal with that?
23:12:56 <Lemmih> Should I upgrade to ion3?
23:15:13 <joelk> I don't notice much difference besides the added status bar. When I finally kicked the gentoo habit and went back to Debian I saw ion3 and just went for it instead.
23:27:40 <GeniXPro> Im learning haskell, and I seem to be confused about the use of func f (x:xs) = ...
23:28:07 <GeniXPro> the (x:xs) has never been explained. : is the cons operator, but it seems to me its destructiong the argument its given
23:28:32 <dons> it's a pattern, equivalent to: func f a = case a of (x:xs) -> ...
23:29:46 <GeniXPro> its the (x:xs) thats confusing, how does that return the head element followed by the tail, or am i improperly accociateing this use of : with the cons operator 1:2:3:[]
23:30:02 <dons> `x' is bound to the head of the list, and xs is the rest
23:30:07 <dons> @eval let f [] = 0 ; f (x:xs) = 1 + f xs in f "haskell"
23:30:09 <lambdabot> 7
23:30:35 <dons> remember that (:) is the list constructor, so it's matching a data type consiting of a single char, and a list
23:30:40 <dons> i.e. (x : xs)
23:30:45 <dons> or List c cs
23:31:03 <dons> s/char/element
23:31:13 <GeniXPro> hmm, ok
23:31:48 <dons> it's like: f (List c cs) = ... but with infix syntax. f (c : cs)
23:32:51 <paolo> @kind Control.Arrow.Arrow
23:32:53 <lambdabot> bzzt
23:32:57 <paolo> 'morning :-)
23:33:17 <GeniXPro> hmm, it still matches only one argument, but creates 2... But I think i understand a little
23:34:13 <dons> it's taking apart the list argument-- your destructor intuition is good
23:34:33 <Lemmih> nibro: Have done any work on porting HSPR to fastcgi?
23:34:56 <dons> nibro around this early?
23:35:18 <Lemmih> It's almost 9am.
23:35:35 <GeniXPro> thankyou dons, I believe i understand
