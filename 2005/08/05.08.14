00:18:39 <lispy_> @type Just Nothing
00:18:41 <lambdabot> forall a. Maybe (Maybe a)
00:22:04 <lispy_> @type let throwErrno loc = do { errno <- Foreign.C.getErrno;  Control.Eval.evaluate errno;ioError (Foreign.C.Error.errnoToIOError loc errno Nothing Nothing) }
00:22:06 <lambdabot> bzzt
00:22:12 <lispy_> @index evaluate
00:22:13 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
00:22:22 <lispy_> @type let throwErrno loc = do { errno <- Foreign.C.getErrno;  Control.Exception.evaluate errno;ioError (Foreign.C.Error.errnoToIOError loc errno Nothing Nothing) }
00:22:24 <lambdabot> bzzt
00:22:32 <lispy_> @type let throwErrno loc = do { errno <- Foreign.C.getErrno;  Control.Exception.evaluate errno;ioError (Foreign.C.Error.errnoToIOError loc errno Nothing Nothing) } in throwErrno
00:22:34 <lambdabot> forall a. String -> IO a
00:53:54 * boegel pokes shapr with a stick
01:00:30 * lispy pokes boegel with a shapr 
01:02:28 * vikasg boegels lispy with a poker
01:08:03 * musasabi throws lambdas into the mix
01:10:41 * lispy starts dancing with a lambda
01:49:04 * Lemmih wants a whole-program dead-code eliminator.
01:49:17 <lispy> yeah
01:49:20 * lispy too
01:55:02 <basti_> hi
01:55:09 <lispy> hi
01:55:16 <Lemmih> hi
01:55:24 <basti_> hi
01:55:34 <basti_> :)
01:56:54 <dblhelix> hi
01:57:02 <sieni> hi
01:57:15 <dblhelix> question: does eta-equivalence hold in Haskell? I think: in general, no...
01:57:16 <Cale> hi
01:57:41 <dblhelix> some thoughts on this?
01:57:42 <Lemmih> h4sh came to #haskell and suddenly everyone gets a hi.
01:58:40 <lispy> dblhelix: i have no thought, but i've heard that it does not hold
01:58:59 <lispy> so just a rumor....
01:59:06 <Cale> dblhelix: it's nearly true -- there are a few good cases where it's not involving seq and of course, unsafePerformIO
01:59:36 <dblhelix> Cale: yeah, I figured
02:00:09 <dblhelix> but, then, try to prove the monad laws for, say, the reader monad without (eta-eq)
02:00:20 <Cale> It basically holds though
02:01:06 <dblhelix> Cale: yes, modulo seq etc.
02:01:23 <Cale> hmm... how did the example with seq go again...
02:01:52 <dblhelix> @eval (\f x -> f x) undefined `seq` ()
02:01:59 <lambdabot> ()
02:02:08 <dblhelix> @eval (\f -> f) undefined `seq` ()
02:02:10 <lambdabot> Prelude.undefined
02:02:16 <Cale> ah, yes
02:03:00 <lispy> so the first one should be undefined?
02:03:24 <Cale> well, they should be the same
02:03:39 <dblhelix> if eta holds, that is
02:03:44 <Cale> yeah
02:04:08 <lispy> and remind me, what is eta exactly?
02:04:20 <lispy> (\x -> x) y ==> y?
02:05:01 <dblhelix> \x -> f x = f (if x not free in f)
02:05:21 <dblhelix> that, eta-eq
02:05:44 <dblhelix> from left to right you have eta-reduction, the other way around you have eta-expansion
02:06:22 <dblhelix> so, you can still use it to prove expressions equivalent, but formally, only up to eta-equivalence, I guess
02:06:56 <dblhelix> or modulo seq etc.
02:07:58 <lispy> so eta reductions form the basis for the point-free transformation?
02:08:12 <dblhelix> lispy:  yes
02:09:49 <lispy> hmm...not see how to apply eta-red to (\f x -> f x)
02:10:43 <dblhelix> well: it's sugar for \f -> \x -> f x
02:10:54 <lispy> right
02:10:55 <dblhelix> so, apply eta to \x -> f x
02:11:03 <dblhelix> it gives you f
02:11:11 <lispy> ah, right
02:11:12 <dblhelix> so, you end up with \f -> f
02:11:53 <lispy> @type deepSeq
02:11:55 <lambdabot> bzzt
02:12:03 <lispy> @index deepSeq
02:12:04 <lambdabot> bzzt
02:12:12 <lispy> hmm...that must not be part of haskell
02:12:52 <dblhelix> it isn't: it's not a function that can be written with parametric polymorp
02:12:55 <dblhelix> hism
02:13:15 <Lemmih> Yay. Two modules down, seventy to go.
02:13:38 <basti_> Lemmih: :D
02:13:40 <dblhelix> so, to have it, you will have to have it built into the language, overload it, or define a suitable generic function
02:13:43 <lispy> Lemmih: checking for dead code?
02:13:46 <Cale> A nice approximation to deepSeq can be written with Data.Generics
02:13:52 <Cale> I did that the other day :)
02:13:58 * basti_ honours Lemmih's heroic work to isolate the haskell parser
02:14:00 <Lemmih> lispy: Yeah, ripped out GHC's Haskell parser.
02:14:09 <Cale> rnf :: (Data a) => a -> ()
02:14:09 <Cale> rnf x = everything seq (\y -> y `seq` ()) x
02:14:11 <lispy> Lemmih: oh, right, gl
02:14:14 <Cale> deepSeq x y = rnf x `seq` y
02:14:33 <dblhelix> Cale: nice
02:14:58 <dblhelix> Generic Haskell has a deepSeq library function somewhere
02:15:18 <lispy> so if we apply deepSeq to the above, does it change the outcome?  I'm guessing no because the deep means it does a traversal right?
02:15:46 <Cale> dblhelix: yeah, I think it's called dSeq
02:15:56 <Cale> or some such
02:16:05 <lispy> so is the eta-eq problem something to do with not reducing to the right NF?
02:16:35 <dblhelix> Cale: yes, it is
02:17:16 <Cale> lispy: I think the trouble is that with seq around, you can force something to diverge before it ought to
02:17:20 <dblhelix> lispy: the thing is that seq only evaluates until it can determine the top-level constructor
02:17:36 <Cale> (before the whole expression would with lazy evaluation)
02:17:57 <dblhelix> you can think of lambdas as being the constructors of the function type
02:18:08 <lispy> so, one possible fix would be to have seq try harder?
02:18:29 <dblhelix> lispy: but then you end up with deepSeq
02:19:17 <lispy> but does deepSeq make your example with undefined give the same answer in bonth cases?
02:19:29 <dblhelix> lispy:  point is, it can be convenient to have seq around, but it makes the semantic properties of haskell a little more complex
02:19:45 <dblhelix> lispy:  yes, it does
02:20:30 <Cale> Hmm... deepSeq on function types...
02:20:57 <lispy> so, there is no way to have deepSeq given the haskell type system.  Is deepSeq possible in system f?
02:21:00 <dblhelix> Cale: that's not easy to define
02:21:10 <dblhelix> Cale: that's not easy to build in either
02:21:26 <Cale> yeah
02:21:58 <dblhelix> lispy: well, it involves checking for bottoms
02:22:14 <Cale> it's not continuous?
02:22:38 <dblhelix> lispy: solving the halting problem, I guess
02:22:57 <lispy> dblhelix: ah, no biggy, lambdabot already does that :)
02:23:04 <lispy> @eval let x = x + 1 in x
02:23:06 <lambdabot> Loop
02:23:20 <dblhelix> lispy: well, that's loop detection
02:23:28 <lispy> dblhelix: i know, i'm just teasing
02:23:32 <dblhelix> @eval [0..]
02:23:34 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
02:23:34 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
02:23:34 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
02:23:34 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
02:23:34 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
02:23:36 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
02:23:38 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
02:23:40 <lambdabot> [24 @more lines]
02:24:32 <lispy> i had a thought the other day, that hours should have a factorial number of minutes
02:25:05 <basti_> lambdabot should be restricted to something like 3 lines
02:25:16 <lispy> then, any way you want to divide up the hour you could do it evenly (unless you want to divide it in more ways than it has total minutes of course)
02:27:20 <lispy> but the problem is that 24minutes and 120minutes don't make good sizes for hours
02:27:46 <SM_ax> @eval length "asdfasdf"
02:27:48 <lambdabot> 8
02:27:50 <basti_> 60 = 2*2*3*5
02:27:53 <basti_> thats pretty good i thinkg
02:27:54 <basti_> -g
02:27:59 <SM_ax> @eval length " CAA:89"
02:28:01 <lambdabot> 7
02:29:08 <lispy> oh, it's flawed anyway
02:29:17 <lispy> 120/7 is not an integre
02:29:41 <SM_ax> Hmm, my ghc interpreter returns "lexical error" on cyrillic characters...
02:29:54 <basti_> hmm
02:30:04 <basti_> in strings or as function names?
02:30:09 <basti_> (symbols9
02:30:09 <basti_> )
02:30:17 <SM_ax> in strings
02:30:30 <basti_> are you using unicode?
02:30:36 <wilx> UTF-8 text?
02:31:03 <basti_> yes utf-8 text
02:31:08 <SM_ax> basti_, i guess ...
02:31:13 <basti_> hm
02:31:15 <basti_> you do.
02:31:16 <basti_> ;)
02:31:17 * dblhelix goes thinking about eta and seq some more
02:31:17 <SM_ax> this can be a problem?
02:31:19 <dblhelix> cheers
02:31:29 <Oeje1> SM_ax: привет.
02:31:35 <basti_> hmm i don't know how cyrillic characters are encoded usually
02:31:38 <SM_ax> I have to check to be sure
02:31:45 <basti_> do you have a hex editor handy?
02:32:10 <basti_> (emacs: M-x find-file-hexl or something)
02:32:52 <SM_ax> Oejel, I can't read that
02:33:01 <SM_ax> Oejel, that was unicode?
02:33:24 <basti_> theres a difference if you CHAT in unicode and if you write your programs in unicode too.
02:34:20 <Oeje1> SM_ax: Yes, I said "privet".
02:35:01 <SM_ax> Oejel, do it once more please
02:35:26 <SM_ax> basti_, the program is in unicode
02:35:31 <basti_> hmm
02:35:35 <basti_> that should work, then.
02:35:36 <basti_> strange
02:36:17 <basti_> my ghc parses unicode.
02:36:23 <basti_> (i never tried before)
02:36:33 <Oeje1> SM_ax: привет.
02:37:22 <SM_ax> Oegel, ok now :)
02:38:08 <SM_ax> may be i did not compile it with unicode support...?
02:38:23 <wilx> Hm, I don't think it is optional.
02:58:50 <basti_> hmm
02:59:24 <basti_> is there a possibility to extend a datatype "later"? (importing a module, and then extending the type)? I thought there was
03:00:58 <autrijus> basti_: sadly no, you'd need to wrap another "data" on top of it
03:01:11 <basti_> i see
03:01:26 <autrijus> data MyBool = Bool Bool | Fuzzy Double
03:01:31 <autrijus> can't simply extend Bool
03:02:04 <musasabi> Extensible types would be very nice for e.g. exceptions.
03:02:24 * autrijus finishes today's visiolization session
03:02:35 <autrijus> # http://pugscode.org/images/lambdacamels.png
03:02:43 <musasabi> @type Control.Exception.catch
03:02:49 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
03:03:19 <musasabi> Would catch :: Exception e => IO a -> (e -> IO a) -> IO a work ?
03:04:11 <autrijus> @type Control.Monad.Error.catchError
03:04:13 <lambdabot> forall (m :: * -> *) e a.
03:04:13 <lambdabot> (Control.Monad.Error.MonadError e m) =>
03:04:13 <lambdabot> m a -> (e -> m a) -> m a
03:04:17 <autrijus> :)
03:04:47 <musasabi> ok, now why does Control.Exception not support such a thing?
03:04:59 <autrijus> perhaps because it's not in h98?
03:05:56 <musasabi> the Exception e => IO a -> (e -> IO a) -> IO a is haskell98.
03:06:06 <musasabi> as it is not parametrized over the monad.
03:08:39 <paolo> 'morning
03:10:01 <paolo> autrijus: nice pic :-)
03:15:22 <paolo> autrijus: what do you use to create them?  They are _so_ nice.
03:21:42 <autrijus> paolo: there are other stuff in http://pugscode.org/images/ too :)
03:21:45 <autrijus> paolo: Visio
03:23:20 <paolo> Yup, I saw them, but I understand just one :)
03:24:55 <lispy> @type Data.Array.(//)
03:25:00 <lambdabot> bzzt
03:25:10 <lispy> @type (//)
03:25:11 <lambdabot> bzzt
03:25:17 <lispy> @index (//)
03:25:18 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.
03:25:18 <lambdabot> Array
03:25:28 <lispy> hmm...
03:25:38 <lispy> @type Data.Array.//
03:25:39 <lambdabot> bzzt
03:31:06 <autrijus> paolo: oh? I think timeline.png should be understandable too :)
03:31:25 <paolo> heh, right.
03:34:23 <paolo> autrijus: could you explain the metamodel.png ? :-)
03:35:31 <autrijus> paolo: hm, what about it? :)
03:35:47 <paolo> What does it represent?
03:37:20 <autrijus> it represents the way to implement perl6's objectmodel on a runtime that may not have native support for objects, eg haskell
03:38:40 <autrijus> also, it shows how the model itself may be exposed as a user-level class, so the user can tweak the object system by changing the meta-object protocol.
03:38:46 <autrijus> it's very close to CLOS stuff.
03:39:11 <paolo> uhm-de-dum
03:40:07 <paolo> Fair enough ;-)
03:45:11 <paolo> So Haskell Strings are Unicode by default?
03:45:25 <autrijus> yes.
03:45:37 <autrijus> but you can't easily create them ;)
03:45:43 <autrijus> from external I/O, that is
03:45:59 <paolo> Aww - I was wishing... ^_^
03:46:12 <autrijus> if you work exclusively with utf8, you can use the UTF8.lhs
03:46:22 <autrijus> and if you work only on Win32, you can use Foreign.C.String
03:46:26 <paolo> @google UTF8.lhs
03:46:28 <lambdabot> http://abridgegame.org/cgi-bin/darcs.cgi/darcs/GNUmakefile?c=annotate&p=20041113122456-53a90-d6d743396b9cda50de4e37e066471d825680d36f.gz
03:46:31 <autrijus> but otherwise you're somewhat out of luck
03:46:56 <autrijus> there are iconv and ICU bindings, but they are not as tightly integrated.
03:46:58 <paolo> I was reading Foreign.C.String for some reason.
03:47:25 <jlouis> hmmm, zipper-topic is overkill
03:47:30 <jlouis> 0verk1ll rather
03:47:36 <paolo> UTF8.lhs it's nice
03:47:43 <paolo> jlouis: Ah! Why?
03:48:21 <jlouis> paolo: UI thoughts from musasabi yesterday. You seldomly want to prod around with a pointer in the topic to alter it, however nice it may be
03:50:07 <paolo> So @topic-cons @topic-snoc @topic-insert @topic-replace @topic-set, where insert and replace are index-based?
03:50:18 <paolo> (replace too)
03:50:49 <paolo> In fact I did like the Zipper idea, tough :-)
03:51:09 <jlouis> heck, lets program it for fun and try it out to see how it works
03:51:21 <musasabi> paolo: if you change the topic once in a week how much sense does the previous "current position" make?
03:52:28 <paolo> musasabi: maybe if one implements @topic-index too the two things could convive?
03:52:41 <paolo> (which moves the marker)
03:54:07 <jlouis>  usual operations are: add something. Delete something. And Destroy the whole topic line replacing it by this
03:54:24 <jlouis> I have a hunch making it any more complicated is overkill
03:54:29 <musasabi> paolo: that still would make most operations involve two operations: 1) move to the right place, 2) do the operation. Using a substring of the topic or an index for the command would make one command suffice.
03:55:48 <jlouis> in fact, theh only reason for the bot to maintain topics is to have an authoritative source when topics are removed by the ircd
03:55:57 <paolo> The substring index is interesting to me.
03:56:53 <jlouis> @help topic-set
03:56:54 <lambdabot>  @help <command> - ask for help for <command>
03:57:00 <jlouis> @help @topic-set
03:57:01 <lambdabot>  @help <command> - ask for help for <command>
03:57:14 <jlouis> @listcommands topic
03:57:15 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-
03:57:15 <lambdabot> init topic-null
03:58:01 <jlouis> oh, we can start documenting the Topic plugin, heh
04:05:39 <paolo> @pl \s p -> f p (g s)
04:05:40 <lambdabot> flip f . g
04:06:19 <paolo> @pl \p s -> f p (g s)
04:06:20 <lambdabot> (. g) . f
04:07:16 <paolo> @pl \s -> f s $ \s' -> g s'
04:07:18 <lambdabot> flip f g
04:08:16 <paolo> Function application is right or left binding?
04:09:38 <lispy> left accosciative, so foo bar baz = (foo bar) baz
04:09:48 <paolo> associative, right.  Thank you.
04:10:03 <paolo> hmm, ok.
04:10:12 <lispy> heh, i tried to reverse the cs and ss...
04:11:34 <sieni> paolo: it doesn't matter since function appication is trivially associative
04:11:48 <paolo> sieni: what do you mean?
04:14:06 <sieni> that f o (g o h) = (f o g) o h
04:14:45 <paolo> But it matters for currying purposes I think.
04:15:25 <sieni> maybe
04:16:30 <lispy> sieni: so that's why can do foo . bar . baz and not need parens
04:16:49 <lispy> but yeah, for currying it's going to be different
04:17:45 <paolo> @pl \s p -> f p (\p' -> g s p')
04:17:46 <lambdabot> flip f . g
04:17:54 <paolo> Lunchtime!
04:35:58 <bourbaki> moin
04:38:50 <shapr> y0!
05:24:21 <FrederikEaton> blargh
05:25:33 <shapr> Wassup?
05:26:03 <shapr> ramkrsna: How's Gofer treating you?
05:26:29 <ramkrsna> so far so good
05:28:24 * shapr boings quietly
05:28:55 * paolo screams quietly too
05:29:01 <autrijus> people are using Gofer?
05:29:58 <shapr> I know some people still teach Gofer. I don't know if anyone uses Gofer over Haskell.
05:31:30 <musasabi> Gofer has monad comprehensions :-)
05:35:25 <wilx> What is that?
05:35:36 <wilx> I mean how does it look?
05:35:50 <musasabi> Like list comprehensions but for more general monads.
05:36:14 <wilx> Ah.
05:37:21 <paolo> musasabi: what are they really useful for?
05:38:10 <Philippa> occasionally they give a nicer syntax for something
05:39:19 <Philippa> monads that're more like List and less like State, generally
05:39:30 <musasabi> paolo: e.g. database queries (think haskelldb) can benefit from them as syntactic sugar.
05:39:56 <musasabi> another thing would be parray comprehensions using the same syntax.
05:40:51 <paolo> Ah!
05:42:44 <Philippa> stuff where you find yourself thinking in terms of "like a set comprehension, only..."
05:42:56 <Philippa> hell, set comprehensions
05:43:15 <musasabi> paolo: They were omitted from haskell as they created evil error messages confusing new people trying to do list comprehensions.
05:44:00 <Philippa> I reckon there's some research to be done on domain-specific type error messages
05:44:12 <paolo> Hmm, what's the difference between list and set comprehension?  The latter are heterogeneous?
05:44:20 <Philippa> it'd be nice if there was a mechanism to suggest likely causes of a given type error
05:44:33 <Philippa> sets are sets, lists are lists
05:44:37 <Philippa> that's the difference :-)
05:44:42 <paolo> sets aren't ordered?
05:44:52 <Philippa> right. And they don't have the same element more than once
05:44:58 <paolo> Cool.
05:45:25 <paolo> musasabi: good choice! hehe, maybe a compiler/interpreter flag could enable it as needed‽
05:45:31 <autrijus> and the Data.Set implementation of Set is finite.
05:46:46 * paolo takes off the pocket the set of the sets not containing theirself.
05:48:33 <pejo> Philippa, as usual it's not much glory in doing practical stuff, it's better to expand the type system so you can get even weirder error messages. ;)
05:48:54 <Philippa> heh
05:48:59 <Philippa> I'd like to have a go at it though
05:49:06 <Philippa> we're rapidly heading to a point where we'll really really need it
05:49:19 <Philippa> if not in haskell then in another language
05:49:33 <pejo> Philippa, sure. Bastiaan Heeren has done some interesting work on it.
05:50:23 <Philippa> I've read up about type slicing and pinpointing where the errors have occurred
05:51:20 <pejo> In order for the research to be useful someone needs to implement it in GHC as well though. Just tuning the stuff that is currently in there could help, I imagine.
05:51:23 <Philippa> ooh, cool, will have to grab the papers
05:51:43 <Philippa> yeah. Though I know of some other places where it could prove useful
05:52:02 <Philippa> you'd be amazed some of the places I've considered using pure FP. Or maybe not. But YKWIM :-)
05:53:46 <pejo> Hm. I can't find a link on his homepage but http://www.cs.uu.nl/people/bastiaan/research.html gives links to lots of stuff too. But it doesn't seem to be updated that recently.
05:54:27 <pejo> Philippa, ENOPARSE. YKWEFWEIO?
05:55:30 <Philippa> ah, apparently you /don't/ know what I mean
05:56:24 <paolo> Hmm, what is needed to configure under linux to use a GHC snapshot?  1) adjusting $PATH - done, 2) "*** Exception: Line 20: Unknown field 'hs-source-dirs'" ?
05:56:55 <pejo> Philippa, no. I just have very bad error messages.
05:57:11 <paolo> (I did make-inplace)
06:04:08 <paolo> I could try adding a user and play with --prefix=$HOME ... mmh.
06:04:51 <pejo> paolo, I've only used binary releases on Linux but I just followed the instructions and everything worked. But thats not much help for you, I guess.
06:05:40 <paolo> pejo: I do have ghc installed, I'm trying to use a snapshot to see if the c2hs problem disappears, but I have some issues (that exception during "runhaskell Setup.lhs configure)
06:13:38 <pejo> Philippa, well, would you care to tell what YKWIM means? :-)
06:14:04 <Philippa> You Know What I Mean
06:14:18 <Philippa> hence my comment that apparently you didn't
06:17:19 <pejo> Heh. Had you just left that last thing out I would have known.
06:17:41 <shapr> jiihaa
06:17:42 * shapr boings
06:18:25 <jyp> What cheers you up mate? :)
06:18:36 * paolo grumbles
06:18:48 <shapr> Non-code happy things in my life.
06:18:52 <shapr> jyp: What cheers you up?
06:19:11 * jyp 's english is lame
06:19:37 <shapr> Je ne parle pas bien francais...
06:19:37 <jyp> Let's rephrase... What is cheering you up mate?
06:20:02 <paolo> Do you know what "hs-source-dirs" is?
06:20:03 <shapr> Ik ook begrijp niet nederlands.
06:20:24 <jyp> Happy things too, I guess :) Though I'm getting closer to the buddha state of permanent bliss :p
06:20:43 <jyp> So it's difficult to tell
06:21:16 <jyp> @google hs-source-dirs
06:21:18 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/cabal.haddock.hidden.modules.patch
06:21:38 <jyp> ni!
06:21:58 <musasabi> paolo: that means that you have to upgrade cabal before installing c2hs.
06:22:17 <shapr> jyp: iki iki ptang zoop sassafras!
06:22:33 <paolo> Silly me, I did not install Cabal 1.1.1 here!  Thank you musasabi.
06:31:01 <paolo> Chasing modules from: c2hs/toplevel/Main.hs
06:31:01 <paolo> Could not find module `CForeign':
06:31:13 <paolo> Snapshot doesn't help, I'll downgrade :(
06:33:20 <musasabi> paolo: add base to the build-depends field (and if it is there then haskell98).
06:34:04 <paolo> musasabi: that field in the c2hs cabal file?
06:34:14 <musasabi> yes.
06:34:41 <paolo> Let me reinstall GHC 6.4.1, heh.
06:35:33 <ski> musasabi,(autrijus) : maybe something like ''catch :: IO a -> (forall e. Exception e => e -> IO a) -> IO a' would be better ?
06:37:30 <musasabi> ski: good point and that shows why it is hard to do in haskell98.
06:37:31 <paolo> musasabi: there is no build-depend field in c2hs.cabal ‽
06:38:12 <ski> musasabi : but, extensible types would possibly be useful, too
06:38:41 <musasabi> paolo: Then add "Build-Depends: base" into the cabal file.
06:38:59 * ski imagines using extensible records for ST-monad like dynamic allocation of "cells"
06:39:16 <paolo> $ runhaskell Setup.hs configure
06:39:16 <paolo> Setup.hs: c2hs.cabal:20: Unknown field 'build-depends'
06:39:20 <musasabi> paolo: if it still complains use "Build-Depends: base, haskell98".
06:39:24 <paolo> hmm
06:43:04 <paolo> There is a precise place to put it.  Found.
06:43:55 * paolo hugs musasabi heavily
06:44:08 <paolo> It worked.  Let me report it on the ML, do you want any credit?
06:45:21 <musasabi> paolo: np glad if it worked :-)
06:46:22 <musasabi> no, just having someone documenting it to the ml is enough :-)
06:48:58 <Lemmih> Yes. Even more modules are out of the way now!
06:52:20 <paolo> musasabi: done.  Thanks again.
07:03:43 <paolo> Linking ...
07:03:44 <paolo> gcc: dist/build/c2hs/c2hs-tmp/c2hs/toplevel/c2hs_config.o: No such file or directory
07:04:04 <paolo> Gasp! It seem to be in dist/build/c2hs/c2hs-tmp/c2hs/toplevel/c2hs/toplevel/c2hs_config.o
07:06:46 <musasabi> ln -s or cp, that is an issue with 6.4.1 prereleases.
07:07:15 <musasabi> The handling of c-sources was changed.
07:07:37 <musasabi> Which is fixed in CVS cabal if I remember right.
07:08:09 * paolo gives the Cabal-award to musasabi 
07:14:37 <ehuber> hey
07:15:22 <paolo> Hi!
07:17:19 <paolo> hmm c2hs doesn't register itself it seems... the only way to "include C2HS" succesfully is "-i/usr/local/lib/c2hs-0.14.3/" ?
07:38:01 <ehuber> bonk
07:58:21 <ehuber> hello, anyone around
07:58:50 <ehuber> im getting an error that i dont understand with this code:
07:58:53 <ehuber> parseHTMLtag :: String -> (String, String) -> [(String, String)] -> [HTMLatom]
07:58:55 <ehuber> parseHTMLtag "" tuple@(label, _) list           = [HTMLtag (list ++  [if label == "" then [] else tuple])]
07:59:22 <ehuber> HUGS says :
07:59:42 <ehuber> Type checking
07:59:42 <ehuber> ERROR parsehtml.hs:16 - Type error in conditional
07:59:42 <ehuber> *** Expression     : if label == "" then [] else tuple
07:59:42 <ehuber> *** Term           : tuple
07:59:42 <ehuber> *** Type           : ([Char],[Char])
07:59:44 <ehuber> *** Does not match : [a]
08:00:26 <Lemmih> 'tuple' has type '(String,String)' and '[]' has type 'String'.
08:00:28 <ehuber> if i replace the entire [if..] with simply [tuple] then no error is produced.
08:00:30 <Lemmih> They don't match.
08:00:53 <ehuber> i thought [] simply meant empty list, for all types?
08:01:02 <Lemmih> A tuple is not a list.
08:01:23 <ehuber> aha i see
08:01:27 <Lemmih> Maybe you want ([],[])?
08:01:53 <ehuber> actually i fixed by doing this :
08:02:04 <ehuber> pparseHTMLtag "" tuple@(label, _) list           = [HTMLtag (list ++  if label == "" then [] else [tuple])]
08:02:23 <Lemmih> ah
08:02:33 <ehuber> i suppose either way would work (:
08:03:49 <Lemmih> No, I was in error. A tuple wouldn't fit there /-:
08:04:28 <ehuber> actually now i think about it
08:04:34 <ehuber> i dont want to add an element in the first if path
08:04:45 <ehuber> if i did ([],[]) that would add an empty tuple
08:08:25 <ehuber> actually i was wrong, this didnt fix it
08:08:39 <ehuber> i suppose i cant specify an empty list of that type
08:08:40 <ehuber> ?
08:09:00 <ehuber> the only way to fix is to do   if (condition) then list else list ++ bla   ??
08:09:01 <kristnjov> heya
08:09:03 <kristnjov> how is it
08:09:59 <ehuber> hi kristnjov
08:10:11 <ehuber> do you know a good deal about haskell?
08:10:19 <kristnjov> i know a bit
08:10:26 * Matt-W just learned something
08:10:45 <ehuber> ok i have what should be a simple problem..
08:10:53 <kristnjov> ask away
08:11:04 <ehuber> is there a way to specify an empty list of any type?
08:11:13 <ehuber> because apparently [] is not 'of any type'
08:11:25 <kristnjov> [a] should do the trick
08:11:29 <Lemmih> ehuber: But it is.
08:11:46 <Matt-W> [] is of any list type
08:14:32 <ehuber> oh okay... i have to be careful with my parentheses (:
08:16:17 <ehuber> this is different from C :p
08:16:32 <kristnjov> imperative is the shit
08:16:39 <Matt-W> yes, it is rather
08:16:45 <Matt-W> That's one reason I enjoy Haskell
08:17:04 <kristnjov> the need to think of different solutions?
08:17:21 <Matt-W> The fact that it's completely different
08:17:43 <kristnjov> so that would mean that you would enjoy C just as much as haskell since C is completely different from haskell?
08:17:51 <ehuber> lol
08:17:59 <Matt-W> No, because C's evil
08:18:00 <kristnjov> the relationship is equivalent
08:18:27 <Matt-W> no it's not
08:18:33 <ehuber> it seems that as long as i cover all cases, i should never get a crash in haskell
08:18:43 <kristnjov> in discrete mathematics the relation is equivalent
08:19:04 <kristnjov> i happen to be in school to study it at this very moment :P
08:19:26 <Matt-W> This is not discrete mathematics :-P
08:19:50 <kristnjov> ah, but see mathematics is a logical system which can be applied into describing reality
08:20:09 <Matt-W> not inside my head it can't
08:20:42 <kristnjov> unfortunately that's where the system falls. it can only be used if you accept it's axioms and interference laws.
08:21:09 <Matt-W> yes, outside my head they seem quite sensible
08:21:15 <kristnjov> :)
08:35:33 <Lemmih> Hey bringert.
08:35:54 <shapr> hej bringert!
08:36:19 * shapr goes unicycling
08:36:24 <Oeje1> Hej bringert.
08:37:37 <chucky> bringert sure is a popular guy today. :) Hej bringert
08:38:41 <ehuber> hej
08:39:51 <bringert> hej everybody
08:43:40 <Lemmih> bringert: Got my patches?
08:44:27 <bringert> Lemmih: yeah, looking at them right now
08:46:06 <bringert> Lemmih: I was planning not to expose the implementation of CGIT etc, but instead have general enough funtions for working on them
08:46:18 <bringert> what is it that you need to do?
08:48:04 <Lemmih> Need my own state and access to unCGIT.
08:48:20 <Lemmih> You don't expose MonadCGI! (:
08:48:36 <Lemmih> s/don't/didn't/
08:50:22 <Lemmih> You can't really do much without MonadCGI and unCGIT.
08:52:51 <bringert> I guess I'll just expose the stuff
08:53:06 <bringert> the web server is down right now though, so I can't push anything
08:56:57 <Lemmih> Great.
09:36:07 * shapr exposes bringert!
09:36:10 <shapr> Look it's bringert!
09:37:00 <Lemmih> Where?!
09:37:05 <shapr> right THERE!
09:37:20 <Lemmih> Oh, indeed it is!
09:37:20 <paolo> ‽
09:37:23 * Lemmih boinks.
09:38:58 <autrijus> hey. I'm DriFTing JSON
09:39:05 <autrijus> do you think it's reasonable to emit
09:39:10 <shapr> JSON?
09:39:20 <autrijus> shapr: http://www.crockford.com/JSON/
09:39:24 <shapr> oh!
09:39:24 <shapr> nifty
09:39:31 <paolo> @google DriFT
09:39:33 <lambdabot> http://www.driftshowoff.com/
09:39:46 <shapr> @google drift meacham
09:39:46 <autrijus> paolo: http://repetae.net/john/computer/haskell/DrIFT/
09:39:47 <lambdabot> http://repetae.net/cgi-bin/darcs.cgi/DrIFT/?c=rss
09:40:06 <Lemmih> @where DriFT
09:40:07 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
09:40:10 <bringert> hi shapr
09:40:13 <shapr> @where bringert
09:40:13 <lambdabot> I know nothing about bringert.
09:40:23 <shapr> bringert: hiii! wassup?
09:40:27 <autrijus> data D = S | A a1 a2 | R { k1 :: t1, k2 :: t2 }
09:40:33 <shapr> bringert: rumor has it that I'll be entering the Swedish educational system.
09:40:44 <autrijus> since JSON only has untagged hash and arrays, it's somewhat tricky
09:41:06 <paolo> Cool!
09:41:30 <bringert> shapr: sweet, how?
09:41:39 * bringert has been gone for a while
09:41:47 <shapr> bringert: via Luleå first.
09:41:48 <autrijus> { "" : "R", "k1" : v1, "k2": v2 }   { "A": [ v1, v2 ] } { "S": null }
09:42:00 <autrijus> is the 0th approximation of encoding
09:42:08 <autrijus> I'm not quite happy with the asymmetry between R and A, though.
09:42:25 <autrijus> maybe  { "R": { "k1" : v1, "k2" : v2 } } is better.
09:42:25 <bringert> sailing, taking an arabic course, got a driver's license, that sort of stuff
09:42:35 <shapr> bringert: Cool! How was the sailing?
09:42:52 <bringert> very nice
09:42:55 <bringert> fast boat
09:42:56 <shapr> Oh, I gotta get ready to go to a friend's house, I'll bug you more later.
09:43:09 <bringert> ok, later
09:43:17 <Itkovian> hi shapr
10:07:02 * Lemmih is down to 50 module dependencies.
10:07:33 <shapr> Lemmih: Could you use Hal's AllInOne inliner to produce a single file?
10:07:52 <paolo> Is it correct, in your opinion, that /usr/include/cairo/cairo.h should #include <cairo-features.h> and not <cairo/cairo-features.h> even if it is in /usr/include/cairo itself?
10:08:24 <basti_> paolo: i think #include "" will look in the current path?
10:08:28 <Lemmih> shapr: I don't really want a single file.
10:08:43 <paolo> basti_: it does, and it is my problem with c2hs.
10:09:52 <basti_> hmm
10:10:46 <paolo> c2hs has only "-i INCLUDE   --include=INCLUDE    include paths for .chi files"
10:11:08 <paolo> Maybe this? "-C CPPOPTS   --cppopts=CPPOPTS    pass CPPOPTS to the C preprocessor"  I'm trying.
10:11:42 <paolo> Ah-ha! Hackery: c2hs -C-I/usr/include/cairo cairo.h Types.chs
10:12:10 <basti_> :)
10:12:22 <bourbaki> hey basti_
10:12:34 <basti_> hey bourbs
10:12:36 <bourbaki> basti_ http://codemages.sf.net/TorusWorld2.png
10:12:56 <bourbaki> this is what i started in haskell that other day this differential equation thingy with the spline words :)
10:13:07 <basti_> cute
10:13:28 <bourbaki> http://codemages.sf.net/TorusWorld.png
10:13:45 <bourbaki> http://codemages.sf.net/SphereWorld.png
10:14:06 <basti_> what are the black stripes?
10:14:13 <basti_> on the torus
10:14:30 <basti_> and sphere world is... black
10:14:31 <bourbaki> that are the rims of the mapped domain
10:14:39 * shapr y0wdels
10:14:44 <basti_> ah
10:14:50 <bourbaki> the shpere thingy is just renderd with wireframe
10:15:13 <basti_> ahh i see something
10:15:14 <bourbaki> i need a way to make my functions tileable now to map them on the torus and sphere without the breakings at the rim
10:16:08 <basti_> thats sounds like a topolgy task
10:16:35 <bourbaki> its a simple math task but it refuses atm to work :)
10:16:52 <basti_> .)
10:16:58 <bourbaki> i must need to build the quotientspace of this thingy but somehow its not doing what i want it to do atm
10:20:57 <basti_> thats the prototypical problem i think
10:22:33 <bourbaki> its simple for the torus case but harder for the sphere i think
10:30:36 <jlouis> yay!
10:43:21 <autrijus> hm, no-one had done DrIFT for Scheme S-Expressions either?
10:43:47 <autrijus> might as well.
10:46:20 <jlouis> what does one use DrIFT for? Simple parsing of arbitrary data?
10:46:37 <jlouis> The homepage doesn't seem to have that nice little one-line definition
10:46:56 <autrijus> jlouis: it's adding "deriving" for user-defined classes
10:47:17 <autrijus> so, for example, you can serialize any data type to XML and parse it back
10:47:20 <jlouis> ;)
10:47:23 <jlouis> my thought exactly
10:47:30 <jlouis> was about to ask if that was the main trick of it ;)
10:47:33 <autrijus> no.
10:47:39 <autrijus> its main trick is you can derive deepseq.
10:47:42 <paolo> Should C's "char*" and "const char*" be marshalled differently?
10:47:51 <autrijus> i.e. reduce any structure back to normal form
10:48:07 <jlouis> autrijus: oh, rather cool
10:48:16 <jlouis> hows pugs?
10:48:17 <autrijus> also it can derive FunctorM, Bounded, Monoid
10:48:36 <jlouis> ah, bingo. DrIFT makes much more sense now
10:48:53 <autrijus> but the main trick is that it is super easy to add production rules for your own classes
10:49:00 <autrijus> so metaprogramming = much easier
10:49:04 <jlouis> ;)
10:49:18 <autrijus> anyway. pugs is fine. I drew lots of pictures
10:49:45 <autrijus> switching to something similar to F-omega-sub as internal language right nwo
10:50:15 <autrijus> and the lambdacamels's assault to perl6 language design suceeded, so we get arrow types, type inferencing, and more :)
10:51:30 <autrijus> you may like this one: http://pugscode.org/images/lambdacamels.png
10:51:36 <paolo> I wonder how can one manage to understand the whole perl6 thing at one point.
10:51:52 <autrijus> paolo: by implementing it :)
10:52:07 <autrijus> it's much easier if you separate the surface syntax away
10:52:13 <autrijus> perl6 has 16,384 layers of sugar
10:52:28 <paolo> Are you kidding?!
10:52:31 <autrijus> but once it's all desugared away it's quite elegant :)
10:52:36 <paolo> heh :-)
10:52:56 <autrijus> (that's what you get when the main designers are all linguists)
10:55:48 <jlouis> Actually having the main designers be linguists proves to be an interesting way of developing a language
10:56:03 <jlouis> Language theorists cringe though, hehe
10:56:56 <autrijus> :)
10:57:21 <autrijus> seen on comp.lang.functional: "In the evolution of computer languages, Perl is a huge step _sidewards_"
10:58:35 <TheHunter> stupid question, do perl programmers rebind the $-sign to another key?
10:58:46 <autrijus> no, I don't think so
10:58:58 <SamB> jlouis: they ALWAYS do!
10:59:10 <autrijus> I think it's just like capitalizing the nouns in German
10:59:24 <autrijus> except the letter to capitalize happens to be on the numeric row
10:59:56 <jlouis> @index init
10:59:57 <lambdabot> Data.List, Prelude
11:00:14 <SamB> I personally cringe at the resend syntax in Self...
11:02:07 <SamB> it seems to require extreme care, and in all the implementations I've seen it requires rather statefull interaction of the scanner and the parser...
11:23:15 <jlouis> autrijus: nice image diagrams. The only one I did not understand instantly was the one showing the metaverse versus the universe
11:23:42 <autrijus> jlouis: nod. it'd be much easier to compare it with say TinyCLOS
11:25:17 <jlouis> Do you own a pug by the way? They are magnificient dogs
11:25:36 <autrijus> no, I do not. when I came with the name "pugs" I didn't even know what it means.
11:25:39 <autrijus> had to google it.
11:25:54 <jlouis> My parents own one. They are quite funny.
11:26:05 <autrijus> *nod* hadn't seen one in real life
11:26:39 <jlouis> The race was originally bred in the ancient China for the purpose of amusing the concubines. And what an outcome.
11:27:10 <jlouis> It was ''imported'' to Europe by the royals.
11:27:43 <autrijus> *nod*
11:29:43 <paolo> My neighbour used to have one!  He snooze all the time.
11:31:19 <jlouis> heh, lambdabot is a memory eater... 44Mb of ram. It takes out Firefox ;)
11:36:55 <TheHunter> i think @vixen consumes most of that.
11:38:25 <TheHunter> no, wait. It's @index's fault.
11:44:17 <TheHunter> % ps aux | grep 'lambdabot\|firefox'
11:44:17 <TheHunter> thomas   26825  2.8 19.7 128652 50444 ?        Sl   13:26   2:14 /usr/lib/mozilla-firefox/firefox-bin -a firefox
11:44:17 <TheHunter> thomas    1589  1.2  4.6  30964 11920 pts/4    Sl+  14:43   0:00 ./lambdabot
11:50:01 <paolo> Couldn't it be lazy-ed ?
11:57:16 <TheHunter> this is what happens after loading 'haddock', btw:
11:57:18 <TheHunter> thomas    1589  0.5 12.7  51464 32748 pts/4    Sl+  14:43   0:04 ./lambdabot
11:57:35 * paolo spoiled a bug in cairo, yay ^_^
11:58:03 <TheHunter> paolo, well, sooner or later, someone will type @index, and then the memory will be consumed anyway.
11:58:27 <paolo> But...
11:58:49 <paolo> Isn't "known" that one could parse 2Gb files in Haskell thanks to laziness?
12:00:02 <TheHunter> but we're keeping the whole @index map in memory.
12:00:31 <TheHunter> We could read it from the file each time, but I don't know why that should be preferred over the OS's swapping.
12:01:47 <paolo> What about combining the two ways?
12:02:00 <paolo> Like password saved in memory for 5 minutes after typing them.
12:02:27 <Muad_Dib> accidentally any russian in here?
12:02:43 <TheHunter> i don't see the advantage.
12:04:08 <TheHunter> hmm, maybe the gc will prevent the map from being swapped to disk.
12:06:57 <Oeje1> Muad_Dib: Я говорит русский. :-P
12:07:16 <Muad_Dib> like i can do any russian myself Oeje1 :P
12:07:17 <Oeje1> Ups, spelling error. :-(
12:08:12 <Oeje1> Muad_Dib: Maybe that's why you are asking?
12:08:29 <Muad_Dib> indeed :)
12:08:42 <SamB> TheHunter: well, the OS can just as well cache as swap...
12:10:11 <TheHunter> good point. But without a fancy seeking algorithm, search time will be linear in the size of the map.
12:11:21 * Oeje1 suggests using a DBMS.
12:11:23 <Oeje1> Hehe.
12:13:37 <TheHunter> certainly an overkill and would make installing lambdabot even harder.
12:16:01 <TheHunter> @where hsql
12:16:02 <lambdabot> I know nothing about hsql.
12:16:41 <TheHunter> @where haskelldb
12:16:41 <lambdabot> I know nothing about haskelldb.
12:17:15 <TheHunter> @listcommands where
12:17:16 <lambdabot> where provides: where where+
12:17:48 <TheHunter> @help where+
12:17:49 <lambdabot>  @where+ <key> <elem>, define an association
12:17:57 <TheHunter> @where+ haskelldb http://haskelldb.sourceforge.net/
12:17:58 <lambdabot> haskelldb ~> http://haskelldb.sourceforge.net/
12:18:11 <Muad_Dib> i couldnt even install lambdabot a lil while ago :P
12:19:16 <TheHunter> why not?
12:20:18 <Muad_Dib> forgot what it was, but some posix package problem. i cannot reproduce it since i have trouble rebooting into linux atm, and it'll probably be me anyway so just ignore it :P
13:06:35 <paolo> Do you happen to know how one runs a Makefile from another? (
13:13:20 <chucky> hej sylvan
13:16:15 <ibid> paolo: one calls make
13:16:36 <ibid> with the right parameters
13:16:42 <ibid> $(MAKE), actually
13:17:00 <paolo> hmm ibid but how to "cd" ?
13:17:28 <paolo> I have this Makefile in / and some Foo/Bar/Baz/Makefile
13:17:30 <ibid> paolo: tell me what you are really trying to do, don't ask tiny bits that make no sense in isolation
13:17:36 <paolo> I should probably just use one.
13:17:41 <ibid> a makefile in /???
13:18:25 <ibid> anyway, you invoke a subdirectory makefile by saying $(MAKE) -C subdir
13:18:42 <ibid> but recursive make is considered harmful
13:18:47 <paolo> OK
13:18:50 <sylvan> hej chucky
13:19:06 <paolo> It's difficult to explain because I don't grok make completely.
13:19:30 <jlouis> you can't grok gmake. bsdmake would probably be a bliss
13:19:36 <paolo> I have Foo/Bar/ with some sources, and Foo/Bar/Baz/ with some other.
13:19:49 <ibid> actually, gmake is much better than the alternatives :)
13:19:57 <paolo> Let me retry...
13:20:25 <goron> ibid: Based on what?
13:20:49 <ibid> goron: based on my experience in writing GNUmakefiles and portable makefiles
13:20:58 <ibid> i like the former much better
13:21:02 <paolo> ./Makefile ./Foo/Bar/ has some sources and some subdirs with even other sources.
13:21:19 <goron> ibid: And gmake is better then bsdmake?
13:21:19 <paolo> So I made ./Foo/Bar/Baz/Makefile for making Baz modules.
13:21:36 <paolo> The same goes for ./Foo/Bar/Quux/Makefile
13:21:59 <paolo> I was trying to make a ./Makefile which runs them all, but you say it's considered harmful.
13:22:21 <paolo> ( And there should also be a ./Foo/Bar/Makefile :-( )
13:22:28 <ibid> paolo: you can do it, there's just a lot of people who think it's better not to do it (still a lot of people do)
13:22:49 <paolo> Maybe I'm not writing the rules in the good way.
13:23:56 <paolo> If I collect all the rules in ./Makefile and delete the others I remain with many lines like:
13:24:04 <ibid> paolo: it just makes builds unnecessarily slow
13:24:12 <paolo> Foo/Bar/Baz/a.hs: Foo/Bar/Baz/a.chs
13:24:12 <paolo> 	c2hs ... a.chs
13:24:22 <paolo> Foo/Bar/Baz/b.hs: Foo/Bar/Baz/b.chs
13:24:23 <paolo> 	c2hs ... b.chs
13:24:23 <ibid> paolo: use pattern rules
13:24:31 <paolo> etc..
13:25:10 <ibid> goron: which are you more likely to find in any given unix-like system. gnu make or bsd make?
13:25:24 <paolo> ibid: what are pattern rules?
13:25:38 <ibid> paolo: stuff that help eliminate that :)
13:26:29 <ibid> paolo: in gnu make, %.hs : %.chs <newline>^Ic2hs ... $<
13:26:38 <ibid> the target is $@
13:26:42 <ibid> $z
13:26:47 <ibid> $< is the first dependency
13:26:58 <paolo> ibid: also, a.chs, b.chs, c.chs sometime differ in some part of the c2hs command (the headerfile)
13:27:12 <ibid> what headerfile?
13:27:30 <paolo> c2hs ${C2HS_FLAGS} cairo.h a.chs
13:27:37 <paolo> c2hs ${C2HS_FLAGS} cairo-pdf.h b.chs
13:27:47 <paolo> and so on, but for the most is cairo.h
13:27:58 <ibid> i'm not familiar with c2hs. what's the point of that .h?
13:28:18 <paolo> c2hs gets a .h and a .chs and produces a .hs
13:28:34 <ibid> how are the .h and the .chs related?
13:28:48 <paolo> .chs binds functions or types defined in that .h
13:29:21 <ibid> and you cannot say what .h file to use in a .chs?
13:30:07 <paolo> I didn't tought of it...
13:30:11 <paolo> Let me lookup the docs
13:30:21 <paolo> It seems so !!!
13:31:42 <ibid> then you only need to specify .h as a dependency for the .hs
13:32:49 <paolo> Hmm.
13:35:16 <paolo> Do I need to specify the paths of all the .chs or there's a way to write only the filenames?
13:37:55 <paolo> ibid: this doesn't seem enough http://rafb.net/paste/results/rbQd4611.html
13:45:30 <ibid> paolo: you need to define a default target that depends on the files that you want to make
13:45:46 <goron> ibid: unix-like? bsdmake ofcourse. On Linux gmake ofcourse.
13:46:27 <ibid> goron: even bsd's have gmake, and so do most of the sysv-based ones
13:46:41 <jlouis> and everything but linux has bsdmake.
13:46:41 <goron> ibid: not by default.
13:47:09 <ibid> depending on the value of "default"
13:47:16 <ibid> most installations i've seen have gmake
13:47:55 <jlouis> ibid: it might have something to do with the fact that 99% of all C source code is written in an inportable linux-only source and thus requires gmake
13:48:19 <ibid> jlouis: unlikely. since a lot of c was written before linux was a serious player
13:48:34 <ibid> jlouis: even gnu make predates linux
13:48:39 <jlouis> ibid: likely, since linux doesn't follow POSIX in a number of places and blends BSD, SYSv etc
13:49:20 <ibid> jlouis: it's still absurd to say that only 1 % of all c code is written on non-linux
13:49:49 <jlouis> anyway, the requirement gmake is usually because a lot of source uses the autoconf and friends which obviously relies on gmake
13:50:05 <jlouis> so it gets pulled in on the platforms
13:50:07 <paolo> OK I'll post about recursive make considered handy :-P
13:50:08 <jlouis> same with gcc
13:50:09 <ibid> jlouis: but yeah. gmake is common because virtually all unixes need gnu tools to feel comfortable
13:50:26 <ibid> paolo: tthat wasn't recursive make :)
13:50:31 <jlouis> you often see a solaris having gcc because the C source people sends have gcc-isms in it
13:50:35 <paolo> ibid: what I use now it is - gee
13:51:02 <jlouis> oh, it also holds true on HPPA
13:51:24 <ibid> jlouis: for a long time the gnu tools were the most posix-conformat of all
13:51:33 <jlouis> I know
13:51:34 <ibid> jlouis: the other vendors have improved since then
13:52:33 <ibid> anyway, this is a silly arugment :)
13:52:37 <jlouis> Also, gmake has no problem parsing most of the bsdmake syntax, so why the hassle?
13:52:54 <ibid> jlouis: because some of the gnummake only stuff are very useful
13:53:00 <jlouis> I just happen to prefer the bsdmake and mk environment a lot over gnumake/autocrap
13:53:04 <ibid> jlouis: make a lot of the pain go away
13:53:21 <ibid> mind you, i'm not an autotools camper, i try to avoid that
13:53:31 <jlouis> ;)
13:53:35 <jlouis> I can understand that
13:53:35 <ibid> autoconf is sometimes useful, but it's mostly non-evil
13:53:46 <ibid> but even it is overused
13:54:08 <jlouis> nevermind, this argument is silly. Lets hack haskell!
13:54:19 <ibid> :)
13:54:26 <paolo> Sorry :)
13:54:55 <paolo> I'll cabalize the thing and *p0f*
13:54:58 <ibid> (http://www.pcug.org.au/~millerp/rmch/recu-make-cons-harm.html)
13:56:05 <pejo> jlouis, autoconf doesn't depend on gmake afaik.
13:56:40 <paolo> Doesn't the linux source tree use recursive make?
13:57:01 <vegai> ibid: "virtually all unixes need gnu tools to feel comfortable" -- I don't know about BSD
13:57:20 <lispy_> iirc, recursive make is still effective, you just have to do it correctly
13:57:22 <ibid> meant the proprietary ones, solaris etc
13:57:31 <vegai> ah
13:57:41 <lispy_> paolo: so reading that article will help you to use make properly
13:57:57 <paolo> That's interesting.
13:58:53 <lispy_> what about ant?
13:58:57 <lispy_> that's all the rage these days
13:59:10 <jlouis> I have not evaluated ant yet
14:00:08 <lispy_> i think with ant you have to use xml for the build file. Or at least, something silly like that turned me off from using it
14:00:18 <ibid> ant feels icky
14:00:25 <ibid> i've used it once, it worked
14:00:30 <ibid> but feeled icky
14:00:48 <lispy_> the java crowed loves it, maybe they tainted it :)
14:01:12 <ibid> one wouldn't use it for anything else but java :)
14:01:49 <lispy_> so i was doing one of the nehe tuts and it feels really sluggish in haskell.  so i profiled it, but the profiling info is very....not helpful.  I think all the functions that eat up time and space were compiled as ghc libs and thus without profiling
14:05:08 <jlouis> @version
14:05:09 <lambdabot> lambdabot 3p68, GHC 6.5 (OpenBSD i386)
14:05:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:06:07 <icb> does ghc64 work on openbsd/sparc64 yet?
14:07:41 <jlouis> icb: check dons page
14:07:53 <jlouis> Maybe he got the unregisterized version up
14:08:19 <icb> okay
14:10:12 * basti_ is listening to finnish polka
14:11:37 <ibid> which?
14:12:19 <basti_> np: Eläkeläiset - Täällähan on tanssit
14:13:03 <basti_> wow even the unicode did work
14:13:33 <basti_> ibid!
14:18:20 * basti_ would love to know what the lyrics mean
14:24:33 <ibid> basti_: ?
14:25:33 <jlouis> basti_: humppa?
14:25:57 <basti_> jlouis: humppa!
14:26:00 <basti_> ibid:
14:26:01 <basti_> np: Eläkeläiset - Vanhamiljonäärihumppa
14:26:15 <jlouis> basti_: as are most OpenBSD developers!
14:26:22 <jlouis> humppa! rocks!
14:26:31 <ibid> the previous would've been täälläh_ä_n
14:26:38 <ibid> an a makes no sense in that context
14:26:50 <basti_> then the cd database is broken :(
14:27:43 <ibid> "oh, there's a dance here", "old-millionnaire-humppa"
14:27:52 <basti_> :-o
14:27:53 <ibid> no idea what humppa is in english
14:28:01 <ibid> the song titles
14:28:08 * basti_ nods
14:28:16 <ibid> the band is "the pensioners"
14:28:22 <bourbaki> moin
14:28:23 <basti_> i heard that much already
14:29:19 <ibid> do the bsd's already have a compliant c99? :)
14:30:35 <basti_> friend of mine: "that many ä are confusing"
14:30:41 <ibid> (about posix compliance)
14:30:47 <ibid> basti_: no, they're not :)
14:31:32 <basti_> ibid: how is Eläkeläiset pronounced? all vowels short and äi two distinct sounds?
14:31:47 <ibid> all wovels short
14:32:09 <ibid> i'm not sure what you mean by "äi two distinct sounds" (as opposed to what?)
14:32:30 <basti_> as a portamento
14:32:41 <basti_> german has lots of those, might not at all apply to finnish
14:32:44 <basti_> "diphtong"
14:33:11 <ibid> äi is a diphtong, but i'm not sure if the word means the same in finnish as in german
14:33:13 <ehuber> (sorry to intrude.. yes, aei is a dipthong)
14:33:26 <basti_> ah ok
14:33:36 <basti_> probably, we just dont have an "äi" diphtong
14:34:23 <ehuber> (in case you dont know already, ae is pronounced as in english 'bad' and not as used in german)
14:34:34 <ibid> finnish pronunciation is very (but not completely) regular
14:34:53 <basti_> uhm
14:35:02 <ibid> ehuber: ä and ae are very different things in finnish
14:35:07 <basti_> german uses ä, ö and ü.
14:35:25 <ehuber> sorry ibid , i dont have the german keyboard set atm
14:35:27 <ibid> but yes, ä is pronounced like the a in the english word bad
14:35:42 <ibid> ehuber: finns don't encode ä as ae
14:35:49 <basti_> just like in german. although german has problems with e/ä distinction
14:36:10 <ehuber> ibid: would you do a: ?
14:36:37 <ibid> ehuber: i'd render it as "a" unless i need to make it clear i mean ä, in which case ii say "a diaeresis"
14:36:37 <ehuber> basti_: is there an ae as in 'bad' in german at all ?
14:36:53 <basti_> ehuber: yes. its ä, and rendered ae when theres no ä available
14:36:56 <ehuber> ibid: thx (:
14:37:23 <ehuber> heh sorry basti_, i meant to ask whether the sound ever occurs as in english 'bad'
14:37:44 <basti_> very similar
14:37:54 <basti_> ä is a little more central than in bad
14:38:44 <ibid> basti_: finnish pronunciation 101: "every letter has a distinctive sound, and it is always used as it is, without change, in all words.  stress is always on the first syllable, a secondary stress on every odd syllable"
14:38:59 <ibid> basti_: of course, since that's 101, i omit some exceptions ;)
14:39:07 <basti_> .P
14:39:30 <ibid> basti_: the main ones are nk and ng
14:39:47 <basti_> hmm
14:39:56 <basti_> which are, nk and ng?
14:40:07 <ibid> hm?
14:40:31 <basti_> i mean its hard to pronounce ng or nk as distinct sounds
14:40:32 <ibid> there's one sound that has no letter of its own
14:40:38 <basti_> ng is that nasal, and nk a stop
14:40:55 <ibid> the n in nk is that sound; ng is a long version of that sound
14:41:09 <ibid> basti_: sorry?
14:41:34 <basti_> hmm
14:41:40 <basti_> "ng" in english is a nasal sound, not two sounds
14:41:55 <ibid> ng in finnish is one sound doubled
14:42:05 <ibid> a double consonant
14:42:15 <basti_> ahh
14:42:18 <ibid> i suppose the ng in english angry has the same sound
14:42:23 <ibid> but not sure
14:42:39 <basti_> -g-
14:42:47 <basti_> its fun to talk about languages without using spoken words
14:42:59 <lispy> "talk" :)
14:43:03 <ibid> oh, more of the 101: "double wovels indicate a long version of the wovel, double consonants indicate doubling of the consonant"
14:43:09 <basti_> .)
14:43:19 * basti_ nods
14:44:05 <basti_> you are so lucky with those rules
14:44:55 <ibid> there are some exceptions yet, but nothing very major
14:45:04 <ibid> with those you'll be understood in finland
14:45:22 <basti_> if i ever go there. and have some written sentences handy.
14:45:23 <basti_> .)
14:46:06 <ibid> you will also need to memorize the letter->sound mapping ;)
14:46:17 <basti_> honestly, i think learning finnish would be very interesting, because its so completely different, and at the same time not "bloody difficult" (like, for example, korean or japanese)
14:46:40 <ibid> there's a myth that finnish is very difficult
14:46:46 <ibid> the truth of that myth is debated
14:46:56 <basti_> i heard the grammar is very regular
14:47:07 <basti_> that would make it a good target. i got frustrated by french.
14:47:20 <basti_> (tons of exceptions everywhere)
14:47:35 <ibid> 14 or so cases
14:47:47 <basti_> yup.
14:47:48 <ibid> or was it 12
14:47:50 * paolo is regexp converting 300 lines of C headers to Haskell bindings via regexps - gah!
14:47:52 <ibid> something like that
14:48:21 <ibid> basti_: the morphology is much harder than english or german
14:48:26 <basti_> i can just say... in german (or french for that cause) the case suffixes depend on "person" and "genus"
14:48:32 <ibid> basti_: but the actual syntax is simpler
14:48:43 <basti_> and declination form of the verb or noun... brrr...
14:48:53 <ibid> brb
14:49:04 <basti_> mmm finnish builds bizarrely long words, yes :P
15:12:15 <metaperl> basti_: have you seen hasChorus?
15:16:07 <ibid> bah, sleep time, i think
15:16:22 <Oeje1> ibid: Sure is.
15:18:14 <basti_> metaperl: no?!
15:18:33 <metaperl> did you google it yet? it is a layer on top of Haskore...
15:19:21 <basti_> cool thing
15:19:59 <Philippa> I'd kinda like a convenient way to control a bunch of VSTis and VSTs with it
15:20:07 <basti_> mmmh :)
15:20:08 <Philippa> maybe a particularly hellish emacs mode or something
15:20:25 <Philippa> but a chance to actually make some noise
15:20:53 <Philippa> heh, a really /good/ emacs mode'd let me set up note lists and edit them as if I were using a tracker
15:20:55 <musasabi> VST ?
15:21:13 <jlouis> Visual STudio or something
15:21:18 <Philippa> steinberg's effect plugin format. The defacto standard under windows
15:21:20 <jlouis> Virtual...
15:21:43 <musasabi> ah.
15:22:18 <musasabi> Sometime I should really take some time to learn windows too.
15:22:41 <musasabi> (and I seem to be too tired to write anything resembling proper english)
15:23:22 <Philippa> IIRC somebody actually went to the effort of writing code to use VSTs from linux
15:23:30 <Philippa> they're bundled in DLLs
15:36:28 <Oeje1> Ouch, Makefiles are specified in a lazy language without caching.
15:36:59 * paolo pretends to understand and nods
15:37:19 * Oeje1 nods back.
15:37:55 <mauke> you mean everything is reevaluated and reinterpreted?
15:38:46 <liyang> but not evaluated unless it's needed.
15:39:06 <Oeje1> mauke: Exactly.  I'm reading the paper at http://aegis.sourceforge.net/auug97.pdf page 8.
15:40:36 <paolo> How would you marshal a C void * ?
15:41:09 <Oeje1> paolo: Ptr ()
15:41:48 <paolo> Thank you.
15:42:25 <Oeje1> paolo: Maybe you will find the TMR article about the FFI useful.
15:42:39 <jlouis> wrapping a C void * in a phantom type can be useful
15:42:56 <jlouis> paolo: you using c2hs?
15:44:47 <paolo> C const type doesn't need special arrangements, right?
15:44:50 <paolo> jlouis: yep!
15:45:10 <paolo> jlouis: phantom type ~= IO?  In the sense data a = Foo ?
15:45:19 <jlouis> C const type? nah, not really.
15:45:27 <paolo> OK, cool.
15:45:56 <jlouis> (just make sure you do not alter a const since the C compiler might be a tad confused then)
15:46:41 <paolo> So I have to track where the const are and take particular care anyway
15:47:01 <paolo> cairo_bool_t  sigh.
15:48:06 <jlouis> A phantom type is a type which exist only for the purpose of the user. Lets say you have two void *'ers: one for Foo objects and one for Bar objects. Just naming them Ptr () means that you can use either in place of each other. Thus you often assign phantom types to them to make them different (Foo (Ptr ()), Bar (Ptr ()). I'll see if I can dig up a line in my sources
15:48:16 <Oeje1> oejet_special_secret_integer_bool_t :-P
15:48:33 <jlouis> I do not remember if c2hs/haskell handles consts in any special way
15:48:53 <paolo> An unsigned char * is a CAString or CString is ok?
15:48:55 <mauke> typedef enum {false, true, wednesday, cheesecake} my_bool_t;
15:49:23 * paolo laughs
15:49:35 <Oeje1> CString = Ptr Char == char*
15:49:38 <jlouis> {#pointer *rawimage as RawImage newtype#}
15:49:44 <jlouis> creates:
15:49:59 <jlouis> newtype RawImage = RawImage (Ptr (RawImage))
15:50:08 <paolo> newtype RawImage = RawImage (Ptr (RawImage))
15:50:09 <paolo> yep
15:50:49 <paolo> Oeje1: are you saying there is no difference between unsigned char * and char * ?
15:50:52 <jlouis> so you can make your void *'ers different inside Haskell if they are with phantom types
15:51:12 * lispy laments the slowness of his code
15:51:37 <lispy> i'm using a mutable, unboxed array and even with -O2 my code is much slower than the corresponding Objective-C
15:52:23 <lispy> and profiling isn't giving me specific information about the slowness
15:52:51 <lispy> it points to one of my toplevel functions, but it's not giving me any information about he functions tat it is calling
15:53:41 <Oeje1> paolo: Ups, didn't see the "unsigned".
15:54:28 <wagle> can haskell tell you about more than one type error at a time?
15:54:57 <lispy> wagle: ghc can
15:55:11 <lispy> wagle: i get multiple type errors all the time :)
15:55:20 <lispy> wagle: but is tht what you mean?
15:55:44 <wagle> i didnt remember seeing more than one at a time...
15:55:54 <wagle> maybe i only have one at a time?  8)
15:56:49 <wagle> anyway, I'm trying to prototype this gui in tcl/tk, and it waits until runtime to complain about even syntax errors..  so i debug one thing at a time...
15:57:06 <lispy> ouch
15:57:13 <lispy> that sounds like perl
15:57:23 <mauke> no, perl actually compiles everything first
15:57:45 <wagle> and testing all the code paths for missing variables, type mismatches, etc takes a bit of a while
15:57:57 <wagle> perl gets at least the syntax..  8)
15:59:47 <jlouis> perl -c -w is good
16:00:21 <mauke> my scripts use warnings; anyway
16:00:45 <wagle> i use both
16:01:00 <wagle> oops..
16:01:11 <wagle> i meant i use perl -w, and use strict;
16:01:41 <mauke> use warnings > -w
16:03:19 <wagle> hmm..  hadnt seen -c before..
16:03:46 <wagle> but i'm not sure what it does with -c that it doesn't do without
16:03:48 <jlouis> good to fire into a make regress at the top
16:04:01 <jlouis> it doesn't try to execute the program
16:04:13 <jlouis> it just checks syntax and exits
16:04:22 <jlouis> plus some semantics
16:04:46 <wagle>  i thought it already refused to execute programs that weren't syntactically correct
16:05:04 <wagle> ohh.. with -c it never executes?
16:05:09 <jlouis> exactly
16:05:20 <wagle> interesting...
16:05:54 <jlouis> its perfect for SVN/Darcs and pre-commit hooks
16:06:24 <mauke> it still executes stuff that happens at compile time, like use Module; and BEGIN blocks
16:07:00 <wagle> yeah..  i looked it up in man perlrun
16:07:19 <Oeje1> Good night all.  See you tomorrow.
16:10:51 <wagle> refactoring is interesting..  i'm having a long time of it with this tcl/tk thing
16:10:57 <fnord123> hello my finish friends
16:11:29 <wagle> lots of (little transformation, test test test)
16:12:07 <wagle> i see now why "they" get so strident that refactoring replaces equal with equal
16:12:51 * paolo can't really believe it took him two hours to regexp out a C header to Haskell types decls.
16:13:10 <Philippa> it's a bit hard to concatenate refactorings otherwise
16:13:11 <paolo> I wonder if it was worth it O_o
16:13:46 <paolo> Do you know of a regexp operator to make a given char upcase?
16:14:41 <wilx> \u
16:14:48 <wilx> At least in Perl 5.
16:15:23 <paolo> My ass is solidly put on GNU Emacs atm
16:15:30 <wagle> Philippa: well, i had been concentrating on self-repair and self-improvement of programs, so was wanting stuff that went uphill, not just "stay at the same elevation"..  (plus wanting to consider fixing syntactic errors)
16:16:04 <fnord123> are there idioms for graph structures in haskell?
16:16:09 <fnord123> or shall i pick up a lib
16:17:07 <lispy> fnord123: i think haskell.org has several graph libs
16:17:29 <fnord123> oh i see
16:17:42 <wilx> Hmm, IIRC GHC has some bundled.
16:17:50 <Philippa> wagle: I'm inclined to separate refactoring from bugfixing and feature addition
16:18:20 <Philippa> that doesn't mean do all of any given one at once, but don't try doing two operations at once unless eg a refactoring will conveniently solve a bug if you just stop special-casing the situation
16:18:35 <wagle> Philippa: yeah, i agree..  i just understand now why they were so stident about the separation
16:19:02 <wagle> i empathize much more viserally now
16:19:12 <fnord123> im looking at my notes and im thinking i dont even need a graph lib actually. im not sure why i thought i did
16:19:36 <fnord123> well i guess i might. damn stupid videogame addiction relapse. i dont want to program. :(
16:20:35 <lispy> hmm...writing to this array was killing my program
16:20:55 <lispy> why are mutable unboxed arrays slow to write to element-wise?
16:21:00 <wagle> before, i would have tried to transform much more at a time..  here, i'm transforming little piece, test, little piece, test, and its much less mind and memory bending
16:21:23 <wagle> just cool to see the point^Wlight
16:22:53 <lispy> i was updating 45*45*2 floats every other frame
16:23:07 <lispy> in C it is very fast...
16:24:37 <lispy> now i just change my indexing, which made the speed comparable to the C version, but it also introduced a bug
16:25:56 <wagle> i guess i've been doing much more hacking and debugging of very large programs than writing large programs..  hmm
16:29:44 <jlouis> heh, the Lambdabot.hs code really needs a cleanup
16:32:55 <TheHunter> i know...
16:34:53 <TheHunter> any suggestions?
16:35:41 <TheHunter> an irc library should be factored out, but it's unclear to me what the best design is.
16:36:38 <lispy> TheHunter: reactive objects?
16:36:57 <wagle> <more thinking out loud> i think its that I have to debug the refactorings thats the issue..  i sorta assumed it was automatic or trivial...
16:36:59 <TheHunter> lispy, what's that?
16:37:20 <lispy> TheHunter: i've not used them, but from what I understand they let you do event handling
16:38:33 <TheHunter> you have an url?
16:39:02 <TheHunter> @google "reactive objects" haskell
16:39:04 <lambdabot> http://www.informatik.uni-freiburg.de/~heimann/rhaskell/
16:39:26 <jlouis> ok, night
16:39:33 <dons> morning. where's my coffee? ah. here it is!
16:39:42 <Pseudonym> dons: They're on your head.
16:39:46 <Pseudonym> Oh, you meant coffee.
16:39:55 <paolo> Hello dons!  Did you see the bugfix? :-)
16:40:06 <dons> paolo, yep :)
16:40:22 <TheHunter> morning, dons.
16:40:51 <dons> hey TheHunter, how's code?
16:41:14 <dons> ah, I see your code is in my inbox :)
16:41:54 <TheHunter> i think i don't trust my flood protection any more.
16:42:33 <TheHunter> @docs Control.Concurrent.Chan
16:42:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.Chan.html
16:43:06 <dons> did we have problems with it?
16:43:14 <TheHunter> apart from that, code is great.
16:43:26 <paolo> OK, I bound more or less _all_ cairo.
16:43:40 <paolo> Goodnight :-)
16:43:46 <TheHunter> i'm not sure, but i've had problems with my local lambdabot not reacting several times.
16:44:02 <dons> ah.  I think I've seen that.
16:44:35 <dons> small commands work, like @bot, but larger output isn't returned
16:45:03 <jlouis> dons: I have half a billion patches for you. Will test and send tomorrow
16:45:11 <TheHunter> i think it's not too wise to rely on System.Time's time arithmetics.
16:45:45 <jlouis> i'll pull and kill conflicts before sending
16:46:09 <Igloo> Hmm, is there a nice solution for mismatched contexts in a binding group other than upgrading GHC?
16:46:16 <dons> jlouis, good good.
16:48:37 <Igloo> Actually, I'm not even sure what a not-too-ugly solution would be. Ho humm.
16:51:31 <TheHunter> all I can think of is instead of |foo :: Foo a => f a; foo = ...|, |foo :: FooWrap; foo = FooWrap $ ...| where |data FooWrap = FooWrap (forall a. f a)|
16:52:30 <TheHunter> or maybe foo :: ((forall a. Foo a => f a) -> r) -> r
16:53:31 * Igloo has duplicated a tiny bit of code rather than stray further into non-standard stuff
16:54:39 <Igloo> In fact, only "t_table $ " needs to be duplicated, so it's not anywhere near as bad as I thought it would be
16:55:33 <gzl> what's up with the vertical lines?
16:57:41 <lispy> gzl: i blame TheHunter ;)  if you're talking about what i think you are, then it's just meant to visually delimit code in text
16:58:21 <TheHunter> ah, i didn't get that the question was adressed to me.
16:58:59 <TheHunter> It's the lhs2tex way of quoting code.
16:59:11 <lispy> TheHunter: i don't know that it was aimed at you
16:59:28 <lispy> but you're the person that gave me the idea, and i loooks like igloo is doing it too
17:00:02 <TheHunter> it's certainly better than using "'s
17:00:08 <lispy> oh, wait
17:00:15 <lispy> maybe igloo didn't do it
17:00:20 * lispy can't read
17:00:37 <TheHunter> i also copied it from someone else, but i don't remember from whom.
17:02:59 <gzl> lispy: ah, ok
17:03:10 <gzl> I thought it might have been some weird new language extension
17:03:42 <lispy> heh
17:03:45 <lispy> that's possible
17:14:01 <TheHunter> @docs Control.Concurrent.Sem
17:14:02 <lambdabot> Control.Concurrent.Sem not available
17:14:12 <TheHunter> @docs Control.Concurrent.QSem
17:14:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.QSem.html
17:20:18 <lispy> is there any way in haskell to do efficient mutation of large arrays?  Do I need to use ffi for this?
17:20:50 <TheHunter> dons, what's your position on TVars in lambdabot?
17:24:08 <lispy> does ML or ocaml allow for modification of state?
17:25:42 <mauke> yes
17:26:06 <mauke> OCaml has mutable reference cells, which are used to implement a general ref type
17:26:23 <lispy> is it fast?
17:26:54 <lispy> i was using a mutable unboxed IO array, and it's painfully slow to update
17:27:49 <mauke> I think so
17:31:10 <TheHunter> dons, nevermind, i'm using a pair of QSems.
17:31:24 <TheHunter> they're probably better in this situation anyway.
17:34:37 <TheHunter> oh, i see i was never believed my solution to be very reliable, as witnessed by this comment:
17:34:44 <TheHunter> -- discarding picoseconds is inacceptable here, therfore we can't use AltTime
17:34:44 <TheHunter> -- and instead pray that we won't be bitten in the ass by one of System.Time's
17:34:44 <TheHunter> -- bugs.
17:35:52 <dons> hehh!
17:43:02 <TheHunter> @dynamic-load wtf?
17:43:03 <lambdabot> module loaded
17:49:53 <TheHunter> hmm, does changing the gcc version affect dynamic loading?
17:50:04 <TheHunter> with hs-plugins, that is.
17:56:50 <dons> hmm. possibly.
17:57:32 <dons> you might end up with incompaible object files
17:57:47 <TheHunter> yep, i think that's what happened.
17:58:18 <dons> on your box?
17:58:39 <TheHunter> yes.
17:58:48 <TheHunter> distclean fixed it.
18:12:49 <TheHunter> the problem seems to be in the reader loop, not in the writer one..
18:26:56 <Philippa> any folks with TMR access awake?
18:28:14 <TheHunter> yes.
18:31:14 <Philippa> I just knocked up part of an article on possible subtyping for haskell (much of the same old I've been talking about in here for a couple of years). Fancy looking over what I've got so far?
18:31:41 <Philippa> It's very much first draft material, as I'm not entirely sure I trust my sleep-deprived over-caffeinated state of mind right now...
18:32:10 <TheHunter> reading, right now.
18:32:14 <TheHunter> @timein London
18:32:17 <lambdabot>  Monday, August 15, 2005 at 2:33:19 AM BST
18:33:41 <Philippa> I'm only really badly sleep-deprived because of the number of minor maladies I've picked up during and since CCDE
18:37:47 <TheHunter> |data List a > Cons, Nil| should this be |... > Cons a, Nil a| ?
18:38:41 <Philippa> no, because the kinds have to match
18:38:47 <Philippa> so it'd be syntactically redundant
18:39:06 <Philippa> you'd be right if that restriction were lifted though
18:39:25 <Pseudonym> Errr... but they don't match.
18:39:38 <Pseudonym> List a has kind *, but Cons has kind * -> *
18:39:40 <TheHunter> what about |data List a > Cons, Nil|, then.
18:39:51 <TheHunter> err, |data List > Cons, Nil|
18:39:55 <Philippa> Pseudonym: List, however...
18:40:08 <Pseudonym> Did you mean to write:
18:40:12 <Pseudonym> data List > Cons, Nil
18:40:15 <Pseudonym> Or is this correct:
18:40:17 <Philippa> TheHunter: you need a name for the type variable if List has its own constructors
18:40:19 <Pseudonym> data List a > Cons, Nil
18:40:35 <Philippa> I meant "data List a > Cons, Nil", and IIRC that's what I wrote
18:41:03 <TheHunter> maybe you should elaborate on the relationship to ocamls polymorphic variants (though i don't know exactly what these are).
18:41:20 <Philippa> nor do I. You're right though, because there are some critical differences
18:41:37 <Philippa> they're doing structural subtyping, I'm not
18:42:28 <shapr> Oh yeah?
18:42:39 <Igloo> What is the type of Cons there?
18:42:59 <Igloo> And which of List, Cons and Nil does the above define?
18:43:15 <Philippa> the above defines List, requiring definitions elsewhere for Cons and Nil
18:43:31 <Philippa> Cons-the-data-constructor has type a -> List a -> Cons a
18:44:00 <Igloo> And the Cons up there is Cons-the-data-constructor, right?
18:44:21 <Philippa> the Cons in the data declaration is Cons-the-type-constructor
18:44:28 <Igloo> Can you do type inference with this?
18:44:37 <Igloo> "up there" being in the "data List a > Cons, Nil"
18:44:49 <Philippa> Partial. If there's a lub of two types, it works. If not, an annotation works wonders
18:45:01 <Philippa> (a lub of two types you need to unify, that is)
18:45:14 <shapr> Ok, it's halfway through the month, time for me to bug people about TMR articles
18:45:26 <shapr> Pseudonym: Hey, think you'll have one of your articles ready this month?
18:46:24 <Philippa> I've not coded it up with type classes, I've got it working without (though I have a slightly different relationship between data constructors and type constructors currently)
18:46:55 <TheHunter> The "Type classes are a little trickier..." section seems a little short. It is especially unclear to me what happens when the 'type-class-variable' is used in a method at a contravariant position.
18:48:10 <Philippa> Erk. Lemme give that some thought - my gut feeling is it works out and that's why I missed it, but I've been wrong before
18:48:23 <Philippa> better yet, lemme give that some thought some time other than tonight
18:49:19 <shapr> Philippa: Hey this is a cool article.
18:50:37 <TheHunter> dons, the problem doesn't seem to be related to the writer. For some reason, the hGetLine in the reader appears to block.
19:03:45 <Igloo> Hurrah, MIME parsing basically done
19:03:56 <shapr> w00!
19:04:01 <shapr> Do you have QC tests for the code?
19:04:07 <Igloo> no
19:04:13 <shapr> Is the code online?
19:04:24 <Igloo> But hunit tests would be better, IMO  :-)
19:04:35 <shapr> Well, I prefer QC myself.
19:04:48 <lispy_> Igloo: what are you working on?
19:04:48 <Igloo> It's in http://urchin.earth.li/darcs/ian/bts
19:04:56 <shapr> Ok, thanks.
19:05:59 <Igloo> Doing the obvious thing with QC will check lots of trivial stuff, e.g. checking both "foo" and "bar". You might be able to get it to test various combinations of the corner cases with a bit of thinking, though
19:06:22 <Igloo> lispy_: The above URL, http://urchin.earth.li/cgi-bin/ian/MIME?message=8 or http://urchin.earth.li/cgi-bin/ian/Index depending on what sort of answer you wanted
19:07:17 <Igloo> s/URL/repo/
19:07:30 <lispy_> Igloo: a bug tracker?
19:07:33 <Igloo> yup
19:07:50 <lispy_> cool
19:07:59 <lispy_> using HSP or WASH?
19:08:04 <lispy_> or something else?
19:08:04 <Igloo> No
19:08:33 <Igloo> Using nothing separate (well, except bringert's newcgi)
19:08:48 <lispy_> ah okay
19:09:00 <lispy_> will darcs use Bark?
19:09:18 <Igloo> I'll talk to David when I've got the mail interface done and the web one tidied up a bit
19:09:29 <lispy> cool
19:09:38 * lispy doesn't lke the current bug tracker
19:09:47 <Igloo> But I've given up trying to get the RT guys to make the current one nice, so this is plan B  :-)
19:09:56 <lispy> heh
19:27:10 <TheHunter> dons, this is really weird. According to ethereal, the freenode server doesn't ack the tcp frames from lambdabot, so my box keeps sending retransmission requests.
19:28:55 <dons> hmm... but lambdabot clearly works in other places.
19:30:00 <TheHunter> it works here, too. But if i @moo again and again, this strange thing happens.
19:30:35 <Igloo> You don't get RSTs either, presumably?
19:30:43 <dons> oh. maybe that's them blocking flooding?
19:31:13 <TheHunter> Igloo, no, I get nothing from some point on.
19:31:30 <TheHunter> @moo
19:31:30 <TheHunter> @moo
19:31:30 <TheHunter> @moo
19:31:30 <TheHunter> @moo
19:31:31 <thbot3>          (__)
19:31:31 <thbot3>          (oo)
19:31:31 <thbot3>   /-------\/
19:31:31 <thbot3>  / |     ||
19:31:31 <thbot3> *  ||----||
19:31:31 <TheHunter> @moo
19:31:31 <TheHunter> @moo
19:31:33 <thbot3>    ~~    ~~
19:31:34 <TheHunter> @moo
19:31:35 <thbot3>      Cow
19:31:35 <TheHunter> @moo
19:31:37 <thbot3>          (__)
19:31:37 <TheHunter> @moo
19:31:39 <thbot3>          (oo)
19:31:40 <thbot3>   /-------\/
19:31:41 <Igloo> Err, do you have to do that in here?
19:31:43 <thbot3>  / |     ||
19:31:45 <thbot3> *  ||W---||
19:32:04 <TheHunter> it's not that noisy.
19:33:35 <dons> igloo doesn't like cows :}
19:33:55 <TheHunter> i just wanted to demonstrate the problem.
19:34:18 <TheHunter> it's much easier than describing it.
19:35:07 <Igloo> Getting nothing back seems odd to me, but I guess it could be flood protection
19:35:14 <Igloo> Does LB rate-limit outgoing stuff?
19:35:26 <TheHunter> yes.
19:35:36 <Igloo> Seems unlikely then
19:35:42 <Cale> it's also possibly ignoring further moo commands while it's still printing a cow
19:35:45 <TheHunter> lb doesn't send out any more than what arrives in the channel.
19:35:57 <Igloo> Cale: The problem is no response at the TCP level...
19:36:23 <Igloo> TheHunter: eh? I mean does it restrict outgoing lines to 1/second after sending a certain number of them
19:36:30 <Igloo> Like clients do, to prevent being killed for flooding
19:36:56 <Cale> ah
19:36:59 <Cale> hmm
19:37:42 <TheHunter> it's overcautions, currently. One line every two seconds, with at most 5 lines being sent out at once.
19:38:54 <TheHunter> actually, this is exactly what the rfc specifies (RFC 2813, section 5.8)
19:39:15 <TheHunter> unless, of course, there's a programming error.
19:39:24 <Igloo> I doubt it's a flood protection thing, then
19:41:34 <TheHunter> but my feeling is that no programming error you mess up something at the tcp level.
19:43:09 <TheHunter> i'm stumped. It even happens with very aggressive flooding protection (6 seconds penalty).
19:47:31 <TheHunter> perhaps it is some kind of flooding protection, and freenode adds the traffic from both connections.
19:52:21 <TheHunter> @botsnack
19:53:03 <TheHunter> maybe we need some kind of fair queueing for different targets...
19:53:18 <dons> :/
19:53:44 <TheHunter> anyway, the real lambdabot doesn't show the problem.
19:54:28 <lambdabot> :)
19:57:08 <TheHunter> dons, could you join #uiuiui and bomb thbot6 with @moo's ?
19:59:09 * TheHunter is ashamed that he doesn't have control over another box right now.
19:59:51 <dons> thbot6? or 5?
20:00:08 <TheHunter> oh, it's thbot5
20:07:55 <TheHunter> dons, same thing as before happens, but at least it doesn't happen on your box.
20:08:44 <dons> weird.
20:08:48 <TheHunter> i'll still send you the new flooding protection code, it's much simpler (uses one thread more, however)
20:16:05 <TheHunter> OMG!
20:16:27 <TheHunter> i'm sending out incorrect checksums.
20:16:42 <TheHunter> Something's seriously messed up here.
20:18:02 <dons> double hmm.
20:18:03 <TheHunter> fwiw, Linux mthomas 2.6.12 #3 Fri Aug 5 16:53:11 EDT 2005 i686 GNU/Linux
20:18:56 <TheHunter> i should have known those black ethereal lines have a reason.
20:22:40 <TheHunter> thanks for your help, everyone.
20:50:16 <Pseudonym> Mmmm... free food.
20:50:41 <Pseudonym> Customer training => surplus food => free food for us.
21:02:45 <lispy_> @doc Graphics.Rendering.OpenGL
21:02:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics.Rendering.OpenGL.html
21:27:51 <dons> @version
21:27:52 <lambdabot> lambdabot 3p73, GHC 6.5 (OpenBSD i386)
21:27:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:44:02 <musasabi> morning
22:07:13 * dons disccovers that h4sh works really nicely from within vim and yi
22:08:28 <dons> hehe. cycle *.hs is fun
22:09:06 <Pseudonym> Phew.
22:09:12 <Pseudonym> The parent thing is really annoying sometimes.
22:09:29 <Pseudonym> Sorry, this isn't Haskell-related. :-)
23:23:37 <SM_ax> "undefined reference to __stginit_ControlziMonadziReader_" -- what linker flag do I need (if any)?
23:23:57 <ozone> tried ghc --make ?
23:24:05 <dons> -package mtl
23:24:16 <ozone> what dons said
23:25:09 <Lemmih> Good morning, #haskell.
23:25:12 <SM_ax> thanks!
23:25:25 <SM_ax> both works fine :)
23:25:33 <vikasg> morning, Lemmih
23:56:58 <musasabi> dcoutts_: any tips on debugging c2hs - in particular it dying when trying to read the .i file?
