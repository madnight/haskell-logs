00:27:27 <kristnjov_> hi
00:27:52 <kristnjov_> i'm doing a blackjack game and need a function here... let me try to explain
00:28:07 <kristnjov_> i have: data Hand = Empty | Add Card Hand
00:28:19 <kristnjov_> never mind what datatype Card is for now
00:28:43 <kristnjov_> now I need a function, removeCard :: Integer -> Hand -> (Card,Hand) which removes the n'th card from the hand
00:28:52 <kristnjov_> and returns the specific card and the rest of the hand
00:28:55 <kristnjov_> any ideas?
00:29:51 <kristnjov_> any help appreciated here.
00:31:26 <dblhelix> kristnjov: why don't you define type Hand = [Card]?
00:31:48 <kristnjov_> this is a lab excercise for school, they told us we have to do it this way
00:31:52 <kristnjov_> lousy way if you ask me.
00:32:17 <kristnjov_> for now the only code i have done is: removeCard n (Add c h) = 
00:32:24 <kristnjov_> don't know where to go from there
00:33:33 <dblhelix> krisnjov_: well, removing the _first_ card is simple, isn't it ... so why don't you first write a case for that (don't giving you a full solution, for didactic reasons ;))
00:34:03 <kristnjov_> i'm thinking recursive, recursive, recursive...
00:34:11 <kristnjov_> are my thoughts pointing in the right direction? :/
00:34:35 <dblhelix> you're thinking right ... but a recursive solution typically relies on some base cases ...
00:34:42 <kristnjov_> indeed
00:34:50 <dblhelix> induction is the magic word ...
00:35:15 <kristnjov_> induction eh?.. let me look into that.
00:35:17 <kristnjov_> thanks man
00:35:34 <dblhelix> so, why don't you split your code into two case removeCard 1 (Add c h) = ... and removeCard n (Add c h) = ... ;)
00:36:12 <kristnjov_> :>
00:36:19 <dblhelix> and then, offcourse, you need to pay some attentions to 'less interesting' cases as n < 1 and empty hands
00:36:24 <dblhelix> good luck ;)
00:36:30 <kristnjov_> thanks a lot! :)
00:36:38 <dblhelix> you're welcome
00:37:50 <kristnjov_> btw, is there a difference (any at all) between Integer and Int? this is not some excercise, just plain interest. :)
00:38:44 <dblhelix> Int is bounded: it has (implementation-dependent) upper and lower bounds
00:38:49 <dblhelix> Integer is unbounded
00:38:56 <kristnjov_> oh... cool
00:39:04 <adept> kristnjov_: yep. one of them is platform-depenent 32-bit (or 64?) int, other - unbounded Real Integere For Real Men
00:39:16 <kristnjov_> haha
00:40:50 * dblhelix thinks Real Integer is a somewhat awkward adjective-substantive combination ;)
00:43:21 <dblhelix> kristnjov_: try (minBound, maxBound) :: (Int, Int)
00:43:40 <dblhelix> @type minBound
00:43:42 <lambdabot> minBound :: forall a. (Bounded a) => a
00:43:58 <kristnjov_> so Integer is not bounded.
00:44:27 <dblhelix> no, isn't (or yes, it isn't :S) ;)
00:44:46 <kristnjov_> could someone point me to a page discussing induction?
00:46:00 <adept> kristnjov_: try wikipedia, perhaps?
00:46:18 <kristnjov_> is induction simply recursion with properties to be satisfied?
00:46:21 <kristnjov_> read: if cases?
00:47:09 <dblhelix> most introductory books on Haskell (or functional programming in general) do a good job explaining induction
00:47:26 <kristnjov_> indeed, but it's too expensive for a poor student like myself :/
00:47:46 <dblhelix> kristnjov_: what materials do you use for you course then?
00:47:57 <kristnjov_> google and lecture notes
00:48:05 <dblhelix> /s/you course/your course
00:48:08 <adept> kristnjov_: induction is more like "if we assume that some properties are satisfied for some expression parametrized by N and then given this assumption show that the same properties are satisfied for this expression parametrized by (n+1), then we could say that properties will be there for any given n".
00:48:43 <kristnjov_> ahh, the induction principle or something, we recently did that in our mathematics course
00:48:50 <adept> kristnjov_: i have some materials from my student days, but they all are in russian ;)
00:48:58 <kristnjov_> russian hacker eh? :)
00:49:20 <adept> kristnjov_: well, it depends on how you define hacker ;)
00:49:24 <kristnjov_> ;)
00:50:04 <kristnjov_> ah you're from the ukraine
00:50:12 <kristnjov_> my friends tell me i look like a ukranian hacker
00:50:19 <adept> kristnjov_: actually, yes :)
00:50:28 * adept is puzzled
00:50:34 <kristnjov_> why?
00:50:50 * adept couldn't come up with a list of characteristic properties of ukrainian hacker :)
00:51:41 <dblhelix> kristnjov: an simple inductive definition of the factorial function could be fac 0 = 1 ; fac (n + 1) = (n + 1) * fac n ; so you use 0 as a base case and define the n + 1 case relying on properties of 'smaller' cases ...
00:51:42 <kristnjov_> i would be able to tell you what one would look like if only the server on which the pic is on was up
00:52:25 <kristnjov_> dblhelix, yes, but i still can't figure out how to use it in my function. i'm used to program c++, so i'm stuck in the thoughts of for loops and global variables :)
00:53:23 <dblhelix> kristnjov_: you know you can split a function's definitions over multiple cases, don't you?
00:53:28 <adept> kristnjov_: do you know how to express "for" loop in terms of "if" and "goto"?
00:54:03 <kristnjov_> dblhelix, yes
00:54:05 <kristnjov_> adept, yes
00:54:36 <kristnjov_> adept, but the thing is that i am only to pass ONE integer to the function
00:55:45 <dblhelix> kristnjov_: the idea is to use the solution to removeCard n h in your definition of removeCard (n + 1) (Add c h)
00:56:39 <dblhelix> so if I want to pick the second card out of a hand of three, I use the fact that I know how to pick the first card out of a hand of two
00:57:18 <Jan_w> hm, has anyone used HaskellDirect, to call a haskell program from c++ (hdirect installed succesfully, but i can't get the example compiled)
00:58:09 <kristnjov_> but there is nothing in the datatype of Hand representing the 1st card really
00:58:19 <kristnjov_> the only way to remove the 1st card is through pattern matching
00:59:25 <dblhelix> I'd say that in data Hand = ... | Add Card Hand the occurence of Card is representing the first card ;)
00:59:57 <kristnjov_> this is higher-order braintwisting.
01:00:38 <dblhelix> let's be a little more concrete: assume you managed to define removeCard 1 (Add c h) = ... successfully ... that shouldn't be too hard, should it? ...
01:00:52 <kristnjov_> removeCard 1 (Add c h) = (c,h)
01:01:18 <dblhelix> then, you are to define removeCard n (Add c h) = ...
01:01:25 <kristnjov_> yep.
01:01:50 <dblhelix> and you  can use removeCard (n - 1) h at the right-hand side of the definition ;)
01:02:07 <kristnjov_> i'll try stuff out.
01:02:25 <dblhelix> okay, feel free to ask again if you need more help
01:02:31 <kristnjov_> thanks
01:03:48 <kristnjov_> btw haven't i seen you in a certain channel at efnet before dblhelix ?
01:03:59 <kristnjov_> a channel in which rndusr is an operator.
01:04:17 <dblhelix> kristnjov_: nope, never been there
01:04:23 <kristnjov_> alright.
01:14:34 <Boegel> my pc has arrived ! :)
01:24:23 <kristnjov_> i seem to be getting nowhere.
01:24:37 <kristnjov_> what does this error mean?
01:24:38 <kristnjov_> ERROR "haskell/Blackjack.hs":130 - Instances of (Random Hand, Num Hand) required for definition of shuffle
01:25:09 <kristnjov_> it's a function which is supposed to shuffle a deck of cards.
01:25:25 <kristnjov_> the deck has the type Hand
01:25:49 <dblhelix> kristnjov_: are you familiar with type classes allready?
01:26:03 <kristnjov_> only "type" and "data" if those are what you're referring to.
01:28:25 <dblhelix> nope, I was referring to another concept ... I can't imagine that you need to work with classes directly for your task ... it's a bit hard to explain classes to their full extend here ...
01:28:38 <kristnjov_> no need to. (is there?)
01:28:55 <dblhelix> is shuffle a function you wrote?
01:29:09 <kristnjov_> yes, but i barely understand it.
01:29:25 <dblhelix> can you give it's definition?
01:29:33 <kristnjov_> sure, hold a sec..
01:29:40 <kristnjov_> shuffle :: Hand -> StdGen -> (Hand, StdGen)
01:29:41 <kristnjov_> shuffle h r = shuffle (switchCards h x) y
01:29:43 <kristnjov_>                 where (x,y) = randomR (1,51) r
01:31:20 <kristnjov_> when i think about it, i think it's even wrong.
01:31:38 <kristnjov_> i'm quite sure of it being wrong...
01:32:34 <kristnjov_> did you catch my code or did chatzilla screw it up?
01:33:41 <dblhelix> no, I got it
01:33:47 <dblhelix> switchCards :: Hand -> Integer -> Hand ?
01:34:05 <kristnjov_> well it ought to be that, but I seem to have written Hand -> Hand -> Hand...
01:34:35 <dblhelix> ah, that explains the error you're getting
01:36:09 <kristnjov_> but then i have the same problem with switchCards as i'm having with removeCard
01:36:12 <dblhelix> futhermore: it seems to me that shuffle is performing a whole lot of shuffles: infinitely many
01:36:16 <kristnjov_> i don't know how to get the n'th card from a hand
01:36:32 <kristnjov_> yes i know, it's infinite, but i'll fix that later on i suppose.
01:37:16 <dblhelix> okay, then let me give you a hand with removeCard; you can implement switchCards yourself then, okay?
01:37:17 <kristnjov_> i wrote suffle Empty r = (Empty,r) just now, hoping that will fix the problem.
01:37:23 <kristnjov_> sure
01:37:51 <dblhelix> removeCard :: Integer -> Hand -> (Card, Hand)
01:38:10 <dblhelix> removeCard 1 (Add c h) = (c, h)
01:38:52 <dblhelix> removeCard n (Add c h) = (..., Add c ...) where (c', h') = removeCard (n - 1) h
01:39:25 <kristnjov_> thanks man
01:39:26 <kristnjov_> appreciate it
01:39:33 <dblhelix> removeCard _ Empty = error "removeCard: Empty"
01:40:15 <dblhelix> kristnjov_: well, you still have to fill in the blanks (...) offcourse ;)
01:40:32 <kristnjov_> indeed, but i'm quite sure about what to fill in :)
01:41:42 <dblhelix> it's important that you recognize 'the bigger idea': induction, recursion ... these are tools you will be using quite a lot when doing functional programming
01:41:55 <kristnjov_> yes, trust me, i want to learn this.
01:42:55 <dblhelix> induction is not limited to integers: consider a function that returns the number of cards in a hand ... you typically induce over the type of Hand there:
01:43:09 <dblhelix> size :: Hand -> Integer
01:43:14 <dblhelix> size Empty = 0
01:43:21 <dblhelix> suze (Add c h) = 1 + size h
01:43:30 <dblhelix> it's really the same principle
01:43:35 <kristnjov_> heh, that's actually EXACTLY the code i already have :)
01:43:53 <kristnjov_> although i didn't use "c", i have _
01:44:21 <dblhelix> well,  you're using induction on the structure of Hand there ;)
01:44:32 <kristnjov_> yeah i guess :)
01:44:46 <dblhelix> Empty makes up for your base case and Add for your inductive step
01:45:06 <kristnjov_> we've recently been taught about foldr and i'm looking forward to using it
01:45:11 <kristnjov_> functional programming ROCKS
01:45:40 <dblhelix> if you see that it's really the same pattern as we just used for removeCard, you're on your way becoming a real functional programmer ;)
01:45:50 <kristnjov_> :) cool
01:46:24 <kristnjov_> our tutor is actually john hughes
01:46:30 <dblhelix> okay, I'll have to get some stuff done myself now ... ;) ... good luck with your task
01:46:34 <kristnjov_> i wonder if one could have a bigger advantage in learning these things.
01:46:42 <kristnjov_> again, thanks a lot
01:46:44 <dblhelix> kirstnjov_: cool
01:47:17 <dblhelix> I'm quite sure you can learn a lot from him ... consider yourself lucky
01:47:29 <kristnjov_> :)
01:48:03 <dblhelix> are his lecture notes available on line somewhere?
01:48:12 <kristnjov_> sure are, just a sec
01:48:36 <kristnjov_> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/
01:48:43 <dblhelix> thanks
03:05:56 <musasabi> morning
03:09:01 <shapr> goood morning #haskell!
03:09:30 <cptchaos> good morning
03:09:31 <earthy> good afternoon, shapr
03:10:03 <shapr> oh, it is nine minutes after noon
03:10:29 <earthy> yah, just teasing ;)
03:19:27 <shapr> I'm looking forward to a new version of QuickCheck
03:19:40 <shapr> I'm glad Koen and John are doing that.
03:21:57 <shapr> has anyone used Debug.QuickCheck.Utils to test monad instances or other observable but not typechecked properties?
03:32:09 <shapr> ok, does anyone here use QuickCheck on a regular basis? :-)
03:34:31 <earthy> hm... just heard RMS was in a car accident
03:35:32 <shapr> any other info?
03:35:41 <earthy> beyond that fact only rumors
03:36:25 <earthy> 4 people in the car, 1 dead, 2 hospitalized
03:39:21 <Boegel> shapr, you there ?
03:40:35 <Lemmih> I don't get why those people on the mailing-list are so concerned about performance.
03:40:42 <earthy> other rumor has it that there's 2 deaths even
03:42:03 <musasabi> is there any link about that ?
03:42:21 <earthy> musasabi: this happened like this morning
03:42:25 <earthy> no, there is no link ;)
03:46:29 <dblhelix> earthy: who are your sources?
03:48:28 <Boegel> does anybody have experience with mobo failure ? :s
03:49:04 <earthy> dblhelix: friends of people in the car, and friends of those
03:49:54 <earthy> it happened somewhere in France... either on the way to France or on the way back... that is unclear
03:51:00 <ibid> rumours say they were on their way from SANE to Paris
03:52:27 <earthy> ah, you heard the rumours as well?
03:52:39 <ibid> yes, on #debian-devel @ OFTC
03:52:45 <ibid> different bits, though
03:53:00 <ibid> they did not have the "one dead, two hospitalized" part
03:53:20 <ibid> i have no confirmation for any of the info
03:53:25 <earthy> that's probably where the `friends of' comes from
03:53:37 <earthy> I only have confirmation for the `accident' and the `France' parts
03:54:19 <ibid> you might want to drop by and inform them of the confirmation
03:54:49 <aj> so msum [...] returns the first thing in the list that's not Nothing?
03:55:10 <shapr> Boegel: ?
03:55:31 <ibid> aj: if the list contains Maybes, i suppose so
03:55:34 <earthy> I presume the rumours'll spread through SANE like wildfire
03:56:06 <ibid> i mean, if you have confirmation, it's better to give that yourself than for me to tell them that i heard that there is a confirmation :)
03:56:36 <earthy> oh, you mean at OFTC? :)
03:56:44 <ibid> :)
03:56:46 <earthy> I think I wouldn't be believed ;)
03:58:58 <arjanb> shapr: same wiki spam again :(
03:59:56 <ibid> oh yeah, the other channel says rms is among the hospitalized
04:01:36 <earthy> yes, the rumors I hear is that a friend of one of the people announcing the rumour died.
04:02:03 <Boegel> shapr, the system I build doesn't work
04:02:07 <Boegel> i get beep errors
04:02:30 <shapr> Boegel: count the number and length of the beeps, look in the motherboard manual to see what the beeps mean
04:03:33 * shapr takes the hardware tech support to /msg
04:03:58 <shapr> arjanb: ok, I'm definitely switching to the global spam list then
04:04:31 <musasabi> How about adding human verification to the wiki?
04:04:46 <shapr> too much trouble
04:05:00 <musasabi> that is a simple "what word in the image" for anonymous edits.
04:05:06 <shapr> the whole point of a wiki is that anyone can come along and add content
04:05:23 <earthy> shapr: anyone *person*. not machine
04:05:35 <earthy> musasabi's thingy might actually be handy
04:05:36 <shapr> from the timing of the edits, I think it's often a human actually sitting at a computer somewhere
04:05:52 <earthy> yeah, you can't prevent that
04:08:14 <shapr> the current 'best practice' is to ban certain strings
04:08:32 <shapr> that's what I'll be doing next
04:36:13 <shapr> greetings oh viv at work
04:36:28 * shapr yawns
04:38:19 * Boegel bounces because he succeeded in building his first pc from scratch
04:39:01 <shapr> yay!
04:39:05 <Boegel> in only 4 hours :p
04:39:33 <shapr> H‰m‰r‰ m‰k‰r‰ k‰misi m‰h‰ss‰
04:39:37 * shapr snickers
04:39:48 <Boegel> eh ?
04:39:52 <shapr> Boegel: hey, four hours is just fine for your first PC
04:40:02 <Boegel> thx :)
04:40:10 <shapr> that was finnish for "A weird mosquito was arguing by himself in a pile of moss."
04:40:20 <Boegel> but i had a little bit of help from a guy
04:40:28 <Boegel> online that is, I built the damn thing :)
04:40:55 <tuomov> that's some strange dialect?
04:41:01 <shapr> tuomov: probably
04:41:11 <shapr> tuomov: I found it here http://www.uebersetzung.at/twister/fi.htm
04:41:27 <shapr> my favorite --> Saippuakippokukkakivikakkukoppikauppias
04:41:34 <shapr> massive palindromic finnish word :-)
04:41:41 <shapr> Soap-bowl-flower-stone-cake-box seller
04:42:02 <Boegel> that's nuts :)
04:42:09 <shapr> finnish is just too cool
04:42:28 * Boegel is putting on some music to celebrate his victory
04:43:10 * vegai wants to know what a soap-bowl-flower-stone-cake-box is.
04:43:49 <shapr> less than useful :-)
04:44:11 <shapr> let's see, ston-cake is probably dwarf bread
04:44:16 <vegai> I read from somewhere that we have over a 100 words for snow
04:44:22 <vegai> I think I know about 10
04:44:41 <tuomov> I know one :)
04:44:45 <shapr> It's easy to make unsubstantiated claims about finnish, since most people can't argue.
04:45:07 <vegai> tuomov: different forms/states of snow, obviously
04:45:14 <shapr> for example, most non-finnish people couldn't tell rakasta from paska
04:45:14 <vegai> oh no! State
04:45:43 <vegai> shapr: perhaps most Finnish can't either :-P
04:45:47 <shapr> haha!
04:45:51 * shapr laughs
04:46:09 * gabor just speaks hungarian
04:46:30 <tuomov> vegai: but all of those that I know are just compound words: pakkas-, suoja-, puuteri-
04:47:09 <vegai> tuomov: the article had mainly non-compound words
04:47:14 <vegai> like loka
04:47:18 <vegai> loska
04:47:19 * Boegel is just loving Elephant by The White Stripes
04:47:26 <tuomov> is that snow?-)
04:47:39 * vegai shrugs. Why not
04:47:53 <vegai> "snow is just water", right :P
04:54:06 <aj> so is it fair to say a monad is a collection of two bits of data, one lot that's interesting, the other lot that we'd like to ignore but can't ("state")?
04:54:30 <musasabi> no...
04:54:41 <musasabi> aj: think about the list monad for example.
04:55:32 <phubuh> snow, blizzard, avalanche, frost, flurry, ice, hardpack, powder, slush, ... :)
04:56:09 <aj> i don't understand the list monad :(
04:57:28 <earthy> aj: is that a problem?
04:57:31 <tuomov> a monad is a way to lift functions to operate on more data than they actually need
04:58:14 <ibid> loska is "half-melted snow on a road"
04:58:31 <earthy> ibid: ah, `slurrie'
04:58:46 <earthy> I can easily imagine the stuff ;)
04:59:06 <phubuh> aj: consider this function:
04:59:10 <phubuh> withAllElements [] f = []
04:59:10 <phubuh> withAllElements (x:xs) f = (f x) : (withAllElements xs f)
04:59:12 <earthy> problem is `slurrie' is somewhat more general ;)
04:59:23 <phubuh> (which has a pretty ambiguous name)
04:59:25 <ibid> i was told once that slush is kind of loska
04:59:48 <earthy> ibid: yeah, they are similar
05:00:04 <earthy> from what you just described
05:00:12 <ibid> but do you know what is a slush pile :)
05:00:40 <phubuh> and once you've considered that, ignore it, because i mistyped it
05:00:53 <phubuh> the : is supposed to be a ++
05:01:07 <earthy> ibid: Slush‚Äù is the inside term for unsolicited manuscripts, and slush stories are, for the most part, unoriginal, sloppily written, and messily presented.
05:01:17 <aj> phubuh: right, what you typed was just map, wasn't it?
05:01:17 <earthy> ugh
05:01:20 <ibid> earthy: correct :)
05:01:34 <earthy> and yes, the analogy fits. :)
05:01:43 <earthy> and the addition of pile as well ;)
05:01:57 <ibid> though most new writers are discovered from the slush pile
05:01:58 <phubuh> aj: almost - the ++ makes it (concat . map), also known as concatMap
05:02:04 <tuomov> map _is_ the monad function on arrows
05:02:14 <ibid> so it's not all bad :)
05:02:15 <tuomov> s/tion/tor/
05:02:27 <earthy> ibid: nor is the half-melted snow all bad
05:02:30 <aj> arrows?
05:02:31 <ibid> heh
05:02:45 <ibid> aj: arrows is the new fad. ignore them for now :)
05:02:47 <tuomov> thinking category theoretically
05:03:00 <phubuh> so withAllElements [1, 2, 3] (\x -> [x]) is [1, 2, 3]
05:03:26 <phubuh> withAllElements is, besides concatMap, also known as >>= when used in the list monad
05:03:49 <aj> okay, so ">>=" is "raise this function up", and "return" is "raise this element up" ?
05:04:01 <earthy> aj: something like that, yes
05:04:09 <tuomov> no, map lifts the function
05:04:31 <tuomov> >>= doesn't directly have anything to do with what monads are
05:04:40 <aj> huh?
05:04:42 <earthy> errr..?! come *again*?!
05:04:44 <ibid> no, i don't think >>= is a lift
05:04:51 <aj> isn't "having a >>= and a return" the definition of monad?
05:04:56 <ibid> but i could be wrong
05:05:03 <ibid> aj: i haskell, yes, but not in the math
05:05:10 <tuomov> >>= is not something in the category theoretical definition of monad
05:05:20 <tuomov> but I think you can get it by forming the kleisli category etc.
05:05:23 <earthy> the formulations in the math are equivalent, yes?
05:05:27 <phubuh> given that (>>=) and return support the monad laws, it is one possible definition of a monad, and the one used by haskell's Monad type class
05:05:48 <ibid> though most newbies are better served by forgetting about the math in the beginning
05:05:49 <aj> sure, but different definitions are isomorphic so what do i care if there are different ones?
05:07:29 <phubuh> anyways, say you have a list [1, 2, 3], and you want to find all possible (x, y) such that x and y are from the list
05:07:46 <vegai> ibid: s/in the beginning// (kidding)
05:08:30 <phubuh> you could map over it, and map over it again for each element, like concatMap (\x -> concatMap (\y -> [(x, y)]) list) list
05:10:15 <phubuh> or, using >>= instead of concatMap, list >>= \x -> list >>= \y -> [(x, y)]
05:10:36 <phubuh> or, using do notation:
05:10:40 <phubuh> do x <- list
05:10:42 <phubuh>    y <- list
05:10:45 <phubuh>    return (x, y)
05:10:55 <phubuh> (return x is just [x])
05:11:27 <aj> the do notation's just syntactic sugar for the >>= notation right?
05:11:31 <phubuh> yup
05:11:47 <aj> and the benefit of making []'s a monad instead of using concatMap is that you can use the syntactic sugar?
05:13:05 <phubuh> that's one benefit - another benefit is that if you have a function that works on all monads, it works on lists, too
05:14:22 <Boegel> shapr, ckech pm
05:14:28 <Boegel> *check
05:15:20 <Igloo> SPJ has merged GADTs onto the CVS HEAD
05:15:34 <kosmikus> yes. but it doesn't build for me
05:15:58 <Igloo> Well, you can't have everything  :-)
05:16:16 <musasabi> aj: consider a function like "fun perms name = databaseLookup name >>= perms"
05:16:31 <Boegel> nevermind shapr :)
05:17:55 <musasabi> now permissions could be defined as "noPerm = const mzero" "allways = return", ifSatisfies pred = \name -> if pred name then return name else mzero
05:18:32 <musasabi> now consider switching from Maybe to List (database lookup can return multiple results instead of maybe one)
05:18:42 <musasabi> Of course that won't work in real life :-(
05:18:50 <aj> heh
05:20:54 <kosmikus> Igloo: have you tried to build it yet?
05:21:43 <aj> hrm, where does "mzero" come from?
05:21:59 <aj> (MonadPlus, i know, but how does it know to use [], and not Nothing?)
05:22:55 <Igloo> Because the instance MonadPlus [a] says mzero = []
05:24:10 <aj> how about if i've got   myfun foo bar = .... mzero; and both foo and bar are MonadPlus'es, of different types, with different mzeros?
05:24:37 <Igloo> The type of mzero will be infered
05:24:48 <aj> aha
05:24:51 <kosmikus> if possible
05:25:01 <Igloo> e.g. in   myfun foo bar = if True then myfun else mzero   it will be inferred as the same type as foo
05:25:41 <aj> if bar == MyBarConst then foo else mzero; # inferred to be foo's mzero, right?
05:25:41 <Igloo> If there's nothing to constrain it it will have type MonadPlus a => a, and the type it is used with will be infered at the place myfun is used
05:25:49 <Igloo> Right
05:26:00 <aj> okay
05:26:15 <yohan> if i have a simpel tree Welcome to my ftp server: RaidenFTPD32
05:26:15 <yohan> server ip: 192.168.1.35 port: 21
05:26:15 <yohan> username: andreas password: andreas
05:26:15 <yohan> ratio 1:0 credit: 15mb
05:26:18 <aj> it might be easiest for me to just treat monad's as random group-like thing
05:26:19 <yohan> ups sorry.
05:26:26 <aj> it might be easiest for me to just treat monad's as random group-like things, with syntactic sugar
05:26:55 <aj> hrm, i wonder if i ever got taught about monads
05:27:16 <Igloo> Probably not unless you were taught category theory or Haskell
05:27:42 <tuomov> I think thinking about monads is easier using the standard category theoretical function and natural transformations
05:27:48 <yohan> i have this: data Mines = DeadEnd | Basement Room Mines Mines ...and i would like to have some sort of tracking where i am in the tree? how would one accomplish this in haskell? if i only had data Mines = DeadEnd | Basement Room Mines i could do this with an integer but now there are 2 branches...
05:27:55 <tuomov> sigh s/function/functor/ again
05:27:56 <aj> i did lots of group theory, it's near enough for the minute, coz nothing else makes sense :)
05:28:15 <tuomov> >>= is complicated..
05:28:37 <Igloo> yohan: You could have data Turn = L | R; type Position = [Turn] or something
05:28:56 <yohan> yeah i thought of that, but isnt that very bad coding?
05:29:07 <Igloo> What you want depends what you're trying to do
05:29:38 <yohan> i have an environment where a player for instance is in a position in the tree, i need to track this position
05:29:59 <yohan> i always start from the root so data turn could be good
05:31:00 <Igloo> If you could arrange it so going up means exiting from a recursive call then you wouldn't need any position info
05:31:19 <ibid> on the rms accident: http://www.wiggy.net/tmp/accident/
05:32:47 <yohan> true
05:39:36 <Igloo> kos: Did you get a failure looking for LPat in HsPat?
05:39:37 <Boegel> ibid, what happened ?
05:42:26 <kosmikus> Igloo: yes
05:42:50 <earthy> Boegel: read the website
05:44:31 <Boegel> damn
05:44:44 <Boegel> who are they ? people from #haskell ?
05:44:54 <earthy> nope
05:44:58 <ibid> Boegel: free software folks
05:45:14 <earthy> RMS == Richard M. Stallman
05:46:22 <vegai> ibid: auchie
05:48:20 <xkb> Was RMS hit as well?
05:48:48 <xkb> lso
05:48:51 <xkb> argh
05:48:52 <xkb> also
05:49:58 <Boegel> Stallman ? I know him
05:50:26 <Boegel> he's the one who defends the open source idea, right ?
05:50:54 <ibid> no!
05:50:55 <vegai> who started it, more or less
05:51:00 <vegai> oh, not open source
05:51:08 <vegai> wrong term :)
05:51:12 <ibid> say that to RMS and you'll wish you didn't
05:51:25 <xkb> Free..
05:51:26 <Igloo> See, RMS can't die. His work is not yet done...
05:51:48 <Boegel> what wrong with the term 'open source' ?
05:52:46 <ibid> Boegel: http://www.gnu.org/philosophy/free-software-for-freedom.html
05:53:04 <Lemmih> Boegel: There's a difference between open source and free software.
05:53:58 <Boegel> hmmz, okay, I see
05:54:10 <Boegel> he did a speech at our university 2 2 years ago
05:54:34 <Boegel> http://zeus.ugent.be/foto/20030210-stallman/
05:54:38 <ibid> "
05:54:38 <ibid> 	Richard Stallman was dropped off in Paris and no longer in the card
05:54:39 <ibid> 	(unconfirmed)"
05:54:40 <Boegel> last year even :)
05:55:01 <Boegel> damn, he was very lucky then
05:55:49 <tromp> @type hGetArray
05:55:50 <lambdabot> bzzt
05:56:30 <tromp> @info hGetArray
05:59:01 <earthy> ummm...
05:59:06 <Lemmih> @index hGetArray
05:59:06 <lambdabot> Data.Array.IO
05:59:16 <Lemmih> @type Data.Array.IO.hGetArray
05:59:17 <lambdabot> Data.Array.IO.hGetArray :: GHC.IOBase.Handle
05:59:17 <lambdabot> 			   -> Data.Array.IO.Internals.IOUArray Int GHC.Word.Word8
05:59:17 <lambdabot> 			      -> Int -> IO Int
06:03:56 <ibid> confirmed: rms was not in the car when the accident occurred (source: wiggy's page)
06:06:25 <tromp> thx, Lemmih:)
06:07:08 <shapr> yow!
06:07:12 <musasabi> arrays are dirty in haskell.
06:07:18 <musasabi> and complex.
06:07:21 * shapr cleans his array
06:07:35 * shapr gets rid of the square root of -1 in his arrays
06:08:07 <shapr> musasabi: I'm such a smartass :-)
06:08:31 <shapr> mmm, sinappisilli
06:08:42 <musasabi> that is tasty.
06:10:19 * Lemmih is annoyed by the lack of documentation for the DC protocol.
06:12:09 * musasabi would like to eat fish more often
06:37:59 <shapr> musasabi: coastal towns have way too much fish
06:38:59 <shapr> lule√• has fishing boats show up at the docks 5pm wednesday to friday, you can buy a kilo of extremely fresh salmon for 100 kronor.
06:39:15 <shapr> maybe it's more than a kilo
06:40:30 <tuomov> only laattakala is easy enough to prepare :)
06:40:54 <pesco> Tadda! Watch me. I'm back.
06:40:59 <shapr> I had some lovely mustard eels once.
06:41:08 <Lemmih> Welcome back pesco.
06:41:08 * shapr bounces over to pesco 
06:41:16 <pesco> Hello shapr and Lemmih!
06:41:16 <shapr> greetings from the Arctic Circle!
06:41:26 <shapr> It's time for Episode Capital Zero!
06:41:30 <pesco> How's the weather?
06:41:40 <shapr> sunny, which means it's way cold outside
06:41:41 <pesco> What is Captial Zero!?
06:41:46 <pesco> Nice.
06:41:53 <shapr> it's like Capital A, but for Zero
06:41:55 * pesco likes cold (outside).
06:42:11 <pesco> Ahah.
06:42:21 <shapr> I prefer unicycling in weather that's warmer than 5¬∞ C
06:42:28 <shapr> actually, I prefer over 10¬∞ C
06:42:28 <pesco> Well, that I can imagine.
06:42:45 <shapr> we've got about 6¬∞ C right now, but when the sun gets lower it'll drop quickly.
06:42:50 <shapr> this is the warm part of the day =)
06:42:54 <musasabi> shapr: the problem is that my gf does not like fish, so I make fish for food only when she is away on trips or somesuch.
06:42:59 <shapr> oh I see
06:43:08 <shapr> I dearly love tuna, but I don't enjoy salmon
06:43:25 <shapr> pesco: why don't numbers have capitals?
06:43:36 <pesco> Wah, I just realised I hear "oic" when I read "oh I see"
06:43:44 <shapr> heh :-)
06:43:49 <pesco> It's funny.
06:44:26 <pesco> Why don't numbers have capitals? I think the question should be, why don't numbers have lower-case!
06:44:43 <kosmikus> pesco: they have
06:44:46 <shapr> that's an excellent question, I agree.
06:44:47 <kosmikus> pesco: it's called oldstyle
06:44:54 <pesco> kosmikus: What's that?
06:45:10 <kosmikus> pesco: every good font has an expert set that comes usually with small caps plus oldstyle numbers
06:45:17 <shapr> oh, like what?
06:45:30 <tuomov> 1¬≤¬≥
06:45:33 <shapr> whoa
06:45:43 <shapr> I thought those were just superscripts?
06:45:55 <pesco> kosmikus: Then, what do the oldstyle numbers look like?
06:45:57 <tuomov> they are, and totally pointless to have in a character set
06:46:50 <kosmikus> pesco: http://www.linotype.com/1317/palatino-family.html
06:47:05 <kosmikus> look at entry number 4
06:47:19 <kosmikus> the 12345 are oldstyle digits
06:47:49 <shapr> did you put a capital number at the beginning of a bunch of digits?
06:48:01 <shapr> like one hundred twenty three as tuomov did it?
06:48:19 <shapr> or did it work like captials at the beginning of a sentence like now?
06:48:29 <shapr> aka, what good is a capital zero?
06:48:50 <shapr> tuomov: what's a laattakala?
06:49:12 <pesco> kosmikus: Yes, how does the usage of oldstyle digits differ from "newstyle"?
06:49:13 <shapr> only three google hits
06:49:17 <kosmikus> pesco: you can also run the file "\oldstyle 1234567890\bye" through tex (not latex)
06:49:18 <tuomov> fish frozen and cut into tiles (=laatta)
06:49:27 <shapr> oh
06:49:29 <tuomov> cod, I think, usually
06:49:31 <shapr> fish fingers?
06:49:32 <tuomov> fish fingers etc.
06:49:49 <shapr> I always thought fish fingers is a name worthy of something I would think up.
06:49:51 <shapr> like fish feet
06:49:57 <kosmikus> pesco: oldstyle figures are designed in such a way that they blend well with surrounding text
06:49:58 <shapr> or capital zero
06:50:33 <kosmikus> in principle, one should thus use them for numbers occurring in running text, like year numbers
06:50:45 <kosmikus> in tabulars, one should use newstyle digits
06:50:46 <shapr> coelanth toes
06:50:54 <pesco> kosmikus: I see.
06:51:05 <pesco> Thanks for the enlightenment!
06:51:31 <shapr> kosmikus: you are a font of knowledge ;-)
06:51:33 * shapr snickers punnily
06:51:39 <kosmikus> in practice, alsmost no-one uses oldstyle nowadays, but I think that's more because most computer fonts don't have them, or if they have them, people don't know how to get them, than for other reasons
06:51:52 <pesco> I'd suspect likewise.
06:52:13 <shapr> I wish linux had better support for truetype concatenation
06:52:29 <shapr> or maybe I wish tengwar fonts had support for that
06:52:45 <kosmikus> what's truetype concatenation?
06:52:54 <shapr> it's where one letter shows up on top of another
06:53:11 <shapr> it's really useful with tengwar fonts where the vowels go above the consonants
06:53:19 <kosmikus> like an accent?
06:53:19 <pesco> What is tengwar?
06:53:24 <shapr> http://www.scannedinavian.org/~shae/emacstengwar.jpg
06:53:45 <shapr> thing is, most tengwar fonts fake it by giving a massive kerning offset
06:53:55 <shapr> which irritates many programs, including emacs
06:54:16 <kosmikus> right, I'd be surprised if truetype directly supports this sort of thing
06:54:39 <shapr> with emacs, if you type a letter that have a kerning offset such that it writes on top of the letter before it, emacs only draws the most recent letter, and you have to hit C-l to see both of them
06:54:55 <shapr> the ttf concat support does make that work, but I've only found one font that supports concat
06:55:10 <pesco> Truetype is just a font format, isn't it? What does it have to do with the rendering?
06:55:27 <shapr> you can make new letters by smashing two on top of each other
06:55:33 <kosmikus> quite a lot
06:55:48 <kosmikus> the font file should contain all information that's required to render a font
06:56:32 <pesco> That's true. Oh you mean, you need the information where to exactly place the overlayed character?
06:56:53 <kosmikus> yes, and you need a concept of composite characters at all
06:57:28 <pesco> Ok.
06:57:50 <kosmikus> I'm not sure, but I think both Type1 and TrueType actually lack that
06:57:51 <shapr> I tried setting my gnome fonts to tengware
06:57:58 <kosmikus> all accented characters are separate glyphs
06:58:01 <kosmikus> for instance
06:58:06 <shapr> very few applications behave well with tengwar fonts.
06:58:16 <shapr> linux is not ready for elvish.
06:58:27 <shapr> Quenyix is barely on the horizon.
06:58:30 <tuomov> supporting all sorts of writing systems is too complicated
06:58:35 <kosmikus> and kerning is the only sort of information you have to specify rendering of combinations of glyphs
06:58:58 <shapr> tuomov: does ion support Quenya? ;-)
06:59:06 <tuomov> what's that?
06:59:18 <shapr> JRR Tolkien's Elvish language.
06:59:32 <shapr> lemme guess, you don't get many requests for Quenya support in Ion?
06:59:52 <tuomov> it can display utf-8 characters if you fonts that support them
06:59:59 <tuomov> but no support for right->left writing etc.
07:00:08 <tuomov> +have
07:00:12 * shapr decides now is the time to upgrade to ion3
07:00:40 <tuomov> ion2 already has the support, but you must be using an utf-8 locale and pass -i18n
07:00:52 <shapr> oh, hm
07:01:00 <shapr> well, I'll port my configs to ion3 first
07:01:24 <shapr> kosmikus: have you had time to try ion3?
07:01:44 <tuomov> oh and composed characters may not always work well
07:01:55 <shapr> I'm very happy with the FloatWS that's new in ion2
07:02:14 <tuomov> Ion only understands code points, anything else and you need a library as large as the whole program
07:02:19 <shapr> means I can use window-happy apps like gimp without needing to swap wms
07:02:28 <tuomov> unicode sucks in that respect
07:02:29 <adept> shapr: I use ion3
07:02:42 <shapr> tuomov: do you use ion3? ;-)
07:02:45 <tuomov> no
07:02:48 <shapr> really?
07:02:52 <shapr> what do you use?
07:02:54 <SyntaxLaptop> hi shapr how's life
07:02:54 <tuomov> ion2
07:02:58 <shapr> why?
07:03:02 <shapr> greetz SyntaxLaptop 
07:03:10 <tuomov> easier to develop ion3 when you're not actually using it
07:03:14 * shapr laughs
07:03:34 <pesco> tuomov: Ah, you're the author of Ion! Thanks very very much for it!
07:05:39 <shapr> tuomov: yes, thanks for Ion :-)
07:14:47 <kosmikus> shapr: not yet
07:14:52 <kosmikus> it's installed though
07:45:20 * Maddas pokes shapr 
07:45:27 <Maddas> :-)
07:48:32 <shapr> Maddas: y0 y0
09:06:00 <stepcut> is there a BNF grammar for BNF? (if that makes any sense...)
09:06:44 <kosmikus> is this a theoretical or a practical question?
09:07:16 <stepcut> just a curiosity
09:07:20 <ibid> stepcut: of course there is
09:07:26 <ibid> or at least can be written
09:07:50 <stepcut> ibid: i suspect it can be written, I just was not able to coerce google into producing the answer :)
09:07:55 <ibid> (the EBNF IS has an EBNF grammar of that particular EBNF variant)
09:09:32 <stepcut> (found it)
09:11:07 <ibid> ok, i can stop writing one :)
09:12:02 <stepcut> chapter 8 of the EBNF iso standard shows an example of EBNF in EBNF :p
09:13:51 <ibid> as i said :)
09:15:22 <stepcut> yes
09:44:39 <shaleh> morning all
09:45:02 <Maddas> Hi
09:45:21 <shaleh> is anyone here familiar with Hal Daume's tutorial?
09:45:29 <shaleh> I am stuck on one of his excercises
10:00:31 <kosmikus> Igloo: fyi: I now get a build error in stage2 for DLPrim.o
10:00:40 <Igloo> Ta
10:03:52 <tromp> what's the exercise?
10:15:51 <Igloo> Does anyone know the nhc equivalent of "ghc-pkg --config-file package.conf -a < q.conf"?
10:16:08 <stepcut> does anyone know of a command-line argument parsing (like getopt) that will automatically generate bash completion code ?
10:16:52 <lmbdwr> try 'set autolist' 
10:17:11 <lmbdwr> ahha
10:20:11 <shaleh> is anyone here familiar with Hal Daume's tutorial? I am stuck on one of his excercises?
10:20:42 <Igloo> Explain your problem and someone might help
10:21:48 <shaleh> Igloo: sure (-:
10:22:38 <shaleh> he asks you to create a data type called 'Quadruple'. The fun part is it is supposed to have 4 items, the first two being of one type and the second two being of another type
10:23:05 <shaleh> I was thinking data 'Quad a a b b' would work, but it seems not.
10:23:41 <Lemmih> You only need to specify two types.
10:23:59 <stepcut> shaleh: on the left side of the = you are declaring with type variables you plan to use on the right side, so you only need data Quad a b = ...
10:24:19 <stepcut> s/with/which/
10:24:41 <tromp> data Quad ab = Quad a a b b
10:24:56 <shaleh> right, I see
10:25:02 <shaleh> that was not what I was expecting
10:25:10 <tromp> oops, data Quad a b = Quad a a b b
10:25:12 <stepcut> :p
10:27:13 <shaleh> thanks all
10:35:52 <pesco> What
10:36:07 <pesco> I see.
10:38:18 * pesco inspects his molecular integrity.
10:38:34 <pesco> Is this me? Is my butt in the right place?
11:11:19 <shapr> anyone has used Debug.QuickCheck.Utils to test monadic properties?
12:15:52 <shapr> yow!
12:16:01 <shapr> EGGSITEMENT!
12:16:10 <Maddas> :-)
12:23:55 <pesco> @arr
12:23:55 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
12:24:30 <kristnjov> cornholio, mayhap!
12:24:39 <kristnjov> eheee hehehe!
12:26:02 <Philippa_> somebody has /got/ to write some better docs for Text.Html, there's a few bits that're a real PITA to figure out...
12:26:06 * shaleh wonders what is in the koolaid and why he didn't get any
12:26:11 <Philippa_> (I might volunteer if I actually knew how it worked!)
12:26:38 * pesco requests koolaid.
12:28:11 * shapr makes koolaid
12:28:18 <shapr> I actually have a bunch of koolaid here.
12:28:25 <kristnjov> COOL aid?!??!
12:28:28 <kristnjov> that's so radical!
12:28:59 <shapr> actually, kool-aid
12:29:05 <pesco> Wow. I didn't go to work today, because I didn't have to. I studied some math at home.
12:29:44 <pesco> I also skimmed a paper on rasterization in n dimensions.
12:30:13 <pesco> Apart from that I cleaned up my appartment a bit.
12:30:27 <phubuh> ooh, is that paper on the internet?
12:31:10 <pesco> phubuh: Yes, it's titled "On Curve Rasterization in n-Dimensional Space", by Charles Wuethrich.
12:31:15 <phubuh> thanks
12:32:02 <pesco> Anyway, I still feel uneasy, as if I had skipped school or something. Just because I didn't leave the house.
12:32:22 <pesco> I'm conditioned. This is troubling me.
12:32:29 <shapr> I'm air-conditioned.
12:32:35 <pesco> Wow!
12:32:38 <phubuh> go out and run around for a while
12:32:46 <pesco> Yes, I think I'll do that.
12:33:02 <pesco> See you in a bit.
12:33:13 * pesco goes air-conditioning.
12:43:13 <XTL> Finally the sauna heats a bit better (less stones)
12:43:53 <shapr> yay!
12:44:50 * XTL is feeling mildly done after karate and sauna
12:45:06 <kristnjov> me too, although i've been playing athens 2004 on ps2 :P
12:46:08 <XTL> There's some food and tea. If only I felt like stepping on my feet
12:49:09 <Philippa> XTL: nice combination of activities - figure at least it stops you getting cramps...
12:50:56 <XTL> Don't know if sauna is much of an activity :) But hopefully.  Tomorrow it'll be bujinkan.
12:53:59 * Philippa googles - myself I've done a bit of various kung fu styles and a little t'ai chi
12:54:53 <Philippa> ah, fair enough. I've a couple of friends who do or have done variations thereof - they're all a bit nuts, but worth crosstraining with
12:55:54 <XTL> I found out there's some people here. They're just starting. Funny thing was they also have a channel on ircnet :)
12:57:12 <Philippa> heh
12:57:18 <XTL> Maybe Niina will stop complaining that I never get up from this chair :)
12:57:42 <Philippa> I keep meaning to get back into training - I'm a bit unsure where I want to go next though
12:58:36 <Philippa> I originally started out of pseudo-intellectual curiosity, but self-defence is increasingly a reason to carry on which is kinda scary tbh - I'm already at the point where I can handle most folks
13:00:32 <Philippa> bah, this quickie wiki clone is /begging/ for hs-plugins
13:00:45 <Philippa> though I guess just running it via hugs and replacing the page generation modules'll do
13:02:19 <XTL> I've been trying to catch up on the cafÈ archives. I wish there was more time to do interesting things.
13:05:27 <shapr> greetz stepcut 
13:06:25 <stepcut> greetz
13:09:40 <shapr> Graham Klyne just wrote a really great quote to the mailing list
13:09:57 <stepcut> which list ?
13:09:58 <Philippa> yeah?
13:10:02 <kristnjov> the mailing list
13:10:05 <kristnjov> the list of mailing..
13:10:17 <stepcut> [Mailing]
13:10:20 <shapr> He totally described how I so often feel when I start asking experience Haskellers about code I've written.
13:10:31 <shapr> "Hmmm... I feel like a (intellectual) bull-in-a-china-shop here.  I'm blundering about on the trail of a delicate and elegant idea that I'm sure others could dissect far more clearly."
13:11:30 <shapr> He says that when Tomasz shows his streamIterate to be a variant of foldl.
13:11:45 <stepcut> heh.
13:13:01 <shapr> 1. I write a bunch of Haskell code that does something. 2. I realize I've rewritten a bunch of general and special cases of Prelude functions 3. I remove half the code, tremendously improving speed and memory usage in the process.
13:13:20 <stepcut> haha
13:13:42 <shapr> Then if I'm feeling really brave I ask Igloo to look at the resulting code.
13:13:53 <stepcut> hah
13:14:36 <Philippa> I take it the prelude functions come in for special optimisation?
13:14:37 <musasabi> But the problem remains that there is no efficient way to iterate over a large file.
13:20:39 <stepcut> is there someway to do something like this: caseM (return True) of True -> "true" ; False -> "false"
13:21:05 <stepcut> I alwsay have to do: b <- return True ; case b of ....
13:34:40 <Philippa> do you need b?
13:34:50 <Philippa> case True of True ->...
13:34:53 <Philippa> same as anywhere else
13:35:00 <Philippa> the entire case bit can be a pure function
13:37:36 <Philippa> the one that gets me is when you're working on impure stuff - I suspect you'd need Template Haskell to frig it up :-(
13:43:07 <Boegel> hello everyone
13:43:58 <Lemmih> Hey Boegel
13:45:23 <Boegel> pretty quiet here again...
13:51:00 <Lemmih> How can I convert a string to a list of Word8?
13:54:34 <Boegel> no idea dude
13:54:43 <Boegel> and everybody else i fast asleep I believe :p
13:54:53 * Boegel excuses for 'dude'
13:56:03 <Philippa> Lemmih: is there a function "ord" or similar?
13:56:28 <Lemmih> @type Data.Char.ord
13:56:29 <lambdabot> Data.Char.ord :: Char -> Int
13:57:16 <Philippa> that's your starting point. Oh, and welcome to i18n hell :-)
13:57:23 <shaleh> (-:
13:57:33 <Boegel> which i18n ?
13:57:47 <Boegel> (I'm being curious again :p)
13:57:53 <shaleh> internationalization
13:57:57 <shaleh> i 18 letters n
13:58:09 <Boegel> I know what it stands for :p
13:58:17 <Boegel> oh, do you mean me Philippa ?
13:59:53 <Philippa> no, I meant Lemmih, assuming it matters
14:00:16 <Philippa> as Char -> Word8 conversions depend entirely on what character set you want your Word8 to represent
14:01:50 <Boegel> oh, that way :)
14:18:55 <pesco> Lemmih: You still there.
14:18:56 <pesco> ?
14:19:49 <pesco> Re String->Word8, there is a UTF-8 encoder in the haskell-i18n repo, which I wrote.
14:20:23 <pesco> http://www.sf.net/project/haskell-i18n should be the URL I think.
14:29:26 <Boegel> damn, it's _really_ quiet here tonight
14:29:48 <pesco> True.
14:30:26 <shapr> so
14:30:33 <shapr> let's talk about something!
14:30:59 <shapr> any QuickCheck users here?
14:32:23 <pesco> Yes, but I've never used it for any monadic stuff.
14:32:26 <Boegel> no :p
14:34:01 <pesco> However, Last time I checked, the Generator library had a flaw (splitting a StdGen every time a new random number was needed). But that was a long while ago.
14:38:45 <Boegel> pff, I'm so tired :(
14:39:15 <stepcut> me too, good think my chair reclines
14:39:27 <stepcut> s/think/thing/
14:46:15 <Boegel> and I'll have a tough weekend
14:46:24 <Boegel> tomorrow evening: party
14:46:36 <Boegel> sat: helping with a beach marathon
14:46:41 <Boegel> sat eve: party
14:46:51 <Boegel> sun: visiting a company
14:46:54 <Boegel> pff :(
14:51:18 <shapr> yowhow
14:51:22 * shapr wibbles
14:51:29 <pesco> Oh, what is it?
14:51:38 <shapr> just general happiness
14:51:43 <pesco> Cool.
14:51:53 <shapr> I'm trying to effectively mix eXtreme Programming and Haskell
14:52:00 <pesco> Cool.
14:52:10 <shapr> I need to improve my one-button testing, make it zero button.
14:52:27 <pesco> Heh.
14:52:39 <shapr> I was thinking about fam
14:52:42 <shapr> any better ideas?
14:52:56 * pesco thinks.
14:53:52 <pesco> Actually, fam should be pretty sensible.
14:54:19 <pesco> If test on every save is really what you want.
14:54:49 <maihem> Could semantic in emacs be told to build and run a test-suite on every successful parse?
14:54:50 <shapr> yah, I think that's what  want.
14:54:58 <phubuh> if you have a new cool kernel, you could use inotify
14:54:59 <shapr> yes, probably so
14:55:22 <shapr> never heard of inotify, $(google inotify)
14:55:25 <phubuh> fam uses a file descriptor for each monitored file, so each process can only monitor a thousand or so on linux :/
14:55:33 <shapr> oh, yuck
14:55:50 <phubuh> and i guess you can't unmount file systems with fam-monitored files
14:56:15 <pesco> It also doesn't work on some sorts of file systems, AFS for example.
14:56:16 <shapr> probably true
14:56:47 <shapr> I could just use emacs' save hook, but I'd rather write up an editor agnostic process.
14:56:56 <pesco> Sure.
14:57:54 <shapr> anyone tried my one-button HaskellMode unit-testing? 
14:58:11 <shapr> oh, I guess zero-button testing would totally subsume that.
14:58:13 <pesco> No, is that for emacs?
14:58:18 <shapr> yes it is
14:58:20 <shapr> http://www.haskell.org/hawiki/HaskellMode
14:58:23 <shapr> bottom of the page
14:58:41 <maihem> why not do it in darcs? so you commit a change to some tree and it is tested. when the tests meet some defined criteria, the changes are pushed up to your main repo?
14:58:45 <pesco> I'm not using emacs currently.
14:58:46 <shapr> I just thought about that
14:59:12 <shapr> is darcs test called with darcs record?
14:59:18 <shapr> I vaguely recall that it is
14:59:22 <pesco> I think so, too.
14:59:30 <pesco> I've used it with Pesco.Cmdline.
14:59:31 <shapr> does it cancel the commit if the tests fail?
14:59:35 <pesco> Yes.
14:59:41 <shapr> ok, that's even better :-)
14:59:44 <shapr> but
15:00:17 <shapr> I prefer thirty second cycles of write test, run test to make sure it fails, then write code and run test to see if it all passses
15:00:24 <shapr> or up to two minute cycles
15:00:37 <shapr> anything longer and I realize I'm working on an oversize chunk
15:01:15 <shapr> hi wkornew 
15:01:18 <wkornew> hi :)
15:01:21 <shapr> want to learn Haskell? :-)
15:01:23 <pesco> Well, I'm off to bed.
15:01:28 <shapr> g'night pesco 
15:01:29 <pesco> G'night everyone.
15:01:31 <Philippa> shapr: give or take the "how do I refactor it this time?" I agree entirely :-)
15:01:31 <Maddas> Good night, pesco
15:01:39 <wkornew> no, want to port it finally (still compiling on damn Linux to get those damn HC files ;)
15:01:40 <Philippa> well, that or "which library functions do I need?" sessions
15:01:49 <shapr> wkornew: port it to BSD 5?
15:02:03 <wkornew> no BeOS
15:02:06 <shapr> oh, neat
15:02:13 <shapr> oh yeah, you were talking about sendmail
15:02:18 <wkornew> right
15:02:21 <shapr> shouldn't be a problem to get it working with something else
15:02:28 <wkornew> that's not the problem
15:02:33 <shapr> in fact, it doesn't really call sendmail
15:02:39 <shapr> oh, what's the problem?
15:02:53 <wkornew> does anyone have some ready-to-use HC files package (FreeBSD and/or Linux)?
15:03:11 <shapr> I don't know of a pre-built .hc package, but I would like that.
15:03:31 <wkornew> my machine is slow and I have to compile all day long to get at least to the point of trying to compile under BeOS
15:03:32 <shapr> dons: hey, how hard to make a generic .hc generator for arbitrary Haskell apps?
15:04:05 <shapr> would be even cooler if you could compile up some .hc files just for darcs.
15:04:30 <shapr> you could ask on the ghc-users mailing list
15:04:35 <shapr> someone might have a bunch
15:04:42 <wkornew> I already have, but got no answer
15:04:49 <shapr> oh
15:04:58 <wkornew> well, I asked ten hours ago, maybe
15:05:09 <shapr> oh, it might take 24 hours to get a response
15:05:30 <shapr> not many GHC experts, and those who exist are usually working on GHC rather than reading their mail :-)
15:05:41 <wkornew> yes :)
15:06:10 <tic> wkornew, didn't know you were a Haskell user. :)
15:06:17 <shapr> oh, you guys know each other?
15:06:23 <wkornew> could you find the darcs bug?
15:06:23 <shapr> oh right, tic the BeOS addict
15:06:32 <tic> shapr, yessir!
15:06:38 <wkornew> tic, hey, the world is small! ;)
15:06:50 <tic> wkornew, indeed it is. :)
15:07:13 <wkornew> why did you not port Haskell over to BeOS if you are here so often? :)
15:07:55 * Philippa can't believe it
15:07:59 <wkornew> shapr, could you at least reproduce the bug?
15:08:02 <Philippa> I'm too worn out to write a trivial parser in Haskell
15:08:05 <Philippa> guess I must be tired :-)
15:08:07 <tic> wkornew, "haskell" ?  I did port hugs.
15:08:15 <tic> wkornew, it's trivial; just type make && make insntall.
15:08:27 <wkornew> hugs? is it on bebits?
15:08:46 <wkornew> is hugs able to compile darcs?
15:09:11 <shapr> hugs is an interpreter
15:09:37 <tic> ghc I don't know about...  but I assume it'll be as easy to port.
15:09:52 <tic> (I did port it in a GG sandbox, so it might not compile out-of-the-box)
15:10:09 <wkornew> GG?
15:10:34 <wkornew> even if it is easy to port, it will compile until next morning :)
15:10:44 <shapr> GHC is big.
15:11:09 <wkornew> shapr, could I use a different haskell compiler for darcs?
15:11:15 <shapr> I don't think so
15:11:22 <shapr> plus GHC is very spiffy too
15:12:13 <shapr> I don't know if darcs builds with nhc
15:12:14 <shapr> it might
15:12:19 <wkornew> shapr, sorry to ask again, but could you reproduce the bug? is it a bug at all? should I post it to the author (or are you the author? ;)
15:12:31 <shapr> I am not the author of darcs, would that I were so cool ;-)
15:12:40 <shapr> I am not yet sure it's actually a bug
15:13:42 <wkornew> it could as well be some fail-safe mode... :)
15:18:25 <shapr> ok, upon further reading, that sure sounds like a bug
15:18:29 <shapr> lemme try it out locally
15:18:34 * shapr swaps to #darcs
15:20:46 <wkornew> bye here
15:44:02 * shapr boings
15:45:50 * stepcut hOps
15:45:58 <shapr> heh
15:46:33 <stepcut> i hope to design the ultimate command-line parsing argument library during the next 6th months...
15:46:51 <shapr> have you checked out pesco's lib?
15:47:29 <stepcut> no, but that is step 1, study all the existing libraries, and study existing programs that have 'extreme' parsing needs
15:47:35 <stepcut> where is pesco's lib ?
15:48:17 <shapr> http://www.scannedinavian.org/~pesco/
15:53:26 <shapr> hiya viv, how was work?
15:54:22 <viv> hey shapr~=)
15:54:39 <viv> it was ok..havent really been going that much..
15:54:43 <viv> =P
15:54:54 <shapr> I get hungry if I don't work enough.
16:00:04 <viv> haha
16:00:10 <viv> that was hilarious~!
16:01:27 <stepcut> shapr: have you used pesco's library ?
16:06:31 <shapr> no, not yet
16:06:48 <shapr> I think a coupla people here have
16:08:00 <Maddas>  What emacs mode do you use/recommend to edit Haskell files? This haskell-indent-mode is indenting in a rather weird way :-(
16:08:42 <shaleh> Maddas: just keep hitting tab, it will jump to the next level
16:09:09 <shaleh> and hell, it is emacs. You can always teach it to be smarter.
16:09:25 <shaleh> I find the first few lines in a new file suck, then it gets the hang of things.
16:09:37 <Maddas> Oh, ok
16:16:29 <shapr> I haven't found anything that's really smart enough to indent Haskell code well.
16:16:50 <shaleh> it is not an easy task
16:16:59 <shapr> yup, offside rule is hard to handle
16:17:01 <shaleh> even if you have parsed the haskell code along the way
16:17:13 <shapr> internals of haskell-mode are pretty scary
16:17:24 <shaleh> internals of elisp code often are
16:17:39 <shapr> somebody wrote an academic paper about haskell-mode :-)
16:19:02 <shaleh> sheesh
16:19:34 * shaleh is enjoying Hal Daume's tutorial.
16:19:42 <shaleh> although his english needs help in places
16:20:11 <shaleh> wish he made the text source available so I could send him a patch
16:21:00 * Maddas is going through Hal Daume's tutorial too
16:22:34 <shaleh> he talks at a good level and his exercises have been helpful
16:22:51 <shaleh> but the grammar and typos occasionally sidetrack me
16:23:08 <Maddas> I think I'm getting too tired :-)
16:24:51 <Maddas> Good night!
16:24:55 <shaleh> night
17:09:55 <shaleh> evening SyntaxLaptop 
17:10:12 <SyntaxLaptop> hi shaleh
17:38:49 * shapr chortles merrily
