00:12:30 <heatsink> I want to do
00:12:34 <heatsink> (fst a) = foo
00:12:38 <heatsink> (snd a) = bar
00:12:49 <heatsink> Is there any way to do this?
00:13:05 <heatsink> actually, it's more like
00:13:14 <heatsink> [(snd a), (snd b), (snd c)] = bar
00:13:38 <ibid> heatsink: no direct way
00:14:07 <adept> heatsink: a = (foo,bar) :)
00:14:44 <heatsink> adept: it's more complicated, look at the second one
00:14:48 <ibid> heatsink: but you can do for example let (a, b, c) = case bar of [x,y,z] -> ((undefined, x), (undefined, y), (undefined, z))
00:14:58 <ibid> in ...
00:17:23 <adept> zip (map fst (unzip [a,b,c])) (repeat bar)
00:17:30 <adept> :)
00:17:32 <adept> voila :)
00:17:57 * shapr cheers
00:18:09 <shapr> I love that sort of compact code.
00:18:28 <adept> scratch the "map" there, just "fst"
00:19:21 <adept> !eval zip (fst (unzip [("f","a"),("o","b"),("o","c")])) (repeat bar)
00:20:06 <adept> Prelude> zip (fst (unzip [("f","a"),("o","b"),("o","c")])) (repeat "bar")
00:20:06 <adept> [("f","bar"),("o","bar"),("o","bar")]
00:21:04 <shapr> hoi stefan
00:21:07 <dblhelix> @yow
00:21:08 <lambdabot> What I need is a MATURE RELATIONSHIP with a FLOPPY DISK...
00:21:15 <shapr> oh, I want that too!
00:21:16 <dblhelix> hi shapr
00:22:21 <dblhelix> exciting thing going on? spectaculair code to be written today?
00:22:46 <dblhelix> /s/spectaculair/spectacular
00:22:59 <shapr> well, I have some Python to write today.
00:23:10 <shapr> it's not very exciting, but it's more fun than digging ditches.
00:23:22 <dblhelix> I can imagine
00:23:58 <heatsink> !eval let x = zip [1,2,3] (map (+1) x)
00:24:04 <heatsink> hmm...
00:24:34 <heatsink> !eval let x = zip [1,2,3] (map (\a -> fst a + 1) x)
00:24:35 <adept> heatsink: do you suppose that gonna work? :)
00:25:02 <heatsink> should give me [(1,2),(2,3),(3,4)]
00:26:33 <heatsink> hmm, it doesn't like my code
00:27:20 <heatsink> I can't even do let x = zip[1,2,3] (map (const 3) x) in x
00:27:40 <heatsink> So there's a cycle in the backbone of the list somehow
00:28:14 <heatsink> It sure looks well-defined to me...
00:29:42 <dblhelix> it's well-defined, sure, but it loops, doesn't it?
00:29:46 <adept> heatsink: why not "let y = ..." ? :)
00:30:24 <heatsink> what difference could that possibly make?
00:30:33 <heatsink> let y = zip [1,2,3] (map (const 3) y) in y
00:30:47 <heatsink> are you talking about something else?
00:31:19 <dblhelix> heatsink: I think adept just kidding ... ;)
00:32:07 <adept> heatsink: i'm talking about let y = zip [1,2,3] (map (const 3) x) in y
00:32:08 <dblhelix> heatsink: it's legal Haskell you wrote, but the calculation of x won't terminate
00:32:33 <heatsink> Yes, but I can't figure out why.
00:33:00 <heatsink> I see no cyclic transfer of data in the evaluation of that code.
00:33:07 <adept> heatsink: what you wrote boils down to "let x=x+1 in x". Quickly, what is the value of "x"?
00:33:15 <dblhelix> you use the first element of x to produce the first element of x
00:33:44 <heatsink> I use the first element of the first element of x to produce the second element of the first element of x
00:34:17 <adept> heatsink: point "first element of the first element of x" in your expression
00:34:25 <heatsink> 1
00:34:42 <adept> heatsink: no. please show an expression for "first element of the first element of x"
00:35:09 <heatsink> case x of a:as -> fst a
00:35:26 * dblhelix frowns
00:35:46 <adept> heatsink: thats not exactly what you've shown before, right?
00:37:02 <heatsink> It is 1
00:37:09 <heatsink> What do you mean by what I've shown before?
00:38:00 <adept> heatsink: before you've shown "let x = zip[1,2,3] (map (const 3) x) in x"
00:38:10 <heatsink> right
00:38:16 <dblhelix> x = zip [1 .. 3] (map (succ . fst) x) ; it still loops, but, well, I really can't tell why :S
00:38:28 <dblhelix> heatsink: I see what you mean ...
00:38:40 <adept> heatsink: why dont you just produce list of first elements and list of second elements separately and then zip. Should be more clear way to express...
00:39:13 <heatsink> adept: in fact, the list of second elements is a function of the list of first elements
00:39:21 <heatsink> My code currently looks like this:
00:39:46 <heatsink> a2 = f b;  b2 = f c;  c2 = f a;
00:39:53 <heatsink> [a,b,c] = g [a2,b2,c2]
00:40:15 <heatsink> I don't like having to define six variables when only three are important
00:40:22 <adept> Prelude> let firsts = [1..]; seconds = map (+1) firsts in take 5 $ zip firsts seconds
00:40:22 <adept> [(1,2),(2,3),(3,4),(4,5),(5,6)]
00:41:01 <dblhelix> adept: yes, of course, that'll work, but why does the original expression loop?
00:41:33 <adept> dblhelix: damn, dont know the term in english :)
00:41:51 <adept> dblhelix: expression is recursive, right?
00:41:52 <heatsink> adept: but in my program, the first list elements are also functions of the second list elements :)
00:42:20 <dblhelix> adept: sure, it is recursive, but that's not a reason on its own, is it?
00:42:53 <adept> dblhelix: that is the reason, because can you tell me the "base case" (that's the term I'm looking for) for this recursion?
00:43:34 <adept> heatsink: ok. suppose that second elements are (+1) bigger that first ones, and first ones are (-1) of the second ones. What will be the first element of such list?
00:44:10 <heatsink> adept: it's not that kind of function... I have some test code that compiles and runs correctly.
00:44:34 <adept> heatsink: then you dont tell us everything :)
00:44:36 <heatsink> Where can I stick the code?
00:44:55 <adept> heatsink: is it big?
00:45:39 <heatsink> fifteen lines of code
00:45:50 <heatsink> I'm going to add comments before pasting it...
00:45:50 <adept> maybe, just post here?
00:46:00 <adept> heatsink: but anyway
00:46:25 <adept> heatsink: if "snd"s are the fuctions of "fst"s and vice versa, how do you define first element of list?
00:46:47 * adept is off to fetch some coffee
00:46:57 <heatsink> second element is a datatype, containing references to first
00:47:46 * shapr boings
00:49:03 <kristnjov_> hi guys
00:49:12 <kristnjov_> does anyone know where i can learn about Trees in haskell?
00:49:28 <kristnjov_> i need it for a lab excercise in school where we're doing a SUD game
00:50:16 <kristnjov_> that is, a text based adventure game, where trees are to represent the map so to speak
00:51:56 <heatsink> kristnjov_: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Tree.html
00:52:10 <kristnjov_> thanks
00:54:35 <heatsink> My code is at http://www.rafb.net/paste/results/MwUfnm52.html
00:54:59 <heatsink> I'm making graphs, but I converted it to linked lists for the example
00:55:29 <heatsink> ask me about the unclear parts...
00:55:53 <heatsink> like reifyList probably needs explanation...
00:57:48 <dblhelix> heatsink, adept: well, I can see why it loops :)
00:58:45 <dblhelix> heatsink: suppose x = zip [1 .. 3] (map (succ . fst) x)
00:58:53 <heatsink> okay..
00:58:56 <dblhelix> heatsink: then, desugar it
00:59:03 <heatsink> wait, what does succ do?
00:59:08 <heatsink> @type succ
00:59:10 <lambdabot> succ :: forall a. (Enum a) => a -> a
00:59:16 <heatsink> successor
00:59:20 <heatsink> okay
00:59:21 <dblhelix> it's the (+ 1)
00:59:45 <dblhelix> desugaring gives:
00:59:49 <dblhelix> x = fix (\x -> zip [1 .. 3] (map (succ . fst) x))
00:59:51 <dblhelix> okay?
01:00:07 <heatsink> what?
01:00:13 <heatsink> @type fix
01:00:14 <lambdabot> bzzt
01:00:39 <dblhelix> think of fix as a special built-in operator, hidden from the language's surface
01:00:47 <heatsink> okay
01:00:51 <heatsink> what does it do?
01:00:55 <dblhelix> it behaves like: fix f = f (fix f)
01:01:13 <dblhelix> so, effectively, it gives you recursion
01:01:16 <ibid> is it the big fix or the small fix?
01:01:35 <heatsink> okay
01:02:11 <dblhelix> this expression is simply reduced ...
01:02:42 <dblhelix>   (\x -> zip [1 .. 3] (map (succ . fst) x)) (fix (\x -> zip [1 .. 3] (map (succ . fst) x)))
01:03:14 <kristnjov_> what does \x mean? i've seen it a lot.
01:03:19 <heatsink> lambda
01:03:32 <heatsink> It's a way to create a function without giving it a name
01:03:32 <dblhelix> heatsink: then you get ...
01:03:35 <xkb> thats a function
01:03:38 <xkb> ah
01:03:40 <dblhelix> zip [1 .. 3] (map (succ . fst) (fix (\x -> zip [1 .. 3] (map (succ . fst) x))))
01:03:40 <xkb> to slow again
01:04:08 <heatsink> ok
01:04:23 <dblhelix> since zip is strict in it's second argument, we have to reduce
01:04:25 <dblhelix> (fix (\x -> zip [1 .. 3] (map (succ . fst) x)))
01:04:26 <dblhelix> again
01:04:31 <dblhelix> hence, we loop
01:05:16 <heatsink> hmm...
01:05:32 <dblhelix> IIRC, this is how GHC works internally when emitting code for recursive expressions, so ... if I'm wrong, someone, please correct me ... but I think it explains why it loops
01:05:48 <shapr> @index fix
01:05:48 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
01:05:48 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
01:05:56 <shapr> @index mfix
01:05:57 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
01:05:57 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
01:06:05 <heatsink> Yes, I think you're right
01:06:26 <heatsink> After your explanation, I realized...
01:06:41 <heatsink> There are four solutions to that expression
01:06:47 <heatsink> x=[]
01:06:52 <heatsink> x=[(1,2)]
01:07:01 <heatsink> x=[(1,2),(2,3)]
01:07:11 <heatsink> x=[(1,2),(2,3),(3,4)]
01:07:18 <heatsink> that's weird
01:07:55 <heatsink> I've never solved a recursive program before :)
01:08:08 <dblhelix> now you have ;)
01:09:23 <dblhelix> ibid: to answer your question, we're talking about _least_ fixed points here
01:10:19 <heatsink> ha! http://haskell.org/hawiki/Recursion
01:11:18 <dblhelix> :)
01:12:38 <dblhelix> check out Section 3.12 of the Haskell report for a translation of recursive let-expressions
01:12:43 <heatsink> ...Is adept coming back?
01:13:23 <dblhelix> heatsink: I'm afraid he started evaluating your code and is trapped in an infinite loop now ;)
01:13:34 <heatsink> :)
01:14:30 * shapr grins
01:14:32 <ibid> dblhelix: thanks :)
01:15:01 <ibid> (i was just wondering, since loops are usually modeled as greatest fixed points)
01:19:36 <heatsink> Well, I'm going to bed... I'll be back on the haskell list to ask my question again, because I'll need help solving it.
01:20:48 <dblhelix> heatsink: do you plan on posting it before you hit your bed? it's 10.20am here, so I may have a look at it ;)
01:21:09 <heatsink> oh, I posted it...
01:21:29 <heatsink> <heatsink> My code is at http://www.rafb.net/paste/results/MwUfnm52.html
01:21:29 <heatsink> <heatsink> I'm making graphs, but I converted it to linked lists for the example
01:21:29 <heatsink> <heatsink> ask me about the unclear parts...
01:21:29 <heatsink> <heatsink> like reifyList probably needs explanation...
01:21:56 <dblhelix> ah, okay
01:22:27 <heatsink> The idea is that I create my elements in arbitrary order
01:22:37 <heatsink> But I want to give them each unique ID numbers
01:23:01 * adept is back
01:23:04 <heatsink> so I put my proto-elements in a list and pass it to a function that returns list elements
01:23:07 <heatsink> ah, good
01:23:23 <heatsink> can you see my code?
01:23:32 <dblhelix> yes, I see it ...
01:23:44 <dblhelix> have a look at it later ... (fist some coffee ;))
01:23:49 <adept> yes, i see it
01:23:53 <heatsink> okay
01:24:27 <adept> heatsink: i dont like your datatype for linked list
01:24:36 * dblhelix is off for coffee ...
01:24:46 <adept> heatsink: how do you denote empty lsit with Vtx'es
01:25:03 <heatsink> I'm actually making graphs
01:25:09 <heatsink> I simplified it to linked list for the example
01:25:42 <heatsink> it was data Vtx = Vtx [Vtx] Int before...
01:25:59 <adept> heatsink: nevertheless, if it going to be used as an example, it should be correct :)
01:26:16 <heatsink> It works correctly
01:26:26 <heatsink> I only want to make singly linked circular lists :)
01:29:45 <adept> heatsink: have you read http://haskell.org/hawiki/TyingTheKnot ?
01:29:51 <heatsink> yes
01:29:56 <heatsink> I don't understand it well
01:32:22 <shapr> how do I force removal of a package even though one of its dependencies isn't configured?
01:32:38 <adept> heatsink: your example is too complex, i believe. Will this one do?
01:32:38 <adept> let firsts = 1:(map (+1) seconds); seconds = map (+1) firsts in take 5 $ zip firsts seconds
01:32:54 <adept> shapr: debian?
01:33:02 <adept> shapr: dpkg --force-all?
01:34:18 <heatsink> Hmm...
01:34:39 <heatsink> I will have to think whether I can apply this example to my problem
01:34:56 <shapr> can't you simplify that example to the lazy fib list?
01:35:07 <shapr> fib = 1 : 1 : zipWith (+) fib (tail fib)
01:35:27 <adept> heatsink: why not? :) Note, that if you remove "1:", code will fail to terminate...
01:35:34 <heatsink> of course...
01:36:56 <adept> heatsink: becasu you just need some piece of data to "bootstrap" from
01:39:22 <heatsink> I understand how let works
01:40:10 <heatsink> What are you trying to explain to me?
01:40:17 <adept> heatsink: :)
01:40:48 <adept> heatsink: what was your question again? :) I think that I was answering the question you have in your mind, but obviously I do not :)
01:41:39 <adept> heatsink: I try to explain that writing things like let x = map fun x will not work, while let x = 1:(map fun (tail x)) might
01:42:17 <heatsink> I have some code that does what I want it to, but it has repetition that I do not like
01:42:49 <heatsink> I am creating a graph. (lines 16 and 17)
01:43:12 <heatsink> Each node in the graph has its own unique identifier (line 21).
01:43:21 <adept> ok
01:43:45 <adept> and ... ?
01:44:11 <heatsink> I have to use two variables for each graph node.
01:44:21 <heatsink> the way it is currently implemented
01:44:34 <heatsink> I am trying to figure out how to use only one variable for each graph node.
01:44:37 <adept> why not just "main  = putStr $ show $ reifyList [(Vtx a), (Vtx b)]" ?
01:45:06 <adept> heatsink: and it seems to me that you interpret word "variable" in imperative sense ...
01:45:25 <heatsink> They don't vary, but they are still called variables...
01:45:34 <adept> heatsink: ah. sorry.
01:45:40 <adept> heatsink: I see
01:46:18 <adept> heatsink: well, then. "g = reifyList [Vtx a, Vtx b] where [a,b]=g" ?
01:47:07 <heatsink> I'm making a graph module
01:47:37 <heatsink> I will not be creating my entire graph in a single closure where all the names that go into the list will be bound...
01:48:30 <heatsink> if I have a function that returns some unreified subgraph nodes, then I cannot use that method
01:50:44 <adept> heatsink: that is because your method of graph creation requires you to specify an order of nodes explicitly, via patter match [a,b]=g
01:51:37 <heatsink> Is there a way to avoid ordering the nodes?
01:52:43 <adept> heatsink: you see, right to denote [a] you have to write 'let a = Vtx a someInt', right?
01:52:57 <adept> heatsink: you see, right now to denote [a] you have to write 'let a = Vtx a someInt', right?
01:53:13 <heatsink> for a circular one-element list, yes
01:53:38 <adept> heatsink: didn't I tell you that this example is bad? :)
01:53:50 <adept> it is bad because you could not test for single-element list
01:54:14 <adept> you cannot test for it because extraction of "next" from single-element list will never terminate
01:54:33 <adept> and in order to create such useless lists you need to jump in hoops at creation time.
01:54:37 <heatsink> That's what the ints are _for_
01:54:55 <heatsink> The ints are there so that different list elements can be distinguished.
01:55:17 <adept> heatsink: then why not "data Vtx = Vtx Int"?
01:56:06 <adept> you see, in your example ol=nly Ints carry some meaning, first element of datatype is meaningless, and yet it require very tricky creation technique. 
01:56:54 <heatsink> You're pointing out the things that I removed to simplify the example
01:57:08 <adept> so it is either a bad example (because it doesnt really show what you are trying to do), or it is a bad way to go, because half of your datatype is meaningless
01:57:49 <adept> heatsink: i'm saying that your example is bad because it shows something different from what you are trying to do, and thus we can not discuss you problem properly
01:58:57 <heatsink> alright
02:04:09 <adept> alright :)
02:06:10 <heatsink> Okay http://www.rafb.net/paste/results/UCd4fN83.html
02:06:24 <heatsink> Notice that bp and cp are identical, but b and c are not
02:09:23 <heatsink> Also, I could potentially create a function [Vtx] -> [Vtx] -> [Int -> Vtx] that creates a subgraph of this graph
02:09:26 <adept> use of reifyList means that you will have "one closure" where reifyList will be called and graph constructed, right?
02:09:32 <heatsink> right
02:11:47 <adept> heatsink: but later you said that "I will not be creating my entire graph in a single closure where all the names that go into the list will be bound", which sort of contradicts this statement.
02:11:54 <adept> sorry, earlier, not later
02:12:22 <heatsink> It's still true, I'm making an example now
02:26:16 <adept> heatsink: you see, you basically have two options: you either describe structure of the graph using haskell data structures, or you provide some formal description of graph structure for haskell code that will transform it to haskell datatypes. Usually graph description is parsed from external file, and it is parser's job to assemble proper datatypes.
02:26:36 <heatsink> yes
02:31:43 <heatsink> Here we go http://www.rafb.net/paste/results/dE0z9L95.html
02:32:58 <heatsink> Do you want me to actually write a parser that reads a datafile and creates a graph, to demonstrate that it's possible? :)
02:33:44 <heatsink> I will write one eventually anyway, but I wanted a data structure that was easier to work with first
02:34:05 <heatsink> I'm going to hit bottom a lot if I keep working with this one
02:38:03 * adept has to eat something
02:38:30 <adept> heatsink: right now you are mopving toward implementing ad-hoc parser over data structure that will describe your graph structure
02:42:12 <heatsink> Yes
02:45:17 <tromp> g'morning folks
02:45:21 <heatsink> morning
02:46:04 <tromp> is there a way to see last 100 lines of discussion? i just connected
02:46:28 <heatsink> tromp: view the log
02:46:36 <arjanb> http://tunes.org/~nef/logs/haskell/
02:47:18 <tromp> so no way to see it in irc client?
02:47:48 <bbls> what's the problem with viewing it in the browser?
02:48:04 <Maddas> tromp: I use a proxy that sends me the lines that I've missed when I connect to it, but the proxy needs to be connected all the time.
02:48:53 <heatsink> I'm going to sleep... goodnight all
02:49:04 <Maddas> Good night, heatsink.
02:49:07 <tromp> g'night hs
03:21:40 <tromp> lots of dutch here:)
03:25:37 <shapr> and some spanish...
03:28:11 <Maddas> I've heard rumours that there are swedish people hiding here too..
04:45:49 <tromp> any efficiency experts here?
04:48:07 <shapr> tromp: efficiency of what?
04:48:24 <shapr> viv: hey, are you the same person as vivien from mcmaster?
04:48:51 <viv> vivien is what i used when i was working in the lab..
04:48:55 <shapr> aha
04:49:02 <shapr> so viv is your less formal home nickname?
04:49:03 <viv> but ya..vivien is my name..
04:49:07 <viv> as well as viv..=)
04:49:15 <viv> yepyep~
04:49:25 <viv> hey i gotta run..
04:49:29 <shapr> peut-etre vous parlez français aussi?
04:49:30 <shapr> ok
04:49:36 <shapr> vivien sounds french to me
04:49:39 <viv> got an early 8:30am haskell class~!!
04:49:43 * shapr wonders if shapr sounds french
04:49:47 <viv> haskell haskell~
04:49:48 <shapr> wow, cool!
04:50:08 <viv> dunno if you ever heard of 'Dr.Kahl'..
04:50:17 <viv> from either dsrt or Cale.....
04:50:31 <shapr> yes, I have
04:58:56 <tromp> efficiency of quicksort, shapr
05:03:04 <det> tromp: http://www.haskell.org/aboutHaskell.html
05:03:09 <det> tromp: scroll down to quicksort :)
05:03:41 <tromp> ok, now if you have a list of 10000 random ints
05:03:43 <det> specificly "When C is better"
05:03:51 <tromp> why is that quicksort so slow?
05:04:19 <tromp> i thought it was the ++ operations, but rewriting those doesnt seem to help
05:14:58 <earthy> tromp: Int or Integer?
05:15:04 <earthy> tromp: boxed or unboxed?
05:16:19 <shapr> tromp: choice of pivot point?
05:17:20 <shapr> does StrategoXT support parallel ops?
05:17:36 <tromp> i was sorting something like rndlist = map (`mod` 97) [0,23..4999999]
05:18:22 <andersca> hello ski, shapr
05:18:37 <shapr> I've seen people complain about the short and sexy Haskell quicksort implementation because it's not the most efficient way to do quicksort in Haskell
05:18:52 <shapr> the primary argument is that it doesn't choose a good pivot point
05:18:58 <shapr> good morning anders
05:19:02 <tromp> but exactly what makes it inefficient?
05:20:08 <shapr> http://c2.com/cgi/wiki?QuickSortInHaskell
05:20:08 <ski> persistent data-structure and naive choice of pivot point
05:20:27 <tromp> pivot choice is irrelevant in my rnd example
05:28:21 <tromp> oh, i see the ++ can't slow it down much, since it spends more time constructing that list
05:30:04 <ski> tromp : have you changed it to have an accumulating parameter ?
05:30:19 <tromp> yes, that only saved a few % in time though:(
05:31:19 <ski> are you comparing with a persistent or nonpersistent implementation ?
05:32:11 <tromp> comparing plain version with accumulating version. what do you mean by persistent?
05:33:03 <ski> hm, i thought you were comparing with C or C++ or something like that ..
05:33:04 <XTL_> There. Things are starting to look normal here.
05:33:44 <tromp> well. comparing it to how long i *think* it should take in C :)
05:34:14 <XTL> Got network uplink, firewall and nat working, fileserver set up and old data recovered and one workstation up.
05:34:27 <ski> tromp : heh
05:35:18 <shapr> XTL: you've reached the north!
05:35:33 <ski> tromp : anyway, the usual C version is prolly non-persistant, in such a case it's a bit like comparing apples and oranges (if you wanted to measure how haskell runs the same algorithm, as opposed to a different one)
05:35:50 <shapr> XTL: did you get some cash for the NeXT?
05:36:04 <shapr> XTL: if you still have it in Oulu, I'll take the bus over and pick it up.
05:36:24 <shapr> though I doubt you'd want to lug it up north :-)
05:36:29 <XTL> shapr: I got the 250 for it and it was picked up.
05:36:39 <shapr> nice
05:37:00 <XTL> I still got one more offer for it afterwards and he asked me to contact the buyer so maybe he can persuade him to change his mind still :)
05:37:03 <shapr> heh
05:37:17 <shapr> Are there any cycle computers that run linux?
05:37:49 <XTL> You mean the things that keep odometer and speed data etc?
05:38:06 <shapr> yup
05:38:34 <xkb> shapr, why would you want to?
05:38:57 <XTL> Haven't heard from one. I imagine you could do that with some data acq kit attached to a palmtop or a phone
05:38:58 <ski> do they run any non-customized OS ?
05:39:01 <adept> xkb: to be able to run irc client there as well, i suppose ;)
05:39:05 <xkb> lol
05:39:08 <shapr> because most of them run something totally custom and will only feed data into a custom windows program
05:39:44 <XTL> "Here's my ramp, brb"
05:40:29 <XTL> They should make one that would save the data in a sane format to a flash card and/or behave like usb-storage
05:43:08 <shapr> "autoaway - sudden altitude drop implies user hospitalization"
05:44:26 <ski> heh
05:44:31 <ski> hi shapr
05:57:37 <musasabi> evening
06:00:56 <shapr> Lemmih: got the seat?
06:03:15 <shapr> hej ski
06:03:18 <shapr> greetz musasabi 
06:03:25 <shapr> looks like your HashTable discoveries were useful
06:07:46 <musasabi> yes ^_^
06:09:12 * adept pricks his ears
06:09:18 <adept> what hashtable discoveries?
06:11:09 <musasabi> and the fix is in the cvs now.
06:11:32 <musasabi> adept: insert adding just a new association, not deleting the old one.
06:11:54 <adept> oh
06:11:57 <adept> thank you
06:13:01 <shapr> with make-kpkg I can say --added-patches=all right?
06:13:17 <Lemmih> shapr: Yay. I got it.
06:13:31 <adept> shapr: yep
06:13:32 <Lemmih> I've just returned from the post office.
06:13:37 <shapr> Lemmih: w00, is the seat better than what you already had?
06:13:46 <Lemmih> It's _so_ much nicer than my origian seat.
06:14:32 * Lemmih is looking at the little plastic bag now.
06:14:34 <shapr> adept: any improvements for "export CONCURRENCY_LEVEL=3;make-kpkg clean && make-kpkg --added-patches=all --config=menuconfig --revision=2.6.8.custom.1.0 kernel_image modules_image" ?
06:15:23 <tromp> btw, ski, i just implemented the exact same sort in c which takes 0.04 secs
06:15:46 <tromp> where ghc took over 6 secs:(
06:16:03 <shapr> Lemmih: so, you like the small bag of random desk bits?
06:17:01 <Lemmih> Yeah.
06:17:35 <Lemmih> The different kinds of currency are awesome.
06:17:38 <shapr> sadly, I couldn't find any chinese money to include
06:17:59 <adept> shapr: not really
06:18:13 * ski have to change 'puter
06:18:14 <shapr> adept: ok, thanks :-)
06:18:25 <Lemmih> shapr: What's that paper thingy?
06:18:33 <adept> tromp: and of course C version clases to sorting arbitrary datatypes just as easily as haskell one? :)
06:18:44 <adept> tromp 'clases' = 'scales' :)
06:18:48 <shapr> er, my business card?
06:19:05 <Lemmih> No. The folded paper.
06:19:20 <shapr> I don't know?
06:19:31 <shapr> what does it look like?
06:20:57 <Lemmih> Half a horse... it's kinda weird (-:
06:21:05 <shapr> oh heh
06:21:09 <shapr> that's origami :-)
06:22:43 <Lemmih> What's "Nome"?
06:23:00 <shapr> that's from Nome, Alaska
06:23:31 <shapr> http://www.nomealaska.org/
06:24:14 <shapr> finish of the Iditarod Trail Sled Dog Race
06:24:28 <Lemmih> And what's the oval thingy with glue on it?
06:24:34 <shapr> um
06:24:44 <shapr> er
06:24:51 <shapr> what does it look like?
06:25:04 <adept> tromp: try something like add-a-gram from http://www.itasoftware.com/careers/programmers-archive.php to compare C vs Haskell :)
06:25:31 <Lemmih> Danish: "Det er en oval svamp med lim paa den ene side."
06:25:53 <shapr> oval mushroom?
06:26:14 <shapr> I dunno what that is
06:26:27 * shapr outdid himself with randomness
06:26:46 <Lemmih> haha. Well I wouldn't translate it to 'mushroom' in that sentence.
06:26:58 <andersca> @arr
06:26:58 <lambdabot> I want me grog!
06:27:00 <shapr> @arr
06:27:01 <lambdabot> Yeh scurvy dog...
06:27:52 * Lemmih is gonna attach the new seat to his cycle.
06:27:57 <shapr> yay
06:29:13 <shapr> @arr
06:29:13 <lambdabot> Shiver me timbers!
06:29:17 <shapr> @fortune
06:29:18 <lambdabot> Overdrawn?  But I still have checks left!
06:31:59 <tromp> c version was a pain to write, since it didn't complain when i mistyped the comparison function:(
06:32:37 <shapr> so, what's the ratio of difference in dev time compared to difference in execution time?
06:33:04 <Boegel> hello everyone
06:33:06 <shapr> hoi Boegel 
06:33:07 <ski> hi Boegel
06:33:22 <Boegel> It's official : I hate windows :)
06:33:40 <tromp> haskell: 1 min   C: 10 min
06:33:42 <Boegel> this morning, my girlfriend woke me up because the spyware was still raging on her computer
06:33:48 <shapr> yow
06:33:48 <Boegel> so I'm reinstalling it know
06:33:54 <Boegel> to her wishes :s
06:33:59 <ski> Boegel : raging ?
06:34:07 <shapr> did you ask her to try Mandrake? :-)
06:34:09 <Boegel> euh
06:34:15 <Boegel> hehe
06:34:22 <Boegel> no shapr, she's afraid of linux :p
06:34:32 <shapr> sounds like she should be more afraid of windows.
06:34:37 <Boegel> and her homebanking and stuff like that wouldn't work probably
06:34:40 <Boegel> true
06:34:46 <Boegel> and she won't use Firefox either
06:34:49 <shapr> why not?
06:34:56 <Boegel> I told her it would do her good, but no
06:34:56 <shapr> not enough bugs?
06:34:58 <Boegel> dunno
06:35:06 <Boegel> I think she's afraid of change
06:35:08 <shapr> oh
06:35:14 <Boegel> that's a good thing for me though :p
06:35:14 <shapr> most people are
06:35:17 * shapr laughs
06:36:26 <shapr> tromp: 0.04 vs 6 and 10 vs 1
06:36:35 * Boegel will try Fedora Core 3 Test 2, but feels problems coming up again with his grapics card
06:37:37 <shapr> tromp: I'm usually prefer algorithms and code that is 'fast enough' because it means I get that much more time to unicycle or write other code.
06:38:13 <shapr> Boegel: what card?
06:38:23 <shapr> hoi arjanb
06:42:09 <tromp> i prefer code that looks sexy. so C is dead in the water in that respect:)
06:42:27 <shapr> haha
06:42:31 <shapr> truly
06:42:39 <shapr> Joy is rather sexy imho
06:45:03 <ibid> for a moment i thought you meant josip rodin :)
06:45:11 <shapr> musasabi: does parr work with the standard GHC debs?
06:45:21 <Boegel> shapr,  Hercules 3D Prophet 4000XT (Kyro based)
06:45:26 <Maddas> shapr: Do you know Clean? Do you find that sexy?
06:45:31 <tromp> quicksort in joy is DEFINE sort == [small][] [uncons [>] split] [[swap] dip cons concat] binrec . according to wikipedia
06:45:31 <Boegel> the manufacturer stopped supporting it for linux
06:45:45 <tromp> but isnt there something missing there?
06:45:54 <shapr> Maddas: I do not know Clean
06:46:21 <shapr> hm, I don't know what small does
06:46:43 <tromp> so how would you write qsort in joy?
06:46:44 <shapr> Boegel: yah, that sucks
06:47:02 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
06:47:18 <shapr> tromp: I'd have to stare at it for an hour or so, maybe this evening
06:47:24 * ski does not (really) know Clean, and finds it sexy
06:47:34 <shapr> I know qsort, and I know Joy, but I haven't tried to write qsort in Joy.
06:47:48 <shapr> I would like to implement Joy in Haskell though.
06:48:14 <Maddas> shapr: heh (qsort) :)
06:48:54 <shapr> Boegel: sadly, there aren't any fast opensource graphics card drivers for Linux, that's one of the problems imho
06:48:56 <tromp> more fun than implementing Haskell in Joy, no doubt:)
06:48:57 <shapr> hiya Knoen 
06:49:02 * shapr thinks about that
06:49:18 <shapr> yes, good point
06:49:48 <Boegel> I'll have to try it with a standard generic driver
06:49:50 <Boegel> only 2D
06:49:51 <shapr> I bet I could make an efficient and speedy Joy interpreter with arrows, but I don't want to think about implement the HM type system in Joy.
06:49:58 <Boegel> but that's not that bad
06:50:05 <shapr> Boegel: nvidia is the best supported, ATI is next
06:50:10 <Boegel> shapr, how are your projects doin' ?
06:50:16 <shapr> I have projects?
06:50:33 <tromp> ATI plans to improve their linux support though
06:50:34 <shapr> Knoen: have you been here to #haskell before?
06:50:57 <kosmikus> xkb: I saw in the logs that you have been struggling with lhs2TeX a while ago ... Have you solved all problems by now?
06:51:42 <Lemmih> shapr: Noooo. The seat doesn't fit /-:
06:51:47 <shapr> suck :-(
06:51:51 <Boegel> you chose 3 projects you would work on
06:52:03 <juhp> well, ati is better supported with opensource drivers fwiw
06:52:06 <shapr> Boegel: right, what were they?
06:52:19 <Boegel> i don't know, you tell me :p
06:52:19 <shapr> oh yeah; darcs, QuickCheck, and haskell-libs
06:52:24 <Boegel> yeah those
06:52:30 <Boegel> any articles yet ?
06:52:55 <shapr> Lemmih said he'd write, and I said I'll write, but no other definites
06:53:16 <shapr> I want at least four people who'll write regular articles before I'll really start Haskell Monthly
06:53:27 <shapr> someone else could start it though, and I'd still write :-)
06:53:49 <phubuh> what kinda stuff are you looking for?
06:53:58 <shapr> Haskell related articles
06:54:03 <phubuh> oh :)
06:54:05 * shapr grins
06:54:18 <shapr> I committed shapr's n00b column and the puzzle column
06:54:27 <phubuh> ooh, puzzles!
06:54:37 <Igloo> Oh, neat, Data.List has a foldl'
06:56:34 <Knoen> sharp: no, I hever been here before.
06:56:51 <ski> Knoen : are you learning haskell ?
06:57:01 <Knoen> ski: yes
06:57:14 <ski> got any questions, yet ?
06:57:23 <Knoen> ski: haskell and ocaml
06:57:27 <ski> ok
06:57:55 <Knoen> ski: no questions for now, just wanted to see what are usual topics here on the channel
06:58:04 <phubuh> little listmania! type things would be cool, like "read this stuff if you want to learn about category theory"
06:58:44 <ski> (Knoen : high and low stuff, theoretical and practical, etc ..)
06:58:58 * phubuh feels bad about buying expensive books without authoritative suggestions :)
06:59:26 <Boegel> Knoen, and lot's of bull too :p
06:59:42 <Knoen> ski: great, i'll continue monitoring ;-)
07:00:29 <Knoen> boegel: that's ok too ;-)
07:02:18 <Boegel> :p
07:06:50 <thebug> yay shapr's n00b column :)
07:07:02 * ski just realized today that some "subtypes" need not be subobjects at all (rather quotient objects)
07:09:27 <Boegel> I'm out, bye
07:17:37 <Lemmih> shapr: I'm gonna visit the blacksmith tomorrow.
07:18:10 <shapr> cool
07:18:31 <XTL> Hmm
07:18:42 <shapr> phubuh: you want to write the listmania column?
07:20:51 <phubuh> i've hardly read any computing books, but i'd love to read it :P
07:21:44 <shapr> you could solicit suggestions from #haskell and other places.
07:21:51 <shapr> like lambda-the-ultimate.org
07:24:48 <phubuh> hm, yeah.  i could do it
07:25:36 <xkb> kosmikus, I will try again using lh2tex soon.. When I need to "literate haskell" a bigger haskell exception mechanism
07:25:48 <xkb> example
07:25:56 <xkb> pfft.. what a borked up sentence :D
07:35:23 <shapr> man, the monads discussion on lambda-the-ultimate.org got really mean
07:35:48 <kosmikus> xkb: which means ... you didn't really get it running last time?
07:35:50 <ski> where, where ?
07:35:51 <ski> ;)
07:35:59 <shapr> http://lambda-the-ultimate.org/node/view/92
07:36:48 <shapr> geez, Wouter Van Oortmerssen is not a fan of monads for general use.
07:37:54 <shapr> admittedly, he's a very productive language designer, but I disagree with his opinion of monads.
07:38:29 <shapr> g'day ozone 
07:38:52 <xkb> kosmikus, correct
07:38:55 <ozone> hey shapr
07:39:50 <ski> shapr : is that the same wouter that visits here ?
07:40:17 <shapr> nah, the wouter who visits here is Wouter Swierstra
07:40:28 <kosmikus> kosmikus: ok, if you have specific questions, you can ask me
07:40:33 <kosmikus> arg
07:40:36 <kosmikus> xkb: ^^
07:40:41 <ski> still netherlands though ? 
07:40:45 <shapr> Wouter Van Oortmerssen is http://wouter.fov120.com/proglang/index.html
07:41:00 <xkb> kosmikus, ok :D
07:41:07 <phubuh> PIG is an "anti-functional programming language", an experiment to see how far one can get in a language which only has global state (in the form of stacks) and argument-less functions.
07:41:11 <phubuh> interesting :-)
07:41:11 <shapr> I do wish he'd release the source for some of his langs.
07:41:13 <ski> shapr : yup, i've ran into that before :)
07:41:28 <shapr> phubuh: how is that different from Joy? where is PIG?
07:41:31 <shapr> oh
07:41:33 <shapr> I see it
07:42:07 <shapr> I wish I could actually play with his implementations
07:42:34 <shapr> wouter vO shows up on freenode as Aardappel
07:42:49 <ski> BRAAK seems interesting
07:43:17 <shapr> I want to play with these langs to see how they feel.
07:43:24 <ski> me too
07:43:25 <shapr> otherwise, what's the point?
07:43:32 <ski> especially the gui ones
07:43:43 <ski> s/gui/visual/
07:44:05 <shapr> yah, the visual langs look way sexy.
07:44:36 <shapr> there's an amiga emulator deb...
07:45:09 <shapr> Darius Bacon has some cool ideas that are derived from visual stack-langs
07:45:44 <ski> deb ?
07:45:49 <ski> hm, where ?
07:45:59 <shapr> apt-get install uae
07:46:06 <ski> aha
07:46:14 * shapr suddenly wants @apt-cache
07:46:17 <ski> good ole uae
07:47:08 <ski> but, where Darius Bacon ?
07:47:37 <shapr> http://www.accesscom.com/~darius/
07:47:46 <shapr> but I don't think his visual-stack ideas are up there.
07:48:13 <ski> usenet ? irc ?
07:48:37 <shapr> I have them in personal email, I don't know if he's published them.
07:48:38 <shapr> I'll ask him.
07:49:27 <ski> ok
07:49:43 <shapr> where's the best arrow-based interpreter I could hack into a Joy interpreter? any suggestions?
07:50:26 * ski has been thinking (a while ago) of another implementation of concatenative lang.s in haskell
07:50:49 <ski> (though, it could mayhaps be made arrow-based)
07:50:52 <shapr> are there already catlang imps in Haskell?
07:50:59 <ski> dunno :)
07:55:48 <Lemmih> What's wrong with type errors about monads?
07:56:41 <ski> Lemmih : huh ?
07:56:56 <ski> which type errors ?
07:57:21 <Lemmih> "If I am a C++ programmers, and someone shows me the Haskell "do" syntax, I think, hey, that is easy, it is just like a statement list. Until I actually try and use it like that. I will create a Monad, maybe a bit weird, but ok, some examples, and I manage to create something. Now I write my do "statements". Something doesn't match up, and I get the weirdest type errors. For a C++ programmers, these are complete chinese to me. To have 
07:57:22 <Lemmih> an instant understanding of these type errors, I need to be so deep into functional languages to the extend that only people on this board are."
07:57:40 <Lemmih> Sorry for flooding.
07:58:10 <ski> seen on ltu ?
07:58:18 <Lemmih> Yeah.
07:58:32 <Lunar^> Lemmih: It's pretty true, IMHO
07:58:35 <vegai> Lemmih: that's a pretty accurate statement
07:58:38 <shapr> from my viewpoint, monadic programming was no harder to understand than object oriented programming
07:59:00 <shapr> C++ programming on the other hand ...
07:59:06 <shapr> now that's chinese =)
07:59:07 <ski> i'm not sure if i can recall many spcifically monad-related type-errors. problem might just be to first understund how typesystem in haskell works
07:59:25 <vegai> I'm probably still one big leap away from understanding the monads
07:59:27 <Lunar^> Lemmih: What I lije particularily in SOE, is the way IO is introduced without talking about monads
07:59:38 <tic> gonads and strife
07:59:52 <Lunar^> Lemmih: It would by intersting to have a setting to get simplified error messages in the particular IO case
08:00:12 <shapr> bonjour Lunar^ 
08:00:17 <ski> maybe Helium does something like that .. ?
08:00:55 <Lemmih> Lunar^: Could you give an example of an unreadable error message, please?
08:02:07 <Lunar^> shapr: It's been a long time no talking here :)
08:02:16 <shapr> I suspect the type errors would be a lot more readable if the C++ programming has given really picky type sigs to each function he's written
08:02:21 <Lunar^> shapr: I started the master few days ago
08:02:25 <shapr> yay!
08:02:42 <shapr> In just a few years, you'll be Dr. Lunar^
08:02:54 <ski> @seeb esap
08:02:55 <lambdabot> Sorry, I don't know the command "seeb", try "lambdabot: @listcommands"
08:02:57 <ski> @seen esap
08:02:57 <lambdabot> esap is in #epigram and #haskell.
08:03:25 <Lunar^> Lemmih: do putStrLn ; return 1
08:03:31 <Lunar^> Lemmih: this one is pretty cool
08:03:43 <Lunar^> shapr: ... that's scarry :)
08:03:55 <Lunar^> shapr: I did some O'Caml today
08:04:12 <Lunar^> shapr: And that's really one of the most crappy syntax I've ever seen
08:04:15 * shapr laughs
08:04:32 <shapr> it does produce speedy binaries.
08:04:48 <Lemmih> Lunar^: It's not very cryptic if you're familiar with type classes.
08:06:18 <Lunar^> Lemmih: Yeah, but that's a cryptic error message
08:06:47 <ski> (hmm, plural of "modulus", anyone ?)
08:06:57 <Lemmih> Of course you can get error messages about features you don't understand yet but that's not limited to monads nor Haskell.
08:07:15 <shapr> moduli?
08:07:18 <shapr> @wn moduli
08:07:22 <lambdabot> *** "moduli" wn "WordNet (r) 2.0"
08:07:22 <lambdabot> modulus
08:07:22 <lambdabot>      n 1: an integer that can be divided without remainder into the
08:07:22 <lambdabot>           difference between two other integers; "2 is a modulus
08:07:22 <lambdabot>           of 5 and 9"
08:07:24 <lambdabot>      2: the absolute value of a complex number
08:07:26 <lambdabot>      3: (physics) a coefficient that expresses how much of a
08:07:28 <lambdabot>         specified property is possessed by a specified substance
08:07:30 <lambdabot> [5 @more lines]
08:07:43 * shapr gets lots of C++ errors
08:07:56 <ski> ty
08:07:57 <shapr> I think C++ is too hard for Haskell programmers.
08:08:10 <kristnjov> imperative programming sucks
08:08:12 <shapr> we should have government subsidies to help us learn C++
08:09:07 <ski> or, maybe .. government subsidies to help us not having to learn C++
08:09:13 <shapr> ok, that's even better
08:10:38 <shapr> is the source for Ross Paterson's FoP chapter online?
08:10:51 <shapr> er, Haskell source
08:11:02 <ski> FoP ?
08:11:16 <shapr> http://www.soi.city.ac.uk/~ross/papers/fop.html
08:11:17 <ski> (oh, FunOfProgramming ?)
08:11:29 <shapr> japp
08:19:30 <shapr> I'm getting this error with fptools: cvs server: warning: cannot write to history file /cvs/CVSROOT/history: Read-only file system
08:19:33 <shapr> any ideas?
08:19:43 <shapr> still appears to be updating though
08:21:58 <Lemmih> Lunar^: Got others?
08:32:45 <shapr> 221.*.*.* is really pissing me off with wiki spam.
08:35:58 <arjanb> 210.82.*.* is another regular wiki spammer
08:41:00 <kristnjov> and 82.182.*.* isn't
08:48:08 <shapr> arjanb: I've already banned the 210.82.106.* subnet
08:50:16 * shapr gives up and bans 221.*
08:51:30 <shapr> I want to switch to http://moinmoin.wikiwikiweb.de/AntiSpamGlobalSolution soon
08:51:38 <shapr> but not today
08:52:15 <shapr> any good example arrowdic interpreters other than the demos in the Hughes and Paterson papers?
08:52:37 <shapr> arjanb: btw, you can do reverts if you login to the wiki
08:53:37 <shapr> hej DenizzzZ
08:54:47 <DenizzzZ> hej
08:54:47 <DenizzzZ> ..
08:54:54 <DenizzzZ> känner jag dig ? :D
08:55:07 <DenizzzZ> går vi i samma klass ?!
08:55:13 <kristnjov> walla billa
08:55:19 <DenizzzZ> muslim ?!
08:55:25 <shapr> d00d, that's latin-1
08:55:28 <shapr> I only speak utf-8
08:56:13 <DenizzzZ> shapr : do I know you ? :)
08:56:31 <shapr> probably not
08:56:40 <DenizzzZ> ok..
08:56:41 <DenizzzZ> :)
08:56:52 <shapr> but if you have Haskell questions, feel free to ask me
08:57:11 <DenizzzZ> nice!.. :)
08:57:30 <DenizzzZ> I have haskell course :D in guthenbourg!
08:57:34 <DenizzzZ> gothenburg..
08:57:36 <ski> good
08:58:02 <kristnjov> i think chalmers and MTI are the only places they teach haskell nowadays
08:58:12 <DenizzzZ> yeah..
08:58:17 <DenizzzZ> and.. chalmers owns!
08:58:26 <ski> MTI = ?
08:58:39 <DenizzzZ> Michigan Tek. Instu.
08:58:48 <ski> ah, ty
08:58:55 <DenizzzZ> np
08:59:04 <shapr> they also teach Haskell at LuleÃ¥ TU, and an UNSW.au
08:59:22 <shapr> and at oxford, and imperial college, and edinburgh, and lots of others
08:59:24 <DenizzzZ> I am currently programming a SUD..
08:59:34 <DenizzzZ> heh..
08:59:38 <shapr> Special Umbrella Destroyer?
08:59:39 <ski> sud ?
08:59:46 * ski chuckles
08:59:58 <kristnjov> MUD but single player
09:00:03 <shapr> oh
09:00:10 <shapr> a text based game
09:00:14 <kristnjov> kind of like "adventure" in emacs
09:00:18 * ski thinks he've seen the lab docs .. :)
09:00:20 <shapr> dunnet is better
09:00:29 <shapr> lemme guess, you're going to use a tree to make the maps?
09:00:33 <musasabi> How can one ask ghc to pass extra flags to gcc and ld?
09:00:43 <kristnjov> shapr correct, but we don't have to though
09:00:47 <shapr> -I for ld, and I forget the gcc arg
09:00:52 <shapr> -L ?
09:00:54 <adept> musasabi: -msomething ...
09:00:57 <ski> shapr : if they're ambitious, it says they can try with a graph
09:00:57 <shapr> oh
09:01:11 <shapr> but, a tree is just a special case of a graph?
09:01:29 <ski> but some graphs are not trees
09:01:33 <earthy> one that is somewhat easier to deal with in the setting of functional languages, I might add. ;)
09:01:52 <shapr> sure, graph is a superset of tree, doesn't that make it easier?
09:02:04 <shapr> not that I've actually tried to write an adventure game
09:02:18 <ski> depends on how easy the respective implementations are ..
09:02:24 <thebug> "go left"
09:02:35 <kristnjov> i believe we only have a right and a left direction so we could just as well use lists
09:02:37 <adept> musasabi: chapter 4.10.2 of ghc docs
09:02:43 <thebug> "You fall off of your unicycle in a spectacular crash into a wall."
09:02:50 <thebug> ;)
09:03:06 <ski> data Map = Room Info [Items] [(Dir,Map)]   or something ..
09:03:08 <kristnjov> "your genitals get stuck in the ps2-port for no particular reason. enter action"
09:03:26 <adept> no, no! "you are lost in the little twisted lambdas, all alike"
09:03:31 <thebug> haha
09:03:36 <ski> heh
09:03:43 <kristnjov> i don't get it :|
09:03:46 <shapr> you find a small compiler gently saying "feed me"
09:03:46 <thebug> surrounded by menacing looking mondads
09:03:55 <thebug> without the extra 'd'
09:04:02 <shapr> tuesdads?
09:04:13 <thebug> aye, that's the ticket
09:04:29 <adept> it's getting dark. You are likely to be consumed by an eager computation
09:04:33 <shapr> heh
09:04:40 <thebug> no, a greedy regexp
09:04:53 <earthy> hm. reading spanish really brings down my reading speed
09:05:12 <earthy> why do people insist on writing PhD theses in their mother tongue? :)
09:05:16 <kristnjov> one would think your speed would increase
09:05:30 <shapr> theses should be written in Haskell.
09:05:34 <shapr> obviously
09:05:55 <earthy> um. :)
09:05:56 <adept> kristnjov: take a look at most recent ICFP contest. Contestants had to mode a game world, essentially....
09:09:36 * ski says bye to #haskell
09:10:23 <kristnjov> time to take my annual shower
09:10:26 <kristnjov> see you in five
09:10:57 * adept . o O (annual shower???)
09:11:32 <musasabi> hmm found it (-optc)
09:11:45 <musasabi> but still no easy way to do it..
09:11:52 <shapr> adept: I'm afraid to ask... I can only hope that's a vocabulary error.
09:12:02 <musasabi> because ghc feeds incompatible options to gcc..
09:12:27 <shapr> can't you tell ghc to use a custom name for gcc and write a wrapper shell script?
09:12:31 <dv_> i have a function that randomly returns one of two functions, is there any way to get rid of the IO in its type?
09:12:46 <shapr> man, I can't find any arrow-based interpreters other than these examples.
09:12:52 <shapr> dv_: don't make it random...
09:13:21 <shapr> pseudorandom and deterministic are both referentially transparent
09:14:39 <adept> !time kristnjov
09:14:47 <adept> no luck :(
09:14:55 <dv_> hm
09:34:34 <kristnjov> adept, what :P
09:34:50 <kristnjov> the word in sweden is that excessive washing is bad for you
09:35:36 <shapr> I thought guys told that to each other so that they could get more women than those who actually believed it.
09:35:59 <kristnjov> but that's just what YOU thought
09:36:22 <kristnjov> stoner rock and not washing is life.
09:36:22 <shapr> after a coupla hours of unicycling, not even guys will stand next to me.
09:37:46 <kristnjov> stoner rock and not washing is life.
09:37:50 <shapr> after a coupla hours of unicycling, not even guys will stand next to me.
09:37:56 <shapr> :-P
09:38:13 <kristnjov> why would you unicycle for hours? :P
09:38:29 <shapr> it's fun
09:38:33 <desrt> s/ for hours//
09:38:43 <shapr> speaking of which... now is a good time to go unicycle...
09:38:54 <kristnjov> wtf..
09:39:09 <desrt> ^^ this is your brain on monads
09:40:39 <tromp> anyone here know mark tullsen?
09:45:40 * adept looks at http://pleac.sourceforge.net/pleac_haskell.html
09:49:44 <Boegel> hello every1
09:50:55 <Cale> for all x, hello x
09:51:00 <Lemmih> Hey Boegel.
09:51:25 * Cale finds factors of 2^1000 + 1
09:51:37 * Cale finds factors of 2^10000 + 1
09:53:47 <Boegel> Cale, you really are a mathematician aren't you :p
09:53:51 <Cale> heh
09:54:03 <Boegel> :o)
09:54:25 <Cale> It's quite amazing what computers are capable of these days :)
09:54:34 <Boegel> why's that ?
09:54:47 <kristnjov> why is it not?
09:54:50 <Boegel> do you mean spyware ? 'cause I had my share the last couple of days :p
09:55:49 <Lemmih> Boegel: Then don't install software from people you don't trust.
09:56:07 <kristnjov> exactly
09:56:15 <kristnjov> spyware is so easy to avoid these days
09:56:20 <kristnjov> viruses such as blaster is a bit harder
09:56:33 <Boegel> spyware isn't that easy
09:56:41 <Boegel> I installs itself when you use IE
09:56:48 <kristnjov> yeah, so don't use ie :)
09:56:50 <Lemmih> Do you trust IE?
09:56:52 <kristnjov> firefox is really amazing
09:56:53 <Boegel> many people ask themselves how this is possible
09:56:55 <Lemmih> I don't.
09:56:56 <Boegel> no I don't
09:56:58 <Boegel> I use Firefox
09:57:07 <Boegel> but my girlfriend won't use Firefox
09:57:18 <Boegel> because she says not all websites work with it
09:57:25 <Lemmih> Boegel: You can always dual boot (-:
09:57:34 <kristnjov> well that's microsoft's fault really and people shouldn't adjust to it
09:57:39 <Boegel> and when I say it's not Firefox, it's the websites, I get a slap around the ears :p
09:58:01 <Boegel> I try to convince her, but still..
09:58:07 <Boegel> I'm really glad with Firefox
09:58:26 <Boegel> it blocks what it should block, but let's through what it should let through
09:58:54 <Boegel> only stupid people who build a website for IE prevent Firefox from growing to the big public (like nivea.be)
10:03:20 <TheHunter> what's the best commenting style when you want to switch frequently between two implementations? (like #if 0, #else #endif in C)
10:04:31 <Cale> using typeclasses to abstract over data :)
10:04:49 <TheHunter> "close the comment if it's open" is easy, but i don't know how to do it the other way round
10:14:42 <TheHunter> ok, it's impossible. That really sucks.
10:19:56 <tromp> why not use multiline comments {-   .....   -}    ?
10:21:11 <TheHunter> yeah, but i still have to make changes at at least two places.
10:21:24 <tromp> yep.
10:21:56 <Lemmih> And you can't use cpp?
10:22:16 <tromp> but at least you can match up the { and } in any decent editor
10:22:35 <TheHunter> Lemmih: i'd like to use ghci.
10:22:38 <tromp> and maybe write a macro to change them with one keystroke
10:22:59 <tromp> what editor do you use?
10:23:09 <TheHunter> vi, i think it should be able to do it
10:23:18 <TheHunter> err, vim
10:23:21 <tromp> yes, that should be well within vi's power:)
10:23:45 <tromp> ppl have written macros to solve ascii mazes...
10:23:48 <Lemmih> GHCi doesn't allow preprocessing?
10:23:55 <TheHunter> does it?
10:26:17 <Lemmih> There's one way to find out...
10:32:37 <TheHunter> alright, thanks. (ghci allows preprocessing, of course).
10:34:37 * TheHunter types alias ghci='ghci -cpp -fglasgow-exts -fno-monomorphism-restriction'
10:35:32 <Lemmih> '-fno-monomorphism-restriction' -> [True,10,"Hey"]?
10:36:44 <TheHunter> Lemmih: ?
10:37:04 <Lemmih> I just don't know that flag.
10:37:23 <TheHunter> it's awfully useful.
10:38:17 <TheHunter> it lets you define x = 3 in ghci and later apply x to a function f :: Int -> Int
10:44:04 <musasabi> hmm I wonder why Data.HashTable is still slow even with update working..
10:54:15 <Cale> Which flag?
10:54:50 <TheHunter> '-fno-monomorphism-restriction', i suppose
11:00:30 <vegai> huh?
11:00:37 <vegai> I thought it allows that without the flag too
11:01:19 <vegai> oh, the other way around
11:01:35 <TheHunter> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
11:02:10 <TheHunter> the problem is, as soon as you dont give x a type, it must, according to the report, get a monomorphic type, i.e. Num a => a defaults to Integer
11:05:08 <shapr> hei tuomov, hyvÃ¤Ã¤ ihltaa
11:07:03 <shapr> man I love unicycling.
11:07:49 <heatsink> can you secure a unicycle to a bike rack?
11:07:51 <tuomov> iltaa
11:08:47 <heatsink> There are a few unicyclists on this campus
11:09:12 <tuomov> I'm trying to fix withLCString (I think) I ripped from somewhere, but can't seem to find anything wrong with it
11:09:13 <shapr> heatsink: I can secure a bike rack to a unicycle, does that count?
11:09:14 <heatsink> They seem to prefer sitting very high
11:09:29 <shapr> seatpost-mounted racks
11:09:29 <tuomov> It's corrupting the data
11:09:45 <heatsink> shapr: only if it's easier to abscond with a bike rack than with a unicycle
11:09:49 <shapr> @index withLCString
11:09:49 <lambdabot> bzzt
11:10:21 <shapr> oh that sort of bike rack, something where you lock up the unicycle. Sure, I have lock for my uni.
11:10:25 <shapr> tuomov: where'd you get withLCString?
11:10:30 <tuomov> it's from ginsu (http://repetae.net/john/computer/ginsu/)
11:10:35 <shapr> ah, ginsu
11:10:47 <shapr> CWString.hsc
11:11:06 <tuomov> I have 'to_locale str = withLCString str (\s -> peekCString s)' to convert data to edit in an external editor
11:11:13 <tuomov> but it occasionally corrupts it
11:11:35 <shapr> I'd suggest you ask John, he's very helpful.
11:11:42 <shapr> but he's not on #haskell, sadly
11:11:50 <shapr> do you have any cases where the string is always corrupted?
11:12:08 <tuomov> no, it's completely random, but happens quite often after a while..
11:12:20 <shapr> it's somehow cumulative?
11:12:21 <tuomov> I have an alternatively implementation that uses iconv, and it works ok
11:12:22 <shapr> that's scary
11:12:33 <tuomov> but I don't trust iconv and nl_langinfo working on every platform
11:14:19 * shapr stares at CWString.hsc
11:14:54 <shapr> have you figured out how the string gets mangled?
11:15:15 <tuomov> it's as if the trailing \0 was missing
11:15:39 <shapr> the first suspect I'd look at is mallocArray0
11:16:54 <shapr> it doesn't look like anything obvious, I'd suggest you email John, he may have a good answer.
11:17:12 <shapr> I'd look at it more, but I'm about to go back out for more unicycling.
11:17:31 <heatsink> This haskell compiled C code is tricky stuff
11:18:57 <shapr> tuomov: before I disappear, is this part of RIOT you're working on?
11:19:06 <tuomov> yeah
11:19:18 <shapr> cool
11:19:33 <shapr> I've only known about riot for a few days, haven't investigated it yet.
11:19:52 <shapr> sure looks neat
11:19:59 * shapr disappears
11:27:42 <musasabi> Is there a way to read lines of a file (with getLine) in a tail recursive way ?
11:28:39 <tuomov> hmm.. should mbsrtowcs null-terminate the result string?
11:28:58 <tuomov> manually terminating it seems to fix the problem
11:29:31 <tuomov> I've always thought it should be terminated
11:32:49 <musasabi> The main problem is that adding the catch makes it eat stackspace.
11:36:12 <psi> the hardest thing about programming, is to think of good names for your functions and variables.
11:36:22 <psi> i always come up with retarded names
11:36:31 <heatsink> I usually go for the verbose option
11:37:37 <heatsink> musasabi: will this work? foo = do {a <- getLine; foo}
11:38:04 <musasabi> heatsink: that works.
11:39:16 <musasabi> heatsink: foo acc = do { a <- getLine `catch` ...; case a of "" -> return acc; _ -> foo (stuff with a and acc) } does not.
11:47:42 <shapr> tuomov: it is using CStrings at some point, so I would also assume they'd be null-terminated.
11:48:41 <tuomov> s/wcsrtombs/ above
11:50:30 <tuomov> I wonder if my libs is just broken
11:50:36 <tuomov> s/libs/libc/
11:51:04 * shapr builds riot
11:51:41 <tuomov> in any case, riot/darcs should no properly support all kinds of locale encodings (and save things as utf-8) if the system has proper wchar_t support and working iconv
11:53:46 <shapr> oh, libncursesw5-dev 
11:56:17 <shapr> hm, I can't add or edit
11:56:47 <shapr> ohh, can't call gnuclient
11:57:08 <shapr> yay, spiffy
11:58:30 <shapr> tuomov: does left arrow collapse a node's children?
11:58:33 <shapr> or should it?
11:58:42 <tuomov> backspace does collapse children or the node
11:59:01 <shapr> ah, I see
11:59:06 <shapr> gutenabend pesco 
11:59:24 <pesco> Moin shapr!
12:00:32 <shapr> tuomov: neato
12:01:37 <shapr> mbox format is handy too
12:01:54 <pesco> mmmm, mbox
12:02:44 <pesco> shapr: How's code?
12:02:46 <tic> mm, food
12:03:27 <shapr> I'm playing with Riot at the moment, but I'm looking for arrow-based interpreters too
12:03:49 <pesco> What's Riot?
12:03:54 <shapr> http://modeemi.fi/~tuomov/riot/
12:04:05 <shapr> http://iki.fi/tuomov/riot/
12:04:26 <pesco> Cool.
12:06:12 <shapr> pesco: you know of any arrow-based interpreters other than Hughes' and patersons?
12:06:45 <pesco> What is an arrow-based interpreter? Interpreter for what? Haskell?
12:06:51 <shapr> actually, for Joy
12:07:04 <shapr> like a monadic interpreter, but using arrows instead
12:07:28 <pesco> Even the term "monadic interpreter" is new to me.
12:07:48 <pesco> And what's Joy? I feel pretty unknowledgable.
12:08:07 <shapr> Joy is a nifty language, postfix stack-based concatenative purely functional
12:08:23 <pesco> I see... I've found it on google.
12:09:28 <pesco> Oh, phone, brb.
12:10:50 <pesco> Bah.
12:11:18 <shapr> sucky phone call?
12:11:25 <shapr> or sucky Joy? :-)
12:11:47 <shapr> tromp was wondering about qsort in Joy
12:11:51 <pesco> Sucky phone call, she didn't pick up. ;-)
12:11:56 <shapr> heh
12:13:59 * shapr grabs the two latest riot patches
12:14:03 <shapr> darcs is sooo nice
12:14:08 <pesco> :)
12:15:42 <pesco> Do you know of algorithms to draw arbitrary 3D curves on 2D raster displays?
12:15:55 <shapr> no?
12:16:07 <pesco> Ok.
12:17:05 <phubuh> how are the curves defined?
12:17:05 <pesco> My principal goal in life is to make this reality approximate cool science fiction realities.
12:17:26 <shapr> pesco: I am totally with you.
12:17:46 <pesco> phubuh: I'm not sure. As functions [0,1] -> R^2?
12:17:51 <pesco> Er, R^3.
12:19:47 <phubuh> i know of one algorithm, but it's really dumb
12:19:55 <phubuh> choose an arbitrary delta and connect the dots :P
12:20:31 <pesco> shapr: The thing is, in science fiction, space ships are always displayed as cool glowing wire-frame schematics.
12:21:29 <pesco> _But_, in the future, the one thing wireframe models should not have, is edgy curves.
12:21:30 <shapr> I see your point.
12:21:35 <shapr> edgy curves?
12:22:43 <pesco> Well, curves approximated by low-resolution line strips.
12:23:15 <pesco> As in, the curve is continuously differentiable, but what's displayed isn't.
12:23:26 <shapr> hmm
12:24:58 <phubuh> doesn't that rule all raster displays out? :)
12:25:15 <pesco> phubuh: *frown*
12:27:05 <pesco> I should have said "what's displayed is distinguishably non-differentiable".
12:56:10 <shapr> pesco: sounds good to me
12:56:20 <tuomov> are signals handled at all if I'm in a foreign call?
13:08:31 <Oejet_> ]ghc tidstest.hs +RTS -K10M
13:08:31 <Oejet_> ]./a.out
13:08:31 <Oejet_> Stack space overflow: current size 1048576 bytes.
13:08:31 <Oejet_> Use `+RTS -Ksize' to increase it.
13:08:47 <Oejet_> I don't understand this!
13:13:03 <Oejet_> He, got it:  ]./a.out +RTS -K10M
13:19:32 <Igloo> The correct fix is often adding a strictness annotation or tw orather than increasing the stack size
13:28:35 <Marvin--> Igloo: hey, were you going to have a look at packaging cpphs?
13:28:49 <Igloo> Yes, why?
13:29:39 <Marvin--> I'm too lazy to look up the mailbox and see if I remembered it right and I don't want to duplicate work :P
13:29:49 <Igloo> lol
13:37:48 <Boegel> hello every1
13:38:41 <Marvin--> hello to you 2
13:38:59 <Marvin--> ... what am I doing
13:39:02 * Marvin-- shudders
13:40:21 <Lemmih> Btw, who named Control.Concurrent.Chan.writeList2Chan?
13:59:53 <Boegel> what is the problem with using 1,2,4 and so on ?
14:01:36 <ntfirewall> does anyone know good forums on haskell
14:05:53 <Boegel> just ask it in here ntfirewall, we'll probably be able to help you...
14:06:44 <Lemmih> Boegel: Using '2' instead of 'To' is annoying and shouldn't be done.
14:07:21 <pesco> There I am.
14:07:36 <Lemmih> Especially not in something as serious as the GHC libraries.
14:07:52 <pesco> Hi Lemmih. What's up?
14:08:56 <Lemmih> pesco: Hacking, trying to figure out if I had any homework due to morrow.
14:09:06 <Lemmih> *tomorrow
14:09:11 <pesco> Heh
14:10:05 <Lemmih> I'm getting more and more happy with my DC library.
14:10:09 <ntfirewall> <Lemmih> he did not use 2 <  i think your script changes it to "to"
14:10:41 <pesco> Lemmih: What's DC?
14:11:05 <Lemmih> pesco: Direct Connect. File sharing network.
14:11:38 <Lemmih> ntfirewall: I don't follow...
14:12:34 <pesco> Lemmih: Ah. Sounds fun, do you have anything specific in mind with your library?
14:14:15 <Lemmih> pesco: Yes. I'm gonna make the perfect DC client (-: DCGUI, DCGUI-qt and *text based DC client which I can't remember the name of* have annoyed me for the last time!
14:14:41 <pesco> What's wrong with mldonkey?
14:15:02 <pesco> (Sorry, I'm not trying to break your initiative!)
14:15:03 <Lemmih> I've heard that it can't upload to the DC network.
14:15:22 <pesco> Oh, I don't know. I'm only running it on eDK and FT currently.
14:16:02 <Lemmih> pesco: http://dcplusplus.sourceforge.net/wiki/index.php/mldonkey
14:16:43 <Lemmih> Highlight: "It's a leechers' tool, hubs are treated as locations to find files from, and banned by all DC hubs aware of its existance."
14:21:21 <pesco> Am I reading that correctly, DC hubs ban mldonkey clients?
14:22:03 <Lemmih> I think so, though I can't confirmed it from other sources.
14:22:31 <pesco> Hm.
14:24:18 <Lemmih> s/can't/haven't/
14:27:33 <Boegel> does anyone have experience with compiling Java programs to executables for win32?
14:28:29 <Lemmih> I've never really used Java nor Windows.
14:35:57 <Boegel> and does anyone have experience with php and an MS Access db ?
14:36:30 <pesco> Boegel: Stop it, it's gotting cold in here! ;]
14:36:36 <pesco> getting even
14:36:40 <Boegel> I'm looking at a page right now, but I'm wondering how I can set up the ODBC connection when I put the db and the php page on a server that isn't mind
14:37:13 <Boegel> pesco, getting even with me ?
14:37:45 <pesco> No, I mean, I feel the temperature dropping as you speak those words.
14:39:46 <xs> hm. is there a reason why instance Foo (a, a) where { blah } is not permitted? (i see hugs has an extension..)
14:40:20 <Boegel> I can only ask can I :p
14:40:34 <Boegel> I don't know if it's even possible without an ODMG connection...
14:40:40 <Boegel> ODBC I mean :p
14:45:29 <tromp> @type replicate
14:45:31 <lambdabot> replicate :: forall a. Int -> a -> [a]
14:46:22 <tromp> @type concat
14:46:24 <lambdabot> concat :: forall a. [[a]] -> [a]
15:11:53 <shapr> wossname: lovely nickname there
15:12:15 <shapr> xs: so, you're the guy those Haskell files are always talking about? do you have a brother named x?
15:12:55 <Maddas> haha
15:14:01 <shapr> Boegel: I can show you how to do webpages with Haskell and PostgreSQL on Linux
15:18:29 <shapr> greetings eugos 
15:18:46 <eugos> shapr, hi
15:19:16 <shapr> looking for Haskell info?
15:19:37 <shapr> anything I can help you with?
15:20:19 <eugos> shapr, thank you, but probably later :)
15:20:23 <shapr> ok
15:20:37 <shapr> feel free to ask me if you come up with any questions.
15:20:46 <shapr> if you're new to Haskell or functional programming, I can give you the quick tour.
15:21:20 <eugos> shapr, at the moment I'm mostly interested in OCaml, but, you know, we all are from the same camp ;)
15:21:30 <shapr> yup
15:21:32 <pesco> Eheh. :)
15:21:44 <xs> shapr: yes. that's why i insist on always using pairs.
15:22:00 <shapr> xs: aha! so that's what Pair Programming is all about!
15:22:16 <eugos> shapr, thanks again :) honestly #haskell is the most active of three: #sml, #ocaml, #haskell. it's nice, guys :)
15:23:17 <xs> shapr: scheme being an inherently (..)paired programming language.
15:23:29 <shapr> well, people ask questions and get answers here
15:23:47 <tromp> is P == NP :-?
15:24:09 <pesco> I think so.
15:24:22 <eugos> shapr, and there are no stupid questions, are they? stupid is as stupid does ;)
15:24:35 <wossname> the tootsie roll pop: how many licks?
15:25:19 <shapr> wossname: the turtle always ate the pop
15:25:21 <shapr> so did the owl
15:25:24 <wossname> :o
15:25:30 <shapr> I actually counted once, it was 35
15:25:37 <wossname> 35 licks?!
15:25:46 <wossname> your tongue must be made of sandpaper
15:25:48 <shapr> yah, I expected something much higher.
15:25:52 <shapr> women love me
15:25:57 <wossname> :D
15:25:59 <shapr> as long as I stay at a distance ;-)
15:26:06 <eugos> shapr, :-D
15:26:26 * shapr snickers
15:27:22 <shapr> eugos: I think stupid questions happen when someone hasn't even tried a five minute Google search for something.
15:27:49 <shapr> of course, sometimes I'm really bad at searching google, so I still ask stupid questions without meaning to.
15:28:07 <shapr> so I try to make up for it by being really patient with questions from others.
15:28:14 <eugos> shapr, sure, firstly brain+google :)
15:29:39 <shapr> anyway, if you have some questions about Haskell, I'd be happy to answer them if I can.
15:29:54 <shapr> I can point you to the introduction for the really impatient if you like.
15:30:36 <eugos> shapr, ok
15:30:52 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
15:31:17 <shapr> be warned, I wrote that, so it might suck.
15:32:11 <shapr> but I'd like to hear any suggestions for improvement
15:32:59 <eugos> shapr, my God! I see it is enough to have only one person, you, to promote Haskell actively. :)
15:33:12 * shapr blinks
15:33:22 <pesco> That's a cool page, shapr.
15:33:49 <eugos> shapr, bookmarked for the sake of the nearest future 
15:33:52 <shapr> :-)
15:34:15 <shapr> pesco: thank you, any ideas for improving it?
15:34:35 <shapr> eugos: you want the quick tour of #haskell while I'm doing the lambda cheerleader act?
15:34:36 <pesco> Yes, may I add an entry on where clauses?
15:34:42 <pesco> Haha!
15:34:50 <shapr> pesco: yes please!
15:34:55 <shapr> naturlijk
15:35:00 <shapr> um naturligtvis
15:35:03 <shapr> bien sur
15:35:06 <shapr> how do you say that in german?
15:35:08 <eugos> shapr, well, I didn't expect to do it but tomorrow I'll reread "Gentle intro.. to Haskell" to recall the language
15:35:13 <shapr> naturlich?
15:35:42 <pesco> shapr: natuerlich.
15:35:43 <eugos> shapr, ich auch verstehe deutsch :)
15:36:01 <pesco> shapr: ue is alternative spelling for u-Umlaut.
15:36:14 <shapr> ah, I see.
15:36:24 <shapr> I don't speak much german, sadly.
15:36:36 <shapr> but hopefully my fiancee will teach me german one day.
15:36:56 <pesco> I think a historical way of writing the Umlauts is with a small 'e' on top instead of the dots. Thus that alternative spelling.
15:37:12 <shapr> eugos: I can still give you the tour of the haskell irc channel before you've read the gentle intro :-)
15:37:24 <shapr> oh neat
15:37:27 <eugos> shapr, it would be so kind of you
15:38:02 <shapr> ok, local tourist spots are the irc bot, lambdabot; the Haskell Wiki; and the channel logs.
15:38:12 <shapr> oh, and the learning pages on haskell.org
15:38:22 <shapr> lambdabot is good for finding things and getting some details on things
15:38:33 <shapr> @index anyChar
15:38:33 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
15:38:44 <shapr> @type Text.ParserCombinators.Parsec.anyChar
15:38:45 <lambdabot> Text.ParserCombinators.Parsec.anyChar :: forall st.
15:38:45 <lambdabot> 					 Text.ParserCombinators.Parsec.Char.CharParser st Char
15:38:50 <shapr> @info Eq
15:38:51 <lambdabot> -- Eq is a class
15:38:51 <lambdabot> class Eq a where {
15:38:51 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
15:38:51 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
15:38:51 <lambdabot>     }
15:39:11 <shapr> NB. the @type plugin was written by pesco
15:39:37 <shapr> the Haskell wiki has useful code and lots of info: http://www.haskell.org/hawiki/RecentChanges
15:40:25 <shapr> the channel logs are available at http://tunes.org/~coreyr/ for the last week, and the last few years are available at http://tunes.org/~nef/
15:40:36 <shapr> and the learning page is http://www.haskell.org/learning.html
15:40:49 <shapr> eugos: ok, you've had the short tour!
15:40:57 <shapr> tada!
15:41:32 <shapr> I wonder if I left out anything.
15:41:33 <eugos> shapr, thank you so much :)
15:41:48 <shapr> you're welcome
15:41:57 <shapr> if you have any specific questions, feel free to ask me.
15:42:13 <eugos> shapr, at any time?
15:42:20 <shapr> well, sure
15:42:25 <eugos> shapr, ok
15:42:28 <shapr> if I'm busy or not awake, I probably won't respond.
15:42:41 <shapr> but I will get back to you when I have time.
15:43:29 <eugos> shapr, yet another question: why do you do it all? ;)
15:43:37 <shapr> well, what all?
15:43:56 <shapr> the channel, the wiki, IOHCC, haskell-libs
15:44:00 <shapr> I enjoy it.
15:44:26 <shapr> the only more fun than programming is sex
15:44:35 <eugos> shapr, great! so, you are really the right person to ask help
15:44:53 <eugos> shapr, I agree with you entirely :)
15:44:59 * shapr grins
15:45:30 <shapr> I also think that the best way to enjoy programming is to learn a lot about it, and to read and write a lot of code.
15:45:52 <shapr> especially different kinds of code
15:45:55 <eugos> shapr, sure
15:46:01 <shapr> functional, procedural, logic/constraint
15:46:04 <xs> @info Ix
15:46:31 <shapr> why are you investigating functional programming?
15:46:35 <shapr> are you computer science student?
15:46:59 <shapr> or maybe a professional programmer looking for a better way?
15:47:20 <shapr> @index Ix
15:47:20 <lambdabot> Data.Array,Data.Array.Diff,Data.Array.IArray,Data.Array.IO,Data.Array.MArray
15:47:20 <lambdabot> Data.Array.ST,Data.Array.Storable,Data.Array.Unboxed,Data.Ix,GHC.Arr,Array
15:47:20 <lambdabot> Ix
15:47:32 <shapr> @info Array.Ix
15:47:33 <lambdabot> -- GHC.Arr.Ix is a class
15:47:33 <lambdabot> class (Ord a) => GHC.Arr.Ix a where {
15:47:33 <lambdabot>     GHC.Arr.range :: (a, a) -> [a];
15:47:33 <lambdabot>     GHC.Arr.unsafeIndex :: (a, a) -> a -> Int {- has default method -};
15:47:33 <lambdabot>     GHC.Arr.index :: (a, a) -> a -> Int {- has default method -};
15:47:34 <lambdabot>     GHC.Arr.inRange :: (a, a) -> a -> Bool;
15:47:36 <lambdabot>     GHC.Arr.rangeSize :: (a, a) -> Int {- has default method -};
15:47:38 <lambdabot>     GHC.Arr.unsafeRangeSize :: (a, a) -> Int {- has default method -};
15:47:40 <lambdabot>     }
15:47:42 <shapr> yow
15:47:43 <shapr> that's big
15:48:03 <eugos> shapr, no, I'm working mainly with Java (at one European bank), but at home and in some small project where I have enough freedom I use what I want: Python, OCaml, etc.
15:48:29 <xs> ya. does lambdabot read this from some file? or some language introspection?
15:48:43 <shapr> xs: haddock indices
15:49:14 <xs> hm. what?! :)
15:49:16 <shapr> it's a quick and ugly hack where I cut'n'paste'd most of haddock's Main.hs into a lambdabot plugin
15:49:32 <shapr> http://www.haskell.org/haddock/
15:49:49 <xs> ahh! i see! cool..
15:50:01 <eugos> shapr, and I'm also a maintainer of the FreeBSD OCaml port 'cause I like the language :)
15:50:02 <shapr> xs: if you've seen http://www.haskell.org/ghc/docs/6.2.1/html/libraries/index.html 
15:50:06 <shapr> spiffy!
15:50:21 <shapr> xs: so I ripped off the code that builds these indices: http://www.haskell.org/ghc/docs/6.2.1/html/libraries/doc-index.html
15:50:48 <shapr> all of the debian packages come with a libname.haddock.gz
15:50:57 <shapr> base.haddock.gz, lang.haddock.gz, etc
15:51:01 <xs> aha, neat.
15:51:28 <shapr> then I massaged those into String to [String] finitemaps
15:51:48 <shapr> it was really simple
15:52:03 <xs> heh :)
15:53:04 <pesco> "massaged" Heheh
15:54:38 <cptchaos> eugos: I thought about learning OCaml, but I don't have time at the moment. (and at the first look, Haskell looked more awesome
15:55:07 <cptchaos> eugos: maybe except speed and size of the compiled programs ...
15:55:20 <shapr> hi G|u][
15:55:28 <pesco> Oh, hi cptchaos!
15:55:43 * shapr suspects pesco hit the 'boss key'
15:55:49 <Maddas> Heh
15:55:51 <shapr> or maybe in this case the girlfriend key
15:56:04 <shapr> oh maybe not, he's back!
15:56:05 <pesco> Gah, hit A-x.
15:56:06 <Maddas> The boss left again?
15:56:17 <eugos> cptchaos, Haskell looks really awesome, it's true
15:56:34 <pesco> No, I just have A-x bound to ioncore.shutdown... (Reminds me of the old Wing Commander days).
15:56:35 <shapr> pesco: I thought you hit the boss key, or maybe the girlfriend key
15:56:40 <shapr> heheh
15:56:40 <pesco> Heh.
15:56:58 <shapr> wing commander was great
15:57:36 <shapr> hey, is that part of the beautiful future?
15:57:44 <shapr> pesco: do you have a name for your project?
15:57:48 <pesco> Yeah, you know how they are, if she sees me in X-Windows it can ruin an entire evening.
15:57:55 * shapr snickers
15:59:21 <pesco> shapr: Wing Commander... apart from the physics model, absolutely.
15:59:30 <cptchaos> hm, I will go to bed now, good Night to all (or what ever your lacal time is)
15:59:38 <pesco> cptchaos: Night.
15:59:39 <shapr> pesco: locate arrowex4.hs (part of fptools cvs repo) to see an arrow-based interpreter
15:59:41 <shapr> g'night cptchaos 
16:00:16 <pesco> shapr: I'm not entirely sure what the project is, currently.
16:00:40 <shapr> hack the future?
16:00:45 <shapr> oh wait
16:00:49 <shapr> hack to the future
16:01:00 * pesco laughs.
16:01:05 <Maddas> heh
16:01:08 <pesco> That's not too bad.
16:01:25 <shapr> cheesy as a half kilo of gorgonzola too
16:01:38 <pesco> I'm a huge fan of Back to the Future.
16:01:47 <shapr> me too
16:01:59 <pesco> There is a certain kind of cheesiness which is really good.
16:02:03 <shapr> yup
16:10:57 <shapr> I liked the Mr. Fusion he had on the car
16:15:57 <pesco> I most enjoy Doc Brown's exclamation "Marty!!".
16:17:39 <shapr> hi nerdlor, long time no see
16:17:56 <nerdlor> hey shapr -- hey, it's been a while
16:18:10 <nerdlor> took the summer off to ride my bike and stop thinking about programming
16:18:17 <nerdlor> (to the degree that my job allows that)
16:18:28 <shapr> I learned to unicycle this summer.
16:18:38 <nerdlor> nice -- that looks hard
16:18:48 <shapr> it's fun
16:20:29 <nerdlor> anyway, thought i'd see what haskellers are talking about these days
16:20:40 <shapr> lots of crazy stuff
16:20:46 <shapr> monads, arrows, epigram
16:20:56 <shapr> category theory, opengl, hack to the future
16:21:15 <nerdlor> far out. epigram?
16:21:28 <shapr> http://www.dur.ac.uk/CARG/epigram/
16:22:29 <nerdlor> cool
16:22:49 <shapr> depedent type systems are fun
16:23:15 <nerdlor> i'll take your word for it. when i see that much notation in a quick glance at the tutorial, i get antsy...
16:23:22 <SyntaxLaptop> shapr: I was just thinking that "simplicity, communication, feedback, and courage" (XP principals) might be the opposite of "Fear, Uncertainty and Doubt" :)
16:23:23 <shapr> it's actually really fun
16:23:30 <shapr> SyntaxLaptop: I agree :-)
16:24:58 <shapr> two ways that people will not criticize your code, either it's so simple everyone knows it's right, or it's so complex no one can tell.
16:25:13 <SyntaxLaptop> oh, speaking of triples, what's the third member of "laziness, hubris, ?"
16:25:26 <shapr> um
16:25:36 <shapr> forgetfulness? ;-)
16:26:03 <shapr> aha, google says impatience
16:26:26 <shapr> nerdlor: have you been studying anything interesting in programming lately?
16:27:33 <nerdlor> ha, not really. i'm just an "ordinary" grunt programmer, with an interest in the occasional esoteric (from the working-world POV) programming language topic
16:27:42 <nerdlor> i've been reintroducing myself to lisp lately
16:27:56 <shapr> well, I'm a grunt programmer too
16:28:05 <shapr> I get paid to write Python to make websites.
16:28:26 <shapr> and I dream of having a job writing Haskell making really cool programs.
16:28:29 <Boegel> I'll go and take a nap, greetings to everyone
16:28:37 <nerdlor> nice -- i did a bunch of python in the mid-nineties (!) when it was a bit wet still
16:28:46 <nerdlor> really liked it -- now very rarely use it
16:28:50 <shapr> Boegel: have a nice nap!
16:28:59 <Boegel> bye !
16:29:24 <SyntaxLaptop> shapr: thanks
16:29:27 <tuomov> shapr: one can always dream...
16:29:32 <nerdlor> shapr, what's going on with zope these days? last time i looked, it was getting really interesting.
16:29:34 <nerdlor> (and big!)
16:29:46 <nerdlor> do you use it in your work?
16:30:07 <shapr> yes, zope is getting interesting
16:30:11 <shapr> it's gaining more concatenative properties in version three
16:30:17 <shapr> and yes, zope is very very large
16:30:22 <shapr> even by itself
16:30:31 <shapr> once you add in the zillions of add-ons, it's even larger.
16:30:54 <shapr> tuomov: what do you do for a living?
16:31:11 <shapr> SyntaxLaptop: this sounds like a blog entry of yours inprogress maybe?
16:31:20 <tuomov> shapr: nothing
16:31:32 <tuomov> got fired a month ago
16:31:44 <shapr> wow, that's a good job if you can keep eating.
16:31:55 <shapr> gives you time to hack at least :-)
16:31:59 <tuomov> haven't even really started looking for another job, because I don't want one
16:32:22 <shapr> I took 'vacation' between jobs when I was still living in the US.
16:32:44 <shapr> usually I had enough money saved up for three or four months of fun before I had to start looking again.
16:32:48 <SyntaxLaptop> shapr: a letter actually. my blog is stalled by those DNS problems, but I think they're almost fixed.
16:32:57 <shapr> oh
16:33:04 <tuomov> I'm considering doing graduate studies in something instead, but I can't decide if I really want that, and in what exactly
16:33:17 <shapr> well, there's always vis
16:33:38 <tuomov> yeah, there would probably enough stuff for one phd thesis
16:33:38 <shapr> sounds like something you could write as a grad student.
16:33:43 <tuomov> but my msc degree is in maths..
16:34:05 <tuomov> probably won't be so easy moving to ui side, and I'd have to study lots of uninteresting stuff
16:34:07 <shapr> that doesn't matter in the US, is it more important in .fi?
16:34:21 <tuomov> they may require to take quite a few courses
16:34:34 <shapr> you do have the advantage of being able to show off ion and its popularity.
16:34:38 <tuomov> and I'm really more interested in studying maths/tcs sort of stuff
16:34:48 <tuomov> I'm just not sure if I want to research that
16:34:57 <shapr> yah, good point
16:35:32 <tuomov> maths research these days is banging your head to the wall, waiting for it to turn into an electron microscope..
16:35:37 <shapr> what's tcs short for?
16:35:44 <tuomov> theoretical computer science
16:35:48 <shapr> oh
16:35:54 <shapr> lots of good tcs stuff to research
16:36:00 <shapr> that's a wide-open field
16:36:02 <tuomov> but not much going on in .fi
16:36:20 <shapr> Oulu has a great computer security group
16:36:24 <shapr> I know some people there
16:37:14 <shapr> that's not exactly deep theory though
16:37:47 <tuomov> I don't even know if I want "deep" theory or something a bit more practical
16:38:06 <shapr> kohonen and torvalds are the most famous .fiple
16:38:11 <tuomov> all I know is I don't want to do "real" work
16:38:12 <shapr> at least, I think so.
16:38:34 <tuomov> if I can think of a way to avoid it
16:38:44 <shapr> what counts as real work?
16:38:53 <shapr> being a codemonkey?
16:38:57 <tuomov> yes
16:39:16 <tuomov> generally non-university, non-volunteer work
16:39:22 <shapr> I thought real work was having the time and the situation that let me write really good software
16:39:41 <shapr> codemonkey is more about being chained to your desk to write PHP eight hours a day
16:39:50 <shapr> at least, this is my viewpoint.
16:40:13 <tuomov> but "real" here is in a sarcastic sense
16:40:21 <tuomov> hence the quotes
16:40:32 <shapr> I was a Nokia-contractor codemonkey for a little while. That was 'real' work exactly as you describe it :-)
16:42:18 <tuomov> in finland 95% of the people in the field are nokia or nokia-contractor code monkeys
16:42:27 <tuomov> fscking nokialand
16:43:02 <shapr> from my americalainen viewpoint, .fi has a high-pressure society, pretty close to what I've read about .jp
16:43:48 <tuomov> I don't know...
16:43:58 <shapr> I think you might have an easier time finding what you're looking for in .se or .us
16:44:08 <tuomov> perhaps
16:44:51 <tuomov> or almost anywhere else... it's a small country where everything is "mobile" or "bio-"
16:45:01 <shapr> yes, I agree.
16:45:08 <shapr> Espoo is the center of the world.
16:46:03 <tuomov> but outside Finland, I don't even know where to start looking
16:46:08 <shapr> the high pressure does produce some amazing things, like the people who survive =)
16:47:28 <tuomov> I wouldn't know about that. I know a few people who work their asses off, but personally in my previous job I wasn't mostly doing anything
16:47:40 <shapr> maybe you could apply to some of the unversities in sweden or the usa?
16:48:09 <tuomov> maybe, if I knew exactly what I wanted
16:48:38 <shapr> when I'm in a situation like that, I usually make a list that broadly outlines what I do *not* want.
16:48:55 <shapr> like when I bailed out of my art degree
16:49:00 <tuomov> depending on the day, I can get everything on that list :)
16:49:05 * shapr laughs
16:49:35 <shapr> in that case, you probably need at least another month before you make that list :-)
16:50:23 <tuomov> to the two years in my old job I've been thinking of these things?-)
16:50:25 <shapr> After I got fired from my job in Seattle, it took me a few months of doing mostly nothing to get back my enthusiasm for programming.
16:50:49 <shapr> One thing I learned is that I can't stand to have a job that sucks me dry of enthusiasm.
16:51:05 <tuomov> I like programming free software, when I want, how I want. I do _not_ want to by symbian/j2ee/c++/mfc/win32/whatever wage slave
16:51:14 <shapr> yah, I agree.
16:51:16 <tuomov> s/by/be/
16:51:45 <shapr> my approach to that is to use open source software (specifically Zope and Plone) to build websites for my clients.
16:52:11 <shapr> that way I get to make cool websites for them and I can still eat.
16:52:20 <tuomov> my theore is that something being a job kills the enthusiasm in anything
16:52:29 <shapr> and they don't care if I want to return all my changes/bugfixes/etc back to the community.
16:53:18 <shapr> that may be true, if I get a Haskell job, will I get tired of Haskell?
16:54:09 <tuomov> possibly
16:54:20 <tuomov> of course it depends on the job
16:54:32 <shapr> on the other hand, with Haskell I'd get to abstract away the repetitive crap
16:54:47 <tuomov> but if you could complete self-manage your doings, it wouldn't be your job
16:54:53 <tuomov> s/your/a/
16:55:08 <shapr> with J2EE, I tried to convince my boss to let me use Jython
16:55:27 <shapr> tuomov: well, I am now self-employed, and it's a *lot* more fun.
16:55:46 <shapr> in some ways it's more stressful, I usually have either too much work or not enough money.
16:55:47 <tuomov> yeah, if you can live with what else comes with it
16:56:05 <shapr> but I can also sing loudly while coding, and tap my foot or run around my room
16:56:10 <shapr> and only the cats complain
16:57:11 <shapr> I'm a lot happier reaching those same old J2EE goals in less than half the time with open source software
16:57:17 <shapr> (java isn't OSS imho)
16:57:36 <shapr> tuomov: have you considered self-employment?
16:57:57 <tuomov> no, I'm not an enterpreneur type
16:57:59 <shapr> Tuomov HB?
16:58:14 <tuomov> I rather do all sorts of esoteric things
16:58:40 <tuomov> Like Ion, Vis, Haskell, maths, tcs, ...
16:59:04 <tuomov> how who would pay for such..
16:59:06 <shapr> hey yome, I want to hear about your parallel scheme implementation
16:59:30 <shapr> tuomov: commercial Haskell work does exist
16:59:43 <shapr> there's lots of cool tcs stuff
16:59:53 <shapr> Vis could probably get you a PhD
16:59:56 <yome> Hello, is there a way to create a local, recursive function (without Y) a la Scheme's "letrec" in Haskell?
17:00:06 <yome> shapr, hi!
17:00:30 <yome> shapr, if you have some precise question, I'll be happy to answer.
17:00:45 <shapr> yome: you still working on the parallel stack-based lang?
17:01:10 <Lunar^> yome: let f x = f x in y  
17:01:13 <heatsink> yome: let is letrec
17:01:22 <yome> shapr, somewhat, though I'll concentrate more on the GC in the near future.
17:01:29 <yome> Oh! :)
17:01:36 <shapr> my actual question is, is there any research on concurrent referentially transparent stack-based langs?
17:01:58 <shapr> I was wondering how to parallelize something like Joy
17:02:01 <yome> shapr, I don't know.
17:02:26 <yome> I think a trivial way to make a parallel stack-based language is to have a data stack and a return stack per process.
17:02:44 <shapr> hm
17:02:58 <shapr> tuomov: you could always ask for donations on the Ion website :-)
17:03:31 <shapr> ion and ratpoison are popular among emacs lovers.
17:03:48 <shapr> viv: not at work?
17:03:50 <tuomov> maybe I could get a month's living that way, but not more..
17:04:16 <viv> shapr: nope =)
17:04:26 <shapr> you could be a wage slave for a year at a time and save up for coding vacations between jobs.
17:04:32 <shapr> that's what I did
17:04:50 <shapr> and I live in a small town so life is cheap
17:05:10 <tuomov> possibly
17:05:28 <tuomov> but I need to decide if I want to do graduate studies..
17:05:34 <shapr> yup
17:05:39 <tuomov> no point in getting a job if you want to study
17:05:41 <tromp> where do u live, shae?
17:05:49 <shapr> tromp: Boden, Sweden
17:06:04 <shapr> The home away from home of the armed forces of Sweden.
17:06:12 <tromp> what's the nearest big city?
17:06:18 <shapr> LuleÃ¥
17:06:36 <shapr> and 800km south of here there's Stockholm
17:06:38 <tromp> that's on my map:_
17:06:55 <tromp> actually northernmost swedish city on the map:)
17:06:56 <shapr> that's good
17:07:16 <shapr> I live 90km south of the arctic circle.
17:07:32 <tromp> does lulea have an airport?
17:07:36 <shapr> I can barely wait for this year's snow to start so I can try unicycling on snow.
17:07:47 <shapr> yes, though not a large airport.
17:08:01 <tromp> i cld never get the hang of unicycling
17:08:17 <tromp> i'll take a recumbent any day:)
17:08:29 <shapr> I'd like to try one of the MR Recumbents
17:08:36 <tromp> MR?
17:08:39 <shapr> those look fast and powerful
17:08:47 <shapr> http://mrrecumbenttrikes.com/
17:09:06 <shapr> the 'touring car' version of the unicycle
17:09:12 <tromp> have you looked at the Quest/
17:09:33 <shapr> quest is a recumbent bicycle, right?
17:09:37 <tromp> www.velomobiel.nl
17:09:44 <tromp> it's a fully faired trike
17:10:05 <shapr> oh wow
17:10:36 <tromp> incredibly fast:)
17:10:39 <shapr> eek, it's a bit expensive
17:10:57 <tromp> not compared to other fully faired trikes
17:11:06 <tromp> like the Versatile
17:11:21 <tromp> my friend ordered one
17:11:33 <shapr> do they have a shaft-drive model?
17:11:41 <shapr> I've never liked chains much
17:11:45 <tromp> no, they like simplicity
17:12:26 <shapr> seems like a good car replacement
17:12:27 <tromp> shaft requires lots of custom designed parts
17:12:47 <tromp> you won't see much of the chain anyway
17:12:55 <tromp> completely sealed from dirt
17:14:06 <tromp> if u click on Velomobielrijders
17:14:19 <tromp> u can see who orders them and in what color
17:14:40 <shapr> I think I'd probably prefer the mango
17:14:49 <shapr> I'm a big fan of maneuverability.
17:15:00 <shapr> unicycles are very agile.
17:15:39 <tromp> oops, bedtime for me:(
17:15:46 <shapr> me too
17:15:47 <tromp> actually way past:(
17:15:58 <tromp> g'night folks
17:16:13 <shapr> g'night tromp
17:16:23 * shapr disappears
17:27:17 <yome> What's the opposite of '=='? (ie != or something) ?
17:27:29 <dons>  /=
17:28:30 <Cale>  /= is also xor, in case you're wondering where that is
17:28:54 <dons>  not (==) would also work, if you felt strange about /=
17:29:07 <yome> OK, thanks.
17:29:38 <heatsink> oh
17:29:44 <heatsink> yes, I was wondering about xor
17:30:10 <yome> What's the @ in somefun(a@(x:xs)) ?
17:30:19 <yome> I don't know how to search for that in the doc...
17:30:25 <dons> pattern binding
17:30:31 <heatsink> a = x:xs
17:30:34 <Cale> that matches a list of the form (x:xs) and binds the whole list to a
17:30:45 <Cale> (and the head/tail to x/xs
17:30:47 <Cale> )
17:30:47 <dons> bit like \( \) in sed..
17:30:58 <dons> ;)
17:34:57 <yome> Cool.  Haskell has quite a few syntactic shortcuts...
17:35:26 <Cale> like list comprehension syntax and do notation, yeah.
17:36:01 <dons> syntactic redundancy rocks
17:37:47 <heatsink> Cale: my solution to putting cyclic data in a list was this:
17:37:54 <heatsink>  a' = Vtx [a]; b' = Vtx[b];
17:38:01 <heatsink> [a,b] = reifyGraph [a',b']
17:38:55 <heatsink> the result is that a = Vtx [a] 1 and b = Vtx [b] 2
19:17:18 <yome> Is there a builtin function that returns all the elements of a list that satisfies a predicate?
19:17:30 <yome> Like 'filter' or something.
19:17:44 <yome> err
19:17:50 <yome> filter seems to actually exists.
19:17:57 <Pseudonym> Odd that.
19:18:05 <yome> :/
19:18:12 <Pseudonym> Sometimes, list comprehensions are more readable.
19:18:16 <yome> Talk about a stupid question.
19:18:23 <Pseudonym> filter p xs = [ x | x <- xs, p x ]
19:18:36 <yome> Nice.
22:51:56 <dblhelix> heatsink: did you solve all the problems you had with graphs and linked lists?
22:57:22 <dblhelix> heatsink: I'm off for an appointment now ... maybe we can discuss this later
23:28:19 <adept> morning (?)
