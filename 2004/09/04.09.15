00:16:02 <jesse99> woe is me: citeseer is down for maintenance
00:19:38 <jedeye> hey all :)
00:21:38 <jedeye> anyone know the command to replace text in a file?
00:33:35 <xkb_> commmand as in function?
00:34:13 <reffie> is there a bitwise and function in haskell?
00:34:31 <Pseudonym> import Data.Bits
00:35:22 <xkb_> (.&.) :: a -> a -> a
00:35:28 <reffie> thank you.
00:42:45 <musasabi> jedeye: perl -i -pe 's/foo/bar/g' ;)
00:48:50 <xkb_> or sed, for the brave
01:10:20 <pesco> ahoi
01:11:03 <xkb_> ola
01:11:27 * pesco waves
01:12:15 * xkb_ is still looking for use of exceptions in real-life programs
01:12:22 <xkb_> written in haskell/clean that is
01:12:34 <xkb_> esp. in the area of "modular" programming
01:12:51 <xkb_> where exceptions are used to sepparate module's error handling
01:13:33 <pesco> Hm, I've thrown them...
01:13:53 * shapr strikes out, completely unable to hit the thrown exceptions
01:14:06 <xkb_> I have written some simple exception handling code
01:14:19 <pesco> But have yet to use that code...
01:14:39 <pesco> Moin shapr!
01:15:32 <shapr> y0 y0
01:15:51 <pesco> xkb: Maybe we should hook up. :)
01:16:08 <xkb_> :D
01:16:18 <xkb_> I can catch em just fine :P
01:16:58 <pesco> My single-handed typing speed is improving!
01:17:18 <xkb_> I'm impressed
01:17:26 <xkb_> is that on a laptop?
01:17:38 <xkb_> or desktop with special keyboard?
01:17:41 <pesco> Yes.
01:17:51 <pesco> Er.
01:18:03 <xkb_> I found some dvorak keyboards for my powerbook
01:18:05 <pesco> Laptop
01:18:27 <xkb_> but they were tactile.. no keys.. just touchpad like material
01:18:43 <pesco> xkb: Gah!
01:19:07 <xkb_> and they cost about 200 usd
01:20:26 <shapr> hm, do I code or unicycle?
01:20:49 <earthy> both
01:20:50 <earthy> ?
01:20:54 <pesco> xkb: Single-handed typing isn't harder than two-handed...
01:21:00 <shapr> but which one first?
01:21:00 <earthy> pseco: yes it is.
01:21:25 <shapr> I do one handed typing, it sure is fun.
01:21:25 <earthy> you have to move your hand about more
01:21:37 * shapr has big hands
01:21:38 <musasabi> the recent haskell-cafe discussion seems to go into a sensible direction.
01:21:55 <shapr> musasabi: that's one of my favorite things about the haskell community
01:22:04 <musasabi> only if they could agree that a simple working solution would be good instead of a perfect one.
01:22:06 <shapr> sensible directions
01:22:28 <xkb_> on the binaryfile issue?
01:22:34 <shapr> on the pragmatic programmer's list there's this guy called Aryeh M. Friedman, you have to read his posts to believe him.
01:22:34 <musasabi> xkb_: yes
01:22:48 <shapr> less than sensible
01:23:01 * musasabi would like to avoid the whole unicode issue and support first efficient binary bit/byte based io.
01:23:16 <shapr> that sounds sensible, suggest it!
01:23:32 <shapr> I totally agree with you, I'd like to separate the issues as well.
01:23:37 <musasabi> then add a layer of iconv :: Encoding -> ByteString -> String
01:23:40 <shapr> yup
01:23:47 <earthy> um, that has already been suggested
01:23:52 <musasabi> earthy: yes.
01:24:01 <earthy> (deleted the mail just now ;))
01:24:12 <musasabi> earthy: but that is not yet the accepted solution.
01:24:23 <earthy> otoh, all that layering really needs to be compiled out for efficiency
01:24:32 <earthy> and I *still* want mmap :)
01:24:53 <musasabi> earthy: well if we have a ByteString it can use mmap.
01:24:57 <xkb_> mmap would be good 
01:25:10 <earthy> note: there is inherent danger in designing I/O systems... it's one of the main reasons for the downfall of say Algol 68
01:25:10 <musasabi> earthy: currently I am using FastPackedString which uses mmap ;)
01:25:19 * earthy nods ;)
01:26:31 <musasabi> well it should be a library in any case ;)
01:26:45 <earthy> which makes it harder to optimise well...
01:27:06 * earthy plays devil's advocate for a bit here
01:27:07 <musasabi> true.
01:27:29 <earthy> and I don't really see the need for the bitstream layer
01:27:36 * musasabi goes to lunch for a little bit
01:27:40 <earthy> enjoy
01:27:42 <musasabi> bytes would be fine for me.
01:27:45 <musasabi> =>
01:27:51 <earthy> (lunch? already? where the bleep art thou?)
01:28:27 * earthy didn't know there was a 2 hour timediff between there and here.
01:28:57 <earthy> but yeah, give me the raw OS I/O and a conversion to something I know I can handle
01:29:01 <earthy> that'd be just peachy
01:29:12 <shapr> maybe he got up at 5am?
01:29:14 <earthy> possibly multiple conversions
01:29:20 <earthy> shapr: maybe he did ;)
01:29:54 * shapr bounces around randomly
01:46:36 <shapr> so, what's up guys? any nifty code today?
01:50:49 <musasabi> earthy: Finland (11:49 here)
01:51:41 <shapr> I wish GHC were easier to bootstrap... what that trick to dump a GHC version as mostly pure C?
01:51:51 <musasabi> and I did got up at 6:30 to get in time to the math lecture 
01:52:03 <shapr> what math class?
01:52:05 <musasabi> bicycling 10km each morning to the uni
01:52:38 <shapr> cool :-)
01:52:39 <musasabi> shapr: just some diff equations (have to tutor my gf on those)
01:53:03 <shapr> I unicycle about 1km to school.
01:54:39 <musasabi> having school that close would be nice.
01:55:21 <shapr> classes at luth.se would require a 45 minute bus ride for me. I wonder if I could unicycle that in the mornings.
01:55:35 <musasabi> we live @ hut.fi and I study @ helsinki.fi. (hut.fi has CS but the courses are not as interesting - not that helsinki.fi has all the courses Iam interested in)
02:00:06 <shapr> how do I generate .hc files from an existing GHC?
02:01:01 <musasabi> well there should be scripts to do it (as it is done for releases)
02:01:35 <dons> shapr: -keep-tmp-files
02:01:55 <dons> if you need to get .hc for the whole thing, look at the nightly build scripts
02:01:55 <shapr> dons: during a GHC build?
02:02:32 <shapr> I want a darcs archive where archive + gcc = darcs
02:04:17 <dons> you want a .hc bundle for all of ghc?
02:04:35 <shapr> I guess so
02:04:35 <earthy> ugh, no
02:04:36 <earthy> ;)
02:05:07 <dons> you want .hc version of darcs
02:05:07 <shapr> I've heard some horror stories from people trying to get GHC and then darcs working on their box
02:05:32 <earthy> well, getting ghc to work from a c compiler is tricky
02:05:44 <dons> sure is.
02:06:05 <dons> even if you had darcs in .hc form, you still need a ghc libraries and rts to install
02:06:39 <earthy> even if you have ghc in .hc form it is tricky
02:06:48 <earthy> (and I've been trying)
02:06:57 <earthy> (solaris is not quite the easiest platform ;))
02:07:15 <dons> certainly! hours of pain 
02:07:21 <earthy> days. :)
02:07:56 <shapr> it looks to me like darcs is the first real killer app for Haskell, so I'm trying to make it easier to just grab and install
02:08:19 <dons> yep. this has come up on the darcs list a few times
02:08:36 <dons> I think the way would be to distribute a .hc bundle of darcs, + precompiled Haskell libs (and rts)
02:08:39 <shapr> hej DenizzzZ
02:08:46 <dons> otherwise you need to do a .hc boot
02:08:57 <shapr> that bundle sounds good
02:09:08 <dons> but if you have precompiled libs that work, you may as well install a ghc binary bundle as well
02:09:16 <earthy> why not distribute binaries?
02:09:24 <earthy> complete installers...
02:10:14 <Si\> who can beg/bribe to make Network.URI.URI in the GHC CVS derive Typeable+Data?
02:10:22 <shapr> the disadvantage of installers is how distro specific they are.
02:10:25 <earthy> simon m
02:10:39 <earthy> shapr: true
02:10:43 <earthy> point
02:11:43 <shapr> the bundle dons talked about would work on the various weird Linux installations I deal with, an ancient SuSE, a majorly hacked RedHat, and other weirdness.
02:15:33 <dons> maybe. it would be very useful to construct a script for generating a gcc-buildable bundle for an arbitrary haskell app
02:15:42 <shapr> yah, I'd love that.
02:15:59 <shapr> the *only* disadvantage of darcs is that it requires GHC.
02:16:28 <shapr> and that's only because it's such a pain to get GHC installed and working correctly for the average non-Haskell user.
02:16:50 <dons> or ... you could use hsInC ;)
02:16:54 <shapr> ?
02:16:56 <dons> http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
02:17:16 <shapr> oho
02:17:44 <dons> you can do a lot with a unsigned long code[]
02:20:02 * dons thinks should have submitted something out of that to iohcc
02:21:11 <musasabi> when will the iohcc results come out?
02:22:42 <earthy> at icfp, no?
02:25:19 <shapr> er, today I hope.
02:25:58 <musasabi> ^_^
02:26:07 <shapr> I still need to hear from one of the jurors.
02:30:35 <shapr> hoi arjanb
02:32:39 <shapr> greetings gintas 
02:32:56 <gintas> hey shapr
02:33:01 <shapr> how's code?
02:33:16 <gintas> as usual ;)
02:33:28 <shapr> have you gotten any taller? ;-)
02:33:49 <gintas> I hope not
02:33:57 * shapr grins
02:35:00 <gintas> it kind of sucks that I can't find time for Haskell...
02:35:36 <gintas> but I've been looking into Scheme lately
02:36:03 <shapr> scheme is nice
02:47:53 <gintas> scheme has very good educational material, which haskell lacks I think
02:47:59 <musasabi> hmm it appears all the needed serailization code already exists
02:59:20 <musasabi> damn nfs server dying on me.
02:59:42 <musasabi> shapr: have you looked into using the parallel haskell code for serialization?
03:05:13 <shapr> no, not yet
03:06:25 <shapr> gintas: there's nothing as generally respected as SICP in the Haskell world, that's true. This might be comparable: http://homepages.cwi.nl/~jve/HR/ But I haven't tried it yet, so I don't know.
03:07:02 <shapr> musasabi: along that route, I've only read a bit about Goffin, where Manuel Chakravarty did mobile bytecode for a version of Haskell.
03:07:39 <gintas> shapr: actually I have ordered this book
03:07:46 <gintas> it should arrive in a couple days
03:07:57 <gintas> I thought it should be worth it
03:08:01 <shapr> I agree.
03:08:38 <gintas> it's reassuring to know that you think it is good
03:08:51 <musasabi> shapr: looking at the code it does a lot of the things I would want to do...
03:09:01 <musasabi> shapr: only it is too trusting..
03:09:10 <shapr> how hard to port to ghc6?
03:09:11 * gintas slaps himself for usage of 'it'
03:10:09 <shapr> musasabi: where'd you get the code?
03:10:19 <shapr> did you email phil?
03:10:58 <musasabi> shapr: I mean the code in the ghc tree.
03:11:08 <musasabi> shapr: PVM.
03:11:46 <shapr> ah
05:13:52 <shapr> jiihaa
05:13:58 * shapr bounds around cheerfully
05:25:27 * PeterE enjoys shapr's bouncing.
05:26:01 * shapr bounces up and down on top of PeterE 
05:26:20 <shapr> lucky for you I weight almost zero on the internet!
05:35:27 * PeterE sneaks away under the door, because he is flat as a pancake.
06:01:00 <shapr> so, what's going on?
06:01:56 * Igloo is fscking
06:02:12 <Igloo> Theuniverse has evidently decided it's about time it reminds me that it hates me
06:11:55 <earthy> that bad huh?
06:17:48 <shapr> hi ta
06:18:06 * shapr boings
06:20:37 * PeterE is getting even flatter.
06:21:13 * shapr stops jumping on PeterE 
06:21:22 <shapr> PeterE: hey, written any Haskell code lately?
06:22:44 <PeterE> Nope, but I have two courses using SML, which is better than using, say Java, won't you say?
06:23:00 <shapr> most definitely.
06:23:24 <shapr> Java does pay well, but I don't enjoy it as much as Haskell.
06:23:40 <shapr> I do enjoy Python, though also not as much as Haskell.
06:26:20 <PeterE> It would be nice to have a module system like in SML, though only better.
06:26:50 <shapr> Oleg wrote a paper about that recently, I think.
06:27:01 <shapr> as in, How to get SML's module system in Haskell.
06:27:07 <shapr> hej ski
06:27:12 <ski> hej shapr
06:27:19 <shapr> Oleg is a scary person.
06:27:25 <shapr> I sure would love to hang out with him and talk FP.
06:27:33 <ski> which oleg ?
06:27:41 <shapr> kiselyov or something
06:27:45 <ski> ak, ok
06:28:24 <shapr> He sent me an email asking if I would add him to the haskell-libs project as a developer, the funny thing is that he included a bunch of references to things he'd written to show that he actually had a clue.
06:28:37 <ski> heh
06:28:40 <shapr> I totally thrilled he wanted to join, and I've known who he is for years :-)
06:28:53 * ski grins
06:29:27 <Igloo> Hmm, looks like 6.2.2 candidate releases will be out well before sarge
06:29:30 <shapr> yay
06:30:35 <musasabi> so what is new in 6.2.2 in addition to the boilerplate code ?
06:32:31 <Igloo> Not sure OTTOMH. 6.4 is due soon, and that's where you should be looking for exciting new stuff
06:36:39 <shapr> bye ta
06:40:03 <ski> bye shapr
06:40:13 <shapr> bye ski
06:40:15 <ski> hmm
06:40:21 <ski> heh
06:40:23 <shapr> are you leaving?
06:40:25 <shapr> or am I?
06:40:28 <Igloo> lol
06:40:29 * shapr looks behind him
06:40:29 <ski> seems we both misunderstood
06:40:36 * shapr gets worried
06:40:44 <ski> hahaha
06:40:55 * Igloo closes his eyes and pretends everyone else has left
06:40:56 <shapr> what's that hiding in that dark corner?!?! AIEE!!
06:41:07 <shapr> oh, that's just a unicycle. never mind.
06:43:35 <earthy> bounc
06:43:36 <earthy> +e
06:45:03 <shapr> speaking of which, it's nearly time to unicycle again.
06:50:08 * Igloo gets to the ghc lists and finds the RC is already out. Bah
06:52:05 <shapr> um, is UK in EET or EST?
06:52:10 <shapr> +1 or +2 ?
06:52:24 <shapr> assuming Sweden is in the same time zone.
06:52:30 <Igloo> BST +1
06:52:38 <shapr> ok, thanks
06:53:08 <Igloo> (Given Greenwich is in the UK we must be +0 when not on DST)
06:53:47 * Igloo discovers BST is also -3 and -11 according to VERA
07:25:04 * shapr gives in to the unicycle urge
07:32:59 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs ","http://www.haskell.org/cabal/","#haskell is now officially 1337","Haskell - too cute for its own good"]' by shapr
07:43:36 <xkb_> bleh
07:43:39 <xkb_> citeseer donw
07:43:41 <xkb_> down
07:43:45 <xkb_> any alternatives?
07:46:34 <monochrom> google :)
07:46:55 <xkb_> yeah.. that gives me links to citeseer
07:47:18 <monochrom> -_-;
07:47:18 <xkb_> bleh.. another one of those non-free papers
07:47:22 <xkb_> yuck
07:47:26 <xkb_> "Dynamic types and type dependent functions"
07:47:31 <xkb_> for those interested
07:48:26 <Smerdyakov> Check the authors' web sites before declaring that it's not freely available. :)
07:49:02 <xkb_> ill walk to there desk, next monday :D
07:49:25 <xkb_> it willa appear in LCNS
07:49:30 <xkb_> eh
07:49:32 <xkb_> LNCS
07:49:36 <xkb_> -a
07:49:38 <xkb_> pfft
07:51:10 <xkb_> I think I need a new typing and spelling course
07:52:29 <monochrom> I can smuggle the paper out.
07:53:48 <xkb_> cool
07:54:13 <monochrom> Do you accept dcc?
07:54:28 <xkb_> I think so.. Never really tried it b4 on this machine
07:54:38 <monochrom> I'll try.
07:54:39 <xkb_> the client does iac
07:55:31 <monochrom> I've started.
07:55:46 <xkb_> ok.. hmm now I need to accept
07:56:33 <xkb_> this should work
07:56:43 <monochrom> Yes, the computer thinks it works.
07:57:23 <xkb_> hmm lets see if I can find it now
07:57:48 <xkb_> ah
07:57:51 <xkb_> thanks!
07:57:56 <monochrom> you're welcome
07:58:35 <xkb_> monochrom, are you in Nijmegen?
07:58:47 <xkb_> or did you just happen to have the paper?
07:59:18 <monochrom> My university (Toronto) has bought electronic access to Springer among other publishers.
07:59:37 <xkb_> ahh..neat!
09:28:00 <shapr> hej oddeh 
09:28:04 <oddeh> tjoo
09:28:05 <oddeh> :)
09:28:20 <shapr> are you another chalmerite?
09:28:29 <oddeh> yes :)
09:28:32 <shapr> ah, excellent
09:28:37 <oddeh> hehe
09:28:49 <shapr> other places of note may be #chalmers and #haskell.se
09:28:58 <oddeh> oh thanks :)
09:29:10 <shapr> are you new to Haskell?
09:29:17 <shapr> looking for learning info?
09:29:24 <shapr> or maybe you're a long time user looking for a community?
09:29:52 <oddeh> >:D
09:30:58 <shapr> If you want to learn Haskell, I can give you some tips.
09:31:29 <oddeh> shoot
09:31:52 <oddeh> :)
09:31:53 <shapr> this is a good place to start: http://www.haskell.org/learning.html 
09:32:10 <shapr> Hal Daume's 'Yet Another Haskell Tutorial' is freely downloadable if you don't have a book.
09:32:26 <shapr> I'd recommend using GHC unles you are low on hardware, in which case Hugs is resource-light.
09:32:43 <shapr> lambdabot has some handy tools for Haskell
09:32:46 <shapr> @index scanr
09:32:47 <lambdabot> Data.List,GHC.List,Prelude,List
09:32:51 <shapr> @type Data.List.scanr
09:32:53 <lambdabot> Data.List.scanr :: forall b a. (a -> b -> b) -> b -> [a] -> [b]
09:32:56 <oddeh> nice :D
09:33:06 <shapr> The Haskell Wiki has lots of useful info
09:33:10 <shapr> @wiki RecentChanges
09:33:10 <lambdabot> http://www.haskell.org/hawiki/RecentChanges
09:33:39 <oddeh> hey thanks =)
09:33:50 <andersca> @arr
09:33:50 <lambdabot> This is the END for you, you gutter-crawling cur!
09:34:02 <shapr> If you have specific questions, I'll try to help with those also.
09:34:32 <oddeh> :)
09:35:12 <shapr> @yow
09:35:13 <lambdabot> ..  Do you like ``TENDER VITTLES?''?
09:35:32 <shapr> andersca: oh, it's almost Talk Like A Pirate Day!
09:46:21 <stepcut> shapr: when is Talk Like A Pirate Day anyway ?
09:47:18 <andersca> 19 sep
09:48:27 <shapr> day after my birthday.
09:48:42 <andersca> shapr: wow
09:48:58 <andersca> shapr: mine is the day after yours
09:48:59 <shapr> I won't be 100000 anymore :-(
09:49:02 <shapr> oh neat
09:49:16 <shapr> we're having a birthday and apartment moving fest on the 18th
09:49:27 <Igloo> But your age will be symmetric on a machine with 6-bit words
09:49:41 <shapr> I've invited the #haskell people, but I suspect psi is only one who might actually show up.
09:49:47 <shapr> (since he's relatively nearby)
09:50:03 * shapr looks at psi 
09:50:18 * Igloo doesn't remember being invited...*sniff*
09:50:27 <shapr> psi: hey, you think you'll show up? We'll have at least four nationalities in the same room.
09:50:32 <shapr> Igloo: please come to my birthday party!
09:50:43 <shapr> We're lifting heavy furniture and boxes for my birthday.
09:51:01 <shapr> oh, and I'm going to show off my unicycle trick. ( I only have one :-/ )
09:52:00 <ski> must go
09:52:01 <ski> bye
09:52:04 <shapr> bye!
09:52:57 <shapr> oddeh: do you like functional programming?
09:54:59 <Igloo> Right, about 1000miles, I think, so if I ran at 5 miles an hour...no, can't do it in 4 days, sorry
09:55:59 * shapr grins
09:56:43 <oddeh> Ye I like it =] You usually end up with much more beautiful code than in imperative programming
09:57:41 <shapr> yah, I think so too.
09:57:45 <oddeh> :)
09:58:54 <oddeh> Have you been programming Haskell for a long time shapr ?
09:59:29 * stepcut wonders if anything will come of the i18n wars on haskell cafe
10:05:31 <shapr> I've been using Haskell for about three years.
10:05:43 <oddeh> Ooh, nice
10:06:13 <shapr> Python used to be my favorite language, but I realized I wanted functional programming before I even knew what it was.
10:06:59 <oddeh> Hahahaha 
10:07:29 <tic> the good thing with haskell is that you can actually prove your programs work
10:07:40 <oddeh> =)
10:08:13 <shapr> I like type inferencing, all the benefits of static programming with the irritation of manifest typing.
10:08:27 <shapr> Of course, higher order functions in Haskell go much further than they ever did in Python.
10:08:41 <shapr> monads are surprisingly elegant too
10:09:08 <oddeh> Ye I read some about monads, we haven't covered them in the course yet though
10:09:28 <tic> shapr, higher-order functions are pretty easy to add using a currying decorator.
10:09:40 <shapr> a monad is a type that's not completely filled-in and two functions, one for making a boring datatype filled into that type, and another for sticking together two values of that filled-in type.
10:10:09 <oddeh> Ahh
10:10:51 <shapr> that doesn't sound very impressive, but it works really well
10:11:11 <xkb__> I actually think thats a very well put description
10:11:29 <Smerdyakov> I think that leaves out the critical idea of sequenced computation.
10:11:53 <shapr> xkb__: yah, but it doesn't have the mystery of the word 'monad' and it doesn't show their elegance.
10:12:25 <xkb__> not the elegance in code, it however does show the elegance of the idea
10:12:25 <oddeh> Always takes solving a problem with a method to really appreciate it
10:12:31 <shapr> yah, I agree.
10:13:13 <shapr> The two most elegant monadic solutions I've seen are modular interpreters and parsers. 
10:13:46 <xkb__> parsers.. 
10:14:04 <xkb__> The first time I read about a monadic parser I did not understand one bit of it
10:14:15 <oddeh^food> Dinner time =) See you later
10:14:17 <xkb__> though strangely you can read the code without knowing it
10:14:27 <stepcut> I have been writing a bunch of KDE/C++ code recently, and I keep wanting to curry functions
10:14:49 <shapr> I keep trying to curry python functions too.
10:15:23 <musasabi> evening
10:15:35 <shapr> There is a python framework to do that, but I suspect very few Python programmers will understand curried functions in the future.
10:16:59 <stepcut> I have this problem, where samba wants me to give it a authentication call back function, but I need it to call methods in my class instance (or whatever they call that in C++). I think I am going to have to use some sort of global variable or something :-/
10:18:23 <stepcut> I wonder if I should try to weasel my way into ICFP...
10:18:46 <xkb__> stepcut, cary me in yr suitcase :D
10:18:50 <xkb__> +r
10:21:25 <stepcut> I hear they have good rootbeer in utah...
10:46:14 <oddeh^food> rootbeer....
10:46:56 * bringert looked up Utah alcohol legislation
10:47:16 <bringert> http://www.utahrights.com/alcohol.htm
10:48:24 * bringert is coding Java right now, but keeps using ++ for string concatenation
10:48:47 <bringert> no wonder I am thinking about beer instead
10:49:52 <andersca> mm, beer
11:16:45 <psi> shapr: i'm not sure yet. mabe :)
11:17:22 <psi> i *would* like to try that unicycle of yours :)
11:18:41 <esap> Is there a way to express the concept of injectivity in Haskell? [I already did epimorphism, but I guess I want to dualize that :-) ]
11:20:56 * Marvin-- dualizes esap for bringing up such a perverse subject
11:21:41 <esap> Here's epimorphism: data Epimorphic a b = Epimorphic { epi_arr :: a -> b, epimorphism :: forall t. (t -> b) -> t -> a }
11:39:30 <stepcut> is there same command I can run like, 'fakeinstall make install', that will try make install into thinking its working, but not actually modify any of the real system files? I just want to know what its going to try to do, before I actually do it
11:40:49 <Lemmih> make -n install?
11:43:19 <stepcut> hrm, I will try that
11:44:12 <stepcut> hrm, somewhat helpful, but really I want a before and after diff file
11:45:09 <Lemmih> On the whole filesystem?
11:45:13 <stepcut> yes
11:45:33 <shapr> stepcut: you could fake it out with lndir
11:46:43 <stepcut> shapr: would that work for files that just get modified ?
11:47:15 <shapr> I think so.
11:47:26 <shapr> wouldn't a modified real file be in the place of the original?
11:47:51 <shapr> er, in place of the symlink?
11:48:05 <shapr> that's what happens with fptools cvs tree at least.
11:48:19 <shapr> oh hey, isn't there a program that already does this?
11:48:24 <shapr> sweep or cleansweep or something
11:48:35 <shapr> it lets you uninstall stuff by wrapping the install process
11:48:37 <stepcut> shapr, if a newer version was copied over the symlink, then yes, but what if it edits the existing file ?
11:48:47 <shapr> stepcut: I don't know
11:49:04 <stepcut> shapr: freesweep - a text-based minesweeper??
11:49:04 <stepcut> :p
11:50:32 * ibid brought that to debian, iirc :)
11:52:19 <shapr> stepcut: http://freshmeat.net/projects/uninst/
11:54:41 <shapr> stepcut: first thing I found that looks like the right thing.
11:57:31 <stepcut> shapr: : thanks
12:09:07 * esap found a way to make things mono:  data Monomorphic a b = Monomorphic (a -> b) ((a -> Bool) -> b -> Bool)
12:17:50 <shapr> hej psi 
12:18:02 <psi> tjena
13:55:53 <shapr> d00d
13:56:19 <monochrom> deadbeef
13:56:52 <shapr> 0x
14:06:09 <Cale> where did the "too cute for its own good" quote come from?
14:06:25 <shapr> um
14:06:31 <shapr> Graham Klyne's latest email
14:06:50 <shapr> had an url to the Ada/C++/Haskell/awk/etc comparison paper
14:07:09 <shapr> the one where the Navy got a bunch of different language experts to whip up prototypes of the AEGIS Weapon System
14:07:23 <Cale> yeah
14:08:02 <Cale> did that paper say that?
14:08:07 <shapr> in the conclusion of the paper, some of the other guys who got to look at the Haskell code said they thought it was actually pseudocode
14:08:13 <Cale> yeah
14:08:13 <shapr> and that it couldn't possibly be executable
14:08:14 <Cale> :)
14:08:31 <shapr> and one of them said "Haskell is too cute for its own good"
14:08:45 <shapr> because they didn't believe the whole higher-order function thing would really work in practice.
14:09:01 <Cale> heh
14:12:42 <shapr> "If functional languages are to become more widely used, various sociological and psychological barriers must be overcome."
14:13:33 <shapr> page 15, http://www.haskell.org/papers/NSWC/jfp.ps
14:16:27 <monochrom> Yes some social-psycho barrier. That's normal.
14:17:16 <monochrom> But "too cute for its own good"?  Some supposedly a group of carefully selected intelligent people?  That's hogwash.
14:17:38 <monochrom> s/Some/From/
14:18:02 <shapr> read the paper, tell me what you think.
14:18:24 <monochrom> It is sad how people resist improvements whenever the improvements threaten their purpose of existence.
14:18:43 <shapr> yup
14:19:29 <monochrom> I can almost hear assembly coders in the 60s say "fortran is too cute for its own good", "this can't be executable!", "pseudocode?"
14:19:58 <shrimpx> a guy gave me an anti-fp the other day, something along the lines of the human mind being intrinsically action-oriented
14:20:05 <shrimpx> anti-fp argument, that is
14:20:13 <shapr> shrimpx: like math for example?
14:20:17 <ibid> i've always found recursion easier to get right than iteration
14:20:24 <shapr> me too
14:20:25 <shrimpx> heh
14:20:27 <shrimpx> same here
14:21:05 <ibid> in fact, i managed to learn to get iteration right after i started to mentally think of it as syntactic sugar for recursion :)
14:22:47 <monochrom> I think all those "human minds naturally think like so-and-so" arguments are all very well.  Most professions - medicine, accounting, law, engineering - require the professionals to work and think *against* their human nature.  I never hear engineers say "human minds are naturally sloppy so let's do things sloppily."
14:23:12 <ibid> except perhaps software engineers :)
14:23:46 <Cale> monochrom: they wouldn't say that out loud, but have you seen their math classes? :)
14:24:40 <monochrom> I know. I think engineers are very careful when it comes to critical things.
14:25:07 <ibid> engineers are not that careful, they just put enough safety margin :)
14:25:44 <ibid> of course, you know what's the difference between an engineer and a scientist :)
14:25:48 <monochrom> As for not proving C^oo-ness of a function f before using f_xy = f_yx, well, their f's always come from the nature and they are pretty much C^oo.
14:26:39 <ibid> scientists love failure; engineers love it too, but they don't want to be there when it happens
14:27:19 <monochrom> If you don't buy that engineers are not sloppy, I can cite other characteristics.  Being analytic, for example.  The point still stands.
14:29:05 <monochrom> Whenever you see an engineer being sloppy, it is always forgivable.  This is because they put their artifacts under strict tests afterwards.  If the sloppiness hurts, it will show; if not, that's good.
14:30:34 <ibid> you can't test a building
14:31:00 <Riastradh> Sure you can.  Fly a plane into it: if it stays standing, it's a pretty well-built building; otherwise, it wasn't good enough, and you need to rebuild it anyway!
14:31:04 * Cale imagines a building with a large harness attached to it.
14:31:04 <monochrom> Another example: surgery.  Did you ever hear doctors say "it is human nature to fear blood and gore, let's never cut bodies open"?  Of course not.  Doctors spend years to overcome their human nature.
14:32:44 <ibid> Riastradh: point :)
14:33:06 <Riastradh> Just like how they test the weight limits on bridges.
14:33:35 <Marvin--> heh, I love the explanation of that in Calvin&Hobbes
14:33:41 <shapr> ?
14:33:50 <Riastradh> Keep driving bigger & bigger trucks over the bridge.
14:33:57 <Marvin--> yep
14:34:08 <Riastradh> When the final big truck collapses it, measure how much that truck weighed & rebuild the bridge.
14:34:16 <shapr> heh
14:34:17 <Marvin--> that's the one :)
14:35:00 <Cale> I think it would be better to measure how much the second last truck weighed :)
14:35:51 <Marvin--> well, yeah
14:36:55 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-28)!
14:37:01 <shapr> man, stepcut needs to upgrade.
14:38:17 <shapr> hiya jesse98 
14:38:22 <jesse98> hi shapr
15:10:23 <shapr> hoi Boegel 
15:23:00 <Boegel> hello shapr
15:23:09 <Boegel> 'bit late reaction there :p
15:23:18 <Boegel> but I'm looking for stuff on ray tracing
15:23:42 <Boegel> I've coded the basic algorithm (ray casting) in Java, but something's not quite right...
15:23:49 <Boegel> it behaves strange
15:23:58 <Boegel> so I'm looking for more information :)
15:40:25 <Boegel> and nowI'm going to sleep
15:40:27 <Boegel> bye
16:02:33 <monochrom> http://slashdot.org/~Albert%20Y.C.%20Lai/journal/83868
18:30:31 <dan2> does any body have a decent example of haskell getopt
18:43:04 <dan2> Cale: ping
18:43:09 <Cale> dan2: yeah?
18:43:23 <dan2> Cale: ever used getopt in haskell?
18:43:59 <dan2> I can't figure out how to use this
18:44:04 <dan2> here is a function I wrote
18:44:05 <dan2> tempOpts :: [String] -> IO ([Flag], [String])
18:44:05 <dan2> tempOpts argv = 
18:44:05 <dan2>   case (getOpt Permute options argv) of
18:44:05 <dan2>     (o,n,[]  ) -> return (o,n)
18:44:05 <dan2>     (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
18:44:06 <dan2>   where header = "Usage: tempconv {-F|-C} temp"
18:45:22 <dan2> Cale: now what do I pass to it, and what do I get back
18:46:06 <Cale> I've only ever used getArgs
18:46:15 <Cale> but I suppose I could try to figure it out
18:47:42 * dan2 can't see why nobody has a logical example of usage
18:48:16 <dan2> Cale: in C, getopt was a switch case
19:07:23 <dan2> Cale: ok, so I think i have something now
19:07:37 <dan2> Cale: next question is how to work with these flags
19:15:00 <dan2> Cale: how do you use case of blah in a do {}
19:25:06 <dan2> anybody around?
19:29:02 <Smerdyakov> dan2, it's an expression like any other, so you use it the same way you would use 2 or "hi".
19:30:35 <dan2> Smerdyakov: hmm, doesn't seem to work that way
19:30:52 <Smerdyakov> dan2, how not?
19:31:30 <dan2> main = do {
19:31:30 <dan2>        argv <- getArgs;
19:31:30 <dan2>        let (opts,args) = tempOpts argv;
19:31:30 <dan2>        case (opts, args) of
19:31:30 <dan2>                 (Help,_)
19:31:33 <dan2>                          bye (usageInfo header options);
19:31:35 <dan2>                 (Fahr,_)
19:31:39 <dan2>                          bye (f2c (read _));
19:31:41 <dan2>                 (Cent,_)
19:31:43 <dan2>                          bye (c2f (read _));
19:31:47 <dan2>        }
19:31:54 <dan2> compiler is always complaining
19:32:49 <seafood> The syntax of case doesn't look right.
19:33:07 <dan2> seafood: hmm what did I do wrong
19:33:26 <seafood> There should be an arrow (->) after each pattern.
19:33:36 <dan2> ahh ok
19:33:36 <seafood> e.g. (Cent,-) -> 
19:33:49 <seafood> Why do you want to use curly braces and semicolons?
19:34:18 <seafood> Are you a C programmer by any chance?
19:34:47 <seafood> (Not that that's a bad thing.)
19:34:59 <dan2> seafood: yes C programmer
19:35:22 <dan2> seafood: compiler keeps complaining about indentation
19:35:53 <seafood> Fair enough. Get it working first and then maybe you can think about removing the brackets and semicolons.
19:36:01 <dan2> seafood: anyhow, it seems to work now kinda...
19:36:12 <dan2> seafood: this getopt stuff is a pita 
19:36:27 <seafood> pita?
19:36:31 <dan2> pain in the ass
19:36:39 <dan2> main = do
19:36:39 <dan2>        argv <- getArgs;
19:36:39 <dan2>        let (opts,args) = tempOpts argv;
19:36:39 <dan2>        case (opts, args) of
19:36:39 <dan2>         (Help,_) -> bye (usageInfo header options)
19:36:41 <dan2>         (Fahr,_) -> bye (f2c (read _))
19:36:42 <dan2>         (Cent,_) -> bye (c2f (read _))
19:36:59 <dan2> seafood: compiler doesn't like the usage of _ in Fahr and Cent
19:37:35 <seafood> Yeah, it does take some getting used to.
19:37:46 <dan2> seafood: hmm, maybe read args?
19:38:27 <seafood> dan2: precisely, you can't have _ on the right hand side of the arrow.
19:38:46 <seafood> _ is a pattern that means "match against anything and throw away the result"
19:38:57 <seafood> But it's not something you can pass to a function.
19:39:36 <dan2> seafood: I see :)
19:41:25 <dan2> is anybody going to care if I paste this file into the channel?
19:42:01 <dan2> here it goes
19:42:05 <seafood> Just paste the relevant parts.
19:42:09 <dan2> import System
19:42:09 <dan2> import System.Console.GetOpt
19:42:09 <dan2> data Flag = Help | Fahr String | Cent String deriving Show
19:42:09 <dan2> options :: [OptDescr Flag]
19:42:09 <dan2> options = [ Option ['h']     ["help"] (NoArg Help)       "show this help"
19:42:10 <dan2>           , Option ['F']     ["fahrenheit"] (OptArg Fahr "Temp") "find celsius temperature given fahrenheit"
19:42:13 <dan2>           , Option ['C']     ["celsius"] (OptArg Cent "Temp") "find fahrenheit temperature given celsius"
19:42:14 <dan2>           ]
19:42:18 <dan2> header = "Usage: tempconv {-F|-C} temp"
19:42:20 <dan2> tempOpts :: [String] -> IO ([Flag], [String])
19:42:22 <dan2> tempOpts argv  =
19:42:24 <dan2>   case (getOpt Permute options argv) of
19:42:26 <dan2>     (o,n,[]  ) -> return (o,n)
19:42:28 <dan2>     (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
19:42:34 <dan2> bye :: String -> IO a
19:42:40 <dan2> bye s = putStr s >> exitWith ExitSuccess
19:42:42 <dan2> c2f :: (Fractional a) => a -> a
19:42:44 <dan2> c2f temp = ((temp - 32)*(5.0/9.0))
19:42:48 <dan2> f2c :: (Fractional a) => a -> a
19:42:50 <dan2> f2c temp = ((9.0/5.0)*temp) + 32
19:42:52 <dan2> main :: IO ()
19:42:54 <dan2> main = do
19:42:56 <dan2>        argv <- getArgs;
19:42:58 <dan2>        let (opts,args) = tempOpts argv;
19:43:05 <dan2>        case (opts, args) of
19:43:06 <dan2>         (Help,_) -> bye (usageInfo header options)
19:43:08 <dan2>         (Fahr,_) -> bye (f2c (read args))
19:43:10 <dan2>         (Cent,_) -> bye (c2f (read args))
19:44:22 <dan2> tempconv.hs:8:52:
19:44:22 <dan2>     Couldn't match `String' against `Maybe String'
19:44:22 <dan2>       Expected type: Maybe String -> Flag
19:44:22 <dan2>       Inferred type: String -> Flag
19:44:22 <dan2>     In the first argument of `OptArg', namely `Fahr'
19:44:23 <dan2>     In the third argument of `Option', namely `(OptArg Fahr "Temp")'
19:44:25 <dan2> tempconv.hs:33:25:
19:44:27 <dan2>     Couldn't match `(t, t1)' against `IO ([Flag], [String])'
19:44:29 <dan2>       Expected type: (t, t1)
19:44:35 <dan2>       Inferred type: IO ([Flag], [String])
19:44:43 <dan2>     In the application `tempOpts argv'
19:44:45 <dan2>     In a pattern binding: (opts, args) = tempOpts argv
19:44:48 <Smerdyakov> OMG. It's a flood fest/
19:44:48 <dan2> tempconv.hs:36:9:
19:44:50 <dan2>     Constructor `Fahr' should have 1 argument, but has been given 0
19:44:52 <dan2>     When checking the pattern: Fahr
19:44:54 <dan2>     When checking the pattern: (Fahr, _)
19:44:56 <dan2>     In a case alternative: (Fahr, _) -> bye (f2c (read args))
19:45:58 <seafood> dan2: You need to pay attention to types.
19:46:24 <dan2> seafood: hmm
19:46:38 <seafood> dan2: I gotta go so someone else should be able to help. 
19:49:46 <seafood> dan2: But, before I go I'll let you know that OptArg needs to take a function of Maybe String -> a.
19:51:02 <seafood> dan2: Shouldn't you be using ReqArg instead of OptArg anyway?
19:51:24 <seafood> dan2: ReqArg means that the option (e.g. F) requires an argument. OptArg means it is optional.
19:51:59 <seafood> Just change it to ReqArg. Taht should fix some of the errors.
20:51:01 <Michael`> hey all :)
20:52:17 <Michael`> how do you replace text in haskell
20:52:38 <Michael`> ie replace(string1,string2,s,Q)
20:52:39 <Michael`> to get
20:53:01 <Michael`> Qtring1,Qtring2
20:53:10 <Michael`> anyone following my thought pattern?
20:53:42 <monochrom> No.
20:54:04 <monochrom> Why is it not: replace(string1,s,Q) to get Qtring1?
20:54:11 <Michael`> yeah i meant that
20:54:36 <Michael`> realised that after i typed it, i think the meaning is still clear enough, since you worked it out
20:54:46 <monochrom> Yes. I'll look.
20:54:52 <Michael`> thanks
20:56:23 <monochrom> There is no library function for this.  But I can write one.
20:56:51 <monochrom> map (\c -> if c != 's' then c else 'Q') "string1"
20:57:27 <monochrom> If you want a general function called replace:
20:57:35 <Michael`> ok - what about replacing a string
20:57:42 <Michael`> since that will work only for a character
20:57:56 <monochrom> replace string1 s q = map (\c -> if c != s then c else q) string1
20:58:07 <Michael`> ok :)
20:58:13 <Michael`> ill give that a shot :)
21:25:46 <Michael`> anyone in here able to help with haskell?
21:26:54 <Riastradh> Not unless you ask a question.  Meta-questions are unhelpable.
21:39:26 <Michael`> I need help writing a program that reads from a text file, and then replaces certain strings with the replacement string
21:44:13 <Michael`> :\
21:44:42 <Riastradh> A _specific_ question.
21:44:51 <Riastradh> (That wasn't a question in the first place, let alone a specific one.)
21:47:30 <Michael`> ok, what is the command to print from a text file?
21:48:07 <Riastradh> What do you mean by 'print from a text file?'
21:49:07 <Michael`> ok
21:49:16 <Michael`> say i have text.txt
21:49:34 <Michael`> How do i print the contents of that file, line by line, to the screen
21:49:43 <Michael`> im assuming through recursion
21:50:07 <Michael`> but i am unaware of the command to open a file for reading access, and then to get the information from each line
21:50:51 <Riastradh> See the IO module, at <http://www.haskell.org/onlinereport/io.html>.
21:51:35 <Riastradh> @info IO.hGetContents
21:51:37 <lambdabot> -- GHC.IO.hGetContents is a variable
21:51:37 <lambdabot> GHC.IO.hGetContents :: GHC.IOBase.Handle -> IO String
21:52:39 <Riastradh> Actually, readFile is even more direct.
21:52:41 <Riastradh> @info IO.readFIle
21:52:43 <Riastradh> @info IO.readFile
21:52:45 <lambdabot> -- readFile is a variable
21:52:45 <lambdabot> readFile :: FilePath -> IO String
21:53:39 <Riastradh> I presume that you already have some understanding of the IO monad before you asked this; is this presumption correct?
21:55:01 <Michael`> what is a monad?
21:55:07 <Riastradh> ...uh, OK.
21:55:37 <Riastradh> What material are you using to learn Haskell?
21:55:43 <Michael`> my lecture notes
21:57:27 <Riastradh> And you are expected to be able to write Haskell code to perform complete I/O transactions without understanding monads first?
21:57:59 <Michael`> it may seem that way, i still dont know what you mean by monads
21:59:00 <Smerdyakov> Why do you think you need to "print" things?
21:59:08 <Smerdyakov> Why can't you write a function that returns the data that you are interested in?
21:59:19 <Smerdyakov> When you evaluate a call to it, the repl will display the result in an appropriate format.
21:59:22 <Riastradh> I'm afraid this is not a very lively hour in the channel right now; I have to leave now.
22:01:01 <Cale> Michael`: perhaps I have an article which may clarify things
22:01:19 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
22:03:19 <Cale> Michael`: read that and see if it helps -- I wrote it, so let me know if you have trouble with ti
22:03:20 <Cale> it*
22:24:21 <Smerdyakov> Michael`, please explain why you think you need to do file I/O.
22:25:07 <Michael`> Smerdy: well to print the contents of the file to the users screen, but apply filtering rules which replace certain strings in the file, with the desired replacement strings
22:25:31 <Smerdyakov> Why do you think you need to "print anything to the user's screen"? I doubt you have been assigned to do this without being taught about monads.
22:25:59 <Michael`> ok, printing it to the screen, i believe is so the accessor can see the results of the computations
22:26:15 <Michael`> applying this sort of code to a real function, you wouldnt normally just print it to the screen
22:26:16 <Michael`> yeah?
22:26:33 <Smerdyakov> In the context of a Haskell class, you will probably never print anything, no.
22:27:13 <Smerdyakov> And you can be sure that you will not use any input or output if it has not been covered explicitly in class, assigned reading, or similar.
22:27:52 <Michael`> input and output has been taught in java, yes, but not explicitly for haskell
22:28:04 <Smerdyakov> OK, then you will not use them in Haskell.
22:28:21 <Michael`> im kinda stuck here man, is there not any way you could give me an example which might help me to grasp and understanding?
22:28:40 <Michael`> i feel like im going around in circles here because i am not able to word my questions up to your standards
22:28:47 <Smerdyakov> You don't understand "you will not use input or output"?
22:28:58 <Smerdyakov> I am sure the problem statement does not mention input or output.
22:29:03 <Michael`> when the question explicitly says print to screen
22:29:10 <Michael`> i am dead certain i have to use IO yes.
22:29:11 <Smerdyakov> Then you should complain to the teacher.
22:29:32 <Michael`> man, your not addressing my request for assistance
22:29:42 <Smerdyakov> If you have not been pointed to material that discusses IO explicitly, then your teacher is at fault.
22:29:48 <Michael`> im sure he is
22:29:54 <Michael`> but that doesnt help my current plight
22:30:00 <Michael`> im asking if you can assist me
22:30:06 <Michael`> how else do you want me to word this?
22:30:26 <Smerdyakov> No. IO is generally the hardest thing for Haskell students to learn. I could not do it justice through a quick conversation here.
22:30:34 <Smerdyakov> It's a _major_ semantic issue that you need to wrap your head around.
22:30:39 <Smerdyakov> It's not an afterthought.
22:30:52 <Michael`> im just asking for an example that i can use to reference with the haskell notes
22:30:58 <Michael`> please?
22:31:04 <Smerdyakov> You can search the notes for "IO monad."
22:31:14 <Michael`> ive told you my specific problem
22:31:18 <Michael`> can you please help me man
22:31:20 <Smerdyakov> No.
22:31:54 <Michael`> what are you here for then?
22:32:02 <Michael`> youve effectively wasted 15 of both my and your time
22:32:09 <Michael`> whne you could have helped me
22:32:17 <Michael`> and enjoyed the satisfaction of being able to help someone
22:32:30 <Smerdyakov> I am not convinced that it would be ethical to provide further information.
22:32:35 <Smerdyakov> I was determining whether this was the case.
22:32:55 <Michael`> ethical? so it is unethical to provide a snippet of code for someone to cross reference with notes?
22:33:16 <Michael`> and to explain how the example works together
22:33:18 <Michael`> are you serious?
22:33:20 <Michael`> where did u you learn that
22:33:26 <Michael`> they dont teach that in ethics.
22:33:39 <Michael`> i think thats your own brand of ethics; not based on any standard
22:33:42 <Smerdyakov> IO will have been discussed explicitly in great detail if you should be using it.
22:33:52 <Michael`> i understand the concept of IO 
22:34:00 <Smerdyakov> So it seems that either you are purposely not paying attention to class, readings, etc., or your teacher is incompetent.
22:34:00 <Michael`> i dont understand its application in haskell
22:34:12 <Michael`> thats part of this question, dont you think?
22:34:18 <Smerdyakov> I find it safer to leave it up to you to handle the second case by complaining to the teacher, if that's really it.
22:34:28 <Michael`> complaining?
22:34:33 <Michael`> is that how you get what you want man,
22:34:37 <Michael`> do you complain to everyone?
22:34:40 <Michael`> are you a serial whinger?
22:34:43 <Michael`> i think you might be
22:35:05 <Smerdyakov> You can tell your teacher that someone who knows a thing or two about the subject questions the appropriateness of an assignment about IO with no prior discussion of it.
22:35:21 <Michael`> why would i bother doing that?
22:35:34 <Smerdyakov> Because you don't want to waste your time on something that is unfair?
22:35:42 <Michael`> why is it unfair
22:35:55 <Smerdyakov> Because you haven't been taught the needed material?
22:36:10 <Michael`> "unfair" is just an excuse that people like you have learnt to rely on when all else fails
22:36:36 <Michael`> life isnt fair man, get used to that; your doing me a dis-service here
22:36:38 <Smerdyakov> Either that or I know much more about the subject than you do.
22:36:40 <Michael`> and your doing yourself one also
22:37:09 <Michael`> man, using your logic, youd only help me if i knew as much as you, and in that case, i wouldnt need your help
22:37:18 <Michael`> thats a bit stupid, dont you think?
22:37:25 <Smerdyakov> I don't think that makes any sense.
22:37:40 <Michael`> your here to kind of blow your horn off, not to help people
22:37:51 <Michael`> so next time, dont offer me the false pretence that you will offer me your assistance
22:37:52 <Michael`> ok?
22:38:21 <Smerdyakov> I would offer you my assistance if I believed that this was an appropriate academic situation.
22:38:33 <Smerdyakov> It clearly isn't, for some reason or another, so I'm playing it safe.
22:38:54 <Michael`> safe? what is the haskell boogie man going to sneak in through your phone line and blow up your house?
22:39:16 <Smerdyakov> Like I said, it's about ethics.
22:39:44 <Michael`> no it isnt
22:40:05 <Michael`> it is not unethical to present me with an example of a concept
22:40:08 <Michael`> it definately isnt
22:40:11 <Smerdyakov> It certainly is.
22:40:13 <Michael`> i dont know where your from man, but that isnt
22:40:15 <Michael`> unethical
22:40:16 <Smerdyakov> Your question is too specific.
22:40:19 <Michael`> no it isnt man
22:40:26 <Smerdyakov> It is too likely that you will be able to use the code without understanding it.
22:40:33 <Michael`> so if i ask you how do i print "Hello world" to the screen
22:40:42 <Smerdyakov> Then I refer you to any Haskell tutorial.
22:40:46 <Michael`> its unethical of you to explain to me how that is done?
22:41:03 <Michael`> oh so unless you refer me to a tutorial, its unethical?
22:41:03 <Smerdyakov> Printing "Hello world" is actually quite conceptually complicated in Haskell.
22:41:12 <Michael`> for you im sure it is.
22:41:39 <Michael`> i think it takes, what 4-5 lines?
22:41:45 <Smerdyakov> I'm curious: what makes you so sure that I'm exaggerating when you know nothing about the subject?
22:41:48 <Michael`> each of which, you could explain as you displayed
22:41:53 <Smerdyakov> No, I couldn't.
22:42:03 <Smerdyakov> It takes several pages to have any hope of explaining what it means.
22:42:16 <Michael`> then how do good haskell tutorials do it in one?
22:42:22 <Smerdyakov> They don't.
22:42:24 <Michael`> man, i understand how IO works.
22:42:27 <Smerdyakov> No, you don't.
22:42:31 <Michael`> oh really?
22:42:37 <Smerdyakov> That's right. IO in Haskell is unique.
22:42:41 <Michael`> how so?
22:42:45 <Smerdyakov> Read a tutorial and find out.
22:42:50 <Michael`> i have read one.
22:42:53 <Michael`> actually, two.
22:43:13 <Smerdyakov> Great. Then how about you explain the basic idea of IO in Haskell to me? (And explain how you managed to understand it without knowing what a monad is!)
22:43:20 <Michael`> im asking for your opinion of why you think in haskell, IO is unqiue, is that unethical for you to answer?
22:43:34 <Smerdyakov> It's obvious how it is unique.
22:43:57 <Smerdyakov> It's a very complicated system that I can't explain in a sentence, but once you understand it, it's clear why it's unique.
22:44:17 <Michael`> ok.
22:57:47 <shapr> whee
22:57:57 * shapr boings
22:59:09 <shapr> hiya shammah 
22:59:35 <shapr> Michael`: you need some help?
23:02:12 <shapr> good morning #haskell!
23:05:11 <Michael`> hehe yes please:) cale has been helping me though, very helpful
23:07:41 <shapr> ok, do you have any more questions?
23:10:28 <Michael`> ok at the moment im working with mkregex
23:11:46 <shapr> is it working for you?
23:14:10 --- mode: ChanServ set +o shapr
23:14:22 --- kick: Smerdyakov was kicked by shapr (don't pick on newbies)
23:14:31 --- mode: shapr set -o shapr
23:14:36 <Michael`> hehe 
23:14:42 <Michael`> im sure it is working just fine
23:14:46 <Michael`> its not doing what i want it to but lol
23:15:43 <shapr> can you get to do something worthwhile?
23:17:55 <shapr> what are you having trouble with?
23:18:09 <Michael`> i am trying to understand how the mkregex command works
23:18:18 <shapr> @index mkregex
23:18:19 <lambdabot> bzzt
23:18:22 <shapr> @index mkRegex
23:18:23 <lambdabot> Text.Regex
23:18:31 <shapr> @type Text.Regex.mkRegex
23:18:32 <lambdabot> Text.Regex.mkRegex :: String -> Text.Regex.Posix.Regex
23:18:57 <Michael`> lol what on earth does that mean
23:19:13 <shapr> that means that it takes a string and evaluates to a Regex
23:19:34 <Michael`> Evaluates to a regular expression
23:19:35 <Michael`> ?
23:19:55 <shapr> I've used it before, I think you use the resulting regex with another function to apply it to a string to search for a match
23:20:18 <shapr> here's the GHC library index: http://www.haskell.org/ghc/docs/6.2.1/html/libraries/index.html
23:21:02 <shapr> the two ways to search through that are to look for the Text.Regex section in the hierarchy, or to look for mkRegex in the name index
23:21:29 <shapr> @type Text.Regex.matchRegex
23:21:31 <lambdabot> Text.Regex.matchRegex :: Text.Regex.Posix.Regex
23:21:31 <lambdabot> 			 -> String -> Maybe [String]
23:21:33 <shammah> hey shapr :)
23:21:44 <shapr> greetings shammah, how's code?
23:21:51 <shammah> stressful.
23:22:05 <shammah> we're not going to make the deadline with the full featureset we wanted to.
23:22:12 <shapr> that sucks :-(
23:22:26 <shammah> unfortunate interactions between multiple features lead to scope creep.
23:22:47 <shapr> Michael`: see how matchRegex takes first the result of mkRegex, and second a string?
23:23:05 <shammah> We've had to defer some of it till post-release, but that's causing pain to management.
23:24:09 <shapr> well, better a quality product than flaky bits
23:25:48 <shapr> @type Text.Regex.matchRegex (Text.Regex.mkRegex "foo.*")
23:25:50 <lambdabot> Text.Regex.matchRegex (Text.Regex.mkRegex "foo.*") :: String
23:25:50 <lambdabot> 						      -> Maybe [String]
23:25:56 <shammah> indeed.  Of course having to deliver the bad news to your management is hardly a relaxing experience.
23:26:03 <shapr> @type Text.Regex.matchRegex (Text.Regex.mkRegex "foo.*") "maybe there's a foo in here?"
23:26:04 <lambdabot> Text.Regex.matchRegex (Text.Regex.mkRegex "foo.*") "maybe there's a foo
23:26:04 <lambdabot> in here?" :: Maybe
23:26:04 <lambdabot> 											 [String]
23:26:19 <shapr> huh, weird formatting.
23:26:44 <shapr> shammah: truer words have never been spoken :-)
23:28:18 <Michael`> i think youve missed ur deadline because u picked haskell to write it in hahaha
23:28:32 <Michael`> just joking, im starting to understand this
23:29:07 <shapr> In my experience, I can write Haskell faster than any other language. For most application goals, not all.
23:29:12 <shammah> shapr: Do you want to tell him, or should I? ;)
23:29:18 <Michael`> hehe :p
23:29:27 <Michael`> yes so all these haskell programmers will say hehe
23:30:07 <shapr> shammah: is your app written in Haskell?
23:30:22 <shammah> shapr: nope, Java.  Remember ;)
23:30:34 <shapr> I didn't think it was written in Haskell.
23:30:56 <shapr> Michael`: my day job is Python programming, but I think I could get more done in less time if it were written in Haskell.
23:31:11 <shammah> I don't get to do much haskell programming atm.  I just continue to hang around here because haskell programmers tend to be smarter ;)
23:32:10 <shapr> I wrote a bayesian spam filter in three or four evenings and less than 200 lines of code (not counting the email parser)
23:33:00 <shapr> not that it did better than 80 or 85 percent
23:39:15 * shapr bounces
23:39:29 <shapr> man, where did I put my homework?
23:41:42 <Michael`> lol i can give you some of mine if ur missing urs
23:41:44 <Michael`> :p
23:41:51 <shapr> Michael`: it my firm belief that programmers should really understand all the different ways of approaching programming (procedural, functional, logic, etc) and find out what works best for each person, and what works best for different problems.
23:41:54 <shapr> heh
23:42:14 <Michael`> that was automated i assume hehe
23:42:18 <jesse99> have you done muh logical programming shapr?
23:42:25 <shapr> jesse99: no, not yet :-)
23:42:29 <shapr> what was automated?
23:42:46 <jesse99> i looked at Curry a bit, looked rather interesting
23:43:15 <shapr> I actually meant to go for logic programming first, but got distracted by Haskell.
23:43:25 <shapr> so here I am for three years and a bit.
23:45:07 <shapr> I meant to go for logic programming next, but now epigram is looking very tasty...
23:45:57 * shapr considers making a "Hooked on Type Theory" t-shirt
23:46:59 <shapr> Michael`: too bad your homework won't help me learn Swedish.
23:47:04 <Michael`> lol
23:47:30 <shapr> var har jag lämnat min läxa?
23:47:32 <Michael`> I am trying to write a function that replaces every instance of Ben with Benjamin
23:47:39 <Michael`> in a certain string
23:48:48 <Michael`> i know now that
23:49:07 <Michael`> "let r = mkRegex "Ben"
23:49:24 <Michael`> matchRegexAll r "Hi my name is Ben"
23:49:27 <Michael`> gives me
23:49:34 <Michael`> Just ("Hi my name is ","Ben",", how are you?",[])
23:49:56 <Michael`> now, i need to write a recursive function that replaces Ben with Benjamin
23:49:57 <shapr> what do you get if there are multiple Ben strings in there?
23:50:12 <Michael`> it just picks the first, right?
23:50:19 <Michael`> so i use recursion until there are no matches
23:50:58 <shapr> if that's true, that sounds like a good approach
23:51:09 <Michael`> well
23:51:20 <shapr> I thought matchRegexAll matched several at once
23:51:22 * shapr tries it
23:52:35 <shapr> Michael`: oh, you're right :-)
23:53:21 <Michael`> hooray
23:53:25 <shapr> yes, that's exactly how I would do that too, if I were using regexes.
23:53:50 <Michael`> i understand in theory
23:53:57 <Michael`> but i dont understand how to access the output of that function
23:54:13 <shapr> the Maybe type represents possible failure
23:54:27 <shapr> type Maybe a = Nothing | Just a
23:54:57 <shapr> that way, if the regex doesn't match at all, it returns Nothing
23:55:10 <shapr> if does match something, it returns Just (match in here)
23:55:29 <shapr> there are cheesy and non-cheesy ways of stripping off the Just
23:55:44 <shapr> the cheesy way is (\ (Just x) -> x)
23:55:58 <shapr> which is what the function Data.Maybe.fromJust does
23:56:20 <shapr> there are at least two less cheesy ways available in Data.Maybe
23:57:16 <shapr> one takes a value to use in place of a Nothing, and Maybe result
23:57:28 <shapr> anyway, you'll probably do fine with the cheesy way
23:57:41 <Michael`> yeah
23:58:39 <shapr> the non-cheesy stuff is nifty, you should check it out if you get interested.
23:58:53 <shapr> oh, lambdabot is written in Haskell, lambdabot is a great code-toy.
23:58:54 <shapr> @fortune
23:58:55 <lambdabot> What GOOD is a CARDBOARD suitcase ANYWAY?
23:58:58 <shapr> @fortune
23:58:58 <lambdabot> Rincewind had generally been considered by his tutors to be a natural wizard
23:58:58 <lambdabot> in the same way that fish are natural mountaineers.  He probably would have
23:58:58 <lambdabot> been thrown out of Unseen University anyway--he couldn't remember spells
23:58:58 <lambdabot> and
23:58:58 <lambdabot> smoking made him feel ill.
23:58:59 <lambdabot> 		-- Terry Pratchett, "The Light Fantastic"
23:59:35 <shapr> @eval map (\x -> x + 1) [1,2,3]
23:59:36 <lambdabot> [2, 3, 4]
