00:00:50 <shapr> @seen Smerdyakov
00:00:50 <lambdabot> Smerdyakov is in #haskell.
00:01:12 <shapr> hm, I think that's a bug I need to fix.
00:02:54 <shammah> @seen shapr
00:02:54 <lambdabot> shapr is in #Chalmers, #haskell, #darcs, #haskell.se, #webwitches, #haskelldb
00:02:54 <lambdabot> and #joy.
00:03:08 <shammah> :)
00:03:34 <shammah> of course that doesn't appear to be a complete list ;)
00:44:14 * jesse99 likes that quote
00:44:36 <jesse99> altho inceidentally is taking things a bit far
00:54:36 <Michael`> is there another way to check for matches of a pattern
00:54:43 <Michael`> since regex isnt 100% portable
00:54:59 <Michael`> it relies on the library
00:58:33 <shapr> Michael`: there's span and break
00:58:46 <shapr> you could use them recursively to cut out a static string and replace it.
01:00:32 <dons> ghc carries its own version of the posix regex library with it, in case the system doesn't have it
01:00:40 <shapr> g'day dons
01:00:43 <dons> heya
01:01:12 <shapr> Cale: hey, mcmaster's link from http://www.haskell.org/jobs.html is 404, is there a working link?
01:02:16 <Cale> hmm...
01:02:19 <Cale> not sure
01:02:29 <Cale> I suppose you could put http://www.cas.mcmaster.ca/cas/contact.html
01:02:38 <Cale> but that's not the same thing
01:03:00 <shapr> I've written up a nice resume with lots of extra included Haskell bits, so I figured I'd send it out to all the places that just might be interested in hiring a Haskell programmer.
01:04:12 <Michael`> hey shapr: i am having trouble
01:04:19 <shapr> what with?
01:04:23 <Michael`> I have imported the Text.Regex library into Hugs
01:04:28 <shapr> ok
01:04:39 <Michael`> but it doesnt recognise ERROR "C:/a.hs":5 - Undefined variable "mkRegex" 
01:04:49 <Michael`> it finds the library
01:05:00 <Michael`> otherwise if it didnt, it would result in an error when loading the file
01:05:10 <Michael`> so why doesnt it recognise mkRegex
01:05:11 <shapr> does a.hs have "import Text.Regex" under the module declaration?
01:05:23 <shapr> it needs to have something like:
01:05:24 <shapr> module Main where
01:05:27 <shapr> import Text.Regex
01:05:28 <Michael`> i havent declared a module
01:05:49 <shapr> it's not always required, but most files have a module declaration.
01:06:08 <Michael`> yep
01:06:11 <Michael`> i will send you my file
01:06:17 <shapr> can you paste it into the wiki?
01:06:29 <Michael`> surely that will be easiest
01:06:30 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:07:39 <Michael`> http://pastepad.com/?pad=96
01:07:54 <Michael`> i couldnt work that wiki thing out
01:07:59 <earthy> ;)
01:08:04 <earthy> this works as well
01:08:48 <shapr> Michael`: that looks right to me
01:08:50 <earthy> hm. my hugs is too old. ;)
01:08:57 <earthy> ERROR /tmp/foo.hs:3 - Syntax error in import declaration (unexpected symbol "Text.Regex")
01:09:03 <Michael`> yep
01:09:05 <Michael`> i get
01:09:15 <Michael`> IO> :l C:/a.hs
01:09:15 <Michael`> ERROR "C:/a.hs":7 - Undefined variable "mkRegex"  
01:09:20 <earthy> (Feb 2001 hugs ;))
01:09:42 <Michael`> im using hugs98
01:09:44 <Michael`> hehe
01:09:46 <earthy> ghci understands it though
01:09:50 <Michael`> yeah
01:09:58 <shapr> can you use GHCi?
01:10:22 <Michael`> i dont have GHCi
01:10:44 <earthy> http://www.haskell.org/ghc/ and then there's a windows installer
01:10:59 <shapr> it should work, sounds like maybe a path problem or so
01:11:11 <shapr> in any case, the span or break method will work as well
01:11:13 <shapr> @type span
01:11:15 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
01:11:24 <shapr> err, I think it will.
01:11:42 <Michael`> do you use head and tail commands on this?
01:11:45 <earthy> michael: what exact version of Hugs98 do you have?
01:12:01 <Michael`> no idea hehe
01:12:18 <earthy> if you start hugs, it displays the Hugs logo and a date underneath it
01:12:29 <earthy> (somethink like Feb 2001 or Nov 2002 or Nov 2003)
01:12:35 <Michael`> ah k
01:12:54 <earthy> the code works with the November 2003 version
01:13:06 <earthy> though not the February 2001 version
01:13:36 <Michael`> im dl'ing the ghci
01:13:37 <Michael`> hehe
01:13:56 <earthy> yeah, that's the better choice in the long run anyway. ;)
01:14:15 <Michael`> i should try to understand this span command
01:14:32 <Michael`> span [a,a]
01:15:13 <Michael`> how is it used?
01:15:46 <shapr> span (/= "foo") "cut this at a foo I think?"
01:15:57 <earthy> shapr: e.g.
01:15:58 <shapr> err
01:16:04 <earthy> but that won't work. ;)
01:16:09 <shapr> yah, I just noticed
01:16:21 <earthy> span (/= "foo") $ words "cut this at a foo I think?"
01:16:23 <earthy> does however
01:16:31 <shapr> ah, cool
01:16:54 <earthy> span (/= 'a') "well when will this span cut?"
01:17:02 <earthy> does as wll
01:23:55 * shapr bounces cheerfully
01:30:37 <shapr> Michael`: everything working?
01:34:10 * shapr bounces
01:51:30 <Michael`> hehe
01:51:33 <Michael`> not really hehe
02:25:52 <musasabi> morning
02:26:08 <musasabi> Text.Regex is quite broken.
02:26:29 <musasabi> or better said the limitations are not documented.
02:59:27 * shapr bounces randomly
03:58:31 <seafood> Maxwell's demon puts him in place
03:58:48 <seafood> in *his* place
03:58:49 <shapr> g'day seafood 
03:59:05 <seafood> g'day my sub-arctic denizen.
03:59:16 <shapr> how's the sunny south treating you?
03:59:23 <seafood> Very well thank you.
04:15:45 <Michael`> :)
04:15:58 <shapr> g'day Michael` 
04:16:02 <Michael`> gday again hehe
04:16:10 <Michael`> im back to try and solve this lingering problem hehe
04:19:20 <Michael`> ok
04:19:27 <Michael`> so it gives you is it called a tuple?
04:19:28 <shapr> ok what?
04:19:36 <shapr> what what?
04:19:36 <Michael`> (,,,,) four values are returned
04:19:39 <Michael`> using the
04:19:46 <shapr> that looks like a tuple to me
04:19:50 <Michael`> matchRegexAll
04:19:55 <Michael`> I want to find the 2nd value
04:19:58 <Michael`> is there a 2nd function
04:20:05 <Michael`> like second (a,b,c)
04:20:06 <Michael`> ?
04:20:13 <Michael`> i know there is a head (a,b)
04:20:20 <Michael`> and tail (a,b) function
04:20:21 <shapr> twoOfFour = (\ (_,x,_,_) -> x)
04:20:22 <Michael`> hehe
04:20:32 <shapr> actually, you're thinking of fst and snd
04:20:36 <shapr> those only work on two tuples
04:20:46 <Michael`> yep yep
04:20:52 <Michael`> head and tail work
04:21:00 <shapr> on lists
04:22:23 <Michael`> so to replace a certain part of text i would think is to make a new variable called idunno newvar
04:22:24 <Michael`> hehe
04:23:15 <Michael`> fst (whatever that function returns) + the replacement string, + the 3rd part of the function return
04:23:19 <Michael`> does that make sense?
04:28:08 <Michael`> ?
04:30:53 <shapr> sounds right so fra
04:30:55 <shapr> far
04:30:56 <shapr> have you tried it?
04:33:24 <Michael`> x = mkRegex "Ben"
04:33:25 <Michael`> testmatch st = matchRegexAll x st
04:33:46 <Michael`> how can i fix that more, perhaps i should define the function?
04:33:50 <Michael`> is that what u call it?
04:34:17 <Michael`> like testmatch :: String -> String
04:34:20 <Michael`> how do i do that?
04:34:28 <Iter> hey Michael.  Managed to work out your replace function yet?
04:35:20 <Michael`> Iter: nope :\
04:48:30 <Michael`> ok im getting somewhere
04:48:32 <Michael`> x = mkRegex "CIT"
04:48:32 <Michael`> st = "My course is run by the CIT department"
04:48:32 <Michael`> testmatch st = matchRegexAll x st
04:48:41 <Michael`> Now how do i get the first and third parts of the return tuple thingy
04:48:42 <Michael`> ie
04:48:47 <Michael`> Just (a,b,c,d)
04:48:54 <Michael`> coz the replacement string will be a + replacement + c hehe
04:49:49 <Iter> nah, that's a tuple.
04:51:02 <Michael`> thats what i said hehe
04:51:13 <Michael`> <Michael`> Now how do i get the first and third parts of the return tuple thingy
04:51:42 <Iter> match it against a pattern.
04:52:19 <Michael`> is there a command?
04:53:02 <Iter> no.  It's a core part of haskell's syntax.
04:53:38 <Michael`> third = (\ (_,_,x,_) -> x)
04:53:39 <Boegel> hello every1
04:53:46 <Michael`> thats what i want for third yeah?
04:54:27 <Iter> something like that.
04:54:47 <Igloo> Those outer parens aren't necessary, and you could also say  third (_,_,x,_) = x
04:55:25 <Boegel> \ and -> is a lambda expression, not really necessary
04:55:31 <Iter> although I would consider having the next function in the sequence match directly against the tuple.
04:55:39 <Iter> func (a,b,c,d) = ....
04:55:49 <Boegel> like Igloo sais :)
05:08:00 <Michael`> im still stuck :S
05:10:38 <Michael`> how do u join 2 strings together?
05:10:48 <Michael`> ie x = string1 + string2
05:10:48 <Michael`> ?
05:10:58 <arjanb> ++
05:11:08 <Michael`> got it, cheers :)
05:12:36 <Boegel> concat :)
05:14:20 <Michael`> yeah
05:14:29 <Michael`> i get this when i look for a match in a string
05:14:45 <Michael`> JUST (a,b,c,d)
05:14:46 <Michael`> right?
05:14:58 <Michael`> why doesnt fst() of that return me a
05:14:59 <Michael`> :S
05:15:47 <ibid> fst takes a pair, Just (a,b,c,d) is Maybe quadruple
05:15:58 <ibid> note, Just, not JUST :)
05:16:07 <ibid> unless you have defined your own JUST
05:16:15 <Michael`> nope i havent
05:16:26 <Michael`> ok, so u can only use first on a couple>
05:16:30 <Michael`> is that correct
05:17:41 <Michael`> ah u cant match it against a maybe thing anyhow :S
05:17:42 <Michael`> grrr
05:17:43 <ibid> on a pair
05:18:17 <Michael`> i just tried it on the type
05:18:27 <Michael`> Maybe (String,String,String,String)
05:18:29 <Michael`> and it doesnt work,
05:18:30 <Michael`> :S
05:20:28 <Michael`> anyone?
05:21:57 <Michael`> -> Maybe [String] Returns: Just strs if the match succeeded (and strs is the list of subexpression matches), or Nothing otherwise. 
05:22:13 <Michael`> how do i access the list of subexpression matches? :S
05:22:41 <ibid> pattern match on it'
05:23:00 <Michael`> how does one do that :P
05:23:31 <Iter> func Maybe a = .... 
05:23:39 <Iter> func Nothing = ....
05:24:03 <Michael`> can you give me an example, that doesnt make sense to me atm :\
05:24:06 <Iter> (or have I got my syntax confused with sml or erlang? ;)
05:24:20 <Boegel> syntax is ok I think
05:24:28 <Boegel> haven't Haskelled in a while :)
05:24:45 <Iter> Michael: Have you got a copy of Thompson or Hudak?
05:24:55 <Michael`> whats that
05:25:14 <ibid> they're (authors of) books
05:25:20 <Michael`> ok, nope
05:25:29 <Michael`> how does this func Maybe a = ... work?
05:25:47 <ibid> get a  book or a good tutorial :)
05:25:49 <Michael`> the function takes in a maybe variable and a variable a
05:25:55 <Michael`> im so close..
05:25:59 <ibid> func (Maybe a) = ...
05:26:05 <ibid> is the correct syntax
05:26:08 <Michael`> yep
05:26:23 <Michael`> ok, will that return the first subexpression in the tuple?
05:26:38 <Iter> bugger.  i've got both of them next to me.  I was hoping I could just point you at a page/chapter :)
05:26:38 <Iter> ibid: thanks.
05:27:06 <ibid> Michael`: you *really* should get a book or a good tutorial
05:27:16 <Iter> Well actually what you're wanting is func (Maybe (a,b,c,d)) = .... and func Nothing = ....
05:27:24 <Michael`> i know, but i am so close to getting this function.. i have been trying for like 5 hrs
05:27:24 <Michael`> :|
05:27:26 <ibid> Michael`: that's one of the central basic topics in haskell programming and it's not that easy to explain on irc
05:27:33 <Michael`> yep
05:27:35 <Michael`> aha
05:27:56 <Michael`> i get that, so that func function, takes in the variable Maybe of type Maybe
05:28:01 <ibid> what's your background?
05:28:05 <ibid> Michael`: no
05:28:09 <Michael`> and assigns each of the tuple values to a b c d?
05:28:13 <ibid> Michael`: no
05:28:16 <Michael`> then?
05:28:18 <ibid> Michael`: well...
05:28:24 <Michael`> my background is java 
05:28:26 <Michael`> not haskell hehe
05:28:32 <Michael`> i have to write a small problem, thats it
05:28:37 <Michael`> i am so close :\
05:28:59 <ibid> Michael`: func (Just (a, b, c, d)) = ... is the header of a function that takes one parameter of type Maybe (a, b, c, d)
05:29:11 <ibid> Michael`: you are not that close if pattern matching is unknown to you
05:29:23 <Michael`> well i learn by example
05:29:29 <ibid> Michael`: in addition, that particular function will only take Maybes that are Justs
05:29:34 <Michael`> hehe, once i can see how it is applied, i am able to conceptualise it
05:29:35 <ibid> Michael`: get a good tutorial or a book
05:29:47 <Michael`> yes, i dont have time, i am running against a clock here
05:29:52 <ibid> Michael`: if your only background is java, you're in for a shock
05:29:55 <Iter> feh.  I did mean func (Just (a,b,c,d)) = ... :)  opps.  
05:30:18 <Michael`> what does the ... represent in your function
05:30:23 <ibid> Michael`: why are you running against a clock?
05:30:31 <ibid> Michael`: stuff that you have to write yourself :)
05:30:33 <Michael`> its a figure of speech ibid
05:30:40 <ibid> Michael`: i *know* that
05:30:41 <Michael`> you know, a metaphorical term?
05:30:48 <ibid> Michael`: i'm not a fool
05:30:49 <Iter> Michael: except that as a professional java developer I can assure you that Java dosn't have anything that even *looks* like pattern matching, or type constructors, and they're basic haskell.
05:31:01 <Michael`> yeah, im aware of that
05:31:06 <Michael`> ive done lots of reading on functional programming
05:31:08 <Michael`> ok?
05:31:13 <Michael`> :)
05:31:22 <ibid> Michael`: i was asking, how did you get into a situation where you have a deadline and inadequate learning materials
05:31:27 <ibid> Michael`: are you on a course?
05:31:34 <Iter> Michael: Do you know python at all?
05:31:36 <Michael`> yes, its called working full time to pay for my course
05:31:44 <Michael`> and having to struggle to meet deadlines on my assignments
05:31:45 <Michael`> ok?
05:31:45 <Michael`> :)
05:31:57 <Michael`> its not easy for everyone u know?
05:32:07 <ibid> Michael`: why hasn't your instructor provided you with adequate learning materials?
05:32:19 <Michael`> well, this is only a *small* question
05:32:23 <ibid> Michael`: that it is not easy is exactly what i've been trying to say!
05:32:34 <ibid> Michael`: it's not a SMALL question, it's a HUGE question
05:32:43 <Michael`> hehe in terms of weight on this project
05:32:45 <Michael`> its SMALL
05:32:45 <Michael`> hehe
05:32:46 <Michael`> :)
05:32:51 <Michael`> i want to understand it
05:32:55 <Michael`> i am nearly there
05:33:05 <ibid> Michael`: it sounds to me that you are, unfortunately, in deep shit, so to speak
05:33:05 <Michael`> i just need to work out what you mean by pattern matching hehe
05:33:14 <ibid> Michael`: get a good tutorial
05:33:27 <ibid> Michael`: in fact, your instructor should have provided you with one
05:33:30 <Michael`> ok for the 9th time ive seen you type that
05:33:31 <Michael`> :)
05:33:41 <ibid> Michael`: because you seem to ignore it
05:33:48 <Iter> Michael: except that pattern matching is the basic call-mechanism used by haskell.
05:34:05 <Boegel> Michael: it means that Haskell will make sure the right defition of your function is executed, looking at the kind of parameter you give
05:34:11 <Iter> haskell functions don't look all that much like java methods.  
05:34:14 <Boegel> func (Type1 a) = bleh
05:34:23 <Boegel> func (Type2 a) = bleh2
05:34:23 <ibid> Michael`: ok, pattern matching is the Visitor pattern on steroids
05:34:30 <Iter> Michael: Have you ever used an ML dialect?
05:34:44 <ibid> Michael`: that's as succinct as i can put it
05:34:47 <Boegel> if you give a parameter of Type1, Haskell will execute bleh
05:34:56 <Boegel> otherwise (Type2) it will execute bleh2
05:35:01 <Boegel> that's the whole idea
05:35:09 <ibid> Type1 and Type2 are not types, though :)
05:35:21 <Boegel> well, that's the whole idea
05:35:31 <Boegel> I know it's not exact
05:35:37 <Boegel> but the idea is right :p
05:35:56 <ibid> Boegel: confusing types and data constructors is, so to speak, confusing :)
05:36:02 <ibid> Boegel: especially to beginners
05:36:11 <ibid> Michael`: i've heard good things about http://www-106.ibm.com/developerworks/edu/os-dw-linuxhask-i.html
05:36:48 <Boegel> okay I know
05:36:57 <Boegel> but it has been a while since I coded in Haskell
05:38:12 <ibid> Michael`: though that particular tutorial neglects pattern matching :/
05:40:13 <Michael`> grrrr
05:40:25 * ibid feels  bad for pounding on Michael` but can't really find any other thing i could do there
05:43:07 <Michael`> yeah
05:43:09 <Michael`> is there any way at all
05:43:10 <Michael`> Just ("Bit before match", "Match", "Bit after match", [])
05:43:22 <Michael`> that u can explain how to get those values set to a variable
05:44:17 <ibid> case Just ("Bit before match", "Match", "Bit after match", []) of Just (a,b,c,d) -> ...
05:44:44 <ibid> now, in the "..." part, a is "Bit before match", b is "Match", c is "Bit after match", d is []
05:55:21 <Michael`> ok, that works great and i understand it no
05:55:26 <Michael`> but i have another problem hehe
05:55:32 <Michael`> haskell gives it a type IO
05:55:39 <Michael`> and i want to use it as a String hehe
05:55:39 <Michael`> :S
05:55:59 <Michael`> now*
05:56:44 <Iter> ok, how did you manage to get into the IO monad? :)
05:56:51 <Michael`> ill show u my code :)
05:56:58 <Iter> did you use a do statement ?
05:57:13 <Michael`> nope
05:57:13 <Michael`> first (Just (a,b,c,d)) = print a
05:57:13 <Michael`> third (Just (a,b,c,d)) = print c
05:57:13 <Michael`> testmatch st x = matchRegexAll x st
05:57:13 <Michael`> replace a b c = first(testmatch a (mkRegex b)) ++ c ++ third (Just (a,b,c,d)) = print c
05:57:28 <Michael`> replace a b c is like
05:57:45 <Michael`> replace "Hello World" "World" "All"
05:57:46 <Michael`> to give
05:57:49 <Michael`> "Hello All"
05:57:53 <Iter> ahhh. the print would have done it.
05:57:56 <Michael`> yeah
05:58:10 <Michael`> how do i return c
05:58:13 <Michael`> without printing it
05:58:19 <Iter> print has the type IO 
05:58:23 <Michael`> yep i see it now
05:58:25 <Michael`> return c
05:58:26 <Iter> feh. type IO ()
05:58:27 <Michael`> does that work?
05:58:45 <Michael`> hehe thats java coming to bite me in the bum
05:58:45 <Iter> nope.
05:58:55 <Iter> 'cause return c is also a Monad ;)
05:58:59 <Michael`> aha
05:59:02 <Michael`> what isnt
05:59:09 <Michael`> hehe, how can i use the value obtained in that function
05:59:12 <ibid> Michael`: lose the java and just first (Just (a,b,c,d)) = a
05:59:13 <Michael`> without much trouble
05:59:19 <ibid> :)
05:59:20 <Iter> Haskell uses expressions.
05:59:24 <Michael`> yes i know hehe
05:59:27 <Iter> Java uses statements.
05:59:30 <Michael`> yes i know
05:59:34 <ibid> and lose the hehe, please :)
05:59:36 <Michael`> ok
05:59:37 <Iter> a function is just a parametised expression.
06:00:38 <Iter> 'a' is an expression, so func (a,b,c,d) = a is a function that expresses 'first' ;)
06:01:38 <Michael`> got it!!
06:01:39 <Michael`> :D
06:01:40 <Michael`> :)
06:02:14 <Boegel> now code in style :p
06:03:15 <Michael`> hehe thats what haskell is about :p
06:03:22 <Michael`> now i gotta write a function called replaceall
06:03:44 <Michael`> that recursively iterates through the given string until there is no more instances of the match text :p
06:04:03 <Boegel> Haskell is great at recursion
06:04:15 <Michael`> how would i write an if statement for that replace function so that if there is no match
06:04:19 <Michael`> it wont have an error
06:04:33 <Michael`> ill use gates
06:04:58 <Boegel> you should break the string in pieces, beginning at the front, and check every word for your match
06:05:06 <Boegel> until you have and empty string
06:05:15 <Boegel> and while you're checking, replace if you have to
06:05:52 * Boegel is beginning to find ray casting annoying, because it's not doing what it's supposed to be doing :@
06:06:05 <ibid> why do i get the feeling that we're being suckered into solving homework
06:06:17 <Boegel> because we are, ibid :o)
06:06:21 <ibid> :)
06:06:55 <Michael`> lol the question for my homework doesnt even relate to writing a replace function
06:07:04 <Michael`> :\ this is just so i get an understanding
06:07:08 <ibid> ok
06:08:17 <Boegel> we believe you *ahum*
06:08:24 <Boegel> so what IS you homework then ?
06:09:11 <Michael`> ok for my homework
06:09:37 <Michael`> I have to write a program that reads a txt file in and replaces certain words as they are read in, and print to screen
06:09:37 <Michael`> hehe
06:10:35 <Boegel> and that has _nothing_ to do with your replace function ? :|
06:10:53 <Michael`> it doesnt man, but it just one portion of the question hehe
06:12:25 <Boegel> so we r solving your homework
06:12:33 <Boegel> not quite fair is it
06:12:41 <Boegel> maybe we should mail your teacher about all this :p
06:12:45 <Michael`> hehe
06:12:58 <Michael`> oh come off it ;)
06:13:00 <Boegel> give us his mail-adres pls :o)
06:13:29 <Boegel> or we shall be forced to give u wrong answers :p
06:13:30 <Michael`> i have 1 more question :P
06:13:36 <earthy> queensland, australia
06:13:41 <Michael`> how do u test if something is null
06:13:44 <Boegel> eh ?
06:13:49 <Iter> lol.
06:13:50 <earthy> lemme guesss, the teach's name is Chakravarty?
06:13:54 <Boegel> null doesn't exist, that's Java :p
06:14:06 <Michael`> no concept for null in Haskell?
06:14:15 <Boegel> [] is empty list
06:14:32 <Iter> ahhh, so Michael`, UQ or QUT?  I suspect UQ. :)
06:14:49 * earthy suspects that as well
06:14:52 <Boegel> I have to go
06:14:54 <Iter> Who's your lecturer?  I probably know him :)
06:15:19 <earthy> possibly dr. Watson, then? :)
06:15:24 <Michael`> lol shhhh
06:15:30 <Michael`> testmatch a (mkRegex b) != Nothing
06:15:34 <Michael`> thats what i have to test for hehe
06:15:41 <Michael`> or
06:15:58 <Michael`> (testmatch a (mkRegex b)) != Nothing
06:16:29 <Michael`> /= in haskell
06:16:29 <Boegel> hehe bye !
06:16:36 <Michael`> ?
06:16:46 <Boegel> I'm gone :p
06:16:57 <Boegel> bye now, good luck with Michael` fellas ;-)
06:16:58 <Michael`> night man, thanks for help :)
06:17:11 <Boegel> night ? it's 15:17 here :o)
06:17:15 <Michael`> ok ok
06:17:17 <Michael`> thats great!
06:20:49 <Iter> 2320 here in .au ;)
06:21:08 <Iter> Michael: This a COMP3400 assignment?
06:28:05 <Michael`> nope :P
06:28:10 <Michael`> i got another question
06:28:25 <Michael`> i am trying to make it replace ALL instances in a string
06:28:55 <Michael`> http://pastepad.com/?pad=97
06:29:15 <Michael`> at the moment, it just returns null, if i take out the extra recursion to make it just replace the first instance, it works fine :)
06:29:55 <Lemmih> @wiki HaskellIrcPastePage
06:29:55 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:32:05 <Michael`> anyone know why?
06:34:51 <arjanb> look at what happens if testmatch can't find the regex
06:38:26 <Michael`> yeah it just returns an empty string
06:38:35 <Michael`> how can i make that function to recall itself with the answer
06:45:00 <Michael`> anyone?
06:46:51 <SyntaxNinja> Michael`: care to repeat your entire question?
06:49:02 <Lemmih> Michael`: Is it homework?
06:51:02 <Michael`> nope
06:51:13 <Michael`> i need help to make a function of mine recur
06:51:13 <Michael`> hehe
06:51:25 <Michael`> here is the code of the function which isnt recursive
06:51:46 <Michael`> replace a b c 
06:51:46 <Michael`>    | (testmatch a (mkRegex b)) /= Nothing = first(testmatch a (mkRegex b)) ++ c ++ third(testmatch a (mkRegex b))
06:51:46 <Michael`>    | otherwise = ""
06:52:08 <Michael`> i want it to instead of returning the string with the first instance replaced
06:52:16 <Michael`> return the string with every instance replaced
06:53:25 <Michael`> to make it recur i just call the replace function like this
06:53:35 <Michael`> replace first(testmatch a (mkRegex b)) ++ c ++ third(testmatch a (mkRegex b)) b c
06:53:56 <Michael`> but, somewhere i need a way to print the answer when its done recurring :\
06:54:24 <Michael`> i need like a counter or something :\
06:54:50 <Lemmih> Not really.
06:55:05 <arjanb> the non recursive one is wrong too in case the string doesn't match the regex
06:55:18 <Michael`> thats right
06:55:27 <Michael`> if the string doesnt match the regex it returns ""
06:55:32 <Michael`> so that way i dont get an error
06:57:02 <arjanb> why not returning the original string?
06:57:56 <Michael`> oh yeah :\
06:59:08 <Michael`> you solved it :)
07:00:11 <Michael`> fook yeah! :)
07:03:45 <shapr> @yow !
07:03:45 <lambdabot> Hmmm..  a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT
07:03:45 <lambdabot>  by a TROLLEY-CAR..
07:06:28 <Michael`> how does one print the entire contents of words.txt to the screen?
07:06:40 <SyntaxNinja> cat words.txt
07:06:51 <SyntaxNinja> hi shapr
07:06:56 <Michael`> cat?
07:07:07 <ibid> man cat :)
07:07:10 <shapr> hiiiiiiii SyntaxNinja 
07:07:26 <shapr> Michael`: you want to do that in pure haskell?
07:07:52 <ibid> shapr: i suggest you read the scrollback :)
07:08:01 * shapr looks
07:08:07 <shapr> wow, that's a lotta scrollback
07:08:21 <Michael`> yes in pure haskell hehe
07:08:45 <Lemmih> Michael`: readFile "words.txt" >> print
07:09:46 <Michael`> ok
07:09:49 <Michael`> the tricky part is
07:10:09 <Michael`> i have to filter words and replace them as its being printed to the screen
07:10:48 <SyntaxNinja> this isn't homework?
07:11:03 <shapr> gutentag irsirius 
07:11:04 <ibid> warning to newcomers: he's trying to make us solve his homework, piece by piece
07:11:18 <ibid> (hence, none of the questions are the totality of his homework)
07:11:20 <irsirius> hi
07:11:23 <Michael`> ibid lol grrr haskell isnt easy
07:11:32 <ibid> Michael`: i told you that
07:11:38 <earthy> haskell isn't hard either
07:11:39 <Michael`> hehe i agree
07:11:52 <earthy> it just requires thinking ;)
07:11:55 <Michael`> yeah
07:12:04 <earthy> buying houses, now that's hard. :)
07:12:05 <Michael`> you have to know the concepts first to be able to apply them
07:12:15 <Michael`> u cant apply concepts u dont know, can u?
07:12:27 <ibid> earthy: isn't that supposed to be "reading klingon"?
07:12:28 <ibid> :)
07:12:34 <Michael`> since ive never programmed in a purely functional programming language
07:12:38 <Michael`> many of these concepts are new, yeah?
07:12:39 <Michael`> :)
07:12:44 <earthy> ibid: I've been doing more of the former and less of the latter lately. ;)
07:12:48 <ibid> earthy: :)
07:12:57 <shapr> reading klingon?
07:12:58 <ibid> earthy: i hope you got the reference, though :)
07:13:20 <earthy> I'm trying to find it
07:13:25 <ibid> Michael`: we understand that, but i'm concerned that you are trying to learn  too much too fast, with inadequate materials
07:14:12 <shapr> I'm a binge learner.
07:14:14 <SyntaxNinja> Michael`: I'm sure people here will be willing to help you learn the concepts, but I think we're all hoping that you'll admit that it's hard and try to think deeply about things.
07:14:16 <earthy> so am I
07:14:30 <earthy> nothing for half a year, then catchup for 2 weeks... ;)
07:14:33 <shapr> I guess that's better than being a binge drinker.
07:15:08 <shapr> I binge about once a month.
07:15:08 <ibid> shapr, earthy: it was a star trek reference
07:15:19 <ibid> which, i suppose, is obvious *blush*
07:15:20 <shapr> well yeah, but to what series, episode, and character?
07:15:22 <Michael`> Syntax: yep ive got my thinking cap on :)
07:15:27 <ibid> character is scotty
07:15:40 <shapr> ah, TOS most likely
07:15:44 <shapr> or maybe one of the klingon movies
07:15:52 <ibid> shapr: star trek iv - voyage home
07:15:54 <shapr> ah
07:16:00 <SyntaxNinja> Michael`: so try to solve the problem and ask us conceptual questions :)
07:16:01 <earthy> yeah, I was thinking either one of the TOS characters or Whorf. :)
07:16:08 <ibid> "damage control is easy. reading klingon - that's hard"
07:16:18 <earthy> (but I'd have guessed Spock)
07:16:19 <shapr> did you hear that scotty got his name on the pavement in front of that famous restaraunt a few days back?
07:16:23 <ibid> earthy: lose the h :)
07:16:27 <ibid> shapr: yeah
07:16:32 <shapr> sadly, scotty also has alzheimers' :-(
07:16:33 <earthy> ibid: that was on purpose. :)
07:16:38 <ibid> earthy: oh?
07:16:46 <Michael`> ok without giving me the code
07:16:51 <earthy> to see who'd bite. ;)
07:16:56 <Michael`> how does one open a file for access in haskell
07:17:01 <Michael`> read it in line by line
07:17:05 <Michael`> and print it to the screen :))
07:17:08 <ibid> earthy: i've seen people make that mistake in earnest
07:17:18 <shapr> I'd use readFile and putStrLn 
07:17:23 <SyntaxNinja> Michael`: there are functions for each of these things in the standard library. do you have a reference to the library?
07:17:40 <SyntaxNinja> http://www.haskell.org/ghc/docs/latest/html/libraries/
07:17:41 <earthy> main = do print $ readFile "filename"
07:17:46 <earthy> (IIRC)
07:18:05 <Michael`> earthy: that wont work coz i need to read it in line by line :)
07:18:14 <earthy> um, yeah? :)
07:18:20 <Lemmih> @type lines
07:18:20 <Michael`> reading libraries now :)
07:18:21 <lambdabot> lines :: String -> [String]
07:18:23 <earthy> ever heard of haskell being lazy? :)
07:18:24 <shapr> you could split it into lines after reading it
07:18:28 * shapr is lazy too
07:19:05 <earthy> it defaults to flushing by line, which implies it also reads by line
07:19:06 <SyntaxNinja> Michael`: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:19:15 <earthy> so the code does as asked.
07:19:18 <SyntaxNinja> that's the "Prelude" which is the stuff where you don't need to "import" anything
07:19:31 <earthy> (but yeah, this is way beyond the homework question you're being asked ;))
07:19:49 <SyntaxNinja> here's stuff about IO, scroll down to "files": http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AIO
07:20:21 * shapr bounces randomly
07:20:27 <shapr> the hills are alive!
07:20:36 <earthy> with the sound of coding... tralalalaaaaa
07:20:48 <shapr> what does coding sound like?
07:21:01 <earthy> rattling keyboards. ;)
07:22:09 <earthy> does anyone else think that whole binary file thread has gotten way out of hand?
07:22:19 <shapr> I just want a solution
07:22:32 <Michael`> Syntax: reading through it now :)
07:23:37 <Michael`> print readfile "C:/a.txt"
07:23:49 <Michael`> is that going to write the text file to the screen :p
07:24:10 <earthy> michael: yes and no. :P
07:24:14 <earthy> try it!
07:24:15 <SyntaxNinja> @type readFile
07:24:16 <lambdabot> readFile :: FilePath -> IO String
07:24:28 <earthy> @type print
07:24:29 <lambdabot> print :: forall a. (Show a) => a -> IO ()
07:25:15 <SyntaxNinja> the problem is that readFile returns an IO String, but print can't input an (IO String). it can input a String, though/
07:25:31 <SyntaxNinja> @wiki ThatAnnoyingIOType
07:25:31 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
07:25:36 <Lemmih> @type (>>)
07:25:37 <lambdabot> (>>) :: forall m b a. (Monad m) => m a -> m b -> m b
07:25:47 <SyntaxNinja> @wiki ThatAnnoyingIoType
07:25:47 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
07:25:54 <SyntaxNinja> (ignore the first link)
07:26:15 <Lemmih> @type (>>=)
07:26:17 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
07:26:42 <Michael`> ah
07:26:57 <Michael`> ok now i want to get Line 1 of a.txt
07:27:05 <Michael`> readfile isnt any good for that, is it?
07:27:23 <earthy> oh, yes it is. ;)
07:27:32 <Michael`> actually, i have no need to do this line by line, if readfile puts the whole file into one string
07:27:36 <Michael`> is that correct?
07:27:41 <earthy> bingo. :)
07:27:58 <Michael`> what if the text file is _large_
07:27:59 <Michael`> hehe
07:28:02 <earthy> we have illumination! :)
07:28:19 <earthy> well, as said, haskell is lazy: it'll only read as much as needed
07:28:31 <Michael`> yep yep i remember reading that
07:28:47 <earthy> plus, it is garbage collected, so anything that *isn't* needed anymore gets freed, e.g. when memory gets tight
07:28:49 <Michael`> well since its reading the whole file, u mean it will just read the most it can store in a string buffer
07:28:56 <Michael`> do the computations
07:29:01 <Michael`> then read more in etc
07:29:03 <Michael`> >
07:29:32 <earthy> not quite
07:29:37 <Lemmih> It's line buffered.
07:29:42 <Michael`> aha :)
07:29:43 <earthy> it will read as much as needed to do the computations
07:29:57 <earthy> so, if it needs multiple lines to do 1 computation, it will read multiple lines
07:30:06 <earthy> but no more than needed to finish the computation
07:30:07 <Michael`> So to do what i have to do
07:30:19 <Michael`> I must create a function that reads the file to a variable
07:30:25 * earthy nods
07:30:40 <Michael`> then just apply my replace function to that variable
07:30:50 <Lemmih> Michael`: The 'do' notation is quite useful for this.
07:31:18 * earthy nods
07:31:24 <earthy> then output the data in the variable
07:32:12 <Michael`> filestring = readfile "C:/a.txt"
07:32:25 <Michael`> that buffers my file into a StringIO
07:32:27 <Michael`> right?
07:32:46 <Michael`> So then i must convert filestring from IO String
07:32:47 <Michael`> to String
07:32:49 <Lemmih> That's probably not what you want.
07:33:03 <Michael`> what other possibilities are there?
07:33:30 <Lemmih> How would you 'convert' IO a to a?
07:33:40 <Michael`> i have no idea
07:33:50 <earthy> you can't, that's why
07:33:56 <Michael`> <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
07:34:07 <Lemmih> yay
07:34:30 <earthy> yeah. which says you can apply a function from e.g. a to IO b to a value in IO a
07:35:09 <Michael`> so how do i create a String which has the same contents as filestring
07:35:21 <earthy> you can't
07:35:24 <earthy> but you don't need to
07:35:50 <earthy> as you can apply a function of type String -> IO String to a variable of type IO String using (>>=)
07:36:19 <earthy> and turning a function of type  String -> String into a function of type String -> IO String is real easy
07:36:52 <earthy> \x -> return (function x)
07:37:41 <Michael`> filestring >>= return . thefilestring
07:39:45 <Michael`> thefilestring being the new String value
07:39:46 <Michael`> ?
07:40:07 <earthy> nope
07:40:17 <earthy> what would the types of filestring and thefilestring be?
07:40:22 <earthy> @type .
07:40:23 <lambdabot> bzzt
07:40:26 <earthy> @type (.)
07:40:27 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
07:41:38 <Michael`> @type print
07:41:39 <lambdabot> print :: forall a. (Show a) => a -> IO ()
07:41:57 <Michael`> filestring is type IO String
07:42:13 <Michael`> and thefilestring is meant to be of type String
07:42:14 <Michael`> hehe
07:43:20 <earthy> Michael: do read http://www.haskell.org/hawiki/ThatAnnoyingIoType
07:43:26 <earthy> and do use do-notation
07:45:22 <Michael`> main = do handle <- openFile "filename" ReadMode  -- open the file for reading
07:45:23 <Michael`>           line <- hGetLine handle                  -- get the first line out of it
07:45:23 <Michael`>           hClose handle  
07:45:34 <Michael`> ive found this, that gets the first line out of a file
07:45:36 <Michael`> yes?
07:45:39 * earthy nods
07:45:45 <earthy> that's the long way 'round
07:46:05 <Michael`> ok thats fine with me because i understand it
07:46:10 <Michael`> now, that only reads the first line
07:46:17 <Michael`> how do i make it so that reads *every* line in the file
07:46:28 <earthy> recurse. :)
07:47:42 <Michael`> yeah obviously hehe
07:47:55 <Michael`> ok let me think about this 1 :p
07:48:07 <earthy> think about local function definitions ;)
07:49:07 <Michael`> im getting an error saying last line in a do function must be an expression
07:49:39 --- mode: ChanServ set +b Smerdyakov!*@*
07:49:42 * earthy nods
07:50:05 <Igloo> left? Curious
07:50:15 <Igloo> Michael`: Is your indentation correct?
07:51:22 <Michael`> i assume so
07:51:26 <Michael`> what is the rule again?
07:52:04 <Michael`> this is how it is spaced
07:52:10 <Michael`> readafile = do handle <- openFile "filename" ReadMode  -- open the file for reading
07:52:11 <Michael`>                     str <- hGetLine handle                  -- get the first line out of it
07:52:11 <Michael`>                     hClose handle  
07:52:26 <Igloo> You have to line things up after do
07:52:33 <Michael`> with do?
07:52:42 <ibid> with handle
07:54:29 <Michael`> spaces make all the difference
07:54:32 <Michael`> yeah the indentation rule
07:55:53 <Michael`> ok, that works, now i must work out how to do the recursion
07:55:55 <Michael`> :p
07:57:33 <Michael`> maybe i should make a function called readline :)
07:58:08 <Michael`> i just dont understand how to recur with this one, since there is no sort of value that changes as u read the file
07:58:10 <Michael`> or is there?>
07:58:12 <Michael`> :S
07:58:55 <ibid> the value of the world :)
07:59:10 <earthy> there is a function that you can call to check if you've hit the end of the file...
07:59:55 <Michael`> yep
08:01:06 <shapr> hoi wouter 
08:01:08 * shapr hops
08:01:16 <wouter> hee shapr
08:01:30 <Michael`> shapr: can you shed some light on how to do recursion when reading a file?
08:01:44 * Igloo wonders if wouter went to AFP
08:01:54 <wouter> yes - that's me.
08:02:02 <Igloo> Ah, cool
08:04:58 <shapr> Michael`: look at the definition of span and break in the Prelude
08:05:20 <shapr> that's a pretty good show of using recursion to build up something useful
08:06:11 <Michael`> i understand recursion
08:06:14 <Michael`> i know how to use it
08:06:21 <Michael`> i dont understand which value changes as u read in the file
08:06:35 <Michael`> thus, i dont know how to take recursive action
08:06:37 <Michael`> :\
08:07:12 <SyntaxNinja> Michael`: you can read the entire file in one go, break it up into a list of lines, and then recurse over the lines instead of over the file.
08:07:48 <Michael`> using readFile "C:/cit.txt"
08:07:51 <Michael`> ie: 
08:08:02 <Michael`> mystring = readFile "C:/cit.txt"
08:08:19 <Michael`> mystring will be an IO String containing the entire contents of that text file
08:08:21 <Riastradh> mystring is not a string, however, Michael`.
08:08:22 <Michael`> is that correct?
08:08:25 <Riastradh> That is correct.
08:08:27 <earthy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#v%3AhIsEOF
08:08:32 <Michael`> yep i understand that now
08:08:37 <Michael`> its of type IO String
08:08:38 <Michael`> cool.
08:08:56 <Michael`> how do i read that variable line by line?
08:09:09 <SyntaxNinja> @wiki ThatAnnoyingIoType
08:09:09 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
08:09:10 <Riastradh> You need to operate with the IO monad.
08:09:41 <SyntaxNinja> Michael`: have you read through any haskell tutorials?
08:09:54 <SyntaxNinja> @wiki LearningHaskell
08:09:54 <lambdabot> http://www.haskell.org/hawiki/LearningHaskell
08:13:40 <SyntaxNinja> Michael`: I think you need to take a step back from your specific problems and try to learn the language a little more clearly.  try using this tutorial or another like it: http://www.haskell.org/tutorial/
08:13:51 <andersca> hey SyntaxNinja, what's up
08:14:33 <SyntaxNinja> hi andersca
08:15:07 <SyntaxNinja> andersca: I'm looking into various distributed file systems.
08:15:15 <shapr> oh really?
08:15:26 <shapr> have you tried SFS? GFS? what sort of distributed do you want?
08:15:40 <andersca> neat
08:16:53 <earthy> Coda?
08:17:30 <SyntaxNinja> shapr: not really; i'm just taking a survey of the field. basically trying to compare afs, coda, arla, etc.  Not finding a lot about how they compare, actually, but still googling.
08:18:12 <shapr> sfs is really spiffy, but difficult to setup outside of the debs
08:19:07 <SyntaxNinja> shapr: link?
08:20:08 <shapr> www.fs.net
08:20:15 <earthy> http://www.fs.net/sfswww/ to be more exact
08:21:32 <SyntaxNinja> eeenteresting
08:21:46 <shapr> I got sfs setup on ScannedInAvian.org, but I never figured out how to give anonymous access to it
08:21:48 <SyntaxNinja> does anyone know if there's common knowledge as to which of the distributed file systems is the best?
08:21:56 <shapr> depends on what you want it for
08:22:07 <shapr> GFS is a good cluster FS
08:22:14 <earthy> it used to be AFS, but now it's not so clear anymore
08:22:20 <shapr> SFS is a better NFS, but it's not like GFS at all
08:22:33 <SyntaxNinja> earthy: is that because other thigns are getting better, or because afs is getting worse?
08:22:52 <SyntaxNinja> note to self: if you ever create a file system, don't put screenshots on the web page.
08:22:52 <earthy> afs has grown stale, and everything else is being developed quicker
08:23:19 <shapr> I'd like to have a p2p distributed filesystem
08:23:26 <earthy> plus, AFS requires (required?) dedicated partitions
08:23:28 <shapr> so we could easily share files here on #haskell
08:23:43 <shapr> something like a chatroom where you can drop files
08:23:46 <shapr> icqfs :-)
08:23:54 <SyntaxNinja> heh
08:24:00 <earthy> gmailfs :P
08:24:05 <shapr> jabberfs!
08:24:07 <earthy> (and yes, it does exist ;))
08:24:31 * shapr thinks about darcsfs
08:24:55 <musasabi> evening
08:24:58 <shapr> hei musasabi 
08:25:24 <musasabi> hej shapr
08:25:29 <shapr> :-)
08:35:44 <Michael`> turns out i think ive been doing this problem all wrong
08:35:53 <Michael`> i think, it has to be done with pattern matching
08:36:07 <shapr> Michael`: ah, but now you understand a heck of a lot more than the rest of class does :-)
08:36:12 <earthy> ;)
08:36:17 <Michael`> yeah true that
08:36:24 <Michael`> it has been very good, i understand haskell way better now
08:36:29 <Michael`> wont deny that hee
08:36:44 <Michael`> on the other hand, i dont know pattern matching, and thats what i think i have to use hehe
08:36:56 <shapr> ah, lemme point you to my tutorial for the impatient
08:37:05 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
08:37:18 <shapr> I am very impatient, I am a binge learner.
08:37:21 <Michael`> sweet :P
08:37:33 <shapr> I want it all right there in front of me, like, gimme the pill, I don't care what color.
08:37:45 <shapr> so, I wrote a basic Haskell tutorial that works the same way.
08:38:28 <Michael`> yep im reading the section on pattern matching now
08:44:13 <Michael`> how does one use pattern matching to replace in a String
08:44:19 <Michael`> all instances of CIT with ICS
08:45:31 <shapr> do you see pattern matching work on an explicit value in the 'more pattern matching' section of that tutorial?
08:46:47 <Michael`> yeah
08:47:02 <shapr> you can use that same trick to match explicit values in a string
08:47:10 <Michael`> nah that doesnt explicitly match it kinda says if its not this value, then it must be that value
08:47:15 <Michael`> because the _ matches all 
08:47:24 <shapr> that's a wildcard
08:47:26 <Michael`> i need to explicitly match like about 15 things
08:47:36 <Michael`> i dont quite grasp how they are changed
08:47:42 <Michael`> can you explain the process?>
08:48:04 <shapr> "weather Summer = Hot"
08:48:17 <shapr> that matches only the Summer value
08:48:19 <Michael`> ics :: String -> String
08:48:20 <Michael`> ics (xs:'C':'I':'T' ]) = (xs:'I':'C':'S' ])
08:48:35 <shapr> that's pretty close to what you need
08:48:43 <shapr> the idea is exactly right, but you need to wiggle the syntax some
08:49:02 <Michael`> hehe, how so?
08:49:21 <earthy> you've just written down something that is not Haskell
08:49:38 <shapr> as in, I think you can only match literal values before the xs
08:49:51 <shapr> and you need to get rid of those extra ] chars
08:50:04 <Michael`> ics (xs:'C':'I':'T':]) = (xs:'I':'C':'S':])
08:50:06 <Michael`> ?
08:50:30 <earthy> more like  ics ("CIT":xs) = "ICS":xs
08:51:22 <earthy> (but that's invalid on purpose)
08:51:26 <Michael`> jeje
08:51:38 * Michael` pulls out his remaining hairs in his head
08:51:46 <earthy> ;)
08:51:52 <shapr> Michael`: now you can release more brain heat!
08:52:03 <Michael`> im going to explode
08:52:20 <earthy> nah, you're not
08:52:30 * shapr pours water on Michael`s now-bald head.
08:52:59 <Michael`> hehe
08:54:41 <shapr> Michael`: you're making steady progress
08:54:45 <shapr> keep it up!
08:54:54 <shapr> I think I'm going off for a bit more unicycling.
08:56:52 <Michael`> im finished :\
08:56:56 <shapr> you got it?
08:57:00 <Michael`> nah i mean im gone
08:57:04 <Michael`> im never going to get it
08:57:09 <shapr> nah, you'll get it
08:57:11 <Michael`> it will be too late by the time i can understand it
08:57:15 <shapr> you're making great progress
08:57:29 <earthy> nah
08:57:52 <shapr> I get frustrated when I'm learning new stuff, I just take a break and come back to it later.
08:57:53 <earthy> if you look at it again tomorrow it'll suddenly make a shitload more sense
08:57:57 <shapr> right, exactly
09:07:55 <Michael`> i have a quick question
09:08:02 <Michael`> using the replace function i created
09:08:31 <Michael`> is there any way to replace any number between 1101 and 1198?
09:08:43 <Michael`> with the number that is 1 greater than it (increment)
09:13:12 <musasabi> yes.
09:13:51 <musasabi> f x = if x > 1101 && x < 1198 then x+1 else x
09:14:13 <Michael`> ok heres my problem
09:14:22 <Michael`> the number itself will be part of a String
09:14:23 <Michael`> hehe
09:14:25 <Michael`> :|
09:15:15 <anduril1> is your input structured at all?
09:15:23 <Michael`> i was thinking u could write a function that replaces every value between 1101 and 1198 with the incremented value
09:15:28 <Michael`> Ive created a function called replace
09:15:30 <Michael`> works like this
09:15:40 <anduril1> a list of integers perhaps?
09:15:44 <Michael`> replace "The sentence" "The" "A"
09:15:49 <Michael`> that returns "A Sentence"
09:17:23 <Lemmih> 'returns' is such a nasty word.
09:17:52 <Michael`> yeah
09:18:22 <Michael`> perhaps pattern matching is the best way
09:18:40 <Michael`> @help pattern matching
09:18:41 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
09:18:47 <Michael`> @listcommands
09:18:47 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
09:18:47 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
09:18:47 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
09:18:47 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
09:18:47 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
09:18:48 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
09:18:50 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
09:18:52 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
09:18:54 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
09:22:42 <Michael`> can anyone help me to discover how to pattern match with strings?
09:24:13 <Lemmih> Sure.
09:24:58 <Lemmih> Know about lists?
09:27:08 <Michael`> yep
09:27:18 <Michael`> ["hello","bob"]
09:27:20 <Michael`> is that a list?
09:28:02 <Lemmih> Yep.
09:28:04 <musasabi> Michael`: it is a list of String.
09:28:14 <Michael`> yep ok
09:28:15 <musasabi> [String] (now String is [Char] too)
09:28:20 <Lemmih> And a string is just a list of Chars.
09:28:24 <Michael`> a String is a list of Chars
09:28:27 <Michael`> yep yep
09:28:52 <Michael`> ics :: String -> String
09:28:52 <Michael`> ics (xs:'C':'I':'T':[]) = (xs:'I':'C':'S':[])
09:28:57 <Michael`> that is meant to replace CIT with ICS
09:29:01 <Michael`> but i get an error stating
09:29:15 <Michael`> Non exuastive patterns in function ICS
09:29:19 <Michael`> this is wher ei have become stuck
09:29:51 <Lemmih> Michael`: What argument did you pass to it?
09:30:07 <Lemmih> And what do you think the type of 'xs' is?
09:30:26 <Lemmih> @type (:)
09:30:27 <lambdabot> (:) :: forall a. a -> [a] -> [a]
09:30:56 <Michael`> i am unsure what xs is at the stage
09:31:10 <Michael`> @type xs
09:31:11 <lambdabot> bzzt
09:31:14 <Michael`> hehe
09:31:22 <Michael`> type xs:
09:31:28 <Michael`> @type xs:
09:31:29 <lambdabot> bzzt
09:31:32 <Michael`> grr
09:31:40 <Lemmih> Don't be foolish.
09:32:20 <Michael`> what type is xs?
09:32:55 <Lemmih> It's a Char.
09:34:51 <Lemmih> Do you understand why I know it's a Char?
09:35:26 <vinodh> So, which implementation of Haskell are you using?
09:35:53 <Michael`> 98 i believe
09:36:09 <Michael`> ok so why do i get the error then?
09:36:14 <Riastradh> That is a version of the language standard, Michael`.
09:36:14 <Michael`> 'C' is a Char
09:36:27 <Michael`> and so is xs
09:36:35 <Lemmih> Michael`: What argument did you pass to 'ics'?
09:36:57 <vinodh> It's just that I'm looking at the implementations page at haskell.org - I'm not too sure which one is widely used.
09:37:23 <Igloo> I use hugs for quick things, ghc for more serious stuff
09:37:26 <Riastradh> GHC is probably the most popular.
09:37:30 <Michael`> im using ghc
09:37:31 <musasabi> vinodh: ghc is quite nice.
09:37:36 <Michael`> i passed this argument
09:37:48 <Michael`> ics (xs:'C':'I':'T':[]) = (xs:'I':'C':'S':[])
09:37:51 <Michael`> im getting a compile
09:37:52 <Michael`> error
09:37:53 <vinodh> Oh, then I guess that's what I'll try : GHC. Thanks.
09:38:03 <Michael`> GHCi i should sa
09:38:04 <Michael`> say*
09:38:06 <musasabi> /c/c
09:38:17 <Lemmih> Michael`: You should only get a warning.
09:38:52 <Lemmih> You shouldn't even get that...
09:40:11 <Lemmih> Michael`: `ics "HCIT"` evaluates to "HICS".
09:40:57 <Michael`> Non Exhuastive errors
09:41:06 <Michael`> Non Exhuastive patterns rather :|
09:42:17 <Lemmih> That's a runtime error.
09:43:19 <Lemmih> Renaming 'xs' to just 'x' would probably make more sense in your eyes.
09:44:01 <Michael`> aha
09:45:34 <Michael`> ics :: String -> String
09:45:34 <Michael`> ics (x:'C':'I':'T':[]) = (x:'I':'C':'S':[])
09:45:42 <Michael`> interprets ok
09:45:44 <Michael`> gives me this error
09:46:03 <Michael`> Non-Exhaustive patterns in function ics
09:46:10 <Lemmih> Yes.
09:46:33 <Michael`> this happens why?
09:46:34 <Lemmih> What are you trying to match with (x:'C':'I':'T':[])?
09:46:52 <Michael`> umm "CIT aaa" for instance?
09:47:18 <Lemmih> And how would you write that as a list of Chars?
09:47:30 <Michael`> well a String is a list of Chars
09:47:35 <Michael`> so like i jsut did :S
09:48:01 <Lemmih> You know that "aa" == ('a':'a':[]), right?
09:48:19 <Michael`> yeah i do now hehe
09:49:38 <Lemmih> So you believe that ('C':'I':'T':" aaa") can match (x:'C':'I':'T':[])?
09:50:06 <Michael`> gives me same error when i do that
09:50:06 <Michael`> ics ('a':'a':[]) gives me a Non-Exhaustive patterns in function ics error
09:50:16 <Lemmih> Yes.
09:50:56 <Lemmih> Try: ics "XCIT"
09:51:03 <Michael`> ok
09:51:14 <Michael`> it worked hehe
09:51:24 <Lemmih> Do you understand why it worked?
09:51:31 <Michael`> not 100%
09:52:11 <Michael`> ah actually
09:52:23 <Michael`> is it because CIT is at the very end of the String/list of Chars
09:52:24 <Michael`> ?
09:52:54 <Michael`> ah i know why, your pattern matching against 4 characters
09:52:56 <Michael`> hahaha :p
09:54:08 <Michael`> nope
09:54:15 <Michael`> i wonder why then, i am not sure
09:55:32 <Michael`> aha, i am understanding now
09:55:40 <Lemmih> Two patterns don't match if they aren't equal and "CIT" is _not_ the same things as (x:"CIT").
09:55:42 <Michael`> its gotta be a 4 character pattern
09:55:52 <Michael`> with a variable character at the start
09:55:56 <Michael`> thats x
09:56:14 <Michael`> so im trying to change anything that is xCIT to xICS
09:56:35 <Michael`> so if i wanted to change subject codes from 1105CIT to 1105ICS id do this
09:56:36 <Lemmih> Exactly.
09:57:12 <Michael`> ics (x:x:x:x:'C':'I':'T':[]) = (x:x:x:x:'I':'C':'S':[])
09:57:15 <Michael`> will that work?
09:57:24 <Michael`> or do those variables need to be different
09:58:32 <Michael`> ill make them wxyz
09:58:33 <Michael`> :
09:58:34 <Michael`> :p
09:58:50 <Lemmih> That will result in a conflicting definition of 'x'.
09:59:17 <Michael`> it sure did
09:59:19 <Michael`> i got it, thanks man
09:59:26 <Michael`> now i understand patternmatching :p
09:59:31 <Michael`> quick question
09:59:31 <vinodh> So which was your favorite Haskell textbook? Or tutorial?
09:59:41 <Michael`> ah ive just been using my lecture notes
09:59:42 <Michael`> hehe
09:59:50 <Michael`> ics :: String -> String
09:59:50 <Michael`> ics (w:x:y:z:'C':'I':'T':[]) = (w:x:y:z:'I':'C':'S':[])
10:00:01 <Michael`> ok, now i used that then as 
10:00:06 <Michael`> ics "1105CIT"
10:00:20 <vinodh> M: You're using this for a class?  Is it the only functional language you've been exposed to?
10:00:24 <Michael`> what if i wanted to increment the 5 by 1?
10:00:28 <Michael`> how is that possible?
10:00:40 <Michael`> it is yes :)
10:01:07 <Michael`> because in that function all those variables are of type Char
10:01:15 <Michael`> how can i increment a Char
10:01:16 <Michael`> :P
10:01:21 <vinodh> Wow, where do you go to school?  I've only heard of schools using Scheme.
10:02:16 <Lemmih> @type chr
10:02:18 <lambdabot> bzzt
10:02:23 <Lemmih> @index chr
10:02:23 <lambdabot> Data.Char,GHC.Base,Char
10:02:29 <Lemmih> @type Data.Char.chr
10:02:30 <lambdabot> Data.Char.chr :: Int -> Char
10:02:33 <Lemmih> @type Data.Char.ord
10:02:35 <lambdabot> Data.Char.ord :: Char -> Int
10:03:33 <Lemmih> @type (chr . (1+) . ord)
10:03:34 <lambdabot> bzzt
10:04:06 <vinodh> @type length [1,2,3]
10:04:07 <lambdabot> length [1,2,3] :: Int
10:04:16 <Lemmih> @eval (chr . (1+) . ord) 'a'
10:04:17 <lambdabot> (line 1, column 11):
10:04:17 <lambdabot> unexpected ")"
10:04:17 <lambdabot> expecting "+", white space or simple term
10:04:37 <vinodh> @eval (length [1,2,3])
10:04:37 <lambdabot> 3
10:06:59 <vinodh> @eval( 5 )
10:06:59 <lambdabot> Sorry, I don't know the command "eval(", try "lambdabot: @listcommands"
10:07:08 <vinodh> @eval (5)
10:07:08 <lambdabot> 5
10:07:28 <Michael`> hmmm
10:07:42 <vinodh> @listcommands
10:07:43 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
10:07:43 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
10:07:43 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
10:07:43 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
10:07:43 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
10:07:43 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
10:07:45 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
10:07:47 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
10:07:49 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
10:09:34 <Lemmih> Michael`: Keeping such information as a String is not very flexible.
10:10:40 <Michael`> agreed
10:12:16 <Michael`> i still dont understand how i can increment the value of a Char hehe
10:12:47 <Lemmih> You don't want to.
10:13:23 <Lemmih> I think you wanna store it as an integer.
10:14:59 <Michael`> i have to return it as a string
10:16:08 <Lemmih> @type show
10:16:10 <lambdabot> show :: forall a. (Show a) => a -> String
10:16:17 <Lemmih> @eval show 100
10:16:18 <lambdabot> unbound variable: show
10:16:26 <Lemmih> @eval (show 100)
10:16:26 <lambdabot> unbound variable: show
10:17:09 <Lemmih> You can always convert it to a string later.
10:24:09 <Michael`> i need char to int
10:24:10 <Michael`> hehe
10:25:26 <Lemmih> Check chr and ord
10:26:17 <Lemmih> But it'll be buggy and ugly!
10:32:07 <Michael`> i got it
10:32:08 <Michael`> :)
10:32:12 <shapr> yay
10:32:33 <Michael`> hehe :p
10:32:40 <Michael`> yeah im so almost there, u were right 
10:32:45 <Michael`> now i understand pattern matching hehe :p
10:32:46 * shapr cheers
10:35:07 <Michael`> I got 1 last question shapr
10:35:20 <Michael`> I want to write a function called makeChanges
10:35:35 <Michael`> and all the pattern matching functions i wrote go inside
10:35:38 <Michael`> do i use the do command?
10:36:05 <shapr> you don't need to use the do command unless you're doing monadic stuff
10:37:50 <Michael`> so how do i get all of my different functions to be processed
10:37:57 <shapr> put 'em in a pipeline
10:38:01 <Michael`> hehe :p
10:38:05 <shapr> seriously
10:38:08 <Michael`> what on earht is a pipeline
10:38:09 <Michael`> :p
10:38:17 <Michael`> you mean like
10:38:22 <shapr> you've figured out that Haskell functions don't have side-effects, right?
10:38:25 <Michael`> a(b(c(d(e(f())))))
10:38:27 <Michael`> or something?
10:38:49 <shapr> yah, pretty much that
10:38:52 <shapr> but there's an easier way in Haskell
10:38:53 <Michael`> thats messy as!
10:39:17 <shapr> right, and Haskell is clean
10:39:28 <shapr> have you seen the . operator?
10:40:35 <maeglin> hello
10:40:44 <shapr> hiya maeglin 
10:41:07 <maeglin> i'm a haskell newbie using hugs. i don't know how to evaluate expressions like defining functions on the fly in hugs.
10:41:19 <shapr> I don't think you can do that in hugs
10:41:23 <shapr> but you can do it in GHCi
10:41:27 <Michael`> nope
10:41:30 <Michael`> what does the . operator do
10:41:33 <Michael`> actually let me look :D
10:41:39 <shapr> Michael`: nice save ;-)
10:41:49 <Michael`> function composition
10:42:28 <Michael`> ok is funca . funcb . funcc
10:42:28 <Michael`> ?
10:42:31 <Michael`> that right?
10:42:39 <shapr> if the order is right, yes
10:42:47 <shapr> maeglin: can you install GHC?
10:42:58 <maeglin> shapr: yes, i already did
10:42:59 <Michael`> is that calling them seperately or one after the other
10:43:09 <Michael`> as in funca(funcb(funcc()))
10:43:11 <maeglin> shapr: but ghci gives similar error messages like hugs
10:43:26 <maeglin> shapr: square :: Int -> Int  results in "square: not in scope"
10:44:10 <shapr> maeglin: let square x = x * x
10:44:46 <shapr> hm, you can stick a type sig into that too, but I forget how
10:45:01 <maeglin> ok, that works, thanks
10:45:09 <maeglin> that's very similar to sml too
10:45:24 <maeglin> but why do all those tutorials say to define a sig first and then define the function ?
10:45:40 <shapr> because they expect you to do that in a file.
10:45:48 <shapr> the sig isn't so important 99% of the time
10:46:00 <shapr> for example, check the type of that square you just defined
10:46:03 <shapr> :t square
10:46:06 <maeglin> oh i see, but doesn't have haskell automatic type inference ?
10:46:11 <shapr> yes it does
10:46:25 <shapr> but most C and Java programmers flip out when there's no type sig in a statically typed lang
10:46:54 <maeglin> oh, but i really think you do not need type sigs when your language supports type inference :-)
10:47:05 <shapr> well, occasionally they're handy
10:47:19 <maeglin> what for?
10:47:30 <shapr> for me, most often when I think some code may not work exactly as I think it does
10:47:32 <maeglin> i have never felt need for them in ocaml
10:47:38 <shapr> then I add a type sig to check my resoning
10:47:40 <shapr> reasoning
10:48:02 <shapr> also, there's lots of tricks to encode information in types
10:48:18 <shapr> and in those cases, you can sometimes dramatically change the behaviour of a function just by changing the type sig, not the code.
10:48:37 <shapr> Haskell's type system is really spiffy (though not as cool as epigram's)
10:50:41 <markus``> so.. what is haskell used for?
10:50:53 <shapr> lambdabot!
10:50:53 <markus``> nothing, but its mathematically correct right?
10:50:54 <shapr> @yow
10:50:55 <maeglin> discussions about type systems can be religous wars
10:50:55 <lambdabot> Hydraulic pizza oven!!  Guided missile!  Herring sandwich!  Styrofoam!
10:50:55 <lambdabot>  Jayne Mansfield!  Aluminum siding!  Borax!  Pedal pushers!  Jukebox!
10:51:05 <shapr> markus``: hey you look familiar.
10:51:10 <markus``> :)
10:51:15 <shapr> I know you!
10:51:33 <markus``> well im just letters dude :O
10:51:50 <shapr> haven't I seen you on #chalmers?
10:52:15 <markus``> i guess you are misstaking me for r3tex right?
10:52:26 <markus``> men ja, jag gr chalmers :)
10:52:32 <shapr> jas!
10:52:46 <markus``> ja!!
10:52:50 <markus``> :)
10:53:07 <shapr> well, I wrote a bayesian email spam filter in Haskell in a few evenings and 200 lines of code
10:53:13 <shapr> never got better than 85% though
10:53:22 <shapr> I wrote a mailing list search webapp
10:53:50 <markus``> well, thats always something :D
10:54:04 <shapr> my website is done with Haskell
10:54:17 <markus``> serious?
10:54:19 <shapr> yes
10:54:19 <markus``> url?
10:54:30 <shapr> http://www.ScannedInAvian.org/
10:54:40 <shapr> I've used two blog systems written in Haskell
10:55:01 <shapr> there's a really awesome database binding for Haskell
10:55:25 <markus``> vrsta leet
10:55:29 <markus``> ;)
10:55:54 <shapr> I still haven't filled in the swedish side of that
10:56:35 <markus``> what year are you studying at chalmers right now?
10:56:54 <shapr> entrance requirements ;-)
10:57:18 <shapr> my only experience with Chalmers so far has been EuroPython and EuroHaskell
10:57:39 <shapr> well, and swapping emails about Haskell (and unicycling) with a bunch of the people there
10:57:46 <markus``> hehe
10:57:56 <markus``> well haskell seems weird now, but im sure ill like it later on :)
10:57:59 <shapr> I'd like to go to Chalmers, would be nice.
10:58:04 <shapr> Haskell is way nifty.
10:58:07 <shapr> powerful and elegant
10:58:15 <shapr> oh, you want to see my tutorial for the impatient?
10:58:22 <markus``> why not!
10:58:25 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
10:59:45 <markus``> omg i know the first page :)
10:59:47 <shapr> oh, I got paid to do Haskell once so far.
11:00:28 <shapr> german university wanted a bunch of ms.doc files in a custom xml flavor, so I batched 'em through OpenOffice and then use HXmlToolbox to convert from openoffice xml save format into the custom flavor.
11:01:00 <shapr> three days of coding to do a better job than the guy who spent a month writing XSLT, Java, and JavaScript for his converter.
11:01:21 <markus``> haha, sound like fun :)
11:01:59 <markus``> gn!
11:02:00 <shapr> and my Haskell code ended up being very short, compared to mountains of this other stuff.
11:02:05 <shapr> bye!
11:20:40 <maeglin> hm, what's the difference between foo x = x*x and let foo x = x*x  .. i guess there's none, right ?
11:20:54 <shapr> well
11:21:00 <shapr> one is top level
11:21:48 <maeglin> ok
11:22:03 <shapr> that can be important for typing and binding reasons
11:28:33 <scrm> hi lemmih
11:28:35 <scrm> :)
11:31:03 <shapr> greetings scrm 
11:31:50 <scrm> hey shapr! lemmih seems afk, well i gtg too, xchat will stay on :)
11:32:15 <scrm> lemmih wanted me to start learning haskell, and now im ready :)
11:32:25 <Lemmih> Hey scrm (-:
11:33:23 <shapr> wow, I suddenly feel gekipt
11:33:28 <shapr> dang, how do spell that?
11:34:03 <shapr> scrm: excuse me, would you happen to know how to spell the german word 'gekipt' that means 'leaned over' ?
11:36:30 <Michael`> hey shapr
11:36:41 <shapr> HI Michael`!
11:36:46 <Michael`> inccoursecode ('1':'1':'x':'y':[]) = ('1':'1':inc(x):inc(y):[])
11:36:56 <Michael`> i need to apply that to every word in a large long string
11:37:02 <Michael`> i am lost
11:37:04 <Michael`> hehe
11:37:35 <scrm> gekippt :)
11:37:39 <shapr> ah, thanks
11:37:44 <scrm> shapr swe?
11:37:52 <shapr> Alabamian
11:38:55 <Michael`> shapr: ?
11:39:03 <shapr> um
11:39:18 <shapr> map inccoursecode $ words string
11:39:18 <Lemmih> Michael`: inc(x) is kinda funny.
11:39:22 <shapr> yah?
11:39:46 <Lemmih> Michael`: This is like math. inc x will do the trick.
11:39:54 <Michael`> how does $
11:39:55 <Michael`> work
11:40:01 <Michael`> Lemmih: not if its a Char it wont
11:40:15 <Lemmih> Oh yes it will.
11:40:23 <Michael`> i asked u that so many times earlier
11:40:43 <Michael`> anyhow matters not
11:40:45 <Lemmih> Shouldn't (:) be binding weaker than a function?
11:41:03 <Riastradh> Every operator binds more weakly than function applications.
11:41:39 <Michael`> i dont understand how the map inccoursecode $ words string
11:41:40 <Michael`> works
11:42:24 <Riastradh> Michael`, I suggest that you take Smerdyakov's advice from last night.  You can't learn Haskell in a few hours for a class deadline.
11:42:38 <Michael`> Rias: i have to
11:42:45 <Michael`> so ill make the exception ok?
11:42:56 <Riastradh> It doesn't matter.  You can't.
11:42:59 <Michael`> i can :)
11:43:18 <Riastradh> You can copy & paste code snippets all you want; it doesn't amount to any understanding of Haskell.
11:43:22 <Michael`> I can get this assignment done
11:43:26 <Michael`> and thats my aim
11:43:28 <Michael`> capish?
11:43:33 <Riastradh> You don't care about learning Haskell?
11:43:48 <Michael`> at this point handing it in so i can *continue* to learn haskell
11:43:52 <Michael`> is more important
11:43:57 <Michael`> i didnt create the system
11:43:58 <Michael`> :)
11:47:17 <Riastradh> If you have not learned a sufficient understanding of Haskell from the class so far, either the class is at fault, in which case you should complain to the professor, or you are at fault, in which case we can't help you very much; I don't know which it is -- and I don't want to insinuate anything against you without knowing you very well --, but in either case there is not much help to be gained here.
11:49:34 <scrm> lemmih: why dont you join ypn?`
11:53:37 <Lemmih> scrm: I got stuck in a discussing about capitalism vs. socialism when I actually only wanted to tell Robert why I was down.
11:53:45 <scrm> lool
11:53:55 <scrm> just before you joined #ypn there was the same
11:55:16 <Michael`> how do i split up a string word by word, i am assuming it is a bit like this
11:55:39 <Lemmih> @type words
11:55:40 <lambdabot> words :: String -> [String]
11:56:15 <Michael`> ok :)
12:09:46 <Michael`> this is the most frustrating experience of my life
12:11:22 <Michael`> makeChanges (x:xs) = ((inccoursecode x): makeChanges xs)
12:11:31 <Michael`> that gives me a parse error
12:11:36 <Michael`> i cannot understand why
12:12:19 <SyntaxNinja> are you typing it directly into the interpreter?
12:14:26 <SyntaxNinja> Michael`: how many hours until you have to turn in your assignment?
12:19:46 <Michael`> only about 4
12:20:08 <Michael`> 6:20am
12:20:11 <Michael`> i started this at 3pm
12:20:13 <Michael`> :\
12:20:29 <Michael`> and its a fuckn question someone could write in 4minutes
12:20:31 <Michael`> :(
12:20:49 <Riastradh> Michael`, just writing down some code is not the point.
12:21:09 <Riastradh> There are a lot of deep & important semantics here to consider, and a snippet of code won't convey them.
12:22:32 <SyntaxNinja> Michael`: I don't know if we can help you to score well on your homework.  I think we can help you learn haskell, but it'll take a little bit of time, and you'll have to start trusting us about the best approach.
12:22:55 <Michael`> indeed
12:23:07 <Michael`> i dont disagree
12:23:15 <Riastradh> And the 'best approach' is not to cram in some Haskell syntax at the last minute.
12:23:40 <Michael`> i realise
12:23:47 <Michael`> it is the only one however.
12:23:51 <Michael`> foor me at this point in time.
12:26:16 <Riastradh> If the professor is demanding what hasn't been taught at all, it is unreasonable for the professor to expect students to hand in good code.
12:32:36 <Michael`> its mainly my fault for not making classes
12:32:46 <Michael`> due to me working nightshifts, to pay for the classes
12:32:47 <Michael`> ok?
12:32:52 <Michael`> so its a bad situation for me.
12:32:57 <Michael`> but one that i have to deal with
12:33:05 <Michael`> having someone tell me how it is doestn ease things for me
12:33:07 <Michael`> ok?
12:36:20 <ibid> that explains it a little
12:36:41 <ibid> but it also makes it a little worse that you ask for the easy way out here
12:37:28 <Riastradh> Of what use are the classes if you can't take many of them?
12:41:40 <SyntaxNinja> Michael`: how can we possibly help you?  I don't think you're asking us to help you cheat, but if you are, no one here is going to.
12:42:29 <SyntaxNinja> If I were you, I would ask for an extension of a couple of days, learn the language properly, and turn in a good piece of code.
13:58:13 <shapr> d00d
13:58:30 <andersca> yo shae
13:59:16 <shapr> y0 y0
13:59:17 <shapr> wassup?
13:59:28 <andersca> not much
14:01:48 <shapr> whoa...
14:01:52 <shapr> (*) We have prototyped our own secure middleware, which had an elegant, 
14:01:52 <shapr> powerful, class-based RPC for Haskell processes, but we haven't really used 
14:01:52 <shapr> that in other projects.
14:01:57 <shapr> man
14:02:05 <shapr> I want that!
14:02:27 <shapr> man oh man
15:30:43 <blackdog> top-of-the-far-too-nice-to-be-inside-sysadminning-morning to you all
15:43:46 <stepcut> mornin'
16:21:06 <wagle> almost time to go home..
16:21:46 <irsirius_> can someone tell men whats wrong with this?
16:22:01 <irsirius_> depthTree :: GTree a -> Int
16:22:01 <irsirius_> depthTree (Leaf a)					= 1
16:22:01 <irsirius_> depthTree (Gnode [a])				= 1 + max (depthTree [a])
16:25:11 <arjanb> you may need the function map
16:26:16 <irsirius_> yes i tried this before
16:26:47 <irsirius_> depthTree :: GTree a -> Int
16:26:47 <irsirius_> depthTree (Leaf a)					= 1
16:26:47 <irsirius_> depthTree (Gnode [a])				= 1 + max (map depthTree [a])
16:27:08 <irsirius_> *** Term           : depthTree
16:27:08 <irsirius_> *** Type           : GTree a -> [Int] -> [Int]
16:27:08 <irsirius_> *** Does not match : GTree a -> Int
16:27:56 <arjanb> map (depthTree) [a]
16:30:36 <shrimpx> you probly want maximum instead of max
16:31:33 <arjanb> @type maximum
16:31:34 <lambdabot> maximum :: forall a. (Ord a) => [a] -> a
16:32:08 <irsirius_> thats it!
16:32:25 <irsirius_> thank you
16:33:13 <irsirius_> @t sum
16:33:14 <lambdabot> Sorry, I don't know the command "t", try "lambdabot: @listcommands"
16:33:37 <irsirius_> @listcommands
16:33:37 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
16:33:37 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
16:33:37 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
16:33:37 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
16:33:37 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
16:33:38 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
16:33:40 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
16:33:42 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
16:33:44 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
16:34:07 <irsirius_> @type sum
16:34:09 <lambdabot> sum :: forall a. (Num a) => [a] -> a
16:35:19 <dan2> @info sum
16:35:20 <lambdabot> -- sum is a variable
16:35:20 <lambdabot> sum :: forall a. (Num a) => [a] -> a
16:35:53 <irsirius_> may i user patterns in that kind of definitions too?
16:36:12 <shrimpx> hm
16:36:13 <irsirius_> like GNode [x:xs] ?
16:36:15 <shrimpx> @shapr
16:36:15 <lambdabot> needs sleep
16:36:18 <shrimpx> heh
16:36:48 <shrimpx> irsirius_: i dunno what you mean
16:38:35 <irsirius_> fun (GNode [x:xs]) = f1 x + map f2 xs
16:38:47 <irsirius_> s.th. like that
16:41:48 <shrimpx> if the param to gnode is a list of lists, you just do fun (GNode (x:xs)) = ...
16:42:59 <shrimpx> and at that point you can nest the pattern on x, since it's a list. GNode ((y:ys):xs) = ...
16:45:13 <shrimpx> but maybe i totally misread :)
16:45:25 <irsirius_> i only used the wrong type of brackets. thats why it didnt work
16:45:32 <shrimpx> ah ok
16:45:43 <irsirius_> [] instead of ()
16:50:06 <tnks> hello
16:50:25 <tnks> I'm trying to write a Haskell parser (probably a common task for a lot of you)
16:50:52 <tnks> My experience with parsers in Haskell is mostly with an old ParseLib library in Hugs.
16:51:11 <tnks> I'm on GHC now, and I noticed that it has quite a few more options for parsing.
16:51:24 <tnks> Is ReadP a good place to start?
16:52:13 <Cale> tnks: I like Parsec quite a lot
16:52:33 <Cale> a parser in Haskell, or a parser for Haskell code?
16:52:36 <tnks> I don't think Parsec has (+++) defined.
16:53:06 <tnks> a parser in Haskell (for a text "config" file)
16:53:54 <tnks> it's weird, because in ParseLib, I was used to using (many) as well as  (+++)
16:54:35 <tnks> but I'm having a problem integrating the two with GHC libraries
16:55:48 <Cale> Well, Parsec has (<|>) which is not symmetric, but is usually good enough, and for permutation phrases, there are <||> and <$$>
16:58:28 <Cale> your grammar must be at worst LL(inf)
17:01:12 <tnks> crazy. . . I glossed over those. . . 
17:01:22 <tnks> I need to read more carefully.
17:01:31 <tnks> let me do that real quick.
17:03:34 <tnks> you know what got me.
17:03:58 <tnks> I think ReadP is just better commented in that it has a one-liner explaining the function in English.
17:04:34 <tnks> sometimes, I just don't trust myself to completely figure everything out from a function name and it's type definition. . . 
17:05:01 <tnks> so. . . let's replace all my (+++)'s with (<|>)'s and see what happens.
17:06:37 <Cale> tnks: Parsec's documentation is separate
17:06:45 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
17:08:23 <tnks> Cale: that's new to me, how did you find that site?
17:08:30 <Cale> google
17:08:32 <Cale> :)
17:08:33 <tnks> ah.
17:09:03 <Cale> Parsec was around before it was in GHC, too. That was the original location for the docs.
17:10:20 <tnks> Cale: Thanks a lot. . . I was close to errorless compilation. . . but you got me there in no time flat.
17:10:26 <Cale> :)
17:10:38 <tnks> (no I just have to run my test cases). . . 
17:11:59 <eckroth> I have a total-beginner question: in Hugs, I try loading my file (can paste relevant part if you want), and it tells me: ERROR "mod-euc.hs":4 - Instance of RealFrac Int required for definition of modEucGcd
17:12:06 <eckroth> What does this mean?
17:12:24 <eckroth> it's referring to "floor (a/b)"
17:12:35 <eckroth> a, b are Int
17:14:48 <Igloo> You want a `div` b
17:14:52 <Igloo> @type (/)
17:14:53 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
17:15:00 <Igloo> Int is not a member of Fractional
17:15:28 <eckroth> ah
17:20:02 <eckroth> oh, so div replaces the floor too :)
17:20:08 <eckroth> that makes sense
17:22:22 <Leimy> is there an arbitrary precsion "float" for haskell?
17:26:09 <Igloo> There's Rational
17:28:56 <shammah> And you were only going to be able to approximate the transidentals anyway so that should be sufficient :)
17:29:43 <Leimy> doh
20:00:15 <Michael`> hey all
20:00:36 <Michael`> Using pattern matching, how do i update an entire sentence using this function
20:01:47 <Michael`> inccoursecode ('1':'1':x:y:[]) = ('1':'1':inc(x):'0':[])
20:06:15 <Michael`> anyone?
20:07:19 <anduril1> what do you mean by entire sentence?
20:08:36 <Michael`> for example
20:08:42 <Michael`> I need to replace all codes like this
20:08:45 <Michael`> 1134
20:09:04 <Michael`> into 1145
20:09:13 <Michael`> in the given string
20:09:25 <Michael`> incrememnt the last 2 digits of the code
20:09:36 <Michael`> inccoursecode ('1':'1':x:y:[]) = ('1':'1':inc(x):inc(y):[])
20:09:46 <Michael`> i am stuck as to how to do this
20:12:58 <Michael`> ?
20:13:05 <anduril1> your pattern only matches strings that look like "11xx" right now, right?
20:13:11 <Michael`> yep thats correct
20:13:21 <anduril1> because at the end of the pattern you have []
20:13:48 <Michael`> ok what does having that at the end mean?
20:14:26 <anduril1> that means its the end of a list
20:14:33 <Michael`> aha
20:14:44 <Michael`> ok i want this then dont i
20:15:03 <Michael`> inccoursecode ('1':'1':x:y) = ('1':'1':inc(x):inc(y))
20:15:06 <Michael`> for starters
