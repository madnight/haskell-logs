00:00:32 <shrimpx> i saw one lisp submission that had a pretty hardcore ant -- and they had used GA stuff
00:07:41 <xkb> were there any haskell submissions?
00:07:46 <xkb> I guess so ;-)
00:09:47 <shrimpx> heh
00:10:06 <shrimpx> wasn't there a #haskell submission?
00:10:27 <xkb> Im always curious to the src of such submissions
00:20:23 <xkb> hmm im having an odd problem.. I guess Im overlooking something
00:20:31 <xkb> I have this very simple quicksort
00:20:36 <xkb> x is a 3triple
00:20:48 <xkb> ecor selects the third element of the triple
00:20:54 <xkb>      17 qSortOnY (x:xs) = qSortOnY [ z | z<-xs, ecor z <= ecor x] ++ [x] ++ [z | z<-xs, ecor z> ecor x]$
00:21:07 <xkb> the problem is: this doesnt sort on ecor :?
00:21:42 <xkb> snippet from output:
00:21:54 <xkb> (14,3,25),(19,18,22),(23,13,29)
00:22:13 <xkb> hmm.. that should not be possible as 25>22<29
00:25:45 <xkb> Any clues?
00:28:21 <ibid> you don't recurse on the top half
00:28:38 <xkb> ahh
00:28:40 <xkb> darn
00:29:20 <xkb> hmm that was kinda ehh.. stupid
00:42:59 <TheDark12> hello all
00:52:36 <TheDark12> hey people
00:52:39 <TheDark12> i need some help
00:52:48 <TheDark12> i wanna start learning haskell and i dont know where to look
00:52:49 <TheDark12> ...
00:54:55 <stefan_> TheDark12: http://haskell.org/learning.html
00:55:17 <TheDark12> thanks allot mate!
00:56:30 <stefan_> TheDark12: and if you have any specific questions regarding the language or the libs, don't hesitate and ask them here ...
00:58:00 <TheDark12> yeah, i dont know what libs are yet, but thanks anyways
00:58:39 <stefan_> I meant 'libraries' ;)
00:59:37 <TheDark12> yeah i dont know what libraries are lol
00:59:48 <TheDark12> <<< noob beyond noobyness
01:05:00 <musasabi> morning
01:05:37 <musasabi> Did the binary-io/locale discussion on -cafe have any real results?
01:45:42 <xkb> If you have a main function, that has some sort of "showable" datastructure as output,what type should main have?
01:45:50 <xkb> for ghc to compile it to an executable
01:45:56 <ibid> IO ()
01:46:02 <ski> :)
01:46:06 <ibid> i assume
01:46:22 <ski> main always has IO type
01:46:23 <xkb> hmm
01:46:39 <ski> if you want to print something, you can do
01:46:44 <ski> main = print something
01:46:50 <xkb> ok
01:46:57 <ibid> (of course you have to define something first :)
01:47:01 <ski> @type print
01:47:02 <lambdabot> print :: forall a. (Show a) => a -> IO ()
01:47:18 <xkb> cool
01:47:25 <xkb> I was converting some code I wrote for hugs
01:47:26 <xkb> to ghc
02:01:06 <xkb> http://acm.uva.es/p/v1/105.html <= how would you solve this?
02:01:21 <xkb> I did it in 2 ways.. one very bad, one somewhat more elegant
02:01:42 <xkb> first way: induction over naturals (Int) to max 10.000
02:02:07 <xkb> second way by analysis on the up/downgoing edges (flank)
02:08:35 <earthy> xkb: the first way is stupid
02:08:38 <earthy> the second way is smart
02:09:03 <earthy> I'd pull apart the triples into ups with height and downs from height
02:09:34 <earthy> so I'd have pairs. Then sort the pairs for x-axis
02:09:43 <earthy> then walk through that to generate the outline
02:10:00 <earthy> keeping the current height as I go along
02:10:18 <earthy> (and that sounds like your second way)
02:10:36 <xkb> yeah almost
02:10:53 <xkb> At first I did not rip the tripples into 2 tuples
02:11:02 <xkb> and then you miss every downgoing edge
02:11:08 <earthy> exactly, and you need those
02:11:33 <xkb> my second problem was that for upgoing edges you can abuse the fact the list is sorted on x
02:11:40 <xkb> however on downgoing you cant
02:11:50 <earthy> yes you can
02:12:07 <xkb> and you always need the "seccond highest" point on a downgoing edge
02:12:12 <xkb> earthy, you can?
02:12:15 <earthy> but you need to not keep a current height, but you need a current stack
02:12:26 <earthy> if you have that, you're home free
02:12:33 <xkb> stack! yeah.. thats what I should have used
02:12:40 <xkb> now I implemented something like it myself
02:12:45 * xkb hits himself on the head
02:13:01 <xkb> thats the "using the second highest point"
02:13:16 <xkb> well.. we live to learn :D
02:14:00 <earthy> yes, because there can be a 3rd highest and a 4th highest
02:14:08 <earthy> a priority queue would be the better term though
02:14:26 <xkb> earthy, cool.. that was the first thing I thought of
02:14:37 <xkb> I could not find any implemenattion for haskell though
02:14:54 <xkb> only 1 paper.. and that was to complicated to implement in an hour
02:15:12 <earthy> err...
02:15:15 <earthy> just a sec
02:17:49 <earthy> newtype Prio a = List a
02:17:49 <earthy> insert :: Ord a => a -> Prio a -> Prio a
02:17:49 <earthy> insert x l = sort (x:l)
02:17:49 <earthy> pop :: Prio a -> (a, Prio a)
02:17:49 <earthy> pop l = (hd l, tl l)
02:18:04 <earthy> sounds like a neat priority queue to me..
02:18:15 <earthy> not a fast one, mind you
02:18:28 <xkb> en the resort?
02:18:29 <xkb> ah
02:18:31 <xkb> ok.. sort
02:20:20 <xkb> earthy, seems ok indeed
02:20:34 <xkb> I ran into some difficulty.. however I can't remember what atm
02:33:52 * musasabi considers writing a "why are strings so ugly" post to haskell-cafe
03:39:03 <TheDark12> hey
03:39:36 <TheDark12> i mean... hello
03:46:00 <xkb> hi again
03:47:40 <TheDark12> hi
03:47:57 <TheDark12> hi
03:48:58 <TheHunter> hi, TheDark12 
03:49:22 <TheDark12> woah
03:49:25 <TheDark12> someone talked
03:49:37 <TheDark12> oh hey and xkb talked before too
03:50:17 <TheHunter> looking for haskell info?
03:50:18 <TheDark12> is linux a good place to start learning to use haskell?
03:50:32 <TheHunter> sure
03:50:47 <TheDark12> great
03:51:07 <TheDark12> all i gotta do now is find out where these compilers went...
03:51:15 <TheHunter> i recommend ghc, it has a nice command-line-interpreter 'ghci'
03:51:33 <TheDark12> oh great! you gotta link where i can download it?
03:51:49 <TheHunter> which distri are you using?
03:51:57 <TheDark12> fedora core 1
03:53:10 <TheHunter> you should probably get some packages made for your distribution
03:54:03 <TheDark12> yeah i just installed all the programming tools off my cd but im an idiot and i cant find them in the start menu...
03:54:49 <TheHunter> open a console window, and try ghci
03:55:10 <TheDark12> one moment
03:56:01 <TheDark12> sorry, im a real big noob to linux, is there a command i am supposed to put before ghci?
03:56:43 <TheHunter> actually not, if it says something like 'bash: ghci: command not found', then ghc isn
03:56:47 <TheHunter> 't installed
03:57:01 <TheDark12> yeah, it said that
03:57:11 <TheDark12> would i be better off in windows?
03:57:51 <TheHunter> you can use haskell both on linux and on windows (though i've never tried the latter)
03:58:10 <TheDark12> im sorta, really nooby to linux, but i wanna use it as much as i can just to get used to it...
03:58:20 <TheDark12> what linux do you use?
03:58:25 <TheHunter> ok, then go ahead, use linux
03:58:35 <TheHunter> i'm using debian (unstable branch)
03:58:43 <TheDark12> haha allright
03:59:40 <TheHunter> i'm not sure how the preferred install procedure for packages in fedora is, but here you can download a ghc fedora rpm: http://www.ifi.unizh.ch/staff/milmei/rpms/ghc-6.2.1-0.fdr.1.i686.rpm
03:59:40 <TheDark12> i might restart in windows, ill be right back ok?
03:59:54 <TheHunter> ok
03:59:55 <TheDark12> oh ok ill use this
04:00:38 <TheDark12> i know how to install things good enough...
04:00:59 <TheDark12> they make it pretty noob proof these days...
04:01:20 <TheDark12> but i think i may be a sufficient enough noob to screw it up anyway
04:01:55 <TheHunter> don't be too hard on you, everybody's been a noob
04:02:05 <TheDark12> haha yeah, i know
04:02:29 <TheDark12> wow, sufficient enough thats horrible english
04:02:42 <TheDark12> pretty big file 10 meg...
04:03:36 <TheHunter> well, it's a great program
04:04:34 <TheDark12> so, what can/cant you do in haskell?
04:04:50 <TheDark12> i mean, im really new to programming and all, so i dont know what limits what
04:05:05 <TheDark12> can every language write every type of program?
04:05:14 <TheHunter> principially yes
04:05:37 <TheHunter> but you may have to express things very differently
04:06:30 <TheHunter> i think haskell is a cool first programming language
04:07:16 <TheDark12> yeah, it sounds cool
04:07:31 <TheDark12> i was gonna try c, but it seemed very overbearing
04:07:38 <TheHunter> usually, people learning haskell have used imperative languages like c or java before, so they use to think 'imperatively' and have a hard time grasping haskells more natural (to me, at least) concepts
04:07:59 <TheDark12> and i thought i remembered reading that it was based on maths, i am not bad at maths
04:08:10 <TheDark12> i used basic before
04:08:10 <TheHunter> c is too low level, i think
04:08:31 <TheHunter> ok, if you like math, then haskell _definitely_ is the right language for you
04:08:31 <TheDark12> basic i was allright at
04:08:50 <TheDark12> cool
04:08:58 <TheDark12> hey, my dinner is ready so ill brb
04:09:01 <ski> hehe
04:09:14 <TheDark12> you think you will be here in 30 mins?
04:09:16 <earthy> basic... wasn't that the belligerintely asinine symbolic idiot creator?
04:09:41 <TheHunter> yep, see you
04:09:56 <TheDark12> ciao
04:11:49 <kristnjov> hi
04:12:01 <ski> good day, kristnjov
04:12:05 <earthy> hi
04:12:22 <kristnjov> i was just wondering if you guys could help me out here
04:12:33 <kristnjov> i'm taking an introduction course to functional programming.
04:12:50 <kristnjov> prop_plot ((a,b):xs) = b > 0 && isAscii a
04:12:58 <kristnjov> ohh sorry mates
04:13:05 <kristnjov> i just realized the problem
04:13:25 <earthy> ah... the `tell it to your granny'-effect
04:13:44 <kristnjov> yes, kind of.
04:14:35 <kristnjov> very common when asking people in newsgroups :)
04:14:43 <kristnjov> you notice the error when pasting the code.
04:15:14 <Iter> irc is less embarassing, as less people get to see, and it isn't archived as obviously
04:15:26 <kristnjov> :) unless there's someone logging it
04:15:45 <Iter> there are logs, just not as obvious as google-groups :)
04:15:48 <musasabi> btw anyone have any thoughs on my Strings whine on -cafe?
04:15:50 <kristnjov> :)
04:16:34 <Iter> krist, btw. thanks, and congrats' on actually telling us upfront it was a homework prob ;)
04:16:53 <Iter> first time I've seen a proper help request in weeks.
04:17:02 <kristnjov> hehe
04:17:14 <earthy> musasabi: it's a whine. :P
04:22:01 <kristnjov> in this course the first week we did 2+2 in hugs, the next week we were to have finished a black jack game in :)
04:23:54 <Iter> krist: so a nice gradual introduction than.... when do you get to prove P=NP? ;)
04:25:01 <kristnjov> say what? ;)
04:25:27 <Iter> P=NP is one of the oldest unsolved problems in CS
04:25:49 <kristnjov> i've never seen it before, sounds like a challenge :)
04:26:44 <Iter> You'll get to cover it in Complexity.
04:27:54 <kristnjov> where did you guys learn haskell? pure hobby or did you read it as a course?
04:29:50 <Iter> I taught myself, although I studied hope back in uni, so I wasn't unfamiliar with functional programming.
04:31:35 <earthy> I studied Clean, and then picked up Haskell on my own
04:32:01 <kristnjov> have you guys created any "big" programs in haskell? i saw an irc client made in haskell on google.
04:32:17 <kristnjov> "big" as in "lots and lots of code doing something with a purpose".
04:32:25 <musasabi> ghc ;)
04:32:32 * earthy hasn't, actually
04:32:54 <kristnjov> ghc? haskell compiler i presume?
04:33:23 <kristnjov> i heard one guy say "i can't do anything with haskell, but it's mathematically correct."
04:34:21 <keverets> darcs is written in haskell, and is quite useful.
04:37:35 <Iter> I know a couple of people who consider Haskell their preferred web-application language.
04:41:10 <kristnjov> do you guys know any site where i can read about arbitrary instances?
04:41:25 <kristnjov> or an already-made arbitrary Char
04:45:01 <ski> huh ?
04:45:29 <ski> you mean "how to make instances of a type class ?" ?
04:45:36 <kristnjov> dude i don't even know :P
04:45:43 <kristnjov> ERROR - Cannot infer instance
04:45:44 <kristnjov> *** Instance   : Arbitrary Char
04:45:46 <kristnjov> *** Expression : quickCheck prop_plot
04:46:02 <ski> oh
04:47:47 <kristnjov> so any ideas? :)
04:48:03 <ski> hm
04:48:12 <kristnjov> basically i haven't written down how to pick arbitrary Chars
04:50:32 <ski> hm, so there doesn't seem to be an Char instance, at a quich glance in QuickCheck.hs
04:51:12 <ski> hmm
04:53:01 <TheDark12> Hey hunter, you there? I am back from dinner...
04:53:19 <TheHunter> wb TheDark12 
04:55:01 <TheDark12> thank you
04:55:05 <TheDark12> good to be back
04:55:21 <TheHunter> so, did the installation of ghc work well?
04:55:25 <ski> kristnjov :you there ?
04:55:30 <kristnjov> i'm here.
04:55:42 <kristnjov> god i hate this irc client
04:55:45 <kristnjov> bloated chatzilla
04:55:55 <TheDark12> i have gaim
04:55:58 <TheDark12> its all weird...
04:56:00 <ski> kristnjov : look at the HaskellIrcPastePage, that code might work
04:56:08 --- topic: set to '#haskell' by kristnjov
04:56:16 <andersca> eeek
04:56:20 <kristnjov> uhh...
04:56:25 <kristnjov> as i said, i hate this client.
04:56:35 <andersca> you broke our topic!
04:57:29 <kristnjov> could someone with a decent client change it back?
04:57:34 <Igloo> desrt: What makes you think Debian's ghc depends on hugs?
04:58:22 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs ","http://www.haskell.org/cabal/","#haskell is now officially 1337","Haskell - too cute for its own good"]' by ski
04:59:27 <ski> kristnjov : does that code work ?
05:00:29 <kristnjov> yeah thanks
05:00:48 <Igloo> It could be there's no Arbitrary Char instance as it's not clear if it should be 0..127, 0..255 or any unicode codepoint
05:00:58 <kristnjov> hi
05:01:02 <kristnjov> sorry wrong window
05:01:05 <kristnjov> i hate this client.
05:01:17 <musasabi> well Char is broken...
05:01:20 <ski> Igloo : Bounded ?
05:01:41 <Igloo> "Bounded"?
05:02:09 <ski> @info Bounded
05:02:10 <lambdabot> -- Bounded is a class
05:02:10 <lambdabot> class Bounded a where { maxBound :: a; minBound :: a; }
05:02:26 <Igloo> I know what it is, I just don't know why you said it  :-)
05:02:51 <ski> 'tseems Char is an instance of Bounded
05:02:52 <Igloo> I'm not even sure [minBound..maxBound] are all valid Unicode codepoints
05:03:01 <ski> hmm
05:03:08 <ski> that's a point
05:03:26 <ski> hi shapr
05:03:27 <musasabi> yes and things like putChar don't support all Chars.
05:03:27 <shapr> good morning #haskell!
05:03:34 <musasabi> morning shapr
05:03:37 <shapr> did I miss anything exciting?
05:03:37 <Igloo> Yo shapr - how's the new place?
05:03:48 <ski> shapr : you moved ?
05:03:50 <shapr> Igloo: it's nice, you want to come to the apartment warming party?
05:03:59 <shapr> ski: yes, three blocks over.
05:04:14 <musasabi> any pics?
05:04:19 <Igloo> When you move to Oxford I'll come to the party
05:04:22 <ski> nhnn
05:04:24 <shapr> heh, fair enough
05:04:33 <shapr> musasabi: we only have chemical cameras, sadly.
05:05:44 <shapr> I'll put up pix as soon as they're developed and scanned in.
05:06:19 <shapr> so, what sort of excitement did I miss?
05:10:00 <Igloo> Well, we all decided Haskell sucks and took up C#. Oh, and the Simon's quit their jobs and became hermits in the alps, living off the land.
05:10:27 <shapr> aieee
05:25:43 <shapr> 10Mbit DSL is far superior to 512kbit DSL
05:27:27 <earthy> shapr: time to fix that chemical-dependency
05:27:47 <shapr> heh, truly
05:28:12 <earthy> digital is *fun*
05:30:46 <xkb> 10 MBit DSL??
05:30:48 <xkb> nice
05:31:00 <musasabi> sounds fun.
05:31:12 * musasabi would not like a DSL though
05:31:17 <musasabi> but then again I am spoiled.
05:34:24 <Igloo> The only time I find 512kb annoying is when copying Haskell programs around
05:34:56 <Igloo> Having had 2 years of 10Mb and I think I have 100Mb at work now
05:37:34 <kristnjov> i recently got 13Mbps VDSL
05:37:38 <kristnjov> sweet.
05:39:21 <kristnjov> i can tell everyone's interested
05:39:38 <edwinb> I still use a modem...
05:40:46 <kristnjov> me too, a vdsl one
05:40:58 <earthy> :P
05:41:22 <shapr> kristnjov: spiffy
05:41:31 <kristnjov> idneed
05:41:36 <shapr> kristnjov: so, are you new to #haskell?
05:41:43 <kristnjov> yep
05:41:49 <kristnjov> don't know if i'll be a regular here though
05:42:12 <shapr> you're a chalmerite too, yes?
05:42:20 <kristnjov> yes
05:42:34 <shapr> chalmers is a neat place.
05:42:39 <kristnjov> ever been here?
05:42:45 <shapr> yup, last summer.
05:42:53 <kristnjov> cool, are you from sweden?
05:42:57 <shapr> for EuroPython and EuroHaskell
05:43:09 <shapr> I live in Boden, but spent the first 28 years of my life in the USA.
05:43:10 <andersca> EuroHaskell!
05:43:16 <kristnjov> oh
05:43:31 <kristnjov> our tutor is john hughes, don't really know if he's famous or anything
05:43:36 <shapr> he is :-)
05:43:43 <andersca> :)
05:43:57 <kristnjov> seriously? :) what's he done for the world of haskell
05:43:59 <kristnjov> ?
05:44:08 <shapr> well, he discovered arrows
05:44:11 <shapr> he wrote QuickCheck
05:44:24 <shapr> he was part of the Haskell standards committee
05:44:31 <edwinb> Perhaps most importantly, he wrote "Why Functional Programming Matters" 20 years ago...
05:44:36 <shapr> yes, that
05:44:49 <kristnjov> damn this is cool :)
05:44:56 <kristnjov> he's a great tutor by the way
05:45:08 <edwinb> I'm sure he is. I was at a talk he gave last week on Arrows, which was very good.
05:45:09 <shapr> I'd say John Hughes and Simon Peyton-Jones were the two people who really got FP moving.
05:45:24 <shapr> hey, any BredbandsBolaget users here?
05:45:31 <shapr> I've been a BBB user for about an hour.
05:45:38 <shapr> looking for an SMTP server.
05:45:55 <kristnjov> i use bostream at home and as you might know bbb owns them.
05:46:17 <shapr> does that mean you know of a state-approved SMTP server?
05:46:36 <kristnjov> i'm sure it doesn't :/
05:46:46 <kristnjov> i don't use bostream
05:46:50 <kristnjov> uh
05:46:52 <kristnjov> i don't use bostream's email
05:47:11 <shapr> might be simpler to do an ssh tunnel to ScannedInAvian.org
05:47:39 <kristnjov> i wouldn't count on it being simpler, but yes that would probably work
05:48:30 <shapr> have you done any functional programming before?
05:48:47 <Igloo> This should give ICFP results times, I believe: http://www.timeanddate.com/worldclock/fixedtime.html?day=20&month=9&year=2004&hour=17&min=30&sec=0&p1=220
05:48:52 <kristnjov> nope, only c++ (opengl and borland) and lots of mirc scripting ;)
05:49:17 <shapr> ah, Haskell will give you a completely different view of programming then.
05:49:35 <kristnjov> yeah, i've already noticed that my programming has changed dramatically
05:50:07 <kristnjov> as the topic states, it's cute :)
05:50:12 <shapr> heh
05:50:54 <shapr> yah, almost too cute
05:51:03 <kristnjov> for its own good :>
05:51:17 <Igloo> I think I'd reserve that accolade for epigram  :-)
05:52:13 <shapr> Epigram is rather sexy, I admit.
05:52:37 <xkb> epigram.org? :P
05:52:46 <shapr> #epigram
05:53:05 <xkb> oh another one of those "interactive" channels ;-)
05:53:07 <shapr> http://www.dur.ac.uk/CARG/epigram/
05:53:50 <shapr> jag Ã¤r altid nyfiken!
06:18:52 <IRCMonkey> how do i convert an Integer to an Char?
06:20:10 <ski> Char.chr :: Int -> Char
06:21:24 <desrt> chr _ = '!'
06:21:58 <ski> ?
06:22:02 <shapr> hey desrt, long time no see
06:22:02 <yohan_> hm
06:22:04 <yohan_> thank you
06:22:06 <desrt> hi shae
06:22:18 <shapr> how's the learning addiction treating you?
06:22:19 <desrt> you people were too smart for me
06:22:30 <Igloo> desrt: What makes you think Debian's ghc depends on hugs?
06:22:32 <desrt> 8:30 classes every morning = :(
06:22:42 <shapr> desrt: gee, I thought you'd just graduated past us :-)
06:22:52 <desrt> Igloo; i think it depended on something called "haskell-utils" which depended on hugs
06:22:59 <yohan_> do i need to import something in order to use chr?
06:23:03 <desrt> according to this webpage i was at (debian.org, i think)
06:23:08 <kristnjov> yohan_, omg noob
06:23:13 <desrt> shapr; pfft.  hardly.
06:23:21 <kristnjov> you might want to import Data.Char
06:23:44 <Igloo> Ah, OK. It "Suggests: ghc6 | ghc5 | ghc4 | nhc98 | hugs" which means only 1 of them, and it isn't a dependency.
06:23:54 <desrt> Igloo; further up
06:23:58 <desrt> says depends on hugs
06:24:04 <desrt> and also suggests one of those
06:24:11 <ski> OT : is it "stone, scissor and bag" or "paper, scissor and stone" ?
06:24:19 <xkb> the latter
06:24:34 <Igloo> Oh, it'll depend on hugs on arches where ghc6 wasn't available at build time, true
06:24:55 <desrt> Igloo; so it's a build dependancy, not a run dependanc
06:25:00 <desrt> +y
06:25:28 <desrt> either way i was unable to unpack the .deb and use it to build ghc-6.2.1 on gentoo using the normal ebuild
06:25:32 <desrt> *able
06:25:40 <desrt> too early!  need coffee
06:25:45 <Igloo> No, if the only Haskell implementation available is hugs then it gets "compiled" by just putting #!/usr/bin/runhugs or whatever at the top, so hugs is needed at runtime too
06:25:56 <desrt> ah
06:26:07 <desrt> but then you can use that ghc to build a real ghc
06:26:10 <Igloo> ghc itself will work fine without the haskell-utils stuff though, as you found out
06:26:49 <shapr> ski: rock, paper, scissors
06:27:10 <shapr> 162,000 hits - http://www.google.com/search?q=rock%20paper%20scissors&ie=UTF8
06:28:59 <desrt> dijkstra is ok on negatively weighted graphs as long as you have no loops, right?
06:29:46 <Igloo> Do you mean a tree?
06:30:03 <desrt> no.  a graph
06:30:13 <Igloo> A directed graph?
06:30:16 <desrt> yes
06:30:25 <Igloo> No then
06:30:35 * desrt blinks
06:30:39 <desrt> can you explain why?
06:30:53 <desrt> oh... i shouldn't say loops
06:30:54 <Igloo> a -> z weight 5. a -> m weight 10. m -> z weight -8.
06:30:55 <desrt> i mean no cycles
06:31:08 <Igloo> You want to get from a to z
06:31:24 <desrt> by 'loop' i meant 'cycle' :P
06:31:33 <Igloo> If you don't have that sort of case then you have a tree
06:31:47 <desrt> uhm.
06:31:49 <xkb> you can include direction information in the weight function right?
06:32:05 <desrt> Igloo; that means i'd take a->m and m->z to get to z
06:32:08 <desrt> with overall cost of 2
06:32:15 <Igloo> Yes, but Dijkstra wouldn't
06:32:30 <Igloo> It would say, what's the cheapest first step? Ah, a -> z with weight 5. Finished!
06:32:44 <desrt> no.  dijkstra runs on the entire tree
06:33:04 <Igloo> It stops when it reaches the end
06:33:04 <desrt> it would set z to have cost 5
06:33:10 <desrt> then it would go to m = cost 10
06:33:16 <desrt> then notice that 10 + (-8) < 5 and relax z
06:33:21 <Igloo> Otherwise it's no better than depth first search or anything
06:33:49 <desrt> oh.  the way i was taught, dijkstra *is* depth first
06:34:16 <Igloo> No, it's breadth-first by weight
06:35:20 <xkb> its eager in the selection
06:35:26 <yohan_> hm i tired chr 1 and i get a control code, i would like to get the numeric value instead...how do i go around this?
06:35:49 <desrt> according to this site, dijkstra assigns a cost number to every node
06:35:54 <yohan_> that is, i want the numeric value of an integer to  char..
06:35:54 <Igloo> yohan_: Do you mean chr (ord '0' + 1)?
06:36:20 <desrt> Djikstra's algorithm (named after its discover, E.W. Dijkstra) solves the problem of finding the shortest path from a point in a graph (the source) to a destination. It turns out that one can find the shortest paths from a given source to all points in a graph in the same time, hence this problem is sometimes called the single-source shortest paths problem.
06:36:26 <desrt> The somewhat unexpected result that all the paths can be found as easily as one further demonstrates the value of reading the literature on algorithms!
06:38:24 * desrt becomes confused by sites offering conflicting information and goes to get his algorithms book
06:38:48 <yohan_> Igloo: i have a variable x which i want to convert to a char cause im adding it to a string
06:39:12 <Igloo> yohan_: You might want to just show it then
06:39:25 <yohan_> show x?
06:39:52 <Igloo> Yup
06:40:06 <yohan_> thank you
06:43:47 <ski> @type intToDigit
06:43:49 <lambdabot> bzzt
06:44:00 <ski> @type Char.intToDigit
06:44:02 <lambdabot> Char.intToDigit :: Int -> Char
06:44:10 <ski> @type Char.digitToInt
06:44:21 <ski> @type Char.digitToInt
06:44:47 <ski> <lambdabot:#haskell.se> Char.digitToInt :: Char -> Int
06:53:08 <musasabi> A
06:54:37 <TheHunter> B
06:58:09 <shapr> C
06:58:36 <ibid> D
06:59:19 <ibid> (the A minor scale:)
06:59:45 <shapr> C-sharp is the same as D-flat
06:59:56 <shapr> why is the De Flat Language so popular these days?
07:00:01 <andersca> I like C Sharp
07:00:03 <earthy> shapr: not true
07:00:12 <shapr> it isn't the same?
07:00:18 <earthy> C sharp and D flat sound identical in a 12-tone scale
07:00:24 <shapr> ah, ok
07:00:36 <earthy> but they are not, in general
07:00:42 <ibid> yeah
07:01:10 <Igloo> Are the accidentals the next 5 notes to come out if you continue producing notes by means of nice ratios?
07:01:13 <ibid> a good musician playing a violin or other freely operable instrument can distinguish between them
07:01:13 <earthy> http://www.xs4all.nl/~huygensf/english/index.html
07:01:15 <shapr> what do they call the notes in other systems?
07:01:34 <ibid> shapr: in other systems?
07:01:57 <shapr> I think Japanese traditional music has an 8-tone scale
07:02:08 <shapr> 8 might be wrong, but I know it's not 12
07:02:32 <ibid> i could be wrong but i think there's a misunderstanding here
07:02:49 <shapr> educate me!
07:03:06 <ibid> for example, the A minor scale is a seven-tone scale, but it is still often played on a 12-note scale :)
07:03:11 * shapr blinks
07:03:19 <ibid> ie. the two scales are not the same kind of scales
07:03:48 <shapr> neat
07:04:12 <shapr> does stockhausen write microtonal music?
07:04:27 <ibid> what we mean when we say "12-tone scale" is a system where the octave is divided into 12 steps and the traditional notes are mapped to them with the principle of least error
07:04:52 <ibid> or something similar :)
07:04:55 <earthy> yes, equal tempered scales
07:05:12 <earthy> as in `Das Wohl-temperierte Klavier' by J.S. Bach
07:05:17 <ibid> yeah
07:05:24 <earthy> which was a novelty in those days
07:07:00 <ibid> but it's fun to note that a piano is, if in perfectly tuned according to modern standards, always slightly wrong 
07:07:11 <earthy> not quite
07:07:18 <earthy> the octaves are perfect octaves
07:07:19 <ibid> close enough:)
07:07:21 <ibid> yeah
07:07:26 <earthy> everything else however... ;)
07:08:18 <ibid> since there is a perfect tuning for each key
07:08:24 <ibid> which are different
07:09:15 <earthy> the big innovation the equal tempered tuning allowed was transposing from one key to another on the exact same instrument in one piece of music
07:09:20 <ibid> you can still hear it in the singing of a well-trained chorus or in the sound of a well-trained string orchestra
07:09:22 <earthy> big increase in musical freedom
07:09:25 <ibid> exactly
07:09:35 <earthy> but slight decrease in tonal quality
07:09:43 <earthy> most people don't hear it though
07:09:46 <ibid> yeah
07:11:32 <Igloo> I can't even tell when keys change in a piece of music, let alone that  :-)
07:11:33 <ibid> it's best noted by a musician playing in a well-trained band, where they can note how they use slightly different positions to get the "same" note in different keys
07:11:49 <earthy> uhuh
07:12:23 <ibid> (on the violin or, in my case, the trombone:)
07:12:33 <ibid> or other such instruments
07:14:02 <shapr> hoi arjanb
07:18:17 <ibid> earthy: i suppose it's the same phenomenon that makes tuning a guitar such a bitch :)
07:20:11 <ibid> earthy: i mean, i usually tune the A string according to some external source and then use octaves to transfer it: A on low-E string against A string, high-E string and E on D string against low-E string, B on A string against B string, G on low-E string against G string
07:20:30 <ibid> earthy: and it will always be noticeably off when I try to match D string and D on B string
07:21:11 <ibid> i then usually fiddle with the tuners until the problem is no longer jarring
07:21:59 <earthy> ibid: that is exactly the problem, yes.
07:23:44 <ibid> people wouldn't believe me when I told them that you can never tune a guitar perfectly
07:24:03 <ibid> at that point i didn't know about the theory but the practice was quite familiar
07:24:17 <ibid> (i was something like 12-14 years old)
07:45:56 * shapr sings
07:46:52 * ski ponders
07:47:54 * ski also sings
07:51:04 <ski> bah
07:51:13 <ski> can't find good example
07:51:33 <shapr> of what?
07:51:38 <ski> array
07:51:53 <ski> indexed with meaningful subtype of integer
07:52:19 <ski> e.g. -10..10
07:52:37 <ski> or 357..389
07:52:41 <ski> or something
07:52:50 <ski> just not starting at 0 or 1
07:53:24 <ski> (and the index should be meaningful/relevant for what the contents of the corresponding cell is)
07:58:03 <Igloo> Timezone or degrees of lat/longitude?
07:58:18 <Igloo> Or year?
07:58:26 <ski> hm
07:58:39 <ski> timezone might be good
07:59:41 <shapr> maybe a histogram that's a cross between an array and a finitemap?
08:01:48 <shapr> hiya paolo1984 
08:01:50 <musasabi> it should be possible to map them to 0..N...
08:02:15 <musasabi> just by using newtype and good instance definitions.
08:03:00 <ski> i know
08:03:27 <ski> but i wanted some example where it's natural to use non 0- (or 1-) based indexing
09:20:38 <shapr> d00d
09:20:40 <shapr> wassup?
09:28:06 <shapr> @yow !
09:28:07 <lambdabot> My forehead feels like a PACKAGE of moist CRANBERRIES in a remote
09:28:07 <lambdabot>  FRENCH OUTPOST!!
09:28:14 * shapr agrees with lambdabot 
09:29:01 <andersca> @arr
09:29:02 <lambdabot> This is the END for you, you gutter-crawling cur!
09:37:45 <SamB> what does a package of moist cranberries in a remote french outpust feel like?
09:38:28 <shapr> cool inside while it's warm outside
09:42:23 <tnks> hey guys. . . 
09:42:39 <tnks> does anybody have an opinion of Haskell performance versus Lisp?
09:42:52 <tnks> Lisp has been around for so long, maybe optimizations are pretty good for it.
09:43:12 <tnks> Both have garbage collection, and other overheads. . . 
09:43:26 <tnks> but I'm wondering if one is clearly the speed winner.
09:46:58 <shapr> Lisp has more compilers, so you'll probably be able to create Lisp binaries that execute faster than Haskell binaries.
09:47:27 <shapr> For me, I can write Haskell programs fatser than Lisp programs.
09:47:31 <shapr> 'faster'
09:47:37 <ski> heh
09:47:43 * ski 's leaving
09:47:49 <ski> bye
09:47:58 <shapr> In my experience, execution speed is not as important as speed of change and quality of 'communication'
09:48:01 <shapr> bye ski!
09:54:20 <tnks> Yeah, I have no aspirations to code in Lisp.
09:55:15 <tnks> Are there any serious contenders to Haskell of the same breed?
09:55:26 <shapr> depends on what you're looking for....
09:55:43 <shapr> OCaml makes faster executables, but is not a pure FP language.
09:56:06 <monochrom> Clean
09:56:07 <shapr> Epigram has a more powerful type system, but dependent types have some possible drawbacks, and the Epigram implementation isn't up to GHC quality yet.
09:56:12 <tnks> Is OCaml's grammar similar to Haskell?
09:56:38 <shapr> I've heard that there are a lot of similarities between Haskell and OCaml
09:57:22 <shapr> I agree with monochrom, you should check out Clean also.
09:57:40 <shapr> for IO and other side-effecty stuff, Clean uses uniqueness types rather than monads.
09:57:53 <tnks> What's the most mature between OCaml, Clean, and Haskell?
09:58:22 <shapr> Haskell has zillions of cool features and abilities you won't find elsewhere.
09:58:35 <shapr> OCaml has the most mature compiler (from what I've heard and read).
09:59:10 <tnks> What are features that keep people with Haskel (over OCaml, Clean, Epigram, etc)?
09:59:22 <shapr> but if you're talking about making commercial applications, I think you'd do fine with either Haskell or OCaml (I don't know anything about Clean)
10:00:09 <thebug> what about SML ?
10:00:10 <shapr> well, Haskell is pure, and OCaml is mutable. Those each have their tradeoffs.
10:00:45 <tic> the purity is good for program verification.
10:00:59 <shapr> Right now, Epigram is a research language to see what can be done with dependent types (and it is *cool*).
10:01:38 <shapr> Originally, Clean was closed source, that's what kept me away from it. I'm pretty sure it's open source now.
10:02:47 <shapr> Yes, the purity of Haskell can be advantageous.
10:03:20 <shapr> You can do a lot of cool stuff with the type system in Haskell.
10:03:36 <shapr> In essence, every type system is a simplified automated proof checker.
10:04:23 <shapr> tnks: Any particular points you're interested in?
10:04:39 <xkb> Clean is open source inded
10:04:41 <xkb> +E
10:05:35 <xkb> Clean has one "problem" it does not have as much usefull libs as haskell
10:06:06 <xkb> And its also possible to use monads in Clean
10:06:24 <xkb> you can implement monads using uniqueness typing
10:07:01 <shapr> tnks: anyway, if you have a particular goal or purpose in mind, some things are easier than others with a particular system.
10:07:20 <shapr> windowing systems are generally easier with mutability.
10:07:39 <shapr> mathy stuff tends to look really sexy when pure
10:08:18 <xkb> I should save that as a quote :D
10:08:23 <shapr> If you end up wanting to encode behavioural aspects of your program into your types, Epigram is worth investigating.
10:08:29 * shapr grins
10:11:08 <tnks> okay.
10:11:18 <shapr> any specific questions?
10:11:20 <tnks> there's a lot of places to look.
10:11:41 <tnks> none for now. I have things to go research for myself.
10:11:42 <tnks> thanks,
10:12:03 <shapr> ok, feel free to ask any questions if you find more.
10:13:12 <shapr> tnks: I would of course recommend learning Haskell, but I may be biased ;-)
10:15:19 <shapr> tnks: if you really want to understand all of these options and their tradeoffs, I'd suggest reading BC Pierce's Types and Programming Languages, and probably Barendregt's survey of the different lambda calculi, and John Hughes' 'Why Functional Programming Matters'
10:15:40 <tnks> cool. .. 
10:15:41 <tnks> thanks. . . 
10:15:57 <tnks> Is Peirce's a book or article?
10:15:59 <shapr> have you found anything interesting that you would suggest I read?
10:16:12 <shapr> it's a massive doorstop of a book
10:16:15 <tnks> you sound like you've read what I've read. . . 
10:16:25 <tnks> (mostly some Wadler articles)
10:16:40 <shapr> if you can get TaPL from your local CS library, that's probably the best option for starters
10:17:04 <shapr> you may end up loving it and purchasing it, or maybe you'll drop it on your foot and just limp back to the library to turn it in
10:17:29 <tnks> gotcha.
10:17:32 <tnks> thanks. . . 
10:17:32 <shapr> which Wadler articles?
10:17:42 <shapr> the ones where he shoehorned monads into functional programming?
10:17:44 <tnks> Composing Functional Monads.
10:17:59 <tnks> I don't know if look at it as "shoehorning"
10:18:03 <tnks> I used to think that too.
10:18:16 <shapr> I think monads are immensely elegant
10:18:24 <tnks> totally.
10:18:50 <shapr> I keep looking for more combinations of power and simplicity in both life and math.
10:19:05 <tnks> I guess I just think of "shoehorning" as implying too tight of a fit (I certainly don't use one for my own shoes). . . 
10:19:32 <shapr> Monads weren't in Haskell from the beginning.
10:19:44 <tnks> yeah, but they have a comfortable place, I think.
10:20:01 <musasabi> shapr: why do you think windowing is easier in dirty languages?
10:20:15 <shapr> yah, but I think there are still some rough edges that would be different if Haskell had been designed with monads in mind.
10:20:16 <tnks> okay guys. . . 
10:20:18 <shapr> Maybe not.
10:20:20 * shapr shrugs
10:20:24 <tnks> I have to get back to programming assignments.
10:20:38 <shapr> tnks: feel free to come back and chat about programming theory and research anytime, that's standard fare here.
10:20:44 <tnks> totally.
10:21:04 <thebug> and unicycling
10:21:06 <thebug> ;)
10:21:06 <tnks> thanks for the notions and referals. . . 
10:21:09 <shapr> yes, unicycling!
10:21:21 <shapr> tnks: you're welcome
10:21:22 <thebug> just thought I'd throw that one out hehe
10:22:01 <shapr> musasabi: now that you mention it, I bet Fudgets/Yampa/etc could make some kick-ass GUI frameworks.
10:23:02 <shapr> I haven't been unicycling in two days :-/ this moving house thing sucks up way too much time.
10:23:35 <musasabi> shapr: in complex gui apps one has usually threads + gui, which make things complex.
10:23:50 <musasabi> shapr: I think the expliteness of monads would solve many of the problems
10:23:57 <shapr> have you read the Yampa papers?
10:25:23 <musasabi> shapr: I glanced at them, but the robotics stuff drove me away.
10:26:07 <shapr> I think it's worth reading, the reactive stuff might get around a lot of the threading complexity.
10:27:37 <shapr> for example, you may be able to set 'reactive properties' on gui elements to give them behaviour. 
10:28:19 <shapr> I wonder how Fudgets did it...
10:30:26 <musasabi> shapr: How about setGUI :: Gui -> IO (), button :: String -> (Gui -> IO ()) -> Gui, ...
10:32:26 <shapr> looks sensible at first glance.
10:33:23 <shapr> hm
10:33:30 <shapr> GUI combinators
10:35:34 <shapr> ya know, I think the optimistic GHC fork really needs to make it back into the base GHC.
10:36:24 <shapr> musasabi: http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/Intro/ex8.html
10:42:28 <musasabi> seems quite sensible
10:45:37 <flaw> optimistic GHC fork?
11:09:56 <Igloo> Anyone know if there's a function to set the clipboard to some text anywhere?
11:12:28 <Lemmih> in GTK?
11:13:11 <Igloo> AFaICS gtk_clipboard_set_text isn't wrapped by gtk2hs yet, so by anything really
11:15:57 <musasabi> wrapping it should be 10 lines of code.
11:57:54 <opet> does anyone happen to have compiled mozart recently?
11:58:21 <Lor> Does July count as recently?
11:59:45 <opet> that depends :) I'm investigating why it's currently broken on freebsd and I think it's due to the gcc update (to 3.4.2)
11:59:53 <opet> do you remember/know what version of gcc you used?
12:02:32 <Lor> I compiled it on a laptop which is currently turned off. I don't think that it was 3.4, though.
12:02:42 <Lor> gcc 3.4 seems to break a lot of things.
12:26:02 <shapr> hej psi 
12:26:15 <psi> hej hej
12:28:42 <stepcut`> what is that new programming language that is being developed in haskell? I think it starts with an e?
12:28:53 <kristnjov_> i heard it earlier today
12:29:02 <kristnjov_> some weird name.
12:29:07 <Lor> epigram?
12:29:12 <kristnjov_> that's it
12:29:13 <stepcut`> yeah, that's the one
12:29:15 <stepcut`> thanks
12:29:20 <shapr> epigram
12:29:35 <jesse99> what's interesting about it?
12:29:48 <shapr> it's dependently typed, and it has a nifty interactive GUI
12:29:58 <Lor> Sounds like Alfa.
12:29:59 <shapr> you can incrementally type your program
12:47:50 <shapr> hi borism 
12:47:51 <shapr> greetz udo
12:48:21 <borism> hi all + shapr 
12:50:19 <ustenzel> hi shapr
12:51:02 <shapr> how's code?
12:52:54 <musasabi> A
12:53:10 <ustenzel> shapr, remember my finite map blowing up the stack some weeks back?
12:53:35 <ustenzel> I tried to isolate the problem to show you some code and suddenly the problem was gone.
12:53:59 <ustenzel> turns out I was too stupid to build a parser.
12:54:07 <shapr> what was the problem?
12:54:27 <shapr> your parser was recursive in the wrong direction?
12:54:42 <ustenzel> the parser was to parse one of two alternatives and then recurse
12:55:02 <ustenzel> well, I made both alternatives recurse independently
12:55:13 <shapr> ah
12:55:38 <shapr> did you end up looking at the bayes code?
12:55:42 <ustenzel> which made ReadP follow thousands of alternative parses, none of which could ever contribute to the result.
12:55:54 <ustenzel> no, completely forgot it.
12:56:17 <shapr> glad you found your problem :-)
12:56:39 <ustenzel> me too :)
13:00:06 <ustenzel> but thanks for your help, without it I'd never have looked in the right place.
13:00:11 <shapr> :-)
13:36:55 <Boegel> hello everybody :)
13:37:08 <Boegel> does someone have a bit experience with the FranTk library ?
13:37:34 <shapr> I've only read about it.
13:38:03 <Boegel> I'm wondering if it supports coloring pixel by pixel
13:38:17 <Boegel> like making your own images and stuff like that
13:38:43 <Boegel> because I would like to make a GUI for my future ray tracer in Haskell, but I need support for that kinda thing
13:39:13 * shapr doesn't know
13:39:38 <Boegel> me neither, and the manual isn't really that good :s
13:40:50 <Boegel> I've been searching on a problem with the basic ray trace algorithm for 2 days (in Java)
13:40:57 <Boegel> today I found it wasn't a problem
13:41:18 <Boegel> my program did what I had to do, I just thought it wasn't
13:41:21 <Boegel> :|
13:41:28 <Boegel> pretty stupid huh :p
14:18:12 <Boegel> it's pretty quiet here...
14:18:17 <Marvin--> yep
14:18:20 <Boegel> is the Haskell community dead ?
14:18:36 <Marvin--> no, just resting ;)
14:18:49 <Marvin--> (sorry, it had to be said)
14:20:12 <Boegel> why ? is Haskell to hard for people ?
14:20:22 <Igloo> Boegel: If you want a nice GUI I'd suggest wxhaskell or gtk2hs, i think. If you don't care about the UI I'd just write out PPM files
14:20:43 <Marvin--> hey Igloo
14:20:51 <Igloo> Evening Marvin
14:20:53 <Marvin--> gotten over your unsafeCoerce# trauma yet?
14:21:38 <Boegel> the problem is that my promotor likes FranTk very mutch :)
14:21:38 <Igloo> Got another one now, but that's probably just me being lazy and not looking for the magic function
14:22:03 * Igloo should fire off a few feature requests for the bits that I think really are missing
14:22:44 <Boegel> I'm thinking about extending FranTk myself, writing extra stuff for it, so that pixel actions are possible
14:22:51 <Boegel> but maybe that's a bridge too far
14:24:12 * Igloo would say any Tk interface just looks dated today, but maybe that's just me
14:24:49 * Boegel agrees, but remembers Igloo about the mathematical stuff underneath the whole thing
14:24:58 <Boegel> FranTk would be easier for that
14:25:10 <Boegel> and it's not like I will commercialize my ray tracer :p
14:25:17 <Boegel> *commercialise*
14:25:21 * Igloo has no experience with it - if it's nicer to use then fair enough  :-)
14:25:41 <Boegel> but I _will_ check out the other ones too
14:25:49 <Boegel> I haven't decided yet which one I'll use
14:25:59 <Boegel> now I'm wrestling with the basic ray tracing algorithm
14:26:04 <Boegel> and I'm learning a lot from it :)
14:36:07 <Marvin--> oof, look at the time
14:36:10 <Marvin--> I'm off to bed
14:36:25 <tic> lucky bastard :(
14:39:38 <Boegel> tic, oy _can_ go to bed if you want to
14:39:50 <Boegel> oy = you
14:39:58 <tic> Boegel, I can't. :(
14:40:06 <Boegel> why's that ?
14:40:09 <tic> Boegel, I've got a hand-in due tomorrow 10:00.
14:40:16 <Boegel> nice
14:40:19 <tic> which means I've got ~9 hours to finish it.
14:40:26 <Boegel> bit late ?
14:40:36 <Boegel> you should have started earlier, not ?
14:40:39 <tic> yeah, but I couldn't get any time with the professor until now, unfortunately.
14:40:52 <Boegel> nice :s
14:40:55 <tic> (yeah well, I could perhaps have done it a week ago, but then I had a lot of other things to do.)
14:40:56 <tic> mhm.
14:41:04 <tic> I have this long-running NN calculation...
14:44:41 <Boegel> what do you mean?
14:45:30 <tic> neural network.
14:45:34 <tic> have to wait for it to finish, etc.
14:45:36 <tic> takes some time.
14:47:02 <Boegel> I have had classes on neural networks
14:47:07 <Boegel> but never coded one
14:47:16 <tic> ah.
14:47:24 <tic> hopfield network.
14:47:43 <Boegel> don't know that one
14:47:50 <Boegel> it was an AI class, so very basic stuff
14:47:55 <Boegel> and boring if you ask me :p
14:48:47 <tic> ah
14:49:23 <Boegel> is it that hard ?
14:54:35 <tnks> you know. . . I tried to read up a little on what OCaml is, and it seems like it's trying to mix functional programming with OOP.
14:54:53 <tnks> But now that I'm using Haskel, I don't find that I really need objects in pure functional code.
14:55:03 <Boegel> off course not
14:55:11 <Boegel> that's the whole idea behind Haskell
14:55:23 <Boegel> actually your types are kinda objects
14:55:28 <Boegel> in a primitive kinda way
14:55:47 <tnks> But why did OCaml take so much pride in integrating the two ideas?
14:56:20 <tnks> Is it because some designs are well-oriented around objects?
14:57:05 <Boegel> I don't know OCaml, so I wouldn't know
14:57:11 <tnks> no problem.
14:57:17 <Boegel> but probably because they find their system works
14:57:28 <Boegel> and that they did a good job
15:05:02 <Boegel> I'm out
15:05:03 <Boegel> sleeping
15:05:10 <Boegel> lot's of luck with your mission tic
15:05:25 <tic> thanks!
15:05:26 <tic> ninte
16:41:27 <TheHunter> congratulations, igloo and kosmikus|away
16:43:41 <Igloo> Thanks  :-)
16:44:52 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers!"]' by Igloo
16:45:15 <Riastradh> You guys won, Igloo & kosmikus?
16:45:45 <Igloo> And Heffalump and someone who was on once or twice, possibly as Duncan
16:46:06 <Riastradh> What sort of approach did you use?
16:46:07 <Igloo> http://www.cis.upenn.edu/proj/plclub/contest/results.php#first
16:46:54 <monochrom> icfp?
16:47:11 <Igloo> http://urchin.earth.li/icfpcontest/2004/Introduction
16:48:11 <Riastradh> Hmmm.  Apparently we didn't do so well.
16:48:19 <Igloo> Our strength was the combination of the Keeper (link at the top of that page) and being good at collecting food due to marking routes to food and back home
16:50:05 <stepcut`> take that ocaml!
16:50:13 <Riastradh> Pretty nice how the top three entries are all Haskell.
16:50:35 <stepcut`> oh how the tides have turned! mwuhahaha
16:50:48 <Igloo> Tomorrow, the world!
16:51:29 <stepcut`> soon haskell will be so pervasive even Microsoft will have to make their own version!!
16:51:36 <stepcut`> oh wait...
16:53:42 <Igloo> :-)
16:57:00 <emu> The judges hastily declare: "Java and C++ are very suitable for rapid prototyping."
16:57:04 <emu> hastily indeed
17:00:27 <Igloo> Riastradh: Who were you?
17:00:27 <Riastradh> #scheme
17:00:55 * Riastradh mutters in a small voice '355th place.'
17:01:22 <Igloo> Ah  :-/
17:01:39 * Igloo tries to remember what the darcs team was called
17:03:00 <emu> the sheer number of C++ entries astounds me
17:03:29 <Igloo> Imperative languages normally have a higher proportion that that don't they?
17:03:53 <emu> trying to spend a weekend doing C++ straight with no breaks would leave me insane by monday
17:04:03 * emu knows, had to do 18 hours of C++ once
17:34:57 <TheHunter> good night and congrats to you and your team, Heffalump 
17:40:15 <chris> Igloo: Congrats!
17:41:29 <Heffalump> I advertised darcs in my comments when they gave it to us, btw :-)
17:42:08 <Igloo> Cool  :-)   And it's on the results web page too
17:42:12 <Riastradh> We used Darcs too!
17:42:20 <TheJohn> ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
17:42:22 * Riastradh tags along behind the winners.
17:42:45 <Heffalump> riastradh: I hear you used this inferior programming language for your actual code, though...
17:42:50 * Heffalump makes use of his unlimited bragging rights
17:42:55 <Igloo> :-)
17:43:15 <Riastradh> No way, Heffalump.  Our _Scheme_ code worked just fine.  It's the authors of the _ant_ code that screwed up, and I wasn't one of 'em!
17:43:36 <Heffalump> so what did you do?
17:44:11 <Riastradh> I wrote a compiler from a higher-level ant language to the lower-level ant FSM description and some simulation code.
17:44:34 <Heffalump> well, if you'd used a decent language, you wouldn't have had to spend all your time on that, and could have helped with the ant itself..
17:45:11 <Riastradh> No, I _deliberately_ avoided working on the ant itself; there were four other people to do that, and I haven't the faintest idea about good ant strategies.
17:45:27 <Igloo> Neither did your teammates, apparently  :-)
17:45:37 <Riastradh> Well, yeah, that was the problem.
17:45:56 <Riastradh> Their strategization was a rather fruitless strategy.
19:18:54 <crackhead> could anyone tell me how to write a merge function?
19:19:52 <monochrom> Yes.
19:20:14 <monochrom> Suppose one of the two input lists is empty.  You know what to do.
19:20:57 <monochrom> Otherwise, both lists are non-empty.  You can peel off the first elements from both input lists, and you know what to do, too.
19:35:29 <crackhead> monochrom: I didn't understand a word of what you said
19:36:17 <crackhead> another question...what does this mean [['a','b'],['b','c']] :: [[Char]]
19:36:36 <crackhead> I don't understand what the [[Char]] means
19:37:31 <crackhead> monochrom : how do you "peel off the first elements"
19:42:04 <monochrom> pattern matching
19:42:46 <crackhead> what is pattern matching....the peeling off?
19:42:56 <crackhead> sorry man...I'm kinda lost with all this haskell
19:43:59 <monochrom> things like "merge (x:xs) = ..."
19:44:41 <monochrom> It is not confusing.  Suppose I am to teach a kid to merge manually.  I will say exactly those words I have said to you.
19:44:58 <monochrom> And the kid will understand.
19:45:42 <monochrom> It is actually more intuitive to use recursion: I just tell the kid "repeat the same method to the rest of the data".
19:45:51 <crackhead> hmmmm....I'm suppose to write: merge :: [Int] -> [Int] -> [Int]
19:45:59 <monochrom> It is harder to tell the kid "keep two indexes/pointers in your head".
19:48:03 <crackhead> I'm reading through some examples and I'm trying to figure out what this means:
19:48:25 <crackhead> map :: (a->b) -> [a] -> [b]
19:48:39 <crackhead> can you tell me what that means?
19:49:08 <monochrom> http://www.cs.utoronto.ca/~trebla/fp/lecture-03.pdf
19:55:54 <Cale> map is a function which takes a function from a's to b's and a list of a's and produces a list of b's.
19:56:05 <Cale> (is what that says)
19:57:22 <crackhead> cool
20:00:06 <shammah> almost, .... a's to b's and returns a function that takes a list of a's....
20:01:12 <Smerdy> Hello, folks. shapr has gone and banned me again for questionable reasons. Can anyone remove the ban (on just my usual nickname)?
20:13:45 <crackhead> squareList (x:xs) = square x : squareList xs
20:13:56 <crackhead> what exactly is this saying?
20:14:39 <Smerdy> crackhead, you should probably read a Haskell tutorial from the beginning.
20:15:45 <crackhead> yea
20:15:54 * crackhead I'm a bitch
20:16:21 <crackhead> I've been under a lot of stress
20:17:51 <crackhead> ok...I think I understand now
21:35:27 <crackhead> can anyone tell me what 'quot' is?
21:37:09 <Heffalump> quotient?
21:40:36 <monochrom> Try quot 10 6
23:49:41 <earthy> dang! dunkosmiloolump won the icfp contest...
23:51:54 <earthy> congrats, hef, igloo, kosmikus!
