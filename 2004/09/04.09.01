00:02:54 <pesco> Gah, I'm reading a book on lambda calculus and one about linear algebra in parallel. Feels a bit like switching back and forth between emacs and vi. (because of the different meanings of lambda)
00:22:29 <kosmikus|away> xkb: if I remember correctly, there exists a pure Haskell implementation (without views) -- the views are mainly used for reasons of presentation
00:57:33 <xkb> kosmikus, ah... neat
00:57:50 <xkb> As I understand it, views are just a simple source to source transformation
01:26:00 <musasabi> hmm one can propagate errors on existentially typed channels ^_^
01:26:11 <musasabi> feed (RSChan ch) str = (readIO str `catch` (\_ -> return undefined)) >>= writeChan ch
01:45:10 <musasabi> Is there a way to do tryReadMVar in a safe way?
01:47:52 <musasabi> That is "if the MVar contains a value return it without taking it away"
01:49:38 <musasabi> I don't see a way to do it with the current semantics :-(
02:20:09 <Lunar^> musasabi: Why ?
02:23:48 <musasabi> Lunar^: all approaches seem to contain races. (I can post explanation why in 2min)
02:24:05 <Lunar^> musasabi: haskell-cafe ?
02:25:16 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/tryReadMVar.txt (was writing for haskell-cafe)
02:26:09 <musasabi> can you see a trivial mistake there?
02:29:45 <Lunar^> musasabi: No... 1 minute, I would like to read PrimOps.cmm again
02:41:22 <musasabi> doing it in C seems easy...
02:45:15 * musasabi posts to haskell-cafe
02:48:45 <Lunar^> musasabi: Strange there's no locking in PrimOps for takeMVar
02:48:55 <Lunar^> tryTakeMVar, sorrf
02:49:42 <Lunar^> mhhh in fact, there is... I need to learn Cmm
02:52:01 <Lunar^> anyway, I think you could manage to implement your own TryableMVars with a tuple of MVar with one doing the locking
02:52:15 <Lunar^> As Chan implementation
02:53:55 <musasabi> Seems like a lot overhead (2 Mvars instead of 1) for little good.
02:56:13 <Lunar^> sure
04:24:32 <goron> How expensive is it to catch an error in terms of number of instructions? 
04:27:12 <Igloo> I have no idea, but I don't think you should be catching errors often enough to care
04:31:18 <goron> Igloo: Well, there is this guy, that thought it was nice to use error for functional code. So when I to (insNode (1,()) (insNode (1,()) empty, I get an exception, while this imo should not be.
04:31:27 <goron> to->do
04:31:53 <goron> and soem bad parentheses...
04:32:01 <goron> soem->some
04:48:35 <musasabi> goron: do you mean an exception or Either ?
04:58:34 <goron> musasabi: exception
05:03:00 <musasabi> goron: well it is not free, but if it becomes a bottleneck then the design is very very bad.
05:06:24 <goron> musasabi: I could always hack the sources of FGL... but what's "not free"?
05:09:09 <musasabi> goron: http://shootout.alioth.debian.org/bench/except/detail.php?g++=on&ghc=on&java=on ;)
05:11:53 <musasabi> goron: fast enough ;)
05:12:03 <musasabi> of course depends on what you are doing.
05:12:05 <goron> musasabi: That's for something with true IO, but I only use error. 0.22 sec cpu time is slow, imo.
05:13:01 <musasabi> goron: for 200000 exceptions?
05:13:08 <goron> musasabi: Thanks for the link though. 
05:13:16 <goron> musasabi: Oops.
05:13:34 <goron> musasabi: I assumed it was 1 exception :)
05:13:49 <goron> musasabi: Then it's pretty fast.
05:14:05 <musasabi> yes, certainly faster than in languages like C++.
05:14:54 <musasabi> then again that is only natural.
05:15:27 <goron> It's only _a_lot_ harder to catch one. :) You need monadtransformers to do so.
05:15:52 <goron> I mean standard calls to error.
05:16:13 <goron> Normal IOErrors can be catched more easily. 
05:17:26 <musasabi> well using Control.Exception is quite easy.
05:18:49 <goron> Well, I meant without the IO monad. 
05:19:08 <goron> I used unsafePerformIO with ErrorT. 
05:19:39 <musasabi> sounds nasty
05:19:42 <goron> A guy in the channel helped with it. It's great wiki stuff, maybe I put it there sometime.
05:20:12 <goron> It's an excellent workaround for people that use error too much.
06:15:24 <Iter> anyone around?
06:15:34 <Lemmih> Yep.
06:16:05 <Iter> wondering if anyone would mind having a quick look over a blog post to see if I've made any glaring errors?
06:16:14 <Lemmih> Sure.
06:16:33 <Iter> http://etymon.blogspot.com/
06:16:56 <Iter> Language in question is java (unfortunately).
06:17:10 <Iter> Thanks.
06:20:34 <goron> Why do you spend your time on Java? Do you want to convert some people? lol
06:22:59 <Iter> goron, nope.  But I do have to live there @work, so I would like my fellow comrades in the gulag to do a better job for my own selfish benefit ;)
06:23:31 <Lemmih> Iter: I think you should find someone more qualified than me to look over your post (-:
06:24:33 <Iter> Lemmih, that's alright.  People more qualified than me will eventually look over it; I was just hoping to get some early feedback :).
06:57:38 <Iter> btw. can someone point me at definition/discussion of points-free style?
06:59:00 <Igloo> Point free style just means  "foo = bar . baz" rather than "foo x = bar $ baz x" or "foo x = bar (baz x)"
07:01:08 <Iter> Fair enough.  And here I was thinking I was going to have to think hard to understand this :)
07:01:36 <musasabi> monadic conversion becomes harder in point freee style sometimes.
07:01:48 <musasabi> but it is nifty for passing parameters...
07:02:41 <Igloo> It can still trip you up. Rewriting "foo x y = bar $ baz x y" as "foo = bar . baz" is a common mistake
07:03:27 <Iter> Currently reading "Genuinely Functional UI's", and they mentioned needing to define signal transformers in 'points-free style', so thought I should work out what they meant by that.
07:04:25 <Iter> foo = bar . baz ==> foo x y = (bar $ baz x) y ?
07:24:17 <SyntaxNinja> can people 'host www.syntaxpolice.org' and let me know if it resolves to something starting with 64 for anyone? 
07:25:05 <Igloo> 216.226.142.131
07:25:12 <rc51> syntaxpolice.org has address 64.46.156.23
07:25:49 <SyntaxNinja> curses!
07:25:51 <SyntaxNinja> ;)
07:25:56 * SyntaxNinja wants it to be 64
07:26:01 <flaw> syntaxpolice.org has address 216.226.142.131
07:26:02 <rc51> Mine was from Toronto, Canada.
07:26:11 <rc51> syntaxpolice.org has address 216.226.142.131 From London, England.
07:26:49 <SyntaxNinja> OK thanks guys.
07:27:04 <flaw> 216 from all my shells too..
07:27:43 <rc51> It just takes a while for DNS to propagate.  When did you make the change?
07:28:25 <SyntaxNinja> rc51: yeah, I know.  I made the changes maybe a week ago, but there may have been a problem with the primary server, and that was fixed two days back, but I would expect it to have propagated a little further by now if that were fixed. idono.
07:29:00 <flaw> how long was ttl? (that has influence here, doesnt it?)
07:29:31 <SyntaxNinja> hm. I don't know. how do I find that out?
07:30:14 <flaw> dig www.syntaxpolice.org
07:30:20 <Igloo> 2 days off for my nameserver here if "dig -t any syntaxpolice.org" numbers mean what I think
07:30:25 <flaw> aye
07:31:10 * Igloo can't see the actual TTL anywhere and can never remember the right incantations as I do these things too rarely
07:31:24 <SyntaxNinja> OK then I won't worry about it for a while.
07:31:26 <flaw> I think it's specified right there..
07:31:34 <flaw> syntaxpolice.org.       2D IN A         216.226.142.131
07:31:40 <flaw> 2D = 2 days?
07:31:55 <musasabi> syntaxpolice.org has address 216.226.142.131
07:32:08 <Igloo> I see "syntaxpolice.org.       172387  IN      A       216.226.142.131" where the number goes down as time elapses
07:34:02 <Igloo> Err, ns1.syntaxpolice.org and ns1.infinitedata.net both seem to think it has address 216.226.142.131
07:35:06 <flaw> yep, shows that way for me too
07:35:44 <flaw> SyntaxNinja: dig @ns1.infinitedata.net www.syntaxninja.org
07:35:58 <Igloo> Or "host www.syntaxpolice.org ns1.infinitedata.net"
07:36:21 * Igloo suspects they fixed it in the wrong direction, anyway
07:38:24 <SyntaxNinja> yeah, the dns should get changed to monk.area614.net soon
07:38:40 <SyntaxNinja> so those who see 64... probably see that.
07:57:27 <roconnor> Is there a standard library function that composes a function with itself n times?
08:01:20 <Igloo> Not in one swoop
08:01:59 <Igloo> iterate f !! n or foldr (.) id $ replicate n f or something should do it, though
08:12:40 <roconnor> okay
08:12:59 <roconnor> I wrote my own. ... I called the function church.
08:14:15 <roconnor> I even used the (n+1) pattern match. I've decided (n+k) patterns are not evil.  I could be wrong about that though.
09:44:19 <stepcut> lets say I define a function that does (host,share) -> "//" + host + "/" + share, and another function that takes the "//host/share" -> (host,share). (add the restriction that host and share can not contain the / character). Would this be an example of an isomorphism? 
09:44:43 <basti_> hm
09:44:57 <basti_> an isomorphism usually is quality "across an operation"
09:45:00 <basti_> e
09:45:46 <stepcut> hrm
09:46:00 <cptchaos> basti_: in mathemtics?
09:46:00 <basti_> you could say, that maybe "5"."8" = "58"  then you could say "5"=5, "8"=8, 5*10+8 = 58 ="58"
09:46:33 <basti_> then the structures "" and . resp. 'numbers' and the operation *10+ would be isomorph
09:46:51 <stepcut> basti_: makes sense
09:46:56 <basti_> cptchaos i'd hope ;)
09:47:36 <cptchaos> basti_: right, isomorphisms are structure s
09:47:36 <Igloo> I'd say the shot/share thing was an isomorphism
09:47:40 <cptchaos> perserving mappings
09:48:05 <basti_> shot/share?
09:48:10 <Igloo> host/share
09:48:15 <basti_> oh
09:48:17 <basti_> hm
09:48:20 <basti_> but in what sense?
09:48:35 <Igloo> Well, actually, I wouldn't, because it would be a fairly pointless thing to want to say, but if someone else said it I wouldn't disagree
09:48:41 <basti_> hehe
09:48:57 <stepcut> so, I actually have the two functions mentioned above, and I want to indicate that when converting from (home,share)->"//"+host+"/"+share -> (home',share'), the properties home==home' and share==share' will always hold true..
09:49:14 <Igloo> There are a set of things of the form (host, share) and a set of things of the form "//host/share", and there is an isomorphism between the two sets
09:49:22 <Igloo> Maybe that's not what stepcut intended, though
09:49:23 <basti_> hmm okay.
09:49:58 <stepcut> Igloo: i think what you said is what i intended :-/
09:50:19 <Igloo> In practice I think I'd be more likely to want to say there's a bijection between them, though (which amounts to the same thing)
09:50:31 <basti_> yes, when youre talking about sets only
09:50:50 <basti_> without any operation
09:51:45 * stepcut reads about bijection
09:52:51 <cptchaos> most isomorphisms include operations. 
09:53:04 <Igloo> There is implicitly the operation \(h, s) -> "\\\\" ++ h ++ "\\" ++ s and its inverse, though
09:54:03 <basti_> an isomorphism is a bijection between sets that preserves the structure of the operations
09:54:35 <cptchaos> basti_: yes,
09:54:47 <cptchaos> s/,/./
09:54:57 <basti_> i think we got it now
09:54:59 <basti_> :P
09:55:50 <cptchaos> acually the word means "equal shaped"
09:56:46 <Igloo> It's preserving the semantics in this case, I'd say, i.e. the location
09:57:25 <Igloo> But it all depends on what definition you choose, and like I say, I don't think I'd actually have reason to call it one
09:58:10 <basti_> k
09:59:47 <stepcut> so, going back to my actual problem, would it be better to say the functions for converting between '(host,share)-> \\host\share' are bijective ?
10:00:05 <basti_> yes i think.
10:00:07 <basti_> :)
10:00:40 <cptchaos> for isomophims they should
10:01:22 <Igloo> The function for converting '(host,share)->\\host\share' {is a bijection|is bijective}.
10:01:34 <Igloo> The functions for converting '(host,share)<->\\host\share' are inverses.
10:02:22 <musasabi> your problem is that String <=> (host,share) is not true.
10:02:35 <stepcut> musasabi: ?
10:03:14 <musasabi> stepcut: expressing the type to which the bijection occurs in a meaningfull way makes litlle sens.
10:03:18 <musasabi> *sense
10:03:20 * musasabi is sick
10:04:16 <cptchaos> the exact definition (as in group theory) is: give are to peers of an set and an operator (M,*::M->M->M) (N,+::N->N->N)
10:04:35 <cptchaos> an function is called isomophism, if
10:04:51 <cptchaos> it is bijective,
10:05:47 <cptchaos> and if (let the function be f:M->N ) f(a*b) == f(a)+f(b)
10:06:00 <cptchaos> for all a,b in M
10:07:02 <cptchaos> (beware I'm not trained in translating Math from german to english)
10:07:33 <cptchaos> used haskell notations here
10:07:34 <basti_> lol
10:20:48 <stepcut> so, going back to my original problem, what would be a clear way to indicate that when converting back and forth between (host,share)<=>\\host\share, there is no loss of information, that each mapping is unique? So far Igloo's suggestion seems the best "The function for converting '(host,share)->\\host\share' {is a bijection|is bijective}."
10:22:03 * arauko wonders if there is anyone from UK here
10:22:17 <shrimpx> by "indicate" you mean encoding that property in code, or writing a comment about it? :)
10:22:33 <stepcut> sorry, write about in an email
10:23:26 <stepcut> there is a debate, do I need to store host,share, and \\host\share, or can I *just* store \\host\share. 
10:23:47 * Igloo is from the UK
10:24:55 <stepcut> So, I wanted to state that it is acceptable to store on \\host\share, because you can always correctly figure out (host,share) if you have \\host\share.
10:24:59 <shrimpx> just \\host\share if there's the mapping is one-to-one and onto :)
10:25:05 <shrimpx> s/there's//
10:25:23 <stepcut> shrimpx: aka, bijective
10:25:38 <Igloo> Given no \s in host I'd say "You're all stupid! We can just store '\\host\share' with no loss of information!"
10:25:55 <cptchaos> htere is as long host and share don't contain / , ( , or )
10:26:23 <cptchaos> the slash is wrong
10:26:30 <cptchaos> meant \
10:26:40 <stepcut> right
10:26:47 <Igloo> (don't forget to insult them or the thread might peter out before the real flames start flying, though)
10:27:10 <Marvin--> Igloo: you read too many Debian lists
10:27:28 <Igloo> When I'm older, I want to be asuffield.
10:27:37 <shrimpx> stepcut: ya, bijective
10:27:43 <stepcut> Igloo: haha
10:27:58 <Marvin--> Igloo: oh dear lord, another asuffield is the last thing we need
10:28:13 <shrimpx> stepcut: be as formal as possible, especially if the people you're dealing with are vbscript kiddies
10:28:13 <Igloo> :-)
10:28:54 <stepcut> is it wrong to say, bijective mapping, (in the same line as atm machine, pin number, etc)
10:29:14 <basti_> i dont think so.
10:29:23 <shrimpx> me neither
10:29:45 <Igloo> bijection is shorter and means the same, though
10:30:25 <Marvin--> I'd be a bit surprised to read "bijective mapping" on the same line as "atm machine" and "pin number", but sure...
10:30:27 <stepcut> can I say, the conversion between (host,share)->\\host\share is bijective ?
10:30:56 <Marvin--> stepcut: I'd replace the arrow with "and"
10:31:04 <stepcut> Marvin--: good point.
10:31:24 <Marvin--> what game are we playing here anyway?
10:31:38 <stepcut> "The conversion between (host,share) and \\host\share is bijective."
10:32:43 <stepcut> Marvin--: I am trying to learn how to properly use terms like bijective and *morphism to communicate clearly and precisely with people that understand what those words mean. But I don't know what those words mean yet :)
10:33:22 <Marvin--> stepcut: so, in essence, you're trying to show off? ;)
10:34:18 <stepcut> Marvin--: mostly. But it would also help me read whitepapers that talk about those things ;)
10:35:01 <Marvin--> fair enough :)
10:35:24 <shrimpx> you should give a formal proof for why it's bijective
10:35:43 <stepcut> heh
10:35:48 <musasabi> stepcut: f : A -> B is bijective iff. exists g such that g . f = id in A and f . g = id in B.
10:36:00 <Marvin--> <Riastradh> There's no Greek letter for it that I can confuse people with?
10:36:11 <stepcut> Marvin--: haha, I love that one
10:36:13 <shrimpx> hah
10:36:31 <Marvin--> oh, be sure to mention that the function converting "\\host\share" to (host,share) is partial
10:37:10 <stepcut> Marvin--: partial, because its only valid for some values of host and share ?
10:37:19 <Marvin--> partial because it's not valid for all strings
10:37:23 <Igloo> Not in the presence of the side condition he gave
10:37:31 <shrimpx> heh
10:37:32 <Marvin--> oh, I must've missed that
10:37:39 <Igloo> That's what you get for turning up for class late  :-)
10:37:45 * Marvin-- grumbles
10:37:47 <edwinb> that would stop it being a bijection surely... (sorry, came in late too ;)
10:38:31 <stepcut> edwinb: a bijection can't have a limited domain ?
10:38:35 <shrimpx> invent a type system where you can express teh type "\\", arbitrary string, "\", arbitrary string
10:38:51 <edwinb> To be honest, I'm not sure ;)
10:38:56 * edwinb looks it up
10:39:14 <Igloo> I'm sure it can
10:39:14 <Marvin--> well, with f : A -> B, you can say that f : A -> f(A) is bijective
10:39:30 <stepcut> edwinb: this page seems to indicate domains are ok: http://en.wikipedia.org/wiki/Bijection
10:39:54 * roconnor reading back
10:39:56 <edwinb> Hmm, f only has to be surjective, which I don't think implies total.
10:40:30 <basti_> ?
10:40:36 <shrimpx> ya
10:40:43 <edwinb> I'll go back to sleep now...
10:41:01 * esap thinks about the recursion in 'f : A -> f(A)'
10:41:02 <roconnor> An isomorphism is (one of) a pair of morphisms f: A -> B and g : B -> A such that f . g = id[B] and g . f = id[A]
10:41:36 <roconnor> the definition comes from catagory theory.
10:41:45 <Marvin--> esap: well, make it  f : A -> B  and  f' : A -> f(A)  then
10:42:08 <esap> marvin: sure, that's the boring version of it.. :-)
10:43:43 <esap> marvin: The interesting is that 'f : A -> f(A)' doesn't seem to as such specify anything as a codomain of f.
10:44:24 <shrimpx> f has any codomain
10:44:36 <shrimpx> if that were legal
10:44:43 <esap> no, if you have f : A -> B, then B is the codomain.
10:45:37 <esap> But for f : A -> f(A), you clearly have some _specific_ codomain, you just don't know what it is.
10:46:01 <shrimpx> well, for f : A -> f(A), any function works as long as it takes elements from A to something arbitrary
10:46:10 <esap> It's not quite the same as f : A -> _|_ though.
10:46:32 <Marvin--> with  f(A)  I mean  { f(x) | x \in A }  if that was unclear, btw
10:46:41 <esap> marvin: yes, that's clear.
10:46:47 <shrimpx> ya
10:47:07 <Marvin--> you never know if people use different notation :)
10:47:32 <roconnor> A bijection is a function that is one-to-one and onto.  I beleive that bijections the same as isomorphism under the assumption of the axiom of choice.
10:48:00 <esap> roconnor: hmm.. why would axiom of choice make bijections the same as isomorphisms?
10:48:11 <roconnor> But without choice, you cannot always make an inverse function, so you might have a bijection without an inverse.
10:48:32 <roconnor> I may be recalling incorrectly here.
10:48:56 <shrimpx> well an isomorphism is a bijection by definition, no?
10:49:11 * esap is looking up axiom of choice from Lawvere's book.
10:49:22 <roconnor> shrimpx: See my definitions of the two above.
10:49:30 <Marvin--> yes, an isomorphism is a bijective homomorphism, isn't it?
10:49:35 <shrimpx> ya
10:50:45 <roconnor> bijection => one-to-one (injective) and onto (surjective).  isomorphism => has an inverse fuction.
10:51:06 <roconnor> bijection => one-to-one (injective) and onto (surjective).  isomorphism => has an inverse morphism.
10:51:20 <roconnor> (morphisms may not be functions).
10:51:23 <stepcut> roconnor: doesn't bijection imply there can be an inverse function ?
10:51:54 <Marvin--> in group theory, at least, isomorphisms and homomorphisms are structure-preserving
10:51:56 <roconnor> stepcut: My claim is that such reasoning requires the axiom of choice.  So sure.
10:52:23 <stepcut> roconnor: sorry, I didn't read back far enough
10:52:45 <esap> bijection preserves number of elements, not necessarily structure.
11:07:19 <roconnor> Hmmm, since the inverse of any element through a bijection is a a set of 1, I suppose you don't need the axiom of choice to produce an inverse.
11:08:04 <roconnor> Of course, esap correctly notes that the inverse function may not be a morphism in your catagory.
11:44:23 <goron> Anyone using XTerm?
11:44:36 <Marvin--> not unless I can help it :)
11:45:07 <goron> How can I change the number of lines in can scroll back?
11:45:28 <goron> I forgot xrdb ...
11:46:36 <goron> Marvin--: Thanks for the help ;) It works...
11:47:02 <Marvin--> xterm -sl  iirc
11:47:13 <monochrom> XTerm*saveLines:        1500
11:47:54 * Marvin-- has his gnome-terminals set to remember 5000 lines
11:48:57 <SyntaxNinja> Marvin--: how do you set that?
11:49:08 <goron> My gnome-terminal is so stupid that it doesn't do unicode. 
11:49:14 * goron is addicted to unicode.
11:49:27 <SyntaxNinja> oh, I se.
11:49:29 <Marvin--> SyntaxNinja: uh, Edit -> Current Profile, and then the Scrolling tab?
11:49:48 <Marvin--> goron: eh? works perfectly for me
11:50:01 <SyntaxNinja> I want to set it for all my profiles, though :)
11:50:29 <goron> Marvin--: Well, it was saying it used Unicode, in the used character set, but it borked. 
11:50:32 <monochrom> I have only one profile.  Therefore I have that setting for all my profiles :)
11:50:39 <Marvin--> same here ;)
11:50:42 <goron> same here.
11:50:52 <goron> Oh, no I am lying.
11:51:05 <goron> I also have a kernel profile.
11:51:11 * SyntaxNinja uses different profiles for each server I use, "open tab> cvs.haskell.org" will open up a new tab, ssh to cvs.haskell.org, and I have a different background color for each server.
11:51:13 <SyntaxNinja> very useful.
11:51:14 <goron> For compiling kernels.
11:51:33 <goron> SyntaxNinja: How's Cabal?
11:51:55 <SyntaxNinja> goron: not bad. I'm working on preprocessors. 
11:52:35 * Marvin-- is almost disappointed that gnome-terminal didn't switch to right-to-left when he pasted some arabic characters
11:52:39 <goron> I noticed that it's pretty hard to write an efficient program in Haskell. 
11:53:23 * roconnor bites his tounge.
11:53:35 * goron off to debug.
11:55:35 * Riastradh bugs goron's program.
11:55:51 <goron> Stop bugging me!
11:56:08 <goron> He, shit, my program can talk :)
11:56:16 * Riastradh inserts unsafePerformIOs and type errors into goron's program.
11:56:32 <goron> I already have unsafePerformIO :)
11:57:05 * Riastradh inserts unsafePerformIOs in unsafe locations.
11:59:07 <goron> Whatever...
11:59:16 <goron> ;)
12:04:51 <musasabi> hmm why does this not work:
12:04:54 <musasabi> class FMA a r | a -> r where fma :: a -> r
12:05:01 <musasabi> data FMAVar = forall a r. FMA a r => FMAVar a
12:05:12 <musasabi> instance FMA FMAVar r where fma (FMAVar f) = fma f
12:06:39 <musasabi> That is how do I specify that the functional dependency is tied inside of the existential
12:08:58 <xkb> hi.. Im trying to do a quicksort on a list of tuples..
12:09:08 <xkb> using this list comprehension:
12:09:54 <xkb> [z | z<-xs, snd x <= snd z] etc
12:10:03 <xkb> however I get runtime errors on this
12:10:06 <ustenzel> musasabi: you are confused.  given "instance FMA FMAVar Foo" there can be no "instance FMAVar Bar", thanks to the fundep
12:10:11 <xkb> snd x :: Int
12:10:35 <ustenzel> musasabi: the fact that you put a variable there leads me to think you are... well... confused.
12:12:08 <ustenzel> xkb: what runtime error?  my crystal ball seems to be defective.
12:12:35 <xkb> ustenzel, hehe
12:12:41 <xkb> Ill run the program again
12:15:53 <musasabi> ustenzel: hmm that is very true.
12:16:01 <xkb> ustenzel, Program error: {freqListSort []}
12:16:06 <xkb> in hugs that is
12:16:59 <ustenzel> xkb: you probably forgot to tell hugs how to sort a list consisting of only one element.  guessing wildly, that is.
12:20:10 <musasabi> I am able to create polymorphic lists out of which I can select things based on type.
12:20:37 <musasabi> now I want to wrap the thing in a existential but that causes headaches.
12:20:54 <musasabi> as "data HVar = forall l. HList l (forall r. r) => HVar l" is not valid...
12:22:52 * musasabi ponders doing the wrapping in an another order
12:26:11 <xkb> ustenzel, I added the empty case to the function and indeed it works
12:27:18 <ustenzel> musasabi: what do you want to accomplish with the instance declaration above?
12:28:46 <musasabi> ustenzel: seek the holy grail?
12:29:19 <musasabi> ustenzel: I got type based selection with keys work in a alist, now I am wondering how to do it with a finitemap.
12:30:00 <ustenzel> musasabi: anayway, first you tell the compiler, in "FMA a r" r can be derived from a
12:30:56 <ustenzel> musasabi: then you add that in "FMA FMAVar r" the r is not derived from the type FMAVar but by looking inside a value of type FMAVar.  this can't both be true.
12:32:26 <musasabi> yes, I see why that cannot work.
12:32:53 <musasabi> Is there any way to make heterogenous Finitemaps ? (like it is possible for lists)
12:33:39 <ustenzel> just dont write "instance FMA FMAVar r" anywhere...
12:34:07 <ustenzel> FiniteMap key FMAVar should work just fine
12:35:01 <ustenzel> musasabi: but think ahead --- if you got the map, what will you do with its contents?
12:36:31 <goron> How can I set the stacksize as commandline option in ghci?
12:36:36 <musasabi> but defining "ffma (FMAVar v) = fma v"
12:36:46 <musasabi> does not work either.
12:37:19 <ustenzel> how would it?  "fma v" has *some* type.  what do you do with a value that does'nt have a known type?
12:37:23 <musasabi> bacause of the functional constraint the type escapes/
12:37:27 <musasabi> *because
12:37:37 <ustenzel> no, the type isn't known.  
12:38:02 <ustenzel> please fill in the X in "fma :: FMAVar -> X"
12:41:09 <goron> Where's the pdf version of the ghc documentation? They had one in ghc 5.04.
12:41:19 <musasabi> hmm that is not possible.
12:41:55 <musasabi> goron: http://www.haskell.org/ghc/docs/latest/users_guide.ps.gz ?
12:42:52 <goron> musasabi: Hmm... ok...
12:45:09 <ustenzel> musasabi: see, if X cannot be filled in, there is not a single function you could apply to it.
12:45:57 <ustenzel> musasabi: therefore it is no loss you cannot make a map containing these thing, it doesn't matter if you throw them away before or after mapping them.
12:47:47 <musasabi> all true... 
12:47:59 * musasabi goes back to plotting
12:49:07 <goron> Is it necessary to compile the program to change the stack size?
12:49:16 <keverets> no.
12:49:44 <keverets> run it with "myprog args +RTS -K(size)" (I think)
12:50:24 <goron> keverets: I want to change the stack size in ghci.
12:50:51 <goron> keverets: I assume myprog can not be ghci.
12:51:31 <keverets> goron: never tried that.  I think it might work, regardless "ghci +RTS -K5000000" or something.
12:52:25 <roconnor> Do concerns about tail-recursion even apply to Haskell since it is compiled to a G-machine?  Did I ask this question before?
13:09:23 <goron> How can I show how many memory is used by ghci in the call to a certain expression? I know there is such an option, but I couldn't find it.  
13:09:44 <keverets> +s ?
13:10:06 <keverets> :set +s
13:10:08 <keverets> that is
13:11:04 <ustenzel> goron: What is it?  Stack overflow?
13:11:47 <goron> ustenzel: Yes
13:12:24 <goron> ustenzel: Do you have any cure?
13:12:39 <ustenzel> goron: more stack won't help.  you have a problem with too much lazyness in the wrong place and either your heap or your stack will blow, no matter how large.
13:13:39 <ustenzel> goron: cure?  no... only common sense, and that isn't helping me much.
13:14:47 <ustenzel> goron: can you paste the code somewhere?  I'd like to have a look.
13:14:52 <goron> This seems unhealty... : (11.20 secs, -3622544172 bytes)
13:15:05 <goron> add h.
13:15:21 <roconnor> ``too much laziness can cause the heap or stack to blow, no matter how large.''  That seems impossible for a program that will terminate.
13:15:26 <goron> I use a negative number of bytes.
13:15:52 <goron> I got this result by interrupting the program. 
13:17:10 <ustenzel> roconnor: due to lazyness you often get linear space usage where constant is expected.  add large input to that and any heap overflows.  happens to me all the time.
13:17:57 <goron> ustenzel: So I should add strictness flags?
13:18:01 <roconnor> ustenzel: Oh, I could believe that.  Do you know a quick example off the top of your head?
13:18:13 <roconnor> If you don't that's okay
13:18:47 <ustenzel> roconnor: yeah. parse a file into pairs of something, put them into a finite map.
13:19:23 <ustenzel> roconnor: adds space for lots of unevaluated "addToFM" calls on top of the space you really need.
13:19:36 <goron> ustenzel: Well, I use _a_lot_ of finite maps...
13:20:25 <goron> But do you know of any quickfix?
13:20:34 <ustenzel> goron: if they are static (built once, read multiple) or if they are continually updated, strictness flags could help.
13:20:44 <roconnor> Doesn't that just convert an O(n) space into O(2n) space?  Not really a change in order.
13:20:50 <ustenzel> no, i really, really wish i had a quick fix.
13:21:21 <goron> ustenzel: And when wouldn't they help? It seems you covered all the cases...
13:21:44 <ustenzel> roconnor: not if the entries are often combined
13:21:48 <goron> Does compilation help a lot?
13:22:31 <ustenzel> come to think of it... a FiniteMap should probably always be strict.
13:23:59 <roconnor> ustenzel: as in addToFM will ``overwrite'' existing keys.
13:24:59 <ustenzel> roconnor: or as in addToFM_C will combine values.
13:25:44 <roconnor> ustenzel: Thanks for the lesson in laziness.
13:27:02 <ustenzel> roconnor: the web is full of lessons of this kind.  somehow nobody seems to have a solution.
13:27:42 <ustenzel> the absolute classic is "fold (+)" over a large, but finite list of numbers.
13:27:58 <roconnor> foldl or foldr?
13:28:13 <roconnor> I guess it doesn't matter.
13:28:15 <ustenzel> doesn't matter.
13:29:00 <roconnor> It will be evaluated when you use it, but the space will stick around until you do.
13:29:18 <ustenzel> foldr (+) 0 [1..4] == 1 + (2 + (3 + (4 + 0)))
13:29:44 <ustenzel> this expression takes away really much heap space and additionally requires stack space to evaluate.
13:30:05 <ustenzel> the foldr case cannot even be repaired.  contrast foldl:
13:30:24 <ustenzel> foldl (+) 0 [1..4] == ((((0 + 1) + 2) + 3) +4)
13:30:33 <goron> 'Night guys. Thanks for the help. I will look further tomorrow...
13:30:51 <ustenzel> if only this was evaluated from the inside out, but it isn't.  so it takes heap space, too.
13:31:50 <ustenzel> you need a strict version of foldl to repair it... at such cases seem to crop up fairly regularly.
13:32:24 <roconnor> Well, I don't really understand your stack/heap problem. Haskell is run in a G-machine no?  There is no call stack?
13:36:21 <roconnor> But I do understand that untill you use the value, you have a huge list.
13:36:39 <edwinb> The G-machine has a "dump" which is effectively a call stack...
13:36:44 <Smerdyakov> My list is huger than yours.
13:36:46 <edwinb> (not that I was paying attention, btw)
13:37:37 <roconnor> edwinb: Good point.  It would be a good exercise for me to compare the evaluation of the foldl and foldr graphs.
13:37:46 <edwinb> essentially that's a list of closures, so...
13:38:11 <edwinb> I should read up and find out what the problem is now ;)
13:38:19 <ustenzel> and still, to actually evaluate a deeply nested expression, the G machine uses a stack to.
13:38:28 <roconnor> So what is a closure?  A list of variables and values they are bound to?
13:38:46 <edwinb> It's a pair of a code pointer and the stack associated with it.
13:39:02 <edwinb> So, yes, local variables and a point to return to.
13:39:10 <roconnor> oh
13:40:20 <edwinb> I forget what happens in the STG machine but I expect it's similar.
13:40:35 <roconnor> Right, so one would push a lot onto the dump, while the other one wouldn't, depending on the order that the parameters to a combinator are evaluated.
13:41:03 <roconnor> STG? spineless-tagless-graph-machine?
13:41:08 <edwinb> yes
13:45:25 <roconnor> So under strict evaluation a program summing numbers 1 ... n could do it in O(log(n)) space, while a lazy evaluation would probably use O(n) space.
13:50:58 <roconnor> foldr 0 (+) $ unfoldr (\x -> if x<0 then Nothing else Just (x, x-1))
13:52:05 <roconnor> foldr (+) 0 $ unfoldr (\x -> if x<0 then Nothing else Just (x, x-1)) 10
13:52:24 <roconnor> Damn, under strict evaluation, that still takes O(n) space.
13:54:12 <roconnor> I can't see how to make code that has a bigger SPACE under lazy evaluation than under strict evaluation.
13:59:27 <monochrom> try foldl
13:59:50 <roconnor> ?
14:00:32 <monochrom> foldl (+) 0 some_list
14:00:49 <Igloo> foldl itself will give you a suspension the size of its input list, so isn't going to have asymptotically higher space usage I don't think
14:00:59 <roconnor> under strict evaluation some_list has length n, so the space requirements are O(n)
14:01:42 <monochrom> foldl (+) 0 [1,2,3,4].  With lazy evaluation, the expression 1+2+3+4 is constructed first.
14:02:13 <roconnor> I certainy agree that in absolute terms, the strict evaluation is smaller, but the claim was made that lazy evalutation could have a larger order in space.
14:02:16 <Igloo> Yes, but is no bigger than the expression [1,2,3,4] (assymptotically)
14:04:31 <roconnor> monochrom: I tired to get rid of the O(n) of [1,2,3,4] by using a fancy unfoldr, but under strict evaluation the [1,2,3,4] is still produced, so I didn't really gain anything.
14:05:20 <Philippa> roconnor: consider updates to a FiniteMap - you could pile up modifications to one entry before evaluating them
14:05:25 <Philippa> (by reading the entry)
14:06:32 <roconnor> Hmmm
14:15:19 <roconnor> Philippa, it's still difficult for me to make a pile of modifications without building up a stack of size n under strict evaluation.
14:15:31 <roconnor> But maybe if I think harder.
14:46:15 <monochrom> I don't know how to pump up the asymptotic space complexity.  But perhaps the "less speed more haste" paper helps.
15:52:14 <roconnor> monochrom: Do you have a reference?
15:53:37 <eixei> hi
15:54:32 <roconnor> hi
16:00:08 <roconnor> ah, more haste, less speed
16:02:50 <roconnor> ``This demonstrates that lazy evaluation is strictly more efficient - in asymptotic terms - than eager evaluation,''
16:03:30 <roconnor> Cool, unfortunately a claim was made about the space requirements of lazy languages.  It looks like that might not be addressed by the paper.
16:22:02 <Sartan> hello
16:22:22 <Sartan> why do I get an error with this?
16:22:30 <Sartan> data A a = A Int a
16:22:30 <Sartan> instance Show (A Int) where show = undefined
16:22:38 <Sartan> ...
16:22:55 <Sartan> Illegal instance declaration for `Show (A Int)
16:22:57 <Sartan> (The instance type must be of form (T a b c)
16:23:03 <Sartan> ...
16:23:28 <Sartan> but I wanted to specify an instance of Show for (A Int)
16:23:38 <Sartan> not (A a) in general
16:23:45 <monochrom> Perhaps it is not allowed.
16:24:04 <roconnor> Sartan: I think that maybe that isn't allowed :-(
16:24:09 <Sartan> but why?
16:24:36 <Sartan> hmmm wait...
16:24:43 <Sartan> it does make some sense
16:25:48 <Sartan> the only explanation I can find
16:26:32 <Sartan> is that wouldn't know in compile time wether some expressions could be printed or not...
16:26:43 <Sartan> So how do they do it with strings?
16:27:08 <roconnor> Show can be overrided for [A]
16:27:15 <roconnor> @info Show
16:27:16 <lambdabot> -- Show is a class
16:27:16 <lambdabot> class Show a where {
16:27:16 <lambdabot>     showsPrec :: Int -> a -> String -> String {- has default method -};
16:27:16 <lambdabot>     show :: a -> String {- has default method -};
16:27:16 <lambdabot>     showList :: [a] -> String -> String {- has default method -};
16:27:16 <lambdabot>     }
16:27:28 <roconnor> buy using showList.
16:27:32 <roconnor> by using showList.
16:27:58 * roconnor shakes his fist at the language designers.
16:28:08 <roconnor> :-)
16:28:17 <Sartan> I'm confused...
16:28:32 <roconnor> Char has a special implementation of showList
16:28:51 <Sartan> Char? or [Char]
16:28:54 <roconnor> Char.
16:29:10 <Sartan> but showList :: [a] -> String -> String
16:29:19 <Sartan> [a] and Char do not unify
16:29:31 <Sartan> what do you mean by default implementation for char?
16:29:43 <Sartan> nevermind
16:29:50 <Sartan> you mean for a = Char
16:29:50 <Sartan> ok
16:29:56 <roconnor> yeah
16:30:01 <Sartan> oh
16:30:03 <Sartan> got it
16:30:28 <roconnor> Sartan: I'm glad you get it, because now that I think about it, I don't really understand how it works. *l*
16:30:30 <Sartan> that is: class Show a where
16:30:44 <Sartan> I was reading: class Show [a] where
16:30:59 <Sartan> ok I got the 1st part
16:31:12 <Sartan> that is, how they were able to define showList 
16:31:16 <Sartan> for char
16:32:07 <Sartan> then it should be,   class Show a => Show [a] where show xs = showList xs
16:32:14 <roconnor> Well, we should be able to look it up.  The (String -> String) result is probably the standard trick for preventing quadradic algorithms that would normally occur by using string concatination.
16:32:20 <Sartan> and that would work fine
16:32:25 <roconnor> Ah
16:32:34 <Sartan> yes that I know
16:32:45 <Sartan> shows is simple show defined using an acummulator
16:33:17 <roconnor> instance  (Show a) => Show [a]  where
16:33:18 <roconnor>     showsPrec p      = showList
16:33:24 <roconnor> It's in the prelude
16:33:29 <Sartan> oh yes of course
16:33:45 <Sartan> because showList also uses the acummulator
16:33:57 <roconnor> Okay, now I understand the complex mess that is show for Strings.
16:34:15 <Sartan> yeap :)
16:35:18 <Sartan> Now I really needed to be able to define that
16:35:26 <Sartan> The idea is the following
16:35:34 <Sartan> To print some structures 
16:35:35 <roconnor> What does the p parameter do in showsPrec?
16:35:42 <Sartan> roconnor: precedencies
16:36:05 <Sartan> roconnor: it is used to decided wether something needs to be enclosed in parentheses or not
16:36:10 <roconnor> precedencies ... for getting rid of brackets in expressions?
16:36:14 <Sartan> s/decided/decide
16:36:22 <roconnor> ah, I half remember reading about that somewhere.
16:36:40 <roconnor> Well, that's convienent
16:36:44 <Sartan> yeap
16:37:08 <Sartan> actually I'm printing terms and formulas
16:37:12 <Sartan> so I can use that :)
16:37:16 <Sartan> now the thing is
16:37:37 <Sartan> to be able to print terms, I need the term and a dictionary 
16:38:15 <Sartan> the dictionary is just somthing that stores the names of the vars and functions and all
16:38:31 <Sartan> so I want to be able to pair stuff with the dictionary
16:38:33 <roconnor> Just encode the dictionary as an Int. ... oh, an Int isn't going to be big enough.
16:38:45 <Sartan> hmmm ?
16:38:47 <roconnor> Too bad it wasn't Integer. *l*
16:38:53 <Sartan> Int is enough
16:39:04 <Sartan> what the dictionary does is store the strings for each int
16:39:25 <Sartan> for instance, I work with  f(1,2)
16:39:32 <Sartan> opss
16:39:38 <Sartan> 5(1,2)
16:40:02 <Sartan> amd the dictionary stores    5->f1  1->x  2->b1 
16:40:08 <Sartan> so that would be printed as 
16:40:17 <Sartan> f1(x,b1)
16:40:40 <Sartan> now I want to pair the dictionary with terms, formulas, etc
16:40:43 <Sartan> therefore the 
16:40:58 <Sartan> Pair Dict a 
16:41:10 <Sartan> and then I'd just implement show for
16:41:26 <Sartan> Pair Dict Term
16:41:30 <Sartan> Pair Dict Formula
16:41:31 <Sartan> etc
16:41:47 <roconnor> Um, does that work?
16:41:50 <Sartan> no
16:41:58 <Sartan> because I cannot define:
16:42:08 <Sartan> instance Show (Pair Dict Term) where ...
16:42:10 <Sartan> :-/
16:42:13 <Sartan> only 
16:42:22 <Sartan> instance Show (Pair Dict a) where ...
16:42:31 <Sartan> wait
16:42:35 <Sartan> that should be 
16:42:41 <Sartan> instance Show (Pair Term) where ...
16:42:43 <Sartan> and
16:42:46 <Sartan> instance Show (Pair a) where ...
16:43:17 <Sartan> so nope, it doesn't work. but it was a nice idea :)
16:43:23 <Sartan> (I think)
16:43:31 <roconnor> It sounds similar to the problem of trying to make an instance of Num for arithmetic modulo n.
16:43:44 <Sartan> nah
16:43:50 <Sartan> I'm not using values here
16:44:08 <Sartan> wait!!
16:44:10 <roconnor> you want the instance to depend on a parameter.
16:44:46 <Smerdyakov> Sartan, why is it so important to have a Show instance?
16:45:27 * roconnor wants dependant sum types.
16:45:39 <Smerdyakov> roconnor, why?
16:46:19 <Sartan> done
16:46:28 <Sartan> I knew I had done it
16:46:29 <roconnor> Hmm... I thought it would solve this sort of problem, but it doesn't really.
16:46:35 * roconnor takes back his thought.
16:46:38 <Sartan> I just needed -fglasgow-exts
16:46:45 <Smerdyakov> Only smelly poop heads want dependent types.
16:47:11 <Sartan> Smerdyakov: you mean I could use just my own function?
16:47:18 <roconnor> Well, in general I want dependant types. :-)
16:47:22 <eixei> goodnight!
16:47:31 <Sartan> Smerdyakov: I want to use the showsPrec stuff
16:48:08 <Sartan> what are dependent Sum types?
16:48:24 <Sartan> I know what dependent types are (I think)
16:48:32 <Sartan> types that depend on values
16:48:39 <Smerdyakov> Sartan, I don't know what showsPrec is, but you can always use your own function.
16:48:44 <roconnor> First you need functions like from Int to Type.
16:48:56 <Sartan> Smerdyakov: yes but I'd be reinventing the wheel
16:49:01 <roconnor> A dependant sum type has values (a, b) where b :: f(a)
16:49:08 <roconnor> and f :: A -> Type.
16:49:13 <Sartan> Smerdyakov: it puts parenthesis where needed, using precedence values
16:50:25 <Sartan> Smerdyakov: there are lots of useful functions in the show class
16:50:39 <Sartan> Smerdyakov: like showParen, showList etc
16:50:49 <Sartan> I wanted to take advantage of that
16:51:32 <Smerdyakov> Okeydokey
16:51:41 <Smerdyakov> This is one of those situations where functors are much nicer than type classes!
16:52:00 <roconnor> oh?
16:52:32 <Smerdyakov> Yup. A single global space for type class instances can cause all kinds of clashes with non-local code.
16:52:37 <Sartan> roconnor: how is that diferent from dependent type... I was trying to understand why the "sum" word
16:53:06 <Pseudonym> Moreover, you can't control whether or not typeclass instances are exported.
16:53:13 <roconnor> There are two types dependant types. dependant sum types, and dependant product types.
16:53:18 <Smerdyakov> Sartan, "sum" because it's like an "exists" quantifier, which is like an infinite disjunction. Disjunctions are thought of as sums in an algebraic notation.
16:53:22 <Pseudonym> Local instances are effectively global.
16:53:40 <roconnor> dependant products are functions from A to f(a).
16:53:47 <Sartan> Smerdyakov: yes I was just wondering what other kind of dependent types can you have...
16:54:25 <Smerdyakov> roconnor, please. Men died for your independence; you could at least spell "dependent" properly!
16:54:50 <Pseudonym> I don't think anyone has made the ultimate sacrifice for my type system yet.
16:54:53 <Jerub> Smerdyakov: please, don't make falicious political statements.
16:55:20 <Smerdyakov> Jerub, please, don't misspell "fallacious."
16:55:21 <roconnor> de·pen·dant   Audio pronunciation of "dependant" ( P )  Pronunciation Key  (d-pndnt)
16:55:22 <roconnor> n.
16:55:24 <roconnor>     Variant of dependent.
16:55:26 <roconnor> I don't feel so bad.
16:55:32 <Sartan> lol
16:55:55 <Smerdyakov> roconnor, yeah, it's a "variant" because an incontrollable flood of people misspell it. :P
16:56:14 <roconnor> And the Engrish language continues to evolve.
16:56:21 <roconnor> :-)
16:57:00 <Pseudonym> Smerdyakov's statement assumes a "standard" that is anything but de facto.
16:57:18 <Pseudonym> And clearly it's not as "de facto" as he thinks if linguists agree it's a variant.
16:57:30 <Smerdyakov> Let me tell you something about linguists.
16:57:39 <roconnor> Oh, I'm from Canada too.
16:57:40 <Smerdyakov> They're addicted to cocaine.
16:57:45 <Pseudonym> All of them?
16:57:58 <Smerdyakov> Yes.
16:58:20 <Pseudonym> I know at least three counter-examples.
16:58:41 <Pseudonym> Of all the linguists that I know, I definitely know that at least three are not addicted to cocaine.
16:58:41 <Smerdyakov> Mail me urine samples and I'll consider it.
16:58:55 <Pseudonym> Though one of them may be a casual user.
16:59:18 <Pseudonym> A urine sample won't prove or disprove addiction.
16:59:28 <Smerdyakov> That's what yooooou think.
17:00:10 <Sartan> this is also pretty usefull for printing with options
17:00:15 <Pseudonym> At most, it will prove or disprove use.
17:00:23 <Smerdyakov> I have ways and means.
17:00:48 <roconnor> Hmm, the XML namespace is a bit hard to understand.
17:00:56 <roconnor> err namespace standard.
17:01:21 <Smerdyakov> Let me tell you something about XML.
17:01:25 <Smerdyakov> It's addicted to cocaine.
17:01:40 * roconnor agrees!
17:01:46 <Pseudonym> And moreover, it's a linguist.
17:01:49 * Pseudonym nods seriously
17:01:54 * roconnor thinks XML is addicted to crack.
17:02:01 <Smerdyakov> Who wants to round up some villagers and storm PLAN-X with torches?
17:02:11 * roconnor and is on crack.
17:02:19 * Jerub laughs
17:03:05 <roconnor> The XML namespaces are also on ketamine
17:03:20 <roconnor> in addition to being on crack.
17:03:35 <Smerdyakov> Or being on the San Andreas fault
17:19:51 <Sartan> <rant> I don't understand this web designers, the Mozilla web site looks much worst now IMO </rant>
17:36:51 <shammah> sartan: I prefer the new design.  Easier to navigate, and no scrolling.
17:38:10 <Jerub> still no new promotional buttons however.
17:38:53 <Jerub> the new design is very 2004. especially some of the elements like the gray box around the dates on the front page.
17:45:45 <Brugo> hello
17:46:18 <Jerub> hello
17:46:23 <Brugo> hi Jerub 
17:46:36 <Brugo> Question about QuickCheck
17:46:40 <Brugo> it seems pretty nice
17:46:44 <Brugo> but...
17:46:53 <Jerub> ?
17:47:06 <Brugo> how can I print generated data structures??
17:47:14 <Brugo> do I need Monad Transformers for that?
17:48:02 <Brugo> If I cannot print the generators...
17:48:12 <Brugo> how do I know if they are working properly
17:48:38 <Brugo> s/print generators/print data
17:49:18 <stepcut> argh! smbmount puts '//host/share name' in /proc/mounts as '//host/share_name', making it indistinguishable from a share actually named '//host/share_name'
17:53:47 <stepcut> /proc/mounts is full of lies!
17:53:57 <stepcut> or atleast, useless information
17:55:38 <Pseudonym> Little-known fact: /proc/mounts is addicted to... oh, forget it.
18:02:33 <Brugo> ok I just noticed there is verboseCheck, but!
18:02:50 <Brugo> not only is this really hackish
18:03:13 <Brugo> I have to define a dummy property to test
18:03:53 <Brugo> it also doesn't help if I don't want to use show to see the structure, but some other function :-/
23:32:35 <musasabi> morning
23:42:38 <Gahhh> aloha
