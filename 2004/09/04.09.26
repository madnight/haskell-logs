00:46:32 <musasabi> morning
00:47:31 <Oejet_> Goodmorning, musasabi.
00:52:53 <borism> good morning
01:13:39 <Boegel> hello every1
01:13:48 <dblhelix> hello Boegel
01:20:46 <Boegel> pretty quiet in here again:o)
01:21:11 <musasabi> hello Boegel
01:21:52 <Boegel> hey
01:21:57 * musasabi plots with the GHC source
01:22:14 <Boegel> I'm having problems with putting the ray casting algorithm in FunMath
01:22:39 * dblhelix specializes generic functions _by hand_ :S
01:22:39 <Boegel> it seems like it doesn't fit or something, but I guess I'm doing it all wrong ;)
01:23:55 <musasabi> What would be the right place to transform constructor matching "foo (C a b) = ..." into "foo (x) | condition, a <- fun1, b <- fun2 = ..."
01:24:16 <musasabi> dblhelix: doesn't ghc do that automatically if you tell it to?
01:25:00 <musasabi> dblhelix: http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#SPECIALIZE-PRAGMA
01:25:17 <dblhelix> musasabi: I'm not talking about GHC generics ;)
01:25:22 <musasabi> Boegel: hmm?
01:25:43 <dblhelix> musasabi: but thanks anyway :)
01:25:46 <musasabi> np
01:27:37 <Boegel> we'll, I guess I want it to be too much like Java
01:27:54 <Boegel> I implemented the algorithm in Java first, to get to know it
01:28:16 <Boegel> I had lot's of problems with it, because I thought something was wrong with the implementation
01:28:20 <Boegel> but there wasn't :o)
01:28:40 <Boegel> there was a thing about ray casting I wasn't aware of: Field Of View
01:29:36 <Boegel> that 'causes' a distortion in the image you get, when you put the camera to close to the scene
01:29:52 <Boegel> so I know the algorithm pretty good know
01:30:35 <Boegel> but it seems not easy to put it in a functional system
01:31:22 <kosmikus> dblhelix: and, are you successful?
01:33:02 <dblhelix> kosmikus: yeah, no problems ... just getting a bit bored ...
01:34:08 <dblhelix> kosmikus: think about specializing a generic function with three dependencies for Frank's Univ type (which has about ten constructors) in a tagged list-like view ;)
01:36:17 <kosmikus> dblhelix: why are you doing it ?
01:37:25 <dblhelix> kosmikus: to make sure that my SYB implementation really works this time ;)
01:38:24 <kosmikus> oh, so you have a new candidate solution?
01:38:56 <dblhelix> yes: the reduce/expand thing seems to work just fine ...
01:39:23 <kosmikus> ok
01:40:11 <dblhelix> I've just semi-automated the specialization process: writing 150 lines for just one function isn't fun anymore ... someone should write a compiler or so to take care of this stuff ;)
01:40:12 * kosmikus is preparing the lecture for Wednesday
01:40:36 <kosmikus> dblhelix: there is a compiler ;)
01:41:07 <kosmikus> I've just started cleaning it up a bit yesterday, to get into it again
01:41:29 <kosmikus> maybe I'll do the views thing, or we can do it together ...
01:41:41 <dblhelix> sounds cool
01:42:03 <kosmikus> btw, do you have a running Windows version on your machine?
01:42:14 <kosmikus> if yes, which one?
01:42:47 <dblhelix> yes ... Win XP Professional UK SP1 (well ... running? what about crawling)
01:43:31 <dblhelix> he ... Wednesday's lecture is about specialization :)
01:44:47 * Boegel is out to shoot some people... virtually that is
01:45:08 <kosmikus> dblhelix: sorry, I wasn't specific enough: a running Windows version of GH
01:45:53 <dblhelix> kosmikus: I still run Beryl
01:46:29 <kosmikus> I see ;)
01:47:02 <dblhelix> kosmikus: and I thinks I have a more recent snapshot sitting around somewhere ... :) ... but, to be honest, I haven't used to GH compiler in quite a while
01:48:13 <kosmikus> me neither ...
01:48:15 <dblhelix> kosmikus: btw, do you keep the slides you used for your talk at last month's GH meeting (or the ones you used in Nottingham) on line somewhere?
01:48:34 <kosmikus> not yet, but I can do that ...
01:55:27 <kosmikus> dblhelix: they're there
01:55:36 <kosmikus> dblhelix: the STC talk was a bit too optimistic
01:55:43 <dblhelix> :) great ... thanks
01:55:55 <dblhelix> kosmikus: too optimistic? in what sense?
01:56:04 <kosmikus> read the other talk ;)
01:56:46 <dblhelix> okay, I will :)
01:57:17 <kosmikus> oh, which reminds me that it officially wasn't STC, but a GH meeting
01:57:57 <dblhelix> yeah, I already wondered if it was the same talk as I attended
01:58:09 <kosmikus> changed
02:05:57 <dblhelix> kosmikus: just doing a quick 'n dirty mental diff ... what's the pessimistic note you added? the problems involving *applying* type-indexed functions with per-case dependencies?
02:08:56 <dblhelix> I think I see the problem ... ah ...
02:09:25 <kosmikus> no, with the higher-kinded types, it's not clear how to translate in presence of per-case dependencies
02:11:11 <dblhelix> yes, I see ... a naive solution would still cause you to pass around dependency information for all cases
02:12:50 <dblhelix> not surprisingly: as soon as you leave the domain that's also covered by type classes you hit rock botton :(
02:13:10 <dblhelix> /s//botton//bottom
02:13:39 <Boegel> hello again
02:13:50 <kosmikus> dblhelix: I have a vague feeling it can be fixed
02:14:04 <kosmikus> dblhelix: but it will require some work on my part ;)
02:16:33 <dblhelix> do you think it's possible to pass *just enough* information for each call ... because that's the problem, isn't it: per-function dependencies typically cause you to pass around too much info ... and a naive implementation of per-case dependencies cause you to pass nog enough info :S
02:17:30 <dblhelix> kosmikus: once again, I can't wait to see what you come up with ... ;)
02:21:38 * dblhelix immediately starts drawing mental pictures of graphs for quite complex multi-level dependency constraints
02:21:45 <kosmikus> dblhelix: I think the trick is to abstract over the right amount of information
02:22:15 <kosmikus> dblhelix: but we can discuss that tomorrow, if you plan to come along
02:23:40 <dblhelix> kosmikus: does another time this weeks suits as well?
02:24:43 <dblhelix> /s/weeks/week
02:28:20 <kosmikus> dblhelix: sure
02:28:38 <kosmikus> dblhelix: Wednesday after the lecture?
02:29:28 <kosmikus> dblhelix: 13:30 or something ...
02:30:27 <Boegel> are you guys dating ? :p
02:30:35 <dblhelix> kosmikus: okay, 13:30 is fine ... (maybe I'll drop by and attend the lecture ;) ... if you don't mind of course)
02:30:45 <dblhelix> Boegel: kind of
02:32:07 <Boegel> :o)
02:44:38 <kosmikus> dblhelix: support is always welcome ;)
02:45:10 <dblhelix> kosmikus: maybe I was planning to learn something ;)
02:45:49 <kosmikus> I doubt that there's anything in the lecture you don't know yet
02:46:57 <dblhelix> I was more or less joking ;)
02:49:54 <dblhelix> kosmikus: btw ... I'm planning to visit Jur as well this week ... it can't hurt to just ask about possibilities, I guess
02:53:48 <kosmikus> dblhelix: yes, definitely
02:55:49 * Boegel is going for a snack
03:15:53 * Boegel is back from his snakc
03:16:13 <Boegel> \/s/snakc/snack
03:26:30 <Boegel> bye wouter :p
03:56:37 * Boegel is leaving
03:56:38 <Boegel> bye
04:19:10 <crackhead> so what is the difference b/w .hs and .lhs?
04:23:39 <arjanb> .lhs is literate haskell
04:25:09 <crackhead> literate haskell?
04:27:35 <arjanb> http://www.haskell.org/onlinereport/literate.html
04:35:42 <crackhead> cool
04:39:34 <crackhead> so is there any way to do something like this: http://rafb.net/paste/results/r61qRr91.html
04:40:01 <crackhead> I know it's all wrong
04:40:47 <crackhead> I just want to be able to print out 'a' from the script
04:47:14 <Lemmih> crackhead: 'main = print a'
04:48:05 <Lemmih> Or simply load it in an interpreter and evaluate 'a'.
04:48:36 <Lemmih> Oh wait. Misread the code /-:
04:49:06 <Lemmih> crackhead: You can use Debug.Trace.trace for that.
04:49:29 <Lemmih> @type Debug.Trace.trace
04:49:30 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
05:03:09 <crackhead> right on
05:03:11 <crackhead> thanks
05:07:35 <Yauolz> Look at that Girl with 3 Pupss http://www.enchant.ru/go.php?login=Begimot  :DDD this is not a virus :DDDD
05:21:57 <crackhead> if b/2 >= 2 then "was the IF" else "was the ELSE"
05:22:16 <crackhead> why can't I get this to worK in hugs?
05:22:43 <crackhead> when I load it with :l it gives me an error about the if
05:22:53 <arjanb> what error?
05:23:11 <dv_> Prelude> if 1/2 >= 2 then "was the IF" else "was the ELSE"
05:23:11 <dv_> "was the ELSE"
05:23:23 <crackhead> ERROR test.hl:3 - Syntax error in input (unexpected keyword "if")
05:23:51 <dv_> you need to put it in a function
05:24:04 <crackhead> huh?
05:24:28 <Boegel> :)
05:24:41 <Boegel> Haskell is a functional language, I hope you know that ?
05:24:56 <crackhead> hehe
05:24:56 <Boegel> there is no keyword 'if' in Haskell
05:25:10 <Boegel> shocking, isn't it :p
05:25:21 <CLxyz> it's certainly different
05:25:29 <crackhead> sorry...so can I say \b in front of it?
05:26:08 <crackhead> hmmm...that didn't work
05:26:29 <dv_> f b = if b/2 >= 2 then "was the IF" else "was the ELSE"
05:26:30 <TheHunter> crackhead: if you want to put it into a file, you'll have to make it a function: testB b = if b/2 >= 2 then ...
05:26:50 <dv_> ^ what he said
05:26:53 <Boegel> http://www.cis.syr.edu/courses/cis352/info/patterns.html
05:27:33 <TheHunter> the hugs interpreter evaluates expressions, so if you've defined b, you can evaluate the expression 'if ...' at the hugs prompt.
05:28:07 <Boegel> @seen shapr
05:28:07 <lambdabot> I saw shapr leaving #webwitches 13 hours 38 minutes 59 seconds ago.
05:30:01 <crackhead> nice
05:30:26 <crackhead> cool....I think I'm beginning to understand
05:47:33 <crackhead> hmmmm....why would I want to use a lamba expression
05:47:50 <crackhead> it doesn't seem that I can use it from a file
05:47:59 <crackhead> ....or can I?
06:30:59 <Lemmih> crackhead: 'add1 = \x -> x+1'
06:34:11 <crackhead> Lemmih : thanks!
06:36:47 <kristnjov> np
06:36:50 <desrt> but whatever you do, don't say 'add1 = succ' :)
06:37:53 <Lemmih> Wow, I never think I've coded so much Haskell on so little time before.
06:39:35 <Lemmih> s/never/don't/ D'oh
06:44:08 <pesco> Hello everyone.
06:44:16 <pesco> Are there any Perry Rhodan fans here?
06:46:06 <Lemmih> Who's Perry Rhodan?
06:46:29 <kristnjov> yeah, who's perry rhodan?
06:47:25 <pesco> Main character of a SciFi series (written - not TV)
06:47:32 <pesco> And the name of the series.
06:48:16 <Lemmih> I don't read comic books.
06:48:16 <kristnjov> i like heteroy better
06:48:27 <pesco> Lemmih: Not comic.
06:49:43 <pesco> It's a German series anyway, but I recall several Germans being on this channel.
06:50:10 <pesco> I'm not sure if they have translations into other languages, actually.
06:53:03 <pesco> Ah, they do. http://www.perry-rhodan.us/ :)
06:53:13 <kristnjov> dude no one CARES
06:53:40 <pesco> Er, sorry?
06:54:12 <kristnjov> why did you ask in the first place, does perry like haskell?
06:55:32 <pesco> I'd like not to be expected to account for me starting a (seemingly) off-topic conversation. But, since you asked, here goes.
06:56:13 <pesco> I consider this channel to be a place for Haskell programmers to meet and talk about Haskell.
06:56:32 <pesco> Or rather "people interested in Haskell".
06:57:02 <kristnjov> so why is this a better channel to join and talk about it than #perryrhodan at dalnet?
06:57:29 <vegai> pesco: oh, don't mind about it
06:57:48 <pesco> It is not a question of better, but a question of "good". My desire was not to ask the most on-topic channel, but to ask my Haskell-programming friends about it.
06:57:50 <vegai> pesco: some people just don't have better things to do than yell "off-topic!" on irc
06:58:10 <pesco> vegai: You're right. Still, I feel the desire to defend myself.
06:58:16 <kristnjov> i'm not yelling off-topic, i'm just telling him no one cares
06:58:39 <pesco> Which is a vastly more rude means to the same effect.
06:58:42 <vegai> kristnjov: and that's better how?
06:58:49 <kristnjov> vegai, i'm better now.
06:59:51 <pesco> kristnjov: Anyway, you don't know any better than me how much other people care. In fact, I fully expect someone on this channel, possibly not looking at it now, to know and like PR.
07:00:09 <pesco> But this metadiscussion is starting to annoy me.
07:00:23 <kristnjov> okay, so stop talking?
07:02:00 <pesco> My point was to mean "You annoyed me, think about it." Not "I'd like to stop talking" - I'll do that seen enough, you'll notice.
07:02:48 <kristnjov> yet the fact is still clear, no one DOES care, and you started this discussion because you felt disapproved in some way.
07:03:16 <pesco> What's your point?
07:03:29 <kristnjov> my point is that no one cares?
07:03:34 <kristnjov> i think i've made that pretty clear.
07:04:53 <pesco> Oh, I'm sorry for suspecting some deeper point behind that, since "no one cares" is indeed an extremely weak "point".
07:05:08 <kristnjov> then why are we even arguing?
07:07:48 <pesco> As you seem to have missed, I was criticizing your behaviour.
07:08:23 <kristnjov> okay, and what am i supposed to do?
07:09:46 <kristnjov> i'm gonna eat now so you carry on.
07:15:22 <Oejet_> Oh, oh, may I take over, while kristnjov is taking a break?
07:15:37 <pesco> :) Sure.
07:34:01 * musasabi ponders why people care to point out that no-one cares if they don't care.
07:40:40 <tic> hello traveling salesman.
08:14:36 <desrt> is there a difference between non-termination and exceptions?
08:14:53 <desrt> i mean, theoretically
08:16:23 <ne1> Depends on which theory. :D  The simplest ones lump them together.
08:27:17 <Lemmih> Is there a 'FilePath -> IO Integer' version of System.IO.hFileSize?
08:29:14 <ne1> Is there one in the posix module?
08:30:56 <desrt> zipWith is rather nice for making infinite lists generated by recursive definitions...
08:38:49 <Lemmih> @type (\x -> getFileStatus x >>= return . fromIntegral . fileSize)
08:38:50 <lambdabot> bzzt
08:38:56 <Cale> desrt: yeah, it is :)
08:39:16 <desrt> check this out:
08:39:18 <desrt> factorial = 1 : zipWith (*) factorial [2..]
08:39:23 <desrt> i'm so proud for having come up with that :)
08:40:36 <Cale> :)
08:42:05 <np_hard> arg, hasktags in the last ghc release still breaks on case-insensitive file systems
08:42:09 <np_hard> damn you apple and your hfs+
08:42:23 <desrt> case-insensitivity is pretty dumb
08:42:51 <np_hard> maybe for some things
08:43:06 <np_hard> frankly I don't see the win in a case-sensitive file system
08:43:19 <np_hard> except compatibility with Unix, which is worth it in itself
08:43:43 <np_hard> (I don't see a big win in case-insensitive file systems either, it's the variation that is killer)
08:44:08 <desrt> case-sensitivity is more theoretically sound
08:44:23 <desrt> you have straight-up equivilence
08:44:29 <emu> case-insensitivity is more user-friendly
08:44:36 <desrt> with case-insensitivity there are two levels of equivilence classes
08:44:43 <emu> don't forget unicode, though
08:44:53 <emu> which makes the question much more complicated
08:44:58 <desrt> mm.  indeed
08:45:07 <desrt> unicode makes everything more confusing
08:45:37 <np_hard> oh yes
08:45:38 <np_hard> nm
08:45:49 <np_hard> i18n everything should be case-sensitive
08:45:53 <emu> well no longer can we make the assumptions which work with english and similar languages
08:45:55 <desrt> like do you count √© the same as compose(' + e)?
08:45:57 <np_hard> as you said, theoretically sound
08:46:06 <np_hard> exactly, I now see the win :)
08:46:50 <emu> But still, how can you achieve unicode-safe case-insensitivity?  Users don't want "File" to be different from "file", most are not anal enough
08:47:17 <np_hard> localized tools should implement a case-insensitive user interface but the actual storage should be done without converting
08:47:33 <desrt> mm.
08:47:47 <desrt> i think these days very few people actually type file names in
08:48:03 <desrt> you do something like open a folder, type-ahead the first few characters, then hit enter
08:48:13 <np_hard> none of this fixes my hasktags conundrum
08:48:15 <desrt> or just use the mouse
08:48:24 <np_hard> I see that Mr. Marlowe fixed it but I don't want to track CVS
08:48:30 <emu> np_hard: that's what they do already
08:48:52 <np_hard> of course 6.2.2 is "planned" for a month ago
08:49:15 * desrt looks over at his laptop building 6.2-20040925
08:49:45 <np_hard> right right, I don't want to track cvs, anyone know when there will be a release that someone might put into fink? 8)
08:49:51 <Cale> np_hard: it's easy to fix hasktags to work
08:50:03 <Cale> just have it only produce one of the tags files
08:50:34 <ne1> Case is not unfriendly.  Even the most dumb English speaker knows the difference between "potter" and "Potter".
08:51:00 <desrt> ne1; and hopefully between "Harry Potter" and "hairy potter"
08:51:08 <ne1> May as well say the English language itself is unfriendly.
08:51:34 <ne1> And "china" vs. "China".
08:51:49 <np_hard> I guess I can do that
08:51:56 <np_hard> never looked at the ghc source tree before though
08:52:01 <desrt> that's a good call.. the china case is a particualrly good example
08:52:06 <desrt> China and china are very different things
08:55:21 <ne1> Suppose a user has two files china.ppt and China.ppt.  First of all this is quite natural.  Now if a computer makes the user's life hard in specifying which file to open, that is user unfriendliness.
08:56:07 <Cale> well, it's going to make life hard before that
08:56:43 <Cale> specifically, when you try to save a file with the "same" name as another in the same directory.
09:01:01 <np_hard> thanks Cale, that was easy
09:01:28 <np_hard> who the heck uses ctags and vi
09:01:30 <np_hard> :-P
09:04:43 <np_hard> the source even has a snide comment
09:04:44 <np_hard> sheesh
09:04:51 <np_hard> -- We generate both CTAGS and ETAGS format tags files
09:04:51 <np_hard> -- The former is for use in most sensible editors, while EMACS uses ETAGS
09:05:11 <Lemmih> haha
09:53:56 <jesse> on the other hand, capitalization is rarely used to distinguish countries from plates when it comes to file names, its more matter of convention and readability. its quite a pain to have to guess the case pattern of some rarely used program from a command line.
10:09:18 * shapr yodels
10:10:02 <shapr> so, what did I miss?
10:10:07 <shapr> Cale: you around?
10:10:12 <Cale> yep
10:10:45 <shapr> er
10:11:02 <shapr> what's past memorizing multiplication and logarithmic tables?
10:11:17 <Cale> past?
10:11:24 <shapr> are there things you can memorize to dramatically simplify mental calculations?
10:11:46 <Igloo> Anyone know how easy it would be to use a C++ library (libapt-pkg) with the FFI?
10:11:54 <shapr> is there some way I can 'memorize' the patterns in a slide rule in such a way that I can use them?
10:12:09 <Cale> The distributive property is useful to break up multiplications in ways other than the usual one used in the algorithm they teach in school.
10:12:26 <Cale> but I'm not really all that good at calculating anyway :)
10:12:44 <Cale> Replacement with letters makes multiplication easy
10:13:18 <shapr> I had a strange idea that programming should be able to grow past computers into more general systems that humans can memorize and use in everyday life.
10:14:55 * Lemmih is deeply confused by the behaviour of his threaded program.
10:15:16 <shapr> I'm sure I'm not the first person to have had this idea, I just wonder if there's already an established system for fitting systems of calculation into human processing capabilities.
10:15:36 <shapr> for example, is there an established way to do spoken crypto past pig latin? :-)
10:17:39 <shapr> is there such a thing as a spoken abacus?
10:18:53 * shapr wonders how'd you chain together spoken calculations and state along with error checking
10:18:56 <Philippa_> shapr: I've done a degree of spoken crypto, insofar as I've talked about highly personal stuff with friends while somebody sitting next to us hadn't the slightest clue what we were talking about
10:19:15 <musasabi> yes, that can be accomplished quite easily.
10:19:25 <Philippa> though that's more steganography, I guess
10:19:26 <shapr> I bet conjugation could easily be used for single bit correction
10:19:29 <musasabi> With certain things having double meanings.
10:19:38 <Philippa> er, this went a bit further than that
10:20:10 <musasabi> and for example we don't need to say most things as they are known to each other out of the context.
10:20:32 <Philippa> yeah, a lot hinged on that - the trick was not giving any of the context away
10:21:36 <shapr> could probably use verb case for state storage maybe
10:22:33 * shapr tries to think of a good spoken type system
10:23:23 <shapr> finnish is the best ;-)
10:23:29 <vegai> hmm
10:23:39 <shapr> sinniset
10:23:53 <vegai> siniset?
10:24:00 <shapr> ok, that :-)
10:24:05 <shapr> blue plural, iirc
10:24:09 <vegai> yes
10:24:27 <vegai> blues? =)
10:24:40 <shapr> well, not exactly
10:24:45 <vegai> indeed
10:24:49 <shapr> I've forgotten 'blue eyes' in finnish
10:24:56 <vegai> siniset silm‰t
10:25:11 <shapr> so in that case the adjective takes on the plurality of the noune
10:25:12 <shapr> noun
10:25:38 <vegai> let's see... it's surprisingly hard to think about your first language on that level
10:25:45 <shapr> there are one or two languages that have different cases for one, two, three, and many
10:26:06 <shapr> english has singular and plural, I don't think it has a two case
10:26:15 <shapr> 'a pair of sheep'
10:26:20 <vegai> some old english did, I think
10:26:37 <shapr> vegai: siniset means 'my noun is blue and plural' right?
10:26:55 <musasabi> shapr: yes, that is blue plural.
10:27:03 <musasabi> siniset silm‰t = blue eyes\
10:27:24 <musasabi> sininen -> siniset and silm‰ -> silm‰t
10:27:49 <shapr> what else gets stuck to the adjective? anything more than plurality?
10:28:05 <musasabi> no that is the normal plural.
10:28:26 <shapr> siniset saunatassani? :-)
10:28:33 * shapr does evil things to finnish
10:28:56 <shapr> to go away from my two blue saunas?
10:29:06 <musasabi> sheep - lammas, sheep (plural) - lampaat, 'pair of sheep' - pari lampaita
10:29:10 <vegai> sinisist‰ saunoistani?
10:29:30 <shapr> oy, you're using latin-1 :-P
10:29:32 <musasabi> = from my blue sauna's 
10:29:42 <musasabi> shapr: all finnish irc channels are using latin-1
10:29:52 <vegai> shapr: aye, as is unfortunately everybody else here :/
10:29:52 <shapr> hm, I thought debian.fi was using utf-8
10:30:05 <shapr> anyway
10:30:07 <vegai> well, *they* might =)
10:30:11 <shapr> can you say that again?
10:30:17 * shapr waves the SILC flag
10:30:23 <vegai> sinisist‰ saunoistani?
10:30:48 <shapr> are those matching 'ist' endings?
10:32:07 <shapr> I think finnish is more brain-stretching than Haskell.
10:32:55 <shapr> what a cool language =)
10:34:50 <vegai> eehhm
10:35:14 <vegai> "sinis-ist‰ sauno-ista"+ni
10:35:31 <vegai> ist‰ and ista match, if I see it right
10:36:46 * musasabi wishes something more sensible than utf-8 existed in wide use.
10:37:27 <vegai> what's the problem with utf-8, musasabi?
10:37:40 <vegai> the only problem I see is that no-one is using it :)
10:37:54 <musasabi> vegai: well it is not a solution for CJK.
10:38:30 <Philippa> how does it fail there?
10:38:37 <musasabi> a solution with a switchable charset would be much nicer.
10:38:58 <shapr> SILC has mime messaging
10:39:09 <musasabi> Philippa: performance and unification.
10:39:13 <shapr> apt-get silky - http://www.silcnet.org/ 
10:39:40 <Philippa> as in "it's slow and everybody's using something else"?
10:39:46 <vegai> silc is cool. It shares the problem of utf-8, unfortunately
10:40:01 <shapr> silc is 100% utf-8, but also supports MIME
10:40:19 <shapr> can't you specify charset in MIME messages?
10:41:01 <Philippa> yeah, otherwise email'd still be ASCII
10:41:39 <musasabi> Philippa: it's slow and people want to handle the same characters different depending on language which unicode makes impossible (but EUC permits)
10:41:52 <Philippa> ah, yeah, that makes sense
10:42:16 <shapr> what's EUC?
10:42:31 <Philippa> you could wrap the unicode in a header, but you still get a PITA
10:42:48 <musasabi> http://www.cit.gu.edu.au/~davidt/cit3611/C_UNIX/euc.htm
10:42:58 <shapr> silc is very cool, but the silky client is flaky.
10:43:21 <vegai> something wrong with the irssi-like client?
10:43:27 <shapr> haven't used it
10:43:35 <shapr> is it in debian?
10:44:01 <shapr> The more I think about text chat, the more I like Gale.
10:45:14 <shapr> I often end up being in twenty IRC channels, with Gale I don't have that problem.
10:45:15 <vegai> I would like to do my communication via jabber as much as possible
10:45:21 <vegai> but no-one uses that either :-/
10:45:41 <shapr> gaim does irc, jabber, and silc
10:46:01 <vegai> it's not actually the protocol I like, it's the form of the client
10:46:04 * musasabi wants to use something that can be run inside screen
10:46:08 <shapr> is there anything that takes advantage of IPv6 multicast?
10:46:17 <vegai> IRC and friends waste my time more than they should
10:46:21 <shapr> heh
10:46:25 * shapr agrees with vegai 
10:46:44 <vegai> (I meant IRC's friends, not you people :)
10:46:45 <shapr> email has advantages because it's async
10:46:57 <shapr> but disadvantages because of too much spam
10:47:10 <shapr> web forums are really horrible to use
10:47:12 <shapr> (imho)
10:47:26 <vegai> aye, and for some weird reason, everybody uses *them*
10:47:56 <shapr> well all people who think interweb is a real word
10:48:12 <shapr> non-techies think browsers are the internet
10:49:31 <shapr> would be nice if opencroquet changes that
10:50:31 <vegai> but I gotta do some filthy Delphi exercises now
10:50:41 <shapr> have fun..
10:50:43 <shapr> or something
10:50:49 <vegai> yes, something
10:51:03 <vegai> well, I guess it could be worse
10:51:15 <vegai> this course used to be called "Windows GUI programming with C"
10:51:22 <shapr> ick
10:51:46 <shapr> Cale: oh hey, did you write a demo of Haskell calling a C++ lib?
10:51:49 <shapr> speaking of C...
10:52:10 <shapr> lots of paying C work in these parts, wonder if they'd take a Haskell wrapper...
10:53:31 <shapr> Igloo: ah, cale put demos here: http://www.haskell.org/hawiki/HaskellIrcPastePage
10:53:35 <shapr> I remember that now.
10:54:07 <shapr> Haskell's FFI is easier than writing Python modules in C
11:10:52 <shapr> hey, I'm canvassing for people to help me run haskell-libs and connected projects.
11:11:00 <shapr> I'd like to get a four-person team
11:12:24 <shapr> and by 'help me' I don't mean 'shae tells people what to do' :-)
11:26:05 <shapr> hiya Leimy
11:26:12 <Leimy> shapr: hello
11:26:25 <Leimy> shapr: I finally got a version of that State Monad word counter working
11:26:30 <Leimy> but not the way I wanted
11:26:45 <shapr> what does it look like?
11:26:45 <Leimy> then i went back and tried to make another program that comes closer but doesn't quite get it either :)
11:26:53 <Leimy> one second :)
11:26:57 <Leimy> have a pastebot in here?
11:27:00 <shapr> well, progress rather than perfection
11:27:14 <Leimy> well I have a working program that seems to do it
11:27:35 <Leimy> but I wanted the state to be whether the previous character was whitespace [Bool] and the current word count.
11:28:04 <np_hard> does anyone have any good candidates for a killer app that would be helped by haskell?
11:28:07 <Leimy> such that a transition from 
11:28:16 <Leimy> whitespace to non-whitespace meant to increment the counter
11:28:18 <shapr> np_hard: darcs is a good Haskell killer app
11:28:34 <Leimy> shapr: I've been meaning to get darcs
11:28:45 <shapr> np_hard: I bet MrProject (now planner?) could be rewritten in Haskell in less than a week, and would have less bugs and far more functionality
11:29:00 <Leimy> MrProject?
11:29:06 <Leimy> like Mr Coffee? :)
11:29:17 <shapr> like the masculine version of MS Project ;-)
11:29:47 <Leimy> Microsoft Projectile
11:29:49 <shapr> http://www.imendio.se/projects/planner/
11:30:14 <shapr> planner has gotten better
11:30:21 <shapr> MrProject was way flaky
11:30:31 <Leimy> oh that looks nice
11:30:35 <shapr> np_hard: can you name some killer app examples?
11:30:43 <Leimy> gantt charts and probably not PERT diagrams
11:30:51 <shapr> hej depaulis 
11:31:14 * Leimy had "The Management Scientist" in college
11:31:14 <shapr> andersca: oh hey, I saw Mikael Hallendal on the cover of a magazine in the shop today.
11:31:17 <Leimy> it did PERT :)
11:31:29 <Leimy> and it was DOS based
11:33:24 <andersca> shapr: wow, what magazine?
11:33:32 <np_hard> that's a good question actually
11:33:43 <shapr> um
11:33:43 * shapr gets the magazine
11:33:51 <np_hard> i would say Twisted is one for python
11:34:05 <np_hard> the jakarta project suffices for java
11:35:09 <shapr> andersca: dator magazin - linux special
11:35:13 <andersca> shapr: ah
11:35:51 <andersca> shapr: why is he on the cover?
11:36:16 <shapr> "d√§rf√∂r utvecklar jag gratis" - intervju med Mikael Hallendal p√• Imendio
11:36:25 <andersca> ah
11:36:29 <andersca> he's my ceo
11:36:36 <andersca> or rather, he's my boss
11:36:54 <shapr> I was very surprised to see a picture of a face I recognized on a magazine at the checkout stand
11:37:12 <andersca> need to get that mag...
11:37:47 <shapr> datormagazin.se, or domus/hemk√∂p checkout stand
11:38:09 <Leimy> shapr: http://paste.lisp.org/display/2815
11:38:39 <Leimy> doCount is doing too much work IMO
11:38:54 <Leimy> I wanted to keep the states  and their transitions in the Monad primitive functions
11:40:12 <Igloo> shapr: Ta, but I think I've decided it'll be easier just to rewrite it in C or Haskell
11:40:18 <Leimy> but this is my first Monadic anything so it's probably not very good
11:48:00 <Leimy> woohoo
11:48:02 <Leimy> darcs installed
11:48:12 <shapr> yay!
11:49:53 <shapr> greetings Russel
11:49:57 <shapr> er, Russell?
11:50:01 <roconnor> hi
11:50:05 <Leimy> heh
11:50:11 <shapr> two l, yes?
11:50:17 <roconnor> yes
11:50:42 <shapr> ok
11:50:46 <roconnor> Like Bertrand
11:50:59 * shapr doesn't see any l in bertrand ;-)
11:51:56 <Leimy> heh
11:52:05 <Leimy> it's pronounced but invisible
11:52:07 <Leimy> like a silent e
11:52:10 * shapr snickers
11:52:11 <Leimy> or the converse
11:52:30 <Leimy> My friend duane use to spell his name pdquakne
11:52:38 <Leimy> the p the q and the k are silent
11:52:38 * shapr laughs
11:53:05 <Leimy> I never knew who Pee-duh-quack-nee was
11:53:08 <Leimy> till he told me
11:53:18 <shapr> that's great
11:53:39 <Leimy> going to get groceries
11:53:40 <Leimy> bbl
11:53:47 <Leimy> then more haskell/darcs fun
12:59:10 <Igloo> Hmm, can I not test IO functions with QC?
13:04:01 <shapr> Igloo: QuickCheckM
13:06:01 <Igloo> ah, hmmm, ta
13:06:26 * Igloo decides that on balance unsafePerformIO is nicer than a non-standard module
13:06:47 <Igloo> But that explains why I thought it was possible but couldn't see how  :-)
13:15:24 <Leimy> shapr: did you get a chance to look at my Haskell and tell me how badly it sucks while I was gone? :)
13:16:29 <Boegel> hey shapr, long time no see :)
13:16:55 <shapr> I've looked at it, but my brain is on vacation
13:16:59 <shapr> hoi Boegel 
13:17:04 <Leimy> shapr: thx anyway :)
13:17:15 <Boegel> how's the magazine thing goign shapr ?
13:17:53 <shapr> I haven't done anything about it, I'm thinking of cutting back to two or three projects total
13:18:06 <Boegel> and is the magazine one of it ?
13:18:18 <shapr> I've been thinking of haskell-libs, darcs, and quickcheck
13:18:40 <Leimy> hmmm darcs diff doesn't seem to work on Mac OS X
13:18:41 <shapr> on the other hand, if enough people will commit to writing for Haskell Monthly, I'll do it.
13:18:50 <Leimy> it calls diff and says "extra operand"
13:19:00 <Boegel> how many people do you have already ?
13:19:58 <Lemmih> At least one.
13:25:30 <Boegel> brb
13:35:15 <Boegel> Lemmih, you said you would write for the magazine ?
13:39:38 <shapr> there's me and Lemmih 
13:40:34 <Leimy> and Leimy? :)
13:40:39 <Leimy> and Lemmy
13:40:49 <shapr> Leimy: are you writing for Haskell Monthly?
13:40:57 <Leimy> shapr: no... I just thought I was being cute
13:40:59 <Leimy> I was incorrect
13:41:05 * shapr looks at Leimy 
13:41:14 <Leimy> where is this Haskell monthly?
13:41:15 <shapr> well, I haven't seen you IRL, so I can't tell if you're cute :-P
13:41:19 * Leimy is interested
13:41:21 <shapr> Leimy: it doesn't exist yet
13:41:27 <Leimy> oh
13:41:36 <Leimy> is it "anything Haskell"
13:41:37 <shapr> I got jealous of the OCaml Weekly newsletter
13:41:40 <Leimy> or more focused
13:41:49 <shapr> I think it's anything Haskell.
13:41:57 <Leimy> cool
13:42:08 <Leimy> HUJ
13:42:12 <Leimy> haskell user's journal
13:42:13 <shapr> ?
13:42:38 * Leimy was thinking it might be like C/C++ User's Journal
13:43:45 <shapr> what's that like?
13:46:39 <Leimy> It's a published periodical with articles from gurus about dos and don'ts with C/C++
13:46:49 <Leimy> as well as some nifty projects from time to time
13:47:10 <Leimy> http://www.cuj.com/
13:47:21 <Boegel> getting gurus to write isn't that easy Leimy :)
13:47:27 <Leimy> http://www.cuj.com/current/
13:47:36 <Leimy> Boegel: no it isn't ... they have to want to :)
13:47:54 <Boegel> well, that's the problem :)
13:48:10 <Leimy> a lot of times they use the magazine article to promote a book they wrote
13:48:19 <shapr> sounds good to me
13:48:21 <Leimy> by giving a taste of what's to come
13:48:28 <shapr> I just want a monthly issue of neat Haskell stuff.
13:48:42 <Leimy> shapr: that's pretty much what this is... but for C/C++
13:48:47 <Leimy> clever idioms
13:48:51 <Leimy> beginner's corners
13:49:48 <shapr> right
13:49:48 <shapr> I've already signed up for shapr's n00b corner
13:49:48 <Boegel> :o)
13:49:48 <shapr> and probably the ACM puzzle column as well
13:49:51 <shapr> that one will be easy enough, choose a puzzle, then judge the entries and write about the best submission
13:49:51 <Leimy> well not so much for beginners in CUJ
13:50:07 <Leimy> shapr: nice... 
13:50:12 * Leimy is a new ACM member this year
13:50:15 <Leimy> didn't see ACM puzzles
13:50:19 <shapr> I'd like to have a spotlight column where someone profiles and discusses a library or application
13:50:28 <shapr> I've never been an ACM member, maybe I should start.
13:50:42 <Leimy> I think it's worth it for their massive database of papers and stuff
13:50:51 <Boegel> like GUI library's shapr ? :)
13:50:52 <Leimy> I found a PDF of McCarthy's Lisp paper
13:51:03 <Leimy> from the 60s
13:51:05 <shapr> so, puzzle, spotlight, n00b, what else?
13:51:08 <Leimy> or maybe the 50s
13:51:35 <Leimy> shapr: random naked chick
13:51:42 <shapr> um, huh?
13:51:48 <Leimy> you want readers? :)
13:51:56 <shapr> no, I want coders.
13:52:00 <Leimy> oh... nevermind then 
13:53:57 <Boegel> shapr, I thought you weren't going to continue this project ? :o)
13:54:10 <shapr> Boegel: I won't unless I get some writers.
13:54:25 <Boegel> well, I would write a GUI article for the first issue
13:54:40 <Boegel> but I can't promise I'll write an article for every issue
13:54:52 <shapr> hej ihb 
13:54:56 <shapr> ihb: are you really root?
13:54:59 <ihb> no
13:55:02 <shapr> whew
13:55:39 <andersca> hej ihb, do you live in emilsborg?
13:56:16 <Leimy> irc as root == bad juju
13:56:29 <shapr> hej ihb have you been here before?
13:56:33 <Boegel> what do you mean Leimy ?
13:56:47 <Boegel> you shouldn't be on irc while you're an admin in Windows ? or what ?
13:56:48 <Leimy> well i don't trust my IRC clients to be well written :)
13:57:02 <Leimy> and to be free of buffer overruns
13:57:04 <Leimy> etc etc
13:57:23 <Boegel> just chatting can't harm anyone now, can it :p
13:57:44 <Boegel> although, my girlfriend is having trouble with some strange mIRC virus on her laptop
13:57:47 <Leimy> that's probably what people thought about playing mp3s with mpg123 also :)
13:57:49 <Boegel> and she isn't admin
13:58:00 <Leimy> they found an exploit in that too
13:58:14 <shapr> jpgs are exploitable now in windows
13:58:35 <Boegel> whatever you do, if you're on the net, your always gonna be volnurable for attacks
14:00:24 <TheHunter> ah crap, neither ghc nor hugs seem to like free type variables in the context declaration that are meant to be universally quantified [like MonadTrans t, Monad (t (Cont r))]
14:00:28 <ihb> andersca: yepp
14:01:01 <ihb> shapr: yes, a while ago.
14:03:32 <shapr> ihb: welcome back!
14:06:09 <andersca> ihb: we do have #haskell.se too you know
14:11:11 <ihb> can anyone give a minimal example of a closure in haskell?
14:11:49 <monochrom> \x -> y
14:12:04 <monochrom> where y comes from an outer scope
14:12:09 <ihb> monochrom: that's a bit too minimal, as y isn't defined somewhere :-)
14:12:14 <monochrom> Actually \() -> y is even smaller.
14:12:35 <shapr> hiya pesco 
14:12:39 <monochrom> Well I'm asked for a closure, not a closure and its context.
14:12:59 <pesco> Hey shapr.
14:13:18 <monochrom> I also want to let the reader fill in whatever context he fancies.
14:16:40 <Boegel> \x -> x then ?
14:17:08 <monochrom> The minimal trivial one would be \() -> ().
14:17:36 <monochrom> However, when people ask for an example of ellipse, they seldom accept a circle (much less a point).
14:17:42 <Philippa> arguably not a "closure" insofar as it's not capturing it
14:17:45 <Philippa> exactly
14:18:04 <monochrom> So when people ask for a closure, they want a free variable at the very least.
14:18:23 <Philippa> \x -> x is "as" trivial as \() -> () IMO, if not more so
14:18:53 <Philippa> at least, in the Haskell interpretation where x is a pattern variable whereas () is the value of type ()
14:19:23 <Leimy> Philippa: what's ()'s name again? 
14:19:41 <monochrom> I disagree with those illogical people, but I live with it.
14:19:53 <Philippa> as in "how do you pronounce it out loud"? I'd pronounce it "unit"
14:19:58 <monochrom> (I cannot kill them all.)
14:20:08 <Philippa> ("type with one value", as opposed to void, a type with no values...)
14:20:09 <ihb> f x = g; where g y = x + y; -- would this be a (good) example of a closure?
14:20:17 <Leimy> Philippa: that's it :)
14:20:30 <Philippa> but I'd write it (), of course :-)
14:20:34 <Leimy> sure
14:20:58 <Philippa> igb: yeah, the end result is
14:21:30 <Philippa> or just f x = \y -> x + y, which still evaluates to a closure
14:21:39 <Philippa> ihb even, damn my tyops :-)
14:22:05 <ihb> Philippa: i didn't remember the lamba syntax (if that's what it's called).
14:22:56 <Philippa> yeah, fair enough
14:23:02 <monochrom> Naw
14:23:16 <monochrom> There were like 5 examples of the lambda syntax before.
14:23:40 <desrt> \monochrom -> rawr
14:23:49 <ihb> monochrom: but none which used anything but an "atom" as the expr.
14:23:59 <Philippa> anyway, once you evaluate f, you just have (\y->x + y), the value of x is "closed" if that makes sense
14:24:41 <Philippa> OK, lemme rephrase - once you evaluate f x for some x...
14:26:21 <flaw> ot, but: anyone know of an ML for designing RDB schemas/layout...? a relational protocol definition language of sorts.. ? from which you could render SQL or potentially other languages to create the necessary tables to "conform"(implement would probably be a better word) to the protocol within a database?
14:27:33 <monochrom> I just know HaskellDB seems good.
14:27:38 * shapr agrees
14:27:43 <shapr> yay HaskellDB!
14:27:56 <monochrom> However, I also know of a similar library for ocaml
14:27:59 <shapr> flaw: I think it already does that.
14:28:07 <monochrom> The library doesn't come with ocaml.
14:28:12 <flaw> shapr: what does? haskeldb?
14:28:16 <shapr> yes
14:28:32 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDbTutorial
14:28:32 <ihb> Philippa: the function f in "f x = x + y; where y = 1" would also be a closure, right? (even though it's a rather useless example)
14:31:42 <flaw> shapr: I see your point, but I guess I'm looking for something that wouldn't require a haskell compiler to use.. I was thinking an XML definition as it seems like it might be appropriate, and I figured it likely that someone drew up a def by now considering all the lovely hype..
14:34:27 <TheHunter> Does it even make sense to speak of 'a closure'? Shouldn't you say something like "the closure of \x -> x + y is \y x -> x + y"?
14:35:18 <ihb> TheHunter: that's kind of my question too, even though i don't understand your second question.
14:39:35 <Leimy> I think he means the closure involves the application of something to "close" that variable
14:39:35 <TheHunter> ihb: The definition of closure I know is "if a is a term with exactly the free variables x1, ... xn, then its closure is the term \x1 ... xn -> a". The term \x -> x + y has the free variable y (x is bound), so its closure is the term \y -> \x -> x + y.
14:39:50 <Leimy> ah... "bind" that's the word :)
14:40:33 <TheHunter> and of course, any closed expression is a closure (the closure of itself)
14:41:02 <Leimy> like 2
14:41:06 <ihb> TheHunter: closed expression == no free vars?
14:42:04 <TheHunter> ihb: yep
14:42:09 <ihb> TheHunter: is it meaningful to speak of closed expressions as closures? in your definition above, wouldn't it make sense to add "with n > 0"?
14:43:18 <ihb> a more general language independent definition of closures is "a datatype (usually function) that deeply binds its lexical context"
14:43:28 <TheHunter> ihb: i guess that would make things more complicated. Usually, you require a closure operation to satisfy something like: "the closure of the closure of a is the same as the closure of a"
14:44:17 <TheHunter> ihb: well, i feared there'd be another definition
14:44:33 <ihb> or perhaps adjust what i said with "an instance of ..."
14:47:01 <TheHunter> ok, that's weird. Because that'd mean that the closure contains free variables
14:47:04 * TheHunter is confused
14:47:38 <ihb> TheHunter: it means that the variables are bound to something at an outer scope.
14:49:26 <ihb> f x = g; where g = x + y -- f 3 returns a closure, in my world. that world may not be unified with the haskell world though.
14:49:52 <TheHunter> ihb: that sounds reasonable
14:52:00 * TheHunter doesn't think there should be two words for closures and closures
14:53:08 <ihb> TheHunter: i only know closures from Perl, but i'm trying to learn more about them on a more language independent plane and compare with other languages.
14:55:15 <TheHunter> ihb: closures in java are weird (in haskell they do exactly what you think)
14:56:08 <ihb> TheHunter: a closure in java would be an inner class?
14:56:43 <TheHunter> or an anonymous instance of an interface
14:57:29 <ihb> which is done through an inner class?
14:58:38 <TheHunter> the problem is, java only allows you to bind final variables to free variables of the closure
14:58:57 <shapr> so, make a final mutable var?
14:58:58 <maihem> hm, I haven't done any haskell for a while and I feel really dumb here... is Nothing a type constructor for Maybe? and should import Maybe bring it into scope?
14:59:18 <shapr> maihem: Nothing is a type constructor for Maybe, yes.
14:59:50 <TheHunter> ihb: i don't know if this tecnically is an inner class
15:00:05 <maihem> thx, need to figure out why the hell this isn't working!
15:00:09 <TheHunter> something like new MyInterface {...}
15:00:23 <shapr> maihem: import Data.Maybe for the new hierarchical imports
15:00:32 <TheHunter> new MyInterface() {...} or something similar
15:01:09 <shapr> isomer: hiya anth!
15:01:31 <isomer> hi shae - what's happening?
15:01:50 <shapr> swedish class tomorrow morning, I gotta sleep if I want time for unicycling before class.
15:01:51 <shapr> g'night!
15:02:16 <ihb> TheHunter: yes, that is compiled to a class called something with $N at the end, where N is just an increasing number.
15:02:17 <maihem> ah, no, I was using Nothing in an instance statement :)
15:02:47 <isomer> well, have fun then :)
15:03:41 <TheHunter> ihb: you're right, it's an inner class then. Anyway, it make programming 
15:03:50 <TheHunter> 'functionally' in java a pain
15:03:57 <Boegel> g'night shapr ! 
15:04:04 <ihb> TheHunter: yeah. it wasn't designed for that really :-)
15:05:35 <TheHunter> right java was designed to limit the damage a bad programmer can do :)
15:10:55 <Boegel> hey TheHunter, not to fast
15:11:12 <Boegel> it's just a higher generation of programming
15:11:21 <Boegel> it allows you to concentrate on other things
15:11:34 <Boegel> you don't mind bit functions in C++ either, don't you ?
15:11:40 <TheHunter> Boegel: are you a java fan?
15:13:11 <TheHunter> first of all, closures in java are a pain to use, and it would be trivial to implement them properly
15:14:29 <TheHunter> I don't like Java because everything is extremely verbose.
15:14:42 <atom-z> *nods*
15:14:48 <atom-z> too business model
15:14:53 <atom-z> and design patterns
15:15:05 <TheHunter> don't get me started on design patterns...
15:15:33 <Boegel> it's the most important language we saw at the university
15:15:48 <Boegel> I know it quite well
15:16:03 <Boegel> what's wrong with design patterns ?
15:16:17 <Boegel> it's a standard solution for a standard problem...
15:16:23 <Boegel> you're not stuck to it
15:16:30 <arjanb> they are just workarounds for language limitations
15:17:13 * TheHunter says "Visitor Pattern" and runs away screaming
15:17:46 <Boegel> I don't know all the patterns
15:17:59 <ihb> TheHunter: what's the visitor pattern?
15:17:59 <Boegel> but MVC isn't really a work-around now is it :)
15:18:06 <Boegel> Proxy isn't either
15:18:13 <Boegel> you say RMI is a workaround ?
15:18:41 <Boegel> (I had to do a lecture on that with some co-student, so I know RMI quite well)
15:19:05 <atom-z> TheHunter, i have to learn that kind of crap for A-level
15:19:09 <arjanb> RMI?
15:19:29 <TheHunter> ihb: it's an extremely stateful way of solving a problem where you have to do something with every node of a tree (or similar datastructures)
15:19:55 <atom-z> from what i can see its:- i have a problem... lets see how we can write it all down to keep the boss happy, instead of actually solving irt
15:19:57 <atom-z> err
15:19:58 <atom-z> it
15:20:38 <Boegel> RMI = Remote Method Invocation
15:20:52 <arjanb> that isn't a design patterns
15:20:55 <Boegel> basicly using objects that are not on your machine, but on an other one
15:21:19 <TheHunter> Boegel: some of those patterns have a point, but many of them are really only workarounds
15:21:34 <Boegel> so there are no workarounds for C/C++ ?
15:21:41 <Boegel> it's just plain perfect ? :o)
15:22:15 <Boegel> true arjanb, but it is built upon one: Proxy
15:22:18 <TheHunter> Boegel: i don't think anyone here thinks C is the perfect language
15:23:30 <TheHunter> Boegel: We don't have the perfect language yet, but it'd be interesting to know how "dependently typed" and how "categorical" it would be
15:26:50 <Boegel> Java is slow, okay, and the made some design mistakes that they're stuck to now, ok
15:27:11 <Boegel> but still, if they would start over (which they won't), they would have a great language
15:27:17 <atom-z> java assumes the programmer is stupid
15:27:38 <Boegel> java helps the programmer with aspects he shouldn't worry about
15:27:38 <vegai> atom-z: which is not a bad assumption for most 
15:27:38 <TheHunter> don't say Java is slow in a Haskell channel!
15:27:59 <Boegel> memory managment -> that can happen automaticly
15:28:04 <Boegel> why not TheHunter ?
15:28:13 <atom-z> haskell is slow+
15:28:19 <TheHunter> well, err..., haskell is slower
15:28:25 <Boegel> heh
15:28:34 <Boegel> that promises for my ray tracer :|
15:28:34 <TheHunter> actually, Java is fast
15:34:08 <pesco> Actually, Haskell is fast.
15:34:09 <Boegel> sow, if I would make Java calculate Pi, and let Haskell do the same, with the same algorithm, Java would beat Haskell ?
15:34:51 <pesco> Depends.
15:35:03 <Leimy> 2 problems
15:35:08 <Leimy> 1 pi doesn't terminate
15:35:17 <Leimy> so neither would finish... what are you measuring :)
15:35:37 <Leimy> write a Java fibonacci generator
15:35:42 <Leimy> and a Haskell one
15:35:51 <Leimy> memoize both and compare
15:36:24 * Leimy has a really fast memoized C fibonacci
15:36:26 <Boegel> I won't do that now, but which one will be faster ?
15:36:35 <Leimy> depends
15:36:43 <Leimy> does the Java implementation use a JIT?
15:36:54 <Boegel> JIT ?
15:36:58 <Leimy> Just In Time Compiler
15:37:07 <Leimy> where it converts to native code before running
15:37:23 <Boegel> i have no idea, you tell me :p
15:37:24 <Leimy> did your Haskell implementation compile to native code or is it being interpretted?
15:37:29 <Leimy> lots of factors
15:37:39 <Leimy> saying "java is fast" is an implementation detail
15:37:47 <Boegel> yeah but overal I mean
15:38:05 <Boegel> you can't say Java is faster than C/C++ because it simply isn't :)
15:38:17 <Leimy> is C++ ever faster than C?
15:38:21 <Leimy> is it always?
15:38:26 <Boegel> I have _no_ idea :p
15:38:29 <Leimy> hehe :)
15:38:35 <TheHunter> wow, the shootout even suggest that ghc is faster than java
15:38:37 <Boegel> I'm comparing C/C++ with Java !
15:38:38 <Leimy> see it doesn't always make sense to even talk about that
15:38:41 <np_hard> if any emacs haskell-ghci-mode users want to look at http://paste.lisp.org/display/2820#1 and give their honest opinion, I am all for it -- my first elisp ever
15:39:35 <Leimy> Boegel: Java was known to be as fast and sometimes faster than some native C programs on Windows
15:40:01 <Leimy> depends on the kinds of optimizations involved... cache misses etc etc
15:40:10 <Leimy> you can't just say "this language is faster than this other language""
15:40:31 <Leimy> some problems have great solutions in some languages and not so great solutions for other problems
15:40:41 <Leimy> that's the way i try to look at it
15:43:26 <Boegel> true Leimy
15:43:50 <Leimy> sometimes compilers can reduce things in different ways too
15:44:01 <Boegel> and with that thought in mind, I'll go to sleep now :)
15:44:09 <Leimy> a recursive C solution written almost the same way as you would write it in lisp or haskell will likely get beat by Haskell or Lisp :)
15:44:40 * Boegel wishes everyone a good night
15:44:45 <Leimy> night!
15:46:30 <TheHunter> good night, Boegel 
15:51:35 <np_hard> Leimy: no way
15:52:20 <np_hard> gcc -foptimize-sibling-calls
15:52:21 <np_hard> :)
15:52:42 <Leimy> I've not tried that one :)
15:53:08 <np_hard> optimizes tail recursion
15:53:51 <Leimy> that would certainly help :)
15:54:08 <Leimy> if it can truly reduce my recursive calls to some form of iterations in a loop
15:54:10 <Leimy> or something
15:55:35 <np_hard> yep
15:55:54 <Leimy> memoization should still beat it pretty well though 
15:56:01 <Leimy> for fibonacci anyway :)
15:56:54 <np_hard> a straight calculation would be faster still :)
15:57:11 <Leimy> yes
16:18:14 <Leimy> anyone want to look at some haskell code for me?
16:18:18 <Leimy> I'm stumped
16:18:26 <Leimy> it compiles ok but it's not doing what I want :)
16:20:01 <Leimy> and it involves monads
16:22:16 <TheHunter> Leimy: Post it to the paste page, i'll have a look
16:22:57 <Leimy> TheHunter: which is the paste page?
16:23:05 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:23:09 <Leimy> thank you
16:25:24 <Leimy> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
16:25:26 <Leimy> doh!
16:25:28 <Leimy> not preview
16:26:14 <Leimy> I wanted to do a word counter using the state of the current and previous characater
16:26:34 <Leimy> if the previous was whitespace and the current is non-whitespace increment the counter
16:26:49 <Leimy> and set the new boolean state to false
16:27:03 <Leimy> so my state in the monad is a pair of Integer, Bool
16:27:10 <TheHunter> ok
16:27:44 <Leimy> wordCount starts the state off with "True" so that the first non-whitespace character increments the word counter.
16:28:23 <Leimy> and the doCount function takes whether the previous state was whitespace.
16:28:35 <Leimy> and returns a monad.
16:28:41 <Leimy> er .. a Counter 
16:49:30 <TheHunter> Leimy: You're there
16:49:32 <TheHunter> ?
16:50:06 <Leimy> yes
16:50:59 <TheHunter> sorry, i'll need another minute
16:51:09 <Leimy> :)
16:51:18 <Leimy> I've needed more than minutes to grok monads :)
16:51:30 <Leimy> it's not clear I really do yet :)
17:04:01 <TheHunter> ok, Leimy I kinda give up...
17:04:56 <TheHunter> the short solution is to replace the two  (snd c)'s in doCount by False and True, respectively
17:05:22 <TheHunter> the problem with your program is that it doesn't really use the state monad at all.
17:05:36 <Leimy> it doesn't?
17:06:07 <TheHunter> sure it does, but not in an essential way
17:06:08 <Leimy> hmmm
17:06:39 <Leimy> the idea is snd c should be the new state as the operation in getCount and incCount returns
17:06:55 <TheHunter> I couldn't really figure out what exactly the getCount and incCount should do.
17:07:17 <Leimy> incCount is called with "true" when the previous character was whitespace
17:07:26 <Leimy> that means we hit the beginning of a word
17:07:32 <TheHunter> yeah that's clear
17:07:56 <Leimy> False means the previous character wasn't whitespace... so I just get the current count and keep the current character as "false" meaning non-whitespace
17:07:57 <TheHunter> they all do different things that should be separeted
17:08:21 <Leimy> but then my doCount wouldn't be "generic"
17:08:38 <Leimy> I'd have to have more complexity in doCount
17:09:36 <Leimy> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:09:39 <Leimy> that second one works
17:09:43 <Leimy> but the state is now just a counter.
17:09:53 <Leimy> and I was hoping to keep the previous character in the monad as well
17:10:03 <Leimy> "wordcounter.hs"
17:10:37 <TheHunter> Leimy: Your new solution is much cleaner
17:10:46 <Leimy> you think so?
17:10:49 <Leimy> I started with that :)
17:10:55 <Leimy> and wanted to move more state to the monad :)
17:11:27 <Leimy> I guess it's cleaner because the Monad primitive functions "getCount" and "incCount" are more... primitive :)
17:11:55 <TheHunter> yes, and because they don't do things they're not supposed to do
17:12:05 <Leimy> like one calling the other? :)
17:12:26 <TheHunter> and like a function get... changing the state
17:12:34 <Leimy> sure
17:16:59 <TheHunter> Leimy: I guess what you were trying to do is to put the information if the last character was whitespace into the monad and then immediately extract it afterwards
17:17:15 <Leimy> what I'm not sure of is why when I do <- to a function that returns a monad that I seem to just get the State back... is that expected?
17:18:18 <TheHunter> a more reasonable type of incState would be incCount :: Counter ()
17:18:35 <Leimy> TheHunter: you guessed correctly
17:19:06 <TheHunter> if you don't need the value a monadic functino is returning, you can just write doStuff instead of c <- doStuff.
17:19:38 <Leimy> so the <- yield the "function" result of the monadic type.
17:19:48 <Leimy> er yields
17:20:27 <TheHunter> yes, kinda
17:20:56 <TheHunter> look at the line "| not (elem x whitespace) && not wasWs = do c <- getCount"
17:20:58 <Leimy> so the action defines the function operation
17:21:50 <TheHunter> getCount doesn't change the state and you don't use c, so you can simply remove c <- getCount
17:22:58 <Leimy> but I can't call snd on getCount's normal return type can I?
17:23:59 <TheHunter> no, you can't. The do notation allows you to get the value in spite of that.
17:25:25 <TheHunter> You know http://www.haskell.org/hawiki/MonadsAsContainers?
17:25:37 <Leimy> TheHunter: oooh I missed that somehow
17:26:05 <Leimy> lists are monads aren't they?
17:26:21 <Leimy> or are they just instances of Functor?
17:26:22 <TheHunter> it's pretty nice. You can picture the state monad as a container which holds a new state for every possible starting state.
17:26:27 <TheHunter> lists are monads.
17:26:38 <TheHunter> they allow you to implement non-determinism
17:27:08 <Leimy> TheHunter: that sounds like a state machine and a state transition engine
17:27:25 <Leimy> well those are the same I guess
17:27:32 <Leimy> I should just say "state machine" :)
17:28:59 <Leimy> I think the reason the bind definition bothers me is that the symbols chosen to represent the function don't mean much to me
17:29:17 <Leimy> I mostly cut and pasted my >>=  definition from another area
17:29:22 <Leimy> in an effort to explore it later
17:29:59 <TheHunter> it's not that important to understand the definitions from the beginning.
17:30:43 <TheHunter> it's important to know how to use the monads. And there are a lot of monads in the library you can practise with
17:31:11 <TheHunter> Btw, your Counter Monad, is essentially the state monad from Control.Monad.State
17:31:51 <Leimy> so i could have just used Control.Monad.State and used it with Integer for my "working" example
17:32:16 <Leimy> and the pair (Integer, Bool) for my other non-working one :)
17:32:40 <TheHunter> yeah, type Counter = State Integer
17:32:52 * Leimy tries it
17:33:09 <TheHunter> getCounter = get
17:33:14 <Leimy> do I need to import it?
17:33:34 <TheHunter> incCounter = update (+1)
17:33:42 <TheHunter> import Control.Monad.State
17:33:48 <Leimy> TheHunter: does that employ "lifting" to get the +1 ?
17:34:01 <TheHunter> err, modify (+1)
17:34:23 <TheHunter> no, that's a state update
17:35:18 <TheHunter> lifting is liftM (+1) which is helpful if you're not using the do notation
17:35:44 <Leimy> I see
17:35:49 <Leimy> that's for more generic programming then?
17:36:24 <TheHunter> it's a different style
17:37:46 <TheHunter> liftM (+1) mx is the same as do {x <- mx; return ((+1) x) }
17:38:19 <Leimy> hmmm
17:40:20 <Leimy> if Counter is now "type Counter = State Integer"
17:40:33 <Leimy> my wordCount function has to change since it's calling a constructor for Counter
17:40:56 <TheHunter> right
17:42:22 <Leimy> now it says "Counter is not applied to enough type arguments"
17:42:23 <TheHunter> evalState doCount 0 should do it
17:42:42 <Leimy> doCount s 0 you mean
17:42:45 <Leimy> have to pass the string
17:42:48 <TheHunter> evalState runs the computatino doCount with initial state 0
17:43:25 <TheHunter> right evalState (doCount s True) 0
17:44:25 <TheHunter> sorry, it should be execState
17:44:26 <Leimy> cool... still have Counter is not applied to enough type arguments in the type signature: "doCount :: String -> Bool -> Counter"
17:44:41 <TheHunter> execState returns the final state (evalState the final value)
17:45:47 <TheHunter> it should still be Counter Integer
17:45:58 <Leimy> even though Counter is "State Integer"?
17:46:02 <Leimy> State Integer Integer?
17:46:38 <TheHunter> exactly
17:46:51 <Leimy> ok... why? :)
17:47:07 <TheHunter> the first integer is the type of the state
17:47:24 <TheHunter> and the second integer is the return type of the monadic computation
17:47:52 <Leimy> ah!
17:48:09 <Leimy> it's all working now except for incCount
17:48:16 <Leimy> which has the wrong definition for the type
17:48:28 <Leimy> modify (+1) is State Integer ()
17:48:33 <Leimy> not State Integer Integer
17:48:44 <Leimy> do I want "get $ modify (+1)"
17:49:15 <Leimy> oh
17:49:21 <Leimy> I think I just have the wrong type for incCount
17:49:26 <Leimy> I don't need the value to be returned
17:49:36 <TheHunter> no, you don't use the return value of incCount anyway, so you might as well return ()
17:49:41 <Leimy> yeah :)
17:49:55 <Leimy> since it's still State Integer it's still "chainable"
17:50:17 * Leimy envisions doCount applying various functions... like a long unix pipe
17:50:26 <Leimy> and that execState seeds it and gets the result
17:50:34 <Leimy> or series of pipes
17:50:38 <Leimy> is that fairly accurate?
17:50:50 <TheHunter> yeah
17:51:06 <Leimy> one could see some opportunities for parallelism there :)
17:51:35 <Leimy> getCount and incCount could run on different hardware and just be end-to-end connected on a cluster
17:52:12 <Leimy> it would make for an interesting scheduler for Haskell anyway
17:52:55 <Leimy> well that's much better than what I had
17:53:10 <Leimy> and it looks more like a proper Monad definition anyway... since I wasn't implementing Functor in mine
17:54:08 <TheHunter> yep, in 99% of the cases you don't implement your own monads.
17:54:25 <Leimy> TheHunter: it seemed I'd be using the same definition for >>= over and over anyway :)
17:55:02 <TheHunter> ok, Leimy I'm gonna go to bed.
17:55:10 <Leimy> thanks for your help!
17:55:18 <Leimy> I'm going to read that wiki page now
17:55:36 <TheHunter> good night, then
17:55:44 <Leimy> night!
19:17:06 <Leimy> @type map
19:17:07 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
19:17:35 <Leimy> @do x <- [10,20,30]; y <- [x,x+1]; if y > 20 then []  else [y,y]
19:17:35 <lambdabot> Sorry, I don't know the command "do", try "lambdabot: @listcommands"
19:17:39 <Leimy> doh
19:17:40 <Leimy> :)
19:38:13 <G|u][> guys is there a way to get the number of elements in a list?
19:38:39 <Leimy> I've often wondered that myself :)
19:38:50 <tautologico> like
19:38:52 <heatsink> length?
19:38:54 <tautologico> @type length
19:38:55 <lambdabot> length :: forall a. [a] -> Int
19:38:58 <Leimy> yeah :)
19:38:58 <tautologico> ?
19:39:03 <Leimy> but that traverses doesn't it?
19:39:07 <Leimy> I guess you must :)
19:39:09 <heatsink> yea
19:39:16 <heatsink> If you don't want to traverse, use an array
19:39:21 <Leimy> yep
19:39:52 * Leimy is trying to figure out what "join" would mean for a Tree
19:40:04 <Leimy> as an exercise
19:41:14 <G|u][> tnx
20:37:41 <heatsink> How do I make a Float that has value +Inf?
20:37:45 <heatsink> or NaN?
20:45:19 <heatsink> Prelude> decodeFloat (3.0/0.0)
20:45:21 <heatsink> (./,),(-*,(,-53)
20:45:26 <heatsink> WTF?
21:23:15 <dons> This might be interesting to #haskell: http://iki.fi/tuomov/riot/
21:23:23 <dons> "Riot is a tool for keeping (textual) information organised."
21:23:33 <dons> Particularly the curses interface...
21:23:46 <dons> oh, riot is written in Haskell :)
21:24:26 <Leimy> yeah
21:24:28 <Leimy> that's cool
21:24:30 <Leimy> GHC in fact
21:27:38 <dons> I wonder if tuomo will rewrite ion in Haskell now
21:33:12 <dv_> won't work on free/openbsd since they don't have wchar.h. oh well
21:33:39 <dons> nope. sigh
21:34:20 <dv_> maybe i can remove all the references and it'll magically work
21:34:36 <dons> should disable wchar binding if wchar.h isn't found (like GHC)
21:34:41 <dons> and just go with ascii
21:47:12 <dv_> well i removed wchar and compiled successfully, but it fails here:
21:47:14 <dv_> Fail: System.Posix.User.getUserEntryForID: not supported
21:47:56 <dons> hmm. on openbsd?
21:48:02 <dv_> yes
21:48:08 <dons> let me see...
21:50:01 <dons> which ghc are you using?
21:50:22 <dv_> 6.2.1
21:51:19 <dons> ok. should work I think. All it needs is getpwuid(3) which we have
21:51:30 <dons> but maybe ghc isn't picking it up a configure time
21:51:43 <dons> (I get same issue with 6.3)
21:55:18 <dons> ah. it's looking for getpwuid_r, which we *don't* have
21:55:34 <dons> now, how to fix. hmm
22:05:09 <dv_> if you figure something out, could you tell me? i have to run
22:05:36 <dons> sure. looks like we have to patch ghc's library for the openbsd case
22:07:09 <dons> alternatively, you could just write a patch to riot. but i'm going to patch the libs anyway
22:57:48 <dons> anyone have a link to the House Haskell OS info?
22:58:54 <musasabi> ,prmomg
22:59:00 <musasabi> *morning even
23:04:29 <shapr> house?
23:04:43 <shapr> musasabi: can I quote that? :-)
23:05:09 <dons> shapr: House was a new project over hOp that was demoed before lunch at hw2004
23:05:17 <dons> not an official talk
23:05:38 <shapr> oh wow
23:05:39 <dons> they booted it on a thinkpad, which was very nifty
23:05:44 <shapr> who did the demo?
23:05:53 <dons> trying to remember..
23:07:52 <shapr> hiya jesse
23:08:09 <musasabi> shapr: yes.. if you want to.
23:08:37 <shapr> musasabi: that's a very evocative quote about mornings imho
23:09:32 * musasabi continues his quest inside ghc
23:10:07 <shapr> what are you questing for?
23:12:48 <musasabi> shapr: changing the internal representation for lists.
23:12:51 <shapr> oh
23:13:02 <musasabi> shapr: currently it is more of a dream though.
23:15:12 <dons> internal representation of lists... sounds hard to do without changing everything
23:15:24 <musasabi> as a first step I am looking into transforming head pattern matching with list into pattern guards (foo ([]) = ... => foo (x) | null x = ...) and (foo (c:cs) = ... => foo(x) | not (null x), c <- head x, cs <- tail x = ...
23:16:26 <dons> oh, so not internal representation as such, but compiler transformation
23:16:44 <dons> not as hard as changing list representations
23:17:28 <dons> musasabi: but which code is faster? what do pattern guards get deSugared to?
23:18:03 <musasabi> dons: well when that is added I dream to make data List a = Cons a (List a) | Nil | LChunk Array# Int# Int#
23:18:54 <dons> that sounds good. I'd like a compiler flag, e.g. -fpacked-strings, maybe
23:19:18 <dons> but there are quite sensible reasons to just use the Packed string library also
23:19:50 <musasabi> dons: the PackedString in the base library is broken for several reasons.
23:20:06 <dons> which ghc version?
23:20:43 <musasabi> dons: even cvs ;) (it does work, just that it is quite unusable)
23:20:52 <dons> oh, sure
23:21:15 <dons> but it works quite well :)
23:21:48 <musasabi> dons: things like it taking four times more memory than needed..
23:22:01 <musasabi> and having abysmal concatenation performance.
23:22:23 <dons> oh! well, they're bugs really. you could profile and submit patches..
23:22:29 <musasabi> and one still has to convert PackedStrings to Strings at interface boundaries.
23:22:35 <dons> yep
23:23:38 <dons> have to be very careful to preserve string semantics
23:25:18 <musasabi> Currently every application just defines their own string types which is not a very good way imho.
23:25:37 <musasabi> e.g. ghc has StringBuffer and FastString.
23:26:13 <dons> yep. not good at all. SimonM has previously commented on this here.
23:26:28 <dons> i'm still not sure what the answer is, other than a really good string library
23:27:41 <dons> would be interesting to see what, e.g. Ocaml does for this stuff
23:28:02 <musasabi> dons: it has array based strings if I remember correctly.
23:28:49 <musasabi> The argument that String should be kept simple and clean is not very good when we don't apply that to numbers and it forces anyone doing serious string processing to use their own abstractions.
23:30:09 <dons> so you'd like an unboxing for Strings optimisation? that would be cool
23:31:06 <dons> since we already do serious magic to Ints
23:31:37 <musasabi> the controversial thing is that I would like to make the chunks based on bytes.
23:32:02 <dons> yeah. since Char is an u_int32..
23:32:10 <dons> in GHC, anyway
23:32:25 <musasabi> This is because 1) doing IO with chars > 255 is not possible, 2) then mmap:ed files could be used as strings..
23:32:36 <dons> ah.. that is nice
23:32:51 <dons> I think it sounds like a reasonable idea
23:39:27 <Pseudonym> String is currently optimised for undergraduate lab classes and not a lot else.
23:39:55 <dons> yep! :)
23:40:28 <Pseudonym> Which is actually quite understandable.  H98 was deliberately designed to be a simplification of previous Haskells.
23:41:19 <dons> and GHC will give you Char# if you treat it nicely
23:43:31 <Pseudonym> I think there are two main barriers to a better string representation:
23:43:38 <Pseudonym> 1. Unboxed values are not "standard".
23:44:04 <Pseudonym> 2. You can't look at strings independent of looking at other kinds of containers, and nobody can agree on a good interface for containers either.
23:46:02 <dons> esp. the last point, i think
23:46:51 <Pseudonym> Right.
23:47:02 <Pseudonym> The first is a problem only because of the second.
23:47:10 <Pseudonym> A container of Char# is hard to visualise.
23:47:22 <Pseudonym> Though, of course, it could just be that internally, and Char externally.
23:54:00 <musasabi> or even Byte# internally ;)
