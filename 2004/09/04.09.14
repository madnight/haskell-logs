00:35:44 <xkb> any users of ghci on mac osx?
00:35:52 <xkb> or ghc
00:36:38 <xkb> I previously installed ghc trough darwinports
00:36:39 <shapr> ozone does, dunno if he's awake
00:36:48 <xkb> shapr, ok..
00:36:55 <shapr> I think pesco too
00:36:55 <xkb> ozone, you awake :P
00:37:00 <shapr> though he's not here
00:37:15 <xkb> I can only find a binary in /opt/local/bin/ghci
00:37:32 <xkb> so perhaps the binary overwrites the darwinports version
00:57:15 <ozone> re
00:57:20 <shapr> y0 y0
00:57:27 <xkb> What is the difference between Control.Exception.catch and GHC.Exception.catch?
00:57:32 <xkb> hi ozone 
00:57:37 <ozone> hey *
00:57:41 <xkb> do you use ghci from darwinports?
00:57:46 <xkb> or ghc
00:57:55 <ozone> i don't, but i hear it works ok.  the version in /opt/local/bin/ghci would be the darwinports one
00:58:06 <xkb> ok..
00:58:09 <ozone> i use wolfgang thaller's GHC disk image, or roll-my-own
00:58:27 <xkb> and wt's version? That's in /usr/local/bin ?
00:58:31 <ozone> that's right
00:58:38 <Pseudonym> Nytol!
00:58:41 <xkb> ok.. then I found the correct one :D
01:01:40 <shapr> hoi wouter 
01:01:46 <wouter> hi
01:02:20 <xkb> hmm.. how can you mask something from an import
01:02:29 <ozone> import Foo hiding (bar, baz)
01:02:31 <xkb> I need catch from Control.Exception
01:02:32 <xkb> ah
01:02:33 <xkb> ok
01:03:15 <shapr> ozone: how can I mask typeclass instances? :-)
01:04:50 <ozone> shapr: don't import them :-)
01:04:55 <ozone> (the module, that is!)
01:06:26 * ozone wishes Haskell had named instances
01:06:34 <ozone> then again, i wish Haskell had lots of things
01:12:11 <shapr> I wish it had a company the size of Sun advertising it.
01:13:02 <shapr> dan2: the ConfigFile.hs from ginsu 0.6.6 looks pretty easy to rip out.
01:14:44 <shapr> hiya pesco 
01:15:12 <pesco> Hey shapr!
01:15:17 <shapr> what's up?
01:15:42 <xkb> hmmz.. using the /usr/local version I get a link error. 
01:15:50 <xkb> undefined symbol
01:16:01 <xkb> ah.. could be from Control.Exception
01:16:06 * shapr wonders which Haskell curses binding is best
01:16:06 <pesco> Me for one...
01:16:32 <shapr> and it's so early!
01:16:41 <shapr> I got up at 5am.
01:16:52 <xkb> Should I use -package or something to point it to the module?
01:17:24 <shapr> pesco: you use ghc on MacOS X?
01:17:38 <pesco> Excuse slow typing, I'm still learning...
01:17:46 <shapr> oh, which layout?
01:17:57 <shapr> or maybe a new keyboard?
01:18:06 <xkb> or gestures :d
01:18:44 <pesco> Single-handed.
01:19:12 <shapr> dvorak right or left?
01:19:24 <pesco> left
01:19:36 <shapr> ah cool
01:19:51 <shapr> there are some nifty advantages to one-handed typing
01:19:57 * shapr considers learning left
01:20:06 <xkb> one handed on dvorak?
01:20:14 <xkb> or one handed on qwerty
01:20:50 <pesco> And yes, I use ghc on MacOS X.
01:21:18 <xkb> pesco, do you know if I need to pass any params to ghc for the compilation of something using Control.Exception?
01:21:27 <xkb> I'm getting ld errors now
01:22:06 <pesco> xkb: I don't think you want QWERTY...
01:22:31 <cptchaos> moin pesco
01:22:33 <xkb> perhaps If you have really large hands
01:22:53 <pesco> xkb: I
01:23:03 <pesco> Ugh.
01:23:52 <pesco> Backspace is next to Return.
01:24:55 <shapr> hiya cptchaos 
01:25:10 <cptchaos> shpr: hi
01:26:28 <pesco> xkb: I'm pretty sure you don't need flags for Control.Exception.
01:26:44 <shapr> cptchaos: are you using a one-hand keyboard also?
01:27:14 <cptchaos> shapr: no an normal qwertz keyboard
01:27:22 <pesco> ;)
01:28:19 * pesco goes to get something to eat...
01:30:02 <xkb> hmm.. odd
01:30:31 <xkb> the ld error is on _ZCMain_main_closurew
01:30:34 <xkb> (-w)
01:32:17 <shapr> do you have a main function?
01:32:33 <xkb> oh.. grrrmblz
01:32:44 <xkb> that means "no" ;-)
01:32:55 <pesco> lol
01:34:21 <shapr> hej bringert 
01:35:48 <xkb> shapr, hmm it did not make any difference though
01:35:53 <xkb> adding main
01:36:00 <shapr> what does your source look like?
01:36:25 <xkb> very simple.. module definition: module ExceptionTest() where
01:36:31 <xkb> imports masking catch
01:36:46 <xkb> one function :: IO () that throws and catches an exception
01:37:05 <xkb> and main :: IO () calling the exceptionTest function
01:37:21 <xkb> I can put it online, if you need more info
01:37:32 <pesco> You need Main.main!
01:37:36 <shapr> yup
01:37:46 <xkb> why?
01:37:56 <shapr> because otherwise it doesn't make a binary.
01:38:03 <xkb> aha..
01:38:05 <shapr> not unless you give -main-is
01:38:38 <xkb> so otherwise it's just compiled?
01:38:40 <xkb> not linked
01:38:50 <shapr> yup
01:39:50 <xkb> ok.. I did not know that :D
01:40:04 <shapr> greetz gpciceri 
01:40:04 <xkb> linking works now.. nice
01:41:16 <pesco> xkb: GHC simply expects the main routine to be Main.main.
01:42:18 <xkb> and otherwise you need to use -main-is?
01:43:43 <pesco> Exactly.
01:52:06 <gpciceri> hello shapr
01:54:16 <gpciceri> mmh. I suppose this is the right place to ask newbie question, isn't it ?
01:54:43 <xkb> welcome fellow newbie :D
01:55:39 <pesco> gpciceri: It is.
01:55:42 <gpciceri> o.k., THX for the welcome. I've used the standard list comprehension sample to produce list permutation, like in this...
01:55:58 <gpciceri> [(x,y,z) | x <- [1,3,5], y <- [2,4,6], z<- [7,8,9] ]
01:56:15 <gpciceri> and this is o.k. - it works and it does what I need
01:56:58 <gpciceri> but now I'd like to generalise this sample for a variable number of lists
01:57:03 <gpciceri> like this...
01:57:33 <gpciceri> [(x1 .. xN) | x1 <- L1, ... , xN<- LN ]
01:57:40 <gpciceri> (pseudo code, of course)
01:57:56 <gpciceri> but I've no idea how to do this
01:58:12 <shapr> hm, couldn't you use <- and the List monad to do that?
01:59:01 <shapr> er, >>= and the monad instance of []
01:59:44 <gpciceri> shapr, THX I can investigate in this direction (I'm really a newbie, so I've to "decode" your suggestion)
01:59:57 <pesco> Would [[x1,...,xN]] | ...] be OK, too?
02:01:32 <pesco> I.e. lists instead of tuples?
02:01:43 <gpciceri> yes
02:02:07 <pesco> Good. ;-)
02:02:19 <gpciceri> sorry I'm still too slow with the sintax 
02:02:25 <gpciceri> :-(
02:04:03 <pesco> The problem with tuples is not in the syntax.
02:04:36 <pesco> But in the types.
02:05:37 <gpciceri> pesco, I mean I was too slow in understanding your question
02:05:53 <pesco> Oh ok.
02:09:40 <xkb> I have the following function: createErrorList (x:xs) (y:z:ys) = x y z : createErrorList xs ys
02:09:48 <xkb> where x:xs is a list of functions
02:09:59 <xkb> obviously this gives rise to errors
02:10:08 <xkb> when y and z or either one is empty
02:10:16 <xkb> How could I handle those errors?
02:10:38 <xkb> I think I need to add a pattern, to detect empty y's or z's
02:11:07 <pesco> gpciceri: You will have to write a function.
02:11:40 <shapr> hi Si\
02:11:52 <Si\> hi shapr
02:11:59 <shapr> how's code?
02:12:13 <gpciceri> I suppose, but I think this could be a standard recipe so perhaps somewhere there's an existing code snippet
02:12:40 <Si\> Hopefully I'll have a useable XML Serializer by the end of today
02:12:47 <shapr> cool
02:13:12 <Si\> Just need to make sure my parser monad is powerful enough
02:13:12 <pesco> gpciceri: That I don't know.
02:13:41 <shapr> can't you use the monad instance of list to recursively build the permutations of a list of lists?
02:15:32 <shapr> my first thought is to fold >>= over the list of lists, but I can't seem to get the types to work out.
02:18:50 <pesco> Oh I think you're right!
02:18:55 <shapr> what about sequence?
02:19:13 <shapr> yes, I think that does work
02:19:21 <shapr> gpciceri: use sequence
02:19:50 <shapr> sequence [[1,3,5],[2,4,6],[7,8,9]]
02:20:21 <pesco> Of course...
02:21:16 <shapr> *Main> Data.List.sort (sequence [[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == Data.List.sort ([[x,y,z] | x <- [1,3,5], y <- [2,4,6], z<- [7,8,9] ])
02:21:16 <shapr> False
02:21:17 <shapr> :-(
02:21:22 <shapr> oh doh
02:21:38 <shapr> argh, I got my lists confused.
02:21:52 <shapr> ah there we go
02:21:53 <shapr> now it's true
02:22:07 <shapr> even order-wise
02:22:19 <shapr> which it should be, of course
02:25:17 <shapr> gpciceri: makes sense?
02:27:29 <gpciceri> shapr, sorry I was out of my desk
02:27:55 <shapr> no worries
02:30:58 <musasabi> hum back to haskell world.
02:31:32 <shapr> yay
02:31:33 <musasabi> shapr: sorry for not having contacted you, there are some architectural problems with serialization.
02:31:45 <shapr> no worries
02:31:58 <shapr> I would like to hear about the problems you ran into
02:32:08 <musasabi> btw implicit parameters are very nice...
02:32:38 <musasabi> shapr: well there is e.g. no proper way to serialize a string.
02:32:57 <musasabi> shapr: I am thinking of looking at parallel haskell sources at ways of doing it.
02:33:15 <shapr> yah, they figured out mobile bytecode at least
02:34:06 <musasabi> the whole "type String = [Char]" is the stupid one.
02:34:19 <musasabi> at least a newtype would have made things simpler..
02:34:23 <shapr> what about packedstring?
02:34:56 <musasabi> shapr: that works nicely but "does not work well with Strings" is not something a general purpose thing should say.
02:36:00 <shapr> according to the recent discussions on the mailing lists, a string is just a list of bytes
02:36:06 <gpciceri> shapr, cool THX 1K
02:36:23 <shapr> gpciceri: the most fun about that is understanding why that works
02:36:29 <shapr> hiya TheHunter
02:36:40 <musasabi> but currently it is a list of Chars, which means that serialization needs 5 bytes * lenght of string (of course that can be packed)
02:36:46 <TheHunter> hiya 5h4pr
02:36:50 <shapr> :-)
02:38:04 <gpciceri> shapr, I suppose that this activity will take the rest of my life :-)
02:38:12 <musasabi> and secondly I am having doubts about many things. foo chan = getChanContents chan >>= writeList2Chan chan
02:39:02 <shapr> gpciceri: not unless you're over 90 and don't expect to live much longer ;-)
02:39:44 <shapr> musasabi: maybe this is the sort of question to dump onto ghc-users and see what the Simons have to say?
02:40:13 <musasabi> well I understand why that is illdefined.
02:40:39 <musasabi> btw http://www.haskell.org/pipermail/haskell/2004-January/013495.html looks very very nice.
02:41:06 * musasabi thinks about adding the "using implicit parameters instead of Reader monad to wiki" if it would be helpfull.
02:41:07 * shapr reads
02:41:23 <shapr> there are some problems that implicit params can have
02:41:28 <shapr> but I forget the details...
02:41:55 <shapr> something about type propagation or type escaping
02:43:13 <shapr> this is a rather dense email
02:43:13 <musasabi> well the problems are similar to existentials in that regard.
02:43:17 <shapr> lots of info
02:43:29 <musasabi> yes, but I like the idea very much.
02:43:39 <musasabi> kind of like clean but with everything implicit.
02:44:14 <shapr> I'm fond of explicit
02:44:46 <shapr> though iirc, monads and implicit params about the same in terms of {ex/im}plicit
02:45:53 <musasabi> well implicit params are explicit in the type signature.
02:46:40 <shapr> off-topic: why are so many programmers unicyclists? willingness to explore the fringe? try new things? optimization (only important numbers are zero, one, and infinity) ?
02:47:11 <shapr> easily bored? ;-)
02:47:36 <shapr> benrg should really design his own language
02:49:29 <shapr> gpciceri: a general understanding of how and why sequence gives you permutations for any number of lists will allow you to write some amazingly sexy code.
02:49:31 <jesse98> what's a good synonym for non-referentiability?
02:49:47 <jesse98> err non-referential transparency
02:49:54 <shapr> side-effecting ?
02:50:01 <jesse98> hmm
02:50:09 <jesse98> the suck maybe
02:50:09 <gpciceri> shapr, THX I've to proceed into studing h. much more
02:50:58 <shapr> gpciceri: once you have a handle on the basics of Haskell (Hudak or Thompson books for example) I'd suggest the nomaware monads tutorial.
02:52:23 <shapr> implicit return values is .... a weird direction
02:54:24 <shapr> is this related to CSP?
02:54:49 <Si\> Is there anyway of getting the Namespace of Typeable value?
02:55:31 <musasabi> Is one allowed to paste GPLed code to the haskell wiki?
02:55:49 <pesco> No! You fool!
02:56:36 * pesco babbles off into a 30-page act of legal mumbo-jumbo.
02:57:10 <musasabi> but is there any real problem, if I say that it is GPL?
02:57:25 <pesco> Ah, all that one-hand typing hasn't ruined my two-handed dvorak skills!
02:57:44 <musasabi> want to add an alternative implementation of a nomaware tutorials example and those are GPL.
02:57:52 <pesco> musasabi: Honestly, I don't know.
02:58:33 <pesco> musasabi: I'd say don't give a fuck until someone comes up to you and tells you to stop. Then you will still have time to worry about licensing nonsense.
03:00:34 <musasabi> http://www.haskell.org/hawiki/ImplicitReader
03:10:30 <musasabi> Does that make sense/look simpler than the alternative?
03:40:15 <shapr> hiya tessier 
03:40:29 <shapr> I asked John Petersen about wiki licensing
03:40:54 <shapr> he said he thought I could just change the license unilaterally and remove anything that people complained about.
03:41:33 <tessier> Hi shapr
03:41:49 <shapr> tessier: have you been here before?
03:41:58 <tessier> shapr: Never
03:42:11 <tessier> Just thinking about picking up a functional language
03:42:12 <shapr> ah, would you like the channel intro, or the language intro? or neither? :-)
03:42:19 <tessier> Both please. :)
03:42:24 <shapr> awright, my favorite option
03:42:56 <shapr> do you have experience with functional coding in a language like lisp, scheme, or python?
03:43:35 <shapr> have you used higher order functions with map,filter, or reduce?
03:44:10 <shapr> In any case, functional programming has several different ideas that make it unusual, first and foremost is function as value
03:44:40 <tessier> No functional coding experience at all.
03:44:56 <tessier> I am learning python also and was hoping to learn something to help me with functional programming in python
03:44:59 <shapr> that shows up in Python, Lisps of all flavors, and a bit in languages like Smalltalk too.
03:45:05 <tessier> Never used higher order functions
03:45:18 <tessier> Although I have read a bit about them
03:45:30 <tessier> In Phil Grahams writings and I've seen map applied once or twice in python
03:45:34 <shapr> in python, you can put a function value into a variable. x = lambda x:x + 1
03:45:48 <shapr> I probably shouldn't have used x twice, that could be confusing
03:46:05 <shapr> f = lambda x:x + 1
03:46:19 <tessier> So what exactly does that mean?
03:46:21 <shapr> then f(2) will give you 3
03:46:30 <tessier> Been trying to get my head around lambda calculus and it's still not clicking
03:46:35 <shapr> do you know what "def addOne(x): return x + 1" does?
03:46:52 <tessier> yes
03:47:00 <shapr> lambda cal is a different but related critter (and very cool stuff too)
03:47:21 <shapr> let's stick with FP in python for the moment
03:47:29 <tessier> ok
03:47:37 <shapr> the lambda keyword in Python lets you define a function with no name
03:48:17 <shapr> especially if you use stuff like map or filter, you get cases where it's shorter to write an anonymous function rather than define it elsewhere and call it in the map or filter
03:48:21 <tessier> in f = lambda x:x + 1 aren't you giving it the name f?
03:48:36 <shapr> sort of, yes
03:49:12 <shapr> let's try a case where it never has a name: map(lambda x:x + 1,[1,2,3])
03:49:17 <tessier> if you use a lambda and not def it elsewhere you can't really reuse that function elsewhere in the code, right?
03:49:40 <pesco> True.
03:49:51 <pesco> (jumping into the conversation)
03:49:57 <musasabi> functional programmming is largely thinking about transformations instead of thinking about objects.
03:49:58 <shapr> if you don't give it a name, then you can't refer to it by name
03:50:02 * pesco waves to tessier and shapr.
03:50:07 * shapr waves to pesco 
03:50:10 <tessier> pesco: hi :)
03:50:38 <shapr> even so, you can often still use an anonymous function by sticking it inside something else that does have a name.
03:50:54 <tessier> I've always been a pretty mediocre programmer and I am hoping that finding a new way to think about problems might improve things
03:51:01 <xkb> using the lambda abstraction
03:51:19 <shapr> Zope (written in Python) does that in its cataloging system
03:51:30 * tessier is using zope
03:51:32 <tessier> Just recently started.
03:51:48 <tessier> It uses anonymous functions in the cataloging system?
03:51:54 <shapr> it defines new functions on the fly and sticks them inside another function
03:52:02 <shapr> yup, in the result scoring specifically
03:52:37 <shapr> but that's not a very common practice in Python, Guido doesn't encourage the FP parts of Python, and hopes to remove at some point.
03:52:54 <tessier> That's too bad.
03:53:01 <shapr> I decided I loved the FP parts of Python so much I had to find more, that's why I jumped from Python to Haskell.
03:53:04 <tessier> Why does he want to force python into imperativeness?
03:53:34 <tessier> I am considering haskell, ocaml, or scheme. Scheme seems to be the most popular.
03:53:39 <shapr> for a variety of reasons, but you'll get first-hand info by searching the python-dev mailing list, and the comp.lang.python newsgroup
03:54:31 <shapr> Scheme is a cool language, and has a wonderful book that teaches Programming using scheme.
03:54:40 <xkb> what book is that?
03:54:44 <shapr> http://mitpress.mit.edu/sicp/
03:54:51 <shapr> Structure and Interpretation of Computer Programs
03:54:52 <xkb> ah.. that one :D
03:54:59 <shapr> also called 'the wizard book'
03:55:00 <xkb> the "bible"
03:55:02 <tessier> I've got "The Little Scheme" but it really lacks good examples
03:55:25 <tessier> It has lots of little basic computing things but not the sorts of things I am interested in doing.
03:55:34 <shapr> what are you interested in?
03:55:58 <xkb> Is there a mozart/oz channel somewhere btw?
03:56:04 <tessier> Sys admin type things, text processing, networking, etc.
03:56:08 <shapr> xkb: I dunno, but if you find one, tell me about it.
03:56:12 <xkb> :)
03:56:20 <tessier> Cool, I love it when people put whole books online.
03:56:22 <shapr> Python is good for those sorts of things.
03:56:24 * tessier bookmarks the wizard book
03:56:29 <tessier> Indeed, it is.
03:56:42 <shapr> In my opinion, Python is a great first language, and good for writing applications too.
03:57:09 <tessier> It's not my first language as I have done a little C, tons of perl, and a smidgeon of various other things.
03:57:09 <musasabi> tessier: I would probably go with ocaml.
03:57:15 <shapr> I wish it were more like Haskell, but it does have a surprisingly good balance already.
03:57:16 <tessier> But I've never mastered any of them,
03:57:29 <shapr> Python is worth mastering.
03:57:29 <musasabi> personally I like haskell, but it is lacking several things...
03:57:31 <shapr> So is Haskell.
03:57:40 * musasabi likes Ruby better than python
03:57:59 <shapr> I think ruby has a better OOP appoach, but explicit END makes me crazy
03:58:04 <shapr> I'm a huge fan of significant whitespace.
03:58:47 <tessier> Yes, I have decided on making python my new language of choice.
03:59:10 <tessier> But like I said, I'm hoping to pick up a functional language also because I have never learned one before and hope to be able to apply some functional concepts to my python programming
03:59:10 <shapr> Haskell is considered the most purely functional of languages.
03:59:35 <shapr> I think that's a good approach.
03:59:38 <tessier> How is it more functional than lisp/scheme and why does "pure" matter?
04:00:03 <jesse98> how is it more functional than clean? :-)
04:00:06 <shapr> because a function in math always evaluates to the same value for the same input.
04:00:19 <shapr> jesse98: I don't know that it is...
04:00:51 <jesse98> pure matters because functions can no longer have side effects: ie local changes can only have local effects
04:01:03 <shapr> tessier: OOP cuts down on program complexity by dividing statefulness into separate objects
04:01:25 <jesse98> whereas in c or something you can change a variable and every damn compilation unit can be affected
04:01:38 <shapr> on the good side, that means that you can usually think about just that piece of code by itself, and it almost always works as you expect
04:01:58 <tessier> jesse98: You can change a variable in a functional language and behavior changes also, right?
04:02:21 <shapr> Haskell doesn't have 'variables' only single-assignment constants.
04:02:38 <tessier> hmmm
04:02:43 <shapr> also, every function in Haskell is described only by its inputs
04:02:49 <shapr> there is no global state
04:03:05 <tessier> So how would you calculate the circumference of a circle without defining pi somehow?
04:03:12 <jesse98> no global mutable state
04:03:17 <shapr> er, right
04:03:29 <shapr> you can define pi just fine, but you can't change its value.
04:03:33 <jesse98> so stuff like pi can be global
04:03:35 <tessier> ah, I see.
04:03:49 <shapr> in python, it's legal to say "pi = 3.1459; pi = 3.0"
04:04:16 <tessier> 3.14159 no? :)
04:04:21 <jesse98> has there been any work done on distributed haskell?
04:04:23 <shapr> in Haskell, you use shadowing and garbage collection.
04:04:33 <shapr> jesse98: yes, see goffin and GdH
04:04:43 <shapr> for example:
04:04:52 <shapr> length [] = 0
04:04:54 <jesse98> they use monads i assume?
04:04:55 <tessier> jesse: That's another thing I was wondering about. With everything defined as functions it seems it should be much easier to parallelize 
04:05:03 <shapr> length (x:xs) = 1 + length xs
04:05:04 <jesse98> it is
04:05:31 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
04:05:32 <jesse98> the bugaboo of threads is shared mutable state which is a non-issue in functional languages
04:05:38 <tessier> In a functional language with no side effects and everything defined in terms of everything else data dependencies should be obvious
04:05:46 <shapr> tessier: exactly
04:06:11 <shapr> so how would getLine work in that language?
04:07:00 <arauko> tessier, what kind fo data dependency?
04:07:27 <tessier> arauko: The kind of data dependency that would prevent you from being able to calculate one thing before you have calcuated another
04:07:34 <arauko> get it
04:08:23 <shapr> some other neat features of Haskell are lazy evaluation and partial application
04:08:44 <arauko> tessier, thats why haskell doesnt have a specific control flow in the programs?
04:08:44 <shapr> lazy eval means you can write code like "ones = 1 : ones"
04:08:53 <tessier> arauko: I have no idea
04:08:54 <shapr> the colon in Haskell is the list constructor.
04:09:09 * tessier wonders how you program without flow control
04:09:10 <shapr> so 1 : [] constructs a list like [1]
04:09:22 <shapr> arauko: that's an excellent question
04:09:27 <arauko> mm. i think i didnt explain it good....
04:09:36 <arauko> shapr, it is? :-)
04:10:06 <tessier> I am very used to thinking of programs as lists of things to do or steps you need to take to get a resul
04:10:06 <tessier> t
04:10:12 <tessier> But clearly that has to change
04:10:16 <shapr> tessier: right, that's the procedural mindset
04:10:27 <arauko> shapr, any answer?
04:10:32 <tessier> And in that list of steps there are decision points where flow control comes into play.
04:10:40 <shapr> the functional mindset is that you have things that 'simplify' or 'evaluate'
04:10:56 <shapr> I still trip over thinking about Haskell in terms of 'returning' a value when in fact, it doesn't
04:11:27 <shapr> the if then else in Haskell evaluates to a value, so both chunks must have the same type
04:11:37 <arauko> im not sure but i thnk i read once that purely functional programs doesnt need a specific control flow
04:11:39 <shapr> arauko: yes, the short answer is monads
04:11:53 <shapr> and lazy evaluation with call-by-need semantics
04:12:03 <arauko> thats cool!
04:12:19 <shapr> in Haskell [1..9] is the same as [1,2,3,4,5,6,7,8,9]
04:12:25 <shapr> can you guess what [1..] is short for?
04:12:39 <Philippa> the only "control flow" you need in FP is access to recursion and choice...
04:12:40 * xkb hints at 8
04:13:27 <shapr> [1..] is all positive whole numbers greater than zero, in order
04:13:53 <shapr> you don't often get to use infinite lists in C or Python, they usually explode.
04:14:05 <jesse98> shapr is a witch! burn him!
04:14:09 <xkb> Speaking of controlflow, side effects and lazyness: I have some example code for the use of exceptions in haskell. Could some of the guru's have a look at it? http://hypernation.net/~xkb/exception_test.hs
04:14:21 <xkb> I want to simplify it some more
04:14:29 <jesse98> who ever heard of infinite data strutures?
04:14:35 <shapr> jesse98: what if I float in water?
04:14:35 <xkb> the idea is to show that exceptions maybe hidden in datastructures
04:14:47 <jesse98> then you must be an angel
04:14:49 <shapr> or maybe if I'm heavier than a duck?
04:14:56 <shapr> wait, this isn't #python
04:15:24 <shapr> anyway... 
04:15:47 <shapr> lazy eval means you can work with lists like [5,1/0] as long as you don't ask for the second item of the list.
04:16:19 <shapr> it also means you can write the fibonacci function like this: fib = 1 : 1 : zipWith (+) fib (tail fib)
04:16:44 <shapr> the next item in the fibonacci sequence is only calculated upon demand
04:17:15 <shapr> let's see... what else is very fp?
04:17:19 <tessier> The idea of infinite data structures is quite handy
04:17:40 <tessier> What are monads?
04:17:54 <xkb> shapr, higher levels of abstraction? DSLs?
04:18:16 <xkb> modularity?
04:18:39 <shapr> a monad is a type that's not completely filled-in and two functions, one for making a boring datatype filled into that type, and another for sticking together two values of that filled-in type.
04:18:55 <shapr> xkb: yah, good point.
04:19:00 <xkb> wow.. nice description :D
04:19:14 <tessier> type as in data type like in other languages?
04:19:20 <shapr> yah, pretty much
04:19:27 <shapr> types in Haskell do a lot of stuff
04:19:52 <shapr> you start out with boring stuff like 1 :: Int and 1 :: Integer
04:20:04 <shapr> but you get to make your own types, and they can do really cool tricks
04:20:18 <shapr> data Temp = Cold | Hot
04:20:43 <shapr> now you have a type named Temp, and it has two (nullary) constructors, Cold and Hot
04:20:50 <xkb> does Haskell support existential types?
04:21:05 <shapr> xkb: yah, depending on what exactly you mean by that...
04:21:05 <xkb> like clean?
04:21:12 <shapr> I don't know clean.
04:21:18 <xkb> for example to create mixed type lists
04:21:43 <shapr> oh, there are several ways to do that in Haskell, and the forall a stuff is what you're talking about, I think.
04:22:12 <xkb> yes..
04:22:17 <shapr> tessier: so, just like I wrote 1 :: Int (value one of type Int) you can now do Cold :: Temp
04:22:43 <shapr> data Season = Winter | Spring | Summer | Fall
04:22:48 <shapr> same thing, more options
04:22:59 <shapr> data Tree a = Nil | Node (Tree a) a (Tree a)
04:23:04 <shapr> now that one's more exciting
04:23:32 <shapr> this tree type can be either nothing with Nil
04:23:45 <shapr> or a Node that holds two other tree values and that a
04:23:59 <shapr> myTree = Node Nil 1 Nil
04:24:19 <shapr> in that case, the type might be "Tree Int"
04:24:33 <shapr> you can fill in the a with whatever other (or same) type you want to use.
04:24:42 <shapr> make sense?
04:25:01 <shapr> these guys are called 'algrebraic types' and I think of them as conceptual lego
04:25:06 <tessier> er...I'm gonna have to think on that one for a while. :)
04:25:35 <shapr> well, Nil is of type Tree a
04:25:46 <shapr> let's say you know the a will be an Int
04:25:46 <tessier> Tree a? Why two words?
04:26:03 <shapr> because it could be a tree of Ints, or of Chars, or of Strings
04:26:13 <pesco> "I guess lambda means more to most Lisp'ers than I knew." -- Guido van Rossum
04:26:29 <tessier> heh...lambda IS lisp from what I can tell.
04:26:30 <shapr> Node (Nil) "foo" (Nil) is of type Tree String
04:26:33 <tessier> No lambda, no lisp.
04:26:40 <shapr> Node (Nil) 'a' (Nil) is of type Tree Char
04:27:10 <shapr> the a means you get to parameterize the type just like you might parameterize a function
04:27:28 <tessier> know lambda, know lisp. No lambda, no lisp.
04:27:34 <shapr> heh
04:27:40 * pesco twists his face through alternating states of fear, pain, and bewilderment.
04:28:22 <shapr> pesco: Guido said some embarassing stuff about FP in 2002
04:29:10 <pesco> Ooh. This was from 1994... 8-)
04:29:39 <pesco> shapr: Got any links?
04:29:52 <shapr> um, lemme see
04:30:21 <bringert> he said some odd things at EuroPython this year too
04:30:39 * Philippa gets a... mixed view of Guido, to put it mildly
04:30:51 <shapr> http://www.artima.com/weblogs/viewpost.jsp?thread=4550
04:31:24 <shapr> "I'd say that a loop is a higher-level concept than recursion; recursion is more powerful, but also more low-level, like assembly language."
04:31:45 <xkb> *glup*
04:31:57 <Philippa> insofar as you have more room to specify things and (possibly) fuck up, sure. map, filter etc are your friends...
04:32:26 <jesse98> isnt recursion lower level shapr? after all there are no loops in the lambda calculus
04:32:37 * pesco grins.
04:33:19 <shapr> yes, recursion is more basic than looping, but... recursion can be used to implement loops
04:33:45 <jesse98> that's sort of the point in calling recursion a lower level concept...
04:34:07 <shapr> personally, I don't think loops have any advantages over recursion, only disadvantages.
04:34:16 <jesse98> ie it's a more fundamental idea than looping
04:34:21 <tessier> ah...so instead of using something like for each in perl or something you could use map in python
04:34:27 <shapr> tessier: right
04:34:35 <tessier> and get rid of loops
04:34:38 <shapr> yes
04:34:49 <tessier> Hmm...I have lots of places where I loop on stdin
04:35:38 <Philippa> yeah, though you can express those loops in terms of recursion
04:36:00 <shapr> Python does not handle recursion well
04:36:14 <shapr> I blow the stack on a regular basis :-(
04:37:08 <shapr> anyway, I think loops and functions and threading as atomic concepts are a result of the C mindset infecting the whole programmer culture.
04:37:34 <jesse98> yes but the lambda calculus isnt the alpha and the omega
04:37:39 <shapr> recursion, continuations, and coroutines are lower-level, and more powerful.
04:38:34 <jesse98> i've been thinking of hybrid systems: lambda calculus for a computational core comunicating with other processes using the pi calculus
04:38:35 <musasabi> unfortunately haskell lacks proper first-order continuations.
04:38:46 <shapr> jesse98: that does sound tempting
04:39:19 <shapr> musasabi: yes, though I vaguely recall that you can emulate them with Cont
04:39:27 * Philippa needs to play with the pi calculus properly sometime
04:39:33 <jesse98> yeah, distributed components sort of approach
04:39:37 <Philippa> or maybe just with a language with a Pi construct :-)
04:39:40 <shapr> Pict?
04:39:43 <tessier> pi calculus?
04:40:02 <shapr> pi calculus is about communication
04:40:02 <jesse98> pict afaict is pi calculus only (reading up on it now)
04:40:06 <tessier> Why is lambda calculus called that anyway?
04:40:23 <tessier> Is the choice of greek letter in each of those arbitrary?
04:40:30 <jesse98> so you lose most of the benefits of a functional language because of th non-determinacy
04:40:37 <musasabi> shapr: no..
04:40:43 <shapr> musasabi: oh, ok.
04:41:01 <musasabi> shapr: Those are not resumable.
04:41:03 <jesse98> the pi calculus is a formalism for distributed/parallel computing
04:41:17 * shapr wishes @fact still worked in lambdabot 
04:41:30 * shapr isn't motivated enough to actually fix it
04:41:55 <xkb> \-bot is on sf right?
04:42:00 <Philippa> yep
04:42:04 <pesco> I'm off for a bit, see you all later.
04:42:04 <shapr> yup
04:42:05 <jesse98> what i want to do is stick the icky stuff like non-determinism into a small isolated part of components so the bulk of the code is more tractable
04:42:08 <shapr> cya pesco 
04:42:34 <shapr> anyway, let's go for partial application next
04:42:45 <xkb> hmm not on lambdabot.sf.net?
04:43:33 <shapr> http://thunderbird.scannedinavian.com/~shae/lbot2.1.tgz
04:43:40 <xkb> tenk joe :D
04:44:09 <shapr> tessier: if you look at the type signature of (+)
04:44:14 <shapr> @type (+)
04:44:15 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
04:44:32 <shapr> you'll see it has three pieces, a -> a -> a
04:45:01 <shapr> if you've been reading about lambda cal, you know that each function in lambda cal takes only one argument
04:45:10 <tessier> right
04:45:37 <shapr> it's the same in Haskell, that type signature really means a -> (a -> a)
04:45:57 <shapr> a -> a means takes something of type a, evaluates to something of type a
04:46:03 <shapr> that's your basic function type
04:46:27 <shapr> so the type sig of (+) means it can take one a, and return a new function
04:46:35 <shapr> @type (1 +)
04:46:36 <lambdabot> (1 +) :: forall a. (Num a) => a -> a
04:47:15 <shapr> that's partial application, you've applied the function to a subset of its possible arguments
04:47:34 <shapr> if you've filled in part of a funtions arguments like that, it's called a closure.
04:47:44 <shapr> you can use it a bit like instances in the OOP world
04:47:58 <shapr> map (1 +) [1,2,3]
04:48:08 <tessier> It is a closure if one of the arguments to a function is another function?
04:48:18 <shapr> sure
04:48:30 <tessier> I've heard about closures somewhere...maybe in Phil Grahams stuff.
04:48:36 <shapr> a closure is just something that's closed over some stuff, that's holding onto it.
04:48:38 <xkb> shapr, do you use exceptions in \-bot?
04:48:48 <shapr> xkb: lambdabot does all sorts of crazy stuff
04:49:00 <xkb> ok.. ill just browse trough the code
04:49:05 <shapr> I know exceptions are used in several places
04:49:10 <xkb> nice
04:49:44 <shapr> tessier: I often use partial application for stuff like a dictionary lookup where I have one key to find in a bunch of dictionaries
04:49:58 <shapr> map (lookup myKey) [dict1,dict2,dict3]
04:50:20 <shapr> the lookup takes a key and a dictionary to look into
04:50:32 <shapr> it's equally useful for sorting functions, etc, etc
04:51:00 <tessier> hmm... 
04:51:05 <tessier> map (1 +) [1,2,3]
04:51:08 <tessier> gets me invalid syntax in python
04:51:17 <shapr> that's Haskell syntax
04:51:20 <tessier> ah
04:51:23 <shapr> in python you have to do import operator
04:51:41 <shapr> err
04:51:50 * shapr switches the big brain switch from Haskell to Python
04:51:59 <tessier> *ka-chunk*
04:52:15 <shapr> map(lambda x:x+1,[1,2,3])
04:52:31 <shapr> you don't get partial application in base python
04:52:47 <shapr> you can get it with the xoltar.org FP extensions for Python.
04:53:03 <shapr> the downside is that other Python programmers won't understand your code if you use the xoltar.org toolkit :-)
04:54:14 <shapr> in Python, the FP stuff is map, filter, reduce, and lambda
04:54:50 <shapr> if you have a Python interpreter open in front of you, you can use help(filter) to get the short help.
04:55:30 <shapr> lambda in Python only allows single-line lambdas. that can suck.
04:55:51 <shapr> anonymous functions in haskell look like: (\x -> x + 1)
04:55:56 <tessier> Yeah, I noticed that and wondered how much you can really do in a single line
04:56:03 <shapr> though in that case partial application of (+) is simpler.
04:56:24 <shapr> you can do a surprising amount in a single line of Python
04:57:13 <shapr> oh, sort and reverse in Python are side-effecting
04:57:45 <shapr> in Haskell, functions are designed to evaluate to their result, so you can build a big long pipeline of stuff and it just works
04:58:38 <shapr> lazy pipeline code ends up looking a lot like unix pipe shellscripts 'cat $1 | sort | uniq | comm -1 -3 /usr/share/dict/words'
04:59:31 <bringert> but backwards
04:59:37 <shapr> right
05:01:11 <shapr> of course, if you like pipelines, you can still do it in Python: reverse  = lambda x: x.reverse() or x
05:02:47 <shapr> tessier: I can't think of anything else to say, have any questions?
05:03:26 <tessier> in what way are sort and reverse side-affecting?
05:03:28 <shapr> I'm sure I left out a lot of stuff, Haskell is more about big concepts that require very few pieces.
05:03:41 <shapr> oh, in Python a list is sorted in-place
05:03:57 <shapr> myL = [1,2,3]
05:04:03 <shapr> to sort that you do myL.sort()
05:04:10 <shapr> and that call returns None, not the sorted list.
05:04:24 <shapr> you now have a sorted list in the place of the original myL
05:05:12 <shapr> that can cause problems if you don't pass a separate *copy* of a list to another piece of code you didn't write
05:05:22 <shapr> sometimes you're using a list very specifically because the order is important
05:05:38 <shapr> if another piece of code sorts it for you, it can be a sneaky bug.
05:06:19 <shapr> Since Haskell doesn't allow mutability, you know that stuff won't change.
05:06:56 <shapr> That can have its own downsides though, it's better to change a multigigabyte file in-place rather than keeping both the original and the modified copies in memory at the same time.
05:07:44 <Philippa> yeah, it's irritating when you can't rely on "a <- f a" or similar doing stuff in-place
05:08:18 <Philippa> worse yet, thanks to laziness it's going to hang on to a until f a is actually evaluated
05:08:42 <Philippa> might not ditch any of it until that call's finished, which is... painful
05:08:51 <shapr> right, the combination of laziness and immutability can lead to the hardest part of Haskell programming....
05:08:56 <shapr> SPACE LEAKS!
05:09:05 * shapr adds scary space alien music and reverberation
05:09:37 <shapr> a space leak is where something was a lot more lazy than you really wanted it to be.
05:10:31 <shapr> I wrote a wimpy bayesian spam filter in a few lines of Haskell, all the tests worked, but when I ran the program on several thousand emails, it sucked up all my ram and swapspace in just a few seconds
05:11:06 <shapr> someone here on #haskell pointed out to me that my code was opening and reading all the files before it started to parse any of them.
05:11:11 <Philippa> oops
05:12:21 <shapr> the addition of one strict call (the $! operator) in one place fixed it.
05:12:28 <shapr> tessier: any other questions?
05:12:45 <tessier> shapr: Not for the moment, thanks!
05:12:48 <shapr> ok
05:12:49 <tessier> I have a lot of reading/playing to do
05:13:13 <shapr> I'd recommend you try to write simple functions in Haskell and ask questions here when you get stuck
05:13:25 * xkb points to hugs
05:13:54 <xkb> hmm.. lhs2tex wont build here.. very strange error messages: C not found :?
05:16:33 <xkb> anyone using lhs2tex on a unix here?
05:19:59 <Igloo> Can you give a bit more context to the error?
05:20:57 <xkb> I just fixed it
05:21:01 <xkb> it was a path problem
05:21:07 <shapr> tessier: http://www.haskell.org/complex/why_does_haskell_matter.html If you want more informational literature :-) 
05:21:22 <tessier> thanks
05:23:42 * shapr thinks that Haskell is easier than unicycling
05:29:28 <shapr> yow, referentially transparent linux: http://linux.slashdot.org/article.pl?sid=04/09/13/2318224&tid=110&tid=106
05:32:15 <xkb> Igloo, on lhs2TeX, I keep getting the error :
05:32:16 <xkb> `code' is not defined;
05:32:16 <xkb> perhaps you forgot to include "lhs2TeX.fmt"?
05:32:29 <xkb> and lh2Tex.fmt is in ~/.lhs2TeX
05:33:36 <Igloo> No idea there, I'm afraid
05:34:01 <xkb> ok
05:49:45 <earthy> well, you have to explicitly use the right pacakge, IIRC
05:51:20 <xkb> yeah..I noticed you need to import the lhs2TeX.fmt etc in the .lhs filer
05:51:22 <xkb> -r
05:51:44 <earthy> unfortunately, kosmikus is at ICFP
05:52:25 <xkb> ICFP.. I would have liked to go there
05:55:23 <musasabi> The basic problem with serializing strings seems to be that it would make sense to treat strings as arrays but not all strings have an array equivalent.
06:09:19 <Igloo> Is it ICFP already?
06:10:34 <shrimpx> a few days
06:52:24 <shapr> g'day SyntaxNinja 
06:53:32 <SyntaxNinja> w00t
06:53:54 <SyntaxNinja> how's it going, shapr?
06:54:09 <shapr> it's sunny outside, and I'm resisting unicycling for the moment.
06:54:15 <shapr> oh, did I tell you about my new uni?
06:54:58 <SyntaxNinja> nope
06:55:11 <SyntaxNinja> similarly, my friend wtfe now has a new baby.
06:55:25 <shapr> cool!
06:55:38 <shapr> I have a 24" Mountain Unicycle
06:55:40 <shapr> it's very nice.
06:56:03 <SyntaxNinja> sweet. pix?
06:56:09 <shapr> not yet
06:56:13 <shapr> I've been too busy actually using it :-)
06:57:21 <SyntaxNinja> that's a good sign.  are you using it off-road?
06:57:58 <shapr> somewhat, off-road unicycling is significantly more difficult than off-road bicycling.
06:58:17 <shapr> on the good side, I've lost 25 pounds in the last three months.
06:58:36 <SyntaxNinja> whoa!
06:58:42 <SyntaxNinja> congrats.
06:58:55 <SyntaxNinja> I bet unicycling is good for the abs.
06:58:55 <shapr> thanks, I worked off some of my programmer's belly.
06:59:10 <shapr> and back muscles, and anything in the legs.
06:59:35 <shapr> leaves me with sort of stick figure arms though
06:59:49 <shapr> anyway, next time we get together I'll let you try it.
07:00:26 <SyntaxNinja> cool. so who all is goign to ICFP?
07:02:14 <tessier> ICFP?
07:02:24 <shapr> kosmikus is already gone in that direction
07:02:30 <shapr> Internation Conference on Functional Programming
07:02:38 <shapr> lots of fun
07:02:49 <tessier> Where is it held?
07:03:20 <shapr> snowbird, utah this year
07:03:28 <tessier> Cool.
07:03:35 <tessier> How far is that from SLC?
07:06:17 <shapr> hi gabor 
07:13:06 <gabor> hi all
07:14:49 <musasabi> hello
08:57:07 <musasabi> why is '-' not binding hard enough?
08:57:21 <tessier> type harder?
08:57:24 <musasabi> it is frustratring that one cannot write foo n-1 
08:57:33 <musasabi> foo (n-1) is not pretty.
08:58:29 <dennisb> what about sin x - 1, (sin x) - 1 is not pretty
08:58:58 <Smerdyakov> musasabi, what you were suggesting goes against all the conventions of math and programming languages, as far as I know.
08:59:22 <monochrom> sin(x) - 1 is the worst.
09:00:16 <musasabi> Smerdyakov: well one could hope to archieve that in a language which uses layout
09:00:38 <Smerdyakov> musasabi, oh dear lord.
09:00:45 <Smerdyakov> musasabi, you must commit yourself immediately.
09:00:46 <stepcut> musasabi: foo $ n - 1 
09:00:47 <stepcut> :p
09:00:48 <monochrom> Face it.  sin x - 1 has two interpretations.  One of them has to be parenthesized.
09:01:17 <anduril1> http://merd.sourceforge.net/choices_syntax.html#horizontal_layout
09:01:21 <anduril1> that is kind of cool
09:03:05 <musasabi> yes.
09:03:35 <musasabi> Smerdyakov: think about space being significant.
09:04:32 <bringert> tessier: about 45 min from SLC I think
09:04:39 * bringert is a little slow
09:06:41 <stepcut> bringert: did you see that the latest mysql release (4.1.4) is gamma release?
09:11:01 <Smerdyakov> musasabi, I'm aware of what you mean, and I think it's a bad idea.
09:11:13 <Smerdyakov> musasabi, indentation like used in Haskell evolved on its own, without any requirements in languages.
09:11:19 <Smerdyakov> musasabi, nothing like you're suggesting has appeared.
09:12:19 <Igloo> I sometimes omit the spaces in innermost operators in complex expressions, especially if I can save a linebreak by doing so
09:13:52 <musasabi> Smerdyakov: imho it would make some code cleaner - but seems like most people don't see it that way.
09:13:55 <musasabi> but sauna...
09:23:33 <bringert> stepcut: I noticed 1 hour 1 minute ago :)
09:23:50 * bringert is looking at the #haskelldb logs
09:24:12 <Igloo> Is that a channel for users or developers only?
09:24:33 <bringert> yes
09:24:54 <bringert> both that is
09:25:05 <Igloo> OK, ta  :-)
09:26:22 <bringert> eh, not both users or developers only
09:26:26 <bringert> that would be strange
09:26:53 <bringert> hmm, guess that should be and, not or
09:27:09 <bringert> anyway, you're all welcome
09:40:31 * TheHunter is fighting with "Recursion Schemes from Comonads"
10:02:21 <Marvin--> hey Heff, what's up?
10:02:49 <Heffalump> hiya
10:02:54 <Heffalump> just wondering who'll be at ICFP
10:03:03 * Heffalump is busy with work and preparing to shift jobs and things
10:05:20 <Marvin--> sorry, it's a bit far away for me :)
10:07:03 <Marvin--> kinda busy at work too
10:07:24 <Heffalump> what are you doing for work?
10:09:50 <Marvin--> I've started working at Safelogic (www.safelogic.se)
10:10:15 <Marvin--> we develop tools for hardware verification
10:10:48 <musasabi> The lack of proper serialization seems to be hitting me in allmost all things I do :-(
10:24:15 <musasabi> Are there any hopes of getting a working goodf serialization layer capable of serialize :: Handle -> a ->  IO () and deserialize :: Handle -> IO a
10:24:49 <Cale> Only if there are restrictions on "a".
10:25:12 <esap> (Serializable a) => Handle -> a -> IO () would probably be possible.
10:25:27 <esap> Or (Data a) => Handle -> a -> IO () would perhaps also be possible.
10:26:02 <Cale> I think that would be quite possible, simply making serialize and deserialize part of the typeclass definition.
10:26:22 <musasabi> but that helps little for serailizing anything that cannot be handled by simple Read/Show.
10:26:35 <Cale> hm?
10:26:54 <Cale> what do you intend to serialize?
10:27:18 <musasabi> Cale: I would like functions very much and/or existentials.
10:27:36 <esap> for that, I guess arrows are the best choice currently.
10:28:58 <musasabi> hmm?
10:29:42 <shapr> dang, I missed Heffalump
10:29:42 <esap> functions in general are pretty hard to serialize. You have to add some structure to them to make it simple. Arrows can do that.
10:30:16 <musasabi> esap: any paper telling how to do it?
10:31:46 <esap> I don't know any that have specifically been designed for serialization, but I guess the basic arrow paper (it has parsers, which are the difficult part anyway :-)
10:32:06 <shapr> how/why is it easier to serialize an arrow over a function?
10:32:16 <shapr> that almost makes sense to me...
10:32:19 <esap> http://citeseer.ist.psu.edu/hughes98generalising.html
10:34:01 <esap> shapr: because you can associate some additional data to an arrow, and still have it behave as if it was a function.
10:34:20 <esap> shapr: and that data can support serialization.
10:34:33 <shapr> %-)
10:34:50 <shapr> in other words, whoa sounds cool, how the heck would that work?
10:35:10 <shapr> that would totally rock
10:35:16 <esap> But functions have such narrow interface that (basically just function application) that it's pretty hard to do any kind of knowledge about the function for that.
10:35:26 <shapr> huh?
10:35:47 * musasabi would accept a solution outside the haskell world readily
10:35:56 <musasabi> that is done in the C world.
10:36:05 <esap> shapr: something like data SerArrowT a b c = SerArrowT (String, a b c)
10:36:18 <shapr> I'd like to be able to communicate Haskell values between running RTSs
10:36:32 <shapr> esap: oh tell me more
10:36:56 <musasabi> esap: what about partial application?
10:37:36 <esap> shapr: of course, that string has to somehow represent the 'function' in a kind of expression.
10:37:46 <shapr> I sort of get that.
10:38:27 <shapr> how would you serialize a SerArrowT value?
10:38:45 <esap> shapr: you'll print the string :-)
10:39:21 <esap> shapr: In a sense, you precompute the serialized form of the arrow.
10:39:32 <shapr> ah
10:40:07 <shapr> any suggestions for good serialized forms?
10:40:24 <esap> musasabi: partial application is a bit harder with arrows than with ordinary functions, but I guess the arrow notation helps a bit.
10:40:58 <esap> shapr: It depends on what kind of functions you want to represent. The 'arr' function is pretty hard case.
10:41:42 <stepcut> the hard part about deserializing data is you have to know the type of the deserialized data at compile type
10:42:28 <stepcut> you can just make a function that reads a file and then returns an Int or a String depending on what it found
10:42:44 <stepcut> CAN'T
10:43:24 <musasabi> stepcut: that is not a problem. I know what *type* of data I want to read.
10:43:52 <stepcut> musasabi: then you are luckier than me :)
10:44:06 <musasabi> e.g. [(String,Handle->Env->IO ()]
10:44:57 <musasabi> Existentials of course make things more interesting.
10:46:03 <esap> for existentials, you could require serialization in the existential type. It's clearly not possible to serialize every encapsulated type.
10:47:49 <musasabi> hmm why not?
10:48:02 <musasabi> if it *is* possible to represent them in memory.
10:48:33 <esap> Because the encapsulation by definition prevents some kinds of uses for that data. If serialization is prevented, then it should not be possible.
10:49:19 <musasabi> well one cannot prevent e.g. garbage collection either.
10:49:54 <musasabi> and what would be gained by making serialization impossible? (a user defined hook which could throw an exception would be good)
10:51:06 <esap> Right. But when you define existentially quantified type, you are supposed to define _all_ ways that it can be used. Of course, some are just assumed to be there, say GC, which are lower level services than what you normally see.
10:52:06 <musasabi> esap: but if one is required to define for each type that it can be serialized then using any libraries will prove hard.
10:54:34 <esap> Well obviously it could be only supported for things that support your platform that supports serialization. I guess what we're discussing is how to write that platform. Not all platforms are compatible with each other.
10:56:26 <esap> What an existential type says is "I know this type will only be used in these kinds of contexts". If that is not a good choice, then you shouldn't use existential types.
10:57:18 <shapr> hiya Olathe 
10:57:27 <Olathe> Hello.
10:57:31 <Kelt> hmm
10:57:33 <Kelt> wee!
10:57:34 <musasabi> esap: requiring the typeclass makes it hard to add serialization if the whole program does not come from the same source. 
10:57:41 <musasabi> the same with Typeable and Data.
10:58:17 <Cale> @yow
10:58:18 <lambdabot> YOU PICKED KARL MALDEN'S NOSE!!
10:59:38 <musasabi> generally when designing a library one does not know what all typeclasses the users will want.
10:59:44 <esap> musasabi: Well not really. Usually when you ship some code, you'll ensure that your interface allows people to do sufficient kinds of extensions. If you don't, then your code is broken.
11:00:00 <musasabi> and defining things by hand is broken.
11:00:33 <musasabi> esap: should all exported algebraic datatypes derive Read if possible ? why / why not.
11:01:10 <musasabi> defining it causes possible code bloat with little gain, on the other hand defining it by hand later is very error prone.
11:02:04 <musasabi> the same with Data and Typeable.
11:02:45 <esap> musasabi: If you export something, you have to ensure your interface is correct. If your interface wants to allow users to use read, then you have to provide that.
11:04:33 <esap> musasabi: In general, everything that is exported is a requirement that your module has to support. And your module doesn't support any requirement that it doesn't export.
11:06:19 <musasabi> esap: well I know that 99% of the users will not need Read. Someone might want it.. e.g. I needed to Read PortIDs which is not supported.
11:07:24 <esap> musasabi: Then you have to decide whether the extra trouble needed to support it later is worth the effort for those 1% of cases. It's usually simple to add new instances in additional modules.
11:07:51 <esap> musasabi: Except of course for existentially quantified things.
11:08:14 <esap> musasabi: But that's just a fact of life for existential quantification. That's what it was designed to do.
11:08:33 <musasabi> esap: except those instances will fail silently when the type is changed in the module.
11:08:35 <Kelt> lambdabot: hello
11:08:35 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
11:08:45 <Kelt> wee!
11:09:03 <esap> musasabi: Right. You can't get everything.
11:09:44 <esap> musasabi: But note that not everything needs to support reusability or transparency of change.
11:10:18 <esap> musasabi: That's only important for *platform* code.
11:10:41 <musasabi> of course but would the ablity to derive instances for types defined elsewhere cause any problems?
11:11:04 <shapr> Kelt: so um, you ever heard of this Haskell language thingy before?
11:11:17 <esap> musasabi: no, but there would not be any real benefit either.
11:11:19 <Kelt> Cale told me about it
11:11:29 <Kelt> lambdabot: @listcommands
11:11:29 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
11:11:29 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
11:11:29 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
11:11:29 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
11:11:29 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
11:11:30 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
11:11:32 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
11:11:34 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
11:11:36 <Kelt> ...!
11:11:36 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
11:11:52 <shapr> Kelt: so, have you tried it yet?
11:12:11 <shapr> Is it like smoking pot or something? The first dose comes free?
11:12:12 <Cale> shapr: looks to me like there's a bug in the line wrapping there
11:12:14 <Kelt> not yet.. going to try and learn it... I need to get away from functional programming :)
11:12:31 <musasabi> esap: except make the instances correct (with recompiling)
11:12:34 <Cale> haskell is functional
11:12:35 <Kelt> lambdabot: moo
11:12:36 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
11:12:36 <psi> shapr: where do you get free pot, anyway?
11:12:43 <Kelt> aww... but it was a command!
11:12:43 <Cale> you probably mean procedural :)
11:12:55 <Kelt> hmm... maybe so Cale
11:12:59 <esap> musasabi: what do you mean by "correct"? Why can't you just write a correct instance in another module?
11:13:02 <Cale> @moo
11:13:02 <lambdabot>          (__)
11:13:02 <lambdabot>          (oo)
11:13:02 <lambdabot>    /------\/
11:13:02 <lambdabot>   / |    ||
11:13:02 <lambdabot>  *  /\---/\
11:13:03 <lambdabot>     ~~   ~~
11:13:05 <lambdabot> ...."Have you mooed today?"...
11:13:08 <Kelt> oh!
11:13:10 <shapr> psi: it used to grow behind my house in Tennessee.
11:13:29 <Kelt> @dummy
11:13:29 <lambdabot> dummy
11:13:33 <musasabi> esap: so what is a correct instance of e.g. Typeable or Data? Are those not implementation specific?
11:13:39 <Kelt> ... lol ok...
11:13:50 <psi> shapr: hehe ;)
11:13:53 <shapr> I was going to report it to the cops until I saw them show up and plant more :-/
11:13:56 <esap> musasabi: no, you can easily write instances for those.
11:13:58 <Kelt> i think I just told the bot to call me a dummy... :/
11:14:25 <Kelt> who's the bigger fool, the person who tells another to call him a fool... or the person calls another a fool?
11:14:25 <Cale> @eval map (+1) [1,2,3,4,5]
11:14:25 <lambdabot> (line 1, column 6):
11:14:25 <lambdabot> unexpected "+"
11:14:25 <lambdabot> expecting simple term
11:14:35 <Cale> @eval map (\x -> x+1) [1,2,3,4,5]
11:14:35 <lambdabot> [2, 3, 4, 5, 6]
11:15:04 <Kelt> @eval map (\x -> x+1) [Infinity]
11:15:04 <lambdabot> unbound variable: Infinity
11:15:07 <shapr> I figured if the cops were planting the pot themselves, they probably wouldn't appreciate me knowing about it.
11:15:22 <Kelt>  @eval map (\x -> x+1) [x+1]
11:15:28 <psi> were they really doing it?
11:15:34 <shapr> yes, they really were.
11:15:41 <shapr> We moved soon after.
11:15:42 <Kelt> hmm.. ... lambdabot.. .. you still alive?
11:16:17 <esap> musasabi: that's why there are these 'mk*Ty*' functions in Typeable so that you can write instances for typeable for your own code. No need to derive if you don't want.
11:16:44 <Cale> @eval foldr (+) 0 [1..10]
11:16:44 <lambdabot> (line 1, column 8):
11:16:44 <lambdabot> unexpected "+"
11:16:44 <lambdabot> expecting simple term
11:16:53 <Cale> @eval foldr (\x y -> x+y) 0 [1..10]
11:16:54 <lambdabot> (line 1, column 26):
11:16:54 <lambdabot> unexpected "."
11:16:54 <lambdabot> expecting simple term
11:17:04 <Cale> @eval foldr (\x y -> x+y) 0 [1,2,3,4,5,6,7,8,9,10]
11:17:05 <lambdabot> 55
11:17:12 <Cale> not quite haskell :)
11:18:26 <Kelt> @eval map (\x -> x+1) [-1, .00000000000000001]
11:18:26 <lambdabot> (line 1, column 18):
11:18:26 <lambdabot> unexpected "-"
11:18:26 <lambdabot> expecting simple term or "]"
11:18:27 <musasabi> yes typeable but Data is quite painfull..
11:18:40 <Kelt> hmm no doubles?
11:18:54 <Kelt> @eval map (\x -> x+1) [-1, 1/1000000000000000000]
11:18:54 <lambdabot> (line 1, column 18):
11:18:54 <lambdabot> unexpected "-"
11:18:54 <lambdabot> expecting simple term or "]"
11:19:00 <Kelt> ... bah!
11:19:02 * Kelt sniffles
11:19:05 <Cale> it's complaining about the unary -
11:19:09 <Kelt> oh!
11:19:10 <Kelt> ha
11:19:19 <shapr> it's a lambda cal interpreter, not a true Haskell interpreter.
11:19:19 <Kelt> @eval map (\x -> x+1) [1, 1/1000000000000000000]
11:19:20 <lambdabot> [2, 1]
11:19:30 <shapr> still is surprisingly close
11:19:37 <musasabi> And doing it creates lots of fragile hand written code which could have been autogenerated.
11:19:44 <esap> musasabi: well Data interface hasn't been very stable recently. So that might be one reason for those problems. But you can still write those instances, it's just not very simple thing for that case. Of course, deriving things is always easier.
11:20:15 <Cale> Kelt: I recommend getting the ghc binaries, which will come with ghci, an interpreter you can try things out in.
11:20:49 <Cale> (don't use the source, as it will take a long time to compile)
11:20:54 <esap> musasabi: Well if your libraries don't provide support for such things, then they cause fragility. But that depends on what you intend your libraries to be useable for.
11:21:11 <esap> musasabi: Sometimes the expected use of the library is such that it doesn't matter.
11:21:29 <esap> musasabi: But if it does, then obviously you should provide it.
11:21:48 <musasabi> Consider how the serialization library fits in this.
11:22:01 <esap> musasabi: The thing is, when you write libraries, you *MUST* know what kinds of situations you intend the library to be useable for.
11:22:25 * shapr boings
11:22:29 <musasabi> It would define a Serializable type class. Now libraries would need to decide whether to depends on it or make serialization hard.
11:22:42 <esap> musasabi: If you aim for very general purpose, then you have to either restrict the functionality or build a lot of things there.
11:23:54 <esap> musasabi: Note that libraries should not care for what other libraries do, at least not much. Application code is intended to combine different libraries together. Writing applications is hard as well, but for different reasons.
11:24:50 <musasabi> esap: so other libraries would not provide support for serialization, and the poor programmer would have to write fragile instances for each datatype.
11:25:18 <esap> musasabi: Well application code has to depend on the platform anyway.
11:26:04 <shapr> hiya maihem 
11:26:08 * shapr boings randomly
11:26:09 <esap> musasabi: What he can do is to write a small 'combined platform' which combines different platforms he wants to use and builds a single platform suitable for the application from them. That would obviously have such instances.
11:26:44 <maihem> howdy!
11:26:48 <esap> musasabi: It's not that bad to have one module in each application where such things are handled.
11:27:00 <musasabi> esap: I dislike the idea of a programmer writing code that could be avoided in many languages.
11:27:53 <esap> musasabi: Well you can only avoid that if somebody did the work already for you.
11:28:47 <esap> musasabi: Or assumed that everybody needs it.
11:28:57 <musasabi> well in OO languages that can usually be done trivially and some functional languages support it too.
11:29:31 <esap> musasabi: what can be done trivially? serialization?
11:30:48 <musasabi> esap: yes. e.g. ruby and erlang
11:31:33 <esap> musasabi: I'm not sure how erlang or ruby do it, but I suspect they assume everybody needs serialization [e.g. you always get the cost even if you don't use it]
11:32:20 <musasabi> well there is little cost in such a language.
11:32:45 <musasabi> as serialization is implemented outside the language.
11:34:28 <esap> But do those languages support existentials and serialization?
11:34:42 <esap> both at the same time?
11:35:28 <esap> because I think this is a particular problem with existentials. With existentials, there is always the problem that you must _fix_ the kinds of interfaces that you support.
11:35:42 <musasabi> well they are dynamically typed so existentials make little sense.
11:36:07 <musasabi> esap: well existentials are the easiest way to simulate polymorphic objects.
11:36:45 <esap> musasabi: simulate?
11:37:42 <esap> musasabi: You can implement objects with existential quantification, type classes and coalgebras.
11:38:03 <musasabi> esap: to support heteregenous values in a e.g. finitemap satisfying some interface using existential types seems like the easiest way.
11:39:41 <esap> musasabi: it's ok for that purpose. But you wouldn't use heterogeneous values in a finitemap in a library unless the finitemap was entirely controlled by a library.
11:40:35 <esap> musasabi: At least for those portions that are encapsulated.
11:40:51 <esap> musasabi: because encapsulation means that clients don't get access.
11:41:26 <esap> musasabi: Except for a very narrow uses.
11:41:28 <musasabi> esap: no, but now consider what happens if we want to add serialization.
11:41:58 <esap> musasabi: You wouldn't need serialization for the encapsulated values.
11:42:10 <musasabi> hmm why not?
11:42:40 <esap> musasabi: Because that would mean that your library was badly designed. You have allowed uses that your library doesn't support.
11:43:12 <esap> musasabi: Libraries shouldn't provide any facilities they don't support.
11:43:58 <musasabi> I think we are mostly arguing whether serialization is a primitive or a nonprimitive optional feature.
11:44:48 <esap> musasabi: It's not about primitiveness. Think of every platform as a language,
11:45:21 <esap> musasabi: What you are trying to do is to have two languages and then mix them together.'
11:46:16 <esap> musasabi: What I'm saying is that you should separate those from each other, then all problems go away.
11:48:32 <musasabi> hmm. My current problem is that I want to create a module to serialize data and I don't want to make my other code depend on it. 
11:49:10 <esap> musasabi: Then that code cannot serialize data.
11:50:20 <esap> musasabi: if you provide a serialization library, everybody who uses serialization must depend on the library.
11:51:14 <musasabi> esap: yes, the code which *uses* serialization should depend on it. The problem is code that is used by code wanting to serialize values.
11:52:56 <esap> musasabi: Well if your libraries are designed well, then no problems should occur, because if your code that uses serialization wants to use another library, then that library had better be well-designed (otherwise, why would you use it), and if so, then it should not assume that the whole application should not use serialization.
11:53:34 <esap> musasabi: Libraries are very bad place for making assumptions about the whole program.
11:55:40 <esap> musasabi: But note that even if the library made such assumptions, that would just restrict the applicability of the library. If the applicability of the library doesn't match your application, then you shouldn't use the library.
11:58:41 <esap> musasabi: That's why library design must absolutely consider what is the applicability of the library.
11:59:48 <musasabi> But library design cannot account for everything... Yes it is very important, but not everything.
12:00:49 <esap> musasabi: Of course. But you have to balance that applicability with other factors. The question to ask is, what purpose is the library intended for.
12:01:39 <esap> musasabi: writing a good general-purpose library is very hard. Most libraries aren't even close.
12:02:21 <musasabi> e.g. I might want to serialize parsers. This is most certainly not a popular design goal for a parser library. On the other hand adding serialization does not affect the library, but is very hard to do from outside in haskell.
12:03:42 <esap> musasabi: It's not that hard really. Maybe you have to wrap the library's parser type with your own wrapper. But that's not a big deal.
12:04:50 <esap> musasabi: It's not the most efficient way of serializing, but maybe those parser libraries were not intended to be efficient either :-)
12:06:36 <esap> musasabi: Or alternatively, you just first build a separate data structure, then convert it into parser, and provide serialization for your data structure.
12:07:22 <esap> musasabi: Then you don't need serialization for the parser itself.
12:43:40 <cptchaos> @seen pesco
12:43:40 <lambdabot> I saw pesco leaving #moodswings 8 hours 1 minute 11 seconds ago.
12:46:37 <stepcut> hehe
12:54:23 <PeterE> Couldn't someone change the topic, so that #darcs" has a space: #darcs ".  This way I can join from Kopete by right clicking the name.  Any issues with this?
12:56:15 <stepcut> PeterE: i think you have to get shapr to change that
12:57:41 <PeterE> stepcut: Request sent.
13:12:33 <Riastradh> You could just type #darcs yourself...
13:12:39 <monochrom> Hahah
13:14:22 <andersca> or fix the irc client
13:51:59 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs ","http://www.haskell.org/cabal/","#haskell is now officially 1337"]' by shapr
17:36:28 <crackhead> hello!
17:36:54 <crackhead> anyone in here?
17:40:37 <Riastradh> Nope, sorry.
17:42:53 <Igloo> Anyone know of a way of having a nice Haskell GUI make dropdown boxes thin enough I can get 26 of them, each selecting a letter, in the width of a sensibly-sized window?
17:43:30 <Igloo> Just doing the obvious thing with gtk2hs and wxhaskell both made the dropdowns far too wide
18:28:12 <juhp> Igloo: not, really - do you have a screenshot or something? :)
18:34:32 <Igloo> OK, well, I want something like the top one in http://urchin.earth.li/~ian/foo.png where the buttons act as dropdown lists where you can select any letter - i.e. the functionality the bottom one has
18:35:01 <Igloo> I don't mind if there's some sort of arrow or something but the bottom window is wider than my screen...
19:08:55 <Pseudonym> Buy a bigger screen, clearly.
19:28:58 <seafood> Anyone here do any GHC hacking?
19:29:14 <seafood> My question is: What libraries can you make use of in the compiler?
19:30:02 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:30:29 <seafood> For instance, can you use Data.Generics which has only been recently added? Won't there be some sort of dependency issues?
19:30:41 <seafood> Sorry, I mean *in* the compiler source code.
19:31:36 <seafood> The idea is that you should be able to build GHC using any version of GHC from version 5.04.3 upwards (I think). If Data.Generics is not a part of that version then how exactly can you use it in the compiler source code?
19:38:47 <Igloo> I suspect you wait
19:39:33 <Igloo> I'm not even sure you'd want to trust the interface yet. I don't know what stability the haddock header thinks the interface has, though
19:40:11 <seafood> Oh yes, it may well be "provisional"
19:49:16 <seafood> Igloo: Errrrr. I can't use it anyway. I'd have to add "deriving Typeable" clauses to internal data types. Can't do that.
19:50:00 <seafood> That really would break backwards compatability.
19:57:58 <juhp> Igloo: sorry - what do you want in those dropdown lists?  I can't really see the advantage of the bottom one over the the top one
19:58:53 <juhp> upper/lowercase?
19:59:38 <Igloo> Each list has each of the letters A through Z
20:00:04 <juhp> Igloo: ok - I guess I just don't understand what it is for :)
20:00:10 <Igloo> The advantage of the bottom one is that it actually has dropdown lists - the top one is just buttons
20:00:18 <juhp> understood
20:01:47 * Igloo has used a textbox that intercepts keypresses for now instead, but since discovered I can't make tags, and hence coloured text, with gtk2hs, so given up for tonight. Maybe I'll see if I can do coloured text with wxhaskell tomorrow  :-)
20:02:24 * Igloo goes to bed
20:02:47 <juhp> Igloo: tried gok?
20:02:52 <Igloo> gok?
20:03:11 <juhp> GNOME Onscreen Keyboard
20:04:10 <Igloo> Oh, that's not what I want. What I want is to be able to specify a mapping from letters to letters
20:04:23 <juhp> Igloo: you should be able to do coloured text with gtk2hs - well it may depend on exactly what you're trying to do
20:04:23 * Igloo realises having it vertical rather than horizontal might solve the space problem
20:05:23 <Igloo> The web tells me I'd want   tag = gtk_text_buffer_create_tag (buffer, "blue_foreground",  "foreground", "blue", NULL);   in C, but AFAICT there is no gtk2hs function to do that for me
20:05:50 <Igloo> I guess I could just write a few lines of FFI code, but not tonight
20:06:35 <juhp> Igloo: one of the demos has coloured text (arabic) fwiw
20:09:25 <Igloo> Ah, looks like it works differently for labels than textviews, but that might be OK for me. Thanks!
20:09:34 <juhp> :)
