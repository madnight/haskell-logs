00:00:46 <Lor> Still, to be _really_ safe, you'd need to carry the type interface of the running program at run-time.
00:02:08 <dons> yes. I'm not sure how else something like run() could be checked
00:04:18 <dons> but we have this code in ghc to generate just the info needed for an interface. currently it is just used for module interfaces in .hi files, but I think it can be reused for the more interesting interfaces something like run() requires
00:06:19 <Lor> If carrying them in the executable (and in the process image) is too expensive, then hashes to recognize the right interfaces would suffice, ocaml-style.
00:06:27 <ozone> Lor: you can't be really safe without proof-carrying code
00:06:41 <ozone> and yeah, the hash approach is on the list of things to do ...
00:06:59 <dons> depends on how expensive all the runtime type info is going to be
00:07:46 <Lor> ozone, you count TAL to be PCC?
00:08:51 <dons> I think he probably does
00:08:52 <Lor> Personally, I don't see native-code compilation (prior to execution) to be strictly necessary nowadays.
00:09:23 <Lor> I'd rather have a neat relatively simple calculus that is easy to type-check and easy to jit-compile.
00:09:33 <ozone> Lor: well, it'll do for purposes of this discussion :)
00:09:59 <dons> we'd be able to do powerful things more easily, if there was a nice typed bytecode
00:10:24 <ozone> is GHCi's bytecode format feasible to use as a typed bytecode?
00:10:44 <ozone> actually, no, i'm just talking crap now :)
00:11:03 <Lor> To my understanding, a bytecode is a sensible intermediate format only if you interpret it directly, not if you are going to jit it.
00:11:42 <ozone> lor: why?
00:12:39 <Lor> Because bytecode (like assembly) is a bitch to type, and it also makes code transformations much harder.
00:13:03 <Lor> See http://citeseer.ist.psu.edu/league01functional.html
00:14:22 <ozone> lor: hmm, but there's no inherent reason why bytecode has to be JIT-unfriendly
00:14:49 <ozone> it's no different from JITting machine code, really
00:15:07 <ozone> is there something else i'm missing?
00:15:24 <Lor> You mean jitting one architecture's machine code into another one?
00:15:36 <musasabi> which is hard.
00:16:20 <musasabi> The problem is that you can see *what* the code does, but not why and what pre/postconditions are needed.
00:16:51 <ozone> Lor: well, in this context, i take "JIT" to mean "dynamic optimisation"
00:18:37 * Lor is off for a while. Laundry.
01:04:32 <shapr> hiya dv^ 
01:26:57 <shapr> hiya gene9 
01:27:11 <gene9> hi shapr
01:27:23 <shapr> how's code?
01:28:27 <gene9> thank you, it looks like I have no time fot haskell now ;(
01:30:21 <shapr> too bad
01:32:02 <shapr> @devils monad
01:32:04 <lambdabot> *** "MONAD" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993
01:32:04 <lambdabot> "
01:32:04 <lambdabot> MONAD, n.  The ultimate, indivisible unit of matter.  (See
01:32:04 <lambdabot> _Molecule_.)  According to Leibnitz, as nearly as he seems willing to
01:32:04 <lambdabot> be understood, the monad has body without bulk, and mind without
01:32:06 <lambdabot> manifestation -- Leibnitz knows him by the innate power of
01:32:06 <shapr> huh
01:32:08 <lambdabot> considering.  He has founded upon him a theory of the universe, which
01:32:10 <lambdabot> the creature bears without resentment, for the monad is a gentlmean. 
01:32:12 <lambdabot> [8 @more lines]
01:32:16 * shapr laughs
01:32:57 <shapr> good morning PeterE 
01:33:21 <PeterE> God morgen.
01:33:30 <shapr> how's code?
01:33:49 <PeterE> shapr: Schlecht.
01:34:30 <tic> Am I the only one who thinks Tubular Bells II is very similar to Tubular Bells?
01:34:33 <shapr> have any questoins about Haskell?
01:34:41 <shapr> I haven't heard II
01:34:50 <tic> shapr, got a fast connection? :)
01:35:07 <shapr> er, I'll pass
01:35:09 <tic> okay. :)
01:35:14 <tic> (you could stream it from me.)
01:35:17 <shapr> I only download music with the permission of the artist.
01:35:27 <shapr> well, sort of
01:35:37 <shapr> magnatune.com is good
01:37:24 <tic> Heh, sort of. :)
01:37:33 <pesco> Hi all. Is someone familiar with XML?
01:37:41 <tic> but if you stream it you don't store it for later use. ;)
01:37:41 <shapr> I'm somewhat familiar with it.
01:37:51 <shapr> hm, interesting point
01:37:53 <shapr> I'll think about that.
01:37:58 <pesco> Is it true that I cannot break a document into a hierachry of physical chunks?
01:38:19 <shapr> you *can* but only if you use something like xslt that can include files
01:38:41 <pesco> Er. So I'd have to invent my own markup?
01:39:08 <shapr> I don't think that would help.
01:39:10 <tic> invent.. well, just add <pesco:include-file href="...">
01:39:18 <shapr> unless you wrote your own preprocessor as well.
01:39:27 <tic> ah, yeah.
01:39:36 <tic> add a custom tag and run it through xslt. no biggie.
01:39:45 <shapr> xslt does support including files
01:39:51 <pesco> This is still pissing me of.
01:39:55 <tic> oh.  Forgot about it.
01:39:55 <pesco> off.
01:40:06 <pesco> OK, I'm confused.
01:40:07 <tic> pesco, maybe you could re-design your implementation so it doesn't need to include it right in the xml?
01:41:34 <shapr> hej bringert!
01:41:36 <pesco> tic: I'd like to break out a chapter from my DocBook document. Which is perfectly reasonable. Incidentally, that part of the document includes a source code fragment (literate program) which I want in a seperate file, so there is a one-to-one mapping of xweb files to .hs files.
01:42:24 <bringert> hej
01:42:36 <shapr> what's up?
01:42:50 <bringert> came back from AFP last night
01:43:00 <shapr> cool! how was it?
01:43:13 <bringert> lost of talks
01:43:18 <bringert> *lots*
01:43:30 <shapr> nifty stuff?
01:43:35 <bringert> yeah
01:43:48 <pesco> shapr: Can you give me an example of how to do that XSLT thing?
01:44:02 <shapr> no, I'd have to look at an XSLT reference.
01:44:23 <pesco> Oh, ok.
01:45:01 <shapr> bringert: your talk went well?
01:45:15 <bringert> arrows, epigram, attribute grammars, HaRe, buddha, clean, wash
01:45:22 <bringert> went ok, I think
01:45:25 <andersca> , rinse, repeat
01:45:59 <bringert> that too
01:46:18 <Lor> Of course it started raining just when I brought my laundry outside to dry...
01:47:15 <tic> hrm..
01:47:23 <tic> pesco, how about just using LaTeX? ;)
01:57:51 <musasabi> the sun is shining ;)
02:08:37 <pesco> tic: DocBook has advantages.
02:09:01 <pesco> I have a solution anyway, which is satisfactory to me.
02:09:11 <pesco> (Just came back from the shower.)
02:10:12 <tic> true.
02:13:16 <pesco> Although it's a pity the DocBook XSL stylesheets' output is much inferior to that of LaTeX, just because spacing and fonts aren't arranged as good.
02:49:41 <Lor> How does docbook generate postscript?
02:50:26 * shapr blinks
02:52:40 <TheHunter> good morning, everybody
02:52:57 <shapr> good morning TheHunter
03:10:39 <ikegami--> good morning :)
03:10:52 <ibid> good afternoon :)
03:11:52 <ikegami--> (however, i will finish today's work and leave our laboratory) ;)
03:14:06 <ikegami--> today, i touch a software which consists of 10000 lines Haskell code
03:14:22 <ikegami--> (includes 3 monads)
03:14:45 <shapr> nifty
03:15:10 <ikegami--> but i'm happy because haskell programming is fun
03:15:31 <shapr> I agree
03:16:33 <ikegami--> types help us to understand codes
03:16:37 <ikegami--> very good
03:18:50 <ikegami--> anyway, see you later
03:18:56 <ikegami--> happy hacking
03:19:25 <shapr> see you later.
03:21:14 <shapr> ah, here's an excellent quote, I think I'll it into my .sig
03:21:38 <shapr> For Java and C, there's a lot you need to know. But most people can learn (memorize) all these facts.
03:21:39 <shapr> Haskell on the other hand requires you to grasp some high level concepts. There is actually not that much to learn. The trouble is to understand it all -- Sjoerd Visscher
03:23:06 <shapr> haha
03:23:25 <shapr> there's a thread on Lambda the Ultimate about Paul Graham's 'Python Paradox' response
03:23:37 <shapr> and a lot of people hit Paul pretty hard in this thread.
03:23:57 <shapr> specifically a lot of them say that he's really missing out since he's never used Haskell.
03:24:32 <shapr> So he replies: "I just listed the first languages that came to mind. But it is probably no accident that those came to mind first. Haskell, for example, seems to me a language that's designed more to write papers about than to hack in. I get the impression that using it would feel like reading a novel written by a literary critic."
03:24:39 <shapr> it's pretty funny to see him jump into an LtU discussion.
03:24:46 <shapr> hiya sorje 
03:25:03 <Lor> I wish LtU were a mailing list, or a newsgroup. Then I might actually read it.
03:25:09 * Lor dislikes web forums.
03:25:14 <shapr> yah, I agree with that.
03:25:17 <shapr> web forums suck.
03:25:25 <shapr> I wonder if it's RSS accessible
03:25:42 <shapr> I think my pull email idea is going to happen anyway with RSS.
03:29:02 <shapr> trivia question: what's the connection between Haskell and valgrind?
03:29:39 <ibid> it seems to be rss accessible
03:30:17 * Maddas dislikes web forums and mailing lists
03:30:22 <Maddas> Discussions on them, that is.
03:30:28 <Maddas> Also discussions on IRC.
03:30:56 <shapr> hm, I enjoy IRC discussions.
03:31:12 <Maddas> I enjoy conversations
03:31:32 <Maddas> on IRC, that is.
03:32:45 <Maddas> It's just that the fact that you can't punch somebody in the face through the internet seems to motivate people to do things that make you want to punch them in the face.
03:32:52 <shapr> I agree with that.
03:33:03 <shapr> but then, that's what the /kickban command is for...
03:33:19 <Maddas> Well yeah, but that doesn't work if you aren't op :-)
03:33:44 <shapr> for #haskell, if someone doesn't respond to polite requests to back off, talk to me
03:33:44 <arjanb> discussions can be good if it's between open minded people
03:33:46 <Maddas> I don't dislike /all/ discussions on the internet, just the large majority. 
03:33:49 <musasabi> /c/c
03:33:56 <shapr> Maddas: I agree with you there.
03:34:04 <shapr> it's hard to find good communities.
03:34:34 <Maddas> Also, I don't think I like any discussion with a sufficiently large number of people involved in the internet.
03:34:45 <Maddas> Since it usually ends up in a bunch of pissing matches :-) 
03:34:46 <Philippa_> gets pretty hard to follow, certainly
03:34:49 <Philippa_> that too
03:35:35 <Maddas> Especially if you don't 'know' the people -- which is bound to be so when there are enough of them.
03:35:53 <Maddas> (for internet values of 'know' :-))
03:36:10 <Philippa_> yep. More so if you've a slightly sarky sense of humour - it's scary the number of people who've gone "ah - OK, everything's cool" the instant they've met me IRL
03:36:23 <Philippa_> or the number of people I've done that with, for that matter
03:36:27 <Maddas> Haha, yeah, I believe that
03:37:57 <shapr> Philippa_: what do you mean?
03:38:08 <Maddas> I always wonder how script kiddies that threaten to packet you would react if you knocked their door the next day and said "Hi, so I'm the guy you wanted to packet yesterday." I can't imagine that not being hilarious for the guy knocking on the door :-)
03:38:19 <Philippa_> shapr: people being unsure as to whether my sarcasm's generally nasty or just playful
03:38:23 <shapr> oh
03:38:35 <shapr> I assume that people are not being nasty unless they make a big point of being nasty
03:38:56 <shapr> hiya shammahs 
03:39:03 <Philippa_> yeah, but there's a lot of room for subtlety - especially in a chan where everbody's subtly egging everybody else about their sexuality all the time
03:39:35 <Maddas> egging?
03:39:49 <Philippa_> "ribbing" etc. Having a (mild) go at.
03:39:57 <Philippa_> not /quite/ teasing, but similar
03:43:24 <Maddas> Ok :)
03:46:15 <Lor> Where is the LtU rss feed?
03:46:52 <arjanb> http://lambda-the-ultimate.org/node/feed
03:47:15 <ibid> there is a link from the sidebar
03:47:25 <Lor> Ah, cool.
03:48:12 <arjanb> but it doesn't seem to include forum posts
05:34:50 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]'
05:34:50 --- topic: set by shapr on [Fri Jun 25 02:34:22 2004]
05:34:50 --- names: list (clog themaximus cptchaos arauko CLxyz gintas Fractal cmeme Lunar^ opet Smerdyakov dennisb dv^ ozone Igloo_ [dan]_ shawn_ kimmell_ Cale_ cm thebug_ mattam_ Philippa viblo shammahs emu Taaus juhp sorje shrimpx cgibbard jak stepcut Joachim dons TheHunter andersca bringert arjanb lelit sisko LrdAway isomer sazzle_ blackdog_ det ksandstr esap asmodai keverets skylan Riastradh lambdabot Maddas eshu tic shapr edwinb kuz ibid wagle kosmikus gdsx)
05:34:50 --- names: list (Matt-W flori musasabi XTL Lor polli Hipo norpan earthy roconnor)
05:44:12 <musasabi> yes, but that does not solve the basic problem..
05:44:58 <musasabi> Let's say I have a few thousand lines of code not using any monad or IO. Now it needs to be converted to using a Reader monad. Things get quite ugly...
05:45:14 <shapr> how so?
05:45:17 <Lor> Why? You just need to change the signature.
05:46:12 <Philippa> Lor: um, no - you need to add return everywhere too
05:46:45 <Philippa> granted that's not exactly impossible to do, but it's a PITA
05:46:56 <Lor> Ah, right. Yes, the conversion _to_ monadic style is difficult, but once you are there, you can change the monadic type used.
05:47:12 <musasabi> and conversions of '.' to >>=...
05:47:25 <Philippa> my pet hate's if
05:47:30 <Lor> But if you often need to change a piece of code to use monadic style, there's something strange in your design.
05:47:53 <Lor> It means that something that you thought would be pure turns out not to be quite so pure after all.
05:48:07 <Philippa> or it means you were hacking away and refactoring as needed
05:48:40 <Philippa> state monads being a frequent offender for that, sooner or later you decide state's becoming fundamental enough to what you're doing to excuse a state monad
05:48:53 <Lor> In any case, I do agree than monads are fundamentally too rigid.
05:49:20 * Lor would prefer effect systems.
05:49:45 <musasabi> Lor: things like reader monad don't imply non-pure code, do they?
05:49:49 * Philippa wants something akin to arrows with pure functions being intrinsically an arrow-like type
05:50:21 <Philippa> so slightly more flexible than monads and with a uniform(ish) syntax
05:50:30 <musasabi> sounds good.
05:50:33 <shapr> yah, I want that too.
05:50:41 <Lor> musa, all right, maybe not reader.
05:51:01 <shapr> Philippa: when do we get to see a preview?
05:51:11 <Lor> Implicit parameters are an alternative to the reader monad.
05:51:56 <Philippa> shapr: when I have something
05:51:59 <shapr> ok
05:52:44 <musasabi> Lor: yes, but haskell has nothing like that.
05:52:58 <Lor> Oh?
05:53:37 <Lor> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#IMPLICIT-PARAMETERS
05:54:36 <pesco> Oh my god, can someone just FIX those stylesheets. Sorry, I'm majorly pissed, need to release some pressure.
05:54:37 <musasabi> looks nice, I didn't know something like that existed.
06:04:03 <musasabi> Then again that kind of screams unportablity...
06:07:22 <kuz> Dynamic scoping evil.
06:07:37 <kuz> Rawr.
06:09:46 <musasabi> but sometimes very usefull.
06:33:01 <shapr> g'day SyntaxNinja 
06:33:25 <SyntaxNinja> hihi shapr
06:33:45 * SyntaxNinja is planning to put some hazelnut syrup in his coffee this morning
06:34:00 <shapr> does that taste good?
06:34:58 <SyntaxNinja> yeah, on occasion.
06:37:06 <Igloo> How do you work out if today is an occasion on which it will taste good? Or is it just pot luck?
06:37:56 <shapr> uh oh, our local eight year delinquent just walked by my window with a hammer and a box of nails.
06:38:22 <shapr> that's the same kid who rolled the car tire through our window not so long ago...
06:39:04 <SyntaxNinja> Igloo: you can tell by the aspect of venus.
06:39:06 <roconnor> @type showInt
06:39:08 <lambdabot> bzzt
06:39:09 <SyntaxNinja> if you know what I mean.
06:39:38 <shapr> I want to implement a stack based lang in Haskell. How about a list for the stack, if the top of the stack is a value, return it, if it's a function, pull off the next value and feed that to the function. Does that sound sane?
06:40:13 <shapr> has anyone already implemented stack lang in Haskell?
06:40:14 * shapr googles
06:40:55 <roconnor> sounds pretty straight forward to write.
06:41:06 <roconnor> By the time you are done googling, you could have it written.
06:42:26 <roconnor> data StackObj = Value Integer | Function (Integer -> StackObj)
06:42:30 <roconnor> Does that work?
06:42:42 <roconnor> newType Stack = [StackObj]
06:43:19 <roconnor> runStack (Value i) = i
06:43:34 <roconnor> oops
06:43:54 <roconnor> runStack ((Value i):rest) = i
06:46:09 <roconnor> runStack ((Function f):(Value i):rest) = (f i):rest
06:46:30 <roconnor> runStack _ = error "Stack goes boom"
06:46:35 <roconnor> done
06:46:38 <roconnor> :-)
06:46:59 <musasabi> except for functions taking functions as args ;)
06:48:05 <roconnor> Did we want higher order function is the stack?
06:48:45 * roconnor woders if what I wrote typechecks.
06:48:58 <roconnor> actually it doesn't
06:49:29 <roconnor> runStep ((Value i):rest) = Right i
06:50:02 <roconnor> runStep ((Function f):(Value i):rest) = Left ((f i):rest)
06:51:18 <Igloo> You'd probably want to recursively runStack until you got a normal form
06:51:41 <Igloo> Your newType declaration is wrong in both case and absence of constructor too
06:52:39 <roconnor> runStackHelp (Left stack) = runStackHelp (runStep stack) 
06:52:51 <roconnor> runStackHelp (Right i) = i
06:53:11 <roconnor> runStack = runStackHelp . Left
06:53:29 <Igloo> It's probably a fold as you've specified it
06:54:05 <roconnor> My newType declaration is wrong?
06:54:30 <Igloo> But I don't think you could do much better than a fix if you allow functions to put things on the stack or anything
06:54:51 <Igloo> "newtype Stack = Stack [StackObj]"
06:55:00 <roconnor> Oh right.
06:55:18 <Igloo> (you also don't actually use the type - you might have meant "type Stack = [StackObj]")
06:57:13 <shapr> geez, I should ask these sorts of simple questions more often :-)
06:58:01 <shapr> what about multi-arg functions? will that work by just repeatedly applying values to the function until it becomes a value itself?
06:58:45 <roconnor> plus = Function \a -> (Function  \a -> (Value a+b))
06:58:49 <roconnor> oops
06:58:52 <roconnor> plus = Function \a -> (Function  \b -> (Value a+b))
06:59:27 <roconnor> I hope that works.  It was my intension.
06:59:43 <shapr> it looks like it'll work.
07:04:32 <Igloo> With a few more parens at least
07:04:43 * shapr is playing with that
07:15:16 <edwinb> This starts to sound like normalisation by evaluation...
07:17:20 <cptchaos> pesco: your cmdline darcs repository leaks an tangle file, so dacs get && make does not work, however you can easily use the one in Comm reprository, but maybe you like to fix that
07:17:58 <pesco> cptchaos: I don't want to replicate the file.
07:18:21 <pesco> cptchaos: In fact, using the one from Comm is exactly what I'm doing myself. :0
07:18:21 <pesco> )
07:18:37 <pesco> cptchaos: I'll come up with a cleaner solution soon.
07:18:51 <cptchaos> pesco: ok
07:18:55 <pesco> cptchaos: The distribution tarball contains all the .hs files, btw.
07:19:49 <cptchaos> pesco: ah, ok, I will use that than
07:42:52 <cptchaos> pesco: a dirty solution would be to put the xweb directory in an extra darcs reprository, and "darcs get" it from the makefile
07:43:30 <pesco> cptchaos: Heh. I might actually end up doing just that, because I'm severely pissed at both the XWEB and the DocBook stylesheets.
07:44:36 <pesco> They are unthinkably bad. You'd expect them to produce at least somewhat reasonable typesetting. But the output defies all rules of readability.
07:45:25 <pesco> Now guess how much fun it is to fix them.
07:45:42 <cptchaos> pesco: 0 
07:46:51 <pesco> If you're clamping to positives, yes.
07:48:06 <musasabi> What would be the best way to parse binary data in haskell?
07:48:35 <pesco> Depends on the format, I'd guess.
07:48:39 <pesco> What do you mean, exactly?
07:49:58 <pesco> Woohoo, indented code fragments.
07:50:13 * pesco bangs his head against the channel wall.
07:50:41 <shapr> hoi goron 
07:50:44 <musasabi> pesco: packets from network. (bitfields and network byteorder {8,16,32}-ints)
07:51:07 <shapr> oh there was a thread about that on the mailing lists some months back
07:51:22 <shapr> have you seen HsDNS from Peter Simons?
07:51:29 <shapr> it parses DNS packets
07:52:51 <shapr> edwinb: would you implement normalisation by evaluation differently?
07:52:59 <pesco> musasabi: Do you have them in raw memory or [Word8]?
07:55:21 <Lor> Hehehe. From LtU: "PS: by the way, your name sounds familiar. Are we acquainted?" "You're sitting two floors above me"
07:56:01 <musasabi> shapr: doesn't use an external C library?
07:56:06 <edwinb> shapr: That depends on what the source language actually is... I wasn't really following that closely...
07:56:12 <musasabi> *doesn't it*
07:56:29 <edwinb> So I'm not quite sure what the conclusion of the discussion was!
07:58:40 <edwinb> I usually have a helper function "apply" which knows how to deal with terms of various forms, not just functions. Say, a local variable where you don't know what its value is yet.
08:04:26 <shapr> Lor: heh, which discussion is that from?
08:04:29 <shapr> musasabi: yes, it does
08:05:20 <Lor> shapr, "Call-by-what?"
08:05:31 <shapr> heh
08:05:37 <shapr> that sounds like fun.
08:07:14 <goron> hoi shapr (what's hoi in Swedisch?)
08:07:20 <shapr> hej
08:08:33 <goron> shapr: When did you banned Smerdyakov? 
08:08:44 <shapr> sometime ago
08:08:55 <shapr> I don't remember exact dates, but I can find it in the logs if you want to know.
08:09:03 <shapr> hoi stefan_ 
08:09:09 <goron> shapr: I want to know.
08:09:19 <shapr> ok, lemme look
08:09:27 <stefan_> shapr: hi shapr ... how's life? how's code?
08:10:11 <shapr> code is really nifty
08:10:14 <Leimy> hello
08:10:18 <shapr> I'm working on sekrit projekt
08:10:32 <Philippa> heh
08:10:50 <Leimy> ugh... my first attempt with a State Monad last night turned into a horrible non-working-but-syntactically-correct beast 
08:10:56 <shapr> Leimy: that's a good start
08:11:00 <Leimy> heh
08:11:04 <Leimy> http://paste.lisp.org/display/2483
08:11:07 <Leimy> there's the code
08:11:14 <shapr> I didn't get syntactically correct with my first try.
08:11:14 <Leimy> it's the wrong way to write a word-counter
08:11:40 <Leimy> I wanted to keep the state of the input stream in a 2 state State Monad
08:11:56 <Leimy> and then I decided to accumulate the word count in the monad and just "show" it at the end
08:12:04 <Leimy> that's when I realized it wasn't counting.
08:12:06 <Leimy> :P
08:12:20 * stefan_ wrote imperative code almost all day yesterday ... and the better part of the night too, actually ... so, please, show me some nice functional stuff ... please ...
08:12:49 <shapr> yow!
08:12:59 <shapr> Leimy: I used a finite map to accumulate the counts.
08:13:00 <Leimy> I can't decided if the problem is the definition of (>>=) or not
08:13:17 <Leimy> s/decided/decide/
08:13:46 <Leimy> well I loosely based this on the IRL [Imperative Robot Language] in Hudak's book
08:14:01 <cptchaos> pesco: your Cmdline lib works fine 
08:14:27 <stefan_> kosmikus: I was glad our meeting was cancelled, 'cause somehow I managed to switch night and day ... feels like early morning right now
08:14:50 <Leimy> hmmm
08:15:15 <goron> Is there a fixed point function in some of the standard libs? 
08:15:17 <pesco> cptchaos: I know. It has unit tests. :) And I've actually written two example programs with it.
08:15:33 <stefan_> goron: not that i know off
08:15:45 <shapr> I think there's in Numeric
08:15:56 <goron> It should be in the standardlibs, imo.
08:15:59 <TheHunter> goron: Control.Monad.Fix
08:16:13 * stefan_ browses the libs
08:16:43 <shapr> oh that fixed point.
08:16:46 <shapr> @index mfix
08:16:46 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
08:16:46 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
08:17:01 <goron> It's just called fix.
08:17:06 <stefan_> @index fix
08:17:07 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
08:17:07 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
08:17:16 <shapr> @type mfix
08:17:18 <lambdabot> bzzt
08:17:24 <stefan_> @type Control.Monad.Fix
08:17:25 <lambdabot> bzzt
08:17:25 <shapr> @type Control.Monad.mfix
08:17:26 <lambdabot> bzzt
08:17:34 <TheHunter> @type Control.Monad.Fix.fix
08:17:35 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
08:17:36 <goron> TheHunter: Thanks
08:17:37 <kosmikus> stefan_: I'm glad as well ... don't feel very creative today.
08:17:40 <shapr> man that bot is difficult
08:18:03 <pesco> @type Control.Monad.Fix.mfix
08:18:05 <lambdabot> Control.Monad.Fix.mfix :: forall m a.
08:18:05 <lambdabot> 			  (Control.Monad.Fix.MonadFix m) =>
08:18:05 <lambdabot> 			  (a -> m a) -> m a
08:18:22 * pesco hugs lambdabot.
08:18:57 <stefan_> kosmikus: tomorrow I'll write about the boilerplate stuff ... which is kind of hard to put on paper nicely, I think ...
08:19:41 <stefan_> kosmikus: when did you got back from the Baltic states?
08:20:45 <goron> What 's wong with the following definition? I get an exception when I execute it.  test = fix (+0)
08:21:14 <goron> *** Exception: <<loop>>
08:21:53 <goron> It needs a starting value, maybe.
08:22:19 <goron> A normal fixed point function has type: (a->a)->a->a
08:22:34 <stefan_> goron: fix (+0) = (fix (+ 0)) + 0 = ... = ... + 0 + 0 + 0 + 0
08:23:00 <kosmikus> stefan_: on Saturday
08:23:13 <stefan_> stefan_: direct flight?
08:23:22 <stefan_> kosmikus: direct flight?
08:23:29 <kosmikus> stefan_: no, via Helsinki
08:23:35 <shapr> goron: ah, here we go: http://www.schizomaniac.net/haskell.html
08:23:39 <shapr> that links to a log of the actual ban.
08:24:26 * stefan_ yawns
08:25:23 <shapr> Anyway, I've told Smerdyakov that if he is troublesome again, he gets banned permanently, with no more forgiveness and extra chances.
08:27:10 <stefan_> shapr: I was asleep all day ... what crimes did Smerdyakov commit?
08:28:27 <shapr> Primarily, he drove newbies away from the channel, and would not agree to disagree with some people who were already here.
08:30:03 <shapr> From my viewpoint, this channel is a community that promotes learning and writing Haskell. I try to promote that. Smerdyakov disagree with that viewpoint.
08:31:03 <kosmikus> is this issue still relevant? I thought that he was unbanned a while ago, so I'm surprised to see this being brought up again.
08:31:32 <shapr> goron was asking about it, he found the text that Smerdyakov wrote on the wiki.
08:32:03 * stefan_ browses the logs ... (January!?)
08:32:17 <shapr> Smerdyakov feels that I am unable to act appropriately here on #haskell.
08:33:03 * shapr shrugs
08:33:15 <shapr> stefan_: yah, it's ancient
08:33:30 <goron> stefan_: I don't see the use of fix. 
08:33:33 <Riastradh> shapr, while I don't want to get involved in any sort of argument about this (especially given how dead the issue ought to be by now), I just want to point out that what you're saying is rather vague, and doesn't explain very specifically what things he's done.
08:34:23 <musasabi> Why is Data.HashTable.hashString using foldr?
08:34:27 <shapr> Riastradh: do you really want to resurrect this?
08:34:41 <stefan_> goron: fac_ f n = if n == 0 then 1 else n * f (n - 1) ; fac = fix fac_
08:34:43 <Philippa> Riastradh: it's surprising how difficult it is to do that when somebody's not capable of abstracting over human behaviour
08:34:59 <Philippa> Ever tried explaining anything social to somebody with an autistic spectrum disorder? Can be... difficult
08:35:21 <Riastradh> shapr, no, certainly not.
08:35:26 <shapr> ok then.
08:36:03 <Philippa> anyway, 'moff for a bit
08:36:25 <shapr> I'd much rather write code or spend my time organizing, indexing, or maintaining existing Haskell code.
08:40:49 <roconnor> Hmm
08:42:37 <roconnor> runStep ((Function f):(Function g):rest) = let (Left newStack) = runStep ((Function g):rest) in ((Function f):newStack)
08:42:49 <roconnor> Anyhow, I guess my code needs a little more work.
08:44:00 <roconnor> runStep needs to return a Stack until there is only a Value on the top.  A post-processing function needs to return that value.
08:44:12 <roconnor> I need to get rid of the Left, Right nonsense.
08:44:20 <goron> stefan_: Ok, I now see the use. You have to use it on a function like this: (a->b)->a->b (in general substitute the a by some function).
09:01:19 <musasabi> How do I do message passing with Control.Concurrent? 
09:02:24 <musasabi> or more precisely, how do I reply to messages from an another thread?
09:03:04 <musasabi> my first hunch is:
09:03:05 <musasabi> myService :: MVar (MVar ReturnType, ArgumentType)
09:03:37 <musasabi> That is a MVar is passed to the service to which the reply is then written. But there is surely a better way to do it?
09:05:58 <shapr> from what I've heard, you use MVars
09:06:08 <shapr> and Channels, which are built on MVars
09:07:03 <musasabi> Channel's don't seem to add anything to MVars except buffering.
09:07:08 <musasabi> Channels
09:24:32 <jargon> cale?
10:15:02 * eshu is implementing a stack based language in haskell as we speak
10:15:31 <Philippa> been reading through the scrollback?
10:15:37 <eshu> yeah :P
10:15:37 <Philippa> anyway, cool
12:29:50 <bourbaki> hiho
12:30:47 <Lemmih> ohih
12:33:05 <bourbaki> heh
13:07:50 <Aglarion> (i would ask a dump question if i did not fear being kicked)
13:08:38 <stepcut> dump?
13:08:43 <Aglarion> dumb
13:08:46 <Aglarion> :)
13:08:51 <Lor> No dumps to the channel, please. :)
13:08:57 <Aglarion> lol
13:09:01 <Marvin--> there are no dump questions, only dumb questions ;)
13:09:18 <Aglarion> i today started learning haskell
13:09:32 <Aglarion> (after i had played around with lisp a few weeks)
13:09:45 <Aglarion> but the type system makes me cry
13:10:10 <Aglarion> (at least explicit typing)
13:10:10 <Marvin--> funny, we kinda like it :)
13:10:42 <Aglarion> i just don't know how to tell the compiler what i want
13:10:48 <Marvin--> explicit typing? why not trust the type inference?
13:10:54 <Lor> aglarion, a less steep path might be lisp->scheme->ml->haskell
13:11:02 <Aglarion> ml?
13:11:13 <stepcut> ml makes me cry
13:11:26 <Lor> ml is like scheme, only typed, or like haskell, only eager. :)
13:11:36 <Aglarion> ok...
13:11:46 <Marvin--> ml makes me cry too
13:11:50 <Marvin--> but then, so does lisp :)
13:11:53 * Riastradh hits Lor with the qualifier 'statically.'
13:11:53 <Aglarion> i think i have mastered the very first step on the way to a haskell programmer
13:12:08 <jesse99> is ml impure or is that only ocaml?
13:12:15 <Lor> Bah. Types are static by definition.
13:12:26 <Aglarion> i wrote my first fibanocci number calculator :)
13:12:29 <Philippa> jesse99: most ML variants are impure, there's a pure "Core ML" though
13:12:31 <Lor> At least by someone's definition... :)
13:12:36 <Aglarion> and a function to check if a number is prim
13:12:40 <musasabi> What should I use if I have a integer value (exchanged with outside world), which has "common" values for which I want to provide a nice name in haskell, but enumerating all possible values is not possible?
13:13:15 <Lor> musa, you mean like HTTP status codes?
13:13:22 <Aglarion> my question is: is explicitly typed a function with myfunc :: a -> a -> [a] -> [a]
13:13:27 <musasabi> Lor: yes.
13:13:31 <Aglarion> but it wouldnt compile
13:13:34 <Lor> Just make an abstract newtype.
13:13:50 <Philippa> musasabi: use patterns that look like "Con i | i == someInt -> blah"?
13:14:12 <Aglarion> then without explicit typing it compiles. after typing :t myfunc in hugs, it tells me the type was  myfunc :: Eq a => a -> a -> [a] -> [a]   
13:14:27 <musasabi> thanks.
13:14:38 <Aglarion> whats this Eq a => stuff? i need a keyword to ask google :)
13:14:39 <Philippa> your function needs equality, hence the restriction that a be a member of the class Eq
13:14:40 <Lor> aglarion, apparently you compare the a:s at some point.
13:14:44 <Philippa> "type class"
13:15:17 <Aglarion> ok... that seems to make sense to me...
13:15:49 <Philippa> your annotation missed out the Eq a => bit, and thus was too broad
13:15:49 <Marvin--> type classes is how overloading works in Haskell
13:15:49 <Aglarion> and class Eq contains all types that have an equal operator defined?
13:15:53 <Philippa> right
13:16:21 <Aglarion> ok... (forgive me... i'm used to imperative programming)
13:16:28 <Philippa> 'sok
13:16:42 <Philippa> type classes are a Haskell oddity/selling point anyway
13:18:36 <Lor> And this is not really relevant to the imperative/functional distinction.
13:18:43 <Aglarion> thanks for the help. (on the most channels it's not usual to help beginners without flaming them)
13:18:54 <musasabi> Type classes seemed important when I first learned haskell, nowadays I seldomly need to create new ones.
13:19:52 <Marvin--> Aglarion: oh, you want some flames? I suppose we could arrange that...
13:19:57 <Philippa> most channels are full of arseholes :-)
13:20:04 * Marvin-- ponders
13:20:10 <Aglarion> marvin: oh please ! :)
13:20:37 * Riastradh ignites a napalm-covered piece of bait regarding static versus dynamic typing.
13:20:41 <Marvin--> but I'm out of practice :-/
13:20:55 <Aglarion> never mind
13:21:05 <Riastradh> Actually, no, that piece of bait has been burnt out by now.
13:21:18 <Philippa> Marvin--: then perhaps you should get your lame arse outta that bed in your mama's house and learn to flame, bitch? ;-)
13:21:24 <jesse99> not on comp.object it hasn't
13:21:29 * Marvin-- laughs
13:21:35 <Riastradh> Yes, but here, it certainly has, jesse99.
13:21:38 <Riastradh> Observe:
13:21:51 <Riastradh> Rhaa rhaa static typing sucks, dynamic typing rules!
13:22:03 * Aglarion needs to get rid of bad C++ thoughts when learning haskell!
13:22:04 <Riastradh> Notice in the following minutes a distinct lack of flamage regarding that exclamation.
13:22:13 <Lor> "dynamic typing" is an oxymoron, therefore your statement is devoid of meaning.
13:22:16 <Lor> Ha. :)
13:22:35 * stepcut read the capture on type checking in the dragon book this weekend
13:22:39 <Philippa> Aglarion: type classes aren't the same as classes, they're mebbe closer to virtual base classes in that all you "inherit" is a list of functions that're available on a type
13:22:42 <Riastradh> See, it falls immediately to the floor and extinguishes itself by simple statements that don't really have much to do with anything.
13:22:46 <stepcut> s/capture/chapter/
13:22:55 <stepcut> what a weird typo...
13:23:02 <Philippa> stepcut: I really don't rate the dragon book these days, the tiger book seems much better
13:23:23 <stepcut> :(
13:23:29 <Lor> The dragon book is rather old-fashioned. The code in it cannot be recommended to anyone.
13:24:05 <Aglarion> what are dragen and tiger book? i'm currently trying to learn it from internet sources
13:24:08 <Philippa> the ML version of the tiger book is nice, covers loadsa ground and doesn't have to feck about too much with the code (I don't want to know how bad the C version is)
13:24:19 <stepcut> well, I just undercovered the book while cleaning, so I thought I would read it before attempting to read 'typing haskell in haskell' for the second time
13:24:29 <Marvin--> the ml-tiger book is really nice
13:24:39 <Smerdyakov> None of these books treat type-checking in much detail.
13:24:43 <Philippa> Aglarion: they're books on compilers, so prolly no use for you
13:24:45 <Smerdyakov> You want a text on PL semantics for that.
13:24:54 <Marvin--> sure
13:25:17 <Philippa> Smerdyakov: well sure. The tiger book has the decency to mention the existance of type inference and hand out some references though
13:25:18 <Smerdyakov> Neither dragon or tiger will help you at all for understanding typechecking, I would guess.
13:25:36 <jesse99> engineering a compiler is the best current book i've seen, seems to be recommended a lot on comp.compilers too
13:25:42 <Philippa> IIRC tiger gets as far as introducing the idea of unification, which is kinda important
13:26:03 <Smerdyakov> jesse99, but any USENET group without a clear connection to the PL community is going to be dominated by crusty UNIX C hackers.
13:26:07 <Philippa> it's good for building a non-theorists' understanding
13:26:11 <Smerdyakov> jesse99, I would take their recommendations as big warning signs.
13:26:13 <jesse99> yes Smerdyakov
13:26:16 <stepcut> Philippa: the dragon book talks about inference and unification and gives an example of unification in a polymorphic ml-like language
13:26:20 <Riastradh> Smerdyakov, from what I've seen, actually, comp.compilers isn't so bad.
13:26:24 <jesse99> heh
13:26:25 <Lor> A general compiler book cannot devote too much space to types, since typing is not at all an obligatory part of compiling.
13:26:29 <Philippa> stepcut: really? Interesting, I didn't find that poking around my copy
13:26:41 <Philippa> Lor: if a useful part of optimisation, but yeah
13:26:42 <Riastradh> (I haven't ever subscribed to it in general, but I've seen plenty of references to intelligent articles on it.)
13:26:46 <stepcut> Philippa: maybe I have a newer version ??
13:26:47 <jesse99> well, whats the title of the tiger book?
13:26:58 <SyntaxNinja> "Modern Compiler Implementation in ML"
13:26:58 <Riastradh> Lor, not obligatory, but quite necessary for any sort of representation analysis.
13:27:00 <SyntaxNinja> or Java or C
13:27:01 * Aglarion is very much interested in compiler construction, but is lacking skill. Maybe univeristy will change that :)
13:27:02 <Lor> "Modern Compiler Implementation in (ML|C|Java)"
13:27:03 <Philippa> stepcut: unless there's been a recent re-release I really hope not - my copy's fairly recent
13:27:07 <jesse99> thanks
13:27:26 <jesse99> i have the java one (bought it before I got into FP)
13:27:34 <Philippa> is the code legible?
13:27:50 <Philippa> I mean, I didn't want to find out and figured I'd rather learn enough ML to be able to read it than read the author's C or Java...
13:27:51 <stepcut> Philippa: well, the second half of the type checking chapter talks about type unification and polymorphism -- around make 366 i think...
13:27:58 <jesse99> generally I dont care too much about the code in programming books
13:28:01 <ibid> the dragon book does talk about type inference and unification
13:28:01 <Philippa> 'k, fair enough
13:28:09 <ibid> they are revising that book, btw
13:28:14 <jesse99> unless it's some made up assembly language :-)
15:21:30 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]'
15:21:30 --- topic: set by shapr on [Fri Jun 25 02:34:22 2004]
15:21:30 --- names: list (clog FlamingRain cm_ Aglarion jpgil-cl jesse99 cm stepcut Si\ Lemmih roconnor flaw cptchaos arauko CLxyz Fractal cmeme Lunar^ opet Smerdyakov dennisb dv^ ozone Igloo [dan] shawn_ Cale_ thebug mattam Philippa viblo shammahs emu Taaus juhp sorje shrimpx cgibbard jak Joachim dons TheHunter andersca arjanb lelit sisko earthy norpan Hipo polli Lor XTL musasabi flori Matt-W gdsx kosmikus|away wagle ibid kuz edwinb shapr tic eshu lambdabot Riastradh)
15:21:30 --- names: list (skylan keverets asmodai esap ksandstr det blackdog_ sazzle_ isomer)
15:21:42 <earthy> ahhhh ;)
15:21:46 <shapr> yet another great thing to learn here!
15:22:07 <earthy> that is somewhat easier to improve though :)
15:22:45 <Philippa> earthy: you an (ex-)afper?
15:23:04 * Igloo set my estonian keyboard to have a UK keymap and confused Conor by telling him he needed the √§ and √∂ keys (or somesuch) for a shed (which is [])
15:23:10 <shapr> what's an afp-er?
15:23:14 <earthy> no, never been a real afp-er
15:23:14 <shapr> hi Oejet 
15:23:19 <shapr> Oejet: looking for Haskell info?
15:23:19 <earthy> know a couple though. ;)
15:23:23 <Philippa> shapr: somebody vaguely involved in alt.fan.pratchett
15:23:32 <shapr> ah, I see.
15:23:35 <Philippa> vaguely involved might mean "hangs around on #afp and shows up to meets" for example
15:23:40 <Aglarion> well... me english was not so bad in school
15:23:41 <Philippa> pterry is himself an afper, incidentally
15:24:03 <Philippa> earthy: Biblically? The afpdating agency is kinda infamous ;-)
15:24:09 <earthy> aglarion: then why did you loose it? and what is your main tongue? :)
15:24:14 <earthy> not biblically >:P
15:24:18 <shapr> yow
15:24:29 <earthy> actually, I wouldn't even want to know them biblically ;)
15:24:30 <Philippa> lack of practice I'd imagine - I can't do half as much french as I could aged 15
15:24:32 <shapr> I suspect Aglarion speaks german.
15:24:35 <Aglarion> german is main tongue and i have not lost it...
15:24:35 <Igloo> Is "pterry" standard? How did it come about?
15:24:44 <shapr> Igloo: from Pyramids
15:25:07 <Igloo> Ah, fair enough
15:25:07 <Aglarion> i had english in my final examination in school
15:25:16 <Oejet> shapr: I'm looking into writing a parser in Haskell, but I haven't found any "basic" litterature.
15:25:19 <Aglarion> it was 10 out of 15 possible points
15:25:37 <earthy> ah, deutsch... naja, dan ist's halt etwas schwieriger sein Englisch auf die sprunge zu behalten
15:25:41 <shapr> Oejet: I'd suggest the Parsec tutorial, but it really depends on what level of parser you want.
15:25:59 <Aglarion> earthy: warum?
15:26:08 <shapr> ocks√•, vi kan tala mycket svenska har...
15:26:13 * shapr grins
15:26:13 <earthy> oejet: writing a recursive descent parser is virtually trivial
15:26:59 <Aglarion> shapr: ich weiﬂ nicht was du da schreibst aber mindestens ein buchstabe sieht bei mir nicht ganze richtig aus... (grins)
15:27:09 <Aglarion> hehe
15:27:10 <shapr> ich habe keine ahnung
15:27:21 <earthy> aglarion: einfach.... in den Buchladen gibt's fast nichts auf Englisch, im Fersehen ist eigentlich alles auf Deutsch ueberspielt...
15:27:35 <Aglarion> earthy: das stimmt. aber wozu gibst das internet?
15:27:40 <Oejet> earthy: He, he, that word "trivial". Maybe I just haven't figured out what data types to use yet.
15:27:54 <shapr> yah, types are really important in Haskell.
15:28:06 <Aglarion> shapr: i was just telling you i did not understand a word of what u write and that at least one char was not displayed correctly on my screen
15:28:10 <earthy> zum lernen :) und auch da kannste ohne Englisch ab. ;)
15:28:15 <shapr> I can understand that much german :-)
15:28:24 <shapr> plus we use utf-8 on #haskell.se
15:28:26 <shapr> so I use it here too.
15:28:41 <shapr> I was just saying "also, we can speak much swedish here."
15:28:53 <Aglarion> don't even know if my old mirc is capable of utf-8
15:28:54 <earthy> that's an a-circle, right?
15:28:55 <Oejet> Kan I alle sammen tysk og svensk?
15:29:01 <earthy> nope
15:29:11 * earthy doesn't understand swedish, sorry.
15:29:20 <earthy> ;)
15:29:27 <shapr> Oejet: jag kan inte tala dansk!
15:29:30 <shapr> ikke!
15:29:39 <Taaus> "jeg"! 
15:29:40 <shapr> :-)
15:29:42 <shapr> heh
15:29:45 <earthy> ghe ;)
15:30:09 <Aglarion> i even cannot speak dutch... but i should for 2 reasons: 1. it is very close to german and 2. my grandfather is dutch native speaker
15:30:10 * jpgil-cl thought, few days ago, that this used to be a very formal, serious and boring channel. What a mistake!!
15:30:24 <shapr> ik spraak en beetje nederlands
15:30:30 <earthy> s/spraak/spreek/
15:30:34 <shapr> whoops
15:30:37 <earthy> s/en/een/ ;)
15:30:39 <shapr> dang
15:30:54 <shapr> ok, I give up on dutch.
15:31:04 <shapr> jpgil-cl: we're exciting and fun!
15:31:11 <earthy> aglarion: I lost virtually all my knowledge of Portuguese, which I spoke fluently until I was about 8
15:31:12 <shapr> and formal and serious too!
15:31:12 <jpgil-cl> hehe
15:31:23 <Aglarion> my grandfather is flamish (i know this word sounds funny but it just means he comes from a region in belgium)
15:31:32 <shapr> it's 'flemish' in english
15:31:38 <shapr> flanders speaks nifty dutch
15:31:44 <earthy> I also lost almost all my knowledge of Clean, but that was by choice
15:31:56 <Taaus> shapr: Ned Flanders, the Simpsons' neighbour?
15:31:57 <Aglarion> shapr: good to know
15:31:57 <shapr> soft and smooth, rather than the nijmegen-style smokers' dutch
15:31:58 <earthy> Yeah, they have cool expressions
15:32:08 <earthy> nijmegen-style ;)
15:32:20 <shapr> I lived with a girl from nijmegen for awhile.
15:32:25 <Aglarion> whats the meaning of "nifty"?
15:32:27 <shapr> learned some smokers' dutch
15:32:33 <shapr> graag gedann! gezeik!
15:32:39 <earthy> actually, Nijmegen dutch is much softer than (say) Amsterdam dutch ;)
15:32:46 <Taaus> shapr: Apropos nothing, the DarcsWiki has been visited by a spammer. (Albeit a subtle one).
15:32:49 <shapr> uh oh
15:32:52 <shapr> thanks for the heads up
15:32:56 <Taaus> O god! Dars'n byl in my kop!
15:33:09 <earthy> sounds like Afrikaans to me
15:33:22 <Oejet> Een byl?
15:33:25 <earthy> (and it probably should read  Daars 'n byl in my kop!)
15:33:36 <earthy> (There's an axe in my head!)
15:33:38 <shapr> jpgil-cl: this channel is *fun* !
15:33:49 <Taaus> earthy: Yep. I couldn't remember it exactly :)
15:34:03 <shapr> gutenabend Joachim_
15:35:13 <Aglarion> but i can actually understand a bit dutch, since my grandfather always brings packages of minute-soup or whatever with him and i can choose between french and dutch description how to prepare it... since my french is 1^10000 times worse than my english is, i NEED TO read the dutch version
15:35:31 <jpgil-cl> this channels seems Babylon to me. In many senses of "Babylon"
15:35:37 <shapr> DarcsWiki is running on my own personal colocated box. I'm *highly* tempted to setup some black ice for spammers.
15:35:39 <kosmikus> Tere (<-- this much Estonian I've picked up during one week)
15:35:42 <Igloo> What does "Klienten avslutas" mean?
15:35:53 <shapr> client exited
15:35:55 <Aglarion> Anyone here knows Quenya or Sindarin?
15:36:01 <Igloo> Oh, ta
15:36:02 <shapr> I know a little.
15:36:04 <jpgil-cl> Aiya meldo
15:36:12 * Riastradh feels miserably monolingual.
15:36:12 <shapr> I like to write it.
15:36:32 <Lor> shapr, what do you count as black ice? There's nothing much worse than tarpits around.
15:36:40 <Aglarion> meldo comes from mel - friend?
15:36:47 <jpgil-cl> Yep
15:36:50 <Aglarion> ok
15:36:57 <shapr> Lor: something that sets the spammers TCP/IP stack into an illegal state.
15:37:03 <Oejet> Riastradh: Where are you from, since you feel monolingual?
15:37:10 <shapr> that's pretty easy to do to a win32 box remotely.
15:37:14 * Riastradh mumbles 'the US.'
15:37:16 <Aglarion> i once tried to learn "Namarie" by heart
15:37:22 * jpgil-cl is about to leave work (in Chile BTW). See you
15:37:25 <Lor> shapr, how do you do that? exploit bugs in the windows tcp implementation?
15:37:27 <Aglarion> Ai! Laurie lantar lassi surinen.
15:37:32 <shapr> I'm from Alabama. My first language is Hick.
15:37:36 <shapr> Lor: yup.
15:37:37 <Aglarion> Yeni unotime ve ramar aldaron.
15:37:40 <Riastradh> I know a small amount of French & Russian, but that's it.
15:37:42 <Lor> aglaron, you forgot the diaereses.
15:37:48 <Lor> And other diacritics...
15:37:52 <Aglarion> Lor: i know...
15:37:58 <shapr> I just a critic, not even dia.
15:38:23 <shapr> Lor: actually, I guess that's only grey ice, since a reboot fixes it.
15:38:24 <Aglarion> i was lucky when i could remember the latin transcription of it without them
15:38:31 <jpgil-cl> diareses is for those who can misspell words.
15:38:35 <Aglarion> and in tnegwar it all looks completely different though
15:39:01 <jpgil-cl> well, should fly now. Bye.
15:39:02 <Aglarion> tengwar
15:39:08 <shapr> cya jpgil-cl, come back soon!
15:39:11 <Aglarion> bye
15:39:14 <Aglarion> 2late
15:39:33 <Aglarion> SÌ man i yulma nin enquantuva?
15:39:55 <Aglarion> Aiya earendil, elenion ancalima!
15:40:29 <Aglarion> mixing lots of poems here...
15:40:44 <Lor> …ala E‰rendel, engla beorhtast!
15:41:02 <Aglarion> Lor: Thats the old-english original, isnt it?
15:41:07 <Lor> Yeah.
15:41:26 <Aglarion> Drego morn. Lacho calad.
15:42:12 <Aglarion> it's always fun to meet people who know something about tolkien that goes beyond the knowledge the movies give
15:43:12 <Aglarion> A elbereth gilthoniel, silivren penna miriel.
15:44:18 <Aglarion> Actually Aglarion is a misspelled sindarin name
15:44:27 <Aglarion> or misformed..
15:45:15 <Aglarion> It consists or aglar (gloss) and -ion (son of/man of)
15:45:19 <Lor> http://archive.gamespy.com/comics/dorktower/archive.asp?nextform=viewcomic&id=539
15:45:20 * Philippa sorta wishes she could stomache Tolkien's writing these days
15:45:30 <Philippa> would love to be able to read it all again, but my brain grinds to a halt
15:46:24 <Aglarion> i told my family if i ever loose my memory they should force me to read LotR, so i can get the feeling of reading it the first time again
15:46:32 <Lor> :)
15:46:33 <shapr> ha
15:46:34 <shapr> neat
15:47:15 <Aglarion> nothing is better then reading the first chapters where the black rider is following the hobbits and you don't know yet what he is...
15:47:47 <Aglarion> or the first time you read the part when the ring is destroyed... Cuio i pheriain annan! Aglar ni pherianath!"
15:48:40 <Aglarion> Lol @ Lor for comic
15:49:23 <Aglarion> nice comics indeed
15:53:18 <Aglarion> wb Philippa
15:54:29 <Philippa_> re
15:57:06 <Aglarion> I think its time to say: "Namarie" which is Quenya for "Farewell". And with Farewell I mean see you later. Good night.
15:57:11 <shapr> g'night
15:57:13 <shapr> come back soon!
15:57:19 <Aglarion> as soon as i can.
15:58:44 <Aglarion> but i'll have to work tomorrow... "civil service" they call it... but slavery they mean.
15:58:56 <Aglarion> bye
15:59:05 <shapr> ah
15:59:06 <shapr> bye!
15:59:11 <earthy> ghe
15:59:20 <earthy> well... yeah, bedtime
15:59:29 <earthy> 6 hours left
16:51:31 <shapr> g'day Pseudonym 
16:51:48 <Pseudonym> G'day.
17:15:03 <shammahs> morning all.
17:28:08 <SyntaxLaptop> does anyone know of preprocessors that can't handle .lhs files? I think happy ? haddock?
17:28:27 <SyntaxLaptop> actually haddockisn't really a preprocessor, but you know what I mean.
18:11:56 <Leimy> I got a working "character counter" using a State Monad
18:12:04 <Leimy> I'll admit it's not terribly useful
23:42:39 <musasabi> morning
23:52:20 <musasabi> When reading the Control.Concurrent.Chan source I stumbled upon:
23:52:22 <musasabi> writeList2Chan ch ls = sequence_ (map (writeChan ch) ls)
23:52:42 <musasabi> Why is it so instead of:
23:52:53 <musasabi> writeList2Chan ch ls = mapM_ (writeChan ch) ls
