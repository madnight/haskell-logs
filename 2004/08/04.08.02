02:02:19 <bringert> morning #haskell
02:02:36 <bringert> shapr: aarne is here now, will ask him about the dictionary
02:12:29 <bourbaki> hi
02:24:09 <heatsink> hello bourbaki
04:19:52 <shapr> good morning #haskell!
04:22:01 <shapr> what's going on?
04:24:20 <Lemmih> I'm on my way out to unicycling with my laptop.
04:24:39 <Lemmih> And I just rewired my room.
04:26:24 <shapr> unicycling with your laptop.... that sounds very cool.
04:46:22 * shapr bounces cheerfully
04:51:00 <norpan> hmmm
04:51:25 <norpan> darn
04:51:30 <norpan> it's starting to rain
04:51:43 <norpan> and i had just gone out to enjoy the sun
04:52:49 <jao> as we say in spain: it never rains to the pleasure of everybody (or something like that) :)
04:53:03 <norpan> the rain in spain stays mainly in the plain
04:53:40 <jao> hahaha... "la lluvia en sevilla es una maravilla"
05:27:44 <shapr> so, anyone written any cool code lately?
05:32:52 <shapr> hej bringert 
05:32:59 <bringert> hej
06:10:45 <andersca> why is a closure called a closure?
06:12:44 <thebug> andersca: check this out -> http://en.wikipedia.org/wiki/Closure_%28computer_science%29
06:12:57 <goron> There was a Haskell library, that implements Linux commands and had a lot of combinators, such that you can use them in Haskell as an alternative to Bash. I only forgot it's name. What is it?
06:13:13 <andersca> thebug: thanks
06:13:18 <thebug> no problem :)
06:13:35 <thebug> there's also a wikipedia entry for Closure (mathematics)
06:16:37 <goron> I already know it again: it's called hash...jammie...
06:46:52 <SyntaxNinja> Igloo: any luck finding a place to host HE?
06:48:47 * Igloo has been away for the weekend so hasn't looked into it, sorry. But you can just do it in your home directory on people if it's urgent
06:49:14 <SyntaxNinja> I don't want to keep moving it around, that's all.
06:49:24 <SyntaxNinja> there's really no urgency.
06:49:50 <SyntaxNinja> well, depends: the old one is going to go away before too long, and I would like to get cabal, wash, and wxhaskell into the new one.
06:50:35 <goron> Has anyone used Text.Regex before?
06:51:53 <goron> I was playing with it, but a simple regex as *.html does not work. 
06:52:04 <goron> I want to know what syntax it uses.
06:53:27 <bringert> it uses POSIX regexps, IIRC
06:53:55 <goron> bringert: But why doesn't "*.html" work then? 
06:54:05 <goron> bringert: In the docs it says POSIX, yes..
06:54:23 <bringert> "*.html" is is pathname glob, not a regexp, I believe
06:54:52 * bringert can never remember POSIX regexp syntax
06:54:55 <goron> bringert: Ok, will look some better. Will be back.
06:55:00 <keverets> .*\.html
06:55:02 <goron> bringert: Thanks
06:55:50 <keverets> or \.html$
06:56:11 * bringert likes perl regexps better
06:56:30 * bringert realizes he said that he likes something from perl in #haskell
06:57:20 <shapr> heretic!
06:57:34 <goron> bringert: You are banned :0
06:58:07 <goron> Main.hs:16: lexical error in string/character literal
06:58:35 <goron> haskellFilesRegex = mkRegex "\.hs$"
06:59:00 <goron> How can I fix this? Is it the cpp preprocessor?
06:59:11 <shapr> nah, you want \\
06:59:22 <goron> shapr: Why?
06:59:28 <shapr> it's standard string escaping
06:59:43 <goron> shapr: :?
06:59:44 <shapr> if you use escapes like \n then the slash has to be special also.
07:00:12 <goron> shapr: So I want \n in PHP/Perl then in Haskell, it's \\n?
07:01:03 <shapr> no, if you want a literal slash character in any lang that uses \n you need \\
07:01:32 <bringert> goron: the problem is that there are two levels of escaping at work here, first haskell's own, then that of POSIX regexps
07:02:08 <bringert> you want to give Text.Regex the string containing a backslash and then a dot
07:02:18 <goron> shapr: Ok, I start to remember somethings now... Thanks. I will try it. 
07:02:21 <SyntaxNinja> hey shapr hope it's OK that I used haskell-libs bugtracking system for cabal?
07:02:21 <bringert> to write that string in haskell, you must escape the backslash
07:02:51 * bringert is also writing regexps
07:02:59 <bringert> what the hell is wrong with this one: ((?[A-Z\xC0-\xD6\xD8-\xDEa-z\xDF-\xF6\xF8-\xFF0-9'_]*)):((?(?[A-Z\xC0-\xD6\xD8-\xDEa-z\xDF-\xF6\xF8-\xFF0-9'_]|[\{\}/\.!])*))(\[(?\[\d+(?,\d+)*\])*\])\.\s*((?(?[A-Z\xC0-\xD6\xD8-\xDEa-z\xDF-\xF6\xF8-\xFF0-9'_]|[\{\}/\.!])*))\s*->\s*((?(?[A-Z\xC0-\xD6\xD8-\xDEa-z\xDF-\xF6\xF8-\xFF0-9'_]|[\{\}/\.!])*)*)
07:03:02 <shapr> SyntaxNinja: of course
07:03:05 <SyntaxNinja> bringert: heh
07:03:32 <goron> I wrote those when I didn't understand parsing lol
07:04:08 * bringert is trying to parse a simple regular language
07:07:21 <goron> Ahh, logical errors... That's why it's not working....
07:08:08 <bringert> ok, got it, non-capturing groups begin with (?:, not (?
07:10:03 <bourbaki> hi
07:10:20 <shapr> y0
07:13:09 <bourbaki> http://rafb.net/paste/results/WoAYAj75.html
07:13:19 <bourbaki> can someone help me with that error in line 25?
07:14:00 <bourbaki> tells me that the number of args is variable
07:14:18 <ustenzel> bourbaki: the error is actually in line 26.
07:14:30 <ustenzel> bourbaki: and in 27 through 30, too.
07:14:50 <bourbaki> oh strange
07:14:56 <goron> bourbaki: The compiler is correct :)
07:15:05 <ustenzel> not at all, the compiler just can't tell.
07:15:17 <goron> bourbaki: Removing the Tile helps:)
07:15:28 <ustenzel> bourbaki: you want getSig to take two arguments.  How many do you match in line 26?
07:16:05 <goron> bourbaki: Ignore what I said. 
07:16:16 <bourbaki> ustenzel 2 of corse
07:16:19 <bourbaki> course
07:16:42 <ustenzel> bourbaki: No, you don't.  Remember, function application is written without parens in Haskell.
07:17:17 <bourbaki> Tile is no function though
07:17:28 <ustenzel> but close enough.
07:17:33 <goron> bourbaki: Yes, you need () around the pattern.
07:18:01 <bourbaki> oh so around the Tile also?
07:18:07 <goron> bourbaki: Yes
07:18:19 <bourbaki> dang :)
07:18:27 <goron> My matching gives me Just [] Does anyone knows why?
07:18:46 <ustenzel> bourbaki: if you write "getSig Tile (...)" the compiler sees getSig with two arguments.
07:19:06 <bourbaki> ok
07:19:13 <ustenzel> bourbaki: if Tile should apply to the tuple, it is "getSig (Tile (...))"
07:23:22 <goron> I think I understand why I get an empty list of subexpressions: there is only one expression, and it's not a subexpression :) lol. I hate non intuitive systems.... Although, I like correct systems...
07:29:26 <shapr> SyntaxNinja: haskell-libs is for anything that contributes to haskell usefulness
07:29:56 <SyntaxNinja> :)
07:31:02 * Igloo puts SyntaxNinja and shapr into haskell-libs
07:32:17 * shapr grins
07:32:48 * SyntaxNinja puts linux into haskell-libs
07:32:52 <shapr> yup
07:33:05 <shapr> tasty linux, mmm
07:39:05 <SyntaxNinja> so my cell phone keeps breaking; it's a treo 270.  maybe I can replace it w/ a linux smartphone next.
07:39:46 <shapr> oh good idea
07:40:43 * thebug pictures SyntaxNinja trying code on a cell phone
07:40:46 <thebug> hehe
07:41:06 <goron> Then you can call for free :)
07:41:18 <SyntaxNinja> haha
07:41:34 <shapr> I want a laptop/PDA 'infrastructure' where separate pieces communicate.
07:43:13 <thebug> nono, it's a -smart-phone, it codes for you :)
07:43:22 <shapr> aha
07:45:10 <goron> Where can you buy these? I need 100...
07:46:17 <thebug> <slasdot>Imagine a beowulf cluster of those!</slashdot>
07:46:45 <goron> lol
07:47:45 * bringert came up with a plan for free sms-like text messages between cell phones this weekend
07:47:59 <bringert> but it's a little impractical
07:48:48 <bringert> hack the phone to call the recipient and hang up after 1 or 2 signals, encode messages using morse code 1 = ., 2 = -
07:49:00 <bringert> hack the recipient phone to decode
07:49:10 <bringert> or just learn morse code and do it manually
07:49:51 <bringert> sending / receiving is a little slow though
07:50:13 <bringert> and it will probably get annoying having the phone ring 500 times just to get a single message
07:51:06 <bringert> although the program could recognize the sender and not have the phone ring
07:51:43 <goron> You could overload the phone network that way, when a zillion people would do it :)
07:51:57 * thebug wouldn't want to be bringert-style sms spammed in that case
07:52:06 <thebug> oy!
07:53:05 <bringert> and the telco would start cutting off your access for abusing the network
07:55:04 <goron> bringert: Then you sue them :)
07:55:29 <goron> bringert: Oh, wait, they will sue you... bad idea ...
07:55:51 <Igloo> Certainly in the UK you are explicitly not allowed to do that, so wouldn't be able to sue them
07:57:26 <bringert> there is a swedish 3G cell phone company that gives you free video calls to other people on the same network
07:57:38 <bringert> unlimited free video calls
07:58:02 <bringert> however, the fine print says that it's only for normal values of unlimited
07:58:07 <Igloo> Are voice calls also free?
07:58:25 <Igloo> heh
07:58:25 <bringert> well, just cover up the camera :P
07:58:26 <goron> Igloo: Not anymore in my country
07:58:43 <Igloo> Well, I was just thinking that i 
07:58:43 <bringert> voice calls are also free
07:59:01 <Igloo> if they weren't then they'd just be hammering their network as everyone would use video pointlessly
07:59:07 <Igloo> Ah, OK
07:59:18 <goron> My regexs are finally working :-)
07:59:35 <SyntaxNinja> I wish the new treos didn't have a camera and cost $200 less
08:07:14 <bourbaki> can i have different type signatures bound to the same function name?
08:08:18 <Igloo> Only by having the function in a class
08:08:45 <esap> put those in different modules, and then shuffle it via import declarations.
08:09:42 <bourbaki> ok but something like ie foobar :: a -> Int
08:09:55 <bourbaki> that would be some polymorph function right?
08:13:25 <Igloo> polymorphic function, yes
08:13:42 <bourbaki> but its independent of the type right?
08:13:59 <bourbaki> i cant do some stuff depending on the type of that a
08:14:05 <Igloo> Right
08:14:09 <Igloo> Unless you put it in a class
08:14:17 <bourbaki> except it was data right?
08:14:19 <Igloo> Or just have a class constraint
08:14:23 <Igloo> huh?
08:14:29 <bourbaki> ie
08:15:14 <bourbaki> data foobar = Int Int | Float Float
08:15:22 <bourbaki> and then in the implementation of the function
08:15:29 <bourbaki> (Int x) = ...
08:15:34 <bourbaki> (Float x) = ...
08:15:36 <Igloo> Right
08:15:58 <norpan> or use Data.Dynamic
08:16:18 <bourbaki> norpan what does that do?
08:16:46 <norpan> dynamic type checking
08:16:59 <bourbaki> the funny thing is i never finish any of my projects completely cause i discover more and more funny things along each :)
08:17:04 <norpan> so you can have foobar :: Dynamic -> Int
08:17:50 <bourbaki> why is that that you cant have two functions under the same name if the type signature is different?
08:17:59 <bourbaki> is that a feature?
08:18:08 <norpan> yes, feature
08:18:09 <Igloo> Type inference would be ambiguous
08:18:13 <norpan> so that you can infer types
08:18:47 <bourbaki> Igloo really?
08:18:55 <Igloo> You already get problems with things like show . read, but it would be worse
08:19:04 <ustenzel> bourbaki: Haskell is not C++.  Or is there any other language out there that plagues itself with unrestricted overloading?
08:19:18 <bourbaki> isnt that something you can do in c++?
08:19:27 <bourbaki> heh :)
08:19:30 <bourbaki> ok
08:20:07 * esap thinks you might be able to use functional dependencies to 'simulate' the C++ way of overloading. Though it's not pretty either way.
08:20:35 <Smerdyakov> Forget that. Haskell needs Turing machine support. Then it will be the most powerful language ever.
08:21:11 <esap> Turing machine support? I thought it already had that one, modulo space constraints.
08:21:24 <shapr> Smerdyakov: good idea, write it!
08:21:30 <Igloo> What space constraints? We have infinite lists
08:21:41 <Igloo> Just because your hardware may be lacking isn't Haskell's fault
08:21:51 <Igloo> Or your compiler
08:22:04 <esap> igloo: right, exactly my point.
08:22:04 * SyntaxNinja takes Igloo's hardware away
08:22:33 <thebug> well, no infinite lists for Igloo now
08:22:35 <Igloo> That's OK, I just run all my code on my brain anyway
08:22:39 * esap doesn't have hardware where you could add more memory without rebooting.
08:23:25 <shapr> some new mobos do have that feature
08:23:28 <Smerdyakov> Such hardware for humans is called "television."
08:23:42 <Igloo> IBM z-series has been able to do it for a while
08:24:19 <shapr> interesting discussion on lwn.net about hot-swap ram support for linux
08:24:25 * esap also doesn't have hardware where there wasn't any limit on how much memory you can add. Address space is finite.
08:24:47 <Igloo> You don't have hardware a tape drive can be attached to?
08:25:30 <esap> tape drives do not produce infinite memory [I can't even buy enough tapes for that...]
08:26:03 * esap is resource-constrained.
08:26:10 <bourbaki> arent there just a infinitely countable many atoms?
08:26:18 <bourbaki> in the universe that is
08:26:26 <Igloo> There are a finite number, no?
08:26:28 <Smerdyakov> Tape drives _do_ provide infinite memory if you keep swapping out the tapes and assume infinite matter in the universe. :)
08:26:32 <Igloo> 2^80 or something rings a bell
08:26:40 <bourbaki> they are countable its like |M
08:27:29 * esap thinks garbage collection is the only viable way of simulating infinite memory.
08:27:39 <bourbaki> so if you would need more elements to store stuff then there are there is no possibility of infinite memory
08:28:13 <Igloo> Ah, looks like 10^80
08:28:37 <bourbaki> Igloo 10^80 atoms?
08:28:47 <Igloo> Give or take a few, yeah
08:29:01 <shapr> esap: I was wondering whether non-cache-coherent NUMA could benefit from that
08:29:13 <bourbaki> oh :) well so infinity is some not renderable concept here anyway ;)
08:31:19 <goron> The is no syntax to use names defined in a do block in a where clause, right?
08:32:05 <Igloo> Right
08:32:14 <Igloo> You want a let in your do statement list
08:32:39 <esap> shapr: probably yes. Though I'm not that sure it's efficient on current hardware.
08:32:58 <goron> Igloo: I will check it.
08:32:59 <shapr> it can't be much worse than the cost of cache-coherency
08:33:37 <shapr> hardware cache coherency costs about ten percent of the total performance.
08:34:53 <goron> Igloo: I don't think that it will work. Care to look at the code and suggest an alternative using let?
08:36:21 <RussellOConnor> bourbaki: I read somewhere that the maximum amount of information contained inside a volume with surface area A is A/(4p), where p is the planck area.
08:36:50 <Igloo> Put it on the web somewhere
08:36:59 <goron> Igloo: Ok
08:37:05 <RussellOConnor> Something about holographic information limit.
08:38:22 <RussellOConnor> Anyhow, counting atoms is probably not enough since I believe you can store a bit in the spin of an electron.
08:38:40 <shapr> I was just wondering that...
08:39:15 * shapr googles for planck area
08:39:31 <goron> Igloo: http://authors.aspalliance.com/aylar/PasteCode.aspx code is 2889
08:40:25 <Igloo> Put "let path = addSlash file currentDir" after the second line
08:40:35 <Igloo> and remove the equivalent line from the where
08:40:48 <bringert> damn, it's raining hard outside
08:40:50 <goron> Igloo: Does that work? That would be cool :)
08:40:57 <Igloo> You could alwo move the other line from the where into the let if you wanted
08:40:59 <shapr> bringert: just clouds here
08:41:09 <shapr> I think I may go unicycle before it rains.
08:41:40 <bringert> I can see skater kids floating by
08:41:46 * shapr grins
08:42:02 <shapr> "when the skateboard becomes a surfboard"
08:43:04 <bringert> "you know you should have gotten on board that animal love boat"
08:43:21 <goron> Igloo: currentDir is still out of scope.
08:44:15 <Igloo> Let me see the code
08:44:18 <bringert> this java code is so ugly it's amazing
08:44:41 <Igloo> Oh, when I said after the second line I wasn't counting the "do" lnie
08:44:55 <bourbaki> RussellOConnor :)
08:44:59 <Igloo> After the lien that binds currentDir
08:45:05 <goron> Igloo: 2890
08:45:10 <bourbaki> RussellOConnor yet its a finite set
08:45:46 <bourbaki> i always wondered about that tychoff paradoxon in topology (hope that was the right thing) where you can construct two shperes of one
08:46:12 <RussellOConnor> The Banach-Tarski paradox
08:46:16 <bourbaki> ah right
08:46:23 <Igloo> do val<-d...
08:46:23 <Igloo>    currentDir<-...
08:46:23 <Igloo>    let path = addSlash file currentDir
08:46:23 <Igloo>    if ...
08:46:44 <goron> Igloo: How stupid of me...
08:46:53 <bourbaki> or the hilbert hotel stuff like that makes me believe that we live in a finite world :)
08:46:57 <goron> Igloo: Thanks
08:46:58 * Igloo wasn't clear
08:47:01 <Igloo> Note no "in"
08:47:15 <bourbaki> maybe jesus was able to use the banach tarski paradox to build new bread ;)
08:47:22 <RussellOConnor> It's dumb.  It uses the axiom of choice to ``construct'' a sets without volume.
08:47:27 <RussellOConnor>  I use the word construct loosely, as I am a constructivist and will not longer have anything to do with such set-theory silliness.
08:47:41 <bourbaki> heh
08:47:43 <RussellOConnor> Hilbert Hotel is more reasonable.
08:48:00 <bourbaki> yes but isnt that quite the same
08:48:13 <bourbaki> you make kind of two interleaved hotels of a single one
08:48:13 <shapr> fooey, it's already raining.
08:48:20 <RussellOConnor> suppose s is an infinite list in haskell.  We and add one more element and make a:s
08:48:23 <RussellOConnor> :)
08:48:44 <RussellOConnor> @type interleave
08:48:45 <lambdabot> bzzt
08:48:49 <RussellOConnor> oh
08:49:09 <bourbaki> well i dont believe in infinity :)
08:49:17 <Igloo> @type Lists.interleave
08:49:19 <lambdabot> bzzt
08:49:19 <Igloo> @type List.interleave
08:49:21 <lambdabot> bzzt
08:49:35 <Igloo> @type List.intersperse
08:49:37 <lambdabot> List.intersperse :: forall a. a -> [a] -> [a]
08:50:07 * Igloo got confused
08:50:09 <Igloo> Or did you really want interleaving?
08:50:23 <RussellOConnor> I thought there was a standard interleave, but maybe not.
08:51:25 <RussellOConnor> bourbaki: I believe in infinity, I just don't understand it.
08:51:46 <Smerdyakov> What does it mean to "believe in infinity"?
08:51:53 <bourbaki> well i mean what is infinite?
08:52:00 <bourbaki> i mean in our world
08:52:04 <RussellOConnor> Smerdyakov: I have no idea.
08:52:07 <bourbaki> im not talking about the concept
08:52:37 <Smerdyakov> RussellOConnor, but you're sure you do it, all the same? :D
08:53:05 <RussellOConnor> Infinity has something to do with there always being a successor to a natural number.
08:53:39 <bourbaki> type Nat = 0 | Suc Nat
08:53:53 <goron> You mean data lol
08:53:56 <RussellOConnor> I believe in the natural numbers.  Although I'm not sure what that entails.
08:54:01 <bourbaki> :) yeah sry
08:54:13 <bourbaki> yes but thats a concept
08:54:28 <RussellOConnor> I don't have faith in ZFC.
08:54:38 <bourbaki> the same applies with the density of |R i dont think that you will find something like that in the real world
08:54:50 <bourbaki> zfc?
08:55:09 * Igloo wonders if   interleave xs ys = catMaybes $ zipWith mplus (intersperse Nothing (map Just xs) ++ [Nothing]) (Nothing:intersperse Nothing (map Just ys))   can be simplified
08:55:20 <RussellOConnor> ZFC = Zermelo-Frankel Axiomatic Set Theory with the Axiom of Choice
08:55:30 <bourbaki> :)
08:56:18 <RussellOConnor> It is the standard (and ridiculous) foundation of 20th century mathematics.
08:56:56 <bourbaki> why is that?
08:56:58 <RussellOConnor> Igloo: yes.
08:57:08 <bourbaki> was it after or before that hilbert thing?
08:57:42 <ustenzel> RussellOConnor: Natural numbers can easily be defined in ZFC.
08:57:48 <RussellOConnor> bourbaki: It happened at the same time.
08:58:10 <RussellOConnor> ustenzel: So can a lot of things.
08:58:36 <ustenzel> RussellOConnor: which makes it quite a bit less ridiculous :-)
08:58:41 <RussellOConnor> ustenzel: each thing more wacky than the last. *l*
08:58:43 <bourbaki> heh
09:00:11 <RussellOConnor> ustenzel: It's things like large ordinals that concern me.
09:00:53 <RussellOConnor> You can prove a lot of theorems in ZFC.  I wouldn't be surprised if one day they prove False.
09:02:06 <ustenzel> RussellOConnor: Large ordinals?  Like different kinds of infinities?
09:02:50 <RussellOConnor> yeah, the really big ordinals, like perhaps the inaccessible ones.
09:04:03 <ustenzel> even they make sense sometimes.  there are surreal numbers that make even less sense and are still applicable to game theory.
09:06:03 <RussellOConnor> Igloo: interleave xs ys = foldr (\(a,b) l -> a:(b:l)) [] (zip xs ys) ?
09:06:36 <Igloo> Ah, yes, good point
09:07:04 <RussellOConnor> Igloo: I'm sure we can do even better.
09:08:18 <RussellOConnor> ustenzel: I've only seen game theory used for finite games, which don't make much use of the surreal number system.
09:10:23 <ustenzel> RussellOConnor: they do.
09:10:53 <ustenzel> RussellOConnor: there are games where you express the advantage of one player over the other as a natural number.
09:11:52 <ustenzel> RussellOConnor: in certain situations very strange numbers crop up... infinitely small numbers that are still greater than 0.  infinitely even smaller number still above zero, etc.
09:12:40 <RussellOConnor> Igloo: interleave xs ys = concat (List.transpose [xs,ys])
09:14:52 <RussellOConnor> ustenzel: I'm fine with finite games.  These surreal numbers can even be expressed in Haskell.  I wrote a library to compute with them once for my game theory class.
09:15:14 <RussellOConnor> ustenzel:  It's when the games become infinite I begin to get worried.
09:15:25 <ustenzel> RussellOConnor: see, strange things do make sense sometimes :)
09:22:51 <bringert> sun is shining again
09:23:03 <bringert> weather is strange
09:23:34 <andersca> makes you wanna move
09:23:37 <andersca> your dancing feet
09:24:20 <bringert> can't keep up
09:24:23 <goron> Why has Linux got a . file that points to the current dir?
09:24:26 <bringert> this fine poetry
09:25:04 <bringert> it's for example useful to give you a way to refer to the current dir
09:25:26 <SamB> goron: doesn't DOS also?
09:25:33 <SamB> and by extension windows?
09:25:40 <goron> SamB: yes
09:25:59 <thebug> SamB: it's just not out in the open like in the unix world, iirc
09:26:09 <SamB> thebug: oh?
09:26:25 <bringert> say you want to refer to the verion of the ls command sitting in you current dir
09:26:26 <Igloo> SyntaxNinja?
09:26:37 <thebug> SamB: dunno, does dir display it?
09:26:40 <thebug> hmm
09:26:45 <goron> bringert: But it's not usefull when you want to recursively something to all dirs. You have to check on it, otherwise you go to infinity :)
09:27:02 <goron> bringert: And guess what: I didn't check it...
09:27:16 <bringert> before you try again, also check for ..
09:27:26 <goron> bringert: I know
09:27:33 <goron> bringert: But thanks
09:27:52 <bringert> and be careful with symlinks
09:27:57 * thebug fires up win2k to see what it says
09:28:13 <SyntaxNinja> hi Igloo
09:28:25 <bringert> wasn't there a thread about directory traversal on one of the haskell lists recently
09:28:31 <goron> bringert: Can you check on isSymlink in Haskell?
09:28:38 <goron> bringert: Don't know.
09:28:40 <SyntaxNinja> bringert: yeah
09:28:40 <Igloo> The example now says "Exposed-Modules: A, B, B.C", which isn't the modules used in teh example
09:28:56 <Igloo> Also, shouldn't the Angela.Internals modules also be listed?
09:29:16 <SamB> thebug: ls doesn't show those either, by default, does it?
09:29:23 <SamB> I certainly do not see them.
09:29:25 <bringert> @type System.Posix.Files.isSymbolicLink
09:29:26 <lambdabot> System.Posix.Files.isSymbolicLink :: System.Posix.Files.FileStatus
09:29:26 <lambdabot> 				     -> Bool
09:29:41 <goron> You are too kind :)
09:30:27 <bringert> and hard links to directories, but linux doesn't allow those, right?
09:30:30 <thebug> SamB: ls -a
09:30:43 <SyntaxNinja> Igloo: yeah, that should be fixed.
09:31:14 <SyntaxNinja> I mean I should fix that
09:31:53 <SamB> unfortunately, I can't get the freedos 'dir' to display a usage message
09:31:56 * Igloo AFKs
09:31:57 <bringert> @type Control.Monad.Fix.fix
09:31:58 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
09:32:06 <bringert> SyntaxNinja: there you go
09:32:39 <SyntaxNinja> bringert: thanks.
09:44:04 <SyntaxNinja> oh no! fedora is catching up! we need to fix haskell-experimental soon!
09:58:38 <Cale> what? forall a. (a -> a) -> a ?
09:59:38 <Cale> what's the definition for fix?
10:01:58 <Cale> ah, I see - it mostly gives bottom
10:03:10 <SamB> fix f = x where x = f x --?
10:04:10 <SamB> I wonder what kind of a proof that represents?
10:04:29 <Cale> ah, so it is the usual fix -- somehow I thought for a moment that a value of type (t -> t) -> t couldn't be defined
10:04:47 <ustenzel> wait a minute... the monadic fix should mention the monad somewhere!
10:04:48 <SamB> a reasonable thing to think.
10:05:22 <SamB> it does, after all, absolutely require laziness
10:05:48 <Cale> mfix :: (a -> m a) -> m a
10:06:10 <ustenzel> looks better.
10:08:03 <SamB> I guess fix is just there to simplify some of the implementations?
10:10:20 <ustenzel> @type Control.Monad.Fix.mfix
10:10:21 <lambdabot> Control.Monad.Fix.mfix :: forall m a.
10:10:21 <lambdabot> 			  (Control.Monad.Fix.MonadFix m) =>
10:10:21 <lambdabot> 			  (a -> m a) -> m a
10:10:38 <ustenzel> Hm.  possibly.
10:36:36 <bringert> time to go home before it starts raining again
11:07:08 <goron> How can I solve this: *** Exception: getFileStatus: invalid argument (Too many levels of symbolic links)?
11:08:01 <Riastradh> Remove some levels of symbolic links, perhaps?
11:08:56 <Riastradh> Or, seriously, you're probably getting into a loop on the file system whereby you're going into a symbolic link that is to an ancestor of itself.
11:09:18 <goron> I am only not sure what is meant by a "level". Is it this: a -> b -> c -> d and then a lot. Possibly looping?
11:11:50 <goron> I am not looping. This is the code (I hope I won't be banned)....
11:11:53 <goron> getAllFilesInADir::FilePath->IO [FilePath]
11:11:53 <goron> getAllFilesInADir dir = do              
11:11:53 <goron>                            files<-(liftM $ filter normal) $ getDirectoryContents dir   
11:11:54 <goron>                            files<-return $ map (\x->dir++"/"++x) files
11:11:54 <goron>           		   files<-filterM isSymLink files 
11:11:55 <goron>                            --files<-(liftM concat)$mapM getAll files 
11:11:55 <goron>                            putStrLn $ show files
11:11:57 <goron>                            return files
11:12:25 <goron> The blocks are dashes.
11:16:44 <goron> That line with the blocks isn't commented...
11:19:00 <RussellOConnor> goron, you need to handle exeptions.
11:19:13 <RussellOConnor> hmmm
11:19:27 <goron> RussellOConnor: I thought that was an option and no obligation?
11:20:00 <RussellOConnor> It might be helpful to find out which file and which command is throwing the exception.
11:20:32 <goron> RussellOConnor: Have you ran it on your machine?
11:20:48 <RussellOConnor> I don't have a Unix environment.
11:21:56 <goron> RussellOConnor: It's the root dir of haddock.
11:22:18 <goron> RussellOConnor: I will try to find the exact file. 
11:22:25 <RussellOConnor> Windows has no sym-links
11:22:32 <goron> RussellOConnor: I know
11:28:17 <goron> RussellOConnor: I had made some vague symlink to tar xzf, and I think there was something broken. Now it works. 
11:28:59 <RussellOConnor> Perhaps your code should be able to handle strange sym-links without crashing?
11:29:10 <RussellOConnor> depending on your goals.
11:35:06 <goron> RussellOConnor: I think it's a hardlink. When I do ls, it gives a blue file. But I want to know what it it. ls -o maybe.
11:36:16 <RussellOConnor> ls -a
11:36:19 <RussellOConnor> er 
11:36:21 <RussellOConnor> ls -l
11:36:31 <RussellOConnor> ls -al
11:36:47 <goron> RussellOConnor: It's a symbolic link. It's only to a non-existent file. 
11:37:23 <RussellOConnor> Which haskell IO command is causing the exception?
11:38:32 <goron> RussellOConnor: getFileStatus
11:39:09 <RussellOConnor> hmm, that wasn't in your code.
11:39:16 <goron> RussellOConnor: Is this standard behaviour?
11:39:33 <RussellOConnor> I don't know the semantics of getFileStatus
11:39:38 <goron> RussellOConnor: Now it is.
11:40:40 <goron> RussellOConnor: It's badly documented. 
11:43:58 <goron> RussellOConnor: I could check whether the file exists. But I thought a symlink was also treated as a file. 
12:01:14 <goron> RussellOConnor: Well, catching it also doesn't work, because I don't know any value of type FileStatus. 
12:29:52 <bringert> grr, bringert has had enough of LaTeX for a while
12:30:39 <bringert> why did HW decide to change which ASM style to use a week before the final deadline
12:30:45 <bringert> eh, ACM
12:31:54 <bringert> and why does the LCNS style use twice as many pages as the SIG one?
12:32:01 <bringert> the tough questions in life
12:35:18 <goron> Why is making a real-world program much harder than an university project?
12:35:43 <SyntaxNinja> goron: because someone else has to be able to use it?
12:35:52 <SyntaxNinja> "recompile" isn't an acceptable user interface? ;)
12:37:36 <goron> SyntaxNinja: Well, the problem is that to do X, I need Y and for Y I need Z etc. I am compiling half the world to do something, of what I thought of as being trivial.
12:38:20 <SyntaxNinja> goron: you aren't talking about Haskell programs are you? ;)
12:38:55 <goron> SyntaxNinja: Well, as a matter of fact I am... :( Don't tell anyone...
12:39:06 <SamB> what stuff do you need to recompile?
12:39:38 <goron> SyntaxNinja: Well, I now have hsunix, which compiles (that's a wonder).
12:39:46 <SamB> oh, and sometimes, recompile isn't actually an unacceptable ui.
12:40:09 <goron> SyntaxNinja: But when I use it with ghci it crashes...
12:40:55 <goron> SyntaxNinja: I just finished c2hs, which was a dependency of hsunix (that's why it probably isn't working)
12:41:05 <SyntaxNinja> SamB: that was my point
12:41:23 <goron> SyntaxNinja: And I do this all to make a program, that can compile all of the CVS fptools.
12:41:24 <SyntaxNinja> goron: did you use the -g flag when you installed it w/ ghc-pkg?
12:41:43 <goron> SyntaxNinja: I have not the slighest idea. 
12:41:43 * SyntaxNinja has never had to compile cvs fptools.
12:41:57 <goron> SyntaxNinja: That's with a t
12:42:13 <goron> SyntaxNinja: What's the -g flag?
12:42:39 <SyntaxNinja>  -g             --auto-ghci-libs          automatically build libs for GHCi (with -a)
12:42:45 <SyntaxNinja> (where -a is add)
12:43:06 <goron> SyntaxNinja: That might be the issue..thanks..
12:43:31 <SyntaxNinja> np
12:48:32 <goron> SyntaxNinja: Hsunix doesn't make a package. 
12:50:03 * SamB wishes A4 styles would fit better on us-letter paper...
12:50:31 <SamB> hmm, I wonder if A4 would fit in my printer?
12:52:05 <goron> How can you search via the commandline in Linux? With find it looks like I can't find recursively. And with locate, you have to create the entire database. 
12:53:19 <SamB> goron: of course you can find recursively!
12:53:41 <SamB> thats what find is for: recursion
12:53:52 <goron> SamB: well then I overlook some option
12:53:59 <goron> SamB: in --help
12:54:16 <SamB> goron: it always recurses
12:54:34 <SamB> although you could tell it to only recurse a certain number of levels
12:55:51 <goron> SamB: Yes, I just read that, but I can't do find Main.hs. What's the syntax of EXPRESSION?
12:56:29 <SyntaxNinja> goron: find /start/location -name "*.hs"
12:56:55 <SyntaxNinja> find . -name Main.hs
12:58:00 <SyntaxNinja> (and that answers your previous question about the "." :) )
12:59:03 <goron> SyntaxNinja: lol. The man page is somewhat more clear. I most of the times use only --help. But that has a but too many bits/letter.
12:59:09 <goron> Thanks
13:01:14 * goron wonders how long this will take...searching +80GB....
13:01:54 <SyntaxNinja> goron: you're searching your entire hard drive?
13:01:57 <SyntaxNinja> that's what the find database is for :)
13:02:05 <SyntaxNinja> er locate
13:03:11 <CrewdenX> or would be, if locate had some useful predicates.
13:03:17 <goron> But it's a new file, if it does exist. 
13:03:32 <goron> And updating locate (updatedb), takes longer.
13:04:24 * SyntaxNinja takes this opportunity to upldate the DB on his laptop
13:05:23 <goron> A couple of weeks ago I was playing UT2004, and suddently I experienced a gigantic frame drop. I check top, and what do I see: updatedb...aaaaaahhh
13:05:48 <SyntaxNinja> that's what you get for playing games all night
13:06:49 <goron> I only don't understand why they don't incrementally update locate. 
13:13:18 <SamB> goron: you should go to bed earlier!
13:13:32 <SamB> I do wish it didn't make so much noise, though
13:21:06 <goron> SamB: Is locate updated very late then? I don't remember how late it was. (Or did you meant it figurely?)
16:12:28 <skew> hi SamB 
19:49:54 * dtb walks in and looks around
19:49:56 <dtb> i have a list ["blah","foo","a"] in haskel, i have the function "length" and i want to match a list of smallest elements when applying the length function
19:50:04 <dtb> so getSmallest length ["blah","foo","a"] should match ["a"]
19:50:11 <dtb> and getSmallest length ["blah","foo","a","b"] should match ["a","b"]
19:50:17 <dtb> that second bit got me
19:51:09 <CrewdenX> the easiest way would be to traverse the list twice, i would think.
19:51:22 <CrewdenX> once to get the smallest length, and once to collect those members of that length.
19:52:47 <dtb> http://www.pastebin.com/88560
19:54:08 <dtb> lol
19:54:14 <dtb> ignore the <php
19:55:27 <CrewdenX> i'm not very familiar with haskell, so i'm not really following the code that well.
19:56:20 <dtb> tis all good - if it were in java or c i could do it in a few mins, but these types are hard to get ur head around
19:57:04 <dtb> m :: funct -> [lis] -> [lis]
19:57:19 <dtb> my function m takes a function, a list, and gives a list type at the end
19:57:29 <dtb> m func (h:t) = m func smaller
19:58:02 <dtb> applying a func and a list (h:t) to the m funciton results in the haskell interpreter trrying to apply func and smaller to the m function again
19:58:10 <dtb> smaller is...
19:58:24 <dtb> fark - theres where myu codes wrog
19:58:28 <dtb> hate typoign so fast
20:04:02 <dtb> m :: func -> [lis] -> [lis]
20:04:03 <dtb> m func (h:t)
20:04:03 <dtb> 	|x == []	= (h:t)
20:04:03 <dtb> 	|otherwise	= m func x
20:04:03 <dtb> 	where
20:04:03 <dtb> 		x = [y | y <- t, func y < func t]
20:04:14 <dtb> whats wrong with that last line?
20:04:30 <dtb> func is a function, such as "length"
20:04:46 <dtb> how do i define that in the top line? or is that correct?
20:06:46 <CrewdenX> wish i could say.
20:06:54 <dtb> func :: func -> a -> a
20:07:17 <dtb> func has type func, arg, which returns a val? is that hwo it works?
20:08:32 <Cale> dtb: what's up?
20:08:48 <Cale> (just started looking at the channel)
20:08:53 <dtb> :D
20:09:02 <dtb> haskell's up - trying to learn
20:09:06 <Cale> cool
20:09:12 <Cale> you're writing map?
20:09:25 <Cale> or something which isn't quite map...
20:09:32 <dtb> see first 3 posts?
20:09:46 <dtb> yea, scheme map is what i want to do
20:09:47 <dtb> kinda
20:09:50 <Cale> ah, I see
20:10:01 <Cale> "map" is also in Haskell
20:10:14 <Cale> i.e. map (+1) [1,2,3,4,5] == [2,3,4,5,6]
20:10:16 <dtb> yea? buga
20:10:50 <Cale> roughly, you want to map length over the list, take the min, and then filter for items of that length
20:10:52 <dtb> so i can map my func onto every element of the list, turnig them intto numbers (hopefully)...
20:11:00 <Cale> You might do this with a zip
20:11:05 <dtb> yes, how do i filter for the smallest length
20:11:09 <dtb> zip?
20:11:10 <dtb> lol
20:11:22 <dtb> where can i find all these cool functions? haskell.org
20:11:34 <skew> dtb: the buggy line is usign func on the list t and an element of t, which might confuse things
20:11:41 <Cale> zip [1,2,3,4,5] [6,7,8,9,10] == [(1,6),(2,7),(3,8),(4,9),(5,10)]
20:12:02 <dtb> argh! not t nooooooooooo its emant to be h
20:12:02 <dtb> lol
20:12:04 <Cale> i.e. it takes a list of data and pairs each with an element of another list of data
20:12:05 <dtb> try that forst
20:12:17 <dtb> oooooo
20:12:18 <Cale> there's also zipWith
20:12:19 <dtb> coolies
20:12:57 <Cale> zipWith op (x:xs) (y:ys) = (op x y) : zipWith op xs ys
20:13:20 <Cale> these are all in the prelude: http://www.haskell.org/onlinereport/standard-prelude.html
20:13:37 <Cale> so one thing that you can do is to pair each element with its length
20:14:27 <Cale> zip (map length xs) xs
20:14:44 <skew> [x | x <- items, length x == minimum (map length items)]
20:15:08 <Cale> or just do that :)
20:15:25 <dtb> lol
20:15:29 <dtb> thats sooooooooo easy
20:15:31 <dtb> argh!
20:16:20 <dtb> min or minimum? whats the diff?
20:16:37 <Cale> min compares two things
20:16:44 <dtb> argh
20:16:49 <dtb> the other takes a list and gets the min
20:16:51 <Cale> and returns the smaller
20:16:52 <Cale> yeah
20:17:07 <Cale> -- maximum and minimum return the maximum or minimum value from a list,
20:17:07 <Cale> -- which must be non-empty, finite, and of an ordered type.
20:17:37 <Cale> minimum xs       =  foldl1 min xs
20:18:09 <Cale> that is, it basically sticks `min` as an operator between each of the elements of the list
20:20:12 <dtb> minimaBy :: func -> [lis] -> [lis]
20:20:13 <dtb> minimaBy func [lis] = [x | x <- [lis], length x == minimum map func lis]
20:20:28 <dtb> what havbe i done thats do blindingly obvious here thats wrong?
20:20:46 <Cale> just bracketing, I think
20:21:01 <Cale> length x == minimum (map func lis)
20:21:20 <Cale> and don't put square brackets there
20:21:36 <Cale> minimaBy func lis = [x | x <- lis, length x == minimum (map func lis)]
20:21:42 <skew> that only has x range over the elements of the list [lis]
20:21:48 <skew> i.e, lis itself
20:23:03 <skew> does anyone here happen to know anything about O_DIRECT?
20:23:39 <dtb> *Main> minimaBy length ["dave","is","cool"]
20:23:39 <dtb> ["is"]
20:23:41 <dtb> w00+
20:24:34 <Cale> heh
20:25:03 <dtb> i think i got the hang of it :S
20:25:10 * dtb walks off to haskell.org
20:25:30 <Cale> erm...
20:25:33 <Cale> okay
20:25:36 <Cale> heh
20:26:19 <skew> the library could really use some half-generic list functions for the cases like this
20:26:43 <skew> like minimumBy :: (Ord b) -> (a->b) -> [a] -> a
20:27:35 <skew> They are trivial to write, but I don't know what to do with a library of functions like that once you've written it
20:27:54 <skew> mail it to the GHC crew asking for the Data.List.Exts slot?
20:28:27 <Cale> Well, that was homework anyway :)
20:28:47 <Cale> but yeah, lots of list functions should be in the libraries which aren't.
20:29:17 <Cale> http://www.it.bond.edu.au/inft313/042/assessment/assign3.html -- what do you want to bet this is his assignment?
20:29:25 <dtb> m func (h:t)
20:29:25 <dtb> 	|x == []	= (h:t)
20:29:25 <dtb> 	|otherwise	= m func x
20:29:25 <dtb> 	where
20:29:25 <dtb> 		x = [y | y <- t, func y < func h]
20:29:32 <dtb> that works toooooo!
20:30:05 <skew> does it?
20:30:52 <dtb> minimaBy' func (h:t)
20:30:52 <dtb> 	|x == []	= (h:t)
20:30:52 <dtb> 	|otherwise	= minimaBy' func x
20:30:52 <dtb> 	where x = [y | y <- t, func y < func h]
20:30:52 <dtb>  
20:30:58 <dtb> *Main> minimaBy' length ["dave","is","is"]
20:30:58 <dtb> ["is","is"]
20:30:58 <dtb>  
20:31:18 <skew> it's correct, just not quite as good
20:31:24 <dtb> :D
20:31:40 <skew> consider the list [10000..1]
20:32:32 <skew> er, [n,n-1..0] for some big n
20:32:59 <skew> (with func = id)
20:33:10 <dtb> whats id do?
20:33:15 <skew> it's just the identity
20:33:32 <skew> I mean, compare how the two algorithms would work on that list
20:33:41 <dtb> so why does: minimaBy' id [1000..1] crap and minimaBy' id [1..1000] work?
20:33:54 <dtb> the way the lists are generated or soemthing?
20:34:04 <dtb> ohh
20:34:05 <dtb> i see
20:34:22 <skew> you're the one in INFT313, right?
20:34:30 <dtb> me - neva
20:35:03 <dtb> who else hav u come accross?
20:35:06 <skew> you could modify the recursive function to work more efficiently
20:35:21 <skew> right now it filters the entire tail
20:35:28 <skew> all it really needs to keep is the best in the prefix you've seen
20:35:50 <skew> that is a bit trickier, though
20:37:42 <Cale> dtb: heheh - you're obviously in INFT313 - can't hide from google :)
20:37:48 <dtb> :d
20:38:05 <dtb> argh! skew - ur an aussie?
20:38:11 <skew> nope
20:38:15 <dtb> :s
20:38:27 <dtb> where r u ?
20:38:38 <Cale> He appears to be at caltech
20:38:42 <skew> yep
20:38:59 <skew> google doesn't know anything useful about O_DIRECT though.
20:39:19 <skew> I was hoping somebody here might know, based on lots of smart people being here...
20:39:42 <Cale> skew: yeah, I did a search for you when you mentioned it - found some general performance information, but nothing specific about it
20:39:49 <dtb> Cale: what was the google search u did :S i cant find myself
20:39:58 <skew> performance info? the one bonnie test?
20:39:58 <dtb> what does O_DIRECT do/
20:40:00 <Cale> dtb: minimaBy
20:40:05 <dtb> :d
20:40:06 <dtb> lol
20:40:26 <dxlvi> hehe ^_^
20:40:33 <dtb> tis all good - neva plagerised - cant risk it, specailly at Bond - going to use my alg
20:40:36 <dtb> dodgey as it is
20:40:39 <Cale> http://www.ukuug.org/events/linux2001/papers/html/AArcangeli-o_direct.html
20:40:52 <skew> yep, saw that
20:41:02 <skew> I don't even know if my system does the zero copy version
20:41:16 <skew> I hear talk about making zero copy network stacks
20:41:29 <skew> which is almost totally unrelated, but pretty nifty too
20:42:49 <Cale> one thing you might try to do is to rewrite minimaBy func lis = [x | x <- lis, length x == minimum (map func lis)]  without using the list comprehension syntax
20:43:19 <skew> an implementation with zip and sort would do better than your quadradic worst case
20:43:38 <skew> there should also be a pair type sorted only by the first component, for tricks like that
20:43:58 <skew> with instance Ord a => Ord (TaggedPair a x)
20:44:14 <dtb> skew: how long have u been programming?
20:44:23 <skew> a long time
20:44:35 <skew> 15 years or so
20:44:36 <Cale> It would be neat if there were some way to have a type implement a class in multiple ways. Coming up with a reasonable notation for it is hard though.
20:44:50 <skew> there was the named instance stuff
20:45:30 <skew> maybe something could be done the other way around with newtype
20:45:48 <skew> not quite
20:46:18 <skew> I was thinking you could make a type synonym like with "type", with the same runtime representation but different class implementation
20:47:22 <Cale> It would be neat to have "deriving all except" for newtypes
20:47:45 <skew> the problem with that (and the named instances stuff, IIRC) is that the class instance being used is a property of the code and not the values
20:47:55 <skew> well, I guess that's not always a problem
20:48:43 <skew> dtb: not professionally or even seriously, though. Mostly learning and coding little nifty things
20:48:51 <skew> dtb: like crazy haskell stuff
20:49:08 <Cale> skew: what do you do professionally?
20:49:15 <skew> nothing just yet
20:49:19 <skew> not quite out of college
20:49:23 <Cale> ah, another student :)
20:49:23 <skew> one more year to go
20:49:28 <Cale> me too
20:49:45 <skew> I'm working at symantec this summer
20:49:51 <Cale> cool
20:50:07 <Cale> interesting project?
20:50:35 <skew> the zero copy network stuff will make bolting on security harder
20:50:52 <skew> I'm trying to improve the performance of the virus scanner
20:51:27 <skew> I want the O_DIRECT stuff to look at raw disk performance
20:51:58 <skew> the final code will be for windows, but the hardware should be the same
20:53:35 <skew> have you ever built TAGS for the linux kernel source?
20:53:42 <skew> I'm in the middle of it...
20:56:13 <skew> well, it only take 10 minutes or so, but I only found I didn't have write permission at the end :(
20:58:35 <dtb> TAGS for the linx kernel - what are they
20:58:53 <skew> I'm runing ctags
20:59:48 <skew> that's simpler, I guess
21:01:05 <skew> Cale, for the stuff with classes, how about doing your newtype idea, but letting that unify with the old type?
21:01:19 <Cale> hmm...
21:01:42 <Cale> that actually sounds good - though you'd need to call it something other than a newtype then :)
21:02:44 <skew> the newtype gives you a tree structure for restricting what instances are available for the unified types
21:02:53 <dtb> back to my small prob for a sec if u dont mind:
21:02:53 <dtb> minimaBy func [lis] = [x | x <- lis, length x == minimum (map func lis)]
21:02:55 <dtb> and
21:03:06 <dtb> minimaBy' func (h:t)
21:03:06 <dtb> 	|x == []	= (h:t)
21:03:06 <dtb> 	|otherwise	= minimaBy' func x
21:03:06 <dtb> 	where x = [y | y <- t, func y < func h]
21:03:16 <dtb> gah
21:03:17 <skew> the [lis] in the pattern side is bad too
21:03:26 <dtb> wireless mouse died, cant copy ........
21:03:47 <skew> I was talking about the one in the right hand side when I described the problem before
21:03:51 <dtb> minimaBy (\u -> u+1) [1,2,3,4] wont work
21:03:59 <dtb> but minimaBy' (\u -> u+1) [1,2,3,4] will
21:04:42 <skew> that's because the first assumes func is length
21:05:14 <dtb> silly me
21:05:16 <skew> because that's the only example you had given when I was writting that code
21:05:20 <dtb> got it
21:06:16 <skew> Cale: I think something else good comes of considering the available instances a property of types as you unify
21:06:20 <skew> but I forget what
21:06:54 <skew> right, it provides a good framework for working with lexically scoped instances too
21:07:04 <Cale> ah
21:07:13 <skew> if the unification algorithm treats pairs of types and sets of instances
21:07:19 <Cale> yeah, that would also be a cool language extension to have
21:07:33 <Cale> it would kill off all those "sortBy" and such functions
21:07:35 <skew> instances in a where clause would be nice
21:08:55 <skew> things like (consume [Int] with one ord Int) $ sort $ (produce [Int] at another Ord Int) are ambigous, though
21:12:39 <skew> I don't know if the typechecker is set up to notice that sort is in the middle
21:14:03 <skew> perhaps the ascending and descending judgements in the type systems Peyton Jones writes up could be useful
21:14:17 <skew> I haven't looked at them thorougly, though
21:15:01 <dtb> ur a nut - how do u learn all this :/
21:15:10 <dtb> im 18 - gah - sooo much to learn
21:16:00 <skew> huh, I feel the same way
21:16:07 <Cale> dtb: We're only a few years older than you :)
21:16:09 <dtb> O__o
21:16:17 <Riastradh> skew, how is that expression ambiguous?
21:16:19 <Cale> You pick things up faster as you go along.
21:16:31 <skew> Riastradh: which Ord do you want to sort by?
21:16:36 <Riastradh> The regular Int one.
21:17:11 <Riastradh> Top-level instance declarations would simply declare the default.
21:17:32 <skew> we were talking about some facility like a type synonym where you get to make new instances
21:18:08 <Riastradh> In a local scope via 'where instance Foo => bar ...', right?
21:18:34 <skew> nah, like type Int' = Int where Ord {...}
21:18:35 <Riastradh> Although I don't understand what type synonyms have anything to do with this.
21:18:40 <Riastradh> Ah, I see.
21:19:24 <Riastradh> You would just need to add explicit type annotations.
21:19:47 <Riastradh> Or, if produce is known to have the type a -> Int', you don't even need them.
21:20:17 <skew> the idea (not quite sure how this is useful) is that Int' can unify with Int
21:20:21 <Riastradh> sort will use Int', because that's what produce returned.
21:20:58 <Riastradh> But consume, if it has the type Int -> a, will accept sort's output -- because Int's unify with Ints --, just using the Ord instance for Int, not Int', because it is explicitly annotated to do so.
21:21:11 <Riastradh> (well, you still need explicit type annotations somewhere)
21:21:31 <skew> the main utility is not needing to redefine all the other stuff on your type
21:21:45 <skew> and deal with newtype wrappers in case matching, and so on
21:22:30 <skew> Riastradh: what I'm worried about, is if sort is used at type [Int] -> [Int'], what instances does it get inside?
21:22:40 <skew> really it should give an error
21:22:46 <Riastradh> Int.
21:23:01 <skew> you think so?
21:23:04 <Riastradh> Yes.
21:23:29 <Riastradh> If you want it to use Int', you should write 'sort :: [Int'] -> [Int']'.
21:23:54 <dtb> why does sort :: [int] -> [int']  make any sense
21:24:04 <dtb> if ur sorting ints, u wil get its back right?
21:24:15 <skew> your policy seems more like the instances propagate until they hit an explicit declaration of something else
21:24:22 <Riastradh> Yes, skew.
21:24:25 <dtb> O__o
21:24:31 <skew> dtb: of course. We're talkinga about totally messing up Haskell here ;)
21:24:32 <Riastradh> dtb, Int is compatible with Int'.
21:24:42 <skew> dtb: don't try this at home
21:24:47 <dtb> :D lol
21:24:48 <Riastradh> The only difference is how < behaves.
21:25:32 <dtb> keep arguing - its interesting
21:25:38 <Riastradh> (I'd also like local instances or type synonyms too, by the way, if this extension is put into practice.)
21:25:56 <skew> I think the local instances are much better behaved and more obviously useful, actually
21:26:12 <Riastradh> Probably.
21:26:23 <Riastradh> However, the problem is that you have to rewrite things over & over again.
21:26:31 <Riastradh> You can't store your local instance globally.
21:26:35 <skew> the idea there is that you name them
21:26:40 <skew> did you read that thesis?
21:26:45 <Riastradh> Which thesis?
21:26:47 <Riastradh> (obviously not)
21:26:52 <skew> something about named instances for haskell
21:27:07 <Riastradh> Whose thesis?
21:27:09 <skew> google "haskell named instances"
21:27:15 <Riastradh> Nah, I'm too lazy.
21:27:20 <Riastradh> Maybe tomorrow.
21:27:21 <skew> Wolfram Kahl and Jan Scheffczyk
21:27:38 <Cale> Ah, Wolfram Kahl - I'm working with him :)
21:27:52 <Riastradh> (No, I'm not asking you to find it for me; I just don't feel like looking for and reading a paper right now.)
21:28:12 <skew> I already found it for you
21:28:35 <skew> first hit for "haskell named instances" is just quicker to type than the URL :)
21:28:47 <Riastradh> And I'm too melted in this heat to operate a web browser.
21:29:54 <dtb> top one skew?
21:29:59 <skew> yep
21:30:10 <Riastradh> That's usually where the first hit is, dtb.
21:30:23 <Riastradh> In fact, I can't ever think of an instance where the first Google hit wasn't at the top of the list!
21:30:25 <dtb> pfft
21:30:28 <Riastradh> (no pun intended)
21:30:30 <dtb> lol
21:30:46 <dtb> didnt read hit :P
21:31:34 <skew> I'm thinking you could declare some instances that get a name rather than going into effect, and use them like "where <instance head> = <instance name>"
21:31:39 <Cale> I can think of some other search engines where this isn't the case :)
21:32:26 <skew> glancing at the thesis they may have been thinking of lexical scoping
21:32:31 * Riastradh smacks Cale with a typeclass.
21:32:35 <skew> dynamic scoping, rather
21:32:58 <Riastradh> Local type synonyms would amount to lexically scoped instances.
21:33:18 * Cale jabs Riastradh in the arm with a functional dependency
21:33:31 * Riastradh homomorphizes Cale exofunctorially.
21:33:49 <dtb> ouch
21:34:43 <Cale> heh
21:36:21 * Cale shoves Riastradh into a local minimum in a continuously differentiable fashion
21:36:36 * Riastradh growls at Cale and plots his next offence.
21:37:04 <Cale> heh
21:37:26 * Riastradh quickly Googles for some category theory jargon he hasn't already overused repeatedly in this channel.
21:40:22 <shrimpx> nontopological embedding functor
21:40:36 * Riastradh contravariantly functorizes a vectorspace dually, mapping across Cale.
21:41:09 * Pseudonym is staying out of this one
21:41:26 * Cale breaks off a piece of the cut space of the Petersen graph, and swings it around.
21:41:32 * Riastradh ducks.
21:41:59 <skew> actually, a local instance should propage down into any calls
21:43:13 <Riastradh> Maybe I ought to learn category theory some day so I know what I'm doing to all those people.
21:43:33 <Cale> Who needs to stop at category theory?
21:44:22 * Cale emphatically generates a radical ideal
21:44:34 <Riastradh> That sounded _sooooo_ mundane.
21:45:41 <Cale> Yeah, it wasn't an attack or anything - I'm just trying to get my message out: a^n in I, you know?
21:46:50 <Cale> http://planetmath.org/encyclopedia/RadicalOfAnIdeal.html
21:47:12 <Cale> Every prime ideal is radical.
21:47:23 <Riastradh> Fields of mathematics are so boring unless they have cool-sounding terminology.
21:47:53 <Cale> I like the notion of the bicycle space of a graph, denoted bike(X)
21:48:59 <Cale> http://www.math.uwaterloo.ca/~dmjackso/publications/ -- this guy knows how to make things sound good
21:49:22 <Pseudonym> Jack symmetric functions
21:49:32 <Pseudonym> Unfortunately, I don't know Jack (symmetric functions).
21:49:41 <Cale> "The virtual Euler characteristic of the moduli spaces of real and complex algebraic curves."
21:49:55 <skew> what is this bike space?
21:50:12 <skew> and how does it differ from a unicycle space?
21:50:56 <Cale> it's the cut space intersected with the flow space
21:51:28 <Cale> a graph with no nonempty bicycles is called pedestrian
21:53:06 <Cale> Professor Jackson (the person to whose papers I linked) is really good, by the way - if you ever get a chance to take a course with him, go for it.
21:54:16 <Cale> btw, open the paper there (The virtual Euler...) and scroll down to ~page 15 or so :)
21:55:50 <skew> what's there?
21:55:54 <Cale> frightening :)
21:55:58 <skew> oh, those?
21:56:44 <Pseudonym> I can kinda follow it, actually.
21:56:58 <skew> it's a bit messy
21:57:11 <Pseudonym> It is, yes.
21:57:18 <Cale> It all makes sense, but it's just the sheer amount of notation that strikes you.
21:58:16 <skew> have you all seen Peyton-Jones' new paper on generalized algebraic data types?
21:58:29 <Cale> yeah - there are a few good pages in that :)
21:58:47 <Cale> and the idea is excellent, I think :)
21:59:28 <skew> the class associated types sound useful too
22:03:31 <Cale> ah, yeah they do
22:03:52 <Cale> Are class associated types going to be in 6.4?
22:10:56 <Cale> Associated types and GADTs would be fun to play with.
