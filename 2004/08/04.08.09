02:11:25 <bourbaki> hi
02:30:45 <shapr> goood morning#haskell!
02:32:45 <shapr> what's going on?
02:36:35 <bringert> morning shapr
02:36:54 <bringert> I'm coding gf stuff as usual
02:38:57 <bourbaki> hi :)
02:41:33 <shapr> hey, I've been trying to think of possible features for web-teaching with GF, I've thought of morphology and translation, but not anything else. Maybe online design of grammars somehow?
02:43:14 <bringert> that would be neat
02:43:35 <shapr> can you think of any other broad feature sets?
02:44:02 <bringert> grammar design would have a very different target audience compared to the others though
02:44:28 <bringert> maybe some sort of reading comprehension?
02:44:44 <shapr> hm, that sounds interesting, how would it work?
02:44:47 <bringert> like translation, but you identify the correct translation instead of writing it yourself
02:44:51 <shapr> oh right
02:44:51 <shapr> nifty!
02:45:00 <shapr> that's an excellent point
02:46:16 <bringert> related to plain morphology exercises (as in "what's vodka in the instrumental singular?") would be to fill in the correct form of a given word or phrase in a sentence with a meta-variable
02:46:30 <shapr> my current user idea is to get GF working for SFI, so I think the teachers might want to work on the grammar, but I don't know if teachers actually would want to do coding of any sort at all.
02:47:17 <bringert> yeah, I think you need both programming and linguistics backgrounds to write GF grammars
02:47:26 <shapr> yah, I've been thinking about phrase testing, I'm still not sure how to make it work.
02:47:48 <bringert> some of the ideas might be a little foreign to your average swedish teacher
02:47:54 <shapr> yes, I think so
02:48:05 <shapr> and to your average programmer as well.
02:48:09 <bringert> right
02:48:50 <shapr> still, allowing the teachers to design their own exercises would be great
02:49:01 <bringert> yeah
02:49:20 <shapr> even if it required giving the broad exercise design and vocab specifics to someone who can translate it into a GF grammar
02:49:20 <bringert> maybe the don't need to change the grammar
02:49:43 <bringert> like a consultant, say you
02:49:48 <bringert> :)
02:49:58 * shapr imagines getting paid to write Haskell
02:50:05 <shapr> in an open source context... mmmm!
02:50:22 <shapr> and it would be an immediate payoff from a VINNOVA program too
02:50:47 <bringert> good point
02:50:52 <bringert> with the stuff I'm writing now, it could be possible to write GF exercise applets in java
02:50:54 <shapr> well, I have a morphology question prototype working, even if it's not very exciting yet.
02:50:57 <shapr> hm nifty!
02:51:06 <bringert> though that's java, not haskell
02:51:11 <bringert> got a demo?
02:51:39 <bringert> did you figure out the large lexicon btw?
02:51:56 <shapr> http://217.211.205.143/cgi-bin/ProtoQ
02:52:04 <shapr> nah, I was fighting WASH
02:52:35 <shapr> I had to figure out how to pass the correct answers through to the next page, and that was more trouble than I expected
02:52:50 <bringert> wash generally is :)
02:53:05 <bringert> a "next question" button would be nice btw
02:53:13 <shapr> yah, that's just a prototype
02:53:33 * shapr adds the button
02:53:58 <bringert> hmm, it says that "komma : VPres Imperat Act" is "komm"
02:54:00 <shapr> oh, I bet I can use GF to make the web interface multilingual, but I dunno how yet.
02:54:02 <bringert> but that's wrong
02:54:13 <bringert> it should be "kom"
02:54:21 <bringert> seems like a problem in the grammar
02:54:22 <shapr> I dunno
02:54:33 <shapr> I'm still using my hacked version rather than the latest CVS, so that may be it.
02:54:47 <shapr> any major changes since you sent me the cvs version?
02:54:52 <bringert> I'm sure there are bugs in the grammars too
02:55:01 <bringert> don't think so
02:55:08 <shapr> would a patch against the cvs version you sent me be easy to reintegrate?
02:55:34 <bringert> you mean if I send you a patch to get you to the latest version?
02:55:47 <bringert> or you send me one?
02:56:03 <shapr> me send you a patch to get Infra a hierarchical lib thingy
02:56:11 <shapr> just so GF can be loaded into GHCi
02:56:24 <shapr> well, GF + WASH
02:56:46 <bringert> that should be easy enough
02:56:54 <shapr> ok
02:57:01 <bringert> is it just infra?
02:57:08 <bringert> or any of the other subdirs too?
02:57:32 <shapr> well, I'm going to redo the changes with the GF-cvs you sent me, so anything else you might like to have as a hierarchical lib?
02:57:49 <shrimpx> what's GF
02:57:55 <bringert> hold on, I'll go ask aarne what he thinks
02:58:05 <bringert> shrimpx: Grammatical Framework
02:58:11 <shrimpx> ah
02:58:23 <bringert> http://www.cs.chalmers.se/~aarne/GF/pub/work-index/
03:00:14 <shapr> also, are there some basic unit tests I can run to see if I've broken something during the refactoring?
03:02:18 <shapr> I think a lambdabot plugin that uses GF to generate random sentences would be a fun hack to do when I'm tired of webapps.
03:02:36 <shapr> we could even get andersca to write a Pirate Grammar!
03:04:35 <shapr> gutentag cptchaos 
03:04:47 <cptchaos> gutengat shapr
03:04:56 <shapr> wie geht es?
03:05:06 * cptchaos still waking up
03:05:15 <shapr> ich auch
03:05:44 <cptchaos> hast du angefangen deutsch zu lernen?
03:05:54 <shapr> nein
03:06:07 <shapr> I just lived with a german girl for a few months and picked up some german that way
03:06:26 <cptchaos> ah, ok
03:06:30 <shapr> actually, I live with a german woman for the last five years, but she doesn't want to teach me german.
03:06:49 <shapr> she'd rather I learn Swedish and Finnish with her first :-)
03:07:28 <cptchaos> *g* could be more useful in sweden
03:07:32 <shapr> heh, yes
03:20:08 <bringert> shapr: we are interested in moving to hierarchical libs, but will probably wait a little
03:21:12 <shapr> ok
03:22:45 <shapr> I can imagine that moving to hierarchical libs would involve some other refactoring first.
04:30:50 <shapr> hi dtb 
04:30:59 <shapr> how's the sunny south?
04:32:33 <dtb> sunny south?
04:32:46 <shapr> well, you're in Australia?
04:32:53 <shapr> that's definitely south of me.
04:33:08 <dtb> hehe
04:33:13 <dtb> well i just rode home from uni
04:33:23 <dtb> in a jumper and long pants, cant feel my ears
04:33:42 <shapr> it's cold?
04:33:48 <dtb> where r u? Mr. IPv6 Man
04:34:23 <dtb> yes its very cold
04:34:52 <shapr> I'm just south of the arctic circle. Even so, it's rather warm here at the moment.
04:35:06 <dtb> sharp night - and there is a fire up in the mountains, so its cold, and a bit misty over the water, along with the odd moving cloud of smoke
04:35:20 <shapr> sound mystical rather than just mysty
04:35:27 <dtb> ya - i love it here
04:35:57 <dtb> specially sittin up on the roof at night - or early in the morn - can see the  sun come up over the sea on a clear day
04:36:11 <dtb> how warm is warm there?
04:36:42 <shapr> we had the warmest day yet of this year two days ago
04:37:17 <shapr> I'd guess it's just below body temperature
04:37:47 <shapr> are you a Haskell programmer?
04:37:51 <dtb> nice - whats the normal temperature there?
04:38:10 <dtb> lol - do u remember my align "xx" "yy" thing ive =been trying to do over the part few days?
04:38:28 <dtb> well im trying to be a haskell programmer
04:38:32 <dtb> the best there is :D
04:38:46 <shapr> depends on the time of the year, the coldest temperature we've had in the past few years was -35° C on the doorstep, and -45°C some kilometers away from here.
04:38:55 <shapr> sounds like a worthy goal t ome
04:39:07 <dtb> -43C :!:!!!!!!!!!!!?????????
04:39:14 <dtb> dude
04:39:17 <dtb> wow
04:39:27 <shapr> yah, we all stayed inside and huddled under the covers.
04:39:35 <dtb> we are at the other end of the scale
04:39:37 <shapr> but it was only about three days that were like that.
04:39:42 <dtb> ok
04:40:00 <shapr> same for the really hot days here, it's only about a week of really hot days
04:40:17 <dtb> did anybody go outside when it was that cold? what do u wear? is there snow or ice ?
04:40:28 <shapr> yes, lots of snow and ice
04:41:00 <shapr> people do go outside in the standard cold temperatures, you just wear warm clothing.
04:41:08 <shapr> in the -45° most people stayed inside.
04:41:46 <lelit> shapr: where are you living?
04:41:55 <shapr> Boden, Sweden
04:42:32 <lelit> ah, just a dream on my desk... :-) 
04:42:46 <lelit> I love snow and ice
04:43:23 <lelit> too bad in the last few years the winters are ... dry
04:43:23 <shapr> sometimes I wish for Jamaica :-)
04:43:39 <lelit> hehe, I can *well* imagine :)
04:44:37 <dtb> i've never left aussie - :( have no idea about the way other countries live their lives
04:44:50 <lelit> But Sweden is known as "definitely not so cheap", here
04:44:52 <shapr> I'm from Alabama originally, so this is quite an experience for me.
04:45:00 <lelit> Wow
04:45:41 <shapr> Sweden is expensive tax-wise, but that's most of it.
04:46:31 <lelit> You have euros, right?
04:48:01 <shapr> nope, we don't :-(
04:49:50 <lelit> bbl
04:50:50 <lelit> shapr, you did update from my repo? I made an important fix..
04:50:59 <lelit> later
04:51:47 <shapr> I'll do it now
04:56:13 <bringert> shapr: did you see this gem in Conor McBride's latest mail to haskell@haskell: "choosing type class unicycling over dependent types is a false economy"?
04:56:31 <shapr> ??
04:56:32 * shapr looks
04:57:21 * shapr laughs
04:57:47 <shapr> this must be on the QuotesPage
04:58:32 * dtb dosnt understand "choosing type class unicycling over dependent types is a false economy"
04:58:51 <shapr> dtb: don't worry about it until you start getting interested in type theory.
04:59:22 * dtb gets interestes - soooooooo much to learn 
04:59:33 <shapr> one of the really neat tricks in Haskell is that the spiffy type system gives you a simplistic optional proof checker.
04:59:49 <shapr> you can encode certain properties in your types that then get checked upon compilation.
04:59:53 <dtb> @type (,)
04:59:54 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
05:00:02 <dtb> is that the types u are talkign about?
05:00:19 <shapr> if you've ever written any large SQL queries, you've probably made some simple errors that weren't noticed until you tested the code.
05:00:36 <dtb> dtbsfunct :: String -> Int -> [String]              -is that a type?
05:00:46 <shapr> HaskellDB gives you good type checking of SQL queries
05:00:48 <shapr> yes, that's a type
05:01:04 <shapr> String is the same as [Char]
05:01:27 <dtb> :t dtbsfunct          = [String] or [[Char]]
05:02:03 <shapr> if you created a new type named LastName that was just a wrapper around the String type, you could declare that employee lookup functions must return (LastName,FirstName) maybe
05:02:14 <shapr> that's one way that you can use the type system to your advantage.
05:02:35 <shapr> In my opinion, a good typesystem is a nice tool to have around.
05:02:56 <shapr> I'd still recommend you also learn completely untyped languages such as Forth
05:03:11 <bringert> or scheme
05:03:16 <dtb> scheme has lists
05:03:20 <dtb> is lists a type?
05:03:25 <bringert> can be
05:03:29 <bringert> not in scheme though
05:03:32 <dtb> ok
05:03:43 <bringert> [1,2,3] is a list value
05:03:48 <bringert> [Int] is a list type
05:04:01 <bringert> in haskell, [1,2,3] can have type [Int]
05:04:18 <bringert> in scheme the list would still be a list value
05:04:23 <dtb> but in scheme '(1 2 3) is just a list
05:04:28 <dtb> no type associates
05:04:29 <dtb> no type associated
05:04:34 <bringert> right, just a list value
05:05:06 <bringert> well, actually, it has no static type
05:05:30 <dtb> and "type class unicycling" is..   (if its not too hard to explain)
05:05:36 <bringert> it still has a type at runtime, so that if you try to treat the list as a number, it will fail
05:05:58 <bringert> "type class unicycling" refers to faking dependent types in haskell
05:06:29 <bringert> dependent typing is a powerful than than Haskell's type system
05:07:08 <dtb> faking dependant types - so would that be treating a list as a number?
05:07:12 <bringert> but you can do (or fake if you will) some of the things that you can do with dependent types by using Haskell's type classes
05:07:33 <bringert> no :)
05:08:21 * dtb opens Kenneth Louden - Programming Languages Principles
05:08:41 <bringert> haskell has types like [Int]
05:09:13 <bringert> you could conceivably have a type for sorted lists, say SortedList Int
05:09:42 <bringert> say you wanted to give a very exact type for a sorting function
05:10:00 <dtb> yea
05:10:11 <dtb> u would need something more than a type for a simple list
05:10:15 <bringert> one that included the facts that: 1) the output is sorted and 2) the output is a premutatation of the input
05:10:20 <bringert> right
05:10:32 <bringert> so you need a more powerful type system
05:11:38 <bringert> in haskell you could say: sort :: [Int] -> [Int]
05:12:29 <bringert> but saying that the output is a sorted permutation of the input is difficult
05:12:37 <dtb> yea
05:13:10 <bringert> having a dependent type system helps here, because they allow the type to depend on the values that you give to functions
05:13:39 <dtb> ohh k
05:15:14 <bringert> epigram is an experimental language with dependent types
05:15:44 <bringert> but you'll probably want to learn more about type systems first
05:15:51 <dtb> :D
05:16:35 <Philippa> bringert: got any good pointers for somebody who has done?
05:16:42 <Philippa> or is it just "play with epigram, have fun"?
05:16:55 <bringert> no, I don't, sorry :)
05:17:05 <bringert> I haven't really looked at it either
05:17:28 <kosmikus> Philippa: there's a nice epigram tutorial due to the upcoming AFP
05:17:37 <kosmikus> Philippa: there are several interesting references in there
05:17:46 <bringert> I just printed that one
05:17:57 <bringert> anyone else here going to AFP04?
05:18:07 <kosmikus> me
05:18:11 <Philippa> urgh, that reminds me. Gotta write that review sometime
05:18:22 <bringert> review?
05:18:39 <kosmikus> bringert: and Igloo
05:18:40 <Philippa> yeah. Call-by-push-value. For the JFP.
05:18:56 * Philippa saw the "anybody wanna review?" post on c.l.f
05:19:24 * kosmikus still has to write a POPL review this week
05:21:06 <Philippa> yeah. This one's prolly a bit overdue by now (though I wasn't given a deadline) - been moving house, not been overly well, boyfriend's been a lot worse...
05:35:26 <shapr> hej Marvin-- 
05:37:04 <Marvin--> goddag
05:43:03 <shapr> hola jao 
05:43:48 <jao> hola shapr
05:52:29 <Marvin--> oh, this is rich: http://lists.debian.org/debian-curiosa/2004/06/msg00028.html
06:11:03 * Philippa is playing about trying to write some bindings to a C lib, only it's turning out all the lib's functions are macros referring to another definition elsewhere...
06:11:21 <Philippa> any suggestions?
06:12:34 * ibid might consider writing simple wrappers in c and bind to those
06:12:40 <Igloo> Tiny wrappers if the only portable thing to do, I believe
06:13:54 <Philippa> none of the FFI tools'll do it, then?
06:14:57 <Igloo> I don't know them well enough to know
06:16:01 <Marvin--> well do I know the evils of libraries providing lots of macros rather than functions
06:16:04 * Marvin-- glares at openssl
06:16:22 <Philippa> the win32 API does it to switch between ANSI and unicode versions
06:16:33 <Philippa> what'd you end up doing?
06:17:33 <Marvin--> oh, I haven't had to deal with it for haskell
06:17:43 <Marvin--> dealing with it for python was enough
06:17:53 <Marvin--> but then, libssl and libcrypto are insane in many other ways too
06:17:53 <SyntaxNinja> hi Marvin--
06:18:00 <Marvin--> hey syntax
06:18:02 <SyntaxNinja> so you didn't see any pretty printer for the description file?
06:18:12 <SyntaxNinja> maybe krasimir forgot to send it.
06:18:19 <SyntaxNinja> I'm waiting for him to reply.
06:18:50 <SyntaxNinja> so Simon and Co want to change the name of the description file. they want something like myTool.hsproj
06:19:09 <Marvin--> SyntaxNinja: there was nothing in the patch names that suggested any pretty printers, and when I grep -i pretty I find nothing
06:19:27 <Marvin--> the .hsproj thing has been a point of debate for a long time, hasn't it?
06:19:41 <SyntaxNinja> yes, but sadly, no one replied until after the release
06:19:44 <SyntaxNinja> I don't particularly care what it's called.
06:20:09 <Marvin--> me neither, but I think it's silly to put the package name in the file name
06:20:20 * Igloo reads "case e of { ((x::a, y) :: a) -> x }" on the list and scratches his head
06:20:33 <SyntaxNinja> Setup.hsproj might work.
06:20:35 <Marvin--> Igloo: ehhhhhh
06:20:49 <SyntaxNinja> yeah, I don't see anything in the patch bundle he sent me, I bet he forgot.
06:21:04 <SyntaxNinja> but the title and his text say something about the pretty printer.
06:21:21 <Marvin--> SyntaxNinja: if the intention is to make it a project file for IDEs, it makes sense to have the project name in the file name, or you mightily confuse "recently opened files" features in said IDEs
06:22:05 <SyntaxNinja> maybe they can use the directory name.
06:22:32 <Igloo> Having to mention the package name in Setup.lhs would be a pity
06:22:44 <SyntaxNinja> yeah; well, we could look for *.hsproj
06:22:50 <SyntaxNinja> the only problem is what if there's more than one :)
06:22:51 <Marvin--> ick
06:22:59 <SyntaxNinja> that's what simon wanted
06:23:01 * SyntaxNinja shrugs
06:23:17 <SyntaxNinja> well, simon wanted Setup.description & *.hsproj
06:23:37 <Marvin--> is there any globbing libs in the standard libraries, or would we have to roll that ourselves?
06:23:39 <SyntaxNinja> windows has this funny thing about wanting the extensions to be for only a single application or something ;)
06:23:47 <SyntaxNinja> I assume we'd have to roll it ourselves.
06:23:54 <SyntaxNinja> that's not too bad.
06:23:54 <Marvin--> windows has this funny thing about extensions. period.
06:24:02 <SyntaxNinja> word
06:24:28 <SyntaxNinja> I would prefer to make the rule for the description file to be a _simple_ rule. 
06:24:36 <Marvin--> *.hsproj looks pretty arcane as it is, having an extension longer than three characters
06:24:44 <SyntaxNinja> I don't want .description AND .hsproj
06:25:55 <SyntaxNinja> meh
06:26:09 <SyntaxNinja> why couldn't they have replied before 0.1
06:26:23 <Igloo> Oh, one thing that occured to me - it's probably silly to allow numbers in package names but not '.'s, so I'd suggest allowing '.' too
06:26:41 <Marvin--> Igloo: yeah I was thinking that too
06:26:57 <SyntaxNinja> sounds good to me :) we just need to agree on the tag syntax and then we can do whatever we want.
06:27:19 <Marvin--> I like Igloo's plusses better than Simon's underscores
06:27:52 <SyntaxNinja> maybe we coul duse both, just so no one gets mad: foo-1.2.3_+_bar_+_bang_+_baz
06:28:00 <Marvin--> hah
06:28:12 <Marvin--> this is starting to look like that Parrot april's fool joke
06:28:20 <Marvin--> while left_bracket right_bracket:
06:28:40 <kosmikus> what are these added phrases good for, anyway? do you have a real example?
06:28:59 <Marvin--> "added value"!
06:29:06 <SyntaxNinja> Simon Says.
06:29:09 <Marvin--> (or is that "value-added"?)
06:29:09 <SyntaxNinja> ;)
06:29:15 <Igloo> It's not for cabal - SM wants it for a more generic version module
06:29:18 <SyntaxNinja> I thought it was value-added
06:29:35 <Igloo> Things like "cvs" or a date
06:29:47 * SyntaxNinja gets coffee...
06:29:50 <kosmikus> hm
06:30:02 <Marvin--> Igloo: and I don't get that at all, a generic version module should be ... generic, not restrictive
06:30:38 <Igloo> If it's too generic it can't do anything
06:30:54 <Marvin--> which is kinda my point, a generic version module is useless
06:31:10 <Igloo> This way you can write versionnumber :: FullThing -> [Int], has_tag :: FullThing -> Tag -> Bool etc
06:31:20 <kosmikus> so, can these extra's affect the ordering of versions or are they purely informative?
06:31:40 <Marvin--> purely informative
06:31:47 <Marvin--> afaict
06:32:16 <Igloo> I think so, but specific things will probably additionally order by date
06:32:27 <Igloo> (for example)
06:34:19 <SyntaxNinja> well, the version module can compare version numbers. that's it, but that's important enough.
06:34:45 <Marvin--> the problem is that it's extremely picky about what kind of version numbers it will compare
06:36:34 * Marvin-- goes back to worrying about getting a release of pyopenssl out the door
07:06:08 <Nathell> hello
07:53:01 <SyntaxNinja> hi Nathell
07:56:47 <Marvin--> SyntaxNinja: whoa, that patch completely rewrites the parser
07:57:04 <Marvin--> poor parser, I'm losing count of how many times it's been rewritten
07:58:40 <Igloo> :-)
07:59:27 <thebug> 'lo dons
07:59:44 <Marvin--> why do we need a pretty printer for it, though?
08:03:01 <Marvin--> (and, incidentally, why doesn't it use the pretty printer combinators?)
08:03:22 <Marvin--> listField :: String -> (a -> String) -> (ReadP [a] a) -> (b -> [a]) -> ([a] -> b -> b) -> Field b
08:03:28 <Marvin--> yikes, quite the type signature
08:05:48 <Marvin--> aiih, user-defined kinds?
08:05:50 * Marvin-- boggles
08:06:01 <Marvin--> I shouldn't read the haskell mailing lists without a cup of coffee nearby
08:06:23 <SyntaxNinja> Marvin--: sorry to spring that on you; poor parser.
08:06:36 <SyntaxNinja> krasimir seems to be a "rewrite it my way" kinda guy.
08:06:57 <SyntaxNinja> Marvin--: but I'm actually hoping to leave the decision on acceptance of that patch to you.
08:07:16 <SyntaxNinja> but he seems amenable to changing things when I complain.
08:07:39 <Marvin--> NIH :-)
08:07:59 <Marvin--> no, it looks pretty good, I've been thinking of restructuring the parser in a similar way myself
08:08:28 <Marvin--> I have only a few small objections, but I'll mail them instead
08:09:15 <SyntaxNinja> great!
08:10:35 <SyntaxNinja> maybe we need a cabal mailing list
08:10:42 <SyntaxNinja> I just feel like it'll only be needed for a while.
08:11:28 <Igloo> It'll be somewherre to send bug reports, talk about new preprocessor options etc
08:13:17 <SyntaxNinja> true. the libraries list is OK for that.
08:13:23 <SyntaxNinja> but it would probably be good to have a list.
08:13:24 <SyntaxNinja> hmmmm
08:13:55 <Igloo> Lists are cheap...
08:15:24 <SyntaxNinja> true
08:15:26 <SyntaxNinja> hmmm
09:09:49 <Lor> Evening, folks.
09:10:10 <stefan_> good evening
09:44:32 <Lor> dons, are you awake?
09:54:53 <shapr> hei Lor 
09:57:37 <Lor> Hei.
09:58:04 <shapr> wassup? haven't heard from you lately.
09:58:46 <Lor> I've mostly been off the net.
09:58:59 <shapr> taking a break to read?
09:59:41 <Lor> Yeah, and to write, and in general to spend the summer sensibly.
10:00:04 <shapr> webapp demo of the moment is the swedish conjugation test: http://217.211.205.143/cgi-bin/ProtoQ
10:00:29 <shapr> written in Haskell of course.
10:00:44 <shapr> hiya aFlag, what flag today?
10:04:06 <aFlag> hi, a sad and black one, since my girlfriend left me for good :-/
10:04:16 <shapr> :-(
10:05:44 <shapr> what's going on guys?
10:05:51 * esap is bored :-)
10:06:07 <shapr> no more papers to read?
10:07:03 <esap> heh, yes there are many I should read, but I'm not planning on reading those right now, maybe later.
10:08:22 <esap> Hmm.. what do you think of the following function btw? run_step f a b = f a >>= \n -> n b   ? I think that's pretty interesting.
10:09:12 <shapr> looks a bit like some of the arrow ops
10:09:19 <shapr> and reminds me of the runST stuff
10:09:23 <shapr> @index runST
10:09:25 <lambdabot> Control.Monad.ST.Lazy,Control.Monad.ST,Control.Monad.ST.Strict,GHC.ST
10:09:33 <shapr> @type Control.Monad.ST.runST
10:09:34 <lambdabot> Control.Monad.ST.runST :: forall a. (forall s. GHC.ST.ST s a) -> a
10:09:54 <shapr> @type run_step f a b = f a >>= \n -> n b
10:09:55 <lambdabot> bzzt
10:10:01 <shapr> @type f a >>= \n -> n b
10:10:03 <lambdabot> bzzt
10:10:07 * shapr smacks lambdabot 
10:10:15 <esap> right. Try run_step id :: (Monad m) => m (a -> m b) -> a -> m b  is also odd, it sounds like a restriction of unsafePerformIO...
10:11:26 <Cale> It really isn't very odd if you think about it :)
10:12:07 <Cale> I have a container of functions from a's to containers of b's, and an a.
10:12:15 <Marvin--> yeah I don't see what's so odd about it
10:12:22 <Cale> Map ($ a) over the container, and then join.
10:12:23 <Marvin--> run_step id looks basically like join
10:12:24 <esap> true, but I actually thought once that it's not possible to go from "m a -> a" for any choice of a.
10:12:43 <Cale> You aren't doing that
10:12:48 <Cale> :)
10:12:57 <Cale> er
10:12:57 <esap> I am, just choose (a -> m b)
10:13:01 <Cale> well, sort of :)
10:13:13 <Marvin--> esap: so, what about join? ;)
10:13:18 <Cale> join is sort of like that
10:13:59 <Cale> @type Control.Monad.join
10:14:01 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
10:14:18 <Marvin--> join is also on the form m a -> a
10:14:37 <esap> True, actually that's another good example.
10:14:39 <Marvin--> but saying that it's on the form m a -> a is kinda deceiving, since there's an m inside a
10:15:14 <Cale> yeah, a isn't forall bound there :)
10:16:52 <esap> I guess it's not possible to have 'm a -> a' form function for every m that wouldn't have 'm' inside a.
10:17:28 <esap> Except of course if you want to allow unsafe things :-)
10:18:04 <esap> But it's useful to find the closest restriction that works.
10:19:40 <esap> join . run_step id :: (a -> a -> a -> b) -> a -> b    hmm...
10:21:35 <SyntaxNinja> Marvin--: Igloo so what would you think about transitioning to using *.hsproj and just giving an error message if there's more than one .hsproj file?
10:21:52 <SyntaxNinja> and for the next version at least, we'll still allow Setup.description.
10:21:56 <Marvin--> esap: don't forget  (Monad ((->) a)) =>
10:22:35 <esap> marvin: Yea, I just realised that as well...
10:22:53 <Marvin--> esap: it's kinda crucial ;)
10:28:13 <Marvin--> SyntaxNinja: I dunno, I think foo.hsproj is really ugly
10:28:59 <Marvin--> SyntaxNinja: how does it work with visual studio and project files in custom formats? sounds weird to me, but what do I know
10:30:03 <SyntaxNinja> what do you mean, 'custom formats' you mean custom cabal tools or custom VS tools?
10:35:46 <Marvin--> what I mean is that the format of the file is fixed, doesn't visual studio care at all?
10:38:05 <SyntaxNinja> they can write their own parsers for the file format
10:38:11 <SyntaxNinja> but in fact, they're going to use ours, I guess.
10:38:44 <SyntaxNinja> I think it's for the sake of the double-clicking that they really want this particular extension. I wonder if it could be Setup.hsproj. That would be fine by me.
10:40:08 <Marvin--> I don't see the point of Setup.hsproj
10:40:24 <Marvin--> Setup.description says "this is the description that goes with Setup.lhs"
10:40:31 <Marvin--> foo.hsproj says "this is the project foo"
10:47:27 <Marvin--> "in the world of Visual Studio, people expect project files to be named something like <project>.hsproj for a Haskell project"
10:47:38 <Marvin--> I wonder what this world is and how large it is :)
10:47:54 <palomer`> visual studio has a haskell plugin?
10:53:24 <pesco> Is the world of Visual Studio something like the convention hall planet?
10:55:58 <SyntaxNinja> the world of meaningful extensions is larger than the world of visual studio, surely.
10:56:34 <SyntaxNinja> .description isn't particularly meaningful in a global sense.
10:59:49 <Marvin--> well I don't care about the extension, what I'm saying is that if you're going to care about having an extension that makes sense for an IDE, mandating the non-extension part is just silly
11:00:10 <SyntaxNinja> right.
11:00:14 <SyntaxNinja> I"m following up now...
11:01:05 <Marvin--> but then, I'm not sure we should cater especially to visual studio, what about other IDEs? What kind of project files do they use?
11:02:02 <Marvin--> What about Eclipse? Anjuta? Kdevelop?
11:02:16 <SyntaxNinja> if we can find compromises that work for them, that would be greatk.
11:02:29 <SyntaxNinja> in particular, .hsproj is probably a better extension for those.
11:03:37 <Marvin--> mandating Setup.hsproj is probably the worst of both worlds though :-)
11:03:45 <SyntaxNinja> why?
11:03:47 <Marvin--> I'm starting to think that Setup.description|*.hsproj makes sense
11:04:07 <Marvin--> with the possibility of adding more patterns for other IDEs
11:06:42 <pesco> I'll be majorly pissed if any VS-artifacts start invading my computer system. Do you read?
11:07:55 <RussellOConnor_> @type sort
11:07:56 <lambdabot> bzzt
11:08:00 <pesco> As much as I'm majorly pissed about the existence of withSocketsDo (/literally spits the word out/).
11:08:14 <Marvin--> @type Data.List.sort
11:08:15 <lambdabot> Data.List.sort :: forall a. (Ord a) => [a] -> [a]
11:08:15 <pesco> Heh, lambdabot can bzzz! That's just awesome. :)
11:10:05 <SyntaxNinja> but that's a confusing rule. What's wrong with Setup.hsproj?
11:10:17 <SyntaxNinja> predictability is more important than aesthetics, in this case :)
11:11:35 <Marvin--> I just don't think it makes sense from an IDE point of view to not be able to name my project files the way I want to
11:12:32 <pesco> What ever happened to integrated _computing_ environments anyway?
11:13:00 <SyntaxNinja> the problem is, so VS-user calls it Foo.hsproj and then someone else wants to use it in Eclipse and needs it to be called "Foo-1.eclipse" or something.
11:13:05 <SyntaxNinja> now we need two description files.'
11:13:28 <SyntaxNinja> it seems like VS can bend to match whatever we decide. if other IDEs can't, they it's them who is broken.
11:13:32 <SyntaxNinja> it is THEY who are broken ;)
11:14:01 <pesco> Just give it some funny name that'll give _every_ IDE und the corresponding users the biggest headach.
11:14:31 <SyntaxNinja> we must make them conform to us :)
11:14:50 <pesco> That's the right spirit.
11:15:49 <SyntaxNinja> It's true, though. Though I don't really want the description file to be a big part of the interface, we can't alter every tool to go looking for a regular expression of description files.
11:16:30 <Riastradh> Why don't you just parameterize the whole system with a description file suffix?
11:16:51 <pesco> I propose adjusting everything so it'll work awesomely fine on VMS.
11:17:14 <Riastradh> If it works on WNT, isn't that close enough?
11:17:57 <pesco> Or, if you want to be stylish and half-serious/half-ironic, cater to Unicos!
11:18:22 <SyntaxNinja> Riastradh: parameterize what exactly with the description file suffix?
11:18:32 <pesco> That way, none of the windows, linux, or mac crowd can get pissed at any of the others.
11:18:33 <Riastradh> Anything that needs to operate on the description files.
11:19:22 <Cale> pesco: ITS!
11:19:35 <pesco> Yes. Yes. That's good!
11:19:43 <pesco> And Multix, obviously.
11:19:58 <SyntaxNinja> Riastradh: that's a generic solution, but it spreads a little bit of pain around to all the end users. I'd rather spread a lot of pain around to the developers ;)
11:20:12 <SyntaxNinja> actually, I will just see if there's any problem with Setup.hsproj and then start worrying about this.
11:20:25 <Riastradh> SyntaxNinja, the users wouldn't have to care unless they have a completely non-standard suffix or they have several description files and they want to choose one.
11:20:38 <Riastradh> The system can _default_ to whatever looks like a description file syntax.
11:20:48 <pesco> It'll be like "Tested and proven on all major platforms! ITS, Multics, Unicos, VMS. You name it!"
11:20:58 <SyntaxNinja> Riastradh: but then we have to build every tool with a little regexp or something so it knows what the description files look like.
11:21:24 <SyntaxNinja> The only tool that uses the description files righ tnow is the Distribution.Simple system, and that _is_ parameterizable.
11:27:37 <SyntaxNinja> it's nice to be arguing with people who actually write code; it's a new phase for the project ;)
11:39:47 <Riastradh> Code?  You mean there's actually code in here and not hand-wavy, philosophically abstract mathematical argument in here?
11:40:19 <SyntaxNinja> Riastradh:  :)
11:41:03 <SyntaxNinja> I was just sorta thinking about how I would normally be a little annoyed at Krasimir for arguing about the description file name (although I _guess_ it does actually matter) but it's hard to get mad because he's been sending me code :)
11:44:10 <Marvin--> I still don't see why the hsproj people can't have their own foo.hsproj files but *also* parse the Setup.description file
11:45:25 <SyntaxNinja> two files?!
11:45:41 <SyntaxNinja> didn't you see simon's use case?
11:45:50 <SyntaxNinja> besides, why would we want to duplicate all that info?
11:48:36 <stepcut`> s
11:48:37 <Marvin--> why would it need duplication? Why can't the visual studio haskell plugin thingy parser open a second file and get the cabal fields?
11:49:42 <SyntaxNinja> Marvin--: but what's in the visual studio .hsproj file?
11:49:45 <SyntaxNinja> nothing?
11:49:48 <Marvin--> heck if I know
11:50:01 <Marvin--> visual studio-specific info that cabal doesn't care about?
11:50:11 <Marvin--> why would it matter what goes in which file if the user edits it via a GUI?
11:50:27 <SyntaxNinja> hm. thus far, the idea has been to put stuff like that in the .description file; that's why it ignores fields it doesn't know about.
11:50:55 <Marvin--> and that's something I never was comfortable with
11:51:01 <Marvin--> too typo-prone
11:51:40 <Marvin--> 'course, it could be done like debian/control file, prefix the field name with X-
11:52:46 <SyntaxNinja> true.
11:53:42 <SyntaxNinja> so what about when something in the .hsproj file over-rides the .description file?
11:53:49 <SyntaxNinja> like they add a module to the project.
11:53:57 <SyntaxNinja> I guess that would just go into the .description file.
11:54:05 <Marvin--> why couldn't the plugin add it to the .description file?
11:55:02 <SyntaxNinja> I'm kinda afraid of divergence, where something gets invented and put into VS's file, then we want it later in the .description file...
11:55:22 <SyntaxNinja> it also seems like we're adding this file just so VS can double-click on a file and have it open.
11:55:49 <Marvin--> isn't that *exactly* why they want it called hsproj?
11:56:41 <Marvin--> I'm pretty sure that eclipse, anjuta and kdevelop don't use ".hsproj"
11:56:47 <Marvin--> so what then?
11:56:55 <SyntaxNinja> VS doesn't use .hsproj, it's being altered to use it.
11:57:10 <SyntaxNinja> we can make it soemthing else, it's just that .description isn't very good in a global sense.
11:57:33 <SyntaxNinja> if eclipse _can't_ use .hsproj then that's another question.
11:58:11 <SyntaxNinja> if we change it to .hsproj, that's because we care about a world that cares about file extensions. that world is bigger than VS.
11:58:45 <Marvin--> I'm not even sure it makes sense in all kinds of IDEs, even plugin-based ones, to use a particular format for the file
11:59:05 <Marvin--> now, I've never used any of these IDEs so maybe I should just shut up
11:59:49 <SyntaxNinja> I've never used them either.  if other ides _can't_ use a particular format, then there's nothing we can do. but it seems like if we can accommodate those that do, just by changing the extension to something meaningful, well that's pretty reasonable.
12:00:25 <Marvin--> my whole point is that for some (possibly most) IDEs it probably makes a lot of sense to keep the "project" file separate from the cabal description file
12:00:45 <Marvin--> heck, different IDEs probably have wildly different ideas about what a "project file" is
12:03:49 <SyntaxNinja> Marvin--: and for those IDEs, there's no option but to use a different file. it seems that VS is very flexible in this way, and all we have to do is change the filename, which is probably a good idea anyway, in a world where the extensions matter.
12:14:31 <irsirius> can anybody tell me howto solve exercise 9.13 in thompsons haskell book?
12:15:28 <irsirius> "use foldr to define prelude 'last'"
12:16:50 <irsirius> is the solution just folding in the tail function or did i missunderstood it
12:17:06 <RussellOConnor_> irsirius: oooh, a bit tricky
12:17:46 <RussellOConnor> I suspect maybe people here can solve that problem.
12:18:14 <RussellOConnor> since foldr isn't tail recursive, that is probably not the right way of looking at the problem.
12:18:47 <RussellOConnor> have you read <http://www.haskell.org/hawiki/WhatIsaFold>
12:27:44 <pesco> irsirius: Have you had any success with that exercise?
12:27:52 <irsirius> no
12:27:57 <RussellOConnor> This problem is a bit tricker that I realized.
12:28:04 <RussellOConnor> s/that/than/
12:28:13 <pesco> I don't think it is. It's simple.
12:28:50 <pesco> Consider the list "abc". You're supposed to use foldr to define last, so that last "abc" = 'c'.
12:29:01 <pesco> @type foldr
12:29:02 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
12:29:26 <pesco> Are you allowed to use foldr1?
12:29:30 <bourbaki> isnt the last element the 0 element of that b?
12:29:31 <irsirius> no
12:29:41 <bourbaki> that is if its numbers then 0 and if its letters then "" ?
12:29:57 <pesco> irsirius: Are you sure?
12:30:00 <Smerdyakov> bourbaki, "zero element" is not a concept associated with fold functions.
12:30:03 <pesco> In that case I have to rethink.
12:30:55 <irsirius> yes, but he wrote foldr1 f (x:xs) = foldr f x xs
12:31:22 <bourbaki> Smerdyakov isnt the first argument supposed to be the last element?
12:31:31 <RussellOConnor> This seems as hard as pred is for church numerals.
12:31:59 <RussellOConnor> @type foldr1
12:32:00 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
12:33:12 <pesco> irsirius: "he" is Thompson? Then use that hint.
12:33:14 <RussellOConnor> are we allowed to use foldr more than once?
12:33:16 <Riastradh> No, it's actually trivial.
12:33:35 <pesco> Because with foldr1 it is trivial.
12:34:21 <RussellOConnor> I suspect it is impossible with only one use of foldr.
12:34:25 <pesco> Obviously, the input list will be the input list to foldr.
12:34:36 <pesco> RussellOConnor: Wrong.
12:34:49 <pesco> Or, foldr1 actually.
12:35:08 <pesco> Because last is undefined on empty lists anyway.
12:35:28 <pesco> So what's missing is the folding function given to foldr.
12:35:40 <RussellOConnor> Presumably (error "Empty List") needs to be returned on []
12:36:05 <pesco> last xs = foldr1 f xs
12:36:13 <pesco> Now look at what foldr1 does:
12:36:25 <pesco> If xs = [x1,x2,x3,...,xn]
12:36:57 <pesco> foldr1 f xs = (x1 `f` (x2 `f` ... (xn-1 `f xn)))
12:37:06 <pesco> You want the result to be xn.
12:37:12 <pesco> What should f be?
12:38:05 <pesco> f is applied to two arguments. Imagine it taking the last element of the list and combining it with the one before, then the result of that with the one before that, and so on.
12:44:13 <shapr> @yow !
12:44:13 <lambdabot> It's today's SPECIAL!
12:44:40 <Smerdyakov> RussellOConnor, it's easy to do this with foldr, but, at least as far as I see, you need a teeny bit of postprocessing on the result.
12:45:22 <shapr> hylo, how are you?
12:45:47 <bourbaki> well why dont you write f like that
12:46:15 <bourbaki> if the second argument of f is some special element (the one you mark the [] with) then you return that
12:46:20 <bourbaki> otherwise you return []
12:47:03 <RussellOConnor> Yeah, I think I can do it now, but it isn't pretty
12:47:06 <SyntaxNinja> hi shapr
12:48:03 <SyntaxNinja> fwiw, I asked a few questions on #eclipse, and we won't break anything by using Setup.hsproj
12:49:32 <bourbaki> RussellOConnor btw my diagonal line is now diagonal ;)
12:49:43 <RussellOConnor> bourbaki: excellent
12:50:43 <RussellOConnor> \l ->  (foldr (\x rec -> (rec (\a b -> b x) (\y a b -> b y))) (\a b -> a) l) (error "empty list") id
12:50:48 <RussellOConnor> sadly doesn't typecheck.
12:51:59 <bourbaki> RussellOConnor though it fails if i interpolate over more then one patch which is why i interpolate in two of the axis linear now and the z cubic
12:52:09 <bourbaki> wont that thing that i mentioned work?
12:52:53 <RussellOConnor> how do you check your special thing?
12:52:58 <RussellOConnor> null?
12:53:16 <RussellOConnor> Nothing?
12:53:36 <RussellOConnor> Are we allowed to use Maybe?
12:54:02 <RussellOConnor> @type maybe
12:54:04 <lambdabot> maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
12:54:19 <bourbaki> my idea was that the function i pass handles it
12:54:54 <bourbaki> foldr f 1 [...]
12:55:18 <bourbaki> and if f has a 1 as second parameter it enques that element in a list
12:55:25 <bourbaki> otherwise it enques []
12:56:38 <RussellOConnor> indeed, we should be able to simulate maybe with functions.  I was trying to do that.  I think I must have got it wrong
12:56:52 <RussellOConnor> \l -> maybe (error "empty list") id (foldr (\x rec -> maybe (Just x) Just rec) Nothing l)
12:56:58 <RussellOConnor> that works
12:57:37 <RussellOConnor> And I should be able to replace Just with (\x a b -> b x), and Nothing with (\a b -> a), and maybe with id.
12:58:04 <RussellOConnor> well maybe becomes \x y z -> z x y
12:58:22 <Marvin--> reinventing lambda calculus combinators, are we?
12:59:22 <RussellOConnor> But doing that substitution makes me not typecheck as before.
12:59:32 <bourbaki> so my idea wont work?
13:00:42 <RussellOConnor> in foldr f 1 [..] 1 has to be the same as the result type, so it only works on lists of integers.
13:01:40 <RussellOConnor> and it also doesn't work if 1 is somewhere in the list.
13:01:52 <bourbaki> ah ok you are right well i could tag the last element with some thing
13:02:08 <bourbaki> at least the overall idea is right right ?
13:02:20 <RussellOConnor> Well, it requires the use of something like Maybe.
13:02:30 <RussellOConnor> But I don't know if we are allowed to use Maybe.
13:02:41 <bourbaki> why would i need maybe?
13:02:53 <RussellOConnor> Smerdyakov, do you have a Maybeless solution?
13:03:12 <RussellOConnor> To make a special element that doesn't appear in the list.
13:03:53 <bourbaki> ahh ok
13:04:47 <Riastradh> Are you still trying to figure out how to define last in terms of foldr1?
13:05:23 <RussellOConnor> Riastradh: I thought the goal is to define it with foldr
13:05:24 <irsirius_> yes!
13:05:58 <Riastradh> You're making it _WAY_ too complicated.
13:06:37 <RussellOConnor> Riastradh: You have a solution using foldr?
13:06:55 <goron> Hmmm, this is interesting ROFL: http://www.gnu.org/prep/standards_7.html#SEC7
13:07:07 <Riastradh> Given that foldr1 is defined in terms of foldr, yes.
13:07:41 <RussellOConnor> how is foldr1 defined in terms of foldr?
13:07:43 <Riastradh> Horrible, isn't it, goron?
13:07:52 <Riastradh> foldr1 f (x:xs) = foldr f x xs
13:08:02 <RussellOConnor> Are we allowed to use pattern matching like that?
13:08:12 <Riastradh> You can just use head & tail.
13:08:22 <Riastradh> foldr f (head ys) (tail ys), for some f.
13:09:17 <goron> Riastradh: Yes, GNU should be more *openminded*.
13:09:42 <RussellOConnor> foldr f (foldr (\x y -> x) (error "empty") ys) (foldr (\x y -> y) (error "empty") ys)
13:09:49 <RussellOConnor> That's three foldr
13:09:58 <Riastradh> Nah, being based on open _source_ is enough already.  Anything more that's 'open' is too much.
13:10:58 <goron> Riastradh: Well, we can compile to C.  I wonder whether they can read that :)
13:12:24 <Marvin--> Riastradh: actually, I think foldr1 f [x] = x ; foldr1 f (x:xs) = f x (foldr1 f xs)
13:12:44 <Riastradh> @info foldr1
13:12:46 <lambdabot> -- foldr1 is a variable
13:12:46 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
13:12:55 <Riastradh> Bah.
13:12:58 <Marvin--> with foldr1 f (x:xs) = foldr f x xs, the "intuitive" solution doesn't work
13:13:26 <RussellOConnor> http://www.haskell.org/onlinereport/standard-prelude.html#$vfoldr1
13:13:36 <Riastradh> ...oh.
13:13:48 <RussellOConnor> Marvin--: It does work for this problem though.
13:14:29 <Marvin--> RussellOConnor: well, the solution using the prelude foldr1 is really, really simple
13:14:41 <Marvin--> the solution for 'last', that is
13:20:34 * RussellOConnor can't see how to define tail in terms of foldr.
13:21:11 <RussellOConnor> Are we allowed to use tail?
13:21:26 <irsirius_> yes
13:21:29 <RussellOConnor> oh
13:21:31 <Marvin--> the assignment is very unclear on what you're allowed to use :)
13:21:50 <Marvin--> I would hazard the guess that as long as you use foldr for all recursion, you're safe
13:22:12 <RussellOConnor> hmm, I suppose that is fail.
13:22:16 <RussellOConnor> s/fail/fair
13:25:33 <RussellOConnor> grrr, I still can't get it.
13:25:35 <RussellOConnor> *l*
13:25:49 <RussellOConnor> damn
13:26:40 <RussellOConnor> indeed the intuitive solution doesn't work.
13:26:44 <Marvin--> man, it's hot
13:26:46 <Marvin--> I need a beer
13:27:28 <RussellOConnor> I think I'll stand by my Maybe solution
13:27:39 <RussellOConnor> \l -> maybe (error "empty list") id (foldr (\x rec -> maybe (Just x) Just rec) Nothing l)
13:28:23 <Marvin--> yuck
13:28:53 <irsirius_> last :: [a] -> a
13:28:53 <irsirius_> last xs = foldr  cut [] xs
13:28:53 <irsirius_> 	where
13:28:53 <irsirius_> 	cut x y 
13:28:53 <irsirius_> 	 | null y 		= x
13:28:56 <irsirius_> 	 | otherwise	= y
13:29:40 <irsirius_> whats wrong with it?
13:29:51 <Cale> what is the type of cut?
13:30:35 <RussellOConnor> cut must be [a] -> [a] -> [a], which is bad.
13:31:47 <bourbaki> irsirius_ it seems that you started to like haskell :)
13:32:25 <irsirius_> i just started to HATE it :)
13:32:31 <bourbaki> hahaha
13:32:48 <Marvin--> irsirius_: it only works for last :: [[a]] -> [a]
13:33:28 <Marvin--> let { cut x [] = x ; cut x y = y } in foldr cut [] :: forall a. [[a]] -> [a]
13:34:10 <RussellOConnor> @type let { cut x [] = x ; cut x y = y } in foldr cut []
13:34:11 <lambdabot> let { cut x [] = x ; cut x y = y } in foldr cut [] :: forall a.
13:34:11 <lambdabot> 						      [[a]] -> [a]
13:34:15 <RussellOConnor> :-)
13:34:52 <RussellOConnor> @type \l -> maybe (error "empty list") id (foldr (\x rec -> maybe (Just x) Just rec) Nothing l)
13:34:54 <lambdabot> \l -> maybe (error "empty list") id (foldr (\x rec -> maybe (Just x) Just
13:34:54 <lambdabot> rec) Nothing l) :: forall a.
13:34:54 <lambdabot> 											     [a]
13:34:54 <lambdabot> 											     -> a
13:35:08 <Cale> you could just map return over the list before passing it to that [[a]] -> [a] version of last, and then take head of the result.
13:35:25 <Marvin--> Cale: unh
13:35:55 <Cale> who cares if it's horribly inefficient? :)
13:37:28 <Marvin--> RussellOConnor: you could replace that  \x rec -> maybe (Just x) Just rec  with  \x rec -> rec `mplus` Just x
13:38:01 <Marvin--> or even   mplus . Just
13:38:07 <Cale> \x rec -> rec `mplus` (return x)
13:38:13 <Marvin--> no, wait
13:40:27 <Marvin--> @type foldr (flip mplus . return) mzero
13:40:29 <lambdabot> bzzt
13:40:31 <Marvin--> meh
13:40:38 <Marvin--> @type foldr (flip Control.Monad.mplus . return) Control.Monad.mzero
13:40:39 <lambdabot> foldr (flip Control.Monad.mplus . return) Control.Monad.mzero :: forall
13:40:39 <lambdabot> m
13:40:39 <lambdabot> 									a.
13:40:39 <lambdabot> 								 (Control.Monad.MonadPlus m) =>
13:40:39 <lambdabot> 								 [a] -> m a
13:40:39 <RussellOConnor> @type \l -> maybe (error "empty list") id (foldr (\x rec -> rec `mplus` (return x)) Nothing l)
13:40:41 <lambdabot> bzzt
13:40:45 <RussellOConnor> ohh
13:41:02 <Marvin--> how's that for obscure
13:41:15 <RussellOConnor> that doesn't seem to be the same
13:41:35 <Marvin--> well, you need to do a fromJust, or head, or something on it
13:41:36 <RussellOConnor> @type \l -> maybe (error "empty list") id (foldr (\x rec -> rec `mplus` (return x)) mzero l)
13:41:38 <lambdabot> bzzt
13:41:59 <Marvin--> Control.Monad.mzero and Control.Monad.mplus
13:42:20 <RussellOConnor> @type \l -> maybe (error "empty list") id (foldr (\x rec -> rec `Control.Monad.mplus` (return x)) Control.Monad.mzero l)
13:42:21 <lambdabot> \l -> maybe (error "empty list") id (foldr (\x rec -> rec `Control.Monad
13:42:21 <lambdabot> mplus` (return x)) Control.Monad.mzero l) :: forall a.
13:42:21 <lambdabot> 														      [a]
13:42:21 <lambdabot> 														      -> a
13:42:26 <Marvin--> Control.Monad> head $ foldr (flip mplus . return) mzero "abcd"
13:42:26 <Marvin--> 'd'
13:42:32 <Marvin--> Control.Monad> fromJust $ foldr (flip mplus . return) mzero "abcd"
13:42:32 <Marvin--> 'd'
13:42:53 <Cale> sweet :)
13:42:56 <RussellOConnor> Marvin--> That's totally awsome
13:43:20 <Cale> That's abstraction for you :)
13:45:01 <Cale> maybe change head/fromJust to coreturn and it will be perfect :)
13:45:07 <RussellOConnor> Okay Marvin--: fromJust $ foldr (flip mplus . return) mzero "abcd" solution is in the lead.
13:46:05 <Marvin--> Cale: ... and will have unresolved overloading
13:46:26 <Marvin--> you'd have something like  (MonadPlus m, Comonad m) => [a] -> a
13:46:45 <Cale> unfortunate
13:48:31 <Cale> Almost makes me wonder if there should be default instances of classes to handle such cases. I'm sure they'd be horribly abused though.
13:48:58 <RussellOConnor> It makes me think that type signatures like (MonadPlus m, Comonad m) => [a] -> a should be allowed.
13:49:26 <RussellOConnor> Some syntax would be needed for you to explicity pass in the class.
13:49:27 <Marvin--> RussellOConnor: how? the type is ambigous
13:49:36 <Marvin--> well, there's the defaulting mechanism
13:49:38 <RussellOConnor> err pass in the instance.
13:49:40 <Marvin--> but it strikes me as ugly
13:49:57 <Cale> (MonadPlus m, Comonad m) => [a] -> a seems like it should reduce immediately to [a] -> a, as m isn't otherwise mentioned.
13:50:28 <Marvin--> but the whole reason that m is present in the context is because m is used in the *implementation* of the function
13:50:49 <RussellOConnor> The type (Exists m. (Monad m, Comonad m)) -> [a] -> a is a perfectly reasonable type.
13:51:11 <Cale> which m doesn't matter to the implementation
13:51:49 <RussellOConnor> Different m could change the behaviour of the functions.
13:52:18 <Marvin--> until we can put things like the monad laws into the type classes, the choice of m makes a big difference
13:52:57 <RussellOConnor> if instance MonadPlus Maybe had xs `mplus` ys = ys, the program wouldn't work.
13:53:16 <RussellOConnor> and that is a perfectly reasonable implemenation of Maybe as a MonadPlus.
13:53:58 <RussellOConnor> Even monad laws wouldn't help here.
13:54:02 <Cale> ah, suppose you have me there :)
13:55:47 <Cale> but yeah, the idea of being able to pass a type value in for m is neat
13:57:30 <RussellOConnor> I like the idea that one has a function that requires a stack implementation to run, and you can provide it whatever your favourite implemenation is.
13:57:36 <palomer`>  There is another reason why I would not recommend using Haskell; Haskell is a purely functional language, which can be great -- but it also will make the efficient implementation of certain algorithms such as unification, meta-variables etc harder and less efficient. Techniques such as destructive updates via references or exceptions are extremely elegant and efficient for implementing meta-variables, handling unification or o
13:57:36 <palomer`> ther data-structures needed. These concepts are not present in Haskel, since they are not purely functional. <---this is why my prof doesn't want to use haskell
13:57:56 <palomer`> anyone have a rebuttal 
13:58:25 <RussellOConnor> MArrays have destructive update.
13:59:30 <RussellOConnor> Actually with Monads, I find imperitive programming in Haskell even better than in imperative languages.
13:59:30 <Marvin--> palomer`: er, he won't recommend haskell because it's bad at *some* algorithms?
13:59:39 <Cale> Using a suitable monad will give you any of those features.
13:59:52 <Marvin--> palomer`: so... basically he doesn't recommend any languages at all?
13:59:56 <RussellOConnor> I love monads.
14:00:07 <Marvin--> I mean, if there was an ultimate language, we'd all be using it and there'd be no debate
14:01:20 <RussellOConnor>                  case (packetTag, packet) of
14:01:21 <RussellOConnor>                       (Right tag, Just p) -> return $ either fail return (evalState (runErrorT (consumePacket tag)) p)
14:01:23 <RussellOConnor>                       (Left error, Just p) -> return $ fail error
14:01:25 <RussellOConnor>                       (Right tag, Nothing) -> liftM return $ consumePacket tag
14:01:26 <RussellOConnor>                       (Left error, Nothing) -> fail error
14:01:28 <RussellOConnor> I wrote that the other day.
14:01:50 <RussellOConnor> :-)
14:01:50 <Cale> I love the data/computation duality which monads have. The ability to think of a verb as a noun and a noun as a verb is quite powerful.
14:02:16 <Cale> (as topologists will confirm)
14:02:22 <Marvin--> RussellOConnor: whoa, why not  do tag <- packetTag ; ... ?
14:03:04 <RussellOConnor> I can't figure out how to do what I said there with a do tag <- packetTag
14:03:10 <Marvin--> return $ fail error
14:03:12 <Marvin--> ... eh?
14:03:30 <RussellOConnor> parsePacket :: (MonadConsumer Word8 m, Monad n) => m (n Packet)
14:03:39 <RussellOConnor> parsePacket = do (packetTag, lengthType) <- consumePacketTag
14:03:40 <Marvin--> yikes
14:03:41 <RussellOConnor>                  packet <- pullRawPacket lengthType 
14:03:43 <RussellOConnor>                  case (packetTag, packet) of
14:03:45 <RussellOConnor>                       (Right tag, Just p) -> return $ either fail return (evalState (runErrorT (consumePacket tag)) p)
14:03:46 <RussellOConnor>                       (Left error, Just p) -> return $ fail error
14:03:48 <RussellOConnor>                       (Right tag, Nothing) -> liftM return $ consumePacket tag
14:03:49 <RussellOConnor>                       (Left error, Nothing) -> fail error
14:03:51 <RussellOConnor> I'm so pleased.
14:04:10 <RussellOConnor> if the other monad fails, you are screwed.
14:04:24 <RussellOConnor> if the inner monad fail, you can continue.
14:04:43 <palomer`> Marvin--: this is my automated reasoning course
14:05:19 <RussellOConnor> I bet there is a beautiful Haskell implementation of unification out there somewhere.
14:05:21 <Marvin--> palomer`: oh, so it's in a specific context, not in general
14:06:02 <RussellOConnor> @type either fail return
14:06:03 <lambdabot> either fail return :: forall m b.
14:06:03 <lambdabot> 		      (Monad m) =>
14:06:03 <lambdabot> 		      Either String b -> m b
14:06:05 <Marvin--> the THIH implementation of unification looks good iirc, but I have no idea how efficient it is
14:06:12 <RussellOConnor> I like that function.
14:07:14 <Marvin--> I have an implementation of unification somewhere that I used as example input for my h2fol project
14:07:15 <RussellOConnor> I think I might be able to do a bit better than what I have by using monad transformers.  I need to spend more time on it.
14:07:35 <Marvin--> that one's fairly obscure though, as it was limited to what parts of haskell my program could parse :-)
14:09:39 <Marvin--> RussellOConnor: do you have any good reason at all to wrap a monad in another monad?
14:15:42 <RussellOConnor> It is more general than m (Maybe Packet)
14:16:04 <RussellOConnor> It is more general than m (Either String Packet)
14:17:26 <Marvin--> what's wrong with m Packet?
14:18:11 <RussellOConnor> even if m (Maybe Packet) returns nothing, I can handle that condition and keep using m.
14:18:22 <RussellOConnor> Otherwise m Packet would fail, and processing inside m would stop.
14:18:41 <Marvin--> so make m an instance of MonadError
14:19:05 <RussellOConnor> Hmmmm
14:20:24 <RussellOConnor> That could work
14:20:49 <Marvin--> and use throwError and catchError, and lift
14:20:55 <RussellOConnor> I'd have to catch some errors, but not others.
14:21:48 <RussellOConnor> so I would have to make my own error data type, but it could be done.
14:22:18 <RussellOConnor> That could possibly look nicer.
14:22:40 <Marvin--> you could write something like catchJust for the MonadError framework (rather than the one for IO)
14:34:26 <RussellOConnor> either error id $ foldr (flip mplus . return) mzero "abcd"
14:36:28 <RussellOConnor> foldr (flip mplus . return) mzero "abcd" >>= print
14:37:37 <Marvin--> stop with the either crud :-)
14:37:54 <RussellOConnor> There is no fromRight function.
14:40:56 <RussellOConnor> head $ foldr (\x y -> y++[x]) [] "abcd"
14:41:06 <RussellOConnor> ah
14:41:12 <Riastradh> Ewww!
14:41:17 <RussellOConnor> it all becomes clear now.
14:41:23 <Riastradh> Die, O(n^2), die!
14:41:25 <RussellOConnor> mplus == ++
14:41:32 <RussellOConnor> return = \x -> [x]
14:41:38 <RussellOConnor> mzero == []
14:41:50 <RussellOConnor> This is totatly the same solution.
14:42:00 <RussellOConnor> at least for the list monad.
14:42:10 <Riastradh> Yes, and your Either/MonadZero/etc thing was just as 'Ewww'-worthy.
14:42:26 <Marvin--> I never claimed that it was efficient :-)
14:42:29 <Riastradh> I like the, uh, simple foldr1 solution.
14:42:41 <Marvin--> me too, but unfortunately it doesn't meet the spec
14:42:43 <RussellOConnor> Isn't the fromJust solution O(n) ?
14:42:50 <Riastradh> last = foldr1 (flip const)
14:43:07 <Riastradh> Even if you have to use foldr, I prefer the simple Maybe solution:
14:43:18 <Riastradh> ...er, that was supposed to be a period, not a colon.
14:43:26 <Riastradh> It duplicated itself, nasty bugger!
14:43:32 <Marvin--> which is the "simple" Maybe solution?
14:43:58 <RussellOConnor> Both the fromJust $ ... and either error id $ ... are O(n) I think.
14:44:08 <RussellOConnor> head $ ... is O(n^2)
14:44:22 <Marvin--> Riastradh: fromJust . foldr (flip mplus . return) mzero ?
14:44:45 <Riastradh> Yes, Marvin--.
14:45:11 <Marvin--> still pretty cryptic :-)
14:48:06 <RussellOConnor> irsirius: <Marvin--> fromJust . foldr (flip mplus . return) mzero, in case you missed it ;-)
15:12:42 <pesco> "[...] but using GUILE is very important for the overall consistency of the GNU system."
15:12:46 * pesco snickers.
15:15:05 * pesco clears his throat and switches to a deep, intoned, and serious voice.
15:15:54 <pesco> But using HASKELL is very important for the overall well-being of athletes nationwide.
15:15:55 <Marvin--> pesco: so? None of us are hacking on the GNU system, are we?
15:17:03 <pesco> Marvin--: I don't know about everyone else. I'm hacking on the, lemme think of a name, system.
15:17:44 <Marvin--> :)
15:17:59 <pesco> I'm just poking fun at the GNU coding standards. Which are not all bad, mind you.
15:18:08 <Marvin--> that howto is so old it's silly
15:19:20 <pesco> Man, what should I call my system! I think I might call it DOS or something. Heh. Heh.
15:19:42 <Marvin--> pescOS
15:19:54 <pesco> "This is my DOS bawx..."
15:20:02 <Marvin--> "the pesky OS"
15:20:11 <pesco> Now that's just silly!
15:20:24 <Marvin--> and "GNU" isn't?
15:20:52 <pesco> Hell no!
15:21:11 <pesco> Well, Plan 9 is still my favourite.
15:24:12 <pesco> Oh, Bingo! Well, see (the deep intoned voice again) this is the BINGO system. It's highly sophisticated anti-matter real-time randomness suspension ensine effects to an overall dishwasher of 390 gigawatts per ampersand.
15:24:49 <Smerdyakov> Go ensine!
15:26:13 <pesco> Note to self: Remember the *ampersand* as unit of measurement for something important.
15:27:38 <shapr> pointers?
15:29:08 <pesco> Yes! That's it shapr! The length of a pointer! Measured in ampersands.
15:29:55 <Marvin--> the length of a pointer? *lol*
15:30:28 * pesco grins around prowdly.
15:30:31 <stepcut> shapr: where is the latest source for lambdabot at ? 
15:31:37 <pesco> Wheah, get that rap out of my head!
15:31:59 <Cale> Where mah source is at?
15:32:13 <pesco> Where it's at! (whoere ids ad) - Where it's at!
15:33:38 <shapr> got two turntables and a microphone
15:33:50 <pesco> Yes!
15:33:58 <shapr> bottles and cans just clap your hands
15:34:04 <dnm> Hey shapr.
15:34:09 <shapr> hiya dnm, wassup?
15:34:22 <pesco> ("That guy off in whoses trailer they were wackin!")
15:34:23 <shapr> stepcut: I have local source that's not yet available, I'll make it available...
15:34:32 <pesco> s/whoses/whose/
15:36:05 <np_hard> shapr: that was a good drum break!
15:36:26 <stepcut> shapr: no rush
15:37:10 <pesco> Good night everyone. I need sleep.
15:37:34 <Marvin--> excellent idea
15:37:42 <dnm> shapr: Not much. Got a job offer today. Going in tomorrow at 3 PM to talk terms.
15:40:08 <shapr> dnm: how's the EFF?
15:43:16 <irsirius_> RussellOConnor: thanks, i dont get it yet, maybe later...
15:47:06 <np_hard> dnm: ooh, congrats
15:47:25 <np_hard> always good to hear about employment
15:54:28 <dnm> shapr: Heh. I haven't been at the EFF since early March. I could have sworn I told you. ;]
15:54:36 <shapr> ah, I missed that.
16:30:20 <stepcut> make pisses me off
16:30:54 <stepcut> it can' handle spaces in filenames in a reasonable manner >:[
16:31:01 <stepcut>             t
16:31:11 <stepcut> doh
16:31:35 <Cale> wow, that 't' moved a long way
16:31:37 <Cale> :)
16:32:01 <stepcut> maybe I should just rewrite my makefile in prolog or something ...
16:32:28 <Smerdyakov> Or use the SML/NJ Compilation Manager!
16:32:46 <stepcut> Smerdyakov: is that useful for non sml projects?
16:32:54 <Smerdyakov> I think so.
16:32:59 <Smerdyakov> I don't know the details, though.
16:33:07 <stepcut> hrm
17:56:04 <palomer`> I've been thinking...why does parsing need to be modal?
17:56:14 <palomer`> why not describe a grammar, and then have a function return the parse tree?
17:57:44 <Smerdyakov> I don't understand what you're saying.
18:06:29 <emu> parsing is modal?
18:27:23 <stepcut> gah! Make sucks
18:41:37 <stepcut> gnu is crap
18:50:22 <emu> gee whiz
20:04:54 <ihb> hi. does anyone have a good reference on n+k patterns?
20:05:10 <Cale> the report?
20:05:13 <Smerdyakov> Oh, I think I have one right here: Don't use them!! ;D
20:05:27 <ihb> Smerdyakov: why not?
20:05:43 <Smerdyakov> It seems like a silly kludge to me.
20:05:46 <Cale> yeah, it seems universally accepted that they shouldn't be used.
20:05:56 <Cale> except for a small group which fights on
20:06:07 <Smerdyakov> And NO ONE can defeat on.
20:06:27 <Smerdyakov> Not even Superman and Batman tied together
20:06:29 <ihb> I, who doesn't know what they really are, isn't much wiser now than I was before. :-)
20:07:56 <Cale> i.e. you can say  f 0 = 1; f 1 = 1; f (n+2) = f n + f (n+1)
20:08:16 <Cale> but it only works with + a constant
20:09:07 <ihb> Cale: are they disliked because they're exceptional and doesn't fit since it's not "true" pattern matching?
20:09:15 <Cale> yeah
20:09:33 <Smerdyakov> Also, they're equivalent to code that is just about as compact.
20:10:26 <ihb> how does it work, under the hood? is it just sugar for "f 0 = 1; f 1 = 1; f m = f n + f (n+1) where n = m - 2"?
20:10:31 <Cale> And it's not really a general idea - it would be sort of neat if you could override arbitrary function applications in patterns, but that's not what this is, and there are likely bad problems with that anyway.
20:10:56 <Smerdyakov> ihb, I think so
20:15:09 <ihb> so over to my next question: when would you need/want/use Y combinators? (any doc reference is also appreciated)
20:17:02 <Smerdyakov> Never, if you're talking about in real programming.
20:17:35 <Cale> http://en.wikipedia.org/wiki/Y_combinator
20:22:11 <ihb> seems i should read up some on lambda calculus first.
20:22:51 <Smerdyakov> That is assuming that you have reason to believe that you ought to care about this. :)
20:23:35 <Cale> Smerdyakov: don't discourage people from learning some lambda calculus :)
20:24:02 <Smerdyakov> Hey, everybody. If you learn some lambda calculus, I'll send Cousin Vinny to break your legs.
20:24:40 <ihb> haha
20:24:54 <ihb> why wouldn't i want to learn lambda calculus?
20:25:13 <Cale> ihb: the only reason I can think of is Cousin Vinny
20:25:18 <ihb> i have a bad habit of learning things that are completely useless but happened to intrigue me at the moment.
20:25:43 <ihb> (and occasionally i have use for it in the future in some totally unforseen way)
20:26:51 <Cale> Just getting a working knowledge of how lambda expressions reduce would be a good idea.
20:27:11 <Smerdyakov> Lambda calculus is good to know, but the Y combinator is of no practical use, as far as I can tell. Some bastards published a paper with a contrived "real world" example for it, but I think that's safely ignored.
20:27:32 <ihb> haha
20:27:59 <Cale> The Y combinator lets you express anonymous recursive functions.
20:28:23 * Smerdyakov pictures "Be here at 9:00 for a recursive function" scrawled on a public restroom stall.
20:28:27 <Cale> but nobody does this in a real programming language, because it's a bit unweildy.
20:29:28 <Smerdyakov> Cale, 'i' before 'e', except after 'c'.
20:29:38 <ihb> this is probably the wrong channel to ask in, but which language would you recommend if i know basic haskell but want to learn more functional programming?
20:29:53 <Smerdyakov> ihb, why do you want to learn more? Do you want to use functional languages to do something?
20:29:56 <Cale> Smerdyakov: yeah, noticed that
20:30:08 <ihb> Smerdyakov: is that possible? ;-)
20:30:15 <Cale> ihb: sure
20:30:16 <Smerdyakov> ihb, I'm trying to get you to name that something.
20:30:26 <ihb> Smerdyakov: probably more academical than practical study.
20:30:31 <Riastradh> Smerdyakov, and when sounding like 'a,' as in 'neighbour' and 'weigh,' or in weird words such as weird, being, seeing, seize, seizure, ancient, foreign, science, society...
20:31:04 <Smerdyakov> ihb, well, I recommend ML for practical programming. Haskell is a good choice if you have a purely academic/theoretical interest.
20:31:34 <Cale> heh, if it was spelled sieeng just to follow the rule, I think we'd all go nuts
20:31:42 <ihb> what about this ever favour Lisp?
20:32:16 <Smerdyakov> ihb, it's a favorite of questionable characters who lurk in alleyways.
20:32:50 * Riastradh sneaks up from a dark alleyway behind Smerdyakov, hits him over the head sharply and quickly, steals all his money, and lurks back into the shadows.
20:32:57 <ihb> err, can't write while distracted, "favour = popular".
20:33:56 <Smerdyakov> Lisp and Scheme are divorced from traditional mathematics, which is pretty much always strongly typed, even if practitioners don't realize it.
20:34:09 <Riastradh> Scheme and most other Lisps _are_ strongly typed, Smerdyakov.
20:34:09 <Smerdyakov> Rather, statically typed
20:35:53 <ihb> Smerdyakov: what would be the difference between a statically typed language, and a dynamically typed, and a strongly typed?
20:36:20 <Riastradh> Static versus dynamic typing has to do with when type checks occur.
20:36:37 <Riastradh> Strong versus weak typing has to do with whether or not _un_checked errors can occur.
20:36:42 <monochrom> strong vs weak typing has to do with how draconian the checks are.
20:36:47 <Riastradh> E.g., C has a static and weak type system.
20:37:06 <Riastradh> Scheme and most other Lisps have dynamic and strong type systems.
20:37:54 <ihb> not knowing any Lisp that example doesn't provide much value for me. :-)
20:38:08 <Riastradh> Haskell has a static and strong type system.
20:38:08 <ihb> Riastradh: is C weak because you can do type casts?
20:38:28 <Riastradh> Yes, and thereby operate on unchecked data.
20:38:41 <Smerdyakov> C is weak because you can cause segfaults with C programs.
20:40:17 <ihb> what would an example of a language with strong and dynamic typing be?
20:40:38 <monochrom> Java
20:40:46 <monochrom> Err, actually no :)
20:40:50 <Riastradh> Vaguely.  Java's type system is screwey.
20:41:01 <Cale> Python, iirc.
20:41:06 <Riastradh> Python would be an example of a strongly & dynamically typed language.
20:41:08 <Riastradh> Bah, Cale!
20:41:10 <monochrom> Well, some type checking in Java is static and some is dynamic.  But yeah python would be it.
20:41:19 <ihb> Riastradh: how's Java's type system screwey?
20:42:33 <ihb> can anyone provide a short snippet of python that would demonstrate the dynamic part of the typing? or perhaps #python is more appropriate.
20:43:22 <ihb> "f :: a -> a" feels like a dynamic type, but i guess it isn't.
20:43:34 <ihb> as haskell is static.
20:43:52 <ihb> so i guess i don't understand what dynamic typing really means.
20:43:55 <Cale> ihb: dynamic just means that the type is checked at runtime, remember
20:44:16 <Cale> rather than at compile time
20:45:11 <ihb> oooh, right. i confused it all up.
20:45:49 <ihb> fudge, 6 am here, i need sleep instead of this.
20:46:11 <monochrom> Relax
20:46:16 <monochrom> Close your eyes.
20:46:20 <monochrom> Relax
20:46:24 <ihb> haha
20:46:43 <monochrom> Now you are back when you are 5 years old.
20:46:53 <ihb> just let me turn on the speech module ;-)
20:47:00 <monochrom> What is the colour of your room?
20:47:03 <Cale> RELAX VERY LOUDLY!
20:47:14 <ihb> i wouldn't know, i'm colorblind ;-)
20:47:28 <monochrom> This is no fun.
20:47:31 <Cale> RELAX TO THE SOOTHING SOUNDS OF SCREAMING!
20:47:42 <ihb> haha
20:48:00 <ihb> anyway, thanks for all the help, appreciate it.
20:48:08 <Cale> see you around
