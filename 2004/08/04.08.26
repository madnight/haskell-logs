01:02:42 <stefan_> Pseudonym: implicit configuration? that's about type classes representing values, isn't it? it's still on my "to read" list ... I'll have a look at it
02:26:38 <musasabi> When compiling CVS ghc I get "cmm/MachOp.hs:9: Variable not in scope: `cIntRep'"
02:28:20 <musasabi> found it and solved it...
02:49:18 <goron> Is it possible to profile something while it operates?
02:51:22 <musasabi> have you read the profiling section?
02:57:28 <Igloo> You can only profile it after it finishes last I checked
03:14:38 <shapr> anyone else here using apache2-mpm-worker in debian/unstable ?
03:19:06 <Boegel> still not solved your problem shapr ?
03:19:40 <shapr> actually, it seems to work now.
03:19:55 * shapr is confused
03:20:28 <_Boegel_> confused, why shapr ?
03:21:03 <shapr> because I don't know what was wrong before.
03:21:36 <_Boegel_> there's _alwyas_ a logical cause to a problem
03:21:44 <_Boegel_> you only have to find it :p
03:23:04 <shapr> yes, I agree.
03:23:44 <_Boegel_> I've been messing with a bug lot's of times
03:23:49 <_Boegel_> even for a few days
03:24:00 <shapr> yah, same here.
03:24:03 <_Boegel_> but there hasn't been one yet which I didn't find
03:24:23 <shapr> there have been some where my boss told me to give up on it and just work around it.
03:25:28 <musasabi> are there any cvs source snapshots of ghc?
03:26:34 <_Boegel_> I don't have a boss yet, so :p
03:29:51 <shapr> musasabi: there's the ghc-cvs debs, that's all I know of
03:29:54 <_Boegel_> is lambdabot back already ? I would like to see it in action
03:33:36 <musasabi> shapr: using BSD so no help there...
03:33:49 <musasabi> unless I would scavenge their source...
03:39:11 <musasabi> cvs just doesn't scale...
03:40:20 <shapr> hi Oejet 
03:40:29 <shapr> musasabi: darcs scales nicely
03:40:56 <Oejet> shapr: Hello to you.
03:40:56 <shapr> _Boegel_: tada
03:41:16 <musasabi> shapr: but there is no darcs repository out of fptools...
03:41:47 <_Boegel_> *juij* :p
03:41:53 <musasabi> shapr: basicly I just want to maintain local changes to a large source tree in many projects, which is very very painfull.
03:41:56 <_Boegel_> now, how do you use this thing ?
03:43:22 <musasabi> e.g.
03:43:36 <musasabi> @index lookup
03:43:37 <lambdabot> Data.HashTable,Data.List,GHC.List,Prelude,List
03:43:52 <musasabi> @type Data.List.lookup
03:43:57 <lambdabot> Data.List.lookup :: forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
03:44:02 <musasabi> _Boegel_: like that ;)
03:45:38 * musasabi waits whether fptools cvs update might over anytime soon
03:48:45 <shapr> musasabi: you could use lelit's cvsync, it creates darcs patchsets from cvs updates
03:49:24 <shapr> actually, maybe I should try to do that on ScannedInAvian
03:49:51 <musasabi> shapr: that means that I have to have a cvs tree alongside?
03:52:06 <musasabi> a simple cvs update takes ages to run... even if there are *no* changes.
03:54:21 <Si\> Question: why can't I do this;
03:54:27 <Si\> class A a where h :: a -> String
03:54:27 <Si\> instance A Int where h = show
03:54:27 <Si\> class C a where f :: (A b) => (b -> String) -> a -> String
03:54:27 <Si\> instance C Int where f g x = (show x) ++ (g x)
03:56:03 <shapr> musasabi: I think anonymous cvs is updated nightly, so I could make a current anon cvs darcs repo available without too much trouble.
03:56:20 <shapr> or alternatively, I could get a 'real' cvs account and do more regular updates.
03:56:41 <shapr> darcs uses a lot less bandwidth too.
03:57:12 <musasabi> Si\: because (x :: a (= Int)) but the function g is of the type (A b) => b -> Int perhaps.
03:57:19 <Igloo> Are you sure about that?
03:57:34 <Igloo> I'd expect CVS to use O(number of files) and darcs to use O(number of patches) bandwidth, I think
03:58:48 <Si\> Yes, but b is a polymorphic type and the restriction A is satisfied for Int
03:58:58 <musasabi> O(number_of_directories + number_of_files_in_changed_directories) would be saner...
03:59:12 <musasabi> Si\: but is that enough?
03:59:18 <musasabi> Si\: what is the error message?
03:59:39 <Si\>     Cannot unify the type-signature variable `b' with the type `Int'
03:59:39 <Si\>         Expected type: b
03:59:54 <Si\>         Inferred type: Int
03:59:54 <Si\>     In the first argument of `g', namely `x'
04:02:25 <musasabi> you could try: f :: (forall b. (A b) => (b -> String)) -> a -> String
04:02:30 <goron> I have a user nobody on my system, is that normal?
04:02:37 <musasabi> goron: yes.
04:02:38 <earthy> yes.
04:02:53 <goron> It's eating all my cpu cycles...
04:03:03 <earthy> runaway daemon
04:03:08 <musasabi> hmm ghc configure tells me:
04:03:12 <musasabi> config.status: error: cannot find input file: mk/config.h.in
04:03:15 <goron> runaway?
04:03:33 <earthy> goron: look at what processes are running as nobody
04:03:43 <goron> find was running
04:03:46 <earthy> there is probably one that has gone haywire, processing and processing
04:03:57 <musasabi> goron: wait 5minutes.
04:04:03 <musasabi> it might be a cronjob.
04:04:11 <musasabi> e.g. updating the locate database.
04:04:18 <earthy> musasabi: that shouldn't be CPU-bound
04:04:19 <goron> it already stopped. And what's famd?
04:04:48 <goron> Also a demon probably.
04:04:48 <earthy> goron: what OS?
04:04:57 <goron> Debian/GNU Linux 
04:05:33 <musasabi> file alteration monitor daemon perhaps
04:05:38 <earthy> perhaps
04:05:39 <Si\> ok, that's one problem sorted; thanks musasabi, I thought it must be to do with existential types but I have never really understood where to put the foralls
04:06:16 <_Boegel_> I'm gone again, bye peoplez
04:06:24 <musasabi> see you later
04:07:03 <goron> File Access Monitor daemon (famd)
04:07:08 <goron> Google is great..
04:07:54 <earthy> oh yes it is
04:09:18 <musasabi> How do I get the config.h.in ?
04:09:25 <musasabi> That does not exist in the cvs...
04:14:42 <musasabi> running the configures in a weird order seems to help along with patching the build system..
04:14:54 <musasabi> but it still crashes :-(
04:15:04 <musasabi> config.status: creating mk/config.h
04:15:04 <musasabi> config.status: error: cannot find input file: mk/config.h.in
04:17:59 <musasabi> gmake -f Makefile.config config.h.in
04:18:03 <musasabi> created it ^_^
04:23:07 <musasabi> now building and praying once more.
04:23:41 <Si\> Can anyone think of anyway of (without using undecidable instances) having type class function of the form f :: (b -> C) -> a -> C and making b and a have the same set of constraints which are calculated dynamically, depending on the type of b, but without b being unified with the type of a?
04:25:21 <musasabi> Si\: I had a quite similar situation and ended up using class (Data a) => TClassify a where ap   :: (Int -> b) -> (forall c. (TClassify c) => [c] -> b) -> (a -> b) -> a -> b
04:25:43 <musasabi> but then again that didn't work in the end the way I wanted.
04:26:23 <musasabi> In the end my solution was "let's use cvs ghc it can do neat stuff and we don't need stupid typeclasses"
04:27:33 <musasabi> My real problem was that there is no way to create a supertype for an existing type class.
04:27:44 <Igloo> musasabi: Did you run autoreconf first?
04:28:13 <musasabi> Igloo: I tried to follow building.pdf
04:28:19 <musasabi> but now it seems to compile.
04:28:20 <Si\> Essentially what I'm trying to do is build a system where any particular type can be serialized, but also one can pass an extra function to the serializer such that if all the types down the type-tree subscribe to a further set of constraints, extra data can be inserted into the serialization tree using those constraints
04:28:40 <musasabi> part of the problem is that I am using Dragonfly -> need to patch all configure scripts.
04:29:03 <musasabi> Si\: I am doing essentially the same thing.
04:29:15 <Si\> I don't care how many hacks I have to use, as long as it's scalable and source can be generated for new types easily
04:29:51 <Si\> so how does the GHC CVS solve your problems?
04:29:51 <musasabi> Basically I have found ext1R to be the way to go.
04:30:07 <musasabi> Si\: I have yet to get it compiling on my platform...
04:31:11 <musasabi> Si\: 6.2 dpes not make a simple way to express other constraints than "is of concrete type X", while one can do neat stuff with ext1R as in cvs...
04:31:33 <musasabi> Si\: I can tell you about my results when I get things working...
04:31:40 <Si\> is there any docs on ext1R?
04:31:53 <pesco> Ahoi.
04:31:58 <musasabi> Si\: http://www.cs.vu.nl/boilerplate/testsuite/xmlish/Main.hs
04:32:06 <musasabi> (and the source code of course)
04:33:01 <musasabi> in the data -> xml you would probably use ext1Q and in the xml -> data ext1R.
04:33:54 <Si\> are these ext things part of Data.Generics?
04:34:06 <musasabi> yes, but not of 6.2.
04:34:25 <musasabi> 6.2. has simple ext things which are not enough for interesting cases.
04:34:56 <musasabi> basically you want to have ext combinators which can be used with Typeable1 type constraints.
04:41:58 <musasabi> next on our list:
04:41:59 <musasabi> Interpreter.c: In function `interpretBCO':
04:41:59 <musasabi> Interpreter.c:405: syntax error before `const'
04:41:59 <musasabi> Interpreter.c:405: `info' undeclared (first use in this function)
04:51:08 <goron> Do you often optimize in Haskell when you are building a *serious* program? 
04:52:29 <musasabi> goron: usually I profile and find a few functions taking 85% of time, change a few lines and have a fast program ;)
04:53:14 <musasabi> Any idea on the ghc build error?
04:56:04 <goron> musasabi: I built ghc a couple of times. What does it say?
04:57:19 <musasabi> goron: http://youzen.b2.fi/~musasabi/t.txt (the error message)
04:58:42 <goron> musasabi: What compiler do you use?
04:58:50 <Igloo> musasabi: You never said if you ran autoreconf first
04:59:15 <goron> musasabi: It should build with 3.4.1 although I didn't test it. 
04:59:18 * Igloo hasn't looked, but it's possible that problem is caused by config.h being wrong due to your config.h.in problems
04:59:31 <goron> musasabi: I tried it with gcc-3.3.3
04:59:45 <goron> musasabi: And that worked a couple of weeks ago.
04:59:49 <musasabi> goron: gcc3.4 dies on my machine with ICEs...
04:59:54 <musasabi> so I am using 2.9
05:00:20 <musasabi> will try using gcc3.4 for that specific place
05:00:30 <goron> musasabi: ICE? My acronymdatabase is lacking...
05:00:57 <goron> I understand it
05:01:00 <musasabi> goron: internal compiler error.
05:01:12 <goron> musasabi: I already derived it :)
05:01:20 <musasabi> seems gcc3.4 can compile that file...
05:01:32 <musasabi> now to interspede gcc versions on different parts...
05:01:39 <goron> musasabi: I had them in gcc-3.3.3 a couple of times. 
05:02:42 <goron> musasabi: I think it costs too much time to get it compiling. They should have better compilation instructions. 
05:04:27 <musasabi> well I am using an unsopperted platform to add to the "fun".
05:06:00 <musasabi> this looks promising...
05:07:04 <Si\> musabi: Does HaXML support namespaces yet?
05:07:30 <goron> musasabi: Are you trying to compile it on your iPod? lol
05:07:49 <musasabi> goron: on DragonFly (FreeBSD fork)
05:08:06 <goron> musasabi: Oh, yeah, that was you. You said that once.
05:14:37 <musasabi> What is the correct value for READDIR_ERRNO_EOF ?
05:14:37 <goron> Does anyone knows of an efficient nub operation?
05:17:34 <shapr> hi vidvandre 
05:17:41 * shapr boings randomly
05:20:44 <goron> Is there a nub function that has < O(n^2) running time?
05:23:06 <Igloo> Only if your elements have an ordering
05:24:37 <goron> Hashes would work, imo. 
05:25:19 <Igloo> Hashes only give you a constant factor
05:26:29 <musasabi> hmm still need iterations - > ghci t.hs
05:26:29 <musasabi> ghc-6.3: not built for interactive use
05:27:28 <Igloo> make should do a 2 stage build for you these days
05:31:57 <goron> Igloo: You could built a tree in which you trow the values and the moment you want to put in a duplicate, you don't put it in. And then extract all values. This is O(n log n)
05:32:27 <Igloo> You need an ordering for that
05:32:43 <Igloo> Well, either that or search the whole tree in O(n^2)
05:33:08 <goron> Igloo: Oh, I interpreteted you wrong. 
05:33:31 <vidvandre> hi shapr
05:33:32 <goron> Igloo: Does this list have to be ordered, or must they be of type (Ord a)?
05:34:54 <Igloo> Of type Ord a, where that actually gives you the right sort of order (a /= b  =>  a < b && b > a || b < a && a > b)
05:35:03 <Igloo> If the list is ordered you can do it in O(n) time
05:38:29 <goron> @index order
05:38:29 <lambdabot> bzzt
05:40:37 <goron> Igloo: Oh, ok, you just defined what "order" meant.  lol
05:41:14 <earthy> *phew*
05:41:34 <earthy> wiping /Applications in MacOS X is not smart
05:41:39 <Igloo> Heh
05:41:39 <earthy> but not really deadly either
05:42:10 <earthy> (I figured out that the rm was taking too long just about early enough to not have that pose any problems :))
05:45:06 <shapr> vidvandre: learning Haskell?
05:45:37 * Igloo whimpers at http://www.zend.com/manual/function.create-function.php
05:47:38 <goron> Igloo: That's to keep people away from fp...
05:50:01 <vidvandre> shapr: yes.. reading "Yet Another Haskell Tutorial" :)
05:50:29 <musasabi> Si\: the boilerplate example works with haskell ghc fine.
05:50:51 * musasabi gave up on compiling the beast and uses the debian package.
05:51:37 <shapr> vidvandre: have any questions?
05:51:42 <shapr> withersoever: are you learning Haskell also?
05:51:47 <stefan_> kosmikus: pff ... just printed your thesis ... if you ever write a bookish thing again, could you keep it below 200 pages? ;)
05:51:56 <vidvandre> not yet :)
05:51:56 <shapr> Igloo: that's a terrifying url
05:52:10 <shapr> vidvandre: if you think of any questions, feel free to ask
05:52:23 <vidvandre> shapr: thanks :)
05:52:31 <withersoever> shapr, just observing.
05:52:48 <shapr> withersoever: seen anything interesting yet?
05:53:04 <shapr> Igloo: maybe <?haskell ?> would be better.
05:53:37 <withersoever> shapr, the php link was interesting... perhaps more repulsive than interesting.
05:53:52 <Si\> musasabi: Could you go about expressing which function should be used based on the constraints on a parameter?
05:55:13 <Igloo> Indeed - please write it!
05:57:46 <musasabi> Si\: I think so, too early to say anything definite.
06:02:41 <Si\> You'd need to be able to store constraints in Typeable and then if the set of constraints on the given value equaled the set of constraints on the given function return Just b, else Nothing
06:05:17 <kosmikus> stefan_: you can have a printed copy
06:05:42 <kosmikus> stefan_: I just forgot to give you one yesterday, but I thought it would be obvious that you get one ;)
06:07:18 <stefan_> kosmiskus: cool, thanks ... don't know whether it's obvious ;) ... but I'm very grateful though
06:09:58 <arjanb> kosmikus: trying to setting a trend with these funny pictures in your thesis? ;)
06:10:10 <musasabi> hmm got ghc to crash...
06:11:18 <stefan_> musasabi: where you trying to make it crash?
06:11:35 <shapr> the pictures in kosmikus' thesis area really cool.
06:11:40 <shapr> "are"
06:13:17 * shapr behover lite hj√§lp med bokstaver...
06:14:00 * musasabi tries to reproduce it.
06:14:18 <musasabi> stefan_: you could say that (trying to mix existentials and generics)
06:14:22 <kosmikus> arjanb: well, not really -- if everyone would have them, no one would talk about mine ;)
06:15:24 <shapr> kosmikus: I think you should have the lambda guys on your personal website.
06:15:41 * stefan_ totally agrees with shapr
06:16:06 <kosmikus> shapr: maybe I'll ask permission from Clara to scan all the material there is and put it online
06:16:14 <shapr> that would be very cool :-)
06:16:20 <shapr> konichiwa ikegami--san
06:16:26 <shapr> ohio gozymus
06:17:06 <shapr> wow, Crosby and Nash are running for the US presidency.
06:17:22 <musasabi> hmm I can reproduce it with ghci, but not with ghc.
06:17:24 <shapr> I now know who to vote for: http://www.crosbynash2004.com/blog/
06:18:01 <kosmikus> shapr: a few lambdas are on her homepage: http://omega.sdf-eu.org/lambda/lambda.html
06:18:04 <shapr> In other news, Microsoft left the UN Standards group.
06:18:23 <shapr> love the klein bottle
06:18:45 * shapr laughs at the lambda cartoons
06:19:26 <ikegami--> :)
06:19:40 <shapr> hiya sazzle 
06:20:37 <ozone> hey saz, i'll be at uni tomorrow
06:20:47 <ozone> let's meet up if you're free
06:23:23 <shapr> hihi SyntaxNinja 
06:23:24 <sazzle> hi andre, shapr!
06:23:31 <sazzle> ozone: sure, when are you there?
06:23:45 <shapr> bah, she calls you andre, but never calls me shae.
06:24:04 <SyntaxNinja> y0 shapr
06:24:07 <shapr> y0 y0
06:24:25 <sazzle> shapr: not like you ever call me sara
06:24:33 <shapr> huh, good point.
06:24:35 <shapr> hi sara!
06:24:39 <ozone> shapr: well, it helps when you've actually met them in real life, shae
06:24:47 <shapr> ozone: that's true *andre* :-P
06:24:48 <ozone> so
06:24:50 <ozone> obviously
06:24:52 <ozone> you
06:24:55 <ozone> should come down to sydney
06:25:00 <ozone> then we'll all be happy
06:25:01 <ozone> aye?
06:25:04 <shapr> aye!
06:25:12 <ozone> say it with me!  AYEEEEEE!
06:25:16 <shapr> AYEEEE
06:25:18 <musasabi> hmm this appears involved...
06:25:27 <ozone> sazzle: hmm, depends, do you know when don's review is on? :)
06:25:29 <shapr> though I dunno if I'll get there before mark's spare room invitation runs out.
06:25:39 <sazzle> ozone: lemme check my mail
06:25:45 <ozone> merci
06:26:08 <SyntaxNinja> Ayyyy
06:26:15 <shapr> how's manuel doing lately? is parr still active?
06:26:17 <ozone> see, isaac's got the spirit
06:26:26 <sazzle> ozone: 
06:26:28 <sazzle> Friday, 27/8/2004
06:26:28 <sazzle>     * 10:00 Don's P/G review
06:26:32 <musasabi> crashing in intToXDR i = [chr (i `mod` 256)] where i :: Int...
06:26:40 <musasabi> and only if called deep inside things...
06:26:40 <ozone> 10am?  bah, and i thought i could sleep in
06:26:51 <sazzle> ozone: that's what the pls website sez
06:27:13 <ozone> shapr: manuel's doing well i'm sure, though i don't think he's working on parr right now
06:27:15 <musasabi> I think the real reason is that my instances of Data and Typeable for Obj are cheated.
06:27:24 <ozone> musasabi: Obj?  kinky
06:27:53 <ozone> sazzle: well, i have to siddown with sean and don and chat to them about haskell stuphs, but lunch should be all good
06:28:33 <sazzle> ozone: well, i'm free from about 11:30 till when i decide to turn up to my ethics lecture
06:28:42 <sazzle> gimme a call?
06:29:30 * sazzle saw don's practice talk, interesting stuff!
06:29:50 <ozone> sazzle: /msg me your number
06:29:55 <shapr> oh me too!
06:29:57 <shapr> I'll call you!
06:29:57 <Si\> musasabi: Can the GHC CVS reify polymorphic type constraints?
06:30:41 <musasabi> ozone: data Obj = forall a. (Typeable a, Data a, Show a) => Obj a ;)
06:30:57 <ozone> musasabi: are you doing some OO modelling in haskell?
06:31:30 <musasabi> ozone: trying to stress test my xdr encoding fold with various "fun" datatypes.
06:31:55 <musasabi> Si\: parts of them at least.
06:32:18 <ozone> musasabi: ah.
06:32:33 <musasabi> Si\: I can express listToXDR :: (Data a) => [a] -> XDRt with it.
06:33:00 <musasabi> Si\: but haven't yet found the key to enumToXDR :: (Enum a) => a -> XDRt
06:33:27 <musasabi> then again my understanding of the TypeableN mechanism is still lacking.
06:44:31 <Si\> Could you do it using existential types with different constraints and Typeable?
06:54:08 <musasabi> Si\: existential types + Typeable => evil
06:54:25 <musasabi> you can try to do it...
06:54:46 <musasabi> remember that the compiler will be unable to help you derive any typeclass for them...
06:55:25 <musasabi> and I don't really know how one would sensible define gunfold for an existential type.
06:56:47 <Si\> data Aa = forall a . A a => Aa a deriving Typeable works
06:59:13 <musasabi> Si\: yes, but not for data.
07:00:17 <musasabi> and typeOf (Obj True) == typeOf (Obj 'a') => True
07:01:36 <stefan_> musasabi: that seems right, since both Obj True :: Obj and Obj 'a' :: Obj :)
07:02:08 <musasabi> stefan_: of course.. but that is not very usefull if you want to do different things depending on the content
07:02:41 <Si\> I don't, I simply want to manipulate what is in Obj via the type-class
07:03:11 <musasabi> ok, then your problem will probably be that you have a :: Data and you want to have a :: Obj
07:03:24 <musasabi> and you will find the conversion hard...
07:03:41 <stefan_> musasabi: but that requirement seems in conflict with the use of an existensial type ... existensiality here indicates that you want the _same_ behaviour for all a1,a2 :: Obj
07:04:02 <musasabi> stefan_: true.
07:04:21 <musasabi> Si\: you want to use a gmap:ing function no?
07:05:07 <musasabi> Si\: then you will have fun :: (Data a) => a -> b, and you want a method for converting a to Obj.
07:05:09 <stefan_> musasabi: that's in fact the main motivation for writing forall instead of exists for extensial types ... but even then, I'd somehow liked exists better
07:05:58 <Si\> Here's what I want; switchQ :: (Typeable a, Typeable b, Typeable c) -> (a -> z) -> (b -> z) -> z -> c -> z
07:06:32 <Si\> Then it compares c to a and c to b, or arg 3 if neither match
07:06:52 <musasabi> Si\: I was doing exactly that last night...
07:07:29 <Si\> oh dear
07:07:34 <musasabi> if a and b are not polymorphic it is trivial.
07:08:07 <Si\> They're not; they're existentially quantified types
07:08:35 <pesco> What's going on?
07:08:38 <Si\> and thus always have the same type, no matter what they encapsulate
07:09:08 <musasabi> Si\: wait 5min and I'll paste a way to do it (or fail).
07:09:36 <Si\> thanks
07:20:40 <musasabi> Si\: http://youzen.b2.fi/~musasabi/F.hs
07:24:14 <musasabi> does it solve your problem?
07:36:06 <Si\> I was hoping to be able to define switchQ f1 f2 d = fromJust ((cast f1) >> (cast f2) >> return (\x -> d))
07:36:17 <Si\> but it's too ambiguous
07:39:17 <esap> you can't ignore the return value of 'cast'.
07:39:47 <musasabi> Si\: why do you want to cast?
07:40:51 <musasabi> Si\: you can do that too... I think. (5 min)
07:41:45 <Si\> Well because then it will pick which function to apply depending on the type of the argument
07:42:27 <Si\> this allows me to substitute a set of constraints for an existential type (which encapsulates those constraints)
07:43:46 <musasabi> got it.
07:43:52 * esap could get the following to type check: \f1 f2 d -> fromJust ((cast f1) >>= \v -> (cast f2) >>= \u -> return (u,v,\x -> d))
07:44:03 <musasabi> now to make it more beautiful
07:44:28 <musasabi> Si\: http://youzen.b2.fi/~musasabi/F.hs new version.
07:46:14 <musasabi> Si\: a newer and cleaner version (refresh)
07:47:15 <esap> altSwitch casts a function? Hmm.. Wonder how it could work.
07:47:45 <musasabi> esap: that is a standard practise...
07:47:52 * esap never did that.
07:48:12 <musasabi> altSwitch and altSwitch2 are the same thing with different syntax.
07:55:31 <musasabi> Of course you start noticing that there is a pattern there...
07:55:38 <musasabi> Then you create a combinator...
07:55:48 <musasabi> Then you notice it is already defined in the library...
07:55:54 <musasabi> @type extQ
07:55:55 <lambdabot> bzzt
07:56:17 <musasabi> even if lambdabot does not want to aknowledge it...
07:56:21 <musasabi> Then you define:
07:56:21 <shapr> @index extQ
07:56:22 <lambdabot> Data.Generics,Data.Generics.Aliases
07:56:28 <musasabi> altSwitch3 fa fb d = const d `extQ` fb `extQ` fa
07:56:31 <shapr> @type Data.Generics.extQ
07:56:33 <lambdabot> Data.Generics.extQ :: forall q a b.
07:56:33 <lambdabot> 		      (Data.Typeable.Typeable b, Data.Typeable.Typeable a) =>
07:56:33 <lambdabot> 		      (a -> q) -> (b -> q) -> a -> q
07:56:50 <musasabi> (update the example on web too)
07:56:59 <esap> ah, I didn't realize you wanted that :-) extQ is very useful.
07:57:08 <musasabi> Si\: now you have got three different ways of doing it.
07:59:47 <esap> How about d `mkQ` fb `extQ` fa, isn't that also close to what you want?
07:59:49 <Si\> that's great, because it means that you can effectively switch between a number of functions base on the context of the type your passing
08:00:08 <Si\> but it would still be way better if it could be done purely on context
08:00:09 <Aglarion> howdy shapr :)
08:00:54 <musasabi> Si\: what do you mean?
08:01:46 <Si\> Well currently a and b are monomorphically typed as Obj1 and Obj2, with contexts encapsulated in the existentially quantified types
08:02:18 <musasabi> yes, do you remember when in the beginning I said that the monomorphic case is easy?
08:02:41 <Si\> but if TyRep could allow casts based purely on context
08:02:59 <Si\> oh yes, I know contextually it's impossible atm
08:04:13 <esap> polymorphic case is possible as well if you pass a TypeRep.
08:05:42 * esap means TypeVal, not TypeRep.
08:06:25 <musasabi> esap: can you give an example?
08:06:56 <esap> Here's an example from real code.
08:08:57 * esap thinks my real-life example is too complex :-)
08:09:05 <esap> No easy way to paste without pasting everything :-)
08:10:02 <esap> Basically I have a function in_category :: (ObjectTheory m p) => TCategory p -> TFunctor p -> m a -> m a
08:10:17 <esap> That I would like to use inside a generic traversal
08:11:18 * esap just split, I think.
08:12:31 <goron> esap, what are you creating?
08:12:37 * shapr carefully sews esap back together.
08:12:44 <esap> The way I've done it I've written a helper function that does that, mapping_scope_transform :: (ObjectTheory m p) => TypeVal a -> TMappingScope p a -> GenericMT m ; mapping_scope_transform _ (TMappingScope m x) = GenericMT trans where trans x = in_context m x >>= (return . fst)
08:12:54 <esap> goron: Well this is part of a compiler.
08:12:54 <musasabi> esap: could you post it somewhere?
08:12:54 <musasabi> if it is < 500 lines, I'd want to try to understand it..
08:13:01 <musasabi> btw the connection here is lagging... sorry if I drop.
08:13:25 <esap> I can post two files of it, which I think will clarify it.
08:13:35 <goron> esap: Thought so. Is it that epigram language? Or something else? 
08:13:45 <musasabi> esap: that would be very nice.
08:13:48 <esap> epigram?
08:14:08 <jedii> hey all :)
08:14:21 <musasabi> hello
08:14:26 <jedii> i am a haskell student experiencing difficulty, is there anyone available to help :)
08:14:35 <jedii> i am trying to create a function, as u do in haskell heh :p
08:14:45 <jedii> function a b t
08:14:45 <jedii>    | f a < f b = function b a t -- Step 1
08:14:45 <jedii>    | a < b = 1
08:14:45 <jedii>    | otherwise =  0
08:14:51 <goron> esap: there were some people busy with it. But what language are you implementing?
08:15:00 <jedii> I want to somehow give a value to the variable c
08:15:06 <jedii> which is b - a
08:15:09 <jedii> how do i go about that? :\
08:15:27 <esap> goron: I'm designing a language as I go.
08:16:02 <goron> esap: Does that work?
08:16:08 <pesco> jedii: In a where clause, maybe?
08:16:31 <esap> goron: no, I do know that :-)
08:16:47 <jedii> can you help me to understand how to use a where clause?
08:16:58 <jedii> i want c to be available to use in the rest of that function just like a and b are
08:17:00 <goron> esap: Do you already have a webpage?
08:17:04 <pesco> function a b t
08:17:04 <pesco>     ...
08:17:04 <pesco>     where c = b - a
08:17:21 <musasabi> jedii: do you basically want difference x y = abs (x - y) ?
08:17:23 <pesco> jedii: That's exactly what the where clause is for.
08:17:46 <jedii> yeah this is my code in java hehe
08:17:47 <esap> http://www.haskell.org/hawiki/HaskellIrcPastePage has my example code now
08:17:54 <esap> goron: for the language? No.
08:18:01 <jedii>           double n= Math.abs(a-b);
08:18:01 <jedii>           if(b<a) c=b-n; else c=b+n;
08:18:06 <jedii> im trying to port to haskell
08:18:08 <jedii> hehe
08:18:29 <goron> esap: Or for your progress? Any that has something to do with it?
08:18:42 <jedii> so as part of the if statement in my function, i want to give birth a variable c and give it the value
08:18:49 <jedii> how do i use the where clause to do this?
08:19:35 <esap> goron: no I haven't much publicized it, I do have lots of material done, but it's not very finished, so I'm somewhat hesitating to publish since it might contain serious mistakes, and I'm really doing some big changes to how things are supposed to work.
08:20:48 <goron> esap: It sure looks like to have something to do with category theory...
08:21:01 <esap> goron: heh, it does.
08:21:44 <esap> musasabi: look at scopes_query, that's using TypeVal to pass type information into the query.
08:21:59 <goron> esap: I was waiting for such a language, as Haskell also has its limitations. 
08:22:19 <pesco> jedii: Is that some kind of contrived homework assignment? In the Java above, c=2b-a, afaics.
08:22:46 <esap> goron: I think two things I'm trying to do is to make object-orientation really work well with functional programming in a complementary way.
08:23:00 <jedii> ah ok pesco
08:23:08 <jedii> how do i set c in haskell ?
08:23:23 <esap> goron: And another is that I'm trying to build coroutines into the system.
08:23:31 <pesco> jedii: What do you mean by "set"?
08:23:39 <goron> esap: coroutines?
08:23:50 <jedii> help me out here, i am unfamiliar with the right terminology hehe
08:24:05 <jedii> I mean, i want c to equal say 5
08:24:21 <jedii> how do i make c to equal 5, so that i can use c for the whole time in the rest of my function
08:24:22 <esap> goron: It's basically message passing. You have two routines that can send information to each other.
08:24:24 <jedii> in this instance
08:24:32 <jedii> <jedii> function a b t
08:24:33 <jedii> <jedii>    | f a < f b = function b a t -- Step 1
08:24:33 <jedii> <jedii>    | a < b = 1
08:24:33 <jedii> <jedii>    | otherwise =  0
08:24:33 <pesco> jedii: Be aware, that Haskell has no concept of mutable state variables! Except you build something with monads, where the monads do.
08:24:51 <jedii> yep, pesco im using recursion
08:25:02 <jedii> so i just call the function again at the otherwise statement, which i have not yet completed
08:25:22 <pesco> jedii: As I said, put a "where c = ..." after the rest of the function definition.
08:25:46 <jedii> how does one do that, as i am unfamiliar with the where statement
08:26:09 <musasabi> esap: I think I understand parts of it.
08:26:28 <musasabi> I can understand how it can be made to dispatch on e.g. a monadic type.
08:26:30 <pesco> jedii: For example. "foo a b = c where c = a+b".
08:27:14 <musasabi> esap: but how do you make the constraint a type class?
08:27:46 <goron> esap: I have *no* idea of why that would be useful, but if you think it's useful, then it probably is. 
08:28:02 <jedii> back, got dc
08:28:35 <jedii> is anyone available to tutor me for a while :\
08:29:03 <esap> musasabi: The reason is, I don't want to depend on the actual type of the monad. The way to do that is that you have to pass the actual concrete type separately (like I've done in 'scopes_query')
08:29:40 <pesco> jedii: For the exact syntax, check the report. Basically, you just write "where" indendet by one level on the next line after the rest of the function def. Then, on the lines after the where, at the same indentation level, you can write more declarations that bind variables local to your function.
08:30:05 <jedii> can you use ifs in a where ?
08:30:16 <esap> musasabi: The whole thing is just wrapping 'in_category', which is in_category :: (ObjectTheory m p) => TCategory p -> TFunctor p -> m a -> m a. What it does it it takes certain points in the parse tree and applies in_context in specific places generically.
08:31:00 <pesco> jedii: Yes, the where clause contains ordinary declarations. Write them just as you would on the top-level.
08:31:32 <jedii> excellent
08:31:38 <jedii> also, how do you make a function return a value
08:31:40 <jedii> ie
08:31:59 <jedii> FunctionAddup a b return a+b
08:32:17 <jedii> so in a different function you can just apply that function to a variable you have already
08:32:23 <musasabi> esap: so your solution is to model the problem domain with monadic types instead of type classes?
08:32:42 <musasabi> esap: I think I understand the dispatch code on a basic level.
08:33:01 <pesco> jedii: fun a b = a+b. You should probably consult a book.
08:34:00 <esap> musasabi: what do you mean with 'problem domain'?
08:34:40 <musasabi> esap: you encode similar set of types under a common monadic type instead of using a type class based approach?
08:35:17 <jedi`> pesco: ok, 
08:35:20 <esap> musasabi: Well I do use a type-class based approach.
08:35:27 <jedi`> one last q: how does one print to the screen
08:35:40 <jedi`> printStrln "A IS LESS THAN B"
08:35:49 <goron> Is there a way to get the hightest node number of a Graph? I use Data.Inductive graphs?
08:35:49 <jedi`> i am having an error with this;
08:36:01 <musasabi> jedi`: putStrLn or print.
08:36:09 <jedi`> k ta guys
08:36:23 <musasabi> esap: but you do the *dispatch* based on monadic type, not the typeclass?
08:36:35 <goron> hightest->highest
08:36:36 * shapr boings expectantly
08:36:54 <goron> shapr: hej
08:37:01 <musasabi> hello shapr 
08:37:08 <shapr> hoi goron, hoe gaat het met jou?
08:37:17 <shapr> hei musasabi, mitt√§ kuulu?
08:37:26 <goron> shapr: goed hoor, en met jou?
08:37:29 <esap> musasabi: I'm not quite sure what you mean.
08:37:30 <edwinb> hello world
08:37:31 <shapr> hm, I think I screwed up my finnish spelling again.
08:37:40 <world> hello
08:37:45 <edwinb> never fails ;)
08:38:29 <musasabi> shapr: one 't' too much (and my irssi still doesn't do utf-8), but thanks ^_^
08:38:32 <esap> musasabi: look at mapping_scope_transform. It pattern matches based on a concrete tyype.
08:38:39 <musasabi> mit‰ kuuluu.
08:38:49 <shapr> kiitos
08:38:53 <musasabi> is the correct spelling... (of course that is encoded in the wrong way)
08:39:21 <shapr> oh hey
08:39:36 <shapr> I was thinking about using QuickCheckM to do GHC testing
08:39:36 <goron> my UTF-8 works in 90% of the times... (Is this the worse is better method)
08:40:04 <goron> shapr: Ever used Data.Graph.Inductive?
08:40:32 <shapr> sadly, the only tests I've been able to think up are math comparison with dc
08:40:50 <shapr> what else could I try to match with external results?
08:41:04 <musasabi> esap: I think I finally catched on. the Typeable forces the correct instance of TMappingScope to be selected and then the dispatch just works... ?
08:41:12 <shapr> goron: no, sorry. But if you show me your code, there's a small possibility I can help.
08:41:23 <jedi`> getc a b 
08:41:23 <jedi`>    | b < a = return c
08:41:23 <jedi`>    | otherwise = return c
08:41:24 <esap> musasabi: Right.
08:41:36 <jedi`> i get an error saying something about IO
08:41:40 <musasabi> esap: many thanks for the patience ^_^
08:41:53 <jedi`> return c isnt the code its just what i want to do
08:42:05 <jedi`> but with my code, i was getting some IO Num error :S
08:43:38 <arjanb> jedi`: leave 'return' away
08:44:33 <jedi`> shapr: can you help me in here?
08:44:37 <shapr> possibly
08:44:57 <jedi`> okei :)
08:45:01 * shapr looks at the paste page
08:45:13 <jedi`> are you familiar with java?
08:45:20 <shapr> somewhat, yes.
08:45:23 <esap> musasabi: The point is, you can't leave any unbound universally quantified variables there, otherwise you'll get errors. Sometimes it's pretty hard to actually see where you've done that, but the compiler fortunately tells that...
08:45:29 <jedi`> so you can become familiar with what im attempting to port to haskell :)
08:45:33 <jedi`> ill paste my java coding :p
08:45:37 <shapr> no please no
08:46:02 <shapr> I've been using Java since it was in beta, I'd rather not see any more if I can help it.
08:46:19 <arjanb> learning haskell by porting code from an imperative language is a bad idea
08:46:21 <shapr> but, if you describe your problem to me, I might be able to suggest some useful approaches.
08:46:33 <jedi`> ok, ive got an algorithm worked out :)
08:46:41 <jedi`> i just need to implement it into hascall hehe
08:46:46 <shapr> ok
08:46:50 <jedi`> Paste my algorithm into a paste pad
08:46:51 <shapr> what's the algorithm?
08:46:53 <jedi`> and give u the link?
08:46:59 <jedi`> or just type it here
08:47:05 <jedi`> I am writing a program for function minimisation
08:47:16 <musasabi> esap: yes, those are nasty ones..
08:47:22 <shapr> what does that mean? you want the smallest number out of three?
08:47:31 <shapr> you want to make functions smaller?
08:47:42 <goron> shapr: It's on the haskellircpastepage.
08:47:45 <jedi`> no it means finding the minimal value on a curve
08:47:53 <jedi`> nonlinear programming hehe
08:48:20 <shapr> so, how do you approach that?
08:49:34 <goron> shapr: Did you get that?
08:49:44 <jedi`> http://pastepad.com/?pad=8a
08:50:16 <jedi`> thats the algorithm i have worked out
08:50:41 <jedi`> i implented that in java, so i know what to do, i just need to know how to do this is haskell
08:51:15 <shapr> goron: it's the code at the top?
08:51:33 <jedi`> f x = (1/x**12) - (1/x**6)
08:51:38 <jedi`> is the code for the function
08:51:38 <goron> shapr: yes
08:51:51 <goron> shapr: "code" :)
08:53:37 <jedi`> anyhow, i just need to know how to return a double value c from my function getc
08:53:38 <jedi`> :\
08:54:27 <shapr> jedi`: haskell code doesn't return, it just evaluates
08:54:44 <jedi`> yep
08:54:44 <jedi`> getc a b 
08:54:44 <jedi`>    | b < a = b - abs(b-a)
08:54:44 <jedi`>    | otherwise = b + abs(b-a)
08:54:56 <jedi`> so i want to set c like
08:55:06 <jedi`> where c = getc 2 4
08:55:09 <jedi`> or something :\
08:55:24 <goron> jedi`: That's valid Haskell code.
08:55:43 <jedi`> im getting a compiler error
08:56:08 <goron> jedi`: Then you have some minor differences with my interpretation of this irc text.
08:56:15 <musasabi> jedi`: isn't step2 just step2 (a,b) = b + (b - a)
08:56:52 <jedi`> since ur swapping a and b up the top
08:56:59 <jedi`> you have to check to see if a and b have been swapped
08:56:59 <jedi`> ?
08:57:04 <shapr> isn't this a good place to iterate until you reach a fixpoint?
08:57:38 <goron> shapr: no, at least I can't see it.
08:58:06 <shapr> sorry, I was thinking about jedi`'s code
08:58:06 <goron> shapr: Well, maybe
08:58:10 * shapr needs to swap threads
08:59:34 <shapr> goron: do you have an entire module that I could play with?
09:00:39 <goron> shapr: no, but, you can give it an explicit instantiation and import Data.Graph.Inductive.
09:01:01 <goron> shapr: But that's not important. 
09:01:23 <goron> shapr: It's the problem of how do I update the i without using explicit recursion.
09:01:29 <shapr> jedi`: what error do you get?
09:01:58 <goron> shapr: Or just avoid the update in general, but that would kill the interface I get from the Graph lib.
09:02:03 <shapr> pass in an update function?
09:03:07 <shapr> jedi`: if you're getting an 'IO Num' kind of error, I think that means you're trying to use the code with an IO value, and that's a whole different discussion.
09:03:14 <goron> This ofcourse works: someFunc i input = doSomething i `applyfunc` someFunc (i+1) smallerinput
09:03:34 <goron> For a list applyfunc would be :
09:03:45 <goron> But that's ugly.
09:03:57 <goron> It's what called "explicit recursion".
09:04:11 <shapr> I think I see what you mean.
09:05:16 <goron> I also can create a map that works on two arguments, but using standard functions it's impossible I think. Unless you have SHP (Super Haskell Powers)
09:05:41 <shapr> um, I think it's easier than that...
09:06:02 <goron> shapr: Burn free(that's an expression in Dutch).
09:06:18 <shapr> I'm trying to figure it out...
09:06:34 <shapr> first I have figure out where I left my local copy of Data.Graph.Inductive
09:06:34 <Aglarion> short question: can i define multiple guards for one pattern in function definitions? or are they just usual function calls? for example if i want one pattern to match only if values of expressions a _and_ be are true?
09:07:16 <kosmikus> Aglarion: && ?
09:07:23 <shapr> oh, ghc-cvs seems to come with Data.Graph
09:07:23 <shapr> spiffy
09:07:36 <Aglarion> so can i use any expression as a guard?
09:07:46 <goron> shapr: That was the sole reason for getting the CVS version :)
09:07:50 <kosmikus> any of type Bool
09:08:02 <jedii> back :)
09:08:05 <Aglarion> ok thanks
09:08:27 <jedii> http://pastepad.com/?pad=8c
09:08:35 <Aglarion> must go... my dial up connection is too expensive
09:08:43 <Aglarion> cya
09:08:47 <jedii> this is my coding, almost finished it, but i am very uncertain of why i am getting this compiler error ;\
09:08:56 <shapr> what's the error?
09:09:49 <jedii> type error in guarded expression
09:09:55 <jedii> something about Num IO's
09:09:56 <jedii> :\
09:10:12 <shapr> do you know how IO works in Haskell?
09:10:16 <jedii> not 100%
09:10:29 <jedii> do i have to define the io of a function?
09:10:30 <shapr> I think your code may be fine, but you don't know how to deal with IO values.
09:10:56 <shapr> have you interactively tried your functions in Hugs or GHCi ?
09:11:14 <jedii> i am compiling on hugs 
09:11:17 <shapr> goron: how do I build a Graph to play with?
09:11:24 <jedii> interactively trying them?
09:12:08 <shapr> jedii: if you load the file into hugs without executing the main function, you can try executing a function by itself
09:12:22 <jedii> yep
09:12:36 <jedii> thats what ive been doing
09:12:40 <jedii> i dont have a main in my hs file yet
09:12:42 <shapr> if you have this in your file: "myFoo x = x + 1" you can load that into Hugs and type "myFoo 1" to see the result.
09:12:55 <jedii> yep, that is the way ive been learning yes :)
09:12:56 <shapr> ok, what exactly is the Num IO error that you're getting?
09:13:26 <pesco> @type print
09:13:27 <lambdabot> print :: forall a. (Show a) => a -> IO ()
09:13:38 <shapr> gutentag pesco 
09:13:43 <pesco> Hej shapr!
09:13:50 <jedii> do i have to make b a string before i can print ?
09:13:54 <shapr> pesco: snowblind was down for a few hours yesterday and this morning, but service should be restored now.
09:14:00 <shapr> jedii: yes.
09:14:06 <jedii> hehe that makes sense
09:14:10 <pesco> shapr: I noticed, no worries.
09:14:26 <shapr> ok, if you have any other sysadmin requests, ask me.
09:14:29 <goron> shapr: empty
09:14:49 <goron> shapr: That gives you an empty graph.
09:14:53 <shapr> ok
09:14:57 <pesco> shapr: Sure! I'm quite pleased for now.
09:15:01 <shapr> spiffy
09:15:12 <jedii> Instance of Num (IO()) required for definition of the function
09:15:16 <jedii> thats my error message
09:15:28 <jedii> i changed the print to print "Done" so that error is gone for now
09:15:29 <shapr> it seems that snowblind may be moving in the near future, no definite information though.
09:15:48 <pesco> shapr: Have a look at v0.9 of Pesco.Cmdline if you like! It got _really_ pretty after I switched to lhs2TeX (thanks to kosmikus) and finished all the documentation.
09:15:48 <shapr> jedii: what's the line of code that causes that error?
09:16:11 * shapr looks
09:16:14 * kosmikus has another look as well
09:16:37 <jedii>    | f a < f b = function b a error -- Step 1
09:17:19 <shapr> @type error
09:17:20 <lambdabot> error :: forall a. [Char] -> a
09:17:28 <jedii> hmm, is that a present word in haskell
09:17:33 <shapr> yup
09:17:34 <jedii> i should try using e or something hehe
09:17:39 <jedii> grr damn languages :\
09:17:45 * shapr grins
09:17:45 <pesco> jedii: That's not the problem!
09:17:55 <jedii> i have to thank you guys for ur help :)
09:17:58 <pesco> jedii: error is rebound by your argument.
09:17:59 <shapr> jedii: on the good side, exposure to a bunch of different programming languages improves your ability to write code.
09:18:35 <pesco> jedii: It's print that's causing the error, because it is an IO action, while the value of the otherwise case is a Number.
09:19:10 <jedii> aha, in an if statement, they both have to be the same type
09:19:46 <jedii> how does one get around this :p
09:20:26 <shapr> pesco: do you have some latex unit-test shortcut?
09:20:35 * shapr looks at the source
09:20:38 <pesco> shapr: No, what do you mean?
09:21:01 <pesco> Because they look so uniform? No, that's just disciplined writing. ;0
09:21:06 <shapr> heh, ok
09:21:34 <shapr> jpgil-cl: greetz
09:21:39 <shapr> looking for darcs info?
09:21:44 <jpgil-cl> Hallo, people.
09:21:52 <kosmikus> pesco: nice ... there's one unintended alignment in opt_default, but that's all I've seen in a quick scan
09:22:16 <shapr> goron: how do I make a graph that has a value?
09:22:27 <shapr> I guess I could just read the docs =)
09:23:01 <pesco> kosmikus: Actually, those type signatures were aligned intentionally. Whether it looks good that way is open for debate, right.
09:23:15 <kosmikus> pesco: no, not the sigs
09:23:34 <kosmikus> the fourth arguments
09:23:43 <pesco> Ah! Of course.
09:23:49 <pesco> ;) I didn't even notice.
09:24:39 <shapr> pesco: looks nice, the Abrechnung app is cute, I may even use it :-)
09:25:11 <pesco> shapr: Heh, isn't it? I'm pretty sure it'll come in handy for me, too. :) Nice if it finds other users. ;-)
09:25:38 <kosmikus> pesco: yes, great -- this is how Haskell libraries should be documented ;)
09:26:19 <jedii> ok finally finished my program, im back to that print error
09:26:24 <pesco> Thanks alot. And what's best; it was real fun to write.
09:26:25 <jedii> I need to print to the screen the value of b
09:27:08 <shapr> jedii: don't do that, evaluate the correct result, then print that result elsewhere.
09:27:18 <shapr> make sense?
09:27:32 <pesco> When I was going through the code yesterday, adding documentation, I repeatedly found myself exclaiming "wow, this looks so much cooler now!"
09:27:48 <jedii> i have to print it to the screen, thats what the question asks hehe
09:27:53 <kosmikus> pesco: I know the feeling
09:27:55 <shapr> I wish there were some way to generate haddocks and latex from the same sources.
09:27:57 <jedii> Just run the prog and u get the answer printed to the screen, nothing else
09:27:58 <jpgil-cl> jedii:  if you use Helium, try with  putStr
09:28:15 <pesco> I was amazed to see how much more structured even these simple functions became during the process.
09:28:18 <shapr> jedii: right, the two alternatives have the same type if they both return a number
09:28:23 <pesco> The old version was horribly convoluted in comparison!
09:28:25 <jedii> yep
09:28:31 <jedii> so is it just putStrLn b
09:28:32 <jedii> ?
09:28:38 <shapr> @type show
09:28:39 <lambdabot> show :: forall a. (Show a) => a -> String
09:28:54 <shapr> @type putStrLn
09:28:55 <lambdabot> putStrLn :: String -> IO ()
09:29:30 <shapr> goron: I'm beginning to remember that FGL is actually rather elegant when it comes to dealing with graphs.
09:29:44 * shapr makes crazy looking cyclic structures
09:29:49 <jedii> @type print
09:29:49 <kosmikus> pesco: you could use \savecolumns \restorecolumns for the four parm_* definitions on page 5
09:29:50 <lambdabot> print :: forall a. (Show a) => a -> IO ()
09:29:59 <jedii> use print?
09:30:17 <pesco> kosmikus: Ah, that's a good idea!
09:30:20 <shapr> jedii: that should work too
09:31:34 <jedii> it did, thanks :D
09:31:41 <jedii> i am so pleased, but i tell you what im not pleased about
09:31:48 <jedii> it took me like 4 and a half hrs to write
09:32:01 <jedii> 12 lines of coding lol
09:32:20 <jedii> my java program is like 5 times as long
09:33:07 <jpgil-cl> hehe
09:33:17 <shapr> jedii: is this the first time you've written any Haskell code?
09:33:46 <shapr> paradigm changes take some time to get used to...
09:34:19 <shapr> If you haven't tried any logic or constraint programming, that will probably also take you some time to figure out. But once you've got it, it gets easier, and you can apply the new knowledge to all the other languages you know.
09:34:29 <jedii> yep first time
09:34:45 <jedii> yeah i can see how simple it was
09:34:53 <jedii> its actually quicker if you are on the ball
09:35:02 <jedii> i cant say i prefer it but hehe
09:35:18 <jedii> all i have to do now is write my main function
09:35:21 <jedii> is this right?
09:35:34 <jedii> module Main(main) where
09:35:35 <jedii> import IO
09:35:35 <jedii> main :: IO ()
09:35:35 <jedii> main = print (function 2.0 2.2 0.00001)
09:35:45 <jedii> ive added that in
09:35:51 <jedii> but i get one compiler error again :\
09:36:50 <jedii> something to do with IO error
09:38:59 <shapr> try putting "do" in front of the print
09:39:13 <pesco> That should not be necessary!
09:39:34 <jedii> yeah same error
09:39:42 <jedii> the error is on this line
09:39:46 <jedii> main = print (function 2.0 2.2 0.00001)
09:40:08 <pesco> What is the type of function?
09:40:38 <jedii> i havent set the type
09:40:44 <jedii> im just letting the compiler decide i think heeh
09:40:50 <jedii> is it wise to set it myself?
09:41:44 <pesco> Yes, if function has another type than you think it should, the error will be caught right there.
09:42:01 <jedii> i am unfamiliar with setting the types of functions
09:42:02 <jedii> :\
09:42:20 <jedii> http://pastepad.com/?pad=8d
09:42:23 <jedii> here is my program
09:42:30 <pesco> It should take three arguments of type Double, i take it.
09:42:36 <jedii> yep, it should :)
09:42:38 <pesco> What should be the return type?
09:42:42 <pesco> Double also I suppose?
09:42:46 <jedii> double indeed
09:42:48 <pesco> result type I mean ;-)
09:43:04 <pesco> So the type of function should be "Double -> Double -> Double -> Double".
09:43:11 <jedii> function :: Double -> Double -> Double -> Double
09:43:16 <jedii> yeah, typing that then
09:43:19 <jedii> is that how u do it?
09:43:20 <pesco> Exactly.
09:43:36 <jedii> 3 in, 1 out
09:43:43 <jedii> ill try putting that in
09:45:23 <Marvin--> "SCO Says 'Linux Doesn't Exist'"
09:45:29 <Marvin--> phew, glad they cleared that up!
09:45:45 <jedii> Type error in guarded expression
09:45:49 <arauko> Marvin--, you reading comedy?
09:45:53 <jedii> Term print b
09:45:59 <jedii> Type IO ()
09:46:04 <jedii> Does not match Double
09:46:07 <jedii> hmmm 
09:46:15 <pesco> Marvin--: Cool, so it finally did part the Einstein continuum.
09:46:18 <Marvin--> arauko: close, /.
09:46:53 <Marvin--> 'Linux doesn't exist. Everyone knows Linux is an unlicensed version of Unix'
09:47:19 <pesco> Wahahaa. They are hilarious.
09:47:59 <jedii> is anyone able to help with my one last question i promise i will not bother you again, youve all been most helpful, wish there was some way more to thank you :)
09:48:02 <jedii> hehe
09:49:59 <pesco> Ah, just scrub the channel floor over in that old corner. We've been avoiding it for ages since that party we had...
09:50:03 <pesco> ;-)
09:50:43 <jedii> lol
09:50:53 <jedii> oh dear 
09:51:06 <jedii> the fact that i find that a bit funny is sad for me :p
09:51:40 <jedii> its now 2:51 thanks to captain Haskell who has kept me up all night :\
09:52:00 <jedii> i am unsure of why i get a type error on this line
09:52:11 <jedii> abs(b - a) < t = print b
09:52:20 <jedii> It wants a double, instead its getting IO
09:52:24 <jedii> how does one fix this hehe
09:52:38 <pesco> drop the print.
09:53:04 <pesco> Print has type (Show a) => a -> IO ().
09:53:27 <jedii> haha, oh so simple how did i not pick that up :p
09:53:38 <jedii> hascall see's b as a function lol
09:53:41 <jedii> haskell*
09:54:39 <jedii> wicked, all done :D
09:55:22 <pesco> It sees "print b" and thinks "IO ()". At the same time though, it sees that the value there should be a Double (function's result type). So it says, "WTF?".
09:55:30 <jedii> lol
09:55:54 <jedii> hey, im using hugs, if i compile it with GHC
09:56:02 <jedii> does it automatically spawn the main method?
09:56:13 <jedii> when u run the compiled version
09:56:27 <pesco> Exactly.
09:57:28 <jedii> woo hoo :)
09:57:50 <jedii> i am so glad this channel exists, i would have been screwed otherwise hehe ;p
10:04:20 <pesco> jedii: Welcome to #haskell. Come by any time. There is always fun coding to be done in Haskell.
10:05:55 <jedii> hehe, yep, even though it sucks being tired, i had fun getting there
10:06:08 <jedii> :)
10:06:15 <pesco> Although I think, I'll have myself a round of Doom 3 now...
10:06:26 <jedii> are you a programmer as your occupation pesco
10:06:26 <jedii> ?
10:06:32 <jedii> or is it just a side interest for you hehe
10:06:41 <pesco> Both.
10:06:45 <jedii> :)
10:06:48 <jedii> way to go
10:16:44 <Aglarion> can someone tell me why the term [(t1,t2) : rest] has type [[(b,c)]] instead of [(b,c)] ?
10:17:00 <stepcut> yes
10:17:05 <Marvin--> because [x] is a list with one element
10:17:14 <Marvin--> you want ((t1,t2):rest) instead
10:17:38 <Aglarion> damn...
10:17:40 <stepcut> :p
10:17:41 <Aglarion> i see
10:18:09 <Aglarion> in my previous programs i did it right :-)
10:18:14 <stepcut> haha
10:18:54 <jedii> is there any chance i may trouble you guys with another question hehe
10:18:54 <Aglarion> thanks a lot... would have searched for this a hundret years before finding it
10:19:14 <jedii> I have to find out the order of languages, i have 3 to research, and i need to find out which rank from highest to lowest :)
10:19:34 <Aglarion> you may trouble me... but most probably i'll trouble you back :-)
10:19:40 <jedii> hehehe
10:19:57 <jedii> Erlang, Icon and Ruby
10:20:07 <jedii> I need to discover in which order they are 
10:20:12 <edwinb> What do you mean by "order"?
10:20:23 <jedii> Erlang is a concurrent functional programming language
10:20:31 <jedii> Icon is a high-level, general-purpose programming language
10:20:38 <jedii> Ruby is a purely object-oriented, scripting language. (Multi-paradigm programming language
10:20:53 <jedii> Thats the paradigms of each language, if that helps
10:21:25 <jedii> i am not entirely sure of order hehe
10:21:28 <Lor> You say "purely object-oriented" and "multi-paradigm". Don't you think that is contradictory?
10:21:40 <jedii> haha yes i do
10:21:57 <jedii> i have taken someone elses words though, as u do with research :p
10:22:16 <jedii> i think purely object oriented has a special meaning though
10:22:43 <Aglarion> purely object oriented means everything is an object
10:22:49 <Aglarion> like in smalltalk or ruby
10:22:53 <Lor> And what is an object?
10:23:00 <Aglarion> while C++ is not purely oo
10:23:07 <Lor> Does ruby have no procedural control structures?
10:23:24 <edwinb> I'm having difficulty coming up with a decent definition of "First order programming"...
10:23:26 <jedii> Have i described ruby correctly Aglarion?
10:23:32 <edwinb> which is a pity, as it might help you understand the question at least...
10:23:36 <Aglarion> i don't know ruby, but i know smalltalk and i heard they are very close to each other
10:24:17 <Marvin--> and what the heck do you mean order?
10:24:37 <edwinb> knowing that would make the question much easier... you might mean chronological order for all I know ;)
10:24:44 <jedii> i have to order them from highest to lowest level
10:24:48 <edwinb> ah
10:25:12 <Aglarion> i think it depends on your point of view
10:25:26 <Lor> Nah, seems like ruby has lots of operations that are not method calls.
10:25:30 <jedii> yeah, well you have to justify your answer of course
10:26:08 <Aglarion> doesn't work for me, since i don't know any of the languages
10:26:11 <edwinb> Think about which ones are most "imperative", or closer to the machine level...
10:26:54 <Aglarion> well... what is more imperative? imperative oop or just imperative?
10:26:56 <Lor> jedii, are you supposed to be able to create such an ordering without being deeply acquainted with each language?
10:27:08 <jedii> Lor: unfortunately :p
10:27:17 <Lor> Bad assignment, I'd say.
10:27:22 <jedii> i agree
10:27:25 <edwinb> I mean how directly do the three of them map to the underlying hardware.
10:27:27 <Marvin--> sounds like a horrible assignment
10:27:27 <Aglarion> what do you need this order for?
10:27:39 <jedii> yeah its for an assignment
10:27:55 <jedii> ive researched each but there is no resource which tells me which order languages are in hehe
10:28:05 <edwinb> no, you'll have to make that up then justify it, I guess.
10:28:56 <TheHunter> ok, i'll make a start and say icon is "lower" than ruby
10:29:12 <edwinb> I'd say Icon was higher...
10:29:23 <Aglarion> and ruby would be lower than a functional language
10:29:26 <edwinb> Based on my five minutes of research on it...
10:29:38 <Aglarion> based on my 0 seconds of research...
10:29:46 <Aglarion> just from hearing what type they are
10:29:51 <TheHunter> ruby has lambdas, icon has backtracking, but ruby has call/cc
10:30:43 <Aglarion> what is call/cc?
10:31:12 <Lor> magic.
10:31:36 <Aglarion> what kind of magic? black? white?
10:31:39 <TheHunter> Aglarion: lets you jump into the past
10:31:55 <Lor> Or the future.
10:32:00 <Aglarion> ?
10:32:04 <Aglarion> your kidding me
10:32:33 <TheHunter> it's kinof a fancy goto
10:32:35 <Aglarion> google will tell me the truth
10:32:59 <Aglarion> call/cc stands for ìcall with current continuationî; it is a function that exists in certain programming languages. What it does is not very easy to describe; in fact, I think it is one of the strangest inventions of computer science. This page tries to explain what call/cc does, what it means, why it is useful and how it works. 
10:33:08 <TheHunter> http://www.eleves.ens.fr:8080/home/madore/computers/callcc.html
10:33:37 <Aglarion> hunter: thats the first link google found :)
10:33:38 <TheHunter> oh sorry, you found that already
10:33:48 <musasabi> how can I make a generic instance of a typeclass without adding a (Foo a) => constraint to it?
10:34:08 <edwinb> I'd argue (again, based on about 2 minutes of research) that ruby's call/cc was quite low level...
10:34:49 <musasabi> hmm seems that adding definitions helps
10:35:11 <TheHunter> earthy: yah, but it should enable you to implement something like icon's backtracking magic
10:35:51 <edwinb> Sure, but the fact that icon has it built in suggests it's higher level...
10:36:02 <edwinb> Anyway, it's a silly question.
10:36:06 * edwinb goes back to a proper language
10:37:18 <TheHunter> edwinb: yes, but with callcc, you can do more than just backtracking. Plus, icon is procedural and has no closures
10:37:48 <TheHunter> (based on my memory which might be totally wrong)
10:37:58 <edwinb> but you can do more than backtracking in machine code...
10:39:47 <TheHunter> anyway, under the assumption that ruby has lambdas and icon doesn't, you can safely say ruby is higher-level
10:40:01 <edwinb> Your other argument "icon is procedural and has no closures" is far more compelling :)
10:41:04 <jedi`> back :)
10:42:17 <jedi`> is anyone able to shed some light on information they know about any of the languages ruby, erlang, icon
10:42:18 <jedi`> ?
10:43:04 <Aglarion> "A continuation is not something, like a function, which takes a value and returns another: it just takes a value and does everything that follows to it, and never returns." this makes absolutely no sense to me :-)
10:44:32 <edwinb> Hmm, erlang doesn't have higher order functions, apparently. I wonder what consequence that has...
10:44:43 <TheHunter> jedi`: i'd say ruby is higher than icon because it has lambdas (aka blocks) and closures while icon is procedural (provided it really has no lambdas)
10:46:06 <jedi`> thanks thehunter
10:46:22 <Aglarion> call/cc is to smart for me... i'll surrender.
10:46:25 <Aglarion> and quit
10:46:27 <Aglarion> cya
10:46:43 <edwinb> Icon's backtracking deserves a mention for high levelness though.
10:46:58 <jedi`> is it just me or is this a silly question :\
10:47:02 <edwinb> It's a silly question
10:47:39 <jedi`> hehe, Another question i have here is what has prevented these languages as being as popular and widely used as Java and C
10:47:44 <jedi`> but my answer to that is just
10:47:47 <jedi`> Real world application
10:47:48 <TheHunter> it's a silly question and depends very much on the views of the guy asking it
10:48:08 <edwinb> I'm not sure where erlang fits in now.
10:48:12 <jedi`> hehe, and lakck of funding/development/support from large corporations
10:48:18 <jedi`> does that sound right?
10:49:41 <edwinb> Lack of commercially available tools, perhaps.
10:50:01 <edwinb> There's no Visual Erlang.NET for example...
10:50:21 <TheHunter> souds ok. Perhaps that guy wants to hear the Paul Graham argument which goes like this: There are two kinds of languages, languages like Java for stupid people and languages like LISP for smart people. Java is more successful because there are less smart people
10:51:26 <edwinb> Perhaps - people use Java because other people use java. Whereas different people use Haskell because it's a nice language to program in.
10:51:29 <jedii> back
10:51:31 <jedii> what'd you say?
10:52:43 <musasabi> Why is GHC unable to chooce the correct instance of Foo Char and Foo a ?
10:52:57 <edwinb> jedii: language choice is driven more by what other people use than what is a good language for the job
10:53:28 <jedii> i agree
10:53:54 <musasabi> it compiles fine, but at runtime complains that it is unable to choose :-(
10:54:06 <edwinb> On an unrelated note, why do employers insist on hiring "C++ programmers" rather than simply "programmers"?
10:54:23 <jedii> :p
10:54:43 <edwinb> I'm sure my Haskell experience has made me a better all round programmer, for example, but employers find this difficult to understand...
10:55:25 <jedii> which major corporation goes with the C language
10:55:31 <jedii> like with java, you said Sun
10:55:33 <jedii> say*
10:55:36 <jedii> but with C ?
10:56:05 <edwinb> I suppose with C, it's more that it's been around for ever.
10:56:15 <jedii> yeah
10:56:33 <edwinb> Having said that, so has lisp...
10:56:53 <jedii> hehehe yep
10:57:23 <jedii> Also, I have to assess the suitability of each language as a language for teaching introductory programming concepts.
10:57:30 <jedii> how the fark do i answer that geeez :S
10:57:38 <Lor> We-hell... :)
10:57:56 <Lor> How big a project is answering these supposed to be?
10:58:04 <Lor> Something you are to do overnight, or after weeks of research?
10:59:01 <jedii> lol, well this question is worth 2 marks on a 20 mark assignment
10:59:17 <jedii> so i dont imagine these questions should take too long to answer
10:59:34 <jedii> the programming was 18 marks hehe
11:05:10 <edwinb> Seems quite hard to do justice to for only 2 marks...
11:06:26 <jedii> your telling me :\
11:07:29 <jedii> what makes a programming language a good language to teach introductory programming concepts?
11:07:43 <tojoko> Marks? Are you crowds?
11:08:13 <Smerdyakov> jedii, are you asking us to do your homework for you?
11:08:44 <edwinb> jedii: Again I think that's highly debatable which is why only 2 marks is a bit harsh...
11:10:00 <jedii> hehe definately
11:10:07 <jedii> can i ask for your opinion
11:10:54 <edwinb> Depends what the question means by "introductory programming concepts" anyway...
11:11:24 <jedii> lol
11:11:28 <jedii> yes i love ambiguity
11:11:50 <Smerdyakov> Ambiguity is an opportunity to state your own refinement of the question.
11:11:51 <XTL> Just put in "mu"
11:12:23 <jedii> Smer: no, im asking for peoples opinions, and discussing them
11:12:35 <jedii> so i can write informed answers to my research topics
11:12:37 <jedii> ok? :)
11:12:58 <Smerdyakov> jedii, well, depending on how the professor means the question to be done, that could be construed as cheating.
11:13:37 <jedii> so if i ask a pal in my programming class, "hey buddy, i wonder if you could tell me hat makes a programming language a good language to teach introductory programming concepts??
11:13:47 <jedii> Do you think thats considered cheating?
11:13:48 <jedii> no.
11:13:53 <jedii> what is the difference here?
11:13:54 <jedii> :)
11:14:09 <Smerdyakov> I think that would be cheating if the first thing were cheating.
11:14:19 <jedii> what do you mean first thing?
11:14:28 <Smerdyakov> Asking us here.
11:14:31 <edwinb> I note that none of us have actually given an outright answer yet.
11:15:05 <jedii> ok i am amused at your distinction between asking a friend, and asking a stranger the same question
11:15:11 <Smerdyakov> No
11:15:14 <Smerdyakov> I am making _no_ distinction.
11:15:22 <edwinb> What do you think introductory programming concepts are, jedii?
11:15:51 <jedii> I think introductory concepts are things like understanding the definitions and meanings of things such as
11:16:17 <jedii> Variables, Functions, Objects, Constants, What an algorithm is
11:16:30 <jedii> What a compiler is, what an interpreter is
11:16:32 <jedii> etc
11:16:35 <jedii> What are your thoughts?
11:17:40 <edwinb> I prefer a language where I can express my understanding of a design/program without having to give too many low level details...
11:17:58 <jedii> I have a feeling the question being asked is referring to the notion that certain program paradigms may be easier for the beginner program to grasp, than others
11:18:02 <edwinb> When you're learning to program, you don't want to know about too many low level things.
11:18:19 <edwinb> I think you know enough to give a good answer, to be honest ;)
11:19:17 <jedii> Also, the more it remains like natural language, the easier it is to learn, i think
11:19:28 <jedii> what do u call it when its more like natural language
11:19:30 <edwinb> What, like COBOL?
11:19:32 <jedii> theres a word for it im sure hehe
11:19:40 <jedii> yeah, perhaps, is that what cobol is like?
11:19:47 <Lor> Gaaah! :)
11:19:57 <edwinb> That's another way of saying "I disagree" ;)
11:21:27 <edwinb> http://en.wikipedia.org/wiki/COBOL -- just look at the "hello world" example
11:24:15 <jedii> ewww
11:24:25 <jedii> not lovely
11:28:18 <Marvin--> "Its lack of support for object-oriented programming is understandable, given that the concept was unknown at the time"
11:28:24 <Marvin--> how ... generous of the writer
11:29:08 <jedii> lol
11:30:40 <jedii> http://www.theadvisors.com/langcomparison.htm
11:30:49 <jedii> this seems to be good for comparing the level of languages :p
11:32:18 <Lor> Aargh, software project management wishwash...
11:32:37 <TheHunter> i wonder what kind of programming language "HTML 3.0" is. But seems to be very efficient
11:33:09 <jedii> is ruby almost like smalltalk?
11:33:13 <Lor> Friggin' idiots want to measure everything and conjure up some factors out of nowhere...
11:34:07 <XTL> Indeed
11:35:14 <eshu> it has allot in common with smalltalk
11:36:26 <Si\> How would you go about converting a unified polymorphic function back to a general polymorphic function?
11:37:24 <jedii> now im all confused, do they mean high level programming language, as in, closest to machine language
11:37:36 <jedii> or high level as in 5th generation languages
11:40:38 <Lor> It's marketroid nonsense.
11:40:58 <Lor> (The "5th generation" bit, that is)
11:41:13 <Lor> Usually high-level means that it provides more abstractions.
11:41:41 <jedii> hehe meaning?
11:41:55 <Lor> I tend to think of the "height" of a language as in: "how directly can I express my intuitive concepts about the problem domain in this language"
11:42:20 <TheHunter> if Lines of Code is a measure, here you go http://shootout.alioth.debian.org/craps.php?xcpu=0&xloc=1&methcall=0&objinst=0
11:43:04 <jedii> the higher it is, the closer to human language it is?
11:44:20 <TheHunter> haskell is pretty high-level but not at all close to human language
11:44:28 <Lor> The closer to human _thought_, not language.
11:44:58 <Lor> Humans are good at thinking abstractly, but natural language is not good for expressing the thoughts precisely enough.
11:45:28 <jedii> yeah
11:45:42 <XTL> .. unambiguously and to someone or something else that should grasp the meaning etc
11:45:49 <jedii> im off to bed, thanks again :)
11:48:42 <Lor> btw, in general I only consider "cheating" about homework to be such activities where one gets an answer to a question without fully understanding the way in which that answer was obtained.
11:54:31 <Aglarion> re
11:54:53 <Aglarion> is there something like lisp's (trace x) in haskell?
11:55:11 <Lor> Yes, but it's a hack.
11:55:23 <Lor> Hood might be closer to your needs.
11:55:24 <Aglarion> no "clean" way?
11:55:30 <Lor> Or buddha, but I don't know it well.
11:55:31 <Aglarion> what does hood do?`
11:55:55 <Lor> Hood is a clean design, but it is internally implemented with lots of magic impure things.
11:56:10 <Aglarion> mhh..
11:56:11 <Lor> Hood allows you to trace function calls and see their return values.
11:56:17 <Aglarion> so there is no easy way?
11:56:31 <Lor> Hood is pretty easy to use.
11:56:31 <Aglarion> but hood is no standard haskell?
11:57:00 <Lor> It probably uses some non-haskell98 extensions. But why do you care?
11:57:09 <Lor> H98 compatibility is rarely important when debugging.
11:57:42 <Aglarion> i know... but are these extensions ghci specific or will it work with hugs?
11:59:08 <Lor> Yes, hood works with hugs.
11:59:13 <Lor> Hugs does implement lots of common extensions.
11:59:38 <Aglarion> good.
11:59:44 <Aglarion> then i'll better get hood
12:02:53 <Aglarion> ERROR "C:\Programme\Hugs98/libraries\Observe.lhs":310 - Syntax error in type expression (unexpected `.')
12:02:57 <Aglarion> oh wait
12:03:03 <Aglarion> hugs is running in haskell98 mode
12:03:24 <Aglarion> works better with -98 :-)
12:04:58 <Aglarion> thank you once again Lor
12:05:25 <Aglarion> learning haskell is for me more saying thank you than actual learning :-)
12:59:52 <Smerdyakov> SamB, have you just started college?
13:08:13 <pesco> Haha, playing through the hell level in Doom 3 set just the right mood for reading about call/cc.
13:20:03 <musasabi> Any haskell trie implementations out there?
13:20:18 <Lor> Why would you want a trie?
13:20:40 <musasabi> "data Trie a = T a [Trie a]" comes to mind first.
13:20:53 <musasabi> Lor: prefix matching.
13:20:59 <kosmikus> http://www.informatik.uni-bonn.de/~ralf/publications/GGTries/
13:21:21 <musasabi> Lor: please tell if there is a better alternative.
13:21:45 <kosmikus> musasabi: ^^^
13:23:30 <Lor> musa, ordinary ordered trees do quite fine.
13:24:18 <Lor> The question is mostly about the space.
13:24:44 <Lor> Unless your entries are realy dense, I doubt tries are going to be of much use.
13:24:54 <Lor> s/realy/really/.
13:25:22 <ibid> tries make sense as a kind of hashing - generally you don't use more than three levels
13:26:04 <Lor> Well, if you have a three-part key, you could just treat it as a three-part key.
13:26:25 <Lor> A hierarchical hash might be sensible in some situations, but not by default, I'd say.
13:26:27 <ibid> no, the key is usually a sequence of unlimited length
13:27:15 <Lor> Looking up a key of length n is _always_ at least an O(n) operation, so tries don't buy you much compared to hashes.
13:27:37 <musasabi> basically I have "type Key = [String]" and have data of the form "(Key, Value)" and want to find the longest match for any given key.
13:27:52 <ibid> Lor: tries *are* hashes
13:28:04 <ibid> extremely simple ones
13:28:17 <ibid> the debian pool is essentially a one-level trie
13:28:19 <musasabi> (all keys match in this case as we have a value defined for ([], v)
13:29:19 <Lor> A hash table is by definition a flat array.
13:29:32 <Lor> The values it maps to may be other hash tables, of course.
13:30:28 <cm> Hi! Does any know of any scientific library for Haskell? Primarly I'm looking for a efficient matrix implementation
13:31:00 <ibid> high-performance numerics and haskell don't seem to be very compatible
13:31:08 <ibid> though i'm sure someone has managed even that feat :)
13:32:15 <cm> A factor 3-5 of c is acceptable to me
13:37:01 <ibid> Lor: istr by knuth's calculations a three-level trie can be useful sometimes (though i'll be damned to remember the details:)
13:43:29 <Lor> Justifying circumstances can be found for anything. :)
13:43:40 <ibid> :)
13:43:46 <Lor> Oh, btw, I returned my thesis today.
13:43:46 <Boegel> does anyone know I mr. Meurig Sage is still active in the 'Haskell field' ?
13:43:47 * ibid rather likes tries
13:43:55 <ibid> Lor: not graded yet?
13:43:59 <Lor> Oh, I like them too. I wish they'd be more useful.
13:44:02 <shapr> Lor: for a refund?
13:44:05 <Boegel> Lor, thesis on ?
13:44:34 <Lor> No, a thesis typically isn't graded in a couple of hours. :)
13:44:48 <ibid> Lor: i think the proper phrase is "turned in" :)
13:44:52 <shapr> "Today I returned my thesis for a refund on the last six years. I felt they hadn't actually taught me anything."
13:44:59 <Lor> whatever.
13:45:01 <ibid> Lor: here it's usually turned in after grading :)
13:45:04 * shapr grins
13:45:16 <Lor> I'm drunk, I'm entitled to poor phrasing.
13:45:25 <shapr> Lor: oh, in that case, you're remarkably coherent.
13:45:44 <shapr> heck I can't english when drunk, much less a language I didn't grow up with.
13:45:45 <musasabi> Lor: congratulations.
13:45:50 <Lor> Obviously I'm not drunk enough. :)
13:45:55 * shapr notices the missing words in that *sober* sentence.
13:46:17 <Boegel> Lor, what's the topic of your thesis ?
13:46:26 <ibid> Lor: i mean, officially there is a procedure by which you turn it in first and it is then graded, but in practice the supervisor and another teacher just assign a grade at some point, sometimes even before the author knows that this is being done :)
13:46:37 <Lor> It's "taiteiden yˆ" out here, but it's raining so I'm not very attracted to going out.
13:46:42 <ibid> shapr: english is a verb? ;)
13:47:15 <musasabi> yes, not very nice this year..
13:47:27 <Boegel> hmm, am I invisible ? :p
13:47:54 <musasabi> (of course my gf being away the whole week on a work trip might have to do with my opinion)
13:48:43 <shapr> hiya Boegel 
13:48:49 <Lor> Boegel, sorry. I'm drunk, and thus my concentration is not the best imaginable.
13:48:50 <Lor> It's about reflection in statically typed languages.
13:48:52 <shapr> musasabi: heh!
13:48:53 * Boegel looks confused and wonders what he has done wrong
13:48:57 <Boegel> oh, here we go :)
13:49:07 <kosmikus> Lor: congratulations
13:49:18 <shapr> I saw tr√§nbar koskenkorva a coupla days ago in the Systembolaget.
13:49:26 <Boegel> statically typed ? I'm sorry, but I'm pretty new here
13:49:28 <shapr> I was unable to persuade Bea to let me buy it though.
13:49:30 * musasabi remembers Lor speaking about that sometime rl..
13:49:34 <Boegel> I know what reflection is
13:49:47 <Boegel> atleast, i knew, it has been a while =)
13:50:04 <shapr> I did end up with a bottle of sake from the USA.
13:50:15 * shapr √§lskar sake
13:50:22 <shapr> hiya CAP6055 
13:50:22 <kosmikus> Boegel: statically typed == typed at compile time
13:50:28 <shapr> CAP6055: what can we do for you?
13:50:40 <Lor> Spent a hell of a lot of effort just to say that typed reflection isn't being done currently.
13:50:42 <Boegel> like Haskell ?
13:50:44 <shapr> Lor: haha
13:50:45 <kosmikus> yes
13:50:49 <jesse98> in other words type errors are detected at compile-time instead of at runtime
13:51:02 <shapr> Lor: on the good side, you got me and a bunch of other people thoroughly interested in changing that.
13:51:25 * ibid is supervising an msc thesis that spends a lot of effor just to say that real-time garbage collection is hard and often done wrong
13:51:28 <kosmikus> jesse98: well, I guess C counts as statically types as well
13:51:30 <Boegel> how does that work in Hugs then ? that an interpreter...
13:51:33 * Smerdyakov throws reflection in the river!
13:51:39 <jesse98> yes kosmikus
13:51:43 <shapr> ibid: what about the 'non-stop haskell' paper?
13:51:47 <kosmikus> jesse98: with Haskell, your description is true, though
13:51:51 <Lor> boegel, now there is a question.
13:51:53 <musasabi> reflection is very nice.
13:51:58 <ibid> shapr: real-time needs more than just non-stop
13:51:59 <jesse98> c is a statially types language with gaping holes in the type checker :-)
13:52:21 <Lor> I allowed myself to indulge in some subjective ranting at the end, and basically stated that the entire idea of the phase distinction between "compile-time" and "run-time" is just silly.
13:52:31 <ibid> yeah
13:52:46 <ibid> static and dynamic attributes sound a lot more learned ;)
13:52:52 <Boegel> silly? why ?
13:52:53 <shapr> ibid: I wonder if Haskell-style generational garbage collection could allow relatively easy programming of non-cache-coherent NUMA. I think that has real potential.
13:52:58 <Lor> Because nothing is static.
13:53:04 <Lor> Look at hugs.
13:53:13 * shapr agrees with Lor.
13:53:18 <Lor> You give it expressions at _run-time_, and it type-checks them at _run-time_.
13:53:36 <Lor> When you compile a haskell program with ghc, the type-checking happens at the _run-time_ of the compiler.
13:53:42 <shapr> That's why I call Haskell 'compile-time dynamically typed'.
13:53:47 <kosmikus> yes, interpreter/compiler run-time, but not program run-time
13:53:51 <jesse98> there's a difference between allowing interactive environments and requiring programs to carry around a compiler/interprter lor
13:54:00 <shapr> kosmikus: with TH you get that too.
13:54:08 <ibid> Lor: i used "static" with the meaning 'constant between executions' ;)
13:54:30 <Lor> you are assuming that there is some static "thing" that is being executed.
13:54:30 <musasabi> kosmikus: but parts of the program may be evaluated at the compiler runtime too...
13:54:34 <kosmikus> well, the distinction still makes sense -- you can complain about the names, but not about the concept
13:54:44 <Lor> No, I complain about the concept.
13:54:49 <Lor> It is artificial.
13:54:57 <kosmikus> but important
13:55:04 <Lor> It's just an optimization hack.
13:55:14 <jesse98> it's not like it's a new subject lor, the lisp community has been wresting with it for decades
13:55:15 <ibid> Lor: it is a useful distinction given that often code is reused between executions
13:55:22 <kosmikus> if you call type safety an optimization
13:55:38 <Lor> jesse, yes, but lisp isn't typed.
13:55:40 <ibid> Lor: it's not optimization hack, it has to do with how one theoretically analyzes language constructs :)
13:55:49 <shapr> type safety does let you prove that certain optimizations are safe.
13:56:10 <Boegel> leaving, sleep tight everybody
13:56:17 <jesse98> from what I can tell they seem to see some value in separating compile-time from runtime so that efficient implementations can be written
13:56:19 <shapr> g'night Boegel 
13:56:33 <ibid> shapr: you don't need to force a type discipline down the programmer's throat for that
13:56:36 <Lor> It's quite fine to perform analysis on a program beforehand, and use the thus ascertained properties to make sure that a number of future executions will behave in a certain fashion.
13:56:40 <shapr> ibid: true
13:56:41 <jesse98> lisp is very much typed
13:56:47 <jesse98> especially common lisp
13:56:57 <Riastradh> Types are hyped.
13:57:04 <Lor> jesse, no it's not, by the terminology that type theorists use.
13:57:27 <Riastradh> Mathematical lingo tends to be misoverreused.
13:57:29 <Lor> But this is not a technical issue. Language is a cultural phenomenon.
13:57:30 <jesse98> ok, by the terminology that 99.9% of programmers use lisp is typed
13:57:30 <kosmikus> Riastradh: if we wouldn't hype them, who would remain ;)
13:57:32 <ibid> i submit type theorists have fallen to the ivory tower trap
13:57:40 <Lor> Quite possible.
13:58:06 <Lor> In any case, it's not very important. As long as one makes clear which terminology one is using, there should be no problem.
13:58:10 <ibid> i'd like to remind people about strachey's nice quote from the sixties
13:58:13 <shapr> I do like epigram's ability to specify behaviour in the types.
13:58:35 <shapr> At least, it does more with less work than Haskell's HM type system.
13:58:35 <jesse98> why would a type theorist say lisp isnt typed anyway/
13:58:37 <kosmikus> yeah, I'd say types are underestimated
13:58:46 <Lor> And, as I advocate breaking down the static/dynamic barrier, I also do think that types as run-time objects make sense.
13:59:01 <shapr> Lor: I agree.
13:59:10 <musasabi> Attaching behaviours to values and reasoning about program correctness based on them is valuable.
13:59:13 <ibid> Lor: my problem with the type theorist terminology is that it unnecessarily restricts the extension of the term "type", leaving no good word for the stuff that gets cut out, while a perfectly good modifier is available to designate their meaning
13:59:13 <mattam> reflection advocates ...
13:59:23 <Lor> However, run-time types are something slightly different from the run-time tags in lispy languages.
13:59:33 <ibid> jesse98: type theorists don't call runtime types types
13:59:36 <kosmikus> note that Epigram does *not* break down the static/dynamic barrier; it is statically checked that your program is correct
13:59:50 <Lor> ibid, what's wrong with "tagged values"?
13:59:51 <esap> Types as run-time objects do make sense, but they're just some specific kind of data. But the compile-time types are completely different thing, since they can enforce properties of the programs before the program is run, which is much better than doing it while the program runs.
13:59:56 <musasabi> dylan is an interesting approach in between.
13:59:59 <shapr> epigram is a lot more incremental though.
13:59:59 <ibid> Lor: because the values may not be tagged
14:00:06 <jesse98> but exactly the same thing happens, only difference is that the runtime instead of the compiler/interpreter does it
14:00:12 <Smerdyakov> Lor, you think run-time types make sense for the majority of applications?
14:00:17 <shapr> in Haskell, the closest thing to epigram's sheds is Template Haskell and hs-plugins.
14:00:19 <Lor> ibid, well, tagged values _is_ what most people mean when they talk of dynamic typing.
14:00:35 <musasabi> Types are imho just assertions. And statical typing means that those assertions are proved at compile time - in dynamic case they are postponed later.
14:00:43 <Lor> Smerdyakov, I think everything is run-time, so if types are useful anywhere, so are run-time types.
14:00:54 <ibid> Lor: what's the word for the thing that provides an interpretation for the bits in a memory area in a traditional algol-style language? i'd say it's the runtime type.
14:01:08 <shapr> yah, the author of Forth once said in an interview "Types are just a crutch for programmers."
14:01:08 <Smerdyakov> Lor, you don't think that it's easier to reason about programs with a phase distinction?
14:01:15 <Lor> ibid, no, that's static.
14:01:52 <musasabi> Smerdyakov: no actually, because that forces one to use different abstractions to encode static and dynamic assertions.
14:01:56 <ibid> Lor: you misunderstand me.  i'm sorry i wasn't clear :)
14:02:00 <Lor> Smerdyakov, of course it is. But assuming the phase distinction crucially reduces the number of programs that you can reason about.
14:02:18 <shapr> I wish Data.Dynamic values actually had the real type descriptor from the types table, rather than just a pointer into the table. Then I could easily throw them from one RTS to another.
14:02:27 <ibid> Lor: i find it surprisingly hard to explain what i mean if i cannot assume that you already know what i'm talking about :)
14:02:28 <Lor> The problem is: how do you formalize what hugs does?
14:02:29 <Smerdyakov> Lor, that leaves you with the task of showing that the majority of applications benefit significantly from using these disallowed programs.
14:02:44 <kosmikus> shapr: with Clean, you can
14:02:45 <ibid> Lor: see "object-level types" in my 2002 popl lecture notes
14:02:58 <shapr> kosmikus: I'm very Haskell-biased.
14:03:00 <shapr> :-)
14:03:07 <kosmikus> shapr: me too :)
14:03:09 <Smerdyakov> musasabi, the compiler handles the static/type-system assertions for you, so you don't have to reason about two abstractions yourself.
14:03:12 <Lor> Give me an url, I'm too tired/lazy/drunk/whatever to look up.
14:03:39 <ibid> http://www.mit.jyu.fi/antkaij/opetus/okp/2002/moniste/
14:04:06 <Lor> Okay, which part? :)
14:04:08 <shapr> I wonder if I can file out the typerep somehow...
14:04:31 <ibid> Lor: looking it up :)
14:04:43 <Smerdyakov> musasabi, which is based on the crucial fact that we choose the static abstraction to be (tractably) decidable and the dynamic abstraction to be undecidable. It's a good way to automate parts of the work.
14:04:55 <musasabi> Smerdyakov: so broaden it to handle dynamic assertions too, and generate checks for those it cannot check at compile time.
14:05:02 <Lor> ibid, I intend to hold a course on basic PL theory next semester, if possible.
14:05:02 <ibid> bah, firefox segfaulted on me
14:05:14 <ibid> Lor: interesting. maybe we should share notes :)
14:05:14 <Smerdyakov> Lor, what is it to "hold a course"?
14:05:36 <Lor> Sorry, me english seems to be deteriorating... :)
14:05:38 <musasabi> Lor: at cs.helsinki?
14:05:41 <Smerdyakov> musasabi, indeed, dependent type systems can do things like that.
14:05:44 <ibid> Lor: i'm holding a remake of the POPL course starting two weeks from now
14:05:47 <kosmikus> Smerdyakov: to teach
14:06:00 <Smerdyakov> Lor, how long ago did you start university?
14:06:04 <ibid> Lor: and, true to my style, it's impossibly hard for the students and probably lacking in some areas :)
14:06:25 <Lor> I'm resorting more and more in direct word-to-word translations between Finnish and English, and forgetting about how things are expressed idiomatically.
14:06:39 <ibid> Smerdyakov: he means being responsible for the course, including giving the lectures
14:06:49 <Lor> My grammar and typography seem to be fairly ok for now, though.
14:07:03 <ibid> Lor: beware of that path, btw, it can lead you to eternal mscification :)
14:07:28 <Smerdyakov> Lor, how long ago did you start university?
14:07:41 <Lor> Until then, though (next autumn at the earliest), I'll probably be in the private industry, trying to hoard some cash.
14:07:55 <Lor> Smerdyakov, I enrolled in '96.
14:08:08 <Lor> I've been studying lots of stuff, and, well... it's complicated.
14:08:11 <shapr> I'd be interested in writing up something to show how the FP and commercial programming communities could be closer.
14:08:25 <Lor> I could have gotten a degree by 2000, if I'd wanted to.
14:08:45 <ibid> Lor: care to read my draft and destroy all of my pretense of doing a good job on it :)
14:08:49 <Lor> I could be a doctor by now, if I'd wanted to.
14:08:54 <musasabi> the "Ohjelmointikielten periaatteet" kurssi at cs.helsinki.fi last spring was a bit dissapointing (algol/OO things, not much about FP)
14:09:01 <shapr> yay finnish!
14:09:09 <shapr> ohjelmointia!
14:09:18 <ibid> shapr: you can read it too, if you want (lots of finnish)
14:09:21 <Lor> Vihavainen tries to say a little bit about everything, IIRC.
14:09:22 <shapr> hehe!
14:10:01 <Lor> musa: ppohja held the exercises?
14:10:08 <shapr> Is there anything outside of procedural(and oop), FP, and logic/constraint?
14:10:19 * shapr is looking for new concepts.
14:10:21 <emu> spaghetti
14:10:25 <ibid> Lor: page 50 and onward
14:10:27 <shapr> emu: good point.
14:10:30 <Riastradh> No, that's an old concept, emu.
14:10:39 <emu> so is XML
14:10:56 <Lor> spaghetti is what procedural was supposed to fix.
14:10:59 <shapr> ibid: if it's in finnish, I doubt I could help much.
14:11:00 <Riastradh> Yes; your point?
14:11:03 <esap> shapr: There are dataflow languages, which I guess could be considered different.
14:11:18 <musasabi> Lor: yes.
14:11:24 <shapr> are there any F/OSS dataflow langs that would give me the flavor?
14:11:34 <shapr> libre logiciel?
14:11:47 <jesse98> oz has a data flow flavor
14:12:00 <emu> bring back spaghetti code! but give it a snappy name
14:12:08 <musasabi> shapr: erlang folks want to call themselves concurrency oriented from time to time.
14:12:13 <shapr> Cool, Mozart/Oz is next on my list anyway.
14:12:19 * esap hasn't actually ever used a dataflow language, I saw some papers and didn't understand any of it.
14:12:25 <jesse98> oz is an interesting language
14:12:26 <Riastradh> How about 'pasta code?'
14:12:35 <emu> tortellini code
14:12:35 <Lor> oz is a freaky-looking language.
14:12:38 <musasabi> oz suffers from a horrible syntax.
14:12:45 <shapr> Hm, I think I'm more likely to investigate Pict when I want to focus on concurrency.
14:12:48 <emu> musasabi: you're saying that on a haskell channel
14:12:50 * Lor has only looked at oz when reading Alice sources.
14:12:52 <Riastradh> Oz suffers from everything bad about _every_ paradigm it tries to include.
14:12:56 <ibid> what was ravioli code supposed to be? :)
14:12:59 <jesse98> i dont think oz is all that horrible looking
14:13:02 <Riastradh> ibid, Intercal.
14:13:02 <emu> ibid: tasty
14:13:07 <shapr> hola jadrian 
14:13:08 <jesse98> of course i'm a long-time c++ programmer :-)
14:13:11 * emu is hungry
14:13:12 <jadrian> hello
14:13:14 <jadrian> hi shammah 
14:13:15 <jadrian> opss
14:13:16 <shapr> I've been meaning to learn C++
14:13:18 <jadrian> hi shapr  
14:13:24 <emu> c++ is insanity-oriented programming
14:13:33 * Riastradh didn't have breakfast, brunch, lunch, snack, or dinner today.
14:13:38 <musasabi> dataflow is nice in principle, but it dies a quick death in heteregenous enviroments where you don't trust anyone.
14:13:39 <emu> so that's a new paradigm for you
14:13:40 <shapr> like, more than just enough to fix bugs in debian packages.
14:13:50 <ibid> Riastradh: no, intercal is the language of the diplomats
14:13:52 * esap would characterize C++ as C-compatibility-oriented programming.
14:13:53 * Riastradh is hungry for supper...snarrrrll...
14:13:54 <musasabi> emu: haskell syntax is nice...
14:13:54 * jadrian is not used to the new xchat autocomplete yet...
14:13:57 <jesse98> only good think in c++ is the template meta-programming, and programming with that is like driving nails into your forehead
14:13:58 <ibid> (be polite but not too polite)
14:14:01 <musasabi> c
14:14:22 <shapr> emu: I have a book by Alistair Cockburn, "Surviving Object Oriented Projects". The whole book in a nutshell is "Don't use C++, ever."
14:14:22 <emu> jesse98: some people enjoy that
14:14:44 <emu> for example, shapr, who desires to use C++ now that he was warned away from it ;)
14:14:51 * shapr cackles
14:15:00 * emu hands shapr some nails
14:15:13 <shapr> actually, all the want ads for Linux programmers in these parts are for C++
14:15:21 <ibid> Lor, shapr: current draft at http://www.mit.jyu.fi/antkaij/tmp/okp2.pdf
14:15:23 <shapr> so I figure, it can't be harder than Haskell.
14:15:33 <emu> shapr: it's a secret microsoft plot to destroy the minds of all linux programmers
14:15:44 <emu> require them to learn C++
14:15:44 <jesse98> it's a lot harder to learn well shapr
14:16:07 <Lor> All right, I think I'm mildly anesthesized by now.
14:16:11 <emu> waste our time learning C++ instead of writing better software
14:16:17 <mattam> and it's so verbose and unhelpful...
14:16:21 <jesse98> const is ctually a pretty cool feature of c++ too
14:16:27 <ibid> uh, sorry, wrong version :)
14:16:30 <Lor> Still no typographical problems, apparently.
14:16:54 <jesse98> easy to ignore feature, but helps a lot with aliased state
14:17:06 <shapr> well, I'd like to make money to fund my Haskell habit.
14:17:24 <shapr> but I'm getting tired of doing web-dev, it can be repetitive.
14:17:36 <ibid> Lor, shapr: correct version at http://www.mit.jyu.fi/antkaij/tmp/okp2.pdf
14:17:37 <Lor> My "final" version of the thesis, fwiw: http://www.cs.Helsinki.FI/u/lealanko/gradu/20040826-submitted.ps
14:18:09 <Lor> (No doubt some minor corrections will abound when it gets reviewed, but nothing major)
14:19:14 <shapr> Lor: that's a big file.
14:19:30 <Lor> It's because there are a couple of screenshots there.
14:19:34 <shapr> ah, ok.
14:19:49 <shapr> Was wondering just how thoroughly you covered the subject matter.
14:19:50 <Lor> The earlier versions used PS level 3, which supported compression quite well, but the printers barfed on it.
14:20:03 <shapr> 133 pages isn't too bad though.
14:20:09 <Lor> So these are just plain level 1 PS.
14:20:15 <ibid> about the same length as my own msc thesis :)
14:20:19 <ibid> probably better, though
14:20:28 <ibid> (even though they did give me the highest grade)(
14:20:33 <Lor> Well, I used that as a sample of a sensible length. :)
14:20:35 <cptchaos> lambdabot: @sepBy  
14:20:35 <lambdabot> Sorry, I don't know the command "sepBy", try "lambdabot: @listcommands"
14:20:41 <ibid> Lor: heh, cool :)
14:20:42 <shapr> @index sepBy
14:20:42 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Combinator
14:20:51 <cptchaos> shapr: thanks
14:20:56 <shapr> sure
14:20:58 <Lor> Usually theses are 50-70 pages hereabouts, though.
14:21:17 <ibid> yeah
14:21:22 <shapr> From my USA viewpoint, Finnish people are overly modest.
14:21:24 <mattam> "reflection advocates" is said, how could have been more right ? :)
14:21:24 <Lor> (and with a longer lineskip)
14:21:28 <ibid> there have been ultra-short too
14:21:31 <mattam> s/is/I/
14:21:32 <Lor> shapr, we're proud of our modesty. :)
14:21:35 * shapr laughs
14:23:05 * shapr skips to page 61
14:23:10 <Lor> Finnish culture has traditionally despised overt self-advocation, although this is slowly changing as american business culture is creeping in.
14:23:26 * Lor is a very traditional Finn in this respect, though.
14:23:32 <jesse98> those evil americans!
14:24:15 <emu> muhahaha
14:24:22 <shapr> Hm, I wonder if I can use the same ideas to add a 'search by type sig' plugin to lambdabot 
14:24:43 <ibid> the finnish culture is very protestant and lutheran despite being very secular at the same time
14:24:53 * shapr agrees
14:25:04 <shapr> It can be confusing to immigrants.
14:25:37 * ibid , on the other hand, am a very bad finn in that regard
14:25:43 <shapr> I'm a thorough Baptist, but I didn't go to church in Tornio, I think that equally confused all my acquaintances there.
14:26:38 <musasabi> well few young Finns go to church...
14:26:40 <Lor> The finnish culture has retained most of the non-religious aspects of a lutheran mindset.
14:26:44 <ibid> it takes me a lot of effort not to start emulating urgo from stargate...
14:27:09 <shapr> Lor: do you know if Cheney and Hinze's type equality code is actually available for GHC?
14:27:11 <ibid> "me me mememe, mememememememememe, me me ME!"
14:27:31 <shapr> or is it just described, and implementation left as an exercise?
14:27:38 * shapr googles for the paper in question.
14:27:47 <Lor> shapr, it's given verbatim in the paper.
14:28:10 <Lor> I don't recall seeing them releasing it as pure source, but you can just write it down as stated.
14:28:10 <shapr> ah, spiffy.
14:28:39 <shapr> cool
14:28:49 <ibid> i should probably go to bed
14:28:58 * Lor recalls trying to hack up a dynamics library that supported higher kinds, too.
14:28:58 <ibid> even though i haven't written my quota yet
14:30:12 <musasabi> btw I was thinking when cycling shopping (as opposed to looking around to avoid collisions) whether the linear types in ghc would be enough to implement mutable types in a safe manner?
14:30:28 <shapr> huh, I think this will let me move Data.Dynamic values from one RTS to another.
14:30:30 <Lor> Linear types in ghc?
14:30:37 <Lor> You mean the linear implicits?
14:30:45 <musasabi> Lor: yes.
14:30:58 <Lor> I don't think so.
14:31:10 <shapr> mutable types?
14:31:20 <musasabi> Lor: I think it is impossible, but cannot see why.
14:31:27 <Lor> The implicit parameters don't propagate "outwards".
14:31:33 <musasabi> that is "it cannot be so simple".
14:31:45 <Lor> You could of course do CPS.
14:31:48 <musasabi> Lor: and if outward propagation is not needed?
14:32:01 <Lor> If outward propagation is not needed, you don't need mutable state.
14:32:15 <musasabi> except as an efficiency hack ;)
14:32:21 <Lor> Well yeah.
14:32:25 <jesse98> your thesis looks interesting lor
14:32:40 <ibid> mutable state is an efficiency hack in any case :)
14:32:45 <Lor> It's just a survey, really.
14:33:00 * musasabi left it open on a different desktop - will read when more awake...
14:33:02 <esap> I think of mutable state as a mechanism for transforming the context.
14:33:03 <ibid> (well, it sometimes helps in structuring the program better)
14:33:21 <jesse98> (altho I tend to go for runtime type-checking with optional type annotations like dylan and clos)
14:33:25 <Lor> All right, it's a survey with the occasional original idea scattered here and there.
14:33:39 <Lor> Mutable state is just a perspective.
14:34:12 <Lor> It's the perspective where there are some implicit parameters that aren't explicitly mentioned in program code.
14:34:14 <ibid> the interpretation of imperative programming that has been the most influential for me is the idea that programs are predicate transformers
14:34:16 <musasabi> Lor: true, the compiler using implicitely mutation behind the scenes would be much nicer...
14:34:29 <esap> lor: ah you're right. It's a perspective where time is considered to be implicit.
14:34:34 <Lor> musa, ghc does use implicit mutation, ultimately.
14:34:43 <Lor> I don't want to bring in the concept of time.
14:34:55 <musasabi> Lor: yes, but not on the scale where explicit mutation would not be required.
14:35:00 <Lor> Time is a continuous thing, whereas ordinary computation happens in a discrete setting.
14:35:49 <musasabi> Lor: making it e.g. update finitemaps in-place whenever it is safe would be nice...
14:35:51 <shapr> Lor: this is excellent, lots of info in here I've wanted to know. Thanks for writing it.
14:35:53 <esap> lor: I'm thinking of a discrete time defined either by the evaluation strategy, by the semantics of reduction, or by the sequentiality of monads.
14:36:09 <ibid> time can be considered discrete for the purposes of computation analysis
14:36:17 <shapr> I'm sure Joachim Durcholz would want to read this too.
14:36:32 <ibid> (time is in a very real sense discrete in actual computers. too)
14:36:36 <jesse98> dynamic languages can be perfectly safe tho lor
14:37:05 <Lor> shapr, feel free to send the link wherever you like. I'm too modest to start plugging it myself. :)
14:37:25 <Lor> I do contemplate submitting a short summary to sigplan notices, thoug.h
14:37:30 <Lor> Whee, a typo!
14:37:30 <shapr> I tend to plug other people a lot.
14:37:45 <shapr> Has your thesis already been mentioned on lambda-the-ultimate.org ?
14:39:25 <Lor> Hopefully not. :)
14:39:51 <shapr> Why not? I think several people there would want to read it.
14:40:07 <Lor> Just because it has been a draft until now.
14:40:14 <shapr> oh, good point.
14:40:42 * ibid is depressed aboout his thesis project. maybe i should just do a taivalsaari: invent a language and write stuff about it
14:41:00 <Lor> Just after I turned it in, I recalled that I hadn't verified that TeX had done the hyphenation properly, so no doubt some minor typographical errors will yet arise.
14:41:23 <kosmikus> Lor: there'll always be errors
14:41:39 <Lor> ibid, say "dissertation" when you're talking about PhD. Helps to avoid confusion. :)
14:42:00 <esap> I got some simple acronyms wrong in my master's thesis. I was pretty embarrassed once I noticed that.
14:42:06 <Riastradh> What's your thesis, ibid?
14:42:09 <ibid> Lor: dissertation can also be used of a msc work
14:42:13 <Lor> If I were to do a PhD here, I'd probably have to do it on string algorithms or suchlike stuff.
14:42:27 <ibid> Riastradh: depends on when you ask, and on my mood :)
14:42:28 <shapr> Lor: I can link to that url directly, yes?
14:42:29 <Lor> ibid, in theory, yes. But in practice, not really.
14:42:48 <Lor> shapr, wait a sec.
14:42:53 <Riastradh> ibid, well...it's probably a pretty good guess that 'when I ask' is now, and that your mood is that right now!
14:43:25 <ibid> Riastradh: the official version was originally something like verification of the b method, but that has sunk
14:43:34 <Lor> shapr, I haven't published to the "great audience" very many things, and so I haven't considered what an appropriate url hierarch would be like.
14:43:41 <Riastradh> 'The b method?'
14:43:48 <ibid> Riastradh: the current semi-official version is "cool stuff about crossing formal methods and programming languages"
14:43:59 <ibid> Riastradh: right now, in this mood, i'd say: i bloody don't know :)
14:44:05 <Lor> What's "suuri yleisˆ" in english properly?
14:44:18 <ibid> Riastradh: are you familiar with formal methods?
14:44:22 <ibid> Lor: general public?
14:44:33 <Lor> Something like that, yes.
14:44:57 <shapr> Lor: In any case, I'm several of the people there will vociferously disagree with your conclusions. LtU is sort of like slashdot for FP people.
14:45:07 <Lor> Have I already mentioned that I'm drunk and that my linguistic aptitude is likely to suffer from it? :)
14:45:12 * shapr grins
14:45:22 <ibid> Lor: haven't noticed :)
14:45:38 * shapr remembers drinking salmiakki in Helsinki
14:45:40 <Lor> That's because grammar and typography are easy. But I lose the idioms.
14:45:51 <shapr> I *think* we were in the Zetor bar, but my memory is fuzzy for some reason.
14:45:58 <Lor> Hee. :)
14:46:01 <cptchaos> @index string
14:46:01 <lambdabot> Text.ParserCombinators.ReadP,Text.ParserCombinators.Parsec,Text.ParserCombinator
14:46:01 <lambdabot> .Parsec.Char
14:46:09 <Lor> Zetor is a restaurant, not just a bar.
14:46:22 <ibid> Riastradh: the b method is a formal method by the creator of the z notation, designed for construction of safety-critical (embedded) software
14:46:23 <jesse98> don't use "untyped" in section 2.2.3 lor
14:46:30 <Riastradh> I see.
14:46:32 <Lor> Too late now. :)
14:46:36 <jesse98> ha
14:46:45 <shapr> Z notation is pretty nifty.
14:46:58 <shapr> Not that I'd heard of it before ibid first mentioned it to me.
14:47:05 <jesse98> i read a vicous paper on formal methods the other day
14:47:11 <ibid> Riastradh: my msc thesis discusses the construction of the b method
14:47:18 <shapr> jesse98: ok, you're officially in the club then.
14:47:20 * shapr grins
14:47:52 * shapr is just being silly.
14:47:55 <ibid> my problem with my research topic currently is that it does not follow dijkstra's recommendation:
14:48:20 <ibid> choose a topic that you can do well and which likely only you can do well
14:48:39 <ibid> marrying formal methods and pl's is an 'in' thing currently in certain circles
14:48:45 <Lor> shapr, would you mind if you'd copy the ps to somewhere in your own domain before linking to it? I take url lifetime seriously, and I haven't yet considered how to organize my pages.
14:48:55 * esap hasn't heard that recommendation. Very good idea.
14:49:12 <shapr> Lor: fair enough, though I'll probably drop it if I get lambda-dotted.
14:49:23 <musasabi> Lor: symbolic links help... 
14:49:30 <Lor> Well yeah.
14:49:33 <ibid> car hoare has actually declared one of its facets a grand challenge in computing
14:49:40 <ibid> musasabi: and http redirects help more
14:49:43 <Lor> The thing is, I don't want everyone to see the drafts.
14:49:53 <Lor> And the current url resides in the draft directory.
14:49:58 <shapr> ah
14:50:23 <musasabi> ibid: of course but I forget those when reorganizing my public_html early in the morning, so they are more unsafe too.
14:51:01 <ibid> esap: the exact quote is "Never tackle a problem of which you can be pretty sure that (now or in the near future) it will be tackled by others who are, in relation to that problem, at least as competent and well-equipped as you are."
14:51:03 <Lor> Ah, what the hell. http://www.cs.helsinki.fi/u/lealanko/types-and-reflection.ps.gz
14:51:05 <shapr> I think I should write an actual homepage for myself, but HTML and XML are so passe.
14:51:12 <ibid> (http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1055A.html)
14:51:13 <shapr> Lor: ok, I'll use that.
14:51:21 <Lor> That ought to be sensible enough.
14:51:35 <jesse98> you keep saying untyped where you mean dynamically typed lor, there are very few untyped languages, B is about the only one I know of
14:51:58 <Lor> Provided that the filename is not too long. I don't want to call it just "thesis.ps.gz", since there are a gazillion of those already around. :)
14:52:00 <ibid> jesse98: you are arguing a lost argument
14:52:03 <shapr> Forth is untyped
14:52:15 <Lor> jesse, this is just a matter of terminology.
14:52:15 <ibid> jesse98: lor's terminology is standard in the circles where his thesis comes from
14:52:18 <jesse98> can't remember any forth :-)
14:52:25 <shapr> Lor: yah, I never want to see another thesis.ps.gz ever again.
14:52:30 <shapr> I have a zilion of them locally.
14:52:46 <ibid> Lor: you might want to name this still as -final-draft or something, in case the examiners demand changes
14:53:30 <Lor> Yes, the examiner told me that he will most likely find some typos that he wants fixed before the thing gets archived in the library.
14:53:39 <ibid> Lor: or are you evil enough to just replace the file? :)
14:53:40 <Lor> So this is not the final final final version.
14:54:07 <musasabi> replacing would be the most 'clean' approach.
14:54:23 <ibid> musasabi: replacing is evil
14:54:36 <Lor> ibid, depends on the semantics you assign to an url
14:54:46 <ibid> Lor: yes
14:55:06 <Lor> urls are a silly thing anyway. Too implementation-dependent.
14:55:10 <ibid> Lor: i prefer permanent urls for stuff that aren't obviously ephemeral
14:55:24 * Lor wishes that URNs, or non-URL URIs in general, became more common.
14:55:26 <ibid> everybody should just switch to storm already :)
14:55:35 <Lor> storm?
14:55:50 <ibid> something i helped write when i was an assistant researcher a couple of years ago
14:56:02 <shapr> well?
14:56:13 <Lor> Hm, how about la-msthesis.ps.gz?
14:56:15 <ibid> i'm looking up the paper
14:56:19 <Lor> A tad shorter.
14:56:23 <ibid> Lor: draft! ;)
14:57:26 <Lor> Gah. It can't be this hard.
14:57:44 <ibid> Lor, shapr: http://portal.acm.org/citation.cfm?doid=900084
14:58:05 <shapr> Lor: I think types-and-reflection.ps.gz is good.
14:58:11 <ibid> this, being a ht paper, is of course written for a hypertext audience
14:58:15 <shapr> I much prefer PS files named by their title.
14:58:28 <Lor> shapr, the thing is, if you publish the url at LtU, citeseer will probably find it at some point, and _then_ the url gets fixed.
14:58:29 <ibid> author should be included too
14:58:42 <shapr> Lor: you could just replace it with the 'real' version later.
14:58:44 <Riastradh> I prefer <author><two-digit-year><short-name>.ps.
14:58:53 <musasabi> Lor: please a name telling what it is about, sounds very good "types-and-reflection.ps.gz"
14:58:55 <Lor> Right, citeseer-naming.
14:58:55 <ibid> Lor: citeseer only indexes stuff that has been submitted to them
14:59:02 <Lor> alanko04types.ps.gz?
14:59:05 <shapr> I'm this close --->|  | to pushing the submit button.
14:59:21 <ibid> at least it used to
14:59:26 <Lor> shapr, uh, shouldn't you _read_ the bloody thing before plugging it to others? :)
14:59:27 <ibid> has to do with copyrights
14:59:28 <shapr> then you'll just have to live with types-and-reflection.ps.gz :-P
14:59:36 <shapr> Lor: I just read a bunch of it.
15:00:03 <shapr> I haven't read all of it, but thirty or forty pages is I think representative.
15:00:07 <Lor> Actually, I quite like citeseer-naming.
15:00:40 <Lor> alanko04types.ps.gz is there now.
15:00:48 <shapr> beleive it or not, I have ~/programming/languages/haskell/people/lor and a lauri.alanko symlink in the same dir.
15:01:08 <shapr> My haskell/people dir has a bunch of stuff.
15:01:17 <shapr> Lor: ok, I'll link to that.
15:01:26 <Lor> I don't categorize stuff by people, since almost everything is multi-authored.
15:01:32 <Lor> shapr, I think that's pretty much ok.
15:01:47 <Lor> If I later think it's a bad idea, I can blame myself for being drunk. :)
15:01:50 <shapr> heh
15:02:26 <Lor> Well... there's a technical point, though.
15:02:48 <Lor> It hasn't been officially approved yet, so strictly speaking it's not proper to refer to it as an MS thesis.
15:03:23 <shapr> see your name on the LtU front page :-P
15:03:31 <shapr> under "New Forum Topics"
15:03:44 <shapr> if one of the editors thinks it's cool they'll lift it to the front page.
15:04:22 <Lor> Gaah, you used my second name.
15:04:42 <shapr> Sorry, it was in the title page of paper that way.
15:04:44 <esap> lor: now you're famous :-)
15:04:54 <Lor> (The only reason I used it in the title page was that there's another Lauri Alanko at the university of Helsinki.)
15:04:58 <ibid> bah, bedtime, nnˆ :)
15:05:04 <ibid> s/nnˆ/bbl/
15:05:17 <Lor> You use qwerty? 
15:05:22 <ibid> yeah
15:05:22 <Lor> You should know better. :)
15:05:26 * shapr goes off to play a game for a bit
15:05:31 * shapr waves the dvorak flag first :-P
15:05:45 <ibid> Lor: i have special needs, and most other keyboards are discriminating :)
15:06:04 <Lor> Hm, you need to see the letters?
15:06:26 <ibid> no
15:06:46 <ibid> however, i cannot use the standard fingerings
15:06:57 <ibid> so anything that is optimized for that is a waste of time
15:07:32 <Lor> You type fairly fast, anyway. How many fingers do you use?
15:07:49 <ibid> six
15:07:52 <musasabi> having non-qwerty layout is evil for lending machines to other people.
15:08:08 <Lor> musa, that's an additional benefit. :)
15:08:20 <ibid> all five of the left hand and one from the right hand
15:08:43 <Lor> "can I borrow your machine?... what the f*ck?! ...maybe I'll find some other machine somewhere..."
15:09:08 <Lor> ibid, there's a left-handed dvorak layout, too.
15:09:45 <XTL> I used to have a keyboard that had all blank keys. Some people cursed at that, too.
15:09:54 <ibid> Lor: i even play the guitar using the right-handed method
15:10:22 <Lor> That'd be kinda neat. Though I still don't have the numeric keys and the special symbols ingrained in my spine.
15:10:36 * Lor mixes 7 and 8 when blind-typing.
15:11:00 <ibid> (anyway, i have a mild case of cerebral palsy, symptomatically hemiplegia spastica; it makes me essentially one-and-half-handed)
15:13:17 <Riastradh> ibid, come on.  This channel is for spouting obscure category theoretical terms of arcanity, not medical terms.  Cut it out!
15:13:27 * Lor feels a bit uncomfortable being aware that his thesis is currently plugged as "going a long way" towards something.
15:13:42 <Lor> Clearly this is an indication that I'm not drunk enough yet.
15:13:48 <ibid> Riastradh: oh, sorry ;)
15:14:30 * esap wonders if it's possible to interpret those medical terms via category theory. What is the dual of that? :-)
15:14:43 <ibid> (http://en.wikipedia.org/wiki/Cerebral_palsy)
15:15:24 <Lor> wikipedia seems to be having a bad day.
15:15:29 <ibid> (hemiplegia spastica is essentially a one-sided stiffness condition)
15:15:40 <Riastradh> Wikipedia works for me.
15:17:36 <Lor> Not for me.
15:17:58 * esap has written quite a bit of text about OO to wikipedia.
15:18:07 <ibid> works for me :)
15:18:14 * ibid has written some stuff to wikipedia
15:18:24 * Lor has only made a small terminological note about CPOs.
15:18:42 <ibid> "Hemiplegia: Only the right side or the left side of the body is involved. It represents the mildest form of CP. An individual with hemiplegic CP will have only few limitations in daily activities."
15:18:52 <ibid> "Spastic: Persons with this type have damage to the corticospinal tract, motor cortex, or pyramidal tract. It occurs in ~70% of all cases."
15:18:57 <shapr> Lor: going a long way towards answering my questions is a good thing.
15:19:28 <Lor> Oh, btw, has anyone here bothered to follow the insane and infinitely prolonged discussion about CPOs in c.l.s?
15:20:19 <Riastradh> If you're referring to the Richter thread (I can no longer tell what it's 'about'), I've followed whatever I find amusing.
15:20:33 <ibid> ohh, i was so engulfed in my military fiction that i thought you were talking abourt chief petty officers ;)
15:20:52 <Lor> shapr, my thesis actually answers something? Cool. What in it do you find edifying?
15:20:59 * esap also tried to look up CPO from wikipedia.
15:22:29 <ibid> anyway, i really need to go to bed, "nnˆ" :)
15:23:35 <Lor> g'night.
15:25:21 * Lor switches to the "Uh-oh, time to tank water" -stage.
15:29:05 <Lor> Hm, the icfp04-discuss -list seems to have died.
15:29:29 <Lor> Maybe there will be some revival once the official winners are announced...
15:30:15 <Lor> I think everyone agrees that this year was the coolest icfp contest ever.
15:33:33 <esap> yea, it was great, I learned a lot from just the problem description, not to mention attempting to solve it.
15:34:10 * Lor still regrets spending far far far far too much time on implementing the visualizer.
15:34:39 * Lor hadn't realized that it is actually quite possible to implement a useful visualizer with a simple character-based UI.
15:34:44 * TheHunter tries to relate CPOs and filters
15:35:27 <Lor> Filters as in?
15:35:54 <esap> as in dual to CPO.
15:36:10 * esap suggests.
15:37:56 <esap> or the first example in the CPO page in wikipedia of set of all non-empty filters?
15:38:10 * TheHunter is hopelessly confused
15:39:11 * esap often has that effect.
15:40:04 <esap> I better get some sleep
15:40:09 <TheHunter> dual means more than exchanging <= and >=?
15:40:22 <Lor> I still haven't managed to spend a while studying what adjunctions are, and hence I'm quite incapable of understanding most of the stuff you speak of. :)
15:41:45 <esap> TheHunter: It's basically reversing all arrows of a category, so yes, it's exchanging the direction. But duality does have some surprising consequences.
15:42:27 <Lor> Is this duality in the same sense as in wadler's icfp paper last year?
15:42:42 * Lor even understood it, and thought it was pretty cool.
15:42:43 <esap> yes
15:42:53 <TheHunter> i'm reading a book which defines a filter as the dual of the wikipedia-filter
15:45:04 <esap> I actually got involved in my current eternal project for building the compiler by trying to figure out duals of different things.
15:45:42 <esap> So it's fairly dangerous stuff.
15:46:39 <Lor> esap, what do you do nowadays for a living, anyway?
15:47:23 <esap> lor: I'm working for Nokia, thinking about how to build software.
15:48:36 <esap> That's not at all related to my compiler project.
15:48:55 <Lor> Right.
15:50:40 <esap> We're doing some telephone switch stuff, nothing very interesting.
15:51:05 <Lor> ...and not even in erlang. :)
15:51:58 <esap> no, but some of the things are quite closely related to FP, though the language is C++
15:52:32 <Lor> Eek!
15:54:25 <esap> I was actually once surprised that you *could* do that, but I suppose C++ doesn't really enforce any paradigm.
15:54:59 <Lor> It doesn't support GC.
15:55:10 <Lor> This pretty much precludes real modularization.
15:55:16 <jesse98> there are c++ GCers
15:55:26 <Lor> Yeah.
15:55:28 <esap> It doesn't, modularization doesn't need GC.
15:55:35 <Lor> The language is not designed for them, though.
15:55:46 <Lor> Destructors and gc don't fit together at all well.
15:56:12 <Lor> esap, I assume you are aware of the usual modularization arguments for GC.
15:56:23 <jesse98> well they could lor, the dtors just wouldnt be determinisitcally called
15:56:28 <esap> You can use destructors with GC. Destructors are invoked much before the GC has any chance of doing anything.
15:56:45 <esap> Finalizers are not close to destructors.
15:57:26 <Lor> esap, this is a scenario where only destructorless objects are gc'd?
15:58:04 <esap> No, it's a scenario, where finalizers hanle resource deallocation, but destructors are used for error handling purposes.
15:58:47 <Lor> Ah, sorry, I think I've finally reached my limits for tonight.
15:58:48 <esap> e.g. for determining what to do during exception propagation.
15:59:04 <esap> yea, me too, have to get some sleep.
15:59:10 * Lor will just play pools of darkness from now on till he passes out.
15:59:10 <Lor> g'night.
15:59:14 <esap> night.
16:14:20 <jedi`sleep> morning all :)
16:16:56 <XTL> screen moves sideways. Enough whisky or not enough sleep?
16:32:11 <jedi`sleep> can ruby be used for interfacing databases with other applications?
17:03:03 <jadrian> Was checking GHC.List in ghc sources
17:03:21 <jadrian> why those #ifdef USE_REPORT_PRELUDE
17:03:23 <jadrian> ?
17:03:31 <jadrian> for instance in reverse...
17:03:37 <jadrian> (small flood sorry)
17:03:42 <jadrian> reverse                 :: [a] -> [a]
17:03:42 <jadrian> #ifdef USE_REPORT_PRELUDE
17:03:42 <jadrian> reverse                 =  foldl (flip (:)) []
17:03:42 <jadrian> #else
17:03:42 <jadrian> reverse l =  rev l []
17:03:43 <jadrian>   where
17:03:45 <jadrian>     rev []     a = a
17:03:47 <jadrian>     rev (x:xs) a = rev xs (x:a)
17:03:48 <jadrian> #endif
17:04:44 <jadrian> I don't even see much of a difference between both defintions... that last one just seems to save one flip
17:04:59 <jadrian> but I don't think that should have any impact on performance
17:05:55 <Riastradh> Come on!  That foldl surely wastes a few instructions!
17:06:48 <jadrian> doesn't the compiler take care of that?
17:07:38 <Riastradh> Joking aside, I don't think there's really much difference unless foldl & flip are unknown functions.
17:08:52 * jadrian checking foldl
17:09:08 <jadrian> hmmm
17:09:16 <jadrian> foldl is actually just the standard definition
17:09:53 <jadrian> except that they went through trouble of defining a local function that uses the parameter function globably
17:10:13 <jadrian> hmmm they really seem to avoid passing arguments around as much as they can
18:19:40 <jadrian> is there something I need to import, to use unboxed types?
18:19:51 <jadrian> I always get syntax error on the #
18:19:56 <shapr> like what?
18:20:31 <jadrian> data Term = Bnd{bndBrj :: Int# } | ...
18:20:40 <jadrian> I get a syntax error there
18:21:37 <jadrian> tryed GHC.Base 
18:21:56 <jadrian> also using -fglasgow-exts...
18:22:12 <jadrian> hmm may have found it
18:22:17 <shapr> ?
18:22:37 <jadrian> nah
18:22:40 <jadrian> GHC.Exts
18:22:45 <jadrian> thought this might be it
18:23:41 <jadrian> shapr: any idea?
18:23:49 <shapr> er, it should work?
18:24:42 <shapr> hmm
18:25:23 <shapr> @index Int#
18:25:23 <lambdabot> bzzt
18:26:02 * shapr blinks
18:26:41 <shapr> hm!
18:26:53 <shapr> let x = (1 :: Int#)
18:26:55 <shapr> that's closer
18:27:10 <shapr> gives a kind error, but shows that you can use it.
18:27:50 <jadrian> I don't get any error with that...
18:28:07 * shapr shrugs
18:28:07 <jadrian> using fglasgow-exts
18:28:14 <shapr> I'm using 6.3
18:28:16 <shapr> cvs version
18:28:43 <jadrian> opss lol
18:29:00 <jadrian> I defined it outside the \begin{code} \end{code}
18:29:23 <jadrian> na just parse error on #
18:30:18 <jadrian> maybe we only need to buy the full version of GHC to have unboxed types...
18:32:32 <jadrian> oh well
18:34:17 * jadrian is off to bed
20:32:44 <kaol> I've made a nested construct of Maybe monads and case statements the tutorial at nomaware.com warned about. I can't quite figure how to turn that to using a monadic notation.
20:33:11 <kaol> I put my code at http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show. Any suggestions?
20:39:46 <monochrom> splitAmbles xs = do { (preable,rest) <- breakOnBrace xs; do { (x,y) <- insidebraces 0 rest; return (preamble,x,y) } `mplus` do { (preamble',amble,postamble) <-  splitAmbles rest; return (preamble++'{':preamble',amble,postamble) } }
20:53:05 <kaol> thanks... I think I'll stare at that for a while and see if I can figure out why it works.
20:53:25 <musasabi> morning
