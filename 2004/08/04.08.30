00:27:47 <dons> here's a game maybe someone wants to play with:
00:27:50 <dons> given: unpack :: Dynamic -> [Dynamic] = Data.Maybe.fromJust . fromDynamic
00:27:58 <dons> and let v = (let x = toDyn [x] in x)
00:28:02 <dons> unpack v
00:28:07 <dons> [<<[Dynamic]>>]
00:28:12 <dons> map unpack (unpack v)
00:28:17 <dons> [[<<[Dynamic]>>]]
00:28:22 <dons> map (map unpack) $ map unpack (unpack v)
00:28:27 <dons> [[[<<[Dynamic]>>]]]
00:28:31 <dons> map (map (map unpack)) $ map (map unpack) $ map unpack (unpack v)
00:28:36 <dons> [[[[<<[Dynamic]>>]]]]
00:28:51 <dons> come up with a function to unpack to an arbitrary integer depth
00:30:26 <Lor> Is definition of new classes ok?
00:30:37 <dons> yep
00:30:46 <dons> anything goes, I think
00:31:34 <Lor> Does the depth has to be specified as an integer parameter?
00:31:55 <dons> I would like that, but alternatives are fine, if they look nice :)
00:34:33 <Lor> class Unpack a where unpackn :: Dynamic -> a; instance Unpack Dynamic where unpackn = id; instance (Unpack a) => Unpack [a] where unpackn = map unpackn . unpack
00:34:40 <Lor> Haven' t tested.
00:35:19 <dons> ooh. lets see
00:36:23 <dons> you want: unpackn v ?
00:36:29 <dons> Couldn't match `Dynamic' against `[Dynamic]'
00:37:05 <dons> problem I think is that from the outside, it looks just like a [Dynamic], although it actually has deeper recursion
00:37:20 <dons> 'v' is a weird value
00:37:58 <dons> oh. maybe my fault. 
00:38:00 <dons> here we go:
00:38:01 <dons>     Ambiguous type variable `a' in these top-level constraints:
00:38:01 <dons>       `Unpack a' arising from use of `unpackn' at <interactive>:1:0-6
00:38:02 <dons>       `Show a' arising from use of `print' at Top level
00:39:49 <Lor> Did you give a type annotation?
00:39:53 <Lor> That's what determines the depth.
00:40:37 <dons> yeah, I see what you mean. let's see
00:41:16 <Lor> Works for me.
00:41:39 <dons> ah ha! yep
00:41:41 <dons> very nice
00:42:05 <ozone> Lor: hey, i had a read of your masters thesis
00:42:22 <Lor> Cool.
00:42:22 <ozone> Lor: very impressive, congratulations
00:42:39 <ozone> Lor: dunno if you remember me, i was one of the aussies you met at ICFP last year (andre)
00:42:52 <kosmikus> hi ozone
00:43:18 <musasabi> Is it possible to tell haddoc to do alpha -> &alpha; in type signatures?
00:43:27 <kosmikus> ozone: will you be at icfp this year?
00:43:48 <ozone> kosmikus: unless anything goes dreadfully wrong, i will be
00:43:54 <ozone> i'm writing up my travel poposal now
00:44:03 <Lor> ozone, sure I do. A realname would have aided recognition, though. :)
00:44:09 <kosmikus> ozone: cool
00:45:17 <ozone> Lor: http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image0.html <- bad picture
00:45:23 <ozone> kosmikus: et tu?
00:46:04 <kosmikus> ozone: yes, I'll go
00:46:47 <ozone> kosmikus: schweet!  who else from utrecht?  clara going, too?
00:47:15 <kosmikus> no clara this time, Arthur will be going, and Daan, otherwise I don't know
00:48:14 <earthy> that's A. Baars. :)
00:48:25 <pesco> Lor: Dang, you beat me to it. (re unpack)
00:49:11 <kosmikus> earthy: sorry :)
00:49:16 <ozone> earthy :)
00:49:26 <ozone> so, no doaitse?
00:49:41 <earthy> no probs ;) just thougth I'd clarify that, as people here might associate me with ICFP due to HC&A :)
00:52:21 <kosmikus> ozone: I don't know, but it could be
02:15:10 <musasabi> Is there a way to perform select/poll on channels or mvars ?
02:15:35 <Lor> There are unblocking versions, IIRC.
02:15:42 <musasabi> yes...
02:16:11 <Lor> Ah, you want to avoid manual polling.
02:17:04 <musasabi> select :: [Chan a] -> Bool, select = find (not . isEmptyChan) 
02:17:23 <musasabi> make that select :: [Chan a] -> Maybe (Chan a)
02:17:47 <musasabi> but that is not what I would call a good scalable solution
02:24:37 * earthy grins
02:24:55 <earthy> the end of the preface to the online edition of the Algol 68 RR states `Ich habe fertig'
02:26:29 * shapr yawns
02:30:20 <shapr> good morning #haskell!
02:46:08 <Jerub> good morning small mortal!
02:46:44 <shapr> I could stand being a bit smaller.
02:49:07 <Jerub> shapr: from 7 days ago, gmail invites were rare. now they are so common you can't give them away.
02:49:31 <dxlvi> oO
02:49:47 <Jerub> shapr: I am so happy to be hacking on CSy stuff again :))
02:49:49 <shapr> yay
02:49:54 <dxlvi> a month ago i had 6 invites, and i didnt get any since then :-(
02:50:12 <Jerub> dxlvi: I've distributed 10 in the last week.
02:50:20 <shapr> I have my own colocated server.
02:50:39 <Jerub> shapr: the interface is pretty damn slick. I prefer it over most things.
02:50:44 <Jerub> I almost prefer it over mutt!
02:50:52 <dxlvi> no way
02:51:32 <dxlvi> i never hardly get any spam to gmail
02:51:55 <dxlvi> but they put many of the nonspam mails to the spam folder :-/
02:52:21 <earthy> I use gmail for spam filtering exclusively
02:52:26 <earthy> and it does a great job of it ;)
02:52:32 <dxlvi> heh yea
02:52:52 <dxlvi> but if i run my own mail server, most other servers reject the mail
02:52:53 <Jerub> I got 2 spams today through gmail ;)
02:53:04 <dxlvi> because i'm "not a known mail gateway"
02:53:14 <shapr> I get about zero spams with my setup.
02:53:31 <Jerub> I use divmod for my real email, gmail for mailing lists at the moment.
02:54:09 <Jerub> anyway.
02:55:37 <Jerub> shapr: how is (citeseer + wiki) / 2 going?
02:55:50 <shapr> slower than I hoped
02:56:19 <shapr> at this point I'm aiming for an alpha by friday
03:01:10 <Jerub> I'm slowly learning stuff about erlang.
03:03:21 <shapr> it's a neat language
03:03:44 <Jerub> I find myself thinking.
03:04:02 <Jerub> "ooh, I could use *that* to implement feature X from language Y"
03:04:06 <Jerub> its hard to break out of that reaction.
03:11:42 <basti_> :P
03:12:11 <Jerub> at least I don't have that reaction with haskell anymore.
03:12:15 <Jerub> I can think in haskell.
03:12:31 <basti_> as long as you don't think in Combinator Logics
03:13:21 <Jerub> not yet!
03:19:58 <basti_> i had to help my gf put her loose sheets into her folder. She needs help with that cos she has so many sheets and folders that when she takes one out, the others fall out too (theyre under tension). You would suppose a student of philosophy at some point in time understands the concept of "practical" and "easy"
03:22:45 <Lor> Does she study practical or theoretical philosophy?
03:24:26 <basti_> there is no such division in the german education system.
03:24:41 <basti_> she's a beginner still (2nd term). maybe that explains that :P
03:26:45 <Lor> Ah, hereabouts we say that the difference is that in practice, the practical philosopher won't find a job, whereas a theoretical philosopher cannot get employed even in theory. :)
03:27:00 <basti_> hehe
03:30:07 <ibid> the division is usually that practical philosophy includes ethics, aesthetics and such like, while theoretical philosophy includes ontology, theory of knowledge, philosophy of science, logic etc
03:30:38 <ibid> theoretical philosophers tend to favor the analytic school, practical philosophers shy away from it
03:33:25 <basti_> hmm i guess she's rather the practical side then.
03:36:55 * basti_ shys away from philosophy.
04:09:03 <musasabi> reading polymorphic values is ugly but seems to work ^_^
04:36:21 <basti_> wow the proof general people fixed the bug i found and sent me a patch :)
04:40:59 <basti_> is "Array" like uhm, quick?
04:41:12 <ibid> for access, yes
04:41:29 <ibid> for update, not in the sense of imperative arrarys
04:41:42 <basti_> is there something similar to these?
04:42:23 <ibid> you can get imperative arrays if you restrict yourself to the IO monad (ST monad might work too)
04:42:36 <ibid> for most uses, FiniteMap is good enough, though
04:42:55 <basti_> hmm
04:42:56 <ibid> that's a tree-based implementation of a dictionary
04:43:09 <basti_> how does this thing with the IO monad work?
04:43:32 <ibid> how as in how you use it or how as in how it works under the hood?
04:43:39 <basti_> how i do use it
04:43:46 <ibid> read the docs :)
04:43:50 <basti_> uhm
04:44:11 * basti_ does
04:44:20 <ibid> to explain them to you i'd have to read them and i don't have the time, sorry :)
04:44:24 <basti_> oh there.
04:44:30 <basti_> i didnt know such a thing exists ;)
04:44:34 <basti_> no i got it now
04:53:02 <shapr> yow
06:06:03 <shapr> mmm, desktop power: http://radio.weblogs.com/0105910/2004/08/30.html
06:20:55 * shapr rebounds
06:24:33 <maihem> I think if people start working on multiprocessor versions of mozilla, openoffice, and evolution, we could start to see thin clients in regular large offices. One of those 12 processor systems could provide processing power for at least 24 corporate desktops.
06:25:00 <maihem> If they are robust and cpu/drive/memory hotswappable, then they would be perfect for that.
06:26:21 <maihem> especially if the above mentioned apps could be written to duplicate their state on a couple of nodes and distribute their processing and UI, then the failure of one node will not significantly interrupt any users workflow.
06:27:47 <maihem> That would be ideal for most corporate offices, where if a users computer breaks, they must wait to share somebody elses - moving from desk to desk. If you have a couple of spare thin clients (since they can be made cheap), you'll always have staff working.
06:41:46 * shapr bounces
06:44:20 <shapr> maihem: an mnesia-style distributed app framework could allow for 'RAID peers' where if any one of them fails the app is still up and just mirrors more state
06:45:51 <shapr> that sort of framework would probably run on a corporate network of desktop machines as well as single boxes with bunches of CPUs
06:46:26 <shapr> now we just need to write that framework for Haskell and get rich selling reliable apps to corps :-)
06:46:56 <shapr> hiya edwinb 
06:47:05 <shapr> how's epigramming?
06:47:32 * shapr wonders if Yampa coding is reactigramming
06:47:53 <shapr> Cobol must be contragramming
06:48:22 <edwinb> afternoon
06:48:40 <edwinb> I might actually get to do some epigramming, or even some programming, soon...
06:48:43 <shapr> yay
06:49:12 <Lor> What's epigramming?
06:49:20 <maihem> shapr: there is a framework called "mnesia"?
06:49:22 <edwinb> It's about time I got around to bolting a compiler onto it, really...
06:49:24 * shapr points to #epigram :-)
06:49:26 <Lor> Looking what a computer does and writing it down?
06:49:35 <musasabi> shapr: I think I will have distributed queues in a few days.
06:49:55 <shapr> maihem: nah, mnesia is an erlang app that uses erlang's distributed framework
06:50:02 <shapr> musasabi: do you have a darcs repo up?
06:50:04 <edwinb> It's like programmingm only they're short and pithy, or something ;)
06:50:05 <Lor> This? http://www.dur.ac.uk/CARG/epigram/
06:50:11 <shapr> Lor: yup
06:50:20 <Lor> Ah, it's on the channel's topic too.
06:51:06 <musasabi> shapr: no, but I will make it available in a few days (don't like to host things home and haven't set up darcs anywhere else)
06:51:11 <shapr> I wonder if I have an epigram screenshot handy...
06:51:19 <shapr> musasabi: need a host?
06:52:59 <musasabi> shapr: that would take more time than it would be worth, later though...
06:53:06 <shapr> heh, ok
07:09:10 <phubuh> oh hey dudes
07:09:19 <shapr> hej phubuh
07:09:21 <shapr> ltns
07:09:22 <shapr> wassup?
07:09:23 <phubuh> hej shapr!
07:09:35 <phubuh> not much, school's started and all
07:09:55 <shapr> do you get to code at school?
07:10:01 <phubuh> nope
07:10:07 <shapr> suck, how long till college?
07:10:13 <phubuh> i would, had i chosen the math/computer specialization thingy
07:10:49 <phubuh> but it's just introductory c++ and java gunk :)
07:10:55 <shapr> yick
07:10:57 <phubuh> about three years
07:11:08 <shapr> sounds like forever :-)
07:11:13 <phubuh> yeah :(
07:11:23 <shapr> I guess you'll have to write your own fun code in the meantime.
07:11:29 <phubuh> yup
07:11:38 <shapr> have you looked for a part-time coding job?
07:11:50 <shapr> that would probably give you both real-world experience and actual cash.
07:12:02 <phubuh> yeah, that'd be nifty
07:12:27 <phubuh> but spare time seems niftier at the moment :)
07:12:32 <shapr> yah, I understand that.
07:12:50 <shapr> hey, do you read research papers you get from the web and make notes in the margins?
07:13:18 <Lor> No. If I make notes, I make them in some file somewhere.
07:13:29 <shapr> Lor: ah even better :-)
07:13:45 <phubuh> dito.  i don't have a printer :)
07:14:21 <shapr> this is the idea: http://www.scannedinavian.org/RandomWiki/AnnotationMockup
07:14:26 <phubuh> hey, i'm getting `ghc-6.2.1: unrecognised flags: -fno-prune-tydecls' when compiling greencard 3.01
07:14:44 <shapr> I'd like to hear any comments, thoughts, or suggestions
07:16:35 <Lor> shapr, firstly, you should probably crop the margins out from the paper itself.
07:16:41 <shapr> yah, I agree
07:16:54 <Lor> There's a driver for ghostscript that calculates the bounding box.
07:16:58 <shapr> hopefully I can persuade imagemagick to do that automatically, but at worst I can use the gimp
07:17:00 <shapr> ah, nifty
07:17:03 <shapr> that's useful info
07:17:57 <Lor> I don't think it's a good idea to use _both_ sides for margin notes. Takes too much space.
07:18:11 <Lor> Or, well, depends on how much screen space you assume the user to have.
07:18:12 <shapr> hm, you're the second person to say that
07:18:57 * phubuh is investigating writing a window manager with hsx11
07:19:00 <Lor> No top/bottom notes either. Just lay the pages on top of each other.
07:19:26 <shapr> phubuh: oh, that would be *spiffy*
07:20:26 <shapr> phubuh: I think you could find some other contributers if you started that sort of project
07:21:28 <shapr> Lor: you think three left-hand margin sections would be good enough?
07:21:44 <phubuh> i'm not sure they'd appreciate my window management :-) but it'd be really awesome to have a framework in a high level language, so one can build one's own window manager easily enough
07:22:24 <Lor> shapr, I don't think the location of the notes is so important.
07:22:32 <shapr> hm
07:22:37 <Lor> You could even have just a single list of notes for each page.
07:22:45 <shapr> that's true
07:23:06 <Lor> There's just no space for more exact placement.
07:23:51 <shapr> that's an excellent point.
07:24:13 <Lor> Well, you could of course use a teensy little font...
07:24:15 <ibid> shapr: have you looked at fenpdf?
07:24:20 <shapr> ibid: nah, what's that?
07:24:21 * shapr googles
07:24:37 <shapr> ah, fenfire
07:24:50 <phubuh> i want to experiment with the widget model most ui toolkits use, with the most important widget being a simple X11 window, and you'd build a windowing environment by putting them together, like an ion user might want to use a tiling widget, but with a floating-windows widget in one tile (for GIMPing or whatever)
07:25:25 <Lor> Doesn't ion already support something like that?
07:25:27 <cgibbard> phubuh: while you're looking into it -- Haskell bindings to the enlightenment foundation libraries would be really neat. :)
07:25:45 <ibid> shapr: http://www.nongnu.org/fenfire/fenpdf-shot.png (big)
07:25:48 <shapr> phubuh: have you seen the Ion authors suggestion along the same lines?
07:25:51 <phubuh> some other widgets i have in mind are vertical lists, where all but one window are rolled up, and you can flip around through the items; and a scrolled area widget
07:25:59 <phubuh> Lor: yeah, it supports floating workspaces
07:26:02 <phubuh> shapr: hm, no
07:26:21 <shapr> http://modeemi.fi/~tuomov/vis/
07:26:27 <shapr> interesting stuff
07:26:36 <shapr> he hangs out on #ion if you want to talk to him.
07:26:41 <phubuh> ooh
07:26:44 <phubuh> cool, thanks
07:27:48 <shapr> ibid: that's very cool
07:28:09 <shapr> is fenfire available on linux and win32?
07:28:37 * Lor cannot believe that that could be practical.
07:28:43 <ibid> shapr: at least linux, though it requires 3d hardware acceleration
07:28:50 <ibid> that being...?
07:28:56 <shapr> wikis only require a browser
07:28:59 <Lor> Fenfire.
07:29:06 <xkb> hi.. is this: data PSQ k p 
07:29:12 <xkb> a correct data definition?
07:29:20 <shapr> xkb: I don't think so
07:29:23 <ibid> Lor: you have to first go out there before you can see what's possible and practical :)
07:29:33 <Lor> xkb, it is, but it declares an empty datatype.
07:29:38 <Lor> (It's not Haskell 98, though)
07:29:39 <xkb> aha
07:29:50 <ibid> shapr: the fenfire people hang out in #fenfire @ IRCnet
07:29:57 <shapr> hm
07:29:58 <xkb> I got it out of a paper and what allready wondering what the were trying to do
07:30:05 <xkb> what=was
07:30:11 <xkb> the=they
07:30:16 <xkb> and I need a typing course :D
07:30:28 <Lor> It wasn't followed by "="? "data PSQ k p = ...."?
07:30:48 <shapr> ibid: I'll look into fenfire later, but for the moment a darcs-controlled wiki would be simpler.
07:30:53 <ibid> :)
07:31:06 <xkb> Lor, no
07:31:25 <xkb> other lines included constructors and insertion functions
07:31:34 <xkb> its a paper on Priority Search Queus
07:31:44 <xkb> Queues even
07:31:45 <xkb> sigh
07:32:35 <phubuh> is greencard 3.01 known to work with ghc-6.2.1?
07:32:43 <xkb> and PSQ k p is the datatype of the queue
07:33:00 <xkb> where k,p are key, priority
07:33:15 <Lor> Is this a source file? Or some documentation?
07:33:20 <shapr> phubuh: I think so... isn't that the latest version?
07:33:20 <xkb> a paper
07:33:43 <xkb> Ill try to find the source 
07:33:47 <phubuh> shapr: yeah, afaik
07:33:49 <shapr> phubuh: I know I got hsx11 to build with 6.2.1, so if you can't figure it out, I can see what I did later.
07:33:58 * shapr is sort of working right now
07:34:07 <ibid> they probably mean that there is a data type PSQ k p but its representation is irrelevant to the discussion at hand
07:34:15 <Lor> xkb, in that case, it probably just means that the definition of the datatype is to be abstract.
07:34:48 <ibid> which is basically the same thing as what Lor said :)
07:41:40 <earthy> hm. looks like I won't be entering into the Succ Zero IOHCC
07:42:09 <shapr> earthy: please please!
07:42:21 <xkb> aha >††data†PSQ†k†p††††††††††††††††††=††Void†|†Winner†(Binding†k†p)†(LTree†k†p)†k
07:42:40 <xkb> that's better
07:42:40 <shapr> We've got three submissions so far I think. They're all crazy and nifty, but I still wish we had more.
07:42:43 <earthy> hm. I just thought up of something. let's see if I can squeeze that into a oneliner. :P
07:42:53 <shapr> thanks :-)
07:43:13 <earthy> -of
07:44:15 <shapr> Cale: where's desrt these days?
07:44:53 <shapr> Some part of me desperately wants to believe that XML-RPC is some kind of elaborate joke,  like a cross between Discordianism and IP Over Avian Carriers -- Ex-Cyber on #plan9
07:45:01 <cgibbard> He's around occasionally. Since he's been working from home I think his sleep schedule has been all backwards though.
07:45:28 <cgibbard> He was talking on #math last night
07:51:07 <shapr> ah, ok
08:01:37 <shapr> hej Pinnen 
08:02:41 <xkb> are views incorporated into hakell yet?
08:02:48 <xkb> http://www.haskell.org/development/views.html
08:03:32 <musasabi> no, they are unlikely to be included
08:15:59 <bringert> shapr: I have felt the same about XML-RPC
08:24:37 * shapr grins
08:24:39 <shapr> hej bringert!
08:24:45 <shapr> how's code?
08:24:57 <bringert> code's still java
08:25:01 <Philippa> shapr: you getting my PMs?
08:25:19 <shapr> wasn't looking in the right buffer...
09:05:32 <Pinnen> shapr: tjena :-)
09:07:52 <shapr> Isn't Anders Gavare aka debug?
09:08:53 <shapr> yes, that's him.
09:09:23 <polli> shapr: do you know Anders Gavare?
09:09:24 <shapr> Neat, the C version of his raytracer was one of the winners of the IOCCC.
09:09:46 <shapr> polli: he's been here, he showed off a Haskell version of his raytracer.
09:10:03 <polli> oh, I've read some courses with him
09:10:09 <shapr> It was pretty hard to read.
09:10:18 * shapr still has a copy around somewhere.
09:10:28 <shapr> he's also the guy who did the forward raytracer.
09:10:46 <shapr> speaking of which, I've been meaning to send him email asking about a Cg port of that.
09:11:32 <shapr> polli: hi! how are ya?
09:12:55 <polli> shapr: I'm fine, how about you?
09:13:05 <shapr> bouncy!
09:13:11 <cgibbard> I hate how so many sites just copy wikipedia's content verbatim.
09:13:12 <goron> Does anyone knows what Tmu means in the context of category theory? Œº
09:14:01 <cgibbard> T mu would refer to the composition of the functor T and the natural transformation mu
09:14:09 <cgibbard> (if you're reading about monads)
09:14:25 <cgibbard> or T applied to mu
09:15:00 <goron> cgibbard: But how can natural transformations be composed with functors? Their "types" don't match.
09:16:27 <cgibbard> They don't?
09:18:22 <goron> cgibbard: There are also some websites that explicity mention that it's not composition. But too bad they don't tell what it is.
09:18:38 <shapr> hiya vidvandre, how's code?
09:19:16 <basti_> ERROR "test.lhs" - Module "IOArray" not previously loaded
09:19:19 <basti_> -?-
09:19:59 <goron> cgibbard: Do you have some reference that explicitly mentions that it is composition? 
09:20:33 <shapr> basti_: do you import IOArray?
09:21:12 <basti_> yes
09:22:46 <cgibbard> It might help to know that T mu : T^3 (C) -> T^2 (C)
09:23:45 <cgibbard> and similarly for mu T
09:24:18 <vidvandre> hi shapr, haven't had time to code anything since last time, and I'm still reading "Yet Another Haskell Tutorial" :)
09:24:29 <shapr> vidvandre: ok, if you have any questions feel free to ask.
09:24:33 <vidvandre> ok :)
09:24:35 <cgibbard> mu.T is really mu_T(C), and T.mu is really T mu_C
09:24:46 <cgibbard> T.mu_C
09:24:59 <cgibbard> no, T(mu_C)
09:25:29 * basti_ .o∞ ( ? )
09:30:33 <cgibbard> I'm fairly sure that mu . (mu . T) = mu . (T . mu) basically just says that  join . (join . map (map f)) = join . (map f . join)
09:31:57 <basti_> it works with hugs :l IOArray
09:32:03 * basti_ is now completely confused
09:33:43 <pesco> shapr: Do you have webserver statistics for snowblind? I'm interested in how many people have already looked at my website.
09:33:52 <cgibbard> it seems to me that "composition" in both the cases T . mu and mu . T is just application of one to the other.
09:35:39 <shapr> pesco: I do, I can build awstats later today.
09:35:48 <pesco> Coo.
09:39:22 <ustenzel> I've got a problem with too much laziness.  I'm parsing a file into a FiniteMap.
09:39:48 <ustenzel> Instead of building the map, a gargantuan thunk is built, and I get heap or stack overflows.
09:39:56 <ustenzel> Any hints on how to avoid that?
09:40:03 <basti_> aaah i got it :)
09:40:13 <basti_> i should import Hugs.IOArray instead of IOArray.
09:40:20 <basti_> strange error, though.
09:40:29 <shapr> ustenzel: how do you read the file?
09:40:56 <ustenzel> readFile and then something built out of readP
09:41:30 <ustenzel> the topmost parser gets a FiniteMap as argument and returns that map with some entries added
09:41:53 <shapr> have you tried strictifying that?
09:43:03 <ustenzel> yeah, I'm out of ideas where to add even more seqs or $!'s
09:43:27 <ustenzel> even if that works sometimes, it can blow up any time
09:43:32 <shapr> how big is the source?
09:43:51 <ustenzel> some dozen lines, but i don't have it handy.
09:43:56 <shapr> hm
09:44:04 <ustenzel> no access to irc at work -- firewalls suck.
09:44:12 <shapr> :-/
09:44:31 <shapr> can you strictify the FM building itself?
09:44:44 <ustenzel> i got it working for a brief moment.  it was quick, used low memory, etc.
09:45:17 <ustenzel> then i tried reading two files, passing the map from the first parser to the second and it went out of control again.
09:45:50 <ustenzel> stupid things like "guard (x==x)" in the parser also help
09:45:56 <shapr> I hacked up a bayesian spam filter that read from a zillion files, first I had to strictify file reading as soon as I had a file list
09:46:16 <ustenzel> but this is annoying... putting seq's everywhere, even in code i want to reuse.
09:46:37 <shapr> yah I understand, I usually throw in seqs until I find the one place where they're really needed.
09:46:40 <ustenzel> not long before i write strict_fold, strict_map, StrictFiniteMap, StrictSet...
09:46:43 <shapr> usually it's just one
09:47:06 <ustenzel> any hints where to look for that one place?
09:47:13 <ustenzel> or even *how* to look for it?
09:47:14 <shapr> I ended up needing only a single $! to bring my ram usage from 1.5GB+ down to 30mb
09:47:50 <shapr> if you can get back to the brief moment where it worked, try profiling that
09:47:56 <shapr> that should tell you something useful.
09:48:10 <shapr> also, I tend to build lazy pipelines, that almost always works.
09:48:13 <ustenzel> that's easy, but it doenst tell anything :)
09:48:43 <ustenzel> this is good: readFile "blah" >>= parseIt emptyFM
09:48:44 <shapr> well, right associate any ++ and related ops, and left associate monadic ops...
09:49:01 <shapr> that works ?
09:49:16 <ustenzel> this is bad : readFile "foo" >>= parseIt emptyFM >>= \m -> readFile "bar" >>= parseIt m
09:49:41 <ustenzel> heck, it's *still* bad if i write "parseIt $! m" at the end!
09:49:58 <shapr> what about "readFile $! "foo" >>= parseIt emptyFM >>= \m -> readFile $! "bar" >>= parseIt m" ?
09:50:38 <ustenzel> huh?  that evaluates two string literals before use... hardly breathtaking :)
09:51:04 <shapr> saved me ~1.4GB of ram.
09:51:43 <shapr> anyway, worth trying
09:51:54 <ustenzel> wait a minute... left-associate monadic ops?  they are right associative by default?
09:52:38 <shapr> I don't think so.
09:52:53 <Lor> >> is right-associative
09:53:01 <ustenzel> thought so.
09:53:11 * shapr shrugs
09:53:36 <goron> cgibbard: T mu:T^3(c) -> T^2 (c), could you explain the parts of this expression? What's T mu (a name? (it also could have been called Foo, for example), T^3(c) is T(T(T c)) and the same holds for T^2?
09:53:47 <Marvin--> Lor: it is?
09:53:58 <Marvin--> infixl 1  >>, >>=
09:54:02 <Marvin--> from hugs' Prelude
09:54:10 <Lor> Oops.
09:54:11 <Lor> Sorry.
09:54:18 <Lor> Well, it bloody well ought to be, anyway. :)
09:54:49 <shapr> there's a really good anti-space-leak reason for monadic ops to be left, and other stuff right, but I forget what it is.
09:55:30 <Lor> Ah, makes sense.
09:55:43 <Lor> All right then. I don't know anything. You'd do well to ignore me.
09:55:47 <shapr> Laziness is really elegant and useful, but it sure bites me in the butt sometimes.
09:56:11 <shapr> Lor: you figured out the reason?
09:56:18 <Marvin--> well it sure makes sense for things like ++ to be right associative, just look at the implementation
09:56:23 <Riastradh> Like when you're just lazing about on a couch, and your butt gets numb from all the sitting, and then you shift it slightly and the nerves jump and make sharp pains in your butt?
09:56:31 <shapr> Riastradh: zigactly!
09:56:38 <ustenzel> I like laziness... it's just that it seems impossible to read static data into memory without blowing the heap.
09:57:18 <cgibbard> goron: yeah, T^3 is T . T . T
09:57:21 <shapr> if you use a lazy pipeline, you can often get away with never having to read more data into memory than you're really using right then.
09:57:48 <shapr> but making sure all your code *stays* a lazy pipeline is often difficult, and sometimes impossible.
09:57:49 <goron> cgibbard: And "T mu" is just a name, like Foo?
09:57:54 <cgibbard> mu : T^2 -> T
09:58:10 <Marvin--> unfortunately, bad associativeness of monadic operations can get hidden in e.g. badly written parsers
09:58:11 <cgibbard> T : (A -> B) -> (T A -> T B)
09:58:31 <cgibbard> so T mu : (T T^2 -> T T)
09:58:31 <Marvin--> but ReadP uses CPS so it shouldn't really be a problem, or so I thought
09:58:34 <ustenzel> i definitely need a map... there goes the pipeline idea.
09:59:18 <shapr> if you can strictify the map building, you can still get away with only keeping part of the input file around at any given time.
09:59:28 <ustenzel> i don't think ReadP is at fault.  it look like a FiniteMap that is too lazy.
10:00:00 <shapr> spamFM = listToFM $! (read spamFMfile :: [(String,Float)])
10:00:17 <ustenzel> and that works?
10:00:17 * shapr had fun writing that code
10:00:31 <ustenzel> are you sure, the map is really built?
10:00:49 <cgibbard> A natural transformation is basically a mapping from one functor on a category to another, which preserves arrows. 
10:00:54 <Marvin--> remember that $! and seq are not deep
10:01:03 <shapr> there is DeepSeq that might help
10:01:35 <Marvin--> they just evaluate far enough to get the topmost constructor.. what's it called, weak head normal form?
10:01:55 <ustenzel> Marvin--: exactly
10:01:55 <shapr> "spamFM = listToFM $! (read spamFMfile :: [(String,Float)])" and "spamFMfile <- readFile $! spamfmdump" were the real killers in my code.
10:02:04 <shapr> yah whnf
10:02:07 <cgibbard> http://en.wikipedia.org/wiki/Natural_transformation
10:02:36 <shapr> An unnatural transformation is how they get pop singers like Britney Spears.
10:02:59 <ustenzel> hm, DeepSeq'ing the FiniteMap all the time doesn't sound very elegant...
10:03:13 <shapr> ustenzel: if I could see your code, I might be able to see the laziness pattern problem.
10:03:29 <shapr> Or you could look at my ugly spambayes hack if you want.
10:04:23 <ustenzel> I'll see if i can isolate the problem and put the code somewhere.  but that will have to wait till tomorrow.
10:04:54 <shapr> ok
10:05:13 <shapr> I remember persuading my boss at my last job that IRC was commercially valuable to them.
10:05:58 <ustenzel> shapr: lemme see the spambayes hack.  ugly code has its value, too.
10:06:05 <cgibbard> goron: I think what you're specifically looking for is in the section "Operations with natural transformations"
10:06:22 <ustenzel> oh no, this boss is too bloated to be persuaded of anything.
10:06:30 <shapr> ustenzel: too bad :-(
10:07:13 <ustenzel> DaimlerChrysler --- by the time my suggestion has reached the right person I'm no longer employed there :)
10:07:28 <shapr> oh
10:08:20 <shapr> I didn't know they used Haskell.
10:08:24 <shapr> Do they know they use Haskell?
10:08:30 <cgibbard> If eta : F -> G is a natural transformation between functors C -> D, and H : D -> E is another functor, the natural transformation H eta : HF -> HG is defined by (H eta)_X = H(eta_X)
10:08:38 <shapr> ustenzel: http://thunderbird.scannedinavian.com/~shae/spambayes/
10:08:51 <ustenzel> shapr: They are not using Haskell.  I am. :)
10:08:55 <shapr> heh, spiffy.
10:09:09 <shapr> oh the name is the best part of that code
10:09:24 <cgibbard> and if K : B -> C is another functor, then the natural transformation eta K : FK -> GK is defined by (eta K)_X = eta_(K(X))
10:09:30 <shapr> Paskalle is finnish for 'to remove the shit from' or 'to take a dump'
10:09:39 <shapr> I figured it was a good name for a spam remover.
10:09:46 <ustenzel> actually this is only a research institute of theirs, I'm writing my masters thesis there and I have pretty much free reign in deciding what to use to get the job done.
10:09:55 <shapr> except irc, right?
10:10:12 <ustenzel> reconfiguring the network of course is out of the question.
10:10:21 <cgibbard> goron: does that help?
10:10:28 <shapr> you could use freenet6 or an ssh tunnel.
10:10:34 <shapr> unless they'd bust you for that.
10:10:48 <ustenzel> everything else here is in C.  not even ++, pure C.
10:10:52 <shapr> yow
10:11:01 <shapr> that explains your FFI knowledge.
10:11:15 <ustenzel> did I mention the firewall?  so much for ssh or freenet.
10:11:25 <shapr> you have no way out at all?
10:11:32 <shapr> why have a network?
10:11:36 <goron> cgibbard: FK(x) is F(K x) again?
10:11:38 <ustenzel> nope.  port 80 it is, nothing else
10:12:06 <shapr> do they limit you to only http requests on port 80?
10:12:14 <shapr> I think I've seen a http wrapper for ssh somewher.
10:12:48 <ustenzel> Oh yeah, ssh-over-http somewhere to start an irc client there!
10:12:57 <goron> ustenzel: There are applets, you know?
10:12:59 <Philippa> or use a CGI IRC clients
10:12:59 * shapr grins
10:13:01 <Philippa> *client
10:13:06 <ustenzel> thank you, but I think I can manage without.
10:13:14 <cgibbard> goron: yes
10:13:42 <cgibbard> it's just the composition
10:13:42 <ustenzel> goron: certainly.  but even the applet cannot use anything but http.
10:14:35 <goron> ustenzel: Ok, I thought you just wanted to have IRC access on your work via http. I wasn't paying that much attention to your discussion.
10:15:07 <ustenzel> there's always a point where the "solution" gets worse than the problem... fighting "IT Services" is well beyond that point :-)
10:16:01 <ustenzel> hm, a cgi irc client might just be worth the trouble.
10:17:39 <goron> cgibbard: What's the use of the underline token in eta_(K(X))?
10:18:13 <cgibbard> goron: subscript
10:18:38 <cgibbard> the intention is eta subscripted with K(X)
10:19:11 <goron> cgibbard: Ok
10:20:01 <cgibbard> eta : F -> G, where F and G are functors C -> D, assigns to every object X of C a morphism eta_X : F(X) -> G(X) in D
10:22:05 <cgibbard> You can see a functor applied to a category as a sort of sketch of the category from a particular angle. It might not have all the features of the original category, and some objects might get identified with each other, or lost, but the shapes that the arrows make are carried across.
10:22:29 <cgibbard> A natural transformation takes one such sketch and converts it into another.
10:22:59 <goron> cgibbard: Functors are clear, natural transformations are too, but the syntax wasn't clear. 
10:23:06 <cgibbard> oh, okay
10:24:55 <cgibbard> well, objects don't get lost, I suppose - that just comes from them being identified with another object :)
10:28:43 <goron> cgibbard: In "Operations with natural transformations", what's the H in H\eta?
10:29:16 <goron> cgibbard: According to the example below it, it should be a functor, but there's no such one.
10:32:38 <goron> cgibbard: I checked the "types" again of your T m example and they are correct. 
10:43:47 <goron> cgibbard: I didn't look good, it's correct. 
10:43:53 <goron> cgibbard: Thanks
11:08:03 <cgibbard> goron: no problem
11:11:33 <basti_> im getting IORefs now.
11:11:41 <basti_> :)
11:28:07 * shapr throws lambdas
11:28:12 <musasabi> morning
11:30:15 <edwinb> you'll put someones eye out with that!
11:31:22 <basti_> OW
11:32:20 <basti_> is it possible to do a "null pointer" in IORefs?
11:32:24 * shapr tries to fix basti_ by putting him into head normal form
11:32:45 <Philippa> basti_: Nope. How would you?
11:32:46 * basti_ head is normal now
11:32:54 <basti_> Philippa i dont know, thats why i'm asking.
11:33:06 <basti_> is a "ring list" possible?
11:33:20 <Philippa> as in ones = 1:ones?
11:33:23 <basti_> i thought of something like, "IORef (Maybe Char)"
11:33:23 <Philippa> yeah
11:33:41 <Philippa> oh, you just want some way of saying "it's not here"? Yeah, a ref to Maybe is prolly a good call
11:33:51 <basti_> k
11:35:12 * Philippa wonders if you can make an IORef undefined
11:35:32 <Philippa> that'd be pretty much a null pointer, I guess
11:35:40 <basti_> i thought it could maybe go "error" when you try to read it
11:35:44 <basti_> something like that
11:35:46 <Philippa> (ref to undefined, rather)
11:37:28 * basti_ always has to think of needles, thread and scissors when dealing with monads
11:42:36 <musasabi> well you can make it so...
11:43:29 <musasabi> readRef ref = maybe (fail "null-pointer") id (readIORef ref)
11:44:04 <goron> basti_: @index cycle
11:44:05 <basti_> uhm
11:44:16 <goron> @index cycle
11:44:16 <lambdabot> Data.List,GHC.List,Prelude,List
11:44:42 <basti_> okay.
11:45:10 <basti_> wh00. rollercoaster.
11:45:41 <basti_> missed that one :P
12:04:07 <cptchaos> does parsec has something like an "either" parser?
12:05:13 <goron> <|>
12:05:55 <goron> If I understand you correctly... But seeing the triviality I am probably not.
12:06:28 <goron> cptchaos: Or maybe "try".
12:06:32 <cptchaos> goron: <|> only works with parsers that return the same type, I want to have an real either, i.e. different types
12:07:09 <Philippa> I'd imagine you could build it if it doesn't have it
12:07:10 <Philippa> gimme a mo
12:07:22 <goron> cptchaos: Well, you could ofcourse use your own type constructor, but that's someting you probably already know.
12:07:49 <cptchaos> Philippa: yes I could build one, but I thougt I ask before
12:08:59 <Philippa> OK, doesn't look like there's a proper either
12:09:20 <cptchaos> OK, thanks, anyway
12:16:58 <shapr> IOHCC has ~27 hours left...
12:18:03 <Philippa> you're not suggesting I cut the comments out of what we've been doing, write a Real Program (tm) and submit? :-)
12:18:07 * shapr grins
12:18:27 <shapr> might get you 'most creative use of category theory'
12:19:17 <shapr> dang, open-exchange.org is really cool, why did they have to write it in JAVA?
12:19:21 <shapr> heck I'd be happier with C++
12:19:32 <shapr> or C
12:19:34 <shapr> or Tcl
12:19:40 <basti_> no
12:19:42 <basti_> not with tcl.
12:19:51 <shapr> at least Tcl is open source.
12:20:05 <basti_> just say no to tcl.
12:20:08 <shapr> heh
12:20:09 <basti_> :P
12:20:10 <shapr> ok, if you say so.
12:20:30 <shapr> jag hatar Java!
12:20:46 <eixei> I think that applies to most people...
12:20:53 <eixei> at least nearly everyone I know
12:21:20 * eixei has yet to understand why so many universities use it :-/
12:21:29 <shapr> Java was written to for managers, not programmers.
12:21:43 <shapr> Too bad managers don't have to actually use Java. That'd change their minds.
12:21:47 <arauko> thats it
12:22:19 <Philippa> eixei: industry wants it, and many of them would only be using C++ otherwise
12:22:42 <eixei> :-/
12:23:19 * shapr sighs
12:23:46 <esap> Java works pretty well if you're constrained to building platforms. [Now, why would you build a platform, if you didn't want to build applications as well; however, Java is not really suitable for writing applications].
12:24:57 <shapr> hm, there's got to be some way to do an advertising anti-campaign...
12:25:33 <ustenzel> shapr: are you nuts?  just imagine the managers you wean off java might turn to haskell instead!
12:25:41 <shapr> let's see, where could you cheaply advertise to reach open source programmers...
12:26:05 <Smerdyakov> Word of mouth
12:26:43 <shapr> Part of the problem is that non-technical people make technical decisions.
12:27:06 <Smerdyakov> That's only a problem if you associate with organizations of that type.
12:27:07 <shapr> One place I worked, the salesman handed me both a task and a deadline.
12:27:39 <shapr> There are very few organizations where technical people get to make technical decisions.
12:27:53 <Smerdyakov> But they produce most of the good software, so that's OK.
12:28:17 <esap> It's actually ok to hand you both a task and a deadline. However, then he can't give any quality requirements :-)
12:28:23 <shapr> esap: heh, fair enough
12:29:23 <shapr> I like languages are written for programmers.
12:30:24 * esap is reminded of the old saying: "fast, cheap, good; pick two".
12:32:23 <shapr> right
12:34:02 <Smerdyakov> Naturally, that saying does not hold in the face of smart planning.
12:34:28 <Philippa> which costs. There goes the cheap
12:34:42 <shapr> oh hey, I wanted to clarify what I said about design and implementation ordering.
12:35:03 <shapr> Ike said "Plans are useless but planning is essential."
12:35:15 <musasabi> There is no ipv6 support in network? :-(
12:35:20 <shapr> I think that applies to software as well.
12:35:22 <shapr> musasabi: not yet
12:35:29 <esap> shapr: That's a good principle.
12:35:36 <musasabi> shapr: anyone working on it?
12:35:37 <shapr> musasabi: should be pretty easy to add though, I've already investigated.
12:35:38 <Smerdyakov> Philippa, the cost is amortized, making it cheap per time unit.
12:36:19 <Philippa> only if the planning's tractable, which frequently it isn't. Developing software is what but a succession of specifications?
12:36:25 <Philippa> 'lo cm
12:36:37 <shapr> In concrete terms, I think Ike applied to software means "hack up a throwaway prototype of anything you've never done before" and I think that happens before you start writing the software proper.
12:36:49 <musasabi> shapr: if you work on it, please think about the following things: 1) make SockAddr derive both Read and Show 2) create a connect :: SockAddr -> Sock function
12:37:55 <musasabi> both can be easily done today but having them in the library would make code less fragile to new protocolls.
12:37:57 <esap> smerdyakov: cheap per time unit is not cheap.
12:38:15 <Smerdyakov> Philippa, you seem to be thinking in "must" terms, while I'm thinking in "may" terms. Planning is likely to pay off in a large proportion of the situations you encounter.
12:38:36 <Philippa> but it's unlikely to pay off to the extent of getting you fast, good *and* cheap all together
12:39:00 <Smerdyakov> I think writing Haskell compilers, for example, has this property when compared to a default of using C.
12:40:07 <Philippa> it's a big improvement, certainly. But writing a good compiler quickly is not gonna be cheap regardless - complexities (eg optimisation) will still get you
12:40:22 <Smerdyakov> It's _extremely_ cheap per user of the compiler.
12:41:08 <Philippa> Unlikely unless you're shipping a lot of copies. And that doesn't mean the cost of production is irrelevant anyway
12:41:31 <Smerdyakov> If everyone in this channel used a certain Haskell compiler, that alone would make its development cheap per person.
12:41:32 * shapr wonders if open-xchange works with gjc
12:41:46 <Philippa> Well over a grand is not cheap IMO
12:41:59 <Smerdyakov> Ah, then you're in starving student mode. :P
12:42:23 <Philippa> or startup mode, or...
12:42:56 <Philippa> well over a grand isn't cheap by the vast majority of individuals' standards
12:42:57 <shapr> hej psi, hur l√§get?
12:43:20 <psi> shapr: bara fint :) sj√§lv?
12:43:32 <Smerdyakov> There are enough Haskell users that the amortized cost of ghc should come out to below $1k.
12:43:38 <shapr> bara bra
12:43:51 * psi hade sin f√∂rsta lektion i haskell idag :)
12:43:54 <Philippa> you mean the amortised cost per user? Don't get me wrong, but I wouldn't pay £100
12:43:59 <shapr> psi: h√§ftigt!
12:44:05 <Smerdyakov> Cost per user, yes.
12:44:28 <Philippa> and even £100 isn't cheap. That's over a month's food, that is.
12:44:28 <psi> shapr: jo, fast det var mest information om kursen osv, men det blir nog bra
12:44:41 <Smerdyakov> It's cheap for a one-time cost.
12:45:01 <Philippa> for your value of cheap, maybe. Not for mine
12:45:14 <Smerdyakov> It's cheap for the people who are doing the work. :P
12:45:34 <Philippa> incidentally, what's your figure for the amortised cost of maintaining and continuing to develop GHC? You know, the bit that's ongoing?
12:45:51 <Smerdyakov> I don't know.
12:45:58 <Smerdyakov> Shouldn't be more than one grad student's stipend, though.
12:46:08 <Marvin--> psi, shapr: #haskell.se
12:46:32 <shapr> Marvin--: right, good point
12:46:33 <Philippa> I'd imagine it would. Needs more concentrated expertise than that
12:46:42 <Philippa> do we count in the costs of the research that feeds Haskell development?
12:46:58 <Smerdyakov> Grad students end up being the leading experts in their thesis subjects.
12:47:17 <Smerdyakov> Regardless of what you think, grad students do all the work. :P
12:47:24 <Philippa> show me somebody with a thesis in "writing the best possible haskell compiler"...
12:47:46 <Philippa> there is more than one PhD's expertise concentrated in GHC
12:47:46 <Smerdyakov> I'm sure Simon P-J has had a student whose thesis would be close to that.
12:48:05 <Smerdyakov> It only takes one full-time PhD student to _maintain_, though.
12:48:30 <Philippa> hence the magic works "continuing to develop"
12:48:31 <Philippa> *words
12:49:02 <Philippa> furthermore, I'll contest that if GHC is cheap, it isn't good. It's certainly not got the level of development behind it that a modern C++ compiler has
12:49:22 <Philippa> if you disagree with that, then it's /not/ been fast
12:49:45 <Smerdyakov> Even the most carefully engineering compiler today is cheap per user, because compiler users are relatively affluent.
12:49:53 <musasabi> /c/c
12:50:18 * Philippa rolls her eyes
12:50:29 <Smerdyakov> Philippa, you have a problem with that statement?
12:50:46 <Philippa> as somebody who couldn't afford to buy a compiler if she wanted to, yes
12:50:47 <shapr> Smerdyakov: start a software company, get rich.
12:51:10 <Smerdyakov> Philippa, and I don't think you produce much widely used software. No contradiction found.
12:51:37 <Smerdyakov> shapr, why did you say that?
12:51:48 <shapr> because if you're right, you'll get rich
12:51:53 <shapr> if you're wrong, you'll lose money.
12:51:56 * shapr shrugs
12:52:27 <Smerdyakov> shapr, why do you assume my advice is meant to be applied only to intra-capitalist-company situations?
12:52:30 <Philippa> Smerdyakov: I am still a compiler user
12:52:36 * shapr laughs
12:52:41 <Smerdyakov> Philippa, but not one who matters to many other people.
12:52:47 <Philippa> well fuck you too
12:53:41 <mattam> :)
12:53:44 * shapr grins
12:53:45 <Smerdyakov> You can go on acting like some kind of transcendant morality governs this case, but I'll stick with economics.
12:54:06 <Philippa> I'm not acting as though there's some morality involved
12:54:51 <shapr> Philippa: hey, do you make notes in the margins of research papers?
12:55:15 <Philippa> nope, I tend to read them on screen so don't have the facility
12:55:30 <shapr> I'm working on a distributed margin notes wiki and I'm looking for ideas and improvements.
12:55:31 <Philippa> I suspect making notes on library copies would make me unpopular
12:55:41 <Philippa> yeah, I took a look earlier, didn't think of anything
12:55:48 <shapr> ok, thanks for looking.
12:56:09 <shapr> I thought up a cheesy name last night while trying to sleep... "Fermat's Last Margin"
12:56:20 * Marvin-- rolls his eyes
12:56:25 <Philippa> Smerdyakov: your idea of cheap is not everybody else's idea of cheap, and economics doesn't judge cheap at all
12:56:27 * shapr snickers
12:56:32 <Philippa> that's... bad
12:56:48 <Smerdyakov> Philippa, my idea of cheap is in line with that of the vast majority of producers of software.
12:56:52 <cptchaos> i still don't get the point of the discussion
12:57:05 <kuz> Such as?
12:57:11 <Smerdyakov> cptchaos, essentially, we seem to be discussing what makes research worthwhile.
12:57:16 <Smerdyakov> cptchaos, economically
12:57:19 <Philippa> Smerdyakov: Which vast majority? A hell of a lot gets sold each week for $50 or less...
12:57:43 <Smerdyakov> Philippa, well, the primary players here have multi-million dollar budgets for things like this.
12:58:04 <Smerdyakov> kuz, was "such as?" addressed to me?
12:58:04 <Philippa> no kidding, I probably know the game industry better than you do
12:58:08 <kuz> Yes.
12:58:19 <Smerdyakov> kuz, can you rephrase the question? I didn't understand.
12:58:19 <shapr> I dunno, I think this started with 'Java is written for managers' and I said I'd like to have more languages written for programmers.
12:58:26 <kuz> I'm curious who we're speaking of.
12:58:46 <Smerdyakov> kuz, well, I think the class I belong to ATM, CS PhD students, is included.
12:58:48 <kuz> Who are the "vast majority of producers of software?"
12:59:01 <Smerdyakov> kuz, then we have software engineers in industry.
12:59:09 <Philippa> most of the IT industry doesn't think CD PhD students count, FWIW
12:59:10 <kuz> No, I mean specifically.
12:59:12 <Smerdyakov> kuz, and their generally mega-rich management.
12:59:24 <Smerdyakov> kuz, now I'm completely lost.
12:59:40 <Smerdyakov> Philippa, ah, then they've accidentally left their history books in the other yacht.
12:59:57 <Philippa> yep. That's what industry's for. Your point?
13:00:13 <Smerdyakov> I'm talking about reality, not what's in the heads of misinformed persons.
13:00:19 <Philippa> most of the software industry isn't rich enough for yachts, btw
13:00:59 <Smerdyakov> kuz, what would it mean for us to be talking about someone specifically? You are asking me to name people who would sign a petition offering to pay a certain amount of finance research, or what?
13:01:00 <cptchaos> Smerdyakov: are you sure, that you _know_ reality?
13:01:07 <Philippa> Smerdyakov: maybe you're misinformed in deciding PhD students count but I (currently an undergrad) don't?
13:01:24 <basti_> wow. My IORef DoubleLinkedList Mechanism now can do append.
13:01:28 <Smerdyakov> Philippa, no, there's a clear productivity difference.
13:01:29 <shapr> basti_: cool
13:01:39 <Philippa> Smerdyakov: you have no idea what my productivity is or isn't
13:01:39 <kuz> I'm curious who it is that "produces most software."
13:01:41 <basti_> :)
13:02:10 <Smerdyakov> Philippa, do you claim to produce widely-used software?
13:02:25 <Philippa> Nope. Nor do most PhD students
13:03:05 <Smerdyakov> It gets tricky, since you have ideas that end up in widely-used commercial software, with very little changed.
13:03:05 <basti_> now i have to do it easier
13:03:22 <esap> Productivity is actually why most companies don't do research. You can't be productive in the short term and also do research.
13:03:51 <Philippa> Smerdyakov: funny that, I imagine that at least once I've had some level of influence on some game's development somewhere too
13:03:54 <kuz> A lot of companies don't do things that necessarily requires considerable in-house research in CS.
13:04:00 <shapr> I try to do both research and production.
13:04:15 <musasabi> Seems it is impossible to serialize PortNumbers :-(
13:04:18 <esap> kuz: That's because they can't. No companies can do that.
13:04:20 <Philippa> I could be accused of being an obsessive researcher into production methods :-)
13:04:25 <Smerdyakov> Philippa, not the kind of extreme impact research has. Not ALL research, but the research that really succeeds is _critical_.
13:04:42 <musasabi> the stupid type does not implement Read or export any constructors :-(
13:04:43 <shapr> I demonstrate my belief in my own software methodology by using it in my self-owned software business.
13:04:50 <shapr> musasabi: that sucks :-(
13:04:51 <Smerdyakov> kuz, you could look at a self-selected community like Debian developers, for example.
13:05:06 <Philippa> Smerdyakov: You're assuming that I'm not doing any research that might be of that nature
13:05:07 <Smerdyakov> kuz, I think the idea of "cheap" averaged through that community is quite high by normal standards.
13:05:50 <ustenzel> musabi: fromIntegral
13:05:55 <Smerdyakov> Philippa, yes. Do you claim to be?
13:06:21 <shapr> I say she is.
13:06:43 * Philippa shrugs - maybe, thne
13:06:44 <Philippa> *then
13:06:53 <Smerdyakov> "Maybe" is a bad sign. ;)
13:06:54 <Philippa> into something to correct my typing at this rate though
13:07:12 <musasabi> ustenzel: thanks
13:07:19 <Smerdyakov> If you were doing something in this category, you would probably have a funding source with a high enough notion of "cheap" that you wouldn't have complained about the one I presented earlier.
13:07:35 <Philippa> Yes, because undergrads get funding like that
13:07:44 <Philippa> yes, because undergrads never start off projects of their own
13:07:55 <Smerdyakov> I got funding like that as an undergrad....
13:08:00 <Philippa> then you're lucky
13:08:04 <Philippa> funding like that isn't available here
13:08:21 <Philippa> I'm living on benefits
13:08:25 <mattam> where are you from Philippa ?
13:08:29 <Philippa> the UK
13:08:35 <Smerdyakov> Look, the situation is such that it's unlikely that you'll have enough time to devote to serious research progress if you don't have income associated with that progress.
13:08:54 * shapr sighs
13:09:19 <Philippa> or maybe I could in return for a somewhat crappy standard of living, which is the current state of play
13:09:31 <Smerdyakov> So in case anyone's gotten lost, the relevance of this is that the people who benefit most from existence of better compilers will tend to have money that they could "invest" in an even share of the compiler's development (in some pretend economy) and come out ahead.
13:09:50 <Philippa> which is relevant to the cheap/good/fast thing how?
13:10:08 <Smerdyakov> When you plan ahead with research, you can get a cheap, good, and fast solution in many cases.
13:10:27 <kuz> How about an example?
13:10:38 <kuz> Everyone likes examples.
13:10:44 <Smerdyakov> Sure. Compare developing a domain-specific language for some task in Haskell vs. C.
13:10:58 <Smerdyakov> Having the Haskell compiler around is a huge win.
13:11:16 <Philippa> OK, you get cheap and fast easily, and the trade-off for good against those two isn't as steep as it was
13:11:32 <Smerdyakov> I think you meet all the criteria, with reasonable cut-offs.
13:11:48 <Philippa> I evidently have different ideas of "reasonable cut-off"
13:11:58 <Smerdyakov> Yes, which is what we were just talking about. :P
13:12:10 <Philippa> no, you were talking strictly about variations in cheap
13:13:04 <Philippa> FWIW, if you have to do the research odds are you'll fail to produce a product fast
13:13:31 <Smerdyakov> The research is done ahead of time, natch.
13:13:50 <Philippa> "we cheat", you mean?
13:14:00 <Smerdyakov> Planning ahead isn't cheating.
13:14:12 <Philippa> no, but not counting the planning time is
13:14:56 <Smerdyakov> Research is beneficial in multiple situations, including those that arise after the research has produced something helpful.
13:15:24 <Philippa> at which point the bar for "good" has risen
13:15:34 <Smerdyakov> Not if the research was far-looking enough
13:16:38 <Philippa> the further-looking the research is, the further it's going to raise before you can use it
13:18:00 <Smerdyakov> That's not always the case. Good ideas don't always necessitate large amounts of development time.
13:18:25 <esap> From what I can tell, research is (by definition) activity that is done with the assumption that you can use infinite time for producing good results.
13:18:25 <Philippa> so it just isn't sufficient to be "good" any more by the end of its lifetime
13:18:54 <Philippa> esap: or at least until your source of funding gets fed up
13:20:13 <esap> philippa: Sure, but that'll just reduce the amount of results you can produce. The standard for the quality is high enough that you can't really avoid using lots of time.
13:20:16 <Smerdyakov> esap, I don't think that's right. I think it's the lack of obvious "customers" driving the process that matters.
13:20:28 <kuz> I don't think research necessitates an assumption of infinite time.
13:20:39 <Philippa> esap: fair enough
13:21:39 <cptchaos> what about research in Mathmatics and Physics?
13:21:45 <esap> smerdyakov: I'm not sure how any lack of customers is significant.
13:22:10 <Smerdyakov> esap, it allows freedom in pursuing avenues that might not work out.
13:22:44 <Smerdyakov> cptchaos, what about 'em?
13:23:29 <cptchaos> they both don't need customers driving the process nor be usable for producing good results?
13:23:35 <cptchaos> s/?/!/
13:24:04 <Smerdyakov> cptchaos, research isn't about producing a product for a customer in any case, including those disciplines you mentioned.
13:24:23 <cptchaos> Smerdyakov: depends on the definition
13:24:30 <esap> smerdyakov: It's not lack of customers that allows that freedom. I guess customers do want to get results in a finite time. But if your customer said you can use as much time you want, then I can't see how you couldn't pursue such avenues.
13:24:39 <Smerdyakov> cptchaos, I'm claiming that this is precisely the widely-used definition.
13:24:56 <cptchaos> Smerdyakov: Where do you live?
13:25:06 <shapr> he lives in anarcho-something-or-other land.
13:25:16 <shapr> what's the word again?
13:25:19 <mattam> you can take the general public and particularly the scientific community as the costumers
13:25:45 <shapr> Anyway, he said his ideas don't apply to an intra-capitalist-company structure.
13:25:46 <Smerdyakov> cptchaos, USA. Do you think you've found a case misclassified by my definition somewhere?
13:26:22 <shapr> anyway, can we skip this surreality and talk about Haskell some?
13:26:32 <cptchaos> Smerdyakov: In germany the definition of research is surly not depending on producing an product
13:26:41 <kuz> Haskell isn't vague-enough for discussion.
13:26:43 <esap> smerdyakov: The problem, as I see it, is that there is no mechanism for having customers that would support research. I'm sure there would be interest if there were good means to do that.
13:26:48 <shapr> kuz: oh, good point.
13:27:16 <Smerdyakov> cptchaos, I doubt it. The USA's academic model is based on the German model.
13:27:23 <Smerdyakov> cptchaos, research always has some kind of goal.
13:28:17 <cptchaos> Smerdyakov: maybe I misunderstood the term Product in your sentence
13:28:24 <mattam> maybe it would be a good time to open #haskell-cafe
13:28:25 <Smerdyakov> esap, it's the particular order of "application begets product" for most things versus "possibilities beget product" for research. A "customer" is a stand-in for a relatively narrow problem (in a particular time/place) that demands a solution.
13:28:29 <shapr> mattam: I like it.
13:28:49 <maihem> My Boss: "Tris! Stop wasting time!", "But Boss, I'm 'researching'."
13:28:54 <shapr> Smerdyakov: write up some Haskell code to simulate your economic convictions
13:29:09 <shapr> talk is cheap, code is something I can argue with.
13:29:25 <kuz> I try not to argue with code.
13:29:31 <Smerdyakov> shapr, and I think your aversion to discussions is a character flaw, conveniently chosen to prevent possible assaults against it.
13:29:38 <cptchaos> Smerdyakov: so what is a product then, if you thing just an model how something is working, then I agree
13:30:03 <Philippa> Smerdyakov: I've not found shapr to be averse to discussions in the slightest. Just averse to discussions with you
13:30:06 <Smerdyakov> cptchaos, I don't have a crisp definition, but I think most people agree on what "work" is, and work creates something (a physical object, a situation, etc.) that wasn't there before.
13:30:11 <esap> smerdyakov: I thought that would characterize platform vs. application code, not application development vs. research.
13:30:35 <shapr> Smerdyakov: are you afraid your economic model wouldn't hold up to actual scrutiny in executable form?
13:30:48 <Smerdyakov> My "economic model" is in place today and doing quite well.
13:31:06 <shapr> So show me in working code, otherwise I don't believe you.
13:31:19 <Smerdyakov> Yeah, and then I'll code up true love for you to show to your hamster.
13:31:29 <shapr> and, since this is #haskell, writing Haskell code to demonstrate your point would be totally on-topic.
13:31:37 <Smerdyakov> On-topic but ridiculous
13:31:57 <Smerdyakov> I'm not an econometricist, and I don't have any interest in doing what one does.
13:32:39 <maihem> Linguists had models in place and doing quite well, then computational linguists came along and put the models in code, found that A: they couldn't because the models were incomplete and inconsistent, and B: once they were completed, found that they were wrong.
13:33:12 <Smerdyakov> Which is fine. As long as they continue predicting correctly the situations that are encountered, they are useful.
13:34:17 <esap> "predicting correctly the situations" is the mantra for physics. Not for economy :-)
13:34:33 <Smerdyakov> It's what any theory does.
13:34:44 <kuz> That's what models do.
13:34:44 <shapr> This is a programming channel, if programming is not at all part of a discussion, take that discussion elsewhere.
13:35:14 <cptchaos> shapr: loosing patience?
13:35:25 <shapr> I lost patience a long time ago.
13:35:26 <Lor> All theory is programming, for a suitably loose definition of programming. :)
13:35:58 <maihem> I theorise that yes, indeed.
13:35:59 <esap> lor: I would say the opposite: All programming is theory, for a suitably strong definition of programming.
13:36:12 <Smerdyakov> esap, they're isomorphic!
13:36:31 <shapr> Programming is applied theory. If you can program, and are not willing to program your theories, I see lack of conviction.
13:36:42 <Smerdyakov> Theory is applied programming.
13:37:16 <Smerdyakov> shapr, you don't make any sense. Your rules of proper discourse are out of synch with any I've ever heard of.
13:37:40 <Smerdyakov> shapr, like if I said "creame pie is delicious" and you said "go code me one or I don't believe you."
13:37:49 <shapr> Smerdyakov: give it up.
13:38:13 <Smerdyakov> shapr, excuse me, but _I_ had stopped discussing it, and _you_ brought it up again with a criticism aimed _precisely_ at me.
13:38:13 <Philippa> no, there's a qualitative difference there - you can't construct a non-trivial model that shows cream pie is or isn't delicious
13:38:51 <kuz> Constructing a complete economic simulator would be non-trivial.
13:38:57 <eixei> uhm, you can... if it has chocolate in it it is delicious, at least 90% of the time
13:39:13 <eixei> would be a pretty good model imho
13:39:16 <Philippa> kuz: yeah, this is why so much economic theory's crap - they don't bother
13:39:23 <kuz> I would settle for just some sort of empirical foundation for the purposes of discussion.
13:39:33 <Philippa> eixei: you've not been subjected to much of the crap that passes for chocolate over here then
13:40:07 <kuz> Social sciences have a tendency to collect crap.
13:40:20 <eixei> Philippa: ouch, unlucky you then... all chocolate I've tasted so far has been pretty nice :-)
13:40:27 <mattam> kuz: and try to make sense out of it
13:40:29 <Smerdyakov> Especially fecoanthropology.
13:40:35 <shapr> Smerdyakov: I did not aim that criticism at you.
13:41:09 <Smerdyakov> All tofu is tastier than all chocolate!
13:41:43 <eixei> tofu? Hmm, I thought tofu tasted like nothing
13:41:48 <Smerdyakov> Exactly!
13:42:05 <kuz> Do you have any non-subjective criticisms to his assertion that you should provide testability?
13:42:13 <Smerdyakov> The human imagination is much better equipped than reptilian sweetness sensors!
13:42:32 <eixei> well, how can it taste better than chocolate then? There is nothing better than a piece of chocolate, except a piece of chocolate and a big cup of coffee
13:42:36 <Smerdyakov> kuz, are you talking to me?
13:42:40 <kuz> Yes.
13:42:52 <Smerdyakov> kuz, but shapr doesn't want you to bring it up again.
13:43:10 <kuz> Ah yes.
13:44:04 * shapr watches the jumping chimpanzees
13:44:47 * Lor suggests everyone to calm down and go have some fun elsewhere for a while.
13:45:04 * Lor will play pools of darkness.
13:45:11 * cptchaos continues coding
13:45:15 <kuz> I'm quite enraged.
13:45:20 <kuz> Rawr.
13:45:49 <Philippa> shapr: you found dubya jumping?
13:45:56 <kuz> Haha.
13:46:11 <shapr> nah, Heinlein's jumping chimpanzees.
13:46:36 <eixei> pools of darkness?
13:47:02 <Philippa> hrmm, I'm not sure which is more nuts - dubya or end-of-career Heinlein
13:47:27 <mattam> how could I have fun watching "Hitler's Hitparade" ?
13:48:51 <eixei> oh, a "classic" rpg, sweet
13:48:52 <kuz> Post-end-of-career Hagelin beats them both.
13:49:50 <mattam> duh, Goebbels was really good at propaganda. It all looks like a US-movie trailer
15:40:10 <cptchaos> @index read
15:40:10 <lambdabot> GHC.Read,Prelude,Text.Read
18:43:17 <eixei[asleep]> night
20:59:08 <heatsink> um...
20:59:10 <heatsink> @pastebin
20:59:10 <lambdabot> Sorry, I don't know the command "pastebin", try "lambdabot: @listcommands
20:59:17 <heatsink> lambdabot: @listcommands
20:59:17 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
20:59:17 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
20:59:17 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
20:59:17 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
20:59:17 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
20:59:17 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
20:59:19 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
20:59:21 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
20:59:23 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
21:01:24 <heatsink> Where is the paste code service?
21:03:38 <heatsink> oh, I found one...
21:03:55 <heatsink> How do I export a data constructor from a module?
21:03:59 <heatsink> When I do this http://authors.aspalliance.com/aylar/ViewPasteCode.aspx?PasteCodeID=3062
21:04:29 <heatsink> I get errors for 'Dollar' and 'Euro' when compiling that file
21:53:13 <Lemmih> heatsink: module Money (Money(..)) where
21:53:44 <heatsink> Lemmih: thx, I found an exmaple of it in the prelude
21:55:17 <Lemmih> @wiki HaskellIrcPastePage
21:55:18 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:01:10 <Lemmih> Hello LrdMtrod.
22:03:48 <LrdMtrod> hej
22:41:20 <Tryblithe> hi
22:41:33 <Tryblithe> can someone benchmark  how fast haskell can do a tan() :)
22:47:45 <Lemmih_> tan()?
22:48:32 <Tryblithe> tan
22:48:33 <Tryblithe> tangent
22:48:34 <Tryblithe> trig
22:55:30 <jesse99> why do you think measuring the speed of tan is going to be a useful benchmark?
22:55:36 <musasabi> morning
22:55:52 <Tryblithe> im deciding if  i should do it in mysql or haskell
22:55:57 <Tryblithe> math functions, that is.
22:56:22 <musasabi> Tryblithe: that won't probably be significant.
22:56:31 <jesse99> it's likely that both languages will ultimately be calling through to the C math library for tan
22:56:57 <Tryblithe> good. then its mysql
22:57:03 <musasabi> Tryblithe: mysql has to parse it, while haskell supports large numbers...
22:57:53 <musasabi> personally I would do it the easiest way - in haskell.
22:58:02 <Tryblithe> lol well its part of a mysql query.
22:58:33 <jesse99> it's a database query but you think tan is going to be the bottleneck?
22:58:45 <Tryblithe> no. i dont know if i should do math functions with the query
22:58:52 <Tryblithe> or should i do it externally using haskell
22:59:09 <Tryblithe> if i can't save a lot of time from haskell, then of course i am using mysql :)
23:00:50 <musasabi> keeping queries simple is one quite important values.
23:01:17 * musasabi generally likes to define some views to the database and keep all queries trivial.
23:01:39 <Tryblithe> ok
