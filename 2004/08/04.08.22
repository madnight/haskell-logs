00:13:33 <musasabi> morning
00:17:01 <musasabi> takeInterval (n,m) = take (m-n) . drop n
00:19:13 <musasabi> How should I go about internalionalizing a haskell program?
00:19:25 <musasabi> I want to provide two language versions of it.
00:19:53 <musasabi> But how to archive that best.
00:37:24 <musasabi> anyone?
00:47:19 <stefan_> musasabi: I just arrived, what's your question?
00:48:14 <musasabi> stefan_: How to would I internationalize a haskell program, that is provide all the messages in two different languages in an elegant way.
00:50:45 <stefan_> I guess you want to avoid passing around the current locale?
00:51:35 <musasabi> yes, and to centralize the translation somehow - adding a translation should not touch each and every file.
00:52:34 <stefan_> I've no idea, really ... almost sounds like AOP in a functional setting ... don't know too much about that, I'm sorry
00:57:37 * musasabi plots something with template haskell
01:37:10 <musasabi> found http://cvs.sourceforge.net/viewcvs.py/haskell-i18n/Source/Text/I18N/
02:05:46 <musasabi> Is there anything like popen in the libs?
02:11:23 <dons> yep. POpen. you need -package posix flag, I think
02:12:17 <dons> @type POpen.popen
02:12:18 <lambdabot> bzzt
02:12:34 <dons> wonder how you pass lambdabot a -package flag
02:19:17 <Lor> dons, I'm a bit dubious about the alleged virtues of pdynload. AFAICS, it is even less safe than the basic dynload.
02:43:59 <esap> What's the haskell notion for the categorical notion of pullbacks?
02:52:25 <stefan_> esap: mmm ... I'm not sure ... I do not really see a Haskell notion ... I can imagine it for languages with subtyping, though ...
02:53:19 <esap> I'm thinking that type classes are close, but I'm not sure they're exactly it.
02:53:52 <stefan_> esap: could you elaborate on that?
02:54:11 <pesco> Mornin.
02:54:47 <esap> Well the idea comes from some slide set I saw that compared UML associations and pullbacks. And a (multi-parameter) type class is a kind of an association between two or more types.
02:56:21 <esap> It's not very exact, I haven't worked out the details. But I suspect the pullback A x_C B would be represented by the types that are constrained by the type class.
02:56:23 <stefan_> esap: do you have a link to the slides?
02:57:26 <esap> I found it from google, hmm.. let me try to find it again
02:57:30 <stefan_> :)
03:01:36 * esap can't find it.
03:02:10 <stefan_> too bad ...
03:02:36 * stefan_ will be thinking about pullbacks and mp type classes during lunch ...
03:03:01 <esap> The idea was anyway that A x_C B (as a subset of AxB) would represent a relation between the types A and B.
03:03:47 <esap> Which is kind of like what type class is.
03:10:05 <Marvin--> category theory - the art of inventing new names for existing stuff
03:10:33 <esap> hehe. Well it does also describe them formally.
03:11:29 <clausen> while we're in maths mode... anyone know of any discontinuous linear mappings?
03:11:46 * Marvin-- flees
03:12:04 <Marvin--> (actually, I'm making coffee)
03:12:57 <Lor> How can a linear mapping be discontinuous? Or which sense of linear are we talking about in here?
03:15:18 <clausen> Lor: if you have weird topologies on the vector spaces
03:15:45 <clausen> but, I'm struggling to come up with a weird topology
03:16:23 <clausen> Lor: do you know what a normed space is?
03:17:18 <Lor> Yeah.
03:17:27 <clausen> "It can be shown that a linear mapping between two topological vector spaces is continuous if and only if it is continuous at 0." -- planetmath
03:18:28 <esap> Hmm.. by that, I guess you have to introduce noncontinuity at 0.
03:18:38 <esap> :-)
03:20:26 <clausen> The space of linear functionals isn't complete wrt the integration norm... I wonder if that helps...
03:21:15 <clausen> (oops, s/linear functionals/functions/... what was I thinking?)
03:41:32 <TheHunter> clausen: are Q-vector spaces ok?
03:46:45 <TheHunter> anyway, fix a basis of R considered as a Q-vector space. A linear map that swaps two vectors of that basis is obviously not continuous (wrt the usual topology on R)
03:53:06 <clausen> TheHunter: yes, q-vector spaces are ok
03:53:32 <clausen> TheHunter: I think it obviously is continuous :)
03:53:44 <pesco> cptchaos: The cmdline parser is feature-complete and basically documented. Check it out.
03:54:38 <TheHunter> clausen: Take the function which leaves all basis vectors fixed and map one basis vector to 0
03:55:30 <TheHunter> clausen: Then the points which are linear combinations of that vector are dense in Q
03:55:40 * clausen thinks
03:56:08 <TheHunter> clausen: so are the points which don't have a component of that vector
03:56:50 <TheHunter> so the points with f(x) = x and the points with f(x) = 0 are dense in R, that is f can't be continous
04:01:59 <clausen> TheHunter: very clever.  thanks
04:03:51 <Lor> Q-vector means just a product of rationals?
04:04:48 <Lor> Hum, apparently not.
04:05:54 <TheHunter> It means that in linear combinations the coefficients are rationals, so sqrt(2) is not a linear combination of 1 because it is irrational
04:17:38 <Lor> Hm, is there always some standard topology associated with a vector space?
04:21:50 <clausen> Lor: don't think so... eg: the sup metric or the integration metric on bounded continuous functions...
04:21:55 <clausen> neither seem "standard" to me
04:23:46 <Lor> What's the meaning of the original question then? "Is there a discontinuous linear mapping" is only sensible if you have some topology relative to which the continuity is defined.
04:42:54 <clausen> Lor: right... the question was about "in which topology is this possible", I guess
04:43:29 <clausen> Lor: in R^n -> R^m with euclidean topology, every linear function is (Lipschitz) continuous
04:43:41 <np_hard> I have a silly question
04:44:05 <pesco> As long as it's not NP-hard. Bwahaha sorry.
04:44:12 <np_hard> :)
04:44:13 <pesco> ;-) shoot.
04:44:28 <np_hard> I am writing a tic tac toe game in Haskell, where the board is represented by algebraic types
04:44:38 <np_hard> data Square = X | O | E
04:44:38 <np_hard> data Row = R Square Square Square
04:44:38 <np_hard> data Board = B Row Row Row
04:45:25 <np_hard> now I am writing a winner function to determine if anyone is the winner of a given board configuration
04:46:01 <np_hard> It seems to me that using pattern matching on those types would be the simplest way to implement that function, but that is a heck of a lot of hardcoding
04:46:05 <np_hard> e.g.
04:46:17 <np_hard> winner (B (R X X X) _ _) = X
04:46:34 <np_hard> winner (B (R X _ _) (R X _ _) (R X _ _)) = X
04:46:36 <np_hard> and so on
04:47:09 <pesco> 8 patterns per player, I think. so, 16 in all.
04:47:25 <np_hard> yeah, but in principle it's something you don't want to do
04:47:30 <clausen> you could use a list of lists, or an array ADT
04:48:12 <pesco> np_hard: In principle no. But sometimes things wrong "in principle" are good in special cases.
04:48:20 <np_hard> right
04:48:25 <np_hard> now here is my question
04:48:26 <arjanb> write the code without assuming a fixed board size
04:48:28 <pesco> Im not suggesting you hard-code here, just pointing out you might.
04:48:45 <np_hard> since it is conceptually nicer to use pattern matching given my data definitions
04:48:54 <np_hard> is this something that Template Haskell would help with ?
04:49:16 <pesco> Ok, someone else please, I haven't used TH.
04:49:51 <np_hard> arjanb: I can't use algebraic data types unless I have a fixed size in mind :)
04:50:30 <Lor> Arrays are best here.
04:51:08 <np_hard> why is that?
04:51:58 <Lor> Don't just list all the possible matching patterns, but express explicitly what is it that makes some boards be victories for X and others for Y.
04:54:05 <goron> np_hard: I know a very inefficient algorithm that does what you want.
04:54:13 <np_hard> what's that?
04:54:29 <goron> np_hard: You make a function that plays "best". 
04:54:37 <np_hard> :-P
04:55:18 <goron> np_hard: Then you just let both players play "best" and check which one wins by definition...
04:56:00 <goron> np_hard: For small boards, this would work.
04:56:46 <goron> np_hard: If you don't know what's "best", you just try everything.
04:56:58 <goron> np_hard: But that's NP-hard...
04:56:59 <np_hard> yes
04:57:02 <np_hard> :)
04:57:10 <np_hard> also
04:57:36 <np_hard> I would need a way to evaluate a move for goodness
04:57:48 <np_hard> and hmm, how would I do that without telling if a position was a winner?
04:57:50 <np_hard> hmm
04:58:06 <goron> np_hard: If you have zero knowledge: then you could calculate everything.
04:58:18 <goron> np_hard: You also can let you program learn.
04:58:33 <goron> np_hard: Using reinforcement learning.
04:58:43 <np_hard> either I would have to manually tell it if a position was winning
04:58:50 <np_hard> or I would have to code a function to tell it so
04:59:17 <goron> np_hard: You have to have a function by definition. The first collapses in the second...
04:59:50 <goron> np_hard: You also can create a program that creates your program, but that would require near infinite time :)
05:00:34 <np_hard> thanks pesco :)
05:01:23 <goron> :?
05:54:09 <shapr> wheee
05:54:17 <andersca> my hard drive is failing :(
05:54:31 <pesco> Hey shapr!
05:55:12 <shapr> andersca: suck, save it!
05:55:15 <shapr> y0 pesco 
05:55:15 <shapr> wassup?
05:55:37 <pesco> My command line parser is feature-complete (for now *g*).
05:55:48 <shapr> cool!
05:56:00 <pesco> Can I run CGI scripts on snowblind?
05:56:23 <shapr> I think so
05:56:26 <shapr> if not, bug me
05:56:30 <shapr> and I'll fix it.
05:57:34 <pesco> Cool. I'd like to run an automatic .xweb -> .hs generator on the server so people can look at the raw source of my programs but I don't have to place in under version control.
05:57:47 <pesco> s/in/it/
05:58:11 <shapr> sure, go for it
05:58:21 <pesco> Do you have xsltproc installed?
05:58:26 * shapr checks
05:58:49 <shapr> now I do :-)
05:58:54 <pesco> Awesome!
05:59:00 * pesco bows to shapr many times.
05:59:12 <shapr> hey, it'd be cool if the darcs cgi browser could handle plugins for custom stuff like xsltproc
05:59:47 <pesco> Yes, probably.
06:03:28 <Shammah> evening shapr :)
06:17:07 <goron> shapr: I still can use some advice on Arbitrary. Can you help?
06:31:55 <goron> shapr: Never mind it. I hacked something together. 
06:35:41 <goron> QuickCheck is pretty darn neat this way. All of the cases of input I purposely did not account for it detects...
06:49:46 <shapr> goron: yay!
06:50:08 <shapr> hiya jak 
06:51:37 <shapr> hej andersca 
06:51:43 <shapr> hiya Shammah
06:51:51 <shapr> goron: you still have QuickCheck questions?
06:52:59 <pesco> later
06:53:03 <shapr> cya
06:53:04 <goron> shapr: Well, my question was how I could generate random instances of a datatype Foo with two constructors A String and B String
06:53:10 <shapr> did you figure it out?
06:53:20 <goron> Yes, I used two choose function
06:53:23 <goron> s
06:53:27 <jak> hey shapr
06:53:33 <andersca> hej shapr
06:53:36 <goron> But coarbitray is a big riddle to me.
06:53:45 <goron> hey shapr ;)
06:53:56 <shapr> have you looked at the original QuickCheck paper?
06:54:20 <goron> Looked yes, but I became bored when I come to the monadic stuff. 
06:54:37 <goron> come=>came
06:54:54 <shapr> the part about coarbitray is on the third page or so, I think.
06:55:20 <goron> Well, I will look to it one more time...
06:57:02 <roconnor> I claim (abs x)*(signum x) == x for (almost) all x.
06:57:12 * goron hates there is no such thing as searching in ps files. At least not in my program. Is there another which can?
06:57:21 <roconnor> google.
06:57:44 <musasabi> grep ?
06:58:14 <juhp> ps2pdf?
06:58:15 <musasabi> the trivial solution is ps2ascii + grep or pstopdf + acrobat + search
06:58:57 <goron> Well that covers it...
07:03:29 <goron> pstopdf? What's the Debian packagename of that?
07:06:57 <musasabi> gs-common has ps2pdf
07:12:36 <roconnor> hmmm
07:12:58 <roconnor> is Haskell a rip-off of Miranda?
07:13:09 <shapr> roconnor: from what I've heard, sort of...
07:13:44 <shapr> the way I heard it, a whole bunch of people dearly loved Miranda, but the company that owned Miranda (research software limited or something like that) wasn't that community friendly.
07:14:01 <shapr> or maybe they were community friendly but it just wasn't enough
07:14:44 <shapr> From what I've heard, Haskell was started to get an open version of some (all?) of the Miranda features.
07:15:03 <shapr> All of this was long before my time of course, but I've heard bits and pieces from different people.
07:16:18 <roconnor> right
07:16:24 <shapr> if you want to know more, you should read all the stuff that SPJ has written
07:16:35 <roconnor> !
07:16:42 <shapr> yah, that's a lot of stuff :-)
07:17:12 <shapr> oh, ask Pseudonym next time he's awake
07:17:15 <shapr> he knows more than I do.
07:17:49 <roconnor> I'm reading ``Implementing functional laguages: a tutorial''
07:18:02 <shapr> oh, is that the book SPJ and whatshisname wrote?
07:18:14 <shapr> oh wait, 'a tutorial' is the other one...
07:18:17 <roconnor> David Lester
07:18:36 <shapr> SPJ is an impressive guy.
07:19:07 <roconnor> Is SPJ pro monomorphism restriction, or anti monomorphism restriction?
07:19:17 <shapr> I met him at ICFP03 and I discovered he's also *really* nice, considerate, friendly, and he takes people seriously all the time.
07:19:29 <shapr> It's almost hard to believe :-)
07:19:40 <roconnor> why is that?
07:20:07 <shapr> I'm surprised someone who is that nice can actually get that much stuff done.
07:20:33 <roconnor> oh
07:20:52 <roconnor> I wish I could get that much stuff done.
07:20:56 <shapr> me too
07:21:04 <shapr> even so, I enjoy trying to follow his example.
07:21:14 <shapr> he's a great lead-by-example guy.
07:21:49 <shapr> Simon Marlow and John Hughes are also really nice, really smart, and don't have that much ego.
07:21:56 <roconnor> He is using Miranda in this book of his
07:22:18 <roconnor> I can barely distinguish Miranda from Haskell.
07:22:24 <andersca> john is nice
07:22:29 <shapr> yah, john is nice.
07:22:34 <shapr> I'd like to hang out with him more.
07:23:00 <shapr> and the rest of the gothenburg Haskellers too :-)
07:23:12 * shapr points at andersca 
07:23:14 <roconnor> where is gothenburg?
07:23:20 <shapr> southwest of Sweden
07:23:44 <roconnor> Er, Sweden is a country.
07:24:01 <shapr> From what I know, gothenburg one of the two largest concentrations of Haskellers.
07:24:06 <tic> hehe.  probably. :)
07:24:09 * tic waves
07:24:17 <shapr> the other is probably ogi.edu/pacsoft/etc
07:24:41 <shapr> I know there are several at oxford, though I'm not sure how many.
07:25:19 <shapr> uu.nl has swierstra and that crew, uni-freiburg.de has Thiemann and his crew of functional guys.
07:25:31 <shapr> The Brazil contingent is growing too.
07:25:33 <roconnor> oh, southwest of Sweden, but inside Sweden.
07:25:38 <roconnor> I'm with you now.
07:25:50 <shapr> hah, I doubt it! I'm in the north east of Sweden!
07:26:09 <shapr> In fact, just south of the Arctic Circle.
07:26:26 <roconnor> *sigh* I'm moving to the birthplace of Clean.  They are all going to frown on my love of Haskell.
07:27:39 <shapr> Clean is from .nl, right?
07:27:44 <shapr> I forget which uni though.
07:27:53 * tic is in Göteborg / Gothenbourg.
07:28:07 <shapr> Anyway, Clean and Haskell are nearly twins when you look from the Java or Forth viewpoint.
07:28:12 <roconnor> Nijmegen
07:28:17 <shapr> ah yes
07:28:26 <shapr> home of a nice girl I used to live with...
07:28:34 <roconnor> I don't really know anything about Clean
07:28:58 <goron> roconnor: You don't want to know *anything* about it...
07:29:22 <roconnor> shapr: I'm surprised you are always on when I am, if you are in Sweden.
07:29:25 <shapr> the first difference you'll see is that Clean uses uniqueness types rather than monads to do IO
07:29:34 <shapr> roconnor: whyso?
07:29:42 <roconnor> I'm in Canada.
07:29:53 <shapr> well, it's nearly 5pm here.
07:29:59 <shapr> and I'm actually working on my company website anyway.
07:30:21 * shapr is not a morning person.
07:30:49 <roconnor> Why would they not use Monads when Monads are awsome?
07:30:59 <roconnor> Isn't ML getting Monadic IO?
07:32:11 * shapr dunno
07:32:29 <shapr> uniqueness types are just a different approach
07:32:48 <shapr> they have their own set of good and bad points, just like monads.
07:33:02 <shapr> They do get you closer to linear types, which are interesting in their own right.
07:33:07 * roconnor doesn't know anything about uniqueness types
07:33:33 <shapr> they're worth reading about.
07:33:40 <roconnor> I have an adversion to fiddling with type systems.
07:33:49 <shapr> I like type theory.
07:33:54 <roconnor> Actually I didn't like the idea of dependant types at first.
07:33:59 <shapr> and now?
07:34:11 <roconnor> But now I know they are the future of programming.
07:34:17 <shapr> I agree with you.
07:34:24 <roconnor> So I guess I should at least look at uniqueness types.
07:34:35 <shapr> Even so, have you read what Frank Atannasow has against dependant types?
07:34:40 <roconnor> no
07:34:43 <shapr> Atanassow?
07:34:44 <roconnor> I should 
07:34:53 <shapr> I can never get the number of n and s straight in his name.
07:35:10 <roconnor> I probably need some balance in my viewpoints
07:35:15 <shapr> in essence, he says it cuts down on the modularity of programs.
07:35:29 <roconnor> that seems unlikely
07:35:48 <arjanb> shapr: do you have a link?
07:35:55 <shapr> well, he says you'll end up with monolithic programs where the code bits can't be easily reused in other programs.
07:36:03 <shapr> arjanb: it's on lambda-the-ultimate.org somewhere
07:36:09 <shapr> might be in the archives, I forget.
07:37:03 <roconnor> I have no idea how one might come to that conclusion.
07:38:08 <roconnor> Dependant types seem to have nothing to do with modularity
07:38:29 <goron> Frans works @ UU, right?
07:38:33 <goron> Frank works @ UU, right?
07:38:44 <roconnor> The only problem I have with Dependant types, is that they are so damned difficult to use.
07:38:45 <shapr> last I checked, he did.
07:39:03 <PeterE> @UU
07:39:03 <lambdabot> Sorry, I don't know the command "UU", try "lambdabot: @listcommands"
07:39:24 <shapr> hey PeterE, wassup?
07:39:47 <goron> Well, I hope he one time creates a categorical programming language.
07:40:22 <PeterE> shapr: Nothing much. Just played BZFlag, and when I got to -108 points, I thought it was time for a brake.
07:40:36 <shapr> heh
07:40:40 <roconnor> caategorical programming languages
07:40:44 <shapr> I just got to 22 honor in America's Army.
07:40:44 <PeterE> shapr: brake -> break.
07:40:54 <roconnor> Sound like a functional language without lambdas.
07:41:17 <goron> roconnor: Why would that be?
07:42:10 <roconnor> Well, I don't know what it would be.  But type theory is a CCC, so maybe if you get rid of lambdas, you have a categorical language?
07:42:13 * goron they f*cked up the interpreter in ghc cvs debian version...
07:42:19 <roconnor> I have no idea what a categorical language is.
07:43:19 <goron> I need to kill ghci and restart to reload...That hurts...
07:45:13 <roconnor> @type (#)
07:45:14 <lambdabot> bzzt
08:08:26 <stefan_> roconnor: (#) :: a -> (a -> b) -> b ; a # f = f a
08:09:04 <stefan_> for some reason # GHC does not allow # as an operator
08:10:42 <TheHunter> stefan_: works for me
08:11:06 <stefan_> goron, shapr: Frank A? yes, he works at UU
08:15:08 <stefan_> TheHunter: it is allowed as long as glasgow extensions are turned off, isn't it :S
08:18:28 <stefan_> perhaps more elegant: (#) = flip ($)
08:27:35 <roconnor> Actually, it looks like the code in this book may have been rewritten in Haskell
08:27:54 <roconnor> Because the code no longer fits with the text around it.
08:33:08 <goron> Lazy evaluation exploit: and $ map (undefined) []
08:34:08 <roconnor> True?
08:34:26 <goron> yes
08:34:45 <roconnor> exploit?
08:35:12 <goron> Wel, use, but exploit sounds nices :)
08:35:32 <roconnor> why do you bring this up?
10:00:35 * shapr bounces cheerfully
10:00:39 <shapr> I love unicycling!
10:00:49 <shapr> I'm getting pretty good at hopping.
10:01:31 <Maddas> :-)
10:11:32 <basti_> hi
10:11:37 <shapr> gutenabend!
10:11:44 <basti_> yep.
10:11:45 <cm> achtung
10:11:47 <shapr> wassup?
10:12:04 <basti_> not much
10:12:22 <Maddas> Not much, me and my hawgs hammin' around, chillin' the cold pen
10:12:30 <shapr> um
10:12:32 <shapr> really?
10:12:36 <Marvin--> man... 17.69 with a bad jump, Christian Olsson is amazing
10:12:36 <shapr> man ebonics sure has changed.
10:12:48 <Maddas> no, just sitting here monitoring IRC :(
10:13:37 <shapr> jetz ist abba feierabend!
10:13:42 <Maddas> shapr: I just memorized that one in case somebody asks me :-)
10:13:50 <shapr> er, which one?
10:13:52 <shapr> oh that one
10:13:57 <basti_> verboten!
10:14:04 <Maddas> Mein lamen!
10:14:10 <basti_> bitte?
10:14:13 <shapr> weiswurst!
10:14:15 <Maddas> Mein Lamen!
10:14:19 <shapr> I like weiswurst.
10:14:23 <basti_> what shall that mean Maddas?
10:14:28 <basti_> bier.
10:14:39 <shapr> I think Maddas is quoting from Castle Wolfenstein the original.
10:14:43 <basti_> ah
10:14:50 <Maddas> What people thought that those guys in, what's it called again, Castle Wolfenstein thing said when they died.
10:15:01 <Maddas> Yeah :-)
10:15:02 * basti_ is a doom era kid
10:15:07 <basti_> pc wise
10:15:16 <Maddas> (They actually said "Mein Leben!")
10:15:17 <basti_> i bet they meant "mein leben!"
10:15:18 <Marvin--> Mein Leben
10:15:22 <basti_> heheh
10:15:23 <Riastradh> Marathon was _soooo_ much better than Doom or Wolfenstein.
10:15:31 <shapr> right, I heard 'mein leben' too, but I still don't know what it means.
10:15:34 <Maddas> I always read about Marathon but never played it yet.
10:15:35 <basti_> "my life"
10:15:37 <Maddas> shapr: "My life"
10:15:39 <shapr> related to leibling?
10:15:40 <shapr> oh
10:15:43 <Maddas> haha
10:15:45 <basti_> not a thing you would say in such a situation.
10:15:56 <Maddas> Indeed. But they had such a nice accent...
10:16:01 <basti_> we did quake and unreal deathmatch later.
10:16:02 <shapr> ja, I was wondering why they would say something like "mein leibling"
10:16:11 <Maddas> haha
10:16:27 * shapr learned that from a cute german girl long ago
10:16:32 <basti_> -g-
10:16:37 <Maddas> liebling :-)
10:16:43 <shapr> oh, thanks
10:16:44 <basti_> how old were you and her back then? ;)
10:17:04 <shapr> um, I was 22, and she was 21
10:17:05 <Maddas> I began with NES and SNES games.
10:17:06 <basti_> ie is a "long i" sound like in "beer"
10:17:07 <Riastradh> And...what does 'leibling' mean, for us ignorant non-barbarians?  *duck*
10:17:09 <basti_> i see
10:17:18 <basti_> liebling = lover, honey
10:17:20 <basti_> dear
10:17:23 <basti_> something like that
10:17:24 <Maddas> sweetheart
10:17:29 <basti_> yep
10:17:30 <shapr> that was ten years ago, does that count as 'long ago' ?
10:17:37 <basti_> i think so.
10:17:39 <shapr> ok
10:17:51 <shapr> anyway, I still get email from her.
10:17:51 <Maddas> heh
10:18:08 <Maddas> Girls never responded to my e-mails
10:18:08 <shapr> nice girl in Leipzig.
10:18:12 <basti_> :)
10:18:57 <Maddas> Actually, one did, but she stopped pretty quickly 
10:19:25 <Maddas> Ack, speaking of which, I still have a letter I got in February 2002 I should reply to
10:19:34 <basti_> i live with one of these responding girls now.
10:19:45 <Maddas> Me too.
10:19:50 <Maddas> (Alone) :-)
10:19:53 <basti_> aww.
10:19:58 <shapr> She's actually from a tiny village outside of Leipzig, she has a *very* hick German accent. I learned high class American from a family friend of ours who has way too much money, and Melanie learned much of that refined accent from me. She met a bunch of other Germans while she was living with me, but it weeks later that she first spoke German with them.
10:19:58 <basti_> i mean in the same flat and stuff
10:20:00 <Marvin--> haha
10:20:34 <Marvin--> poor Maddas
10:20:37 * shapr agrees
10:20:49 <basti_> women.
10:20:51 <Riastradh> Maddas, cheer up!  Your burning (er, whirring, or whatever) CPU will keep you warm!
10:20:58 <shapr> can't live with 'em, can't live without 'em
10:21:17 <basti_> yep
10:21:40 <shapr> I sure do love 'em though.
10:21:42 * Maddas pats his laptop
10:21:48 <shapr> Women are *far* better than programming.
10:21:58 * Riastradh cuddles the AlBook warming his lap.
10:22:17 <basti_> hmm well yes programming isnt warm and soft and wet and stuff.
10:22:18 <Maddas> shapr: But computers are more responsive, at least the ones not running Windows!
10:22:20 <shapr> I live with a cute german/french girl right now.
10:23:06 <cm> best possible combination
10:23:08 <cm> you combinator!
10:23:13 * shapr agrees
10:23:17 <basti_> hmm really?
10:23:23 <shapr> all the emotion of the french, and the organization of the germans.
10:23:25 * basti_ is into asians secretly.
10:23:28 * shapr grins.
10:23:34 <basti_> ;)
10:23:44 <Riastradh> That's not much of a secret now, is it, basti_?
10:23:45 <shapr> Well, my favorites are german and french, so I've very lucky.
10:23:57 <basti_> i mean secret to my girlfriend for example
10:24:04 <Maddas> Heh heh heh.
10:24:05 <shapr> heh
10:24:08 * shapr laughs
10:24:09 <Maddas> What's her e-mail address again?
10:24:14 <Riastradh> How do you know she isn't reading the logs?  Or...here?
10:24:20 <basti_> she isn't
10:24:22 <basti_> i'm sure.
10:24:24 * Riastradh shifts his eyes shiftily.
10:24:27 <basti_> she doesnt care about haskell
10:24:29 <Philippa> ah well. My boyfriend /knows/ I'm into women, no problems there
10:24:33 <Marvin--> basti_: aw :/
10:24:34 <shapr> yow!
10:24:38 <basti_> :(
10:24:40 <Maddas> @yow
10:24:40 <lambdabot> I am a jelly donut.  I am a jelly donut.
10:24:44 <cm> hey Philippa
10:24:47 <Philippa> 'lo cm
10:24:51 <cm> checking out your stuff atm
10:25:19 <Philippa> cool, lemme know what you think
10:25:42 <Philippa> it's not exactly revolutionary IMO, would like to bolt overloading on top and see what can be done though
10:31:24 <Maddas> Yay for ERC, it lets me replace "im" with "i'm" and "its" with "it's" and so on when necessary in the logs.
10:31:32 <Maddas> Er, in the scrollback.
10:31:35 <shapr> yay
10:31:42 <shapr> ERC roxx
10:31:45 <shapr> I even wrote part of it!
10:31:55 <Maddas> I know :-)
10:32:22 <cm> .oO(ERC? :)
10:32:41 <shapr> Emacs Irc Client
10:33:55 <cptchaos> emacs? That OS that pretends to be an text-editor?
10:34:04 <shapr> yes, that's it.
10:34:11 <basti_> :P
10:35:02 <tic> a+a'b == a+b?
10:35:32 <cptchaos> depends on the values of a , a'b  an b 
10:35:55 <basti_> -g-
10:36:21 <cm> hehe
10:36:44 <cm> cool, vim 6.3 for windows uses the NSIS
10:37:31 * cm installs vim as notepad2 has no haskell syntax highlighting..
10:37:48 <Maddas> It doesn't?!? :-)
10:38:03 <cm> or does it?
10:38:35 <Maddas> I doubt it..
10:39:37 <cm> indeed, it doesn't
10:39:40 <Philippa> cm: textpad does, 'swhat I'm using under win32 atm
10:39:53 <Philippa> though if you're comfortable with vim it's prolly what you should go with
10:39:58 <cm> hrm
10:40:07 <Marvin--> notepad2?
10:40:09 * cm googles for textpad
10:40:21 <cm> Marvin--: http://www.flos-freeware.ch/notepad2.html
10:40:27 <Marvin--> oh
10:40:41 <cm> pretty neat
10:40:43 <Marvin--> silly me, I thought micros~1 had decided to ship a decent text editor
10:40:47 <Philippa> you'll need to grab the syntax file off haskell.org. It's a fairly nice MDI editor, though not overly scriptable
10:40:58 <Philippa> Marvin--: if you can afford VS.net...
10:41:31 <Marvin--> well, I can probably *afford* it, but I think I'd be happier if I spent the money on beer and women :)
10:42:27 * cm is still awaiting Visual Haskell ;o
10:42:47 <shapr> eek
10:44:05 <shapr> hiya jpgil-huinca 
10:44:07 <Philippa> for the right values of Visual it could be cool...
10:44:18 <cm> i used to be on the mailing list for it
10:44:23 <Philippa> certainly if it parses and type checks as you edit
10:44:28 <cm> Simon Marlow appears to be kinda coordinating it
10:44:35 <jpgil-huinca> Hi shapr
10:44:52 * Philippa wants a fully guified emacs w/haskell instead of elisp though
10:45:09 <shapr> yes!
10:45:24 <cm> emacs with cua.el is good :P
10:45:30 * jpgil-huinca wonders what relation has shapr with brainfuck
10:45:37 <Maddas> cua.el?
10:45:51 <Philippa> cm: would like the facility for script code to build nice graphical stuff where useful though
10:45:52 <cm> CUA bindings for the poor souls! :)
10:46:04 <shapr> jpgil-huinca: excuse me?
10:46:05 <cm> Philippa: yeah
10:46:18 <jpgil-huinca> I read something about brainfuck in your wiki page.
10:46:44 <Philippa> brainfuck's just a language designed for the purpose of brainfucking...
10:46:56 <Maddas> CUA?
10:47:00 <jpgil-huinca> I tried it months ago, and it's curious to find another people who even has heard about
10:47:07 <tic> really?
10:47:14 <Philippa> Maddas: an old common UI standard, windows uses it or a variant
10:47:18 <Maddas> Ok
10:47:19 <tic> Bunch of my friends have known about it for years. :) 
10:47:24 <tic> Afterall, it's a pretty old language
10:47:27 <Maddas> jpgil-huinca: I think it's quite well known
10:47:29 <Philippa> cm: does it do alt-f s for save, stuff like that?
10:47:42 <cm> Ctrl-S for save
10:47:46 <cm> such stuff ;)
10:48:15 <cm> i think there was a link to it on cl-bookbook.sf.net
10:48:30 <Philippa> my problem is I can never be arsed to learn a UI really really thoroughly but I /do/ want access to all the nice stuff you can do with a scripted text editor
10:48:36 <jpgil-huinca> Maddas: surely, but in the circle that you are used to be.
10:49:01 <shapr> I've been thinking about an emacs-style editor with Haskell
10:49:05 <np_hard> emacs is just all right with me
10:49:07 <np_hard> emacs is just all right with me
10:49:08 <np_hard> emacs is just all right with me
10:49:08 <shapr> I should write down my ideas and get some  feedback
10:49:10 <np_hard> emacs is just all right with me
10:49:15 <shapr> emacs is not good enough.
10:49:36 <shapr> it's single threaded, it uses elisp, and it is in desperate need of refactoring
10:49:39 <np_hard> oh happy day ... when emacs washed all my vims away!
10:49:42 <basti_> indeed.
10:49:58 <Philippa> not to mention anything a user can end up having to kill from another prompt because they've forgotten how to close it has problems...
10:50:00 <shapr> I admit, emacs is my favorite editor, and I've been using it for many years, my .emacs is ~1400 lines long.
10:50:12 <np_hard> single threaded is fine
10:50:12 <cm> top 3 things you like about emacs?
10:50:16 <np_hard> it can spawn processes
10:50:41 <basti_> its all reconfigurable
10:50:45 <shapr> yah, that's the top thing
10:50:49 <shapr> that's everything actually
10:51:17 <shapr> emacs has a simple paradigm of windows, buffers, and point and mark
10:51:47 <shapr> emacs is an API, and the actual editor is written in elisp.
10:51:49 <cm> "simple" :O
10:51:58 <shapr> well, it's simpler than Java Swing
10:52:05 <shapr> try the EditorKit in there :-(
10:52:13 <shapr> it's powerful, but it's waay complicated.
10:52:27 <cm> a lot harder than the simple-stupid Ctrl-Tab i'm used to switch windows (or buffers?) ;)
10:52:33 <cm> hrm don't know that one
10:52:56 <shapr> so, emacs is the best editor I've ever used, and it's still not good enough.
10:53:16 <Philippa> cm: you can have multiple windows showing the same buffer, AIUI. Which has its uses
10:53:19 <shapr> first of all, documents *are* structured. They're not just buffers with lines.
10:53:38 <shapr> and I'm very interested in that structure.
10:54:10 <shapr> emacs has editor macros, where you record an action and replay it, you can even parameterize the replay
10:54:26 <ibid> emacs = editing macros :)
10:54:28 <shapr> I want parse tree macros 
10:55:03 <shapr> my dream editor uses incremental parsing to do syntax highlighting, indentation, and editor macros too.
10:55:25 <stefan_> I myself like emacs very much ... but for those interested in advanced structured editor might want to check out Martijn Schage's Proxima
10:55:28 <Philippa> shapr: if I ever have a spare year to do something for a laugh, will happily work on a usable parsing setup for it
10:55:28 <cm> my dream "editor" works on the AST of the language
10:55:35 <shapr> cm: exactly!
10:55:52 <np_hard> cm: isn't that semantic?
10:55:54 <np_hard> :)
10:56:00 <stefan_> Proxima does just that
10:56:06 <cm> np_hard: hm?
10:56:23 <shapr> Philippa: my plan at the moment is to make a parsing mode that works like epigram, where you have the text in one buffer, and you incrementally write the parser in the other buffer, and you immediately get to see changes.
10:56:28 <np_hard> http://cedet.sourceforge.net/info/semantic.html
10:56:57 <shapr> semantic is the right direction, but it's still an add-on for emacs, and it's not very fast or robust.
10:57:12 <stefan_> http://www.cs.uu.nl/groups/ST/Center/Proxima
10:57:23 * cm has a look at proxima
10:58:11 <Philippa> shapr: would be cool. I would probably wimp out and leave the user banging a refresh button regularly...
10:58:49 <shapr> well, the epigram sheds would work sort of like that.
10:58:56 <shapr> whenever you close a shed you see changes immediately.
10:59:34 * jpgil-huinca is bussy with #haskell-newbie issues.
10:59:42 <shapr> jpgil-huinca: like what?
10:59:46 <shapr> any questions I can help with?
10:59:57 <jpgil-huinca> Yes, now I've some regarding types
11:00:08 <shapr> Philippa: thing is, I have some ideas for a Haskell-emacs but not enough to make a coherent whole.. I need input and ideas.
11:00:21 <shapr> jpgil-cl: ask away!
11:00:23 <cm> shapr: braindump onto a wiki?
11:00:29 <cm> or is that "into"
11:00:30 <Philippa> shapr: yeah, similar here. Plus I need a GUI lib I'm confident I could build the thing on
11:00:34 <shapr> cm: good idea
11:00:50 <jpgil-cl> Here? I opened #haskell-newbie to don't stop the current conversation
11:01:03 <shapr> jpgil-cl: yes, this is #haskell-newbie as much as anyplace.
11:01:03 <Philippa> jpgil-cl: some of us can multitask :-)
11:01:10 <jpgil-cl> :)
11:01:13 <cm> [re above: for instance, hitting <ctrl-left arrow> wouldn't move the cursor a word (in the text sense) left, but move to the preceding entity in the AST (or the parent node, if none)
11:01:16 <Philippa> really, just ask away
11:01:22 <jpgil-cl> Well, I 've this function:
11:01:23 <shapr> feel free to jump in and talk about Haskell at any time
11:01:35 <jpgil-cl> -- Genera una línea diagonal
11:01:35 <jpgil-cl> -- Esto me dio varios problemas con los tipos [String], [[Char]], etc.!!!
11:01:35 <jpgil-cl> espaciosPrevios :: Int -> [String] -> [String]
11:01:35 <jpgil-cl> espaciosPrevios _ [] = []
11:01:35 <jpgil-cl> espaciosPrevios n (x:xs) = (replicate n " ") ++ x : "\n" :  (espaciosPrevios (n+1) xs)
11:01:36 <jpgil-cl> nestedList :: [a] -> [[a]]
11:01:38 <jpgil-cl> nestedList [] = []
11:01:40 <jpgil-cl> nestedList (x:xs) = [x] : nestedList(xs)
11:01:42 <jpgil-cl> generaDiagonal :: [Char] -> [Char]
11:01:44 <jpgil-cl> generaDiagonal str = concat (espaciosPrevios 0 (nestedList str) )
11:01:54 * jpgil-cl realizes that it's in spanish!! Do you need translation?
11:02:02 <shapr> as for pasting more than five lines of code, it's recommendet to use the paste page on the wiki.
11:02:35 <jpgil-cl> ok
11:02:38 <cm> given a good GUI framework, that might be cool..]
11:03:05 <Philippa> cm: right. I can't find a single GUI lib that does it all, even if I restrict myself to win32 only :-(
11:03:08 <jpgil-cl> then, in briefing: my trouble line is:
11:03:27 <cm> Philippa: yeah, so true :(
11:03:29 * jpgil-cl writes: prevSpaces n (x:xs) = (replicate n " ") ++ x : "\n" : (prevSpaces (n+1) xs)
11:03:53 <shapr> Philippa: I think it's better to have the GUI lib be swappable
11:03:58 <jpgil-cl> I want to pass a text, "hello world", for example
11:04:00 <cm> Philippa: and that is even if you don't restrict yourself to a specific language
11:04:09 <Philippa> shapr: IOW, we get to write our own on top of everybody else's - joy!
11:04:12 <shapr> then you can use the same editor with text mode, qt, gtk, win32, etc
11:04:18 <goron> shapr: This testing idea is pretty useful afterall :) I am now prery confident that I have a *bug-free* implementation. 
11:04:28 <shapr> goron: yes, I agree. Testing is a great thing.
11:04:33 <shapr> especially with something like QuickCheck.
11:04:47 <shapr> goron: the downside is that you can't use standard QuickCheck to do test-driven-development
11:04:54 <shapr> but, now you can!
11:04:57 <Philippa> shapr: sorry. I agree that if you're going to end up having to do it anyway you may as well make the interface clean so it can be swapped. I have some things in mind that might be hard to do in text mode though
11:05:00 <goron> shapr: :?
11:05:09 <jpgil-cl> but I can't do:   prevSpaces "hello world"    -- because type doesn't match.  
11:05:16 <Philippa> but yeah. GUI development is something I despair of whenever I want to do a proper job of it...
11:05:21 <Marvin--> shapr: I find that if you try to write something that has swappable gui, you get a program with several bad guis instead of one good gui
11:05:22 <shapr> for the special low-price of one download, you too can have the special edition of QuickCheck 2004!
11:05:43 <Philippa> jpgil-cl: where's the n?
11:05:46 <shapr> call the number at the end of this informercial, and you'll be instantly connected to our operators who are standing by!
11:05:51 <goron> shapr: You changed something to QuickCheck?
11:05:56 <shapr> actually yes
11:05:58 <Philippa> your prevspaces seems to take two parameters...
11:06:08 <jpgil-cl> yes, sorry.     prevSpaces 0 "hello world"  
11:06:10 <Marvin--> different UI toolkits don't just have a different look and feel, they usually have different development methodology
11:06:35 <shapr> Marvin--: ok, you've been drafted to give advice on the HEmacs project ;-)
11:06:35 <Philippa> OK. "Hello world" is a String not a [String]
11:06:35 <goron> shapr: Uh...What? And what's test-driven development by your definition?
11:06:53 <shapr> goron: sorry, just being silly. that was my imitation of an informercial.
11:07:04 <Marvin--> shapr: you wish, I'm not even an emacs user
11:07:12 <Philippa> Marvin--: me either
11:07:15 <shapr> goron: test driven development is where you write the test code before you write the code itself
11:07:23 <goron> shapr: Well, it was kinda funny, especially in the context of a few days ago on IRC.
11:07:34 <shapr> I've often seen the test code as a question, and the actual code as an answer.
11:07:38 <Philippa> thing is, I know HEmacs-with-good-GUI is what I want. I just prioritise good (or at least tolerable) UI over the scripting
11:07:42 <jpgil-cl> if it's a String, how can I add more text in the tail?  
11:07:44 <shapr> really? what few days ago context?
11:07:45 <goron> shapr: But why does QuickCheck doesn't support that?
11:08:03 <Philippa> jpgil-cl: a String is the same as a [Char]
11:08:04 <shapr> I guess because John Hughes didn't think of it.
11:08:10 <Philippa> bit of a gotcha that
11:08:25 <goron> shapr: I believe pesco said something about his command line parser..
11:08:36 <shapr> oh, neat :-)
11:08:45 <shapr> I do rather like pesco's sense of humor.
11:09:41 <goron> shapr: I mean it in a different way. As in what modifications did you made that you can say:"well mine support test-driven development".
11:09:44 <jpgil-cl> Thanks Philipa. I'll try to modify my function to use [Char] instead.
11:09:56 <shapr> I just hacked in something that saves the seed when the test fails.
11:09:58 <pesco> What's going on? (*waves*)
11:09:59 <jpgil-cl> ["\", "n"] instead of "\n"
11:10:17 <shapr> y0 pesco, I was just saying I like your sense of humor.
11:10:28 <Philippa> jpgil-cl: ["\","n"] is a [String]
11:10:36 <Philippa> " for strings, ' for characters
11:10:36 <pesco> Cool, thanks. :)
11:10:42 <goron> shapr: You mean some of the random instances?
11:10:49 <jpgil-cl> hey!! Thanks! That's what I need
11:10:51 <shapr> goron: you want a copy? It may have bugs etc, no one other than me has tried it.
11:11:03 <Philippa> of course, you could also try taking out the type signiatures and seeing if Haskell works out the right types for the lot?
11:11:03 <goron> shapr: And by saving you mean to disk?
11:11:08 <pesco> Erm, what was that talk about HEmacs?
11:11:09 <shapr> yes, to disk.
11:11:16 <np_hard> I don't think a text editor needs much of a gui
11:11:28 <shapr> I'm really not sure the to-disk saving I've done is the right way to do it, but at least it works.
11:11:33 <Philippa> np_hard: it doesn't, so long as you're using it very strictly as a text editor
11:11:42 <musasabi> shapr: add deductive logic programming and you can automatically generate code from your tests ;p
11:11:44 * jpgil-cl thanks everybody and go for lunch
11:11:44 <Philippa> me, I want to be able to build tree views when I want for example
11:12:05 <shapr> pesco: I was just complaining that all my years of emacs loving are leading me to abandon it for something better that doesn't yet exist.
11:12:12 <goron> shapr: And then you get one big file on which you test your application eventually. I think that's useful. But randomness helps a lot to. 
11:12:25 <goron> shapr: Where can you say that you want more than 100 tests?
11:12:31 <shapr> in the test configuration
11:12:39 <shapr> QuickCheck is shockingly simple
11:12:47 <shapr> I think it's less than 300 lines of code total.
11:12:50 <pesco> shapr: I've had the same feeling. And I've written a prototype text-editor in Haskell. I don't have it in use yet, though.
11:12:58 <shapr> pesco: oh oh, can I see?
11:13:00 <cm> it's shockingly haskell :)
11:13:01 <goron> shapr: I will check it. 
11:13:14 <pesco> shapr: Of course. Wait a second.
11:13:18 <shapr> QuickCheck is just so *elegant*
11:13:51 <shapr> I've been reading the 'Worse is Better' saga lately, and my current thoughts are that 'interface is everything'
11:14:04 <shapr> like, code tiling
11:14:13 <shapr> monads are tiled code
11:14:21 <pesco> shapr: Okay, i'm taring up the directory as-is. Don't stumble over the junk.
11:14:21 <goron> shapr: This one: check :: Testable a => Config -> a -> IO ()
11:14:38 <Philippa> shapr: interface can't help but be everything - it's not the components, it's the wiring
11:14:39 <shapr> goron: right, Config
11:15:01 <shapr> Philippa: right, so with a good enough interface, everything is simple
11:15:33 <tic> shapr, URL to the Worse is Better thingy?
11:15:41 <cm> peter gabriel thingy
11:15:46 <shapr> because interface and abstraction are all about comprehension
11:15:54 <cm> www.dreamsongs.com
11:16:00 <shapr> they're all about making it easy to reason about the code in front of you.
11:16:04 <goron> I don't thing "Worse is better". It does have some nice quotes as I said earlier...
11:16:14 <shapr> tic: http://www.dreamsongs.com/WorseIsBetter.html
11:16:17 <goron> thing->think
11:16:23 <shapr> goron: have you read his rebuttal?
11:16:29 <tic> shapr, thanks!
11:16:46 <shapr> Richard Gabriel changed his mind and wrote a paper that argued *against* 'Worse is Better'
11:16:56 <shapr> then he changed it back and argued *for* Worse is Better in the next paper.
11:17:02 <shapr> and then swapped again!
11:17:08 <Marvin--> ISTR that he changed his mind back and forth many, many times
11:17:15 <shapr> yes
11:17:31 <goron> shapr: I have no idea of what rebuttal should mean. The dictionary also doesn't know it.
11:17:34 <pesco> shapr: http://www.scannedinavian.org/~pesco/distfiles/hed-2004-08-21.tar.gz Watch out, it's 2MB.
11:17:43 <shapr> pesco: thanks!
11:17:52 <goron> Now I think I understand it.
11:17:54 <shapr> goron: it means a paper that refutes an argument
11:18:02 <shapr> gives counter-arguments, disagrees with
11:18:15 <goron> shapr: Is it correct English?
11:18:23 <shapr> Yes, it's a standard English word.
11:18:29 <shapr> @wn rebuttal
11:18:31 <lambdabot> *** "rebuttal" wn "WordNet (r) 2.0"
11:18:31 <lambdabot> rebuttal
11:18:31 <lambdabot>      n 1: the speech act of refuting by offering a contrary contention
11:18:31 <lambdabot>           or argument
11:18:31 <lambdabot>      2: (law) a pleading by the defendant in reply to a plaintiff's
11:18:33 <lambdabot>         surrejoinder [syn: {rebutter}]
11:18:50 <goron> shapr: You wrote that... That's not much of an argument ;)
11:19:00 <shapr> huh?
11:19:40 <Maddas>   @wn looks up things in a dictionary not created by shapr :-)
11:19:52 <shapr> oh
11:19:53 <shapr> heh!
11:20:10 <shapr> that's part of the dictionary module, which calls wordnet
11:20:34 <shapr> goron: that's funny, too bad I missed it the first time around :-)
11:21:05 <shapr> Marvin--: hey, which email can I use to put you onto the [iohcc] list?
11:22:05 <Marvin--> shapr: msjogren@gmail.com will do
11:22:13 <shapr> pesco: cool, comes with a Mach-O binary
11:22:22 <pesco> Oh yes. Mach-O man.
11:22:26 <pesco> :)
11:22:58 * shapr installs c2hs
11:23:13 <shapr> oh, I still haven't updated the c2hs deb
11:23:20 * shapr grumbles
11:23:26 <pesco> gotta go, see you!
11:23:33 <shapr> cya!
11:23:53 <shapr> hm, documented in German...
11:24:17 <basti_> ;)
11:25:03 <shapr> huh, this is pretty nifty
11:25:36 * shapr tries to install his own deb
11:25:48 <Marvin--> shapr: are you going to adopt c2hs?
11:25:53 <shapr> um
11:25:54 <shapr> ok
11:25:55 <shapr> sure
11:25:58 <shapr> how do I do that?
11:26:11 <Marvin--> well I don't even know if it's up for adoption, thus my question
11:26:30 <shapr> I emailed michaelw and asked him, he'd be happy to give it up.
11:26:47 <shapr> at least, I think that's what he said.
11:26:51 * shapr checks
11:27:44 <Marvin--> oh, if he's happy to give it up, then you just update the package, set yourself as maintainer and get a sponsor to upload it
11:29:19 * shapr looks suspiciously at ibid
11:29:41 <shapr> oh, I remember, I was going to update the standards-version
11:29:43 <Marvin--> I'd be happy to upload it for you
11:30:37 <shapr> ok, lemme check it over and see if I can update the standards-version without too much trouble, then I'll send it to you later this evening? Can you upload it tomorrow?
11:30:52 <Marvin--> if I have time to look through it
11:31:05 <Marvin--> I came way too close to having to do a ghc5 upload a few days ago, that was scary ;)
11:31:07 <shapr> I can send you what I have now, if you want to look through it.
11:31:09 <shapr> heh :-)
11:31:42 <Marvin--> sure, put the source package somewhere on the web and I'll have a look at it
11:31:47 <shapr> I just stole the debian/ dir from 0.12.something and hacked the Makefile and the control file to use ghc6 instead of ghc5
11:32:20 <Marvin--> (though I'm kinda distracted by the olympics, two potential Swedish gold medals... :)
11:32:32 <shapr> :-)
11:33:21 <Marvin--> What did Igloo mean with "Force dependency to be on ghc5 rather than any other ghc (doesn't get ghc6 dependencies right currently)." in the 0.12.0-1 changelog entry?
11:33:47 <Marvin--> Hrm. That should've been 0.12.0-0.1 since it was an NMU, bad Igloo :)
11:36:21 <Marvin--> Yay! Gold medal for Stefan Holm!
11:44:32 * Marvin-- pokes shapr
11:44:37 <shapr> eh?
11:44:38 <shapr> oh
11:44:46 <Marvin--> where'd you go? :)
11:44:53 <shapr> I don't have a .orig
11:45:00 <shapr> should it be generated from the Makefile?
11:45:07 <Marvin--> .orig is the upstream tarball
11:45:25 <shapr> I don't have any diffs except the debian/ dir
11:45:48 <Marvin--> you should probably read some packaging docs :)
11:45:54 <shapr> yes, I'm beginning to think so.
11:46:17 <shapr> I think I'll send you the source package tomorrow after I've read some docs :-)
11:47:57 <Marvin--> I think it's important that we figure out what Igloo meant with "Force dependency to be on ghc5 rather than any other ghc (doesn't get ghc6 dependencies right currently)." before we upload a version using ghc6
11:49:23 <shapr> ok, sounds good.
11:49:36 <shapr> for completeness, I should create a ghc5 version of c2hs as well.
12:03:01 * roconnor wishes he had a G-machine co-processor
12:03:54 <shapr> bah, spineless software!
12:04:13 * basti_ wishes he could use all the cycles his computer wasted by waiting for user input.
12:04:23 * shapr wishes his computer has uni-cycles.
12:04:23 <ibid> G-machine is not spineless, the spineless, tagless g-machine is :)
12:04:47 <ibid> (stg, that is)
12:05:45 <basti_> i find it amusing that the frequency of "X: Not in the dictionary. Add to dictionary." like pages in each google answer increases
12:21:50 <pesco> shapr: Oh, indeed, I wrote that in German. :/
12:22:20 <goron> shapr: I just found a dictionary that had it in Dutch :)
13:06:36 <Leimy> is there a better version of Haskell mode for emacs anywhere?
13:07:02 <stepcut> no
13:07:54 <Leimy> vim seems to do pretty well with it
13:09:09 <jadrian> Leimy: what does the vim mode has that emacs does not?
13:09:12 * np_hard wonders what it would take to make a better version of haskell-mode
13:09:29 <Leimy> jadrian: It seems to get the indenting done a little better
13:09:38 <Leimy> but perhaps I am misusing the emacs mode
13:09:56 <jadrian> np_hard: in my case some knowledge of elisp :)
13:10:04 <np_hard> emacs just cycles through possible tab locations
13:10:13 <np_hard> if you don't like the indent, hit tab again
13:11:04 <jadrian> I really like (X)emacs capabilities, but I just hate the way it looks :-/
13:11:21 <Lor> (x)emacs can look like anything you want it to.
13:11:36 <jadrian> Lor: do you have any good tips for nice fonts?
13:12:00 <Lor> It all depends on so many things.
13:12:04 <np_hard> bitstream-vera-sans-mono
13:12:06 <np_hard> or clean
13:12:12 <np_hard> depending on what size you want
13:12:22 <np_hard> fixed isn't bad either
13:12:33 <jadrian> do you have anti-aliasing?
13:12:36 <np_hard> Courier is ugly, I dunno why it is the default
13:12:49 <np_hard> I do, but that's not saying much because I use the Carbon build for OS X
13:12:57 <Leimy> np_hard: ditto
13:13:02 <Leimy> I build it from CVS normally
13:13:09 <np_hard> me too
13:13:22 <Leimy> looks a bit like GTK these days icon-wise
13:13:42 <jadrian> Bitstream vera looks horrible in my xemacs...
13:14:08 <np_hard> I turn off icons
13:14:10 <jadrian> default font in default size is the only acceptable one
13:14:23 <pesco> np_hard, Leimy: Do your emacsen display non-ASCII characters correctly?
13:14:34 <jadrian> but I know next to zero about fonts and customizing xemacs
13:14:34 <Leimy> good question
13:14:37 <np_hard> jadrian: lucida typewriter, then
13:14:37 <Leimy> I don't think it does
13:14:47 <np_hard> pesco: no, I don't believe so
13:15:03 <np_hard> at least posts I read in GNUS from foreigners have a lot of boxes in them
13:15:10 <jadrian> np_hard: really they look like crap
13:15:12 <pesco> Gah.
13:15:21 <jadrian> np_hard: something must be very wrong here :/
13:15:25 <Leimy> np_hard: yep
13:15:46 <Lor> jadrian, this is what my xemacs looks like currently: http://www.cs.helsinki.fi/u/lealanko/ss/ss20040822.png
13:16:10 <jadrian> damn
13:16:17 <jadrian> those fonts look great
13:16:32 <jadrian> let me try and upload some screenshots of my own...
13:16:41 <np_hard> here is mine
13:17:39 <np_hard> ah nm, I have no web space
13:17:39 <np_hard> :)
13:17:47 <Leimy> http://homepage.mac.com/leimy2k/emacs.png
13:18:22 <Lor> That seems like quite a basic configuration for a modern gnu emacs.
13:18:28 <Leimy> yeah :)
13:18:40 <np_hard> Lor's fonts are not AA, jadrian
13:18:41 <Lor> It even has antialiasing? Wow.
13:18:47 <np_hard> try using fixed.
13:18:48 <pesco> "the GNU operating system"
13:18:50 <Riastradh> Carbon Emacs does, Lor.
13:19:04 <jadrian> np_hard: they still look quite good
13:19:10 <Lor> Yeah, my font is the very very basic fixed 10x20.
13:19:12 <jadrian> I'd like to use smaller fonts though
13:19:14 <np_hard> yep, 'cause they're not courier :)
13:19:16 <np_hard> clean
13:19:17 <np_hard> use clean
13:19:26 <jadrian> I really like the way Kate looks (KDE)
13:19:34 <np_hard> I use it at work to get two 80x40 windows on a 1024x768 screen
13:19:35 <Lor> I tend to use just 10x20, lucidatypewriter, and some helvetica.
13:20:04 <np_hard> (vertical split)
13:22:49 <np_hard> that's schumacher-clean
13:24:55 <np_hard> size 12 is what I have for schumacher-clean at wor
13:24:56 <np_hard> work
13:26:38 <jadrian> http://www.mat.uc.pt/~jadrian/
13:26:45 <jadrian> check those screenshots...
13:26:52 <jadrian> IMO Kate looks great
13:27:06 <Leimy> I didn't know Kate had a Haskell mode
13:27:07 <jadrian> and from the xemacs screenshots only the default is acceptable
13:27:14 <Leimy> nice
13:27:22 <jadrian> There are 2 haskell syntax highlight modes for haskll
13:27:50 <jadrian> the default one doesn't work with LaTeX litterate style 
13:28:01 <Leimy> ah
13:28:13 <jadrian> (I just used non-litterate Haskell mode for the screenshot as you can see)
13:28:22 <jadrian> but the other one available at Haskell.org does
13:28:32 <Lor> For literate programming, use mmm-mode.
13:28:43 <jadrian> I don't like it
13:29:20 <jadrian> I rather set up keys for LaTeX and Haskell modes
13:29:54 <jadrian> because it's annoying to have the syntax highlight changing each time your cursor moves over a comment section
13:30:52 <jadrian> did you see the bitstream screenshot?
13:30:57 <jadrian> quite bad isn't it?
13:31:03 <flaw> yuck, misc-fixed 18 is the only font to use :P
13:31:18 <Lor> jadrian, huh? The syntax highlighting doesn't change anywhere.
13:31:31 <jadrian> Lor: maybe I don't know what mmm is :)
13:31:44 <jadrian> Lor: isn't that the multi mode mode?
13:31:48 <jadrian> or something like that?
13:32:04 <jadrian> that changes emacs mode according to context?
13:32:06 <Lor> Yeah, but it's the advanced version. It doesn't change the mode of the whole buffer.
13:32:12 <jadrian> Oh
13:32:22 <Lor> It keeps differently-moded fragments in separate logical regions.
13:32:24 <jadrian> but still
13:32:48 <jadrian> when I'm editing my Haskell code I like the LaTeX to be grayed out
13:32:59 <jadrian> and same for LaTeX editing
13:33:26 <jadrian> (blued out in this case :)
13:34:27 <Lor> Well, suit yourself.
13:36:56 <PeterE> Lor: What Emacs package are you talking about?
13:37:25 <Lor> mmm-mode
13:37:38 <Lor> mmm-mode.sf.net
13:50:03 <PeterE> Lor: Ok, thanks.
14:33:51 <goron> I still think someone just should make an app with haskell plugins, where *everything* is configurable. The plugins will probably make it a success. I think there's even a market for it...
14:35:39 <Leimy> what would this app do?
14:38:41 <ibid> who cares? as long as it is an app with haskell plugins
14:38:42 <ibid> :)
14:38:52 <Leimy> sounds like Hugs 
14:38:57 <ibid> heh
14:38:58 <Leimy> or ghci
14:39:05 <Leimy> I mean... isn't that basically what smalltalk was
14:39:13 <Leimy> a gui that you could run smalltalk programs in
14:39:36 <Leimy> so what you'd have is a Haskell VM
14:39:37 <ibid> i think emacs would be a more appropriate analogy
14:39:48 <Leimy> sure
14:39:55 <Leimy> it's an environment for executing emacs-lisp
14:39:58 <Leimy> or something like that
14:40:01 <goron> An editor...
14:40:29 <Leimy> an emacs-like Haskell editor would be neat
14:40:34 <goron> With pluggable parser, type checker...
14:41:02 <goron> automatic tester...automatic correctness prover...
14:41:22 <Leimy> semi-automatic handgun
14:41:24 <ibid> emacs is a lisp interpreter that is prepackaged with an editor and marketed as an editor ;)
14:41:24 <Leimy> oh wait
14:42:10 <goron> Well, you get the idea...
14:42:31 <Leimy> yeah
14:42:37 <Leimy> Haskell-OS :)
14:43:00 <Leimy> Inferno is like a giant Limbo system in some ways
14:43:21 <stepcut> hOp
14:44:34 <Leimy> http://www.webster-dictionary.org/definition/Yale%20Haskell
14:52:04 <Leimy> sounds like they wanted to head down that road but still used Emacs
14:53:03 <pesco> Were they compiling to LISP?
14:54:09 <Leimy> it was controlled by an inferior emacs mode
14:54:23 <Leimy> or process I should say
14:55:09 <Leimy> it did/does have a foreign function interface to call lisp or C
14:55:29 <goron> stepcut: The guy developing hOp didn't update his webpage for a long time.
14:55:47 <stepcut> :(
15:06:33 <goron> Does anyone knows of a place where I can see how a bufferoverflow *exactly* works? Thus, with an example unsafe program and with an exploit? A minimal example would be best ofcourse.
15:21:16 <shapr> goron: the guy developing hOp is here on #haskell
15:21:49 <shapr> goron: there are some excellent guides to buffer overflows in some of the phrack issues
15:27:16 <goron> shapr: What's his screenname?
15:27:27 <shapr> Lunar^: 
15:27:30 <goron> shapr: phrack? website?
15:27:41 <shapr> phrack is something you should look up :-)
15:27:54 <goron> shapr: ok, I am just lazy...
15:28:03 <goron> shapr: He, I use Haskell...
15:28:08 <goron> :)
15:28:11 * shapr laughs
15:28:21 <shapr> Lunar^: bonjour, comment Ã§a va?
15:28:24 <goron> http://www.collusion.org/Article.cfm?ID=176
15:28:30 <Lunar^> shapr: Ça va :)
15:28:31 <goron> This is also a nice article.
15:28:45 <shapr> bonne nuit
15:29:02 <shapr> wassup?
15:30:24 <goron> Lunar^: Why are you making hOp? Is it intended to be used by Haskellers in one year, and within 5 years by the world, or is it just playing with the RTS?
15:30:44 <shapr> Lunar^: any word on university?
15:31:46 * shapr bounces
15:32:41 <Lunar^> shapr: no :(
15:32:53 <shapr> I hope it happens.
15:32:53 <Leimy> I thought it was pretty clear that hOp was for experimenting with writing device drivers in Haskell
15:33:06 <Lunar^> goron: I'm not working on it right now
15:33:06 <shapr> I thought hOp was for being nifty.
15:33:10 <Leimy> :)
15:33:22 <Leimy> Well I thought it was the haskell analog to preScheme or something
15:33:39 <shapr> Lunar^ told me he booted hOp on real hardware recently.
15:33:42 <shapr> that's nifty
15:33:46 <Leimy> that is indeed
15:33:52 * Leimy has to run to the grocery store
15:33:57 <Lunar^> hOp is free software, so it can be what ever people want it to be
15:33:58 <goron> Leimy: Yes, that's clear. But what's the use of writing a device driver for an OS that no one uses?
15:34:11 <shapr> for teaching
15:34:13 <Leimy> goron: proof of concept that Haskell can be used in device drivers
15:34:23 <Leimy> then you could do stuff like stick it in Set top boxes
15:34:27 <Leimy> or embedded systems
15:34:28 <shapr> I suspect a pure FP device driver would be much easier to read.
15:34:31 <Leimy> that would be very neat :)
15:34:37 <Leimy> and probably easier to maintain
15:35:08 <shapr> I wonder if space leaks would cause problems with embedded Haskell.
15:35:10 <Lunar^> But I should not talk about it, it gets on my nerves thinking about what I should be doing instead of this damn job
15:35:19 <Leimy> Lunar^: hehe :)... Understood
15:35:19 <goron> Leimy: Ok, so it's meant to be a proof of concept? Are you paid for it?
15:35:24 <shapr> Lunar^: it's okay, hOp is cool.
15:35:30 <Leimy> goron: ??? paid?
15:35:38 <Leimy> what the heck does getting paid have to do with it
15:36:29 <Leimy> my use of proof-of-concept isn't saying it's low quality software
15:36:38 <goron> Leimy: Ok, it's a university...
15:36:51 <Leimy> what's this it?
15:37:07 <goron> Leimy: http://www.macs.hw.ac.uk/
15:37:11 <Leimy> I am not sure where you are going with this :)
15:37:29 <Leimy> I think it's interesting stuff.
15:37:35 <shapr> me too
15:37:44 <shapr> one day I'll get around to writing a TCP/IP stack for hOp
15:37:53 <goron> Well, I wanted to know how much time you/anyone will invest in it. 
15:37:53 <Leimy> Someone did a version of that Io language on L4 microkernels
15:38:04 <Leimy> I think it might be cooler to move hOp to Pistachio
15:38:10 <shapr> what's pistachio?
15:38:13 <Leimy> then you can support all the hardware Pistachio supports in one shot
15:38:28 <shapr> oh, I found it
15:38:29 <Leimy> Pistachio is an implementation of L4 for PowerPC, SPARC, Alpha, x86, AMD64, ARM etc etc
15:38:32 <Leimy> :)
15:38:56 <Leimy> and if you can get something like hOp on it... you could have a lot of hardware support by only coding to the L4 APIs
15:39:08 * Leimy notes linux 2.4 is ported to L4
15:39:16 <Leimy> and Linux treats it kind of like a CPU architecture
15:39:35 <Leimy> so IoL4 [you should be able to find it] is taking advantage of that too.
15:39:51 <Leimy> http://www.iol4.com/
15:40:21 <goron> Leimy:How much time have you planned to invest in it?
15:40:22 <Leimy> oh it does MIPS too I guess :)
15:40:32 <Leimy> goron: 0 time planned to invest in it
15:40:38 <Leimy> I just think it would be an interesting direction
15:40:42 <Leimy> at least no time this year
15:40:48 <Leimy> I've got a backlog of other stuff to do
15:40:56 <Leimy> L4 is one of them... stuff on L4... not sure yet :)
15:41:36 <goron> Leimy: But you are the sole developer (just to get things straight)?
15:41:50 <Leimy> goron: I'm not an L4 developer
15:41:53 <Leimy> I am just learning  :)
15:42:01 <Leimy> I actually don't get paid to do any of this stuff
15:42:06 <goron> Leimy: Of hOp I mean.
15:42:11 <Leimy> I don't work on hOp
15:42:14 <Leimy> I just think it's cool
15:42:15 <Leimy> :)
15:42:18 <goron> Me too
15:42:22 <Leimy> I think you mean Lunar^ 
15:42:34 * goron is confused.
15:42:35 <Leimy> I think hOp on L4 would be REALLY cool :)
15:42:52 <Leimy> goron: howso?
15:43:01 <goron> Leimy: not anymore
15:43:08 <Leimy> I am just a person learning to use Haskell and beginning to write serious code with it :)
15:43:17 <Leimy> I am also trying to learn Lisp and Scheme
15:43:35 <Leimy> I've spent most of my life dealing with C/C++, Python, Perl and other junk
15:43:44 <Leimy> and I like the "fresh perspective" of FP
15:44:42 <goron> Leimy: Lisp is something I would like to be able to do, but if I see sourcecode, I have to puke. 
15:44:46 <Leimy> hehe
15:44:52 <Leimy> It's better than reading XML IMO :)
15:44:59 <jesse98> have you looked at Clean Leimy?
15:45:05 <Leimy> jesse98: I've heard of Clean
15:45:12 <Leimy> and Mercury
15:45:17 <Leimy> and plan to play with those too
15:45:18 <goron> Yes, there are also XML based languages. They kill eyes...
15:45:20 <Leimy> but no time :)
15:45:22 <jesse98> seems more practical for real work than haskell
15:45:43 <Leimy> jesse98: what makes you come to that conclusion?
15:46:00 <Leimy> everyone has a favorite... some folks still like ML :) 
15:46:08 <goron> Leimy: No unicode support, no IDE..., not a lot of libraries..
15:46:13 <jesse98> it's type system is more powerful and uniqueness typing seems more flexible than monads
15:46:21 <roconnor> !
15:47:00 * roconnor ponders suspending reading about lazy functional compilers to read about this ``uniqueness types'' thing
15:47:03 <Leimy> goron: you are referring to Haskell?
15:47:32 <Leimy> main = "Hello World"
15:47:41 <Leimy> for Clean
15:47:48 <Leimy> oops
15:47:52 <Leimy> Start = "Hello World"
15:48:51 * roconnor wonders how uniqueness types could be more flexible than monads.
15:52:12 <Leimy> http://www.cs.kun.nl/~clean/CleanExtra/report20/chapter9/s91.html
15:53:46 <Leimy> interesitng
15:55:36 <stepcut> well, uniqueness checking would require an addition to the haskell type system, whereas monads are built within the existing type system with some syntatic sugar. 
15:56:30 <stepcut> in many ways, I don't think you can have a uniqueness types vs monads debate, because they are solving different problems, and you can be used together...
15:57:21 <stepcut> it just happens that both are good for solving certain types of problems (like IO)
15:57:55 <Leimy> on the surface, it's not clear to me that this is necessarily better than Monads.  It might make it easier to express some programs
15:58:15 <Leimy> I was just reading about State Monads earlier today
15:58:27 <Leimy> those seem damned convenient for many possible applications
15:58:51 <Leimy> Hudak uses em for an Imperative "robot" language
15:59:04 <jesse98> well, i don't understand monads or unique types well enough yet to have a truly informed opinion, but unique types seem like a very natural way to allow arbitrary state changes without affecting refeential transparency
15:59:11 <roconnor> I've been reading about how to compile functional programs:  Monads would've make the code much more clear ;-)
15:59:41 <roconnor> for suitable definitons of clear.
15:59:46 <stepcut> right, I think it is wrong to say uniqueness types are better than monads, or vice versa, but it is appropriate to say 'it is easier to express a solution for this task using uniqueness types instead of monads'
15:59:47 <Leimy> heh
16:00:02 <Leimy> that's what I'm getting at :)
16:00:12 <Leimy> just like it's sometimes easier to write a program in bash shell than in C
16:00:13 <Leimy> :)
16:00:38 * Leimy is a firm believer in "tools" development
16:00:51 <jesse98> do monads work well when interfacing to functions written using a foreign (and imperative) language?
16:00:54 <Leimy> I don't think you can always take "technology A" and glue it to "problem space B" and get a good solution :)
16:01:22 <TheHunter> so,... can you fake uniqueness types in haskell?
16:01:31 <Leimy> good question
16:02:12 <TheHunter> i think even arrows are not quite suitable, since you can always do fork = arr (\x -> (x,x))
16:02:13 <stepcut> TheHunters: yes, but the type checker won't tell you if you made a mistake
16:02:30 <roconnor> Type attributes.
16:02:33 <roconnor> :-(
16:03:35 <stepcut> In any case, I believe the primary reason haskell does not have uniqueness types is because nobody wants to do the work :p
16:04:08 <jesse98> well, i dont know that it makes sense for a language to have both unique types and monads
16:04:42 <TheHunter> jesse98: it definitely makes sense, though it maybe doesn't make sense to use both for IO
16:04:46 <stepcut> When I asked a few years ago, the excuse was 'the type checking code is already to hard to work with, we don't want to make the problem worse just for uniqueness types'
16:05:19 <stepcut> so.. maybe the code is easier to work with now =)
16:05:48 <roconnor> *l*
16:09:36 <stepcut> I am not sure what benefits you would get from adding uniqueness types to haskell though (besides being able to use them)
16:11:55 <stepcut> Or to state things differently, given the limited resources for haskell development, I would rather have better records than uniqueness types
16:20:36 <TheHunter> uniqueness types are strange. For almost any feature of any programming language out there, you can find a haskell equivalent (it might be painful, but usually, it's quite elegant). But I don't see any way to fake uniqueness types in haskell, which is disturbing from a theoretical point of view, because it suggests haskell isn't general enough to deal with certain kinds of problems.
16:22:14 <jpgil-cl>  isn't haskell Turing-complete then?
16:22:25 <np_hard> naturally it is
16:22:36 <np_hard> TheHunter is just getting worked up over nothing :)
16:23:15 <jpgil-cl> so, *any* kind of problems can be solved if it can be solved in a pure Turing way, if I'm not wrong
16:23:16 <jesse98> assembly is turing complete too, but that doesnt mean haskell is worthless...
16:23:38 <roconnor> It means is that there is not way to prevent data from being used more than once in a lambda term.
16:23:40 <np_hard> uniqueness types are not an expansion of the generality of expression in a language
16:23:46 <np_hard> they are a restriction
16:24:05 <roconnor> np_hard: Well put
16:24:12 * stepcut agrees with np_hard
16:24:18 <jesse98> but they're a restriction that allows you to introduce controlled side-effects/state changes
16:25:32 <stepcut> back in the good old days, IO in haskell used to be done clean-style, except without the help of the uniqueness type-checker...
16:25:33 <np_hard> nothing is preventing you from programming that way
16:25:34 <roconnor> I'm not convinced from what I just read about uniqueness types that they would be very good for controlling state changes.
16:26:44 <ozone> one problem with uniq types is that you need to annotate your code with them
16:26:57 <ozone> it would be far cooler if you didn't need to
16:29:04 <np_hard> personally I can't see what I would use uniqueness types for, myself
16:31:24 <stepcut> I can see how uniqueness types (especially if automaticly infered) could be useful from an optimization standpoint -- because its lets you know when destructive updates can be done instead of copying (like in array updates), but...
16:33:09 * roconnor wonders if array updates could be handled by copy on write.
16:33:10 <stepcut> but I would expect that to be transparently by the compiler -- not something I would explicitly see (similar to how the compiler currently does strictness checking, which *can* be controlled by the user, but almost never is)
16:35:17 <TheHunter> you are probably right, uniqueness types don't add any expressiveness to the language (except for io, maybe)
16:35:56 <Riastradh> Uniqueness types permit you to use an entirely different algorithm that the compiler probably couldn't deduce.
16:42:05 * jpgil-cl comes with anoter basic question:
16:42:29 <jpgil-cl> In patterns, why this is invalid sintaxis?     myDivide (x:x:xs) = x : '\n' : x : xs
16:43:00 <jpgil-cl> (I want to catch when I've 1st and 2nd elements equal)
16:43:06 <Pseudonym> You can't have repeated variables on the left-hand side.
16:43:09 <Pseudonym> Do this instead:
16:43:19 <Pseudonym> myDivide (x1:x2:xs) | x1 == x2 = ...
16:43:33 <jpgil-cl> ok, using guards.
16:43:37 <Pseudonym> Right.
16:43:47 * stepcut only knows of one language that allows myDivide (x:x:xs) =...
16:43:55 <Pseudonym> Me too.
16:44:11 <stepcut> Q?
16:44:16 <Pseudonym> Miranda.
16:44:26 <Riastradh> What about Prolog & Mercury?
16:44:27 <stepcut> hrm, well, I guess there are atleast 2 then :p
16:44:33 <stepcut> 4...
16:44:37 <Pseudonym> Prolog & Mercury look nothing like that.
16:44:42 <jpgil-cl> I'm making assignments (for personal enjoyment) and trying to write in both ways: guards and patterns, just to learn.
16:44:47 <Pseudonym> They use "." or "[|]" for list syntax.
16:44:58 <Riastradh> Well, yes, but...uh, never mind, the principles are rather different.
16:45:01 <Pseudonym> stepcut: What was yours?
16:45:05 <stepcut> Q
16:45:08 <Pseudonym> Ah.
16:45:51 <stepcut> http://q-lang.sourceforge.net/
16:46:07 <Pseudonym> Is Q lazy?
16:46:37 <stepcut> which, btw, turns out to be any annoying program to have installed, because if you hit q <enter> two many times to exit a program, you will end up in the q interpreter
16:46:50 <Pseudonym> Good point.
16:47:06 <Pseudonym> OK, Q is lazy.  Doesn't have (==) implemented as a typeclass, though.
16:48:20 <stepcut> how did you figure that out so fast ?
16:48:22 * jpgil-cl is in love with Helium, what a great error messages! It's truly for lazy students
16:48:38 <Pseudonym> I looked at the page, saw there was some source code for the infinite stream of primes.
16:48:41 <Leimy> Helium will make you talk funny though
16:48:42 <stepcut> ah
16:49:04 <Pseudonym> A quick inspection of the source reveals code that would only work if it was lazy.
16:49:05 <Leimy> Riastradh: adding a symlink for libreadline-5.0 worked by the way
16:49:08 <Leimy> oops wrong channel!
16:49:29 <Pseudonym> So like I said, she was dead when I got there.  Complete misunderstanding.
16:49:32 <Pseudonym> Oops wrong channel!
16:49:41 <Leimy> hehe
16:49:51 <jpgil-cl> Oh, another Helium user.
16:49:57 <Leimy> just cuz you have sex with someone doesn't mean you like em....
16:50:00 <Leimy> oops wrong channel
16:52:39 * roconnor drools over the G-machine.
16:54:35 * Pseudonym really, really hopes that was intended for another channel too
16:54:58 <roconnor> sorry
16:55:14 <roconnor> First time I've seen how to take functional code and make it look like assemby code.
17:04:04 <jpgil-cl> Mmm, defining patterns seems to be sequential in Helium. It is true in Haskell language itself?
17:27:21 <eshu> it is. two different patterns can match the same value, so order is significant.
17:38:55 <shapr> dude, as if.
17:41:16 <eshu> me?
17:41:24 <shapr> er, sorry EWRONGCHAN
17:41:34 <eshu> oh
17:41:45 <Pseudonym> Yeah, we get a lot of that around here.
17:42:27 <shapr> I keep forgetting just how intellectual this irc channel is... then I spend some time with the first-person shooter players.
17:42:42 <shapr> I swear those guys have nothing above their overdeveloped cerebellums.
17:42:49 <shapr> just empty space.
17:43:31 <Pseudonym> Ugly bags of mostly water.
17:43:55 <shapr> I keep expecting these children to know something about computers, since they use them so much.
17:44:25 <shapr> the most common urban legend is that a player with a high ping increases the ping of every other player as well.
17:44:43 <shapr> so players with a high ping get voted out
17:45:46 * Pseudonym has no clue what you're talking about
17:45:58 <shapr> ever played doom, quake, etc?
17:46:05 <Pseudonym> The most common urban legend I've heard is the psycho with the head on top of the car.
17:46:20 <shapr> the gaming culture is seriously weird.
17:46:26 <Pseudonym> Ah, OK.
17:46:37 <Pseudonym> Yes, I've played games like that, but not multi-player online thingy.
17:47:11 <shapr> well, if you have a high ping, you get voted out. I've tried to reason with these people, and explain that it's not synchronous software, but no one listens.
17:47:51 <stepcut> shapr: :p
17:48:05 <shapr> lots of crazy stuff too, they make up explanations of what the in-game scripting console commands do, and then these explanations are gospel.
17:48:19 <stepcut> haha
17:48:20 <shapr> for example, pb_security 0 supposedly download the older version of punkbuster to your computer.
17:49:01 <shapr> I've tried to explain that punkbuster has a high security feature where servers with older versions get dropped, because there are known cheats that get around those older versions, but no one believes me.
17:49:18 <shapr> anyway, you can disable that older version rejection temporarily with pb_security 0
17:49:30 <shapr> it's bizarre.
17:49:58 <shapr> I wonder if this is how Cargo Cults get started.
17:50:05 <stepcut> heh
18:00:02 <cptchaos> hm, in rpm of ghc 
18:01:20 <cptchaos> in "/usr/lib/ghc-6.2.1/hslibs-imports" all important files are missing, so I can't use package util
18:01:35 <cptchaos> does anyone know a quik fix?
18:01:41 <stepcut> use debian ?
18:02:07 <cptchaos> quite quick, but not quick enough
18:03:08 <stepcut> hrm, you don't have to install debian, just create a debian chroot :p
18:03:28 <cptchaos> ;-) 
18:03:56 <stepcut> atleast, that's what I do when I need to install software on redhat machines...
18:04:30 <cptchaos> really? sounds a bit odd
18:04:47 <stepcut> perhaps, but it has its advantages 
18:05:36 <cptchaos> hm I will try to search the files in the source distribution, and copy manually ...
18:06:10 <stepcut> the fact that they are running redhat at all indicates that I am not the sys admin for the machine... So by installing all the software I need in a chroot, I don't don't screw up the machine and make the sys admin unhappy :)
18:08:15 <cptchaos> hm, I have a fedora core system ,because my gentoo was getting to big for my laptop
18:13:12 <juhp> cptchaos: which ghc rpm are you using?
18:13:48 <juhp> I see 
18:13:50 <juhp> % rpm -ql ghc|grep hslibs-imports/ |wc -l
18:13:50 <juhp> 141
18:14:37 <cptchaos> 133
18:15:59 <Leimy> anyone ever try to use the SOEGraphics package Hudak did for the Hugs interpretter on GHCi on Mac OS X
18:21:32 <cptchaos> got it, misinterpetated the documentation had the wrong module name
18:22:41 <cptchaos> the files are actually there, I just didn't saw them 
18:22:52 <juhp> cptchaos: I'm using the rpm from haskell.org/fedora btw
18:24:25 <cptchaos> juph: cool thanks
18:58:49 <Leimy> hmmm
18:59:18 <Leimy> I tried to write  a wordcounter in Haskell really quick and it displays the result in the interpreter but not when compiled
18:59:35 <Smerdyakov> The interpreter evaluates expressions for you.
18:59:45 <Smerdyakov> A compiled program probably needs a main function of IO ().
19:00:01 <Leimy> main = do interact wordcount
19:00:18 <Leimy> I don't want "do" I bet
19:00:21 <roconnor> @type interact
19:00:23 <lambdabot> interact :: (String -> String) -> IO ()
19:01:20 * roconnor thinks the do shouldn't matter, but should be removed for clairity.
19:01:56 <Leimy> http://paste.lisp.org/display/2476
19:02:55 <roconnor> seems like the code ought to print something.
19:03:05 <Leimy> I wonder if my prompt is overwriting it
19:03:09 <Leimy> since there may be no newline
19:03:25 <roconnor> maybe
19:03:33 <Leimy> yeah
19:03:35 <Leimy> that was it 
19:03:37 <Leimy> D'oh!
19:03:38 <roconnor> pipe the output to a file.
19:03:40 <roconnor> oh
19:03:41 <Leimy> yeah
19:03:46 <Leimy> I added do back in
19:03:51 <Leimy> and a putStrLn ""
19:03:56 <shammahs> Leimy, btw, you are going to want to strip leading whitespace ;)
19:04:09 <Leimy> nah... I was just wanting to play with "interact"
19:04:14 <Leimy> it's not a serious program :)
19:04:36 <Leimy> but you are right
19:04:39 <shammahs> and each time you find a word you'll need to strip leading whitespace again.  Otherwise "     " counts as 5 words instead of 
19:04:49 <Leimy> right
19:05:01 <Leimy> it's really not counting words
19:05:01 <shammahs> and "   a   b   " counts as 9 instead of 2.
19:06:38 <Leimy> yep...
19:07:17 <Leimy> what I really want is to reflect state changes in the stream between whitespace and non-whitespace
19:07:50 <Leimy> and make sure the initial state is whitespace
19:07:57 <Leimy> that way the first transition should be the first word
19:08:28 <Leimy> but interact is pretty cool :)
19:08:32 <Leimy> and that's what I wanted to look at :)
19:34:34 <Leimy> is there a difference between "data" and "newtype" ?
19:35:23 <Pseudonym> Yes.
19:35:28 <Pseudonym> One of them starts with a "d".
19:35:38 <Leimy> how about semantically ?
19:35:39 <Pseudonym> There are also additional differences.
19:36:01 <Pseudonym> Newtype can only be used to define one data constructor with one argument.
19:36:15 <Pseudonym> data Foo = Foo Int Int   -- OK
19:36:23 <Pseudonym> newtype Foo = Foo Int Int   -- Not OK
19:36:33 <Pseudonym> newtype Foo = Foo (Int,Int)   -- Fine.
19:36:51 <Pseudonym> In addition, any constructor made with "newtype" is effectively unlifted.
19:37:01 <Leimy> I see
19:37:03 <Pseudonym> newtype C a = C a
19:37:08 <Leimy> it allows for extra optimization too it seems
19:37:09 <Pseudonym> C bottom == bottom
19:37:11 <Pseudonym> Right.
19:37:13 <Riastradh> data Foo = Foo Int | Bar Char    -- OK
19:37:20 <Riastradh> newtype Foo = Foo Int | Bar Char -- Not OK
19:37:29 <Pseudonym> Basically, you can think about it as meaning any data constructor which can be compiled away.
19:37:31 <Smerdyakov> data data data hi hi hi -- Maybe OK
19:37:45 <Leimy> yeah... cool stuff :)
19:38:35 <Pseudonym> The reasons for its existence are 1) you can't define typeclass instances on type synonyms, and 2) to get around the occurs check.
19:38:48 <Pseudonym> type Foo = Int -> Foo    -- Not OK
19:38:58 <Pseudonym> newtype Foo = Foo (Int -> Foo)   -- Works fine
19:39:17 <Pseudonym> type Synonym = {- something -}
19:39:30 <Pseudonym> instance Class Synonym where -- Not OK
19:39:38 <Pseudonym> newtype Synonym = Synonym {- same thing -}
19:39:43 <Pseudonym> instance Class Synonym where -- Works fine
19:40:20 <Pseudonym> Lunch.
19:40:40 <Leimy> I see
20:19:31 <stepcut> I can never decide between: multiWordIdentifier and multi_word_identifier, so then I end up using both styles intermixed :(
20:20:06 <stepcut> maybe I should just use one letter identifiers from now on
21:56:40 <Pseudonym> Yay, TPS reports.
21:56:46 <Pseudonym> And I did get the memo about the new covers.
21:57:34 <stepcut> bah, css sucks
21:59:06 * jpgil-cl is a cascade style sheet evangelist, by the way
21:59:31 <Pseudonym> Many existing CSS implementations suck.
21:59:39 <jpgil-cl> I agree
22:02:57 <stepcut> I have a div, and in the div I want it too look something like [<- back     photo 1 of 10     forward ->], ie, back and forward at the edges, and 'photo 1 of 10' centered. However, in the event that '<- back' or 'forward ->' is not present, I don't want the position of the other two elements to move
22:04:12 <jpgil-cl> visibility: hidden
22:04:25 <stepcut> yeah, that is the best hack I can come up with
22:06:24 <jpgil-cl> but, in your specific example it's needed javascript to actually rotate pics. So, you can use buttons and set "disabled=true", that is semantically more correct.
22:06:54 <stepcut> there is no javascript...
22:08:17 <jpgil-cl> change "javascript" with your preferred server-side language. (I could reformulate my previous advice as a high roder function, now that I see...)
22:09:37 <stepcut> yes, that is the other idea. To leave the button on the page, but in a disabled state. But I wanted to figure out how to solve the css problem anyway 
22:10:20 <stepcut> and, indeed I do have a higher order function :p
22:11:45 * jpgil-cl is available for those kind of questions, just send a /msg to prevent off-topics
22:12:24 <stepcut> well, I the gallery is written in haskell, so I think it's pretty on-topic :p
22:14:06 <jpgil-cl> It should be interesting to write a web-API in haskell
22:15:35 <jpgil-cl> <ul class="navPhoto"> <li class="back disabled"></li>  <li class="forward"></li>  </ul>
22:16:22 <jpgil-cl> ul.navPhoto back { color: gray; ... } ul.navPhoto disabled { visibility: hidden; }
22:16:40 <jpgil-cl> ups... change "back" for "li.back"
22:17:42 <jpgil-cl> well, that should work ( disabled --> li.disabled )
22:21:58 <stepcut> yeah, I got it working, using the visibility: hidden trick, thanks!
22:23:57 <jpgil-cl> I bet you aren't supporting (<=4.0) browsers. Results are impredecible.
22:24:14 <jpgil-cl> impredictable? Sorry, I miss the word
22:25:28 <stepcut> no
22:25:51 <stepcut> I may not even support ie < 6.0
22:28:01 <jpgil-cl> just to be sure, you could use, instead of <link rel=stylesheet">, the following:   <style type="text/css" media="screen">@import url(./default.css);</style>
22:28:32 <stepcut> oh?
22:28:55 <stepcut> because <6.0 does not support @import ?
22:28:57 <jpgil-cl> to include external .css files in your html.
22:29:13 <jpgil-cl> <5.0 doesn't support it. IExplorer and many others.
22:29:36 <stepcut> my plan is to support IE 6.0, the latest konqueror, and the latest mozilla family of browsers.
22:29:46 <stepcut> If I can also get IE 5.X support, that is a bonus
22:30:18 <jpgil-cl> that's the magic of CSS. It "tends" to be compatible.
22:30:27 <stepcut> heh
22:31:54 <jpgil-cl> I was trained in the mid of Browser-War Age. Fortunately I'm fast to forget, so I'm using CSS from years, without a single FONT or TABLE to do stuff.
22:32:04 <stepcut> heh
22:33:01 <stepcut> I highly approve of the concept of CSS, but I find it very frustrating to use, especially when attempting cross-platform capatability
22:33:39 <Riastradh> If you're having these difficulties, your page is vastly too complicated.
22:34:03 <jpgil-cl> frustrating?? I'm a Haskell newbie, mainly with PHP / MySQL / Javascript skills. I know what "frustrating" means!
22:34:08 <stepcut> jpgil-cl: heh
22:34:24 <Pseudonym> All it takes is one effect which someone does wrong and you're frustrated.
22:34:48 <stepcut> the whole margin thing done wrong in ie 5.0, for example, really screws things up
22:35:05 <jpgil-cl> forget about margins. Use two nested divs every time.
22:35:22 <Riastradh> It frustrates me when people work so hard to fix these complications instead of working on content, or useful code.
22:35:31 <jpgil-cl> (better yet, don't stick on pixel-design)
22:37:48 <jpgil-cl> Riastradh: I could save lots of hour by just programming in my well known languages, but I'm here. Everyone needs to keep training to expand his mind.
22:40:21 <Riastradh> That's what content is for, jpgil-cl.
22:40:29 <Riastradh> Frivolous elements of style serve only to waste time.
22:40:38 <Riastradh> ...stylesheets, that is.
22:41:26 <Riastradh> It's late, and I ought to go to bed, however, so that I shall do now.
22:41:55 <stepcut> I don't use CSS enough to have learned the 'right way' to do things, so everthing always takes forever
22:41:55 <jpgil-cl> Although I think very close to you, there's still reasons to show content in a nice way.  (Think in Helium)
22:43:14 <stepcut> I really hate it when navigation buttons for a gallery move around from picture to picture, that is all I am trying to avoid 
22:43:37 <jpgil-cl> you did it, by the way?
22:43:45 <stepcut> yes
22:44:30 <stepcut> mostly, if an image is too tall, then the scroll bars appear, and cause everthing on the page to shift left a few pixels :(
22:44:35 <stepcut> but I can live with that
22:46:08 <jpgil-cl> I remember I developed a set of methods to generate and show rectangular thumbnails in a visually coherent way
22:46:38 <jpgil-cl> starting with different proportions and sizes.
22:47:48 <jpgil-cl> just by equalling areas to a normalized one. The graphical designers where very happy with the solution.
22:48:12 <stepcut> I have a half-formed idea for building a photo gallery that is a graph instead a list, but I have not worked out all the details yet
22:48:21 <stepcut> jpgil-cl: sounds neat
22:49:18 <jpgil-cl> The traditional approach is to cut in max height or width. Really ugly, but widely used way to do.
22:51:47 <stepcut> thanks for your help
22:51:49 * stepcut goes to bed
22:52:24 <jpgil-cl> Good things worked.
23:07:27 <jpgil-cl> Haskell Q: in Helium I must explicit float add with (+.) instead of (+)  -- Is that needed in, say, GHC?
23:08:29 <dons> @type (+)
23:08:30 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
23:09:21 <dons> (+) is overloaded. which is why the different +'s in Helium aren't needed in Haskell
23:09:49 <jpgil-cl> Overload... yes, that means use of type classes, right?
23:10:33 <jpgil-cl> Anyway, I see some lights. Thanks!
23:11:41 <dons> yep. type classes solve the problem. in this case, the Num class.
23:11:44 <dons> for instance:
23:11:52 <dons> instance  Num Float  where
23:11:52 <dons>     (+)         x y     =  plusFloat x y
23:12:22 <dons> instance  Num Int  where
23:12:22 <dons>     (+)    = plusInt
23:12:58 <jpgil-cl> it's different from polimorfism? I see it very related
23:15:37 <dons> hm. a class is a way of defining some ad-hoc polymorphism
23:16:21 <jpgil-cl> (uh.. sorry for the spanglicism)
23:18:09 <jpgil-cl> eqChar could be polymorphized in some way to just write "a" = "a" ...
23:25:51 <dons> you see the polymorphism in the class declaration:
23:25:52 <dons> class  (Eq a, Show a) => Num a  where
23:25:53 <dons>     (+), (-), (*)       :: a -> a -> a
23:25:53 <dons>     negate              :: a -> a
23:26:45 <dons> here's the Eq class
23:26:46 <dons> class  Eq a  where
23:26:47 <dons>     (==), (/=)           :: a -> a -> Bool
23:26:59 <jpgil-cl> @type (=)
23:27:01 <lambdabot> bzzt
23:27:09 <jpgil-cl> @type (==)
23:27:10 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
23:27:12 <ozone> dons: have you seen john meacham's supertyping suggestion?
23:27:17 <ozone> it's very nice
23:27:21 <ozone> http://repetae.net/john/recent/out/supertyping.html
23:27:28 <dons> you want it in minhs?
23:27:32 <dons> :p
23:27:44 <ozone> type classes in minhs is probably a prerequisite for supertyping ;)
23:27:55 <dons> oh. yeah... oops
23:29:01 <dons> hehe "if this functionality .. horribly breaks the soundness of the typesystem then i apologize."
23:29:23 <dons> that should be a standard clause when proposing a new construct :)
23:30:06 <ozone> along with "(2) if oleg has already implemented this, please ignore my ignorance"
23:33:42 <Lor> Morning.
23:34:09 <dons> hey Lor
23:35:46 <Lor> Now this is funny. I contemplated mailing to you last night with the subject "pdynload", but then decided to defer it. So when I got your mail, I was for a moment like: "What the hell? How can he reply something I haven't even sent yet?" :)
23:36:10 <dons> hehe
23:36:19 <dons> spooky huh
23:37:07 <Lor> Anyway, the problem with pdynload is nots its implementation, but its type. It enforces no association between the type to be checked from the module, and the type of the returned value.
23:38:14 <dons> hm. well, the old dynload has this type:
23:38:20 <dons> dynload :: Typeable a
23:38:20 <dons>         => FilePath
23:38:20 <dons>         -> [FilePath]
23:38:20 <dons>         -> [PackageConf]
23:38:23 <dons>         -> Symbol
23:38:25 <dons>         -> IO (Maybe (Module, a))
23:38:35 <dons> and in pdynload the Typeable contraint has to become a typerep argument, instead
23:38:59 <Lor> Yes, but it's not a typerep. You have "Type" and not "Type a".
23:39:42 <dons> ah. because the user has had to manually apply a typeOf function themselves.
23:39:47 <dons> that is annoying.
23:40:18 <dons> they should be able to use the typereps generated by GHC in a more convenient way
23:40:36 <Lor> This is not so much about convenience as about safety.
23:41:10 <dons> yes. it trusts the user to do a correct typeOf. 
23:41:16 <dons> that is defintately on the list to fix
23:41:43 <dons> though the goal is to get back to the original dynloda type, but with a better Typeable
23:45:08 <Lor> Hm, typeOf is not quite the right thing. It requires you to have an element of that type already. And the typereps aren't parameterized.
23:49:35 <dons> the type of pdynload overly-exposes that fact that it is implemented by typechecking a code fragment. Once this stuff is internalised, it should be relatively straight forward to change the type back to pdynload :: PTypeable a => ... (Module, a)
23:50:32 <dons> so I'm not to worried about the munginess of pdynload's current type
23:50:56 <Lor> Yes, but how do you intend to implement PTypeable and still support even polymorphic types?
23:52:12 <dons> ah. it isn't going to be like the Data.Dynamic strategy, of course. It can't be.
23:52:30 <dons> hmm. let me think about what the desired type would look like
23:52:55 <shapr> @yow
23:52:55 <lambdabot> I'm young..  I'm HEALTHY..  I can HIKE THRU CAPT GROGAN'S LUMBAR REGIONS
23:55:27 <dons> I guess the make and load function would turn into something more like a staged type inf. run()
23:58:42 <dons> that's where it is currently heading, now that the full type checker is getting invoked at runtime
