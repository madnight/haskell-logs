04:17:51 <shapr> dons: ok, I'll try it with the cvs snapshots
04:18:23 <dons> cool. otherwise send me email. i'll look into it if you can give me more info
04:19:13 <dons> there's going to be a new release this week or next, hence using the snapshot is fine as it is about to turn into 0.9.6
04:27:07 * dons -> sleeps
04:27:27 <tic> Anyone good at rotation matrices
04:27:27 <tic> ?
07:52:15 <ron_> If you have some algorithm that's depend on 6 parameters, is it then time to use a StateMonad, or are there some other fancy methods for it?  
07:52:53 <ron_> /s/that's depend/that depends
07:57:03 <dtb> hey hey - i decided to try and write haskell quicksort
07:57:17 <dtb> got it not complaining to me...but it dosnt work
07:57:22 <dtb>  
07:57:28 <dtb> get_ltitem x [] = []
07:57:28 <dtb> get_ltitem x [h:list] = if h < x then h:rest else rest
07:57:28 <dtb>         where
07:57:28 <dtb>                 rest = get_ltitem x [list]
07:57:28 <dtb> get_gtitem x [] = []
07:57:28 <dtb> get_gtitem x [h:list] = if h > x then h:rest else rest
07:57:36 <dtb>         where
07:57:39 <dtb>                 rest = get_ltitem x [list]
07:57:40 <dtb> quicksort [] = []
07:57:43 <dtb> quicksort [h:list] = less ++ [h] ++ great
07:57:45 <dtb>         where
07:57:48 <dtb>                 less = get_ltitem h [list]
07:57:50 <dtb>                 great = get_gtitem h [list]
07:57:52 <dtb>  
07:57:54 <dtb> can anyone pick up what i've done wrong? or have a REALLY cool way of doing quicksort???
07:58:28 <dtb> HAHA
07:58:31 <dtb> nm - lol
07:58:37 <dtb> thats not quicksort
07:58:55 <Cale> qsort []     = []
07:58:55 <Cale> qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
07:58:55 <Cale> 		 where
07:58:55 <Cale> 		   elts_lt_x   = [y | y <- xs, y < x]
07:58:55 <Cale> 		   elts_greq_x = [y | y <- xs, y >= x]
07:58:58 <dtb> but anyway - lets pretend it was quicksort - eh, what was wrong
07:59:04 <dtb> oo cool
07:59:12 <dtb> thats called list comprehension right??
07:59:21 <Cale> you might recognise that from the "about haskell" page on haskell.org
07:59:26 <Cale> yeah
08:00:05 <dtb> ok - so im stupid - but can u pick what i've done wrong in the above ?
08:00:12 <Cale> get_ltitem x [h:list] ...
08:00:29 <Cale> the second param is a list containing a single list as an element?
08:00:48 <Cale> I think you might be looking for parens there
08:00:58 <ron_> I want to have a function like iterate that uses on it's nth call the nth value of a list. Is there a standard function for it?
08:01:00 <dtb> :D
08:01:30 <Cale> ron_: folding does this in general
08:02:00 <Cale> or is that not what you want?
08:02:33 <dtb> call_me callnumber list = list!!callnumber
08:02:37 <ron_> Cale: Yes
08:02:37 <dtb> :D i feel smart
08:03:09 <ron_> I am getting rusty :P
08:03:23 * ron_ thinks he needs to use Haskell some more...
08:28:24 <dtb> is there a haskell function like the scheme list member
08:28:57 <Lemmih> elem?
08:29:25 <dtb> :D Lemmih 
08:31:04 <dtb> what about generating a random integer between 4 and 80 ?
08:32:13 <ron_> module Random (
08:32:14 <ron_> RandomGen(next, split, genRange),
08:32:14 <ron_> StdGen, mkStdGen,
08:32:14 <ron_> Random( random,   randomR, 
08:32:14 <ron_> randoms,  randomRs,
08:32:15 <Lemmih> generateRandomInt = 43
08:32:16 <ron_> randomIO, randomRIO ),
08:32:18 <ron_> getStdRandom, getStdGen, setStdGen, newStdGen
08:32:55 <dtb> how do i use a module in haskell? is it already there for me?
08:33:16 <Lemmih> `import MyHaskellModule`
08:35:02 <dtb> argh
08:35:06 <dtb> i feel stupid
08:35:17 <dtb> can someone tell me how to do it? :
08:36:37 <Lemmih> Why do you wanna mess with impure programming?
08:36:52 <dtb> ?
08:36:53 <dtb> lol
08:36:59 <dtb> all i want is a list of random numbers 
08:37:03 <dtb> O__o
08:37:04 <Cale> heh
08:37:19 <Cale> http://www.haskell.org/onlinereport/random.html
08:37:20 <Lemmih> listOfRandomNumbers = [342,23,432,257,3,23,]
08:37:25 <Cale> hahaha
08:37:43 <Lemmih> eh... without the last ','.
08:37:44 <dtb> Lemmih: how long can u generate for?
08:37:46 <Cale> you're probably looking for "randoms"
08:37:52 <Hobbes> can anyone suggest any ways to tidyup/reduce the length of this code ive written... http://haskell.org/hawiki/HaskellIrcPastePage?action=show ... its the bags module
08:38:10 <Cale> which will give you an infinite list of random numbers
08:38:51 <Cale> or randomRs which will put them in a range
08:39:10 <dtb> Cale: what do i type in the silly prompt to get a list O__o
08:39:10 <dtb> *Main> randoms
08:39:11 <dtb> <interactive>:1: Variable not in scope: `randoms'
08:39:31 <dtb> and ive seen that random module page 10 times already - its EVERYWHER ON TEH NET
08:39:32 <Cale> dtb: you need to import the module "Random"
08:39:33 <dtb> arg
08:39:51 <dtb> <interactive>:1: parse error on input `import'
08:39:52 <dtb> lol
08:40:03 <Cale> what are you using for an interpreter?
08:40:07 <dtb> ghci
08:40:08 <Lemmih> Use: ":m Random"
08:40:12 <dtb> the best ive been told
08:40:13 <Cale> :m + Random
08:40:18 <dtb> ARHLSKJd!
08:40:20 <dtb> thasnkyou!
08:40:22 <Cale> yeah, ghci is good
08:40:33 <dtb> Cale:  what does the + do? add onto instead of replace?
08:40:37 <Cale> yeah
08:40:42 <ron_> ghci should have TAB completion..
08:40:48 <Cale> It does
08:40:54 <ron_> ??
08:40:58 <Lemmih> Really?
08:41:05 <Cale> yes, for filenames :)
08:41:05 <dtb> but not for modules, only files in current directory
08:41:33 <ron_> Cale: I need it for function names (the only real use)
08:42:05 <ron_> But I must admit I didn't knew anymore that it lists filenames...
08:42:44 <Cale> yeah, the available functions would be much more useful to complete against
08:43:03 <Cale> or make it context sensitive :)
08:45:19 <dtb> randomR (4,80)
08:45:24 <dtb> take 20 (randomR (4,80))
08:45:26 <dtb> ish
08:45:33 <dtb> i think ill go back to java
08:45:43 <ron_> Cale, there's nothing difficult to that. It would be even possible to write your own for one module, and that ghc recognizes that interface.  
08:46:04 <ron_> dtb: #java
08:46:19 <dtb> :D
08:47:48 <dtb> someone care to explain what a Mondad is in 12 words or less?
08:47:54 <ron_> ok
08:48:38 <Lemmih> Hobbes: You can remove the 'remove' function.
08:49:04 <ron_> dtb: A monad is a structure if it supports some laws. :)
08:49:28 <ron_> dtb: A structure is a monad  if it supports some laws. :)
08:49:31 <Cale> dtb: it's a sort of container
08:49:35 <Riastradh> dtb, a monad is a generalization of computation.
08:49:40 <Cale> hehehe
08:49:49 <dtb> O__o
08:49:57 <Riastradh> dtb, it's not as scary as it sounds.
08:50:03 <dtb> yes - give me 2 mins
08:50:07 <dtb> i'll get it...
08:50:11 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
08:50:14 <Riastradh> Just think of what a computation is abstractly: a sequence of state transitions.
08:50:18 <Cale> have a look there :)
08:50:20 <tic> dtb, http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
08:50:23 <ron_> Riastradh: It's an endofunctor with two natural transformations :-)
08:50:34 <Riastradh> ron_, now _that_ is bound to sound scary!
08:50:53 <ron_> Riastradh: How do you underline "that"?
08:51:01 <Riastradh> (and unfortunately I even understand that description...)
08:51:02 <dtb> _ _ 
08:51:13 <Riastradh> Um, just as it looks.
08:51:20 <ron_> _test_
08:51:28 <ron_> Hmm, that's nice.
08:51:30 <Cale> hm?
08:51:31 <dtb> what chat client u using ron_ ?
08:51:32 <Riastradh> Oh, does your IRC client convert words with underscores around it to be underlined and without the underscores?
08:51:36 <ron_> irssi
08:51:41 <Cale> *hello*
08:51:42 <dtb> arr
08:51:45 <Riastradh> Ah.
08:51:46 <Cale> is that bold?
08:51:46 <dtb> u get cool stuff
08:51:52 <ron_> Riastradh: Yes
08:51:52 <dtb> xchat is didgey
08:51:53 <Cale>  /hello/
08:52:07 <Riastradh> (irssi doesn't remove the underscores.)
08:52:16 <Riastradh> (It's what I'm using too.)
08:53:25 * ron_ just loves offtopic :-)
08:54:49 <dtb> ron_: and endorfunctor and functor - are they just tricky names for functions?
08:55:13 <dtb> planetmath.org
08:55:17 <dtb> wow
08:55:26 <Lor> "functor" has a gazillion meanings.
08:57:57 <Hobbes> lemmih, but i use it later on in the makeListList function
08:59:03 <Hobbes> is there anyway i can condense the listToBag, makeListList and findOthers functions?
08:59:23 <Hobbes> http://haskell.org/hawiki/HaskellIrcPastePage?action=show for those who didnt see it earlier
08:59:24 <Lemmih> Hobbes: It's very similar to `\x -> filter (/=x)`
09:00:20 <Hobbes> aaah
09:07:57 <dtb> thx guys cya
09:35:11 * ron_ scanned an image with a resolution of 10000*160000 or so. When I tried to zoom in, it needed 3GB of memory(only have 2)=>Crash  lol
09:35:32 <ron_> /s/160000/16000
09:47:04 <monochrom> haha
10:06:40 <gdsx> ron_: a map?
10:39:40 <ron_> gdsx: No, a form.
10:50:04 <Hobbes> hi... is there a sorting algorithm that will sort lists of tuples based on the fst item in the tuple?
10:51:20 <Hobbes> anybody here?
10:52:15 <Lemmih> List.sort maybe.
10:53:50 <Lemmih> I'm not sure how it's implemented but: List.sort [(1,2),(0,4213)] => [(0,4213),(1,2)]
10:54:10 <Hobbes> cool...thanks muchly
10:56:09 <Hobbes> hang on how do i use that in my module... do i have to "import list(sort)" then just type "sort [somelist]"
10:56:56 <Lemmih> Module names must be capitalized.
10:57:24 <Hobbes> oh yeah. cheers
10:57:43 <Lemmih> And yes, I don't think that the Prelude exports Data.List.
10:59:46 <Hobbes> can i have Eq and Ord constraints in the same type decleration?
11:00:11 <Marvin--> sure
11:00:17 <Marvin--> foo :: (Eq a, Ord a) => ...
11:00:25 <Hobbes> aahhh brackets...cool
11:00:54 <Marvin--> but actually, all instances of Ord are instances of Eq
11:01:10 <Marvin--> Ord is declared  class Eq a => Ord a where ...
11:01:22 <Marvin--> so you won't need the Eq a constraint
11:01:42 <Hobbes> hmm it complains if i remove Eq a
11:01:58 <Marvin--> really? that's odd
11:02:56 <Hobbes> ok now its not. must have forgotten to reload!
11:03:14 <Marvin--> happens to all of us :)
11:03:52 <Hobbes> thats it! my coursework is finished and im a happy man
11:04:02 <Marvin--> yay!
11:04:31 * Lemmih is envious.
11:05:07 <Hobbes> haha ive still got ADVANCED haskell coursework to do!
11:07:07 <Lemmih> Lucky bastard (-: I can't get classes in programming for another year. And they are only teaching Java /-:
11:08:03 <Smerdyakov> It's not lucky to be able to take poorly taught classes.
11:08:06 <Marvin--> Lemmih: bah, be a good boy and fall into the line with the other j2ee monkeys
11:08:30 <Hobbes> hey i dont swing from trees
11:08:36 <Hobbes> i do use swing though
11:09:36 <Lemmih> Smerdyakov: How do you know that Hobbes' Haskell classes are poorly taught?
11:09:47 <Hobbes> i told everyone yesterday
11:10:15 <Smerdyakov> P.S.: Almost _all_ university classes are a let-down for anyone with self-motivation and talent.
11:10:16 <Marvin--> that's soooo yesterday's news ;)
11:10:23 <Marvin--> Smerdyakov: true dat
11:10:27 <Smerdyakov> You can do so much better with self-study.
11:10:51 <Lemmih> oh (-: Well I would be glad to just meet some Haskeller irl.
11:10:52 <Hobbes> it is nice to have someone to talk to though. you can ask a book questions
11:11:05 <Hobbes> cant
11:11:07 <Hobbes> duh
11:12:33 <arjanb> noticing that you learn more outside courses is very demotivating
11:14:30 <Lemmih> Not knowing anyone with the same interests as you is very depressing (at least for me it is).
11:15:39 <Smerdyakov> You're miscalibrated.
11:15:48 <Smerdyakov> I never met anyone with a serious interest in programming until college.
11:15:51 <Smerdyakov> It didn't bother me one bit.
11:18:38 <Lemmih> Don't you have serious mental problems now?
11:18:48 <Smerdyakov> Well, that depends on your idea of serious!
11:19:13 * arauko still doesnt meet anyone with the same interest
11:19:21 <Riastradh> I don't think Smerdyakov is _joking_ about being schizophrenic, so...
11:20:13 <Smerdyakov> Riastradh, that's not a problem in itself.
11:21:50 <Hobbes> is there an easy way to get names at the beginning of a reply?
11:22:51 <Smerdyakov> Hobbes, I must have missed some context, because I have no idea what you just said.
11:23:19 <arjanb> Hobbes: first few letters and pressing tab works in most clients
11:23:21 <Lemmih> I think he's talking about tab completion.
11:23:30 <Hobbes> thats the one
11:26:56 * Lemmih is still disapointed at wxHaskell.
11:28:08 <Lemmih> s/at/with/?
11:28:14 <Smerdyakov> 'with' sounds better.
11:36:49 <Hobbes> i have a function listToBag which returns a bag and a function bagOccur which takes a bag. do i have to type "bagOccur (listToBag blah)" everytime i want to test bagOccur or is there some way of putting listToBag into memory..im using winHugs
11:37:43 <Smerdyakov> You can make a type class for things that can be interpreted as bags.
11:38:16 <Smerdyakov> You could also just define 'listOccur = bagOccur . listToBag' and use listOccur instead.
11:57:12 <jadrian> hello
11:57:48 <Lemmih> Yo.
11:58:27 <jadrian> is there any place (available online) to learn more about Data.Set and Data.FiniteMap besides the source of GHC?
11:58:30 <jadrian> hi Lemmih  
11:59:32 <Lemmih> Have you checked out GHC's documentation? ( http://haskell.org/ghc/docs/latest/html/libraries/index.html )
11:59:38 <jadrian> yeap
11:59:48 <jadrian> nothing is said about the complexity of the operations
12:00:08 <jadrian> I have no idea whether Data.Set.cardinality is constant time or not
12:01:22 <jadrian> well I'll just look at the source
12:01:48 * arauko amazing with 2^5000
12:06:44 <jadrian> yeap it's constant alright :)
12:14:54 <Lemmih> Smerdyakov: Didn't you get lonely?
12:15:42 <hofi> hello
12:15:45 <Lemmih> Hey
12:16:28 <Lemmih> Smerdyakov: Or did you have other more 'normal' interests which you could share with friends?
12:17:04 <hofi> i am new to haskell. i am reading a tutorial on it. the tutorial uses a function called "ord". i try to use this function with hugs but it doesn't recognize it
12:17:09 <hofi> can anyone help me?
12:19:15 <Lemmih> It's in Data.Char in GHC.
12:19:29 <hofi> so i should use a better compiler?
12:19:48 <Lemmih> Hugs is fine. I just don't know much about it.
12:20:01 <Lor> :l Char
12:20:15 <Lor> type that and then it should work.
12:21:12 <hofi> :l is short of load?
12:21:18 <Lor> Yes.
12:21:33 <hofi> hm, "is short for :load" i wanted to say
12:22:11 <hofi> so you can only load one file at a time?
12:22:13 <Lemmih> Lor: Why is :m not the same as :l?
12:22:40 <Lemmih> hofi: :also should allow you to load several modules.
12:22:58 <hofi> right
12:23:17 <hofi> that's listed right below :load in the help screen, i should've seen it
12:23:17 <Lor> :l loads modules, :m sets the visible modules of the already loaded ones.
12:24:09 <hofi> ok
12:24:42 <hofi> hm, i still get the same error
12:25:39 <hofi> this language is confusing and depressing me :-)
12:25:50 <Lor> Does the prompt say "Char>" ?
12:25:55 <hofi> yes
12:26:05 <hofi> and i can call the ord function on the prompt
12:26:14 <Lor> But?
12:26:42 <hofi> ERROR "example3.hs":15 - Undefined variable "ord"
12:27:06 <Lemmih> You have to import Char in your source code.
12:27:25 <hofi> how might i accomplish that task?
12:27:27 <Lor> Ah. Problems in a file are completely distinct from problems in the prompt.
12:27:48 <Lor> Put "import Char" to the beginning of your source file (but after the "module Foo where" ...)
12:28:19 <hofi> there is supposed to be a "module Foo where" at the beginning of my file?
12:28:29 <hofi> this tutorial is skipping over many things
12:28:44 <Lemmih> hofi: Any reason you're using a file? Most learning can be done without the use of anything else than just the interpreter.
12:29:09 <hofi> Lemmih: the interpreter produced errors when i didn't put things in a file
12:29:41 <Lemmih> Which tutorial are you reading?
12:30:12 <hofi> ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf
12:30:41 <hofi> by Damir Medak and Gerhard Navratil
12:35:12 <hofi> it is linked on haskell.org, so i gave it a shot
12:36:48 <Smerdyakov> Lemmih, I don't know of any interpreters that allow declarations.
12:37:45 <Lemmih> Smerdyakov: Never heard of GHCi, eh? (-:
12:38:31 <Lemmih> hofi: Did you import the Char module?
12:39:43 <hofi> Lemmih: yes
12:39:56 <hofi> Lemmih: i added "import Char" to the top of my file
12:40:16 <hofi> Lemmih: now it doesn't produce an error any more, yay :-)
12:41:22 <Smerdyakov> Lemmih, you can just type declarations in the interpreter like any other code?
12:42:26 <Lemmih> Prelude> let x = \y -> y
12:42:30 <hofi> thank you everyone
12:42:32 <Lemmih> Prelude> y 10
12:42:33 <Lemmih> 10
12:43:21 <Lemmih> eh (-: 'x 10 => 10'
12:43:26 <Smerdyakov> How about recursive functions?
12:43:57 <Smerdyakov> I was thinking of top-level declarations, which don't have 'let' before them, also.
12:45:52 <Lemmih> let map' f lst | null lst = [] | otherwise = f (head lst):map' f (tail lst)
12:46:08 <Smerdyakov> That begins with 'let'.
12:46:15 <Lemmih> So?
12:46:37 <Smerdyakov> I don't know enough about Haskell to know if there is some essential difference between that and top-level declarations.
12:46:42 <Smerdyakov> How about mutually recursive functions?
12:48:03 <Lemmih> I'm talking about grasping the very basics of Haskell.
12:49:04 <hofi> so there are no loops in haskell and everything that could be done with a loop is done with recursion?
12:49:19 <Lemmih> Yep.
12:49:44 <hofi> that is scary
12:50:11 <Lemmih> But very elegant.
12:50:12 <Marvin--> Smerdyakov: let { foo 0 = 1 ; foo n = n * bar n ; bar n = foo (n-1) }  works just fine in ghci
12:50:34 <hofi> Lemmih: i don't know what it means when programmers call code elegant
12:50:39 <hofi> Lemmih: can you explain it to me?
12:51:00 <Smerdyakov> Marvin--, that's an awkward way to enter large mutually recursive functions!
12:51:17 <Marvin--> Smerdyakov: better than nothing
12:51:25 <Smerdyakov> Marvin--, and worse than just loading from a file.
12:51:35 <Marvin--> well... yes :)
12:52:14 <Lemmih> @dict elegant
12:52:15 <lambdabot> Supported dictionary-lookup commands:
12:52:15 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon
12:52:15 <lambdabot> @lojban @prelude @vera @web1913 @wn @world02
12:52:15 <lambdabot> Use "@dict-help [cmd...]" for more.
12:52:43 <hofi> the machine is talking gibberish. it doesn't understand the word either
12:52:49 <Lemmih> @jargon elegant
12:52:51 <lambdabot> *** "elegant" jargon "Jargon File (4.3.0, 30 APR 2001)"
12:52:51 <lambdabot> elegant adj. [common; from mathematical usage] Combining simplicity,
12:52:51 <lambdabot>    power, and a certain ineffable grace of design. Higher praise than
12:52:51 <lambdabot>    `clever', `winning', or even {cuspy}.
12:52:54 <lambdabot>    The French aviator, adventurer, and author Antoine de Saint-Exupe'ry
12:52:58 <lambdabot>    probably best known for his classic children's book "The Little Prince
12:53:00 <lambdabot> [8 @more lines]
12:53:19 <Lemmih> @more
12:53:19 <lambdabot> ,
12:53:19 <lambdabot>    was also an aircraft designer. He gave us perhaps the best definition
12:53:19 <lambdabot> of
12:53:19 <lambdabot>    engineering elegance when he said "A designer knows he has achieved
12:53:19 <lambdabot>    perfection not when there is nothing left to add, but when there is
12:53:20 <lambdabot>    nothing left to take away."
12:53:39 <Marvin--> there, let's hope I didn't fuck up this release
12:53:57 <hofi> i see
12:54:15 <hofi> so recursion is simple yet effective and powerful
12:54:21 <hofi> and loops aren't?
12:54:49 <Lemmih> Loops can be very crude sometimes.
12:55:57 <hofi> and recursion can't?
12:55:59 <Smerdyakov> hofi, recursion expresses data dependencies explicitly.
12:56:12 <Smerdyakov> hofi, they are much easier to follow when you get the basic idea down.
12:57:19 <hofi> ok
12:57:31 <Marvin--> I'd say that elegance aside, Haskell doesn't have loops because the loop is an imperative concept, not a functional one
12:57:32 <hofi> maybe i will see it myself when i get more experience
12:57:45 <Marvin--> loops rely on side effects, Haskell doesn't have side effects
13:00:40 <Smerdyakov> That's basically what I just said.
13:15:16 <jadrian> well... what is a loop?
13:17:46 <Smerdyakov> jadrian, a pumpkin.
13:17:53 <jadrian> eh :)
13:18:45 <jadrian> I just don't see loops as requiring side efects
13:19:34 <Lemmih> jadrian: How would you loop 10 times in C?
13:20:17 <Lemmih> (Or some other imperative language)
13:20:17 <jadrian> the fact that in C it is implemented with destructive updates doesn't mean you cannot do it without them
13:20:46 <Marvin--> jadrian: I wasn't trying to be philosophical :)
13:21:36 <jadrian> yeap but me neither Marvin--, my point is that you have some things in functional laguages, even in the prelude that are pretty close to imperative loops
13:21:48 <jadrian> like "interate" and "until"
13:21:49 <Marvin--> oh, sure
13:21:55 <Smerdyakov> jadrian, I think that loops require side effects by definition.
13:22:06 <Riastradh> Smerdyakov, by what definition?
13:22:13 <jadrian> Smerdyakov: that's why I asked about the definition of loop ;) 
13:22:14 <Smerdyakov> Riastradh, by the folk definition in common use.
13:22:32 <Riastradh> Smerdyakov, and that definition is...?
13:22:53 <monochrom> I don't think we should be too serious about such dogmas.
13:23:57 <Smerdyakov> Riastradh, a loop is a program construct gets things done by repeatedly executing a body.
13:25:53 <Riastradh> Smerdyakov, and this implies side effects?
13:26:14 <Smerdyakov> Yes. Such a construct is useless without side effects. There is no provision for threading values through the iterations.
13:26:24 <Riastradh> That wasn't part of the definition.
13:26:31 <Smerdyakov> It was as I meant the definition to be read.
13:26:34 <Riastradh> Is a recursive function not a loop by your definition?
13:26:41 <Smerdyakov> Yes, it is not.
13:26:46 <Riastradh> How is it not?
13:26:57 <Smerdyakov> It gets things done by doing more than executing a body repeatedly.
13:26:57 <Riastradh> It is a program construct that repeatedly evaluates the function's body.
13:27:06 <Riastradh> What more does it do?
13:27:07 <Smerdyakov> Right, but the value of the body is key.
13:27:15 <Smerdyakov> The value of the body is passed to the callers.
13:27:24 <Smerdyakov> Loops have no such thing.
13:27:26 <Riastradh> Is the recursive function call not part of the 'body?'
13:27:36 <Smerdyakov> It is. I am not saying there is no body.
13:27:49 <Smerdyakov> I am saying that the value of the body is given as input to certain subexpressions.
13:28:01 <Smerdyakov> This means it is not a loop. It does more than a loop is allowed to do by my definition.
13:28:08 <Riastradh> How is that contradictory with your definition of loop?
13:28:17 <Marvin--> hey syntax
13:28:22 <Smerdyakov> My definition is not meant to be read as a set of minimum requirements.
13:28:33 <Smerdyakov> A loop may do no more with its body than what my definition stated.
13:28:43 <Marvin--> turns out I didn't get any cabal refactoring done after all
13:28:44 <Riastradh> Where does this definition come from?
13:28:59 <Riastradh> I have never seen such a restrictive meaning.
13:29:31 <Marvin--> I think you are over-analyzing it a bit :)
13:29:33 <Smerdyakov> This is what everyone means by "loop."
13:29:40 <Riastradh> An example of what I _have_ seen is: A loop is a set of mutually or self-recursive functions all called with the same continuation.
13:30:02 <Smerdyakov> And it is certainly what hofi meant by loop.
13:30:12 <SyntaxNinja> hi Marvin--
13:30:13 <Riastradh> I don't think any Schemer or Lisper would agree with you, Smerdyakov.
13:30:25 <Smerdyakov> They're not in tune with the rest of the universe.
13:30:29 <SyntaxNinja> Marvin--: that's OK. it's been on my backburner, but is bound to get to the front Real Soon Now
13:31:03 <Smerdyakov> hofi asked if Haskell has loops, and I think someone said no.
13:31:06 <Riastradh> Smerdyakov, must you always make such flagrantly derogatory comments that have no relevance to anything every time I bring up Schemers or Lispers?
13:31:15 <Smerdyakov> If we accept that some valid definition applies to "loop" as used there, then it's going to be mine.
13:31:21 <Marvin--> bleedin' scheming lithpers
13:31:33 <monochrom> Hahaa
13:32:08 <monochrom> Does Prolog have loop?
13:32:55 <Smerdyakov> No
13:35:10 * esap thinks iteration and recursion are _duals_, not the same thing at all.
13:35:23 * Marvin-- groans
13:35:27 <Marvin--> there we go with the duals again
13:35:47 * esap laughs. Everything has a dual...
13:35:57 <jadrian> If you have an Int as a strict field of some datatype, are there any situations where Unboxed Ints are *not* a better choice?
13:36:25 <jadrian> or are we always better off with unboxed ints in that case?
13:37:39 <monochrom> I can't think of a counterexample.
13:37:57 <jadrian> I can only think of one... and even then I'm not sure
13:38:07 <monochrom> esap: what dualization would bring iteration to recursion?
13:38:15 <Riastradh> esap, iteration and recursion aren't duals; they're unrelated.  Recursion is simply a property of a function; iteration is a process.
13:38:49 <jadrian> and that would be if we need to box it all the time (to use it as an argument to other functions)
13:38:56 <jadrian> but other than that
13:39:09 <jadrian> I can't think of a counterexample either..
13:39:09 <esap> monochrom: The categorical duality. There is a paper by Filinski about it.
13:39:10 <monochrom> Ah.
13:39:53 <Marvin--> I need a beer
13:40:46 <monochrom> We need a new field called "philosophy of programming", in line with "philosophy of science" and "philosophy of mathematics".  You guys can argue things under that banner forever.
13:40:55 <esap> monochrom: It's actually "call-by-name recursion" is dual to "call-by-value iteration".
13:43:10 <Marvin--> doesn't Wadler talk about the duality of call-by-name and call-by-value too?
13:43:29 <hofi> you would have said all these weird things if i hadn't asked about recursion, right?
13:44:09 <monochrom> Hrm that's interesting.  Perhaps the duality is really between by-name and by-value, not between recursion and iteration?
13:44:24 <esap> monochrom: Yes it is, call-by-name is dual to call-by-value.
13:44:38 <Marvin--> http://homepages.inf.ed.ac.uk/wadler/topics/dual.html
13:45:27 <Marvin--> hofi: there's a lot of weirdness on this channel :)
13:46:47 * esap thinks there once was a field that was almost like this philosophy thing [called 'AI'] :-)
13:47:18 <Marvin--> ouch ;)
13:47:24 <jadrian> :)
13:47:58 <hofi> Marvin--: i can see that, yes
13:48:13 <jadrian> by the way, do you know of any pratical examples of 1st order proofs using intuitionistic logic?
13:48:36 <monochrom> practical examples of proofs?  Hahahah...
13:48:39 <Smerdyakov> Sure. "Anything proves true." :)
13:49:10 <monochrom> "Today I showed that there are transcendental numbers at work.  Constructive proof too."
13:49:14 <Smerdyakov> I'm working with first-order intuitioninstic proofs now, in proof-carrying code.
13:49:41 <jadrian> I've read somewhere that there is a relation between proofs in intutionistic logic and functional programming
13:49:43 <monochrom> But seriously, the tutorials of Coq has examples.
13:50:00 <Marvin--> has anybody here read Out of Their Minds?
13:50:01 <esap> jadrian: That's curry-howard isomorphism.
13:50:08 <Smerdyakov> jadrian, intuitionistic proofs really aren't exotic at all. Most proofs will tend to be intuitionistic without trying.
13:50:11 <monochrom> And Coq furnishes that relation too, by providing a program that transforms Coq proofs into ML programs.
13:50:17 <monochrom> Marvin--: Yes!
13:50:20 <jadrian> esap: yeap I thought that might be just it :/
13:50:57 <Marvin--> I really liked that book
13:51:00 * esap suggests everyone reads "Sorensen: Lectures on the Curry-Howard isomorphism".
13:51:03 <jadrian> esap: but since I'm no expert in lambda calculus I thought they could be saying something else
13:51:54 <jadrian> Smerdyakov: I was wondering if there were some simple pratical examples of fields where you require intutionistic logic though
13:52:08 <Smerdyakov> jadrian, what do you mean by "require"?
13:53:02 <jadrian> Smerdyakov: I'm doing some work with theorem proving, and I'm working directly with getzen deduction systems. I'd just like to show some practical examples of applications of the theorem prover.
13:54:05 <jadrian> Smerdyakov: So by require I just meant some fields where you may need a proof constructed using the gentzen rules of intuitionistic logic
13:54:06 * esap would suggest proving the enormous theorem, but as the name says, it's enormous, so might be too much work :-)
13:55:49 <Smerdyakov> jadrian, well, anywhere where you want to be able to construct something from a proof that it exists.
13:56:39 <Smerdyakov> jadrian, I think a more common reason comes from the usual desire to work with as simple a formal system as possible.
13:56:50 <Smerdyakov> jadrian, the extra rule for classical logic is just not needed for many domains.
13:57:27 <jadrian> Smerdyakov: but it may be more efficient to use it right?
13:58:07 <Smerdyakov> Maybe, but less intuitive. :)
13:58:43 <esap> jadrian: It depends on what you want to do. There are situations where the end-result has to be a constructive proof, such that you can, say, evalute the proof with the computer.
13:59:38 <jadrian> I'd like something like, "we really need a constructive proof in this case, because..."
14:00:12 <jadrian> some "real world" examples of fields where a non constructive proof is not useful
14:00:37 <esap> Say, constructive real numbers?`:-)
14:01:00 <jadrian> by real world examples I mean stuff like "hardware verification" and stuff
14:01:17 <wagle> is there a canonical reference for a (concise?) formal/mathematical description of universal and existential types (in haskell)?
14:01:30 <jadrian> esap: no no no, real numbers have nothing to do with real world
14:01:32 <jadrian> :)
14:01:51 <jadrian> I'd like stuff I could should to people in a Department of Computer Engeeniering
14:01:58 <esap> jadrian: well constructive reals are, by definition, constructive, and thus part of the real world :-)
14:02:13 <jadrian> esap: no to a Department of Computer Engeeniering their not :D
14:02:23 <wagle> reals are all in your head.  your head is in the real world?
14:02:40 <jadrian> wagle: of course it isn't...
14:03:42 <jadrian> by interpretation of reall world right now is stuff like, hardware verification, software verification, etc...
14:03:46 <jadrian> usefull stuff
14:03:50 <jadrian> my head is not usefull
14:03:50 <wagle> hermann geuvers et al proved the fundamental theorem of algebra in Coq
14:04:07 <jadrian> my head is full of theoretical non-sense :)
14:04:37 <wagle> become an ultrafiniticist
14:04:39 <esap> wagle: I'm not sure about the canonical part, but check the Sorensen: Lectures on the Curry-Howard isomorphism.
14:05:30 <esap> wagle: That's not Haskell-specific, but that shouldn't matter.
14:07:17 <esap> wagle: I guess the online report should describe the Haskell-specific parts.
14:08:12 <Marvin--> universal and existential types aren't part of haskell98 though
14:09:05 <wagle> alias hugs='hugs -98'
14:11:07 <esap> Right, I guess GHC manual is a good reference for compiler-specific extensions.
14:11:10 <jadrian> "<esap> jadrian: It depends on what you want to do. There are situations where the end-result has to be a constructive proof, such that you can, say, evalute the proof with the computer."
14:11:18 <jadrian> esap: opss sorry I missed this 
14:11:43 <wagle> esap: right now i'm reading pierce's chapters on universal and existential types. the original question is "why does haskell use forall to define existential types, and what exactly is the derivation motivating this?"
14:11:43 <jadrian> esap: what do you mean by "evaluate the proof"?
14:12:44 <Smerdyakov> wagle, existentials can be modeled as functions that take the existential witness as an argument.
14:12:50 <shrimpx> the 'forall' thing is documented in an email by spj somewhere. they used 'forall' because they didn't want to waste yet another keyword
14:12:51 <wagle> isnt english wonderful that "constructive" can mean so many competing things simultaneously
14:13:13 <Smerdyakov> wagle, you generally want these functions to be able to return any type, so forall is used to allow that.
14:13:36 <esap> jadrian: Well for every theorem, you get a type via Curry-Howard isomorphism. For every proof, you get a program that implements the proof. You can actually run such code to test specific cases.
14:14:46 <Smerdyakov> jadrian, so if you _prove_ that, say, for every element of set X, there exists an element of set Y, then you can compile the proof into a _program_ that takes an X as input and gives you the proper Y.
14:14:49 <esap> jadrian: Although most of the time, the program that corresponds to the proof does pretty silly things from operational point of view.
14:15:15 <Smerdyakov> jadrian, and you can have conditions on which Y is proper for each X, of course.
14:16:40 <wagle> Smerdyakov: uh..  sounds like "or every element of set X, there exists an element of set Y" is equiv to "or every element of set X, there set Y is non-empty"?
14:16:57 <wagle> s/or/for/
14:17:13 <wagle> argh
14:17:46 <wagle> Smerdyakov: uh..  sounds like "for every element of set X, there exists an element of set Y" is equiv to "for every element of set X, set Y is non-empty"?
14:18:03 <Smerdyakov> wagle, see my addendum about imposing a relationship beteen the X and Y elements.
14:18:31 <esap> wagle: set emptiness is not dependent on the elements of set X in that case.
14:18:56 <wagle> you want an unto map from X to Y?
14:19:06 <Smerdyakov> I will restate what I said before, this time not omitting important aspects:
14:19:33 <Smerdyakov> If you prove that a function satisfying a specification exists in constructive logic, then you can automatically extract such a function from the proof.
14:19:33 <wagle> ..  hrmp total map..  i'm spacy
14:19:35 <Smerdyakov> Better? :)
14:21:39 <wagle> ok.. i know what you are trying to say now
14:21:46 <shrimpx> kinda on-topic question: does anyone have an intuition for why universal types can be modelled/explained in terms of set intersection and existential types in terms of union?
14:22:09 <wagle> and is intersection, or is union
14:22:40 <wagle> universal quant is and, existential quant is or
14:23:16 <wagle> types might, or might not be sets
14:23:20 <esap> shrimpx: One way to think about it is like this: universal type is like an infinite element version of '/\' (=and) and existential quantification is like an infinite element version of '\/' (or).
14:23:49 <esap> shrimpx: And /\ and \/ are obviously related to set intersection and union.
14:24:09 <shrimpx> oh ya
14:24:45 <wagle> i tend not to think of types as sets, though
14:25:07 <musasabi> Trying to compile happy fails with errors seemingly from -cpp not working.
14:25:15 <shrimpx> me neither, really. but a type is inhabited by a set of terms
14:25:17 <wagle> might generalize away from sets and think in terms of join and meet
14:25:31 <musasabi> with GHC 6.2.1 on DragonFly.
14:25:43 <wagle> dragonfly?
14:25:52 <musasabi> wagle: FreeBSD clone.
14:25:52 <jadrian> BSD fork I think
14:26:00 <jadrian> clone?
14:26:02 <wagle> i knew i heard o that
14:26:09 <jadrian> isn't it a fork?
14:26:17 <musasabi> yes from the 4.X line.
14:27:06 <shrimpx> a concrete example if the intersection/union thing is forall x.list x is inhabited only by [], (intersection of all list terms) while exists x.list x is inhabited by every list term. (union)
14:27:16 <shrimpx> i get it
14:27:27 <shrimpx> s/if/of/
14:31:34 <esap> About the 'type is inhabitated by set of terms' thing, isn't it possible that for some types, it's not a term that inhabitates it?
14:32:27 <shrimpx> dunno, what would inhabit it if it's not a set of terms?
14:32:38 <wagle> well, i imagine that if haskell added the exists keyword with the expected meaning, you couldnt just replace "forall" (when its being used to mean existential) with "exists"..  you'd have to do the syntactic transformations to negate it
14:33:04 <esap> well kinds are a type of types. types are not terms. In OO, classes are types of objects [and objects are not terms].
14:33:29 <shrimpx> they're not?
14:33:56 <esap> I mean, there is a difference between 'value', 'type' and 'term'.
14:34:05 <shrimpx> a value is a term
14:34:12 <wagle> i've seen object calculi where objects were terms
14:34:57 <wagle> sometimes values are terms
14:35:10 <esap> I'd say that a term is an expression that evaluates to a value. And there is a term (constant term) that evaluates to itself.
14:36:06 <Smerdyakov> The convention is that types describe terms.
14:36:14 <Smerdyakov> There's just no way to get any other situation by definition.
14:36:15 <wagle> i prefer to separate terms (programs?  expressions?) from values
14:36:50 <wagle> terms can be normalized to terms, or evaluated to values
14:37:29 <wagle> of course, the pierce i'm reading defines certain terms as values
14:37:30 <shrimpx> typically a value is a term in NF that's typable. if you have a typable non-reducible term that's not a value, i'd say the semantics is broken
14:37:58 <wagle> where values are used to define what is and is not a redex
14:39:07 <wagle> (\x. x x) can be type annotated in system F
14:39:18 <shrimpx> ya
14:39:45 <shrimpx> and a lambda is always a value
14:40:06 <wagle> (\x . x x) (\x . x x) is non-reducible
14:40:33 <shrimpx> it is, it's reducible forever :)
14:40:56 <wagle> then i dont know what you mean by non-reducible
14:41:04 <esap> shrimpx: non-reducible is defined as that its reduction doesn't change the expression.
14:41:06 <shrimpx> stuck. there's no evaluation rule that matches
14:41:12 <shrimpx> ah
14:41:12 <shrimpx> ok
14:41:21 <wagle> then its reduced
14:42:56 <shrimpx> so i guess when i said non-reducible i meant stuck.
14:43:25 <esap> Actually the difference between 'stuck' and 'non-reducible' is an interesting concept.
14:43:47 <shrimpx> i think some literature uses them interchangeably
14:43:57 <wagle> i took non-reducible to mean either that (1) there exists no finite sequence of redexes that ends with a terms with no redexes, or (2) the preferred order of redexes (normal order, applicative order, etc) doesn't produce such a finite sequence
14:44:30 <wagle> what is the difference between stuck and normal-form?
14:46:07 <shrimpx> hmm
14:46:23 <shrimpx> i need to get my terminology up to date
14:47:09 <wagle> your terminology might be more uptodate than mine
14:47:27 * esap has constant problems with my understanding of standard terminology.
14:47:41 <shrimpx> k. so "stuck" == "normal form but not a value"
14:48:02 <wagle> ahh
14:48:19 <wagle> (x x)
14:49:00 <wagle> (1 (\x . x))
14:49:23 <esap> self_apply :: (forall c. c -> c) -> d -> d ; self_apply x = x x
14:50:27 <shrimpx> (\x.x x) is not stuck, but (1 2) is
14:50:41 <shrimpx> or even ((\x:Nat.x) True)
14:50:41 <wagle> can you actually get stuck in the lambda calculus if your top level term has no free vars?
14:50:50 <wagle> can you actually get stuck in the >pure< lambda calculus if your top level term has no free vars?
14:51:23 <esap> wagle: well you can write an infinite loop in lambda calculus: (\x -> x x) (\y -> y y)
14:51:29 <wagle> pure utyped.  sigh
14:51:41 <wagle> esap, but thats not stuck
14:51:47 <stefan_> (1 1) is
14:51:53 <wagle> 1 is not pure
14:52:16 <wagle> x, x y, and \x . y
14:52:28 <shrimpx> since all you ahve is lambdas, i don't think you can get stuck, since as long as you have an APP node, the thing on the left is guaranteed to be a lambda
14:52:32 <stefan_> both have free vars
14:53:13 <shrimpx> that is if you _start_ with a closed term
14:53:20 <shrimpx> but i'm not sure
14:53:50 <wagle> i think i now remember a theorem in barendregt for closed terms
14:54:08 <wagle> (not a terribly interesting one)
14:56:22 <shrimpx> i remember while going through pierce i always had a hard time remembering that evaluation rules don't care at all about types. so in fact ((\x:Nat.x) True) is not stuck
14:56:26 <stefan_> wagle: it still depends on what you consider a value; pierce, to whom you were referring, f.i., doesn't consider terms of function type values iirc; so then \x . x is stuck
14:56:42 <shrimpx> stefan_: lambdas are values
14:57:06 <esap> shrimpx: You have to assume type checking succeeds before you start evaluating.
14:58:06 <shrimpx> in the system as a whole, but i was just saying that when given the evaluation rules and the term above, i would feel tempted to say "can't be evaluated"
14:58:10 <shrimpx> just me
14:58:40 <stefan_> shrimpx: yep, you made my run for the book, actually ... he does consider lambdas values :)
14:59:13 <esap> shrimpx: Well I'd say that's true, but not because of anything in the evaluation rules, but because you never get to evaluate due to the type system.
15:00:27 <esap> shrimpx: Evaluation rules don't have to work for anything that's prevented by the type system.
15:01:14 <stefan_> esap: that's because ill-typed terms aren't considered part of the language, are they?
15:02:28 <esap> shrimpx: Right. Or you could consider it as 'eval :: Context -> WellTypedExpr -> Value', where WellTypedExpr would be restricted to well-typed terms.
15:02:39 <esap> s/shrimpx/stefan_/
15:03:34 <shrimpx> esap: i think the important note is that ill-typed term _might_ evaluate. that becomes crucial when you do desugaring into a typed language.
15:04:25 <stefan_> shrimpx: could you elaborate on that?
15:04:25 <esap> shrimpx: Well it might, but I think that's not required, is it?
15:06:05 <esap> I can imagine a language where intermediate expressions produced during evaluation are not well-typed, but I guess that's pretty obscure.
15:06:39 <shrimpx> hmm
15:06:55 <stefan_> esap: I guess I'd be pretty hard to reason about programs in such a language
15:07:45 <esap> stefan: Yes true. It breaks the most basic property of reduction, subject reduction.
15:08:43 * esap thinks.
15:09:06 <shrimpx> i think in such a language, you could pretty simply show that preservation doesn't hold :)
15:09:20 <stefan_> lol
15:10:30 <stefan_> to get back to the issue of values vs. terms: Mitchell identifies values as terms of 'observable', i.e., printable, type; a program is then a closed term of observable type, i.e., one yielding a value
15:11:26 <shrimpx> what's a printable type?
15:11:49 <esap> I would think of values as equivalence classes of terms based on the reduction.
15:12:17 <wagle> if you work, functions are actually printable
15:12:38 <stefan_> shrimpx: ints or bools, f.i., and pairs and sums of printable type
15:12:51 <wagle> but the common wisdom is that functions arent printable, in the way i imagine mitchell thinking
15:13:32 <shrimpx> makes sense
15:14:44 <wagle> hmm..  observable might have a less adhoc meaning of being able to observe (decide) equality..  the printability thing seems a red herring
15:15:20 <shrimpx> can't you decide equality on arrow types?
15:15:26 <stefan_> iirc, operational equivalence is shown much easier for programs, rather than terms; from that result operational equivalence for terms is deduced by introducing the concept of a context, i.e., a term with a hole
15:15:32 <wagle> shrimpx: i dunno
15:15:35 <shrimpx> shrug
15:17:02 <stefan_> do I make sense? (it's been a long time ;))
15:17:11 <wagle> i'm just trying to give a sensible/interesting meaning to "observable" without actually having mitchell in hand to figure out what he meant
15:17:38 <esap> stefan: Yes, that sounds reasonable. I'm still thinking about the context part, whether it's a good assumption that a context is a term with a hole.
15:17:40 <wagle> (i feel "printability" is not interesting
15:17:42 <wagle> )
15:17:59 <esap> stefan: That might work only for pure languages.
15:19:00 <stefan_> I did not mean a context as in a denotation assignment for variables
15:20:31 <stefan_> C[ ] = (\x . x) [ ]
15:21:16 <esap> right, I think that's pretty standard thing. But I'm still wondering how that idea works for impure languages.
15:21:45 <stefan_> if M and N are terms, I condider them operational equivalent iff C[M] and C[N] are programs and C[M] ~= C[N], where ~= denotes a Kleen equation.
15:21:59 <stefan_> Kleene, that is
15:22:17 <wagle> felleisen did some stuff with assignment with that sort of notation in the mid to late 80's
15:22:34 <stefan_> esap: I don't think it'll work for impure languages :)
15:22:43 <wagle> .. and i saw him refer back to it recently..  (trying to find where, now)
15:23:14 <shrimpx> esap: so about the equivalence class thing, you mean that a value and the equivalence class of terms that evaluate to that value are isomorphic, right?
15:23:21 <wagle> maybe it was the recent thread on the =types mailing list?
15:23:41 <esap> shrimpx: yes.
15:24:05 <shrimpx> cool
15:24:11 <shrimpx> never thought about it that way
15:24:13 <stefan_> shrimpx, esap: whouldn't you say that the value *is part of* the class?
15:25:02 <wagle> yeah..  =types..  he did continuations and assignment in his thesis work
15:25:02 <shrimpx> the reduction relation doesn't apply to the value...
15:26:14 <wagle> where there was an interesting interaction between the contexts, "top level", and continuations..  and the notion of shift/reset continuations appeared
15:26:32 <stefan_> shrimpx: I'd say it does, since we're talking about the reflexive, transitive closure of one-step reduction. then, being a term itsself, a value is clearly related to itsself
15:26:40 <wagle> i was more interested in continuations than the sigma/assignment stuff..
15:27:23 <esap> shrimpx: An important thing there is that an equivalence class can be defined as a pair of (reduction, normal-form). So a reduction describes a set of equivalence classes.
15:27:46 <shrimpx> ah yeah.
15:28:19 <wagle> what if you dont have the diamond property?
15:28:38 <esap> Well obviously you have to assume Church-Rosser there.
15:28:43 <wagle> (err, confluence)
15:29:43 <esap> If you don't have that, then the corresponding equivalence class is somehow vaguely defined.
15:30:14 <palomer> are there any books on writing a compiler or computer algebra system in haskell?
15:30:40 <esap> Which just means in that case you need to use some other mechanism for describing that, I guess.
15:30:44 <stefan_> palomer: what part of a compiler are you interested in?
15:31:12 <shrimpx> without the diamond property, a term can evaluate to two NF's, right?
15:31:37 <esap> right.
15:31:38 <palomer> stefan_: erm, any kind
15:32:20 <shrimpx> so you can still define values as equivalence classes with some overlap
15:32:36 <stefan_> palomer: I guess lexing and parsing can be studied in isolation
15:33:19 <esap> shrimpx: Hmm.. I think I see what you're getting at. Maybe define the value as equivalence classes of _all_ normal forms of a term in that case [I'm not sure that can be called value, but it would be a similar concept].
15:34:29 <wagle> the union of all equivalence classes must be the entire set. the pairwise intersections must all be empty.
15:34:49 <shrimpx> so the diamond property is good to have! :)
15:34:50 <stefan_> palomer: this might fit your needs, although it does not treat lexing/parsing: http://www.cs.uu.nl/groups/ST/twiki/pub/Ipt/CourseLiterature/ipt-20040123-dikt.pdf
15:35:27 <jadrian> I got 2 modules. A and B, both define a function f
15:35:39 <jadrian> I import them both from a module C
15:35:39 <stefan_> shrimpx: a excellent conclusion! :)
15:36:25 <jadrian> now if I do   :t A.f   I get   f :: Type1 -> Type2 
15:36:49 <esap> The diamond property ensures that every expression has at most one result. But maybe we want to allow an expression to have multiple results, chosen nondeterministically.
15:36:54 <wagle> stefan_, shrimpx: what if i didnt get the same answer?
15:36:57 <jadrian> but when I do  t: B.f   I get   f :: B.Type1' -> B.Type2'
15:37:04 <jadrian> with namespaces :/
15:37:25 <jadrian> now the really weird part is that in C I cannot even use Type1' nor B.Type1' 
15:37:35 <wagle> esap: i hear powerset semantics is horrifying
15:37:45 <shrimpx> esap: i'm working on a project (involving the language Curry) where the diamond property does not hold, depending on who you ask =)
15:37:46 <esap> wagle: powerset semantics?
15:37:47 <jadrian> is this some ghci bug?
15:38:26 <wagle> semantics where you get the set of all possible answers..  and combinatorial explosions thereof
15:38:29 <stefan_> jadrian: are the types exported as well?
15:38:52 <stefan_> wagle: haven't look at that ever ... sounds nasty
15:39:02 <jadrian> stefan_: well I used no export list, I think it should export everything in that case right?
15:39:24 <stefan_> jadrian: yes, it should
15:39:24 <jadrian> stefan_: besides how can you export  f, and not export the types on its signature?
15:39:44 <shrimpx> in curry you can say (coin = 0; coin = 1). then (coin) evaluates to either 0 or 1, nondeterministically
15:39:50 * esap likes horrifying semantics. Clearly I must learn more about that...
15:39:53 <wagle> modern model checking seems to have ways to handle combinatorial explosions..  maybe you can do one of their tricks
15:40:16 <jadrian> stefan_:  in fact I have in C:   f = B.function
15:40:26 <jadrian> stefan_:  and it works (without the type signature)
15:40:42 <palomer> stefan_: do you have any books on lexing and parsing in haskell?
15:40:55 <jadrian> stefan_:  in ghci I get  :t f    f:: B.Type1' -> B.Type2'
15:41:07 <jadrian> stefan_:  and if I copy that signature to C it doesn't work
15:41:38 <wagle> esap: i imagine you could have some sort of typing/constraint on the non-determinism so that your favorite model checker can handle it
15:41:57 <esap> wagle: of course.
15:42:31 <esap> wagle: I already know some mechanisms for doing that, basically from some concurrent ways of building object-oriented programs.
15:42:33 <wagle> the question is "what interesting things cant you do" and "what interesting things can you do"?
15:42:58 <stefan_> jadrian: do you only experience problems from GHCi? what happens when you actually compile your code?
15:43:14 <wagle> esap: got any keywords for me to search with?
15:43:16 * stefan_ is not sure how GHCi handles imports
15:44:06 <esap> wagle: well CFFD equivalance, service-oriented architecture are two keywords that might bring up something.
15:45:23 <jadrian> stefan_: let me try
15:45:53 <stefan_> jadrian: mmm, I can't really reproduce your problems
15:46:28 <wagle> esap: thanks
15:46:33 <esap> wagle: The service oriented architecture stuff is pretty badly hyped, so might be hard to find anything useful :-)
15:47:09 <wagle> "decoupling"..  8)
15:47:44 <jadrian> stefan_: same in compilation
15:47:55 <jadrian> stefan_: but I cannot reproduce with a minimal example either
15:48:16 <stefan_> jadrian: ouch ...
15:49:05 <jadrian> stefan_: still here I am,  
15:49:05 <jadrian> *T2MT> :t f
15:49:05 <jadrian> f :: MetaLogica.Term -> MetaLogica.FunID
15:49:08 <jadrian> but I cannot add that type siganture to f
15:49:21 <jadrian> and I have no idea why does it show the namespaces
15:49:25 <stefan_> jadrian: can't you just import the modules as qualified?
15:49:55 <jadrian> stefan_: sorry don't rememeber what the term means...
15:50:05 <jadrian> "qualified" that is...
15:50:48 <stefan_> jadrian: just use  import qualified MetaLogica
15:51:02 <musasabi> If I want to match a candidate string against 20 (constant) candidates, should I use 1) alist, 2) FineteMap 3) function like fun "foo" = ... fun "bar" = ... ?
15:52:01 <jadrian> stefan_: I get the same
15:52:10 <stefan_> musasabi: of course it really depends on your particular situation, but I'd say a finite map
15:52:13 <jadrian> stefan_: it just loads without the type signature
15:53:21 <stefan_> jadrian: what can I say? you're doomed ... ;) ... I'm not sure what time zone you're in, but I would be pretty frustrated: here it's Saturday for almost an hour now :)
15:54:13 <musasabi> stefan_: thanks.
15:54:24 <stefan_> musasabi: in general, a finite map performs better than a list, and it scales better than the solution requiring pattern matching on constants
15:54:30 <stefan_> musasabi: you're welcome
15:54:58 <jadrian> stefan_: 23:54 :/
15:55:28 <stefan_> jadrian: sounds like a great start for the weekend
15:56:31 <jadrian> stefan_: it's worst than I thought
15:56:32 <wagle> jadrian: 3:54
15:56:36 <wagle> 8)
15:56:38 <jadrian> wagle: damn :)
15:56:47 <jadrian> stefan_: it has nothing to do with name clashes
15:57:02 <jadrian> stefan_: if I import just MetaLogica I have the same prob
15:57:34 <wagle> hmm.. you must be in england or so
15:57:35 <jadrian> stefan_: that is, I cannot use the type declared on MetaLogica for some reason
15:58:26 <stefan_> jadrian: well, then you're actually making progress ... just have to look at MetaLogica now ... how many imports are there in MetaLogica, how many lines of code? ;)
15:59:09 <jadrian> stefan_: going to start cutting it to a minimal example ;)
15:59:45 <stefan_> jadrian: good idea ... let's see if you solved this before wagle tracks down your exact location :)
16:01:20 <jadrian> stefan_: hooray I found it :(
16:01:50 <stefan_> jadrian: are you willing to share?
16:01:54 <jadrian> stefan_: I was actually exporting functions explicitly, but not types... 
16:02:07 <jadrian> stefan_: I missed it cause I'm using literate programming
16:02:14 <jadrian> stefan_: so I have lots of LaTeX there
16:02:20 <jadrian> stefan_: and I mean lots
16:02:32 <jadrian> stefan_: and the export was in the middle of it
16:02:50 <stefan_> jadrian: hey, not exporting types ... someone asked for that a few minutes ago? ;)
16:03:03 <jadrian> stefan_: I had even looked for it before lol
16:03:22 <jadrian> stefan_: I just saw it after deleting the LaTeX stuff :/
16:03:45 <jadrian> stefan_: I should have looked at the dvi instead...
16:03:53 <stefan_> jadrian: I'm just glad your weekend isn't ruined after all :)
16:03:57 <jadrian> thinks look less confuse there
16:04:03 <jadrian> stefan_: me too lol
16:04:44 * stefan_ is going to get some sleep ...
16:05:44 <stefan_> hope I won't dream of wagle's horrifying powerset semantics :)
16:06:34 <stefan_> goodnight, all!
16:07:52 <wagle> bwahaha
16:31:39 <musasabi> I am trying to make sense of prelude.read no parse errors, I have code like:
16:31:41 <musasabi> scanner (c:cs)    = Word (read num) : scanner rest
16:31:41 <musasabi>     where (num,rest) = span wordChar cs
16:32:18 <musasabi> There seems to be an error even if I make wordChar x = False.
16:35:23 <musasabi> solved it...
17:32:29 <shrimpx> from p(c) \/ a, you can infer exists x.p(x) \/ a if x does not occur free in a, right?
17:42:26 <Cale> shrimpx: yeah, I don't see why not :)
17:46:27 <shrimpx> was working on a proof for the equivalence exists x.t(x) === forall y.(forall x.t(x) -> y) -> y
17:46:53 <shrimpx> that pierce gives for encoding existentials in system f
17:52:47 <Cale> Well, suppose there is such an x for which t(x). Then the assumption that for any x, if we have t(x), we have y, and the existence of such an x, gives us y. That's one way :)
17:53:26 <shrimpx> ya. it seems obvious after you stare at it for a while... i gave a formal derivation taht seems to work
20:12:21 <dtb> qs (h:t) = qs (filter(< h)t)++[h]++(filter(>= h)t)
20:12:46 <dtb> sure beats my:
20:12:48 <dtb>  
20:12:50 <dtb> get_ltitem x [] = []
20:12:50 <dtb> get_ltitem x (h:list) = if h < x then h:rest else rest
20:12:50 <dtb>         where
20:12:50 <dtb>                 rest = get_ltitem x list
20:12:50 <dtb>                 
20:12:56 <dtb> get_gtitem x [] = []
20:12:58 <dtb> get_gtitem x (h:list) = if h > x then h:rest else rest
20:13:00 <dtb>         where
20:13:02 <dtb>                 rest = get_gtitem x list
20:13:04 <dtb> quicksort [] = []
20:13:07 <dtb> quicksort (h:list) = less ++ [h] ++ great
20:13:10 <Smerdyakov> And not pasting long programs sure beats pasting them.
20:13:11 <dtb>         where
20:13:11 <dtb>                 less = quicksort (get_ltitem h list)
20:13:14 <dtb>                 great = quicksort (get_gtitem h list)
20:13:14 <thebug> this isn't emacs ...
20:13:16 <dtb>  
20:13:23 <dtb> :D
20:13:50 <Smerdyakov> Please don't do that again.
20:14:10 <dtb> :D k
20:14:34 <dtb> soz learning haskell - stoked
20:15:00 <Smerdyakov> And please don't use British slang like "soz." >:p
20:15:20 <dtb> pop quiz -> whats an endofunctor with two natural transformations?
20:15:44 <Smerdyakov> Your mom riding a rhino
20:15:53 <dtb> :D close
20:18:19 <thebug> that was 'different'
20:22:32 <emu> look what your popularization of Haskell has caused!
20:22:55 <thebug> widespread chaos and mayhem?
20:23:26 <emu> We must stop the spread before it's too late!
20:23:33 <Riastradh> Indeed.  At times I'm glad that a vast quantity who claim to be 'programmers' force themselves to suffer with C++.
20:25:24 * Smerdyakov throws a supersonic "hello" at emu.
20:56:52 <shrimpx> i have a question about existential types. the people who defend use of 'forall' in the definition of an existential type do so because an existential type constructor has universal type, right?
21:17:39 <arauko> i only can define functions in a file?
22:01:44 <arauko> mysignum x =
22:01:44 <arauko>     if x < 0
22:01:44 <arauko>        then -1
22:01:44 <arauko>     else if x > 0
22:01:44 <arauko>        then 1
22:01:44 <arauko>        else 0
22:03:29 <arauko> i dont get the correct result for a negative value
22:06:46 <arauko> mm...
22:21:05 <Smerdyakov> What do you get?
23:24:50 <stefan_> mmm ... lots of you were here when I finally went to sleep just a few hours ago ... don't _you guys_ sleep? do some of you live here? :)
23:25:03 <stefan_> anyway, goodmorning all!
23:25:26 <Riastradh> Good morning!
23:25:40 <Riastradh> (very, very early morning, 2.30, but morning nevertheless)
23:26:07 <stefan_> 8.26am here :)
23:40:22 <cm> same :)
23:51:04 <heatsink> What extension goes on the end of ghc library files?
23:51:31 * heatsink can't compile because of a bunch of linker errors
