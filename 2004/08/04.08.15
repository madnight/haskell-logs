00:08:04 <SamB> heatsink: it does have a scheme counterpart! only the scheme counterpart generates lots of ugly macroexpansion!
00:09:48 <SamB> oh, and haskell functions have fixed arity
00:20:05 <heatsink> hmm, okay
00:49:13 <arauko> i always need to write 
00:49:14 <arauko> module Main
00:49:14 <arauko>     where
00:49:31 <arauko> what is the "where" for??
00:50:16 <LrdMtrod> ohh this is better then #haskell@efnet
00:51:04 <heatsink> Where delimits the contents of main
00:51:23 <heatsink> as for wherefor, well, wherefor is like why
00:51:27 <LrdMtrod> I'm currently learning haskell and neewd some guidance, I would appreciate if you could help me with my questions on the way
00:51:50 <arauko> heatsink, i still dont get it
00:52:18 <LrdMtrod> I got these
00:52:28 <LrdMtrod> type Segment = (Int, Int, Int, Color)   -- sx, ex, dx, color
00:52:28 <LrdMtrod> type SegmentList = [([Segment],Int)]    -- segment, y
00:52:48 <heatsink> arauko: let x = y in 
00:52:54 <heatsink> arauko: module Main where
00:53:00 <LrdMtrod> now I would like to define a variable of type SegmentList
00:53:02 <heatsink> arauko: case x of
00:53:04 <LrdMtrod> ls :: SegmentList
00:53:18 <heatsink> arauko: The structure is the same
00:54:25 <LrdMtrod> ls = [([(1,2,3, col),(4,5,6,col)]. 1)] <-- is this right
00:55:02 <stefan_> LrdMtrod: if your dot is actually a comma, it seems right
00:55:25 <LrdMtrod> yes, of course... 
00:56:26 <LrdMtrod> so did I get a list with two segments in the same slot as y=1?
00:56:50 <stefan_> LrdMtrod: yes
01:00:02 <stefan_> LrdMtrod: under the assumption that col :: Color, of course ;)
01:04:38 <LrdMtrod> yes
01:04:48 <LrdMtrod> of course... I thought that was obvious...
01:05:14 <stefan_> oh, it was ... just to be sure, though
01:05:22 <LrdMtrod> no problem'
01:06:49 <LrdMtrod> if I have a "variable" ls defined previously can I use ls inside another function to handle my parameters?
01:08:12 <stefan_> LrdMtrod: what do you mean exactly by "handle my parameters"? can you be more specific? you can need ls inside other function definitions, yes
01:09:00 <stefan_> LrdMtrod: that is, within the scoping limitation imposed by the module system etc.
01:09:29 <LrdMtrod> search :: SegmentList -> Int
01:09:29 <LrdMtrod> search sl = 
01:09:43 <LrdMtrod> where sl == ls just malwrote it in here...
01:10:06 <LrdMtrod> so I defined the sl as a variable I want to work with
01:10:29 <LrdMtrod> now is I use sl like that... it will not interfere with my variable, right?
01:11:04 <heatsink> yo defined ls at global scope?
01:11:20 <LrdMtrod> now there is some terminology I haven't learned yet
01:11:25 <LrdMtrod> however it is global...
01:11:39 <LrdMtrod> I just got:
01:11:44 <heatsink> yes, the parameter ls overrides the global ls
01:11:44 <stefan_> heatsink, LrdMtrod: yes, he did :)
01:11:55 <LrdMtrod> hhe
01:12:06 <stefan_> heatsink, he named his parameter sl, not ls
01:12:20 <LrdMtrod> I wrote wrong when I did the ls
01:12:34 <LrdMtrod> the parameter and the global scope is both called sl
01:12:38 <LrdMtrod> as in segmentlist
01:12:42 <stefan_> LrdMtrod, oops
01:13:24 <stefan_> LrdMtrod: okay, then inside the def of search sl refers to the parameter, not to your previously defined variable
01:14:00 <LrdMtrod> okay, I just wanted to be sure I didn't do any thing crazy...
01:15:38 <LrdMtrod> http://www.haskell.org/learning.htm <-- doesn't work!
01:15:58 <LrdMtrod> anyway, I think I got this straight... but I'm a little bit unsure how to write it...
01:16:20 <LrdMtrod> I want to fetch the first Int in [Segment] of the SegmentList
01:16:51 <LrdMtrod> x | xs<-Segment or what?
01:18:14 <heatsink> learning.html
01:19:03 <stefan_> LrdMtrod: i'd suggest you first write a function that returns the first Int of a single Segment, ok?
01:19:09 <heatsink> LrdMtrod: the indexing operator is !!
01:19:24 <stefan_> getFirstInt :: Segment -> Int
01:19:56 <heatsink> [5,6,7] !! 0 returns 5
01:20:12 <LrdMtrod> okay... One of my problems with this language is that I can't make divide the problem to enough subproblems
01:21:05 <stefan_> getFirstInt (sx, ex, dx, col) = sx
01:21:23 <stefan_> LrdMtrod: simple enough isn't it
01:21:32 <LrdMtrod> yes
01:21:52 <stefan_> LrdMtrod: but now you want getFirstIntList :: SegmentList -> Int, right?
01:22:06 <LrdMtrod> I would however prefer to fetch any one of the data in segment with one function
01:22:15 <LrdMtrod> mmm
01:23:39 <stefan_> LrdMtrod :: then, I'd really suggest choosing a different datastructure, but to keep it simple, we could write a function that does it for this type, okay?
01:24:00 <stefan_> LrdMtrod: so, you want getInt :: Int -> Segment -> Int, okay?
01:24:12 <LrdMtrod> okay
01:24:58 <stefan_> getInt 1 (sx, ex, dx, col) = sx
01:25:16 <stefan_> getInt 2 (sx, ex, dx, col) = ex
01:25:25 <stefan_> LrdMtrod: etc.
01:25:35 <LrdMtrod> allright
01:26:25 <LrdMtrod> could I do a unkown output
01:26:34 <LrdMtrod> so would be able to get the col as well
01:27:03 <stefan_> not with the same function: the types wouldn't be okay then
01:28:16 <LrdMtrod> I wuld be able to do getInt :: String -> Segment -> Int
01:28:35 <LrdMtrod> getInt "sx" segment
01:29:04 <musasabi> morning
01:29:07 <LrdMtrod> hej
01:29:43 <heatsink> I don't think you can match arrays like that... stefan_?
01:30:35 <stefan_> LrdMtrod, heatsink: you can do that in the same fashion, if you really want ... but, as said, you probably want another data structure
01:30:36 <heatsink> oh you can
01:30:53 <stefan_> getInt "sx" (sx, ex, dx, col) = sx
01:31:25 <LrdMtrod> I can't work with any other datastructure, as I try to emulate something from another environment
01:32:38 <heatsink> why?
01:33:05 <LrdMtrod> well, it's how the datastructure looks like in my mind, and would be easy to cope with in C
01:33:37 <LrdMtrod> I code haskell now, as in a form of pseudo code for analyzing my algos and at the same time learning the language
01:33:55 <LrdMtrod> I do however intend to code this in C later as I'm working with a GBA game...
01:34:50 <LrdMtrod> Can't use haskell for that, the GBA wouldn't be able to handle the workload associated with the function types which makes haskell such a nice language
01:35:03 <LrdMtrod> and I don't have a compiler either...
01:35:14 <LrdMtrod> for GBA that is...
01:35:37 <heatsink> Well, there are a lot of C idioms that you can't do in haskell without a lot of awkwardness
01:35:47 <LrdMtrod> mmmhm
01:36:00 <LrdMtrod> anyway, now how do I reach that Segment in my SegmentList?
01:36:16 <stefan_> LrdMtrod: which segment?
01:36:33 <LrdMtrod> type SegmentList = [([Segment],Int)]    -- segment, y
01:36:51 <LrdMtrod> I want to get access to the list of Segment associated with a specific y
01:37:47 <stefan_> LrdMtrod: how is your Color type defined?
01:37:59 <LrdMtrod> getSegment :: Int -> SegmentList -> Segment
01:38:10 <LrdMtrod> type Color = String
01:38:13 <stefan_> okay
01:38:35 <stefan_> first define: swap (x, y) = (y, x)
01:38:51 <LrdMtrod> why would I want that?
01:39:07 <stefan_> LrdMtrod: you'll see :)
01:41:01 <LrdMtrod> allright
01:41:24 <stefan_> LrdMtrod: is the type of getSegment you gave correct? now it'll give you a single segment, while many can be associated with the y value you are searching for
01:41:44 <stefan_> LrdMtrod: which segment do you want to get from the function?
01:41:46 <LrdMtrod> no I forgot to add [Segment}
01:41:50 <LrdMtrod> *]
01:42:21 <LrdMtrod> I want to get the first anyway though!
01:42:28 <stefan_> LrdMtrod: so you have getSegment :: Int -> SegmentList -> [Segment]?
01:42:42 <LrdMtrod> as it is now, but can probably be changed fi needed
01:43:09 <stefan_> okay, define force (Just x) = x ... we'll discuss if this is good idea later
01:43:41 <heatsink> we're going to be using Maybes?
01:44:36 <stefan_> then: getSegment n = force . lookup n . map swap
01:44:49 <stefan_> heatsink: yes, we are ...
01:45:04 <LrdMtrod> When I define swap can I do: swap :: (Int) -> (int)?
01:45:20 <stefan_> swap :: (a, b) -> (b, a)
01:45:25 <LrdMtrod> ahh
01:45:38 <stefan_> force :: Maybe a -> a
01:46:17 <LrdMtrod> hmm, what does a . do?
01:46:36 <stefan_> function composition
01:46:41 <stefan_> @type (.)
01:46:43 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
01:47:27 <LrdMtrod> soit reroutes the function
01:47:33 <stefan_> LrdMtrod: so, this works ... now you may want to spend some time to figure out why it actually works ... and then why really you don't want to do it this way
01:47:39 <heatsink> Is that (force . lookup) (n . map) swap? Or ((force . lookup) n) . map) swap?
01:47:45 <stefan_> LrdMtrod: so, it
01:47:57 <LrdMtrod> of course...
01:48:23 <stefan_> force (lookup n) . map swap
01:48:25 <Lor> stefan, force is already defined in the standard Maybe module. It's name is "fromJust".
01:48:50 <stefan_> Lor: oops, yes
01:49:04 <Lor> s/it's/its/
01:50:52 <stefan_> LrdMtrod: point is: the definition we came up with (well, I came up with) is completely driven by the type you wanted it to have ... but your type does not take into account the possibility that the segment list does not contain an entry for the search key ... that's why we are using force/fromJust which has a bad smell to it here ...
01:52:18 <LrdMtrod> well I don't want anything if there isn't any segments in the list
01:52:30 <LrdMtrod> so I would want a [] or NULL in C
01:53:04 <LrdMtrod> hmm, I don't give any parameters to swap, how does the map handle that...
01:53:04 <stefan_> so, what you really want is getSegment :: Int -> SegmentList -> Maybe Segment
01:53:20 <LrdMtrod> okay
01:54:44 <stefan_> "getSegment n = fromJust . lookup n . map swap" is more or less another way to write getSegment n sl = fromJust (lookup n (map swap sl))"
01:55:23 <LrdMtrod> I thought $ added parenthesis
01:55:29 <stefan_> in Haskell, function can be _partially_ applied
01:55:45 <LrdMtrod> stefan_: I know about that partially applied...
01:56:19 <LrdMtrod> hmm, can't find anything about the lookup
01:56:50 <stefan_> LrdMtrod: well, about the parentheses: h = g . f ~~~> h x = g (f x)
01:57:03 <stefan_> @type lookup
01:57:05 <lambdabot> lookup :: forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
01:57:06 <LrdMtrod> ahh f bol g
01:57:55 <LrdMtrod> so the dot is the same thing as putting a dot in math between 2 functions intertweening them booth
01:58:07 <stefan_> exactly
01:58:26 <LrdMtrod> what about $ how does that work?
01:58:36 <stefan_> f $ x = f x
01:59:21 <heatsink> a b c d $ e f g h = (a b c d) (e f g h)
01:59:27 <LrdMtrod> okay
01:59:43 <stefan_> it's the same as the invisible operator in a normal function application, except that is associates to the right
02:00:17 <LrdMtrod> concat $ replicate l c => concat(replicate l c)
02:01:00 <stefan_> LrdMtrod: yes
02:01:45 <stefan_> f l = concat $ replicate l ~~~> f l c = concat (replicate l c)
02:03:44 <heatsink> That means (concat $ replicate l) c --> concat (replicate l c), right?
02:04:32 <stefan_> I meant a (.) instead of ($) in that last line :)
02:05:38 <LrdMtrod> Where can I find a list of all kinds of these fromJust, lookup, map, etc and what they do?
02:05:42 <stefan_> (concat . replicate l) c ~~~> concat (replicate l c)
02:05:52 <LrdMtrod> my book doesn't seem to have them collected in an easy accesable way!
02:06:09 <heatsink> stefan: zvon.org has a good reference
02:06:22 <Cale> http://www.haskell.org/onlinereport/
02:06:23 <Cale> there
02:06:24 <heatsink> but you won't find it there if you don't know what you're looking fore
02:06:29 <Cale> Check the prelude
02:06:43 <Cale> (chapter 8)
02:06:47 <Cale> and the libraries
02:07:39 <heatsink> Hmm, that's not right
02:07:46 <heatsink> The prelude should come before the introduction
02:08:04 <stefan_> heatsink: :)
02:11:31 <LrdMtrod> what is a Just and Maybe?
02:11:53 <stefan_> data Maybe a = Nothing | Just a
02:13:16 <Cale> Here, "Nothing" is a value in the "Maybe a" type which doesn't carry a value of type a, and "Just a" is another, which does.
02:14:11 <heatsink> LrdMtrod: (It's like a C union that remembers which union member it really is)
02:14:37 <Lor> Hm, in English, the word "family" means both "the people you live with" and "the people who are your relatives". Is there any easy way to make it explicit which meaning is intended?
02:14:38 <LrdMtrod> haskell is a language of wonders...
02:14:47 <stefan_> so a function that has Maybe Segment as a result type gives you either Nothing (no segment) or Just s (the segment s) for some s :: Segment
02:14:55 <heatsink> Lor: biological family
02:15:18 <heatsink> yes
02:15:52 <Lor> Hm, right. But that's not a word you'd use in common parlance when talking about people.
02:16:49 <Cale> Lor: you could just say "relatives", or "the people you live with"
02:16:58 <Lor> There is "clan" of course, but that's also a bit unusual.
02:18:00 <Lor> Hmm... kindred.
02:18:36 <heatsink> tribe. kith.
02:18:47 <Lor> Ah, "kinsfolk", now there's a word.
02:20:22 <LrdMtrod> t;t;t;t...
02:26:44 <stefan_> LrdMtrod: still want to go back to C now? ;)
02:27:22 <heatsink> stefan_: Maybe :)
02:27:37 <LrdMtrod> stefan_: coding for the GBA, and I don't have much of a choise...
02:28:16 <stefan_> LrdMtrod: yeah, but do you still _want_ to? :)
02:29:10 <LrdMtrod> hehe, well I always liked haskell even though I can't code with it... I like it because it's so little to write,
02:29:53 <LrdMtrod> and that it's so automaticly understands and do stuff behind the scene
02:30:35 <Cale> ack - wiki spam!
02:30:46 <heatsink> I don't think haskell automatically understands and does suff behind the scenes...
02:30:48 <LrdMtrod> However C has it's uses as I can controll in such pentious ways...
02:30:52 <heatsink> Yeah, spammers spam wikis now
02:30:52 <Cale> look at it all!
02:31:01 <Marvin--> scumbags
02:31:02 <heatsink> pentious?
02:31:23 <LrdMtrod> heatsink: compared to C, you can do infinity lists and stuff... you can't do that in C without segfaulting, at least not in such easy way as in haskell
02:32:12 <heatsink> A list is not a special type in Haskell
02:32:53 <stefan_> yeah, blogging software comes with moderation tools for comments now, just because of spammers, but well ... a moderated wiki ... ?
02:33:03 <heatsink> data List a = Nil | Cons a List
02:33:32 <heatsink> which in C would be struct list {int type; struct list *next;}
02:34:00 <heatsink> Haskell isn't doing much behind the scenes
02:34:03 <stefan_> heatsink, LrdMtrod: I think he meant stuff like type inference when he said "behind the scenes"
02:34:23 <heatsink> okay...
02:34:31 <stefan_> heatsink, LrdMtrod: and [1 ..] is kind of hard to do in C :)
02:34:41 <LrdMtrod> mmm
02:34:47 <heatsink> I think if you had to rewrite the prelude, though, you'd get the sense that haskell isn't doing much behind the scenes.
02:35:43 <LrdMtrod> well that [1 ..] is major behind the scene IMHO!
02:35:53 <stefan_> heatsink, LrdMtrod: the only thing "special" about special types like [] and (,) is their syntax ... besides that they're just ordinary types
02:36:18 <heatsink> True that it is much easier to make abstractions in haskell
02:37:05 <heatsink> I've often griped silently about how much code I have to write to do the equivalent of a lambda expression in C
02:37:21 <stefan_> LrdMtrod: I would not say that evaluation order is a "behind the scenes" issue ... it's just a non-syntactic feature of a programming language ... as it is in C or any other language
02:40:28 * heatsink tried to print the value of [1 ..] in hugs
02:40:54 <heatsink> hugs wants to show you the whole thing
02:41:09 <heatsink> it wouldn't be so concise in C for sure
02:42:09 <stefan_> heatsink: so, it seems like hugs gives you what you ask for ;)
02:43:14 <musasabi> it would be nice of it to be able to print cyclic data structures...
02:43:33 <stefan_> LrdMtrod, heatsink: [1 ..] itself is not hard to express in C at all, using it is a different story
02:43:42 <heatsink> can you make a cyclic data structure in haskell?
02:44:16 * heatsink could make an iterator for [1 ..] in C++
02:44:18 <LrdMtrod> hmm ghci says fromJust isn't defined anywhere
02:45:00 <stefan_> heatsink: but then you're actually mixing use and definition explicity
02:45:42 <stefan_> LrdMtrod: it's in the Maybe module: import Maybe
02:46:19 <heatsink> stefan_: what use?
02:47:10 <stefan_> heatsink: iterating over it :)
02:47:53 <stefan_> heatsink: about cycles ... with STRef inside the ST monad you can, can't you?
02:48:11 <heatsink> what is that?
02:48:48 <stefan_> mutable references
02:49:00 <musasabi> heatsink: yes.
02:49:26 <heatsink> hmm, that would do it
02:49:27 <stefan_> so you can do "real" imperative programming in Haskell ;)
02:49:33 <heatsink> Does haskell have cyclic GC?
02:49:45 <musasabi> heatsink: http://www.haskell.org/hawiki/TyingTheKnot
02:51:14 <musasabi> heatsink: define cyclic GC.
02:52:20 <heatsink> identifying and reclaiming data that is referenced but unreachable
02:53:21 <musasabi> heatsink: only reference counting lacks the support for that.
02:53:22 <arjanb> heatsink: that's only a problem when reference counting is used for GC
02:53:22 <heatsink> reclaiming memory
02:53:39 <heatsink> right
02:56:45 <heatsink> stefan_: What operations can you do with a haskell list, besides taking elements off its head and examining them?
02:57:11 <musasabi> Why does haskell have a bool datatype?
02:57:24 <maihem> What methods of GC are there?
02:57:25 <musasabi> instead of Maybe Unit 
02:57:26 <Cale> musasabi: why shouldn't it?
02:57:40 <Cale> oh
02:57:42 <musasabi> Cale: because it does not fit in very well.
02:57:53 <Cale> well, it's nice to write True and False
02:58:02 <stefan_> heatsink: see what you're getting at and you're probably right :)
02:58:04 <Cale> rather than Nothing and (Just ())
02:58:49 <musasabi> maihem: ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps is a good introduction to various GC techniques.
02:59:00 <maihem> musasabi: thanks
02:59:21 <stefan_> musasabi: well, types are a form of documentation too you know ...
02:59:23 <musasabi> Cale: well one could have done just true = Just (); false = Nothing in the prelude.
02:59:37 <Cale> musasabi: what about pattern matching?
02:59:52 <Cale> and the point about documentation is good
03:00:39 <musasabi> pattern matching support for Maybe's would not be hard. And it would fit in monadic framework very well.
03:00:45 <heatsink> the train algorithm isn't in the paper... that was a cool idea
03:01:00 <stefan_> musasabi: but besides that, you're right: Bool and Maybe Unit are isomorphic to each other, modulo strictness ... 1 + 1 ~= 1 + 1 :)
03:01:59 <Cale> musasabi: why *not* have Bool?
03:02:22 <musasabi> Cale: avoid duplicating the same functionality?
03:03:34 <Marvin--> then why have Maybe when you can do that with Either?
03:03:52 <Marvin--> why have data types at all when you can do everything with Either and (,) ?
03:04:07 <stefan_> and ()
03:04:11 <Marvin--> and (), yes
03:04:50 <Marvin--> (actually, this isn't true, you'll need something recursive too)
03:05:02 <heatsink> 3 = Left Left Left ()
03:05:26 <stefan_> newtype Fix f = In (f (Fix f))
03:05:57 <stefan_> Fix, Either, (,) and () and we're done :)
03:06:09 <heatsink> what does fix do?
03:06:28 <stefan_> data ListF a r = NilF | ConsF a r
03:06:38 <stefan_> type List a = Fix (ListF a)
03:07:23 <heatsink> oh, ok :)
03:07:59 <heatsink> except I would make it f `in` (Fix f)
03:08:19 <Marvin--> In
03:08:22 <Marvin--> not in
03:08:29 <Marvin--> it's a constructor
03:08:47 <stefan_> Marvin--> but then we will still need at least one newtype to define List with just Fix, (,), Either and ()
03:09:02 <heatsink> you can have infix constructors, right?
03:09:25 <stefan_> heatsink, you can, but they will have to start with a colon
03:09:53 <stefan_> newtype ListF a r = ListF (Either () (a, r))
03:10:47 <heatsink> so that's why : starts with a :?
03:10:59 <stefan_> since we cannot do type List a = Fix (/\r -> Either () (a, r)) or something
03:11:49 <Marvin--> oh, right, we can't partially apply a type synonym
03:12:17 <stefan_> heatsink: well, it's consistent yeah, but both the type constructor and data constructor [] are not, so ...
03:12:29 <Marvin--> heatsink: and if you read carefully, it says   In (f (Fix f)),  not  In f (Fix f)
03:12:54 <Marvin--> and : is kinda hardwired into the implementations, too :-)
03:13:20 <stefan_> GHC allows infix type constructors too, btw
03:13:38 <stefan_> data a :*: b = a :*: b
03:13:47 <stefan_> data a :+: b = Inl a | Inr b
03:14:11 <heatsink> neat
03:14:55 * Marvin-- contemplates whether it makes sense to put the different gtk2hs ghc packages in different debian packages or just go with one debian package for all of it
03:16:01 <Marvin--> meh, I'll just go with one package and see if there's any demand for splitting it up later
03:19:11 <musasabi> Does the standard library really not define:
03:19:13 <musasabi> def :: Maybe a -> a -> a ; def Nothing val = val ; def (Just x) _  = x
03:19:59 <heatsink> that looks like mplus
03:20:40 <heatsink> def a b = a `mplus` (Just b)
03:20:59 <musasabi> mplus produces a value still in Maybe, no?
03:21:07 <heatsink> oh, right
03:21:21 <heatsink> def a b = fromJust $ a `mplus` (Just b)
03:21:27 <stefan_> def ma a = maybe id a ma
03:21:29 <Marvin--> @type Data.Maybe.fromMaybe
03:21:30 <lambdabot> Data.Maybe.fromMaybe :: forall a. a -> Maybe a -> a
03:21:45 <Marvin--> @type Data.Maybe.maybe
03:21:46 <lambdabot> Data.Maybe.maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
03:22:01 <musasabi> Marvin--: thanks
03:22:01 <stefan_> Marvin--: let's go for fromMaybe :)
03:22:27 <Marvin--> I find that maybe is really neat with record selection functions
03:22:51 <Marvin--> maybe defaultvalue somefield maybe_a_record
03:23:23 <heatsink> o i c
03:24:01 * heatsink falls asleep
03:24:09 <Marvin--> aw, am I that boring?
03:25:55 <stefan_> Marvin, don't get this wrong ... :) but, well ... brb
03:26:33 <Marvin--> haha
03:34:37 * Marvin-- goes back to packaging gtk2hs
03:40:31 <musasabi> how would I convert Maybe (IO ()) to IO Bool ?
03:41:10 <musasabi> that is without adding a tedious if/case into the function.
03:41:39 <Marvin--> that depends on what you want the result to be
03:43:00 <musasabi> Nothing -> IO False, Just () -> IO True
03:43:34 <Marvin--> you mean that with Just m, you execute m and return True
03:43:39 <Marvin--> there is no Just ()
03:44:30 <Marvin--> how about  maybe (return False) (>>= const (return True))
03:46:55 <musasabi> thanks.
03:59:55 <Marvin--> yikes, building gnome packages in chroots is painful
04:03:40 <stefan_> musasabi, Marvin--: even nicer, 'cause shorter ;) ... maybe (return False) (>> return True)
04:04:45 <musasabi> thanks
04:05:12 <musasabi> now it looks even readable
04:11:14 <Marvin--> stefan_: ah, true
04:13:10 <musasabi> What is the "best" cgi library out there? - http://www.pms.ifi.lmu.de/mitarbeiter/panne/haskell_libs/CGI.html ? 
04:13:16 <musasabi> Not counting WASH that is.
04:14:57 <musasabi> http://www.janweb.net/laitenbe/haskell/CGI/ seems newer.
04:15:26 <stefan_> musasabi: and newer == better? ;)
04:16:52 <musasabi> stefan_: newer version of the same library => more chance of bugs fixed or someone else being able to help with problems.
04:17:13 <stefan_> musasabi: ah, okay
04:17:41 <Marvin--> and more chances of new bugs ;)
04:17:48 <Marvin--> "for every bug fixed..." ;)
04:38:15 <musasabi> and Marlow's web server is quite dead too?
04:42:07 <shapr> ?
04:42:13 <shapr> it runs fine for me
04:43:34 <maihem> how do you do pattern matching with lambda expressions? like {fn (a:a') = blah:(fn a'); fn [] = []}
04:43:52 <musasabi> shapr: googling reveals mostly references from 2001.
04:43:57 <shapr> (\(x:xs) -> print xs)
04:44:19 <shapr> musasabi: I'm running a version of his web server that's modified by Marvin-- right now
04:45:13 <shapr> I've been using WASH and GF as apache CGI programs, but I'm trying to find some way to build an application server around that whole thing.
04:45:31 <shapr> WASH does a lot of nice stuff,though it gets weird in some ways.
04:45:46 <maihem> I have non-exhaustive patterns in my lambda expression, do I just do {\(a:a') -> (foo a):(bar a'); \[] -> []} ?
04:45:47 <shapr> maihem: or with a constructor, (\(Just x) -> x)
04:46:18 <shapr> I don't remember...
04:46:39 <musasabi> shapr: WASH + databases seem very ugly.
04:46:50 <musasabi> due to the IO issues and the table workaround.
04:46:53 <maihem> I'll try it, if all else fails I can always just use a case
04:47:21 <shapr> musasabi: maybe halipeto and HaskellDB?
04:47:52 <shapr> anyway, I'm going to watch a movie with my woman, bbl.
04:48:48 <Marvin--> maihem: no, you can't have several alternatives in a lambda
04:48:55 <Marvin--> maihem: you need to turn it into a case expression
04:50:05 <maihem> damn, Thanks Marvin-- 
04:50:07 <musasabi> have fun.
04:51:09 <maihem> anyone know how to turn (Just $ take n list) into Nothing if the length of list is < n?
04:51:32 <maihem> without ugly shit
04:57:04 <Marvin--> how about   guard (length list >= n) >> return (take n list)
04:58:04 <Marvin--> or let xs = take n list in guard (length xs == n) >> return xs
04:59:54 <Marvin--> guard is in Control.Monad, btw
05:01:03 <maihem> ooh, not bad, will haskell's lazyness stop length from actually running over the whole list once it finds out that it is >= n?
05:01:25 <Marvin--> no
05:01:39 <Marvin--> which is why I suggest the let xs = take n list route
05:03:04 <maihem> let xs = take n list in case (length list >= n) of {True -> Just xs; False -> Nothing} ?
05:03:27 <Marvin--> no, the  let xs = take n list in guard (length xs == n) >> return xs
05:03:42 <Marvin--> but the case works just as well
05:03:49 <maihem> ok, thanks
05:03:59 <Marvin--> I just thought I'd boast my knowledge of MonadPlus :P
05:04:06 <Marvin--> @type Control.Monad.guard
05:04:07 <lambdabot> Control.Monad.guard :: forall m.
05:04:07 <lambdabot> 		       (Control.Monad.MonadPlus m) =>
05:04:07 <lambdabot> 		       Bool -> m ()
05:36:09 <musasabi> There is no key-value collection supporting io other than alists?
05:37:16 <musasabi> Using finitemaps seems quite stupid when I usually just load it from disk and do ~3-5 operations on it before discarding.
05:37:34 <musasabi> That is with serialization via lists.
05:38:45 <Marvin--> what do you mean?
05:39:01 <Marvin--> if you do serialization via lists, why would finite maps be more stupid than any other key-value collection?
05:42:14 <musasabi> Marvin--: well using them is slower than using lists.
05:42:32 <musasabi> as the list -> finitemap takes more time than the list lookups.
05:43:12 <Marvin--> then I expect other key-value collections to take time to create too
05:44:27 <musasabi> yes, if they don't have a Show/Read implemented directly.
05:49:18 <goron> What can I do about this? Ambiguous type variable `gr' in the top-level constraint:
05:49:22 <goron>       `DynGraph gr' arising from use of `showGraph' at Main.hs:12:7-15
05:59:41 <Marvin--> goron: hard to say without seeing the code
06:00:07 <Marvin--> goron: my guess is that you have a context that mentions gr but gr isn't actually used in the type
06:31:33 <goron> Marvin--: It only comes up when I add one function that uses the rest of my functions. 
06:32:14 <Marvin--> goron: well, as I said, it's hard to say without seeing the code
07:00:01 <goron> Marvin--: I know what the problem was. 
07:00:16 <goron> Marvin--: And thus the solution
07:00:23 <Marvin--> good
07:00:38 <Marvin--> I wish I knew what my problems with gtk2hs were
07:01:03 <goron> It is definitely something worth writing in the Wiki. Know a nice spot?
07:01:45 <Marvin--> since I don't know what the problem was, no
07:01:49 <goron> FAQ, is nice... 
07:02:03 <goron> Problem was that I had too choose an implementation at the toplevel
07:03:10 <goron> I could choose between a Treebased or a array based implementation. But if you don't choose, it's ambiguous.
07:03:15 <Marvin--> well, yes, of course you do
07:03:31 <Marvin--> had you shown me the code, I'd been able to tell you that pretty quickly ;)
07:03:59 <goron> Marvin--: It would be nice, if GHC said *why* it was ambiguous.
07:04:32 <goron> Marvin--: So that you get a list of all the implementations you can choose from. 
07:04:52 <Marvin--> *shrug* discuss it on g-h-u
07:06:24 <goron> *shrug*? That means that you don't want me to spam the channel?
07:07:30 <Marvin--> I mean that I can't do anything about it, but the people on g-h-u might :)
07:09:52 <goron> Marvin--: I know.
07:10:55 <musasabi> hmm 95% of time and allocation spent in read...
07:30:12 <Hobbes> hello again.... would this mean anything to people here "1::2::[3]"?
07:31:59 <edwinb> Looks like ML to me...
07:32:56 <Hobbes> ive been asked to explain what is wrong with the expression and i dont even know what the expression is supposed to do
07:33:26 <Marvin--> is it supposed to be haskell or ml?
07:33:29 <edwinb> Depends what [3] actually means in ML...
07:33:34 <Hobbes> haskell
07:33:40 <Philippa_> you want : instead of ::
07:33:43 <edwinb> If it's haskell, it probably should be 1:2:[3]
07:33:46 <Marvin--> then error is that you want ":" instead of "::"
07:33:48 <Philippa_> :: is for type annotations, : is 'cons'
07:34:18 <Marvin--> [1,2,3] = 1:[2,3] = 1:2:[3] = 1:2:3:[]
07:34:21 <Hobbes> yeah thats what i thought but that seems like a somewhat trivial answer when the rest of the question is about typing mismatches
07:34:41 <Marvin--> perhaps it's meant as a trick question :)
07:34:47 <edwinb> how strange
07:35:04 <maihem> yeah, its probably supposed to look like it is using numerals as type names
07:35:50 <Hobbes> i guess if i put that it should use : instead of :: then im not wrong and he cant refuse to give me marks for it
07:41:57 <edwinb> I'd also say what :: is supposed to mean.
07:43:42 <Hobbes> good point cheers
08:05:21 <pesco> Why is there no operation in Data.Dynamic for querying the type inside a Dynamic?!
08:06:02 <musasabi> /c/c
08:52:11 * Marvin-- frowns
08:55:51 <stepcut> turn that frown, upside down!
09:01:02 <Marvin--> when I figure out why I can't build the gtk2hs documentation, I will
09:01:06 <monochrom> >:-|  is the frown, right?
09:01:32 <monochrom> >:-| turned upside down is >:-|.  Frown is a fixed point of turning upside down!
09:02:00 <Marvin--> dude
09:06:23 <Marvin--> I wonder how to generate proper dependencies
09:06:25 * Marvin-- sighs
09:08:22 <stepcut> monochrom: :p
09:12:29 <arjanb> sigh, the same spammer again on the haskell wiki
09:17:11 <stepcut> @arr
09:17:11 <lambdabot> This is the END for you, you gutter-crawling cur!
09:27:39 <Hobbes> can anyone point me in the right direction of finding out what is wrong with "data BinaryDigit 0|1" im guessing its because 0 and 1 can be instantiated as different types but im not 100% sure on that
09:28:42 <Marvin--> Hobbes: uhh, that is wrong on so many levels
09:28:57 <Marvin--> Hobbes: I suggest you go back to reading basic texts on defining data types :)
09:29:04 <Hobbes> hmmm
09:29:05 <Hobbes> ok
09:29:17 <Marvin--> or if you're comfortable with reading BNF grammars, read the grammar in the report
09:39:28 <monochrom> You need an equal sign.
09:39:45 <Hobbes> yeah i missed that out
09:39:46 <Hobbes> oops
09:40:01 <Hobbes> data BinaryDigit = 0|1
09:40:06 <monochrom> But I don't know whether data BinaryDigit = 0 | 1 works or not.
09:40:12 <Hobbes> no it doesnt
09:40:25 <monochrom> Use capitalized words then.
09:40:46 <monochrom> Or consider using Boolean altogether. :)
09:41:10 <Hobbes> and helpfully once again my lecturer has omitted to mention anything about what happens when you put a numerical literal in a data type definition
09:41:27 <Hobbes> god knows how this guy got his job
09:41:51 <monochrom> I think that's a reasonable omission.
09:42:51 <monochrom> I am also sure the lecturer omits the monomorphism restriction.  Further I am sure you don't want to hear about it.
09:43:10 <Marvin--> heh
09:43:38 <Hobbes> if it means i can answer these god damn questions then im all for hearing itr
09:45:01 <monochrom> In Knuth's TeX book, some paragraphs are marked by a "turn" sign and printed in small fonts.  These are meant to be omitted on the first reading.
09:45:42 <monochrom> Further, some paragraphs are marked by a "double turn" sign and printed in fine fonts.  These are meant to be omitted on the first and second readings.
09:45:52 <arjanb> imho having a mediocre lecturer teaching a functional language is better then having one teaching only java or c++
09:46:37 <monochrom> Suppose Knuth now has to teach a TeX class.  I am sure he will omit all those turns and double-turns in the lectures.  And I am sure you won't impeach him on this count.
09:48:26 <Hobbes> no i wouldnt. but say he asks me a question that requires me to read the book three times to find the answer. i would be pleased because i know that after 3 reads i can supply him with an answer. unlike the current situation where i have read all that i have been supplied with only to find i am still clueless
09:49:12 <monochrom> Are you posed a question "what happens if data constructors are numbers?"
09:50:24 <monochrom> I suppose you are just posed a question "define a data type", and in the lecture you are told "use capitalized words for data constructors!"  If you stick with that advice, you wouldn't run into problems.
09:50:30 <Hobbes> no just "what is wrong with this expression?" and as far as i can tell from his notes..nothing is wrong with it. it matches his examples perfectly except for the fact that it uses numbers rather than strings
09:50:44 <edwinb> In that case it doesn't match them perfectly...
09:51:19 <Hobbes> but that doesnt tell me how to fix it
09:51:45 <edwinb> I imagine he's expecting you to work that much out.
09:51:51 <monochrom> As long as he has said, in one form or another, but unambiguously, "use capitalized words", he has done his job.
09:51:53 <Hobbes> and there is no mention of capitalized words in our lectures
09:52:13 <Hobbes> nor in the book that i have
09:53:41 <Marvin--> what? What kind of books do you have?
09:54:42 <Hobbes> simon thompson - the craft of functional programming
09:54:53 * edwinb looks
09:55:10 <Hobbes> it says the contructors start with capital letters. it doesnt say you HAVE to use strings
09:55:24 <monochrom> There you go.
09:55:39 <monochrom> 0 doesn't start with a capital letter, now does it?
09:56:15 <monochrom> And that is the piece of text you will quote verbatim and get 100% marks.
09:56:34 <edwinb> Page 48, "Names in Haskell" tells you everything you need to know.
09:56:59 <monochrom> So this has been a book reading exercise.  I think it's fair game.
09:57:51 <Hobbes> i dont expect to have to read a text i found myself to answer questions posed by a lecturer. i would expect to be told everything i need in the lectures unless told otherwise
09:57:55 <monochrom> After many years on IRC, I have learned to disbelieve claims of teacher incompetency.  Throughout the years I have seen that 99% of them don't have a case.
09:58:38 <Marvin--> Hobbes: huh, what is this? Elementary school?
09:58:44 <Marvin--> grow up
09:58:48 <edwinb> Hobbes: This is a university course isn't it?
09:59:11 <monochrom> What is the book the lecturer tells the class to read?
09:59:31 <Hobbes> not his one
09:59:33 <Hobbes> this
09:59:45 <edwinb> which one? I bet it's in that too.
10:00:42 <Hobbes> god knows...probably one he has written himself so he can rape his students for some more cash
10:01:09 * edwinb boggles
10:01:23 <monochrom> Very few lecturers actually have time to write anything up.
10:01:48 <Marvin--> you could also have read the online report, which clearly states  "Variables and type variables are represented by identifiers beginning with small letters, and the other four by identifiers beginning with capitals" [where "the other four" are constructors, type constructors, type classes and modules]
10:01:49 <monochrom> (Much less to write one to sell students.)
10:01:51 <edwinb> I gather there's no money in writing textbooks.
10:02:06 <monochrom> (Not to say that very few lecturers *want* to do that. :)
10:02:23 <Marvin--> and if they do write text books, it's often part of the job and they make no extra money from it
10:02:38 <Hobbes> strange most of mine seem to have taken the effort to write a "necessary" book which costs around £20 more than an equivalent text
10:03:00 <Hobbes> yet conviently contains the answers to exam problems
10:03:17 <monochrom> So where can I find this lecturer's book?
10:03:24 <edwinb> I find that rather difficult to believe, I must say...
10:04:03 <Hobbes> try browsing the sheffield uni webpages and you'll find plenty of them. its certainly not just my course that does it
10:04:44 <monochrom> w00t google's logo today is cute
10:04:49 <Hobbes> maybe its just a policy that my uni has. whatever its incredibly frustrating
10:05:04 <Hobbes> especially when the book is no longer ni print
10:05:09 <monochrom> http://www.shef.ac.uk/  is that right?
10:05:17 <Hobbes> man that made me laugh when they told me that in the first year
10:05:20 <Hobbes> yes thats it
10:08:09 <np_hard> ah, the full monty
10:08:16 <edwinb> Hmm, looks like Simon Thompson's book is the recommended text for FP...
10:20:29 <Marvin--> Igloo: ping
10:24:30 <goron> Anyone used QuickCheck?
10:24:38 <Marvin--> all the time
10:25:07 <goron> Why is the example a Testable function?
10:25:20 <Marvin--> which example is this?
10:25:42 <goron> prop_RevRev xs = reverse (reverse xs) == xs
10:25:42 <goron>   where types = xs::[Int]
10:26:15 <Marvin--> I don't understand the question
10:26:38 <goron> According to the docs: quickCheck has type quickCheck :: forall a. (Testable a) => a -> IO ()
10:26:42 <Marvin--> yes
10:27:06 <goron> And prop_RevRev :: [Int] -> Bool
10:27:30 <goron> And Hmm, never mind, I already know it...Thanks :-)
10:27:37 <Marvin--> the idea is that prop_RevRev simulates an all-quantified property
10:29:52 <goron> The real question is what are all defined instances of Testable. I can't see that. 
10:35:12 <Marvin--> yeah, the docs are kinda sub par, you'd be best off reading the source
10:39:25 <goron> I have *no* idea of why they don't just put it in the Haddock gen. files. But I found it :) 
10:52:54 <musasabi> How do I set and check unix file permissions? e.g. sgid bit.
10:53:52 <stepcut> file:/usr/share/doc/ghc6-doc/html/libraries/unix/System.Posix.Files.html
10:54:33 <stepcut> though, I am not sure if you can get at sgid through that
10:55:04 <stepcut> @info setFileMode
10:55:12 <stepcut> :(
10:55:32 <stepcut> getFileStatus and setFileMode 
10:55:53 <musasabi> there seems to be setGroupIDMode
10:56:37 <goron> Marvin--: As I see it, is that QuickCheck is usefull for "proving
10:57:02 <goron> Marvin--: " that your code is equivalent to someother thing. 
10:57:32 <goron> Marvin--: But when you make something new, you still have to create input output pairs. 
10:58:15 <goron> Marvin--: Or do I see it wrong? 
10:58:32 <musasabi> A function like 'filemodeFromUnix :: Int -> FileMode ' would have been nice
10:59:31 <Marvin--> goron: well, you have to define instances of Arbitrary for your own data types, yes
11:01:14 <goron> musasabi: Well, that's unsafe.
11:01:51 <musasabi> goron: why?
11:04:03 <goron> musasabi: Well, I honestly I don't know what FileMode is. If it's just converstion than it's not unsafe. 
11:04:48 <goron> musasabi: /s/I/
11:06:10 <musasabi> goron: FileMode is a symbolic representation of the constants. like 0660 -> ownerReadMode `unionFileModes` ownerWriteMode `unionFileModes` groupReadMode `unionFileModes` groupWriteMode
11:06:28 <musasabi> now I prefer the 0660 to the latter representation...
11:07:24 <goron> musasabi: Than write such a function and send it to the maintainer. I think it's nicer too.
11:07:56 <musasabi> goron: I am first trying to determine whether it actually exists somewhere but is hidden.
11:12:30 <Marvin--> remember that octal numbers are written 0o660 in haskell, not 0660
11:12:44 <monochrom> 0o666
11:12:58 <Marvin--> the octal beast :)
11:43:34 <palomer> lol marvin
12:10:35 <musasabi> I created a small cgi-script to create directories on the server readable as both the user and the web-server - shows the System.Posix.Files api a little bit - http://www.cs.helsinki.fi/u/ekarttun/util/CreateCgiDirs/CreateCgiDirs.hs
12:19:21 * shapr boings
12:22:08 <Marvin--> hey shapr
12:23:23 <shapr> hiya
12:23:35 <shapr> I've been thinking about how to do database queries from inside hws-wp
12:24:15 <arjanb> shapr: maybe you should make the wiki not changable by anonymous users :S
12:24:17 <shapr> I think maybe it needs a whole separate persistent store thread
12:24:43 <shapr> arjanb: :-(
12:25:02 <shapr> that's getting depressing
12:25:14 <arjanb> indeed
12:25:25 <Smerdyakov> Ban every IP address that causes trouble.
12:25:29 <Smerdyakov> That's worked well for me so far.
12:25:54 <Smerdyakov> You end up having to ban anonymizer services, too, of course.
12:26:06 <shapr> it doesn't work that well for me, several of the spammers have many different addresses.
12:26:07 <arjanb> today the same spam from 2 different ip's
12:26:29 <Smerdyakov> So? Keep adding those IP's. There are only 2^32 possibilities, after all.
12:26:55 <Smerdyakov> Like I've said, this has seriously worked for me.
12:27:00 <Smerdyakov> I add every IP address as it occurs.
12:27:01 <monochrom> There is good chance you need only ban a few hundred.
12:27:02 <Smerdyakov> No spam in a while.
12:27:21 <shapr> maybe I'll add a moinmoin extension action "ban this IP"
12:27:42 <Smerdyakov> Well, I do this with Apache config directives.
12:28:02 <Smerdyakov> Letting random visitors ban others is a bad idea in the first place, so you don't really lose anything by this.
12:28:27 <arjanb> aren't there spam filters for wiki change yet?
12:28:44 <Smerdyakov> Who cares? I'd rather leave the fuckers mystified by 403 error pages for any accesses, even reads.
12:28:45 <shapr> yes there are
12:29:11 <shapr> the spam filters check for certain inputs and disallow any changes that include those inputs
12:29:14 <Cale> Smerdyakov: there are permissions settings :)
12:29:15 <shapr> certain urls for example
12:29:26 <Smerdyakov> Cale, for MoinMoin?
12:29:39 <Cale> yeah, from what I understand :)
12:29:46 <Smerdyakov> That's OK. I prefer the cowboy approach.
12:30:12 <Marvin--> heh, gung-ho admin
12:30:26 <stepcut> shapr: I looked into the hws-wp thing a bit, I am not really clear on what you are trying to do with haskelldb in that context..
12:32:11 <shapr> stepcut: I'd think I want to run a persistent HaskellDB thread alongside the rest of the hws-wp stuff for quick and easy database access.
12:32:42 <shapr> Cale: looks like we got them all
12:32:46 <Cale> yeah
12:33:02 <shapr> I've banned both IPs
12:33:12 <musasabi> shapr: isn't that a generalizable idea.
12:33:40 <shapr> musasabi: I think so, I think that's what I call an application server...
12:33:46 <musasabi> shapr: you need to have resource handles with 3 operations : open, reset and close.
12:33:55 <stepcut> shapr: I don't really see the benefit of a 'shared' haskelldb thread...
12:34:05 <musasabi> stepcut: database connection caching.
12:34:41 <shapr> right, I was thinking of a webapp with heavy database usage
12:35:07 <shapr> maybe it's enough to just keep all the HaskellDB code loaded, but I'd rather have an open connection hanging around for near-instant use.
12:35:37 <stepcut> hrm
12:35:40 <musasabi> for files those are just open, close and seektobeginning.
12:36:39 <shapr> Cale: I'll look into the pattern-based anti-spam plugins next week.
12:36:51 <shapr> then we can just add in a pattern and not worry about banning a bunch of IPs
12:37:59 <stepcut> shapr: this sounds a lot like pre-mature optimazition to me...
12:38:02 <shapr> stepcut: an application server could integrate a bunch of stuff into one app, HaskellDB, WASH, halipeto, etc; sounds like J2EE I guess.
12:38:05 <shapr> yah, could be
12:38:54 <shapr> well, any better suggestions for building a webapp that saves student records in HaskellDB? CGI is too slow already
12:39:03 <stepcut> shapr: the two possible solutions I see are: (1) have a global pool of open connections that you get at via MVar (2) always pass an open connection in as a parameter when you spawn of a 'thread'
12:40:38 <stepcut> shapr: too slow already? are you doing lots of queries per second ?
12:40:43 <shapr> I'll see if I can hack up some prototypes, that should give some feedback on what sucks or doesn't.
12:41:11 <shapr> nah, startup cost is the real problem. I'm loading WASH, Grammatical Framework, some GF grammars, and then randomly generating questions.
12:41:27 <Igloo> Marvin--?
12:41:27 <shapr> I haven't even gotten to using DB stuff yet.
12:41:48 <stepcut> shapr: using ghc?
12:42:13 <shapr> but when it takes a few seconds to generate one new exercise on my dual 1544MHz Athlon MP, I know it's far too slow for my 600MHz colo box.
12:42:16 <Marvin--> Igloo: oh hey
12:42:56 <stepcut> shapr: and you think that time is due to start-up overhead ?
12:43:20 <shapr> well, it's a CGI program right now, so everything is loaded up again at the beginning.
12:43:30 <shapr> I guess I could generate a bunch of questions and save them
12:43:36 <shapr> that would work
12:43:58 <shapr> but I'd rather allow people to load new grammars at runtime
12:44:03 <Igloo> Marvin--: Hey  :-)
12:44:11 <Marvin--> A ffi-using lib that needs -dev packages to build probably needs those same -dev packages when compiling programs, right?
12:44:18 <stepcut> shapr: I am confused, what is the slow part? Initialize GF?
12:44:33 <shapr> yah, GF and the grammars
12:44:44 <shapr> hoi goron 
12:44:57 <stepcut> shapr: right, and you aren't even using haskelldb yet, so why are you worried about a db connection pool ??
12:45:22 <shapr> well, not that specifically, but how to make haskelldb and gf and others into hws-wp plugins
12:45:37 <goron> How hard is to automatically fill in some forms on a website using Haskell? I need to fill in the same form every 3 months or so. 
12:45:41 <goron> shapr: hoi
12:45:47 <shapr> goron: use wget
12:45:57 <shapr> or netcat 
12:46:11 <goron> shapr: I thought that it was only for getting files.
12:46:13 <Marvin--> I'm wondering if there's some simple way to figure out which -dev packages are needed
12:46:22 <goron> shapr: I will look for it. Thanks
12:46:31 <Marvin--> or if I just have to look through the extra_libraries field of the packages
12:46:41 <stepcut> shapr: are the plugins in hws-wp dynamically loaded and unload on a per connection basis ?
12:47:16 <shapr> the national swedish ISP requires you to fill in a login webform just to get anywhere except the login server, so I have an /etc/init.d/telia.sh script that uses netcat to do it.
12:47:33 <shapr> goron: yes, but a webform submission is a file get
12:47:47 <stepcut> shapr: i don't understand why do don't just make your CGI thing into a plugin, and load the plugin. Even if the plugin takes 30s to load, once its loaded, its going to stay loaded until you explicitly unload, right ?
12:48:17 <shapr> hm, sounds right
12:48:31 <Marvin--> Igloo: I'm just wondering if haskell-policy should point out any of these things, or if it makes more sense to put it in some sort of packaging guide document
12:48:34 <palomer> netcat!
12:49:11 <shapr> stepcut: Maybe I'm just missing the obvious, I'll try it. Thanks for the discussion. :-)
12:49:17 <goron> goron: Yes, I only interpreted it different. 
12:49:19 <stepcut> shapr: :p
12:49:45 <goron> palomer: is netcat easier?
12:50:11 <goron> palomer: I don't see the docs of it on the website.
12:50:19 <shapr> goron: is the form GET or POST?
12:50:24 <palomer> I hear netcat is the best thing in the world
12:50:38 <shapr> netcat is nice. paketto is cool too
12:50:44 <shapr> dsniff is sniffy
12:50:47 <Igloo> Marvin--: Hmm
12:51:10 <Marvin--> I'm wondering if I can generate that list of dependencies in a smart way somehow
12:51:13 <palomer> the netcat documentation is divided in 2, I think
12:51:14 <shapr> I like ettercap a lot. ARP poisoning rocks.
12:51:18 <palomer> "the light side" and "the dark side"
12:51:23 <Marvin--> or I guess I could use the same dependencies that I have in the build-deps
12:51:27 <Marvin--> (*d'oh*)
12:51:42 <shapr> palomer: there's no difference imho
12:51:48 <Igloo> We could get them into depends by a variable and a but of shell hackage
12:52:25 <Marvin--> but it boils down to checking extra_libraries?
12:52:28 <palomer> between the light side and the dark side?
12:52:41 <shapr> right, it's just in how you apply your knowledge.
12:53:34 <Igloo> Well you'd normally need to do that bit yourself somehow anyway, right? A tool to help you might be cool, though
12:53:41 <goron> shapr: Well, its POST
12:54:31 <goron> Which one would work best in that case?
12:54:44 <Marvin--> my approach to getting build-deps right is pretty ad-hoc, I'm afraid :)
12:55:03 <Igloo> afk
12:57:37 <Spark> away from ketamine
13:04:17 <Igloo> Does foo-dev depend on foo (= $verison)?
13:04:35 <Marvin--> for c libs, typically yes
13:04:48 <Igloo> OK, that's not an issue then
13:05:11 <Marvin--> I'm wondering if we need versioned deps for the binary packages
13:05:59 <Marvin--> actually... ouch... don't we need to depend on exactly the packages containing the libs in extra_libraries *and* their -dev packages?
13:06:09 * goron sees potential of autocreating wget scripts....
13:06:16 <Marvin--> or you won't be able to compile anything
13:06:43 <Marvin--> I wonder if we can/should/have to make use of the shlibs infrastructure
13:06:44 <goron> Doesn't that exists somewhere?
13:07:36 <Igloo> I thinkk the requirements from shlibs on the object files will suffice, no?
13:07:52 <Igloo> That's what I thought was made a non-issue by the dep above
13:08:24 <goron> How is multipart/form-data handled with wget?
13:08:38 <Marvin--> the object files?
13:08:47 <Marvin--> which object files?
13:09:26 <Marvin--> heh, evil thought: compile a dummy program that's just module Main where main = return () by ghc --make -package foo -package bar and run dpkg-shlibdeps on it
13:09:39 <goron> > I need submit a file to a web page and then download its output. The
13:09:39 <goron> > ENCTYPE files of the form is : multipart/form-data. It seems wget
13:09:39 <goron> > doesnot support multipart data. Is that right?  Thanks.
13:09:41 <goron> That's right.  The support might not be too hard to add, though.
13:09:51 <Igloo> The ones GHC makes. Or do they not get found inside .a files?
13:10:06 <goron> Is netcat a bit more advanced?
13:10:08 <Marvin--> shlibdeps only looks at ELF files
13:12:10 <Igloo> Hmm, ELF executables and share libraries according to dh_shlibdeps. I'm sure I've had troublewiht it complaining about my .o files before, though
13:13:16 <goron> netcat works on a more general level. 
13:13:29 <goron> I just need basic CGI communication.
13:13:39 <Marvin--> actually, I think the dummy .hs program compiled with -package foo for every ghc-package in the deb could work
13:14:04 <SamB> netcat is just that: cat for TCP/IP
13:14:37 <SamB> dead simple in principle, but very handy
13:14:54 <Marvin--> dpkg-shlibdeps: warning: could not find any packages for /usr/lib/libncurses.so.5 (libncurses.so.5)
13:14:55 <goron> SamB: But I don't want to study the entire TCP/IP/CGI protocol just to POST some data to some server. 
13:14:56 <Marvin--> huh, that's odd
13:15:05 <SamB> goron: you don't need to study it.
13:15:11 <goron> SamB: Or can you explain some basic stuff?
13:15:21 <SamB> you would only need to study HTTP for that ;-)
13:15:40 <goron> SamB: Uh, yeah, right, sorry for that ...
13:16:08 <SamB> I would look at wget or curl
13:16:21 <goron> wget doesn't understand multipart data
13:16:28 <goron> curl? I will look at that.
13:17:34 <goron> SamB: Looks promising :)
13:17:51 <Marvin--> Igloo: I think I'll see if I can hack together a script for this purpose
13:18:21 <Igloo> OK, cool
13:21:35 <musasabi> Anyone have a wikiparser in Haskell? (or should I just write it from scratch)
13:28:37 <musasabi> What should be used instead of System.Sendfile ?
13:29:38 <Marvin--> grmf, but to actually be able to compile against the packages that I'm building... is slightly trickier
13:30:30 <Igloo> Oh, yeah, you'll have to do someminor hackage
13:30:42 <Marvin--> *minor*
13:30:46 <Igloo> That sounds like an ugly solution anyway
13:31:07 <Marvin--> ugly or not it has the advantage of being exact
13:31:27 <Igloo> Well, you just need to hack the paths in the package.conflet, askghc-pkg to create a new package.conf with it and then tel ghc to also use thatpackage.conf right?
13:33:22 <Marvin--> right, which means properly parsing the .conf files
13:33:31 <Marvin--> and then it's beyond a "simple shell script" :)
13:35:01 <Igloo> Oh, I thought they tended to be onepath for a library and one for the imports or similar, so a sed would work in the common case
13:36:37 <Marvin--> huh?
13:37:18 <Marvin--> well, yeah, in the simple case, I suppose it would be sed:able
13:37:32 <Marvin--> you'd change import_dirs and library_dirs
13:37:45 <Marvin--> actually you probably wouldn't even need to change import_dirs since you're not importing anything, just linking :)
13:38:20 <Igloo> Hmm, would that really work?
13:38:41 <Igloo> Oh, is this going to work at all on arches with library splitting?
13:38:47 <Igloo> (e.g. does it work on x86?)
13:39:28 <Marvin--> regardless of whether you're importing anything, the linker will throw all the -l:s at you
13:39:35 * Igloo realises I've been looking at the wrong clock and should go to bed
13:39:56 <Igloo> Ah, true
13:40:02 <Marvin--> I just compiled an empty program with -package gtk2 and ldd is giving me a looong list of deps
13:40:06 <Igloo> 'night
13:40:13 <Marvin--> I should get some sleep too
13:40:26 <Marvin--> I'll have to think more on this
13:43:34 <shapr> Marvin--: you could sleep on that
13:43:51 <shapr> Extra Low Frequency Executables, yay!
13:44:32 <monochrom> You mean Extra Low Frequency Executables, huuuuuuuuuuuuummmmmmmmmmmmm!
13:48:33 <Marvin--> night guys
13:48:58 <musasabi> Somehow profiling a cgi-script fails to produce a .prof file with ghc.
13:50:00 <musasabi> it works from command line, but not from web...
13:59:55 <musasabi> What is the faster alternative to "readFile filename >>= putStr" ?
14:02:49 <monochrom> perl -e 'while (<>) { print; }'
14:03:35 <goron> Good night, guys/girls...
14:37:48 <stepcut> so, california has this 'domestic partnership' thing, so that gays/lesbians can get similar rights as married people in regards to financial decisions making, health care benefits, etc. But here's the kicker, you *have* to be gay or lesbian to sign up. It's not available for straights.... go figure.
14:38:00 * stepcut makes some lunch
17:40:27 <koli> "a computation of computations into a single computation"
17:40:37 <koli> is that like a binary operator in group theroy ?
17:40:42 <koli> theory
17:41:01 <koli> A.B=C
17:43:31 <koli> "An introduction to category theory, category theory monads, and their relationship to functional programming" - Jonathan M.D. Hill and Keith Clarke
17:43:49 <Cale> Is that in relation to join?
17:43:59 <koli> i have no idea.
17:44:12 <koli> it doesn't really say.
17:44:20 <Cale> url?
17:44:30 <Cale> oh, might have found it
17:44:33 <koli> i have it printed out.
17:44:39 <koli> i'll google it for ya.
17:44:44 <koli> ok
17:45:12 <Cale> yeah
17:45:41 <koli> yeah, as in it is like a binary operator in group theory ?
17:46:18 <Cale> yeah, as in I really did find it :)
17:46:25 <koli> ah ok.
17:46:36 <koli> page 6
17:47:13 <Cale> right
17:47:24 <Cale> mu is called join in haskell
17:47:44 <Cale> it's a sort of multiplication, yeah
17:48:52 <koli> how would you rate this paper for its effectiveness in teaching monads ?
17:49:04 <koli> hmmm
17:49:11 <koli> i guess you're not familiar with it.
17:49:18 <koli> nm
17:49:26 <Cale> looks sort of poor unless you already know a good deal of category theory :)
17:50:08 <koli> i have a feeling its poor even if you do know about category theory.
17:53:00 <Cale> It looks like it was written quite a while back.
17:53:39 <Cale> http://www.nomaware.com/monads/html/
17:57:26 <koli> cale: do you follow what the paper is saying ?
17:59:41 <monochrom> "a computation of computations into a single computation" is join indeed.
18:00:00 <monochrom> There are two ways to view join.
18:00:51 <monochrom> One is the "list is an example monad" view.  If you have a list of lists [[a]], sometimes you want to concatenate them to get [a].
18:02:36 <monochrom> Another is the "computation is an example monad" view.  If you have a procedure x::IO (IO a) that, when executed, returns another procedure y:IO a, sometimes you want to execute x, get y, then execute y.
18:02:42 <monochrom> Both are joins.
18:03:08 <koli> ah
18:03:41 <koli> i did read cales article about containers, but unfortunately the other view isn't available.
18:06:30 <koli> http://www.haskell.org/hawiki/MonadsAsComputation
18:06:33 <koli> blank
18:07:11 <koli> monochrom: thanks for that, anyway, i've never seen that said before.
18:12:16 <Cale> Yeah, I intend to write a MonadsAsComputation page if nobody goes and writes it for me :)
18:12:41 * Pseudonym listens to the sound of chipring crickets
18:12:42 <koli> well i certainly won't be doing it any time soon.
18:12:45 <Pseudonym> Guess you're it.
18:13:29 <monochrom> I bet the computation view can be easily obtained from the container view by the following substitution: s/open/execute/
18:13:33 <Riastradh> The crickets here are quite vocal.
18:13:43 <koli> is pseudonym calling me a chirping cricket ?
18:13:49 <monochrom> Ah s/take/execute/
18:14:38 <monochrom> But not all "take"s.
18:16:51 <monochrom> I think the two views can be unified by careful wording.
18:17:33 <koli> there seems so many things that can cause confusion :/
18:18:12 <Riastradh> If you think monads are confusing, try reading John Hughes' original paper on arrows.
18:18:39 <monochrom> I think Phil Wadler's explanation is quite successful.
18:19:21 <koli> whats the longest its taken someone to understand monads ?
18:19:33 <Riastradh> That's a rather silly question.
18:19:40 <monochrom> +oo
18:19:42 <koli> yeah ?
18:19:43 <Riastradh> There are plenty of people who don't understand monads at all.
18:19:56 <koli> there isn't a entry in the guiness book of records ?
18:20:03 <koli> oh cool :)
18:20:07 <monochrom> Haha they wouldn't care.
18:20:08 <Riastradh> I don't think they particularly care about monads.
18:21:40 <Riastradh> Hmmmm.  I'm getting a peculiar urge to write a detailed explanation of monads.  Is this normal?
18:22:27 <monochrom> Recall that it took mathematicians --- generality bigots themselves no less --- two or three generations to accept such obvious generalizations as groups, rings, vector spaces.
18:22:33 <koli> abnormality isn't necessarilly a bad thing riastradh.
18:22:42 <koli> you should definitely go for it.
18:23:12 <koli> monochrom: good point.
18:23:46 <monochrom> I am beginning to see the beauty of death.
18:26:27 <Pseudonym> That's very poetic.  And gothic.
18:28:04 <koli> it reminded me of that chick.
18:28:16 <monochrom> She died in beauty? :)
18:28:20 * koli googles for information/news of heather nova
18:28:33 <koli> i hope shes still alive.
18:29:21 <koli> beauty of deathv -> super nova -> heather nova
18:29:29 <koli> -v
18:29:34 <Pseudonym> I thought you were talking of the Lady of Shallot.
18:30:23 <Pseudonym> Shallott
18:30:54 <koli> www.heathernova.com :)
18:31:02 <koli> anyway.
18:31:14 * koli tries to get back to think of monads.
18:31:28 <koli> thinking
19:15:10 <SIN^s> !users
19:25:25 <Cale> !users?
20:31:22 <monochrom> !osers
20:31:32 <Jerub> monochrom: ?
20:31:40 <Smerdyakov> !jerub
20:31:46 <monochrom> joking about !users.
20:31:52 <Smerdyakov> !joking
20:31:59 <Riastradh> Imagine the ! as an l.
20:32:24 <Smerdyakov> I am Ljoking, Hegemon of the Viking Horde!
20:32:42 <monochrom> bjoking
20:33:12 <Jerub> I have discovered erlang.
20:33:19 <Jerub> I just wanted to come in here and say that.
20:34:38 * stepcut plans to discover erland some day
20:35:11 <Jerub> it feels like haskell with dynamic typing.
20:36:48 <stepcut> I am mostly interested in it because I want to learn more about error handling, and from what I hear, the developers had some interesting ideas on the subject
20:37:03 <Jerub> stepcut: thats something I've heard, and I get that feeling.
20:37:20 <Jerub> I'm up to chapter 5 and haven't seen what happens when an error occurs, its slightly ominious
20:37:40 <stepcut> hehe
20:39:55 <shammah> Jerub: well that's chapter 7.  But really you want chapter 4 (iirc) of Armstrong's thesis.
22:50:11 <Maddas> Good morning
22:50:22 <stefan_> Good morning
22:50:34 <Riastradh> Good night!
22:50:38 * Riastradh is off to bed.
22:50:49 <stefan_> Riastradh: good night :)
22:50:56 <Maddas> Good night :-)
23:04:05 <heatsink> good night riastradh
23:06:05 <stefan_> kosmikus: how's AFP thusfar? and how's Estonia? (never been there)
23:09:18 <kosmikus> the school just started today
23:09:29 <kosmikus> during the weekend, there have been introductory talks
23:09:50 <kosmikus> the building is nice and the organization is very good
23:10:21 <stefan_> interesting stuff?
23:10:31 <kosmikus> Estonia is very interesting as well, although I occasionally feel helpless when confronted with the language
23:11:00 <kosmikus> promising topics, yes
23:11:10 <stefan_> does it resemble russian? it does, I guess
23:11:16 <kosmikus> have a look at the web page
23:11:21 <stefan_> I will
23:11:29 <kosmikus> no, the language has no connection with russian
23:11:37 <kosmikus> it's much like finnish
23:11:43 <stefan_> :S
23:48:50 <musasabi> morning
23:50:28 <heatsink> monring
23:50:42 <heatsink> mroning
23:50:47 <heatsink> gnirmon
23:51:31 <Pseudonym> mirgnon
23:56:14 <ozone> g'doi
