00:25:37 * musasabi growls at being forced to use DataStructuresNotFunctions
00:26:54 <musasabi> I just want data Event a = Event { match :: Date -> Bool, data :: a }
00:27:03 <musasabi> but that is too much to ask..
00:27:52 <ibid> how so?
00:28:20 <musasabi> ibid: no possiblity of Equality or serialization.
00:30:50 <ibid> ah
00:53:00 <stefan_> musasabi: it seems to me that the match predicates define only small sets ... doesn't that give you a possibility to more or less effectively define equality and serialization on them?
01:17:11 <musasabi> you mean serialize f = bitmap $ map f domain ?
01:22:22 <stefan_> musasabi: no, I was thinking about modelling match functions as sets
01:24:41 <ibid> stefan_: isn't that what's meant by "DataStructuresNotFunctions", which he was lamenting
01:25:46 <stefan_> ibib: yep, I'm sorry ... wasn't reading too carefully
01:26:43 <ibid> ibi_d_ :)
01:26:51 <stefan_> still, if the predicates define small sets, the data-structure approach seems quite reasonable to me ...
01:27:11 <musasabi> yes, it just is not very elegant.
01:27:22 <stefan_> ibid: now I'm not typing too carefully either ... yes, it's weekend ...
01:27:37 <musasabi> Why can't I define a function with the type "asT :: (Typeable t) => a -> Maybe t" in a typeclass?
01:28:04 <stefan_> musasabi: why? the only thing you can do with functions is applying them ... you can do that with these structures as well
01:28:49 <stefan_> musasabi: ouch, back to generics again ... I'm not sure ... can't you? :S
01:29:03 <musasabi> stefan_: but then I have to build an interpreter, not as much fun.
01:30:58 <stefan_> musasabi: why, if you model f :: a -> Bool as f' :: [a], then (f $) ~= (`elem` f')
01:32:15 <musasabi> stefan_: yes that is possible, but it is simply not as "elegant".
01:32:55 <stefan_> musasabi: "class Foo t where foo :: (Typeable a) => t -> Maybe a" works fine ... what's the problem?
01:33:56 <stefan_> musasabi: so, appearantly there's a trade-off between what you consider elegant and the functionality you need ... ;)
01:34:12 <musasabi> yes.
01:34:43 <stefan_> well ... :)
01:34:48 <musasabi> stefan_: I think I am lacking a needed explicit forall somewhere (doing optionally Typeable dispatch)
01:36:54 <stefan_> musasabi: but then your class method's signature is likely to be a litle more complicated, I guess?
01:37:05 <musasabi> defining the first level of typed catch "don't catch if not typed" works fine:
01:37:11 <musasabi> base eo f d = maybe d f (asT eo)
01:37:30 <musasabi> that is default if it is not typeable in case of f.
01:38:17 <musasabi> However I cannot make the basic cast based dispatch work in f:
01:38:20 <musasabi> notWorking o f d = base o (\v -> maybe d f (cast v)) d
01:38:59 * stefan_ forces himself to awake and have a look at the dispatching stuff ...
01:39:16 <musasabi> imho the type of base (base :: (ErrorC e, Typeable tt) => e -> (tt -> a) -> a -> a)
01:39:35 <musasabi> should be enough as our typed dispatcher is called on a Typeable
01:40:15 <stefan_> musasabi: let me have a look
01:41:50 <musasabi> http://youzen.b2.fi/~musasabi/F.hs
01:44:52 <musasabi> base and notWorking is the problematic case.
01:48:38 <musasabi> Basically I am building a "cast' :: (Typeable t) => a -> Maybe t" with a handwritten cast' for each a to allow subtyping.
01:49:03 <musasabi> Meaning that one can use both hierarchical subtyped exceptions and basic ones in the same hierarchy.
02:01:15 <stefan_> musasabi: I'm sorry ... can't get it working right now ...
02:02:19 <musasabi> np, I'll try to figure it some more in the evening.
02:03:30 <stefan_> musasabi: well, I got it working now, but for some reason I doubt if it is what you want ...
02:03:38 <stefan_> musasabi: at least it typechecks now
02:03:54 <stefan_> working :: forall a b t . (ErrorC a, Typeable t) => a -> (t -> b) -> b -> b
02:04:04 <stefan_> working a f b = base a (g f b) b
02:04:15 <stefan_>  where g :: forall t b . (Typeable t) => (t -> b) -> b -> t -> b
02:04:25 <stefan_> g f b v = maybe b f (cast v)
02:04:34 <stefan_> hey, I didn't say it looked nice
02:05:18 <stefan_> I'm sure you can rewrite it to something far more elegant ;)
02:05:55 <musasabi> thanks a lot, I'll try to work someting from that.
02:15:45 <musasabi> hmm defined catchTyped - now to test it.
02:22:27 <musasabi> seems that I have to refactore things a bit as currently it is not possible to declare any typed instances although things work... just making the dispatch happen *inside* the typeclass should help as I can make the interface monomorphic behind the existential.
02:22:38 <musasabi> -> shopping & hacking
02:23:55 <stefan_> good luck :)
02:25:32 <stefan_> musasabi: I really don't see where working would behave different from base :S ... seems to me they are the same function, but maybe I'm mistaken ... :S
02:26:04 <stefan_> anyway ... I'm out now ... I'll ask you how things worked out later this weekend ... have fun!
04:33:11 <KC> Hello 
04:33:15 <KC> channel
04:34:03 <KC> Anybody used Qtparted for resizing partitions
04:35:19 <pesco> No. Are you in the wrong channel maybe?
04:41:33 <basti_> the channel just has the wrong theme
04:41:50 <pesco> Right.
05:41:06 * pesco finishes Haskell-manpages.7hs.
05:51:41 <pesco> Hi, somebody here who could have a look at a Postscript file that looks wrong on my viewer, to see if they get the same result?
05:55:24 <cptchaos> pesco: where is it?
05:56:33 <pesco> http://www.scannedinavian.org/~pesco/foo.ps
05:57:11 <pesco> That is supposed to be a rendition of some manpage on A5 paper.
06:02:37 <musasabi> pesco: looks wrong with gv.
06:02:59 <pesco> So I suspected.
06:03:07 <musasabi> only starts from halfway of the page and does not end where the page ends.
06:03:15 <cptchaos> pesco: with ggv as well
06:03:27 <pesco> Ok, those results are identical with mine.
06:03:58 <pesco> Can you see (by switching on/off some options on (g)gv) any clue as to the reason why it displays that way?
06:04:53 <pesco> I only have the Mac OS viewer and it doesn't offer much help.
06:13:15 <cptchaos> doing an ps2ps, makes it better, but ist still wrong
06:14:04 <cptchaos> I guess that the ps ist simpy flawed in some way, how did you generate it?
06:17:02 <pesco> groff -dpaper=a5 -P-pa5 ...
06:17:19 <pesco> I think groff just has no settings for A5, although it knows the paper size in principle.
06:17:49 <cptchaos> hm, does is work correctly with 
06:17:53 <cptchaos> a4?
06:18:12 <pesco> Yes. There is an a4 file in groff.
06:18:54 <pesco> I've found a mailing list post where someone contributed corresponding files for all other DIN paper sizes, but I can't get the attachement out of the list archives.
06:19:29 <cptchaos> hm
06:20:12 <pesco> begin 644 isopapers.tar.gz
06:20:12 <pesco> ...
06:20:13 <pesco> end
06:20:17 <pesco> is that uuencoded?
06:21:49 <cptchaos> don't know
06:22:06 <pesco> God, pipermail totally mangled that thing.
06:22:52 <pesco> Hah! Got it.
06:23:00 <pesco> It was uuencoding.
06:26:03 <pesco> Yes, it works.
06:27:31 <pesco> God, this is getting me ON!
06:28:01 <pesco> I'll be printing QUALITY reference pamphlets soon.
06:32:50 <jrpage> pesco: yay! what are you making pamphlets for?
06:33:22 <pesco> jrpage: Heh, actually nothing. But I'll print one just to see how it looks and put on my shelf. ;-P
06:36:06 * pesco imagines himself handing out Haskell documentation pamphlets to demonstrators. Next to the spartakists.
06:36:19 <jrpage> what are spartakists?
06:37:01 <pesco> A flavor of communists.
06:37:31 <pesco> People frequently seen handing out pamphlets to strangers.
06:37:39 <pesco> ;-)
06:39:50 <jrpage> do we have enough supporters to start our own demonstrations yet?
06:40:14 <pesco> What would you like to demonstrate for/against?
06:40:42 <jrpage> Down with side effects! Lift the lambdas!
06:40:52 <pesco> I'd like to demonstrate agains the use of XSL stylesheets. They're obviously supporting zionist state terrorism.
06:41:06 <pesco> Lift the lambdas! LOL.
06:42:00 * pesco imagines enraged programmers swinging wooden lambdas at the ignorant.
06:43:22 <Jerub> pesco: I've actually seen christians handing out tracts to people walking past or into a mormon temple.
06:43:31 <Jerub> pesco: that was funny.
06:43:46 <jrpage> we could hang out by local java users groups
06:44:06 <pesco> Yeah!
06:44:13 <Jerub> jrpage: awesome.
06:44:15 <pesco> I'd really do that.
06:44:25 <pesco> Jerub: What are tracts?
06:44:40 <Jerub> pesco: like phamphets but have a bit more information, usually religious based.
06:44:48 <pesco> Jerub: Ok.
06:44:56 <Jerub> the principal differnce is that they fold differently.
06:45:33 <pesco> lol. How do they fold?
06:46:16 <Jerub> they usually end up square.
06:46:29 <Jerub> folded both lengthways and sideways.
06:46:34 <Jerub> kinda like a map.
06:46:38 <Jerub> anyway, I'm going to bed.
06:47:18 <pesco> I see. Goodnight!
06:47:24 <jrpage> like a map? So, several times in each direction, with the special technique where they can never be refolded once opened?
06:48:11 <jrpage> bye
06:48:34 <jrpage> hmn, what could we say to Java users?
06:49:05 <jrpage> especially without any objects to offer them...
06:50:10 <pesco> That Hindley and Milner have come to save them.
06:50:17 <pesco> Christians don't use reasoning.
06:51:34 <pesco> We just make up some messiah figures and tell them they're doomed unless they "allow them into their lives" or something similarly vague.
07:08:56 <jrpage> I
07:19:44 <musasabi> objects are overrated anyways
07:21:07 <jrpage> of course, but how would that fly at a Java users group?
07:23:01 <musasabi> you could troll them about concurrency too.
07:23:10 <musasabi> not that haskell does do it right.
07:24:12 <jrpage> is Java worse than most other languages there?
07:24:35 <musasabi> well the per object sychronisation model is very poor.
07:24:37 <arauko> yes
07:24:40 <pesco> I here COBOL is much worse.
07:24:56 <kaol> I usually just smack java users with a salmon and yell "FOO!" at them.
07:24:58 <musasabi> java adds per object overhead due to concurrency but still does not get it right.
07:25:06 <pesco> But I have yet to come across a live COBOL programmer.
07:25:19 <musasabi> salmon is tasty.
07:27:45 <roconnor> what's wrong with java's mutexes?
07:28:10 <musasabi> roconnor: well they are so low level, that it is very easy to get algorithms wrong with them.
07:28:48 <musasabi> message passing and transparent futures are the way to go.
07:29:29 <jrpage> what's Haskell missing from that?
07:30:43 <roconnor> sounds like java just needs a decent library then.
07:31:30 * roconnor has been secretly using multiple inheritence in his C++ code lately.
07:33:28 <musasabi> jrpage: a good implementation.
07:40:09 <shapr> whoa
07:43:46 <pesco> Hoi shapr!
07:44:38 <shapr> y0 y0
07:45:38 * shapr wibbles confusedly
07:45:46 <pesco> What's the confusion?
07:45:53 <shapr> I'm not sure ;-)
07:45:58 <pesco> Heh.
07:46:24 <shapr> conversational paradoxes are funny.
07:46:39 <shapr> "A: You're being defensive! B: No I'm not!"
07:47:14 <musasabi> Is there any point in using Data.Dynamic as opposed to Data.Typeable ?
07:47:32 <shapr> I think Typeable doesn't do the same thing at all.
07:47:47 <shapr> I think Dynamic requires Typeable
07:48:07 <pesco> Typeable is a type class. Dynamic is a data type.
07:48:33 <shapr> a Dynamic value is two pieces, a raw bit field and a representation of a type that bitfield can be.
07:48:55 <pesco> Types in class typeable offer a representation of their type in terms of programmatic values.
07:49:17 <shapr> right, you need a typeable instance to get the type representation.
07:49:41 <shapr> I do wish that typeable *were* an actual value.
07:50:10 <shapr> That would mean I could send a Typeable value across the wire and the bunch of bits separately, and then reconstitute them on another RTS.
07:50:35 <pesco> Types as first-class values?
07:50:43 <shapr> yah
07:50:48 <shapr> hiya eixei, ltns
07:50:49 <pesco> Hm.
07:50:55 <eixei> yep, ltns :-)
07:50:57 <eixei> heya everyone
07:51:06 <pesco> Tach.
07:51:33 <shapr> it's probably simpler to find some way to go from a type to the source file it came from, then send that file across the wire.
07:51:33 <musasabi> but there is TypeRep
07:51:38 <shapr> feel sort of hackish though.
07:59:15 <pesco> I'm getting good at roff!
07:59:35 <pesco> At least wrt. the man macro package.
08:00:03 * shapr roffs
08:00:11 <shapr> roff roff! meow!
08:00:16 * pesco snickers.
08:01:03 <pesco> Haddoc needs a roff backend.
08:01:35 <shapr> whoa, spiffy: http://www.erikyyy.de/tempest/
08:02:07 <pesco> Awesome.
08:07:20 <musasabi> roff is nice...
08:07:31 * musasabi does most of school work with roff..
08:07:45 <musasabi> but then I am thinking of a wiki->latex backend.
08:15:11 <shapr> oh, that would neat
08:16:15 <shapr> I hope to get to ICFP05 in Estonia
08:16:24 <shapr> I'll aim for it, at least.
08:16:49 <shapr> Anyone suggest any fun workshops?
08:16:58 <shapr> Maybe I should discuss unicycling =)
08:17:01 * shapr is joking
08:18:30 <pesco> [Sh05] "The Effects of Unicycling on Programmng Behaviour", Shae Erisson, in Proceedings of the ICFP '05 pp. 102-123
08:20:31 * shapr cackles
08:21:14 <shapr> I wonder.. what sort of fun workshop is needed?
08:22:04 * musasabi thinks he will go there..
08:29:06 <shapr> anyone else planning on going to ICFP05 in Estonia?
08:29:30 <shapr> pesco: you might enjoy it.
08:30:06 <pesco> shapr: I'd strongly consider going.
08:30:27 <shapr> I'll be there if I can afford it. (assuming I still live in Europe, which is likely)
08:30:50 <pesco> However, I might already have started my colledge year in .cz.
08:31:02 <pesco> Next september, that is.
08:31:20 <shapr> do you speak czechoslovakian?
08:31:31 <pesco> Not very much yet, but I'm learning! ;-)
08:31:34 <shapr> nifty!
08:32:04 <pesco> It's a cool language. Makes you sound like the villains in 007 movies. ;-P
08:32:07 * shapr laughs
08:32:20 <musasabi> depends quite much the registration will be..
08:33:07 <eixei> btw, anyone from norway here?
08:33:28 <shapr> I think jlouis is from norway, he shows up here occasionally.
08:33:29 <musasabi> The trip to Tallin is dirt cheap from here...
08:33:43 <eixei> nice, thanks shapr
08:33:48 <shapr> probably a bit more expensive from here, but no comparison to traveling to Utah.
08:42:03 <pesco> groff is so _fast_!
08:42:42 <shapr> this Sniper Yagi looks *so* cool: http://www.shmoocon.org/sniperyagi/images/image018.jpg
08:43:07 <shapr> it's by far the most stylish bit of wifi gear I've ever seen.
08:44:08 <eixei> lol
08:44:45 <Cale> @yow
08:44:45 <lambdabot> What's the MATTER Sid?..  Is your BEVERAGE unsatisfactory?
08:45:42 <shapr> lambdabot needs some way to figure out if he's lost connection
08:49:52 <pesco> musasabi: I have a collection of manpages. Do you know how to make a title page for them (saying "Foo API Reference" or such).
08:49:55 <pesco> ?
08:51:52 <cm_> heyho
08:52:02 <cm_> got anyone some recommendations for papers i could print for my spain vacations? ;)
08:52:14 <eixei> lol
08:52:29 <cm_> "a nerd's gotta read what a nerd's gotta read"..
08:52:31 <cm_> but anyway :)
08:53:17 <eixei> where are you going in spain?
08:53:50 <cm_> lloret de mar
08:53:59 <cm_> but i think i'll manage not to be drunk at least a couple of days
08:54:06 <eixei> lol
08:54:25 <eixei> lloret del mar, that means you are german, right? :-)
08:55:09 <eixei> otherwise I would just recommend you a good german-(whatever you speak) dictionary
08:55:15 <cm_> jawohl
08:55:21 <eixei> that should be all you need :-)
08:55:26 <cm_> hehe
08:55:34 <cm_> i doubt german will be a problem ;)
08:55:43 <shapr> cm_: have you read Mark Jones' 1995 paper that got mfix and a bunch of other stuff going?
08:55:47 <musasabi> pesco: a simple troff page, or something containing an index to them?
08:56:02 <pesco> Just a troff page will do.
08:56:22 * shapr tries to think of really good papers to read.
08:56:42 <musasabi> uhm write a troff page? (I don't probably understand what you are after)
08:56:58 <shapr> Labra Gayo's monad transformers for compositional interpreters stuff is good, if you like that kind of thing.
08:57:02 <shapr> cm_: what are you interested in?
08:57:11 <cm_> shammah: is that "unctional Programming with Overloading and
08:57:11 <cm_> --	 Higher-Order Polymorphism
08:57:13 <cm_> "?
08:57:15 <cm_> (duh)
08:57:22 <shapr> cm_: that sounds like the right one
08:57:35 <pesco> musasabi: I have a bunch of manpages. I'd like to print them out into a pamphlet, but I'd like that to have a simple cover page.
08:57:55 <cm_> shawn_: all kind of stuff.. languages in general, type theory, garbage collection, concurrency, ..
08:58:17 <cm_> shapr: "
08:58:19 <cm_> (i suck)
08:58:25 <shapr> have you already read "Types and Programming Languages" by Benjamin Pierce?
08:58:53 <shapr> that's a really good type theory book that can get you from zero to clue in just a coupla weeks of reading.
08:59:32 <cm_> yeah, i've bought that one
08:59:43 <shapr> As for concurrency, you may want to check out the language (and papers for) Pict, also by BC Pierce and some other people.
08:59:47 <cm_> not completed it though (/me puts it into the backpack)
08:59:50 <musasabi> pesco: I usually do cover pages separately for stuff.
09:00:00 <musasabi> pesco: just use your favorite tool to do it.
09:00:00 * cm_ puts the little \pi calculus book next to it
09:00:02 <shapr> I think Pict was originally designed to do investigation into the Pi concurrency calculus.
09:00:07 <shapr> yes :-)
09:00:20 <pesco> musasabi: Hrm.
09:00:51 <shapr> also, you may want to check out some of the stuff for Epigram, it's a dependently typed language.
09:01:01 <shapr> epigram - http://www.dur.ac.uk/CARG/epigram/
09:01:25 <cm_> shapr: how about the acute paper?
09:01:54 <cm_> shapr: or "types and reflection" (did you submit that to lambda-the-ultimate?)
09:02:23 <shapr> yes, I submitted that, "Types and Reflection" is definitely worth reading.
09:02:38 <shapr> which acute paper?
09:03:07 <cm_> "Acute - High-level programming language design for distributed computing"
09:03:16 <cm_> (Aug 2004)
09:03:28 <shapr> If you want some lambda-calculus-style variety, check Brent Kerby's paper on combinator 'bases' - http://tunes.org/~iepos/joy.html
09:03:37 <shapr> oh, I don't know that one, what's the url?
09:03:57 <cm_> http://www.cl.cam.ac.uk/users/pes20/acute/acute2-long.ps
09:04:19 <shapr> cm_: on another tack, my girlfriend told me that I'm no longer allowed to bring more than a total of three academic books or papers on any future vacations :-)
09:04:21 <musasabi> hmm erlang style message passing (only better) is 30 lines of haskell code ^_^
09:04:56 <shapr> musasabi: eh?
09:05:49 <cm_> shapr: haha :)
09:05:52 <pesco> shapr: Hihihi.
09:07:19 <cm_> shapr: i suggest The Art of Computer Programming part 1-3
09:08:35 <cm_> shapr: I read the lenses paper yesterday, cool stuff :)
09:08:39 <cm_> ltu is inspiring ;)
09:10:26 <musasabi> shapr: i'll paste to the wiki.
09:11:24 <musasabi> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:13:49 <musasabi> Is that a good approach?
09:16:37 * musasabi looks at the time and runs to sauna..
09:16:48 <cm_> fin!
09:21:28 <shapr> musasabi: nifty!
09:21:39 <shapr> cm_: yah, LtU is great
09:28:56 <sysfault> The Art Of Computer Programming, is it good?
09:55:43 <musasabi> shapr: while I was in sauna I realised why that (= my code) is utterly poor and stupid... (The solution is to use channel handles instead of process handles and is even more powerfull, I'll write something up tomorrow on the topic)
09:59:37 <shapr> hiya udo
09:59:39 <shapr> musasabi: cool
09:59:51 <shapr> I think I'll go unicycle before continuing on my code.
09:59:59 <shapr> sysfault: I've heard it's awesome, but I'm too poor to purchase it.
10:00:17 <sysfault> shapr: same here.
10:01:15 <shapr> musasabi: check this out: http://www.windley.com/2004/08/25.html#a1383
10:01:26 <shapr> it's actually related to the code you just wrote :-)
10:02:32 <shapr> musasabi: couldn't that be done in Haskell with cross-RTS channels?
10:02:43 * shapr thinks about that
10:02:47 <shapr> yes, pretty easily
10:03:21 <shapr> you just set up a channel to each RTS peer
10:03:45 <shapr> ah, I like it.. it's a pull system.
10:05:25 <shapr> I wonder if cross-RTS channels would be easy to implement
10:08:00 <musasabi> shapr: I have read about tuple spaces but don't like them very much.
10:08:23 <musasabi> shapr: then again I am interested mainly in systems where you don't trust everyone.
10:09:09 <musasabi> shapr: and no you cannot implement distributed tuple spaces easily in haskell.
10:09:45 <shapr> why not?
10:09:47 <musasabi> shapr: lazyness, infinite values and the unablity to serialise functions...
10:09:54 <shapr> hm
10:10:14 <musasabi> but I don't even know why one would want a tuple space...
10:10:37 <shapr> I'd like to write programs to run on multiple Haskell RTSs
10:10:49 <shapr> I haven't found a good way to do that yet.
10:11:06 <musasabi> well there is parallel haskell (I haven't touched it and it looks scary)
10:11:19 <shapr> I've looked at it, it's not scary, but it's bitrotting.
10:11:52 <musasabi> shapr: whenever you create a distributed program you must account for 1) failure modes 2) distribution patterns 3) error handling.
10:12:06 <shapr> tuplespaces pretty much do all that
10:12:17 <musasabi> shapr: in one unified way.
10:12:26 <shapr> in that you publish a service request, and services pick up and execute the nearest request 
10:12:26 <musasabi> shapr: and that may not be what you want.
10:12:55 <shapr> I suspect you could deal with not trusting everybody by wrapping 'real' services in an authentication service.
10:13:05 <shapr> hiya SyntaxLaptop 
10:13:16 <musasabi> shapr: so you need to have a peer for authenticating...
10:13:31 <shapr> or a single local auth service
10:13:58 <shapr> for example, you post a tuple request for authenticated execution of another task
10:14:02 <musasabi> shapr: also you need limit writing so that attackers cannot insert services which look close to your request and get picked instead of your requests.
10:14:31 <shapr> hm, I see your point.
10:14:39 <shapr> lindaspaces really aren't designed for security.
10:14:52 <musasabi> shapr: a better solution is to use a kind of unified resource names, (hierachial object ids)
10:15:17 <shapr> personally, I'd be fine with a tuplespace implementation for GHC right now.
10:15:29 <shapr> as long as it works ...
10:15:39 <musasabi> basically you have a method like resolve :: Oid -> SomeThingYouCanMessage
10:16:33 <musasabi> and maybe add a simple wrapper resolve_and_fetch :: Oid -> a (resolve, send message and return reply)
10:16:52 <shapr> hm, this calls for unicycling and thought.
10:16:53 <musasabi> note that resolve uses prefix matching.
10:16:55 * shapr wobbles away
10:16:58 <musasabi> have fun
10:23:39 <eixei> hi basti
10:23:41 <basti_> hi
10:23:58 <basti_> what brings you here? 
10:24:14 <eixei> *thinks for a while and then answers*
10:24:17 <eixei> haskell
10:24:27 <basti_> oh :)
10:24:33 <eixei> how about you?
10:24:48 <basti_> uhm i'm somewhat of a regular.
10:24:58 <basti_> often did haskell.
10:25:14 <eixei> so it would be some kind of "haskell and smalltalk"? :-)
10:25:30 <basti_> uhm, yes? ;)
10:25:40 <eixei> sounds good enough for me
10:26:39 <eixei> I used to bere for a while back in jan-march or something like that
10:26:52 <eixei> but I guess shapr is the only one that remembers me :-)
10:26:52 <basti_> oh i see
10:29:16 <eixei> the channel seems to have become much bigger though
10:29:22 <basti_> hm
10:29:33 <basti_> more people, but the same talk.
10:29:44 <eixei> oh... glad to hear it
10:29:50 <eixei> mostly, the more people, the less talk
10:29:58 <basti_> oh.
10:30:03 <eixei> at least from what I've seen in other channels
10:30:04 <basti_> not really i think
10:30:42 <eixei> maybe I just joined the wrong channels :-)
10:30:47 <basti_> ;)
10:34:56 <SyntaxLaptop> hey shapr
10:35:08 <SyntaxLaptop> anna is having a good time with gnome.
10:35:13 <SyntaxLaptop> "window shopping"
10:35:32 <basti_> shapr is there?
10:35:44 * eixei liebt erdnuss-flips
10:35:47 <eixei> ooops
10:35:51 <eixei> sorry, wrong channel
10:35:54 <basti_> hehe
10:35:55 <roconnor> shapr wobbled away
10:36:15 <roconnor> I think is is a wobbly type of person.
10:38:01 <basti_> oh
10:40:53 <roconnor> ... er that was supposed to be a joke. ... Not a very good one I suppose. *l*
10:41:14 <musasabi> SyntaxLaptop: I think he went uni-cycling.
10:47:28 <SyntaxLaptop> :)
10:49:32 * pesco darcs pushes.
10:52:14 * pesco beholds his manpages.
10:52:49 <musasabi> Can I write lhs.files and convert them to "real" latex so that the code sections are prettyprinted?
10:52:57 <musasabi> lhs-files even
10:53:04 <pesco> Oh yes, you can. ;-)
10:53:49 <musasabi> and how?
10:55:40 <pesco> With lhs2TeX for example.
10:55:45 <pesco> That's what I've used.
10:56:10 <keverets> I use lhs2TeX as well.  It does the job well.
10:56:43 <pesco> Look at http://www.scannedinavian.org/~pesco/code/Cmdline/ for example code.
10:56:46 <pesco> ;-P
10:58:06 <pesco> Actually, you might want to fetch the files polycode.fmt and pescofmt.fmt from there to get the code pretty. The lhs2TeX defaults are a little out of date.
10:58:35 <pesco> kosmikus pointed me to polycode.fmt, pescofmt.fmt is what I've added for personal taste.
10:59:09 * roconnor doesn't like LaTeX.
10:59:30 <roconnor> I think I'm the only compute geek who doesn't like LaTex.
11:00:07 <basti_> yep.
11:00:46 * pesco scp's.
11:02:01 * pesco Pesco releases 1.0.
11:02:36 <Riastradh> No, you're not, roconnor.
11:03:05 <pesco> It is done.
11:06:02 <pesco> I'm afraid to say it. I have finished this command line parser from beginning to end. It's a literate program. It has a complete reference documentation, including manpages. It includes unit tests. Everything typesets beautifully. It works well. It already has one happy user. It is on the web in a convenient tarball.
11:08:29 <musasabi> pesco: thanks.
11:08:52 <roconnor> Riastradh: I'm glad I'm not alone.
11:09:02 <pesco> I think this is the first programming project I have really completed.
11:09:30 <pesco> I think I'm going to have a beer now. And put some music on.
11:09:58 <musasabi> roconnor: well there is no sensible alternative.
11:10:10 <musasabi> roff is good for short things, but not for longer ones.
11:10:16 <basti_> roff?
11:11:06 <musasabi> basti_: troff/nroff (postscript/screen)
11:11:11 <basti_> oh
11:11:12 <basti_> yes
11:12:13 <roconnor> musasabi: I'd like to think Docbook would be a sensible alternative, but I don't write many documents, so I don't know.  HTML suits my limited purposes.
11:12:40 <pesco> roconnor: Don't start on DocBook. In 20 years maybe.
11:13:07 <roconnor> Well, I've never really used Docbook, so I don't really know.
11:13:25 <pesco> You could have a look at Scribe. I've stumbled across it but couldn't use it. But it looks kind of neat.
11:13:43 <pesco> Couldn't use because it doesn't run on Mac OS atm.
11:14:27 <pesco> roconnor: I take it you were not around during one of my DB rant phases during the past week?
11:14:38 <roconnor> Nope.
11:14:57 <pesco> I wanted to use it for this project. I started to use it.
11:15:21 <pesco> Then I found out that it could not provide any of the things I wanted it to do.
11:15:30 <roconnor> pesco: Really?
11:15:36 <musasabi> roconnor: not very sensible it is.
11:15:54 <pesco> I finally switched the whole thing to LaTeX and roof over the last two or three days. And everything is wonderful.
11:15:55 <musasabi> roconnor: it is hard to produce anything good with docbook.
11:16:12 <musasabi> and certainly nothing that should be printed.
11:16:15 <roconnor> I've done some pretty crazy things using SGML and HTML.  I just haven't got to Docbook yet.
11:16:28 <pesco> roconnor: Yes. The biggest problem are the Stylesheets. The XSL stylesheets, that is. I didn't want to use SGML.
11:16:55 <roconnor> Oh.  I'm looking forward to writing DSSSL stylesheets for Docbook.
11:17:07 <roconnor> Unfortunately DSSSL isn't really supported. :-(
11:17:23 <pesco> I wanted to use it because I thought the whole structural markup idea was good in principle and it suited my needs:
11:18:12 <roconnor> http://math.berkeley.edu/~roconnor/math240/cubic.html
11:18:20 <pesco> I wanted a literate program that I could transform to PDF. Actually there it was mainly "Hey, this docbook thing looks cool, let's use it".
11:18:26 <roconnor> I wrote my paper using SGML extensions of HTML.
11:19:01 <roconnor> The structural markup of SGML seems better than LaTeX.
11:19:23 <musasabi> roconnor: doing math in xml/sgml is very painfull.
11:19:30 <pesco> True. But the important structure _is_ in LaTeX.
11:19:37 <musasabi> MathML is not very usable (or at least was not in 2001)
11:20:06 <roconnor> It's not so bad if you make your own SHORTREFs
11:20:07 <pesco> The only real difference I can see is in small things like marking inline text as "code" or "user input" or "program output".
11:20:27 <pesco> That's not possible in plain LaTeX.
11:20:43 <musasabi> We were evaluating things for producing lots of math content online then and the result was tat it is simpler to write tools to create suitable pages from latex than to us XML.
11:20:48 <musasabi> *use
11:21:03 <roconnor> I write `p`(`t[i]`) = `f`[1](`t[t]`) to produce ...
11:21:05 <musasabi> roconnor: the only problem is then collaboration.
11:21:06 <pesco> I'll believe that any time.
11:21:30 <musasabi> roconnor: 20 people each using his/her favorite short-refs.
11:21:36 <roconnor> <var>p</var>(<var>t</var><sub><var>i</var></sub>)&nbsp;=&nbsp;<var>f</var><sub>1</sub>(<var>t</var><sub><var>i</var></sub>)
11:21:38 <musasabi> roconnor: and you cannot have them in XML.
11:22:25 <pesco> roconnor: What is SO(3), quick?
11:22:32 <roconnor> I pass my source through sgmlnorm, and the result is more or less valid XML.  At least it can be SGML.
11:22:43 <roconnor> &so3;
11:22:47 <roconnor> is what I used.
11:22:58 <roconnor> I did have to define it once though.
11:23:23 <pesco> No, I mean mathematically?
11:23:31 <roconnor> oh
11:23:41 <roconnor> It is the special orthogonal group of 3x3 matrices.
11:23:46 <pesco> Ok.
11:23:48 <roconnor> Do you want more information.
11:24:12 <pesco> Sure. :)
11:24:26 <musasabi> roconnor: yes, but that form of xml is extremely unfriendly...
11:24:39 <musasabi> roconnor: for humans that is.
11:26:21 <roconnor> pesco: 3x3 matrices represent linear transformations of 3D vectorspace.  O(3) are the transformations that are rigid (preserve distances).  So they are mirror flips, and rotations.  SO(3) is just rotations, and no mirror flips.
11:26:45 <pesco> Oh. cool.
11:26:50 <roconnor> musasabi:  That's why I don't write XML.  I write SGML with SHORTREFs, and transform it into code that computers like.
11:27:20 <pesco> My linear algebra is quite weak. I'm happy about any change to that state. ;-)
11:27:25 <roconnor> So when animating an object you use R^3 to represent it's position, and SO(3) to represent it's orientation.
11:28:57 <pesco> Yes.
11:29:09 <pesco> ugh
12:04:55 * shapr luvs unicycling.
12:07:52 <shapr> musasabi: I think the capability security stuff in E is the only decent way I've seen to do mutually suspicious grid/distributed computing.
12:10:48 <Cale> plusPF = (.(.)) . ((.(.)).) . (.) . (.(.(+))) -- ahaha
12:10:57 <shapr> ???
12:11:11 <shapr> @type (.(.)) . ((.(.)).) . (.) . (.(.(+)))
12:11:12 <lambdabot> (.(.)) . ((.(.)).) . (.) . (.(.(+))) :: forall c a c1 c2.
12:11:12 <lambdabot> 					(Num a) =>
12:11:12 <lambdabot> 					((a -> c1) -> c2) -> ((a -> c) -> c1) -> (a -> c) -> c2
12:11:18 * shapr undrar
12:11:22 <shapr> um.. wonders
12:12:03 <shapr> oh, I begin to understand.
12:13:51 * shapr almost gets it
12:16:07 <shapr> oh, I do get it.
12:16:19 <shapr> neat
12:20:11 <roconnor> ?
12:21:41 <shapr> Cale: what does the PF stand for?
12:22:00 <Cale> point-free, I suppose -- someone just added that to the wiki
12:22:18 <roconnor> @type (.(.))
12:22:18 <shapr> ah
12:22:19 <lambdabot> (.(.)) :: forall b c a c1.
12:22:19 <lambdabot> 	  (((a -> b) -> a -> c) -> c1) -> (b -> c) -> c1
12:22:46 <Riastradh> That's definitely not point-free!
12:22:59 <Riastradh> There are indeed eleven points.
12:23:05 <Cale> heheh
12:23:06 <roconnor> *groan*
12:23:23 * shapr snerks
12:23:37 <shapr> that is both terrifying and nifty.
12:23:43 <shapr> I suspect TheHunter wrote that.
12:24:54 <roconnor> I don't know what the expression does
12:25:21 <shapr> look at the types
12:25:31 <shapr> well, it took me ten minutes of staring...
12:25:46 <Riastradh> Just keep staring.
12:26:18 <Riastradh> At some point, it'll burn really hard into your retinas and then you can shift your eyes and everywhere you look you'll have to see the expression, so you'll be forced into understanding what it does.
12:27:42 <shapr> ((a -> c1) -> c2) -> ((a -> c) -> c1) -> (a -> c) -> c2 - let's call the three arguments a, b, and c. b produces a c1, so it's the first argument of a, and c is the first argument of b. That means you lack only the first incoming a to get the whole thing rolling
12:27:51 <shapr> it's a painfully explicit monad
12:28:27 <shapr> roconnor: make more sense now?
12:29:10 <roconnor> I got that.  I don't get the (Num a) requirement, or where (+) fits into this.
12:29:19 <roconnor> Hard to see that from the type.
12:30:54 <roconnor> @type (.)
12:30:55 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
12:31:03 <shapr> roconnor: on this page: http://www.haskell.org/hawiki/MonadicStyleTransformation in the section "Relation to Continuation Passing Style Transformation"
12:32:15 <pesco> Woah, writing manpages is such fun!
12:32:26 <shapr> pesco: so, you going to make a Cabal package too?
12:32:40 <pesco> shapr: Is Cabal ready?
12:32:48 <shapr> well, it works ...
12:32:55 <shapr> dunno if that means it's ready or not.
12:33:32 <shapr> Anyway, SyntaxLaptop is the expert there.
12:33:50 <pesco> If there are no major obstacles to making a package, of course I'll do it. :)
12:34:26 <roconnor> @type (.(.(+)))
12:34:27 <lambdabot> (.(.(+))) :: forall a c c1.
12:34:27 <lambdabot> 	     (Num a) =>
12:34:27 <lambdabot> 	     ((a -> c) -> c1) -> ((a -> a) -> c) -> c1
12:34:27 * shapr pulls the latest cabal
12:35:01 <roconnor> @type (.(+))
12:35:02 <lambdabot> (.(+)) :: forall a c. (Num a) => ((a -> a) -> c) -> a -> c
12:35:05 <shapr> Cale: that reminds me of those crazy multi-arg function composition functions you came up with.
12:35:24 <Cale> heheh
12:35:47 <musasabi> things like that are not very usefull for getting a wider acceptance for haskell.
12:35:53 <pesco> I'm still amazed at the speed of the "vim<->groff" cycle.
12:36:08 <roconnor> okay, that's the first fragment I understand.
12:36:18 <shapr> musasabi: I think it was written just for educational comparison of CPS and monads.
12:36:20 <musasabi> yes, no waiting 30 secs for latex to be ready.
12:36:25 <musasabi> shapr: true.
12:36:26 <pesco> Multi-arg function composition? I need those!
12:36:50 <shapr> it's someting simple like (.(.)) for two-arg... Cale came up with a lot more that I've forgotten.
12:37:19 <shapr> @type (.(.))
12:37:20 <lambdabot> (.(.)) :: forall b c a c1.
12:37:20 <lambdabot> 	  (((a -> b) -> a -> c) -> c1) -> (b -> c) -> c1
12:37:31 <shapr> @type (.(.).)
12:37:32 <lambdabot> bzzt
12:37:42 <shapr> @type (.).(.)
12:37:43 <lambdabot> (.).(.) :: forall a b c a1.
12:37:43 <lambdabot> 	   (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:37:47 * shapr blinks
12:38:28 <shapr> oh hey
12:38:34 <shapr> I just had a crazy idea for a lambdabot plugin...
12:39:04 <shapr> it randomly generates a type signature, and multiple players try to write a chunk of code that has that type sig.
12:39:11 <shapr> irc games :-)
12:39:31 * shapr wonders just how silly that is.
12:40:01 <roconnor> oh, that page makes a lot more sense.
12:40:09 <shapr> roconnor: oh what did you figure out?
12:40:54 <roconnor> Well, I don't understand the function yet, but I think I understand what it is trying to do.  Basically a coninuation passing style of + right?
12:41:35 <shapr> yes, one that makes eval order explicit.
12:42:34 <roconnor> The type is more general that would be expected.  I would have expected ((a -> r) -> r) -> ((a -> r) -> r) -> ((a -> r) -> r)
12:43:39 <roconnor> or maybe ((a -> r1) -> r1) -> ((a -> r2) -> r2) -> ((a -> r3) -> r3)
12:44:18 <shapr> for some reason I think those types sigs aren't necessarily explicit about evalution order, but I'm sure if that's right.
12:44:26 <shapr> "not sure"
12:45:03 * basti_ .o° ( . . . )
12:46:12 <roconnor> oh
12:46:24 <roconnor> interesting
12:46:36 <shapr> the type sig on the wiki page is nested
12:46:46 * shapr isn't sure how to explain that
12:47:18 <shapr> hi stratocaster, how's the big city?
12:47:42 <shapr> roconnor: does what I said make sense?
12:47:57 <shapr> I think the nested type sig is explicit about eval order even from the type sig.
12:47:57 <roconnor> I thinks so
12:48:22 <shapr> there's only one eval order in which to plug together the arguments to match that type sig
12:48:51 <shapr> but with "((a -> r) -> r) -> ((a -> r) -> r) -> ((a -> r) -> r)" eval order is not as explicit
12:49:41 <SyntaxLaptop> hi pesco cabal questions?
12:49:53 * shapr bounces
12:49:56 <pesco> SyntaxLaptop: Not, yet. Reading the proposal.
12:51:01 <shapr> anyway, I'm glad TheHunter wrote that page, I've just learned something new.
12:52:06 <SyntaxLaptop> where's Marvin-- been lately?
12:52:34 <SyntaxLaptop> pesco: it works for packaging simple stuff.
12:52:51 <pesco> Pesco.Cmdline should be simple enough, I guess...
12:53:26 <roconnor> @type \a b f -> a (\x -> b (\y -> f (x+y)))
12:53:27 <lambdabot> \a b f -> a (\x -> b (\y -> f (x+y))) :: forall t t1 t2 a.
12:53:27 <lambdabot> 					 (Num a) =>
12:53:27 <lambdabot> 					 ((a -> t1) -> t) -> ((a -> t2) -> t1) -> (a -> t2) -> t
12:53:38 * roconnor compares with the wiki
12:54:49 <pesco> SyntaxLaptop: I only have an old version of Hugs, will that be a problem (seeing runhugs there)?
12:55:34 <SyntaxLaptop> pesco: cabal is pretty portable, but it probablyi depends on how old your hugs is.
12:55:35 <pesco> I see, no.
12:55:42 <SyntaxLaptop> pesco: no ghc?
12:55:51 <pesco> Yes, GHC 6.2.
12:56:01 <pesco> I just saw the runhugs. But I've now seen that it doesn't matter.
12:56:07 <SyntaxLaptop> right.
12:56:59 <musasabi> hmm lhs2tex does not know how to make the haskell source colored?
12:57:36 <pesco> It can do that, but not by default.
12:57:38 <shapr> roconnor: yes, that's t.
12:57:40 <shapr> "it"
12:58:04 * roconnor demonstrates at least some understanding.
12:58:16 <pesco> musasabi: There is a .fmt file for just that in its latest version in the Subversion repository.
12:58:32 <roconnor> Haskell is as bad as perl. *l*
12:58:37 <shapr> I went through all these detailed tracing about inside monads not that long ago, so it's fresh in my memory.
12:58:45 <roconnor> write only code
12:59:17 <shapr> monads are actually quite readable imho, you just have to understand how the whole structure 'falls out'
12:59:43 <shapr> I think monads are a good instance of Richard Gabriel's 'Worse is Better' saga.
12:59:47 <roconnor> In the CPS style, I'm still not sure which of a or b is evaluated first.  It looks like b is.
13:00:16 <roconnor> monads make perfect sense to me.
13:00:21 <shapr> actually, I think monads are an instance of the *answer* to 'Worse is Better'
13:00:47 <roconnor> CPS also makes sense, but they are hard to read.
13:00:47 <shapr> monads took me a long time to figure out, but when I had that thunderclap of understanding, everything was crystal clear.
13:00:49 <pesco> musasabi: Go to https://svn.cs.uu.nl:12443/repoman/info/lhs2TeX
13:01:40 <roconnor> shapr:  I missed out on the thunderclap.  After reading enough tutorials, one made sense.
13:01:42 <shapr> I think Object Oriented programming is just as hard to really 'get' as monads, but more people have done it, so it's easy to find people who will explain till they're blue in the face.
13:01:53 <roconnor> reading tutorials over a long period of time.
13:02:14 <roconnor> But perhaps that last tutorial wouldn't have made sense if I hadn't read all the others first.
13:02:23 <shapr> well, I haven't had the same lightning bolt with arrows yet, but I'm seeing small sparks at least.
13:02:45 <roconnor> By OOP you mean virtual functions?
13:02:48 <shapr> I wonder if I could bribe the nomaware guy to write an arrows tutorial.
13:03:00 <pesco> musasabi: The file you want is https://svn.cs.uu.nl:12443/repos/lhs2TeX/lhs2TeX/trunk/Library/colorcode.fmt
13:03:08 <shapr> virtual functions?
13:03:48 <roconnor> Well puting code and functions together isn't so hard to understand.  But overriding methods is pretty crazy.
13:03:51 <pesco> musasabi: Then you can give the \colorhs command at the beginning of your program and I guess the code will be colored ;-)
13:04:08 <shapr> when I say OOP, I think of class inheritance, instance statefulness, and how all that can make programming easier.
13:04:47 <pesco> musasabi: Oh no! I'm lying. colorcode.fmt is only for putting the code in colored _boxes_... :-(
13:05:24 <musasabi> I think it could be done.. oh well I can do it with putting latex and haskell in separate source files too.
13:05:24 <SyntaxLaptop> anyone got c2hs? is there a -o option?
13:05:25 <pesco> I'm sorry. But still, you can color things. But you'll have to find out how on your own. I don't know that, because I prefere code uncolored.
13:05:54 * shapr sends an email to Jeff Newbern, writer of the nomaware monads tutorial.
13:06:02 <shapr> SyntaxLaptop: I have the 0.13.something version
13:06:13 <shapr> and a deb that seems to work but doesn't produce a source package :-)
13:06:39 <SyntaxLaptop> shapr: so? -o option?
13:06:41 * shapr loos
13:06:44 <shapr> looks
13:07:09 <shapr> yes
13:07:20 <roconnor> nomaware monads tutorial: That's the one I read last.
13:07:41 <musasabi> Has anyone got emacs to make the literate part of .lhs files to work in latex-mode?
13:08:04 <shapr> huh, that would be neat.
13:08:22 <shapr> oh, maybe one could actually combine preview-latex and haskell-mode...
13:08:24 <musasabi> well it is certainly possible...
13:08:25 <shapr> that would be way sexy
13:08:44 <shapr> SyntaxLaptop: http://thunderbird.scannedinavian.com/~shae/c2hs--help.txt
13:08:47 <roconnor> I won't be happy until my editor give me types of subexpressions.
13:08:56 <shapr> epigram does that.
13:08:58 <shapr> sort of
13:09:13 <shapr> anyway, I think epigram is going that way, towards editors using type slicing to show errors.
13:09:27 <SyntaxLaptop> shapr: can you let me know if "-ofoo" works, or if there must be a space?
13:09:34 <musasabi> roconnor: make an elisp function that types it to the ghci function and displays the result in the statusbar.
13:10:33 <shapr> Is there some way for GHC to dump type-slicing error information?
13:10:48 <shapr> if so, it wouldn't be so hard to use that for syntax hightlighting in haskell-mode
13:11:09 * shapr looks for something to use to test c2hs
13:12:44 <SyntaxLaptop> shapr: don't worry about it :)
13:12:51 <SyntaxLaptop> shapr: thanks for the help output :)
13:13:18 <shapr> well, I've been meaning to use c2hs to build gtk2hs anyway... but it'll take me awhile to get that all setup.
13:14:10 <shapr> btw, David Roundy said he won't put more effort into a graphical darcs GUI unless wxHaskell finds its way into debian. (because it's too much trouble to reinstall it regularly)
13:14:40 <SyntaxLaptop> I know
13:14:45 <SyntaxLaptop> I already talked to him.
13:14:53 <shapr> I'm beginning to think that Haskell needs more *debs* rather than more libraries.
13:15:32 <shapr> oh, I still haven't tried your new WASH debs, where are they again?
13:15:46 <shapr> I've been wondering about hacking WASH to generate XUL
13:16:35 <SyntaxLaptop> shapr: they're not online right now. I'll try to get them into haskell-unsafe ASAP
13:16:48 <shapr> ok, spiffy
13:17:12 <shapr> of course, this means I've really gotta finish the c2hs deb, and see what others I can do.
13:17:25 <shapr> SyntaxLaptop: any suggestions?
13:18:06 <shapr> ah, buddha
13:19:22 <SyntaxLaptop> shapr: buddah would be cool. of course, my suggestion would be to get stuff packaged for cabal, and then use the debian templates to mak ehte .deb :)
13:19:36 <shapr> good point
13:21:22 <musasabi> I would like the cabal->deb route
13:21:33 <musasabi> As it would make it easy to create BSD packages too ;)
13:21:50 <SyntaxLaptop> ahh... cabal is so wonderful.
13:22:30 * SyntaxLaptop is working on preprocessors now...
13:22:47 <SyntaxLaptop> who thinks that cpphs should be included w/ cabal?
13:26:11 <pesco> Oh this is fun, the proposal tell me how to install Cabal, using Cabal... :)
13:27:37 <SyntaxLaptop> heh. in reality, it uses a bootstrap makefile
13:27:52 <pesco> Hm.
13:28:22 <pesco> Should I pull from the repo or download the tarball?
13:29:06 * pesco is pulling.
13:29:30 <SyntaxLaptop> the repo one should be OK :)
13:33:59 * pesco sudo makes install.
13:35:33 <pesco> neeto.
13:35:36 * shapr agrees
13:37:08 <pesco> Hm, I thought it was going to install HUnit as well?
13:37:37 <shapr> SyntaxLaptop: are cabal packages 'cabs' ?
13:37:44 <pesco> Heh
13:37:49 <SyntaxLaptop> pesco: it doesn't need hunit anymore
13:37:53 <SyntaxLaptop> unless you compile with DEBUG
13:37:59 <SyntaxLaptop> shapr: they can be if you want :)
13:38:17 <pesco> Syntax: Does it include HUnit? I would like to install it. :-)
13:38:31 <pesco> Oh yes, there it is.
13:38:33 <SyntaxLaptop> pesco: yeah.
13:39:52 <kuz> Hmm.
13:40:12 <shapr> hi kuz 
13:40:15 <shapr> wassup?
13:40:34 <kuz> Would overloading cab be confusing?
13:40:40 <shapr> I dunno.
13:40:47 <shapr> cab files are rarely seen on unices.
13:41:04 <pesco> Gah! It installed the Cabal package root-readonly!
13:41:18 <SyntaxLaptop> strange
13:41:26 <SyntaxLaptop> must be your fault.
13:41:27 <SyntaxLaptop> ;)
13:42:26 <pesco> My umask is 022, that's not the problem.
13:43:48 <pesco> SyntaxLaptop: Do you have any idea what could be causing this?
13:44:03 <SyntaxLaptop> pesco: nope. it's a little strange.
13:44:17 <pesco> What kind of method does it use to install its files.
13:44:29 <SyntaxLaptop> haven't heard anyone complain about this. maybe it's the permissions on the files you downloaded?
13:44:31 <pesco> Note: The directories have correct permissions.
13:45:16 <kuz> Yay.
13:45:18 <pesco> No.
13:45:25 <SyntaxLaptop> pesco: it's probably using Distribution.Simple.Utils.copyFile
13:45:51 <kuz> Just what I wanted to do; fix an ebuild.
13:46:01 <kuz> Happy Saturday, me!
13:46:10 <pesco> kuz: Woohoo. Have fun!
13:48:43 <SyntaxLaptop> pesco: what are the permissions in dist/build ?
13:49:25 <pesco> 755.
13:49:41 <musasabi> Is there a reason StablePtr's are not in Ord ?
13:50:04 <pesco> On the directory. 644 on all .hi and .o files.
13:50:11 <pesco> The .hs files however show 700.
13:50:11 <SyntaxLaptop> pesco: do the files have the wrong permissions, as they do in the installation?
13:50:36 <goron> What's the algo. complexity of group?
13:50:51 <SyntaxLaptop> pesco: what kind of system are you using?
13:50:53 <musasabi> @index group
13:50:53 <lambdabot> Data.List,List
13:51:07 <pesco> SyntaxLaptop: powerpc-apple-darwin
13:52:06 <SyntaxLaptop> pesco: I can't remember for sure, but the files in dist/build probably don't use our custom copyFile function
13:52:18 <pesco> Er.
13:52:43 <goron> Oh, I see, it's O(n), although it's not in the docs.
13:52:44 <musasabi> goron: group is 3 lines of code...
13:52:53 <SyntaxLaptop> I mean, that's just where ghc sticks them.
13:53:02 <goron> musasabi: And?
13:53:44 <musasabi> goron: meaning the complexity is quite easy to understand. 
13:53:50 <musasabi> wait no.
13:53:54 <musasabi> That is not true. 
13:54:01 <musasabi> Short != easy to understand. 
13:54:10 <musasabi> true in this case though.
13:54:15 <musasabi> true in this case though.
13:54:18 <musasabi> sorry.
13:54:28 <musasabi> irssi wanted to say that instead of /c.
13:54:56 <goron> musasabi: But I don't have the sources. Although it's possible to get them, yes...
13:55:00 <SyntaxLaptop> pesco: if you feel like helping to debug this, can you try to compile a file in that directory using ghc?
13:55:31 <pesco> Could it be that the problem is with the getPermissions >>= setPermissions action?
13:55:37 <shapr> dang, I was going to say how he can get the sources.
13:55:58 <musasabi> the libraries sources are very educating - to me at least.
13:56:04 <shapr> me too
13:56:13 <shapr> and occasionally mystifying.
13:56:17 <SyntaxLaptop> pesco: if the permissions in dist/build are still wrong, then I don't think that's the problem, since I don't think that they use copyFile to get there.
13:56:27 <musasabi> although they cause me to rewrite code seing how much simpler I could have done things.
13:56:49 <shapr> Someone recently said "With C++ and Java there's a lot to learn, and not much to understand, with Haskell and some others, there's not much to learn, but very much to understand."
13:57:15 <pesco> SyntaxLaptop: The Permissions type doesn't seem to include the owner/group/user info. Maybe setPermissions leaves the group and user fields at 0?
13:58:04 <pesco> SyntaxLaptop: Which directory did you mean, where I should try compiling something?
13:59:58 <SyntaxLaptop> pesco: well, you could just load up Utils.hs and try using copyFIle to see if the permissions setting screws things up.
14:00:13 <SyntaxLaptop> pesco: but I'm not convinced that copyFile is even getting called
14:00:55 <SyntaxLaptop> what i was suggesting was to compile something in the cabal root directory and output it to dist/build and see if the permissions are messed up
14:01:26 <pesco> But the permissions in dist/build are right for all the files that get copied.
14:02:02 <SyntaxLaptop> oh, OK.
14:02:09 <SyntaxLaptop> then it sounds like copyFile is the culperate
14:04:03 <pesco> Yes, it is. Manual call to copyFile confirms loss of all bits in group and other permission fields.
14:04:38 <SyntaxLaptop> sucks. hm. thanks for noticing this.  it seems to work on some other Unixes.  I wonder how we're going to manage to get the permissions right :(
14:04:51 <SyntaxLaptop> maybe it's something GHC can fix?
14:05:09 <pesco> Lemme check the docs for get/setPermissions
14:06:26 <pesco> I see. It says nothing about the behaviour for user/group/other fields.
14:06:39 <pesco> Probably the behaviour on my platform differs from other platforms.
14:08:01 <SyntaxLaptop> yeah :(
14:08:10 <SyntaxLaptop> does your platform implement System.Posix?
14:10:09 <pesco> I think so.
14:10:33 <SyntaxLaptop> maybe I can change it to use FileMode
14:10:41 <SyntaxLaptop> if I mess with this for a few minutes, will you try it out?
14:11:56 <pesco> Yes.
14:12:16 <pesco> I'm trying to track down what exactly setPermissions is doing.
14:12:46 <SyntaxLaptop> pesco: does it always strip away the bits? what if you copy something from /tmp/foo to /tmp/bar?
14:13:29 <pesco> Yes.
14:14:12 <pesco> AFAICS, setPermissions applies False to all fields but True only to the owner field.
14:14:22 <pesco> ls -l moo
14:14:34 <pesco> -rw-r--r-- ...
14:14:51 <pesco> setPermissions (Permissions False False False False)
14:15:01 <pesco> => -rw-------
14:15:07 <pesco> er, ----------
14:15:21 <pesco> Then setPermissions (Permissions True True False False)
14:15:27 <pesco> => -rw-------
14:18:00 <musasabi> Why is unsafeInterleaveIO unsafe?
14:21:43 <SyntaxLaptop> pesco: OK I uploaded a fix, but it's just a quick hack, and will only work on a posix system, but would you mind trying it out?
14:21:54 <pesco> NP.
14:21:55 <SyntaxLaptop> well, it's not such a bad hack, it's just that it only works for posix.
14:23:38 <SyntaxLaptop> does anyone know whether windows has the Posix module?
14:27:00 <shapr> hey jpgil-cl 
14:27:06 <jpgil-cl> hi shapr
14:27:18 * jpgil-cl is still playing with Helium, in his free time
14:27:19 <shapr> any further thoughts on XML?
14:27:52 <jpgil-cl> I downloaded those PDF to my PC, but for now I'm studying Haskell instead.
14:27:57 <shapr> ok
14:28:01 <shapr> any Haskell questions?
14:28:57 <jpgil-cl> Mmm, not yet :)  I'm making my own functions and following the book of Jeroen Fokker
14:29:12 <jpgil-cl> But I'm stil far of a real world app.
14:29:39 <jpgil-cl> Also, I've to reade carefully about Haskell Style and Haskell Literacy.
14:30:16 <cm> Any parsec wiz around? How do i rewrite "intLiteral = do{ i <- integer; return (IntLit i) }" to something without the "do" construct?
14:30:47 <pesco> SyntaxLaptop: Permissions look right now.
14:31:00 <pesco> But, I'm getting the following undefined symbols from ld:
14:31:09 <pesco> _DistributionziPreProcess_preprocessSources_closure
14:31:10 <pesco> ___stginit_DistributionziPreProcess_
14:31:37 <pesco> This might be related to what ld said earlier:
14:31:47 <shapr> jpgil-cl: well, if you have any questions, feel free to ask them.
14:31:51 <pesco> ld: archive: /usr/local/lib/Cabal-0.1/libHSCabal-0.1.a has no table of contents, add one with ranlib(1) (can't load from it)
14:32:02 <jpgil-cl> Yes, I know this is the right place. Thanks you very much.
14:32:03 <pesco> I did just that, ran ranlib...
14:32:38 <shapr> hiya Rhymes, looking for Haskell info?
14:32:47 <SyntaxLaptop> pesco: I'm guessing that's not going to cause you a problem.
14:33:03 <Rhymes> hi shapr :)
14:33:06 <pesco> Those messages were produced by "ghc -package Cabal -o Setup Setup.lhs" in tests/HUnit-1.0/
14:33:45 <SyntaxLaptop> pesco: that's because of a missing "Distribution.PreProcess" in Setup.description
14:33:52 <SyntaxLaptop> PreProcess is what I'm in the middle of working on
14:33:54 <SyntaxLaptop> well, it might break.
14:33:56 <SyntaxLaptop> hm.
14:34:05 <pesco> Erm. How do I fix this?
14:34:45 <SyntaxLaptop> one sec. I'll have a patch for you
14:35:49 <SyntaxLaptop> OK pull again :)
14:36:16 <SyntaxLaptop> you might want to make remove by the way, but no promises that it'll work perfectly
14:36:36 <pesco> What does make remove do?
14:36:56 <SyntaxLaptop> tries to remove and unregister cabal.
14:37:04 <pesco> It tried to remove HUnit as well.
14:37:07 <SyntaxLaptop> yeah
14:37:11 <SyntaxLaptop> that's why I thought it might not work.
14:37:58 <jpgil-cl> @type case
14:37:59 <lambdabot> bzzt
14:38:13 <pesco> Haha.
14:39:27 <pesco> Syntax: Do you have an idea where this ranlib messag is coming from? And what it means, practically?
14:39:47 <jpgil-cl> Mmm, I don't find what "case" means in Haskell... it's like the switch / case in C?
14:40:08 <SyntaxLaptop> pesco: nope.
14:40:22 <pesco> Still undefined:
14:40:23 <pesco> _DistributionziPreProcessziUnlit_plain_closure
14:40:26 <pesco> _DistributionziPreProcessziUnlit_unlit_closure
14:40:26 <pesco> ___stginit_DistributionziPreProcessziUnlit_
14:40:38 <pesco> I think I've come across that ranlib thing before. Maybe it's GHC's fault.
14:40:56 <pesco> But that's not so bad, I can do the ranlib myself.
14:41:11 <SyntaxLaptop> can you "ghci -package Cabal"?
14:41:13 <pesco> But it's late, let's continue with this tomorrow, when you've finished the PreProcess thing.
14:41:37 <pesco> No, the impossible happened. ;-)
14:41:38 <SyntaxLaptop> OK. thanks for helping me w/ that permissions bug. 
14:41:44 <SyntaxLaptop> not... the impossible?!
14:41:50 <SyntaxLaptop> goodness
14:42:00 <pesco> *g*
14:42:07 <SyntaxLaptop> OK ttyl. thanks again.
14:42:13 <pesco> Byebye.
15:09:42 * shapr writes vicious rejoinders to "FP sucks" on WardsWiki
15:09:48 * shapr cackles evilly
15:11:44 * shapr roots out the infidels
15:16:27 <kaol> FP is more fun than a herd of cats
15:16:54 <Riastradh> What about a herd of cats writing functional code?
15:17:26 * jpgil-cl gets nervous about recursive claws
15:17:30 * shapr owns a herd of cats.
15:17:41 <shapr> assuming five is a herd.
15:17:42 <kaol> isn't that infinite recursion? Good thing that Haskell is lazy, then.
15:18:20 <kaol> A friend has 11.
15:18:23 <shapr> wow
15:19:05 <shapr> I enjoy arguing with these people who say that mutability is absolutely necessary for efficiency.
15:19:16 <shapr> I point them to GCC which uses SSA internally.
15:19:35 <Riastradh> ...uh, SSA doesn't imply immutability.
15:19:42 <shapr> that's right.
15:20:26 <shapr> It also doesn't imply that an immutable model is inherently inefficient.
15:21:01 <kaol> I like to think that getting code efficient is the compiler's concern, not mine.
16:25:56 <jpgil-cl> Any one is awake?
16:26:38 <jpgil-cl> Fudget... I found a doctoral thesis regarding that. Any thoughts about?
16:26:49 <roconnor> I'm awake
16:27:13 <jpgil-cl> Hey, hello roconnor. Have heard about Fudgets?
16:27:22 <roconnor> nope
16:27:35 <jpgil-cl> http://www.cs.chalmers.se/~hallgren/Thesis/top.html   .. 1998, Sweeden
16:28:50 <roconnor> I like the cover page!
16:31:05 <roconnor> this is almost as exciting as reading about how lazy functional languages are compiled.
16:31:34 <jpgil-cl> That was a sarcasm or truly interest?
16:31:46 <roconnor> interest.
16:32:06 <jpgil-cl> I feel so. (Excepto that I don't deal with compilers)
16:32:10 <roconnor> One step closer to my goal of writing a ``pure'' functional operating system.
16:32:26 <jpgil-cl> Are you involved in hOs ?
16:32:28 <roconnor> Maybe goal is a bit of a strong word.
16:32:35 <roconnor> Nope, never heard of it.
16:34:29 <Rhymes> is haskell dinamically and strongly typed, right?
16:34:55 <roconnor> haskell is statically and strongly typed.
16:35:00 <Rhymes> ok thanks
16:35:08 <Rhymes> i started learning it two minutes ago :)
16:35:16 <roconnor> strong and weak type systems are not well defined terms.
16:35:41 <jpgil-cl> I'm few days older than your, Rhymes :)
16:35:44 <roconnor> I assume weak types systems mean that you can cast types.
16:35:45 <Riastradh> Sure they are.  A strong type system does not permit unchecked type errors; a weak type system does.
16:35:46 <Rhymes> mmm in python, where i come, the type system is strong but dynamic
16:36:25 <Rhymes> it means that you cannot change the type of an object like in php "6" + 4 in php is 10 if i remember correctly
16:36:31 <Rhymes> in python is an error
16:36:58 <Rhymes> and if a object is a string, it will remain a string until garbage collection
16:37:05 <roconnor> Riastradh: I mantain you will find strong and weak types used in various ways in many places.
16:37:45 <Riastradh> The terms are sometimes misused to mean static & dynamic, respectively, but that is misuse.
16:37:58 <jpgil-cl> Rhymes: right, 10 in PHP. Even "10s" + 1.1 is 11.1
16:38:02 <roconnor> Riastradh: fair enough.
16:38:10 <Rhymes> jpgil-cl: bleah :D
16:38:15 <jpgil-cl> hehe
16:38:19 <Rhymes> it is definitely ugly
16:38:32 <roconnor> Rastradh: I think our definitions of strong and weak types systems are the same?
16:38:44 <jpgil-cl> It's useful many times, but a BIG source of bugs. Tons of them.,
16:39:01 <roconnor> I don't think the implict conversion of "10" to the number 10 makes a system weakly typed.
16:39:09 <Riastradh> Almost, roconnor.  Casting/type conversion does not make a type system inherently weak; _unsafe_ coercion does.
16:39:24 <roconnor> Riastradh: right.
16:39:37 <jpgil-cl> Couly give an example, Riastradh? I don't get it.
16:39:42 <roconnor> A weak type system has ``reinterpret_cast''s (to use a C++ term)
16:39:56 <Rhymes> i use python for quite everything, i didn't reach the end of php manual, it's a big idiosyncrasy as a language
16:41:16 <Riastradh> jpgil-cl, in C, try this: printf("%s\n", 1.23);
16:41:24 <roconnor> Casting an object of a class to a decendent class is a common thing to do in Java, and is an example of why Java is weakly typed.
16:42:09 <jpgil-cl> Riastradh: but that's implicit conversion, isn't?
16:42:29 <Riastradh> jpgil-cl, whether it's implicit or explicit is irrelevant.
16:43:23 <Rhymes> wowow i read about lazy evalution, what a great feature :) very nice
16:43:32 <Rhymes> s/evalution/evaluation
16:43:34 <roconnor> jpgil-cl: the print won't print 1.23.  If it did print 1.23 then it would be using implicit conversion, the fact that it prints random garbage is what makes the system weakly typed.
16:44:19 <jpgil-cl> Oh, I see! I don't use C, now I see.
16:44:27 <roconnor> Rhymes: Unfortunately lazy evaluation isn't a great as it sounds. :'(
16:44:57 <roconnor> Rhymes: but there are a couple of cool things you can do with it.
16:45:06 <Rhymes> roconnor: newbie enthusiasm :(
16:45:25 <Rhymes> roconnor: what are those couple of things?
16:45:31 <jpgil-cl> Ryhmes: one thing I was very impressed about lazy evaluation is the definition on "replicate"
16:45:33 <roconnor> Rhymes> :-)  Haskell is pretty exciting.  Have you used Scheme or ML?
16:46:05 <roconnor> Rhymes: When the introduce laziness the talk about circular and infinite data structures.
16:46:06 <Rhymes> no i'm totally a newbie in the functional languages domain
16:46:15 <roconnor> Those are some examples.
16:47:00 <roconnor> There are some other neat things like making doubly link-lists that you are probably not ready to see yet.
16:47:21 <jpgil-cl> Rhymes: replicate n x = take n (repeat x) ... means that you extract the first "n" elements of the *infinite* list of repeat the term "x".
16:47:26 <Rhymes> roconnor: this winter it seems that i have to learn using clisp for a university course, so, because i heard speaking about haskell very well i want to give it a try
16:47:36 <roconnor> And then there is the one-pass vector normalization like stuff that Richard(?) Bird wrote about.
16:47:39 <Rhymes> jpgil-cl: seems cool
16:48:52 <roconnor> The type system of Haskell can be quite a struggle at first, but it is worth it.  Once your programs do compile they are very close to working correctly.
16:49:28 <Rhymes> :)
16:50:10 <roconnor> You've seen the definition of ones.  ones = 1 : ones
16:50:18 <roconnor> An infinite list of ones.
16:50:55 <jpgil-cl> Do you understand the above definition, Rhymes?
16:51:29 <Rhymes> jpgil-cl: mmm not really
16:51:41 <Rhymes> i'm still reading http://www.haskell.org/aboutHaskell.html
16:51:43 <jpgil-cl> : is for list concatenation.
16:51:54 <Rhymes> so the only source code i've seen is the qsort example :)
16:52:02 <Rhymes> ah ok
16:52:03 <jpgil-cl> 1 : [2,3,4]  yields [1,2,3,4]. 
16:52:34 <Rhymes> and why in the qsort example he uses ++ ?
16:52:36 <jpgil-cl> So, ones = 1:ones adds  1  at the head of the list of ones. It's a recursive function.
16:52:56 <jpgil-cl> Sorry... ++ is for concatenation
16:53:03 <jpgil-cl> : adds 1 element in the front.
16:53:08 <Rhymes> ah ok
16:53:17 <Rhymes> yup
16:53:19 * jpgil-cl is also a newbie
16:53:22 <Rhymes> seems work with hugs
16:53:23 <Rhymes> :)
16:55:45 <roconnor> the infinite list of 1's wouldn't work in a non-lazy langauge like lisp or ML (without extra work) because ones would run forever trying to produce the entire list.
16:55:52 <jpgil-cl> One thing I had troubles with was differences between Char and String. If you start to programming in Haskell  you'll have to make it clear for you.
16:56:30 <jpgil-cl> roconnor: ML is functional but not lazy, I'm right?
16:56:40 <roconnor> correct
16:56:44 <Rhymes> roconnor: how to initialize the ones list? 
16:57:13 <roconnor> Rhymes: I'm afraid I don't understand your question.
16:57:18 <jpgil-cl> You don't need to, Rhymes
16:57:55 <Rhymes> roconnor: mmm sorry but my mind thinks in a imperative way
16:58:03 <Rhymes> jpgil-cl: mmm it doesn't work then
16:58:30 <jpgil-cl> 1 : ones  has the initialization in it.  Read as  "1 plus (recursive calling to ones)"
16:58:30 <Rhymes> hugs gives me syntax error
16:58:51 <roconnor> ones = 1:ones is basically like a static declairation. 
16:59:09 <roconnor> But because haskell is lazy, nothing is initialized.
16:59:17 <roconnor> Things are only computed when they are used.
16:59:20 <Rhymes> it says that '=' is unexpected :(
16:59:40 <jpgil-cl> in Helium it compiles right
16:59:43 <roconnor> try let ones = 1:one in take 5 ones
16:59:48 <jpgil-cl> but don't try to use it yet! :)
17:00:12 <roconnor> Oh, Rhymes, you should try Helium.  It's a light-weight Haskell for beginners
17:00:22 <roconnor> I've never used it, but it looks pretty good.
17:00:27 <Rhymes> roconnor: ah, i've installed hugs
17:00:40 <jpgil-cl> I'm using only Helium as a learning tool. Very, very easy to learn Haskell.
17:01:01 <Rhymes> ok
17:01:04 <jpgil-cl> Though you'll have some troubles with type classes. 
17:01:10 <roconnor> Because Helium is a simplier language, it can give more detailed error messages.
17:01:17 <jpgil-cl> 1 = 1 works, but for floats, you've to write 1 =. 1
17:01:18 <Rhymes> roconnor: the "let ones = 1 : ones in take 5 ones" works
17:01:50 <Rhymes> cool, gentoo does have helium
17:01:52 <roconnor> The let expression lets you make declairations that you then can use in the body of the expression.
17:02:29 <jpgil-cl> roconnor: I don't fully understand when to use the let / in sintaxis, or the differences with "where"
17:02:32 <roconnor> You could try let ones = 1 : ones in ones, to see what ones contains. ;-)
17:02:43 <Rhymes> roconnor: let me understand one thing, why there are different versions of haskell? if i write something in helium will it work with ghc or hugs?
17:03:21 <jpgil-cl> Don't try to, Rhymes, In my case I stick only to one compiler to strip extra complications.
17:03:35 <Rhymes> understood
17:03:41 <jpgil-cl> When I've enough training, I'll try GHCi
17:04:07 <jpgil-cl> Obviously, roconnor or another old seasoned haskell programmers may have another thoughts about
17:04:22 <roconnor> let / in and where are different ways of doing the same way.  Let / in is supposidly expression style,  where is supposedly declaration style.
17:05:01 <roconnor> My understanding is that Helium is a different language from Haskell, so I'm not certain all Helium programs will work as Haskell programs.
17:05:04 <jpgil-cl> roconnor: ok. It's a matter of style only, nothing intrinsecally different.
17:05:07 <Cale> where scopes over guards, let doesn't
17:05:28 <Rhymes> it seems that helium is based upon ghc anyway
17:05:32 <roconnor> As Cale correctly points out, there are some subtile techinical differences.
17:05:43 <jpgil-cl> No, Ryhmes, Helium has it's own compiler
17:05:52 <Rhymes> mmm jpgil-cl but it needs ghc to work
17:06:10 <roconnor> I find that delcarative style is the way you want to go most of the time.
17:06:15 <jpgil-cl> I haven't installed ghc, only the 1.5 Mb of the Helujm windows binary
17:06:48 <Rhymes> jpgil-cl: eh eh i use gentoo :P (also windows, but i don't want to install haskell there by now)
17:07:06 <jpgil-cl> I forgot what gentoo is
17:07:10 <Rhymes> gentoo linux
17:07:20 <Rhymes> www.gentoo.org
17:07:25 <jpgil-cl> yep, thanks
17:09:14 <jpgil-cl> Anyway, I read somewhere that there are things named "modules" or "implementations" in GHC that expands the power of Haskell, but I don't have any idea of what ot's suppoused to be.
17:13:01 <jpgil-cl> Rhymes: to learn a bit more try in http://www.haskell.org/hawiki/  ... I've to go now. See you!
17:13:14 <Rhymes> bye :)
17:13:23 <Rhymes> anyway i think i will stick with hugs
17:16:48 <roconnor> Fudgets look like arrows.
17:17:07 <roconnor> oh jpgil-cl is gone.
17:17:52 * roconnor starts feeling that arrows are going to be importantt
17:24:03 <Rhymes> mmm gotta go, thanks roconnor 
17:44:26 <shapr> roconnor: I do think arrows will be quite important.
17:52:07 <roconnor> Are fudgets arrows?
17:52:56 <shapr> I think so
17:53:18 <shapr> http://www.cse.ogi.edu/PacSoft/seminar/magnus_abstract.html
17:53:41 <Jerub> shapr!
17:53:49 <shapr> Jerub!
17:53:51 <shapr> wassup?
17:54:12 <Jerub> shapr: been talking with computer scientists again. it makes me feel like coming back here.
17:54:15 <shapr> heh
17:54:41 <shapr> this is a good place.
17:54:52 <shapr> any MoinMoin users and research paper readers here?
17:55:03 <shapr> I'm looking to test my crazy idea.
17:55:10 <shapr> though it's not quite ready yet.
17:55:16 <Jerub> uhh, yeah?
17:55:42 <shapr> Jerub: you use MoinMoin on your personal box and you read research papers?
17:55:45 <shapr> oh, I need a name too.
17:56:04 <shapr> g'day SyntaxLaptop 
17:56:39 * roconnor reads about hyper-functions
17:56:47 <shapr> hyper-functions are extra-spiffy.
17:56:55 <Jerub> shapr: Both, yes.
17:57:08 <shapr> Jerub: excellent, do I have your email address?
17:57:53 <Jerub> stephen@thorne.id.au
17:57:57 <shapr> cool
17:58:20 <shapr> Jerub: here's the basic idea
17:58:22 <shapr> http://www.scannedinavian.org/RandomWiki/AnnotationMockup
17:58:46 * roconnor wants to write an SGML parser in Haskell
18:00:35 <Jerub> shapr: I'd prefer left or right margin only.
18:00:41 <Jerub> perhaps right margin would be better.
18:01:26 <shapr> I usually write stuff in the margins of my books and papers as close to the actual text as I can get.
18:01:33 <SyntaxLaptop> hi shapr
18:02:00 * roconnor doesn't understand hyperfunctions at all.
18:02:06 <roconnor> oh well
18:02:11 <Jerub> shapr: but the font difference there is so big.
18:03:01 <shapr> Jerub: the rest of the idea is, a) stick the annotations in a local darcs repo b) write a MoinMoin macro that sucks down a pdf/ps file, feeds it to imagemagick, and generates separate images and wikipages for each page c) share the annotations with your friends
18:03:39 <Jerub> shapr: editing the wiki page puts stuff back into darcs?
18:03:44 <shapr> right
18:03:55 <Jerub> *fantastic* idea.
18:04:22 <shapr> two factors here, 1) I can't distribute research papers or images of their pages 2) wikispam has become popular
18:04:54 <shapr> so, each person has only their local moinmoin research wiki, but they can pull updates from other users.
18:05:02 <Jerub> shapr: then obviously an automated turing test will be needed. 2 multiple choice functional programming questions would be sufficient.
18:05:08 <Jerub> ;)
18:05:14 <shapr> heh
18:06:19 <shapr> so, only sync annotations, and let the user click on an url to ps/pdf that then downloads it locally and creates the images for the user.
18:06:37 <Jerub> yep.
18:06:39 <Jerub> sounds great.
18:07:10 <Jerub> I've got approximately a billion papers and manuals for erlang I need to read.
18:07:11 <shapr> anyway, I need some guinea pigs to a) test, b) populate, and c) name this shared margin wiki 
18:07:14 <roconnor> Arrows are a) sharp pointy sticks  b) generalizations of Monads  c) a mark to indicate a direction
18:07:17 <Jerub> and annotate.
18:07:51 <shapr> roconnor: have you heard about the generalization of arrows called spears?
18:08:00 <roconnor> Oh god
18:08:03 <roconnor> nope
18:08:08 * shapr is joking =)
18:08:13 <roconnor> *whew*
18:08:16 * shapr laughs
18:08:20 <Jerub> shapr: was the researcher's name Brittany?
18:08:29 <shapr> what researcher?
18:08:33 <shapr> oy
18:08:34 * shapr gets it
18:08:38 * shapr arghs painfully
18:09:09 <shapr> I think a pull-only distributed wiki should get rid of spam
18:09:10 <Jerub> http://en.wikipedia.org/wiki/Recursion <- odd. doesn't mention tail call elimination.
18:09:29 <Jerub> I've been reading too much wikipedia lately :(
18:09:35 <shapr> wikipedia is cool.
18:09:51 <shapr> any good name suggestions for a research paper margin wiki?
18:10:08 <Cale> Jerub: the nice thing is that you can add the bit about tail call elimination :)
18:10:25 <Jerub> Cale: yep.
18:10:32 <roconnor> Tail recrusion is supposed to get rid of stacks of environment variables, but in the G-Machine everything is lambda-lifted so there are no more stacks of environement variables.
18:10:40 * roconnor ponders
18:10:42 <Jerub> Cale: just today I referenced the single assignment page to both erlang and haskell.
18:11:26 <roconnor> oh, that page isn't the haskell wiki.
18:11:52 <shapr> which page?
18:12:01 <shapr> oh wikipedia?
18:12:11 <shapr> nice guys run that place.
18:12:16 <shapr> they're experts on wikispam too
18:12:40 <Jerub> oh well, see you folks.
18:12:45 <shapr> cya Jerub 
18:13:00 * roconnor would call the natural numbers an inductive definition.
18:13:28 <Smerdyakov> roconnor likes to rock the boat.
18:14:01 <roconnor> I'm not really sure how it goes.  Data is inductive, functions are recursive?
18:14:20 <Smerdyakov> There's no important distinction.
18:14:29 <roconnor> oh
18:14:55 <Smerdyakov> It's certainly very rare that someone would call a function "inductive," though.
18:15:19 <roconnor> Such languages generally make tail recursion as efficient as iteration ...
18:15:28 <Smerdyakov> Which languages?
18:15:29 * roconnor quoting the wiki page
18:15:40 <roconnor> ``Such languages generally make tail recursion as efficient as iteration ...''
18:15:45 <roconnor> better
18:16:19 <roconnor> so the page sort of vaguely mentions tail call elimination.
18:19:09 <Jerub> roconnor: well, which church numerals, you can have the entire number set defined as a recursive function.
18:19:42 <Smerdyakov> Jerub, I wouldn't apply the term "recursive function" there, myself.
18:19:53 <roconnor> Church numerals aren't really recursive functions.
18:20:20 <roconnor> No Y combinator, no recursion?
18:20:41 <roconnor> No Y combinator, no recursion.
18:21:05 <Smerdyakov> Church numerals are typically expressible in languages with no recursive constructs.
18:21:16 <Smerdyakov> And no possibility to define Y, etc..
18:22:54 <roconnor> intersting, you can add church numerals without recursion.
18:23:44 <Riastradh> Adding Church numerals is trivial.
18:23:50 <Riastradh> As is multiplying them, in fact.
18:24:07 <roconnor> why do I feel bad that addition can be done without recursion.
18:24:30 <Smerdyakov> roconnor, maybe you need to go on a diet.
18:24:33 <roconnor> subtracting 1, not so easy. :-)
18:24:40 <Smerdyakov> Subtracting 1 is easy.
18:24:48 <roconnor> really?
18:24:52 <Smerdyakov> Yup.
18:24:58 <roconnor> write it.
18:25:32 <roconnor> you can map 0 to whatever you'd like, although I'd prefer 0.
18:25:55 <Smerdyakov> pred n = fst (n (\ (x, y) -> (y, S y)) (0, 0))
18:26:32 <roconnor> that was easy.
18:26:42 <jpgil-cl> That is haskell?
18:26:55 <roconnor> should be
18:27:00 <Smerdyakov> jpgil-cl, yes, with appropriate definitions, and probably making S lowercase.
18:27:09 <Smerdyakov> jpgil-cl, and changing 0 to your custom 0.
18:27:24 <Smerdyakov> Although, I bet type classes would allow the use of 0 for a CN.
18:28:03 <Riastradh> @get-definition fst
18:28:04 <lambdabot> fst = \p.p const
18:28:20 <roconnor> pred n = fst (n (\ (x,y) -> (y, succ y)) (fromInteger 0, formInteger 0)).  Now we just need to make church numerals part of Num and Enum. ;-)
18:28:21 <Smerdyakov> Ah. I mean for the first projection function for pairs.
18:28:31 <Riastradh> @get-definition pair
18:28:31 <lambdabot> pair = \k p.p k
18:28:46 <Riastradh> @define pred \n. fst (n (\x -> pair (snd x) (S (snd x))) (pair 0 0))
18:28:47 <lambdabot> pred defined
18:29:01 <Riastradh> @eval pred (\f. \x. f (f (f x)))
18:29:01 <lambdabot> type error
18:29:05 <roconnor> @get-defintion S
18:29:06 <lambdabot> Sorry, I don't know the command "get-defintion", try "lambdabot: @listcommands
18:29:14 <roconnor> @get-definition S
18:29:14 <lambdabot> S = \f g x.f x (g x)
18:29:20 <roconnor> Wrong S.
18:29:23 <roconnor> @get-definition succ
18:29:23 <lambdabot> succ not defined
18:29:31 <Riastradh> @get-definition add1
18:29:31 <lambdabot> add1 not defined
18:29:58 <roconnor> I guess we ought to avoid S for successor.  That's too bad.
18:30:06 * jpgil-cl just now realizes what really lambdabot is
18:30:34 <roconnor> @get-definition zero
18:30:34 <lambdabot> zero not defined
18:30:56 <shapr> jpgil-cl: he's an irc bot
18:31:02 <roconnor> @define zero \f. \x. x
18:31:02 <lambdabot> zero defined
18:31:08 <shapr> jpgil-cl: actually, lambdabot is a code-toy
18:31:13 <roconnor> Everyone happy with that definition?
18:31:18 <jpgil-cl> I knew that, but I didn0t know that it executes haskell
18:31:24 <shapr> it's doesn't
18:31:33 <shapr> the @eval command is a lambda-calculus interpreter.
18:31:37 * jpgil-cl feel lost
18:31:59 <shapr> Haskell isn't very far from lambda calculus in some ways.
18:32:00 <Cale> jpgil-cl: it's written in Haskell though
18:32:07 <roconnor> @define succ \a. \f. \x. s (f x)
18:32:07 <lambdabot> succ defined
18:32:21 <shapr> IOHCC is nearly over
18:32:27 <shapr> I hope we get a flood of last minute entries...
18:32:35 <roconnor> jpgil-cl: Sorry, we are going a little fast here.
18:32:40 <shapr> we don't have very many right now :-/
18:32:44 <thebug> how many so far? <if it's allowed to say>
18:32:45 <shapr> I was hoping for more than last year.
18:32:45 <jpgil-cl> Don't wory, I'm the gust, not you
18:32:50 <jpgil-cl> guest
18:33:01 <shapr> thebug: two that got through into my broken mailing list
18:33:06 <roconnor> jpgil-cl: I can help straighten you out.
18:33:18 <shapr> jpgil-cl: we're all guests here.
18:33:20 <jpgil-cl> You already are doing it
18:33:35 <shapr> Stone Soup and all that.
18:33:40 <Smerdyakov> shapr, if I remember correctly, you are quite into the idea of considering yourself to be in a special position. :P
18:34:04 <roconnor> @define pred \n. fst (n (\x -> pair (snd x) (succ (snd x))) (pair zero zero))
18:34:05 <lambdabot> pred defined
18:34:36 <roconnor> Everyone is a guest here, ... except for shapr. ;-)
18:34:38 <jpgil-cl> I haven't found a lambda-calculus online book. I feel I need it
18:34:45 <shapr> Smerdyakov: we have a very flat organization here...
18:34:54 <shapr> nearly everyone is equal.
18:34:55 <Smerdyakov> shapr, yup. You and then everyone else.
18:35:36 <shapr> I told you before that if you really think it should be done differently, feel free to start a #haskell on another IRC network. This channel is by no means 'official'
18:35:57 <Smerdyakov> I was just pointing out that you were contradicting yourself.
18:36:01 * roconnor now that lambda bot knows all these definitions, what can it do with them?
18:36:05 <Cale> shapr sets modes [+o Smerdyakov]
18:36:06 <shapr> I'm not contradicting myself.
18:36:20 <Smerdyakov> You said "everyone is a guest here."
18:36:26 <shapr> I'm a guest here just as much as anyone else, irc channels are just a convention.
18:36:37 <shapr> I don't own any of the irc server hardware, and doubt I ever will.
18:36:44 <shapr> Therefore, I am a guest too.
18:36:51 <Smerdyakov> You can pretend that "conventions" are not assumed in conversations that take place within them, but that's out of keeping with reality.
18:37:22 <shapr> dude, give it up.
18:37:24 <roconnor> does @eval use definitions?
18:37:37 <shapr> what do you mean?
18:37:53 <jpgil-cl> It's glad to see two old friend chatting friendly, but coming back to #haskell... is there any online book about lambda-calculus? Please.
18:38:07 <roconnor> ... how does @eval work for the lambdabot?
18:38:36 <roconnor> jpgil-cl ... I er could recommend to you my favourite book in the world.
18:38:43 <shapr> the @eval command is a lambda calculus intepreter that's wrapped into a lambdabot plugin
18:38:51 <jpgil-cl> LOTR?
18:38:55 <shapr> it's implemented with monad transformers and is very spiffy
18:38:59 <roconnor> @eval S K K x
18:38:59 <lambdabot> unbound variable: x
18:39:03 <roconnor> :-(
18:39:19 <roconnor> @eval S K K S
18:39:19 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:39:24 <roconnor> oh
18:39:26 <shapr> there are very few pieces of @eval that are hard wired
18:39:39 <roconnor> @eval S K K 0
18:39:40 <lambdabot> 0
18:39:42 <shapr> @definitions e
18:39:43 <lambdabot> ["either","elem","enumFrom","enumFromThen","enumFromThenTo","enumFromTo
18:39:43 <lambdabot> ,"even"]
18:39:47 <roconnor> hmm
18:40:21 <shapr> the lambdabot sources include @eval, though I just realized they probably don't include the base definitions
18:40:27 <shapr> @get-definition either
18:40:27 <lambdabot> either = \f g e. e f g
18:40:53 <roconnor> @get-definition add
18:40:53 <lambdabot> add not defined
18:41:29 <roconnor> @define add \a b f x. a f (b f x)
18:41:29 <lambdabot> add defined
18:41:32 <shapr> the #joy channel has ended up being the lambdabot testing grounds
18:41:40 <roconnor> I should really test my definitions.
18:41:50 <shapr> if you want to do a lot of @eval stuff, it might be better to do stuff there or in private messages.
18:50:15 * roconnor thinks that maybe every provably total function in Peano Arithmetic can be written without recursion.
18:56:34 * shapr thinks sleep is near.
19:04:32 <Smerdyakov> roconnor, you mean with an untyped Y operator?
19:10:11 <jpgil-cl> For those who was speaking about church numerals, there's a paper in http://www.informatik.uni-bonn.de/~ralf/publications.html#J13
19:10:27 <jpgil-cl> From the same author of Generic Haskell.
19:19:54 <roconnor> Smerdyakov: I think I mean that it can be written in the typed-lambda calculus without Y.
19:20:02 <roconnor> @get-definition S
19:20:02 <lambdabot> S = \f g x.f x (g x)
19:20:06 <roconnor> @get-definition K
19:20:06 <lambdabot> K = \x y.x
19:20:10 <roconnor> @get-definition succ
19:20:10 <lambdabot> succ = \a. \f. \x. s (f x)
19:20:14 <roconnor> @get-definition zero
19:20:15 <lambdabot> zero = \f. \x. x
19:21:22 <roconnor> *whew*  For a moment I was afraid that S and K would be the same as succ and zero.
19:33:38 <sysfault> howdy
19:34:56 <shapr> hiya
19:37:07 <sysfault> haskell looks so complex.
19:37:18 <Jerub> sysfault: YES.
19:37:23 <Jerub> that is becuase of its sanity.
19:37:47 <sysfault> Jerub: which do you like better python or haskell, truthfully?
19:37:47 <kuz> Perl is the sanest language ever then.
19:38:54 <Jerub> sysfault: I like cutting code in python better, but haskell is an incredibly nice language to have learned.
19:39:23 <shapr> I like Haskell better than Python.
19:39:29 <shapr> But Python was my first love :-)
19:39:48 * shapr still writes lots of Python, mostly for money.
19:39:51 <Jerub> sysfault: learning haskell made my python code much better when I learned python.
19:40:58 <sysfault> which did you learn first?
19:41:33 <shapr> I learned Python first, whenever Python 1.5 was in beta
19:41:40 <kuz> I started using Python in '97.
19:41:49 <sysfault> wow
19:43:49 <sysfault> well I've been learning python, got up to chaptger 11 in my book, it went the the execution model, various python implementations, type objects, loops, loop variations, etc. I was reading it until yesterday, when I realized I wanted to be a mathematician. I asked around for some nice languages which will teach me program logic, and the core semantics of computer programming, instead of just "programming in a certain language"
19:44:10 <sysfault> I was told scheme ws a good first language, and it will help me alot for when i learn future languauges.
19:44:57 <sysfault> I was going to ditch python completely to start from scratch with 1 nice language which teaches me the all around methods, and skills for programming..
19:46:01 <sysfault> My math knowledge sucks as of now, but I'am teaching myself basic algebra.
19:46:09 <sysfault> my highschool does a poor job.
19:46:21 <sysfault> Cale has been helping me tremendously.
19:46:29 <kuz> Oh, you're a wee youngin'.
19:46:41 <sysfault> well no
19:46:45 <sysfault> I'am 17 :(
19:46:55 <sysfault> 11th grade..
19:47:03 <sysfault> graduate in 2 years.
19:47:19 <np_hard> that is pretty wee :)
19:47:43 <sysfault> it's just that my 9th, and 10th grade math classes sucked horrendously.
19:47:55 <sysfault> teacher cuoldn't speak english if his life depended on it.
19:47:57 <Jerub> yay crappy high school.
19:47:59 <Jerub> sysfault: what country?
19:48:05 <sysfault> US, New Jersey
19:48:29 <kuz> School quality is inconsistent.
19:48:50 <sysfault> highschool is simply a requirement.
19:48:53 <sysfault> it sucks.
19:49:27 <sysfault> the modern day school system is unreliable, and the teachers are as bad as the student.
19:49:31 <sysfault> students*
19:49:35 <kuz> Then you'll go to college and your TAs will barely speak English. ;)
19:49:50 <sysfault> haha
19:49:55 <sysfault> hopefully not
19:51:39 <np_hard> no, that's pretty much how it is
19:53:01 <sysfault> crazy..
20:17:28 * heatsink cannot build GHC until GHC is installed
20:17:35 <heatsink> This is what we call a catch-22
20:18:16 <Jerub> heatsink: its called bootstrapping.
20:18:18 <Cale> heatsink: no it isn't
20:18:21 <Jerub> heatsink: same with free pascal.
20:18:31 <Cale> Just get the binary
20:18:37 <heatsink> I got the binary
20:18:49 <Cale> then you're all good
20:18:57 <Cale> no need to compile it
20:19:00 <heatsink> the binary doesn't work with this version of the libraries
20:19:14 <Cale> which version?
20:19:25 <heatsink> : undefined reference to `__ctype_b'
20:19:40 <heatsink>  /usr/lib/ghc-5.04//libHSrts.a(RtsFlags.o)(.text+0xd0): In function `splitRtsFlags'
20:19:48 <heatsink> hmm
20:19:52 <Cale> ghc 5.04 ?
20:20:19 <Cale> http://haskell.org/ghc/download_ghc_621.html
20:20:34 <heatsink> yes, 5.04
20:20:50 <Cale> why not 6.21?
20:21:06 <Cale> er, 6.2.1
20:21:09 <heatsink> I found rpms for 5.04
20:22:05 <Cale> there are RPMs for 6.2.1 on the official ghc page
20:26:03 <heatsink> okay, it works
20:37:29 <heatsink> I think I solved my problem
20:37:52 <heatsink> One of my functions is Obfuscated Haskell but the rest of it is clear and concise
20:41:37 <heatsink> The amazing thing is that I can write a working program while understanding remarkably little about how it works
21:25:07 <Jerub> shapr: are you still awake?
21:45:00 <al_busy> hello
21:45:36 <al_busy> if <list>!!<index> gets the object at the index of the list, what is the syntax to put an object at that index?
21:46:11 <al_busy> eg the equiv. of array[3] = "three" in C for instance. Can anyone please help me?
21:47:07 <Cale> take (n-1) xs ++ [elt] ++ drop n xs
21:47:24 <Cale> there's probably a shorter way
21:47:37 <al_busy> thanks. I didn't realize it was so complicated :-/
21:47:42 <Cale> lists aren't really good for random writes
21:48:04 <Cale> you should probably use an array or finite map in the case that you want to randomly update values
21:48:17 <al_busy> aha, so it does have arrays :-)
21:48:57 <al_busy> i'm trying to find a tutorial that isn't heavy on presenting things in mathematical notation
21:49:14 <Jerub> that's going to be hard to find ;)
21:49:20 <Cale> but it's easy enough to define that as update_list xs n y or something
21:49:46 <Cale> Yet Another Haskell Tutorial is pretty good - is it too mathematical?
21:50:24 <al_busy> my data type doesn't have to be a list :)
21:51:30 <al_busy> thanks, I havn't tried YAHT yet because you have to register. I will since you recommend it
21:51:49 <al_busy> <-- yet another student with a haskell requirement, doing an assignment :)
21:52:51 <Jerub> yay schools.
21:52:56 <Jerub> teaching real computer science I hope.
21:53:10 <Jerub> what univeristy you at?
21:53:20 <Jerub> btw, you're too lame to read bitchx.doc
21:53:46 <al_busy> jerub: I'm using mIRC
21:54:23 <al_busy> the course is a double degree thingo, EE and IT (software engineering)
21:54:45 <Jerub> I'm australian, what univeristy are you at.
21:54:51 <al_busy> QUT.
21:55:01 <al_busy> I should have gone to UQ I think
21:55:05 <Jerub> ;)
21:55:14 <Jerub> UQ has gotten better recently, they're using SICP in first year now.
21:55:17 <Jerub> instead of javacrap.
21:55:26 <Jerub> but QUT has had the better course up until now.
21:55:27 <al_busy> I'm not familair with SICP?
21:55:42 <Jerub> "Structure and Intreptation of Computer Programs", the MIT scheme course.
21:55:51 <Cale> al_busy: google for "Yet Another Haskell Tutorial pdf" and look for the pdf :)
21:55:53 <al_busy> I don't mind java, its slow, but it gets the job done. 
21:56:01 <al_busy> thanks cale
21:56:18 <Jerub> al_busy: as I recall, the subject you're doing now is basically a crash course in compiler writing and functional programming.
21:56:39 <al_busy> hahahha, so true :-) did you go to QUT?
21:56:51 <Jerub> al_busy: No, I know QUT students.
21:57:14 <Jerub> I'm a UQ graduate.
21:57:14 <al_busy> I'm pretty interested in the compiler writing part, but not super keen on FP yet. I probably don't know enough to decide if I like it or not
21:57:25 <Cale> al_busy: btw, X-Chat is available on windows machines, and is generally a nicer option than mIRC, I find.
21:57:39 <Jerub> (me, I use irssi, never found anything better)
21:57:54 <Jerub> al_busy: learning FP will make you a better programmer.
21:57:57 <al_busy> hmm, I'll look into it. I'm probably too lazy to change clients though :)
21:58:15 <Jerub> al_busy: I find people that know FP back to front actually know what OO *is*, unlike java programmers who think they know ;)
21:58:29 <Jerub> which makes me quite vexed when I come up against an ignorant programmer.
21:58:34 <Cale> oh, somehow it costs money now
21:58:36 <Jerub> </bitch>
21:58:44 <Jerub> Cale: wtf? xchat?
21:58:50 <Cale> only for windows
21:58:53 <al_busy> my favourite lang for small things (I like playing with embedded systems) is probably C with lots of inline asm :)
21:58:59 <Jerub> al_busy: omfg.
21:59:03 <Cale> because they decided that the windows development was too much work
21:59:03 <Jerub> al_busy: you need help.
21:59:08 <al_busy> I thinks its challenging
21:59:37 <al_busy> its fun shaving 2 instructions off an inner loop, and making the system 30% faster
21:59:56 <al_busy> (This was for a PC based oscilloscope byw)
22:00:02 <Jerub> Cale: surely that's only the compiled version that's only available for registered users.
22:00:35 <Cale> perhaps -- they're saying that the porting takes lots of work
22:01:05 <Cale> it seems that the license for the windows version is now different
22:01:15 <Cale> that sucks for windows users
22:01:21 * Jerub pukes.
22:01:26 <Jerub> weanies.
22:01:32 <Jerub> anyhow. irssi > *
22:02:04 <Jerub> al_busy: my advice : learn a fun language to write code in. python is my recommendation.
22:02:12 <Jerub> al_busy: but learn haskell first.
22:02:42 <Jerub> al_busy: also, since you're a C/asm programmer, you must be informed. forget everything you know.
22:02:45 <Cale> al_busy: you might be interested in the project that I'm working on
22:02:54 <Jerub> haskell is so different, if you try to think like a C programmer, you will fall flat.
22:03:41 <Cale> I've been writing an interesting pipeline scheduler in Haskell for ppc assembly
22:03:51 <Jerub> sadly I've seen smart people go into a mild psycosis trying to learn haskell by just converting C idioms to it and basically end up chanting "haskell is impossible/haskell is crap"
22:04:05 <Jerub> which is of course just because they haven't been able to adjust their thinking.
22:04:14 <Jerub> Cale: ooooh.
22:04:20 <al_busy> I'm finding that, its someone what going :). Although RPL (which I know) is also kind of like FP
22:04:39 <al_busy> "somewhat slow going" rather, stupid brain
22:04:54 <Jerub> :)
22:04:58 <Jerub> al_busy: what are you working on now?
22:05:13 <Cale> My scheduler finds a 3 stage schedule of 17 cycles for a loop which has vector code to compute 4 sine/cosine pairs per iteration.
22:05:31 <Cale> so 17 cycles/8 results :)
22:05:50 <al_busy> cale: I'm not too familair with the PCC, but sounds tricky
22:06:45 <Cale> It presently uses the list monad to do the computation nondeterministically -- returning a lazy list of all the possible schedules.
22:06:48 <al_busy> this is just a university assignment, that out lecturer has basically taken from another university. Basically it involves tiling a square with 'trominos', which are like 4 by 4 tiles with one missing
22:07:25 <al_busy> I'm on Q9 of 11, and its driving me nuts because could do it in about 30 seconds with C, but I'm stuck with haskell
22:07:37 <Jerub> al_busy: okay. this is a good thing.
22:07:53 <Jerub> al_busy: I think I know the problem you're working on actually ;)
22:08:21 <al_busy> its heavily based on http://cs-www.cs.yale.edu/homes/carsten/classes/f02/assignments/hw5/hw5.html
22:08:56 <al_busy> thanks for the help btw
22:10:12 <Jerub> what help?
22:11:02 <al_busy> the problem is basically, given a list of 'trominos' (each one has an orientation and position) and a board size, generate a string containing HTML code that when displayed, will render a graphical representation of the layout
22:11:49 <al_busy> if I was writing this in C, I would first have a 2D array, and iterate through the list of trominos. With each tromino i will calculate the positions it took up, and write it to the array
22:12:25 <al_busy> after that, I would generate the HTML and insert the contents of the array into a HTML table
22:12:43 <Jerub> okay, and that is exactly how we will avoid doing it in haskell. good.
22:12:54 <Cale> al_busy: why not just define the thing such that it takes a coordinate and checks if there's a tromino there?
22:12:56 <al_busy> of course :)
22:12:57 <Jerub> what does the data structure look like? can you show a portion?
22:13:15 <Cale> functions are data too :)
22:13:17 <al_busy> actually thats probably a better idea
22:13:32 <al_busy> I think I'll do that
22:13:53 <al_busy> can I paste 5 lines here?
22:13:57 <Jerub> sure
22:13:59 <al_busy> > type Cell = (Int, Int)
22:14:00 <al_busy> > data Orientation = NW | NE | SW | SE deriving (Show, Eq)
22:14:00 <al_busy> > type Tromino = (Cell, Orientation)
22:14:15 <al_busy> > type Colour = String
22:14:16 <al_busy> > type ColouredTromino = (Tromino, Colour)
22:14:37 <al_busy> thanks for that, I think I can do this now :-)
22:14:57 <Jerub> ;)
22:15:34 <Jerub> just remember, if it makes sense to do it one way in C, don't do it that way in haskell. ;)
22:16:08 <Cale> in fact, you could build a 2d array, and simply define the array elements that way from the beginning, without any updates at all.
22:16:18 <al_busy> so for larger programs, what is the big advantage to FP anyway? The lecturer just glossed over that
22:17:08 <Jerub> wouldn't know. only ever written small FP programs. Thing is, when I write large programs in python or similar, I use lots of the knowledge I gained in FP. ;)
22:17:22 <np_hard> ditto
22:17:57 <np_hard> FP makes it easier to reason about programs
22:18:28 <Jerub> The software verification group over at UQ go nuts over FP because it makes their life easier.
22:18:46 <Cale> I find that code that I write in Haskell tends to be closer to my initial impression of what needs to be done. I (usually) don't need to mess with how to iterate over something or how a bunch of updates to some structure are going to happen in order, because higher order functions take care of these things most of the time.
22:19:06 <Jerub> Cale: definately.
22:19:50 <Jerub> I couldn't survive in a language where the iterable datatypes aren't core language features.
22:21:13 <al_busy> just out of curiosity, do you get ever students in here ranting about how they haskell? 
22:21:34 <al_busy> "they hate haskell". Why do I keep skipping words
22:21:43 <Cale> yeah, occasionally
22:21:48 <Jerub> yep.
22:21:53 <Cale> but their hate is usually ill-founded :)
22:22:05 <Jerub> and usually because of premature calcification.
22:22:47 <al_busy> Calcification: Hard calcium deposits in tissues ? :)
22:23:31 <Cale> calcification: your head turning into a rock which only thinks one way (often the imperative-programming way)
22:24:03 <Jerub> calcification is the kind thing that affects vi users, casuses them to use nvi even tho vim is a billion times better.
22:24:13 <Riastradh> #haskell has even had one guy who just came in here to say 'you know, Haskell sucks; why does anyone use it?' for about three days, and then left.
22:24:19 <Riastradh> (well, variations on that theme)
22:24:47 <Riastradh> Coherent reasoning, of course, was absent from his side of that entire episode.
22:24:56 <al_busy> I asked, because I found this via via a logfile about someone ranting about how much he hated it :)
22:25:05 <Jerub> hah
22:25:12 <Riastradh> That guy wouldn't happen to have 'joey' somewhere in his nick, would he?
22:25:21 <al_busy> oh great, now I'm not skipping words, I'm repeating them
22:25:34 <Cale> http://www.haskell.org/complex/why_does_haskell_matter.html
22:25:47 <Cale> that might answer some questions about the benefits of fp
22:25:49 <al_busy> I forget
22:25:57 <Jerub> my favourite exchange on haskell was about how much haskell sucked because of its "too clever by half" typing. about how because a function used a + in it, you couldn't pass an arg that couldn't be added.
22:26:16 <Cale> Jerub: hahahaa
22:26:23 <Jerub> so I drew parallels to java, and she shut up.
22:26:23 <Cale> do you have a log of that?
22:26:29 <Jerub> Cale: it was on a newsgroup.
22:26:32 <Cale> oh
22:26:45 <Cale> any nice quotes for the quotepage?
22:26:59 <Cale> or was it sort of spread out?
22:27:05 <Jerub> this is years ago, and it was an internal usegroup.
22:27:10 <Jerub> no, it was a single exchange.
22:27:10 <Cale> oh
22:28:46 * Jerub sighs
22:29:35 <Cale> lazy evaluation is also really cool - it basically gives you coroutines without quite as much trickiness on the face of it
22:32:00 <Cale> It takes a little bit of getting used to, but it's just something that you eventually pick up in time.
22:32:01 <al_busy> my only gripe is that most of the tutorials (the one I looked at the most was "a gentle introduction...") seem to overcomplicate things with jargon
22:32:23 <al_busy> YAHT seems reasonable though
22:32:30 <Cale> al_busy: well, I think "a gentle introduction..." is mainly intended for people who are already used to FP
22:32:39 <Cale> (but not Haskell)
22:32:41 <Riastradh> The gentle introduction is not held in very high regard in #haskell for a general Haskell tutorial.
22:33:24 <al_busy> ha, the nick in the logfile was "_joey"
22:33:38 <Riastradh> That sounds like the same dork I was talking about.
22:47:41 <al_busy> stupid question
22:49:19 <al_busy> http://rafb.net/paste/results/UlSHXc39.html - I'm sure its something obvious, but what am I doing wrong?
22:49:38 <Riastradh> @type and
22:49:39 <lambdabot> and :: [Bool] -> Bool
22:49:42 <Riastradh> @type (&&)
22:49:44 <lambdabot> (&&) :: Bool -> Bool -> Bool
22:49:58 <Riastradh> @type (1 == 2) && (2 == 2)
22:50:00 <lambdabot> (1 == 2) && (2 == 2) :: Bool
22:50:00 <al_busy> ah, I see
22:50:09 <Riastradh> and returns true if every element in its argument is true.
22:50:20 <Riastradh> && returns true if either its first or its second arguments is true.
22:50:23 <al_busy> cheers, I don't know why I didn't try that first
22:51:11 <Cale> && returns true if both its first and its second arguments are true.
22:52:51 <Riastradh> ...er.
22:52:57 <Riastradh> Yes, sorry.
22:53:10 * Riastradh discharged cognitive gas.
22:56:06 <al_busy> likewise, || is OR as in C?
22:56:20 <al_busy> @type ||
22:56:21 <lambdabot> bzzt
22:56:21 <Riastradh> Yes.  || is what I described in reality when I said &&.
22:56:25 <Riastradh> @type (||)
22:56:26 <lambdabot> (||) :: Bool -> Bool -> Bool
22:56:35 <al_busy> thanks
22:56:41 <Riastradh> Likewise:
22:56:41 <Riastradh> @type or
22:56:42 <lambdabot> or :: [Bool] -> Bool
