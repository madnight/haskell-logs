00:50:26 <musasabi> Is connectTo lazy ?
00:50:43 <musasabi> that is can I call it safely within a thread without fear of blocking.
01:01:20 <musasabi> hmm seems that it does block :-(
01:02:43 * musasabi redesigns a little bit
01:09:54 <pesco> musasabi: That's not a question of laziness! It would be as bad if it blocked at some later time. Maybe that's even worse. I'm not sure whether connectTo blocks, I'd think so. And then, I'd also think it would do it when called, because it's an IO action.
01:10:27 <musasabi> hmm point.
01:11:02 <musasabi> seems like I need 2 threads for each connection :-(
01:11:13 <pesco> What are you writing?
01:11:22 <musasabi> pesco: distributed channels.
01:11:30 <pesco> Ah, cool!
01:11:53 <pesco> How do they work?
01:12:35 <musasabi> pesco: using a simple net proto (of course local things are optimized)
01:12:54 <musasabi> pesco: my main hindrance is the haskell io model.
01:13:17 <pesco> Heh. How does it hinder you, in particular?
01:13:20 <musasabi> pesco: that is the unablity to wait for multiple events.
01:13:27 <pesco> Ah, I see.
01:14:26 <pesco> But you can implement select with threads, can't you?
01:14:34 <musasabi> yes.
01:14:53 <pesco> Then why is that a problem?
01:15:17 <musasabi> pesco: I'd like to have a solution with fewer than 2n (n = number of connections)
01:15:24 <musasabi> threads.
01:15:41 <basti_> whats bad about threads?
01:15:54 <pesco> Haskell threads are light-weight. Maybe it's not so bad?
01:16:05 <basti_> thats an i386 reflex.
01:16:16 * pesco snickers.
01:16:29 <musasabi> basti_: or a reflex looking at sources and seeing things quite unoptimized.
01:16:56 <basti_> nope its a pure i386 reflex. i386 take like, uhm, ages to switch context, and that fear made its way into the brains of programmers
01:17:25 <musasabi> but we are talking about userlevel threads..
01:17:38 <basti_> id hope
01:51:01 <musasabi> Any good visual graph editor for making my block diagrams electonic?
01:51:12 <musasabi> UML is not very suitable for haskell...
01:51:22 <Jerub> musasabi: dia
02:15:54 <mikael> hey hey
05:42:08 <goron> How can I "catch" calls to error in a library function? 
05:47:40 <ski> i think it can be done in, ghc, at least
05:48:05 <ski> it generates an exception that can be caught at IO level
05:49:08 <goron> So it generates a value of type IOError?
05:49:27 <ibid> no
05:49:35 <ski> or IOException or something like that ..
05:50:06 <ibid> error evaluates to bottom, but through ghc magic you can notice that within the IO monad :)
05:50:22 * ski smiles
05:51:00 <goron> Any example of that? 
05:51:14 <ibid> i don't have one
05:51:15 <ibid> bbl
05:55:45 <ski> Prelude Control.Exception> Control.Exception.catch (evaluate $ error "a") (\(ErrorCall s) -> putStrLn $ "The error was " ++ s ++ " !")
05:55:46 <ski> The error was a !
05:55:56 <ski> goron : ok ?
05:56:58 <goron> ski: I only find it odd that this happens in the IO monad. 
05:57:20 <ski> goron : for what reason ?
05:57:24 <goron> ski: Well, it's more that I think the library is wrong. 
05:57:35 <goron> I search for an element in a graph. 
05:57:37 <ski> care to elaborate ?
05:57:55 <goron> If it's there, it gives the node, if it's not, it calls error.
05:58:03 <goron> Maybe would be better
05:58:26 <ski> yes, prolly  (depends a bit on circumstances, though)
05:58:30 <Philippa> yep, sounds a screwy lib - assuming it's not monadic and calling fail instead?
05:58:52 <goron> It's the Functional Graph Library. 
05:59:11 <ski> mhm
05:59:19 * ski haven't looked at that yet
05:59:43 <goron> Someone should change it, imo.
06:00:12 <ski> mayhaps it doesn't fit with erwigs graph model ..
06:00:59 <goron> ski: I think that every occurence of error can be replaced by maybe in non IO code. 
06:01:36 <ski> goron : in some case you'd have to change types, i think
06:02:06 <ski> (i.e. implementations of data types)
06:02:15 <ski> flaw : good afternoon
06:03:08 <goron> ski: Well, but that's lazyness, imo, and not the Right Thing To Do.
06:03:42 * ski first thought of laziness as in "haskell, a lazy language" :)
06:04:19 <goron> Now, I have to screw up my completelely functional program(or take a serious performance hit) to make it work...
06:04:38 <ski> goron, i'm not sure if one could always insert a maybe without having to restructure the whole prog ..
06:05:13 <ski> (not sure if that would be the case in here, though)
06:05:23 <goron> ski: In any call to <function that generates Maybe> you have to have somekind of case statement, nothing more. 
06:05:24 <ski> you could always ask him, i suppose
06:05:38 <goron> ski: I don't think he's maintaining it anymore.
06:05:50 <ski> goron : what about lazy recursively tied knots ?
06:05:58 <ski> goron : mhm
06:06:11 <goron> ski: I have no idea about that. 
06:06:26 <goron> ski: Is that a joke?
06:06:35 * ski has some doubts it would be as easy in such cases
06:06:36 <ski> no
06:07:14 <ski> one simple example is http://www.haskell.org/hawiki/TyingTheKnot
06:07:44 <flaw> ski: good morning, here ;)
06:07:52 <bourbaki> hi
06:08:14 * ski seem to have a vague memory of erwigs graphs being cyclic structures (in general), but not sure about this
06:08:28 <ski> hello bourbaki
06:10:14 <goron> ski: I skimmed through it, but I don't see the relevance, but when I have spare time, it's probably worth reading :) 
06:12:12 <goron> ski: I saw something on the Haskell lists using unsafePerformIO. I think I will use that. 
06:12:37 <ski> i'd be careful with that ..
06:13:07 <ski> goron : hmm, got an uri ?
06:13:33 <goron> http://www.haskell.org/pipermail/haskell-cafe/2004-April/006029.html
06:13:38 <ski> ty
06:15:11 * ski 's looking at an erwig paper
06:16:49 <goron> @index unsafePerformIO
06:16:49 <lambdabot> Graphics.Rendering.OpenGL.GL.Extensions,Foreign,GHC.IOBase,System.IO.Unsafe
06:17:41 <ski> you'll prolly want the third one
06:18:02 <goron> ski: I know
06:18:31 <goron> The quality of code in the Haskell Cafe is below zero...
06:18:47 <ski> mhm ?
06:19:47 <goron> ski: It's not working. There's type where there should be Data
06:19:51 <goron> data
06:20:04 <goron> and then it still doesn't work.
06:20:44 <ski> methinks you'll have to import some lib module defining the monad transformer ErrorT
06:21:03 <ski> (i.e. i think it should be "type", not "data")
06:21:06 <goron> that's possible. 
06:21:41 <ski> Control.Monad.Error
06:21:45 <ski> 'tseems
06:21:52 <goron> You are right.
06:22:09 * goron is a stupid n00b...
06:22:25 <ski> np
06:23:06 <goron> It works. 
06:23:35 <goron> Well, as long as there's an evil hack, people may call error :)
06:23:49 <ski> heh
06:25:11 <goron> I only hope I can get the value from the ErrorT value, when the computation succeeds. 
06:29:12 <ski> (though, it's prolly better to use "catchJust errorCalls ..." instead of "catch ..." (or handleJust, if that looks nicer ..))
06:34:09 <goron> ski: There is no need for a handler. 
06:35:15 <ski> huh ?
06:36:27 <ski> the handler is invoked if an exception is raised. didn't you want to catch it ?
06:36:42 <goron> ski: Well yes, but it works with IO again.
06:37:13 <ski> oh right
06:37:37 * ski forgot you switched to the bringerts code
06:38:02 <goron> I don't have experience with exceptions in Haskell and although I know some of the theory, I  don't get it. 
06:39:04 <ski> anyway, i just wanted to remark that it's prolly better if you only catch calls to error and not other exceptions (alternatively, reraise the exception if it's not an ErrorCall)
06:39:43 <goron> I have this value:(m (Either e a)), how can I only get the either part? I don't know the type of m.
06:39:58 <ski> no
06:40:31 <ski> (i.e. : can't be done)
06:40:46 <ski> what are you trying to do ?
06:40:59 <ski> shapr : hi there, god eftermiddag !
06:41:20 <shapr> hej ski!
06:41:33 <goron> hej
06:41:51 <shapr> hoi goron 
06:42:06 * shapr bounces
06:42:20 <goron> shapr: Did you ever catched a function that called error and converted into something of type Maybe something. 
06:42:53 <ski> goron : (i.e. how can you not know what m is ? are you trying to use/write a generic monad operation ?)
06:42:55 <shapr> I think I've seen code that does that.
06:43:22 <goron> ski: Well, I could know it. 
06:43:33 <goron> Let me have a look again
06:44:56 <ski> hmm
06:45:06 <ski> i think i see where you got it from
06:45:49 <ski> you're extracting to argument of the ErrorT constructor, right ?
06:45:54 <ski> s/to/the/
06:46:16 <goron> I call runErrorT on the value.
06:46:27 <ski> right
06:46:28 <goron> And then I want to get to the Either value
06:46:46 <ski> so the m can be whatever monad you like
06:47:11 <ski> e.g. Identity :)
06:47:18 <goron> Well, it should work for the example on mailinglist. 
06:47:48 <ski> @index Identity
06:47:48 <lambdabot> Control.Monad.Identity,Control.Monad.Identity
06:48:21 <goron> What would be the use for Michael Weber to put a monadic layer on it?
06:48:47 <ski> who ?
06:49:23 <goron> That's the guy who wrote Control.Monad.Error
06:49:41 <ski> oh
06:49:53 <ski> because it's a monad tranformer
06:50:00 <ski> Error /= ErrorT
06:50:51 <ski> if you're just copying bringerts code, you could modify it somewhat so it fits more closely with what you want, i guess
06:51:04 <goron> Ah, yes. You have this monad A and this monad B. And you want to get both of the functionality in your monad C. 
06:51:16 <shapr> whoa, there's an emulator for the Apollo Guidance Computer.
06:51:33 <ski> shapr : what's that ?
06:51:46 <ski> goron : aproximately that, yes
06:52:16 <shapr> it's the hardware that got men on the moon.
06:52:43 <shapr> only 57 were made
06:52:52 <ski> hmm goron, which function is it that generates the error that you want to catch ?
06:52:54 <shapr> some are still on the mood
06:52:55 <shapr> moon
06:52:58 <ski> shapr : interesting
06:53:08 <goron> Data.Graph.Inductive.Graph.context
06:53:22 <shapr> I don't think GHC would run on that hardware.
06:53:35 <goron> shapr: URL?
06:53:55 <shapr> http://www.sandroid.org/Apollo/index.html
06:54:08 <goron> It compiles, but if it does the right thing?
06:54:36 <shapr> gutentag basti_ 
06:54:59 <basti_> hi
06:55:05 <ski> hello basti_
06:55:28 <shapr> hm, 43 memory banks of size 2000, but only 1777 usable because the rest is checksums
06:55:53 <basti_> what kind of device is that?
06:56:07 <shapr> It's the Apollo Guidance Computer
06:56:16 <basti_> oh
06:56:23 <basti_> i heard about that emulator
06:56:25 <shapr> for Nasa's Apollo missions, moon landings, and that sort of thing.
06:57:06 <earthy> yeah, they really had an interesting update of the space shuttles a decade ago
06:57:32 <shapr> earthy: what happened?
06:57:36 <earthy> replaced the existing core memory with *thick* *heavy* shielding and a bit of solid state memory
06:58:00 <earthy> suddenly allowed for orbital control and landing software to be in memory at the same time
06:58:07 <basti_> hehe
06:58:22 <shapr> is core memory less susceptible to charged particles or something?
06:58:22 <earthy> thereby making it unnecessary to go to manual control while swapping from orbital control to landing guidance
06:58:29 <earthy> well, yeah
06:58:35 <basti_> a lot less i'd say
06:58:46 <earthy> it's big chunks of magnetised metal as opposed to tiny charges in silicon...
06:59:01 <shapr> I've had my hands on 80 bits or so of core memory.
06:59:08 <basti_> core memory is written with currents like, 5 A
06:59:16 <shapr> oh, good point.
06:59:39 <earthy> core is cool though... you can actually *count* the bits by eye... :)
06:59:47 * shapr agrees
06:59:52 <basti_> the computer center in clausthal (where i studied once) kept the core memory of an older computer they had
07:00:00 <basti_> 1024 x 11 bit or something
07:00:02 <shapr> I wish I could get hold of some core memory.
07:00:07 <basti_> (shoebox size)
07:00:13 <basti_> what for? ;)
07:00:14 <shapr> basti_: wow, nifty
07:00:18 <goron> It works :-)
07:00:19 <shapr> I'd like to keep it on my desk
07:00:19 <ski> goron : when did context raise the error you wanted to catch ?
07:00:39 <basti_> you could build some yourself =)
07:00:41 <goron> ski: create empty graph 
07:00:46 <earthy> I think Doaitse has some in his office
07:00:51 <goron> ski: search for a non-existing node.
07:00:54 <earthy> I know Kees Koster does. ;)
07:00:57 <goron> ski: ready
07:01:02 <shapr> I have a nice RCA vacuum tube and box, but it's still in the States.
07:01:18 <basti_> whats rca?
07:01:20 <shapr> earthy: I bet doaitse wouldn't let it go though.
07:02:00 <shapr> basti_: http://cgi.ebay.com/ws/eBayISAPI.dll?ViewItem&item=5717055897&category=73379
07:02:14 <ski> goron : why don't you just test for "isEmpty" and call "nodes" to get a list of all nodes in the graph (checking with that) before calling context, then ?
07:02:19 <earthy> no, he wouldn't ;)
07:02:48 <basti_> is that for modulation?
07:03:03 <goron> Haskell is easy, you only need one monadtransformer, some type theory, and some hackery to catch an error. I mean come on that's easy :)
07:03:08 <basti_> ah no
07:03:21 <shapr> tubes were the original transistors
07:03:28 <goron> ski: Ever heard of performance?
07:03:30 <basti_> i know.
07:03:39 <basti_> and some sorts of devices still need tubes
07:03:45 <basti_> not computers, though
07:03:45 <shapr> basti_: ok, I just like to talk about how computing started :-)
07:04:02 <basti_> i guess it started with Leibniz or Babbage.
07:04:08 <shapr> well, that's true
07:04:19 <earthy> Pascal? :P
07:04:23 <earthy> and then Zuse of course
07:04:23 <basti_> or Zuse.
07:04:24 <shapr> then there was thomas edison and electrical signal smoothing in a vacuum tube
07:04:26 <basti_> :)
07:04:26 <goron> Leonardo already thought of a computer. 
07:04:34 <shapr> Zuse? the linux distro? ;-)
07:04:37 <basti_> uhm
07:04:41 * shapr laughs
07:04:52 <ski> goron : yes (wanted to see if you'd just missed those, or something :)
07:05:14 <mikael> hey hey
07:05:15 <basti_> well Leonardo thought of a lot.
07:05:18 * goron thinks the dinosaurs thought of the computer first. :)
07:05:25 <ski> hej hej, mikael
07:05:27 <shapr> hej mikael 
07:05:33 <mikael> hej ski, shapr!
07:06:58 <earthy> I really should finish the book on `The First Computers'
07:07:02 <earthy> http://mitpress.mit.edu/catalog/item/default.asp?tid=3731&ttype=2
07:07:47 <shapr> I've read that trinary logic is actually more efficient in terms of hardware usage
07:08:06 <ski> on trinary.cc ? :)
07:08:13 <shapr> yes, I think so
07:08:17 <phubuh> shapr: did you figure anything out about greencard?
07:08:19 <earthy> pity it's a bit harder to manufacture, right? :)
07:08:23 <shapr> no, I got distracted.
07:08:42 <shapr> earthy: I think the site said that it's only harder to design
07:08:47 <basti_> hmm. i think most processors are actually developed using non-binary logic
07:08:49 <shapr> phubuh: I'll check it now
07:08:53 <phubuh> awesome
07:09:04 <earthy> ummm...
07:09:11 <basti_> buses for example rely on maximum one transistor open at the same time
07:09:13 <earthy> yeah, well, there's something like 9 levels
07:09:25 <basti_> heard something along that line too
07:09:25 <earthy> in current designtooling
07:09:25 <earthy> IIRC
07:09:38 <basti_> but with states like "undefined", "high ohm" etc.
07:09:43 * earthy nods
07:09:47 <earthy> driven or not
07:09:47 <shapr> phubuh: which version of hsx11 and greencard are you using?
07:10:01 <basti_> so its not like 9-valued logic strictly
07:10:23 <earthy> no, it's still 2-valued logic
07:10:45 <basti_> though i would wonder why ternary logic should be better ;)
07:11:05 <basti_> ENIAC was 10-valued iirc, but that un-ruled, because every of the 10 tubes can fail.
07:11:10 <shapr> trinary.cc says you can get the same functionality with less components.
07:11:15 <phubuh> shapr: i haven't downloaded hsx11 yet, i'm trying to compile gc 3.01
07:11:23 <basti_> mh
07:11:33 <earthy> well, trinary logic also allows untimed circuitry
07:11:37 <shapr> basti_: I don't remember if I actually believed it or not
07:11:41 <earthy> if implemented well
07:11:44 <shapr> I do believe that clockless logic is better
07:11:58 <basti_> well
07:11:58 <shapr> having a single clock for the whole chip seems silly to me
07:12:04 <basti_> they don't have.
07:12:04 <earthy> so that might be a good thing
07:12:05 <phubuh> http://mikael.phubuh.org/greencard.txt
07:12:16 <basti_> its like, with phase differences and stuff
07:12:22 <basti_> pipelines
07:12:23 <shapr> phubuh: ah, 3.01
07:12:24 <earthy> though having a single clock for the whole chip is less and less common
07:12:37 <basti_> at least for High End CPU's :P
07:12:53 <Igloo> phubuh: Do you have the GHC profiling libraries installed?
07:13:07 <phubuh> oh, i don't
07:13:10 <shapr> another neat trick is the null-convention logic
07:13:22 <shapr> phubuh: using debian/unstable?
07:13:33 <phubuh> yup, ghc6-prof right?
07:13:40 <shapr> null-convention logic uses 'waste' bits to power further computations rather than burning it off as heat
07:13:41 <phubuh> oh yay!
07:13:47 <basti_> uhm?
07:14:19 <basti_> whats the approx gain in energy usage?
07:14:23 <phubuh> it compiled fine with the profiling libraries.  thanks
07:14:25 <ski> shapr : waste bits ?
07:14:54 <ski> is that related to reversible logic ?
07:14:55 <shapr> null-convention logic is very much harder to design, but the closer your design is to 100% null, the closer it is to producing zero 'waste' heat
07:14:58 <shapr> ski: yes, same thing
07:15:02 <ski> ok
07:15:21 <basti_> i dont believe that would work.
07:15:30 <shapr> basti_: it does work.
07:15:35 <basti_> a part of the loss is when you "flip" a bit
07:15:45 <basti_> since you're moving charges through a wire with resistance
07:15:54 <ski> iirc, discarding information creates waste heat
07:16:08 <shapr> basti_: ok, other than electrical resistance...
07:16:10 <basti_> sure, you can avoid to have to "cut short" stored bits to erase them
07:16:17 <shapr> basti_: http://www.zyvex.com/nanotech/reversible.html
07:16:29 <basti_> -reads-
07:16:44 <shapr> one extraspiffy connection was reversible and quantum computing
07:16:55 <shapr> quantum computations *must be* reversible. 
07:17:27 <shapr> hiya keverets 
07:17:37 <basti_> o.o
07:20:31 <phubuh> oh hm, i think i remember getting this error compiling hx11 -- newForeignPtr recently changes signature, right?
07:20:33 <phubuh> er, changed
07:20:55 <keverets> shapr: hello
07:21:11 <shapr> how's code?
07:21:33 <keverets> longer and more complicated than it should be.  I'm always in awe of how the masters can write such elegant code.
07:21:45 * shapr agrees
07:22:00 <shapr> have you written any Haskell code lately?
07:22:16 <Igloo> phubuh: Just argument order changed I think
07:22:17 <keverets> Not since last night ;)
07:22:33 <keverets> about to do more hacking, but I really should be thesis writing instead.
07:22:40 <phubuh> Igloo: yeah.  will bad things happen to me if i frob the .hs files resulting from the .gc files?
07:22:59 <Igloo> No idea - is that easier than frobbing the .gc files?
07:23:20 <phubuh> well, the .gc files don't mention newForeignPtr :)
07:23:31 <Igloo> What is hx11 OOI?
07:23:42 <phubuh> er, hsx11
07:23:54 <phubuh> (OOI?)
07:23:55 <shapr> http://www.reid-consulting-uk.ltd.uk/projects/HSX11.html
07:23:59 <shapr> out of interest
07:24:07 <phubuh> ah
07:24:07 <Igloo> Oh, I thought that was in ghc6 already, but I'm wrong - it's only in ghc-cvs
07:24:36 <phubuh> ooh, i'll just install that then
07:37:14 <shapr> phubuh: what did you think of tuomov's vis proposal?
07:40:01 <phubuh> shawn: it's way more interesting than my mere window manager, but a lot wider in scope :)
07:43:17 <shapr> still, it goes down the same road
07:44:44 <phubuh> yeah
07:45:50 <ski> vis proposal ?
07:48:33 <shapr> ski: http://iki.fi/tuomov/vis/
07:48:39 <shapr> hej Marvin--, wassup?
07:48:42 <ski> shapr : ty
07:50:32 <Marvin--> ello
07:50:34 <Marvin--> nothing much
07:54:40 <Lemmih> Anyone got a TI84+ to play with a Linux box?
08:00:31 <basti_> i used a HP48 as a serial line terminal once.
08:00:40 <basti_> with a self written terminal emulation.
08:21:24 <phubuh> is there a [(a, b)] -> a -> b somewhere in the standard library?
08:21:54 <Lemmih> lookup?
08:22:03 <ski> @type lookup
08:22:04 <lambdabot> lookup :: forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
08:22:08 <phubuh> ooh
08:34:58 * shapr plays with halipeto
08:36:56 <thebug> how is that, does it work well?
08:37:19 <shapr> it looks nice, haven't tried to build a real site with it yet.
08:37:41 <shapr> would be interesting to mix with HaskellDB
08:39:21 <shapr> anyone else here tried halipeto?
08:50:03 <xkb> halipeto = haskell server pages?
08:54:19 <shapr> not exactly
08:54:28 <shapr> more like page templates
08:56:52 <shapr> xkb: it's related though
09:10:01 <shapr> Halipeto does seem related to Steve van Hoyweghen's data-centric ideas.
09:10:15 <xkb> hmm sounds intersting
09:10:19 <xkb> interestingeven
09:10:21 <xkb> aargh
09:10:29 <xkb> anyway.. is it an apache module?
09:11:16 <shapr> no, it's purely a templating system.
09:11:53 <shapr> it generates static pages from a simple filesystem and text file database
09:12:23 <shapr> it was designed in such a way that dynamic generation and/or SQL database should be simple to add.
09:13:22 <shapr> actually, I'm secretly considering using Halipeto for the new version of a German Univeristy's website, but don't tell them that :-)
09:14:09 <xkb> ah.. is it that finished yet?
09:14:13 <xkb> or rather complete
09:14:35 <shapr> Sure, the static webpage generation works nicely.
09:15:29 <shapr> I did the original static generation of the previous version of this uni website with Python a few years back.
09:16:55 <xkb> Im currently using mambo ( a php framework ) for all my sites
09:17:02 <xkb> but its a bit overkill for alot of stuff
09:18:08 <shapr> Halipeto is actually quite simple.
09:19:24 <shapr> give me a coupla hours to come up with real executable proof though :-)
09:20:16 <xkb> lol
09:20:52 <shapr> The included demo is simply structured and looks great, but I'll have more info when I've written one or two tests of my own.
09:21:44 <shapr> xkb: here's a demo of Halipeto: http://acooke.org/pancito/intnleng/index.html
09:21:54 <xkb> cool..
09:28:31 <ski> bye ffolks
09:55:51 <shapr> @yow !
09:55:51 <lambdabot> I know how to do SPECIAL EFFECTS!!
09:57:50 <shapr> so, who here builds websites with Haskell, or wants to?
09:58:10 <shapr> I wonder if a Haskell webtool summary wiki page would be popular.
09:59:06 <Smerdyakov> I build web sites with SML.
09:59:48 <shapr> Have you written anything about functional web frameworks?
10:00:03 <Smerdyakov> I have written one that is functional in the same way that ML is functional.
10:00:07 <Smerdyakov> http://smlweb.sf.net/
10:02:47 <shapr> hiya stepcut 
10:03:42 <stepcut> hello
10:03:56 <shapr> have you tried halipeto?
10:04:01 <stepcut> not yet
10:04:25 <shapr> it appears to have some real advantages.
10:04:44 <stepcut> yes, I definately plan to check it out Soon(tm)
10:05:14 <shapr> I'm trying it now, it's a very different approach from WASH.
10:05:44 <stepcut> do you think it can be used as a complete replacement? Or just in different cases ?
10:07:42 <shapr> it's more about templates with filled-in spots, it's mostly a Haskell rewrite of Zope Page Templates
10:08:14 <Smerdyakov> Does it support pattern matching?
10:08:16 <shapr> so, there's no type-checking of anything in particular, though I think WASH has lost a lot of type-checking usefulness lately.
10:08:33 <shapr> pattern matching in what way?
10:08:57 <Smerdyakov> Like Haskell case expressions, to choose alternate text.
10:09:10 <shapr> in essence, <span hal:foo="input"> calls the  foo function with "input"
10:10:04 <shapr> it oriented towards a data-centric approach, but I'm not sure if it specifically uses pattern matching.
10:10:41 <shapr> I do like the simplicity of the custom attribute name being the function to call.
10:11:26 <Smerdyakov> In my system, you can do things like: <% foreach color in genColors () match color with RED => %> <font color="red">Red!</font> <% | _ => %> Not red. <tt>:-(</tt> <% end %>
10:11:58 <Smerdyakov> Naturally, you get the usual nested pattern matching as well.
10:12:34 <Smerdyakov> And my ace in the hole is that it takes a shitload of work to write something like mine, which helps hold the competition back. :)
10:12:57 <Smerdyakov> I use the SML/NJ compiler source directly to interface with SML code in arbitrary ways.
10:12:59 <shapr> I would assume that the function being called could do pattern matching of its inputs.
10:13:25 <Smerdyakov> shapr, yeah, but then you are deciding presentation in the _Haskell_function_ instead of the _template_.
10:14:36 <shapr> Not necessarily.
10:14:40 <Smerdyakov> My templates are guaranteed to terminate, while still allowing _lots_ of freedom in running over data structures to determine layout.
10:15:15 <Smerdyakov> But, gotta run now.
10:15:31 <shapr> right so
10:15:46 <shapr> Haskell websites...
10:16:59 <shapr> Smerdyakov: I dislike the <% %> syntax, I much prefer custom attributes. SGML editors often refuse to deal with tags they don't recognize, but usually have no problems with unfamiliar attributes.
10:27:49 <stepcut> i wish I had more time to study the problem of dynamic website generation :(
10:29:49 * flaw thinks building up a DOM structure is pretty nice.. change anything you want, whenever you want..
10:30:05 <flaw> well, with obvious exceptions
10:30:38 <shapr> I really like the idea of type publication.
10:31:15 <flaw> what is that idea?
10:31:54 <shapr> something where you can write "deriving WebPublish" at the end of your type declaration (or a custom instance)
10:32:15 <shapr> and you get view, edit, and input forms for your type.
10:32:44 <shapr> it could probably be done with Data.Generics in Haskell.
10:32:59 <shapr> Python is also leaning towards publishing of 'native' language structures.
10:33:21 <shapr> I think that's the best approach for data-centric stuff like anything that's web <-> database
10:33:22 <flaw> dunno what WebPublish is, but I think I can guess...
10:33:37 <flaw> feh
10:33:39 <shapr> I dunno what it is either, I just made it up a few weeks back :-)
10:35:02 * flaw likes to think of "web pages" as javascript applications. at least that's the direction I think moz and IE are moving...
10:35:26 <flaw> XmlHttpRequests and all that can make for some powerful applications..
10:36:21 <flaw> and JS can handle all the GUI layout too with DOM manipulations..
10:36:24 <shapr> have you seen XUL?
10:36:34 <shapr> I think it has potential.
10:36:38 <flaw> yeah
10:36:51 <flaw> I saw an amazon app written in it
10:36:59 <shapr> yah, nifty app.
10:37:09 <flaw> well, XUL+JS
10:38:33 <flaw> XUL is nice, but I dunno if MS will ever support it in any way, which will matter so long as 80% of ppl use IE...
10:39:18 <flaw> dunno if it was 80%, but I think it was around that quite significant area.
10:39:36 <flaw> also :o
10:39:52 <flaw> I hear with XmlHttpRequests you can work out persistent connections 8)
10:40:00 <shapr> I don't like bowing to MSIE, but I don't know how to get people to start using Mozilla.
10:40:10 <flaw> using the multipart mime type..
10:40:23 <xkb> I defined a simple type and now I want to show it in hugs. Do I need to create a class for that?
10:40:30 <xkb> If I want to use Show
10:40:39 <shapr>  XUL uses the multipart mime type for persistent connections too.
10:40:48 <shapr> xkb: in the source file, you can use "deriving Show"
10:40:57 <shapr> or you can make an explicit Show instance if you want.
10:41:00 <xkb> that works on all simple types?
10:41:09 <keverets> shapr: I give them Mozilla, tell them that it's like MSIE but without popups and popunders, and remove all links to MSIE on their desktop.
10:41:11 <flaw> I thought XUL was just a GUI markup language?
10:41:33 <flaw> keverets++ :)
10:41:37 <shapr> It depends on how simple. If it's just a type alias you don't need to do anything.
10:41:44 <shapr> flaw: ok, XUL apps.
10:42:14 <shapr> yes, XUL is just a gui markup language, and the apps use the multipart stuff to do updates through a persistent connection.
10:42:30 <flaw> ic
10:42:58 <shapr> keverets: I like that plan.
10:43:10 <shapr> I've never heard of a popunder.
10:45:50 <flaw> shapr: I have. nasty things..
10:45:57 <keverets> shapr: even more tedious than popups in that they use javascript to lower themselves under the main browser window.
10:46:24 <flaw> yep, some are real nice and continue to open windows when closed..
10:46:35 <shapr> I cannot understand why people would tolerate such torturous behaviour from software for which they've put out money.
10:46:47 <flaw> (I hear the University Diploma spammer uses that trick)
10:46:54 <shapr> I am repeatedly amazed that people pay money for windows.
10:47:01 <keverets> most don't.
10:47:02 <flaw> shapr: they don't know any better.. =\
10:47:10 <keverets> or at least think it came free.
10:47:48 <shapr> Along the same lines, I've discovered that the various "Don't Pirate This Or Else" warning screens on DVD can take up to two minutes every time you put the disc into the player.
10:48:02 <shapr> If that were software, that wouldn't be tolerated.
10:48:37 <shapr> Is there some website that collects player scripts that get around that sort of stupidity?
10:49:07 <shapr> I wouldn't mind if it were a checkbox the first time I put the disc into the player
10:49:35 * phubuh really adores the snippet on rented swedish video tapes where a bunch of people steal tapes from a video store, and then it's like "THIS IS WHAT YOU'RE DOING, PIRATE"
10:49:40 <shapr> but being forced to watch previews and see anti-pirate warnings in several languages really wastes my time.
10:49:52 <keverets> I really want a set-top DVD player where I can pop in a movie, press play, and have the movie start.
10:49:58 <shapr> keverets: YES!
10:50:00 <shapr> exactly!
10:50:14 <shapr> thing is, the data is on the disc
10:50:20 <flaw> take you straight to the menu.
10:50:42 <Philippa> build a media PC, do it that way
10:50:42 <shapr> so, we only need to have custom scripts that start the movie directly on the disk once they know which sector to start playing
10:50:44 <shapr> right?
10:50:51 <keverets> None of these menus unless I ask for it.  If I want to see an extra feature, I could hit the "Menu" button and see what's available.
10:51:17 <shapr> and then we all find the location of the actual content on the discs we own and keep a website that shares these scripts, right?
10:51:30 <Philippa> I don't mind the menus so long as there's a clear "play now, dammit!" option on the first one
10:51:59 <shapr> I *very much* mind the crap that I'm forced to watch before the menus.
10:52:10 <keverets> Philippa: I built one using a P100 and a Creative dxr2 to output to the TV.  When I put in a DVD it would look for the largest VOB on the disk, and start playing that using the Linux command-line utils.
10:52:10 <Philippa> oh, agreed
10:52:12 <shapr> and I'm forced to watch it *every time* I put in the disc.
10:52:31 <Philippa> ouch. I can skip that with the player on this PC, the PS2 respects the "no jump to menu from here" though :-(
10:52:36 * shapr goes off to unicycle.
10:52:40 <phubuh> keverets: clever
10:52:48 <keverets> but I never got around to doing the remote control interface and such, and the P100 was too large and loud.
10:52:49 <shapr> I will think up a solution.... 
11:13:38 <musasabi> shapr: using mplayer works fine (you can skip the intros) and it skips all menus.
11:19:28 <pesco> Can somebody enlighten me as to the full story of the greek letters in terms like alpha-conversion and beta-reduction?
11:20:16 <ibid> i'd assume it's just ordinals
11:20:44 <pesco> So it's just Church's way of "numbering" the operations on lambda-terms?
11:21:18 <Philippa> though I wouldn't be surprised if alpha-conversion = "alphabet conversion" or similar
11:21:20 <musasabi> pesco: you can treat them as arbitary names.
11:21:41 <Philippa> certainly it's a nice mnemonic
11:22:09 <pesco> musasabi: I'm just trying to get the whole picture, thus I need to know why these things are named that way.
11:22:44 <pesco> Are there other operations on lambda terms? Named delta-something or so?
11:22:46 <Philippa> may as well start with "why lambda?" then. At least at that point you've a tendency towards greek letters
11:22:59 <Philippa> there's eta-something
11:23:15 <pesco> Yes, I thought I remembered that...
11:23:39 * flaw finds those terms annoying...
11:23:47 <flaw> and currying still makes me hungry..
11:23:58 <pesco> Philippa: I'm pretty sure there's an interesting piece of history about the origin of the "lambda".
11:25:37 <xkb> hmm I think im doing something the hardway here
11:25:59 <xkb> I have a type [(Char,Int)] and thats a frequency table
11:26:12 <xkb> I have functions for inserting and increasing an element
11:26:21 <xkb> and a lookup function
11:26:24 <xkb> those work fine
11:26:38 <xkb> now I have a function freq to fill the datastructure
11:26:48 <xkb> however: im passing the ds around now.. as in
11:27:04 <xkb> freq :: String -> FreqList -> FreqList
11:27:23 <xkb> Is there any way to ease this? Besides using a monad?
11:28:06 <basti_> not strictly lambda.
11:28:17 <pesco> Depends on what you consider "easing". Have you considered implicit parameters?
11:28:19 <basti_> as in the bright side of lambda.
11:29:24 <basti_> monads is just another way of putting this
11:29:33 <basti_> but the compiler then knows how to do it right
11:30:45 <xkb> do we have a codedump site?
11:30:54 <basti_> uhm yes
11:31:10 <basti_> that doesnt mean i know where.
11:31:13 <xkb> ill paste the function.. the problem is in the lazy evaluation of insert..
11:31:13 <xkb> :D
11:31:19 <xkb> ill look 1 up
11:32:25 <xkb> http://eugeneciurana.com/pastebin/pastebin.php?show=2834
11:32:32 <xkb> ignore the line nrs
11:32:40 <xkb> ie 6,7
11:33:03 <xkb> insert :: Char -> FreqList -> FreqList
11:33:05 <basti_> well that works, yes.
11:33:25 <xkb> The problem is the list doesnt grow beyond 1 element
11:33:29 <basti_> oh
11:33:51 <basti_> then insert works a little different maybe?
11:33:58 * basti_ just guessing
11:34:22 <xkb> hmm
11:34:34 <xkb> maybe im making another mistake..
11:35:30 <xkb> http://eugeneciurana.com/pastebin/pastebin.php?show=2835
11:35:33 * basti_ has to stop spoiling his stomach right now, he thinks.
11:35:34 <xkb> thats insert :P
11:38:47 <basti_> that || thing irritates me
11:39:03 <xkb> jah.. that vim's config here
11:39:07 <basti_> oh
11:39:11 <xkb> to indicate tab
11:39:23 <basti_> @type lookup
11:39:24 <lambdabot> lookup :: forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
11:39:37 <basti_> you sure that pattern matching works this way with Maybe?
11:39:40 <xkb> I overwrote it
11:39:59 <xkb> to a [a] -> bool
11:40:07 <basti_> oh
11:40:27 <basti_> yes of course it doesnt grow.
11:40:34 <basti_> youre inserting a to a []
11:40:42 <basti_> why should it become more than one element :)
11:40:55 <xkb> oh
11:40:57 <xkb> darn
11:41:06 <xkb> how stupid
11:41:40 <basti_> you shouldnt recurse too.
11:41:48 <basti_> not that way.
11:42:09 <xkb> hmm I see.. this way ill create an endless loop
11:42:50 <xkb> if I would change [] to xs
11:43:00 <basti_> yes
11:45:17 <xkb> ok.. got it working
11:45:25 <xkb> created an add function
11:45:38 <basti_> :)
11:45:53 <xkb> that just does ++ [(char,1)
11:45:55 <xkb> ]
11:46:11 <basti_> :)
11:46:12 <basti_> sure
11:46:13 <basti_> ;)
11:46:43 <xkb> Is there any cleaner way to handle this kind of datastructure passing?
11:46:53 <basti_> besides monads?
11:46:57 <xkb> yah
11:47:13 <basti_> hmm
11:47:21 <basti_> not that i know of spontaneously
11:49:01 <basti_> but im not a haskell rewl0rz.
11:49:50 <basti_> any haskell rewl0rz sp34k l33t?
11:49:58 <xkb> lol
11:53:25 * musasabi shudders
11:53:27 <Philippa> j0
11:55:18 <basti_> so do tell
11:55:52 <xkb> I guess they are all eating/sleeping/hacking
12:12:30 <shapr> j0 j0
12:12:42 <basti_> y0 shapr share ur w1sd0m!
12:12:51 <shapr> on what?
12:12:58 <basti_> read what xkb said
12:13:13 * shapr looks
12:13:24 <ibid> gmail invites available
12:14:41 <shapr> xkb: do you want a nice way to do histograms, or is your code for teaching yourself about Haskell?
12:17:04 <shapr> nice histograms would addToFM_C or addListToFM_C
12:19:19 <basti_> hmm i think Data Flow languages are good for Histograms.
12:23:59 <basti_|> re
12:24:01 <shapr> xkb: other ways to write your existing code would include mixing lookup and Data.Maybe.maybe, or applying an increment function to the list item, but I'd probably fold addToFM_C across your string
12:31:54 <xkb> shapr, thans
12:31:57 <xkb> +k
12:32:29 <xkb> addToFM_C is in what lib? Ah.. ill look it up
12:32:54 <Lunar^> @index addToFM_C
12:32:54 <lambdabot> Data.FiniteMap
12:33:06 <Lunar^> xkb: lambdabot is your friend :{
12:33:10 <Lunar^> :) sorry
12:33:29 <shapr> xkb: this may not be terribly readable but...
12:33:32 <shapr> fmToList $ (addListToFM_C (+) (emptyFM :: FiniteMap Char Int)) $ zip "this is a test" [1,1..]
12:33:40 * shapr lags horribly
12:34:35 <xkb> http://dada.perl.it/shootout/wordfreq.ghc.html <= nice example for letter frequency
12:35:36 <xkb> maybe not "nice"
12:36:06 <shapr> I get this result: [(' ',3),('a',1),('e',1),('h',1),('i',2),('s',3),('t',3)]
12:36:38 <xkb> looks ok :)
12:37:06 <xkb> It's for a en- and decryption demo
12:37:30 <shapr> seen the haskell-crypto collection?
12:37:36 <xkb> ehm no
12:37:47 <shapr> you can do nearly 'serious' crypto with that.
12:37:55 <xkb> The idea was however to keep it as readable as possible
12:38:00 <xkb> hence the "no monads"
12:38:27 <shapr> http://www.haskell.org/crypto/ReadMe.html
12:38:56 <shapr> DES, Blowfish, RSA, PKCS#8, lots more.
12:39:13 <xkb> wow.. kinda neat
12:39:21 <xkb> even Rijndael
12:39:28 <xkb> or however u write that
12:39:43 <shapr> ik veit het niet
12:39:49 <xkb> hehe
12:40:05 <xkb> that was a pretty good attempt :P
12:40:12 <shapr> :-)
12:40:48 <xkb> Strange though, I'm Dutch and dont even know how to write it
12:40:56 <xkb> maybe thats because its belgian
12:42:25 * musasabi frowns at passing 5 args to functions...
12:42:33 <musasabi> should redesign things more...
12:43:52 <Philippa> sometimes it's justified, though I find myself sometimes thinking I should be passing tuples for certain sets of parameters for ease of binding
12:45:17 <musasabi> "handle mv cons _  lm@(LMsg m@(Items cn _  _) _)= doLMsg mv cons cn m lm"
12:45:20 <musasabi> ugly.
12:45:41 <shapr> can you partially apply some of it?
12:46:08 <musasabi> hmm changing the call order of handle would do that...
12:55:48 <Philippa> I've found myself getting a pile of parameters for different (wrappers around) STRefs in a couple of places
12:56:31 <Philippa> I kind of like references for state actually, used to do that in C++ - you get fairly explicit flow-of-state, and you know what the function can and can't change
14:04:01 <Lemmih> Gmail is still unwanted?
14:05:55 <bringert> huh?
14:06:31 <eixei> lol, why is everybody trying to give away those gmail invitations lately?
14:06:47 <Lemmih> I'm stuck with 6 gmail invites but it seems like no Haskeller wants a gmail account.
14:07:04 <bringert> what's the story with those anyway?
14:08:12 <bringert> how does one get them? who can one give them to? does one have to give them to someone within 48 hours or ones compiler will mysteriously stop working?
14:10:23 <Lemmih> They show how many invites you have left with a red text which is somewhat annoying.
14:10:34 <bringert> ah, clever
14:13:14 <bringert> is there a catch?
14:13:41 <bringert> guess I'm asking why people don't want your invitations
14:14:45 <Lemmih> They don't do me any good.
14:15:08 <ibid> bringert: i assume that the market is saturated :)
14:15:18 * ibid too has 5 invitations to spend
14:15:24 <eixei> actually, I have never been on gmail
14:15:28 <eixei> is it any good?
14:15:32 <Lemmih> Well there are ads when one is viewing an email but those are only text- and content based.
14:15:42 <ibid> eixei: for a webmail, yes, very good
14:16:03 <ibid> the ads are unobtrusive, i hardly notice them. think google text ads
14:16:21 <eixei> they are based on the content of your emails, right?
14:16:25 <ibid> yes
14:17:01 <eixei> oh :-(
14:17:11 <ibid> why the frownie?
14:17:52 <eixei> uhm, I don't actually feel like letting my emails get parsed :-/
14:18:02 <ibid> eixei: then don't use a mail program
14:18:09 <ibid> eixei: mails are parsed anyway
14:18:24 <eixei> :-/
14:18:28 <Lemmih> do { text <- getContent; sendToGovernment; display(text)}
14:18:44 <bringert> I'd be happy to accept an invitation, sooner or later I won't have a nice university account any more
14:18:48 <ibid> eixei: do you have a problem with content-based spam filters?
14:18:49 <eixei> well... I guess I could try it out, if one of you could invite me :-)
14:19:00 <ibid> eixei: real name and email please :)
14:19:08 <eixei> ibid: not really, at least not if the data isn't used for anything else
14:19:17 <eixei> sure :-)
14:19:44 <eixei> thanks
14:20:01 <ibid> eixei: yeah. the ad scanner does not have any state, it just scans the mail just before the mail is displayed, and the ad selection is discarded immediately
14:20:12 <eixei> oh
14:20:18 <eixei> well, that isn't so bad then
14:21:38 <eixei> the 12'' ibook costs 1099$ in the US and 1199? in germany :-(
14:24:18 <ibid> i think all data it gathers are statistics on how many times particular ads are shown, in total, over the whole google product line
14:25:12 <ibid> (they discuss this at length in the faq)
14:25:35 <eixei> Well, I guess I'll read it a little bit later then :-)
14:26:19 <ibid> anybody else want one? :)
14:26:24 <ibid> if not, i'll go to bed
14:27:52 <eixei> goodnight :-)
14:35:01 <LittleDan> is it possible to define your own function that has the same sort of special behavior that - does?
15:19:55 <eshu> LittleDan: which sort?
15:30:31 <eixei[sove]> good night everybody!
16:27:10 <stepcut> c++ has too many things to remember 
16:31:36 <Lunar^> Is SyntaxPolice's debian repository brocken ?
16:54:47 <Jerub> stepcut: kill it.
17:00:22 <Igloo> Lunar^: Yes. It should make a reappearence elsewhere RSN.
17:01:24 <Lunar^> Igloo: good news
17:01:41 <Lunar^> Igloo: I can help for hosting, if neede
17:01:43 <Lunar^> e
17:03:11 <Igloo> Thanks for the offer, but that's not the current problem (making time to set it up is)
17:08:32 <Lunar^> Igloo: ok
18:58:10 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]'
18:58:10 --- topic: set by shapr on [Fri Jun 25 02:34:22 2004]
18:58:10 --- names: list (clog tic emu flori musasabi ibid shammah wagle shrimpx ozone sorje juhp kosmikus|away XTL cmeme det SamB sisko lambdabot isomer CLxyz Fractal andersca opet thebug mattam kaol Smerdyakov kuz Lunar^ edwinb Pinnen Lor earthy asmodai noclouds Igloo polli Taaus jak eshu Matt-W Hipo flaw phubuh shawn eixei[sove] Philippa jesse99 arauko dennisb norpan [dan] Pseudonym Joachim_ Cale GreyLensman Riastradh)
20:16:08 <Gahhh> when you write "putStr s = sequence_ (map putChar s)", does GHC (or hugs) really construct a list of actions before sequence_ing them, or does it somehow emit code that skips that step ?
20:17:17 <Cale> it doesn't construct the list before sequencing them in any event
20:17:23 <Cale> because it's lazy
20:18:00 <Cale> if anything, it would construct the list as the actions were executed
20:18:40 <Cale> (one element at a time)
20:18:54 <Gahhh> so it basically performs a for_each si in s, putChar s without the extra overhead ?
20:19:21 <Cale> there might be some overhead, but it ought to be quickly garbage collected
20:19:44 <Cale> but there's some overhead in anything :)
20:20:44 <Cale> It's certainly not going to evaluate all of s, then construct the whole list of actions, and then call sequence_ on that in a strict fashion.
20:21:25 <Cale> It will construct the head of s, then apply putChar to it, and then execute it, and then continue with the next element of s, and so on.
20:21:35 <Gahhh> I suppose the calls go back and forth between sequence_ and map during execution as new elements are needed ?
20:21:36 <Gahhh> ok
20:22:17 <Cale> If you know what coroutines are, think of it as that :)
20:22:26 <Gahhh> I don't. what are they ?
20:24:17 <Gahhh> http://en.wikipedia.org/wiki/Coroutine
20:24:24 <Cale> They're like an alternate structure to subroutines which rather than giving back control only at the end of the call, give back control somewhere in the middle.
20:24:39 <Jerub> yay wikipedia
20:24:41 <Cale> and then come back and start up where they left off the next time
20:26:14 <Gahhh> They sound like python's generators to me. or it's the other way around.
20:26:32 <Jerub> Gahhh: pythons generators are a specific case of coroutines.
20:26:45 <Cale> they're like that, except you might have many processes all hooked into each other
20:27:16 <Cale> and they pass control to each other generally based on demand
20:27:22 <Jerub> my favourite example of lazy evaluation is the function
20:27:26 <Jerub> ones = 1:ones
20:27:38 <Gahhh> that's data, I thought
20:27:42 <Jerub> How can it print before the function has fully evaluated ;)
20:28:06 <Jerub> Gahhh: would you like a gmail invite, I've got 1 left?
20:28:24 <Gahhh> well, why not
20:28:35 <Jerub> Gahhh: whats your name and email address?
20:28:59 <Cale> heh, people have been struggling to give away gmail invites a lot recently
20:29:05 <Jerub> Cale: its hard.
20:29:15 <Jerub> Cale: I find newbies on irc channels generally don't have them tho.
20:29:21 <Gahhh> << newbie
20:29:26 <Jerub> Cale: I just gave away 4 to IT workers at the local university.
20:29:45 <Gahhh> what do you get from giving them away ?
20:29:48 <Jerub> (my wife works there and advertised that she had 5, she got 9 responses in 10 minutes)
20:29:52 <Jerub> Gahhh: nothing.
20:29:54 <Jerub> except karma I guess.
20:30:05 <Gahhh> I'll be grateful to you forever
20:30:08 <Jerub> Gahhh: its just that there's a limited supply.
20:30:13 <Gahhh> I pm'd you with my info
20:30:27 <Jerub> you're not a registered user.
20:30:38 <Gahhh> of freenode ?
20:31:59 <Jerub> check your server window.
20:32:13 <Gahhh> picky
20:32:14 <Jerub> just email me on stephen.thorne@gmail.com , thats easier ;)
20:32:42 <Gahhh> ok
20:33:51 <Gahhh> you've got mail !
20:34:11 <Jerub> :)
20:34:15 <Gahhh> yay
20:34:30 <Gahhh> omg I have only three weeks to comply
20:35:17 <Gahhh> I'm happy with fastmail, tho. free, and no ads in your outgoing email, free imap access.
20:39:51 <Gahhh> whoa they don't have ssl login
21:11:16 <musasabi> morning
21:14:09 <Gahhh> aloha
21:22:46 <musasabi> Is there any map-like collection with an operation like deleteRange (Ord k, Eq k) => Map k v -> k -> k -> IO [v]
21:25:54 <Jerub> musasabi: IO ?
21:26:06 <musasabi> Jerub: well operating out of IO is fine too.
21:26:31 <musasabi> (then it would be deleteRange (Ord k, Eq k) => Map k v -> k -> k -> (Map k v, [v])
21:27:29 <musasabi> "find all keys between a and b out of the map, delete and return them"
21:28:37 <Jerub> musasabi: I'd be doing somethign with filter and zip there.
21:30:34 <musasabi> Jerub: wouldn't that traverse the whole tree?
21:30:58 <musasabi> even lists should be faster than that...
21:31:41 <Jerub> hmm. yes. it would.
21:32:33 <Jerub> takeWhile and dropWhile would be the way then.
21:32:46 <Jerub> takeWhile (before range) ++ dropWhile (afterRange)
21:33:07 <musasabi> the only problem being is that I started from replacing lists with something faster ;)
21:35:37 <musasabi> the current way is 'delPart min max = partition (\a -> a > min && a < max)
21:40:10 <musasabi> Something like: "iterFM FiniteMap k v -> k -> a -> (k v a -> (Iter, Action,a))  data Iter = Stop | Next | Prev \n data Action a = Ok | Delete | Update a | Insert a " would be very very nice.
21:41:34 <musasabi> (and add a proper return type:
21:41:37 <musasabi> iterFM FiniteMap k v -> k -> a -> (k v a -> (Iter, Action,a)) -> a 
22:20:32 <pesco> Good Morning #haskell!
22:22:21 <musasabi> morning pesco
22:22:40 * musasabi continues to look for a working map.
22:24:14 <pesco> What are you mapping over?
22:24:40 <pesco> I love getting up at 7:20 (assuming enough sleep).
22:24:58 <musasabi> pesco: I need operations that operate on a key-range.
22:25:13 <pesco> What's a key-range?
22:26:45 <musasabi> pesco: e.g. "partition (\a -> a > min && a < max) list"
22:27:06 <musasabi> all keys larger than min and smaller than max.
22:27:11 <musasabi> trivial with trees...
22:27:37 * pesco rocks joyfully.
22:27:53 <pesco> (I also love waking up to KMFDM, NIN, and thelike)
22:27:53 <musasabi> only their API does not support it.
22:28:20 <pesco> So you have a custom tree data type?
22:28:36 <musasabi> no, I was hoping to use an existing one.
22:29:16 <musasabi> I know *how* to code that. The problem is that I would like not to implement yet another map.
22:29:32 <pesco> I see.
22:29:57 <pesco> That's what you meant by "looking for". :)
22:30:43 <pesco> Look no further! Data.Tree is an instance of Functor. :)
22:31:14 <pesco> @prelude Functor
22:31:15 <lambdabot> ERROR: connect: does not exist (Connection refused)
22:31:18 <pesco> Er.
22:31:31 <pesco> @info Functor
22:31:32 <lambdabot> -- Functor is a class
22:31:32 <lambdabot> class Functor f :: (* -> *) where {
22:31:32 <lambdabot>     fmap :: forall a b. (a -> b) -> f a -> f b; }
22:32:03 * pesco goes to take a shower.
22:32:11 <musasabi> hmm haven't used Data.Tree at all... *googles things*
22:39:53 <musasabi> mailing list posts reference a Data.Tree.AVL but I cannot locate it anywhere?
22:57:19 <Gahhh> musasabi: it looks like its ghc specific
23:45:16 <musasabi> hmm my weight balanced tree implementation seems very non-haskell portable :-(
23:45:34 <pesco> Haha, cool way to say it. :)
23:46:34 <musasabi> 10 * log_2(n) tree nodes allocated with delete worst case :-(
23:47:25 <pesco> Why 10*?
23:47:52 <musasabi> pesco: 5 potential rotations per level, each can create 2 new nodes.
23:48:14 <pesco> Ah.
23:48:32 <xkb> musasabi, is it a balanced tree for searching etc?
23:48:35 <musasabi> the sad thing is that it kills AVL-trees in terms of speed in C.
23:48:38 <musasabi> xkb: yes
23:48:57 <xkb> I just read a paper on priority search trees, also very intresting
23:49:07 <musasabi> hmm?
23:49:15 <xkb> also available in a balanced form
23:49:23 <xkb> allows searching on keys
23:49:28 <xkb> or by "value"
23:49:37 <xkb> as in value of a priority queue
23:49:43 <xkb> node
23:50:20 <musasabi> I have a quite good tree benchmark suite in C, so if you give me a link I can figure where it stands as compared to the alternatives...
23:50:31 <xkb> ok
23:50:34 <xkb> one moment
23:50:59 <xkb> this:
23:51:00 <xkb> http://www.informatik.uni-bonn.de/~ralf/software/PSQueue/Documentation.html
23:51:04 <xkb> is the source
23:51:21 <xkb> it uses views however.. dont know if he implemented those 2..
23:55:09 <musasabi> evil.. including source in html fragments..
23:55:29 <musasabi> views are not very nice because of the lack of support.
23:57:07 <pesco> Done by LaTeX2HTML.
23:57:12 <musasabi> and that does not seem to support the range operations either.
23:58:12 <xkb> it has a range function
23:58:30 <xkb> at-most
23:58:43 <xkb> but again, using views
23:59:20 <xkb> Im not yet fully comfortable with views though
23:59:23 <musasabi> imperative skip lists could be easy (no rotating things)
23:59:56 <xkb> hasnt Okasaki written anything on those datastructures?
