00:25:06 <pesco> Morning
02:10:39 <Lor> Hm, too bad arXiv.org isn't used much by CS folks.
02:16:00 * earthy nods
02:16:07 <earthy> we've got citeseer though
02:17:46 <Lor> Yes, but I mean for previewing.
02:18:34 <Lor> And in general as a forum for "pre-publishing" papers, since it can take ages for them to appear in print.
02:18:59 * earthy nods
02:19:06 <earthy> yeah, it is a pity
02:21:51 <Lor> I have in mind a couple of ideas for some short articles that would in principle be worth publishing, but don't make such a contribution that would warrant appearance in a journal or a conference.
02:22:14 <Lor> Right now the only suitable medium for something like this seems to be sigplan notices.
02:26:59 <ibid> department report series are commonly used for prepublishing
02:27:14 <Lor> Yeah. But no one reads them. :)
02:27:32 <ibid> no, unless you put the paper online and advertise it :)
02:27:47 <ibid> the dept report has the advantage that it is citable
02:28:16 <Lor> Yeah.
02:31:07 <bourbaki> hi
02:32:09 <kaol> could someone please write monochrom's example with using layout instead of braces and semicolons? I can't seem to find the right way to intend it.
02:32:19 <ibid> Lor: i assume you'll be subitting something for splst? :)
02:33:28 <Lor> Dunno, haven't considered it. Where is it, and when?
02:33:52 <musasabi> kaol: look at the code in wiki...
02:34:02 <musasabi> emacs helps too.
02:34:06 <ibid> i think the schedule puts it in estonia next year
02:35:04 <ibid> there seems to be no official announcement that i can find
02:35:20 <bourbaki> does anyone of you know a good http proxy for win32?
02:35:31 <Lor> Righto.
02:35:58 <ibid> Lor: it's a nice venue that is international but not too international :)
02:36:04 <ibid> a good place to practice
02:36:30 <Lor> Right.
02:38:38 <kaol> musasabi: I've tried about all the intendations emacs offers me, but I always seem to get errors about variables not being defined or that "Last generator in do {...} must be an expression".
02:39:41 <stefan_> irc is not that great for discussing multiline code fragments :(
02:40:09 <Lor> I'll have to see. I'm not sure I'll become a real researcher (i.e. a paid one) any time soon, so I may not find too much time for such work...
02:41:10 <kaol> oh well, I'll try to figure it out myself
02:41:29 <ibid> kaol: i think the problem is the mplussing of two do's. that's tricky
02:41:36 <ibid> (to indent, that is:)
02:46:15 <kaol> Is my function a place people would usually use monads in?
02:47:02 <kaol> ie. if I learned really well the concept of monads, would I have written it that way in the first place?
02:49:00 <monochrom> Yes. For example I would.
02:52:23 <Boegel> Is it possible to explain what a monad is ? Short ? 'Cause I'm not familiar with 'em either
02:52:47 <monochrom> Cale can.
02:53:29 <kaol> ok. It just seemed a bit contrived to me (and still does), I couldn't tell if I was stupid or using a monad here was. No offense meant with that. ;-)
02:53:47 <musasabi> kaol: if your code starts looking complex try to find a better combinator for it.
03:04:33 <pesco> Boegel: A monad can be seen as a data type that represents a computation.
03:05:18 <pesco> Whereas I'm still not sure whether the _type_ is the monad, or its _values_ are the monads. I think it's the type, though.
03:06:02 <eshu> the way i see it, is a monad is a polymorphic type, that represents some kind of container
03:06:35 <pesco> Yes, that is also possible. The MonadsAsContainer view.
03:06:44 <pesco> @wiki MonadsAsContainer
03:06:45 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainer
03:06:55 <pesco> @wiki MonadsAsComputation
03:06:55 <lambdabot> http://www.haskell.org/hawiki/MonadsAsComputation
03:07:23 <pesco> Or sorry, add an 's' there, MonadsAsContainers.
03:07:29 <kaol> Ok, I think it's starting to make sense to me. Once I looked at what happens when those foo <- bar things fail, it began to unravel.
03:08:54 <musasabi> hmm there is no MonadsAsCombinators which is my own favorite.
03:09:21 <pesco> I don't think there's MonadsAsComputations either.
03:09:36 <pesco> musasabi: What is the MonadsAsCombinators view?
03:10:30 <musasabi> pesco: monads are just fancy ways of combining two things.
03:11:13 <eshu> well, the as a computation description is useful when looking at the IO monad, but to me it makes no sense for, eg: the list monad
03:11:39 <pesco> eshu: It does if you consider a list to represent a non-deterministic calculation.
03:11:41 <musasabi> eshu: it does make sense for list.
03:11:48 <musasabi> like pesco says ;)
03:12:14 <pesco> eshu: The list elements are the possible outcomes of the computation. The rest follows.
03:12:31 <kaol> I think I'll go write a UsingMaybeMonad page to the wiki from what I learned today.
03:13:23 <eshu> yeah, i guess so, but telling someone new to haskell that a list is a computation is allot harder to swallow than telling them that its a container
03:14:06 <pesco> I don't think it's hard. You don't tell them that it _is_ a computation (because it isn't), but that it can represent one.
03:15:02 <pesco> Exhaustive definition of a non-deterministic computation by listing all its possible results should be a natural concept.
03:15:42 <pesco> Also note to the newbie, that the computations you mean are only ones that do not take input.
03:16:06 <pesco> You can mumble something about arrows at that point, if you like. ;-)
03:18:55 <Boegel> thx, it's al little bit clearer to me now
03:18:59 <Boegel> but still...
03:19:17 <Boegel> I think I should work with them more, before I really understand them
03:19:25 <Boegel> I have to go now, so bye
03:30:44 <musasabi> Any paper that would explain Mu in a gentle way?
03:31:22 <musasabi> things starting with "newtype Mu f = Mu (f (Mu f))" and then going to more complex cases without explanations are quite tiresome...
03:33:22 <Lor> musa, do you understand Y?
03:35:18 <musasabi> Lor: yes, in theory, that is I have worked myself through it a couple of times, but have never used in real life.
03:36:33 <Lor> Usually you don't need to, yeah.
03:36:39 <Lor> Only when you want to tie the knot manually.
03:38:49 <musasabi> hmm?
03:39:57 <Lor> E.g. if you want to insert a memoizer.
03:44:01 <musasabi> I think that sounds sensible.
03:53:39 * TheHunter is angry *grrrr*
03:57:22 <basti_> hi
04:05:37 <bourbaki> TheHunter what happened?
04:11:04 <TheHunter> bourbaki: stupid police caught me driving to fast
04:11:41 <TheHunter> 75 Euro and three points
04:12:41 <arjanb> points for just driving too fast? :S
04:13:24 <basti_> "points" are not a good thing i think
04:14:02 <bourbaki> heh no :) they arent
04:14:32 <bourbaki> TheHunter dang how much too fast is that for 75 euros?
04:14:52 <pesco> Like 30km/h?
04:15:10 <TheHunter> i drove 100 km/h instead of 60. But 60 was just ridiculous at this place
04:15:13 <pesco> Or one of those Autobahn traps?
04:15:18 <pesco> Ah yeah.
04:16:12 <TheHunter> it was a bundesstrasse (2 lanes) just after an Autobahn exit
04:16:52 <bourbaki> these speed limits are shit at a lot of places
04:16:52 <TheHunter> it's an awful lot of money for really endangering *nobody*
04:17:10 <pesco> Hrm. They are just doing this to raise the money for themselves.
04:17:40 <bourbaki> i have never been caught driving too fast :)
04:17:52 <bourbaki> but that might be due to the fact that i usually drive too slow :)
04:18:21 <basti_> too slow in relation to what... that's the question
04:19:07 * pesco imagines bourbaki happily riding his flower-painted VW bus through town.
04:19:10 <bourbaki> in relation to the speed limit :)
04:19:15 <bourbaki> haha
04:19:34 <TheHunter> ok, i have to admit there were roadworks there, so the road was a little bit narrower than usually, but there was almost no traffic
04:19:59 <pesco> And TheHunter in behind, fiddling for the rocket launcher on the back seat of his Delorean.
04:20:06 <bourbaki> :)
04:20:17 <TheHunter> :)
04:20:39 <bourbaki> you mean that trans am aka kit :)
04:20:43 <basti_> btw. i actually saw a GMC DeLorean in good shape on road once.
04:20:54 <basti_> I guess that car is pretty rare here in europe ;)
04:20:57 <pesco> bourbaki: Or that one.
04:21:20 <bourbaki> the coolest car ever build is a 52 shelby cobra
04:21:21 <pesco> basti_: I once stumbled over one parked right in front of an electronics store.
04:21:26 <eshu> pesco: do you think the average java programmer sees a list as a representation of non-deterministic computation? Though 'lists can represent non-deterministic computation' may be a correct, its hardly natural to joe q programmer.
04:22:23 <eshu> (20 minutes later)
04:22:35 <basti_> eshu i didnt get it.
04:23:04 <pesco> Hm. I don't know. I'm imagining someone without any background understanding "imagine a computation with these possible outcomes, you might represent that computation simply by listing all the outcomes it could have."
04:23:30 <pesco> Assuming the computation can have no side-effects.
04:26:11 <pesco> I don't know. I just don't like labeling things as "too complicated for joe programmer".
04:28:07 <pesco> Because most things are not at all complicated if you think about them for a minute or two.
04:28:38 <basti_> yep
04:31:17 <cptchaos> @index readFile
04:31:17 <lambdabot> Prelude,System.IO,IO
04:31:53 * pesco greets cptchaos.
04:45:44 * cptchaos greets pesco
04:46:08 <pesco> cptchaos: I'm approaching 1.0. Finishing reference  documentation.
04:46:44 <cptchaos> pesco: cool, for Module Comm?
04:46:56 <pesco> cptchaos: No, Cmdline.
04:47:07 <pesco> cptchaos: Have you tried Comm? How did it work?
04:47:27 <pesco> cptchaos: I have to get back to Comm, that will be a lot of work.
04:47:30 <cptchaos> pesco: not jet just, finished to get my config parser compiled a minute ago
04:47:40 <pesco> Ah, cool.
04:48:15 <cptchaos> pesco: debugging at the moment, when I can read configfiles properly, I will start network code
04:48:24 <pesco> I see.
04:49:36 <cptchaos> pesco: module comm is already usesed in the project, for the immense importand debug flag (and the config file location)
04:49:52 <pesco> Cmdline, you mean.
04:50:06 <cptchaos> peso: yes
04:50:39 <cptchaos> got typoitis, or something alike
04:51:02 <pesco> cptchaos: There has been a slight interface change, so you might want to update. Just fetch Pesco/Cmdline.lhs from the darcs repository.
04:52:21 <cptchaos> pesco: ok, later, I promised my grandma to visit her today ... (have to go now..)
04:52:34 <pesco> cptchaos: No prob. Just wanted to let you know.
04:52:44 <cptchaos> pesco: thanks
04:54:12 <shapr> @yow !
04:54:14 <lambdabot> Oh, FISH sticks, CHEEZ WHIZ, GIN fizz, SHOW BIZ!!
04:54:24 * pesco grins.
04:54:57 <pesco> What IS the origin of that yow thing?
04:55:10 <shapr> a comic strip from San Francisco
04:55:14 <shapr> Zippy the Pinhead
04:55:19 <pesco> Really?
04:55:32 <shapr> http://www.zippythepinhead.com/
04:57:30 * shapr considers buying a "Yow, I am having fun." t-shirt.
05:04:48 <shapr> Lor: you got promoted to the front page :-)
05:05:53 <shapr> Anton van Straaten seemed to like it.
05:07:20 <Lor> Yeah.
05:09:05 <Lor> Hum, off to the country.
05:10:24 * shapr reads about XUL
05:10:40 * basti_ has a visa for australia now.
05:11:15 <shapr> basti_: cool! Are you visiting andre, mark, sara, and manuel?
05:11:41 <basti_> i dont know. does any of them live by chance near nerang or brisbane?
05:12:02 <shapr> I dunno where nerang is...
05:12:17 <basti_> "gold coast"... southeast end of QLD
05:12:32 <shapr> nifty
05:13:19 <basti_> http://www.mrdaytours.com.au/gold%20coast.gif < about 20 km from there.
05:34:34 <seafood> Igloo: Hey there. You've got commit access to the GHC CVS tree don't you?
05:42:35 <shapr> g'day seafood 
05:42:40 <shapr> heya atom-z 
05:42:54 <shapr> greetz Iter, wassup?
05:43:29 <shapr> hoi Boegel, hoe gaat het met jou?
05:43:35 * shapr bounces in circles
05:43:37 <basti_> -?-
05:43:46 <basti_> shapr: lithium lick?
05:44:02 <shapr> I've never tried lithium, isn't that an anti-depressant?
05:44:13 <Boegel> shapr, goed :)
05:44:28 <Boegel> this is becoming my favourite channel :p
05:44:33 <shapr> mine too!
05:44:40 <seafood> shapr: G'day mate.
05:44:46 <basti_> its said to be good for "stabilisation" of some sort ;)
05:45:01 <basti_> mostly given to manic-depressives though (bipolar)
05:45:17 <shapr> seafood: how's the big city treating you?
05:45:29 <Boegel> big city ?
05:45:38 <Boegel> which one ? (being curious again :p)
05:45:43 <seafood> shapr: Pretty well.
05:45:56 <seafood> Boegel: Sydney. 4 million people. Nothing special I suppose.
05:46:04 <shapr> seafood: you going to enter the IOHCC?
05:46:42 <goron> shapr: Did you find some solution to my "problem"?
05:47:03 <shapr> er no, I got distracted while playing with FGL
05:47:06 <shapr> it's a fun library.
05:47:09 <seafood> shapr: Don't think so.
05:47:20 <seafood> shapr: was considering it. Don Stewart will be though.
05:47:25 <goron> shapr: Ok, then I just implement it the ugly way :-)
05:47:32 <seafood> shapr: He's got a couple of interesting entries :)
05:47:42 <shapr> seafood: I'm scared already :-)
05:47:47 <shapr> and looking forward to it.
05:48:26 <shapr> hey, did you see Lauri Alanko's thesis on "Types and Reflection" ?
05:48:39 <shapr> it mentions Template Haskell, hs-plugins, Data.Dynamics and a bunch of other interesting stuff.
05:49:16 <seafood> shapr: When did he release it?
05:49:22 <shapr> um. yesterday?
05:49:32 <seafood> Cool. I'll have to have a look.
05:49:43 <shapr> it's linked from LtU front page as well.
05:51:12 <Igloo> seafood: Yes, but I can't do anything right now
05:51:15 <shapr> seafood: writing cool code lately?
05:53:20 <shapr> goron: most likely the elegant solution will occur to me in the middle of the night a coupla weeks from now.
06:05:11 <Boegel> out again ;)
06:05:19 <Boegel> bye shapr (and the rest)
06:07:32 <shapr> cya!
06:12:03 <shapr> I swear, I'm this -->| |<-- close to blocking any links to .cn in the Wiki.
06:12:55 <shapr> maybe I could just block any external links?
06:14:11 <shapr> nah, overly restrictive.
06:21:59 <atom-z> shapr, hi
06:22:07 <atom-z> bbl
06:23:33 <shapr> is there a debian package to add dyndns support to my own bind server?
06:32:23 <shapr> Si\: looks like your XSD stuff is getting interesting
06:38:38 <Iter> hey there shapr.  How's things? :)
06:39:47 <shapr> life is good, what's up with you?
06:39:49 <shapr> hiya SyntaxNinja 
06:43:38 <shapr> greetings flaw, how's code?
06:44:02 <Iter> not too bad.  Got bit by yet another buggy equals() implementation (Java), I *hate* that.
06:44:05 <SyntaxNinja> hi shapr
06:44:22 <flaw> shapr: slow going, and not much haskell yet :)
06:44:42 <shapr> Iter: sounds like a need for unit tests for the system as well.
06:46:39 <Iter> shapr: I just don't understand why java programmers feel that symmetry is an optional-extra when implementing equivalence!
06:47:58 * flaw thinks java was misnamed; should have been 'Molasses'.
06:48:14 <flaw> hehe, I suppose that's "changed".
06:50:02 * pesco bursts in tears.
06:50:15 <shapr> pesco: ?
06:50:17 <pesco> (after reading Iter's post)
06:50:28 <Iter> Well I went and wrote up a 'This is how you implement equals() in java' document; and I'll hit the next lazy java 'programmer' over the head with it until they either get a clue, or lose conciousness..... either is a win.
06:50:32 * shapr got out of his Java job for a good reason.
06:51:00 <pesco> Iter: Please do, and send me the results.
06:51:24 <Iter> yes, it's java, but it is a great job.  So I can put up with java atm :)
06:52:21 <Iter> pesco: http://etymon.blogspot.com/2004/08/objectequals.html
06:53:02 <shapr> Etynym would be a cool irc nick.
06:53:30 * shapr considers ressurecting his blog
06:56:25 <shapr> Iter: you left region allocation out of the feature wishlist.
06:56:28 <Iter> shapr: I was able to snarf netymon.net as a domain, so as soon as I can setup my server again, I'll be having fun there :)
06:56:36 <Iter> shapr: what do you mean?
06:56:48 <shapr> er, maybe your next to last point covers it.
06:56:49 <Iter> (which wish list?)
06:56:58 <shapr> or was that entirely Paul Snively's list?
06:57:11 <Iter> which list?
06:57:19 <shapr> "Why Java Sucks"
06:58:12 <Iter> ahh ok. that was a direct quote from Paul Snively on lambda.
06:58:39 <shapr> Ok, at least one feature was left out of that list, possibly two.
06:58:48 <shapr> generics and region allocation.
06:58:51 <Iter> what do you mean by region allocation?  I'm always ready to find YARJS (ya-reason java sucks)
06:59:55 <shapr> Moscow ML has region-based memory management, which gives some very cool advantages.
07:00:00 <Iter> shapr: I would also add autoboxing, closures, and type-safe bound methods.
07:00:21 <Iter> oh, fair enough.  I haven't looked into that sort of thing much beyond reading a few gc survey's.
07:00:33 <shapr> From what I've heard (not actually tried) Moscow ML can ensure that a chunk of memory will be free when a particular chunk of code exits, and automatically deallocate it.
07:00:42 <Iter> cool.
07:00:57 <shapr> it's supposedly much faster and simpler, but has a lot of up-front costs.
07:01:06 <Riastradh> Much faster & simpler than what?
07:01:15 <Iter> up-front == compile-time?
07:01:22 <shapr> Riastradh: than the chunk by chunk de/allocation we do nowadays.
07:02:24 <Riastradh> Stop-and-copy GCs require only the allocation part, and I'd say allocation in a system with a stop-and-copy GC is, uh, pretty simple.
07:04:49 <musasabi> Riastradh: the analysis is very good as you can make the allocations from *stack*.
07:05:25 <Riastradh> You can do the same with a simple generational GC that uses the stack as its nursery.
07:05:39 <Riastradh> There exist several Scheme systems that do this, such as Chicken and Scheme48.
07:07:02 <shapr> "A Brief Introduction to Regions" - http://www.it.edu/research/mlkit/kit_general/ismm98p1-9.ps.gz
07:07:20 * shapr is tempted to add a citeseer-style factoid plugin to lambdabot 
07:08:34 <musasabi> Riastradh: but they get sparse...
07:08:47 <Riastradh> What do you mean 'they get sparse?'
07:08:50 <musasabi> of course if you use the "sliding stack" that is not an issue.
07:09:14 <musasabi> Riastradh: if you don't do a cps transformation...
07:09:25 <Riastradh> ...?
07:09:28 <shapr> Iter: what's a type-safe bound method?
07:10:57 <Riastradh> musasabi, can you fill in those ellipses so I know what you're talking about?
07:11:07 <Iter> shapr: Have a class A, with method foo(T p).  Given an instance of A, a, obtain a handle to foo curried on a.
07:11:14 <musasabi> Riastradh: consider the stack (a = allocated, f = not needed) ->aaafaaffaafffffaaaa now there is no way we can properly compact that if we wish to use that (as it contains return addresses too)
07:12:08 <Riastradh> Sure.  As long as continuations are represented as something the GC can trace, you just trace the top of the stack and copy everything onto the heap.
07:12:11 <Iter> Make sure it keeps it's signature/type so you can later call fooHandle(v::T) on the curried method.
07:12:13 <ibid> musasabi: why do return addresses prevent compaction?
07:12:18 <Riastradh> Copy everything tracable onto the heap, that is.
07:12:24 <Riastradh> Or onto a second stack.
07:12:34 <Iter> Python calls this a bound method, and I rather like that name.
07:12:35 <Riastradh> (i.e. your stack would be a two-semispace generation)
07:12:51 <Si\> shapr; yes I think Data.Generics is definately the only way to go now
07:13:21 <musasabi> ibid: well consider foreign stack segments (FFI) alogn the way too.
07:13:49 <ibid> musasabi: yeah, FFI does mess things up, but that wasn't what you claimed ;)
07:13:52 <musasabi> of course one could just wrap then in opaque blocks.
07:14:18 <musasabi> ibid: well the FFI messes things, because it makes playing around with the stack harder.
07:14:30 <ibid> musasabi: of course it does
07:15:03 <Riastradh> Only if the C stack and the Scheme stack are the same.  This isn't the case in Scheme48, although Chicken still works just fine where they are the same.
07:16:03 <Iter> shapr: as things stand, you currently either have to use reflection, or you have to assign a to a field or final-variable, and instantiate an anon-inner-class with a method with the same signature closing over the variable and pass that.
07:19:31 <Iter> anyway.  After midnight here, so I'd better head off to bed.  Night all.
07:19:34 <shapr> g'night
07:27:42 <musasabi> shapr: btw for the haskell-emacs project, have you considered making an elisp interpreter in haskell to make the transition smoother?
07:27:57 <shapr> I have considered that
07:28:13 <basti_> -?-
07:28:20 <shapr> I'm torn between that and 'making a clean break' 
07:28:31 <musasabi> shapr: but gnus...
07:28:36 <musasabi> and bbdb...
07:28:37 <musasabi> and ...
07:28:40 <shapr> I know, I know
07:28:54 <shapr> I love them too :-) except when they frustrate me viciously
07:29:31 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-13)!
07:29:37 * musasabi has some wicked ideas for a bbdb replacement with boilerplate things if the time comes sometimes...
07:30:04 <musasabi> shapr: I never got erc to be as easy to use as irssi...
07:30:17 <musasabi> modefull keybindings would help a lot...
07:30:34 <shapr> I started using ERC when delYsid and kensenata started hacking on it.
07:31:45 <shapr> I did a bunch of debugging and wrote some small parts myself
07:31:52 <shapr> modeful keybindings in ERC?
07:32:08 <musasabi> in emacs in general - a little bit like gnus...
07:32:24 <shapr> there are modeful keybindings?
07:32:50 <musasabi> not really... rather it defines simple keypresses to functions in some windows.
07:32:55 <musasabi> which is very usefull...
07:33:07 <shapr> huh?
07:33:42 <musasabi> shapr: e.g. when reading a message I can use 'r' to reply instead of C-c-<something>-r
07:33:53 <shapr> ah, I see
07:34:06 <shapr> that's more a design question
07:34:12 <shapr> having 'sub-modes'
07:34:15 <shapr> but I do agree with you.
07:35:02 <shapr> sub-mode-style design isn't really in emacs-culture, only in the small contingent that uses the CL extensions from what I've seen.
07:35:16 <musasabi> It is really frustrating e.g. when I am just browsing a document and *all* the commands I want to use are behind function keys, while all simple keypresses are not used at all.
07:35:23 <basti_> re
07:35:31 <shapr> yes, that's what view-mode and friensd are for
07:36:32 <shapr> I'm looking for some imagemagick advice, any heavy users here?
07:37:10 <shapr> hiya basti_ 
07:37:38 <musasabi> just basic imagemagic use...
07:37:46 <musasabi> sometimes I even use viper inside emacs...
07:37:49 <shapr> heh
07:38:14 <shapr> I'd like to turn a pdf into a bunch of page images
07:38:34 <shapr> and I'd like to know if I can superimpose partially transparent arrows on a page image
07:38:45 * shapr is trying to figure out how to implement the research paper wiki
07:40:31 <shapr> aha, imagemagick can create images from both .pdf and .ps
07:41:45 <musasabi> shapr: convert foo.pdf foo.png
07:42:36 <shapr> now I wonder how to anchor annotations according to both page and location around the image
07:42:57 <basti_> -?-
07:44:42 <shapr> yeesh, convert just ran over a gig of ram usage while converting
07:45:00 * shapr wonders what it's oding
07:45:42 <shapr> basti_: don't you ever want to argue withe authors of a paper?
07:46:11 <basti_> i just wonder why that has to be in form of an image or another...
07:46:59 <pesco> GWAH, How the F did they come up with these stylesheets!
07:47:25 * pesco is blindly spewing pure hatred in all directions.
07:47:54 * Riastradh wipes some hatred goop off of his shoulder.
07:48:17 <Riastradh> That stuff stings, pesco.  Cut it out.
07:48:34 <pesco> Hrmblgrmmm..
07:48:43 * Riastradh hands pesco a cookie.
07:48:58 <Riastradh> ...uh, a cookie as in the kind you eat.
07:49:06 * pesco grabs the cookie quickly.
07:49:09 <Riastradh> ...not the kind you swear at for web designers having done stupidly.
07:49:31 <shapr> basti_: because I don't know a better way to embed a pdf/ps page into a wiki page.
07:49:39 <pesco> Riastradh: Thank you.
07:50:08 <shapr> plus I'm aiming for a working prototype for user feedback anyway.
07:50:42 <musasabi> shapr: but using that will be unlawfull at least here I think...
07:50:49 <shapr> yeesh, just how much memory should convert require for a ~500MB PDF?
07:50:56 <basti_> shapr hmm i would use .latex files and let users annotate those.
07:51:21 <shapr> musasabi: neither images nor docs will come with the wiki, you only get a link so you can click and download it yourself.
07:51:25 * musasabi worked on a latex-web interface thing in 2000
07:51:34 <Riastradh> shapr, a GB, if it's converting a 500 MB PDF file to a 500 MB PNG file...
07:52:08 <shapr> musasabi: in fact, this won't be a server-based wiki at all, you have your own installation of rpwiki and everything is kept in a darcs repo so people can pull annotations.
07:52:36 <musasabi> distributed wikies are fun...
07:52:41 <shapr> and very hard to spam
07:53:08 <musasabi> but fundamentally I want something more than a wiki.
07:53:15 <shapr> only annotations are sync'd among users.
07:53:18 <shapr> like what?
07:53:42 <shapr> wow, the png files look really nice
07:53:48 <musasabi> shapr: distributed graph of suitable typed objects.
07:54:00 <shapr> well sure
07:54:11 <shapr> but I haven't finished reading Lor's paper yet.
07:54:21 <shapr> :-)
07:54:37 <shapr> tvättstuga, brb
07:55:35 <musasabi> for object types like images you would automatically create a "proxy" object of wikitext, where users can add comments.
07:56:34 <musasabi> but for adding comments and managing their rights one wants a container type instead of a raw wikipage... and when one has containers messageboards/email are just few corners around.
08:09:51 <shapr> well, if I can hack up this simple prototype in the next hour, I'll be thrilled.
08:20:37 <pesco> Oh my god, this is so unbelievably bad.
08:20:46 <shapr> ?
08:21:19 <pesco> Nothing nothing, just try not to be around when I meet anyone involved with the docbook xsl stylesheets.
08:21:29 <shapr> heh
08:21:55 <pesco>  join #docbook
08:22:03 <shapr> was that a request? :-)
08:22:11 <pesco> oops, forgot a character there... ;-)
08:35:46 <shapr> does this look usable for a prototype? http://www.scannedinavian.org/RandomWiki/ShaeErisson
08:36:06 <shapr> the idea being that you can put your annotations in any of the cells around the edges to refer to that part of the page
08:37:18 <basti_> shapr to go the graphical way, sure. I would then suggest to split the "left" and "right" sections into 3 subcells, so that you can get a finer resolution for where your annotation refers to.
08:38:05 <shapr> it's got that.
08:38:25 <basti_> oh i see
08:38:32 <basti_> it doesnt show graphically though
08:38:41 <shapr> it doesn't?
08:38:43 <basti_> with my browser that is
08:38:48 <basti_> Opera 7 foo
08:39:02 <shapr> can you save a screenshot that I can look at?
08:39:13 <basti_> yep.
08:39:14 <shapr> thanks
08:40:47 <basti_> im sending it with another client
08:40:50 <goron> shapr: Looks nice :)
08:49:15 <basti_> shapr?
08:49:32 * basti_ pokes shapr
08:50:16 <shapr> er, sorry I can't do DCC
08:50:16 <shapr> email, http, or sendfile maybe?
08:50:49 <basti_> oh
08:51:02 <basti_> http upload you mean?
08:51:15 <basti_> if not, msg me your email address
08:51:23 <shapr> you can just attach it to that wiki page :-)
08:51:28 <basti_> hehe
08:51:30 <basti_> i'll try
08:52:32 <basti_> like how?
08:52:34 <shapr> do you see the AttachFile link on that page?
08:53:13 <basti_> oh yes
08:53:51 <basti_> its now attached
08:53:56 <basti_> do i need to link it?
08:54:15 <shapr> if you want to
08:54:17 <shapr> or I can
08:54:22 <basti_> k
08:54:51 <shapr> what's the filename?
08:55:01 <goron> What's the complexity of size in Data.FiniteMap?
08:55:13 <basti_> wait i'll try :)
08:55:41 <basti_> hmm
08:55:44 <basti_> wait.
08:55:53 <shapr> attachment:foo.jpg if you uploaded foo.jpg
08:56:38 <basti_> yep but i downloaded "name with spaces" without any extension ;)
08:56:50 <shapr> ah, I see it
08:57:04 <basti_> now it works
08:57:06 <shapr> hmm
08:57:43 <basti_> what a luck that there are no embarassing html titles to be read.
08:58:16 <shapr> heh
08:58:46 <shapr> I dunno what to do about that.
08:58:58 <basti_> hmm
08:59:04 <basti_> well
08:59:07 * shapr looks at the generated source
08:59:07 <basti_> i dont too.
08:59:09 <basti_> :)
09:00:31 * shapr shrugs
09:00:35 <shapr> well, at least I know that bug exists.
09:00:49 <basti_> yep.
09:01:14 <shapr> I'll just try to make it work any at all first.
09:01:28 <basti_> k
09:01:28 <basti_> ;)
09:24:33 <musasabi> hmm why does the wiki not mention how trivial dynamic exceptions are?
09:24:42 <musasabi> or rather dynamic exception types...
09:26:41 <musasabi> would it help newbies if such a page existed?
09:26:56 <shapr> probably
09:29:16 <jpgil-cl> It does for sue!
09:29:19 <jpgil-cl> sure
09:31:27 <musasabi> ok, I'll write something up (first checking all the material that exists on Error/Either there)
09:46:24 <goron> Can somebody explain to me why I get the error that is pasted on the HaskellIRCPastePage?
09:46:45 <goron> I can load the module Map in ghci without errors.
09:47:05 <goron> The moment I import it in another module, I get errors.
09:47:39 <goron> I thought that separate modules would not interfere. 
09:47:57 <shapr> overlapping Eq intances?
09:48:03 <goron> The weird thing is that I get an error inside the Map module.
09:48:10 <goron> shapr: yes.
09:48:57 <goron> But it says there's an error in Map.hs, while loading it in ghci (on its own) gives no errors.
09:49:08 <shapr> can you compare them for equality without using toAscList ?
09:49:14 <shapr> t1 == t2 ?
09:49:17 <goron> no
09:50:21 <goron> I don't understand why it gives an error in that module. Somehow *suddently* a larger namespace is exposed.
09:50:41 <shapr> what's the module source?
09:50:57 <goron> Daan's DData->Map.hs
09:51:23 <goron> He takes complexity issues serious. He documents.
09:51:42 <shapr> I don't know why there's a custom Eq instance in Data.Graph.Inductive.Internal.RootPath
09:52:06 <shapr> um, maybe I do
09:52:23 <shapr> oh wait
09:52:55 <shapr> try "all $ map (==) $ zip (toAscList t1) (toAscList t2)"
09:52:55 <goron> shapr: I have module MyModule that imports the Graph modules and imports Map. If Map doesn't give any errors on its own and Graph also doesn't, why would it give an error when I load them both in MyModule.
09:52:58 <shapr> @type all
09:52:59 <lambdabot> all :: forall a. (a -> Bool) -> [a] -> Bool
09:53:34 * shapr isn't sure that made sense
09:53:42 <goron> shapr: Why would I do that? With the sources of Map isn't anything wrong. 
09:53:48 <shapr> um
09:53:56 <shapr> I think it's an FGL bug, sort of.
09:54:10 <shapr> there's a standard Eq instance for lists
09:54:26 <shapr> that compares all the pieces inside the list
09:54:50 <shapr> and I think whatever list you've got is also an instance of Data.Graph.Inductive.Graph.LPath
09:55:16 <shapr> an explicit type signature *might* solve the problem.
09:55:43 <jpgil-cl> @type FLG bug
09:55:44 <lambdabot> bzzt
09:55:47 <goron> Hmm, so if I make an empty module, you think there's no error?
09:55:48 * shapr grins
09:55:52 <shapr> goron: I think so
09:56:05 <shapr> that's assuming that FGL already requires -fallow-overlapping-instances all by itself.
09:56:07 <goron> shapr: Thanks for you logic. I think it's correct :)
09:56:11 <shapr> which I think is true
09:56:33 * goron is gonna test your theorie.
09:56:36 * goron is gonna test your theory.
09:57:02 <shapr> I think it'll work if you give a carefully thought out type signature for the (k,a) in your list of tuples.
09:57:24 <jpgil-cl> in the meanwhile...  What FGL stands for ?
09:57:27 <shapr> but I've never gotten around to learning how to get GHC to prefer one instance over another when some overlap
09:57:31 <shapr> Functional Graph Library
09:57:34 <jpgil-cl> Thx!
09:57:45 <shapr> greetings oh bright one, Mr. noclouds.
09:58:28 <jpgil-cl> Mm, as bright as a sudden flash of light
09:58:36 <shapr> yup
09:58:50 <goron> shapr: I think my compile script wsa broken...
09:58:57 <goron> wsa->was
09:59:10 <shapr> compile script?
09:59:27 <goron> shapr: So now I am able to load Map (with a *shitload* of warnings).
09:59:38 <shapr> that's an improvement.
09:59:49 <goron> shapr: I have a lot of options that I need to give to ghci.
09:59:56 <musasabi> http://www.haskell.org/hawiki/DynamicErrors
10:00:28 <musasabi> (please check it - I might have made some mistakes and my english leaves certainly much to wish)
10:00:44 <goron> shapr: You also was thinking about avoiding spam on the wiki lately, I have an idea. 
10:01:40 <goron> shapr: You could follow the link that people add, and check for certain words, or you could search Google and look whether it has *anything* to do with functional programming.
10:06:07 <shapr> hm, neat idea
10:06:34 <jpgil-cl> regarding spam... why not just ask to HaWiki users to verify and delete spam?
10:07:25 <jpgil-cl> ufff.. boss alarm
10:07:26 <shapr> musasabi: looks nice to me
10:07:41 <shapr> heya stepcut 
10:08:09 <goron> shapr: Do you know curl? You could use that *very* easily..
10:08:36 <shapr> I do not know much about curl, but I have looked at the code that darcs uses to wrap curl
10:09:02 <shapr> goron: I think your bayesian wiki-spam filter is an excellent idea.
10:09:13 <shapr> mind if I pass that on to the MoinMoin developers?
10:09:41 * shapr used to be a MoinMoin developer, but never actually got around to writing any code for it, and was kicked off the sf.net project :-)
10:10:16 <shapr> I have lots of enthusiasm and energy, but very little focus or consistency.
10:10:40 <shapr> speaking of which, I'm off to unicycle and think about this rpwiki 
10:10:45 * shapr wobbles away
10:47:04 * basti_ and his girlfriend had fish today.
10:47:20 <basti_> -slurp-
10:48:23 <stepcut> that sounds dirty
10:48:37 <basti_> not the way YOU think.
11:03:03 <pesco> There . We . Go !
11:07:05 <basti_> where? here?
11:07:14 <Riastradh> No, there.
11:07:54 <pesco> http://www-sop.inria.fr/mimosa/fp/Scribe
11:08:47 <musasabi> shapr: that sounds familiar... (and thanks for looking at the page)
11:26:10 * shapr luvs unicycling
11:30:50 <pesco> shapr: Why is it so much fun? Is it more fun than riding a skateboard?
11:30:55 <shapr> yes, much more fun.
11:31:20 * shapr thinks about why
11:32:38 <shapr> Skateboards are about momentum and some balance, unicycles are all about balance and focus.
11:32:55 <shapr> I think the focus part is the real fun with unicycles.
11:33:41 <shapr> Especially on terrain like old pavement where it's cracked, squished and unpredictable.
11:35:05 * pesco nods
11:35:53 <shapr> Even with small rises and drops and cracks, you still get the rush of a halfpipe with a skateboard.
11:36:45 <shapr> pesco: oh, I know how to show you, I can direct you to some of the unicycle home videos
11:37:39 <goron> shapr: Using DData I *finally* got a mega elegant solution. 
11:37:44 <shapr> people ride their unicycles on stair railings about two fingers wide, or jump up onto picnic tables, or jump around on the metal and concrete stuff at a building site
11:38:17 <musasabi> goron: please post it somewhere.
11:38:18 <shapr> I hope to work up to being able to ride on a railroad rail for some distance.
11:38:40 <Riastradh> Preferrably not while there is a train on that segment of rail, I presume.
11:38:49 <shapr> hopefully not.
11:38:55 <Riastradh> Although that might add a bit of adrenaline & excitement.
11:39:01 <shapr> possibly even too much.
11:39:16 <shapr> speaking of which, have you heard of urban surfing?
11:39:54 <Riastradh> Not I.
11:40:07 <shapr> people take trains/subways/etc and climb on top of them to 'surf' on the roof. It's very dangerous.
11:40:17 <goron> musasabi: finitemap = foldr (\k f->Map.adjust (\x->[node]++x) k f) fm keysToMake
11:40:41 <goron> musasabi: This is the most important part
11:44:05 <pesco> shapr: Haha, "S-Bahn" surfing is what I used to hear about as _the_ bad thing crazy youngsters would do when I was a kid. It was about as scary as anarchy. (S-Bahn: german commuter rail)
11:46:25 * shapr finds a tandem unicycle
11:46:36 <shapr> this must be a Dr. Seuss inspiration.
11:47:28 <arauko> jpgil-cl, saludo a chile 
11:47:45 <jpgil-cl> Salud, señor Araujo.
11:47:54 * jpgil-cl translates: greetings to all
11:47:57 <arauko> :-)
11:48:12 * pesco greets.
11:48:17 * shapr y0s
11:48:27 <basti_> anybody speak l33t?
11:48:46 <shapr> n0 w4y
11:48:50 <shapr> y4 n00b
11:48:51 * pesco s4luts0rz
11:48:59 <basti_> h3h3
11:49:04 <pesco> OK, enough!
11:49:05 <basti_> k3wl
11:49:07 <shapr> I've been called a noob more often in the last few days than ever before.
11:49:13 <jpgil-cl> I'm n0t 4 g33k!
11:49:14 <basti_> how that?
11:49:20 <pesco> Ha, what were you playing?!
11:49:27 <shapr> the free game, "America's Army"
11:49:33 <basti_> uh
11:49:34 <pesco> Ah, right.
11:49:37 <shapr> how did you know I was playing an online game? :_)
11:49:43 * shapr grins
11:49:45 * basti_ abstains from that
11:49:49 * pesco whistles a tune.
11:50:17 <shapr> It's a nice lesson for #haskell though, I think.
11:50:26 <basti_> uhm
11:50:35 <shapr> If you insult and anger your teammates, they're not likely to help you.
11:50:43 <shapr> #haskell is really friendly, I like that.
11:50:47 <pesco> Yes.
11:50:48 <shapr> no one ever calls me a noob.
11:50:51 <shapr> :-)
11:50:59 <pesco> lol
11:50:59 <basti_> ;)
11:51:41 <shapr> so, enthusiastic willingness to help can be an infectious attitude just as much as anger and frustration.
11:52:11 <pesco> *G*
11:52:30 <shapr> ok, now to implement the inspirations I had while unicycling.
11:52:45 <basti_> i always get inspired while showering
11:52:54 <Riastradh> Is 'America's Army' any good, shapr?
11:53:12 <shapr> Riastradh: yah, it has some really fun parts, and some really irritating parts.
11:53:28 <pesco> No, America's army is a bunch of noobs. ;-)
11:53:33 * shapr laughs
11:54:35 <shapr> Riastradh: the most irritating part is called 'spam' where some people have played a map so much that they know where and when players on the other side will be somewhere, so they fire grenades or machine guns and kill you from a long distance when there's no way they could see you.
11:55:35 <shapr> grenade spam, automatic rifle spam, and sniper spam; it's worst when the round starts, and m203 grenades kill half your team seconds later.
11:55:58 <Riastradh> Boy, their web page is stunning: <http://www.bloodandcoffee.net/campbell/images/aa-webpage.png>
11:56:17 <shapr> hej andersca
11:56:25 <shapr> Riastradh: at least you can see the flash :-P
11:56:31 <andersca> hej
11:57:25 <shapr> uukuujoeuiu
11:57:35 <shapr> bea types dvorak...
11:57:40 <Riastradh> Bloody Flash.
11:58:38 <pesco> Hi Bea.
11:59:13 <shapr> ukuuuyyy
11:59:30 * shapr won't even try to translate
11:59:48 <shapr> she claims it's japanese.
12:00:15 <pesco> I know what it is. I have the same keyboard as you, shapr. ;-P
12:01:00 <pesco> Anyway, welcome to #haskell, Bea! Feel free to press the keys as printed, I'll be able to translate. :P
12:01:01 <shapr> bea uses qwerty, and my keycaps are qwerty, but I use a modified dvorak layout.
12:01:08 * shapr grins
12:01:22 <andersca> I use qwerty
12:01:34 * basti_ too
12:01:42 * Riastradh too
12:02:01 <basti_> heard dvorak isnt worth the effort.
12:02:13 * pesco thinks it is.
12:02:20 <shapr> I actually don't want to use any set layout at all. I'd rather have something like electronic velcro that I can stick onto styrofoam shapes of my choice and put the keys anywhere I want
12:02:40 <goron> Anyone with a clue of how to copy something from Xterm?
12:02:47 <basti_> just mark it
12:02:50 <basti_> left button
12:02:57 <goron> basti_: That doesn't work. 
12:02:57 <basti_> it does a "copy" on button release
12:03:06 <shapr> goron: drag across it with the left button held down, then middle click over something else
12:03:07 <basti_> it doesnt mark but it does copy
12:03:23 <pesco> I had a friend here some days ago, who half-touchtypes querty. She sat at my keyboard for a while, guessing the keys to type stuff into the webbrowser etc.
12:03:30 <shapr> pesco: neat!
12:03:45 <shapr> most people aren't willing to make the effort.
12:03:56 <goron> 21:01 < andersca> I use qwerty
12:03:56 <goron> 21:01  * basti_ too
12:03:56 <goron> 21:01  * Riastradh too
12:04:04 <Riastradh> Yup, that worked, goron!
12:04:11 <goron> Well, it only works in Xterm
12:04:15 <shapr> huh?
12:04:23 <Riastradh> You expect integration in X11?
12:04:34 <goron> I want to copy something to FireFox.
12:04:36 <shapr> goron: oh, it may not work with anything outside of latin-1
12:04:41 <pesco> She picked up the key positions very quickly and said they felt very natural.
12:04:59 <pesco> I had explained to her, that the most used keys are on the home row and all vowels on the left.
12:05:27 <goron> It's just FireFox that's sucking...
12:05:49 <goron> I had a segfault yesterday with FireFox... 
12:06:03 <shapr> wow
12:06:19 <goron> When will mankind create something that doesn't suck? (except for Haskell)
12:06:27 <shapr> well, Haskell isn't perfect either.
12:06:30 <shapr> it sure is nifty though.
12:06:40 <pesco> My regular suckage is Firefox seemingly forgetting to hook handlers to popup dialogs' OK or Cancel buttons.
12:06:56 <goron> It's not perfect. But it doesn't suck.
12:06:58 <jpgil-cl> goron, you've to try MS IEplorer to get really sad for humankind.
12:07:04 <shapr> goron: yah, agreed.
12:07:41 <shapr> The one thing I hate about MS and Windows is that they try to keep people in the ignorant computer savage category.
12:07:47 <goron> jpgil-cl: I tried for years, and I still dual-boot for my family, but I had it crashing(the GUI that is) a couple of times. 
12:08:42 <shapr> I wish they instead spent their money divining the essential difficulties of computer use and tried to write powerful systems that were easy to incrementally learn.
12:08:55 * shapr shrugs
12:08:56 <goron> The thing I hate in the Linux software community, is that it sucks way too often. I would like to have a list of software that hasn't borked for like +1 year.
12:09:51 <thebug> goron: that sort of depends on what you're looking for from OSS apps, and how new they -have- to be...there's plenty of stable, usable OSS
12:09:53 <shapr> I think the Linux software community would improve if they followed the ideas that Iter mentioned earlier today.
12:10:12 <pesco> What did he say?
12:11:07 <pesco> I'll just look it up in the logs.
12:11:28 <shapr> http://etymon.blogspot.com/2004/08/why-java-sucks.html
12:11:42 <shapr> it's the Alan Kay quote "What to do until software engineering is invented... do late binding, which means being able to make the changes easily."
12:12:04 * arauko goes and read
12:12:22 <tic> FF still sucks less than IE
12:12:47 * shapr agrees
12:13:39 <goron> Although IE is full of holes, it hasn't crashed a single time. 
12:13:52 <shapr> it sure has crashed for me
12:14:11 <goron> But I must admit I didn't use it that much.
12:14:11 <shapr> and I've only used it for a few minutes since 4.0
12:14:31 <basti_> uhm.
12:14:56 * goron will read the logs...
12:15:17 <shapr> anyway, I like Paul Snively's intepretation "get out of these tools that do neither software engineering nor dynamic change well (C, C++, Java...) and either head for software engineering (SML, O'Caml, Haskell, Concurrent Clean, Epigram, Alice...) or head for late binding (Common Lisp, Scheme, Smalltalk, Oz...)"
12:16:11 <shapr> I totally agree with that.
12:16:36 <basti_> oz rules.
12:18:47 <goron> FSF GNU software is normally rock-solid, imo. 
12:33:51 <goron> I don't really get why late-binding is bad. 
12:34:23 <shapr> sometimes you don't find errors until runtime explodes.
12:34:30 <shapr> that happens to me often with Zope
12:35:06 <goron> But that's not a reason to say late binding is bad. It's just a bad programmer. 
12:35:16 <Riastradh> The idea is that the run-time shouldn't _explode_ but wait nicely for you to fix it and easily proceed.
12:35:21 <Smerdyakov> Late binding generally requires more complicated reasoning to understand.
12:35:28 <Smerdyakov> That's why I like to avoid it.
12:35:40 <basti_> i just observe that late binding gives usually programs that are better understandeable
12:35:49 <shapr> I've never been much of a fan of static typing myself.
12:35:51 <Smerdyakov> basti_, example?
12:35:57 <shapr> but Haskell makes static typing worthwhile.
12:36:07 <basti_> hmm i mean, like, python programs
12:36:19 <Riastradh> Smerdyakov, would you still refuse to use a late-binding language in long, continuous, concurrent distributed applications, like what Erlang is used for/
12:36:22 <Riastradh> ?
12:36:23 <shapr> Late binding is a great thing in Python.
12:36:23 <Smerdyakov> basti_, what are you saying? You think Python is inherently more understandable than Haskell?
12:36:32 <basti_> no.
12:36:42 <Smerdyakov> Riastradh, I think I would go for restricted, explicit swapping of components.
12:36:51 <shapr> I don't think one is more understandable than the other, they just have different approaches.
12:37:00 <basti_> i just think for practical purposes it makes a quick way of doing things right.
12:37:19 <basti_> functional programming does too, sure
12:37:28 <Smerdyakov> shapr, I think it's obvious that a formalization of late-binding execution is more complicated, and that's what you have to use internally to reason about such programs.
12:37:47 <basti_> hmm
12:37:58 <shapr> er, huh?
12:38:14 <shapr> why would I need to formalize late-binding execution to reason about a Python program?
12:38:37 <shapr> in many cases, the extreme late-binding nature of Python makes things very much simpler.
12:38:47 <shapr> because *everything* happens at runtime in Python
12:39:04 <shapr> it's a lot like building a Smalltalk image from boot-time on up.
12:39:29 <Smerdyakov> shapr, certain things are simpler, but reasoning about complicated correctness properties is harder.
12:40:06 <shapr> That may be true, but with unit tests it's likely you can quickly get reliable code with Python.
12:40:21 <Smerdyakov> That doesn't mean that writing unit tests isn't a waste of time.
12:40:42 <basti_> sure you would have to employ things like hoare calculus.
12:40:42 <shapr> hiya nephtis, looking for Haskell info?
12:40:47 <Riastradh> Repeatedly recompiling & regenerating theorems about the program may be considered by some a waste of time as well, Smerdyakov.
12:41:17 <goron> Smerdyakov: Are there any Haskell theorem provers?
12:41:32 <basti_> goron coq?
12:41:39 <Riastradh> That would be OCaml.
12:41:47 <Smerdyakov> goron, what do you mean?
12:41:51 <shapr> In my experience, both approaches have their good points. I think it's best to know enough about both to know when to use them.
12:41:55 <basti_> but it can do haskell as well
12:42:24 <Smerdyakov> Riastradh, nonethless, it is impossible to write correct programs without doing that.
12:42:35 <goron> Smerdyakov: Well, what I understand of \-calculus is that you can prove that two expressions are equal to each other. I want to do exactly that. 
12:42:42 <Riastradh> Smerdyakov, no, certainly not.
12:42:53 <shapr> type systems are essentially simplified automatic proof systems, hopefully someday they'll be simple and powerful enough to be used by people who do not have to understand the entire system first.
12:43:09 <Riastradh> It is absolutely preposterous of you to use the word 'impossible,' Smerdyakov.
12:43:33 <Smerdyakov> goron, you can formalize that in any good logic system, including Coq.
12:44:01 <shapr> In the real world, good results for the least amount of cost are most important, not 100% program correctness.
12:44:02 <Smerdyakov> goron, I don't know if someone has written a nice translational of Haskell code into denotational semantics, but that would make the job pretty easy.
12:44:19 <Smerdyakov> Riastradh, well, prove me wrong. How can you make a working program if you don't understand it?
12:44:45 <goron> Smerdyakov: Well, that's essentially something I would be *very* interested in. 
12:44:45 <Riastradh> What does that have to do with what I said some may argue wasted time, Smerdyakov?
12:44:58 <Smerdyakov> Riastradh, it's not wasted because it's unavoidable.
12:45:14 <Riastradh> Smerdyakov, that doesn't answer my question.
12:45:18 <Smerdyakov> goron, it's an easy exercise to implement the translation yourself, if all fails. Coq's underlying language is basically a subset of Haskell.
12:45:38 <Riastradh> I wasn't asking about what you thought was a waste of time.  I was asking about how understanding the program has anything to do with automated compilation and theorem generation of programs.
12:45:51 <shapr> Anyway, Haskell code often needs software tests just as much as Python code.
12:46:03 <Smerdyakov> Riastradh, I'm talking about informal, manual, in-your-head reasoning, not machine automated anything.
12:46:27 <goron> Smerdyakov: Well, ok, I will put some time in it, I have had some true logic education (I only hope they have some pretty good documentation). Thanks :)
12:46:29 <shapr> If you guys haven't read the "Why are type systems interesting?" threads on lambda-the-ultimate.org, they're related to this discussion.
12:46:32 <Riastradh> Smerdyakov, and I'm talking about the automated theorem generation and recompilation that you were talking about several days ago.
12:46:38 <Smerdyakov> goron, you can also translate manually and take your own word for it that you have represented Haskell faithfully.
12:47:03 <Riastradh> Smerdyakov, yet another example of where you completely distort a discussion just to come to conclusions you want to come to, regardless of their relevance to the original statements.
12:47:03 <Smerdyakov> Riastradh, and I'm not. :)
12:47:16 <Smerdyakov> Riastradh, I love you, too!
12:47:43 <shapr> For maintenance programming of deployed software, it's rarely cost-effective to understand the entire program before fixing a bug.
12:48:28 <shapr> There's a balance needed between refactoring and 'understandable chunks'.
12:48:34 <Smerdyakov> shapr, unless you planned ahead with suitable specifications.
12:48:45 <shapr> that's impossible.
12:49:02 <Smerdyakov> shapr, it's impossible to have specified enough of the program in advanced to avoid the need to reason about that part while upgrading?
12:49:08 <Riastradh> Yes, let's plan _EVERYTHING_ we'll ever write ahead!
12:49:09 <shapr> Yes.
12:49:13 <Smerdyakov> shammah, that's ridiculous.
12:49:18 <Smerdyakov> shapr, "
12:49:21 <shapr> no, it's true.
12:49:24 <goron> Smerdyakov: Is there anything you created that we can see? I would like to see some quality software.
12:49:54 <pesco> Smerdyakov: You are aware of the fact that the viability of Big Design Up Front is not at all certain?
12:50:05 <shapr> From what I've seen, the only way to do good software design is to do it at implementation time.
12:50:06 <Smerdyakov> shapr, for instance, if you re-implement finite maps, but both implementations are hidden behind a specification that fully explains their behavior, there is no need to worry.
12:50:21 <Smerdyakov> goron, my home page is at http://www.schizomaniac.net/ .
12:50:51 <shapr> I do not believe it's possible to separate specification and implementation of software.
12:51:04 <Smerdyakov> shapr, types show up at implementation time. Types are a kind of specification.
12:51:06 <shapr> First of all, in the real world, specifications change like socks.
12:51:40 <Smerdyakov> Indeed, which is why it is all the more important to have a formal model of specifications and an automated way of checking when changes cause them to be violated.
12:51:50 <shapr> Second of all, no design is perfect, you often see a better way to do a part of the design during implementation.
12:52:59 <Smerdyakov> You are missing the point: the fact that we don't know what we are doing until we get there is an argument _in_favor_ of specifications, as a facility for managing the effects of changes.
12:53:04 <shapr> Sure, formal models are great, I've decided I really like Haskell and it's HM typesystem.
12:53:16 <shapr> That's not true.
12:53:37 <Smerdyakov> It's sure been true in my experience.
12:53:50 <Smerdyakov> Change the type of a function, and now you can be shown everything else that needs to be refactored.
12:53:51 <shapr> Unless you take something like user stories and customer tests as specifications.
12:53:53 <Smerdyakov> No chance of mistakes.
12:54:29 <shapr> And those change too, so...
12:54:39 <Smerdyakov> Oh puh-lease. I'm not off in that wishy-washy world of software engineering talk therapy. I'm talking only about formal specifications.
12:54:55 <Smerdyakov> Those change, too, and anything invalidated by those changes will also be marked for you, and so on.
12:55:50 <shapr> In the real world of writing software, specifications are usually a waste of time and money.
12:56:14 <shapr> Most of the time, the customers don't know what they want until you don't give it to them.
12:56:33 <Smerdyakov> I'm not on that level.
12:56:38 <shapr> Especially in cases like that, languages like Python are very powerful.
12:56:42 <Smerdyakov> I'm talking about very low-level specifications.
12:56:55 <Smerdyakov> Specifications of artifacts that "customers" don't care about.
12:58:04 <esap> Specifications are useful even if you wouldn't have any customers.
12:58:05 <shapr> If I can't use a system to help me model customer requirements, what good is it?
12:58:33 <Smerdyakov> Ha.
12:58:47 <Smerdyakov> Like customers know know or want to know anything about the true engineering properties of a system.
12:59:00 <Smerdyakov> Nonetheless, should these properties not be up to snuff, they'll be a bit peeved.
12:59:57 <Smerdyakov> I have a feeling that the ython work that you do is on quite simple systems, where comparatively few details are both invisible to the customers and complicated enough that you can't tell they're correct at a glance.
13:00:05 <esap> Customer's are like that. They expect you to know what their requirements are, and then build the system according to that specification.
13:00:32 <shapr> Smerdyakov: check out Plone and Zope from Plone.org and Zope.org
13:01:57 <shapr> I believe that anything that helps me improve my speed of change is beneficial.
13:02:28 <Smerdyakov> shammah, what was the relevance of that? Are you agreeing with me, because these tools do most of the work for you?
13:02:38 <Smerdyakov> shapr, "
13:02:40 <esap> speed of change smells like OO.
13:02:44 <shapr> So, Python without unit tests is great for quick prototypes that may have hidden bugs, it's also great for throwaway scripts that get 95% of the work done where you can do the rest by hand.
13:03:20 <shapr> Haskell is good for separation of effects, and for highly concatenative systems, and (I could go on a long time here).
13:03:26 <Smerdyakov> esap, speed of change is almost always one of the most important factors.
13:03:37 <shapr> Smerdyakov: no, I'm saying your feeling is wrong.
13:04:01 <Smerdyakov> shapr, how did what you say give any information that should convince me of that?
13:04:20 <esap> smerdyakov: well sometimes. But it's hardlt ever the only important factor.
13:04:25 <shapr> so that you can find out for yourself if you really want to know.
13:04:45 <Smerdyakov> shapr, I've used Zope, and I don't see the fact that it exists having any relevance here.
13:04:48 <esap> smerdyakov: And often performance is more important.
13:05:16 <shapr> Smerdyakov: do you consider Plone + Zope a simple system?
13:05:30 <Smerdyakov> shapr, a tiny bit above simplicity.
13:05:34 <shapr> heh
13:06:19 <Smerdyakov> It's hard for me to explain exactly what I mean, but Zope has very little that is algorithmically complicated going on.
13:06:40 <shapr> I disagree.
13:07:31 <pesco> Smerdyakov: Could you _please_ stop being such a big-mouth?
13:07:37 <Smerdyakov> pesco, elaborate?
13:07:49 <shapr> Anyway, I don't think I'll be able to affect your opinion, I think you should get a part time job in the real commercial software industry and see what you think.
13:07:57 <pesco> Read your last 20 posts. Think. Then continue talking.
13:08:11 <Smerdyakov> pesco, I don't see a problem with my last 20 posts.
13:10:10 * XTL yawns
13:10:19 <shapr> hei XTL 
13:10:35 * XTL waves and tries to stay on the chair
13:10:36 <shapr> wassup?
13:10:42 <shapr> written any cool code lately?
13:11:04 <XTL> No. I've been spending most of my time organizing the move to Oulu.
13:11:11 <shapr> whee, fun
13:11:25 <shapr> I'll be able to drop by and have a beer with you then :-)
13:11:40 <shapr> well, sake for me.
13:12:00 <XTL> :)
13:12:25 <shapr> oh, I'm moving two blocks over into another apartment.
13:12:35 <pesco> Smerdyakov: Let me give you an example. The latest one. You were having a feeling that the Python work of shapr was so simple, that comparatively few details are both invisible to the customers and complicated enough that one couldn't tell they were correct at a glance.
13:13:21 <pesco> In other words, your claim is that Zope for instance does not contain anything in its core for which there would be the need for any kind of testing beyond "a glance".
13:14:31 <pesco> Which is to say, that had you been the programmer and designer of all that, there had been no bugs, no tests, no nothing, because it's all so algorithmically simple.
13:15:42 <pesco> The truth is, that you are wrong. But you are constantly degrading things and others' comments to a supposed triviality, which is insulting.
13:15:45 <shapr> esap: In my estimation, speed of change is the most important factor in commercial programming. Per-hour costs of programmer time are so much higher than that of hardware that it's often cheaper to spend six hours writing an terribly inefficient program and just run it on a quad Opteron
13:15:46 <pesco> Thus my remark.
13:16:36 <esap> shapr: you're right for basically everything except real-time systems, where being too slow is same as a fatal bug.
13:17:04 <shapr> esap: I think performance is the most important for consumer software products like games, etc because half the computers out there are below average :-)
13:17:15 <shapr> esap: oh, excellent point
13:17:40 <shapr> that's a case where execution speed is part of the actual result.
13:19:18 * XTL munches pizza and thinks about some Java servlets that he saw that raised machine loads up to eighty and had to be restarted every few hours
13:20:47 <esap> shapr: Actually, I guess there is always a niche where every small property of programs becomes important. I wonder how many of those still have programmer efficiency as the most important factor. Might be very many.
13:21:27 <shapr> A 4-cpu opteron is roughly 6000 euro, at 50 euro an hour that's 120 hours, or roughly 3 weeks of programmer time.
13:22:14 <XTL> shapr: http://irc-galleria.net/view.php?nick=XTL&image_id=3430785&navi=true We briefly visited Estonia a while ago BTW now that it's still so easy
13:22:34 <shapr> XTL: you look great in that suit :-)
13:22:45 <esap> Yea, hardware is almost never the biggest cost. Usually it's either programmers, or how to get the system to its correct user [if he happens to be in a spaceship circling the earth for example :-)]
13:23:12 <XTL> shapr: It's just random things picked up actually :)  
13:23:48 <shapr> In my opinion, that sort of cost calculation is why Haskell is a better commercial programming language than C or C++.
13:24:13 * goron can't take the silence. Was this a record? shapr: Another feature for your bot. :) 
13:24:24 <shapr> goron: record what?
13:25:11 <esap> shapr: True. I guess there is one thing that might have some effect in some areas: space efficiency. It's pretty hard to control space usage in Haskell (I think that's at least partially due to GC).
13:25:37 * pesco puts on some KMFDM.
13:25:40 <shapr> Yes, that's the hardest problem in Haskell I think.
13:26:05 <XTL> shapr: Do you think "cheap" Haskell-wielding programmers could be available?
13:26:05 <shapr> I dearly wish optimistic Haskell had been kept in the main branch of GHC.
13:26:10 <esap> shapr: I mean, GC is a simulation of infinite memory. If you have infinite memory, then you are by default not being very careful about space usage.
13:26:19 <goron> shapr: I was waiting to a reply, but it was just my irc-client that didn't show the new messages, until I hit the "Page Down" button. :)
13:26:29 <XTL> Or perhaps that only programmers that are able to adapt are ones worth having
13:26:48 <shapr> XTL: sure! if they do contract work. I did an XML transform program in three days in Haskell that a JavaScrip / XSLT guy gave up on after costing a month of work.
13:26:58 <pesco> goron: Haha. :)
13:27:07 <shapr> goron: heh :-)
13:28:26 <shapr> XTL: I think the secret is to find what works for you, what makes you most efficient and productive, and then keep trying to improve that in your spare time, while using what you know works for you for paying work.
13:29:25 <shapr> esap: maybe it's about 'space complexity'
13:30:01 <XTL> shapr: I was just wondering trying to imagine if the programmers I've seen could. Then again, I can't say what the big hurdle would be. Maybe it's just somehow a hard thing to see.
13:30:16 <esap> shapr: I'm not quite sure what you mean. Space complexity vs. space usage?
13:30:21 <shapr> space complexity (the dual to algorithmic complexity?) usually only varies by manageable amounts in most languages.
13:30:35 <shapr> in Haskell your 'space complexity' can get way way out of hand.
13:31:07 <esap> shapr: Right. I was actually thinking about dualizing GC and getting a scheduler :-)
13:31:27 <esap> shapr: that would be a simulation of infinite time :-)
13:32:09 <shapr> I wrote a bayesian spam filter in Haskell, and it ended up trying to read several hundred megabytes of email into memory all at the same time. It ate my ram and swap space in just a few seconds.
13:32:22 <esap> hehe
13:32:43 <kuz> Javadoc did the same thing when I built Eclipse.
13:32:45 <shapr> Darius added one $! in the right place and then it worked just fine in about 30m of memory.
13:33:57 <kuz> It's good to know what you're potentially telling a computer to do when you write something.
13:33:59 <shapr> I'm still not convinced that strict languages are inherently better or more efficient, but they are easier to reason about.
13:34:26 <shapr> Yah, but ...
13:35:17 <shapr> I think there's always a tradeoff between predictability and optimization.
13:35:26 <Riastradh> I'd say the easiest languages to reason about are those that the compiler gets the most say in what happens; that is, neither a lazy nor a strict language, but a language in which the compiler can decide when things are evaluated.
13:35:30 <esap> shapr: I think strict languages aren't inherently better, they're just better suited for optimizing space usage. For performance, the Haskell approach has better control.
13:35:48 <shapr> esap: oh, I think you totally got it.
13:35:51 * shapr writes that down.
13:36:26 <shapr> Okasaki's amortized algorithms support that conclusion.
13:36:30 <goron> Haskell can be strict, so what are we talking about?
13:36:34 <esap> riastradh: I wouldn't let compiler's make such decisions. You must give the choice to the programmer.
13:37:11 <shapr> goron: default behaviour can make a big difference.
13:37:28 <Riastradh> Hmmmm.  It now occurs to me that what I said was rather obvious and tautological.
13:38:09 <shapr> with an ML flavor, I wouldn't have run out of memory with my spam filter, but I also wouldn't have been able to get word scores from the dictionary without reading every email (at least, not the way my code was structured)
13:39:27 <shapr> esap: hey, maybe epigram and its children will come up with some way to encode space complexity in the type system, so that you'll know just how insane your program could possibly be.
13:39:56 * esap hasn't looked at epigram. I think I should do that...
13:40:06 <shapr> I think you'll like it.
13:41:43 <goron> shapr: But ghc could easily be instructed to be strict, I think, only you should code a bit different, but not much. 
13:41:50 <shapr> Riastradh: maybe the point is to allow the programmer to be able to reason about code concatenatively?
13:42:02 <shapr> goron: it's been done
13:42:08 <shapr> in two flavors
13:42:35 <shapr> there was Strict Haskell (Jan Willem-Maessan maybe?) and Optimistic Haskell (Robert Ennals and SPJ)
13:42:56 <shapr> Optimistic Haskell was *awesome*. I want it back.
13:43:04 <arjanb> strict languages make it easier to write space efficient programs and lazy languages time efficient program but combining both makes it harder to reason about the program
13:43:05 <goron> shapr: But they are dead?
13:43:20 <Riastradh> What's optimistic Haskell?
13:43:39 <esap> arjanb: True. But I think it's worth the price.
13:43:42 <shapr> goron: Strict Haskell isn't used that I know of, and Optimistic Haskell was a fork of 5.04.2 (I think) that required major internal changes to GHC
13:43:52 <shapr> I asked Robert Ennals and Simon Marlow about it, and they said
13:44:43 <shapr> Robert Ennals said he's been hired by Intel Research and has given up on lazy languages, and Simon Marlow said if I wanted to port the changes from 5.04.2 up to 6.3 he'd be happy to put them into the main branch.
13:44:52 <shapr> They both said it would a *lot* of work.
13:45:26 <shapr> On the nifty side, Optimistic Haskell had a real debugger that worked!
13:46:10 <XTL> Sounds handy
13:46:25 <Riastradh> shapr, what's optimistic Haskell?
13:46:44 <shapr> It was a fork of GHC that did speculative evaluation internally.
13:46:50 <goron> If I add everywhere strictness flags, why isn't it equivalent to Optimistic Haskell?
13:47:01 <goron> Ow ok
13:47:21 <jesse99> was it eager or parallel evaluation shapr?
13:47:38 <shapr> It was eager, mostly.
13:47:48 <jesse99> some was parallel?
13:47:51 <shapr> It wouldn't speculate past anything dangerous.
13:47:57 * arjanb can't think of any language that has more than one default evaluation strategy
13:48:12 <shapr> like, not past any IO actions, not past any of the unsafe guys, etc
13:48:52 <shapr> On the good side, that meant that humans could actually understand a dump of its internal state, that's why it had a debugger.
13:50:04 * esap just read epigram's paper that says epigram has two-dimensional syntax. aargh :-)
13:50:10 <shapr> jesse99: there are a few different parallel/distributed forks of GHC, but nothing really killer.
13:50:42 <shapr> Well, Manuel Chakravarty's Nested Data Parallelism stuff is really killer.
13:50:54 <jesse99> seems like an iffy thing, maybe if you couple it with runtime profiling...
13:52:20 <goron> I think it would be possible to calculate whether it's worth the trouble to start a thread for some partial expression for complete programs. I really don't see why that would be hard. 
13:52:28 <shapr> there's an ICFP03 paper on Optimistic Haskell that's worth reading.
13:52:54 <shapr> hej cm
13:53:43 <shapr> hej d-bug 
13:54:01 <shapr> I wonder if anyone has tried to fit shapely types into Haskell.
13:54:01 <d-bug> hemskt mycket hej
13:54:19 <jesse99> statically determining the computational expense seems like a hard problem, especially if you support separate compilation of modules
13:54:34 <jesse99> s/expense/expense of expressions
13:54:53 <shapr> you could probably end up with complexity info at least.
13:54:57 <shapr> hi karingo 
13:55:40 <shapr> maybe?
13:55:41 * shapr isn't sure
13:57:45 <arjanb> ideally you want a language\compiler where you can give a space\time tradeoff for the generated code
13:58:30 <goron> infixl 0 (#) 
13:58:38 <goron> This is in PreludeExts on the Wiki
13:58:46 <shapr> ?
13:58:49 <goron> ghc doesn't swallow it. 
13:58:54 <shapr> what does it say?
13:59:05 <goron> PreludeExts.hs:758:9: parse error on input `('
13:59:18 <shapr> that sounds like an error on an earlier line.
13:59:21 <shapr> maybe
13:59:25 <shapr> oh wait
13:59:33 <shapr> maybe put spaces inside the parens?
13:59:54 <shapr> it might think the # is referring to an unboxed something.
13:59:58 <goron> nope
14:01:25 <goron> TheHunter wrote it. 
14:01:52 <goron> Why don't we have an infinite number of precedence levels? Even I got that in my education. 
14:02:07 * shapr dunno
14:03:51 <Igloo> Computer scientists can only count to 10. And that's on a good day.
14:04:54 <shapr> There are only 10 types of the people in the world. Those who understand binary...
14:05:13 <goron> shapr: You also could add a check on proper haskell code in the wiki. Maybe some special syntax. PreludeExts should be something that one could cut-and-paste. 
14:05:18 * esap does like epigram.
14:05:33 <goron> join #epigram lol
14:05:52 * esap did.
14:08:54 <shapr> goron: yah, I agree
14:09:13 <basti_> epigram is a great idea.
14:09:39 * shapr agrees
14:10:07 <basti_> and, i did see the gap, but i never could put my finger on it
14:11:07 <shapr> bonjour Boegel 
14:11:12 <shapr> comment Ã§a va?
14:11:17 <Boegel> hello shapr
14:11:26 <Boegel> en ik spreek niet zo goed frans :p
14:11:32 <Boegel> bien ;)
14:11:35 <shapr> heh, ok :-)
14:12:12 <Boegel> I'm still tring to figure out the last dynamic example from the FranTk manual
14:12:24 <shapr> what's it look like?
14:12:24 <goron> shapr: You should keep your dictionary of people->language associtions more consistent ;) 
14:12:34 <Boegel> I'm beginning to realise how hard it will be to design my own GUI
14:12:36 <shapr> goron: belgium has two national languages :-)
14:12:47 <Boegel> he knows shapr :p
14:13:14 <Boegel> he said people->language, not people->country :p
14:13:19 <goron> I wonder how associtions ever came of my keyboard. I should learn to type...
14:13:42 <shapr> Some of the belgian people I've met speak french just as well as they do dutch, and some only speak french and no dutch.
14:13:43 <Boegel> Well now consider a more dynamic example. Consider the interface below. It allows a group of users to log on to a system and monitor who else is also logged on. Users can log on with the register window. They each have an individual window that displays their name in the title bar. They can change their own details using the entry area. Pressing the set button updates their
14:13:43 <Boegel>  
14:13:43 <Boegel> details with the current value of the entry area. Each user can each see the name of the other users and if they wish their details. The details field is only shown when the view checkbutton is selected.
14:13:46 <shapr> so, I figured I'd try it.
14:13:54 <Boegel> hmmz, sorry 'bout that :s
14:14:02 <Boegel> that's the example shapr
14:14:08 <shapr> no worries, but wiki paste or url is better.
14:14:19 <Boegel> wiki ?
14:14:26 <shapr> HaWiki paste page.
14:14:32 <Boegel> where's that ?
14:14:58 <goron> Is there an official merge sort implementation, except for the one in Data.Graph.Inductive?
14:15:01 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:17:20 <Boegel> pasted :)
14:17:27 <Boegel> that's handy dandy such a page
14:17:47 <Boegel> I haven't worked with the wiki-system before
14:18:04 <Boegel> but don't you guys get spam on that all the time ?
14:19:07 <goron> We are working on that... 
14:19:18 <arjanb> the paste page is getting rather large
14:20:11 <goron> We discriminate low-bandwidth users. That's 1337.
14:20:32 <Boegel> lolz@ goron
14:20:37 <XTL> Now what was that thing...
14:20:41 <Boegel> that's stupid you mean :p
14:21:14 <XTL> http://pastepad.com/
14:22:51 <goron> I don't think there's a single human that cares about the size of the paste page. As long as it's rendered in your browser fast enough, that is.
14:23:33 <goron> Oh wait, arjanb did, stupid me...
14:24:04 <Boegel> who came up with the wiki system ?
14:24:10 <goron> shapr
14:24:20 <Boegel> no, I mean, with the name wiki
14:24:38 <XTL> Ward Cunningham perhaps?
14:24:41 <goron> What's wiki, it's at HaWiki.
14:25:12 <XTL> I think every "out of the box" wiki has one demo page saying "what's a wiki"
14:28:29 <Boegel> we'll I hadn't heard about it until a few months ago, about the 'system' I mean
14:28:45 <jpgil-cl> Ward Cunningham
14:28:56 <jpgil-cl> the same guy who developed Extreme Programming
14:29:04 <goron> Forums are great sometimes:http://www.jonturk.com/modules.php?name=News&file=article&sid=108
14:31:10 <Boegel> *hehe*
14:31:16 <Boegel> got ya ! :p
14:32:47 <basti_> lol
14:36:09 <Boegel> I'm going to bed
14:36:46 <Boegel> you guys won't see me here for a while, 'cause I'm going on holiday with my girlfriend *yaay*
14:36:55 <Boegel> bye
14:48:51 <shapr> wikiwiki is Hawaiian for "quick"
15:35:41 <pesco> Mmm. troff has rapid turn-around times.
18:03:07 <Iter> wow shapr, that looks like a great thesis you found.
18:04:59 <Riastradh> What thesis did he find?
18:06:22 <Iter> Types and Reflection.  Currently the top item on lambda.
18:43:55 <shapr> Iter: Lor wrote it
18:49:17 <shapr> can anyone explain oleg's latest post to me?
18:49:30 <shapr> dons: hey, you're mentioned on the front page of lambda-the-ultimate.org :-)
19:00:50 * shapr thinks Sniper Yagi is an awesome both an awesome name and a cool tool.
19:01:18 <shapr> this is seriously spiffy: http://www.shmoocon.org/sniperyagi/
19:11:34 <pesco> Yay everyone, look at me. I used DocBook, XSLT, and FO processors. I now use LaTeX and roff. And lhs2TeX. And I'm HAPPY. That's a buzzword. Happy.
19:13:43 <pesco> I am rendering my literate program to PDF and the reference docs to man pages, html, and PostScript. And they ALL look GREAT!
19:14:03 <pesco> I should write an article.
19:14:39 * shapr agrees.
19:14:56 <shapr> Compare and contrast all of the above, in not less than fifteen pages.
19:15:05 * shapr is being silly since it's 4:15 am
19:15:09 <pesco> Wuah. :/
19:15:39 <shapr> actually, a bullet list of good and bad points would probably be short enough to write, and short enough to read.
19:15:55 * shapr is having trouble reading a full page at a time right now.
19:16:31 <pesco> I'm just so amazed at how effortlessly and _majorly_ LaTeX and roff beat the hell out of all those fancy new XML-based whatnot great grand thingies.
19:17:03 <shapr> you could compare and contrast their authors intsead.
19:17:13 <pesco> LOL.
19:17:31 <shapr> It's hard to beat Knuth.
19:17:44 <pesco> Look here. Donald Knuth. And over here, Norman Walsh. What do you notice? Isn't it OBVIOUS?
19:18:40 <pesco> Ah, but the author of the original roff is deceased.
19:18:47 <shapr> I still think XML suxx.
19:19:02 <shapr> not sure why, it just doesn't feel elegant at all.
19:19:21 <dons> sharp: hehe :)
19:19:22 <pesco> It does. And here's why: Because S-Expressions are cool.
19:20:15 <jpgil-cl> Why don't you like XML, shapr?
19:20:26 <shapr> somethings feel right, like I couldn't do a better job in a year of thinking about it. XML feels like something I would do in five minutes, but only if I hadn't any sleep the night before and no food so I had low blood sugar.
19:20:37 <jpgil-cl> It's not a language at all, but a way to bring structure to our poors lifes :)
19:21:00 <pesco> I'm taking a wild guess, but has anyone of the XML-crowd ever touched a LISP-like language with a ten-foot pole? Could it be that they are precisely congruent with the "LISP has two many parantheses"-crowd?
19:21:35 <shapr> simple XML is closer
19:21:37 <shapr> YAML is closer
19:21:45 <pesco> shapr: Hehe. Look at XSL code. Who in Hell is supposed to write that?
19:21:50 <shapr> I've done it :-/
19:21:56 <shapr> it's painful.
19:22:00 <pesco> So have I (in limited amounts).
19:22:05 <shapr> it's like digging ditches with a spoon.
19:22:08 <shapr> a small spoon at that.
19:22:18 <pesco> <xsl:param name="paper.type" select="'a4'"/>
19:22:30 <pesco> It's ridiculous and just gets worse.
19:23:16 <shapr> jpgil-cl: I think a 'universal structure' thingy should cut structure down to its simplest essence so everyone can understand and use it.
19:23:20 <pesco> That element-attribute craze is worse than the Java-Everything-is-an-Object craze.
19:24:14 <pesco> Oh this is fun, it's 4:23 and I'm in rant mode again.
19:24:19 <jpgil-cl> Mmm, I didn't speak about the Ultimate Source of Structure, just only a common way to do things.
19:24:33 <shapr> jpgil-cl: I'm not saying I know a really elegant way to do that, but s-expressions, simple xml, and YAML ain't a markup language are better alternatives.
19:24:53 <jpgil-cl> Look, I lived in the middle of the Browser Wars, IE4 and N4. I have suffered of lack of standards!
19:25:16 <shapr> well, Microsoft just left the UN software standards committee, it's just going to get worse.
19:25:17 <jpgil-cl> XML appears as an excellent option.
19:25:58 * pesco pats lambdabot on the back.
19:26:02 <shapr> @yow
19:26:04 <pesco> Good to have ya back buddy.
19:27:07 <pesco> Ok, I'm off to bed, more roffing tomorrow, and this project will be finished.
19:28:07 <shapr> g'night pesco 
19:28:16 <pesco> Night, shapr.
19:28:24 <lambdabot> I'm using my X-RAY VISION to obtain a rare glimpse of the
19:28:24 <lambdabot>  INNER WORKINGS of this POTATO!!
19:32:07 <shapr> jpgil-cl: http://homepages.inf.ed.ac.uk/wadler/topics/xml.html specifically page 19 of http://homepages.inf.ed.ac.uk/wadler/papers/xml-essence/xml-essence-slides.pdf
19:34:53 <shapr> jpgil-cl: XML could have been worse, but it could also be better.
19:35:00 * shapr wanders off to bed
19:35:31 <jpgil-cl> Ok, it's early here so I'll take a look.
22:05:05 <tic> A turing machine has only one input _and_ output tape, right?
23:29:08 <emu> turing machines suck
23:29:29 <emu> model with the lambda calculus and save yourself a headache
23:30:14 <ibid> tic: i don't think the number of tapes (at least as long as its finite) has any effect on what problems it can solve
23:30:33 <ibid> but i too dislike turing machines :)
23:30:50 <ibid> lambda calculus is nice, or if you prefer or need an imperative model, use the RAM
23:31:11 <emu> anyone who disagrees will be clobbered over the head with the s-m-n theorem
23:41:38 <musasabi> morning
23:54:29 <Iter> emu: s-m-n theorm ?
23:55:46 <ibid> (http://antti-juhani.kaijanaho.info/blog/en/stuff/gmail-invites.html)
