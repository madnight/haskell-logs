00:25:06 <musasabi> morning
00:47:32 <musasabi> Why is unsafeInterleaveIO unsafe?
00:48:22 <Cale> musasabi: because it executes side-effecting computations and pulls the result out of the IO monad
00:48:43 <Cale> so the side effects will happen randomly
00:55:12 <musasabi> hmm that is true.
00:55:22 <musasabi> now why didn't I see it?
01:35:55 <al_busy> Hi. If I have a list, and a function that takes an item and returns a string, how can I feed all the items in the list in turn to this function, and concatanate all the resulting strings together?
01:36:50 <kaol> foldl (++) [] (map yourfunc list)
01:37:00 <kaol> or something like that?
01:37:36 <al_busy> thanks :)
01:37:49 <al_busy> I am very slowly getting my heard around this...
01:38:50 <Cale> concatMap yourfunc list
01:39:17 <Cale> or  list >>= yourfunc
01:44:02 <Jerub> I just implemented multimethods in python.
01:47:25 <kaol> hmm. foldl is O(n^2) here, but foldr only O(n)?
02:27:54 * pesco drags himself onto his seat.
02:28:18 <pesco> Morn'...
02:28:22 * pesco yawns
02:46:55 <al_b> the map thing isn't working too well :-/ I have a list of strings, called 'fred' just for the heck of it, that I want to concatanate
02:47:14 <al_b> Main> map ++ fred
02:47:31 <al_b> gives a type error, (a -> b) -> [a] -> [b]
02:48:02 <al_b> does not match [[char]]. I guess map is the wrong command to use for this given I want a single output
02:48:31 <pesco> What are you trying to concatenate? The above code says "concatenate map and fred", which is clearly a type error, because map is not a list.
02:49:46 <pesco> Were you trying to pass the concatenation function to map as its first argument? In that case you have to surround the operator in paratheses, like so: map (++) fred.
02:49:46 <al_b> yeah, I'm still clueless at this, stuck in my C ways :) I would like to concat all the strings in that list, and get a single string
02:50:17 <pesco> al_b: Oh, in that case, there is a Prelude function for your purpose, called concatenate.
02:50:27 <pesco> Ah, no. It's called 'concat'.
02:50:47 <al_b> ha. thanks.
02:50:49 <pesco> @info concat
02:50:50 <lambdabot> -- concat is a variable
02:50:50 <lambdabot> concat :: forall a. [[a]] -> [a]
02:51:18 <pesco> Can lambdabot show the definition of the function?
02:51:23 <al_b> great, that worked
02:51:33 <al_b> I think I've finally got the crazy thing working :D
02:51:38 <pesco> Sure. :)
02:52:55 <pesco> Hah.
02:53:00 <pesco> @get-definition concat
02:53:00 <lambdabot> concat = foldr (\x y.x++y) []
02:53:21 * pesco pats lambdabot on the back.
02:54:12 <Cale> Isn't that the lambdabot definition though, and not the Haskell one?
02:54:25 <pesco> Hm, may be.
02:54:26 <Cale> anyway
02:54:31 * Cale goes to sleep
02:54:37 <Cale> look in the prelude :)
03:32:17 <Lemmih> Hello goron
03:36:32 * musasabi fights latex
03:36:41 <musasabi> how would I make lines denser?
03:38:40 <pesco> \linespread.
03:39:20 <pesco> @google The Not So Short Introduction to LaTeX
03:39:20 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands
03:39:31 <pesco> ;)
03:39:42 * pesco pats lambdabot on the back.
03:39:45 <goron> Lemmih: Hi Lemmih
04:09:12 * shapr yawns
04:09:17 <shapr> good morning #haskell !
04:09:42 <cptchaos> morning
04:17:06 <musasabi> thanks pesco, only it does not work.
04:17:25 <pesco> Did you look up its exact usage somewhere?
04:17:45 <pesco> I've never used that command, just seen it in the guide.
04:17:54 <pesco> Good morning shapr!
04:18:03 <musasabi> pesco: googled and tried with "\linespread{0.1}\small"
04:18:15 * pesco shrugs.
04:18:25 <pesco> Isn't there a #latex maybe?
04:19:28 <Jerub> there is a #latex.
04:19:42 <pesco> Gah, what am I doing wrong, why is man2html not picking up that reference?!
04:19:50 <Jerub> shapr: I'm trying to implement tail call elimintation in python.
04:21:03 <musasabi> yes, only it does not help either.
04:22:21 <shapr> Jerub: I've seen it done in a very ugly manual way, but never automatically
04:22:35 <Jerub> shapr: I need to find an ugly manual way.
04:22:49 <Jerub> shapr: because I can generalise it.
04:23:03 <Jerub> But I can't remember how to go recursion -> imperitive.
04:23:06 <Jerub> it is sadness :(
04:24:15 <Jerub> shapr: I have a teensy puzzle to solve.
04:27:15 * shapr looks for the manual method
04:37:14 <musasabi> shapr: Have you stumbled across http://www.cee.hw.ac.uk/~dsg/gdh/ ?
04:43:12 <shapr> I've seen it. I heard it was based on 5.02 though, do you know more?
04:45:36 <musasabi> well at least the mainline is 5.x based but http://www.macs.hw.ac.uk/~dsg/gdh/summary/GdHSummary0504.html looks promising.
04:46:19 <shapr> well, I'll send in an email and ask for the latest alpha
04:46:46 <pesco> I'm good. I fix Perl code.
04:46:56 <shapr> @yow
04:46:56 <lambdabot> Is this "BIKINI BEACH"?
04:47:04 * pesco prints a T-shirt.
04:47:44 <cptchaos> pesco: is there a way in Cmdline do parse a -v -vv -vvv for different levels of verbosity
04:48:05 <pesco> cptchaos: No. Use -v with an optional integer argument!
04:48:26 <cptchaos> pesco: ok, thats fine as well
04:48:29 <pesco> :-)
04:49:00 <pesco> Remember that the parameter will map to Maybe Int.
04:49:22 <cptchaos> pesco: i just upgraded to cmdline 1.0, and implemented the --help ;-)
04:49:30 <pesco> Yes! Very good. :)
04:49:32 <shapr> musasabi: I'll tell you what I get back from them.
04:49:54 <cptchaos> pesco: looks fine, really
04:50:14 <cptchaos> pesco: and a lot better than getOpt
04:50:15 <pesco> cptchaos: Have you seen the manpages? I'm in the process of making hyperlinked HTML versions of them.
04:50:20 <pesco> :)
04:50:22 <pesco> Thanks.
04:50:46 <cptchaos> pesco: I read all till the Implementation seciton
04:51:15 <pesco> cptchaos: The manpages are in a seperate document. It's on the webpage under the [ref] link.
04:51:23 <pesco> They're also in the distribution, of course.
04:51:31 <pesco> The website link is to a PDF rendition of them.
04:51:52 <pesco> Just copy the man/ subdir to /usr/local/man/man3 or what have you.
04:52:06 <pesco> Well, copy the contents of the man/ dir, that is. :)
04:52:41 * cptchaos is searching his man dir
05:00:00 <cptchaos> pesco: ah, manpages cool
05:00:15 <pesco> *g* thought so.
05:01:34 <goron> Is there any way to see, which functions are being called in a program? A trace or something like that?
05:02:31 <musasabi> shapr: I wrote a short (very incomplete) thing about the pids vs channels - http://www.cs.helsinki.fi/u/ekarttun/pidvschan.pdf
05:03:01 <pesco> Eek, it's all yellow!
05:04:54 <musasabi> pesco: ok, a non-yellow version for you ;)
05:05:22 <pesco> *g*. It strains the eyes, don't you think?
05:06:32 <musasabi> actually it looks more readable to me (a light brown would be better though), but there is now a non-colored version (just reload)
05:06:59 <pesco> Cool. :)
05:35:43 <cptchaos> musasabi: is this intended for IPC only?
05:36:34 <musasabi> cptchaos: currently it mainly discusses communicating parallel processes inside a single virtual machine. (forkIO threads in the haskell world)
05:37:32 <musasabi> cptchaos: it is very preliminary and mostly an explanation why I think the erlang style messaging code is not a good solution.
05:37:45 <cptchaos> musasabi: ah, ok, but looks similar to pescos pipes, in some way
05:38:47 <musasabi> pescos pipes?
05:39:22 <cptchaos> http://www.scannedinavian.org/~pesco/
05:39:26 <musasabi> Creating distributed channels would be nifty - but that needs some work.
05:40:02 <cptchaos> module Comm
05:40:47 <cptchaos> is a gereal Communication abstracion, but with networking in mind I think. 
05:41:35 <cptchaos> maybe you could unify the api
05:42:48 <cptchaos> if I understand it right you could make Chan an instance of pipe
05:44:32 <musasabi> cptchaos: yes, they appear compatible.
05:45:01 <musasabi> cptchaos: in fact you could implement both pid based and channel based messaging with the pipe model.
05:45:23 <musasabi> cptchaos: the point of my paper was *why* channels are better than pid based approaches.
05:46:13 <cptchaos> musasabi: right
05:48:22 <cptchaos> musasabi: i just thought it would be nice to use one api for all communications, and pescos probosal seem to be a good way for that. However, at the moment I do not need to use threads in haskell.
05:49:05 <cptchaos> musasabi: so I can't really say something relevant at that point
05:50:24 <musasabi> cptchaos: the only slightly problematic thing is to support typed communication.
05:54:30 <musasabi> does Show and Read require that "read (show x) == x" ?
05:55:03 <musasabi> *do
05:55:07 <cptchaos> it should 
06:20:11 <goron> Thinking a couple of minutes can save you days. :-) Think about it, it saves you days ;) 
06:23:55 <pesco> goron: Thanks! That was just the tip I needed.
06:53:17 <goron> What's the complexity of The lookup by index operation on Haskell arrays? O(1)? 
06:55:14 <musasabi> yes.
06:55:39 <goron> Great :)
07:17:49 <musasabi> shapr: did you manage to make your serialisation code transfer other values than Typeable ones?
07:18:24 <musasabi> btw it seems to me that it would make sense to have "all types implicitely derive Typeable" in haskell2.
07:18:34 <musasabi> This would have no ill effects, but lots of good ones.
07:27:32 <pesco> Dependant types mix types with values. Typeable represents types in values. It seems as if the worlds of types and values were growing towards each other. I wonder if somebody will find a way of unifying them.
07:28:27 <pesco> I'm playing Doom...
07:29:35 <roconnor> It seems that with dependant types you can make an interpretation function that maps from Typeable to types.
07:29:47 <roconnor> @info Typeable
07:30:28 * roconnor looks up Typeable the old fashion way.
07:33:36 <roconnor> Well a function from TypeRep to type.
07:33:51 <roconnor> not that I understand Typeable very well.
07:34:45 <roconnor> I was thinking this would be used in implement dynamic loading of modules.
07:35:19 <roconnor> You could make an interface using something like TypeRep, and query an object to see if it supports that interface
07:37:16 <roconnor> GetInterface :: (forall x :: TypeRep .  LoadableObject -> Maybe (interpretTypeRep x))
08:14:46 * roconnor is pretty excited about Fudgets
08:55:42 <basti_> moooooooo.
08:56:41 <cptchao1> basti_: any cows over there?
08:56:59 <basti_> just wanted to see what happens.
08:57:32 <cptchao1> basti_: ah, ok
08:57:40 <basti_> :)
08:57:43 * Riastradh does something in response.
08:57:54 * basti_ is currently installing ghc6
08:58:27 * basti_ his debian thinks, it needs new binutils for that.
09:05:35 <roconnor> @moo
09:05:35 <lambdabot>          (__)
09:05:35 <lambdabot>          (oo)
09:05:35 <lambdabot>    /------\/
09:05:35 <lambdabot>   / |    ||
09:05:35 <lambdabot>  *  /\---/\
09:05:35 <lambdabot>     ~~   ~~
09:05:37 <lambdabot> ...."Have you mooed today?"...
09:10:35 <shapr> no, I haven't
09:11:21 <shapr> lambdabot: ya n00b, I said COVER ME.
09:11:21 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
09:13:04 <shapr> @index Typeable
09:13:04 <lambdabot> Data.Dynamic,Data.Generics,Data.Generics.Basics,Data.Typeable
09:13:13 <shapr> @info Data.Typeable.Typeable
09:13:14 <lambdabot> -- Data.Typeable.Typeable is a class
09:13:14 <lambdabot> class Data.Typeable.Typeable a where {
09:13:14 <lambdabot>     Data.Typeable.typeOf :: a -> Data.Typeable.TypeRep; }
09:13:35 <shapr> @info Data.Typeable.TypeRep
09:13:36 <lambdabot> -- Data.Typeable.TypeRep is a type constructor
09:13:36 <lambdabot> data Data.Typeable.TypeRep
09:13:36 <lambdabot>     = Data.Typeable.TypeRep ! !Data.Typeable.Key Data.Typeable.TyCon [Data
09:13:36 <lambdabot> Typeable.TypeRep]
09:14:20 <roconnor> @info Either
09:14:21 <lambdabot> -- Either is a type constructor
09:14:21 <lambdabot> data Either a b = Left a | Right b
09:14:36 <roconnor> What are those  !! in TypeRep?
09:15:01 <shapr> musasabi: I think auth is the primary problem with tuplespaces
09:15:10 <shapr> tuplespaces are really designed for implicit trust.
09:15:23 <shapr> even so, I'd like to have a Haskell cross-RTS version of tuplespaces
09:15:41 <shapr> musasabi: any idea how mnesia handles auth?
09:15:51 <shapr> does it assume implicit trust?
09:16:23 <musasabi> shapr: implicit trust.
09:16:52 * shapr thinks about HaskellDB + cross-RTS Chans
09:16:55 <musasabi> there is simple cookie based auth on connection - but after that complete trust.
09:17:07 * musasabi is very interested in cross-RTS chans.
09:17:16 <shapr> any idea how to implement them?
09:17:22 <shapr> I haven't even thought about it yet.
09:17:38 <musasabi> well I know how to implement them in principle - just not how to marshall haskell values.
09:17:39 <shapr> oh, section 3
09:18:00 <shapr> did you read Lor's thesis about Haskell marshalling?
09:18:15 <shapr> I don't remember what it said about that.
09:18:51 <musasabi> iirc there was not a lot of stuff about that.
09:19:13 <shapr> musasabi: a first cross-RTS chan prototype could assume the matching TypeRep is already present on the remote RTS, and just send the bits part of a Dynamic value.
09:19:36 <shapr> would also have to assume that the names match
09:20:39 <shapr> @info Data.Dynamic.Dynamic
09:20:40 <lambdabot> -- Data.Dynamic.Dynamic is a type constructor
09:20:40 <lambdabot> data Data.Dynamic.Dynamic
09:20:40 <lambdabot>     = Data.Dynamic.Dynamic Data.Typeable.TypeRep (forall a. a)
09:21:07 <musasabi> shapr: but there is no standard way to read/write dynamics is there?
09:21:26 <shapr> I don't know
09:21:33 <shapr> I'm looking at the Data.Dynamic sources now
09:22:10 <shapr> if an instance of NewBinary can be made for the Data.Dynamic value, then it should work just fine.
09:22:31 <shapr> (well, assuming the foreign typerep a) exists and b) has the same name)
09:25:57 <shapr> I'm not really sure what to make of the source... seems that it just calls (unsafeCoerce v) :: Dynamic
09:26:13 <musasabi> shapr: but you cannot make all dynamics on wire...
09:26:19 <shapr> why not?
09:27:01 <musasabi> shapr: consider:
09:27:03 <musasabi> data U = forall u. U u deriving(Typeable)
09:27:11 <musasabi> toDyn (U length)
09:27:20 <musasabi> now put that on wire please ;)
09:27:25 <shapr> :-)
09:27:34 <shapr> so maybe it'll only work for kind *
09:27:44 * musasabi goes to sauna to ponder things
09:27:47 <shapr> er, just data
10:04:00 <roconnor> A web browser in 4000 lines of Haskell.  I'm impressed.
10:04:34 <cptchao1> roconnor: where?
10:04:44 <roconnor> http://www.cs.chalmers.se/~hallgren/Thesis/wwwbrowser.html
10:05:00 <roconnor> It's no Mozilla, but still.
10:07:40 <cptchao1> wow, not bad, however 4000 lines of Haskell is still a quite complex program ;-)
10:48:54 <basti_> ghc has somewhat of a hydrocephalus hasnt it?
11:04:07 <roconnor> Wow.  Oracle trees seem useful for debuging parellel programs.
11:04:16 <Lor> Evening, folks.
11:04:24 <roconnor> You should be able to save the oracle results to repeat the same execution.
11:07:48 <shapr> hei Lor 
11:08:33 <Lor> Hej på dig.
11:10:43 <stefan_> hi, all
11:10:52 <shapr> hiya stefan_ 
11:11:06 <stefan_> musasabi: how's type-safe casting?
11:11:20 <stefan_> shapr, hi
11:11:26 <shapr> Lor: any suggestions for cross-RTS Concurrent.Chan or maybe serializable Data.Dynamic values?
11:12:14 <Lor> So marshalling, basically?
11:12:19 <shapr> yup
11:12:29 <shapr> I'm still in pursuit of an mnesia-style database in Haskell.
11:12:34 <Lor> Weell, with the cheney-hinze -dynamics system it might be feasible
11:13:00 <Lor> But maybe it would be better just to have a simple Serializable class.
11:13:08 <musasabi> stefan_: existential types are still a bottleneck.
11:13:11 <shapr> the cheesy approach assumes that the remote RTS has a) the same typerep and b) under the same name
11:13:16 <Lor> Show+Read does the job, pretty much.
11:13:33 <Lor> You can use generics to automagically generate the marshallers.
11:13:35 <musasabi> show+read is not very good if one wants statefull serialization.
11:13:51 <Lor> Stateful? In what sense?
11:14:02 <musasabi> And state is needed to serialize cyclic values.
11:14:05 <Lor> You want to serialize mutable objects?
11:14:08 <stefan_> musasabi: but what about the "base" and "notworking"/"working" functions? did they at least did what you expected after they type checked?
11:14:29 <musasabi> Lor: mainly remembering which objects have already been serializing.
11:14:35 <musasabi> stefan_: yes, they work quite well.
11:14:43 <Lor> musa, yeah. But that can be done with a nasty hack using unsafe pointer comparison.
11:14:49 <stefan_> musasabi: glad to here
11:15:15 <musasabi> Lor: but you need to have a table of saved pointer == state.
11:15:21 <musasabi> pointers
11:15:42 <Lor> Yes. Vanilla Show+Read won't cut it.
11:16:23 <Lor> Then again, a valid point of view might also be that if you willfully serialize cyclic structures, you deserve to get hosed.
11:16:30 <Lor> wilfully.
11:16:46 <basti_> lol
11:16:51 <Lor> Woops, sorry, both are valid spellings.
11:17:22 * stefan_ reads Oleg's post on applicative translucent functors ...
11:20:36 <musasabi> Lor: but cyclic structures are very usefull..
11:20:58 <Lor> And also bloody annoying.
11:20:58 <musasabi> That is kind of argumenting for reference counting "you should not have cyclic structures".
11:21:24 <Lor> Nono. Cyclic structures are fine, but only when attained with explicit references.
11:22:12 <Lor> "pure" cyclic structures bring all kinds of problems: one cannot perform any transformations on them.
11:22:19 <Lor> http://citeseer.ist.psu.edu/claessen99observable.html
11:22:42 <Lor> That's imho a reasonable approach.
11:24:19 * musasabi reads that
11:27:32 <Lor> This is related to chakravarty's lexer combinators.
11:28:33 <Lor> Recall that there are no truly cyclic structures in there. This is exactly the reason: if there were, you couldn't build a _finite_ state machine out of them.
11:40:47 <shapr> hiya Kferdous, looking for Haskell info?
11:40:55 <Kferdous> I guess so
11:41:22 <shapr> do you want a summary, links to tutorials, compare/contrast with other languages, or something else?
11:41:37 <Kferdous> yes please
11:41:39 <stefan_> :)
11:41:41 <stefan_> lol
11:41:44 * shapr grins
11:41:57 <Kferdous> did I say something wrong?
11:41:59 <shapr> Do you already know some other programming languages that I could contrast with?
11:42:07 <stefan_> not at all, kferdous
11:42:15 <shapr> Kferdous: it's funny because 'yes' is not the usual response to a multiple choice question.
11:42:16 <Kferdous> no, sadly none at all.
11:42:32 <stefan_> ask what you want, anyway
11:42:46 <shapr> ok, what sort of math background do you have?
11:43:06 * shapr jumps into an intro
11:43:14 <Kferdous> Upto H.S Math, going to uni this oct.
11:43:31 <shapr> here's a short and sweet code intro: http://www.scannedinavian.org/AvianWiki/HaskellDemo
11:43:37 * basti_ plays the first chords of "so spoke zaratustrah".
11:43:48 <shapr> ok, so you've worked with equations before
11:44:05 <stefan_> kferdous: what are you going to study at uni?
11:44:09 <Kferdous> yes, but I am the worst of all in math.
11:44:14 <shapr> there are several different flavors of programming, procedural, functional, and logic are the first that come to mind.
11:44:20 <cptchao1> Kferdous: haskell is good starting point for learning programming. It will avoid learning a lot off odd ways of doing something 
11:44:23 <Kferdous> stefan_ well MBA (marketing) or try that is
11:44:23 <Lor> It's "thus spake" :)
11:44:29 <basti_> oh okay.
11:44:40 <shapr> procedural is totally step-by-step, you do step 1, then you do step 2
11:44:50 <Lor> "Thus" and "spake" are both much, much neater words than "so" or "spoke".
11:44:56 <stefan_> Kferdous: out of curiosity: what brought you to haskell?
11:45:08 <basti_> Lor uhm. yes.
11:45:20 <shapr> functional is closer to math in that you set up code that works like an equation and it 'simplifies' down to the result
11:45:23 <Kferdous> Cale said the name and wanted to see if there was a channel on it.
11:45:52 <shapr> logic programming is more about relationships, if you say x = y + z then you can put in any two of those and get the third
11:46:29 <shapr> Haskell fits into functional programming for the most part.
11:46:41 <shapr> It's considered the 'most functional' language from what I've heard.
11:47:04 <Kferdous> what is it used for?
11:47:22 * basti_ .o° ( programming )
11:47:35 <shapr> it's a general purpose programming language, I've used it to write mailing list search web apps, hack on irc robots, play with grammatical framework stuff
11:47:35 * basti_ goes stand in the corner
11:47:39 <Kferdous> oh I know that, I mean what do you make with it.
11:47:41 <Kferdous> ?*
11:47:45 <shapr> lambdabot is written in Haskell
11:47:46 <shapr> @yow
11:47:46 <lambdabot> I'm having an EMOTIONAL OUTBURST!!  But, uh, WHY is there a WAFFLE
11:47:46 <lambdabot>  in my PAJAMA POCKET??
11:48:08 <shapr> I've used two blog systems and a wiki written in Haskell
11:48:17 <Kferdous> 0.o
11:48:19 <shapr> the Glagow Haskell Compiler is written in Haskell
11:48:38 <shapr> Several compilers both commercial and research are written in Haskell
11:48:51 <shapr> Xilinx and Intel use Haskell for some of their circuit design stuff.
11:48:55 <stefan_> it's used as a research object itsself too
11:49:09 <roconnor> Is GHC entirely in Haskell yet?
11:49:16 <Kferdous> oh ok
11:49:28 <shapr> Kferdous: I can go on for a long time about various apps or toolkits written in Haskell.
11:49:48 <shapr> roconnor: what parts weren't?
11:50:01 <cptchao1> shapr: the runtimesystem?
11:50:12 <Kferdous> Ah I was wondering what is the diff in Haskell and other programming languages?
11:50:21 <shapr> Kferdous: programming is usually about making things simple so we can understand enough of a program to improve it or extend it
11:50:34 <roconnor> I vaguely recall a (perl?) script that did something about ripping out unused stack assembly code after C was compiled.
11:50:43 <shapr> oh, the 'Evil Mangler'
11:50:46 <roconnor> But I don't remember very well
11:50:49 <roconnor> That's sounds right.
11:51:03 <shapr> the new backend generates C-- 
11:51:20 <shapr> see http://www.cminusminus.org/ for more detail on C--
11:51:21 <roconnor> Is the Evil Mangler gone?
11:51:27 <shapr> not in 6.2
11:51:51 <shapr> but I think the C-- replacement is finished and ready to go.
11:52:07 <Kferdous> C--?
11:52:10 <shapr> dons hacked on part of the C-- backend, he'd probably know more than me.
11:52:10 <roconnor> I'm looking forward to that.
11:52:12 <Kferdous> isn't there a c++?
11:52:25 <shapr> C-- aka C minus minus is designed to be a 'portable assembly language'
11:52:46 <Kferdous> oh
11:52:48 <shapr> it's not really designed to be written by humans
11:52:54 <shapr> it's designed to be written by compilers.
11:53:09 <shapr> Anyway, back to abstraction...
11:53:33 <shapr> In object oriented programming, complexity is cut apart into 'objects'
11:53:56 <shapr> a class is like a blueprint, and an instance is like an actual existing thing of whatever is in that blueprint
11:54:05 <shapr> so each of these 'instances' have their own state
11:54:28 <shapr> that's one way of doing abstraction, you can often safely reason about multiple objects independently
11:55:06 <shapr> The downside is that sometimes, you have to keep in mind too much state of too many objects to reason effectively about an OOP program.
11:55:21 <shapr> also, two objects may work together in some of their states, and not in others.
11:55:35 <shapr> Haskell's approach is to move all the statefulness of the code into one place
11:55:53 <shapr> Kferdous: is this helping any?
11:56:10 <Kferdous> yes
11:56:12 <shapr> ok
11:56:43 <shapr> if you want to make a calculator in Python, you'd probably make an object, and the 'memory' button would set the current value into the Calculator instance
11:56:59 <Kferdous> ok
11:56:59 <shapr> with Haskell, the memory value would be explictly passed to the calculator code.
11:57:12 <Kferdous> oh
11:57:39 <shapr> explicit passing is done so much in Haskell that there's a coding convention that lets you do that sort of plumbing automatically
11:57:46 <Kferdous> Question: if Haskell does this so nicely, why does everyone want a c/c++/python/perl programmer?
11:58:10 <shapr> If Finnish is a better language for literature, why does everyone write English?
11:58:17 <Kferdous> sorry If I did ask the question in a wrong way, I have no idea about programming.
11:58:22 <shapr> no, that's a good question.
11:58:30 <Kferdous> oh ok.
11:58:40 <shapr> The one thing that Java has that I wish Haskell had...
11:58:48 <shapr> commercially funded advertising :-)
11:58:53 <Kferdous> Finnish is a better language for literature?
11:59:07 <shapr> I think that's likely.
11:59:47 <shapr> But today is not a good time to talk about the Kalevala :-)
11:59:48 <roconnor> Everyone I talk to says they are not smart enough to program in Haskell.  I have no idea where they got that idea from. ... especially because some of them are REALLY smart.
12:00:06 <shapr> Kferdous: you know a bunch of people are convinced math is hard, right?
12:00:59 <roconnor> c/c++/python/perl all have better library support I think.
12:01:31 <shapr> Kferdous: part of it is that with Java/C++/etc you have a lot to learn, and not much to understand, and with Haskell, there's not much to learn, but lots to understand.
12:01:52 <Marvin--> woot, The Usual Suspects on tv
12:02:27 <Kferdous> oh ok
12:02:49 <shapr> I prefer systems that have just a few moving parts that result in a lot of complexity, like Go
12:02:49 <Kferdous> brb please
12:02:50 <shapr> ok
12:03:00 * shapr bounces
12:03:23 <shapr> cptchao1: I think the rts is written in Haskell, though I'm not sure if all of it is.
12:03:57 <cptchao1> shapr: i'm not shure as well
12:07:32 * shapr cranks up Cibo Matto
12:38:09 <shapr> two days left until IOHCC submission is over.
12:45:28 * fraxtal pokes around for cale
12:46:29 <cptchao1> Marvin: The Usual Suspects? CCC?
12:48:04 <Marvin--> CCC?
12:49:12 <cptchao1> cptchao1: http://www.ccc.de/congress/2004/
12:49:26 <roconnor> cartesian closed categories?
12:49:45 <cptchao1> :-)
12:49:53 <Marvin--> I'm talking about the movie
12:50:07 <cptchao1> ah, oh
12:50:32 <cptchao1> overloaded names ;-)
12:50:38 <cptchao1> and Acronyms
12:50:50 <roconnor> abreviations actually.
12:50:59 <roconnor> or initaialisms
12:51:03 <roconnor> oops
12:51:05 <roconnor> initialisms
12:52:22 <cptchao1> roconnor: ah, ok
12:53:13 <roconnor> I would have thought Fudgets would have a liftIOF function of type (a -> IO b) -> F a b
12:54:35 <roconnor> Instead there seem to be specific functions for handling File IO and socket IO.
12:57:46 <roconnor> Stream Processors are nifty by themselves.
12:57:54 <shapr> have you seen Yampa?
13:00:08 <roconnor> nope
13:00:29 <cptchao1> shapr: yes, its cool
13:00:55 <Lemmih> It is a movie or a monad?
13:02:14 <shapr> it's an arrow
13:02:21 <shapr> I guess it's sort of both :-)
13:11:15 * shapr bounces
13:11:31 * basti_ reflects
13:11:33 <shapr> Lemmih: http://www.haskell.org/yampa/
13:13:58 <Lemmih> oh.
13:15:14 <shapr> the movie part comes from the included "Robot Soccer"
13:48:33 <eixei> heya
13:50:48 <jesse98> hi
14:00:59 <shapr> y0
14:01:04 * shapr bounces
14:01:16 <eixei> o.O
14:01:20 <eixei> bouncing, yay!
14:01:33 <shapr> coding, yay!
14:01:42 <eixei> learning math, yay!
14:01:45 <eixei> wait...
14:01:48 <eixei> not yay :-(
14:01:52 <shapr> math is cool
14:02:06 <shapr> have you seen the "Haskell road to math" ? 
14:02:06 <eixei> it isn't when you have to learn a lot of it under pressure in little time
14:02:14 <eixei> um, nope
14:02:18 <eixei> what is it?
14:02:20 <shapr> http://homepages.cwi.nl/~jve/HR/
14:02:24 <shapr> it's cool.
14:02:52 <eixei> ok, bookmarked it
14:03:07 <eixei> I'll be sure to check it later, after I finish this chapter of my math book
14:03:09 <shapr> Logic, Maths, and Programming.
14:03:14 <shapr> using Haskell
14:03:31 <eixei> which reminds me, I haven't used haskell in months :-(
14:03:46 * eixei remembers in what channel he is and hides
14:03:49 <shapr> it's fun
14:12:28 <shapr> hiya clawghoul 
14:12:31 <shapr> looking for Haskell info?
14:12:36 <clawghoul> hi :p
14:12:48 <clawghoul> actually I'm looking for eixei ;-)
14:12:50 <shapr> ah, ok.
14:12:56 <shapr> @seen eixei
14:12:56 <lambdabot> eixei is in #haskell.
14:13:03 <eixei> lol, heya claw
14:13:05 <shapr> I suspect you've found hiw.
14:13:46 <clawghoul> :)
14:15:18 * eixei sighs and throws the mathbook on the floor while getting up to make yet some more tea
14:25:34 <shapr> hiya  rewot 
14:25:39 <rewot> hi
14:25:45 <shapr> looking for Haskell info?
14:26:00 <rewot> hmm
14:26:19 <eixei> lol
14:26:27 <rewot> last time i did haskell was in february
14:26:29 <shapr> are you part of the eixei posse?
14:26:52 <rewot> no, no
14:26:54 <rewot> :P
14:26:56 <shapr> You could do more Haskell if you like. Lots of nifty Haskell projects to work on.
14:27:17 * eixei points to the clawlike creature in here
14:27:30 <clawghoul> :o
14:27:39 <rewot> lol
14:29:26 <shapr> rewot: have you written any fun code in Haskell?
14:29:39 <rewot> enough
14:30:08 <rewot> in excercises at university 
14:31:14 <shapr> found anything you wanted to do more of?
14:31:24 <shapr> lambdabot has a bunch of plugins, and more ideas
14:31:37 <shapr> the haskell web server has some cool stuff going for it.
14:31:49 <shapr> the new packaging system, Cabal, is making steady progress.
14:32:11 <shapr> the Daan Leijen's DData libraries are being added to the standard libraries.
14:32:19 <shapr> Lots of active and fun stuff happening in the Haskell community.
14:32:58 <basti_> uhm
14:33:00 <basti_> good night
14:34:18 <rewot> great ;)
14:34:36 <musasabi> night basti
14:34:51 <shapr> rewot: have any Haskell questions?
14:35:13 <rewot> no atm
14:35:17 <shapr> ok
14:35:22 <shapr> feel free to ask if you find some.
14:35:34 <rewot> ok, thanks
14:35:54 <Smerdyakov> Yeah, like if you find one inside a fortune cookie.
14:35:58 <shapr> I have a design question for any here who are interested in the shared research paper annotations wiki.
14:36:14 <shapr> too bad Jerub isn't around.
14:36:40 <Smerdyakov> You don't need shared research paper annotations when you have an in-person reading group!
14:41:04 <musasabi> Is a version of hierarchical libraries with DData available somewhere?
14:42:15 * shapr thinks about a haskell wiki-zine
15:04:41 <eixei> hmm, shapr, there was a gui for haskell, right?
15:04:51 <eixei> wxhaskell or something like that, if I remember correctly
15:04:52 <musasabi> gtk2hs
15:04:57 <musasabi> and wxhaskell
15:05:08 <eixei> gtk for haskell? nice
15:05:08 <musasabi> and many others too
15:05:12 <shapr> and a Tk binding, and ncurses, and ...
15:05:16 <eixei> lol
15:05:20 <eixei> any recommendations?
15:05:37 <shapr> wxHaskell seems to be the most active, and the one people are trying to standardize on.
15:05:46 <eixei> ok, thanks you two
15:05:58 <jesse98> is it based on wxWindows?
15:06:09 <musasabi> yes.
15:06:38 <jesse98> so it sucks on os x then? :-)
15:07:47 <musasabi> Is there a reason StablePtrs are not deriving Ord,Eq ?
15:09:16 <musasabi> seems like that limits their usablity to the C side.
15:09:57 <musasabi> (of course one could hack things with importing things from C)
15:10:32 <musasabi> int stableptreq(void *s1, void *s2) { return (s1 == s2); }
15:10:54 <musasabi> of course that would only work if the same object would allways become the same stableptr.
15:12:06 <Lunar^> musasabi: StablePtrs can move around memory
15:12:50 <Lunar^> musasabi: but it seems dumb to read that again
15:14:09 <musasabi> Lunar^: the objects pointed by stableptrs can move, but the stableptr should remain constant (as it can be passed to C world).
15:15:07 <Lunar^> musasabi: There's a specific operation to dereference, if I remember correctly
15:15:50 <musasabi> @type Foreign.StablePtr.deRefStablePtr
15:15:51 <lambdabot> Foreign.StablePtr.deRefStablePtr :: forall a.
15:15:51 <lambdabot> 				    GHC.Stable.StablePtr a -> IO a
15:16:12 <musasabi> but that is in no kind of helpfull..
15:16:18 <Lunar^> on C land
15:17:48 <Lunar^> StgTSO * t = (StgTSO *) stable_ptr_table[(StgWord)sp].addr;
15:18:50 <Lunar^> sp is an arbitrary integer, .addr contains the current memory address
15:28:46 <shapr> hej bojohan 
15:28:52 <shapr> looking for Haskell info?
15:29:20 <bojohan> not really :)
15:29:24 <shapr> ok
15:34:43 <Jerub> shapr: 
15:35:21 <Jerub> shapr: I did it last night :))
15:35:32 <Philippa> evenin'
15:37:20 <shapr> hey Jerub
15:37:26 <shapr> hiya Philippa, wassup?
15:37:29 <shapr> Jerub: what did you do?
15:38:01 <Jerub> shapr: I wrote a decorator that emulates tail call elimination in python
15:38:09 <shapr> nifty!
15:38:22 <Jerub> from tailcall import tail, call, eliminate
15:38:27 <Jerub> @eliminate
15:38:27 <lambdabot> Sorry, I don't know the command "eliminate", try "lambdabot: @listcommands
15:38:36 <Jerub> def fact(n):
15:38:41 <Jerub>    if n == 0: return 1
15:38:51 <Jerub>     return tail(operator.mul, n, call(n-1))
15:38:57 <Jerub> :)))
15:38:58 <Jerub> and it works
15:39:58 <Lor> trampolines?
15:40:23 <Jerub> fact(100000) no worries.
15:40:27 <Jerub> just takes a little while.
15:41:51 <Jerub> (btw, fact(100000) is a really big number)
15:42:39 <Lunar^> Jerub: How does _that_ work ?
15:43:33 <Jerub> Lunar^: eliminate is a decorator, it replaces fact() with a function that calls fact(), then uses an iterative tree traversal to evaluate all the recursive calls.
15:45:08 <shapr> Jerub: have you posted it to c.l.p yet?
15:45:29 <Jerub> shapr: I'm just about to...
15:45:47 <shapr> should be a fun thread
15:46:06 <eshu> does anyone know where i might find some code for an arrow instance that represents functions of type [b] -> [c]?
15:46:31 <shapr> well, there's an arrow instance for (->)
15:46:40 <Jerub> shapr: I have also implemented multimethods using decorators.
15:46:44 <Jerub> but I don't like my implementation.
15:46:56 <shapr> multimethods are handy.
15:47:30 <shapr> eshu: I don't think I understand your question. Can't you just arr whatever function you have?
15:48:01 <eshu> i dunno, im just trying to better understand arrows, i figured a list processing arrow would be pretty straight forward
15:48:06 <shapr> @type map
15:48:07 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
15:48:12 <shapr> @type Control.Arrow.arr
15:48:14 <lambdabot> Control.Arrow.arr :: forall a c b.
15:48:14 <lambdabot> 		     (Control.Arrow.Arrow a) =>
15:48:14 <lambdabot> 		     (b -> c) -> a b c
15:48:17 <shapr> @type Control.Arrow.arr map
15:48:18 <lambdabot> Control.Arrow.arr map :: forall a a1 b.
15:48:18 <lambdabot> 			 (Control.Arrow.Arrow a) =>
15:48:18 <lambdabot> 			 a (a1 -> b) ([a1] -> [b])
15:49:01 <shapr> eshu: yah?
15:49:12 <eshu> lemme have a look, thanks
15:50:11 <shapr> @type Control.Arrow.arr (map id)
15:50:12 <lambdabot> Control.Arrow.arr (map id) :: forall a a1.
15:50:12 <lambdabot> 			      (Control.Arrow.Arrow a) =>
15:50:12 <lambdabot> 			      a [a1] [a1]
15:50:59 <shapr> Arrows let you treat functions like first class transformations, even more so than monads.
15:57:37 <pesco> Hihihi, Google doesn't know about my webpage!
15:58:40 <pesco> My webspace is a disjoint component of the WWW.
15:58:52 <eixei> omg! incredible...
15:59:05 <eixei> google even knows about my site, although there is nothing on it, or has ever been
15:59:35 <pesco> How might it have picked it up?
15:59:44 <eixei> I have no idea...
15:59:56 <pesco> If it ever picks up mine, then from the logs of this channel!
16:00:07 <pesco> Oh god, I should have thought about that.
16:00:11 <eixei> lol
16:02:46 <eshu> shapr, ok, but the only code i can find that makes use of arrows, is in simulation and all kinds of thick subject matter i dont understand. Im really just looking for some simple code that does something useful with arrows.
16:03:25 <pesco> eshu: AFRP.
16:03:35 <shapr> have you read Ross Patterson's FoP chapter?
16:04:17 <eshu> no idea
16:04:28 <eshu> chapter in what?
16:05:02 <shapr> http://www.soi.city.ac.uk/~ross/papers/fop.html
16:07:57 <eshu> im pretty sure i have, but its been a while. Ill have another look at it.
16:08:59 <shapr> There's no real application code in there, but he does demonstrate a lot of nifty stuff.
16:09:25 <tic> speaking of nifty stuff, shapr, http://www.veyboard.nl/intro.swf
16:09:39 <shapr> hm, I don't have flash installed...
16:09:45 <tic> aw. :|
16:09:50 <tic> it's a cool keyboard they use at tv station
16:09:53 <tic> tv stations, too
16:09:54 <shapr> hm
16:10:43 <shapr> that does look cool.
16:10:49 <shapr> I bet this is based on the flinder.
16:11:00 <pesco> 450 tekens!
16:11:06 <shapr> eek 2000euro ?
16:11:18 <pesco> "investering"
16:11:55 <shapr> they don't have any good pictures
16:12:20 <shapr> aha
16:12:24 <shapr> http://www.veyboard.nl/images/veyboard_2.gif
16:12:30 <shapr> http://www.veyboard.nl/images/veyboard_1.gif
16:12:43 <shapr> interesting
16:17:32 * pesco goes to bed.
16:17:34 <pesco> Good night.
16:17:41 <eixei> night pesco
16:17:44 * pesco waves.
16:17:56 * shapr waves
16:27:03 <shapr> g'day Pseudonym 
16:27:13 <Pseudonym> G'day.
16:27:34 <Jerub> shapr: okay, NOW I've posted to c.l.p
16:27:37 <shapr> yay
16:27:42 <Jerub> now to wait for crappy usenet to catch up.
16:28:28 <Pseudonym> http://www-2.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf
16:28:35 <Pseudonym> Excellent paper, if you're into that sort of thing.
16:29:18 <jesse98> what sort of thing Pseudonym?
16:29:34 <tic> Pseudonym, thanks! I need that for a class I failed
16:29:35 <Pseudonym> Solving sparse linear systems.
16:29:41 <jesse98> oh
16:29:51 <shapr> hey Pseudonym, I need some input from you
16:30:02 <Pseudonym> Malfunction?  Need input?
16:30:04 <shapr> research paper margin notes wiki
16:30:14 <Pseudonym> Ooh, good idea.
16:30:32 * Pseudonym gets out the red font to mark up the comonads paper
16:30:44 <shapr> actually, the whole comonads thing is why I came up with this.
16:30:50 <Pseudonym> :-)
16:31:53 <shapr> you found the OI problem immediately after the paper came out, then at least two other people came here at different times and mentioned the same thing
16:32:25 <shapr> so, I have a mockup and I'm partway into an implementation
16:32:43 <shapr> Pseudonym: http://www.scannedinavian.org/RandomWiki/AnnotationMockup
16:33:23 <Pseudonym> Very nice.
16:33:48 <shapr> the idea so far is to use darcs and pull-only to combat spam and get around copyright issues
16:34:04 <shapr> only the annotations will be in the repo, and you only get to edit your own annotations
16:34:16 <shapr> but other people can pull annotations from you
16:34:55 <Pseudonym> Very nice idea.
16:34:59 <shapr> imagemagick can produce png images of each page in a pdf or ps, so that's the plan.
16:35:02 <Pseudonym> Looks cool, too.
16:35:31 <shapr> still feels pretty rough, any ideas, suggestions, or refinements?
16:38:25 <shapr> anyone know if imagemagick can autocrop the whitespace around the edges of these page images?
16:38:40 <Jerub> shapr: don't see why not.
16:39:32 <Jerub> hmm. but it doens't seem trivial.
16:41:17 <shapr> autocrop is not high on my list, along with a lot of other features that aren't high on my list
16:41:31 <shapr> I've nearly got the page generation done
16:41:48 <shapr> then I'll do the darcs integration, and then it'll be ready for alpha testing.
16:42:29 <Pseudonym> Removing the margin is going to be hard on papers which are scanned.
16:43:12 <shapr> I think the marginwiki idea is sound, but the implementation will need a lot of user feedback. (and a good name)
17:21:44 * roconnor looking for a reference on Gadgets
17:23:12 <roconnor> maybe Gadgets are gone.
17:34:45 <Pseudonym> http://www.cs.mu.oz.au/pgrad/seminars/
17:34:49 <Pseudonym> Looks very interesting.
17:35:55 <eixei> goodnight people
17:36:18 * eixei wonders... should he change his nick to eixei[asleep] or leave the channel...
17:36:31 <Pseudonym> Do you want to be able to scroll back later?
17:36:35 <Cale> eixei: just idle, that's what I do
17:36:42 <eixei[asleep]> ok, I'll do that :-)
17:36:58 <eixei[asleep]> see you!
19:26:54 <heatsink> ...damn...
19:27:05 <heatsink> For my code to work correctly, this list has to contain itself
19:27:21 <heatsink> How do I do that?
19:28:01 <dons> the list has to contain itself... nasty
19:28:08 <dons> you certainly can't do: let x = [x] in x
19:28:10 <dons> :)
19:28:20 <roconnor> I doubt that will typecheck.
19:28:28 <heatsink> hmm...
19:28:31 <heatsink> so let is letrec
19:28:50 <dons> yep
19:29:03 <roconnor> heatsink: Does the list need to contain itself as a sublist, or as an item of the list?
19:29:23 <roconnor> The first is easy, the latter is impossible (I think).
19:29:35 <heatsink> roconnor: As an item of the list
19:29:57 <heatsink> roconnor: it actually needs  to look like this:
19:30:04 <roconnor> So you have a list of lists of lists of lists of lists ...?
19:30:13 <heatsink> foo [a, b, c, d, foo[a, b, c, d, foo[ ......
19:30:38 <heatsink> foo is [a] -> a
19:30:40 <roconnor> what are type are a b c and d?
19:30:49 <roconnor> oh!
19:30:52 <roconnor> that's good.
19:31:33 <heatsink> It's funny since I wasn't trying for something weird like that, it just kinda happened.
19:31:40 <roconnor> Then you can just say bar = foo [a, b,c,d, foo bar]
19:31:51 <heatsink> cool
19:32:32 <roconnor> oops 
19:32:35 <roconnor> that's wrong
19:32:50 <roconnor> bar = foo [a, b, c, d, bar]
19:33:28 <heatsink> yea, that makes more sense
19:33:28 <roconnor> or bar = [a, b, c, d, foo bar], depending on if you want bar to be an [a] or an a.
19:41:19 <heatsink> It looks correct, but it also looks very strange to me
20:04:42 <dons> here's something to play with for a little while: let x = toDyn [x] in x
20:05:11 <heatsink> !help
20:05:15 <heatsink> `help
20:05:24 <dons> problem: can't unpack it in finite time though
20:05:28 <heatsink> How do I ask what the type of toDyn is?
20:05:51 <heatsink> @help
20:05:51 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
20:05:56 <heatsink> @listcommands
20:05:57 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
20:05:57 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
20:05:57 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
20:05:57 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
20:05:57 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
20:05:57 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
20:05:59 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
20:06:01 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
20:06:03 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
20:06:17 <dons> @type Dynamic.toDyn
20:06:18 <lambdabot> bzzt
20:06:26 <dons> @type Data.Dynamic.toDyn
20:06:27 <lambdabot> Data.Dynamic.toDyn :: forall a.
20:06:27 <lambdabot> 		      (Data.Typeable.Typeable a) =>
20:06:27 <lambdabot> 		      a -> Data.Dynamic.Dynamic
20:07:39 <dons> @type let x = Data.Dynamic.toDyn [x] in x
20:07:40 <lambdabot> let x = Data.Dynamic.toDyn [x] in x :: Data.Dynamic.Dynamic
20:09:36 <dons> @type head (Data.Maybe.fromJust $ Data.Dynamic.fromDynamic (let x = Data.Dynamic.toDyn [x] in x)) :: Data.Dynamic
20:09:37 <lambdabot> bzzt
20:09:52 <heatsink> Okay, I think I get it
20:10:07 <heatsink> the type of x is [x]
20:10:20 <heatsink> which is okay as long as x is encapsulated in Data.Dynamic.Dynamic
20:10:52 <heatsink> but it can't be resolved when converting to a regular type
20:11:09 <dons> well, you can compile (let x = toDyn [x] in x), and you can even unpack it a bit at runtime, but it has type Dynamic [Dynamic ...]]], so you can never unpack it fully
20:11:30 <dons> i.e. we just defer the impossible type check to runtime. kinda cute
20:11:51 <heatsink> yea
20:12:22 <heatsink> for some reason this brings to mind kiting
20:12:36 <dons> head (Maybe.fromJust (fromDynamic (let x = toDyn [x] in x))) :: Dynamic
20:12:37 <dons> <<[Dynamic]>>
20:13:08 <dons> so a new way to construct an infinite loop: get dynamic typing to diverge :)
20:13:41 <heatsink> heh
20:14:19 * Smerdyakov laughs at Gahhh's username.
20:17:39 <np_hard> must work in corporate IT
20:23:19 <Gahhh> haha
20:23:36 <Gahhh> I don't
20:23:39 <Gahhh> phew
20:24:04 <np_hard> well, you have the proper attitude
20:24:07 <np_hard> care to enlist? :-P
20:26:06 <Gahhh> I am a software engineer working in the imperative world
20:26:31 <Smerdyakov> Now whose fault is that?
20:26:40 <Gahhh> The system's, I am telling you !
20:27:09 <np_hard> but you don't work in corporate IT or a software company producing corporate IT software?
20:27:15 <np_hard> amazing.
20:27:31 <Smerdyakov> Gahhh, nope. It's YOUR fault, for choosing the job!
20:27:55 <np_hard> I hear that in the free market, job chooses YOU!
20:29:10 <Gahhh> I chose the job for the money and I am happy with that mistake
20:29:21 <Gahhh> I work for an electronics company actually
20:29:34 <np_hard> oh, that sounds like fun.
20:29:58 <Gahhh> yup.  hardware gets all the glory and we get nailed for the bugs
20:30:06 <np_hard> I would be happy if people just understood that NULL and "N/A" mean two different things
20:30:12 <Smerdyakov> Good thing you'be been brainwashed to care about money enough to accept this!
20:30:20 <np_hard> functional over imperative would be icing on the cake
20:30:45 <np_hard> Gahhh: well, the Therac-25 system pretty much spoiled it for you
20:30:52 <Gahhh> Therac-25 ?
20:31:04 <np_hard> google it
20:31:07 <np_hard> first link
20:31:15 <Smerdyakov> And that's an order, LOO-TEN-ANT.
20:31:32 <Gahhh> ahahha
20:31:42 <Gahhh> I wanna fry some people as well
20:31:42 <np_hard> it's always the software peoples' fault
20:31:47 <Gahhh> I suppose I should get coding
20:32:05 <np_hard> likely because hardware engineers generally follow some semblance of, you know, engineering discipline
20:32:06 <np_hard> :)
20:32:25 <Gahhh> funny thing is, they are not any better
20:32:28 <SamB> well, the software is easier to fix bugs in. that is, you can work around hardware bugs in software...
20:32:51 <Gahhh> our hardware guys issue change orders after change orders, have fpga bugs, etc.
20:32:52 <Smerdyakov> Software is way harder to find or fix bugs in.
20:33:05 <np_hard> especially typical software
20:33:09 <np_hard> with global variables
20:33:28 <Smerdyakov> I don't think that's much of an issue compared to recursion.
20:33:28 <np_hard> large blocks in the same lexical scope
20:33:43 <Gahhh> software can be made more complex much easier. It's hard to increase the complexity of hardware as fast as software.
20:34:21 <Gahhh> hardware guys spend weeks to go over changes that affect 1% of the layout
20:34:24 <SamB> Smerdyakov: well, if you have hardware already, it is hard to recompile it!
20:34:35 <Gahhh> software guys overhaul and rewrite the whole thing overnight lol
20:34:45 <shammah> hardware also becomes unmodifiable earlier in the project cycle.
20:34:52 <Smerdyakov> SamB, not anymore, with FPGA's.
20:35:00 <Gahhh> yeah it's costly to touch hardware
20:35:16 <SamB> Smerdyakov: that only works when you actually used FPGAs!
20:35:22 <shammah> Smerdyakov, but not everything can be done in FGPA's or you blow your budget.
20:35:42 * shammah also worked as a soft-eng in an electronics company for a while. :)
20:35:44 <Smerdyakov> That's OK. You can simulate the hardware in software and do most of the debugging that way, as I understand it.
20:35:55 <dons> here you go. sit back and what the dynamic typing wander away:
20:35:58 <dons> let (unpack :: Dynamic -> Dynamic) = head . Data.Maybe.fromJust . fromDynamic in (let f x = let y = unpack x in f y in f) (let x = toDyn [x] in x) :: Dynamic
20:36:33 <shammah> Smerdyakov, that only works to a first-order approx.  And really only works if you're doing asic design.  Most projects are COTS so this dosn't really apply.
20:36:35 <SamB> Smerdyakov: that doesn't do anything for the hardware you already ran off the line before you found the bug, now, does it?
20:36:45 <Smerdyakov> SamB, well, why did you go and do that?
20:36:56 <SamB> Smerdyakov: because hardware is hard?
20:37:12 <Smerdyakov> shammah, I don't know what either of those things are, but I do know that there is a long history of hardware verification techniques and tools.
20:37:48 <shammah> asic -- Application Specific Integrated Circuit.
20:38:00 <shammah> cots -- Commercial Off The Shelf.
20:38:14 <Gahhh> what are you discussing, anyways ?
20:38:28 <Smerdyakov> I'm making the case that hardware is much easier to debug.
20:38:29 <SamB> Gahhh: I'm not sure
20:39:00 <SamB> I'm arguing that you can cover up hardware bugs in software, sometimes
20:39:04 <Gahhh> Smerdyakov: h.w debug has many kinds. state machine vs signali ntegrity  are quite different to debug
20:39:41 <Gahhh> SamB: yes, we are quite often asked to mask some hardware bugs. but it's not always possible or desirable.
20:39:54 <SamB> Gahhh: true!
20:40:18 <Smerdyakov> SamB, did you just start college?
20:40:24 <SamB> Smerdyakov: uh huh
20:40:42 <Gahhh> One thing that is pretty much guaranteed not to happen is h/w covering s/w bugs lol
20:40:52 <Smerdyakov> SamB, I grew up near Lehigh -- in Lehigh County, but in Allentown, not Bethlehem.
20:41:07 <SamB> Interesting
20:41:20 <Smerdyakov> SamB, yah mon!
20:41:39 <Smerdyakov> SamB, why did you pick Lehigh?
20:41:59 <SamB> Smerdyakov: Irrationally
20:42:06 <SamB> hence, I can not explain it.
20:42:11 <Smerdyakov> SamB, huh... how about that.
20:42:48 <Gahhh> ok, little nitpicking about haskell:
20:42:55 <Smerdyakov> SamB, do you plan to stay there for 4 years?
20:43:04 <SamB> Smerdyakov: yes!
20:43:20 <Smerdyakov> SamB, all right. Seems a bit like shooting your future possibilities in the foot to me, though.
20:43:22 <Gahhh> "We use the term error for _|_: a condition which cannot be recovered from such as non-termination or pattern match failure. Exceptions, on the other hand, can be caught and handled within the I/O monad.". Then why is the type named IOError not IOException ?
20:44:10 <SamB> Smerdyakov: oh?
20:44:48 <Smerdyakov> SamB, yeah. It's pretty much a backwater for CS. Bad place to be if you're planning grad school.
20:45:06 <SamB> Smerdyakov: oh, yeah, well, I'm probably doing EE anyway.
20:45:19 <SamB> especially if it is backwater for CS!
20:45:33 <SamB> (the other thing I was thinking of was Computer Engineering)
20:45:47 <heatsink> what kind of ee?
20:46:52 <SamB> heatsink: I don't know about kinds at this point, really ;-)
20:46:53 <Smerdyakov> SamB, well, I don't know about EE. If I were you, I would try to find out how the EE department is viewed in the research community, if grad school is at all on your mind.
20:48:11 <SamB> Smerdyakov: my understanding is that people often go to gradschool somewhere other then they get their undergraduate degree
20:48:25 <heatsink> yes, but it is very impt where you get your undergrad degree
20:48:46 <SamB> anyway, I really want to get a job programming, so...
20:48:47 <heatsink> among other things
20:48:51 <Smerdyakov> SamB, yes, but you won't get in if you're from a school nobody's heard of.
20:48:59 <Smerdyakov> SamB, faculty recommendation letters are the single most important thing.
20:49:09 <Smerdyakov> SamB, and the people writing the letters have to be known to the people reading them.
20:50:05 <Smerdyakov> We get maybe 2 or 3 new PhD students in CS at Berkeley each year who didn't do their undergrad at one of the top 10 CS PhD schools.
20:50:39 <Smerdyakov> Well, that figure is probably more accurate if I say top 20.
20:50:49 <Gahhh> SamB: If you wanna be a programmer, I don't see why you would want to study EE.
20:51:57 <SamB> Gahhh: because it is interesting!
20:52:30 <SamB> in any case, I'm not particularly interested in a PhD
20:52:48 <Smerdyakov> OK. There is also the issue of connections in getting Regular Industry Jobs With Fascist Companies.
20:53:05 <Smerdyakov> Social connections and networking are the most important thing in university choice.
20:53:22 <Pseudonym> Or fascist customers, as the case may be.
20:53:37 <Gahhh> fascist language designers too
20:54:05 <Gahhh> I concur on social conenctions. I owe my grad degree to my social connections.
20:54:19 <Smerdyakov> SamB, at least apply to transfer to CMU, eh? :)
20:54:36 <Pseudonym> I think the word "fascist" has officially grown up from technical term to punctuation mark.
20:55:36 <Gahhh> fascist = enhanced exclamation mark ?
20:55:45 <Pseudonym> Yes, only it's prefix.
20:56:00 <Gahhh> how about fascist !
20:56:02 <Gahhh> err
20:56:06 <Gahhh> "fascist!"
22:01:30 <musasabi> morning
22:44:43 <Lor> Morning.
22:44:53 <Lor> Why do I sleep too little?
22:45:31 * Lor went to sleep at 4:30, and couldn't sleep any more, and is now (and probably for the rest of the day) tired.
22:50:43 * jesse98 thinks living in Finland will do that to you
22:51:09 <Lor> How come?
22:51:39 <jesse98> too far north, not enough sunlight :)
22:53:45 <Lor> Uh. That's not quite how it works. During summers we have much longer days than equatorial lands.
22:54:14 <jesse98> ok, too much sun :-)
22:54:53 <Lor> Then again, it comes in an oblique angle, not directly from above.
22:55:25 <jesse98> probably doesnt matter anyway unless you're outdoors a lot
23:00:05 <kuz> Sleep is overrated.
23:00:30 <musasabi> well it is quite disorienting when in the summer it is not really dark -> no need to sleep, and the winter it seems allways dark -> no need to sleep 
23:01:05 <kuz> I think that I might like the winter conditions.
23:01:56 <kuz> Does it tend to alter larger social patterns?
23:02:22 <jesse98> it's not good for you to get no sunlight tho: screws up vitamin D production, and linked to over sleeping and depression
23:03:43 <musasabi> kuz: well in the summer it is bright and warm, winter is cold and wet, so it influences things a little bit.
23:05:09 <kuz> I should see how different the winters are from here.
23:11:01 <kuz> Hmm. Not too disimilar temperature-wise.
