01:15:52 <shrimpx> so the (read "5") thing above doesn't seem related to numeric defaults.
01:17:50 <shrimpx> the GHCi toplevel seems to imply a Num constraint on unannotated uses of read or something...
01:17:53 <shrimpx> hmm
01:37:26 <musasabi> What does LGPL mean with haskell libraries?
01:37:33 <musasabi> sorry.
01:37:52 <musasabi> That means that is it fine even if ghc inlines stuff and so on?
01:39:54 <Lor> Hm... wonder what the situation is with C macros. You can't link them dynamically.
01:40:28 <Igloo> With C you could licence the headers differently
01:40:54 <musasabi> btw the Chakravartys lexer combinators look nice.
01:41:11 <Lor> "If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object
01:41:11 <Lor> file is unrestricted, regardless of whether it is legally a derivative work."
01:41:44 <Lor> Presumably ghc doesn't inline anything bigger than ten lines.
01:42:13 <musasabi> well most haskell functions are <10 lines.
01:43:41 <Lor> They'd better be.
01:48:39 <Igloo> lines is an odd way of measuring code, of course
01:52:24 <Lor> What would be better? Kolmogorov complexity?
01:55:27 <earthy> that is *hard* to measure, and not all that much better ;)
01:55:54 <Igloo> I didn't say there was anything better  :-)
01:56:56 <arjanb> number of tokens is a little better than lines
01:59:04 <Igloo> Also, is it the <whatever> before or after other things are inlined into it?
02:09:54 <earthy> arjanb: only a little
02:10:08 <earthy> (because it is in fact quite hard to count tokens in a language such as C)
02:10:16 <earthy> (due to the preprocessor)
05:04:46 <thebug_> dons: excellent!
05:07:10 <dons> also, just built stable on mips64 successfully. no patches needed
05:07:21 <dons> though a couple of values still need to be set in build.mk
05:07:35 <dons> i'll put up a page  about it
05:08:10 <dons> hey shapr
05:08:26 <shapr> heya dons 
05:08:36 <shapr> hey, I have a few hs-plugins questions
05:08:56 <dons> well, fire away!
05:09:11 * shapr is trying to remember them
05:09:39 <Igloo> Can't you just patch config.mk to magically work?
05:09:56 <shapr> I'd like to make a distributed database like Erlang's mnesia.
05:10:17 <dons> Igloo: yes. I should do that
05:10:30 <shapr> I wonder if I could use hs-plugins to 'download' any types that are defined by remote sources.
05:10:56 <shapr> I'm sure I could if I knew how to get from a type to a source file...
05:11:04 <shapr> actually, I guess that's not a question...
05:11:13 * shapr tries to remember the other question
05:11:42 <dons> so you have a known type, and you want to map it to the source it was defined in?
05:11:47 <shapr> right
05:11:53 <dons> sounds like a job for .hi file information
05:11:58 <shapr> hm!
05:11:58 <dons> -package ghc
05:12:46 <shapr> do you think that a value of Data.Dynamic, and the source file that defines that type, could be used to reconstitute a value remotely?
05:13:12 <dons> hmm. possibly.
05:13:13 <shapr> cool, I'll look into .hi info
05:14:00 <dons> so you'd send the source, and a dynamic, and have the remote code compile the source?
05:14:11 <shapr> and then reconstitute the value
05:14:26 <shapr> at least, it sounds good :-)
05:14:32 <dons> sounds doable
05:15:02 <dons> you could send the .o, couldn't you?
05:15:12 <dons> or are you thinking super-cross-platform
05:15:21 <shapr> yah, I'm thinking win32 and linux
05:15:32 <shapr> and macosx
05:15:35 <dons> ok. so src will be our mobile object code
05:15:40 <shapr> would the same .o file work on multiple arches?
05:15:49 <dons> nah.
05:15:55 <shapr> like, foo.o built on x86 would work on ppc?
05:16:02 <dons> no.
05:16:02 <shapr> for linux?
05:16:16 <shapr> in that case, source really is better.
05:16:43 <shapr> because mobile values for linux-{ppc,x86} would give you win32 as well.
05:16:44 <Igloo> Would the same dynamic work across endianesses and 32/64bit?
05:16:52 <dons> the dynamic should
05:17:15 <dons> it is just a string rep of the canonical type name
05:17:31 <shapr> could you have name collisions?
05:17:32 <Igloo> Oh, maybe I don't mean dynamic then
05:17:43 <Igloo> You are also passing values of this type, right? OAIC?
05:17:50 <shapr> just dynamics
05:18:06 <shapr> I think the source and a dynamic would be portable.
05:18:12 <shapr> I can't think of any cases where it wouldn't be.
05:18:21 <dons> you could have name collisions if the remote code happens to have a module loaded with the same name as that being sent to it
05:18:23 <Igloo> Ah, or d you just read+show the values?
05:18:44 <dons> i think you could get around the type name issue though
05:19:45 <dons> maybe you could look at some of the mobile stuff done in Clean
05:20:00 <shapr> I may do that
05:20:03 <dons> as our dyn loading stuff is very similar.
05:20:19 <dons> though we use native code objects, while they have a bytecode format, afaik
05:20:25 <shapr> but it's more likely I'll just hack around with hs-plugins when I have some spare moments
05:20:30 <dons> yep.
05:20:37 <dons> have you read the final version of the paper?
05:20:46 <shapr> I haven't seen 9.6 yet, if that's what you mean.
05:21:02 <dons> ok. you should look at pdynload(). it is an alternative to makeWith
05:21:07 <shapr> ah, interesting
05:21:16 <dons> uses the .hi file to find the type representation for the dynamic typing
05:21:22 <dons> and uses the ghc typechecker to check them
05:21:22 <shapr> oh, I couldn't get makeWith working with cvs or 9.5, but make worked fine
05:21:29 <dons> rather than Data.Dynamic's check
05:21:41 <shapr> I'll check out pdynload and 9.6
05:21:46 <dons> why didn't makeWith work?
05:22:13 <shapr> I don't remember the details, but I do remember it mystified me for four or five hours before I gave up on it.
05:22:26 <shapr> on the good side, hws-wp works great with make
05:22:31 <dons> cool!
05:23:15 <shapr> I think I'll port lambdabot to hs-plugins soon
05:23:36 <dons> nice idea. would clean up a lot of the admin work. and those makefiles!
05:23:41 <shapr> yup, truly
05:24:56 <shapr> I'd really like to have a distributed peer database.
05:25:35 <shapr> distributed computing with Haskell would be a lot easier to deal with then.
05:26:12 <dons> yep.
05:26:33 <shapr> do you know if parr is still in development?
05:28:38 <dons> i haven't seen anything recently
05:28:52 <shapr> what future plans do you have for hs-plugins? anything other than possible integration with -package ghc?
05:30:35 * shapr reads the 0.9.6 docs
05:30:51 <dons> did you see the recent thread on glasgow-haskell-users?
05:31:02 <shapr> some of it
05:31:33 <dons> ok. well runtime metaprogramming is what I'm working on at the moment
05:31:47 <dons> and better dynamics
05:31:50 <shapr> greetings PeterE, looking for Haskell info?
05:32:10 <PeterE> Wow, thats service.
05:32:20 <shapr> PeterE: and I'm not even an irc bot.
05:33:07 <PeterE> Well.  Just reading the Haskell Communities and Activities Report.  And saw the channel mentioned.
05:33:31 <norpan> det ær en go kanal
05:33:33 <shapr> we're here and we're cool
05:34:04 <shapr> finns det en go kanal på freenode?
05:34:26 <shapr> PeterE: do you write Haskell for fun or for profit?
05:34:38 <PeterE> Fun.
05:34:53 <shapr> me too
05:35:02 <norpan> both both both
05:35:18 <shapr> bah, lucky you
05:35:25 <shapr> I've only gotten paid for three days of Haskell coding.
05:35:56 <PeterE> Just build the wxHaskell library.  It works, but not the OpenGL part.
05:36:47 <shapr> I've used the HOpenGL debian packages, they work well.
05:38:36 <shapr> nearby interesting touristy sights are lambdabot, an IRC bot written in Haskell
05:38:38 <shapr> @yow
05:38:38 <lambdabot> --- I have seen the FUN ---
05:39:02 <shapr> there's the Haskell Wiki, which is the less fluid communications medium for people here and elsewhere
05:39:19 <PeterE> shapr: Have you tried to build HOpenGL from source?
05:39:51 <shapr> yes, many times over a period of a few weeks, I gave up and used the debs.
05:40:18 <shapr> at the time I tried it, there were two flavors of Haskell OpenGL
05:40:27 <shapr> there was OpenGL and HOpenGL
05:40:40 <PeterE> The problem for me is the dependency, Green Card.
05:40:49 <shapr> you can get that from alistair reid's site.
05:41:11 <PeterE> I couldn't get it to build.
05:41:34 <PeterE> And how does it install anyway?
05:41:50 <shapr> which, green card or HOpenGL?
05:41:59 <PeterE> GC.
05:42:12 <shapr> I think I've always used it in-place
05:42:38 <shapr> there are also debian packages of greencard, so if you use debian, it's a lot easier to deal with.
05:43:17 <shapr> are you using Linux?
05:43:29 <PeterE> Hm, yes obvoiusly, but you see, I'm interested in building a recipe for GoboLinux.
05:43:35 <shapr> ah, ok
05:43:41 <juhp> the version of HOpenGL in ghc cvs doesn't require greencard anymore iirc
05:43:58 <shapr> you may want to grab the debs and dissect them, or you could ask the HOpenGL debian package maintainer.
05:44:29 <PeterE> Good idea.
05:44:53 <shapr> what sort of Haskell code do you write?
05:45:19 <PeterE> Nothing much yet.
05:46:05 <shapr> well, if you have any questions, feel free to ask
05:46:54 <PeterE> Where is HOpenGL in the GHC CVS?
05:47:34 <PeterE> Why is wxHaskell so heavy to compile with?
05:47:34 <shapr> I'd guess it's in the fptools tree
05:47:52 <PeterE> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/?
05:48:12 <PeterE> Found it.
05:48:17 <shapr> wxWidgets is heavy to begin with...
05:49:02 <PeterE> And the Hello.hs example compiles to 6MB.
05:49:15 <shapr> that's mostly because of the -split-objs stuff
05:49:44 <shapr> and because there's no dynamic linking with GHC
05:50:03 <shapr> meaning, the entire .hs file for a function is statically linked into the binary.
05:50:09 <dons> yeah there is... hs-plugins ;)
05:50:33 <shapr> dons: does that solve the 6mb hello.hs?
05:50:45 <shapr> PeterE: also, you can strip binaries to make them smaller.
05:50:50 <shapr> usually halves the size.
05:50:59 <dons> who has 6mb hello.hs ? it's more like 300k
05:51:08 <shapr> wxHaskell
05:51:19 <dons> (no, hs-plugins doesn't solve this, just splitss it across muliple .o)
05:51:45 <dons> fixing this is on the todo list of either ozone or me. but wolfgang thaller will beat us there I think
05:58:29 <PeterE> #du -h a.out
05:58:29 <PeterE> 6.4M    a.out
05:58:29 <PeterE> This is the HelloWorld.hs from the samples directory (it has two menus). After stripping it's 2.8MB.
05:58:49 * shapr thinks he just broke his mta
06:04:12 <shapr> konichiwa ikegami--san
06:04:20 <shapr> god morgon
06:05:18 <shapr> actually, I fixed my MTA and unstuck 98 msgs. urf.
06:05:31 <ikegami--> Hej, hej
06:05:47 <ikegami--> god afton ;)
06:06:08 * shapr grins
06:06:28 <PeterE> Cool.
06:08:01 <shapr> hiya LrdMtrod 
06:08:11 <shapr> are you learning Haskell? long time user?
06:08:34 <LrdMtrod> still a n00b
06:08:43 <shapr> have any questions?
06:10:24 <norpan> värst vad du var vänlig idag shapr
06:11:14 <shapr> well, I got energy or something.
06:15:52 <PeterE> In GHCi how do I bind a value at the top level?
06:16:38 <shapr> you can use let
06:16:39 <shapr> let x = 1
06:17:02 <PeterE> Ah, thanks.
06:17:30 <shapr> because GHCi is in a monadic context, you can also do handy tricks like 'big_string <- getContents ".zshrc"'
06:17:53 <shapr> any idea where I turn off subscriber-only for mailman?
06:18:53 <PeterE> shammahs: Hm, big_string 
06:19:06 * shapr looks at shammahs 
06:19:15 <shapr> shammahs: how's code?
06:19:21 <PeterE> shapr: Hm, big_string 
06:19:42 <PeterE> " big_string <- getContents ".zshrc""
06:19:50 <PeterE> didn't work.
06:19:56 <PeterE> Ah, there.
06:20:09 <shapr> lemme guess, you don't use zsh?
06:20:28 <PeterE> <interactive>:1:
06:20:28 <PeterE>     Couldn't match `IO String' against `t -> t1'
06:20:28 <PeterE> 	Expected type: IO String
06:20:28 <PeterE> 	Inferred type: t -> t1
06:20:28 <PeterE>     Probable cause: `getContents' is applied to too many arguments in the call
06:20:29 <PeterE> 	(getContents ".zshrc")
06:20:31 <PeterE>     In a 'do' expression: big_string <- getContents ".zshrc"
06:20:41 <shapr> oh
06:20:50 <shapr> my mistake, use readFile
06:21:16 <PeterE> Ah, getContents gets a handle.
06:21:27 <shapr> right, I don't use readFile much
06:21:33 <shapr> @type getContents
06:21:35 <lambdabot> getContents :: IO String
06:21:38 <shapr> @type readFile
06:21:39 <lambdabot> readFile :: FilePath -> IO String
06:22:07 <shapr> I think I'll add @browse soon enough
06:22:46 <PeterE> Are you a maintainer of GHCi?
06:23:10 <shapr> no, I was talking about lambdabot 
06:23:15 <shapr> I'm maintainer of lambdabot
06:23:26 <shapr> there's already :browse in GHCi
06:23:37 <PeterE> @type map
06:23:38 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
06:23:42 <PeterE> Cool.
06:24:18 <shapr> in fact, lambdabot calls GHCi to do that
06:24:24 <shapr> one thing that GHCi doesn't have is @index
06:24:27 <shapr> @index foldr
06:24:27 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
06:24:35 <shapr> that uses Haddock's index
06:26:05 <PeterE> I was thinking about if there were a Haskell equivalent to BRL (Beautiful Report Language)?
06:26:14 <shapr> I don't know BRL
06:26:51 <PeterE> Special Scheme syntax -> HTML.
06:27:27 <shapr> ah, there are several ways to do that in Haskell
06:28:01 <PeterE> [(define myname "Bruce")
06:28:01 <PeterE>  (define my "Bruce's")]
06:28:01 <PeterE> <pre>
06:28:01 <PeterE> This is [my] web page.
06:28:01 <PeterE> [myname myname
06:28:01 <PeterE>  myname myname]
06:28:03 <PeterE> [my] favorite person is [[your name here].
06:28:05 <PeterE> [my] favorite number is [(brl-random 2)].
06:28:07 <PeterE> </pre>
06:28:13 <shapr> right, I just looked at the examples.
06:28:41 <PeterE> It uses the square brackets as string delimiters.
06:29:14 <PeterE> ]this is a string[
06:29:31 <shapr> actually, PLog uses a syntax much like that
06:29:51 <shapr> HaXML generates significant datatypes from a DTD
06:30:21 <shapr> HXmlToolbox uses a generic tree structure and a separate validation step
06:30:30 <shapr> halipeto is pure templates
06:30:58 <shapr> WASH uses predefined monadic functions
06:31:51 <PeterE> I relly like the simplicity of BRL.
06:31:54 <shapr> y0 SyntaxNinja 
06:32:25 * shapr swears at postfix
06:33:13 * monochrom swears at *fix
06:33:32 <shapr> I can't send mail to iohcc@lists.scannedinavian.org
06:33:46 <shapr> that's irritating because I setup that list!
06:34:04 <thebug> danger will robinson!
06:36:11 <shapr> even scarier, Jeremy Gibbons *did* manage to send mail to that list.
06:36:14 <shapr> and I can't figure out how!
06:40:00 <PeterE> Got to go,  Thanks for the talk!
06:40:09 <shapr> sure, drop by anytime.
06:40:14 <shapr> talk all you want :-)
06:47:47 <SyntaxNinja> hi shapr; how's code?
06:48:15 <shapr> just doing sysadmin work at the moment
06:48:40 <shapr> how's code for you?
06:48:51 <shapr> SyntaxNinja: can you send a test message to iohcc@lists.scannedinavian.org ?
06:52:17 <SyntaxNinja> shapr: me too
06:53:51 <SyntaxNinja> shapr: done
06:54:03 <SyntaxNinja> shapr: hm. was that email sent out to a bunch of people?
06:54:05 * SyntaxNinja hopes not ;)
06:54:53 <shapr> no, I don't think it got through at all... *sigh*
06:59:19 <shapr> man, I wish I'd known about CUFP
06:59:35 <shapr> http://www.galois.com/cufp/
07:01:30 <kosmikus> shapr: would you have gone there?
07:01:49 <shapr> maybe
07:05:34 <shapr> I am very interested in applying Haskell commercially.
07:05:53 <shapr> how about a quick straw poll?
07:06:08 <shapr> what changes to Haskell would get you to use it more?
07:07:04 <shapr> more libraries? smaller executables? a real debugger? a fast and simple persistent store? more documentation and examples?
07:07:40 <shapr> anyone awake? :-)
07:08:00 <Igloo> shapr: Did Jeremy enter?
07:08:00 <monochrom> Lower prices.
07:08:07 <shapr> monochrom: on what?
07:08:11 <shapr> Igloo: yes
07:08:19 <shapr> Igloo: and I still don't know how :-)
07:08:23 <monochrom> And fresher vegetables and meats.
07:08:41 <monochrom> Oh you are not asking about supermarkets.
07:08:47 <Igloo> :-)
07:09:59 <shapr> I'd like more libraries, and better support for distributed processing.
07:10:39 <shapr> and I guess more examples.
07:10:56 <shapr> I think existing applications like Ginsu should be mined for libs.
07:11:06 <kosmikus> I'd like more (and better maintained) libraries
07:11:41 <kosmikus> Jeremy? where?
07:11:50 <shapr> Jeremy Gibbons, iohcc
07:12:01 <kosmikus> cool
07:13:31 <Igloo> The thing that would have the biggest immediate effect for me would be a sensible way to do web aps with Haskell
07:13:49 <shapr> yah, me too
07:14:12 <SyntaxNinja> shapr: fwiw, it bounced.
07:14:19 <shapr> ok, thanks.
07:14:40 * shapr grumbles at postfix
07:16:23 <musasabi> Getting Cabal working and packing lots of libraries.
07:25:09 <SyntaxNinja> cabal!!!
07:25:16 <shapr> hm, I think I know why some messages don't get through...
07:25:23 * SyntaxNinja hasn't received too many bug reports for cabal
07:25:36 <SyntaxNinja> except for the port-to-windows process.
07:26:44 <shapr> ok, I think it'll work now, mostly.
07:27:04 <shapr> can someone try sending a test message (or more) to iohcc@lists.scannedinavian.org ?
07:30:26 <thebug> sent
07:30:35 <SyntaxNinja> """
07:31:44 <shapr> thanks
07:32:00 <shapr> yay, it works!
07:32:19 <Lemmih> hurra!
07:32:23 <shapr> heh, entertaining mail from both :-)
07:32:51 <shapr> hiya Lemmih, what's up?
07:33:31 <SyntaxNinja> shapr: wow, that Lemmih-calling whistle is awesome.
07:33:52 * shapr snickers
07:44:41 <shapr> hoi goron 
07:44:46 <goron> hoi :)
07:45:17 <goron> Do you know whether there are xorg packages for Debian? Those slackers on the debian channel don't know...
07:45:45 <shapr> xorg packages are the fork from XFree86.org, right?
07:45:50 <goron> shapr: Yes
07:45:58 <shapr> if so, then the current debs are xorg, since they're DFSG compatible.
07:46:06 <shapr> they may not be the latest version though
07:46:21 <goron> shapr: AFAIK, it's XFRee
07:46:45 <goron> shapr: XFree 4.3, is pretty buggy...
07:46:46 <shapr> Version: 4.3.0.dfsg.1-6
07:46:58 <shapr> hmm, I dunno
07:47:20 <goron> shapr: xorg, is better (I tried it on another distro)...
07:47:23 <thebug> I thought 4.4 was when XFree86 became non-DFSG
07:47:34 <goron> thebug: Correct.
07:47:50 <thebug> the 4.3 ones in sid are XF86, not xorg
07:48:03 <thebug> dunno about testing <if they even have 4.3>
07:48:48 <shapr> I wonder if there's something about it on the X Strike Force page
07:48:57 <goron> How much does it hurts if I just compile it, and don't have it in the packagesystem? Will it just be overwritten the next time, it's installed as deb?
07:49:51 <thebug> goron: you can change where it gets installed to, like /opt/xorg or something
07:50:40 <thebug> if you're compiling it yourself
09:49:18 <cptchaos> shapr: apropos comercial application of haskell, I think if it was faster in "number crunching", a lot of technical projects could come attention (e.g. for ode solvers, etc) 
09:51:22 <cptchaos> hm, smaller binaries would be fine, for emedded stuff along with good standard binary IO libs 
10:36:45 * SyntaxNinja meeting &
11:14:20 <earthy> increase haskell's usefulness: more libs, more docs, stable binary interface
11:15:49 <shapr> now we just need to find specific instances and work on those.
11:16:05 <shapr> like, which libs, which docs, etc
11:16:23 <Igloo> The difficult problem is finding manhours, not tasks
11:17:22 <shapr> I think it would be easier for people to drop in and contribute code if we had a plan and some unit tests for code that doesn't yet exist.
11:40:24 <kaol> hmm, should I use parsec or happy? Maybe I should read their documentation and pick the one which feels more natural.
12:59:09 <jadrian> hello
12:59:19 <Lemmih> Hey
12:59:24 <jadrian> hi Lemmih  
12:59:41 <Lemmih> Hacking on something fun?
12:59:58 <jadrian> Theorem Proving stuff
13:00:23 <jadrian> right now implementing Martellis unification algorithm
13:02:50 <jadrian> I'm starting to use monads more, and I don't mean just State monads and such
13:03:02 <jadrian> but using the fact that some structures are Monads
13:03:56 <jadrian> I can't understand the decision for having (>>=) insteadof standard monadic function composition :-/
13:04:28 <Smerdyakov> What is "standard monadic function composition"?
13:04:37 <jadrian> mc       :: Monad m => (b->m c) -> (a->m b) -> (a->m c)
13:04:37 <jadrian> mc f g x = g x >>= f   
13:05:11 <jadrian> isn't this the usuall monadic composition in Category Theory?
13:05:20 <Smerdyakov> I wouldn't know. :)
13:05:34 <Smerdyakov> >>= maps well from do notation. Does mc?
13:05:37 <Marvin--> because bind isn't meant to compose functions, but monadic values?
13:05:52 <Lor> >>= is _practical_
13:06:06 <jadrian> Marvin--: yes my point exactly, I usually find actuall composition more useful
13:06:32 <Marvin--> I don't think I've seen a need for it yet
13:06:39 <jadrian> for instance when generalizing functions for their monadic equivalent
13:06:50 <Lor> That's the >>> operation for the kleisli arrows.
13:07:01 <jadrian> if you use composition, the monadic version looks quite different
13:09:37 <jadrian> one simple example for this is generalizing functions to return Maybe a instead of a
13:09:59 <jadrian> if you had:   h = f . g 
13:10:13 <jadrian> you'll end up with:  h x = g x >>= f
13:11:03 <jadrian> a simple change and now the order is different and you cannot use free point style anymore 
13:11:08 <Marvin--> or h x = f =<< g x  if you prefer
13:11:19 <TheHunter> or h = f . (g =<<)
13:11:37 <Smerdyakov> jadrian, now how do you write the code to print two strings in the IO monad?
13:11:37 <Lor> or just h = liftM f . g
13:12:05 <Lor> Oops, sorry.
13:12:22 <Marvin--> mc is easy to define in terms of >>=, whereas the definition of >>= in terms of mc is ugly
13:12:35 <jadrian> Smerdyakov: mapM putStrLn [s1,s2] ?
13:12:44 <Marvin--> plus, as Smerdyakov said, >>= maps extremely well to do notation
13:13:06 <jadrian> Marvin--: is you have a point there...
13:14:02 <jadrian> I still can't help but think of composition as an elementary operation
13:14:30 <Marvin--> what is elementary is just what you decide to use
13:14:32 * TheHunter thinks there should be a default definition of (>>=) in terms of join
13:14:49 <Marvin--> the join + fmap combo is just as elementary'
13:14:52 <Smerdyakov> jadrian, what about if you are mixing different function calls executed only "for side effects"?
13:15:39 <Smerdyakov> jadrian, it seems like you'll be forced to introduce extraneous closures.
13:18:00 <Riastradh> The Monad type class should just include all five of the monadic operators -- mu, eta, extend, compose, & map --, with suitable definitions of each other in terms of the various different sets of elementary primitives, and let implementors of the Monad instances decide themselves what set of operations are primitive to their type.
13:30:38 <norpan> seems resonable
13:31:06 <norpan> i never understood why map is not in monad
13:31:40 <Lor> it's called fmap
13:31:54 <norpan> it's not in monad, it's in functor
13:33:45 <Lor> functor is in monad :)
13:35:17 <Lor> In practice it is: fmap = liftM
13:42:48 <norpan> functor is not in monad in the prelude, of course you could define it
13:43:28 <norpan> map was in monad before haskell 98 though
13:43:36 <norpan> it was removed for some reason
13:45:16 <jadrian> I don't know much about pre-H98
13:45:31 <jadrian> but I think some changes were meant to simplify error messages
13:45:34 <norpan> yes
13:46:07 <norpan> but that could be handled in the compiler i think
13:46:15 <norpan> with special cases for List
13:46:42 <norpan> well well
13:46:49 <norpan> it's not a problem in practice
14:53:49 <jadrian> hmmm, no choice :: Set a -> a ...
14:54:18 <jadrian> wait nevermind, head . setToList  does the trick
14:55:15 <jadrian> I was afraid there was no Axiom of Choice for us in Data.Set :)
15:16:11 <roconnor_> Set requires Ord!
15:19:21 <roconnor> Hmm, I wonder if everything that is an instance of Eq should be an instance of Ord?
15:19:54 <stefan_> roconnor: that would not make sense for all data types
15:19:57 <jadrian> roconnor: and? 
15:20:11 <roconnor> Have an example?
15:20:20 <musasabi> having Eq => Ord would make no sense.
15:20:24 <jadrian> roconnor: ord in haskell doesn't stand for total order
15:20:28 <jadrian> roconnor: opss
15:20:35 <jadrian> roconnor: ord in haskell doesn't stand for *well order*
15:20:55 <stefan_> roconnor: data Term = Var String | Abs String Term | App Term Term deriving (Eq)
15:21:18 <jadrian> roconnor: so having Sets as an instance of Ord doesn't imply you're assuming the axiom of choice
15:21:20 <roconnor> stefan_> Might as well add deriving Ord
15:21:37 <stefan_> roconnor: yeah, but would it make sense?
15:21:53 <stefan_> roconnor: why would you want to do that?
15:21:57 <roconnor> Does  LT < GT make sense?
15:22:15 <roconnor> You could put Terms into sets if you do that.
15:23:22 <stefan_> Ord facilitates *certain* collection implementations, for instance Set ...
15:24:09 <musasabi> jadrian: iirc Ord of haskell *is* a total order.
15:24:20 <jadrian> musasabi: yes what I said was,
15:24:28 <jadrian> <jadrian> roconnor: ord in haskell doesn't stand for *well order*
15:24:40 <jadrian> musasabi: I said total order the 1st time by mistake :)
15:24:52 <jadrian> musasabi: well order and total order are different things
15:24:53 <musasabi> sorry.
15:25:07 <musasabi> just too tired and slow reading logs.
15:25:08 <stefan_> but what if I just want to test for equality and nothing more ... should I than just derive Ord ... and why just Ord ... and not other derivable classes as well?
15:25:26 <jadrian> musasabi: and total order on every set does not imply you're using the Axiom of Choice
15:26:27 <jadrian> of course we have setToList :)
15:26:33 <roconnor> What can we derive, Eq, Ord, Show.  Anything else?
15:27:52 <musasabi> jadrian: true.
15:28:49 <jadrian> I just hope  setChoice = head . setToList, is constant time
15:28:51 <jadrian> but it should be
15:28:52 <roconnor> If you don't make your data type deriving Ord, you are telling the world: Hey, I don't want this type used in a Set.
15:29:01 <roconnor> Seems like a poor thing to be saying.
15:29:25 <stefan_> roconnor: Eq, Ord, Bounded, Enum, Read, Show
15:29:42 <jadrian> roconnor: nope, it just means you cannot use the GHC Data.Set ADT
15:29:47 <roconnor> Well, not everthing can be Bounded.
15:29:59 <jadrian> roconnor: you can have sets without Ord 
15:30:13 <roconnor> Sets without Ord will suck.
15:30:19 <musasabi> jadrian: how would you implement efficient sets based on Eq only?
15:30:33 <jadrian> musasabi: I didn't say efficient :)
15:30:43 <stefan_> roconnor: what makes you think that?
15:31:12 <musasabi> stefan_: please do tell ;)
15:31:24 <roconnor> If you don't make your data type deriving Ord, you are telling the world: Hey, I don't want you to have an efficent Set over my type.  Seems like a poor thing to say.
15:31:41 <jadrian> roconnor: nope
15:31:56 <musasabi> roconnor: can't you later make it an instance?
15:31:58 <jadrian> roconnor: GHC Ord is a total order right?
15:32:03 <roconnor> I suppose your compiler could have a primative Set that uses an ordering under the hood.
15:32:10 <stefan_> roconnor: what makes you think that you can only implement efficient sets with Ord?
15:32:14 <roconnor> Ord is total, yes.
15:32:16 <jadrian> roconnor: what if you want your datatype to be a pre-order?
15:32:46 <jadrian> roconnor: or a partial order
15:32:57 <musasabi> stefan_: It is true Ord is not necessary, but something like it is. (Or please tell about the efficient sets with only Eq)
15:32:59 <jadrian> roconnor: then you cannot use Ord
15:33:36 <roconnor> Right, you can't use Ord for your partial ordering, so you might as well make Ord your random ordering, and implement some PO class.
15:34:02 * stefan_ thinks ...
15:34:04 <musasabi> jadrian: although you can create bijection from your datatype to an ordered datatype and thus obtain Ord...
15:34:07 <Philippa> roconnor: sorry if I confused you a bit on clf the other day?
15:34:22 <roconnor> clf?
15:34:28 <Philippa> comp.lang.functional
15:34:37 <jadrian> musasabi: bijection? you mean isomorphis?
15:34:38 <roconnor> comp.lang.functions?
15:34:44 <roconnor> er functional?
15:34:48 <Philippa> yeah
15:34:52 <jadrian> musasabi: bijection is too week
15:34:54 <roconnor> the news group?
15:34:55 * shapr subscribes to comp.lang.dysfunctional
15:34:59 <Philippa> right
15:35:02 <Philippa> shapr: heh
15:35:08 <roconnor> You didn't confuse me, I don't read it.
15:35:08 <stefan_> Philippa, roconnor: which thread?
15:35:22 <roconnor> maybe I should though.
15:35:23 <Philippa> ah, in that case I've confused you with somebody of a similar name :-)
15:35:29 <musasabi> jadrian: true again.
15:35:30 <jadrian> roconnor: another simple example would be functions
15:35:40 * Philippa posted some partly broken stuff about a week ago
15:35:44 <jadrian> roconnor: how would you define Ord for functions
15:35:47 <roconnor> Function's don't implement Eq.  That was one of my requirements.
15:35:56 <jadrian> roconnor: right! opss
15:36:31 <Philippa> roconnor: assuming I have seen you around usenet, where'd be likely?
15:36:59 <jadrian> roconnor: but I think pre order is a good example
15:37:03 <Philippa> or am I just suffering dain bramage?
15:37:09 * shapr is!
15:37:13 <roconnor> I don't hang out on usenet much these days.  I made a post to comp.text.xml a few months ago asking some questions.
15:37:26 <Philippa> dain bramage it is, then...
15:37:46 <jadrian> roconnor: in a PO you can have a>=b, b>=a and a /= b
15:38:20 <roconnor> I know, but Ord must be total.
15:38:23 <jadrian> roconnor: I don't understand what you mean by having PO my random Ordering
15:38:33 <jadrian> roconnor: yes that's my point
15:38:57 <Philippa> jadrian: I believe he meant arbitrary, eg sorted by address in memory?
15:39:07 <jadrian> but what's the point?
15:39:18 <jadrian> wouldn't that be confusing
15:39:31 <roconnor> jadrian.  I mean that you make a data type that is ``naturally'' a PO.  But since Ord is total, you can't use < to represent that order.  So just add deriving Ord, and when you want to use your PO, implement the PO class with whatever symbol it uses.
15:39:58 <Philippa> jadrian: depends what you want an order for
15:39:59 <roconnor> Leave < for the random order that deriving Ord gives you, and never use it for anything.
15:40:15 <roconnor> (except for use in Data.Set)
15:40:35 <jadrian> roconnor: yes but that might end up being really confusing because someone using that lib might think that you're dealing with a total order
15:40:40 <jadrian> roconnor: when you are not
15:40:43 <roconnor> Oh
15:40:46 <roconnor> hmmmm
15:41:03 <roconnor> I suppose that is a somewhat reasonable point.
15:41:04 <jadrian> roconnor: or they may se  >= and think this is the PO relation
15:41:35 <jadrian> I mean if I say  A is a PO, and write  a,b in A : a >= b
15:41:57 <jadrian> I'd think I'm using the PO >=
15:42:33 <roconnor> You can't use >= for PO.  >= is bound to Ord.
15:42:41 <roconnor> oh wait
15:42:48 <roconnor> yeah, Now I see what you are saying
15:42:53 <jesse99> how does this sound for a pure functional language that uses exceptions: for a given program run a function called with the same arguments always 1) returns the same value 2) returns the same exception or 3) fails to terminate
15:44:27 <Philippa> jesse99: you mean exceptions are part of a function's type.
15:45:03 <jesse99> not neccesarily, they could do a non-local goto (this is with a strict language)
15:46:23 <jesse99> the big problem with exceptions in functional languages is that they expose evaluation order which can lead to non-determinism
15:47:08 <Philippa> boils down to ifs all over the place though
15:47:09 <roconnor> I wonder if Set should be a primiative of the langauge, so that it will always be efficent.
15:47:34 <jesse99> not with my definition Philippa, if a function throws a catch block somewhrre catches it
15:47:39 * stefan_ favours as few primitives as possible
15:47:40 <roconnor> But you would want to restrict it so that it isn't over all types.
15:48:18 <roconnor> Of course, Set is a stupid name for the Data.Set type.  It should be called FiniteSet.
15:48:34 <Philippa> jesse99: sure. But a catch block is just something that knows how to do something with exceptions other than return them
15:48:37 <roconnor> newtypedata Set A = A -> Bool is set
15:48:51 <jesse99> the worst thing I can see is that enabling optimizations could change the result of a program
15:49:01 <roconnor> er, there needs to be an (Eq A) restrictions I suppose.
15:49:23 <Philippa> not in a strict language. But yeah, it could in a lazy one
15:49:24 <jesse99> but there are no if's Philippa: the rror handling code is cleanly seprated from the normal code as it should be
15:49:36 <Philippa> jesse99: there's the equivalent of ifs everywhere
15:50:19 <jesse99> even in a strict language the results may change, depending on which argument the compiler chooses to evaluated 1st
15:50:37 <jesse99> not in the code that prgrammers write
15:51:13 <Philippa> in a strict language the compiler has no choice which argument to evaluate first - there's only ever one
15:51:28 <Philippa> since when does the syntax the coder sees matter for semantic purposes?
15:51:53 <Philippa> there is a translation that maintains purity that is equivalent-in-effect to the goto translation. Therefore, the goto translation maintains purity
15:52:00 <jesse99> it matters if the programmre has to litter his code with if's everywhere an error may occur
15:52:43 <Philippa> he doesn't
15:53:10 <Philippa> no more than somebody using the Maybe or Either monads has to do so
15:53:14 <Riastradh> Philippa, huh?  There's only ever one argument to evaluate first?
15:53:24 <Philippa> Riastradh: currying is your friend
15:53:29 <Riastradh> You're still wrong.
15:53:32 <Philippa> oh, OK, I guess tupling
15:53:35 <Riastradh> There's both an argument and a function to evaluate first.
15:53:49 <Philippa> point
15:56:28 <jesse99> well the language i'm considering is eager evaluation (ie functions may have more than one argument)
15:57:40 <Philippa> OK. At this point yeah, you're right and there's been a lot of messing about working out how to handle it
15:58:25 <jesse99> i've researched it a fair amount, didnt really see anything I liked tho
15:58:53 <Philippa> that's 'cos there's no real solution bar constraining the evaluation order
15:59:34 <jesse99> well i'm trying to dodge that by allowing different runs of the program to return different results
15:59:54 <jesse99> which I think still produces referential transparency
16:00:13 <Philippa> does so whenever nothing breaks, certainly
16:00:23 <jesse99> breaks?
16:01:06 <Philippa> throws an exception. Assuming, of course, exceptions are for when things break
16:01:36 <jesse99> even if there's an exception the function will always raise the same exception for the same input (for the same program run)
16:02:17 <Philippa> yeah, but if you want to talk about for the same run /everything/ does that
16:02:32 <Philippa> that's pretty much what "same run" means
16:02:39 <jesse99> parallel evaluation doesnt neccesarily
16:03:21 <jesse99> spec evaluation too
16:03:59 <Philippa> for parallel evaluation there's still a concept of a run, it's just more involved. Not what you're trying to get at though, I grant
16:05:47 <larsl> Can Haskell do operator overloading of +, -, * etc?
16:06:04 <roconnor> larsl: Sort-of
16:06:34 <Philippa> by ensuring the original declarations don't happen. Can't remember if they're in the prelude or actually built-in
16:07:30 <larsl> So if I have a data type "data Matrix = Mtr a b c d" and I want to do matrix addition with '+', how would I define that?
16:07:52 <larsl> Ops - "data Matrix a = Mtr a a a a"
16:08:08 <Philippa> with great difficulty atm, IIRC
16:08:13 <roconnor> larsl: That is incompatible with the standard prelude.
16:08:16 <roconnor> :-(
16:08:21 <larsl> Hm.
16:08:46 <roconnor> However you are not required to import (all of) the standard prelude, so there are ways around it.
16:08:53 <roconnor> At least in theory.
16:09:11 <stefan_> @type (+)
16:09:13 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
16:09:31 <roconnor> @info Num
16:09:32 <lambdabot> -- Num is a class
16:09:32 <lambdabot> class (Eq a, Show a) => Num a where {
16:09:32 <lambdabot>     (-) :: a -> a -> a {- has default method -};
16:09:32 <lambdabot>     (*) :: a -> a -> a;
16:09:32 <lambdabot>     (+) :: a -> a -> a;
16:09:33 <lambdabot>     negate :: a -> a {- has default method -};
16:09:34 <jadrian> roconnor: that's not something people should teach newbies :)
16:09:35 <lambdabot>     signum :: a -> a;
16:09:37 <lambdabot>     abs :: a -> a;
16:09:39 <lambdabot>     fromInteger :: Integer -> a;
16:10:03 <roconnor> Wow, Num requires Show.  That's silly.
16:10:06 <stefan_> just explain ad-hoc polymorphism
16:10:22 <larsl> Can I make my Matrix a Num somehow?
16:10:57 <roconnor> larsl: You would need to implment *.  It would work if you are only dealing with square matrices.
16:11:35 <roconnor> well, you would also need to implement abs, and signum.
16:11:38 <roconnor> hmmm
16:11:39 <larsl> So + can only be defined for Num, and Num must have *, abs, sign etc?
16:12:04 <jadrian> what is the signum?
16:12:08 <stefan_> larsl: but why not take the easy road and define your own operator, for instance <+>
16:12:10 <roconnor> yeah,  I would be tempted to use another operator for Matrices, like >+<, or something.
16:12:41 <roconnor> signnum returns the sign of the number.  either -1, 0 or 1.
16:12:43 <stefan_> jadrian: it indicates the sign of a value
16:13:04 <jadrian> stefan_: that's what I thought but is there a specification?
16:13:09 <jadrian> stefan_: oh wait
16:13:14 <jadrian> stefan_: I think I got it
16:13:22 <jadrian> stefan_: was wondering what it did for complex numbers
16:13:45 <jadrian> stefan_: it just returns the unit vector with the same direction
16:14:04 <stefan_> jadrian: exactly
16:14:29 <jadrian> signum is not such a great name then though, is it? :)
16:15:07 <roconnor> Num isn't the best possible class.
17:55:37 <stepcut> chmod -x $( which chmod )
17:55:41 <stepcut> :p
18:16:47 * roconnor ponders the data-type of first-order logic.
18:18:38 <thebug> well, the answer is 42, so don't spend too long on that ponderance :)
18:33:28 <jpgil-cl> Hello.
18:33:49 <thebug> hello jpgil-cl 
18:34:40 * jpgil-cl is another wanna-be-haskell, with some weeks of study yet in his back.
18:35:16 <jpgil-cl> I'm in the right place to make somewhat novice questions?
18:36:22 <thebug> sure! <though I admit, I likely won't be much help, being quite new to haskell as well>
18:37:11 <jpgil-cl> The whole thing is... I found haskell by just luck, and after reading a bit I got in love with functional paradigm
18:37:34 <jpgil-cl> So, the last two months I've been studying haskell, lambda and that sort of things
18:37:34 <thebug> yes, it is quite elegent, isn't it?
18:38:00 <jpgil-cl> but I haven't download Hugs or any other compiler / interpeter.
18:38:06 <roconnor> Haskell is the second-best language out there.
18:38:16 * jpgil-cl really elegant! Brief and precise
18:38:55 <thebug> roconnor: curious, what would you say is the first?
18:39:12 <jpgil-cl> Huh... CAML?   :)
18:39:16 <roconnor> thebug: I'm not sure, but whatever it is, it has dependant types.
18:39:20 <thebug> hehe
18:39:33 <thebug> INTERCAL?
18:39:47 <roconnor> I don't think INTERCAL has dependant types.
18:40:09 <thebug> iirc, intercal is more like bludgeoning yourself, because you enjoy it ;)
18:40:23 <roconnor> Someday (Vector Double 3) will be a type.
18:40:33 * jpgil-cl wonders if the 2nd best language is only for Linux world.
18:40:47 <thebug> jpgil-cl: you can use ghc[i] on win32
18:41:06 <jpgil-cl> and it's versatile as a Linux compiler?
18:41:13 <thebug> iirc, there's also a Hugs for win32
18:41:17 <roconnor> yeah, ghci has replaced hugs for me.
18:41:23 <jpgil-cl> I mean, for finished works, a.k.a. "ready to sell"
18:41:59 <thebug> likely you wouldn't want to ship software with Hugs, you'd compile it with ghc or nhc98
18:42:08 <thebug> and ship the executables
18:42:24 <jpgil-cl> Good! We are close to my questions...
18:42:37 <jpgil-cl> I've found a lot about Haskell itself, but
18:42:51 <jpgil-cl> I haven't read about interface in Haskell.
18:43:01 <thebug> 'interface' ?
18:43:07 <jpgil-cl> (apart from GTK, for Linux).
18:43:09 <roconnor> like IO?
18:43:29 <roconnor> or like windowing
18:43:31 <jpgil-cl> Yes, IO for dummies. I meant windows, whistles and bells.
18:43:32 <thebug> there's wxhaskell
18:43:49 <Riastradh> Is Fudgets still maintained?
18:44:02 <thebug> uses wxwindows [gfx toolkit, like GTK] for cross-platform mumble mumble
18:44:17 <jpgil-cl> Look, there are people at university who barely knows how to turn off a PC. They didn't like an efficient but cryptic system.
18:44:51 * jpgil-cl is going to Google to seek something about wxwindows
18:44:58 <roconnor> I'd say that a good windowing interface is an open problem in Haskell, but wxhaskell probably works for now.
18:45:16 <thebug> well, wxwindows is written in C or C++, but it has haskell bindings [called wxhaskell]
18:46:29 <jpgil-cl> ... it says "An open source C++ GUI framework to make cross-platform programming child's play". If true, that's a good news.
18:47:08 <juhp> jpgil-cl: you may also want to try gtk2hs
18:47:24 <roconnor> Actually a good windowing interface is probably an open problem in any language.
18:47:26 <jpgil-cl> for windows environment?
18:47:38 * jpgil-cl meant MS Windows
18:48:07 <juhp> jpgil-cl: it should work on both *nux and windows
18:48:41 * juhp only runs linux
18:48:48 <jpgil-cl> Ok. I'm a veteran in web environment but a novice in desktop software. That's why I say silly questions...
18:50:38 <jpgil-cl> The fact is, the only software I've seen (in Haskell) for Windows is "Paradrop troopers" game, and visually isn't too much amazing :)
19:17:58 <monochrom> C++ programming is child play?
19:41:18 <jpgil-huinca> Regarding GHCi.... it's part of GHC binary? I'm downloading it, but I'm not sure and isn't in FAQ.
19:41:52 <thebug> ghc is the compiler, ghci is the interpreter
19:49:09 <jpgil-huinca> Thanks thebug. And, I found in "HaWiki/HaskellNewbie" that GHCi comes inside the binary GHC package. I'll post that somewhere because isn't a trivila question
19:50:16 <thebug> I think haskell.org/ghc already has that information
19:50:44 <thebug> and if it's already on HaWiki, I know it's in good hands :)
19:50:51 <jpgil-huinca> I digged on it, but I found nothing.
19:51:05 * jpgil-huinca dig in /ghc
19:51:29 <thebug> you can actually invoke ghc itself with a switch that will make it do the interpreter rather than the compiler
19:51:32 <jpgil-huinca> Anyway, I'll add that piece of info in HaWiki.
19:51:43 <jpgil-huinca> Really? Thanks again.
19:52:06 <tautologico> ghc --interactive
19:52:15 <thebug> ^ yep yep
19:52:16 <thebug> :)
19:52:20 <tautologico> ghci is just a wrapper to ghc --interactive
19:52:40 <jpgil-huinca> interactive is very close to interpeter anyway
19:53:11 <jpgil-huinca> tatutologico, i speak spanish also (cl is for Chile). How big is the spanish-spoken haskell community?
19:53:38 <tautologico> jpgil-huinca, I'm brazilian
19:53:57 * jpgil-huinca notes that he's not jpgil-cl anymore... IRC reconnection :)
19:54:13 <jpgil-huinca> Brazil, well, not too much far 
19:54:20 <tautologico> as for Brazil, there are some academics involved with it... 
19:55:05 <shapr> I thought cl was for common lisp?
19:55:09 <shapr> should I be shapr-fp ?
19:55:19 <Riastradh> No, shapr-se.
19:55:24 <shapr> oh right
19:55:28 <shapr> shapr.se ?
19:55:32 <thebug> welcome back shapr :)
19:55:38 <shapr> but I don't have .se citizenship? does that count?
19:55:41 <shapr> greetings thebug 
19:55:46 <jpgil-cl> shapr... I read that nick few minutes ago...
19:55:55 <Riastradh> I dunno.  It's better than having a -us suffix, anyway.
19:56:14 <jpgil-cl> Good, I'm amid a bunch of haskell-stars :)
19:56:21 <shapr> jpgil-cl: greetings, I'm shapr. nice to meet you.
19:56:41 <shapr> jpgil-cl: where did you read that nick? someplace nifty?
19:57:10 <jpgil-cl> Hello :)  jpgil-cl means "Juan Pablo Gil - Chile". Not too creative, I'm afraid
19:57:24 <jpgil-cl> "shapr", ina web page about haskell
19:57:44 <shapr> ah, cool
19:57:46 <jpgil-cl> I'm studying it from google, HaWiki, haskell.org and many other sites.
19:58:08 <jpgil-cl> But I can't remember the exact page where I found it. Err.. found you.
19:58:41 <shapr> well, I'm around a few places.
19:59:14 <shapr> so, how much have you used Haskell?
19:59:18 <shapr> do you have any questions?
19:59:29 <shapr> I'm about to go to sleep, but I can answer a few questions if you have some.
19:59:55 <jpgil-cl> Yes, I've thousand of questions! But I guess that I've to study myself a bit more before come here and ask 
20:00:09 <shapr> feel free to jump in and ask anything you can think of
20:00:22 <shapr> I think self-study is for those times when no one on #haskell is awake :-)
20:00:24 <jpgil-cl> By now, I know where to download a Windows Framework to write my first hello world programr
20:00:39 <thebug> 'Windows Framework' ?
20:00:51 <jpgil-cl> wxHaskell + GHC
20:00:57 <shapr> yes, wxHaskell is a good choice
20:00:59 <jpgil-cl> call it as you want :)
20:01:19 <thebug> you can download ghc from haskell.org/ghc, as to precompiled wxhaskell for win32, I have no clue
20:01:24 <jpgil-cl> I feel I need something a bit more powerful than Hugs98
20:01:36 <jpgil-cl> I'm oing it already, thanks
20:01:55 <shapr> are you using win32 or linux?
20:01:59 * jpgil-cl uses 56.6 modem, and GHC is 40MB.... the whole night!
20:02:01 <shapr> or maybe mac os x or beos?
20:02:03 <jpgil-cl> Windows.
20:02:08 <jpgil-cl> I'm stuck in windows.
20:02:09 <shapr> yow, 56.6
20:02:14 <shapr> why are you stick in windows?
20:02:15 <thebug> @yow
20:02:16 <lambdabot> OMNIVERSAL AWARENESS??  Oh, YEH!!  First you need 4 GALLONS of JELL-O
20:02:16 <lambdabot>  and a BIG WRENCH!!...  I think you drop th'WRENCH in the JELL-O as if
20:02:16 <lambdabot>  it was a FLAVOR, or an INGREDIENT...  ...or...I...um...  WHERE'S the
20:02:16 <lambdabot>  WASHING MACHINES?
20:02:20 <shapr> can you switch to Linux?
20:02:25 <shapr> oh, lambdabot is written in Haskell
20:02:32 <shapr> lambdabot is our local code-toy
20:02:41 <jpgil-cl> I could but I don't want. I prefer to spend my time learning Haskell
20:02:48 <thebug> you said 'yow', I felt compelled to inform lambdabot :)
20:02:57 * jpgil-cl looks at lambdabot.. nice thing
20:03:17 <shapr> it's a lot harder to learn about programming in windows.
20:03:23 <shapr> that's my experience at least.
20:03:25 * thebug concurs
20:03:41 <shapr> for one thing, programming is much more exposed in linux
20:03:42 <thebug> it's doable though, certainly don't take those as discouraging statements
20:03:46 <shapr> you can do shell scripting for example
20:03:59 <jpgil-cl> I've worked on PHP / MySQL / Apache / RedHat for nearly 8 years, but I never learn how to administrate Linux systems from scratch.
20:04:03 <shapr> right, I've been learning programming for twenty years, and there's still so much more fun stuff to know!
20:04:09 <jpgil-cl> Yes, I know bourne shell
20:04:40 <shapr> admin from scratch isn't much harder than maintenance
20:05:10 <tautologico> well, there's a glaring problem in windows, haskell-mode doesn't work with GNU emacs
20:05:35 <thebug> then again, that's only a problem if you use emacs
20:05:49 <jpgil-cl> Fortunately I'm still far of those problems, tautologico.
20:06:09 <tautologico> I downloaded XEmacs once because of that
20:06:16 <jpgil-cl> Also, I want to learn Haskell to develop for the windows world, at least the first years.
20:06:34 <tautologico> but there's some initial Haskell support in eclipse
20:06:34 <shapr> happily, you can do both
20:07:02 <jpgil-cl> I read the same in wtHaskell, shapr. Good news, I've to do the half of work :)
20:07:11 <shapr> developing for Haskell is 99% the same on win32 and linux
20:08:19 <tautologico> wxHaskell is cool, but I haven't found out how to strip windows executables :)
20:08:58 <jpgil-cl> People, do you expect an increasing popularity of Haskell in coming years? With few months reading about, I feel that is's growing.
20:09:03 <thebug> tautologico: I'd be willing to bet mingw has the 'strip' tool
20:09:04 <shapr> I think so
20:09:13 <thebug> and I know cygwin does
20:09:21 <tautologico> yes, cygwin has it
20:09:22 <shapr> I think Haskell will have a steady increase.
20:09:55 <thebug> tautologico: then what's the problem with stripping executables?
20:10:32 <tautologico> I'm not sure about mingw and don't want to generate cygwin exes
20:10:34 <shapr> jpgil-cl: this channel has gone from zero to sometimes over one hundred in less than three years.
20:10:38 <shapr> I think that's a good sign.
20:10:48 <jpgil-cl> Yes it is
20:11:26 <jpgil-cl> Also the ratio newbies/expert is a good indicator. Today it seems 1/3 (active users)
20:11:39 <tautologico> anyway, I don't care all that much... I did only experiments with wxHaskell, executables are huge
20:12:15 * jpgil-cl wonders what "huge" means for lambda-guys
20:12:39 <tautologico> I remember a hello, world program having 8 mb or so...
20:13:11 <Riastradh> The overhead probably becomes littler & littler as your app becomes bigger & bigger.
20:13:12 <thebug> tautologico: I think you ought to be able to strip any executable you like using the mingw/cygwin tools
20:13:15 <tautologico> in linux, after stripping and compressing, it got down to less than a mb, if I remember correctly
20:13:51 <tautologico> Riastradh, yes, sure, it is that big because all of wxHaskell and wxWidgets are linked statically
20:14:09 <jpgil-cl> Not common libraries?
20:15:10 <jpgil-cl> I use AVG, that uses wxWidget. I've to install it again for every wxHaskell executable?
20:15:59 <thebug> if they're statically linked into your haskell programs, no
20:29:31 <tautologico> gtg... good night
20:29:44 <jpgil-cl> Bye tutologico
22:14:30 <jpgil-cl> @listcommands
22:14:30 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
22:14:30 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
22:14:30 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
22:14:30 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
22:14:30 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
22:14:31 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
22:14:33 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
22:14:35 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
22:14:37 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
22:15:47 <Riastradh> @stepcut
22:15:48 <lambdabot> juicy bits of code
22:16:15 <Riastradh> @musasabi
22:16:15 <lambdabot> Einar
22:16:23 <Riastradh> @moo
22:16:24 <lambdabot>          (__)
22:16:24 <lambdabot>          (oo)
22:16:24 <lambdabot>    /------\/
22:16:24 <lambdabot>   / |    ||
22:16:24 <lambdabot>  *  /\---/\
22:16:25 <lambdabot>     ~~   ~~
22:16:27 <lambdabot> ...."Have you mooed today?"...
22:16:35 <Riastradh> @shapr
22:16:36 <lambdabot> needs sleep
22:16:39 <jpgil-cl> ups... sorry, I was /msg lambdabot in another window :S
22:17:47 <jpgil-cl> A very nice way to understand haskell and this channel is to review past logs in http://meme.b9.com/ ...
