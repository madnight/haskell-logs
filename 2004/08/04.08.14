00:31:07 <musasabi> Is there a way to dump data structures to disk and read them back in with GHC?
00:31:22 <musasabi> I care only about speed, not how they are on disc.
00:33:02 <sazzle> haxml?
00:33:51 <musasabi> Is it that fast? (show seemed *very* slow)
00:34:45 <sazzle> no idea
00:51:38 <stefan_> musasabi: you could serialize your values to bits yourself and then write them to disk ... it shouldn't be that hard ...
00:53:00 <stefan_> musasabi: you will need some what to write and read binary files ... the serialization and deserialization itsself is very well behaved: just encode every choice between two constructors by a bit
00:54:46 <cm> is this the "get stuff done" factor "scripting languages" appear to have?
00:55:56 <stefan_> musasabi: this way of encoding and decoding is very popular in the literature on generic programming. in GHC you could use derivable type class to accomplish it ...if you have a small number of type constructors, you might as well write the functions by hand and optimize them
00:55:59 <musasabi> stefan_: something for automatically writing out algebrachic types would be quite enough.
00:57:33 <stefan_> musasabi: if you are willing to read through the GH stuff, you might find parts of this paper interesting: http://www.cs.uu.nl/~johanj/publications/GH.pdf
00:59:04 <stefan_> musasabi: hint: you could gain better results by encoding the structure of a data type as a balanced tree, rather than a right-nested tree as is done in the paper
00:59:54 <cm> duh
00:59:59 * musasabi reads that
01:01:08 <stefan_> musasabi: http://www.cs.chalmers.se/~patrikj/poly/dc/DataCompression.ps.gz is perhaps a better source, the material in the other paper is derived from this one
02:34:12 <shapr> greetings
02:34:20 <shapr> wassup?
02:38:31 <arjanb> goedemorgen shapr
02:39:16 <shapr> hoi, hoe gaat het?
02:41:21 <arjanb> :-)
02:53:06 <shapr> yay, shell/simple works with the latest hs-plugins
02:53:11 <shapr> latest cvs, that is
02:53:27 <shapr> makes me wonder if it was in fact userError
02:53:32 <shapr> @type userError
02:53:34 <lambdabot> userError :: String -> IOError
02:53:36 <shapr> @yow !
02:53:37 <lambdabot> ..  I feel..  JUGULAR..
02:53:40 <shapr> lambdabot: @hello
02:53:40 <lambdabot> Hello world. 
02:53:42 <shapr> hmm
02:53:59 <shapr> @yow
02:54:00 <lambdabot> I hope you millionaires are having fun!  I just invested half
02:54:00 <lambdabot>  your life savings in yeast!!
02:54:01 <shapr> @hello
02:54:01 <lambdabot> Hello world. 
02:54:04 <shapr> huh
02:54:13 <shapr> weird
02:54:47 <kaol> @yow
02:54:48 <lambdabot> SANTA CLAUS comes down a FIRE ESCAPE wearing bright
02:54:48 <lambdabot>  blue LEG WARMERS..  He scrubs the POPE with a mild
02:54:48 <lambdabot>  soap or detergent for 15 minutes, starring JANE FONDA!!
02:54:55 <shapr> wonder what happened
02:55:04 <shapr> @type userError
02:55:05 <lambdabot> userError :: String -> IOError
02:55:33 <shapr> huh, I thought it was "Nothing :: Maybe Clue"
02:55:55 <Lemmih> eh?
02:56:19 <shapr> like, user error... I need a to get a clue :-)
02:57:25 <Lemmih> Am I the only person using wxHaskell on a windows box?
02:57:47 <shapr> you could ask on the mailing list
02:58:57 <shapr> ok, if shell/simple works, should I write my own example from the ground up, or should I try to hack this into lambdabot?
02:59:41 <Lemmih> But mailing lists are scary.
02:59:59 <shapr> they can be nice too
03:02:25 * shapr dances happily
03:02:29 <shapr> makeWith works!
03:02:35 <shapr> hoi ron_ 
03:02:40 <shapr> how's the Low Country?
03:03:01 <shapr> foo
03:03:07 <ron_> shapr: Great, nice weather, and how are you doing?
03:03:16 <shapr> I'm doing well, my code is working!
03:03:43 <shapr> actually, it's dons' code, but his code is working for me, so I'm happy.
03:04:43 <shapr> ron_: are you learning Haskell? or maybe a long time user?
03:04:57 <ron_> shapr: I am that goron character :)
03:05:03 <shapr> oh, hello goron
03:05:18 <shapr> greetings from the Arctic Circle.
03:05:49 <ron_> I changed my username on my system. 
03:06:20 <ron_> So I need to tell IRC I am goron. /msg change Nick or something like that... Will check it out...
03:06:34 <shapr> try /nick goron
03:07:24 <shapr> if you're using linux, many irc clients check the environment variables. I forget exactly which var though. Maybe $IRCNICK ?
03:09:44 <goron> shapr: When do you usually use a statemonad? If you have like 6 parameters, Haskell becomes ugly, what do you do with it?  
03:10:10 <shapr> you can also use a record to turn it into a single param.
03:10:57 <goron> shapr: yes, but still it's not nice. It's also not extendible.
03:11:09 <goron> shapr: snd3,snd4, snd5 etc.
03:11:24 <shapr> you can partially apply functions as well
03:11:28 <shapr> that's often useful.
03:12:01 <shapr> records are extensible, but they can require you to recompile unrelated parts of your program when you add new fields.
03:12:10 <goron> shapr: I know what it is, but don't see the relevance...
03:12:36 <goron> shapr: I mean the partially stuff
03:12:36 <shapr> a partially functions can work like "poor man's objects"
03:12:40 <shapr> they're called closures
03:12:53 <shapr> on the other hand, objects are sometimes called "poor man's closures"
03:14:11 <shapr> for example, if you have a filter function that takes an 'access function', and you want to filter by the second half of a tuple, it could be myFilter = thisFilter snd
03:14:24 <Lor> abadi & cardelli provide two-way translations between the lambda-calculus and their object calculus.
03:14:30 <shapr> or if you want to filter a bunch of records, it might be myFilter = thisFilter theName
03:16:11 <goron> I don't see why this would save me the snd4,snd5,snd6 stuff...
03:16:22 <shapr> I often use partial application with finite maps. myLookup = lookupFM myKey ; map myLookup listOfFms
03:17:09 <goron> shapr: I also use it, but I don't see why it would save me the snd4,snd5 stuff. 
03:17:19 * goron thinks he needs TH.
03:17:21 <shapr> depends on your code
03:17:44 <shapr> it sounds like you're passing around a big tuple
03:17:54 <shapr> can you partially apply some of those value instead?
03:18:00 <shapr> would a record be easier?
03:18:14 <shapr> hi Plume__ 
03:18:20 <shapr> looking for Haskell info?
03:18:28 <Plume__> hi
03:18:42 <Plume__> what sort of info ?
03:18:51 <shapr> how to write Haskell?
03:19:08 <Plume__> that's not a problem
03:19:13 <shapr> ok
03:19:28 <Plume__> are u serious ?
03:19:38 <shapr> yes?
03:19:53 <goron> I find it an annoyance to apply a function each time I just want to do something with a value. I want to use a left hand value right(Is this correct English?) away, and not after applying a function.
03:19:55 <shapr> This is the Haskell channel, so I thought you might want to learn how to program in the Haskell programming language.
03:20:07 <shapr> goron: can you show me some examples?
03:20:29 <Plume__> i don't know this language
03:20:41 <shapr> I partially apply a function when I'll be using that combination of functiond and input often, sort of as a 'default value' 
03:20:47 <shapr> Plume__: would you like to?
03:20:52 <shapr> greetz gintas 
03:20:55 <goron> data Blaat = BlaatCon {str::String}
03:21:12 <goron> f::Blaat->EndType
03:21:12 <Plume__> where is it used ?
03:21:27 <Plume__> for what kind of program ?
03:21:44 <goron> f b = superTransformation $ str $ b
03:22:00 <shapr> Haskell is used in a lot of different places. Artificial Intelligence, Compiler and Language research, and lots more.
03:22:19 <shapr> it's also used for irc 'bots, mailing list search programs, irc clients, etc
03:22:25 <goron> Plume__: You can build operating systems with it, that *don't* break...
03:22:40 <goron> Plume__: Mostly used in building compilers. 
03:22:55 <shapr> goron: why not BlaatCon String ?
03:23:15 <shapr> the curly braces are a record, and a record with a single field seems needlessly complicated to me.
03:23:18 <goron> shapr: I just gave an example of why I hate records. 
03:23:23 <Plume__> ok
03:23:56 <shapr> records can be really handy when you have a bunch of different chunks to carry around.
03:23:58 <shapr> Plume__: lambdabot is written in Haskell
03:23:59 <goron> shapr: Mostly a record contains 10 fields or so. 
03:23:59 <shapr> @hello
03:24:00 <lambdabot> Hello world. 
03:24:10 <Plume__> nobody talked about this language
03:24:18 <shapr> Plume__: now they have!
03:24:21 <goron> shapr: You are scaring him away ;)
03:24:31 <Plume__> lambdabot
03:24:33 <shapr> lambdabot is fun!
03:24:34 <shapr> @yow
03:24:34 <lambdabot> Loni Anderson's hair should be LEGALIZED!!
03:24:37 <Plume__> :D
03:24:46 <shapr> @fortune
03:24:55 <shapr> hm, lambdabot is slow today.
03:25:34 <goron> Plume__: This language is superior, if you want to have a slow program, that is programmed very fast.
03:26:10 <Plume__> have you seen mayhem ?
03:26:12 <shapr> Haskell is very good at abstractions.
03:26:18 <shapr> @hello
03:26:18 <lambdabot> Hello world. 
03:26:21 <shapr> @seen mayhem
03:26:22 <lambdabot> I haven't seen mayhem
03:26:32 <Plume__> :DD
03:26:33 <goron> shapr: Well, Java is that too, only it's a burdon to do so. 
03:26:46 <Plume__> Java is too slow
03:26:48 <Lor> If it's a burden, it's not "good".
03:26:57 <shapr> Java is not good at abstraction.
03:27:02 <shapr> right, I totally agree with lor.
03:27:11 <goron> Lor: Me too...
03:27:22 <shapr> Lor: I have to ask, is Lor CoData?
03:27:41 * shapr grins
03:27:56 <shapr> Plume__: Haskell is worth learning.
03:28:05 <Lor> Huh? Wha?
03:28:06 <shapr> it's very different from Java.
03:28:21 <Lor> Ah, "Lore". Hee.
03:28:28 * shapr snickers
03:30:15 <Lor> No, it's a derivative of my name.
03:31:15 <Lor> "lor" is, apparently, the Old French form of "laurel", and the Latin "Laurentinus", from which "Lauri" is derived, is based on "laurus", laurel.
03:31:21 <shapr> oh, nifty
03:31:48 <shapr> I think CoData is the geekiest joke I've made in quite some time.
03:31:57 <Lor> The nearest English variant is probably Lawrence.
03:32:30 <goron> Is there a company that supports a Haskell compiler, if that compiler is death in 10 years?
03:32:50 <Lor> Companies die before open source software.
03:33:43 <Lor> You have the source, so if you just pay enough, you can get someone to maintain it, even if no one did so otherwise.
03:33:43 <shapr> there are companies that do commercial Haskell support though.
03:33:47 <Lor> (Which is unlikely)
03:33:55 <goron> shapr: I know that. 
03:34:09 <goron> Alistair Reed from the mailinglist does so.
03:34:17 <shapr> I'll do it too :-)
03:34:27 <goron> :?
03:34:40 <shapr> I own half a company, webwitches.com
03:34:56 <shapr> haven't gotten much paying Haskell work yet.
03:35:06 <shapr> the app I'm hacking on now is a attempt to get more.
03:35:18 <goron> shapr: What does it do?
03:35:39 <shapr> It's a web-based Swedish teaching app.
03:35:53 <goron> Your website, is kind of *dead*.
03:36:04 <shapr> yah, we have a new one at ScannedInAvian.com
03:36:21 <goron> I remember that address from some place.
03:36:35 <shapr> Anyway, I think this app is a good demo of what could be done with some funding.
03:36:56 <shapr> There are some nifty bits of Haskell code on ScannedInAvian.org
03:37:25 <shapr> so I want to release all the code under the GPL, and get the nearby kommuns to fund some further development.
03:37:55 <shapr> I dunno if this will actually fly, but in the meantime it sure is fun to write.
03:38:17 <goron> kommuns? 
03:38:28 <shapr> um, city governments
03:38:44 <shapr> related to the word 'commune' I assume.
03:38:47 <goron> Ok... Swedish?
03:38:47 <shapr> It's Swedish.
03:38:56 <goron> That was fast :)
03:39:47 <shapr> I started out with a CGI program, and it works, but it's *very* slow to start.
03:40:24 <shapr> so I'm trying to hack together hws-wp and hs-plugins so I can add in the HaskellDB and Grammatical Framework stuff as persistently loaded plugins.
03:40:26 <musasabi> Is it normal for parsec made things to be ~2 times slower than sloppy hand written ones ?
03:40:33 <goron> Haskell CGI? I did a Hello World in it, and it worked :)
03:40:42 <Lor> musasabi, do you use backtracking a lot?
03:41:02 <shapr> the try or option combinators can kill your performance
03:41:23 <Lor> Try the UU parsing combinators.
03:41:40 <goron> musasabi: I once had a exponentional xml parser written using try and option :)
03:42:46 <musasabi> no try nor option...
03:43:15 <musasabi> mainly just separate words and lines.
03:43:31 <goron> musasabi: You can use profiling for that. 
03:43:43 * goron done it before. 
03:43:51 <goron> (in Haskell)
03:44:19 <musasabi> goron: yes, and it shows most of the time being spent in the parser functions.
03:44:33 <goron> musasabi: No specific function?
03:44:33 <musasabi> oh well, I can use the handwritten one...
03:45:11 <musasabi> goron: well the whole parser is just 3 functions.
03:45:37 <goron> musasabi: Can you post it somewhere? I don't mind here.
03:45:56 <shapr> it's best to post anything over five lines on the paste page on the wiki
03:46:49 <musasabi> http://youzen.b2.fi/~musasabi/parse.hs
03:47:49 <shapr> Cale: I banned the whole 218.13.*.* subnet, three strikes and it's out.
03:48:21 <shapr> hm, I had makeWith working just a moment ago, what's wrong with it now?
03:48:33 <shapr> anyone else here played with hs-plugins?
03:49:18 <shapr> this is weird, it looks like make works, but makeWith doesn't.
03:51:50 <shapr> goron: do you have the snd4 snd5 code up somewhere so I can look at it?
03:52:00 <shapr> I might be able to suggest an easier way to do things.
03:53:56 <goron> musasabi: You have *a lot* of <|> in it. Changing order also helps, I think.
03:54:46 <goron> shapr: No, I just wanted to illustrate something. 
03:55:22 <goron> shapr: But when do you use a StateMonad?
03:56:40 <shapr> when I have something that I will be using in a bunch of different places.
03:56:57 <shapr> a record is good when you have a bunch of pieces that only go a few places
03:57:09 <shapr> a state monad is good when you have some pieces that go many places
03:57:21 <shapr> that's how I do it.
03:57:24 <shapr> what do you think/
03:57:25 <shapr> ?
03:57:44 <musasabi> goron: thanks, I'll try something.
03:57:57 <goron> Sounds logical, but sometimes you don't know that at forehand. 
03:58:54 <goron> shapr: Ever use algebra's?
03:59:02 <shapr> huh?
03:59:22 <goron> Ok, that's university stuff. Never mind that. 
03:59:32 <shapr> I've used algebra, sure.
03:59:43 <shapr> but how does that fit into when to use a state monad?
04:00:20 <shapr> I've used university too :-)
04:00:40 <shapr> I had years of learning with no focus.
04:00:45 <shapr> it was great fun.
04:01:14 <goron> Well, it fits in the picture of extendible programming. 
04:01:41 <shapr> I was just discussing chiaroscuro yesterday with an unsuspecting victim.
04:01:49 <shapr> how so?
04:02:05 <goron> chiaowhat?
04:02:39 <shapr> it's an italian word meaning 'light and dark' It's a shading technique I learned about in art class.
04:03:21 <shapr> anyway, how does algebra fit into extensible programming?
04:03:36 <goron> Ok, imagine you have this:
04:03:59 <goron> data A = ConsA Type1 Type2 Etc 
04:04:22 <goron> And you have a lot more of those Constructors that belong to A,
04:04:46 <goron> Now you can create a type AAlgebra a = ()
04:05:07 <goron> With (), has as much entries as that there are constructors for type A
04:05:28 <goron> Now you create a foldr for that datatype that works on that algebra.
04:05:36 <goron> algebra = tuple
04:06:00 <goron> Every compositional function can be described highly elegant by an algebra. 
04:06:06 <goron> And thus a fold. 
04:06:19 <goron> Do you know the repmin problem?
04:06:31 <shapr> no, what's that?
04:06:43 <goron> You have a tree with values in it. 
04:06:45 <shapr> what's repmin short for?
04:07:00 <goron> replicate min I thoughy
04:07:05 <shapr> ah, I found it on google.
04:07:07 <goron> with min=minumum
04:07:10 <goron> And?
04:07:23 <shapr> I've heard about it, but haven't studied it.
04:08:01 <shapr> mdo is on my list of things to figure out.
04:08:31 <goron> mdo has nothing to do with it. But it could be an implementation
04:08:48 <goron> Nice quote:"Mdo has nothing to do with it". :)
04:08:54 <shapr> so, what are you trying to illustrate?
04:09:29 <goron> Well, that type A, can be easily extended with another dataconstructor. 
04:10:13 <goron> Then you add one entry to your tuple, and you let the fold work on that tuple/algebra.
04:11:12 <goron> It's usefull for building interpreters/compilers in a compositional way. Only I think monads are better, because GHC people use them, but I don't know why. 
04:11:28 <shapr> have you looked at Generic Haskell?
04:11:32 <shapr> and the Data.Generics library?
04:11:37 <goron> Yes and no.
04:11:39 <shapr> and the various boilerplate papers?
04:12:13 <goron> I know the word, did see something in the Wiki, but didn't read the papers. 
04:12:14 <shapr> Steele wrote an interesting paper (95?) on compositional interpreters
04:12:16 <goron> Link?
04:12:38 <shapr> most of the compositional interpreter work in the haskell world uses monad transformers.
04:12:43 <shapr> so does the @eval plugin in lambdabot 
04:13:55 <shapr> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Generics.html
04:14:06 <shapr> the boilerplate approach is different from that of Generic Haskell.
04:14:23 <shapr> Generic Haskell uses type-indexing a lot.
04:14:34 <shapr> hej Marvin-- 
04:18:31 <shapr> as for implementing foldr on any datatype, that's what's the boilerplate libraries do, generic traverse is just one part of it.
04:21:47 <Plume__> what is #webwitches  ?
04:25:38 <Lemmih> An IRC channel.
04:26:57 <goron> It seems to be for hackers...
04:27:11 <goron> And shapr is hiding there. 
04:28:49 <shrimpx> his secret's out
04:30:53 <goron> shapr: Generic Haskell is built on my uni. I was thinking of following a course on it, but it is a bit offtrack, for my master. 
04:32:53 <shapr> actually, #webwitches is a channel for the company Webwitches HB
04:33:09 <shapr> We have irc meetings with our clients.
04:33:42 <goron> Than you are in a tiny, tiny niche :)
04:33:57 <goron> /s/Than/Then
04:34:20 <shapr> works nicely though.
04:34:31 <shapr> it's more difficult to have a written log of conference call
04:34:43 <shapr> and it's a lot harder to have good throughput in a conference call
04:34:50 <shapr> harder to give urls too
04:36:26 <shapr> also tends to weed out the weenies.
04:37:17 <shapr> goron: the Generic Haskell guys are fun to hang out with.
04:37:26 <goron> Well, we in the Low Lands, are behind. (3rd world country :))
04:37:36 <shapr> Swierstra can be difficult sometimes though :-)
04:38:13 <goron> shapr: I don't know, I was a student-assistent of Jeuring @ a functional programming course. 
04:38:32 <shapr> I don't think I've met Jeuring.
04:38:45 <goron> shapr: But I didn't see him much(almost never). 
04:38:46 <shapr> Andres is really cool.
04:39:18 <goron> I heard/met him, I think. Will check it's photo.
04:39:55 <goron> He has it's doctorate now. 
04:40:18 <goron> /s/it's/his
04:40:50 <goron> shapr: Where do you hang out with them? Not in Sweden I think ;)
04:41:08 <shapr> actually, it was in Sweden, at ICFP03
04:41:32 <dnm> Hey shapr.
04:41:38 <shapr> hiya dnm, how's the job?
04:42:13 <shapr> written any interesting code lately?
04:42:23 <shapr> goron: ICFP was lots of fun.
04:42:36 <shapr> if you can afford it, it's worth it.
04:43:24 <goron> Maybe when I am somewhat older. 
04:43:45 <shapr> fun people, high quality papers, interesting discussions.
04:44:06 <shapr> I wish for more focus on parallel implementations, but that's just me..
04:44:27 <shapr> well, Manuel Chakravarty is doing that.
04:44:52 <shapr> goron: I don't think it matters how old you are, if you can afford it, it's fun!
04:45:21 <shapr> There were people both young and old at EuroHaskell, and it was a blast too.
04:45:35 <shapr> You should come next year, if only for the unicycling :-)
04:46:51 <shapr> Luke Gorrie has challenged me to a unicycle race at the next EuroHaskell. Should be interesting.
04:47:13 <shapr> Hopefully he'll talk about some of the stuff he's done with Erlang.
04:48:20 <shapr> goron: do you think TH could be used to extend Data.Generics and/or Generic Haskell?
04:59:27 <goron> shapr: I didn't study it extensively. If they don't intersect eachother(language extensions and stuff) then I would say: why not?
05:01:49 <jak> hi, can anybody point me to the advice on when you should define a class and when you should make another constructor for a datatype?
05:13:02 <goron> jak: A class is imho only used for overloading, so if you have something that can be overloaded, you can use a class, but to actually do somethin, you always need data/newtype. 
05:16:01 <goron> shapr:Is there also a Graphical Frontend for Ghci/Hugs, these days in Linux?
05:20:27 <Igloo> "Merge backend-hacking-branch onto HEAD.  Yay!" </Simon Marlow>
05:20:43 <Marvin--> Yay! </me>
05:21:10 <Igloo> :-)
05:23:07 <goron> FGL is also standard is ghc-6.3 :) 
05:40:07 <goron> /s/is/in
05:44:46 <shapr> goron: what sort of graphical frontend?
05:45:19 <goron> Just one with a scrollbar, and where you click on stuff. lol
05:45:42 <jak> Thanks goron 
05:45:51 <Lemmih> click on stuff?
05:46:00 <goron> :-)
05:46:01 <shapr> how would that work?
05:46:20 <shapr> what would the clicky stuff do?
05:46:29 <goron> Well, something like Hugs on Windows?
05:47:02 <shapr> I've never used Hugs in Windows.
05:47:29 <Lemmih> One could make a really simple winGHCi with wxHaskell.
05:47:34 <shapr> I don't use Windows unless paid to do so.
05:47:57 <goron> Lemmih: That's what I meant. 
05:48:08 <goron> It's an open project @ ghc
05:48:35 <goron> Everything is open. I think that's where Open Source comes from :)
05:49:00 <shapr> the other thing about open source is that usually you have to be responsible for your own ideas.
05:49:09 <shapr> it's rare that someone else implements an idea of mine.
05:49:26 <goron> shapr: Responsible?
05:50:03 <shapr> like, if you have an idea that you think is worthwhile, you have to write it yourself.
05:51:55 <goron> shapr: Well, yes, guess what I am doing right now :-)
05:52:01 <shapr> cool :-)
05:52:28 <goron> I hope it will serve humanity. 
05:52:43 <shapr> yah, I hope that for my code too.
05:52:54 <shapr> but most of the time I'm the only person that uses my code.
05:55:02 <goron> What I am doing is making a "demo" of an extremely breaktrough algorithm. I am only not entirely sure whether it will work :p Lacking of the FGL lib, has slowed me down a lot. 
05:56:11 <shapr> I've gotten the FGL lib to work at some point in the past, maybe an older version will help?
05:56:13 <shapr> hej cm__
05:56:48 <goron> shapr: I already got it working in ghc-6.3
05:56:53 <shapr> ok
05:57:00 <goron> But thanks.
05:58:35 <goron> http://www.haskell.org/pipermail/haskell/2004-June/014241.html
05:58:47 <goron> I agree with it, you?
06:00:06 <shapr> no, not really
06:00:21 <shapr> debuggers rely on strict semantics.
06:00:45 <goron> shapr: I mean the thread.
06:00:58 <goron> modern language design, stone age tools
06:01:09 <shapr> no, not really
06:01:14 <shapr> look at QuickCheck
06:01:21 <edwinb> It's harder to write buggy code in Haskell ;)
06:01:31 <shapr> it's a space-age tool that's way ahead of the stuff available in the procedural world.
06:01:44 <goron> QuickCheck?
06:01:48 <shapr> I think the problem is that people expect things to work the same in Haskell as they do in C++
06:01:51 <shapr> and that doesn't work
06:02:12 <edwinb> QuickCheck is a really useful tool. I should use it more.
06:02:17 <shapr> of course, some things are still really handy, like test-first programming, regular refactoring, that sort of stuff.
06:02:23 <shapr> HUnit still works just fine.
06:02:34 <shapr> I've used a debugger maybe three times in my entire life
06:02:46 <Plume__> :D
06:02:56 <Plume__> reverse powa
06:02:58 <shapr> once in visual basic 3, once in gcc-2.something, and I once used DDD just to see what it looked like.
06:03:26 <shapr> In my opinion, debuggers treat symptoms rather than causes.
06:03:31 <goron> Well, I think I will import QuickCheck a time. I have used gdb for a project @ university. I hate C++, especially when someone else has written something buggy that I need to use, without docs. AARG!
06:04:32 <shapr> right now, there's not a really good way to encode behavioural assertions into types, but languages like epigram are working on that.
06:04:45 <shapr> Haskell can encode a lot more than C or Java though.
06:04:58 <edwinb> shapr: Mmm, yes, my experience with debuggers is that it's too easy to stick in a hacky patch to stop a specific bug occurring, rather than working out what's wrong at a higher level.
06:05:36 <edwinb> I remember when I worked as a C++ programmer, I once grepped the source (about 100,000 lines) for the word "Hack" and found over 100...
06:05:44 <shapr> yikes
06:05:48 <edwinb> of which a significant proportion were marked "Temp" ;)
06:05:54 <shapr> even worse!
06:06:09 <shapr> I think debuggers are about 'small scope'
06:06:14 <edwinb> I now write "Tmp Hack" when I mean "This doesn't work properly and I have no intention of ever fixing it."
06:06:19 <shapr> you're just trying to think about what's wrong 'right here'
06:06:23 <shapr> hehe!
06:06:39 <goron> Well, the real world is just evil... Client-side password validation...aaaahhh...
06:06:55 <shapr> if you have unit tests or properties for your code, you have a much higher level view on everything.
06:07:24 <shapr> I'm a great fan of test-driven-development
06:07:33 <shapr> I even figured out how to do it with QuickCheck :-)
06:08:01 <Plume__> @seen Plume__
06:08:02 <lambdabot> Plume__ is in #haskell.
06:08:06 <Plume__> :DDDD
06:08:08 * shapr looks at lambdabot 
06:08:10 <shapr> @hello
06:08:10 <lambdabot> Hello world. 
06:08:13 <shapr> huh
06:08:18 <shapr> is he lagging? or am I?
06:08:24 <Plume__> no no
06:08:28 <Plume__> very quick
06:08:51 <shapr> hm
06:09:20 <Plume__> :D
06:09:41 <goron> lambdabot is dead I think...
06:09:51 <goron> Somebody should feed it...
06:10:04 <Plume__> à pwal lambdabot
06:10:08 <shapr> lambdabot probably wants to run on a faster computer. He's on a 600MHz right now.
06:10:38 <Plume__> isn't it sufficient ?
06:11:17 <shapr> yes, it is
06:11:19 <shapr> but I wish it were faster too
06:11:30 <shapr> since a lot of other stuff also runs there.
06:11:31 <Plume__> huhu
06:16:35 <goron> What I don't understand about writing tests, is that your datatypes aren't known before programming and somehow you should be able to write tests. Isn't it true that you waste time then? 
06:16:45 <shapr> not at all
06:17:20 <shapr> Tests immediately put 'pressure' on your external interface.
06:17:43 <shapr> that means you have to think about API design before writing the internal code.
06:18:11 <edwinb> Anything that forces you to understand the program you're writing is good.
06:18:33 <shapr> Code that is easy to test usually has a flexible externel API.
06:18:36 <goron> I just created the best foldr ever :)
06:18:59 <shapr> Some really bad examples are Zope, which in many cases requires you to manufacture a REQUEST object just to give function input.
06:19:21 <goron> I am reading QuickCheck now, and will try to use it in a couple of tens of minutes
06:19:21 <edwinb> I never managed to get Zope to do anything.
06:20:11 <shapr> if that code were written test-first, you'd write the code that does thing X, once it tested fine, then you'd write the code that stripped that same info out of a REQUEST
06:20:22 <shapr> I make 99% of my income from Zope work.
06:20:30 <shapr> Zope has its own set of tradeoffs.
06:21:14 * goron never heard of Zope. 
06:21:35 <Plume__> @seen lambdabot
06:21:35 <lambdabot> Yes, I'm here
06:21:41 <Plume__> :P
06:21:49 <Plume__> @seen lambdabot
06:21:49 <Plume__> @seen lambdabot
06:21:49 <Plume__> @seen lambdabot
06:21:49 <lambdabot> Yes, I'm here
06:21:50 <lambdabot> Yes, I'm here
06:21:50 <lambdabot> Yes, I'm here
06:21:57 * Marvin-- tries to build gtk2hs
06:23:25 <goron> Is it hugs only?
06:24:52 <shapr> Notice that I'm trying to use hs-plugins to integrate a dynamically reloading webserver with Database and SGML generating plugins
06:26:06 <goron> never mind my last post
06:32:16 <goron> shapr: Do you maintain lambdabot? As is that you can replace it?
06:35:29 <ksmks> @seen kosmikus|away
06:35:30 <lambdabot> I haven't seen kosmikus|away
06:37:26 <Marvin--> yuk, gtk2hs seems to install directly into /usr/lib
06:41:31 <Lemmih> Marvin--: Why are you using gtk2hs?
06:43:38 <Marvin--> just playing with it
07:08:19 <goron> shapr: Do you maintain lambdabot? As is that you can replace it?
07:08:32 <goron> That supposed to be another window...
07:09:18 <shapr> er, yes!
07:09:38 <shapr> would you like to write some plugins for lambdabot?
07:12:19 <goron> Well, I was thinking of putting one like @ aiforum as a replacement. That thing rules :)
07:12:53 <goron> shapr: You can learn it things. 
07:13:18 <goron> "learn" I mean.
07:14:01 <goron> It uses no real semantics or advanced reasoning, but works nice.
07:14:26 <shapr> how does it work?
07:14:32 <shapr> markov chaining?
07:14:40 <goron> Ask it :) A lot of logic.
07:15:11 <goron> Markov chaining is too advanced for the guy who made it, I think. 
07:15:33 <goron> Do you have some ai knowledge?
07:17:53 <shapr> yes, some.
07:18:15 <shapr> I've written some neural network code before, and I've read about expert systems and genetic algorithms.
07:19:00 <goron> neural networks are of no interest to me, because no one can see why it does some things. You can prove somethings about it, but that's it. 
07:21:05 <goron> The thing I see when I see the human brain is a closed system, that somehow (after exposure to its environment) can understand some things. I think this closed system can be created with a little(make that a lot) thought.
07:21:56 <shapr> I don't think it's a closed system at all, I think it's a lot closer to the statistical adaptability of neural networks.
07:22:39 <goron> shapr: How do you mean it's not closed? In what way can we know whether something is "good"?
07:23:09 <goron> shapr: While not dead "good"? I don't think so.
07:23:12 <shapr> because the built-in parts of the system are simple like hunger, pain, pleasure.
07:23:50 <goron> shapr: Well, I disagree, I did thought that for some time, but not anymore.
07:24:30 <shapr> Most people function on a purely reactive basis. Very few people spend time thinking about their life on a planning basis. Maybe that's just my experience.
07:25:11 <goron> shapr: Well, that is a true statement, imo.
07:25:46 <shapr> Along the same lines, most employees only learn new stuff when they must learn it to keep their job.
07:26:08 <goron> shapr: But still how do you know that having hunger is "bad"?
07:26:32 <shapr> how do you know that pain is bad?
07:26:54 <shapr> Not everyone does. They call those people masochists :-)
07:28:05 <goron> shapr: I think it all are correlations and that a human is smart enough to cope with a lot of them (unconsciously). 
07:29:47 <shapr> Many programmers have small to nonexistent ability to cope with social interactions unconsciously. Some of them learn conscious 'interpreted' social skills, but the 'compiled' social skills are much easier to deal with. :-)
07:30:05 <goron> I think it's possible to build a program that can learn to program after being exposed to a lot of 1's and 0's.
07:30:20 <shapr> I'm sure it's possible.
07:30:35 * shapr stares at Marvin--'s plugin code in hws-wp
07:31:04 <goron> shapr: Is this true in general? Do you have a paper stating that (programmers)?
07:31:17 <shapr> no, just personal experience.
07:31:35 <goron> Do you have that too?
07:31:43 <shapr> To some degree, yes.
07:32:04 <goron> I think it's just a matter of how much experience you have with it.
07:32:10 <shapr> No, I don't think so.
07:32:46 <shapr> There's more to it than that.
07:35:22 <goron> Now the question is: are these people influenced by programming/too much mental stimulation or were they just born that way?
07:35:32 <shapr> I'd say they're just born that way.
07:35:33 <Marvin--> shapr: it's that awful? :-(
07:35:48 <shapr> Marvin--: no, just trying to figure out how to make it use hs-plugins instead.
07:36:10 <shapr> since that will let it recompile and reload the plugin whenever the source changes.
07:36:37 <shapr> goron: for example, there's a gene for attention deficit disorder.
07:37:23 <goron> Did you know there's a thing that slows mental activity, while boosting social skills? 
07:37:44 <shapr> The human race as a whole gains benefits from the ADD or Asperger's people, so it's probably natural selection.
07:37:47 <shapr> Yes, I'm aware of it.
07:38:22 <goron> What's it?
07:38:36 <shapr> I forget the name, it's related to Down's Syndrome.
07:38:56 <shapr> These people generally have an IQ of around 75, but are very social, friendly, and fun to be around.
07:39:06 <goron> No, I just meant *beer*...
07:39:10 <shapr> oy :-)
07:39:27 * shapr grins
07:39:45 * goron burks (no just kidding)
07:39:46 <Marvin--> argh, sourceforge really really really sucks
07:39:53 * shapr agrees with Marvin-- 
07:40:23 <Marvin--> cvs [login aborted]: unrecognized auth response from cvs.sourceforge.net: M PserverBackend::PserverBackend() Connect (Connection refused)
07:40:25 * Marvin-- boggles
07:40:30 <shapr> Most people are sheep, they follow the crowd. The strange ones can't follow the crowd, so the crowd sometimes follows them.
07:41:25 <shapr> I'm a sheep in many ways. I can barely stand to look at my bookkeeping. I just want to pay my taxes and get back to doing something fun.
07:42:09 <Marvin--> nnngh
07:42:51 <andersca> heyhey Marvin-- 
07:46:23 <Marvin--> and jeepers I really don't grok all this makefile wizardry
07:47:00 <Marvin--> screw this, I'll just use --libdir=/usr/lib/gtk2hs
07:48:03 <shapr> what's the "first Just in a list of Maybes" trick?
07:48:09 <shapr> mplus?
07:49:01 <shapr> @index mconcat
07:49:01 <lambdabot> Control.Monad.RWS,Control.Monad.Writer,Data.Monoid
07:49:05 <shapr> @index mplus
07:49:05 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
07:49:05 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
07:49:05 <lambdabot> State,Control.Monad.Writer,Monad
07:49:09 <Marvin--> msum surely?
07:49:15 <shapr> @index msum
07:49:15 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
07:49:15 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
07:49:15 <lambdabot> State,Control.Monad.Writer,Monad
07:49:27 <shapr> ah, right
07:49:42 <shapr> msum seems to work too
07:49:58 <goron> shapr: I would like to see that definition.
07:50:05 <shapr> err, doh
07:50:24 <shapr> goron: what?
07:50:29 <shapr> Marvin--: yes, thanks
07:50:42 <goron> Of that "trick".
07:50:52 <Marvin--> it's not much of a trick
07:51:01 <Marvin--> Maybe is an instance of MonadPlus, defining mplus
07:51:09 <Marvin--> msum is just a fold using mplus
07:51:36 <Marvin--> Just x `mplus` m = Just x ; Nothing `mplus` m = m
07:51:52 <goron> I understand it.
07:52:04 * goron remembers something about sheeps
07:52:10 <shapr> heh :-)
07:52:16 <shapr> the famous Nomaware sheep.
07:52:20 <goron> shapr: Yes
07:53:32 <shapr> so, should hws-wplug try to rebuild and reload on each request?
07:53:42 <shapr> or should it wait for a HUP?
07:53:45 <goron> I like the approach used there. It's really simple like: "He, we are doing things a couple of times"=>Abstract.
07:54:01 <shapr> I agree, it's an excellent tutorial.
07:54:04 <goron> shapr: Marvin-- is the other guy in your company?
07:54:58 <shapr> no, not exactly.
07:55:37 <shapr> This is me in the background, and the 'other guy' in my company is in the foreground. :-) http://www.scannedinavian.org/~shae/foto/unicycle.jpg
07:55:46 <shapr> aka "The Boss"
07:56:09 <Marvin--> what do you mean "not exactly"? :)
07:56:25 <goron> :-)
07:56:43 <Marvin--> I'm not involved professionally with webwitches in any way, last I looked
07:56:47 <shapr> Marvin--: sadly, I have neither the finances nor the business to hire you to do Haskell coding, but I'll ask you if I do :-)
07:56:54 * shapr grins
07:57:06 <Marvin--> I think I'll be happy at safelogic for a while, thank you :)
07:57:13 <shapr> yes, probably so.
07:57:21 <Marvin--> I got a report from their USA trip yesterday
07:57:35 <shapr> and?
07:57:44 <Marvin--> they'd met with a competitor to discuss some form of merger, I think
07:58:11 <goron> Is this inside information :? Should I buy stocks? 
07:58:21 <shapr> goron: this is a picture of me: http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
07:58:23 <Marvin--> hah
07:58:39 <shapr> as you can probably see, I need a haircut.
07:58:50 <goron> shapr: Where are you? 
07:58:51 <Marvin--> the competitor's program apparently had a fantastic GUI and an excellent debugging environment
07:58:56 * shapr laughs
07:59:11 <Marvin--> but our program completely crushed theirs in raw verification performance
07:59:34 <Marvin--> and I mean *crushed*
07:59:38 <shapr> is safelogic using Haskell?
07:59:52 <goron> "Performance"
08:00:04 <goron> Don't think so...
08:00:13 <shapr> bah, Haskell can be just as fast as C
08:00:15 <shapr> faster in fact.
08:00:29 <Marvin--> safelogic verifier is an unholy mixture of C, C++, Haskell, Java and Tcl :-)
08:00:40 <Philippa> shapr: not without a lot more compiler work though
08:00:49 <Philippa> which is a shame - if it got the level of work C++ did, it'd be /fast/
08:01:24 <shapr> a) write the program in Haskell, with QuickCheck tests to verify sanity b) profile the program c) rewrite the slow parts in C, using the FFI d) profile e) rewrite the slow parts in assembler, using C's FFI f) get rich, retire to the Bahamas.
08:02:00 <shapr> goron: ok, here's a relatively boring picture of me: http://www.scannedinavian.org/~shae/foto/Image007.jpg
08:02:12 * shapr has a programmer's tan
08:02:28 <shapr> Philippa: yah, would be nice
08:02:31 <shapr> maybe one day.
08:03:08 <Philippa> I suspect more likely to actually get implemented is something akin to what I described to you in PM a while back with Haskell or similar as the metalanguage...
08:03:09 <shapr> well, hws-wp runs nicely
08:03:25 <Philippa> which reminds me - really ought to knock up the type classes for that
08:03:32 <shapr> hm, we've had a lot of fun bluesky PMs... which one?
08:03:45 <Philippa> the arrows-minus-arr one
08:04:19 <Philippa> sadly, the current translation of the arrows syntax wouldn't work with it, too many lambdas :-(
08:05:58 <shapr> I remember discussing it, but I don't remember the details.
08:06:03 <shapr> write it up?
08:06:15 <Philippa> it's on my to-do list. So's a lot of other stuff though
08:06:38 <Philippa> might bring that one up with gmh though - too late to change my dissertation project, but it may make something to do early on in a PhD
08:07:57 <Marvin--> meh, gtk2hs doesn't use hierarchical libs and mixes the gtk2 package files with the mogul package files
08:08:01 <Marvin--> what a mess
08:13:24 <goron> I need to have a strongly connected component function in FGL. Where is it?
08:18:46 * goron is getting the sources...
08:28:22 <goron> Ah, yes :) scc... (figures)( I remembered the name from reading the paper a year back or so :)_
08:28:22 <Marvin--> what's the difference between = and := in make?
08:28:44 <Smerdyakov> :
08:28:46 <goron> Read that a week ago and I forgot it...
08:29:35 * goron is pretty sure you can do something useless with it lol
08:30:31 <Marvin--> hm, apparently = expands variables lazily, but := expands variables immediately
08:30:56 <shapr> bah, plugins isn't happy in GHCi
08:31:39 <shapr> hm, how do I make an .so for each .a ?
08:32:32 <goron> popular question
08:32:48 <goron> I investigated it for Cabalizing HSUnix.
08:33:38 <goron> Ghci can load .so files, but ghc/ghci can't create them. You need to make a package.
08:33:43 <Marvin--> $(shell echo $(addsuffix ...) | $(SEDPIPE))
08:33:49 <shapr> I've got a package
08:33:51 <Marvin--> sed ain't the only pipe these guys have been at
08:33:54 <shapr> heh!
08:34:07 <goron> Possible cause: the monomorphism restriction applied to the following:
08:34:26 <goron> Stupid rule (I get this like *often*)
08:34:47 <shapr> hiya heatsink 
08:35:23 <heatsink> hi shapr
08:35:44 <goron> shapr: Do you have a bot running that greets everybody? take random ["hi","hello"] ++ name ?
08:36:54 <heatsink> let's find out
08:37:36 <heatsink> seems not
08:38:05 <goron> heatsink: The program could be smarter than that...
08:39:03 <shapr> goron: no, just me.
08:39:42 <shapr> I've noticed that when I join an irc channel, it always looks empty, so I don't know if anyone is awake, or if there are any conversations happening.
08:40:00 <shapr> I sort of wish I could get the last ten lines when I join a channel.
08:40:24 <shapr> In the meantime I try to greet people so that they know that this channel is awake, and interesting.
08:40:53 <heatsink> (didn't work for ron_ aparently)
08:41:00 <heatsink> Good idea, though.
08:41:04 <shapr> and I try to be helpful so that people will come back :-)
08:41:15 <goron> I saw it. 
08:41:32 <musasabi> Is there any mutable M<->N two-way lookup structure in the standard library?
08:41:42 <goron> But ron_ was logged on a couple of hours ago. 
08:42:16 <goron> (ron_ equals me)
08:42:25 <shapr> musasabi: you could build a reverse FM
08:42:28 <heatsink> oh
08:42:37 <shapr> other than that, there may be something in DData?
08:42:47 <shapr> heatsink: do you have any Haskell questions?
08:43:23 <musasabi> shapr: doesn't that make deletions very expensive?
08:43:33 <shapr> well, yes.
08:44:38 <shapr> it is simple though: reverseFM = listToFM . map (\(x,y) -> (y,x)) $ fmToList 
08:45:16 <shapr> I usually try to get my code working first, then make it faster later.
08:45:24 <goron> musasabi: Algorithmically it's not bad.
08:45:53 <musasabi> goron: I am trying to find an algorithm that would make it O(log n)
08:45:55 <heatsink> you could create an object that contains a pair of mappings, one in each direction, all operations will take twice the time that a single mapping takes...
08:46:13 <goron> musasabi: You just found it. 
08:46:32 <musasabi> the one object in the middle?
08:46:44 <heatsink> "in the middle"?
08:46:50 <goron> "in the middle"?
08:47:10 <goron> What is he talking about? :-)
08:47:28 <shapr> on the good side, the reverseFM would be lazily built, so get amortization.
08:47:30 <goron> Oh, I understand it
08:47:31 * musasabi thinks he misunderstood heatsink 
08:48:01 <goron> You want to have the center element of some structure?
08:49:02 <goron> musasabi: FiniteMaps have n*log n built time and log n search time. 
08:49:27 <goron> shapr: Addition how fast is that?
08:49:28 <musasabi> goron: I know. (the delete case is problematic - let me explain)
08:49:30 * shapr holds breath
08:49:35 * shapr hopes this works
08:49:46 <shapr> yay!
08:50:17 <shapr> I dunno how fast the FM_C stuff is.
08:50:48 <musasabi> The basic problem is that I have a group of named pages (e.g. 2000). Now each page links to a set of other pages. I need to support the following operations: pageLinksTo :: PageMap -> PageName -> [PageName] -> IO (), links :: PageMap -> IO ([Page]) and reverseLinks :: PageMap -> Page -> IO ([Page])
08:50:58 <shapr> Marvin--: wow, I think I got hws-wp to use hs-plugins!
08:51:03 * shapr bounces cheerfully
08:51:11 <goron> musasabi: There is a paper written on FM...
08:51:12 <heatsink> what's hws-wp?
08:51:30 <goron> haskell webserver- wrapper?
08:51:30 <shapr> it's a web server with plugin interface
08:51:34 <Philippa> musasabi: how common're deletes?
08:52:18 <Marvin--> shapr: cool
08:52:54 <musasabi> Philippa: quite common as all pageLinksTo, must potentially purge the reverse links.
08:53:10 <shapr> now to make it check whether to rebuild the plugins on every request.
08:53:17 * heatsink can't figure out what pageLinksTo does
08:54:21 <Philippa> musasabi: that's an update rather than a delete, isn't it? Slightly different behaviour in that you can navigate the rest of the structure without evaluating the bit that's updated
08:54:25 <shapr> bonjour |Lupin|, comment ça va?
08:54:35 <|Lupin|> hi,
08:54:39 <|Lupin|> it's ok, thanks :-)
08:54:40 <|Lupin|> U ?
08:54:40 <musasabi> heatsink: Think about PageMap as a directed graph. pageLinksTo tells the set of edges starting from a page. (That means delete all old edges starting from this vertex and add the ones passed as parameter.
08:54:53 <shapr> life is good.
08:55:00 <shapr> Code is working :-)
08:55:11 <Philippa> heh
08:55:25 <Philippa> reminds me, I just sent cm a copy of my dissertation work as stands (no actual writeup)
08:55:27 <musasabi> Philippa: real deletions are not frequent.
08:56:07 <Philippa> heh, thinking that through, laziness on an interactive system doing stuff like that nearly breaks my brain...
08:56:39 <|Lupin|> please, could somebkdy suggest me a good reading about continuations ?
08:57:08 <goron> |Lupin|: The Wiki isn't good enough=>no idea...
08:57:38 <musasabi> Haskell continuations are very different from the scheme ones.
08:57:42 <shapr> yes, that's true.
08:57:55 * goron clueless...
08:58:08 <musasabi> it caused me endless headache when thinking scheme continuations and trying to do it in haskell.
08:58:10 <shapr> continuations are like GOTO
08:58:18 <goron> NNNNNNNNNNOOOOOOOOOOOOOOOO
08:58:22 <shapr> really, they are.
08:58:35 <goron> instant death
08:58:42 <shapr> continuations are like functions calls, but simpler
08:58:44 <Riastradh> Function calls are like goto as well.
08:59:04 <shapr> right, with the difference that a function call always returns, and continuations don't.
08:59:04 <Philippa> shapr: unless you're evil enough to stack your StateT the other way round, then it's more interesting...
08:59:16 <goron> Everything is a like, only some things more than others. I rest my case.
08:59:27 <shapr> Philippa: er, the next call being calculated on the fly?
08:59:45 <|Lupin|> well
08:59:47 <shapr> goron: but, the whole C culture takes as a given that a function will return
08:59:53 <|Lupin|> I didn't want to start any flame
08:59:58 <|Lupin|> thepoint is
08:59:59 <shapr> and continuations don't, and are more powerful because of it.
09:00:03 <Philippa> well, it's exception-like behaviour vs modifying the state throughout
09:00:08 <|Lupin|> I'm an Ocaml programmer, sorry, nobody is perfect
09:00:13 <shapr> heh
09:00:16 <shapr> it's okay :-)
09:00:23 <|Lupin|> ok, so...
09:00:31 <|Lupin|> In Ocam there is a printf function
09:00:31 <goron> Ocaml has some things Haskell doesn't have.
09:00:32 <heatsink> musasabi: pageLinksTo sets the set of edges starting from a page?
09:00:39 <|Lupin|> which takes an argument o type string
09:00:44 <|Lupin|> and then several arguments
09:00:55 <|Lupin|> and does the same thing its C equivalent does
09:01:23 <|Lupin|> so I wondered how a function can accept a variable number of arguments
09:01:26 <heatsink> musasabi: the [PageName] argument is the new set of edges?
09:01:28 <|Lupin|> and I ha a look t it
09:01:34 <|Lupin|> expecting some ugly C trick
09:01:35 <musasabi> heatsink: yes.
09:01:44 <heatsink> ok
09:01:44 <|Lupin|> but it is written entirely in Caml
09:01:55 <|Lupin|> using aontinuations
09:02:02 <Philippa> is it typesafe?
09:02:22 <|Lupin|> yes it is
09:02:28 <Philippa> interesting
09:02:39 <|Lupin|> so now I'm just starring at this code
09:02:47 <|Lupin|> wonderinghow such a thing is possible...
09:02:58 <|Lupin|> I know whatcontinuations are
09:03:08 <|Lupin|> butstill, I can't figure out how this all works...
09:03:35 <heatsink> musasabi: which links does links return, since it doesn't have a PageName argument?
09:03:38 <Lemmih> I once made a typesafe sprintf with TH...
09:04:42 <|Lupin|> TH ?
09:04:46 <shapr> yes, Template Haskell can do it.
09:04:53 <shapr> and Cayenne can do it
09:05:00 <|Lupin|> Philippa: Actually I'm not sure my answer is correct. What do you call typesafe ?
09:05:10 <musasabi> heatsink: sorry links :: PageMap -> PageName -> IO ([PageName])
09:05:31 <Philippa> |Lupin|: in C you can give a format string that expects an int and feed it a float, for example. That's not typesafe
09:05:49 <heatsink> ok
09:06:16 <musasabi> that is return names of all pages that the the given page links to. and reverse_links is return names of all pages linking to the current page.
09:06:40 <shapr> @yow !
09:06:40 <lambdabot> Yow!  It's a hole all the way to downtown Burbank!
09:06:47 <heatsink> musasabi: yea, so you can build the reverse map when you need, or you can keep both forward and reverse maps all the time
09:07:54 <musasabi> heatsink: yes. Only the (even amortized) cost of building the reverse maps should be quite high.
09:08:07 <|Lupin|> Philippa: I try...
09:09:16 <|Lupin|> Philippa: Yes it is type safe. It's surprising I think...
09:09:17 <heatsink> musasabi: if you keep both maps all the time, then the cost of building the reverse maps will be same as the cost of building the fwd maps
09:09:52 * shapr does the happy dance
09:09:56 <shapr> my code works! yay!
09:10:11 <Marvin--> bah, gtk2hs's "make distclean" is a joke
09:10:22 <Marvin--> it doesn't even remove config.status and config.log
09:10:23 * heatsink high-fives shapr
09:10:29 <shapr> Marvin--: any suggestions for keeping persistent HaskellDB connections in a hws-wp plugin?
09:11:17 <Marvin--> err...no?
09:11:26 <shapr> I wonder if this will require something like lambdabot's Typeable thingy.
09:11:32 <shapr> there must be a better way.
09:12:09 * shapr thinks
09:12:31 <Marvin--> let me quote Falk Hueffner
09:12:35 <shapr> uh oh
09:12:39 <Marvin--> "Damn. Why does everybody think I know how mklibs works just because I wrote it?"
09:12:44 * shapr grins
09:13:38 <musasabi> heatsink: changing the set of links in the forward map is just a single modification of the finitemap, but the reverse link table needs (OldLinks \ NewLinks) * modificationCost.
09:15:19 <heatsink> oh, this is a one-to-many map... I overlooked that...
09:15:45 <musasabi> or rather #((OldLinks U NewLinks) \ (OldLinks \cut NewLinks))
09:15:52 <musasabi> but that is not important.
09:16:05 <musasabi> heatsink: yes, that is the root of the problem.
09:16:34 <heatsink> ok, I dunno
09:19:04 <musasabi> -> sauna (brb 45min)
09:21:09 <heatsink> What is filename for compiled haskell code? For example, when I import Data.Bits what file is the code contained in?
09:30:18 <shapr> you can start up ghci with -v to see
09:30:21 <shapr> or use :set -v
09:45:28 <heatsink> ah, I see
09:45:34 <heatsink> it seems to be HSdata.o
09:45:53 <heatsink> hey, HSparsec.o is right there so I shouldn't be getting link errors
09:45:58 * heatsink grumbles
09:46:15 * heatsink has been getting link errors with my parser
09:48:08 <shapr> are you using -package data ?
09:48:42 <heatsink> no
09:48:52 <shapr> see if that helps
09:49:44 <heatsink> yes, that helps
09:50:03 <heatsink> thank you
09:50:26 <Marvin--> Data.Bits should be in the base package, shouldn't it?
09:50:32 <heatsink> I think so
09:50:57 <heatsink> it was Text.ParserCombinators.Parsec that I wasn't finding... I was just using Data.Bits for test
09:51:04 * Marvin-- builds his first gtk2hs program
09:51:17 <Marvin--> that shouldn't need -package data either
09:54:13 <shapr> I thought Data.Bits was part of the non-hierarchical libs?
09:55:32 <heatsink> I'm going now, thanks for the help
09:56:58 <Marvin--> shapr: "Data.Bits" looks pretty hierarchical to me
09:57:09 <shapr> awright then :-)
09:57:28 <shapr> how do I carry around a HaskellDB connection?
09:57:37 <shapr> maybe I should go unicycle and think about this.
09:58:00 <Marvin--> I'm going to the pub
09:58:02 * shapr goes off to unicycle
10:02:36 <musasabi> back.
10:02:48 <musasabi> persistent gfs...
11:05:01 <shapr> whee
11:05:53 <SyntaxLaptop> hi shapr
11:17:22 <goron> It seems that the partial application of two parameters is not possible in Haskell, is this correct?
11:18:12 <emu> eh?
11:18:29 <emu> (f x y) ?
11:18:56 <goron> emu: I am not clear :)
11:19:28 <goron> I will give a concrete example.
11:19:29 <emu> i would say so
11:19:52 <goron> context:: (Graph gr) =>  gr a b -> Node -> Context a b
11:20:31 <goron> Context a b::(z,q,a,r) (only the a matters)
11:20:55 <goron> thrd4 (_,_,a,_) = a
11:21:18 <goron> Now I want to write down:
11:21:30 <goron> f = (thrd4.context)
11:21:38 <goron> This is typed wrong. 
11:21:51 <goron> But f x = (thrd4.context x) is correct
11:22:23 <goron> I would like that context "absorbs 
11:22:30 <goron> " two parameters.
11:23:12 <goron> But I don't think it's possible in Haskell/any language ....
11:27:54 <maihem> goron, it is because of the type of the dot operator
11:28:16 <goron> maihem: Is there another operator?
11:29:19 <goron> I do this trick more than once. And an abstraction is usefull.
11:29:23 <maihem> I haven't written any haskell for months, so I can't remember.
11:30:41 <maihem> perhaps: f `dotdot` g = \a b -> f $ g a b
11:31:37 <maihem> then thrd4 `dotdot` context
11:31:41 <arjanb> goron: does  (thrd4 .) . context   work?
11:32:23 <goron> (--+) :: forall b (t1 :: ??) (t :: ??) a.
11:32:23 <goron>          (a -> b) -> (t -> t1 -> a) -> t -> t1 -> b
11:32:28 <maihem> ooh
11:32:49 <goron> That's the same as you I have written.
11:34:15 <goron> arjanb: You are great :)
11:34:22 <goron> arjanb: It works
11:34:39 <arjanb> no the haskell wiki is great :-)
11:34:54 <goron> arjanb: Link?
11:35:10 <maihem> @wiki
11:35:11 <lambdabot> http://www.haskell.org/hawiki/
11:35:27 <goron> I meant like a little more precise. Well I can search. Thanks
11:36:15 <goron> arjanb: What terms did you use?
11:37:33 <arjanb> i don't know which page it was  i read that trick some months ago
11:39:06 <arjanb> ah halfway this one: http://haskell.org/hawiki/PipeliningFunctions
11:45:16 * goron thinks Syntax Highlighting in gvim sucks...
11:48:36 <goron> arjanb: Op de universiteit Twente hebben ze toch alleen Clean?
11:50:21 <arjanb> nee ze gebruiken Amanda voor fp vak
11:52:59 <arjanb> geen haskell vanwege een docent die monads maar niks vind :-(
12:16:30 <shapr> wheee
12:17:17 <shapr> hi flori 
12:18:53 <shapr> you can do something like (.).(.) or so, I forget the exact order of the parens and the dots
12:19:04 <shapr> but it ends up allowing you to pipeline functions with two arguments
12:19:39 <shapr> goron: also, you can just call it with arguments instead of a tuple
12:21:55 <Riastradh> @type (.).(.)
12:21:57 <lambdabot> (.).(.) :: forall a b c a1.
12:21:57 <lambdabot> 	   (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:27:03 <shapr> geez, how do I make WASH, HaskellDB, and GF hws-wp plugins?
12:27:20 <Riastradh> By hacking.
12:27:39 <goron> shapr: How do you mean?
12:32:28 <shapr> hws-wp defines an apache-module style plugin interface.
12:32:52 <shapr> so you can catch/filter a lot of requests, but it's still totally request-centric.
12:33:03 <shapr> I guess I want a more general application server.
12:33:26 <shapr> but I'm not sure how to approach it.
12:33:29 <Plume> @seen mayhem
12:33:30 <lambdabot> I haven't seen mayhem
12:33:34 <Plume> :/
12:33:36 <Plume> :'(
12:40:32 <zamer> kikoo Plume ::)
12:40:39 <Plume> :D
12:40:50 <zamer> le mec avec un 'i' c pas lui
12:40:57 <Plume> tu connaissais ce language ?
12:41:03 <zamer> nop
12:41:07 <Plume> moi non plus
12:41:15 <zamer> lol
12:41:39 <Plume> shapr est un expert il explique tout
13:30:16 <adamiak> Hi. I'm quite new to haskell and use Hugs. I have got a list of 20000 strings. I want to check if an element exists in the list. But using the standard recurency it takes about 10 sec. What should I do?
13:30:41 <adamiak> I just want to iterate over the list.
13:32:37 <adamiak> ??? any1 here ????
13:33:26 <Riastradh> Try using it as if it were a trie.
13:33:58 <Riastradh> And take advantage of Haskell's laziness.
13:34:07 <adamiak> trie?
13:35:05 <adamiak> ok - i'm checking it on google
13:38:24 <adamiak> Am I - using trie - already taking advantage of Haskell's lazines, or did you mean some other technique?
13:43:21 <Spark> if you want to optimise some inner loop surely its best to specify the instrucitons yourself rather than hacking functional progrmaming concepts?
13:44:22 <adamiak> I don't know if I should optimise, or maybe change the techniqe (data structure) used.
13:44:44 <adamiak> I have a list of 30000 words, and want to run 'elem "some_word" words'
13:44:55 <adamiak> but this works horribly slow
13:45:22 <musasabi> adamiak: what you want is a search structure with better performance than O(n).
13:45:24 <adamiak> I will never change this list. I just want to check, if an element is a member.
13:45:55 <musasabi> adamiak: and creating this structure will seem cheaper in haskell due to lazyness.
13:46:20 <adamiak> musasabi: not quite. If I'm not mistaken, using recurency doesn't give O(n), because in each step the tail of the list is copied
13:46:35 <adamiak> and it takes most of the time.?!?!
13:46:57 <adamiak> am I right?
13:47:04 <Riastradh> The naive recursive algorithm for checking list membership for a list of strings is O(n*m), where n is the length of the list and m is the length of the string you're checking.
13:48:00 <Lor> Unfortunately, tries are rarely practical, neat as they are.
13:48:04 <Riastradh> Using tries can make it O(m).
13:48:34 <Riastradh> What do you mean 'rarely practical?'
13:49:03 <adamiak> hmmmm. search algorith of O(n) or even O(n*m) should be fast. But during one search I get tens of garbage collection's
13:49:04 <Riastradh> They're quite practical for large sets of strings.
13:49:07 <Lor> That they don't have particularly great advantages over the standard associative data structures, trees and hash tables.
13:49:19 <Riastradh> Yes, they do, Lor, if n is big.
13:49:42 <Lor> If n is big relative to m, that is.
13:50:06 <adamiak> Well, it's my case
13:50:23 <Lor> All right, you have a great number of strings, all of which are of fairly short length?
13:50:32 <adamiak> yes
13:50:35 <Lor> 30000 is still not very much, though.
13:50:37 <adamiak> actually it's a dictionary
13:50:55 <adamiak> I have list  [(polish_word, english_word)]
13:51:05 <adamiak> where both word's are Strings
13:51:16 <adamiak> and want to find translation of a polish word
13:51:35 <Lor> Riastradh, what would you recommend as the lookup structure in the trie nodes?
13:51:36 <adamiak> so I have to check if appropriate tuple exists in a list
13:51:52 <adamiak> And it take about 10 sec on Hugs on my Celeron 633
13:52:03 <Riastradh> Lor, for string keys, arrays.
13:52:20 <Lor> Uh, arrays indexed by the character code?
13:52:23 <Riastradh> Yes.
13:52:43 <Lor> All right, so you have a 30-element array in each node.
13:53:20 <Riastradh> Or perhaps even alists, so they can be variably sized.
13:53:22 <Lor> With a fill ratio of, say, 1/30 or threreabouts...
13:53:30 <adamiak> so... there is no way to get a pointer to a first element, and then - even recursively - move it to next elements? That;s what I would do with list in C
13:54:31 <musasabi> adamiak: why not use a Data.FiniteMap ? (if you don't need to do prefix-matching)
13:54:54 <Lor> Yeah, prefix matching is one of the sensible reasons to consider tries.
13:56:24 <adamiak> musabi: hmmm. I don't know this data type - I'm really new to Haskell. I'l check on google
13:56:51 <musasabi> adamiak: so you have match key [] = return Nothing; match key ((key,val):_) = return val; match key (_:r) = match key r ?
13:56:59 <Lor> In a way perl had it right: a single associative data structure that is "good enough" for almost every use...
13:58:37 <adamiak> musabi: match key [] = return Nothing; match key [(pol, ang):rest] if key == pol: return ang else return match key rest
13:58:54 <adamiak> musasabi: Is my version slower than yours?
13:59:20 <adamiak> musabi: sorry - without 'return's
14:00:01 <musasabi> adamiak: your's is probably slower.
14:00:08 <Lor> musa's version is faulty (hopefully intentionally).
14:01:20 <adamiak> but tell me: there is no way to iterate over list with something like a pointer, right?
14:01:38 <Lor> Why would you need to?
14:01:46 <adamiak> and I MUST use some other structure, like search tries etc., right?
14:01:57 <Lor> You can iterate over lists. What additional convenience do you want?
14:02:04 <Riastradh> Regular alists are obviously not fast enough, adamiak.
14:02:06 <Lor> adamiak, for better performance, yes.
14:02:22 <adamiak> Lor: because on each recurency I copy the rest of a list
14:02:29 <Lor> I'm more than a little bothered by the fact that _every_ data structure in Haskell is going to be a memory hog.
14:02:41 <Lor> Unless you use lots of low-level tweaks like PackedStrings etc.
14:02:55 <Lor> adamiak, copy? how so?
14:02:57 <musasabi> Lor: packedStrings just seem to be quite slow.
14:03:50 <adamiak> Lor: hmmmm... isn't "match (x:sx) = match sx" COPYING sx for another call of match?
14:03:57 <Lor> No.
14:03:59 <Riastradh> Uh, no.
14:04:05 <adamiak> Lor: if it isn't then wy I get so many garbage collections?
14:04:06 <Riastradh> Why would it copy sx?
14:04:08 <Lor> It's a functional language. You don't need to copy anything, since you never change anything.
14:04:29 <musasabi> Lor: I tried to make a scanner to work with them (PackedString) but it was slower than Strings.
14:04:32 <Riastradh> adamiak, there are a number of possible reasons.
14:05:04 <Riastradh> Most likely it's because there are a lot of ephemeral lazy boxes.
14:05:08 <adamiak> Oh! I have good example. I type in hugs: "elem 100000 [0..100000]"
14:05:09 <Lor> Well, I'm not comfortable with using Haskell for anything that requires either speed or needs to deal with large amounts of data.
14:05:36 <adamiak> and in this example I get (after 5 sec.): (2200065 reductions, 3100172 cells, 13 garbage collections)     
14:05:37 <Lor> Yep, lazy boxes all the way.
14:06:09 <musasabi> the return in the else clause might be the root of the problem.
14:06:29 <adamiak> how on earth does it take so much time? 
14:06:43 <Riastradh> Laziness.
14:06:56 <Riastradh> It adds a lot of extra overhead.
14:06:58 <Smerdyakov> How long does it take to build and traverse a 100000 element list elsewhere?
14:07:19 <musasabi> adamiak: could you paste the whole code somewhere?
14:07:36 <adamiak> milisec's on python
14:07:42 <Riastradh> Note that it doesn't add any time complexity.  If it copied the list, elem would have O(n!) time complexity, but that's definitely not the case.
14:07:42 <adamiak> milisecs on python
14:08:39 <Smerdyakov> adamiak, and you're sure this Python version uses linked lists and not arrays/vectors?
14:09:07 <Riastradh> It takes milliseconds in Scheme48, too, with lists.
14:09:08 <adamiak> but iterating over liked list is fastes possible
14:09:27 <musasabi> adamiak: no it isn't.
14:09:48 <musasabi> adamiak: think about cache for a moment. not all memory references are born equal.
14:10:18 <Plume> @seen zamer
14:10:18 <lambdabot> zamer is in #haskell.
14:10:21 <Plume> :DDDD
14:10:25 <musasabi> and you need to do two times more memory references in any case.
14:10:47 <adamiak> musasabi: yes, but anyway moving a pointer to pointer->next is fast
14:10:59 <Plume> @seen lambdabot
14:10:59 <lambdabot> Yes, I'm here
14:11:03 <Riastradh> No, adamiak, because you're chasing pointers, not walking across continguous memory.
14:11:09 <zamer> lol
14:11:15 <Plume> :DDD
14:11:29 <Riastradh> If you're unlucky, that is.
14:11:38 <Plume> c un jouet codé en Haskell
14:11:39 <adamiak> :) OK. But should I do with my case?
14:11:45 <adamiak> :) OK. But WHAT should I do with my case?
14:11:46 <musasabi> adamiak: try the finitemap?
14:11:53 <Smerdyakov> adamiak, change the function to just return 100000. :)
14:11:56 <musasabi> or paste the code somewhere ;)
14:11:57 <adamiak> :)))))
14:12:01 <Riastradh> You may get lucky and your lists might be in contiguous memory, but you may also get unlucky; your lists might even be in different generations, which would thrash the read barrier.
14:12:31 <Riastradh> ...assuming a generational GC.
14:15:24 <Riastradh> And in C or with non-compacting garbage collectors, it's even worse, because every allocation has to traverse a freelist to find a sufficiently-sized block of memory, which easily fragments the list's memory.  So, no, linked lists are not 'fastest' to traverse.
14:16:12 <adamiak> Riast: yes. You're right. Now i see
14:21:11 <adamiak> but anyway, if would iterate 100000 elements in linked list in C, or python, it wouldn't take 5 sec's
14:21:54 <adamiak> so why does it take so much with hugs?
14:24:04 <Riastradh> Laziness, as we said.
14:24:05 <adamiak> so much = so long
14:24:33 <adamiak> Riastradh: and the only way to make it faster is use other data structure?
14:24:37 <Riastradh> There are a _LOT_ of ephemeral thunks.
14:24:45 <Riastradh> That would improve it, yes.
14:25:19 <adamiak> But - by the way - where does this laziness exists here?
14:25:36 <Riastradh> Haskell is in general lazy.
14:25:36 <adamiak> what is not being evaluated?
14:25:55 <Riastradh> Anything that's not needed, until it is needed.
14:26:12 <Riastradh> The problem is that a lot of things are needed soon, but not immediately, so there are a zillion ephemeral thunks.
14:26:21 <arauko> also called "call-by-name" evaluation 
14:27:34 <adamiak> hmmm - so without this laziness it would run faster?
14:27:48 <Riastradh> Probably.
14:28:56 <shapr> you can add strictness
14:29:11 <adamiak> is it easy to add it?
14:29:25 <shapr> usually
14:29:28 <shapr> the hard part is to find where to add it.
14:29:46 <shapr> if the code is simple, it's not hard, if the code is very large, it can be hard.
14:30:27 <shapr> hiya SyntaxLaptop 
14:31:01 <SyntaxLaptop> hi shapr
14:34:12 <goron> adamiak: Maybe everything is optimized away in Python... 
14:35:21 <adamiak> goron: Maybe the hugs interpreter is simply slow? Maybe I download ghc?
14:35:56 <Lor> ghc does strictness analysis
14:42:07 <musasabi> btw I benchmarked the list case with ghci - accessing 50000:th element is still very fast.
14:42:42 <adamiak> musasabi: miliseconds?
14:42:45 <adamiak> :)
14:43:59 <goron> adamiak: That too...
14:44:36 <goron> hugs is a toy... (but he, they have nice frontend on Windows)
14:44:49 <Riastradh> GHC is considerably faster for me as well.
14:44:53 <adamiak> And, btw, I have to write some function's in C, that I will use with Haskell (ghc). Is it relatively easy? Is there a good documentation for it?
14:45:59 <goron> adamiak: You are a beginner?=>use a finitemap...
14:46:18 <arjanb> adamiak: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
14:46:53 <adamiak> goron: i'm a very beginner TO HASKELL. I will check the finitemap for sure, but I need to interface with a C library anyway.
14:47:14 <musasabi> http://youzen.b2.fi/~musasabi/a.hs - solutions using lists and finitemap.
14:47:50 <adamiak> arjanb: thank you!
14:47:53 <musasabi> the first few lookups will be slow but that is due to time actually generating the lists.
14:48:05 <adamiak> musasabi: thank you very much!
14:50:11 <goron> adamiak: Well, that's possible, but even I just read the documents a few months ago, and tried a toy app. You really have to know what you are doing. And it's often only usefull for porting, as Haskell Code >>C code... premature optimization is bad, as I have learned. 
14:50:50 <adamiak> goron: I don't have much choice, so I will try it anyway. But thanks for the warning.
14:50:58 <adamiak> I'm not disturbing you any more! Thank you all for solving my problem and answering all my questions. You are really great. Bye!
15:18:05 <shapr> man I've had it. I'm going to go shoot somebody.
15:18:15 <shapr> (in a computer game)
15:18:24 <arjanb> heh
15:19:15 <stepcut> shapr: fall off the wrong side of the unicycle ?
15:20:06 <shapr> stepcut: actually, you might be able to help me with my frustration :-)
15:20:18 * shapr cues the dramatic scary music
15:20:52 * kaol likes how you can use ' in names in haskell. It gives me all mathy feeling.
15:21:16 * stepcut gets the shivers
15:21:34 <shapr> stepcut: I hacked hws-wp to use hs-plugins instead of just the plain old runtime_loader so that it can automagically rebuild and reload the plugins. But, I don't know how to make an hws-wp HaskellDB plugin.
15:22:05 <stepcut> hrm, I have never used hs-plugins :(
15:22:12 <shapr> I think the problem may be that a HaskellDB plugin just doesn't fit as into an apache-module-style interface, and maybe I'm looking for a more general application server, but I'm not sure where to go.
15:22:32 <shapr> hs-plugins is a highly refined version of runtime_loader, which is a slightly built-up version of GHCi's dynamic loader.
15:23:01 <stepcut> still, I have never even used the runtime_loader until last week when I made a new lambdabot module :)
15:23:24 <stepcut> what is hws-wp ?
15:23:29 <shapr> well, you just reload .o files... but that's besides the point anyway
15:23:42 <shapr> hws-wp is Marvin--'s extension of Simon Marlow's hws webserver.
15:23:51 <stepcut> ah
15:24:01 <shapr> hws is a speedy web server written in pure Haskell, I think Simon wrote a paper about it.
15:24:27 <shapr> he was able to saturate a 10Mbps ethernet link with the web server, so it's fast enough for pretty much anything.
15:24:27 <stepcut> yeah, I have heard of hws, but I didn't know its name
15:24:33 <stepcut> hehe
15:24:59 * jao tries to make out what 'wp' stands for
15:25:08 <stepcut> I should look into that more...
15:25:11 <arauko> roots a b c =
15:25:12 <arauko>     let det = sqrt (b*b - 4*a*c)
15:25:12 <arauko> 	twice = 2*a
15:25:12 <arauko>     in (((/)((+) (-b det)) twice) ,
15:25:12 <arauko> 	((/)((-) (-b det)) twice))
15:25:17 <shapr> I hacked the Grammatical Framework and WASH together into a nifty Swedish-teaching CGI
15:25:23 <stepcut> hehe
15:25:24 <arauko> any problem with that?
15:25:46 <shapr> but the CGI is very slow, GF is pretty big. And it'll get far slower when I add support for student records, so that's why I was going for hws-wp (with plugins)
15:26:15 <shapr> thing is, a database binding just doesn't fit into an apache-module, and that's the interface that hws-wp uses.
15:26:17 <stepcut> yeah, WASH is neat, but ultimately, its very painful...
15:26:21 <shapr> yah, I agree.
15:26:32 <shapr> and it's not very good about checking types either.
15:27:06 <shapr> so I guess my question is, how the heck do I build a application server in Haskell?
15:27:39 <shapr> do I add some extra threads to hws-wp and make one of them the 'database thread' ?
15:27:42 <stepcut> if haskell had some type of persistant store, I would probably not even use a SQL database for most stuff...
15:28:02 <musasabi> haskell + persistent fast store == something very very nice.
15:28:14 <stepcut> shapr: um, I would have to read the paper first...
15:28:31 <shapr> I'm just not sure where to go from here.
15:29:04 <shapr> I can tell that I want something vaguely like Zope here, where I can generate HTML, query the database, and respond to http requests, but I dunno how to structure it all.
15:29:38 <shapr> I think the HTML generation part of WASH might be okay to use, but not the CGI part
15:30:09 <stepcut> the html stuff in wash always seems clunky to work with to me
15:30:31 <arauko> isnt a way to declare two variables with let in ghci?
15:30:34 <stepcut> I can never get the attributes of an element to attach to the right element and the first try
15:31:18 <stepcut> arauko: ?
15:31:19 <stepcut> Prelude> let (a,b) = (1,2)
15:31:20 <stepcut> Prelude> a
15:31:20 <stepcut> 1
15:31:20 <stepcut> Prelude> b
15:31:20 <stepcut> 2
15:31:21 <stepcut> Prelude> 
15:31:30 <shapr> yah, but I don't want to write a better lib right now, I just want to figure out how to mix these pieces in a working app.
15:31:40 <stepcut> hehe
15:32:26 <stepcut> well, I don't have an immediate answer, but I will read the papers, because this sounds like something I would also be interested in getting to work
15:33:00 <stepcut> I have too much stuff to read :(
15:33:37 <shapr> if you think of any ideas, I'd like to hear about it. I'm not sure how to make a real app server.
15:33:43 <shapr> Maybe I should look at the way Zope and the others do it.
15:33:49 <arauko> stepcut, thanks
15:34:06 <arjanb> arauko: ((+) (-b det)) doesn't make sense  why not write that as  (-b + det) ?
15:34:21 <shapr> maybe I should ask for ideas on the mailing lists.
15:35:03 <stepcut> shapr: what do you mean by an 'app server' anyway ?
15:35:29 <arauko> arjanb, yeah, i did that
15:35:33 <stepcut> some process is running all the time, and it can dynamically load/unload new modules that provide additional features ?
15:35:39 <shapr> yah, that
15:36:04 <shapr> some relatively sane integration of database access, web serving, maybe telnet serving
15:36:08 <shapr> I guess something like Twisted
15:36:08 <stepcut> in someways, that sounds like a possible future for something like hOp
15:36:13 <musasabi> getting it to work with a statically set set of modules would be a good start.
15:36:24 <shapr> musasabi: sure, but how to structure it?
15:36:43 <shapr> a good structure will work fine statically or dynamically.
15:36:51 <shapr> actually, the dynamic part will be really easy with hs-plugins.
15:37:28 <shapr> it took about three lines of code to switch hws-wp from runtime_loader to hs-plugins
15:37:35 <stepcut> heh
15:37:47 <shapr> I think I'll switch lambdabot next, since that would remove a lot of ugly code from lambdabot.
15:37:56 <stepcut> nice
15:38:07 <stepcut> lambdabot is fully of ugly code ;p
15:38:21 <shapr> yes, but it's there so new Haskellers can clean it up :-)
15:38:25 <stepcut> haha
15:38:46 <shapr> anyway, I'll try to think of a good structure by tomorrow.
15:39:00 <shapr> tomorrow is my last holiday for awhile.
15:39:05 <stepcut> :(
15:39:14 <shapr> back to school, back to work.
15:39:32 <stepcut> I have to go to work on Monday -- but we are having a beach party =)
15:39:40 <shapr> cool!
15:39:55 <stepcut> yeah
15:39:57 <shapr> I have to start wearing long pants and a jacket on my unicycle :-(
15:40:01 <stepcut> :p
15:40:02 <shapr> it's getting way cold outside.
15:40:28 <shapr> maybe I should try to integrate halipeto into hws-wp first
15:40:34 <shapr> that might find me some inspiration
15:43:32 * stepcut goes to lunch
15:44:45 * shapr goes to shoot people
15:45:32 <arauko> what is a good book to learn haskell?
15:47:06 <shapr> I'd suggest you start with Hal Daume's "Yet Another Haskell Tutorial"
15:47:26 <shapr> and maybe try Hudak's "Haskell School of Expression" if you want to purchase hardcopy.
15:47:44 <shapr> I also have Thompson's "The Craft of Functional Programming"
15:48:01 <shapr> I learned from Thompson, but I think Hudak is better if you understand some basic math.
15:48:23 <shapr> actually, I mostly learned from #haskell :-)
15:48:40 <shapr> lots of smart and helpful people here.
15:48:44 <arauko> :-)
15:48:57 <arauko> thanks
15:49:06 <arauko> well, yes, i was thinking to get a hardcopy
15:49:32 <arauko> i always try to ask first , to avoid throwing away my money ....
15:49:48 <palomer> are there any languages that don't require outside tools (such as flex and yacc) to generate parsers?
15:50:18 <Smerdyakov> All languages
15:50:58 <musasabi> palomer: look at e.g. parsec.
15:51:09 <palomer> so, erm, why do the tools exist if they're not needed?
15:51:34 <Smerdyakov> They make things easier.
15:51:44 <Smerdyakov> (Which is why pretty much any tool exists)
15:52:47 <palomer> ok...are there languages that have machinery that make it easy enough to pars such that no outside tools are ever needed?
15:52:57 <palomer> s/pars/parse
15:53:07 <Smerdyakov> All functional languages
15:53:38 <palomer> how is the CFG described?
15:53:55 <Smerdyakov> In the popular parser combinator approach, as an expression.
15:54:14 <palomer> do you have an example of a typical clause?
15:55:53 <Smerdyakov> No. It should be easy to find on the web.
15:56:09 <Smerdyakov> Someone here just mentioned Parsec, f'rinstance.
15:56:23 <musasabi> palomer: writing a parser is very simple. Writing a really fast parser needs tuning and is tedious.
15:56:40 <palomer> but...there exist ocamlex and ocamlyacc
15:56:42 <Smerdyakov> musasabi, don't forget error messages!
15:56:54 <palomer> ocamllex
15:57:14 <Smerdyakov> palomer, what is your point?
15:57:16 <musasabi> Smerdyakov: error "Stupid you are - the input is not correct" ;)
15:57:21 <musasabi> like that ?
15:57:54 <palomer> Smerdyakov: ocaml is a functional language, you asserted that functional programming languages never need outside tools, yet ocaml users have created and thus had a need for these outside tools
15:58:19 <musasabi> palomer: there is happy for haskell too.
15:58:27 <palomer> outside tools for parsing, that is
15:59:13 <musasabi> btw about parsers how should I match a complicated character pattern? In C I would just use if(table[c]) (where char table[256]; )
16:00:36 <palomer> oh, I remember scheme not needing an outside tool, but I'm past my scheme loving phase
16:01:00 <musasabi> palomer: there should be outside tools for scheme too... 
16:01:18 <musasabi> palomer: different approaches for different needs.
16:01:40 <palomer> which approach would, say, ocaml users usually pick?
16:03:00 <musasabi> palomer: depends mainly on the subjective views of the said user, and on the problem too.
16:03:19 <palomer> musasabi: notice I inserted the word usually
16:04:35 <musasabi> palomer: I would say they would go with ocamlyacc because they come from a C background and thus are familiar with yacc, but nort with top down parsers (which are usually simpler though)
16:05:12 <palomer> ah, what's the difference?
16:07:22 <musasabi> With parser generators one usually writes the grammar in *BNF-form with attached actions, while in the top down parser case one just writes parse_foo :: String -> ([Foo], String) 
16:07:33 <musasabi> and an implementation of parse_foo ;)
16:09:17 <palomer> but...you still need to describe the grammar
16:09:53 <musasabi> not formally.
16:10:16 <palomer> I'm confused
16:10:29 <palomer> is haskell supposed to guess the grammar?
16:10:39 <musasabi> no. you write a parser for it.
16:11:19 <palomer> so you end up using yacc, right?
16:11:31 <musasabi> nope.
16:11:40 <palomer> I thought we were discussing writing parsers
16:12:49 <palomer> were we not?
16:12:57 <musasabi> yes.
16:13:07 <musasabi> How are parsers and lexers different?
16:13:41 <palomer> I asked how to implement a parser without using yacc (using a top down approach)
16:13:50 <palomer> and you said: <musasabi> no. you write a parser for it.
16:13:54 <palomer> ?
16:14:03 <palomer> that's the crux!
16:14:07 <shapr> do parser combinators count as external tools?
16:14:15 <musasabi> ok. let's make a simple grammar. a list of digits separated by a comma.
16:14:28 <shapr> are you thinking of a language that has parsers integrated like perl has regexes integrated?
16:15:01 <palomer> shapr: erm, I guess
16:15:13 <palomer> shapr: all you have is the programming language, nothing else
16:15:40 <shapr> but that's not true, as soon as I write a function, then it's something else.
16:15:50 <palomer> ok, programming language and your code
16:15:52 <palomer> (silly)
16:16:22 <shapr> at what level is code part of an external tool?
16:16:29 <musasabi> palomer: http://youzen.b2.fi/~musasabi/a.hs
16:16:38 <shapr> like, Parsec is written in Haskell, is it an external tool?
16:16:39 <palomer> if you need to run something else other than haskell
16:16:42 <musasabi> that is a simple lexer/parser.
16:17:16 <musasabi> palomer: there are three implementations of the same thing in the file.
16:17:33 <palomer> ahh
16:17:34 <musasabi> one using a simple scheme, an another threaded one, and one using parsec.
16:18:13 <palomer> so no exterior tools are needed
16:18:16 <palomer> (libraries are fine)
16:18:30 <musasabi> (please reload the file it was a stale version)
16:18:38 <arjanb> musasabi: how do you write code that fast?
16:19:07 <musasabi> arjanb: magic or cut-and-paste - select the one you want to believe.
16:19:48 <palomer> which way is usually the easiest?
16:20:10 <palomer> out of the 3
16:22:03 <musasabi> palomer: using the language is usually easiest in the start, but if the grammar gets very complex then using an external tool will help. Also consider whether you need backtracking and how easy it is to implement in different places.
16:23:22 <palomer> so yacc is recommended for complicated grammars
16:23:47 <palomer> I always wondered why the code and the grammar aren't _completely_ separate 
16:24:02 <palomer> ie you get the parse tree and manipulate it
16:24:20 <palomer> the grammar is only there to generate the parse tree
16:25:02 <Smerdyakov> Why build an extra data structure?
16:25:11 <musasabi> palomer: yacc is not very well suited for complicated things because of it's limitations, but yes starting from scratch would not be wise for something complex.
16:25:15 <palomer> separation of concerns
16:25:25 <musasabi> palomer: you don't want to have a separate structure...
16:25:32 <palomer> why?
16:25:37 <Smerdyakov> Of course, the real reason this wasn't done originally is that using such a structure is intractable in C.
16:25:39 <musasabi> palomer: and when you have ~1million elements?
16:26:15 <palomer> then you have a big structure
16:27:06 <palomer> I don't think parsing is the most time consuming part of compilation, is it?
16:27:08 <musasabi> would kind of defeat "I will use this tool to generate a hyper-fast parser for me" ?
16:27:24 <musasabi> palomer: not of compilation, of many other tasks, yes.
16:27:33 <palomer> I don't care much for efficiency 
16:28:04 <palomer> and compilation is my main concern
16:28:52 <musasabi> palomer: then use whatever is the simplest for you.
16:29:01 <palomer> are there any other reasons for not generating the parse tree?
16:29:08 <musasabi> palomer: parsec has some nice things for parsing programming language source.
16:52:34 <musasabi> Something like distcc for ghc would be nice...
17:11:14 <stepcut> is there a reason to use fail instead of error ?
17:38:04 <ne1> fail comes from Monad.  It generalizes.
17:56:30 * stepcut is writing from very hacked up code
18:41:53 <upiom> Hi. I'm a total newbe on haskell and functional-languges. And I seem to constantly bang in to error after error. I have made an loop to calculate from 10 to 0, works fine. But when I try to print the values I get an error.
18:41:58 <upiom> Here is the function:
18:42:08 <upiom> loopi 0 = 
18:42:08 <upiom> 	putStr "Klar"
18:42:08 <upiom> loopi i =
18:42:08 <upiom> 	print i
18:42:08 <upiom> 	loopi (i - 1)
18:44:07 <anduril1> upiom: are you familiar with "do"?
18:45:01 <upiom> anduril1: only that it was the last big problem I run into when trying som I/O helloworld stuff.
18:46:10 <anduril1> upiom: okay, in Haskell, when you want to do IO, you use a construct called a "Monad" to do it
18:46:37 <upiom> anduril1: hmm ok, so writing do in the beginning of the function solves the problem. I havn't really understood what I've read about do so far. Biggest question i propably when no to have it.
18:46:45 <anduril1> upiom: but you don't care about that, so there's a simple abstraction over monads, called do notation
18:48:26 <anduril1> http://www.haskell.org/hawiki/UsingIo
18:48:33 <anduril1> maybe that'll help you?
18:50:06 <upiom> I've had a problem finding a good tutorial. I started follow one but the second example (from the tut.) didn't compile :( the wiki seems nice though, tanks for the tips
18:50:10 <heatsink> upiom: Monads are hard to understand, and unfortunately you have to understand them to do anything that does input or output
18:50:22 <arauko> factorial 1 = 1
18:50:22 <arauko> factorial n = n * factorial (n-1)
18:50:47 <arauko> i cant believe it
18:51:17 <heatsink> arauko: why not?
18:52:54 <arauko> i use(d) to write 5 lines (at least) to calculate the factorial of a number 
18:53:53 <heatsink> arauko: factorial n =
18:53:58 <heatsink>     (n *
18:54:00 <heatsink>      factorial
18:54:07 <heatsink> you can make it five lines :)
18:54:15 <anduril1> arauko: http://www.willamette.edu/~fruehr/haskell/evolution.html
18:54:29 <anduril1> there are some examples if you want things to be more complicated
18:56:28 <arauko> oh no, i mean, what a great language 
18:57:02 <anduril1> arauko: of course!
18:58:13 <arauko> you use to read about languages that makes your life easier.... but you barely appreciate that in some fields.., seems like Haskell does it for everything, even for a simple factorial function 
18:58:52 <heatsink> haskell won't make my life easier until I understand how to use monads
18:59:38 <heatsink> These two lines from parsec confuse me
19:00:29 <heatsink> type Parser a           = GenParser Char () a
19:00:38 <heatsink> newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))
19:01:16 <heatsink> The GenParser in the first line is the same as the GenParser in the second line, right?
19:01:24 <heatsink> Is the Parser in the second line the same as the Parser in the first line?
19:02:10 <anduril1> I think the second line's Parser is not the Parser referred to in the first
19:05:39 <arauko> how do i do to pass two arguments to sumsquare, and then its result to factorial... i was trying something like (factorial . sumsquare) 2 3
19:05:53 <arauko> but doesnt work
19:05:55 <heatsink> factorial $ sumsquare 2 3
19:06:07 <arauko> thanks
19:06:22 <heatsink> I think (factorial . sumsquare) 2 3 becomes (factorial (sumsquare 2)) 3
19:06:57 <arauko> it looks like 
19:19:20 <anduril1> ((.).(.)) factorial sumsquare 2 3
19:19:33 <anduril1> that works too, if you're in the mood for ridiculous
19:27:47 <blackdog_> we need more emoticon seport in haskell.
19:27:50 <blackdog_> support, even.
19:31:55 <dons> shapr: you can use hs-plugins' loader in ghci, but you need ghc-6.2.2 or the head. there is a fix that went in to let the internal and external loaders cooperate properly
19:32:18 <dons> you can even run plugs inside ghci, which is kind of silly and fun
19:33:01 <arauko> anduril1, hah, thanks
19:52:21 <stepcut> dons: nice!
19:53:49 <dons> :)
20:57:16 <palomer> hrm
20:57:26 <palomer> I need a guide on how to become an expert parser
20:58:10 <stepcut> palomer: step 1. practice
20:58:28 <stepcut> it's a 1-step plan
20:59:21 <palomer> practice with what?
20:59:24 <palomer> C/flexx/yacc?
20:59:45 <stepcut> parsec, of coure!
20:59:54 <palomer> I  don't even know haskell though
21:00:21 <stepcut> that will make things take longer
21:06:11 <palomer> hrmphrm
21:09:10 <heatsink> cool, my parser sort-of works
21:09:20 <heatsink> I get the feeling parser code isn't supposed to be this ugly, though
21:11:06 <stepcut> :p
21:12:35 <heatsink> Why did they have to use continuations to demonstrate combining monads? One difficult concept at a time, please! http://www.nomaware.com/monads/html/hardway.html
21:13:20 <arauko> is this monad stuff really hard to get?
21:13:34 <palomer> considering that I'm the smartest person here
21:13:39 <palomer> and I don't know what monads are
21:13:42 <heatsink> heh
21:13:46 <arauko> hahaha
21:14:17 <palomer> I have to say unequivocally: yes
21:14:21 <heatsink> arauko: I think yes, but you should get the opinion of someone who understands them as well
21:14:33 <arauko> hah good point 
21:14:43 <arauko> well, they would say me it is easier :-)
21:15:45 <palomer> do you guys dream about tetris?
21:15:50 <heatsink> no
21:15:51 <arauko> what is a good book, with either beginner and intermediate contents?
21:15:57 * heatsink hasn't played tetris in long
21:16:59 <heatsink> arauko: "Network security: Private Communication in a Public World" by Kaufman, Perlman, Speciner
21:17:34 <arauko> heatsink, i was asking about tetris 
21:18:04 <heatsink> there are tetris books?
21:18:26 <arauko> arent there?
22:46:35 <heatsink> Could someone give me style comments on my code?
22:47:05 <heatsink> It works but I think it's messy
22:47:58 <heatsink> hmm
22:48:08 <heatsink> rafb.net's paste tool doesn't do haskell syntax highlighting
22:48:25 <heatsink> !pastebin
22:48:30 <heatsink> !paste
22:48:33 <heatsink> !help
22:48:48 * heatsink looks for the channel's bot
23:04:39 <heatsink> can I get some style advice on this code? It's working but it doesn't look "right"... http://www.rafb.net/paste/results/rZ35TS89.html
23:15:55 <arauko> i got a function like this = 
23:16:09 <arauko> length (x:xs) = ...
23:16:17 <arauko> what the (x:xs) means?
23:17:18 <heatsink> x:xs is a list
23:17:29 <heatsink> x is the first part of the list, xs is the rest of the list
23:18:44 <arauko> something like the (lambda(x . y) .... in scheme rigth?
23:18:59 <heatsink> no...
23:19:25 <heatsink> it uses haskell pattern matching, which doesn't have a scheme counterpart
23:20:04 <heatsink> A haskell list is recursive like a scheme list
23:20:08 <arauko> ok, but i mean, is it the same effect?
23:20:23 <heatsink> hmm
23:20:33 <heatsink> yes, I think so
23:20:50 <arauko> aah ok thanks
