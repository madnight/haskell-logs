01:20:22 <musasabi> hmm is Text.Regex supposed to break with strings containing '\NUL' ? (it does with ghc because it uses withCString)
01:20:27 <musasabi> Prelude Text.Regex> matchRegex (mkRegex "b") "a1b"
01:20:27 <musasabi> Just []
01:20:27 <musasabi> Prelude Text.Regex> matchRegex (mkRegex "b") "a\000b"
01:20:27 <musasabi> Nothing
01:24:18 <dons> well, it is a binding to the POSIX regular expression library, which requires null-terminated strings
01:26:05 <musasabi> so it does not use ghc-6.2.1/libraries/base/cbits/regex, but the posix facilities?
01:27:11 <musasabi> (after reading Makefiles, seems that it uses it's own code on platforms not supporting posix regexps)
01:27:50 <dons> yep.
01:27:57 <dons> looks for regex.h, doesn't it?
01:28:13 <dons> and otherwise uses the local copy
01:28:24 <dons> #if !defined(__HUGS__) || defined(HAVE_REGEX_H)
01:54:45 * musasabi thinks of evil piggypack-loading schemes for haskell via mod_perl
02:24:37 <juhp> yay - gtk2hs docs are now generated with haddock :)
02:28:18 <shapr> yay
02:57:28 <ikegami--> Tj\"ana' shapr
03:35:13 <juhp> hmm
03:36:12 * juhp ponders removing the -ghcXYZ suffix from the rpm binary gtk2hs subpackages
03:37:52 <juhp> ah, I think I "get" the main pkg package shouldn't have any ghc suffix, if there is a ghc64 package say, then we can have gtk2hs-ghc64 etc...
03:38:02 <juhp> get=get it
03:57:33 <goron> @seen Smerdyakov 
03:57:34 <lambdabot> Smerdyakov is in #haskell.
04:51:33 <shapr> hej ikegami-- 
04:52:04 * shapr Ã¤r yrvaket
04:58:09 <juhp> on second thoughts that is upgrade unfriendly I think I'll stick with -ghcXYZ (replacing -ghcX.Y.Z)
05:04:42 <ikegami--> now I'll return home from our lab.
05:04:44 <ikegami--> bye all
05:30:12 <shapr> dons: awake?
05:30:40 <shapr> too bad Si\ isn't around...
05:32:00 <musasabi> damn ghci panicking...
05:32:14 <shapr> is there any way to ask a value or type which source file it comes from?
05:32:25 <goron> :info
05:32:27 <Lemmih> :i?
05:32:32 <goron> in ghci
05:32:42 <shapr> from inside a running Haskell program?
05:32:43 <goron> I used it 5 minutes ago. 
05:33:03 <goron> shapr: If you administrate it yourself
05:33:07 <shapr> I'm trying to figure out some way of transporting a Data.Dynamic value and reconstituting it on the other end of a TCP/IP connection.
05:33:39 <shapr> bok Amadan 
05:33:49 <Amadan> hi shapr, how's things?
05:33:56 <goron> reconstituting equals reconstructing?
05:34:25 <shapr> right, I want to figure out how to get enough information to a separate running RTS to pass the value
05:34:37 <shapr> even if it's a complex type that the other RTS doesn't know about yet
05:34:45 <shapr> Amadan: fun as always
05:34:48 <shapr> how are you?
05:35:00 <goron> That's out of my league :) At least for the moment...
05:35:02 <Amadan> nervous... my uni's not here yet... :(
05:35:55 <shapr> goron: so, I figure I can use dons' hs-plugins to dynamically load send a Haskell source file I've just sent over (assuming it doesn't depend on any C code)
05:36:53 <shapr> I just wonder how I can go from a type to file(s) that it depends on...
05:38:59 <goron> shapr: Well, you could dump it in some file... But I would contact Simon Marlow to ask whether there's some support for it in the RTS.
05:40:22 <goron> Unless you know the RTS system inside out, that is.
05:40:50 <shapr> not me
05:46:47 <goron> shapr: But if you know you always have the haskell sources, you can send an extra file containing the types. I believe you also can make it work binary(increasing usage, although you are only open-source). Don't you agree?
05:47:54 <musasabi> shapr: you could parse the files containing the types and keep a Typename -> FilePath association map.
05:48:09 <shapr> yes, but I was hoping for built-in support.
05:48:28 <musasabi> shapr: then the receiving site does e.g. readIO, and if it fails asks the site "send me the file needed". 
05:48:35 <goron> shapr: Then you should ask the people that know best :-)
05:49:00 <musasabi> shapr: you want to limit the mechanism to just type declarations to give some decree of security.
05:50:12 <shapr> actually, I'd like to be able to send anything
05:50:27 <shapr> but I'd be fine starting with values
05:50:47 <musasabi> well haskell handles functions in an evil way...
05:51:10 <musasabi> that is they are not values in a usefull sense.
05:51:14 <shapr> right
05:52:21 <musasabi> and instead of values one should provide futures to the remote side...
05:52:44 <musasabi> (consider value versus future with infinite structures)
05:52:53 <shapr> hiya Si\!
05:53:08 <shapr> yah, that's a good point.
05:53:16 <shapr> how would you send a thunk?
05:53:38 <shapr> Si\: are you sending values to a remote RTS?
05:55:00 <shapr> Si\: any ideas on sending types/values to a remote RTS via TCP/IP?
05:56:12 <musasabi> shapr: you wouldn't you would send a transparent future when evaluated force the evaluation of the original value. Of course that would need to be optimized for the common case.
05:56:50 <shapr> in any case, you'd probably want to have some way to ask for remote thunks
05:57:12 <shapr> right, hm
05:58:09 <goron> shapr: There is SOAP.
05:58:34 <shapr> it's not really Haskell oriented
05:58:38 <goron> shapr: And that looks to works...
05:58:43 <goron> shapr: There is a haskell version
05:58:55 <shapr> it's mostly about remote execution
05:59:11 <goron> shapr: That's true, but values can be send. 
05:59:21 <goron> only no functions, I think/
05:59:22 <shapr> part of my goal is a database like mnesia
06:01:22 <shapr> Si\: hey, there's no source in the HAIFA cvs tree on savannah
06:01:24 <musasabi> shapr: then perhaps start with ets?
06:01:38 <shapr> doh, I was looking at the *web* cvs tree
06:02:28 <shapr> I wonder how ets works...
06:03:25 <shapr> g'day SyntaxNinja 
06:03:34 <SyntaxNinja> hihi shapr
06:05:06 * shapr reads about ETS
06:06:07 <Igloo> Hi guys
06:07:35 <shapr> hi Igloo 
06:07:47 <shapr> still in .ee?
06:07:56 <Igloo> Yup
06:08:02 <shapr> having fun at AFP?
06:08:20 * Igloo is trying to convince epigram my shed is syntactically correct, currently
06:08:41 <Igloo> Ah, I'd just put the type sig ni the wrong place
06:08:47 <shapr> heh
06:08:47 <Igloo> So yes  :-)
06:08:53 <shapr> sounds like fun!
06:09:09 <Igloo> But exporting xemacs+epigram over SSH is definitely not fun
06:09:44 <shapr> it'd probably be a lot faster if you run it with -nw
06:09:57 <Igloo> nw?
06:09:57 <shapr> but you may lose some of the color
06:10:08 <shapr> means don't use X, just text
06:10:16 <Igloo> I assume the problem is it redrawing the entire screen each keystroke
06:10:19 <shapr> 'run in a terminal'
06:10:35 <Igloo> Oh, that would probably be much better but I don't know enough of the buffer navigation commands to do that
06:10:41 * Igloo is in the lab running it locally now
06:10:51 <shapr> that's partially epigram, it does a lot of interaction with xemacs
06:11:02 <kosmikus> the problem is that Conor has redefined all the buffer navigation commands
06:11:13 <kosmikus> there is, afaik, no way to scroll up besides using the scroll bar
06:11:56 <Igloo> Oh, the interface itself is horrid too. Can't select text without copying it to a scratch buffer, no "press tab for next shed", ...
06:12:32 <shapr> Conor has claimed he'll clean up the xemacs stuff.
06:12:38 <kosmikus> yes, and shift-space not producing space, and no way to put something in parentheses after you've written it, and ...
06:12:47 * shapr agrees
06:12:59 <shapr> Igloo: maybe you can persuade him to use your curses binding :-)
06:13:25 <Igloo> Why do you want shift-space? Just to make it easier to write "FOO BAR" or something?
06:13:32 <kosmikus> I think his first priority is to make it more efficient, and he somehow hopes to find someone else to write a better user interface
06:13:53 <Igloo> We just need to drop Duncan some gtk2hs hints, I think  :-)
06:13:58 <kosmikus> Igloo: happens many times to me, especially after a :, that I still have space pressed
06:14:03 <kosmikus> shift, even
06:14:44 <kosmikus> so, I think I write X : *, and I get X :* on screen, or even X:* ... it's mildly annoying, not a real problem
06:14:55 <kosmikus> but every other program I know interprets shift-space as space
06:15:08 <Igloo> For some reason when I try to write vec I don't get a place to write the actual definition. I wonder if I'm putting the _ in the wrong place or something
06:15:15 <shapr> I'm almost tempted to clean up the xemacs code, it can't be too hard to make all the bindings buffer local
06:15:24 <shapr> too bad elisp sucks so much
06:15:25 <Igloo> Ah, well epigram will twiddle all your spaces for you anyway, of course  :-)
06:15:43 <kosmikus> Igloo: what are you writing? the _ is not really working in interactive mode ...
06:16:02 <Igloo>      (       x : X        !    
06:16:02 <Igloo> let  !--------------------! ;  
06:16:03 <Igloo>      ! vec _n x : Vec X n )    
06:16:35 <kosmikus> then _n will just be implicit, so epigram will ask you to program vec x, without n
06:16:51 <kosmikus> and there's no way currently to make that _n visible again in interactive mode
06:16:54 <Igloo> But it's not asking me to program anything
06:17:01 <kosmikus> oh
06:17:13 <kosmikus> ah
06:17:20 <kosmikus> try 
06:17:30 <kosmikus> let ( n; x : X ! ....
06:18:07 <kosmikus> I think I had the same problem
06:18:36 <kosmikus> but if you mention the n in the antecedent (no type required), it should work
06:18:46 <Igloo> Aha, ta
06:19:07 <kosmikus> but even better is to do it the way Conor described in his talk
06:19:22 <kosmikus> make a vecPre with an explicit length argument
06:19:31 <kosmikus> then define vec x => vecPre ? x
06:19:44 <kosmikus> code inference :)
06:20:35 <Igloo> Ah, this works, I just have to guess what variable names it has picked and what the constructors are
06:20:41 <Igloo> This is going to be a scary definition  :-)
06:21:40 <Igloo>      vec x <= rec n                 
06:21:40 <Igloo>      { vec x' <= case x             
06:21:40 <Igloo>        { vec x' => vnil             
06:21:41 <Igloo>          vec x' => vcons x' (vec x')
06:21:51 <Igloo> works  :-)   (with a couple more }s)
06:21:59 <kosmikus> yes, it does
06:22:12 <kosmikus> but there is some risk that it won't accept the buffer next time
06:22:39 <kosmikus> because it might name the internal variables (n,x,...) differently
06:22:45 <kosmikus> very strange, but I had this
06:31:05 <shapr> Igloo: if it won't distract you, can you think of some way to go from a type to a FilePath so I can migrate values from one running RTS to another? 
06:32:21 <TheHunter> stupid question: how do i write a "-----" in epigram?
06:32:33 <shapr> type ---- and hit enter
06:32:38 <Igloo> "---", but you might need a blank line above and/or below it
06:32:42 <shapr> it's wiki-like in that respect
06:32:46 <shapr> oh, three times :-)
06:32:46 <Igloo> I don't understand, shapr
06:34:15 <shapr> Igloo: if data Tree a = ... isn't on the other RTS, I could use hs-plugins to dynamically load the type, if I can send the source file across the connection. Is there some way to get from a value to a FilePath where its type is defined?
06:34:53 <TheHunter> i see, thanks
06:34:59 <Igloo> Hmm, I could do with more informative error messages than a brown background  :-)
06:35:31 <Igloo> Oh, err, NAFAIK, but I haven't looked into that sort of stuff
06:35:41 <kosmikus> Igloo: Rinus is giving a talk right now ... I don't know if you're still upstairs, or if you're interested
06:36:06 <Igloo> If I'd known before I might have stayed, but I CBA to move for it now
06:36:13 <shapr> heh
06:36:18 <Igloo> I'm not overly interested in clean I don't think
06:36:25 <Igloo> I'd rather spend more time on epigram
06:36:31 <kosmikus> agreed
06:36:43 <kosmikus> epigramming is fun
06:36:47 * shapr agrees
06:36:49 <Igloo> Can you see what's wrong with this?
06:36:50 <Igloo> let  (------------------------!                                    
06:36:50 <Igloo>      ! testlist : Vec ? three )                                    
06:36:50 <Igloo>                                                                    
06:36:50 <Igloo>      testlist [=> vcons three (vcons five (vcons fifteen vnil))]
06:36:57 <Igloo> Ooops, sorry for the spaces
06:36:59 <shapr> epigram is extraspiffy.
06:37:05 <Igloo> three, five and fifteen are Nats
06:37:18 * shapr creates #epigram
06:37:37 <kosmikus> does it work without the `?' ?
06:37:57 <Igloo> Just tried that - yup
06:38:13 <Igloo> So I don't understand why it would ever accept a ?
06:38:37 <musasabi> shapr: have you considered multiple types with the same name in the local program?
06:38:44 * Igloo makes a non-working copy too to ask Conor about later
06:39:02 <kosmikus> I think it must be possible to "locally" infer the missing argument
06:39:23 <Igloo> It accepted the entire type sig, though
06:39:26 <shapr> musasabi: I think I just need to find some way to match and synchronize entries in the type tables of two RTSs
06:39:41 <kosmikus> I don't know the precise status of ?
06:39:59 <shapr> from reading Typeable.hs, it seems that each type does have a unique name
06:40:13 <shapr> I don't know how that works with qualified names and such.
06:40:34 * kosmikus is tired of fixing lhs2TeX
06:40:39 * kosmikus starts epigram again
06:40:45 <Igloo> :-)
06:40:58 <shapr> I think I'd understand the problem a lot better if I wrote some unit tests to check all these picky bits
06:41:32 <Igloo> Hmm, what's this meant to mean? inspect map (plus three) testlist => ? : Vec Nat (suc (suc (suc zero)))
06:42:17 <kosmikus> that it can't evaluate the call (yet)
06:42:31 <Igloo> Oh, it means my magical vec definition broke. Bah humbug  :-)
06:42:31 <kosmikus> but it tells you the type
06:42:40 <kosmikus> I warned you
06:43:00 <Igloo> I thought you were hypothesising but expected it to be consistent
06:43:14 <kosmikus> no, I said that I had this problem
06:43:35 <Igloo> I thought you just meant needing the "n; " in the type
06:43:46 <kosmikus> both ;)
06:45:42 <Igloo> Oh, I think I crashed it
06:47:29 <earthy> ah, the famous generic guis talk
06:47:52 <kosmikus> grmblxkrch
06:53:28 * Igloo fails to work out exactly what conditions are needed for ^C^C to work
06:53:59 * kosmikus doesn't know either
06:54:02 <kosmikus> it usually works
07:07:14 <Igloo> What's emacs for J?
07:07:20 <Igloo> Oh, that won't help anyway
07:09:58 <musasabi> How can I define a recursive type like:
07:10:03 <musasabi> type Parser = (State -> Char -> Parser, State)
07:10:22 <kosmikus> musasabi: use newtype or data
07:10:53 <musasabi> thanks
07:14:46 <Igloo> Hmm, anyone know how to say "case eq x y of" in epigram?
07:14:55 <Igloo> Both case and view seem to do it, but not show me which case is which
07:17:30 <kosmikus> now Conor is saying something
07:17:39 <shapr> ?
07:17:44 <shapr> Conor speaks!
07:17:57 <Igloo> Oh bother. Is it important?
07:18:04 <kosmikus> not yet
07:18:23 <kosmikus> he's saying one of his expert students will shortly come upstairs to help you :)
07:18:33 * Igloo investigates to see if Horace knows the answer
07:18:58 <Igloo> Excellent  :-)
07:19:44 <Igloo> Right, Horace seems as ignorant as me
07:21:08 * Igloo wonders how I recognise the student
07:23:44 <kosmikus> maybe you'll notice him helping someone else, or looking around, or looking british, or ...
07:23:58 <kosmikus> Conor also announced that he'll divide his time between both rooms
07:24:22 <kosmikus> as he's easily recognisable, ...
07:27:24 * Igloo found him, but he wasn't much help
07:27:55 <Igloo> I'll leave that definition and see if Conor appears, I think
07:37:38 <kosmikus> I think I'm a step closer to understanding "view"
07:42:45 <Igloo> Ooops, I've started swapping
07:43:40 <stefan_> seems like you are having all the fun there ...
07:46:36 <kosmikus> true
07:46:44 <kosmikus> my machine is swapping as well :)
07:49:08 <Igloo> The problem with the ? was that I'd written something equivalent to   foo :: a -> Bool; foo = <something of type Int -> Bool> BTW
07:49:51 <Igloo> And you can't do case analysis of intermediate values, unless you make use of the fact that the cases are in the order you defined them in
07:50:25 <Igloo> Ho humm, I think I really need to stick some of my old crap into another module. Although actually, most of it is still needed.
07:50:53 <edwinb> Oh is Conor on now?
07:51:20 <kosmikus> we're having practical right now
07:51:41 <Igloo> Ah, but you can say
07:51:43 <Igloo> let  testlist2 : Vec ? three
07:51:46 <kosmikus> but epigram doesn't let me write boundCheckable :/
07:51:47 <Igloo> testlist2 => vcons three (vcons five (vcons fifteen vnil))
07:51:55 <edwinb> What are you trying to write?
07:52:32 <kosmikus> Igloo: isn't that the same you had before?
07:52:56 <Igloo> No, before it was on the bottom of a ---
07:53:02 <kosmikus> ah
07:53:44 <kosmikus> I think I can understand why it makes a difference
07:59:19 * Igloo gets bored of waiting for epigram
08:03:14 <earthy> is it that slow? :)
08:03:37 <edwinb> It's, er, in need of some optimisation, yes...
08:03:46 <earthy> ah. it is. :)
08:03:53 <edwinb> Best thing to do is save, quit, and restart, if it gets too chugsome.
08:06:42 <kosmikus> seems to have some considerable space leaks
08:06:52 <Igloo> It's not fast to start with. Once it hits swap it's really that slow
08:07:34 <edwinb> I suppose Conor must have mentioned that he's planning to refactor it soon.
08:10:30 <kosmikus> sure
08:10:40 <kosmikus> but we're trying it *now* :)
08:12:05 <Igloo> Fools that we are  :-)
08:12:33 * goron too
08:14:04 <goron> Is there a haskell benchmark project?
08:15:09 <edwinb> I just wouldn't want the impression to be that it's inherently slow ;)
08:15:23 <edwinb> There's the "nofib" suite, I suppose...
08:15:48 <goron> edwinb: But that compares two interfaces, I thought?
08:16:25 <goron> I mean something with nice visualisations. Nice addition to haddock
08:16:45 <edwinb> Oh, I see. Not nofib then ;)
08:16:56 <kosmikus> edwinb: epigram or haskell? I don't believe that the epigram language is inherently slow.
08:17:12 <edwinb> epigram, I meant.
08:19:52 <kosmikus> don't worry, then. I don't like everything, but it is very promising
08:28:04 <goron> Epigram looks unfriendly, imo. Is it meant to have any practical relevance someday?
08:29:23 <edwinb> It is the early stages of research. What looks unfriendly about it?
08:29:56 <stefan_> haven't read to much about it yet, but it sounds promising ... where should I start?
08:30:22 <edwinb> The AFP notes, I think. On http://www.dur.ac.uk/c.t.mcbride/
08:30:26 <goron> The enormous amounts of ----. I know that you are deducing, but still... Nice idea, though..
08:30:53 <edwinb> The interface has much to be done to it, you should expect to have to do as much typing as you do now.
08:31:06 <goron> I was reading the docs, only the pdf isn't rendered ok, either my system is wrong, or you didn't made the pictures not just yet.
08:31:06 <edwinb> Or indeed as much mousing.
08:31:25 <edwinb> The one on http://www.dur.ac.uk/CARG/epigram is better, come to think of it.
08:32:00 <goron> edwinb: I could read somethings, but a lot is missing.
08:32:11 * edwinb has a look
08:32:13 <stefan_> edwinb: thanks, I'll check it out
08:32:34 <goron> edwinb: The tutorial is completely unreadable.
08:33:02 <goron> edwinb: I only get horizontal lines.
08:33:27 <edwinb> Weird.
08:33:49 <edwinb> Hang on... I'll see fi I can make a better one
08:34:02 <goron> edwinb: What program do you use?
08:34:17 <edwinb> Conor made that one with ps2pdf. I use dvipdfm
08:34:22 <goron> edwinb: For rendering the pdf?
08:34:30 <edwinb> yes
08:34:38 <goron> edwinb: I mean viewing. 
08:34:43 <edwinb> Oh, acroread
08:35:25 <goron> I will get it.
08:35:32 <edwinb> Oh, I see what's happened...
08:35:48 <edwinb> There's an overnight build which overwrote the nice pdf with the badly rendered one.
08:36:38 <goron> edwinb: You should make more building logic ;)
08:36:54 <edwinb> http://www.dur.ac.uk/e.c.brady/epigram.pdf is a nicer version
08:37:03 <edwinb> I don't have time to fix it properly now...
08:37:23 <goron> edwinb: Indeed
08:41:09 <goron> edwinb: Your expression(first in motivation) has no type error... 
08:41:28 <edwinb> Now read on ;)
08:43:00 <goron> Well, I did, but I don't find it clear. It looks like you want to imply something with:"Of course you haven't."
08:43:24 <goron> edwinb: That's how I interpreted it. But you meant something else.
08:43:27 <edwinb> Er, yes, it means that there isn't a type error...
08:43:31 <edwinb> (I didn't write this, btw...)
08:43:48 <edwinb> The point is that the program is clearly nonsense, but the typechecker doesn't spot it.
08:43:56 <goron> edwinb: I understand, but I read it different the first time. 
08:44:02 <goron> edwinb: I know.
08:45:09 <edwinb> I'm not sure what you see as the problem - how did you interpret it?
08:47:44 <goron> goron: Well, I interpreted it as, you as a stupid human, would never find this super hard to find error. As in, that the human looks over the type error. While in fact, that's not what the writer is trying to say. But that's how I read it.  
08:47:57 <edwinb> Oh, I see.
08:51:57 * stefan_ decided to never write an imperative program again ... (after helping someone debug a program this morning) :S
08:53:07 <goron> stefan_: Functional programs can also be annoying to debug. You have to check every application of a function in a chain... And as far I know there are no debuggers for Haskell, that can do this, or am I wrong?
08:54:23 * shapr bounces
08:54:26 <stefan_> goron: you might be right about that ... but I want a language to make me feel like _I_ am stupid, not make me curse its designers ;)
08:55:38 <edwinb> I find debugging Haskell a rather different process than debugging imperative code though.
08:56:06 <shapr> I think that if you use HUnit and QuickCheck, it's very easy to debug Haskell code.
08:56:09 <edwinb> In that if there's a bug I've got something rather more fundamental wrong than a null pointer or somesuch.
08:56:18 <stefan_> shapr: I agree
08:56:22 <shapr> but I've already explained my dislike of debuggers.
08:56:48 * shapr waves the three XP books in his hand
08:56:53 <goron> shapr: Explain. I am using QuickCheck now. But I only have tests for input and wanted output, and not for every tiny function.
08:56:54 <stefan_> edwinb: yep ... in Haskell I find myself debuggind far less oftern than when I'm writing C or Java
08:57:12 <edwinb> That's partly because the type system gives you a lot more help, of course.
08:57:16 <shapr> goron: write the tests first
08:57:39 <SyntaxNinja> has anyone ever heard of "CWL" Containers and Widgets Language, "a declarative, haskell-based EDSL to define data-centric web GUIs using a container and widget abstraction"
08:57:49 <goron> shapr: On what level of complexity do you write them? 
08:57:50 <shapr> er, I've heard of that somewhere.
08:57:52 <edwinb> Think about what properties the functions ought to satisfy.
08:58:02 <SyntaxNinja> referenced in "generic implementation strategies for data-centric web applications" by Steve Van Hoyweghen
08:58:07 <shapr> oh yeah
08:58:18 <shapr> that's a cool demo
08:58:26 <shapr> though it doesn't work with the latest moz
08:58:36 <goron> How can I make random parser input that is element of the language represented by the parser?
08:58:42 <shapr> I think he's right about changing the approach to data-centric webapps
08:58:56 <shapr> but, I think he's just approaching Generic programming from another direction.
08:59:35 <SyntaxNinja> shapr: do you know where I could find this EDSL?
08:59:44 <edwinb> goron: You have a data structure representing parsed terms, yes?
08:59:53 <goron> edwinb: Yes
08:59:54 <shapr> SyntaxNinja: yes, it comes with the download of his demo
09:00:05 <shapr> I have the download around here somewhere if his site is offline
09:00:12 <SyntaxNinja> the author's demo?
09:00:14 <shapr> I've swapped email with him too, but he says he's not pursuing that idea.
09:00:14 <shapr> sure
09:00:14 <edwinb> So make a random one of those, then write out a string which is parsable.
09:00:22 <edwinb> This may not be easy, of course...
09:00:39 <shapr> goron: make an instance of Arbitrary so that QuickCheck does it for you.
09:01:04 <goron> edwinb: But randomness is only in the IO monad. Although I remember that QuickCheck exported randomness, as non IO...
09:01:18 <SyntaxNinja> shapr: so this Van Hoyweghen guy si the author of CWL?
09:01:23 <shapr> sure
09:01:35 <stefan_> edwinb: it makes some strong assumptions: all values of the AST type are sentences of the language, and there is a pretty printer available
09:01:45 <shapr> it's a good idea with just enough implementation to show that it would be cool
09:01:52 <shapr> but it's not usable, because it's just barely a skeleton
09:02:04 <shapr> believe me, I tried :-)
09:02:05 <SyntaxNinja> shapr: I'm confused about whether you're talking to me
09:02:09 <shapr> SyntaxNinja: yes you
09:02:15 * SyntaxNinja hasn't been folloowing the other conversation ;)
09:02:23 * goron goes to eat... But some advice about QuickCheck is still welcome :)
09:02:29 <SyntaxNinja> shapr: cool. thanks.
09:02:31 <SyntaxNinja> off to lunch &
09:02:35 <shapr> hm, I can't find his website...
09:02:39 <edwinb> stefan_: I prefer my ASTs only to represent valid terms, but maybe that's because I'm a type theorist...
09:04:21 <stefan_> edwinb: I prefer the same, but well ... you know ... sometimes ... non-empty lists and stuff ... one is easily seduced
09:04:37 <edwinb> heh, indeed.
09:04:59 <edwinb> I don't know if there's a better way though - I know very little about QuickCheck
09:05:00 * edwinb reads up
09:05:10 <edwinb> I ought to use it more I think.
09:05:16 <shapr> QC roxx
09:05:25 <shapr> I even hacked it to save failing cases for later retests
09:05:54 <shapr> SyntaxNinja: it looks like his website may have disappeared, I'll send you the demo when I find it.
09:06:19 <shapr> SyntaxNinja: ah, I found his thesis, do you already have a copy of that?
09:07:15 <shapr> SyntaxNinja: well, bug me when you get back from lunch
09:07:52 * stefan_ wonders what command shapr gave to lambdabot making it take down an entire website
09:08:05 <shapr> ??
09:08:10 <shapr> :-)
09:08:38 <stefan_> shapr: i'm sorry, it has been a long day
09:10:57 <shapr> SyntaxNinja: also, I can forward you the email I swapped with Steve if you want. In summary, his thesis is that there are two types of webpages, regularly structured interfaces to databases, and everything else. I'd paraphrase the whole thesis as, 'given a HaskellDB DBInfo record, I can automatically input,view,and edit pages for those records'
09:11:15 <shapr> er "automatically generate"
09:12:13 <shapr> I think he's right, but looking at it backwards. I think the correct approach is to be able to web-publish native values in a given language.
09:13:05 <shapr> ie. data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show, Eq, WebPublish)
09:20:51 <stefan_> is this related to the generic UI's in Clean?
10:27:40 <SyntaxNinja> shapr: I have the thesis.
10:28:01 <SyntaxNinja> nah, don't forward me his email, that's OK. I was just curious about this component that I'd never seen or heard of.
10:30:03 <Marvin--> I never thought I'd say this about anything xml-based to come out of w3c, but I actually like XPath
11:03:25 <shapr> SyntaxNinja: have you read the thesis or played with the demo? it's a great idea... but the current demo is mostly smoke and mirrors, it needs real code to be usable.
11:07:24 <Marvin--> what thesis?
11:08:00 <shapr> Steve Vay Hoyweghen's thesis 
11:08:13 <Marvin--> on?
11:08:17 <shapr> 'generating *ML for data-centric webapps' or something like that
11:09:04 * esap supposes the '*' in *ML doesn't match SML? :-)
11:09:09 <shapr> SyntaxNinja: where'd you run across it?
11:09:16 <shapr> esap: nah, it was HTML or XML or something like that
11:09:54 <shapr> I have the thesis handy, and I know the demo is somewhere on my drive...
11:10:01 <shapr> if you want to see them
11:11:05 <Marvin--> I've had enough xml for today, and will have another bout with it tomorrow :P
11:11:52 * goron thought Gnumeric sucked, but a closer look seems to show that it could indeed be *used*. I wonder how hard the corba interface is and whether it works, but I have confidence.   
11:18:49 <Marvin--> meh, stupid raining
11:18:56 <Marvin--> still, I need to buy food, so off I go, I guess
11:22:22 <Riastradh> Does rain vary in intelligence or something?
11:27:54 <Maddas> No, it's always stupid.
11:28:18 <Riastradh> Why did he make it explicit, then?
11:28:46 <thebug> emphasis :)
11:29:41 <Maddas> Maybe he just wanted to note that it's raining...
11:30:01 <Maddas> (Not as if that answered the question)
11:37:59 <goron> shapr: AFK?
11:42:32 <shapr> ?
11:43:54 <goron> shapr: If you define tests, before you program, do you write them using abstract constructors like mkStack etc. or do you use the direct types (like Stack) ?
11:44:27 <shapr> well, it depends
11:44:46 <shapr> more often, I use abstract constructors, so I can change my data structures without changing my code
11:44:52 <shapr> er "without changing my tests"
11:50:26 <goron> shapr: And where do you put your tests? All in one module called Tests, or rather local with your functions. 
11:51:09 <shapr> I usually keep my tests in a separate module, but some people prefer to keep their tests in the same module so you can test non-exported code.
11:53:09 <shapr> I feel that tests should be clients of the external API. I think that results in better APIs.
12:19:45 <esap> Hmm.. Is it true that category theory objects are special cases of functors (i.e. objects in C are functors in [1,C]). Are there some conditions that need to be true for this to hold?
12:20:50 <Lor> [1,C] means { 1 } \cup C ?
12:21:07 <esap> no, the category of functors and natural transformations.
12:21:24 <Lor> Ah, right.
12:21:47 <esap> I mean, an object in C is like an object in [1,C] which is a functor.
12:22:36 <esap> Or maybe I'm missing some structure somewhere?
12:37:14 <Marvin--> man, it's really pouring down
12:46:59 <SyntaxNinja> shapr: investigating for Mark, not sure where he ran across it.
13:29:30 <Marvin--> SyntaxNinja: have you looked at the mail from Igloo?
13:38:12 <SyntaxNinja> Marvin--: I saw it; haven't taken a look at the bug report, I dno't even know offhand what package it's for.
13:38:49 <Marvin--> ghc5 :)
13:39:42 <Marvin--> meh, am I the only one who can't checkout things from sourceforge cvs repos?
13:39:52 <SyntaxNinja> so I guess allw e have to do is apply his patch, test it, and upload it?
13:40:20 <SyntaxNinja> i'm nervous about doing a NMU (even if an invited one) so close to release on a non-rc bug for a package I don't use :(
13:42:30 <Marvin--> well, FTBFS is RC, isn't it?
13:46:26 <Marvin--> I'm trying to build it right now, with his patch
13:50:28 <SyntaxNinja> OK coo
13:50:35 <SyntaxNinja> like I said, haven't had a chance to look @ the bug.
14:01:58 <musasabi> I am having doubts over the right way to define context sensitive parsers.
14:02:08 <musasabi> currently I have a type like:
14:02:12 <musasabi> data Parser = P { fun :: State -> Char -> Parser, state :: State }
14:03:39 <musasabi> and just fold over the input with a function calling the current function for the input resulting in a new parser like "foldl (\(P f s) c -> f s c) init string"
14:03:49 <musasabi> Is this a good way to handle things?
14:04:56 <Lor> All the information about the parsed string is stored in the state?
14:06:50 <Lor> Hm, in (P f s), isn't f _always_ applied to s?
14:07:21 <Lor> So you could just do it earlier and just have data Parser = P (Char -> Parser) ?
14:07:29 <Lor> (except of course that you need to extract the final state)
14:08:53 <musasabi> yes, f is allways applied to s, but both s and f will change over the iterations of the list.
14:09:29 <Lor> Yes, but if you have a function that produces (P f s), you could as well have it produce (P (f s))
14:09:57 <musasabi> true.
14:10:29 <musasabi> only termination seems problematic as you said.
14:10:43 <Lor> You seem to want some kind of an explicit low-level stack automaton where you can do individual transitions.
14:10:51 <Lor> Is this for debugging purposes, or why?
14:13:29 <Lor> Btw, do you intend to do backtracking, or will you keep things strictly LL(1)?
14:15:18 <musasabi> LL(1) is fine.
14:15:49 <Lor> Well, if your grammar were LL(1), you wouldn't need any fancy context-sensitive stuff...
14:16:15 <musasabi> Lor: context-sensitiveness makes things simpler.
14:16:41 <Marvin--> I wonder if I should create a sarge chroot and see if the bug happens there
14:17:33 <Lor> for a simple language recognizer (ie. one that doesn't return anything), data Parser = Consume (Char -> Parser) | Fail | Succ should do.
14:18:14 <musasabi> Lor: and neither happy nor parsec looked very promising to me. Then again I am using a custom packed string representation.
14:18:28 <Lor> promising in what sense?
14:18:59 <Lor> You want to parse packed strings without unpacking them?
14:20:19 <musasabi> yes. Mainly I want to make quite simple transformations I would do with regexs in perl with a simple grammar.
14:20:47 <Lor> Your language is regular? Then why not just use regexps?
14:21:00 <Lor> Or Chakravarty's fancy lexer combinators, for that matter...
14:21:33 <musasabi> Lor: haskell regexes don't like '\0' which may be present. (evil users)
14:22:04 <Lor> Ah, that's the problem with using C-based libraries. :)
14:22:52 <Lor> Then again, regexps aren't very often used with binary data.
14:23:31 <musasabi> Chaktrvarty's lexers are those on http://www.cse.unsw.edu.au/~chak/haskell/ctk/ ?
14:24:22 <Lor> Yeah. http://www.cse.unsw.edu.au/~chak/papers/Cha99.html
14:25:04 <musasabi> I'll read that. Thanks for the tips.
14:29:56 <Lor> Do read swierstra's notes on parser combinators, if you intend to roll up your own.
14:30:32 <Lor> http://www.cs.uu.nl/~doaitse/Books/GramPars2001.pdf
14:47:25 * Marvin-- tortures his computer by building two ghc5:s in parallel
14:53:10 <Lor> ghc5? Why?
14:55:12 <Marvin--> because I was dumb enough to promise Igloo to look after his packages ;)
14:57:31 <Marvin--> *argh* painful when the build failure you're trying to reproduce isn't until stage2
14:58:28 <Lor> Ah, ghc5 still needs maintenance? Some binary compatibility issues?
14:59:32 <Marvin--> well, we still have ghc5 packages in debian and for some reason there was an ftbfs
15:00:13 <Lor> ftbfs?
15:02:17 <Marvin--> but I think it only happens on a very recent sid, so I'm building it in a sarge chroot to make sure
15:02:20 <Marvin--> fails to build from source
15:05:54 <stepcut> my other computer is a chroot
15:13:19 <LrdMtrod> what's the difference between a bottom up and top down style? I can't keep their definition seperate!
15:15:21 <Lor> LrdMtrod, in which context? Software design? Parsers?
15:16:19 <LrdMtrod> yes... software design, or just general way of thinking!
15:16:46 <Lor> Top-down means you think of the big picture first, then the small bits. Bottom-up is the other way round.
15:18:03 <LrdMtrod> I see... hehe, I'm a Top-Down and that's why I have so hard with haskell!
15:18:39 <Lor> Why do you think haskell doesn't allow top-down design?
15:19:33 <Lor> In general, I think things ought to be designed top-down, but implemented bottom-up.
15:19:57 <Lor> Some people like to implement top-down too, but that's a bit tricky.
15:19:58 * Riastradh concurs.
15:25:18 <LrdMtrod> yeah, but I have problem figureing out what smaller parts needs to be created in order to get the big whole done!
15:25:54 <LrdMtrod> and I don't know much standard functions in haskell yet which makes it even more difficult as I don't know my options of doing things
15:26:05 <Lor> LrdMtrod, that's why you need to design before you implement. :)
15:26:15 <LrdMtrod> I also have a difficulty creating profs which means haskell can become quite a pain...
15:26:30 <Lor> In Haskell, it is very easy to implement top-down, too.
15:27:06 <LrdMtrod> I have been trying to write specification documentation... however I can't get my pseudo code understandable, even by myself...
15:27:18 <Lor> You just write the top-level function, and give stub definitions (foo :: FoosType; foo = undefined) to all the as-yet-unimplemented auxiliary functions.
15:27:42 <LrdMtrod> this is for C btw, so a friend suggested using haskell for it, as I have been intersetd in haskell for some time but never gotten around to learn it... We do 2 things in one go...
15:28:17 <LrdMtrod> learn haskell and make the haskell code my pseudo code... meaning I don't have a design document for my code as it is my document!
15:28:41 <Lor> That is even feasible in haskell.
15:28:48 <Lor> Very much unlike C. :)
15:29:42 <Lor> However, your Haskell-based design may not serve as a good starting point for implementing it again in C.
15:30:12 <Lor> Since many of the programming techniques you'd use in Haskell are not available in C.
15:35:57 <arauko> hello
15:36:21 <arauko> reading about haskell, one thin give noticed is the function definition 
15:36:53 <arauko> a function is an unit which returns always the same value correct?
15:37:22 <arauko> leading to referencial transparency?
15:37:28 <Lor> Yes, a Haskell function always returns the same result for any particular argument.
15:38:05 <arauko> Lor, ok, my question is.. is it the general definition of a function, or is it only for haskell?
15:38:43 <Lor> "function" is a word, and like most words, it has a number of different meanings in different contexts.
15:39:01 <Lor> A mathematical function always returns the same value for the same argument.
15:39:12 <arauko> but here in programming langauges... 
15:39:13 <Lor> But a mathematical function may be uncomputable, unlike a Haskell function.
15:39:16 <arauko> yeah 
15:39:39 <arauko> i was thinking about Alonzo Church's lambda calculus 
15:39:46 <Lor> In most other programming languages, "functions" or whatever they are called ("methods", "procedures") can have side effects.
15:40:01 <arauko> i know (imperative languages after all)
15:40:03 <jesse98> functions in pure functional languages behave like mathematical functions
15:40:15 <arauko> jesse98, Good, 
15:40:22 <jesse98> (and haskell functions are not all computable)
15:40:26 <arauko> ive noticed that ....
15:40:36 <Lor> They are computable partial functions.
15:40:44 <jesse98> right
15:41:35 <arauko> correct, i think then if we talk about functions in an imperative language, it has a quite different meaning 
15:42:50 <Lor> "procedure" might be a more precise term, if you want to avoid confusion.
15:42:57 <arauko> indeed
15:43:20 <arauko> ive always used procedure... i like more.. but you usually hear "functions" time to time 
15:43:21 <Lor> Then again, some languages have "procedures" which may have side effects but don't return a value, and "functions" which do return a value, but may also have side effects...
15:43:39 <arauko> i know
15:44:04 <Lor> So there's no one unambiguous terminology that would be crystal-clear to everyone.
15:44:13 <arauko> indeed....
15:44:43 <arauko> but if we talk about p?rely functional language, ,then the mathematical definition fit well 
15:45:01 <Lor> Well, depends on which mathematical definition you take.
15:45:16 <arauko> the lambda calculus 
15:46:02 <Lor> That's hardly "the mathematical definition" of a function. The most common one defines a function to be a special kind of relation.
15:46:26 <Lor> And again the lambda calculus only defines partial computable functions.
15:48:14 <arauko> yes, i take that formalism
15:48:57 <arauko> i think that for programming languages fit pretty well
16:47:12 <arauko> mmm...
16:47:21 <arauko> monads are sort of interesting
16:47:33 <arauko> mondas are actions?
16:47:36 <arauko> monads
16:48:18 <Riastradh> It is difficult to say what a 'monad' in specific is.
16:48:48 <Riastradh> Monads provide a generalized interface to sequential computations, or actions, I suppose.
16:48:57 <arauko> im reading about _do_ .. i see _do_ is used for sequence 
16:49:15 <arauko> is it related to monads?
16:49:30 <Riastradh> do is used to linearize a sequence of monadic actions that would, when expanded, be nested.
16:49:39 <Riastradh> It is.
16:49:46 <arauko> i see now
16:51:39 <arauko> Riastradh, in tthat case, _do_ is a monad?
16:52:26 <Riastradh> I'd not say that 'do' itself is a monad.   Rather, I'd say that 'do' is a convenient form of structuring monadic computations.
16:52:39 <arauko> yes
16:53:05 <arauko> but i dont gete xactly this monadic computation is all about
16:53:21 <arauko> monadic computation == sequential computation ??
16:53:32 <pesco> Do notation is syntactic sugar for monad sequencing.
16:54:34 <pesco> do x <- a; y <- b; z <- c; d == a >>= \x -> b >>= \y -> c >>= \z -> d
16:57:26 <arauko> what i read here, iis that monads are functions, that might take an argument and returns an action that is then run by the compiler 
16:59:25 <pesco> That's wrong. I think the data type representing an action is called a monad if it supports the monad operations and satisifes the monad laws.
17:00:27 <arauko> so monads doesnt return an action?
17:01:14 <pesco> Is it the type that's called a monad, or the value? I'm not sure.
17:01:18 <Riastradh> arauko, the noun 'monad' alone in specific is generally confusing.
17:01:46 <monochrom> At the onset, I wouldn't say monads are functions.
17:02:07 <Riastradh> The term 'monadic computation' refers to a computation that is operated upon by the monadic operators.
17:02:28 <arauko> what is the special aboput them?
17:02:49 <Riastradh> Monads compute output.  Functions return output given input.
17:04:40 <monochrom> I too dislike the C convention of saying that getchar is a function.
17:04:59 <Riastradh> Rather, functions map inputs to outputs.
17:13:47 <arauko> but according to this, monads would be a way to run actions 
17:13:58 <arauko> and _do_ sequences those actions 
17:15:28 <Riastradh> Monads are a way to _represent_ actions.  do is a convenient way to notate a sequence of actions.
17:15:51 <monochrom> >>= is the operator that sequences actions.
17:20:33 <arauko> but the actions will be executed by the compiled code of the program correct?
17:20:59 <monochrom> I suppose I shouldn't be too pedantic about who does the sequencing, "do" or ">>="? ... they are translatable to each other anyway.
17:21:57 <monochrom> Are you speaking of the IO monad specifically?
17:22:04 <arauko> yes
17:22:42 <arauko> so, they behave differently?
17:23:05 <monochrom> An IO monad is executed iff: base case: it is the main program; induction step: it is called by an IO monad that is executed.
17:31:22 <arauko> 0_0
17:31:42 <arauko> so, an action is run by the compiled program correct?
17:32:25 <monochrom> Yes.
17:43:59 <roconnor> ?
17:46:27 <Riastradh> !
17:52:12 <roconnor> oh, nevermind.  I figured it out.
18:00:25 <shrimpx> the program gets compiled into an application of main to an internal 'world' object, which gets threaded through all IO monad activity in the whole program
22:53:56 <musasabi> morning
23:32:39 <shammah> evening.
23:43:12 <dons> thebug: hi
23:43:17 <dons> doing some mipsing now
23:43:31 <dons> you'll be please to know
23:43:37 <dons> pleased, even
23:54:17 <shrimpx> so how come (read "5") works at the ghci top level but (read "5.5") doesn't? is Int picked as default for read?
23:55:01 <Igloo> Integer is used if it fits the constraints
23:55:06 <Igloo> (by default)
23:55:20 <shrimpx> ok
23:55:23 <Igloo> Then Double if Integer doesn't fit
23:55:29 <shrimpx> oh
23:55:31 <Igloo> You can set it with the default keyword
23:56:03 <Igloo> But note that read "5.5" :: Integer is well typed
23:56:33 <shrimpx> makes sense
