06:01:07 <Marvin--> hey syntax
06:02:04 <Marvin--> did you suggest to Daan to change the soname?
06:04:06 <SyntaxNinja> Marvin--: no
06:04:21 <SyntaxNinja> well, I did some time back
06:04:32 <SyntaxNinja> but back then, he didn't believe me that the .so didn't have a soname :)
06:05:14 <Marvin--> heh
06:05:44 <Marvin--> maybe you should tell him how package upgrades work in Debian
06:06:01 <Marvin--> I mean, that if a binary package is no longer mentioned in a source package it is removed
06:06:28 <Marvin--> which makes the change-soname-every-release principle a PITA
06:06:52 <Marvin--> I really don't see why libwxc would need to change soname more often than libwxgtk
06:07:22 <SyntaxNinja> I don't understand what that has to do with a binary package being removed from a source package?
06:09:25 <Igloo> It's more a PITA because you have to wait a week or two for it to be accepted
06:10:06 <SyntaxNinja> because the ftpmasters are slower to accept packages that change the soname?
06:10:42 <Marvin--> it's a PITA because any package depending on the old package becomes uninstallable and has to be rebuilt with the new version
06:11:09 <SyntaxNinja> but the only package that's goign to depend on it will be wxhaskell
06:11:48 <Marvin--> uh, no
06:12:05 <Marvin--> any program that links it will depend on it
06:12:35 <SyntaxNinja> ahh so...
06:12:42 <Marvin--> If I write a haskell program foo that uses wxhaskell, foo will be dynamically linked to libwxc and the package foo is in needs to depend on the libwxc package
06:12:43 <Igloo> No, it's a week or two regardless
06:13:21 <Marvin--> of course, you could do what wxwindows does and put the version in the source package name (Source: wxwindows2.4) but that's hella-ugly and a dumb workaround
06:13:30 <Igloo> Oh, if you have libwxc rather than libwxc<soname> then you have the problem of everything needing to be updated simultaneously instead
06:13:59 <SyntaxNinja> OK so the idea is that we don't want the soname to track the wxhaskell version because it'll cause all packages that are built with wxhaskell to be uninstallable.  instead, what do we want the soname to be?
06:14:03 <Marvin--> well, with "the libwxc package" I meant, "whatever package contains this particular version of libwxc"
06:14:22 <Igloo> Hang on, does Linux have the mixed code problem?
06:14:31 <Igloo> Can we just use a non-shared library?
06:14:37 <Marvin--> "certain versions of gcc" is what he said
06:14:42 <Marvin--> I was thinking of that too
06:14:51 <Marvin--> make it static on Debian and don't give a damn
06:15:27 <SyntaxNinja> but with the diversity of Debian systems, we're begging to discover the platforms where it doesnt' work.
06:15:30 <Igloo> I might also be worth finding out if people more knowledgeable in such matters (doko or gcc maintainers maybe?) can give a better generic solution
06:15:50 <Marvin--> SyntaxNinja: btw, your .diff.gz is broken, it contains some huge auto-generated .hs files
06:16:38 <Marvin--> in any case, if we go with a shared lib, the package name should be based on the name of the shared lib, not libghc6-somethingsomething
06:17:31 <Marvin--> if the shared lib is libwxc-gtk2.4-0.8.so, it should be in the package libwxc-gtk2.4-0.8
06:18:05 <SyntaxNinja> ok
06:18:07 <Marvin--> though libwxc-gtk2.4.so.0 in a libwxc-gtk2.4-0 package is obviously preferrable
06:18:52 <Marvin--> but yes, ask on -devel or the gcc list if there are any good ideas
06:18:54 <SyntaxNinja> you mean pulling it out into its own package
06:19:38 <Marvin--> SyntaxNinja: it already *is* in its own package, you just call it libghc6-wxhaskell0.8
06:21:22 <Marvin--> btw, I noticed that you called it libwxc-gtk2.4.2, may I suggest libwxc_gtk-2.4 instead? (cf. libwx_gtk-2.4)
06:21:40 <Marvin--> meh
06:22:34 <Marvin--> this isn't the default, is it? the default is libwxc-0.8.so?
06:22:55 <Marvin--> If we rename the lib, we're breaking cross-distro compatability
06:24:20 <SyntaxNinja> I dont' recall changing the default
06:24:33 <Marvin--> oh, so that's a change from 0.6 to 0.8?
06:25:00 <Marvin--> fair enough, then I'll suggest it to Daan instead
06:25:23 <Marvin--> I think libwxc-gtk2.4.2 is misleading, it's not *gtk* 2.4 we're talking about, it's *wxgtk* 2.4
06:25:27 <Marvin--> wxgtk still uses gtk 1.2
06:25:40 <SyntaxNinja> right
06:25:56 <Marvin--> but if the 2.4 comes from Daan, then there's even less reason to put the 0.8 in the soname too
06:26:57 <Marvin--> I guess the wxgtk people put their major.minor in their soname because they expect lots and lots of changes between releases, but note that they still use a .0 suffix too
06:27:10 * Igloo suggests forwarding the mail he talks about runtime engines in to debian-gcc@lists.debian.org and seeing what they say before working out what should be called what
06:27:28 <Marvin--> agreed
06:28:52 <Marvin--> if there's no issue with the static linking in Debian, we shouldn't worry
06:29:28 <Marvin--> man, I bet haskell programs using wxhaskell are huge
06:30:14 <Marvin--> mh, maybe not much huger than other
06:44:53 <shapr> hej hram 
06:45:37 * shapr bOings
06:45:40 <shapr> wassup guys?
06:46:02 * shapr listens to the quiet sound of the wind blowing...
06:48:27 <Marvin--> we're trying to DTRT with packaging wxhaskell
06:48:46 <shapr> oh
06:48:51 <shapr> is it working?
06:52:40 * shapr reads up on hs-plugins
06:53:48 <Marvin--> don't know yet :)
06:55:29 <shapr> so, I wonder if I can stick together hws-wp, hs-plugins, and haskelldb to make a weenie zope-like thingy.
06:56:39 <shapr> I realized I want to track a bunch of different student stats with my language teaching webapp, and it's getting painfully slow to load up GF and the grammar for each new CGI question 
07:03:29 <shapr> whoa spiffy, I'm in the hs-plugins acknowledgements!
07:03:47 * shapr bounces happily
07:04:35 <shapr> hram is in there too
07:14:11 <shapr> hm, hs-plugins deals with several of the problems that lambdabot is having with dynloading.
07:15:59 <Lor> When is dons usually awake?
07:19:40 <shapr> after midnight GMT
07:19:47 <shapr> since he's on aussie time.
07:19:57 <shapr> did you see the part about extra typechecks for dynloading?
07:20:10 <Marvin--> meh, I wish strakt would take more of an interest in the pyopenssl development
07:20:26 <shapr> this part --> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-1.html#node_toc_node_sec_3.3
07:21:53 <Lor> I don't buy it.
07:22:41 <shapr> are they switching you to other projects?
07:29:34 <shapr> how so?
07:30:23 <Lor> Was that directed to me?
07:30:34 <shapr> yes!
07:32:06 <Lor> Ah, well. I write in my thesis: "there is no guarantee that the type information that is used by the compiler is compatible with the types in the running program. If, for example, a program that uses dynamic loading is built, and afterwards the libraries in the system are
07:32:06 <Lor> upgraded in a way that breaks backwards compatibility, then the object files created by \K{eval} may be unsafe to use."
07:35:01 <Igloo> If anyone has any problems with ghc6 6.2.1-5 currently in incoming.debian.org can you please shout ASAP?
07:35:23 <shapr> ok, I'll try it when I can upgrade.
07:35:51 <shapr> Lor: if you use makeWith, you effectively get to carry the typechecker around with you.
07:36:17 <shapr> of course, it requires access to the source...
07:36:18 * Igloo will mail the list when it's in the archive, although I'm not sure I'll be able to fix it myself much after that
07:51:24 <shapr> Igloo: does the latest ghc-cvs have C-- ?
07:52:00 <Lunar^> Hey, that was gintasfrom EuroHaskell!
07:52:18 <shapr> yes!
07:52:45 <shapr> I thought he was actually gintas from #haskell when we met him at EuroPython...
07:52:48 <shapr> hiya gintas!
07:54:48 <Igloo> No
07:54:54 <shapr> ok
07:57:32 <shapr> hej spenatmannen 
07:57:48 <spenatmannen> hej shapr
07:57:54 <shapr> wassup?
07:58:10 <spenatmannen> nothin' much... omtentor o jobb...
07:58:58 <shapr> ingen Haskell-skriving? how do I really say that anyway? :-)
07:59:10 <shapr> skrivning?
07:59:17 <spenatmannen> no... no haskell-writing =)
07:59:38 <shapr> ah, tyv‰rr
07:59:48 <spenatmannen> d k‰nns lite tomt =)
08:00:07 * shapr kan inte l√§ser latin-1
08:00:38 <shapr> actually, I can't read so much swedish either, but I'm especially lost with latin-1 
08:00:43 <shapr> anyway...
08:10:28 <gintas> shapr: hi
08:10:35 <shapr> how's code?
08:10:57 <gintas> ok
08:11:47 <gintas> hi Lunar^ 
08:25:02 <Marvin--> Igloo: grmbl, yeah, I have an issue, but it's not your fault
08:25:28 <Marvin--> shapr: Syntax error: end of file unexpected (expecting "then")
08:25:29 <Marvin--> Trigger failed: ("if [ $(\"%p\" --numeric-version) = 6.2.1 ] then $(\"%p\" --print-libdir)/bin/ghc-pkg -r wx","/usr/bin/ghc6")
08:25:39 <Marvin--> s/shapr/sh/, stupid autocompletion
08:25:39 <shapr> eh?
08:25:42 <shapr> whew
08:25:45 <Marvin--> :)
08:26:04 <Smerdyakov> Shell scripts for building stuff are such a KLUDGE.
08:26:06 <shapr> I'm hacking around on hws-wp so I immediately thought it had to do with that...
08:26:23 <shapr> Smerdyakov: feel free to work on Cabal, it's the expected replacement
08:26:32 <Marvin--> SyntaxNinja: chalk up one more bug in the wxhaskell packages
08:31:13 * shapr throws lambdas
08:38:36 <Marvin--> Igloo: other than that, seems to work fine
10:01:16 <SyntaxNinja> Marvin--: what's the bug? wanna email me?
10:05:11 <LittleDa1> I've heard people make claims that Haskell's monadic equivalents of side effects are safer and better-organized than side effects in impure languages. Why is that?
10:08:38 <LittleDa1> ok, I guess no one is going to answer me...
10:08:50 <Philippa_> LittleDa1: they're visible to the type system
10:08:58 <LittleDa1> why does that matter?
10:09:12 <Philippa_> similarly, you work within a specific monad, you don't necessarily have access to all the possible kinds of side-effect
10:09:25 <LittleDa1> isn't that a disadvantage?
10:09:31 <Philippa_> because you can look at a function's type and know it won't screw you over in this way, that way, the other way...
10:09:32 <Philippa_> nope
10:09:54 <Philippa_> see the word "necessarily" - you can build most things with a bunch of monad transformers
10:10:16 <LittleDa1> but when you use monad transformers, everything becomes so much more verbose and complicated
10:10:41 <LittleDa1> how are side effects "screwing you over"?
10:10:56 <Philippa_> so you stick them in an ADT and wrap the monad operations so you don't need lift. End of problem
10:11:10 <Philippa_> ever watched a C program accidentally crap on its stack?
10:12:55 <LittleDa1> what's ADT?
10:13:00 <Philippa_> Abstract Data Type
10:13:06 <LittleDa1> oh, yeah
10:13:28 <LittleDa1> isn't crapping on its stack more a symptom of lack of automatic garbage collection?
10:14:07 <LittleDa1> s/garbage collection/memory management/
10:14:20 <Marvin--> SyntaxNinja: it's in the postinst, did you miss the "syntax error"/"trigger failed" thing that I pasted before?
10:15:03 <Philippa_> LittleDa1: no, it'd be a symptom of having pointers and pointer arithmetic
10:15:16 <Philippa_> you're thinking about things like deallocating memory too early
10:15:34 <LittleDa1> Philippa: well, you don't have pointer arithmetic if you have automatic memory management...
10:15:54 <Philippa_> not true. You can have Hans-Boehm under C++, for example
10:16:15 <LittleDa1> Philippa: What about in a language like OCaml? That stuff doesn't happen there, even though it has side effects
10:16:15 <Philippa_> but even if you don't crap on the stack (a fairly drastic example of altering a program's state) you can alter bits of state that the caller's not expecting to be altered
10:17:04 <LittleDa1> but what if you skip doing that and instead use side effects for fewer things, such as IO or holding random number seeds
10:18:05 <Philippa_> It's always possible to perform good engineering with bad tools
10:18:30 <LittleDa1> but I still don't understand why the possibility of doing bad things makes the tools bad
10:18:52 <Philippa_> because there are other tools where it's harder to do bad things and easier to spot when you're doing them
10:18:56 <LittleDa1> you can do bad things in haskell too
10:19:05 <Philippa_> sure, you have to work harder at it though
10:19:18 <Philippa_> and you get a lot more flagging as to when you're doing something potentially bad
10:20:20 <LittleDa1> it's pretty easy to naively do a bunch of list things in O(n) that would be done with arrays in O(1). Does that make lists a bad tool?
10:20:40 <edwinb> Being able to do bad things doesn't make a tool bad.
10:21:07 <edwinb> It's quite easy to write inefficient programs in any language.
10:21:22 <LittleDa1> so what makes the tool bad in the first place?
10:21:33 <edwinb> Nobody ever said any tools were bad did they?
10:21:43 <LittleDa1> Philippa did
10:21:58 <LittleDa1> he said side effects were a bad tool
10:22:00 <edwinb> No she didn't, she said Haskell and the like were better.
10:22:12 <LittleDa1> (sorry for messing up the gender)
10:22:40 <Philippa_> I offered an aphorism about bad tools - you can write correct code in assembler, but assembler's not generally a good tool for doing so
10:23:02 <LittleDa1> so are there any advantages besides stronger typing?
10:23:12 <edwinb> To what, Haskell specifically?
10:23:39 <LittleDa1> for monads as opposed to side effects; monads have stronger typing, generally
10:24:11 <Philippa_> monads also offer a nice way to structure some more interesting side-effects and other types of computation
10:24:46 <LittleDa1> you mean like with the list monad?
10:24:50 <Philippa_> yeah
10:25:01 <Philippa_> a monad is like a little language - you can customise it to your needs, it might have unification and backtracking for example (prolog!)
10:25:41 <Philippa_> so it's easier to write your side-effecting code in the terms you're actually thinking in
10:25:58 <Philippa_> monads supporting unification're fairly common in type checkers, for example
10:26:09 <LittleDa1> what's unification?
10:27:16 <Philippa_> taking two values and making them "the same"
10:27:44 <LittleDa1> I get that from the name, but could you be more specific?
10:28:02 <LittleDa1> I assume you don't mean same identity...
10:28:23 <LittleDa1> but that's what it sounds like
10:29:25 <Philippa_> well, unifying a variable with a value would make that variable equal to the value for example
10:30:28 <LittleDa1> isn't it already?
10:30:41 <Philippa_> not necessarily
10:30:48 <Philippa_> think solving equations
10:31:08 <LittleDa1> so you mean finite domain type stuff?
10:31:56 <Philippa_> dunno what you mean, possibly
10:33:07 <LittleDa1> what are the advantages of monads over cps and/or call/cc? They could do most of these things, couldn't they?
10:33:38 <Philippa_> in fact you can implement monads that way
10:34:27 <LittleDa1> but monads can't implement full continuations, as far as I know. the continuation monad is exit-only
10:34:42 <LittleDa1> and only one chance to exit per action
10:35:51 <shapr> @yow unicycling!
10:35:51 <lambdabot> Is this "BIKINI BEACH"?
10:36:11 <Philippa_> the "action" thing is a bit misleading in a way. Yeah, it'd be nice to split up functions into monadic versions where every bit of evaluation is an "action" sometimes...
10:36:34 <LittleDa1> is lambdabot the same as #scheme's sarahbot?
10:37:00 <LittleDa1> @yow
10:37:01 <lambdabot> Let's go to CHURCH!
10:37:45 <shapr> nah, lambdabot and sarahbot are going out, but have not yet become an item.
10:37:53 * shapr snickers
10:38:13 <LittleDa1> can you talk to lambdabot?
10:38:22 <shapr> er, I can, yes.
10:38:29 <shapr> what do you mean?
10:38:40 <LittleDa1> like if you want to talk to sarahbot, you do Sarahbot: hi, how are you?
10:38:48 <shapr> lambdabot: @yow
10:38:48 <lambdabot> Yow!
10:38:59 <shapr> like that?
10:39:03 <LittleDa1> yeah
10:39:10 <LittleDa1> lambdabot: what language are you programmed in?
10:39:11 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
10:39:17 <shapr> lambdabot is written in Haskell.
10:39:18 <LittleDa1> oops, I guess not
10:39:21 <LittleDa1> ok, thanks
10:39:31 <LittleDa1> lambdabot: @listcommands
10:39:31 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
10:39:31 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
10:39:31 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
10:39:31 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
10:39:31 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
10:39:32 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
10:39:34 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
10:39:36 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
10:39:38 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
10:39:39 <shapr> I think I'm the maintainer of lambdabot at the moment.
10:39:48 <shapr> @listmodules
10:39:48 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
10:39:48 <lambdabot> ,"dynamic","eval","hello","karma","more","quote","seen","state","system
10:39:48 <lambdabot> ,"topic","type"]
10:39:55 <shapr> @listcommands dict
10:39:55 <lambdabot> Module dict provides the following commands: ["dict","dict-help","all-dicts
10:39:55 <lambdabot> ,"devils","easton","elements","foldoc","gazetteer","hitchcock","jargon"
10:39:55 <lambdabot> "lojban","prelude","vera","web1913","wn","world02"]
10:40:20 <shapr> speaking of which, stepcut requested an updated lambdabot repo, I need to work on that soon.
10:40:58 <shapr> LittleDa1: the whole point of lambdabot is to be a code-toy, lambdabot has two different plugin APIs so that people can get started writing fun and useful Haskell code immediately.
10:41:22 <LittleDa1> oh, it's completely different from sarahbot, then. where's lambdabot's sourcecode?
10:41:23 <shapr> I think it's nice to see your name in the AUTHORS file next to a nifty lambdabot plugin :-)
10:41:47 <stepcut> shapr: the @arr module was getting a !! out of bounds error ;)
10:42:04 <shapr> try this: http://217.211.205.143/~shae/lbot2.1.tgz
10:42:11 <shapr> yah, I wrote thah bug myself :-)
10:42:24 <shapr> I should have used randomR instead of my own custom (broken) function
10:42:39 <shapr> LittleDa1: what's the point of sarahbot?
10:42:51 <stepcut> the code I have uses randomR, but it just yes a bound that is 1 too big...
10:43:07 <shapr> it still gives the error with randomR?
10:43:10 * shapr blinks
10:43:18 <shapr> oh, an off-by-one error?
10:43:58 <LittleDa1> sharpr: it has a bunch of useful functions, like yow the ability to talk to you. You can use it to send messages to people and it remembers things that you tell it, such as URLs.
10:44:25 <stepcut> in QuoteModule/Yow.hs, I had to change: 'llen = (length mylist)' to 'llen = (length mylist) - 1'
10:44:37 <shapr> lambdabot has a plugin that remembers factoids, it was the first working plugin after the @hello plugin
10:45:07 <stepcut> Are factoids things like @shapr ?
10:45:21 <shapr> nah, I was thinking about the @fact plugin
10:45:30 <stepcut> ah, I have not played with that yet
10:45:31 <shapr> which hasn't been working in a long time because I haven't gotten around to porting it to HaskellDB
10:45:43 <stepcut> :p
10:46:04 <shapr> anyway, I wrote code at one point that used randomR, but I then overwrote it with some old code, could I get a copy of your Yow.hs ?
10:46:40 <stepcut> I was thinkng of adding some haskelldb support for the quotemodule, but I wanted to wait for haskelldb to be cabalized, etc first
10:47:03 <stepcut> how would you like Yow.hs delivered ?
10:47:12 <shapr> email I guess
10:47:52 <shapr> ohh, I do have a copy that uses randomR
10:47:52 <shapr> huh
10:47:55 <shapr> spiffy
10:48:19 <shapr> and it has that bug too
10:48:28 <stepcut> too late I already sent it!
10:48:35 <shapr> that's okay :-)
10:48:47 <stepcut> yeah, my lambdabot is from some hlibs darcs repo from last week
10:48:53 <shapr> ah ok then
10:49:21 <stepcut> oh oh! Now I have to confirm my message :P
10:49:28 <shapr> whoops
10:49:34 <stepcut> ;)
10:49:35 <shapr> I should add linspire to the whitelist
10:50:03 <stepcut> linspireinc.com
10:50:14 <shapr> ok
10:50:23 <stepcut> you probably don't want to add linspire.com
10:51:35 <shapr> alrighty, you are whitelisted.
10:51:39 <stepcut> :p
10:51:46 <stepcut> @state I am whitelisted
10:51:50 <shapr> heh
10:51:54 <shapr> @state Nebraska!
10:51:55 <lambdabot> I am whitelisted
10:52:21 <lambdabot> Ow!  Quit hitting me with new states and making me regurgitate the old ones
10:52:37 <shapr> bah, wimpy bot!
10:52:40 <stepcut> have you looked at hatchet at all ?
10:52:45 <shapr> err, no?
10:52:53 <shapr> it's a type-checking thingy, isn't it?
10:52:56 <stepcut> yes
10:52:57 <shapr> modular type-checking maybe?
10:53:17 <shapr> is that also from Martin Sulzmann? or am I thinking of Chameleon?
10:53:19 * shapr googles
10:53:31 <stepcut> yeah, hatchet is the haskell typechecker
10:53:35 <shapr> oh, from bernie
10:53:43 <stepcut> based on typing haskell in haskell, but more pragmatic
10:53:56 <shapr> I bet he's using it for buddha
10:54:19 <shapr> heh "Hatchet is supposed to be as simple as possible, particularly so that it can be understood and used by mortals."
10:54:27 <stepcut> yeah
10:54:46 <stepcut> but I am thinking with a bit of hacking (hahaha) it can be made into a lambdabot module
10:54:47 <shapr> I'm beginning to realize that library code comes in two flavors, a) fast, modular, and totally opaque b) code that I would have written myself
10:54:53 <shapr> ha!
10:54:59 <shapr> very punny
10:55:35 <shapr> oh, I've also discovered that my idea of the B kind of code is slowly overtaking the A kind of code.
10:56:04 <stepcut> the main problem is hatchet really wants to take a valid .hs as input, whereas with lambdabot, you would want to feed it littte fragments
10:56:13 <shapr> yup
10:56:23 <shapr> I've been thinking of a random sentence generator plugin that uses GF
10:56:31 <shapr> should work in several languages too :-)
10:56:31 <stepcut> heh
10:56:49 <stepcut> a bit like yow ?
10:56:51 <stepcut> @yow
10:56:52 <lambdabot> There's a lot of BIG MONEY in MISERY if you have an AGENT!!
10:56:55 <shapr> yup, a lot like yow
10:57:11 <shapr> andersca wanted a pizza timer plugin, but no one has thought of a good way to write timers in lambdabot 
10:57:23 <shapr> the only solutions I can think of require either threading or arrows
10:57:46 <shapr> and the arrows solution is sort of threading anyway
10:57:54 <stepcut> interesting
10:57:58 <shapr> could be fun though, porting lambdabot to Yampa
10:58:04 * shapr thinks about that
10:58:26 <shapr> hm, might be worth trying
10:58:40 <stepcut> I have not looked at the code any more than was needed to (1) log into a password protected irc server (2) make a clone of @arr with jokes my boss tells
10:58:48 <shapr> hahaa
10:59:04 <shapr> lambdabot can login to a passworded irc server?
10:59:05 <shapr> neat
10:59:29 <stepcut> well, my lambdabot can, but its not a portable hack
10:59:29 <shapr> hey, that could be *very* neat if you mix it with bitlbee
11:00:13 <shapr> think you could hack it into a BotConfig.hs setting?
11:00:16 <stepcut> actually, I take it back. It is a portable hack
11:00:21 <shapr> something like password :: Maybe String ?
11:00:31 <shapr> nifty
11:00:38 <stepcut> yeah, thats what I did, added a maybe password
11:00:48 <shapr> excellent, great minds and all that :-)
11:00:51 <stepcut> then in the ircSignOn, I added:
11:00:52 <stepcut> 	case pass of
11:00:52 <stepcut> 	     Nothing -> return ()
11:00:52 <stepcut> 	     Just passwd -> ircWrite (mkIrcMessage "PASS" [passwd])
11:01:03 <stepcut> before it sends the USER message
11:01:06 <shapr> cool, sounds perfect
11:02:19 <shapr> btw, any ideas for solutions for the CGI arrow problem?
11:02:29 <stepcut> no
11:02:33 <shapr> it seems to stand in the way of many things I'd like to do.
11:02:39 <stepcut> yes
11:02:54 <shapr> just now, hws-wp using arrows would run across the same problem
11:03:10 <shapr> maybe we should bug SPJ about it.
11:03:22 <shapr> I can anyway
11:04:03 <shapr> hmm, I wonder if epigram could be a lambdabot plugin.
11:04:28 <shapr> how would you show 2 dimensional data on irc?
11:04:49 <stepcut> brb
11:04:53 <shapr> or how would you interact with it, I wonder
11:05:16 <shapr> edwinb: what do you think? could epigram work across irc somehow?
11:05:55 <shapr> maybe a web interface would be better. would let you put type tooltips up at least
11:06:32 <shapr> in some way, epigram is a somewhat graphical abstract syntax tree, or maybe a type tree?
11:06:39 * shapr burbles pleasantly
11:06:57 * Riastradh whiffles at shapr.
11:07:05 * shapr galumphs about
11:07:15 <shapr> Riastradh: ever tried unicycling?
11:07:33 <Riastradh> No.  That's why I always make silly snide comments about it when the topic is brought up.
11:07:39 <shapr> oh, ok.
11:07:52 <shapr> it's a pleasant experience.
11:08:19 <Riastradh> If I actually knew much about it, I'd probably have less silliness to say about it.
11:09:22 <stepcut> shapr: I would have to look at the arrow CGI thing again to see a solution. Basically, I think you want the ability to make instances of the arrow modules that have class constraints. So you can say, I want arrows with the constraint (Show b, Read c) or something like that
11:09:25 <shapr> it's not a very complicated subject, but it does require some time to learn.
11:10:04 <stepcut> shapr: but doing that might require modifications to the haskell type system ... I would have to look at the problem again
11:10:04 <edwinb> shapr: across irc? In what way?
11:11:02 <shapr> some way to interact with epigram and preserve the same info across irc
11:11:24 <edwinb> you mean in an interactive programming kind of a way?
11:11:28 <shapr> yup
11:11:33 <edwinb> The interface would be ... interesting, but I'm sure it'd be possible.
11:11:34 <shapr> I love the sheds idea
11:11:56 <edwinb> I like the word "shed".
11:12:14 <shapr> hej cm__
11:12:35 <shapr> I like the way that epigram is halfway between what Riastradh and I think about editors.
11:12:53 <shapr> Riastradh: hey, have you tried epigram?
11:13:01 <edwinb> The big problem is the way changing one thing interacts with everything else and potentially breaks the types.
11:13:25 <Riastradh> No, not yet...
11:13:30 <edwinb> It's a pretty hard problem. Probably Somebody Else's PhD.
11:13:39 <shapr> you mean that opening only one shed can mean that the type of something is limited by multiple other spots in the closed source?
11:13:58 <edwinb> Indeed.
11:14:05 <shapr> type shed
11:14:12 <edwinb> Say you're editing a function which is used in a type somewhere else.
11:14:13 <shapr> like type slicing
11:14:23 <shapr> graphical type refactoring :-)
11:14:27 <edwinb> Even in simple types it's a pain, like if you add an argument to a function.
11:14:35 <Riastradh> Oh, right, I remember why I didn't try it: it requires XEmacs, but XEmacs and I haven't gotten along very well in the past.  It ate my .emacs file, and regurgitated only a few bytes into its own version of that file.
11:15:09 <shapr> I think you really are heading in the direction of graphical type/source refactoring.
11:15:14 <edwinb> Yes, so do I.
11:15:29 <shapr> Riastradh: hack the epigram.sh file to use xemacs -q and it should work
11:15:31 <edwinb> But I'd prefer someone else to think about that bit ;)
11:15:42 <shapr> I'd love to, need a PhD student? ;-)
11:15:56 <shapr> I just have to get a degree first.... :-)
11:16:03 <edwinb> heh
11:16:32 <shapr> basically, you need to open a single type shed wherever it exists in the source file
11:18:40 <shapr> so it opens in multiple places, even though it's the same shed
11:18:57 <shapr> it really is strongly related type-slicing
11:19:06 * shapr takes a walk to think about that
11:20:11 <shapr> I must send an email about this to Claus Reinke, I bet he'd be interested in an orthogonal type-based approach to refactoring that's closely related to (or maybe the same as?) type-slicing.
11:20:30 <SyntaxNinja> y0
11:20:44 <shapr> y0 SyntaxNinja
11:20:53 <edwinb> Hmm
11:20:55 * shapr disappears for a bit
12:11:57 <shapr> well
12:12:36 <shapr> I think type-slicing based refactoring is just another way of metaphysically expressing meaning in a given application.
12:12:56 <shapr> basically, types are one flavor of MeaningfulNames
12:13:20 <shapr> so, it's just a different take on the same stuff in Don Robert's thesis.
12:15:34 <shapr> email needs ringtones
12:28:51 * shapr hacks up an implementation with procmail and ALSA's aplay
12:32:15 <shrimpx> haah
12:32:30 <Marvin--> now that's just sick
12:32:36 <shapr> what?
12:32:45 <shapr> email ringtones?
12:32:48 <Marvin--> yes
12:32:55 <shapr> I think it's cute.
12:35:55 <arjanb> i think it will interrupt concentration too often
12:36:17 <shapr> hm, maybe so.
12:38:57 <Philippa_> I think it stinks of AOL, but hey
12:39:04 <Philippa_> "You've got mail!"
12:39:11 * shapr snickers
12:39:43 <shrimpx> if you do that, you should have a pic of tom hanks pop up when you get mail
12:40:09 <shapr> actually, I think this would be good for work-related email
12:44:13 <Igloo> Marvin--: That's my wx packages being broken, I hope
12:45:49 <keverets> years ago, I used to use a Monty Python clip of "*thwap* Message for you sir" when my mail arrived.
12:46:21 <Marvin--> Igloo: yours or syntax' or both :)
12:46:25 <shapr> the advantage of procmail is that you get to choose the sound clip by field regex
12:46:47 <Marvin--> keverets: me too, for a very very short time, then I discovered mailing lists
12:46:52 <Igloo> :-)
12:46:55 <Igloo> Thanks for the info, anyway
12:48:44 <keverets> Marvin--: ;)
12:49:53 * Lemmih wonders why 'get lstCtrl (item idx)` isn't working as expected.
12:54:03 <Cale> shapr: ugh - could you put a ban on 218.13.219.146 and 218.79.109.3 -- they're both (different) spammers, and they don't seem to want to stop.
12:54:40 <shapr> sure
12:56:09 <shapr> done
12:56:13 <Cale> good :)
12:57:11 <shapr> want me to put some immutable taunts on Qiyang?
12:58:15 * shapr does so
12:59:58 <shapr> hiya lumm0x, long time no see
13:00:12 <shapr> how's code?
13:06:48 <lumm0x> shapr, I don't know you. Maybe there's another lumm0x..
13:07:16 <shapr> haven't you been before? some years back?
13:07:46 <shapr> actually, January 25th this year?
13:07:53 <lumm0x> could be =)
13:08:33 <lumm0x> I haven't learned much. I'm too lazy :P
13:08:40 <shapr> well, as long as you're having fun
13:08:54 <lumm0x> I'm still trying to learn English ;)
13:09:00 <shapr> I'm trying to learn Swedish.
13:09:04 <lumm0x> nice
13:26:44 <Marvin--> I wonder if libwxc is interesting enough to split off from wxhaskell and turn it into a separate package
13:26:49 <Marvin--> I mean, upstream as well
13:27:10 <Marvin--> or if it could be merged into wxwindows in general, so that it could provide both a C api and a C++ api
13:29:37 <Hobbes> hello?
13:31:55 <Riastradh> Hi.
13:33:37 <Lemmih> Hobbes: Looking for Haskell info?
13:33:46 <Hobbes> im need to sort a list such as [1,1,2,3,3,3,4,5,6,6] into a list of tuples such as [(1,2),(2,1),(3,3),(4,1),(5,1),(6,2)] ie the fst in the tuple is the number in the original list and the snd in the tuple is the number of times it occured in the original list
13:33:59 <Hobbes> but it needs to be polymorphic as well
13:34:08 <Hobbes> any ideas?
13:35:01 <Riastradh> How would you do it monomorphically?
13:35:16 <Hobbes> i have no idea
13:35:20 <Hobbes> thats the problem
13:36:32 <Riastradh> Can you just describe the general algorithm for how you might do this?
13:37:20 <Hobbes> i dont know what the general algorithn would be. all i know is what i need to do.
13:39:22 <Riastradh> Well, given a bunch of objects in real life, how would you count the duplicates manually?
13:41:45 <Riastradh> Suppose I gave you a bunch of chunks of various materials: ruby, diamond, ruby, granite, granite, ruby, diamond, granite.  How would you count the chunks?
13:44:59 <Cale> I might also point you at the List library where there is a function called group.
13:45:29 <stefan_> it's more fun doing it yourself first ;)
13:46:31 <Cale> or to compromise a bit more, the prelude, where there is a function called span
13:55:01 <stefan_> @type span
13:55:03 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
13:56:45 <keverets> I think there was something in Craft2e to do with this...
13:57:09 <stefan_> Hobbes: are you still trying?
14:10:52 <Hobbes> yeah...just had a nice break..back to this...
14:11:21 <Hobbes> i'd go through the list and count up each type
14:11:52 <Riastradh> Well, yes, but can you be more specific?
14:12:04 <stefan_> I'd suggest: start simple.
14:12:32 <Hobbes> put say all the ruby's into one list?
14:12:36 <Hobbes> then diamond
14:12:39 <Hobbes> etc
14:12:42 <Riastradh> OK.
14:13:02 <Riastradh> Can you go further and be even more specific as to how to do that?
14:13:15 <Hobbes> with filter? but doesnt that only remove items not put them in a list?
14:13:38 <Philippa_> no, it can't remove anything in a pure language. It gives you a list of the items matching the filter
14:13:41 <Riastradh> No, don't go to Haskell yet.
14:13:49 <Hobbes> ok
14:13:51 <Riastradh> You're just considering how this might be done.
14:13:58 <Riastradh> Abstractly.
14:14:09 <Riastradh> So you'd separate all the stones into one pile.
14:14:15 <Hobbes> so yeah id put all of the same type into piles and count them from there
14:14:17 <Riastradh> How would you do this, even more specifically?
14:14:55 <Hobbes> erm...other than putting into piles?
14:15:25 <Riastradh> Right.  You're given a sequence of stones.  How are you putting them into separate piles?
14:15:38 <Hobbes> matching the different types?
14:15:39 <Riastradh> They don't magically sort themselves into piles; you have to pick them up and put them into piles.
14:16:17 <Riastradh> Do you just randomly pick up stones and put them into their respective piles?
14:16:28 <Riastradh> Or do you use some more systematic approach?
14:16:38 <Philippa_> the former :-)
14:16:53 <Philippa_> a computer shouldn't though
14:16:59 <Hobbes> no id look at the first stone ive got then pick up all then ones that match it
14:17:10 <Riastradh> OK.
14:17:34 <Riastradh> So can you describe this entire process of how you sort the stones into their own piles, now?
14:18:11 <Hobbes> id pick one...match it with the others...then start again
14:19:16 <Riastradh> OK, good enough.  Now, to begin translating this idea to Haskell.
14:19:30 <Hobbes> ok
14:19:38 <Riastradh> First, at what point do you stop this process?
14:19:55 <Hobbes> when there is nothing left to pick up
14:20:11 <Riastradh> Right.  In Haskell, this is...?
14:20:22 <Hobbes> when the list is empty
14:20:24 <Hobbes> []
14:20:26 <Riastradh> Right.
14:20:51 <Riastradh> So, if you have a function to separate the stones into separate piles, what's its base case?
14:20:59 <Riastradh> Just write the definition of the function for [].
14:21:20 <Hobbes> an emtpy list.... null lis = []?
14:22:43 <Riastradh> Let me be clearer: you're going to have a function separatePiles that will separate a sequence of objects into piles of equal objects.
14:22:54 <Hobbes> yeah
14:23:03 <Riastradh> I want you to define the base case of separatePiles in Haskell.
14:23:08 <Hobbes> aah
14:24:22 <Hobbes> erm... 
14:25:05 <Riastradh> Just define what separatePiles is supposed to do when given the empty list.
14:25:29 <Hobbes> return an empty list?
14:25:45 <Riastradh> Right, but how do you write this in Haskell?
14:26:10 <Hobbes> seperatePiles [] = []?
14:26:16 <Riastradh> Yes.
14:26:33 <arauko> hello
14:26:49 <arauko> haskell is a pure functional programming language correct?
14:26:59 <Riastradh> Now, what do you do if separatePiles is given a list whose head is x and with the remaining elements xs?
14:27:04 <Riastradh> arauko, yes.
14:27:43 <Hobbes> inspect x and look through xs for more occurences of x
14:27:52 <arauko> Riastradh, scheme isnt pure functional?
14:27:57 <Riastradh> No, arauko.
14:28:53 <Riastradh> Hobbes, right, so we need to define another function findOthers, which, given an object z and a list zs, returns a list of a list of all elements of zs that are equal to z.
14:29:25 <Hobbes> ok..
14:30:20 <Hobbes> so findOthers z zs = something
14:30:23 <Riastradh> Actually, just to make things less confusing, ignore the variable names I used.
14:30:30 <Hobbes> haha...ok
14:30:55 <Riastradh> First, can you define the base case of findOthers?
14:31:11 <Hobbes> zs is the empty list again?
14:31:17 <Riastradh> Yes.
14:31:26 <Hobbes> findOthers z [] = []
14:31:26 <Riastradh> So can you define this base case?
14:31:35 <Riastradh> Actually, not quite.
14:32:32 <Riastradh> Er, never mind.  This will work, just not quite as optimally as it could, and I don't want to confuse you by changing things in the middle.
14:32:54 <Hobbes> optimallnes isnt really important anyway
14:33:37 <Riastradh> So, yes, that's right.  Now, what if you're given a non-empty list whose head is equal to z?
14:34:27 <Hobbes> return a list with z in it?
14:34:31 <Hobbes> [z]
14:34:32 <Hobbes> ?
14:34:45 <Riastradh> Not quite.
14:35:06 <Riastradh> If you did that, findOthers would always return a single-element list.
14:35:14 <Hobbes> aah yeah
14:35:17 <Riastradh> But we want to get a list with as many elements as there are duplicates of the object.
14:35:27 <Riastradh> So, after creating a list whose head is z, what do you need to do?
14:36:09 <Hobbes> add any more z's to the tail of the list?
14:36:20 <Riastradh> Right.  How do you do that?
14:36:24 <Hobbes> ie check the tail for more z's
14:36:41 <Riastradh> More specifically, in Haskell...?
14:36:50 <Hobbes> i would guess with a recursive call using the tail as the new list
14:36:56 <Riastradh> Yup.
14:37:22 <Riastradh> So, given x -- the object you're finding duplicates of --, z -- the current element in the list --, and zs -- the remaining elements in the list --, how would you create this list?
14:37:34 <Riastradh> (x & z are really the same)
14:39:27 <Hobbes> findOthers x (z:zs) = erm...
14:39:42 <Riastradh> No, just construct a list given all that.
14:41:35 <Hobbes> this is god damn confusing i keep trying to do it imperatively
14:42:29 <Riastradh> Well, first, how do you construct a list with the head h and the tail t?
14:42:36 <Hobbes> (h:t)
14:43:51 <Riastradh> Now, the head is going to be z in this case.  The tail is going to be a list of all the copies of x in zs.
14:44:46 <Hobbes> so... (z:findOthers z zs)?
14:44:53 <Riastradh> Yes, that will work.
14:44:59 <Riastradh> Now, what if z _isn't_ equal to x?
14:44:59 <Hobbes> woohoo
14:45:35 <Hobbes> you mean if the head of zs isnt the same as z?
14:46:58 <Riastradh> Well, you wrote:
14:47:03 <Riastradh> findOthers x (z:zs) = ...
14:47:15 <Riastradh> Given that, if x isn't equal to z...
14:47:47 <Hobbes> aah... ignore z and move onto zs?
14:48:46 <Riastradh> So the code will be...?
14:51:15 <Hobbes> findOthers x (z:zs) = findOthers x zs
14:51:33 <Riastradh> Not exactly.  I just wanted the 'findOthers x zs' snippet.
14:51:40 <Riastradh> Now, to combine all three snippets.
14:51:44 <Riastradh> Do you know about guards?
14:51:47 <Hobbes> yeah
14:51:51 <Riastradh> OK.
14:51:58 <Riastradh> So you'll want a guard for when x == z.
14:52:05 <Hobbes> yep
14:52:38 <Riastradh> Can you combine the three snippets -- the first part of the definition, the case where x == z, and the other case --?
14:53:30 <Hobbes> |(x==z) = (z:findOthers z zs)
14:53:51 <Hobbes> god damn
14:54:01 <Hobbes> right from the beginning..
14:54:13 <Riastradh> Yes, the whole findOthers definition.
14:55:47 <Hobbes> findOthers :: a->[a] -> [a] -- or does it return [[a]]
14:56:00 <Riastradh> Don't worry about the type signature.
14:56:14 <Hobbes> ok
14:56:14 <Riastradh> That type signature is correct as it is, but don't worry about it.
14:56:29 <Riastradh> I just want the definition -- I don't care about the type declaration --, for now.
14:57:08 <Hobbes> findOthers z zs
14:57:24 <Hobbes> |(zs == []) = []
14:57:29 <Riastradh> No, no.
14:57:33 <Riastradh> Use pattern matching.
14:58:01 <Riastradh> Don't modify the code you had written previously.
14:58:14 <Hobbes> ok
14:58:55 <Hobbes> |z [] = []
14:58:58 <Hobbes> ?
14:59:06 <Hobbes> sorry x not z
14:59:14 <Hobbes> |x [] = []
15:00:32 <Riastradh> No, no, no.
15:00:40 <Riastradh> Just look at the code snippets above.
15:01:42 <Hobbes> ok ive got....  findOthers z [] = [] and (z:findOthers z zs) and  findOthers x zs
15:02:13 <Riastradh> The base case definition of findOthers; the definition of findOthers on non-empty lists, its case where x == z, and the remaining case.
15:02:13 <Hobbes> im thinking the first findOthers isn't necessary?
15:07:02 <Hobbes> ok so the first guard isnt |z [] = []?
15:08:43 <arjanb> no just use findOhters z [] = []
15:09:15 <Hobbes> ok
15:09:52 <Riastradh> Just use the code that you've already written; don't cruft together what you guess might be what I'm looking for.
15:10:54 <Hobbes> then findOthers z zs = (z:findOthers z zs)
15:11:26 <Riastradh> No, there are two cases to consider there.
15:11:46 <Riastradh> Look, you've already written all of the code:
15:11:56 <Riastradh> For the empty list: findOthers x [] = []
15:12:02 <Hobbes> yeah
15:12:44 <Riastradh> For findOthers x (z:xs), when x == z:   z : findOthers x zs
15:12:53 <Hobbes> yeah
15:12:58 <Riastradh> And the final case, just:  findOthers x zs
15:13:08 <Riastradh> Now, I just want you to combine all these parts in Haskell.
15:13:14 <Riastradh> Don't modify the existing code.
15:14:21 <Hobbes> you want me to write that lot out in guards?
15:14:48 <Riastradh> Just the two non-empty list cases in guards.
15:15:05 <Hobbes> oh ok...
15:15:22 <Hobbes> findOthers x [] = []
15:15:49 <Hobbes> findOthers x (z:xs)
15:16:16 <Hobbes>      | x == z = z:findOthers x zs
15:16:57 <Hobbes>      |findOthers x zs
15:17:21 <Riastradh> Not quite.
15:17:24 <Hobbes> damn it that last one isnt right is it
15:17:39 <stefan_> Time to call it a day. G'night everybody.
15:17:56 <Hobbes> how do you do ISNOT in haskell is it != ?
15:18:31 <Cale>  /=
15:18:31 <Hobbes> or can i just put otherwise?
15:18:47 <Riastradh> You can just use otherwise.
15:19:04 <Hobbes> so | otherwise = findOthers x zs
15:19:21 <arjanb> yes
15:19:35 <Riastradh> Good.
15:20:15 <Hobbes> sorry man i wish i had your patience
15:20:43 <Hobbes> ok so ive got the code for getting a list of items matching z
15:20:55 <Riastradh> Oh, wait...er...
15:21:11 <Riastradh> This findOthers actually won't quite work.
15:21:31 <Hobbes> oh
15:21:38 <Riastradh> You need to _also_ collect every element that _isn't_ equal to x.
15:22:26 <Hobbes> yes so i dont throw it away ...or i wount be able to get anything except the first element right?
15:22:54 <Riastradh> Well, you could still use this findOthers, I suppose, but...mumble...oh well.
15:23:59 <Riastradh> OK, so, now, back to separatePiles.
15:24:24 <Hobbes> ok
15:26:14 <Riastradh> What's the base case for separatePiles again?
15:26:59 <Hobbes>  seperatePiles [] = []
15:27:47 <Riastradh> And what will we do if we get a non-empty list?
15:28:05 <Hobbes> call findOthers
15:28:13 <Riastradh> And?
15:28:43 <Hobbes> move onto the next part of the list?
15:31:03 <Hobbes> seperatePiles [] = []
15:31:38 <Hobbes> seperatePiles (h:t) = findOthers h t
15:31:54 <Hobbes> hmmm maybe not
15:31:55 <Smerdyakov> That word is spelled "separate." :P
15:32:01 <Riastradh> But that will give you only one pile.
15:32:48 <Hobbes> separatePiles (h:t) = separatePiles
15:32:57 <Hobbes> damn didnt mean to press enter
15:37:33 <Hobbes> do i put "separatePiles t" as the third line?
15:38:59 <Riastradh> It doesn't matter how you format your code.
15:40:07 <Hobbes> but thats right?
15:40:12 <Riastradh> No, not yet.
15:46:56 <Hobbes> separatePiles (h:t) = (findOthers h t:separatePiles t)
15:47:13 <Hobbes> hmmm
15:47:37 <Riastradh> Almost.
15:47:50 <Riastradh> Note that that will create a fresh pile for _every_ duplicate.
15:47:59 <Riastradh> You need to remove h from t when you recursively call separatePiles.
15:48:10 <arauko> a question about concepts: im reading about "pure functional languages" , it says that they always return the same value for the same functions , they give an example with C, f=(getchar(), getchar()) wont return the same result for both getchar, my question is, that wont happen with I/O always?... i mean, how is it done in haskell? 
15:48:31 <Smerdyakov> The IO monad!
15:49:17 <Smerdyakov> It's a non-trivial subject. Read a tutorial about it if you want to know more.
15:49:18 <monochrom> We don't let IO procedures be functions.
15:50:00 <arauko> ooh.... 
15:50:12 * arauko thought it was a dumb question 
15:50:41 <Riastradh> So, Hobbes, you could use the delete function from the List module:   delete h t
15:50:59 <arauko> monochrom, so, IO is implemented differently?
15:51:01 <Hobbes> oh ok... i wasnt aware of that
15:51:08 <monochrom> Yes.
15:51:29 <Riastradh> arauko, the interface to I/O is very different from what you're used to.
15:51:31 <Philippa_> arauko: IO's effectively implemented as a function of type World -> World, but said function's actually within a framework that prevents there being more than one copy of the world in use at once
15:51:45 <Philippa_> but yes, the interface is seriously different
15:52:29 <Hobbes> so separatePiles (h:t) = (findOthers h t:separatePiles (delete h t))
15:52:39 <arauko> Riastradh, hah yeah.. thats what im noticing 
15:53:14 <Riastradh> Hobbes, now constructing the final list is trivial: for each pile p in the list of piles, you construct a tuple (head p, length p).
15:53:42 <Hobbes> can i do that with map>
15:53:43 <Hobbes> ?
15:53:57 <arauko> Philippa_, aaah... think i get it... so.. everytime it is called IO, a new World is created?
15:54:15 <Riastradh> You can, Hobbes.
15:55:06 <Lor> World -> World is how _universe_ implements _time_
15:55:17 <Lor> (or rather, it would be, if time were discrete...)
15:55:20 <Hobbes> woohoo! thanks so much for helping... i wish my lecturer could help me like this
15:55:40 <Riastradh> Hobbes, so does your function work?
15:55:51 <Hobbes> haha...im just going to check that now
15:59:46 <Hobbes> eh.....i get this error... Prelude> :l "C:\\Documents and Settings\\Christopher\\Desktop\\Bags2.hs"
15:59:47 <Hobbes> ERROR "C:\Documents and Settings\Christopher\Desktop\Bags2.hs":16 - Syntax error
15:59:47 <Hobbes>  in declaration (unexpected `}', possibly due to bad layout)     
16:00:01 <Hobbes> but its only a 15 line file
16:05:25 <Hobbes> oh hang on
16:28:47 <Hobbes> do i have to import the LIST module to use the delete function?
16:29:04 <Hobbes> or is it imported automatically?
16:29:05 <Riastradh> Yes.
16:29:08 <Riastradh> No.
16:29:27 <Hobbes> it seems to mess up my module declaration
16:29:37 <monochrom> import List
16:29:43 <Hobbes> now it says its an unexpected keyword
16:29:51 <monochrom> Or if you are a minimalist, import List(delete)
16:30:04 <Hobbes> my module bags that is
16:30:16 <Cale> put the import declaration after the module declaration
16:30:22 <Hobbes> duh
16:30:24 <Hobbes> cheers
16:31:12 <monochrom> Ah
16:32:19 <Hobbes> im amazed at how much my lecturer has glossed over
16:33:54 <Cale> Well, you might try some of the tutorials which are floating around on the web.
16:34:16 <Cale> I like Hal Daume's
16:34:32 <Smerdyakov> Hobbes, is this a programming languages survey course?
16:34:41 <Hobbes> i think i might. funny you would think that for just over £1000 per year you would get proper tuition
16:34:55 <Philippa_> Hobbes: hah
16:35:06 <Philippa_> which uni're you at?
16:35:09 <Hobbes> sheffield
16:35:33 <Philippa_> Nottingham here
16:36:11 <Philippa_> they do sort of OK at Haskell in the first year (but not enough to write whole programs). Too many folks make it past the first year not being able to code in Java though, and it's the main lang here
16:36:39 <Hobbes> thats my problem...too much java. so when they threw this at us it confused the hell out of me
16:38:40 <Hobbes> ok so ive changed the name of separatePiles to listToBag to fit in with my work and i get this when i test it..
16:38:41 <Hobbes> Bags2> listToBag [1,1,1,2,2,3,3,3,3,4,5,5,6,6]
16:38:41 <Hobbes> [[1,1],[],[2],[3,3,3],[3],[],[5],[6]]  
16:39:47 <Hobbes> could that be cos i havent put my type declarations in yet?
16:40:22 <Hobbes> or maybe its deleting things too early
17:05:55 <Hobbes> ok its kind of working...trouble is each pile has one less element in it than it should do
17:11:19 <Cale> Hobbes: what do you have so far?
17:13:07 <Hobbes> http://www.pastebin.com/91253
17:13:22 <Hobbes> is there a haskell equivalent of pastebin?
17:13:35 <Cale> the Paste Page on the wiki
17:13:51 <Hobbes> coolio
17:14:14 <Hobbes> but anyway thats what ive got...but it knocks one off each pile
17:15:04 <Cale> try  listToBag (h:t) = findOthers h (h:t) : listToBag (remove h t) 
17:15:44 <Hobbes> will do thanks..
17:16:39 <Hobbes> BINGO!!! thanks man i can finally go to sleep
17:16:51 <Cale> :)
17:17:16 <Hobbes> cheers for all the help everybody! ill probably be back tomorrow mind you
17:17:36 <Cale> no problem :)
17:18:52 <Cale> Hobbes: but isn't findOthers x just filter (==x) ? :)
17:18:58 <Cale> oop
21:53:34 * palomer wants not patterns!
21:53:45 <palomer> does haskell have and patterns?
22:18:33 <palomer> can you store patterns in variables?
22:19:39 <Smerdyakov> No
22:19:46 <SamB> palomer: what in the world are you talking about?
22:19:52 <monochrom> f b@(x:xs) = b
22:20:00 <SamB> I don't understand those questions!
22:21:02 <palomer> a(x) = Literal x | Variable x ... Plus(a(x),a(x)) => x , for example
22:21:09 <monochrom> in sml: f (b as x::xs) = b
22:21:27 <palomer> monochrom: hmm?
22:21:50 <monochrom> I don't claim to understand what you want, but I bet it is related to my examples.
22:21:51 <palomer> I want to store them for a long time
22:22:21 <monochrom> I'll paraphrase Wendy in Peter Pan.  "A long time" is a long, long time...
22:22:26 <palomer> I see your point...
22:22:38 <palomer> actually no, this isn't quite it
22:22:49 <palomer> my example is what I want
22:23:32 <monochrom> I see.
22:23:41 <palomer> in your example, I can only bind if I match
22:23:55 <monochrom> #define favourite Literal x | Variable x
22:24:09 <monochrom> ...Plus(favourite, favourite)...
22:24:12 <palomer> yes, if you wish
22:24:36 <monochrom> No, unfortunately.
22:24:40 <palomer> this would be _immensely_ useful
22:24:58 <monochrom> I understand. I don't know how to make it easier.
22:25:02 <palomer> hrm
22:26:07 <palomer> I was also thinking of declaring the commutativity of certain constructors, like Plus(Literal a,Variable b) is the same as Plus(Variable b, Literal a)
22:29:35 <palomer> or...constructor arity overloading and associativity!
22:29:51 * palomer gets shivers
22:30:06 <Cale> Then you'd have Mathematica, and Mathematica has problems. :)
22:30:17 <monochrom> I think you are very ambitious.
22:31:30 <palomer> come on...
22:31:42 <palomer> constructor arity overloading would be very useful
22:32:16 <Cale> Why not just include a list?
22:32:36 <palomer> Cale: associativity on a list?
22:33:05 <Cale> Well, if the thing is associative, then you can record it as a plain list.
22:33:29 <Cale> data Expr = Plus [Expr] | ...
22:34:12 <palomer> oh, good points
22:34:18 <SamB> alternatively, create a frontend HaskellFront that takes another Haskell++ which supports overloading of names, and mangles it up
22:34:45 <Lemmih> wxHaskell question: Why is `get lstCtrl (item idx)` always returning a list of empty strings on Windows? Is it a bug or (very weird) feature?
22:36:16 <Cale> Lemmih: and it doesn't on other platforms?
22:36:28 <Cale> or you haven't tried it?
22:36:41 <Lemmih> Cale: No. It works fine on my Debian box.
22:36:54 <Cale> odd, I'd probably call that a bug
22:37:18 <Cale> Or else they've chosen a very funny way to tell you what platform you're on :)
22:38:05 <SamB> Lemmih: might try the equivalent in wxPython to see if the bug is in wx or the bindings
22:38:07 <palomer> Cale: you know as well as I that sometimes tuples are easier to use than lists
22:38:42 <Lemmih> SamB: I'm not familiar with Python.
22:39:38 <SamB> Lemmih: well, get someone with wxPython on win32 to try it if you don't want to?
22:39:55 <SamB> I am on Debian so I'd be absolutely no help
22:40:03 <Cale> palomer: when tuples are what you really want
22:40:41 <palomer> Cale: in the case of overloading constructor arity, they are 
22:40:51 <Cale> hm?
22:40:59 <palomer> hm!
22:41:30 <Cale> Okay, so show me some example code to handle collapsing this overloaded Plus
22:41:53 <Cale> or what would the data declarations even look like?
22:42:49 <palomer> ok, for Plus it wouldn't work
22:42:56 <palomer> take, for example, Minus
22:43:04 <Cale> okay
22:43:11 <palomer> binary Minus and unary Minus
22:43:21 <palomer> how about that, tough guy?
22:43:36 <Cale> But these are entirely different things, and shouldn't be represented as the same.
22:43:39 <SamB> palomer: a mess through and through, that's what
22:44:04 <Cale> Just have Negate and Minus
22:44:16 <Cale> or remove minus altogether and have Negate and Plus
22:44:29 <palomer> I'm sure I'll find a case where arity overloading would be useful
22:44:30 <SamB> yeah, haskell's use of - for both is a pain!
22:44:51 <palomer> I think we can all agree that commutativity would be a really good keyword
22:44:55 <palomer> all in favour?
22:45:05 <SamB> and, really, the one and only special-cased binop
22:45:18 <palomer> (Plus:commutative) of int * int 
22:45:35 <palomer> SamB: special cased binop?
22:45:38 <Cale> but why stop there?
22:45:46 <SamB> palomer: in the syntax!
22:46:00 <Cale> commutativity is only a special case of the symmetric group
22:46:10 <Cale> heheh
22:46:20 <SamB> it interferes with sectioning
22:46:34 <Cale> Have the ability to support arbitrary symmetries under a group of permutations :)
22:46:45 <palomer> now we're talking
22:46:49 <Cale> haha
22:46:59 <palomer> get cracking people!
22:47:13 <SamB> Cale: that sounds vaguely undecidable from here!
22:47:13 <palomer> or what about this: patterns of patterns?
22:47:16 <Cale> haha
22:47:54 <Cale> yeah, especially with the word problem for groups being undecidable and all, I suspect you could construct some very "fun" examples.
22:47:55 <palomer> right now, all we have is boring composition of two patterns (and oring and other boring things)
22:48:31 <palomer> Pat1(Pat2) <--YAWN!
22:48:49 <palomer> I have no idea where I'm going with this
22:48:51 <SamB> YAWN! is right. must sleep...
22:49:06 <palomer> oh, yeah, like
22:49:37 <palomer> Pat1(_(Pat2,constructor of function)) <--YUMMY!
22:49:53 <palomer> add negation too!
22:55:05 <Cale> I want to have patterns with 43252003274489856000 values such that the symmetry group of the Rubik's cube is used to put them into the right order during pattern matching.
22:55:43 <Cale> erm, sorry
22:56:00 <Cale> I suppose you'd only need 48 or so
22:56:11 <palomer> symmetry cube of the rubik's cube?
22:56:24 <Cale> but 43252003274489856000 possible permutations there :)
22:57:11 <palomer> 9^6?
22:57:22 <Cale> Like, identify the elements in the data constructor with the corner and edge stickers.
22:57:29 <palomer> nevermind
22:57:42 <Cale> 2^27 3^14 5^3 7^2 11
22:58:39 <palomer> ooh, only two other factors of 3 fit into it, neat
22:59:34 <palomer> 11 seems like a big prime to be in that number
22:59:43 <palomer> I think you should recount
22:59:46 <Cale> not really
23:00:01 <Cale> Those factors are actually pretty small given that number.
23:01:38 <palomer> hrm
23:01:53 <SamB> well, the 000 at the end couldn't hurt that
23:01:54 <palomer> how easy is it to see if a certain configuration is a possible configuration of a rubik's cube?
23:02:16 <SamB> palomer: well, do you have god's algorithm?
23:02:23 <palomer> god?
23:02:30 <SamB> or rather, God's method?
23:02:35 <SamB> of solving the cube
23:02:46 <Cale> You don't need a perfect method.
23:02:55 <Cale> You just need one that works :)
23:02:58 <SamB> Cale: well, it would be easier with one!
23:03:25 <SamB> of course, no one really knows for sure if God ever does this
23:04:15 <Cale> palomer: you just apply an algorithm which solves it, and if it fails, then it wasn't a possible configuration :)
23:04:42 <palomer> hrm
23:05:00 <Cale> There are many which are known to solve the cube.
23:05:07 <SamB> or rather, a qubie-popping configuration
23:05:19 <palomer> oh, righto
23:05:40 <palomer> so...any plans on having better matching capabilities in the next haskell?
23:05:56 <SamB> I didn't even understand that stuff :-(
23:06:01 <Cale> Did you read the GADT paper?
23:06:10 <Cale> SamB: which stuff?
23:06:16 <SamB> I didn't understand that either
23:06:27 <SamB> Cale: what palomer wanted to do
23:06:44 <palomer> commutativity?
23:06:56 <Cale> Oh, he just wanted to have the ability to say that the order of the arguments to a data constructor doesn't matter.
23:07:00 <SamB> well, I guess that one isn't so incomprehensible
23:07:30 <palomer> constructor wildcards?
23:07:32 <palomer> negation?
23:07:36 <SamB> although it would have a rather... extreme effect on pattern matching
23:08:04 <palomer> storing patterns?
23:08:08 <SamB> and wouldn't give a nice error if it was accidentally removed/left out
23:08:14 <Cale> Mathematica has all of these (though I'm not sure about negation), but its type system is weaker.
23:08:21 <palomer> I don't see why haskell doesn't have storing patterns, it's trivial to implement
23:08:33 <SamB> palomer: I didn't understand that part at all.
23:08:39 <Cale> palomer: but what do you do with the patterns you've stored?
23:08:39 <SamB> they aren't values, are they?
23:08:52 <SamB> where would you store them and what would you do with them?
23:09:00 <Cale> Unless you allow functions to have very weak types
23:09:09 <palomer> #define foo Plus(Literal,Variable) | Plus(Variable Literal)
23:09:19 <palomer> Times(foo,foo) => ...
23:09:30 <palomer> substitute foo for the crap on the right
23:09:53 <SamB> I don't parse the | there
23:10:01 <palomer> oh, that's an or pattern
23:10:17 <Cale> why is Times taking two foo's?
23:10:21 <palomer> Literal | Variable matches either
23:10:29 <palomer> Cale: because it's a binary op?
23:10:50 <Cale> but the data constructors already have two things
23:11:02 <palomer> Cale: eh?
23:11:17 <Cale> so you'd be passing it two literals and two variables
23:11:31 <SamB> what made-up language are we talking about, anyway?
23:11:32 <palomer> that'll match Times(Plus(Literal,Variable),Plus(Variable,Literal)),... (4 things in total)
23:11:36 <Cale> at least, the way that I'm reading that
23:11:39 <SamB> it doesn't look much like Haskell
23:11:49 <Cale> palomer: right - but why?
23:11:59 <Cale> why 4, and not 2 -- it's a binary op
23:12:37 <palomer> Cale: what do you mean? There are 4 variations I'd like to catch with my pattern
23:12:45 <palomer> (the pattern says: Plus is commutative)
23:13:24 <Cale> so Plus(a,b) means either a or b?
23:14:24 <palomer> eh?
23:14:35 <palomer> no, Plus(a,b) matches the plus constructor
23:15:12 <palomer> Plus is simply a constructor
23:15:36 <palomer> #define foo Plus(Literal,Variable) | Plus(Variable Literal) ;Times(foo,foo) => ... <--to do this without my binding would take alot of typing
23:15:43 <palomer> and it gets even uglier with other ops
23:17:54 <palomer> oh wait, I see your point
23:17:56 <palomer> hrm
23:18:05 <palomer> though binding patterns is still useful
23:21:06 <palomer> (it saves on typing)
23:21:31 <palomer> like, instead of typing Plus(Times(...)), you could just write PlusTimes or something
23:24:24 <palomer> actually no, I don't see what you mean
23:29:33 <Cale> that's what I originally thought
23:29:37 <Cale> but you have
23:29:55 <Cale> Times(foo,foo), rather than Times(foo)
23:30:08 <palomer> oh, you don't understand my | operator
23:30:12 <palomer> | is match one or the other
23:30:28 <palomer> (I don't know what it is in haskell, maybe || ? maybe or? )
23:30:32 <Cale> that's also what I though
23:30:33 <Cale> t*
23:43:42 <shrimpx> omg the ghc runtime is huge
23:43:50 <monochrom> Yes.
23:44:04 <palomer> hrm
23:44:17 <palomer> are there any tutorials in writing a CAS in functional programming language?
23:45:52 <Cale> The maxima source code?
23:45:55 <Cale> hehe
23:46:03 <monochrom> hahah
23:46:48 <monochrom> Writing a CAS in a non-CAS is difficult.
23:48:06 <palomer> writing a CAS in a CAS is trivial: while(1){cin >> somestring ; eval(somestring);}
23:48:46 <shammah> what is a CAS?
23:49:04 <palomer> computer algebra system
23:50:00 <shammah> I thought was the most probable expansion of the ones google gave me :)
