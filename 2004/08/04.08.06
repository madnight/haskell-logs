03:10:26 <TheHunter> wow, the Nondet monad is twice as fast as the list monad, in my toy example!
04:10:01 <tic> Any lambda-reduction-specialists around? :)
04:31:44 <kosmikus> tic: what's the question?
04:32:05 <tic> kosmikus, I solved it. :) It was about normal reduction of a lambda expression.
04:33:37 <kosmikus> normal reduction? do you mean normal order reduction?
04:35:13 <tic> Right.
04:37:15 <kosmikus> ok
04:38:32 <tic> trying to get the grip of it.
05:27:11 <shapr> @yow !
05:27:12 <lambdabot> NOW do I get to blow out the CANDLES??
05:27:49 <Marvin--> lambdabot: no, you don't
05:27:49 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
05:28:08 <Marvin--> hello shapr
05:28:32 * Marvin-- saunters off to the kitchen to make some coffee
05:29:34 <shapr> greetings
05:33:12 <tic> In ( ((\x.a)(\x.b)) ((\x.c)(\x.d)) ), do you always "apply" c and d to b?
05:37:31 <Marvin--> hah, turns out I won't start working on Monday after all
05:37:44 <tic> Anyone? :(
05:37:44 <shapr> next week?
05:37:52 <kosmikus> tic: I don't understand the question.
05:37:57 <shapr> yah, I don't either
05:38:06 <tic> err, ... my bad.
05:38:23 <tic> hrm. imagine that instead of a..d it says x
05:38:55 <tic> do I do s/\x.b/\x.c \x.d/ or s/\x.a/\x.c \x.d ?
05:39:29 <kosmikus> I thought you just said that all the other letters are x's?
05:40:17 <kosmikus> So what is the correct lambda term you start from?
05:40:38 <Marvin--> shapr: well, I was going to start on Monday, but the guy who's going to be my mentor has to go on an urgent business trip to usa, and while I guess I could get by without a mentor the first few days, a worse problem is that everybody else who are not on vacation are going too, so the office is completely empty :)
05:41:05 <tic> kosmikus, (((\x.x)(\x.x))(\x.x x)(\x.x)))
05:41:11 <tic> oops.
05:41:15 <tic> kosmikus, (((\x.x)(\x.x)) ((\x.x x)(\x.x)))
05:41:20 <shapr> Marvin--: well, as long as you still get paid for this week ;-)
05:41:37 <tic> kosmikus, so do I insert the second group in the first or second part of the first group?
05:41:40 <Marvin--> :-)
05:41:58 <kosmikus> ok, so it's basically id id ((\x. x x) id) ?
05:41:59 * shapr rereads the QuotesPage
05:42:09 <shapr> we've come up with some excellent quotes over the last few years.
05:42:26 <tic> kosmikus, yeah.
05:42:37 <kosmikus> tic: and you should perform normal order reduction on it?
05:42:40 <tic> kosmikus, yeah.
05:42:48 <kosmikus> tic: ok, so what is the first redex?
05:42:49 <tic> and I'm a bit lost.
05:42:56 <Marvin--> shapr: it's been kinda slow lately though
05:43:01 <tic> kosmikus, dunno; the first id?
05:43:25 <shapr> Marvin--: we need a renaissance! any suggestions?
05:43:47 <shapr> some of these are hysterically funny
05:43:47 <Marvin--> not really
05:43:48 <kosmikus> tic: can id itself be reduced?
05:43:57 <shapr> I remember CowGirl trying to get us to do her homework
05:44:00 <tic> kosmikus, no.
05:44:11 <kosmikus> so can it be a redex?
05:44:42 <Marvin--> shapr: heh, yeah
05:45:05 <tic> kosmikus, ah.  No, it can't.
05:45:18 <tic> kosmikus, the first redex is (\x.x x)
05:45:33 <kosmikus> can (\x.x x) be reduced?
05:45:38 <shapr> She told me that she was a gorgeous female bartender who would be eternally grateful if I did her Haskell homework for her. I think she watched Coyote Ugly one time too many.
05:45:47 <tic> kosmikus, yeah, if I apply it to id.
05:45:50 <Marvin--> shapr: *lol*
05:46:11 <kosmikus> tic: well, ok, so ((\x. x x) id) is a redex
05:46:14 <Marvin--> that is one seriously bad movie
05:46:23 <shapr> I've never seen it, only the previews.
05:46:24 <kosmikus> tic: but it's not the correct one to start with for normal order reduction
05:46:45 <shapr> sexual bribery may work in person, but not from Australia to Sweden.
05:47:15 <Marvin--> shapr: the movie would've worked if it had been compressed into music video length :-)
05:47:39 <shapr> I'll keep that in mind if I ever end up watching it.
05:48:09 <shapr> Marvin--: what sort of things do you think Haskell needs to be better accepted into the industry?
05:48:34 <tic> kosmikus, what it says in my text book is that you reduce the larger groups.
05:48:47 <tic> kosmikus, but I can't really make anything useful out of it.
05:49:39 <kosmikus> tic: do you understand the syntax of lambda calculus?
05:49:52 <Marvin--> shapr: I have no clue, I think a general shift in thinking is needed, in "the industry", "programming language" is equal to "imperative programming language"
05:50:13 <tic> kosmikus, *shrug* appearently not... ?
05:51:09 <shapr> Marvin--: how do we get closer?
05:51:14 <Marvin--> shapr: no idea
05:51:22 <shapr> Jython helped Python, maybe Jaskell would help?
05:51:23 <tic> kosmikus, I understand simpler ones, but these cases puzzles me.
05:51:23 <kosmikus> Marvin--: ... "imperative programming language such as Java, C, Cobol, or HTML"
05:51:26 <kosmikus> tic: well, I'm trying to find out where to start
05:51:26 <kosmikus> tic: do you understand what a free and a bound variable is?
05:51:31 <Marvin--> kosmikus: :)
05:51:42 <shapr> tic: quick lunch?
05:51:49 <Marvin--> hah
05:52:11 <tic> heh.
05:52:13 <tic> lost my connection somehow.
05:52:20 <shapr> maybe more code examples?
05:52:42 <shapr> I don't know how to use some of the existing libraries because I've never seen them used.
05:52:47 <tic> kosmikus, the entire expression is: (((\x.x)(\x.x))((\x.x x)(\x.x)))((\x.x x)(\x.x))
05:52:53 <Marvin--> shapr: I think one of the better ways is to just keep hacking and see what happens, if we produce interesting tools written in Haskell, tools that people want to hack on, that encourages them to learn Haskell
05:52:59 <shapr> that's true
05:53:10 <shapr> lambdabot has been both accessible and useful
05:53:16 <kosmikus> tic: ok, let's start with something simpler
05:53:25 <tic> kosmikus, but I've understood that I want to split it up in two parts; say A and B.  The part A is what I've been trying to reduce.
05:53:29 <kosmikus> tic: what about ((\x.x) (\x.x))
05:53:33 <tic> kosmikus, \x.x
05:53:35 <thebug> shapr: I can't seem to ever get it to compile
05:53:36 <shapr> maybe I should take Heffalump's suggestion and port all the TaPL code to Haskell.
05:53:38 <tic> kosmikus, or, id.
05:53:38 <Marvin--> Like darcs, while darcs is interesting because it's written in Haskell, it's mainly interesting because it's *good*
05:53:48 <shapr> thebug: I shall fix that problem! tell me your symptoms.
05:53:48 <kosmikus> tic: ok
05:53:57 <kosmikus> tic: what about ((\x.x) (\x.x x))
05:53:58 <shapr> ok, any nifty app ideas?
05:54:07 <shapr> I'd like to write a pull email system in Haskell.
05:54:14 <thebug> shapr: sure, let me get the source out ... /msg ok?
05:54:18 <tic> kosmikus, same thing: (\x.x x)
05:54:21 <shapr> sure yeah
05:54:31 <kosmikus> tic: well, it's not the same, but correct
05:54:42 <kosmikus> tic: ((\x.x x) (\x.x))
05:54:44 <shapr> I hacked a bit on lambdabot last night, so my brain is online wrt to that.
05:54:51 <tic> kosmikus, (\x.x) (\x.x)
05:55:02 <Marvin--> shapr: btw, have you used pyrex?
05:55:08 <kosmikus> tic: which can be reduced again ...
05:55:09 <shapr> nope
05:55:16 <tic> kosmikus, to \x.x. right.
05:55:27 <kosmikus> tic: ok
05:55:46 <Marvin--> shapr: it seems pretty cool, I'm considering rewriting pyopenssl in pyrex rather than continuing to maintain this messy C code
05:55:48 <kosmikus> tic: ((\x.x x) (\x.x x))
05:55:51 <tic> kosmikus, okay, but then I must've mis-understood how normal reduction is done.  Isn't that application? And as such should be avoided as far as it goes?
05:56:09 <shapr> Marvin--: abstraction is good
05:56:14 <tic> kosmikus, ((\x.x x)(\x.x x)) ==> (\x.x x)(\x.x x)
05:56:21 <kosmikus> yes
05:56:32 <tic> kosmikus, ==> (\x.x x)(\x.x x), can't be reduced further.
05:56:48 <tic> heh. That last step was pretty unneccesary.
05:56:57 <kosmikus> tic: there is no such thing as "application" in lambda calculus, there only is (beta-)reduction
05:57:19 <kosmikus> tic: better say, "it reduces to itself"
05:57:31 <tic> kosmikus, okay, so what would be the difference between applicative order and normal order reduction in the example of: id id ((\x.x x) id) ?
05:57:34 <tic> *nods
05:58:01 <kosmikus> applicative and normal order reduction determine which redex to choose if you can reduce at multiple positions
05:58:23 <tic> left-most for normal, right-most for applicative?
05:59:35 <kosmikus> and outer-most
05:59:47 <tic> outer-most for which of them?
06:00:09 <kosmikus> sorry
06:00:42 <kosmikus> normal order reduction selects the left-most outer-most redex
06:00:47 <tic> ah-a.
06:00:51 <tic> And applicative?
06:00:57 <kosmikus> applicative order reduction ... iirc ... the left-most inner-most redex
06:01:06 <tic> ah.
06:01:07 <kosmikus> anyone else, is this correct?
06:02:27 <tic> sure it isn't the right-most inner-most redex?
06:02:34 <tic> Try this one: http://ellemose.dina.kvl.dk/~sestoft/lamreduce/lamframes.html
06:02:37 <shapr> greetz SyntaxNinja 
06:02:42 <tic> and plug in (\x.x) (\x.x) ((\x.x x) (\x.x)) into it.
06:03:01 <kosmikus> tic: relatively sure, yes
06:03:02 <tic> it seems that call-by-value uses the inner- and right-most redex.
06:04:22 <kosmikus> tic: no
06:04:35 <tic> Wow. This makes no sense.  According to that page, and everyone else, I'm supposed to take the right-most redex first in an applicative reduction for this expression: (\x.x x x)((\x.x x)(\x.x))
06:06:05 <kosmikus> in this case, the leftmost innermost is the rightmost outermost redex :)
06:06:36 <tic> yeah, that's obvious.. ;)
06:06:49 <tic> Hrm. Is there a good rule/rules I can use to get the hang of it?
06:06:57 <tic> 'cause I'd have no idea on when to choose what.
06:07:07 <SyntaxNinja> hey shapr!
06:07:22 <tic> I mean, in this particular case, what decides that this is actually the left-most inner-most redex?
06:07:34 <tic> i.e., what defines inner/outer-most?
06:07:43 <Marvin--> tic: why not just think in terms of call-by-value? "Reduce the argument before reducing the abstraction"
06:08:01 <tic> Marvin--, Hm..
06:08:19 <tic> how are parens grouped, if I have regex regex regex?
06:08:27 <tic> is it (regex (regex (regex))) ?
06:08:40 <kosmikus> yes, but you probably mean redex, not regex
06:08:46 <kosmikus> ah no
06:08:48 <tic> indeed I mean.
06:08:49 <Marvin--> ((regex regex) regex)
06:08:53 <kosmikus> it's the other way around, of course
06:08:57 <tic> a-ha.
06:09:00 <tic> okay.
06:09:04 * kosmikus is always getting confused by parentheses
06:09:29 <thebug> Igloo: ping
06:09:43 <Igloo> pong
06:09:49 <tic> So say I have ((regex1 regex2) regex3) (regex4 regex5).  What to do here using applicative order?
06:10:02 <thebug> Igloo: ghc 6.2.1 on woody?
06:10:02 <tic> (regex4 regex5) would be the argument, right?
06:10:09 <thebug> packages? pitfalls to building?
06:10:18 <bourbaki> hi
06:10:19 <Igloo> Is there not one in HE?
06:10:32 <thebug> Igloo: 'HE'?
06:10:35 <Igloo> It needs a couple of minor changes. GL/GLUT package names changed IIRC
06:10:42 <kosmikus> will be back in 5 minutes
06:10:50 <tic> and then, which of regex1..3 do I apply it to?
06:10:54 <tic> hrm
06:10:57 <thebug> Igloo: ah, well if I don't have GL or related goo on this system, is that a problem?
06:11:04 <Igloo> http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html (but hopefully not for long  :-)  )
06:11:32 <thebug> ahhh
06:11:51 <Igloo> You'd need to hack the package a bit to not build the opengl bits
06:12:39 <thebug> ah, if there's an existing package, I'll just go the lazy route :)
06:13:15 <bourbaki> Igloo you have done something with hgl right?
06:14:01 <bourbaki> irsirius hi
06:14:07 <Igloo> wrong
06:14:18 <bourbaki> dang ok :)
06:14:19 <kosmikus> tic: back
06:14:35 <thebug> Igloo: interesting broken-ness
06:14:36 <thebug> ghc6-threaded-rts: Depends: ghc6 (= 6.2-0.woody.1) but 6.2.1-1.woody.2 is to be installed
06:14:46 <thebug> but 'ghc' seems to install fine
06:14:50 <bourbaki> i have finished my normal map thing in the morning just need to render it to a texture and apply it to the model
06:14:55 <Igloo> The threaded RTS packages should have disappeared
06:15:08 <Igloo> Probably HE is missing whatever it is that does that cleanup
06:15:14 <kosmikus> tic: so, you have (((r1 r2) r3) (r4 r5)), and all of the rn's are redexes?
06:15:20 <tic> kosmikus, yes.
06:15:35 <tic> kosmikus, hypothetical case.
06:15:37 <thebug> Igloo: nice domain :)
06:15:57 <kosmikus> then you select r1 as first in applicative order
06:16:02 <Igloo> It's SyntaxNinja's  :-)
06:16:03 <bourbaki> is the guy who maintains the hgl package here also?
06:16:11 <thebug> I figured as much
06:16:15 <tic> kosmikus, aha.
06:16:23 <Igloo> bourbaki: Do you really mean HGL or HOpenGL?
06:16:52 <tic> kosmikus, and then I put in (r4 r5) into that?
06:17:05 <kosmikus> tic: what?
06:17:20 <tic> kosmikus, uhm, nevermind.
06:17:36 <kosmikus> tic: no, you reduce r1
06:17:48 <tic> kosmikus, say r1 == id.  what then?
06:17:56 <kosmikus> then r1 isn't a redex
06:18:06 <bourbaki> Igloo hopengl i mean
06:18:06 <kosmikus> because it cannot be reduced
06:18:16 <Igloo> Ah, yes then
06:18:32 <bourbaki> Igloo who is it?
06:18:57 <tic> kosmikus, okay.  let's say it's not a redex, how do I continue reducing the whole expression?
06:19:08 <Igloo> Me
06:19:12 <bourbaki> i think i could write a small tool that generates normal maps for meshes
06:19:19 <kosmikus> tic: in applicative order, you'd next choose r2 to reduce
06:19:39 <bourbaki> ah :) heh could you do a small tut to show how to use textures?
06:19:59 <tic> kosmikus, right.  Thanks!
06:20:00 <kosmikus> tic: let's call the result of that reduction r2'
06:20:04 <tic> kosmikus, yeah?
06:20:10 <tic> s/?/.
06:20:17 <kosmikus> tic: after that, you'd choose (id r2') as the next redex
06:20:24 <Igloo> I think Sven might have done so - check his examples directory in CVS
06:20:29 <thebug> Igloo: thanks for the pointer to HE, that fixed my old ghc5 setup right up :)
06:20:30 <kosmikus> tic: and reduce this to r2'
06:20:34 <Igloo> Otherwise, he's a better person to ask than me
06:20:42 <Igloo> thebug: np  :-)
06:20:43 <bourbaki> Igloo whos sven?
06:20:53 <tic> kosmikus, okay, and then continue working my way from the inside to the outside, so to speak?
06:20:58 <Igloo> He is the author of HOpenGL
06:21:08 <bourbaki> is he here also?
06:21:08 <kosmikus> tic: yes, precisely
06:21:09 <tic> kosmikus, and, if I were to use normal reduction order, I'd be reducing what redex first?
06:21:13 <Igloo> No
06:21:17 <kosmikus> tic: that's why it's leftmost *inner*most
06:21:19 <bourbaki> dang
06:21:27 <Igloo> But I'm sure his e-mail address is easy to find
06:21:32 <bourbaki> yes
06:21:36 <bourbaki> thank you
06:21:45 <bourbaki> can i browse the cvs with html?
06:21:58 <Igloo> I don't think you can nowadays  :-(
06:22:08 <bourbaki> :(
06:22:18 <shapr> no one has gotten around to fixing view-cvs
06:22:22 <shapr> but there is a solution!
06:22:25 <kosmikus> tic: still for (((id r2) r3) (r4 r5)) ?
06:22:29 <tic> kosmikus, yeah
06:22:55 <kosmikus> tic: well, there you'd start trying from the outside
06:23:15 <kosmikus> tic: (((id r2) r3) (r4 r5)) cannot be reduced as a whole, because the left hand side is not a lambda abstraction
06:23:22 <kosmikus> tic: so you descend to the left
06:23:42 <Igloo> shapr: Are you going to expand on that?  :-)
06:23:47 <kosmikus> tic: ((id r2) r3) cannot be reduced either, because the left hand side is not a lambda abstraction
06:23:58 <shapr> oh sorry, got distracted
06:24:11 <tic> kosmikus, mhm.
06:24:12 <bourbaki> heh
06:24:13 <kosmikus> tic: (id r2) is in reality ((\x.x) r2). This can be reduced, to r2.
06:24:29 <tic> kosmikus, yap.  So that is what I
06:24:33 <tic> kosmikus, so that is what I'd do then?
06:24:44 <shapr> I was thinking about using lelit's spiffy code to make a browseable darcs repo from the haskell cvs
06:24:45 <tic> try (id r2) r3, failing that I do (id r2) ?
06:24:54 <kosmikus> tic: here's the difference: in normal order (id r2) is reduced to r2 and then r2 is reduced to r2'. In applicative order, r2 is first reduced to r2', then (id r2') is reduced to r2'.
06:25:03 <kosmikus> tic: the result is the same, the steps are different
06:25:24 <Marvin--> kosmikus: ... yes and no
06:25:28 <tic> kosmikus, but that's the deal; the result isn't /always/ same. And I'm afraid of mixing applicative and normal order within a reduction.
06:25:45 <kosmikus> Marvin--: ... yes, apart from marginal termination issues
06:26:07 <tic> Hm. I'll have to chew on that for a while.. Thanks for the help though.
06:26:38 <shapr> now I want a cvs.haskell.org account
06:26:54 <Igloo> I thought you had one
06:27:07 <shapr> long ago, but no more
06:27:21 <kosmikus> tic: if reduction terminates in applicative order, then the result with normal order reduction is the same
06:27:38 <Igloo> Ah, you can mail the guys to get it reinstated
06:27:56 <Igloo> Or you could just base it on the public CVS
06:28:37 <tic> kosmikus, yeah, only problem is that it might never terminate in applicative order. Back to the book for me!
06:29:31 <kosmikus> hey, I'll probably get my thesis from the printer next tuesday
06:29:31 <shapr> yah, I'll just use public cvs for the moment
06:29:32 <Marvin--> tic: it might not terminate in normal order either, but *if* the term has a normal form, you can find it with normal order reduction
06:29:34 <Igloo> Bah, m68k's timeouts don't mesh well with things being compiled by ghc
06:29:37 <Marvin--> kosmikus: yay
06:30:13 <Marvin--> Igloo: heh
06:30:30 <RussellOConnor> Is `mplus` supposed to be communtative?  the ``plus'' sort of indicates that.
06:30:41 <Igloo> No
06:38:38 * shapr tries to remember how to see if a file exists
06:38:56 <Igloo> @index doesFileExist
06:38:57 <lambdabot> System.Directory,Directory
06:39:06 <shapr> too easy!
06:39:08 * shapr grins
06:39:16 <Igloo> Don't forget to catch the exception anyway to handle race conditions
06:40:10 <SyntaxNinja> hi Marvin-- welcome back.
06:42:14 <shapr> hiya __stefan_h__ 
06:42:18 <shapr> are you a magic method?
06:42:26 <__stefan_h__> hi
06:42:41 <__stefan_h__> kind of ;)
06:43:01 <thebug> __ctor ;)
06:43:08 <shapr> looking for Haskell info?
06:43:51 <__stefan_h__> in general: always ... but nothing particular right now ...
06:44:02 <shapr> ok
06:44:08 <shapr> if you have any questions, feel free to ask
06:44:22 <__stefan_h__> I will :)
06:44:46 <__stefan_h__> is this a "busy" channel?
06:44:55 <shapr> what's your definition of busy?
06:45:01 <SyntaxNinja> everyone here is very busy
06:45:44 * shapr is hacking on lambdabot 
06:45:46 <shapr> @yow !
06:45:47 <lambdabot> How many retired bricklayers from FLORIDA are out purchasing
06:45:47 <lambdabot>  PENCIL SHARPENERS right NOW??
06:46:01 <__stefan_h__> I figured ... I meant: is there a lot of activity here ... or are you guys sitting around here waiting for interesting questions to pop up?
06:46:07 <shapr> both!
06:46:30 <__stefan_h__> okay
06:47:31 * shapr gicks at ugly old code in lambdabot 
06:47:38 <Lemmih> And I'm actually waiting for an interesting answer.
06:47:40 <shapr> I really should have cleaned that up long ago
06:47:44 <shapr> Lemmih: 42
06:47:59 <SyntaxNinja> we usually sit around waiting for someone to ask a question, then we make a half-assed attempt to answer it, then we talk about how we could change the language to make it a one-line solution.
06:48:19 <Lemmih> shapr: A little less interesting than that.
06:48:31 <__stefan_h__> ok, sounds like fun; can't wait to see the concept in action :)
06:48:38 * shapr laughs
06:48:59 <shapr> SyntaxNinja: you've been spending too much time in #java
06:49:07 <SyntaxNinja> unfortunitely, a lot of things can be solved with Template Haskell now-a-days, and that limits our conversation options
06:49:30 <SyntaxNinja> shapr: :P
06:49:52 <Marvin--> hello syntax
06:50:20 <__stefan_h__> well, maybe I will be asking a lot about TH then, the next couple of days, for I'm planning to prototype a particular addition to Generic Haskell using TH
06:50:34 <shapr> oh, that's good stuff
06:50:49 <shapr> have you read the thesis that Andres Löh wrote on Generic Haskell?
06:50:59 <shapr> I particularly liked the pictures.
06:51:18 <__stefan_h__> yes, the lambdas are great! :)
06:51:30 <bourbaki> how can you edit the colours for the highligting of the emacs haskell font lock?
06:51:47 <__stefan_h__> I have to admit I haven't read all 300+ pages yet ... but I've got the big picture anyway
06:51:56 <shapr> bourbaki: there are a variety of options, color-theme being the most common
06:52:08 <__stefan_h__> (Andres is supervising my Master's thesis project)
06:52:14 <shapr> ah, nifty
06:52:20 <bourbaki> color-theme whats that?
06:52:45 <shapr> http://www.emacswiki.org/cgi-bin/wiki/ColorTheme
06:53:51 <bourbaki> thanks
06:54:16 <shapr> __stefan_h__: what's your thesis project about?
06:54:44 <__stefan_h__> adding views to generic haskell
06:54:47 <shapr> oh
06:54:53 <shapr> nice pic
06:55:01 <__stefan_h__> :)
06:56:11 * RussellOConnor wonders what Template Haskell is.
06:57:00 <shapr> it's got the coolest logo of any Haskell project
06:57:18 <shapr> http://www.haskell.org/th/
06:57:49 <shapr> that logo entertains me on a regular basis.
06:59:28 <__stefan_h__> how do you guys value TH? I haven't worked with it myself too much, so ...
06:59:41 <RussellOConnor> I'm confused.  It looks like a poor substitution for dependant types.  I probably just have a bad attitude.
06:59:58 <shapr> dependant types have their own problems
07:00:06 <shapr> like, lack of modularity
07:00:23 <RussellOConnor> dependant types lack modulairty?
07:00:31 <bringert> TH is for example useful for generating interface code for external systems
07:00:55 <shapr> dependant types require a more monolithic approach to software
07:01:11 <Marvin--> I use TH as macros-on-steroids
07:01:26 <RussellOConnor> shapr> that doesn't seem obvious to me.
07:01:31 <bringert> or for deriving instances of your own classes
07:01:31 * shapr parrots a discussion he saw on lambda-the-ultimate.org between Frank Atannasow and some of the epigram guys ;-)
07:02:06 <shapr> TH r0xx0rs
07:02:37 <shapr> none of my meatspace friends want to hear about type theory :-/
07:02:49 <Lemmih> bringert: Got any tutorials/guide lines for that?
07:03:16 <shapr> RussellOConnor: I'll see if I can find that discussion
07:03:27 <kosmikus> I'd say that there's just not enough experience with dependently typed programming yet
07:03:42 <kosmikus> I hope that Epigram will make it into a language that can be used for more than just toy examples
07:03:50 <shapr> me too
07:03:55 <kosmikus> because that is needed to gain this experience
07:04:03 <shapr> epigram is the sexiest thing I've seen in a coupla years.
07:04:20 <bringert> Lemmih: deriving your own instances?
07:05:24 <kosmikus> RussellOConnor: TH provides access to the actual AST of your program, which gives you more pragmatic solutions to some problems from time to time than dependent types would
07:05:24 <Lemmih> Yes. Maybe I misunderstood you...
07:05:33 <bringert> don't think I have seen a tutorial or anyhting on that, but it was pretty easy once you know some TH
07:05:44 <bringert> there is an example in the XmlRpc package
07:05:57 <Lemmih> bringert: like: data MyType = MyType Int deriving (MyCLass)?
07:06:26 <bringert> I wish you could do it like that, but you can't do it exactly that way
07:06:33 <bringert> hold on, I'll dig up some code
07:06:46 <Marvin--> Lemmih: unfortunately not, but you can provide TH code that can be spliced into your program
07:07:00 <Marvin--> or whatever the correct terminology is, I'm unsure :)
07:07:05 <RussellOConnor> bah, pragmatic solutions. ;-)
07:07:16 <shapr> hiya bringert, how's code?
07:07:22 <bringert> Lemmih: this is what I do:
07:07:30 <bringert> data Person = Person { name :: String, age :: Int }
07:07:31 <kosmikus> RussellOConnor: I sort of agree with you there ;)
07:07:36 <bringert> $(asXmlRpcStruct (reifyDecl Person))
07:07:57 <bringert> where asXmlRpcStruct generates an instance declaration
07:08:13 <RussellOConnor> Dependant types will let you do what TH does, but at runtime as well.  Or at least that's the impression I get.
07:08:21 <Si\> If you're doing inheritance via type-classes (w/o phantom types) and storing the super-type as an attribute, what is the best way of building constructors?
07:08:23 <bringert> hi shapr
07:08:38 <bringert> got the applet to parse danish
07:08:49 <shapr> yay!
07:08:53 <RussellOConnor> Not that I know how to implement Dependant Types.  Nor do I know how to implement Haskell to begin with.
07:09:03 <shapr> SPJ's book is nice
07:09:08 <bringert> shapr: how's yours?
07:09:20 <kosmikus> RussellOConnor: sure, they let you do the same things, but the way you have to do them is still different
07:09:25 <shapr> I've been hacking on lambdabot and haskell-libs
07:09:33 <RussellOConnor> Oh
07:10:10 <RussellOConnor> ``$(asXmlRpcStruct (reifyDecl Person))''  I don't know what this does, but I suspect that dependant types won't do whatever it is.
07:11:09 <bringert> reifyDecl Person gives you a haskell representation of the declaration of the Person type
07:11:37 <bringert> asXmlRpcStruct takes such a representation and produces some abstract haskell syntax for an instance declaration
07:12:07 <bringert> $(...) inserts the haskell abstract syntax produced by ... into the program at that point
07:12:25 <bringert> i.e. stuff inside $(...) is evaluated at compile time
07:12:34 <RussellOConnor> Yeah, dependant types don't let you parse arbitrary types.
07:12:43 * RussellOConnor warms a little to TH.
07:12:55 <shapr> it's got such a great logo!
07:13:38 <bringert> you can also use it for things like domain specific compile-time optimizations
07:14:23 <bringert> see for example "Unrolling and Simplifying Expressions with Template Haskell"
07:14:28 <bringert> by Igloo
07:15:13 <bourbaki> whats TH?
07:15:19 <shapr> template haskell
07:15:21 <thebug> Template Haskell
07:15:26 <thebug> arr :)
07:15:27 <Lemmih> bourbaki: Template Haskell. www.haskell.org/th
07:15:39 <Marvin--> no no no, you're all wrong, it's Template Haskell
07:15:46 <Marvin--> </sarcasm>
07:15:50 <shapr> @arr !
07:15:50 <lambdabot> Drink up, me hearties
07:15:58 <thebug> yo ho
07:16:02 <shapr> @arr
07:16:03 <lambdabot> Shiver me timbers!
07:16:06 <shapr> @arr
07:16:06 <lambdabot> Get out of me way, yeh landlubber
07:16:41 <bourbaki> i really need to wrap the ogl stuff somehow to make it easier to use
07:17:06 <bourbaki> what does this line do? 		texName <- liftM head (genTextures 1)
07:17:12 <Lemmih> Where is reifyDecl defined?
07:23:54 <Marvin--> bourbaki: what do you mean?
07:24:56 <Marvin--> bourbaki: liftM f m = do x <- m ; return (f x)
07:25:05 <Lemmih> bourbaki: It generates a list of textures and takes the first one (since it only created one).
07:25:36 <bourbaki> hm
07:25:48 <Lemmih> Is there a nice infix operator for liftM?
07:26:02 <shapr> `liftM`
07:26:07 * shapr grins
07:26:34 <RussellOConnor> I don't feel that liftM should be infix.
07:26:50 <RussellOConnor> but that's just me.
07:27:37 <RussellOConnor> liftM is sort of only takes one parameter.
07:30:01 <Lemmih> I don't follow..
07:31:32 <RussellOConnor> liftM take an (a -> b) and returns a (m a -> m b).  At least that's how I think of it.
07:32:14 <RussellOConnor> liftM2 takes an (a -> b -> c) and returns a (m a -> m b -> m c)
07:32:35 <RussellOConnor> and liftM0 would take an (a) and return a (m a).
07:33:07 * Lemmih thinks of a TH liftMn.
07:33:24 <Marvin--> but the beauty of partial application is that you can think of liftM as *both*  (a -> b) -> m a -> m b  *and*  (a -> b) -> (m a -> m b)
07:34:00 * RussellOConnor thinks of the dependant type (forall n:Nat . liftM n)
07:35:46 <bourbaki> hm i cant import GL
07:36:31 <bringert> Lemmih: I don't think that reifyDecl is defined in the normal haskell sense
07:37:12 <bringert> I think it is a primitive, but I'm quite likely to be making this stuff up on the spot
07:37:24 <__stefan_h__> if you think of liftM as (a -> b) -> (m a -> m b), i.e., Marvin's second alternative, a infix synonym resembling ($) would make sense, I guess
07:39:33 <Marvin--> I think I've seen $$ used as a synonym for fmap sometimes
07:47:47 <Marvin--> SyntaxNinja: so, got any interesting feedback on cabal 0.1 yet?
07:59:00 <SyntaxNinja> Marvin--: got some patches from Krasimir for windows compatibility )
07:59:38 <Marvin--> SyntaxNinja: yeah I saw that
08:00:09 <Marvin--> SyntaxNinja: (checking what it did is what caused my whining on #darcs)
08:00:46 <SyntaxNinja> ahh
08:00:59 <SyntaxNinja> I think there's more that I haven't sent up yet.
08:02:21 <Marvin--> re the failing test case on splitExt, can't you simply do a splitFilenameDir before doing the extension splitting, and then join them back together?
08:03:56 <SyntaxNinja> I think that one's already fixed, but it's  big patch that I haven' tpushe dyet
08:03:58 <Marvin--> and shouldn't joinFilenameDir be defined in terms of pathJoin? (and is it really needed at all?)
08:04:19 <SyntaxNinja> he added a lot of stuff... I'm not clear about everything he did.
08:04:19 <Marvin--> SyntaxNinja: you do know that you can select which hunks you want to be part of a patch when recording, right? :P
08:04:52 <Marvin--> that's a feature I really like and that I really miss when working with subversion or cvs
08:06:07 <SyntaxNinja> yes, I know of that feature :)
08:06:32 <SyntaxNinja> I added the failing test case after getting his change of implementation of splitExt or whatever; 
08:06:54 <SyntaxNinja> my worry is that on windows these functions will actually sometimes wnat to behave as they do on Unix, and sometimes as they would on window
08:06:55 <SyntaxNinja> s
08:07:29 <SyntaxNinja> so for instance, if you're manipulating the path of something from the "main-is" field, then even if you're on windows, you want to treat the path as a unix path.
08:07:58 <bourbaki> hm these hopengl samples dont compile here :(
08:08:44 <Marvin--> I'm wondering if the parser should convert all the slashes into pathSeparator directly
08:09:02 <Marvin--> that is, parseFilePath should break up the string based on '/', and then call pathJoin
08:09:07 <SyntaxNinja> yeah, maybe.
08:09:30 <Marvin--> heh, that'd make the test suite tricky
08:09:48 <SyntaxNinja> the test suite for the parser?
08:09:51 <Marvin--> yes
08:10:45 <SyntaxNinja> hm. I like the solution otherwise.
08:11:44 <SyntaxNinja> OK I pushed krasimir's patches.
08:11:56 <SyntaxNinja> at worst, they'll break windows ;)
08:12:18 <SyntaxNinja> I'll CC you when I email him about this.
08:12:32 <Marvin--> actually, it wouldn't be so hard
08:13:12 <Marvin--> we'd just rewrite the testPkgDescAnswer to use pathJoin instead of slashes :-)
08:13:45 <SyntaxNinja> yeah
08:13:59 <Marvin--> I still think we should move a lot of stuff from D.Simple.Utils out of the D.Simple tree to a more generic D.FileUtils
08:14:16 <SyntaxNinja> that's fine by me; it's just that we don't really use them outside of Simple :)
08:18:54 <Marvin--> D.Make imports D.Simple.Utils
08:19:38 <SyntaxNinja> ahh
08:19:47 <Marvin--> true, it's just to get maybeExit
08:19:50 <Marvin--> but still :)
08:20:03 <SyntaxNinja> yeah, at the very least, anything that's used outside Simple should be moved out.
08:20:05 <Marvin--> and with my proposed change, D.Package would import it too
08:20:21 <SyntaxNinja> I'm working on OS.Path to orgnaize some of these functions in a meaningful way.
08:20:53 <SyntaxNinja> that wouldn't be the module's final name, btw, but that's Python's name for the module :)
08:21:36 <Marvin--> yeah I know
08:37:44 <Marvin--> SyntaxNinja: since it turns out I won't start working on Monday after all, I'm thinking I'll start thinking a bit on the Dist.Compiler.* refactoring
08:39:24 <SyntaxNinja> not starting work? is everything OK?
08:39:34 <barli> how to interpret this:
08:39:41 <barli> twice f a = f(f a)
08:39:43 <__stefan_h__> \away
08:40:00 <barli> twice :: (a -> a) -> a -> a
08:40:06 <__stefan_h__> apply f twice to a
08:40:25 <barli> what about the second part?
08:40:36 <__stefan_h__> you mean the type?
08:40:39 <barli> yes
08:41:18 <__stefan_h__> twice is a function that takes a function of type (a -> a) as its first parameter and a value of type a as its second; it produces a new value of type a
08:41:31 <SyntaxNinja> Marvin--: feel free to hack on the refactoring. 
08:42:05 <__stefan_h__> twice (+1) 2 --> (+1) (2 + 1) --> 2 + 1 + 1 --> 4
08:42:23 <barli> so you interpret every a as an argument to a function?
08:42:50 <RussellOConnor> x -> y -> z is the type for a (curried) function that takes two parameters.
08:43:01 <Marvin--> SyntaxNinja: yeah, everything's okay, the guy who's supposed to be my mentor is going on an urgent business trip to the US, and the few people who are not on vacation are going too, so the office will be empty during Mon-Wed
08:43:05 <RussellOConnor> in this case x is a function of type (a -> a), and y is of type a.
08:43:07 <__stefan_h__> nope ...  you interpret the first part, (a -> a) as a single parameter ... of function type
08:43:56 <barli> should i think of this notation in terms of currying or the more ordinary function argument view?
08:44:21 <Marvin--> SyntaxNinja: so I can't even get into the office :P
08:46:22 <__stefan_h__> whatever you like, I guess ... plustwo :: Int -> Int ; plustwo = twice (+1)
08:46:51 <RussellOConnor> You want to think of it as twice (a -> a) -> (a -> a), ie, twice takes a function as a parameter and returns a function as a result.
08:47:06 <RussellOConnor> twice f = f .  f
08:47:09 <RussellOConnor> :-)
08:47:16 <RussellOConnor> That's how I would write it.
08:47:29 <RussellOConnor> Oh wait, you are probably getting this from a tutorial?
08:47:34 <SyntaxNinja> Marvin--: heh
08:47:36 <RussellOConnor> Maybe I'm just confusing matters.
08:48:11 <__stefan_h__> RussellOConnor: That's what we're here for, aren't we: confusing matters ... ;)
08:48:38 * Marvin-- idly wonders if stefan_h(x) calls x.__stefan_h__()
08:49:15 <barli> this is how it was written by hugs. so i guess that's the offical way...
08:49:41 <__stefan_h__> \me wasn't liking it's nick too much anyway ... so what should I change it to?
08:49:53 <bourbaki> http://www.cin.ufpe.br/~haskell/hopengl/files/tex4color.zip can someone compile this source?
08:50:35 * __stefan_h__ seems to have a problem hitting the right slash today
08:50:53 <bourbaki> __stefan_h__ what about steve ;)?
08:51:05 <RussellOConnor> barli: okay.  In this case there are times that thinking of twice as a curried function is good and times with thinking of twice as a function of two parameters is good.
08:52:08 <__stefan_h__> bourbaki: mmm ... I have a feeling it should sound much cooler: perhaps something with 'thunder' in it :)
08:52:09 <bourbaki> is it by chanve possible that the tutorials on the site arent compilable anymore?
08:52:33 <bourbaki> __stefan_h__ heh ;) do you know stan from monkey island ?:)
08:52:50 <__stefan_h__> boubaki: yes, I do :)
08:53:20 <barli> yes, maybe there's more than one way to do it as they say...
08:53:36 <bourbaki> Igloo do you happen to know if the source on the site should be compilable?
08:55:55 <stefan_> (That'll do it for now. ;))
08:56:20 <bourbaki> heh
08:56:22 <Igloo> Which source on which site?
08:56:34 <bourbaki> Igloo http://www.cin.ufpe.br/~haskell/hopengl/files/tex4color.zip
08:56:46 <Igloo> No idea, never seen it before
08:58:59 <kosmikus> stefan_: you can always call yourself "kosmikus'apprentice" ;)
08:59:19 <bourbaki> hahaha
09:00:16 <stefan_> lol
09:02:12 * Lemmih wonders if there is a way to force xfree to release some memory.
09:02:46 <kosmikus> Lemmih: kill -KILL ...
09:03:06 <lelit> or Ctrl-Alt-Backspace
09:04:11 <Lemmih> ... without shutting it down.
09:05:36 <lelit> ah, no then the only way is not starting it up right from the beginning :)
09:06:38 <bringert> mmm, sun and beer
09:07:22 <RussellOConnor> I don't understand why all monads have a ``fail'' function.  Why doesn't failure to pattern match in a do structure just run error?
09:08:50 <Lemmih> Because to fail can mean other things than a fatal error.
09:10:00 <RussellOConnor> Why not just have an Error class as well?
09:10:04 <Lemmih> Checkout the Maybe and Either monad.
09:10:18 <Philippa> because then you end up making the do notation much more complicated
09:10:20 <kosmikus> yes, it could be in a separate class
09:10:48 <RussellOConnor> Why would the do notation be more complex?
09:10:49 <Marvin--> RussellOConnor: the default implementation of fail is error
09:10:57 <Philippa> because it'd have to be type-aware
09:11:14 <RussellOConnor> fail seem like a blemish on the beauty of the Monad.
09:11:34 <RussellOConnor> Philippa: I don't understand.
09:11:52 <kosmikus> I never considered monads beautiful
09:11:56 <Marvin--> eh? How so? One of the features of Monad is that it propagates errors
09:11:58 <Philippa> It'd have to know whether a monad was a member of Error or not
09:12:02 <Lemmih> 'fail' is very important in some monads.
09:12:19 <Philippa> like, uh, most of the ones that aren't just state transformers in disguise
09:13:13 <kosmikus> but still, fail has nothing to do with monads theoretically
09:13:21 <Philippa> sure
09:14:10 <Philippa> it's just another operation ala get and put, that Haskell happens to require on all of them
09:14:35 <RussellOConnor> I would just have do notation call error when there is a failure to pattern match.  Why should do be more special than case?
09:15:09 <Lemmih> eh?
09:15:32 <Philippa> Because failure to pattern match could be something you can recover from
09:15:40 <Marvin--> it's a feature, not a bug :-)
09:15:41 <RussellOConnor> If Foo needs to be both a Monad and support fail, let it implement two classes.
09:15:43 <Philippa> and the do notation doesn't let you supply more than one pattern
09:16:20 <Philippa> these aren't "case" patterns, they're "let" patterns
09:16:30 <RussellOConnor> you can't recover from pattern matching in lambdas.
09:16:53 <Philippa> because under pure functional semantics it doesn't make sense to try
09:17:00 <RussellOConnor> oh, I suppose you can't recover in let bindings either.
09:17:11 <RussellOConnor> Oh
09:17:20 <RussellOConnor> that's an interesting observation.
09:17:27 <kosmikus> the advantage with monads is that you have a relatively clear idea about when the pattern matching is performed
09:17:33 <Philippa> whereas under other semantics it can make sense, and monads are used to embed other sets of semantics in Haskell
09:17:39 <Philippa> (specifically, higher-order ones)
09:18:29 <RussellOConnor> I'm almost convinced; however monads are just an abstract data type.  Order of evaluation isn't forced.
09:18:46 <RussellOConnor> notwithstanding it being a ADT to sequence computation.
09:19:12 <Philippa> to rephrase: you *can* have a relatively clear idea as to when the pattern matching is performed
09:19:20 <Philippa> you may do so, you may not
09:20:01 <Philippa> also, "just" a more generic concept tends to be a misleading thought
09:20:07 <Philippa> monads are "just" a subset of arrows...
09:20:48 <Philippa> only they have a particular property that doesn't apply to arrows generally that's necessary for eg the IO monad to work
09:21:01 <RussellOConnor> My point is that monads are not necessarily evaluated in the order given in the do notation.  Like the list monad.
09:21:24 <Philippa> Sure
09:21:47 <Marvin--> and in the list monad it makes sense for pattern match failure to give empty lists, like the fail function does
09:22:19 <Philippa> but that doesn't stop there being a meaningful notion of "recovery from pattern match failure" in the list monad, because the value of fail is the zero of concatenation
09:22:33 <RussellOConnor> fail for lists return the empty list!
09:23:24 <RussellOConnor> I'm unsure how I feel about that.
09:23:28 <Philippa> Right. A representation of "no possible result"
09:23:41 <Marvin--> RussellOConnor: yes
09:24:04 <Philippa> the point of the list monad being that it keeps a list of all possible results
09:24:04 <RussellOConnor> @info MonadPlus
09:24:40 <RussellOConnor> @help
09:24:40 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
09:24:43 <Marvin--> Prelude> [ x | Just x <- [Just 3, Nothing, Just 5, Just 6] ] :: [Int]
09:24:43 <Marvin--> [3,5,6]
09:24:43 <Marvin--> Prelude> do Just x <- [Just 3, Nothing, Just 5, Just 6]; return x :: [Int]
09:24:43 <Marvin--> [3,5,6]
09:24:56 <Marvin--> RussellOConnor: see the similarity?
09:25:36 <Marvin--> fail s = [] is integral for the list monad
09:26:36 <RussellOConnor> Well, it only makes sense because lists are a memeber of MonadPlus.
09:26:43 <Marvin--> in fact, there used to be an extension that had "monad comprehensions", where  [ ... | ... ] was translated to a monadic expression rather than a list expression, but it was reverted because the error messages were confusing for newbies
09:27:42 <ustenzel> Hm, what is the relationship between fail and mzero?
09:27:51 <Philippa> RussellOConnor: In this case, yes. In another case the monad in question may enforce a strict evaluation order
09:27:55 <RussellOConnor> fail _ = mzero
09:29:20 <Philippa> not inherantly
09:29:24 <RussellOConnor> I'm still unconvinced.  However I'm starting to beleive that fail is at least not harmful.
09:29:34 <bourbaki> Igloo wont it be possible to pack all the samples in one pak and place them on the site?
09:29:59 <kosmikus> Marvin--: I wouldn't call it integral for the list monad; I'd never write above code and even consider it bad style
09:31:18 <ustenzel> kosmikus: catMaybes ms = [ x | Just x <- ms ]
09:31:44 <ustenzel> kosmikus: quite compact and clear, a style I sometimes like.
09:35:46 <RussellOConnor> catMaybes ms = ms >>= Maybe.maybeToList
09:35:50 <RussellOConnor> I think that is more clear
09:36:15 <Marvin--> kosmikus: list-monad-as-nondeterminism is really useful and can make code a lot clearer
09:36:33 <RussellOConnor> and has better form
09:36:44 <kosmikus> Marvin--: oh yes, I'm only referring to the use of pattern matching
09:37:47 <ustenzel> RussellOConnor: okay, now repeat with Either and extract the Rights.
09:40:14 <RussellOConnor> foo ms = ms >>= (either (const []) (\x -> [x]))
09:40:29 <RussellOConnor> Is there something better than \x-> [x]
09:40:36 <Marvin--> RussellOConnor: return ;)
09:40:43 <RussellOConnor> great
09:41:04 <RussellOConnor> foo ms = ms >>= (either (const mzero) return)
09:41:32 <Marvin--> so... you object to list comprehensions in general? How novel
09:41:38 <RussellOConnor> a piece of beauty. *l*
09:41:49 <ustenzel> RussellOConnor: it *does* start getting ugly.  (though i like it somehow.)
09:42:19 <RussellOConnor> Marvin--: No, I'm with kosmikus.  I only have a problem with pattern matching on types with more than 1 constructor.
09:42:19 <Marvin--> I find  ms >>= either (const mzero) return  thoroughly obfuscated compared to  [ x | Right x <- ms ]
09:42:38 <ustenzel> foo = (>>= either fail return)
09:43:07 <ustenzel> Ha! fail *is* useful after all!
09:43:18 <RussellOConnor> Marvin--: I guess you are sort of right.  But it is a little unclear what happen when the pattern match fails.
09:44:00 <RussellOConnor> unstenzel: fail has the wrong type no?
09:44:16 <ustenzel> dammit, you're right.  needs a string.
09:44:44 <Marvin--> just think of list comprehensions as combining the functionality of map and filter
09:45:08 <kosmikus> Marvin--: they do that without pattern matching trickery
09:45:41 <kosmikus> Marvin--: with, they can do more
09:46:21 * stepcut puts the amb in lambda
09:47:25 <goron> Marvin--, and concat...
09:48:51 <kosmikus> goron: sure
09:49:46 <Philippa> RussellOConnor: the only reason it's unclear is you could run it through another monad with a similar signiature
09:50:37 <Philippa> in List's case there's even a potential application: Suppose all the "choices" are associated with probabilities, List gives you the entire probability space, another monad could just pick one possibility randomly
09:50:48 <Marvin--> ustenzel: either fail return is a function that translates an "Either monad" to any monad, sounds pretty useful to me :)
09:56:07 <ustenzel> Marvin--: almost.  as RussellOConnor said, is has to be a "Either String" monad.
09:57:01 <Marvin--> ustenzel: yes, but that's the typical Either monad
09:57:12 <Philippa> do it with classes - "Either String" does the obvious, "Either a" throws away the a
09:59:00 <Marvin--> using MonadError you'd have  either throwError return :: MonadError e m => Either e a -> m a
09:59:04 <ustenzel> I like to have more strutured errors.  The habit to encode everything as a String better suits Perl than Haskell.
10:00:07 <Marvin--> yes, while I don't consider the presence of the fail function a wart, the actual interface with a String as argument, otoh, is
10:06:03 <Philippa> yeah, no argument there
10:17:11 <RussellOConnor> I think I can accept pattern matches failing in list comprehension, but I'm still not sure about general do notation.
10:18:08 <Lemmih> Yay.
10:18:31 <Philippa> RussellOConnor: you'd rather the only pattern allowed were a single variable?
10:18:36 <Philippa> that's the only alternative
10:20:29 <RussellOConnor> Pattern match only if there is one constructor for the type.
10:21:01 <Philippa> point. Pretty pathetic "pattern matching" though, and somewhat crippling
10:21:30 <Philippa> at the moment, Maybe and related monads effectively catch pattern match errors for you - you can use them as a match failure exception
10:21:42 <RussellOConnor> Well case expression and function declarations are fine as they are.
10:21:58 <Philippa> given that the type system isn't perfect, it's a great way to handle situations where you /should/ only be handed data meeting certain preconditions
10:22:01 <Philippa> they can fail too
10:22:25 <RussellOConnor> Philippa: Perhaps you are right.
10:24:12 <RussellOConnor> The Maybe monad can only catch pattern match failures inside do notation.  But maybe the point is that this is better than nothing.
10:33:27 <Philippa> the do notation only does it by shoving _ -> fail "whatever" on the bottom of the pattern
10:56:52 <boubaki> hi
10:57:09 <boubaki> does anyone of you use ghc in cygwin?
11:33:53 <boubaki> what version of HOpenGL is delivered with the latest ghc verion in windoze?
11:35:30 <stepcut> boubaki: do you know about the difference between the HOpenGL tarballs and what is currently shipped with the compiler?
11:35:47 <boubaki> stepcut i try to figure it out
11:35:54 <boubaki> i guess the version :)
11:36:09 <boubaki> cause the prob is that i cant compile the newest examples
11:36:38 <stepcut> the stuff on this page:
11:36:39 <stepcut> the HOpenGL 1.05 stuff is 
11:36:41 <stepcut> oops
11:36:45 <stepcut> http://www.haskell.org/HOpenGL/releases.html
11:37:17 <boubaki> yes and the one in ghc that is shipped with the latest windows selfinstaller?
11:37:19 <stepcut> that stuff is obsolete. The stuff in the fptool cvs tree is a rewrite of HOpenGL and is not backwards compatible
11:37:39 <boubaki> :) i know it took me nearly all day to figure that out ;)
11:38:00 <stepcut> I suspect the one in the lastest windows installer is built from CVS, so you can only use the examples/documentation from CVS
11:38:00 <boubaki> but i cant compile HOpenGL 1.05 without greencard and i cant compile the latter :(
11:38:27 <stepcut> You really want the new OpenGL stuff anyway, it is much better
11:38:33 <boubaki> yes
11:38:43 <boubaki> ive seen the examples look very clean
11:38:57 <boubaki> but do you happen to know how to compile green card in cygwin?
11:39:01 <stepcut> nope
11:39:05 <boubaki> dang
11:39:24 <boubaki> maybe i will switch to debian then again for some time
11:40:04 <boubaki> damn i am so close to the perpixel lighting for the landscape :) and now i have to install stuff again :(
11:40:10 <stepcut> installing ghc+opengl is indeed trivial to install in debian
11:40:20 <thebug> hehe apt-get is your friend
11:40:30 <boubaki> yep i know i just need to book it then
11:40:34 <boubaki> erm boot
11:40:50 <stepcut> apt-get and Ian Lynagh
11:41:04 <stepcut> (the debian ghc6 packager)
11:41:04 <thebug> definitely
11:41:11 <boubaki> i quit to play nwn though anyway :)
11:41:12 <thebug> <aka Igloo >
11:41:45 <stepcut> though, I have built ghc from source, and it was no more complicated than ./configure ; make ; make install, so that is nice too :)
11:41:54 <boubaki> i wonder why there are so few opengl stuff written in haskell
11:41:59 <thebug> stepcut: ah, but you did it on a -supported- platform :)
11:42:04 <thebug> try doing that on IRIX sometime
11:42:44 <boubaki> cause imho its cool to have 3d algorithms written like in haskell
11:42:49 <stepcut> thebug: true :)
11:42:53 <boubaki> makes the stuff a lot more obvious
11:44:44 <thebug> @yow
11:44:44 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
11:44:58 <boubaki> heh
11:45:08 <RussellOConnor> @list-commands
11:45:08 <lambdabot> Sorry, I don't know the command "list-commands", try "lambdabot: @listcommands
11:45:12 <RussellOConnor> @listcommands
11:45:13 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
11:45:13 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
11:45:13 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
11:45:13 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
11:45:13 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
11:45:13 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
11:45:15 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
11:45:17 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
11:45:19 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
11:45:36 <thebug> uh you may want to /msg lambdabot for that one next time :)
11:45:46 <RussellOConnor> okay
11:47:59 <boubaki> RussellOConnor would you be able to maybe help me to develop an intersection algorithm for a ray and the bicubic landscape thing?
11:48:34 <RussellOConnor> bourbaki: I wrote that for my computer graphics project.
11:49:03 <boubaki> what cg project :)?
11:49:15 <RussellOConnor> for my CG course at university.
11:49:44 <boubaki> ah fine once i have that new version of gl running in haskell i can do some per pixel lighting on the landscape
11:50:04 <boubaki> i have finished anything yesterday but the intersection thing :)
11:50:11 <RussellOConnor> However if the word ``resultant'' scares you, you should probably stick to triangulation or subdivision.
11:50:40 <RussellOConnor> Actually if the word ``slow'' scares you, you should probably stick to triangulation or subdivision.
11:50:48 <boubaki> :)
11:50:58 <boubaki> i have an orthogonal grid
11:51:22 <boubaki> so i think its possible to speed the algorithm up
11:51:45 <RussellOConnor> my teapot: http://math.berkeley.edu/~roconnor/cs488/sample.png
11:52:07 <boubaki> id like to have that thing for a dynamic visible cell algo
11:52:39 <boubaki> nice :) have you seen some of the shots of the engine i have been working on?
11:52:48 <RussellOConnor> nope
11:53:06 <boubaki> http://www.nvidia.com/object/games_codecult.html
11:53:11 <RussellOConnor> the teapot is made up of bi-cubic patches, as ususal.
11:53:21 <boubaki> that is a demo we wrote for nvida
11:53:29 <RussellOConnor> oooooh
11:53:38 <RussellOConnor> I think you used hardware. ;-)
11:54:01 <boubaki> i have finished an algo yesterday that projects the landscapes normals into a 2d plane aka texture
11:54:18 <boubaki> heh yep we used the hw at that time to the max
11:54:54 <boubaki> i really like the way you can write 3d stuff in haskell
11:57:07 <RussellOConnor> So the algorithm is described in ``Ray Tracing Parametric Patches'' Computer Graphics Volume 16, Number 3, July 1982
11:57:29 <RussellOConnor> All the equations in the paper are wrong, so I used Maple to be sure to get them right.
11:59:00 <RussellOConnor> The paper used a root solver based on Laguerre's method.  I recommend instead using one that is based on Higher Order Bezier curves.
11:59:24 <RussellOConnor> And once again, I recommend using subdivision and ignoring all this.
11:59:33 <RussellOConnor> ;)
12:00:24 <boubaki> heh
12:00:34 <stefan_> hey
12:01:34 <boubaki> hi
12:02:01 <boubaki> RussellOConnor well the thing is id like to solve it with the homotopy thing cause i can reuse that for anything
12:02:58 <boubaki> i already thought about metaballs with hopotopies
12:03:09 <jadrian> hello
12:03:18 <RussellOConnor> Well, this only works for polynomail patches.  And even then it probably only really works with bicubic patches.
12:03:57 <jadrian> got a question about recursive datatypes
12:03:58 <RussellOConnor> intersecting a ray with an arbitrary parametric function is really very difficult.
12:04:08 <RussellOConnor> jadrain: go ahead.
12:04:28 <boubaki> the thing i would have to solve is : linear_interpolation(l) = patch(project_xy(linear_interpolation(l))
12:04:38 <stefan_> jadrian: go ahead
12:04:41 <jadrian> single parameterized recursive datatypes can easily be made instances of the Functor class
12:05:06 <jadrian> the interpretation of Function in this setting seems simple
12:05:14 <stefan_> yes, you will need to define a fmap functions, which is very well behaved
12:05:51 <jadrian> We are working in only one Category where the types are Objects and functions are Morphisms
12:06:47 <jadrian> Ok now, sometimes there is a similar pattern
12:07:12 <jadrian> for instance substitutions on Terms
12:07:13 <stefan_> yes, the type constructor and the fmap function together form the functor, categorically
12:07:21 <jadrian> yeap exactly stefan_ 
12:07:38 <jadrian> now if I define a Type Term in the usuall way
12:08:12 <stefan_> depends on what you regard usual ;)
12:08:33 <jadrian> I was trying to put that in a few words and I'm missing the enlish term lol
12:08:41 <jadrian> T(Sigma, X)
12:08:53 <jadrian> where X is the variable set and Sigma a signature...
12:08:58 <jadrian> ou do you call this?
12:09:37 <stefan_> still digesting ... what do you want to be named, exactly?
12:10:38 <jadrian> well it's just
12:11:14 <ne1> What is T(Sigma, X) then?
12:11:57 <jadrian> elements of X are terms
12:12:14 <jadrian> and for every f in Sigma, and t1...tn terms
12:12:24 <jadrian> f(t1,...,tn) are also terms...
12:12:34 <jadrian> (I didn't mention cardinality but you get the picture)
12:12:46 <jadrian> So you have variables as leafs
12:13:13 <jadrian> also constants as leafs (functions of arity 0)
12:13:31 <jadrian> and non-constant functions in the other nodes...
12:13:33 <jadrian> was that clear?
12:13:40 <ne1> Yes.
12:14:10 <jadrian> I was trying to remember the name while typing this... probably the Sigma Algebra generated over X?
12:14:34 <ne1> Yes precisely
12:14:50 <jadrian> pheeeew good, I hate when I forget this stuff :)
12:14:52 <ne1> Usually with a hyphen between Sigma and algebra.
12:14:58 <jadrian> thanks :)
12:15:05 <jadrian> ok anyway, when declaring such a datatype there may be no need to parameterize it
12:15:46 <jadrian> in that case it cannot be made an instance of class functor
12:16:09 <jadrian> Now I may want to define stuff like substitutions
12:16:27 <jadrian> substitutions are very close to a mapping
12:17:52 <jadrian> now do you usually deal with this situations?
12:18:01 <jadrian> for instance, 
12:18:27 <jadrian> I'm just using Ints for the leaves
12:18:37 <jadrian> leafs
12:19:18 <jadrian> so I cannot even state something like
12:20:00 <jadrian> generalize a function  f: X -> T(f,X)   to   f' : T(f,X) -> T(f,X)
12:20:08 <jadrian> because I have no type X
12:20:44 <jadrian> I could use a:  newtype Var = Var Int
12:20:53 <jadrian> but it kind of seems overkill
12:21:20 <jadrian> because then I'd need to have    data Term = ... | Var' Var
12:21:50 <jadrian> now I am not being clear enough am I?
12:23:18 <jadrian> I guess the question is:- how do you deal with mapings in non-polymorphic recursive data types
12:23:41 <jadrian> is there a standard strategy?
12:24:17 <ne1> Two alternatives.
12:24:31 <stefan_> I'm not sure what you want to substitute ... the integers you use for Var in your structures?
12:24:56 <ne1> 1. Why not parameterize the Term type?  You can always instantiate it with Int afterwards.
12:25:21 <jadrian> stefan_: leafs (vars) for terms
12:25:40 <stefan_> okay
12:25:43 <boubaki> can someone help me with the last line in that file here ? http://rafb.net/paste/results/kw0KOx48.html
12:26:00 <ne1> 2. If I am given "data IntList = Nil | Cons Int IntList", I won't bother hacking it into the Functor type class.
12:27:05 <stefan_> no, you'd staightforwardly define a function mapTerm :: (Int -> Int) -> IntList -> IntList
12:28:12 <stefan_> however, it seems to make sense to parameterize the Term type with the Var type, because choosing integers to represent your leaf elements is just a implementation choice here, I guess
12:29:03 <jadrian> I was wondering though, if there was a more general approach to it
12:29:45 <jadrian> that is, is this alos some common pattern in category theory?
12:30:30 <ne1> Suppose I am given this open-ended task: input a list of numbers, output a corresponding list of booleans, indicating which numbers are odd.
12:30:40 <ne1> There are two ways I can do this.
12:31:21 <stefan_> boubaki, this one? [[map (uncurry pi) (x,y) | x <- xs] | y <- ys]
12:31:32 <stefan_> boubaki: what's the problem?
12:31:38 <ne1> 1. data IntList = INil | ICons Int IntList; data BoolList = BNil | BCons Bool BoolList; solution :: IntList -> BoolList; ...
12:33:09 <ne1> 2. data [a] = [] | a : [a]; solution :: [Int] -> [Bool]; solution = map (not.even); map :: (a->b) -> [a] -> [b]; map = ...
12:33:27 <arjanb> boubaki: something like this:  map (\x -> map (pi x) ys) xs ?
12:33:32 <ne1> Which of the two choices I make depends just on how much I am paid.
12:34:32 <stefan_> :)
12:34:37 <jadrian> ok...
12:35:00 <jadrian> about the 1. yeap, simple, can do it...
12:35:21 <jadrian> but that may mean rewriting some patterns over and over
12:35:25 <jadrian> now 2...
12:35:42 <boubaki> [[(uncurry pi) (x,y) | x <- xs] | y <- ys] thats what i do now
12:37:11 <jadrian> Guess I just don't like parameterizing it over one of the leafs to be able to use map on it
12:37:28 <stefan_> jadrian, the point is that 1. is just a very specific instance of the general pattern in 2.; why would you bother deriving specific instances over and over again if you could do with the simple generalization?
12:37:29 <jadrian> (one of the kinds of leafs)
12:39:19 <jadrian> I had onethr thing in mind...
12:39:23 <jadrian> another
12:39:40 <jadrian> do you think multi-parameter classeswould be nonsense in this case?
12:39:49 <RussellOConnor> FWIW, http://www.swiss.ai.mit.edu/users/dae/notes/monads-algebra
12:39:53 <RussellOConnor> A monad for Terms.
12:40:08 <jadrian> Thanks RussellOConnor!
12:41:31 <jadrian> instead of making Term a parameterized datatype, I could define a multiparameter class that took as parameters the Terms and Vars datatypes
12:42:34 <jadrian> would also use functional dependencies since for each Term there is only a Var type
12:43:17 <jadrian> I was thinking about that since it could be generalized for every Term datatype and wouldn't need it to be parameterized over the vars
12:44:13 <jadrian> also it wouldn't make me choose a map instance over vars (since I actually have other leafs in my datatype and it may make sense to also map them)
12:45:54 <jadrian> RussellOConnor: reading your link
12:46:32 <RussellOConnor> jadrian: I don't know if it is relevent.  The discussion just reminded me of it.
12:48:06 <stefan_> the boilerplate approach (http://www.cs.vu.nl/boilerplate/) gives you, amongst others, a design pattern for dealing with transformations and substitutions like this
12:52:51 <jadrian> stefan_: yeap, that might be a good way to put it too
12:53:34 <stefan_> boubaki, I'd write  map ((`map` ys) . f) xs  but arjanb's alternative reads better, I guess
12:54:08 <jadrian> stefan_: *might* :)
12:54:32 <jadrian> got to learn more about generics...
12:54:53 <jadrian> but yes it might be a good way to generalize it.
12:55:12 <stefan_> if t is a term and f :: Int -> Int, you could just write everywhere (mkT f) t to carry out the subsitution
12:55:58 <jadrian> yes stefan_ I was just looking forward to generalize this pattern to any possible definition of "Term"
12:56:27 <jadrian> and if use some categorical concept to do it, if one existed
12:58:32 <stefan_> jadrian, ok, just one more link then: http://homepages.cwi.nl/~ralf/just-two/
12:58:35 <jadrian> I was wondering about your opinion on using multiparameter classes like I said
12:59:48 <goron> You don't have permission to access /~ralf/just-two/paper.pdf on this server.
13:01:10 <stefan_> it seems feasable, although you could perhaps do with two separate type classes too a la the boilerplate stuff: your term type fits into ... well ... the Term class, while your var type would have to be an instance of Typeable to go with the everywhere stuff
13:01:42 <jadrian> yeap seems like there is no permission :)
13:01:49 <jadrian> class SigAlgOver  t x | t => x where     -- <
13:02:55 <stefan_> goron, jadrian: http://www.arxiv.org/pdf/cs.PL/0212048
13:03:00 <jadrian> stefan_: yeap the boilerplate stuff migh be a way to do it, but I need to spend some time reading it to really understand what you're saying :)
13:03:20 <goron> stefan_, got it
13:04:01 <stefan_> okay, I think it might be worthwile to read the first paper
13:04:17 <jadrian> yeap I'll do it
13:04:23 <jadrian> thank you all for all the tips
13:04:33 <stefan_> you're welcome
13:05:29 <jadrian> need to go, I'll take a look at all those links
13:05:32 <jadrian> thanks again
13:42:12 <stepcut> is there a simple haskell interpreter written in haskell anywhere ?
13:42:23 <stepcut> something like helium, but in haskell
13:43:22 <Lemmih> GHCi isn't working or do you understand the source?
13:43:37 <Lemmih> *you wanna
13:45:09 <stepcut> ghci seems like overkill, I just wanted to add a more haskell-like @eval mode to lambdabot
13:46:10 <Lemmih> Why not use Hugs?
13:46:12 <Igloo> You could make hugs callable by the FFI if no-one has already. The issues are security and limiting the amoutn of time it'll spend trying to evaluate something, though
13:46:46 <Lemmih> stepcut: mod_haskell already made the interfacing code iirc.
13:46:58 <stepcut> Igloo: exactly! That's why I wondered if there was something simple. Something I could easy tweak to be secure and controllable
13:48:28 <Igloo> safe-{hugs,ghci,...} would be a useful step towards a good modhaskell, too
13:59:28 <stepcut> Language.Haskell.Parser is pretty sweet
14:00:37 <stepcut> I am tempted to make a trivial haskell interpreter based on 'Implementing Functional Languages: a tutorial'
14:08:12 <boubaki> hi irsirius
14:10:30 <boubaki> hm the fungen site hasnt been updated in quite a while
14:12:33 <boubaki> sf doesnt list haskell in the programming language category :)
14:14:40 <Riastradh> Wow.  There's a Simula project on SourceForge.
14:14:52 <Riastradh> And _thirteen_ APL projects.
14:17:45 <palomer> hullo, what's new in haskell world?
15:33:48 <Lemmih> palomer: Me on a Windows box with GHC is kinda new.
15:38:14 <Lemmih> But I still can't understand why the notebook interface isn't similar to MDI frames.
15:52:55 <monochrom> I hate MDI frames.
16:38:36 <bourbaki> can someone help me with my code? try to run it that is http://rafb.net/paste/results/DpSDOq52.html
16:39:26 <bourbaki> there seems to be some problem with a list but i can call all the functions that use them
16:41:20 <bourbaki> line 173 is the critical line
16:41:55 <bourbaki> but i can run the last past of it in the shell and it returns a correct list without that list error
18:08:13 <clausen> oi tautologico
18:08:21 <tautologico> oi
18:12:57 <tautologico> fala portugues ?
18:13:12 <stepcut> oi no falu portugues
18:13:13 <clausen> +-
18:13:25 <clausen> faz tempo que falei portugues
18:13:28 <tautologico> clausen, where did you learn ?
18:13:31 <clausen> brasil
18:13:35 <clausen> e irc :)
18:13:48 <tautologico> clausen, cool, I'm from brasil
18:13:56 <clausen> percebi :)
18:14:13 <clausen> brasil mata a pau... quero voltar :)
18:14:14 <tautologico> é, claro, meu dominio e tudo
18:14:33 <tautologico> ah, sabe falar bem, entende até as gírias :)
18:15:01 <tautologico> engraçado, eu sempre tive vontade de ir à Austrália
18:18:48 <clausen> :)
18:44:32 <clausen> tenho que desconectar a rede
18:44:34 <clausen> t+
