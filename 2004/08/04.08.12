03:12:01 <musasabi> Does Wash cope with ~20 concurrent users?
03:13:33 <musasabi> Or should I just use php/mod_perl or something similar yucky?
04:06:45 <basti_> hi
04:11:09 <musasabi> hello
04:11:30 <stefan_> basti, hi
04:12:13 <basti_> hi stefan_
04:55:47 <shapr> yow!
05:05:15 <bringert> @arr
05:05:16 <lambdabot> Yeh scurvy dog...
05:09:15 <shapr> hej bringert, wassup?
05:10:50 <shapr> does anyone here know if disabling the LBA jumper on my drive will increase linux' efficiency by giving the actual drive geometry rather than the imaginary geometry?
05:11:27 <basti_> shapr i would think this is rather not probable.
05:11:35 <shapr> hm, ok
05:12:09 <basti_> the translation done is rather trivial and hard-wired anyways... much quicker than any software would ever do
05:12:34 <basti_> the driver doesnt care much too... 
05:17:21 * shapr wibbles
05:25:24 <shapr> what's going on?
05:25:35 * basti_ looks around
05:25:36 <basti_> nothing.
05:26:31 <shapr> ok then
05:29:54 <shapr> hiya kimmell 
05:30:12 <Lemmih> shapr: I'm still wondering why wxHaskell is broken on Windows...
05:30:26 <shapr> I don't know. I also don't have a copy of windows handy.
05:30:38 <shapr> even so, I would like to know that wxHaskell works on win32.
05:40:56 <Philippa_> shapr: the current binary distribution off their site works fine
05:41:08 <shapr> well, that's good to hear.
05:41:19 <Philippa_> not tried building the current version from source - wasn't fun last time I had to
05:44:34 * shapr bounces cheerfully
06:06:22 <Lemmih> Philippa_: It's only some parts which are broken/buggy.
07:20:12 <SyntaxNinja> do you guys think the debian package name for wash-utils should be wash-common?
07:22:32 <Igloo> What's in it?
07:22:36 <basti_|> re
07:22:39 <basti_|> ß"$(
07:22:59 * Igloo blinks
07:23:21 <Igloo> I think there should be a good reason if you're going to stray from what it's cabal package name is/will be
07:23:30 <Igloo> s/it's/its/
07:24:54 <Igloo> Did you get my e-mail, BTW?
07:25:41 * Igloo 's brain catches up with basti - hi  :-)
07:26:26 * basti_ 's image gets fuzzy, doubles and regains an sharpness
07:33:07 <SyntaxNinja> Igloo: yeah, I got your email.
07:33:12 <SyntaxNinja> and that's my next task...
07:33:27 <SyntaxNinja> what's in it? some crap that's used by the other wash libraries :)
07:34:03 <Igloo> But is it a library or binaries?
07:34:06 <SyntaxNinja> library
07:34:31 <Igloo> libghc6-wash-utils-dev then, surely?
07:34:53 <SyntaxNinja> that's fine. I just felt there might be a debian standard that takes precedence.
07:35:17 * Igloo idly wonders what we do if a Haskell guy decides to make a foo-dev version of his foo library that we want to package
07:35:37 <SyntaxNinja> that's what the militia is for.
07:35:44 <Igloo> -common isn't generally used in that way, and even if it was I think mirroring the Haskell names would be more important IMO
07:35:48 <Igloo> :-)
07:35:56 <SyntaxNinja> fine. that's the way I have it now, so that's good :)
07:36:14 <Igloo> heh
07:36:48 <Igloo> In a bizarre twist of fate it seems that mips and m68k are going to be the 2 arches that /don't/ cause trouble with the new ghc6 upload
07:41:54 <SyntaxNinja> hm
07:41:58 <SyntaxNinja> that is bizarre.
07:42:34 <Riastradh> How many GHC users _use_ those two architectures?
07:42:52 <Riastradh> My guess would be...oh, about three or so.
07:45:16 <Igloo> I dunno, but I do know there are at least 2 alpha users. Yeah baby!  :-)
08:06:03 <SamB> that is bizarre
08:32:35 <goron> There were people talking about Debian packages for wxHaskell, is there some news about it?
08:41:55 <goron> lambdabot: wxhaskell
08:41:56 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:47:26 <thebug> goron: lambdabot isn't a blootbot
08:47:48 <thebug> yay MIPS!
08:49:20 <SyntaxNinja> goron: I'm making debian packages for wxhaskell. tweaking it now and working with upstream to iron out all the little problems.
08:49:25 <SyntaxNinja> but the packages themselves are rather passible.
08:50:12 <Marvin--> SyntaxNinja: did you fix the bug in the postinst?
08:50:40 <Marvin--> there was a missing semicolon before the 'then':s in some haskell-utils triggers
08:51:21 <SyntaxNinja> Marvin--: no, I didn't see that one.
08:51:36 <SyntaxNinja> Marvin--: do you have a diff?
08:52:38 <Marvin--> SyntaxNinja: no, but it should be easy to see...
08:55:00 <Marvin--> SyntaxNinja: and did you see my comment about how the .diff.gz is fucked up?
08:55:10 <SyntaxNinja> I did see that one.
08:56:15 <Igloo> The haskell-utils triggers should have disappeared
08:56:24 <Marvin--> they should?
08:56:28 <Igloo> Is that what the ghc6 problem was? That's good news
08:56:48 <Igloo> Yes - with the way packages.conf is now handled I believe they aren't necessary (please tell me if I'm wrong!)
08:57:04 <Marvin--> I don't know, what's changed?
08:57:22 <Marvin--> so... haskell-utils triggers aren't needed?
08:57:51 <Marvin--> +        haskell-utils --add-untrigger wxhg GHC "if [ \$(\"%p\" --numeric-version) = @GHCVER@ ] then \$(\"%p\" --print-libdir)/bin/ghc-pkg -r wxcore"
08:57:51 <Marvin--> +        haskell-utils --add-untrigger wxhg GHC "if [ \$(\"%p\" --numeric-version) = @GHCVER@ ] then \$(\"%p\" --print-libdir)/bin/ghc-pkg -r wx"
08:57:59 <Igloo> igloo@userpc15-unstable:~$ dpkg -L ghc6 | grep package.conf
08:57:59 <Igloo> /usr/lib/ghc-6.2.1/package.conf.shipped
08:57:59 <Igloo> igloo@userpc15-unstable:~$ grep package.conf /var/lib/dpkg/info/ghc6.postinst 
08:57:59 <Igloo>         if [ ! -e $libdir/package.conf ]
08:57:59 <Igloo>             cp $libdir/package.conf.shipped $libdir/package.conf
08:58:02 <Marvin--> SyntaxNinja: there should be semicolons before the 'then' on both lines
08:58:37 <Igloo> I believe that means libraries depending on ghc6 can just ghc-pkg -u themselves on uninstall and -r on remove and have it all work out
08:58:46 <Marvin--> Igloo: ummm... and if one of the packages that comes with ghc has changed?
08:58:46 <Igloo> And be maintained across ghc6 upgrades
08:59:10 <Igloo> That can't happen anyway - it violates the way the dependencies work in the haskell-policy
08:59:52 <Marvin--> I'm talking about bugfixes like "whoops, there should be an extra flag here" and stuff
09:00:15 <Igloo> I can hack around that in postinst if need-be
09:01:41 <Igloo> But I'm working on the assumption such bugs will be rare, and rarer as libraries move out to separate packages
09:01:55 <Marvin--> sure
09:02:13 <Igloo> I don't think it would have been an issue in all the time I've maintained the package
09:02:30 <Marvin--> I'm just trying to cover all bases :)
09:03:11 <Igloo> *nod*
09:03:21 <Igloo> I think (hope  :-)  ) this way is simpler overall
09:03:49 <Marvin--> oh yes, the haskell-utils triggers are hideous
09:04:07 <Marvin--> the basic problem is that ghc-pkg has no concept of *ghc* upgrades
09:07:03 <kosmikus> oh, I'm tired even before AFP has started ;)
09:07:46 <Marvin--> heh
09:08:32 <arauko> anyone recommends a good online book to learn haskell?
09:09:10 <shapr> there's Hal Daume's 'Yet Another Haskell Tutorial'
09:09:26 <Riastradh> @seen hdaume
09:09:27 <lambdabot> I haven't seen hdaume
09:09:51 <shapr> it's been a few months since he's been here.
09:09:57 <Riastradh> Indeed.
09:11:27 <Marvin--> Igloo: I mean, if there was a smart way to merge two package.conf files into one, it wouldn't really be a problem, would it?
09:12:03 <Igloo> If one has flags=[] and the other flags=["-foo"], what does the merged one have?
09:12:14 <Marvin--> that's why I said "if" ;-)
09:12:41 <Marvin--> actually, couldn't you just split up the new package.conf into packages and run ghc-pkg -u on each of the fragments?
09:12:48 <Igloo> Ah, I thought you meant if a tool existed
09:12:59 <Igloo> How does that help?
09:13:17 <Igloo> Oh, I see, you're assuming the user doesn't change things deliberately
09:13:21 <Igloo> Which they /ought/ not
09:13:45 <Igloo> Anyway, that's only an issue if it changes, right? So I can ignore it unless it becomes an issue.
09:13:48 <Marvin--> we don't give any guarantees about preserving user changes outside /etc
09:14:06 <Marvin--> if they want to make local changes they should use dpkg-divert
09:14:15 <Marvin--> but yes, it's only an issue if it changes
09:14:45 <arauko> The Haskell language has evolved significantly since its birth in 1987
09:14:52 <arauko> didnt know it was so new 
09:15:42 <SyntaxNinja> goron: you can play with these packages, no promises, though. there are a couple of known problems: http://www.syntaxpolice.org/tmp/wxhaskell/
09:17:18 <Igloo> dpkg-divert wouldn't help them in this case as the postinst wouldn't honour it
09:17:56 <Marvin--> Igloo: then the postinst is broken :-)
09:18:03 <Marvin--> actually, no
09:18:20 <Marvin--> since package.conf isn't part of a package it's a whole lot trickier
09:18:51 <Igloo> Even if it was, it's not standard practice for postinsts to query dpkg-divert before fiddling with their files  :-)
09:20:05 <Marvin--> it isn't? eww
09:20:29 <Marvin--> dumpPkgGuts :: PackageConfig -> Doc
09:20:32 <Marvin--> heh, funny name
09:20:36 <Igloo> Well, I've never heard of it being done
09:20:47 <Igloo> I could just be misinformed
09:21:07 <Igloo> s/mis/un/
09:25:46 <Marvin--> all right, so which version of the ghc6 package should you depend on to get the new, improved package.conf handling that doesn't need haskell-utils?
09:26:41 <shapr> dons: you around?
09:26:49 * shapr is having problems with the hs-plugins demos
09:28:49 <shapr> hm, makeWith isn't rebuilding changed sources.
09:32:01 <Marvin--> Igloo: possibly that could be good to mention in haskell-policy?
09:33:55 <Igloo> 6.2.1-5   I think haskell-policy will need to talk about getting deps and builddeps right, and haskell-utils will provide a script to mangle builddeps (AFAIK you can't do that at build time)
09:35:08 <Marvin--> dh_haskell! :-)
09:36:58 <Hobbes> hello
09:37:08 <shapr> greetings Hobbes 
09:37:16 <shapr> how do you like Haskell so far?
09:37:17 <Hobbes> can anyone tell me what is wrong with this type declaration... 	type Bag = [(a,Int)]
09:37:32 <Hobbes> its..... 
09:37:32 <shapr> have you tried using newtype?
09:37:32 <Igloo> type Bag a = [(a, Int)]
09:37:37 <shapr> doh
09:37:37 <Hobbes> how can i put this nicely
09:37:42 <shapr> different?
09:37:46 <Hobbes> yes
09:37:48 <Hobbes> different
09:37:56 <Hobbes> VERY different
09:38:03 <Igloo> And preferably without a tab at the start of it
09:38:04 <shapr> how would you put it not nicely?
09:38:22 <Philippa> yeah, tabs in Haskell are a very, very bad idea what with the layout rule...
09:38:38 <shapr> I was frustrated when I started with Haskell, but I knew it was better than what I already knew then.
09:38:58 <Hobbes> i get the feeling that if i knew what i was doing then it would be great
09:39:01 <Igloo> And especially at the start of a type decl line  :-)
09:39:14 <shapr> yah, it's powerful stuff once you get a handle on it
09:39:21 <Marvin--> tabs are fine as long as you ONLY use tabs, and always start the layout blocks on a new line
09:39:23 <shapr> like drinking from the fountain of knowledge or something
09:39:41 <Marvin--> Igloo: you don't *have* to start your lines in column 1 :)
09:41:07 <shapr> Hobbes: one neat thing I've learned is that Haskell is just 'really high quality paper' on which to write ideas.
09:41:18 <Igloo> Indeed, sanity is not a prerequisite for writing Haskell code  :-)
09:41:54 <shapr> Some things are easier to write and/or read/understand in Haskell.
09:42:12 <Marvin--> as long as you start all the lines in the same column, ghc won't argue
09:42:20 <shapr> for example, once you understand the basics, you should check out some of Mark Jones' papers.
09:45:16 <Hobbes> i keep getting undefined type variable "a"
09:45:31 <Marvin--> Hobbes: Igloo gave you the answer
09:45:41 <Marvin--> Hobbes: you need to parameterize the type
09:45:43 <shapr> Hobbes: http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:45:46 <shapr> hiya maihem 
09:46:15 <Hobbes> duh....never noticed that extra a!
09:46:17 <Hobbes> thanks
09:46:30 <shapr> hej spenatmannen 
09:46:36 <spenatmannen> hej
09:46:42 <shapr> wazzup?
09:46:48 <maihem> hello
09:47:27 <Hobbes> my lecturer sucks so much
09:56:45 <arauko> ?
09:57:01 <shapr> Hobbes: happily, you have us! and we're lots more fun than any lecturer!
09:58:19 <Smerdyakov> Oh, I wouldn't say that.
09:58:46 <shapr> I would.
09:59:24 * arauko has found people in irc that know more than his univ. professors 
09:59:26 <Smerdyakov> Then it's clear that you've not met many lecturers.
09:59:47 <shapr> It's clear that you have no idea ;-)
10:00:11 <Smerdyakov> I've had a number of extremely "fun" lecturers.
10:00:29 <shapr> I haven't.
10:00:34 <shapr> I have had a lot of lecturers though.
10:01:02 <shapr> The fun lecturers I did know were in stuff like neuro-optical medical research.
10:01:02 <Smerdyakov> How many were also researchers?
10:01:14 <flaw> I don't think lectures arent supposed to be fun..
10:01:25 <Smerdyakov> Yeah, see, if they just teach, they can get down in the dumps from all those annoying students.
10:01:32 <Smerdyakov> If they do research, too, they can keep upbeat. :)
10:01:38 <maihem> Smerdyakov: Is that the "Trying to hard to fit in" fun, or the "interesting anecdotes that have nothing to do with the subject but somehow you understand the subject better because of them" fun?
10:01:58 <Smerdyakov> maihem, the "genuinely funny; could have a stand-up comedy routine" fun.
10:02:17 <shapr> From what I've seen, comedy pays more than teaching.
10:02:27 <flaw> feh, that's not a lecture. that's a bit.
10:02:31 <maihem> I had one of those, taught C.
10:02:47 <Smerdyakov> flaw, OK, Mr. Spartan!
10:02:56 <shapr> of course, comedy pays more than programming in most cases.
10:03:09 <Marvin--> spartans? where?
10:03:14 * Marvin-- looks out for trojan horses
10:03:17 <Smerdyakov> In university, most programming _is_ comedy.
10:03:29 <shapr> sad but true
10:04:14 <maihem> Most memorable quote - when asked what "#include <stdio.h>", "int main (void) {",and  "return 0; }" do, "They make you program work"
10:04:41 <Marvin--> maihem: and it's true!
10:04:48 <Marvin--> "it's funny because it's true"
10:37:21 <shapr> dons: you think that makeWith could be called many times a second and still be okay?
10:42:48 <Hobbes> if two objects are null do they equate to being equal?
10:43:22 <shapr> equality in Haskell is defined by the Eq typeclass
10:43:30 <shapr> identity doesn't happen in Haskell
10:43:52 <Smerdyakov> Hobbes, there is no concept of "null" in Haskell.
10:44:10 <Riastradh> Smerdyakov, uh, yes, there is.
10:44:15 <Hobbes> ok let me rephrase that..if i have two null lists and i test them for equality will it return true
10:44:18 <Riastradh> null []  -- evaluates to True
10:44:19 <Smerdyakov> Riastradh, what is it?
10:44:21 <shapr> yes, it will
10:44:23 <Riastradh> I.e. the null list.
10:44:28 <Hobbes> thank you
10:44:32 <shapr> [] == [] will be true
10:44:42 <Smerdyakov> Riastradh, oh, there's a function 'null'. But the empty list is called '[]'. *shrug*
10:44:51 <Riastradh> Smerdyakov, also known as the null list.
10:44:52 <shapr> Hobbes: you can also try that interactively in hugs or ghci
10:44:57 <flaw> 0 list
10:44:59 <Riastradh> Or, more succinctly, 'null.'
10:45:10 <Smerdyakov> Riastradh, I have never heard it called "the null list."
10:45:22 <Hobbes> our lecturer calls it the null list
10:45:30 <Hobbes> but hes a retard
10:45:30 <Smerdyakov> Riastradh, and if someone calls it that, it's a bad idea, because of the different meaning "null" has in more popular languages.
10:45:34 <Riastradh> Smerdyakov, any Lisper will call it 'tthe null list' or 'null.'
10:45:39 <Riastradh> The, even.
10:45:41 <Smerdyakov> Riastradh, this is not the Lisp world.
10:45:59 <Riastradh> Nor is it the world of those popular languages.
10:46:08 <flaw> null is german for zero.. I doubt a "null list" in haskell is meant to be equivalent to SQL's NULL..
10:46:09 <flaw> yes?
10:46:38 <shapr> well, I do use the SQL NULL in HaskellDB...
10:46:57 <shapr> not like that's very helpful :-)
10:47:00 <flaw> hehe
10:49:38 <flaw> I've heard that SQL's NULL is meant to be a "unknown value".. I can't help but feel it's a bit misnamed.. A better name being unknown.. :P
10:49:39 <emu> lispers don't call it the null list, they call it nil
10:53:21 <Riastradh> As a noun, yes, emu; more precisely, 'null' is an adjective.
10:56:43 <emu> is +RTS -M<n> a GHC option?
10:57:05 <emu> because darcs is suggesting it, since i blew the heap
10:57:29 <Igloo> Put it at the end of the darcs command line
10:57:47 <emu> still 'bad'
10:58:24 <Igloo> I thought it defaulted to unlimited, actually
11:00:45 <emu> Heap exhausted;
11:00:45 <emu> Current maximum heap size is 268435456 bytes (256 Mb);
11:05:01 <Lemmih> I'm so annoyed. I still haven't found a workaround to fix list controls in wxHaskell /-:
11:05:10 <emu> $ darcs get <repo> +RTS -M512
11:05:13 <emu> like that?
11:16:52 <arauko> im surprised... i thought haskell was older ....
11:17:23 <emu> that's what they all say
11:18:02 <emu> "But your Honor, I thought Haskell was older"
11:18:03 <arauko> well yeah, people always talk about functional languages as old stuff
11:21:27 <arauko> where is installed the hugs binary?
11:21:35 <arauko> i just do make && make install 
11:21:44 <arauko> but.. mm.. 
11:28:37 <monochrom> functional programming and oop are equally old.
11:29:36 <Lor> Hm. Who invented functional programming?
11:29:52 <monochrom> However, the ACM Turing Award for inventing of fp was almost four decades older than that for inventing oop. :)
11:30:18 <monochrom> John McCarthy.
11:30:25 <monochrom> No, Backus.
11:30:30 <arauko> Lor, as far as i know Alonzo Church implemented the bases for it 
11:32:00 <Lor> That's what I mean. It was invented in bits and pieces, so it's hard to credit it to any single person, or give any particular date for its inception.
11:32:37 <Lor> Church didn't do any _practical_ stuff with the lambda-calculus, and McCarthy didn't do really _functional_ things in the beginning...
11:32:43 <arauko> well the first computing language was IPL 
11:47:20 <shapr> @yow randomness!
11:47:21 <lambdabot> Yow!  We're going to a new disco!
11:48:14 <shapr> I'd be happy to give credit to SPJ et al for making Haskell usable.
11:48:34 * shapr discovers that ftp.se.debian.org is having update problems
11:50:37 <Marvin--> is it just me or has Keean misunderstood why some people want to use closed classes? [-cafe discussions]
11:51:42 <Philippa> closed classes seem like a substitute for subtyping to me, BICBW. Inextensible subtyping certainly has its uses
11:52:13 <shapr> hm, unicycling or coding?
11:52:22 <Marvin--> unicoding!
11:52:46 <Igloo> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6+ghc5+nhc98+hugs+darcs&show_installed=on&want_percent=on&beenhere=1 might interest people
11:53:24 <Marvin--> Igloo: is that %? cool, I'd expect it to be lower
11:54:10 * Marvin-- is ashamed to admit he doesn't run popcon
11:54:35 * shapr runs popcon
11:54:47 <Igloo> Yup - I even labelled my axes like my teachers taught me to  :-)
11:55:01 <Igloo> I was a bit depressed at first until I remembered to multiply by 100
11:55:07 * shapr hacks his axes
11:55:25 <shapr> how many submitters?
11:55:41 <Marvin--> Igloo: haha
11:55:51 * Igloo gives Marvin a popcon-running glare  :-)
11:55:52 <arauko> hello
11:55:54 <arauko> is there any way to use Hugs with emacs?
11:56:00 <shapr> yes, there is
11:56:03 <Igloo> 6000 or so ATM I think
11:56:05 <shapr> but I'd suggest GHCi
11:56:35 <shapr> are there any mirror stats available?
11:56:36 <Marvin--> I mean, ~160 installations of hugs and ~120 installations of ghc6, that ain't bad
11:56:37 <arauko> shapr, why?.. and how do i do it?
11:56:49 <Igloo> Does DI suggest popcon to people, Marvin?
11:57:17 <Marvin--> Igloo: I'm pretty sure that base-config does
11:57:22 <shapr> arauko: GHCi is generally spiffier, and M-x turn-on-haskell-ghci
11:57:32 <shapr> yah, popcon is in the base install nowadays
11:57:40 * Igloo suspects our percentages will drop soon then
11:57:43 <Marvin--> Igloo: have you missed the debate of default configuration of MTAs on -devel?
11:57:50 <shapr> Marvin--: oh, nice review of debian installer rc1 on lwn.net, and also it works nicely for me.
11:58:08 * Marvin-- tries to remember his lwn.net password :)
11:58:31 <Marvin--> or is it old enough that I won't need my password?
11:58:33 <Igloo> Oh, I knew it was about popcon but didn't infer that meant popcon was installed by default, nor did I read the thread closely
11:58:35 <shapr> not yet
11:58:40 <shapr> one or two days old I think
11:59:17 <shapr> arauko: hugs is a Haskell interpreter written in C, it's great for low-memory situations like the Sharp Zaurus
11:59:43 <shapr> GHC is a compiler with some interactive ability. It generates fast executables, and has support for a lot more cool stuff.
11:59:47 <Marvin--> hmm, you're talking about the review on linux.com that they linked, right? I could access that and the comments without logging in
12:00:00 <shapr> and I think GHCi gives better error messages than Hugs nowadays.
12:00:05 <shapr> Marvin--: no, there's a real review on lwn.net
12:00:33 <Marvin--> oh
12:01:15 <shapr> no wait, maybe not
12:01:34 <Igloo> Anyone got a URL handy if it's free?
12:01:35 * shapr is now confused
12:01:43 <shapr> I swear I saw a different review on lwn.net
12:01:46 <arauko> shapr, ooh cool, ill try that
12:02:55 <shapr> arauko: also, I wrote some HaskellMode stuff here: http://www.haskell.org/hawiki/HaskellMode
12:04:09 <Marvin--> oh look, PSM remembered my password, yay
12:04:14 <shapr> yay
12:04:44 <arauko> shapr, ok, i check 
12:05:26 <shapr> ah, it's on the front page of the latest lwn.net issue, "Our brief tests of the RC1 of the Debian installer were quite positive."
12:06:16 <shapr> anyway, I'll be testing d-i RC1 with two of my friends here in Boden in the next week or so
12:06:30 <shapr> They said they'd try Linux if I'd install it for them.
12:06:55 <Marvin--> then let them install it and let them ask for help if they need it
12:07:35 <shapr> Yah, I'm going to tell them they're helping the open source effort by letting me report bugs or ideas to my friend who's part of d-i
12:07:52 <shapr> hi Nathell 
12:07:55 <Nathell> hello
12:08:02 <shapr> looking for exciting programming alternatives?
12:08:10 <Marvin--> shapr: I'm not into d-i development these days
12:08:13 <shapr> oh, ok
12:08:14 <Nathell> actually, I have a Haskell question :)
12:08:25 <shapr> excellent, what is it?
12:08:27 <Hobbes> whats everyones favourite linux distro by the way?
12:08:33 <shapr> I use Debian.
12:08:40 <shapr> debian/unstable even
12:08:44 <Marvin--> the intense debcamp in Oslo kinda burnt me out, and then I was too busy with h2fol
12:09:02 <Marvin--> I use Debian unstable too
12:09:02 <Nathell> is there a shorter way of writing case foo of { bar -> blah; baz -> blah } ?
12:09:14 <shapr> Nathell: take out the braces?
12:09:20 <Nathell> so that the 'blah' wouldn't have to be given two times
12:09:32 <shapr> oh, use otherwise =
12:09:35 <shapr> which is the same as True =
12:09:59 <Lor> Uh, that's in guards, not in case expressions.
12:10:00 <shapr> or you could use guards maybe
12:10:13 <arauko> To use the software in-place, now run:
12:10:13 <arauko>         make in-place
12:10:13 <shapr> ok, what about _ -> blah
12:10:14 <shapr> ?
12:10:17 <arauko> what it means?
12:10:31 <shapr> arauko: means type that at the shell prompt "make in-place"
12:10:32 <Lor> ocaml has simple or-patterns.
12:10:44 <arauko> shapr, hah, i know .. but what it will do....
12:10:50 <shapr> I have simple not-patterns
12:10:56 <shapr> I will NOT do Java...
12:10:59 <shapr> I will NOT do Perl...
12:11:06 * shapr gives up on that poor attempt at humor
12:11:14 <shapr> Lor: hey, what do you think of makeWith in hs-plugins?
12:11:18 <Nathell> shapr: what if there are more blah's?
12:11:21 <shapr> arauko: what are you building?
12:11:22 <Lor> shapr, what about it?
12:11:34 <arauko> shapr, well.. im gonna install the GHC binaries 
12:11:41 <shapr> I wanted to hear your opinion on that approach to type-safety.
12:11:46 <arauko> Configuration done, ready to either 'make install'
12:11:46 <arauko> or 'make in-place'.
12:11:51 <Lemmih> Nathell: case foo of something -> notBlah; _ -> blah
12:11:57 <arauko> i want to install .... 
12:11:59 <shapr> I'd suggest make install most likely.
12:12:05 <arauko> ah ok...
12:12:07 <shapr> which linux ditro are you using?
12:12:14 <shapr> distro
12:12:15 <arauko> thanks, i have no idea what make in-place is 
12:12:17 <shapr> feh, I can't type
12:12:18 <arauko> LFS
12:12:22 <shapr> oh I see
12:12:31 <shapr> yes, make install will install a system-wide copy of GHC
12:12:36 <arauko> cool
12:12:37 <arauko> thanks
12:12:43 <shapr> make in-place will build GHC only in the downloaded source
12:12:46 <shapr> and leave the binary there
12:12:47 <Lor> shapr, I don't see how it guarantees safety. It _can_ be safe, when used appropriately, but that is true of any language.
12:13:00 <Nathell> ok, thanks :)
12:13:02 <arauko> shapr, aah get it...
12:13:04 <shapr> well, it's better than Dynamics by themselves...
12:13:17 <Nathell> (re distro: I use Slackware, btw)
12:14:22 <shapr> Lor: maybe dependently typed languages can give better safety guarantees and still allow separate compilation?
12:15:10 <shapr> hm, I wonder if dependent types make separate compilation significantly more difficult.
12:15:47 <Smerdyakov> I don't think dependent types make anything but type inference significantly more difficult.
12:16:01 <Lor> It all depends on what the types depend on... :)
12:16:16 <Smerdyakov> What safety guarantees are we talking about here?
12:16:22 <shapr> time for unicycling, bbl
12:16:33 <Lor> Anyway, I've pretty much written my thesis and said enough about the subject for a while now.
12:16:41 <arauko> shapr, i dont have such a thing as M-x turn-on-haskell-ghci
12:16:49 <Lor> So I no longer feel a horrible urge to preach about this matter. :)
12:16:50 <shapr> have you loaded haskell-mode ?
12:17:05 <shapr> Lor: I'm still interested in the subject, is your thesis in english?
12:17:12 <Lor> Yeah.
12:17:14 <Smerdyakov> Lor, what's the thesis?
12:17:15 <shapr> whew
12:17:27 <shapr> my finnish isn't even up to food shopping anymore...
12:17:39 <shapr> is your thesis available online?
12:17:40 <arauko> shapr, how do i do that?
12:18:06 <shapr> arauko: download haskell-mode, put it into your load-path, then load it.
12:18:20 <shapr> it may be as simple as M-x load-library haskell-mode
12:19:20 <arauko> oh yeah, let me look for it
12:19:39 * shapr wobbles away on one wheel
12:20:18 * Smerdyakov pokes Lor!
12:22:08 <Lemmih> Is it possible to use paths with spaces when loading a module in ghci?
12:22:12 <Smerdyakov> Lor, will you apply for a faculty position here at Berkeley?
12:22:37 <Lor> I can't claim that to have been my foremost thought. :)
12:23:10 <Smerdyakov> Well, consider this a heads-up that we are hiring multiple PL people in the near future. ;)
12:24:30 <Smerdyakov> Would you normally be looking for a job soon in the standard procedure of your country?
12:24:40 <arauko> shapr, this one = http://home.arachsys.com/~chris/haskell-ghci.el ?
12:25:11 <Lor> I'm looking for an industry job at the moment. Got to make a living after an eternity of school.
12:25:26 <Lor> I may well be employed next week already. :)
12:25:33 <Smerdyakov> Lor, you can make quite a good living as an American professor of CS. I don't know how it is in Europe.
12:25:49 <Smerdyakov> Lor, starting salaries counting grant money tend to be over $100k/year, I think.
12:26:02 <Lor> The mind boggles.
12:26:31 <Smerdyakov> Is the situation in Europe very different?
12:27:03 <Lor> In europe an academic job is pretty much a... "kutsumusammatti", something you do because you believe in it, not because it makes you much money.
12:27:21 <Smerdyakov> CS professors in the USA get rich from the Military Industrial Complex.
12:27:30 <Lor> Well, at least in the nordic countries, where education is free and all the pay comes from the government.
12:27:35 <Smerdyakov> Also, MS Research and IBM Research start people at $130k/year or similar.
12:28:09 <jao> (sadly, it's the same in south countries)
12:28:25 <Smerdyakov> I learned this from a recent discussion with some people who just finished the post-PhD job search.
12:28:44 <Smerdyakov> Lor, you are finishing the PhD, right, or is it something else?
12:29:50 <Lor> No, I'm not even a grad student yet (although technically I do have all the required studies except for a PhD thesis).
12:30:19 <Smerdyakov> Oh, my mistake. I thought that _was_ a PhD thesis.
12:30:34 <Smerdyakov> IN THAT CASE: Retract previous statements; instead, apply to Berkeley as a PhD student!! :D
12:32:08 <SamB> Smerdyakov: is that why college is getting to be so expensive here?
12:32:35 <Smerdyakov> SamB, not really. Professor salaries tend to be low, but they augment it with government grants and consulting.
12:32:52 <Lor> Well, I have some qualms about being involved with the US at the moment.
12:33:03 <SamB> Lor: me too
12:33:22 <Lor> Which PL folks reside in berkeley at the moment? I can only recall Alex Aiken from the top of my head?
12:33:40 <SamB> unfortunately for me, I live here
12:33:51 <Smerdyakov> Lor, here's how I see it: If I can get the US Department of Defense to pay me to develop useful (and peaceful!) software, then I've saved the money from being used for military purposes.
12:34:02 <Lor> Point. :)
12:34:07 <Smerdyakov> Lor, George Necula; Rastislav Bodik; David Wagner
12:34:20 <Lor> Ah, Necula.
12:34:36 <Smerdyakov> Lor, we have some people who were faculty members in the 1970's who are close to retirement and do very old-school research, so I don't bother to list them. :)
12:35:21 <Smerdyakov> Lor, and, like I said before, we're hiring, and there's a good chance we'll grab some excellent PL people in the next few years.
12:36:12 <Smerdyakov> The atmosphere is very different than in Europe, though.
12:36:25 <Smerdyakov> No one who describes his main research area as "functional programming" has a chance of being hired.
12:36:32 <Lor> The faculty has made some explicit policy decision: "hey, let's get good at PL stuff" ?
12:36:57 <Smerdyakov> No. PL faculty members have made the explicit decisions to retire or move to other schools. :)
12:37:38 <Lor> Ah, but at least someone feels that this needs to be remedied?
12:38:04 <Smerdyakov> Sure. Every area tries to at least maintain its head count.
12:38:06 <Lor> You see, hereabouts in Helsinki there is absolutely no interest in any of this stuff.
12:38:27 <Lor> There used to be some work on compilers in early 80's, but even that has gotten out of fashion in here.
12:39:14 <Smerdyakov> I encourage you to think of coming to the USA for grad school in this way: Hardly anyone in universities agrees with the government. We are more like subject peoples than conspirators to wreck the world.
12:39:15 <Lor> I am hoping to be able to do at least some teaching next year to fix these glaring omissions.
12:39:40 <Lor> Yes, I understand that. :)
12:39:59 <Smerdyakov> So there's no great difference from going to school in Europe, in that respect.
12:40:26 <Smerdyakov> The big difference is that grad students in technical fields are treated lavishly in the USA.
12:42:04 <Lor> If I ever go to the US, I'd prefer to go study under someone like Harper or Felleisen...
12:42:35 <Smerdyakov> Yeah, much closer match with that thesis.... but less grant money available for that stuff, so you have stiffer competition.
12:43:14 <Marvin--> how much time do you typically have to spend on hunting grant money?
12:44:55 <Smerdyakov> Professors spend a lot. They hire people whose only job is to manage grants.
12:45:06 <Smerdyakov> Grad students generally don't need to worry.
12:45:14 <Smerdyakov> They match up with advisors who determine how to divide up grant funds.
12:46:18 <irsirius> hello
12:46:41 <irsirius> can anybody tell me if theres a way to compile haskell to java bytecode?
12:46:55 <Marvin--> Smerdyakov: so, being a grad student == good, being a professor == bad? :)
12:47:12 <Smerdyakov> Marvin--, it's a trade off. :)
12:47:17 <Marvin--> I bet
12:47:28 <Smerdyakov> Being a grad student is definitely good, though!
12:47:52 <Marvin--> I've heard Koen complain about how he had much more time for research when he was a grad student, now it's all meetings, meetings, meetings ;)
12:47:53 <Lor> Hm, in US you don't have Licentiate degrees?
12:48:08 <ibid> licentiates are pretty uncommon afaik
12:48:11 <ibid> worldwide
12:48:25 <Smerdyakov> Lor, never heard of it.
12:48:29 <Marvin--> my dad got a licentiate degree in logic and theoretical philosophy this summer
12:48:56 <ibid> Smerdyakov: it's a phd lite or msc on steroids, depending :)
12:49:14 <Marvin--> heh, that's one way of putting it
12:49:15 <Smerdyakov> ibid, hey, YOU should apply for a faculty position here! :D
12:49:21 <ibid> Smerdyakov: oh?
12:49:26 <Smerdyakov> ibid, yup yup!
12:49:33 <Marvin--> whoa
12:49:44 <ibid> Smerdyakov: how come?
12:49:49 <Smerdyakov> ibid, if I remember correctly, you have a PhD or are close, right?
12:49:55 <Marvin--> I thought I had a can of weak salsa, so I put more chili in it... I just noticed it was a can of hot salsa
12:50:07 <Marvin--> now it's hot++ salsa
12:50:08 <ibid> Smerdyakov: no
12:50:15 <Smerdyakov> ibid, oh :(
12:50:18 <ibid> Smerdyakov: working on it, but not that close :)
12:50:25 <Smerdyakov> ibid, well, apply when you're close. :)
12:50:40 <ibid> aren't you in the usa?
12:50:51 <Smerdyakov> ibid, if you expect to be finished by the start of 2006, you should apply. :)
12:50:57 <Smerdyakov> ibid, I am.
12:51:04 <Lor> I had a talk with the head of department recently, and he said that I really can't do a PhD on PL stuff in here, since there is no one who would be qualified as an advisor. :)
12:51:09 <ibid> i have no intention of entering that country in the foreseeable future
12:51:26 <ibid> Lor: come here, they aren't that picky here :)
12:51:31 <Smerdyakov> ibid, you get a skewed view from the outside....
12:51:33 <ibid> of course, your hod has a point
12:51:39 <ibid> Smerdyakov: it scares me still
12:51:59 <Smerdyakov> A university is practically a sovereign nation, anyway. :P
12:52:12 <Lor> Hereabouts the government is doing its best to change that.
12:52:28 <ibid> Lor: oh?
12:52:30 <Smerdyakov> California, too, is practically a sovereign nation. :D
12:52:34 <ibid> :)
12:52:54 <Smerdyakov> So you get 2 layers of protection!
12:53:01 <Lor> Well, universities cannot _own_ anything, except for Helsinki which is an exception, kind of.
12:53:17 <Smerdyakov> Universities are allowed to own Helsinki?
12:53:21 <ibid> Lor: that's actually something that the government might want to change
12:53:26 <monochrom> Hahha
12:53:44 <ibid> Smerdyakov: university of helsinki has certain special powers for hysterical raisins
12:54:16 <ibid> such as the right to have its chancellor sit in any cabinet meetings that discuss stuff related to finnish universities
12:54:33 <ibid> (no such right for the other universities)
12:54:51 <Lor> He's also allowed to speak, not just sit. :)
12:55:01 <Smerdyakov> California state universities have the right to have their budgets cut. :(
12:55:02 <ibid> true
12:55:44 <ibid> Smerdyakov: finnish universities get a bulk of their bugdet based on how many degrees they promise to award (not on the actual numer, mind you:)
12:56:00 <ibid> which is silly in many ways
12:56:31 <Lor> Hum. Maybe I should write a short summary of my thesis to sigplan notices. It's a pretty nice venue for "I haven't got any scientific results but here's something that might interest you" -stuff..
12:56:43 <ibid> do that
12:56:52 <ibid> oh, btw, sorry for not reading the draft...
12:57:26 <Lor> You can still do it. I probably won't return it until next week. :)
12:57:30 <ibid> :)
12:57:40 <ibid> i'm too busy, unfortunately
12:57:59 <ibid> i'm trying to rush in lecture notes for my course
13:14:43 <arauko> can anyone help me to start a ghci process in emacs?
13:20:42 <arauko> after typing , M-x haskell-mode , M-x turn-on-haskell-ghci 
13:20:49 <arauko> C-c C-s doesnt do anything 
13:33:23 <arauko> anyone?
13:45:20 <arauko> shapr, you there?
14:00:02 <barli> can someone explain why this works: foldr  (:) [] [1,2,3,4,5]
14:00:25 <barli> but this does not: foldl  (:) [] [1,2,3,4,5]
14:01:08 <Lor> Because foldl gives the arguments in a different order to the function.
14:01:23 <Lor> try (flip (:)) instead of (:)
14:01:55 <barli> ok. but why doesn't foldl work?
14:02:51 <sorrow> does it probably append the [] on the wrong side of the list?
14:06:44 <Marvin--> barli: what do you mean "doesn't work"?
14:06:51 <Igloo> foldl :: (a -> b -> a) -> a -> [b] -> a. The "a -> [b] -> a" must be "[Int] -> [Int] -> [Int]" for what you want, so a = [Int], b = Int. So (:) must have type [Int] -> Int -> [Int], but it is only allowed types of the form c -> [d] -> [d]
14:07:08 <barli> there is an error
14:07:14 <Igloo> So you need to flip the arguments round, which is what flip does
14:08:09 <barli> i'm not trying to make it work. just trying to understan whats going on.
14:08:20 <Marvin--> barli: then compare the types of foldr and foldl
14:08:25 <Marvin--> @type foldr
14:08:27 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
14:08:28 <Marvin--> @type foldl
14:08:30 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
14:08:50 <Marvin--> @type (:)
14:08:52 <lambdabot> (:) :: forall a. a -> [a] -> [a]
14:08:56 <barli> what are you using?
14:09:06 * Marvin-- pats lambdabot
14:09:31 <Marvin--> barli: you can also use :t in hugs and ghci
14:09:33 <Igloo> It may be easier to compare that foldr type with this foldl type: forall a b. (b -> a -> b) -> b -> [a] -> b
14:11:38 <barli> it says "unification would give infinite type"
14:28:39 * palomer wishes he could use haskell instead of sml
14:36:59 <arauko> anyone can recommend a good tutorial for haskell?
14:37:42 <Smerdyakov> arauko, have you looked at the topic?
14:42:10 * esap just tried to play nethack, and it said it's friday the 13th, so I'd better watch out. Hmm.. 
14:42:52 <sorrow> But.. it's Thursday the 12th, so don't worry. ;-)
14:43:04 <esap> Ah, it's friday already here...
14:43:20 <esap> Clearly nethack knows about time zones...
14:44:16 <arauko> Smerdyakov, i found it dude.. thanks 
14:44:20 <arauko> i already found it
14:46:32 <Marvin--> it won't be Friday here for another 15 minutes
14:46:39 <Marvin--> better get to bed before that :)
14:47:50 <sorrow> Right, good night.
15:09:59 <Hobbes> ok.... problems again... ive got a list like so... [(1,2),(2,2),(3,1),(1,1),(3,2),(6,1)] and i need to convert it to a list like so... [(1,3),(2,2),(3,3),(6,1)]
15:10:33 <Hobbes> i know this is virtually the same as i did last night but i cant seem to convert my previous function to handle this type of list
15:11:01 <Hobbes> maybe if i start from scratch again....
15:22:49 <shapr> hi koli 
15:23:09 <koli> ello
15:23:35 <koli> #webwitches  <:-O
15:23:39 <shapr> er, yes?
15:23:47 <shapr> I own half of that company.
15:23:51 <koli> did i just say hello to a witch ?
15:23:55 <koli> oh
15:23:57 <koli> *phew*
15:24:00 <koli> thats ok then.
15:24:10 <shapr> I'm actually a Baptist.
15:24:22 <koli> :I
15:24:38 <shapr> aha, freenode is going down for some maintenance in just a few hours.
15:25:09 <koli> for how long ?
15:25:18 <shapr> for an hour
15:25:24 <koli> ok
15:25:34 <koli> i should be able to get my questions in before then.
15:25:39 <shapr> what are your questions?
15:25:56 <koli> i haven't composed them yet.
15:26:00 <shapr> ok
15:26:19 <koli> ok heres the first one :-
15:26:38 <shapr> dons: awake?
15:26:39 <koli> what percentage of ppl who think they understand monads actually do understand monads ?
15:26:52 <shapr> I'd say about 99%
15:27:01 <shapr> because there's a simple test
15:27:09 <shapr> write your own monads and monad transformers, and actually use them.
15:27:15 <shapr> if they work, you understand monads.
15:27:25 <shapr> monads are just an abstraction like objects are just an abstraction
15:27:27 <Riastradh> Monads are not anywhere near as complex, arcane, obscure, and overwhelmingly confusingly category theoretical as you might think.
15:27:43 <shapr> they're a way of structuring your code such that some complexity is hidden in a systematic fashion
15:28:13 <shapr> a lot of things in programming are just conventions, look at ASCII
15:28:36 <koli> you're saying monads are just a convention ?
15:28:37 <shapr> yah, I agree with Riastradh, monads aren't that scary, they're just a good way to do things.
15:28:46 <shapr> yes, objects are just a convention also
15:29:07 <shapr> you can do monads in pretty much any language, but they'd be really painful in something like C
15:29:19 <koli> is general relativity just a convention ?
15:29:28 <shapr> sorry, that's a law.
15:29:35 <koli> ok
15:30:32 <shapr> look at objects, you can write code that acts like OOP code in pure C. Is it then OOP code?
15:31:15 <shapr> hej cm__, l√§get?
15:32:02 <koli> so, whats the purpose of the associative law in moads ?
15:32:07 <koli> monads
15:32:10 <shapr> koli: a monad is just a parameterized type and two functions that fulfill certain conventions.
15:32:33 <shapr> the associative law is part of being a monad, just like having state is part of being an object
15:32:58 <koli> would a monad be any use if it wasn't associative ?
15:33:14 <Cale> koli: read my article on the wiki, and you should be able to make sense of the laws :)
15:33:18 <Smerdyakov> It wouldn't have the same use, because it would no longer be intuitive.
15:33:20 <shapr> well, it wouldn't be a monad, and it would be much less useful
15:34:14 <shapr> koli: If you want to understand monads, I'd suggest you first read the page that Cale wrote on the wiki, and then read the nomaware.com monad tutorial.
15:34:29 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
15:34:33 <koli> i have.
15:35:03 <koli> i have a full understanding of templates in c++ STL, the whole lot.
15:35:07 <koli> but monads ...
15:35:29 <shapr> but the central big idea of a monad is that if you use a parameterized type and two functions (one to suck something 'into' the container, and one to say how two containers fit together), then your program is easier to modify.
15:35:55 <shapr> a great step by step working code demo is on Steve Atkin's webpage
15:35:58 <shapr> I can get you the url if you want.
15:36:25 <koli> its ok, i can google.
15:36:30 <shapr> alright
15:37:39 <shapr> Once I was really comfortable with Haskell, monads weren't that hard to understand. Monads fit the functional viewpoint very well.
15:38:34 <shapr> But, object oriented programming is kind of strange in the pure FP world. For example, pure FP doesn't have a concept of identity.
15:38:40 <shapr> just value equality.
15:38:46 <koli> i read somewhere that one of the creators of haskell regrets not calling monads 'warm fuzzy things'
15:38:50 <shapr> heh, yes
15:39:01 <shapr> that's Simon Peyton-Jones' "Hair Shirt Retrospective"
15:39:06 <koli> i find that rather patronising.
15:39:16 <shapr> no, I think he's right.
15:39:50 <shapr> The greatest obstacle I've seen to people learning certain subjects (both math and monads included) is that people are convinced those things must be difficult to learn.
15:39:56 <esap> It's possible to put identity into FP. You just need to be explicit about resources.
15:40:01 <Cale> Koli - do you understand what return, join, and map do?
15:40:13 <shapr> esap: right, but you understand all of that far better than I do :-)
15:40:14 <koli> cale: yes.
15:40:20 <Cale> Then you understand monads :)
15:40:23 <shapr> hei kaol 
15:40:31 <koli> nah
15:40:35 <koli> i don't think so.
15:40:47 <shapr> really, it's just about how to string stuff together to make life easier for yourself.
15:40:53 <Cale> This is a common tendency to think that there's somehow more to them
15:40:55 <shapr> look at the @eval command in lambdabot
15:40:55 <kaol> all that imperative programming has rotted my brain... A little help with making a function that transforms a string like "a,b,c" to ["a","b","c"], please?
15:41:19 <esap> shapr: Well I'm actually trying to build it. It's still not simple. Basically instead of datatypes you need to introduce OO objects. That'll do it.
15:41:52 <shapr> kaol: I'd use the split function from http://www.haskell.org/hawiki/PreludeExts
15:42:15 <shapr> but you could recursively call span or break explicitly.
15:42:25 <esap> shapr: But this means 'input' and 'output' will have to be redefined to allow for encapsulated values.
15:43:05 <shapr> koli: the @eval command in lambdabot uses monad transformers to get around a bunch of explicit lifting. If you can write your own monads, and your own monad transformers, you're doing just fine.
15:43:34 <Cale> koli: try the exercise there to make the tree datatype into a monad
15:43:38 <koli> "it is doubtful that the stucturing methods presentd here would have been discovered without the insight afforded by category theory" - wadler
15:43:54 <koli> "warm fuzzy things"
15:44:01 <shapr> sure, but discovering something is a lot harder than just using it.
15:44:35 <koli> i don't want to use it tho. i want to understand it.
15:44:39 <shapr> thing is, they're useful, they're simple, but people are convinced they're hard! 
15:44:50 <Cale> http://planetmath.org/encyclopedia/Monad.html is the mathematical definition
15:44:53 <shapr> I understood monads by using them.
15:44:58 <shapr> might work for you too.
15:45:03 <Cale> eta is return, and mu is join.
15:45:26 <koli> cale: i've tried understanding adjoint functors etc.
15:45:49 <Cale> You don't even have to worry about adjoint functors
15:45:58 <koli> maybe they should have called adjoint functors 'warm fuzzy things' too.
15:46:08 <kaol> shapr: thanks a lot. I need to do a bit more than simple split too, but that'll get me started at least.
15:46:29 <shapr> kaol: there's a lot of good stuff on PreludeExts
15:46:52 * shapr wish dons were awake!
15:46:58 <shapr> I have hs-plugins questions.
15:47:16 <kaol> I just hope I was smart enough to come up with all that myself. :-)
15:49:03 <Hobbes> ok.... problems again... ive got a list like so... [(1,2),(2,2),(3,1),(1,1),(3,2),(6,1)] and i need to convert it to a list like so... [(1,3),(2,2),(3,3),(6,1)]   i know this is virtually the same as i did last night but i cant seem to convert my previous function to handle this type of list
15:50:26 <Smerdyakov> You expect us to understand what you need to do from that single example?
15:50:43 <Hobbes> well no...
15:50:51 <shapr> what's the transform?
15:50:54 <Riastradh> I know:
15:50:54 <shapr> hej tic 
15:51:18 <Riastradh> frobList [(1,2),(2,2),(3,1),(1,1),(3,2),(6,1)] = [(1,3),(2,2),(3,3),(6,1)]
15:51:32 <Hobbes> frobList?
15:52:19 <tic> hejsan shapr
15:53:39 <Hobbes> whats frobList?
15:53:49 <Riastradh> Your function.
15:53:57 <Riastradh> It performs _exactly_ the transformation that you described.
15:54:26 <Hobbes> hmmm...
15:54:43 <Smerdyakov> Hobbes, so you don't want help on this anymore?
15:55:24 <Hobbes> maybe not... it depends on whether i pull all of my hair out or not
15:56:19 <Smerdyakov> Hobbes, OK. I tried to make it clear that you haven't yet told us what problem you are to solve, so you'd need to do that before getting any help.
15:56:59 <Hobbes> sorry... Riastradh was helping me with this last night...
15:58:05 <arauko>  main = putStr (unlines (repeat "Hello World"))
15:58:21 <arauko> any wrong with it??
15:58:47 <Riastradh> unlines scans for newlines.  Its argument has no newlines.
15:59:04 <Riastradh> ...oh, wait.
15:59:07 <Riastradh> Never mind.
15:59:12 <Riastradh> Cognitive gas discharge.
15:59:30 <arauko> :-)
15:59:45 <arauko> <interactive>:1: parse error on input `='
15:59:53 <arauko> it gives that message
16:00:02 <Riastradh> You can't enter definitions at the REPL like that.
16:00:14 <arauko> 0_0
16:03:18 <arauko> Riastradh, onl?y can do it froma file?
16:03:21 <Hobbes> ok say i have two lists of tuples... [(a,2),(b,2),(c,1)] and [(a,1),(c,2),(f,1)] where abc etc. are some item and the number following them in the tuple is the frequency of that letter. i need to sum the two lists so i get a list with everything that is in list1 and list2. if a appears 3 times in list1 and twice in list2 i need it the frequency in my summed list to be 5.
16:03:47 <Riastradh> Yes, arauko.
16:03:55 <arauko> Riastradh, thanks
16:04:16 <Riastradh> If you're using GHCi, you can get something similar by using let, because the REPL's input is essentially an implicit 'do.'
16:04:42 <Hobbes> i kind of had it working but it would only add up the items in the lists that matched...eg all the a's. it threw away the f
16:04:48 <Riastradh> I.e.:   let f x y = x + y    -- will work in GHCi.
16:05:40 <arauko> pretty cool
16:08:20 <shapr> grrr, what's wrong with this code?
16:08:22 * shapr bangs head
16:08:43 <shapr> happily, my keyboard survived this time.
16:10:39 <shapr> Hobbes: once you've learned to write all that code manually, you should check out Data.FiniteMap.plusFM_C
16:10:55 <shapr> it's really handy for summing frequency counts and that sort of thing.
16:20:19 <Hobbes> ive put what code ive got here... http://haskell.org/hawiki/HaskellIrcPastePage?action=show
16:20:56 <Hobbes> but it comes up with this error if i try to use it.. Bags> bagSum (listToBag [1,2,3,2,1]) (listToBag [1,3,3,6])
16:20:56 <Hobbes> [(1,3),(2,2),(3,1)
16:20:56 <Hobbes> Program error: pattern match failure: bagSum_v1651 []   
16:21:19 <Hobbes> listToBag is my code for changing the lists to the right tuple format
16:21:39 <Hobbes> oh my code is at the top by the way
16:49:56 <Hobbes> hello?
16:50:57 <Riastradh> Hobbes, does bagSum allow you to pass the null list?
16:52:07 <Hobbes> no... but it should be able to
16:52:46 <Hobbes> one of my test cases is [] and [1,1,1,1,1,1,1,1]
16:52:59 <Hobbes> which should return [1,1,1,1,1,1,1,1]
16:53:20 <Riastradh> You need to explicitly say what happens when the lists are empty.
16:54:13 <Hobbes> ok... i have this... 
16:54:16 <Hobbes> 		| bg1 [] = bg1
16:54:21 <Hobbes> 		| [] bg2 = bg2
16:57:04 <Hobbes> god damn it. 4 hours and all it was was i forgot to deal with empty lists. thanks Riastradh youve saved my sanity again
16:57:08 <shapr> g'day Pseudonym 
16:57:13 <Pseudonym> G'day.
16:57:22 <shapr> what's going on?
16:57:38 <Pseudonym> Gearing up for a release at w*rk.
16:57:43 <shapr> sounds good
16:57:43 <Pseudonym> It's a developer release, but a release nonetheless.
16:57:54 <Pseudonym> Sounds good, but feels stressful. :-)
16:58:05 <shapr> :-)
16:58:09 <Pseudonym> Thankfully, everything I need to go in was in a few days ahead of the deadline.
16:58:15 <Pseudonym> Which is good and bad.
16:58:22 <Pseudonym> Good, because I don't have as much work to do.
16:58:31 <Pseudonym> Bad, because I therefore have been nominated the official CD stamper.
17:15:16 <koli> "I'm a self-taught "programmer" with no formal education in mathematics or computer science, and I found the monad concept to be fairly difficult to learn.  It took a leap of consciousness that feels about the same level of difficulty as what I remember needing to get through my high school calculus class."
17:15:18 <koli> http://caml.inria.fr/archives/200303/msg00123.html
17:15:33 <Hobbes> ok night....thanks for the help again!
17:15:33 <koli> "leap of consciousness"
17:17:22 <Smerdyakov> koli, I think the person either read a very bad introduction or has very poor programming skills in general.
17:18:19 <koli> http://www.wetware.com/jhw <--- well thats him.
17:18:24 <koli> lets take a look.
17:20:37 <koli> he seems to be an expert o'caml programmer.
17:20:53 <koli> http://sardes.inrialpes.fr/~aschmitt/cwn/2004.01.06.html
17:20:58 <koli> his is the first project.
17:22:39 <Cale> People had a good deal of trouble understanding monads, I think primarily because the understanding of how they ought to behave in programs was less well understood in general, and there were many things that were known but not written down. Now there are good tutorials like the one at Nomaware.
17:23:16 <Cale> I wouldn't say that understanding monads is any more difficult really than understanding objects.
17:23:51 <Riastradh> Monads are _very_ simple: the merely abstract & generalize sequential computation.
17:24:17 <Cale> Or, if you'd prefer, there is the view that they simply abstract containers :)
17:24:20 <shrimpx> people take 20 years learning structured/OO programming and complain endlessly when 3 days of reading about monads has them confused
17:24:53 <koli> theres absolutely nothing to objects.
17:25:01 <Riastradh> That may sound like a hairy subject, but it's really not.  Monads are abstractions of sequential computation in almost its simplest form: a sequence of transitions.
17:25:11 <Cale> koli: not much to monads either.
17:25:18 <Riastradh> Objects are just things.  Monads are just an interface to computation.
17:25:32 <Pseudonym> Containers and computations are somewhat dual.
17:25:44 <Pseudonym> The container view is what category theorists get taught.
17:25:45 <koli> that require things like associativity ?
17:26:00 <Cale> Saying that they're an "interface to computation" is a little harder to grasp than saying that they're "containers" though :)
17:26:03 <Riastradh> Associativity is simply a consequence of the interface.
17:26:25 <shrimpx> Riastradh: people come to monads through IO, which is the totally wrong way to approach it. and literature is like 'use this construct but we won't tell you how it works underneath because it's really complicated'. pure FP books should come straight out, talking about sequential composition after explaining functions
17:26:33 <Pseudonym> But it's mathematically equivalent to Kleisli triples, which is what abstracted computation looks like.
17:26:35 <koli> well i know about interfaces in c++ etc. and they have nothing to do with associativity.
17:26:50 <Riastradh> I'm using the term 'interface' very generally.
17:26:57 <Pseudonym> koli: You're right and wrong.
17:26:59 <palomer> interfaces in C++?
17:27:09 <Pseudonym> First off, C++ doesn't have interfaces.
17:27:14 <koli> yeah, as in COM
17:27:27 <Pseudonym> COM isn't part of C++.
17:27:36 <koli> COM uses c++
17:27:42 <Pseudonym> It can use C++.
17:27:47 <palomer> I can use C++
17:27:51 <Pseudonym> But COM is at most an add-on to C++.
17:27:55 <Pseudonym> It's not part of C++.
17:28:20 <koli> the point is is that i used 'interfaces'
17:28:53 <Pseudonym> See, when you said "interfaces", I thought you meant "abstract base classes".
17:29:09 <palomer> I thought you meant "header file"
17:29:12 <koli> well they're basicaly the same thing.
17:29:16 <shrimpx> haha
17:29:23 <Riastradh> koli, don't get caught up in details like these.
17:29:26 <Cale> koli: Stare at (m >>= f) >>= g == m >>= (\x -> f x >>= g) for a little bit - presumably it's what you're having trouble with, let's take it apart.
17:29:40 <Cale> what is this actually saying?
17:30:07 <Cale> well, first, let's focus on the left side
17:30:16 <Cale> (m >>= f) >>= g
17:30:30 <koli> i know all about group theory.
17:30:43 <koli> rquite a bit about ring theory.
17:30:45 <koli> modules.
17:30:49 <koli> tensor products.
17:30:58 <shrimpx> cool
17:31:09 <Cale> take each thing in m, apply f, giving a new container, join the containers, take each thing in that container, apply g, join the containers.
17:31:11 <koli> i don't know ALL about group theory :I
17:31:36 <Cale> right?
17:31:41 <koli> right
17:31:42 <shrimpx> Cale: do you really think of them as containers?
17:31:47 <Cale> shrimpx: yes
17:31:51 <shrimpx> hmm
17:31:54 <Cale> m >>= (\x -> f x >>= g)
17:32:05 <Cale> take each thing in m and do the following
17:33:07 <Cale> apply f to x, giving a container, and each thing in that container, apply g, and join the resulting containers
17:33:15 <Cale> and then join the results for each x
17:33:35 <Cale> this is just a rewording of the other thing
17:33:49 <Cale> you're doing f, then g, and combining as you go
17:34:16 <shrimpx> so reading that explanation, i'm immediately wondering what it means to "take each thing"
17:34:21 <Cale> :)
17:34:22 <Cale> map
17:34:53 <Cale> perhaps being a little more formal...
17:34:57 <Pseudonym> I'm trying to think of them as abstracted algebras, but my brain hurts a little.
17:35:19 <koli> Pseudonym: but they're really easy dude !
17:35:36 <Cale> (m >>= f) >>= g  -- map f over the container m, giving a container of containers which we then join, and then map g over that, again giving a container of containers which we join.
17:35:58 <Cale> >>= is just a generalised concatMap
17:36:24 <koli> you don't explain why associativity is necessary in your article.
17:36:34 <koli> i know what associativity is.
17:37:04 <Pseudonym> Let's assume for a moment that semicolon separates statemenst in C++.
17:37:07 <Pseudonym> Rahter than terminats.
17:37:22 <Pseudonym> Then (f() ; g()) ; h() should be the same as f() ; (g() ; h())
17:37:26 <Pseudonym> That's an associative laqw.
17:37:28 <Pseudonym> law
17:37:39 <Pseudonym> Make sense?
17:37:46 <koli> hmmm
17:38:01 <koli> well yeah
17:39:44 <Cale> you can also view  x >>= f as "give x as a parameter to the computation f"
17:39:56 <Cale> (this is the non-container view)
17:40:26 <koli> ok
17:40:39 <Cale> (m >>= f) >>= g then just expresses a pipelining of computations
17:40:48 <Cale> f, then g
17:41:17 <koli> Pseudonym: isn't that more to do with referential transparency ?
17:41:19 <Cale> m >>= (\x -> f x >>= g)
17:41:23 <koli> cale: ok
17:41:24 <Cale> look at that
17:41:33 <Pseudonym> Referential transparency is something specific.
17:41:51 <Pseudonym> It means that x == y implies f(x) == f(y)
17:41:54 <Pseudonym> Sort of.
17:42:00 <koli> yeah
17:42:24 <Pseudonym> That would actually imply a commutative law.
17:42:33 <Pseudonym> f() ; g() == g() ; f()
17:42:39 <Pseudonym> But in an impure language, that's not true.
17:42:52 <koli> :)
17:43:48 <Cale> or in any language where sequence is important, to say almost nothing :)
17:43:50 <Pseudonym> mh_le: Very funny. :-)
17:43:54 <Pseudonym> Sorry.
17:43:59 <Pseudonym> Wrong channel.
17:44:11 <monochrom> Very funny!
17:44:25 <Pseudonym> Yes!
17:45:23 <Cale> So in one light, monads are just a way to express computations of any sort which happen in a particular order.
17:45:36 <Cale> Possibly with special features thown in :)
17:45:38 <monochrom> I invite you to enjoy my http://www.cs.utoronto.ca/~trebla/fp/prover/index.html  I have a monad there.
17:47:11 <Cale> but really, the best way to get a feel for what monads are about is to first just use them to do some things.
17:47:16 <monochrom> I also want to say...  I understand higher-order logic, so I have no problem with "container of computations".
17:48:25 <Cale> Even just the IO monad will probably suffice to give some idea, though it's not the best example, and the list and state monads are easy enough to sit down and try to use.
17:48:59 <koli> apparently the IO monad isn't even associative.
17:49:10 <koli> it has problems embarrassing ones.
17:49:19 <koli> something to do with 'seq'
17:49:28 <Pseudonym> Wel, 'seq' breaks a lot of things.
17:49:36 <koli> <koli> it has problems apparently, embarrassing ones.
17:49:39 <Pseudonym> It's actually seq's fault, not IO's.
17:49:50 <Pseudonym> IMO
17:49:57 <koli> so it would seem that associativity isn't necessary.
17:50:04 <Cale> hm?
17:50:14 <Cale> no, it's certainly necessary
17:50:26 <Cale> if you want to keep things sane
17:50:27 <koli> well IO isn't associative.
17:50:31 <koli> and its used alot.
17:50:34 <Pseudonym> Yes it is.
17:50:39 <Pseudonym> It's just that seq is evil.
17:50:44 <Pseudonym> It should be called "unsafeSeq".
17:51:23 <koli> it doesn't inspire confidence tho.
17:51:32 <Cale> hm?
17:51:41 <monochrom> I concur with Pseudonym.
17:51:46 <koli> when the inventors of haskell find out that a monad they use isn't even fully associative
17:51:55 <shrimpx> haha
17:51:56 <Cale> altering the evaluation order of side effecting computations will generally affect things in a bad way
17:52:12 <Cale> IO *is* associative
17:52:27 <koli> did you know about the problems with 'seq' ?
17:52:29 <shrimpx> koli: haskell, like other languages, has features that allow you to shoot yourself in the foot if you're unwise enough to do so
17:52:31 <Cale> yeah
17:52:39 <Pseudonym> And actually, the only problems that seq causes with IO is when you try to seq something that doesn't terminate.
17:52:46 <Pseudonym> The static semantics are fine.
17:52:53 <Pseudonym> It just throws the operational semantics out a bit,
17:53:35 <Pseudonym> If you like, IO is associative, even in the presence of seq, if you use weak equality.
17:53:46 <monochrom> unsafePerformIO breaks a lot more things.  I have not heard of inconfidence due to unsafePerformIO.  Actually people like it a lot.
17:54:11 <Pseudonym> Uhm...
17:54:16 <Pseudonym> Yes, weak equality.
17:54:18 <koli> weak equality. you wouldn't be talking about higher dimensional algebra would you. n-category theory ?
17:54:30 <Pseudonym> No, this is denotational semantics.
17:54:37 <koli> oh.
17:54:42 <Pseudonym> But it probably turns up in n-category thoery too.
17:54:57 <koli> i figured you were gonna tell me how easy n-category theory was for a second :I
17:54:57 <Pseudonym> Basically, strong equality means that x = y can only return true or false.
17:55:04 <koli> ok
17:55:05 <Pseudonym> Weak equality means that it can also return bottom.
17:55:40 <koli> ok guys.
17:55:45 <koli> thanks for trying.
17:55:49 <Pseudonym> So the associative law for IO holds in the sense that if you could compare two IOs for equality, they would never compare non-equal.
17:56:05 <Pseudonym> But the equality tester may not terminate itself. :-)
17:56:21 <Pseudonym> In the presence of seq'ing things which don't terminate.
17:56:41 <koli> :I
17:56:43 <koli> ok
17:56:51 <koli> well i gotta get to bed now.
17:56:54 <koli> night night
17:56:56 <koli> and thx.
17:56:57 <Pseudonym> Night.
17:59:18 * esap is thinking about structural equality for coalgebras. How could you do that?
17:59:21 <shapr> yow!
17:59:36 <Pseudonym> No idea.
17:59:47 <Pseudonym> Do coalgebras have that kind of structure?
17:59:59 <Pseudonym> I thought they could only be observed.
18:00:06 <Pseudonym> Not actually pulled apart.
18:00:16 <Pseudonym> How would you, for example, compare two infinite streams for equality?
18:00:24 <Pseudonym> @yow
18:00:25 <lambdabot> ...PENGUINS are floating by...
18:01:37 <Cale> I never quite get used to the fact that there's always the implicit assumption in CS that valid solutions to problems be computable. :)
18:01:48 <esap> pseudonym: that's the problem. I guess you could mark nodes in the data structure and find loops, then terminate the comparison when you've got through all the elements. Of course this interacts badly with referential transparency...
18:02:24 <Pseudonym> Indeed.
18:02:38 <Pseudonym> Besides, what if the stream is actually infinite?
18:02:46 <kaol> hugs is giving me syntax errors. :-(
18:03:04 <Cale> kaol: which ones?
18:03:08 <esap> pseudonym: If the stream is actually infinite, I guess the only way would be to look at the syntactic form of how the stream was constructed and try to compare those.
18:03:29 <kaol> Cale: "syntax error in input"
18:03:41 <Cale> where in the input?
18:03:42 <esap> pseudonym: But I'd suppose that's very hard to do in general.
18:03:44 <kaol> (unexpected `|')
18:03:50 <Cale> okay - on line?
18:04:08 <kaol> the whole line: ERROR "brace.hs":20 - Syntax error in input (unexpected `|')
18:04:20 <Cale> look at brace.hs on line 20
18:04:35 <Cale> and see if you see anything syntactically missing around there
18:06:49 <esap> pseudonym: I suppose there is a 'smallest' representation for every sequence. Maybe you might find a reduction algorithm to make sequences into this smallest form, then compare those directly.
18:07:17 <Pseudonym> esap: That's an undecidable problem.
18:07:45 <kaol> Cale: looks like I'm misusing "where" somehow, I'll try to decipher it
18:07:50 <Pseudonym> It's called "Kolmogorov complexity", and it basically involves finding the smallest Turing machine which will generate the stream.
18:08:00 <Cale> kaol: if you paste the code somewhere, I'll have a look
18:08:10 <Cale> like on the wiki's paste page
18:08:20 <esap> pseudonym: Well at least if you are not restricting the sequences in any way. Maybe there are classes of sequences that can be compressed in such way.
18:11:29 <Pseudonym> No doubt.
18:11:44 <Pseudonym> But if you're dealing with infinite streams... well, the stream might be anything.
18:11:44 <kaol> Cale: it's at http://www.haskell.org/hawiki/HaskellIrcPastePage
18:11:56 <Pseudonym> Digits of an irrational number, for example.
18:12:07 <kaol> Cale: It's that "otherwise" line I get the error from
18:12:20 <Cale> oh
18:12:48 <Cale> shift the where so that it lies before the "(piece1, ..." on the same line
18:12:50 <esap> pseudonym: Well at minimum, I'd expect all sequences I encounter will have an algorithm for computing it :-) But that might not be quite sufficient restriction.
18:13:08 <Cale> (this will require you to tab in the "(piece1,..." code a little)
18:13:49 <Pseudonym> Right.  So your problem is reduced to finding the smallest program equivalent to a given program.
18:13:54 <Pseudonym> :-)
18:14:01 <esap> pseudonym: :-)
18:15:52 <esap> pseudonym: Well I can think of one general solution to the 'full' problem: Leave it up to the end-user to prove there is a solution :-)
18:15:57 <Pseudonym> So I'll give you a program which generates the digits of the Euler-Mascheroni constant, you write the smallest program which generates it, and then you can line up for your free PhD.
18:16:38 * esap 's solution is just to postpone all the PhD level stuff to someone who actually is a PhD :-)
18:16:43 <Pseudonym> :-)
18:17:29 <Cale> kaol: is that helping?
18:18:12 <kaol> no luck yet with it
18:18:32 <Cale> the stuff that goes inside the where clause has to be more tabbed in than the where keyword.
18:18:40 <esap> The obvious next question: What tools are needed to provide sufficient support for that.
18:19:42 <kaol> Cale: If I tab the (piece1,... and (piece2,... lines to the same column with the where above them, I still get the same error
18:20:06 <Cale> tab just a little more :)
18:20:40 <Cale> or move the where down so it's like:
18:20:51 <Cale> where (piece1, ...
18:20:59 <Cale>       (piece2,...
18:21:48 <kaol> I'm still getting the same error with that
18:22:32 * kaol is stumped
18:24:40 * esap has to get some sleep. bbl.
18:25:17 <kaol> is it a problem, that I have (piece1, rest1)... on the first line and use rest1 on the second already?
18:25:30 <Cale> try what I changed it to
18:26:41 <Cale> where scopes over guards
18:26:59 <kaol> Cale: of course, that works...
18:27:16 <kaol> Really obvious now.
18:27:17 <Cale> if you want an expression level thing, use let
18:27:42 <Cale> sorry that I didn't realise quicker what was going on :)
18:30:39 <kaol> "where" is clearly defined in the tutorial, my fault for not reading it more thoroughly. Then again, learning new languages is always a messy process, no matter how clear the tutorials.
18:32:32 * shapr burbles
19:12:52 <shrimpx> as far as lists are concerned, liftM is the same as map, right?
19:13:06 <shrimpx> and fmap for that matter
19:15:05 <Cale> yeah
19:15:26 <Cale> map is the list-specific one, fmap works on all functors, and liftM on all monads.
23:20:26 <ibid> hoho
23:20:53 <Lor> Our department will move today. By a steam engine. :)
23:21:00 <ibid> reading the c++ library tr, the following caught my eye (specifying which regular expression syntax is to be used):
23:21:04 <ibid> perl Specifies that the grammar recognized by the regular expression is an implementation defined extension of the normal syntax.
23:21:19 <ibid> Lor: oh?
23:21:54 <Lor> http://www.cs.helsinki.fi/u/wikla/1009/
23:23:11 <ibid> wow
23:23:23 <ibid> i trust you will be there?
23:24:41 <Lor> Yeah.
23:25:44 <ibid> is that just a people-mover or do your stuff get to travel with you?
23:26:26 <Lor> Nah, people only. It's just symbolic.
23:26:35 <Lor> All the stuff has been moved during the summer.
23:27:20 <ibid> ok
23:29:33 <dons> shapr: makeWith not rebuilding src. hmm.
23:29:52 <dons> are you using the cvs snapshots? I recommend that for the moment
23:45:26 <stefan_> morning, all
23:46:16 <XTL> Morning
