02:36:06 <shapr> yow!
02:39:07 <shapr> good morning #haskell!
02:39:11 <shapr> @yow !
02:39:11 <lambdabot> And furthermore, my bowling average is unimpeachable!!!
02:40:42 * shapr bounces cheerfully
02:40:58 <shapr> bringert: hey, has Aarne ever mentioned a visual grammar?
02:41:26 <shapr> I was just thinking about something that can display pictures with prepositions maybe
02:41:35 <shapr> apple on table, apple under table
02:41:39 <shapr> and make a picture
02:49:25 <shapr> hiya lelit 
02:49:43 <lelit> ciao shapr, good morning all
03:19:32 <bringert> morning shapr
03:19:45 <bringert> I have never seen a non-text GF-grammar
03:19:59 <bringert> but there might be one
03:20:32 <bringert> assuming you use text to represent the picture somehow, and then use some external tool to convert text <-> picture
03:21:38 <bringert> there have been discussions about multi-modal grammars, e.g. text + mouse-clicks on a map
03:22:00 <bringert> "I want to go here <click 546,234>" or something like that
03:32:02 <shapr> hm, sounds interesting
04:01:46 <shapr> WASH wants to pass fields in some cases, but not with activate. I have a function I'd like to call with both sorts of values, I wonder how to do that.
04:02:28 <shapr> hiya musasabi 
04:02:32 <musasabi> hello shapr 
04:02:35 <shapr> what's up?
04:02:49 <musasabi> playing again with haskell (not fire though).
04:03:01 <shapr> :-)
04:03:07 <shapr> doing something fun?
04:03:16 <musasabi> not yet ;)
04:03:19 <musasabi> Is there anyway to use data constructors in monadic code without do blocks.
04:03:39 <shapr> ?
04:03:51 <musasabi> that is code like do a <- foo; return (Constructor a);
04:04:14 <shapr> oh, there is something like thatt
04:04:15 <musasabi> How would I do it without the rebundant do-block?
04:04:16 <shapr> sort of
04:04:32 <musasabi> create a function to do it and use liftM?
04:04:48 <shapr> you want a simple way to unpack a datatype, right?
04:05:24 <shapr> John Hughes did a nifty and mystical unpack that took me an hour to figure out... lemme see if I can find it.
04:07:29 <shapr> I think you can do something like tuple unpacking in a where clause
04:07:33 <shapr> evaluate :: Testable a => a -> Gen Result
04:07:33 <shapr> evaluate a = gen where Prop gen = property a
04:08:08 <musasabi> hmm.
04:08:17 <shapr> property a returns 'newtype Property = Prop (Gen Result)'
04:08:37 <shapr> is that the sort of thing you're asking for?
04:10:18 <musasabi> yes something like that.
04:11:44 <shapr> is there a text browser that supports javascript?
04:12:47 <musasabi> http://atrey.karlin.mff.cuni.cz/~clock/twibright/links/ ? 
04:17:51 <Lunar^> shapr: links2 AFAIK
04:18:35 <musasabi> How would I sequence functions with signatures like a->IO (Maybe b), b->IO (Maybe c) ?
04:30:05 <shapr> sounds like a candidate for lifting
04:47:03 * shapr fights WASH
04:53:27 <shapr> yay
04:55:23 * shapr bounces
04:57:58 <musasabi> hmm got it as a function - now how do I make this more elegant?
04:58:00 <musasabi> adj :: Maybe a -> (a -> IO (Maybe b)) -> IO (Maybe b)
04:58:00 <musasabi> adj a f = case a of
04:58:02 <musasabi>   Just v  -> f v
04:58:17 <musasabi>     Nothing -> return Nothing
04:58:49 <shapr> that looks like the monad instance for Maybe
04:59:36 <musasabi> but note how it is used with Io.
04:59:48 <shapr> seems like you'd be able to lift it to get both
05:00:02 * shapr hacks up a spike solution
05:05:00 <shapr> huh, I know this can be lifted, but it's not obvious.
05:05:18 <shapr> hola jao 
05:05:19 <musasabi> yes, the signatures seem always to be slightly wrong.
05:05:24 <shapr> right, I'm getting that myself.
05:05:37 <musasabi> as for a more practical aspect, what I am trying to do is:
05:06:04 <jao> hi shapr
05:07:00 <musasabi> HashTable.lookup db key `something` readIORef
05:07:22 <musasabi> (and after that check permissions - with the same combinator)
05:09:10 <shapr> I think the nomaware monad tutorial uses just that same sort of thing to show monad transformers
05:11:42 <shapr> check this out: http://www.nomaware.com/monads/html/hardway.html
05:33:22 <shapr> sourcefourge bug tracker suxx
05:33:30 <shapr> items should be in chronological order
05:34:50 <shapr> hej Marvin-- 
05:34:50 <shapr> wassup?
05:35:57 <musasabi> hmm created a better version:
05:35:59 <musasabi> (>!>)         :: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b)
05:35:59 <musasabi> (val) >!> (f) = val >>= \r -> case r of
05:35:59 <musasabi>                                      Nothing -> return Nothing
05:35:59 <musasabi>                                      Just x  -> f x
05:36:02 <Marvin--> hi shapr
05:36:11 <Marvin--> shapr: I'm struggling with getting a new release of pyopenssl out the door
05:36:40 <shapr> sounds like fun, did you try pyrex?
05:37:28 <Marvin--> I've been playing with it a bit, but this release won't have anything to do with pyrex
05:37:49 <Marvin--> and I'm still waiting for a reply to some questions I sent to the pyrex mailing list, it's not exactly ultra-high traffic...
05:39:19 <shapr> defining a useful grammar for a natural language is a *lot* of work.
05:39:28 <shapr> er, useful computational grammar
05:39:49 <shapr> musasabi: I'm still convinced there's a simpler solution, but I don't see it at the moment.
05:40:29 <musasabi> shapr: Yes, I think it exists too, but it seems to elude both of us.
05:41:18 <musasabi> the main problem seems to be that mzero cannot be automatically lifted.
05:51:55 <bringert> shapr: aarne said that he has played with the idea of having a concrete syntax for pictures
05:52:05 <bringert> but never implemented it
05:52:29 <Igloo> Marvin--: Will "Modules:" ever disappear completely?
05:53:10 <Marvin--> Igloo: dunno
05:53:22 <Igloo> Marvin--: It occurs to me that if a module has conditional imports then you'll need it when building a source package. In fact, the whole thing gets distinctly ugly when making source packages
05:53:24 <Marvin--> Igloo: I like to think that it shouldn't be necessary
05:54:18 <Marvin--> well, we definitely need some sort of extra-files field
05:54:38 <Marvin--> or something like distutils' MANIFEST
05:55:36 <Igloo> #if defined(__GHC__) #elif defined(__NHC__) ... #else #error "Unknown compiled #endif would cause automatic module searching when making a source package to fail
05:55:55 <Marvin--> yes
05:56:28 <Marvin--> but I think a more general mechanism than modules is what we want
05:56:37 <Marvin--> since you'll want other things in your source dist as well
05:57:04 <Marvin--> (docs, utilities, stuff...)
05:59:58 <Marvin--> huh, perl code never ceases to amaze me
06:00:27 <Marvin--> if (read F, local $_, 32 and m%^...%) { ...
06:00:38 <Marvin--> where on earth does that 32 come from?
06:00:50 * Marvin-- boggles
06:01:10 <Igloo> Is and bitwise or just boolean?
06:01:27 <Marvin--> I have no idea
06:03:10 <Igloo> Looks boolean, so I have no idea  :-)
06:09:48 <Marvin--> gzip pyOpenSSL-0.6rc1.tar
06:09:56 <Marvin--> here goes, I guess
06:10:45 <Igloo> Why don't you use tar's -z?
06:12:09 <Marvin--> old habit when writing Makefiles I guess
06:16:24 <Marvin--> whoops, maybe I should've upped the version in the docs
06:16:27 <Marvin--> eh, whatever
06:29:26 <SyntaxNinja> 'mornin
06:30:27 <Igloo> Yo Isaac
06:31:22 <SyntaxNinja> how's it going, Igloo
06:49:52 <SyntaxNinja> has anyone seen any problems w/ the wxhaskell packages that should preclude them from being uploaded to debian? (besides the lintian errors)
06:52:41 <Igloo> Oh, sorry, forgot to answer that. "Hectically".  :-)
06:54:21 <Marvin--> which version of wxhaskell and where are the packages? in h-e?
06:54:54 <SyntaxNinja> they're not in HE right now.
06:55:11 <SyntaxNinja> http://www.syntaxpolice.org/tmp/wxhaskell/
06:55:13 <SyntaxNinja> and 0.8
06:56:43 <Marvin--> er, why aren't they called libghc6-wxhaskell?
06:57:22 <Marvin--> brb, gonna go check my snail mail
06:58:00 <SyntaxNinja> I guess I'm confused. I thought we decided on libfoo-ghc6{,-dev}...
06:59:16 <Igloo> We agreed on "libghc6-wxhaskell-dev", I think, although we didn't decide about hugs package names
06:59:29 <SyntaxNinja> ok
07:00:06 <SyntaxNinja> oh, I guess I fixed the "cabal" package, but not the wxhaskell package.
07:01:17 <SyntaxNinja> so we have libghc6-wxhaskell-dev and libghc6-wxhaskell0.8
07:04:34 <Marvin--> why libghc6-wxhaskell0.8? Is that the package with the stupid libwxc.so that lacks a soname?
07:05:44 <SyntaxNinja> yeah
07:06:11 <Marvin--> I still think it's broken to put a .so file in /usr/lib if it doesn't have a soname
07:06:33 <SyntaxNinja> I can you give me any ammunition to convince upstream?
07:06:46 <SyntaxNinja> last time I asked on here, we seemed to come to the conclusion that it's a historical thing
07:06:51 <SyntaxNinja> maybe I misunderstood.
07:07:05 <Igloo> I'm not convinced the package name for it is right either way
07:07:24 <SyntaxNinja> Igloo: what do you think the package name should be?
07:08:17 <Igloo> I haven't checked policy, but it might require (or at least recommend) libwxc<soname>
07:08:19 <Marvin--> there was a discussion on -devel recently about debtags and fluctuating api/abi
07:08:59 <Marvin--> I didn't follow it closely but I think the consensus was that if you don't want to commit to a soversion/soname, you shouldn't provide a .so file at all, only .a
07:11:21 <SyntaxNinja> OK so here's what daan says, which I don't really understand...
07:11:35 <SyntaxNinja> "However, we should keep
07:11:36 <SyntaxNinja> in mind that libwxc is not meant as the usual shared library but
07:11:36 <SyntaxNinja> more as a static library. The only reason for making it shared is
07:11:36 <SyntaxNinja> to mix the different c++ and c runtime systems. Therefore, each
07:11:36 <SyntaxNinja> wxHaskell application will link against a specific libwxc library, and
07:11:36 <SyntaxNinja> never use an "older" version, as is the case with libc for example."
07:12:07 <Marvin--> I don't understand it either
07:12:11 <Marvin--> bring it up on -devel
07:12:13 <SyntaxNinja> and then he says:
07:12:20 <SyntaxNinja> The bottom line is that the current name scheme is just fine, and we
07:12:20 <SyntaxNinja> should probably not use the "standard" shared library name scheme
07:12:20 <SyntaxNinja> with the ".<version>" appended. libwxc is linked with  -soname where
07:12:20 <SyntaxNinja> the soname is just the file name itself -- no indirections needed here.
07:12:33 <SyntaxNinja> beh. I don't like to bring up things on -devel that I don't understand.
07:12:55 <Igloo> I don't get why it can't be static
07:13:09 <SyntaxNinja> I'll reply with you guys in the CC list.
07:13:24 <Marvin--> if it's meant to be "more as a static library", why isn't it static?
07:26:51 <shapr> yeehaa
07:27:14 <SyntaxNinja> hi shapr
07:27:14 <shapr> bringert: I'll email Aarne and ask him about that.
07:43:04 <Marvin--> http://slashdot.org/comments.pl?sid=117449&cid=9928877 <- heh
07:45:27 <esap> at least somebody understands finite automata...
07:46:33 * esap doesn't, really. I'm even having trouble building a type-safe generic finite automata with Haskell....
08:01:54 <shapr> y0 SyntaxNinja 
08:02:04 <shapr> FSMs are just case-ful continuations
08:02:15 <shapr> look at the FSM arrow
08:03:15 <shapr> heh
08:03:16 <shapr> cute
08:04:19 <shapr> hiya hztk_pak 
08:04:28 * shapr bounces cheerfully
08:04:43 <shapr> so, who's been working with hws-wp lately?
08:04:51 <shapr> dons: heard of anyone integrating hs-plugins and hws-wp?
08:05:35 <hztk_pak> [shapr] Irie
08:06:12 <shapr> jah love
08:06:39 <hztk_pak> xD XD
08:10:41 <shapr> aks yah I-mon wat dey be sayin 
08:10:53 <bringert> haskelldb with hs-plugins would be cool too
08:11:01 <bringert> dynamic driver loading
08:11:22 <shapr> I realized I wanted to integrate WASH, GF and now HaskellDB
08:11:35 <shapr> it's probably time I looked at fitting it all into hws-wp
08:11:56 <shapr> GF startup time (before the recent changes) is painful
08:13:17 <shapr> dem bwoys brukout
08:13:38 <shapr> I bet there's not a rasta <-> english GF grammar yet =)
08:16:01 <shapr> HDB dynamic loading would be very cool
08:16:17 <shapr> I think then you could define and load database tables on the fly.
08:18:31 <shapr> @arr
08:18:32 <lambdabot> This is the END for you, you gutter-crawling cur!
08:18:50 <shapr> vadÂ
08:19:21 <shapr> WASH is pretty painful all in all.
08:19:29 <shapr> there must be a better way.
08:23:53 <SyntaxNinja> so does anyone know why so many files in wxhaskell are executable?  what OS does daan use?
08:24:02 <shapr> I think he uses MOX
08:24:34 <shapr> anyone know why I could have two debian computers pointed at the same mirror, and only one sees new packages?
08:24:50 <SyntaxNinja> what's MOX?
08:24:56 <shapr> Mac Os X
08:25:07 <SyntaxNinja> shapr: because they're using different distributions? they're looking in different sections?
08:25:19 <shapr> one points to unstable, one to sid
08:25:35 <shapr> I tried switching the confused one to sid, but that didn't fix it either.
08:25:47 <SyntaxNinja> are the package files it gets the same?
08:25:56 <shapr> hm, good question
08:25:57 * shapr checks
08:26:28 <shapr> how do I check that?
08:26:45 <SyntaxNinja> look in /var/lib/apt/lists
08:29:25 <shapr> the md5sum of the ...debian_dists_{sid,unstable}_binary... are the same
08:29:42 <shapr> what's the latest version of darcs in unstable? 9.22 or 9.23?
08:29:57 <SyntaxNinja> should be 9.23
08:30:23 <shapr> right, and the box that updates has that, and the box that's confused shows 9.22 with apt-cache
08:30:35 <shapr> sounds like the packages file is right but something's still not getting updated
08:30:52 <SyntaxNinja> maybe you got 9.23 from someplace else?
08:31:03 <SyntaxNinja> the package file on the "confused" machine says 9.23?
08:31:30 <shapr> haven't looked in th actual file, just compared md5sum
08:32:16 <shapr> huh, yes... the package file does say 9.23, but apt-cache show 9.22
08:32:25 <shapr> wtf
08:32:58 <SyntaxNinja> is it showing just 9.22?
08:33:03 <SyntaxNinja> or is it showing both?
08:33:20 <shapr> er, now it's showing both
08:33:22 * shapr blinks
08:33:25 <shapr> so why won't it upgrade?
08:33:48 <SyntaxNinja> do you have something in apt-preferences telling it to prefer to use sarge?
08:33:58 <SyntaxNinja> what if you say apt-get install darcs/sid or something
08:34:17 <shapr> huh
08:34:24 <shapr> that worked
08:34:26 <shapr> what's up with that?
08:34:44 <shapr> apt-get install darcs/unstable worked
08:34:45 <SyntaxNinja> check your apt preferences... that's all I can think of offhand.
08:34:49 <Marvin--> you sure you don't have any pinning going on?
08:35:38 <shapr> what do I do with my /etc/apt/preferences ?
08:36:09 <Marvin--> er, what do you mean?
08:36:13 <shapr> aha, man apt_preferences
08:36:35 <Marvin--> read it and see if anything looks suspicious
08:36:36 <shapr> I think this is because I installed from the installer, and only change my sources.list to unstable, not my /etc/apt/preferences
08:36:50 <Marvin--> possibly
08:37:01 <Marvin--> I don't even have a preferences file
08:37:04 * shapr didn't know about /etc/apt/preferences
08:37:08 <shapr> must be new
08:37:53 * shapr hails SyntaxNinja as the apt-expert
08:38:01 <shapr> SyntaxNinja: any news on apt-secure?
08:38:34 <SyntaxNinja> shapr: apt-secure is integrated in 0.6 and is in experimental.
08:38:39 <shapr> yay!
08:38:46 <SyntaxNinja> http://packages.debian.org/cgi-bin/search_packages.pl?keywords=apt&searchon=names&subword=1&version=all&release=all
08:39:15 <SyntaxNinja> http://monk.debian.net/apt-secure/
08:41:50 <shapr> I see the problem, I think. stable has priority 1001, testing has 101, unstable has 99, and experimental 9
08:42:29 * shapr removes the stable and testing entries and hopes
08:47:05 <Marvin--> meh, I need to get in shape, badly
08:47:47 <shapr> ?
08:47:50 <shapr> unicycle!
08:47:56 <shapr> it's fun and good exercise.
08:48:12 <Marvin--> I think I'll settle for my bicycle
08:48:48 <shapr> this is a *really* cool app - http://www.auralizer.com:8080/peep/download.html
08:48:50 <Marvin--> I think starting to work will make it slightly better, I've been sitting mostly still all summer
08:48:52 <shapr> you gotta hear the demos
08:49:07 <Marvin--> but I think my out-of-shapeness predates the summer, unfortunately
08:49:18 <SyntaxNinja> so upstream wxhaskell contains some windows binary that presumably doesn't get installed anywhere in debian. is there any use in deleting it, or will that just make the diff.gz bigger?
08:49:21 <shapr> low-traffic demo - http://www.auralizer.com:8080/Introduction/demo.mp3
08:49:37 <Marvin--> SyntaxNinja: a .exe?!
08:49:45 <SyntaxNinja> Marvin--: yeah.
08:50:03 <SyntaxNinja> or should I delete it from the upstream tarball? that seems wrong.
08:50:04 <Marvin--> SyntaxNinja: lart Daan for putting binary files in a source distribution
08:50:33 <Marvin--> you can't delete it from the upstream tarball, and deleting it will only make the diff larger
08:50:40 <SyntaxNinja> right
08:50:50 <Marvin--> the Right Thing is to lart^Weducate upstream
08:51:28 <Marvin--> shapr: I found a scales recently and noticed I've gained quite a lot of weight :-/
08:51:38 <shapr> bet I'm still heavier than you :-P
08:51:43 <Marvin--> and looking at my belly I think I know where those extra kilos are
08:51:59 <shapr> I've been losing weight, I'm down to 99 kilos.
08:52:14 <Marvin--> 99kg is what the scales showed :-/
08:52:18 <shapr> oh, wow.
08:52:30 <Marvin--> well, before the barbecue, didn't dare look again *after* the barbecue :-P
08:52:34 <shapr> you need to get in shape, badly ;-)
08:52:38 * shapr grins
08:52:41 <Marvin--> that's what I said
08:52:51 <shapr> of course, I'm much shorter than you, so I need to get in shape even more.
08:53:41 <Marvin--> stupid illness I've got that sped up my metabolism
08:53:54 <shapr> you have a metabolic illness?
08:53:56 <Marvin--> now that I'm medicating it, I have a feeling I'm eating way too much just from habit
08:54:12 <shapr> hyperthyroidism or something?
08:54:33 <shapr> that's all I can think of that speeds up metabolism
08:54:56 <Marvin--> yeah
08:55:02 <Marvin--> found out about it last fall
08:55:42 <shapr> I've heard it gives you lots of energy. I'm not overly jealous :-)
08:55:51 <shapr> I do wish I had more urge to leave my computer though.
08:56:26 * shapr is only slighly jealous
08:57:46 <Marvin--> it also caused palpitation
08:57:53 <shapr> oh. that sucks.
08:58:04 <shapr> I've had that, it can be scary.
08:58:33 <shapr> mine got better when I stopped drinking so much coffee. (and switched to amphetamines ;-)
08:58:59 <shapr> prescription amphetamines of course.
08:59:29 <Marvin--> which is why I ended up in the hospital over the weekend last fall
08:59:34 <Marvin--> with chest pains
08:59:36 <Marvin--> scared the hell out of me
08:59:47 <shapr> :-(
09:00:16 <shapr> Marvin--: I hope it's better now
09:00:25 <shapr> hiya aFlag, how's your colors today?
09:01:33 <Marvin--> shapr: well, I'm just fine, but I'm still medicating and will be for quite some time
09:01:41 <aFlag> i'm all colourful today, i was playing warcraft 3 until 5am today, now i'm happy again :D
09:01:49 <shapr> aFlag: that's good to hear
09:01:49 <Marvin--> shapr: and, my metabolism seems to be down, as evidenced by the belly :/
09:02:04 <shapr> Marvin--: well, your belly had an unfair advantage before
09:02:21 <aFlag> who need girls, i have blizzard!
09:02:40 <shapr> honestly, I like girls better. but blizzard is nice too.
09:03:55 <aFlag> hehe
09:13:27 <shapr> g'day dons
09:20:57 * shapr hOps cheerfully
09:22:10 <shapr> dons: hs-plugins is nifty
09:23:15 <shapr> gutenabend pesco 
09:23:27 <pesco> hoi
09:24:21 <pesco> I'm looking for a good book on type theory. Can someone recommend one?
09:25:17 <shapr> Types and Programming Languages by BJ Pierce
09:25:23 <shapr> aka TaPL here on #haskell
09:25:38 <pesco> That sounds good.
09:25:47 <shapr> it has a punny cover picture of bricks. It feels sort of like a brick too.
09:25:57 <pesco> *g*
09:26:10 <shapr> would make a decent self-defense weapon in many cases.
09:28:32 <pesco> Cool. Thanks for the pointer.
09:29:15 <Marvin--> we use our Calculus books (Adams) as hammers
09:29:44 <Marvin--> or mallets, I should say
09:32:11 <shapr> I was thinking Amazon and other online book sites should add a weight rating to each book.
09:34:42 <pesco> shapr: Do you also have a pointer to a book on the semantics of programming languages and program verification?
09:35:17 <pesco> I need to import some theory.
09:35:21 <shapr> um, I had some semantics pointers, but I haven't gotten far enough to order and try any of them.
09:35:32 <pesco> Anyone else?
09:35:45 <shapr> TaPL barely touches on denotational semantics.
09:35:57 * pesco nods.
09:36:25 <Smerdyakov> pesco, http://www-2.cs.cmu.edu/~rwh/plbook/ has semantics of PL.
09:36:44 <shapr> there's an interesting thread right now on the mailing lists, it's mostly started and continued by The Oleg
09:36:58 <pesco> :)
09:37:11 <Smerdyakov> More traditional PL semantics is covered in "The Formal Semantics of Programming Languages," by Glynn Winskel.
09:37:14 <shapr> as for program verification, you should talk to Lor when he's on, he's very knowledgable about that sort of thing.
09:37:23 * Smerdyakov waves his hands about.
09:37:26 <Smerdyakov> So am I!
09:38:38 <shapr> I've discussed program verification with Lor, esap, and some others here, but I haven't discussed it with you, so I wouldn't know one way or the other.
09:38:52 <pesco> What do you mean by "more traditional pl semantics"/
09:39:14 <Smerdyakov> pesco, no types. :)
09:39:21 <pesco> ew.
09:39:27 <shapr> Lor said that type-safety of hs-plugins and anything else of that flavor is only as type-safe as Haskell's Dynamics. What sort of limitations does that imply?
09:40:00 <Smerdyakov> I don't know, since I don't know about these Dynamics.
09:40:01 <shapr> I know that Lor is a fan of proof-carrying code, I wonder if type-carrying code would be a decent stopgap measure.
09:40:09 <pesco> Haskell's Dynamics means the Dynamic type?
09:40:13 <Smerdyakov> Type-carrying code is a form of proof-carrying code.
09:40:15 <shapr> yup
09:40:31 <Smerdyakov> Though I've not heard the phrase "type-carrying code" used by researchers.
09:40:44 <Smerdyakov> But the usual PCC strategies all rely primarily on types.
09:41:07 <shapr> so, hs-plugins does parse the .hi file, maybe a .o with its .hi would be PCC?
09:41:41 <Smerdyakov> pesco, I could swear there's a textbook about something like "Logic in Computer Science" with Edmund Clarke as a co-author, which treats introductory program verification, but I can't find it on his publications list.
09:42:10 <Smerdyakov> shapr, that's unlikely. You need more type information than just what's in the interfacer.
09:42:42 <shapr> hm
09:42:49 <shapr> I'll have to get around to reading up on PCC at some point.
09:42:52 <Smerdyakov> shapr, Typed Assembly Language is probably what you would want.
09:43:19 <shapr> at the moment, I'll be happy if I can get hws-wp using hs-plugins.
09:44:21 <Smerdyakov> Chances are that getting a trustworthy certified code system for any current Haskell compiler would be a lot of work, on the order of the work it took to construct the compiler in the first place.
09:44:25 <pesco> Do you know any of the following books? They are from the literature list of my semantics course. "The Science of Programming" (Gries '81), "Foundations for Programming Languages" (Mitchell, '96), "Theories of Programming Languages" (Reynolds, '98)
09:45:09 <Smerdyakov> pesco, I read part of the first one. I think it's one big introduction to axiomatic semantics.
09:45:20 <shapr> I've heard rumors that something alongs the lines of a proof of GHC is being done by an organization that has both the interest and the resources to do it.
09:45:36 <Smerdyakov> pesco, I think I've read part of the second one as well.
09:45:39 <pesco> "an organization"?! :)
09:45:55 <shapr> yup
09:46:14 <Smerdyakov> pesco, oh, wait, I haven't.
09:46:23 <Smerdyakov> shapr, what do you mean by "a proof of GHC"?
09:47:14 <Riastradh> Presumably, a mathematical verification of GHC's correctness.
09:47:21 <shapr> yes, something along those lines.
09:47:22 <Smerdyakov> What is "GHC's correctness"?
09:47:49 <Riastradh> Along the lines of VLISP, the Verified Lisp project.
09:48:11 <Smerdyakov> What is the idea of correctness there?
09:49:20 <Riastradh> I gave you the name of another project deliberately so that you could look up what VLISP entailed, because I don't know many particulars off of the top of my head.
09:50:06 * shapr sings along with Bob Marley
09:50:26 <Smerdyakov> Riastradh, it's old. :(
09:50:32 <Riastradh> Oh dear.
09:50:54 <Riastradh> I'm horrified by this stunning revelation.
09:51:25 <Smerdyakov> It seems a non-trivial job to find even an abstract for any work on that.
09:51:35 <Riastradh> Try looking on readscheme.
09:51:50 <Riastradh> I believe it has references to every paper published regarding VLISP.
09:54:31 <Riastradh> s/references to/links to copies of/1
09:55:20 <Smerdyakov> OK, indeed, a treasure trove is there found.
09:55:28 <Smerdyakov> It seems they are proving semantic equivalence.
09:56:00 <Smerdyakov> Which is probably not directly relevant to guaranteeing safety of dynamically loaded code.
09:58:00 <shapr> aha
09:58:06 <shapr> hej cm_, vad h‰nder?
09:58:40 <shapr> vill du l√§r dig att anv√§nda Haskell?
09:58:54 * shapr vill l√§r Haskell att anv√§nda svenska...
10:00:02 <Igloo> Can anyone confirm that Estonia wants the same sort of power whatsit that Sweden did?
10:00:44 * shapr har ingen aning
10:00:47 <shapr> er, no clue
10:01:39 <Marvin--> the what now?
10:02:04 <shapr> the power plug in the wall, for laptops etc
10:02:23 <Marvin--> oh, hmm
10:03:29 <Marvin--> according to http://kropla.com/electric2.htm yes
10:03:47 <Philippa> 'lo cm
10:05:10 <Igloo> I found that but got all confused by Cs, Es and Fs  :-)  But I suspect the convertors do the most generic one anyway, so I'll assume it's OK. Thanks  :-)
10:23:30 <musasabi> shapr: please use iso-8859-1 ;)
10:23:46 <pesco> Hm? Isn't freenode UTF-8 land?
10:27:08 <Marvin--> musasabi: we like utf-8 thank you very much
10:28:25 <Igloo> Can't represent all Haskell code without it  :-)
10:35:01 <pesco> shapr: You said something about protocol combinators the other day, remember?
10:41:57 <pesco> shapr, do you read? Please respond *crackling in receiver*. shapr, I repeat, do you remember? *crack* *fzzz* scrrr *fzz* units... *brzt* *blamm* *ratatat* ...verify station *br* grity... *moeahm* *brfzzzztzzzzz*
10:50:09 <RussellOConnor> pesco: I recommend Type Theory and Functional Programming by Simon Thompson.
10:50:41 <RussellOConnor> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
10:58:23 <pesco> RussellOConnor: Thanks.
11:07:40 <musasabi> Marvin--: so how do I make irssi have per-channel encodings?
11:08:19 <musasabi> as all local channels use non-utf-encodings...
11:10:32 <Marvin--> I have no idea
11:11:12 <Marvin--> I don't see that it matters much, there's very rarely "non-ascii conversations" going on here
11:11:21 <Marvin--> mostly it's when shapr mixes up #haskell and #haskell.se ;)
11:16:34 <pesco> *g*
11:17:07 <musasabi> #haskell.se is utf-8 ?
11:17:34 <Marvin--> yeah, and in Swedish ;)
11:27:13 <musasabi> Swedish is not a problem per se.
11:28:46 <musasabi> What is the best way of store large amounts of utf-8 text with ghc?
11:29:46 <pesco> What do you mean? Store in a file, or store in memory?
11:29:56 <musasabi> Data.PackedString seems to be still not very dense.
11:30:22 <musasabi> pesco: in memory - loaded and written from/to the disc.
11:31:04 <pesco> Would [Word8] be good?
11:31:38 <musasabi> pesco: that would pay the list penalty.
11:31:43 <pesco> Please note the distinction between Unicode and UTF-8, btw.
11:31:49 <musasabi> I don't need to actually do anything with the text.
11:32:10 <pesco> musasabi: Yes. What about an IOUArray of Word8?
11:32:55 <Marvin--> if you don't need to do anything with it, what about Ptr Word8
11:33:24 <musasabi> That could work.
11:33:28 <pesco> Which reminds me, has anyone got a suggestion on what to use best to represent long vectors (i.e. dim > 100)
11:33:33 * Marvin-- whines a bit about the mouse not working properly in the latest unstable version of galeon but notices that there are already 5+ merged bugs about it
11:33:45 <musasabi> Marvin--: how would I do io with them (Ptr Word8)
11:35:20 <Marvin--> musasabi: hGetBuf and hPutBuf (System.IO)
11:35:52 <Marvin--> hPutBuf :: Handle -> Ptr a -> Int -> IO ()
11:35:58 <Marvin--> hGetBuf :: Handle -> Ptr a -> Int -> IO Int
11:36:50 <RussellOConnor> @type System.IO.hGetArray
11:36:52 <lambdabot> bzzt
11:37:03 <RussellOConnor> @type Data.Array.hGetArray
11:37:05 <lambdabot> bzzt
11:37:14 <RussellOConnor> @type Data.Array.IO.hGetArray
11:37:16 <lambdabot> Data.Array.IO.hGetArray :: GHC.IOBase.Handle
11:37:16 <lambdabot> 			   -> Data.Array.IO.Internals.IOUArray Int GHC.Word.Word8
11:37:16 <lambdabot> 			      -> Int -> IO Int
11:37:35 <musasabi> Marvin--: nice.
11:40:54 <musasabi> hmm why is the Ptr/Array argument not inside IO?
11:41:14 <RussellOConnor> The fact that the result types are in IO means the functions are inside IO.
11:41:42 <RussellOConnor> @type (>>=)
11:41:44 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
11:41:55 <musasabi> 'hGetBuf :: Handle -> Ptr a -> Int -> IO Int' instead of 'hGetBuf :: Handle -> Int -> IO(Ptr a, Int)'
11:42:25 <RussellOConnor> You need to allocate Ptr before hand in some complex incantation that I don't know. ;-)
11:42:37 <RussellOConnor> That's why I used hGetArray
11:42:43 <pesco> musasabi: The caller is responsible for allocation of the required space.
11:42:59 <RussellOConnor> The array needs to be allocated with hGetArray too, but at least I know how to do that.
11:43:03 <pesco> @type Foreign.Marshal.Array.allocaArray
11:43:04 <lambdabot> Foreign.Marshal.Array.allocaArray :: forall b a.
11:43:04 <lambdabot> 				     (Foreign.Storable.Storable a) =>
11:43:04 <lambdabot> 				     Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:43:42 <Marvin--> musasabi: it's basically C :)
11:44:02 <Marvin--> this way, you can allocate the buffer once and reuse it, in a very efficient way
11:44:24 <RussellOConnor> How does using Ptr a compare with using IOUArray?
11:44:55 <Marvin--> I don't know
11:45:10 <musasabi> Marvin--: can I do arithmetic with Ptrs ? (just got to know)
11:45:24 <Marvin--> I suspect the IOUArray is basically just a wrapper around a Ptr
11:45:46 <Marvin--> musasabi: sure, look in Foreign.Ptr
11:46:01 <Marvin--> there's even castPtr :: Ptr a -> Ptr b if you're not squeamish
11:46:24 <Marvin--> I'm off to the supermarket before it closes, bbl
11:48:09 <musasabi> hmm all the evil of C at my disposal ^_^
11:51:22 * SyntaxNinja tries to picture a country where the supermarkets close
11:52:12 <Smerdyakov> SyntaxNinja, never been to the USA? :)
11:57:31 <RussellOConnor> A more reasonable function to read a file:
11:57:39 <RussellOConnor> readBinaryFile :: (IArray a Word8) => Handle -> IO (a Int Word8)
11:57:40 <RussellOConnor> readBinaryFile fh = do filesize <- liftM fromInteger (hFileSize fh)
11:57:42 <RussellOConnor>                        arr <- newArray_ (0, filesize-1)
11:57:43 <RussellOConnor>                        hGetArray fh arr filesize
11:57:45 <RussellOConnor>                        freeze arr
11:58:04 <RussellOConnor> Perhaps you want to remove the last freeze arr.
11:58:59 <pesco> But that's not an IArray then, or is it?
11:59:35 <RussellOConnor> If you remove the last freeze you will get an IO (IOUArray Int Word8) I believe.
12:00:16 <pesco> Oh, right.
12:00:28 <RussellOConnor> I like to pretend the copy in the freeze will be optimized out, but I fear it is not.
12:00:56 <RussellOConnor> You may wish to replace freeze with unsafefreeze.
12:05:17 <stepcut> i wonder if it would be possible to write a mini-language which could be used to specify a sort order for two arbitrary strings -- and be able to statically determine if the sorting algorithm will always terminate (and perhaps even better, terminate in less than n steps)
12:09:57 <Spark> that sort of things been done for lots of cases though hasnt it
12:10:12 <Spark> and theres no algorithm that does it in the most efficient way for an arbitrary list
12:10:17 <Spark> it breaks down at n=19 or something
12:10:52 <stepcut> any idea what I should search for on google to find out more information ?
12:11:44 <musasabi> is it possible to modify an ioref with a function like "fun :: a -> IO a" ?
12:12:13 <musasabi> modifyIORef wants the function to be a -> a
12:13:31 <Spark> stepcut: i dont see why you'd want a language for that, or sorting 2 strings
12:14:09 <Spark> and its not really an algorithm if you're specifying the order of comparisons in the specific case
12:14:20 <Spark> or have i misunderstood :)
12:16:51 <stepcut> I have a bunch of projects that have version strings, and for each project I want to be able to show the history of the project in cronological order. But each project has it's own policy for versioning. So, I would like to be able to store a little file with each project that specifies a compare function, so I can then sort the project correctly without having to know the rules ahead of time
12:16:57 <Lor> Evening, folks.
12:17:16 <stepcut> but, I want to make sure that the compare function will always terminate in a reasonable amount of time
12:17:31 <Smerdyakov> stepcut, only allowing primitive recursion is a good tactic.
12:17:39 <pesco> Ah, hello Lor, did you get my message?
12:17:46 <Lor> Yes, just got it.
12:18:02 <Lor> I don't really know much about program verification beyond type systems.
12:18:05 <stepcut> Smerdyakov: what is an example of primitve recursion
12:18:05 <Lor> Ask ibid. :)
12:18:39 <pesco> Lor: Ok. Thank you.
12:18:53 <Lor> As for semantics of programming languages, there are lots of books on the subject, but I haven't really read very many of them.
12:19:21 <Lor> Mitchell's "Foundations for Programming Languages" is the most comprehensive of the few I have read, but it is not the easiest text in the world.
12:19:30 <Smerdyakov> stepcut, you can find it in most books on mathematical logic. You can only make "recursive calls" on syntactic subterms of the current argument.
12:19:37 <pesco> Lor: Ok...
12:20:07 <Spark> Smerdyakov: is this like the idea of energy functions to prove that a recursive neural network is stable?
12:20:28 <Spark> if you can prove that f(iterative_step) for some f always decreases then ...
12:20:33 <Spark> (and has a lower bound)
12:22:03 <stepcut> Smerdyakov: does this look like what you are talking about: http://www.tcs.informatik.uni-muenchen.de/~abel/foetuswf.pdf
12:22:47 <Smerdyakov> Spark, I am not familiar with that, but "energy functions" sound much more complicated.
12:24:00 <Smerdyakov> stepcut, that looks like it's about the sort of thing I mean, yes.
12:24:13 <stepcut> Smerdyakov: thanks!
12:25:23 <Spark> come on internet connection...
12:25:33 * stepcut is doing a mini-study of programming with predictable termination
12:25:38 <monochrom> Abel has a home page?!
12:25:47 <monochrom> (Abel as in "abelian" :)
12:26:06 <Smerdyakov> Often real implementations based on the idea use the familiar function call notation, but it's better to think of primitive recursion as a family of Y-like combinators that guarantee termination of their resulting functions.
12:26:57 <Spark> ah so that assumes that the definition of 'size' is predefined, rather than being specified by the programmer in the definition of the recursion itself
12:27:00 <Smerdyakov> Every inductive type has an automatically generatable primitive recursion scheme/combinator.
12:27:22 <Smerdyakov> Spark, the definition of size is number of rolls of the recursive type, basically.
12:27:50 <Spark> of rolls?
12:27:52 <Spark> is that its depth
12:27:54 <Smerdyakov> foldr is the primitive recursion combinator for lists, for example.
12:28:26 <Smerdyakov> Spark, it's a term from type theory, related to recursive/inductive type.
12:28:45 <Smerdyakov> Spark, we have type equations like int = unit + int.
12:28:49 <Spark> oh ahh i remember chatting about this before
12:28:56 <RussellOConnor> foldr isn't quite primitive recursive, because the tail isn't passed as a parameter.
12:28:56 <Smerdyakov> A "roll" operation is a convertor unit + int -> int.
12:28:59 <stepcut> right, I always thought of fold as a recursive function that will always terminate for finate lists.
12:29:00 <Smerdyakov> And unroll is the opposite.
12:29:06 <Smerdyakov> RussellOConnor, ah, right.
12:29:34 <stepcut> s/finate/finite/
12:30:03 <Spark> so the as10k1 assembler that only allows forward jumps is as expressive as primitive recursion
12:30:23 <Spark> since you can model the interpreter as a roll function
12:31:45 <Spark> foldl (state + instruction -> new state) [instructions] initial_state kinda thing
13:17:54 <SyntaxNinja> the debian policy manual should just give up and say "look at the list archives"
13:18:33 <stepcut> SyntaxNinja: having trouble?
13:18:40 <SyntaxNinja> no, just bitter.
13:18:50 <SyntaxNinja> I was looking for the actual rules of package descriptions
13:18:53 <stepcut> that's ok, i am very bitter at gnu make
13:19:15 <SyntaxNinja> stepcut: use cabal!
13:19:16 <SyntaxNinja> ;)
13:19:39 <stepcut> SyntaxNinja: I don't think cabal will help in this case :( 
13:22:32 <Marvin--> SyntaxNinja: package descriptions isn't exactly the most important part of the policy
13:23:47 <Marvin--> SyntaxNinja: did you see my and Daan's replies?
13:24:15 <SyntaxNinja> Marvin--: about the soname? yeah... I rebuilt it, but it still doesn't have the soname, even when I pass that param to configure. i don't know what's up.
13:24:42 <Marvin--> huh, even with my suggested changes?
13:26:23 <SyntaxNinja> which was to chagne --soname= into -soname,  right?
13:26:45 <Marvin--> er, not just that
13:26:57 <Marvin--> his code was   -Wl --soname=foo
13:27:02 <Marvin--> mine is  -Wl,-soname,foo
13:27:15 <SyntaxNinja> ok. lemmy fix.
13:32:11 <Marvin--> based on his description of the C++ <-> C problems, I'm feeling sorry for Daan :)
13:33:29 <SyntaxNinja> yeah, really.
13:35:53 <pesco> Marvin--: What's that? (C++ <-> C)
13:37:07 <Lor> C++ is a different thing from C, although oftentimes people claim to be programming in some bizarre language they call "C/C++"
13:37:18 <pesco> Note: Pesco has lots of C++ and C in his past.
13:37:23 <SyntaxNinja> Lor: that's a pet peeve of mine, actually.
13:37:25 <pesco> Lor: Eek.
13:37:38 <SyntaxNinja> especially when people put it on resumes.
13:37:42 <Marvin--> pesco: some issue regarding statically linking C++ and C code into the same executable
13:38:08 <Lor> C++ requires "extern C" for a purpose...
13:38:20 <pesco> Marvin--: Shouldn't that work perfectly with "extern C"?
13:38:59 <Marvin--> I don't know, it was an issue in wxhaskell
13:39:30 <pesco> AFAIK C++ can link to C code with no problems at all, and the same goes for C++ free functions if they are surrounded by extern C. But enough of that.
13:42:07 <Marvin--> I'm not familiar with the inner workings of wx and wxhaskell, so I'm not sure what the exact problem was
13:42:35 <Lor> how does dynlinking work with c++? You have to do manual demangling of symbols?
13:43:41 <Marvin--> how does the FFI work with C++? Is there a foreign import cppcall or something? Or do you have to mangle the names and use ccall?
13:44:05 <musasabi> Lor: sometimes people really code in a language that is C/C++.
13:44:20 <pesco> Marvin--: The latter. You'll be better off writing a C wrapper around the C++ and importing ccall's.
13:44:34 <musasabi> Lor: it is C, but with neat things from C++ taken in, without using OO to organise things.
13:45:05 <pesco> And still using the .c extension, of course, because the compiler doesn't care.
13:45:29 <pesco> Actually, I think that's only true for C++ comments, because the preprocessor doesn't see the extension.
13:46:54 <pesco> But it's still awfull to see // in .c files.
13:47:02 <Lor> It's legal C99.
13:47:04 <pesco> Ah well. I'll shut up.
13:47:08 <pesco> Lor: Is it?!
13:47:13 <pesco> I was not aware.
13:47:16 <Lor> Yep. Good thing, too.
13:47:25 <Lor> newline-terminated comments are handy.
13:47:25 <pesco> Ok, forget what I said then.
13:47:28 <pesco> True.
13:48:06 <SyntaxNinja> Marvin--: looks like that worked to fix the soname.
13:49:43 <Marvin--> great, so what is the soname?
13:50:30 <Marvin--> libwxc-0.8.so?
13:51:03 <pesco> soname? That rings memories of GNU libtool. Are you dealing with interface version numbers in the way libtool suggests?
13:51:40 <Marvin--> no
13:51:44 <pesco> Why not?
13:51:57 <Marvin--> because this is now our code :)
13:52:08 <Marvin--> er, s/now/not/
13:52:09 <pesco> What do you mean?
13:52:24 <Marvin--> Daan picked the soname
13:52:34 <SyntaxNinja> the soname is /usr/lib/libwxc-gtk2.4.2-0.8.so
13:52:46 <SyntaxNinja> but that /usr/lib is probably my fault, I was messing with the configure options
13:52:46 <Marvin--> FULL PATH?
13:52:47 <pesco> Ok, I thought it was about Cabal picking it.
13:53:28 <pesco> But sonames including release numbers _are_ a bad thing.
13:53:37 <Marvin--> SyntaxNinja: no, I don't think so, I tink it comes from the $(SHARED-PREFIX)
13:53:41 <Marvin--> pesco: indeed
13:55:12 <SyntaxNinja> Marvin--: I know. I changed that via configure when there was still no soname after the first fix I tried.
13:57:50 <Marvin--> I wonder if they'd object if I brought a sleeping bag to the supermarket and lived in the dairy corner
13:57:56 <Marvin--> it was nice and cool compared to my flat
14:00:00 <Marvin--> libwxc-gtk2.4.2-0.8.so would be a much saner soname
14:00:31 <Marvin--> of course, libwxc-gtk2.4.so.0 would be even saner
14:00:49 <Marvin--> I don't see why the libwxc soversion would be changed more often than the libwx_gtk soname
14:01:29 * SyntaxNinja goes home &
14:03:19 <Marvin--> in any ca-d'oh
14:13:12 <Marvin--> meh, maybe I shouldn't be "educating" Daan about this when it's Syntax's package
14:23:57 <palomer> can you match a not pattern?
14:25:47 <Marvin--> a wha?
14:26:18 <palomer> like (not Cow, horse) => horse
14:26:47 <Lor> You can first match a cow, and then match anything. The latter will then catch all not-Cows.
14:27:13 <palomer> Ooooh
14:27:13 <palomer> smart
14:27:31 <palomer> can you match constructor?
14:27:51 <palomer> like (_(hay,grass),horse) => horse
14:27:57 <palomer> where the _ stands for any constructor
14:28:02 <Lor> Nope.
14:28:11 <palomer> what? why!
14:28:41 <Marvin--> how would you expect type inference to work with that?
14:28:45 <monochrom> It is not well-understood.
14:29:07 <ihb> palomer: how would you know how to match the parts of the constructors, if you don't know which constructor it would be?
14:29:23 * esap 've been playing with one language feature that would do something quite similar. But it's difficult.
14:29:47 <palomer> ihb: if it cannot be inferred, it would have to be specified
14:30:17 <esap> One idea how to implement arbitrary constructor matching would be similar to what you see in OO, dynamic dispatch.
14:30:20 <ihb> palomer: (i'm not questioning you btw, it was actually an honest question :-))
14:30:40 <palomer> monochrom: oh, hullo monochrom 
14:30:46 <palomer> what do you mean by not well-understood?
14:31:18 <monochrom> that many questions such as those of ihb can be raised with no known satisfactory answer.
14:32:10 <monochrom> That means a few decades later you will see a language that does what you suggest, but not now.
14:32:19 <ihb> haha
14:34:47 <esap> how about having a class with an operation match :: a -> Maybe b?
14:35:02 <monochrom> I suppose there is another factor.  Sometimes it is well-understood, but the effort of implementing it doesn't worth the usage.
14:35:58 <monochrom> For example there is no theoretic problem if you also require the programmer to specify enough typing.  But how often will you use it?  I bet it is very rare.
14:36:09 <ihb> can anyone give a, preferably short, typical example of when you want to use Maybe types?
14:37:01 <monochrom> When I want a kind of poor-man's exception.
14:37:05 <esap> ihb: for example, to build reusable components out of common patterns.
14:37:58 <Lor> That silenced everyone. :)
14:39:16 <esap> I mean, matchId :: Expr -> Maybe String ; matchId (Expr (Identifier x)) = Just x ; matchId _ = Nothing. Then use f x | Just(y) <- matchId x = ...
14:40:44 <esap> lor: I see what you mean, I don't mean design patterns, I mean patterns as in algebraic datatypes.
14:41:59 <monochrom> Here is another application.  Sometimes you want to provide a function that takes optional parameters.  You can use Maybe for that.  In fact ocaml does precisely that, with some syntax sugar.
14:42:28 <monochrom> (Maybe in Haskell is called option in ocaml.)
14:44:51 <ihb> i read up on how the prelude defines it. that alone helped a lot. i see why it could be used to do exceptions now, and optional arguments. thanks.
14:44:55 <palomer> I think of data type instances as tuples, the first element being the constructor and the rest being the data of that constructor
14:45:05 <palomer> using this model, matching the any constructor would be very easy
14:45:53 <monochrom> If you write all your data as tuples and all your constructors as integers, certainly.
14:46:14 <palomer> monochrom: hmm?
14:46:31 <monochrom> #define NIL 0
14:46:36 <monochrom> #define CONS 1
14:48:57 <Marvin--> you'll run into problems with that though
14:49:15 <monochrom> Yes, some type safety is compromised.
14:49:25 <Marvin--> *some*? :)
14:49:26 <shapr> the midnight sun is gone :-( it's really dark now.
14:49:46 <palomer> summers gone, school time
14:49:55 <musasabi> It should be safe if the store is Write-Once.
14:50:01 <monochrom> It retains checks on arities :)
14:50:15 <Marvin--> palomer: meh, don't say that, it just reminds me that I'm not a student any more :/
14:50:35 <palomer> so, do we all agree on my implementation of wildcard constructors?
14:50:49 <monochrom> Yes.
14:50:56 <monochrom> I just have never needed it.
14:51:18 <palomer> I'm needing it
14:51:37 <shapr> schoool time
14:51:40 <Marvin--> have you considered looking into records that have the same field in several constructors?
14:51:45 <monochrom> That's interesting.  Could you describe how you need it?
14:51:55 <palomer> I've created a function datatype with the basic arithmetic operations as constructors 
14:52:05 <palomer> I'm writing a simplify_function function
14:52:13 <shapr> pesco: *crackling in receiver* that's a big ten-four good buddy, what's your forty? *more crackling*
14:52:18 <Marvin--> data Foo = F1 { x :: Int, y :: Char } | F2 { x :: Int, z :: String } | ...
14:52:23 <palomer> as a rule, I want anyop(f,Literal x) => anyop(Literal x,f)
14:52:52 <monochrom> Ah, then you shouldn't use different constructors for different arithmetic operations to begin with.
14:53:03 <palomer> monochrom: how should I do it then?
14:53:10 <pesco> shapr: *chrsssshhhhhh*
14:53:34 <Marvin--> I assume you have data Expr = ... | Expr :+ Expr | Expr :- Expr | ... or something similar?
14:53:46 <ihb> is there a good reason there's no magic way to tell a function to recurse? like "sum [] = 0; sum (x:xs) = x + R xs;" where R would be something that automagically called sum in this case?
14:53:46 <monochrom> This may work much better.  data Op = Plus | Minus;  data Expr = Expr Op Expr Expr | base case
14:53:58 <Marvin--> Right, what monochrom said
14:54:21 <palomer> Marvin--: I'm actually doing it in sml, but my constructors have the op names and take two function types as data (they're all binary).
14:54:38 <Marvin--> palomer: details, schmetails
14:54:46 <shapr> *frshhh* We're just outside of B Town, headin for Circle City, You know of any Beartraps down that way? *crshht*
14:54:49 <palomer> monochrom: oh, that's an idea
14:54:58 <Marvin--> palomer: a pretty standard idea actually ;)
14:55:15 <monochrom> f (Expr _ e0 e1) = ...  is possible.
14:55:16 * shapr used to listen to the CB on long drives around the USA
14:55:30 <shapr> eight days is a long drive.
14:55:40 <monochrom> g (Expr Plus e0 e1) = ...  is also possible IIRC; but if not, you know how to fix it.
14:55:52 <palomer> mutually recursive datatypes. hmm
14:56:40 <shapr> ihb: you should check out the 'Envelopes, Bananas, Barbed Wire, and Lenses' paper.
14:57:03 <ihb> shapr: online i supposed?
14:57:07 <shapr> yup
14:57:07 * esap also suggests "bananas in space" paper.
14:57:31 <shapr> I don't get paid to be an academic, so I won't suggest anything that's not freely available.
14:57:57 * shapr gets nostalgic about long ago car trips driving around the US.
14:58:33 <Marvin--> bah, category theory junk
14:59:14 <shapr> hei Lor, I had some program verification questions earlier :-)
14:59:24 <shapr> ah I see it was already discussed.
14:59:43 <Lor> I don't know squat about verification.
15:00:00 <ihb> shapr: any hint on what to search for to find an answer for my question?
15:00:04 <Lor> Given a formal semantics, I might be able to prove or disprove some trivialities about a program, but that's about it.
15:00:14 <esap> which program verification questions?
15:00:45 <shapr> ihb: well, I can give you a pragmatic answer, but that won't give you all the theory.
15:01:54 <ihb> shapr: any knowledge is always welcomed :-)
15:02:29 <shapr> pragmatically speaking a magical recurse combinator would leave you out of mutually recursive functions
15:02:47 <shapr> realistically speaking, Joy has ... at least three explicit flavors of a recursion combinator.
15:03:19 <monochrom> @type fix
15:03:21 <lambdabot> bzzt
15:03:23 <esap> One interesting variant is built with adjunction from 'swap'.
15:03:41 <ihb> shapr: i'm not sure i got much wiser, but thanks for trying anyway :-)
15:05:13 <esap> http://citeseer.ist.psu.edu/hasegawa97recursion.html has that recursion combinator.
15:05:58 <pesco> "Day changed to 11 Aug 2004" Bedtime. Good night everyone.
15:05:59 <shapr> the neat thing about those papers is that they factor out recursion as an explicit pattern, so that may be closer to the answer to your question.
15:05:59 <shapr> I think you could find a very detailed answer to your question by reading the Bananas, Lenses, etc paper, and then reading the papers that reference that paper.
15:05:59 <shapr> it's all about 'patterns of computation'
15:06:09 <shapr> ihb: also, there's usually not a need for a recursion combinator. it's normal for Haskell implementations to have what's called the "tail-call optimization"
15:08:13 <shapr> pesco: g'night!
15:08:13 <shapr> ihb: that automatically turns tail-recursion into a loop in the compiled code.
15:08:13 <shapr> ihb: ska du kommer till #haskell.se ocks√•?
15:08:16 * shapr lags horribly
15:11:44 <RussellOConnor> @type Control.Monad.fix
15:11:46 <lambdabot> bzzt
15:11:46 <shapr> ihb: which irc client are you using?
15:11:57 <shapr> @type mfix
15:11:57 <shapr> @type Control.Monad.mfix
15:11:58 <lambdabot> bzzt
15:11:59 <lambdabot> bzzt
15:12:03 <RussellOConnor> @type Control.Monad.MoandFix.fix
15:12:05 <lambdabot> bzzt
15:12:19 <RussellOConnor> @info fix
15:12:23 <earthy> @type Control.Monad.MonadFix.fix
15:12:24 <lambdabot> bzzt
15:12:36 <monochrom> fix :: ((x -> y) -> x -> y) -> x -> y
15:12:36 <monochrom> fix f = f (fix f)
15:12:52 <shapr> @index mfix
15:12:52 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
15:12:52 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
15:13:03 <shapr> @type Control.Monad.Fix.mfix
15:13:04 <lambdabot> Control.Monad.Fix.mfix :: forall m a.
15:13:04 <lambdabot> 			  (Control.Monad.Fix.MonadFix m) =>
15:13:04 <lambdabot> 			  (a -> m a) -> m a
15:13:07 <shapr> aha
15:13:16 <earthy> oh hell. bedtime.
15:13:22 <earthy> more category theory tomorrow
15:13:23 <shapr> g'night earthy!
15:13:33 <RussellOConnor> @type Control.Monad.Fix.fix
15:13:34 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
15:13:49 <earthy> which reminds me... I'm quite a bit closer to you now, shapr, than I normally am. :)
15:13:56 <shapr> where are you?
15:14:01 <earthy> Koebenhavn. :)
15:14:04 <shapr> oh nifty!
15:14:13 <Marvin--> hey, that's practically nextdoor
15:14:20 <earthy> practically. :)
15:14:22 <shapr> yah, feel free to drop by!
15:14:29 <earthy> pity I won't have time off to hop across the pond. ;)
15:14:32 <shapr> too bad
15:14:43 <Marvin--> you don't have to hop, we built this bridge, y'know
15:14:46 <earthy> (even though it's supposed to be 35 mins to malmo)
15:14:48 <esap> When discussing recursion, it's often useful to remember also fold :: (Functor f) => (f a -> a) -> Rec f -> a  [and data Rec f = In ! (f (Rec f))
15:15:00 <earthy> anyway, g'night.
15:15:17 <Marvin--> I'm off to bed too
15:15:24 <earthy> (and yeah, I know... I still got to experience the train-on-ferry thing though ;))
15:15:38 <Marvin--> hah
15:15:49 <earthy> but that was between germany and denmark
15:15:58 <shapr> earthy: so, are you coming to the next EuroHaskell just for the train-on-ferry? :-)
15:16:12 <earthy> I'd be flying then ;)
15:16:25 <Marvin--> with a train? *boggles*
15:16:30 * shapr laughs
15:16:46 <earthy> (found out there's flights from Niederrhein airport to Copenhagen about 2 days after I booked my non-refundable traintrip)
15:17:06 <earthy> (Niederrhein being some 30km from where I live... with good bus connections...)
15:17:08 <Marvin--> d'oh!
15:17:32 <earthy> well, makes the next EuroHaskell more of an option. ;)
15:17:49 <shapr> Well, you may want to fly into Gothenburg for EuroHaskell
15:19:23 <shapr> or maybe take the train to see the scenery!
15:20:02 <palomer> 		      | ((Plus(Variable x,Variable y)) as arg)  => if x = y then Times(Literal 2, Variable x) else arg
15:22:49 <earthy> hm. Gothenborg is from Brussels airport
15:23:09 <earthy> how far is Gothenborg from Copenhagen (or Malmo) by train?
15:23:53 <earthy> never mind
15:23:57 <earthy> nytol
15:24:05 <Marvin--> four hours, or something like that perhaps?
15:26:45 <Marvin--> well, I'm off to bed
16:26:48 <palomer> hrm
16:27:03 <palomer> aren't op and expression mutually recursive datatypes?
16:30:19 <monochrom> I can see why expression needs op.  I don't see why op needs expression.
16:33:40 <palomer> hrm
16:33:45 <palomer> I don't quite understand this implementation
16:33:51 <palomer> (because, well, I don't know haskell syntax)
16:34:00 <palomer> an expression has which forms?
16:34:08 <palomer> which constructors, I should ask
16:34:36 <monochrom> datatype op = plus | minus   datatype expr = expr of op*expr*expr
16:34:55 <palomer> the constructor and datatype can have the same name?
16:35:25 <monochrom> at least Moscow ML allows me to do that.
16:35:35 <monochrom> I am very bad at invention new names.
16:35:43 <monochrom> s/ion/ing/
16:36:18 <monochrom> ha smlnj does too.
16:36:54 <Riastradh> Why couldn't they?
16:38:09 <monochrom> I suppose you actually want to name them like "atom of int | compound of op*expr*expr"
16:39:53 <monochrom> Of course I'm just coming up with examples.  If you have other cases such as variables, quantified expressions, etc., go ahead.
16:42:01 <palomer> is there a reason why constructors can't be overloaded?
16:43:06 <Riastradh> How would you overload constructors?
16:43:29 <Lor> palomer, type inference.
16:43:37 <Lor> The same goes for overloading functions, and just about anything.
16:52:30 <Philippa> Lor: it's a bit more specific than that with constructors though - you can't overload constructors in the presence of type inference because the inference system'd be left with nothing to start from, whereas with functions you can at least start looking at the type of the parameter
16:58:19 <Spark> ada's polymorphism is all backwards
16:58:31 <Philippa> ?
16:58:47 <Philippa> I mean OK, being a military project Ada's kind of inherantly all backwards...
16:59:11 <Spark> you can extend records (structs) but in order to override a method you have to overload it
16:59:35 <Spark> so you end up with method(this : Object) and method(this : Fish) and method(this : Pike)
16:59:47 <Pseudonym> Eeek.
17:00:00 <Pseudonym> There was this article from years ago... can't remember where...
17:00:08 <Pseudonym> About the DoD dropping Ada in favour of a new language.
17:00:17 <Spark> of course it still needs to do late binding to work out which one to call so its very similar, just hte syntax is err 'wrong' :)
17:00:23 <Pseudonym> Which fitted its philosophy better.
17:00:29 <Philippa> Which DoD?
17:00:33 <Pseudonym> US
17:00:36 <Spark> dod is america isnt it
17:00:39 <Pseudonym> It was to be called "Rambotran".
17:00:40 <Spark> here its the something else
17:00:45 <Spark> lol
17:00:48 <Spark> GREAT NAME
17:00:59 <Spark> oh yeah its the MoD here
17:01:13 <Pseudonym> One of the things was it didn't have exception handling.  If a problem happened, the program was expected to be resourceful and improvise.
17:01:43 <Pseudonym> And if it couldn't achieve its final objective, it was expected to destroy itself, taking as many enemy programs as possible with it.
17:02:05 <Philippa> heh
17:02:42 <Philippa> I'd imagine it'd look a bit like the list monad - fire off a bunch of potential solutions and hope one hits the target
17:02:43 <Spark> lol
17:03:51 <Spark> they use C at work for quite a lot of stuff anyway
17:04:12 <Spark> you can train monkeys to write ada though
17:04:21 <Philippa> ah, it's like Java then?
17:04:26 <Spark> which is handy when you have an excess of monkeys
17:04:31 <Spark> hm not fully type safe
17:04:35 <Spark> i think you can still do bad stuff
17:04:42 <Spark> it does have dynamic checking though i believe
17:04:47 <Spark> ive only been looking at it for a week
17:05:04 <Spark> its got a really developed type system
17:05:08 <Philippa> "my program's crap, but at least it'll tell the soldier it's crap!"
17:05:10 <Spark> (compared to java)
17:05:23 <Philippa> yeah, it still gets cited when folks talk about ADTs
17:05:29 <Spark> so you can create a type for every variable practically
17:06:18 <Philippa> tell me more?
17:06:26 <Spark> which means you end up with Class_Ships_Motion_Data.Pain_Stations.Fish_Hugger.Bearing_Type is Range (0-359)
17:06:42 <Spark> and you can make it overflow automatically in the right way
17:06:59 <Spark> you just end up with names after names after names and it really gives me a headache reading it all
17:07:12 <Spark> Like_Reading_A_Fucking_Book_Written_Like_This
17:07:15 <Philippa> ah. Like somebody doing some really blatant type hacking in Haskell, then
17:07:35 <Spark> well its more the opposite of hacking
17:07:52 <Spark> hacking would be using a type that happens to already exist for the 'wrong' thing :)
17:08:18 <Spark> but you cant cast in the usual way i think, even though these things are all ints
17:09:11 <Spark> so you cant point the ship in the direction of 5 miles or 10 kg neither can you procede at a speed of 20 degrees :)
17:09:31 <Spark> i think thats why its used
17:10:44 <Philippa> Spark: type hacking in Haskell tends to refer to getting the type system to show impressive amounts about the computations involved, rather than doing anything broken
17:11:06 <Philippa> and yeah, dimensional analysis good
17:11:19 <Philippa> something I'll sit down and work out how to make Haskell do some day
17:11:42 <Spark> ah i get it
17:11:51 <Spark> thinking of it in terms of domains / ranges of functions and whatnot
17:12:08 <Spark> the units thing was dead handy in a level mechanics
17:15:46 <Spark> shit i wanted to go to bed at 9
17:15:52 <Spark> and now im droning
17:15:56 <Spark> no depth perception
17:16:00 <Spark> irc
17:16:07 <Spark> its like a club at 7:30
17:16:09 <Pseudonym> Damn 2D IRC.
17:16:13 <Spark> all the drugs have worn off
17:16:21 <Spark> the only people still dancing are zombified
17:17:02 <Spark> and you step outside into the city and the light dazzles you and everything is dead
17:40:09 <np_hard> so is haskell ever gonna run on the jvm or the clr?
17:45:01 <Philippa> Think there was a project to make a Haskell-like language do it, can't see Haskell itself anytime soon though
22:06:12 <ez4> how do i print out a message within functional code, i.e for debugging purposes?
22:07:36 <Pseudonym> If it's for debugging purposes only, you can use Debug.Trace.
22:07:54 <ez4> thanks
22:08:00 <Pseudonym> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
22:28:01 <Cale> the output of trace (at least on unix systems) will go to stderr, which is good :)
22:29:54 <Cale> and you should also be careful that using trace to print partially computed results will of course very likely change the strictness of the code and affect performance.
22:40:46 <Riastradh> Anyone offhand have a set of etags regexps for Haskell?
23:19:49 <pesco> Moin.
23:20:33 <Riastradh> 'Night.
23:20:42 <pesco> :)
23:23:47 <shammah> afternoon.
23:25:27 * Riastradh goes off to bed.
23:49:24 <shrimpx> so is anyone going to icfp 04?
23:49:33 <shrimpx> (anyone here)
23:53:15 <palomer> NO
