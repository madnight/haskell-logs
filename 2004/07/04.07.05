01:06:05 <shapr> good morning #haskell!
04:05:22 <shapr> Lor: you said that UUAG parsers were spiffier than Parsec, do you have any demo code along those lines?
04:06:30 <keverets> Cale: (setq indent-tabs-mode nil)  in his .emacs (or mark the whole buffer and "M-x untabify" to do it just once)
05:19:10 <Username249> what does <- in haskell mean ?
05:20:08 <arjanb> depends on where it's used
05:22:08 <Username249> for example "do x1 <- p0; x2 <- p1; x3 <- p2; ... xn <- p(n-1); pn"
05:22:16 <Username249> btw. is that valid haskell code ?
05:23:49 <Marvin--> yes, it's valid haskell code, and it's syntactic sugar for  p0 >>= \x1 -> p1 >>= \x2 >>= ... \xn -> pn
05:24:44 <Username249> i still dont get what >>= means. does "x >>= 3" mean that x gets the value 3 ?
05:30:02 <Marvin--> Username249:  m >>= f  basically means "evaluate m, and apply the function f to the result"
05:31:44 <Username249> okay if m is ie 100 and f ist sqrt then "m >>= f"  sets m to 10, right ?
05:31:59 <Marvin--> no no no
05:32:04 <Marvin--> m has to be a *monadic value*
05:32:11 <Marvin--> and there is no *setting*
05:32:19 <Marvin--> there are no assignments in haskell
05:32:29 <shapr> unless you're in haskell class.
05:32:41 <Username249> oh.
05:32:46 <andersca> shapr: haskell type class?
05:32:49 <Marvin--> shapr: damn overloaded natural language :-)
05:33:02 * shapr snickers
05:33:15 <Username249> i tried to understand sth. about monadic values, but i didnt get it , is there a good document about it.
05:33:47 <shapr> Username249: do you understand that a function can be a value just like an integer?
05:33:58 <Username249> i think yes.
05:34:20 <shapr> so, you know that you can put the number 1 into the value a
05:34:21 <bourbaki> hiho
05:34:22 <shapr> a = 1
05:34:25 <shapr> hi ho bourbaki 
05:34:31 <bourbaki> heh thanks
05:34:36 <Marvin--> hohi
05:34:43 <shapr> you can also put a function that adds one into the value f
05:34:50 <shapr> f = (\x -> x + 1)
05:34:59 <Username249> that was my yesterday lesson :)
05:35:03 <shapr> ok
05:35:29 <Username249> anonymous function and values.
05:35:40 <shapr> one more step up is to put the action of a function into a value
05:35:52 <shapr> it's like dynamite and a fuse
05:36:20 <shapr> or maybe it's like a rocket with fuel inside, but you haven't pressed the start button.
05:36:51 <shapr> if you have a function in a value, then you can use that function like a hammer on a row of nails
05:36:58 <shapr> map f [1,2,3,4]
05:37:08 <shapr> @eval map (\x -> x + 1) [1,2,3,4]
05:37:08 <lambdabot> [2, 3, 4, 5]
05:37:10 <Username249> yeah i understand the map example
05:37:34 <Username249> but what has this to do with ">>=" ?
05:38:01 <shapr> a monadic value is not yet evaluated
05:38:13 <Username249> this is hard to understand.
05:38:22 <shapr> it's just a bit different :-)
05:38:29 <shapr> C is really weird from the Haskell viewpoint :-)
05:38:43 <Username249> lol
05:40:27 <Username249> Okay, it is not a topic here, but as I was learing C (years ago) i needed like 3 hours and a good book, to get anything done, but i am now like 30 - 40 hours in heskell, and I still dont get the basics. :)
05:40:47 <Username249> err haskell. lol
05:40:53 <Marvin--> that's because your mind is TAINTED, TAINTED I SAY!!
05:40:59 <Username249> :)
05:41:19 <Username249> okay but is still dont get the >>= thing. Is it in YAHT ?
05:41:46 <Username249> I mean, an explanation for ">>=".
05:43:14 <shapr> monadic programming is just an abstraction like object oriented programming
05:43:44 <shapr> they're both ways of hiding complexity 
05:44:35 <shapr> have you read the nomaware monad tutorial?
05:45:39 <Username249> No ! It sounds good !
05:45:42 <Marvin--> ISTR pointing you to it yesterday, didn't I?
05:45:54 <Marvin--> maybe I'm misremembering
05:46:02 <Username249> let me take a look in the log... waitasec pls
05:46:51 <Username249> http://www.nomaware.com/monads/html/ <-- This one  ?
05:47:00 <shapr> yes, that one
05:47:11 <Username249> i have overseen it, i only looked in http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
05:47:29 <Marvin--> theo's tutorial is pretty good too
05:48:17 <Username249> nah, i got lost in the second one at the "StateTrans" part.
05:48:40 <Cale> Username249: have you looked at the list monad?
05:48:40 <Marvin--> but that was before we clarified the functions-as-values problem, wasn't it?
05:49:03 <Username249> Cale, i dont think so, but I looked in a lot, perhaps I simply forgot it...
05:49:04 <Marvin--> so if you look at it again, maybe it'll make more sense
05:49:17 <Cale> Username249: you should read what I wrote at the top of http://www.haskell.org/hawiki/UsingMonads perhaps :)
05:49:48 <Username249> Marvin--, I will try, but first i will read the nomaware stuff, it seems more elaborate
05:50:28 <Username249> or the wiki. Okay, i have a lot to read I think. :) Thanks again , guys.
05:50:31 <Cale> the list monad is the first one which you should try to understand, as it provides really solid, easy to understand definitions of return and bind
05:52:55 <Cale> Username249: All that bind does is apply a function (a -> m b) to everything in a container (m a), getting a bunch of new containers, and collecting them together into one (m b)
05:54:13 <Username249> AH ! A monad is sth like a set ?
05:59:58 <Username249> Congrats to the guys who wrote the haskell-wiki entry for list monads. It is very good to understand. I thing i Understodd >>= now. Thanks again !
06:09:37 <Username249> okay, i have to go to a course now -> "business studies" will be back in 2 hrs.
06:46:31 <shapr> Cale: that's a really nice explanation
06:47:37 <bourbaki> is there anything like monadic streams?
06:51:07 <shapr> what would that be?
06:51:30 <bourbaki> something like a reverse readln :)
06:51:53 <bourbaki> do blub <- readline  reads something from teh keys right?
06:51:57 <shapr> yah
06:52:17 <bourbaki> is there something in the other direction?
06:52:26 <bourbaki> to write on a socket or stream
06:52:53 <shapr> sure
06:53:14 <bourbaki> whats its name :)?
06:53:24 <shapr> putStrLn
06:53:30 <shapr> or hPut*
06:53:34 <shapr> @index hPutLine
06:53:35 <lambdabot> bzzt
06:53:37 <shapr> @index hPut
06:53:38 <lambdabot> bzzt
06:53:41 * shapr smacks lambdawar
06:53:42 <shapr> whoops
06:53:43 <bourbaki> bzzt ?:)
06:53:49 <shapr> gotta work on my aim
06:54:14 <bourbaki> sounds like a shorted :)
06:54:36 <shapr> it's short for "BZZT, thank you for playing! Your consolation prize is NOTHING."
06:54:53 <bourbaki> heh
06:55:24 <shapr> man, it's *so* time for me to add apropos
06:55:59 <Igloo> :-)
06:56:06 <Marvin--> @index hPutStr
06:56:07 <lambdabot> GHC.IO,System.IO,IO
06:56:09 <shapr> aha
06:57:33 <shapr> Igloo: what's the easy cheezy way to do apropos on a finitemap?
06:57:39 <bourbaki> has anyone of you written an irc lib that is usable like that?
06:57:54 <shapr> well, lambdabot is written in Haskell
06:58:10 <Igloo> Convert it to a list and filter with whatever predicate you want
06:58:16 <bourbaki> can i have a look at the source?
06:58:22 <Igloo> But the more sensible way would be to use a more sensible datastructure
06:58:30 <shapr> what's more sensible?
06:58:41 <Igloo> What do you want, just foo*?
06:58:44 <shapr> bourbaki: sure, www.sourceforge.net/projects/haskell-libs/ download lambdabot 2.0
06:58:55 <Igloo> Or do you want *foo* too? Or even *foo*bar*?
06:59:01 <shapr> I think *foo* is fine
06:59:42 * Igloo thinks
06:59:49 <Marvin--> *foo* is tricky
06:59:51 <shapr> gutenabend moista 
06:59:58 <Marvin--> foo* and *foo is easy
07:00:02 <Igloo> You might be better off just searching through the lot for *foo*
07:00:02 <Marvin--> and so is foo*bar
07:00:11 <Igloo> Yeah
07:00:23 <moista> shapr : guten tag
07:01:23 <moista> its 3 o'clock here ;)
07:01:36 <shapr> hm, same here.
07:01:37 <Igloo> I think anything faster will require 26^length space
07:01:41 <shapr> ick
07:01:47 <Igloo> Well, O(26^length)
07:02:47 <shapr> wouldn't a suffix tree take less space?
07:02:51 <Igloo> But messrs C, L and R might think differently  :-)
07:03:09 <Igloo> What's a suffix tree?
07:03:28 <shapr> it's one of those crazy datastructures people use for fast and efficient searching of text
07:04:15 <Igloo> Oh, you might be right, actually
07:04:33 <shapr> http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Suffix/
07:04:36 * Igloo gets confused
07:05:10 <moista> shapr : youre from the monash uni ?
07:05:36 <shapr> no, I just found that url
07:05:51 <shapr> bye!
07:05:56 <Igloo> Yeah, that should only be O(26*length*number)
07:06:20 <Igloo> IM O(26*length^2*number)
07:06:41 <shapr> re moista 
07:06:44 <moista> hi, can you tell me about the problem ?
07:06:47 <moista> hwdy
07:06:48 <shapr> which problem?
07:07:01 <moista> the O(26....) problem
07:07:35 <shapr> oh, I have a bunch of different strings and I want to search them for a substring
07:08:11 <moista> maybbe you allready know, but you have to prpare that string first.
07:08:37 <moista> you have to create a table for it .. ill search for a link
07:09:14 <shapr> well, I was thinking that suffix trees might allow me to search in less space/time.
07:09:23 <Igloo> If you mean KMP then that's not really appropriate here as what is being searched is fixed
07:09:35 <Igloo> And fairly small
07:09:48 <moista> this table will tell where to restart if the comparison fails at location n
07:10:01 <Igloo> That sounds like KMP
07:10:36 <Igloo> (in fact it's small enough I'm sure fmToList and filter would do, but hey  :-)  )
07:10:39 <moista> i guess characters in these string will be in random roder and i cant see how to use trees then
07:11:11 <shapr> actually, fmToList and filter is the easy solution
07:11:33 <moista> Igloo : but this procedure would always start from the beginning if failure
07:11:55 <moista> what means KHP ?
07:12:00 <moista> KMP ?
07:12:12 <Igloo> You take the branch corresponding to the next character in the substring you are searching for at each level. When you run out of substring you print out all strings at the current node in the tree
07:12:19 <Igloo> Knuth-Morris-Pratt or similar
07:14:46 <moista> yes this is the right thing
07:15:26 <moista> the script i'm currently reading als suggests the Boyer-Moore algo
07:16:34 <moista> that one is even more efficient but also more comlicated
07:18:15 <shapr> hi ho ham
07:25:03 <bourbaki> hi :)
07:32:05 <bourbaki> elmex: wheres aronal ;)?
08:01:24 <shapr> hey delYsid 
08:01:29 <shapr> ltns
08:01:35 <delYsid> ahh, I knew you'd hang out here :)
08:01:36 <delYsid> hi shapr
08:01:45 * Igloo sighs. I hate randomly occuring problems in threaded apps.
08:01:49 <delYsid> how's life?
08:02:03 <Marvin--> Igloo: your problem lies in the "threaded" part :)
08:02:11 <shapr> not very exciting, how's your life/
08:02:12 <shapr> ?
08:02:29 <Igloo> Tell me about it  :-)
08:02:57 <delYsid> Got a brand new display borrowed for 2 weeks for driver hacking.
08:03:00 <delYsid> very exciting actually
08:03:44 <shapr> larger display?
08:04:25 <shapr> maybe a MEMS display?
08:04:41 <delYsid> shapr: no, a 40 cell one (http://www.papenmeier.de/reha/products/braillezeilen/el_40se.htm)
08:06:12 <shapr> delYsid: nice, much smaller.
08:06:33 <delYsid> hmm, must be some unconscious reflection of the male psyche, whenever I talk with a sighted person about new braille displays, they ask me if it is a larger one :-]
08:06:54 <shapr> :-)
08:07:16 <Igloo> How come there isn't a common interface for displays, and hence a common driver?
08:07:30 <delYsid> because every vendor has a different wire protocol...
08:07:42 <delYsid> much like "Why there are different types of mice?"
08:07:46 <shapr> I think it's more because 40 chars feels a bit limiting to someone who uses a monitor.
08:07:51 <Igloo> So there's no good reason then?
08:08:02 <Marvin--> "because hardware sucks"
08:08:08 <delYsid> Igloo: Absolutely not, they could have agreed upon a common protocol...
08:08:08 <shapr> since LCD boxfront displays usually have more characters
08:08:11 <delYsid> but you know how it is.
08:08:13 <Igloo> Well, with mice there are different types of port they connect to and new features like extra buttons
08:08:26 <delYsid> Igloo: same for braille displays.
08:08:32 <delYsid> they've got keys on them, for navigation
08:08:43 <Igloo> Oh, and this is USB. Fair enough
08:08:45 <shapr> I'm surprised braille displays don't use USB and the standard input drivers.
08:08:52 <delYsid> and there are serial, usb, and even bluetooth braille displays
08:09:06 <Igloo> Is there going to be a standard for USB braille displays like there is for USB keyboards/mice?
08:09:30 <Marvin--> good god I hate ghc's stupid command line parsing
08:09:32 <delYsid> Igloo: No, most vendors go the "USB-to-Serial adapter built-in" approach
08:09:44 <Igloo> Ah  :-(
08:09:55 <Marvin--> not being allowed to write a space after "-i" sucks bigtime
08:10:02 <shapr> Marvin--: I agree
08:10:33 <delYsid> Igloo: well, in the beginning, that even was an advantage, I was able to use my new USB display via the kernel driver for one usb-to-serial adapter, needing no additional code.
08:10:44 <delYsid> these days, we support that in user-space, to be platform-independent.
08:11:01 <Igloo> It's only a short term advantage though
08:11:11 <Igloo> Even ignoring the platofrm independent bit
08:11:22 <Igloo> In the long term a standard protocol will make life much easier
08:11:38 <delYsid> yeah, but they dont *want* to agree on a common protocol.
08:11:47 <delYsid> would be much more work for each of the companies, for not much gain...
08:12:21 <delYsid> otoh, a braille display is damn simple to program, and they are usually helpful about specs.
08:13:41 <delYsid> Igloo: And most of the USB displays these days have a serial port too, so they'd have to implement two protocols, which is kind of ugly.
08:14:04 <delYsid> anyway, /me being awfully OT shuts up now
08:14:24 <Igloo> *nod* - and OT stuff here is common in quiet moments  :-)
08:14:54 <delYsid> ahh, a second #emacs, then :)
08:17:26 <Igloo> #emacs is like a second #haskell, yes  :-)
08:18:18 <Marvin--> grrr, Parsec's ParseError isn't an instance of Error
08:18:34 <shapr> can you make it an instance ?
08:19:26 <Marvin--> I hope so
08:19:26 * Igloo starts to wonder if my debugging prints have "fixed" my problem
08:19:40 <Marvin--> Igloo: not very uncommon
08:20:21 <Marvin--> hrmm, except that the constructors of ParseError aren't exported
08:20:26 <Marvin--> "!/¤#"
08:21:02 <Igloo> Is ¤ a key on your keyboard? What is it?
08:21:11 <Marvin--> ¤
08:21:15 <Marvin--> hmm, shift+4
08:21:18 <Marvin--> Swedish keyboard :)
08:21:27 <Igloo> But what does it mean?
08:21:32 <Marvin--> heck if I know
08:21:35 <Igloo> lol
08:21:44 <Marvin--> oh well, data Error = Parsec ParseError | FromString String
08:21:48 <ibid> i assume you are not seeing the euro symbol there? :)
08:21:56 <Igloo> No
08:21:56 <ibid> then it's the international currency symbol
08:22:08 <Igloo> An x with a ircle in the middle
08:22:11 <Igloo> circle too
08:22:16 <ibid> something that the swedish delegation forced down everybody's throat when latin-1 was being drawn
08:22:31 <Marvin--> go Sweden!
08:22:39 <Marvin--> (of course, it was removed in latin-15)
08:22:49 <ibid> probably one of the most useless symbols ever
08:22:57 <Marvin--> yeah
08:23:05 <Igloo> Ah yes, U+00A4 CURRENCY SIGN apparently
08:23:18 <ibid> i asked about euro because euro in -15 has the same code as the currency symbol in -1
08:23:41 <Igloo> Yeah, my cunning script tells me 'As latin-15: "!/Â€#"'
08:24:09 <ibid> and irc does not have content type information, so i had to check :)
08:24:16 <Igloo> Oh, only that's not quite equivalent to what you said as I was seeing it in Latin-1
08:24:21 <Igloo> Err, IM in UTF-8
08:24:38 * Igloo gives his brain a sharp tap on one side
08:28:28 * Igloo scratches his head at U+20A7 PESETA SIGN
08:33:04 * Marvin-- badly wants haskell support in ctags
08:33:55 <shapr> there's hasktags
08:35:54 <Marvin--> I know, but I'm using a vim plugin that calls out to ctags to generate a tags buffer
08:36:02 <shapr> ln -s ?
08:36:14 <andersca> I heard vim suxxors
08:36:30 <Marvin--> shapr: that won't be very helpful when I'm writing code in other languages :)
08:36:37 <Igloo> I heard Java is a lovely language
08:37:17 * Marvin-- laughs evilly as he rewrites syntax's parser from scratch
08:37:36 <bourbaki> does anyone happen to know if that gult bug is also in the newest ghc release?
08:38:54 <Igloo> gult?
08:39:23 <bourbaki> glut :)
08:39:38 <bourbaki> hm that .conf bug seems to be fixed
08:39:42 <Igloo> Oh; I don't even know what "that glut bug" is
08:40:28 <bourbaki> well n the old release there was a "bug" in that package.conf file
08:40:55 <bourbaki> they didnt link a file that was needed they fixed it though an the problem isnt existant anymore;)
08:41:19 <bourbaki> i just had to start my program again it wont like after it told me that there was an error in that linking
08:47:12 * Marvin-- needs another cup of coffee
08:47:34 <andersca> I tried a new kind of coffee today
08:47:36 <andersca> it was very nice
08:48:03 <desrt> andersca; you're the one that looks like frasier, right?
08:48:12 <andersca> grr
08:48:22 <desrt> heh.
08:48:46 <Marvin--> haha
08:50:01 <Username249> so , i am back.
08:50:16 <Username249> i mondaic parser, here I come.
08:50:44 <desrt> parsec?
08:52:46 <Username249> desrt, No I am currentyl sitting on a homework, in this homework I was given an LR grammar, and I have to build a mondaic parser for it.
08:53:09 <Username249> mondaic should be monadic.
09:01:47 <desrt> ah.
09:02:36 <desrt> i love how homework is more or less synonymous with reinventing the wheel
09:03:19 <shapr> well, if you don't do it in homework, you end up doing it in the workplace.
09:04:06 <bourbaki> you have to at least done it once to know how it works
09:07:47 <norpan> monadic parsers are nice
09:08:21 * shapr agrees
09:08:28 <norpan> although you'd want a good combinator library, like Parse[ck]
09:09:16 <bourbaki> does anyone have a link to an introduction to monadic parsers?
09:09:31 <shapr> the parsec tutorial is nice
09:09:39 <norpan> dito
09:09:42 <Username249> the deal is, that I try to solve this assignment for 4 days know, and i havent written a SINGLE line of code.
09:09:44 <shapr> but that's just for using a monadic parser
09:09:45 <bourbaki> does it also explain what it is?
09:09:50 <norpan> yes
09:09:59 <bourbaki> Username249 do you have some lecture slides about that?
09:10:01 <shapr> Username249: if you just want to solve it, read the Parsec tutorial
09:10:17 <shapr> if you want to understand it, it's a bit more work.
09:10:31 <bourbaki> i dont want to use the parser i want to know how it works :) maybe i can write a monadic l system ;)
09:10:31 <Username249> i basically still dont know what a monadic parser is. So i found out how a parser works, (with  action and goto tables and all that stuff) and i know now what a monad is, but i still dont get the connection :(
09:11:04 <shapr> a monad is a way structure computations in terms of values and sequences of computations using those values
09:11:38 <shapr> with a parser, that usually means you turn a string into a tuple of (Result,String)
09:11:40 <Username249> yeah I got it, a monad is like a "set" under C or Java, and you can use functions on it.
09:11:54 <shapr> it's not a set
09:12:06 <norpan> from a user's point of view, a Monad is something you can use "do" on :)
09:12:11 <shapr> it's a way of organizing things, like objects are a way of organizing things
09:12:12 <Username249> i meant like a set, it has similarities.
09:12:14 <Riastradh> A monad is a generalization of computation.
09:12:22 <bourbaki> http://cs-www.cs.yale.edu/homes/carsten/classes/s01/parser.hs
09:12:30 <shapr> Username249: you know how object oriented programming works?
09:12:42 <Username249> shapr, of course !
09:12:56 <shapr> ok, tell me, what's an object? ;-)
09:13:00 <Marvin--> wow, I don't
09:13:06 <Marvin--> OOP is way complicated
09:13:21 <norpan> monadic parsing is really simple actually
09:13:40 <bourbaki> http://www.cs.nott.ac.uk/Department/Staff/gmh/monparsing.ps does anyone know that paper?
09:13:50 <bourbaki> norpan do you have a good introduction to MP?
09:13:55 <shapr> yah, monadic parsing is where the structure of your computations is primary a nested set of transformations of String -> (Result,String)
09:14:06 <Username249> my english is not good enough, i fear, but an object is some sort of "blueprint" , with derivations and properties
09:14:10 <shapr> so you end up with (Result,(Result,(Result,String))) sort of thing
09:14:28 <shapr> Username249: now, could I do OOP programming from that description you just gave to me?
09:14:29 <norpan> shapr: it doesn't have to be
09:14:45 <shapr> true, but that's what's used in Meijer's paper on monadic parsing
09:14:50 <norpan> yeah
09:15:26 <Username249> shapr, no of course not, you should know how the syntax works, and what types are, and how derivation works, and all that stuff.
09:15:26 <bourbaki> and how do you apply the productions?
09:16:49 <shapr> Username249: it's the same kind of thing with monadic structuring, the idea isn't very complicated, but it has a lot of implications about how you structure your program to do it usefully.
09:16:53 <norpan> let's say you have a primitive parser that parses keywords, call it (keyword k), and a primitive parser that parses an identifier, now, if you want to parse the keyword "declare" followed by an identifier, you'd do this: do { keyword "declare"; i <- identifier; return (Declare i) }
09:17:07 <norpan> very easy
09:18:51 <Username249> norpan, but i dont think it is very easy, a much simpler solution would be in my opinion some_word_parser "declare" x :: k = x;
09:19:09 <Username249> so then i would know that k is a number value now.
09:19:49 <norpan> ok, let's say you have the following BNF
09:20:03 <Username249> and some_word_parser would be (String, Int) -> Int or so.
09:20:13 <norpan> i don't follow you
09:20:35 <Username249> norpan, no problem, i dont understand it myself.
09:20:52 <norpan> do you understand the general problem of parsing?
09:21:04 <norpan> you have a string and want to produce a haskell data type out of it
09:21:36 <norpan> so, you make a function that operates on that string, producing the data type
09:21:59 <Username249> norpan, i dont know exactly. if you wnat to parse, you have a lot of states, and a goto table, an action table.
09:22:04 <norpan> no
09:22:13 <Username249> and depending on the input, your lookahead and the stack you change states-
09:22:19 <norpan> that's just _one way_ to solve the parsing problem
09:22:28 <norpan> with a monadic parser you don't do it like that
09:22:46 <norpan> a monadic parser is basically a recursive descent parser
09:23:16 <Username249> okay, you got my total attention now.
09:23:44 <norpan> lets say you want to parse expressions
09:23:51 <Username249> reg exp ?
09:23:54 <Username249> okay..
09:24:07 <norpan> no, things like (1+3)*5
09:24:17 <Username249> ah of course. all clear.
09:24:32 <norpan> and you have a data type like this: Expr = Plus Expr Expr | Times Expr Expr | Number Int
09:26:05 <norpan> and, lets say you have these primitive parsers: (keyword k) which parses a keyword, and (number) which parses a number
09:26:20 <norpan> now, you want to combine these into a parser for expressions
09:26:56 <norpan> so, you write a function expr :: Parser Expr
09:27:11 <norpan> where the type Parser a is defined as String -> (String, a)
09:27:31 <norpan> like the state transformer you were talking about yesterday (they are the same monad actually)
09:27:55 <norpan> then you could write your parser like this:
09:28:46 <norpan> expr = do { n <- number; keyword "+"; e <- expr; return Plus (Number n) e }
09:28:56 <norpan> this only parses additions though
09:29:17 <norpan> so you need something to combine different parsers with
09:29:43 <Username249> not so fast, pls.... i still try to understand the expr... line...
09:29:48 <norpan> hehe
09:30:29 <norpan> don't you have lectures and classes explaing this stuff?
09:31:13 <Username249> norpan, not really, i have a script but it is more about grammars, then about haskell. for example the explanation for monads is 6 lines long.
09:31:24 <Username249> then should be than,
09:31:32 <Marvin--> yeah, it sounds strange to have an assignment on monadic parsers without first explaining monads and parsers...
09:32:31 <norpan> you could just teach monadic paring by example though
09:32:34 <norpan> parsing
09:32:45 <Username249> Marvin--, its true, but basically this course is more about grammars, than about haskell. we only use haskell for the understanding.
09:33:10 <norpan> errr
09:33:21 <norpan> why don't you just use flex or something :)
09:33:41 <SamB> norpan: C is a pain
09:34:01 <norpan> flex works for c++ too :)
09:34:03 <Username249> beacuse the professor ( Peter padawitz ) is an expert on haskell.
09:34:03 <Username249> http://ls5-www.cs.uni-dortmund.de/~peter/
09:34:12 <SamB> norpan: C++ is a bigger pain
09:34:13 <bourbaki> norpan in your example what does keyword "+" do?
09:34:24 <norpan> bourbaki: it parses the keyword "+"
09:34:38 <Username249> and I think he wants that more people should use haskell, so he tries to torture us poor students :)
09:34:42 <norpan> if the input string contains the string "+" it parses it, otherwise it fails
09:35:02 <bourbaki> ah ok
09:35:04 <norpan> contains was a bad word, substitute with "starts with"
09:35:20 <bourbaki> and n <- number does the same for the string right?
09:35:40 <norpan> bourbaki: yes, number parses a number if the input starts with a number, otherwise it fails
09:35:52 <norpan> and we use a monad to track the state, and also to handle failures
09:35:54 <bourbaki> what does it return if it fails?
09:36:05 <norpan> bourbaki: if it fails, it doesn't return
09:36:22 <bourbaki> so you just build all possible parsers or what?
09:36:35 <norpan> bourbaki: that depends on the implementation of the parser monad
09:36:38 <bourbaki> then parse the word or what ever to see if it returns?
09:36:45 <norpan> normally you'd return a list of parses
09:36:50 <norpan> and fail is the empty list
09:37:14 <norpan> so the type would then be String -> [(String, a)]
09:37:35 <norpan> but you could imagine other implementations as well
09:37:49 <norpan> one of the points of using a monad is that you don't have to know the implementation
09:38:15 <bourbaki> yeah well doesnt sound that thrilling to me though :)
09:38:25 <norpan> and can change the implementation for a more efficient one without rewriting your parser
09:38:35 <Username249> but norpan if you have a string like "4 + 5" how does haskell see the +
09:38:48 <Username249> and know that it has to compare with keyword.
09:39:00 <Username249> and how does it eliminate the whitespace ?
09:39:08 <norpan> it works like this, first it runs the number parser, the number parser eats the "4" and returns (" + 5", 4)
09:39:23 <norpan> Username249: yeah, if you want to handle whitespace you need a whitespace parser as well :)
09:39:43 <Username249> in c i would write sth like String mystring = "4 + 5"; if mystring.find('+') then ....
09:40:12 <norpan> Username249: no, thats not the way to do it, you want to be able to parse generic expressions, not just number + number
09:40:18 <SamB> monads are really, really, cool. I mean, what other language has first-class sequencing?
09:40:43 <Username249> i feel totaly retarded, how do you guys understand this stuff ?
09:40:59 <norpan> we have studied it for several years
09:41:23 <norpan> in general, i'd say it takes about two years to understand this
09:41:32 <norpan> if you're clever, you can do it faster
09:41:37 * SamB wonders when he started on haskell
09:41:42 <bourbaki> Username249 are you familiar with dual spaces in la?
09:41:59 <Username249> is "keyword" a function in haskell ?
09:42:16 <norpan> yes, keyword is another function
09:42:16 <bourbaki> dual spaces and monads are quite similiar to me does anyone think so also?
09:42:17 <Igloo> It's not a standard function
09:42:19 <Username249> bourbaki, no, what is LA ? and what are dual spaces ?
09:42:22 <SamB> Username249: it is presumably from the parser combinator library you are using
09:42:27 <shapr> Username249: it's very (to me) much like making the jump into really thoroughly understanding OOP, at some point you see how it all works.
09:42:29 <bourbaki> linear algegra
09:42:33 <bourbaki> algebra
09:42:34 <norpan> keyword is probably a standard function in you parser combinator library
09:42:56 <bourbaki> keyword could also be implemented as such a parser again right?
09:44:20 <Username249> bourbaki, i forgot most of my math stuff.
09:44:31 <SamB> bourbaki: you mean, in terms of other combinators? yeah. I would expect it to be.
09:45:56 <norpan> maybe
09:46:17 <norpan> in a simple implementation, keyword could easily be a primitive operation
09:47:32 <Username249> in this example "expr = do { n <- number; keyword "+"; e <- expr; return Plus (Number n) e }" is expr the name of the function ? and, if you start with(4+5) doesnt it lose the 5 ?
09:47:33 <SamB> I actually don't understand what a monad *is* well enough to make a one-sentance description of one...
09:48:12 <Riastradh> A monad is a generalization of computation.
09:48:14 <norpan> like keyword x str = if x `isSuffixOf` str then [(drop (length x) str, x)] else []
09:48:21 <bourbaki> to me a monad is something that does some dual space conversion (return) and implements a dual space +
09:48:48 <bourbaki> (>>=)
09:49:07 <norpan> you could think of what a monad is in more ways than one
09:49:23 <norpan> and it pays to do that
09:50:03 <bourbaki> yep its just that dualspaces seem something that is really cool for computations imho and seems to be used in physics quite alot
09:50:36 <Username249> SamB, i am very new to this stuff, but I found it very easy, if you just think of a monad as some type of list, or set. with 2 function >>= and return. >>= just works a function on all entries of this list/set.
09:50:38 <norpan> what >>= means is very different depending on which monad you use
09:51:01 <bourbaki> sure but + can mean also alot in a field as a math structure :)
09:51:06 <norpan> in the case of a parser monad, a >>= b means "parse a, and then parse b"
09:51:23 <norpan> (providing that a suceeded)
09:51:38 <norpan> succeeded (how do you spell that bastard)
09:52:13 <bourbaki> :)
09:52:18 <norpan> and for parser monads, you also use MonadPlus
09:52:32 <norpan> because you want to run parsers in parallel as well
09:52:33 <bourbaki> to combine parsers right?
09:52:36 <norpan> yes
09:52:40 <norpan> alternative
09:52:52 <bourbaki> ah i see
09:53:19 <bourbaki> that is you add up all possible primitive parsers and then apply that big paerser recursively?
09:53:37 <Username249> okay i am reading the 10. tutorial now. this time I will read this one--> expr = do { n <- number; keyword "+"; e <- expr; return Plus (Number n) e }
09:53:49 <Username249> sorry, that one -> http://www.cs.nott.ac.uk/Department/Staff/gmh/monparsing.ps
09:54:56 <xkb> Is there anything like Clean's dynamics for Haskell?
09:55:30 <norpan> yes, Data.Dynamic
09:56:00 <xkb> is there any scientific documentation on how it was implemented/designed?
09:56:40 <norpan> oh, that's not dynamic types?
09:57:07 <xkb> norpan: no
09:57:09 <shapr> what do Clean's dynamics do?
09:57:26 <xkb> hmm.. how do you explain that in short..
09:57:48 <xkb> you can write and read stumps of code to and from disc or other IO
09:57:57 <shapr> oh, that's Binary
09:58:00 <xkb> and those are indeed dynamically typed
09:58:10 <shapr> err, stumps of code?
09:58:22 <shapr> Binary lets you save a value to disk
09:58:27 <xkb> stub is a better word I think
09:58:35 <shapr> if you want runtime reloading of code, hs-plugins is a good option
09:58:53 <xkb> Ill see if I can find a link for Dynamics
09:59:36 <norpan> clean is very interesting
09:59:38 <xkb> in manager speak:
09:59:39 <xkb> The Clean 2.0 type system combines the best of two worlds: static typing in the best functional tradition, and dynamic typing. Static types can be converted to dynamic types and vice versa in a type safe way. With dynamics you can exchange code and data in a flexible and type-safe way between Clean applications.
10:00:21 <xkb> ftp://ftp.cs.kun.nl/pub/Clean/papers/2004/vWeA2004-Esther.ps.gz
10:00:30 <xkb> a paper about a functional shell using Dynamics
10:00:36 <norpan> well, Data.Dynamic lets you use dynamic types in a type-safe way
10:00:53 <xkb> ok.. ill have a look at that
10:01:09 <norpan> but i don't think you can write them out to disk and read them in from another application
10:01:28 <xkb> thats the idea of dynamics amongst others
10:02:11 <xkb> I want to use them in my exception handling design
10:02:17 <xkb> or better, they are allready in use
10:02:37 <shapr> I think you can save them to disk
10:03:01 <shapr> but I don't have any code handy to prove that :-)
10:03:02 <norpan> maybe you can save them to disk if they are values, but how do you save computations
10:03:21 <xkb> norpan, thats the stub I was mentioning
10:03:39 <andersca> I heard norpan has skäggstub
10:03:40 <xkb> unevaluated pieces of the function tree
10:04:04 <norpan> andersca: i have more than that you konw
10:04:22 <andersca> norpan: I want to have a full, luxorious beard like you
10:04:41 <norpan> andersca: my kind of beard is not for everyone, you know
10:04:50 <andersca> norpan: I guess
10:04:58 <norpan> only real programmers get to have a beard like mine
10:05:25 <andersca> you and alan and rms
10:06:18 <norpan> why did you have to pick those smelly bastards
10:06:44 <Lemmih> alan?
10:06:49 <bourbaki> norpan :) show us your beard ;)
10:06:49 <norpan> alan cox probably
10:07:10 <norpan> i don't have a big beard, i'm just foolin around with andersca
10:07:48 <bourbaki> hehehe
10:08:27 <bourbaki> some of the real programmers you where reffering too might pass as terrorists ;)
10:08:36 <xkb> hehe.
10:08:42 <xkb> thats a nice site indeed
10:08:47 <xkb> forgot the url though
10:18:07 <shapr> hoi guido__ 
10:29:34 <ozone> xkb: probably the closest thing haskell has to clean's dynamics right now is hs-plugins
10:29:44 <ozone> (disclaimer: i worked with the hs-plugins author on it)
10:30:00 <ozone> that said, we're still a long way off from clean's dynamics
10:30:20 <ozone> but we do have some nice tricks of our own (e.g. fully staged compilation)
10:32:34 <xkb> ozone, ah sounds nice
10:32:43 <xkb> is there any design documentation on that?
10:33:02 <ozone> hmm, what do you mean by design documentation?
10:33:10 <xkb> papers
10:33:10 <ozone> hs-plugins's api is quite well documented, if that's what you're asking
10:33:20 <xkb> thats ok 2 :D
10:33:22 <ozone> if you're asking how it works, then there's one paper on it so far
10:33:26 <ozone> hang a sec ...
10:33:57 <ozone> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
10:34:09 <xkb> thanks :)
11:07:38 <bourbaki> does the return of a monad relate do a bilinear form?
11:07:45 <bourbaki> er relate to
11:10:03 <bourbaki> i mean you have something like V -> V^* which look like a return to me
11:13:45 <cptchaos> bourbaki: what do you mean with an bilinear form? (As in linear Algebra?)
11:13:55 <bourbaki> yep
11:14:34 <cptchaos> in genral an monadic computaion is not linear,
11:14:35 <bourbaki> V -> V^* is the same as V -> V -> k if V is a field over k
11:14:51 <bourbaki> ah ok but its roughly the same
11:15:02 <bourbaki> ok i see the prob with the liniarity
11:15:19 <bourbaki> but in the case of lists it would apply
11:15:44 <bourbaki> though they have no multiplication :)
11:17:01 <cptchaos> hm, I do not realy see an strong relation between linear forms and monadic computations
11:17:22 <cptchaos> maybe expect, that both could be functions
11:17:26 <bourbaki> yep
11:17:36 <cptchaos> ok
11:18:04 <bourbaki> to me dualspaces look like a monad of linar computations ;)
11:18:29 <bourbaki> and you need a bilinar form that does the return
11:18:48 <bourbaki> V x V -> k which is the same as V -> V^*
11:18:59 <bourbaki> wich to me looks like a retrun
11:19:22 <cptchaos> ok, linear spaces could be modeled as Monads (very well)
11:20:44 <bourbaki> and the >>= would be the dual mapping i dont know what the gain of that is i just think its interesting :)
11:21:03 <bourbaki> but you could apply maybe some interesting things if >>= is linear
11:22:26 <cptchaos> hm, somewere I saw a paper about duality concepts in haskell, but I don't remember where
11:22:40 <cptchaos> maybe somone here, has an Idea
11:23:34 <shapr> I've seen several
11:23:55 <shapr> I only remember Wadler's recent duality paper though.
11:24:03 <shapr> esap is the man when it comes to duality in Haskell
11:25:01 <bourbaki> cool i am always glad to see if someone has thought my thoughts already ;)
11:26:29 <bourbaki> and what is the cool thing about that way to look at haskell?
11:27:28 <cptchaos> hm, I don't remember anymore, when I read this, I was looking for some other info
11:27:52 <cptchaos> maybe you could ask esap
11:28:08 <bourbaki> sure
11:28:35 <cptchaos> if he stops idling
11:28:50 <bourbaki> its not too important really but its fun for me to unify different kinds of knowledge ;)
11:29:32 <cptchaos> I agree, it is fun :-)
12:14:13 <stepcut> anyone know if you can find all the instance declarations for a class that are currently in scope via TH (or perhaps even at runtime??)
12:15:21 <lambdawar> bourbaki: ENS ?
12:15:34 <bourbaki> ens?
12:18:47 <bourbaki> i know ents
12:18:56 <bourbaki> :) and ants but whats ens?
12:19:15 <Username249> is this http://cs-www.cs.yale.edu/homes/carsten/classes/s01/parser.hs a monadic parser ? if so, then why is there no monad ?
12:20:02 <shapr> Username249: there is a monad there.
12:20:50 * stepcut writes a scary proposal
12:20:59 <shapr> stepcut: oh, what is it?
12:21:05 <Username249> shapr, where ?
12:21:14 <shapr> has anyone set up SFS in debian?
12:21:18 <Lemmih> Username249: 'Parser'
12:21:19 <stepcut> shapr: it will be on haskell-cafe later today
12:21:30 <bourbaki> Username249 bind :: Parser a -> (a -> Parser b) -> Parser b
12:21:30 <shapr> Username249: first you have the type "type Parser a = String -> [(a, String)]"
12:21:36 <bourbaki> char :: Char -> Parser Char
12:22:22 <Username249> i thought all monads would be "class Monad m where...."
12:22:40 <shapr> nah, that's just for ease of use
12:22:56 <bourbaki> no thats the (joke) "classical" way ;)
12:23:04 <shapr> http://www.nomaware.com/monads/html/introduction.html
12:23:13 <Username249> shapr, i read that one
12:23:36 <shapr> how did it describe a monad?
12:24:01 <Username249> It is useful to think of a monad as a strategy for combining computations into more complex computations.
12:24:27 <shapr> do you remember what it said about the Haskell representation?
12:25:04 <shapr> anyway, the Meijer monadic parsers are just that, they let you easily connect a bunch of parsers together
12:25:04 <Username249> to be true, i cant remember
12:25:19 <Username249> i read the "graham Hutton" after that
12:26:13 <shapr> it says that a monad in haskell is 1. a type constructor 2. a function that builds values of that type and 3. a function that combines values of that type with computations that produce values of that type to produce a new computation that for values of that type...
12:26:45 <shapr> type constructor: type Parser a = String -> [(a, String)]
12:27:03 <shapr> well, sort of :-)
12:27:42 <shapr> look at the result and zero functions in that source
12:27:50 <shapr> and bind is part 3
12:28:15 <shapr> I think result is the monadic return there
12:29:00 <shapr> Username249: it's the difference between buttons and a zipper.
12:29:14 <Username249> because it returns a parser ?
12:29:52 <shapr> part 1. is the monadic type, that's "type Parser a = String -> [(a, String)]"
12:29:53 <Username249> I try really really really hard to understand it, but something is missing. i still dont get it.
12:30:16 <shapr> part 2. is the parser constructor, and that's "result v = \s -> [(v, s)]"
12:30:25 <Username249> okay, so ALL types, that are polymorpic and return a List are Monads ?
12:31:06 <shapr> no, a list by itself is an instance of a monad
12:31:37 <shapr> Username249: it really is like a zipper, you say how executable pieces are combined
12:31:59 <shapr> in some cases there are different but equally valid ways of combining stuff
12:32:09 <shapr> it depends on what outcome you want
12:32:34 <Username249> yeah perhaps this is my problem. "type Parser a = String -> [(a, String)]" Means i have a new datatype with the name of "Parser" that needs an Variable type to accept strings and OUTPUTS Lists of Tupels of strings and that parameter ? Is that right ?
12:32:55 <shapr> yup
12:33:24 <shapr> if you want to make a parser for a calculator, maybe that will be type Parser CalculatorCommand
12:33:39 <Username249> Okay, that is really simple. Such a data type is necesserary if you want to build a monad ?
12:33:44 <shapr> or maybe it's your grocery list, so it's type Parser GroceryList
12:34:08 <shapr> yes, you need a datatype like that
12:34:14 <Username249> And ClacultorCommand are FUNCTIONS like ADD, SUB, MULT and and and
12:34:20 <stepcut> yeah, my evil proposal draft is done. Now I need to take a break, and then proof read it :)
12:34:31 <shapr> no, CalculatorCommand is another type
12:34:35 <Username249> Arghg !
12:34:54 <shapr> but those types are Add Mult and so on :-)
12:34:59 <Username249> Okay type CalcCommand Int -> Int ....
12:34:59 <shapr> you got that right
12:35:27 <Username249> pls dont leave me now i am short before a breakthrough !
12:35:31 <shapr> :-)
12:35:59 <shapr> have you looked at the analogy? http://www.nomaware.com/monads/html/analogy.html
12:36:18 <Username249> so okay, would "type ClacCmd Int -> Int" be the correct type ?
12:37:05 <Username249> okay, i will look at the analogy, i am not sure if i read it. I am really not sure what I did the last 10 Hours.
12:37:21 <shapr> a monad is like pipes that go around inside your code
12:37:40 <shapr> it's good for automatically passing stuff, and defining how exactly things are passed around
12:37:56 <shapr> you can write a calculator that carries around one piece of memory
12:38:11 <shapr> and you only write the carrying around code in one place
12:38:25 <shapr> in the monad definition
12:38:38 <shapr> then when you combine a bunch of calculator commands, the memory goes around automagically
12:38:51 <shapr> but that's not so useful in a parser
12:39:16 <shapr> in a parser, it's handy to carry around two pieces, the representation of what you have already parsed, and the leftover bits of the string that you have not yet parsed
12:39:36 * stepcut listens to some chinese hiphop/r&b
12:39:57 <shapr> neither of those are very useful for writing a way to pass around failure of a computation
12:40:13 <shapr> but the maybe type can be a monad also, and it's a good monad for describing failure
12:40:29 <shapr> Username249: do you see the common idea in all three of those descriptions?
12:40:45 <Username249> i dont know.
12:40:47 <shapr> data Maybe a = Just a | Nothing
12:40:56 <Username249> i saw that like 1000 tiems
12:41:18 <Username249> is a monad like a function that calls other functions ?
12:41:38 <shapr> a monad is type, and two functions that have to fit with it.
12:41:43 <Marvin--> a monad can be many different things
12:41:49 <Username249> like if the parameter is like 3 i call the function x, if the parameter is like 6 i call function y
12:41:49 <shapr> maybe by itself is not a monad
12:42:05 <andersca> a monad can be many things
12:42:07 <Username249> return and bind >>=
12:42:10 * andersca tries coming up with a poem
12:42:17 <andersca> what rhymes with 'things'
12:42:25 <shapr> but, the maybe type with a good definition of return and bind, that is a monad
12:42:41 <shapr> andersca: sings, schwings, brings, flings, slings
12:42:58 <shapr> stings plings zings
12:43:08 <Username249> rings.
12:43:10 <shapr> Username249: so, what are three pieces of a monad?
12:43:24 <Username249> the type , the return and the bind ?
12:43:27 <bourbaki> andersca http://www.rhymezone.com/
12:43:31 <shapr> Username249: yes!
12:44:39 <Username249> okay but how stores the monad its values ?
12:44:58 <Username249> through its instance ?
12:45:56 <shapr> a monad is an organized and conventional way to explicitly pass on something
12:46:11 <shapr> the convention comes with the idea of a monad
12:46:22 <shapr> but you decide the organization
12:46:31 <shapr> hei XTL 
12:46:33 <XTL> Evening
12:47:01 <shapr> Username249: the same set of conventions are applied to all monads, but the exact organization depends on what that monad should 'do'
12:47:40 <shapr> your boss says that your code doesn't handle failure, it always assumes that it will succeed. He commands you to fix that.
12:48:19 <shapr> so you take your boring Haskell functions, and you tell them that instead of returning a boring Int when your user adds with the calculator
12:48:24 <shapr> now they return a Maybe Int
12:48:48 <shapr> Username249: do you want to go through every function in the entire calculator and add code to check for the Nothing or the Just Int ?
12:49:08 <shapr> I sure don't
12:49:39 <shapr> but instead, I can define in one place how types of Maybe Int get stuck together
12:49:51 <andersca> <andersca> Rupert: quote hp
12:49:51 <andersca> <Rupert> "Haskell is the least-broken programming language available today." --hp, 05-apr-04
12:49:53 <shapr> so I write the code there
12:49:57 <Username249> but you would have to rewrite every function
12:50:19 <Username249> an maybe int  addition is different then a Int addition
12:50:29 <shapr> Username249: if you start out using monads, you almost never have to change the functions, only the definition of >>= or maybe the type
12:50:47 <shapr> that's the great idea behind monads
12:51:09 <shapr> this funny symbol --->  >>=  means "plug stuff together"
12:51:18 <Username249> lol
12:51:22 <XTL> :)
12:51:37 <shapr> and the cool part is that you get to define how it all plugs
12:51:53 <shapr> suddenly, your boss is not happy with only knowing that your code has failed or not.
12:51:59 <shapr> now he wants useful error messages!
12:52:08 <shapr> rather than quit your job...
12:52:15 <shapr> you decide to use more monad wizardry
12:52:35 <shapr> you switch away from using Maybe Int, and switch to using Either Error Int
12:52:43 <XTL> shapr: I wonder if this kind of explanation is neatly written down anywhere (apart from the logs now)
12:52:59 <shapr> XTL: sure yeah, http://www.nomaware.com/monads/html/index.html
12:53:09 <shapr> nomaware tutorial is great
12:53:31 <shapr> now that you're using the Either datatype instead, you can return Either the successful Int
12:53:40 <shapr> or you can return the Error describing what got broken
12:53:57 <Username249> Yeah but you would have to write an error message in every function !
12:54:13 <XTL> Hm. I seem to have the link, but maybe I haven't read it.  I really need more time...
12:54:22 <Username249> like if you divide by zero you would have to rewrite the divide function, and would have to do sth like
12:54:35 <Username249> divide Int->Int->Int
12:54:58 <Username249> divide x 0 : Errormsg = "divide by zero error".
12:55:18 <shapr> ah, but the secret is that you've been using divide :: Int -> Int -> m Int
12:55:26 <shapr> or something to that effect
12:55:55 <shapr> or even smarter, you started out with monad transformers, where you can just plug in the new piece when you want it.
12:56:00 <Username249> so the ONLY trick about monads is, that m can be String or Int or Whatever ?
12:56:29 <Marvin--> m has to be some sort of container
12:56:53 <Username249> yeah in C it would be an pointer, that I could Cast in anything I would need.
12:56:58 <Marvin--> forget C
12:57:02 <Username249> is that right ?
12:57:03 <Marvin--> forget pointers
12:57:05 <shapr> no, the trick is that you can rip out all the wiring of your entire application, reorganize it, rewire it, and close the whole thing back up by changing the monad type, and the bind definition
12:57:24 <shapr> it's like circuitry lego
12:58:28 <Marvin--> list is a container type, Maybe is a container type, String and Int are not container types
13:00:10 <XTL> shapr: BTW it seems more takers for the next keep piling up here.
13:00:13 <shapr> hiya skew 
13:00:30 <shapr> XTL: I'm not surprised :-)
13:00:39 <shapr> serious geek points
13:00:56 <XTL> I'm trying to get rid of more stuff now  (http://www.cs.helsinki.fi/u/hhaataja/fi/myydaan.html) and I put it on the list.
13:01:08 <XTL> You're "first come" if you insist, of course ;)
13:01:36 <shapr> right, now I just gotta get to helsinki....
13:03:49 <shapr> I think I've seen a web page where someone demonstrated taking an interpreter through the nothing, Maybe, and Either stages
13:04:56 <Username249> okay so "type Parser a = String -> [(a, String)]" if i would like to parse "1+2" the first String would be the "still to do stuff" the list, would have ther results ? right ?
13:06:05 <shapr> no, a type of Int -> Int means "takes an Int, returns an Int"
13:06:12 <shapr> @type (1+)
13:06:14 <lambdabot> (1+) :: forall a. (Num a) => a -> a
13:06:24 <shapr> @type (+ (1 :: Int))
13:06:25 <lambdabot> (+ (1 :: Int)) :: Int -> Int
13:07:11 <shapr> the type String -> [(a,String)] means "takes a string, evaluates to a list of tuples, each of which are a pair of something, and a string"
13:08:16 <shapr> if you have  "data CalculatorCommand = ADD | MUL | NUM Int"
13:08:43 <shapr> and you want to go from "1 * 5 + 6" into something that is a series of CalculatorCommand
13:09:23 <shapr> then your type will be "type Parser CalculatorCommand = String -> [(CalculatorCommand, String)]"
13:12:24 <shapr> Username249: look at that url you pasted, it does the same thing, with + - ( ) and numbers
13:18:01 <Username249> okay, i read the analogy
13:18:25 <Username249> i think i understood it.
13:18:47 <Username249> the data Tray2 x = Contains x | Failed String            part is easy.
13:18:59 <Username249> I just dont get the instance part.
13:19:19 <Username249> what does the stuff after "...Tray 2 where" really mean ?
13:19:58 <Username249> (Failed reason) >>= _ = Failed reason  (what does this mean ?)
13:20:16 <shapr> the _ means "match anything and drop it"
13:20:37 <Username249> and reason is just a variablename ?
13:20:45 <shapr> so it means, if you bind a failure together with anything, only return the failure
13:20:45 <shapr> yes
13:20:53 <shapr> it's probably a text string that describes the failure
13:21:07 <shapr> but maybe it's a picture, I dunno how you want to describe failure
13:21:18 <Username249> Okay, that means if IN THE TRAY is Failed andsomeString i give back Failed andSomestring
13:21:44 <shapr> failed holds the string
13:22:01 <shapr> just like Contains holds the useful output
13:22:18 <Username249> What ?
13:22:37 <shapr> the type is Tray2 x
13:23:00 <shapr> if it's chopsticks, then data Tray2 Chopsticks = Contains Chopsticks | Failed String
13:23:02 <Username249> and it say x can Ieither be Contains x OR Failed String
13:23:11 <shapr> yes
13:23:35 <Username249> Contains is the name of the variable from the ttype x ?
13:24:14 <shapr> have you ever written any C code where you had to write it several times, once for int, once for float, and again for something else?
13:24:31 <shapr> where the code was exactly the same, except for the int/float/etc difference?
13:24:34 <Username249> yes i did
13:24:37 <XTL> hmh. m4 eats spaces after commas inside parens even though the output comes out fine otherwise.
13:24:48 <XTL> I hate adding ``quotes'' all around.
13:24:49 <Username249> basically it was exactly the same
13:25:02 <shapr> this "data Foo a" is the same thing, but you get to say what fits into the slot named a
13:25:15 <shapr> so it can be data Foo Int or data Foo Float or whatever
13:25:18 <XTL> Might be high time to look for something else to render html with.
13:25:28 <Username249> okay the TYPE of Foo is a ...... and a can be String Int or Whatever
13:25:30 <shapr> ever nicer, you never have to really say it, you just use it the way you want
13:25:51 <shapr> actually, Foo Float and Foo Int are different types, and they're not the same as Int or Float
13:26:22 <Username249> okay what does return = Contains mean ?
13:26:38 <shapr> do you know how typeclasses work in Haskell?
13:26:48 <shapr> if not, have you used interfaces in Java?
13:26:49 <Username249> i think,
13:27:10 <Username249> No i dont write Java regulary, i am more in writing C++
13:27:36 <shapr> well, an interface in java is a few names of methods, and the type signatures of those methods
13:27:43 <Username249> but I think i got this with the Typeclasses in Haskell, you mean that they can be polymorph ?
13:27:56 <shapr> sort of polymorphic
13:28:36 <shapr> in reality, it means that for each separate type, it can have its own code to do a certain thing
13:28:54 <shapr> there's an Eq class
13:28:55 <shapr> @info Eq
13:28:56 <lambdabot> -- Eq is a class
13:28:56 <lambdabot> class Eq a where {
13:28:56 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
13:28:56 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
13:28:56 <lambdabot>     }
13:29:09 <shapr> usually a class defines a set of operations
13:29:18 <shapr> if you create a whole new type, like complex numbers or something
13:29:20 <sorrow> Hey, that's a cool command. :-)
13:29:37 <shapr> then how they compare is completely different too
13:29:57 <shapr> so you write a new instance of Eq to show how they can compare to themselves and to other types too
13:30:07 <shapr> there's a typeclass for Monad as well
13:30:15 <shapr> @info Monad
13:30:16 <lambdabot> -- Monad is a class
13:30:16 <lambdabot> class Monad m :: (* -> *) where {
13:30:16 <lambdabot>     (>>=) :: forall a b. m a -> (a -> m b) -> m b;
13:30:16 <lambdabot>     (>>) :: forall a b. m a -> m b -> m b {- has default method -};
13:30:16 <lambdabot>     return :: forall a. a -> m a;
13:30:17 <lambdabot>     fail :: forall a. String -> m a {- has default method -};
13:30:19 <lambdabot>     }
13:30:49 <shapr> you only have to write the >>= and return implementations for your own type, the others two often work by themselves.
13:31:17 <shapr> if you've been reading these tutorials with a good memory, you know that return puts something into the container
13:31:34 <Username249> yeah okay, but in the tray2 example only return is defined right ?
13:31:39 <shapr> and and bind (aka >>= ) tells you how to stick together two containers
13:31:54 <shapr> no, three pieces are defined
13:32:04 <Username249> i can see return ....
13:32:05 <shapr> >>= and return and fail
13:32:14 <Username249> okay fail i see too
13:32:20 <shapr> greetings icb 
13:32:24 <Username249> but >>= isnt defined
13:32:39 <Username249> AHHHH !
13:32:40 <shapr> it is, it's defined in the 'infix style'
13:33:05 <Username249> it is once defined for types of the type x, and once for types of the type Failed ?
13:33:16 <shapr> that's called pattern matching
13:33:24 <shapr> man, you need to read a Haskell tutorial :-P
13:33:45 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
13:33:50 <Username249> i swear by everything i own that i read A LOT of tutorials !!!
13:34:44 <shapr> but you also need to understand what's in them to understand all of this.
13:35:02 <Username249> i think i got.
13:35:05 <Username249> it
13:35:21 <shapr> I would strongly suggest that you write some pure Haskell code to get the syntax and the basics.
13:35:23 <Username249> I Finally got it. he matches the tray against his list.
13:35:40 <shapr> huh? what list?
13:35:54 <Username249> (failed reason) >>=
13:36:01 <Username249> Cotnains x >>=
13:36:05 <Username249> return
13:36:09 <Username249> and fail reason
13:36:22 <shapr> the two lines with >>= are the same function
13:36:32 <Username249> against that list, not really a list i know, but he start at the top and compares down.
13:36:35 <shapr> return and fail are different functions
13:36:40 <shapr> yes, pattern matching
13:37:05 <Username249> like the mul example in the lambda complex tutorial.
13:39:01 <Username249> okay i will write my monadic parser now.
13:39:24 <Username249> Thank you all so much guys, especally shapr who had A LOT of patience.
13:40:35 <shapr> :-)
13:42:14 <XTL> One more taker for the cube. This one already has a slab to go with it :)
13:49:49 <Riastradh> Haskell ought to have reify & reflect.
13:51:51 <Riastradh> (They can't, of course, be defined in regular Haskell.)
13:57:05 <monotonom> reflection breaks certain free theorems and universality properties.
13:58:11 <monotonom> not to say that I am against it
13:59:32 <Riastradh> Such as?
14:02:09 <monotonom> Suppose f has type (forall a. a->a).  When the free theorems hold, we know that either f=id or f diverges.
14:02:34 <Riastradh> OK...
14:02:52 <monotonom> But if we have reflection, we can write: f x = if x is an integer then x+1 else x.  This is not id or divergence.
14:03:15 <Riastradh> Huh?
14:03:35 <monotonom> Unless my reflection is not the same as your reflection.
14:03:38 <Riastradh> Where do you get the operation that tells you if x is an integer?
14:03:53 <Riastradh> I'm talking about Filinski's monadi operators reify & reflect.
14:03:57 <Heffalump> reflection?
14:04:02 <Heffalump> oh, them.
14:04:07 <Riastradh> Monadic, even.
14:04:24 <Riastradh> reify :: Monad m => (() -> a) -> m a
14:04:33 <Riastradh> reflect :: Monad m => m a -> a
14:04:45 <Riastradh> However, reflect must be within a reify'd function.
14:05:22 <Heffalump> ahh
14:05:30 <Heffalump> I was thinking the other day I wanted something like that.
14:05:40 <Heffalump> how does it schedule the computations?
14:05:46 <Riastradh> It allows for direct-style code without breaking monads.
14:05:50 <Riastradh> Schedule the computations?
14:06:06 <Heffalump> suppose your monad is a state monad
14:06:30 <Heffalump> inside a reify, you do reflect (something side-effecting) + reflect (something else side-effecting)
14:06:37 <Heffalump> what order do they happen in?
14:07:28 <Riastradh> Hmm.  I suppose reflect is made a little complicated with laziness.
14:07:58 <Heffalump> laziness is mostly irrelevant, the same question would arise in a strict language
14:08:22 <Riastradh> Oh, never mind, right.
14:08:32 <Riastradh> It would occur in the order they are evaluated.
14:08:58 <Marvin--> so it's useful for commutative monads and use-at-own-damn-risk for non-commutative monads?
14:09:05 <Heffalump> SPJ has been saying for a while that we need a notation for commutative monads.
14:09:15 <Heffalump> isn't this is?
14:09:16 <Marvin--> right, that's what I was thinking of
14:09:19 <Heffalump> s/is/it/2
14:09:32 <Riastradh> Possibly.
14:10:33 * Marvin-- pours a cognac and watches Casablanca
14:10:55 <Riastradh> I only recently really looked deeply into shift, reset, reflect, & reify; and within the past couple days I've discovered their quite practical use in a Scheme program I'm writing.
14:11:08 * XTL sips tea and browses some mail in order to take a break from Monads
14:12:23 <Marvin--> why do we need () -> a though?
14:12:35 <Riastradh> Well, you don't, I suppose, with Haskell.
14:12:42 <Riastradh> But you do in strict languages.
14:12:47 <Marvin--> I mean, isn't that the make-this-lazy trick used in strict languages?
14:12:50 <Marvin--> right
14:13:41 <Heffalump> a TH implementation of reflect and reify would be great.
14:13:49 <Riastradh> ?
14:14:01 <lambdawar> <- beginner question : is it posible to bound the type checking recursion on template types in haskell ?
14:14:17 <Heffalump> lambdawar: you're using polymorphic recursion?
14:14:43 <lambdawar> Heffalump: no, thats just a theorical question that I wondered 
14:15:03 * Riastradh departs.
14:15:07 <Heffalump> can you be more concrete about your question, then?
14:17:03 <lambdawar> thing is that I dont even know myself the real meaning of my question, haha
14:17:28 <Heffalump> well, then my answer is that you can use polymorphic recursion only if you give an explicit type signature
14:18:14 <Marvin--> template types?
14:18:31 <lambdawar> generic types
14:18:42 <shapr> little black & white labels
14:20:25 <lambdawar> Heffalump: does the signature contains the template type ? (I dont know haskell, I used to code on ocaml, but haskell sounds really neat for all the theorical playground implementations about lambda calculus)
14:36:40 <bourbaki> bracket  :: Parser a -> Parser b -> Parser c -> Parser b
14:36:40 <bourbaki> bracket open p close = open `bind` \x2 -> p `bind` \x -> close `bind` \x3 -> result x
14:36:59 <bourbaki> ive got a question regarding the x,x2 and x3 in the second line
14:37:28 <bourbaki> that function returns something that requires me to pass a string
14:37:44 <bourbaki> how do these x's relate to the string that i put in?
14:38:20 <shapr> it's the monadic bind, passing stuff behind the scenes?
14:38:39 <bourbaki> yep
14:38:59 <bourbaki> thats the example of Username249 :)
14:39:25 <bourbaki> i just try to figure out what happens with the string that i put in
14:39:32 <shapr> oh, I think it wants bracket (char "{") stuff (char "}")
14:39:45 <bourbaki> yeah but what i mean is
14:39:45 <shapr> or something like that
14:40:09 <bourbaki> that bracket function gives me a function that accepts a string
14:40:31 <bourbaki> and i wonder what happens with the string in that bracket function
14:40:32 <shapr> oh, once all the bits are in?
14:40:43 <bourbaki> yes what is x2 x and x3 value wise
14:40:52 <shapr> you mean once you've filled in the three parsers, it still wants a string?
14:41:04 <shapr> I think it should need a string
14:41:05 <Marvin--> bourbaki: the point is that you can combine functions with the bind combinator, and in the end, when you've assembled one big function, you apply it to the string you want to parse
14:41:16 <shapr> right
14:41:20 <bourbaki> yes i know all that :)
14:41:22 <Username249> you called me ?
14:41:26 <bourbaki> no :)
14:41:29 <shapr> Username249: yes, but you weren't home!
14:41:29 <Marvin--> Username249: no, go back to sleep :P
14:41:36 <shapr> Username249: we tried to come over and eat your pizza!
14:41:38 <Username249> i wont sleep today.
14:41:46 <shapr> Username249: sleep is good for learning.
14:41:49 <Username249> i will finish my monadic parser today.
14:41:59 <shapr> you have twenty minutes before today is over.
14:42:03 <XTL> Hm. Is that bind "queue" interchangeable with a do?
14:42:04 <bourbaki> what i wonder about is what x2 , x and x3 s values are
14:42:05 * shapr cackles evilly
14:42:13 <Marvin--> bourbaki: x2 and x3 will be the "results" of open and close
14:42:17 <Username249> okay, so i will finish my parser this night.
14:42:22 * shapr grins
14:42:29 <Username249> But currently i am totally lost, AGAIN.
14:42:37 <Marvin--> XTL: the do syntax is just syntactic sugar for >>=
14:42:49 <Username249> so i understood all that stuff, but now i have no clue where to start.
14:43:17 <XTL> Marvin--: That's how I understood it. The examples I saw used do's so it was a bit easier to see that way.
14:43:21 <shapr> do you know how to make a parser for just one character?
14:43:32 <shapr> Username249: the simple answer is, read the parsec tutorial, try out the examples
14:43:32 <XTL> Now there's some more depth to all this. I fear I'll be sucked in again...
14:43:36 <shapr> then you'll be good to go
14:44:03 <Username249> okay, parsec url was http://www.cs.uu.nl/~daan/parsec.html ?
14:44:12 <lament> haskell?
14:44:18 <shapr> YES PLEASE!
14:44:18 <Username249> lol
14:44:22 <XTL> :)
14:44:27 <Marvin--> bourbaki: char typically has the type  Eq a => a -> Parser a, so if you do  bracket (char '{') p (char '}'), the x2 and x3 being thrown away are '{' and '}'
14:44:45 <shapr> Username249: sure, that's good
14:44:59 <Username249> bourbaki, you are sure you are not studying at the university of dortmund ?
14:45:24 <bourbaki> heheheheheh
14:45:25 <bourbaki> yes
14:45:28 <bourbaki> 100%
14:45:41 <bourbaki> thats one of the few unis i was not studying at ;)
14:46:40 <shapr> I haven't studied at dortmund either.
14:46:48 <lament> Neither have I!
14:46:51 <Marvin--> me neither
14:46:51 <Username249> so noone did my homework.
14:47:02 <Marvin--> Username249: looks like you're on your own :P
14:47:03 <shapr> I hope not.
14:47:05 <bourbaki> heh :)
14:47:13 * Username249 sings "Alll by myself... I am ...."
14:47:16 <shapr> how would you learn if we did your homework?
14:47:39 <Username249> bersetzerbau ( the name of the course ) is not the only course i visit.
14:47:57 <Username249> for the homework at ANY other course i need like 3 maximum 5 hours.
14:48:23 <Username249> for bersetzerbau i am currently running at 30 till 40 hours (per sheet !!)
14:48:48 <bourbaki> i like that parser thingy ;)
14:48:49 <arjanb> learning haskell and parsers in one course is a bit heavy
14:48:59 <bourbaki> i think i will apply it on some linguistics stuff
14:49:02 <Username249> arjanb, 100000% agree
14:49:18 <shapr> bah, I learn Haskell and Parsers outside of any course.
14:49:25 <bourbaki> heh
14:49:30 <Username249> kudos for that.
14:49:52 <Username249> the parsec pdf, i may be stupi but i cant find a tutorial in there ?
14:49:53 <Marvin--> feh, we pick up new langauges in various comp.sci. courses all the time
14:50:27 <XTL> Sleep or more monads?
14:50:29 <Username249> the word "tutorial" has just one hit.
14:50:33 <shapr> XTL: MONADS!
14:50:38 <Username249> and its not a tutorial
14:50:51 <XTL> shapr:  I was afraid of that :)
14:51:05 <shapr> Username249: http://www.cs.uu.nl/~daan/download/parsec/parsec.html
14:51:16 <shapr> you can sleep if you want to...
14:51:25 <shapr> I have to work tomorrow, so I'm stretching today as far as it goes.
14:53:24 <Username249> shapr, that is the PDF file, just as an HTML file. there is no tutorial in it ? An no I cant sleep.
14:54:04 <shapr> there is a tutorial in it.
14:54:05 <Username249> i searched the word "tutorial" one match, but that was not an tutorial .
14:54:17 <shapr> start at the part that says "Users Guide"
14:54:23 <Username249> oh.
15:00:10 <XTL> There. Sandwiches.
15:05:53 <XTL> And one more next buyer steps up.
15:06:13 <shapr> geez
15:06:17 <shapr> I gotta get moving
15:07:04 <bourbaki> ye
15:07:05 <bourbaki> bye
15:07:09 <Username249> Oh lord.
15:07:21 <Username249> The parsec tutorial doesnt help at all.
15:07:31 <Username249> but goodbye shapr, and thanks again.
15:07:44 <Username249> i think i will work on my monadic parser.
15:09:12 <shapr> g'bye!
15:09:18 * shapr sighs
15:09:25 <Username249> bye
15:13:43 <shapr> hiya saba 
15:13:45 <shapr> greetings skylan 
15:13:54 <saba> hello
15:14:17 <Username249> Oh my god !
15:14:24 <shapr> saba: have any Haskell questions?
15:14:45 <Username249> I think my parser just parsed something ! I want to let the world know of that ! Where is the copy paste wiki !
15:14:46 <Username249> ?
15:14:55 <shapr> @wiki HaskellIrcPastePage
15:14:55 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:14:56 <saba> i'm here hopefully to answer any :p but generally idling to avoid work
15:15:11 <shapr> saba: oh, I have a question about arrows...
15:15:22 <saba> arrows?
15:15:37 <shapr> yah, arrows
15:15:45 <bourbaki> byebye
15:16:38 <shapr> saba: do you write Haskell at work?
15:17:33 <saba> no. but i study them at university (also stuff like mercury)
15:17:46 <Username249> bye bourbaki, and thanks for the help
15:17:54 <Username249> i updated the wiki IRC Page.
15:18:15 <shapr> mercury seems nifty
15:18:34 * Username249 makes a coffee . . o o O (Nothing beats Coffee at midnight....)
15:19:07 <Marvin--> Username249: looks nice :)
15:19:27 <shapr> saba: nice hostname
15:20:55 <shapr> greetings IRCMonkey 
15:21:20 <shapr> oh well
15:21:35 <shapr> Username249: looks nice!
15:23:49 <XTL> And one more. This one might want the sparc boards as well.
15:24:00 <shapr> yow
15:25:14 <Username249> but I dont understand what zero_ does ... :(
15:25:32 <Marvin--> it's the parser that always fails
15:25:46 <Username249> ahh !
15:25:51 <Marvin--> surprisingly useful to have
15:25:59 <XTL> Lots of finns read news at midnight, it seems :)
15:26:13 <Username249> zero, item sat are all Parsers !! I get it
15:26:27 <XTL> Username249: Is it the topmost code?
15:26:35 <Username249> but what is satSym then ? A Parser Helper variable ?
15:26:42 <Username249> XTL ???
15:26:55 <XTL> Username249: There on the paste page.
15:27:00 <Username249> Yeah !
15:32:55 <Marvin--> I'm off to bed
15:33:21 <XTL> Hm. I can't make all of it fall together yet. I'll probably need to learn a bit more first.
15:34:21 <Username249> XTL, what is your question. I am like Super-Haskell now
15:39:42 <XTL> Hm. satSym is the "worker", is it?
15:40:13 <Username249> i dont know
15:40:32 <Username249> i think satSym is "a" worker
15:40:50 <Username249> it is called only by sat , but I am not 100 % sure.
15:40:52 <XTL> Nono.. now I'm lost again.
15:41:23 <Username249> Oh no, dont believe what I type
15:41:28 <Username249> i am totally new to this all.
15:42:18 <Username249> ih haskell only had sth like a trace or so
15:42:57 <XTL> I don't know what it could be called, actually. But I do see what it does. Forget about that question :)
15:43:57 <Username249> i have no clue how I can understand now the grammar on top of it.
15:44:08 * XTL wonders where the grammar is
15:44:16 <Username249> the topmost.
15:44:24 <Username249> E -> E+T
15:44:29 <Username249> E -> T
15:44:32 <Username249> and so on.
15:44:37 <Username249> this is the grammar.
15:44:44 <Username249> this grammar can create words.
15:44:46 <XTL> Yes, and in the code?
15:45:11 <Username249> for example "a" . "a" is a word from this grammar.
15:45:22 <Username249> Yeah, that is my problem. It isnt in the code.
15:45:34 <Username249> this is just the least you need for a parser.
15:45:45 <Username249> now I dont get the connection right.
15:46:01 <Username249> how can I see if he accepts sth, where do I start.
15:46:06 <Username249> What do I have to code ?
15:46:46 <Username249> I dont think that I ever will understand this language. If my task could be done in C, I would have done it 6 days ago
15:47:55 <Username249> hmm apply char doesnt work. I wonder why
15:48:55 <saba> C. urrrgh :p
15:49:58 <Username249> in C noone is helpless. In Haskell all you can do is ask ask ask, you never can try.
15:52:39 <XTL> So now it matches any character and terminates there?
15:53:34 <SyntaxLaptop> hm. no marvin--
15:53:41 <Username249> I think, but I dont know. I dont know what it does exactly-
15:54:12 <Username249> i really have no clue what to do now
15:55:32 <Username249> i mean, I can call apply with a function like item as second, and then a String, but I am missing the loop.
15:55:33 <XTL> My guess would be to make another parser besides "item" to apply.
15:56:29 <Username249> I will write the parser Number
15:57:38 <XTL> I smile at the complexity of making a matcher in a language that has a built-in matcher. Maybe I'm tired. :)
15:57:55 <Username249> no I cant, i dont know how to check if the char is an integer ?
15:59:43 <Username249> What the frell.
15:59:53 <SyntaxLaptop> what are you guys working on?
16:00:01 <Username249> I cant do anything in this language.
16:00:17 <Username249> the first problem on the IRC wikipedia copy paste page.
16:00:29 <SyntaxLaptop> link?
16:00:35 <Username249> i try to write an monadic parser that accepts a certain grammar
16:00:47 <Username249> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:01:01 <SyntaxLaptop> is this from scratch, or w/ parsec?
16:01:29 <Username249> from scratch
16:01:34 <Username249> it doesnt need parsec.
16:01:57 <bourbaki> bk
16:02:12 <Username249> but currently the only parser that seems to work is the item parser
16:02:26 <Username249> bourbaki, hi ! i completed my first part of the parser...
16:02:30 <Username249> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:02:32 <bourbaki> :)
16:02:34 <Username249> its the topmost.
16:03:17 <bourbaki> :)
16:03:19 <Username249> but I am missing the loop now, where do I have to implement the loop now ?
16:03:31 <bourbaki> loop?
16:04:12 <Username249> yeah, it should read the complete String.
16:04:30 <bourbaki> ah the magic word is tail recursion :)
16:04:31 <Username249> not just read one char of it. I have to code some sort of loop I assume
16:04:38 <Username249> ?
16:04:51 <Username249> how do I implement that ?
16:05:21 <stepcut> arg! My post to haskell-cafe is to big (almost twice the legal limit). Now I must wait for moderation ....
16:05:43 <bourbaki> haskel cafe?
16:06:15 <stepcut> a non-compiler specific haskell mailing list
16:06:27 <Igloo> What did you send? A small pile of source code?
16:06:33 <SyntaxLaptop> hiya stepcut. maybe that means you should be writing a paper, not a post ;)
16:07:01 <Username249> are there any documents about tail recursion ?
16:07:34 <Username249> ahh query. i am an idiot
16:07:34 <bourbaki> my uni does java in the algorithm course should i start a demonstration?
16:07:34 <bourbaki> :)
16:07:36 <bourbaki> Username249 sry
16:08:13 <stepcut> Igloo, SyntaxLaptop: it's basically a mini-paper proposing a compiler extension (a scary one at that) :p
16:08:54 <Igloo> It's all words? Isn't the limit 40k or something?
16:09:02 <stepcut> 5k
16:09:23 <stepcut> my post was just under 10k 
16:09:37 <monotonom> Some kind of "loop" will be in order, yes. I.e., given a parser p, "loop p" will invoke p again and again until it acts like zero.  But its implementation is subtle --- the obvious implementation is too strict, even though Haskell is lazy.
16:09:47 <Igloo> Ah, OK, I'm probably thinking of another list. In fact, I must be, as I probably got the number from spam bounces from it
16:11:01 <monotonom> However, don't worry about the general "loop" yet.  Just work on a special case first to see the problem and the solution --- say, write a parser that eats up as many 'a's as possible.
16:12:18 <bourbaki> i eat up as many m's as i can ;) which results in a belly ache usually ;)
16:12:56 <Username249> but there is one thing that I dont get.
16:13:12 <Username249> i have functions like item. that will be called if an item is read,
16:13:59 <Username249> and i cann probably write a function that reads an a, but I still dont understand how I can write a function that will call all my functions.
16:16:04 <monotonom> Now here is the catch to make your life hard (but when you solve it, you will know how to write "loop" in general).  Write a parser that eats up as many <insert your favourite> as possible. The parser should return a list of <whatever>, whose length equals the number of <favourite> you find.  However, the items in the list must be available as soon as possible.
16:16:42 <monotonom> E.g., the third item of the list must be ready and usable before the parser reads the 4th or 5th.
16:17:52 <bourbaki> i think that the eat up is actually the problem :)
16:18:35 <monotonom> I.e., if you write: apply {do (_:_:x:_) <- eat; return x}, the program will not need to read the 5th item, and preferrably not even the 4th.
16:18:46 <Username249> monotonom, i still dont get it  I could write a line in c that would do the trick, but in Haskell i am lost...
16:19:31 <monotonom> Right it is not obvious.  It took me several day to even see what's wrong with the naive implementation i.e. why it reads everything before returning anything.
16:20:10 <Username249> i got the assignment last week monday, i worked every day on it. and I still have no clue.
16:21:01 <bourbaki> i would just recursively apply your function
16:21:13 <bourbaki> that is you have an end element like ]
16:21:18 <bourbaki> [] in lists
16:21:25 <bourbaki> that will be read at the end
16:21:44 <monotonom> Remember that I had already had two years of Lisp experience and one year of SML experience before I touched Haskell, and then I had had two years of Haskell experience before I looked at this monadic parser business, and then it still took we two weeks to understand this one single issue.
16:21:49 <bourbaki> or something like "" in strings
16:21:49 <Username249> why cant i just write sth like functionx somestring = somestring -1 ; functionx
16:22:31 <Username249> I will put that sentence on the top of my homework monotonom :)
16:22:57 <bourbaki> ok what you do then is something like that
16:22:59 <monotonom> However, for homework purposes it is alright to be naive.
16:23:07 <Username249> :)
16:24:23 <bourbaki> yourfn (head:tail) = concat (somefn head) (yourfn tail)
16:24:55 <bourbaki> and you have a function that implements the abortion of the recrusion like that
16:25:15 <bourbaki> yourfn endelem = endelem
16:25:42 <bourbaki> yourfn would be some thing that constantly parses the string you read the first char
16:25:58 <monotonom> You are proposing the equivalent of: eat = do { x<-item; y<-eat; return (x:y) }.  But it won't do anything because when does it stop, what is the base case.
16:26:00 <bourbaki> then the function reads the rest that is the string without the frist char
16:29:01 <Username249> yeah okay, but do i have to write the recursion to call all the time apply ?
16:29:32 <Username249> I had the idea that I call apply once, and it automatically "digests" the whole string ?
16:30:30 <Username249> ie in this example : http://cs-www.cs.yale.edu/homes/carsten/classes/s01/parser.hs Where is the loop ?
16:30:50 <Username249> chanl1 ?
16:30:51 <monotonom> Yes, you are supposed to have all your recursions inside parsers, and just have one top-level apply.
16:30:59 <bourbaki> he does it recursively
16:31:09 <bourbaki> word :: Parser String
16:31:09 <bourbaki> word = neWord `plus` result ""
16:31:09 <bourbaki>        where neWord = letter `bind` \x ->
16:31:09 <bourbaki> 		      word `bind` \s -> 
16:31:09 <bourbaki> 			  result (x : s)
16:31:11 <SyntaxLaptop> Username249: I haven't been watching long enough to tell, but do you realize that instead of loops, you do everything with recursion in Haskell?
16:31:19 <monotonom> His loop is "many".
16:31:32 <Username249> ah...
16:31:54 <Username249> SyntaxLaptop, yeah I know, but I cant.
16:32:29 <monotonom> You just need a "plus" like he does.
16:33:46 <monotonom> You want to say, "try p as many times as possible, until it fails".  First you need a notion of failure, and that is your zero_.  Second you need to say what to do when it fails, what is the alternative; "plus" is the alternate operator.
16:34:23 <monotonom> "p plus q" says: try p, if p fails, go with q instead.  You need that.
16:36:40 <bourbaki> monotonom doesnt that plus do both things at a time?
16:36:51 <bourbaki> monotonom p `plus` q = \s -> (p s ++ q s) 
16:37:15 <bourbaki> monotonom doesnt that apply the parser p and q to s and add the two things together?
16:37:22 <monotonom> That particular one yes.  But Username249 is doing something simpler; he uses Maybe.
16:37:39 <bourbaki> ah ok sry dont want to mess things up
16:46:00 <Username249> omg, i cant get it running anymore
16:55:39 <stepcut> are there any docs for people who want to hack on the hugs internals?
16:57:20 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/new-rts.htm
16:57:24 <Pseudonym> That might help.
16:57:36 <Pseudonym> Plus of course there's the STG machine paper.
16:59:06 <stepcut> i see a number of papers on the STG machine, any particular one?
16:59:27 <Pseudonym> http://research.microsoft.com/research/pubs/view.aspx?pubid=179
16:59:28 <Pseudonym> That one.
16:59:57 <stepcut> ah yes, I have heard the title
17:00:22 <stepcut> i might be more inclined to buy microsoft software if I could earmark the money for haskell development :p
17:01:58 <monotonom> haha
17:02:14 <Pseudonym> Also it's a little bit out of date, but this might help.
17:02:16 <Pseudonym> http://www.cse.ogi.edu/~mpj/pubs/goferimp.html
17:02:59 <stepcut> this tagline always cracks me up: Available by http in Glorious pdf, PostScript, or gzipped dvi. 
17:03:37 * stepcut goes to the store
17:04:44 <Username249> okay, i give up.
17:07:04 <Pseudonym> What have you given up?
17:07:08 <Pseudonym> I hope it was an evil vice.
17:09:04 <Username249> Pseudonym, I try to get an monadic parser working.
17:09:14 <Pseudonym> Ah.
17:09:23 <Username249> for 5 day now, still no results. I am a little frustrated.
17:09:46 <Username249> for example, why does this example not run ? http://cs-www.cs.yale.edu/homes/carsten/classes/s01/parser.hs
17:10:04 <Pseudonym> What do you mean by "not run"?
17:10:12 <Pseudonym> Does it infinitely loop?
17:10:53 <Username249> Pseudonym, no i get an error message.
17:11:02 <Pseudonym> What error message?
17:11:07 <Username249> Undefined variable ord in line 79.
17:11:39 <monotonom> @type ord
17:11:41 <lambdabot> bzzt
17:11:45 <monotonom> @type Char.ord
17:11:47 <lambdabot> Char.ord :: Char -> Int
17:11:47 <Pseudonym> @type Data.Char.ord
17:11:48 <lambdabot> Data.Char.ord :: Char -> Int
17:11:52 <Pseudonym> OK, Char.
17:11:56 <Pseudonym> There you go.
17:12:01 <Username249> it the eval xs = foldl1 op [ord x - ord '0' | x <- xs] line. seems good to me
17:12:14 <monotonom> do an "import Char(ord)" at the very beginning.
17:12:16 <Username249> excuse me ?
17:12:21 <Username249> ah !
17:12:29 <Pseudonym> Or perhaps "input Char"
17:12:32 <Pseudonym> "import Char
17:12:45 <Pseudonym> Might as well.  Never know what you might need from there.
17:12:47 <Username249> it runs !
17:13:10 <Pseudonym> One other suggestion.
17:13:19 <monotonom> You must memorize all the function names in all standard modules.
17:13:20 <Pseudonym> Some of these parsers don't depend on others.
17:13:26 <monotonom> Repeat after me: You must memorize all the function names in all standard modules.
17:13:40 <Pseudonym> e.g. "nat" doesn't depend on "expr".
17:13:42 <monotonom> Write that line a 100 times.  Due tomorrow.
17:13:48 <Username249> You must memorize all the function names in all standard modules.
17:13:57 <Pseudonym> Just don't flood the irc channel.
17:13:59 <Pseudonym> :-)
17:14:21 <Pseudonym> It's worth testing the leaf parsers first, before testing the high-level ones.
17:14:40 <Igloo> Is the use of replicateM_ considered cheating?  :-)
17:15:00 <Username249> Pseudonym, is there any good document out there which explains how to create an parser for context free grammars?
17:15:04 <monotonom> Haha I wouldn't care if you used Perl.
17:15:08 <Pseudonym> It is if your productivity is measured by number of lines of code.
17:15:46 <Pseudonym> Here, watch me initialise a 10,000 element array... :-)
17:15:52 <Igloo> That's OK, I can use replicateM_ to generate code
17:16:14 <monotonom> metaprogramming is the next hottest thing
17:16:15 <Pseudonym> Username249: Parser combinators don't work well if your grammar is left-recursive.
17:16:23 <Username249> i=100;while (i>0) {printf("You must memorize all the function names in all standard modules.\n");i--;}
17:17:06 <Username249> Pseudonym, what do you mean by that ?
17:17:35 <monotonom> A rule "B ::= B * A" would spell trouble.
17:17:37 <Pseudonym> Well, you'll notice in your parser that you have a rule which looks pretty much like this:
17:17:50 <Pseudonym> expr'' ::= factor (addop factor)*
17:18:00 <Pseudonym> Where Kleene closure is spelled "many".
17:18:04 <monotonom> This problem plagues all top-down parsers.
17:18:04 <Pseudonym> Right?
17:18:13 <Username249> i think so , yes.
17:18:18 <Pseudonym> Well, the problem plagues all recursive descent parsers.
17:18:32 <Pseudonym> "top-down" is a more general term than "recursive descent".
17:18:45 <Pseudonym> Username249: This isn't a context-free grammar because of the Kleene star.
17:18:54 <monotonom> Not to be against top-down recursive descent parsers.  I love them.
17:19:03 <Pseudonym> You could express this as:
17:19:12 <Pseudonym> expr'' ::= expr'' addop factor | factor
17:19:30 <Pseudonym> This is left-recursive because expr'' has expr'' directly on its left-hand side.
17:19:45 <Pseudonym> If you tried to write that as a parser combinator, you'd hit infinite recursion.
17:19:57 <Pseudonym> Another way to express this might be:
17:20:05 <Pseudonym> expr'' ::= factor expr'''
17:20:33 <Pseudonym> expr''' ::= 1 | addor factor expr'''
17:20:38 <Pseudonym> s/addor/addop/
17:21:01 <Pseudonym> Where 1 is the empty string, incorrectly called "zero" in your combinators.
17:21:12 <Username249> Pseudonym, my grammar has rules like S->SaB
17:21:20 <Pseudonym> Where?
17:21:34 <Pseudonym> Sorry, I mean your program dowsn't.
17:21:34 <Username249> So it is not possible to write a recursive descent parser ?
17:21:49 <Pseudonym> No, it's not.  But you can do tricks like using "many".
17:22:00 <Pseudonym> Or you can turn left recursion into right recursion, HOWEVER...
17:22:21 <Pseudonym> If you do that, then the parse tree may be wrong because you may get the associativity of your operators wrong.
17:22:32 <Username249> oh....
17:22:37 <Pseudonym> So you may need to slightly modify the parse tree in that case.
17:22:49 <Pseudonym> It's not a huge deal, but it's something to keep in mind.
17:22:52 <Username249> okay, but i dont need an parse tree, I just need to accept or not accept the word.
17:22:57 <Pseudonym> Right.
17:23:16 <Pseudonym> So if you have a rule: S -> S A | B
17:23:25 <Pseudonym> This is basically: S -> B A*
17:23:44 <Pseudonym> Which you can implement directly using "many".
17:23:53 <Pseudonym> Or you can factor it like this:
17:23:56 <Pseudonym> S -> B S'
17:24:02 <Pseudonym> S' -> 1 | A S'
17:24:18 <Pseudonym> Which is right-recursive and hence safe.
17:24:21 <Username249> more like S -> SaA | A and A -> AbB | B and ...
17:24:30 <Pseudonym> Here, "A" is a general target.
17:24:43 <Pseudonym> Could be a string of stuff in general.
17:25:02 <Pseudonym> Do you get the idea?
17:25:23 <Username249> the idea, yes, but i dont think that I am able to implement it :(
17:25:50 <Pseudonym> Have you done any formal language/parsing/compiler-type stuff before?
17:26:17 <Username249> Pseudonym, I am currently learning it. This will be my first compiler.
17:26:24 <Pseudonym> Do you have a textbook?
17:26:30 <Username249> a what ?
17:26:30 <Pseudonym> e.g. the dragon book?
17:26:56 <Pseudonym> A textbook.  Is this for a course, and does the course have a textbook about compilers or formal languages?
17:27:03 <Pseudonym> Or is this just a Haskell course?
17:27:14 <Username249> oh no, i heard that this one is good, but it was conferred at our library
17:27:19 <Pseudonym> Ah, OK.
17:27:28 <Pseudonym> Here's what I suggest.
17:27:31 <Username249> no its basically no haskell course.
17:27:48 <Pseudonym> Go to your library and pick up a book called "Compilers: Principles, Techniques, and Tools" by Aho, Sethi and Ullman.
17:27:53 <Username249> we just "use" haskell to undestand compilers
17:27:58 <Pseudonym> It has a dragon on the cover, hence the dragon book.
17:28:09 <Username249> i will write that one down.
17:29:12 <Pseudonym> Section 4.3 has a few pages on eliminating left recursion.
17:30:51 <Pseudonym> Grrrr... people who don't understand basic formal language theory shouldn't write papers on making parsers.
17:31:06 <Pseudonym> "zero" is precisely the wrong name for parsing an empty string.
17:31:17 <Username249> what me ? i didnt write papers.
17:31:28 <Pseudonym> No, not you.  Hutton and Meijer.
17:31:50 <Username249> oh i read that one
17:32:07 <Pseudonym> Yeah, I noticed it up the top of your code.
17:32:39 <Username249> but I think I will give up now.
17:32:54 <Username249> i worked like 30 to 40 hours on my task, and I couldnt solve it.
17:33:28 <Username249> I hope I will get enough points for the other tasks that I had to do.
17:33:52 <Pseudonym> Cool.
17:34:21 <Username249> basically, because, this taks should finalize my haskell training, and my "haskell course" at the university, this will be my departure from the functional but strange world of haskell.
17:35:57 <Pseudonym> Awww.
17:35:57 <Pseudonym> We'll miss you.
17:35:57 <Username249> lol
17:36:05 <Username249> dont lie. :) it gives bad karma
17:36:12 <Pseudonym> Hah, you'll be back.
17:36:48 <Pseudonym> Next time you need a quick 'n dirty solution to a symbolic combinatorial problem, you'll be firing up Haskell.
17:37:00 <Username249> i dont think so. My brain is too much like C , i will never unterstand the haskell syntax.
17:37:09 <Pseudonym> Oh, poor brain.
17:37:21 <Pseudonym> I hope it doesn't dereference a wild pointer.
17:37:25 <Username249> Lol, i cant even solve SIMPLE math problems with my l33t haskell skills.
17:37:28 <Username249> lol
17:37:51 <Username249> it is really tough.
17:37:57 <Pseudonym> Think of us next time you get a core dump, won't you.
17:39:37 <Username249> it is sooooo frustrating i tried everything to get my programm running, and now I am lost and hopeless.
17:41:40 <Pseudonym> As you say, it's got something to do with your brain.
17:41:48 <Pseudonym> It's like learning a non-native language.
17:41:55 <Pseudonym> At first you are translating your native language.
17:42:03 <Username249> the thing i missed most in haskell was some sort of debugger.
17:42:17 <Pseudonym> But you get to a point where you stop translating and start using the language natively.
17:42:21 <Username249> where i can step through the source while running it.
17:42:33 <Pseudonym> At that point, your brain has been rewired.
17:42:39 <Pseudonym> Ah, the debugger, yes.
17:42:46 <Pseudonym> Point of contention at the moment.
17:43:11 <Pseudonym> Part of the problem is that stepping through the source to see what is happening isn't particularly helpful in Haskell.
17:43:28 <Pseudonym> Being a lazy language, you never know when something will be evaluated.
17:43:29 <Username249> no its not that i want to debug my programm, it is more like, i have a working example here, and i would like to understand how it works.
17:43:49 <Pseudonym> Ah!  I have a cure for that.
17:44:01 <Pseudonym> Read a book on how to implement Haskell.
17:44:04 <Username249> if it would be C/C++ source i would step through the complicated parts and understand it then, but in haskell (at least with hugs) i dont have such a thing.
17:44:06 <Pseudonym> THEN you get the idea.
17:44:39 <Cale> Username249: break the thing into pieces
17:44:41 <Username249> i read like 10 tutorials in the last 5 days. I am more the "learning by doing" - type.
17:44:51 <Cale> if you understand the pieces, you understand the whole thing
17:44:55 * Pseudonym nods
17:45:08 <Cale> Haskell has a nice feature called referential transparency
17:45:23 <Cale> it means that if you call a function with the same arguments, it always returns the same thing
17:45:31 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
17:45:36 <Pseudonym> That is a really good book.
17:45:55 <Username249> there is "microsoft" in the url.
17:45:59 <Pseudonym> Yes.
17:46:20 <Pseudonym> There's a bittersweet story there.
17:46:28 <Username249> microsoft / good book = oxymoron ? :)
17:46:43 <Pseudonym> No, plenty of people at Microsoft write good books.
17:46:57 <Cale> One of the only redeeming features of MS is their research department.
17:47:13 <Pseudonym> Even the developers occasionally write good books.
17:47:23 <Pseudonym> Especially when they bitch about their fellow developers in said books.
17:47:30 <Username249> lol
17:47:32 <Pseudonym> THat's always a fun read.
17:47:58 <Pseudonym> There's one book written by the head of Excel where he constantly complains about the crap software they get from the software tools department.
17:50:28 <Username249> i cant let go.
18:00:12 <Username249> I want to solve my problem but I cant.
18:35:37 <Pseudonym> Owowowow.
18:35:46 <Pseudonym> Sorry.  Infected wisdom tooth.
18:40:12 <ozone> Pseudonym: ouch
18:40:47 <Pseudonym> Partially erupted, so it's impossible to clean thoroughly.  It was only a matter of time.
18:43:23 <ozone> seeing a dentist about it soon?
18:46:53 <Pseudonym> This afternoon.
18:47:04 <Pseudonym> It only really got painful last night.
18:47:28 <Pseudonym> Trouble is it's school holidays 'round these parts, so getting a full appointment will be difficult this week.
18:47:47 <Pseudonym> So he'll probably prescribe some antibiotics and maybe some strong pain reliever and tell me to come back in a week.
18:48:07 <Pseudonym> Which would suit me fine.
18:50:28 <Cale> mmm... percocet. heh
18:57:08 <ozone> school holidays here too
18:57:25 <ozone> which means (1) i can get parking at uni, and (2) less scenery around campus :(
18:57:41 <Pseudonym> ozone: Yeah, I always get a parking spot at the railway station.
18:58:00 <Pseudonym> Actually, surely there's _more_ scenery, since there are fewer undergrads in the way.
18:58:18 <ozone> i think it depends on what you mean by scenery
18:58:23 <Pseudonym> Indeed.
18:58:36 <Pseudonym> About 5 years ago, undergrads started looking too much like kids.
18:58:50 <Pseudonym> And they ain't getting any older.
18:59:06 <Pseudonym> Your mileage may vary.
18:59:11 <ozone> didn't stop a few of my friends ...
19:00:26 <ozone> in other news, i ordered types and programming languages last night!
19:00:35 <ozone> finally got me the courage to click on that "place order" button at amazon
19:00:52 <blackdog> ozone: no names, no pack drill?
19:01:13 <ozone> blackdog: no names, but i'm sure there was lots of "drilling" of "packs" involved, as it were
19:01:40 <dons> this is all very distasteful
19:01:54 <ozone> dons: quiet, slave
19:02:27 <dons> yes, master ozone. please beat me harder.
19:02:46 <ozone> dons: get back to work on getting ghc to run with .so's!
19:02:49 <ozone> *whip*
19:03:12 * blackdog is learning more about ozone than he is entirely comfortable with
19:04:28 <ozone> blackdog: muahahaha
19:05:14 * Pseudonym is even less comfortable learning things about dons
19:06:46 <Igloo> Does anyone have a list of commands that do profiling with TH handy?
19:07:18 <ozone> "whacking"?  hrrm
19:13:22 <Igloo> Ah, n/m, got it
23:30:35 <earthy> Good Morning, #Haskell!
23:31:06 <dnm> Ho there.
23:31:23 <heatsink> Good night, #haskell!
23:31:39 <dnm> I'm going to get a soft drink, #haskell! ;]
23:32:22 <earthy> ;)
23:32:37 * dnm just "set up" darcs.
23:32:44 <earthy> much to set up for. :)
23:32:45 <dnm> If you could call it "setting up" anything
23:32:58 <earthy> `darcs create', right? :)
23:33:15 <ozone> init :)
23:33:28 <ozone> earthy: how's UHC's progress these days?
23:33:34 <ozone> anywhere near close to a compiler yet?
23:33:36 <earthy> steady, IIRC
23:33:48 <earthy> ISTR something being said about a code generator
23:33:59 <earthy> but I'm nowhere near close enough to those developments
23:34:05 <earthy> it really is mostly Atze working on it
23:34:10 <dnm> "darcs initialize" actually.
23:34:31 <dnm> And then the usuall suspects.
23:36:02 <earthy> Get:1 http://ftp.nl.debian.org testing/main darcs 0.9.20-1 [851kB]
23:36:05 <earthy> there we go
23:36:11 <earthy> I forgot to put it on my home PC
23:39:10 <ozone> earthy: are any of the UHC team on #haskell?
23:39:25 <ozone> actually, are any of you guys going to ICFP/Haskell workshop?
23:39:33 <ozone> i'd love to meet up with you all again
23:44:34 <earthy> err.. UHC team...
23:44:39 <earthy> welll. :)
23:45:05 <earthy> there isn't really a UHC team as such ;)
23:45:42 <earthy> it's mostly Atze with some input from Doaitse, Arthur, Bastiaan, Jurriaan, and Daan
23:46:08 <earthy> but ther'll be a sizeable enough Utrecht presence at ICFP/Haskell Workshop
23:46:28 <earthy> there's at least 3 papers submitted to Haskell Workshop, from here
23:46:31 <dnm> Warm cake donuts are a beautiful thing.
23:46:32 <ozone> where arthur == you?
23:46:35 <earthy> I think 2 to ICFP
23:46:44 <earthy> no, other Arthur 
23:46:47 <ozone> oh.
23:46:50 <earthy> (there's 2 of us ;))
23:46:59 <ozone> hmm, are you the mac guy?
23:47:10 <earthy> we both use macs. :)
23:47:10 <ozone> who spoke to me about ghc + project builder/xcode?
23:47:20 <earthy> that would be me,yes ;)
23:47:26 <ozone> ok, phew
23:47:35 <earthy> Arthur B is a bit taller and blond. :)
23:47:38 <ozone> for a moment, i thought i was confusing you with the other arthur for about the past 9 months :)
23:48:15 <dnm> Speaking of IDEs.
23:48:15 <earthy> nah ;)
23:48:28 <dnm> I was playing around with Eclipse and the Haskell support plugin someone wrote for it.
23:48:38 <earthy> Leif Frenzel, IIRC, yes
23:48:44 <dnm> Seemed nice, though I need to learn Eclipse itself more.
23:48:56 <dnm> Is he in here at all?
23:49:03 <earthy> not that I know of, no.
23:49:49 <dnm> Writing Eclipse plugins seems to be less than trivial.
