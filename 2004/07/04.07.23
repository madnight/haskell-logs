01:57:37 * Marvin-- wrestles cpp and haddock
01:58:04 <Marvin--> damn them, damn them to hell
01:58:32 <Lemmih> eh?
01:59:54 <Marvin--> well, running cpp on something that isn't C is ... usually a bad idea
02:00:03 <Marvin--> it gets funny ideas about string literals and stuff
02:01:22 <Lemmih> Isn't there hscpp for haskell sources?
02:01:47 <Marvin--> cpphs, I was about to download it right now
02:10:21 <Lemmih> OT: My understanding of monads have finally become so complete that I've made my first useful and non-trivial monad (for a configuration library in the same style as WASH). And when I look at it now, it's just so simple.
02:16:24 <Marvin--> :-)
02:16:32 <Marvin--> there comes a time for all of us :)
02:19:03 <Spark> heh
02:19:22 <Spark> i'll recontinue playing with haskell when i get bored of linux proaudio
02:25:59 * Marvin-- is a good boy and comments his code
02:30:23 <Spark> can i see some output of haddock?
02:30:25 <Spark> html output
02:30:33 <Spark> im curious how it compares to javadoc and doxygen
02:32:07 <Marvin--> the hierlibs docs are generated by haddock
02:32:18 <Spark> ah
02:32:52 <Marvin--> "Produced by Haddock" is something of a giveaway ;)
02:32:59 <Marvin--> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
02:35:01 <Spark> mm i like blue
02:35:20 <Spark> look sgood
02:44:36 <bourbaki> hi
02:47:11 <Lemmih> Did I hear something about GADTs being in GHC CVS?
02:47:15 <Lemmih> Hey bourbaki.
02:50:46 <Marvin--> oh really? Cool
02:51:02 <Marvin--> then we just need Igloo to crank out a new version of ghc-cvs :-)(
02:56:54 <Lemmih> Hmm I really wish I could find more information about it.
03:05:35 <Heffalump> they may only be in a separate branch
03:05:55 <Heffalump> though obviously he could still do it
03:49:52 <bourbaki> what is wrong with this piece of code?
03:49:52 <bourbaki> gft :: [a] -> a
03:49:53 <bourbaki> gft x = x !! num
03:49:53 <bourbaki> 	where
03:49:53 <bourbaki> 	do num <- rollDice
03:49:53 <bourbaki> 	return num
03:50:55 <sazzle> don't think you can have returns in where clauses
03:51:21 <sazzle> and you can't return multiple times
03:51:32 <sazzle> and you can't use do in a pure function
03:51:51 <bourbaki> yep i see the point but can i do something similar?
03:52:04 <sazzle> what's it meant to do?
03:53:52 <bourbaki> well rollDice gives me a random number
03:54:03 <bourbaki> and i want to pick a random entry of the list
03:54:20 <sazzle> why are you returning num?
03:54:30 <sazzle> and what's the type signature of rollDice?
03:54:52 <bourbaki> rollDice :: IO Int
03:54:52 <bourbaki> rollDice = getStdRandom (randomR (0,99))
03:55:11 <bourbaki> well i just added the where block
03:55:36 <bourbaki> so the retrun was still there before it was retrun (x !! num)
03:57:47 <sazzle> you can't have that in a pure function, afaik
03:58:35 <bourbaki> well if i return (x !! num) then the function yields a function right?
03:58:50 <bourbaki> which retruns the random list entry or am i mistaken?
04:00:18 <sazzle> yeah, but you'd need to get rid of the where clause (put the whole thing under do), and change your type sig
04:00:54 <bourbaki> yep
04:01:30 <bourbaki> gft :: [a] -> (b -> b) ?
04:01:38 <sazzle> no no 
04:01:43 <bourbaki> why?
04:02:01 <sazzle> that's still a pure function!
04:02:21 <sazzle> (it just makes less sense than what you had before)
04:02:29 <bourbaki> heh
04:02:48 <bourbaki> well i takes a list and retruns an endomorph function
04:03:04 <sazzle> yeah
04:03:14 <sazzle> well, it takes a list and returns a function
04:03:17 <sazzle> that's not what you're doing
04:03:28 <bourbaki> not now i change the stuff
04:03:43 <bourbaki> delete the where line and return (x !! num)
04:05:26 <sazzle> still wont work
04:06:21 <bourbaki> hmhmhm
04:08:02 <sazzle> (it's a simple fix though)
04:08:26 <sazzle> you can't have IO in the middle of a non-IO function
04:08:32 <bourbaki> gft :: [a] -> IO a
04:08:32 <bourbaki> gft x =	do num <- rollDice
04:08:32 <bourbaki> 	   return (x !! num)
04:09:05 <sazzle> that looks ok
04:19:00 <Marvin--> bourbaki: the point is that once you step into the IO monad, you can't step out
04:19:02 <Marvin--> and that's a feature
04:24:54 <bourbaki> Marvin-- why is that a feature?
04:28:04 <Marvin--> because that would break the solution to the problem IO is meant to solve
04:29:04 <Marvin--> Haskell can only do side effects by way of stepping into the IO universe, if you could step in and out of IO at will, you wouldn't have a pure language
04:29:10 <Marvin--> take your rollDice function
04:30:06 <Marvin--> say that we have an unIO :: IO a -> a function, what would you expect unIO rollDice to produce if you reference it multiple times? The same value or different values?
04:30:59 <bourbaki> why would i reference it multiple times?
04:31:17 <Marvin--> furthermore, IO a is basically a function RealWorld -> (a,RealWorld), an unIO function would have to "invent" a RealWorld to run the IO a, and that's kinda ... absurd
04:31:27 <bourbaki> i would expect that function to return the value in that function
04:31:46 <bourbaki> hm
04:31:59 <Marvin--> the question is here, is  let x = unIO rollDice in x+x  the same as  unIO rollDice + unIO rollDice?
04:33:20 <bourbaki> hmhmhm
04:33:59 <aleator_> That might be a better example if you replace (+) with (,)..
04:34:18 <Marvin--> true
04:35:32 <bourbaki> i still dont get the point fully
04:35:59 <bourbaki> i mean unIO is like that 2nd function in a coalgebra or comonad
04:36:14 <Marvin--> ah, but IO isn't a comonad, IO is a monad
04:36:35 <bourbaki> yes sure i also heared that there are probs with states and comonads but i dont understand fully why
04:36:56 <bourbaki> id like to have a bimonad for that so that i can project back to values
04:37:15 <Marvin--> there's been experimentation with an "OI" comonad, but I don't know much about that
04:37:46 <bourbaki> i mean its just a bit unfamiliar to me to write programs that way
04:38:01 <bourbaki> not that it hurts to stay in the monad all the time but you have to know it for once ;)
04:38:26 <Marvin--> the thing is that you can sort of get out of it *locally*, by way of the bind operator
04:38:33 <Marvin--> or using the <- notation
04:38:59 <bourbaki> how can i concat strings that are in IO String?
04:39:18 <Marvin--> @type liftM concat
04:39:20 <lambdabot> bzzt
04:39:21 <bourbaki> would i have to do x <- all the three of them and then return the concat?
04:39:23 <Marvin--> meh
04:39:27 <Marvin--> @type Control.Monad.liftM concat
04:39:28 <lambdabot> Control.Monad.liftM concat :: forall a m.
04:39:28 <lambdabot> 			      (Monad m) =>
04:39:28 <lambdabot> 			      m [[a]] -> m [a]
04:40:09 <Marvin--> @type Control.Monad.sequence
04:40:10 <lambdabot> Control.Monad.sequence :: forall a m. (Monad m) => [m a] -> m [a]
04:40:32 <Marvin--> IOW, you can do  liftM concat (sequence [m1,m2,m3])
04:41:05 <bourbaki> sequence does what?
04:41:33 <bourbaki> juts enlist the stuff from the monads in a single list?
04:41:39 <Marvin--> it runs all the monadic computations in the input list, and returns the list of values
04:42:45 <bourbaki> why do i lift the concat then if its a simple list?
04:42:53 <bourbaki> ah ok
04:43:02 <Marvin--> *returns*
04:43:12 <Marvin--> once you go in, you can't get out
04:43:13 <Marvin--> :)
04:43:13 <bourbaki> it yields a monad again the sequence
04:43:48 <bourbaki> sequence reutrns something like a -> m [a] ?
04:44:03 <Marvin--> no, look at the type signature
04:44:14 <Marvin--> given  [m a]  it returns  m [a]
04:44:32 <bourbaki> er m [a] but thats some function like a -> [a] ?
04:44:44 <Marvin--> no, it's a monadic computation
04:44:57 <Marvin--> it could be IO [a], or Maybe [a], or even a list monad ([[a]])
04:45:14 <bourbaki> oh ok
04:45:19 <Marvin--> which kind of monad it returns is of course determined by which monad you pass into it
04:45:34 <Marvin--> @type sequence [Just 'a', Just 'b', Nothing, Just 'c']
04:45:35 <lambdabot> sequence [Just 'a', Just 'b', Nothing, Just 'c'] :: Maybe [Char]
04:45:56 <Marvin--> @type sequence [putStr "foo", putStr "bar"]
04:45:57 <lambdabot> sequence [putStr "foo", putStr "bar"] :: IO [()]
04:46:50 <bourbaki> and how does the lift work?
04:47:05 <bourbaki> can you lift any function into the monad space?
04:47:31 <Marvin--> @type Control.Monad.liftM
04:47:32 <lambdabot> Control.Monad.liftM :: forall r m a1.
04:47:32 <lambdabot> 		       (Monad m) =>
04:47:32 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
04:47:43 <Marvin--> yep, any function
04:48:31 <bourbaki> the implementation does differ though does it?
04:49:01 <Marvin--> well, all monads implement bind (>>=) and return differently
04:49:08 <Marvin--> the rest can be implemented using just bind and return
04:49:31 <Marvin--> liftM f m = m >>= return . f
04:49:32 <bourbaki> ah of course otherwise it would not make much sense
04:50:06 <Marvin--> sequence [] = return [] ; sequence (m:ms) = do x <- m ; xs <- sequence ms ; return (x:xs)
04:51:06 <bourbaki> i just dont like the idea of not stepping out though ;)
04:51:11 <Marvin--> another way to see how absurd it would be to be able to jump out of the IO type is when you add console I/O to the equation
04:51:14 <bourbaki> things like that scare me
04:51:29 <bourbaki> why?
04:51:35 <Marvin--> say you've got   (unIO (putStr "foo"), unIO (putStr "bar"))
04:51:42 <Marvin--> would it print first foo and then bar, or vice versa?
04:52:20 <Marvin--> say you've got  let (x,y) = (unIO getLine, unIO getLine) in ... x ... y ...
04:52:20 <bourbaki> hm
04:52:25 <Marvin--> which line would be read first? x or y?
04:52:48 <Marvin--> we use the IO monad to enforce a sequence of execution
04:52:53 <Marvin--> which makes the I/O sane
04:53:00 <Marvin--> if you could jump out of it, it would no longer be sane ;)
04:53:04 <bourbaki> yep the above thing is paralell
04:55:23 <Marvin--> hmm
04:55:28 <Marvin--> now how do I actually run this test suite
04:55:42 <Marvin--> Iglooooo :)
04:55:46 <bourbaki> heh :)
04:55:49 <bourbaki> dont ask me ;)
04:55:58 <bourbaki> well i got to run thank you very much
05:06:04 * Marvin-- groans and runs ./configure in the fptools directory
05:06:34 <sazzle> has anyone else had the hostmask they join this channel with spammed?
05:09:07 <Cale> hmm
05:09:40 <Cale> I can see it happening, as they're all on the web.
05:09:48 <sazzle> yeah
05:09:58 <sazzle> i'm pretty sure this is where they found that address from
05:10:43 <sazzle> they look exactly like email addresses too
05:11:07 <Marvin--> I wouldn't know, our port 25 is firewalled
05:11:53 <sazzle> well, i got it at my uni account
05:12:20 <Cale> I've been getting blank spam lately.
05:13:20 <Cale> I can't imagine what would drive someone to spam people with a message with no body.
05:13:38 <Marvin--> I have long since ceased to understand spammers
05:14:16 <sazzle> spammers make no snese
05:14:18 <sazzle> sense
05:14:46 <sazzle> they went through a period where they just sent you random markov chain generated rubbish
05:14:51 <sazzle> and nothing else
05:15:00 <sazzle> maybe they were testing their markov generators?
05:16:20 <Marvin--> A few weeks ago I got spam where there were un-substituted variables
05:16:35 <Marvin--> there was a bunch of %{RND1} stuff in the body
05:16:42 <Marvin--> or whatever the syntax was
05:17:24 <sazzle> yeah, i think i've seen that
05:18:00 <Marvin--> oh god, I have absolutely no idea how to run these test cases without actually compiling large parts of fptools
05:18:04 <Marvin--> *whimper*
05:23:38 <Marvin--> where's Igloo when you need him
05:38:29 <Marvin--> (/¤&3$#!
05:39:31 <Marvin--> this is not going my way
05:40:23 <Igloo> I'm here
05:40:38 <Igloo> What are you trying to do?
05:40:39 <Marvin--> ooh, Igloo, my knight in shining armor
05:41:14 <Igloo> Is this what you want?  ./configure; make -C testsuite boot; make -C testsuites/tests/ghc-regress TEST_HC=ghc
05:41:34 <Marvin--> well
05:41:53 <Marvin--> the thing is that that will test the Text.ParserCombinator.ReadP of the installed ghc
05:41:59 <Marvin--> whereas I would like to test my changes
05:42:07 <Marvin--> preferrably without compiling all of fptools...
05:43:01 <Marvin--> configure complained about the nonexistence of mk/config.h.in
05:43:20 <Marvin--> but I did make boot in the testsuite dir
05:43:38 <Igloo> Oh, do autoreconf before configure
05:44:23 <Marvin--> funny that make -f Makefile.config didn't do that
05:44:52 <Igloo> You're going to have to recompile whatever package Text.ParserCombinator.ReadP with your changes and replace the one in your installed ghc with it
05:45:03 <Marvin--> oh dear
05:45:10 <Igloo> If I understand correctly
05:45:16 <Marvin--> that package is base :-/
05:45:24 <Igloo> Ah  :-)
05:45:36 <Marvin--> that's why we wanted to use ReadP instead of Parsec, remember ;-)
05:46:11 <Igloo> You could probably get away with just compiling that particular module and then hacking it into the library (which is really an ar archive)
05:46:14 <Marvin--> I tried preprocessing the ReadP.hs and using EXTRA_HC_OPTS=-i/tmp/foo but...
05:46:39 <Marvin--> I guess it looks in the archives before searching the -i paths
05:46:46 <Igloo> Oh, hmm
05:47:12 <Igloo> Did you also compile it? I'd have thought that would work now you mention it
05:47:37 <Marvin--> hm, no, let me try that
05:48:16 <Igloo> Oh, and it is /tmp/foo/Test/Pa.../ReadP.*, right?
05:49:17 <Marvin--> yes
05:49:37 <Marvin--> ah, and I of course have to add the .o file to the command line, but let's see, this is progress
05:50:07 <Igloo> You do? Shouldn't -i find it itself?
05:50:19 <Igloo> Oh, only if --make is being used
05:50:21 <Marvin--> well, it doesn't run --make
05:50:34 <Marvin--> 1 expected passes
05:50:35 <Marvin--> yay
05:51:01 <Igloo> I'd make it give the wrong answer and check it fails if I were you  :-)
05:51:16 <Marvin--> I will
05:51:33 <Marvin--> whoops, I should probably stick to WAY=normal
05:53:18 <Marvin--> well, currently my tests are as advanced as  [ x | (x,"") <- readP_to_S (chainl1 (munch1 isDigit >>= return.read) (char '-' >> return (-))) "1-2-3-4" ] == [ foldl1 (-) [1,2,3,4] ]
05:53:35 <Marvin--> and vice versa for chainr/foldr
05:53:51 <Marvin--> but that
05:53:54 <Marvin--> that's a nice test case to have
05:58:25 <Marvin--> SyntaxNinja: niice!
05:58:38 <Igloo> ?
05:58:57 <Marvin--> he's added code for building and installing executables
05:59:24 <Igloo> Ah, cool
05:59:47 * Marvin-- ponders what else to put in the test suite
06:00:06 <Marvin--> the chain combinators were the only slightly complex combinators, really
06:00:51 <Igloo> Check +++ gives you all results
06:01:29 <Igloo> That many accepts no things and many1 doesn't, that they both accept 3 things, that optional can both take and not take a thing
06:07:58 <Marvin--> well, there are already quickcheck tests for +++ and <++ and stuff
06:14:21 <Marvin--> prop_Plus p q s = readP_to_S (p +++ q) s =~. (readP_to_S p s ++ readP_to_S q s)
06:25:40 <Marvin--> ah, there you are
06:28:29 <SyntaxNinja> hihi Marvin--
06:28:46 <Marvin--> <Marvin--> SyntaxNinja: niice!
06:28:50 <Marvin--> (re: the executable building)
06:29:19 <SyntaxNinja> :) wash2hs works now :)
06:29:55 <SyntaxNinja> did you get the latest patch from about 45 minutes ago? sorry I emailed it too, I was having connectivity problems last night.
06:35:56 <Marvin--> I got it both by mail and from a pull
06:37:12 <Marvin--> I will probably add my ReadPCombinators module to the Distribution dir and use that for .Version and .Package, and when ghc 6.4 is released (hopefully with my ReadP combinators included) we can do some conditonal compilation and stuff, and either way we get rid of the parsec dependency, how does that sound?
06:39:33 <SyntaxNinja> sure, sounds good :)
06:44:01 <Cale> The list monad is really strong for doing lazy exhaustive search with greedy solutions first. (If there's a name for that, it would be good to know)
06:48:58 <Cale> I'm more and more impressed by the elegance of this kind of computation where you have layered processes each lazily consuming a list and producing another lazy list (by monadic extension) ordered roughly by the likelihood that the solution is the one you want.
06:52:25 <Marvin--> yeah, it's nifty
06:57:50 <SyntaxNinja> so I've got a little problem. I need to make the executables actually executable, or copy with preserving permissions... but is there a ifdef POSIX or something I can use for conditional import and such?
06:57:55 <SyntaxNinja> or maybe I shouldn't care about posix?
06:58:01 <SyntaxNinja> erum. non-posix?
06:59:15 * Igloo sighs. alex 125th in the mips queue. Oh well, at least it's bounded above by 10000 or so  :-)
06:59:52 <Marvin--> go mips!
06:59:57 <Igloo> Doesn't Windows have the POSIX module?
06:59:57 <Marvin--> how's m68k doing? :)
07:00:06 <bringert> SyntaxNinja: System.Directory has setPermissions :: FilePath -> Permissions -> IO ()
07:00:24 <Igloo> It built alex aaages ago  :-)
07:00:34 <bringert> dunno what it does on windows, but at least it should be there
07:01:00 <Marvin--> I guess there are more m68k buildds than mips buildds
07:01:05 <SyntaxNinja> bringert: oh. hm
07:01:23 <SyntaxNinja> that's 1337
07:04:06 * Marvin-- idly wonders how many percent of the lines in Distribution.Version are commented out now
07:04:31 <Igloo> :-)
07:05:46 <bringert> friday!
07:05:53 * SyntaxNinja waits for shapr to poke Marvin-- with the refactor stick
07:06:26 <Marvin--> in my defense, a lot of stuff already was commented out, and some *should*'ve been
07:07:26 <SyntaxNinja> :)
07:07:45 <SyntaxNinja> the module suffers from a lack of attention as a child
07:11:34 <Marvin--> I think I'll just throw out all the crap, if we really need it it can be restored from the repo
07:11:49 <SyntaxNinja> there's an attic file if there's anything in particular you want to save
07:14:08 <SyntaxNinja> OK copyFile preserves permissions now.
07:18:33 <Marvin--> attic file?
07:20:16 <Igloo> Is it just me or does http://www.python.org/doc/2.3.4/lib/matching-searching.html not actually explain matching vs searching?
07:20:25 <SyntaxNinja> I think it's Distribution/attic looks like I forgot to add it
07:20:30 <SyntaxNinja> I'll add it just for fun
07:20:58 <Marvin--> but why do we need such a file? Can't we just restore older versions using darcs?
07:21:19 <SyntaxNinja> well, this is for things you might want to save and have an easy time finding.
07:22:04 <Marvin--> eh, I don't think any of this is interesting to save
07:22:13 <SyntaxNinja> that's fine.
07:22:17 <Marvin--> old date parsing crud and stuff
07:22:44 <SyntaxNinja> the date parsing was so beautiful!
07:24:01 <Marvin--> and unused
07:27:15 <SyntaxNinja> *sigh*
07:45:28 <Marvin--> we-ell, replacing Parsec with ReadP was pretty simple
07:49:08 <Marvin--> heh, though I turned out to only use many and sepBy1§
07:49:10 <Marvin--> sepBy1 even
07:52:05 * shapr pokes Marvin-- with the refactor stick
07:52:10 <SyntaxNinja> so I'm about to post cabalized WASH
07:52:22 <shapr> yay!
07:52:48 <Marvin--> SyntaxNinja: hm, why is there no Exposed-Modules field in the cabal description file? (do we even do anything *with* that field yet?)
07:52:58 <Marvin--> shapr: hey, careful with that thing
07:53:35 <SyntaxNinja> Marvin--: no, I think that's waiting on HC-PKG
07:53:42 <Marvin--> oh, okay
07:53:52 <Marvin--> so there's no way to make a module sekhrut yet?
07:55:20 <Marvin--> remind me again, why are we using Distribution.GetOpt instead of System.Console.GetOpt?
07:55:23 <SyntaxNinja> not really.
07:55:49 <Marvin--> oh wait, there's the comment
07:55:50 <SyntaxNinja> Marvin--: because there's no way to ignore stuff we don't understand in System.Console.GetOpt, so I had to hack that in
07:55:59 <Marvin--> right
07:56:23 <Marvin--> I used a locally-hacked GetOpt in h2fol too :-/
07:56:48 <Marvin--> I wanted some decent line wrapping, since I had long flag names
07:57:16 <SyntaxNinja> yeah, that's a problem
07:57:26 <Marvin--> But I sent that upstream too
07:57:37 <SyntaxNinja> darcs get http://cvs.haskell.org/darcs/cabal_examples
07:58:09 <Marvin--> hm, now that we can build executables, I should give cabalizing h2fol another go
07:59:30 * Igloo ponders trying to cabalise some of my stuff this weekend
07:59:44 <SyntaxNinja> bug reports and patches welcome :)
08:00:26 <SyntaxNinja> maybe this is a good time to drop the bomb about what the description files look like
08:00:45 <Marvin--> hmm, why did make hunitInstall PREF=/tmp/hunit  create /tmp/hunit/bin?
08:00:52 <SyntaxNinja> hm
08:00:55 <SyntaxNinja> thanks for the bug repor
08:00:56 <SyntaxNinja> t
08:00:59 <Marvin--> ;)
08:01:17 <Marvin--> unless (null executables) ... :-)
08:01:27 <SyntaxNinja> right
08:04:09 * Marvin-- runs make install PREF=~/temp/cabal-libs user=1
08:04:28 <Marvin--> err, yikes
08:05:05 <Marvin--> multiple definitions of lots of symbols
08:05:09 <Marvin--> hmmmm
08:05:22 <SyntaxNinja> HUnit stuff?
08:05:27 <SyntaxNinja> do a "make remove" first?
08:05:41 <SyntaxNinja> make remvoe might not respect the user=1 flag or the PREF flag actually
08:06:11 <SyntaxNinja> I think this happens because of the Cabal and / or HUnit packages, along with the source itself.
08:06:30 <Marvin--> it might have just been that I forgot to run make clean
08:07:11 <SyntaxNinja> yeah maybe. I hate those makefiles.
08:07:32 <SyntaxNinja> it's my own damn fault for using HUnit as an example, a test, and within the system itself.
08:07:43 <Marvin--> well, the mutual recursion between cabal and hunit doesn't make it simpler
08:08:16 <Marvin--> wouldn't it be simpler if we *did not* have -DDEBUG in the OPTIONS pragma in the cabal files? Then cabal wouldn't actually depend on hunit
08:08:48 <SyntaxNinja> hm. there's not any deep reason for there to be an HUnit package within cabal anymore. it was kinda just a temporary thing
08:09:01 <SyntaxNinja> I mean... making it a cabal package was temporary
08:09:42 <SyntaxNinja> now that we have other examples, maybe I shouldn't bother with that, we can get rid of the -DDEBUG so there's no dependency
08:09:55 <SyntaxNinja> and continue to distribute HUnit with the source of Cabal
08:10:21 <Marvin--> there, this looks good
08:10:39 * Marvin-- found some errors in the makefile that was due to his stamping voodoo
08:12:00 <SyntaxNinja> the todo list never seems to get shorter
08:12:32 <Marvin--> there is that
08:13:00 <Marvin--> erhmm, the Modules: field isn't really used for executables, right?
08:13:09 <Marvin--> (yet)
08:13:35 <Marvin--> and, ehm, if I have a Foo.hs as Main module, should I write Foo or Main?
08:14:27 <SyntaxNinja> Marvin--: well, the modules field isn't yet used, but logically, it's used. at least for sdist (ohno! that's something _else_ i have to do!)
08:14:57 <SyntaxNinja> um. hm.
08:15:04 <SyntaxNinja> Foo I guess.
08:15:15 <Marvin--> but... there is no module Foo
08:15:21 <Marvin--> damn! :)
08:15:27 <SyntaxNinja> maybe the main module shouldn't be listed there.
08:15:36 <Marvin--> but that's kinda... odd too
08:15:50 * Marvin-- tries to figure out what kind of extensions he uses in h2fol, heh
08:15:51 <SyntaxNinja> kinda, but it makes more sense. we won't have any way to find the module if they use the module name.
08:15:57 <SyntaxNinja> (Main)
08:17:22 * SyntaxNinja is not sure about all this...
08:17:43 <SyntaxNinja> if they have 10 executables that each share 10 source files, they'll have to list all those source files every time. that's kinda lame.
08:17:46 <Marvin--> hmm, did you change RankTwoTypes to RankNTypes as Malcolm suggested?
08:17:51 <SyntaxNinja> not yet.
08:17:53 <Marvin--> yeah, I know
08:18:13 <SyntaxNinja> so is Modules ever going to be used? well, maybe not. we can chase down dependencies with hmake or whatever
08:18:25 <SyntaxNinja> but we still need them at least for sdist, possibly for other things
08:19:14 <SyntaxNinja> so maybe we should pull it out of BuildInfo 
08:19:38 <Marvin--> I wonder if Parsek needs anything else than forall
08:19:40 * Marvin-- frowns
08:19:59 <SyntaxNinja> I'm about to go to a meeting, I think.
08:20:49 <Marvin--> I'll let you know how h2fol works out :)
08:22:29 <SyntaxNinja> cool. thanks.
08:23:09 <Marvin--> oohboy
08:23:28 <Marvin--> I'm deriving Data and Typeable all over the place
08:23:46 <Marvin--> what Extension does that correspond to, you think?
08:24:35 * SyntaxNinja doesn't know
08:24:51 <SyntaxNinja> think about the ramifications of moving modules outside of buildInfo and into PackageDescription
08:24:52 * SyntaxNinja &
08:26:23 <Marvin--> "You need -fglasgow-exts to derive an instance for this class"
08:26:25 * Marvin-- swears
08:39:34 <Marvin--> meh, the executable building isn't exactly working
09:24:14 * Marvin-- brings out the refactoring stick again
09:30:03 <Igloo> Don't forget to refill it with refactoring juice and return it to shapr when you're done
09:30:35 <SamB> refactoring juice?
09:31:55 <Marvin--> coffee?
09:32:27 <Marvin--> this code looks more like it's been hit with the ugly stick than a refactoring stick
09:36:04 <Marvin--> heh, these command lines aren't short
09:42:15 * shapr snickers
09:44:06 * Marvin-- rebuilds cabal and hunit for the umpteenth time
09:44:33 <Marvin--> gah, note to self: run *both* make remove and make clean
09:44:39 * Marvin-- rebuilds cabal and hunit for the umpteenth+1 time
09:44:47 <Igloo> :-)
09:45:18 <Marvin--> I need a beer
09:47:01 <Marvin--> heh, maybe we should run nub on the result of extensionToFlag
09:47:08 <Marvin--> I'm getting a zillion -fglasgow-exts here
09:47:23 <Marvin--> but yay, it worked
09:47:39 <Marvin--> coolies
09:47:54 <Marvin--> now to make this work with preprocessing
09:47:55 * Marvin-- sighs
09:48:52 <Marvin--> no, actually, time to eat
09:49:30 <shapr> I just had a beer.
09:49:34 <shapr> it wasn't very exciting.
09:49:42 <shapr> the uncycling was more fun.
09:50:03 <shapr> I'm wearing the tread off my tire :-(
09:50:14 <Igloo> Heh
09:51:17 <shapr> it's completely flat in two places, and nearly flat in the rest of the center.
10:07:03 <Smerdyakov> shapr, your face? :O
10:22:29 * Marvin-- now has a beer
10:31:27 <Marvin--> SyntaxNinja: I've fixed executable building
10:31:40 <Marvin--> (it didn't pass options and stuff)
10:33:43 <SyntaxNinja> oh yeah, options
10:34:00 <Marvin--> so I started refactoring constructGHCCommandLine a bit
10:34:01 <SyntaxNinja> so I was going to refactor that constructGhcCommandLine thing so we don't have to duplicate code for that stuff
10:34:25 <Marvin--> it looks like this now: constructGHCCmdLine :: BuildInfo -> [PackageIdentifier] -> [String]
10:35:07 <SyntaxNinja> cool.
10:35:27 <Marvin--> a bigger problem is that we don't preprocess the sources for executables
10:35:52 <Marvin--> and like you said earlier, I'm a bit worried about how to handle overlapping hs-source-dir
10:37:55 <SyntaxNinja> preprocessing the sources for executables should be easy enough
10:37:59 <SyntaxNinja> what do you mean about overlapping dir?
10:38:35 <Marvin--> well, for my case, both executables have the same hs-source-dir
10:39:10 <SyntaxNinja> why is that a problem?
10:40:18 <Marvin--> well, several files are common between the executables, so they'll be listed twice
10:40:37 <Marvin--> should we just nub (map modules executables) ?
10:40:50 <Marvin--> er, nub . concat $ map modules exes that is
10:40:50 <SyntaxNinja> but we nub them when we move them, right?
10:41:18 <Marvin--> I dunno
10:41:29 <Marvin--> we don't, at all, at the moment :)
10:42:10 <SyntaxNinja> btw, we had a power outage here while I was afk, so I might have missed something.
10:42:55 <SyntaxNinja> but. hmm, so we don't have to worry so much about nub if they list all the modules in packageDescription intseaed of buildinfo, right?
10:42:59 <SyntaxNinja> did you have any thoughts on that idea?
10:43:41 <Marvin--> yes, I do, I don't see how it'll work... how would it know which modules to use for the library-if-any?
10:43:48 <Igloo> That can be written as nub $ concatMap modules exes FYI
10:44:04 <Marvin--> Igloo: yeah yeah yeah
10:44:15 <Marvin--> :)
10:45:45 <SyntaxNinja> I think we need to clarify some distinctions; maybe we should add a section for libraries just like the one for executables?
10:46:08 <SyntaxNinja> I do like the semantics of the library name being the same as the package nam.e
10:46:27 <Marvin--> won't we lose the 1:1 between package and library then?
10:46:47 <SyntaxNinja> yeah... 
10:47:20 <SyntaxNinja> well,  maybe we can say that modules isn't use for executables then...
10:47:35 <SyntaxNinja> I don't like the idea of having to list modules names over and over again
10:48:55 <Marvin--> oh I do see your point
10:49:14 <Marvin--> but if we don't have hmake, we'll need to do that anyway
10:49:28 <Marvin--> and if we do have hmake... would we need to list the modules at all?
10:50:16 <SyntaxNinja> so they can be included in sdist
10:51:47 <Marvin--> I don't really mean calling hmake as a command, I meant merging hmake with cabal
10:52:16 <Marvin--> then sdist could look at the listed modules for the library, and the main modules for the executables, and generate a list of dependencies
10:52:36 <SyntaxNinja> true enough. I really want to do that, and the code is somewhat ready
10:53:00 <Marvin--> actually, then we wouldn't even need the distinction between exposed modules and all modules, because you'd just list the exposed modules and the rest are pulled in by deps
10:53:10 <SyntaxNinja> but then what do we do for the 0.1 release? I guess having a slightly broken sdist command isn't TOO bad, but it's definitely sub-optimal.
10:53:22 <SyntaxNinja> ooh! I like that idea.
10:54:22 <Marvin--> I bought a crate of beer today, btw, where should I send the bill? ;)
10:54:45 <Marvin--> anyway, no, we can't really do that for 0.1
10:54:52 <SyntaxNinja> but I ph43r making the relesae contingent on dependency tracking
10:54:58 <SyntaxNinja> unless ghc can output the dependencies or something?
10:55:15 <Marvin--> ghc -M outputs it in make format
10:55:56 <Marvin--> no, I think actually ghc -M modifies an existing Makefile, which is kinda broken
10:56:25 <Igloo> You can change which file it is, but I don't remember if - is possible
10:57:01 <Marvin--> -M isn't listed in the man page :(
10:57:32 <SyntaxNinja> so the problem with just listing exposed modules is that now we definitely need to chase down dependencies if we want to build libraries, and that's lame.
10:57:58 <Igloo> Hmm, it's probably hiding somewhere with --make. I'm going to try to hunt the small issues like that down when 6.2.1-4 finally gets into testing
10:58:13 <Marvin--> well, what I meant was that "if we have dependency tracking, we could use it for this too", you know :)
10:58:36 <SyntaxNinja> right
10:58:45 <SyntaxNinja> but the thing is that it impacts the interface pretty heavily.
10:58:53 <SyntaxNinja> I guess what we can do...
10:59:00 <SyntaxNinja> we can leave it as it is now, but using nub as necessary
10:59:12 <SyntaxNinja> then just make the "modules" fields optional later, once we have dependency tracking built in
10:59:21 <Marvin--> makes sense
10:59:36 <Marvin--> let me see if my preprocessing fix worked
10:59:50 <SyntaxNinja> c00l
10:59:56 <SyntaxNinja> btw, have you ever been able to run the test suite?
10:59:59 <SyntaxNinja> I think I might have made it easier now.
11:00:37 <Marvin--> I don't think I've ever tried, except for the hunit stuff
11:00:53 <Marvin--> except for the per-module tests, of course
11:00:53 <SyntaxNinja> make moduleTest && ./moduleTest
11:01:35 <Marvin--> ah, neat
11:02:14 <SyntaxNinja> btw, from my memory, you've never broken the test suite :)
11:03:03 <Marvin--> well, I've mainly been working on D.Package and made sure to run those tests before recording and sending
11:03:04 <SyntaxNinja> it should fail on one test. I'm thinking of removing that test for the time being
11:03:16 <Marvin--> and we have no idea what the coverage is anyway ;)
11:05:07 <SyntaxNinja> it's not too bad, I'd say :) tests the major features, and whenever I Find a bug, I add a test for it.
11:05:22 <Marvin--> hmmyep, that seemed to work... now to make the exe building use the files in dist/ instead
11:07:01 <SyntaxNinja> any chance of adding mainModules to sdist btw?
11:07:07 <SyntaxNinja> oh, and you can send me the bill for the beer ;)
11:07:36 <SyntaxNinja> we should create, as a component of cabal, some kind of networked international mechanism for buying someone a beer.
11:11:09 * SyntaxNinja off to another meeting &
11:12:16 * Marvin-- wreaks havoc in the repo
11:18:20 <Marvin--> oh crap
11:20:50 <Marvin--> okay, this officially sucks
11:21:32 <Riastradh> What does?
11:21:33 <Marvin--> When Foo.hs is the Main module, ghc --make Foo.hs creates Foo.hi and Foo.o, but ghc --make -odir some/where Foo.hs creates Foo.hi and Main.o
11:21:47 <Riastradh> Inded.
11:21:50 <Riastradh> Indeed, even.
11:23:29 <Marvin--> now let's see where to report bugs
11:25:20 <Marvin--> luckily, I don't think we need -odir at all
11:25:30 <Marvin--> not that that's an excuse for its suckage
11:33:41 <stepcut> Marvin--: what if you do ghc --make -odir some/where -hidir some/where Foo.hs ?
11:33:44 <stepcut> (just curious)
11:34:00 <stepcut> actually, i know the answer
11:34:09 <stepcut> some/where/Main.hi and some/where/Main.o
11:35:19 <Marvin--> oh, good point
11:35:51 <Marvin--> not that we really need -odir and -hidir at all, since we start by copying the sources into dist/build
11:37:03 <Marvin--> ... except that now I managed to make cabal incapable of building itself
11:37:06 <Marvin--> dang
11:37:21 <Marvin--> oh crud
11:37:37 <Igloo> Copying or symlinking(where available)?
11:38:02 <Marvin--> still need it for library building :-)
11:38:08 <Marvin--> right now copying
11:38:18 <Marvin--> the idea is that we should pass the files through whatever preprocessor makes sense
11:38:24 <Marvin--> hsc2hs/cpphs/etc.
11:38:26 <Igloo> Ah, right
11:38:32 <Marvin--> but right now that preprocessor is cp :-)
11:38:36 <Igloo> :-)
11:39:08 <Marvin--> meh, it's kinda annoying that cabal builds itself twice when building itself :)
11:49:22 <Marvin--> heh, now to sort out this mess of modifications
12:11:10 <Marvin--> woha
12:11:37 <Marvin--> these addfile bugs are annoying
12:12:35 <Marvin--> SyntaxLaptop: want some patches? :)
12:13:29 <SyntaxLaptop> Marvin--: yes!
12:17:31 <Marvin--> sent
12:17:36 <SyntaxLaptop> sweeeeeet
12:17:52 <SyntaxLaptop> is anyone here colocated w/ Marvin--?
12:18:45 * SyntaxLaptop is running out of battery
12:55:54 <Fractal> If I have this type declaration:  type Board = (Array Int Player, Player)
12:56:05 <Fractal> How can I derive a Show instance for it?
12:56:16 <Fractal> instance Show Board where
12:56:26 <Fractal>   show b = "test"
12:56:28 <Fractal> doesn't work
12:57:13 <stepcut> Fractal: you can't declare class instances for type synonyms
12:57:41 <Fractal> Can I use newtype then?
12:57:57 <stepcut> i think so... not sure
13:00:21 <Marvin--> Fractal: If Array Int Player and Player have Show instances, (Array Int Player, Player) will have a Show instance
13:00:49 <Marvin--> and so will Board, as Board is the same as the tuple
13:02:43 <Fractal> Ya, but I want to define a new show instance
13:03:07 <Smerdyakov> One is already defined for that type, so you need to do it for another type.
13:03:35 <Fractal> Er I can't override it or anything?
13:03:42 <Smerdyakov> That's right.
13:03:59 <Marvin--> there can only be one instance per type
13:04:03 <Fractal> The problem is I don't really want to create a new data definition and have constructors everywhere
13:04:27 <Smerdyakov> Why is it critical that the function to generate the string be 'show'?
13:04:29 <Marvin--> that's why hugs' restricted type synonym extension is neat
13:04:40 <Fractal> Like  data Board = B (Array Int Player, Player)
13:04:52 <Fractal> Well it's not critical I guess...
13:05:03 <Fractal> Marvin-- : What's that?
13:05:11 <Smerdyakov> 'show' is meant to show what values look like as Haskell code.
13:05:17 <Smerdyakov> The default instance for your type does this.
13:05:25 <Smerdyakov> If you want another look, it doesn't make sense to use 'show', anyway.
13:05:32 <Marvin--> you can say  type Foo = Bar in f1, f2, g, h
13:06:49 <Marvin--> the semantics is that Foo is only visible as a type synonym for Bar in exactly the functions f1, f2, g and h
13:06:57 <Marvin--> elsewhere it looks like a newtype
13:07:02 <Marvin--> too bad only hugs has it
13:07:05 <Fractal> Hmm
13:10:03 <Smerdyakov> Marvin--, Standard ML has it. :P
13:10:13 <Marvin--> feh
13:10:20 <Marvin--> you know perfectly well what I mean :)
13:10:28 <Marvin--> how wude
13:10:32 <Smerdyakov> Marvin--, well, with different syntax. The function definitions are lexically nested with the type definition.
13:12:26 <Marvin--> I find it a really useful extension, and I never quite understood why ghc doesn't have it
13:13:06 <Fractal> How do I convert from integral to string again? Something like toString ?
13:13:14 <Smerdyakov> I think the Haskell design decision to make all top-level definitions mutually recursive leads to some awkward consequences like this.
13:13:16 <Marvin--> uh, show?
13:13:25 <Fractal> Oh ya
13:14:15 <Marvin--> Fractal: well, you'll need to determine exactly which instance of Integral it is, of course
13:22:22 <cm> yo
13:43:50 <Fractal> What could this possibly mean?
13:43:51 <Fractal> rogram error: {foldl1 (Ord_min instOrd_v31) []}
13:44:00 <Fractal> Program error: {foldl1 (Ord_min instOrd_v31) []}
13:45:18 <Marvin--> that foldl1 was called with an empty list
13:45:31 <Fractal> Oh ok
13:46:49 <Fractal> Kind of an odd error message though
13:47:44 <Marvin--> it looks like it comes from after the overloading mangling
13:49:39 <Fractal> That was it, by the way
13:49:43 <Fractal> empty list
13:50:55 <Marvin--> Hugs' error messages aren't the best around
13:59:09 <Marvin--> hey andersca
13:59:11 <andersca> hey
14:26:15 <Fractal> In general, if I do something like this:
14:26:15 <Fractal> if (alpha >= (min val beta)) then val
14:26:16 <Fractal> else searchAB alpha (min beta val) ms
14:26:38 <Fractal> Are the compilers smart enough to not evaluate (min beta val) twice?
14:26:56 <Riastradh> Probably.
14:27:08 <Fractal> Or am I better of putting where min_beta_val = min beta val
14:27:12 <Fractal> And using that?
14:27:15 <Fractal> Hmm ya?
14:27:30 <Riastradh> I'd not worry about it.
14:27:52 <Riastradh> Un{less,til} profiling shows that it's a problem.
14:28:17 <Fractal> Well I'd like to know the capabilities of the compiler
15:50:38 <nleavrh> Fractal - I'd say 'where mbv = min beta val', myself, and just do that for the readability advantage.
16:52:24 <bourbaki> hi
16:52:50 <Lemmih> Hey
