01:41:22 <bourbaki> hi
03:11:58 <bourbaki> hi
03:23:32 <shapr> y0
03:28:46 <bourbaki> hi
03:41:54 <Amadan> is there somewhere some primitive function like this:
03:41:57 <Amadan> fzip f = uncurry f . zip
03:41:59 <Amadan> ?
03:42:25 <Amadan> i.e, with the same end condition as zip, but:
03:42:29 <Amadan> fzip f (x:xs) (y:ys) = (f x y):(fzip f xs ys)
03:51:55 <aleator_> zipWith?
03:53:40 <jba_> zipWith
04:01:47 <Amadan> :) thanks
04:54:15 <Igloo> Aha, GADT just hit a CVS branch
04:55:25 <TheHunter> cool! those GADTs seem really useful
05:00:44 <bourbaki> ok what are the wobbly types good for?
05:05:27 <TheHunter> they improve type-safety
05:06:25 <bourbaki> in which way ?
05:10:53 <TheHunter> they let you construct a parameterized algebraic data type that has constructors only for special parameter type, so you don't have to introduce ugly case-constructs. well, it's hard to explain
05:11:35 <bourbaki> :) ok ill just read the paper when i have time then ;)
05:11:36 <aleator_> http://research.microsoft.com/~simonpj/papers/gadt/gadt.ps.gz has an example. Are there others?
05:12:19 * TheHunter tries to write a state comonad
05:19:28 <bourbaki> TheHunter what was a good application of a comonad?
05:20:33 <TheHunter> i don't know any application for comonads. I just do that for fun. But negation types are bitches...
05:21:46 <TheHunter> i haven't even defined coreturn yet
05:23:34 <bourbaki> negation type?
05:23:51 <bourbaki> i see that coreturn as in the anamorphism
05:23:55 <TheHunter> they appear when you dualize stuff
05:24:41 <TheHunter> there are no negation types in haskell. You can emulate them with rank-2 polymorphism, but i think that's no use
05:25:49 <bourbaki> isnt it in an anamorphism like (coreturn foo, cobind bar) ?
05:27:02 <TheHunter> i don't see the connection to anamorphisms
05:27:36 <TheHunter> but there might be a connection between algebras and monads
05:27:43 <bourbaki> the idea if the anamorphism is to expand something
05:27:56 <bourbaki> and thats what a comonad does right?
05:29:15 <TheHunter> the anamorphism expands to the terminal object in the coalgebra category, coreturn just expands into the image of the functor
05:29:33 <TheHunter> ok, that was nonsense
05:30:16 <bourbaki> well the cobind is like the coproduct of the coalgebra
05:32:22 <TheHunter> i don't know much about algebras/coalgebras
05:32:57 <bourbaki> ok but what could you use that co return for?
05:33:17 <Cale> hmmm... the declaration scanner in haskell-mode is scanning too early. font-lock-mode needs to be on before it can work.
05:33:19 <bourbaki> in a monad the return to me is like a lift into the space of computations
05:34:29 <TheHunter> i think of w a as containing the state of the world
05:34:37 <bourbaki> is the coreturn then something like the projection to the space of values?
05:34:54 <TheHunter> that's what i think
05:35:13 <bourbaki> well maybe we can try to apply it to my l system then
05:35:34 <bourbaki> you have the space of literals that the productions act on
05:35:39 <TheHunter> i wouldn't try that, comonads are hard to think about
05:35:56 <bourbaki> so T -> T^2 is something that extends the string
05:37:06 <Cale> TheHunter: I thought I told you that comonads don't have to capture state :)
05:38:07 <bourbaki> isnt a comonad something like head and tail of a list ie?
05:38:50 <TheHunter> Cale, i know, but i find it convenient to think that way :)
05:39:54 <bourbaki> where monads construct lists comonads decompose them
05:40:34 <TheHunter> it might be possible to make infinite list a comonad instance, but you'll have the prove the laws...
05:41:04 <Cale> finite lists too
05:41:17 <Cale> hmm
05:41:39 <Cale> well, hmm... perhaps not
05:42:45 <Cale> you could perhaps cojoin a singleton list [x] to [[x],[x]], and then it will act like an infinite list
05:43:54 <TheHunter> Cale, do you have intuition for list comonads?
05:43:56 <Cale> not sure how "natural" that is though :)
05:44:21 <bourbaki> yes why not?
05:44:37 <bourbaki> lik cobind [x] -> [[x],[x]]
05:45:00 <Cale> we still have the problem of the empty list
05:45:12 <Cale> but I suppose that not much can be done with that
05:45:17 <bourbaki> cobind [x] = [[(head x)],tail x]
05:45:22 <Cale> yes
05:45:28 <Cale> er
05:45:30 <bourbaki> and the return
05:45:33 <Cale> cojoin you mean
05:45:47 <Cale> cobind is different
05:45:50 <bourbaki> cobind [x] = [(coreturn [(head x)]),tail x]
05:45:58 <bourbaki> that would be roughly like an anamorphism
05:46:07 <bourbaki> yes sry
05:46:08 <Cale> that doesn't have the right type
05:46:26 <bourbaki> but thats like an anamorphism isnt it?
05:47:00 <bourbaki> processString string = rule1 (head string) ++ (tail string)
05:47:16 <bourbaki> thats what i do in my lsystem
05:48:35 <bourbaki> where rule1 returns a list again
05:49:01 <TheHunter> ok, i'm starting to think that implementing a state comonad in haskell is impossible
05:49:30 <bourbaki> heh
05:49:48 <Cale> what about the one from the paper?
05:49:57 <Cale> Does it not work?
05:50:26 <TheHunter> i don't believe that's a state comonad
05:50:37 <TheHunter> it's more like a reader comonad
05:51:08 <bourbaki> i have a paper that does some stuff with coalgebras and automatas
05:52:02 <TheHunter> i wanted my comonad to have type isomorphic to ~s * (s + a)
05:53:00 <bourbaki> ?
05:53:10 <bourbaki> sec let me search the url
05:56:07 <bourbaki> http://www.dsse.ecs.soton.ac.uk/seminars/docs/CirsteaTalk.pdf
05:57:38 <TheHunter> man, i hate slides
05:58:03 <bourbaki> sry its from some seminar :)
06:03:19 <TheHunter> i don't understand it :(
06:03:57 <bourbaki> i had another paper about coalgebras where they did that more explicitly if i find it then i will send it to you
06:07:32 * esap suggests reading about CFFD equivalence. Seems related as well.
06:07:58 <bourbaki> CFFD?
06:08:15 <esap> I think it stands for 'chaos-free failures divergences' or something like that.
06:08:22 <bourbaki> heh
06:48:49 <Cale> TheHunter: I'm not entirely sure what that type you gave means, but I agree that there's no way to make (State s) into a comonad.
06:50:22 <bourbaki> why is that?
06:51:11 <Cale> because you need to apply an initial state to get a value of type a out
06:51:24 <Cale> so there's no good definition for coreturn
06:51:38 <Cale> you can't break the boxes up
06:51:59 <bourbaki> hm
06:52:59 <Cale> A monad m is like a container for values where you can take a value, and make a container from it, and also take a container of containers, and join them all together.
06:53:30 <Igloo> SyntaxNinja: I didn't e-mail SM having written a small test that showed the problem I suspected, incidentally
06:53:40 <bourbaki> well but these containers are he elements you do compuatations over right?
06:53:50 <Cale> A comonad w is like a container for values where you can take a container, and grab out a value, and also take a container and chop it up into a container of containers.
06:53:51 <bourbaki> and they dont have to be decomposable in the end
06:54:22 <SyntaxNinja> Igloo: this is the -package problem an ddependencies?
06:54:37 <Cale> I think the whole point is that they're internally decomposable.
06:54:57 <bourbaki> but then you would have something like a coalgebra
06:55:00 <bourbaki> or comonad
06:55:01 <SyntaxNinja> so my laptop is back to the land of the living, is there anything important tor ead in the PROPOSAL or "madness" emails on debian-devel?
06:55:05 <Igloo> It's the ABI changing when you make changes to how your library works (and are compiling with optimisation)
06:55:08 <TheHunter> Cale, maybe it's possible in sml using continuations
06:55:10 <bourbaki> and thus it was some kind of bialgebra or bimonad
06:55:33 <Igloo> Well, not the ABI changing so much as cross-module inlining meaning the wrong code is linked
06:55:34 <Cale> TheHunter: yes, perhaps if you make use of continuations you can get something
06:55:45 <Cale> bourbaki: hm?
06:55:52 <Cale> which thing are you talking about?
06:56:17 <bourbaki> if a monad construct decomposable elements
06:56:26 <bourbaki> then you can define a coalgebra on it right?
06:56:39 <Igloo> Not really, I don't think (re d-d)
06:56:57 <SyntaxNinja> Igloo: yeah, I figured.
06:57:06 <Igloo> Except the unhapiness of many people at a GR being used to decide things like amd64 inclusion
06:57:14 <SyntaxNinja> right, I got that from planet.debian :)
06:58:16 <Igloo> The result of the inlining thing is that libraries'll need to depend on libfoo-ghc6 (= 1.2.3-4)
07:00:39 <Cale> bourbaki: a monad is more like an algebra - it has a sort of "multiplication"
07:00:54 <Cale> It's the comonad that's sort of coalgebraic
07:01:14 <bourbaki> yes
07:01:27 <bourbaki> but if the type of the monad is decomposable
07:01:32 <bourbaki> that multiplication
07:01:40 <bourbaki> then you have a comultiplication
07:01:48 <bourbaki> and thus something like cobind
07:01:52 <Cale> Yeah
07:01:54 <bourbaki> cojoin that is
07:02:09 <bourbaki> so that would apply to lists for example
07:02:17 <Cale> yeah
07:02:19 <bourbaki> i just wonder why there is nothing like a bimonad
07:02:19 <Cale> or trees.
07:02:31 <Cale> Well, sure, if you want to call it that.
07:05:55 <bourbaki> and imho you can do anamorphisms and catamorphisms
07:13:59 <Cale> bourbaki: quite possibly
07:49:29 <bourbaki> can someone give me an example for a cone of a functor?
08:56:31 <segv> let me see if i get this straight: foo (x:xs) = ... denotes a function of type [a] -> whatever, foo [x:xs] is hog wash, and foo (x, xs) = ... is a function (a, a) -> whatever.
08:57:44 <Cale> foo [x:xs] is valid, it's a function from [[a]] -> whatever
08:58:00 <Cale> and the last one is (a,b) -> whatever
08:58:01 <dennisb> and the last is (a,b) -> whatever, since x and xs can be anything
09:02:24 <segv> doesn't [[a]] mean "a list of lists holding things of type a" ? and x would be bound to the first list of a [a] and xs would be bound to the rest of them [[a]] or [] ?
09:03:03 <segv> or mould x be bound to the first element of the firts (and only) list in the parameter "passed" to foo?
09:03:36 <Igloo> The first one
09:03:46 <Igloo> Except even if xs = [], xs :: [[a]]
09:04:11 <segv> is [] :: [a] as well?
09:04:22 <Igloo> Yes
09:04:51 <segv> thanks.
09:05:37 <Igloo> Oh, wait, sorry, I'm wrong
09:05:44 <Igloo> You're talking about [x:xs], right?
09:05:58 <Igloo> That's taking a singleton list as an argument
09:06:23 <Igloo> so foo :: [[a]] -> ... so [x:xs] :: [[a]] so (x:xs) :: [a] so x :: a, xs :: [a]
09:06:33 <segv> i really think i need to play with this a bit more before i can ask intellingent questions (and understand the answers)
09:06:55 <segv> thanks anyway.
09:07:28 <Igloo> Don't be confused by the parentheses in (x:xs), they don't "mean" anything themselves, just like the parentheses in (3+4)*5 don't "mean" anything (but are required)
09:07:40 <Igloo> It's just a precedence thing
09:07:56 <segv> so what would "foo x : xs = ..." parse as?
09:08:18 <Igloo> (foo x) : xs
09:08:30 <Igloo> So you'd be defining the : operator, only you aren't allowed to, so it would be an error
09:08:46 <segv> that makes sense.
09:09:08 <segv> is there a way i can ask ghci what type it thinks a value (or function) is?
09:09:17 <Igloo> And (foo x) wouldn't be a valid pattern for the left hand side even if you were allowed to
09:09:19 <titanstar> :t map
09:09:52 <segv> titanstar: beautiful.
09:10:00 <segv> Igloo: that was my next question :)
09:10:33 <bour> how can i get a Maybe String to a normal String?
09:10:46 <Igloo> You can do things like this, though (redefining +):
09:10:46 <Igloo> Prelude> let x + y = x - y in 5 + 8
09:10:46 <Igloo> -3
09:10:59 <Igloo> bour: What String do you want for Nothing?
09:11:50 <Igloo> Maybe.fromMaybe "foo"   anyway
09:11:58 <bour> ah :)
09:12:13 <bour> thanks ;)
09:19:48 <segv> is there something stupid in "my_map :: ( a -> a ) -> [a] -> [a]"?
09:20:54 <Igloo> "something stupid"?
09:21:01 <Igloo> It's not as general as map
09:21:12 <segv> i want to define a more restrictive map function
09:21:29 <Igloo> Looks OK then
09:21:36 <Igloo> Why, out of interest?
09:21:41 <segv> my_map f (x:xs) = (f x) ++ (my_map f xs)
09:22:09 <Igloo> What's the type of ++?
09:22:13 <segv> Igloo: to learn how to do it.
09:22:13 <Lemmih> my_map = map
09:22:40 <mattam> i think segv wants concatMap 
09:23:05 <segv> ++ :: a -> a -> [a] ?
09:23:17 <mattam> @type (++) ?
09:23:20 <lambdabot> bzzt
09:23:30 <Igloo> No, (++) :: [a] -> [a] -> [a]
09:23:40 <Igloo> Now, what's the type of (f x)?
09:24:50 <segv> that makes sense. i should have realized that from the error message too (expceted: [a1] infered [a]).
09:25:39 <segv> s/infered [a]/infered a/
09:26:09 <segv> in fact, "my_map f (x:xs) = (f x) : (my_map f xs)" works.
09:26:19 <Igloo> Right
09:26:21 <bour> can someone help me with the error in my code?
09:26:23 <bour> http://rafb.net/paste/results/XxufLe63.html
09:26:31 <Igloo> (:) :: a -> [a] -> [a]
09:26:47 <Igloo> ++ is for joining two lists, where here you just wanted to stick an extra element on the front
09:26:49 <bour> myshow (processString [Symbol1])
09:28:32 <Igloo> bourbaki: What's the error?
09:29:00 <bourbaki> well when you run the thing the line above then it gives me an error
09:29:15 <bourbaki> non exclisives pattern in apply rules
09:31:14 <Igloo> You have a lower case r in applyRules
09:32:29 <bourbaki> ah thanks :)
09:33:29 <bourbaki> hm ok now i have some other error in there ;) thank you
09:40:09 <bringert> I seem to have written gunzip in haskell
09:43:41 <Igloo> Oh, I did that a while ago
09:43:53 <Igloo> Well, the compression algorithm I think is at the heart of it, anyway
09:44:27 <bringert> I only did decompression so far, and in the most naive way possible
09:44:37 <segv> suggested libraries for reading haskell code?
09:44:45 <bringert> it's really slow
09:44:47 <Igloo> Me too re decompression
09:45:03 <Igloo> I'll git it out later if you're interested
09:45:08 <Igloo> s/git/dig/
09:45:11 <bringert> sure
09:45:27 <Igloo> segv: Huh?
09:45:34 <bringert> how did you represent the 32K window for lookup of old output?
09:45:50 <Igloo> No idea. I'll see if I can find it  :-)
09:45:56 <bringert> I just used a list now, and the lookups account for 99.1% of the CPU time
09:46:06 <bringert> I think that's what I should optimize :)
09:46:43 <Igloo>  history :: Array Word32 Word32, -- last 32768 output words
09:46:46 <Igloo>  loc :: Word32                   -- where in history we are
09:47:11 <bringert> so you use two of those arrays?
09:47:34 <Igloo> http://urchin.earth.li/~ian/Inflate.lhs
09:47:39 <Igloo> Why would I need 2?
09:48:00 <bringert> ah, of course, it's circular
09:48:15 <Igloo> Ah, yes
09:49:04 <bringert> what is the complexity of // for Array?
09:49:15 <Igloo> Depends on the array
09:49:59 <Igloo> Probably O(size) there, which is O(1) in this case of course  :-)
09:50:06 <bringert> :)
09:50:35 <Igloo> DiffArray is really O(1), but I think would use memory linear to the number of //s
09:50:53 <Igloo> Hmm, maybe not
09:51:01 <bringert> how about IOUArray?
09:51:49 <Igloo> IO*Array and ST*Array would be O(1) but require you to use them in a monadic style. Of course, I'm in a State Monad here anyway so ST*Array wouldn't be entirely unreasonable
09:53:46 <Igloo> Hmm, the docs don't mention memory. But I think it would be hard for the GCer to realise the old values could be GCed
09:55:14 * Igloo is happy for this to be used as GPL, LGPL or BSD licenced incidentally, if you want
09:56:37 <bringert> cool, thanks
09:58:26 <bringert> I'll just steal some ideas for now since I wanna learn from writing it myself, but yours looks nicer so I might just steal the whole thing later :)
09:59:45 <Igloo> Sure, I didn't know if you were working towards a goal or just doing stuff randomly to learn  :-)
10:00:09 <Igloo> I doubt I optimised this too heavily or anything
10:17:08 <bringert> I'm doing both :)
10:17:57 <Igloo> :-)
10:18:02 <Igloo> What is your goal, OOI?
10:19:09 <Smerdy> What is OOI?
10:19:36 <Igloo> Out Of Interest
10:21:35 <bringert> we have some large, redundant textfiles used as input to a haskell program
10:21:58 <bringert> I'm playing with having them gzipped to make them smaller and reduce I/O overheads
10:23:05 <bringert> hmm, using an array instead of a list for the history seems to have made it a lot slower
10:23:06 <Igloo> Ah, right. Depending on what you do once you've read them ni you might find it advantageous to stay away from Haskell Strings completely
10:23:41 <Igloo> How does the speed of yours compare to mine?
10:24:03 <bringert> I haven't run yours yet
10:24:21 <bringert> need to adapt my gzip-format reader to use you decompressor
10:24:34 <Igloo> Also, you could try changing Array to Data.Array.DiffArray and see if that improves either yours or mine
10:24:38 <Igloo> Ah, good point
10:25:10 <bringert> just changed my decompressor to use an aray instead of a list, helped a little, but not very much actually, copying old bytes still accounts for 91% of the time
10:25:27 <bringert> probably the array copting overhead
10:25:30 <Igloo> Eeek, does yours use [Bit]?
10:25:36 <bringert> total alloc = 10,496,302,976 bytes
10:25:40 <Igloo> If not it probably ought to be faster than mine  :-)
10:25:51 <bringert> for a 78K uncompressed file
10:26:06 <bringert> I kind of use [Bit]
10:26:36 <bringert> but I convert from bytes on the fly, to be able to do efficient copying of uncompressed blocks
10:27:36 <titanstar> write it in c instead :)
10:27:55 <bringert> hmm, Data.Array.Diff is in the IO monad
10:28:06 <bringert> titanstar: that's no fun
10:28:09 <Igloo> It is?
10:28:34 <bringert> ah, just the creation
10:29:07 <bringert> hmm, weird
10:29:51 <bringert> newDiffArray is in IO, but you can create one using array, which isn't. unsafePerformIO lurking somewhere in there?
10:30:29 <Lunar^> bringert: all around
10:30:40 <Lunar^> bringert: Diff array is a real hack :)
10:32:18 <bringert> whoa, DiffArray reduced time from 40-something seconds to 0.8 seconds
10:33:21 <Igloo> Can you tell if memory usage goes from constant to linear?
10:34:14 <Igloo> You'll probably need quite a large (when uncompressed) input to tell
10:34:46 <bringert> total memory allocation goes way down with DiffArry, but that's expected I guess
10:34:53 <Igloo> And preferably one that doesn't compress well, actually
10:35:02 <Igloo> Yeah, it's not copying entire arrays around as much  :-)
10:35:29 <bringert> problem is, with Array I can't test large inputs, because it takes too long :)
10:35:41 <Igloo> Heh
10:36:06 <bringert> hmm, haven't tried UArray
10:36:15 <Igloo> Just try it with DiffArray then - if you're just gunzipping then it should be constant space as long as you don't keep the result around
10:36:20 <dv> when using map, is there any way i can get the elements position in a list?
10:36:39 <Smerdyakov> dv, no. Use a different function for that.
10:36:46 <Igloo> DiffUArray is what you want
10:37:07 <bringert> actually DiffUArray was slower than DiffArray for my test
10:37:25 <Igloo> dv: zipWith f xs [0..]
10:37:32 <Igloo> Urgle?
10:38:11 * Igloo doesn't understand that
10:38:37 * bringert neither
10:38:48 <Igloo> What's it a DiffUArray of?
10:39:02 <bringert> DiffUArray Word32 Word8
10:39:12 <Igloo> Ah, could be an alignment thing
10:39:37 <Igloo> If it packs the Word8s tightly it'll have to update fractions of words
10:39:40 <dv> basically i need to have a list of pairs with values (position in list, number)
10:39:56 <bringert> hmm, guess that could happen
10:39:57 <Igloo> dv: zip xs [0..] then
10:39:57 <dv> i have no idea how do use zipWith to do that
10:40:08 <bringert> I noticed that you used Word32 in the array
10:40:17 <Igloo> Oh, I mean zip [0..] xs
10:40:39 <Igloo> It's zipWith (\x y -> (x, y)) [0..] xs   or just zipWith (,) [0..] xs
10:40:57 <dv> ah
10:40:58 <dv> thanks
10:41:10 <Igloo> Is there anything in the algorithm that would make Word32 the obvious choice?
10:41:22 <Igloo> (is gunzip actually RFC 1951?)
10:41:36 <bringert> well, deflate is 1951
10:41:50 <bringert> the gzip format is RFC 1952
10:42:18 <bringert> no, I would think that Word8 would be the obvious choice
10:42:45 <bringert> since the algorithm works on bytes in the decompressed data
10:43:53 <bourbaki> how can i concat an Int to a String?
10:44:02 <bringert> use show
10:44:21 <bringert> if I understand the question correctly
10:44:52 * Igloo greps the RFC and can't see an obvious reason why I'd hvae used Word32
10:45:09 <bourbaki> so "foobar " ++ (show x) where x if of type Int?
10:46:27 <kosmikus> bourbaki: yes
10:47:57 <bourbaki> :) yeah
10:48:12 <bourbaki> just have written my first lsystem in haskell ;)
10:49:03 <bourbaki> http://rafb.net/paste/results/OgDOMt27.html
10:56:25 <bringert> Igloo: yeah, it seems to be linear in total memory use
10:56:55 <Igloo> Hmm, I guess STUArray is the way to go then  :-/
10:56:55 <bringert> eh, maximum memory use rather
10:57:29 <Igloo> Well, I imagine a heap profile would show it was linear over time too
10:58:17 <Igloo> I wonder if the gzip guys ghave a testsuite
11:02:25 <bringert> heap profile looks like the upper half of an onion
11:03:40 <bringert> how come the max value in the heap profile is around 100M, when the total memory use is around 350M?
11:07:11 <bringert> hmm, what if I had a counter and every N updates it would copy the whole DiffArray to a fresh one?
11:07:56 <bringert> then we'd get bounded memory use, and reasonable fast update on average
11:12:03 <Igloo> The 350M will include stuff that is freed, no?
11:12:31 * Igloo doesn't understand "looks like the upper half of an onion"
11:12:56 <Igloo> Can you put the graph on the web easily?
11:17:16 <bringert> 350M was the "total memory use", "total allocated" was a lot higher, a couple of gigs
11:17:59 <bringert> Igloo: http://www.cs.chalmers.se/~bringert/misc/
11:18:53 <Igloo> Hmm. Do you wait to see if it succeeds or fails before doing whatever it is you do with the output?
11:18:59 <bringert> making fresh DiffArrays once in a while seemed to help
11:19:51 <Lunar^> Does anyone know if there is an IMAP library ?
11:23:35 <bringert> there's one in haskell-libs, don't know anything about it though: http://cvs.sourceforge.net/viewcvs.py/*checkout*/haskell-libs/libs/Imap.hs
11:26:48 <bringert> Igloo: yeah, I'm guessing that's one of the problems
11:27:20 <bringert> as I said before, I've coded it in the most naive way possible, thinking that premature optimization is the root of all evil
11:27:30 <Igloo> If that is the case you'd expect it to be linear regardless of whether the DiffArray updates get GCed
11:28:34 <bringert> yeah
11:29:14 <bringert> but that should only be the output list that grows like that, right?
11:29:36 <bringert> lots of that that word in that there sentence
11:29:36 <Igloo> As opposed to what?
11:30:12 <Igloo> There's no reason why the array can't be constant space if that's what you mean
11:30:22 <bringert> as opposed to the list of history updates, which, come to think of it, probably is on the same scale
11:30:32 <bringert> guess so
11:30:48 <Igloo> history updates are the same as the output
11:31:09 <bringert> would this be the time for a lazy state monad?
11:33:23 <bringert> thing is, the output is only about 650K here, so I can't see why it should use that much memory
11:55:51 <Igloo> What do you mean by a lazy state monad?
11:55:58 <Igloo> The nede the state itself to be strict
11:56:05 <Igloo> s/The nede/You need/
11:56:47 <Igloo> You just need to return String and throw exceptions if you get bad input rather than returning Maybe String
11:57:04 <Igloo> Hmm, darcs would suck for a gzip testsuite
11:57:18 <bringert> hmm, that's what I do already, need to think about this
11:58:35 <Igloo> To see if it's actually behaving lazily, do something like    do xs <- readFile "foo.gz"; let x i = x (i+1); print inflate (take 1000 xs ++ x 0)   and see if you get any output
11:58:50 <Igloo> Oh, hSetBuffering stdout NoBuffering first
12:13:25 <bringert> ok, thanks, will look at that later. trying to get the crc-32 check working
12:17:57 * Igloo wonders if there's an easy way to get the unicode test to pass on the buildds
12:20:16 <Igloo> Looks like there's one in Haskell libs if you want one to compare against
12:27:27 <bringert> that's the one I'm using :)
12:28:00 <bringert> it gives the right result, same as cksum(1), but it's not the same as the checksum in the gz-file
12:28:18 <Igloo> Ah
12:28:24 <bringert> or rather, I must be reading the gz-file wrong somehow
12:28:56 <Igloo> :-(
12:29:23 <bringert> I don't get it, are there different CRC-32 algorithms or something?
12:29:45 <Igloo> I'm not sure
12:30:25 <Igloo> Are you sure you are checksumming the right part of the file? And does the answer you get appear in the file?
12:30:30 * SyntaxNinja has had a lot of meetings this week.
12:31:00 <Igloo> You should write some code to recover
12:31:25 <Igloo> At worst, get the gzip C code and so through it with gdb
12:31:45 <bringert> my gzip program calculates gets the same checksum as cksum on the uncompressed file
12:31:56 <bringert> but that does not seem to be the checksum in the .gz-file
12:32:01 <SyntaxNinja> I've noticed that meetings usually make it harder to write code, not easier.
12:40:55 <Igloo> You just need to have your laptop under the desk and go "Uh huh" every now and again. The tricky part is learning to hack without being able to see what's one the screen
12:42:41 <SyntaxNinja> heh
12:43:28 <SyntaxNinja> it takes a great deal of concentration for me to hack productively. also, if I don't pay attention to the meetings, then I don't get to have any influence over the direction we're going.
12:50:31 <bringert> this isn't funny anymore, cksum and my program say the checksum is 2073713086, the value in the file is 831927574 and gzip -l --verbose says that it is 31963516
12:52:05 <Igloo> Heh
12:52:39 <Igloo> Convert them to hex, hexdump the file and look for any of those near the top
12:52:59 <Igloo> Don't forget byte swapping and endianness might happen
12:54:18 <bringert> I've checked that already :(
12:55:20 <Igloo> And you found only 831927574?
12:57:52 <bringert> rfc 1952 says the crc-32 checksum should be 4 bytes from the end of the file
12:58:12 <bringert> (it's only followed by a 32-bit input size)
12:59:03 <bringert> and that's 0x16359631 = 831927574
12:59:26 <Igloo> 0x16359631 is what gzip -l --verbose said byte-backwards
12:59:51 <bringert> heh, I saw that right when you wrote that :)
13:00:05 <bringert> stupid gzip, should prepend 0x to hex numbers
13:01:11 <bringert> that must mean that either there are different crc-32 algorithms, or gzip doesn't use crc-32 in the obvious way
13:02:51 <bringert> hmm, maybe it uses the braindead, least-significant-bit-first encoding
13:03:09 <bringert> hmm, no, crc-32 is bytewise
13:04:10 <Igloo> Best to either look at the links in the RFC (including references at the end) or the C source
13:04:39 <bringert> the rfc has a reference crc32 implementation in it
13:04:51 <Igloo> Ah, well, there you go then  :-)
13:11:52 <bringert> ok, there really shouldn't be different algorithms called CRC-32, but it seems there are
13:12:23 <bringert> the reference implementation from rfc 1952 gives 831927574, the same as gzip does
13:12:36 <bringert> which is not the same as what cksum gives
13:17:42 <bringert> hmm, it seems the haskell-libs crc32.hs does not actually use the CRC-32 algorithm
13:30:11 <SyntaxNinja> cool! it was actually quite easy to Cabal-ize at least the "Utility" part of WASH
13:30:33 <stepcut> SyntaxNinja: nice!
13:30:43 <stepcut> SyntaxNinja: I tried, but failed
13:30:48 <SyntaxNinja> really?
13:30:52 <SyntaxNinja> hm.
13:31:05 <SyntaxNinja> @wiki HaskellIrcPastePage
13:31:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:31:24 <stepcut> I don't think i got cabal installed right or something ...
13:31:52 <SyntaxNinja> oh :(
13:32:00 <SyntaxNinja> I have to tweak the makefiles / installer thing
13:32:08 <SyntaxNinja> there are definitely some sub-optimal things going on there. 
13:33:07 <stepcut> ~/projects/haskell/wash/Utility-0.3.10 # ./Setup.lhs configure --ghc
13:33:07 <stepcut> runhugs: Error occurred
13:33:07 <stepcut> ERROR "./Setup.lhs" - Can't find imported module "Distribution.Simple"
13:33:22 <stepcut> :p
13:33:31 <Marvin--> can't get much more wrong than that :P
13:33:33 <SyntaxNinja> oh
13:33:44 <SyntaxNinja> hugs maybe doesn't work yet. that #! at the top is just to throw you fof
13:33:45 <SyntaxNinja> off
13:34:07 <SyntaxNinja> try ghc -package text -package Cabal -package parsec Setup.lhs -o setup
13:34:07 <stepcut> yeah, I couldn't envisioning hugs working, so I stopped until I got a chance to ask you :)
13:34:37 <SyntaxNinja> actually, delete "-package text"
13:35:03 <Marvin--> er, is -package parsec really needed? Didn't you fix the description file for cabal?
13:35:05 <SyntaxNinja> and I"m not clear if the fact that one needs to indicate -package cabal is a bug or not
13:35:18 <SyntaxNinja> Marvin--: yeah, but haven't yet pushed that change
13:35:18 <stepcut> ./setup 
13:35:19 <stepcut> Fail: Setup.description: openFile: does not exist (No such file or directory)
13:35:21 <Marvin--> oh
13:35:35 <SyntaxNinja> stepcut: go to the HaskellIrcPastePage to get the description file
13:35:46 <SyntaxNinja> Marvin--: i'll do that in a minute.
13:35:59 <Marvin--> did you get a chance to look at the patch for a new parseFilePath?
13:36:13 <SyntaxNinja> Marvin--: from yesterday? nope.
13:36:21 <SyntaxNinja> a friend of mine got laid off yesterday and so I went drinking with him.
13:36:29 <SyntaxNinja> so yeah, I'll do some hacking tonight.
13:36:42 <SyntaxNinja> now that my laptop is back. for some reason, gmail was a PIA for getting the patches.
13:36:42 <Marvin--> oh, sucks
13:36:53 <Marvin--> :/
13:37:52 <stepcut> SyntaxNinja: what do I do once I have the description file?
13:37:53 <Marvin--> can't say I've been extraordinarily productive today either :)
13:38:02 * Marvin-- has been playing computer games with a friend all day
13:38:11 <SyntaxNinja> stepcut: if you have the description file, and you manage to build Setup.lhs, then you shuold be able to try ./setup configure 
13:38:50 <stepcut> does the description file need a specific name?
13:39:06 <Marvin--> Setup.description: openFile: does not exist, remember :)
13:39:28 <SyntaxNinja> but...but
13:39:38 <SyntaxNinja> oh, yeah.
13:39:50 <stepcut> Marvin--: yeah, I remember that part
13:39:59 <Marvin--> that's what the description file should be called
13:40:00 <SyntaxNinja> So you should have Setup.{lhs,description}
13:40:30 <stepcut> ah, I though Setup.description was the function that threw the expcetion
13:40:38 <Marvin--> oh, no
13:40:45 <stepcut> :p
13:40:56 <Marvin--> one of these days we'll put some proper error handling in cabal, too
13:41:15 <SyntaxNinja> so I pushed the dependency patch; you should be able to say: ghc -package Cabal  Setup.lhs -o setup
13:41:23 <Marvin--> (memo to self: send a warm hat to the devil first)
13:41:51 <SyntaxNinja> btw, I just noticed that the options parsing isn't done yet, but that probably is as it should be
13:42:11 <SyntaxNinja> or maybe i'm FOS, but there will probably be some small chagnes based on libraries@ traffic that I saw for the firs ttime yesterday.
13:42:27 <SyntaxNinja> also, Marvin--, I really like the look of the description files, but that's probably the Debianer in me speaking.
13:44:08 <Igloo> :-0
13:45:13 <stepcut> SyntaxNinja: when I first tried to install cabal it failed because I did not have a .ghc-packages, is .ghc-packages now required ?
13:46:14 <stepcut> SyntaxNinja: also, after you installed Wash_Utils, did it work with ghci ?
13:47:42 <SyntaxNinja> I think that you might still need ~/.ghc-packages... we fixed the configure code but not the build code... OTOH, you must configure before building so maybe it'll work.
13:47:48 <SyntaxNinja> it's a small fix, I just haven't ogtten around to it yet...
13:48:02 <SyntaxNinja> the remaining TODO list is actually really small, I wish I could have 2 hours to rub together to work on it...
13:49:06 <Marvin--> SyntaxNinja: hm, options parsing? Do you mean command line options or compiler options in the description file?
13:49:15 <stepcut> (in ghci): Loading package Wash_Utils ... ghc-6.2.1: can't load .so/.DLL for: HSWash_Utils-0.3.10 (libHSWash_Utils-0.3.10.so: cannot open shared object file: No such file or directory)
13:49:22 <SyntaxNinja> but as far as GHCI, no.
13:49:30 <SyntaxNinja> right. that's what I got too :)
13:49:37 <SyntaxNinja> that's also probably a small fix.
13:50:00 * SyntaxNinja adds to todo list
13:50:29 <SyntaxNinja> and you probably saw a warning during package install time
13:51:03 <stepcut> yes
13:52:41 <SyntaxNinja> Marvin--: the compiler options in the description file
13:53:55 <Marvin--> SyntaxNinja: hm, what's wrong with them? (except for the numerous FIXME comments...)
13:55:21 <SyntaxNinja> maybe I'm not sure; when I tried to use the ForeignFunctionInterface, i get an error
13:55:27 <SyntaxNinja> extensions: ForeignFunctionInterface
13:55:28 <SyntaxNinja> ...
13:55:33 <SyntaxNinja> Fail: "extensions" (line 1, column 1):
13:55:34 <SyntaxNinja> unexpected "F"
13:55:34 <SyntaxNinja> expecting parseExtension
13:55:44 <Marvin--> feh, you know what we should do after the first release? We should refactor all the compiler-dependent stuff and put into Distribution.Compiler.{GHC,Hugs,NHC,...}
13:55:56 <Marvin--> SyntaxNinja: meh, so you *don't* mean options, you mean *extensions* :-P
13:56:18 <Marvin--> yeah, when I wrote the extensions parser you hadn't finished the extensions data type yet
13:56:26 <SyntaxNinja> right
13:56:26 <Marvin--> I'm replacing it with a parseReadS parser now
13:56:30 <SyntaxNinja> sorry.
13:56:52 <SyntaxNinja> Marvin--: sounds like a good idea (the refactoring)
13:57:08 <Marvin--> import qualified Distribution.Compiler.GHC as GHC   and then use GHC.build, GHC.extensionToFlag etc.
13:58:35 * SyntaxNinja watches GHC work very hard to compile HtmlPrelude98 in WASH
14:03:11 * SyntaxNinja looks over martin's patch
14:05:47 <Marvin--> hm, there was a patch from Lemmih too, for cleaning up the ugliness in parseDescription
14:05:57 * Igloo hands SyntaxNinja a red biro  :-)
14:06:07 <SyntaxNinja> woowoo; Wash_HTML is now cabalized
14:06:15 <SyntaxNinja> this is addictive
14:06:15 <Igloo> Cool  :-)
14:06:27 <SyntaxNinja> now we just need the super-duper cabal-to-deb program :)
14:06:43 <SyntaxNinja> or maybe a makefile for cdbs (there's an old exmple there, I believe_)
14:07:29 <stepcut> SyntaxNinja: Wash_Utils seems to be missing Base64, is that on purpose ?
14:07:43 <Igloo> I'd rather it wasn't specific to a particular tool like cdbs unless it's intended to be fully-automatic
14:08:23 <Marvin--> dh_haskell :-)
14:08:52 <SyntaxNinja> stepcut: nope. but I think it gets included in the build by virtue of being depended upon, but that's no excuse :)
14:09:04 <Igloo> Hmm, we could have a dh_haskell for amking the Debian deps only we don't know if the version number will be in the package
14:10:11 <Marvin--> kosmikus|away: hey, did you put the thesis online yet?
14:11:40 <pimpbot5000> hi, might anyone know where isAlphanum resides in the GHC?
14:11:51 <Igloo> Data.Char
14:11:54 <pimpbot5000> thanks!
14:11:57 <Igloo> Not sure what its capitalisation is
14:12:20 <pimpbot5000> hmm, that didn't work
14:12:36 <Lemmih> It's isAlphaNum.
14:12:38 <Igloo> Not even sure it exists for that matter
14:12:42 <stepcut> SyntaxNinja: Base64.hi is not installed in /usr/lib/Wash_Utils-0.3.10
14:12:48 <SyntaxNinja> ahh
14:12:55 <SyntaxNinja> Modules: Auxiliary, Base32, Base64, FileNames, Hex, IntToString,
14:12:55 <SyntaxNinja>          JavaScript, Locking, RFC2047, RFC2279, RFC2397, SHA1,
14:12:55 <SyntaxNinja>          Shell, SimpleParser, URLCoding, Unique, ISO8601,
14:12:55 <SyntaxNinja>          QuotedPrintable
14:13:03 <SyntaxNinja> quotedprintable was missing too. sorry
14:13:31 <Igloo> Is there a sanity-checking tool that does things like look for *.hs / *.lhs that isn't listed?
14:13:58 <Igloo> And perhaps has its own config file of files to ignore
14:14:32 <SyntaxNinja> Igloo: that's a good idea :)
14:14:41 <bringert> finally!
14:15:13 <bringert> calling a file crc32.hs when it doesn't calculate CRC-32 can be confusing sometimes
14:15:31 <SyntaxNinja> if someone tells me the magic to get GHC or ghc-pkg or whatever to create ghci libraries, I can probably add it pretty quickly.
14:15:53 <bringert> ghc-pkg --auto-ghci-libs
14:16:13 <Igloo> There's something about it on the usersguide page
14:16:32 <Igloo> 4.8 IIRC
14:24:28 <SyntaxNinja> hmm. I get a darcs bug when trying to apply Lemmih's patch
14:26:18 <Lemmih> It contains obsolete escaping code iirc.
14:26:43 <SyntaxNinja> ok
14:27:14 <SyntaxNinja> sorry I couldn't get to that. I had assumed that the bug was from some mess I created when forwarding this from my sytnaxpolice to gmail so I could open the attachment, but I guess that wasn't the problem.
14:30:44 <Igloo> Hurrah, I've finished triaging the GHC test failures I have so far
14:30:55 <Marvin--> there, now I've got a patch for fixing the license and extension parsers
14:31:10 <Marvin--> they're pretty simple ;)
14:31:15 <SyntaxNinja> Marvin--: sweet :)
14:31:20 <Marvin--> parseExtension = parseReadS
14:31:26 <Marvin--> parseLicense = try parseReadS <|> liftM OtherLicense parseFilePath
14:32:22 <Marvin--> sent
14:32:23 <Igloo> Hmm, you don't need to put "Other: " in front of another licence or anything?
14:32:54 <Igloo> I worry that a less common licence cabal knows about might overlap with someone else's licence
14:32:55 <Marvin--> you think that should be necessary?
14:33:50 <Marvin--> the only ones we special case for are GPL, LGPL, BSD[34], PublicDomain and AllRightsReserved
14:34:08 <Igloo> e.g. if there was a Haskell Public Licence for the HLs (which would obviously go into cabal) then someone else might call another licence HPL as there isn't a common one by that name
14:35:01 <SyntaxNinja> yay! auto-ghci seems to work :)
14:35:09 <Igloo> Or even "Licence: GPL" vs "Licence-file: MyLicence.txt"
14:35:31 <Marvin--> hmm, good point, that's even better
14:36:09 <Igloo> Does dual licencing need a special file or can you just have multiple "Licence: Foo"s?
14:36:24 <Marvin--> feh
14:36:28 <Igloo> If the former then haveing both Licence: and Licence-file: should be an error
14:36:28 <Marvin--> special file, right now
14:37:11 * Igloo feels bad making so much noise and not having time to hack on the code
14:37:43 <Marvin--> there are *many* things that should be errors that aren't yet :-)
14:38:45 * Marvin-- wants to read kosmikus' thesis
14:39:11 * Igloo wants to have time to read kosmikus' thesis  :-)
14:39:39 * Spark wants his car to go again
14:39:41 * Spark wants a job
14:39:49 * Spark wants a pc that works
14:39:51 <Marvin--> Igloo: yeah, that too
14:40:02 <Marvin--> Igloo: but I'll settle for browsing it, for now :)
14:41:08 <Marvin--> Spark: "pc that works" is rarely possible
14:41:17 <Spark> mm true
14:41:44 <Smerdyakov> Spark, why don't you have a job?
14:42:20 <Spark> ive only just graduated
14:42:29 <Spark> i had summer work all ready
14:42:38 <Spark> then they ditched me at the last minute because they couldnt find anything for me to do
14:42:42 <Spark> useless shites
14:42:55 <Spark> dont buy any radars from AMS
14:43:08 <Smerdyakov> Spark, have you looked for university research assistant positions?
14:43:16 <Spark> temporary?
14:43:22 <Spark> theres no universities near here :/
14:43:23 <Smerdyakov> Yes
14:43:29 <Smerdyakov> So move!
14:43:30 <SyntaxNinja> we need to set up a bugzilla or something
14:43:31 <Spark> i should never have come back to the isle of wight
14:43:34 <Spark> sounds like a good idea
14:43:40 <Spark> i going a masters at imperial college
14:43:41 <Igloo> For cabal?
14:43:43 <SyntaxNinja> Igloo: yeah
14:43:47 <Spark> if i could work there, that would be ace
14:43:57 <Spark> id already know half the staff before i started studying
14:44:15 <Smerdyakov> Spark, I bet you could. Just ask professors doing interesting things if they need some help. (Of course, it might be too late in the season for it to be worthwhile.)
14:44:45 <Spark> yeah
14:45:04 <Spark> if AMS hadnt led me on i could have easily gotten a job at warwick university
14:45:13 <Spark> my supervisor really loved what i did my 3rd year project on
14:45:40 <Spark> they only told me last week that they wouldnt be employing me
14:45:55 <Spark> and now im broke, *and* my car has broken down too
14:45:56 <Riastradh> What did you do your third year project on?
14:45:59 <Spark> and i cant repair it
14:46:09 <Spark> err "empirical modelling"
14:46:18 <Spark> in the field of human computing
14:46:25 <Spark> it was a sort of virtual machine
14:46:30 <Spark> i was playing with new ideas that he liked though
14:46:59 <Spark> the point was not that it was good, but that i could convince them it was good, which is why i got a 1st :)
14:47:03 * Gowilla points out to Smerdyakov that it's fairly rare for UK universities to employ students over the summer on research projects
14:47:15 <Smerdyakov> Gowilla, I guess the UK is lame.
14:47:22 <Spark> yeah the uk is pretty lame
14:47:32 <Spark> Smerdyakov: are you from scandanavia ish type place?
14:47:37 <Smerdyakov> Spark, USA
14:47:37 <Gowilla> this coming from someone who lives ina country ruled by a chimpanzee :-p
14:47:40 <Spark> oh
14:47:45 <Spark> it should be less lame than the usa :)
14:48:02 <Smerdyakov> Spark, hardly. CS research is ridiculously well-funded by the US government.
14:48:12 <Spark> mm
14:48:16 <Gowilla> oh, our CS research is more lame, certainly
14:48:28 <Spark> imperial college will give me 11 grand for my MSc
14:48:30 <Gowilla> but only cos of the ridiculous amounts of money the US has, relatively
14:48:31 <Smerdyakov> Spark, when I was an undergrad, I had 2 offers to be a summer research assistant after my sophomore year, without even asking anyone.
14:48:38 <Spark> heh
14:48:40 <Gowilla> IC, or EPSRC?
14:48:52 <Spark> ic or epsrc?
14:49:11 <Gowilla> giving you the money for your MSc
14:49:16 <Spark> imperial college
14:49:18 <Spark> its a bursary
14:49:21 <Spark> dunno where its from :)
14:49:29 <Spark> but i dont get any until november
14:49:30 <Smerdyakov> 11 grand is pounds?
14:49:35 <Spark> yeah
14:49:37 <Heffalump> 11 thousand pounds
14:49:46 <Spark> 3000 will go on fees for that year
14:49:54 <Heffalump> I'd be quite surprised if a university was funding an MSc directly themselves.
14:49:54 <Spark> and ill probably spend the rest of trying to live in london :)
14:50:15 <Spark> they probably get an amount to give to students
14:50:22 <Spark> then they decide who to give it to and how much
14:50:31 <Heffalump> it's probably from EPSRC originally
14:50:34 <Spark> yeah
14:50:55 <Smerdyakov> Spark, I'm getting about twice that from the US government, guaranteed for 5 years.
14:51:08 <Spark> fulltime job?
14:51:22 <Smerdyakov> No. I just have to be a student.
14:51:26 <Smerdyakov> I'm a PhD student in CS.
14:51:31 <Spark> ah
14:51:42 <Spark> i think 1.5* that is normal for phd
14:51:55 <Heffalump> 10K living grant is normal for PhDs in the UK.
14:51:59 <Spark> really?
14:52:10 <Spark> im sure people in warwick get more than that
14:52:12 <Heffalump> smerdy: it's only cos the US has lots of money that comes from stealing oil from everyone :-)
14:52:19 <Spark> maybe because they also teach or something
14:52:29 <Heffalump> spark: people with CASE awards might get 13K
14:52:31 <Smerdyakov> Heffalump, good thing it goes to me instead of to building weapons to steal more oil!
14:52:33 <Spark> nah the reason the US has lots of money is slavery :)
14:53:04 <Heffalump> oh yes, and hastening the end of the world
14:54:22 <Heffalump> spark: anyway, isn't Southampton uni nearby?
14:54:28 <Spark> ah yes i could commute
14:54:35 <Spark> 20 quid a day on ferry fares though :)
14:54:43 <Heffalump> ouch
14:54:45 <Spark> plus costs of getting to the ferry terminal without a car
14:54:46 <Heffalump> swim? :-)
14:54:49 <Spark> mm
14:54:51 <Spark> i'd get fit :)
14:54:53 * SyntaxNinja goes home &
14:55:05 <Spark> you're forking that task into the background? :)
14:55:11 <Spark> mm
15:31:42 <stepcut> hxml vs haxml ?
15:31:49 <Riastradh> SXML!
15:32:46 <monotonom> SDML = super duper meta language
15:38:26 <Smerdyakov> SDML = some days monotonom lies
16:35:42 <SyntaxLaptop> now marvin-- is gone?
16:39:46 <Igloo> Looks like it
16:54:38 * SyntaxLaptop envisions a release of Cabal before ICFP..
16:58:33 <Igloo> Cool  :-)
19:02:28 <stepcut> is there a function to create a temporary directory 
19:02:45 <stepcut> System.Posix.Temp.mkstemp is only for files
19:03:07 <kosmikus> twelve hours later than I expected, but I've done it :) my thesis is submitted to the printer, I cannot change it anymore ...
19:03:21 <Igloo> Congrats  :-)
19:03:31 <kosmikus> thanks
19:03:36 <Smerdyakov> kosmikus, do you have a job lined up?
19:03:40 <stepcut> kosmikus: did you fix that mistake on page 12?
19:04:09 <kosmikus> stepcut: yes, I did, but I see now that I introduced three on pages 13, 97, and 260
19:04:24 <kosmikus> Smerdyakov: nothing definitive yet -- why, got one to offer?
19:04:44 <Smerdyakov> kosmikus, well, we have an opening for a programming languages assistant prof. here at Berkeley.
19:04:58 <Smerdyakov> kosmikus, but I just asked because I was curious. :)
19:05:14 <kosmikus> doesn't sound too bad, actually ;)
19:05:37 <Smerdyakov> I have a feeling you wouldn't get hired in the CS dept. here, though. Maybe the math dept.. :)
19:06:11 <kosmikus> why not? because of me, or because of the CS department?
19:06:29 <Smerdyakov> Both. The CS dept. here only hires systems-y PL professors.
19:06:54 <Smerdyakov> Almost all of what would be considered PL stuff in Europe is not even on their radar.
19:07:17 <kosmikus> hmm
19:08:06 <Smerdyakov> You do pretty theoretical stuff, right?
19:08:29 <kosmikus> well, it always depends from which side you look at it
19:08:49 <kosmikus> it's not extremely theoretical
19:09:09 <Smerdyakov> Is there any chance it would be published at a systems conference?
19:09:53 <kosmikus> no, don't think so
19:10:04 <Smerdyakov> OK. All the PL faculty here have several papers at systems conferences.
19:10:25 <Smerdyakov> My advisor probably has the lowest number of those, 2. ;)
19:12:57 <Smerdyakov> In the USA, it is usual to begin a job search about a year before finishing a PhD, and people usually have jobs by the time they graduate, sometimes even before they graduate. :)
19:16:04 <kosmikus> well, I still have six weeks before I graduate and then another month before my contract ends
19:16:47 <Smerdyakov> There are well-defined hiring seasons in the USA.
19:17:38 <kosmikus> for the interested: my thesis is now online, but not linked, www.cs.uu.nl/~andres/ExploringGH-submit.pdf
19:18:22 <bourbaki> hi
19:18:51 <kosmikus> Marvin--, shapr: ^^^
19:34:09 <kosmikus> I'll be away for the most time until Tuesday -- have fun ...
20:28:50 <blackdog> Igloo: there?
21:39:28 <sazzle> anyone built ghc6.2.1 on freebsd?
21:39:37 <sazzle> (freebsd 5.1, in particular)
21:50:14 <eno> on fbsd 5.2.1 no problem, but i remember having some problem on 5.1
21:54:31 <sazzle> eno: yeah, i haven't had a problem on 5.2.1
21:55:00 <sazzle> eno: i've got 5.04.3 installed on 5.1, i'd like to update to 6.2.1, but it's giving me pain
21:56:11 <sazzle> eno: did you manage to get it to work on 5.1 eventually?
22:26:42 * SamB wishes for pattern matching in Python...
22:27:36 <heatsink> SamB: import re
22:27:38 <heatsink> :)
22:27:51 <SamB> umm...
22:28:18 <SamB> that will not help me implement a purely functional data structure!
22:28:47 <SamB> although of course my Thunks mutate themselves ;-)
22:28:53 <heatsink> Why do you want to implement a purely functional data structure in python?
22:29:25 <Riastradh> Why do you want to use Python?
22:30:35 <SamB> why not?
22:31:15 <SamB> imperative datastructures have O(n) copy!
