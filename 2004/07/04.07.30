02:18:17 <TheHunter> hi
02:27:01 <Lemmih> yo
03:12:58 <bringert> morning andersca
03:13:10 <andersca> morn
07:13:31 <SyntaxNinja> I was thinking of writing a little substituter; it parses a file, and looks for strings like ${FOO} or something; it has mapping, [(FOO, bar), (BANG, baz)] to do substitutions
07:13:43 <SyntaxNinja> has anyone written this?
07:14:10 <Igloo> Yes, but I'm not sure if it's overly generic. Let me look.
07:14:54 <RussellOConnor> Questiong of the Day:  Can Bird's one pass tree-min function be written without using general recursion?
07:15:09 <RussellOConnor> grrr
07:15:13 <RussellOConnor> stupid keyboard.
07:15:20 <ski> RussellOConnor : fold, iirrc
07:15:40 <RussellOConnor> Question of the Day: Can Bird's one pass tree-min function be written without using general recursion?
07:17:59 <ski> RussellOConnor : ok ?
07:18:19 <RussellOConnor> ski: ???
07:19:01 <ski> <ski> RussellOConnor : fold, iirrc
07:19:35 <Igloo> SyntaxNinja: Ah, my implementation has the lexer split it up into text and variable references
07:19:40 <Marvin--> SyntaxNinja: I wrote something like that a while ago, let's see if I can find it
07:19:55 <RussellOConnor> I'm okay with the tree traversal, the problem is the recursive let in the initial replaceMin call that ties the knot.
07:20:11 <Igloo> So it's probably less effort to rewrite it than to pull it out and put it back together  :-)
07:20:28 <SyntaxNinja> hehe
07:20:34 <ski> RussellOConnor : oh
07:20:34 <SyntaxNinja> effort isn't the point ;)
07:20:37 <Marvin--> though iirc my function was in IO and did getEnv
07:20:54 <Igloo> SyntaxNinja, Marvin--, do either of you use ifscheme of waproamd?
07:20:54 <ski> RussellOConnor : lemme think a little on it ..
07:20:56 <SyntaxNinja> that's OK, I can fix that
07:21:01 <SyntaxNinja> Igloo: no
07:21:26 <SyntaxNinja> er I'm about to disappear to a meeting (have you noticed that I've been in a lot of meetings lately?) so email me if I disappear too fast...
07:21:28 <Marvin--> Igloo: no
07:21:31 <Igloo> "effort isn't the point"?
07:21:47 <Marvin--> SyntaxNinja: yeah, I'm wondering how you can get anything done at all
07:22:31 <SyntaxNinja> Igloo: well, there's just something about not writing something from scratch. even if it's more effort to gaze at someone else's implementation and think about how to fix that, at least you learn from their mistakes and good choices.
07:22:31 <Marvin--> hmm, wonder if I had that file on the laptop
07:23:08 <Igloo> Marvin--: Haven't you worked it out yet? He doesn't, he just offers to buy you drinks...  :-)
07:23:38 <TheHunter> RussellOConnor: that's easy, you only need two "fixed point iterations"
07:24:10 <TheHunter> however, you can only express this with gr for types that have a "default value"
07:24:17 <RussellOConnor> TheHunter:  I don't think I understand.
07:25:03 <TheHunter> RussellOConnor: look at http://www.haskell.org/hawiki/FixedPointCombinator
07:25:15 <Marvin--> Igloo: actually, I meant at work, not cabal...
07:25:24 <TheHunter> and replace the definition of replaceMin' by replaceMin' = fst . fix' . rpMin'
07:25:34 <TheHunter> where fix' f = f . f $ undefined
07:26:00 <RussellOConnor> TheHunter: The problem is to solve this problem without using any general recursion, and fix' uses general recursion in it's definition.
07:26:19 <Marvin--> expandVariables :: String -> IO String
07:26:21 <Marvin--> there it is
07:26:29 <RussellOConnor> I want Y outlawed.
07:26:29 <SyntaxNinja> Igloo: hey! I do lots of work!
07:26:38 <RussellOConnor> :)
07:26:38 <TheHunter> RussellOConnor: the undefined is no problem since we can provide a default value
07:26:57 <RussellOConnor> oh wait
07:27:03 <TheHunter> apart from that fix' is (second-order?) primitively recursive 
07:27:03 <RussellOConnor> now I see what you are getting at.
07:27:36 <SyntaxNinja> Igloo: didn't you see my beautiful packages?
07:28:02 * SyntaxNinja suspects that wearing headphones is getting me out of doing some manual labor that's going on on the other side of the room
07:28:21 <Igloo> SyntaxNinja: Yeah, only teasing. You're wonderful, we love you  :-)
07:29:07 <SyntaxNinja> :) :)
07:29:48 <Igloo> TheHunter: Surely you can't walk over an unknown tree without mor than primitive recursion?
07:31:09 <TheHunter> Igloo: i think primitive recursion over the datatype definition of the Tree is allowed
07:31:14 <RussellOConnor> Igloo: primitive recursion is adequate for walking trees.
07:32:03 <Igloo> Oh, fair enough, I'm misremembering the definition then
07:32:22 <RussellOConnor> Although I am willing to allow any recursion that cannot lead to looping.
07:32:34 <RussellOConnor> err
07:32:42 <RussellOConnor> I should clarify that.
07:32:50 <Igloo> I don't really understand the exact problem you're trying to solve, though
07:32:52 <TheHunter> RussellOConnor: i think that's pretty much higher-order primitive recursion
07:33:14 <thebug> dons: what type of documentation are you missing? N64 ABI and/or MIPS64 asm?
07:33:15 * SyntaxNinja meeting &
07:35:57 <RussellOConnor> Igloo: Well, the given solution to the problem uses recursive let bindings.  Recursive let binding are a source of infinite loops (often bugs) in programs.  If you disallow recursive let bindings, your program cannot loop forever.  So I want to know if this one pass solution can be writen in a language that disallows recursive let bindings, Y combinators, aka general recursion.
07:36:29 <RussellOConnor> So you are allowed higher-order structural recrusion.
07:37:11 <TheHunter> RussellOConnor: do you know "Elementary strong functional programming" (lncs 1022)?
07:37:27 <ski>  /msg #haskell.se hej och hå
07:38:03 <RussellOConnor> TheHunter: I haven't read it.
07:38:30 <RussellOConnor> But I probably agree with it's thesis.
07:38:52 <TheHunter> it's about the whole only allowing primitive recursion thing in a haskell-like language
07:39:28 <RussellOConnor> primitive recursion is too tight.
07:41:16 <Igloo> You can write recursive programs you can prove terminate given finite datastructures, though. They're primitive recusive aren't they?
07:41:17 <TheHunter> according to this article, it isn't. Turner says there's an article by Gödel proving that higher-order-primitive recursion gives you all algorithms that you can prove to terminate in second-order arithmetics, iirc
07:45:26 <TheHunter> so, for example the ackermann-function is primitively recursive
07:48:55 <ski> HO-prim-rec ?
07:49:08 <RussellOConnor> ack 0 = succ
07:49:10 <RussellOConnor> ack (n+1) = iter (ack n)
07:49:12 <RussellOConnor>   where iter f 0 = 1
07:49:13 <RussellOConnor>              iter f (n+1) = f (iter f n)
07:49:20 <RussellOConnor> ackermann is not primative recursive.
07:49:51 <RussellOConnor> But it is ``higher-order primitive recursive''
07:49:54 <ski> one can write ackermann in charity
07:52:16 <ski> RussellOConnor : was higher-order primitive recursive with dep. types ?
07:52:51 <ski> (for a combinator, i.e.)
07:55:22 <RussellOConnor> ski: Higher-order primitive recursion should be independant of depend types, although I've only read about them at the same time.
07:55:43 <RussellOConnor> ski: But the above definition of ackermann has no dependant types.
07:56:11 <RussellOConnor> the fact that the result of ack n is a fuction makes the definition higher-order primitive recursive.
07:56:51 <RussellOConnor> primitive recursive function can only have ground types for their results.
07:57:10 <ski> i meant if we want a fold combinator for naturals, that supports HOprimrec
07:58:28 <RussellOConnor> a reasonable fold combinator for the natural would support HOprimrec.  foldNat :: Nat -> (a -> a) -> a -> a.
07:58:45 <RussellOConnor> if a can be a function, then foldNat supports HOprimrec.
07:59:50 <RussellOConnor> Hmmm. foldNat :: Nat -> (a -> Nat -> a) -> a -> a.
08:00:46 <Amadan> hi ppl
08:01:00 <Amadan> i got a ghci question
08:01:06 <RussellOConnor> In any case ack n = foldNat n (\rec _ -> iter rec) succ
08:01:42 <ski> RussellOConnor : i think i remember somthing like  foldNat :: (p :: Nat -> *) -> p Zero -> (forall n :: Nat. p n -> p (Succ n)) -> (n :: Nat) -> p n
08:02:19 <RussellOConnor> iter f n = foldNat n (\rec _ -> f rec) 0
08:03:02 <RussellOConnor> ski: that would be the more general, dependent-type formulation for foldNat.
08:04:04 <RussellOConnor> ski: if you replace p::Nat -> * with just p::*, you get the non-dependant typed version, which is basically the same as what I gave.
08:04:20 <ski> mm, yes
08:04:42 <RussellOConnor> foldNat :: (p::*) -> p -> (Nat -> p -> p) -> n -> p
08:04:52 <RussellOConnor> foldNat :: p -> (Nat -> p -> p) -> n -> p
08:05:03 <RussellOConnor> Hmm, that's a much nicer order of parameters.
08:05:31 <RussellOConnor> Err, that n should be a Nat.
08:05:45 <RussellOConnor> foldNat :: p -> (Nat -> p -> p) -> Nat -> p.
08:06:05 <Amadan> @eval getStdGen >>= \g -> putStr (show (next g))
08:06:05 <lambdabot> (line 1, column 12):
08:06:05 <lambdabot> unexpected ">"
08:06:05 <lambdabot> expecting simple term
08:06:13 <ski> mm, was just gonna say that
08:06:58 <ski> RussellOConnor : hmm, never thought of that way of seeing the source of the Nat argument of the 'succ' function argument
08:08:04 <Amadan> um. okay. anyway, if I type "getStdGen >>= \g -> putStr (show (next g))" in ghci, it works; but it always shows the same result. why is that? ease of debugging, or I'm missing something?
08:08:37 <Marvin--> Amadan: getStdGen doesn't change the state
08:08:40 <RussellOConnor> ski: yep, that's where it is from.
08:09:03 <Marvin--> Amadan: you probably want newStdGen
08:09:04 <RussellOConnor> It makes writing (- 1) much easier.
08:09:05 <ski> RussellOConnor : (re order) not sure what is nicest. perhaps depends on context
08:09:09 <Amadan> yeah; but shouldn't `next` change it?
08:09:33 <ski> RussellOConnor : (that one prolly fit better with cat.theory, though)
08:09:45 <Marvin--> Amadan: no, next returns a new generator, but it doesn't update any states
08:09:51 <Marvin--> Amadan: next is a pure function
08:09:57 <Marvin--> it cannot change states
08:10:01 * Amadan smacks himself
08:10:02 <Amadan> of cours
08:10:07 <Amadan> s/cours/course
08:10:21 <RussellOConnor> My order was just some random order that came into my head.
08:10:42 <Marvin--> so either use setStdGen, or use newStdGen (which basically does getStdGen, split and setStdGen I think)
08:11:21 <Amadan> so within a single program execution (as well as within a single ghci session), the StdGen is constant IO StdGen, right?
08:12:09 <Amadan> i mean, getStdGen value
08:12:20 <Marvin--> well the getStdGen is a constant value, but every time you *run* it, its side effect takes place
08:12:43 <Marvin--> there's a big difference between IO StdGen and StdGen
08:13:39 <Marvin--> Amadan: simplest might be to use randomIO and randomRIO and not worry about the StdGen:s at all :)
08:14:15 <ski> RussellOConnor> : the order with the nat to recurse on being the first arg is the usual for prim.rec. i think
08:15:29 <Amadan> :) but it does not fit as nicely, because then i would have to contaminate my pure functions with IO
08:15:49 <Marvin--> well, it's either that or pass around the StdGen:s
08:16:01 <Marvin--> PRNGs are inherently stateful, you know
08:16:06 <Amadan> yeah, i will do that
08:16:17 <Amadan> yeah
08:16:28 <Marvin--> one neat thing to do is to wrap the mess in a monad
08:16:33 <Marvin--> like the Gen monad in Debug.QuickCheck
08:16:39 <Amadan> ?
08:17:50 <Marvin--> QuickCheck's Gen monad basically provides functions like  choose :: Random a => (a,a) -> Gen a, elements :: [a] -> Gen a etc.
08:18:10 <Marvin--> and a function  generate :: Int -> StdGen -> Gen a -> a  that you call at top level
08:19:09 <Amadan> oh... no, i don't think i'll need that... and besides, the only monad i've managed to wrap my head around properly is Maybe... :)
08:19:27 <RussellOConnor> ski: Anyhow, prim. rec. requires that the polymorphic variable be a Nat.
08:19:38 <RussellOConnor> primRec :: Nat -> (Nat -> Nat -> Nat) -> Nat -> Nat
08:20:01 <ski> right
08:20:09 <Amadan> Lists and Eithers and IO, I can use, but don't get completely. States - I understand the basic concept and motivation, but I can't even follow through a simple example. :(
08:20:49 <Marvin--> Amadan: there's not much head-wrapping to do. All the Gen monad does is manage StdGen:s for you
08:21:03 <Amadan> anyway, I'm trying to make a shuffling function, so I'll just pass it a list and a StdGen... no need for monads, I think.
08:21:05 <RussellOConnor> ski: When talking loosely most people accept anything equivalent to a nat, any ground type.
08:22:12 <ski> constructivistically ?
08:22:58 <Amadan> anyway, thanks for the ghci hint, it was really bugging me!
08:23:30 <RussellOConnor> ski: yes, I believe.
08:41:30 <bourbaki> hi
08:42:24 <ski> hi bourbaki
08:42:26 <Amadan> second try - again screwed up somewhere. can someone look at the top of the paste page, please?
08:43:06 <ski> in main ?
08:44:14 <Amadan> what does the error mean?
08:45:27 <ski> it means that 'randoms' is creating a list of 'a's
08:45:36 <Marvin--> Amadan: that it doesn't know what the type of the list elements is
08:45:39 <ski> and show10 is showing it
08:45:53 <ski> yes
08:45:56 <Marvin--> all it knows is that it's in Show and Random
08:46:15 <Marvin--> you'll have to force the type
08:46:24 <Amadan> How do I make randoms return Integers?
08:46:44 <ski> e.g.  let rndStream = randoms g :: [Integer]
08:46:45 <Amadan> I tried (randoms:StdGen->[Integers]), but it didn't parse
08:47:15 <ski> two colons ("::")
08:47:24 <Amadan> yeah sorry typo
08:47:43 <Amadan> anyway, i'm still getting an error:
08:47:49 <Amadan> Ambiguous constraint `Show a'
08:47:55 <Amadan> At least one of the forall'd type variables mentioned by the constraint
08:47:55 <Amadan>         must be reachable from the type after the '=>'
08:48:06 <Amadan> In the type: forall a. (Show a) => [Integer] -> String
08:48:14 <Amadan> While checking the type signature for `show10'
08:48:24 <Marvin--> Amadan: heh, get rid of the context :)
08:48:38 <Marvin--> you don't have any a:s to the right of the =>, so you shouldn't have any to the left of it either
08:48:55 <Amadan> ah! so i don't...
08:49:04 <Amadan> yay! thanks...
08:50:16 <ski> hmm, how come it infers a monomorphic show10 ?
08:50:31 <RussellOConnor> monomorphism restriction?
08:50:39 <Amadan> 'cause I told him to, after I pasted on the wiki :)
08:50:55 * Amadan blushes
08:51:10 <ski> RussellOConnor : should only kick in if the signature is left out
08:52:07 <Amadan> i figured, if I make show10 accept only a certain type of argument, randoms might get a hint... but it didn't work as planned. :/
08:53:13 * ski thinks that ought to work
08:54:31 <Amadan> oh... it does, i just checked. seems the parser was bothered by the Show a context, and I didn't notice the switch in the error msg
08:55:02 <Marvin--> it's not the parser, it's the type system that objects
08:55:04 <ski> s/parser/type checker/
08:56:13 <Amadan> thanks people... i've just seen somebody say how newbie-friendly this community is, and it's true
08:56:35 <thebug> it -is-
08:56:49 <thebug> :)
09:11:45 * shapr tries to think of a good way to build a web-test
09:12:50 <thebug> you mean like an online quiz style thing?
09:16:52 <shapr> yup
09:17:09 <thebug> have you looked at the software packages 'CAPA' and 'LON-CAPA' ?
09:17:13 <thebug> they do just that
09:17:24 <thebug> they might have some good ideas
09:22:34 <shapr> http://217.211.205.143/cgi-bin/ProtoTeach
09:22:56 <shapr> doesn't do much yet..
09:23:40 <shapr> I like lon-capa's german pronoun exercise, I'll see if I can get GF to do that once it works with basic morphology
09:25:43 <thebug> I'm not a big fan of lon-capa <as a user>, but it works
09:26:46 <thebug> I can see how it'd be really handy as an instructor to have all of the automated grading and reporting that it does though
09:27:25 <thebug> wow, I don't understand a thing this page is telling me :)
09:33:33 <thebug> uh oh shapr, I think I broke it
09:34:35 <thebug> it tried to give my 5 words, but 2 of them only have the word, a colon, then nothing, whereas the other 3 have the tense, and <I presume> the morphed word
09:34:55 <shapr> nah, that's a GF bug that's fixed in CVS
09:35:01 <dfd> hey
09:35:07 <shapr> but I'm still using my hacked version, rather than the GF CVS
09:35:12 <shapr> greetings dfd 
09:35:45 <thebug> I found lots of docs I think dons might be interested in, but I'm guessing he's passed out :)
09:40:09 <dfd> Are there docs comparing haskell to other functional languages?
09:40:42 <ski> think there's a doc comparing to mercury on it's site
09:41:22 <dfd> thanks
09:44:26 <shapr> dfd: this might be interesting: http://www.haskell.org/complex/why_does_haskell_matter.html
09:45:11 <dfd> yes, i'm reading it, thanks :-)
09:55:25 <Marvin--> ah, neat, cabal runs with hugs too
09:55:34 <Marvin--> for some definition of "runs", I suppose
09:55:42 <Marvin--> runhugs -98 -P:../projects/library-infrastructure "-Fcpphs\ --noline\ -D__HUGS__" Setup.lhs --help
09:57:07 * stepcut puts on his robe and wizard hat
09:58:56 * shapr puts on his chainmail
10:00:28 * stepcut ponders writing a photo gallery with the photos linked to each other as a directed cyclic graph
10:00:41 <bourbaki> heh
10:00:44 * bourbaki rolls dice
10:00:51 <bourbaki> its a pleasure to meet you ;)
10:07:33 * Marvin-- sneak attacks bourbaki
10:09:12 * Marvin-- moves on to torturing his parser
10:37:49 <shapr> aFlag: so, what kind of flag today?
10:38:10 <aFlag> i guess white and black again since my team won :D
10:38:18 <aFlag> 4 to 0 :D
10:39:59 <shapr> spiffy
10:40:05 * shapr swears at WMV
10:40:25 <bourbaki> what team?
10:40:31 <shapr> I downloaded some unicycle film, and I can't play them... :-(
10:40:56 <thebug> shapr: mplayer won't play them?
10:40:59 <Igloo> Have you tried mplayer, xine, vlc?
10:42:12 <shapr> vlc and xine
10:42:16 <shapr> I'll try mplayer
10:42:58 <SamB> hmm, pair comes out huge translated to SKI.
10:43:44 <SamB> well, probably less huge without all these As
10:43:44 <thebug> shapr: if you're using marillat's repo, make sure to install the win32codecs or whatever it's called
10:45:55 <ski> SamB : As ?
10:46:29 <SamB> well, I have a datatype Term:
10:46:34 <SamB> data Term = L Var Term
10:46:35 <SamB> 	  | S | K | I
10:46:35 <SamB> 	  | A Term Term
10:46:35 <SamB> 	  | V Var deriving (Show, Eq)
10:46:44 <ski> oh, applications
10:46:52 <SamB> yes
10:48:58 <RussellOConnor> SamB: Can you do show (A x y) = "("++(show x)++(show y)++")" 
10:49:08 <RussellOConnor> SamB: is this pair from yesterday?
10:51:11 <SamB> yes
10:54:28 <RussellOConnor> SamB: How long is the expression?
10:54:54 <SamB> RussellOConnor: I'm not entirely sure I've got this code quite right anyway
10:55:04 <RussellOConnor> oh, okay.
11:08:48 <SamB> somehow a lambda is falling through the cracks on fst and snd...
11:09:15 <SamB> I have a driving lesson in about five minutes, though.
11:09:34 <ski> SamB : after ski conversion ?
11:09:40 <SamB> I'm looking at http://en.wikipedia.org/wiki/Combinator
11:10:59 <SamB> have a BSD/MIT X11 license with that, RussellOConnor
11:11:17 * ski made a lambda->ski converter with folds
11:11:23 <SamB> or maybe a nonexclusive copyright assignment
11:12:00 <SamB> oh, right, IPv6...
11:12:21 <SamB> oh, nevermind, I'm connected with v4
11:12:52 <SamB> ski: you can have a license too ;-
11:13:21 <ski> heh
11:13:44 <thebug> the Exclusive SamB License Plus or ESL+
11:14:00 <SamB> no, I said nonexclusive!
11:14:08 <thebug> hehe
11:14:16 <SamB> that means I can still give it away, but he can too
11:15:12 <ski> should showTerm (L x e) only give an opening paren and not a closing one ?
11:16:32 <SamB> ski: good point
11:17:02 <SamB> however, if the SKI conversion (t) was working, it wouldn't matter that much
11:17:23 <ski> i think the parens around the show part in P.error ("t: unhandled case " P.++ (P.show e)) is unnecessary
11:17:39 * ski 's reading the other parts before t
11:18:07 <SamB> does freeIn seem okay?
11:18:34 <ski> yes
11:18:40 <SamB> good
11:19:29 <SamB> the driving instructor is finally here.
11:19:31 <SamB> bye!
11:19:35 <Riastradh> SamB, do you get that pair = S (S (K S) (S (K K) (S (K S) (S (K (S I)) K)))) (K K)?
11:19:40 <ski> i see more problems
11:19:53 <ski> t (L x e)         | not (x `freeIn` e)      = A K e   is worng
11:19:59 <ski> SamB : bye
11:23:27 * RussellOConnor wonders if all parathesis can be dropped under the assumption the combinator is in normal form.
11:23:40 <RussellOConnor> probably not.
11:23:55 <ski> correct
11:24:15 <RussellOConnor> Right, so places K is applied to 0 parameters.
11:24:21 <RussellOConnor> s/so/some
11:24:42 <Riastradh> ski, do you get that SKI expression for pair?
11:25:50 <SyntaxNinja> Igloo: Marvin--, did either of you manage to dig up that substitution code we talked about?
11:25:52 <ski> Riastradh : with his code, you mean ?
11:26:00 <Riastradh> With something that's correct.
11:26:20 <ski> i dunno
11:26:30 <ski> i could check, i suppose
11:26:48 <ski> \a.\b.\k.k a b  right ?
11:26:53 <Riastradh> Yes.
11:27:23 <Riastradh> Why is that guard above wrong, by the way?
11:27:46 <Riastradh> -- the [[t (L x e) | not (freeIn x e) = A K e]] bit.
11:27:47 <ski> it doesn't recurse into e
11:27:53 <Marvin--> SyntaxNinja: http://sjogren.ost.sgsnet.se:8080/static/Stuff.hs
11:27:53 <Riastradh> Oh.
11:29:49 * Riastradh is leaving soon, too, by the way, to see Alice Cooper.
11:30:11 <thebug> wooo good stuff
11:33:42 <stepcut> insane!
11:33:58 <Riastradh> Insane?
11:34:04 <SyntaxNinja> Marvin--: thanks.
11:34:17 <stepcut> Riastradh: in a good way (going to see Alice Cooper)
11:34:51 <Riastradh> Oh, indeed.
11:36:37 <ski> Riastradh : if i haven't erred it's  S (S (K S) (S (K K) (S (K S) (S (K (S I)) (S (K K) I))))) (K (S (K K) I))
11:36:52 <ski> Riastradh : would prolly be a bit shorter with C,B
11:37:27 <Riastradh> Hmmm.
11:37:29 <ski> 5CRiastradh : (haven't looked for optimisations other than K:ing subexprs with no occurance )
11:38:07 <Riastradh> You can optimize (S (K K) I), too, to just K.
11:38:23 <ski> right
11:38:34 <Riastradh> Which reduces it to what I got.
11:38:40 <norpan> combinator porn
11:38:42 <Riastradh> @definition B
11:38:43 <lambdabot> Sorry, I don't know the command "definition", try "lambdabot: @listcommands
11:38:47 <Riastradh> @get-definition B
11:38:47 <lambdabot> B = \\f g x. f (g x)
11:38:57 <Riastradh> @get-definition C
11:38:57 <lambdabot> C = \\f x y.f y x
11:39:05 <ski> Riastradh : yes
11:39:15 * Riastradh reduces it further with B & C.
11:40:49 <Riastradh> C (B S (B K (B S) (B (S I) K))) K
11:41:35 <Riastradh> And car is S I K; cdr is C I K.
11:41:44 <ski> i got C (B B (B C (B (C I) I))) I
11:41:53 <Riastradh> Ook.
11:44:28 <Marvin--> SyntaxNinja: I've been fiddling with remembering line numbers in the stanza parser, so the parse error messages should be a bit more interesting now
11:44:48 <Spark> heh is that lambda calculus
11:45:04 <ski> and ski calculus
11:45:10 <Spark> what is a combinator?
11:45:25 <ski> an expression with no free variables
11:45:31 <Spark> ahh
11:45:34 <Spark> simple as that
11:45:51 <ski> as in e.g. "combinator library"
11:46:02 <ski> and "parsing combinators", etc ..
11:46:35 <Spark> so a combinator is a value?
11:46:41 <Spark> in terms of the syntax
11:46:56 <Spark> erm
11:46:56 <ski> guess that depends on how you define "value"
11:47:01 <Spark> semantics even
11:47:05 <Spark> it'll be an abstraction wont it?
11:47:12 <ski> not necesarrily
11:47:12 <SyntaxNinja> Marvin--: sweet
11:47:22 <Smerdyakov> ski is an ethical relativist.
11:47:24 <Spark> ah do you include numbers and stuff as primitive
11:47:38 <ski> C (B B (B C (B (C I) I))) I   is a combinator
11:47:50 <ski> Smerdyakov : heh
11:48:02 <ski> Smerdyakov : didn't know that, ty ;)
11:48:40 <ski> Spark : that could be done, if wanted
11:49:49 <Spark> what are B C and I?
11:49:59 <ski> I = \x.x
11:50:05 <ski> the identity function
11:50:42 <ski> C f g = S f (K g)
11:50:46 <Smerdyakov> Spark, in untyped lambda calculus, or lambda calculus with an expressive enough type system, you don't need anything but functions to define all primitives.
11:50:50 <ski> B f g = S (K f) g
11:51:36 <Philippa_> I had fun showing the standard means of doing booleans and pairs to my boyfriend the other day
11:51:53 <Philippa_> the \calc means of doing pairs pretty much says it all about data hiding
11:52:02 <ski> :)
11:52:27 <Philippa_> "what do you mean it's an OO invention - it predates the hardware computer!"
11:52:41 <Spark> Smerdyakov: yeah, so all combinators are abstractions in that case?
11:52:58 <Spark> or abstractions applied to abstractions
11:52:59 <Spark> heh i dunno
11:53:03 <Smerdyakov> Spark, not necessarily.
11:53:12 <Smerdyakov> Spark, you can define combinators with arbitrary terms.
11:53:33 <Spark> mm
11:53:41 <ski> Spark : abstraction is a syntax thing
11:53:52 <Smerdyakov> Spark, of course, if you're working with a strongly normalizing system, you can always find an equivalent normal form abstraction.
11:54:01 <Smerdyakov> Spark, or just use an eta-expansion. :)
11:54:02 <SyntaxNinja> man... today's meeting went from 10:30 - 2:30... I escaped at 1:00, though
11:54:50 <stepcut> SyntaxNinja: the cabal debian package seems to be working out so far, I can install and uninstall :) Now I am working on cabalizing and then debianizing a library with it
11:55:10 <SyntaxNinja> sweet. want to tell me what library, ooi?
11:55:38 <SyntaxNinja> stepcut: I'm working on a script to input a cabal-ized tarball and outputting a debian package. want to help me w/ it?
11:55:52 <stepcut> SyntaxNinja: sure
11:55:55 <SyntaxNinja> because I"m doing WASH next, and I don't feel like maintaining all 5 packages.
11:56:09 <SyntaxNinja> stepcut: the cabal/debian/rules file should give a pretty good idea about what a rules file should look like.
11:56:26 <stepcut> SyntaxNinja: will cabal packages ever include descriptions?
11:56:37 <SyntaxNinja> except that the #bootstrap step should be "ghc -package Cabal Setup.lhs"
11:56:49 <SyntaxNinja> ghc -package Cabal Setup.lhs -o setup
11:56:51 <stepcut> SyntaxNinja: unless your script is in perl, in which case I will decline to help
11:56:58 <SyntaxNinja> stepcut: no, I was going to do it in Haskell :)
11:57:25 <SyntaxNinja> I just now started on it, though, so there's not much to hack on... do you know much about debhelper? I seem to remember there being a way to add templates to debhelper or something
11:57:57 <stepcut> dunno
11:58:40 <stepcut> do you have a good library for calling tar, etc ?
11:58:48 <SyntaxNinja> no, could really use one. does darcs have one?
11:58:55 <SyntaxNinja> that's on th TODO list
11:59:01 <stepcut> dunno, I have only used darcs to download cabal
11:59:12 <stepcut> but I have started a "shell" library 
11:59:14 <SyntaxNinja> darcs has some kind of "make tarball" command
12:00:03 * stepcut gets the darcs source
12:01:09 <SyntaxNinja> so basically, all I want to do is generate a debian/ directory with a standard RULES file, a lot like the one in cabal, but with substitutions like ${CABALPACKAGENAME} in a variety of places in both rules and control
12:01:35 <stepcut> sounds reasonable
12:01:38 <SyntaxNinja> then run a little substitution script over the debian directory replacing CABALPACKAGENAME and maybe doing the dependencies, but I'm not too worried about that yet.
12:02:18 <SyntaxNinja> but hmmm. the substitution syntax will probably get in the way in the rules file and stuff.
12:03:06 <stepcut> it looks like darcs has an exec function with just calls a program and writes stdout and stderr to whatever files specify
12:03:14 <SyntaxNinja> so maybe we should just generate the files with the substitution already done.
12:03:36 <SyntaxNinja> perl has a nicer way of doing that :(
12:03:54 * stepcut ponders for a moment
12:04:20 <SyntaxNinja> stepcut: I wonder what it does on windows?
12:05:45 <stepcut> dunno, how does windows handle stdout/stderr ?
12:05:59 <thebug> huh apparently I already know some [nearly-]functional programming -- SQL ;)
12:06:10 <thebug> cool
12:06:41 <RussellOConnor> @get-definition I
12:06:41 <lambdabot> I = \\x.x
12:06:43 <stepcut> oh wait, the darcs exec file uses the first file for stdin, and the second file for stdout/stderr
12:06:50 <RussellOConnor> @get-definition K
12:06:50 <lambdabot> K = \\x y.x
12:06:51 <ski> thebug : (sortof) declarative
12:06:53 <RussellOConnor> @get-definition S
12:06:53 <lambdabot> S = \\f g x.f x (g x)
12:06:56 <RussellOConnor> @get-definition Y
12:06:56 <lambdabot> Y = \\f.U(\\g.f(U g))
12:07:07 <RussellOConnor> @get-definition U
12:07:07 <lambdabot> U = \\f. f f
12:07:21 <RussellOConnor> :type \f. f f
12:07:22 <thebug> ski: care to elaborate? I'm interested
12:07:24 <RussellOConnor> @type \f. f f
12:07:26 <lambdabot> bzzt
12:07:27 <SyntaxNinja> huh; system.environment doesn't have f :: IO [(String, String)]
12:07:31 <RussellOConnor> @type \f -> f f
12:07:32 <lambdabot> bzzt
12:07:38 <RussellOConnor> @type (\f -> f f)
12:07:39 <lambdabot> bzzt
12:07:44 <RussellOConnor> okay then.
12:08:37 <SyntaxNinja> stepcut: about descriptions... idono
12:08:41 <SyntaxNinja> I think it used to...
12:08:42 <ski> @type \f -> f f
12:08:44 <lambdabot> bzzt
12:08:48 <ski> :)
12:09:19 <stepcut> SyntaxNinja: seems useful -- for example, you could then generate a website with all the library descriptions
12:09:27 <ski> (\f -> f f) :: forall a.x  where x = x -> a
12:09:32 <SyntaxNinja> stepcut: yeah, it should probably be there somewhere.
12:09:43 <ski> thebug : waitasec
12:09:53 <thebug> no problem
12:10:26 <monochrom> fixpoint equations in types. w00t
12:10:47 <stepcut> SyntaxNinja: ok, so the problem is, we want to generate a bunch of files from an input template
12:11:10 * Philippa_ curses this chair
12:11:14 <Philippa_> my arse *hurts*
12:11:22 <SyntaxNinja> stepcut: yeah, basically a function from PackageDescription to the debian directory (in case that's not obvious)
12:11:55 <SyntaxNinja> so I was just looking around for my debhelper stuff from the prototype, but I can't find it; it's probably not worthwhile anyway.
12:12:37 <stepcut> SyntaxNinja: but we want the template to maintain? ie. not template = ["Package: " ++ cabalPackageName ++ "\nVersion" ++ cabalPackageVersion ....]
12:13:07 <SyntaxNinja> to maintain?
12:13:15 <SyntaxNinja> I think it only wants to be generated once, then the end user takes care of it.
12:13:21 <SyntaxNinja> end user == packager
12:13:39 <stepcut> let's back up
12:13:47 <SyntaxNinja> but yeah, I'm not sure of what the best way to generate these files is; we could come up with a syntax that won't clash with the rules file or the control file substitution syntax
12:14:22 <stepcut> the function PackageDescriptionToDebianDirectory, what will it take as input? Just the package description, or the package description and a template ?
12:15:06 <SyntaxNinja> idono, what do you think? 
12:15:27 * stepcut ponders
12:16:05 <stepcut> having the function take an in template is only useful if there is more than a few reasonable templates
12:16:58 <stepcut> I don't know the answer to that yet, so the safe thing would be to allow an optional template but not require one by default
12:17:31 <stepcut> also, do you want this tool to be haskell98 compatabile, or can it use ghc-only extensions?
12:17:31 <SyntaxNinja> well, the template might make things more flexible when we want to change things later, 'eh?
12:17:59 <SyntaxNinja> this tool? could be ghc-only, it's just for Debian use; it's always nice to be compatible, though
12:18:07 <stepcut> SyntaxNinja: right, but you can have a template that is read only at compile time, or one that is used at run time
12:18:40 <SyntaxNinja> right. I don't care much which way we do it this time.
12:18:52 * stepcut ponders some more
12:18:56 <SyntaxNinja> is there a ghc extension to help write multi-line strings, like wheredocs or whatever in perl?
12:19:08 <thebug> heredocs :)
12:19:18 <SyntaxNinja> jaja ;)
12:19:58 <thebug> heredocs are a great embodiment of laziness :)
12:20:11 <stepcut> SyntaxNinja: you can use TH to read a file at compile time and turn it into a string
12:20:48 <stepcut> my favorite hack is to use TH to generate the version number at compile time based on the current revision control patch level
12:21:20 <SyntaxNinja> heh
12:22:54 <stepcut> so, we have to worry about substituting variables within a file, but also the names of some of the files themselves ?
12:23:52 <SyntaxNinja> yep
12:24:35 <stepcut> and we need a 'syntax' that is uniquely distinguishable from valid debian syntax
12:25:00 <SyntaxNinja> right, which is kinda lame... hm
12:25:22 <stepcut> or we can restrict the input language of the templates
12:25:48 <stepcut> just because something is valid in debian language, does not mean the templates *have* to support it
12:25:52 <SyntaxNinja> thebug: got a better idea than heredocs? i haven't used them much.
12:26:10 <SyntaxNinja> we could just use something like ($-=cabalpackagename=-) or something
12:26:55 <stepcut> right
12:27:31 <stepcut> and perhaps provide an escaping mechanism, if you really want that string to appear unsubstituted in the output
12:28:28 <RussellOConnor> I can't beleive this haskell is valid
12:28:31 * stepcut ponders other possibilities
12:28:36 <RussellOConnor> hour = [(mm,ss,ff) | mm<-[0..59], (ss,ff)<-(if (mm `rem` 10)==0 then normalMinute else dropMinute)]
12:28:53 <RussellOConnor> I love this language.
12:29:03 <SyntaxNinja> stepcut: yeah, maybe :)
12:30:56 <stepcut> another possibility is to use an existing template language for the contents of files
12:31:19 <SyntaxNinja> true
12:33:19 <Marvin--> SyntaxNinja: darcs dist just calls tar and gzip
12:33:29 <Marvin--> iirc
12:34:31 <SyntaxNinja> actually, I'm looking at dh_make's man page and there are templates in there...
12:34:49 * stepcut installs dh-make
12:35:47 <stepcut> SyntaxNinja: if they can do what we need, that would certainly be the right thing to do
12:36:02 <SyntaxNinja> yeah...
12:36:06 <SyntaxNinja> they use syntax like this:
12:36:11 <SyntaxNinja> Source: #PACKAGE#
12:36:28 <Marvin--> yes, reusing dh-make makes sense
12:36:36 <stepcut> you you templatize file names?
12:36:38 <SyntaxNinja> I wonder if we can add variables here
12:36:52 <SyntaxNinja> I'd like that, yeah
12:39:06 <Marvin--> look at /usr/share/doc/dh-make/README.examples
12:41:31 <SyntaxNinja> fwiw, I'm asking about it on #debian-devel...
12:41:43 <SyntaxNinja> (it's not worth much, yet)
12:41:50 <shapr> yow!
12:44:34 <shapr> hiya anth
12:45:06 <shapr> so if there's an algorithmic description of a shuffle, what's the algorithmic description of a scramble?
12:46:12 <norpan> what's the difference?
12:46:15 * SyntaxNinja mutters something about debian tools being under-documented
12:46:36 <Marvin--> Fail: src/HUnitText.lhs: openBinaryFile: resource busy (file is locked)
12:46:39 * Marvin-- boggles
12:48:44 <monochrom> scramble = map shuffle
12:48:45 <stepcut> SyntaxNinja: looking at the source I don't see a way to add new variables
12:48:53 <Marvin--> SyntaxNinja: meh, your wash2hs Setup.description file has an underscore in the name field
12:49:07 <SyntaxNinja> is that bad?
12:49:11 <SyntaxNinja> change it to a '-' :)
12:49:25 <SyntaxNinja> stepcut: you're looking at the dh_make source?
12:49:34 <Marvin--> why do you want a separator at all?
12:49:36 <stepcut> SyntaxNinja: unfortunately
12:49:56 <SyntaxNinja> stepcut: I'd like to be able to say "dh-make --maint-address=foo --var BAR=BANG" or something
12:50:40 <stepcut> SyntaxNinja: too bad!
12:50:58 <SyntaxNinja> stepcut: but the source is right in front of you!
12:51:08 <SyntaxNinja> stepcut: you hack on debhelper and I'll work on the templates ;)
12:51:20 <SyntaxNinja> or s/debhelper/dh-make
12:51:22 <stepcut> :p
12:51:27 * stepcut does not know perl at all
12:51:32 <SyntaxNinja> oh, it's in perl?
12:51:48 <stepcut> yep
12:52:09 <stepcut> its ~600 lines
12:52:15 <SyntaxNinja> hmm
12:52:38 <SyntaxNinja> I'm not exactly a perl expert, but maybe I could hack on debhelper and you can do the templates :)
12:52:55 <stepcut> :p
12:53:07 <stepcut> do you need a variable they don't have ?
12:53:08 <Marvin--> I don't get it, why do I get these stupid locking errors?
12:53:24 <SyntaxNinja> Marvin--: I don't care about the "_" very much... I seem to remmeber that this was his package name or something.
12:53:59 <SyntaxNinja> stepcut: there should be a distinction between the debian source package name, and the cabal package name, I think.
12:54:26 <Marvin--> haskell-$cpackage
12:54:28 <SyntaxNinja> like for cabal itself, "haskell-cabal" is the soruce package name, whereas "cabal" is the cabal package name.
12:54:37 <SyntaxNinja> hm.
12:54:59 <SyntaxNinja> Marvin--: but I don't think that's going to be the normal rule
12:55:03 <stepcut> SyntaxNinja: hrm
12:55:03 <SyntaxNinja> in general, they're different namespaces.
12:55:27 <SyntaxNinja> Marvin--: I get them sometimes due to laziness of reading the files?
12:55:58 <Marvin--> SyntaxNinja: and the script isn't meant to produce a finished debian package either, haskell-$cpackage is a good suggestion, but iirc dh-make asks for a package name too
12:56:09 <dfd> bye
12:56:12 <SyntaxNinja> also, we could maybe do some dependencies, though not very well... and in the future, we might have a description
12:56:22 <stepcut> whoa, dh_make will try to look your name up via ldap
12:56:23 <Marvin--> oh, hm, so, where do we use readFile
12:56:46 <SyntaxNinja> reading the package description, the localBuildInfo, the config info
12:57:03 <Marvin--> yes, so why do I get the errors on *other* files?
12:57:10 <stepcut> SyntaxNinja: yes, so basically, debian let us down again :(
12:57:19 <Marvin--> Fail: hs/WASHClean.hs: openBinaryFile: resource busy (file is locked)
12:57:21 <SyntaxNinja> stepcut: I wouldn't be too harsh on them ;)
12:57:31 <stepcut> :p
12:57:41 <SyntaxNinja> Marvin--: maybe preprocessing?
12:57:59 * RussellOConnor thinks list comprehension is syntactic sugar for do notation.
12:58:19 <stepcut> SyntaxNinja: so, do we want to fix dh_make, or do we want to do something else ?
12:59:02 <SyntaxNinja> well, I'm thinking about marvin's suggestion that it isn't meant to build a perfect package or anything; the maintainer is going to have to edit it.
12:59:18 <Marvin--> SyntaxNinja: preprocessing just copies, and copying uses copyFile which uses bracket to ensure the handles get closed...
12:59:26 <Marvin--> well, *should* ensure that the handles get closed!
13:00:19 <stepcut> SyntaxNinja: true, but it's a same to throw away information that could be generated if dh_make wasn't so lame
13:00:45 <SyntaxNinja> stepcut: yeah; I don't know if I can justify hacking on dh_make at work right now, just to produce WASH packages...
13:00:54 <stepcut> SyntaxNinja: we could use dh_make as is for now, and the later fix dh_make ?
13:01:47 <SyntaxNinja> that seems to be the sane approach
13:02:49 <stepcut> my cat is eating seaweed !!
13:03:05 <Philippa_> cats like salty stuff
13:03:09 <Philippa_> eg sweat
13:03:20 <SyntaxNinja> stepcut: it's probably part of it's unknowable master plan.
13:05:15 <Philippa_> "indulge self at every opportunity" isn't exactly unknowable
13:05:47 <monochrom> w00t ghc 6.4 will support cabal
13:05:55 <Marvin--> stepcut: does it like sushi too?
13:06:04 <SyntaxNinja> so there's some rule that -dev packages are supposed to depend on um.... the non-dev version, if there is one, rigth?
13:06:45 <ski> i know a cat who eats peas
13:07:14 <ski> (and my cat likes to lick at plastic bags)
13:07:41 <stepcut> Marvin--: of course! and chicken shashimi
13:08:40 <SyntaxNinja> monochrom: what do you mean?
13:08:46 <stepcut> SyntaxNinja: so, should we start on the templates then?
13:08:55 <SyntaxNinja> stepcut: I just did...
13:09:08 <SyntaxNinja> I can add them to the cabal repo if you want?
13:09:12 <Marvin--> SyntaxNinja: uh, if it makes sense
13:09:22 <Marvin--> SyntaxNinja: if you just do static linking there will be no non-dev package to depend on
13:10:00 <SyntaxNinja> ok
13:10:57 <Marvin--> wonder how large a log file I'll get if I strace moduleTest
13:11:00 <SyntaxNinja> stepcut: does it look like those filenames like "package-dev.dirs" and "package1.dirs" get substituted for the package names?
13:11:18 <stepcut> SyntaxNinja: i think it usually does not make sense for the -dev to not depend on the non-dev. For example, usually the lib.so is in -dev, but the lib.so.1.0.0 is in the non-dev (and lib.so is just a symlink)
13:11:21 <SyntaxNinja> presumably package for the source package, package1 for the first binary package, etc?
13:11:59 * stepcut looks
13:13:22 <stepcut> yes
13:13:36 <Marvin--> I think we need our own templates, we can't really use the ones in dh-make
13:14:09 <SyntaxNinja> Marvin--:  we can use some of them
13:14:29 <Marvin--> sure
13:15:04 <SyntaxNinja> stepcut: does that mean #PACKAGE1# will do likewise in a source file? (I guess not...)
13:15:28 <stepcut> no
13:15:48 <SyntaxNinja> we could have another pass over the soruces after dh_make generates them, of coruse
13:16:05 <SyntaxNinja> will dh-make puke if it sees #SOMETHING# it doesn't understand
13:16:35 <stepcut> hrm, i think it might just ignore it
13:17:13 <SyntaxNinja> what does #PRESERVE# do?
13:17:17 <stepcut> it basically just does this:       $line =~ s/#PACKAGE#/$main::package_name/g;
13:17:33 <Marvin--> meh, don't tell me I have to look at how openBinaryFile is implemented just to figure this out
13:17:34 <stepcut> i don't think it checks for unknown fields, just known
13:17:57 <stepcut>   $PRESERVE="$PRESERVE --exclude $orig";
13:18:05 <Marvin--> oh wait, hmm
13:18:47 <Marvin--> openBinaryFile src WriteMode
13:18:50 <Marvin--> spot the error :-/
13:19:05 <SyntaxNinja> it's a directory?
13:19:07 <Marvin--> why-oh-why do I never learn that I suck at copying&pasting code
13:19:27 <Marvin--> openBinaryFile src ReadMode
13:19:28 <Marvin--> openBinaryFile dest WriteMode
13:19:31 <Marvin--> er, 
13:19:36 <SyntaxNinja> oh
13:19:37 <Marvin--> well, that's the fix, that is
13:19:44 <Marvin--> I had src for boths path names
13:19:46 * Marvin-- sighs
13:20:26 <stepcut> it appears that PRESERVE will be substituted with '--exclude $orig1 --exclude $orig2' for every .orig.tar.gz found
13:21:05 <stepcut> in the upstream source
13:21:19 <Marvin--> I need a beer
13:21:21 <SyntaxNinja> does anyhone care if I add debianTemplate to the cabal source?
13:21:26 <SyntaxNinja> Marvin--: help yourself to one on me :)
13:21:56 <SyntaxNinja> I'll get coffee and brb...
13:22:00 * Marvin-- wanders off to the kitchen
13:25:20 <Marvin--> this brewery has funny names on their beer
13:25:35 <Marvin--> like this lager which has a very "czech" character
13:25:51 <Marvin--> it's called Prague
13:27:50 <stepcut> SyntaxNinja: so I suspect you could use dh_make to do the initial processing, and then use sed to do a few additional replacements ...
13:29:19 <SamB> ski: thanks for finding the hole in my net
13:30:05 <Marvin--> not much of a net if it only has one hole
13:30:07 <SamB> well, *that* hole, anyway
13:30:31 <Marvin--> Cases: 25  Tried: 25  Errors: 0  Failures: 0
13:30:33 <Marvin--> *phew*
13:30:34 <SamB> Marvin--: the metaphore lacks depth
13:30:35 <ski>  SamB : oh you're back
13:30:54 <ski> i haven't looked through the rest of 't' yet, though
13:31:31 <SamB> hmm. I guess that is a bug in the article. I better fix it!
13:43:05 <Marvin--> SyntaxNinja: hmm, have we made any dramatic changes to our concept of hc-pkg that we should tell the Simons about before they release ghc 6.4?
13:47:13 <SyntaxNinja> Marvin--: is a ghc 6.4 pending?
13:47:32 <SyntaxNinja> Marvin--: there may be some things; I would be surprised to learn that they've been hacking on hc-pkg without telling me
13:48:44 <SyntaxNinja> we definitely need to mention the dashes
13:48:54 <pimpbot5000> hi, does anyone know of a good place for me to ask java parsing questions?
13:49:24 <shapr> #javapro
13:49:39 <stepcut> SyntaxNinja: (repeated from above) I suspect you could use dh_make to do the initial processing, and then use sed to do a few additional replacements, since dh_make appears to ignore unknown directives
13:49:50 <pimpbot5000> shapr: coo, thanks!
13:49:59 <SyntaxNinja> stepcut: yeah, that's kinda what I had in mind
13:50:16 <Marvin--> SyntaxNinja: SimonMar said something about end of August
13:50:19 <SyntaxNinja> stepcut: are you going to be working on this over the weekend (end of the day is coming up here on my side)
13:50:25 <SyntaxNinja> Marvin--: ok
13:50:35 <SyntaxNinja> it would definitely be good if 0.1 were released before ghc 6.4
13:50:44 <SyntaxNinja> I was even thinking of pushing to release this weekend...
13:50:49 <SyntaxNinja> what would you thinka bout that?
13:51:25 <stepcut> SyntaxNinja: sure, I need to get something packaged before monday
13:52:01 <SyntaxNinja> stepcut: I might put the dh_make template stuff on hold until monday, though... so I can do the release critical stuff for cabal over the weekend
13:52:05 <SyntaxNinja> (the dh_make stuff is for work)
13:52:14 <SamB> okay, did I fix the article right? http://en.wikipedia.org/wiki/Combinatory_logic
13:52:54 <stepcut> SyntaxNinja: if you send me what you have I can work on it
13:53:06 <SyntaxNinja> any objections to adding it to the cabal source tree?
13:53:12 <SyntaxNinja> (marvin--?)
13:53:20 * stepcut has no objections
13:53:58 <Marvin--> with parseStanzas remembering line numbers, parse errors in .description files should be much easier to track down, so a 0.1 should be possible pretty soon
13:54:27 <ski> SamB : what did you change ?
13:54:48 <Marvin--> actually, getting it out during the weekend might be a good idea, since I'm visiting my parents next week and won't have net access
13:55:55 <SyntaxNinja> is what you're working on stabalizing pretty well?
13:56:17 <SamB> ski: look in history
13:56:27 <SamB> "fixed rule 3 of each of the two Ts that I see so that they do not leave E unconverted"
13:56:46 * ski was looking for a diff
13:57:00 <SyntaxNinja> stepcut: OK, darcs pull will get the goods
13:57:00 <ski> (does wikipedia have that feature ?)
13:57:26 <SyntaxNinja> stepcut: I'm going to play w/ the postinst script and stuff...
13:57:48 <SamB> well, if nobody edits it first, http://en.wikipedia.org/w/wiki.phtml?title=Combinatory_logic&diff=0&oldid=4923172 should get you one
13:58:27 <SyntaxNinja> stepcut: is any substitution done in those other files, like package1.foo?
13:58:58 <Marvin--> yes, I think it's looking pretty good right now
13:59:22 <Marvin--> most likely people will find some d'oh:s right away and we'll be forced to release 0.1.1 after just a few days :)
13:59:40 <SyntaxNinja> Marvin--: yeah.
13:59:43 <SamB> what are fresh pairs of eyes for?
13:59:45 <SyntaxNinja> but at least they can test it for us ;)
14:00:13 <SamB> not that I have anything against one-eyed people
14:00:36 <SyntaxNinja> stepcut: OK, I added a "postinst" and "prerm"
14:00:56 <SyntaxNinja> I have these substitutions in there like #PACKAGE1# that would be the first thing to add to dh_make, IMO, and very useful.
14:01:00 <SyntaxNinja> would require an extra pass, though.
14:06:31 * Marvin-- sends some patches
14:07:49 <SamB> Riastradh: is it just me or do you not get many (S (K K) I)s with Î·-reduction?
14:11:33 <SyntaxNinja> stepcut: you might want to pull again if you pulled a few minuts ago.
14:12:43 <SamB> of course, with my showTerm, they show up as ((S (K K)) I)s...
14:15:19 <SamB> hmm. I wonder if they are assuming that there are no two variables named the same
14:18:01 * shapr grumbles at WASH
14:18:11 <stepcut> shapr: problems?
14:18:24 <shapr> have you used activeInputField?
14:18:33 <stepcut> no 
14:18:37 <RussellOConnor> K eqivalent to (S (K K) I)?
14:18:37 <stepcut> wacky ?
14:18:38 <SyntaxNinja> Marvin--: pushed
14:18:48 <shapr> I'm trying to figure out a good way to pass the answers to the questions around
14:18:56 <shapr> I'm not sure how to match them up
14:19:22 <shapr> GuessNumber.hs uses activeInputField, but I can't seem to get it to actually submit
14:19:26 <shapr> http://217.211.205.143/cgi-bin/ProtoQ
14:20:37 <RussellOConnor> S (K K) I x
14:20:42 <RussellOConnor> (K K) x (I x)
14:20:49 <RussellOConnor> K x (I x)
14:20:50 <shapr> @eval S (K K) I 2
14:20:50 * stepcut takes a nap
14:20:50 <lambdabot> <<EM Dynamic -> EM Dynamic>>
14:21:06 <RussellOConnor> oops
14:21:09 <shapr> stepcut: before you sleep, any suggestions for passing around answers for checking?
14:21:12 <RussellOConnor> K (I x)
14:21:13 <ski> SamB : ok, i think your changes are ok
14:21:14 <RussellOConnor> K x
14:21:28 <shapr> @get-definition K
14:21:29 <lambdabot> K = \\x y.x
14:21:29 <RussellOConnor> @eval S (K K) I  1 2
14:21:29 <lambdabot> 1
14:22:36 <SamB> shapr: would you try to get rid of that escaping?
14:22:40 <SamB> it also messes up:
14:22:43 <SamB> @moo
14:22:44 <lambdabot>          (__)
14:22:44 <lambdabot>          (oo)
14:22:44 <lambdabot>    /------\\/
14:22:44 <lambdabot>   / |    ||
14:22:44 <lambdabot>  *  /\\---/\\
14:22:44 <lambdabot>     ~~   ~~
14:22:46 <lambdabot> ...."Have you mooed today?"...
14:23:30 <SamB> are you going to say something?
14:24:02 <shapr> er, yes..
14:25:10 <RussellOConnor> @get-definition Y
14:25:10 <lambdabot> Y = \\f.U(\\g.f(U g))
14:25:12 <RussellOConnor> @get-definition U
14:25:12 <lambdabot> U = \\f. f f
14:26:18 <RussellOConnor> so what is T of \f.(\x. (f (x x)) (\x. (f (x x)))
14:29:05 <shapr> @get-definition K
14:29:05 <lambdabot> K = \x y.x
14:29:19 <shapr> SamB: fixed!
14:29:44 <SamB> @moo
14:29:45 <lambdabot>          (__)
14:29:45 <lambdabot>          (oo)
14:29:45 <lambdabot>    /------\/
14:29:45 <lambdabot>   / |    ||
14:29:45 <lambdabot>  *  /\---/\
14:29:45 <lambdabot>     ~~   ~~
14:29:47 <lambdabot> ...."Have you mooed today?"...
14:30:04 <SamB> okay, it works just like you said ;-)
14:30:41 <SamB> now, make it use real lambdas ;-) (just kidding!)
14:31:18 <ski> RussellOConnor : didn't you reduce worng up there ?
14:31:39 <RussellOConnor> yeah I think I made an error.
14:31:45 <ski> S (K K) I x = (K K) x (I x) = K (I x) = K x
14:32:08 <RussellOConnor> yep
14:32:11 <ski> S (K foo) I x = (K foo) x (I x) = K (I x) = K x
14:32:18 <ski> hmm
14:32:19 <ski> no
14:32:34 * ski confused it with another suck rule
14:32:38 <ski> such
14:32:48 <RussellOConnor> @T [\f.(\x. (f (x x)) (\x. (f (x x)))]
14:32:48 <lambdabot> Sorry, I don't know the command "T", try "lambdabot: @listcommands"
14:32:49 <shapr> oh I gotta integrate dons' new lambdabot code
14:32:50 <SamB> I notice I don't seem to get any (S (K K) I)s with Î·-reduction
14:32:53 <RussellOConnor> :-)
14:33:09 <ski> "Î·-reduction" ?
14:33:36 <RussellOConnor> \x. e x is Î·-equivalent to e.
14:33:44 <ski> RussellOConnor : iirc  Y = S I I
14:33:51 <ski> aha, eta
14:33:53 <RussellOConnor> Really?
14:33:59 <RussellOConnor> that's tiny.
14:34:27 <ski> hmm no
14:34:40 <ski> Y = S I I (S I I)   it might've been
14:35:07 * SyntaxNinja home &
14:35:26 <RussellOConnor> ski: not quite.
14:36:02 <RussellOConnor> that is (S I I) = (\x. x x)
14:36:06 <ski> right
14:44:33 <wagle> whats the option to get hugs (or ghc) to permit class Foo (Baz x y) where
14:44:34 <wagle> ...
14:44:58 <ski> \f.(\x. f (x x)) (\x. f (x x))  =  S (K (S I I)) (S (S (K S) (S (K K) I)) (K (S I I)))  if i didn't err
14:45:10 <shapr> -fglasgow-exts ?
14:45:26 <wagle> shapr: will hugs do it/
14:45:29 <wagle> ?
14:45:31 <shapr> oh, I dunno
14:46:04 <RussellOConnor> S (K (S I I)) (S (S (K S) K) (K (S I I)))
14:46:55 <wagle> hmm..  that doesnt work for "class Table (table key value) where" ...
14:47:57 <stepcut> everytime I try to update my darcs repo with pull, it ends with:
14:47:57 <stepcut> So far so good... finished merging.
14:47:58 <stepcut> HUP
14:48:00 <stepcut> !!
14:48:03 <ski> RussellOConnor : yes
14:48:55 <shapr> weird
14:49:46 <stepcut> hrm, I think its because I am using eshell and not bash ...
14:50:53 <wagle> shapr: nevermind for now, i was botching something else
14:53:57 <wagle> type MM k v = [(k, v)]
14:54:45 <wagle> class Table table key value where tlookup = table key value -> key -> Maybe value
14:55:01 <RussellOConnor> hand evaluation:
14:55:03 <RussellOConnor> S (K (S I I)) (S (S (K S) K) (K (S I I))) f
14:55:04 <RussellOConnor> (K (S I I)) f ((S (S (K S) K) (K (S I I))) f)
14:55:06 <RussellOConnor> (S I I) (S (S (K S) K) (K (S I I)) f)
14:55:07 <RussellOConnor> (S I I) (S (K S) K f (K (S I I) f))
14:55:09 <RussellOConnor> (S I I) ((K S f) (K f) (K (S I I) f))
14:55:10 <RussellOConnor> (S I I) (S (K f) (K (S I I) f))
14:55:12 <RussellOConnor> (S I I) (S (K f) (S I I))
14:55:13 <RussellOConnor> (S (K f) (S I I)) (S (K f) (S I I))
14:55:14 <RussellOConnor> (K f (S (K f) (S I I))) ((S I I) (S (K f) (S I I)))
14:55:16 <RussellOConnor> f ((S I I) (S (K f) (S I I)))
14:55:18 <RussellOConnor> Looks good.
14:55:23 <wagle> instance Table MM Int Int where tlookup table key = lookup key table
14:55:30 <SamB> I tried to do it by hand for 'pair', but I messed up real quick
14:56:04 <wagle> RussellOConnor: there's a applicative and a normal order Y, by the way, just in case it matters
14:57:16 <SamB> wagle: explain which is which!
14:57:28 <SamB> I want to know why they are both called Y
14:57:34 <SamB> and neither has a prime
14:58:00 <wagle> SamB: one works in call-by-value, and on works in call-by-need
14:58:01 <RussellOConnor> They are Î·-equivalent.
14:58:15 <SamB> oh
14:58:57 <wagle> when i by recursion in simple toy CBV languages, i use applicative Y combinator
14:59:04 <RussellOConnor> Î·-conversion can be used to delay evalutation in a crappy call-by-value language.
14:59:15 <RussellOConnor> :-)
14:59:26 <SamB> well, maybe you should explain about why people call both y f = f f) and y' = f (y' f) Y
14:59:43 <SamB> er, sorry about the stray paren
15:00:08 <wagle> shapr: it doesnt like my instance
15:01:02 <RussellOConnor> @get-definition X
15:01:02 <lambdabot> X = \x.x K S K
15:01:40 <RussellOConnor> ah, X.  The only combinator you need.
15:02:01 <SamB> RussellOConnor: well, you still need parens
15:02:02 <wagle> unary
15:02:06 <SamB> well, or `s
15:02:39 <RussellOConnor> Once you only have one combinator, you can omit it?  ((())())
15:02:53 <RussellOConnor> Hmm, I guess not.
15:03:19 <SamB> you still need to know how many you have in a row
15:03:41 <saynte> shapr: I made the installation of gtkmozembed for gtk2hs a little easier, did you want the new one?
15:04:12 <shapr> sure
15:04:46 <Marvin--> mmm, guinness
15:05:46 <det> RussellOConnor: hand-evaluation of SKI combinators makes you crazy
15:05:56 <det> RussellOConnor: for bonus points, expand the I combinators
15:05:57 <saynte> shapr: do you do DCC yet or will email be better?
15:08:24 <shapr> email please!
15:09:35 <saynte> hehe ok, what's your address again? i must've junked it :)
15:10:08 <wagle> yargh..  type/newtype is a horrible joke
15:10:36 <saynte> actually it's more of anecdote i find ;)
15:13:13 <shapr> shae at scannedinavian dot com
15:16:59 <saynte> ok, that should do it
15:17:00 <SamB> det: expaning Is has got to be the easiest part of that job!
15:19:22 <det> SamB: who calls y f = f f?
15:19:27 <det> SamB: I call that U
15:20:07 <det> shapr: harvesters have got to pick up that form by now :)
15:25:48 <SamB> det: are you certain? isn't that undecidable?
15:32:15 <ski> isn't what undecidable ?
15:55:27 <wagle> i need lfix for types
16:00:34 <ski> lfix ?
16:00:46 <det> SamB: what is undecidable?
16:01:31 <det> SamB: I have always considered the combinator of the form \x . x x to be named "U" is what I meant
16:01:39 <det> SamB: you can implement Y in terms of U
16:02:23 <RussellOConnor> @get-definition Y
16:02:23 <lambdabot> Y = \f.U(\g.f(U g))
16:16:56 <RussellOConnor> Okay, in GHCi, how do I add a file located at crypto\Codec\Encryption\SHA1.hs?
16:17:27 <RussellOConnor> I guess I want to add crypto to my ``path''
16:17:30 <RussellOConnor> or something.
16:17:39 <Cale> :add crypto/Codec/... or some such
16:17:47 <Marvin--> ghci -icrypto Codec.Encryption.SHA1
16:17:48 <RussellOConnor> because it relies on Codec.Encryption.Utils
16:18:04 <RussellOConnor> can I do :set -icrypto then?
16:18:46 <RussellOConnor> excellet.
16:18:50 <RussellOConnor> excellent.
16:37:29 <RussellOConnor> Is it easy to print a number as a hexidecimal number?
16:39:05 <RussellOConnor> er hexadecimal
16:41:54 <RussellOConnor> Util.intToHexString
16:47:33 <RussellOConnor> http://www.ninebynine.org/Software/HaskellUtils/HXmlToolbox-4.00/hdom/Util.hs
16:52:20 <keverets> import Numeric ; showHex 12345 ""
16:54:33 <shapr> there used to be NumExts
16:54:33 <shapr> it had showHex showBin
16:55:37 <keverets> showHex should probably be called showsHex, but whatever.
16:55:38 <RussellOConnor> What is ShowS?
16:55:38 <RussellOConnor> oh
16:55:38 <RussellOConnor> It's for efficent list manipulation?
17:03:01 <shapr> @index showHex
17:03:01 <lambdabot> Numeric
17:43:02 <ski> @info ShowS
17:43:03 <lambdabot> -- ShowS is a type constructor
17:43:03 <lambdabot> type ShowS = String -> String
18:40:10 <ski> bye
19:08:10 <Spark> oi
19:10:47 <stepcut> I made some changes to cabal, how do I sumbit them back to isaac ?
22:54:42 <SamB> Fixed point combinators are not especially rare. Here is one constructed by Jan Willem Klop:
22:54:44 <SamB>     Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L L L)
22:54:46 <SamB> where
22:54:57 <SamB>     L = Î»abcdefghijklmnopqstuvwxyzr.(r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
23:49:10 <dxlvi> 08:45 -!- Irssi: #haskell: Total of 1 nicks [0 ops, 0 halfops, 0 voices, 1
23:49:10 <dxlvi>           normal]
23:49:17 <dxlvi> O_o whoa!
