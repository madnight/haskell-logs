01:35:38 <Brandon__> Good orning
03:33:40 <shapr> good morning #haskell!
03:33:46 <Lukhas> salut shapr
03:34:53 <shapr> salut Lukhas 
03:34:59 <shapr> how's life?
03:35:23 <Lukhas> too hot :)
03:36:27 <shapr> I'm going unicycling in a bit.
03:36:37 <Lukhas> good luck
03:38:31 <shapr> but first... I need to write an IOHCC announcement.
03:39:19 <shapr> je lis 'Le sanscrit pour les nuls'
03:41:29 <Lukhas> you wanna learn Sanscrit ?
03:41:56 <shapr> sure, at some point
03:42:00 <Lukhas> wow
03:42:12 <shapr> I'm mostly reading this right now for the morphology connections.
03:42:47 * Marvin-- builds darcs 0.9.23
03:42:55 * andersca builds X
03:43:28 * shapr builds desk sculptures with empty cola bottles
03:43:57 * Lukhas body builds
03:44:10 <shapr> :-)
03:44:43 <Marvin--> wha? what kind of geek are you?
03:45:36 <shapr> well, part of being a geek is a committment to quality
03:46:25 * shapr looks for the IOHCC announcement from last time
03:50:08 <bourbaki> hi
03:52:40 <shapr> gutenmorgen!
03:53:06 <shapr> wie geht es?
03:53:24 <shapr> anything interesting happening today?
03:53:26 <bourbaki> gut danke ;) wie geht es dir?
03:53:38 <shapr> I'm jes' fine
03:53:42 <bourbaki> not yet i just got out of my bed
03:53:47 <Marvin--> aiih, deutsch
03:54:36 <bourbaki> ive started to progam a game in haskell
03:54:37 <shapr> vill du prata svenska istället?
03:54:45 <andersca> jag vill prata svenska!
03:54:58 <shapr> jag också!
03:55:09 * shapr ringer till andersca
03:55:27 <andersca> :)
03:59:10 <shapr> I need to study my swedish more!
04:06:20 <Spark> my glowsticks are still glowing
04:07:15 <shapr> how long?
04:07:43 <Spark> dunno
04:07:50 <Spark> over 12 hours prolly
04:07:50 <Spark> heh
04:08:32 <Marvin--> anyone feel like helping me torture the cabal package description parser?
04:10:32 <Spark> is that sadism or masochism
04:11:09 <Marvin--> http://www.nd.edu/~jsmith30/xul/test/spoof.html <- ouch
04:15:52 <shapr> hiya Iter 
04:44:50 <Iter> hey shapr :)
05:02:55 <Brandon__> okay. I want to perform a word search on 114 files.. the matches should be returned by closest proximity and include the the order of the initial words in the priority
05:03:47 <Brandon__> I would end up using this on spiritual/religious scripture, such as the Koran and the Old and New Testaments
05:04:12 <Marvin--> use an index/query engine?
05:04:38 <Brandon__> well, the 114 files are small enough that this can be processed at runtime without an index.. although I could possibly use such a thing
05:04:48 <Brandon__> I also want to include the possibility of spelling errors
05:05:15 <Brandon__> my idea is to use what I call a Peak Gradient Addition + Sort
05:05:32 <Brandon__> which I didn't call until that very line, and just made up the term
05:05:37 <Brandon__> :)
05:05:55 <Brandon__> That is.. consider representing the entire text as all white
05:06:03 <Brandon__> and where a word is matched, consider it a fuzzy black dot
05:06:20 <Brandon__> perhaps the gradient of the dot spreads to the very ends of the "image"
05:06:28 <Brandon__> so where words would appear would be black fuzzy dots
05:06:46 <Brandon__> when two words are near, the additive effect would be higher
05:07:24 <Brandon__> (hence, black is not a max or minimum value, so to speak)
05:09:02 <Brandon__> the end result, when reduced, has similarities to other ways of doing proximity searches
05:09:30 <Brandon__> ie. you end up with some sort of additive effect based on the difference in distance between words
05:09:55 <Brandon__> however, the direction of the origin of the algorithm contains the visualization
05:10:15 <Brandon__> for example, we were working on profanity filters for our system
05:11:45 <Brandon__> my system is a communications system online, and receives about 1.3 million hits per day
05:12:33 <Brandon__> and we like to keep it suitable for viewing by all ages (although there are some medical-related sections which some people might differ in opinion over)
05:13:13 <Brandon__> one of the things we had to rank high in the disapproved-scale is posts with children in the context of sex
05:14:01 <Brandon__> therefore, we might generate a rank for the amount of relativity a message has to "adult" content
05:14:15 <Brandon__> adding words, basically.. with weighted words
05:14:23 <Brandon__> and another for the "youth" ranking
05:14:52 <Brandon__> this will, for the most part, be sufficient, but I considered the proximity as well
05:17:01 <Brandon__> guess this channel's no so active at this time :)
05:49:55 <lmbdwar> lo
05:50:32 <Brandon__> hilo
07:14:26 * Marvin-- swears at the record update syntax
07:18:35 <Marvin--> maybe I should write some TH code for generating setters
07:37:18 <Marvin--> Igloo?
07:53:04 <Marvin--> woot
07:55:37 <Marvin--> update field = [| \rec val -> $(recUpdE [| rec |] [fieldExp (mkName field) [| val |]]) |]
07:56:04 <Marvin--> TH rules
07:56:26 <Marvin--> now, what sucks is that I can't use this in cabal ;)
07:56:27 <thebug> 'TH'?
07:56:35 <Marvin--> Template Haskell
07:56:44 <thebug> ah, sneaky :)
07:56:56 <Marvin--> [| foo |]  turns the expression foo into an abstract syntax tree for foo
07:57:08 <Marvin--> $(bar)  turns the abstract syntax tree bar into a haskell expression
07:57:21 <Marvin--> it's insanely powerful
07:57:36 <thebug> looks like it would be
07:58:09 <Marvin--> $(update "package") emptyPkgDesc "PackageName"
07:59:10 <bourbaki> could you use monads to construct some kind of combined object? like adding more information to vertices in a 3d mesh
07:59:15 <Riastradh> That's a hideous syntax for updating record fields.
07:59:31 <Marvin--> Riastradh: yes, but at least it can be partially applied, which was my goal
07:59:42 <Marvin--> emptyPkgDesc{package="PackageName"} is hard to partially apply
09:47:03 <shapr> man I love unicycling.
09:47:43 <shapr> ~seven km today
09:48:57 <Lemmih> Unicycling is a pain the in butt.
09:49:17 <shapr> heh
09:49:26 <shapr> or you can buy one of the Kris Holm seats
09:49:39 <shapr> five hundred kronor at unicycle.se
09:49:46 <shapr> but worth it :-)
09:49:49 <Lemmih> eeek..
09:50:00 <Lemmih> I don't have that kind of money.
09:50:18 <Smerdyakov> Right. You have Den-marks.
09:50:20 <shapr> I saving up for a 4000 kronor unicycle
09:50:28 <shapr> but it might be a few months :-/
09:50:36 <shapr> 92cm wheel!
09:50:42 <shapr> mmmmm
09:50:58 <shapr> Lemmih: did you find out which brand you have?
09:51:05 <shapr> I can send you my old seat if you want :-)
09:51:09 <shapr> it's not too bad
09:51:24 <Riastradh> Unicycling tends to be a pain in the part of the body you fall on, not your butt.
09:51:40 <shapr> I usually fall onto my feet.
09:51:44 <Lemmih> shapr: It says "20x1.75" on the wheel...
09:51:44 <Riastradh> Which is unfortunate, because your butt has more padding than most of the rest of your body.
09:52:18 <shapr> Lemmih: what color is the seat?
09:52:49 <Lemmih> Grey and kinda furry. (-:
09:53:00 <Smerdyakov> The seat, not your grandmother!
09:53:05 <shapr> those numbers mean that it's a 20 inch wheel diameter wheel, and a 1.75 inch width tire
09:53:29 <shapr> hm, might be a miyata
09:54:54 <Lemmih> Couldn't it be expensive to send something as big as a seat all the way from Finland to Denmark?
09:55:00 <Lemmih> *Wouldn't
09:55:31 <shapr> I dunno
09:55:37 <shapr> would be interesting to find out though
09:59:49 <Lemmih> Anything newer than my 18 years old seat would be greatly appreciated. (-:
10:01:35 <sazzle> unicycling more fun then bicycling?
10:02:27 <Riastradh> I like nullicycling.
10:03:00 <Lemmih> sazzle: It's more challenging.
10:03:01 <SamB> Riastradh: how is that done?
10:03:17 <Riastradh> With zero wheels, duh.
10:03:17 <sazzle> you slide on your butt?
10:03:41 <sazzle> Lemmih: where do you do it?
10:03:42 <SamB> Riastradh: yes, but there are a variety of things you can do with zero wheels
10:06:34 <Lemmih> sazzle: I used to ride it to school and I practice tricks in a park just next to where I live.
10:06:57 <sazzle> Lemmih: on the road?
10:07:02 <Riastradh> Practice tricks or practice hitting yourself with the earth?
10:08:17 <Lemmih> Riastradh: I almost never land on anything else than my feets.
10:27:55 <shapr> sazzle: unicycling is lots more fun than bicycling
10:28:03 <shapr> unicycles are more agile
10:28:25 <shapr> you can do tighter turns, ride on narrower things, etc
10:28:59 <sazzle> shapr: but you wouldn't really use it as a means to commute, would you?
10:29:03 <sazzle> or ride it in the bush
10:29:05 <shapr> yes I would actually
10:29:06 <shapr> both
10:29:09 <sazzle> really?
10:29:14 <sazzle> it's stable enougH?
10:29:18 <shapr> there are commuter unicycles, and mountain unicycles.
10:29:24 <andersca> boom
10:29:40 <sazzle> how fast do you go?
10:29:49 <shapr> you can got 25m/h with a coker
10:30:33 <shapr> sazzle: here's the coker, http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
10:31:27 <sazzle> 25m?
10:31:38 * sazzle hopes you mean km :)
10:32:04 <shapr> miles an hour
10:32:11 <sazzle> ah
10:32:16 <shapr> here's a sample of mountain unicycling: http://www.krisholm.com/multimedia/topofworld.jpg
10:32:17 <sazzle> read it as metres
10:32:58 <sazzle> nifty
10:33:45 <shapr> kris holm : http://community.webshots.com/photo/73832924/73843454UzXzxf
10:33:55 <shapr> kris holm is the most famous unicyclist around at the moment.
10:34:23 <sorrow> But you're catching up?
10:34:26 <shapr> he's the guy who does stuff like this: http://www.unicycle.se/images/FreeYourMindWebuk.jpg
10:34:38 <shapr> sorrow: only in my own city (-:
10:34:52 <sorrow> ;-)
10:34:59 <SamB> shapr: you are doing upside-down stunts ?
10:35:10 <shapr> SamB: never on purpose ;-)
10:35:21 <Brandon__> he makes unicycle cut-and-paste artwork?
10:35:23 <sazzle> shapr: i hope that's photoshopped :P
10:35:29 <shapr> it's not photoshopped.
10:35:30 <SamB> shapr: why was the smile upside-down?
10:35:40 <shapr> I felt backwards for a moment.
10:35:49 <SamB> ah
10:36:05 <shapr> (-: ?ton yhw ,yeh
10:36:50 <Brandon__> what about a word search of a file
10:36:52 <Brandon__> in haskell
10:36:56 <shapr> great idea!
10:37:10 <Brandon__> is it really??
10:37:15 <shapr> sure
10:37:26 <Brandon__> I'd be happy to have brought out a great idea into public
10:37:29 <Brandon__> usually I keep them to myself
10:37:36 <Brandon__> unsure if they're truely good
10:37:37 * SyntaxLaptop pokes shapr
10:37:55 <SamB> ‮okay, whatever :-)
10:38:00 * shapr pokes SyntaxLaptop back
10:38:35 <SyntaxLaptop> hey!
10:38:42 <shapr> I've always wondered what chinese IRC would look like... vertical lines that start at the top and go down...
10:39:42 <shapr> Brandon__: well, if you write the code, I'm sure people will use it.
10:40:14 <Brandon__> I've never coded a haskell program
10:40:24 <shapr> now is a good time to start!
10:40:52 <Brandon__> if you help me code this first one .. just read a file and, using space-separated words, display the lines containing the word
10:41:23 <Brandon__> the next goal is to do a proximity type of search.. where multiple words are specified on the commandline, the haskell program will display results sorted by a sort of best-fit
10:41:26 <Brandon__> best-match
10:41:49 <Brandon__> ie. words being close together, possibly including the order of the original given words to search for...
10:41:57 <SamB> you know, I think brackets ought to be swapped in right-to-left mode
10:42:09 <shapr> SamB: how so?
10:42:12 <Brandon__> and the eventual goal would be for the program to work on a character-level, incorporating the possibility of misspellings
10:43:15 <SamB> shapr: it just seems like it would be the way to go
10:43:15 <shapr> I have some bayesian statistics based spam-checking Haskell code that could be hacked into doing that.
10:44:04 <SyntaxLaptop> man... waht'st he email address for the debian haskell list? has anyone ever posted to it?
10:44:07 <Brandon__> well, how do I open a file and look word by word for a word?  :)
10:44:32 <Brandon__> is it more difficult than it would for me to type out C to do it right now?
10:44:45 <shapr> I've posted to it!
10:45:13 <shapr> Brandon__: yes, it's harder to start doing stuff in Haskell than to write it in C if you already know C :-)
10:45:36 <Brandon__> #include <stdio.h> int main(int argc, char *argv[]) { while(fgets()) etc...}
10:45:48 <SamB> it is not easy in C, though
10:45:58 <Brandon__> well, such a thing is not so easy to do in C.. it actually does take a bit
10:46:19 <shapr> Brandon__: http://www.scannedinavian.org/~shae/src/haskell/ProtoReadFile.hs
10:46:37 <Marvin--> SyntaxLaptop: debian-haskell@lists.urchin.earth.li
10:47:00 <shapr> I tend to write a prototype / code snippet for each new feature I want.
10:47:42 <shapr> so I have a zillion files named Proto*.{lhs,hs,py,c,joy,epi,sh,html,css,etc}
10:47:52 <Brandon__> perl -e 'undef $/; grep(/^$ARGV[0]$/, split(/\W/,<STDIN>));'  
10:48:09 <shapr> the nice thing about that is that I can come back and look at my prototypes to see how stuff works
10:48:10 <Brandon__> That might work.. might not have gotten it right though.. and some work could be done--accepting apostrophes, etc.
10:48:21 <shapr> lines $ words $ stuff
10:48:30 <SamB> where are the file-related functions again
10:48:48 <SamB> shapr: are you sure you aren't missing a map?
10:49:07 <shapr> um
10:49:17 <SamB> nevermind
10:49:37 <shapr> good point
10:50:03 <shapr> concatMap words $ lines stuff
10:50:10 * Brandon__ looks through shapr's Haskell/ dir
10:50:12 <SamB> or don't never mind, if it seems like the right thing to do ;-)
10:50:31 <sazzle> doing taxes is the pits
10:50:35 <shapr> sazzle: truly
10:51:05 <shapr> my local ~/src/haskell/ dir has 474 files in it
10:51:22 * sazzle grumbles and considers forgetting about it for the night
10:51:22 <shapr> 133 prototypes
10:51:29 <SamB> oh, I see. my hugs is the confused one, not me ;-)
10:51:41 <SyntaxLaptop> Marvin--: thanks.
10:51:48 <SamB> it can't remember how to find modules anymore for some reason
10:51:55 <Brandon__> I'm not sure how I got this page before:  http://paulgraham.com/accgen.html
10:52:22 * SyntaxLaptop is tempted to add a "haddock" target to the setup script just because I don't feel like writing the makefile stuff
10:52:38 * shapr has a bottle of sake!
10:52:43 <SyntaxLaptop> oh no
10:52:47 <shapr> oh, I'm dangerous now.
10:53:18 <shapr> I think beer and wine taste nasty, but I have a great fondness for sake.
10:53:35 <SyntaxLaptop> so maybe there should be a standard "doc" target
10:53:40 <SyntaxLaptop> maybe it should be non-standard
10:53:50 <SyntaxLaptop> there's nothjing wrong w/ the "simple" system implementing a non-standard target, right?
10:53:53 <SyntaxLaptop> hm. 
10:53:54 <shapr> why not standard?
10:53:59 <shapr> most things have docs
10:54:09 <SamB> I got some wine by mistake once and it tasted pretty bad
10:54:25 <shapr> wine is fermented grapes.
10:54:41 <shapr> if you expect fermented stuff to taste good, you should try fermented herring.
10:55:07 <SamB> shapr: I wasn't expecting to taste it
10:55:15 <shapr> there's a whole scandinavian industry dealing with fermented herring.
10:55:27 * Brandon__ eats a mulberry
10:55:30 <maihem> shapr: Are you serious?
10:55:55 <Brandon__> just one.. or a lot of them?
10:56:12 <shapr> maihem: google for fermented herring, check out the second hit :-)
10:56:20 <thebug> fermented herring?!
10:56:59 <shapr> thebug: hey, many people like fermented grapes, right?
10:57:02 <shapr> why not herring?
10:57:03 <thebug> indeed
10:57:11 <thebug> I guess that's quite a valid point :)
10:57:34 <Riastradh> Lutefisk!
10:57:52 <thebug> Somebody ate all my lutefisk!
10:59:14 <shapr> a lutefisk sounds like a guitar played with kitchen utensils.
10:59:31 <sorrow> mm, lutefisk. http://www.norwaypost.no/images/bildearkiv/lutefisk.jpg
10:59:35 <Smerdyakov> It sounds like Wilson Fisk, the Kingpin of Crime!
11:00:39 <Brandon__> http://www.soa.edu.stockholm.se/holland/summer/cans.jpg
11:00:42 <Brandon__> fermented herring cans
11:01:02 <maihem> heh: "This is the trick - you must as quick as possible see to that you strike out your smelling sence."
11:01:14 <maihem> on opening a can of fermented herring :)
11:05:02 * Lemmih wonders why wxHaskell is working in ghci on his Debian machine but not on his Gentoo machine.
11:06:59 <SyntaxLaptop> Lemmih: are you using my wxhaskell packages?
11:07:02 <SyntaxLaptop> (ooi?)
11:07:41 <SyntaxLaptop> so I can't figure out a way to get the haskell sources to preprocess in a way that'll output something that haddock will eat.
11:07:50 <Lemmih> SyntaxLaptop: Nope.
11:07:50 <SyntaxLaptop> there's always this cruft on the top
11:08:54 <Brandon__> in looking through this haskell source.. it doesn't seem like a comfortable language to code in
11:09:15 <Cale> Brandon__: it's quite comfortable actually
11:09:43 <Brandon__> it seems more algorithmic .. more mathematical..
11:09:47 <Cale> I'm working on a compiler in Haskell, and there are some algorithms involved that I would not want to attempt in most other languages.
11:09:52 <Brandon__> so in that respect it's less practical to me.. 
11:10:07 <Smerdyakov> Brandon__, why?
11:10:28 <Cale> You want a language which allows you to express algorithms more clearly.
11:10:42 <Brandon__> if anyone wants to help me through this, I would appreciate it.. I like to feel I have important matters to tend to, and you could contribute to getting past some of these little hurdles that, I think, should be overcome
11:10:47 <Cale> That's all you do with programming languages - express algorithms to do things :)
11:10:48 <Brandon__> see www.mtoshahmaghsoudi.org
11:11:34 <Brandon__> Cale, there are three routes I'm looking at--one or more might be taken.
11:12:02 <Marvin--> SyntaxLaptop: what the heck is the deal with these package1.* files in the templates?
11:12:16 <Brandon__> One is to merely have someone program for me/us -- we've already had someone, whom I taught to program myself, when she was young, and who now, many years later, has returned to work for us (for my wife)
11:12:37 <Marvin--> SyntaxLaptop: shouldn't those postinst/prerm scripts be for the dev package?
11:13:06 <Smerdyakov> Brandon__, so what you are saying is that you are primarily looking to obtain someone to program for your institute, not necessarily to learn anything yourself?
11:13:24 <Brandon__> The second is to come up with easier ways to code.  I am more task oriented, now, and want to deal with the cludge of C much less than I am forced to when coding in C; however, I wish not to give up the efficiency of C itself--it's impractical for our services to waste our limited resources
11:14:14 <Brandon__> Obviously, shifting over to the first route means I end up doing less C myself
11:14:17 <Smerdyakov> Brandon__, I'd encourage you to look into ML instead of Haskell if every bit of runtime efficiency matters to you.
11:14:31 <Cale> Brandon__: what sort of things is your code doing?
11:14:38 <Brandon__> one sec.. 
11:14:46 <Brandon__> want to get the third one out of the way
11:15:29 <Brandon__> The third, and very important one, is that I've noticed my thoughts and behavior are affected in some way, whether small or large, by my coding in C for so long.
11:15:54 <Brandon__> and I've noticed a shift--usually a subtle but interesting shift, but a shift in thought nevertheless
11:16:08 <Brandon__> ... upon learning other _ways_ of programming
11:16:36 <Brandon__> so it was important to me to experience a bit of haskell, for example, because its seeming very different way of approaching coding
11:16:56 <Brandon__> seemingly
11:17:32 <Cale> yeah
11:17:33 <Brandon__> Smerdy, regarding looking for someone... no... we have someone.  I'm discussing the significance and options that are available
11:17:40 <Brandon__> These are also the same options available to everyone
11:18:20 <SamB> Brandon__: yes. it has been said that a language is not worth learning if it does not change the way you think
11:18:53 <Smerdyakov> Brandon__, all right. Then I'd like to return to the two replies I made to you earlier.
11:19:07 <Smerdyakov> Brandon__, first, I asked you why being "algorithmic and mathematical" made a language "less practical."
11:19:08 <Brandon__> I'm speaking of them in terms of programming--however, it applies in many ways.  Our thoughts are influenced by many things as we grow up, and many of the ways in which we think about things are limitations.
11:19:19 <Smerdyakov> Brandon__, I also suggested looking at ML if runtime efficiency is important to you.
11:19:25 <Brandon__> I might say that they are "guided" a certain way.
11:20:02 <Brandon__> have it up in a webbrowser now, Smerdyakov.. thanks.  :)
11:20:17 <Brandon__> SamB, who said that?
11:20:49 <Cale> "ghc -O2" has been reasonably efficient for everything I've ever tried to do.
11:21:50 <Smerdyakov> Cale, I think it has slowdown factors of 2 or more compared to gcc, doesn't it?
11:21:54 <Brandon__> is ml more efficient than C?
11:22:10 <Brandon__> ohh.. I didn't know caml was a dialect of ml
11:22:35 <Brandon__> was looking into caml about the time I began looking into haskell
11:22:37 <Smerdyakov> Brandon__, I think so. We are in the critical period now where ML compiler writers work to put the effort into ML compilers that has been put into Fortran and C compilers for the last 30 years.
11:26:10 <Brandon__> http://www.dcs.napier.ac.uk/course-notes/sml/recball.htm
11:26:24 <Cale> Smerdyakov: Using what as comparison?
11:26:41 <Brandon__> did I miss anyone's question.. while I was talking?
11:27:01 <Brandon__> Ah yes, Cale
11:27:06 <Brandon__> hold on, m'lady needs me
11:27:46 <Cale> Smerdyakov: (that was in reference to the slowdown factors involved)
11:28:40 <Brandon__> regarding what the application of my programming is
11:28:52 <Smerdyakov> Cale, a reasonable sized set of programs that do the same things, written by people with reasonable skill.
11:29:04 <Brandon__> well.. there's work.. and then there are other things
11:29:11 <SyntaxLaptop> Marvin--: package1.foo means "the first binary package".foo
11:29:25 <Brandon__> almost all of which I take seriously..
11:29:31 <Brandon__> maybe when I was young I played :)
11:30:17 <Brandon__> I figure it's a mix of ages in this channel?
11:30:47 <Marvin--> SyntaxLaptop: so why is there both package1.files and package-dev.files?
11:31:27 <Brandon__> The main purpose for me to be involving myself with Haskell is, most importantly, because my approach to problem solving, while I think very good... how do I say this--there is the "unknown" factor.
11:31:39 <Cale> A factor of 2 is actually pretty good. I'd have figured it would be worse.
11:32:07 <Smerdyakov> Cale, I said that because ML compilers routinely do much better than that.
11:32:29 <Brandon__> That is, C, then Perl.. and that was very long ago.  I've not learned any new programming languages since then, and I feel it worthwhile, as a part of a feeling of duty to you, perhaps, or to myself, to ensure I have the understanding of the significance of the difference in programming thought.
11:32:44 <Cale> Brandon__: go for it :)
11:32:51 <Brandon__> As a programmer, you have a certain potential for determining where a problem is in life.
11:32:52 <Smerdyakov> Brandon__, why did you say that "algorithmic and mathematical" means "less practical"?
11:32:53 <SyntaxLaptop> Marvin--: hm. are there package1.files?
11:32:53 <Cale> You need a link to a good tutorial?
11:33:07 <SyntaxLaptop> Marvin--: when was the last time you pulled? 
11:33:19 <Brandon__> You might have already experienced this when working with others, and you found yourself able to find what wasn't a problem, put it aside, and move until you found the problem.
11:33:34 <Cale> Brandon__: http://www.isi.edu/~hdaume/htut/tutorial.pdf
11:33:49 <Marvin--> SyntaxLaptop: just now
11:34:05 <Brandon__> Smerdy, perhaps it's only because most of the program samples I've seen have been different from what I normally need.
11:34:10 <Marvin--> SyntaxLaptop: just look at the main repo
11:34:12 <Brandon__> Normally I process words, text, load features up, etc.
11:34:33 <Brandon__> see www.voycabulary.com
11:34:41 <SyntaxLaptop> even cpphs doesn't make the files parsable by haddock :(
11:34:51 <Brandon__> I coded that in 1998 .. was doing medical research and had to look up words repeatedly
11:34:52 <Marvin--> SyntaxLaptop: cpphs --noline?
11:35:14 <Brandon__> that is, had to look up a lot of medical words in a biopsy report, so I typed it out, and wrote this program that allowed me to click on them to look them up
11:35:43 <Smerdyakov> Brandon__, I think you'll find that this is not an inherent property of the language; it comes from your lack of familiarity with it.
11:35:55 <Brandon__> I know that possibility exists..
11:36:17 <Brandon__> so, I wanted to code up a sample app--it's not practical for my work, and that's fine, it's something else I would use..
11:36:24 <Marvin--> gha, nameserver issues again
11:36:26 <Marvin--> sucks
11:36:47 <SyntaxLaptop> Marvin--: hm. something is messed up
11:37:00 <Brandon__> because it's originating from my own thoughts, implementing it should be even better than these samples I'm looking at
11:37:18 <Marvin--> SyntaxLaptop: addfile bugs? :)
11:37:36 <Brandon__> because, for the most part, "why would I want to do that?  this doesn't make sense." comes into play.. not as a fault of me, but as a part of the natural learning process
11:37:40 <Brandon__> but I'm babbling
11:37:54 <SyntaxLaptop> Marvin--: might be... I'll try to fix it
11:37:59 <SyntaxLaptop> but package1.perrm is correct.
11:38:03 * Brandon__ goes to install hugs on his linux box
11:38:11 <SyntaxLaptop> package-dev.foo is maybe not correct.
11:38:32 <SyntaxLaptop> maybe I should package the new darcs ;)
11:38:34 <Cale> Brandon__: you might also like ghc
11:39:07 <Brandon__> what's the difference?
11:39:21 <Cale> ghc is a compiler and an interpreter
11:39:29 <Marvin--> SyntaxLaptop: actually, I was just about to offer to co-maintain it
11:39:39 <Cale> It has more features than hugs
11:40:13 <Marvin--> but right now I'm having sodding nameserver issues and can't reach anything with a .debian.org domain
11:40:14 <Marvin--> grrr
11:40:22 <thebug> anyone seen dons in the recent past?
11:40:32 <Brandon__> My name is Brandon, by the way.  Nice to meet you all.
11:40:44 <SyntaxLaptop> Marvin--: I don't really feel like I need help on that one, actually.
11:40:50 <Brandon__> I thought hugs was a compiler too
11:41:02 <Marvin--> SyntaxLaptop: sure, just a thought
11:41:13 <SyntaxLaptop> hi Brandon__ :)
11:41:19 <thebug> Brandon__: just interpreter
11:41:22 <Brandon__> ahh
11:41:25 <thebug> Brandon__: also, nhc98 is a compiler
11:42:12 <Smerdyakov> I am going to check a book out of the library to read for pleasure. Does anyone have any suggestions on what I should choose?
11:42:27 <thebug> Smerdyakov: do you enjoy neal stephenson?
11:42:38 <Marvin--> SyntaxLaptop: I built myself an ugly 0.9.23-0.1.local so I could get rid of the addfile bug ;)
11:42:44 <Smerdyakov> thebug, never read any, and I have reason to doubt I would like it.
11:42:53 <Brandon__> okay.. got ghc installed..
11:42:54 <thebug> mmm, just a thought :)
11:43:15 <Brandon__> now to pick an application to begin coding
11:43:23 <Marvin--> SyntaxLaptop: anyhoo, I always thought that the package1 and package-dev files in the 'l' dh-make template corresponded to the libfooX and libfoo-dev packages
11:43:58 <Brandon__> the first program I ever coded was an artificial intelligence learning application, (from a book!), which asked questions about an animal, and learned, and attempted to guess them
11:44:06 <stepcut> dh_make is a horrible program
11:44:12 <Brandon__> done in basic with line numbers on a commodore 64..
11:44:27 <stepcut> heh
11:44:36 <Brandon__> copied from a book, that is
11:44:45 <stepcut> you should have used prolog :p
11:45:13 <Marvin--> or lithp
11:45:22 <SyntaxLaptop> ahh, stepcut :) glad to see you
11:45:35 <Brandon__> i'm also in #lisp now.. also interested in trying it a bit
11:45:39 <SyntaxLaptop> Marvin--: harass stepcut while I hack on the release :)
11:45:45 <Brandon__> not to make the compilers jealous
11:45:58 <Marvin--> I don't want to harass anyone, I don't know enough about this to harass anybody about it, I just thought it looked odd
11:46:03 <Brandon__> I scold them and tell them I'm using vi for all my coding anyway
11:46:07 <stepcut> SyntaxLaptop: I sent you an email with some patches
11:46:13 <Marvin--> oh, the rules file is broken, btw
11:46:34 <SyntaxLaptop> stepcut: I applied the email I got this morning
11:46:48 <SyntaxLaptop> but maybe, just maybe it didn't work because of a darcs bug
11:46:55 <stepcut> SyntaxLaptop: no, I just sent a second email
11:47:02 <stepcut> with more patches ;)
11:47:20 <SyntaxLaptop> Marvin--: I meant "harass" in a good way ;) I thinkt hat your concerns are valid, I'm just trying to focus on something else right now
11:47:31 <SyntaxLaptop> mostly because the dh_make stuff is for work, and I'm not at work ;)
11:47:36 <SyntaxLaptop> stepcut: OK cool.
11:48:13 <stepcut> dh_make is really lame
11:48:49 <stepcut> basically, the *only* file renaming in can do is rename files like package-something.ext to <name_of_source>-something.ext
11:49:02 <stepcut> it won't do: libghc6-package-dev.postinst
11:49:22 <stepcut> and there is no way to refer to 'the first binary package', etc
11:49:59 <stepcut> dh_make is another fine example of a crappy debian tool :)
11:53:27 <Marvin--> I think it's more likely that it started out as a simple tool to make a few things just a bit simpler and then people tried to shoehorn it into doing loads of other stuff it wasn't designed for
11:53:43 <stepcut> exactly
11:53:44 <Marvin--> and if you want to sum that up as "crappy"... *shrug*
11:54:08 <stepcut> debian is full of tools that had no design and only do a half-assed job
11:54:12 <RussellOConnor> @get-definition X
11:54:12 <lambdabot> X = \x.x K S K
11:54:40 <stepcut> for example, dh_install can't handle spaces in filenames/directories
11:54:55 <Marvin--> what?
11:55:00 <Marvin--> that sucks
11:55:03 <stepcut> yes
11:55:13 <Marvin--> how the heck did that happen anyway?
11:55:22 <Marvin--> bad pattern expansion?
11:55:26 <stepcut> .install files are a space delimited format with no escaping mechanism
11:55:33 <Marvin--> gnngh
11:55:45 <SyntaxLaptop> :(
11:56:01 <Marvin--> maybe someone made an executive decision that spaces in filenames suck ;)
11:56:05 <SyntaxLaptop> we're not so much trying to shoehorn it into doing something it wasn't designed to do, really...
11:56:29 <Marvin--> well I'm not sure what it was originally designed to do, so I wouldn't know
11:56:39 <RussellOConnor> K = X X X
11:56:40 * stepcut notes that we are trying to do exactly what it claims to do
11:56:42 <RussellOConnor> S = X (X X)
11:57:38 <Marvin--> so file bug reports
11:58:14 * Marvin-- swears at the name server problems
11:59:34 <Brandon__> can you declare and initialize a variable at the same time
12:00:59 <Cale> Brandon__: in which language?
12:02:00 <RussellOConnor> ((a ⇒ b ⇒ a) ⇒ ((c ⇒ d ⇒ e) ⇒ (c ⇒ d) ⇒ c ⇒ e) ⇒ (f ⇒ g ⇒ f) ⇒ h) ⇒ h
12:02:02 <Brandon__> Haskell
12:02:25 * stepcut heard shapr can declare and initialize a variable at the same time while riding a unicycle
12:02:36 <Cale> Variables don't change their values after declaration, unless they're formal parameters to a function.
12:02:47 <Cale> (in which case they don't really have values)
12:03:04 <Brandon__> is Shapr the one who rode the unicycle at the Haskell gathering..
12:03:22 <stepcut> Brandon__: probably
12:03:24 <Brandon__> looking like they were up a story or two next to windows
12:03:41 <Marvin--> well, John Hughes tried the unicycle too
12:03:41 <Cale> So when you write "a = 5" in Haskell (say at the top level), you declare a variable called a to be equal to 5.
12:04:21 <Riastradh> Marvin--, that 'tried' sounds fairly ominous to me.
12:04:24 <stepcut> Cale: techincally, that is a constant applicative function
12:04:35 <Cale> stepcut: sure :)
12:04:42 <Marvin--> Riastradh: :)
12:04:51 <SyntaxLaptop> stepcut: not sure what to usefully do w/ this dh_make patch; are yhou sending it upstream/
12:05:19 <Cale> Which is probably a better name, as it's really not going to take on any other values.
12:05:46 <SyntaxLaptop> Marvin--: I'm totally lame. I forgot to push stepcut's patches, that's why it seemed so broken
12:05:49 <stepcut> SyntaxLaptop: dunno. They clearly made a choice to *only* support renaming files that start with package, so I am not sure if they will be interested...
12:05:51 <SyntaxLaptop> (the debianTemplates stuff)
12:05:58 <SyntaxLaptop> stepcut: worth a try
12:06:07 <SyntaxLaptop> I suspect upstream doesn't get many patchse for that.
12:06:20 <SyntaxLaptop> stepcut: pushed your patches.
12:06:26 <Marvin--> SyntaxLaptop: ah :)
12:06:39 <stepcut> SyntaxLaptop: yeah, I guess I should just file bug reports on everything I think is broken with dh_make and see what they say
12:07:16 <Cale> Brandon__: anyway - there's no destructive update in Haskell (at least, not in the core of the language)
12:07:23 <SyntaxLaptop> stepcut: put on your fireproof jacket ;)
12:08:09 * stepcut suits up
12:08:33 <SyntaxLaptop> stepcut: please do CC me
12:08:43 <SyntaxLaptop> or even debian-haskell list?
12:13:07 <Marvin--> cp .installed-pkg-config installed-pkg-config
12:13:08 <Marvin--> uhhh
12:16:39 <SyntaxLaptop> ?
12:17:22 <Marvin--> it's in the rules file
12:17:26 <Marvin--> in debianTemplate
12:19:13 <SyntaxLaptop> so it can be instaled in /usr/share/doc/foo?
12:20:29 <stepcut> yeah, that may be overkill
12:21:06 <SyntaxLaptop> btw, stepcut, I didn't mean for the "make clean" rule to remove setup and Setup.o; I meant for the debian/rules clean rule to do it.
12:21:16 <stepcut> technically, you should use dh_installdocs to install documentation, so that if the location changes, (for example, when it changed from /usr/doc to /usr/share/doc) your docs will still install in the right place
12:21:24 <SyntaxLaptop> becuase it'll need to do so in order to not include those int he diff, right?
12:21:33 <SyntaxLaptop> stepcut: I think that's good
12:21:36 <stepcut> but dh_installdocs does not let you rename the file when it gets installed :(
12:22:19 <stepcut> SyntaxLaptop: right, that's what i meant too 
12:23:02 <stepcut> (in regards to make clean vs debian/rules clean)
12:23:23 <SyntaxLaptop> stepcut: maybe .installed-pkg-config shoud be "cp .installed-pkgconfig debian/tmp/installeded-pkg-confgi" or whatever
12:23:26 <SyntaxLaptop> ok
12:23:31 <stepcut> in my email, just substitute make with debian/rules
12:24:33 <stepcut> SyntaxLaptop: I was thinking about that, we would just need to add a rules to clean to make sure tmp got removed (unless clean already does that even in compat 4 mode)
12:25:05 <Marvin--> I don't get why we use a dot-name for the file at all (from the cabal PoV)
12:25:58 <SyntaxLaptop> Marvin--: I'm not too wedded to it; it seems like the kind of thing you make a dotfile for :)
12:26:18 <Marvin--> I think it's a bit obscure
12:26:42 <Marvin--> but maybe that's me
12:27:08 <SyntaxLaptop> Idono; it seems like a temporarly configuration file that the user shouldn't be bothered with.
12:28:44 <Marvin--> actually, why don't we give a flag to the install command for target file name?
12:28:48 <SyntaxLaptop> well, if we change it, we should probably do it now.
12:29:17 <SyntaxLaptop> why? it's internal to Setup.Description.
12:30:23 <Marvin--> because the file *isn't* internal, for precisely the packaging use case
12:30:50 <SyntaxLaptop> true; it seems like overkill, though.
12:30:58 <SyntaxLaptop> to allow them to specify where to put it, that is.
12:31:02 <Marvin--> and I don't see why setup register has to generate a file at all, can't it just generate a string and open a pipe to hc-pkg?
12:31:04 <Brandon__> time to go.. take care
12:31:23 <Marvin--> (and if it badly needs to generate a file, it should generate a temporary file)
12:31:31 <SyntaxLaptop> actually, it's generated at build time now, fwiw.
12:31:45 <Marvin--> well, I don't care *when* it's generated, especially if it doesn't need to be generated at all ;)
12:33:06 * SyntaxLaptop shrugs
12:33:27 <SyntaxLaptop> the way it works is pretty straightforward and works well enough; it seems reasonable to me.
12:33:30 <Marvin--> I just feel uncomfortable with the large amount of magick going on
12:33:54 <SamB> Marvin--: you would prefer manual labour?
12:34:09 <Marvin--> no, I would prefer that it's a bit more predictable
12:34:33 <SyntaxLaptop> it might be nice if there were an explicit target "./setup generate-installed-pkg-info --location=/tmp/foo" and otherwise, the file doesnt' get generated.
12:35:04 * stepcut agrees with marvin about magic
12:35:44 <SyntaxLaptop> I don't think that the .installed-pkg-info file shuold be a part of the promised interface... it would be good to be able to make some commitment about the interface there.
12:36:11 <Marvin--> I don't think we should be too scared to change the interface, we're talking about 0.1, not 1.0 or even 0.99
12:36:13 <SyntaxLaptop> I think this is a 0.2 issue, though.
12:36:45 <SyntaxLaptop> yeah; it's a pitty that we'd break the debianTemplate stuff, but not really a big deal.
12:37:12 <Marvin--> you use the template once, when you generate the skeletal package, it doesn't matter if it changes
12:37:42 <Marvin--> especially when it changes to keep pace with the real world ;)
12:37:43 <SyntaxLaptop> I especially see annoing problems with .installed-pkg-info when we start working w/ more than one compiler, though it may be that each version of HC-PKG will use the same file.
12:37:55 * stepcut would rather break interfaces and get it right, than use broken interfaces for the next 20 years
12:38:03 <SyntaxLaptop> stepcut: word.
12:38:38 <SyntaxLaptop> despite my wanting to use the interface for debianTemplate, we're not making any promises as to the itnerface for this release; it's just for people to take a look at and give us feedback.
12:42:34 <SyntaxLaptop> OK, I've gotten to the bottom of my release-critical todo list, except for some documentation stuff. so it would be nice if Igloo, Marvin--, and stepcut take a look at the repo for anything that looks release-critical for 0.1
12:44:46 <Marvin--> there are still several items in the TODO, have you pushed to the main repo?
12:45:55 <SyntaxLaptop> just did
12:45:58 <SyntaxLaptop> sorry
12:46:18 <SyntaxLaptop> there's stuff like "grep for FIX" and "look at this code" which I still plan to do
12:46:55 <SyntaxLaptop> those are less concrete TODOs, I've actually already done them, I jst want to remind myself to double-check before the release
12:47:01 <Marvin--> fuck, stupid el-cheapo cognac glasses that break when you fucking wash them
12:47:03 * Marvin-- growls
12:47:12 <SyntaxLaptop> Marvin--: are you grumpy today?
12:47:22 <Marvin--> not really
12:47:28 <Marvin--> I just get annoyed when I break glasses
12:48:24 <SyntaxLaptop> I'm going to take a shower; email me if you see any good reasons not to release :)
12:50:16 * Marvin-- pours a cognac in a non-broken glass
13:02:14 <RussellOConnor> Tail recursive == good, yes?
13:02:44 <Cale> RussellOConnor: generally, yeah :)
13:04:03 <Marvin--> depends on how lazy you want it to be
13:04:55 <RussellOConnor> I'm pretty lazy.  Maybe I wasting time trying to use foldl instead of foldr.
13:09:28 <RussellOConnor> oh, is foldl less lazy than foldr?
13:12:05 <Marvin--> well, let's say that you use foldr to produce a list, for every recursive call, it will produce a new list element (f x (foldr f ...) remember?), whereas with foldl you wouldn't get at the list until all the input list is consumed
13:13:04 <stepcut> there needs to be another layer on top of haskelldb i think
13:13:55 <stepcut> something that understands mapping haskell data structures to a relation database and back -- "I want to store this tree in a table"
13:14:10 <RussellOConnor> Marvin--> Ah.  In this case I'm producing and integer, so I might as well not be lazy, since I'm going to need to consume the whole list.
13:14:23 <RussellOConnor> decodeInteger :: (Integral b, Bits b, Bits c) => [b] -> c
13:14:25 <RussellOConnor> decodeInteger = foldl decodeIntHelp 0
13:14:27 <RussellOConnor>   where decodeIntHelp n x = (shift n (bitSize x)) .|. (fromIntegral x)
13:15:07 <Marvin--> sure, I just want to dispel the "myth" or whatever you want to call it that foldl is always better than foldr :)
13:15:28 <RussellOConnor> Marvin--: Thanks for the tip on what I need to consider.
13:15:51 <Marvin--> for example, foldr works with infinite lists, foldl obviously doesn't
13:15:56 <Marvin--> that's a very good reason to use foldr
13:16:22 <RussellOConnor> Since decodeIntHelp is associative, I could use either foldl or foldr.
13:19:26 <TheHunter> and be careful: ghci doesn't optimize tail recursion away
13:21:31 <RussellOConnor> TheHunter: Will ghc compiler?
13:21:57 <TheHunter> i think you need some -O flag
13:22:21 <Riastradh> It doesn't!?
13:23:42 <TheHunter> i just did foldl const 0 [1..] and my comp ran out of memory
13:24:11 <Riastradh> YUCK!!
13:28:08 <TheHunter_> dammit, i should have never enabled that stupid 2.6er option that claims to handle out-of-memory conditions even more gracefully...
13:28:40 <TheHunter_> ghc without optimization does the same thing, btw
13:30:26 * SyntaxLaptop is now clean
13:30:37 <RussellOConnor> I'm engaging in premature optimization anyways.  My lists are actually only on the order of 100 Word8's
13:31:53 <Marvin--> SyntaxLaptop: so, wanna explain uniqueness types to me, then?
13:33:43 <Marvin--> (sorry, horrible joke)
13:33:52 <SyntaxLaptop> hm
13:34:02 * SyntaxLaptop has a feeling that one has to understand uniqueness types to get the joke
13:34:11 <Riastradh> No, it's that Clean uses uniqueness types.
13:34:20 <Riastradh> It was, um, a pretty simple-minded joke.
13:34:51 <stepcut> uniqness types are nifty
13:35:05 <Marvin--> SyntaxLaptop: did I tell you that I changed the options field so it's not a comma-separated list? It's just a space-separated list now, looks like any ol' command line
13:35:45 <stepcut> Marvin--: but what if an option has a space in it ?
13:35:49 <Cale> hehehe
13:35:57 <Marvin--> you and your damn spaces
13:36:09 <Marvin--> yeah I'm planning on adding quoting, but I'm putting that down for 0.2
13:36:09 <stepcut> hey! they are perfectly valid!
13:36:27 <stepcut> what about unicode ?
13:36:44 * stepcut is just causing trouble now
13:36:46 <Marvin--> what about it?
13:37:41 <Cale> Wasn't there just a discussion about how dh_install is broken for this very reason?
13:37:53 <shrimpx> are we playing the 'what about <buzzword>?' game?
13:37:56 <SyntaxLaptop> hm. we should definitely get a mailing list, cabal@haskell.org... that would give us the extra benefit of reading secret emails meant for _the_ cabal.
13:38:05 <Marvin--> hah
13:38:14 <Marvin--> ooh, ooh, what about xml?
13:38:19 * Marvin-- wanna play too
13:38:31 <SyntaxLaptop> oh, I think we need a bug tracker before the release. any suggestions? I'm leaning toward sourceforge
13:38:34 <shrimpx> :)
13:38:38 <Riastradh> Ooh, ooh, what about category theoretical adjoint endofunctorial pseudomorphic Cabal options?
13:38:44 <shrimpx> haha
13:38:46 <SyntaxLaptop> Marvin--: don't bring up xml on the libraries list, whatever you do.
13:38:52 <shrimpx> Riastradh: you win
13:38:53 <Marvin--> Riastradh: shouldn't there be a "combinators" somewhere in there?
13:39:01 <Riastradh> Combinators?  How 1920s.
13:39:05 <Marvin--> :-/
13:39:46 <Marvin--> SyntaxLaptop: I prefer not to touch xml even with ten foot poles
13:40:32 <SyntaxLaptop> Marvin--: it is the case that the parser ignores fields it doesn't understand, right?
13:41:33 <Marvin--> SyntaxLaptop: um, no, it protests, should it ignore them?
13:41:39 <Marvin--> hah, this was a great piece of xml
13:42:02 <Marvin--> <opening-tag><string>doc</string></opening-tag><string>Hello, world!</string><closing-tag><string>doc</string></closing-tag>
13:42:03 <SyntaxLaptop> yeah, it should ignore them.
13:42:03 <Marvin--> meta-xml!
13:42:42 <Marvin--> why? ignoring is scary :/
13:43:22 <SyntaxLaptop> Marvin--: it's part of the spec :)
13:43:31 <Marvin--> change the spec! ;-)
13:43:53 <SyntaxLaptop> so that new fields can be added and distribution.simple won't croak on package description files written for other setup files.
13:44:04 <Marvin--> I just feel that silently ignoring fields can lead to obscure bugs
13:44:22 <Marvin--> it should at least warn about unknown fields, but that would require restructuring the code a bit
13:45:14 <SyntaxLaptop> hm. this probably isn't RC.
13:45:20 <Riastradh> It shouldn't silently ignore them; it should voluminously ignore them with incessant pesterings to the user about their audacity in attempting to pass off false data though the Cabal as useful information.
13:45:25 <Marvin--> well, it's a simple change to make it ignore them
13:45:45 <Marvin--> Riastradh: also known as "warn" :)
13:46:04 <Marvin--> eloquently put, though
13:46:15 * Riastradh bows.
13:48:14 <SyntaxLaptop> well, people are allowed to add completely random stuff to the Setup.descrioption file... this is so that other tools can use it for their own nefarious purposes.
13:48:33 * SyntaxLaptop glances suspiciously over at visual studio
13:49:01 <Marvin--> so, let's go down the brainf*** road and declare that anything we can't parse is a comment?
13:49:10 <Marvin--> or what are you saying?
13:49:45 <Marvin--> yay, then I could throw error handling out the window
13:49:54 <Marvin--> s/parse error/empty description/, problem solved!
13:49:57 <Riastradh> You could just have an option for declaring the list of options to ignore.
13:50:09 <Riastradh> ...silently ignore, that is.
13:51:09 <SyntaxLaptop> that's an option
13:52:06 <SyntaxLaptop> Marvin--: you could return a tuple (PackageDescription, (options you dont' know about, their rhs value))
13:52:24 <RussellOConnor> My friend says that every function in C++ should fit on the screen.  I claim that in Haskell, every function should fit on one line.
13:52:43 <Marvin--> SyntaxLaptop: that's what I was thinking, but in order for that not to tremendously uglyify the code, I'll have to restructure it
13:52:44 <SyntaxLaptop> heh
13:53:01 <Marvin--> and either way it's not something I want to do the wee hours before a release
13:53:17 <SyntaxLaptop> (16:45:15) SyntaxLaptop: hm. this probably isn't RC.
13:53:26 <Marvin--> right, so we'll leave it until later
13:53:51 * Marvin-- update the todo
14:00:46 * Marvin-- watches Rainmaker and tries the damn flies away from his cognac
14:04:34 <SyntaxLaptop> Marvin--: do tags in version names allow nubmers?
14:05:58 <Marvin--> hmm, no, munch1 isAlpha
14:06:16 <Marvin--> maybe that should be munch1 isAlphaNum
14:06:40 <SyntaxLaptop> probably
14:08:21 <Marvin--> changed
14:08:25 <Marvin--> I have a bunch of stuff to record now
14:08:40 <SyntaxLaptop> ok
14:09:12 <Marvin--> well, mostly stuff in the TODO :)
14:09:47 <SyntaxLaptop> also, what's allowed in free text fields? :)
14:12:18 <Marvin--> anything
14:13:21 <Marvin--> splitStanzas doesn't touch anything after the colon (well, except whitespace), and the free text fields just use that string as-is
14:13:35 <Marvin--> parseBasicStanza pkg (lineNo, "copyright", val) = return pkg{copyright=val}
14:14:19 <SyntaxLaptop> so they could have
14:14:26 <SyntaxLaptop> copyright: foo\n  bar asdf asd
14:15:04 <Marvin--> yep
14:23:25 <SyntaxLaptop> so for the next versino fo the parser, we should make it output its spec ;)
14:25:00 <Marvin--> ?
14:26:36 <Lemmih> Hmm wxHaskell doesn't work very well with ghci /-:
14:35:10 <Marvin--> SyntaxLaptop: sent you some patches
14:40:53 <SyntaxLaptop> coooooo
14:41:50 <Marvin--> er, mostly trivial stuff
14:49:43 <SyntaxLaptop> what's the syntax for the executable field? i'm not sure I totally grok the parsers
14:49:49 <SyntaxLaptop> is it free text again?
14:50:52 <Marvin--> yeah, it's free text, you can have any old file name you want
14:51:00 <Marvin--> not that it's always a good idea
15:06:59 <RussellOConnor> Hmmm [a]->[a] can behave like a linked list with a tail pointer.
15:07:37 <stepcut> RussellOConnor: ok...
15:09:01 <RussellOConnor> I beleive I can take myList::[a]->[a]  do a length (myList []), and then continute to use myList elsewhere, and still have constant time append.
15:09:12 <RussellOConnor> It's amazing.
15:15:12 <Marvin--> SyntaxLaptop: so, where are we standing?
15:15:28 * SyntaxLaptop shakes head
15:15:36 <SyntaxLaptop> Distribution/Version.hs:212: Variable not in scope: `isAlphaNum'
15:15:41 <Marvin--> gah
15:15:42 <Marvin--> I suck
15:15:48 <SyntaxLaptop> :P
15:15:55 <Marvin--> that's what you get for all those stupid named imports
15:16:16 <SyntaxLaptop> I just updated the documentation with a bunch of field names / descriptions... still have a little work to do there.
15:16:43 <SyntaxLaptop> will probably start a bug tracking system before releasing
15:16:51 <SyntaxLaptop> I want bugzilla; that's the one I'm most familiar with.
15:17:12 <Marvin--> ugh, yet another site I'll have to register a stupid account
15:18:02 <Marvin--> the more accounts I have to register just to do something simple, the more I appreciate the simplicity of debbugs
15:22:38 <SyntaxLaptop> bah
15:22:41 <SyntaxLaptop> I gotta run ttyl
15:49:54 <RussellOConnor> oh, maybe what I said won't work.  Two lists have to be created.
16:23:38 <stepcut> I think I figured out a strategy for getting a third party candidate elected in the US
16:24:04 <Smerdyakov> Does it involve lots of Jello?
16:24:41 <stepcut> no, but it does involve the cooperation of the media, or atleast polling companies. So, it's not likely to happen :)
16:26:48 <stepcut> Here is the theory. People sometimes make the claim that a third party will never get elected because you only get one vote. So, for example, a vote for nader is a vote for bush, type mentality prevails
16:27:30 <stepcut> In general, even if you *could* vote for your first, second, and third choice candidates, the winner would still be from the two main parties
16:28:23 <stepcut> However, let's say that there is a candidate who could win in a 'multi-vote' senario. Cleary, the US is not about to switch voting methods.
16:29:45 <stepcut> but, what if the newpapers did polls as if we did have such a system. If the third party candidate could demonstrate a win in the papers, then that might be enough to make people feel like they aren't throwing their vote away, and they would actually vote third party
16:30:34 <RussellOConnor> You guys really need to change your voting system.
16:30:36 <stepcut> of course, the two missing pieces are (1) a candidate that could win (2) the cooperation of the papers
16:31:50 <RussellOConnor> I recommend removing the position of president.
16:33:22 <stepcut> i think if the popular vote is within %5, the two leading candidates should just alternate weeks :)
16:34:37 <RussellOConnor> each week pick a random candidiate with a distribution proprotional to the number of votes taken, and let em be president for that week.
16:35:00 <stepcut> RussellOConnor: yeah, that's even more fair 
16:35:41 <GreyLensman> Pistols at 20 paces is the only way to pick a REAL president in the event of a 5% diff or less situation.
16:36:35 <stepcut> GreyLensman: guess the gun control people would never get elected (cause they wouldn't have a gun to bring )
16:37:59 <edrx> anyone here with a heavy CS backgound? I spent some years away from Haskell, but doing a lot of Category Theory and Type Theory... anyone has a pointer for how Haskell's classes "mean" in a categorical semantics?
16:38:15 * stepcut wishes
16:38:25 <RussellOConnor> Even 3rd party candidates can rule for a while.  No problem voting for them.
16:38:34 <stepcut> RussellOConnor: exactly!
16:38:38 <edrx> s/for how/on what/
16:39:21 <RussellOConnor> edrx: I'm only familiar with Haskell classes as Existential types.
16:39:45 <stepcut> edrx: there are often people here that could talk about that stuff, not sure if any are currently aronud
16:40:49 <Smerdyakov> edrx, why are you interested in that?
16:41:46 <edrx> because I never understood Haskell's classes really well...
16:42:44 <edrx> and also because I developed a way to express some categorical diagrams involving datatypes and it just occurred to me that I could try them on Haskell
16:47:18 <RussellOConnor> (Monad m) => [m a] -> m [a] is the same as (Exist m:*->*. (forall a:*. a -> m a /\ forall a,b:*. m a -> (a -> m b) -> m b)) -> forall a:* . [m a] -> m [a]
16:47:22 <RussellOConnor> Did I get that right?
16:50:04 <RussellOConnor> or (forall m:*->*. (forall a:*. a -> m a /\ forall a,b:*. m a -> (a -> m b) -> m b) -> forall a:* . [m a] -> m [a] if you don't like writing out exists.
16:53:02 <edrx> looks good, and I pasted it to my files of notes... but I can't say right now if it's right, I've been away from the language for a while... does it embody the conditions that monadic maps have to obey?
16:54:08 <RussellOConnor> edrx: Unfortunately I don't know much about catagory theory.  I know some people who hang around here do.  You may have to try asking later.
16:54:47 <RussellOConnor> (Oh, I've also ignored the ``fail'' function inside Haskell's monads.  It's a bit of an anomoly anyways)
16:55:09 <edrx> ok
16:55:30 <Cale> edrx: If you want to know what monads are categorically, that's easy enough to describe. I don't know much about the interpretation of type classes in general though.
16:55:51 <edrx> well, thanks a lot anyway... I'll have fun with your definitions later :)
18:05:54 <RussellOConnor> Does GHC optimize id . f to f?
18:06:05 <RussellOConnor> :)
19:31:21 <bourbaki> hi
19:46:09 <bourbaki> can someone help me constructing a monad?
19:46:37 <Cale> bourbaki: sure
19:47:10 <bourbaki> ok i want to build a monad that constructs a kind of extendable mesh
19:47:15 <bourbaki> mash
19:47:30 <bourbaki> erm sry mesh :) its a bit late
19:47:57 <bourbaki> so i thought to choose the type as    type Mesh a -> [[a]]
19:48:19 <bourbaki> such that the mesh consists of lists of lists of ie 3d points
19:48:42 <bourbaki> the return would look like retrun :: a -> Mesh a
19:49:08 <Cale> perhaps  newtype Mesh a = Mesh [[a]]
19:49:20 <bourbaki> hm why is that?
19:49:39 <Cale> or do you really mean your type is a function type?
19:49:45 <Cale> and if so, what is Mesh?
19:49:52 <bourbaki> oh ok
19:50:16 <bourbaki> and whats the difference between newtype and tyoe?
19:50:44 <bourbaki> ok did you use that to overload my Mesh :)?
19:50:51 <Cale> newtype constructs a new type which is type checked on its own, type just makes synonyms.
19:51:21 <Cale> For example  type String = [Char]
19:52:29 <bourbaki> hm ok
19:52:56 <Cale> But String will still match [a]
19:53:28 <bourbaki> so my return v = [[v]]
19:53:37 <Cale> the other major difference is that newtypes require their type constructors, and so are closer to data declarations than type synonyms.
19:54:14 <bourbaki> i think i will read on that specifically tomorrow again
19:54:42 <Cale> What does the list [[], [], [5], [4,5,6], [], [8,1]] mean as a mesh? :)
19:55:04 <bourbaki> no the idea is that you have a list of 3d points ie
19:55:13 <bourbaki> and then you want to add normals to that mesh
19:55:32 <bourbaki> and i thought that it might be possible to do that in a monad
19:55:56 <Cale> Well, possibly, but you should first work out a good type for the data you want to store :)
19:56:14 <bourbaki> ok thats why i thought to ask you :)
19:56:15 <Cale> You can then add a parameter to the type
19:56:54 <bourbaki> i thought that something like [(String, [a])] would be better maybe
19:57:13 <bourbaki> so that you can give that list a name like "normals" or "points"
19:57:16 <Cale> Maybe what you want are rich vertex/face types
19:57:23 <Cale> for example,
19:57:54 <Cale> data Vertex a = Vertex { location :: Point, label :: a }
19:58:49 <Cale> and then label can be any type depending on what you want to extend the thing with
19:59:20 <bourbaki> hm ok that sounds reasonable
19:59:48 <bourbaki> but then i would label every single element of the mesh
19:59:53 <Cale> could even be a  Maybe a  so that you can leave things unlabelled if that's an option
20:00:07 <bourbaki> i rather would like to label complete lists
20:01:43 <Cale> So, labelling the entire mesh with a single type?
20:01:57 <bourbaki> yes kind of
20:02:24 <bourbaki> simple example
20:03:13 <bourbaki> [("points", [pos1,po2,pos3]),("color", [col1,col2,col3])]
20:04:00 <Cale> This is a very flexible structure, but also one which is quite weak.
20:04:00 <bourbaki> and if you want to add normals now you would have something like
20:04:10 <bourbaki> why is that?
20:04:23 <bourbaki> weak in what sense?
20:04:40 <Cale> Well, it allows gibberish, which if you want to make sure your program has no bugs, you have to check for.
20:05:17 <bourbaki> my idea was that you check that when the monad is applied and retrun something like maybe mesh
20:05:17 <Cale> For example, what to do if the lists given for each label are of different lengths?
20:05:28 <bourbaki> so if the lengths dont fit its just nothing
20:05:57 <Cale> That's okay, but perhaps a data structure where they're forced to be the same length would be better.
20:06:04 <bourbaki> but i need these labels so that you can apply certain functions to just certain aspects of the mesh
20:06:44 <bourbaki> hm ok you are right there cause if you render an indexed mesh that wont work then
20:07:09 <bourbaki> but that kind of thing could be done in the function you bind
20:07:22 <Cale> What sort of work would bind do?
20:07:47 <bourbaki> the bind of the monad would just add the new list to the existing one
20:07:58 <Cale> hmm...
20:08:22 <bourbaki> that is the second thing a -> Mesh b
20:08:28 <Cale> It's supposed to take each thing in the container, and expand a new container given by the function into that thing's place.
20:08:59 <Cale> Which seems neat if you're doing adaptive mesh type stuff.
20:09:14 <Cale> but you have to work out the mechanics of it carefully :)
20:09:23 <bourbaki> yes
20:09:32 <bourbaki> well you add meshes
20:09:46 <bourbaki> in the above case you would also have a nromal mesh so to say
20:10:08 <bourbaki> [("normal"), [n1,n2,n3)]
20:10:24 <bourbaki> dang :)
20:10:36 <bourbaki> [("normal", [n1,n2,n3])]
20:10:58 <Cale> hmm...
20:11:08 <Cale> and these would be the normals at each vertex?
20:11:14 <bourbaki> now that i think about it isnt that just the normal list monad so far?
20:11:18 <bourbaki> yes
20:11:35 <Cale> well, it might be the normal list monad depending on how you work it
20:11:50 <Cale> If you want bind to smoothly attach edges and such
20:11:57 <Cale> then I doubt it will be
20:12:15 <bourbaki> nope nothing like that but
20:12:34 <bourbaki> i thought that i would like to have translations and animations and such in the same monad
20:12:50 <Cale> hmm...
20:13:01 <Cale> Well, have you read my article?
20:13:16 <bourbaki> your article ?
20:13:18 <Cale> MonadsAsContainers on the wiki -- it might give some ideas.
20:13:31 <bourbaki> nope give me the url plz
20:13:57 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
20:14:07 <bourbaki> my idea is to use that kind of stuff to do a render graph
20:14:32 <bourbaki> you traverse the render tree and constantly bind new monads
20:15:44 <bourbaki> and do animations and scales and such also in the same monad
20:16:25 <bourbaki> i think that something like that would be quite interesting for a simple 3d engine
20:16:51 <bourbaki> cause you can construct your renderpipeline in a monadic way
20:18:16 <Cale> I think you might just use the list monad, together with the right structures contained in the list.
20:18:31 <bourbaki> well the second function then would look like
20:18:33 <Cale> But it depends on how much structure you need.
20:19:32 <bourbaki> \x -> [x,some predifined list]
20:20:16 <bourbaki> and if you want to scale a specific list you would write another function
20:20:46 <Cale> I was thinking something like  [some list of structures in the scene] >>= some transform on them = [some new list of structures in the scene]
20:20:58 <bourbaki> yes
20:21:19 <bourbaki> but the problem is i need to be able to work on a flexible data format
20:21:28 <Cale> where each element of the first list expands into 0 or more structures in the new list - they can't interact
20:21:37 <bourbaki> cause in a good engine you dont have a fixed vertex
20:21:44 <Cale> well, list bind doesn't care :)
20:22:11 <bourbaki> sec wait
20:22:26 <bourbaki> cant i have more then one monad over the same thing?
20:22:45 <bourbaki> then i could have one bind that adds new stuff and another that transforms
20:23:04 <Cale> Well, not for the exact same datatype
20:23:30 <bourbaki> ah yes we had that already
20:23:59 <bourbaki> hm i think i will have to put some more thought into that
20:24:25 <bourbaki> the problem is that i also want to be able to do OpenGL statechanges with that monad and stuff
20:25:11 <Cale> and have a read through my article, let me know what you think of it :)
20:25:36 <bourbaki> i have scanned it but its 5.30h here already
20:25:39 <Cale> :)
20:25:44 <bourbaki> i will tell you tomorrow ok?
20:25:46 <Cale> sure
20:25:54 <bourbaki> where are you from if i may ask?
20:26:29 <Cale> Ontario, Canada
20:26:39 <bourbaki> ah i was told
20:26:49 <bourbaki> have you had a look at that rhydeheart book?
20:27:01 <Cale> not extensively
20:27:38 <bourbaki> i started to programm carcassonne in haskell do you know that game?
20:27:48 <Cale> yeah
20:27:52 <Cale> I've played it
20:27:56 <Cale> just once or twice
20:28:06 <Cale> Seems like a neat game
20:28:16 <bourbaki> i think it will be quite interesting to write some artificial player for it
20:31:44 <bourbaki> anyway thank you i need to go to bed cant keep my eyes open anymore :)
20:31:58 <Cale> okay :)
20:32:15 <bourbaki> oh one last thing
20:32:33 <bourbaki> is there anything you can load jpegs with for haskell?
20:32:44 <Cale> actually, yes there is
20:32:52 <Cale> but it's not very public :)
20:33:02 <Cale> well, that's my fault
20:33:07 <bourbaki> heh :)
20:33:08 <Cale> I should put it somewhere
20:33:24 <bourbaki> cool cause i have all the tiles for the game as jpegs :)
20:33:32 <Cale> http://vx.hn.org/haskefl/Imlib2.hs
20:33:48 <bourbaki> then i can put them on quads and render them with opengl
20:34:02 <Cale> it's not quite finished, but it's a mostly complete low-level binding to Imlib 2
20:34:22 <bourbaki> can i use that in windoze?
20:34:30 <Cale> oh... hmm...
20:34:49 <Cale> not sure if there's a windows port of that library
20:35:12 <Cale> The other option would be to use something like wxWidgets or GTK
20:35:12 <bourbaki> dang :(
20:35:24 <bourbaki> thats quite an overhead
20:35:31 <Cale> true
20:35:40 <bourbaki> i think ill convert it to some other more simple format
20:35:43 <Cale> you could write your own binding to a graphics library
20:35:54 <bourbaki> and then write some loader in haskell on my own
20:36:04 <Cale> it's not that hard, especially if you only need a few functions
20:36:19 <Cale> the FFI is quite nice, I find
20:36:30 <bourbaki> hm i havent had a look at that yet
20:37:20 <Cale> as you can see in that file, the bindings for most things were 2 lines
20:37:32 <bourbaki> yep
20:37:49 <bourbaki> but i dont know any good lib in windoze anyway :)
20:38:01 <bourbaki> so i will write my own routines in haskell
20:41:05 <bourbaki> night ill read your link tomorrow
20:41:11 <Cale> 'night
21:02:24 <stepcut> is their a wiki<->palm gateway?
21:03:13 <Cale> nope, it's a possessive pronoun :)
21:03:47 <Cale> and, I'm not sure :)
22:34:34 <dons> thebug: you can email me if you have queries. easier to sync australian and us (?) time that way :)
22:34:50 <Smerdyakov> dons is the most wanted man alive.
22:35:25 <dons> lots of people like ghc and mips :p
22:35:44 <clausen> Smerdyakov: ?!
22:36:26 * Smerdyakov grabs clausen's shoulders, shakes him vigorously, and screams into his face.
23:18:56 <thebug> dons: uh yeah :)
23:20:20 <thebug> dons: I'll try to put together some sort of coherent archive of stuff I've dug up
23:29:18 <dons> ok. cool.
23:30:35 <thebug> yes, EST/EDT to whatever TZ you're in in australia is a bit of a time difference :)
23:31:57 <thebug> do you have any more details of what exactly you're looking for? I can get many many specs on instructions and architecture for mips, or is it specifics on n32/n64 that are more the problem domain?
23:32:18 <thebug> <my guess is ABI docs>
23:42:01 <dons> I just need the 64 bit instructions. that would probably do it 
23:42:42 <dons> then, to do, say, ghci, we'd need linker-level stuff. but that's a fair bit more work.
23:43:08 <dons> getting registerisation is the priority atm. haskell goes a lot faster then :)
23:43:31 <thebug> okay, I'll focus on getting a good doc of the 64-bit instructions then
23:43:54 <dons> cool. I'll set up the mips machine i have access to, and see what we can do :)
23:44:09 <thebug> one thing I did find in my digging though was that in n32 -> n64, callee-save and caller-save were reversed (!)
23:44:30 <thebug> I don't remember which one was set up which way, but I found that strange
23:45:35 <dons> yeah. maybe something in there will explain why 32 bit doesn't work too.
23:45:52 <dons> though I'll have another look at that, in light of the working 64 bit compiler
23:46:38 * thebug just about done getting the r5000 indy up and running <slower than r10000 octane yes, but much quieter and less electricity :) >
23:47:00 <thebug> hopefully, it'll work for this 64-bit mayhem
23:47:06 <dons> ok. good. that gives us 3 machines. should be enough to test on :)
23:47:36 <thebug> also, I have an r4000 indigo that's already working fine
23:47:40 <thebug> so 4 machines :)
23:49:23 * thebug trying to remember ... is flex/lex a build dep for ghc?
23:50:22 <dons> nope
23:50:31 <dons> alex, if you're building from cvs
