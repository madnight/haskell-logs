02:04:13 <bourbaki> hi
02:05:50 <kosmikus> hi
02:06:43 <bourbaki> kosmikus where are you from?
02:11:58 <bourbaki> just wonder because you fly to all the cool conferences
02:14:43 <bourbaki> http://www.pcworld.com/news/article/0,aid,116655,00.asp
02:15:01 <kosmikus> I'm from .de, but I lieve in .nl
02:16:03 <kosmikus> where in .de do you live
02:16:12 <kosmikus> oh, s/lieve/live/
02:16:13 <bourbaki> and you are working for a uni? or how can you get all the money for the conferences? or a company
02:16:31 <kosmikus> yes, university of utrecht
02:16:44 <bourbaki> ah cool
02:16:51 <bourbaki> professor?
02:16:58 <kosmikus> well, not sure yet if I get money for all conferences I want to go to
02:17:06 <bourbaki> i thought to go there for a semester
02:17:08 <kosmikus> no, just a phd student ;)
02:17:39 <bourbaki> you have quite some cool theory guys right?
02:17:54 <kosmikus> it's a nice university also for students, if I judge it correctly; I've never been a student here ...
02:18:03 <kosmikus> such as?
02:18:14 <bourbaki> hm well i will get my bachelor first :
02:18:16 <bourbaki> :)
02:18:35 <bourbaki> cant remember names but some papers i have seen where from utrecht
02:18:49 <kosmikus> ^^ I mean, we have good people here, but I'm not sure who to classify as "cool theory guys"
02:19:11 <bourbaki> and my professor said that the universities in the netherlands had some ppl that are quite prominent in the field of logics
02:19:19 <bourbaki> heh
02:19:27 <kosmikus> johan jeuring, eelco visser, doaitse swierstra, daan leijen are all in my group
02:19:42 <bourbaki> what do you do?
02:19:54 <kosmikus> but they're not exactly theory guys
02:20:18 <kosmikus> I'm working on Generic Haskell
02:21:58 <earthy> the cool theory guys in logic are in the CKI department, IIRC
02:22:00 <bourbaki> hm id like to do some stuff in ai later
02:22:07 <bourbaki> cki?
02:22:33 <earthy> CKI. definitely. :) short for cognitieve kunstmatige intelligentie, i.e. cognitive artificial intelligence
02:23:01 <bourbaki> my prof told us something about a special kind of lattice that relates topology to locigs and that was developed at .nl uni
02:23:28 <bourbaki> earthy and where is that group?
02:23:46 <earthy> that group is in Utrecht as well, other department though
02:23:56 <kosmikus> bourbaki: which university are you?
02:24:06 <bourbaki> osnabrueck
02:24:13 <kosmikus> ah
02:24:14 <bourbaki> cognitive science
02:24:38 <earthy> http://www.masters.uu.nl/index.cfm/site/Masters/pageid/19B1BF5F-20ED-5DD2-53DC48B9ACECE35E/objectid/24EC6D95-20ED-5DD2-5319E18C8577CBA2/index.cfm
02:24:46 <earthy> for the master's in cognitive ai
02:25:16 <earthy> dang, that's in dutch. :)
02:25:23 <bourbaki> heh :)
02:26:26 <earthy> http://www.internationalmasters.uu.nl/index.cfm/site/International%20Masters/pageid/6CD6021F-20ED-5DD2-53D5103CC3AEF053/objectid/81156832-20ED-5DD2-537DAE45585C5EAC/index.cfm
02:26:33 <earthy> there we go. ;)
02:26:48 <bourbaki> thanks
02:27:01 <earthy> anyway, it kinda depends on what your interests are, but if you are in cognitive science anyway, this seems like a good match
02:27:47 <bourbaki> eeeeek philosophy :)
02:28:00 <earthy> (owh, and don't be deterred by the september 2005 date, the dutch version states that the master's is in english and starts september 2004)
02:28:48 <bourbaki> well i hope that my uni says that i can do the thing i do for my bachelors thesis in the masters
02:29:51 <bourbaki> earthy what are you doing?
02:30:41 <earthy> I'm in exactly the same office Kosmikus is in. :)
02:30:59 <bourbaki> oh cool :)\
02:31:16 <earthy> somewhat different subject matter though
02:31:35 <bourbaki> what i need is someone who has a talent to write :)
02:31:46 <bourbaki> oh which one?
02:31:48 <earthy> no, what you need is a talent to write. :P
02:31:59 <bourbaki> heh ok or that way :)
02:32:20 <earthy> oh, semantics of programming languages and automated proofsupport for those semantics in compilers
02:32:28 <bourbaki> but i always have been bad at that i can write but i write in a style that noone can understand it :)
02:32:36 <bourbaki> ah
02:32:58 <earthy> oh, that's a matter of editing, and that is a skill that can be acquired
02:33:00 <bourbaki> well could you listen to my idea for a sec and tell me what you think about it as a language semanticist?
02:33:06 <earthy> go ahead
02:33:27 <bourbaki> well i want to write programs with machines in graphs
02:33:43 <bourbaki> like a fsm for example
02:33:58 <earthy> you have a number of fsm's with interconnections?
02:34:27 <earthy> with the fsm's running in parallel, and switching state according to the events that come in over the interconnections?
02:34:28 <bourbaki> yes that is something on the application level
02:34:41 <earthy> go on with your explanantion
02:35:00 <bourbaki> well lets say you want to complete number sequences
02:35:28 <bourbaki> then you could build a fsm that builds computations that do the iteration over such a sequence
02:35:41 <bourbaki> that is the edges are functions
02:36:20 <bourbaki> then i map this thing into a topology that is made of paths in that graph
02:36:57 <bourbaki> then i could pick a starting point in that topology and get all the neighbourhoods of that point
02:37:25 * earthy nods
02:37:59 <bourbaki> and then i take these paths and map them into a category where i can use the monadic laws to crunsh the path to a single function
02:38:08 <bourbaki> and apply that to the numbers
02:38:34 <earthy> why go through the topology?
02:38:52 <bourbaki> we also could go through graph operation
02:38:52 <bourbaki> s
02:38:59 <earthy> why not model it in category theory directly?
02:39:08 <bourbaki> the idea is that you can map stuff like that to other very similar fields
02:39:22 <bourbaki> automation, graphs, topology and categories
02:39:51 <bourbaki> because some operations make a lot of sense in topology
02:40:10 <earthy> I'm hazy on topology though
02:40:19 <bourbaki> then take graphs
02:40:25 * earthy nods
02:40:32 <bourbaki> we map the automaton to a graph
02:40:46 <earthy> well, it is a graph already, right?
02:40:49 <bourbaki> and we use an implementation of a*
02:40:50 <earthy> in a certain sense
02:40:55 <bourbaki> yes
02:41:10 <earthy> a*?
02:41:46 <earthy> (do go on though :))
02:41:51 <bourbaki> thats a kind of search that has a heuristic and considers also the "distance" you already went
02:42:18 <bourbaki> the idea for the heuristic there would be that you try to complete the next number as soon as possible
02:42:44 <earthy> okay, so you have a set of weighted paths on the graph, and you select the one with the lowes weight
02:42:45 <bourbaki> so if the next function gets you closer to the value of the next number its considered better
02:42:58 <bourbaki> its uniform cost
02:43:11 <bourbaki> that is each edge has the value 1
02:43:47 <bourbaki> but you see how mapping the problem to a graph now makes me able to use stuff form graph theory
02:44:01 * earthy nods
02:44:12 <bourbaki> i also could change the semantics that way
02:44:23 <earthy> this can be done directly on the automaton as well though
02:44:46 <earthy> considering the words the automaton accepts and weighting them letter by letter
02:44:54 <earthy> where the letters are representatives for the functions
02:45:24 <earthy> so yeah, interesting idea
02:45:36 <earthy> but what do you expect to gain?
02:46:02 <bourbaki> i hope to gain something in the field of ai
02:46:14 <earthy> (hint: graph transformations may be used for turning non-deterministic automata into determenistic automata, e.g. ;))
02:46:17 <bourbaki> because you can analyze ie the topology of a problem
02:46:52 <earthy> ah, right.
02:47:19 <bourbaki> and its quite cool that you can do some things from topology on programs
02:47:44 <earthy> you want to look into using the mathematical `tools' that have been developed for e.g. topology for the domain of algorithmic problem solving
02:47:54 <bourbaki> yes
02:48:41 <bourbaki> and i want to do that with monads i think
02:50:11 <bourbaki> i should have a look at more lattice theory in logics
02:50:38 <earthy> well, a monad is also called a triple, which is related to a topos, which in turn are related to topological spaces
02:50:55 <bourbaki> yep
02:51:05 <earthy> so the idea isn't too farfetched
02:51:31 <bourbaki> topologically speacking i have an equivalence mapping between all of these things
02:51:39 <bourbaki> nope
02:52:01 <bourbaki> i can construct any  function from a field to each other
02:52:33 <earthy> uhuh
02:53:04 <MakeMyDay> Is there an easy way to check a directory AND it's subdirectories ? 
02:53:06 <bourbaki> well in the case above we have a* for an automation
02:53:11 <bourbaki> automaton
02:53:20 <bourbaki> and for the topology of it
02:54:06 <MakeMyDay> Or do I have to get the list of files in a directory and then open everyone is it is a directory ? 
02:54:23 <bourbaki> that sounds reasonable
02:54:49 <earthy> MMD: that is classically the only way to do it, yes.
02:54:53 <bourbaki> if you had a generic search algo you could to it in that function
02:55:15 <earthy> thing is, a subdirectory is no different from a file with a special bit set `this is a directory'
02:55:27 <earthy> so you have to stat every file in a directory to find the subdirectories.
02:55:52 <MakeMyDay> ok thx gonna try it
02:57:42 <bourbaki> earthy do you do something like that in semantics also?
02:58:52 <earthy> bourbaki: not really
02:59:07 <earthy> you are working within a logic
02:59:15 <earthy> I'm working without the logic, trying to build it
02:59:35 <earthy> and to figure out what reasoning steps are reasonable within it
02:59:49 <bourbaki> oh i see
03:03:15 <earthy> the problem I have is that when specifying a programming language and its semantics you often run into wanting to extend both
03:03:51 <earthy> and usually what seems like a simple extension to the language has huge effects on the specification of its semantics
03:04:02 * bringert thinks that he has a pure-haskell readline with line-editing, history and tab-completion
03:04:14 <bringert> unix + vt100 only for now
03:04:25 <bringert> based on andersca's work from EuroHaskell
03:05:08 <earthy> schweet
03:05:15 <earthy> now to add termcap support... ;P
03:08:43 <bringert> yikes
03:22:20 <MakeMyDay> ok this is irritating
03:22:43 <MakeMyDay> why does "doesDirectoryExist" return an IO(Bool)
03:22:53 <MakeMyDay> how am I supposed to use it in a filter ?
03:26:19 <kosmikus> because if a certain directory exists or not does not only depend on the name of the dir, but also on the state of the world
03:26:33 <kosmikus> you cannot directly use the function in filter, but there is a monadic variant of filter
03:26:38 <kosmikus> @type Control.Monad.filterM
03:26:39 <lambdabot> Control.Monad.filterM :: forall a m.
03:26:39 <lambdabot> 			 (Monad m) =>
03:26:39 <lambdabot> 			 (a -> m Bool) -> [a] -> m [a]
03:26:48 <MakeMyDay> ahhhh
03:56:56 <shapr> good morning #haskell!
03:57:08 <MakeMyDay> morning
03:57:26 <MakeMyDay> and a question to start :) : What should I import inorder to use concatM ?
03:57:36 <MakeMyDay> import Monad no?
03:58:22 <shapr> @index concatM
03:58:22 <lambdabot> bzzt
03:58:33 <shapr> lambdabot hasn't heard of it
03:58:38 <shapr> @index mconcat
03:58:38 <lambdabot> Control.Monad.RWS,Control.Monad.Writer,Data.Monoid
03:59:19 <MakeMyDay> that is wierd. Because some refs on the net have it as concatM
04:00:38 <MakeMyDay> ok so I am importing Control.Monad and it still doesn't find mconcat
04:00:55 <shapr> what about Data.Monoid ?
04:02:16 <MakeMyDay> ow yeah now it find mconcat but it doesn't work..anyway why would mconcat be in Monoid and not in the same lib as filterM ?
04:02:45 <kosmikus> mconcat is probably not what you'd expect a concatM to be
04:03:37 <kosmikus> concatM :: (Monad m) => [m [a]] -> m [a] ?
04:03:37 <MakeMyDay> yeah...
04:03:46 <MakeMyDay> that is what I am looking for
04:04:03 <kosmikus> should be easy to define it in terms of sequence
04:04:29 <kosmikus> @type sequence >>= (return . concat)
04:04:30 <lambdabot> sequence >>= (return . concat) :: forall a.
04:04:30 <lambdabot> 				  (Monad ((->) [[a]])) =>
04:04:30 <lambdabot> 				  [[a]] -> [a]
04:04:47 <kosmikus> hmm
04:05:12 <kosmikus> ah, well
04:05:37 <kosmikus> @type \x -> sequence x >>= (return . concat)
04:05:39 <lambdabot> \\x -> sequence x >>= (return . concat) :: forall m a.
04:05:39 <lambdabot> 					  (Monad m) =>
04:05:39 <lambdabot> 					  [m [a]] -> m [a]
04:05:43 <kosmikus> better
04:20:51 <musasabi> Is there a way to catch pattern match failures in a nice way?
04:22:11 <shapr> I usually put _ -> error "function foo fell through"
04:25:42 <shapr> man, I had some crazy typeclass question yesterday after reading the epigram stuff. I wish I could remember it.
04:26:03 <shapr> Lor: hey, you said that UUAG parsers were cooler than Parsec, you got some demo code for that?
04:26:10 <musasabi> well that should work... and how to match a singleton list? [x] seems to cause problems...
04:26:45 <shapr> is that where people use the irrefutable match stuff? ~[x] or something?
04:27:40 <musasabi> acar [x] = do_stuff x \n acar _ = error "car with invalid arguments"
04:28:03 <musasabi> that works until one tries something like "acar 500".
04:28:21 <shapr> ?
04:28:49 <shapr> I usually write cases for [] (x:xs) and _
04:29:09 <shapr> then the (x:xs) case is the singleton case
04:29:43 <keverets> does "_" ever match then?
04:30:10 <shapr> if I wrote my code correctly, the _ case should *never* be called.
04:30:18 <shapr> in practice...
04:30:55 <shapr> in practice, I see _ calls about once a week to once a month depending on how much Haskell coding time I have :-)
04:31:08 <keverets> are there other arguments?  Otherwise I don't see how, given the first two, the third could ever be called.
04:31:57 <kosmikus> no, in this particular case, _ would never be called
04:32:24 <kosmikus> however, it is a common mistake to add a new alternative to some data type and forget to update all functions that do induction on that data type
04:32:34 <keverets> that makes sense.
04:32:51 <shapr> hei _Codex, wassup?
04:33:01 <shapr> kosmikus: how's the thesis? is there a later draft available?
04:35:15 <shapr> hiya Hatori 
04:35:27 <shapr> looking for Haskell info?
04:36:09 <kosmikus> shapr: the thesis is accepted, but not yet at the printer
04:36:13 <shapr> yay!
04:36:20 * shapr waves the lambda pom-poms
04:36:36 <kosmikus> currently I have a paper to write, and then I will have 3-4 days to merge as many as the comments as possible into the final version
04:37:10 <shapr> that's great! Your heuristic worked!
04:43:17 <MakeMyDay> ok I am a bit confused here. I search a directory tree for all files with the extension .reversedep .I now have a list of the names of those files , but I can't open them because I don't have the directory they are in.
04:44:58 <shapr> actually, I suspect you never search a 'directory tree' you search a directory, and that function calls itself for subdirs
04:45:25 <shapr> so the function should always know where it found a file with that extension, it just needs to add the dir name to the front
04:46:19 <MakeMyDay> hm
04:48:01 <shapr> is there a deb for acroread?
04:49:22 <Hatori> Can anyone tell me how i should go about stating the induction principle for non-negative values of type Int ?  I can explain induction on finite lists, trees, and perhaps also general cases (as opposed to finite).  I can do mathematical induction with my eyes shut but maybe Im missing the point here.  Induction is used to prove a series or recursive event but how does this apply to single Int values?
04:50:47 <keverets> shapr: deb ftp://ftp.nerim.net/debian-marillat/ unstable main
04:51:10 <shapr> thanks
04:54:27 <Igloo> xpdf also exists, though
04:58:04 <keverets> I use xpdf most of the time, but for looking at very large graphs I find that xpdf can only sometimes open them, and when it can it is difficult to zoom in to particular places (and the searching facility is not as good)
04:59:22 <Igloo> Hatori: I'm not sure what you mean if it's not essentially the same as mathematical induction
05:00:12 <shapr> hej Marvin-- 
05:01:19 <shapr> keverets: any other good unofficial aptsources?
05:03:51 <Marvin--> hej hej
05:05:39 <keverets> shapr: there's a big list at www.apt-get.org
05:06:16 <keverets> I also use "deb http://www.fbriere.net/debian/dists/unstable ./" and "deb http://dijkstra.csh.rit.edu/~mdz/debian unstable mythtv"
05:15:48 <MakeMyDay> damn it I can't get along with this IO stuf
05:15:49 <MakeMyDay> f
05:38:11 <neologism> hi
05:38:22 <neologism> can you give me an url where is described why are monads so great?
05:38:26 <neologism> their advantages etc.
05:39:47 <RussellOConnor> You want to know why they are great, as opposed to how to use them?
05:39:55 <shapr> http://www.nomaware.com/monads/html/index.html
05:40:24 <shapr> look at the section "Why should I make the effort to understand monads?"
05:41:45 <neologism> no
05:41:49 <Cale> I always think of monads as just another abstraction of container types.
05:42:19 <neologism> shapr: ok
05:42:21 <neologism> I missed it ;)
05:42:28 <neologism> thnx a lot!
05:42:48 <RussellOConnor> I think of Monads as an abstract way of sequencing.
05:43:09 <RussellOConnor> But I guess MonadPlus is much like a container too.
05:43:26 <shapr> I like the container viewpoint, that seems to be the best one for me.
05:43:35 <neologism> I understand monads (at least a bit)
05:43:41 <neologism> I just want to do some "propaganda"
05:43:44 <neologism> of haskell and monads etc.
05:43:47 <neologism> among my friends
05:44:32 <RussellOConnor> I haven't done much programming in Haskell, but the more I do, and the more I understand how to use Monads, the more I like them.
05:45:01 <RussellOConnor> I got to get rid of my big staircase of case analysis on Maybe Foo.
05:45:28 <Marvin--> haha
05:46:13 <shapr> neologism: I think the best 'propaganda' would be a modular interpreters demonstration via Monad Transformers.
05:46:53 <neologism> huh?
05:46:56 <neologism> whats that?
05:50:08 <rubix> ksirc marche moins bien que xchat, maintenant je le sais
05:50:36 <rubix> ooops sorry wrong channel
05:51:18 <shapr> mais, ERC marche mieux!
05:52:07 <rubix> c'est quoi ERC ?
05:52:25 <rubix> un client IRC en haskell ? :)
05:52:31 <shapr> non, en elisp...
05:52:40 <shapr> mais hircules est en haskell
05:53:03 <shapr> juhp ecris hircules.
05:53:12 <rubix> pour l'instant j'ai la flemme de changer ; je reste à xchat
05:54:22 <shapr> je comprends :-)
05:55:58 <RussellOConnor> I can't believe there is no Consumer Monad.
05:57:17 <bourbaki> consumer monad?
05:58:08 <RussellOConnor> Something where you squence a bunch or reads
05:58:34 <RussellOConnor> Probably would have an EndOfStream : m Bool as well
05:58:57 <shapr> ?
05:59:02 <shapr> hiya dnm, wassup?
05:59:10 <dnm> Not much.
05:59:12 <dnm> You?
05:59:34 <shapr> epigram is the latest nifty thing I've been playing with
06:00:23 <shapr> dependently typed languages
06:01:35 <bourbaki> shapr got a paper for that?
06:02:46 <earthy> bourbaki: search for jfp volume 14 part 1, jan. 2004
06:03:19 <bourbaki> is that a free journal?
06:04:01 <dnm> shapr: Heh.
06:04:19 <dnm> shapr: I've been playing around with more late-bound actor concepts.
06:04:20 <earthy> title: `The view from the left.', pp 69-112
06:04:50 <bourbaki> earthy is it free?
06:05:01 <kosmikus> bourbaki: no
06:05:04 <earthy> the journal? no.
06:05:11 <earthy> but, look at http://www.dur.ac.uk/CARG/epigram/
06:06:29 <bourbaki> thanks
06:06:58 <earthy> http://www.dur.ac.uk/c.t.mcbride/view.ps is the paper, btw.
06:17:51 <bourbaki> what was the name of that one paper that described cata, ana and hylo morphisms?
06:20:34 <shapr> meijer et al, bananas, barbed wire, and some other stuff
06:20:43 <bourbaki> ah right
06:21:20 <shapr> lenses
06:30:27 <bourbaki> thank you
06:31:18 <earthy> programming with bananas, lensens and barbed wire
06:31:20 <earthy> IIRc
06:32:11 <earthy> bananas, lensens, *envelopes* and barbed wire, even. ;)
06:32:27 <shapr> aha
06:32:53 <earthy> and, ofcourse: Bananas in Space: Extending Squiggol to Function-Space Types.
06:33:02 <earthy> http://www.cse.ogi.edu/~erik/Personal/classic.htm
06:33:07 <shapr> I found a paper about dealing with large bananas
06:33:25 <earthy> peel 'm open and eat 'm up? :P
06:36:34 <kosmikus> shapr: that's a ralf laemmel paper and something like an early predecessor of "scrap your boilerplate"
06:37:07 <shapr> ah, that's good to know
06:37:23 <shapr> it's been sitting in the root dir of my research papers while I try to figure out where to put it
06:52:25 <shapr> I just had a neat thought, a unit test blog
06:53:00 <shapr> I discovered the value of a developer's diary when I was working in Finland, I wonder if a unit test diary would be a more condensed version of that.
07:10:09 <bourbaki> hi
07:11:28 <shapr> y0
08:14:18 <Lemmih> nhc1.16 is broken?
08:14:24 <MakeMyPantiesWet> how can I do "string"++"\"++"string" ?
08:14:28 <MakeMyPantiesWet> oooppa
08:14:31 <MakeMyPantiesWet> my nick
08:14:32 <MakeMyPantiesWet> hehe
08:14:37 <Marvin--> o.O
08:14:40 <MMD> :D
08:14:49 <MMD> haha
08:15:09 <MMD> back to Haskell now *cough*
08:15:14 <MMD> so why doesn't > filterTupelDep			:: (String,[String]) -> (String,[String])
08:15:14 <MMD> > filterTupelDep (dir,s)   		= (dir,filterStringDep s)
08:15:19 <MMD> damn sorry
08:15:43 <MMD> why doesn't a++"\"++b work?
08:15:56 <RussellOConnor> "\\"
08:16:14 <RussellOConnor> Does the \ need to be escaped
08:16:27 <MMD> if I do "\\" it gives me a\\b 
08:16:40 <MMD> I jsut need to add the \ because it is a directory name
08:16:44 <Marvin--> yes and no
08:16:55 <Marvin--> the show function for strings will escape backslashes
08:16:58 <Smerdyakov> Which is what you want, if you are just looking at the string that is the result of an expression.
08:17:05 <Marvin--> try  putStrLn "foo\\bar"
08:17:25 <MMD> ahhh
08:18:06 <MMD> but if I try to open a file at "foo\\bar" will it check at "foo\bar" ?
08:18:47 <Lemmih> Has anyone successfully compiled nhc 1.16?
08:19:09 <RussellOConnor> MMD: I believe so
08:19:12 <Igloo> Yes
08:19:24 <Igloo> Well, with patches
08:19:34 <Smerdyakov> MMD, the double-slash is only for inputing and outputing the strings at a meta-level.
08:19:44 <Smerdyakov> MMD, you really always have a single slash there.
08:19:50 <shapr> speaking of crazy string escapes, beware the use of a bunch of numeric literals in a row, it can sometimes require a \& to separate stuff
08:20:41 <Lemmih> Igloo: I get tons of errors with gcc 3.3.3 and ghc 6.2.1
08:22:57 <Igloo> Lemmih: You're going to have to be rather more specific if you want help, but first, have you got all the patches from the download page applied?
08:24:44 <shapr> what do I need to do get ssh -X working in debian?
08:25:04 <Lemmih> Only the typesyn... I'm gonna try to install it manually now. Was using portage before.
08:25:10 <neologism> shapr: startx -listen_tcp
08:25:16 <neologism> xhost that machine you ssh -X to
08:25:21 <neologism> and ssh -X to that machine ;)
08:25:25 <neologism> thats all
08:25:35 <norpan> xhost? no no no!
08:25:44 <neologism> I do this
08:25:46 <neologism> and it works
08:25:56 <norpan> you should not need xhost when doing -X
08:25:56 <neologism> (not on debian thought)
08:26:02 <norpan> xhost is evil evil evil
08:26:23 <neologism> why?
08:26:27 <Igloo> You need xauth install
08:26:28 <Igloo> ed
08:26:35 <Igloo> Which I think is in xbase-clients or somesuch
08:26:40 <norpan> because xhost is host based, not user based
08:26:50 <neologism> norpan: hm..
08:26:55 <TheHunter> i think you have to edit /etc/sshd.conf
08:27:19 <norpan> you can make xhost use kerberos or the likes, but i never got it to work
08:27:26 <norpan> ssh -X should work regardless of xhost
08:27:39 <Igloo> Ah, yes, you'll also need "X11Forwarding yes" in /etc/sshd.conf
08:27:51 <shapr> ah
08:28:08 <Igloo> (or possibly just the lack of a no)
08:28:36 <RussellOConnor> Interesting. `show string' is not the same as `id string'.
08:29:04 <norpan> of course not
08:29:24 <norpan> just like show integer is not the same as id integer :)
08:29:44 <RussellOConnor> well, show integer and id integer don't even have the same type
08:30:28 <RussellOConnor> iterate show "foo\\bar"
08:30:34 <norpan> just like (+) is not the same as (*) then :)
08:30:54 <shapr> spiffy, that fixed it.
08:31:28 <norpan> just because two functions have the same type, doesn't mean they are the same function
08:31:37 <RussellOConnor> true
08:31:57 <bringert> well, kind of depends on the type system
08:31:58 <RussellOConnor> But one might expect show to be the identity function on strings.
08:32:05 <norpan> not at all
08:32:32 <norpan> show displays the value as you would write it as a haskell expression
08:33:11 <bringert> wouldn't it be be possible to define a (somewhat silly) type system where functions only have the same type if they are the same function
08:33:50 <norpan> if the only type you have is () and you disallow partial functions, then yes
08:33:54 <bringert> :)
08:34:02 <earthy> bringert: that would not be very useful
08:34:22 <earthy> not impossible, though
08:34:24 <earthy> just not very useful
08:34:36 <bringert> earthy: that sounds highly reasonable
08:34:40 <norpan> just ditch the type system and use the definition of the function as the type :)
08:35:10 <earthy> problem is that such a type system would have to assign different types to different partial results in the evaluation of such a function
08:35:33 <earthy> so you don't get type stability, so typing suddenly loses virtually all its usefulness
08:37:00 <bringert> I never said it would be useful :)
08:37:49 <RussellOConnor> I suggest having only the empty type, and allowing partial functions. :-)
08:38:13 <RussellOConnor> oh
08:38:24 <RussellOConnor> I guess haskell has no empty type.
08:38:24 <earthy> that will not fulfill the original question
08:39:06 <RussellOConnor> Sure it would, every function of a given type would be the same.
08:39:18 <RussellOConnor> (at least extensionally equivalent)
08:39:31 <Smerdyakov> data Empty = Empty Empty is pretty empty!
08:39:45 <kosmikus> data Empty = Empty !Empty is emptier
08:40:01 * earthy laughs
08:40:02 <kosmikus> GHC allows data Empty = 
08:40:05 <RussellOConnor> (error "boo") :: Empty
08:40:26 <bringert> RussellOConnor: if all you have is the empty type, you can't type any functions
08:40:39 <kosmikus> you cannot get around "undefined", yes
08:40:51 <RussellOConnor> Sure you can:  (\x::Empty -> x) :: Empty -> Empty
08:41:17 <bringert> but then you don't only have the empty type, you also have function types
08:41:22 * bringert is being silly
08:41:26 * earthy agrees with bringert ;)
08:41:31 <RussellOConnor> oh right.
08:41:47 <RussellOConnor> Same applies to () being the only type though.
08:41:53 <bringert> yeah
08:41:54 <Igloo> kos: Err, without the = I think
08:42:06 <kosmikus> oh, could be
08:42:33 <Igloo> Oh, was that on Syn's extension list? It probably should be
08:43:32 <bringert> Igloo: don't think it is
08:44:02 <RussellOConnor> (\x::Empty -> case x of {}) :: Empty -> Integer 
08:44:34 <RussellOConnor> Hmm
08:44:41 <bringert> pattern match failure is just another bottom, right?
08:44:44 <RussellOConnor> is that just a failure to patterm match.
08:44:56 <RussellOConnor> But my case analysis was ment to be total.
08:45:36 <bringert> hmm, if the type you match on is empty, there can't really be a pattern match failure
08:46:25 <RussellOConnor> It doesn't really matter too much, the function cannot be executed. :-)
08:46:48 <RussellOConnor> So it will never fail, or succeed.
08:51:04 <bringert> what if you call it on bottom?
08:51:56 <RussellOConnor> Same thing that happens whenever you pattern match on bottom.
08:53:36 <bringert> hmm, but if there are no cases, it doesn't need to evaluate the argument to know that the pattern matching should fail
08:53:53 <bringert> i.e. it could be a pattern matching error
08:55:17 <bringert> not that it matters, one bottom is a good as another
08:55:47 <bringert> hmm, that could be misinterpreted if taken out of context
09:00:41 <monotonom> Suppose you have f (x:xs) = ...  and you evaluate f bottom
09:01:08 <monotonom> It will hang. The pattern matching forces the argument.
09:02:07 <monotonom> Suppose you have f (x:_) = ....  and you evalutate f (1:bottom). It will work.
09:02:15 <bringert> right
09:02:46 <bringert> then if an empty 'case' was allowed in haskell, it would not force its argument
09:03:03 <monotonom> Finally, suppose you have f ~(_:_) = ...  and you evaluate f bottom.  It will work.  The ~ says "don't force the argument just yet".
09:03:55 <monotonom> Lastly, f _ = ...  will work for anything.
09:04:44 <bringert> which, for an empty input type would equivalent to not having any pattern matching at all
09:05:15 <bringert> eh, no
09:06:01 <bringert> sorry, no patterns would give a pattern matching error
09:10:44 <norpan> normally, for the purpose of equvialence, all errors are equal to bottom
09:17:11 <bringert> time to go
09:38:37 <MMD> I think I am getting the hang of IO()
11:04:05 <Igloo> Hi Isaac
11:04:48 <SyntaxNinja> hihi Igloo
11:17:37 <Igloo> SyntaxNinja: I think GHC's (and others?) ability to say "data Foo" without any constructors should also be an Extension, BTW
11:24:32 <RussellOConnor> Igloo, should cases analysis also be allowed to have 0 alternatives?
11:24:49 <Igloo> RussellOConnor: Do you mean should they or are they?
11:25:11 <RussellOConnor> The Haskell 98 Report says case statements must have at least 1 alternative.
11:25:36 <Igloo> Yes, so they aren't
11:25:47 <Igloo> And I can't think why it would ever be useful
11:30:01 <RussellOConnor> If you want to do exhastive case analysis on a type with no constructors.
11:30:35 <Igloo> Why would you want to do that?
11:30:42 <Igloo> (you could do it with _ anyway)
11:30:42 <RussellOConnor> There should be a function of type forall a . Foo -> a  if Foo has no constructors.
11:30:57 <Igloo> undefined
11:31:03 <RussellOConnor> No, if you use _ -> body, you need to provide a body
11:31:26 <ksandstr> so what good is an exhaustive case analysis of a type with no constructors?
11:31:33 <Igloo> OK; but still, undefined. And when would you want to do it?
11:31:59 <RussellOConnor> Use it to make a function of type forall a . Foo -> a
11:33:28 <RussellOConnor> How do you guys think that a type with no constructor would be used?
11:33:41 <Smerdyakov> As the return type of a continuation.
11:33:51 <Igloo> I've wanted them when they are a C type I just pass to FFI functions
11:34:03 <Igloo> Or rather, a Ptr Foo
11:35:20 <RussellOConnor> Return type for a continuation might be good, although running the continuation would be somewhat difficult.
11:35:59 <RussellOConnor> I'm not certain that an empty data type would be good in place for a FFI type that actually has data.
11:36:06 <RussellOConnor> But I don't know much about FFI
11:36:48 <Smerdyakov> An abstract type is better than a void type for that.
11:36:59 <Smerdyakov> Does Haskell support abstract types?
11:37:12 <Igloo> What do you mean yb an abstract type?
11:37:44 <Smerdyakov> A type whose definition is only available to a subset of the code.
11:37:52 <Igloo> It does
11:38:05 <SyntaxNinja> hm. is the boxed vs unboxed distinction just in the libraries?  is # supposed to be allowed in symbol names?
11:38:07 <Igloo> But in this case none of the Haskell code knows what the type is
11:38:17 <ksandstr> um. from an amateur's pov, a type without constructors wouldn't see much use outside type declarations. also, just "case x of" without alternatives sounds... weird. don't we already have () besides?
11:38:34 <Igloo> An example that comes to mind is the WINDOW type in curses
11:38:39 <Smerdyakov> () has one value. Void has no values.
11:39:05 <Smerdyakov> Igloo, in the SML/NJ NLFFI, such types have concrete ML equivalents.
11:39:06 <Igloo> I pass "Ptr Window"s around but there are no sensible constructors I can give Window
11:39:56 <Igloo> Smer: But there would be no point going to the effort of making one. It's really an abstract C type
11:40:24 <Igloo> Syn: I don't understand. GHC allows # in function names if -fglasgow-exts is given
11:40:45 <ksandstr> Smerdyakov: does this mean that you can't actually evaluate a Void, being that it has no values?
11:41:18 <Smerdyakov> ksandstr, what do you mean by "evaluate a Void"?
11:42:24 <ksandstr> Smerdyakov: um. i guess i mean, how would you pass anything to a function of type forall a. Foo -> a?
11:42:46 <Smerdyakov> ksandstr, you would call it with something of type Foo.
11:43:02 <ksandstr> Smerdyakov: ... and if Foo has no constructors?
11:43:22 <Smerdyakov> ksandstr, then you pass a Foo that was passed to you.
11:43:23 <RussellOConnor> You can call the function if you have a x::Foo introduced by a lambda.
11:43:29 <RussellOConnor> For example.
11:43:44 <edwinb> Yeah, but then you couldn't call *that* function!
11:43:59 <edwinb> You need to make a canonical value eventually...
11:44:18 <RussellOConnor> But you could pass that function in somewhere else.
11:44:20 * edwinb should probably read up to find out what you're arguing about first, of course. *ahem*
11:44:30 <edwinb> and when could it ever get run?
11:44:35 <RussellOConnor> never
11:44:47 <RussellOConnor> (unless you count _|_)
11:44:51 <edwinb> indeed
11:45:07 <edwinb> Which you probably should...
11:45:22 <RussellOConnor> In dependent type theory, these functions are used all the time to provide proof of properties of your programs
11:45:23 <ksandstr> i'm missing something here. is this just something that exists in Haskell for consistency's sake? some sort of weird-yet-consistent status for constructorless types?
11:45:37 <edwinb> The empty type is used in DTT to eliminate impossible cases, that sort of thing.
11:45:53 <RussellOConnor> It's not actually in haskell.  I think we are exploring the consequences of such a thing here.
11:45:55 <edwinb> I can't see a use for it in Haskell though, basically because Haskell has _|_
11:46:50 <RussellOConnor> _|_ really messes up the empty type, by making it non-empty. :-)
11:47:08 <RussellOConnor> (error "make me a Foo")::Foo
11:47:37 <Igloo> RussellOConnor: I think the rest of us are waiting for you to tell us why we might want it in Haskell. At least, I am  :-)
11:47:51 <edwinb> Yes, I was hoping that I'd find that out by reading up, but I didn't ;)
11:47:56 <ksandstr> ah, i see. this is a feature of some sort of theoretical mumbo jumbo (sorry, i haven't much of a formal cs education). and i was struggling to understand it from an engineering perspective...
11:48:16 <RussellOConnor> Oh, I don't know why we want an empty data type in Haskell.  I just think we should have empty case alternatives if we do.
11:48:39 <Igloo> I just told you why, though
11:48:53 <Igloo> Type safety of abstract C types
11:48:59 <Smerdyakov> Igloo, I strongly object to using Void when you really mean abstract type.
11:49:12 <edwinb> Abstract C types aren't empty...
11:49:16 <RussellOConnor> My gut says they won't work for that.
11:49:59 <RussellOConnor> Because there ought to be a function of type forall. a Empty -> a, while you won't want this for abstract C types.
11:50:12 <pimpbot5000> does anyone know of a source of info for finding out how to bootstrap a compiler?  i'm not interested in writing a bootstrapping compiler myself, just was interested in seeing a bit how it's done
11:50:44 <Igloo> edwinb: But if all I do is pass Ptr Foos to FFI functions and have Ptr Foos returned by FFI functions then all I need is a name for the type, which means I just need a name for a type with no constructors
11:50:45 <edwinb> pimpbot5000: The Red Dragon book has a bit on it (Aho, Sethi and Ullman, 1986)
11:50:49 <ksandstr> pimpbot5000: the dragon book has a pretty good explanation (and it's a good book besides)
11:50:59 <pimpbot5000> true, i was looking at that on half.com
11:51:23 <edwinb> Igloo: Yes, but it's not an empty type. By all means have an abstract type that you can't make values for directly, but don't treat it like the empty type, because it isn't.
11:51:27 <pimpbot5000> although my cheapness got in the way, and i figured there might be an online source
11:51:28 <pimpbot5000> hehe
11:51:40 <Igloo> edwinb: I don't understand
11:51:54 <Smerdyakov> I think that dragon book is out of date.
11:51:54 <ksandstr> pimpbot5000: shouldn't be that hard to find on the net, given the amount of course notes etc. googling usually turns up...
11:52:08 <edwinb> Okay. If you have an abstract blob of data, it's an abstract blob of data that lives somewhere else.
11:52:09 <Igloo> I'm really giving a reason why "data Foo" is useful. If you mean something else by empty type I'm not defending that
11:52:12 <edwinb> If you have an empty type, you have nothing.
11:52:18 <edwinb> The concepts are very different...
11:52:34 <edwinb> Ultimately, this is theoretical mumbo jumbo, to be fair.
11:52:41 <Igloo> AIUI ROC is saying that if we have "data Foo" we should have "case foo of {}"
11:52:48 <RussellOConnor> For example there is a function of type (Either () Empty) -> (), but no function (Either () Empty) -> Empty.
11:52:55 <Igloo> Whereas I can see a use for the first but not the second
11:53:09 <edwinb> So when you say "data Foo" do you mean an abstract type whose values are unknown, or an empty type?
11:53:13 <edwinb> I may have missed that bit...
11:53:32 <edwinb> I think, in that case, we are agreeing!
11:53:40 <Igloo> I mean what you get when you write "data Foo" in a GHC source file
11:53:42 <RussellOConnor> But you would want a function operating appropriately on (Either () AbstractCThing).
11:53:55 <Igloo> You can call it what you like  :-)
11:54:04 <edwinb> I think I'd want to write "data False = " if I meant the empty type.
11:54:09 <edwinb> Like (IIRC) in Cayenne.
11:54:25 <SyntaxNinja> Igloo: access to the unboxed types is not a language extension proper, correct? it's a library extension.
11:54:27 <Igloo> RussellOConnor: But I can't make an AbstractCThing in the Left case. I'm not sure I see your point
11:54:41 <RussellOConnor> (Either a False) is natrually isomorphic to a.
11:54:42 <Igloo> RussellOConnor: There is a function of that type, it just uses error in the Left branch
11:54:58 <RussellOConnor> (Either a AbstractCThing) is not isomorphic to a.
11:55:14 <Igloo> Syn: Err, to be able to talk about the I# constructor (for example) you'll need extensions enabled
11:55:39 <Igloo> But they only represent unboxed values by conventions, I believe
11:56:23 <RussellOConnor> okay, there is a total function of type (Either () Empty) -> (), but no total function (Either () Empty) -> Empty.
11:56:53 <Igloo> That's true for   Either () AbstractHaskellType -> AbstractHaskellType too
12:00:46 <RussellOConnor> But there is no total function of type (Either () AbstractCThing) -> ().
12:02:15 <Igloo> Yes there is
12:02:20 <edwinb> doesn't foo _ = () work?
12:02:28 <Igloo> Exactly
12:02:45 <RussellOConnor> crap
12:02:53 <RussellOConnor> Hmmm
12:03:00 <RussellOConnor> That was pretty dumb of me.
12:03:48 <RussellOConnor> So what do I want to say.  There is a total function of type forall a. (Either a Empty) -> a, but no total function of type forall a. (Either a AbstractCThing) -> a.
12:04:43 <RussellOConnor> I must be able to find a better example of how AbstractCThing and Empty are different.
12:05:17 <Igloo> A function of type   Either a Anything -> a   must return bottom if given Right _
12:06:04 <RussellOConnor> In the case where Anything is False, then Right _ is impossible, so the function is total.
12:06:20 <Igloo> You can still pass it Right undefined
12:06:58 <RussellOConnor> A function is total if it always returns defined outputs given defined inputs.
12:07:44 <Igloo> Fair enough. I still don't think you've demonstrated that it's useful, though
12:08:16 * Igloo heads home
12:08:50 <edwinb> I think you have to remove _|_ (and general recursion) to make it useful...
12:09:42 <RussellOConnor> I think so too
12:10:03 <RussellOConnor> I'm a big fan of removing general recursion.
12:10:07 <edwinb> Me too.
12:10:24 <RussellOConnor> Turing complete was a mistake.  Too much power.
12:10:26 <edwinb> But I'm a dependent type theorist so I would say that ;)
12:10:32 <edwinb> I do think Turing completeness is overrated.
12:11:09 <edwinb> I haven't yet found a useful non-terminating non-productive function!
12:11:55 <RussellOConnor> Every time I find one, it's a bug.
12:12:23 <edwinb> indeed ;)
12:12:48 <edwinb> Everyone should read Turner's paper on "Elementary Strong Functional Programming"
12:13:00 <RussellOConnor> I haven't read that
12:13:19 <RussellOConnor> I think I would like that
12:13:33 <RussellOConnor> Although I'm probably not the target audience.
12:13:57 <edwinb> It's aimed at functional programmers in general.
12:14:32 <edwinb> It's in "Functional Programming Languages in Eduction", 1995. LNCS 1022.
12:35:28 <SyntaxNinja> Igloo: I think we'll have to talk later about this :) I keep getting pulled away.
12:51:18 <Igloo> Can you do while (<>) { ... } without general recursion (excuse my perl)
12:51:20 <Igloo> ?
12:51:35 <Igloo> (and my ignorance)
12:51:44 <neologism> iterate?
12:52:51 <RussellOConnor> you can be productive without general recurion.
12:53:16 <RussellOConnor> presubably by doing recursion over a codata structure.
12:53:30 <RussellOConnor> s/presubably/presumably/
12:53:35 <Igloo> I was looking for a yes/no answer
12:53:47 <RussellOConnor> no
12:54:05 <RussellOConnor> wait
12:54:09 <RussellOConnor> maybe
12:54:09 <Igloo> That's what I thought. I don't think it's practical, then
12:54:11 <Igloo> Oh
12:55:10 <Igloo> Well, if it turns into a yes I'll hunt down definitions and think about it  :-)
12:55:24 <monotonom> map (\one_line -> ...) . lines
12:57:04 <monotonom> Here is an example equivalent to grep '^Hello' 
12:57:33 <monotonom> main = interact (unlines . filter (List.isPrefixOf "Hello") . lines)
12:58:41 <Marvin--> SyntaxNinja: ping
12:59:34 <Igloo> You need to make interact a builtin to avoid GR there. You might be able to cover all the necessary cases with primitives without having primitives that can creat the problem you're trying to solve, but I'd have to think about that harder
12:59:56 <monotonom> interact is a builtin.
13:01:03 <SyntaxNinja> hi Marvin--
13:01:10 <Igloo> Not being able to run commons things like    f n | odd n = 3*n+1 | even n = n `div` 2   would suck too, IMO
13:01:39 <Igloo> It's not currently if you think of the languages as being defined on top of a minimal core
13:03:33 <monotonom> That f does not use recursion.
13:03:53 <Marvin--> SyntaxNinja: yes, I broke the build, because I only updated the data structures and the parser, I didn't know how you want to do the building 'n stuff :)
13:03:53 <Igloo> Oh, I forgot the recursive calls
13:04:08 <Igloo> f n | odd n = f (3*n+1) | even n = f (n `div` 2)
13:04:14 <Igloo> Oh, and the base case
13:04:25 <monotonom> If you add back the recursion, you will find that the same recursion is inevitable in Perl.
13:04:31 <Igloo> f 1 = 1 or something. I should probably be counting steps too
13:05:16 <Igloo> I wasn't meaning that perl isn't GR or anything, I was just using perl syntax as it was less to type
13:05:21 <Igloo> Sorry, I shouldn't have been lazy
13:05:40 <SyntaxNinja> Marvin--: I was hoping you'd refactor those bits while I'm working on the extensions stuff, which is almost done.
13:05:51 <SyntaxNinja> it's no big deal, I was just too busy to break the build last night.
13:05:58 <Marvin--> sure
13:06:26 <monotonom> And I'm using Perl as just a representative of imperative languages.
13:06:31 <SyntaxNinja> the hardest part of the refactoring is the parser; the rest is just little stuff that the compiler catches.
13:06:41 <SyntaxNinja> so that's why I figured I'd leave it to you :)
13:06:50 <Marvin--> I didn't mean for you to push the stuff, I just wanted to bring you up to date on what I was doing and let you comment on it
13:06:57 <Marvin--> and darcs send was the easiest way :-)
13:07:29 <Igloo> I think I've lost track of what your point is somewhere along the line
13:07:29 <Igloo> Are you saying GR is necessry or that we could live without it?
13:07:46 <SyntaxNinja> wow! nautilus is suddenly really fast and usable!
13:08:39 <SyntaxNinja> Marvin--: right. I got that from your last email... darcs should have a way to add extra comments to "darcs send" :) anyway, I glanced over it, but didn't look very hard; I will probably do so tonight.
13:08:52 <Igloo> It does have
13:08:55 * SyntaxNinja is suddenly addicted to opening windows
13:09:04 <Igloo> --edit-description
13:09:14 <Marvin--> SyntaxNinja: *g* gnome 2.6 is sweet :)
13:09:49 <neologism> boys, do you use pango?
13:10:05 <monotonom> I am just giving counterexamples to a myth.  The myth is that there are more non-tail recursions in functional programming than in imperative programming.
13:10:09 <Marvin--> Igloo: oh, neat, I'll have to remember that
13:10:58 <Igloo> Ah, OK
13:12:53 <Marvin--> SyntaxNinja: anyhoo, I can have a look at continuing the refactoring, at least to a point where library building works again, even if I don't add support for executables yet
13:13:23 <Marvin--> man, you write essays for log messages
13:13:42 <Igloo> :-)
13:13:57 * Marvin-- is reminded of Branden's xfree86 changelogs
13:15:08 <SyntaxNinja> Marvin--: cool.
13:15:23 <SyntaxNinja> I will happily implement the actual building of the executables
13:15:46 <SyntaxNinja> Marvin--: heh. actually, I just pasted my email to libraries@ into the log message. I figured it was a good summary
13:16:58 <SyntaxNinja> I love dist-upgrades.  all my applications look slightly different and new.
13:17:47 <thebug> I'll second the notion of dist-upgrades being quite nice
13:18:06 <Marvin--> I very rarely dist-upgrade, I keep my sid current :)
13:18:41 <thebug> well yeah, that's what I do on my home machine, but for moving from say potato->woody on a server ... :)
13:20:37 <Marvin--> sure
13:21:20 <SyntaxNinja> I go in phases between dist-upgrading all the time and waiting for a few weeks.  since I'm using sid on several machines, I tend to perform an upgrade on one of them about as often as I should upgrade each of them.
13:21:26 * SyntaxNinja got sick of trying to figure out a good way to say that.
13:29:13 <SyntaxNinja> when I'm browsing code, I often wish I could ask the interpreter for the type of a where-nested function (because people tend to not write type sigs for them)
13:30:40 <Marvin--> oh shucks, I missed Midsomer Murders
13:35:43 <Igloo> The downsides of upgrade, of course, is that sometimes you find that your webbrowser lost half its functionality
13:36:41 <Marvin--> no kidding
13:37:04 <Marvin--> that's on its way to be resolved, though
13:37:12 <Igloo> Oh?
13:37:42 <Marvin--> you *are* talking about the printing in mozilla/galeon/epiphany issue, right?
13:38:17 <Igloo> No, I'm talking about the lossage in galeon 1.2 -> 1.3
13:38:47 <Igloo> I /still/ have to quit galeon with kill to have my session saved, and we're up to 1.3.16 now
13:39:10 <Igloo> And ^T still doesn't put the cursor in the URL bar either
13:39:17 <Marvin--> er. ever tried the "Save session on exit" option?
13:40:10 <Marvin--> and what's wrong with ctrl-L to get to the location bar?
13:40:42 <Igloo> Oh, hmm, maybe it's just saving in the middle of using it that hasn't reappeared then
13:41:05 <Igloo> Why should I have to do ^L whenever I do ^T? Why would I not want to be in the URL bar after doing ^T?
13:41:29 <Marvin--> oh, I misunderstood
13:41:36 <Marvin--> yes, that's a good point
13:41:41 * Igloo goes to prod food
13:44:54 * Igloo decides the upstream guys I mentioned it to have almost certainly forgotten about it by now so I should file a bug
13:45:35 <Marvin--> SyntaxNinja: actually, this could be a bit more tricky than I thought, what should the configure function return if library pkg_descr is Nothing?
13:48:03 * Marvin-- reads code
13:50:44 <SyntaxNinja> Marvin--: what's the "library" field for again?  it's not the list of sources...
13:51:59 <Marvin--> library :: Maybe BuildInfo  is for the stanza that has to do with building a library
13:52:19 <Marvin--> right now I'm pretty much copping out by replacing   foo pkg_descr   with   maybe [] foo (library pkg_descr)   :-)
13:52:35 <Marvin--> So Far So Good
13:56:08 <SyntaxNinja> heh
13:56:58 <SyntaxNinja> hm. I think that should be fine... the other thing to do if there's no library is to build an executable,w hich is done in a different way.
13:57:23 <Marvin--> yes, but we really need one LocalBuildInfo per executable/library...
13:58:01 <Marvin--> well, perhaps not the local build info, but a lot of code can be shared between library building and executable building
13:59:22 <SyntaxNinja> yeah
13:59:32 <SyntaxNinja> i don't get your "one local build info" comment
13:59:39 <SyntaxNinja> but I agree about the code sharing
14:00:02 <Marvin--> my mistake, I misremembered what LocalBuildInfo contained
14:05:47 <Marvin--> woot, Distribution.Simple loads
14:06:03 <Marvin--> now how do I go about testing HUnit with this
14:06:14 <Marvin--> hey, maybe I should write a proper Setup.description for it
14:10:35 <Marvin--> WHOA, warnings
14:12:31 <Marvin--> hey cool, it worked
14:12:36 <Marvin--> SyntaxNinja: it worked, it worked
14:12:42 * Marvin-- dances around SyntaxNinja cheerfully
14:14:34 <SyntaxNinja> cool!!
14:14:36 * SyntaxNinja dances w/ marvin
14:14:40 <SyntaxNinja> How many beers do I owe you now?
14:15:30 <Marvin--> you owe me beer?
14:15:34 <Marvin--> cool!
14:15:43 <SyntaxNinja> so you wrote a new Setup.description file for test/HUnit?
14:16:00 <Marvin--> yep
14:16:07 <SyntaxNinja> sweet!
14:16:17 <SyntaxNinja> so that read/show code is all gone now, right?
14:16:30 <Marvin--> yep
14:17:01 <SyntaxNinja> gooood.
14:17:14 * SyntaxNinja feels like we're tantalizingly close to a release
14:18:41 <Marvin--> many of the field parsers are really really arbitrary
14:18:56 <stepcut> s
14:18:59 <stepcut> eek
14:19:10 <Marvin--> s to you too, sir
14:20:28 <Riastradh> rm -rf stepcut
14:20:53 <Marvin--> man, darcs confuses me at times
14:21:38 <Marvin--> I run darcs whatsnew -s in a subdirectory and still get file names relative to the root of the repo
14:23:36 <SyntaxNinja> yeah... it's confusing. it's just complicated enough that you have to spend a non-trivial amount of time thinking, "Is this a bug? or am I dumb?"
14:27:13 <Marvin--> even more confusing when you ask it  darcs whatsnew foo/bar  and it responds with the file name  some/where/foo/bar
14:32:54 <Marvin--> there, sent a new patch bundle
14:33:00 <SyntaxNinja> cool. thanks.
14:33:15 <Marvin--> I even used --edit-description :P
14:34:23 <Marvin--> argh, or at least I *would* have sent it, if I could *spell* your domain name
14:34:54 <Igloo> heh
14:34:54 <SyntaxNinja> heh. darcs needs autocomplete
14:35:07 <Igloo> What you want is a named repo
14:35:21 <Igloo> It has autocomplete. Or rather, bash and zsh autocomplete whatsits
14:35:37 <Igloo> But named repos are far nicer IMHO
14:35:44 <Marvin--> yeah, there is bash/zsh autocompletion for darcs, but that won't really help with the email address
14:35:59 <Marvin--> but I'm not sending it to a repo, I'm sending it to a person...
14:36:04 <Igloo> Huh? You should be able to do   darcs send repo_url
14:36:59 <Marvin--> If I dont give any repo url at all, it uses the latest, but asks for a mail address
14:37:19 <Igloo> You (Syntax) will need a suitable address in _darcs/prefs/email
14:37:56 <Marvin--> "Google sysadmin preaches Debian for software management" cool :-)
14:38:31 <Marvin--> ah, so it's not my fault
14:38:42 * Marvin-- points at SyntaxNinja and screams "it's all your fault!"
14:39:29 <SyntaxNinja> huh?
14:39:45 <SyntaxNinja> I think it probably remembered the lie about my email address that you recently told it.
14:40:04 <Marvin--> I've had to use --to every time
14:40:53 <Marvin--> I guess that's because I'm working towards the repo on cvs.h.o rather than against your personal repo
14:40:56 <SyntaxNinja> Marvin--: is that from the auto-update thread?
14:41:09 <SyntaxNinja> (on slashdot?) they won't mod up my touting of apt-secure :)
14:41:41 * SyntaxNinja goes home
14:41:41 <Marvin--> I dunno, I saw it on DWN
14:41:46 <SyntaxNinja> ahh
16:37:50 <phubuh> Does GHC have an unsigned and unboxed 32-bit integral type?
16:44:00 <ibid> there seems to be a Word#
16:44:24 <ibid> (see GHC.Exts docs, for example)
22:11:39 <CLxyz> Whats a good play project to learn haskell with?
22:11:58 <Riastradh> Write an SML compiler.
22:12:21 <CLxyz> LOL
22:12:40 <CLxyz> I really need to pick which one i'm going to learn first
22:13:10 <Riastradh> Scheme!
22:13:26 <heatsink> Write a haskell tool that does file operations based on command line parameters
22:14:01 <heatsink> This encourages understanding and clear, concise coding
22:14:08 <hyp3rion> write a microkernel for the mips in haskell ;)
22:14:08 <heatsink> Because if you make an unlucky mistake, it will erase your drive
22:15:43 <CLxyz> hyp3rion that sounds fun
22:16:48 <hyp3rion> ^_^ that'd be a bit hard
22:20:32 <CLxyz> True
22:20:33 <CLxyz> But fun
22:34:40 <Gahhh> CLxyz: I am using some contest questions 
22:35:13 <Gahhh> they are small enough to be successfully written within an hour
22:35:30 <Gahhh> and they pose different kinds of problems
22:36:38 <Gahhh> once I'm done with those, I am going to write an open source application that you can run on your PDA, which will pick up ladies at the bar.
22:36:47 <CLxyz> LOL
22:36:53 <CLxyz> Gahhh which set of contest questions?
22:37:04 <Gahhh> like these:
22:37:21 <Gahhh> http://acm.uva.es/problemset/
22:39:32 <Gahhh> But lemme tell y'all Haskell people: learning haskell is a true challenge if you're a seasoned imperative programmer.
22:39:59 <Verbophobe> It's worse for people who've no programming background whatsoever.
22:40:17 <Gahhh> I thought it could be easier, but oh well
22:40:45 <CLxyz> Its a very different way of thinking
22:40:50 <Verbophobe> Nah man...  First, Haskell is really functional + imperative, because of the IO monad.
22:41:36 <Verbophobe> Also, whether you like it or not, imperative programming shapes your brain in a way that makes you at very apt at programming.
22:42:08 <Gahhh> it makes damn good drill sergeants
22:42:24 <Verbophobe> All you have to do to use haskell is to rework your brain in the proper shape, whereas a newbie has to cultivate it into the Haskell mold.
22:43:01 <Gahhh> in my case it involves heavy drinking
22:43:10 <Pseudonym> Actually, learning Haskell is much easier if you've done no programming but you have done maths.
22:43:16 <Pseudonym> Assuming you don't want to do any IO.
22:43:21 <Gahhh> heh
22:43:36 <Pseudonym> Writing functions in Haskell is like writing functions in maths.
22:43:40 <heatsink> Much easier if you've taken a computer science THEORY cuorse
22:43:53 <Gahhh> yes, it is also easy to explain those functions to other people
22:44:08 <Verbophobe> Yeah, of course...  But you're not going to go very far in Haskell without Monads.
22:44:36 <Gahhh> by the way, that monad tutorial at nomaware.com is excellent
22:45:02 <Gahhh> if the author is here, I'd like to kiss him on the forehead
22:45:58 <Gahhh> maybe not
22:47:00 <CLxyz> havent seen that one yet
22:47:08 <Gahhh> you have to see it
22:47:09 * CLxyz visits
22:48:15 <Gahhh> http://www.nomaware.com/monads
22:49:16 <Gahhh> What's the most popular application written in haskell ?
22:49:23 <Pseudonym> GHC
22:49:29 <Pseudonym> Seriously.
22:49:35 <Gahhh> heh, I mean for non-programmers
22:49:41 <Riastradh> Darcs is probably high on the list too.
22:50:30 <Gahhh> darcs would probably qualify, since the user is not a haskell programmer necessarily
22:51:27 <Gahhh> hmm, it looks like a full blown cvs replacement
23:05:01 <greenrd> I find darcs even more incomprehensible than haskell :(
23:05:36 <Riastradh> What do you find incomprehensible about Darcs?
23:05:37 <greenrd> I mean, I understand that it's a replacement for CVS... I don't understand the patch theory behind it though
23:05:48 <Riastradh> You don't need to understand the patch theory to be a casual user.
23:05:56 <greenrd> This is true.
23:06:52 <desrt> it's just like arch
23:07:07 <desrt> read: frightening and perverse
23:07:30 <Riastradh> Not at all.
23:07:42 <Riastradh> Darcs is _dramatically_ simpler & easier to use than arch.
23:08:02 <desrt> if god had intended for us to use patchset-based revision systems then he wouldn't have given moses cvs
23:08:20 <Riastradh> I picked up Darcs in about two minutes.  I've yet to figure out how to use arch properly after at least about three tries involving several hours of studying arch.
23:08:21 <greenrd> heh
23:08:35 <desrt> hm
23:08:40 <Riastradh> If he had intended for us to use patchset-based revision systems, he'd have made CVS suck.
23:08:43 <Riastradh> ...oh...right...
23:08:44 <desrt> my impression of darcs is that it's very much the same as arch
23:09:00 <desrt> hey.  back off.  i love cvs :)
23:09:06 <desrt> i know it's crappy, but i don't care
23:09:08 <greenrd> Well, arch is a bit fiddly. But I feel more confident that I know what's going on under the hood with arch.
23:09:43 <Riastradh> What does that matter, greenrd?
23:13:00 <CLxyz> subversion perhas?
23:13:20 <CLxyz> arch looks quite complicated
23:14:11 <Riastradh> arch is.
23:14:19 <Riastradh> Darcs isn't.
23:14:36 <CLxyz> havent used darcs yet
23:14:50 <Riastradh> I'm very happy with Darcs.
23:15:15 <CLxyz> does it integrate with VS.NET?
23:15:27 <CLxyz> [I'm looking for something that does the integration nicely
23:15:42 <Riastradh> I know very little about VS.NET except that I'd prefer avoiding it.
23:15:42 <CLxyz> [and, yes i know this is probably a bad place to ask
23:15:52 <CLxyz> heh
23:15:57 <CLxyz> .NET's nice
23:16:39 <Riastradh> Sure, if you don't mind selling your soul to Microsoft and bringing your language closer & closer to C# until it operates OK on .NET.
23:17:34 <Pseudonym> On a related note, has anyone used SCons?
23:17:44 <Pseudonym> How does it compare with autotools?
23:17:49 <SamB> scons has a wierd style
23:17:54 <SamB> for python code, I mean
23:18:12 <SamB> but it at least isn't written in m4, so...
23:30:26 <Verbophobe> Oh good lord.  I'm eating something that contains not an insignificant amount of vinnegar, and I have an ulcer in my mouth.  It's rather painful.
23:30:57 <Verbophobe> I just thought I'd share that with you guys.
23:35:43 <lament> Thanks a lot!
23:37:17 <Verbophobe> You're more than welcome.
23:37:49 <Pseudonym> Eat bicarb soda.
23:37:56 <Pseudonym> That way, they'll cancel each other out.
23:39:08 <Verbophobe> Actually, I went for a more proactive but alltogether less chemistryful solution: I put a bunch of salt on the wound.
23:39:25 <Verbophobe> It sealed it up pretty good, but it did leave me in quite a lot of pain.
