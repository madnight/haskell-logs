00:06:27 <ayrnieu> wow, qemu works wonderfully.
00:55:16 <saba> evening all.
00:56:25 <Lemmih> Yo
01:55:47 <Marvin--> Does anybody know if there are any specific advantages to implementing a continuation monad as   newtype ContT m a = forall b. ContT ((a -> m b) -> m b)  rather than  newtype ContT r m a = ContT ((a -> m r) -> m r)  ?
01:56:25 <Marvin--> errr, newtype ContT m a = ContT (forall b. (a -> m b) -> m b)  obviously
01:58:58 <Marvin--> Koen uses the forall form in ReadP, and a trivial way to make ReadP haskell98 would be to move the b out to a type parameter...
02:39:55 <Marvin--> hm, freaky, I never thought of *that*
02:40:04 <Marvin--> ReadP can be made an instance of MonadCont
02:40:39 <Marvin--> > readP_to_S (callCC (\esc -> do char 'a' ; esc 'k' +++ char 'b')) "abc"
02:40:39 <Marvin--> [('k',"bc"),('b',"c")]
03:15:17 * Marvin-- grumbles and wishes parsec had something like Parsek's longestResultWithLeftover
03:16:15 <sazzle> hm
03:16:20 <sazzle> can someone tell me what to do here?
03:16:23 <sazzle> Loading package wxcore ... ghc-6.2.1: can't load .so/.DLL for: wxc-gtk2.4.2-0.7 (/usr/X11R6/lib/libwxc-gtk2.4.2-0.7.so: Undefined symbol "_ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette")
03:27:13 <Marvin--> sazzle: run around and scream?
03:27:22 <Marvin--> I dunno, really
03:27:49 <Marvin--> wait for Igloo to show up, I guess :)
03:34:09 <sazzle> hehe, ok
03:35:05 <sazzle> things that work in ghc, but not ghci are weird!
03:35:30 <Marvin--> I wouldn't be so surprised, dynamic loading is tricksy
03:36:42 <Marvin--> but yes, it does sound like a bug
03:37:12 <Marvin--> (I get the same error, fwiw)
03:43:24 * Marvin-- continues to ponder parsers
03:45:19 <Marvin--> I think this calls for a cup of coffee
03:45:22 <sazzle> heh
03:45:38 <sazzle> oh you do, good, at least it's not a freebsd problem then
03:53:03 <Marvin--> hmm, wait a sec, that's not a haskell mangled symbol, that's a C++ mangled symbol
03:53:22 <Marvin--> $ echo  _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette | c++filt
03:53:22 <Marvin--> wxGLCanvas::wxGLCanvas(wxWindow*, int, wxPoint const&, wxSize const&, long, wxString const&, int*, wxPalette const&)
03:54:50 <sazzle> what does that mean?
03:55:05 <Marvin--> I have no idea
03:56:37 <Marvin--> I suspect that it means that wxhaskell should be linked against libwx_gtk_gl rather than libwx_gtk
03:57:10 <sazzle> i gave this argument too:
03:57:12 <sazzle>  `wxgtk2-2.4-config --gl-libs`
03:57:19 <sazzle> which works in ghc
03:58:10 <sazzle> $ ghci -package wx  `wxgtk2-2.4-config --gl-libs`  Layout.hs
03:58:15 <sazzle> ^that doesn't work
03:59:02 * Marvin-- installs libwxgtk2.4-dev too
03:59:54 <Marvin--> ah, ghci probably doesn't play well with -l flags
04:01:28 <sazzle> hm
04:02:03 <Marvin--> try LD_PRELOAD?
04:02:18 <sazzle> no..
04:02:20 <sazzle> how?
04:04:09 <Marvin--> LD_PRELOAD=space-separated list of the libs ghci -package wx, I suppose
04:05:35 <Marvin--> LD_PRELOAD="libwx_gtk-2.4.so.0 libwx_gtk_gl-2.4.so.0 libGL.so.1 libGLU.so.1" ghci -package wx  <- this worked for me, yay
04:06:36 <sazzle> /usr/libexec/ld-elf.so.1: Shared object "libwx_gtk-2.4.so.0" not found
04:07:43 <sazzle> didnt work for me :(
04:07:50 <Marvin--> your library naming might be different, this was on debian
04:10:55 <Marvin--> I mean, check what wxgtk2-2.4-config --gl-libs prints and base it on that
04:16:14 <sazzle> hm
04:16:17 <sazzle> i'm a little confused
04:16:19 <sazzle> $ wxgtk2-2.4-config --gl-libs                          :-(
04:16:19 <sazzle> -L/usr/local/lib -liconv -L/usr/X11R6/lib -lc_r -lwx_gtk2_gl-2.4 -lGL -lGLU
04:17:32 <sazzle> would it be something like LD_PRELOAD="lwx_gtk2_gl-2.4.so.0" ?
04:17:47 <Marvin--> no, libwx_gtk2_gl-2.4.so.0
04:17:55 <Marvin--> "-l" is the flag
04:21:16 <sazzle> oh, right
04:22:54 <sazzle> like so?
04:22:56 <sazzle> $ LD_PRELOAD="libwx_gtk2_gl-2.4.so.0"  ghci -package wx Layout.hs                                                                  
04:22:59 <sazzle> /usr/libexec/ld-elf.so.1: /usr/X11R6/lib/libwx_gtk2_gl-2.4.so.0: Undefined symbol "_ZN12wxWindowBase13sm_eventTableE"
04:23:12 <Marvin--> but you probably need both libwx_gtk2-2.4.so.0 and libwx_gtk2-2.4.so.0 in the LD_PRELOAD, and probably libGL and libGLU too
04:23:31 <Marvin--> LD_PRELOAD doesn't do any resolving afaik
04:23:43 <Marvin--> so you need to provide an explicit list
04:23:45 <sazzle> what exactly does it do? preload the libraries in the linker?
04:23:51 <Marvin--> yes
04:24:12 <Marvin--> well, at least that's what it does on linux :-)
04:24:29 <sazzle> hmm
04:24:31 <sazzle> $ LD_PRELOAD="libwx_gtk2_gl-2.4.so.0 libwx_gtk2-2.4.so.0 libGL.so.1 libGLU.so.1"  ghci -package wx Layout.hs                                           
04:24:34 <sazzle> zsh: bus error (core dumped)  LD_PRELOAD="libwx_gtk2_gl-2.4.so.0 libwx_gtk2-2.4.so.0 libGL.so.1 libGLU.so.1
04:24:40 <Marvin--> eep
04:24:57 <Marvin--> okay, I'm out of ideas
04:34:58 * Marvin-- grumbles
05:01:28 * Marvin-- loves vimdiff
05:04:10 <sazzle> what's that?
05:05:04 <Lemmih> diff integrated in vim maybe...
05:05:16 <Marvin--> oh it splits the vim window in two halves and shows you the differences between two files, updating as you make changes
05:05:43 <Marvin--> I wonder if I have a screenshot of it somewhere
05:05:43 <sazzle> nice
05:05:48 <sazzle> a script?
05:06:45 <Marvin--> it's built into vim 6, I think
05:07:04 <Marvin--> http://sjogren.ost.sgsnet.se:8080/static/vimdiff.png
05:08:46 <sazzle> how did you invoke it?
05:09:54 <Marvin--> gvimdiff Makefile Makefile.mine  in that case (it's an old screenshot)
05:10:51 <sazzle> ah
05:11:45 <sazzle> this is rather strange:
05:11:47 <sazzle> $ gvimdiff Layout.hs ~/thesis/samples/wx/Layout.hs     :-(
05:11:48 <sazzle> /usr/libexec/ld-elf.so.1: /usr/X11R6/lib/libwx_gtk2_gl-2.4.so.0: Undefined symbol "_ZN12wxWindowBase13sm_eventTableE"
05:11:57 <sazzle>  
05:12:05 <Marvin--> ehhh
05:12:14 <Marvin--> ookay, your LD_PRELOAD seems rather evil
05:12:31 <sazzle> ja
05:15:43 <Marvin--> crap, my armored gpg key is too long to fit the X paste buffer :)
05:18:35 <sazzle> heh
05:21:13 <Marvin--> err, that was, however, not my key... I wonder why pere felt the need to mail bdale's key to me
05:24:33 <Marvin--> hmm, now how do I get at those juicy +# and -# operators
05:25:14 <Marvin--> ah-hah! GHC.Base
05:25:17 * Marvin-- does evil things
05:38:02 <Marvin--> hm, I wish syntax was here so I could discuss this with him
05:59:41 <ozone> what are you doing marvin? :)
06:00:02 <ozone> it sounds nice and evil
06:00:06 <ozone> (right up my alley)
06:00:22 <ozone> hmm, hacking on HeliumFrontend.hs, i see
06:00:34 <Marvin--> huh?
06:01:05 <Marvin--> heh, that screenshot is almost a year old :)
06:01:08 <ozone> Marvin--: using +# and -# sounds positively evil
06:01:47 <Marvin--> ozone: eh, I didn't write it, I was just trying to get it to work :)
06:02:03 <ozone> Marvin--: that's always a safe answer :)
06:02:22 <Marvin--> it was an #ifdef __GLASGOW_HASKELL__ in ReadP.hs
06:03:27 <Marvin--> a helper function was supposed to discard n copies of something, and the ghc version used 0# and n-#1# instead of 0 and n-1
06:04:00 <Marvin--> you'd think the optimizer could do stuff like that on its own
06:28:20 <ozone> Marvin--: yep, sounds evil
06:28:55 <Marvin--> ozone: eh, the ghc libs are littered with stuff like that
06:32:26 <Marvin--> meh, it's annoying having to stick to H98
06:36:50 <ozone> agreed on both counts
06:38:37 <Marvin--> but if cabal doesn't run on H98 it'll be kinda useless
07:28:03 <Marvin--> meh
07:28:17 <Marvin--> I think I need another cup of coffee before refactoring cabal's command line parsing
07:48:37 <Marvin--> oh hell
07:48:50 <Marvin--> note to self: instance Monad (Either e)  isn't H98 either
07:48:51 <RussellOConnor> troubles?
07:49:16 <Marvin--> something tells me we've got a lot of work to do to make cabal compile with nhc
07:50:06 <Igloo> Marvin--: Why not?
07:50:37 * RussellOConnor tries to imagine the sematics of Either as a Monad
07:51:15 <Marvin--> Igloo: because H98 doesn't allow partial application of type constructors in instance heads, does it?
07:51:28 <RussellOConnor> Is it identity on when data is from left, and regular function application if the data is on the right?
07:51:35 <Igloo> If that was teh case you couldn't write /any/ instances of Monad
07:51:58 <Marvin--> Igloo: er, right, but that's not what I meant
07:52:33 <Marvin--> Igloo:  instance Monad (Either String)  is definitely not H98 though
07:52:55 <Marvin--> RussellOConnor: the idea is that Left carries errors and Right carries values
07:52:56 <Igloo> No, but neither is instance Foo (Either String Bool)
07:53:07 <Igloo> You have to give type variables as the arguments
07:53:22 <Marvin--> right, right
07:53:50 <Marvin--> RussellOConnor: Left e >>= f = Left e ; Right x >>= f = f x
07:54:31 <Igloo> I don't think you can get fail to work how you want without overlapping instances, though
07:54:47 <Marvin--> so with the proper Error class, you could have instance Error e => Monad (Either e)
07:55:01 <Marvin--> but it's sort of a moot point because I looked through the .hi files that nhc ships and it doesn't do it ;)
07:55:02 <Igloo> Or using a different function to fail
07:55:38 <Igloo> Oh, no, I'm being a fool, you can have class constraints on teh first type variable, just not on the second
07:55:59 <Igloo> What doesn't nhc do?
07:56:21 <Marvin--> instantiate Monad (Either e) for some e
07:56:32 <Marvin--> so then we'd have to #ifdef and stuff
07:57:58 <Marvin--> does nhc define __NHC98__ or something?
07:58:39 <Marvin--> Igloo: ohbtw, now that you're here, sazzle was having problems using wxhaskell from ghci, and I got the same problem with your Debian packages
07:58:53 <sazzle> hi Igloo 
07:58:57 <Marvin--> I worked around it by using LD_PRELOAD, but that was kinda ugly :)
07:58:58 <Igloo> ITYM "debs"  :-)
07:59:21 <Marvin--> huh?
07:59:28 <Igloo> There was a symbol problem that could be solved by adding something to the package.conf - google ought to nkow the details
08:00:00 <Marvin--> right, it was a symbol problem
08:00:13 <Marvin--> I fiddled with package.conf but didn't get it right and got bored ;)
08:00:43 <Igloo> Well, they aren't in Debian, and certainly aren't good enough that they ought to be. I'm possibly being pedantic.
08:01:08 <Marvin--> oh
08:01:24 * Igloo will look once I've looked at why nhc98 doesn't have Control.Monad.Error if you can't find it
08:01:30 <Marvin--> heh, I just did apt-get, I missed that they were from h-experimental :)
08:01:39 <Igloo> heh
08:02:02 <Marvin--> probably because C.M.E is " non-portable (multi-parameter type classes)"
08:02:11 <Igloo> Ah, the standard libraries use MPTC "class (Monad m) => MonadError e m | m -> e where"
08:02:19 <Igloo> And fundeps for that matter
08:03:09 <Marvin--> hrm, dammit, even with Error e => Monad (Either e) I can't instantiate Error String anyway...
08:03:23 <Marvin--> oh well, instance Error Char ; isntance Error e => Error [e]  :-/
08:05:31 <Marvin--> yuck
08:05:46 <Marvin--> class Error e where eFromStr :: String -> e
08:05:46 <Marvin--> instance Error Char where eFromStr s = head s
08:05:46 <Marvin--> instance Error e => Error [e] where eFromStr s = map (eFromStr . (:[])) s
08:05:46 <Marvin--> instance Error e => Monad (Either e) where ...
08:05:55 <Marvin--> talk about hack
08:06:44 <Igloo> Hmm, /usr/include/nhc98/ doesn't seem to have mtl at all, but there is a libraries/mtl/Makefile.nhc98 (in CVS at least) that lists a couple of sources it should build. Maybe the release just predates that
08:07:14 <Igloo> Urgle?
08:07:20 <Marvin--> Igloo: Control.Monad needs a serious thwack with the refactoring stick, there are even modules there that are perfectly valid H98 but are non-portable because they import non-portable modules and instantiate other MPTC:s
08:07:26 <Igloo> Shuoldn't concatMap eFromStr s work?
08:07:40 <Igloo> Oh, ermm, maybe not
08:07:42 * Igloo thinks
08:07:47 <Marvin--> no :-/
08:08:02 <Marvin--> because the innermost eFromStr has type String -> Char
08:08:22 <Marvin--> what's libraries/mtl?
08:08:46 <Igloo> Monad Transformer Librariy or something. Has Control.Monad.Error in
08:08:51 <sazzle> sorry to break your discussion, but Igloo, any idea how to stop ghci breaking when i try to use -package wx (on freebsd)
08:08:56 <Marvin--> oh, it's been moved from base?
08:08:56 <Igloo> There is a new Monad library being developed, but I haven't looked at it
08:09:47 <Marvin--> mtl/Makefile.nhc98 only seems to list Identity and Trans
08:10:10 <Igloo> Yeah, but not even those are in /usr/include/nhc98/
08:10:35 <Marvin--> hm, I've got Fix.hi and Trans.hi
08:11:20 <Marvin--> pesky li'l compiler, nhc, sticking to standards and stuff :-)
08:12:28 <Marvin--> sazzle: before I started babbling and making the screen scroll way off, Igloo suggested googling :)
08:12:41 <sazzle> oh
08:12:52 * Igloo is looking through the thread now
08:14:17 <Igloo> Hmm. What's the symbol called?
08:14:36 <sazzle> ghc-6.2.1: can't load .so/.DLL for: wxc-gtk2.4.2-0.7 (/usr/X11R6/lib/libwxc-gtk2.4.2-0.7.so: Undefined symbol "_ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette")
08:14:57 <sazzle> i didn't compile wxhaskell with opengl though
08:15:15 <Igloo> Oh, try doing so then
08:15:16 <sazzle> (the default option was not to, iirc)
08:15:44 <sazzle> hm, ok
08:15:48 <Igloo> http://www.haskell.org/pipermail/glasgow-haskell-users/2004-April/006495.html
08:15:52 <Marvin--> the thing is, I had the exact same problem, with Igloo's debs
08:16:05 <Marvin--> and got it to work with LD_PRELOAD
08:16:17 <sazzle> Igloo: arh
08:16:44 <Igloo> Marvin--: I think that's a different problem, and the one I couldn't find the solution too for some reason
08:16:47 <Marvin--> so if there's something wrong with how sazzle built the lib, there's something wrong with the deb too ;)
08:17:06 <Igloo> I also can't see the WXH mailing list on its homepage, though, so it's probably just me  :-)
08:18:09 <Igloo> There are a number of things wrong with the debs  :-)   But also, I believe the Haskell libr should be split to mirror the splitting of the C lib into OpenGL/non-OpenGL bits
08:18:20 <Marvin--> right
08:18:38 <Marvin--> ldd shows that libwxc is only linked with the non-gl lib
08:18:41 <sazzle> Igloo: out of curiosity, why should i compile it with opengl if i'm not using any opengl stuff?
08:20:34 <Marvin--> I have adding #ifdef:s to haskell code
08:20:38 <Igloo> sazzle: I can't remember the details of this stuff any more
08:20:39 <Marvin--> s/have/hate/
08:20:40 <sazzle> Igloo: i just recompiled it, and got the same error again
08:20:54 <sazzle> ./configure  --wx-config=/usr/X11R6/bin/wxgtk2-2.4-config --with-opengl
08:21:05 <Marvin--> http://tunes.org/~nef/logs/haskell/04.03.24 <- this log discusses some of the problems
08:23:07 <sazzle> hm
08:26:21 <Marvin--> very soon I'm going to need an NhcCompat module
08:26:24 <Marvin--> and that will suck
08:26:25 <Marvin--> badly
08:26:33 <Marvin--> I need to discuss this with syntax
08:26:49 <sazzle> hm, a stupid question, does the ghc search path include the cwd?
08:27:05 <sazzle> it's not finding a module i imported which is in the same dir
08:27:20 <Marvin--> and it's properly named and everything?
08:27:23 <sazzle> yeah
08:27:28 <sazzle> module Wam where
08:27:32 <sazzle> and it's called Wam.hs
08:27:41 <Marvin--> sounds odd
08:27:51 <sazzle> i did -v and..
08:27:55 <Marvin--> do you have any -i flags?
08:28:05 <sazzle> Layout.hs:7:
08:28:05 <sazzle>     Failed to load interface for `Wam':
08:28:05 <sazzle>         Could not find interface file for `Wam'
08:28:05 <sazzle>         locations searched:
08:28:05 <sazzle>             Wam.hi
08:28:07 <sazzle>             Wam.hi-boot-6
08:28:08 <Igloo> Marvin: Doesn't GHC work with the nhc stuff?
08:28:10 <sazzle>             Wam.hi-boot
08:28:12 <sazzle>             /usr/local/lib/ghc-6.2.1/imports/Wam.hi
08:28:15 <sazzle>             /usr/X11R6/lib/Wam.hi
08:28:18 <sazzle>             /usr/X11R6/lib/imports/Wam.hi
08:28:20 <sazzle>             /usr/local/lib/ghc-6.2.1/hslibs-imports/data/Wam.hi
08:28:22 <sazzle>             /usr/local/lib/ghc-6.2.1/hslibs-imports/util/Wam.hi
08:28:25 <sazzle>             /usr/local/lib/ghc-6.2.1/hslibs-imports/posix/Wam.hi
08:28:28 <sazzle>             /usr/local/lib/ghc-6.2.1/hslibs-imports/concurrent/Wam.hi
08:28:30 <sazzle>             /usr/local/lib/ghc-6.2.1/hslibs-imports/lang/Wam.hi
08:28:33 <sazzle> no.. i didn't have -i
08:28:36 <Marvin--> sazzle: oh, if you're doing separate compilation you have to compile Wam first, so there's a Wam.hi available
08:28:42 <Marvin--> Igloo: WDYM?
08:28:49 <sazzle> Marvin--: ooh
08:28:56 <Igloo> sazzle: Or you can use --make
08:28:56 <Marvin--> Igloo: oh, I think I see
08:29:10 <sazzle> aah, i see
08:29:14 <sazzle> i was missing the -i
08:29:14 <Marvin--> well yes, but NIH kinda sucks
08:29:26 <Igloo> Huh?
08:29:30 <sazzle> Igloo: how does make work, ghc foo.hs --make?
08:29:43 <Marvin--> sazzle: you shouldn't need -i
08:29:54 <Igloo> You are currently writing essentially 2 versions (of parts), one for nhc and one for ghc, right?
08:29:57 <Igloo> sazzle: Yes
08:30:15 <Igloo> sazzle: well, plus -o foo if you want the executable to have a sensible name
08:30:23 <Marvin--> Igloo: except that the part for ghc is already distributed with ghc ...
08:30:26 <sazzle> Marvin--: that was my previous experience, but it didn't work without -i
08:30:30 <sazzle> Igloo: *nod*
08:30:32 <Marvin--> so I'm not exactly *writing* it
08:30:43 <sazzle> i'd always done ghc foo.hs bar.hs
08:30:55 <Igloo> Oh, hmm. But still, having #ifdefs when one fo the branches will always work and efficiency isn't an issue seems silly
08:31:15 <Marvin--> efficiency isn't the issue, ugly code is the issue :-P
08:31:26 <Marvin--> that Error hack is ghastly
08:31:29 <Igloo> But you have the ugly code either way
08:31:51 <Igloo> You just added a bit more ugliness so you can pretend the ugly code doesn't exist sometimes  :-)
08:31:58 <Marvin--> yeah, but this way I get to jab at nhc in a comment!
08:32:11 <Igloo> Heh
08:32:40 <Igloo> Well, I'd put the whole instance/class thing in a block witha  comment that it would just be Control.Monad.Error if all impls supported it
08:34:27 <Marvin--> the thing is, it's not C.M.E that defines the instance
08:34:32 <Marvin--> the instance is defined in C.M
08:34:53 <Marvin--> at least for ghc 6.2
08:35:29 <Marvin--> I think
08:35:36 <Igloo> Oh, of course, it'll be reexported  :-/
08:36:06 <Marvin--> er, no, wait...
08:36:08 <Marvin--> the docs are confusing
08:36:09 <Igloo> I suppose it's only 1 line anyway, so not a big deal
08:36:48 <Marvin--> we're going to need a Compat dir anyway
08:37:33 <Igloo> :-(
08:37:35 <Marvin--> we've got a locally hacked GetOpt since a long time (though I may do away with the need for that if my refactoring ideas for parameter parsing works out), and it looks like I'm adding a locally hacked ReadP module too
08:38:00 <Igloo> I'd suggest calling the H98 one H98 rather than NHC, assuming that's accurate
08:38:01 <Marvin--> oh, and there's Distribution.Version that supposedly will become Data.Version, but until then, it's sort of a Compat thingy too
08:38:06 <Marvin--> yeah
08:38:10 <Marvin--> true
08:38:43 <Marvin--> I realized that ReadP uses local quantification so it wasn't H98 and thus not distributed with nhc
08:39:01 <Marvin--> so I just hacked it to pass around an extra type variable all the time, which is ugly to boot, but it's what C.M.Cont does
08:39:48 <Igloo> So, where's the Haskell 2 working group then?  :-)
08:41:28 <RussellOConnor> Wait, what does C.M.Cont do?
08:42:24 <Marvin--> it's a continuation passing style monad
08:42:41 <RussellOConnor> Yeah, but what is the ugly thing it does?
08:43:23 <Marvin--> RussellOConnor: instead of  newtype Cont a = Cont (forall r. (a -> r) -> r),  it does  newtype Cont r a = Cont ((a -> r) -> r)
08:43:39 <Marvin--> Igloo: yeah... I'm leaning towards the ultimatum method
08:44:10 <Marvin--> Igloo: "If you smart guys can't get your act together and start a HaskellTwo working group, then *I* will do it, and that'll be a disaster, your choice"
08:44:29 <RussellOConnor> Marvin--, that is very interesting.
08:44:50 <Marvin--> RussellOConnor: of course, the way it's implemented has the advantage of being valid Haskell98 :-)
08:45:48 <RussellOConnor> Marvin--, I think I just doubled my understanding of continuations after reading your comment.
08:47:34 <Igloo> Marvin--: :-)
08:47:59 <Marvin--> RussellOConnor: haha
08:48:10 <Marvin--> you're welcome. I think. :-)
08:48:42 <Marvin--> not that it really matters that Cont and ContT are Haskell98, since the rest of the module *isn't*
08:49:20 <Marvin--> and that's what I mean about the refactoring stick
08:49:31 <Marvin--> Igloo: do you know who is working on the C.M refactoring?
08:49:54 <Igloo> Ermmm, someone with a name like Iaodvor possibly?
08:50:04 <RussellOConnor> Doesn't everyone know what is going to be in HaskellTwo anyways?
08:51:14 * Igloo realises the cabal extension datatype provides the basis from which a skeleton H2 possible feature page could be made, if one doesn't already exist
08:51:42 <Igloo> RussellOConnor: If we knew that then H2 would alerady exist and we'd just be waiting for the implementors to catch up
08:51:42 <Marvin--> there is some stuff on the hawiki HaskellTwo page, iirc
08:52:53 <RussellOConnor> Let's see: Rank 2 polymorhpism, fun-deps, and that other thing.
08:53:00 * RussellOConnor goes looks at the wiki
08:54:13 <RussellOConnor> oh yeah, multiparamter typeclass
08:55:57 <Marvin--> hm, I'd like to see restricted type synonyms on that list
08:56:30 <Marvin--> Igloo: looks like someone with the login 'diatchki' has been working in the libraries/monads directory, any idea who that is?
08:57:24 <Igloo> Iavor S. Diatchki - that's probably him
08:58:03 <RussellOConnor> restricted type synonyms?
08:58:23 <Igloo> http://www.cse.ogi.edu/~diatchki/MonadTransformers/
08:58:24 <Marvin--> RussellOConnor: a hugs extension
08:58:42 <Marvin--> you can say  type Foo = ... in f, g, h
08:58:56 <Marvin--> that way, Foo acts like a type synonym to the functions f, g and h, but as a newtype elsewhere
08:59:37 <RussellOConnor> Interesting.
08:59:48 <Igloo> There are numerous other small things, like instance Foo (Maybe String)"
09:00:05 <Igloo> that will no doubt be debated, plus bigger issues like the monomorphism restriction
09:00:30 <Igloo> Oh, and I would expect something would be done to give H2 principal types
09:00:42 <Marvin--> principal types?
09:00:49 <Marvin--> it rings a bell, I should know what it is, but I don't remember
09:01:35 <Igloo> t is the principal type of e in env G if    G |- e :: t' => (t' <= t)
09:01:41 <RussellOConnor> I think the three things I named are the most important, and least contrivisial things that could be added to Haskell 98.
09:01:48 <Igloo> Where => is implication and <= is an inequality
09:02:03 <Igloo> You might want the other inequality depending on what definitions you use
09:02:08 <Marvin--> ahh, gotcha
09:02:41 <Igloo> (actually the definition is a bit more lenient than that, but that's the normal choice for this sort of language)
09:03:19 <Igloo> RussellOConnor: I think they would give you an approved addendum, not a new language version, though
09:03:38 <Igloo> Or 3 approved addenda
09:03:55 <RussellOConnor> Igloo, I think that would make lots of people happy
09:04:08 <RussellOConnor> Like Marvin-- right now.
09:04:15 <Igloo> It wouldn't make me particularly happy  :-)
09:04:28 <Marvin--> if approved addenda for MPTC, FunDeps, Rank N types etc. are enough to make the nhc people implement them, it'd make me happy ;)
09:04:38 <Marvin--> Igloo: why not?
09:04:58 <RussellOConnor> Well, I personally would program with those three things anyways, approved or not.
09:05:21 <Marvin--> Igloo: btw, Iavor's MonadTransformers package has a vastly different interface from the stuff in cvs
09:05:22 <Igloo> Because it won't necessarily make implementations for existing compilers magically appear, and it won't fix what I view as more serious problems with the language
09:07:18 <Marvin--> Igloo: sure, but if implementations are a necessity for getting approved addenda or a new version of the standard... are the nhc people simply not interested in that?
09:07:22 <RussellOConnor> Don't implemenations of these things already exist?
09:07:49 <Marvin--> RussellOConnor: ghc implements most of it, hugs too (but not as much as ghc), and nhc implements none of it
09:07:54 <Marvin--> afaict
09:08:14 <Igloo> I think the nhc people are short of funding that would allow them to work on nhc/hat/...  :-(
09:08:33 <Marvin--> ah
09:09:15 <Marvin--> which sadly means that haskell will continue to evolve without it
09:09:24 <Riastradh> RussellOConnor, least controversial?  They require run-time type information & dispatch.  That could be pretty controversial.
09:09:58 <Marvin--> (though that is a lesser evil than nhc's non-funding holding the evolution back)
09:10:31 <RussellOConnor> Riastradh, You may be right.  To be fair, I know nothing about language implementations.  I'm just a mathematician.
09:10:49 <RussellOConnor> Do they really require run-time type info?
09:10:53 <Riastradh> They do.
09:10:59 <RussellOConnor> I don't see why these things would.
09:11:22 <Marvin--> well, they're certainly less controversial than the monomorphism stuff :-)
09:12:09 <RussellOConnor> Yeah, I hate programming with the monomorphism restriction, but I fear I would also hate programming without it.
09:12:24 <Marvin--> Igloo: I mean, the thing is, at some point in time you do have to make the choice between compatability and progress
09:12:33 <esap> I think monomorphism restriction is a failed attempt at considering performance issues.
09:13:03 <Riastradh> How can you statically decide what methods of Num to use for the elements of a list :: [forall a. Num a => a]?
09:13:24 <RussellOConnor> haskell should be a perfomance-free language. ;-)
09:14:29 <esap> russell: I think that's not a good idea. Functional programming is really better suited for performance critical stuff, just people need to be educated that doing everything manually is not usually a good idea.
09:15:17 * RussellOConnor ponders Riastradh's example
09:15:57 <Igloo> Ria: But for normal class stuff (with the simple translation at least) you have dictionary passing anyway
09:16:51 <RussellOConnor> So as it stands now, class methods will be inlined at compile time where functions with class restrictions are called?
09:17:46 <RussellOConnor> I don't see how Functional programming is better suited for performance critical stuff.
09:17:49 <Riastradh> ...without rank-N polymorphism.
09:18:14 <Riastradh> I believe multiparameter typeclasses and fundeps are also problematic here in a similar fashion, and I'm looking for an example.
09:18:34 <RussellOConnor> Riastradh, that's okay, I understand now.
09:19:00 <RussellOConnor> I didnt realize that Haskell 98 was able to inline methods at compile time.
09:43:20 <Marvin--> Fail: Rename.hs:709: Non-exhaustive patterns in lambda
09:43:21 <Marvin--> jeepers
09:43:28 <Marvin--> bad nhc, bad!
09:48:26 * esap never understood how could it make sense to have pattern matches in lambda abstractions if there are more than one alternative. At least since there is no mechanism for combining \ Nothing -> 0   and  \ (Just x) -> x + 1  into a single function.
09:50:03 <Marvin--> it's a typical case of "Oh, but that will never happen anyway" :-)
09:51:15 <esap> heh, well if so, then why allow pattern matches in lambdas at all?
09:52:03 <Igloo> For a start \(x, y) -> ... can't fail (unless the input is bottom)
09:53:21 <esap> sure, but then type checking could easily disallow using pattern matching in lambda if the match can fail.
09:53:52 <esap> Though I'd prefer to actually allow the match, but also should support it fully then.
09:54:19 <Igloo> Do you have a nicer syntax than \x -> case x of ...?
09:54:42 <esap> yes. \ Nothing -> 0 ||| \ (Just x) -> 1 + x
09:54:51 <edwinb> I wouldn't call that "nicer"...
09:55:00 <edwinb> Although many might disagree
09:55:05 <Igloo> You could define a ||| operator that does that anyway
09:55:07 <esap> well at least you can split that into two functions.
09:55:28 <esap> Note that the type system must be changed to allow that, there is no good type for \ Nothing -> 0
09:55:29 <Igloo> Oh, no you can't, not quite
09:56:26 <Igloo> @type \ Nothing -> 0
09:56:29 <lambdabot> \\ Nothing -> 0 :: forall t a. (Num t) => Maybe a -> t
09:56:35 <Igloo> What's wrong with that one?
09:56:53 <Marvin--> Igloo: er, how would the operator catch the pattern match failure?
09:56:56 <esap> It's too general. That function cannot take arbitrary "Maybe a" as input.
09:57:06 <Igloo> Marvin--: Yeah, hence "Oh, no you can't, not quite"
09:57:14 <Marvin--> ah
09:57:29 <Igloo> esap: But the type checker would unify the two types the case as it would for a case expression
09:57:30 <Marvin--> esap: er, but that'll be unified...
09:58:13 <esap> igloo: yes, but only when the '|||' operator is used. Before that, I'd expect the function should be more restrictively typed.
09:59:01 * Igloo realises you probably couldn't set the ||| precedence right anyway
10:00:23 <Marvin--> which is all moot, since you can't catch the pattern match unless you're in IO
10:01:03 <Igloo> You can't catch just the one you want anyway
10:01:33 <esap> marvin: For that, Adjunctions help :-) You just need a right adjoint for IO.
10:01:48 <Marvin--> oh dear
10:01:49 <RussellOConnor> I think disallowing lambda pattern matching on types with mutliple contructors is a good idea.  Or at least give a warning.
10:01:56 <esap> marvin: umm, F -| IO  I mean.
10:02:22 <esap> marvin: And obviously, for Maybe as well :-9
10:02:31 <RussellOConnor> I also think it should be an error to not have complete pattern matching in case expressions, etc.
10:02:50 <Marvin--> RussellOConnor: ghc -Wall will warn you about missing patterns
10:03:06 <RussellOConnor> Oh, that's good
10:03:13 <RussellOConnor> can I turn that on in ghci?
10:03:22 <esap> Missing patterns are pretty difficult thing. Sometimes you don't _want_ to match all patterns. OTOH, in other cases, it's essential to know whether you have.
10:04:01 <Igloo> You can always have foo _ = error "foo: Can't happen"
10:04:02 <RussellOConnor> can't people just do foo  _  = error "I suck"
10:04:13 <Marvin--> but that's ugly
10:04:15 <RussellOConnor> Good call Igloo
10:04:27 <esap> russell, igloo: Run-time error is too late for that.
10:04:37 <Igloo> The one that's annoying is record updates as you can't do a similar trick with   foo { bar = baz } if not all the constructors of foo's type have a bar field
10:04:49 <Marvin--> NonTermination :: Exception... I wonder when that one's thrown
10:04:51 <Igloo> esap: WDYM?
10:05:11 <Igloo> I do it in places it can't happen so that -Wall only gives me warnings I don't expect
10:05:34 <Igloo> Marvin--: ghc will spot things like foo = foo and throw an exception
10:05:39 <edwinb> esap: I guess you mean that if you think it can't happen, and it really can, then the compiler will warn you?
10:05:44 <Marvin--> Igloo: ah, neat
10:05:48 <Igloo> Prelude> let foo = foo in foo
10:05:48 <Igloo> *** Exception: <<loop>>
10:06:20 <Marvin--> right
10:06:24 <esap> edwinb: well it depends. If I enable the warning, the compiler will warn in many places that I don't want it to warn. And if I don't, then I'll miss some cases where I'd want to know about it.
10:06:36 <Marvin--> > try (let foo = foo in foo) >>= print
10:06:36 <Marvin--> Left <<loop>>
10:06:36 <Marvin--> nifty
10:06:53 <edwinb> I would guess that it's undecidable for Haskell anyway.
10:07:54 <esap> edwinb: I don't think it's undecidable. I think there are extensions you could make for it that make it undecidable [consider boolean guards to be pattern matching], but I'd expect that's not a problem.
10:08:31 <edwinb> I do. If you have foo (Just x) = bar, and no foo Nothing, how can the compiler know if foo Nothing can't happen?
10:08:39 <Marvin--> hmm, so I wonder if I should have a multi-purpose Compat.H98 module, and possibly use ifdef inside it, or if I should break it down in tiny pieces (Compat.H98.EitherMonad...)
10:08:52 <esap> edwinb: because what you really want to do is for the programmer to be able to tell which situations are "ok" to be partially matched and which are not.
10:09:05 <RussellOConnor> I think it is pretty undecidable.
10:09:10 <esap> edwinb: From the type of the function.
10:09:22 <edwinb> The type is just "Maybe x -> something"...
10:09:29 <edwinb> Nothing in there that says it can't be "Nothing".
10:09:34 <edwinb> You can do it with dependent types, of course ;)
10:09:42 <esap> edwinb: That type is wrong.
10:09:55 <edwinb> foo (Just x) = bar isn't of type Maybe x -> something?
10:10:12 <esap> edwinb: Well it is, currently. But that's not a good idea.
10:10:21 <edwinb> Of course not. You're arguing for dependent types here...
10:10:40 <esap> edwinb: I'm arguing for finding a solution to this problem. Dependent types are just one solution to it.
10:11:02 <edwinb> Right. It's not going to happen in Haskell as we know it, I fear.
10:11:08 <esap> edwinb: refinement types are another. I think subtraction types are yet another.
10:11:11 <RussellOConnor> Better rewrite it as foo x = bar
10:11:18 <RussellOConnor> of type X -> something.
10:11:31 <RussellOConnor> :-)
10:11:32 <edwinb> In this case, yes.
10:11:59 <RussellOConnor> Would you be able to come up with a new data type to suit every case?
10:12:16 <RussellOConnor> Or maybe there is a generic problem that I'm not seeing.
10:12:38 <esap> russell: Yes, I guess you could declare 'subtypes' of algebraic data types or something like that.
10:13:26 <esap> russell: That's actually the way refinement types work, you are allowed to explicitly declare a subtype.
10:16:35 <esap> russell: ... based on what uses of constructors are part of the subtype, and what are not.
10:20:03 <edwinb> I think "tail" is a better example.
10:20:11 <edwinb> tail [] is clearly nonsense, but there's nothing to stop you doing it.
10:21:17 <RussellOConnor> data NonEmptyList a = NonEmptyList a [a]
10:21:23 <esap> don't get me started on how projections have been ill-typed :-)
10:21:43 <RussellOConnor> Actually that is a pretty terrible road to head down.
10:22:11 <RussellOConnor> projections are ill-typed?
10:22:20 <esap> like head and tail.
10:22:23 <edwinb> RussellOConnor: this only works at the top level though
10:22:50 <RussellOConnor> head and tail aren't projections. ... I don't think.
10:23:15 <RussellOConnor> hmmm
10:23:22 <esap> head and tail both should have type: head :: (Monad m) => [a] -> m a and tail :: (Monad m) => [a] -> m [a]
10:23:30 <edwinb> They ought to be though. If the input is a non-empty list.
10:23:53 <RussellOConnor> esap: Let's change that in HaskellTwo!
10:24:06 <Cale> Shouldn't the monad type used have a zero?
10:24:20 <Cale> or do you just mean to call fail?
10:24:33 <esap> cale: Yes, call fail, like with pattern matching.
10:24:40 <edwinb> That's a run-time error though...
10:24:50 <edwinb> ...which is what you said wasn't good enough earlier.
10:24:54 <esap> yes, but at least the type says it'll produce the run-time error.
10:24:55 <RussellOConnor> fail isn't a run-time error in the Maybe monad.
10:26:08 <esap> edwinb: No, this issue is different in the sense that it's OK to have run-time errors _when_ it's clear to everybody that this is the case. And the type will make it immediately obvious that the run-time error will occur.
10:27:09 <esap> edwinb: But if it's hard to determine whether run-time error will occur or not, then there is a problem. You shouldn't be required to _assume_ that a run-time error doesn't occur if it somehow still can occur.
10:27:46 <esap> edwinb: and using 'head' and 'tail' currently do involve assuming that the list is not empty, for example.
10:27:49 <edwinb> There are type systems in which a run-time error can be shown to be impossible, though.
10:28:14 <esap> edwinb: And if this is not a correct assumption, I'd expect the type system to warn me about this.
10:29:11 <edwinb> I'm not disputing that...
10:29:26 <edwinb> But I am saying we can do even better.
10:30:20 <esap> edwinb: Sometimes you _want_ the error to be deferred to run-time. Then it's OK to get a run-time error, since then it's part of the design.
10:30:30 <edwinb> Then pick a different type!
10:30:46 <edwinb> Sometimes you want it to be a compile-time error...
10:32:12 <esap> edwinb: I sometimes actually do that, not for lists [I rather not use head and tail], but sometimes I do use a non-empty list type, which cannot be constructed to be empty.
10:33:14 <esap> edwinb: But building all those projections by hand is a bit verbose for doing something this simple.
10:33:26 <edwinb> Yes, I'm not saying we should all do it in Haskell
10:33:40 <edwinb> For one thing, tail (tail x) no longer works that way...
10:33:41 <Marvin--> meh, darcs what suggests that I should probably stop hacking on this before I discuss it with the syntaxninja
10:35:04 <esap> edwinb: that's ok, you're supposed to perform error checking on it unless you _know_ that you have enough elements in the list.
10:36:55 <esap> edwinb: And I guess the only way currently to know that is to have already been pattern matched against that.
10:37:44 <aFlag> what's wrong with this code http://rafb.net/paste/results/BU9vLS78.html ?
10:38:00 <esap> edwinb: But if so, then you should be able to use the information obtained from that pattern match to determine that it's ok not to check.
10:38:36 <Marvin--> aFlag: you need to use 'return' to create monadic values
10:38:50 <aFlag> like return []?
10:39:07 <Marvin--> aFlag: yes
10:39:51 <RussellOConnor> that num:doReading at the bottom will need some work
10:39:59 <Marvin--> note that the recursive call to doReading has type IO [Int], so you need to bind it to a variable (like with getLine) before you can prepend num to it
10:40:13 <aFlag> hum...
10:40:16 <RussellOConnor> ahh that's it
10:40:18 <edwinb> esap: Sure, you can do it by hand. I just prefer the dependently typed way.
10:40:38 <edwinb> that is, without the error checking.
10:40:52 <RussellOConnor> else do { nums <- doReading; return num:nums; }
10:41:11 <Smerdyakov> Num-nums!
10:41:15 <Marvin--> RussellOConnor: return (num:nums)
10:41:18 <aFlag> other thing, i don't really get when i should use do, the tutorial said it was for multiple commands, but that need to use return and stuff are because of the do or the IO thing?
10:41:55 <Smerdyakov> aFlag, in the context of IO, you use do for sequencing computations that have a defined order.
10:42:02 <Marvin--> aFlag: the do is needed because of the IO
10:42:08 <Smerdyakov> aFlag, order usually doesn't matter in Haskell.
10:42:09 <esap> edwinb: right, actually that's a good point. There are more than one style you might want to use for it for different purposes.
10:42:42 <aFlag> hum... ok, thanks
10:42:54 <RussellOConnor> do says: ``the follwing is a list of Monad commands I want put together''
10:42:55 <RussellOConnor> return makes a trival monad command
10:43:18 <edwinb> I prefer my functions to be total, where possible, but of course it isn't always possible and perhaps it's not even desirable sometimes.
10:43:37 <edwinb> But I can't imagine when I'd ever want a runtime error...
10:44:35 <esap> edwinb: If there is a problem with user input, I guess you want a runtime error.
10:44:37 <aFlag> hum... functional programming is different from everything I know, it's like learning to program all over again eheh
10:45:01 <RussellOConnor> aFlag: programming with Monads is pretty crazy at first.
10:45:05 <Smerdyakov> aFlag, I think you should view it more optimistically: It's like learning to program _for_real_.
10:45:23 <aFlag> if you use IO in a function it becomes a monad function?
10:45:26 <Smerdyakov> aFlag, you'll realize that there were things you never really learned in other programming settings, and it's just that functional programming prevents you from taking shortcuts.
10:46:31 <edwinb> esap: I wouldn't say so - I'd want to report an error to the user and then let them try again.
10:46:46 <esap> edwinb: Right, but a run-time error is exactly for that purpose.
10:46:52 <RussellOConnor> aFlag, that's pretty much the case.  If you use IO in a function, then you need sequenced too, since all IO must be sequenced.
10:46:58 <edwinb> No, a runtime error bombs out completely.
10:47:22 <edwinb> It should report an error, of course, but I'd want to hand 
10:47:24 <edwinb> le it more gracefully
10:47:41 <RussellOConnor> do says: “the follwing is a list of Monad commands I want put together in this particular sequence”
10:47:52 <Riastradh> That's a very particular interpretation of the term 'run-time error,' edwinb.  A run-time error is merely something that's incorrect at run-time.
10:49:09 <esap> edwinb: All exception handling is run-time. The problem with (some) run-time errors is that if the exception you raise does not provide enough information to actually recover from the error, then there is not much you can do to fix it.
10:49:43 <esap> edwinb: but normally you should catch all errors in interactive programs and let the user do something.
10:50:41 <edwinb> Riastradh: The sort of run-time error I'm talking about is the sort that crops up due to a pattern match failure... which *is* very particular.
10:51:15 <Marvin--> edwinb: which can still be caught
10:51:29 * edwinb sighs
10:51:36 <esap> edwinb: and the errors raised by 'head' and 'tail' for empty lists are very good examples of how such run-time errors, if they occur in unknown situations, can make things difficult [there is not enough information to recover].
10:51:51 <edwinb> Yes, that's why we can stop them with a decent type system...
10:52:22 <Marvin--> but isn't dependent typing pretty darn complicated?
10:52:30 <Riastradh> Types are hardly enough for all errors of this sort.
10:52:44 <edwinb> I'm not saying they are, I started talking about a very specific problem...
10:53:06 <esap> marvin: yes. Though for some extent that just reflects the difficulty of the problem they are intended to solve.
10:53:46 <Marvin--> true
10:54:02 <edwinb> I'm suggesting that a compile time error, where possible, is better than a run time error. Fewer bugs that way.
10:54:11 <edwinb> It's not always possible, or easy, naturally.
10:54:20 <Marvin--> what I mean is that there are practical problems involved in implementing it
10:54:25 <edwinb> (Incidentally, I don't think dependent types are always darn compicated)
10:54:45 <edwinb> Sure there are, most of which are solved...
10:54:50 <edwinb> no, not most. many.
10:55:23 <Marvin--> but not all, and there's the rub :-)
10:55:43 <esap> I think the practical problems of implementation are much less than the practical problems caused by not implementing it :-)
10:56:34 <edwinb> We know enough to implement a usable language, certainly.
10:57:25 * esap is writing a compiler, btw.
10:57:59 <edwinb> esap: For what kind of language?
10:58:31 <esap> edwinb: functional language based on category theory.
10:58:37 * edwinb runs screaming
10:58:45 <edwinb> You said the "c" word ;)
10:58:59 * Riastradh shouts 'Category theory! category theory! category theory!' at edwinb.
10:59:24 * esap suggests people don't hold their breath on that one though, I'm nowhere near being able to specify a type system for it.
10:59:27 <Riastradh> We are the knights who say...category theory!
10:59:36 <tautologico> category theory
10:59:50 <tautologico> say we have a CCC
10:59:59 <edwinb> Category theory has been something I haven't quite got around to learning for the last 4 years or so...
11:00:12 <edwinb> people keep telling me not to bother
11:00:21 <Riastradh> Bother.
11:00:27 <edwinb> Thanks ;)
11:00:45 <edwinb> Whereas I'd like to know this special secret language that everyone else seems to understand.
11:01:12 <Marvin--> edwinb: you're not alone :)
11:01:23 <Smerdyakov> Maybe it makes sense for Europeans to learn.
11:01:33 <Smerdyakov> It's not so popular in the USA.
11:01:44 * esap suggests reading Categorical primer and Categorical manifesto.
11:01:56 <Smerdyakov> As in, you will screw yourself out of research funding opportunities by focusing too much on it. ;)
11:02:05 <cm> esap: available online?
11:02:13 <edwinb> I'd like something which just links Category Theory concepts to type theory concepts, since there seems to be a pretty direct mapping in lots of cases.
11:02:40 <esap> cm: yes. http://citeseer.ist.psu.edu/goguen91categorical.html for categorical manifesto.
11:02:56 <esap> cm: http://citeseer.ist.psu.edu/487012.html for the primer.
11:03:49 <tautologico> edwinb, there's a book called "Categories for Types" by Roy Crole
11:03:59 <edwinb> I think I've seen that one
11:04:01 <cm> thanks
11:04:30 <esap> Categories for types is a good one as well, though at times requires some background knowledge.
11:04:35 <poing> wow i shoulda been paying attention over here
11:05:03 * edwinb will have a look some time
11:06:03 <poing> categorical imperative ... i'm not going to have to read Kant before this paper, am I? ;)
11:06:20 <Smerdyakov> poing, yes. Yes, you are.
11:06:47 * esap would suggest reading Kant anyway.
11:07:50 * poing eeeeek
11:08:06 <Smerdyakov> I've always found that reading fiction is more enlightening than reading philosophical tracts.
11:08:18 <poing> i was drawn to logic when taking philosophy.  as a result, i have a real distaste for doublespeak
11:09:03 <esap> smerdyakov: that's because philosophy has been limited to handle only very narrow part of things. You need to add all of mathematics to it and then it starts to make sense :-)
11:09:11 <poing> but i'll give him points for not using the philosophy to prop up theological arguments, ala descartes
11:10:34 <Marvin--> heyy, syntax
11:10:46 <Marvin--> I was just going to send you a longwinded mail
11:13:35 <SyntaxLaptop> Marvin--: hey :)
11:13:41 <SyntaxLaptop> well, glad I headed that off by loggin inm ;)
11:13:49 <SyntaxLaptop> all I can say is 'windows is dumb' by the way
11:14:09 <Riastradh> You just figured this out, SyntaxLaptop?
11:15:42 <SyntaxLaptop> well, I keep hearing that, but I never knew for sure
11:16:01 <SyntaxLaptop> my gf has a windows partition that we use, apparently not very often, because suddenly, it wants me to "register with microsoft"
11:16:12 <SyntaxLaptop> but I swear we've used it before. does it just make you do that 1x a year or something?
11:19:03 <poing> hardware change a lot?
11:19:28 <SyntaxLaptop> hmmm. nop
11:19:28 <SyntaxLaptop> e
11:19:59 <poing> dunno.  sort of annoying to have to warez your legitimate product
11:20:24 * poing has a legit win2k, but the OEM shipped him win98 CD's instead
11:20:24 <Smerdyakov> My solution: Stick to Windows 98 in situations where there is a compelling reason to run Windows.
11:20:29 <SyntaxLaptop> So this one time, someone stole my gf's computer.  She got a new one just like it. then it stopped working. I opened it up...
11:20:29 <SyntaxLaptop> and inside, the zip drive wasn't connected.
11:20:29 <SyntaxLaptop> I was like, "hmmmm"
11:20:29 <SyntaxLaptop> then I looked at the graphics card... it was the one from the _old_ computer!
11:21:13 <poing> so i had to get someone to burn me a new CD
11:22:02 <Riastradh> The exact same graphics card?
11:22:41 <SyntaxLaptop> someone had come in and swapped out the new computer for the old one and moved the zip drive (which the old one didn't have) but of course didn't realize that the graphics card was different.
11:22:41 <SyntaxLaptop> but unless that has happened again... this should be the same hardware as last time.  there maybe is one new card, though.
11:22:48 <SyntaxLaptop> Smerdyakov: I don't have windows 98. I have XP, and I'm not going to buy it.
11:23:27 <SyntaxLaptop> Riastradh: the card I added is a pcmcia card.
11:23:32 <SyntaxLaptop> but it's a desktop
11:23:40 <SyntaxLaptop> so you know, the pcmcia card-card
12:01:39 <aFlag> hum... someone came here and closed a bunch of stuff
12:08:50 <RussellOConnor> while cond command = do check <- cond
12:08:51 <RussellOConnor>                         if check then liftM2 (:) command (while cond command)
12:08:53 <RussellOConnor>                                  else return []
12:09:02 <RussellOConnor> Is this already defined somewhere?
12:10:06 <aFlag> now, what's wrong in this code: http://rafb.net/paste/results/XxejV569.html ?
12:11:00 <RussellOConnor> aFlag, doReading is an IO thing right?
12:11:09 <aFlag> yes
12:11:25 <RussellOConnor> aFlag, so you need to sequence it
12:11:34 <RussellOConnor> Try the following
12:11:41 <Cale> aFlag: try   lista <- doReading
12:11:59 <RussellOConnor> main = do lista <- doReading
12:12:00 <RussellOConnor>                  return $ foldr 0 lista
12:12:13 <Cale> RussellOConnor: forgot the (+)
12:12:18 <aFlag> i was trying that but i didn't realise i needed the do
12:12:22 <RussellOConnor> right
12:12:48 <RussellOConnor> But if you want to see the output you need to print it.
12:13:03 <Cale> yeah
12:13:10 <RussellOConnor> main = do lista <- doReading
12:13:12 <RussellOConnor>                  print $ foldr (+) 0 lista
12:13:26 <aFlag> what's the $?
12:13:39 <Cale> aFlag: it's low precedence function application
12:13:53 <Cale> so that's like  (print) (foldr (+) 0 lista)
12:14:04 <aFlag> oh, i see
12:14:19 <aFlag> what's the difference between print and putStrLn?
12:14:21 <RussellOConnor> $ says everything after me is just one parameter.
12:14:32 <Cale> print = putStrLn . show
12:14:34 <RussellOConnor> putStrLn requires a tring
12:14:38 <RussellOConnor> a string
12:14:41 <aFlag> oh, i see
12:14:50 <aFlag> nice
12:15:02 <Cale> if you use print on a string, it will quote it
12:15:06 <aFlag> things are starting to get less confusing :D
12:15:19 <Cale> :D
12:15:21 <aFlag> thanks guys
12:16:31 <Cale> and depending on your version of GHC, you might not need to set the buffering, though I know the tutorial says to do it :)
12:16:46 <Cale> Recent versions set the buffering sanely
12:28:18 <RussellOConnor> okay, now I gotta learn how to put two monads together.
12:31:06 <aFlag> oh, i think it's about the last version
12:31:20 <Marvin--> RussellOConnor: ooh, monad transformers, fun fun :-)
12:31:26 <aFlag> i got it on the home page like 3 months ago
12:39:19 <RussellOConnor> I want to add an Error Monad to a State Monad.
12:40:41 * RussellOConnor thinks about the order they should be added in.
12:41:14 * RussellOConnor decides I want an ErrorT State Monad
12:50:19 <gejun> Hi guys, a question.  how to simplify the twoOrThree in the following definition. 
12:50:24 <gejun> span (twoOrThree) [3, 2, 3, 1, 2, 4] where twoOrThree x = (x == 2) || (x == 3)
12:51:02 <Igloo> span (`elem` [2, 3]) [3, 2, 3, 1, 2, 4]
12:51:32 <Riastradh> Or use pointless arrow operators.
12:51:37 <Igloo> Although yours will probably be more efficient
12:52:35 <gejun> what is wrong in this definition?  span (==2 | ==3) [3, 2, 3, 1, 2, 4] 
12:53:02 <dv> this is probably a stupid question, but when I run main in hugs it just returns "<<IO action>>", why isn't it running it?
12:53:05 <Igloo> It's not Haskell 98
12:53:23 <Igloo> dv: Give it a type signature
12:53:26 <Igloo> i.e. main :: IO ()
12:54:11 <dv> oh, i see. thank you
12:54:28 <Smerdyakov> gejun, you are making up your own syntax that is not really part of Haskell.
12:54:59 <gejun> I see.  One more question, what is pointless arrow operators?
12:55:16 <Igloo> gejun: There were some messages about doing that sort of thing on one of the mailing lists recently, though
12:55:29 <Riastradh> Arrow operators that allow for a pointless style.
12:55:48 <Riastradh> (Pointless is a pun on 'point-free.')
12:56:08 <Marvin--> everybody's favourite haskell pun
12:56:52 <gejun> can you give me a link about that?  I am new to haskell
12:57:14 <gejun> Igloo:  thank you I am looking for it now.
12:57:28 <Riastradh> Don't worrry about it, gejun.
12:57:52 <TheHunter> you might do "Prelude Control.Monad.Reader> span (liftM2 (||) (==2) (==3)) [3, 2, 3, 1, 2, 4]", but i think Igloo's answer is much more practical
13:00:13 <gejun> I feel difficult in understanding monad, could someone give a good reference for it?
13:00:47 <Riastradh> Monads are generalizations of sequential computations.
13:00:52 <Smerdyakov> gejun, monads are an interface for composing computations sequentially. There's not really anything more to it than that.
13:01:37 <TheHunter> http://www.haskell.org/hawiki/UsingMonads has a lot of links
13:02:38 <gejun> I think your one sentence summarizing is cool but I still need to read more to understand it :)
13:02:41 * RussellOConnor still a little confused as how the order of monad transformers works.
13:03:02 <SamB> I think that is the best summary I've seen so far
13:03:12 <Riastradh> gejun, it's really simple.  Consider a computation c.
13:03:22 <Riastradh> It has a single result value v.
13:03:45 <Riastradh> c might itself be a simple unit computation, i.e. it might be 'return v'.
13:04:00 * gejun listening to Riastradh
13:04:14 <RussellOConnor> It important to realize that an IO foo, is quite different from a foo.   A foo is a foo.  An IO foo is a sequence of IO operations that will, someday, result in a foo.
13:04:20 <Riastradh> The value v may be mapped to another value, w, with fmap.
13:04:33 <Riastradh> Oh, I probably ought to annotate some types:
13:04:42 <SamB> perhaps several different foos, from several different ivokations
13:04:44 <Riastradh> c :: m a   -- m is a kind of monad.  It doesn't matter what.
13:04:58 <Riastradh> v, w :: a
13:05:17 <Riastradh> Actually, no, make that:
13:05:18 <Riastradh> v :: a
13:05:21 <Riastradh> w :: b
13:05:28 <Riastradh> fmap :: (a -> b) -> m a -> m b
13:06:08 <Riastradh> 'fmap f c' applies f to v, which results in w, and produces a new computation, d :: m b, whose value is w.
13:06:29 <Riastradh> A computation might be considered just a simple box with a value stored therein.
13:06:51 * gejun gejun keeps reading
13:07:01 <Riastradh> fmap opens the box, applies f, creates a new box -- of the same sort as the original -- that contains the value f returned, and returns the new box.
13:08:01 <Cale> fmap applies f to everything in the box :)
13:08:15 <Riastradh> ...er, yes, s/applies f/applies f to the contents of the box/1.
13:08:46 <Cale> you can skip the way that it does this and just accept that it does it somehow :)
13:08:56 <Riastradh> Does this so far make sense?
13:09:32 <gejun> I am reading and thinking.  Sorry I am slow
13:09:54 <Smerdyakov> gejun, I would describe things differently. First, do you understand how order of evaluation is unimportant in normal Haskell code?
13:10:21 <gejun> not much
13:10:54 <gejun> it is important in understanding monad?
13:11:00 <Smerdyakov> gejun, well, it's illustrated by silly questions like: "In calculating 1 * 4 + 2 * 3, do you need to evaluate the 1 * 4 or the 2 * 3 first?"
13:11:20 <gejun> OK.  Pls continue
13:11:20 <Smerdyakov> gejun, in functional code, "order of evaluation" is meaningless. You describe _what_ to compute, not _how_ to compute it.
13:11:30 <Smerdyakov> gejun, there are no "side effects."
13:11:35 <gejun> I see it now
13:11:59 <Smerdyakov> gejun, so, in Haskell, evaluation can be viewed as simplifying the program in whatever order you want until you get a final answer.
13:12:13 <Cale> The IO monad provides a way to handle those computations that we want to have side effects.
13:12:14 <Smerdyakov> gejun, good so far?
13:12:28 <gejun> yes, pls go on
13:12:42 <Smerdyakov> gejun, monads provide an interface for describing computations where order _does_ matter.
13:13:12 <Smerdyakov> gejun, you can think of monads as basically providing a function composition operator that enforces that the first function must run before the second function, even if the second function doesn't use the first function's result.
13:13:38 <Smerdyakov> gejun, this composition is also special: there is arbitrary state, specific to each kind of monad, preserved across a sequence of function compositions.
13:13:49 <Cale> However, I don't like this way of thinking very much, as it seems to imply that calculations in a monad are strict, which isn't true.
13:14:06 <Cale> (at least, not in general)
13:14:31 <Smerdyakov> Cale, the monadic operations define a separate language, embedded in Haskell, in which everything _is_ strict.
13:14:59 <Cale> Smerdyakov: you can still, say, use the list monad, and get lazy results.
13:15:05 <Riastradh> It's just that the computation is enclosed in its own little world as a Haskell value.
13:15:17 <gejun> Smerdyakov: can you give me an example of the application of the idea you mentioned in IO?
13:15:35 <Riastradh> gejun, the IO monad's state is the state of the outside world.
13:15:37 <Smerdyakov> gejun, sure. I'll probably use the wrong names of functions.
13:16:03 <Smerdyakov> gejun, getStr >> \name -> putStr ("Hello " ++ name ++ "!")
13:16:07 <Riastradh> Computation in the IO monad performs actions that operate on the outside world.
13:16:20 <Smerdyakov> gejun, getStr is a function to read a string, with no input. Its output is fed to the function that takes name as an argument.
13:16:20 <Cale> (>>=)  :)
13:16:58 <Smerdyakov> gejun, the whole state of the world is theoretically threaded throughout a chain of IO compositions.
13:17:24 <RussellOConnor> Cale, I think of a list monad as the non-deterministic Identity monad.  Anyways, sequentail doesn't mean strict, although in most monads, we end up with strictness.
13:19:20 <Cale> Here's the way that I think of monads, though it seems that most people currently don't think of them this way. A monad is just a generalisation of a container type. You can make a container with a single element in it, you can apply a function to all the elements of a container, and you can take a container of containers of objects and join them together into a container of objects.
13:19:30 <gejun> getStr is a monad here, right?
13:19:43 <Cale> getStr is a value of type IO String
13:20:04 <Cale> In my way of thinking, it's a box with some string in it.
13:20:18 <Riastradh> It's sort of hard to say what 'a monad' is.
13:20:35 <RussellOConnor> :-) There are two types of people in the world:  Those who think monads are containers, and those who think that monads are sequences of computation.
13:20:43 <Cale> RussellOConnor: yeah
13:20:51 <Riastradh> RussellOConnor, they're both; the computation is a kind of container.
13:21:04 <poing> it's a box with a sequence
13:21:08 <poing> you get into the box at one end
13:21:13 <poing> and get a value out at the other
13:21:21 <Riastradh> No, it's a sequence of box states composed by functions.
13:21:21 <Cale> I usually find that "containers" are easier to think about than "models of computation", but that's just me :)
13:21:29 * RussellOConnor doesn't really like the containter view point.
13:21:29 <poing> it's a box of boxes
13:21:48 <poing> boxes are good.  people can identify with boxes.
13:21:49 <gejun> confused more than before ;)
13:21:58 * RussellOConnor perfers non-deterministic computation instead.
13:22:05 <poing> non-mathematics folks can't deal with category theory
13:22:05 <Cale> gejun: try reading the start of UsingMonads
13:22:07 <gejun> thank you, I think I understand better now.
13:22:19 <gejun> OK, I will read it.
13:22:40 <poing> i was always terrible at math.  verbal skills are my forte
13:23:15 <RussellOConnor> I liked `All About Monads': http://www.nomaware.com/monads/html/index.html
13:23:20 <Cale> yeah
13:23:27 <RussellOConnor> http://www.nomaware.com/monads/html/analogy.html was okay too.
13:23:28 <Cale> All About Monads is really quite good
13:23:57 <poing> stuff like haxml and haskelldb is just stunningly awesome for real world use
13:24:14 <poing> but it's so hard for the language to be accessible to the average perl hacker
13:24:18 <poing> or even C hacker
13:24:20 <Cale> >>= is now my favourite function -- I've been using it so much with lists lately. :)
13:24:58 <ayrnieu> poing - s/accessible/immediately $&/
13:25:28 <poing> ayrnieu: the learning curve is nearly vertical.  so when you finally figure it out, it's like "kwatz!" and you're enlightened
13:25:35 <Cale> I think Haskell is pretty accessible to anyone willing to put in some effort to learn to program again :)
13:25:43 <poing> some people like climbing mountains.  others prefer hiking up hills
13:25:55 <Cale> It's not that the slope is any steeper than programming in any other language.
13:26:14 <RussellOConnor> I don't like the containter analogy because if getChar :: IO Char were a box containing a character, then you'd think each instance of getChar would contain the same character.
13:26:21 <Cale> It's just that if you thought you were already on top of the mountain, it seems striking that you're not :)
13:26:21 <poing> Cale: i agree, but it's hard for people to learn to program from the pure CS mathematics viewpoint, most people have learned it as verbal expression
13:26:39 <RussellOConnor> I should shut up before I confuse gejun even more.
13:26:45 <ayrnieu> poing - or, rather, it simply doesn't offer itself as immediately hackable to people who only know languages such as Perl or C.  You can still hack it after you'd spent a little bit of time on it -- and you certainly don't need that 'pure CS mathematics viewpoint'.
13:27:02 <poing> RussellOConnor: it would, if it were deterministic.  but they're "black boxes", nondeterministic
13:27:18 <Cale> RussellOConnor: it's a box that contains a single string that you don't know yet, and the user is going to have to type
13:27:27 <RussellOConnor> getChar is not non-deterministic either.
13:27:39 <RussellOConnor> err, getChar is deterministic
13:27:46 <ayrnieu> russell - not in the context of the state of the world, no =)
13:27:59 <Cale> It deterministic in a nondeterministic way :)
13:28:05 <poing> uh
13:28:08 <Cale> hehe
13:28:14 <skew> I like the phrase "computation producing a Char" for IO Char
13:28:19 <Cale> yeah
13:28:21 <RussellOConnor> all IO is most definitely deterministic.
13:28:25 <poing> deterministic to me means you get the same result back every time you call it with the same args
13:28:31 * RussellOConnor is with skew
13:28:35 <skew> RussellOConnor: not from the point of view of the program
13:28:41 <Cale> There are two meanings of determinism here
13:28:56 <ayrnieu> poing - I'd suggest the introductory section of concurrent-haskell.ps for that.
13:29:06 <poing> deterministically nondetermistic ... that's, uh ...
13:29:13 * poing grabs his head before it explodes
13:29:19 <Cale> There's determinism in the sense "produces a single result" and there's determinism in the sense "always produces the same result"
13:29:23 <ayrnieu> poing - just read the nice academic paper.
13:29:24 <poing> i get a lot of moments like that learning haskell
13:29:38 <poing> ayrnieu: got a url i can bookmark?
13:29:43 <ayrnieu> poing - no.
13:29:44 <skew> perhaps it's possible to predict what the user is going to type ten minutes from now if you slice their brain up finely enough...
13:29:50 <Cale> It produces a single result, but not always the same result.
13:29:58 <RussellOConnor> Cale, I see the confusion now
13:30:07 <poing> skew: one would imagine such a slicing process would affect the results somewhat
13:30:14 <poing> like "ow, you're slicing my brain"
13:30:42 <skew> if penrose is sufficiently correct
13:30:49 * RussellOConnor monad transformers are slicing up his brain.
13:31:21 <poing> ok, it's deterministic in that it returns "something", as long as you only care about the type of "something" and not the value?
13:31:24 <Cale> * RussellOConnor needs to remember what /me does grammatically. :)
13:31:35 <poing> i thought it wasn't even deterministic that way, i.e. it could fail
13:31:36 <skew> but yeah, I see there are two senses of determanistic here
13:32:01 <skew> one in the sense of nondetermanistic computation, and the other not knowing what the result will be
13:32:13 <ayrnieu> poing - no.  Please do read the academic paper.
13:32:27 <poing> ayrnieu: on concurrent haskell?
13:32:43 <ayrnieu> poing - you probably just want the introductory section of it, just yet, as I said.
13:33:07 <poing> got it in my reading list
13:33:14 <skew> a paper?
13:33:18 * poing is hoping to get outside sometime today
13:33:47 <RussellOConnor> right
13:33:53 <Cale> I think one of the things that makes monads really hard to understand is that the people who will try to teach you about them are CS and Math students ;)
13:33:57 * RussellOConnor is having his brain sliced up by Monad Transformers.
13:34:02 <RussellOConnor> much better
13:34:26 <poing> that's the point i'm getting at
13:34:48 <Cale> I tried to get away from complicated jargon in my explanation at UsingMonads
13:35:06 <poing> maybe it's not possible to grasp the totality of haskell without the pure CS, but i'm not sure i buy it
13:35:26 <Cale> Though I now think that perhaps using map, join and return would have helped the intuition work better.
13:35:56 <poing> if hofstadter can introduce number theory to literary geeks, there's gotta be layman's explanations for the theory in haskell
13:36:07 <Cale> I think it's quite possible to understand everything here. We just need to find good tricks with analogies to teach it all to people.
13:36:09 <skew> poing: I could believe you need to understand CS theory to understand Haskell
13:36:35 <Cale> And it's worth doing that, because it helps us understand it better too :)
13:36:58 <poing> introductions to the cs theory are helpful.  i'm liking the category theory introduction so far
13:37:01 <skew> not in the sense that it's a prerequisite, but just because Haskell is a sufficiently pure expression that by the time you've understood it completely you've got the rest...
13:37:15 <poing> e.g. where it says topology is like a language where verbs have the footing of nouns
13:37:52 <skew> hmm, I don't have a good analogy
13:38:36 <skew> Cale: CS-and-Math students explain monads poorly?
13:38:46 <Cale> skew: I'm half kidding :)
13:38:49 <poing> they explain them with math
13:39:05 <gejun> hi folks, I am familiar with imperative programming.  What's functional language's advantages compared with imperative language?
13:39:08 <poing> sadly, we're a math starved culture
13:39:13 <Cale> skew: but yes, to people who don't understand the mathematics, mathematical explanations are not so useful.
13:39:26 <skew> I could see us using big scary words to say what a monad is, but the real problem is explaining how they relate to programming
13:39:45 <poing> rethinking "programming" is a big scary thing
13:39:45 <Cale> gejun: well, for one, functions are first class, and can be passed around like values.
13:39:49 <skew> what discipline has big scary words for relating programming to mathematical structures?
13:40:12 <poing> category theory
13:40:21 <gejun> function pointers can also be passed as arguments.
13:40:45 <poing> gejun: imagine not having to use special "pointer" syntax
13:40:53 <skew> gejun: it goes a bit deeper than that. like, if you have an add function, you can pass around "add 2"
13:41:18 <skew> function pointers (at least in C) can't save any of the state of the function
13:41:26 <Cale> You also have higher order functions, which take functions as arguments and produce other functions.
13:41:35 <Cale> like map, for example
13:41:58 <poing> gejun: now without any pointer syntax, imagine making up new functions on the fly.  like "sort this list of names, where you drop "Mc" and "Mac" before the last name, then use the standard alphabetical sort"
13:42:13 <poing> gejun that could translate into half a line of code in a FP language
13:42:29 <poing> without even defining a special "drop Mc/Mac prefix" function first
13:42:31 <skew> gejun: another thing that's quite useful is being able to define functions that don't depend on state
13:42:33 <gejun> this makes sense, to some extent :)
13:42:47 <skew> gejun: and where the compiler will check that for you.
13:42:47 <poing> gejun: it's about expressivity like that
13:43:01 <RussellOConnor> You can create a function to be passed as an argument that has access to the local variables inside your program at that point.
13:43:01 <skew> that's useful becuase then you can test all your functions in isolation
13:43:11 <RussellOConnor> *whew* I think I need an example to explain that.
13:43:11 <Cale> gejun: also, at least with Haskell, you have something called "referential transparency" -- if you call a function with the same arguments, it *must* return the same value all the time
13:43:12 <poing> gejun: haskell takes the approach to an amazing extreme mind you
13:43:44 <Cale> referential transparency makes debugging easier
13:44:12 <Cale> you don't have to worry about some state variable being messed up
13:44:17 <poing> gejun: but in haskell, you get strong typing that's related to FP, so strong that, let's imagine an xpath query in XML.  you actually aren't able to complile a program that references an element that's impossible to exist in the schema
13:44:34 <poing> or you can't formulate an invalid join in a database query
13:44:42 <poing> won't bomb on runtime, it won't even compile
13:44:45 <poing> that's strong typing
13:44:50 <RussellOConnor> The purity found in Haskell is probably even more advantagous over ML, than the functional programming of ML over C++.
13:45:08 <RussellOConnor> Er, purity == referential transparency.
13:45:38 <skew> also the compiler figures out any types you don't specify for you
13:45:46 <skew> (at least until you do really crazy stuff :)
13:45:57 <Smerdyakov> RussellOConnor, I don't think I agree with that at all.
13:46:20 <poing> gejun: haskell specifically also has something called "lazy evaluation".  so you can do neat tricks like "take the first 10 lines of every line you'll ever see from this socket".  and it'll read the first 10 lines and give them to you without having to read everything
13:46:38 <RussellOConnor> Smerdyakov, You think functional is more imporant than purity?
13:46:50 <gejun> But I feel the following problem is a little against intuition if implemented in Haskell instead of in C.  Delete the second (or third, fourth) occurrence of x in a list ls.  delete_second x ls
13:46:50 <fraxtal> how is functional programming better than imperitive programming?
13:46:53 <Smerdyakov> RussellOConnor, yes, meaning that I think it has greater engineering benefits.
13:46:55 <Cale> hahaha
13:47:07 <Cale> fraxtal: that's the current discussion :)
13:47:13 <fraxtal> no shit?
13:47:16 <fraxtal> llol
13:47:16 <skew> fraxtal: ask gejun for logs :)
13:47:25 <poing> fraxtal: it's merely different.  it's worse for some tasks
13:47:35 <poing> i wouldn't want to write an IRC bot in pure FP code
13:47:49 <RussellOConnor> Isn't lambabot written is haskell?
13:47:56 <Cale> Me, I'd probably write an IRC bot in purely functional code :)
13:48:05 <Smerdyakov> gejun, the relevant question you should consider is how much of your "intuition" is based on past experience with imperative languages instead of any inherent advantage of a way of thinking about things.
13:48:06 <poing> it's possible.  it's just not always fun
13:48:07 <Cale> well, all but the IO for it
13:48:18 <shapr> wow!
13:48:29 <Cale> shapr: what's up?
13:48:29 <Igloo> Lots of things you want an IRC bot to do are essentially IO, though
13:48:40 <shapr> lots of TV watching....
13:48:43 <shapr> Cale: what's up with you?
13:48:46 <Igloo> e.g. @type, @dict
13:48:51 <poing> however, i write data mining code, FP is just pure gold for making sure i don't write queries that couldn't make any sense
13:48:52 <Cale> lots of IRC watching :)
13:48:55 <shapr> heh
13:48:56 <poing> which happens quite a lot
13:49:14 <shapr> anything exciting?
13:49:27 <poing> not that i write *formal* data mining code, just ad hoc knowledge extraction, "see what you can find out about xyz" stuff
13:49:44 * poing is a business analyst
13:49:47 <skew> gejun: deleting elements isn't too hard
13:50:07 <shapr> Cale: any nifty new papers lately?
13:50:22 <shapr> I am yet again wondering whether I should code or unicycle...
13:50:27 <gejun> fraxtal: you can read http://poirot.cs.iastate.edu/tmp/log.txt for the previews discusstion just before you join this channel.
13:50:51 <skew> delete_second l = take 1 l ++ drop 2 l
13:50:58 <SamB> in C its like "the red pointer, or the blue pointer?"
13:51:03 <shapr> there are also #haskell logs gathered by clog 
13:51:10 <SamB> and if you cut the wrong one, it goes boom!
13:51:13 <skew> gejun: actually, that makes a new list, but upi cam
13:51:26 <Cale> shapr: the last one I looked at was the GADT one
13:51:27 <skew> but you can't change values out from under other code using them
13:52:16 <skew> gejun: how often do you need to delete just the second element of a list, though?
13:52:34 <Smerdyakov> skew, I don't know, but I bet Microsoft has a certification on it!
13:52:52 <skew> mostly we use filter, which takes a test function and a list and returns a list of just the elements that passed the test
13:52:53 <SamB> bah, certification!
13:52:54 <gejun> skew: this is just an exercise I want to do :)
13:52:59 <skew> gejun: have you seen STL?
13:53:25 <skew> gejun: or worked in a language like Python with real first class functions?
13:53:47 <skew> gejun: well, you see my code above.
13:54:33 <shapr> personally, I think functional code is simpler to test and reuse than imperative code.
13:54:59 <shapr> poing: lambdabot is quite readable I think
13:55:02 <shapr> hiya ramiro 
13:55:09 <ramiro> hi
13:55:18 <shapr> looking for excitement in a procedural world?
13:55:38 <ramiro> what is haskell used for?
13:55:46 <skew> shapr: that barely made sense to us!
13:55:46 <ramiro> never really heard about it
13:55:49 <Cale> Haskell is general purpose
13:55:58 <Cale> What is C++ used for?
13:55:59 <Smerdyakov> What is going on?
13:56:00 <Cale> :)
13:56:04 <shapr> lambdabot is written in Haskell.
13:56:13 <Smerdyakov> Is it Super Bowl day, and did someone run a Haskell ad during a commercial break?
13:56:19 <shapr> skew: really? did you have a hard time reading lambdabot?
13:56:22 <shapr> @yow !
13:56:23 <lambdabot> RELATIVES!!
13:56:28 <shapr> lambdabot: bad bot!
13:56:28 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:56:46 <skew> shapr: no, "looking for excitement in a procedural world?"
13:56:49 <shapr> oh
13:56:50 <ramiro> so what is it used in in the industry
13:57:09 <skew> what does Allistair use it for?
13:57:09 <Cale> ramiro: I'm writing a compiler in it for my work at the moment.
13:57:16 <shapr> circuit design, speedy compiler implementation, programming language prototyping, that sort of stuff
13:57:28 <shapr> Alistair Reid uses it for Knit and friends
13:57:46 <skew> Knit looks pretty cool
13:57:57 <Cale> ramiro: For a new special purpose language for parallel and SIMD implementations of high performance signal and image processing algorithms.
13:58:03 <skew> if I coded more C I might use it
13:58:14 <shapr> bluespec is written in Haskell, cryptol is written in Haskell, Xilinx' Lava is written in Haskell
13:58:38 <shapr> skew: I was thinking about trying Knit and friends on the Linux kernel to find bugs
13:58:39 <ramiro> is there a language that is similar to it from the really popular languages?
13:58:48 <Smerdyakov> ramiro, yeah. Math.
13:58:52 <shapr> what counts as really popular languages?
13:58:55 <shapr> Smerdyakov: be nice
13:59:14 <ramiro> java, c, c++,
13:59:20 <ramiro> sml
13:59:20 <Cale> ramiro: no
13:59:25 <Cale> sml, perhaps
13:59:30 <RussellOConnor> Is there a function like isLeft : Either a b -> Bool  ?
13:59:48 <fraxtal> is haskell better than lisp
13:59:49 <fraxtal> ?
13:59:54 <ramiro> so its more functional?
13:59:56 <skew> RussellOConnor: either (const True) (const False) works
14:00:09 <Cale> fraxtal: I like to think so -- I like the fact that Haskell has syntax
14:00:20 <Riastradh> fraxtal, define 'better.'
14:00:25 <Cale> some people would disagree
14:00:31 <skew> lisp does different things
14:00:39 <shapr> I think that both Haskell and Lisp have their advantages, you should learn both to see which one you like better.
14:00:40 <fraxtal> lisp seems VERY hard to read to me
14:00:44 <skew> nothing in Haskell really approaches the lisp macros
14:00:45 <Cale> It's really a matter of taste and what you're doing.
14:01:26 <Cale> I find Haskell 10's of times easier to read than lisp, but I haven't spent huge amounts of time with lisp.
14:01:35 <Riastradh> fraxtal, compared with what?
14:01:47 <Riastradh> Languages that you've already spent a large amount of time getting used to?
14:02:10 <fraxtal> there's so many ( ) that it's hard to follow
14:02:59 <Riastradh> fraxtal, do you think whitespace is hard to follow?  Most languages have a hell of a lot of whitespace.  And a lot of them have semicolons and commas and stuff all over the place.
14:03:12 <Cale> Lisp has the disadvantage that sometimes it's hard to see where the brackets line up. I think this can be helped a lot by formatting, but it's too bad that there's no way to enforce this sensibly without changing things completely.
14:03:18 <fraxtal> no not really
14:03:40 <Riastradh> fraxtal, if you spent the same amount of time getting used to Lisp's syntax as you did getting used to, say, C's syntax, do you think you'd still have this trouble?
14:03:46 <Cale> It can also be helped a lot by using a good text editor.
14:04:03 <ramiro> what text editors do people use here
14:04:10 <Riastradh> I use Emacs.
14:04:10 <Cale> vim and emacs mostly
14:04:15 <Cale> I use both.
14:04:27 <Cale> I've just started to use emacs more.
14:04:45 <ramiro> Cale, how come
14:04:58 <ramiro> vim users are usually really hardcore about vim
14:05:04 <Cale> because I like haskell-mode, and the programmability is really cool
14:05:31 <Cale> It takes a while to get used to the keys, but they're almost as good as vim's :)
14:05:31 <skew> I use vim, but I haven't looked at emacs much
14:05:47 <shapr> I use both, but more emacs
14:06:04 <shapr> once again, they each have their advantages :-)
14:06:39 <Cale> sometimes modal editing is really good and sometimes it gets in the way
14:09:06 <aFlag> is there something wrong with this indentation:
14:09:08 <aFlag> factlist (x:xs) = do
14:09:08 <aFlag>                 print $ fact x 
14:09:08 <aFlag>                 if xs /= []
14:09:08 <aFlag>                    then factlist xs
14:09:10 <aFlag> ?
14:09:18 <Cale> where's the else?
14:09:26 <aFlag> you have to have the else?
14:09:33 <Cale> of course :)
14:09:42 <Igloo> You probably want when
14:10:06 <aFlag> i was doing it without the if and it was raising an exception
14:10:11 <Igloo> Well, in actual fact you want just   mapM_ print xs
14:10:31 <aFlag> how do i do so factlist doesn't get called if the xs is a empty list?
14:10:56 <Cale> when             :: Monad m => Bool -> m () -> m ()
14:11:05 <Igloo> IM mapM_ (print . fact) xs
14:12:10 <Cale> or just mapM, but you really don't care about the results here, so mapM_ is a bit cleaner version of that when you don't want the list of results
14:12:55 <aFlag> what's mapM_?
14:12:59 <Cale> mapM f as = sequence (map f as)
14:13:26 <Cale> and mapM_ is just a version of that that returns m () rather than m [b]
14:13:37 <Cale> (it throws away the results)
14:14:44 <Cale> sequence takes a list of actions and runs them all in order, producing a list of the results returned
14:15:03 <Cale> sequence_ is a version of that which ignores the results returned
14:16:04 <aFlag> hum... i just wroted else putStrLn "", crappy but worked hehe
14:16:37 <Cale> you could have also used  else return ()
14:17:46 <RussellOConnor> Whenever I make a new Monad,  I need to make things like instance (Error e, MyMonad m) => MyMonad (ErrorT e m) ?
14:18:10 <Igloo> Yes
14:18:32 <Igloo> Oh, wait, with a transformer?
14:18:38 <Igloo> Shouldn't do
14:18:39 <skew> I think that's a bit confused
14:19:05 <Igloo> Ah, yes, you probably want to be transforming your monad
14:19:19 <skew> you need to make instances like ErrorMonad e m => ErrorMonad e (MyMonadTransformer m) if you want to participate in the Control.Monad.Transformer system
14:19:37 <skew> MyMonad is a replacement monad class?
14:22:04 <RussellOConnor> MyMonad is ... a class that `decends' from the Monad class.  In the same way that say MonadState decends from Monad.
14:22:36 <RussellOConnor> Oh, this could get confusing.
14:22:59 <shrimpx> yeah, since you said 'monad'
14:23:31 <skew> actually, he said a new "Monad"
14:23:45 <skew> capitalized names are types or classes.
14:24:05 * RussellOConnor should reread the Monad Transformers section of All About Monads
14:34:27 <RussellOConnor> Okay, (ErrorT e (StateT s (Identity))) is an instance of both MonadError, and MonadState
14:34:45 <RussellOConnor> Same goes for (StateT s (ErrorT e (Identity))).
14:37:22 <RussellOConnor> And same for (ErrorT e (State s)) and (StateT s (Error e)).
14:37:48 * RussellOConnor ponders what lift does in those two cases.
14:53:05 <Marvin--> Igloo: lib$impl-$cname ? I thought we were talking about lib$cname-$impl ?
14:53:35 <Marvin--> though I guess it might be nice for tab completion to have say apt-cache show libghc6-<tab>
15:12:06 <RussellOConnor> Hmmm, I can't seem to evalState my (ErrorT String (State [Word8]) [Pakcet])
15:12:13 <RussellOConnor> Hmmm, I can't seem to evalState my (ErrorT String (State [Word8]) [Packet])
15:12:56 <RussellOConnor> :-(
15:15:41 <Marvin--> no, you'll have to runErrorT first
15:15:59 <Marvin--> possibly you want to have StateT Error rather than ErrorT State
15:16:27 <RussellOConnor> ah
15:16:34 <RussellOConnor> runErrorT, eh.
15:17:02 <Marvin--> or whatever it's called, something like that anyway
15:18:57 <RussellOConnor> cool
15:19:00 <RussellOConnor> it works
15:19:12 <RussellOConnor> but I'm confused.  Must reflect upon this.
15:20:31 <RussellOConnor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.Error.html confuses me
15:21:04 <RussellOConnor> What does newtype ErrorT e m a all by itself mean?
15:22:13 <RussellOConnor> wait
15:22:38 <Marvin--> er, what do you mean?
15:22:56 <RussellOConnor> So ErrorT e m a is pratically a synonym for (m (Either e a))
15:23:16 <Marvin--> yes
15:23:30 <RussellOConnor> The only reason ErrorT e m a exists, is so that it can have the proper monad transformer form.
15:23:33 <Marvin--> but a constructor is needed to create a new type that can instantiate Monad and stuff
15:27:35 <RussellOConnor> Excellent, it is all working as expected now.
15:27:50 <RussellOConnor> Execpt that I have `lift' scattered everywhere.
15:28:20 <Smerdyakov> Like a gym after a tornado
15:28:28 <Marvin--> hmm, you shouldn't need that
15:28:41 <Marvin--> there's an  (Error e, MonadState s m) => MonadState s (ErrorT e m)  instance
15:29:27 <Marvin--> so get:s and set:s should be auto-lifted
15:30:18 <RussellOConnor> Probably is that I'm actually using my own MonadStream
15:30:21 <RussellOConnor> err
15:30:30 <RussellOConnor> Problem is taht I'm actually using my own MonadStream
15:30:36 * RussellOConnor can't type
15:31:07 <RussellOConnor> So I should write my own instance to get my auto-lifting.
15:31:54 <Marvin--> yeah, shouldn't be so hard
15:32:18 <RussellOConnor> yep, it should be easy.  
15:34:25 <RussellOConnor> I just define next to be lift next.
15:34:33 <RussellOConnor> and endOfStream to be lift endOfStream
15:35:54 <RussellOConnor> yay, it works
15:39:00 <Marvin--> alright, now let's see if we can get this ReadP show on the road
15:43:11 <Marvin--> funny how I have to build cabal once or twice when compiling the test suite and then three more times *during* the test suite run
15:43:22 <Marvin--> we should get these Makefiles cleaned up one of these days :-)
15:46:30 <Marvin--> Cases: 39  Tried: 39  Errors: 0  Failures: 0
15:46:31 <Marvin--> yay
15:50:11 <shapr> Marvin--: yay!
15:55:30 <Marvin--> shapr: always nice when you manage to unbreak stuff you've broken ;)
16:05:47 <Marvin--> yay, 52 hunks to inspect while recording :-/
16:06:29 <RussellOConnor> *sigh* I don't suppose there is anything standard to decode UTF-8
16:07:40 <Cale> decode in what sense?
16:07:49 <RussellOConnor> [Word8] -> String
16:09:23 <Marvin--> there's nothing in the standard libs, no, but if you google for it, I bet you'll find a couple of different implementations
16:11:02 <RussellOConnor> bingo: http://repetae.net/john/computer/haskell/UTF8.hs
16:12:58 <Marvin--> Finished recording patch 'Switch from parsec parsing to ReadP parsing'
16:13:00 <Marvin--> yay
16:13:23 <Cale> What are the advantages of ReadP over Parsec?
16:14:45 <Marvin--> in this case, only that we want cabal to have as few dependencies as possible
16:15:16 <Marvin--> the fewer dependencies cabal has, the more packages can be distributed separately from the compilers
16:16:51 <Marvin--> 'course, there are neat things about how ReadP is implemented, read Koen's paper on it
16:17:11 <Marvin--> http://www.cs.chalmers.se/~koen/Papers/parsing-pearl.ps
16:17:38 <Cale> thanks for the link
16:20:09 <Marvin--> a more advanced/flexible implementation of the same concepts are in http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
16:31:36 <Igloo> Marvin--: I decided perl et al had made a mistake, so being consistent with them was foolish. e.g.: http://lists.debian.org/debian-perl/2002/03/msg00001.html
16:33:33 <Marvin--> Igloo: right
16:33:47 <Marvin--> I wonder if the lib prefix is really necessary though
16:34:14 <Igloo> They are libraries
16:34:54 <Igloo> I think whether we should have a -dev suffix is more of a question, especially with Wolfgang working on PIC and shared libraries and suchlike
16:35:51 <Marvin--> hmmyeah
16:36:30 <Marvin--> section 3 could use some more info on the dependency hell for those of us who are not intimitely familiar with it
16:38:43 <Marvin--> but now that I've sent off my readp patch to syntax, I'm off to bed
17:44:05 <koli> how can one tell when two objects are actually the same object ? by that i mean have the same address in memory.
17:44:23 <Cale> koli: why would you want to?
17:44:40 <Cale> Objects are immutable, so that's a useless piece of information
17:44:55 <koli> coz i want to terminate a recursion when i get to a predefined object that i've created.
17:45:14 <Cale> what is the type?
17:45:24 <koli> its a user defined type.
17:45:29 <Cale> Perhaps you could just have a specific data constructor
17:45:53 <koli> gosh
17:46:00 <koli> is there no simpler way ?
17:46:12 <Cale> Is that a bad solution somehow?
17:46:28 <koli> isn't it possible to tell when to objects are actually the same object ?
17:46:33 <Cale> I'm not sure what the problem is that you're trying to solve
17:47:10 <koli> basically i want to create a function that takes two objects of the same type and checks to see if they are in fact the same object.
17:47:24 <Cale> are they in Eq ?
17:47:33 <koli> no, they are user defined.
17:47:50 <koli> i'd have to add em to Eq ?
17:47:50 <Cale> you can put "deriving Eq" after your data declaration
17:47:57 <koli> ah
17:48:05 <koli> so how would i create the == function ?
17:48:08 <Cale> this will derive an equality test
17:48:14 <koli> oh right.
17:48:16 <Cale> and you get == for free
17:48:25 <koli> so its default.
17:48:30 <koli> ok cool thanks.
17:48:35 <Cale> (so long as your user defined data type is composed of things in Eq)
17:48:53 <koli> erm
17:49:28 <koli> that sounds like its not checking the addresses of the objects. but the contents.
17:49:37 <Cale> right, it checks the contents
17:49:43 <Cale> the addresses are not accessible
17:49:44 <koli> but i don't want that :I
17:49:50 <koli> oh
17:50:14 <Cale> It would be meaningless to check them, as it really can't affect your decisions in any reliable way.
17:50:29 <koli> hmmm
17:51:06 <koli> odd
17:51:14 <Cale> You can't rely on the fact that GHC won't copy something out from under you, or make a pointer to a pre existing object when you don't expect it. Many things are unlikely to happen, but you shouldn't think about pointers.
17:51:57 <koli> i'll have to think about that. :)
17:52:10 <Cale> just write the code so that it is correct first, and don't worry about references unless you're really into hardcore there's-no-better-way-to-optimise-this mode
17:57:17 <koli> this seems to imply that if you want to know when two things are intended to be equal you have to give each object an index number, so you can compare the indexes.
17:58:19 <koli> that way the number of objects you can create isn't bounded.
18:01:38 <Cale> koli: remember that only the objects you look at are actually created
18:02:11 <Cale> the number of objects you construct will always be bounded by the number that is required to produce your output
18:04:32 <Cale> The only problem that you might have is if there are a bunch of unevaluated thunks piling up on the stack. But don't worry about this until it becomes a problem.
18:05:17 <Cale> koli: Remember that infinite lists/trees etc are perfectly valid Haskell structures.
18:07:30 <koli> ok, thanks for your help cale.
18:08:42 <Cale> no problem - if you need any more specific help, feel free to let me know. The HaskellIRCPastePage on the wiki provides a good place to put code you'd like to discuss.
18:09:09 <koli> ok, thx.
18:16:00 <Cale_> blah
18:28:47 <bourbaki> hi
18:29:11 <stepcut> hi
19:11:47 * stepcut considers the possibility that the ideal web programming language may not be turing complete
19:13:30 <ayrnieu> everytime someone says 'turing complete', a little fairy comes by and fuzzes the word out for me.  I love that.
19:13:49 <Igloo> I'm not sure I've written anything primitive recursion couldn't handle
19:14:31 <Igloo> Oh, that's not true, I'd have needed a "how many lines are there in this file?" function too
19:14:52 <Igloo> But only for real files, I think, so that's easy enough to do
19:15:59 <stepcut> if you have a language with no recursion/looping constructs (but useful primatives like map). It makes things like partial evaluation, distributed computing, and many other things much easier.
19:16:48 <stepcut> who wants a cgi app that never terminates ?
19:16:58 <cm> fastcgi :)
19:17:32 <stepcut> (of course, that depends on your definition of terminates)
19:20:20 <titanstar> just have the web server kill the cgi script after a timeout
19:20:30 <titanstar> voila, the halting problem is solved! :)
19:21:42 <stepcut> titanstar: yes, but more interesting would be the possibility to answer the question "Can I run this app to completion in less than n-cycles" without having to actually run it to find out...
19:22:00 <titanstar> of course
19:22:28 <titanstar> but just killing apps that use more than their alloted time is an easy, practical solution
19:22:49 <titanstar> from a sysadmin point of view, that is
19:23:03 <stepcut> yes, but not from a developer point of view
19:23:14 <titanstar> the coder might want to know why it exceeded the timeout, yeah
19:23:41 <cm> make sigkill dump a stacktrace as well ;)
19:23:49 <titanstar> yeah
19:24:26 <titanstar> or even attach gdb to the app and stop it
19:24:32 <stepcut> titanstar: yes, but it would be better to know at compile time that your program will exceed the constraints, rather than wait for a runtime error -- which can be much more castistrophic
19:25:03 <cm> well
19:25:06 <titanstar> that is true
19:25:15 <cm> as soon as your program relies on external entities such as mysql
19:25:18 <titanstar> but as long as it's unsolvable, it doesn't really matter
19:25:20 <cm> you can't knw anything
19:25:22 <cm> know*
19:25:46 <cm> and without external entities i suppose the programs would be rather "simple", so to speak ;)
19:26:29 <stepcut> cm: true, I/O is always such a killjoy
19:26:49 <titanstar> yeah, i triggered a bug in a web application written by a friend of mine recently - i entered a password that coincidentally was md5-encoded into something that contained characters that should have been escaped, and weren't
19:27:02 <titanstar> solving the halting problem wouldn't have caught that bug
19:27:41 <stepcut> titanstar: of course not. 
19:27:42 <titanstar> yet that is a normal bug in web apps
19:28:02 <titanstar> s/normal/common/
19:28:44 <stepcut> titanstar: yes, non-turing completeness is only *one* aspect of the ultimate web programming language. 
19:28:59 <titanstar> and i'd say more urgent to catch as well, as it might have security implications, something that nonterminating programs don't
19:30:09 <monotonom> I am surprised that escaping was not implemented correctly in the first place.
19:30:34 <stepcut> titanstar: yes, but proper escaping is boring and non-controversial :)
19:31:06 <titanstar> heheh
19:31:21 * ayrnieu sighs at http://nice.sourceforge.net/language.html
19:31:43 <Igloo> Huh? The md5output contains only alphanumerics - surely none of them needed to be escaped?!
19:32:06 <stepcut> ayrnieu: what is your opinion, if you had to develope for the jvm, would nice be better than java ?
19:32:06 <Igloo> Or do you mean he echoed it into md5sum and it got expanded by a shell or something?
19:32:37 <monotonom> ayrnieu what's wrong?
19:32:58 <ayrnieu> stepcut - if you just want 'better than java', sure, probably.  I've only looked so far as that page.
19:33:11 <ayrnieu> mono - nothing.  Just looking around in darwinports lang/
19:33:58 <monotonom> You sighed. I gathered there is some kind of disappointment.
19:34:25 <titanstar> Igloo: i don't remember correctly, it was something about my md5sum ending up with numbers
19:34:32 <titanstar> i might be wrong though
19:34:53 <Igloo> Hmm, maybe if it was all numbers then an overloaded + would have gone wrong
19:35:39 <Igloo> 0.00000029387358770557 probability of that I think
19:35:42 <ayrnieu> bah, even Perl wouldn't get confused by such an occurence.
19:36:04 <titanstar> the error occured when he constructed a mysql query out of it
19:36:23 <Igloo> That makes even less sense as it should have been in quotes
19:36:34 <titanstar> it wasn't, so it failed
19:36:42 <titanstar> when he quoted it, it worked
19:37:23 <monotonom> That is regretful.
19:39:12 <monotonom> A logical programmer has only two choices.  1. hand-write his own SQL query and be very careful and paranoid in making it right.  2. Just use HaskellDB or something.
19:40:22 <titanstar> if my friend knew haskell, do you think he would be programming web apps? :)
19:40:33 <monotonom> Haha
19:40:51 <titanstar> i think this one was in php
19:41:52 <cm> good night
19:43:13 <monotonom> But I have another point in mind.  You either know that you are excellent with tiny ugly details, so you work at low level stuff (Knuth); or you know that you are easily overwhelmed, and so you stay high-level declarative (Dijkstra).  The calamity of today's programmers is they suck at tiny details and they get their hands on tiny details.
19:47:56 <monotonom> Something like HaskellDB ought to be done in php, perl, python.  It is actually easier to do their, given a dynamic type system.
19:48:04 <monotonom> s/their/there/
19:48:15 <titanstar> what does haskelldb do?
19:48:35 <titanstar> apply language types to sql queries?
19:50:43 <monotonom> You write (I'm paraphrasing here): do { x <- table1; y <- table2; restrict (x.name == y.name && x.id == 10); return (x.name, y.age)}
19:51:09 <titanstar> ooh, nice
19:51:22 <monotonom> Of course the operators == and && are not going to be really == and &&; they may actually be .==. and .&&. or something.
19:51:39 <titanstar> so you can write queries that look like regular code
19:51:45 <monotonom> Likewise you may have to write to_expr 10 instead of 10.
19:52:13 <titanstar> i guess you could do an operator overloading hack in python and make that work
19:52:25 <monotonom> Lastly the return tuple may have to be something like x.name >- y.age instead of (x.name,y.age).
19:52:44 <monotonom> But in any case you bloody cannot make quoting mistakes.
19:53:03 <titanstar> nope
19:53:29 <titanstar> that might be very useful if ported to mainstream web programming languages
19:54:05 <monotonom> HaskellDB also does some type system tricks to check your types as much as possible.  For example as long as it knows that the id field of table1 is supposed to be an integer, it won't let you say x.id == "hello".
19:54:39 <titanstar> that should be possible to do in python as well
19:55:46 <titanstar> of course, only detectable at run-time
21:01:29 <dumbintel> .
21:05:55 <poing> ?
21:35:10 <gejun> hello everyone, what's wrong in the definition.  I want to delete the second occurrence of m in ls.  
21:35:19 <gejun> delete_snd_3 :: (Eq a) => a -> ([a] -> [a])
21:35:19 <gejun> delete_snd_3 m ls = helper 1 m ls
21:35:19 <gejun>     where helper _ m [] = []
21:35:19 <gejun>  	  helper 0 m ls = delete_fst_2 m ls
21:35:19 <gejun>  	  helper n m (x:xs) 
21:35:20 <gejun>   	      | x==m      = helper n-1 m xs
21:35:22 <gejun>   	      | otherwise = helper n m xs
21:35:45 * stepcut ponders
21:36:15 <gejun> error message:  
21:36:17 <gejun> ERROR "/home/gejun/Work/Haskell/Haskell/review.hs":54 - Type error in guarded expression
21:36:17 <gejun> *** Term           : helper n m xs
21:36:17 <gejun> *** Type           : [a]
21:36:17 <gejun> *** Does not match : a -> [a] -> [a]
21:36:58 <ayrnieu> ..
21:37:41 <gejun> hi ayrnieu :)
21:37:49 <ayrnieu> hello, gejun.
21:38:27 <ayrnieu> gejun - you've an incorrect type assertion on delete_snd_3
21:38:37 <monotonom> write (n-1) instead of n-1
21:39:17 <gejun> monotonom: It loads correctly now.   Let me test.  
21:39:41 <ayrnieu> or, no, that works.
21:42:13 <gejun> It doesn
21:42:23 <gejun> it doesn't give what I want.  
21:42:25 <gejun> Main> delete_snd_3 3 [1,2,3,2,3,5,5]
21:42:25 <gejun> [2,5,5]
21:42:45 <gejun> Anyone can help?
21:43:12 <ayrnieu> gejun - you forgot my accumulator example, then?
21:43:40 <gejun> ayrnieu: you mean the one liner you give me?
21:44:18 <ayrnieu> I don't remember a one liner, but maybe.
21:47:24 <ayrnieu> gejun - why does helper return [] in the case of 'helper _ m []' ?  What happens to x in the case of 'otherwise = helper n m xs' ?
21:47:28 <gejun> ayrnieu: The one you gave didn't work.  I am looking for it in my log though.
21:48:26 <aFlag> is there something wrong with this type signature: Quadruple ::  a -> a -> b -> b -> Quadruple a a b b
21:48:27 <aFlag> ?
21:49:05 <Cale> for a data constructor, that's not sufficiently general
21:49:10 <aFlag> i have to do a data type that holds 4 elements but the first two have to be the same type and the last two must be the same type
21:49:13 <Cale> er
21:49:20 <Cale> no, that's fine
21:49:27 <aFlag> i've done this
21:49:28 <aFlag> Quadruple ::  a -> a -> b -> b -> Quadruple a a b b
21:49:29 <aFlag> data Quadruple a b c d = Quadruple a b c d
21:49:32 <SamB> why don't you give it a better name?
21:49:36 <Cale> oh
21:49:42 <ayrnieu> aflag - why do you think it has something wrong with it?
21:49:53 <aFlag> it was on the tutorial to name it quadruple so i did
21:49:55 <Cale> you can't make the first declaration, I don't think
21:50:08 <Cale> what you're looking for is data Quadruple a b = Quadruple a a b b
21:50:11 <aFlag> ayrnieu: because it doesn't load
21:50:12 <SamB> or, well, where does the "a a b b" part come in?
21:50:34 <aFlag> it doesn't it was just how i thought it should be
21:50:52 <ayrnieu> aflag - well, hopefully it doesn't load more verbosely.
21:51:05 <Cale> let me change this a bit so that it's easier to explain the parts of it to you
21:51:05 <Cale> data Quadruple a b = Quad a a b b
21:51:05 <Cale> here, "Quadruple" is the type constructor
21:51:13 <aFlag> hum...
21:51:16 <Cale> it takes a pair of types a and b, and produces a new type
21:51:22 <aFlag> a and b are actually types?
21:51:29 <Cale> they will be
21:51:35 <Cale> they're variables where types go
21:51:38 <Cale> and Quad is the data constructor
21:51:56 <Cale> it will take values, two of type a, and two of type b
21:52:02 <gejun> ayrnieu: you are right.  It works now.  The final version is 
21:52:10 <gejun> delete_snd_3 :: (Eq a) => a -> ([a] -> [a])
21:52:10 <gejun> delete_snd_3 m ls = helper 1 m ls
21:52:10 <gejun>     where helper _ m [] = []
21:52:10 <gejun>  	  helper 0 m ls = delete_fst_2 m ls
21:52:10 <gejun>  	  helper n m (x:xs) 
21:52:11 <Cale> and produce a value of type Quadruple a b
21:52:11 <gejun>   	      | x==m      = x : (helper (n-1) m xs)
21:52:13 <aFlag> but the first a of the quad constructor won't have the same value as the second a?
21:52:13 <gejun>   	      | otherwise = x : (helper n m xs)
21:52:25 <gejun> Thank you very much!
21:52:36 <ayrnieu> gejun - what does (delete_snd_3 1 [2,3,4]) evaluate to?
21:52:39 <Cale> aFlag: no, but it will have the same type
21:52:45 <aFlag> hum...
21:52:52 <Cale> For example
21:53:02 <Cale> (Quad 3 7 "Hello" "World")
21:53:18 <Cale> is a value of type, say, Quadruple Int String
21:53:30 <aFlag> i see
21:53:36 <gejun> ayrnieu:  the result is 
21:53:36 <gejun> Main> delete_snd_3 1 [2,3,4]
21:53:36 <gejun> [2,3,4]
21:54:03 <gejun> anything wrong?
21:54:05 <aFlag> so the values after the typename are the types that types accepts?
21:54:13 <ayrnieu> gejun - I don't believe that what you just pasted matches the function you just used.
21:54:49 <Cale> aFlag: the variables that the type constructor accepts as parameters
21:54:58 <gejun> ayrnieu:  you can try it :)
21:55:12 <ayrnieu> gejun - oh, sorry, I did misread it =)
21:55:13 <Cale> you then use those variables to specify what the data constructor for the new type will look like
21:55:28 <Cale> for example...
21:55:40 <SamB> Quadruple is almost the same as (,,,). only the name is different ;-)
21:55:49 <gejun> ayrnieu: I double checked and it is right.
21:55:58 <gejun> Main> :load /home/gejun/Work/Haskell/Haskell/review.hs
21:55:58 <gejun> Main> delete_snd_3 1 [2,3,4]
21:55:58 <gejun> [2,3,4]
21:55:58 <gejun> Main> delete_snd_3 3 [1,2,3,2,3,5,5]
21:55:58 <gejun> [1,2,3,2,5,5]
21:56:08 <aFlag> SamB: i know, it's for me to learn about types, not to use in some code
21:56:12 <Cale> SamB: not in this case
21:56:34 <Cale> data Quadruple a b = Quad a a b b
21:56:37 <ayrnieu> gejun - try removing the first argument to (helper)
21:56:47 <Cale> in the case of the tuple
21:56:50 <SamB> oh, right. you changed it
21:57:03 <Cale> actually that's what the tutorial wants
21:57:04 <Cale> :)
21:57:10 <SamB> oh, okay
21:57:12 <aFlag> so data Foo a = Bar a a a a the constructor will get 4 different values all of the same type?
21:57:22 <Cale> yeah
21:57:31 <SamB> exactly
21:57:33 <Cale> you could do somehting like
21:57:45 <Cale> data Foo a = One a | Two a a | Three a a a
21:58:14 <Cale>  | Zero
21:58:15 <Cale> :)
21:58:16 <gejun> ayrnieu: why should I do that?  The purpose is to delete the second `m' in `ls'.  Delete_snd_3 should have two arguments.  
21:58:22 <SamB> I think that might actually be usefull for a few of okasaki's datastructures ;-)
21:58:27 <aFlag> hum...
21:58:31 <Cale> hehe
21:58:48 <ayrnieu> gejun - why does helper need that argument?
21:59:22 <Cale> and then both  (Two 5 4) and (Three 9 8 2) would be of type (Foo Int)
21:59:50 * SyntaxLaptop bed
21:59:51 <aFlag> they are called constructors though, right?
21:59:52 <Cale> (or really (Num a) => Foo a, but I'll try not to confuse you too much yet ;)
22:00:01 <gejun> ayrnieu: in this case I need to delete the second `m'.  I want it to be extensible.  
22:00:05 <Cale> aFlag: One and Two are data constructors
22:00:12 <Cale> Foo is a type constructor
22:00:14 <gejun> for example, 
22:00:39 <gejun> delete_100_3 m ls = helper 100 m ls
22:00:39 <gejun>     where helper _ m [] = []
22:00:39 <gejun>  	  helper 0 m ls = delete_fst_2 m ls
22:00:39 <gejun>  	  helper n m (x:xs) 
22:00:39 <gejun>   	      | x==m      = x : (helper (n-1) m xs)
22:00:39 <gejun>   	      | otherwise = x : (helper n m xs)
22:00:41 <ayrnieu> gejun - ... OK, then write another function that deletes the Nth 'm', and use that in delete_snd_3
22:00:52 <gejun> should delete the 100th.
22:00:58 <aFlag> hum... i get it but i'm still not really confortable with it hehe
22:01:14 <Cale> aFlag: play around with it and you'll figure out what it means
22:01:33 <Cale> for example, you could possibly write the type of lists as
22:01:52 <Cale> data List a = Nil | Cons a (List a)
22:02:03 <ayrnieu> gejun - right now, you could remove that argument and just have '| x==m = x : (delete_fst_2 m xs)'
22:02:13 <aFlag> i keep wondering where are those values, i keep thinking Two 5 4, 5 and 4 would be attributes in an object or something
22:02:18 <Cale> or binary trees:
22:02:24 <ayrnieu> gejun - and that doesn't delete the 100th m, unless you count from zero =)
22:02:36 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
22:02:49 <Cale> aFlag: they sort of are
22:03:26 <aFlag> when you do Two 5 4 what are you creating?
22:04:16 <Cale> a value of type Foo Int
22:04:52 <aFlag> yeah, now everything is a value hehe
22:05:01 <SamB> aFlag: you want to know how to get them out again?
22:05:35 <aFlag> well, i wrote some function to get them out like firstTwo (Quad a b c d) = [a,b]
22:05:49 <SamB> good ;-)
22:06:08 <SamB> did you take note of the type on that?
22:06:09 <aFlag> i get what it does, but it still looks kinda wierd hehe
22:06:35 <aFlag> what you mean take note?
22:07:03 <SamB> you could ask ghci/hugs to give you the type by saying ":t firstTwo"
22:07:04 <aFlag> firsTwo :: (Quad a a b b) -> [a,a]
22:07:08 <aFlag> something like that?
22:07:26 <Cale> firstTwo :: (Quadruple a b) -> [a]
22:07:38 <ayrnieu> or -> (a,a)
22:07:41 <gejun> ayrnieu: the purpose of helper is to delete the Nth `m' in ls, right?
22:07:47 <SamB> aFlag: why don't you ask hugs/ghci?
22:07:51 <Cale> (depending on how you write it :)
22:07:55 <aFlag> yeah, i just did
22:08:03 <gejun> the _3 and _2 are just version.  Ignore them.
22:08:10 <aFlag> i typed that before you talk about the :t
22:08:39 <SamB> what did it say?
22:08:48 <aFlag> same as cale'
22:08:48 <aFlag> s
22:08:56 <ayrnieu> gejun - no, mostly just to hide the accumulator (on the stack, in your code, but nevermind) and extra state from the caller.
22:09:28 <SamB> okay, first off, the type has type constructors in it, not data constructors...
22:09:56 <SamB> although sometimes these may appear identical, such as, well, ()
22:10:02 <aFlag> oh, firstTwo is not the constructor
22:10:14 <aFlag> the constructor said Quad :: forall b a. a -> a -> b -> b -> Quadruple a b
22:10:53 * SamB wonders what aFlag is getting confused
22:12:03 <aFlag> i get what happens, i'm just still adjusting to the new thinking
22:12:13 <SamB> one problem, I guess, is that the right-hand-side of a data declaration isn't fully in either type or data namespace
22:12:34 <gejun> ayrnieu: (sorry I am slow and newbie)    Just now you said I'd better write a function to delete the Nth `m' and use it in delete_snd_3.  Do you mean I should move helper from inside delete_snd_3 and make it another function?
22:13:26 <ayrnieu> gejun - if you want 'extensibility' to delete the Nth element from any number of delete_4th and such functions, yes.
22:13:27 <SamB> all the newly-minted data constructor names are in the value namespace, wheras the things after each one are types
22:13:36 <aFlag> it's just that the constructor doesn't seem to do anything, it just has arguments and it doesn't look like it stores it anywhere
22:13:49 <SamB> aFlag: of course it does!
22:14:03 <gejun> ayrnieu: For the part of hiding state and accumulator in stack, I understand it better now with your help.  Thank you!
22:14:09 <aFlag> i'm not saying it doesn't it just looks like it doesn't
22:14:10 <ayrnieu> gejun - otherwise, you don't need the first argument to helper ... or helper at all, really, since you don't use an accumulator.
22:14:50 <SamB> when the constructor call is actually evaluated, an object on the heap is allocated, with a shape based solely on that of the data constructor.
22:15:24 <SamB> in this case, we'd have the header stuff and four pointers
22:15:36 <ayrnieu> delete_2nd m (x:xs) | x==m = x : (delete_fst m xs)    | otherwise = x : delete_2nd m xs
22:15:44 <aFlag> hum...
22:16:09 <aFlag> now i'm getting it better
22:16:23 <ayrnieu> (please do the obvious reformatting)
22:17:03 <SamB> since haskell is purely functional, there is no way to do the allocation explicitly, so it has to be implicit ;-)
22:17:31 <SamB> not that ML doesn't do it the same way, even though ML is not pure
22:17:47 <aFlag> ml?
22:18:15 <ayrnieu> aflag - another functional programming language.  See SML or O'Caml, for modern variants.
22:18:28 <SamB> a family of strict, impure functional languages, with similar typesystems to that of Haskell
22:18:30 <aFlag> oh
22:18:55 <aFlag> what's an impure functional language?
22:18:58 <aFlag> is haskell pure?
22:19:15 <Cale> haskell is fairly pure, as far as languages go
22:19:18 <SamB> that means it does IO more like C does, with so-called functions
22:19:37 <SamB> it also makes laziness dangerous
22:19:41 <Cale> Haskell functions are pretty close to actual mathematical functions.
22:20:05 <SamB> haskell is purely functional unless you cheat, and the cheating tools are clearly marked as such
22:20:07 <aFlag> it wouldn't be possible to do io stuff using only pure functions, would it?
22:20:20 <Cale> no, it wouldn't
22:20:21 <Cale> :)
22:20:49 <SamB> aFlag: well, at the lowest level I believe GHC uses ugly hackery, but at the high level it is just using lazy evaluation...
22:21:24 <SamB> of course, I guess the IO sequencing is really half outside of haskell-land ;-)
22:21:27 <ayrnieu> abstracted beauty is beauty, yet.
22:22:03 <SamB> I didn't say it was ugly when you don't look too close
22:22:57 <aFlag> i like how functional languages are different from everything else
22:23:03 <gejun> ayrnieu: how to remove the argument?  Could you give me the whole code.  I have put the code at http://poirot.cs.iastate.edu/tmp/test.hs.  It is short.  Only 15 lines.
22:23:19 <ayrnieu> gejun - I just showed you.
22:24:04 <stepcut> aFlag: you  might like prolog then
22:24:07 <gejun> I know.  I couldn't understand it well though.  Sorry.  Could you be more specific?  If you are busy, just forget my request :)
22:24:22 <ayrnieu> aflag - FSVO 'functional language', they've much internal difference as well: Haskell, Clean, SML, O'Caml, Mercury, Erlang, Scheme.
22:24:41 <aFlag> what's prolog?
22:24:53 <stepcut> a 'logical' programming language
22:24:59 <gejun> ayrnieu:  you mean  delete_2nd m (x:xs) | x==m = x : (delete_fst m xs)    | otherwise =
22:24:59 <gejun> 	  x : delete_2nd m xs
22:24:59 <aFlag> hum...
22:25:25 <stepcut> aFlag: http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/contents.html
22:25:42 <SamB> the passing the world around as an argument stuff is kind of cute ;-)
22:25:44 <ayrnieu> gejun - formatted differently, yes.  What don't you understand?
22:25:55 <SamB> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:26:16 <gejun> ayrnieu: I understand it totally now.  I misread it just now.  Sorry :)
22:27:02 <ayrnieu> aflag - Prolog and Mercury have some relation, with the latter more functional, and they've some trivial similarity to Erlang, which probably gets used in a more 'functional' style than Scheme, much of the time.
22:27:24 <SamB> unIO (IO a) = a
22:27:32 <stepcut> aFlag: basically, you define some facts, and some rules, and then you present a goal, and prolog "figures out the answer for you"
22:27:34 <SamB> bindIO (IO m) k = IO ( \ s ->
22:27:34 <SamB>   case m s of 
22:27:34 <SamB>     (# new_s, a #) -> unIO (k a) new_s
22:27:34 <SamB>   )
22:28:32 <aFlag> i'm looking that tutorial
22:28:45 <aFlag> that looks like fun :)
22:29:38 <ayrnieu> aflag - http://burks.brighton.ac.uk/burks/language/prolog/amzi/advtop.htm =)
22:29:47 <aFlag> but those languages aren't much used in the commercial world, are they? They are more academic directed, right?
22:30:10 <ayrnieu> aflag - yes, prolog has commercial use.
22:30:23 <SamB> mozilla embeds SWI prolog, correct?
22:30:47 <aFlag> hum... interesting
22:31:02 <SamB> for that RDF inference
22:31:05 <aFlag> but i think i'll try to finish up learning haskell first :P
22:31:15 <ayrnieu> aflag - good luck 'finishing up' =)
22:31:19 <SamB> yeah, probably wise. Prolog seems a bit messy ;-)
22:31:34 <SamB> ayrnieu: well, he could at least get all the basics down pretty well
22:31:40 <aFlag> hehe i should say "learning the basics" :P
22:32:11 <stepcut> aFlag: http://groups.google.com/groups?selm=a9kar3%24pmo%241%40panther.uwo.ca&output=gplain
22:32:49 <SamB> hmm, would it be a good idea to print out IOBase.lhs?
22:33:26 <SamB> what document would that be typeset into, by the way?
22:33:54 <aFlag> nice
22:34:26 <aFlag> i like learning new stuff, i'm just not much crazy about using it afterwards :P
22:35:33 <ayrnieu> aflag - could you write a program for me, then, while you still find Haskell interesting/
22:36:28 <aFlag> hehe if i capable :P
22:36:49 <SamB> you'll find that there is a lot of new stuff in haskell
22:36:55 <SamB> a *lot*
22:37:11 <Cale> :)
22:37:28 <aFlag> eheh each new chapter i read the tutorial is a new chapter :P
22:38:21 <Cale> aFlag: once you're finished the tutorial, you'll have to start learning extensions to the language - there are lots of cool new features that have been implemented in GHC :)
22:38:38 <Cale> and then there are papers that people have written :)
22:38:39 <SamB> but a word to the wise: C is not a good language to try and parse (particularly the type stuff), if you ever want to play with parser combinators
22:39:01 <ayrnieu> aflag - OK.  For English, ask google about the 'rhyming dictionary', probably at rhyme.sourceforge.net or like.  Interface with that dictionary (and not necessarily with its databases) to create a list of words that rhyme with their rot13.  Also create a list of words that rot13 into synonyms.
22:39:42 <SamB> heh
22:39:46 <aFlag> :P
22:39:49 <Cale> That would be awesome
22:39:51 <ayrnieu> aflag - I don't know of a good synonym dictionary, sorry, but you shouldn't have a problem with that.  I'd suggest your system dictionary as a source of words.  rot13 itself shouldn't pose a problem.
22:39:51 <Cale> :)
22:40:19 <SamB> ayrnieu: you mean there isn't a function for that in stdlib already?
22:40:20 <Cale> you might start by simply constructing a list of words that rot13 into other words
22:40:21 <SamB> shocking!
22:40:56 <ayrnieu> indeed, Cale's suggestion would speed things up.
22:40:56 <aFlag> what's rot13? hehe
22:41:08 <SamB> aFlag: do you have a copy of python?
22:41:09 <Cale> a -> n, b -> m ...
22:41:12 <SamB> >>> 'foo'.encode('rot13')
22:41:12 <SamB> 'sbb'
22:41:32 <Cale> m n, sorry
22:41:40 <Cale> I'm going to bed.
22:41:47 <SamB> >>> string.letters.encode('rot13')
22:41:47 <SamB> 'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
22:42:05 <Cale> and I have the offset off by 1
22:42:06 <Cale> :)
22:42:11 <aFlag> good night cale
22:42:24 <Cale> night
22:42:33 <SamB> the decoding is identical
22:42:37 <ayrnieu> arr, I need to hit the sack as well.
22:42:43 <SamB> yeah, me too
22:43:24 <aFlag> hehe it's some wierd charset? :P
22:43:27 <Cale> I'm willing to bet that the list of words that rot13 into other words is small enough to look through by hand.
22:43:29 <ayrnieu> aFlag - so, do you feel up to the task?
22:43:48 <Cale> aFlag: it's "encryption"
22:43:50 <aFlag> hum... maybe after a few drinks... :P
22:43:51 <Cale> :)
22:43:58 <SamB> aFlag: it is commonly used to hide spoilers on usenet
22:44:12 <aFlag> oh
22:44:20 <SamB> so that they aren't unintentionally read
22:44:30 <aFlag> neat
22:44:42 <SamB> it does see a few other uses now and then, of course.
22:45:00 <aFlag> i'm used to the spoilers in web forums [spoiler]aa[/spoiler] :P
22:45:28 <ayrnieu> aFlag - you may want to start with creating a list of words that rot13 into palindromes.
22:45:36 * SamB goes ahead with printing IOBase.lhs
22:45:50 <SamB> ayrnieu: umm...
22:45:52 <ayrnieu> aflag, e.g., gnat->tang
22:45:59 <aFlag> hehe
22:46:03 <ayrnieu> eh, not palindromes.
22:46:06 <SamB> okay. at first it sounded extremely
22:46:08 <SamB> silly
22:46:10 <SamB> and easy
22:46:18 <ayrnieu> a palindrome keeps palindromeness through rot13 =)
22:46:45 <aFlag> hehe
22:46:47 <SamB> gnat <-> tang
22:46:49 <ayrnieu> I want a list of words for which reverse L == rot13 L
22:46:56 <SamB> thats a palindromic mapping for you
22:47:04 <aFlag> hum... such an useful tool :D
22:47:05 <ayrnieu> SamB =)
22:47:19 <SamB> well, rot13 does go both ways ;-)
22:47:33 <ayrnieu> oh, darn, I've already leaked the most important part of the code :-/  well, that'll get you up to speed with filtering your source of words =)
22:48:10 <ayrnieu> aFlag - I have purely devious plans for these lists of words, I assure you.
22:48:11 <SamB> ayrnieu: umm... I already demonstrated mapping all the letters in python ;-)
22:48:40 * SamB goes to take the dog out
22:49:13 <ayrnieu> aFlag - well, please let me know when do that =)
22:49:42 <aFlag> ok, it will be at you e-mail inbox by tomorrow sir! :P
22:50:30 <SamB> but clog doesn't see ayrnieu's inbox
22:51:54 <ayrnieu> concat . reverse $ [".com", "gmail", "@", "ayrnieu"]
22:52:15 <ayrnieu> hm, I should rot13 that.
22:52:29 * ayrnieu goes to sleep.
22:54:02 <aFlag> i'm going to bed also
22:54:06 <aFlag> it's already 3am here
22:54:36 <SamB> hmm. where might that be?
22:54:45 <aFlag> brazil
22:54:53 <SamB> 'cause I can only think of ocean that would be in that time zone...
22:55:22 <SamB> oh. I guess I don't look at world maps enough...
22:55:55 <aFlag> or we're underwater :(
22:56:11 <aFlag> damn global warming
22:56:24 <SamB> I hadn't thought of south america...
22:57:12 <aFlag> nobody thinks about us :(, that's why we're always so sad
22:57:14 * SamB wonders what they use for time on seaboard
22:57:23 <ayrnieu> SamB - next you'll tell us that the sun doesn't rise in the south!
22:57:49 <SamB> no, I'm not *that* silly.
22:58:14 <aFlag> everybody knows it rises in the north!
22:58:15 <SamB> if I was, though, I might move over there ;-)
22:58:15 <aFlag> :P
22:58:29 <SamB> I thought it rose in the east ;-)
22:59:01 <aFlag> no, it actually rises on a different place each time
22:59:10 <aFlag> why would it follow conventions done by man?
22:59:59 <SamB> well, I don't have a clear enough sense of direction to distinguish exactly which way is east anyway
23:00:12 <SamB> plus I don't usually get up that early
23:00:27 <SamB> but I better go to bed just the same...
23:02:00 <aFlag> yeah
23:02:05 <aFlag> i hope the sun rises tomorrow
23:02:08 <aFlag> or later today
23:12:07 <aFlag> bye
