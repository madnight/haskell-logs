00:15:58 <earthy> moinz.
00:16:25 <earthy> falling off staircases is not very pleasant...
00:54:02 <bourbaki> hi
00:58:06 <hadesq> Hello, how do I do this?: list!!(a/b)
00:58:37 <hadesq> is there somthing like a fromFractional function?
01:13:09 <Heffalump> earthy: ouch :-(
01:13:12 <Heffalump> how big a staircase?
01:23:36 <earthy> well, let's put it like this: I can currently stand for about 10 minutes on end
01:24:04 <earthy> nothing broken, fortunately
01:39:37 <kosmikus> earthy: did you do that before or after your presentation on Friday?
01:40:00 <Heffalump> earthy: :-/
01:43:23 <shapr> yay, I have internet!
01:44:08 <Verbophobe> Hrm...  It looks IPv6
01:44:50 <shapr> I didn't even have IPv4 this weekend
01:45:02 <shapr> telia was down for 48+ hours
01:45:12 <Verbophobe> Painful...
01:45:24 <Verbophobe> And your IPv6 address is so painfully l33t.
01:46:12 <shapr> you can get one too!
01:46:24 <Verbophobe> Yeah, but I really don't feel like it.
01:46:30 <shapr> oh, ok
01:46:44 <Verbophobe> It seems too complex just to get remarks on how l33t your hostmask looks.
01:48:53 <bourbaki> hi shapr :)
01:49:31 <shapr> hi bourbaki 
01:49:52 <shapr> Verbophobe: I got it so I could investigate IPv6 advantages
01:50:15 <Verbophobe> What are they?
01:50:21 <Verbophobe> I'm not very informed.
01:51:28 <shapr> multicast, real quality of service, better support for a variety of things like autoconfiguration, mobile ip, vpns, and sane extensible header structures
01:51:48 <shapr> there's more too, but nothing I can think of off the top of my head
01:52:21 <Verbophobe> Oh.
01:52:26 <Verbophobe> SO, like, integrated DHCP?
01:52:40 <shapr> better than DHCP
01:52:49 <Verbophobe> Sounds promising.
01:53:06 <shapr> multicast and extensible headers are my favorite features
01:53:07 <Verbophobe> And when will all these marvelous things reach common mortals?
01:53:13 <Verbophobe> What are those?
01:53:32 <shapr> right now IPv4 has the standard flags like SYN, URG, et
01:53:33 <shapr> c
01:53:50 <shapr> most routers don't read those flags 
01:54:27 <shapr> the URGent flag has fallen by the wayside because it was cheaper to write router software that ignored that flag
01:54:56 <Verbophobe> Well, wouldn't people just slap "URG" on all their packets?
01:55:01 <shapr> IPv6 has a linked list of headers, and support for the basic headers is mandatory
01:55:41 <shapr> that way, cheap router software can ignore the extended headers, but still parse the basics
01:56:26 <shapr> also, there's a user area in the headers, and I have some neat ideas to do per-packet billing with that
01:56:31 <Verbophobe> What do you mean by "linked list of headers?"  How does a linked list help the headers?
01:56:33 <shapr> well, authentication and billing
01:57:21 <shapr> there's a bunch of flags in IPv4, and just 'getting it working' meant you could have software that would ignore many IPv4 flags
01:58:04 <shapr> so IPv6 cut down the number of basic flags, and set it up so you can ignore extended flags, but other routers can still benefit from them
01:58:37 <shapr> another advantage of a linked list of headers is that you don't have to ship a bunch of ignored flags in every packet.
01:58:52 <Verbophobe> Oh, I see what you mean.
01:58:55 <Verbophobe> Sounds cool.
01:59:06 <Verbophobe> Are the RFCs finalized?
01:59:11 <shapr> I think so
01:59:58 <Verbophobe> So why hasn't this dominated the world yet?
02:00:11 <Verbophobe> Because the of the existing infrastructure?
02:00:16 <shapr> yup
02:00:22 <Verbophobe> Ah.
02:00:32 <Verbophobe> Arguably, it's a good business decision.
02:00:35 <shapr> my friend who owns an ISP said "right now, IPv6 only means you have to deal with twice the amount of network security"
02:00:55 <shapr> I disagree with him :-)
02:01:39 <Verbophobe> Well, as of now, isn't all IPv6 just done over IPv4 networks?
02:01:41 <shapr> I had a neat thought a coupla days ago about implementing bittorrent in IPv6
02:01:51 <shapr> no, there is native IPv6 available
02:02:25 <Verbophobe> But how are you connecting through to IRC?
02:02:27 <shapr> my ISP even has one or two top level IPv6 blocks (biggest ISPs in finland and sweden merged)
02:02:39 <shapr> I'm using an IPv6 over IPv4 tunnel
02:03:14 <shapr> I have been unable to persuade my ISP to actually sell me a native IPv6 address :-(
02:03:40 <Verbophobe> You'd need to know the right people for that to happen.
02:04:49 <shapr> I think IPv6 would quickly become popular if the first person shooter world realized they could use it to increase the max number of concurrent players and decrease overall ping time.
02:05:11 <shapr> though someone recently told me it won't become popular until IPv6 is required to sell porn on the internet :-/
02:05:42 <bourbaki> hahahaha
02:06:04 <Verbophobe> Bingo.
02:06:47 <Verbophobe> In fact, I read somewhere that the size of the internet was directly proportional to the amount of porn sites online.
02:08:10 <tooki> my harddrive can proof that ;)
02:09:50 <Verbophobe> I think we just incited him into spilling his seed.
02:10:09 <Verbophobe> That thought might haunt me for the rest of my miserable existance...
02:13:09 <Ganesh> cool, it works
02:13:22 <Ganesh> (as if by magic)
02:14:59 <Ganesh> aww, they killed shapr just when I was trying to show off my shiny native IPv6 address
02:15:43 <bourbaki> ;)
02:45:51 <Amadan_AWAY> This is really non-functional way of thinking, but I've no ideas: I have a file with records which I should load - it's basically a CSV, one record per line, so I transform it to [Record]. The problem is, the data is heterogeneous, and different from file to file (although fixed within a file). How do I type this?
02:46:20 <Amadan_AWAY> (e.g. (Double, Double, Int, Double))
02:46:51 <Amadan_AWAY> I'd like to use tuples, but the code can't know at compile-time what types are going to be there
02:48:19 <Amadan> (I'd put a header row in the file to tell the parser what the record would look like for that type)
02:51:59 <Amadan> so perhaps the tuples are a bad idea
02:53:28 <Amadan> perhaps the cleanest would be to just define data RecordType = A Int | B Double, and use [RecordType] or Array Int RecordType...
02:55:55 <Amadan> ...ouch gotta go...
03:38:58 * Marvin-- ponders
03:39:35 <Ganesh> don't do that, it's bad for you
03:40:54 <Marvin--> hey Heff, what's with the nick?
03:41:11 <Heffalump> just playing with IPv6
03:41:22 <Heffalump> and it is my real name :-)
03:41:33 <Marvin--> well, yes, I know that
03:42:10 * Gowilla picks his other alternate nickname
03:43:14 <Marvin--> I was just pondering why the moveSources function takes both a list of "source modules" and a list of "main modules", when all it does is concatenates the two lists before using them
03:43:37 <Marvin--> especially since the function is called in the exact same way in every place, too
03:43:54 <Marvin--> moveSources ... (allModules pkg_descr) (mainModules pkg_descr) ...
03:44:03 * Marvin-- brings out the refactoring hammer
03:57:35 * bringert was wondering that too
03:58:06 * bringert thinks that main modules are intended to be put in something like /usr/bin 
03:58:10 <Marvin--> yes
03:58:23 <Marvin--> but I thought allModules was supposed to list... well, all modules
03:58:43 <Marvin--> I'll have to ask syntax when he shows up
04:00:02 <Marvin--> but then again, maybe not
04:00:20 <Marvin--> hmmmm
04:49:17 <bourbaki> bk
04:58:13 <bringert> I can't seem to find a standard function for locating a given subsequence in a list
04:58:28 <bringert> e.g. findList :: Eq a => [a] -> [a] -> Int
04:58:39 <bringert> am I blind?
05:00:03 <bringert> easy enough to write, but it feels like there should already be one
05:00:08 <Marvin--> er, what would it return on failure?
05:00:28 <bringert> right, should be Maybe Int
05:01:08 <bringert> or it could be a dropUntilList or something: dropUntilList :: Eq a => [a] -> [a] -> [a]
05:02:24 <Marvin--> wouldn't that just be something like dropWhile (not . (xs`isPrefixOf`))  or something?
05:06:55 <bringert> @type dropWhile
05:06:56 <lambdabot> dropWhile :: forall a. (a -> Bool) -> [a] -> [a]
05:07:27 <bringert> unfortunately the function given to dropWhile doesn't take a list argument
05:07:55 <bringert> maybe if you through a 'tails' in there somewhere
05:07:56 <Marvin--> oh, right
05:08:00 <bringert> throw
05:08:57 <Marvin--> head . filter (xs`isPrefixOf`) . tails
05:09:05 <Marvin--> or something :)
05:09:44 <bringert> works, but fails if xs is not in the input at all
05:09:59 <Marvin--> right, so you need case distinction instead *shrug*
05:10:29 <bringert> it still seems useful enough to be in Data.List
05:12:35 <Marvin--> I think it's a bit obscure
05:12:52 <bringert> guess it is, since it isn't in there already
05:13:07 <norpan> the choice of functions in the standard library is not obvious
05:13:25 <bringert> at least something like java's String.indexOf(String)
05:13:35 <bringert> would be useful
05:16:58 <norpan> findIndex (isPrefixOf xs) (tails ys)
05:18:25 <norpan> of findIndices
05:18:27 <norpan> or
05:27:21 <bourbaki> TheHunter hi
05:27:42 <TheHunter> bourbaki: hi
05:27:58 <bourbaki> TheHunter i have a new idea to solve my problem :) want to hear it?
05:28:28 <TheHunter> yeah, go ahead
05:28:55 <bourbaki> ok my idea is that i have graphs and automatons topologies and categories seperatly
05:29:21 <bourbaki> all of these have Functors over their own type
05:29:40 <bourbaki> and now i have monads to convert between them
05:29:47 <bourbaki> that is the returns to the conversion
05:31:02 <bourbaki> that way you can add arrows easily by shifting to graphs or topologies
05:31:10 <bourbaki> and then map back to categories
05:31:46 <TheHunter> ah
05:32:07 <bourbaki> that is like a natrual transformation
05:32:32 <bourbaki> and i think these diagrams also commute
05:32:48 <TheHunter> but aren't monads endofuntors?
05:32:50 <bourbaki> hence i start to make use for some CT stuff :)
05:33:07 <bourbaki> (Endo, NatTrans, NatTrans)
05:33:31 <bourbaki> yep but i dont get it how it is in haskell
05:33:47 <bourbaki> it didnt look to me like an endofunctor either
05:34:32 <bourbaki> take a retrun like a -> [a]
05:35:06 <TheHunter> maps from the category of types into some subcategory, namely the category of lists of types
05:36:06 <bourbaki> ok and foobar -> TypeConversion foobar is not?
05:36:18 <TheHunter> this is one, too
05:36:32 <bourbaki> ok :)
05:36:40 <bourbaki> so a simple example
05:36:45 <bourbaki> you have number sequences
05:37:18 <bourbaki> well you want to find a function that completes the next numbers
05:37:34 <bourbaki> so you build an automaton
05:38:01 <bourbaki> and you convert the automaton to a topology that is the topology of the graph of it
05:38:17 <bourbaki> and the sets in the topology are paths on that graph
05:38:31 <TheHunter> ok
05:38:35 <bourbaki> path in that graph in the category view are functions
05:39:10 <bourbaki> then i use the bind of the monad to get a function that maps the numbers either iteratively or form Nat to Nat
05:40:12 <bourbaki> and the search in the graoh point of view could be done as searches in that space
05:40:22 <bourbaki> so you could use a* to build the functions
05:41:01 <bourbaki> the sense of it all is that you gain more functions if you are able to map it to some of the other things
05:41:27 <bourbaki> ie glueing is something usefull imho for automatons
05:42:32 <bourbaki> TheHunter does this make any sense?
05:43:25 <TheHunter> i have to say, i don't fully understand what you mean, but looks like it could make sense :)
05:43:53 <bourbaki> heh
05:44:25 <bourbaki> i think i will change the topic of my thesis slightly and include that in my examples
05:51:48 <TheHunter_> stupid laptop crashed...
06:38:58 <Si\> I've come up against a problem in writing my XML Schema implementation; most of the data-types are mutually recursive because this is the nature of XSchema types. But I discovered that there exist several different elements which have the same name but different structures, so I've tried to split it up into several modules
06:39:42 <Si\> unfortunately I can't, because the modules all depend on each other in several ways, what's the easiest way to get around the cyclic modules problem?
06:40:56 <Marvin--> Different elements have the same name?? Man, that's broken
06:41:56 <Marvin--> I'm not sure you can (or should) solve the cyclic modules problem
06:42:56 <Marvin--> but perhaps you could replace recursive bits with type variables and introduce type synonyms that "fill in the blanks"?
06:43:46 <Igloo> That could lead to infinite types if they are recursive, no?
06:43:55 <Marvin--> hrm, true
06:44:17 <Si\> Yes, for example there are 2 different structures for the restriction element, one for Complex Types and one for Simple Types
06:44:45 <Si\> I suppose I could name them differnetly, but then I'd end up with a humungously long source file to try and code with anyway
06:44:48 <Igloo> Is a convention like FooBar and QuuxBar possible when you have a type Bar inside both types Foo and Quux?
06:45:42 <Igloo> Or even Bar, Bar1, Bar2, .... It's not going to be pleasant, though.
06:46:07 <Si\> My data types are not pleasent already
06:46:40 <Si\> data Element = 
06:46:40 <Si\>     Elem { ea_abstract::Bool, ea_block::Selection ERS, 
06:46:40 <Si\>            ea_default::Maybe String, ea_final::Selection ERS, 
06:46:40 <Si\>            ea_fixed::Maybe String, ea_form::IsQualified, ea_id::Maybe ID, 
06:46:40 <Si\>            ea_maxOccurs::Maybe Int, ea_minOccurs::Int,
06:46:40 <Si\>            ea_name::Maybe NCName, ea_nillable::Bool, 
06:46:42 <Si\>            ea_ref::Maybe QName, ea_substitutionGroup::Maybe QName, ea_type::Maybe QName,
06:46:46 <Si\>            ee_cont::Maybe (Either SimpleType ComplexType), ee_keyData::[KeyData]
06:46:49 <Si\>          }
06:47:00 <Si\> for e.g.
06:47:56 <Marvin--> eep
06:48:59 <Si\> problem is I've got no data-type inheritance, and most of the elements contain at least two attributes with the same name, so I have to repeat them all
06:49:21 <Si\> it was going quite well, until I hit the cyclic modules problem
06:53:18 <Si\> I did ready somewhere that GHC can do mutually modules with pragmas, how does that work?
06:57:36 <Marvin--> no idea
06:58:18 <Si\> Ok, guess it's one big source file then
06:58:43 <Marvin--> yikes, there's no middle ground at all?
06:59:49 <ozone> Si\: it does permit cyclic modules, you have to compile them specially
06:59:55 <ozone> see the ghc's user guide for more info, it's in there
07:03:49 <Igloo> Oh, I suppose if you are autogenerating the files then making .hi-boots wouldn't be an issue
07:04:06 <Si\> I'll leave that method as a last resort atm, I figure I can use an optional switch to get around some of the element naming issues
07:35:10 <Lemmih> How hard would it be to make a haskell apache module?
07:36:21 <Lemmih> It requires detailed knowledge of apache internals right?
07:38:55 <thebug> you mean, like a mod_perl sort of thing for haskell ?
07:44:47 <bourbaki> hi MakeMyDay
07:50:54 <Lemmih> thebug: More like mod_caml actually.
07:51:27 <thebug> ah
07:52:04 <Igloo> What's the difference?
07:52:14 <shapr> ahem. telia suXX0rs.
07:52:27 <shapr> 2.5 days offline.
07:52:40 <shapr> bringert: HI! wassup?
07:52:50 <Igloo> Yikes
07:53:34 <shapr> y0 Si\, I darcs'd your version of hws-wp that you sent me, is there a later version than that tbz?
07:53:49 <shapr> @yow !
07:53:50 <lambdabot> I think I'll make SCRAMBLED EGGS!!  They're each in LITTLE SHELLS..
07:54:06 <Lemmih> Igloo: mod_perl interprets perl, mod_caml executes bytecode.
07:54:18 <shapr> greenrd: greentings
07:54:55 <Igloo> Or interprets bytecode  :-)
08:02:24 <bringert> hi shapr
08:02:28 <shapr> hi!
08:02:38 <bringert> back to work today
08:02:40 <shapr> oh, I saw my name in the HaskellDB acks, w00!
08:02:45 * shapr feels cool
08:02:49 <bringert> the paper?
08:02:52 <shapr> yup!
08:02:56 <bringert> how have you been?
08:03:11 <shapr> trying to figure out if I'm on vacation or working :-)
08:03:17 <shapr> I got QuickCheck to save failing cases
08:03:25 <shapr> but it's an ugly hack, and I'm not sure how to do it better :-/
08:03:40 <kosmikus> is there a list of accepted papers for HW?
08:03:50 <bringert> I haven't found one
08:04:08 <shapr> bringert: how have you been?
08:04:20 <kosmikus> bringert: you got in?
08:04:24 <shapr> is there a latest GF package?
08:04:40 <bringert> all I know is that there are 9 accepted papers + ours, which was accepted as a student paper
08:04:52 <bringert> shapr: I've had a really good time
08:05:22 <bringert> shapr: I thought they would release one while I was gone, but it doesn't llok like that happend
08:05:30 <kosmikus> bringert: congratulations
08:05:39 <shapr> oh, where ya been?
08:05:45 <shapr> in .ru again?
08:05:56 <bringert> shapr: prerelease stuff from before I left is at http://www.cs.chalmers.se/~bringert/gf/gf-download.html
08:06:08 <bringert> kosmikus: did you submit anything?
08:06:21 <kosmikus> no
08:06:21 <bringert> shapr: nope, haven't been there for years
08:06:29 <kosmikus> I'm currently trying to meet the popl deadline
08:06:53 * bringert was persuaded to talk about haskelldb at AFP04
08:06:56 <kosmikus> icfp and hw were too close after my thesis
08:07:05 <kosmikus> I'll be at afp
08:07:10 <bringert> cool
08:07:19 <bringert> will you present anything?
08:07:33 <shapr> I wish... I'd really like to see the epigram bit.
08:07:40 <kosmikus> again, I've told them I don't want to think about it because I was in the middle of getting my thesis done
08:07:53 <kosmikus> if there's a possibility to do a presentation spontaneously, I might
08:08:01 <Si\> shapr: No, if you put the most recent patched version in which works with GHC 6.2, AFAIK you have the l8st version
08:08:12 <bourbaki> where is that afp thing?
08:08:18 <kosmikus> in tartu, estonia
08:08:27 <shapr> Si\: spiffy, I'll put it up and rip out the hws-wp cvs.
08:08:50 <bourbaki> estona ?
08:09:07 <shapr> .ee
08:09:14 <kosmikus> estonia; its the most northerly of the baltic countries
08:09:20 <bringert> we have a lot of comments from the reviewers to fix, and we need money to go to HW
08:09:25 <bringert> but we got in!
08:09:30 <shapr> yay!
08:09:31 <MakeMyDay> Is there a way to read all files ending with a specific extension? iow is there a wildcard?
08:09:55 <shapr> MakeMyDay: you can get a file list and filter it.
08:10:00 <shapr> Lemmih: use hws-wp!
08:10:07 <bringert> @type Directory.getDirectoryContents
08:10:07 * kosmikus still hasn't decided whether to go to icfp this year
08:10:08 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
08:11:23 <bourbaki> kosmikus where is that?
08:11:27 <bringert> shapr: I had a great time, courses during the day, beach volleyball, swimming, sauna and beer the rest of the time
08:11:32 <bringert> all paid for
08:11:38 <shapr> oh, where'd you go?
08:11:53 <kosmikus> bourbaki: in snowbird, utah, us
08:12:00 <bourbaki> bah
08:12:14 <bourbaki> why always that far away?
08:12:17 <bringert> shapr: northern Bohuslän
08:12:34 <bringert> Sweden can be a really nice place in the summer
08:12:56 <shapr> yah, I've been uncycling my butt off (somewhat literally)
08:13:23 <shapr> didn't you have some range parsing stuff in HaskellDB? like 1-9 and that sort of thing?
08:13:42 <bringert> have you been to the west coast (of sweden that is) in the summer?
08:13:57 <bringert> shapr: hmm, don't think so, what would it be for?
08:14:12 <shapr> not sure, I thought you'd said something like that. 
08:14:25 <kosmikus> bourbaki: where are you located?
08:14:41 <kosmikus> ah yes, .de
08:14:43 <kosmikus> I remember
08:14:48 <bringert> shapr: not that I can remember, but I'm probably wrong
08:14:50 <bourbaki> yep
08:14:59 <kosmikus> bourbaki: ifl 04 is in september in HL
08:15:13 <bourbaki> hl?
08:15:20 <kosmikus> luebeck
08:15:33 <bourbaki> oh what does it cost?
08:15:43 <kosmikus> don't know, look at the web
08:15:57 <bringert> I've been totally cut off from the world for two weeks, didn't read email, kept cell phone traffic to a minimum. damn nice, but it feels strange to be back in an office
08:16:03 <kosmikus> http://www.isp.uni-luebeck.de/ifl04/index.htm
08:16:04 <bourbaki> k :) not that i will understand a lot
08:16:12 <bourbaki> thanks
08:16:21 <bringert> can't really remember anything about haskelldb or anything else
08:16:24 <shapr> I got a lot of organizing stuff done over the last 2.5 days of being offline.
08:16:31 <Lemmih> shapr: What's that?
08:16:33 <shapr> bringert: oh no! vacation amnesia!
08:16:41 <bringert> what did you organize?
08:17:04 <Lemmih> ekk, a haskell webserver,
08:17:09 <shapr> I ripped my local copy of haskell-libs cvs into pieces, turned hws-wp into a darcs repo
08:17:17 <bourbaki> 230 euros thats a lot of money
08:17:20 <shapr> reorganized my local research papers archive
08:17:35 <shapr> cleaned my room!
08:17:35 <bourbaki> maybe i can convince my prof that i really have to go there ;)
08:17:38 <shapr> I was that bored!
08:17:51 <bourbaki> hahaha
08:18:02 <bringert> shapr: did the weather suck or something?
08:18:08 <shapr> mmm, new xml-rpc release
08:18:22 <bringert> oh, cool
08:18:23 <shapr> nah, telia ADSL rolled over and died for 2.5 days
08:18:43 <bringert> a release, when did that happen?
08:18:46 <bringert> did I do that?
08:18:46 <shapr> we called the tech support line and we were number 88 in the line
08:18:54 <bringert> oh joy
08:19:02 * bringert used to work in ISP tech support
08:19:15 * bringert didn't really enjoy that very much
08:19:24 <shapr> oh, I called BBB tech support today and asked them about their IPv6 offerings...
08:19:37 <bringert> especially when the italy server caught fire
08:19:45 <shapr> !!
08:19:46 <bringert> what did they say
08:19:53 <bringert> bbb that is?
08:19:58 <shapr> they said no, but they might offer it in the future.
08:20:03 <shapr> bredbandsbolaget
08:20:05 <bringert> lol
08:20:27 <bringert> it be interesting if they had said that they will not offer it in the future
08:20:34 <bringert> _it'd be_
08:20:53 <shapr> all the email I sent to telia never got a response
08:21:08 <bringert> hmm, some really messed-up use of the subjunctive there
08:21:16 <bringert> in my sentence that is
08:21:34 <bringert> and then it magically started working again?
08:21:55 <shapr> well, it worked this morning at 11am for about five minutes, then died agani
08:22:01 <shapr> now it's back, hopefully for good.
08:23:26 <bourbaki> what kind of talks will you hear there?
08:23:30 <bourbaki> wb TheHunter
08:26:41 <kosmikus> who? I? where?
08:27:36 <bourbaki> ifl
08:30:18 <TheHunter> hi, bourbaki
08:30:42 <firefly> Is there a haskell implementation that works with Mono?
08:32:35 <kosmikus> bourbaki: I won't be at ifl; it was just suggesting it because you were complaining that all (interesting) conferences are too far away
08:33:31 <bringert> wasn't someone working on a .net backend for ghc?
08:33:43 <bringert> re: mono that is
08:39:04 <firefly> bringert: I had hoped somebody had actually tried such a backend and could tell me what worked and what didn't.
08:39:58 <bringert> I think that andersca has played with mono and haskell, you might want to ask him when he shows up
08:40:07 <firefly> thanks!
08:42:39 <Si\> Has anyone any experience of how long it usually takes Savannah to respond to project requests?
08:53:09 <MakeMyDay> ok so I have the list of files in the directory but they are IO [FilePath] format. How do I cast it to a [String] format to work with them? The Type FilePath is actually a String anyway no?
08:54:33 <keverets> you won't be able to get rid of the IO, nor should you really.  Recent mailing list discussions cover this, though I'm not sure there's a web archive of them.
08:54:51 <Igloo> There is
08:54:55 <Igloo> On www.haskell.org
08:55:12 <SamB> keverets: there are several
08:55:25 <SamB> also, an nntp-accessible archive.
08:56:19 <Marvin--> http://haskell.org/hawiki/ThatAnnoyingIoType
08:56:47 <MakeMyDay> thx
08:58:12 <SamB> news.gmane.org/gmane.comp.lang.haskell.cafe
09:10:33 <bringert> MakeMyDay: yes, FilePath is a type synonym for String
09:11:44 <bringert> gaah, creating loops be unintentional variable shadowing is not fun
09:11:48 <bringert> s/be/by/
09:30:28 <MakeMyDay> May I say that the IO system of Haskell is really really un-natural to newbies?
09:31:30 <Cale> It's really really unnatural if you're used to other programming languages :)
09:31:37 <neologism> its not unnatural
09:31:38 <shapr> yah, I was thinking that myself.
09:31:51 <shapr> I think the processing system of procedural languages is unnatural.
09:32:08 <Cale> It's quite natural if you don't think of imperative/procedural programming.
09:32:18 <MakeMyDay> I just can't seem to really understand how I am supposed to play with the Files that I read
09:32:21 <shapr> no one would keep an employee who required as much detailed directions as C.
09:32:35 <Cale> an "IO a" is an IO computation which you can pull values of type a out of
09:32:42 <MakeMyDay> Is there a special tutorial for IO() out there?
09:32:55 <Cale> MakeMyDay: see UsingMonads on the wiki
09:33:04 <Cale> actually
09:33:04 <shapr> MakeMyDay: the best way is to write pure functions that can work with a String, then call those pure functions in the top level monadic code.
09:33:06 <Cale> before that
09:33:16 <Cale> go to HaskellNewbie
09:33:28 <Cale> and look for where the guy wanted to know how to move a bunch of files
09:33:36 <MakeMyDay> sharp: Yeah I am doing this I just hope I will be able to put it together later:/
09:34:12 <MakeMyDay> ok I will
09:34:15 <Cale> http://www.haskell.org/hawiki/HaskellNewbie
09:34:48 <Cale> the part that I'm referring to starts with "IO isn't the easiest thing to get used to in Haskell..." :)
09:35:03 <Cale> but really, it's not so bad once you see how it's done :)
09:35:31 <Marvin--> SyntaxNinja: ping?
09:35:43 <MakeMyDay> ok thx
09:35:51 <MakeMyDay> reading it now
09:36:22 <Cale> I should point out that the return () doesn't cause the IO computation to stop there
09:36:35 <MakeMyDay> yeah I read that allready
09:36:52 <MakeMyDay> in some toehr tutorial
09:39:51 <SyntaxNinja> hi Marvin--
09:41:44 <shapr> g'day SyntaxNinja, how's code?
09:41:47 <Marvin--> SyntaxNinja: I've updated the parser for the change in mainModules, but in the process I got confused about what allModules is supposed to do
09:41:53 <SyntaxNinja> hi shapr. not bad at all :)
09:42:09 <SyntaxNinja> Marvin--: good point. you're presumably wondering whether they include the main modules
09:42:14 <Marvin--> exactly
09:42:27 <SyntaxNinja> I don't think so. I think they should be the library modules. maybe we should change the name to that.
09:42:42 <SyntaxNinja> they are the ones that are compiled together, then linked into a .a file
09:42:48 <Marvin--> which got me thinking
09:42:53 <SyntaxNinja> the name is left over from before I insisted on having mainModules.
09:43:00 <Marvin--> what does the use case for application-and-no-lib look like?
09:43:22 <Marvin--> empty allModules? That'll break moveSources
09:43:28 <SyntaxNinja> I think I have been avoiding thinking about that... 
09:44:49 <SyntaxNinja> maybe mainModules should be more like [mainSupport] where mainSupport :: {moduleName :: String, exeName :: String, supportModules :: [String]}
09:45:04 <SyntaxNinja> er MainSupport... you know what I mean
09:45:17 <SyntaxNinja> mainSupport :: MainSupport
09:45:59 <Marvin--> it kinda sucks having to list all the modules used by a program when at least ghc already knows how to figure it out
09:46:37 <SyntaxNinja> do you think sourceDist, etc, should go do the dependency analysis?
09:46:56 <Marvin--> I don't know :(
09:47:15 <Marvin--> it sucks to duplicate code too
09:47:20 <SyntaxNinja> I think that would be a good goal for the next version... I want to include stuff for dependency analysis in the library
09:48:00 <SyntaxNinja> I actually almost have hmake ready to fold into cabal, but don't want to do that until the first release
09:49:19 <Marvin--> oh
09:49:39 <shapr> fold it!
09:50:06 <Marvin--> hmm, maybe the setup file should consist of multiple stanzas, like debian/control files?
09:50:11 <SyntaxNinja> I want the first release to handle a few use-cases well, but there is the issue of getting the interface right.
09:50:45 <SyntaxNinja> I'm trying to put off decisions that impact the interface in a non-backward-compatible way (like the options discussion we had yesterday)
09:50:46 <Marvin--> like, one stanza per mainmodule
09:51:10 <SyntaxNinja> I see what you mean. are stanzas separated by newlines? hm.
09:51:39 <Marvin--> having Main-Modules: foo: Foo, bar: Bar  kinda works, but it IS slightly hackish, and if we need to provide even more info per main module, it's going to suck badly
09:51:41 * SyntaxNinja was hoping to use the same syntax if we ever need a list of packages file.
09:52:35 <Marvin--> instead, we could have  Executable: foo\nMain-Module: Foo\nModules: Fooish1, Fooish2, ...
09:52:48 <Marvin--> heck, different executables are bound to have different dependencies and flags anyway
09:53:04 <Marvin--> turning on -fth for all executables just because one of them needs it kinda sucks, doesn't it?
09:54:56 <Marvin--> give me a few minutes to think of some example syntax
09:55:06 <SyntaxNinja> makes sense.
09:55:14 <SyntaxNinja> Il'l bbiab. meeting.  your idea sounds good to me.
09:59:37 <Marvin--> I wonder if it makes sense to build several libraries in one package
10:00:02 * Marvin-- ponders
10:06:26 <Igloo> Is there a reason not to have multiple description files if there are multiple executables in a package?
10:06:46 <Igloo> (or libraries)
10:07:22 <Marvin--> oh dear
10:08:02 <Marvin--> well, first of all, I imagine a 1-1 mapping between description files and Setup.lhs files
10:08:30 <Marvin--> and having to type ./Setup configure twice, ./Setup build twice and ./Setup install twice kinda... sucks
10:09:28 <Marvin--> like in my case, there's sort of one main program (h2fol) but there's also a utility program that parses the output of the theorem prover and pretty-prints it
10:09:36 <Marvin--> it doesn't really make sense to install one without the other
10:09:44 <Igloo> No reason setup couldn't do it for all of them
10:10:08 <Igloo> For hat I would like to be able to build the tools with just one compiler and the libraries for all of them
10:10:45 <Marvin--> but two description files? what about the common metadata like version, license, maintainer...?
10:10:48 <Igloo> But that could be two directories each with their own Setup.lhs
10:11:06 <Igloo> An alternative would be sections inside a single description file
10:11:31 <Marvin--> that's what I'm talking about
10:11:34 <Igloo> With defaults values either in a section "Default" or outside all sections
10:11:40 <Marvin--> <Marvin--> hmm, maybe the setup file should consist of multiple stanzas, like debian/control files?
10:12:06 <Igloo> Ah, yes, think I missed that bit, sorry
10:12:54 <Marvin--> http://www.mdstud.chalmers.se/~md9ms/cabal/usecases/OnlyExecutables.txt
10:13:26 <Marvin--> but for multiple libraries, I think separate setup files makes sense, actually
10:14:01 <Marvin--> since you'll want them to be separate packages in the hierarchy anyway
10:14:53 <MakeMyDay> meh that's enough for me today.. see you tommorow:)=
10:16:37 <shapr> edwinb: sure, a web folder of archives would be fine
10:16:59 <edwinb> shapr: I've just put it at http://www.dur.ac.uk/e.c.brady/epigram.txt
10:17:36 <edwinb> Turns out our mailing list manager has an archiving feature, but in the config options it says "This item does not currently work. Leave it blank."
10:17:48 <Marvin--> heh
10:18:02 <shapr> edwinb: thanks!
10:18:09 <edwinb> at least it's honest so that I don't have a frustrating few hours trying to make it work ;)
10:24:59 <shapr> I'm totally infatuated with the interactivity of epigram.
10:25:18 <shapr> it's better than Python.
10:27:05 <edwinb> yeah, it's nice not to have to write half of your program...
10:27:13 <edwinb> It needs a better interface ultimately though.
10:27:27 <shapr> like what?
10:27:43 <edwinb> Well, similar sort of appearance, but not tied to emacs like it currently is.
10:27:49 <shapr> or should I just read the original version of view?
10:27:57 <shapr> yah, as much as I love emacs, it scares many people.
10:28:18 <shapr> and emacs has its unfixable sucky bits too
10:28:27 <edwinb> The current version is just a quick hack really.
10:28:39 <shapr> it's still gorgeous
10:28:41 <edwinb> And I'd like, in particular, not to have to use the mouse.
10:28:47 <shapr> yah, I agree with that
10:28:50 <edwinb> Oh yes, I think it's rather impressive.
10:28:55 <shapr> having to use the mouse in emacs is oxymoronic.
10:29:20 <shapr> I also wish epigram.el wouldn't eat my whole xemacs session, I have to run it with xemacs -q so it won't load my desktop and all my other settings.
10:29:28 <edwinb> Conor's refactoring the whole thing soon... to make it easier to bolt on new front and back ends.
10:29:41 <edwinb> Mmm, yes, that's annoying.
10:29:44 <shapr> the first time I ran epigram.el it took me five minutes to beat it into submission and swap back to the #haskell buffer.
10:30:20 <edwinb> Mmm, you do also find that it eats memory!
10:30:47 <shapr> I haven't looked at the memory usage.
10:31:19 <shapr> anyway, I want to steal the whole interactive approach for building parsers
10:32:24 <shapr> are there single-file archives of conor's slides? or should I just rip them off with wget?
10:34:25 <bourbaki> does anyone of you know a good tex style file for diagrams?
10:36:04 <edwinb> shapr: I think wget is your best bet really
10:37:00 <edwinb> bourbaki: what sort of diagrams? I use xfig and export eps...
10:37:03 <shapr> edwinb: btw, "Iain Georgeson" "Steve Quinney" "Kevin Rose" and "Tom York" are the only "people" links that work, and under Other People, "James McKinna" is dead too.
10:37:20 <edwinb> Yeah, I should get rid of all that stuff...
10:37:39 <edwinb> And, indeed, write a proper web page some day.
10:38:35 <shapr> your LEGO and proglang research resources are also dead :-)
10:38:55 <edwinb> Gah!
10:38:58 <bourbaki> shapr have you had a look at cube?
10:38:58 * edwinb curses link rot
10:39:08 <edwinb> I'll fix it one day ;)
10:39:09 <shapr> I discovered I only have enough focus to keep up a wiki page anyway.
10:39:16 <bourbaki> one of the coolest programming langages is chef :)
10:39:17 <shapr> bourbaki: I was unable to find it.
10:39:34 <shapr> I found a bunch of dead links pointing to various Cube websites, but no actual website.
10:40:04 <bourbaki> hm a pitty
10:40:12 <bourbaki> didnt google cach them?
10:40:30 <bourbaki> http://www.dangermouse.net/esoteric/chef.html
10:42:46 <edwinb> oh wonderful ;)
10:43:34 <bourbaki> heh
10:43:44 * SyntaxNinja is back
10:43:52 <SyntaxNinja> Marvin--: I'm running again in a minute. got any quick questions? (screw timezones!)
10:45:03 <SyntaxNinja> in general, as to what igloo was saying, I don't think we want to aim toward a system which handles complexity that will be offered by having two Setup files or two package descriptions
10:45:15 <SyntaxNinja> if a package is that complex, maybe it needs to be split off into two.
10:45:21 <Marvin--> right, that's what I think too
10:45:35 <Marvin--> basically, my suggestion is this: http://www.mdstud.chalmers.se/~md9ms/cabal/usecases/OnlyExecutables.txt
10:45:50 <Igloo> Well, two setup files doesn't need any cabal support
10:45:51 <Marvin--> if you've got a library too, you put that info in the initial stanza
10:46:06 <SyntaxNinja> i was just looking at that. looks nice.  I have a vague worry about multiple source dirs, but I'm not sure why
10:46:08 <Marvin--> Igloo: right, you can just compile two setup.lhs files separately
10:46:27 <SyntaxNinja> Igloo: right. ATM the "cabal" standard says "one setup file in the top level of the directory"
10:46:30 <Igloo> I was assuming that as Marvin was wondering how to handle it you did want to support two separate things in one Setup, though
10:46:59 <SyntaxNinja> now maybe we're in the meta-cabal (the over-all package system and layered tools) territory, but right now, fwiw, the cabal standard does say that the setup file should be at the top.
10:47:38 <SyntaxNinja> it's easy for layered tools to handle that; I fear adding another layer of indirection that tells layered tools "go look for all the setup files" or something
10:47:40 <Igloo> WDYM by top? I don't want ./Setup.lhs in tarballs, I want ./foo-1.2/Setup.lhs
10:47:55 <SyntaxNinja> what's "."?
10:48:11 <SyntaxNinja> I think that what we have is what you want.
10:48:18 <SyntaxNinja> I'm not insane, after all ;)
10:48:18 <Igloo> Like I said, I don't think cabal should do anything special to handle multiple Setup.lhss
10:48:22 <Marvin--> I don't think *anyone* want tarballs that don't contain a directory
10:49:18 <Cale> I hate compressed archives which expand into the current directory
10:49:28 <sazzle> they're very annoying
10:49:32 <Cale> (rather than a subdirectory thereof)
10:49:55 <Igloo> :-)
10:50:22 <Cale> there seems to be a tendency for .zip files to do this
10:50:51 <SyntaxNinja> Igloo: so I guess that the question is whether htere are multiple directories on the top level with setup, and i htink there shoudl not be... I want to keep it simple.
10:51:42 <Marvin--> Cale: I think that's because winzip tends to encourage you to uncompress foobar.zip into a new directory foobar
10:52:23 <Igloo> Syn: But you won't even know, so it doesn't matter
10:56:40 <SyntaxNinja> Igloo: what do you mean?  in order to build layered tools, we will have to make decisions there.
10:58:07 <RussellOConnor> Is foldl prefered to foldr whenever possible?
10:58:07 <Marvin--> Igloo's point is that if people want several setup files in the same tarball, we can't stop them, but we don't particularly have to care either :)
10:59:41 <SyntaxNinja> true enough. but I wanted to have a standard, like "packagename-version.tgz" so you can "wget packagename-version.tgz;cd packagename-version/;./Setup build"
11:00:18 <Marvin--> and that is what we should recommend, for sure
11:00:22 <SyntaxNinja> so if it's the case that there's more than one top-level package, yeah, we can just ignore them if that's the plan.
11:00:59 <Marvin--> I'm going to do some more thinking on the multiple-executables-multiple-stanzas idea
11:02:02 <SyntaxNinja> cool.  thanks so much for your work, Marvin-- it makes a world of difference to not be working alone and trying to make these types of decisions in a vacuum (or rather, having the choice between vacuum and bikeshed via the mailing list)
11:02:41 <Igloo> I would like hat, for example, to unpack hat-1.2/tools/Setup.lhs and hat-1.2/lib/Setup.lhs, for example. Dunno if MW will agree with me, though  :-)
11:03:05 <Marvin--> Igloo: er, why?
11:03:47 <Igloo> Because for the deb I make the tools once and the libs 3 times
11:04:20 <Marvin--> argh, good point :-/
11:04:22 * Igloo suddenly wonders if hat-hugs could exist
11:04:52 <Marvin--> otoh, it shouldn't be a problem to support ./Setup build --only-library
11:04:54 <Igloo> Hmm, I can't think of a good reason why not. I'll have to see if it breaks horribly some time.
11:05:06 <Marvin--> for the both-executables-and-library use case
11:05:10 <Igloo> Marvin: As a special thing for hat or in general?
11:05:16 <Marvin--> in general
11:05:20 <Marvin--> I don't see why not
11:05:26 <Marvin--> sounds useful
11:05:50 <Igloo> I didn't see the problem with them being completely separate as far as cabal is concerned, TBH
11:06:19 <Marvin--> well, there is a certain appeal to only have a single setup file
11:06:36 <Marvin--> only one file which lists version/copyright/license/maintainer/...
11:06:41 <Marvin--> and it's easy to find
11:07:55 <shapr> what the heck is Caption PNG?
11:08:20 <Marvin--> ?
11:08:22 <Marvin--> never heard of
11:08:45 <shapr> seems to be some sort of movie format like MP4, AVI, etc
11:22:17 <shapr> why is ccNUMA so much easier to code for than pure NUMA?
11:27:44 <shapr> if the problems with cache coherency in NUMA have to do with mutability, can't you use something like Haskell's system where variables are only created and never changed?
11:28:25 <Marvin--> what is NUMA?
11:28:37 <shapr> http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access
11:58:29 <RussellOConnor> Is there a function in the prelude of type (Monad m) => (m a) -> (a -> b) -> (m b)  ?
11:59:31 <TheHunter> flip liftM
11:59:41 <TheHunter> or flip fmap
11:59:46 <SyntaxNinja> Control.Monad.liftM I don't think it's in the prelude
11:59:54 <TheHunter> sorry
11:59:58 <TheHunter> but fmap is
12:00:25 <SyntaxNinja> :t Control.Monad.liftM
12:00:25 <SyntaxNinja> Control.Monad.liftM :: forall r m a1.
12:00:25 <SyntaxNinja> 		       (Monad m) =>
12:00:25 <SyntaxNinja> 		       (a1 -> r) -> m a1 -> m r
12:01:54 <RussellOConnor> So  filesize <- liftM fromInteger (hFilesize handle)  would be a fine way of geting a filesize that I want to use as an Int instead of as an Integer.
12:03:54 <Marvin--> RussellOConnor: yep
12:04:01 <RussellOConnor> what's the difference between fmap and liftM?
12:04:12 <Marvin--> liftM is monadic, fmap is in the Functor class
12:04:27 <Marvin--> but in reality, none
12:04:44 <RussellOConnor> Are all Monads Functors?
12:04:49 <TheHunter_> and every monad should be a functor, but this is not strictly enforced
12:07:10 <RussellOConnor> excellent
12:08:02 <monotonom> Ideally liftM and fmap do the same thing, albeit with possibly different coding.
12:08:32 <RussellOConnor> I'll uses fmap since it is in the prelude, and IO is a functor.
12:09:01 <RussellOConnor> one less thing to import (for now)
12:09:28 <monotonom> There are real applications in which some people want the two divorced, e.g, an almost-monad that is not a functor.
12:10:22 <monotonom> Usually fmap is more efficient because someone hand-coded it optimally.  liftM is always coded as per the Monad module and may be suboptimal.
12:12:51 <phubuh> oh hey dudes
12:13:50 <SyntaxNinja> hi phubuh
12:14:24 <phubuh> hi!  what's up?
12:16:17 <Marvin--> SyntaxNinja: how do you feel about moving the fields buildDepends, modules, cSources, hsSourceDir, extensions, extraLibs, includeDirs, includes and options into a separate BuildInfo data type, and put the fields library :: Maybe BuildInfo, executables :: [BuildInfo]  in PackageDescription?
12:16:55 <Marvin--> er, executables :: [(String, BuildInfo)], rather
12:17:49 <SyntaxNinja> hm. sounds like a good idea.  it shouldn't have to make the basic case any harder (just one exe or just one library)
12:18:10 <SyntaxNinja> why not library :: [BuildInfo]?
12:20:03 <Marvin--> because I don't think it makes sense to build more than one library
12:20:30 <Marvin--> what does that mean in terms of another package build-depending on this package?
12:20:42 <SyntaxNinja> hm. that's a point.
12:20:47 <SyntaxNinja> and it also has impact on the -package flag
12:20:50 <SyntaxNinja> (in ghc)
12:20:51 <Marvin--> yes
12:20:56 <SyntaxNinja> OK. you win.
12:25:38 <Marvin--> yay!
12:25:40 <Marvin--> ;)
12:35:53 * Marvin-- writes a splitStanzas function
14:58:19 <shapr> telia suger apa
14:58:31 <stepcut> hey shapr
14:58:36 <shapr> hiya stepcut 
14:59:57 <stepcut> do you ever feel stupid when people come on the channel and say: "I just heard about homotopy and haskell this weekend, so I thought I would write an opengl app in haskell to do homotopy morphing in spherical space, wanna see the source code?"
15:00:42 <monotonom> Hahahaha
15:01:38 <Marvin--> stepcut: yes ;)
15:01:44 <shapr> yes
15:01:48 <stepcut> :p
15:01:55 <shapr> but I sure like being around people who know more stuff than I do
15:02:14 <Cale> You mean you haven't heard of the functor pi_1? :)
15:02:21 <monotonom> I just heard about syntax-directed editing and haskell this weekend, so I thought I would write an eclipse plugin to let you enter haskell programs by syntax-directed editing. wanna see the source code?
15:03:11 <shapr> I get really tired of talking to people who've just discovered control-tab in windows.
15:03:39 <monotonom> Haha. Do they like it?
15:04:04 <shapr> they tell me "hey, did you know you can use the keyboard to navigate in windows?"
15:04:12 <monotonom> Bwhahahahah
15:04:13 <Cale> hahhaa
15:04:15 <Marvin--> haha
15:04:40 <shapr> and I want to say "I've been reading about dependently typed languages over the weekend, wanna hear about 'em?"
15:04:49 <Cale> :)
15:04:58 <RussellOConnor> dependently typed languages are awsome
15:05:15 <monotonom> "Did you know you can have strong static typing without manual type annotations?"
15:05:22 <shapr> anyway, I'd *much* rather be around people who can hear about homotopy and haskell one weekend and then use them.
15:06:23 <Marvin--> hrrm
15:06:35 <Marvin--> I think I'm getting to a point in this refactoring that could use some test cases
15:06:47 <Marvin--> feh
15:07:06 <monotonom> "Did you know you can write f x instead of f(x) in Haskell?"
15:08:02 <shapr> hi nbb, looking for Haskell info?
15:08:25 <nbb> just lurking around ;)
15:08:30 <shapr> stepcut: so, in summary... Yes, I feel stupid when that happens, but I also feel like I'm in the right place to get over being stupid.
15:08:38 <shapr> nbb: ok, if you have any questions, feel free to ask.
15:08:51 <nbb> thx
15:10:13 <stepcut> shapr: :p
15:15:27 * Marvin-- really doesn't want to know what homotopy morphing is ;)
15:19:56 <Cale> well, it's easy if you're doing it in a convex space. You just slide the points of your curve along line segments joining their start and finish positions.
15:20:19 <Marvin--> neat, I got the test case to work
15:35:02 <Marvin--> hmm, maybe I should just pitch this over to syntax for a while
15:45:03 <Marvin--> Finished recording patch 'Refactor package description and parser to handle multiple executables use case'
15:45:05 <Marvin--> phew
15:49:08 <Igloo> :-)
16:09:31 <Marvin--> I'm off to bed
16:24:17 * shapr stabs telia
18:00:27 <SyntaxLaptop> does anyone know offhand where GHC keeps it's list of options?
18:00:38 <SyntaxLaptop> command-line options, I mean
18:35:55 <dons> SyntaxLaptop: $fptools/ghc/compiler/main/CmdLineOpts.lhs
18:36:21 <dons> also DriverFlags.hs
18:36:53 <SyntaxLaptop> thanks
19:47:11 <SyntaxLaptop> does anyone know about the Hood extensions in Hugs and NHC offhand?
19:47:20 <SyntaxLaptop> are they actual language extensions or just a library? are they implemented in GHCX?
19:47:25 <SyntaxLaptop> s/GHCX/GHC
20:20:23 <dons> i've not seen hood references in ghc source
20:46:21 <SyntaxLaptop> dons: thanks.
