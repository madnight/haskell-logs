00:06:30 * SamB bypasses most of the printing infrastructure because he doesn't feel like fighting it now...
00:07:54 <SamB> try doing *that* in windows ;-)
02:20:21 <bourbaki> hiho
04:45:29 * esap appears.
04:50:09 <bour> hi
04:55:25 <lambdawar> greetings
04:56:14 <bour> does someone make use of the emacs haskell mode
04:56:36 <Heffalump> I do
04:57:34 <bour> Heffalump is there no standard colouring?
04:57:46 <Heffalump> no idea :-)
04:57:56 <bour> heh so you dont use colours?
04:58:05 <Heffalump> I do, I just dunno if it's standard.
04:58:17 <bour> ah so you edited the faces?
04:58:20 <Heffalump> no.
04:58:34 <Heffalump> stuff comes up in colour for me, and I didn't do anything to make it do so.
04:58:50 <Heffalump> keywords in brown, data constructors in blue
04:58:58 <Heffalump> and same for type constructors
05:22:29 <bour> hmhmhm dang might be cygwin
05:23:33 <bour> aha! :)
05:52:19 <Igloo> Waah, my modules keep wanting to be recursive
05:52:44 <Heffalump> go and watch Shrek instead.
05:59:30 <ibid> spank them
06:00:12 <Igloo> It's GHC that needs spanking - the report says they're allowed to  :-)
06:01:35 <Heffalump> you can do it with GHC...
06:05:04 <Igloo> Only by messing about with .hi-boot files
08:30:59 <RussellOConnor> Anyone know how to read binary data from a file?  I suppose I want to produce a [Word8] to then parse.
08:32:19 <Marvin--> you could use hGetBuf I suppose
08:33:58 <RussellOConnor> Should I be afraid of `Ptr a', or are my fears unfounded.
08:35:08 <Marvin--> you should always be afraid of pointers ;-) but you can use peekArray :: Storable a => Int -> Ptr a -> IO [a]  to get a list
08:36:25 <Marvin--> but yes, I do think you need to allocate the pointer first
08:37:28 <Marvin--> look in System.IO and Foreign.Marshal.Array
08:37:35 <RussellOConnor> So I have to manage my own memory.
08:37:55 <RussellOConnor> I might be able to live with that.
08:38:37 <Igloo> There's probably something like withalloc that'll take take of freeing it for you
08:39:02 <RussellOConnor> Wouldn't it be nice to have Haskell make a memory mapped file, and let me access it as an array?
08:39:06 <Marvin--> you could also use hGetArray from Data.Array.IO
08:39:30 <Marvin--> don't think it mmaps, but at least you get an array
08:39:58 <RussellOConnor> wow
08:40:00 <Marvin--> hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
08:40:13 <RussellOConnor> hGetArray looks a lot like what I want
08:40:24 <Marvin--> so first you create the array, and then fill it with hGetArray
08:40:35 <RussellOConnor> What is an IOUArray?
08:40:53 <Marvin--> IO array with unboxed elements
08:41:23 <Marvin--> IO array basically means it's mutable
08:42:00 <RussellOConnor> Can I make it unmutable inside my IO monad?
08:42:27 <RussellOConnor> In fact, how it is that it isn't inside an IO monad?
08:42:34 <Marvin--> it is
08:42:36 <Marvin--> -> IO Int
08:42:38 <Marvin--> see? :)
08:42:44 <RussellOConnor> ahh, right
08:42:58 <Igloo> You can convert it to an STArray if you want I think
08:43:39 <Marvin--> RussellOConnor: all the operations on it will be in IO too
08:43:40 <Igloo> Well, STUArray
08:43:40 <RussellOConnor> What does unboxed mean?  That the elements are strict
08:44:44 <Marvin--> it means that the elements are "machine" values rather than "haskell" values, which means less overhead
08:45:24 <RussellOConnor> I guess that implies strict evaluation.
08:45:45 <Marvin--> well, reading the darn values from a *file* sort of implies that already, doesn't it?
08:46:27 <RussellOConnor> True, but since the arrays are mutable, I could want to change the values. ... Fortuantely I don't
08:47:22 <RussellOConnor> I wish the GHC documentation didn't have so many broken links. :-(
08:48:21 <Igloo> You should report broken links
08:48:32 <Igloo> Are they to GHC.* library docs or something?
08:48:58 <Marvin--> If you don't want to modify the elements, you should freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)  the array to get an immutable array from it so you don't have to carry around the IO monad everywhere you go
08:50:14 <RussellOConnor> perfect.
08:50:28 <RussellOConnor> ... I wonder if freezing will make a copy
08:51:04 * RussellOConnor wonders if he shouldn't worry about implementation.
08:51:20 <Marvin--> actually yes, freeze will make a copy
08:51:39 <Marvin--> you can use unsafeFreeze if you don't want to copy
08:52:51 <RussellOConnor> Maybe for now I'll pretend the complier will be smart enought to know I don't need a copy.
08:53:13 <RussellOConnor> I can always make it an unsafeFreeze later
08:54:42 <hyp3rion> test
08:55:12 <Marvin--> RussellOConnor: well, you can safely do something like write a function that internally creates an array, hGetArray into it and then unsafeFreeze it
08:55:27 <RussellOConnor> crap, I can't find where that broken link was
08:57:05 <Marvin--> I'm off to the supermarket since it - wonder of all wonders - isn't raining right now :)
08:57:48 * RussellOConnor tries to think if there is a safe way to freeze without making a copy
08:58:06 <RussellOConnor> You would need to have the mutible array go out of scope inside your monad.
08:58:15 <RussellOConnor> I wonder if Arrows can do this sort of thing.
09:03:01 <Igloo> If you want to box everything you'll have to make a copy (well, not quite a copy as it'll be different)
09:04:08 <Marvin--> well if you use a UArray, the boxing will happen when reading from the array, won't it?
09:05:09 <Igloo> If you are going from an IOUArray to an Array the in-memory representation will change
09:05:45 <Marvin--> hm
09:05:59 <Marvin--> true
09:06:37 <Marvin--> no wait, IOUArray -> UArray is O(1) with -O
09:06:46 <Igloo> UArray, yes
09:07:05 <Igloo> But didn't ROC say he wanted to have lazy values earlier?
09:07:06 <Marvin--> UArray is what I was talking about the whole time! :)
09:08:16 <RussellOConnor> Well, I sort of like laziness, but I don't have a real need for it.
09:09:38 <Marvin--> my point is that if your data comes from freezing an IOUArray that comes from data on a file, there never was any laziness from the beginning
09:10:01 <Marvin--> but now I'm off
09:44:15 <LittleDan> How do you take a substring (or a section of a list) starting and ending at given indicies?
09:45:07 <titanstar> combine drop and take, perhaps
09:45:39 <LittleDan> I'm so stupid, why didn't I think of that
09:45:47 <LittleDan> thanks
09:47:25 <titanstar> np
09:59:12 <Lemmih> Is it possible to make a parser like 'try' which doesn't consume any input even when it doesn't fail?
09:59:26 <Lemmih> I'm using Parsec.
09:59:35 <LittleDan> so what would it do?
09:59:56 <LittleDan> if it never consumes anything
10:01:36 <Marvin--> I don't think that's possible
10:01:38 <Lemmih> It can still fail.
10:01:50 <Marvin--> ReadP has this funky combinator called gather
10:02:18 <Marvin--> gather :: ReadP a -> ReadP (String, a)
10:19:07 <Lemmih> Yay. I solved it.
10:23:54 <Marvin--> 'ello syntax
10:26:22 <SyntaxLaptop> heyhey Marvin--
10:35:51 <Marvin--> "In other news, AltaVista demands that anyone using MSN search pay them $699."
10:35:53 * Marvin-- laughs
10:39:15 <SyntaxLaptop> Marvin--: how's the parser?
10:39:39 <Marvin--> I just sat down to have a look at it
10:41:00 <Marvin--> the reason I wanted to work with ReadP instead of Parsec was that it would make some of the parsers simpler... not that it really matters that much
10:42:00 <SyntaxLaptop> I'm trying to decide how to do the clean target.  I can go through and delete the things that I know we created.  problem with that is that we have to keep the "create stuff" code and "Delete stuff" code in sync.  otherwise, I can just delete the entire build directory, which should have been created for building, but then the down-side is that I might delete something else that was put in there for some reason.  i'm leaning twoar
10:42:57 <ibid> "i'm leaning twoar" - cut off?
10:43:27 <RussellOConnor> Is there a prefered editor for WinXP for editing haskell code?
10:44:06 <Marvin--> vim? emacs? :)
10:44:11 <SyntaxLaptop> hm
10:44:21 <SyntaxLaptop> 'm leaning toward the 2nd option, even though I already implemented hte first.
10:44:28 <bourbaki> bk
10:44:44 <Marvin--> what's the structure of the build directory as of now?
10:45:49 <SyntaxLaptop> dist/{package.tgz, maybe other stuff, build}
10:46:12 <SyntaxLaptop> dist/build/{ModuleA.hs, ModuleA.o, ModuleA.hi}
10:46:29 <SyntaxLaptop> dist/build/ModuleB/{C.{hs,hi,o}}
10:46:30 <SyntaxLaptop> etc
10:46:48 <SyntaxLaptop> so dist is just where we stick various stuff, stuff for bdist targets as well
10:46:49 <Marvin--> then I think it's pretty sane to have the clean command remove the entire dist directory
10:46:59 <SyntaxLaptop> then dist/build is where the build targets go, oh, and the .a file too
10:47:04 <SyntaxLaptop> yeah
10:47:27 <Marvin--> possibly with flags for fine tuning
10:47:34 <Marvin--> like clean --only-build
10:47:46 <Marvin--> or something
10:47:59 <SyntaxLaptop> hmm
10:48:25 <SyntaxLaptop> has anyone ever implemented "rm -r"?
10:48:58 <SyntaxLaptop> presumabliy doesDirectoryExist against a symlink won't return true, right?
10:50:42 <Marvin--> I wouldn't bet on it
10:51:14 <SyntaxLaptop> heh
10:51:29 <SyntaxLaptop> so is there any safe way to recurse down a directory tree without posix?
10:51:36 <Marvin--> nope, doesDirectoryExist follows symlinks
10:54:13 <Marvin--> what you could do is removeFile and catch the error, then check if it's a directory and recurse
10:55:04 <RussellOConnor> How do I allocate an IOUArray Int Word8?
10:55:27 <Marvin--> RussellOConnor: newArray
10:56:03 <RussellOConnor> ah
10:57:13 <Marvin--> SyntaxLaptop: why does the anyOf parser combinator use foldl instead of foldr?
10:58:11 <monotonom> To give left-to-right behaviour maybe?
10:58:37 <Marvin--> anyOf (h:t) = foldl ((<|>) . try) (try h) t
10:58:43 <Marvin--> the darn thing looks overly complicated
10:59:10 <monotonom> But it behaves as expected.
10:59:41 <monotonom> There will be people who want anyOf to attempt h first before attempting things in t.
11:00:25 <monotonom> Hrm but I don't understand the two "try"s. one of them ought to be enough.
11:05:02 <Igloo> You'd only need one if it was foldr
11:06:07 <Igloo> I don't think I see why foldr wouldn't make sense. Is this in parsec or the cabal parser?
11:06:26 * SyntaxLaptop is actually surprsied that the similar built-in function doesn't do what that one is meant to do
11:06:40 <SyntaxLaptop> foldr is fine.
11:06:45 <Igloo> Also, depending on what argument you give it, it might be hideously inefficient
11:07:19 <Marvin--> SyntaxLaptop: choice . map try  probably does :)
11:09:31 <Marvin--> parseLicense = choice [ try (string s >> return l) | (s,l) <- licenses ]  works just fine
11:09:44 <SyntaxLaptop> cool
11:17:11 <SyntaxLaptop> bbl.
11:19:56 * Marvin-- has an evil idea
11:22:30 <Marvin--> parseFoo = choice [ try (string (show x) >> return x) | x <- [minBound..maxBound] ]
11:22:53 <Marvin--> data Foo = A | B | C deriving (Show,Bounded,Enum)
11:22:58 <Marvin--> yay, type system abuse
11:25:41 <LittleDan> how is that abuse?
11:26:06 <LittleDan> isn't that a proper use?
11:27:04 <Marvin--> depends on how you look at it, I suppose
11:27:44 <LittleDan> well, I just don't understand how it could be interpreted at all as abuse
11:28:30 <Marvin--> maybe it's just that I very very rarely use Bounded and Enum
11:28:45 <Marvin--> I tend to associate Enum very closely with numbers
11:29:03 <Marvin--> but you're right, Foo is definitely enumerable
11:34:51 <LittleDan> Isn't Int in those same typeclasses?
11:36:02 <Marvin--> yep
11:36:27 <Marvin--> that'd give you a hideously inefficient int parser though
11:36:55 <LittleDan> what do you mean?
11:38:27 <Marvin--> try (string "-2147483648" >> return (-2147483648)) <|> try (string "-2147483647" >> return (-2147483647)) <|> ...
11:39:39 <monotonom> Hahahahaha
11:40:03 <LittleDan> I don't really get how it works; I'm somewhat of a parsec and Haskell novice
11:40:37 <Marvin--> parseFoo creates a list of all possible values of the data type, and then tries to parse them one by one, with backtracking
11:40:55 <Marvin--> which is all right when you have a data type like Foo, but it's hideous for Int :-)
11:47:16 <Marvin--> nice
11:47:21 <Marvin--> Distribution.Package is looking more and more complete
11:51:21 <LittleDan> What's that?
11:51:44 <Marvin--> oh, I'm working with syntax on Cabal
11:52:03 <LittleDan> cabal?
11:52:09 <LittleDan> is that a new language or something
11:52:28 <LittleDan> or just the word cabal?
11:52:33 <Marvin--> www.haskell.org/cabal/
11:52:49 <Marvin--> Common Architecture for Building Applications and Libraries
11:53:15 <Marvin--> sort of like distutils if you know python
11:53:46 <LittleDan> so it's like things to help with compilation and instalation?
11:53:57 <Marvin--> exactly
11:54:58 <Marvin--> and it's compiler agnostic, so in a perfect world, someone could be developing their haskell library using ghc and you download it and use cabal to install it using hugs
11:55:26 <LittleDan> it's for libraries *and* applications?
11:55:45 <Marvin--> yeah, well, mostly for libraries
11:56:03 <LittleDan> oops, I should've read the naem
11:56:05 <LittleDan> stupid
11:56:39 <LittleDan> Aren't things already compiler-agnostic?
11:57:02 <Lemmih> Is it a fever dream like Haskell world domination or is it actually being worked on?
11:57:36 <Marvin--> LittleDan: building and installing is different for each compiler
11:57:40 <LittleDan> I don't think Haskell can achieve world domination because it's a LFSP, not a LFM
11:58:17 <Marvin--> many many libraries use extensions to haskell98 and the compilers have different sets of flags for turning these extensions on
11:58:18 <Lemmih> LFSP, LFM?
11:58:19 <Marvin--> etc.
11:58:37 <LittleDan> Lemmih: http://www.paulgraham.com/vanlfsp.html
11:59:21 <monotonom> I don't think Paul Graham can achieve world domination.  So much for Paul Graham.
11:59:51 <LittleDan> monotonom: ummm... is that supposed to be some kind of joke?
12:01:02 <monotonom> I think we shouldn't overrate Paul Graham.
12:01:14 <LittleDan> what do you mean?
12:02:17 <monotonom> I mean we shouldn't overrate Paul Graham.
12:02:27 <LittleDan> you mean he's bad?
12:02:34 <LittleDan> well, that actually wasn't paul graham's essay
12:02:41 <LittleDan> just on his website
12:02:57 * Marvin-- even remembers to sign the patch he sent to syntax this time :-)
12:03:24 <LittleDan> what syntax does Cabal need? Are there configuration scripts or something?
12:04:08 <Marvin--> yeah, basically you write a little description file with dependencies, what kind of extensions you use, where the source files are etc.
12:04:36 <LittleDan> Why isn't that done in Haskell, like Distutils does?
12:04:48 <Lemmih> Marvin--: Is it gonna be usable any time soon?
12:05:27 <Marvin--> LittleDan: search me, I said the same thing but got outvoted
12:05:52 <LittleDan> is it because haskell is usually compiled?>
12:06:46 <Marvin--> Lemmih: yeah, actually I think that the package description parser is one of the final pieces of the puzzle before we can do some sort of beta release
12:07:40 <Marvin--> LittleDan: well, we use a distutils-like Setup.lhs file too, but some people thought it valuable to separate the description from the setup code
12:07:40 <Igloo> One reason is that if you just load it as a Haskell module people will do all sorts of things, which will make parsing the descriptions some other way for some purpose much harder
12:08:03 * Marvin-- grins
12:08:04 <Igloo> The xpm format can suffer from that
12:08:09 <Lemmih> Is there anything we, motals, can do to help?
12:08:20 <Marvin--> Igloo: have you seen my setup.py for pyOpenSSL? it's hideous :-)
12:09:00 <Igloo> You see, it's people like Marvin spoiling it for the rest of us  :-P
12:09:18 <Marvin--> Lemmih: well, check out the source, read the TODO, send patches... :)
12:09:38 <Marvin--> Igloo: aww, it's not that bad
12:09:49 <Marvin--> (actually, it is)
12:10:08 <Igloo> But even simple things like using list comprehensions, or even unsafePerformIO, to build module lists would screw a mod_perl automagic whatsit, say
12:10:26 <Igloo> It wasn't a serious comment however bad it is  :-)
12:10:45 <Marvin--> trust me, it *is* that bad
12:11:18 <LittleDan> Igloo: Wouldn't list comprehensions be ha help when building module lists?
12:12:33 <Igloo> Yes, so people would use them. Which would make parsing in perl harder
12:12:48 <Marvin--> distutils in python 2.2 got some basic dependency handling that I wanted to use but still retain backwards compatability with python 2.1 and python 1.5, so what I did was that I wrapped distutils' Extension class and inspected the code objects to see if they supported the 'depends' keyword argument. If not, I deleted those arguments before I called the parent constructor
12:13:08 <LittleDan> what does this have to do with perl? why do you need to protect the programmer in this way?
12:13:48 <Igloo> I think we're going in circles here. My point is it makes it harder to use the files anywhere else (including an already compiled Haskell program)
12:14:16 <Marvin--> well, it *is* rather nice to be able to grep '^Version:' (say) over several description files
12:52:41 <Lemmih> Isn't phubuh working on the Setup.description parser?
12:53:57 <Marvin--> he was
12:54:18 <Marvin--> right before he disappeared :/
12:55:14 <Lemmih> Yay
12:56:36 <Lemmih> I was actually thinking I would like to hack on it when he showed me some of his code.
13:02:24 <Lemmih> Marvin--: You want a Parsec parser instead of just using 'read'?
13:04:42 <Lemmih> Is there some specific reason to avoid read/show?
13:06:25 <Marvin--> the parser is basically finished, but parsePackageDesc doesn't call it yet
13:15:19 <bourbaki> what is wrong with type foobar a = foo a | bar a ?
13:15:35 <LittleDan> capitalization, I think
13:15:41 <LittleDan> unless that's not significant
13:15:50 <LittleDan> oh, wait, use data, not type
13:15:51 <bourbaki> nope consider it
13:16:03 <bourbaki> type Foobar a = Foo a | Bar a
13:16:10 <bourbaki> ok
13:16:14 <LittleDan> does that work?
13:16:30 <bourbaki> no
13:16:37 <LittleDan> use data instead of type
13:16:50 <bourbaki> i did
13:17:04 <LittleDan> you wrote data Foobar a = Foo a | Bar a?
13:17:16 <bourbaki> type Object a = a
13:17:16 <bourbaki> type Arrow a = (String, a -> a)
13:17:16 <bourbaki> Data CatThings a = Object a | Arrow a
13:17:30 <LittleDan> data has to be lowercase
13:17:35 <bourbaki> ah
13:18:06 <bourbaki> ok that does the job
13:18:18 <LittleDan> but I'm not sure those type definitions will do what you want them to do
13:18:55 <bourbaki> i want to be able to have a mapping of both objects and arrows within the same map
13:19:45 <LittleDan> then it should be data CatThings a = Object (Object a) | Arrow (Arrow a), I think
13:19:58 <LittleDan> anyone else more experienced on this sort of thing?
13:20:29 <bourbaki> the mapping would be  CatThings -> CatThings
13:21:18 <LittleDan> Are you using FiniteMap or something?
13:21:25 <bourbaki> nope
13:21:35 <LittleDan> then what's the mapping made out of?
13:22:04 <bourbaki> type MyFunctor a = CatThings a -> CatThings a
13:23:49 <LittleDan> is MyFunctor supposed to be just a single mapping?
13:24:00 <LittleDan> or a collection of mapping
13:24:00 <LittleDan> s
13:24:27 <bourbaki> ah right its supposed to map anything ill have to do that later though
13:25:03 <Marvin--> bourbaki: constructor != type name
13:25:18 <bourbaki> Marvin-- ?
13:25:21 <Lemmih> Doesn't HUnit ship with ghc 6.2.1?
13:25:36 <Marvin--> if you have data CatThings a = Object a | Arrow a, those are different "Object" and "Arrow" than type Object a = a etc.
13:25:53 <Marvin--> as LittleDan said, you want data CatThings a = Object (Object a) | Arrow (Arrow a)
13:26:01 <LittleDan> Marvin--, Thanks, i couldn't figure out how to explain that
13:26:11 <bourbaki> Marvin-- what is Object (Object a) ?
13:26:20 <Marvin--> or simply data CatThings a = Object a | Arrow (String, a -> a)
13:26:33 <LittleDan> you can use teh constructor Object with an argument of type Object a
13:27:01 <bourbaki> ah ok
13:27:11 <Marvin--> bourbaki: the Object in data CatThings a = Object ... | ...  is a constructor, it is used to create CatThings *values*
13:27:21 <LittleDan> you'd probably want to do data CatThings a = Object a | Arrow String (a -> a)
13:28:13 <Marvin--> you have to "tag" each alternative of a data type
13:28:51 <bourbaki> yep i see the point :) now :)
13:32:09 <np_hard> this is probably a stupid question but is there a way to specify a tuple type without specifying its length?
13:32:31 <monotonom> Unfortunately no.
13:32:33 <LittleDan> not unless you use template haskell
13:32:43 <monotonom> If you don't mind, you may use lists.
13:32:58 <bourbaki> lists?
13:33:01 <np_hard> they have to accept heterogeneous members
13:33:11 <np_hard> so they are real tuples
13:33:12 <monotonom> Ah.
13:33:13 <bourbaki> yes thats the point
13:33:20 <Marvin--> then you'll have to use existential types
13:33:23 <LittleDan> use a variant then
13:35:39 <monotonom> I am now inclined to template it.
13:35:41 <LittleDan> can you give a mockup type signature of what you want?
13:36:32 <bourbaki> what i want to do is to get a mapping between two categories
13:36:48 <LittleDan> can you give a mockup type signature
13:36:53 <bourbaki> with a functor that accepts the objects and the arrows of the category
13:36:59 <LittleDan> TYPE SIGNATURE
13:37:08 <LittleDan> of the final thing
13:37:13 <bourbaki> if you tell me what that is :)
13:37:20 <LittleDan> ok :)
13:37:25 <RussellOConnor> There's the broken link.  Trying to follow IArray from <http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html>
13:37:35 <monotonom> id::a->a   a->a is a type signature
13:37:56 <Lemmih> Doesn't HUnit ship with ghc 6.2.1?
13:38:00 <LittleDan> it shows what the type of something is. For example, a function that adds 2 Ints could have a type signature of add :: Int -> Int -> Int
13:38:07 <monotonom> (True,"")::(Bool,String)  (Bool,String) is a type signature
13:38:16 <bourbaki> type MyFunctor a = CatThings a -> CatThings a
13:38:38 <bourbaki> foobarfunctor :: CatThings -> CatThings
13:39:03 <bourbaki> well thats not the whole thing though i need to map anything
13:39:18 <LittleDan> that type signature doesn't make sense
13:39:31 <bourbaki> why?
13:39:31 <LittleDan> CatThings is a type constructor, not a type
13:40:12 <bourbaki> well then i cant solve that
13:40:28 <monotonom> Probably CatThings a -> CatThings a ?
13:40:32 <bourbaki> not that way that is
13:40:38 <LittleDan> yes you can, just change it to foobarfunctor :: CatThings a -> CatThings a
13:40:40 <LittleDan> how is it, then?
13:40:46 <bourbaki> ah ok
13:40:52 <LittleDan> it's parametrically polymorphic, isn't it?
13:42:09 <bourbaki> erm my head is spinning :) ill just write it and then see if its what i need i cant explain it anymore
13:42:26 <LittleDan> could you post yoru whole code somewhere, if you're still having trouble?
13:42:55 <bourbaki> yes but its just the lines you have seen so far
13:43:39 <LittleDan> oh :)
13:43:40 <bourbaki> there are a hell of a lot things i need to do :(
13:43:44 <LittleDan> no actual functionality
13:43:49 <LittleDan> what are you writing this for?
13:43:54 <bourbaki> can you get the type as a string?
13:44:03 <bourbaki> for understanding atm
13:44:14 <LittleDan> yes, I think, if the type is a member of the Typable typeclass
13:44:22 <bourbaki> understanding categories that is
13:45:00 <LittleDan> it won't help you understand categories, though
13:45:42 <LittleDan> I think Hugs's Windows IDE has something to help you visualize the type categories
13:45:55 <LittleDan> I mean type classes
13:46:28 <bourbaki> i need something like (Int, "Int") for some stuff
13:46:43 <LittleDan> I don't think you should need that
13:46:48 <LittleDan> what do you need it for?
13:46:51 <bourbaki> and the objects should be all possible combinations of the name of the type and the type itself
13:47:41 <LittleDan> umm... I don't think that's possible
13:48:01 <bourbaki> why?
13:48:08 <LittleDan> it needs to manually program an instance of itself for the Typable typeclass
13:48:20 <bourbaki> type foo a = (Sting, a)
13:48:45 <bourbaki> and then a data over all possible types
13:48:52 <LittleDan> that's possible, but it can't do that abstraction with types you wanted
13:49:11 <LittleDan> this isn't tcl, you can't get everything as a string
13:49:38 <bourbaki> well there is still a strong barrier between data and code
13:49:40 <LittleDan> types aren't even first-class
13:49:50 <bourbaki> i want to interpret that as string and type
13:50:12 <LittleDan> do you know what static typing is?
13:50:37 <bourbaki> heh yes and thats what i seem to have problems with now
13:51:02 <LittleDan> you don't have runtime type information
13:51:24 <LittleDan> and there's no easy way to get it
13:52:03 <bourbaki> well i cant explain what i want to do really
13:52:31 <bourbaki> i need to know what type there is and that requires me to give it some kind of symbol ie a string
13:53:01 <LittleDan> I'm not sure what you're doing can be done in Haskell. Maybe something like Lisp...
13:53:24 <LittleDan> or another dynamically typed language
13:53:30 <Riastradh> bourbaki, you need to give a more general description of the problem you're trying to solve, not this specific aspect that you think you need to solve in order to solve the broader problem.
13:53:37 <bourbaki> anything that can be done there can be done in haskell :)
13:53:52 <bourbaki> i want to map categories
13:54:12 <LittleDan> what do you  mean by "categories"?
13:54:14 <LittleDan> lists?
13:54:18 <LittleDan> type classes?
13:54:22 <Riastradh> LittleDan, categories as in category theory.
13:54:22 <LittleDan> functions?
13:54:28 <bourbaki> yes
13:54:28 <LittleDan> oh, sorry
13:54:35 <LittleDan> well, I'm at a loss
13:54:36 <bourbaki> categories as in cat theory
13:54:54 <Riastradh> bourbaki, and you have to implement the entirety of this yourself, or would the existing map operator work?
13:54:57 <Riastradh> @info fmap
13:54:58 <lambdabot> -- fmap is a method in class Functor
13:54:58 <lambdabot> fmap :: forall f :: (* -> *). (Functor f) =>
13:54:58 <lambdabot> 	forall a b. (a -> b) -> f a -> f b
13:55:29 <LittleDan> do I need to know category theory to understand Haskell fully?
13:55:40 <bourbaki> well i need to understand all that from the base to tep
13:55:42 <bourbaki> top
13:55:55 <Riastradh> It would help in many aspects of Haskell, LittleDan.
13:56:06 <bourbaki> so i would like to write it from the base to to as generic as possible
13:56:48 <Smerdyakov> LittleDan, no.
13:56:56 <bourbaki> ie when i have Mor(A,B) then i will have to get a sybol of the type or all arrows aka functions that is
13:58:07 <Riastradh> bourbaki, perhaps it would be easiest to start from the very beginning.
13:58:33 <bourbaki> what is more basic then the objects?
13:58:34 <Riastradh> Are you just trying to implement some category theoretical operators?
13:58:55 <bourbaki> no i try to build CT in an abstract way
13:59:07 <bourbaki> as in the mathematical definition
13:59:25 <esap> that's quite a big task :-)
13:59:34 <bourbaki> heh yes
13:59:45 <bourbaki> and its boggleing my mind
14:00:08 <LittleDan> I think you need a firmer grasp of Haskell before you can do that
14:00:57 <bourbaki> esap is that data thing over all these (type,typename) pair a good representation of the objects?
14:01:27 <esap> bourbaki: what data thing?
14:02:39 <bourbaki> that (i think its the cat sum) data foo = ObType1 (type, typename) | .... | ObTypen (typen, typenamen)
14:02:59 <bourbaki> then arrows would be functions foo -> foo
14:03:12 <bourbaki> and the type object woule be foo
14:03:33 <bourbaki> ok im mixing up some things ;)
14:04:01 <LittleDan> why do you need the type name?
14:04:13 <LittleDan> if you already have it in an unamiguous constructor
14:04:17 <bourbaki> if i cant get the name of a type
14:04:25 <esap> bourbaki: That sounds like you're trying to build some kind of universal type that would represent any other type. It's not that simple, and it'll lead to some bad design, I'd say.
14:04:34 <bourbaki> i need it later not at that time
14:04:57 <bourbaki> esap hm ok but you get what i want to do dont you?
14:05:01 <LittleDan> What kinds of math do you need to know to understand category theory?
14:05:05 <TheHunter> bourbaki, arrows are not necessarily funtions
14:06:03 <bourbaki> TheHunter still in need a way to model the objects in an abstract way
14:06:03 <esap> bourbaki: yes, I think it's a kind of language (interpreter/compiler) you want to build.
14:06:10 <bourbaki> and the arrows also
14:06:23 <bourbaki> esap yes i think its the lisp influence in me ;)
14:06:40 <LittleDan> esap: You mean he should make a new languaeg?
14:07:27 <bourbaki> well thats basically what will happen in the end i think but what bothers me it that i have to start that early to do that stuff but i dont see no other way anymore
14:07:28 <esap> littledan: well I'm not exactly sure whether bourbaki should do that, but at least that's what he's been doing :-)
14:08:03 <bourbaki> heh :)
14:08:14 <bourbaki> neither do i know what i am doing anymore ;)
14:08:39 <bourbaki> i cant stop thinking about it though ;)
14:10:35 <LittleDan> do you know of any introductions to category theory for stupid people?
14:11:14 <Marvin--> ooh, ooh, I want that too
14:11:20 <Marvin--> "Category Theory for Dummies"
14:11:59 <esap> littledan: depends on how simple you want. One good is categorical primer http://citeseer.ist.psu.edu/487012.html. And Categorical manifesto: http://citeseer.ist.psu.edu/goguen91categorical.html
14:12:20 <Marvin--> "When you see this icon in the margin, there will be lots of funky greek letters and stuff in the text, woo!"
14:12:58 <Riastradh> Where? where?!
14:14:02 <bourbaki> esap how would you represent the objects?
14:14:27 <bourbaki> and how would you implement that mor(a,b)?
14:14:40 <LittleDan> you're going to need to make a new type system if you want full runtime type information
14:14:54 <bourbaki> i mean thats a function over types so they have to have some kind of symbol
14:15:25 <esap> bourbaki: Now, first, category theory doesn't put any representation on objects. But in specific cases, like what I understand your situation is, you should choose something based on what the semantics of your objects are.
14:15:27 <LittleDan> OCaml is extremely hackish, so they have something kinda like that. It's called Obj.magic
14:16:29 <bourbaki> esap ok but that would not allow me to build a framework of it as in the mathematical definition right?
14:17:03 <bourbaki> i try to not hack though with is why i want to use haskell
14:17:05 <LittleDan> does the mathematical definition of category theory specify that all Haskell types must be included?
14:17:14 <Smerdyakov> bourbaki, how do you implement math?
14:17:25 <Smerdyakov> bourbaki, most math is very non-constructive and non-computational.
14:17:30 <bourbaki> heh :)
14:17:49 <bourbaki> yeah but thats just really really abstract i think
14:17:56 <Smerdyakov> It's not a joke... it's something you should keep in mind before imagining there is some sensible project describable "implementing category theory."
14:18:22 <bourbaki> yeah i know what you mean but that would not say that its not worth to think about it
14:19:03 <monotonom> "implement ring theory" simply means writing a module interface that contains the ring operations.
14:19:18 <bourbaki> right
14:19:20 <esap> bourbaki: well you're right, it doesn't allow. But OTOH, category theory by itself doesn't even try to describe what happens in the objects. So to get a representation for objects, you have to look beyond that, and see what is the meaning of the objects. I think in your case, you'll want to represent data types with the objects. You'd need to describe what kind of data you support to do that.
14:19:44 <monotonom> The program thus written will not prove the first isomorphism theorem, I assure you.
14:20:20 <monotonom> Similarly, "implement category theory" does not mean to prove Yoneda's lemma.
14:20:25 <bourbaki> esap right i want the user to be able to add objects though of course there is a limit of what i can do there
14:20:42 <TheHunter> bourbaki, what about class Category o a | a -> o where {dom :: a -> o; cod :: a -> o; comp :: a -> a - > a }?
14:20:52 <bourbaki> what was that lemma? i have read about it but i cant remember
14:21:17 <LittleDan> what does category theory have to do with Haskell?
14:22:03 <bourbaki> TheHunter hm but how do you get the morphisms of that cat them?
14:22:30 <esap> bourbaki: yoneda lemma describes how Mor(A,B)  [or C(A,B)] works, at least one aspect of it. Used to prove lots of theorems.
14:23:02 <bourbaki> ah ok ill read on that tomorrow i dont think that i am able to understand anything today anymore :)
14:23:05 <TheHunter> bourbaki, the class represents a category with morphisms of type a and objects of type o
14:23:26 <esap> http://en.wikipedia.org/wiki/Yoneda_lemma has description
14:23:45 <bourbaki> the problem is that i need the cat also as data not only as structrue
14:24:35 <TheHunter> bourbaki, why?
14:25:17 <bourbaki> you wont be able to construct categories otherwise or have real functors over them or am i wrong there?\
14:25:44 <bourbaki> i am still a total haskell newbie ;) so i am not sure how to do what i want to do in haskell
14:26:10 <LittleDan> maybe you should focus on learning Haskell, then you can do all of this stuff in category theory
14:26:36 <bourbaki> imho haskell is not hard to learn
14:27:02 <bourbaki> its just some tricks that are hard to get i guess
14:27:24 <LittleDan> Haskell is easy to learn, hard to understand
14:27:47 <bourbaki> i like to apply what ableson said about scheme
14:27:50 <bourbaki> its like chess
14:28:06 <LittleDan> but it's even more applicable here
14:28:10 <bourbaki> you can learn the rules quickly but it needs years to master i guess the same applies to haskell
14:28:43 <esap> chess is not a good example, it's way too hard to start on chess.
14:29:01 <bourbaki> then go ;)
14:29:07 <esap> that's better :-)
14:29:18 <bourbaki> do you play go ?:)
14:29:23 * esap nods.
14:29:35 <bourbaki> cool whats your rank?
14:29:41 <esap> 6k
14:30:05 <bourbaki> pretty good would you mind to play a 9x9 game another day?
14:30:17 <esap> sure
14:31:31 <LittleDan> esap: the category theory paper you pointed me to says category theory is bunk
14:32:11 <esap> littledan: heh, that's a famous quote :-)
14:32:31 <bourbaki> :)
14:32:44 <bourbaki> abstract nonsense ;)
14:35:30 <LittleDan> the Zeta lemma of category theory: for every category, there exists a functor which transforms a set C of categories within the category into set D of functors which represent the categories
14:35:38 <LittleDan> I just made that up
14:36:00 <LittleDan> but it sounds real, doesn't it?
14:36:37 <TheHunter> bourbaki, so want to be able to construct the category A^B, for example? This is possible with my definition (though probably not in a really easy way). You should probably get a firm understanding of Haskell (that is, ghc -fglasgow-exts or hugs -98) typeclasses before you can do this.
14:36:44 <esap> almost. Only that functors hardly represent categories, they represent diagrams of the categories.
14:37:00 <esap> s/of/in/
14:37:07 <LittleDan> esap: yeah, I know, but to someone who doesn't know category theory
14:37:20 <bourbaki> TheHunter i want to construct them at run time
14:37:44 <TheHunter> bourbaki: You only want to consider finite categories?
14:37:54 <bourbaki> yes
14:38:21 <bourbaki> though
14:38:58 <bourbaki> as in that tree constructing example i could construct infinite cats i guess and then do something with it as pruneing or so
14:39:49 <TheHunter> bourbaki, be careful, categories are usually inherently more infinite than most other things you encounter in math (at least when you perform constructions on them)
14:40:31 <bourbaki> well my idea is to write progams with categories
14:41:03 <LittleDan> TheHunter: How can something be "more infinite" than irrational numbers?
14:41:19 <esap> bourbaki: Haskell is already how you can write programs with categories :-)
14:41:40 <Heffalump> littledan: at a guess, the power set of the irrational numbers?
14:41:51 <thebug> this application brought to you by the letters H and S
14:41:58 <bourbaki> esap yeah but you know what i mean :) i hope so at least :)
14:42:46 <LittleDan> Heffalump: I have no idea what that means, so I'll just have to assume you're right
14:42:50 <Heffalump> I'm guessing a bit.
14:43:05 <Heffalump> I think there are more subsets of the set of irrational numbers than there are irrational numbers.
14:43:23 <LittleDan> I thought that that was undecidable
14:43:40 <bourbaki> dont they have the name irrational becasue of a rather historical incidence?
14:44:00 <TheHunter> LittleDan, it's even worse than  power sets. In category theory you consider small categories and large categories, where usual mathematics takes place in small sets.
14:44:03 <Heffalump> what's undecidable?
14:44:06 <bourbaki> because ppl werent able to imagine infinite numbers or so?
14:44:27 <Heffalump> I think the point was that constructing a number as a fraction is somehow 'rational'.
14:44:37 <LittleDan> Heffalump: you can prove it both ways; it's a contradiction
14:45:07 <Heffalump> probe _what_?
14:45:10 <Heffalump> s/probe/prove/
14:45:15 <LittleDan> the pythagoreans thought all numbers were rational, so when they discovered irrational numbers, they said they were wrong and irrational
14:45:19 <Heffalump> and that's not the definition of undecidability
14:45:28 <LittleDan> Heffalump: sorry
14:45:28 <Heffalump> that makes sense
14:53:56 <LittleDan> what does category theory have to do with haskell? Is it haskell specifically or just functional programming?
14:55:01 <esap> littledan: category theory is a generalization of many things, including Haskell. But I think Haskell design has been quite much influenced by category theory.
14:55:19 <LittleDan> in what way?
14:55:26 <esap> littledan: so many terms (say, Functor) are directly taken from category theory, for example.
14:55:38 <TheHunter> LittleDan, basically, there is the category of haskell types and functions between those types
14:57:06 <esap> littledan: So it is useful for learning Haskell to learn category theory and vice versa.
14:58:10 <esap> littledan: but they are still somewhat different in that Haskell also has to care for being executable on the machine :-) Category theory can generalize even that :-)
15:01:55 <TheHunter> category theory makes you thinks differently about things. I just heard the word copilot and wondered what the hell is dual to a pilot?
15:02:11 <Marvin--> and that's supposed to be *good*?
15:02:16 <esap> hehe :-)
15:02:29 <TheHunter> that's a very bad thing
15:02:37 <Marvin--> oh
15:02:39 <Marvin--> just checking
15:03:16 <ibid> interesting that the dual of a spy is a certain kind of firm
15:03:23 <ibid> by that logic :)
15:04:32 <Marvin--> I've already had one headache this week, thank you very much
15:04:48 <ibid> (operative and cooperative, that is)
15:05:08 <ibid> one could make a game out of this
15:05:17 <Marvin--> oh god
15:05:17 <ibid> "what is the dual of a spy?"
15:05:33 <ibid> :)
15:05:48 * esap brings out all the comathematician jokes.
15:09:19 * Cale turns some theorems into coffee.
15:10:05 * esap forms an equivalence class by turning the coffee back to theorems.
15:10:19 <ibid> be careful, there is only a limited number of theorems...
15:10:29 <LittleDan> well, since theorems and arrows can be put in the same category, a functor exists to transform a set of one into the other, right?
15:10:31 <ibid> known theorems, that is
15:13:38 <Marvin--> I think this is the part where I run away, screaming
15:35:38 <bourbaki> http://rafb.net/paste/results/SnRyKG94.html
15:35:49 <bourbaki> this is somehow what i was thinking about
15:41:50 <monotonom> You only dualize twice.
15:42:06 <bourbaki> hm?
15:42:33 <bourbaki> monotonom why is that a problem?
15:43:12 <monotonom> Oh just another dual joke and at the same time a pun on a Bond movie name.
15:43:32 <bourbaki> heh
15:44:13 <TheHunter> bourbaki, from the way you write it, i think want you want is existential types
15:44:34 <bourbaki> TheHunter what is that?
15:44:37 <TheHunter> the ArrowEdge thing doesn't seem to make much sense
15:44:53 <bourbaki> why?
15:45:21 <bourbaki> i want to get the domain codomain as well as the function between them
15:45:56 <bourbaki> sry
15:46:29 <TheHunter> the two CatNodes are the domain and the codomain, right.
15:46:44 <TheHunter> s/\./?/
15:46:44 <bourbaki> yes
15:47:08 <bourbaki> and they contain the type and a name
15:47:13 <TheHunter> the whole point of category theory is that you don't describe what arrows (aka morphisms) are.
15:47:27 <TheHunter> You only describe what happens if you compose them
15:48:02 <bourbaki> except if you want them to do something
15:49:02 <TheHunter> so if you want to describe a category you should provide a composition function
15:49:22 <bourbaki> yep
15:49:36 <bourbaki> composition of two categories?
15:50:39 <TheHunter> I think I finally got what you're trying to do
15:50:45 <bourbaki> :)
15:50:51 <TheHunter> you want concrete categories
15:50:59 <bourbaki> yes
15:51:29 <bourbaki> i want to implement them as graphs
15:51:36 <bourbaki> with a topology
15:51:46 <bourbaki> Glue :: Cat_Grpah -> Cat_Graph -> [[Cat_Node]] -> CatGraph
15:52:07 <bourbaki> and my + for categories looks like that then
15:52:48 <bourbaki> that is something like A + B \ ~ topological adjoint if i am not mistaken
16:00:22 <TheHunter> are you sure you get again a category by using glue?
16:02:17 <bourbaki> yes its a continous mapping between two topologies
16:03:20 <TheHunter> so you are actually only interested in topology?
16:03:20 <bourbaki> and programs look something like this
16:03:20 <bourbaki> type Machine t = (String, CatGraph ([t],t))
16:03:58 <bourbaki> nope also automatons
16:04:13 <bourbaki> and graphs
16:04:48 <bourbaki> thats what i try to links somehow (automatons, graphs, topology and ct)
16:06:54 <bourbaki> TheHunter you are a mathematician right?
16:07:07 <TheHunter> yes
16:07:21 <bourbaki> does this look right to you so far?
16:07:53 <TheHunter> i don't know much about automatons and graphs
16:07:54 <bourbaki> except that the categories are just over a single type so far which i would like to change buy combineing them in a single type
16:08:31 <bourbaki> but it does look like a rather general way of categories doesnt it?
16:09:57 <TheHunter> it looks interesting, but i think you have to be careful to get the theory right
16:10:20 <bourbaki> well that is why i show it to all of you :)
16:10:43 <TheHunter> what about those machines? how do they work?
16:11:11 <bourbaki> well the type is in each channel
16:11:18 <TheHunter> you want to glue them together in some way, right?
16:11:19 <bourbaki> nodes are channels in progams
16:11:27 <bourbaki> yes
16:11:32 <bourbaki> i gule progams
16:11:40 <bourbaki> i will explain you what channels to
16:11:40 <bourbaki> do
16:11:51 <bourbaki> channels are the nodes in programs they are just like this channel
16:11:59 <bourbaki> functions listen to the channel so to say
16:12:20 <bourbaki> and then they do something with the presented data
16:12:27 <bourbaki> map it to another channel that is
16:12:46 <bourbaki> it they do that new type of the Machine takes care of that
16:12:58 <bourbaki> ([t],t) is the channel with a certain type t
16:13:07 <Smerdyakov> bourbaki, did you know that punctuation and capitalization were invented to make written language more readable?
16:13:13 <bourbaki> it can stack elements of type t
16:13:33 <bourbaki> no :)
16:13:57 <bourbaki> i use a lot of smilies though cause they make it more funny ;)
16:14:36 <bourbaki> i am bad at expressing myseld
16:14:38 <bourbaki> myself
16:15:18 <TheHunter> in such a machine, is the wiring fixed or can functions add channels they're listing to?
16:15:37 <Smerdyakov> Concurrent ML.
16:15:50 <bourbaki> that is what i am bothering with atm
16:15:59 <bourbaki> bothering my brain
16:16:29 <bourbaki> i want to be able to add channels to a cat with an arrow inside the category
16:16:46 <Smerdyakov> I've often found myself wanting to add channels to a cat.
16:17:05 <bourbaki> well my programs do exactly that
16:17:22 <bourbaki> my programs are categories over channels so to say
16:17:56 <Smerdyakov> Cat as in "meow."
16:18:04 <bourbaki> :)
16:18:48 <bourbaki> channels like what :)?
16:18:59 <Smerdyakov> CSPAN
16:19:12 <bourbaki> whats that?
16:19:44 <Smerdyakov> A US television channel that shows our national legislature 24 hours a day.
16:19:53 <TheHunter> sorry, i don't see the category theory in that. What are the objects/arrows of your category
16:19:56 <gdsx> Smerdyakov: don't forget CSPAN2
16:20:19 <bourbaki> TheHunter edge_arrow is its an edge and an arrow
16:22:01 <bourbaki> an edge is something that has a name and two nodes
16:22:09 <TheHunter> you have those machines which are certain graphs (that's how I understand it).
16:22:16 <bourbaki> and an arrow is something that has a name and a function
16:22:25 <bourbaki> yes
16:22:50 <bourbaki> where every node has an agenda of things like in a socket or so
16:23:20 <TheHunter> the edges of the graph is a function from a stream to stream
16:23:27 <bourbaki> yes
16:24:02 <TheHunter> but these graphs aren't categories, i think
16:24:13 <bourbaki> why?
16:24:31 <bourbaki> they fulfill all the laws dont they?
16:24:59 <TheHunter> categories have an identity for each object and the composition of two composable arrows is again an arrow
16:25:24 <bourbaki> yes i omit that thats ture
16:25:51 <bourbaki> because to me its a technicality that is not needed really just consider them to be there
16:26:48 <bourbaki> i think you might be able to use them to syncronize now that i think about it
16:28:14 <TheHunter> ok, as long as there are no cycles, you get a category.
16:28:39 <bourbaki> why is that?
16:29:00 <bourbaki> is there somehting that follows out of the laws that its forbidden?
16:29:41 <TheHunter> do you have special in- and out- nodes?
16:29:55 <bourbaki> no
16:30:28 <bourbaki> though if you want you could model that if you take sometype (in,out) and plug that in
16:30:49 <TheHunter> where do the values the channels get come from?
16:31:08 <bourbaki> they are written by other programs or the user
16:31:15 <bourbaki> imagine a bot in this channel
16:31:31 <bourbaki> he has some endomorph functions from this channel to this channel
16:34:52 <bourbaki> TheHunter still with me?
16:35:06 <TheHunter> yes, i'm thinking
16:35:15 <bourbaki> oh :)
16:37:11 <TheHunter> i guess you are considering the category of "channels" and functions between channels that are called during execution of the machine (all possible machines?)
16:37:28 <bourbaki> yes quite so
16:37:40 <TheHunter> that seems quite artificial
16:37:59 <bourbaki> is that good or bad :)?
16:38:17 <bourbaki> automatons are very similar to that
16:38:39 <bourbaki> that way to execute programs that is
16:38:40 <TheHunter> i don't know how to get anything out of these categories
16:39:14 <bourbaki> i will try to continue the program :)
16:39:34 <bourbaki> maybe it will show what i mean
16:39:52 <bourbaki> at least its good that you dont see a problem with loops
16:40:02 <TheHunter> seems to me that category theory isn't the right hammer for this problem, so prove me wrong! :)
16:40:27 <bourbaki> another fine thing is that i can or hope to be able to construct programs like cw-simplices in topology
16:40:37 <bourbaki> heh
16:40:43 <TheHunter> the problem still seems interesting
16:40:59 <bourbaki> cool thanks :) i want to apply it on ai
16:41:11 <bourbaki> thats what my thesis is about
16:41:27 <Smerdyakov> Describing something as "AI" is totally irresponsible. There is no consensus on what that means.
16:41:39 <bourbaki> yes you are right
16:42:11 <bourbaki> i was refering to the field of computational ai that is stuff like FSM, decision trees, neural nets and the like
16:44:36 <bourbaki> the idea is that you can compose the algorthms somehow
16:46:11 <TheHunter> i see, the topological analogy seems to be much more apropriate than the categorical one.
16:46:44 <bourbaki> well i want to make these chanel programs catesian closed categories
16:46:56 <bourbaki> so i can build new channels that are the product of two
16:48:40 <bourbaki> maybe you can find interesting properties in your programs if you see them as categories
16:49:11 <TheHunter> Wait, you mean you want to consider a category of channel programs which is cartesian closed. That's quite different from what i thought so far.
16:49:13 <bourbaki> maybe you could search in your category with some graph algos to match interesting categories with your program
16:49:53 <bourbaki> i think of it that you can build the product over any two channels
16:49:57 <bourbaki> or objects
16:50:25 <bourbaki> thats like the categorical product to me
16:50:30 <TheHunter> ah
16:51:00 <bourbaki> you have to channels and you want to get the product of both functions that head away from a node
16:51:45 <bourbaki> and with that you can do stuff like if clauses so that you can reduce the stuff the machine computes since it its deterministic there is always only one way the program runs
16:52:11 <bourbaki> so if you see the product over the whole process there are a lot of nils or so and just one value
16:52:28 <bourbaki> do i dont process the nil paths so to say
16:53:40 <bourbaki> if you run programs that can run in mayplaces at the same time that is something different but still there are just as many values in that vector as threads that run so to say
16:54:54 <bourbaki> and the caterogy sum is something that could be used to model something like the feeding two machines at once
16:56:32 <bourbaki> i hope to get something of the caterogy aspect for makeing sense of programs
16:57:24 <bourbaki> if you would model a problem in such a way you could search for analogical structures to other categories and do something like lifts to them
16:59:11 <bourbaki> now that i have scared you all off ....
16:59:31 <TheHunter> seems like a big project...
16:59:39 <bourbaki> :)
17:00:05 <bourbaki> but i have to start somewhere
17:00:22 * esap has been trying to understand programming languages for decades and I still don't understand how coroutines really work :-)
17:00:32 <bourbaki> i bet if ppl start to think about it they will come up with a lot ideas from different places of the fields
17:01:10 <bourbaki> coroutines?
17:01:13 <TheHunter> i still don't see what your categories actually are.
17:01:29 <bourbaki> esap do you see it?
17:01:49 <esap> bourbaki: that's a control structure where there are two communicating pieces of code.
17:01:53 <TheHunter> esap, are there programming languages other than sceme where you can define coroutines?
17:02:22 <Smerdyakov> Any with call/cc
17:02:29 <TheHunter> ok
17:02:29 <esap> TheHunter: Well I don't think they are universally very well supported. But you can build similar facility in many languages, including C++ and Haskell.
17:04:45 <TheHunter> do you need coroutines when you have lazy evaluation?
17:05:25 <bourbaki> what are coroutines?
17:06:17 * TheHunter just found out ruby has call/cc
17:06:25 <esap> bourbaki: well think 'subroutines'. Coroutines are like subroutines, except that there the two participants are 'at same level' in the sense that there is no 'caller' and 'subroutine', but both are in equal position to each other.
17:07:01 <bourbaki> like a thread?
17:07:46 <esap> bourbaki: well the 'context switches' are explicit, you have to specifically say when you do it.
17:08:14 <bourbaki> like in a scheduler?
17:08:24 <esap> bourbaki: it's more like sending and receiving messages [but not like OO].
17:08:53 <bourbaki> like in a message handleing system ie operating system
17:09:36 <esap> something along those lines. But coroutines are 'only' a control mechanism, nothing fancy, it's pretty primitive operation.
17:09:49 <bourbaki> ah ok
17:10:03 <bourbaki> first i thought it was related to co algebras
17:10:16 <esap> no, it's not related to OO :-9
17:10:34 <esap> at least not directly.
17:10:41 <bourbaki> well that corutines thing sounds like what would happen if i write an interpreter for my Machines
17:12:13 <esap> bourbaki: I actually thought that what you do with the graphs would be one application where coroutines would be useful [e.g. to represent the semantics of the channels].
17:12:28 <TheHunter> ok, i'm gonna go to bed
17:12:41 <bourbaki> yes that depends on how it all will be executed
17:12:45 <bourbaki> good night
17:13:05 <bourbaki> esap i have a lisp implementation that runs bots in channels to do all that
17:13:30 <bourbaki> i think i will use both codes to show that it both is possible
17:14:17 <bourbaki> the lisp code is distributable but i would not be able to crunch code together as in "folding" subgraphs to nodes
17:14:43 <bourbaki> what i see as something like a compilation
17:14:57 <esap> see http://www.computerdictionary.info/computer-term-details/Coroutine
17:15:48 <bourbaki> i also thought that its quite similar to that inferno and plan9 thing
17:16:02 <bourbaki> and their language limbo shapr pointed that out
17:16:33 <bourbaki> one idea i had was to apply that to the linux file system
17:16:41 <bourbaki> where you can cat from and to files
17:17:14 <bourbaki> and map that file system to a graph and programs that read and write programs are just glued at the right place
17:18:27 <bourbaki> ie you want to log what happens in the channel you would add a function (arrow) to a file from this channel
17:19:49 <bourbaki> i am quite happy that no one so far said that its a non sense project :)
17:20:15 <esap> it's big, at least.
17:20:51 <bourbaki> well my idea was to point out some interesting things that can come up by that im my thesis
17:20:58 * esap has been doing my own hobby project for about 7 years now and I'm saying your project is big :-)
17:20:59 <bourbaki> and write some small examples
17:21:07 <bourbaki> :)
17:21:34 <bourbaki> i thought that if its interesting enough they will allow me to write my masters thesis about it :)
17:22:43 <esap> as far as my experience goes, they allow you to write almost from any subject.
17:23:30 <bourbaki> well at my university you usually choose some stuff that they let you choose from
17:23:54 <bourbaki> but i had this idea and went to my prof and told him that i would like to do that in my thesis and it seems to be ok
17:24:18 <bourbaki> thats why i started almost 2 semester earlier :)
17:24:23 <esap> hmm.. different from here then, because I think most people here make thesis from something they encounter at work [=very simple and trivial things]
17:25:05 <bourbaki> yeah the bachelors thesis is meant to be something really simple at our place also and they are open for ideas but most ppl dont come up with own things really
17:25:30 <bourbaki> so they seem to have a collection of things you can choose from if you dont come up with something good
17:25:57 <bourbaki> and the masters thesis is coupled to some project you have to do at the university
17:26:02 <bourbaki> in groups
17:26:11 <esap> There wasn't any way to get bachelors degree for us, only master's.
17:26:21 <bourbaki> ah ok
17:29:23 <bourbaki> though we dont do enough computation and math stuff :( imho
17:30:26 <esap> Well I guess that's an universal problem :-)
17:30:37 <bourbaki> hehe
17:31:06 <bourbaki> that matching of nice categories into a problem could be seen as crafting classes or so
17:31:18 <esap> Though I've sometimes thought it's just me :-) And I went though all the courses I could find that were even remotely related to CS...
17:31:28 <bourbaki> :)
17:31:51 <bourbaki> well i am not really good at memorizeing the stuff since i dont use it often enough
17:32:21 <bourbaki> but i am quite good at remembering intersting ideas of mathematical things and like to toy around with them :)
17:32:23 <esap> memorizing? I never could memorize anything for longer than 10 minutes or so :-)
17:32:30 <bourbaki> :)
17:32:37 <bourbaki> welcome in my world :)
17:32:40 <esap> ok, maybe half an hour :-)
17:33:51 <bourbaki> i will read further im my topo book i have seem a lot more interesting things you can do on topologies that would be nice for programs
17:35:15 <bourbaki> something else i thought about to change the topic :) is a monadic renderer
17:35:31 <esap> well the whole mathematics is full of interesting ideas that are useful for programs.
17:35:56 <bourbaki> yes but its quite simple to apply them once they are topologies ;)
17:35:57 <esap> monadic renderer? you mean like 3D engine?
17:36:06 <bourbaki> yes
17:36:18 <bourbaki> i want to construct a render pipeline with them
17:36:20 <esap> bourbaki: I could say the same for category theory. I could never understand topologies :-)
17:36:21 <bourbaki> and a render graph
17:36:45 <bourbaki> for me its quite imaginable in terms of 3d rendering
17:36:51 <bourbaki> have you seen my homotopy demo?
17:37:05 <esap> I've actually worked in a small company that did 3D engines.
17:37:19 <bourbaki> http://codemages.sf.net/homotopy1.hs
17:37:41 <bourbaki> i worked on an engine for 2 1/2 year as a pro :)
17:39:09 <bourbaki> www.codecult.com
17:39:10 <esap> hmm. the link doesn't seem to work.
17:39:30 <bourbaki> http://www.nvidia.com/object/games_codecult.html
17:39:49 <bourbaki> it works here
17:41:02 <bourbaki> did you do some work on that 3d engine with haskell?
17:41:14 <esap> no, C++.
17:41:42 <bourbaki> well i think it might be a cool way to build renderpipelines maybe
17:45:27 <bourbaki> esap have you had a look at the file?
17:46:23 <esap> I'm still having trouble accessing it. It might be I wasn't logged on to sourceforge.
17:46:32 <bourbaki> sec
17:48:02 <bourbaki> http://rafb.net/paste/results/Cgkynx57.html
17:48:07 <bourbaki> k posted it
17:48:43 <esap> ok, that's better.
17:48:51 <bourbaki> thats something i made after i read about homotopies in my topology book my first haskell program :)
17:50:21 <esap> you're not using much 'data' declarations, I wonder why?
17:50:45 <bourbaki> well i have not read that far im my haskell book i think :)
17:51:30 <esap> hehe :-) If you've been able to do this big program without running into need for algebraic datatypes, I'm wondering.. :-) I can hardly do anything without :-)
17:51:51 <bourbaki> have you run the program?
17:52:23 <bourbaki> well i just did what my topology book said :) i just used the same types
17:52:35 * esap doesn't have GLUT installed :-)
17:52:52 <Cale> neat :)
17:52:59 <bourbaki> dang too bad cause you cah morph between splines
17:53:14 <bourbaki> i was about to write a mapping that maps from spheres to meshes
17:53:23 <bourbaki> and then has a mapping bwtween spheres
17:53:33 * esap is wondering whether I can install glut via some Debian package easily :-)
17:53:37 <bourbaki> so that you can morph meshes
17:53:58 <bourbaki> yes i think you can i was able to do it :)
17:55:39 <bourbaki> or you could do animations with that also
17:55:52 <bourbaki> when you have a lot of the homotopies in a row
17:56:59 <bourbaki> Cale maybe you want to add some more letters :)
18:03:17 <bourbaki> i was thinking about writeing a small demo in haskell :)
18:09:02 <bourbaki> anyone still awake :)?
18:09:31 * esap is still trying to get GLUT working. I seem to miss some libHSGLUT libraries 
18:10:10 <bourbaki> heh :)
18:10:34 <esap> is there some debian package that contains them?
18:10:51 <bourbaki> hm yes i think so
18:10:59 <esap> what's the name? I didn't find.
18:11:12 <bourbaki> hm i dont have a debian machine atm
18:11:16 <bourbaki> sec
18:12:19 <bourbaki> i think its something with ghc
18:12:20 <Cale> esap - did you compile with ghc --make homotopy.hs -lglut -o homotopy ?
18:12:57 <esap> no, I tried -package GLUT [I did have such line in package.conf]
18:12:57 <Cale> this made it work for me
18:13:24 <bourbaki> there also is an error in the package.conf or at least there was
18:14:07 <esap> it says 'Can't find module 'Graphics.UI.GLUT''.
18:14:46 <esap> and package.conf referes ti /usr/lib/ghc-6.2.1/imports which doesn't have anything resembling glut.
18:15:05 <bourbaki> i think i used hopengl but i am not sure
18:15:39 <esap> oh I don't have ghc6-hopengl installed :-)
18:15:46 <bourbaki> that was something that made me wonder on win32 its just installing the exe file
18:15:52 <bourbaki> aha :)
18:21:10 <esap> hmm.. another problem :-) "OpenGL GLX extension not supported by display ':0.0'. Hmm... Maybe I need to enable that as well :-)
18:21:18 <stepcut> heh
18:21:32 <esap> I clearly haven't used OpenGL for anything :-)
18:21:46 <stepcut> my opengl acceleration is completely hosed right now -- glxgears runs at 9 frames per second :(
18:21:55 <Lemmih> whoa
18:22:02 <stepcut> :p
18:22:29 <stepcut> something to do with the fact that I just switch from xfree86 to x.org server I am sure...
18:22:31 <Lemmih> I thought my 4k was slow...
18:22:37 <bourbaki> you have to add glx to the loaded modules in the XFConfig file
18:24:37 * esap is doing dpkg-reconfigure xserver-xfree86
18:25:44 * esap wonders if I need GLcore as well? :-)
18:33:39 <esap> whoa, got it working.
18:33:46 <bourbaki> :)
18:34:17 <esap> nice transformation
18:34:35 <bourbaki> ywp its a homotopy
18:34:46 <bourbaki> you can also morph between strings
18:34:57 <bourbaki> anything is a spline a topology that is
18:35:12 <bourbaki> you can add splines letters to a spline word
18:35:31 <bourbaki> and then you morph over the words or a text if you want
18:35:33 <esap> I've once made a bit similar demo effect, but it wasn't at all based on homotopies :-) so much more boring.
18:36:08 <bourbaki> :) i would like to apply more topology thing
18:36:37 <bourbaki> one demo effect i am thinking about is an abritrary body with a texture running over it
18:37:01 <bourbaki> a sphere topology that is
18:38:02 <bourbaki> thats how i got interested in topology :)
18:39:34 <bourbaki> i also have code that morphs spheres somewhere on my hard disk
18:39:40 <bourbaki> though you cant see it yet
18:39:51 <bourbaki> rendered that it
18:39:54 <bourbaki> is
18:41:52 <bourbaki> so anything you have to do is map the vertices of your sphere to the mesh you want to morph and then you are done
18:46:00 <esap> hmm.. have you seen this: http://www.kotiposti.net/epulkkin/obfuscated.hs
18:46:34 <Heffalump> that's not very obfuscated
18:46:50 <Heffalump> any fule can see it's computing the Mandelbrot set :-)
18:47:09 <esap> heh :-)
18:47:26 <esap> but it's doing more than that.
18:47:30 <bourbaki> i get an error when i try to compile it
18:47:55 <Heffalump> apart from just displaying it?
18:48:06 <bourbaki> aha
18:48:58 <bourbaki> what do i have to call to start it? or doesnt it render anything?
18:49:17 <Heffalump> compile it with ghc and run the binary
18:50:38 <bourbaki> hm i need to set some env variables in win for that
18:50:50 <esap> env variables?
18:51:11 <bourbaki> that i can call ghc every where in cygwin
18:51:17 <esap> ah
18:51:19 <bourbaki> or the windoze shell
18:52:57 * esap hasn't tried this in windows, so I have no idea how fast it's there [it's somewhat too fast for most people even in X :-)]
18:53:57 <bourbaki> i dont care about speed :) i am not writeing to be something performant i enjoy just the structure of the programs rather :)
18:54:15 <bourbaki> if its a bit slower but it looks cooler in the program i am happy :)
18:55:47 <stepcut> bourbaki: that is a cool bit of code 
18:56:00 <bourbaki> thanks
18:56:14 <bourbaki> im very proud to hear that
18:56:43 <bourbaki> as i said its my first haskell program i copy pasted the glut stuff though and modified it to my needs
18:56:48 <stepcut> hehe
18:57:05 <bourbaki> maybe i will work on that shere thing then :)
18:57:25 <bourbaki> and make a new section on my site with a little paper about that mapping stuff
19:08:52 <bourbaki> ok i think i map myself to bed now ;)
19:09:16 * esap is already asleep [5am]
19:09:28 <bourbaki> heh 4 here
19:09:34 <bourbaki> ok see you all later :)
19:09:45 <esap> ok, see you.
22:53:55 <SamB> huh. water is very strange.
22:55:00 <Cale> the long line http://en.wikipedia.org/wiki/Long_line_%28topology%29 is more strange :)
22:55:26 <SamB> could someone tell water in #slate that I think banning my entire netmask from #slate for months is, shall I say, a bit excessive?
22:56:01 <Riastradh> I'm sure he cares a lot, SamB.
22:56:11 <Cale> why did you get banned?
22:56:25 <Riastradh> It's not hard with water.
22:56:27 <SamB> I forget exactly.
22:56:44 <SamB> something to do with talking.
22:57:17 * SamB joins #squeak to see if there is still a bot in there that is allergic to IPv6
22:57:33 * Riastradh sneezes.
22:58:48 <SamB> hmm. I don't see anything resembling a crashing bot. maybe it just hangs?
22:59:30 <Cale> SamB: change your ident
22:59:38 <SamB> I wonder how he failed to notice my presence until I pointed it out to him
22:59:50 <SamB> Cale: a lot of good that will do me before college!
23:00:21 <Cale> The ban is for *!~naesten@...
23:00:28 <SamB> Cale: oh?
23:00:54 <SamB> Cale: isn't there one that covers my IPv6 address too?
23:01:01 <Riastradh> Nope.
23:01:05 <Riastradh> /mode #slate b
23:01:08 <SamB> how odd!
23:01:26 <Cale> the ... includes a part of your ip
23:02:01 <SamB> that *!*@*.concentric.net is because I did just that on IPv4
23:02:40 <Cale> heh, choose a different nick while you're at it, and hopefully they won't notice :)
23:03:02 <SamB> I had actually managed to talk a bit on IPv6 without water noticing, but just now when I mentioned I was still banned on v4, he banned me on v6 too!
23:08:41 <Cale> "<water> i may be the founder in #squeak, but i don't ban people without a really good reason for it"
23:10:24 <SamB> I think he would be considerably better off if he (a) forgot more and (b) didn't keep people banned when he had forgotten why
23:11:24 <Cale> when was it you got banned?
23:12:27 <SamB> I don't feel like digging through logs for it...
23:12:35 <SamB> mostly, getting confused, I think...
23:13:07 <SamB> I see he didn't say what that reason was
23:13:17 <desrt> turing completeness implies the posibility of non-termination, right?
23:14:04 <SamB> desrt: well, I hardly see how you can have a turing complete thing without the halting problem...
23:14:45 <desrt> now... how is haskell turing complete?
23:14:49 <Riastradh> By solving the halting problem, of course!
23:14:55 <desrt> eventually, all calculations will terminate in haskell
23:15:08 <SamB> desrt: not necessarily.
23:15:09 <Riastradh> Technically, no physical machines are Turing-complete.
23:15:46 <desrt> samb; in order to infinite loop you need to be able to repeat a machine state
23:15:54 <desrt> it seems like haskell is incapable of doing this
23:16:28 <SamB> what about main = loop f where loop f = f >> loop f ?
23:16:45 <Riastradh> last [0..]
23:16:58 <SamB> wouldn't it repeat at some point?
23:17:06 <desrt> both of those programs will eventually exaust memory
23:17:15 <Riastradh> Not at all, desrt.
23:17:29 <desrt> Riastradh; yours definitely will
23:17:40 <Riastradh> How?
23:17:52 <desrt> when the number gets so large that it won't fit in ram
23:17:53 <SamB> I'm positive that, even if these particular programs were to leak memory, it would be possible to slightly refactor them in order to not leak memory.
23:17:57 <Riastradh> OK, fine.
23:18:08 <Riastradh> last x where x = 0 : x
23:18:10 <SamB> desrt: that never happens at Int!
23:18:30 <Riastradh> x will turn to garbage as it's processed, and last is tail-recursive, so the stack is bounded.
23:18:32 <desrt> Riastradh; you'll overflow the stack as x keeps recursively calling itself
23:18:45 <SamB> desrt: what calling?
23:19:40 <Riastradh> No, because the previous cells in the list become unnecessary for the remainder of the program as soon as they're processed, and therefore become garbage.
23:19:49 <desrt> hm.
23:19:52 <SamB> how long does a stack usually take to overflow?
23:20:09 <desrt> Riastradh; you appear to be right
23:20:28 <desrt> ok.  you win :)
23:20:44 <Riastradh> SamB, it won't.  My program uses bounded stack space.
23:21:02 <Riastradh> ...unless the stack in question has a _REALLY_ low limit, like 1 element.
23:22:56 <SamB> well, with a program that simple, it better, or I want my money back. any system which took longer than this to overflow the stack on such a simple program must be really slow ;-)
23:23:03 <Riastradh> Do note, however, my statement that, technically, no physical machine is Turing-complete, because any such machine would contribute to the amount of entropy, so at infinity, there would be an infinite amount of entropy and no tangible machine.
23:24:20 <stepcut> Riastradh: unless you could outrun the entropy!
23:24:28 <Riastradh> You'd create entropy in running after it.
23:24:40 <Riastradh> You can't outrun it.
23:24:43 <stepcut> yeah, but its all behind you, like car exhaust :)
23:24:50 <Riastradh> But if you run your programs _backwards_, you can remove it!
23:24:54 <stepcut> hehe
23:25:17 <stepcut> well, entropy aside, I don't think I can write the program I am trying to write 
23:25:18 <Riastradh> So only a language that allows computations to be fully reversible are Turing-complete.
23:25:21 <Riastradh> But that would require infinite memory!
23:25:38 <Riastradh> Unless the language is clever.
23:25:44 <Riastradh> Which Haskell is not, in this regard, anyhow.
23:26:13 <stepcut> well, if you could solve infinate calculations in finite time, that would help
23:26:20 <Riastradh> Actually, it would require a very clever language _and_ a very clever physical machine.
23:26:27 <Riastradh> None of the store could be reused.
23:26:31 <monotonom> Two jars A and B are connected with a door. Write a Haskell program to control the door so that it is open iff a gas particle in A is trying to go to B and no gas particle in B is trying to go to A.
23:26:34 <Riastradh> Assignment would be impossible!
23:26:50 <monotonom> (You may use unsafePerformIO.)
23:27:03 <Riastradh> Define 'trying to go to X.'
23:28:12 <monotonom> Haskell's Daemon!
23:29:44 <Riastradh> !nomeaD s'lleksaH     -- Get rid of some of that entropy...
23:29:48 <Riastradh> Oops.
23:30:00 <monotonom> heee
23:34:50 <stepcut> I want to write a function that will deserialize a value stored in a file. But I don't know what the type of the value is in advanced. All I know is that it is an instance of a class I have defined for saving/restoring values. I am willing to have the restriction that when I 'load' the value, I can only use that value as an argument to a few other functions defined in the same class
23:37:29 <stepcut> so my class might have three member functions(?) save :: a -> FilePath -> IO (), load :: FilePath -> IO a, and dispatch :: a -> IO ()
23:37:58 <stepcut> then I could do something like: do { v <- load "file.save" ; dispatch v }
23:38:16 <Riastradh> You'll have to use Dynamic & Typeable junk.
23:39:08 <stepcut> because, even though at *compile time*, it is not possible to tell which dispatch function to call, you will know that if load returns successfully, then there is a corresponding dispatch for that type
23:39:57 <stepcut> Riastradh: I tried, but I ultimated end with with 'Ambigious type variable a'
23:40:55 <stepcut> when you do fromDynamic, it still needs to know what type you are *expecting*. If the dynamic value has a different type inside, then it will return Nothing, otherwise it will return 'Just <the value>'
23:42:47 <stepcut> damn you hindley-milner !
23:45:57 <stepcut> i could do it if I could get the compiler to tell me all the instances of a class currently in scope ...
23:46:15 <stepcut> I know it knows! but it's holding out on me!
23:47:05 * SamB wonders if Slate is just too complicated for him to understand
