01:07:05 <vincent> is the hugs in Debian somewhat recent ?
01:07:17 <vincent> or should I look at ghc for recent features
01:12:31 <Lemmih_> hi
01:23:21 <vincent> hi
01:24:23 <vincent> does anyone know what the best place for ready to use extensions is ?
01:24:39 <vincent> is there a CHAN like CPAN ?
01:24:42 <vincent> :)
01:37:03 <ozone> vincent: there's a work-in-progress named Cabal which is exactly what you're looking for
01:37:30 <ozone> i don't know what its current state is though.  syntaxpolice is the one to talk to about it, but he's not here now ...
01:42:11 <vincent> nice :), thanks for the info
01:57:15 <Lemmih_> Isn't CPAN a collection of Perl libraries?
01:57:57 <vincent> yep
01:59:57 <Lemmih_> Then how can it be compared with Cabal?
02:05:23 <boubaki> hi
02:06:29 <Lemmih_> Hey boubaki
02:08:03 <bourbaki> is there any link from coalgebras to anamorphisms?
02:09:50 <bourbaki> s/from/between
02:09:51 <vincent> Lemmih_ cause they serve a similar Funktion ? :)
02:11:10 <vincent> Lemmih_ CHAN would mean comprehensive Haskell Archive Network
02:13:15 <Lemmih_> vincent, But they dont... Cabal is just a "Common Architecture for Building Applications and Libraries". It has nothing to do with storing collections of libraries (or links to them).
02:14:24 <Lemmih_> Maybe I've misunderstood the concept of CPAN...
02:18:20 <karingo> :( cpan is two things and archive of libraries and a program for downloading libraries from the archive and installing them and all of their dependencies
02:21:40 <vincent> Lemmih_ ah, no. I don't know what cabal is,  thats all :)
02:22:18 <vincent> karingo that's an interesting tool/archive for any language
02:22:38 <vincent> I mean the concept is more widely applicable
02:30:09 <dons> vincent: do you just want www.haskell.org/libraries ?
02:35:50 <vincent> dons: thanks :)
02:37:32 <dv> can someone help me out a bit, i'm trying to learn haskell (and functional programming), but i'm having trouble implementing the lucky numbers algorithm (http://en.wikipedia.org/wiki/Lucky_number).. what i have so far: http://transfixion.org/files/test.txt (probably totally wrong)
02:46:03 <earthy> what is ln supposed to do?
02:46:47 <earthy> but, it seems your problem is in determining which numbers to cross out, right?
02:46:54 <dv> yes
02:47:11 <earthy> well, try working with a list of pairs of numbers
02:47:27 <earthy> with one element of the pair the current position of the number in the list
02:47:35 <earthy> and the other element the number itself
02:47:49 <earthy> then, when crossing out, you can adjust the number in the list
02:48:00 <earthy> and just walk the list
02:48:10 <dv> that could work.. thanks
02:48:11 <earthy> and finally pick the numbers left
02:58:25 <bourbaki> hi dv
03:16:04 <dv> hi bourbaki 
04:01:01 <Igloo> marvin--?
04:03:08 <Marvin--> yes?
04:04:41 <Igloo> As well as libcp-ghc6 we may also want libcp-cv-ghc6 sometimes (cp = cabal package, cv = cabal version). I'm not sure if that means we shouldn't use cp_cv for cabal or not
04:05:22 <Igloo> On balance I think cp_cv is fine, but just thought I'd mention it
04:05:45 <Marvin--> hmm, good point
04:06:13 <Igloo> An alternative would be c-p-cv_t1-t2
04:06:51 <Marvin--> but that would be *really* confusing if you're familiar with Debian's versioning style
04:07:03 <Igloo> Hmm, true
04:07:27 <Igloo> c-p-cv+t1+t2?
04:07:39 <Marvin--> I think we basically have two options: 1) use another character for separating tags, or 2) disallow dashes in cabal package names and use BiCapitalization instead
04:08:09 <Igloo> Given the two, I'd vote for 1  :-)
04:08:13 <Marvin--> a BiCapitalized name maps naturally to a dash-separated debian package name, so that's not an issue
04:09:10 <Igloo> Yeah, but every time you give something a BiCapitalized name a fairy dies
04:09:22 <Marvin--> hah
04:09:56 <Marvin--> BiCapitalized names are already common in Haskell
04:09:59 <Igloo> I vote for 1 and +, anyway, but I'll leave it up to you guys to decide
04:10:14 <Marvin--> I mean, look at module names, type names, constructors
04:10:37 <Igloo> Oh, BiCaps will be nasty on a truly case insensitive filesystem, but I'm not sure if there are any that aren't case preserving
04:10:43 <Marvin--> and even some packages today (QuickCheck)
04:11:29 <Marvin--> well, I'm not saying that the capitalization should be *significant*
04:11:55 <Igloo> I mean nasty from a readability point of view
04:11:59 <Marvin--> but both haskell-src and HaskellSrc are more readable than haskellsrc, and if we can't use dashes, then I'd rather use BiCaps than nothing
04:12:32 <Igloo> Oh, definitely. I'm just making the case for -s  :-)
04:13:23 <Marvin--> I think there are Issues<tm> with copying all-caps filenames from linux onto vfat and vice versa, but I haven't ever seen any problems with BiCaps
04:13:34 <Marvin--> oh yes, I would much prefer dashes too
04:13:45 <Marvin--> but I can't think of a tag separator character that doesn't suck
04:14:22 <Igloo> Ah. Why don't you like + OOI?
04:14:34 <Igloo> It has URL issues admittedly
04:16:59 <Marvin--> well, for one thing, '-' > '+', so 0.3-1 > 0.3+foo-2, I'm not sure if that's an issue though
04:17:52 <Marvin--> using colon might look nice, but sucks from the perspective of unix environment variables (and debian epochs...)
04:18:09 <Igloo> Oh crikey, I hadn't thought about the possibility of Debian caring about tags
04:18:33 <Igloo> Oh, but it's in the package name so it's not an issue I think
04:18:46 <Marvin--> is + even *allowed* in the package name?
04:18:53 <Igloo> Yes
04:19:19 <Marvin--> so you're saying that the tags shouldn't be part of the version of the debian package?
04:19:25 <Igloo> Incidentally, do you know when/why/how /usr/lib/locale/locale-archive gets created?
04:19:59 <Igloo> If they are I think they would always be part of that package's version
04:20:22 <Igloo> As I understand their purpose, anyway
04:20:29 <Marvin--> right
04:21:00 <Marvin--> well, I'm not quite sure how to interpret them
04:21:19 <Marvin--> how does 0.3-cvs20041011 compare to 0.3?
04:21:26 <Marvin--> how does 0.3-pre1 compare to 0.3?
04:21:44 <Igloo> The way I'm thinking of tags given what Jaffa said is that they are essentially branches
04:22:16 <Marvin--> I'll be damned, we can have periods in package names, I never knew
04:22:22 <Marvin--> can't say I've ever seen that, though :)
04:22:36 <Igloo> Soo you would have  libfoo-0.3-ghc6_0.3-1  and  libfoo-0.3+mytag-ghc6_0.3+mytag-1
04:22:55 <Igloo> You haven't seen gstreamer0.8* packages, for example, then?  :-)
04:23:07 <Marvin--> oh, good point
04:23:08 <Igloo> libc6.1 I think too, for that matter
04:23:21 <Marvin--> I never think of the abi crud as part of the package name, but you're right of course
04:23:50 <Igloo> We may also have libfoo-ghc6_0.3-1, of course. I guess new tags could be introduced to the main package which could be bad
04:24:33 <Marvin--> libfoo-0.3+mytag-ghc6 is a seriously horrid package name
04:25:07 <Marvin--> liblong-package-name-0.1.2+cvs20041011-ghc6
04:25:14 <Marvin--> oh my god
04:25:36 <Igloo> Oh, but 0.3+foo-1 > 0.3-2 so that will work. There are cases where it'll break if tag order matters, but we can't do anything about that
04:25:55 <Igloo> Yes, but I doubt we'll have many version numbers, let alone tags, in package names
04:26:43 <Igloo> WASH packages, for example, would just have the latest wash in libwash-utils-ghc6_1.2 etc
04:26:54 <Igloo> Err, 1.2-1
04:27:08 <Marvin--> any time they change interface in a non-compatible way
04:27:35 <Marvin--> or, hm
04:27:36 <Igloo> But we obviously do need some sort of plan for the cases where it is necessary
04:29:23 <Marvin--> I mean, c libs change the major when the abi changes in a non-compatible way, right?
04:30:03 <Marvin--> oh wait, that doesn't apply to us since we link statically
04:30:05 <Marvin--> hooray
04:30:25 <Igloo> Yes. Maybe cabal's foo-1.3.4 should be libfoo1-ghc6 / libfoo1-1.3.4-ghc6 / libfoo1-1.3.4+foo+bar-ghc6
04:30:35 <Igloo> Err, the libraries don't
04:30:44 <Marvin--> oh damn, you're right
04:31:00 <Marvin--> package foo depends on package bar, but the static linking is only in the final executable program
04:31:07 <Igloo> The real question is what to do with libraries that claim to have unstable interfaces
04:31:25 <Marvin--> so *programs* won't have any dependency issues
04:31:41 <Igloo> We can either have really nasty dependencies, ignore the problem and make the latest packages work together or just not put such libraries into Debian proper
04:31:45 <Marvin--> IMX any non-standardized library has an unstable interface :-P
04:32:12 <Igloo> Well there is a haddock header for stability of interface, right?
04:32:21 <Igloo> So we (Debian) should believe that
04:32:57 <Marvin--> isn't a larger problem that the *abi* of haskell modules change all the freakin' time?
04:33:06 <Igloo> And we (Haskell) should bump the first digit when a stable library's interface changes (just non-backwards compatibly or at all?)
04:33:34 <Igloo> They'll all depend on ghc6 (>= 6.2.1), ghc6 (< 6.2.2) yes
04:33:57 <Igloo> And when we have a number I'll probably make an autoupdating whatsit
04:37:04 <Marvin--> I really think haskell libs should use a MAJOR thingy just like c libs, it's much more comforting than relying on version numbers
04:37:53 <Igloo> major thingy for API or ABI?
04:38:11 <Marvin--> both? :-/
04:38:12 <Igloo> API I agreed and described above, no?
04:38:40 <Marvin--> well, library version != package version
04:38:40 <Igloo> ABI we really don't want 100 packages sitting in NEW every time a new GHC point release comes out
04:39:46 <Marvin--> true, but those things are taken care of by strict dependencies on ghc
04:40:07 <Marvin--> there are other abi issues, like internal data types that change from version 0.3 to 0.4
04:40:35 <Igloo> I don't understand "library version != package version"
04:41:30 <Marvin--> what I mean is that the soname of a shared library is totally unrelated to the version of the package
04:41:32 <Igloo> Oh balls. I was about to say that doesn't matter, but with cross-module optimisation it probably does. I wonder just how strong our deps really need to be to cover the worst case
04:41:46 <Igloo> (that = internal data types changing)
04:42:03 <Igloo> In C or in Haskell?
04:42:30 <Marvin--> er, language shouldn't matter, should it? same problem, only in haskell it's even more complex
04:42:58 <Marvin--> I mean, look at libc6, version 2.3.2
04:43:04 <Igloo> Hmm, true
04:43:17 <Marvin--> you should be able to fix a bug that changes the soname in a point release
04:43:53 <Igloo> But that means dependencies would really be on sonames, not versions
04:43:57 <Marvin--> (though I can't say I *encourage* things like libgal23 :-P)
04:44:04 <Igloo> And versions exist, in part, to be the things that are depended on
04:44:07 <Marvin--> on both, actually
04:44:45 <Marvin--> the simplest form of dependency would be on the soname, but you may need a *backwards-compatible* change from a later version, so you might need to depend on libfoo3 >= 0.3.4
04:45:00 <Igloo> I think if libc6 was in our scheme it should be libc-6.2.3.2
04:45:13 <Marvin--> and I think that's a bad idea
04:45:33 <Igloo> But it's isomorphic and simpler
04:45:36 <Marvin--> that 1.0 version is holy
04:45:57 <Igloo> 1.0 is what you get when you declare the interface stable
04:46:19 <Marvin--> us hackers interpret libfoo-1.0.1 in a completely different way than libfoo1-0.3.4
04:46:29 <Igloo> Which I think corresponds well to what people use it for
04:47:08 <Marvin--> but there are different issues here, even if the *api* is stable, the *abi* might not be, and indeed in haskell probably won't
04:47:41 <Marvin--> but I don't know enough about the internals of ghc to argue in an informed way about this
04:47:55 <Igloo> I think we need to depend on precise versions in Debian
04:49:18 <Igloo> I think small changes could change function strictness and that could escape with cross-module inlining, for example, and we can't rely on programmers to spot that
04:51:15 <Marvin--> so if the foo package needs the bar package, it should depend on libbar-ghc6 (=0.1.2-3)?
04:51:38 <Marvin--> what was the decision on installability of multiple versions of the same package?
04:51:41 <Marvin--> (cabal packages)
04:52:16 <Igloo> libbar0-ghc6 (= 0.1.2-3)  (not sure if libbar0-ghc6 would be in Debian though as 0 < 1)
04:52:40 <Igloo> If we want to do that we have the libbar0-0.1.2-ghc6 scheme for all, or all but 1, of the packages
04:53:00 <Marvin--> we have an insane number of packages with versions <1.0 in debian, hackers are often loathe to go to version 1.0 :)
04:53:03 <Igloo> But in practice the major version ought to cover it
04:53:42 <Marvin--> well, if cabal can't handle multiple installed versions, then it doesn't make sense to have both libbar0 and libbar1 anyway
04:53:54 <Igloo> Well if the interface is declared stable the libbar0-ghc6 could definitely go into Debian
04:54:10 <Igloo> cabal can according to the spec
04:55:04 <Marvin--> I wonder how that works
04:55:05 * Igloo is now wondering if libbar1-ghc6 is better than libbar-ghc6 given we could just depend on (>= 1)
04:58:07 <Igloo> Anyway, I think I will write SM a mail later about ABIs. I'll hold off on writing a Debian Haskell policy until this is all worked out
04:59:11 * Igloo heads into town
04:59:37 <Marvin--> hmm, hidden vs exposed packages
04:59:58 <Marvin--> the spec says nothing about which versions can coexist
05:41:31 <Igloo> Given it can happen at all I don't see what you gain by restricting it
05:51:31 <Marvin--> Igloo: what I mean is that if there's no restrictions, we probably need to put the entire darn version numer in the debian package name
05:51:56 <Igloo> Only if we want multiple versions in Debian
05:52:33 <SyntaxNinja> hm. are we still talking about this? ;)
05:52:44 <Igloo> Oh, you're here
05:52:49 <Igloo> Hi  :-)
05:52:50 <Marvin--> won't we be seriously hampered if we don't?
05:52:53 <Marvin--> hey syntax
05:53:11 <Igloo> You might want to read http://tunes.org/~nef/logs/haskell/04.07.20
05:53:52 <Igloo> Well the main reason for it (apart from API changing) is that you may have libraries linked against old libraries, but with Debian that will all upgrade at once so shouldn't be a problem
05:54:01 <Igloo> s/linked/compiled/
05:55:39 <Marvin--> right, but there's still the API issue
05:56:21 <Igloo> Yes, hence libfoo1-ghc6 or libfoo-ghc6 (>= 1) (if it's reasonable to just fix everything)
05:56:53 <SyntaxNinja> reading log...
05:57:56 <Marvin--> my objection is that the 1 in libfoo1-ghc6 seems very arbitrary
05:59:00 <Igloo> Do you mean the 1 shouldn't be part of the cabalversion, or that taking just a single digit is too arbitrary?
05:59:40 <SyntaxNinja> any take-away points from this log?
05:59:50 <Marvin--> I mean that there should be an API versioning that's orthogonal to the package version
06:00:01 <Marvin--> kinda like libtool suggests
06:00:14 <Igloo> SyntaxNinja: I suggested wash-utils-1.2+tag1+tag2 for cabal names
06:00:36 <Igloo> And we scratched our heads lots at what to do about API and ABI changes, and when ABI changes could occur (I'll mail SM to check)
06:01:18 <thebug> ugh ABI changes
06:01:24 <Igloo> I think that in a version 1.2.3, 1 should be the API version. Marvin thinks that the API version should be elsewhere, distinct from the package version
06:01:57 <SyntaxNinja> Igloo: feel free to CC me so I can file that away
06:02:13 <Igloo> Rightyho
06:02:26 <Marvin--> feel free to CC me too :)
06:02:40 <SyntaxNinja> don't CC Marvin--!
06:02:42 <Igloo> Ooo, maybe I could CC the shiny debian-haskell list  :-)
06:02:46 <SyntaxNinja> oh my
06:03:08 <Marvin--> yay, debian-haskell
06:03:10 * Igloo will probably actually send it a real mail (status report) when ghc6 6.2.1 hits testing
06:03:36 <Igloo> Which might be tonight, finger crossed!
06:06:54 * Marvin-- ponders if it's actually worth figuring out how to use lm-sensors properly
06:07:07 <Igloo> HDYM?
06:07:12 <Igloo> You just run sensors, no?
06:07:35 <thebug> Marvin--: if you use gkrellm, it's sorted for you
06:08:13 <Marvin--> well, reading the stats is all fine and dandy
06:08:22 <Marvin--> what I'm pondering is whether I should try to use fancontrol
06:08:35 <Igloo> Ah
06:18:33 <Marvin--> temp3:    +224.4°C
06:18:36 <Marvin--> somehow I doubt that
06:19:07 <Marvin--> I suppose it's slightly more realistic than what a friend had, though
06:19:16 <Marvin--> (-48°C)
06:22:05 <Igloo> It could be a sensor you don't have
06:22:10 <Marvin--> exactly
06:23:02 <Marvin--> gah, hardware sucks
07:19:05 * Marvin-- swears at mozilla
07:20:52 <Marvin--> where'd my plugins go
07:23:28 * SyntaxNinja is so confused
07:23:38 <Igloo> How so?
07:23:48 <SyntaxNinja> I built cabal on my work machine, and everything looks perfect; the package is in the right place, the library is there
07:23:55 <SyntaxNinja> but when I try to use it, I get a bunch of linking errors
07:24:23 <SyntaxNinja> and I'm not convinced that I've tried to use the package itself lately. i'll have to add a test suite item for that.
07:24:24 <Igloo> What errors? Have you tried ghc -v to make sure it's looking in the right place?
07:25:00 <SyntaxNinja> yeah, it seems to be finding the library just fine
07:25:06 <SyntaxNinja> Setup.o(.text+0x1b): In function `__stginit_Main_':
07:25:06 <SyntaxNinja> : undefined reference to `__stginit_DistributionziSimple_'
07:25:06 <SyntaxNinja> Setup.o(.text+0x3c): In function `Main_main_srt':
07:25:06 <SyntaxNinja> : undefined reference to `DistributionziSimple_defaultMain_closure'
07:25:06 <SyntaxNinja> Setup.o(.text+0x90): In function `Main_main_entry':
07:25:07 <SyntaxNinja> : undefined reference to `DistributionziSimple_defaultMain_closure'
07:25:09 <SyntaxNinja> and some more like that
07:26:11 <Igloo> The only thing that comes to mind is if it could be finding the .hi files but not trying to link with the actual library for some reason
07:26:22 <Igloo> Have you tried explicitly giving it -package cabal or whatever?
07:26:41 <SyntaxNinja> yeah. somehow I manage to get more errors that way
07:26:47 <Marvin--> heh
07:26:50 * Igloo has never made a package myself, though
07:26:57 <SyntaxNinja>  undefined reference to `__stginit_TextziParserCombinatorsziParsec_'
07:27:02 <SyntaxNinja> oops
07:27:05 <SyntaxNinja> those errors look more like this:
07:27:06 <Igloo> More errors probably mean your package is missing deps
07:27:11 <SyntaxNinja>  undefined reference to `__stginit_TextziParserCombinatorsziParsec_'
07:27:11 <SyntaxNinja>  /usr/local/lib/Cabal-0.1/libHSCabal-0.1.a(Package.o)(.text+0xa8): In function `rzbq_srt':
07:27:28 <Marvin--> meaning you need -package parsec too
07:27:31 <SyntaxNinja> hm. maybe I am missing a dependency
07:27:47 <Igloo> You probably want   package_deps = [parsec],   or somesuch
07:27:51 <Igloo> in package.conf
07:27:52 <SyntaxNinja> whoa, yeah. 
07:27:57 <SyntaxNinja> that's strange. 
07:28:03 <Igloo> Ah, package_deps = ["parsec"],
07:28:16 <SyntaxNinja> I don't know how I managed to not notice that all the errors were related to parsec
07:28:23 <Marvin--> no, you want build-depends: parsec in Setup.description :-)
07:28:25 * SyntaxNinja wonders why this used to work
07:28:26 <SyntaxNinja> yeah
07:28:33 <Igloo> Does your package have auto = True?
07:28:46 <SyntaxNinja> yay! you guys are so smart
07:28:46 <SyntaxNinja> yeah
07:29:16 <Igloo> Hmm, that's the only thing that jumps up and down at me saying "This is what you need to be able to leave off -package cabal"
07:31:06 <SyntaxNinja> why's that?
07:31:25 <Igloo> why's what?
07:31:48 <SyntaxNinja> are you saying that you need to be able turn off cabal's auto status?
07:32:15 * SyntaxNinja has clearly not had nearly enough coffee yet today
07:32:28 <Igloo> No, I thought you were still unable to leave off -package cabal when you thought you should be able to. Am I confused?
07:32:35 <SyntaxNinja> oh, but I'm getting an ipod. I'm psyched. has anyone here used one on linux?
07:33:03 <SyntaxNinja> oh, ummm. maybe. the problem was the parsec dependency
07:33:48 <SyntaxNinja> but I do need to put -package Cabal, though it is auto hm.
07:35:26 * Igloo hasn't looked into how that's meant to work, like I say
07:36:40 <SyntaxNinja> Marvin--: is there an example of your super-duper new main-modules syntax anywhere in the repo?
07:38:00 * SyntaxNinja goes to a meeting &
07:38:19 <Marvin--> hm, no
07:38:25 <SyntaxNinja> ooh, looks like I forgot to check in A/test/Setup.description...
07:38:48 <Marvin--> http://www.mdstud.chalmers.se/~md9ms/cabal/usecases/OnlyExecutables.txt
07:39:03 <Marvin--> planning on implementing the program building?
09:30:55 <PerlJam> Is there a way to get the equivalent of python dicts or perl hashes in haskell?
09:32:07 <Marvin--> there's Data.FiniteMap
09:32:26 <Marvin--> balanced binary trees
09:33:07 <SamB> its not quite equivalent, but hashtables don't work too well in a pure functional context ;-)
09:33:09 <Igloo> There's also hash tables somewhere
09:33:38 <Igloo> But Data.FiniteMap is more normally used as it's nicer
09:33:44 <PerlJam> so where do I get it?
09:33:50 <PerlJam> I'm ueber new to haskell.
09:34:08 <SamB> PerlJam: it should be there already.
09:34:39 <SamB> if using hugs, try the -98 (non-Haskell 98) flag
09:34:47 <PerlJam> ah, thanks.
09:35:22 <SamB> GHC seems to enable the heirarchical libs by default
09:35:52 <SamB> even though the syntax is a bit different from Haskell 98
09:37:52 <shapr> hiya PerlJam, ltns
09:38:05 <shapr> PerlJam: you're following me around or something? first Python, now Haskell?
09:38:23 * shapr grins
09:38:23 <PerlJam> hey shapr
09:38:51 <PerlJam> Well, I've admired haskell from afar and lately I've decided to gain carnal knowledge of it. :_
09:38:56 * shapr snickers
09:39:12 <shapr> yah, it's a great language.
09:39:13 <PerlJam> Also on my list of languages to learn is ML
09:39:25 <thebug> OCaml looks nifty too
09:39:44 <shapr> I'd suggest learning Haskell first, then ML will be easy.
09:39:58 <PerlJam> well, that's how it's happening :)
09:40:30 <shapr> Haskell has kept my interest for three years or so
09:40:42 <shapr> that's the longest yet.
09:41:31 <shapr> PerlJam: any questions so far?
09:41:56 <PerlJam> I'm just fumbling around in the dark right now.  Trying to get a handle on things.
09:42:04 <PerlJam> reading the stuff on haskell.org
09:42:08 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:42:24 <shapr> do you use emacs?
09:42:49 <PerlJam> nope
09:42:50 <shapr> I'd suggest starting with Hal Daume's Yet Another Haskell Tutorial
09:42:53 <shapr> ok
09:43:00 <PerlJam> vi and its clones 
09:43:02 <shapr> too bad, I have lots of Haskell + emacs advice :-)
09:43:18 <shapr> though I think there's an equal number of vi(m) users here.
09:43:57 <SamB> is emacs repugnant to you, or have you just happened to learn vi* first?
09:44:06 * shapr actually started with vim
09:44:26 <shapr> I learned emacs in order to repudiate all the emacs lovers...
09:44:30 <shapr> but was turned to the dark side instead.
09:44:34 <PerlJam> I learned vi first and found emacs repugnant when I later tried to use it. :)
09:44:51 * darth_shapr duals esap 
09:45:05 <darth_shapr> @yow
09:45:05 <lambdabot> WHO sees a BEACH BUNNY sobbing on a SHAG RUG?!
09:45:16 <SamB> I unfortunately do not know vi...
09:45:22 <darth_shapr> vim is nice
09:45:28 <darth_shapr> though I prefer emacs
09:45:29 <SamB> although at the moment I don't remember why that is unfortunate
09:45:48 <darth_shapr> it's worth knowing as many as you can, then you get to use whatever's best for the current task
09:46:38 <SamB> well, I seem to remember something about not having a (working?) emacs...
09:47:01 <darth_shapr> PerlJam: checked out that HaskellDemo?
09:47:08 <PerlJam> yep
09:47:12 <darth_shapr> I am available for interactive questions if you have any
09:47:46 * shapr is bored
09:47:50 <shapr> too much Python today.
09:47:50 <thebug> shapr, the haskell interpreter
09:48:05 <thebug> interactive, even
09:48:10 <PerlJam> I'm just trying to solve a problem right now.
09:48:15 <shapr> oh, what's the problem?
09:48:16 <thebug> shapr: (\x->x*x)5
09:48:28 <shapr> 24
09:48:35 <PerlJam> I saw a haskell assignment on the web last night to convert a number to a string representation, so I thought that'd be fun to start with.
09:48:36 <shapr> whoops, f00f bug
09:48:36 <monotonom> 25.000001
09:49:00 <Cale> PerlJam: hehe, "show" :)
09:49:09 <shapr> or do you mean a word representation?
09:49:12 <shapr> like one thousand
09:49:14 <shapr> ?
09:49:14 <PerlJam> shapr: yes.
09:49:20 <Cale> ah
09:49:21 <Cale> :)
09:49:29 <thebug> heh
09:49:29 <monotonom> Ingenious.
09:49:33 <PerlJam> Cale: yes, that's a wee bit different :)
09:49:46 <shapr> you want the solution? or hints?
09:49:56 <Cale> Yeah, that's a fun one to do then.
09:50:08 <SamB> hmm, I wonder if the Inform Grammar.h would be any help?
09:50:19 <PerlJam> shapr: hints are fine.  I'd like to figure out a solution on my own though.
09:50:23 <SamB> or maybe it is English.h...
09:51:04 <shapr> I'd suggest a recursive function that clips off a single 'word' and calls itself again with the leftover part of the number
09:51:08 <monotonom> It is going to be a lot of boring work.  The English number system is not exactly regular.
09:51:28 <monotonom> And it is going to be just as much work in any programming language.
09:51:28 <PerlJam> shapr: yeah, I got that much :)
09:51:48 <PerlJam> how do you modulo arithmetic?
09:51:58 <shapr> I think there's both % and mod
09:52:02 <monotonom> 5 `mod` 3
09:52:03 <shapr> though I forget the difference
09:52:12 <PerlJam> which is Int -> Int ?
09:52:16 <monotonom> % is for fractions
09:52:27 <Cale> there's mod and rem
09:52:29 <SamB> huh, what happened to inform-mode...
09:52:30 <monotonom> 5 `mod` 3, 5 `rem` 3
09:52:44 <PerlJam> ah, what's the ` do?
09:52:55 <shapr> make an op from a function
09:53:03 <Smerdyakov> Calls a human on the phone to interpret what it means.
09:53:03 <PerlJam> interesting
09:53:06 <shapr> if you have add x y = x + y
09:53:11 <shapr> you can do 1 `add` 2
09:53:31 <shapr> I think it may require a binary function though
09:54:26 <SamB> hmm. I guess the monomorphism restriction prevents you saying add = (+)...
09:54:29 <monotonom> Yes of course.
09:55:02 <SamB> I think % is the smart constructor for fractions...
09:55:09 <monotonom> Yes.
09:55:30 * shapr fights I18N support in Plone
09:55:31 <SamB> oh, you said that already ;-)
09:55:39 <PerlJam> how do I concatenate strings?
09:55:47 <PerlJam> Or should I be thinking in terms of lists?
09:55:49 <shapr> strings are lists
09:55:50 <SamB> ++
09:55:50 <shapr> yup
09:55:55 <PerlJam> gotcha
09:56:34 <SamB> it is horribly inefficient, but it would be worse in a strict language
09:56:47 <shapr> it sure does feel nice though
09:58:08 <Igloo> ++ is only O(m) given arguments of length m and n
09:59:56 <SamB> it might even be less than that sometimes, with fusion...
10:00:25 <SamB> (but not in hugs)
10:00:30 <shapr> greetings segv 
10:01:08 <Igloo> Hmm, ghc has spent 157mins trying to compile a test and counting
10:01:13 <shapr> yow
10:01:16 <shapr> is that m68k?
10:01:24 <Igloo> And a comment in the test script says it sometimes goes into an infinite loop on alpha-dec-osf3
10:01:27 <Igloo> No, IA64
10:01:47 <shapr> is this related to the 64bit stuff I've seen on cvs-all ?
10:02:02 <Igloo> No
10:02:11 <shapr> oh, ok
10:02:20 * shapr hOps randOmly
10:03:16 <Igloo> They were me fixing up other tests (mostly ones that print minBound :: Int and suchlike)
10:07:09 <shapr> so I've been thinking about the dual of dependent types...
10:07:28 * shapr wonders if that one's obvious
10:07:33 <segv> as a haskell newbie (zerobie would be more precise) is runnig hugs98 from cvs a good idea?
10:07:56 <shapr> codependent types :-D
10:07:59 <Cale> I recommend using ghci :)
10:08:00 * shapr laughs hysterically
10:08:20 <shapr> yah, I prefer GHCi 
10:08:22 <Cale> oh, perhaps I should have directed that specifically at segv
10:08:48 <shapr> segv: I'd suggest GHCi
10:08:52 <segv> will i notice the difference while learning?
10:09:04 <segv> (and does it compile on MacOS X?)
10:09:07 <Igloo> FWIW I prefer hugs
10:09:28 <monotonom> I prefer shapr, the interactive haskell interpreter.
10:09:38 * shapr snickers
10:09:57 <Cale> segv: there's a nice GHC package for OSX
10:10:02 <segv> is GHCi GHC?
10:10:24 <Cale> It's the interactive thing that comes with ghc
10:10:26 <Cale> :)
10:10:46 <segv> i had some problems with building GHC, is there a package for 10.2? (i saw the 10.3 package)
10:11:34 <monotonom> Advertisement: "shapr handles 1000000 haskell queries per hour over the www.  Guess what he uses behind the hood? GHCi.  GHCi: the pros use it."
10:11:47 * shapr laughs
10:12:03 <shapr> it's really lambdabot... he's the behind the scenes puppet master.
10:12:41 <Cale> segv: if you have darwinports, you can get it to build one for you
10:12:54 <Cale> however, it will take a while
10:13:21 <monotonom> such as 157 minutes
10:13:38 <Igloo> If you can get it to build one why can't you just install the one it uses to build it?
10:14:27 <Cale> I'm not quite sure how it works :)
10:15:07 <Cale> segv: does the panther package not work at all?
10:15:38 <segv> i didn't even try. other 10.3 packages i've tried to use have failed miserably.
10:16:11 <Cale> certainly the stuff that's in it isn't specific to panther
10:16:22 <Cale> I wonder if ghc is in fink
10:16:24 <segv> well, i've gotten pretty far this time, it (hugs98) now complains about _main missing in Hugs.Storable...
10:17:44 <segv> Cale: net in fink for 10.2
10:17:47 <segv> s/net/not/
10:17:54 <Cale> :/
10:18:41 <Cale> I'd compile it for you if I had a machine which ran 10.2
10:20:12 <PerlJam> so I've got a structure that looks like this:  foo x | x>=1000 = bar x `mod` 1000 | x>=100 = bar x `mod` 100 | ... and I realize that I'm going to add million, billion, etc. and the structure will be exactly the same only the numbers will change.  What's a way to parameterize this?
10:20:17 <PerlJam> Am I making sense?
10:21:00 <Cale> roughly :)
10:21:57 <Cale> you could have a list with the appropriate pairs in it
10:23:08 <PerlJam> I guess I want to use map here.
10:24:51 <SamB> maybe foldr would work better?
10:25:00 <PerlJam> What's foldr?
10:25:29 <Marvin--> Igloo: did you send that mail to SM?
10:25:42 <shapr> foldr is a map that eats the first two items to produce a new first item
10:25:51 <PerlJam> oh, like reduce
10:26:04 <Igloo> No, I'll probably write it this evening
10:26:13 <shapr> right, foldr1 is reduce
10:26:46 <shapr> there's also foldl and the 1 means "no initial item" and  a single tick on the end means "strict"
10:27:02 <Marvin--> Igloo: oh, okay
10:27:11 <shapr> so foldr (+) 0 [1,1] is the same as foldr1 (+) [1,1]
10:27:47 <Marvin--> I thought foldr1 (+) [1,1] was the same as foldr (+) 1 [1] :-)
10:27:58 <shapr> er, well... ok
10:29:12 <PerlJam> okay ... something is screwy.  I have say 40 = ["forty"] and say x | x >= 20 = say (x - x `mod` 10), but "say 43" just hangs.
10:30:28 <Igloo> I think foldl1 would be reduce if it existed, incidentally
10:30:28 <TheHunter> you probably mean x - (x `mod` 10)
10:30:58 <PerlJam> TheHunter: That would be some screwy precedence when I need to parenthesize modulus
10:31:06 <PerlJam> (over subtraction)
10:31:32 <Cale> you don't.
10:31:41 <Cale> Prelude> 43 - 43 `mod` 10
10:31:41 <Cale> 40
10:31:48 <PerlJam> well, I don't understand why it's hanging.
10:32:03 <Igloo> Because you're calling say recursively
10:32:51 <Cale> that code works for me, printing "forty"
10:33:04 <PerlJam> oh, d'oh!  The order of the definitions matters.
10:33:07 * PerlJam smacks forehead
10:33:36 <Cale> it tries to match them in order
10:33:54 <PerlJam> right, right, just like in prolog
10:36:51 <segv> is ghci cool because other haskells don't have interactive repls?
10:37:22 <vincent> hugs is interactive ?
10:37:30 <shapr> yup, and so is GHCi
10:37:42 <PerlJam> so ... how would I join a list of strings such that I get a single string with the items separated by a single space?
10:37:48 <Marvin--> ghci is cool because it can run both interpreted and compiled code
10:37:52 <PerlJam> I think I've been thinking in perl too long
10:37:55 <shapr> Hugs is a Haskell interpreter written in C, GHC is a compiler written in Haskell.
10:38:39 <shapr> PerlJam: map (++ " ") could put space on the end of each string in the list
10:38:52 <Cale> foldr1 (\x y -> x ++ " " ++ y) ["List", "of", "strings"]
10:38:54 <shapr> but foldr / reduce might be better if you're going to return the whole result.
10:39:20 <shapr> Hugs is the best choice when doing Haskell on Sharp Zaurus.
10:39:29 <shapr> GHC can be a memory hog.
10:40:36 <Igloo> Alternatively, concat . intersperse " "
10:41:47 <Marvin--> intersperse is your friend
10:42:25 <segv> hm. are the building hugs from cvs docs?
10:43:26 <PerlJam> wee! I've now got a routine that can turn any number into a string representation of that number.
10:43:35 <shapr> yay!
10:43:37 <SamB> hmm, thousands seem to mess up the foldr approach... or am I wrong?
10:44:05 <PerlJam> pronounce 2345
10:44:09 <PerlJam> "two thousand three hundred forty five"
10:44:25 <shapr> PerlJam: now to hook that into eflite...
10:44:33 <vincent> :)
10:44:45 <PerlJam> eflite?
10:44:57 <shapr> eflite - Festival-Lite based emacspeak speech server
10:45:03 <Cale> now do one that goes the other way :)
10:45:09 <shapr> ohh, good idea
10:45:24 <PerlJam> Cale: so your foldr1 would be the same as foldr (\x y -> x ++ " " ++ y) [] ["List
10:45:33 <PerlJam> Cale: so your foldr1 would be the same as foldr (\x y -> x ++ " " ++ y) [] ["List", "of", "strings"]
10:46:00 <Cale> roughly, though that will give an extra space at the end
10:46:30 <PerlJam> indeed
10:47:13 <shapr> greetz stepcut
10:47:23 <shapr> do you think GADTs will fix the CGIArrow prob?
10:47:39 * PerlJam looks for the forum where he found this problem to see how the others did it.
10:52:21 * stepcut pondes
10:52:28 <stepcut> ponders, ever
10:52:32 <stepcut> yikess
10:52:34 * stepcut gives up
10:52:35 * shapr lakes
10:53:52 <stepcut> shapr, the problem with CGIArrows, is that you need to be able to write an instance off 'arr' that works on all functions of type, f::a->b
10:54:40 <stepcut> but, in the case of CGIArrows, (and similar things), you need to convert a/b to/from Strings 
10:54:57 <stepcut> so, I don't see how GADTs would help that
10:55:00 <shapr> SyntaxNinja: you're back!
10:55:26 <SyntaxNinja> shapr: so I was wondering, "WHy doesn't my CD burner work"
10:55:34 <SyntaxNinja> and I was going to figure it out
10:55:42 <SyntaxNinja> and so I tried to put a CD in there, but the door wouldn't open
10:55:51 <shapr> !
10:55:57 <SyntaxNinja> (though it did the other day)
10:56:02 <SyntaxNinja> so I opened up the case, on a hunch
10:56:05 <shapr> and??
10:56:08 <SyntaxNinja> and for some reason, the data cable wasn't connected :)
10:56:10 <stepcut> shapr: to fix CGIArrows, I think you need a haskell partial evalutor
10:56:11 <shapr> crazy
10:56:15 <shapr> hiya Si\ 
10:56:17 <SyntaxNinja> it wasn't me!
10:56:35 <shapr> reminds me of a coworker I had who somehow got multiple audio CDs in the same drive
10:57:00 <stepcut> SyntaxNinja: do you have a moment to answers some questions about cabal ?
10:57:25 <shapr> SyntaxNinja: your coworkers are teasing you?
11:00:56 <shapr> hiya gintas 
11:01:02 <gintas> hi
11:01:06 <shapr> what's up?
11:01:29 <gintas> well, RMS is coming over here tomorrow
11:01:34 <shapr> cool!
11:01:38 <gintas> yeah
11:01:40 <Lemmih> Hey SyntaxNinja.
11:02:02 <segv> where can i find distrib/hc-build ?
11:02:41 <Lemmih> SyntaxNinja: I have some questions about a parse in Cabal.
11:02:47 <Igloo> In the GHC tarball
11:04:03 <segv> don't mind me. i'm far more confused than i should be.
11:05:21 <segv> "This is GHC 6.2.1 for MacOS X 10.2. It REQUIRES Mac OS X 10.3 (Panther) and won't work on previous versions." Now that's some clear language :(
11:05:34 <Marvin--> haha
11:06:19 <kosmikus> hiho -- I am going to put the following acknowledgement notice in my thesis -- please correct the english, and complain if you feel you should be mentioned by nick but aren't:
11:06:23 <kosmikus> The people on the @#haskell@ channel, including, but not limited to
11:06:25 <kosmikus> earthy, Heffalump, Igloo, Marvin-{}-, ozone, shapr, and SyntaxNinja, 
11:06:28 <kosmikus> have provided a great deal of -- probably largely subconscious -- mental 
11:06:30 <kosmikus> support during the phase in which I had to write my thesis and 
11:06:33 <kosmikus> diversions were scarce.
11:08:17 <Igloo> I'd put a comma after "to", but my English isn't great
11:09:10 <Marvin--> and here I thought you were English
11:09:19 <Marvin--> could've fooled me
11:10:10 <Marvin--> kosmikus: so that's what we are, eh, a diversion? ;-)
11:11:13 * gintas gets out of his cave
11:11:26 <gintas> kosmikus: might I ask what your thesis is on and if it's available online
11:11:33 <shapr> kosmikus: yay!
11:11:54 <segv> last stupid question, is it morth this much effort to get ghc 6.2 or should i just settle for the 6.0.1 binaries i've found?
11:12:01 <segv> s/morth/worth/
11:12:09 <shapr> kosmikus: are you going to include your thesis quote from the QuotesPage?
11:12:20 <Marvin--> kosmikus: so you're done now, then? :)
11:12:20 <kosmikus> gintas: it is on Generic Haskell, and it is not yet officially online
11:12:29 <Cale> stick with 6.0.1 for now, upgrade later
11:12:39 <kosmikus> gintas: I'll put it online once I ship it to the printer, which is planned for tomorrow
11:12:51 <kosmikus> shapr: no, I won't include the quote ;)
11:12:53 <shapr> aww
11:13:03 <Marvin--> kosmikus: I suppose congratulations are in order then, yay! :)
11:13:04 <shapr> well, I'm looking forward to the pictures in your thesis
11:13:11 <shapr> congraduations kosmikus!
11:13:17 <Marvin--> kosmikus: aww, chicken
11:14:08 <Marvin--> I remember a report we wrote for a big project in a course on object orientation and systems development, where we put a quote after every chapter heading
11:14:29 <kosmikus> shapr: one of the reading committee members has specifically complained about the pictures, so there will be some last minute discussion tomorrow if they can stay in
11:14:40 <Marvin--> I think the quote from the chapter on the design was me saying "Singleton is just a prettier name for global variable"
11:15:02 <shapr> whattt?!
11:15:07 <Marvin--> what pictures?
11:15:08 <shapr> no way! the pictures are awesome!
11:15:13 <Marvin--> what've I missed?
11:15:52 <segv> Cale: thanks.
11:16:25 <kosmikus> well, I have a picture at the beginning of each chapter, and mark some very difficult sections as well as future work sections with pictures in the margin
11:16:38 <kosmikus> there was discussion about whether that is "appropriate"
11:16:39 <shapr> I think it's great
11:16:48 <shapr> whyever would it *not* be appropriate?
11:17:11 <shapr> do they think that putting pictures in there will make it too similar to a "Learn Generic Haskell in 21 Days" book?
11:17:46 <Marvin--> they're objecting to the appropriateness of chapter pictures but not to irc nicknames? :)
11:17:49 <kosmikus> well, I have a hard time understanding it myself, but if I get it right, it does not show the appropriate respect for the formal status of a phd thesis
11:18:06 <shapr> oh I forget, education isn't about having fun.
11:18:18 <kosmikus> well, the irc nicknames are limited to one sentence in the acknowledgements
11:18:26 <kosmikus> the pictures taint the entire thesis :)
11:18:33 * shapr sighs
11:18:46 <Marvin--> well, true, there are certain forms to follow and stuff
11:18:48 <shapr> and these people probably wonder why they haven't made any impact in 'the real world'
11:19:14 <shapr> I actually prefer things that are fun to read.
11:19:59 <Marvin--> hehehe, no, the quote from the design chapter was from when we discovered a big D'OH design mistake in the second iteration, close to the deadline
11:20:26 <kosmikus> well, I'll just discuss it with my supervisor tomorrow and we'll decide what to do
11:21:08 <Marvin--> the quote from the conclusions and reflections chapter showed an undecipherable error message from cvs :-P
11:21:12 * flaw doesn't feel like he's learning anything if he's not board (;
11:21:20 <shapr> boy that fires up every anti-ivory-tower reflex I have...
11:21:39 <shapr> kosmikus: well, if you decide to not put the pix in, can we still see them? :-)
11:21:57 <shapr> flaw: I don't learn something unless I'm enjoying learning that thing.
11:22:40 <kosmikus> shapr: yes, the "real" version will definitely be online
11:22:45 <shapr> Did you know that people consider *me* an ivory tower academic because I talk about type inferencing to Java programmers?
11:22:59 <kosmikus> hehe
11:23:23 <shapr> I'm glad to hear the 'real' version will be accessible.
11:23:23 <PerlJam> shapr: but you *are* an ivory tower academic ;)
11:23:24 <Marvin--> you shouldn't scare the poor java programmers
11:23:28 <shapr> PerlJam: :-P
11:23:59 * shapr smacks PerlJam with the Lambda of Doom
11:24:00 <flaw> I agree with marvin on that; you are in #haskell.. ;)
11:24:02 <edwinb> Nothing wrong with being an ivory tower academic ;)
11:24:11 <Lemmih> Hey nainef
11:24:14 <nainef> hey
11:24:23 * flaw wants an ivory cabin
11:24:51 <edwinb> they view wouldn't be as good
11:25:05 <shapr> I don't want to learn stuff I can't use in my everyday job.
11:25:32 <edwinb> Maybe that's the difference. I've never cared about that sort of thing. That's why I haven't got a job...
11:25:35 <flaw> I could build it on a mountain, or a hill; but you are still right..
11:25:48 <edwinb> (Don't suppose anyone has any need of an unemployed type theorist do they? ;)
11:25:52 * shapr grins
11:25:58 <shapr> edwinb: are you already done with your thesis?
11:26:00 <PerlJam> "type theorist"?
11:26:08 <PerlJam> you theorize about typing?
11:26:12 <edwinb> Not yet, but I still need a job...
11:26:13 <nainef> oh no
11:26:23 <PerlJam> you theorize about the types of things that might be?
11:26:24 <shapr> oh, did you see the discussion about Epigram on lambda the ultimate?
11:26:29 <edwinb> PerlJam: We play with type systems.
11:26:37 <edwinb> shapr: Oh, I missed that...
11:26:40 * edwinb has a look
11:26:50 <PerlJam> edwinb: Unless you're writing a programming language/compiler, I don't see much use in that :)
11:27:03 <shapr> Frank Atanassow had some interesting things to say about depedent types and lack of modularity.
11:27:15 <edwinb> PerlJam: Guess what we do...
11:27:20 * shapr laughs
11:27:42 * segv is now running ghc 6.0.1. now i can actually start working :(
11:27:44 <shapr> I wish I could get to the AFP Epigram talk
11:27:51 <shapr> hiya xs 
11:28:01 <xs> hello
11:28:05 <shapr> looking for Haskell info?
11:28:06 <gintas> why does 'type theorist' sound so much like 'type terrorist'?
11:28:23 <PerlJam> gintas: because you've been brain washed!
11:28:25 <xs> no. i was looking for secret government plans.
11:28:41 <shapr> xs: we have some of those too, but you have to be inducted into the Cabal first.
11:29:06 <xs> shapr: as long as it is not any more painful than talking to a ruby afficionado, fine.
11:29:14 * PerlJam looks around to make sure he's not on #perl6
11:29:15 <kosmikus|away> without having looked at the discussion: the lack of modularity in a dependently typed language is exactly why you need generic programming ;)
11:29:39 <gintas> PerlJam: or because you guys scare poor Java coders?
11:29:42 <gintas> :)
11:30:08 <edwinb> I don't see why you have to lose modularity anyway. The point is to keep the low level details consistent, then abstract them away.
11:30:19 <PerlJam> So ... how difficult would it be to write a haskell compiler?
11:30:26 * edwinb isn't going to get into a discussion about generic programming vs dependent types ;)
11:30:27 <shapr> xs: well, I've only had a few knock-down drag-out fights with Ruby aficionados, so I guess it's not so bad here.
11:30:37 <xs> shapr: eexcellent :D
11:31:11 <shapr> actually, there really are some not so secret government plans accessible in the Haskell community.
11:31:40 <xs> well, given the power of haskell..
11:31:42 <shapr> yup
11:32:09 <shapr> I'm sure no one would tell me about secret plans of any sort, I talk too much.
11:32:13 <kosmikus|away> edwinb: it's not *versus*, they need each other, which is good
11:32:32 <edwinb> yeah, I'd agree with that.
11:32:40 <edwinb> That was no fun...
11:33:07 <shapr> I'm impressed with epigram, I want more...
11:33:19 <vincent> epigram ?
11:33:29 <edwinb> I'll prod Conor next time I see him...
11:33:30 <shapr> http://www.dur.ac.uk/CARG/epigram/
11:33:44 <edwinb> Although he's my office mate, he's never here...
11:33:50 <shapr> he said he's cleaning it up for AFP, right?
11:34:01 <edwinb> Yes
11:34:12 <edwinb> And so that the rest of us can start hacking on it.
11:34:20 <shapr> cool, I look forward to that.
11:34:48 <edwinb> I have stuff I want to bolt on but he says it'd be a waste of time until he's refactored it...
11:36:02 <shapr> AFP approaches, so that should be soon.
11:36:43 <vincent> where is afp ? :)
11:36:54 <shapr> estonia this time
11:36:55 * vincent a bit too lazy too google
11:36:58 <vincent> cool
11:37:05 <vincent> lazy == good ;)
11:37:11 <shapr> I'm sure gintas is going to AFP...
11:37:18 <shapr> he's much closer than I am...
11:37:30 * shapr looks at gintas suspiciously
11:37:39 <shapr> gintas: are you getting any taller?
11:38:18 <Cale> shapr: you should consider banning cache2-sot3 from the wiki
11:39:42 <shapr> ok
11:41:52 <Igloo> Is it a common spamming source or something?
11:42:09 <Cale> yeah
11:43:01 * Marvin-- likes shapr's comment on deleting the ParisHilton page
11:43:05 * shapr grins
11:44:47 <shapr> ok, banned.
11:44:52 <Igloo> What was it?
11:45:00 * Igloo assumes only banned from editting?
11:45:22 <shapr> "as if she's ever heard of Haskell"
11:45:59 <Igloo> :-)
11:46:08 * Marvin-- sighs at debian-vote
11:46:15 <Igloo> Did it just explode?
11:46:39 <Marvin--> I'm not subscribed, so I'm only reading the archives, but it's the sheer silliness of the whole thing
11:46:56 <Igloo> Hurrah, 4 process kills later and the IA64 build trundles on
11:47:03 <Igloo> Ah, yes
11:48:20 <Marvin--> forcing the release team to do something by vote, sheesh
11:48:51 <Cale> What is all this about AMD64 and sarge?
11:49:06 <Marvin--> stupidity, is what it is
11:49:13 <thebug> ^ seconded
11:49:19 <Cale> heh
11:49:27 <shapr> I like the pure 64-bit direction that Debian has taken.
11:49:38 <Igloo> Huh?
11:49:48 <Igloo> It's clearly worse than multiarch as it's a subset of the functionality
11:50:34 <shapr> I'd like to skip out of 32-bit myself.
11:50:42 <Marvin--> the project as such hasn't taken *any* direction yet
11:51:20 <vincent> shapr: me 2
11:51:40 <vincent> too bad OS X is not fullblown 64 bit
11:51:49 <shapr> yah, why not?
11:51:56 <vincent> but there is also an issue of feasibility I guess
11:52:00 <vincent> and legacy code ?
11:52:16 <thebug> why is it that people think they need 64-bit? unless you need >8GB of RAM, or do large integer calculations, you don't gain much
11:52:41 <vincent> thebug: well, I need userspace programs with more than a few gig process memory space :)
11:52:53 <vincent> so ...
11:52:56 <thebug> well then it's a valid reason
11:53:01 <vincent> ;)
11:53:08 <vincent> it can be a fallacy too
11:53:17 <vincent> and PAE is an ugly hack
11:53:18 <thebug> but aunt tillie certainly gains nothing from 64-bit while browsing the web, so why the hype about it?
11:53:25 <vincent> true
11:53:31 <vincent> hype kills
11:53:33 <thebug> anyone who needs 64-bit has already moved on to !x86 processors anyway
11:53:42 <Igloo> amd64 is fundamentally faster than IA32 due to more registers, of course
11:53:52 * vincent asks 1 sec of silence for alpha
11:53:59 <shapr> mregparm=16 ;-)
11:54:06 <shapr> yah,the alpha was great :-/
11:54:06 <thebug> look at all the processors that have been 64-bit for 5+ or 10+ years already
11:54:12 <vincent> yep
11:54:22 <vincent> don't tell Steve though ;)
11:55:01 <shapr> maybe the IBM/Sony Cell (now called "grid" I think) CPU will be nice.
11:55:16 <thebug> why does this make 64-bit x86 news? seems like a pointer to the failure of intel to make the smart move years ago when they had the chance to kill of 8088 compatibility ...
11:55:29 <vincent> yeah, they should have
11:55:31 <thebug> not like windows xfoo will run your CP/M executables anyway
11:55:38 <vincent> too much layers of cruft
11:56:00 * vincent likes the Transmeta approach :)
11:56:43 <vincent> btw, the best thing about amd64 is not 64 but hypertransport imho
11:57:39 <shapr> I'd rather have a PC made with a shape that tiles in 3D, for infinite expandability.
11:57:41 <Riastradh> 64 sounds bigger and therefore better than 32.  Technical merit doesn't matter one bit to marketers or marketees.
11:57:52 <thebug> so, something that SGI has had the idea for nailed for years
11:58:02 <vincent> Altix rocks
11:58:22 <vincent> who needs beowulf clusters
11:58:23 <vincent> heh
11:58:44 <shapr> I'd also like to have a Linux working with asymmetric multiprocessing so I can run it with an x86 cpu for games, and some other CPUs for actual usefulness.
11:59:02 <vincent> shapr dunno if its worth the pain
11:59:17 <Riastradh> Just having, um, two computers would work fine.
11:59:21 <vincent> :)
11:59:36 <Igloo> You can get what are essentially MBs as PCI cards
11:59:36 <vincent> of course, it would be _neat_
11:59:41 <thebug> shapr: so...Sequent machines <NUMA x86> ?
11:59:57 <vincent> what about a functional os ?
12:00:28 <vincent> has it been tried ?
12:00:29 <thebug> Sequent machines ran Squent Unix
12:00:38 <shapr> thebug: I have wondered if Haskell's 'create immutable garbage collected structures' would work on non-cache-coherent NUMA
12:00:39 <Riastradh> I want an OS based on rigorous mathematical verification and one focus language.
12:00:41 <thebug> err s/Squ/Sequ/
12:00:49 <shapr> vincent: look at hOp
12:00:54 <shapr> GHC boots on the bare metal.
12:00:59 * vincent fires up google
12:01:00 <vincent> cool
12:01:07 <Riastradh> Preferrably Scheme, but I'm probably not allowed to say that here.
12:01:11 <Riastradh> ...oops.
12:01:52 <shapr> well, if Linux did support amp, you could plugin more CPUs as cards, as Igloo said
12:02:04 <shapr> or you could do crazy stuff like recompile linux for your NVidia GPU
12:02:12 <vincent> hehe
12:02:26 <shapr> or even crazier, get linux running on an FPGA where it reconfigures the FPGA according to what sort of CPU would be handy right now.
12:02:53 <vincent> chicken and egg problems ?
12:03:11 <Igloo> I don't think you'd want to rewrite your FPGA /too/ freely
12:03:22 <Igloo> That would get (even more) expensive
12:03:33 <vincent> try to proove the validity of such a system
12:03:34 <thebug> linux does support NUMA
12:03:37 <vincent> would be hard
12:03:45 <shapr> thebug: but only ccNUMA, right?
12:03:55 <vincent> yep
12:03:57 <thebug> shapr: propbably
12:04:20 <shapr> would be fun to write an FPGA scheduler 
12:05:04 <Igloo> Oh, looks like debian-vote was a false start, anyway
12:05:05 <shapr> "it'll cost me 3000 cycles to reconfigure half the chip for MPEG decoding, but xine is running so..."
12:05:12 <Cale> :)
12:06:13 <thebug> 3000 cycles isn't all that long ...
12:06:14 <Cale> It's probably possible to do quite well when you can statically analyse what you'll need.
12:06:22 * vincent tries to grok nomads (euh, monads)
12:06:25 <Cale> 3000 cycles is forever :)
12:06:47 <shapr> unless you're playing a movie
12:06:51 <Cale> right
12:07:04 <vincent> so we are looking for a realtime noncc NUMA kernel preferably written in a functional language
12:07:07 <vincent> :)
12:07:20 <thebug> hang on, I'll grab one at the conveniece store
12:07:24 <shapr> asymmetric kernel
12:07:25 <vincent> realtime so you know the bounds on all the things you want to do
12:07:34 <shapr> that runs on FPGAs too ;-)
12:07:40 <vincent> thebug: pick one for me too
12:07:49 <vincent> thebug strawberry flavor please
12:07:56 <thebug> mmmkay, fat free or no?
12:08:05 <vincent> um, with lots of bloat
12:08:07 <vincent> ;)
12:08:21 <shapr> I think cache-coherency costs more than 10% of the hardware performance
12:08:24 <thebug> okay, I'll make sure to pick one of those up ... you want the hardware to go with that?
12:08:26 <shapr> I've read as high as 15%
12:08:35 <vincent> thebug of course, blinkenlights
12:09:12 <vincent> shapr we need fast memory: let's make caches obsolete
12:09:13 <gintas> shapr: what's AFP? :)
12:09:17 <shapr> bah, this calls for unicycling!
12:09:27 * shapr wobbles off into the rain
12:09:30 <Riastradh> Build a garbage collector into hardware.
12:09:54 <vincent> Riastradh Intel does that ;)
12:09:56 * esap thinks that a garbage-collecting hardware is a very bad idea.
12:10:34 * vincent smells a hw vs software debate and joins shapr
12:10:45 <vincent> *wobble*
12:10:47 <Cale> heheheh
12:11:36 <thebug> looots of blinkenlights
12:11:42 * Riastradh beats someone over the head with a chunk of hardware.
12:11:52 <vincent> thebug: blue ones
12:12:05 <Riastradh> Black ones!
12:12:13 <gintas> shapr: well, if you were referring to the International Summer School on Advanced Functional Programming, I'm not coming
12:12:14 <thebug> hmm I'm not sure if blue ones count as heresy or not
12:12:41 <gintas> shapr: and what was that about my height? :-/
12:12:50 <esap> naah, not a big debate, just an observation that garbage collection is not always the correct solution for memory management needs. Putting it into hardware would have to consider this, and then you would need to distinguish between OO and functional programming in the hardware. Not a good idea.
12:13:25 * esap would rather like a type system for the hardware :-)
12:14:04 <gintas> ahh, no lithuanians in AFP...
12:14:12 <Cale> Will the type system have wobbly unification? :)
12:15:09 <vincent> the one finger type system doesn't work with unicycles, so no
12:16:20 * vincent hears parsers cringe
12:16:44 <vincent> I'll take me coat ;)
12:17:11 * esap tries to semantically analyse the wobbly unifiers.
12:18:15 <Cale> Figure 6 in the recent GADT paper is awesome :)
12:18:19 <Riastradh> The communist wobblies are taking over #haskell!!
12:18:43 <SamB> Riastradh: umm, you mean they have to take it over?
12:19:07 <esap> cale: GADT paper?
12:19:22 <vincent> SamB electroshocks might help too :)
12:19:28 <Cale> http://research.microsoft.com/~simonpj/papers/gadt/
12:21:01 <vincent> great
12:21:04 <SamB> it seems to me that putting GC in hardware would just constrain the memory layout too much... unless, of course, it was reprogrammable hardware.
12:21:07 <esap> "... Any feature with so many names must be useful..."
12:21:24 <vincent> :)
12:50:43 <Lemmih> SyntaxNinja: Still not here?
13:09:11 <SyntaxNinja> hi Lemmih
13:16:31 <bourbaki> hi
13:17:55 <Lemmih> SyntaxNinja: Do you think parseFilePath should allow unescaped spaces?
13:18:42 <SyntaxNinja> my intuition says 'no'.  why would you want them?
13:18:50 <SyntaxNinja> we'd have to go through and put the escapes in, right?
13:20:21 <Lemmih> Marvin thinks it would be good for readability but it would probably be a little inconsistent.
13:23:39 <Marvin--> I just want to know exactly what should be escaped and how (and why...)
13:24:05 <Marvin--> the only things we strictly have to escape are commas, and leading and terminating spaces
13:24:48 <Marvin--> oh, and we should consistently use / for path separation and convert them for non-unix platforms IMO
13:27:44 <SyntaxNinja> ok
13:27:46 <SyntaxNinja> ummm
13:28:49 <SyntaxNinja> I guess to use the paths, we'd actually have to unescape them
13:29:29 <SyntaxNinja> so what about "foo , bar"
13:29:33 <Marvin--> well, Lemmih's parseEscapedChar = try (char '\\') >> anyChar  does that automatically
13:30:12 <SyntaxNinja> if we don't have escapes either we have to enforce a rule about whitespace, or we have no way to say "foo\ "
13:30:23 <SyntaxNinja> I guess that's why you asked about spaces?
13:30:48 <Marvin--> well, as I said, the only spaces we need to escape are leading and terminating
13:31:12 <SyntaxNinja> oh right
13:31:24 <Marvin--> they are bound to be extremely rare
13:31:26 <SyntaxNinja> man. i'm so inefficient when I only give IRC half of my attention
13:31:42 <SyntaxNinja> OK but I definitely think it woudl be nicer to have clear rules about what needs to be escaped
13:32:14 <Marvin--> definitely
13:32:27 <SyntaxNinja> I guess what you said works, it's a little different from most rules of that nature
13:33:13 <Lemmih> Wouldn't it be overkill to difference between leading/trailing spaces and mid sentence spaces?
13:33:34 <SyntaxNinja> I got my laptop back today, btw.
13:34:01 <SyntaxNinja> martin's rule is actually simple, it's just kinda funny. otherwise, we have to give a list of things that need to be escaped maybe?
13:34:19 <SyntaxNinja> but I guess there's nor eason to escape anything besides commas and spaces
13:34:21 <SyntaxNinja> soooooo
13:34:26 <Marvin--> the question is, exactly *what* do we want to escape?
13:34:33 <Marvin--> newline? tab?
13:34:48 <Marvin--> unix allows a lot of characters in file names
13:35:03 <SyntaxNinja> how 'bout commas and whitespace? 
13:35:24 * Marvin-- grumbles something about how this wouldn't have been a problem if we'd just stuck to haskell strings in source code
13:35:36 <SyntaxNinja> or xml
13:35:37 <SyntaxNinja> ;)
13:35:50 <Marvin--> oh. what joy
13:35:54 <Smerdyakov> Does anyone know of a way in LaTeX to define a macro to be used in math mode, such that nothing will be typeset directly after it?
13:36:16 <Smerdyakov> LaTeX runs space-separated sequences of alphabetic characters together by default.
13:36:42 <SamB> Smerdyakov: how much nothing do you want?
13:37:05 <Smerdyakov> SamB, not sure. About the same as between words in a sentence.
13:37:16 <Marvin--> SamB: haha
13:38:58 <SamB> Smerdyakov: do you have the latex info file? if so, try visiting "(latex)Spacing in Math Mode"
13:39:54 <Smerdyakov> I know how to add spaces explicitly. I don't always want extra space after such an entity, though.
13:40:04 <SamB> oh.
13:40:50 <SamB> so when would you want extra space?
13:41:11 <Smerdyakov> Only to prevent merging of adjacent groups of alphabetic characters
13:41:14 <Marvin--> SyntaxNinja: we could do it the ugly way, quoting the file names and using read :: String -> String
13:42:17 <Marvin--> that would make it rather obvious what quoting will do
13:42:52 <SyntaxNinja> hm.
13:43:17 <SyntaxNinja> is that much simpler than the "commas and whitespace" rule?
13:43:25 <SyntaxNinja> oh, and "/" I guses
13:44:10 <XTL> le0: excessive collisions, tdr 65
13:44:16 <XTL> *sigh*
13:44:26 <Marvin--> well, we get a bunch of escaping for free, predictable escaping
13:44:46 <Marvin--> and we don't limit what people can put in their paths
13:45:12 <Marvin--> two rather nice things to have, IMO
13:46:50 * Marvin-- pours a glass of caol ila
13:47:03 <SyntaxNinja> but those quotes...
13:47:15 <SyntaxNinja> well, I guess I don't hate ite, and you're writing it, so I say go for it :)
13:47:32 <Marvin--> *we* are writing it
13:48:08 <Lemmih> And error handling via fail?
13:49:15 <Marvin--> parse errors for the string? We can tap directly into readsPrec
13:50:13 <Marvin--> @type reads
13:50:18 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
13:50:46 <Marvin--> I don't know if that can be turned into a parsec parser
13:51:45 <SyntaxNinja> Marvin--: hm. I guess if I were doing it, I would not use quotes. I like the readability of no-quotes. OTOH, predictability and ease of implementation are important
13:52:08 <SyntaxNinja> so it's a bit of a trade-off decision. I'd say you and I might make different decisions there, but I think you'll get to it before me.
13:52:22 <SyntaxNinja> so I would be more than happy to let you decide.
13:53:41 <Marvin--> well, regardless of how we do it, actually needing quotes will be very very very very rare
13:53:51 <Marvin--> honestly, how often do you see a path that begins or ends with a space?
13:54:09 <Marvin--> commas, I can see, which means that copy&paste will be ruined anyway
13:55:15 <Marvin--> if we use haskell string syntax, we won't have to escape commas, copy&paste will be just fine and for the people who do want to put funky stuff in their path names, using haskell strings makes the escaping very predictable
13:56:17 <SyntaxNinja> I agree with all that.
13:56:21 <Marvin--> if you have  c-src: foo\ bar..., some\\where..., weird\tstuff  you'll wonder what on earth it means
13:56:34 <SyntaxNinja> so are you saying that you'll require quotes, or just allow quotes?
13:57:42 <Igloo> You could have   Haskell String with quotes | [-a-zA-Z0-9.]+   or somesuch
13:57:44 <Marvin--> I was going to say require, but on the other hand we could relax the need for quotes in the case of paths that don't contain commas and backslashes
13:58:07 <Marvin--> Igloo: and / ;-)
13:58:29 <Igloo> Yeah, and probably _ and a few others, but you get the idea  :-)
13:58:34 <Marvin--> right
13:59:11 <Marvin--> It's a pretty simple rule to remember, "as long as I don't do anything funky, I'm all right, but otherwise I'm going to have to use haskell strings"
14:00:05 <Marvin--> and we should stress that cabal expects / as directory separator and will convert it properly based on platform
14:01:32 <SyntaxNinja> I have to run. if you still have any concerns, email me :)
14:01:40 <SyntaxNinja> I'll be able to check syntaxpolice.org email tongiht :)
14:01:41 <SyntaxNinja> peace all
14:01:42 * SyntaxNinja &
14:08:05 <Lemmih> Marvin--: How would you use reads with Parsec?
14:11:04 <Marvin--> I probably wouldn't
14:11:06 <Marvin--> pity
14:11:12 <Marvin--> works quite well with ReadP though :)
14:12:08 <Marvin--> I'll think a bit on it, though
14:12:27 <Igloo> You can do it with getInput and setInput surely?
14:16:18 <Marvin--> @index getInput
14:16:19 <lambdabot> Language.Haskell.ParseMonad,Text.ParserCombinators.Parsec,Text.ParserCombinators
14:16:19 <lambdabot> Parsec.Prim
14:16:25 <Lemmih> parseFilePath = do s <- getInput >>= return . reads
14:16:26 <Lemmih>                    case s of
14:16:26 <Lemmih>                      [(s,_)] -> return s
14:16:26 <Lemmih>                      _       -> fail "Some error"
14:17:15 <Lemmih> ?
14:17:16 <Igloo> You'll also need to setInput _ (YKWIM), no?
14:18:01 <Marvin--> and there should be a case for non-quoted string too
14:22:29 <Marvin--> this means we'll have to rewrite parseCommaList though
14:22:32 <shapr> man I love unicycling
14:22:43 <Marvin--> parseFilePath :: GenParser Char st FilePath
14:22:43 <Marvin--> parseFilePath = try (many1 (satisfy (`notElem`"\\ ,")))
14:22:43 <Marvin-->                 <|>
14:22:43 <Marvin-->                 do toks <- getInput
14:22:43 <Marvin-->                    case reads toks of
14:22:44 <Marvin-->                      [(str,toks')] -> do setInput toks'
14:22:46 <Marvin-->                                          return str
14:22:48 <Marvin-->                      _             -> mzero
14:23:20 <Marvin--> but we'll need a separate parseFilePaths :/
14:23:39 <Igloo> I'd make a parseReads or something and use that in parseFilePath
14:24:07 <Marvin--> well, sure
14:24:28 <kosmikus|away> if I say: >word< is capitalized, do I mean >Word< or >WORD<?
14:26:09 <Igloo> I mean >Word<
14:26:14 <Igloo> I don't know what you mean though  :-)
14:26:22 <kosmikus|away> ok
14:26:23 <kosmikus|away> good
14:26:33 <shapr> capitalized means the first letter is caps
14:26:43 <kosmikus|away> what would you say if you meant >WORD<?
14:26:48 <Marvin--> 3. To print in capital letters, or with an initial capital. [1913 Webster]
14:26:53 <shapr> uppercase?
14:26:57 <Marvin--> I'd say it's ambigous :-)
14:27:06 <shapr> @wn capitalize
14:27:08 <lambdabot> *** "capitalize" wn "WordNet (r) 2.0"
14:27:08 <lambdabot> capitalize
14:27:08 <lambdabot>      v 1: draw advantages from; "he is capitalizing on her mistake";
14:27:08 <lambdabot>           "she took advantage of his absence to meet her lover"
14:27:09 <lambdabot>           [syn: {capitalise}, {take advantage}]
14:27:11 <lambdabot>      2: supply with capital, as of a business by using a combination
14:27:13 <lambdabot>         of capital used by investors and debt capital provided by
14:27:15 <lambdabot>         lenders [syn: {capitalise}]
14:27:17 <lambdabot> [7 @more lines]
14:27:18 <Igloo> in all capitals, maybe
14:27:44 <kosmikus|away> I see, thanks
14:28:00 <Marvin--> last minute changes? ;)
14:28:02 <shapr> oy, I just got a website support email in spanish
14:28:15 <shapr> Estimados Senores,
14:28:18 * shapr grins
14:28:40 <thebug> what a capital idea
14:28:53 <shapr> so, anyone here knows spanish?
14:30:13 <Marvin--> eh, chuck it in the spam folder, that's what I do with mails I can't read :P
14:31:35 <shapr> sadly, this website is officially in english, spanish, and portuguese.
14:31:44 <shapr> at least I have some basic idea about spanish
14:31:55 <shapr> brazilian portuguese is beyond me
14:32:23 <shapr> hey, how would you make an i18n website framework with Haskell?
14:32:29 <Lemmih> parseEscapedString = many1 (choice [parseEscapedAnyChar,noneOf " \t,"])
14:32:29 <Lemmih> parseFilePath = do i <- getInput
14:32:29 <Lemmih>                    case reads i of
14:32:29 <Lemmih>                      [(s,r)] -> setInput r >> return s
14:32:29 <Lemmih>                      _       -> setInput i >> parseEscapedString
14:32:30 <shapr> I haven't come up with any good solutions yet...
14:35:09 <Marvin--> Lemmih: no, we don't want any escaping in the non-quoted version
14:35:22 <Lemmih> Why not?
14:35:29 <Marvin--> KISS
14:35:42 <Marvin--> if you don't want to KISS, use quoted strings
14:35:55 <bourbaki> :)
14:36:28 <Marvin--> (and don't you dare twist that into some perverted quote! :)
14:36:42 <Lemmih> s/parseEscapedString/many1 (noneOf "\\ ,")/
14:37:15 <bourbaki> can anyone tell me if there is a connection between anamorphisms and coalgebras?
14:37:21 <Marvin--> Lemmih: but then it's equivalent to my version, isn't it?
14:37:55 <Lemmih> Marvin--: Yeah but mine is shorter d-:
14:42:10 <Igloo> I assume setInput i in the last line there is redundant
14:44:27 <Lemmih> D'oh
14:46:11 <Marvin--> see bottom of the paste page, what do you think of that?
14:47:12 <Marvin--> > parse parseFilePaths "foo" "foo, \"b,ar\", baz"
14:47:12 <Marvin--> Right ["foo","b,ar","baz"]
14:48:31 <Lemmih> Why not use parseCommaList?
14:49:10 <Marvin--> because that's ambigous
14:49:13 <Marvin--> > parse (parseCommaList parseFilePath) "foo" "foo, \"b,ar\", baz"
14:49:13 <Marvin--> Right ["foo","\"b","ar\"","baz"]
14:49:50 <Lemmih> That would not be the case.
14:49:52 <Marvin--> well, actually I suppose if parseFilePath = try parseReadS <|> many1 (...)  it would work
14:50:10 <Marvin--> (I had written it as try (many1 (...)) <|> parseReadS  first
14:50:30 <Marvin--> damn asymmetric <|>
14:51:41 <Lemmih> I've added my version of the wiki.
14:51:52 <Igloo> " should be a character that needs escaping and you shouldn't need try
14:52:14 <Igloo> My preference would still be for an explicit list of characters you can use in the simple case
14:52:35 <Lemmih> s/of/to/
14:52:37 <Igloo> Or at least eliminate all whitespace too
14:53:33 <Marvin--> true
14:53:52 <Marvin--> well, newlines will already be removed at this point, by the unlines call :)
14:55:14 <Igloo> Woo! http://people.debian.org/~igloo/status.php?packages=ghc6
15:01:59 <Lemmih> Marvin--: So what will it be?
15:02:17 <vincent> Igloo: great
15:02:39 <Marvin--> aww, don't push me, I'm reading Meaning of Liff now :P
15:03:03 <Marvin--> I'd better have another glass
15:05:42 <Marvin--> how about  parseFilePath = parseReadS <|> (many1 (alphaNum <|> oneOf "-+/_."))
15:05:46 <Igloo> I'd take Lemmih's, rename it to parseReads, change the last line to   _ -> fail "bad readS"  (or similar) and then parseFilePath = parseReads <|> many1 (noneOf ",\\ ")   (except if it were me I'd also change the regexp as suggested)
15:05:59 <Igloo> Yeah, like that  :-)
15:26:52 * Marvin-- even takes the time to write a long comment this time
16:38:54 <Igloo> Anyone know why ghc-pkg isn't liking my ––config-file=package.conf argument?
16:39:34 <Marvin--> umm... no?
16:40:14 <Igloo> Does this work for you? echo "[]" > package.conf; ghc-pkg --add-package ––config-file=package.conf
16:42:41 <Marvin--> well, it's complaining about paths, because I just grabbed a random config snippet
16:43:12 <Marvin--> but yes, it works
16:43:23 <Igloo> Urgle - execve("/home/igloo/local/ghc//lib/ghc-6.3/ghc-pkg.bin", ["/home/igloo/local/ghc//lib/ghc-6.3/ghc-pkg.bin", "-f", "/home/igloo/local/ghc//lib/ghc-6.3/package.conf", "--add-package", "\342\200\223\342\200\223config-file", "./package.conf"]
16:45:03 <Marvin--> ooh, I thought the hyphens looked weird
16:45:22 <Igloo> Oh, it'll be because I copied them from galeon
16:45:52 <Marvin--> there are way too many dashes
16:46:41 <Igloo> Hmm, why do the files need to exist? Is it just sanity checking?
16:47:24 <Marvin--> I suppose
16:47:47 <Marvin--> not finding the .a file is an error, not finding the .o is just a warning
16:51:38 <TheHunter_> bourbaki: sure there is
16:52:55 <bourbaki> is there a haskell go client?
16:52:58 <bourbaki> hi TheHunter
16:53:08 <TheHunter> hi, bourbaki 
16:53:14 <TheHunter> how are you?
16:53:38 <bourbaki> fine thank you and you?
16:53:53 <bourbaki> TheHunter do you know anamorpisms and coalgebras?
16:54:00 <TheHunter> i'm ok (though not entirely sober...)
16:54:32 <TheHunter> a little bit, mostly from the "bananas in space" paper
16:54:54 <bourbaki> ah heh i havent read that yet i will do that then :)
16:55:19 <Igloo> Excellent, I now have an example set of libraries where if optimisation is use and a library internals changes the resulting program is wrong
16:55:35 <TheHunter> it has a pretty good introduction, but i haven't read the "in space" part yet...
16:55:46 <Marvin--> Igloo: And by "excellent" you mean "damn", right?
16:56:04 <Igloo> Well, it at least means I was right  :-)
16:56:28 <bourbaki> TheHunter i think about writeing an l system with coalgebras as a little example :)
16:57:25 <Igloo> OK, I'm not going to mail SM now as I have the answer, and an example to prove it
16:57:56 <TheHunter> bourbaki, l system, isn't that something about fractals?
16:58:23 <Igloo> So the only question IMO is whether we depend on (>= 1.2.3 && < 1.2.4.0) or (= 1.2.3-4)
16:58:28 <bourbaki> TheHunter yes its an interative fracal system
16:58:36 <bourbaki> dragon curves koch curves etc
16:59:47 <TheHunter> bourbaki, cool, can you model coalgebras in an l-system?
17:00:04 <bourbaki> i hope so yes
17:00:08 <TheHunter> they're probably very ubiquiteous
17:00:14 <bourbaki> that is like in an production system
17:00:17 <Marvin--> Igloo: if we want to be completely sure? (=1.2.3-4)
17:00:35 <Marvin--> Igloo: do we know *what* library internals we can safely mess with? :)
17:00:55 <bourbaki> TheHunter if you want i tell you how i would like to do that tomorrow
17:01:04 <bourbaki> after i read bananas in space :)
17:01:05 <Igloo> Well, we promise not to touch the code if we do the && one. And if we do we add a pile of conflicts with existing libraries
17:01:30 <Igloo> But it means we can't fix bugs without hassle, so I guess = it is
17:01:34 <Igloo> *sigh*
17:01:48 <Marvin--> *shudder*
17:02:37 <Igloo> Evil manglers, now this - remind me why I love this language again?  :-)
17:02:49 <Marvin--> I was thinking the same thing
17:02:57 <TheHunter> bourbaki, sounds interesting. I'm always surprised where you can apply all that categorical stuff.
17:03:03 <Marvin--> this is a big point against cross-module optimization
17:03:24 <bourbaki> TheHunter you mean where i can do it or in general :)?
17:03:46 <TheHunter> bourbaki, in general
17:04:01 <bourbaki> TheHunter i just think what i could add to my thesis :)
17:04:11 <bourbaki> and i will add coalgebras to simulate my machines
17:04:32 <Igloo> Did anyone decide anything about cabal dashes and tags and stuff, BTW?
17:06:33 <Igloo> It looks like both modules have to be optimised for it to break, but I think that's probably a bug
17:06:57 <Igloo> I don't see why the inlining shouldn't happen if the calling module isn't optimised
17:08:51 <SamB> Igloo: some poeple think inlining is an optimization.
17:10:01 <Igloo> I guess that's a reasonable point
17:10:22 <Igloo> And it won't quite be free as you'll have more code to compile
17:10:54 <TheHunter> bourbaki, the more i think about that algebra/coalgebra/cata/ana stuff the less i think i understand it :(
17:11:59 <Marvin--> what happens if you compile libraries without optimization and only optimize when you compile applications?
17:12:16 <bourbaki> TheHunter :) heh well i just apply it to stuff
17:12:18 <Marvin--> major loss of speed?
17:12:23 <Igloo> That would work, but your libraries would all be slow
17:12:48 <Igloo> And you'd expect most of the work to be done by libraries ultimately
17:12:50 <Marvin--> hm, yeah, it won't optimize while linking, obviously
17:13:43 <bourbaki> TheHunter i wonder if you can see monads as catamorphisms and then construct something like a coalgebraic monad and combine them
17:13:48 <bourbaki> like a bialgebra
17:14:18 <shapr> comonads?
17:14:49 <bourbaki> is there something like that?
17:14:52 <TheHunter> bourbaki, catas and anas are very intuitive actually, the former recursively destruct a algebraic data typ, the latter destroy it. And Hylos are primitive recursions with a "recursion pattern" given by the functor. The connection to category theory seems quite difficult to me, though
17:15:05 <TheHunter> you won't be lucky with comonads in haskell
17:15:22 <TheHunter> you need a linear type system
17:15:43 <bourbaki> well it might be interesting in some cases
17:15:56 <TheHunter> s/destroy/construct/
17:16:02 <Cale> You'll be fine with comonads in Haskell, just don't use them for IO
17:16:20 <bourbaki> is there something like bimonads also?
17:16:27 <shapr> http://www.haskell.org/hawiki/CoMonad
17:16:48 <Igloo> http://urchin.earth.li/~ian/ps.tar.gz if anyone is interested
17:17:09 <shapr> oh, what's that?
17:17:15 * shapr reads back
17:18:29 <Igloo> It's an instrument of torture for Debian Haskell packagers
17:18:56 <shapr> oh
17:18:57 <shapr> neat!
17:19:08 <Igloo> I think you're confused, dear  :-)
17:19:17 * shapr bounces confusedly
17:19:41 * shapr confuses bouncily
17:19:41 <Igloo> How's the c2hs packaging going, anyway?  :-)
17:19:44 <shapr> um
17:19:45 <shapr> uh
17:19:46 <shapr> well
17:19:51 <shapr> I haven't looked at it since it built.
17:19:54 <Marvin--> meh, I was wondering why it talked about /home/igloo, then I read the .conf files
17:19:56 <shapr> oh, I was going to update the standards version
17:20:09 <Igloo> Oh, point
17:20:54 <Marvin--> gosh, look at the time
17:20:57 <Marvin--> I'm off to bed
17:23:35 <shapr> hiya jao 
17:23:38 <TheHunter> Cale, if you have f, g :: w a -> a, you can generally do \wa -> (f wa, g wa) :: w a -> (a, a) which is unsafe. I kinda think state comonads satisfy additional properties that ensure that this doesn't matter
17:23:52 <jao> hi shapr
17:24:06 <Cale> TheHunter: why is it unsafe?
17:24:37 <Cale> If w has nothing to do with IO, I can't see how that would be unsafe.
17:24:54 <shapr> jao: did you write a book?
17:24:54 <TheHunter> doesn't w a -> a contain side effects?
17:25:02 * Igloo updates the tarball to be working-directory independent
17:25:04 <Cale> not unless w = OI
17:25:10 <jao> shapr, sort of, yes
17:25:16 <shapr> nice cover pic
17:25:23 <jao> :)
17:25:37 <bourbaki> what cover pic?
17:25:38 <Cale> It's just like monads - not all monads embody side effects, just IO
17:25:42 <shapr> does that mean you know Darius Bacon?
17:25:46 <shapr> g'day Pseudonym 
17:25:49 <Pseudonym> G'day,.
17:25:58 <jao> shammah, no, I don't know him
17:25:58 <Pseudonym> Been reading Ralf Hinze's paper on Church numerals.
17:26:03 <Pseudonym> Very cute.
17:26:07 <jao> shammah, sorry, it was shapr
17:26:31 <Pseudonym> It dovetails nicely with his "deriving from specifications" paper.
17:26:34 <TheHunter> Cale, i mean "side effects" like the state monad has (e.g., updating the state)
17:26:51 <shapr> jao: did you move to columbia.edu for graduate work?
17:27:07 <shapr> I thought you were somewhere else before...
17:27:19 * shapr is confused
17:27:44 <jao> bourbaki, this http://www.gnu.org/doc/mdk.html
17:27:52 * shapr finds the "about the author" entry on amazon.com
17:28:00 <jao> shapr, no, i'm here in a conference (AAMAS 04)
17:28:00 <Cale> TheHunter: well, depending on the implementation, I can't really see that going wrong if it's implemented using pure haskell functions.
17:28:07 <shapr> ah, ok
17:28:10 <shapr> jao: nifty!
17:28:18 <shapr> whoa, theoretical physics :-)
17:28:31 <jao> :-) it was in a previous life
17:28:36 <Cale> The result you get will be referentially transparent still.
17:29:00 <TheHunter> has anyone figured if there is a connection between hinze's nondet monad (a -> b -> b) -> (b -> b) and church numerals (b -> b) -> (b -> b)
17:29:39 <shapr> how'd you get from physics to programming?
17:30:46 <TheHunter> Cale, let me think about it...
17:30:46 <shapr> aha, I found your homepage.
17:30:47 <jao> i quit the university and began working as a programmer. after six years, i'm back in the academia, but this time as a 'computer scientist' (I studied CS during that period).
17:31:13 <jao> heh... it's a little bit outdated :)
17:31:19 <bourbaki> jao is that your book?
17:31:29 <jao> bourbaki, yes, it is.
17:31:33 <bourbaki> cool :)
17:31:46 <jao> thx :)
17:32:15 <bourbaki> id like to write a book also one day :)
17:32:38 <jao> it's just a matter of beginning to write :)
17:32:47 <shapr> wow, I've never heard of the word viscoelastic.
17:32:58 <bourbaki> well yes thats true but i cant write :)
17:33:11 <jao> bourbaki, oh, how so?
17:33:26 <bourbaki> isnt that the elasticity of viscous suff?
17:33:45 <bourbaki> jao well lets say i cant put down in words what i think :)
17:33:56 <bourbaki> i have a hard time explaining my ideas
17:34:20 <jao> you just need practice, then :)
17:34:37 <bourbaki> maybe yes
17:34:37 <shapr> aamas looks like fun
17:34:41 <jao> and reading a lot!
17:34:45 <TheHunter> bourbaki, i have the same problem
17:34:58 <bourbaki> i read a lot of math stuff and fun books and so
17:35:17 <jao> then, practice! :)
17:35:35 <bourbaki> well i have written some small articles
17:35:48 <bourbaki> and stuff at uni and so
17:35:53 <bourbaki> and at work
17:36:16 <jao> (btw, viscoelasticity = elasticity of not perfectly elastic bodies)
17:36:38 <jao> bourbaki, then, you _can_ write
17:36:39 <bourbaki> but i still cant put down what i thought really :) i need to discuss things to tell others what i really mean
17:36:59 <bourbaki> yes its just that ppl ask me what i meant with stuff and so
17:37:09 <jao> bourbaki, oh, maybe you could try to write socratic dialogs ;)
17:37:31 <bourbaki> heh maybe yes :)
17:37:43 <bourbaki> like putting down your train of thought that is?
17:38:07 <jao> yes. you could be the author of 'the little haskeller' :)
17:38:30 <bourbaki> heh
17:38:32 <shapr> Pseudonym: hey, does your physics stuff do autoconverting?
17:38:54 <shapr> I was thinking of exploiting it for a @units plugin
17:39:01 <bourbaki> well i dont think i can do that :)
17:39:32 <bourbaki> to me its often like that , i think about something and then in a split second i branch to something completely different
17:39:50 <jao> bourbaki, sure you can. 'i can't do that' is just an excuse for not working :)
17:40:12 <bourbaki> heh ok you are right there
17:40:31 <bourbaki> more pleasant would be to log the channels i talk in :)
17:40:39 <jao> :)
17:40:41 <bourbaki> and then make up a book of that ;)
17:40:53 <bourbaki> like the explenations in some religions
17:41:47 <bourbaki> or more ppl should give me feedback :)
17:42:05 <shapr> you could write Haskell tutorial for specific subjects
17:42:08 <shapr> then get people to try them
17:42:49 <shapr> that could refine your communication abilities
17:42:58 <bourbaki> oh btw have you put some more thought in the haskell teaching channel ?
17:43:50 <bourbaki> most often its just that i have thought things through like a million of times and dont put them down in the end until someone asks why is that the case
17:47:02 <bourbaki> also i would need a topic to write about :)
17:47:15 <shapr> write what you know
17:47:29 <shapr> if possible, write about something you know, that other people would like to know about
17:50:31 <TheHunter> bye
17:50:34 <bourbaki> bye
17:55:09 * shapr swears at Plone
17:55:56 <bourbaki> whos plone?
17:56:14 <Cale> It's a CMS
17:56:23 <bourbaki> cmd?
17:56:27 <bourbaki> cms
17:56:31 <Cale> http://plone.org/
17:56:41 <Cale> content management system
17:57:12 <bourbaki> ah cool
18:03:50 <shapr> it's how I keep from starving.
18:04:12 <bourbaki> you eat webpages?:)
18:05:43 <shapr> well, I make webpages, and then I got money.
18:06:05 <Cale> He's lying to you. He eats webpages.
18:06:05 <bourbaki> ah
18:06:13 <bourbaki> :)
18:06:20 * shapr grins
18:06:45 <bourbaki> what was that other thing that was derived form phantom types and algebraic types?
18:06:58 <Cale> wobbly types
18:07:05 <bourbaki> right
18:08:55 <ozone> gee, i wonder if simonpj chose the name for that
18:29:01 <Pseudonym> @arr
18:29:02 <lambdabot> Get out of me way, yeh landlubber
20:55:05 <Fractal> Why does hugs give an error on this expression:  [] == []
20:55:05 <Fractal> ?
20:55:21 <Riastradh> What error does it give?
20:55:32 <Fractal> ERROR - Unresolved overloading
20:55:33 <Fractal> *** Type       : Eq a => Bool
20:55:33 <Fractal> *** Expression : [] == []
20:55:50 <Fractal> But, for instance, [1] == [1] works fine
20:56:06 <Fractal> [()] == [()] works
20:56:17 <Cale> bug?
20:56:22 <Cale> It works in ghci
20:56:23 <Riastradh> That's because those have specific types.
20:56:34 <Riastradh> [] has the type [a], for any a.
20:56:50 <Riastradh> Hugs can't figure out what instance of Eq [a] to use, because a is unresolved.
20:57:30 <Riastradh> GHC has a lot more type system magic than Hugs does, I believe.
20:57:42 <heatsink> so... will [] :: [Int] == [] work?
20:57:49 <Riastradh> Try it and find out.
20:57:59 <Fractal> [1] == [] works fine
20:58:06 <Cale> yeah
20:58:07 <Fractal> Returns False, that is
20:58:10 <heatsink> [] == [] works for me in hugs
20:58:10 <Cale> Prelude> ([] :: [Int]) == []
20:58:10 <Cale> True
20:58:22 <Cale> Prelude> [] == []
20:58:22 <Cale> True
20:58:24 <Cale> yeah
20:58:29 <Fractal> Wierd
20:58:32 <Cale> which version of hugs are you using?
20:58:52 <Fractal> Version: December 2001
20:58:59 <Fractal> Time for an upgrade?
20:59:00 <Cale> Version: November 2003
20:59:02 <Fractal> Heh
20:59:05 <Fractal> Ya OK
20:59:07 <Fractal> Will do
20:59:40 <Cale> depending on your platform, you may also want to get a hold of ghc
20:59:52 <Cale> ghci is really quite nice :)
21:20:04 <Cale> hahaha
21:20:14 * Cale needs to learn that it's C-S-Backspace and not C-M-Backspace :)
21:20:53 <SamB> ouch
21:20:57 <Cale> Never had this problem using vim :)
21:21:32 <SamB> I sometimes accidentally hit that, I don't remember what I'm usually doing at the time, but it is something to do with my brain not being thread-safe.
21:22:00 <Cale> :)
21:32:56 <jba> hi
21:33:25 <Cale> hello
21:34:39 <jba> I have a parameterized datatype for which a particular constructor should only be available for a particular type parameter
21:35:29 <jba> data Foo a = SomeInt a, but SomeInt should only be available if a is Int 
21:36:05 <monotonom> data Foo a = SomeInt Int  -- it is alright to leave 'a' unused
21:36:50 <jba> Unfortunately, I don't want SomeInt Int to construct a Foo a, I want SomeInt to construct a Foo Int
21:37:10 <jba> I want SomeInt to have type Int->Foo Int
21:37:25 <monotonom> data Foo = SomeInt Int  -- what's wrong with that?
21:37:46 <jba> Well, Foo also has other constructors that are parameterized on a
21:38:08 <Cale> jba: you're perhaps looking for wobbly types :)
21:38:15 <Cale> They're not implemented yet though.
21:38:17 <jba> I am!
21:38:26 <jba> But I'm trying to fudge it
21:38:27 <jba> I'
21:38:36 <jba> m willing to type a bit of boilerplate
21:39:19 <jba> I have a more specific question, in fact. I tried Foo a = forall b . (EqType a b, EqType b Int) => SomeInt Int
21:39:59 <monotonom> If you can afford to put Foo in a module, export minimally and hide a lot of things, you are game.
21:40:06 <jba> where class EqType a b | a->b, b->a and instance EqType a a
21:40:29 <jba> I thought about putting Foo in a module, but I don't know how to pattern match, then
21:41:28 <monotonom> Then wobbly type it is.
21:41:58 <jba> I was wondering why the existential mess above doesn't work
21:42:18 <SamB> because it is a mess, therefore not obviously correct.
21:42:37 <SamB> so the compiler couldn't figure it out either ;-)
21:43:07 <jba> But ghci tells me SomeInt 0 has type Foo Int
21:43:27 <jba> but foo (SomeInt x) = x barfs
21:43:45 <jba> "Inferred type is less polymorphic than expected"
21:46:14 <jba> I'm not sure what that means - everything looks kosher to me
21:48:04 <jba> It's very strange watching this appear here: http://tunes.org/~nef/logs/haskell/04.07.20
21:48:42 <Smerdyakov> This sentence is not yet in the log.
21:49:45 <jba> When you're not looking, this sentence isn't in the log.
21:50:27 <SamB> why do you say that? clog: is it in the log yet?
21:50:42 * SamB pretends to listen for an answer.
21:50:56 * Smerdyakov pretends to check SamB for bit-errors.
21:52:00 * monotonom pretends to pretend
21:52:19 <SamB> monotonom: you'll blow the proof checker!
21:52:21 <monotonom> I pretend those who don't pretend themselves
21:52:36 <Smerdyakov> You have nothing to pretend but pretension itself.
21:52:55 <SamB> I think the first one was plenty to form the paradox...
21:52:58 <jba> That's pretenditude, duh
21:53:20 * Smerdyakov hires a team of monkeys to check jba for bit-errors.
21:53:56 * monotonom makes a bunch of bit-errors to test the monkeys' ability.
21:54:21 <Smerdyakov> I see you are a raw youth, unacquainted with the realities of this world.
21:54:34 <Smerdyakov> The number one commandment for one who values his life: never test the monkeys' ability.
21:54:57 <monotonom> What? I thought the "real world" is about testing testing and testing, cf. JUnit, extreme programming, etc.
21:55:15 <Smerdyakov> You're right. The real world is all about cf..
21:55:26 <SamB> employ a QuickTest to make your bit-errors for you...
21:56:14 <Smerdyakov> You'll have the monkeys' union up in arms.
21:57:13 <SamB> Smerdyakov: but they won't know who wrote the QuickTest...
21:57:31 <Smerdyakov> Be realistic. A monkey can't write a QuickTest.
21:58:24 <SamB> I didn't say anything about a monkey writing a QuickTest...
21:59:08 <Smerdyakov> That's good. Let's keep it this way.
21:59:44 <SamB> I wonder why I typed QuickTest that first time, and not QuickCheck.
