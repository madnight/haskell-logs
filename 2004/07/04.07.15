00:40:49 <anduril1> I think I've found a bug in GHC, but I'd like somebody to check and see if I'm just crazy
00:41:06 <anduril1> see http://cse.unl.edu/~sjanssen/MakeChange.hs
00:46:33 <kosmikus> you write the code should return a tuple, but it returns a list of tuples (in my case, the empty list); so what's expected and actual behaviour?
00:47:08 <anduril1> do you have hugs?  it gives a different result
00:47:26 <anduril1> it should return [(2.0,1.05)]
00:52:53 <anduril1> Hugs returns [(2.0,1.05)] and GHC returns []
00:53:06 <norpan> hugs returns []
00:53:18 <anduril1> my comments were very vague and unclear
00:53:25 <anduril1> does it?
00:53:27 <norpan> yes
00:53:34 <norpan> Version: November 2002
00:53:43 <anduril1> that is the same version I have
00:54:45 <norpan> on the other hand, you use == on Float, which is a bad idea, numerically
00:55:17 <anduril1> that makes sense
00:55:30 <anduril1> maybe I'm running in to a rounding error
00:55:52 <norpan> perhaps
00:56:00 <norpan> but i get the same result in hugs, ghc 5 and ghc 6
00:56:13 <kosmikus> my hugs returns [] as well
00:56:20 <kosmikus> november 2003
00:56:54 <kosmikus> wasn't there something with hugs that you could allow or disallow double precision floats via a compile time flag?
00:57:00 <norpan> i haven't upgraded hugs, since  never use it :)
00:57:08 <norpan> i
00:57:36 <kosmikus> but anyway, don't use == on Floats, yes ...
00:57:52 <kosmikus> oh, they're floats anyway, not doubles
00:57:56 <kosmikus> so forget my other remark
00:58:14 <anduril1> yep, definitely a precision thing
00:58:43 <anduril1> sorry for the false alarm
01:01:50 <anduril1> quoth Office Space: "I must have put a decimal point in the wrong place or something. Shit, I always do that, I always mess up some mundane detail."
01:09:45 <dons> andruil1: you've take the code down?
01:10:05 <dons> oh. ok. I see.
02:26:30 <bourbaki> hi
05:03:21 <bourbaki> greetings
05:03:28 <lantis> hi
05:04:32 <Spark> tapl has started to get interesting :)
05:05:32 <bourbaki> tapl?
05:07:00 <Spark> types and progrmaming languages
05:07:11 <Spark> i like reading text books cover to cover
05:07:24 <Spark> probably cos they cost a fortune
05:07:33 <bourbaki> :)
05:35:10 <shapr> TaPL r0xx0rs
05:36:34 <thebug> indeed (re textbooks being large money sinks) ... I had a textbook that was about 100 pages (paperback) that cost about 125$ last year (!)
05:37:13 <norpan> yeah, they cost much, and they all suck
05:37:26 <thebug> even the wonderful (yet still expensive) ORA books are cheaper than that!
05:40:30 <flaw> dont you love that? books of facts(hopefully) cost $30->$100->..,, books of fiction can be purchased for <$5 at your local grocery store.. not so strange, but it is annoying.. =\
05:41:29 <thebug> yeh, though the <$5 'fiction' at the grocery store is usually more trash than fiction
05:41:33 <thebug> ;)
05:42:33 <flaw> makes it that much sadder ;)
05:43:12 <thebug> indeed ... I ought to be able to get Knuth's TAOCP for about 15$ at 7-11 ;)
05:43:44 <flaw> yeah damnit
05:44:10 <flaw> get some beef jerky while yer at it, now that's convenience!
05:44:27 <thebug> well, you have to have snacks with a good read
05:44:50 <thebug> and there's a lot to read of TAOCP ... 7 volumes worth if I remember correctly
05:45:08 <flaw> TAOCP?
05:45:20 <thebug> ah 5 volumes apparently
05:45:26 <flaw> de-acronymize?
05:45:36 <thebug> The Art of Computer Programming .. Donald Knuth
05:45:40 <thebug> http://www-cs-faculty.stanford.edu/~knuth/taocp.html
07:25:25 <kosmikus> 3 volumes; if you've got volume 4 already, I'd like to see it
07:27:39 <kosmikus> :)
07:32:25 <bourbaki> hi
07:32:35 <bourbaki> volumes of what?
07:33:05 <Igloo> TAOCP
07:33:18 <Igloo> kosmikus: So have you finished the first 3 then?  :-)
07:37:15 <bourbaki> what do these books cover?
07:38:35 <sazzle> lotsa things
07:41:19 <ibid> the core of classical computer science, in exceptional detail and rigour
07:41:42 <ibid> which explains why there are only three volumes of the seven promised puhlished :)
07:42:14 <bourbaki> its doesnt seem to be a must read then :)
07:43:20 <sazzle> they're not books that i'd read back to back
07:43:32 <sazzle> great reference though
07:51:21 <ibid> i originally figured out linked lists from taocp :)
07:52:46 <sazzle> heh
07:56:19 <thebug> hooray for linked lists!
07:56:33 <ibid> in 1998 or so
08:06:47 <sazzle> ibid: 2BG ?
08:23:29 <ibid> sazzle: 2BG?
08:23:47 <thebug> just to make this complete: 2BG?!
08:24:01 <sazzle> 2 years, before google :-P
08:24:06 <ibid> ah
08:24:22 <ibid> i have no memory of when i started using google
08:24:41 <thebug> haha
08:24:46 <thebug> nice
08:24:47 <sazzle> it appeared sometime around 2000, and that's when i first started using it, i think
08:26:37 <bourbaki> http://www.cis.upenn.edu/proj/plclub/contest/lists.php
08:26:48 <bourbaki> does anyone happen to know what language won the contest?
08:27:26 <Smerdyakov> The results are not announced until January.
08:27:33 <Smerdyakov> Er, until whenever the conference is.
08:27:36 <Smerdyakov> (Wrong conference :)
08:27:46 <bourbaki> ?
08:27:56 <Smerdyakov> What?
08:27:57 <bourbaki> dang i just got interested :)
08:28:03 <sazzle> The contest results will be announced at ICFP 2004 in Snowbird, Utah this September. 
08:28:09 <bourbaki> that wrong conf thing irritated me
08:29:08 <sazzle> that's a long time before results come through!
08:29:24 <bourbaki> yep
08:29:38 <bourbaki> i hope they will release an interpreter
08:29:51 <bourbaki> so that you can have a look at the sim :)
08:31:00 <arjanb> a haskell entry is likely to win this year
08:31:36 <bourbaki> whys that ?:) did you participate ;)?
08:33:22 <arjanb> someone did a comparison of most ants which were posted on websites and a haskell one won
08:34:14 <arjanb> i have participated though not in haskell
08:37:55 <bourbaki> i didnt get the idea fully
08:38:02 <bourbaki> you wirte a program that puts out the ant files?
08:39:12 <arjanb> yes and a primitive simulator for debugging the ants
08:40:19 <bourbaki> and you are allowed to iterate the ants via that program?
08:42:12 <arjanb> wdym?
08:49:45 <Igloo> The idea of the contest was to write an ant, which is itself a program
08:49:58 <Igloo> Many people wrote programs to generate the ants based on a higher level language
09:56:58 * SamB wonders what these word processor things are that they mention on http://www.cs.cornell.edu/Info/Projects/NuPrl/Intro/intro.html
09:57:35 <Smerdyakov> SamB, LaTeX! :D
09:57:52 <SamB> Smerdyakov: oh, that ;-).
10:02:36 <thebug> not a word processor per se, but extremely nice layout system
11:55:00 <shapr> good morning #haskell!
11:55:16 <Riastradh> It's afternoon here.  Isn't it evening for you?
11:55:25 <shapr> oh, so it is
11:55:26 <cptchaos> good morning 
11:55:28 <tooki> good evening
11:55:34 <Maddas> good night
11:55:47 <Riastradh> Good wee-hours-of-the-morning.
11:56:32 <Smerdyakov> Good God
11:56:52 <ski> good haskell
11:56:52 <Smerdyakov> Who's submitting to POPL here?
11:57:26 <shapr> I will not submit to anyone!
11:58:12 <Riastradh> Bow before me, shapr!!
11:59:45 <SyntaxNinja> hi shapr
12:06:01 <shapr> y0 SyntaxNinja, wassup?
12:07:33 <Gowilla> smerdy: someone in our group is, but not me
12:07:49 <Gowilla> sorry, auto-complete not behaving as expected
12:08:45 <Smerdyakov> Gowilla, I see you have a tricky new nick!
12:09:36 <ski> what happened to the Milne Monster ?
12:13:39 <SyntaxNinja> shapr: nomuch. my laptop is broken ATM, but gateway is all over it.
12:13:49 <SyntaxNinja> gotta get X working on that sparc of mine again :)
12:13:56 <shapr> you have a sparc at home?
12:14:45 <ski> hi shapr
12:15:11 <SyntaxNinja> shapr: yeah, sun blade 100. Igloo and jaffacake were using it recently to figure out some sparc GHC problems.
12:15:35 <shapr> hi ski
12:15:40 <shapr> SyntaxNinja: running debian?
12:16:24 <SyntaxNinja> shapr: of course!
12:16:30 <shapr> yay!
12:16:40 <SyntaxNinja> this was my main machine until recently, when I acquired the laptop.
12:16:54 <Igloo> Oh, I didn't realise that
12:16:55 <SyntaxNinja> I think I'm goign to donate it to my church soon.
12:17:03 <shapr> sparc hardware is very reliable stuff
12:17:09 <shapr> (in my experience)
12:17:33 <SyntaxNinja> yeah, my laptop was my reward for finishing apt-secure :)
12:17:41 <Igloo> But modern stuff expensive  :-(
12:18:10 <shapr> yah, I'm looking forward to the Sony/IBM Cell cpu
13:39:55 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]'
13:39:55 --- topic: set by shapr on [Fri Jun 25 02:34:22 2004]
13:40:49 * ski has tried to learn some more category theory, lately
13:40:52 <ski> ty
13:41:14 * esap also :-)
13:41:35 * esap read Lawvere's "Sets for mathematics".
13:42:02 <ski> oh
13:42:10 <ski> me want that book !
13:42:27 <ski> (haven't found it on local library)
13:43:08 <esap> I found it in a local bookstore.
13:43:56 <ski> have browsed forward and back in a topos book by McLarty and a think tome called "Abstract and Concrete categories" (or something alike that)
13:44:03 <esap> It has very good description of how to build set theory based on category theory. Quite nice description of surjections and epimorphisms and that stuff.
13:44:45 <ski> it says Set is a topos with 1 as generator + some more ?
13:45:40 <esap> heh, yea, quite a bit more.
13:46:20 <esap> I liked how it handled inverse images and existential quantification.
13:47:00 <ski> (hmm, s/think/thick/)
13:49:07 <ski> exists x.F = forall o.(forall x.F -> o) -> o   or something alike ??
13:50:18 <esap> no it uses an inference rule: exists_f(A) |-_Y B  ===> A |-_X Bf
13:50:24 <ski> ok
13:50:52 <ski> Y and X ?
13:51:49 <esap> they are just two universes of things.
13:52:46 <ski> objects ?
13:53:49 <esap> Well it uses the set theory foundation, so Bf is a statement about things in X.
13:54:32 <ski> grothendieck universes ?
13:54:42 <esap> At least it doesn't say so :-9
13:54:46 * ski 's just guessing
13:54:51 <Smerdyakov> Universes are overrated.
13:54:51 <ski> heh
13:55:05 * esap suggest everyone buy this book :-)
13:55:54 <esap> http://titles.cambridge.org/catalogue.asp?isbn=0521010608 
13:56:25 <ski> heh
13:57:03 * ski 's been thinking a bit about a category of ZF sets with morphisms that preserve all of the recurisive set structure ..
13:57:06 <esap> It has quite narrow scope though, that is, it tries to describe set theory with category theory, not much more. So not many things about type theory etc.
13:57:14 <ski> ok
13:57:30 <Smerdyakov> Maybe I should learn some category theory some day.
13:58:27 <ski> (but i'm not sure how to formalize what the morphisms should preserve)
13:59:38 <esap> what do you mean by "recursive set structure"? anti-foundation? :-)
13:59:59 <ski> not necessarily
14:00:15 <ski> haven't even considered that axiom yet
14:01:01 <esap> ok, so just the normal hierarchy of sets
14:01:52 <ski> by "recursive set structure" i mean something like : the sets consists of elements, but those elements must also be sets, and so a morphism must preserve all 'deep' structure of a set also
14:03:09 <ski> (i'm trying to formalize an idea i saw in some mailing list archive about cat. theory and ZF ..)
14:03:51 <ski> (not totally sure if i understood that idea correctly, though :), so i'm playing around with my interpretation of it ..)
14:04:09 <esap> The lawvere book had an interesting approach to modelling membership. a \in_A i was defined to be that 1) i is mono 2) there exists a' such that a = i o a'
14:06:08 <esap> Which was pretty surprising for me.
14:06:32 <ski> i've seen that in the McLarty book i'm reading
14:07:11 <ski> (named "Elementary Categories, Elementary Toposes", if i'm not mistaken (don't have it here))
14:10:27 <ski> though the other book i mentioned seems to relativise it a bit by abstracting out monomorphisms out of subobjects and topoi
14:12:35 <ski> (so they get M-subobject, where M is a class of morphisms, e.g. : mono, extremal mono, strong mono, swell mono, m?? mono)
14:13:34 <esap> interesting. What are the restrictions on M? Can it be any class of morphisms or does it have to be some specific kind of class?
14:14:31 <ski> seems they first had a restriction that it should be mono (respectively epi, for quotient object)
14:14:31 <esap> like always a special case of mono?
14:14:42 <esap> right ok.
14:14:42 <ski> but then it says they dropped it
14:15:03 <esap> oh hmm...
14:16:08 <ski> anyway, they say that mono isn't quite right to describe some intuitive 'parts of objects' in e.g. seome topological categories
14:18:08 <esap> I got the feeling from the lawvere's book that injections and surjections seem like special 'multiplicity constraints' [if you know UML :-)], though mono/epi are not quite the same, but close anyway.
14:18:27 * ski doesn't know UML :)
14:19:06 <esap> that is, about counting the number of elements in the domain of a function.
14:19:24 <esap> Of course, that analogy is not applicable in all categories, but anyway.
14:19:44 <ski> oh, those
14:20:42 <ski> epi is not like generalized surjective in all cats, right
14:20:48 <esap> right.
14:21:25 <ski> generalized surjective <-> is a retraction, iirc
14:22:27 <esap> I guess you mean split surjective [at least lawvere uses that term].
14:22:48 <esap> means that there exists a section
14:23:20 <ski> yeah
14:23:41 <ski> though, i'd like to know where the word 'split' comes from ..
14:23:46 <ski> do you know ?
14:25:15 <esap> well in split injection, lawvere says: "such a mapping r is also sometimes called a "splitting for i" instead of "retraction for i" or "left-inverse for i".
14:25:43 <ski> aha
14:26:13 <esap> I don't know why one would call retractions like that :-)
14:26:36 <ski> so it's 'split' because of the retraction-section pair, and surjection/epi (resp. injection/mono) because that it is epi (resp. mono)
14:27:08 <esap> ok seems reasonable assumption.
14:27:45 <esap> meaning it's due to the mono/epi factorization.
14:28:43 <ski> thought it might be that ..
14:31:45 <shapr> y0 asmodai, wassup?
14:32:41 <Igloo> Shiny new ghc-cvs is sitting on incoming.debian.org, incidentally
14:34:20 <Marvin--> whee, shiny
14:41:37 <shapr> Igloo: yay!!
14:41:43 <shapr> I'll be able to build minstrel!
14:41:55 <shapr> oh, and I'll be able to play with seafood's PanTHeon
14:41:57 <Igloo> :-)
14:42:01 * shapr hOps happily
14:42:10 <shapr> mmm, new Template Haskell goodies
14:42:15 * Igloo has just done a big refactoring, so I'll be able to add shiny new features soon
14:42:24 <opet> mmmm, shiny
14:44:21 <shapr> oh, I had some ideas for minstrel
14:44:30 <shapr> minor stuff that I can hack in myself
14:44:55 <shapr> have you recorded the refactoring?
14:45:51 <Igloo> I'll just push it through
14:46:59 <Igloo> Done
14:47:44 * shapr pulls
14:47:45 <Igloo> I've also added blurb about modes and states to the webpage (although it's not implemented yet, which is why I hadn't pushed, but it's not particularly important for now  :-)  )
15:02:29 <LittleDan> how does the IO monad keep from breaking referential transparency?
15:06:12 <monotonom> By not providing unsafePerformIO.
15:06:50 <ski> heh :)
15:07:39 <shapr> LittleDan: literally speaking, each IO computation passes around the state of the world explicitly
15:09:16 <ski> maybe one could resemble it to Atlas
15:09:18 <Igloo> It /literally/ passes around the state of the whole world? Gosh, no wonder Haskell programs use more memory than C ones
15:09:22 <Igloo> :-)
15:09:23 * shapr snickers
15:10:36 <LittleDan> but then doesn't it still have a side effect?
15:10:45 <LittleDan> (which is bad, AFAICT)
15:10:58 <ski> it represents/contains an effect
15:11:14 <LittleDan> but then that effect does something to the outside world, I think
15:12:09 <LittleDan> you mean it represents an effect and doesn't actually perform it, but what happens there is irrelavent
15:12:18 <LittleDan> (in the outside world, that is)
15:13:02 <Igloo> LittleDan: If you are happy with a state monad being referentially transparent, then just think of the IO Monad as a state monad
15:13:40 <Igloo> Where the IO primitives are strictly depend on the state
15:13:41 * shapr agrees
15:13:55 <LittleDan> Igloo: I'd be happy with that if I knew what a state monad was...
15:14:04 <ski> LittleDan : have you seen a state monad yet ?
15:14:07 <shapr> have you read the nomaware tutorial?
15:14:31 <LittleDan> sharpr: I'm reading it
15:14:44 <shapr> ok, it'll help.
15:15:57 <LittleDan> "Binding threads a state parameter through the sequence of bound functions so that the same state value is never used twice, giving the illusion of in-place update." what does that mean?
15:17:00 <shapr> think about a pocket calculator that has the MR, M+, etc buttons
15:17:32 <shapr> if you were to write that in Haskell, you'd need to explicitly pass around whatever number is in the Memory
15:17:57 <LittleDan> yeah...
15:18:13 <LittleDan> but how does that create a State monad?
15:18:41 <ski> type State a = Double -> (Double,a)
15:19:03 <shapr> a monad is just {a convention, an idea, a viewpoint} that requires a type and two functions
15:19:19 <ski> m_plus :: Double -> State ()
15:19:23 <shapr> much like object oriented programming is just {a convention, an idea, a viewpoint}
15:19:28 <ski> m_recall :: State Double
15:19:36 <shapr> oh, I like that
15:19:36 <Igloo> You essentially pass a state value to each function, only with the use of an abstract datatype and a couple of helper functions you only allow the state to flow through functions in the right order
15:20:12 <LittleDan> ski: what's Double?
15:20:19 <ski> like Float
15:20:26 <ski> like e.g. 15.234
15:20:39 <Igloo> Double is the type of the state in this case
15:20:41 <ski> i.e. a (decimal) number
15:21:00 <LittleDan> oh, I thought  you were doing state in general, so putting double there confused me
15:21:20 <ski> one can both have generic states and specialized ones
15:21:39 <ski> the IO monad can be seen as a state monad with state specialized to "World" :)
15:22:30 <shapr> LittleDan: the state monad usually acts like a game of marble madness where each ramp/pipe/jump gets to alter what's inside the marble.
15:22:33 <ski> so m_recall is a monadic 'action' (think 'function with effect') that gives you the number stored in the pocket calculators single momory
15:23:20 <ski> shapr : i like that ! :)  like relay race
15:24:13 <ski> LittleDan : you want me to continue explaining m_recall and m_plus ?
15:24:32 * Marvin-- prods shapr
15:24:35 <ski> (hmm s/me/us/ ;))
15:24:55 <LittleDan> ski: yes, I still don't really get it
15:25:23 <shapr> Marvin--: wha?
15:25:32 <Marvin--> shapr: I sent you a /msg :P
15:25:37 <shapr> oh I see
15:26:12 <LittleDan> ski: but by 'effect', what do you mean? not side effect, right?
15:26:51 <shapr> gutenabend cm
15:26:57 <cm> hallo welt!
15:28:32 <ski> LittleDan : more or less like side effect, yes :) depends on how one views it
15:29:47 <ski> so, in this small pocket calculator example, the only state we model is that residing in the single-cell "memory"
15:30:20 <Igloo> LittleDan: It alters the Double being passed around by the State type
15:30:28 <ski> so each operation could potentially read and/or write that memory cell, ok ?
15:30:40 <LittleDan> but then how can you handle the order that it's all being done it? I mean isn't it un predictable when you have lazyness?
15:30:42 <Igloo> But because the State type is abstract you can't get the Double out yourself, you can only use the functions I give you to change it
15:31:21 <ski> LittleDan : the order is explicitely sequentialized in the monad
15:31:26 <cm> shapr: wazza!
15:31:44 <ski> LittleDan : so, we had
15:31:51 <ski> type State a = Double -> (Double,a)
15:31:52 <ski> m_recall :: State Double
15:31:56 <shapr> cm: workin, you?
15:31:57 <ski> that's just
15:32:07 <ski> m_recall :: Double -> (Double,Double)
15:32:09 <Igloo> So as far as you can see, there is a side effect, but that's because you can't see the Double I'm passing around for you
15:32:12 <cm> shapr: experiencing my first firefox crash ;)
15:32:13 <ski> LittleDan : ok ?
15:32:18 <shapr> cm: shocking
15:32:21 <shapr> I had one of those recently
15:32:27 <shapr> er, two actually
15:32:42 <cm> and being annoyed at PHP's unserialize() crashing as well ;)
15:33:22 * Igloo wrote my first PHP program today. I feel so dirty.
15:33:39 <shapr> Igloo: oh, I'm going to try it too....
15:33:45 <shapr> not enough Python jobs around here lately :-/
15:33:47 <cm> tua culpa
15:33:59 <shapr> :-P
15:34:01 <shapr> I know
15:34:23 <ski> LittleDan : something of type  State a  is a something that takes the current state of the memory cell as input, and returns as output the next memory state, + some extra value of type  a  that can depend on the input state
15:35:38 <ski> LittleDan : do you follow ?
15:42:35 <LittleDan> I still don't get how the next value of it is passed around, or is it not passed around?
15:42:56 <LittleDan> does it make a new state?
15:43:01 <shapr> yup
15:43:03 <ski> i'll show how, ok ?
15:43:06 <LittleDan> ok
15:43:14 <ski> type State a = Double -> (Double,a)
15:43:18 <ski> m_recall :: State Double
15:43:25 <ski> i.e.  m_recall :: Double -> (Double,Double)
15:43:43 <ski> LittleDan : you see that those two types are the same ?
15:43:47 <LittleDan> yeah
15:43:55 <ski> so we try to define m_recall
15:43:56 <LittleDan> but I don't get why you defined State that wya
15:44:04 <ski> oh
15:44:24 <Igloo> LittleDan: There is a helper function (>>=) that does the actual state passing
15:44:40 <Igloo> (>>=) :: Monad a => a b -> (b -> a c) -> a c     where a = State in this example
15:45:15 <ski> LittleDan : if you have an action that can affect the memory
15:45:39 <ski> then you can represent that as a function taking the current memory contents into it's next memory contents
15:45:40 <Igloo> And >>= is allowed to see the concrete representation of the type, hence it can see the state and pass it around the right way
15:45:43 <ski> get that ?
15:46:05 <ski> (Igloo : i was thinking of introducing >>= on the way)
15:46:42 <LittleDan> it sets the contents of the memory?
15:46:49 <Igloo> *nod*, fair enough - I'm not sure which approach will make more sense to him, but having two to read can't do any harm  :-)
15:47:12 <Cale> It seems generally easier to understand >>= if you first look at what it does with lists.
15:47:14 <ski> Igloo : haha
15:47:14 <LittleDan> Igloo: I already know a little about >>=, but I don't fully understand it
15:47:32 <ski> Cale : or some other specific example(s)
15:47:39 <Cale> LittleDan: have you read what I put up at UsingMonads?
15:47:55 <LittleDan> Cale: no, is it at the wiki?
15:48:00 <Cale> http://www.haskell.org/hawiki/UsingMonads
15:48:12 <Igloo> In this case it'll be something like     m >>= f = \s -> case m s of (s', x) -> (f x) s'    if that helps at all
15:48:32 <Igloo> Where s and s' are states
15:49:08 <ski> m_recall s0 = (s1,return_value)
15:49:09 <ski>   where
15:49:12 <ski>   s1 = s0
15:49:16 <ski>   return_value = s0
15:49:56 <LittleDan> so isn't that the same as m_recall x = (x,x)?
15:50:11 <LittleDan> how does that recall anything?
15:50:20 <ski> m_recall is a function that takes the current state, s0, and returns a pair of the new state, s1, (which is in this case the same as s0, because m_recall doesn't modify the state)
15:50:42 <LittleDan> ok
15:50:55 <ski> and it also returns a value in the second part, the "return value part" of the pair, namely the state
15:50:58 <ski> it'
15:51:12 <ski> it's that part that easily gotten at, later
15:51:26 <ski> so, in that sense, it 'recalls' the memory
15:51:53 <ski> lets try m_plus
15:52:05 <ski> it should take a number to add into the memory
15:52:25 <ski> and it's only effect is in changing the memory
15:52:39 <ski> i.e. it doesn't have any interesting return value
15:52:45 <LittleDan> m_plus s0 other = (s0, s0+other)?
15:52:49 <ski> so it has type
15:52:54 <LittleDan> no
15:53:00 <ski> m_plus :: Double -> State ()
15:53:05 <ski> which is
15:53:22 <ski> m_plus :: Double -> ( Double -> (Double,()) )
15:53:38 <ski> LittleDan : almost
15:53:48 <ski> m_plus other s0 = ...
15:53:55 <LittleDan> oh
15:54:00 <ski> m_plus other s0 = (...,...)
15:54:17 <ski> the first part should be the new memory/state
15:54:30 <ski> the second part should be the "return value"
15:54:33 <LittleDan> m_plus other s0 = (s0+other, s0)
15:54:41 <ski> which, in this case, is uninteresting
15:54:45 <ski> almost :)
15:54:49 <LittleDan> oh
15:54:50 <LittleDan> oops
15:55:06 <LittleDan> m_plus other s0 = (s0+other, ())
15:55:11 <Cale> well, it could be defined that way
15:55:11 <ski> yes !
15:55:33 <Cale> then you get the old value as the return value of m_plus
15:56:11 <ski> Cale : one could do that, of course. but i don't know of any pocket calculator that does it that way
15:56:19 <Cale> :)
15:56:41 <LittleDan> so you could make a function to set the state like m_set new_state _ = (new_state, ())?
15:56:47 <LittleDan> or is that pointless?
15:57:01 <ski> LittleDan : with your previous version, m_plus would have type   Double -> State Double
15:57:06 <ski> no
15:57:11 <ski> it's not pointless
15:57:19 <ski> only it should be
15:57:30 <ski> (hmm, ignore that, misread)
15:57:34 <LittleDan> because you shouldn't really need to do that?
15:57:59 <ski> that can be a useful thing
15:58:22 <LittleDan> so than how is (>>=) implemented?
15:58:29 <LittleDan> s/than/then/
15:59:02 <ski> lets see if we can make a function that takes two numbers and adds them in order to the memory (without taking the shortcut of adding them together first and then just calling m_plus once :)
15:59:14 <ski> LittleDan : coming to that .. :)
15:59:16 <LittleDan> ok
15:59:22 <LittleDan> what do you mean?
15:59:59 <ski> m_plus_plus :: Double -> Double -> State ()
16:00:12 <LittleDan> which state is being set? the first or teh second?
16:00:32 <LittleDan> is it like m_plus_plus x y = (x+y, ())
16:00:47 <ski> it should take two numbers, first add the first number to the memory (using m_plus), then add the second number to the memory (also using m_plus)
16:01:05 <ski> it's like
16:01:18 <ski> m_plus_plus x y s0 = ((s0+x)+y,())
16:01:36 <ski> only we should call m_plus instead of modifying the state directly
16:01:40 <ski> ok ?
16:01:44 <LittleDan> oh, I keep messing up how many args it should take by the type signature
16:01:50 <LittleDan> yeah
16:01:51 <ski> np :)
16:01:56 <ski> so we have
16:02:03 <ski> m_plus_plus x y s0 = ...
16:02:32 <ski> so if we pass x and s0 to m_plus, we get a new memory state
16:02:34 <ski> right ?
16:02:47 <ski> i.e. we should call  m_plus x s0  somewhere
16:03:02 <LittleDan> yeah
16:03:16 <LittleDan> but how does that affect the original thing?
16:03:24 <ski> and that will return a pair of the new state and an uninteresting return-value
16:03:33 <LittleDan> yeah
16:03:43 <ski> m_plus_plus x y s0 = let (s1,()) = m_plus x s0
16:03:47 <ski>                      in  ...
16:04:01 <ski> ok ?
16:04:10 <LittleDan> should I fill in ...?
16:04:20 <ski> not necessarily :)
16:04:38 <ski> it just represents how far we've gotten :)
16:04:42 <LittleDan> ok
16:05:03 <ski> but you can try if you want. otherwise i'll continue
16:05:04 <ski> ok ?
16:05:25 <LittleDan> you can continue
16:05:36 <ski> :)
16:05:49 <LittleDan> oh, I see where (>>=) comes in, I think
16:06:01 <ski> so this code adds x to the first state and gets the next state
16:06:04 <ski> ok
16:06:06 <LittleDan> yeah
16:06:23 <ski> so the next step is calling m_plus on y and that new state
16:06:28 <ski> m_plus_plus x y s0 = let (s1,()) = m_plus x s0 in
16:06:38 <ski>                      let (s2,()) = m_plus y s1 in
16:06:41 <ski>                      ...
16:07:10 <ski> so we get yet another state, s2
16:07:43 <ski> now, we have added the two numbers into the state, so we'll finish this off by returning that state, and the uninteresting value
16:07:46 <ski> m_plus_plus x y s0 = let (s1,()) = m_plus x s0 in
16:07:48 <ski>                      let (s2,()) = m_plus y s1 in
16:07:58 <ski>                      (s2,())
16:08:04 <ski> do you follow ?
16:08:38 <LittleDan> yeah, but why don't you just do m_plus_plus x y s0 = let (s1, ()) = m_plus x s0 in m_plus y s1
16:08:56 <ski> that is a possible shortcut, yes
16:09:07 <LittleDan> ok
16:09:35 <Cale> It's because he's trying to emphasize certain details. This will look different in a little bit :)
16:09:49 <LittleDan> Cale: ok
16:09:51 <ski> one can use that if the 'return-value' of the last 'action' should be the 'return-value' of the whole function-action we're writing
16:10:20 <LittleDan> which it is, in this case
16:10:28 <ski> right
16:10:57 <ski> but if we wanted to return x*y as 'return-value', it would look like
16:11:02 <ski> m_plus_plus' x y s0 = let (s1,()) = m_plus x s0 in
16:11:07 <ski>                       let (s2,()) = m_plus y s1 in
16:11:15 <ski>                       (s2,x*y)
16:11:32 <ski> m_plus_plus' :: Double -> Double -> State Double
16:11:39 <LittleDan> yeah, but that's pointless...
16:11:48 <ski> for this function, yes
16:11:59 <LittleDan> but in general, no?
16:12:04 <ski> right
16:12:09 <ski> imagine a function
16:12:21 <ski> tick :: State Double
16:12:42 <ski> it increments the memory by 1 and returns the memory contents
16:12:55 <ski> tick s0 = (s0,s0+1)
16:13:21 <ski> (hmm, maybe this wasn't a very good example ..)
16:13:22 <wagle> what is "State" here?
16:13:29 <LittleDan> not tick s0 = (s0+1, s0)
16:13:37 <LittleDan> ?
16:13:42 * wagle jumps in at the last moment
16:13:42 <ski> type State a = Double -> (Double,a)
16:13:53 <ski> LittleDan : you're right, i mistyped :)
16:13:59 <ski> wagle : np
16:14:06 <ski> or
16:14:14 <LittleDan> haven't we already established the type of State?
16:14:17 <ski> tick s0 = (s0+1, s0+1)  -- if one likes that better
16:14:30 <ski> LittleDan : "* wagle jumps in at the last moment"
16:14:37 <wagle> preincrement / postincrement
16:14:42 <ski> right
16:15:05 <ski> well, let's go back to m_plus_plus, 'k ?
16:15:09 <LittleDan> ok
16:15:27 <ski> m_plus_plus x y s0 = let (s1,()) = m_plus x s0 in
16:15:33 <ski>                      let (s2,()) = m_plus y s1 in
16:15:33 <ski>                      (s2,())
16:15:49 <LittleDan> yes
16:15:55 <LittleDan> so...
16:15:58 <ski> so, the tedious part here is in passing around all the states here
16:16:04 <ski> the s0,s1,s2
16:16:32 <ski> imagine we want to m_times a number z in between the two m_plus adds, ok ?
16:16:45 <ski> m_times :: Double -> State ()
16:17:16 <LittleDan> ok
16:17:54 <ski> (so m_times of course multiplies its (first) argument into the state)
16:18:07 <LittleDan> yes
16:18:07 <ski> so we could modify m_plus_plus like this
16:18:24 <ski> m_plus_times_plus x z y s0 = let (s1,()) = m_plus x s0 in
16:18:40 <ski>                              let (s2,()) = m_times z s1 in
16:18:46 <ski>                              let (s2,()) = m_plus y s1 in
16:18:51 <ski>                              (s2,())
16:18:53 <ski> ok ?
16:18:57 <LittleDan> ok
16:19:17 <ski> now look more closely at that ! (there's a bug lurking :)
16:19:26 <wagle> m_plus_plus x y s0 = runState (do { m_plus x ; m_plus y }) s0  --?
16:19:27 <LittleDan> oh, I wasn't really looking
16:19:46 <ski> wagle : something like that, yes
16:20:01 <ski> LittleDan : >;-}
16:20:21 <LittleDan> you did it in the wrong order?
16:20:25 <ski> no
16:20:38 <LittleDan> oh, in the third line, you used s1 instead of s2
16:20:43 <ski> i copied&pasted the original code of m_plus_mplus
16:20:48 <ski> added the z argument
16:20:56 <ski> and added a line for calling m_times
16:21:02 <ski> LittleDan : right
16:21:04 <wagle> why you inlining bind for State?
16:21:28 <ski> wagle : i'm explaining how to invent bind for State )
16:21:40 <wagle> ah..  ok
16:21:45 * wagle trundles off
16:22:03 <ski> so, the second m_plus operation gets the state from *before* the m_times operation
16:22:24 <LittleDan> ski: yeah, and you should really be throwing that away?
16:22:43 <ski> of course ( ;) ) the states should only be used once (and exactly once)
16:23:03 <ski> LittleDan : no.  it's a bug, as i said :)
16:23:29 <LittleDan> ski: I mean you should be throwing the old states away
16:23:39 <ski> no
16:23:58 <ski> the old states should be passed (once) to an operation, and not be used after that
16:24:17 <LittleDan> yeah, "not be used after that", that's waht I mean
16:24:24 <ski> so the corrected version of m_plus_times_mplus is
16:24:28 <ski> m_plus_times_plus x z y s0 = let (s1,()) = m_plus x s0 in
16:24:32 <ski>                              let (s2,()) = m_times z s1 in
16:24:39 <ski>                              let (s3,()) = m_plus y s2 in
16:24:44 <ski>                              (s3,())
16:24:54 <LittleDan> yeah, that's how I would've done it
16:25:29 <ski> so, it'd be nice if we didn't have to invent names for all those states, so that we can mix them up ;)
16:25:34 <LittleDan> could you just introduce bind already?
16:25:38 <LittleDan> sorry to be rude, but
16:25:47 <ski> np
16:25:52 <ski> i'll do it now
16:26:14 <ski> (>>=) :: State a -> (a -> State b) -> State b
16:26:24 <ski> so we'll change m_plus_times_plus to
16:26:43 <ski> m_plus_times_plus x z y = m_plus  x >>= \() ->
16:26:52 <ski>                           m_times z >>= \() ->
16:27:05 <ski>                           m_plus  y >>= \() ->
16:27:12 <ski>                           return ()
16:27:16 <ski> with return being
16:27:21 <ski> return :: a -> State a
16:27:29 <ski> return a s0 = (s0,a)
16:28:03 <ski> in this case, all of the actions return just (), but in other cases we could use variable names there instead
16:28:22 <LittleDan> so the State is passed around implicitly?
16:28:22 <ski> do you follow ?
16:28:29 <LittleDan> yeah
16:28:30 <ski> yeah
16:29:17 <ski> so >>= takes an action to perform on the left, passing the result of that into the lambda, and implicitely passing the state on to the part to the right
16:29:23 <LittleDan> ok
16:29:41 <LittleDan> so how is it implemented?
16:29:50 <ski> (s_sa >>= a_s_sb) s0 = ...
16:30:24 <ski> >>= returns a new action, so that one must get it's initial state, s0, before we can do anything
16:30:49 <LittleDan> what's an action?
16:30:53 <ski> s_sa is the action of type  State a  i.e.  Double -> (Double,a)
16:31:29 <LittleDan> oh
16:31:33 <ski> if m is a monad type (constructor), then a value of type  m a  , is called an action of that monad
16:32:01 <LittleDan> ok
16:32:03 <ski> a_s_sb is the function taking a  b  into an action of type  State b  i.e.  Double -> (Double,b)
16:32:20 <ski> so first we pass the initial state to the first action
16:32:33 <ski> (s_sa >>= a_s_sb) s0 = let (s1,b) = s_sa s0 in
16:32:36 <ski>                        ...
16:32:48 <ski> hmm
16:32:52 <ski> (s_sa >>= a_s_sb) s0 = let (s1,a) = s_sa s0 in
16:32:54 <ski>                        ...
16:33:08 <ski> (the first action produces an 'a')
16:33:16 <ski> ok, so far ?
16:33:22 <LittleDan> yeah
16:33:34 <LittleDan> just calculate the result of the first action
16:33:55 <ski> then we pass a to the function, and that gives us a function taking the next state
16:33:57 <ski> (s_sa >>= a_s_sb) s0 = let (s1,a) = s_sa s0 in
16:34:11 <ski>                        let (s2,b) = a_s_sb a s1 in
16:34:14 <ski>                        ...
16:34:29 <ski> got that ?
16:34:38 <LittleDan> yrsh
16:34:42 <LittleDan> oops
16:34:44 <LittleDan> yeah
16:34:58 <ski> the last part is obvious, right ? :)
16:35:25 <LittleDan> (s2, b)?
16:35:30 <ski> yes
16:35:41 <ski> so, in this case we can simplify as before
16:35:45 <ski> (s_sa >>= a_s_sb) s0 = let (s1,a) = s_sa s0 in
16:35:50 <ski>                        a_s_sb a s1
16:36:23 <ski> ok ?
16:36:31 <LittleDan> ok
16:37:12 <LittleDan> so then how is >>= generalized to other monads?
16:38:28 <LittleDan> it's not all implicitly passing around states, is it?
16:38:35 <ski> right
16:39:02 <ski> if you want, we can see how >>= expands in m_plus_times_plus or m_plus_plus
16:39:09 <LittleDan> no, I think I get it
16:39:11 <ski> or we could look at e.g. the list monad
16:39:14 <LittleDan> you're great at explaining things
16:39:19 <ski> ty
16:39:19 <LittleDan> yeah, that would help
16:39:33 <Cale> the list monad is my personal favourite
16:39:58 <LittleDan> so it's for nondeterministic computing?
16:40:00 <Cale> because it gives a nice insight into what >>= and return are supposed to do in general
16:40:16 <ski> LittleDan : yes
16:40:29 <Cale> yeah, a function of type a -> [b] is a nondeterministic computation
16:41:22 <LittleDan> Cale: you mean \n -> [1..n] is nondeterministic?
16:41:26 <Riastradh> (Reflect & reify make monadic nondeterministic computation a lot more pleasant!)
16:41:38 <Cale> LittleDan: yes
16:41:39 <ski> (LittleDan : good you told me before of me being too long-winded. i mayhaps sometimes try too hard to make sure people understands ..)
16:41:40 <Riastradh> LittleDan, yes.  It returns n possible results.
16:41:49 <ski> Riastradh : yay!
16:42:04 <Riastradh> ...um, n-1, rather.
16:42:15 <Riastradh> ...er, no, n.
16:42:15 <Cale> no, n :)
16:42:20 <Cale> hehehe
16:42:21 <Riastradh> Damn zero-based brain.
16:42:45 <wagle> length [0..n] == n + 1
16:42:49 <ski> (Riastradh : re mon.refl. i.e)
16:42:52 <Riastradh> Before you say 'uh, that would make it n+1,' my response is already: 'see, all this garbage with one- versus zero-based indexing is confusing!'
16:42:55 * wagle runs
16:42:57 <Cale> In general, I like to think of a monad as a sort of container type.
16:43:34 <Cale> "return :: a -> m a" takes an element, and puts it in a container by itself
16:43:37 * esap likes to think of a monad as an interface to a sort of a container type.
16:43:56 <wagle> does nondeterminism also involve time arrow reversal?
16:44:09 <ski> not that i know of
16:44:23 <Riastradh> ski, what do you mean by 'yay' there?
16:44:32 <Cale> and bind "(>>=) :: m a -> (a -> m b) -> m b" takes a container of a's, and a function from a's to containers of b's, and applies the function to each a, and combines the containers it gets together
16:44:57 <ski> wagle : maybe if you look at it from a certain angle, though (think prolog backtracking)
16:45:02 <Riastradh> Bind/extend is a little harder to understand when explaining monads as container types.
16:45:16 <ski> Riastradh : just expressed that monadic reflection is nice
16:45:20 <Cale> well, not with some examples :)
16:45:21 <Riastradh> ski, ah, OK.
16:45:53 <Cale> lists are a monad, and they illustrate what is going on very clearly
16:46:43 <Cale> [10,20,30] >>= (\x -> [x, x+1, x+2]) = [10,11,12,20,21,22,30,31,32]
16:46:55 <Riastradh> fmap & join usually make a bit more sense at first.
16:47:01 <Cale> that's true :)
16:47:12 <Riastradh> fmap transforms the value in a container with a user-given function.
16:47:16 <Riastradh> @type fmap
16:47:17 <lambdabot> fmap :: forall f b a. (Functor f) => (a -> b) -> f a -> f b
16:47:27 <Cale> every monad is a functor :)
16:47:28 <Riastradh> For example, with lists, fmap is just map.
16:48:08 <Riastradh> fmap (\x -> x + 1) [1,2,3]     --> [2,3,4]
16:48:50 <LittleDan> so then what's its point?
16:49:04 <Cale> Well, fmap is just the general version of map
16:49:08 <esap> fmap (\x -> x + 1) (Just 10) --> Just 11
16:49:09 <Riastradh> map is specific to lists.
16:49:18 <LittleDan> why isnt map generic?
16:49:22 <LittleDan> is fmap slower?
16:49:36 <Cale> not really, it's just a silliness about H98
16:50:05 <ski> (apropos, does anyone know why Functor is not a superclass of Monad ?)
16:50:07 <Cale> Personally, I think that the specific map on lists should be lmap or something, and the general one should be called map
16:50:15 <Riastradh> Join/mu 'combines' a container within a container; it puts all of the auxiliary data that the nested container had along with the auxiliary data that the base container had.  join :: m (m a) -> m a
16:50:16 <Cale> ski: I complain about this as well.
16:50:16 <esap> There are some situations where it's useful that you have a name for the specific version of some generic utilities.
16:50:17 <LittleDan> is there a chance it'll be changed in the next haskell version, whenever that is?
16:50:24 <wagle> i think instance Functor [] where fmap = map
16:50:32 <Riastradh> For example, for the list/nondeterminism monad, join is concat.
16:50:40 <Cale> LittleDan: I hope so - Haskell 1.4 had it right there
16:50:46 <Riastradh> join [[1,2,3], [4,5,6]]     --> [1,2,3,4,5,6]
16:50:56 <ski> esap : agreed
16:51:07 <Cale> join (Just (Just 5)) = 5
16:51:10 <Cale> er
16:51:12 <Cale> Just 5
16:51:13 <Cale> :)
16:51:14 <wagle> Just 5
16:51:17 <Riastradh> Bind/extend is just a combination, then, of fmap & join, and requires no complicated explanation.
16:51:23 <Cale> yeah
16:51:26 <LittleDan> esap: when is that useful?
16:51:31 <Riastradh> m >>= k = join (fmap k m)
16:51:34 <Cale> xs >>= f = join (map f xs)
16:52:38 <ski> LittleDan : it can be helpful if one's writing code that won't be overloaded anyway, and want to make it clear in the code which operation is which
16:52:39 <esap> littledan: when you are composing some generic functions with (.)
16:53:13 <esap> littledan: then sometimes you get ambiguous type variable. In that case, you may want to explicitly specify the types of containers you want to use.
16:53:19 <ski> (especially if one works with multiple monads/monad transformers at the same time)
16:53:22 <wagle> perhasp you should describe what join and fmap are in State
16:53:50 <esap> littledan: and using a specific version of the mapping is often useful and clean way of doing that.
16:53:56 <ski> smap :: (a -> b) -> (State a -> State b)
16:54:03 <LittleDan> esap: you mean so you can skip writing the type signature in making it more specific?
16:54:42 <esap> littledan: yes, sometimes you don't have a good place for the type signature.
16:54:57 <ski> esap : did you mean the type signature of the whole function/action ?  or the type signature/restriction of some local variable/expression
16:55:34 <esap> ski: I mean for some local variable used in a sequence of operations put together with (.).
16:55:50 <esap> ski: say something of the form: show . fmap f . read
16:55:50 <ski> ok
16:56:44 <LittleDan> esap: so what would happen if you did that?
16:57:38 <esap> you get some errors that are due to not specifying a type that is passed through from read to show.
16:57:41 <stepcut> s
16:57:41 <ski> LittleDan : it would have type  String -> String
16:57:45 <stepcut> doh
16:57:58 <ski> so it would know what type it should read and show
16:58:16 <esap> littledan: but if you use show . map f . read, then the type of container is fixed to list, and the type of 'f' had better fix the element type.
16:58:18 <ski> (without some way of restricting the possibilities, i.e.)
16:58:40 <ski> stepcut : why do you keep doing that ?
16:59:39 <esap> littledan: but with just 'fmap', the type of container would never be determined, and the code wouldn't compile.
17:00:44 <LittleDan> esap: what if you made a series of functions that had names like list (:: [a]->[a] = \l -> l) that you could use to make sure things had the right type like show . map f . list . read
17:01:35 <esap> littledan: sure, you can specialize the identity function [there is the asTypeOf that also helps].
17:01:38 <LittleDan> that would be much more general and flexible, wouldn't it?
17:01:43 <ski> @info asTypeOf
17:01:44 <lambdabot> -- asTypeOf is a variable
17:01:44 <lambdabot> asTypeOf :: forall a. a -> a -> a
17:02:35 <LittleDan> so if you have those, why do you need map?
17:02:42 <ski> show . map f . (`asTypeOf` (undefined :: Whatever Something)) . read
17:03:58 <esap> littledan: well I consider use of asTypeOf to be ugly :-) and having to do explicit type annotations within such piece of code is ugly as well. Most code can be written without local type annotations.
17:04:57 <LittleDan> but map is almost like a local type annotation. I agree, asTypeOf is ugly, though
17:04:57 <esap> And often you'd write the specific version of the generic thing already in a separate function.
17:05:29 <esap> At least if it's at all complicated.
17:05:46 <LittleDan> or what if it was the generic version is map and the list version is lmap
17:06:23 <esap> that would be better naming. But you can't really change naming for Prelude.
17:06:51 <ozone> you can if you really want to :)
17:07:02 <ozone> (i posted some code to the haskell list about a week ago which did just that)
17:07:18 <LittleDan> ozone: yeah, but it would be really stupid since it's a minor issue
17:07:25 <esap> heh, right, but that's ugly as well.
17:07:54 <LittleDan> ozone: unless you're changing actual code in the prelude, then you kinda need to do that
17:08:14 <ozone> that was my original goal (changing code)
17:08:38 <LittleDan> oh, sorry
17:08:56 <LittleDan> but changing names in the prelude is still stupid unless you're changing the standard
17:11:35 <LittleDan> ski: so can you tell me about the list monad (unless you don't want to for some reason)
17:12:32 <Cale> LittleDan: you could have a look at UsingMonads on the wiki :)
17:12:58 <LittleDan> ok
17:15:04 <ski> LittleDan : if you want, i can try to explain some of the list monad, yes
17:16:54 <Cale> The whole idea behind bind is "If I give you a box of apples (m a), and for each apple, you give me a box of blueberries (a -> m b), then I can get a box of all the blueberries together (m b)."
17:17:26 <Cale> this is especially true of the list monad :)
17:17:30 <ski> yes
17:20:09 <LittleDan> what does (>>) mean in the context of the list monad?
17:21:09 <shrimpx> do you collect the wood of all the blueberry boxes and build one box of blueberries (m b)? or do you take out the apples from the apple box and put all the blueberries in it? in which case they probably wouldn't fit
17:21:49 <esap> [1,2,3] >> [2,3,4] ===> [2,3,4,2,3,4,2,3,4]
17:22:40 <Cale> it puts a copy of the second list for each thing in the first
17:23:06 <Cale> [1,2,3] >> [2,3,4] = [1,2,3] >>= (\x -> [2,3,4])
17:24:17 <LittleDan> what does the State >>= have to do with the List >>=?
17:25:08 <LittleDan> they seem completely different, apart from the fact that they look good in do syntax
17:27:37 <esap> They both have similar interface, that is, a user of the monad need not know which version [list or state] is actually used. You can write generic code that doesn't need to know the difference between list and state monads. Both (>>=) operations express sequentiality.
17:28:10 <ski> in a certain sense
17:28:26 <LittleDan> could you give an example of generic code for them?
17:28:29 <Cale> a "State a" is like a container which holds an "a" as well.
17:28:33 <esap> With state monad, it's sequentiality of the operations that access the state. With list monad, it's the sequentiality of non-deterministic operations.
17:28:46 <ski> @type sequence
17:28:48 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
17:29:42 <esap> yes, sequence is a good example of a generic operation that works on any monad.
17:31:04 <LittleDan> how is sequence implented?
17:31:17 <LittleDan> or is it monad-specific
17:32:15 <esap> from Prelude: sequence = foldr mcons (return []) where mcons p q = p >>= \x -> q >>= \y -> return (x:y)
17:32:18 <ski> it's generic (over specific versions of return and (>>=))
17:32:44 <ski> sequence [    ] = do return []
17:32:58 <ski> sequence (m:ms) = do a <- m
17:33:07 <ski>                      as <- sequence ms
17:33:11 <ski>                      return (a:as)
17:33:17 <ski> iow
17:33:34 <esap> right, those two implementations are the same.
17:35:27 <LittleDan> is there a difference between do return [] and return []?
17:35:56 <esap> no, the do is not necessary if you have only one action.
17:37:10 <ski> it just looked nicer to indent the two bodies the same
17:37:24 <ski> (imo, of course)
17:38:31 <LittleDan> so for a list of States, it would be like map fst?
17:39:21 <bourbaki> hi
17:39:26 <Lemmih> yo
17:39:27 <esap> hi
17:39:36 <LittleDan> hey
17:39:48 <LittleDan> how's your category theory library going?
17:39:50 <bourbaki> esap got a sec?
17:39:56 <esap> sure
17:40:12 <bourbaki> well i am still working on it all but i make progress
17:44:48 <ski> bourbaki : you're making a cat. theory lib. ?
17:45:33 <bourbaki> well not exactly i just try to connect graphs topologies automatons and category theory somehow
17:46:36 * ski hasn't learned what a topologie is ..
17:47:45 <LittleDan> topology is about studying shapes, I think
17:48:16 <ibid> not really
17:48:21 <ibid> well. really abstract shapes
17:50:07 <LittleDan> still, shapes
17:50:18 <ski> hmm, i thought he was referring to a topologie (which, iirc (which may not be the case :), is not the same as a topology)
17:50:34 <ibid> topology is the abstract study of continuity, unless i remember wrong
17:50:49 <ski> yes
17:50:56 <ibid> but graph topology is different :)
17:50:57 <LittleDan> topologies is the plural of topology
17:51:36 * ski maybe confuses it with some other Big Scary *ie Word of cat. theorists
17:51:55 <Cale> Category theory is used in algebraic topology.
17:52:09 <ski> yes
17:53:04 <ski> it was invented there, iirc
17:53:21 <ski> so what is a graph topology ?
17:54:16 <LittleDan> Am I the only person attempting to learn Haskell who doesn't know category and other advanced fields of mathematics?
17:54:24 <Pseudonym> No, you're not.
17:54:31 <Pseudonym> I didn't know any of this when I learned Haskell.
17:54:55 * ibid still does not know category theory :)
17:55:05 * ski 's only attempting to learn category theory after learning haskell :)
17:55:08 <ibid> although i did major in maths a few years ago
17:55:29 <Smerdyakov> ibid, by accident, right?
17:55:45 * ski laughs
17:55:52 <Pseudonym> I found it helped to know some basic maths to learn functional programming.
17:56:00 <Pseudonym> I mean really basic maths.  Like what is a function.
17:56:12 <Smerdyakov> Pseudonym, that is a deep philosophical question.
17:56:36 <ibid> Smerdyakov: majored in math by accident? no, it was quirte deliberate
17:56:43 * Smerdyakov pulls out a knife to hack a POPL submission closer to the page limit.
17:56:53 <Pseudonym> Haskell, though, has a problem that all programming languages has.
17:57:06 * ibid envies Smerdyakov for having a POPL submission to hack
17:57:10 <Pseudonym> Which is that there's a group of "elites", who all know something that you don't.
17:57:22 <Pseudonym> And they're the ones writing the language definitions and writing papers.
17:57:32 <Pseudonym> The Haskell elite is much, much friendlier than most.
17:57:43 <Pseudonym> The Perl elite and C++ elite are notorious for being snotty.
17:57:49 <Riastradh> And bombastic, and wrong.
17:57:55 <LittleDan> before learning haskell, I thought all haskell programmers were in the elite group
17:58:09 <Pseudonym> LittleDan: A few hours here should cure you of that misconception.
17:58:16 <ibid> by some counts, we have a C++ elite member (at least former one) as a faculty member here
17:58:38 <Pseudonym> Which one?
17:58:46 <ibid> sakkinen
17:58:51 <Pseudonym> Ah, cool.
17:58:55 <ibid> you know him?
17:59:05 <Pseudonym> Only by reputation.
17:59:14 <Pseudonym> I used to have the desk next to Fergus Henderson, of course.
17:59:19 <ibid> heh :)
17:59:32 <LittleDan> It seems like better programming languages have better elite groups, doesn' it
17:59:47 <Pseudonym> It could be a function of how big the community is.
18:00:15 <Pseudonym> A lot of people use C++.  By Sturgeon's law, there necessarily must be a LOT of crap in the C++ community.
18:00:22 <ibid> heh
18:00:26 <LittleDan> not necessarily. Python has a pretty good elite group, but it's a big community (it's also a bad language, though)
18:00:30 <Pseudonym> Which means that the elites are possibly _correctly_ bombastic a lot of the time.
18:00:34 <Smerdyakov> ibid, why envy? You could write something to submit, too!
18:01:14 <ibid> Smerdyakov: i'm currently immersing myself with self-pity over the fact that my papers suck
18:01:29 <Pseudonym> I think it helps that most of the Haskell elites are academics, and academics like to teach.  (On the whole.)
18:01:31 <ibid> where is POPL this time?
18:01:52 * esap has also tried writing a paper with bad results. I wouldn't dare to show them to anybody because they're so bad :-)
18:01:52 <Smerdyakov> Los Angeles
18:01:57 <ibid> oh, ok, no go then :
18:01:58 <ibid> )
18:02:06 <Pseudonym> I have to wonder, sometimes, if the C++ elites actually write any code, or if they just write books.
18:02:24 <Smerdyakov> ibid, esap, it's amazing what working with other people can do to the quality of papers. :)
18:02:32 <ibid> when sakkinen wrote his phd he had a strong industrial background
18:02:40 <LittleDan> they write some inscrutable theoretical code, but they're probably not involved in any big projects
18:02:44 <ibid> Smerdyakov: yeah
18:02:44 <esap> I think at least some of the C++ elite use time to attend the standardization meetings [which takes lots of time, I guess]
18:02:46 <Pseudonym> Yes, but does he write code any more?
18:03:02 <ibid> Pseudonym: i don't know, really
18:03:07 <Pseudonym> Right, that's the thing.
18:03:40 <ibid> Pseudonym: he was on leave for some years, at least some of the time was spent in a industry-funded research project focusing on testing
18:03:42 <Pseudonym> Apart from boost, I suppose.  That counts as "code".
18:03:52 <Pseudonym> I dunno if Sakkinen has contributed to that.
18:04:09 <Pseudonym> Oh, unrelated topic.
18:04:16 <ibid> Pseudonym: but i don't know about writing code, but then again, he has not been very active in the c++ paper scene for years
18:04:16 <Pseudonym> My 2.5-year-old daughter is learning to read.
18:04:26 <LittleDan> wow
18:04:35 <Pseudonym> She's discovered that to "read", you spell out the letters one by one, and then say what the picture above the word is.
18:04:39 * esap hasn't been active in C++ scene also in about three years or so
18:04:47 <ibid> Pseudonym: heh :)
18:04:50 <Pseudonym> I was wearing a certain t-shirt about a month ago.
18:05:03 <Pseudonym> And she "read" it: P... E... R... L... Camel!
18:05:18 <ibid> you english types have a hard time learning to read
18:05:22 <Riastradh> The C++ scene is actively repulsive.
18:05:26 <LittleDan> go easy on her; I didn't know how to read until I was 4
18:05:39 <esap> riastradh: hmm.. why is that?
18:05:46 <ibid> spelling out letters one by one seems so quaint to me :)
18:05:46 <Pseudonym> I'm going very easy on her.  Trouble is, she wants to read like she's on a mission.
18:05:55 <Riastradh> esap, oh, just making a silly pun on your statement.
18:06:05 * ibid read jerry cottons before i knew how to read
18:06:20 <Riastradh> Pseudonym, give her _War & Peace_.
18:06:22 <Pseudonym> I was an early reader.  I read my first item in public at the age of 3.5.
18:06:47 <ibid> i think i learned to read from the milk cartons
18:06:56 <Pseudonym> Actually, I think I might give her "Concrete Mathematics".
18:07:08 <ibid> somehow i'm convinced i knew how to read when i was four
18:07:17 <ski> Pseudonym : have a link ?
18:07:19 <ibid> i have no idea where i know that from
18:07:23 <Pseudonym> ski: ?
18:07:43 <LittleDan> ski: you mean for the book?
18:07:52 <Pseudonym> ski: http://www-cs-faculty.stanford.edu/~knuth/gkp.html
18:07:57 <Pseudonym> If that's what you meant.
18:07:57 <ibid> concrete math is quite fun, especially if you neglect to read the boring main text :)
18:08:05 <Pseudonym> ibid: Yes!
18:08:12 <Pseudonym> Oh, the marginal notes are the best bit.
18:08:23 <ibid> i bought my copy because of them
18:08:32 <esap> ibid: "boring main text", heh.
18:08:42 <Pseudonym> It was based on a course that Knuth et al taught at Stanford.  And they let the students write annotations, which ended up in the book.
18:08:48 <Pseudonym> The annotations are priceless.
18:09:14 <esap> I wouldn't call the main text bad either.
18:09:23 <ibid> Pseudonym: i think my copy had a price, a rather dear one too
18:09:25 <ski> Pseudonym,LittleDan : yeah
18:09:49 <ibid> yeah, the main text is good too, but not as much fun
18:10:34 <LittleDan> when I was little, I always found those "see spot run" books really condecending. Is that the stuff you're having your daughter read?
18:10:57 <ibid> i have no idea what's a "see spot run" book
18:11:12 <Pseudonym> She's only 2.5.  She's still on single words.
18:11:12 <ibid> i enjoyed some children's literature when i was little
18:11:22 <Pseudonym> Needs some vocabulary before we move to sentences.
18:11:32 <LittleDan> ibid: see spot run. Spot runs fast. Run spot run
18:11:37 <ibid> ah
18:11:54 <LittleDan> Pseudonym: oh
18:11:54 <ibid> yeah, that's bad with english, you cannot jump from words to sentences overnight
18:12:13 <LittleDan> ibid: and you can in other languages?
18:12:24 <Pseudonym> Most kids don't learn to read until they're 4-5, so I'm in no hurry.
18:12:32 <LittleDan> you shouldn't be
18:12:36 <ibid> LittleDan: well, assuming that the reader can grasp sentences when spoken...
18:12:54 <LittleDan> I mean you shouldn't be in a hurry, not you shouldn't be in no hurry
18:14:03 <ibid> of course, i have no real knowledge about how children learn
18:14:37 <LittleDan> I am a child, so I have some vague knowledge...
18:14:50 <ski> (see jack drive, drive jack drive .. :)
18:15:34 <ibid> it just seems bad about english that you essentially have to treat each word as a unit, it cannot be deduced from the letters (at least in the one or two-syllable cases)
18:16:12 <Pseudonym> ibid: Are you referring to pronunciation or semantics?
18:16:23 <Pseudonym> If it's semantics, then all languages have that problem.
18:16:45 <Pseudonym> And I might add that French has the opposite pronunciation problem.
18:17:07 <ibid> pronunciation, more or less
18:17:18 <ibid> i mean, the connection between the written word and the spoken word
18:17:36 * esap probably couldn't pronounce half of what I write in English.
18:17:38 <Pseudonym> In French, you can't determine the letters from the pronounced word.
18:17:47 <Pseudonym> Because half the word isn't pronounced at all. :-)
18:17:59 <esap> heh :-)
18:18:02 <LittleDan> Pseudonym: you can still deduce it
18:18:06 <ibid> i assume that most kids have a decent spoken vocabulary by the time they learn to read
18:18:23 <Pseudonym> You'd think so.  Not in this kid's case.
18:18:29 <ibid> Pseudonym: i believe the problem in both languages is two-way
18:18:34 <ibid> Pseudonym: yeah, the age explains it
18:18:35 <LittleDan> ibid: I didn't
18:18:47 <Igloo> esap: Do you think that's normal?
18:18:57 <Pseudonym> She has a spoken vocabulary of about 20-40 words, but a reading vocabulary of about 15-20.
18:19:08 <ibid> do those sets of words intersect? :)
18:19:13 <Pseudonym> Yes!
18:19:21 <ibid> is one a subset of the other?
18:19:28 <ibid> or mostly so
18:19:30 <LittleDan> that's really good if she can read 2/3 of what she can say at the age of 2
18:19:30 <Pseudonym> I believe so.
18:19:40 <Pseudonym> One word, for example, is "pizza".
18:19:47 <Pseudonym> That's a very distinctive word when you look at it.
18:19:49 <Igloo> That's a good word to start on
18:19:52 <esap> igloo: Well yes, for a non-native speaker, I'd expect my pronouciation is somewhat off :-)
18:19:52 <Pseudonym> I agree.
18:19:55 <Pseudonym> Much better than "Perl".
18:20:09 <Smerdyakov> Pseudonym, are you raising your poor defenseless children on dairy products?
18:20:24 <Pseudonym> Smerdyakov: Partly.
18:20:32 <ibid> esap: it sometimes happened to me that i suddenly realize that a written word and a spoken word (in english) are actually the same
18:20:38 <Pseudonym> Is breast milk a dairy product?
18:20:45 <ibid> i think, vehicle was one such case
18:20:51 <Smerdyakov> Pseudonym, that depends on your wife.
18:21:08 <Pseudonym> She is American, which does count as human IMO.
18:21:23 <Igloo> OK. My impression is that English speakers do quite well at pronouncing other languages correctly (modulo accent and inability to make some sounds), but English is particularly bad in this regard of course
18:21:38 <Igloo> s/other languages/other languages they have learnt/
18:21:41 <Pseudonym> That's because English is a bastard child of other languages.
18:21:53 <Pseudonym> You need to learn how to do that just to learn English.
18:21:55 <ibid> Pseudonym: not really; only of certain other languages
18:21:56 <Igloo> But that should work either way
18:22:12 <Pseudonym> ibid: German, French and Greek, mostly.
18:22:58 <esap> igloo: another thing is, I've mostly learned English from reading and writing articles to usenet. Not probably the best place to learn pronounciation.
18:23:04 <ibid> Pseudonym: well, greek, latin, and old german...
18:23:04 <LittleDan> Pseudonym: English doesn't have half of french's sounds
18:23:11 <Riastradh> English doesn't just 'borrow' from other languages.  It follows them into dark alleys, beats them up, and goes through their pockets for loose words & grammar.
18:23:31 <Pseudonym> That's true, but remember that French was the major language in Britain during the middle ages.
18:23:39 <ibid> i doubt knowing english is of particular help when you learn finnish
18:23:42 <Igloo> Ah, OK, I assumed you started from a school education
18:23:53 <Pseudonym> Old French, admittedly.
18:23:55 * esap did start from school education.
18:24:08 <esap> igloo: but most of english I've still learned from usenet.
18:24:14 <Igloo> Oh...well I'd expect that to cover most of the prononciation stuff
18:24:22 <ibid> i learnt my english from star trek :)
18:24:31 <Igloo> I guess you never hear how ambiguities resolve for new words, though
18:24:48 <Igloo> Yeah, fair enough
18:24:53 <ibid> and the rest i learned from usenet
18:25:12 <ibid> school english helped shape up my grammar
18:25:25 <LittleDan> ibid: English and Finnish are both Germanic languages, so I'd think it would help to know English
18:25:25 <ibid> which irc is quickly destroying :)
18:25:30 <ibid> LittleDan: not true
18:25:39 <ibid> LittleDan: finnish is not germanic
18:25:55 <ibid> LittleDan: finnish is uralic, fenno-ugric more precisely
18:25:58 <Igloo> Of course, English speakers disagree on the pronounciation of a reasonable percentage of words anyway  :-)
18:26:17 <LittleDan> ibid: oh, I was thinking of scandanavian languages
18:26:25 <ibid> LittleDan: yeah, finnish is not one of those :)
18:26:26 <Igloo> ibid: Grammar is /so/ 20th century  :-)
18:26:32 <ibid> Igloo: heh
18:26:58 <ski> which languages are 'agglutinating' ?
18:27:03 <ibid> finland is not part of scandinavia, either
18:27:20 <ibid> though many people, even finns, make the mistake of believing otherwise
18:27:27 <LittleDan> ski: I think Esperanto, German, and Latin
18:27:39 <ski> and finnish ??
18:27:40 * Igloo reads "there aren't any 32bit apps in Debian" in the Debian flamewar and wonders if he should bring up nhc98 or just keep quiet at the back  :-)
18:27:47 <ibid> that's why we prefer "nordic" instead of "scandinavian" here :)
18:27:53 <LittleDan> ski: maybe, I don't know finish
18:28:01 <ski> esap : ?
18:28:08 <ibid> Igloo: how hard would it be to make a 64-bit port?
18:28:16 <Pseudonym> Igloo: It's bad luck to get involved in a Debian flamewar.
18:28:26 <Igloo> ibid: No idea. Send me the patch when you're done  :-)
18:28:35 <ibid> Pseudonym: no, one does it quite deliberately :)
18:28:39 <Pseudonym> It's kind of like getting invited to a family reunion on Jerry Psringer.
18:28:43 * esap is having trouble determining which question ski just asked :-)
18:28:45 <Pseudonym> Springer
18:28:45 <Igloo> It's hard enough that someone who actually looked at doing it a while ago didn't
18:28:47 <Pseudonym> Just don't do it.
18:29:01 <Riastradh> Pseudonym, funny thing about that 'Psringer.'
18:29:16 <ibid> Igloo: i have enough projects for this vacation, thanks anyway :)
18:29:33 <ibid> funny, springer said alone makes me think of lncs
18:29:39 <Riastradh> When I was very young, I did that _all_ the time: reverse a sequence of S & consonant.
18:29:41 <esap> ski: oh the agglutinating thing, yes, finnish does that as well.
18:30:18 <LittleDan> is agglutinating where you squish the words together or where you squish them together and change them slightly?
18:30:23 * esap thinks based on reading the description on what 'agglutinating' means :-)
18:30:24 <Igloo> I suddenly started typoing tion as tino a couple of years ago
18:30:24 <Riastradh> 'Psrayer,' 'psoon,' et cetera.
18:30:34 * esap just loves 'wordnet'.
18:30:45 <ibid> LittleDan: i think it's where you add suffixes to words and don't use that many prepositions :)
18:31:01 <Riastradh> And I was very consistent.  But at some point it just stopped.
18:31:57 <Taaus> Riastradh: Stopped? Or tsopped? :)
18:32:12 <ski> esap : ok
18:32:13 <Riastradh> Well, that depends on whether it was an inclusive or exclusive tsop.
18:32:16 <Riastradh> ...stop...
18:32:22 * Riastradh
18:32:24 <Riastradh> Er.
18:32:33 <Igloo> Ria: Was this typing or writing or both?
18:32:45 <Riastradh> Igloo, this was before I could read or write.
18:32:54 * ski confuses agglutinating and non-agglutinating with each other, not knowing which is which
18:32:58 <Igloo> Ah
18:33:25 <Riastradh> (_Very_ young.)
18:34:57 <Pseudonym> I think Englishlanguage should have agglutinationwords.
18:35:09 <Pseudonym> It makes commonsense.
18:35:29 * ski 's leaving
18:35:37 <ski> bye all
18:35:42 <Pseudonym> Night
18:35:46 <Pseudonym> Or whatever
18:35:46 <esap> night
18:35:59 * Pseudonym should have checked ski's local time before saying "night"
18:36:23 <Pseudonym> Oooh, spam subject line of the week!
18:36:40 <LittleDan> what?
18:36:49 <Pseudonym> You know how they add random words to the end of subject lines sometimes?
18:37:03 <Pseudonym> Well in this one, the main part was: "Now you can have her"
18:37:10 <Pseudonym> And the random word they added: "retch"
18:37:56 <Pseudonym> On the whole, probably not the impression they were trying to give.
18:38:06 <LittleDan> :)
18:38:37 <ibid> hoho, a package "experienced copyright issues" ;)
18:38:59 <esap> package?
18:39:06 <esap> which package?
18:39:10 <ibid> stellarium
18:39:15 <ibid> quoting from a mail
18:39:21 <ibid> to debian-devel
18:39:41 <ibid> >> The package stellarium disapeared from the debian packages since it experienced copyright issues. Those problems are now perfectly fixed and this package needs to be re-made but there are no more packager on it apparently.
18:40:38 <Pseudonym> It still needs some therapy to deal with its issues.
18:40:48 <ibid> :)
18:41:41 <LittleDan> I like debian, but why do they have to be so touchy about copyright?
18:42:06 <Igloo> Because that's the raison d'etre
18:42:10 <ibid> because that's the world we live in
18:42:56 <ibid> LittleDan: what do you mean by "touchy about copyright", exactly?
18:43:08 <Pseudonym> There's something to be set for just getting on and writing code.
18:43:16 <Pseudonym> The thing is, _someone_ has to care about this stuff.
18:44:08 <LittleDan> ibid: they remove things for licencing issues even when they don't really have to
18:44:09 <Igloo> Debian isn't about writing code, though. It's about collecting OS code other people have written into one lovely bundle of loveliness.
18:44:20 <Pseudonym> The FSF, Debian and so on do the rest of us a big favour.
18:44:30 <ibid> the problem is that if we are not careful about copyright (and, unfortunately, most fs developers seem not be), we could easily be undone by another sco
18:44:37 <Pseudonym> They care about the legal issues and we write code.
18:44:43 <ibid> LittleDan: debian does not do that
18:44:57 <ibid> LittleDan: packages are removed for licensing reasons only when necessary
18:45:07 <esap> littleDan: The reason is, if there were some unclarities with the licenses, or something that's not simple from licensing point of view, then it would be a problem for many of Debian's users.
18:45:10 <ibid> the thing is, your definition of "necessary" may differ :)
18:45:42 <Pseudonym> Right.  Debian's POV is that it's "necessary" if they can't prove beyond reasonable doubt that it's legal to distribute.
18:45:56 <ibid> yeah
18:46:46 <ibid> i think it has its roots in the fact that (almost) nothing is implicitly allowed
18:46:59 <Pseudonym> Right.  Fair use, that's about it.
18:47:06 <ibid> and then as experience grows, the attitude extends itself
18:47:45 <ibid> i suppose one could make the case that it's not "necessary" to remove stuff until a "cease & desist" letter arrives
18:47:57 <ibid> but debian does not take that stance
18:48:26 <Igloo> I don't think the UK for one even has fair use
18:48:33 <ibid> it opens us susceptible for malicious ligitation
18:48:39 <Igloo> But I get easily confused about such things
18:48:53 <ibid> Igloo: most countries have some exceptions, but i think very few call it "fair use"
18:49:43 <ibid> exceptions such as copying is allowed from a legitimely obtained copy for the individual's private (not business) use
18:50:15 <ibid> there is an counter-exception to that for software, at least in finland
18:58:01 <Pseudonym> Commentary, review and criticism are the most common fair use provisions.
18:58:35 <ibid> yeah
18:58:50 <Pseudonym> Also parody.
18:59:04 <ibid> well, those are the us fair use provisions
18:59:18 <ibid> it differs from jurisdiction to jurisdiction
18:59:21 <Pseudonym> No, the US has even more.
18:59:27 <Pseudonym> These are the most common ones.
18:59:40 <Pseudonym> The US has provisions to protect journalists, too.
19:04:03 <ibid> finnish law has a rule that allows journalistic publications to quote other journalistic publications about current topics
19:05:45 <Igloo> I always wondered about that - do you have to to anything to be covered by "Freedom of the press"?
19:06:09 <ibid> i can't quite parse tha
19:06:12 <ibid> +t
19:06:22 <Igloo> s/to to/to do/
19:06:25 <Igloo> Does that help?
19:06:58 <ibid> in finland, your publication has to fit a certain definition
19:07:03 <ibid> but it's fairly broad
19:07:29 <Igloo> I'm talking about what Pseudonym said really
19:07:52 <ibid> i suppose you just have to fit some definition
19:07:59 <ibid> assert your journalistic rights
19:08:09 <ibid> and see if the courts agree, if necessary :
19:08:11 <ibid> :)
19:09:25 <Igloo> Three cheers for bugs in my program being fixed by upgrading random packages!
19:09:30 <ibid> heh
19:10:33 <ibid> apt-get upgrade /dev/random? :)
19:11:44 <Igloo> :-)
19:21:03 <Igloo> Anyone know if J http://jsoftware.com/ is interesting?
19:21:33 <esap> is that the same J that is somehow related to COBOL? :-)
19:21:46 <Igloo> No idea
19:22:34 <Igloo> But less than half way through http://jsoftware.com/labs/taste1.htm and the syntax is scaring me
19:22:54 <Cale> I think it's a newer APL without the funny symbols.
19:23:15 <esap> oh maybe it was APL and not COBOL, one of the very old languages anyway
19:24:32 <Igloo> It looks like a grea language for one-liners, once you've remembered what everything does
19:24:43 * Igloo closes the window  :-)
19:26:26 <esap> the examples on the papers section are even more obscure, looks like obfuscated C :-9
19:26:40 <Cale> The equivalent of an obfuscation contest for J would probably be to lean the other way and try to produce code that was actually readable, against all odds.
19:26:48 <Igloo> :-)
19:27:25 <Igloo> Working with darcs repos is nice. It keeps sending me mails saying it's applied my patches, which gives me a warm fuzzy feeling inside.
19:27:37 <esap> there is a publication with the name "J for the APL programmer". APL
19:30:50 <Pseudonym> Unbelievable!
19:31:14 <Pseudonym> Just looking through the code of our $30k-a-pop flagship product.
19:31:25 <Pseudonym> Someone didn't check the return value of malloc().
19:31:33 <Pseudonym> That's like a first year mistake.
19:32:27 <esap> the correct solution is not to use malloc :-)
19:32:32 <Pseudonym> Agreed.
19:32:40 <Pseudonym> This is C++ code.  malloc() is inexcusable.
19:32:59 <Pseudonym> free() is excusable if you're unfortunate enough to have to use code which malloc()s stuff.
19:33:06 <Pseudonym> e.g. tmpnam()
19:34:12 <esap> In C++, the problem has been shifted to uses of ::operator new.
19:34:13 <ibid> malloc may be excusable if you are writing a custom allocator
19:34:28 <Pseudonym> Even then, using new char[size] is better.
19:34:46 <ibid> Pseudonym: that will initialize the memory
19:34:50 <Pseudonym> esap: Ah, but in C++, you don't have to check the return value of ::operator new.
19:34:53 <ibid> not always a good idea
19:35:05 <ibid> if you are doing an allocator, that is
19:35:07 <Pseudonym> It throws an exception, which is much better.
19:35:09 <Pseudonym> Hmmm.
19:35:12 <Pseudonym> That's a good point.
19:35:39 <ibid> of course, i'd probably using anon mmap instead of malloc :)
19:35:43 <Pseudonym> Right.
19:36:03 <Pseudonym> For a custom allocator, that's usually the right thing.
19:36:14 <Pseudonym> Because you usually want a lot of memory at once.
19:36:52 <ibid> but there may be special circumstances where you cannot rely on anon mmap working
19:37:13 <Pseudonym> Right.
19:37:13 <esap> ah of course, I'm remembering CFront :-) I mean the nothrow version of operator new :-)
19:39:23 <esap> though you normally don't need to check that either.
19:39:31 <Riastradh> What product is that, Pseudonym?
19:40:14 <Pseudonym> http://www.teratext.com/get/page/browser/browser?category=Products/TeraText%20DBS
19:40:16 <Pseudonym> That one.
19:57:43 <Pseudonym> As a matter of fact, this code _is_ a custom allocator.
19:57:48 <Pseudonym> So I feel better about the malloc().
20:27:34 <loopy_666> anyone know of a russian room?
20:30:20 <Riastradh> A Russian room?
20:37:26 <loopy_666> yes Russian
20:38:31 <loopy_666> know of any?
20:38:35 <loopy_666> or no
20:39:15 <Riastradh> It might help to clarify what you mean by 'a Russian room' and explain what this has to do with Haskell.
20:39:46 <loopy_666> uh ok
20:41:10 <loopy_666> I need a real Russian to translate sumthing for me and i cant find one
20:41:17 <loopy_666> its really irrating me
20:41:49 <Cale> A Russian Haskell user?
20:42:15 <loopy_666> im not russian im german looking for a russian
20:42:25 <Riastradh> What does this have to do with Haskell?
20:42:46 <loopy_666> WTF is haskell?
20:43:19 <Riastradh> A non-strict functional programming language.  http://www.haskell.org/
20:43:21 <sazzle> perhaps there's a reason why his nick is 'loopy'
20:43:27 <loopy_666> 0421043c0435043d0438043b0441044f 04340438043704300439043d 04410430043904420430 -=0414044004300439043204350440.New=- 0438 043f043504400435044004300431043e04420430043d 0434043204380436043e043a, 04420435043f04350440044c 043204410435 044004300431043e0442043004350442 0433043e0440043004370434043e 0431044b04410442044004350439!!! this is what i want translat
20:43:42 <Cale> loopy_666: this channel is about Haskell
20:43:55 <Pseudonym> loopy, is there a reason you chose here to ask?
20:44:39 <loopy_666> yes
20:44:39 <Cale> Haskell is a programming language. Not like Russian, which is a human language.
20:44:44 <loopy_666> because i want to
20:45:04 <Cale> Channels on freenode are generally topic-directed.
20:45:28 <loopy_666> well thats fucked uh
20:45:50 <Cale> You might do better with another IRC server if you like offtopic discussion. :)
20:45:57 <loopy_666> The Europian people are fucking funny as hell
20:46:48 <loopy_666> what the hell is haskell i still dont know 
20:50:07 <Pseudonym> I didn't know there was anyone here from Europa.
20:51:09 <monotonom> Americans are retarded.
20:51:25 <Pseudonym> Sturgeon's law.
20:51:36 <Pseudonym> There are 280 million Americans.
20:51:41 <Pseudonym> 90% of everything is crap.
20:51:56 <Pseudonym> Therefore 252 million Americans are retarded.
20:52:05 <Riastradh> That's literally a shitload of crappy Americans.
20:52:07 <monotonom> You are right. I must rethink my blanket statement.
20:52:29 <Pseudonym> The reason why there are so many stupid Americans is that there are a lot of Americans.
20:52:32 <monotonom> But doesn't all of Europe have a larger population than the USA?
20:52:39 <Pseudonym> Taken together, yes.
20:53:00 <Pseudonym> But not all of them speak good enough English, even for IRC.
20:53:04 <Riastradh> Europa probably has an even smaller population than Monaco, though!
20:55:45 <Pseudonym> That's true.
20:57:01 <monotonom> Alright, I cannot justify that Americans are more retarded.  I interpret them to be more retarded, but that's only because I observe them to be more obnoxious, or less modest; and that I can justify.
20:58:14 <SamB> the reason why there are lots of stupid americans is that they somehow get an aversion to learning, imo.
20:58:14 <Pseudonym> That's fair, because if there's a problem with your assessment, it's merely that your interpretation is not valid with respect to the underlying model.
20:59:33 <Riastradh> Going further, most of the teachers seem to have an aversion to teaching interesting classes.
21:00:32 <SamB> Riastradh: I haven't been there, so I don't know about that one.
21:00:40 <monotonom> America is a large country; Americans need not know more cultures and ways of lives than their own.  Europeans live in comparatively small countries, and just for the sake of survival they have to be aware of a handful of slightly different cultures.  Awareness of diversity tends to make one modest.
21:01:00 <Pseudonym> monotonom: Some Americans do.
21:01:10 <monotonom> Yes. Not enough of them.
21:01:20 <Pseudonym> For example, those outside the "mainland", Alaska and Hawaii.
21:01:25 * Riastradh is going to bed now.
21:01:26 <SamB> what does that have to do with an aversion to learning?
21:01:45 <Smerdyakov> There are about as many rich people in the USA as in particular European countries.
21:01:47 <monotonom> Not enough proportion either.  An American can choose to know.  A European is forced to know.
21:02:06 <Smerdyakov> Only those associated with or living near rich people get good educations (or are encouraged to learn) anywhere.
21:02:32 <Smerdyakov> With more total population in America, we have a smaller proportion of people in this good situations.
21:03:11 <Pseudonym> Actually, that is a good point.
21:03:18 <Pseudonym> The US has a very odd geography.
21:03:43 <Pseudonym> It's a large country, but there are no large areas where nobody lives.
21:04:04 <Pseudonym> In China, Russia or Australia, you'll find huge expanses where few people live.
21:04:04 <SamB> Smerdyakov: homeschoolers are always encouraged to learn, aren't they?
21:04:20 <Pseudonym> Travelling in the US, you find a town every few minutes.
21:04:30 <Pseudonym> No matter which direction you travel.
21:04:37 <Pseudonym> (The exception being Alaska, as previously mentioned.)
21:04:44 <Smerdyakov> SamB, there are two kinds of homeschooling: poor fanatical Christians and rich fanatical Christians. :D
21:05:00 <Smerdyakov> SamB, the fanaticism perhaps makes up for the surroundings in the first case.
21:05:15 <SamB> how do I tell which category I fit in?
21:05:20 <Smerdyakov> Family income
21:05:31 <SamB> I don't think I'm cleared for that
21:05:43 <Smerdyakov> Neighborhood where you live, then
21:06:03 <Pseudonym> Homeschoolers are encouraged to learn, but they are not necessarily encouraged to learn a wide variety of things.
21:06:04 <SamB> house has negative equity
21:06:23 <Smerdyakov> SamB, if you have to worry about "getting by from day to day," you're in the first category.
21:06:26 <Pseudonym> Not _necessarily_.  Naturally there are exceptions.
21:06:51 <Smerdyakov> SamB, am I correct that both your parents are committed Christians?
21:06:57 <monotonom> You can also be part of a rich family that is declining towards poverty.  in transit. :)
21:07:08 <SamB> well, I was discouraged from learning only about computers, at any rate
21:07:35 <SamB> Smerdyakov: as far as I can tell
21:07:50 <Smerdyakov> SamB, interesting how I can predict such things from the fact that you're home-schooled, eh? :D
21:08:23 <SamB> oh, I don't know. most of our home-school freinds are also christians...
21:08:37 <monotonom> You understand the social structure.
21:08:54 <Smerdyakov> I am in tune with the Matrix.
21:09:22 <monotonom> Ugh, so you set things up that way, rather than predict it...
21:10:24 <Smerdyakov> Like how I make money from little kids on the street by betting them that I am about to punch them
21:12:42 <monotonom> The real question is...
21:12:49 <monotonom> Is the Matrix purely functional?
21:13:21 <Pseudonym> No, it uses unsafePerformIO a lot.
21:14:01 * Smerdyakov suggests renaming that to unsafeTemptFate
21:16:27 <Pseudonym> I have to go.
21:16:44 <Pseudonym> It was lovely chatting with you all, especially the troll.
21:16:50 <Pseudonym> Fare well!
21:19:55 <PerlMan> as a newbie to ghci and wxhaskell I am having trouble running the bouncing balls demo. Anyone care to help?
21:23:52 <Cale> what's the error?
22:20:10 <PerlMan> the file bouncing balls runs but only displays a blank window. the balls do not appear
22:21:20 <Cale> click?
22:21:31 <Cale> I seem to remember clicking made balls
22:21:40 * PerlMan slaps forehead
22:21:43 <PerlMan> I did not try that
22:22:55 <PerlMan> yep - works like a charm. Sometimes the stupidest things...
