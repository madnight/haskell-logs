02:02:48 <juhp> SamB: right
03:01:51 <bourbaki> hidiho
03:03:25 <lambdawar> bourbaki: are you part of the b. crew ?
03:04:12 <bourbaki> heh
03:04:17 <bourbaki> who knows :)
03:04:48 <lambdawar> impressive if you are, Im not even sure it is still officially existing 
03:05:06 <bourbaki> heh i wish i was but i guess i am not
03:05:17 <lambdawar> except the seminars standing 
03:05:21 <bourbaki> but maybe i just forgot that i am ;)
03:05:29 <lambdawar> free & open seminars, pretty cool actually
03:05:47 <bourbaki> whats the url?
03:06:23 <lambdawar> http://www.bourbaki.ens.fr/
03:06:54 <lambdawar> its in french, but a mathematician who doesnt speak french is not a true mathematician I guess ;)
03:08:17 <lambdawar> the same probably stands for english and russian
03:08:52 <bourbaki> how old are you ?
03:09:09 <bourbaki> thats what my math teacher in school said and he was like 60 years old
03:09:23 <lambdawar> I'm ~ 20
03:09:24 <bourbaki> i am no mathematician though
03:09:45 <bourbaki> i wish i would know more math ppl in my vicinity to discuss things
03:10:01 <bourbaki> i would describe myself as a scientific vagabond
03:10:07 <bourbaki> :)
03:10:22 <lambdawar> its a pretty fun & sympathic description
03:10:33 <bourbaki> well i dont speak french ;)
03:10:44 <bourbaki> neither can i read it
03:11:10 <bourbaki> that is i can kind of read it but make no sense of most of the expressions
03:11:12 <lambdawar> <- frog
03:11:19 <bourbaki> heh
03:11:32 <bourbaki> frog == french ;)?
03:11:48 <lambdawar> ya
03:12:06 <bourbaki> france is quite cool imho
03:12:17 <lambdawar> for maths, yea it is
03:12:20 <lambdawar> for other things, it sucks 
03:12:44 <lambdawar> we are one of the most repressive country in europe 
03:12:52 <lambdawar> concerning a lot of stuff 
03:12:55 <bourbaki> well you have good weather at the coast :) and nice women
03:13:06 <bourbaki> yeah thats true
03:13:14 <lambdawar> i wish paris was on the coast 
03:13:22 <bourbaki> heh
03:14:12 <bourbaki> so i guess you study in paris math probably?
03:14:47 <lambdawar> not that far from truth
03:15:20 <lambdawar> im more into maths related CS 
03:15:43 <bourbaki> ah cool
03:18:28 <lambdawar> you studied banach spaces ?
03:19:27 <bourbaki> nope i have read about them though in my topology book
03:19:43 <bourbaki> cant remember though what their properties where though
03:20:59 <bourbaki> lambdawar why do you ask?
03:21:53 <lambdawar> I need to buy a good book about those, I found one but I dont remember the name 
03:22:44 <bourbaki> a whole book about banarch spaces :)?
03:22:49 <bourbaki> what do you need them for in CS?
03:23:19 <lambdawar> its quite useful for functionnal analysis 
03:24:16 <bourbaki> but not for programs?
03:24:20 <bourbaki> hi shapr ;)
03:24:32 <shapr> hi bourbaki 
03:26:11 <lambdawar> bourbaki: programs are different than functions ? ;)
03:26:28 <shapr> Howard and Curry had some thoughts on that.
03:26:28 <bourbaki> heh
03:26:48 <bourbaki> the question is what kind of functions
03:27:13 <bourbaki> lambdawar so tell me how banarch spaces relate to programs
03:28:17 <lambdawar> a lot, since many kinds of normed vector spaces are banach spaces (euclidian space, hilbert spaces ..)
03:29:02 <bourbaki> well but is the space of functions in haskell normed?
03:29:51 <lambdawar> a good question, I guess it is, but I cant confirm it 
03:30:19 <bourbaki> well if it was you would have to have a bilinear form of some kind right?
03:31:13 <bourbaki> hm maybe if you would pick the op codes of the cpu you could use these as a space to render the basic functions in
03:33:12 <bourbaki> the haskell functions are no vector space though are they?
03:33:48 <lambdawar> honnestly, I have no idea, my ignorance is flagrant here ;) I dont know enough haskell. Maybe monads can be represented as morphisms of banach spaces, but I have really no clue about it for real
03:34:32 <shapr> Banana Space... where all monkeys have POWER!
03:34:39 <bourbaki> well lets just think about it a banarch space is based on vector space right?
03:34:45 <bourbaki> :) hahaha
03:34:49 <bourbaki> ugh!
03:36:01 <bourbaki> hmmm what could i write ?
03:37:17 <lambdawar> bourbaki: yea, so stable by internal addition and scalar multiplication, it has to be normed, and it has to be complete for beeing a B.S.
03:37:48 <bourbaki> ok what would the scalar multiplication of our space be?
03:38:03 <bourbaki> the vector would be a function and the scalar?
03:39:30 <lambdawar> nah, scalar is scalar, the function is the vector
03:39:53 <bourbaki> yeah but what would the multiplication look like what is the type of the scalar
03:40:09 <shapr> hm, I wonder if you could skip out on the battery/MHz/performance balance of handhelds by adding a cost factor with a software configurable FPGA.
03:40:45 <lambdawar> af1 + bf2 + cf3 ... with (a,b,c) C |K x |K x |K, |K beeing |R or |C, or probably something else
03:40:46 <shapr> hiya Si\, how's code?
03:40:57 <bourbaki> hey a qick question
03:41:12 <lambdawar> f1,f2,f3 in the V.S.
03:41:23 <shapr> gutentag cptchaos 
03:41:27 * shapr hOps randomly
03:41:36 <bourbaki> you know that you can stream videos in winamp and such and i thought that maybe there should be some kind of haskell lecture channel :)
03:41:44 <cptchaos> hi, shapr
03:41:48 <bourbaki> lambdabot yes and the scalar mul?
03:41:50 <shapr> oh, that's a good idea bourbaki.
03:41:58 <bourbaki> greetings cptchaos where you from?
03:41:58 <lambdawar> af1 is a scalar mult 
03:42:01 <lambdawar> a is the scalar 
03:42:04 <shapr> I've been working on setting up an sfs mount for #haskell
03:42:13 <bourbaki> lambdawar and what type is has a?
03:42:16 <cptchaos> bourbaki: germany
03:42:25 <bourbaki> cptchaos so am i :) where from?
03:43:04 <lambdawar> i said it, a C |R, a C |C, and probably other possible spaces that I've not experimented
03:43:16 <Si\> Hi shapr; I've applied for Savannah, just waiting their reply
03:43:23 <cptchaos> \me confused looking
03:43:25 <bourbaki> shapr do you think that it was possible to gather some kind of lecture video ?
03:44:01 <Si\> other than that as such I can parse XSchema simple-types, and hopefully by the end of today should be able to validate simple values
03:44:23 <lambdawar> bourbaki: I doubt we can improvise something about banach spaces without beeing experimented with it ;)
03:44:41 <bourbaki> lambdawar do you talk about some subset of the possible functions that you could do with haskell that map from |R -> |R ?
03:45:06 <lambdawar> bourbaki: NO, im talking about the set where scalars take their value
03:45:22 <bourbaki> lambdawar dual spaces?
03:45:26 <shapr> bourbaki: I don't know, but I can ask around.
03:45:33 <lambdawar> it is the definition of a vectorial space
03:45:38 <lambdawar> dual spaces is something else 
03:45:52 <shapr> greetings RussellOConnor, I don't see any Haskell code on your home page, have you released any?
03:46:00 <bourbaki> shapr that would be really cool do you know these old scheme lectures of ableson and sussman?
03:46:29 <shapr> yes, I have a bunch of them.
03:46:41 <shapr> I'm tempted to put up an inofficial bittorrent
03:46:46 <bourbaki> shapr it would be cool if they would be like them in the end with these cool jingles ;)
03:46:56 <shapr> I have 8gb of SICP lectures
03:47:03 <shapr> in realaudio format I think :-(
03:47:08 <shapr> I want a theora port
03:47:09 <bourbaki> yeah i have them all in mpg
03:47:15 <shapr> oh you do??
03:47:20 <shapr> I want !
03:47:21 <bourbaki> yes
03:47:33 <bourbaki> sec let me connect my disk
03:47:38 <shapr> .rm sucks
03:47:43 <bourbaki> ill give you my ip and you can dl them if you want
03:47:50 <shapr> thanks!
03:48:30 <shapr> I can host a low-speed bittorrent on ScannedInAvian, I'll email the SICP guys and ask them if that's okay.
03:49:37 <Igloo> 8G of RA? My word, how long does that go on for?
03:49:47 <bourbaki> we really need something like that for haskell :) and we need someone to make one of these cool 80's jingles and one of these cool wizards ;)
03:50:12 <shapr> Igloo: around twenty hours
03:50:30 <cptchaos> bourbaki: hamburg (I have an long latecy in understanding, at the moment ... :-) )
03:50:42 <Igloo> Oh, I thought it was a lower bitrate than that
03:50:50 <shapr> Igloo: http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
03:51:00 <Igloo> Maybe it's just higher quality than most
03:51:36 <shapr> the MPGs are 320x240 3Mbps
03:52:50 * Igloo makes that 26G
03:53:37 <shapr> well, the .rm files are ~8GB
03:54:23 <shapr> gutentag lantis 
03:54:34 <shapr> lantis: do you ever make jokes about @lantis ?
03:54:35 <lantis> guten tag :)))
03:54:36 <bourbaki> the avis are in total abou 9gigs
03:54:45 <lantis> shapr: not yet ;D
03:54:47 <shapr> have I already asked you that before?
03:54:57 <lantis> nope
03:59:03 <shapr> andersca: is there a theora utility to import mpg?
03:59:16 * shapr googles around
04:02:15 <shapr> gutentag Joachim_
04:05:43 <shapr> hmm, cmml ... isn't ozone working on that?
04:11:55 <ozone> mmmm?
04:12:13 <ozone> you want to convert mpg to theora?
04:16:49 <Igloo> Is theora what your company makes?
04:17:46 * Igloo googles and is enlightened
04:17:52 <bourbaki> :)
04:18:19 <shapr> ozone: yes, mpg to theora, or .rm to theora, or even more
04:20:22 <ozone> shapr: see http://www.annodex.net/anx_theora.html
04:20:33 <shapr> yah, I noticed that... and the CSIRO at the bottom
04:20:34 <ozone> and leave out the last anxenc step, since you don't want to annodex it
04:20:42 <ozone> indeed, that'd be me
04:44:04 <bour> what was the standard emacs paste command again?
04:44:10 <shapr> control y
04:44:51 <Lukhas> and M-y to cycle through kill-ring, after that
05:29:43 <shapr> man, I want flip for shell commands
05:32:35 <esap> why not write it? :-)
05:35:20 <Lemmih> `$1 $3 $2`?
05:36:24 <shapr> Lemmih: too easy!
05:36:46 <shapr> I was trying to pipe a bunch of files through grep and only move them to another dir
05:37:02 <shapr> but the dir is the last arg with mv
05:38:05 <Cale> you can always build a list of commands to be piped to bash
05:38:33 <Cale> which can then be modified by anything you want - sed, awk, etc.
05:43:35 <Cale> or if it was all the same dir - you could probably use | xargs --replace=% mv % somedir
06:04:37 <lambdawar> Georges Gonthier?s thesis was a major step in the development of Esterel. He understood the fundamental distinction between the behavioral semantics, which is of a logical nature and based on mutual agreement about signal presence and values, and causality issues that deal with effective information propagation.
06:04:46 <lambdawar> what is that supposed to mean
06:05:17 <lambdawar> http://www-sop.inria.fr/esterel.org/Html/History/History.htm
06:18:19 <Igloo> Is it possible to have an "a" instance and a "Show a => a" instance of a class?
06:21:16 <Igloo> shapr: Why does http://www.haskell.org/hawiki/TipsAndTricks tell me I'm not allowed to view the page?
06:22:19 <Igloo> Oh, it works now
06:22:35 <shapr> sorry, I'm trying to add an access control list
06:23:50 <shapr> Cale: when have a moment, can you try to edit AdminGroup?
06:24:08 <shapr> I think the ACL is working, but I don't know why the delete action doesn't show up.
06:27:07 <bourbaki> does anyone of you know a command for tex that lets me do my own indention?
06:29:18 <Igloo> Hmm, looks like I can't do it  :-(
06:30:08 <Igloo> Oh, I wonder if I can do it with default methods
06:31:18 <Igloo> Ah, no, because then there is no instance for anything outside of Show
06:35:26 <shapr> Cale: ok, you got WikiAdmin, means you can both revert and delete.
06:35:33 <xkb> hmm
06:35:34 <shapr> also means you can add new people to the AdminGroup page if you want.
06:35:44 <xkb> anyone here ever used DynException in haskell?
06:36:00 <JaffaCake> yes
06:36:28 <xkb> the type is a dynamic type ?
06:36:36 <xkb> Data.Dynamic?
06:36:39 <JaffaCake> that's right
06:36:59 <RussellOConnor> shapr, I had some up before.  My harddrive crashed 2 weeks ago. ... I hope I have a backup.
06:38:21 <RussellOConnor> shammah, Cont (\f -> f) is not well typed.
06:39:33 <shapr> do you have any SGML/DSSSL code around?
06:40:08 <Marvin--> Igloo: no, I think SPJ mentioned on one of the haskell list a while ago that the overlapping instances code doesn't look at the context of an instance declaration
06:42:46 <Igloo> *nod*, ta
06:42:47 <RussellOConnor> shapr, I have a little. Once upon a time I wrote: <http://www.nyx.net/~gthompso/self_sgml.txt>
06:43:06 <shapr> man, everytime I think I've made a big breakthrough in understanding all the theoretical and implementational underpinnings of Haskell, I realized I'm just in the next room of the dungeon.
06:44:09 <SyntaxNinja> s/dungeon/palace
06:44:10 <shapr> on the good side, Haskell has held my interest far longer than any other computer related subject.
06:44:13 <shapr> SyntaxNinja: ha!
06:44:18 <shapr> good point!
06:44:49 <SyntaxNinja> hi Marvin-- how's code?
06:45:00 <shapr> has anyone worked on an RSS parser/aggregator in Haskell?
06:45:27 <RussellOConnor> Coq is even crazier than Haskell.  MMmmmm dependant types
06:45:43 <shapr> have you seen Epigram?
06:45:48 <RussellOConnor> Nope
06:46:12 <shapr> Epigram is something like visual programming with dependant types
06:46:51 <shapr> http://www.dur.ac.uk/CARG/epigram/
06:47:17 <shapr> screenshots don't do it justice, you gotta play with it.
06:48:05 <shapr> I wish I had the same thing for interactively defining *BNF grammars and showing how they parse input in a separate window
06:49:38 <shapr> Riastradh: actually, epigram's incremental syntax-directed editing would be a great compromise between what you and I both want in an editor.
06:54:09 <Marvin--> SyntaxNinja: code isn't at all, right now, I've been bedridden all morning with a nasty headache
06:54:54 <Igloo> :-(
06:55:44 <RussellOConnor> Heffalump, call/cc doesn't let you adjust the result of the future computation f::(a -> r).  So Cont (\f -> 1 + f 3) seems like a very strange thing to do for a continuation.
06:58:52 <SyntaxNinja> Marvin--:  :(
06:59:33 <Marvin--> well, it's better now :)
07:14:45 <MakeMyDay> I have a function that searches a Graph. If it doesn't find what it is looking for it gives out a simple error. Now I want to take this function and use it to search a list of Graphs ( a Forrest) . The element I will be searching for can only exist in 1 of all those Graphs.Can I somehow ignore the "not found" errors and only give back my element?
07:16:09 <Amadan> i'm a newbie, but... why not use Maybe?
07:16:43 <shapr> yah, I agree
07:17:06 <MakeMyDay> I never was good with maybe..I'll read up on it though.-
07:17:26 <shapr> @type ap
07:17:30 <lambdabot> bzzt
07:17:35 <shapr> @type Control.Monad.ap
07:17:36 <lambdabot> Control.Monad.ap :: forall b m a.
07:17:36 <lambdabot> 		    (Monad m) =>
07:17:36 <lambdabot> 		    m (a -> b) -> m a -> m b
07:18:11 <shapr> I think you can use ap to return the first Just x result from a list
07:18:53 <shapr> something like  foldr1 ap (map myLookup myGraphList)
07:19:13 <shapr> as long as myLookup myGraph :: Maybe x
07:19:31 <Igloo> That type doesn't look right; mplus should do it, though
07:20:09 <Marvin--> foldr1 ap doesn't work at all
07:21:08 <shapr> oh, hmm
07:21:23 <Amadan> msum (map myLookup myGraphList) ?
07:21:45 <shapr> oh, right
07:21:46 <shapr> msum
07:21:53 * shapr was confused
07:21:55 <Marvin--> msum is nice
07:22:09 <Igloo> Presumably it's foldr mplus mzero?
07:22:15 <shapr> yes it is
07:22:20 <Marvin--> yep
07:23:43 <Heffalump> rusell: hmm, true
07:23:51 <Heffalump> s/rusell/RussellOConnor/
07:24:39 <shapr> ap is very nifty
07:24:59 * shapr hugs the nomaware monad tutorial
07:25:19 <RussellOConnor> I think I should be trying to write my expression only using callCC and return and >>=.  But maybe that's impossible, and maybe that is a good thing.
07:26:22 <shapr> @type [(*2),(+3)] `ap` [0,1,2]
07:26:23 <lambdabot> bzzt
07:26:36 <shapr> @type ap [(*2),(+3)] [0,1,2]
07:26:37 <lambdabot> bzzt
07:26:47 <shapr> @type Control.Monad.ap [(*2),(+3)] [0,1,2]
07:26:48 <lambdabot> Control.Monad.ap [(*2),(+3)] [0,1,2] :: forall a. (Num a) => [a]
07:27:23 <Heffalump> RussellOConnor: the thing about your implementation is that it is translating CPS code back into direct style code.
07:27:40 <Heffalump> and I'm confused about whether that should be possible or not.
07:28:52 <Smerdyakov> It should certainly be possible for code translated from "direct style" in the first place!
07:30:31 <Heffalump> well, yes.
07:30:49 <Heffalump> but I thought call/CC lets you write code that couldn't be written in direct style.
07:30:56 <Heffalump> but I don't really understand continuations
07:31:17 <Smerdyakov> That depends what you mean by direct style.
07:31:44 <Smerdyakov> Clearly you can implement a Turing machine without using continuations, for example. :)
07:32:22 <Heffalump> yes, but his implementation is a direct translation back
07:32:27 <Heffalump> no extra layers of abstraction
07:32:44 <Heffalump> (well, apart from those constructors)
07:35:31 <RussellOConnor> I originally just wrote the function \f->f (\g->g (\a->f (\h->a))), and I wanted to figure out what it did.  So I've been trying to find a interpretation of the function using continuations.
07:37:01 <RussellOConnor> Sprinking in the word Cont made the type easier to understand.  But I really shouldn't be using Cont to make continuations.  I should be using return and callCC
07:39:17 <RussellOConnor> I wonder if I can use this lambdabot
07:39:30 <RussellOConnor> @type \f->f (\g->g (\a->f (\h->a)))
07:39:31 <lambdabot> \\f->f (\\g->g (\\a->f (\\h->a))) :: forall t t1.
07:39:31 <lambdabot> 				 ((((t -> t1) -> t) -> t) -> t1) -> t1
07:39:36 <RussellOConnor> :-)
07:41:51 <Marvin--> whoa
07:42:39 <RussellOConnor> higher higher higher higher order functions confuse me
07:46:05 <RussellOConnor> That probably doesn't help your headache much
07:47:06 <Marvin--> no kidding
07:47:23 <Igloo> :-)
07:47:47 <shapr> isn't there a paper on infinite types of that style?
07:47:56 <shapr> I think it's a John Launchbury paper...
07:56:49 <SyntaxNinja> I know I mentioned this the other day, but is there any kind of type class that looks like this:
07:56:50 <SyntaxNinja> class Sequenceable col where
07:56:50 <SyntaxNinja>    sequenceIt :: (Monad m) => col (m a) -> m (col a)
07:57:12 <SyntaxNinja> you guys pointed me to some threads and a paper, but the thread seemd inconclusive and the paper a bit of an overkill.
07:57:52 <SyntaxNinja> so this is like a functor, but with sequence
07:58:13 <Igloo> Wasn't there a thread on one of the lists just the other day about that?
07:58:57 <SyntaxNinja> the one with grahm klyne?
07:59:25 <Igloo> No idea
07:59:58 <SyntaxNinja> I see something from a week ago.  I mean, the thing I just pasted is exactly what i need, I'm just not sure if there's a moderately standard version of it.
08:04:03 <Marvin--> What do you mean there *is* such a type class? You just defined it, didn't you? :)
08:04:37 <RussellOConnor> Hmmm, I don't see how to create \a -> Cont (\h -> a) using callCC.  I suspect it is impossible, so my expression doesn't really conform to the Continuation abstract data type
08:05:26 <shapr> SyntaxNinja: you could always cd fptools && fgrep -ir class | sort | uniq
08:05:29 <shapr> actually, so could I...
08:05:51 <SyntaxNinja> ah well. I figure that after 5 minutes if no one on here knows about one then there probably isn't one ;)
08:06:10 <shapr> is a unix pipe normally lazy?
08:06:24 <Marvin--> well, as I said yesterday or whenever it was, there was a discussion on the lists a while ago
08:06:38 <SyntaxNinja> so I saw the paper Monads, Shapely Functors and Traversals, are there any other papers about this kind of typeclass and functors?
08:07:15 <SyntaxNinja> Marvin--: yeah, I think I found that discussion; I don't think it's quite what I'm looking for, but I'll keep staring at it.
08:07:37 <shapr> that moggi guy is pretty smart.
08:07:39 <SyntaxNinja> I feel that I'm missing a connection that I'm really close to getting :)
08:08:34 <Marvin--> well, that discussion was specifically about turning a monad pair inside out
08:08:51 <Marvin--> and it was kind of interesting which kinds of monads you can turn inside out in which "direction"
08:09:37 <Igloo> I suppose this is slightly different in that collections generally ca't be Monads due to Eq/Ord constraints
08:10:44 <SyntaxNinja> I like the phrase "Shapely functors and Traversals" and "Functors shapely over lists"
08:11:31 <SyntaxNinja> it makes me feel like I'm having fun, even though I'm not.
08:11:52 <Igloo> Heh
08:12:22 <Marvin--> Igloo: you won't be able to instantiate this kind of type class with a Set either
08:12:30 <Marvin--> you're just as restricted here
08:12:30 <shapr> greetings kc
08:12:38 <Marvin--> unless you turn it into a MPTC
08:12:41 <SyntaxNinja> I had a dream about arrows the other day
08:12:50 <shapr> SyntaxNinja: yikes!
08:12:52 <KC> hello shapr
08:12:57 <shapr> SyntaxNinja: what kind of dream?
08:13:02 <SyntaxNinja> Marvin--: you mean my Sequenceable typeclass?
08:13:08 <Marvin--> SyntaxNinja: yes
08:13:13 <shapr> KC: how's code?
08:13:24 <SyntaxNinja> shapr: it was pretty abstract and hard to explain.
08:13:32 <SyntaxNinja> (perhaps that goes without saying ;) )
08:13:35 * shapr grins
08:13:40 <Marvin--> the Sequenceable Set instance would be something like sequenceIt = liftM mkSet . sequence . setToList
08:13:41 <Igloo> Marvin: Oh?
08:13:55 <KC> shapr code ?
08:14:02 <Marvin--> but since sequenceIt has no Ord constraint in the class definition, it won't work
08:14:14 <shapr> KC: have you written any interesting or fun code lately?
08:14:22 <Marvin--> (of course, you could work directly with Set operations rather than going via lists, but the Ord constraint is still there)
08:14:47 <Igloo> Oh yeah, you have the same problem
08:14:50 <KC> shapr: nope
08:15:01 <SyntaxNinja> the same is true of functor, no?
08:15:03 <KC> shapr: but some diff code
08:15:20 <shapr> is that diff for indifferent? or diff like the utility?
08:15:49 <KC> shapr: utility
08:15:56 <shapr> I've often wondered how diff works internally.
08:16:32 <Marvin--> with MPTC you could write
08:16:33 <Marvin--> class Seq col elem where seq :: Monad m => col (m elem) -> m (col elem)
08:16:33 <Marvin--> instance Ord elem => Seq2 Set elem where seq = liftM mkSet . sequence . setToList
08:17:05 <KC> shapr: i mean different code
08:17:14 <shapr> ah, ok.
08:17:18 <Marvin--> er, s/Seq2/Seq/
08:18:48 <KC> shapr: what you are into these days ?
08:19:29 <shapr> the last few days I've been interested in how grid computing and  data parallelism fits together.
08:20:06 <shapr> oh, I had a neat idea today about using epigram-style interactive 'shed' input to build parsers.
08:20:14 <shapr> what are you into?
08:20:54 <KC> shapr: no coding these days
08:21:00 <shapr> oh, that's too bad.
08:21:14 <shapr> coding is fun
08:21:28 <KC> shapr: but will start soon
08:21:41 <shapr> have you written any Haskell code?
08:21:56 <KC> shapr: wondering how screen command works
08:22:57 <KC> shapr: nope, harsha told me about haskel that it is functional programming language
08:23:27 <shapr> screen lets you have shells/programs running on 'virtual terminals' that you can detach from, attach to, or share with other users.
08:23:51 <keverets> yeah, "screen -x" can be really useful.
08:24:00 <KC> shapr: Yup i din do the sharing part
08:24:30 <KC> ok
08:24:53 <shapr> yes, Haskell is a functional programming language. The functional approach is somewhat different from the procedural approach.
08:25:24 <shapr> From what I've seen there are three major paradigms to programming; procedural, functional, and logic/constraint.
08:25:48 <shapr> I'd suggest learning to use all three if you want to be an excellent programmer.
08:26:32 <KC> shapr: what abt OOP ?
08:26:41 <RussellOConnor> I might add multi-threaded to that list
08:26:44 <neologism> KC: oop is about how you understand data
08:26:49 <neologism> not the data manipulation itself
08:26:55 <neologism> you can use oop in all three paradigms
08:26:59 <norpan> oop is what you say when your program goes wrong
08:27:25 <norpan> c++ is the primary oop language in that repect
08:27:30 <norpan> respect
08:27:33 <shapr> :-)
08:28:01 <RussellOConnor> err, maybe I should say event-driven or message-passing-style instead.
08:28:51 <KC> neo: it is also an approach to
08:29:09 <KC> shapr: what abt you ?
08:29:16 <shapr> er, what about me?
08:29:26 <neologism> KC: oop is how you define datas
08:29:37 <neologism> not about how you define manipulation with the data itself
08:31:09 <KC> shapr: functional, procedural and oop approach are'nt different ?
08:31:51 <neologism> KC: you can use oop with all three ;)
08:32:01 <neologism> in fact
08:32:05 <neologism> haskell is oop too ;)
08:32:25 <shapr> oop has a bunch of different pieces
08:32:30 <KC> neo: that is cool
08:32:44 <shapr> many of the pieces of OOP are in Haskell, but not all of them.
08:32:53 <neologism> shapr: which are not?
08:32:54 <KC> ok
08:33:29 <shapr> identity
08:33:42 <neologism> what is identity?
08:33:48 <shapr> you can't test whether two functions are the 'same' function
08:33:50 <neologism> I am afraid I dont know tis trem
08:33:55 <shapr> you can test for value equality, but not identity
08:34:00 <neologism> of course
08:34:09 <neologism> you never can
08:34:24 <shapr> in OOP, value and identity are different things entirely.
08:34:39 <neologism> I dont understand
08:34:45 <KC> me too
08:34:48 <neologism> you can never say wheter two functions are equivalent
08:34:57 <neologism> its undecidable
08:34:57 <ibid> in OOP, there are no functions
08:35:02 <shapr> two separate instances of an object can be equal, but not occupy the same memory space.
08:35:10 <neologism> oh... you mean THAT ;)
08:35:27 <neologism> aka... two methods belong to objects of the same class
08:35:28 <ibid> in OOP, the identity of an object is independent of its value
08:35:35 <neologism> and have the same name -> are identical
08:35:36 <neologism> ok?
08:35:59 <ibid> it's not about methods
08:36:06 <ibid> it's about objects
08:36:23 <neologism> objects is made ofmethods and atributes
08:36:55 <shapr> in Haskell, if you have a = 1 and b = 1, a is equal to b, but, are they the 'same' variable?
08:37:04 <ibid> that's one pov; but what i meant was that the identity/value distinction is about objects, not about methods
08:37:24 <shapr> in Python, if you have a = 1 and b = 1, they are equal, but they are definitely *not* the same variable, they occupy separate spaces in memory.
08:37:59 <shapr> in purely functional programming, identity is not important.
08:38:01 <ibid> in Python, asking whether a and b are the same variable makes no sense
08:38:16 <ibid> you are asking whether they are bound to the same object or not
08:38:24 <shapr> ok, how about comparing lambdas? ;-)
08:38:48 <ibid> which, incidentally, is the same question in haskell, only that haskell gives you no means for checking identity
08:38:55 <ibid> what do you mean?
08:39:00 <KC> that is same in case of C
08:39:06 <ibid> anyway, OOP is a state of mind, not a set of language features
08:39:19 <ibid> KC: what is same in case of C?
08:39:40 <ibid> it also applies to FP: FP is a state of mind, not a set of language features
08:39:49 <KC> a = 1 b = 1 have same value but have diff mem locations
08:39:56 <ibid> yeah
08:40:07 <ibid> in C it makes sense to ask whether they are the same variable
08:40:27 <ibid> because in C, there is no distinction between variables and the objects they bind to
08:40:32 <KC> and offcourse they are not
08:40:40 <ibid> of course
08:40:46 <shapr> part of the state of mind of FP is that value is what's important.
08:40:51 <ibid> we are not off course, are we? :)
08:41:08 <shapr> that gives you some neat tricks like common subexpression elimination
08:41:24 <ibid> well, there are several conflicting definitions of FP
08:41:53 <ibid> in the case of OOP, there are several definitions, which makes the term effectively useless (they are all-inclusive)
08:42:21 <ibid> (there are a couple of useful definitions of OOP, but they are not commonly accepted)
08:43:10 <shapr> you can still have all the OOP features with monads.
08:43:20 <ibid> 18:39  <ibid> anyway, OOP is a state of mind, not a set of language features
08:43:21 <ibid> :)
08:43:27 <shapr> right
08:43:54 <shapr> I started learning Haskell because my Python code was entering that state of mind.
08:44:04 <ibid> it seems to me that the OO research community is converging to conventional programming
08:44:11 <shapr> conventional?
08:44:23 <ibid> procedural
08:44:43 <ibid> but modernized
08:46:25 <KC> but comp science says FP, PP and OOP are different write ?
08:46:39 <ibid> KC: i can't parse that sentence
08:47:21 <shapr> KC: In summary, programming is *really* complicated. If you share some assumptions (that hopefully simply some stuff) with a bunch of other people who write code, that's called a paradigm.
08:47:30 <neologism> ibid: s/write/right ;)
08:47:54 <ibid> neologism: thanks, it's clearer, but i still can't understand it:)
08:48:13 <shapr> for example, OOP tends to put state in the instance, and FP tends to put all the state in one place.
08:48:17 <ibid> KC: if i understood you correctly, no, it does not
08:48:40 <shapr> so OOP cuts the state into a bunch of smaller pieces that are easier to think about on their own.
08:48:58 <neologism> shapr: I usually think of FP as data-flow computing
08:49:00 <KC> write
08:49:10 <neologism> where your data flows modified by functions
08:49:12 <ibid> the defining difference between OOP and FP is that the former is based on object decomposition and state encapsulation, the latter is based on functional decomposition and the abolishment of state
08:49:14 <shapr> Each approach gives different benefits and drawbacks.
08:49:35 <ibid> add IMHO to that :
08:49:37 <shapr> yah, I agree with the data-flow view, it's a good view.
08:49:39 <ibid> )
08:49:55 <Amadan> and besides (hoping no-one gets angry for mentioning other camps), scheme can do oop, fp, pp - whatever you want - so it's definitely not exclusive
08:50:02 <Amadan> even lp
08:50:05 <neologism> shapr: thnx ;)
08:50:17 <flaw> lp?
08:50:21 <neologism> logic programming
08:50:23 <KC> neo:so how come haskell OOP too
08:50:26 <ibid> Amadan: it's not about language features, so of course it can
08:50:30 <shapr> But (in my opinion), nothing is 'The Right Thing' by itself. It's best to be able to combine them all, and use them when you need them.
08:50:43 <neologism> KC: haskell is oop
08:50:53 <Amadan> yeah, i know, but usually languages specialise.
08:50:56 <neologism> KC: there are classes in haskell
08:51:10 <Amadan> you mention java, one thinks of (bad) procedural oop.
08:51:15 <neologism> so you can decompose your programm ona class basis
08:51:23 <shapr> I'd argue that closures can work like a poor-man's instance
08:51:32 <KC> neo: ok
08:51:37 <Amadan> you mention haskell - pure functional. prolog? logical, no oop.
08:51:43 <ibid> neologism: where is the word "class" in Object-Oriented Programming? ;)
08:51:57 <neologism> ibid: object is an instance of a class?
08:52:01 <neologism> there?
08:52:10 <Amadan> you could perhaps force procedural oop through prolog, but i wouldn't try it, 's what i meant.
08:52:11 <shapr> in Haskell, typeclasses work like Java interfaces
08:52:12 <ibid> neologism: not necessarily, though it can be
08:52:21 <neologism> ibid: ok... USUALLY ;)
08:52:38 <ibid> neologism: depends on your definition of "usual" :)
08:52:40 <neologism> shapr: since you dont have variables inhaskkel its the only possibility
08:52:44 <neologism> ibid: :)
08:52:55 <ibid> neologism: class-based languages are popular, that is true
08:53:19 <ibid> neologism: but if we went for popular, we wouldn't be on this channel, would we? :)
08:53:29 <neologism> I am misseducated, I admit
08:53:33 <shapr> you can still make java-style classes and instances with monads, if you really wanted to do that.
08:53:37 <neologism> undereducated
08:53:48 <shapr> KC: so, are you completely confused now? :-)
08:54:16 <KC> true really true
08:54:30 <KC> :-(
08:54:32 <ibid> neologism: abadi & cardelli's theory of objects has a nice overview of classless oo
08:54:36 <shapr> the best way to get unconfused is to read code and write code.
08:54:56 <shapr> I would suggest Python for learning about good OOP practices, and Haskell for good FP practices.
08:55:02 <neologism> ibid: I think I am able to understand what ois classless oop
08:55:16 <neologism> I just dont use it so I dont have it hardcoded in my brain
08:55:23 * flaw likes Python
08:55:27 <KC> So C++ does'nt stand any where ?
08:55:30 <flaw> very easy on the eyes
08:55:48 <neologism> shapr: my ai proffesor always says: "its a sad thing to see a strange pascal program and then realize its lisp" :)))
08:56:02 <Amadan> sure, ugly badly designed oop procedural... :)
08:56:08 * RussellOConnor finds languages without a compile time type-checker frightening.
08:56:28 <shapr> I think types and type-checking are just one tool to have in your toolbox.
08:56:41 <KC> is blender written in Python
08:56:49 <shapr> no, but it has a Python scripting plugin.
08:56:58 <ibid> the sad thing is that you usually have to switch languages to switch typechecking on or off
08:57:05 <neologism> KC: definitely try haskell
08:57:09 <neologism> its a goodschool ;)
08:57:12 <RussellOConnor> I think finding that you misspelled a variable in you program after it has been running for 3 months is bad.
08:57:24 <Amadan> c++: all the beauty of C with all the simplicity of cobol
08:57:26 <KC> Ofcourse
08:57:31 <ibid> RussellOConnor: that has nothing to do with typechecking
08:57:34 <neologism> Amadan: ;)
08:57:54 <RussellOConnor> ibid, good point.
08:58:03 <ibid> RussellOConnor: to detect that you need to have an initialization checker; that is independent of typechecking
08:58:18 <ibid> though they are often combined
08:58:20 <KC> neo: yes i will
08:58:34 <RussellOConnor> Hmm, I guess there are 2 things I don't like about Python then. ... But I won't pass judgement untill I program in it.
08:58:58 <shapr> plus, type-checking isn't very useful by itself, only if you actually *use it*
09:00:55 <neologism> I think we can agree upon that C++ is bad while haskell is good ;)
09:01:35 <shapr> I haven't used C++ very much, but I do know I would not choose it to write production quality code.
09:01:57 <ibid> i kind of like C++, sometimes
09:02:02 <shapr> on the other hand, good programmers usually write good code in almost any language.
09:02:11 <shapr> and bad programmers write bad code in almost any language :-)
09:02:17 <neologism> shapr: on the other hand who can claim he IS a good programmer
09:02:20 <neologism> ?
09:02:30 <shapr> no one, but his friends can claim that.
09:02:52 <shapr> or her friends
09:03:05 * shapr looks at the various female members of #haskell
09:03:06 <Amadan> did you guys read the fake interview with stroustrup?
09:03:11 <ibid> their peers, really
09:03:38 <KC> yup i have read
09:03:51 <KC> it was really sick
09:04:06 <Amadan> sure it was a hoax, but i found myself agreeing with some of his points :)
09:04:19 <ibid> url?
09:04:24 <Amadan> http://www.edu-cyberpg.com/Technology/c++.html
09:04:26 <KC> shapr: true
09:04:52 <neologism> shapr: sorry I dont know how to write it gender neutrally except he/she
09:05:00 <neologism> but I wouldnt claim I am good programmer
09:05:33 <shapr> I think I'm an above average programmer when I have time to do things right.
09:06:02 <shapr> of course, after hacking on a bunch of the games in debian, above average is looking pretty easy.
09:06:15 <shapr> :-)
09:06:27 <Amadan> well, me neither (especially in this channel) - but i think i can measure one language against another, for a number of languages.
09:07:00 <Amadan> and i wouldn't touch a c++ project with an eleven-foot pole, even if the pole had a cute sister.
09:07:27 <Amadan> (okay, maybe i would - bosses tend to get grumpy at refusals)
09:07:42 <neologism> I am sometimes forced to use c++ (school)
09:07:50 <neologism> and it makes me even worse programmer ;)
09:20:32 <Philippa> <neologism> shapr: sorry I dont know how to write it gender neutrally except he/she <- "they" works well, and additionally won't offend somebody who isn't of the two classical genders
09:20:56 <Philippa> shapr: talking of games, I just built Adrian Hey's SDL bindings under win32
09:21:15 <shapr> neat!
09:21:34 <shapr> I wonder if some of the code from dark's SDL bindings can be integrated
09:22:51 <Philippa> I had to frig a little with the makefile (wasn't too bad) and the Package.conf (required some reading of docs)
09:23:05 <Philippa> in fairness Adrian did note that the makefile would need frigging with anyway
09:23:16 <shapr> I remember hearing that GHC6.x or later can be 'exported' to pure C for porting and easy bootstrapping
09:24:13 <shapr> is there any reason that shouldn't be the default way to distribute GHC? does that export entail path deps or something?
09:24:30 <Igloo> It's not portable C
09:24:41 <shapr> how unportable?
09:24:59 <shapr> actually, what keywords can I look for in the docs?
09:25:37 <Igloo> It's dependent on sizes of types, values of constants and suchlike
09:25:54 <Igloo> What are you trying to do?
09:26:27 <shapr> just trying to find an easier way for people to install ghc/darcs on systems without easy access to ghc binaries.
09:26:33 <Igloo> Given you have an x86 Linux machine, the porting process is straightforward now. It's just when it doesn't work you have problems, but there's no way you're going to fix that
09:26:58 <Igloo> I'd investigate making darcs work with nhc98 first
09:27:16 <shapr> ok
09:27:20 <Igloo> Although that won't help with 64-bit platforms. It would be a useful thing to do anyway, though, IMO
09:27:38 <shapr> nhc98 is 32-bit dependent?
09:27:48 <Igloo> But surely Linux/x86 and Windows covers almost everyone anyway?
09:28:15 <Igloo> Certainly breaks on 64-bit arches. Dunno about anything else
09:28:24 <shapr> yes, but building ghc and/or darcs is still a lot of work for most people.
09:29:20 <Igloo> Then make binaries available?
09:29:38 <Igloo> Everyone should just use Debian already  :-)
09:29:44 <shapr> I agree :-)
09:29:46 <neologism> Igloo: not me ;)
09:29:54 <neologism> I dont use linux nor windows
09:30:02 <Igloo> What do you use?
09:30:07 <neologism> freebsd
09:30:12 <neologism> and netbsd on sparc
09:30:21 <neologism> but your point is valid
09:30:23 <neologism> (of course)
09:30:24 <Igloo> Ah, Debian/FreeBSD now has CD images I believe
09:30:56 <Igloo> Although admittedly no GHC as I haven't got an account on a machine on which to make it  :-)
09:31:19 <neologism> I have ghc and hugs on fbsd
09:31:21 <MakeMyDay> possibly stupid question following:
09:31:22 <neologism> and no problem
09:31:35 <MakeMyDay> can you reverse the arguments in map?
09:31:53 <neologism> flip?
09:31:54 <MakeMyDay> I wan't the elements in my list to be the first argument of the function map uses
09:31:54 <monotonom> (flip map) mylist myfunc
09:32:05 <MakeMyDay> :o
09:32:10 * MakeMyDay slaps forehead
09:34:34 <MakeMyDay> ar..
09:34:53 <MakeMyDay> my function has a constant argument and I am getting a type error..
09:35:02 <MakeMyDay> like:
09:35:18 <MakeMyDay> (flip map) (list) (find g)
09:35:46 <neologism> what type is (find g) ?
09:36:44 <MakeMyDay> find					:: String -> Graph -> Maybe Node
09:37:13 <monotonom> And g::String? list::[Graph]?
09:37:44 <MakeMyDay> g is my Graph
09:38:11 <monotonom> list::[String]?
09:38:23 <MakeMyDay> yeah
09:39:02 <monotonom> (flip map) list ((flip find) g)
09:39:16 <monotonom> Some parentheses may be omitted.
09:39:19 <Igloo> I suspect you really wanted map (flip find g) list
09:39:52 <monotonom> Or develop "Arabic Haskell"!
09:40:39 <MakeMyDay> ar thx that works
09:42:21 <SyntaxNinja> reverse-polish haskell
09:55:27 <neologism> seeen this?
09:55:28 <neologism> (((DO SOMETHING!) SMALL) USEFULL) NOW!)
09:55:32 <neologism> (by bob bremer)
09:55:39 <neologism> bemer even ;)
09:58:58 * shapr bounces cheerfully
10:00:04 * Igloo bounces in a mips-possibly-working-soon sort of a way
10:00:16 <shapr> yay!
10:01:13 <Igloo> But then I thought it was working a couple of weeks ago before it mysteriously stopped  :-)
11:51:49 <shapr> y0 dnm 
11:52:41 <dnm> Hey shapr.
11:52:43 <dnm> You're up late.
11:52:55 <shapr> it's only 21:00
11:53:01 <dnm> True.
12:44:42 <Lemmih> How easy would it be to bind a certain key (C-cC-v) to a createComment function in emacs?
12:45:00 <shapr> very easy
12:45:16 <shapr> interactively, M-x global-set-key
12:46:31 <Lemmih> What about the createComment function?
12:47:10 <shapr> comment-region is most commonly used
12:47:55 <shapr> or maybe indent-for-comment
12:48:28 <shapr> interactive definitions disappear when you quit emacs though
12:48:35 <shapr> if you like it, you can put it into your .emacs
12:49:40 <shapr> (global-set-key "\C-c\C-v" 'indent-for-comment)
12:49:48 <shapr> that should work with gnumacs
12:51:07 <Lemmih> whoa, indent-for-comment is nice (-:
12:53:05 <Lemmih> But I was actually thinking of something like a box spanning several lines..
12:53:25 <shapr> oh, that's comment-region
12:53:30 <shapr> but you have to select a region first
12:53:42 <Lemmih> I'm not familiar with marks...
12:53:54 <shapr> control-space, then move the cursor somewhere
12:54:01 <shapr> then comment-region
12:54:28 <shapr> edwin2: hey, do you have read access to the Epigram cvs?
12:54:52 * edwin2 notes his #haskell tab turn blue
12:54:55 <edwin2> hi ;)
12:54:57 <edwin2> Yes, I do.
12:54:57 <shapr> hiya!
12:55:10 <Igloo> Oh, is it not public?
12:55:19 <shapr> the docs mention a test/ dir with cool examples, but it's not in the tarball
12:55:26 <shapr> how could I request a copy?
12:55:43 <Igloo> Oh, I see
12:55:44 <edwinb> Can you send me an email, and I'll sort it later? I'm just on my way out now!
12:55:57 <shapr> edwinb: oh hey, you're Edwin Brady...
12:55:58 <shapr> duh
12:56:01 <shapr> ok, no worries
12:56:24 * edwinb wonders who you thought he was...
12:56:33 <shapr> I just hadn't made the connection yet :-)
12:56:36 <edwinb> ;)
12:57:39 * Igloo guesses not the Edwin Brady of Edwin Brady Construction: Specialty Grouting and Concrete Repair
12:57:52 <edwinb> No, not that one. Curse him for beating me to top spot on google!
12:57:57 <Igloo> :-)
12:58:03 <shapr> I'd love to get a draft copy of your thesis
12:58:18 <Lemmih> shapr: Can I access the buffer directly? Like put-to-buffer, or something?
12:58:25 <edwinb> http://www.dur.ac.uk/e.c.brady/ps/thesis.ps
12:58:26 <Igloo> Eww, the one with a php page, though  :-P
12:58:35 <edwinb> Only not linked to due to bizarre university rules!
12:58:36 <shapr> Lemmih: sure, but that gets more complicated, what *exactly* do you want to do?
12:58:48 <edwinb> shapr: Incidentally, the docs should refer to examples/ rather than test/
12:58:52 <shapr> aha
12:58:59 <edwinb> Anyway, must go.
12:59:03 <shapr> thanks!
12:59:05 <edwinb> cheerio
12:59:10 * Igloo thinks "Java" on an any browser logo is a little odd
12:59:44 * kosmikus hopes that he'll have some time for epigram before afp
12:59:45 <shapr> epigram has a lot of cool ideas
12:59:46 <Lemmih> shapr: I want a comment like this: "------------\n-- x" where x is the cursor.
13:00:01 <shapr> oh, box comments
13:00:46 * shapr thinks
13:03:45 <shapr> ah, there's boxquote-region
13:03:55 <shapr> it's sort of overkill though
13:05:25 <shapr> actually, boxquote might be quite spiffy
13:11:54 * shapr notes fTerror in the epigram examples and agrees
13:12:22 <Igloo> ?
13:12:59 <shapr> I'm just being facetious :-)
13:13:20 <shapr> actually, I think epigram is very spiffy, I think I'm going to rip off some of its ideas for my dream editor.
13:13:22 <Igloo> Ah, OK, thought I was missing something  :-)
13:13:59 <shapr> huh, efficient runtime implementation of Peano numbers
13:14:30 <shapr> y0 pimpbot5000
13:14:31 <shapr> ltns
13:14:35 <wagle> unary?
13:14:55 <pimpbot5000> what up
13:15:22 <pimpbot5000> might anyone know where i can find the (%) operator in GHC?
13:15:34 * shapr laughs at edwinb's ACKs 
13:15:40 <shapr> @index (%)
13:15:40 <lambdabot> bzzt
13:15:55 <shapr> pimpbot5000: where'd you find it?
13:16:08 <Igloo> Do you mean its definition?
13:16:11 <pimpbot5000> yea
13:16:16 <RussellOConnor> you mean `mod'?
13:16:20 <pimpbot5000> im trying to compile an old haskell parser
13:16:21 <shapr> @index %
13:16:21 <lambdabot> Data.Ratio,GHC.Real,Ratio
13:16:26 <shapr> aha
13:16:26 <pimpbot5000> http://www.pms.ifi.lmu.de/mitarbeiter/panne/haskell_libs/hsparser.html
13:16:44 <RussellOConnor> oh the rational thing
13:16:48 <pimpbot5000> there are a number of tweaks to make it compile with ghc 6.2
13:16:58 <Igloo> (%) should be in scope by default
13:17:37 <Igloo> Oh, maybe not. Data.Ratio would be the recommended place to get it from today IMO, anyway
13:18:06 <pimpbot5000> yea, there are a number of prelude ops not in default scope with GHC
13:18:07 * Igloo wonders why hugs thinks it is in scope by default
13:18:12 <wagle> 6.2.1 ghci for macosx doesn't have % by default
13:18:40 <wagle> i think its in the hugs prelude
13:18:53 <pimpbot5000> hmm, now it's saying map is not in scope
13:19:51 <wagle> % is used a lot in the hugs prelude..  and the prelude includes Ratio
13:20:16 <wagle> prolly because hugs is primarily an interpreter, and ghc is a compiler
13:29:11 <Lemmih> shapr: Thank you, It's really nice. (-:
13:43:56 <shapr> :-)
14:01:46 <bourbaki> esap you awake?
14:06:16 <bourbaki> night
15:59:17 * TheHunter wonders why most cs students think every language they don't know must be useless
15:59:39 <Riastradh> Because they don't know how useful it can be!
16:00:52 <TheHunter> if i don't know something i admire all people who do, i don't think they're fools who're doing useless stuff
16:01:12 <Riastradh> Yes, but you're a minority.
16:11:33 <blackdog_> there are _some_ forms of useless knowledge... do you admire people who memorise football trivia?
16:14:32 <Riastradh> Yes.  I admire how trivial people are able to make themselves.
16:16:21 <lament> Most languages are useless.
16:16:29 <lament> Consider Haskell :)
16:17:37 <blackdog> it's a skill of sorts, i suppose
16:18:20 <Riastradh> I wasn't aware that people were actually capable of that magnitude of triviality without keeping a lifeline of wit like Oscar Wilde.
16:21:21 <monotonom> The people who know all the football trivia are the same people who say math is useless.
16:22:02 <monotonom> "Why would you memorize trig identities?"
16:24:40 <monotonom> Tyranny of the majority.
16:24:41 <lament> football trivia is a lot easier to memorize for many people
16:48:48 <Cale> lament: Yes, consider Haskell, because it isn't :)
21:57:48 * SyntaxLaptop adds clean target to Cabal
22:09:48 <monotonom> make clean is very good.
22:14:42 <SyntaxLaptop> :)
22:54:10 <Gahhh> what does pascal have over C ?
23:17:44 <jesse> well it differs, in that it has strong typing
23:23:02 <jesse> and a simpler syntax
23:23:39 <jesse> simpler for computers anyhow
