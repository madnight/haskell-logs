03:24:52 <Janni> Hi. Long time no see... if someone remembers me at all...
03:27:23 <Janni> The last months I wrote two packages (in Java |:p) for reading/creating/writing ELF-files and DWARF2 debug information. Now I'm doing the same in Haskell. Don't know why. Probably want to see it again...
03:28:13 <Janni> That is, the effect of being 5 times faster, having 1/10 of code and having 10 times fun...
03:29:11 <Janni> I guess, I'll really try to get a job, where I'll be able to do functional programming and definitivly NOT Java.
03:29:25 <Janni> Anyways, I have a question.
03:30:25 <Janni> Currently I'm using Hugs and I'm looking for a better way to read in words, sbytes, ubytes and whatnot
03:30:59 <Janni> I wrote functions like "readUnsignedByte input = fmap ord (hGetChar input)
03:31:41 <Janni> ", but I don't I want to use hGetChar for reading in bytes...
03:31:47 <Janni> +think
03:32:24 <earthy> um. true.
03:32:35 <Janni> Yes! Someone responding!
03:33:09 <earthy> well, shapr is obviously off unicycling or somesuch... ;)
03:34:11 <Janni> If it's possible I'd like to be able to use hugs, so want to be sure before using GHC function...
03:34:15 <Janni> s
03:34:30 <earthy> ah.
03:35:12 <earthy> well, openBinaryFile and friends are in hugs' IOExtionsions.hs
03:35:34 <earthy> --   readBinaryFile         : versions of readFile, writeFile, appendFile,
03:35:34 <earthy> --   writeBinaryFile        : and openFile for use on binary files
03:35:34 <earthy> --   appendBinaryFile       : (These don't do LF <-> CR-LF translation on
03:35:34 <earthy> --   openBinaryFile         :  DOS/Windows systems.)
03:36:26 <earthy> whereas they are in System.IO for ghc
03:36:49 <Janni> Yes, but the only reading operations I can commit with the resulting handlers are hGetChar, etc...
03:38:23 <earthy> primitive readBinaryFile         :: FilePath -> IO String
03:38:35 <earthy> dunno, sounds quite reasonable to me.
03:38:59 <Janni> Yes right, but I would have to extract the bytes from the string
03:39:11 * earthy nod
03:39:12 <earthy> +s
03:39:34 <earthy> for full binary you're stuck with going to ghc's System.IO
03:40:22 * Janni say's bye to hugs
03:40:35 <earthy> and dealing with buffers yourself and such stuff
03:52:20 <Janni> Well, I don't really see something better, that GHC offers, so I'm sticking with hugs
03:53:26 <Janni> But still, I think it's strange that there are no such Operations like "readSignedByte :: Handle -> Int".
03:53:46 <titanstar> ghci lets you define functions on the command prompt using let
03:53:49 <titanstar> that's useful
03:54:27 <Janni> Er? Does that something have to do with my problem?
03:54:46 <titanstar> probably not
03:54:49 <Janni> Ah, I see, you want to cover up some advantage of GHC...
04:03:36 <Janni> BTW, does anybody know, what fmap stands for?
04:04:03 <Janni> I don't think this name really make sense
04:11:20 <ustenzel> Janni: can hugs access C functions via the ffi?
04:14:25 <Janni> Ja
04:15:30 <kosmikus> Janni: I think the "f" is for "functor"
04:16:58 <Janni> Stimmt wohl. Trotzdem ergibt das "map" dadrin wohl nicht viel Sinn..
04:18:24 <ustenzel> Janni: you could call read(2) and extract bytes from a buffer.  Ugly?  Yes, but it certainly works.
04:19:43 <kosmikus> Janni: why not?
04:19:48 <Janni> Can you tell me _which_ "read" you mean?
04:20:17 <ustenzel> the one from the C-library.
04:20:18 <Janni> In Haskell "mapping" means evaluating a function over a list
04:20:32 <kosmikus> yes, and it's a generalization of that
04:21:20 <kosmikus> evaluating a function over a data structure
04:22:55 <Janni> Can I somehow import all Constructors of a data-type?
04:23:29 <Janni> (I mean without defining them all explicitly)
04:23:34 <ustenzel> import Module ( Type(..) )
04:23:53 <Janni> Oh well, it was a long time ago... thi
04:23:57 <Janni> s/thi/thx
04:39:14 <musasabi> morning
04:41:27 <musasabi> Janni: well you could read things as an array of bytes... (or even use the Binary but that works only with nhc96 (there is a ported version for other compilers too))
04:43:07 <Janni> Hafta go
04:52:50 <Si\> Has anyone ever heard of any work on a complete XML Schema Parser? Because if not I'm going to write one
04:53:03 <Si\> in Haskell naturally ;)
04:54:32 <musasabi> should be quite easy with one of the xml toolkits
04:57:08 <Si\> Oh, I'm quite sure of it using HXT, just don't wanna make sure some already hasn't written something 100 times better than I could manage with my highly limited mind :D
04:57:28 <Si\> sp/don't/
04:58:30 <kosmikus> doesn't uuxml have a schema parser?
04:59:04 <Si\> if it does, I haven't found it ye
04:59:05 <Si\> t
04:59:37 <Si\> plus, even if it did, it would probably be implemented in Generic Haskell, and I want it in Haskell 98 (or thereabouts)
05:00:33 <Si\> The UUXML paper presents a set of abstract data-types which can be used to represent element and attribute construction in XML Schema
05:00:54 <Si\> it does not however provide methods of building XML Schema from Haskell data-types
05:01:19 <kosmikus> you want to build a schema from a datatype? or the other way around?
05:01:46 <Si\> both preferably, plus all the possible extensions such as those employed in WSDL type representation
05:03:00 <Si\> HAIFA currently can build simple ad-hoc skeletons from annotated Haskell code, and generate the associate server node code, but cannot deliver any form of Discovery information
05:04:07 <Si\> a key part of describing a service node is type-representation, and this is done in most cases by XML Schema, so I gotta build something that can generate clean Haskell data-types from and XSchema
05:04:33 <Si\> and extension to the Skeleton generator for data-type output to XSD
05:50:18 <musasabi> Has someone done CSP in haskell?
05:50:45 <ozone> musasabi: i think you can use the continuation monad to do that, and more
05:51:11 <musasabi> ozone: does the continuation monad support first class continuations?
05:51:28 <musasabi> I tried to use it for stuff but it looked like those were simple escapes :-(
05:51:29 <ozone> iirc, yes
05:51:52 <shapr> aw, I missed Janni
05:51:57 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/Cont.hs does not work, at least.
05:53:27 <musasabi> or works like they were simple escapes.
05:53:37 <ozone> musasabi: did you see the shift/reset continuation combinators on the haskell wiki?
05:54:56 <musasabi> "The type of continuations callCC provides are called escape (or abortive) continuations, because when called they immediately abort the rest of the computation and return whatever is passed to the continuation." :-(
05:56:30 <ozone> what are you looking for?
05:56:46 <musasabi> ozone: saving state and then resuming it later.
05:57:05 <musasabi> scheme's call-with-current-continuation would be fine.
05:58:16 <musasabi> Of course continuations can be emulated using CPS + saving the thunk, but is there any automated CPS transformer?
05:58:46 <earthy> yes. ContT
05:58:55 <ozone> i don't know enough about continuations to be authoritative, but i think this page has what you're looking for: http://www.haskell.org/hawiki/MonadicContinuationPassingStyle
06:00:27 <earthy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.Cont.html#t%3AContT
06:02:07 <musasabi> The problem with ConT seems to be that invoking an escape continuation will allways return to the most recent invocation of the runCont, not the one that created it.
06:03:06 <earthy> how do you mean?
06:03:50 <musasabi> earthy: I want to use continuations to resume prosessing not as an escape handler.
06:04:07 <earthy> um, yes.
06:04:20 <earthy> that is quite usual.
06:04:33 <musasabi> can you show one simple haskell example of that?
06:04:53 <earthy> just a sec, have to type one up
06:05:15 <musasabi> that is save a bunch of continuations somewhere and then select a random one to continue (just like my example only working)
06:06:04 <earthy> http://www.haskell.org/hawiki/ContinuationPassingStyle
06:06:15 <earthy> has exactly such an example.
06:06:17 <musasabi> earthy: that is different.
06:06:29 <earthy> how so?
06:07:21 <musasabi> earthy: try to implement save from the example with that, and you will see it is impossible.
06:07:23 <earthy> the 3 different continuations passed to solve_quad are in a sense analogous to the resumptions you require, no?
06:07:44 <musasabi> earthy: not really.
06:07:53 <earthy> `ah'
06:08:05 <earthy> okay, I'll look at your code for a bit.
06:14:46 <earthy> right. so, you want to put continuations in a table and then select which one to use?
06:15:21 <musasabi> yes.
06:15:27 <earthy> why? :)
06:16:11 <musasabi> earthy: well it allows threading, and saving state in e.g. web applications, snapshots of state in text editors etc
06:17:26 <musasabi> and one thing is that I just want to be able to express it in haskell ;)
06:17:35 <earthy> you want shift and reset then
06:17:48 <musasabi> since I can do it in SML, Scheme and Ruby too.
06:18:14 <earthy> ?
06:18:28 <musasabi> earthy: the table example works in them easily.
06:18:48 <earthy> thing is that you have mutable state in those 3 languages
06:19:01 <earthy> that is implicitly passed to the continuation
06:19:05 <musasabi> yes, so it *should* be simpler in haskell.
06:19:25 <earthy> you'd have to *explicitly* pass the table containing the continuations to select from *to* the continuations as well
06:19:31 <earthy> which is harder to specify
06:19:36 <ozone> arrows?
06:19:41 <ozone> (talking out of my arse)
06:19:48 <earthy> ozone: totally. :)
06:19:57 <ozone> reading an interesting post on LtU about it
06:19:59 <musasabi> earthy: well if it is a mutable table behind a global IORef ;)
06:20:01 <ozone> i'll spam the channel with it
06:20:09 <ozone> Maybe one way to regard the arrow paradigm is as "reified continuation passing-style", because the continuations become ADTs, so you can look into and examine them. (If you've read Friedman, Wand and Haynes' "Essentials of Programming Languages" (1st edition), this is sort of what they do in section 10.3, where they transform a CPS interpreter into a stack interpreter by representing continuations as data structures.) You can't do 
06:20:16 <ozone> how much of that did you get? :)
06:20:33 <earthy> `You can't do
06:20:34 <earthy> '
06:20:44 <ozone> You can't do that with monadic values because the second argument of >>= is a function, and those are opaque. (Indeed, this is basically what motivated the introduction of arrows, I think.) And you certainly can't do it with CPS because _everything_ becomes a function.
06:21:56 * earthy nods
06:22:19 <earthy> anyway, musasabi, read the notes section on http://www.haskell.org/hawiki/MonadCont
06:22:25 <earthy> which is *directly* applicable to your problem
06:22:43 <ozone> that's what i thought
06:22:53 <ozone> looks like shift/reset should be able to handle it
06:23:02 * earthy nods
06:23:33 <ozone> and just in case they can't, arrows solve everything ;)
06:24:03 <earthy> ozone, one man arrow evangelization team!
06:24:24 <ozone> well, i think i'll be more evangelizanish after reading the fudgets thesis
06:24:31 <ozone> but it'll have to be a bloody boring weekend for me to do that
06:25:28 * earthy laughs
06:25:32 <earthy> I know the feeling ;)
06:25:42 <ozone> what the hell is the strict monad?
06:25:48 <ozone> A related monad (not part of Control.Monad) is the Strict Monad that strictly evaluates the arguments to a function before applying it. In this case, the sequential ordering is significant and is the order in which the arguments will be evaluated. The Strict monad can be had by changing f x to f $! x.
06:25:53 <ozone> i've never heard of it
06:25:57 <ozone> (that's on the MonadIdentity page on the hawiki)
06:26:09 <ozone> that sounds _hella_ useful
06:26:43 <earthy> it is MonadIdentity with f x changed to f $! x
06:27:01 <earthy> in (Identity x) >>= f = f x      -- i.e. x >>= f = f x
06:27:28 <ozone> hmm
06:27:30 <musasabi> well /me tries to read about shift/reset more, most of the papers about it just described it at lambda calculus level, now found something more applicable...
06:27:46 <ozone> earthy: and that's different from the ST.Strict monad in that order of evaluation isn't defined?
06:27:58 <ozone> (except that arguments to functions are evaluated before the function call, obviously)
06:29:13 <earthy> unsure
06:29:48 <ozone> hmm
06:29:55 <ozone> i thought it would be a killer optimisation
06:30:07 <ozone> if you want stuff to be strict, easy, just evaluate everything in a strict monad
06:30:12 <earthy> ah, right, no, ST.Strict maintains state
06:30:19 <earthy> which Strict doesn't
06:30:23 <ozone> as opposed to deepSeq'ing the crap out of everything
06:30:25 <ozone> right
06:30:31 <earthy> it *only* guarantees strict evaluation
06:30:57 <ozone> sure, but i thought it would help heaps for scenarios where laziness performance problems kills you
06:31:15 <earthy> yup, could.
06:32:20 <Igloo> It will only do seqing, not deepSeqing, no?
06:32:36 <ozone> Igloo: well, i guess that would depend on how you define the monad
06:32:46 <ozone> you can always make a DeepThroat, err, DeepStrict monad, i figure :)
06:32:56 <Igloo> *nod*
06:42:09 <reffie> DeepThroat \o/
06:46:54 <musasabi> There seems to be an abundance of papers on how to implement shift/reset with call/cc, but nothing really applicable that I could understand...
06:48:16 <musasabi> shift/reset seems to be more for cases where the places of capture and invokation are directly related with each other.
06:55:25 * shapr beats the Auto Arrow with a stick
06:55:49 <shapr> stick :: a -> Beaten a
06:56:13 <ozone> sup shapr
06:56:21 <shapr> beatage
06:56:26 <shapr> err
06:56:29 <shapr> of this misbehaving idea
06:57:02 <shapr> ozone: I'm still not sure how to fit a protocol into the Automaton arrow
06:57:05 <shapr> you have any advice?
06:57:18 <ozone> reading all this stuff about CPS is destroying my brain
06:57:28 <ozone> err, see a gypsy?  what? :)
07:01:31 <ozone> wow
07:01:37 <ozone> the UsingMonads page on the wiki kicks ass now!
07:02:10 <shapr> hey, I think I'm going to retroactively relicense the wiki
07:02:20 <ozone> uh oh
07:02:24 <shapr> any complaints?
07:02:35 <shapr> ok then, since no one minds...
07:03:04 <shapr> seriously though, I was thinking of a BSD license for the content
07:03:09 <shapr> any thoughts on that?
07:03:26 <earthy> as I don't have any content on the wiki I'm fine with it. :P
07:03:42 <norpan> is there any current license?
07:03:44 <shapr> I've written some stuff on the wiki
07:03:54 <ozone> why is it that after all this time, my brain still hurts when looking at monads
07:04:08 <shapr> ozone: because arrows are easier to think about
07:04:15 <ozone> argh, no
07:04:17 <shapr> norpan: nothing that I'm aware of
07:04:18 <ozone> quiet!
07:04:28 <norpan> license suck
07:04:28 <shapr> I really do think arrows are easier
07:04:34 <norpan> everything shoud be public domain
07:04:39 <shapr> oh I agree
07:04:40 <earthy> monads are brainwarping
07:04:47 <shapr> with the public domain part
07:04:54 <earthy> and your brain is of strong rubber: it won't let itself get warped that far
07:05:07 <ozone> earthy: i found that out when i was first introduced to lambda calculus
07:05:18 <ozone> as chilli said, "dont worry, your brain will be thankful after it has reconfigured itself"
07:05:19 <norpan> it's not like anyone expects to gain anything else but improving the wiki by writing in the wiki
07:05:25 <ozone> i still dunno about that
07:05:30 <shapr> bok Amadan 
07:05:40 <ozone> shapr: so tell me what arrows are
07:05:49 <ozone> cos everytime i think i have a grip on them, i read another page of that damn paper and cry
07:05:49 <shapr> norpan: even so, I'd like to explicitly license stuff like PreludeExts
07:05:56 <shapr> ozone: which one, the FoP paper?
07:05:57 <earthy> what paper? :P
07:06:03 <earthy> the FoP paper is cool
07:06:10 <shapr> Ross Patterson's FoP chapter is nice
07:06:17 <Amadan> hello again
07:06:33 <ozone> FoP?
07:06:33 <shapr> Amadan: long time no see, how's code?
07:06:38 <ozone> the original hughes one on arrows
07:06:39 <shapr> Fun of Programming
07:06:44 <shapr> ozone: oh, I agree, that one hurts
07:06:59 <shapr> it helped me somewhat to talk to Hughes himself about his paper
07:07:02 <earthy> ugh, yeah. that's horrid in a sense
07:07:03 <ozone> is this FoP paper downloadable?
07:07:07 <shapr> sure yeah
07:07:17 <norpan> the current "copyright is implied" stuff sucks
07:07:24 <shapr> norpan: where's that?
07:07:25 <ozone> i think i totally lost it when the hughes paper started talking about using arrows to model state of web transactions
07:07:35 <shapr> ozone: me too
07:07:37 <norpan> shapr: it's there if you don't specify anything
07:07:37 <ozone> i get using continuations to model web state, but arrows?  aieeee
07:07:43 <norpan> copyright is the default
07:07:50 <shapr> but Patterson's paper brings it together better
07:07:56 <musasabi> ozone: one can model continuations with arrows.
07:08:06 <ozone> musasabi: yeah, i know that much
07:08:06 <shapr> ozone: I read Hughes' paper six times in a row, and I still didn't get that much of it
07:08:11 <ozone> so where's this FoP paper?
07:08:22 <shapr> I haven't finished Patterson's paper because I understand enough that I had to try to write some code!
07:08:34 <shapr> http://www.soi.city.ac.uk/~ross/papers/fop.html
07:08:50 <shapr> Amadan: how's programming treating you?
07:09:18 <shapr> bonjour rubix^3, comment ça va?
07:09:31 <ozone> it appears i've already downloaded it
07:09:35 * ozone goes to re-read
07:09:36 <earthy> The Hughes thing is quite huge as well
07:09:40 <earthy> at 41 pages
07:09:50 <ozone> my co-workers must think i'm crazy
07:10:06 <Amadan> shapr: yellow belt :)
07:10:09 <ozone> one minute, i'm working on multimedia, next minute, i'm trying to figure out category theory
07:10:23 <shapr> Amadan: yay!
07:10:32 <earthy> ozone: what is so crazy about that?
07:10:38 <shapr> ozone: oh hey, I had some neat ideas about QuickCheck and category theory
07:10:43 <shapr> and monads for that matter
07:10:53 <musasabi> monads are simple in principle imho, just not very suitable for programming. a little bit like goto.
07:11:07 <shapr> I think most of software testing is about checking specific instances of rules like transitivity, commutativity, etc
07:11:17 <ozone> shapr: oh?
07:11:19 <Amadan> shapr: i found some exercises by some guy who teaches/taught haskell, and i started solving some of them in my spare time
07:11:24 <earthy> `Monads considered harmful -- musasabi'. :)
07:11:27 <shapr> with QC, I think you could write commutativity and transitivity combinators!
07:11:29 <musasabi> "goto is a good thing, you can do all kinds of loops and errorhandling with it."
07:11:41 <shapr> Amadan: oh neat!
07:11:56 <ozone> earthy: well, i dunno how many people this year will be attending ACM Multimedia + ICFP :)
07:11:57 <shapr> ozone: I got this idea from looking at Debug.QuickCheck.Util
07:12:10 <shapr> ozone: you could chaneg the Multimedia world!
07:12:26 <Amadan> shapr: http://www.cs.ou.edu/cs1323h/handouts/index.html
07:12:30 <ozone> soembody here had the idea of modelling gstreamer via arrows
07:12:39 <ozone> Igloo: who was that?
07:12:50 <Amadan> shapr: pretty basic, but it's a start.
07:12:53 <earthy> ozone: 1? :)
07:13:17 <ozone> earthy: yes, that's a good guess :)
07:13:27 <ozone> shapr: i don't think i get you yet
07:13:33 <ozone> i'm a bit slow, y'see
07:13:38 <ozone> being an ex-convict and all
07:14:58 <shapr> hah
07:15:13 <shapr> ozone: I'm an ex-rebel-secessionist
07:15:16 * shapr wonders if that's a word
07:15:24 <shapr> ozone: which part?
07:15:35 <ozone> shapr: i'm actually a vampire
07:15:43 <ozone> the upside is that i get to dance with kate beckinsale
07:15:46 <ozone> anyhoo
07:16:01 <ozone> shapr: umm, ok, i understand what transitivity, commutivity, and combinators are
07:16:17 <ozone> the bit you lose me at is how that applies to QC
07:16:51 <ozone> curse these paper writers
07:17:03 <ozone> if you guys ever write a paper, can you _please_ use more descriptive things than one-bloody-letter variable names?
07:17:12 <shapr> yah, I agree with that
07:17:19 <shapr> even worse, different letters in different functions
07:17:20 <ozone> "addND f g b" is quite a bit less clear than "addND func1 func2 value"
07:17:29 <shapr> my mental alpha renamer isn't very good
07:17:51 <shapr> so I'd like it if the letters matched in the different code bits in such a way as they would when executing
07:18:26 <shapr> ozone: http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Debug.QuickCheck.Utils.html
07:19:46 <ozone> hmmm
07:19:58 <ozone> i wasn't even aware QC could do that.  neat
07:20:02 <ozone> (to say the least)
07:20:26 <shapr> thing is, that can go a lot further
07:20:49 <shapr> I suspect you could use that same idea to test monad and arrow laws
07:21:44 <shapr> I'm not the first one to have this idea, SyntaxNinja alread wrote some code to try that
07:21:46 <ozone> ah.  sounds sensible ...
07:23:28 <shapr> did you read the automaton part of Ross's paper?
07:23:39 * ozone ponders if you could write 'type a b :>: = Arrow a b' in GHC
07:23:45 <ozone> getting to it ...
07:24:02 <shapr> for years I've wanted to be able to specify a protocol as a 'specification' that's a combination of a state machine and some parsers.
07:24:29 <musasabi> erlang folks have some tools for that.
07:24:31 <shapr> I think the Auto arrow might be able to do that, but I haven't figured out how to turn it into actual code.
07:25:43 <Igloo> ozone: Phubuh?
07:26:25 <ozone> Igloo: ah, thanks.
07:28:23 <shapr> gutentag basti_ 
07:28:54 <shapr> hej chucky 
07:29:05 <chucky> hello shapr
07:29:07 <basti_> hi all
07:29:16 <shapr> chucky: wassup?
07:29:30 <basti_> chucky the killer puppet?
07:29:46 <chucky> doll, if I may. :)
07:30:08 <basti_> oh i see
07:30:14 <basti_> my apologies
07:30:28 <chucky> :)
07:31:10 <ozone> ok
07:31:13 <ozone> i still don't get arrows.
07:31:27 <shapr> have you understood his Auto type?
07:31:31 <shapr> data Auto a b = Auto (a -> (b, Auto a b))
07:31:35 <ozone> yep.
07:31:53 <shapr> do you think that could be used to model a protocol like smtp?
07:31:59 <chucky> I think the "I still don't understand arrows/monads" has to be one of the most used phrases on this channel. :)
07:32:20 <ozone> chucky: sssh, stop making me feel average!
07:32:32 <basti_> lol
07:32:38 <chucky> lol
07:32:42 <basti_> I now understand monads, btw.
07:32:55 <shapr> bah, anyone who's gotten far enough to know that they do not understand monads/arrows is above average.
07:33:00 <ozone> shapr: hmm.
07:33:04 <chucky> I haven't even tried understanding arrows yet, so does that make me sub-average?
07:33:07 <ozone> what's the output of smtp?
07:33:23 <Amadan> I still don't understand arrows/monads :)
07:33:28 <ozone> chucky: maybe it makes you super-average!
07:34:06 <ozone> shapr: is the output the response(s) from the server?
07:34:06 <chucky> ozone: lol, yeah. Or maybe I'm just "unique" :)
07:34:07 <shapr> ozone: I was thinking, smtp server would be Auto (a -> (b, Auto a b)) with a being the input from the client, and b is the response, and the new Auto is the next state
07:34:16 <earthy> I don't understand arrows, but I think I understand monads
07:34:17 <ozone> ok
07:34:22 <ozone> i'm with you there
07:34:38 <ozone> so you mean, use an arrow to model one side of the SMTP conversation
07:34:46 <earthy> should be possible
07:35:11 <shapr> y0 SyntaxNinja 
07:35:16 <ozone> i thought you meant using an arrow to model the "whole" SMTP transaction
07:35:20 <ozone> (both sides)
07:35:24 <ozone> sup isaac
07:35:33 <andersca> hey SyntaxNinja
07:36:26 <shapr> ozone: you think that could work?
07:36:37 <ozone> shapr: i thiiink so.
07:36:42 <ozone> i'm trying to think about it in terms of code.
07:37:03 <ozone> so you have, say, this Arrow Auto instance.
07:37:07 <ozone> how do you write an SMTP server with that?
07:37:33 <ozone> i mean, if i can write an SMTP server in 10 lines, i think i'll be a slightly better haskell advocate. :)
07:38:14 * shapr is thinking
07:38:14 <musasabi> That needs to work with timeouts too.
07:38:21 <ozone> screw timeouts for the time being
07:38:30 <SyntaxNinja> hi shapr, hi ozone
07:38:37 <musasabi> screw code that can be used in real world?
07:38:50 <Igloo> What do you mean both sides?
07:38:55 <SyntaxNinja> hi andersca
07:38:57 <ozone> musasabi: when i'm trying to understand arrows, yes, screw code that can be used in the real world!
07:39:06 <reffie> hi hi hi
07:39:40 <musasabi> ozone: well it adds a requirement to the arrow so, it needs to be taken into account in the design.
07:39:46 <ozone> Igloo: i thought initially that shapr was talking about modelling an entire SMTP transaction with arrows
07:39:57 <ozone> well, he is
07:40:00 <norpan> case stdin of { "HELO":x -> "250 i.am.great"; x -> "502 Not implemented }
07:40:01 <ozone> how do i express this ...
07:40:49 <shapr> man where's ski when you need him ...
07:40:51 <ozone> Igloo: i was thinking "what's the output of the arrow" with respect to the smtp transaction, rather than from the perspective of either the server or the client
07:40:56 <shapr> I bet ski would know the answer to this.
07:41:20 <ozone> musasabi: well, i'm dictating it's not a requirement for the purposes of this example, if you want to get pedantic
07:41:35 <musasabi> ok...
07:41:49 <Igloo> OK, so is that the wrong way to think about it or am I more confused than normal?
07:42:12 <shapr> Igloo: I'm just trying to jump from the arrows papers into using an arrow in actual useful code
07:42:19 <basti_> ozone: i would say, nothing?
07:42:26 * Igloo vaguely ponders reading about arrows and trying to write something like an SMTP one myself
07:42:33 <basti_> i mean whats the result of a SMTP transfer... a changed state on both ends
07:42:37 <shapr> and the Auto datatype sort of looked like I could use it to model protocols
07:43:03 <shapr> since a procotol could be thought of as a state machine and some parsers
07:43:46 <shapr> at the most general, you could fill in 'data Auto a b = Auto (a -> (b, Auto a b))' with data Auto String String, with strings for input from the client and strings for output to the client
07:44:15 <shapr> might be more sensible to a Reply type
07:44:29 <ozone> sure
07:44:31 <ozone> i get that
07:44:35 <shapr> where the code would look like Reply 250 "OK"
07:44:35 <ozone> i don't get how to write it. :)
07:44:42 <ozone> write the code, that is
07:45:20 <Igloo> What's the best thing to read assuming 0 arrow knowledge OOI?
07:45:32 <shapr> I'd say Patterson's FoP chapter
07:45:37 <ozone> lemme actually try breaking out some code
07:45:44 <Igloo> Ah, that's convenient
07:45:47 <norpan> just a simple state machine
07:45:54 <shapr> ozone: I dunno either, but I can randomly try stuff and see what doesn't work until I get something that sort of does
07:46:04 <Igloo> :-)
07:46:07 <ozone> that's what i usually do
07:46:14 <shapr> each Auto should be a 'state'
07:46:45 <shapr> so, are Session initiation and Client initiation separate states, or is there a single NotAuthenticated state?
07:47:28 <shapr> -> HELO<SP><domain><CRLF>
07:47:33 <shapr> hiya Janni!
07:47:34 <Janni> Hello.
07:47:36 <shapr> <- 250 OK
07:47:40 <shapr> or <- 550 Relaying not allowed
07:48:12 <basti_> i guess that is free to choose
07:48:42 <Janni> What luck, that there are still Haskellers who remember an ol' fella. Times are rough...
07:48:52 <shapr> if it's a 250 OK, you return a new Auto that can then MAIL FROM:
07:48:54 <Janni> s/remember/recognize
07:49:05 <shapr> Janni: you still playing lots of soccer?
07:49:12 <Janni> :)
07:49:34 <reffie> you mean football
07:49:37 <Janni> Not much. As time passes, people change, and so do I
07:49:58 <shapr> if it's not a 250 OK, you return the original Auto that was executed to do Client initiation
07:50:11 <shapr> so I guess that means init of Client and Session have to be separate
07:50:52 <shapr> ozone: sounds sensible so far?
07:51:23 <ozone> shapr: sure.  i'm still pondering how on earth to write the code. :)
07:51:47 <shapr> well, I'm hoping the >>> or something will do all the execution for me
07:52:14 <shapr> have you seen the arrow instance for auto?
07:52:21 <ozone> yep.
07:53:28 <Janni> What are you working on? (JFMI)
07:53:50 <shapr> trying to turn the automaton arrow in Ross Patterson's Fun of Programming chapter into a protocol arrow
07:53:59 <shapr> as a concrete instance, I'm trying to do SMTP
07:54:18 <Janni> Weren't you doing this a year ago?
07:54:20 <shapr> ozone: so, I'm going to guess that the a part needs to be a socket handle?
07:54:23 <shapr> probably so
07:54:27 <shapr> I'm slow ;-)
07:54:40 <musasabi> In the SMTP case you have the added problem of various orderings.
07:54:41 <shapr> actually, I think I was doing monadic SMTP last year.
07:55:29 <ozone> shapr: let's just assume it's a String for now
07:55:37 <shapr> ok
07:55:43 <ozone> "HELO\nQUIT" will do. ;)
07:55:50 <shapr> yes
07:56:25 <shapr> or with runAuto, ["HELO","QUIT"]
07:56:59 <shapr> actually, it looks just fine with runAuto
07:57:11 <ozone> shapr: are you coding this up right now?
07:57:15 <shapr> but I still don't see how composition of two SMTP arrows does anything
07:57:55 <SyntaxNinja> Pisces: (Feb. 19—March 20)
07:57:55 <SyntaxNinja> An unusual series of events will teach you to never underestimate the abilities of a master [Syntax] Ninja or pastry chef. -- theonion
07:58:03 * shapr grins
07:58:11 <shapr> too bad I'm a virgo
07:59:37 * Igloo hands SyntaxNinja the Dummies Guide to Haskell. Did I mention I'm a sagittarius?
08:01:02 <Janni> I had asked this earlier that day in here: I need to read signed/unsigned bytes, etc. from a file. What would you do to achieve that? Probable create a Handle trying to get the bytes out of it? That's what I did, too but since there is no method like hReadUnsignedByte, I ended up using :
08:01:07 <Janni> readUnsignedByte :: Handle -> IO Int
08:01:14 <Janni> readUnsignedByte input = fmap ord (hGetChar input)
08:01:40 <Janni> But I don't really think that nice code, using hGetChar for reading a byte...
08:02:18 <Janni> Although I didn't find a better solution browsing through the GCC library. Isn't that weak?
08:02:21 <Igloo> Because of efficiency or because byte /= Char?
08:02:27 <SyntaxNinja> Igloo: why the dummies guide?
08:02:42 <Igloo> Syn: Underestimating your abilities...
08:02:59 <Janni> Igloo: Look at that:
08:03:00 <Janni> readSignedByte :: Handle -> IO Int
08:03:00 <Janni> readSignedByte input = fmap sign (readUnsignedByte input)
08:03:00 <Janni>   where sign unsigned = if unsigned > 127 then 127 - unsigned else unsigned
08:03:02 <Igloo> Are Dummies Guides an international thing or just a UK thing?
08:03:33 <basti_> in germany we have "dummie's guide" too
08:03:39 <shapr> in the US also
08:04:10 <basti_> but i doubt there is need for a "dummie's guide to haskell". Dummies per definition don't do haskell.
08:04:13 <basti_> or do they?
08:04:17 <earthy> ummmmmm.
08:04:27 <earthy> well. uummmm.
08:04:30 <Amadan> well, since we have 'em in croatia, that means it's really international... :)
08:04:32 * Janni doesn't want to believe he has to search for an external library for such a task...
08:04:35 <SyntaxNinja> Igloo: ahhh
08:04:44 <earthy> there *is* such a thing as Haskell being used for introductory programming classes
08:04:53 <SyntaxNinja> basti_: maybe a dummies guide to haskell would work actually.
08:04:57 <earthy> and there also is such a thing as dummies in introductory programming classes
08:05:13 <SyntaxNinja> I've met a few people on this channel who would appreciate one, I think.
08:05:19 <earthy> so that kinda implies that there are dummies doing Haskell
08:05:24 <basti_> hmm
08:05:32 <ozone> shapr: i'm pondering coding this thing
08:05:44 <shapr> me too
08:05:48 <earthy> ozone, are you pondering what shapr's pondering?
08:06:00 <ozone> earthy: actually, i'm pondering about shapr, but don't tell him that
08:06:00 * basti_ ponders there is too much pondering going on
08:06:03 <shapr> I think ArrowChoice can be used to do +++ parsing
08:06:05 <ozone> shapr: well, i have something which works
08:06:06 <Janni> You could ponder pondering together
08:06:12 <ozone> but it's rather ... simple
08:06:24 <ozone> and completely useless.
08:06:36 <Igloo> An O'Reilly book would be cooler, though
08:06:37 <shapr> for example, helo <+> ehlo
08:06:55 <earthy> an O'Reilly on Haskell would be great.
08:06:56 <ozone> i'm not Getting Something.
08:07:07 <ozone> in particular, i'm not getting how using this makes life easier. :)
08:07:09 <earthy> Haskell in a Nutshell... ISAGN
08:07:45 <shapr> ozone: oh, I don't understand that either. but I also said that a lot before I understood OOP.
08:08:10 <ozone> i mean, you could just write a whole bunch of case statements, or use pattern guards, and a chain of functions
08:08:12 <earthy> any book on Haskell that goes just beyond where e.g. Haskell SOE and such end
08:08:17 <ozone> and obviously arrows somehow make it nicer
08:08:23 <ozone> but i don't know how
08:08:25 <shapr> yah, I'm with you
08:08:37 <shapr> but first, I want to make an arrow that works even just a little bit
08:08:43 <shapr> then I can see where the 'pressure' is in the code
08:08:51 <earthy> and really explains arrows and monads and continuations and such would be nice.
08:08:56 <ozone> well, here's some code for you to chew on, even if it's useless:
08:08:56 <ozone> smtp = proc initialState -> do
08:08:57 <ozone>             if (take 4 initialState) == "HELO"
08:08:57 <ozone>                then returnA -< "250 Yay!"
08:08:57 <ozone>                else returnA -< "502 Boo!"
08:09:00 <ozone> that works. :}
08:09:06 <shapr> like, what's easier to do with arrows, and what's harder to do with arrows
08:09:08 <ozone> but somehow, i don't think it's what you had in mind ...
08:09:16 * shapr grins
08:09:57 <ozone> where's the hughes paper
08:10:09 * ozone searches the 3000 pages on his floor
08:10:09 <norpan> i only learned to appreciate monads after i understood monad transformers
08:10:45 <earthy> norpan: :)
08:11:01 * earthy decides to go home
08:11:22 <norpan> and Control.Arrow.Operations looks like the same deal
08:12:16 * basti_ now tries an arrow.
08:12:40 <norpan> time flies like an arrow
08:13:00 <shapr> fruit flies like a banana
08:13:00 <basti_> do we want to make a poem?
08:13:43 <musasabi> an arrow is a banana?
08:13:58 <musasabi> or a banana can be modelled as an arrow?
08:14:25 <desrt> arrows often point in the same direction as bananas
08:14:55 * SyntaxNinja mumbles something about syntactic ambiguity
08:15:24 * shapr mumbles something about typechecking arrow types
08:15:48 <ozone> {-# OPTIONS -fglasgow-exts -farrows -fno-monomorphism-restriction #-}
08:15:51 <shapr> lastStraw :: a Frustration Postal
08:15:53 <ozone> and it's all good. :D
08:15:58 <shapr> oh
08:16:20 <shapr> that does fix it
08:18:00 <shapr> so how do you turn your smtp into something that uses the Auto datatype?
08:18:21 <ozone> type SMTPServer = Auto String String
08:18:28 <ozone> not that i needed to do that
08:18:35 <ozone> (i don't actually use that type anywhere)
08:21:27 <norpan> time flies like a stopwatch
08:22:17 <andersca> fruit flikes like a banana
08:23:04 <ozone> shapr: did you read the bit on stream processors in the hughes paper?
08:23:41 <shapr> I read it, not sure if I understood it
08:24:10 <shapr> but I have both hughes and patterson printouts in front of me
08:24:11 <shapr> which page?
08:24:40 <norpan> andersca: 17:13
08:24:54 <andersca> sorry :(
08:24:58 <norpan> welcome to the last ten minutes
08:25:00 <shapr> I think these papers have more pen ink on them than bubblejet ink
08:25:05 <andersca> :'( 
08:25:07 * andersca cries
08:25:18 * shapr buys andersca a beer
08:25:25 <norpan> shapr: that's why you should always use a pencil
08:25:35 <shapr> nah, pencils can get erased
08:26:12 <shapr> and I often find surprisingly useful inspirations or blind alleys that I've escaped before in the margins of my printouts
08:30:09 <shapr> ozone: ok, I'm convinced, stream procs looks better for SMTP
08:31:30 <musasabi> What adverse effects would it have to use instead of Bool a type of "Maybe Unit"?
08:31:51 <shapr> for what code/
08:31:52 <shapr> ?
08:32:09 <musasabi> shapr: in general, not haskell specific (but Monad related)
08:33:08 <shapr> well, Maybe usually denotes failure or success on top of an actual value
08:33:39 <shapr> the maybe monad instance lets you get rid of a bunch of a big stack if/then/else or case statements that you'd need in most languages
08:35:56 <ozone> back in a sec
08:36:01 <ozone> ichat av kicks ass
08:36:50 <musasabi> Yes, just thinking that would it not make more sense... (and then one could define if as (pseudo) "if :: Maybe a -> (() -> c) -> (() -> c)"
08:37:04 <shapr> maybe liftStream on top of an automaton arrow?
08:37:42 <Amadan> a noob question: how can I pattern-match a value out of a list? let's say i have [Maybe Int], and I want to get rid of Nothings?
08:38:15 <andersca> filter isJust
08:38:16 <sazzle> filter?
08:38:36 <shapr> @index catMaybes
08:38:41 <shapr> @index catMaybe
08:38:50 <shapr> foo
08:39:00 <shapr> @index catMaybe
08:39:02 <lambdabot> bzzt
08:39:03 <shapr> @index catMaybes
08:39:04 <lambdabot> Data.Maybe,Maybe
08:39:14 <shapr> @type Data.Maybe.catMaybes
08:39:15 <lambdabot> Data.Maybe.catMaybes :: forall a. [Maybe a] -> [a]
08:39:36 <shapr> hiya lelit 
08:39:54 <lelit> hi shapr
08:39:54 <Amadan> thanks, helped a lot.
08:40:20 <shapr> g'day sazzle, how're your exams?
08:40:33 <sazzle> i'm just too good at procrastinating for them :(
08:40:44 * sazzle has managed to read about 5 pages.. all day
08:41:19 <ozone> yeeee
08:41:26 <ozone> i just used up 100mb of bandwidth chatting for 15 minutes
08:41:48 <sazzle> how'd you manage that?
08:42:02 <ozone> sazzle: chatting to my boss in japan, via ichat av
08:42:09 <ozone> holy shit it rules
08:42:25 <ozone> 100kb/sec video looks _sweet_
08:46:16 <ozone> shapr: ok, i haven't gotten any further with this
08:47:00 <shapr> a stream processor looks good, but so does an automaton
08:47:07 <shapr> maybe if you lift one into the other?
08:47:16 <ozone> mebbe.
08:47:29 <ozone> i'm still having a hard time trying to codify how all this works
08:47:34 <shapr> yah, me too
08:47:37 <ozone> and also what the big benefits are :)
08:47:41 <shapr> yup, I agree
08:47:51 <ozone> i have a feeling that reading the fudgets thesis will reveal all
08:47:56 <shapr> I can see obvious benefits in the Swierstra & Duponcheel parsers that expose static info
08:48:01 <shapr> hm, could be
08:48:01 <sazzle> ozone: aarh, so not just irc :-)
08:48:19 <ozone> well, not everything about arrows
08:48:27 <ozone> but understanding a concrete instance of arrows would sure help a lot
08:48:46 <shapr> the parsers in Hughes' paper are easy enough
08:48:52 <shapr> but I don't know how to generalize that info
08:49:27 <shapr> I can see that an arrow parser could 'float' up static info and allow for lots of extra optimization with that
08:49:58 <shapr> I think that could be very useful where you need a bunch of different layers tightly bound together, in something like speech recognition
08:50:51 <shapr> greetings Si\ 
08:51:38 <ozone> shapr: i have two comments
08:51:54 <ozone> first, let's assume you write an SMTP server in the IO monad
08:51:55 <shapr> ?
08:52:16 <ozone> that's fine, you use operations like hGetLine (or whatever it's called) to read in input
08:52:42 <ozone> and hPutStrLn "foo" for output if you're writing an IO () monad, or return "foo" for an IO String monad
08:53:10 <ozone> i guess with arrows you don't limit yourself to hGetLine
08:53:44 <ozone> hmm, although i suppose you could just pass the handle to the initial function
08:54:12 <ozone> shrug, anyhoo
08:54:13 <shapr> the S&D parsers were motivated by space leaks in existing parsers
08:54:24 <shapr> specifically with the try combinator
08:54:38 <shapr> most of the time you already know after three or four chars if the parser is going to work or not
08:54:48 <shapr> but there's no way you can 'export' that info to your caller
08:55:05 <shapr> instead, your caller has to hold another copy of the input while you chug along
08:55:16 <shapr> your caller has to wait for you to not fail before he can discard the input
08:55:25 <Si\> Hello shapr
08:55:26 <ozone> second thought is that you can code your SMTP server as functions
08:55:31 <ozone> one function per request
08:55:32 <shapr> if you multiply that by lots of functions, you use too much memory, you get a space leak
08:55:44 <ozone> each functions outputs an automaton
08:55:48 <ozone> (which is an arrow)
08:55:57 <shapr> you can only apply a monad to an input
08:56:03 <shapr> an arrow is like a monad's monad
08:56:10 <ozone> to connect the functions together, you just get a feedback loop going
08:56:20 <shapr> you move up another level to 'first class first class actions'
08:56:26 <ozone> shapr: how's that relevant to the smtp server example?
08:56:42 <shapr> well, I was trying to answer <ozone> but understanding a concrete instance of arrows would sure help a lot
08:56:57 <shapr> I thoroughly understand the S&D parser example.
08:57:02 <ozone> ah
08:57:06 <ozone> i get that example too
08:57:12 <shapr> I'm just not sure how to generalize that information to other applications.
08:57:17 <ozone> problem is with _this_ particular example. :)
08:57:23 <shapr> yah, I agree
08:57:50 <shapr> yah, the second thought is what I started with
08:57:59 <shapr> protocols as FSMs
08:58:16 <shapr> I don't understand your first thought
08:59:50 <shapr> ozone: thing is, I can't figure out how to actually write down the code that does that 'each function outputs an automaton'
08:59:56 <ozone> ignore first thought
09:00:00 <ozone> second thought looks more promising. :)
09:00:04 <shapr> maybe I just need to hack on it for a few days and see what I end up with
09:01:01 <shapr> and I like what Heffalump said about parameterising the functions
09:01:15 <shapr> like "sessionInit allowed_domains = ..."
09:01:54 <shapr> so sessionInit :: c -> a - (b, Auto a b)
09:02:18 <ozone> shapr: i was thinking more along these lines ...
09:02:25 <ozone> you have a bunch of small functions
09:02:49 <ozone> one function will await a HELO or EHLO
09:02:53 <ozone> and outputs a new automaton
09:02:59 <shapr> right, that's clientInit
09:03:07 <ozone> actually, scrap that
09:03:09 <ozone> one function awaits a HELO
09:03:10 <shapr> sessionInit talks to the socket as soon as someone opens it
09:03:13 <ozone> and outputs a new automaton
09:03:17 <ozone> another function awaits a EHLO
09:03:18 <ozone> and outputs a new automaton
09:03:28 <ozone> another function awaits a MAIL FROM
09:03:29 <ozone> and outputs a new automaton
09:03:31 <ozone> etc etc etc
09:03:38 <shapr> then sessionInit calls clientInit, which waits for HELO or EHLO
09:03:47 <ozone> so, one function per possible client request
09:04:00 <shapr> and something like sessionInit = helo <+> ehlo
09:04:03 <ozone> so, you know in the arrows papers, they like drawing diagrams of how these functions fit together?
09:04:13 <shapr> so you get the same failover parser stuff like helo +++ ehlo
09:04:17 <shapr> yah?
09:04:49 <ozone> i'm guessing that you have some sort of arrow function, like the diagram, which basically takes all the various functions and builds a control flow from them
09:04:59 <ozone> so in the diagram at http://www.haskell.org/arrows/syntax.html
09:05:22 <ozone> f and g are these little functions which await client requests, and outputs new automatons
09:05:28 <ozone> im i completely off-track?
09:05:39 <ozone> i think i'm getting the gist of it.
09:06:12 <shapr> I think you're getting it
09:06:12 <Amadan> sorry - probably a similar noob question:
09:06:25 <Amadan> let's say i have a getOpts option list
09:06:43 <shapr> ozone: does this mean you can actually write code to do the HELO\nQUIT example? :-)
09:06:53 <shapr> I can't quite do that yet
09:06:56 <Amadan> like [Verbose, Output "outfile", Input "infile", Level 2]
09:07:20 <Amadan> and I want to extract "outfile"; how would I do it most easily?
09:07:53 <Amadan> the best I could think up required half a dozen lines per parameter... :(
09:07:57 <ozone> shapr: *thinking*
09:09:16 <ozone> Amadan: are you guaranteed thre's only going to be one Outfile in the list?
09:09:27 <Amadan> okay, let's say it's so
09:10:04 <shapr> filter (\x -> case x of (Output _) -> True; _ -> False)
09:10:17 <shapr> though that's not the prettiest solution
09:11:56 <shapr> I wonder if that can be parameterized...
09:11:57 <Amadan> that's about where I was, and then you still have to pattern-match against the constructor to get at the value...
09:12:00 <Igloo> [ o | Output o <- xs ]
09:12:00 <Amadan> so getInput :: [Flag] -> String gets really complicated
09:12:07 <Amadan> ... doh!...
09:12:11 <Igloo> head of that if you know there's exactly one
09:12:12 <Amadan> thanks
09:12:20 <ozone> what igloo said. :)
09:13:15 <ozone> shapr: the bit i get confused is how to compose things extensibly
09:13:59 <shapr> ozone: yah, I agree
09:14:21 <shapr> hughes and patterson think that arrows give more extensibility, but I don't get it in this case.
09:14:33 <ozone> i mean, i guess you can build one huge momma function which looks like a massive control flow graph
09:14:44 <ozone> but then you have this one huge moma function which looks like  massive control flow graph
09:14:50 * shapr grins
09:15:01 <shapr> and the question is, is that extensibility?
09:16:04 <ozone> the goal for me is this: if a new command is added to SMTP, how easy is it to drop in to your program?
09:16:13 <shapr> I'd like to say something like [(parser,auto),(parser,auto),(otherwise,auto)]
09:16:16 <shapr> for each auto
09:16:20 <ozone> can you just write another function to handle it, and add it to some list of commands, and that's it?
09:16:44 <shapr> you'd have to add it to your CFG
09:17:13 <shapr> if each automaton is just a list of pairs of (parser,auto) where a successful parse calls that auto...
09:19:46 <shapr> or maybe that should be parser,func,auto
09:19:46 <shapr> so that you can do stuff like access control
09:19:48 <shapr> does that sound extensible?
09:19:50 <ozone> sounds OK to be :)
09:19:52 <ozone> s/be/me/
09:20:59 <shapr> won't really know till it works
09:21:23 <shapr> auto could often point back to the auto being defined
09:22:19 <shapr> maybe clientInit = [(ehlo,f,a),(helo,f,a),(otherwise,f,clientInit)]
09:23:06 <shapr> I keep thinking I'm missing something here
09:23:52 <shapr> at EuroHaskell I realized that Hughes discrete timing simulation had the semantics of the simulation encoded in the arrow instance
09:28:31 <ozone> shapr: i think, basically, if you can find a state diagram or automata for SMTP
09:28:31 <ozone> you can model it with, well, an Auto arrow :)
09:28:36 <ozone> the advantage is that you can directly encode the state diagram as an arrow function
09:28:45 <ozone> (maybe even automatically, assuming you have a smart-enough tool)
09:29:09 <ozone> you may need an arrow transformer to keep track of the state, too
09:29:16 <ozone> so your final arrow would be composed of state & automata
09:29:25 <shapr> what about stream?
09:29:42 <shapr> ok, I agree with you
09:29:47 <ozone> well, i was just talking about automata/state diagrams
09:29:57 <shapr> so, what would be the point of composing two SMTP arrows?
09:30:01 <shapr> or two protocol arrows in general?
09:30:35 <shapr> patterson says that >>> feeds the output of one into the input of another
09:31:30 <ozone> i dunno.  does it make any sense to compose two protocol arrows?
09:31:39 <shapr> I don't know
09:31:53 <shapr> but >>> seems central to the usefulness of arrows... so I wonder
09:32:27 <ozone> well, maybe
09:32:40 <shapr> if I don't need >>> then maybe I could just use the Auto type without needing arrows at all?
09:32:46 <ozone> if you think about network protocols ...
09:33:07 <ozone> so, you have TCP, UDP, ICMP
09:33:12 <ozone> all running over the same wire
09:33:16 <Igloo> Is the arrow output the commands you send or the messages that come in?
09:33:33 <Igloo> Or something else?
09:33:34 <ozone> Igloo: commands you send, i would think.
09:34:23 <Igloo> They wouldn't just be sent with hPutStrLn by the code amking up the arrow?
09:34:26 <ozone> Igloo: or rather, a thingy (new automaton, new stream processor) which contains the commands you send
09:34:44 <Igloo> Hmm, OK
09:34:58 <ozone> Igloo: you could, the point is to abstract that out
09:36:04 <Igloo> What happens to the message I receive? Is that also part of the arrow output or is that written with writeFile in the arrow code?
09:37:00 <ozone> Igloo: that's one problem i'm having :)
09:37:26 <ozone> i think you might be able to use an arrow transformer to handle that
09:37:41 <ozone> e.g. combine an automaton with state, or an automaton with the IO monad
09:38:00 <Igloo> I think the message should be the output. Then you would compose IP, TCP, SMTP, MDA arrows
09:38:12 <Igloo> (I also don't know anything about arrows don't forget)
09:38:52 <Igloo> Where the IP equivalent of message is the TCP stream, and so on
09:40:57 <Igloo> *ominous silence*
09:41:10 <Igloo> *everyone muffles giggles at Igloo's foolishness*
09:41:36 <ozone> i'm certainly befuddled :)
09:42:05 <ozone> trying to get a feel for it by looking at fudgets pages, but that's not working either.
09:42:19 <shapr> Igloo: I think you're right
09:42:20 <Igloo> Hmm, actually, the SMTP commands need to go the other way down the arrow composition
09:42:36 <shapr> liftSMTP
09:42:38 <Igloo> But that can't happen can it?
09:42:39 <shapr> ?
09:42:41 <shapr> I dunno
09:42:48 <shapr> I'm just trying to get anything at all working
09:43:08 * Igloo decides I should read the chapter before trying to contribute anything
09:43:09 <ozone> shapr: well, it's pretty trivial to get stuff working
09:43:15 <ozone> it's more a question of how nice it works :)
09:47:50 * Heffalump suggests you start with a monad.
09:48:05 <Heffalump> then if you discover you need an arrow, make one
09:48:16 <ozone> damn munchkins
09:48:59 <ozone> Heffalump: i gather that's a serious suggestion? :)
09:49:07 <Heffalump> yes.
09:49:17 <Heffalump> why do you think you want an arrow to begin with?
09:49:27 <ozone> err
09:49:33 * ozone looks at shapr 
09:49:33 <ozone> blame him!
09:49:45 <Heffalump> to be fair, the Auto arrow may be entirely right for making a state machine
09:50:35 <shapr> I just want to know when I need an arrow
09:50:44 <Heffalump> when a monad isn't good enough
09:50:46 <shapr> I don't yet know how to decide that.
09:51:01 <shapr> so I figure, if I write some arrows, I'll have a better understanding of them.
09:58:41 <Heffalump> naah, write some monads and figure out what the restrictions are
10:03:55 <shapr> monads are a special case of arrows :-P
10:04:06 <ozone> ok, brain be dead
10:04:08 <ozone> time to sleep
10:04:11 <ozone> nite all!
10:04:13 <shapr> so what's wrong with writing arrows first and then learning how monads aren't arrows?
10:04:18 <shapr> ozone: thanks for the chat!
10:04:24 <shapr> g'nite ozone 
10:04:24 <ozone> sure, ditto
10:04:25 <ozone> later
10:04:38 <Amadan> bye
10:05:18 <Amadan> one more filtering question: can i make an or pattern? i.e. can i transform [o | Input o <- opts] into something like [o | (Input o | Output o) <- opts] in pseudohaskell?
10:05:44 <sazzle> Amadan: you can put any function before the |
10:06:09 <Amadan> yeah... but it's the matching part that bothers me
10:06:19 <sazzle> what're you trying to match?
10:06:22 <Igloo> You can't, no
10:07:00 <sazzle> yeah, you can't do it that way, but you can make a function that behaves that way (though I'm not sure what you're trying to do)
10:07:55 <Amadan> say I have a getOpt list like [Verbose, Output "outfile", Input "infile", Level 2]; i want to get [Input "infile", Output "outfile"], i.e. filter out the Inputs and Outputs and throw away the rest
10:09:05 <sazzle> have a fn that returns True for inputs and outputs
10:09:11 <Amadan> the best I've come to it (with Igloo's kind help) is [p | p@(Input i) <- opts] ++ [p | p@(Output i) <- opts]
10:09:12 <sazzle> then do filter fn list
10:10:10 <Amadan> ah. right... :) sorry, not very inteligent questions... thanks
10:10:49 <sazzle> or, have it as a condition
10:11:16 <sazzle> if you really want to use a list comp
10:13:00 <TheHunter> you could define a function getArg with getArg (Input i) = [i], getArg (Output o) = [o], getArg _ = [] and then do opts >>= getArg
10:13:53 <Amadan> :) i love the way everything can be done in a million different ways in haskell!
10:14:12 <Amadan> (i hate the way i have problems thinking up even one of them)
10:24:32 <wagle> ping
10:24:40 <TheHunter> ping
10:24:42 <TheHunter> pong
10:24:59 <wagle> sigh
10:25:37 <basti_> gong
10:26:36 * shapr cackles happily
10:37:19 <Heffalump> shapr: ?
10:37:31 * shapr hides
10:39:06 <TheHunter> is anyone here from germany?
10:39:18 <shapr> I visited germany once. :-)
10:39:38 <TheHunter> shapr: do you speak german?
10:39:49 <Igloo> Someone in Germany was here earlier
10:40:16 <shapr> ich habe keine ahnung.
10:40:17 <TheHunter> i'm thinking about switching the university, but i don't know where to go...
10:40:26 <Igloo> basti_
10:40:47 <shapr> you want to go to a uni with Haskell offerings?
10:40:50 <shapr> freiburg has Thiemann and some others
10:41:00 <TheHunter> shapr: that's not the main point, but would be nice
10:41:06 <shapr> I forget which uni has George @ tzi.de
10:41:21 <Heffalump> kosmikus is from Germany.
10:42:03 <Amadan> that's bremen
10:42:09 <Amadan> (tzi, i mean)
10:42:12 <shapr> ah, thanks
10:43:06 <musasabi> shapr: as in Freiburg in Breisgau ?
10:43:32 <shapr> http://www.informatik.uni-freiburg.de/~thiemann/
10:45:33 <musasabi> hmm, I lived there for nearly two years...
10:45:53 <musasabi> as a child and my father worked at the uni.
10:49:42 <shapr> as a child I played in nuclear power plants.
10:49:46 <shapr> that's how I got the glowing green eyes, you see.
10:54:11 <basti_> TheHunter i am
10:54:36 <TheHunter> hey, where are you studiing?
10:54:40 <basti_> marburg
10:56:27 <Amadan_away> bye
10:56:30 <shapr> bye
11:02:25 <shapr> Igloo: I think you're right, composing protocols should work like that
11:02:43 <Igloo> I think I'm wrong since Heff told me the type of >>>
11:03:03 <Igloo> As the arrows have to have the same type, but they are different as they have different states
11:03:25 <shapr> @type (>>>)
11:03:26 <lambdabot> bzzt
11:03:49 <shapr> Igloo: but, if they're all Automaton arrows, it works fine
11:03:51 <Igloo> a b c -> a c d -> a b d
11:04:18 <shapr> and you can have the bottom (top?) one do something like liftIO, yes?
11:04:39 <Igloo> But they're automota parameterised by different states. In fact, the state varies depending on where in the state machine you are (i.e. it's not a FA)
11:05:04 * Igloo will think more afte rI've read about arrows
11:07:25 <shapr> wouldn't something like this typecheck? smtp (:: Auto SMTPCommand  SMTPResponse) >>> tcp (:: (TCP => a) => Auto a b)
11:08:07 <shapr> in that case >>> does the ISO/OSI stack composition
11:08:19 <shapr> tcp >>> udp >>> dll
11:08:28 <jemfinch> dll?
11:08:35 <shapr> data link layer
11:08:53 <Heffalump> tcp is not a layer on udp..
11:09:05 <shapr> right, sorry
11:09:32 <shapr> in that case, each automaton does have its own state because that's how it should work
11:09:33 <Heffalump> using >>> to do OSI stack composition is just wrong.
11:09:40 <shapr> whatever for?
11:09:44 <Heffalump> if anything, you should use an arrow transformer
11:10:08 <shapr> but if a layered protocols are all instances of the automaton arrow, why not use composition?
11:10:31 <shapr> the whole point is just to find a useful abstraction, do you think protocol composition would make some things unusuable?
11:11:55 <shapr> bonjour Lukhas`
11:12:23 <shapr> sorry, I meant tcp >> ip
11:12:26 <shapr> not udp
11:12:32 <Lukhas> re shapr
11:12:43 <Heffalump> have you looked at the definition of >>> for Auto?
11:12:48 <shapr> yes
11:12:56 <shapr> it does just that
11:13:14 <shapr> it preserves the state of each automaton, while feeding the output to the next automaton
11:13:52 <shapr> Auto f >>> Auto g = Auto $ \b -> let	(c, f') = f b ; (d, g') = g c ; in	(d, f' >>> g')
11:15:22 <shapr> so if tcp :: Auto a b and ip :: Auto b WireData, then tcp >> ip means that tcp outputs get wrapped into ip, right?
11:16:11 <Heffalump> hmm, maybe you're right
11:16:12 <basti_> wow i got my useful.libraries to work.
11:16:21 <shapr> Heffalump: not me, Igloo  :-)
11:16:31 <Heffalump> oh, then it can't be right
11:16:33 <musasabi> shapr: but putting tcp directly on top of ip is not enough.
11:16:34 <Heffalump> Igloo is always wrong.
11:16:38 * shapr snickers
11:16:43 <musasabi> shapr: you need to have ip -> tcp direction too.
11:17:20 <shapr> musasabi: yes, I agree, but I'm still seeing my first ideas work at all
11:18:15 <shapr> hiii Philippa!
11:18:20 <Philippa> 'lo shapr
11:18:29 <musasabi> one problem with haskell is that adding new aspects to existing solutions can be very hard.
11:18:31 * shapr bounces cheerfully
11:18:35 <Philippa> Damien was just talking about my fanboy collection ;-)
11:18:40 <shapr> hehe
11:18:45 <shapr> I'm far too old to be a fanboy
11:19:02 <shapr> too bad there's not a single word in english for 'gubbe'
11:19:05 <shapr> 'old man'
11:19:12 <Philippa> "dirty old man"?
11:19:19 <shapr> yah, but that takes multiple words :-P
11:19:31 <shapr> fanboy, fanman, fanoldie?
11:19:32 <shapr> I dunno
11:20:02 <Philippa> anyway, been up to anything interesting?
11:20:03 * Heffalump appears have definitely decided Igloo is wrong.
11:20:11 <shapr> Heffalump: anyway, Igloo answered my question of "what the heck is the point of composing two Auto arrows?"
11:20:20 <shapr> hah! we need proof!
11:20:29 <Heffalump> I proved it to his satisfaction, I think.
11:20:52 <shapr> Philippa: yes, making a protocol arrow out of the automata arrow in patterson's paper.
11:20:59 <Igloo> Yes
11:21:00 <Philippa> cool
11:21:05 <shapr> what was the proof?
11:21:13 <Heffalump> you need 4 parameter types, not two
11:21:23 <shapr> huh?
11:21:29 <Heffalump> because the automaton needs to be the same for both passing information up and passing information down
11:21:39 <Philippa> 'mafraid I've been playing with the dark side today - though VC#Express looks kinda funky from this beta. Might just be that Windows Forms is finally turning into the GUI lib I want though
11:22:14 <shapr> why does it need to be the same?
11:22:32 <shapr> why not ip >>> tcp >>> smtp ?
11:23:08 <Heffalump> because SMTP inputs and SMTP outputs are not independent
11:23:11 <Heffalump> they share the same state machine
11:25:07 * shapr thinks about that
11:25:39 <Marvin--> evening
11:25:40 <shapr> hej Marvin-- 
11:26:46 <Marvin--> I went to Strakt today, to hand back keys and stuff
11:27:00 <shapr> oh, you're out?
11:27:14 <Marvin--> well, by intention :)
11:27:20 <Marvin--> I'm starting at Safelogic in August
11:27:38 <shapr> did you ask Pete Gammie about Safelogic?
11:27:46 <Marvin--> nah
11:27:48 <shapr> ok
11:28:35 <shapr> hm, maybe I'll send an email to Ross and ask him :-)
11:28:50 <Marvin--> about what?
11:29:12 <shapr> about this protocol arrow as automaton arrow
11:29:13 * Heffalump suggests you just write the code you want to write, and then work out the right abstraction for it
11:29:53 <shapr> I want to write an arrow...
11:30:17 <Heffalump> ok, take our ICFP contest entry and rewrite that in terms of arrows.
11:30:24 <shapr> :-P
11:30:34 * Marvin-- idly wonders where he can buy posters of Escher prints
11:30:56 <Igloo> Blackwells Poster Shop
11:33:42 <Marvin--> somewhat close to Gothenburg would be preferrable
11:44:31 <shapr> Heffalump: type SAuto s = StateT s Auto
11:45:18 <shapr> that way, you can do smtp >>> tcp >>> ip and ip >>> tcp >>> smtp
11:47:05 <shapr> Heffalump: can you think of better implementation with arrow lifting?
11:49:20 <Luke> where can I find the docs for the Hugs Prelude module?
11:49:45 <Matt-W> The Prelude is documented in the Haskell Report
11:49:51 <Matt-W> Not necessarily tehmost friendly docs though
11:49:56 <Matt-W> not sure if there are any better ones around
11:49:56 <shapr> greetings Luke
11:49:58 <det> @yow
11:50:00 <lambdabot> C'MON, everybody!!  I've flown in LESLIE GORE and two dozen KOSHER
11:50:00 <lambdabot>  BUTCHERS!  They'll be doing intricate MILITARY MANEUVERS to the
11:50:00 <lambdabot>  soundtrack from "OKLAHOMA"!!
11:50:13 <Matt-W> hi shapr
11:50:26 <shapr> hiya Matt-W
11:50:28 <Luke> Matt-W: is it exactly the same as the spec? e.g. scanl I didn't see described in a standard-looking reference I found on the web
11:50:45 <shapr> @type scanl
11:50:46 <lambdabot> scanl :: forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:50:49 <shapr> @info scanl
11:50:50 <lambdabot> -- scanl is a variable
11:50:50 <lambdabot> scanl :: forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:51:03 <shapr> hm, that wasn't a helpful info.
11:51:11 <shapr> anyway, do you know scan?
11:51:14 <Matt-W> not really, no
11:51:27 <Matt-W> I did the Perl Quiz of the Week in Haskell this week
11:51:39 <Luke> I'd prefer not to have to read the Prelude.hs file from top to bottom looking for code that does what I want :)
11:51:45 <shapr> what do you want?
11:51:49 <Matt-W> that's understandable :-)
11:52:15 <shapr> scan is fold but it saves intermediate results
11:52:38 <Philippa> Luke: GHC's docs seem fairly decent, and IMO GHCi's a better interpreter than hugs
11:52:39 <Luke> right now I want a function to split a list in two parts, the first containing the prefix that satisfies a predicate. but I'll probably want a lot of simple functions and would prefer not to ask about them all on irc
11:53:07 <Luke> Hugs's emacs mode is nice - how does GHC's compare?
11:53:20 <Philippa> filter the string first on the predicate then on not-predicate, then concatenate the two as a first approximation?
11:53:22 <shapr> imho, GHC is spiffier than Hugs
11:53:27 <shapr> but the emcas mode is the same
11:53:53 * Philippa is a heretic who's currently considering writing her own text editor on the grounds that emacs would be great if it didn't suck so much :-)
11:54:00 <Philippa> so I'm prolly not the person to ask
11:54:00 <shapr> there's span and break
11:54:20 <Matt-W> Phillipa: isn't that what vim is for?
11:54:23 * Matt-W hides
11:54:34 <shapr> but if you want to split a string on every \n and get back a list of that, you can use breakOnGlue from PreludeExts on the wiki
11:54:49 <shapr> yah, I'd like to rewrite emacs too
11:54:54 <wouter> you may want to use: span :: (a -> Bool) -> [a] -> ([a],[a])
11:54:59 <shapr> I only actually know one person who's really tried it
11:55:07 * shapr looks significantly at Luke
11:55:32 <stepcut> Philippa: bah, that is nothing, the author of tla wrote his own revision control system, to store his own scheme implementation, that runs on his own VM, that will form the basis of his own emacs clone, on the grounds that the existing tools would all be great if they didn't suck so much :)
11:56:02 <shapr> Luke: ghc gives you let x = (\y -> y + 1) and also stuff <- readFile "/home/shae/.zshrc"
11:56:02 <Luke> rewriting Emacs is a very stupid thing to do imho :)
11:56:02 <Philippa> the main things I want to do are a) sanitise the keyboard shortcuts a little (I have a plan for this), b) design with a GUI as a base assumption and c) replace elisp with something statically typed
11:56:13 <shapr> so I think GHC is better for exploratory stuff
11:56:15 <Matt-W> stepcut: has he come up with a version of autoconf that doesn't drive its users insane?
11:56:22 <shapr> Hugs is better when you want to run Haskell on your Sharp Zaurus
11:56:26 <stepcut> Matt-W: yes
11:56:32 <Matt-W> stepcut: more power to him
11:56:46 <stepcut> Matt-W: but I don't know if it is nearly as powerful
11:56:48 <wouter> Luke: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html may be useful.
11:57:14 <stepcut> Luke: writing your own emacs clone is only stupid if you don't plan to do it right and finish the task
11:57:28 <Luke> wouter: I'm there, but not finding it so helpful. I'd like to see functions grouped by how similar they are, and also it doesn't include all the Hugs prelude
11:57:56 <shapr> I feel the same way about named spaces/theorems/etc in math
11:58:05 <shapr> I don't want to know the name, just what they actually do
11:58:58 <shapr> Luke: I'd recommend that you look at the online GHC docs for the Data.* part of the Hierarchy
11:59:04 <shapr> Data.List for example
11:59:19 <wouter> Luke: http://haskell.cs.yale.edu/ghc/docs/latest/html/libraries/base/Prelude.html
11:59:31 <shapr> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
11:59:47 <Luke> thanks guys
12:00:12 <shapr> anymore questions?
12:00:17 * shapr is eager to answer Haskell questions
12:00:34 <Luke> 'span' is what I was fishing for
12:00:41 <Luke> (those docs are just right)
12:00:41 * Matt-W is eager to do things in Haskell, and wishes his employers would pay him for it
12:01:09 <shapr> my employer pays me to meet my customers needs. I haven't yet been able to do much of that with Haskell.
12:01:19 <shapr> but it's getting closer
12:01:37 <Matt-W> Haskell generally requires too much of a space and time penalty for me to be able to use it on our products unfortunately
12:01:44 <Matt-W> also because nobody else would be able to maintain the code
12:01:55 <musasabi> shapr: well logic variables or a computation with a timeout would be both be nice...
12:01:56 * stepcut is using haskell for his job right now...
12:01:58 <Matt-W> I even have to tone down some of my Perl :-(
12:02:07 <musasabi> any idea how to do either?
12:02:13 <shapr> what sort of logic vars?
12:03:03 <shapr> hm, there may be a way to do max timed computations.
12:03:51 <shapr> but in general the lambdabot fuel idea where you wind down an iteration counter seems easiest
12:04:08 <musasabi> doing timed computations is fine in principle, (that is in >>= we check for timeout) but if we want to abort when any code inside takes too long?
12:04:29 <shapr> there may be a way to do that actually
12:04:36 <musasabi> hmm?
12:05:48 <shapr> lemme check
12:07:59 <Heffalump> shapr: huh (re your suggestion for the arrows)
12:08:42 <shapr> the state arrow transformer can be applied to any arrow instance
12:10:34 <Luke> i'm not understanding the docs - how do I convert from string to integer (atoi)?
12:10:34 <Heffalump> so?
12:11:00 <Heffalump> that doesn't help you *share* state between two different arrows
12:11:44 <shapr> musasabi: I think you could do that if you're using Concurrent
12:11:50 <shapr> though it might require a GHC-specific hack
12:12:10 <shapr> I dunno anything about Concurrent in Hugs
12:12:16 <shapr> Luke: read "1" :: Int
12:13:09 <Luke> pardon my ignorance, what's the name for the ":: Int" bit of that expression?
12:13:10 <shapr> type sig
12:13:14 <shapr> type signature
12:13:59 <Luke> readInt :: String -> Int
12:14:00 <Luke> readInt = read
12:14:12 <shapr> sure, that'll work
12:14:16 <Luke> gee wiz, so this is that "polymorphism on return value" thingy I've heard about :)
12:14:33 <shapr> you can also do read "1" :: Integer
12:14:39 <shapr> or read "1.0" :: Float
12:14:51 <Luke> what's Int vs. Integer?
12:15:03 <shapr> Integer uses gnu gmp
12:15:06 <shapr> no size limit
12:15:08 <Luke> ok
12:16:20 <shapr> Luke: even scarier, you can say your function is of type :: (Num a) => String -> a
12:16:27 <Luke> I'm writing a small module in a file, and usually the file as a whole is broken, but I'd like to be able to test individual definitions in it. is there a convenient way? I don't see any `eval-region' type of command in the emacs mode
12:16:35 <shapr> since Float, Int, Integer, etc are in the Num typeclass...
12:16:50 <shapr> no convenient way that I know of
12:17:05 <shapr> best to comment out the broken bits and C-c C-l the file
12:17:17 <Luke> currently I'm using a separate "scratch" file to put single definitions into and C-c C-l. is that normal?
12:17:19 <musasabi> shapr: don't see how to do it trivially.
12:17:21 <shapr> with both hugs and ghci that calls them to reload the whole file
12:17:34 <musasabi> other than having  a worker thread and waiting for it.
12:17:44 <musasabi> which might even work...
12:17:53 <Luke> does each load redefine the whole world?
12:18:00 <shapr> it does
12:18:07 <shapr> redefine, that is
12:18:35 <shapr> Haskell is getting to the point where you can do piecewise coding
12:18:49 <shapr> but I suspect it'll be a few more months till hs-plugins and friends become popuar.
12:19:12 <Luke> hs-plugins?
12:19:38 <shapr> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:20:40 <Luke> looks heavy-duty
12:20:41 <shapr> Luke: in general, Haskell wants to do a large amount of type-checking upon program compilation, so it expects all the soure code to be available at the same time.
12:20:46 <musasabi> shapr: isn't that without unloading?
12:20:46 <shapr> it's pretty spiffy
12:21:40 <shapr> musasabi: huh?
12:23:35 <shapr> at the bottom of http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-7.html#node_chap_6 you get to see how you can edit the source file at runtime, and the next time a command is executed, the plugin is automatically unloaded, recompiled, and reloaded.
12:24:16 <Luke> this can only mean one thing, I guess. haskell-emacs. :)
12:24:38 * shapr agrees
12:24:48 <shapr> He-macs
12:25:06 <shapr> By the Power of Hindley-Milner!
12:25:18 <Luke> I'd like to try that Ocaml emacs to see how it handles "doing emacsey things in a fully statically typechecked language", but I've not been able to compile it
12:25:34 <shapr> I'd like to write a nice editor in Haskell
12:25:38 <stepcut> Luke: yeah, it requires ocaml 2.x i think
12:25:38 <shapr> with parse tree macros!!
12:26:07 <Philippa> shapr: Great minds dream up shite^W^W^Wthink alike?
12:26:13 * shapr snickers
12:26:16 <Luke> stepcut: you mean I'd need to downgrade from 3.x to compile it?
12:26:34 <Luke> why parse tree macros?
12:27:38 <Philippa> refactoring on the spot
12:27:46 <shapr> and lots of other stuff
12:29:13 <shapr> python added += and -= at one point, you could then write a macro that would go through all of your source and look for "identifier = identifier [op +,op -] constant" and replace that with "identifier op constant"
12:29:42 <shapr> well, you get the idea
12:29:58 <shapr> that's just one of many parse tree macros I would write
12:30:15 <stepcut> Luke: yeah... I am not convinced it is worth the effort
12:30:22 <shapr> also, if the editor included a incremental parser, I wouldn't have to complain about regexp syntax highlighting anymore
12:30:36 <shapr> and I could do lots more useful tab completion
12:30:38 <stepcut> regexp syntax highlighting sucks
12:30:57 <Matt-W> syntax directed editor
12:31:06 <Philippa> shapr: hrmm, I'm thinking for a mo about how hard it'd be to get parsec to do that
12:31:22 <Heffalump> any parser that can parse the language in question could do it
12:31:24 <stepcut> I think I need to write something that turns parsec parsers into some sort of elisp state machine thing
12:31:42 <Heffalump> one of the biggest problems is outputtnig the source again maintaining the original formatting and comments
12:31:58 <shapr> emacs has semantic bovinitar, which does take bnf (bovine normal form) files and spit out elisp parsers
12:31:58 <Philippa> Heffalump: was thinking about the syntax highlighting
12:32:07 <Heffalump> ah, right
12:32:48 <Luke> I'd think regexps are okay for syntax highlighting in most languages. usually you want to highlight lexical tokens, and most languages are lexed by regexp
12:32:50 <shapr> the original refactoring browser added a comment node (and some other nifty bits) to a subclass of the Smalltalk parse tree
12:33:20 <Philippa> Luke: alternating the paren/bracket colour is a nice use for non-regular stuff to kick off with
12:33:40 <shapr> and included a pretty-printer with preferences
12:33:45 <Philippa> and yeah, that's roughly how I figure you'd have to do comments
12:33:51 <Luke> have you guys really used refactoring editors in non-Java-like languages? I'm curious if they live up to the hype
12:34:03 <shapr> they are all the hype and a bag of chips
12:34:13 <Philippa> I haven't had the chance. I can see it being a lot better in Haskell than Java though
12:34:31 <Philippa> functional languages are almost by definition going to be easier to refactor
12:34:37 <Heffalump> I've not tried HaRe yet
12:35:11 <Luke> in Java they put a type inferencer into the editor to generate the type boilerplate, which AFAICS is why people love it so much. wondering if it's still good when you don't have those language deficiencies to work around
12:36:14 <shapr> I think refactoring is better outside of Java, C and related painfully typed languages.
12:36:35 <Philippa> rewriting state-by-rampant-passing into monadic form would be one simple example I'd like
12:36:37 * shapr tags himself as a refactoring fanatic
12:36:45 <shapr> heh, me too
12:36:54 <Philippa> because when you've got a bunch of code like that it's /hell/ rewriting
12:36:58 <Luke> that would surprise me, since Java has a lot of low-hanging busy-work to eliminate
12:37:21 <Philippa> and I end up doing that a lot when going from first to second attempt at solving a problem
12:37:22 <Luke> shapr: which refactoring editors do you like?
12:37:22 <shapr> refactoring is not about the low-hanging busy-work, it's about reorganizing your code so that you understand it better
12:37:30 <shapr> I like the original a whole lot
12:37:58 <Luke> what are your top 3 favourite refactoring commands?
12:38:00 <shapr> if you get a chance to try it, I think you'll join the converted :-)
12:38:20 <Luke> does it run in squeak?
12:38:31 <shapr> it did at one point, I don't know if does now.
12:38:49 <shapr> region to method is a big one
12:39:37 <shapr> but the whole idea of being able to pull up a method into a superclass from two different subclasses, and then if they're the same method, you only have one left... that's sexy :-)
12:40:38 <shapr> we all do refactoring when we get rid of duplicate code, or some newbie rape'n'paste code, but a refactoring browser automates the drudgery
12:41:50 <Luke> I have region-to-method in the erlang mode, but I find it a bit of a ho-hum myself
12:43:13 <shapr> do you have the {push-down,pull-up,inline,extract} of {method,class,etc} ?
12:43:26 <Luke> no, region-to-method is the only one. :)
12:43:32 * shapr grins
12:43:35 <shapr> it's the hardest one
12:43:57 <Luke> if it's what I think, anyway. it takes a region of a function and converts it into a subfunction, passing any variables that become free as arguments
12:44:03 <shapr> yup
12:44:46 <shapr> if you can do that, you can do a lot of the other refactorings
12:45:05 <shapr> because it means you check variable scope, naming, and a bunch of other info
12:45:26 <Luke> that one is kinda easy because it's so local. renaming a function and all of its callers would be much trickier to do well, I think
12:45:35 <Luke> for erlang in Emacs, anyway
12:46:59 <Luke> in Erlang you can't have any free variables in a function, so all variables that are free in the region you want to extract must be passed as arguments. so all you need is a "which variables are free in this snippet" function, which thankfully somebody else wrote for me :)
12:47:37 <shapr> hm, neat
13:02:30 <shapr> Heffalump: could I use credit card transform to get the same arrows in both pipelines?
13:18:40 <Heffalump> use what??
13:19:34 <shapr> @wiki TyingTheKnot
13:19:35 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
13:22:10 <Heffalump> shapr: no.
13:25:40 <Marvin--> The greeks are playing really well
13:28:11 <SyntaxNinja> Marvin--: you pinged me yesterday.
13:30:04 <Marvin--> SyntaxNinja: not yesterday, I think, but the other day yes... I was confused about your latest cabal mail where you said that you'd committed some changes but I couldn't find them in the repo
13:30:20 <Marvin--> otoh, the changes are there now, so consider the ping revoked :)
13:31:07 * SyntaxNinja is unpinged
13:39:17 <Igloo> Is there a (public) cabal list then? Or is this just random mail?
13:41:04 <Marvin--> random mail
13:41:17 <norpan> not entirely random i hope
13:43:38 <SyntaxNinja> Igloo: I sent out an email to the authors of the document and people who've hacked on it about something or other that I changd. I didn't think it's of general interest.
13:43:46 <SyntaxNinja> though there should probably eventually be a cabal list, I think.
13:45:00 <Igloo> *nod*, it's just that if there was a list that was open to non-implementors I'd have joined
13:46:31 <Marvin--> SyntaxNinja: parseFreeText in Distribution.Package, is that the function that's meant to do the multiple-line parsing?
13:47:26 <Igloo> Heh, I like that function name
13:54:25 <TheHunter> unbelievable
13:54:36 <TheHunter> @state
13:54:36 <lambdabot> GRE-CZE 1:0
13:54:37 <Marvin--> wow
14:07:23 <reffie> YAY GREECE
14:09:23 <Igloo> Is the opposition known?
14:09:28 <Heffalump> Portugal.
14:09:31 <Heffalump> Rerun of the opening match.
14:09:56 <Igloo> Oh, it's not a simple knockout then?
14:10:08 <Heffalump> not for the opening matches
14:10:29 <Heffalump> 4 groups of 4 teams, each group played as a league; top two in each group go through to quarter-finals
14:10:49 <Igloo> Ah, right
14:10:50 <ne1> Wow lambdabot has football news.
15:20:31 <kosmikus|away> Heffalump, TheHunter: yes, I am from .de ... what was the exact problem/question?
15:20:48 <Heffalump> he was asking about unis there, IIRC
15:21:18 <Heffalump> you'd have to check logs properly for the precise question
15:22:30 <kosmikus|away> TheHunter: feel free to /msg me; I will go to bed now, but read logs tomorrow; I will try to provide whatever limitited knowledge I have ...
16:53:46 <np_hard> microsoft employs some haskell gurus, right?
16:54:08 <stepcut>  np_hard: the top!
16:54:43 <np_hard> nobody ever got fired for choosing microsoft, right?
16:54:51 <np_hard> ergo, nobody ever got fired for choosing haskell.
16:55:02 <np_hard> Q.E.D
16:55:05 <Pseudonym> I think that's true, actually.
16:55:24 <Pseudonym> This is probably because nobody has ever chosen Haskell.
16:55:28 <np_hard> aah, the old correlation/causation thing
16:55:30 <np_hard> :)
16:55:44 <np_hard> oh
16:55:46 <Pseudonym> Except in contexts where there was already agreement that Haskell was a good thing.
16:55:50 <np_hard> you are going the trivially true route
16:56:01 <Pseudonym> Yes.
16:56:10 <np_hard> oh well
16:56:15 <Pseudonym> Nobody has been promoted for choosing Haskell either.
16:56:21 <np_hard> it'd be nice if microsoft had a haskell web page
16:56:24 <np_hard> that would be good
16:56:34 <Pseudonym> I suspect that would be the kiss of death.
16:57:10 <stepcut> well, where I work, you might get fired for choosing microsoft, but not for haskell
16:57:13 <np_hard> why's that?
16:57:25 <np_hard> stepcut: not a bad gig, there
16:57:47 <stepcut> np_hard: because I work for lindows :)
16:57:53 <np_hard> oh
16:58:01 <np_hard> ha ha :)
16:58:11 <np_hard> Pseudonym: why would that be the kiss of death?
16:58:16 <np_hard> just a little page for now
16:58:36 <np_hard> nothing like a mass hype machine
16:58:44 <Pseudonym> If Microsoft actually adopted Haskell as a production language, it would kill the research imperative.
16:59:50 <np_hard> well, I suppose we must distinguish between Haskell implementations, Haskell standards, and the evolution of the Haskell language
17:00:16 <Pseudonym> True.
17:01:11 <np_hard> I guess GHC would need to be better behaved on Windows first anyway
17:01:35 <np_hard> at least the build process etc
17:02:05 <Cale> I want to see the prelude cleaned up so that we don't have 3 (more?) names for map.
17:02:20 <Heffalump> map, fmap, what else?
17:02:25 <Cale> liftM
17:02:38 <Cale> I suppose that's not in the prelude per se
17:02:54 <wagle> if "data Foo a = Baz a", is there a way to define a instance of Show (Foo a) such that if "a" is "String", then "show a" doesnt put quotes around, but if a isnt String, "show a" works normally?
17:03:12 <Cale> This seems to be a common desire for some reason.
17:03:39 <wagle> right now i'm doing overlapping instances: Show (Foo String) and Show a => Show (Foo a)
17:04:14 <Cale> I don't really understand why you'd want that, but yeah, it's at least possible with overlapping instances.
17:05:02 <wagle> data Exp a = Lambda a (Exp a) | App (Exp a) (Exp a) | Ide a
17:05:23 <wagle> if "a" is String, I dont want quotes
17:05:58 <wagle> eg (\v. v) and not (\"v". "v")
17:06:05 <Cale> Just make a type like "data Identifier = Identifier String" with an instance of Show that doesn't put quotes.
17:06:24 <Cale> (and doesn't put the Identifier either)
17:06:53 <wagle> then i have to type (Identifer "v") over and over instead of just "v"
17:07:36 <Pseudonym> wagle: You could try this.
17:07:37 <wagle> and then (Lambda (Identifier "v") (Ide (Identifier "v"))
17:07:40 <Pseudonym> @wiki TypeclassWrapper
17:07:41 <lambdabot> http://www.haskell.org/hawiki/TypeclassWrapper
17:07:49 <Pseudonym> Dunno if that helps or not.
17:08:15 <Pseudonym> Probably not.
17:08:17 <Cale> make a good instance of read
17:10:20 <wagle> was thinking of chomp x = cdr (rdc x)
17:10:35 <wagle> chomp :: String -> String
17:10:55 <wagle> but that was grosser than what i have
17:11:56 <wagle> well, actually, chomp would only want to remove the first and last chars in a string if they were "'s
17:12:21 <wagle> but then i could (chomp (show a))
17:12:26 <Cale> Is it unmanageable to have "instance Monad m => Functor m where fmap = liftM" by default?
17:12:43 <Cale> Why is that somehow undecidable?
17:13:08 <wagle> multiple inheritance
17:13:28 <wagle> well..  overlapping instances
17:13:30 <Cale> well, you just don't allow monads to be functors in any other way
17:13:44 <Cale> overlapping instances is another thing
17:14:18 <wagle> doesnt (unconstrained) class Functor define fmap?
17:14:52 <wagle> who/what is claiming "undecidable"?
17:14:59 <Cale> ghc :)
17:15:08 <wagle> whoa
17:15:21 <wagle> whats the exact error message?
17:15:21 <Cale> the first flag that you have to set is -fallow-undecidable-instances
17:15:48 <Cale> mf.hs:5:
17:15:48 <Cale>     Illegal instance declaration for `Functor m'
17:15:48 <Cale>         (There must be at least one non-type-variable in the instance head
17:15:48 <Cale>          Use -fallow-undecidable-instances to permit this)
17:15:48 <Cale>     In the instance declaration for `Functor m'
17:16:42 <wagle> maybe you gotta say which liftM you want?
17:17:08 <Cale> there's only one in scope
17:17:11 <wagle> ... where fmap = (liftM :: ... m ...)
17:17:22 <Cale> ah, hmm
17:17:29 <wagle> liftM is polymorphic
17:17:31 <Heffalump> it's unmanageable because you can't control whether other modules will make either Monad or Functor instances for random things
17:17:46 <Heffalump> s/unmanageable/hard to manage/
17:18:18 <Cale> oh, so it's to do with the module system
17:18:37 <Heffalump> essentially, yes
17:18:59 <Heffalump> you want there to be a unique route for inferring module instances
17:19:36 <wagle> where is liftM and how do i tell hugs?
17:19:47 <Cale> liftM is in Monad
17:20:07 <wagle> :l Moand
17:20:29 <Heffalump> :m +Monad
17:20:37 <Heffalump> in ghci
17:20:46 <Heffalump> in hugs, I'm not quite sure, short of loading a program that does import Monad
17:21:19 <Cale> :l Monad works
17:21:30 <Heffalump> ah, ok
17:21:38 <Heffalump> oh, so it does
17:21:41 <Heffalump> I wonder why it didn't just now
17:21:59 <wagle> yeah.. i just wanted to :t liftM
17:22:19 <Cale> Its type is exactly like map's.
17:22:26 <Cale> @type Monad.liftM
17:22:27 <lambdabot> Monad.liftM :: forall r m a1. (Monad m) => (a1 -> r) -> m a1 -> m r
17:23:22 <Cale> the implementation given in the standard library is ugly
17:23:51 <Cale> I like  liftM f x = x >>= (return . f)
17:24:03 <Heffalump> what is the library implementaiton?
17:24:14 <Cale> liftM f = \a -> do { a' <- a; return (f a') }
17:24:34 <Heffalump> that's exactly equivalent to yours, and more clear...
17:24:49 <Cale> not really
17:25:00 <Heffalump> well, maybe the a should be on the LHS, not a lambda on the RHS
17:25:02 <Cale> well, I agree that it's exactly equivalent
17:25:56 <Heffalump> how would you write map?
17:26:18 <Cale> map on what?
17:26:20 <Cale> lists?
17:26:21 <Heffalump> lists
17:27:01 <Cale> probably the same way as in the prelude
17:27:30 <Heffalump> what's that, a case analysis definition?
17:27:35 <Cale> yeah
17:27:38 <Cale> map f []     = []
17:27:38 <Cale> map f (x:xs) = f x : map f xs
17:28:33 <Cale> though the monad way is tempting :)
17:29:08 <Cale> I make lots of use of >>= on lists.
17:29:21 <Cale> it's just a shorthand for concatMap
17:29:24 <wagle> [a | a <- f a]
17:29:40 <wagle> 8)
17:29:45 <Heffalump> DYM [f a | a <- xs] ?
17:29:48 <Cale> perhaps [f a | a <- xs]
17:29:57 <wagle> prolly
17:30:02 <Heffalump> you couldn't do that in the real Prelude, because list comprehensions are defined by translation to map etc.
17:30:17 <wagle> i dont use list comprehensions enough to get it right the first time
17:30:50 <Riastradh> Who uses list comprehensions and not monads instead?
17:30:51 <wagle> reach down.  grab shoelaces.  lift.
17:31:06 <Heffalump> is anyone else seeing oddness with .org? Specifically, it seems not to be working, and the nameservers for it seem not to be the usual ones.
17:31:34 <Cale> Often the list comprehension syntax looks much better than do notation.
17:31:48 <Cale> Despite the obvious equivalence for lists.
17:31:54 <wagle> i translated a gopher program (jpeg decompression) that uses list comprehension syntax for monads that werent lists
17:31:55 <Heffalump> it's a shame they gave up on proper monad comprehensions
17:31:55 <Riastradh> Works fine for me, Heffalump.
17:32:08 <Heffalump> what servers do you see for .org itself?
17:32:12 <Cale> I think that monad comprehensions are a good idea.
17:32:30 <Cale> I wish there were a flag to turn them on.
17:32:48 <Cale> Even if they're unwilling to put them into the language proper.
17:33:08 <wagle> ugh
17:33:12 <Riastradh> Heffalump, what do you mean 'for .org itself?'
17:33:22 <Riastradh> s/'for/'see for/1
17:33:29 <Cale> ugh?
17:33:33 <wagle> the ones i translated were clunky..  do was much better
17:33:42 <Cale> Sometimes do is better
17:33:53 <Cale> it depends on the way that you're thinking about the monad
17:34:03 <Cale> if you're thinking of it computationally, do is better
17:34:04 <Heffalump> riastradh: what are the nameservers you ask for $sld.org ?
17:34:18 <wagle> this thing had to twist itself into pretzel to fit into the comprehension syntax
17:34:25 <Cale> if you're thinking of it as a container type, then often the comprehension syntax will be better
17:34:53 <Riastradh> '$sld.org'?
17:35:10 <Heffalump> what nameserver would you ask to find a random .org domain?
17:35:34 <Heffalump> what IM is, what is the output of dig @a.root-servers.net org
17:35:41 <Heffalump> or equivalent
17:35:47 <np_hard> i can't dns resolve haskell.org
17:36:08 <Cale> org.                    8504    IN      SOA     tld1.ultradns.net. domadmin.ultradns.net. 2004140191 1800 900 604800 86400
17:36:10 <Riastradh> tld[12].ultradns.net
17:36:15 <Heffalump> ta.
17:36:21 <Riastradh> (204.74.112.1)
17:36:25 <Heffalump> are those what people remember them being, if anyone does?
17:36:28 <wagle> haskell.org has address 128.36.229.215
17:36:29 <Riastradh> (& 204.74.113.1)
17:36:32 <np_hard> ty
17:36:34 <wagle> took 5-10 seconds, though
17:38:16 <Cale> If you always think of >>= as a generalisation of concatMap, then it tends to make sense :)
17:39:27 <wagle> join . fmap?
17:39:37 <Riastradh> @type join . fmap
17:39:39 <lambdabot> bzzt
17:39:45 <Riastradh> @type Control.Monad.join . fmap
17:39:46 <lambdabot> bzzt
17:39:51 <Riastradh> @type Monad.join . fmap
17:39:53 <lambdabot> bzzt
17:39:58 <Riastradh> You suck, lambdabot.
17:40:36 <wagle> fine
17:40:42 <wagle> fmap . join
17:40:59 <wagle> @type fmap . join
17:41:00 <lambdabot> bzzt
17:41:25 <Riastradh> @type fmap . Control.Monad.join
17:41:28 <lambdabot> fmap . Control.Monad.join :: forall f a a1.
17:41:28 <lambdabot> 			     (Functor f, Monad ((->) a)) =>
17:41:28 <lambdabot> 			     (a -> a -> a1) -> f a -> f a1
17:41:40 <wagle> that actually typechecks (see?)
17:41:50 <wagle> but i dont think thats what i'm remembering
17:42:16 * Heffalump thinks the .org servers are a bit broken.
17:42:36 <Riastradh> @type (.).(.)
17:42:39 <lambdabot> (.).(.) :: forall a b c a1.
17:42:39 <lambdabot> 	   (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:42:42 <wagle> but it was more that i had the vague notion that "not all monads obey the bind == fmap . join law
17:43:27 <wagle> but didnt know of any counter examples..  i played with this about a year or two ago, and dont remember
17:44:05 <Heffalump> DYM because most monads don't obey any monad laws properly due to seq, or for other reasons?
17:44:30 <wagle> s/vague/really vague and unsupported/
17:44:35 <Riastradh> @type \m f -> Control.Monad.join (m >>= f)
17:44:36 <lambdabot> \\m f -> Control.Monad.join (m >>= f) :: forall m a a1.
17:44:36 <lambdabot> 					(Monad m) =>
17:44:36 <lambdabot> 					m a -> (a -> m (m a1)) -> m a1
17:44:48 <Riastradh> @type \m f -> Control.Monad.join (fmap f m)
17:44:50 <lambdabot> \\m f -> Control.Monad.join (fmap f m) :: forall f a a1.
17:44:50 <lambdabot> 					 (Monad f, Functor f) =>
17:44:50 <lambdabot> 					 f a1 -> (a1 -> f a) -> f a
17:44:58 <Riastradh> There.  That's what you were thinking of.
17:45:19 <wagle> ... just had it mentally flagged as "figure this out someday and find the counter example"
17:46:18 <Heffalump> if you made an instance of Functor for a Monad that wasn't consistent with the fmap = liftM rule, then you could violate your law
17:46:23 <wagle> man, i gotta get my old stuff on a disk that is spinning and on the network so i can get at it
17:49:39 <Cale> I think that return and join may actually be easier for explaining monads to people, so long as you don't talk about IO.
17:49:57 <Cale> :)
17:50:04 <Riastradh> You, uh, kind of need map as well.
17:50:10 <Cale> yeah, and map
17:50:20 <Riastradh> map is a lot easier to understand than extend.
17:50:53 <Cale> That's what a monad is by the usual mathematical definition - a functor with return and join.
17:51:54 <Cale> An easier way to say that is that it's a container type with something like map, something that puts one element in a container, and something that takes a container of containers, and combines them into one.
17:52:21 <Cale> or, easier to understand for someone new to monads, is what I mean
17:52:23 * wagle blows popsicle stand
17:53:45 <Cale> A graph monad would be interesting.
17:53:59 <wagle> (for the stuff i was doing a year ago, the join connection was easier to wrap my brain around for the twisted monad i was beating my head against)
17:54:43 <Pseudonym> Cale: Is that possible?
17:54:49 <Pseudonym> How would you make a graph a functor?
17:54:59 <Cale> Labelling the nodes.
17:55:00 <Cale> :)
17:55:04 <Pseudonym> Ah, right. :-)
17:55:16 <Pseudonym> Hmmm...
17:55:20 <Pseudonym> OK, how would you implement join?
17:56:03 <Cale> Well, you'd be defining a function of type Graph (Graph a) -> Graph a
17:56:16 <Heffalump> would your graphs have entry and exit nodes?
17:56:28 <Cale> I think that having all the nodes in the inner graph inherit the edges of the outer one seems sensible.
17:57:03 <Cale> Heffalump: entry and exit nodes?
17:57:24 <Heffalump> yes, entry and exit nodes; do your graphs have specific nodes that are designated entry and exit?
17:57:29 <Cale> no
17:57:34 <Riastradh> Of what use would a graph monad be?
17:57:36 <Cale> well, they could
17:58:00 <Cale> I'm not sure - I'm not one to think of practicalities - I'm a pure math student.
17:58:04 <Cale> :)
17:58:22 <Cale> But I think I could probably come up with some good uses.
17:58:36 <Riastradh> Then do so, knave!
18:03:54 <Pseudonym> Oh, and while you're at it, prove that your join is a natural transformation.
18:03:59 <Cale> :)
18:05:45 <Cale> well, it's obviously natural
18:06:50 <Cale> If I join the graphs together, and then map f over the vertices, it's the same as mapping map f over the vertices first, and then joining.
18:09:23 <Cale> coming up with realistic applications is tricky, but it does lend itself to a nice way to recursively compute graphs
18:10:27 <Cale> where you treat vertices as perhaps not-yet-computed subgraphs, and use bind to continue the computation
18:10:51 <Riastradh> Implement it!
18:12:02 <Cale> Anyone have any suggestions as to where I should steal a labelled graph datatype? Well, I suppose that I could use Data.Graph together with a finitemap.
18:18:14 <Pseudonym> Stealing is wrong.
18:18:55 <Cale> heh
18:19:25 <Igloo> Okasaki is the place outside of the standard libraries I'd think of first to look for such a thing
18:19:36 <Igloo> Well, OK, so he's not a place, but YKWIM  :-)
18:19:38 <Pseudonym> Or FGL?
18:19:52 <Pseudonym> http://web.engr.oregonstate.edu/~erwig/fgl/
18:44:01 <Cale> btw... map f = foldr ((:) . f) []
18:44:10 <Cale> :)
19:41:39 <Spark> lol ive never made that connection before
19:43:38 <np_hard> how much do packed strings buy you over strings?
20:19:19 <Igloo> Hmm, how do I safely get information from a foreign exported function into my programming in a state-transformed IO monad?
