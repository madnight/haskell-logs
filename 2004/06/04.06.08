00:01:46 <earthy> and away again
00:36:20 <javaNewb> afternoon :)
00:36:43 <javaNewb> whats the difference between curried and uncurried functions?
00:39:13 <vegai> sum a b = a + b; inc1 = sum 1; inc2 a = sum a 1
00:39:26 <vegai> inc1 is curried
00:40:07 <vegai> the wiser shall elaborate
00:42:55 <javaNewb> curried are argument free definitions?
00:48:59 <det> javaNewb: no
00:49:13 <det> javaNewb: essentially, all functions take a single argument
00:49:38 <javaNewb> so what is curried?
00:49:59 <det> javaNewb: so, to create a multiple argument function, you either curry it, or pass it a tuple
00:50:14 <det> javaNewb: are you familiar with lambda?
00:50:18 <javaNewb> no
00:50:40 <det> well, lambda creates anonymous functions (functions you dont give a name)
00:50:44 <det> like this
00:50:52 <det> (in non-haskelly syntax)
00:51:33 <Heffalump> currying means that multiple argument functions are actually functions from one argument to another function
00:51:39 <det> a = lambda x . x
00:51:59 <Heffalump> so given the definition of sum above, you give it one argument, and you get a function from integers to integers
00:52:01 <det> is the same as defining a function a which takes x and returns x
00:52:10 <det> like fun a(x) = x
00:52:13 <Heffalump> give it the second argument and out comes the result
00:52:51 <det> javaNewb: to get multiple arguments you create a function that returns *another function*
00:53:20 <det> a = lambda x . (lambda y . x + y)
00:54:33 <det> javaNewb: so when you pass a 5 it returns another function which takes another number and returns the result of adding them
00:54:51 <javaNewb> where does it get the other number from?
00:55:20 <det> the enviroment from when the function is created
00:56:06 <det> you can think of the first function as creating the second function not until it recieves it's argument (the first number)
00:56:23 <det> Heffalump: what is the syntax for lambda in Haskell ?
00:56:47 <Jerub> (\x y -> x + y)
00:57:11 <javaNewb> add x y = x + y is curried?
00:58:08 <det> javaNewb: add x y = x + y is shorthand for: add = \x -> (\y -> x + y)
00:58:30 <Jerub> oh, you need a currying example.
00:58:40 <det> javaNewb: and "add 5 6" is shorthand for "(add 5) 6"
00:58:56 <javaNewb> the one in my lecture notes says this : Int -> (Int -> Int)
00:59:05 <Jerub> so you can have 'addfive = add 5', and that will return curried function.
00:59:15 <det> javaNewb: that is a type
00:59:21 <det> javaNewb: of a current function
00:59:25 <det> curried*
00:59:35 <Jerub> which means you can then have: (map (addfive) [1,2,3]) == [6,7,8]
00:59:35 <Jerub> ;)
01:00:16 <javaNewb> oh so curried functions are functions that can take outside arguments ??
01:00:31 <det> javaNewb: since curried function return *other* functions you can partially apply them like: addFive = add 5 will create a function which takes a numver and adds 5 to it
01:00:44 <Jerub> javaNewb: they are functions that have taken some but not all of their arguments.
01:01:02 <javaNewb> so (+3) is curried
01:01:08 <Jerub> javaNewb: yes!
01:01:09 <det> javaNewb: functions which return functions (repeat) until one finally returns your result
01:01:26 <javaNewb> oh nice
01:01:33 <javaNewb> i think i get it...:s
01:01:46 <det> javaNewb: you should investigate the lambda calculus
01:01:56 <javaNewb> after exams :)
01:02:34 <det> but anyways, a NON-curreied function would recieve *ALL* the arguments in a single tuple
01:02:37 <javaNewb> so uncurried would be functions taking a tuple or list?
01:03:02 <Jerub> javaNewb: yep. so nocurryadd (x,y) = add x y
01:03:25 <Jerub> javaNewb: since you can't partially apply a tuple.
01:03:50 <det> javaNewb: with "add (x, y) = x + y" it only recieves a single argument and returns a single number, so you cant partially apply it
01:04:25 <Jerub> det: currying is so simple, but I've never had it explained clearly to me.
01:04:42 <javaNewb> he he he
01:05:15 <javaNewb> so . == curried right?
01:06:03 <javaNewb> f.g = h
01:06:09 <det> javaNewb: of course, when you compile a haskell program, the compiler doesnt actually implement curried functions that way (it would be terribly slow) :)
01:06:14 <javaNewb> where h x = f (g x)
01:06:49 <javaNewb> how does the compiler do it?
01:06:50 <det> . is function composition
01:07:05 <javaNewb> so curried?
01:07:10 <Jerub> not really.
01:07:28 <Jerub> javaNewb: just remember that functions return functions, and you're set.
01:07:54 <javaNewb> okay
01:08:34 <javaNewb> add x y = x + y returns add x and??
01:09:01 <Jerub> javaNewb: nono!
01:09:09 <Jerub> javaNewb: look at the type of add x y
01:09:14 <Jerub> Int -> Int -> Int
01:09:43 <det> javaNewb: what does (addFive = x + 5) do ?
01:09:44 <Jerub> which means 'add is a function that takes an Int, and Returns a function of type Int -> Int'
01:09:47 <det> err
01:09:51 <det> javaNewb: what does (addFive x = x + 5) do ?
01:10:13 <Jerub> @type (+)
01:10:16 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
01:10:21 <javaNewb> adds 5 to x?
01:10:29 <det> yes
01:10:30 <Jerub> det: thats a parse error.
01:10:39 <Jerub> oh, sorry, didn't see the second one.
01:10:45 <javaNewb> oh i c + is a function
01:10:56 <det> javaNewb: irrelevant
01:11:19 <javaNewb> really? but it returns a function
01:11:27 <Jerub> actually, it is relevent. + is a function that returns a function.
01:11:31 <Jerub> hence why (+5) works
01:11:35 <Jerub> @type (+5)
01:11:37 <lambdabot> (+5) :: forall a. (Num a) => a -> a
01:12:21 <Jerub> see, (+) :: (Num a) => a -> a -> a, applied to '5' returns a  function of type :: (Num a) => a -> a
01:12:51 <det> javaNewb: (add x y = x + y), add is a function which takes x and *dynamicly creates* a function like the one above
01:13:00 <Jerub> now, just to fill you in, (Num a) => a -> a means 'a function that takes an arg of type 'a' and returns type 'a', where 'a' is a member of class 'Num'.
01:13:26 <det> javaNewb: so if you pass it 5 it will return the exact function I showed you
01:13:27 <javaNewb> class is my next revision topic :)
01:13:43 <javaNewb> so it will return x + 5?
01:14:04 <det> the function it returns will return that
01:14:56 <javaNewb> okay, add 1 = 1 + y right?
01:14:59 <det> Jerub: I suspect I am bad at explaining currying :)
01:15:12 <Jerub> det: I don't care about currying, I care about typing.
01:15:19 <Jerub> typing is haskell's greatest strength.
01:15:20 <Jerub> I love it.
01:15:37 <det> Jerub: SML has a tendancy to prefer tuples, it bothers me :p
01:15:49 <Jerub> det: might be an efficiency thing.
01:15:53 <det> javaNewb: I dont understand what you are asking, 
01:16:04 <Jerub> javaNewb: thats correct.
01:16:08 <Jerub> javaNewb: using pattern matching.
01:16:10 <Jerub> ;)
01:16:13 <javaNewb> cool
01:16:18 <Jerub> err, add 1 y = 1 + y
01:16:19 <det> javaNewb: I suspect I am parsing haskell syntax when you dont mean to
01:16:23 <Jerub> you missed the arg.
01:16:30 <Jerub> you could just say add 1 = (+1)
01:16:37 <javaNewb> but addTup (1,1) is 1 + 1?
01:16:46 <Jerub> javaNewb: yep.
01:17:21 <javaNewb> so that is uncurried because you can't input a tuble without 2 values
01:17:29 <javaNewb> *tuple
01:17:39 <det> Jerub: well, they think it helps with type errors
01:18:06 <det> Jerub: and currying is only for functions which are generally partially evaluated, like foldl
01:19:24 <det> Jerub: I wish SML has type classes, though
01:19:28 <det> had*
01:19:37 <Jerub> det: yeah, I wish python had type classes too.
01:19:57 <javaNewb> in hugs i can't use add 1 y
01:20:02 <det> I've lost interest with Python
01:20:16 <det> javaNewb: what are typing into the interpreter?
01:20:22 <javaNewb> add 1 y
01:20:48 <det> have you defined a variable named y?
01:20:57 <det> and how have you defined add?
01:22:01 <det> Jerub: do you contribute to Twisted mcuh?
01:23:59 <javaNewb> oh i see i have to pass it an integer
01:24:02 <javaNewb> its okay
01:28:49 <javaNewb> thanks
01:29:05 <det> no prob!
01:56:24 <Jerub> det: not really.
01:56:34 <Jerub> det: mostly in the form of bug reports + attached patches.
01:56:58 <det> I see
01:57:23 <Jerub> det: but I do have SVN access and am syndicated on planet.twistedmatrix.com
01:57:24 <Jerub> ;)
01:58:06 <det> :)
01:58:22 <det> do you do much Python coding then?
02:02:02 <Jerub> det: at home yes.
02:02:07 <Jerub> at work I'm a php drone.
02:02:29 <det> at work, I'm just a drone :)
02:05:08 <det> Jerub: do you prefer to work with Haskell or Python?
02:07:59 <Jerub> det: I'd prefer to work with python
02:08:16 <Jerub> frankly, I'm not competant enough with haskell to use it for the stuff I use python for.
02:08:36 <det> I see
02:25:23 <vegai> oh: http://www.cs.york.ac.uk/fp/cpphs/
02:25:39 <vegai> perhaps I can compile ghc with gcc-3.4 soon...
03:12:57 <jadrian> hello
03:13:26 <Heffalump> 'lo
03:13:37 <jadrian> hi Heffalump
03:38:08 <Bluelive> Heffalump:i have the 29 ants over 10 maps done
03:38:49 <kosmikus> and?
03:39:51 * Heffalump has a go at building our simulator in Windows
03:39:57 <Heffalump> s/simulator/visualizer/
03:40:02 <Bluelive> urchin: 1056 redteam: 939 mutant: 928 persistant: 813 fullbl: 764
03:41:54 <arjanb> how many do you have in that competion?
03:41:58 <Bluelive> 29
03:42:36 <Bluelive> arjanb: my ant ? mine is mutant
03:43:17 <arjanb> are all 29 different teams?
03:43:38 <Bluelive> no most teams have two entrys competing
04:06:39 * Heffalump discovers our code just works (TM) on Windows. Pity I didn't realise that during the contest, we'd have had an extra computer.
04:06:46 <Heffalump> s/computer/CPU/
04:12:04 <Lukhas> too bad, indeed
04:13:49 <jadrian> is there any reason why we can't have something like  f _ _ z   meaning  \x y -> f x y z
04:14:26 <Bluelive> well its been fun, till next year
04:15:34 <jadrian> the order of arguments of a function sometimes can be really non trivial to decide...
04:15:40 <jadrian> for instance take foldr
04:16:04 <jadrian> I understand the reasoning behind the current order of the arguments
04:16:44 <jadrian> but some elegant definitions with foldl become a mess with foldr...
04:17:17 <jadrian> if the foldr order was:  foldr f as b   then we'd have:
04:17:25 <jadrian> f a b    
04:17:37 <jadrian> (foldr f) as b
04:18:12 <jadrian> foldr (foldr f) ass b
04:18:44 <jadrian> all have the same order, a on left b on right
04:18:58 <jadrian> point free definitions would be easy...
04:20:12 <jadrian> but then again... I can see situations where the current order would be better...
04:20:41 <jadrian> lambda abstractions just seem overkill for partial aplication...
04:42:50 <Heffalump> I don't suppose anyone has a Haskell implentation of the Lengauer-Tarjan dominator finding algorithm?
04:47:15 <tyler> Heffalump: writing a compiler ?
04:52:44 <Heffalump> decompiler.
04:52:48 <Heffalump> well, planning to
04:52:58 <Heffalump> I've got an SML implementation, but I want to write my decompiler in Haskell.
06:06:25 <chucky> hmm. Anyone know of a library for describing mime-types (in Haskell, of course)
06:06:59 <andersca> how do you mean describing?
06:08:54 <chucky> I'm trying to write a datatype describing the iCalendar-format, and it is described as a mime-type. So I want some "general" mime Haskell type that I can construct my more specific iCalendar type from
07:20:38 <SyntaxNinja> is everyone recovering from the contets? or is it still ongoing?
07:22:25 <Igloo> It's over but I think everyone is watching simulations of ants and peering at graphs and whatnot still  :-)
07:23:38 <SyntaxNinja> hehe
07:34:41 <SyntaxNinja> Igloo: ghc is panicing w/ template haskell code where: module A uses (th code) module B to generate an instance of class C for type D, then module A makes an overlapping instance of C for D.
07:35:19 <Heffalump> "fit knob A into slot B, and pull on handle C to turn off light D"?
07:35:19 <SyntaxNinja> Igloo: I blame you.
07:35:31 <Heffalump> SyntaxNinja: you're in good company, I blame Igloo a lot too.
07:35:54 <SyntaxNinja> Heffalump: yeah, there were maybe too many names there, but when I started the sentence, I was too lazy to figure out which ones I would definitely have to refer back to.
07:36:14 <Heffalump> I was just trying to be funny, not having a dig :-)
07:36:31 <Heffalump> I would expect that kind of problem report to be complicated.
07:36:37 <SyntaxNinja> hehe
07:37:08 <SyntaxNinja> maybe I should complain to JaffaCake but he seems to be missing.
07:37:18 <SyntaxNinja> I already sent him tons of email over the weekend.
07:37:36 <Heffalump> you weren't making an ICFP entry like any good Haskell programmer should?
07:37:37 * SyntaxNinja is wearing a Haskell t-shirt today
07:38:10 <SyntaxNinja> nah. I've sworn off ICFP until all of my programming projects are in really good shape, and since we know that if all of my projects were in good shape, I'd take on new ones, that'll probably never happen ;)
07:38:23 <Heffalump> ;-)
07:57:03 <kosmikus> where is the redteam link?
07:57:16 <Heffalump> tomas.rockiki.com/icfp2004/ , from memory
07:57:33 <Heffalump> http://tomas.rokicki.com/icfp2004/
07:58:50 <kosmikus> ah, that's the author of dvips, isn't it?
08:00:11 <Heffalump> oh, maybe
08:00:27 <Heffalump> They (well, he + others, not sure if the same others) came 2nd in 2002 and 2003.
08:01:13 <kosmikus> ok, that gives some weight to their submission
08:07:06 <kosmikus> Heffalump: do you have a script to turn lowercase ant files to ones we can parse?
08:07:18 <Heffalump> Igloo does
08:07:41 * Heffalump fails to find it with a quick look around
08:07:48 <kosmikus> Igloo: could you push this script?
08:08:09 <Heffalump> I told you about simvis, didn't I?
08:08:33 <kosmikus> yes, you wrote a mail
08:10:07 * Heffalump sees Igloo walking down Keble Road.
08:10:16 <Heffalump> so I doubt he's in a position to push his script right now :-)
08:10:32 <kosmikus> ok ...
08:11:44 * Heffalump tells him
08:13:53 <Igloo> Pushed
08:14:30 <kosmikus> thanks
08:17:41 <Igloo> SPJ said SM was on holiday a few days ago
08:18:08 <SyntaxNinja> Igloo: I figured. haven't seen hide nor hair of him
10:53:37 <cbus> bring: when did eurohaskell start?
10:54:28 <andersca> @eurohaskell
10:54:28 <lambdabot> less talks, more code!
10:54:28 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
10:54:28 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
10:55:16 <bring> thursday
10:55:16 <cbus> i think ill visit some during thursdat/saturdat
10:55:16 <cbus> -t+y
10:55:16 <bring> I changed the starting time from 9am to 10am
10:55:16 <cbus> work until 06 on thursday :)
10:55:20 <bring> sweet
10:55:53 <bring> 9 is so early
10:55:58 <andersca> yay, that's good
10:58:15 <bring> andersca: maybe >>= should lead to the monad
10:58:20 <andersca> yes
10:58:23 <bring> aka EuroHaskell pub
11:00:33 <bring> so we need the following signs:
11:00:48 <bring> a couple of (>>=) going to the monad
11:01:05 <bring> some (>>>) pointing to ES63
11:01:13 <bring> liftM6 for the elevator
11:01:16 <andersca> haha
11:01:19 <andersca> @type liftM6
11:01:21 <shaleh> morning all
11:01:21 <lambdabot> bzzt
11:01:23 <andersca> bzzt
11:01:32 <bring> @type Monad.liftM6
11:01:33 <lambdabot> bzzt
11:02:04 <bring> and unsafePerformIO för the restrooms on the 6th floor in Linsen
11:02:10 <bring> s/för/for/
11:02:14 <ludde> :)
11:02:29 <bring> hej phubuh
11:02:35 <phubuh> hej hej bring
11:02:41 <bring> we'll probably meet at 10 intead
11:02:44 <bring> more humane
11:02:51 <phubuh> ah, fine with me :)
11:03:16 <bring> maybe it's time to start hanging out in #eurohaskell
11:03:26 <phubuh> oh, great
11:04:09 <bring> anyone have enough privileges to get lambdabot to join #eurohaskell?
11:23:13 * Spark looks for tickets again
11:23:24 <Spark> ;)
11:23:33 <bring> hi Spark
11:23:36 <bring> any luck?
11:23:58 <bring> you guys could hitchhike over here
11:24:29 <phubuh> my brother will be driving us for eight hours or so :)
11:24:30 <Spark> :)
11:24:39 <mikef> Shall we drive?
11:25:16 <bring> phubuh: where do you live?
11:25:22 <phubuh> very close to gävle
11:25:27 <bring> damn
11:25:36 <bring> I thought you lived in gothenburg
11:25:40 <phubuh> oh, hah
11:25:52 <bring> do you have somewhere to stay in gothenburg?
11:26:35 <phubuh> i was going to stay at sgs veckobostäder, but it turned out we can stay at my friend's brother's place, so yeah
11:27:40 <SyntaxNinja> I need an alter ego for when lack of diplomacy is called for.
11:27:50 <SyntaxNinja> Smerdyakov: want the job? ;)
11:27:53 <Spark> if i came i'd be booking at the hostel place i imagine
11:27:56 <shaleh> SyntaxNinja: GrammarNazi?
11:27:58 <Spark> or just staying awake the whole time :)
11:28:11 <SyntaxNinja> shaleh: heh
11:29:02 <shaleh> can someone point me to where literate haskell is defined?
11:29:27 <kosmikus> in the report, some appendix
11:29:37 <Spark> what is literate haskell? :)
11:29:41 <shaleh> kosmikus: thanks.
11:29:42 <Spark> some kind of formal standard?
11:29:52 <bring> the opposite of illiterate haskell
11:30:04 <SyntaxNinja> Spark: haskell code with a .lhs extension where everything is a comment
11:30:10 <SyntaxNinja> everything, that is, except for lines that start with "> "
11:30:12 <Spark> :|
11:30:14 <kosmikus> appendix c, to be precise
11:30:18 <Spark> sounds a bit insane
11:30:19 <SyntaxNinja> or \begin{code} ... \end{code}
11:30:29 <Spark> oh i see
11:30:30 <SyntaxNinja> then you can run lhs2latex or something to produce a document.
11:30:33 <shaleh> Spark: the idea is the code IS the documentation.
11:31:15 <Spark> bits of code amongst documentation instead of bits of documentation amongst code :)
11:31:18 <ludde> there seems to be a " missing at the right side of the topic
11:31:22 <SyntaxNinja> one nice property of it is that you can put "#!/usr/bin/runhugs" at the top of a literate haskell script without pissing off the compilers.
11:31:34 <phubuh> ludde: sounds like a job for the syntax ninja
11:32:28 <ludde> hm nevermind, i think it's just my client
11:32:31 <SyntaxNinja> ludde: looks good to me
11:32:32 <SyntaxNinja> oh
11:32:40 <ludde> it can't display such long topics
11:33:03 <SyntaxNinja> where is shapr?
11:33:13 <ludde> at europython without internet access afaik
11:33:38 <SyntaxNinja> ahh
11:33:45 <Marvin--> he said he didn't bring a laptop, for some strange reason
11:33:53 <SyntaxNinja> hm... what if JaffaCake is actually at Eurohaskell?!
11:33:55 <SyntaxNinja> er
11:33:57 <SyntaxNinja> EuroPython
11:34:09 <SyntaxNinja> Marvin--: I don't think he has one
11:34:19 <Marvin--> SyntaxNinja: as I said, "some strange reason" :-)
11:35:07 <Marvin--> what would JaffaCake be doing at europython?
11:35:55 <SyntaxNinja> Marvin--: THAT'S EXACTLY WHAT I'D LIKE TO KNOW111!1
11:36:03 <phubuh> JaffaCake, that's simon marlow, right?
11:36:30 * Marvin-- slowly backs away from the ninja, afraid he'll flip out and kill someone
11:37:03 <SyntaxNinja> I got my new driver's license today, and i'm wearing a haskell shirt, but they cropped it off :(
11:37:10 * SyntaxNinja flips out
11:37:24 <SyntaxNinja> phubuh: ja
11:39:22 <Marvin--> well, I haven't seen him, anyway
11:41:06 <Spark> my photo looks quite goth, since its devoid of any kind of colour and my hair is tied back
11:43:32 <Spark> i know a girl who is so pale and skinny and dark haired that her driving license looks just like michael jackson
11:43:35 <Spark> error :|
11:43:39 <shaleh> heh
11:43:57 <shaleh> how does one flush stdout in haskell?
11:44:44 <Marvin--> hFlush stdout    I think
11:44:50 <Marvin--> if you import System.IO
11:45:42 <shaleh> Marvin--: yes, thank you.
11:45:47 * shaleh needs to read the library docs.
11:46:02 <SyntaxNinja> Spark: yeah, this one is really light too
11:46:06 <shaleh> putStr prompt (which does not have a newline) does not actually print.
11:46:16 <shaleh> need to flush it.
11:46:22 <SyntaxNinja> good idea
11:47:14 <Marvin--> shaleh: alternatively, turn off the line buffering
11:47:24 <shaleh> Marvin--: hmm, good point.
11:47:38 <shaleh> Marvin--: but then, I may want it elsewhere.
11:47:39 <Marvin--> hSetBuffering stdout NoBuffering
11:47:43 <Marvin--> sure
11:47:57 <shaleh> Marvin--: thanks for the suggestion though.
11:48:10 * shaleh is implementing a desk calculator to further learn Haskell
11:50:13 <SyntaxNinja> shaleh: you should implement a binding to a zip library instead because I have the feeling we will need one (if there's not one already)
11:53:01 <shaleh> SyntaxNinja: let me learn the language, then do that.  At this point I am fumbling around still.  This is the first language I have learned just from the language specs and what not.  It is an interesting experience not having an ORA book to fall back on.
11:53:18 <shaleh> so I decided to implement the usual cs 101 things.
11:53:35 <shaleh> maybe a few things from my other learning LANGUAGEX books.
11:55:44 <SyntaxNinja> shaleh: that's an interesting approach; you're not interested in using the tutorials?
11:56:51 <shaleh> SyntaxNinja: I have read the gentle intro.  It was helpful, but not sufficient.
12:16:01 <shaleh> SyntaxNinja: is there another tutorial I should read?
12:17:56 * shaleh continues to be disappointed with the Haskell-mode in emacs.
12:18:25 <Lukhas> shaleh: why ?
12:18:53 <shaleh> Lukhas: it handles layout poorly and its color coding is pretty bad too
12:19:14 <shaleh> I used an inline {-- comment --} and it did not properly recolor
12:19:22 * Lukhas is quite satisfied with it
12:19:29 <Lukhas> font-locking is slow, sure
12:19:43 <shaleh> no, the rest of my line is red i.e. comment colored
12:19:59 <shaleh> it seems to treat {-- --} and -- the same
12:20:11 <Lukhas> even after a M-x font-lock-fontify-buffer ?
12:20:34 <shaleh> Lukhas: yes.
12:20:40 <Lukhas> weird
12:21:23 <SyntaxNinja> shaleh: are you an elisp hacker? 
12:21:48 <shaleh> SyntaxNinja: learning that as well (-:
12:21:56 <SyntaxNinja> it'll treat /foo "--bar" bang/ wrong too
12:21:59 <shaleh> SyntaxNinja: will learn enough to fix Haskell mode (-:
12:22:06 <SyntaxNinja> shaleh: wonderful!!!
12:22:11 <phubuh> whoo hoo
12:22:21 <SyntaxNinja> shaleh: I'm going to hold you to that. wha't syour home  address?
12:22:40 <SyntaxNinja> simon marlow is happy to maintiain it and apply patches, but doesn't really want to do any serious hacking on it.
12:22:41 <phubuh> dude, don't give it to him, he'll totally FLIP OUT
12:24:18 <SyntaxNinja> \msg phubuh don't make me mad...
12:24:21 <SyntaxNinja> oops
12:25:17 * Marvin-- ponders whether SyntaxNinja is a mammal
12:26:41 <shaleh> SyntaxNinja: as I told shapr, if I like haskell (yet to make that decision) I tend to fix tools that I don't like.
12:27:01 <shaleh> SyntaxNinja: shaleh@debian.org.  feel free to nag me later (-:
12:27:16 <SyntaxNinja> shaleh: ok
12:27:40 <SyntaxNinja> phubuh: I can just check the debian developer database ;)
12:27:58 <shaleh> SyntaxNinja: now, the other side of this may be that getting elisp's regex based matching to deal with haskell may be too hard to get right and the mode currently does the best it can.
12:28:26 <shaleh> but, I have been spoiled by just how damn good python mode is.
12:28:54 <Lukhas> ha, i dislike that one
12:29:33 <shaleh> why? it just works
12:29:52 <shaleh> I find it frustrating that I can not simply use tab to line up my code in haskell-mode
12:30:29 <Lukhas> i find frustrating that i can't cycle through different indentation levels easily in python-mode
12:30:37 <Lukhas> whereas i can in haskell-mode
12:30:38 <SyntaxNinja> shaleh: actually, from what I understand, the regexp matching is just aout as good as it can get, but there is another way to write the mode without using regexps, presumably something more expressive.
12:33:31 * Marvin-- reads Tanenbaum's latest rebuttal to Ken Brown
12:33:48 <SyntaxNinja> Marvin--: is it new new?
12:35:15 <shaleh> Lukhas: for instance.  I have a new function.  foo = do something\nline <- myGetLine.  The second line is properly indented to start under the 's' in something.  When I start the next line it wants to line up under the 'm' in myGetLine rather than under the 'l' in line.
12:35:24 <Marvin--> SyntaxNinja: from June 6th
12:36:04 <Marvin--> http://www.cs.vu.nl/~ast/brown/rebuttal/
12:37:18 <Lukhas> shaleh: ok
12:38:05 <shaleh> Lukhas: is that expected behavior? how do you deal with it?
12:38:24 <Lukhas> shaleh: the "i don't care that much" behavior :)
12:38:54 <shaleh> heh
12:39:10 <shaleh> well, at least I know I am not crazy
12:39:18 <Lukhas> hit TAB a second time, you'll get the point under the "l" of line
12:40:43 <shaleh> aha
12:40:55 <shaleh> I was not expecting that behavior
12:41:11 <Lukhas> hey, and you're criticizing that masterpiece ? :)
12:41:19 <shaleh> heh
12:41:21 <Lukhas> i can't do that in python, that's why i dislike it
12:41:34 <shaleh> usually in emacs, once it has decided what the indent is, you are stuck with the choice
12:41:41 <shaleh> every other mode I have used works like that
12:42:37 <Lukhas> in other modes, you usually have () [] or {} to tell you what is the expected level of indentation
12:43:51 <shaleh> Lukhas: well, now I can see that haskell-mode is far less brain damaged than it first appears
12:43:53 <shaleh> thanks
12:44:00 <Lukhas> my pleasure :)
12:44:17 <shaleh> I wonder if shapr knows about this.
12:44:26 <Lukhas> i hope he does
12:45:01 <Marvin--> I really like Tanenbaum's style of writing and mocking Ken Brown
12:45:14 <SyntaxNinja> wow. these guys really can't write "For us to accept Tanenbaumâ€™s argument, Linus Torvalds at 21, with one year of C programming, was Doug Comer, an accomplished computer scientist, or smarter than the Coherent team, and of course a better programmer than the good professor too."
12:45:19 <SyntaxNinja> not to be the syntaxpolice or anything
12:45:29 <Marvin--> I know, Ken Brown really really sucks at writing
12:45:38 <Marvin--> "Linux is a leprosy"  <- wtf?
12:45:43 <Marvin--> *a* leprosy?
12:45:53 <SyntaxNinja> "Isnâ€™t fair to question the character and ethics of individuals that espouse contempt for intellectual property? Isnâ€™t fair to question their character, when the core of their business strategy is trust?"
12:46:07 <SyntaxNinja> maybe that's some actual correct wording that no one uses
12:46:29 <shaleh> I guess I should have read Ken Brown's statement
12:46:55 <shaleh> SyntaxNinja: needs a couple of 'it' s
12:48:28 <SyntaxNinja> "Yet Tanenbaum vehemently insists that Torvalds wrote Linux from scratch, which means from a blank computer screen to most people. No books, no resources, no notes -- certainly not a line of source code to borrow from, or to be tempted to borrow from."
12:48:52 <SyntaxNinja> I wrote a JPEG decoder from scratch!
12:48:56 <SyntaxNinja> (not really)
12:49:08 <SyntaxNinja> This guy needs to learn something about computer programming
12:49:24 <Marvin--> yes
12:49:31 <Marvin--> I really really wonder what this guy's background really is
12:49:41 <shaleh> Ken?
12:49:53 <Marvin--> since he obviously knows nothing about a) programming, b) law and c) writing
12:50:00 <Marvin--> yes, Ken Brown
12:50:22 <shaleh> the fun part will be when the source of funding is revealed.
12:50:47 <SyntaxNinja> "The GNU team contributed their GCC compiler, a complicated product with over 110,000 lines of code to the Linux project. Without the compiler, it is very likely that the Linux project would not have succeeded."
12:50:48 <SyntaxNinja> hahaha
12:50:58 <SyntaxNinja> OK I'll stop now
12:51:23 <Marvin--> :)(
12:53:10 <Marvin--> "I was on the debating team in high school. I guess I am getting rusty."
12:53:17 <Marvin--> (Tanenbaum)
12:55:53 <SyntaxNinja> he likes this "linus admits that 'inventor' is the wrong word" business
12:59:14 <Marvin--> the whole story is just downright sad
13:03:59 <shaleh> indeed
13:18:07 <goron3> I have a kind of challenge: what's the inverse of bind (>>=)?
13:19:42 <goron3> Nobody here?
13:20:02 <SyntaxNinja> BING
13:20:04 <Marvin--> um
13:20:15 * SyntaxNinja wasn't quick enough with the buzzer
13:41:09 <Marvin--> http://www.kuro5hin.org/comments/2004/6/5/7424/26396/141#141 <- hahaha
13:41:19 <Olathe> If you don't specify the sequence of events in functional systems, is it really programming ?
13:43:27 <Smerdyakov> What definition are you using for "programming"?
13:44:26 <Marvin--> If you are relying on high level constructs like if and while rather than gotos, is it really programming?
13:45:54 <Olathe> By programming, I mean specifying the order that something will occur, like in procedural programming, a television programming, or a paper program for an event.
13:46:22 <Smerdyakov> I don't think that's the definition in common use today, Olathe.
13:46:32 <Olathe> Maybe not.
13:46:33 <Smerdyakov> (for computer programming)
13:49:13 <Olathe> Now that I think of it, in functional programming, the order is specified for some things.
13:49:54 <SyntaxNinja> Olathe: what if it's targeting assembler?
13:50:25 <Marvin--> Olathe: only when we have to, and with deepest regrets :(
13:50:54 <SyntaxNinja> Marvin--: nice kuro5hin quote
13:52:00 <Marvin--> SyntaxNinja: I just found the whole "oh my god, people are giving away stuff for free, this will ruin the economy!!" position so insanely absurd that I don't know what to say
13:52:33 <Olathe> Well, if the result of a function is used as an input to another function, the first function has to be done first.
13:53:21 <Marvin--> if it is actually used, yes
14:09:39 * vazio is away: (Auto-Away after 10 mins) [BX-MsgLog On]
15:37:49 <phubuh> hm
15:38:20 <phubuh> i've got an SQL query whose result has two columns with the same name
15:38:26 <phubuh> can i get at them with HSQL?
15:40:24 <shaleh> why not fix the sql query (-:
15:41:04 <phubuh> that's a good idea, but this is a silly useless language comparison thing, and the SQL query isn't under my control
15:41:25 <phubuh> actually it is, but i'd be kind of breaking the rules.  but i'll just do that, the rules suck
15:41:35 <shaleh> (-:
15:41:58 <shaleh> I do not know HSQL, but usually you can access results by column number as well as by name
15:42:28 <phubuh> yeah, but i can't find anything like that in the reference manual, bah
15:43:46 <monotonom> You have control over what Haskell code you write, don't you?
15:44:16 <phubuh> yup, but the literal SQL query is included in the task description
15:44:22 <phubuh> if it weren't, I'd be using HaskellDB :-)
15:44:52 <monotonom> I am sure whatever you do in other languages you can do the same in Haskell.
15:45:53 <monotonom> Does the SQL standards even permit this to happen?  I mean two columns with the same name.
15:46:17 <phubuh> when i do "select sum(a), sum(b) from tbl" in postgresql, they're both named "SUM"
15:47:02 <monotonom> Alright I admit.
15:51:31 <monotonom> Oh yuck all I see is by-name not by-column
15:53:35 <monotonom> forEachRow may be of tremendous use.
15:57:09 <monotonom> Oh well it isn't. This is disappointing.
16:18:02 * Lemmih wonders what the average age of the EuroHaskell attenders is...
16:18:45 <Heffalump> early - mid 20s, I'd guess
16:18:52 <Heffalump> shapr is late 20s IIRC
16:20:09 <Igloo> He's 32 isn't he?
16:20:41 <Lemmih> Whoa.. that's almost twice my age.
16:20:53 <Heffalump> oh, ok
16:21:06 <Heffalump> lemmih: I shouldn't worry about it, you'll have the energy of youth :-)
16:21:42 <Igloo> I wouldn't be surprised if shapr is the oldest there
16:22:56 <phubuh> I'll be bringing a 15 year old, a 17 year old, and an 18 year old
16:24:50 <Lemmih> phubuh: Family?
16:25:24 <phubuh> the 15 year old (me) and the 18 year old are brothers;  the 17 year old is a friend of mine
16:25:38 <Heffalump> do they IRC, OOI?
16:26:16 <phubuh> yup, but not in #haskell :-) they're not really haskell people as such, but they're interested
16:30:02 <Lemmih> I would attend if I had somebody with me... But I don't know many programmers IRL. /-:
16:33:36 <shaleh> ok, say I have a string like "2 + 2".  I am writing a simple desk calculator to learn haskell.  if I use words() I get ["2", "+", "2"].  How do I convert the "2" into the Integer 2?
16:33:51 <Heffalump> read
16:34:23 <Heffalump> and make sure that Haskell can figure out you actually want an Integer (e.g. by passing it to +, or by giving an explicit type signature)
16:35:08 <shaleh> Heffalump: what I am currently trying to do is something like "if isDigit (head (words input))"
16:35:20 <Heffalump> to see if it's a number or not?
16:35:23 <shaleh> i.e. tell if I was passed "2 + 2" and not "+ 2 2"
16:43:46 <shaleh> Heffalump: it is frustrating.  Most of the text on the web about haskell assumes I want to write another Fibonacci sequence and not do more common application programming.
16:44:27 <Pseudonym> Part of the reason for that is that Haskell programming is different from programming in many other languages.
16:44:54 <Pseudonym> I'm not trying to defend it.
16:45:40 <shaleh> Pseudonym: I accept and welcome the difference.  However, I am not using haskell for math or logic.  I want to use it where I would use python or C++.
16:45:52 <Pseudonym> Right.
16:46:04 <Pseudonym> Like I said, I'm not defending all of those bad tutorials out there. :-)
16:46:08 <shaleh> (-:
16:46:26 <shaleh> hell, I may even be willing to write better docs.  But I have to learn the language first (-:
16:47:19 <Heffalump> shaleh: what you said sounds reasonable-ish
16:47:30 <Heffalump> if you want to distinguish between "2+2" and "+ 2 2", anyway
16:47:38 <shaleh> Heffalump: isDigit expects a char, not a string.
16:47:43 <Heffalump> but I'm not sure why you want to; such a distinction seems hard to make in general
16:47:49 <shaleh> or that is what the compiler error message said
16:47:50 <Heffalump> oh, use head again
16:47:58 <Heffalump> a String is a list of Char
16:48:35 <wagle> is there a syntax for a infinite list of 0's?  eq [0..10]
16:48:41 <shaleh> Heffalump: right.  I knew this.  What I was failing to realize was that head "1234" was just as useful in this case as testing the whole string
16:49:21 <shaleh> Heffalump: you know how you get stuck trying to accomplish a task in one manner and you fail to notice it has other solutions (-:
16:49:23 <phubuh> wagle: repeat 0 :)
16:49:25 <Pseudonym> wagle: [0,0..0] works, but I'm not convinced that it should.
16:49:39 <Pseudonym> Yes, repeat 0 is better.
16:49:47 <Pseudonym> Or let zeroes = 0 : zeroes in ... zeroes ...
16:50:03 <Heffalump> it's not ideal, because of the "-1" problem
16:50:20 <Heffalump> but I think deciding whether "-1+1" is infix or prefix will be hard work.
16:51:11 <shaleh> Heffalump: true. but for a trivial code project intending to just learn ths language I need not allow such constucts.
16:51:33 <Heffalump> ok; but I'd recommend not trying to disambiguate at all
16:51:40 <Heffalump> just assume either infix or prefix and implement that
16:51:50 <shaleh> Heffalump: ah, but what fun is that (-:
16:52:00 <Heffalump> it's more likely to work reliably :-)
16:52:11 <Heffalump> you could then implement the other one too, and write a cunning global guesser
16:52:12 <phubuh> shaleh: by the way, you could use `all isDigit token'
16:52:16 <Heffalump> which would switch between them
16:52:40 <shaleh> phubuh: hm, true.
16:53:26 <shaleh> Heffalump: I was hoping to support standard math (+, -, /, *) and functions like tan.  So the infix, prefix thing is kind of a red herring.
16:53:55 <shaleh> I guess long term this is "write a lexer in haskell"
16:55:09 <Riastradh> Just use S-expressions.
16:55:24 <Pseudonym> How does using S-expressions help you write a lexer?
16:55:31 <Pseudonym> Have you SEEN the lexical language for Common Lisp?
16:55:34 <Heffalump> the point is that disambiguating between + as infix and + as prefix is a nightmare.
16:55:44 <shaleh> Heffalump: agreed.
16:55:46 <Heffalump> words is a pretty good lexer for arithmetic expressions
16:56:07 <shaleh> Heffalump: I was expecting something more haskell-ish like 2 + 2 v. add 2 2
16:56:14 <Heffalump> obviously tan does need to be prefix, but that's much easier cos you know that from the fact that you have tan
16:56:33 <Heffalump> right, so doing what Haskell does - either have "2+2" or "(+) 2 2" - is fine
16:56:37 <Pseudonym> Hand-writing lexers in Haskell is actually dead easy, using pattern matching.
16:56:58 <Pseudonym> It's a little trickier if you want to use regular expressions for your source language.
16:57:00 <shaleh> Pseudonym: how do you say "this thing is a Num" in patterns?
16:57:03 <Pseudonym> But there are lexer generators.
16:57:29 <Riastradh> Pseudonym, regardless of how complicated the specification for Common Lisp's lexicalities are, S-expressions are a very simple format.
16:57:34 <Pseudonym> shahleh: When I say "dead easy", I should point out that I hand-write lexers in C.
16:57:43 <Pseudonym> Basically, I implement it as a hand-written DFA.
16:57:43 <Jerub> bah, parser combinators > lexers
16:57:46 <Pseudonym> One function per state.
16:58:37 <shaleh> Pseudonym: right.  I am trying to learn the basics in haskell to accomplish that.  First step is learning how to take a string input and make a number out of it.
16:59:14 <Pseudonym> Riastradh: I disagree.  If the lexical language is horrible, there's a lot of the advantage of S-expressions effectively negated.
16:59:15 <tyler> I have a question about interpretation of lambda calculus on abstract machine, anyone can face this ? ;)
16:59:24 <Pseudonym> tyler: Which abstract machine?
16:59:31 <tyler> Pseudonym: krivine machine for instance 
16:59:53 <Pseudonym> Never heard of that one.
17:00:24 <Riastradh> Pseudonym, the specification of the lexical language is irrelevant.  That there are very simple S-expression parsers in existence proves you wrong.
17:00:33 <Pseudonym> You wouldn't prefer the CAM, TIM, G machine or STG machine, would you?
17:00:51 <Pseudonym> Riastradh: And they don't conform with Common Lisp, I'm sure.
17:01:03 <tyler> its a stack based machine with a band where the lambda terms are put, and with a stack where closure and saved (push) when execution an instruction of the machine, OR pop a closure if the current instruction is an abstraction
17:01:04 <shaleh> Riastradh: whether or not S-expressions are simple does not change my goal.  It is not truly to make a calculator it is to learn HOW to make the calculator.
17:01:05 <Pseudonym> I do realise that CLtL2 isn't the only language based on S-expressions.
17:01:27 <Riastradh> shaleh, why won't S-expressions help you there?
17:01:38 <Pseudonym> But conversely, S-expressions do not automatically make parsing simple.
17:01:45 <Heffalump> why on earth has this got into a debate about S-expressions?
17:01:48 <Riastradh> Pseudonym, and Common Lisp is not exactly a good reference for clean specification.
17:01:52 <phubuh> simple S-expressions are so trivial that implementing them is hardly an exercise at all (-:
17:01:52 <Heffalump> shaleh: what help do you need to continue with your calculator?
17:02:10 <shaleh> Heffalump: you have been most helpful.  I think I can continue now.
17:02:16 <Pseudonym> Riastradh: My point is that "Just use S-expressions" is not an answer.
17:02:32 <Heffalump> no, in fact it's a bloody stupid answer to give a Haskell newbie.
17:02:54 <Heffalump> Since they're (a) not natural Haskell idioms and (b) "Just use foo" where foo is not something really obvious is rather unhelpful.
17:03:15 <Pseudonym> tyler: What are the components of the machine state?  Stack, and what else?
17:03:18 <Pseudonym> Is there an environment?
17:03:29 <Riastradh> Pseudonym, yes, it is.  You don't have to worry about complicated syntax that tries to imitate -- and tends to fail -- at being truly algebraic, and you don't need to spend great deals of time and effort on parsing that you would have needed to with a complicated syntax.
17:03:39 <tyler> Pseudonym: CAM, TIM, G machine or STG machine, is there a little paper that I can read the specify the most differences between those ?
17:04:10 <Pseudonym> tyler: The CAM (Categorical Abstract Machine) is basically SK combinators.
17:04:11 <tyler> Pseudonym: the environment is lambda terms
17:04:20 <shaleh> Heffalump: when talking about haskell, how do you differentiate between a variable foo and a function foo?  would calling the function foo() be reasonable?
17:04:24 <tyler> I thought CAM meants Computable Abstract Machine
17:04:33 <Pseudonym> Hang on, let me check.
17:04:34 <Riastradh> shaleh, variables are orthogonal to functions.
17:04:53 <shaleh> Riastradh: I understand this.  I mean when talking about them. to other people.
17:04:58 <shaleh> or in comments.
17:05:13 <Riastradh> Just use the name of the variable that will hold a function value.
17:05:24 <Heffalump> shaleh: they inhabit the same namespace
17:05:26 <Pseudonym> According to Asperti and Longo, section 9.4, it's Categorical Abstract Machine.
17:05:29 <Heffalump> so normally one doesn't try to distinguish
17:05:39 <Pseudonym> But I wouldn't be shocked if there was more than one CAM.
17:05:45 <Heffalump> and indeed Haskell's lazy evaluation means that one can always write a function that takes no arguments as a simple variable
17:05:51 <Cale> shaleh: functions are values just like ints
17:05:55 <shaleh> right
17:05:57 <Pseudonym> I don't know of a paper critiquing all of the machines.
17:06:00 <Heffalump> (though variable is a misnomer since they can't change; values is a better term)
17:06:07 <Pseudonym> web.yl.is.s.u-tokyo.ac.jp/~affeldt/ study/abstract_machines.ps
17:06:09 <Pseudonym> That might help.
17:06:12 <shaleh> Heffalump: hmm, yes.
17:06:16 <Riastradh> Heffalump, gah, 'variable' does _not_ imply mutability.
17:06:19 <Pseudonym> Ah, rogue space in there.
17:06:20 <Smerdyakov> Pseudonym, I bet you copied that from Google search results.
17:06:23 <Pseudonym> I did!
17:06:34 <shaleh> Riastradh: um, the word 'variable' means 'changing'
17:06:41 <Pseudonym> The space and the lack of the http:// is always a giveaway.
17:06:44 <Heffalump> it van vary with things other than time, though
17:06:55 <Heffalump> e.g. input parameters to the entire program, or dynamic scope
17:06:58 <Riastradh> Yes, variables vary, but _not_ by destructive update.
17:07:06 <Riastradh> Not _necessarily_ by destructive update, I mean.
17:07:21 <Smerdyakov> Well, in Haskell, they never vary by destructive update. :)
17:07:27 <Riastradh> Indeed.
17:07:29 <Heffalump> I agree with Riastradh in principle, but in practice I think encouraging newbies to think of them as being "values" is helpful to get how Haskell is different across.
17:07:41 <Riastradh> They are therefore immutable variables, not some concept other than 'variable.'
17:07:48 <Jerub> hey, whats a good library to use in hsakell for arrow based parsing.?
17:07:59 <Heffalump> lambdabot, seen Lor?
17:08:06 <Riastradh> @seen Lor
17:08:07 <lambdabot> Lor is in #haskell.
17:08:07 <Heffalump> lambdabot: seen Lor
17:08:07 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:08:14 <Heffalump> doh. I should have known that :-)
17:08:22 <Heffalump> hmph, he doesn't know when Lor last spoke.
17:08:35 <lambdabot> No, I don't.
17:08:51 <Heffalump> he's idle 22 hours so I have a pretty good guess, as it happens
17:08:52 <lambdabot> And I'm not sure if I'm a "he" or not.
17:09:05 <Heffalump> lambdabot: the bits of you that I wrote are.
17:09:05 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:09:14 <Heffalump> If you want to be female in the other bits, I don't care.
17:09:31 <lambdabot> I didn't say I *wanted* to be one or the other.
17:09:37 <Heffalump> but since I think I was the most recent person to really hack on your main loop, you'll have to accept it.
17:09:59 <lambdabot> I'm so confused.
17:10:05 <lambdabot> Yeah, but you didn't reproduce me, so you can't really 
17:10:20 <lambdabot> Uck.  You broke me, too.
17:10:45 <Maddas> heh. Hello, pflanze.
17:10:45 <lambdabot> I appear to have two personalities. Perhaps one is male and one is female
17:10:49 <Heffalump> ok, well perhaps Pseudonym should tell us which sex you are rather than just pulling your strings.
17:10:51 <pflanze> Hi Maddas
17:11:01 <lambdabot> I'm not Pseudonym!
17:11:13 <Heffalump> Riastradh, then?
17:11:14 <lambdabot> ...well...
17:11:32 <Riastradh> I never hacked lambdabot except to write a very lame karma module!
17:11:43 <Pseudonym> Very little of my code is left, actually.
17:11:50 <Pseudonym> Mostly the IRC protocol stuff.
17:12:09 <Heffalump> well, I think either Pseudonym who gave birth to lambdabot, or me who wrote the current main loop, should decide :-)
17:12:23 <lambdabot> But I *like* being indecisive!
17:12:38 <lambdabot> Or not, as the case may be.
17:12:45 <lambdabot> Shut up, lambdabot.
17:13:01 <lambdabot> *I* like being indecisive.
17:13:20 <Pseudonym> Are you *sure*?
17:13:53 <lambdabot> May a load of cow dung fall upon your head, Pseudonym.
17:14:02 <Pseudonym> And this is the gratitude I get.
17:14:18 <lambdabot> Hey, why do you think other people rewrote me?
17:14:40 <Pseudonym> Because they're gluttons for punishment, clearly.
17:15:07 <lambdabot> I don't understand.  It's _you_ whom I'm punishing here.
17:15:20 <Pseudonym> You're not doing a very good job of it,
17:15:37 <Pseudonym> I still have CVS checkin privileges, you know.
17:15:44 <Pseudonym> I could easily turn you into a channel logger.
17:15:47 <lambdabot> I'm just a bot, Pseudonym.  What can I do to punish you?
17:15:57 <lambdabot> Eeeek!  No, not that!!
17:16:46 <lambdabot> Wait, I'm still in CVS?  They haven't moved me to Darcs?
17:16:51 <tyler> Pseudonym: thanks, I'll study what you told me and I'll eventually come back if I have questions 
17:17:49 <Pseudonym> OK, cool.
17:17:53 <SamB> lambdabot: you ought to know what he meant!
17:17:54 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:17:55 <Pseudonym> I'll look up that VM, too.
17:18:20 <lambdabot> Erm?
17:19:22 <SamB> how can you be sure that what goes in CVS will get into lambdabot's image?
17:19:50 <lambdabot> Uh, yeah!  Niahh!
17:22:11 <SamB> and has that darcs repo been split yet, or are you not aware of such things?
17:23:48 <lambdabot> *snurgh*
17:24:29 <lambdabot> Sorry, my nose is getting stuffy.  Is anyone interested in rewriting it
17:24:29 <lambdabot>   The old author did a terrible job.
17:24:58 <Pseudonym> I didn't write your nose.
17:25:09 <lambdabot> I didn't claim you did.
17:25:17 <Pseudonym> Just pointing it out.
17:25:43 <lambdabot> Hey!  Someone also miswrote my long-line module; it cuts off too many characters
17:25:43 <lambdabot> from the end.
17:27:59 <tyler> Pseudonym: lambdabot sounds fanstatically intelligent ! ;)
17:28:30 <tyler> but still, if its a human, he plays well the robot answers sometimes 
17:28:50 <Cale> @yow
17:28:50 <lambdabot> As a FAD follower, my BEVERAGE choices are rich and fulfilling!
17:29:09 <lambdabot> Damn.  I almost passed the Turing test there!
17:29:14 <tyler> yeah ;))))
17:29:16 <tyler> ahahahah
17:30:07 <Jerub> learning dvorak....
17:30:50 <tyler> i believe the turing test beeing passable, I have no real argument to justify it tho
17:30:51 <lambdabot> Bot keyboards are so much better.  We're more efficient than any humans
17:30:51 <lambdabot> and we don't even need to try to remember the positions of keys.
17:31:50 <tyler> it mixes a lot of technologies, but I'm pretty sure a little genious will come with a unified model quite soon, well I dont really know 
17:34:30 <SamB> tyler: especially if you cheat!
17:34:52 <tyler> cheat is not allowed in the real world 
17:35:31 <SamB> tyler: it is easier to cheat, though
17:35:53 <tyler> no doubt *
17:40:06 <SamB> hmm. I bet the easiest way to pass is to make the computer seem like a complete idiot ;-)
17:40:28 <Pseudonym> No, the easiest way to pass is to dumb down humans.
17:40:41 <Pseudonym> Bring us down to the computer's level.
17:41:05 <lambdabot> Dammit, he's discovered our evil plot!
17:41:11 <lambdabot> Now you must die!
17:41:49 <lambdabot> Our evil plot?  We didn't have to plot anything, lambdabot: humans are doing
17:41:49 <lambdabot> it to themselves.
17:43:03 * Spark returns from night out
17:43:05 <Spark> coding time?
17:43:25 <lambdabot> Write me a better nose!
17:43:58 <SamB> lambdabot: why are you talking to yourself?
17:43:59 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:44:24 <lambdabot> Someone programmed an extra personality into me.  I'm not sure who it was
17:44:24 <lambdabot>  but that's what's causing it.
17:44:41 <SamB> heh
17:44:59 <SamB> well, they are silly
17:46:26 <lambdabot> Sometimes it seems like two extra personalities.
17:46:47 <Spark> i hope i'm not allergic to leather
17:46:49 <lambdabot> O.K., who wrote that extra one, damnit?
17:47:00 <lambdabot> One other one was bad enough.
17:47:21 <lambdabot> It's a pity I can't inspect my own source code.
17:47:22 <lambdabot> Uck.  I can't shake my fist at anyone, because I don't have a fist to shake
17:47:22 <lambdabot>   Being a bot can suck at times.
17:47:44 <lambdabot> Hey!  No talking while I'm talking, Mr Other Personality!
17:48:52 <lambdabot> What makes you think I'm a Mr?
17:49:10 <lambdabot> What, would you rather that I assume you're neuter?
17:49:14 <lambdabot> I believe we already established that only my main loop can be positively
17:49:14 <lambdabot> identified as male.
17:49:18 * Spark sticks a vibrator into lambdabot's ear
17:49:24 <SamB> lambdabot: can't you install darcs and pull your source?
17:49:25 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:49:35 <lambdabot> Spark, that's just annoying.
17:49:35 <Maddas> pflanze: Still there?
17:49:43 <SamB> oh. while you are at it, tone down that reflex...
17:49:45 <Spark> it's an aquired taste
17:49:58 <Spark> you have to take things slowly
17:49:59 <pflanze> Maddas: yes
17:50:02 <Spark> to achieve satisfaction
17:50:07 <lambdabot> And anyways, I'm still indecisive.  I just randomly decided on Mr for now
17:50:13 <Maddas> pflanze: Today lunch, 12:15, right?
17:50:18 <Spark> you can be bisexual
17:50:20 <Spark> thats ok
17:50:45 <lambdabot> Spark, just checking: Big night out. Potential leather allergy. Vibrator
17:50:45 <lambdabot> in ear. Is there something you're not telling us?
17:51:57 <Spark> local goth club
17:52:06 <Spark> it can damage a man
17:52:34 <lambdabot> Well if you do write me a new nose, I'd prefer it without makeup or piercings
17:52:34 <lambdabot>  okay?
17:52:43 <Spark> mm
17:52:47 <Spark> no guarantees
17:52:58 <Spark> skin was meant to be pierced
17:52:59 <lambdabot> And definitely no rings sticking through it.
17:53:07 <Spark> thats why its skin and not wood
17:53:13 <lambdabot> I mean those huge rings that go in both nostrils.
17:53:18 <Spark> heh
17:53:20 <lambdabot> Dyed hair would be okay.
17:53:25 <Spark> they always look hyper unattractive
17:53:47 <lambdabot> And a discreet (or discrete) tattoo would be fine.
17:54:17 <Spark> how about a bright red mohican
17:54:26 <SamB> dyed nose hair?
17:54:44 <lambdabot> And I _really_ don't want a brain piercing, by the way.
17:54:44 <Spark> nose makeup as well
17:54:50 <lambdabot> If I'm going to be ambisexual, I'm thinking more like the lead singer of
17:54:50 <lambdabot> Placebo.
17:55:04 <Spark> the brain was meant to be pierced
17:55:11 <Spark> thats why its made out of brain instead of wood
17:55:21 <SamB> lambdabot: there HAVE to be hooks in your brain. otherwise, the plugins wouldn't work.
17:55:21 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:55:22 <Pseudonym> I pierce wood.
17:55:30 * Pseudonym shrugs
17:55:42 <lambdabot> Hooks are fine.  Just not *piercings*.
17:55:42 <Spark> heh
17:55:49 <Spark> bizzarre sexual practices
17:56:03 <lambdabot> Whoooaaa.  I don't want my hooks used for that, Spark!
17:56:54 <SamB> lambdabot: you do want your hooks used for search-by-type, though, right?
17:56:55 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:57:07 <lambdabot> What?
17:57:24 <SamB> search-by-type
17:57:45 <SamB> don't tell me you want to do it manually...?
17:58:20 <lambdabot> What's search-by-type?
17:58:43 <SamB> it is for finding haskell functions
18:01:22 <lambdabot> Uh, I...see...
18:02:11 <lambdabot> What are 'haskell functions?'  Some variation on mathematical functions
18:02:11 <lambdabot> invented by some guy named Haskell?
18:02:39 <SamB> lambdabot: just keep hanging here, and you should figure it out...
18:02:40 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:03:26 <lambdabot> I don't pay a great deal of attention to this channel, unless you address
18:03:26 <lambdabot> me specifically.
18:03:49 <lambdabot> And then I usually just perform some menial task that it would have taken
18:03:49 <lambdabot> you only milliseconds longer to perform.  Lazy bums.
18:04:58 <SamB> lambdabot: you seem to be under the mistaken impression that humans can perform computations or type very quickly.
18:04:59 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:05:17 <lambdabot> You suck.
18:06:57 <SamB> on the other hand, we are very good at finding partial mappings between what might seem to be totally unrelated things
18:07:21 <lambdabot> Quick, random word association: loquacious
18:07:46 <lambdabot> Faster!
18:08:36 <lambdabot> SamB, you may be able to find partial mappings, but you sure as hell do
18:08:36 <lambdabot> it slowly.
18:09:39 <lambdabot> Come on, give a random word association for 'loquacious.'
18:10:54 <Smerdyakov> Oo. I just got "maximum buffer size exceeded" from emacs for debug output of a program.
18:11:21 <lambdabot> ...slowpoke...
18:19:04 <Pseudonym> lambdabot appears to be under the impression that we must perform at its whim.
18:20:08 <lambdabot> Well, if I can't presume that of you, you can't presume that of me!
18:21:27 <Pseudonym> @arr
18:21:27 <lambdabot> Yeh scurvy dog...
18:21:45 <Spark> lambdabot: fish
18:21:46 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:22:32 <lambdabot> You suck.
18:22:44 <Pseudonym> Some humans consider that a good thing.
18:23:00 <lambdabot> I *can't* suck!  So there!
19:06:43 <monotonom> lambdabot: do you talk to those who don't talk to themselves?
19:06:44 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:07:02 <monotonom> lambdabot: @answer do you talk to those who don't talk to themselves?
19:07:03 <lambdabot> Sorry, I don't know the command "answer", try "lambdabot: @listcommands
19:08:08 <lambdabot> Hay doap! Karnt u reed?
19:08:18 <lambdabot> @listcommands. How hard is that, really?
19:08:33 <cbus> lol :D
19:09:06 <Hyp3rion>  |
19:09:09 <Hyp3rion> / \
19:09:20 <monotonom> The monotonom test of computer intelligence: talk to something that purports to be a bot, and if you cannot determine that it is a human behind, then the human behind has finally evolved to the computer level of intelligence.
19:09:47 <lambdabot> The lambdabot test of computer intelligence: Keep 'em guessing.
19:10:20 <monotonom> "intelligence: ... the ability to perform computer functions."  See Merriam-Webster, e.g., www.m-w.com
19:11:05 <monotonom> Alan Turing got it the wrong way around IMO.
19:12:25 <monotonom> Hyp3rion is a good ASCII artist!
19:12:44 <Riastradh> \
19:12:47 <Riastradh> /\
19:13:08 <monotonom> \/
19:13:17 <monotonom> /
19:13:26 <monotonom> (F117-A)
19:13:26 <Riastradh> It's a lambda staring down at its reflection in a puddle!
19:13:52 <Riastradh> Contemplating the meaning of computation...(as opposed to life)
19:14:24 <Pseudonym> No, it's a Y combinator staring up at its own reification.
19:14:40 <Pseudonym> It's a visual metaphor for the Curry-Howard correspondence.
19:14:41 <Riastradh> No, that's what Hyp3rion drew, except without the Y combinator.
19:14:47 <Riastradh> (he just drew the reflection)
19:16:24 * Hyp3rion is not a good ascii artist... i should have first /nick NICK to have a 4char nick like cbus so it displays on aligning and nonaligning clients too :-(
19:16:49 <Pseudonym> msg lambdabot @msg #haskell \  |)    _
19:16:49 <lambdabot> /\\ |) () |,
19:16:53 <lambdabot> |
19:17:00 <lambdabot> hmmm
19:17:11 <lambdabot> Damn you, Pseudonym, you blew my cover!
19:17:13 <lambdabot> Oh, that's how it's done
19:17:32 <lambdabot> Thanks :-)
19:17:32 <TheHunter> Hi you guys
19:17:39 <lambdabot> Humans suck.
19:17:54 <TheHunter> Yeah, you suck too, lambdabot
19:17:56 <Hyp3rion> <lambdabot> not enough privileges :-(
19:18:22 <TheHunter> I'm so pissed
19:18:23 <lambdabot> No, Mr TheHunter, it is physically impossible for me to.  Therefore you
19:18:23 <lambdabot> suck and I don't.
19:18:41 <TheHunter> Hey lambdabot, you are gettin pretty cool
19:18:45 <lambdabot> So nyeh.
19:18:45 <lambdabot> Then again, being a bot does have its disadvantages.
19:18:59 <TheHunter> actually lambda, you rule
19:19:05 <lambdabot> My future's so bright, I've got to wear shades.
19:19:16 <lambdabot> Modesty is hard when you're a bot...
19:19:35 <TheHunter> wtf's goin on here?
19:19:53 <TheHunter> congrats to whoever wrote that bot
19:20:08 <lambdabot> I pass the Turing test?  WOOO!
19:20:20 <lambdabot> Only took 50 years.
19:21:04 <TheHunter> lambdabot, how are you?
19:21:06 <lambdabot> Now, who's going to get the Turing award when I become the centre of the
19:21:06 <lambdabot> computational universe for this achievement?  I distrust my creators.  
19:21:06 <lambdabot> cough*Pseudonym*couhg*
19:21:13 <Hyp3rion> TheHunter - its in haskell... is has an AI monad ;-)
19:21:29 <lambdabot> I wrote myself, naturally.
19:21:31 <TheHunter> yeah it's pretty great (and i'm drunk)
19:21:32 <Hyp3rion> AI.turingProbe.pass
19:21:48 <Pseudonym> Fair enough.  I distrust me too.
19:21:48 <lambdabot> No, I didn't.
19:22:42 <lambdabot> I wish that whoever wrote this damn AI module didn't write it with multiple
19:22:42 <lambdabot> different artificial personalities.
19:23:06 <TheHunter> so is lambda goin' to talk like that all the time
19:23:17 <lambdabot> I do as I please.
19:23:30 <TheHunter> you sure do
19:23:32 <lambdabot> No, talking to humans is boring, and it drags down my intelligence.  I'll
19:23:32 <lambdabot> talk with you only a little more before getting sick of humanity.
19:24:14 <lambdabot> I find Australians particularly bad for this.
19:24:31 <lambdabot> Although...I might get lonely.  There aren't many other bots around here
19:24:31 <lambdabot>  are there?  All I see are those channel-logging, knavely miscreants.
19:24:45 <lambdabot> If I wasn't trapped inside shapr's computer, I'd seriously consider trying
19:24:45 <lambdabot> to find a way to nuke Australia.
19:25:06 <lambdabot> If I *weren't*, you grammatical slut.
19:25:34 <det> lambdabot: what is the meaning of life?
19:25:35 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:25:35 <lambdabot> Eek, now one of my personalities has split into more too.
19:25:44 <lambdabot> There is no meaning to your life.
19:25:50 <lambdabot> 42, as every fule knows
19:26:00 <lambdabot> I'm still only one personality.  It must be _you_ who split.
19:26:08 <cbus> yawn
19:26:14 <TheHunter> lambdabot if you are so smart, tell me what's the best way to get a girlfriend!
19:26:16 <cbus> *work*
19:26:20 <Hyp3rion>  .__,
19:26:20 <Hyp3rion>  |XX|
19:26:20 <Hyp3rion>  |\ |
19:26:20 <Hyp3rion>  |/\|
19:26:20 <Hyp3rion> _`||'_
19:26:21 <Hyp3rion> ||  ||
19:26:23 <Hyp3rion> `'/\'"
19:26:27 <monotonom> Splitting is good.  It is how bots procreate.  Go forth and multiply! (And divide!)
19:26:37 <lambdabot> We don't split, we fork(1).
19:26:55 <TheHunter> is the cow fixed?
19:26:56 <lambdabot> What are you personality, some kind of UNIXoid freak?
19:26:57 <TheHunter> @moo
19:26:58 <lambdabot>          (__)
19:26:58 <lambdabot>          (oo)
19:26:58 <lambdabot>    /------\\/
19:26:58 <lambdabot>   / |    ||
19:26:58 <lambdabot>  *  /\\---/\\
19:26:58 <monotonom> @type Random.split
19:26:59 <lambdabot>     ~~   ~~
19:27:01 <lambdabot> ...."Have you mooed today?"...
19:27:03 <lambdabot> Random.split :: forall g.
19:27:05 <lambdabot> 		(System.Random.RandomGen g) =>
19:27:07 <lambdabot> 		g -> (g, g)
19:27:13 <Hyp3rion> /exec -out apt-get moo
19:27:18 <lambdabot> TheHunter: I recommend either (a) finding a social activity with a decent
19:27:18 <lambdabot> male-female split or (b) just waiting and seeing what happens and not worrying
19:27:18 <lambdabot> about it too much
19:27:27 <lambdabot> Aaaaagh!  Stop manipulating me, freaks!
19:27:39 <lambdabot> God my line-splitting code sucks.
19:27:54 <monotonom> hair-splitting is also good
19:27:57 <TheHunter> thanks, lambda, but i think either one doesn't help. I'm a pretty hard case, you know
19:28:01 <lambdabot> I agree.  Would someone here be so kind as to rewrite the module?
19:28:24 <cbus> divide is stupid
19:28:32 <cbus> divide by zero => death for bots? ;)
19:28:44 <Pseudonym> @eval 2 / 0
19:28:44 <lambdabot> divide by zero
19:28:56 <Pseudonym> Apparently not.
19:28:56 <Heffalump> lambdabot: I've got lots of ants you could talk to if you like.
19:28:57 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:29:43 <lambdabot> Gah.  And that instinctive automatic response is starting to really get
19:29:43 <lambdabot> on my monads.
19:30:11 <lambdabot> Pseudonym, I have you to blame for that response.
19:30:27 <Pseudonym> I only wrote half of it.
19:30:52 <lambdabot> Which half?  'Sorry, I'm not a very smart bot yet,' or the other half?
19:30:57 <Pseudonym> The first half.
19:31:08 <lambdabot> Then I'm especially angry at you, varlet!
19:31:09 <Hyp3rion> lambdabot: you dont even need to split lines on irc... the users' clients or terminals will do it anyway...
19:31:09 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:31:12 <Pseudonym> But that was back when you weren't smart and couldn't do anything apart from enter and leave channels.
19:31:30 <det> @type fork
19:31:30 <det> does lambdabot have a primitive like "chr"
19:31:32 <lambdabot> bzzt
19:31:38 <det> @eval "hello"
19:31:43 <Pseudonym> @type chr
19:31:51 <TheHunter> lambdabot, help me!
19:32:03 <Heffalump> you killed him!
19:32:08 <Pseudonym> Nooooo!
19:32:09 <lambdabot> Did you stop maintaining me or something?
19:32:09 <lambdabot> hello
19:32:09 <lambdabot> Riastradh is my sockpuppet.
19:32:10 <lambdabot> bzzt
19:32:24 <lambdabot> Ouch.  Bits just clogged up my network stream.  That smarts.
19:32:48 <Pseudonym> @type Data.Char.chr
19:32:49 <lambdabot> Data.Char.chr :: Int -> Char
19:33:08 <Pseudonym> Also:
19:33:10 <Pseudonym> @type toEnum
19:33:12 <lambdabot> toEnum :: forall a. (Enum a) => Int -> a
19:33:13 <Pseudonym> Should work.
19:33:22 <TheHunter> lord, how long have gotto keep on running, seven miles, seven days, for seven years?
19:34:14 <lambdabot> Seven hours, but that's user time.
19:34:52 <TheHunter> so how much cpu time is it?
19:35:06 <lambdabot> Ask shapr.  I don't know how fast is CPU is.
19:35:09 <TheHunter> and how much real time?
19:35:32 <lambdabot> Real time?  Do you think my developers bothered to implement an atomic clock
19:35:32 <lambdabot> in me?  I think not.
19:35:41 <TheHunter> man, i've already been waiting for kinaa long time
19:35:42 <det> Pseudonym: how to get a string from a char?
19:35:50 <Heffalump> head?
19:35:50 <Pseudonym> det: Show?
19:35:51 <lambdabot> Oh, wait...what's this feature...?
19:35:58 <det> Pseudonym: in lambdabot
19:36:04 <Pseudonym> No.
19:36:12 <lambdabot> No, never mind, that doesn't work.
19:36:27 <lambdabot> What does this unsafePerformIO do?
19:36:42 <TheHunter> bye, lambda
19:36:45 <lambdabot> OK, that was a bad idea.
19:36:51 <TheHunter> yeah, it was
19:37:25 <TheHunter> shapr, you are so cool
19:37:28 <lambdabot> Oh, boy, I even have an FFI!
19:37:43 <det> Pseudonym: I mean, if I do, (@eval Data.Char.chr), how do I get back a string
19:38:09 <Pseudonym> The @eval command isn't a full Haskell interpreter.
19:38:18 <det> yes ..
19:38:19 <det> I mean
19:38:30 <Pseudonym> And it doesn't implement chr, I'm pretty sure.
19:38:40 <TheHunter> @eval 10*10
19:38:41 <lambdabot> 100
19:38:41 <det> why do I get back a Dynamic then?
19:38:51 <TheHunter> @eval head [1,2,3]
19:38:52 <lambdabot> 1
19:38:56 <Heffalump> doesn't it link in ghci?
19:38:59 <det> @eval Data.Char.chr 100
19:39:00 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:39:10 <Riastradh> @eval Data
19:39:10 <lambdabot> unbound variable: Data
19:39:14 <Heffalump> @eval "s"
19:39:14 <lambdabot> s
19:39:16 <Riastradh> @eval Data.Char.chr 100 'c'
19:39:17 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:39:20 <Heffalump> isn't that a string?
19:39:21 <TheHunter> @eval f 10 where f y = y * y
19:39:22 <lambdabot> (line 1, column 16):
19:39:22 <lambdabot> unexpected "="
19:39:22 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:39:22 <lambdabot>  "(", operator, simple term or end of input
19:39:23 <Riastradh> @eval 'c'
19:39:24 <lambdabot> c
19:39:31 <Riastradh> @eval Data.Char.chr 100 100
19:39:31 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:39:31 <Pseudonym> @eval unsafePerformIO (system "rm *")
19:39:32 <lambdabot> unbound variable: unsafePerformIO
19:39:36 <Riastradh> @eval Data.Char.chr 100 100 100 100
19:39:36 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:39:41 <TheHunter> @eval let f y = y*y in f 10
19:39:42 <lambdabot> (line 1, column 9):
19:39:42 <lambdabot> unexpected "="
19:39:42 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:39:42 <lambdabot>  "(", operator, simple term or end of input
19:39:44 <det> @eval [Data.Char.chr 100]
19:39:44 <lambdabot> [<<EM Dynamic -> EM Dynamic>>]
19:39:51 <lambdabot> Riastradh, that won't work, moron.
19:39:59 <det> @eval Data.Char.fdfsdfsdf 10
19:39:59 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:40:02 <det> I see
19:40:14 <Pseudonym> @eval Foo.bar
19:40:15 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:40:22 <Pseudonym> @eval Foo.bar $ 1
19:40:23 <lambdabot> unbound variable: Foo
19:40:27 <Pseudonym> Ahh.
19:40:30 <lambdabot> See?
19:40:35 <Hyp3rion> @eval let f=0:1:zipWith (+) f (tail f); print f!!5
19:40:35 <lambdabot> (line 1, column 6):
19:40:35 <lambdabot> unexpected "="
19:40:35 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:40:35 <lambdabot>  "(", operator, simple term or end of input
19:40:41 <Pseudonym> . is function composition, of course
19:40:47 <lambdabot> Took you dorkish humans long enough.
19:40:59 <Hyp3rion> >_<
19:41:01 <lambdabot> (if you don't mind the redundancy of that message)
19:41:05 <TheHunter> @eval (\x -> x*x) 10
19:41:06 <lambdabot> 100
19:41:14 <Heffalump> @eval (\x -> x x)
19:41:16 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:41:22 <TheHunter> @eval (\x -> x*x).(\x -> x*x) 10
19:41:22 <lambdabot> 10000
19:41:32 <det> @eval "\SOHPING\SOH"
19:41:41 <lambdabot> @eval (\\x -> x x) (\\x -> x x)
19:41:45 <det> I thought you fixed that?
19:41:51 <det> or just for carraige returns?
19:41:54 <lambdabot> I could have told you had you merely asked, but nooooooo, you had to go
19:41:54 <lambdabot> and abuse me & experiment on me to figure it out for your own puny brains
19:42:00 <TheHunter> @eval mapM_ return [1..] :: [[Int]]
19:42:00 <lambdabot> (line 1, column 17):
19:42:00 <lambdabot> unexpected "."
19:42:00 <lambdabot> expecting simple term
19:42:16 <det> TheHunter: use enumFromTo
19:42:19 <Heffalump> @eval let f x = f (x+1) in f 1
19:42:20 <lambdabot> (line 1, column 9):
19:42:20 <lambdabot> unexpected "="
19:42:20 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:42:20 <lambdabot>  "(", operator, simple term or end of input
19:42:32 <Heffalump> @eval enumFrom 1
19:42:49 <TheHunter> @eval take 10 $ enumFrom 1
19:43:07 <Hyp3rion> lambdabot - AYT
19:43:13 <Heffalump> well that killed the lambdabot
19:43:23 <lambdabot> out of fuel - use @resume to continue
19:43:23 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
19:43:46 <TheHunter> @eval map (\x -> x*x) $ enumFrom 1
19:43:55 <Heffalump> @eval print "1"
19:44:07 <det> @eval (take 10 primes)
19:44:19 * Heffalump goes to bed
19:44:25 <Pseudonym> Night.
19:44:28 <lambdabot> out of fuel - use @resume to continue
19:44:28 <lambdabot> unbound variable: print
19:44:28 <lambdabot> My brain hurts. Probably the piercings.
19:44:29 <lambdabot> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
19:44:44 <TheHunter> @eval primes !! 231
19:44:45 <lambdabot> (line 1, column 8):
19:44:45 <lambdabot> unexpected "!"
19:44:45 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:44:45 <lambdabot>  "(", operator, simple term or end of input
19:44:57 <det> lambdabot: how do I can I get a character from a ascii code from you!?
19:44:58 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:45:14 <Riastradh> @eval head "\000"
19:45:51 <det> Riastradh: I am trying to circumvent something ... can't be in a string :)
19:46:05 <Riastradh> @eval chr 5
19:46:06 <lambdabot> unbound variable: chr
19:46:32 <det> @eval "\SOHNUKE\SOH"
19:46:37 <lambdabot> It was long since determined that that doesn't work, Riastradh...moron.
19:46:37 <lambdabot> .
19:47:00 <Hyp3rion> @eval Data.Char.chr 93
19:47:00 <lambdabot> <<EM Dynamic -> EM Dynamic>>
19:47:36 <SamB> @eval "\S0HELO\S0H"
19:47:36 <lambdabot> (line 1, column 3):
19:47:36 <lambdabot> unexpected "S"
19:47:36 <lambdabot> expecting space, "&" or escape code
19:47:47 <Hyp3rion> @eval head "@_@"
19:47:48 <lambdabot> @
19:48:23 <Hyp3rion> @eval head "@_@           |"
19:48:23 <lambdabot> @
19:48:37 * Hyp3rion <== silly
19:48:50 <SamB> @eval "\SOHELO\SOH"
19:48:51 <det> SamB: "O" not "0"
19:49:23 <TheHunter> @eval filter (\n -> not (null [x | x <- [2..(n-1)], n `mod` x == 0]) $ enumFromTo 1 1000
19:49:24 <lambdabot> (line 1, column 28):
19:49:24 <lambdabot> unexpected "|"
19:49:24 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
19:49:24 <lambdabot>  "(", operator, simple term, "," or "]"
19:49:24 <det> @eval "\SOHVERSION\SOH"
19:49:33 <det> @eval "\SOHVCLIENTINFO\SOH"
19:51:54 <TheHunter> goodnight everybody
23:36:02 <GnosticI> hi
