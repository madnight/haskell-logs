02:45:28 <Frippster> hello
02:45:40 <Frippster> could anybody help me with a small haskell problem
02:46:23 <Lunar^> Frippster: Most people here are screen user, just ask
02:46:58 <Frippster> I don't know who to ask :P
02:47:08 <Lunar^> Just ask here
02:47:23 <earthy> stel je vraag, slimling. :)
02:47:23 <Frippster> I have made a simple function that takes 2 lists and performs a "minus" on them
02:47:34 <bringert> yourfun :: Eq a => [a] -> [a] -> [a]
02:47:35 <bringert> :)
02:47:40 <Frippster> yeah :D
02:47:41 <Frippster> ok
02:47:42 <Frippster> thanks
02:47:52 <cbus> like filter? ;)
02:47:58 * bringert saw the question in #haskelldb
02:48:08 <bringert> more like \\, I think
02:48:28 <earthy> yourfun = map (\x y -> x - y) $ zip     ?
02:48:44 <earthy> !autolart
02:48:54 <shapr> earthy: well, you have ops
02:49:06 <bringert> I think he is talking about set minus
02:49:07 <Frippster> yeah well
02:49:10 <Frippster> the function works
02:49:15 <bringert> @type List.(//)
02:49:17 <lambdabot> bzzt
02:49:21 <Frippster> but I used an == operator
02:49:22 <shapr> @index //
02:49:22 <bringert> @type (//)
02:49:23 <lambdabot> Data.Array.Base,Data.Array.Diff,Data.Array.IArray,Data.Array.Unboxed,Data
02:49:23 <lambdabot> Array,GHC.Arr,Array
02:49:23 <lambdabot> bzzt
02:49:29 <bringert> @type List.(\\)
02:49:30 <lambdabot> bzzt
02:49:33 <bringert> is what I meant
02:49:34 <shapr> @index \\
02:49:34 <lambdabot> Data.List,List
02:49:38 <Frippster> so I needed to put "Eq a" in front of the typedef
02:49:40 <bringert> @type List.\\
02:49:42 <lambdabot> bzzt
02:49:44 <earthy> @type Data.List.(\\)
02:49:45 <shapr> @type (List.\\)
02:49:45 <Frippster> it works now
02:49:45 <lambdabot> bzzt
02:49:46 <lambdabot> (List.\\\\) :: forall a. (Eq a) => [a] -> [a] -> [a]
02:49:58 <Frippster> thanks :D
02:50:01 <earthy> ah, right. ;)
02:50:01 <shapr> man, that explicit extra backslash sucks
02:50:11 <shapr> someone fix that!
02:50:15 <earthy> you wanted set subtraction.
02:50:17 * shapr points to the guilty party
02:50:46 * shapr *is* the guilty party
02:53:08 <andersca> @arr
02:53:09 <lambdabot> Prelude.(!!): index too large
02:53:12 <andersca> @arr
02:53:13 <lambdabot> Shiver me timbers!
02:57:03 <earthy> Avast, ye landlubbers!
03:03:13 <earthy> T-6 hours for ICFP Contest to start...
03:25:41 <shapr> is there a deb to get postfix do SPF checking?
03:28:41 <shapr> hiya maihem 
03:40:54 <maihem> howdy
03:41:03 <shapr> wassup?
03:41:10 <maihem> well, just applied for another job
03:41:14 <maihem> w00t!
03:41:36 <shapr> cool, what sort of job?
03:41:57 <maihem> Senior ICT Technician at an upper school
03:42:17 <maihem> Gonna be mostly tech support, but I need the production experience
03:43:08 <maihem> I've wasted too much time since graduating simply trying to earn money that I've ignored my career.
03:43:41 <maihem> hows things in Sweden?
03:43:56 <shapr> sunny, getting ready for flying south tomorrow
03:44:06 <shapr> at the moment I'm playing with TMDA
03:44:10 <maihem> TMDA?
03:44:34 <shapr> http://tmda.sourceforge.net/ 
03:45:06 <shapr> I wish I had an implementation of im2000, I'd switch to that instead
03:45:20 <shapr> I think that would be a great killer app for Haskell
03:49:08 <shapr> an irate client in Haskell would be spiffy too
03:49:41 <maihem> I'm still playing around with GUI stuff, I need more time to practice :(
03:49:53 <shapr> oh I'm just spouting ideas
03:54:10 <maihem> I'm doing my GUI thing as a state machine, using machine transformers to compose simpler state machines. runGUI takes a list of triggers and outputs a list of events, I really want to wrap HGL around those two lists somehow
03:55:33 <Iter> evening shapr.
03:55:38 <shapr> hiya Iter 
03:56:56 <Iter> Had a guy at work find a log of our conversation about kowari a few weeks back :)
03:57:14 <Iter> google's rather comprehensive :)
03:57:56 <shapr> is that good or bad?
03:58:03 <Iter> amusing.
03:58:25 <shapr> anything mention here on #haskell is logged, and tends to show up on google quickly
03:58:44 <Lukhas> we also sell the logs to various employers
03:58:49 <Iter> it's an open-source product, so it's not like I'm spilling trade-secrets or anything.
03:58:51 <Iter> lol.
03:59:20 <Iter> yeah, all irc is logged.  Was just amused to see it turn up on google is all.
03:59:55 <Lukhas> if your terms are too specific, you also end in finding a guy asking the same question  in #haskell
04:00:20 <shapr> I get a surprising number of http hits with referrers from the irc logs
04:00:38 <shapr> or google cached copies of the irc logs
04:02:10 <arjanb> in one logged channel we got more offtopic questions about things we happened to mention once
05:50:11 * shapr casts an arrow at Lunar^ 
05:58:41 <shapr> @yow !
05:58:42 <lambdabot> If elected, Zippy pledges to each and every American
05:58:42 <lambdabot>  a 55-year-old houseboy...
05:58:46 <shapr> @fortune
05:58:47 <lambdabot> When you are at Rome live in the Roman style; when you are elsewhere live
05:58:47 <lambdabot> as they live elsewhere.
05:58:47 <lambdabot> 		-- St. Ambrose
06:18:28 <phubuh> hey hey
06:18:30 <shapr> hej hej
06:18:41 <shapr> kan du åka enjuhling?
06:18:42 <phubuh> hej shapr
06:18:51 <shapr> whoops, wrong channel
06:18:56 <phubuh> om jag håller i något :)
06:19:46 <shapr> what's "hold in" ?
06:19:53 <shapr> want to?
06:20:02 <phubuh> hold on to
06:20:07 <shapr> hah
06:20:28 <shapr> that's a nice way to put it.
07:14:57 <SyntaxNinja> hi all
07:15:12 <bringert> hi
07:15:18 <shapr> y0
07:16:29 <bringert> SyntaxNinja: any LIP TODOs for EuroHaskell?
07:21:36 <SyntaxNinja> bringert: what do you mean?
07:22:04 <shapr> Spark: you coming to EuroHaskell?
07:22:50 <bringert> are there any LIP tasks that we could do as sprints at EuroHaskell?
07:24:02 <SyntaxNinja> bringert: yeah, sure. when is it again?
07:24:17 <shapr> @eurohaskell
07:24:18 <lambdabot> less talks, more code!
07:24:18 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
07:24:18 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
07:24:24 * shapr bounces happily
07:25:34 <shapr> SyntaxNinja: oh, bernie is interested in getting buddha into HE
07:26:05 <shapr> though I dunno how to trace keysigns to him
07:26:30 <SyntaxNinja> bringert: so hm... I could put together something; a task list.
07:26:46 <SyntaxNinja> someone could probably hack on the HUGS or NHC stuff, using the GHC stuff as boilerplate.
07:31:34 <shapr> SyntaxNinja: iirc, that's the requirement? get a signed key that connects to you?
07:32:04 <SyntaxNinja> shapr: yeah; or some other good reason to trust, I guess.
07:32:14 <SyntaxNinja> where's he located again?
07:33:49 <SyntaxNinja> shapr: problem is that access to HE means r00t on any machine that uses it, basically.
07:34:23 <bringert> SyntaxNinja: sounds good
07:35:02 <bringert> if you get some sort of task description together, just post it here or add it to the EuroHaskell wiki page
07:35:13 <bringert> or post a link anyway
07:35:14 <shapr> SyntaxNinja: uni of melbourne
07:35:47 <SyntaxNinja> bringert: one thing that could be done, which isn't directly (or only) LIP related is to make a haskell data-file format and parser
07:35:51 <shapr> his website: http://www.cs.mu.oz.au/~bjpop/ - buddha's website: http://www.cs.mu.oz.au/~bjpop/buddha/
07:36:00 <shapr> data-file ?
07:36:04 <SyntaxNinja> something that parses files that look like GHC's package.conf
07:36:09 <shapr> oh
07:36:24 <SyntaxNinja> but does it in a more genearal way, a kind of XML in haskell, but simpler :)
07:39:02 <Lunar^> buddha rocks
07:41:18 <earthy> syntaxninja: you mean something like Perl's Data::Dumper, but then with a reader?
07:41:55 <SyntaxNinja> earthy: don't know perl's data dumber ;)
07:42:16 <earthy> Data::Dumper - stringified perl data structures, suitable
07:42:16 <earthy>      for both printing and "eval"
07:42:30 <earthy> bah, nah. that's show and read
07:42:37 <ozone> SyntaxNinja: what are you after?
07:43:27 <SyntaxNinja> ozone: basically, people like data files where, rather than using XML, they use something that looks like Haskell data types.
07:43:44 <SyntaxNinja> but in reality, read & show don't offer enough; for instance, we want to be able to ignore fields and such
07:44:04 <ozone> why not just use XML?
07:44:10 <SyntaxNinja> ozone: because people hate xml
07:44:36 <earthy> and rightly so
07:44:48 <earthy> man, does xml turn ugly *fast*
07:45:09 <ozone> so you propose yet another standard which does exactly the same thing?
07:45:18 <ozone> (not accusing, merely asking)
07:45:19 <SyntaxNinja> ozone: much more lightweight.
07:45:42 <ozone> sure, at the expense of incompatibility with all the XML tools around
07:45:50 <SyntaxNinja> ozone: we already have a syntax and some parsers.
07:46:05 <SyntaxNinja> ozone: it's either that, or people make up their own shit. I'm not going to talk libraries@ into using XML.
07:46:26 <ozone> it's the "make up their own shit" bit that i'm worried about. :)
07:46:36 <SyntaxNinja> you mean what I'm doing?
07:46:40 * earthy grins
07:46:46 <ozone> SyntaxNinja: yeah
07:46:52 <ozone> this is NIH syndrome
07:46:59 <earthy> why not use the .INI format? :P
07:47:19 <earthy> or even simple keyword = value  ?
07:47:24 <SyntaxNinja> well, at least we'd have somewhat of a standard; a way of doing escapes, etc.
07:47:32 <ozone> i think XML is a nice match for haskell: at least you can easily map it to haskell data structures
07:47:41 <SyntaxNinja> ozone: yeah, it might be NIH
07:47:47 <ozone> not sure what you mean by 'escapes'
07:48:01 <shapr> I think whoever writes some code and sticks it into the LIP project will get their format in.
07:48:10 <SyntaxNinja> well, if you're making up a syntax for a data file, you have to have some way to escape quotes and what-have-you.
07:48:19 <SyntaxNinja> and haskell already has a syntax for that.
07:48:30 <SyntaxNinja> and a syntax for lists
07:48:42 <SyntaxNinja> name=value doesn't give you arbitrary data structures.
07:49:06 <earthy> it doesn't?
07:49:12 <earthy> then how does memory work?
07:49:52 <SyntaxNinja> OK, well, it's not pretty at least :)
07:50:29 <ozone> SyntaxNinja: escape quotes?  of course XML does that for you
07:50:50 <ozone> it'd be kinda crap if you couldn't write "<foo>!" into a file :)
07:51:10 <shapr> I'm a big fan of argument by code.
07:51:11 <SyntaxNinja> what I'm suggesting is to get the most out of Haskell developer's instincts; if they refuse to use XML for mostly aesthetic reasons, it would be nice to have a standard alternative
07:51:26 <SyntaxNinja> ozone: I wasn't talking about XML, I was talking about stuff you make up yourself.
07:51:41 <ozone> SyntaxNinja: well, if you absolutely _must_ refuse to use XML, check out NeXT's property list format, which is used a lot on mac os x
07:51:51 <ozone> same representation power, but looks nicer
07:51:55 <SyntaxNinja> ozone: if you followed libraries@ some months ago, you'll see me arguing for XML and everyone hating it and not giving me any good reasons.
07:52:04 <ozone> SyntaxNinja: ah.
07:52:13 <SyntaxNinja> ozone: I will look at that.
07:52:13 <ozone> no, i haven't been following -- only joined libraries@ a few weeks ago
07:52:24 <shapr> libraries@ is fun
07:52:35 <shapr> if you like the occasional vicious infighting ;-)
07:52:52 <SyntaxNinja> (not everyone hated XML, and finally simonMar called "bike shed" and the conversation ended, but it was clear to me that XML would be a barrier to acceptance)
07:53:05 <ozone> sounds like a case of head-up-arses to me
07:53:15 <shapr> what about using GHC package.conf format, and an equivalent XML?
07:53:27 <shapr> hej spenatmannen, wassssup? you coming to EuroHaskell?
07:53:46 <ozone> SyntaxNinja: well, for what it's worth, i think that once you start dealing with i18n, you should have a _very_ good reason not to use XML
07:54:10 <ozone> because if you do i18n yourself, you are bound to get it wrong
07:54:16 <Lunar^> ozone: ?
07:54:20 <SyntaxNinja> ozone: oh, really? I thought that was a reason to us XML.
07:54:22 <spenatmannen> maybe... if i'm not doing anything else.. 
07:54:24 <SyntaxNinja> shows what I know.
07:54:29 <ozone> SyntaxNinja: not
07:54:43 <ozone> (i'm saying that XML addresses the i18n issue nicely :)
07:54:45 <SyntaxNinja> oh, I parsed that the other way
07:54:51 <SyntaxNinja> yeah, I mentioned that, but no one cared.
07:54:53 <SyntaxNinja> *sigh*
07:55:11 <shapr> SyntaxNinja: ok, just use XML and ask for patches for alternate formats?
07:55:23 <ozone> oh well.  sorry you have to bear the brunt of stupidity, isaac :)
07:55:27 <shapr> the IETF method... rough consensus, running code
07:55:42 * shapr sends e-beer to SyntaxNinja for his work on that most religious of issues
07:56:39 <ozone> i'm just a bit puzzled since tools like HaXML are already around
07:56:52 <shapr> does HaXML work with nhc98 and hugs?
07:56:54 <ozone> anyhoo, i'll be quiet now, it's obvious i'm preaching to the converted
07:57:10 <ozone> and thus only making the converted more angry :)
07:57:12 <shapr> I think that was one complaint, HaXML doesn't work with hbc or something
07:57:26 <SyntaxNinja> ozone: yeah... the thing about this project is that it first and foremost must be accepted. that's why I think "rough consensus and working code" is not a good argument in this case... people have to like it and use it.
07:57:29 <ozone> shapr: that'd be a relevant argument if HBC were still maintained
07:57:43 <SyntaxNinja> I think that the HaXmL compatibility is not a big issue.
07:57:47 <shapr> oh
07:57:53 <SyntaxNinja> ozone: BTW, my 2nd prototype used XML.
07:58:44 <ozone> SyntaxNinja: why must it be accepted by concensus?  all you have to do is get an infrastructure agreed upon by a few people, get a couple of packages together, and let it roll from there
07:59:06 <ozone> if you're asking all of libraries@ for input, you won't get off the ground for years
07:59:15 <ozone> (design by committee yadda yadda yadda)
07:59:48 <SyntaxNinja> yeah, but at least representatives from the main implementations must be on-board.
08:00:04 <ozone> how many people does that involve?
08:00:49 <SyntaxNinja> me + about 4 others
08:00:55 <SyntaxNinja> (me is not a compiler author of course)
08:01:20 <ozone> 5 people shouldn't be too bad.  just make sure to heed and ignore everyone else (including me). :}
08:01:45 <SyntaxNinja> ozone: thanks for the advice :)
08:02:44 <ozone> SyntaxNinja: btw, here's a page on the old next-style property lists:
08:02:44 <ozone> http://developer.apple.com/documentation/Cocoa/Conceptual/PropertyLists/Concepts/OldStylePListsConcept.html
08:02:58 <ozone> looks quite similar to Haskell record syntax, as you can see
08:03:24 <ozone> and here's a fairly nice page on XML alternatives, which we used for some projects before coming to the design that going with anything other than XML was silly:
08:03:27 <ozone> http://www.pault.com/pault/pxml/xmlalternatives.html
08:04:00 <ozone> anyhoo, have to get back to work on this paper.  sorry to inject some annoyance into your day :)
08:04:09 <shapr> oh, use ATerms!
08:04:15 <SyntaxNinja> thanks.  feel free to chime in on libraries@. there was an anti-xml comment there just the other day :)
08:04:15 <shapr> that would be bizarre and nifty
08:04:25 <SyntaxNinja> ozone: nah, this was a useful conversation :)
08:04:28 <shapr> already has a Haskell parser
08:04:46 <ozone> shapr: there's this other thing called XML which has a haskell parser, too ;)
08:04:55 <ozone> must ... restrain ... self ...
08:05:01 * shapr grins evilly
08:05:45 <shapr> oh we could use ASN.1
08:05:55 <shapr> that's compact, efficient, platform independent...
08:06:48 <ozone> shapr: i think lambda calculus written in XML is a better idea
08:07:09 <shapr> I agree with you.
08:07:16 <Grind> hello
08:07:19 <Grind> hello shapr
08:07:24 <shapr> greetings Grind 
08:07:44 <shapr> how's code?
08:07:53 <Grind> playing with monad transformers
08:08:04 <Grind> StateT and Maybe
08:08:09 <Grind> it's going fine
08:08:42 <Grind> I just have some philosophical doubts about State monads... :-/
08:08:54 <shapr> like what?
08:09:08 <Grind> right now I'm not using a state monad so I just pass an evironment around
08:09:25 <Grind> some functions just "read from" it and return other stuff 
08:09:33 <Grind> so they just take it as an argument
08:09:49 <shapr> ReaderT ?
08:09:50 <Grind> other "read from it" and "change it"
08:10:01 <Grind> close...
08:10:11 <shapr> lambdabot uses both ReaderT and StateT, since part of the state is read-only
08:10:23 <Grind> can I easily switch between ReaderT and StateT?
08:10:27 <shapr> I don't know
08:10:36 <Grind> that's the problem...
08:11:06 <Grind> If I'm in a State/StateT can I easily use Reader/ReaderT functions?
08:11:21 <Grind> because if I don't feel safe
08:11:34 * shapr doesn't know that either
08:11:45 <Grind> I might be accidently changing state in some "read only" function
08:12:00 <Grind> and why am I using haskell after all ;)
08:15:42 <SyntaxNinja> Grind: are you trying to use the same type to both allow yourself and prevent yoruself from writing to the staet?
08:16:07 <Grind> SyntaxNinja: not quite, I know I cannot do that
08:16:36 <Grind> SyntaxNinja: I'm using a State Monad because I need to change state
08:16:58 <Grind> SyntaxNinja: but some of the auxiliary functions I use are not supposed to change state, just read it
08:17:31 <Grind> SyntaxNinja: If I use a State Monad in them, then I am allowing changes 
08:17:51 <Grind> SyntaxNinja: but how can I avoid it...
08:18:08 <SyntaxNinja> and in these cases, it's not correct to extract the state and pass it as params to the aux functions?
08:18:08 <Grind> SyntaxNinja: (without messing up the code to much...)
08:18:45 <Grind> well in fact right now the code is being passed as parameters everywhere
08:19:09 <Grind> the 'stable' code does not uses State Monad yet
08:19:22 <Grind> my goal was to get rid of that now
08:19:46 <Grind> because passing the evironment around doesn't look that good
08:19:48 <shapr> you could pass the state to pure functions
08:19:52 <SyntaxNinja> right
08:19:54 <Grind> it ends up being kind of messy
08:20:26 <Grind> shapr: yes shapr but then I'd have to pass it from auxiliar to auxiliar function
08:20:40 <Grind> shapr: that's what I'm doing now...
08:20:54 <SyntaxNinja> Grind: how many functions are we talking about here?
08:21:15 <Grind> let me see...
08:21:51 <Grind> 10 functions
08:22:13 <SyntaxNinja> there are 10 aux functions that dont' alter the state? are they deeply nested so you have to pass the state around to functions that don't use it and such?
08:23:16 <Grind> no, 3 that change state, and 7 that do not, sorry
08:23:50 <Grind> and all of them use the state
08:24:53 <SyntaxNinja> in my experience, it's good to pass them as params to the 7 that do not use it; those 3 that do use it will otherwise have to be careful to write the state before calling the other functions, which is a bit of a pain (more painful than passing them anyway)
08:25:15 <SyntaxNinja> but it depends on your code, of course
08:25:31 <SyntaxNinja> also, presumably, those 7 functions don't call the 3 that alter the state?
08:25:37 <Grind> no
08:25:52 <Grind> the ones that change it are top level functions
08:25:59 <Grind> the ones that just read them are auxiliary
08:26:11 <Grind> in case it maters it's a unification algorithm
08:26:35 <Grind> the environment has meta var info
08:26:53 <Grind> so the top level functions are trying to do the unification
08:27:07 <Grind> and they call other functions that search for info in the environment
08:27:33 <Grind> right now I just pass env around
08:27:48 <shapr> hi tmoertel 
08:27:50 <Grind> function that try to unify return Maybe Env
08:27:54 <shapr> wassup?
08:28:07 <tmoertel> hi, shapr. not much here: just working.
08:28:13 <Grind> may idea was to change that to a,  StateT Env Maybe a
08:28:24 <shapr> tmoertel: written any fun code lately?
08:28:44 <Grind> seemed nice to have the Environment in a monad accecible to all those functions
08:28:52 <tmoertel> no, not fun, not even *fun*ctional in a while, even   :(
08:28:56 <SyntaxNinja> Grind: yeah
08:29:11 <Grind> SyntaxNinja: I can make this work fine
08:29:12 <tmoertel> shapr: are you doing the contest?
08:29:28 <Grind> SyntaxNinja: I'd just like to have some way to tell, this functions are read only, and this ones are not 
08:29:49 <shapr> tmoertel: nah, preparing for EuroHaskell and EuroPython
08:30:08 <shapr> sadly EuroPython was scheduled long before the contest dates were public
08:30:34 <tmoertel> shapr: this year it's hard to find time. if i get some time away from working, I might try an entry, but that's doubtful
08:31:04 <shapr> yah, we're flying south tomorrow morning, and I'm hacking on last minute stuff that has to be done.
08:31:28 <shapr> at least I can afford hardware and internet.
08:32:12 <shapr> tmoertel: haven't had a chance to try HaskellDB?
08:32:36 <shapr> tmoertel: check out the latest HaskellDB-using app: http://shapr.homelinux.net/cgi-bin/blob/BlobHtml - written by bringert 
08:32:53 <tmoertel> shapr: I packaged it up and installed it, but then the project for which I had planned on using it got pushed back.
08:33:44 <SyntaxNinja> Grind: yeah, it makes sense... I would at least try what I suggested; (make the 7 functions pure, and the 3 functions use the state, since that is what's logically happening).  I'm not sure how you can get what you want, though, where they're all in the same monad, but some can write and some can't.
08:34:00 <tmoertel> shapr: is that a wiki or blog? WASH/CGI, too, I presume?
08:34:15 <shapr> blog, and actually Text.XHtml
08:34:34 <shapr> straightup Network.CGI I think
08:35:04 <shapr> tmoertel: darcs get http://homer.vsg.sgsnet.se:8080/~bjorn/blob/ if you want sources
08:36:21 <Grind> SyntaxNinja: I see your point, just not sure if it's worth to use monad transformers just because of the top level functions
08:37:10 <SyntaxNinja> I wasn't suggesting you use monad transformers.
08:37:11 * SamB wants a look at the source of a T4 phage, wonders where such things are found
08:37:28 <shapr> SamB: T4 antibody?
08:37:45 <shapr> is that a helper T cell?
08:38:09 <Grind> SyntaxNinja: yes but I need a StateT 
08:38:32 <SamB> it seems to look like a LEM
08:38:36 <Grind> SyntaxNinja: (hmm just noticed I missed one function that changes state... :) )
08:38:42 <SyntaxNinja> Grind: because of the Maybe monad?
08:38:46 <Grind> SyntaxNinja: yeap
08:38:49 <shapr> SamB: http://phage.bioc.tulane.edu/
08:38:58 <Grind> SyntaxNinja: I can either get a new environment or the unification may fail
08:39:04 <SyntaxNinja> Grind: is this too large to write it several ways and decide which you like best?
08:40:02 <Grind> SyntaxNinja: nah, I guess I can do it... maybe just too dynamic as I keep changing them :)
08:41:57 <SyntaxNinja> Grind: leave it with the functionality it has now, and either use your vc system or just copy the files, write it several ways, and decide which is most elegant :) you'll learn a lot that way, and it'll probably answer questions more clearly than you can hope for on here.
08:42:06 <SyntaxNinja> though it's good to come here to get the suggestions for what to try :)
08:42:23 <SamB> if I was reading right, it apparantly uses some tricks a bit like those of the 45 byte true(1) ;-)
08:44:46 <Lor> Is everyone already trembling with excitement?
08:45:06 <shapr> I'm at least trembling. does that help?
08:45:27 <Grind> SyntaxNinja: yeap, I intend to do that of course ;) I like to ask the opinion of more experienced people because I'm pretty sure that there are several 'standard' techniques I have never heard of
08:46:57 <Grind> SyntaxNinja: just some time ago I was reinventing (a particular case of) arrows :)
08:47:51 <SyntaxNinja> Grind: heh
08:53:05 <Hyp3rion> ^_^ there is something i dont understand about "monads"... are they referentially transparent? or just a way to tell the system that the following "function" is not ref. transparent?
08:54:58 <SamB> Hyp3rion: they are referentially transparent
08:56:09 <Hyp3rion> SamB - :-) okay then i need to read further... thanks!
08:56:58 <Lor> It's 16.00 UTC already.
08:57:00 <Lor> They're late!
08:57:23 <Lor> And boy, did their server just start lagging... :)
08:57:39 <tmoertel> Not late yet: Fri Jun  4 11:57:38 EDT 2004
08:58:03 <tmoertel> (So says stratum-3 time server.)
08:58:15 <Lor> Sheesh. My local clock has drifted that much in just a month or so without ntp?
08:58:33 <tmoertel> Lor: what's the URL again?
08:59:31 <Grind> argh!
09:00:00 <tmoertel> The time is NOW!
09:00:32 <vegai> Seven o'clock says mr. Fuzzy Clock
09:00:43 <Grind> lol, it took me 5 mins to find out the mistake in:
09:00:46 <Grind> if b then modify (+1) else modify (-1)
09:00:50 <Grind> lol
09:00:55 <tmoertel> wow, the upenn server just ground to a standstill ...
09:00:55 <Grind> I need something to eat :)
09:01:35 <Heffalump> so, is everyone obsessively reloading the task page?
09:01:45 <Grind> but it was really tricky hehe :)
09:01:49 <tmoertel> Heffalump: yes, it would seem that way.
09:01:50 <Heffalump> their webserver seems not to be talking to me.
09:01:59 * tmoertel is downloading the PDF version of the task.
09:02:10 <Grind> Heffalump: :)
09:02:14 <Grind> Heffalump: works fine here...
09:02:20 <Grind> Heffalump: (ghc website right?)
09:02:21 <Heffalump> hmm.
09:02:26 <Heffalump> no, the ICFP one
09:02:30 <Grind> oh
09:02:32 <Heffalump> if someone could make a copy available to me that'd be nice.
09:02:40 <Grind> that I don't know 
09:02:42 <Grind> let me see
09:02:51 <Heffalump> since it really isn't responding from either of the places I'm trying
09:02:56 <Heffalump> oh, got it
09:03:00 <Grind> http://www.cs.luc.edu/icfp/ ?
09:03:34 <Heffalump> no, http://www.cis.upenn.edu/proj/plclub/contest/task.php
09:03:39 <tmoertel> Heffalump: http://community.moertel.com/~thor/ants.pdf
09:03:40 <Lor> icfpcontest.org
09:03:43 <Lor> 10 seconds...
09:03:44 <Lor> There!
09:03:46 <Lor> Wow! Cool!
09:03:52 <Lor> It's both local output generation (like last year) _and_ a tournament.
09:04:06 <Heffalump> tmoertel: ta muchly.
09:04:08 <Grind> Heffalump: nah, not loading here either
09:04:18 <Grind> brb
09:05:45 <Heffalump> 15 pages!
09:06:07 <tmoertel> thank goodness my printer does duplex!   ;-)
09:06:46 <Lor> This looks pretty darn cool.
09:07:02 <shapr> yes it does
09:09:11 <Lor> This also looks pretty darn non-trivial.
09:09:37 <tmoertel> Lor: No, it *is* trivial: Just de-compile a real ant and reverse engineer it.
09:09:43 <tmoertel> :P
09:10:28 <shapr> haha!
09:10:33 * shapr quotes that
09:11:25 <Lor> So. One has to write both an ai program _and_ a compiler for it. Whoopidoo.
09:11:48 <shapr> or use the genetic approach
09:12:04 <Lor> Well yeah.
09:12:18 <tmoertel> shapr: of course, the fitness function would be non-trivial and probably expensive.
09:18:13 <SamB> while you are at it, can you get these ants off my computer desk?
09:18:33 <Lor> Gah. The mind boggles at the size of the task.
09:23:29 <phubuh> oh
09:23:32 <shapr> tmoertel: just run them in the simulator and eliminate those who rarely wine
09:23:35 <shapr> :-)
09:23:53 <phubuh> so that's the purpose of the misspelling of "Annual" :)
09:30:55 * phubuh thinks he'll skip the contest this year (-:
09:33:09 <Lor> I really hated the 2002 contest, but this one is cool.
09:33:23 <Lor> The reason I hated it was that they didn't specify anything about the maps that would be used.
09:35:51 <phubuh> i loved the SML/NG one, but i failed to notice it until after the deadline
09:35:53 <Lor> Argh. They use stupid hex coordinates.
09:36:01 <phubuh> i'm not much for this kind of AI stuff :)
09:36:34 <Lor> hex coordinates should go along two of the three axes. Not alternating in an attempt to imitate a square grid.
09:45:25 <stratocaster> Hi. Any way I can catch the exception thrown by a failed "read"?
09:49:19 <Spark> shapr: i'd like to :)
09:52:04 <stratocaster> Hmm, "There is no way to catch an error indicated by the error function.", ttp://www-fp.dcs.st-and.ac.uk/~kh/papers/io-tutorial/subsubsectionstar3_2_3_2.html . I guess that answers my question.
09:52:29 <tmoertel> stratocaster: actually, I believe that you can do it.
09:52:49 <stratocaster> So any time I use "read" on, say, user input, I've got to do, say "all isDigit inp" and stuff like that to make sure it's going to work?
09:53:32 <stratocaster> tmoertel: Any idea how in particular?
09:57:46 <tmoertel> stratocaster: evaluate your read (fully, use seq or deepSeq) in the IO monad where you can catch failures
09:59:08 <tmoertel> stratocaster: see the Control.Exception.evaluate: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html#7
10:03:38 <tmoertel> stratocaster: evaluate (read "9" :: Int) `Control.Exception.catch` const (return 0) >>= print
10:03:58 <tmoertel> prints 9, but the following prints 0:
10:04:07 <tmoertel> stratocaster: evaluate (read "blah" :: Int) `Control.Exception.catch` const (return 0) >>= print
10:05:18 <stratocaster> Ah, terrific. Thanks.
10:12:44 <stratocaster> Yea, that's working perfectly. Much nicer than before.
10:56:36 <SyntaxNinja> is alexander jacobson in this room by chance?
10:57:48 * stepcut is not alexander jacobson, if that helps
11:01:40 <SyntaxNinja> is anyone following the discussion on libraries@ between me (isaac) and him?  I can't tell if there's really something that's unclear.
12:06:15 <tmoertel> is anybody here working on the icfp contest?
12:06:24 <shaleh> tmoertel: is it public?
12:07:01 <tmoertel> the contest? yes, there's even a web page for it: http://icfpcontest.org/
12:07:14 <shaleh> tmoertel: I meant, is the problem know yet?
12:07:25 <sorrow> What is an "antual contest"?
12:07:32 <tmoertel> yes, it was released 3 hours, 7 minutes ago.
12:07:35 <shaleh> sorrow: spoof on annual
12:10:28 <SyntaxNinja> does readChan remove the top item?
12:16:30 <shaleh> reffie: icfp, interesting problem, still reading .......
12:16:36 <shaleh> grrrr
12:16:40 <shaleh> silly xchat
12:18:01 <Verbophobe> Trix are for kids, right?
12:27:36 <shaleh> hmm, icfp sounds like a fun one this year
12:28:14 <shaleh> write a game engine, write programs to output ant state machines
12:29:15 <SyntaxNinja> yeah, I'm a little jealous
12:29:46 <stepcut> yeah, I am very jealous, but I have to spend the weekend moving across town
12:29:47 <stepcut> :(
12:30:05 * stepcut goes to lunch
12:30:55 <shaleh> I never have this weekend free either
12:30:59 <shaleh> oh well
12:31:12 <shaleh> doesn't mean I can't save the final data and work on it later
12:31:26 <shaleh> the task will still be fun even if it is not for a competition
12:31:52 <shaleh> the last few competitions have been games driven by neural nets / genetic algos
12:39:13 <earthy> yeah, I would've *loved* to join...
12:39:20 <earthy> the assignment is fun!
12:39:57 <earthy> such a pity I can't enter due to time constraints
12:40:09 * earthy needs to schedule the first weekend of june 2005 *empty*
12:43:17 <shaleh> earthy: yeah, I said that last year (-:
12:43:57 <earthy> problem is that there is no fixed weekend in which the contest is held
12:44:08 <earthy> and it usually isn't announced more than roughly a month in advance
12:47:34 * timbod is back (gone 01:40:22)
13:33:52 <shapr> earthy: yes, I agree
13:34:39 <shapr> earthy: if they'd do it on a yearly basis, same weekend every year, then I'd always reserve that spot in my calendar.
13:37:36 <Hyp3rion> to print all elements of a list, say, one per line, i need to define a separate recursive function that does it right? or can it be done simpler?
13:37:50 <shapr> SyntaxNinja: I think S. Alexander Jacobson is being flipping pedantic.
13:39:08 <SyntaxNinja> shapr: I feel like he's not reading my posts or the proposal.
13:39:26 <SyntaxNinja> he wants to change the goal of the project for some silly idea about security that's not going to work.
13:39:34 <SyntaxNinja> (from what I can tell)
13:40:14 <shapr> I think that's an accurate summary.
13:40:45 <phubuh> Hyp3rion: there's usually no need for explicit recursion for simple stuff like that:  mapM_ (putStrLn . show) ["things", "to", "print"] is more idiomatic :-)
13:40:49 <shapr> his idea might be workable, but not without at least a Ph.D. written on the subject :-)
13:41:33 <shapr> SyntaxNinja: anyway, ensuring safety isn't one of the goals of your project, easing the installation process of Haskell libs and tools is your goal.
13:41:50 <SyntaxNinja> shapr: and even then, it's only a theoretic security advantage; you still have to trust the vast majority of your upstream authors.
13:42:01 <SyntaxNinja> that's why it should be on the OS level, like with apt-secure
13:42:18 <SyntaxNinja> though his points on language-level safety are interesting enough (wrt the IO monad)
13:42:24 <Hyp3rion> phubuh - i see... i am new to haskell. thanks :-)
13:43:32 <shapr> SyntaxNinja: an easy way to do safe lib downloads is to include an md5 hash in the import, then you can download that lib from anywhere as long as hash works
13:43:50 <shapr> but once again, that's not the point right now
13:43:51 <shapr> maybe next year
13:44:41 <phubuh> Hyp3rion: mapM_ f xs basically creates an IO action that -- in order -- performs every application of f to an element from xs; so mapM_ foo [1,2,3] is equivalent to do foo 1; foo 2; foo 3
13:45:00 <Hyp3rion> is GHC using GCC on x86 in the generation of native code?
13:45:09 <shapr> do all non-chamerite EuroHaskell attendees have either my phone number or bringert's?
13:45:14 <phubuh> hey, strike that IO, I guess it works for any monads
13:45:15 <shapr> er "non-chalmerite"
13:45:18 <phubuh> shapr: I don't!
13:46:06 <Hyp3rion> phubuh - yes simple map complained about types :-/
13:46:48 <stepcut> what's the best way to learn about category theory, with the intent of being able to understand whitepapers about haskell better?
13:46:56 <stepcut> is there a really good book or something?
13:47:04 <shapr> Pseudonym had some good suggestions
13:47:18 <stepcut> ok
13:47:31 <shapr> have you already read this: http://www.xp123.com/wwake/dissertation/model.shtml ?
13:47:36 <stepcut> nope
13:47:52 <stepcut> I have read almost nothing
13:48:00 <stepcut> except a bit about functors
13:48:00 <shapr> I really like that page
13:48:19 <stepcut> looks cool, I will read it now
13:48:50 <shapr> it's short, easy to read, and quite illuminating.
13:52:31 <TheHunter> for a very short intro you could check out http://www.cs.toronto.edu/~sme/presentations/cat101.pdf
13:53:39 <shapr> Spark: hey, if you're showing up, do you have my number?
13:54:26 <shapr> Lunar^: you have my number?
13:54:46 <shapr> oh, I'll see Lunar^ at EuroPython
13:54:52 <shapr> he won't escape
13:54:57 <shapr> same with gintas
13:55:33 <shapr> maihem: your passport didn't make it in time, is that correct?
13:56:18 <phubuh> i'm still not entirely sure i can come, by the way.  it depends on whether i can 1) coerce my brother into joining, and 2) coerce my mother into lending us her car
13:57:24 <shapr> no worries, it'll be fun if you can come, but no pressure :-)
13:58:06 <phubuh> yeah :)
14:02:23 <maihem> hell no, I wish I could come, but I hope to attend next year
14:02:28 <shapr> ok
14:02:57 <shapr> where's EuroHaskell happening next year?
14:10:16 <maihem> please let it happen
14:27:25 <SyntaxNinja> I swear, this is the last email from alexander jacobson that I'm going to reply to...
14:27:46 <SyntaxNinja> at least he seems to have gotten off of the security business for now.
14:27:51 <SyntaxNinja> maybe I shouldn't reply to this one either.
14:29:00 * SyntaxNinja home &
14:45:12 <shaleh> emacs mode needs a C-C arrow indenter
14:48:01 <shapr> shaleh: eh?
14:48:21 * shapr packs for the plane ride tomorrow morning
14:48:38 <shapr> I'm flying to vacation in the sunny south!
14:48:58 <shaleh> shapr: I can not seem to get the indent right on things like case statements, it always wants to jump way deep into the line
14:49:07 <shaleh> so an equiv to C-C = would be nice.
14:49:15 <shapr> oh, yah, I agree with that.
14:49:29 <shaleh> perhaps C-C >
14:49:33 <shapr> I usually end up throwing "of" to the next line to get a shallower indent
14:50:06 <shaleh> I am just a little surprised no one else has solved this by now
14:54:48 <shapr> shaleh: feel free to fix it :-)
14:55:01 <shaleh> shapr: oh, if I keep hacking in Haskell I *WILL*
14:55:08 <shapr> that's good to hear
14:55:20 <shaleh> shapr: the python-mode has shown me how good a mode can make things
14:55:29 <shapr> yah, python-mode has some nice points
14:55:41 <shapr> it could be far better with a full lexer/parser
14:55:50 <shaleh> so when I hack in some other mode which sucks, I notice it
14:55:53 <shapr> that's why I always get frustrated with emacs modes
14:56:04 <shapr> they're all based on regexps, and it's just not good enough
14:56:08 <shaleh> right
14:56:21 <shaleh> but making it any better is a *LOT* of work
14:56:30 <shapr> maybe not
14:56:38 <shapr> at least, not TOO much work.
14:57:06 <shapr> have you seen the ATerm parse tree format?
14:57:22 * stepcut wonders if debian will just stick with Xfree86 4.3 forever
14:57:35 <shaleh> shapr: no, what is it?
14:57:37 <desrt> stepcut; they're using 4.3?  i thought they were still at 3.3 :)
14:57:50 <shaleh> stepcut: nah, x.org will eventually take over it seems
14:58:09 <stepcut> well, i think sid has 4.3 now
14:58:21 <desrt> sid does not count :)
14:58:23 <shapr> shaleh: http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary
14:58:25 <shaleh> stepcut: it does
14:58:30 <det> ehh, I think I remember some extra tag being added to the sid XFree packages
14:58:32 <stepcut> shaleh: yes, but it's taken atleast a year to get xfree86 4.3 into *sid*
14:58:35 * desrt doesn't want some demented doll-mutilating kid to have access to his machine
14:59:02 <shaleh> stepcut: yeah, I know.  Debian does an insane amount of work on X.  Never really understood why.
14:59:07 <shapr> shaleh: ATerm is  designed to be exchanged between programs, so it doesn't use much ram, and structures are immutable, etc
14:59:17 <shaleh> and it is mostly done by < 3 people
14:59:24 <stepcut> i figure after all the work on 4.3, they are just going to stick with it forever :)
14:59:30 <shapr> anyway, I think the next generation editor should be based on that
14:59:31 <desrt> cgibbard; are you here?
15:00:01 <shaleh> shapr: yeah, I am not bound to emacs.  The next thing just needs to be as powerful.
15:00:02 <shapr> shaleh: the MetaEnvironment http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/MetaEnvironment
15:00:17 <shapr> is a language agnostic parse tree rewriting toolkit
15:00:33 <shapr> but it's not quite tight enough to use as a full-time editor
15:01:57 <det> Get:1 http://ftp.rutgers.edu unstable/main xserver-xfree86 4.3.0.dfsg.1-1 [5449kB]
15:02:41 <det> what does the "dfsg" signify (other than Debian Free Software Guidlines, I mean) ?
15:02:56 <Lukhas> fix some compliance stuff, i think
15:03:17 <Lukhas> and show that's it's still considered as Free Software according to Debian
15:03:58 <det> with what version was DFSG compliance broken?
15:04:04 <det> 4.3 ?
15:04:05 <shaleh> det: 4.4
15:04:08 <shaleh> i thought
15:04:09 <det> ahh
15:04:21 <shaleh> the 4.3dfsg is the pre4.4 tree
15:04:27 <shaleh> right before the break
15:04:33 <shaleh> as I understand it
15:04:50 <Lukhas> i think so
15:06:22 <shaleh> say I am given a string of input, something like 'cmd option ...'
15:06:42 <det> shaleh roll over
15:06:44 <shaleh> is a case statement based on head (words input) reasonable for making decisions?
15:06:44 <det> now what
15:07:03 <shaleh> det: sorry
15:08:09 <det> I dont understand your question
15:08:30 <shaleh> I am learning haskell, so forgive the silliness here
15:08:31 <det> are you talking about argv, argv?
15:08:40 <det> erm argc, argv
15:08:56 <shaleh> to learn haskell, I am implementing a simple pop3 server which will run from inetd.
15:09:17 <shaleh> an input looks like 'retr 111' which gets the 111th message
15:09:37 <det> ohh
15:09:47 <shaleh> so I have a cmdHandler function which does: case (head (words input))
15:09:55 <shaleh> and the cases are the commands
15:10:14 <det> I imagine that depends on the POP3 protocol
15:10:15 <shaleh> is that a reasonable approach in haskell? or am I misusing the syntax?
15:10:45 <shaleh> cmdHandler line =  case (head (words line)) of
15:10:45 <shaleh>                    "user" -> putStr "Heard: login request\n"
15:10:45 <shaleh>                    "pass" -> putStr "Heard: password\n"
15:10:45 <shaleh>                    "quit" -> myExit
15:10:45 <shaleh>                    a      -> mapM_ putStr ["Heard: ", line, "\n"]
15:12:43 <det> I am not familiar enough with Haskell to answer that, however ..
15:12:50 <det> greping all the 
15:12:57 <SamB> can't imagine what you mean by abusing the syntax, really ;-)
15:13:12 <det> ".hs" files on my computer reveals that idiom is used in hug's CGI library
15:13:57 <shaleh> SamB: (-: I guess I am trying to say "how close to normal Haskell idioms is this approach?"
15:14:39 <shaleh> or someone to say "dear god that is known to be the WORST way to do that"
15:15:03 <det> shaleh: run this: locate "*.hs" | xargs egrep "\".+\" ->" :)
15:16:33 <shaleh> hmmm
15:16:38 <SamB> I can think of a worse way, trust me ;-)
15:17:33 <ne1> A case statement with three or more cases is better than a cascade of if-then-elseif-then-elseif-...
15:19:28 <SamB> you can't get all that nicer than what you have already, but you *can* get an awfull lot worse
15:23:10 <SamB> I don't know if I've had a real opportunity to use if yet ;-)
15:23:35 <cgibbard> desrt: yeah
15:23:45 <desrt> woh
15:23:46 <desrt> you're here
15:23:50 <desrt> how's the parser coming?
15:23:56 <cgibbard> It's going well
15:24:05 <desrt> have you thought about memory writes?
15:24:21 <cgibbard> I should be able to finish the parser before I leave.
15:24:38 <desrt> macros?
15:24:49 <cgibbard> Well, it will parse them :)
15:25:00 <desrt> will it mangle declaration names?
15:25:14 <cgibbard> It will be up to us to actually do the expansion afterward, but that should be simple given the way that I defined things.
15:25:21 <desrt> o.
15:26:17 <desrt> so i guess my question is a little out of context
15:26:19 <cgibbard> Believe it or not, contstants were the most complicated thing so far.
15:26:25 <desrt> i believe it
15:26:33 <desrt> we have to have predicates to explain how they work :)
15:26:34 <desrt> oh wait.
15:26:37 <desrt> you mean just parsing them
15:26:41 <cgibbard> yeah
15:26:44 <desrt> pfft :P
15:26:59 <desrt> do we have data constructors?
15:27:10 <cgibbard> Roughly :)
15:27:17 <desrt> heh
15:27:29 <desrt> is <= assignment?
15:27:30 <desrt> or <-
15:27:34 <cgibbard> <-
15:27:40 <desrt> hmm
15:27:47 <desrt> i'd have prefered <= :)
15:28:27 <desrt> save <- for assignments while passing around monad state
15:28:29 <desrt> *cough*
15:28:46 <cgibbard> Const{f,s,u,b}{8,16,32}[Splat] val, val, ..., val [, "comment"]
15:29:04 <desrt> no....
15:29:20 <cgibbard> where {} denotes disjoint selection, and [] optional
15:29:39 <desrt> not good names
15:29:52 <cgibbard> They're the ones that Chris likes :)
15:29:54 <desrt> Constf{8,16} make no sense, for example
15:30:08 <cgibbard> oh, right, that's not quite allowed :)
15:30:21 <desrt> also.. if you give b
15:30:27 <desrt> then the number is not required
15:30:35 <desrt> so f/b are special cases, really
15:30:38 <cgibbard> then the values take the form {True,False}
15:30:47 <desrt> oh.  b is bool?
15:30:51 <cgibbard> Yeah
15:30:54 <desrt> ah
15:30:57 <desrt> i thought it was like u8
15:31:16 <cgibbard> "comment" will be handy for your graphs :)
15:31:28 <desrt> my graphs don't show constants
15:31:40 <desrt> they have a node for each instruction within the loop
15:31:40 <cgibbard> you could label the edges
15:31:49 <desrt> i could
15:31:53 <desrt> hm
15:32:07 <desrt> please keep the old way of specifying constants :)
15:32:50 <desrt> myconst <= { 45, 29., 0x23456ab, 92.348e12 }
15:33:15 <desrt> well
15:33:21 <desrt> maybe that is v_myconst
15:33:29 <desrt> depending on if we are doing the type thing or not
15:33:56 <cgibbard> what non-vector constants do we have?
15:34:03 <desrt> we'll have them soon
15:34:16 <cgibbard> Yeah - which ones do we get?
15:34:29 <desrt> floats, doubles, 64-bit integers
15:36:10 <cgibbard> the only problem with the format you have above for the constants is that it pretty much requires existential typing to make convenient.
15:36:46 <desrt> no... just no types at all
15:37:05 <cgibbard> and what part of Haskell is untyped?
15:37:17 <desrt> oh.  you mean types in haskell
15:37:31 <cgibbard> We do need to actually parse the values
15:37:37 <cgibbard> Or am I wrong?
15:37:46 <desrt> we need to parse some of the values
15:38:00 <desrt> just the floats
15:38:15 <desrt> but they all parse to the same thing
15:38:33 <desrt> so we just need a function that takes a string and gives you an integer
15:38:50 <desrt> using the rules:
15:38:55 <desrt> 1: if it starts with 0x it's hex
15:38:57 <cgibbard> let me update darcs
15:39:01 <desrt> 2: if it contains . or e it's float
15:39:05 <desrt> 3: else it's an int
15:39:42 <desrt> handling non-vectors is slightly more difficult
15:40:12 <desrt> i think we only want type constructors for splatted types
15:40:27 <desrt> because it's better than typing <= { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
15:40:50 <desrt> or <-
15:41:38 <desrt> but, again... it would almost be cool to say something like....
15:42:00 <desrt> constants <- { 3., 0x2345abc, 1200, 1 }
15:42:06 <cgibbard> okay, the new code should be in darcs
15:42:15 <desrt> allones <- vspltb constants, 15
15:42:35 <desrt> and have constant-propagation take care of the vspltb
15:43:30 <desrt> although that's giving hints on how to store constants... which is decidedly not the point
15:46:12 <desrt> it would actually be harmful in some cases
15:46:37 <shaleh> take care all
15:47:01 <desrt> we could use {{ 1 }} to denote splat constants... but that's ambiguous
15:47:11 <desrt> is it a byte or a halfword or a word?
15:51:35 <cgibbard> Well, sort out entirely how you want it to work, and I'll implement that. For now, homogeneous, completely prespecified vectors are working :)
15:51:54 <desrt> :)
15:52:00 <desrt> certainly if you see { 2, 3, 4, 5 }
15:52:07 <desrt> it's safe to assume that that's a 16-entry vector
15:52:11 <desrt> errr.. 4-entry, sorry
15:52:14 <cgibbard> heh
15:52:59 <desrt> with the 'other' syntax
15:53:17 <desrt> how would i load a vector that contains { 2., 3., 123, 321 }
15:53:57 <desrt> if it's not too much of a hassle then perhaps i should just learn to use it
15:54:20 <cgibbard> You wouldn't. I agree that we should allow for heterogeneously typed vectors, but that's not done yet.
15:54:42 <desrt> i'm just worried about the data constructors getting really awful looking
15:55:52 <cgibbard> Well, if it comes to that, I don't think it will be part of the "type constructor".
15:55:54 <desrt> it would also be nice (but strange and not entirely useful) to go totally heterogeneous
15:56:00 <cgibbard> "data constructor" rather
15:56:17 <desrt> like allow half of a vector to be specified as 32bit parts
15:56:26 <desrt> and the other half to be specified as 16bit
15:56:51 <cgibbard> well, that's not entirely impossible
15:57:05 <desrt> { 0x12345678, 6.023e23, { 0x3920, 4, 5, 9 }}
15:57:06 <cgibbard> we should make our own channel for this discussion
15:57:06 <desrt> *shrug*
15:57:47 <desrt> #= :)
17:52:31 <stepcut> anyone know of a program for 'statically analyzing' bash scripts for errors?
18:06:29 <SyntaxLaptop> stepcut: rm?
18:06:32 <SyntaxLaptop> oh, he's gone :(
19:16:50 * timbod is away: I'm busy
23:01:49 * shapr yawns
23:06:26 <Igloo> How goes it, shapr?
23:07:34 <shapr> last minute packing
23:07:41 <Igloo> Ah, EuroHaskell?
23:07:44 <shapr> yup
23:08:12 <shapr> I've seen lots of people check-in their snowboards and skis, I wonder if they've had other unicycles before.
23:09:17 <shapr> Igloo: you're up early
23:09:22 <Igloo> No, late
23:09:26 <shapr> oh :-)
23:09:33 <Igloo> Don't ask.
23:09:40 * shapr grins
23:10:35 <shapr> welp, I'll be back in a week.
23:10:52 * shapr waves
