01:12:48 <javaNewb> evnin fellow haskell ppl :)
01:13:05 <ski> good morning javaNewb
01:16:05 <javaNewb> how can i print something onto the screen and then do a claculation all in one function?
01:17:28 <ski> foo = do print 1234
01:17:38 <ski>          return (17*42)
01:24:52 <ski> javaNewb : does that help ?
01:25:10 <javaNewb> umm not realli...but im still trying to use it
01:25:31 <javaNewb> its like ummm f x y | is this si true then terminate
01:25:55 <javaNewb> |show this list comp then f x' y'
01:26:03 <javaNewb> thats what im trying to do
01:26:25 <ski> why are you trying to show it ?
01:26:40 <ski> for debugging ?
01:26:49 <ski> or for normal operation of the program ?
01:26:56 <javaNewb> not the show function...i meant to say create this list comp
01:27:05 <ski> mhmm
01:27:31 <ski> so what do you want to do with the list comprehension after you've created it ?
01:29:12 <javaNewb> save it add to it until the first test is true then print it out
01:29:32 <ski> not return it from the function, then ?
01:30:11 <javaNewb> just a minute...i don't think i fully understand what im being asked to do for this question...i'll re-read it and come back okay?
01:30:28 <ski> sure
01:36:23 <javaNewb> im stuck...
01:36:25 <javaNewb> :S
01:37:05 <ski> oh
01:37:27 <ski> you don't understand what you're supposed to do ?
01:37:42 <earthy> then thing are going to get real hard
01:37:54 <ozone> be nice. :)
01:37:57 <javaNewb> its a wierd situation
01:37:57 <ski> or you can't figure out how to do it (in haskell) ?
01:38:21 <javaNewb> i can get the desired answer but not all the steps in between
01:39:29 <ski> how do you mean ?
01:39:37 <javaNewb> umm maybe its best i show you
02:07:40 <shapr> yow!
02:07:50 <ski> @yow
02:07:51 <lambdabot> BRYLCREAM is CREAM O' WHEAT in another DIMENSION..
02:26:51 <shapr> good morning #haskell!
02:27:08 <ski> morning' :)
02:29:54 <Lukhas> morning shapr
02:29:57 <javaNewb> evnin/mornin
02:32:43 <shapr> good @439 to ya
02:33:10 <Lukhas> hey, ERC recognizes this, but no idea what it is :)
02:33:35 * shapr grins evilly
02:33:44 <shapr> try middle-clicking on it
02:33:55 <Lukhas> that's what i did
02:33:57 <shapr> if kensanata's code is still in there, it should translate that into your local time
02:34:04 <Lukhas> it does
02:51:51 <Amadan> @index StateT
02:51:52 <lambdabot> Control.Monad.RWS,Control.Monad.State,Control.Monad.RWS,Control.Monad.State
02:54:44 <shapr> whoa, I just realized that skap in swedish is like "ship" in english. so vännskap is friendship, and kunskap (knowledge) is abilityship,  and vetskap (science) is knowship.
02:54:59 * shapr epiphanizes
02:55:37 <Amadan> :)
02:55:43 <ski> så bra :)
02:56:06 <ski> (shapr : btw 'vänskap')
02:56:14 <shapr> ah, tack
02:58:49 <shapr> bok Amadan, wassup?
03:00:15 <Amadan> hi... just saw your linguistic epiphany, rofled for a minute :)
03:00:40 <Amadan> otherwise, struggling with a) learning haskell, b) getting a parallel thingy set up
03:01:03 <bringert> morning y'all
03:01:05 <Amadan> i went halfway through the (not so) gentle monad tutorial
03:01:11 <Amadan> 'morning!
03:01:21 <shapr> god morgon ni!
03:01:28 <shapr> y'all is the american ni
03:02:32 <shapr> Amadan: I would guess you know more than hrvatska and engelska, since croatian -> english seems to me like it wouldn't give so many epiphanies.
03:02:54 <shapr> but maybe I just don't know enough croatian.
03:03:06 <Amadan> and got really stuck somewhere around States... about the time the inner type changed to functions :)
03:03:25 <Amadan> a bit... i'm a linguist slash programmer
03:04:01 <shapr> Programming is my hobby, I just haven't bothered to find a real job yet. Languages is a sub-hobby for me.
03:04:23 <Amadan> for me too... not much work for a linguist around here.
03:04:33 <ski> (shapr : 'ni' can also be a polite form of 'you' (but i think, 'you' is actually the polite form of 'thou', no ? :))
03:04:57 <shapr> ski: I thought thou was the polite form of you, but I could be wrong
03:05:08 <Amadan> except teaching linguistics to other boobs who would subsequently again wonder about what is linguistics good for
03:05:39 <Amadan> no, thou used to be singular
03:05:43 <javaNewb> haha i do linguistics
03:05:58 <shapr> I think we have some other linguistics people here too
03:06:02 <shapr> what's the connection?
03:06:06 <Amadan> then they started using you (plural) for politeness
03:06:17 <bringert> dobar dan
03:06:24 <Amadan> then started being polite to even their kids, and all hell broke loose :)
03:06:26 <Amadan> dobar dan :)
03:06:48 <bringert> that's about all the croatian I know
03:07:11 <bringert> but I found that you can get around croatia using russian
03:07:12 <shapr> I can hi,couch,chair, and forehead in croatian ;-)
03:07:16 <Amadan> and then americans apparently wanted the difference back, so instead of listening to the good amish people (who still treasure their thou-s), they thought up a new word, y'all (you all)
03:07:34 <Amadan> rofl, you should tell me how you arrived at that selection
03:08:00 <bringert> the irish add an "s" to "you" for plural
03:08:17 <shapr> it was easy, my best friend in the US got married to a nice croatian girl, and when we asked her for a selection of choice croation curse words, she said "sorry, standard vocabulary only"
03:08:46 <Amadan> i don't know, to me it seems kind of sensible to link linguistics and programming, both deal in languages... and both can be formal about it.
03:08:49 <Amadan> :)
03:08:57 <Amadan> but FOREHEAD? :)
03:09:01 <shapr> bringert: right, and people in chicago say "youse" for y'all
03:09:05 <shapr> well, why not?
03:09:09 <Amadan> (maybe it was Klingon? :))
03:09:14 <shapr> haha
03:09:39 <shapr> bringert: so I guess that came from the irish...
03:09:43 <shapr> nifty connections
03:10:14 <Amadan> anyway, i'd really like to learn this haskell beastie...
03:10:34 <bringert> you've come to the right place
03:10:37 <Amadan> and my boss is directing us towards parallel/distributed/grid processing
03:10:55 <Amadan> and i thought that it might be nice to try coupling the two
03:10:59 <shapr> I like the connections for 'bär' in swedish. bär is "to bear" like bearing gifts or bearing fruit. and a berry in swedish is a bär too
03:11:14 <shapr> so you can see that bearing fruit and berries came from the same word
03:12:17 <bringert> and bears eat berries
03:12:36 <shapr> yes, but bear is björn in swedish, so I dunno how that's connected.
03:12:55 <Amadan> probably not
03:12:56 <bringert> hmm, goog question, I'll look it up
03:13:04 <bringert> it's my first name after all
03:13:09 <shapr> yes
03:13:22 <shapr> of course, my first name is spoken tjej
03:13:23 <Amadan> bear (v) is related to latin ferre
03:13:50 <shapr> tjej erisson :-P
03:14:03 <Amadan> (to carry)
03:14:22 <Amadan> and the other one is unknown, but probably related to something that means "to eat"
03:15:03 <bringert> the big swedish ethymological dictionary says that it's possibly related to the indoeuropean "adj. bhero, lit. bÃ«ras" = brown
03:15:04 <Amadan> so i would like to make parallel programs in haskell, but i can't do that until i actually manage to set up a parallel haskell distribution
03:15:39 <shapr> Amadan: you could use hMPI
03:16:09 * bringert is trying to be a linguist
03:16:28 * shapr is trying to be a programmer
03:16:29 <javaNewb> what can linguists do?
03:16:44 <shapr> speak softly and carry a big book
03:16:53 <javaNewb> that it?
03:17:15 <shapr> I think linguists have a better understanding of what people are saying.
03:17:28 <javaNewb> which is important in cs why?
03:17:44 <Amadan> yeah, all my friends tell me i'm the worst punner they know... :)
03:18:02 <Amadan> depends which branch of linguistics interests you.
03:18:38 <Amadan> historical linguistics like what we just discussed, is not.
03:18:45 <Amadan> but formal linguistics is
03:18:45 <javaNewb> none atm, just doing ling 101
03:19:27 <Amadan> like, for example, formal semantics which (according to some people) tells you that meaning of person is \x -> person x
03:19:43 <shapr> there's a neat wiki page called SourceCodeAsUserInterface
03:19:53 <shapr> I think that's the sort of stuff that linguistics is good for
03:20:04 <Amadan> and that the meaning of every is \p \q (exists)x -> (P x `implies` Q x)
03:20:15 <ski> Amadan : that looks just like eta expansion ..
03:20:34 <javaNewb> looks like a foreign language to me
03:20:40 <Amadan> unfamiliar term: eta expansion?
03:22:05 <Amadan> (should have been (each), not (every) - sorry)
03:22:24 <Amadan> on haskell list? :) okay, it means that every is a function that takes two predicates P and Q as arguments, and is true when everything that is P is also Q
03:22:31 <bringert> if anyone is interested in formal semantics for natural languages, the notes fro the lang tech course might be interesting
03:22:33 <bringert> http://www.cs.chalmers.se/~aarne/course-langtech/lectures/lang09.html
03:22:38 <ski> and the meaning of "everybody" ? :)
03:22:39 <bringert> and 08 too
03:22:56 <Amadan> everybody == every person
03:23:07 <javaNewb> but what would a comp sci need with linguistics?
03:23:26 <Amadan> so, \Q (each)x (person x `implies` Q x)
03:23:31 <bringert> javaNewb: creating natual language interfaces for example
03:23:46 <javaNewb> like compilers?
03:23:46 <Amadan> (in a subject position)
03:23:51 <bringert> natural language processing, like making a good search engine
03:24:02 <Amadan> no, like AI systems that could converse in human languages
03:24:10 <Amadan> or search engines
03:24:22 <javaNewb> hmmm....
03:24:25 * bringert wrote a natural language interface to curryspondence
03:24:57 <bringert> "Which emails from Hughes sent after January 1, 2004 are about monads?"
03:25:19 <bringert> natural language technology was a fun course
03:25:27 <javaNewb> well nite all, have a good one :)
03:25:31 <Amadan> 'nite
03:26:43 <ski> "John saw everyone."
03:27:01 <Amadan> :)
03:27:25 <ski> forall x.Saw John x
03:27:27 <Amadan> you have to lift John... :)
03:28:00 <bringert> forall x . Person(x) implies Saw(John,x)
03:28:07 <ski> you mean separate betwixt syntactic and semantic John ?
03:28:20 <Amadan> no, i mean lift like in haskell lift.
03:28:39 <ski> monadic transformer lift ??
03:28:46 <Amadan> the type system formal semantics basically uses has two primitive types: e and t
03:28:50 <Amadan> e is object
03:28:53 <Amadan> t is truthvalue
03:29:01 <Amadan> so "person" is e->t
03:29:12 <Amadan> and "run" is e->e->t
03:29:16 <ski> yes
03:29:17 <Amadan> and john is r
03:29:20 <Amadan> sorry, e
03:29:27 <ski> i was thinking about
03:29:32 <ski> forall x :: Person.Saw John x
03:29:50 <Amadan> yeah, that's the end result
03:30:15 <Amadan> but then you can't use the nice compositional value for "every"
03:30:33 <ski> but how do we know to create a universal quantification at the top ?
03:30:40 <ski> right
03:31:22 <Amadan> (actually, it'd be (each)x (person x => saw x John)
03:31:43 <ski> hmm
03:31:55 <ski> right
03:32:04 <Amadan> and the problem is that saw (x) John is curried in the wrong way :)
03:32:25 <Amadan> saw John x is easy, it's e->t
03:32:28 <ski> John >@ (saw @< x)
03:32:40 <ski> left and right application
03:33:07 <ski> saw : e -> (t <- e)
03:33:28 <Amadan> :) sorry, unfamiliar territory... :)
03:33:36 <Amadan> anyway, i forgot a lot
03:34:05 <Amadan> but i kind of remember that if you want to have "e" (i.e. John) in the subject position, you lift him
03:34:21 <Amadan> and instead of... tall(John), you make it John(tall)
03:34:42 <Amadan> which changes John from e to (e->t)->t
03:34:49 <Amadan> which is lifting, no?
03:35:06 <ski> mm
03:35:28 <Amadan> this is sooooo off topic... :)
03:35:43 <ski> there's some papers that talk about how to use continuations to do these kind of things
03:35:59 <ski> (to bring it a bit more on topic)
03:36:08 <Amadan> :)
03:36:14 <ski> so we get 'linguistic side-effects'
03:36:35 <ski> hmm
03:36:39 <ski> http://www.cs.bham.ac.uk/~hxt/cw04/cw04-program.html
03:36:49 <ski> first and second paper there :)
03:37:25 <Amadan> seems interesting, first glance...
03:39:09 <ski> [[every]] = \r. shift k. forall x. r(x) => k(x)
03:39:52 <ski> where shift extract the current (delimited) continuation
03:40:12 <ski> it seem that one don't need to lift John to (e -> t) -> t  then
03:40:15 <ski> and so on
03:40:48 <Amadan> i don't understand
03:41:00 <Amadan> i'm still a functional beginner
03:41:07 <ski> well
03:41:14 <Amadan> but it appears to me that r and k are functions
03:41:26 <ski> continuations are quite heavvy to understand, i guess
03:41:44 <Amadan> and if you use this definition, you'd bind john to r
03:41:52 <Amadan> and execute john(x)
03:42:22 <ski> there's some example there
03:42:34 <ski> "Alice liked every course"
03:42:45 <ski> so i think r becomes Course, here
03:43:38 <ski> [[Alice liked every course]] =
03:44:01 <Amadan> can't
03:44:09 <ski> sorry ?
03:44:37 <shapr> I've found that translating natural lang sentences into lojban is instructive.
03:44:51 <Amadan> you have to have forall x. is_alice(x) => like(course)(x)
03:45:04 <Amadan> do tavla xu la lojban. cai
03:45:29 <shapr> .ue
03:45:33 <ski> hmm, they seem to have alice of type 'e' here, not of type 'e -> t'
03:45:38 <shapr> go'i
03:46:35 <Amadan> sorry ski
03:46:38 <Amadan> my bad
03:46:41 <ski> = alice >@ liked <@ (shift k. forall x. course(x) => k(x))
03:46:52 <Amadan> forall x. course(x) => like(x)(alice)
03:46:54 * shapr tries to use rusty lojban skills
03:47:11 <ski> = alice >@ liked <@(shift k. forall x. course(x) => k(x))
03:47:13 <shapr> dang, I can't even remember how to stick together na mutce and mi tavla la lojban
03:47:14 <ski> sorry
03:47:14 * Amadan has forgotten pretty much all his vlaste
03:47:46 <ski> = forall x. course(x) => (\v.alice >@ liked <@ v)(x)
03:47:54 <ski> = forall x. course(x) => alice >@ liked <@ x
03:48:08 <Amadan> .i do tavla piso'uda pe la lojban. 
03:48:14 <ski> it seems to evaluate something like that, i that paper
03:48:41 <shapr> mi go'i
03:48:46 <Amadan> .i le la lojban. seldju be mi na mutce
03:49:08 <Amadan> it was a long, long time ago...
03:49:28 <ski> Amadan : the interesting thing is the 'shift' capturing the "alice >@ liked <@ .." that surrounds it, taking control over it
03:51:26 <shapr> alis xaufri piroda la te cilre pluta
03:51:30 <Amadan> :) okay, i'm way over my head now, ski... i got what the continuations are, but i can't yet make a sentence using them...
03:52:32 <shapr> urf, I let an argument escape there
03:52:47 <shapr> @cmafihe .i le la lojban. seldju be mi na mutce
03:52:48 <lambdabot> .i <I> [`.'] le <LE> [the] la <LA> [ ] lojban. <CMENE> [] seldju <BRIVLA
03:52:48 <lambdabot>  [-2nd conv-help] be <BE> [ ] mi <KOhA3> [I, me] na <NA> [not] mutce <BRIVLA
03:52:48 <lambdabot>  [much] 
03:53:01 <Amadan> !!!!!
03:53:11 <shapr> lambdabot speaks some lojban ;-)
03:54:18 <shapr> hiya Alcides 
03:54:25 <Amadan> (the [(related to) named-as lojban] knowledge-of me) is not plentiful
03:54:38 <ski> Amadan : not used directly in sentences, but in giving a semantics to them
03:55:11 <Amadan> i meant, make a program either in scheme or in haskell, the two langs i learned about that use them
03:55:37 <ski> haskell has no implicit continuations
03:55:46 <Amadan> but the problem is that i've never actually tried to program in either of them, so all my knowledge is extremely theoretic
03:55:50 <ski> (though one can make a continuation monad)
03:56:21 <ski> (also SML/NJ has implicit (refifyable) continuations)
03:56:27 <ski> oh
03:56:28 <shapr> g'day clausen 
03:56:46 <ski> clausen : hi there
03:56:54 <clausen> gday
03:57:04 * clausen just finished marking :)
03:58:22 <Amadan> .i la .alis. nelci rolori tercli
03:59:21 <Amadan> yeah... as i said, i've been reading the (not so) gentle intro to monads... i couldn't understand anything past Maybe and IO...
04:00:14 <Amadan> i have to have to use them somewhere, then it'll maybe enter my brain
04:01:07 <Amadan> (oh, that's too much; this is closer: .i la .alis. nelci ro tercli)
04:01:19 <Amadan> gotta go; be back in an hour
04:01:28 <ski> have you looked at List monad ?
04:01:30 <ski> mhmm
04:01:40 <Amadan> oh yeah, that one was also pretty okay
04:02:01 <Amadan> i got lost around States...
04:02:09 <Amadan> sorry, gotta run
04:02:14 <shapr> cya :-)
04:02:49 <shapr> I got lost around the States too. Florida, Alabama, Maryland, New York, Mississippi, Tennessee...
04:04:00 <shapr> hej spenatmannen 
04:04:18 <spenatmannen> halloj!
04:04:47 <shapr> wassup?
04:05:23 <spenatmannen> nothin much... you?
04:05:54 <shapr> just bouncing
04:07:01 <spenatmannen> studsar? läckert...
04:07:51 <shapr> jag hoppar!
04:15:24 * shapr hops
04:15:28 <shapr> hOp!
04:15:38 * ski leaves
04:15:47 <ski> bye
04:41:21 <Amadan> .i mi di'a zvati
04:42:15 <Amadan> re hMPI, i've tried compiling it, but it won't go on ghc6
04:44:17 <Amadan> i'm probably going to try later with ghc5, but i haven't seen many examples of its use...
05:14:13 <shapr> Amadan: hal might update hMPI for ghc6 if you ask him
05:14:16 <shapr> or I can ask him
05:15:30 <shapr> g'day andrae
05:17:04 * shapr boings furiously
05:18:43 <bringert> eurohaskell is only a week away
05:18:57 <bringert> @eurohaskell
05:18:58 <lambdabot> less talks, more code!
05:18:58 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
05:18:58 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
05:19:08 <shapr> w00
05:19:10 <bringert> go haskell!
05:19:15 <shapr> jiihaa!
05:19:25 <shapr> oh, I thought of a plan!
05:19:35 <bringert> let's hear
05:20:26 <shapr> I figure we get together in the biggest room when it all starts, introduce people, then decide who wants to work on what, and when it's time for beer.
05:20:41 <shapr> I know, detailed plan ;-)
05:21:09 <bringert> sounds good
05:21:15 <shapr> any improvements?
05:22:02 <shapr> oh, I gotta ask phubuh if he's showing up
05:22:06 <bringert> should distribute computer and network accounts those who don't have any
05:22:11 <shapr> right, good idea
05:22:37 <bringert> I haven't got the network accounts yet, only the unix accounts
05:23:45 <shapr> oh, we may want to have WASH and HaskellDB installed
05:23:54 <bringert> add it to the wiki
05:24:05 <bringert> hsql 
05:24:09 <bringert> maybe wxhaskell
05:24:32 <shapr> right
05:24:36 <bringert> [mysql|postgre|sqlite] libs
05:24:46 <shapr> yes, one of those
05:24:52 <bringert> chucky looks like he needs something to do
05:24:57 * shapr grins
05:25:08 <bringert> he's in charge of installing stuff
05:25:16 <shapr> spiffy
05:28:38 <bringert> blob rss feed now gets the right url
05:28:45 <shapr> yay!
05:29:01 <bringert> + links to individual entries actually work now
05:51:09 <cbus> bringert: vart på chalmers ska eurohaskell hållas, nc? ;)
05:53:06 <bringert> ES63, E6209, E6211, E6213 and E6215
05:53:09 <shapr> w00
05:53:15 <shapr> wow, I thought we had three rooms?
05:53:33 <bringert> ES63 is fairly large, the others are smaller
05:54:04 <bringert> but we can hang out in other places too, won't be that many people around in june I guess
05:54:22 <bringert> cbus: ska du komma?
05:54:56 <bringert> ES63 is not all that nice, the windows are quite small
05:55:08 <bringert> there are however 16 machines in there, and a projector
05:55:11 <shapr> w00!
05:55:18 <cbus> bringert: joda det tror jag
05:55:38 <cbus> ska bara kolla sa jag inte ska jobba da
05:55:43 <bringert> the nicest place would have been the cafe, but then we'd all have to bring laptops
05:55:49 <cbus> yeah
05:55:54 <bringert> cbus: who are you irl?
05:55:55 <cbus> ill bring mine anyway i think
05:55:58 <cbus> bringert: salman
05:56:05 <bringert> ah
05:56:53 <bringert> I haven't decided if I should bring a laptop or not
05:57:00 <bringert> nice not to have to lug it around
05:57:24 <bringert> but it's easier to screw around with your own machine
05:57:33 <bringert> but not so nice when you spill beer all over it
05:58:22 <shapr> heh
05:58:43 <cbus> bringert: hehe true :)
05:58:48 <bringert> maybe someone could bring some speaker + maybe and amplifier
05:58:56 <shapr> heh
05:58:59 <bringert> speaker*s* preferrably
05:59:01 <shapr> you think we'll need it? :-)
05:59:08 <shapr> or is that for the dance party after?
05:59:10 <bringert> oh, not for talks
05:59:12 <bringert> yeah
05:59:25 <bringert> and watching south park on the projector
05:59:28 <shapr> whoa!
05:59:30 <bringert> no speakers in that room
05:59:31 <shapr> PROFIT!
05:59:39 <bringert> exaclty
05:59:42 * shapr cackles evilly
05:59:49 <bringert> exactly to be more exact
06:00:33 * shapr snickers
06:00:37 <bringert> maybe my haskell games programmer buddy can show us some demos
06:01:08 <shapr> ??
06:01:20 <shapr> one of the HaskellWars guys?
06:01:27 <bringert> no
06:01:48 <bringert> he designed a dsel for 2-d games
06:01:54 <shapr> whoa, nifty
06:02:11 <bringert> I've been trying to get him to come
06:02:30 <cbus> bringert: ska farre dit?
06:02:55 <bringert> jag har sagt till honom
06:03:00 <bringert> han har inte skrivit upp sig
06:03:03 <bringert> eh sorry
06:03:12 <bringert> I told him to come
06:03:16 <bringert> but he hasn't signed up
06:03:24 <bringert> but I think he'll show up
06:03:30 <bringert> especially if we bug him
06:03:44 <bringert> cbus: english in #haskell
06:03:49 <bringert> swedish in #haskell.se
06:03:57 <shapr> ja!
06:03:59 <shapr> um, yes!
06:04:02 <bringert> haha
06:04:09 <shapr> I'm so forvirrad!
06:06:35 <cbus> yeah sorry :)
06:06:41 <cbus> yay, more mail to read ;)
06:07:44 <cbus> yay, time to flee, a friend is graduating
06:07:51 <bringert> have fun
06:07:53 <shapr> flee!
06:07:57 <shapr> whee!
06:08:03 <bringert> don't do anything I would do
06:08:04 <cbus> bringert: thanks, have a nice day :)
06:26:56 <shapr> Spark: hey, are you related to Ward Cunningham?
06:34:13 <phubuh> hey dudes
06:34:41 <shapr> hej phubuh!
06:36:06 * phubuh looks forward to the ICFP contest tomorrow :)
06:36:34 <shapr> wow, lots of blob patches
06:36:46 <bringert> editing works now
06:36:49 <shapr> yay!
06:37:26 <phubuh> what's blob?
06:37:39 <shapr> hey, I had a crazy idea for spreading linksys WiFi router around my town to give a free IPv4 WiFi network, and a free WiFi IPv6 that charges only for packets into the internet proper
06:37:47 * vegai chuckles
06:37:53 <vegai> microsoft patented doubleclick
06:38:07 <Heffalump> does #haskell have a team, OOI?
06:38:27 <shapr> phubuh: http://shapr.homelinux.net/cgi-bin/blob/BlobHtml
06:38:31 <phubuh> due to real-life issues, I'll be participating with Common Lisp
06:38:37 <shapr> I know d3z and droundy are on a team
06:38:48 <phubuh> (the only people eligible for pair programming don't know Haskell)
06:39:00 <Heffalump> kosmikus, Igloo, Duncan Coutts and I are one too (kosmikus is in Oxford atm)
06:39:01 <phubuh> shammah: ooh, nifty
06:39:07 <bringert> shapr: just added a patch that fixes the alignment of the edit link
06:39:15 * shapr pulls that patch
06:39:25 <shapr> darcs r0xx
06:39:26 <phubuh> whence can I pull the source? :)
06:39:40 <shapr> bringert is the author :-)
06:40:04 <shapr> bringert: is it ok to give out the url to the BLob repo?
06:41:20 <bringert> sure, but just keep in mind that the code is in flux, and may eat your children
06:41:34 <phubuh> they're all still un-born, so I'll be OK :)
06:41:43 <bringert> db layout may change etc
06:42:25 <shapr> I thought about adding an extra IPv6 header that has part of a riemann something sequence (or maybe two of them mixed) and some way to resync the sender and receiver headers
06:42:56 <bringert> doesn't seem like I will have time for the icfp contest
06:42:59 <bringert> sadly
06:43:47 <shapr> Heffalump: do you think that would be a sane way to use something like the TCP sequence but for authenticated billing?
06:43:59 <Heffalump> sorry?
06:44:31 <shapr> if you want to do per-packet billing with IPv6, I figure you add a custom 'billing' header to the linked list of headers
06:44:46 <shapr> and you put in part of the sequence from that riemann thingy (highly technical term)
06:45:31 <shapr> Heffalump: if you have a moment to consider that, do you see any obvious problems with that approach?
06:46:07 <Heffalump> what does this have to do with the TCP sequence?
06:46:20 <Heffalump> it sounds like there would be too much overhead to sign each packet, though
06:46:32 <Heffalump> maybe you could make up a cookie first then put that in each packet
06:46:40 <shapr> right, so instead include a tiny unique part of an 'unguessable' sequence
06:47:13 <Heffalump> OIC
06:47:20 <shapr> and some way to resync on the sequence in case of active interference
06:47:35 <Heffalump> sounds reasonable
06:47:42 <shapr> ok, thanks :-)
06:48:35 <shapr> now I just have to wonder how to inject custom IPv6 headers with win32
07:03:33 <bringert> phubuh: there is a bit of a README for blob now
07:03:33 * SyntaxNinja dances around
07:03:35 * SyntaxNinja hakcs
07:03:37 <SyntaxNinja> hacks!
07:03:40 <shapr> w00!
07:03:46 <shapr> happy ninjas!
07:10:40 <phubuh> bringert: cool!  where do i find it? :)
07:11:02 <bringert> it's in the repo
07:11:39 <shapr> bringert: can I give out the repo url?
07:11:44 <bringert> sure
07:11:47 <shapr> ok!
07:11:51 <phubuh> whee
07:12:12 <shapr> phubuh: darcs get http://homer.vsg.sgsnet.se:8080/~bjorn/blob/
07:12:19 <phubuh> thanks!
07:14:31 <phubuh> darcs is really quick
07:14:34 <shapr> yah it is
07:14:40 <phubuh> compared to CVS at least
07:14:49 <shapr> and it'll be faster if someone adds fsh code to it
07:14:56 <phubuh> what's that?
07:15:04 <shapr> apt-cache show fsh
07:15:25 <shapr> hm, I think lambdabot needs an apt-cache search plugin
07:15:45 * phubuh googles
07:15:53 <phubuh> http://www.lysator.liu.se/fsh/ aye?
07:16:06 <shapr> yup, that's it
07:16:40 <phubuh> nifty.  does darcs use ssh at the moment?
07:16:50 <shapr> of course, most people use get/pull with http
07:16:57 <phubuh> oh, right :)
07:17:17 <shapr> but for push/get/pull via ssh, fsh would be a great improvement
07:18:48 <shapr> phubuh: hey, did you see my distributed darcs-wiki idea?
07:19:02 <phubuh> hm, nope, but it sounds intriguing
07:19:50 <shapr> if any number of people can pull patches to the same repo from each other, if you use a filesystem wiki, you don't need a server, and you get patches from only the people you want to get patches from
07:20:17 <shapr> if you use emacs-wiki I have a wikiwiki darcs repo up on ScannedInAvian.org
07:20:34 <phubuh> ooh
07:21:14 <phubuh> I'm not sure I understand
07:22:43 <shapr> I've patched BLob so that AddUserBlog and CreateTables use user shae, but everything else uses www-data so I can just throw the binaries into cgi-bin, but still use the others as me
07:22:53 <shapr> you could pull those patches from me if you wanted to
07:23:02 <shapr> right?
07:23:05 <phubuh> yup
07:23:08 <shapr> or I could pull any patches from you if I wanted to
07:23:20 <shapr> now, what if that's a wiki?
07:24:12 <phubuh> ah, so you'd put your patch on a wiki, and I'd put mine on the same one?
07:24:28 <shapr> you'd put your wiki edits into your local darcs repo
07:24:30 <bringert> shapr: where's your blob repo?
07:24:32 <shapr> then I'd pull those edits
07:25:02 <phubuh> oh!
07:25:07 <shapr> bringert: http://shapr.homelinux.net/repos/blob
07:25:15 <shapr> but I haven't recorded those patches yet :-)
07:25:21 <shapr> just a moment I'll clean them up
07:25:40 <phubuh> yeah, that's nifty!
07:27:09 <shapr> hello again kimmell 
07:27:32 <kimmell> hello
07:28:38 <shapr> have any Haskell questions?
07:37:52 <shapr> bringert: ok, recorded
07:38:22 <shapr> dunno if it's an elegant solution, but it works
07:59:47 <bringert> shapr: I'll check it later, preparing haskelldb paper for submission now :)
08:07:12 <shapr> bringert: w00!
08:07:38 <shapr> will we be able to grab it once it's submitted?
08:09:50 <bringert> how does that work? is there any restriction on online publishing of submitted papers?
09:03:05 <shapr> bringert: whatever rules your school or publisher has set up
09:03:22 <shapr> companies like Springer-Verlag have a tendency to work like Time-Warner if you let them.
09:05:34 <Heffalump> most just say you must warn people about the copyright
09:05:37 <Heffalump> (including Springer)
09:05:47 <Heffalump> they do _request_ that you not put them online immediately, but most people ignore that
09:05:57 <Heffalump> oh, _submitted_ papers
09:06:03 <Heffalump> no issue at all, you still have copyright
09:23:45 <shapr> hiya FlamingRain_ 
09:24:27 <FlamingRain> hello shapr
09:24:38 <shapr> how are ya? working on any cool code?
09:24:57 <FlamingRain> not any in haskell at the moment, sadly
09:25:04 <shapr> any other language?
09:25:22 <FlamingRain> I'm working on some stuff in C right now and designing a pseudo-language for my website generation software
09:25:54 <shapr> oh, nifty
09:26:10 <FlamingRain> i'm designing a semi-OOP type system that lets me separate style and data so I can quickly and easily update the site and effectively manage content
09:26:25 <shapr> sounds nice
09:26:37 <shapr> I want to do a system like that in Haskell
09:26:41 <shapr> but I want to use generics
09:27:48 <FlamingRain> i have almost no haskell experience, :(, I've got a book somewhere, but I'm trying to refine my C skills before I step out into another language, and I already have two others on my plate
09:29:07 <shapr> I've never had the patience to do one thing at a time :-)
09:29:35 <FlamingRain> heh
09:30:54 <shapr> anyway, my approach is to use the native structures of Haskell, but tell Haskell how to show an Integer as HTML/XML, then a String, then a list, etc
09:31:22 <shapr> and allow that view to be overridden where needed
09:31:31 <shapr> then you just write code and show the results
09:31:42 <shapr> we'll see if that actually works :-)
09:38:36 * shapr hops sporadically
10:02:32 <Hyp3rion> well does anyone know here where does cmeme put the logs? if they are available on the net? or am i wrong? is it a loggerbot? it seems it pretty much logs the whole network, but /whois doesnt give me the url, nor a google search on cmeme :-/
10:02:55 <Heffalump> I thought clog was the logger
10:03:46 <Hyp3rion> clog is the Tunes.org logger, the "cnoolb" one...
10:03:55 <Hyp3rion> cmeme is also a logger i think :-/
10:07:24 <phubuh> http://meme.b9.com/start
10:09:10 <Hyp3rion> phubuh - thank you!
10:09:11 <Hyp3rion> :-)
10:27:33 <shapr> w00! fixed the bug I've been staring at for DAYS. time to unicycle!
10:27:38 <phubuh> whee
10:44:02 <shaleh> morning
10:45:29 <shaleh> anyone here write haskell on OS X?
11:00:01 <Lunar^> shaleh: I do
11:00:42 <shaleh> Lunar^: I install GHC 6.2.1 on Panther last night.  Whenever I tried to compile a haskell program (hello world in this case) all I got was a .hi file.
11:01:14 <Lunar^> shaleh: yuk... never eard of this problem
11:01:25 <Lunar^> shaleh: ghc -v ?
11:01:30 <shaleh> Lunar^: yeah, I suspected that would be the answer (-:
11:01:45 <shaleh> Lunar^: i am not at that machine (it is my wife's laptop)
11:01:59 <shaleh> what would the -v do? turn on the verbosity?
11:02:03 <Lunar^> shaleh: yes
11:02:12 <Lunar^> shaleh: Check if it has Xcode installed
11:02:17 <shaleh> Lunar^: i will try that.
11:02:19 <Lunar^> shaleh: that could help !
11:02:34 <shaleh> Lunar^: I do not believe Xcode is installed.  I am pretty sure I did not install it.
11:05:46 <Spark> shapr: nope fraid not
11:05:57 <Spark> shapr: plenty of cunninghams about
11:06:35 <Spark> time to get 5 hours sleep
11:06:40 <Spark> then get ready for next exam
11:07:57 <shaleh> hmm, haskell-cafe is much quieter than python's tutor list.
11:09:16 <vegai> that's momentum for ya
11:09:26 <shaleh> vegai: true enough
11:09:40 <shaleh> from what I have seen on the web, Haskell is largely a .eu thing.
11:11:06 <maihem> From what I have seen, with the singular exception of one man's office in Cambridge, UK, it's largely a Swedish thing.
11:11:43 <vegai> I've thought of it as an American thing
11:12:02 <vegai> but we can be pretty sure that Haskell is confined to this planet
11:12:10 <vegai> for now
11:12:21 <Igloo> I think of it as Sweden, UK, Australia, Germany and Netherlands
11:12:34 <Igloo> Roughly speaking
11:12:42 <shaleh> like I said, .eu (-: except for the aussies
11:12:55 <maihem> No worries
11:14:16 <Igloo> Who does Haskelly stuff in America?
11:15:18 <stepcut> ??
11:15:20 <shaleh> Igloo: no web site I have seen.  I felt lonely reading the various web pages. (-:
11:15:29 * stepcut does haskelly stuff in america...
11:15:32 <shaleh> and most of the people here appear to be .eu as well
11:16:27 <vajrabum__> I'm in America although it's debateable whether I'm a "real" Haskelly typed programmner.
11:16:53 <vajrabum__> Some of the OGI people are haskelly.
11:17:16 <shaleh> well, I could not even get hello world working on my wife's laptop last night, so obviously I have a little ways to go (-:
11:39:05 <shapr> eesh
11:39:13 <shaleh> ~user@3ffe:bc0:8000:0:0:0:0:237b
11:39:14 <shaleh> nice
11:39:31 <stepcut> greetings shapr
11:39:41 <shapr> aka 3ffe:bc0:8000::237b
11:39:48 <shapr> y0 stepcut
11:39:56 <shapr> I finally made The Infinite Ride!
11:39:59 * shapr bounces tiredly
11:40:31 <stepcut> the infinite ride? on your unicycle?
11:40:35 <shapr> yup
11:40:48 <stepcut> did it take long?
11:41:03 <shapr> not really
11:41:19 <SyntaxNinja> one shouldn't assume that it was infinite in time.
11:41:23 <shapr> :-)
11:41:24 <SyntaxNinja> it could be infinite in some other attribute
11:41:24 * stepcut has no idea what The Infinite Ride is 
11:41:34 <stepcut> like coolness
11:41:45 <shapr> barring tiredness and really big holes in the road, I can stay on forever
11:42:03 <stepcut> shapr: you got one of those recumbant unicycles?
11:42:10 <shapr> nah, I want one of those next
11:42:15 <stepcut> heh
11:42:45 <stepcut> maybe you could build a hybrid unicycle-pogostick....
11:42:55 <stepcut> just jump over the big holes
11:43:33 <stepcut> how much is that pci fpga thing?
11:44:10 <shapr> which one?
11:44:25 <stepcut> the one you want?? 
11:44:29 <shapr> the 6million element chip with board, 128MB of ram, and lots of other stuff is USD $6k
11:44:32 <shapr> but I think I'll get a cheaper one
11:44:36 <stepcut> ah
11:44:49 <shapr> you gotta admit though, that's a cool idea
11:44:52 <stepcut> yeat
11:44:54 <shapr> write your own coprocessor
11:45:18 <stepcut> though, personally, I am more interested in making a hand-held scheme machine
11:52:18 <vajrabum__> Shae, are you interested in playing with something like Lava on the fpga?
11:54:37 <SamB> vajrabum__: why? do you have a pirate copy?
11:55:19 <vajrabum__> No, do you have to buy it from Xlilinx these days? I've just read the papers.
11:55:43 <vajrabum__> Or perhaps it's not for sale?
11:56:03 <vajrabum__> I did notice that Satnam Singh left Xilinx. I don't know where he went though.
11:56:07 <SamB> vajrabum__: I haven't seen any mention of any way to get it at the moment...
11:56:14 <vajrabum__> Ahhh
11:57:39 <vajrabum__> There's a version of lava that doesn't have the special stuff for generating xilinx FPGA compatible that I do have a copy of laying around somewhere.
11:57:40 <shapr> I emailed Satnam a few days ago.
11:58:05 <vajrabum__> They had promised to release the Xilinx compatible stuff a couple of years ago so I just assumed it was out there somewhere.
11:58:23 <shapr> xilinx --> http://shapr.homelinux.net/~shae/blog/2004-05-27.html
11:58:39 <vajrabum__> My wife got sick and passed away beginning a couple of years ago, so I'm just getting back to FP and Haskell after a hiatus.
11:58:59 <shapr> :-(
11:59:00 <SamB> vajrabum__: ooh, you maybe got it before they took it down?
11:59:21 <vajrabum__> They took it down?
11:59:31 <shapr> Satnam Singh said that "a freely usable copy of Lava is a coupla months out"
11:59:56 <shapr> in the email I sent him, I made it clear I wouldn't use Lava unless it was BSD/GPL/lGPL/etc
12:00:45 <shapr> Lava could be the ultimate in FFI :-)
12:01:08 <shapr> a) write your coprocessor b) call it from GHC
12:01:42 <vajrabum__> Heh, that's cool.
12:03:19 <vajrabum__> A few years ago, I had the idea of trying to write a wire speed regexp based IDS using Xilinx fpgas, but real life intruded.
12:04:06 <vajrabum__> So it would work kind of like a virus checker but you'd be downloading your weekly netlist with the intrusion signatures.
12:06:44 <vajrabum__> It's also cool that they're going to release that stuff. I know Xilinx has something based on java that is similar in concept, but lava looks way cooler.
12:12:05 <shapr> I've had fever dreams of a self-rewriting CPU
12:13:32 <shapr> something like "I have six million elements, I only need half that for a single CPU of my current design, if the system is busy, use the other half for another CPU, if not, try to build a smaller/faster/better version of myself in the other half"
12:14:54 <SamB> shapr: that would probably work better with room for more than two
12:15:02 <vajrabum__> Just remember that unlike certain netlists can fry your fpga which is part of the reason why Xilinx want's you to use their tool chain.
12:15:36 <vajrabum__> So you can't use random evolution or at least you'd have to constrain it rather tightly and carefully.
12:15:55 <shapr> does Xilinx tell you which lists will fry your fpga?
12:15:59 <SamB> vajrabum__: that does sound nasty
12:16:25 <vajrabum__> No, that connects to the other part of the reason that they want you to use their tool chain--vendor lock in.
12:16:29 <shapr> I don't want to use any software written by Xilinx unless it's BSD/GPL/lGPL or other DFSG compatible
12:16:35 <shapr> bzzt, thank you for playing.
12:17:23 <shapr> @index xilinx
12:17:23 <lambdabot> bzzt
12:17:34 <vajrabum__> To be fair to Xilinx they live in a pressure cooker world with thin margins and tough competition.
12:17:52 <SamB> why don't they try to be as nice as possible, instead?
12:17:54 <shapr> usd $6k is a thin margin?
12:18:09 <vajrabum__> That sort of information also could/would reveal design features that could be copied by the competition.
12:18:22 <SamB> they could have a monopoly on niceness with fpgas
12:18:25 <vajrabum__> Remember they aren't selling many of those yet.
12:18:29 <shapr> well, if Lava works with their hardware, I'm happy.
12:18:36 <shapr> and I'll buy it.
12:18:43 <SamB> or fpgas with niceness, whichever way you like it
12:18:51 <shapr> hopefully Nvidia and ATI et al will figure that out too
12:19:13 <shapr> I promise 'pon my honor that I will never again buy a gfx card that does not have a fully open source driver
12:19:28 <vajrabum__> I'm quite sure lava works by generating vhdl which gets compiled using their tools.
12:19:45 <shapr> not because I'm a fanatic, just because I tend to have non-standard configurations that don't WORK with closed source drivers.
12:20:10 <shapr> and I can FIX an open source driver.
12:20:34 <shapr> I fixed the Linux kernel to talk to my IDE chipset when I first got this Athlon MP mobo
12:20:54 <vajrabum__> You shouldn't have problems figuring out the drivers because of lack of information. 
12:21:13 <vajrabum__> It's just PCI, so it's kind of raw.
12:21:41 <vajrabum__> You will probably have to use their PCI interface code for the fpga itself though.
12:21:51 <shapr>  :-(
12:22:01 <shapr> I want 100% DFSG from end to end
12:22:07 <vajrabum__> DFSG?
12:22:18 <shapr> http://www.debian.org/social_contract
12:22:26 <vajrabum__> Gotcha
12:22:53 <SamB> vajrabum__: your athlon isn't DFSG/OSI compliant
12:23:03 <shapr> my athlon?
12:23:41 <shapr> what's not DFSG about the athlon?
12:23:42 <vajrabum__> There is opencores.org, but I don't think their stuff is very high quality and I/O bits are usually proprietary in one way or another.
12:24:01 <shapr> vajrabum__: so let's write something better with Lava!
12:24:12 <vajrabum__> SamB, that's true. I am using mozilla for irc then.
12:24:34 <vajrabum__> how do I change my nick here?
12:24:39 <shapr> use /nick foo
12:24:54 <vajrabum__> And how do I register it? Or should I?
12:25:05 <shapr> yah, If you don't want someone to use it instead of you
12:25:12 <SamB> er. s/vajrabum/shapr/ (wonders how he messed that one up. s isn't near v!)
12:25:15 <shapr> plus channel privileges are nickserv based
12:26:22 <vajrabum> I'm all sorts of dolt. Today I'm an irc dolt. Where do I rtfm re the nickserve?
12:26:43 <shapr> use /msg nickserv help
12:26:50 <shapr> there's also chanserv seenserv statserv
12:26:55 <shapr> and probably some more I haven't run across yet
12:26:57 <vajrabum> Grazia :)
12:27:07 <shapr> we all start at the beginning :-)
12:28:01 <cgibbard> Why is earthy in op-mode? :)
12:28:07 <shapr> I guess he's cool
12:28:12 * shapr grins
12:29:28 <shapr> I want dark to come back :-(
12:30:59 <shapr> time to be social
12:31:03 * shapr disappears
13:05:47 * esap blinks.
13:23:32 <Lor> Less than 20 hours until the contest begins... everyone prepared?
13:24:14 <Lemmih> Contest?
13:24:35 <Lor> icfpcontest.org
13:24:58 <Lemmih> oh
13:29:23 <Igloo> Well, as of earlier today we achieved the same number of working computers as people. Tomorrow we're hoping to be able to plug them all into power sockets and hub ports simultaneously too. So yeah, we're really on top of it  :-)
13:34:26 <Lor> Hm, am I confused, or is DiffArray broken?
13:34:49 <Lor> It shouldn't be distinguishable from an ordinary array in any way except in performance characteristics, right?
13:40:48 <Lor> It gives me "Fail: thread blocked indefinitely" in a single-threaded program.
13:40:49 <Lor> Hum.
13:41:15 <Lor> This is the 6.2.1 debian package.
14:01:32 * TheHunter wanders what ghci dislikes about sum [1..1000000]
14:02:48 <TheHunter> s/a/o
14:03:19 <Riastradh> Well, what does it claim to dislike?
14:03:22 <maihem> ? TheHunter wanders whot ghci dislikes about sum [1..1000000]?
14:03:37 <anduril1> *** Exception: stack overflow ?
14:03:40 <TheHunter> it eats up all the stack
14:07:55 <Lor> It's as if sum was written using foldr, which it isn't.
14:07:59 <TheHunter> maihem: wander = walk, wonder = ask oneself
14:08:20 <maihem> oh, wrong 'a', sorry :)
14:08:30 <Riastradh> How is sum defined in GHC?
14:08:47 <TheHunter> it's defined by recursion
14:09:05 <Riastradh> Tail recursion?
14:09:13 <anduril1> I thought it used foldl'
14:09:29 <TheHunter> it seems ghc without optimization flags doesn't eliminate tail recursion
14:10:05 <TheHunter> anduril1, that's hugs
14:10:12 <anduril1> ah
14:11:55 <Riastradh> ?!?!?
14:12:06 <Riastradh> No TCO without special flags!!!?!?
14:14:00 <Lor> Now let's not jump into conclusions.
14:14:26 <Lor> At least let a () = a() in a () doesn't blow the stack.
14:14:54 <maihem> this has the same problem: let {mysumiter tot a (bh:bt) = mysumiter (tot + a) bh bt; mysumiter tot a [] = tot + a}; let {mysum2 (a:b) = mysumiter 0 a b; mysum2 [] = 0}
14:15:06 <maihem> I thought that would be okay, I'm crap
14:16:01 <maihem> it overflows even sooner :(
14:16:31 <Lor> Uh, isn't that a bit complex?
14:16:38 <maihem> yep :)
14:16:49 <Lor> Why do you store the head separately?
14:17:00 <anduril1> he was trying to confuse GHC into working correctly
14:17:52 <Lor> I can understand why that would blow the _heap_, but the stack I don't get.
14:21:18 <maihem> how do you force eager evaluation of something?
14:21:26 <Riastradh> !
14:21:32 <Riastradh> Er, no, seq.
14:21:42 <Riastradh> ! in types, $! for eager application.
14:22:06 <Lor> A strict parameter annotation would be nifty.
14:23:05 <Grind> hi everyone
14:24:48 <Grind> I'm doing some stuff and I need to pass around a certain environment...
14:25:05 <Riastradh> Can you be a bit more vague?
14:25:08 <Grind> which sometimes needs to be updated
14:25:12 <Grind> I thought I'd use a state monad
14:25:40 <SyntaxNinja> Riastradh: behave ;)
14:25:45 <Grind> Riastradh: not now, since I already typed this lines... but I could have stopped before yes :P
14:25:48 <SyntaxNinja> Grind: sounds reasonable, at first glance
14:25:55 <Grind> ok 
14:26:02 <Grind> now the important bit
14:26:18 <Grind> that environment is of type   Maybe Sometype
14:26:36 <Grind> and right now, I am passing it around as a parameter
14:26:52 <Grind> and as soon as I get a Nothing my computation stops
14:27:02 <Grind> I know I could do what I just said
14:27:20 <Grind> use a State Monad with the that Maybe Sometype as the state
14:27:33 <Grind> but is there some specific monad that combines both?
14:27:43 <Grind> handling the state, and failure
14:27:59 <Riastradh> No.  That's what monad transformers are for.
14:29:02 <Grind> I've seen monad transformers before, but it seemed overkill in this case. Of course it might just be me not knowing enough about them
14:30:49 <Riastradh> Why overkill?
14:32:56 <Grind> I don't have a great answer for that... when I played with Monad Transformers seemed to me that:
14:33:27 <Grind> it would be useful when you'd want, in certain situations end up combining one or more monads for specific purposes...
14:33:36 <Grind> but that if you were always going to use them together
14:33:52 <Grind> then it would be better to just make a monad that combined them both
14:34:45 <Grind> I also find the code pretty complicated sometimes, when the goal was pretty simple
14:35:16 <Grind> but I'm not claiming that is indeed the case
14:35:30 <Grind> since I didn't spend that much time using them
14:35:40 <Grind> I'll just read more about them now and find out
14:35:55 <Grind> let me google them
14:42:24 <shapr> jiihaa
14:42:29 <shapr> excitement!
14:43:14 <Grind> Riastradh: hmm from what I've read seems like you're right...
14:43:15 <Lor> What's the most concise programming language? Perl? K?
14:43:40 <Grind> Riastradh: now I'm trying to understand whether I need a ErrorT on a State monad or a StateT on an error monad
14:44:30 <shapr> Lor: maybe joy?
14:45:04 <Grind> Riastradh: my guess is the 1st
14:46:53 <mattam> APL
14:47:04 <Grind> ok so let me see if I got this right
14:47:28 <Grind> if I'm maintaining a state, and I may want to stop the computation in case of some error
14:47:42 <Grind> I should use the error as the outer monad, that is the transformer
14:47:44 <Lor> APL is non-ascii, it doesn't quite compare..
14:48:00 <shapr> though Haskell with unicode operators would be spiffy
14:48:02 <Grind> so I can lift that I can lift the fail
14:48:06 <Grind> and stop instantly
14:48:08 <Lor> Is there any ascii-based _and_ free array processing language?
14:48:19 <mattam> :)
14:48:23 <Grind> right?
14:48:25 <Lor> There's aplusplus, which seems to use all kinds of weird symbols, and there's j and k, which aren't free.
14:48:55 <shapr> yah, that's why I never bothered to learn j and k
14:49:17 <shapr> there's also the parr extensions for GHC, though that's specifically for data parallelism
14:49:23 <mattam> Grind: i think so
14:49:24 <shapr> parr == parallel array
14:49:38 <Grind> thanks matt
14:49:42 <Grind> thanks mattam
14:50:06 <mattam> matt fits well too actualy
14:50:53 <Lor> That thingie by Manuel Chakravarty? Is there an implementation somewhere?
14:50:54 <Grind> :)
14:51:23 <Grind> is he still developing it?
14:51:45 <Grind> it sure would be nice to have some fast arrays in haskell
14:51:58 <Grind> (besides the ST/IO ones)
14:52:27 <Lor> What's used for arrays in joy?
14:52:40 <shapr> nothing I think
14:52:41 <shapr> sadly
14:52:52 <Lor> Gah. No ciphersaber, then.
14:53:18 <shapr> Joy could be great with a few more everyday features
14:53:27 <Lunar^> shapr: We made some progress on the release today
14:53:30 <shapr> yay!
14:53:37 <stepcut> yay!
14:53:45 <shapr> Lunar^: what sort of progress?
14:53:50 <Lunar^> shapr: We'll make an EuroHaskell release _in anyway_
14:53:56 <shapr> I haven't even looked at the NE2K spec yet
14:54:10 <shapr> though I did read through the CMOS, Keyboard, and PS2 drivers
14:54:27 <shapr> I couldn't figure out where you defined the date command!
14:54:29 <Lunar^> shapr: We found why he wasn't able to boot hOp when he build on Gentoo
14:54:33 <shapr> oh, why?
14:54:51 <Lunar^> shapr: -march=pentium3 -> bochs compiled without --enable-cpu-level=6
14:55:07 <shapr> what's that do?
14:55:07 <Lunar^> shapr: 'cmove' assembly instruction
14:55:26 * shapr is lost
14:55:30 <shapr> sounds interesting :-)
14:55:36 <Grind> thanks kimmell
14:55:39 <Lunar^> shapr: The first is an optimisation flag for GCC, the second makes bochs able to understand newer x86 extensions
14:55:48 <shapr> ah
14:55:56 <shapr> I know the march stuff, I use it with athlonmp
14:56:02 <shapr> but cpu-level, no
14:56:12 <shapr> nor do I know why cmove is useful/necessary
14:56:14 <Lunar^> shapr: He found why the hardware cursor wasn't working (Word8 instead of Word16 for IO port adress)
14:56:22 <Lunar^> shapr: Then we mostly worked on the README
14:56:24 <shapr> ohh
14:56:33 <shapr> so it has 'gpm' now?
14:56:43 <shapr> or whatever the console mode mouse driver thingy is...
14:57:22 <Lunar^> shapr: mhh no it's just the cursor for inserting text
14:57:28 <shapr> ah, ok
14:57:43 <Lunar^> shapr: hardware cursor was not working so I finally made a softcursor as a workaround
14:58:15 <shapr> I see
14:58:39 <Lunar^> shapr: I looked on memtest86 source code to understand how to know the memory size on x86 architecture
14:58:48 <Lunar^> It's just awfull !
14:59:03 <Lunar^> That damn BIOS give the data in 'ax' register which is 16 bits
14:59:20 * shapr grins
14:59:50 <shapr> I won't even ask about support for the v1.4 Intel MultiProcessor Spec ;-)
15:00:29 <Lunar^> Unfortunately, x86 arch is changing these days
15:00:41 <shapr> for the better in many ways
15:00:59 <shapr> NUMA is spiffy
15:01:10 <Lunar^> instruction set extensions, ACPI (this is a BIG change), new BIOS system
15:01:21 <Lunar^> Intel announced open source for the last one \o/
15:01:39 <shapr> yay
15:02:02 <shapr> they should be scared of LinuxBIOS
15:02:19 <Riastradh> Why don't people just use a processor that doesn't suck to begin with?
15:02:27 <Lunar^> Riastradh: emulators
15:02:36 <Riastradh> Emulators?
15:02:41 <shaleh> Riastradh: cost
15:02:41 <Riastradh> What about emulators?
15:02:42 <Lunar^> Riastradh: I would be really happy to use PowerPC
15:02:54 <Lukhas> or sparc
15:03:06 <Lunar^> Riastradh: unfortunately, there is no good emulator for PowerPC, hence it's difficult to write an OS for
15:03:25 <Riastradh> shaleh, it's less expensive to keep ugrading rapidly changing x86 products?
15:03:58 <shapr> I wish Alpha hadn't diead
15:04:00 <shaleh> Riastradh: who is upgrading? i just retired my PII after 5+ years of service
15:04:03 <shapr> Alpha had a great future
15:04:23 <shaleh> shapr: not if you lived in warm climates.  we do not need heaters
15:04:33 <Riastradh> shaleh, um, except that what we're discussing right now is upgrades in the x86 architecture.
15:04:45 <shapr> shaleh: heat is a problem for any CPU arch
15:05:09 <shapr> anyway, I'm aiming for at least a dual Opteron next, and maybe a quad if I'm lucky
15:05:12 <shaleh> shapr: the alpha was one of the worst.  itanium is trying to take that role now
15:05:51 <shaleh> Riastradh: right, tech moves forward.  we went from the 603 to the 604 to the G3 to the G 4 to the G 5
15:05:54 <shaleh> things go on
15:06:30 <Lunar^> Riastradh: PPC arch. has gone though major changes these last years
15:06:43 <Lunar^> Riastradh: the PCI switch is one example
15:06:51 <shapr> no more NuBus!
15:10:10 <shapr> clockless logic is the way to go
15:10:27 <shapr> and reversible logic
15:11:02 <shapr> on the downside, it's more complicated
15:27:28 <Grind> can I define types in ghci?
15:27:54 <monotonom> No.
15:28:32 <Grind> :-/
15:28:34 <Grind> thanks monotonom
15:28:39 <shapr> I like to use haskell-mode and C-c C-l
15:33:41 <Lor> Suppose there's a total finite map Word8 -> Word8 with three lookups per a (two-entry) update. Is it faster to use an Array or a FiniteMap?
15:35:00 <Lor> That is, is an array update slower than three lookups and two updates in a tree?
15:37:42 <Lor> Hm, is DData getting incorporated into the standard libraries anytime soon?
15:37:47 <shapr> I think so
15:37:58 <shapr> big smoke on the libraries list about that
15:39:40 <Lor> And is DiffArray broken for anyone else besides me?
15:39:47 * shapr hasn't tried it
15:39:57 <shapr> they're very responsive on the list
15:40:21 <Lunar^> shapr: btw, I had a blasphemish idea today
15:40:25 <shapr> what's that?
15:40:43 * Lunar^ is going to look for a proper translation
15:40:52 <shapr> what's the idea?
15:41:18 <Lunar^> blasphemish seems ok
15:41:33 <Lunar^> By using foreign export, we could make hOp Posix compatible
15:41:41 * shapr blinks
15:41:48 <shapr> er
15:42:14 <shapr> are you saying write Posix functionality in Haskell and export it via the FFI, so that C sources link to the hOp implementation?
15:42:29 <Lunar^> yes... I said this was a blasphemy
15:42:33 <shapr> I think it's very cool
15:42:39 <Lunar^> I had to punish myself after ;)
15:42:41 <shapr> haha
15:43:05 <shapr> it's great, it means that with sufficient insanity on the implementors part, you could totally replace the Linux kernel with hOp
15:43:34 <Lunar^> That's crazy :)
15:43:44 <shapr> it might be interesting actually
15:44:57 <shapr> for one thing, it means you can export any ABI you want, right?
15:45:17 <shapr> hm, sort of
15:46:19 <Lor> I also wonder why there's no standard array construction function of the type (i,i) -> (i -> e) -> a i e
15:47:07 <shapr> isn't there?
15:48:07 <Lor> Not that I can see.
15:48:47 <Lor> An array is really just an optimized memoizer for a finite map with an enumerable domain.
15:49:25 <shapr> that makes sense
15:55:21 <Lor> tst :: DiffArray Int Int
15:55:21 <Lor> tst = scanl f (listArray (0,99) [0,7..]) [0..] !! 300
15:55:21 <Lor>     where f a i = a // [((a ! (i `mod` 100)) `mod` 100, i)]
15:55:47 <Lor> That gets stuck in ghci, and when compiled with ghc it says "thread blocked indefinitely"
15:56:24 <Lor> Apparently it gets into an internal deadlock while trying to read and write the representation at the same time.
15:56:46 <vajrabum> I think the idea of HoP as a drop replacement for the Linux kernel is interesting. Nobody is ever going to prove any security properties of Linux.
15:56:52 <vajrabum> Err, drop = drop in
15:57:15 <shaleh> HoP?
15:57:25 <Grind> are there any thumb rules to decide when to use State, and when to use ST?
15:57:44 <Grind> (for instance ST + Implicit Parameters...)
15:57:54 <vajrabum> Err, hOp =- HoP
15:58:05 <Lor> What's the right list for library bug reports? The library list?
16:03:52 <Lunar^> Grind: I think that's a matter of personal preferences... implicit parameters are less portable accross Haskell implentations
16:04:38 <Lunar^> vajrabum: hOp has no concept of security currently
16:08:00 <Lor> Could someone else try out that test snippet of mine to confirm that the bug is not only in my setup?
16:10:35 <Lunar^> Lor: why not?
16:11:30 <Grind> Lunar^: I see...
16:11:48 <Grind> Lunar^: Seems to me like using ST may make things more efficient...
16:12:19 <Grind> Lunar^: on the other hand sometimes ST + Implicit Pars seems a little hasckish :-/
16:13:55 <Lor> This is probably minimal:
16:14:03 <Lor> main = print (a // [((a ! 0, 0))])
16:14:03 <Lor>     where a :: DiffArray Int Int
16:14:03 <Lor> 	  a = array (0,0) [(0,0)]
16:15:41 <Lunar^> Grind: It's personal taste, but I don't like the implicit parameters syntax
16:17:48 <Lunar^> Lor: GHCi prints 'array' then stall
16:21:19 <Lor> Yep.
16:22:49 <Lunar^> Lor: seems related to DiffArray
16:23:11 <Lunar^> Lor: more specifically accessing a cell while changing it
16:26:27 <Lor> Yep. It just locks the thing too early.
16:26:31 <Lunar^>     do let a = array (0,0) [(0,0)]
16:26:31 <Lunar^>        b <- return $! a!0
16:26:32 <Lunar^>        print (a // [(b, 1)] :: DiffArray Int Int)
16:26:33 <Lunar^> This wokrs
16:26:41 <Lor> It should be strict in the indices of //
16:27:03 <Lor> Well, it is, of course, but it should evaluate them all _before_ getting the lock.
16:27:39 <Lor> Is the library list the right place for library bugs?
16:30:23 <Lunar^> Lor: sure
16:30:31 <Lunar^> Lor: Or maybe glasgow-haskell-users
16:30:47 <Lunar^> Lor: Is DiffArray specific to GHC ?
16:31:21 <Lunar^> Lor: Is this bug really a DiffArray bug ?
16:31:30 <Lor> The docs say "portability non-portable" "maintainer libraries@haskell.org"
16:31:34 <Lor> Yes, really.
16:31:48 <Lor> I'm working on a patch already.
16:31:57 <Lunar^> Lor: The code is really complicated, can't find where is the exact cause
16:32:10 <Lor> It's in replaceDiffArray
16:32:14 <Lunar^> thanks
16:32:23 <Lor> it does the takeMvar _before_ evaluating ies
16:33:00 <Lor> And if evaluating ies means calling readDiffArray, the readMVar causes the deadlock.
16:33:16 <Lunar^> Lor: understood
16:33:30 <shaleh> main = do line <- getLine
16:33:30 <shaleh>           sequence_ (map putStr [line, "\n"])
16:33:37 <shaleh> I am just playing with input and output
16:33:39 <Lunar^> Lor: why doesn't GHCi detects the deadlock... strange
16:33:44 <shaleh> is there a better way to write the above?
16:33:52 <Lunar^> Lor: is completely single threaded deadlock ...
16:34:01 <Lor> ghc does.
16:34:10 <Lor> Apparently ghci uses a different runtime.
16:34:18 <Lunar^> shaleh: There's putStrLn...
16:34:50 <Lunar^> Lor: Discovered another strangeness of GHC... when would it stop ? ;)
16:34:54 <shaleh> Lunar^: assume that I may want to prepend or append something other than '\n'
16:35:32 <Lor> Yick. This is ugly.
16:35:43 <Lunar^> shaleh: in your case, you can use mapM_ instead of sequence_ . map
16:36:00 <Lunar^> @type mapM_
16:36:01 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
16:36:14 <Lunar^> @type sequence_ . map
16:36:15 <lambdabot> bzzt
16:36:23 <Lunar^> @type (sequence_ . map)
16:36:24 <lambdabot> bzzt
16:36:26 <Lunar^> :(
16:36:44 <shaleh> Lunar^: but the general idea is correct, yes?
16:38:20 <Lunar^> shaleh: I think so :)
16:40:25 <Lunar^> :t (sequence_ .) . map
16:40:33 <Lunar^> @type (sequence_ .) . map
16:40:35 <lambdabot> (sequence_ .) . map :: forall m a a1.
16:40:35 <lambdabot> 		       (Monad m) =>
16:40:35 <lambdabot> 		       (a1 -> m a) -> [a1] -> m ()
16:40:38 <Lunar^> gotcha :p
16:40:53 <Lunar^> That damn double compose trick
16:56:00 <Lor> Hm, how do I compile source files with preprocessor directives in them?
16:56:57 <shapr> -fpgm or something like that
16:57:50 <shapr> ghc -F -pgmF preproc infile
16:57:55 <shapr> g'day Pseudonym 
16:58:00 <Pseudonym> G'day.
16:58:16 <shapr> Lor: for example, check out HaRP - http://www.dtek.chalmers.se/~d00nibro/harp/
16:58:23 <Lunar^> Lor: fptools is really fragile...
16:58:37 <Lunar^> shapr: http://suivez.mon.regard.free.fr/photos/Blog/paris_carnet011/PC_011_021.jpg
16:58:53 <shapr> whoa nifty!
16:59:10 <shapr> http://shapr.homelinux.net/~shae/blog/images/kanin.jpg
16:59:13 * shapr snickers
16:59:59 <shapr> Lunar^: nice impressionistic style of photography
17:00:15 <shapr> I like the near-picasso look of the woman on the right
17:00:32 <shapr> that photo has nifty composition
17:01:33 <shaleh> shapr: true, it is a nice photo
17:01:40 <Lor> Ha, it was simply -cpp.
17:01:55 <shapr> that rabbit on the other hand...
17:02:19 <shapr> the rabbit says "I have no idea what you're talking about. Here's a rabbit with a pancake on its head."
17:02:41 <Pseudonym> My wife says post-impressionistic.
17:02:47 <shapr> oh, sorry
17:02:48 <Pseudonym> She's a fine art major, so she should know.
17:03:00 <shapr> well, I like it :-)
17:03:07 <shapr> what does she say about the rabbit? ;-)
17:03:08 <Pseudonym> Oh, she does too, and she's an expert.
17:03:48 <Lunar^> shapr: funny picture
17:03:57 <shapr> definitely bizarre 
17:04:30 <Pseudonym> If only the guy in the middle was drinking absinthe instead of beer, it could easily be a Lautrec painting.
17:04:45 <shapr> I'm relatively certain that guy in the middle is Lunar^ 
17:05:26 <Pseudonym> http://www.ibiblio.org/wm/paint/auth/degas/absinthe/degas.absinthe-2.jpg
17:05:28 <shapr> since I'm from alabama, I usually drink beer from the container.
17:05:35 <Lor> Is there an easy way to seq all the elements in a list?
17:05:43 <Lor> Easier than foldl, that is.
17:06:49 <shapr> map ($!) ?
17:06:53 <shapr> use DeepSeq ?
17:07:15 <Riastradh> Lor, uh, what's not easy about foldl?
17:07:57 <Lor> It requires me to write a lambda. :)
17:08:19 <Riastradh> Does it, now?
17:08:32 <Riastradh> @type foldl seq
17:08:34 <lambdabot> foldl seq :: forall b. b -> [b] -> b
17:08:46 <Riastradh> @type foldl' seq
17:08:47 <lambdabot> bzzt
17:08:54 <Riastradh> @type foldr' seq
17:08:55 <lambdabot> bzzt
17:08:58 <Riastradh> @type foldr seq
17:08:59 <lambdabot> foldr seq :: forall a b. b -> [a] -> b
17:09:05 <Riastradh> There.
17:09:11 <Riastradh> @type foldr seq ()
17:09:13 <lambdabot> foldr seq () :: forall a. [a] -> ()
17:09:55 <Lor> Yes, right.
17:13:09 <Lunar^> @type seq
17:13:10 <lambdabot> seq :: forall b a. a -> b -> b
17:13:38 <Lunar^> Pseudonym: right, it's me
17:13:47 <Lor> Actually, I decided just to use sum. :)
17:14:24 <Lunar^> Lor: Are you trying to correct the DiffArray bug by making every position argument strict ?
17:15:08 <Lor> Yeah.
17:15:13 <Lor> a `replaceDiffArray` ies = sum (map fst ies) `seq` do
17:15:17 <Lor> That's the only changed line.
17:16:29 <Lunar^> Lor: Doesn't it change the meaning of (//) ?
17:17:29 <Lor> I don't see how.
17:17:51 <Lunar^> I'm asking myself...  I can't see any reason either
17:17:56 <Lor> The operation is strict in the indices anyway.
17:18:41 <Lunar^> All indices are evaluated at some point... and can throw an exception if not in bounds
17:18:59 <Lunar^> Wouldn't it be better to force evaluation by making this check ahead instead of a 'sum' ?
17:19:45 <Lor> It's done already.
17:20:06 <Lor> the "ies" is a [(Int,e)] where the ints are gotten by calling "index" on the ix elements.
17:20:19 <Lor> So when I force the ints I also force the checks.
17:20:30 <Lor> DiffArray seems to work now, DiffUArray still gets stuck. Hm.
17:22:51 <Lunar^> shapr: I really like your new blog :)
17:24:02 <shapr> which one?
17:24:21 <shapr> I'm soon to move from PLog to BLob
17:24:22 <Lor> Argh. DiffUArray is strict on the elements, too.
17:24:45 <Lor> So now it'd need to also force the elements but _only_ if the underlying imperative array is unboxed.
17:24:58 <Pseudonym> I'm trying to find a citation for Cooper's Law.
17:24:59 <Lunar^> shapr: I'm talking about content :)
17:25:15 <shapr> ah, thanks :-)
17:25:15 <Pseudonym> "If you do not understand a particular word in a piece of technical writing, ignore it. The piece will make perfect sense without it."
17:25:27 <Pseudonym> Anyone know where that came from?
17:25:30 <shapr> Lunar^: any content suggestions?
17:25:39 <shapr> Pseudonym: every boss who ever wanted to get moving towards a deadline?
17:25:41 <Lunar^> Lor: more class/instance tricks ?
17:26:00 <Pseudonym> Very possibly.
17:26:07 <shaleh> how do I cause the program to exit?
17:26:14 <shapr> hammer!
17:26:25 <shapr> pull the plug?
17:26:32 <shapr> um, wiggle stuff inside the case?
17:26:38 <Lunar^> shaleh: In which case ? nice exit or error ?
17:26:40 <shaleh> ie. what is the equiv to C's exit(0)
17:26:43 <shapr> ohh
17:26:49 <Lunar^> shapr: look at System.Exit module
17:26:52 <Lunar^> oops
17:27:04 <shapr> shaleh: you use emacs?
17:27:11 <Lunar^> I'm used to type 'sh'<tab> grrr
17:27:13 <shaleh> I am working on a simple talk back server to learn haskell
17:27:15 <shapr> heh
17:27:27 <Lunar^> shaleh: Look at System.Exit module
17:27:30 <shapr> System.exitWith ()
17:27:34 <shaleh> I am working on "listen for text, emit text" if text is nothing, exit
17:27:42 <shapr> here's semi-useful demo code: http://www.haskell.org/hawiki/HaskellMode
17:27:49 <shaleh> shapr: yeah. I use emacs
17:28:02 <shapr> then you may really like that code
17:28:11 <shaleh> shapr: thanks, will look.
17:28:15 <shapr> hey, Jef Raskin will be at EuroPython!
17:28:22 <shaleh> I definitely want 'include standard Main stanza'
17:28:24 <shapr> I've been reading his Humane Interface stuff for years!
17:28:50 <Lunar^> shapr: I would be glad to learn about how did you set up your current geek life: e.g. paid work / Haskell community involvement
17:28:59 <shaleh> do I have to import System or is that standard prelude stuff?
17:28:59 <shapr> oh, ok
17:29:10 <shapr> you gotta import System
17:29:25 <Lunar^> shaleh: import System.Exit, then use 'exitWith ExitSuccess'
17:30:09 <Lunar^> shaleh: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Exit.html
17:30:26 <shaleh> thanks
17:30:29 <shapr> I need more funny pix for blog entry inspiration.
17:32:29 <Lunar^> shapr: print.squat.net/move.html
17:32:38 <Lunar^> shapr: The dead screen picture
17:33:21 <shapr> hm, interesting
17:33:34 <Lunar^> shapr: It was the first demo against the LEN in France
17:33:46 <Lunar^> shapr: (one of the reason for last sat. demo)
17:34:27 <Lunar^> shapr: pRiNT means Pour la Réappropriation d'Internet et des Nouvelles Technologies
17:34:33 <shapr> cute
17:34:42 <shapr> the crypto laws in france scare me
17:34:53 <Lunar^> shapr: Which could be translated as 'for getting back Internet and new technologies'
17:35:18 <shapr> repossession
17:35:43 <Lunar^> shapr: It really is an hacklab, so they skip (or are given) a lot of old computer screens
17:36:00 <Lunar^> shapr: Some of them where sacrified for this demo :)
17:36:22 <shapr> I can see. It looks like fun.
17:37:04 <shapr> greetings paganini_ 
17:37:12 <shapr> where's BCT?
17:37:24 <shapr> somewhere in Mississippi?
17:37:26 <paganini_> how you doing?
17:37:47 <shapr> I am doing fine! tomorrow I fly south for a week of geek socialization.
17:37:52 <shapr> how are you?
17:37:59 <paganini_> good
17:38:55 <paganini_> trying to get back on my project
17:39:13 <shapr> next week I get to meet Lunar^, bringert, Lor (?), cbus, phubuh, tic, spenatmannen, Spark (?), ludde (?), polli (?), and more.
17:39:32 <Lunar^> That well be so great !
17:39:44 <shapr> Lor: coming to EuroHaskell?
17:39:50 <shapr> yah, it'll be fun
17:39:58 <Lor> Still not sure.
17:40:00 <shapr> ok
17:41:05 <shapr> Lor: you have my number? I figure any non-chalmerites coming to EuroHaskell should have either my number or bringert's, so we can hook up when the thang happens.
17:41:42 <shapr> paganini_: is there any public info on Rete II ?
17:41:51 <shapr> is that what you're using?
17:42:04 <phubuh> yay
17:42:14 <shapr> phubuh: man, you should be sleeping ;-)
17:42:21 <shapr> phubuh: hey, did you see my kanin pic?
17:42:41 <shapr> I have to wonder, is that standard swedish humor?
17:42:41 <phubuh> i definitely should
17:42:42 <paganini_> not rete II
17:42:50 <paganini_> just rete
17:42:51 <phubuh> graduation tomorrow at eight thirty, bah
17:43:01 <paganini_> never heard of rete II
17:43:23 <shaleh> ok, still stuck
17:43:28 <shapr> paganini_: http://en.wikipedia.org/wiki/Charles_Forgy
17:43:28 * phubuh sleeps
17:43:49 <Lor> shapr, I don't think so.
17:44:17 <shaleh> I have a function called 'handler', it takes the String line as input.  If line is empty, I want to exit, otherwise I want to print the line.  Of course, System.exitWith is not type IO, so this is not happy currently
17:44:39 <Lunar^> @type System.Exit.exitWith
17:44:40 <paganini_> yes, that's the base of what I am doing
17:44:41 <lambdabot> System.Exit.exitWith :: forall a. GHC.IOBase.ExitCode -> IO a
17:44:51 <paganini_> but I am doing something more
17:45:14 <paganini_> my implementation is multithreaded safe
17:45:16 <Lunar^> shaleh: exitWith is an IO function. The 'a' in the type means that you can use it anywhere
17:45:34 <paganini_> allowing concurrency in the network
17:45:36 <shaleh> handler :: String -> IO
17:45:36 <shaleh> handler ""   = System.exitWith ExitSuccess
17:45:36 <shaleh> handler line = mapM_ putStr ["Heard: ", line, "\n"]
17:45:49 <Lunar^> @type System.exitWith
17:45:51 <lambdabot> System.exitWith :: forall a. GHC.IOBase.ExitCode -> IO a
17:45:51 <shapr> paganini_: sounds nifty!
17:46:00 <paganini_> it is fun
17:46:17 <paganini_> I am using a simple algorithm from Tanenbaum to prevent deadlocks
17:46:25 <Lunar^> That last one was defined before the hierarchical library I think
17:46:46 <Lunar^> shaleh: handler has not the good type
17:46:58 <Lunar^> shaleh: look at getLine's
17:47:01 <Lunar^> @type getLine
17:47:02 <lambdabot> getLine :: IO String
17:47:45 <Lunar^> shaleh: You can see 'IO' has a marker which means that the function has to do something with the real world, but it doesn't give you any type
17:48:04 <Cale> IO is a type constructor
17:48:11 <shaleh> so how should I define handler?
17:48:39 <Cale> handler :: String -> IO (), perhaps
17:48:53 <Lunar^> shaleh: () is the unit type, it has only one value ()
17:49:01 <shaleh> Cale: yeah, that worked
17:49:20 <Lunar^> shaleh: A function having 'IO ()' has return type is like a 'void' function in C
17:49:34 <Lunar^> @type putStr
17:49:36 <lambdabot> putStr :: String -> IO ()
17:49:48 <Lunar^> shaleh: which is indeed putStr's case
17:51:01 <shapr> paganini_: what language are you writing it in?
17:51:22 <paganini_> hmm
17:51:55 <shaleh> hmm, seems like the standard lib eats Ctrl D.  How do I intercept that?
17:52:21 <paganini_> I am coding it with Java
17:52:39 <shapr> eivuokko: coming to EuroHaskell?
17:52:42 <shapr> paganini_: yow
17:52:48 <shapr> hi sundeep 
17:53:02 <shapr> I'm unfond of Java.
17:53:18 <shapr> Spark: look! I said something negative!
17:53:35 <sundeep> i hate java too
17:53:47 <shaleh> ok, do you guys have a pasting place? I would like to show you the code (it is mostly working currently, just need to handle the ^D thing)
17:54:07 <shapr> sundeep: do you use Haskell?
17:54:34 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:54:45 <Lunar^> shaleh: I can't think of an easy way to handle ^D with getLine
17:54:54 <sundeep> not really, though I plan to
17:56:26 <shaleh> ok, it is up
17:58:20 <shapr> sundeep: have any questions about Haskell?
17:58:48 <shaleh> guess my code is ok .....
17:58:57 <paganini_> why you guys hate Java?
17:59:08 <paganini_> I have my reasons
17:59:10 <sundeep> shapr: thanks! but i just hang about on this channel looking to pick up thin
17:59:18 <paganini_> but want to know your thoughts?
17:59:21 <sundeep> ...things
17:59:25 <Cale> paganini_: For me, I find it's horribly verbose.
17:59:28 <shapr> I don't hate Java, I just think it's clunky and schizophrenic.
17:59:39 <Lunar^> paganini_: "So if Java has generics, continuations, pattern matching, AOP and open classes what language innovations are left in our supposedly more advanced languages?"
17:59:56 <Lunar^> paganini_: quote from Noel Welsh on Lambda The Ultimate
18:00:27 <shapr> it doesn't do tail call optimization, the culture uses collections (and class loading) in such a way that very little Java code is statically typed
18:00:47 <shapr> the libraries could be cut down by 75% with judicious refactoring (J2EE even more)
18:00:58 <Lunar^> paganini_: see http://lambda.weblogs.com/discuss/msgReader$12518 for answers of what still miss :)
18:01:16 <Cale> data BaudRate = B0 | ... Zero baud? :)
18:01:36 <Cale> I suppose you could use it to represent "disconnected" :)
18:02:01 <Cale> (From System.Posix.Terminal)
18:02:04 <Lunar^> paganini_: Anyway, once you have done enough code in statically infered types, it's hard to use explicitely and loosely typed language
18:02:15 <shapr> paganini_: java's interfaces are like a broken and painful version of Haskell's typeclass instances
18:02:24 <Lunar^> Cale: The guilty is between the two dots :)
18:02:42 <Cale> heh
18:03:24 <shapr> I once spent a week trying to think of what Java has that Haskell needs.
18:03:36 <paganini_> io
18:03:42 <sundeep> libraries?
18:03:42 <shapr> my only conclusion was "advertising"
18:03:50 <stepcut> heh
18:04:10 <paganini_> I find Haskell incredible elegant. But when you try to do io it gets really messy
18:04:29 <shapr> it's not so bad when you get your head around monads
18:04:43 <shapr> write as much as you can in pure land, and call that from the monadic code
18:04:51 <paganini_> the other thing I would argue is that Java has a lot of open source code base available
18:04:56 <sundeep> paganini_: is it messy coz coding imperatively in haskell is intrinsically messy
18:05:02 <shapr> but Java itself isn't open soure
18:05:10 <paganini_> almost anything that you can think of is already done
18:05:17 <paganini_> right, Java is not open source
18:05:32 <paganini_> that's is a huge advantage
18:05:39 <shapr> so if you want to fix the famously broken bits, you can't
18:05:49 <paganini_> I mean, the availability of code
18:06:00 <Lunar^> shapr: Java type system is *broken*
18:06:00 <shapr> yes, Haskell could use more libraries
18:06:11 <shapr> Lunar^: even when people *use* the type system
18:06:20 <paganini_> lol
18:06:30 <shapr> explicitly casting out of collection classes makes me crazy
18:06:39 <paganini_> with Java 1.5 (generics) it gets a little bit better
18:06:58 <shapr> there are a lot of Haskell libraries out there
18:07:09 <Pseudonym> Not enough, though.
18:07:12 <shapr> true
18:07:15 <paganini_> don't get me wrong, my favorite language so far is scheme
18:07:23 <shapr> and Pseudonym has written quite a few cool libraries for Haskell
18:07:31 <Pseudonym> Not very many.
18:07:35 <Pseudonym> Almost none, in fact.
18:07:40 <Pseudonym> Mostly snippets.
18:07:47 <shapr> like lambdabot, right? ;-)
18:08:02 <Lunar^> shapr: class A { } ; class A1 extends A { } ; class A2 extends A { } ; public static void foo(A[] as) { as[0] = new A2(); } ; public static void bar() { A1[] as = { new A1() }; } ;
18:08:02 <sundeep> how many of you use haskell for day-to-day tasks?
18:08:03 <Pseudonym> That's not a library.
18:08:08 <paganini_> how scalable is Haskell?
18:08:10 <shapr> anyway... I think network libs are the most important
18:08:13 <shapr> sundeep: I do
18:08:18 <Pseudonym> sundeep: Depends what you call day-to-day.
18:08:23 <sundeep> work?
18:08:27 <Pseudonym> Indirectly.
18:08:29 <Lunar^> shapr: what happens if you add : foo(as) in bar ?
18:08:40 <shapr> Lunar^: I'm afraid to even think about it! my head will explode!
18:08:40 <Pseudonym> I use it as a very powerful calculator, and for little prototypes.
18:08:51 <Lunar^> shapr: Try it, it is interesting :)
18:08:59 <Pseudonym> paganini_: What's "scalable"?
18:09:12 <sundeep> Pseudonym: and what do you code your major projects in?
18:09:17 <Pseudonym> sundeep: C++
18:09:23 <paganini_> sundeep, if u go to monster.com and search for haskell, there are no results
18:09:25 <Pseudonym> The work ones, anyway.
18:09:50 <Pseudonym> paganini_: If you go to monster.com, you won't find any job resembling mine listed.
18:09:50 <Cale> shaleh: check the irc paste page for one way to catch ^D
18:09:51 <shapr> paganini_: yes, but Aetion.com and galoisconnections.com will hire you if you impress them.
18:09:57 <sundeep> actually, i had just tried ocaml, coded up a small project in it
18:10:15 <Pseudonym> I dunno about you, but I've never gotten a job from a job site.
18:10:20 <sundeep> didn't like it so much esp after i had such high expectations
18:10:22 <shapr> neither have I
18:10:27 <shapr> sundeep: well, it's fast :-)
18:10:27 <paganini_> Pseudonym, that can scale, that can manage huge load
18:10:35 <sundeep> so i am a bit wary of trying haskell
18:10:51 <sundeep> shapr: yes, it is quite fast
18:10:53 <shapr> sundeep: I believe that haskell is more elegant/expressive than ocaml
18:11:03 <Pseudonym> sundeep: I find that knowing Haskell makes my C++ code better.
18:11:12 <shapr> but my only proof is typeclasses
18:11:26 <sundeep> Pseudonym: yes, i do agree with that. ocaml improved my general style too i think
18:11:27 <Pseudonym> paganini_: What kind of huge load?
18:11:40 <Pseudonym> See, "scalable" is such a vague term.
18:11:53 <paganini_> I know what you mean
18:11:54 <Pseudonym> Certainly languages like Haskell do scale to large teams of programmers, for example.
18:12:01 <Cale> shaleh: is that what you're looking for?
18:12:04 <shapr> oy, the sunlight is breaking in through the blinds, that's my 3am go to sleep signal.
18:12:06 <sundeep> shapr: elegant yes, from what i've heard, but expressive?
18:12:09 <Pseudonym> There's good evidence for that, though not explicitly for Haskell.
18:12:15 <shapr> sundeep: yes, I think expressive too.
18:12:34 <Pseudonym> To pick one example, though, GHC's threads aren't OS threads.
18:12:41 <Pseudonym> They're multiplexed on top of _one_ OS thread.
18:12:42 <shapr> sundeep: but I don't know how I can easily show you that.
18:12:45 <Pseudonym> Which isn't SMP-scalable.
18:12:52 <Pseudonym> But then there's GpH, which is better in that regard.
18:13:02 <sundeep> shapr: expressive in a pythonic sense
18:13:03 <sundeep> ?
18:13:05 <Pseudonym> OTOH, there's no reason why Haskell-based middleware can't horizontally scale.
18:13:17 <shapr> well, I started with Python and swapped to Haskell
18:13:23 <Pseudonym> It largely depends on what you're doing.
18:13:37 <shapr> sundeep: what do you mean by expressive?
18:13:39 <sundeep> was haskell any faster?
18:13:40 <paganini_> I believe that after you are proficient in a functional language, you get better in the other languages
18:13:48 <shapr> faster to write, yes.
18:14:00 <shapr> and faster to execute too, now that I think of it.
18:14:08 <shapr> python has a lot more libraries though.
18:14:15 <paganini_> any haskell team for the ICFP?
18:14:17 <Pseudonym> "Faster to execute" is interesting.
18:14:21 <sundeep> i see
18:14:41 <Pseudonym> See, I've always thought that the best thing you can do for the performance of your code is write it well and cleanly, with good internal abstractions.
18:14:56 <shapr> the only real downside for Haskell (imho) is that it's hard to bootstrap on a non-package system.
18:14:57 <Pseudonym> That way, if you find a problem, you can swap code out, swap better code in, and everything else works.
18:14:57 <sundeep> i have heard that haskell's libraries are a lot more standardized and better written than ocaml's? is that true?
18:15:08 <shapr> sundeep: I don't know ocaml's libs
18:15:15 <sundeep> ok
18:15:26 <shapr> Pseudonym: python doesn't do list deforestation
18:15:42 <Pseudonym> So it's not necessarily that Haskell code runs faster, but it's that Haskell lets your programming be more agile.
18:15:48 <shapr> yah, I agree with that
18:15:50 <Pseudonym> Better able to respond to performance problems when they arise.
18:15:53 <sundeep> agile?
18:15:55 <Lunar^> shapr: Java broken type system demo is at the end of wiki's paste page
18:16:06 <shapr> agile = increased speed of change
18:16:21 <Pseudonym> Performance is almost always a moving target.
18:16:23 <sundeep> i see
18:16:43 <Pseudonym> And IMO it's the speed of responding to a performance problem which is more important than raw throughput.
18:16:51 <Jerub> where's the wiki paste page, I wanna see java breakage.
18:17:09 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:17:19 <sundeep> Pseudonym: i don't see why that is a positive
18:17:32 <shapr> because requirements change
18:17:41 <shapr> working code needs new features
18:17:47 <shapr> businesses change their minds
18:17:51 <shaleh> Cale: thanks
18:17:59 <shapr> so, if you can stably and quickly change existing code to do something eles
18:18:03 <Pseudonym> Performance problems show up only when you have a new customer with a different data set.
18:18:05 <shapr> you'll get rich
18:18:09 <shaleh> Cale: I think the real answer is to catch the exception.
18:18:16 <sundeep> ok
18:18:29 <Cale> shaleh: the problem is that it's not generating an exception
18:18:32 <Pseudonym> Oh, also, robustness is often just as important as throughput.
18:18:42 <Pseudonym> "Throughput" is the amount of work that you can get done jsut prior to overload.
18:18:46 <Cale> (which is why your program doesn't quit on ^D)
18:18:56 <Cale> It just eats the \EOT happily.
18:18:57 <shaleh> Cale: ah, but it does
18:18:58 <sundeep> but then haskell seems to require a lot of tweaking in order to extract performance
18:19:00 <Pseudonym> Handling overload gracefully, degrading cleanly, is often FAR more important.
18:19:08 <shapr> the smaller your loop is between customer request and successful feature implementation, the more likely you are to get paid to do more features
18:19:08 <cedricshock> shapr: That java code isn't broken. It shouldn't work.
18:19:12 <Cale> Oh, you mean that System.exitWith does?
18:19:14 <shaleh> ./line
18:19:14 <shaleh> Fail: <stdin>: hGetLine: end of file
18:19:18 <shapr> cedricshock: tell me more!
18:19:38 <Jerub> thats an interesting breakage.
18:19:50 <Pseudonym> Part of the problem is that when certain programmers who have never been in the real world think "performance", they think "first-person shooter games".
18:20:03 <Pseudonym> FPS games are the exception to every rule in the software industry.
18:20:17 <shapr> except for the "we don't use unit tests" rule
18:20:20 <cedricshock> shapr: You made an array of A1s, and then shoved an A2 into it. A2 is an A, but not an A1.
18:20:29 <Lunar^> cedricshock: Why that ? A1 is an A, and A2 is an A, so A1[] is an A[] and A2[] is an A[]....
18:20:30 <Pseudonym> shapr: True!
18:20:34 <Cale> hmm... interesting
18:20:53 <Lunar^> cedricshock: Exception in thread "main" java.lang.ArrayStoreException
18:20:57 <Cale> yeah, you'll probably want to stick a try in there
18:21:23 <Lunar^> Which means that for *every* array modifications, the entire heritage is looked upon
18:21:51 <sundeep> Pseudonym: well then, why don't use haskell for your work then
18:21:59 <shaleh> Cale: your code does this: Fail: <stdin>: hGetChar: end of file
18:22:01 <sundeep> unless you are forced not to
18:22:06 <shapr> sundeep: in any case, I want to get my request -> response loop as small as possible, and that's why I'm here on #haskell
18:22:10 <paganini_> hmm, the Java arrays are screw up
18:22:12 <Pseudonym> sundeep: Because I'm paid to hack 2+ million lines of C++.
18:22:16 <Cale> yeah, I just noticed that when it's compiled
18:22:25 <Pseudonym> Adding features and maintaining an existing product.
18:22:34 <sundeep> shapr: yeah, i see the community is good
18:22:41 * Jerub updates paste page to show what the output of running program will do.
18:22:57 <Jerub> java.lang.ArrayStoreException
18:22:57 <Jerub>    at Broken.foo (Broken.java:8)
18:22:57 <Jerub>    at Broken.main (Broken.java:4)
18:23:22 <shapr> sundeep: and the language and implementation are nice too
18:23:39 <cedricshock> shapr: Changing the last line to class A2 extends A1 { } makes it work
18:23:43 <sundeep> in what sense is the implementation nice
18:23:45 <Lunar^> paganini_: s/arrays // :)
18:24:09 <paganini_> how would c++ manage it?
18:24:10 <Jerub> actually a cleaner solution is:
18:24:14 <Jerub>                 A[] as = { new A1() };
18:24:19 <Jerub> instead of                 A1[] as = { new A1() };
18:24:25 <shapr> sundeep: well, much of Haskell is just lambda calculus, that's why lambdabot's @eval command confuses people
18:24:26 <cedricshock> Jereub: That would work too
18:24:40 <shapr> @eval map (\x -> x + 1) [2,3,4]
18:24:41 <lambdabot> [3, 4, 5]
18:24:46 <Lunar^> This code is meant to show how broken is Java type system... :)
18:25:10 <shapr> sundeep: GHC is pretty fast, has a lot of neat features, lets you customize stuff
18:25:21 <sundeep> thats a nice bot i didn't know about
18:25:36 <shapr> some people recently hacked the Glasgow Haskell Compiler to boot on x86 hardware as the kernel
18:25:40 <Lunar^> sundeep: GHC even allowed two crazy guys to make an operating system...
18:25:45 <shapr> right :-)
18:25:46 <Jerub> I'm not sure I'd consider that breakage. It illustrates how having an array's type signature doesn't change when it is passed to a function.
18:25:53 <sundeep> shapr: dunno, i thought the main complaint with ghc was speed
18:25:56 <Lunar^> shapr: noosphere in action :)
18:25:59 <shapr> speed of what?
18:26:21 <sundeep> speed of the compiled code
18:26:21 <cedricshock> Lunar^: That's not broken. It shouldn't work. A1 is an A, A2 is an A, A2 is not an A1. That would be like Hammer is Tool, Screwdriver is a Tool, you can use both as tools, but you can't use a hammer as a screwdriver.
18:26:36 <Lunar^> Jerub: I call it breakage when this little error force the runtime to add a lot of checks *every* array modfications
18:26:47 <shapr> from what I've heard/read GHC-built programs (pre apply model change) were about seven times slower than C. That's still faster than Python or Perl
18:27:07 <cedricshock> Lunar^: Oh i see it.
18:27:11 <Lunar^> cedricshock: The compiler can't check it
18:27:18 <shapr> the model change from eval/apply to whatever did speed up GHC, but I don't know how much
18:27:46 <Pseudonym> It depends on your code.
18:27:48 <sundeep> python/perl are scripting langs
18:27:58 <shapr> zope is written in python
18:28:01 <Pseudonym> The eval/apply change only applies to certain kinds of coding pattern.
18:28:04 <Lunar^> sundeep: Zope is not what I call a script.. :)
18:28:05 <cedricshock> Lunar^: An array of A1s is an Array of As, and you can write an A2 to an array of As. The problem is in the whole philosophy of destructive assignment, not in the type system.
18:28:05 <Pseudonym> e.g. higher-order-heavy code
18:28:12 <shapr> I don't think there is such a thing as a scripting lang
18:28:28 <Pseudonym> shapr: There is, kind of.
18:28:50 <shapr> I think there's the Alternate Hard and Soft Layers pattern http://c2.com/cgi-bin/wiki?AlternateHardAndSoftLayers
18:28:53 <Pseudonym> Any DSL which is only embedded in one (or several) application(s) is by definition a scripting language.
18:29:05 <Lunar^> cedricshock: I was shocked the first time sebc show me this point. It stills hurt me
18:29:08 <sundeep> dsl?
18:29:11 <shaleh> take care all, heading home
18:29:17 <shapr> Pseudonym: in that case, neither Perl nor Python are scripting langs
18:29:35 <Pseudonym> shapr: I never said the converse was true.
18:29:57 <shapr> though it would count the custom lisp in sawfish, GIMP's custom scheme, and a bunch of others
18:30:05 <Pseudonym> Emacs Lisp
18:30:06 <shapr> I see your point, I agree with it.
18:30:13 <Pseudonym> Those are obvious.
18:30:25 <shapr> sundeep: domain specific language
18:30:30 <sundeep> k
18:31:18 <shapr> oy, it's 3:30am, I'm off to sleep. I have to get up early all of next week.
18:31:26 <shapr> g'night folks!
18:31:29 <Pseudonym> Night.
18:31:31 <sundeep> g'night
18:31:37 * shapr disappears
18:31:39 <Lunar^> I'm doing the same :)
18:31:43 <sundeep> i gtg too, have a meeting tomorrow
20:28:19 <black_dog> anyone here got experience in using haskell for parallell programming?
21:09:33 <Cale> black_dog: well, I haven't done much of it, but it's quite nice from what I recall
21:19:04 <Spark> how does it work?
21:19:25 <Spark> can you evaluate a pair of expressions in parallel (because of referential transparency) ?
21:20:06 <Spark> because they have no interdependencies
21:28:36 <Cale> file:///usr/share/doc/ghc6-doc/html/libraries/base/Control.Concurrent.html
21:28:39 <Cale> oops
21:29:12 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
21:31:26 <monotonom> If you have GpH you can evaluate a pair of expressions in parallel on two computers.
21:33:06 <monotonom> But GpH has fragmented from GHC de facto, and no one has time to reconcile them.
21:39:35 * Cale is away: sleep
21:40:33 <black_dog> Cale: cheers mate. currently wrestling with pvm... the user guide seems to suggest that ghc still has some support for parallelism; is that no longer true?
