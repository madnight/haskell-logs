00:44:42 <shapr> yow!
00:46:38 <liiwi> yoyo
00:52:36 <Pseudonym> @arr
00:52:54 <Pseudonym> Ah, not present.
00:53:13 <shapr> whoops
00:54:35 <lambdabot> That's better. I was missing this place.
00:54:49 <shapr> right, home home on the strange
00:55:14 <lambdabot> I did hear a discouraging word the other day.
00:55:23 <shapr> :-)
01:09:09 * shapr sings cheerfully
01:13:24 <shapr> @arr
01:13:24 <lambdabot> I'll keel haul ya fer that!
01:35:22 <dons> hey JaffaCake
01:35:27 <JaffaCake> yo
01:35:32 <dons> ah, Gofer, those were the days
01:35:53 * JaffaCake stares whistfully out the window
01:36:29 <JaffaCake> when the only decent Haskell implementation wasn't even proper Haskell :-)
01:36:40 <dons> :)
01:37:03 <JaffaCake> re: your patch... could we have a warning in the DEBUG case?
01:37:15 <dons> yep. good idea.
01:40:01 * ozone wins!
01:40:37 <dons> ozone: re. "plugs", :)
01:41:30 <ozone> dons: i dare you ;)
01:42:21 <dons> I think G==GHCi is cute!
01:46:20 <Pseudonym> Gofer was a cool system.
01:46:29 <Pseudonym> MonadZero
01:46:40 <Pseudonym> And, of course, pre-monad continuation-based IO.
01:46:47 <Pseudonym> main :: [Response] -> [Request]
01:47:28 <Pseudonym> Must away.
01:47:30 <Pseudonym> Nytol!
04:53:45 <vegai> were there other "portable assembler" languages than C--?
04:53:59 <vegai> s/than/in addition to/
04:54:15 <ibid> C? :)
04:58:58 <vegai> *that don't suck ;P
05:10:27 <Lunar^> vegai: even C-- is not that far usable
05:10:41 <Lunar^> vegai: The most recent version is actually the one in GHC's backend-hacking-branch
06:24:20 <blackdog> shapr: you there? xemacs newbie needs help again.
06:28:25 <Lunar^> Does anyone know what SplitObjs is usefull for ?
06:37:08 <earthy> ease of linking?
06:37:17 <Lunar^> ?
06:37:22 <JaffaCake> yes, I know ;-)
06:37:32 * earthy laughs
06:37:41 <earthy> then, explain, if you would. :)
06:37:41 <Lunar^> Is it easier to link more than a thousands small objects ?
06:37:51 <JaffaCake> it's to make binaries smaller
06:38:01 <earthy> that's what I meant
06:38:21 <JaffaCake> by splitting the library into lots of small bits, you reduce the transitive closure of stuff that needs to be linked in
06:38:21 <earthy> it makes it possible to link just those objects you actually need
06:38:42 <Lunar^> I don't remember seeing anything about it in the GHC commentary, or am I wrong ?
06:38:57 <earthy> I seem to remember having seen something about it somewhere
06:38:59 <JaffaCake> might not be
06:39:18 <Lunar^> That's mostely related because one module = one object file, right ?
06:39:35 <JaffaCake> yes
06:39:44 * Lunar^ apologies for his bad english..
06:39:53 <JaffaCake> SplitObjs makes roughly  one function == one object file
06:40:00 <Lunar^> Another good reason to remove files :)
06:40:26 <JaffaCake> remove files?  and use what?
06:40:48 <Lunar^> Is there any other functional language implentation that use the same trick?
06:40:49 <earthy> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg05973.html
06:40:51 <earthy> there it was
06:41:25 <JaffaCake> Lunar^: not that I know of
06:42:17 <Lunar^> Replacing files with something with a smaller granularity
06:42:32 <JaffaCake> there are better ways to do it these days... see ld's --gc-sections flag
06:43:06 <JaffaCake> but we don't have support for that, and it's more than an afternoon's hack
06:43:27 <Lunar^> See Jerzy's last mail on haskell-cafe about files and modules:http://haskell.org/pipermail/haskell-cafe/2004-June/006238.html
06:44:41 <JaffaCake> I don't buy it .... the filesystem *is* a database
06:45:45 <Lunar^> --gc-sections doesn't seem really portable
06:46:10 <JaffaCake> yes, probably not
06:46:20 <JaffaCake> but then, neither is -split-objs :)
06:46:42 <Lunar^> Sure.. but distributing something with GHC isn't something like distributing a patch to ld... :)
06:48:48 <Lunar^> GHC isn't multi-threaded at all, right ?
06:48:58 <shapr> blackdog: y0 y0
06:49:09 <shapr> blackdog: what can I do for you?
06:49:30 * shapr hOps hAppily
06:49:31 <blackdog> hey shapr. my xemacs is b0rked. should i be able to apt-get it cleanly in unstable debian?
06:49:44 <shapr> yes, should be, what's the prob?
06:50:10 <JaffaCake> ghc is a little bit multithreaded
06:52:38 <Lunar^> JaffaCake: mhhh.. I'm going for an MVar so..
06:59:34 <shapr> hiya wouter, any new haskell questions?
07:01:03 <JaffaCake> shapr doesn't tolerate lurkers on #haskell :)
07:01:09 * shapr grins
07:01:21 <wouter> not yet - thankx
07:01:22 <shapr> I just don't want anyone to feel left out.
07:02:33 <earthy> you even use multiple languages to accomplish that, right? :)
07:03:18 <SyntaxNinja> shapr does a great job :)
07:05:27 <shapr> earthy: bien s√ªr!
07:05:43 * arjanb thinks hard for a question before turning into a lurker
07:06:21 * shapr grins evilly at arjanb 
07:11:55 <arjanb> foo :: [a] -> [a] -> [a]
07:11:56 <arjanb> foo x y = if x == [] then y else x
07:12:01 <arjanb> why does this code yield a type error while writing it with patterns does not?
07:12:22 <JaffaCake> good question
07:12:28 <shapr> arjanb: smart, you had a question before the time ran out :-)
07:12:44 <JaffaCake> it needs Eq a, right?
07:12:49 <arjanb> yes
07:13:19 <JaffaCake> I can't think of a simple way to answer that one
07:13:44 <SyntaxNinja> well, do you know what Eq a is, arjanb?
07:14:30 <arjanb> yes
07:15:09 <SyntaxNinja> so when you say (x == []) you're asking it to compare all the contents of x to all the contents of the empty list
07:15:17 <SyntaxNinja> to do so, it has to know how to compare the contents (that is, Eq a)
07:15:36 <JaffaCake> except that the Eq a is never used
07:15:37 <SyntaxNinja> you're not really asking it to match the pattern (asking "null x" would probably do what you want)
07:15:47 <SyntaxNinja> yeah, that's the confusing part.
07:15:57 <SyntaxNinja> but JaffaCake's silly compiler doesn't know that ;)
07:16:12 <SyntaxNinja> @type null
07:16:13 <lambdabot> null :: forall a. [a] -> Bool
07:16:17 <JaffaCake> I didn't write the type checker :-P
07:17:55 <arjanb> couldn't all nullary constructors be instance of Eq?
07:18:29 <SyntaxNinja> JaffaCake: I sometimes do wish I had something to check a pattern without going to a function or case statement.
07:19:12 <JaffaCake> like using null?
07:19:32 <SyntaxNinja> yeah
07:19:52 <SyntaxNinja> arjanb: constructors themselves don't take instances, the types do.
07:20:02 <JaffaCake> yes, sometimes the distinction between boolean expressions and pattern matching seems a bit arbitrary
07:21:08 <JaffaCake> perhaps there ought to be a nice way to say  'if (case x of Just x -> True; _ -> False) then ...'
07:23:46 <SyntaxNinja> JaffaCake: right... it wouldn't be so bad if lambdas weren't irrifutable... otoh, I usually figure that when I want to do that, I've probably done something wrong somewhere :)
07:24:41 <JaffaCake> OTOH, there are already too many ways to write things
07:25:46 <SyntaxNinja> arjanb: any clearer?
07:26:30 <earthy> timtowtdi
07:26:38 <arjanb> yes
07:26:46 <shapr> tanstaafl
07:27:00 <arjanb> the haskell type system keeps surprising me
07:27:27 * SyntaxNinja hides inside the type system, just waiting to scare arjanb when he's least expecting it
07:27:57 <shapr> the other Simon encoded financial contracts in the type system, right?
07:28:48 <JaffaCake> well, not really the type system, it was just functions
07:29:26 <shapr> I want an O'Reilly book "Encoding Information in the Hindley-Milner Type System in a Nutshell"
07:30:17 <JaffaCake> so write it!
07:30:24 <kosmikus> JaffaCake: you example can be written "if isJust x then ...", but I guess you want to have a construct that is parametrizable over the constructor?
07:30:26 * shapr scribbles madly
07:30:57 <JaffaCake> it's not a good example
07:31:08 <earthy> kosmikus: exactly
07:31:55 <JaffaCake> sometimes you want to say 'if e matches p then ...'
07:32:20 <JaffaCake> you can do it in a guard, using pattern guards:  f | p <- e = ...
07:32:42 <kosmikus> yes, I can see that this would be nice
07:33:04 <JaffaCake> there could be no bindings in the pattern, of course
07:34:42 <kosmikus> well, you could make the "matches" construct return a Maybe of a tuple, containing the bindings in the pattern; then you'd need to write "if isJust (e matches p) then ..." if you're not interested in the bindings
07:35:32 <JaffaCake> maybe
07:36:02 <earthy> that looks almost as horrible as if (case e of p -> True; _ -> False) then
07:36:03 <kosmikus> reminds me of RhoStratego
07:36:39 <kosmikus> it's not horrible if patterns are first-class in the language
07:36:46 <kosmikus> then you can write your own abstractions
07:41:42 * earthy nods
07:41:53 <earthy> but they aren't, currently
07:42:51 <kosmikus> true, but neither is "matches" implemented ;)
07:43:31 <earthy> ;)
07:55:38 <Lemmih> Whoa... I'm getting the same error with hsql as with darcs' /-:
07:58:21 <saz> hsql?
07:58:52 <Lemmih> http://htoolkit.sourceforge.net/
08:00:25 <saz> hmm
08:00:37 <saz> another widgetset?
08:00:41 <saz> or am i missing something
08:00:56 <earthy> you're missing something
08:00:57 <Lemmih> I'm only using hsql.
08:01:02 <shapr> what's the error?
08:01:05 <earthy> HSQL is a database-binding
08:01:41 <Lemmih> build/Database/HSQL/Types.hs:91:27:
08:01:41 <Lemmih>     Couldn't match `TypeRep' against `TyCon'
08:01:41 <Lemmih>       Expected type: TypeRep
08:01:41 <Lemmih>       Inferred type: TyCon
08:01:41 <Lemmih>     In the first argument of `mkAppTy', namely `sqlErrorTc'
08:01:42 <Lemmih>     In the definition of `typeOf': typeOf _ = mkAppTy sqlErrorTc []
08:02:31 <Lemmih> Hmm It compiled fine with ghc-6.2.1.
08:06:37 <Lunar^> Lemmih: which GHC it is then ?
08:09:03 <Lemmih> Current cvs version. I probably shouldn't use it for normal apps.
08:14:30 <Lunar^> This one is really interesting : http://www.joelonsoftware.com/articles/APIWar.html
08:14:52 <Lunar^> Lemmih: From what I've seen from the cvs-ghc mailling-list, I think there was a lot of changes in Dynamic part
08:15:06 <Lunar^> Lemmih: Which are often used to add new exceptions type
09:21:21 * JaffaCake goes off  to watch England v. Switzerland
09:32:20 <shapr> hej ski!
09:32:32 <ski> hej pÂ dig, shapr
09:41:21 <shapr> hej bringert 
09:41:28 <bringert> hej
09:48:16 * shapr hops cheerfully
09:48:21 <shapr> bringert: I'm trying to hack kupu into BLob
09:52:49 <shapr> huh, what's up with saz?
09:52:55 <shapr> is she in .il ?
09:53:09 <Philippa_> How not to type check pattern-matching: make the types of the variables in a pattern generic
09:55:25 <bringert> shap: what's kupu?
09:55:53 <bringert> yes, I know, fuckinggoogleit.com
09:56:04 <shapr> http://kupu.oscom.org/
09:56:18 <shapr> it's a WYSIWYG javascript editor, everything's client side
09:56:25 <shapr> and you can set it to force strict XHTML output
09:56:59 <shapr> I met the developers at EP, and I've always wanted to see if prototype oriented programming is noticeably different for abstractions, etc
09:57:05 <shapr> saz_: hey, are you in .il ?
09:57:39 <shapr> oh, I think the saz nickname just got registered by someone in .il
09:57:58 <shapr> hei Lor, wassup?
09:58:09 <shapr> what does the E stand for?
09:58:09 <Lor> Well.
09:58:21 <shapr> or would you rather not say?
09:58:42 <Lor> In my username?
09:58:55 <shapr> bringert: anyway, I figured I'd hack on kupu for fun, and what better way than to hack it into BLob?
09:59:01 <shapr> Lor: yah, I assume it's your middle initial?
09:59:52 <Lor> Yeah. My full name is Lauri Emil Alanko. "Emil" is a Swedish name.
09:59:52 <bringert> shapr: that looks interesting
09:59:58 <shapr> Lor: oh, neat
10:00:11 <shapr> bringert: yah, plus it would solve the problem of forcing strict/legal XHTML
10:00:39 <Lor> You probably know how it's pronounced. Which is good, because I can't think of an easy explanation to an English-speaker. :)
10:00:44 * shapr grins
10:01:10 <Lor> There's no long [e] in English.
10:01:30 <shapr> you could try to explain the eegore and Igor bit
10:01:31 <shapr> maybe
10:01:56 <bringert> shapr: I was considering using HaXml's HTML parser and then render it with the XML renderer, that should create valid xhtml
10:02:38 <bringert> shapr: kupu looks cool, a few bugs in my mozilla, but it looks usable
10:03:47 <bringert> hmm, it uses <font> tags
10:05:13 <shapr> it works with both moz and ie from what I've heard
10:07:08 <bringert> in my mozilla 1.6 that url input field is really small, and the window that it's in is really big
10:08:03 <bringert> it seems to have some problems when the user changes the browser font size
10:09:08 <bringert> don't get me wrong, it's pretty nice. it's just that making javascript that looks good for everyone is really hard
10:10:34 <shapr> yah, I agree
10:10:39 <shapr> should be fun to hack on though
10:10:50 <shapr> I've never worked on a real javascript app
10:16:06 <Lor> javascript shouldn't "look" like anything.
10:17:06 <Lor> All conceivably useful presentation tricks can be done with CSS, javascript should only be used for real client-side processing, when that is needed for some purpose.
10:17:20 <Lor> But before I go on bashing more... what was the context again? :)
10:17:56 <Marvin--> do we need a context for bashing javascript? ;)
10:18:31 <Marvin--> the concept of web applications scare me, because it goes against so many usability principles :(
10:19:19 <Marvin--> did anyone else read the latest Joel-on-software?
10:20:05 <shapr> Lor: kupu the javascript XHTML editor, I'd like to plug it into bringert's nifty blog software
10:21:16 <Lor> Ah.
10:21:20 <bringert> Lor: yes, sorry, I was being imprecise. I meant javascript, or any other language, when used to achieve dynamic client-side behavior in web pages
10:21:23 <shapr> actually, the real context is that I'd like to have some blog software that I can set up for clients, friends, family, etc
10:21:50 <shapr> and kupu + BLob is somewhere imbetween my fantasies and my real life.
10:22:16 <Lor> Isn't a simple wikisyntax usable enough with just a standard textarea editor?
10:22:57 <shapr> yes, I think so
10:23:20 <shapr> but my clients often can't remember wiki syntax
10:23:48 <Lor> An embedded "real" editor would probably be the best choice.
10:24:02 <Lor> Of course such a thing cannot be done portably... unless it's a java applet.
10:24:47 <Lor> Personally, I'd like some sort of magic that allowed me to edit all textareas within xemacs.
10:24:58 <shapr> and Java is "Write Once, Debug Everywhere" about as much as JavaScript
10:25:13 <Marvin--> I would like to turn time back and never have the <form> tag invented
10:25:31 <shapr> Lor: there is that magic actually
10:25:44 <shapr> but a better magic would give me embedded xemacs buffers for each text area
10:25:56 <Lor> Nah.
10:25:56 <shapr> that magic can also exist without a huge amount of work
10:26:03 <Lor> Embedding is awful.
10:26:10 <shapr> since xemacs has gnome support now
10:26:14 <Lor> I hate embedded acroread windows. 
10:26:31 <Marvin--> acroread is awful in general
10:26:32 <Lor> I'd much rather view pdf's in a separate acroread window.
10:26:36 <shapr> personally, I like using a web browser inside xemacs
10:26:52 <shapr> then you have the best of all worlds, but no HaskellScript :-(
10:28:20 <Lor> Haskell doesn't really work as a scripting language.
10:28:34 <shapr> it's getting there
10:28:47 <shapr> hs-plugins is another step in the right direction
10:28:58 <shapr> especially now that hs-plugins is 'self-hosting'
10:29:01 <Lor> Still unsafe?
10:29:16 <shapr> I don't think so.
10:29:30 <shapr> but I'd like to hear your opinion on it :-)
10:29:47 <shapr> oh, speaking of type-checked mobile code, JaffaCake pointed me to Goffin and friends
10:29:53 <shapr> interesting stuff, though I haven't read it all yet.
10:30:26 <Lor> Agh. Seems like I have to mention hs-plugins in my thesis.
10:30:44 <Lor> It's got eval.
10:30:50 <Marvin--> heh
10:30:50 <shapr> yah, ain't that spiffy?
10:33:50 <Lor> I will tell within a moment, once I've had a look at it...
10:35:18 <Lor> Ah. I think it is just as safe as haskell's dynamics are.
10:35:26 <shapr> is that good or bad?
10:35:27 <Lor> I.e. not very.
10:35:50 <Lor> Well, it works in practice. IMHO it's an ugly hack, but hey...
10:36:59 <Lor> The thing is, it all depends on each instance of Typable having a distinct typerep.
10:37:25 <Lor> Or rather, on each constructor having a distinctly named TyCon.
10:37:47 <Marvin--> yeah, it's not pretty
10:37:52 <Lor> But this is only convention, it's not enforced by the language.
10:38:24 <shapr> Lor: I hope you and JaffaCake are awake at the same time someday, so I can hear you two discuss the type-safety of dynloading in Haskell
10:38:29 <Lor> So, you should be able to break it all by constructing your own type whose Typeable instance fakes some other type's name.
10:39:24 * shapr gives in to unicycling.
10:39:36 <bringert> could dynamic loading / evaluation ever be safe?
10:39:42 <Lor> Sure.
10:39:51 <Lor> In Java it is.
10:39:59 <shapr> how about in Haskell?
10:40:00 <Lor> Well, could be, if it were not for some silly engineering decisions.
10:40:32 <Lor> How big changes would you allow for while still calling the language Haskell? :)
10:40:45 <shapr> did I already ask you what you thought about doing dynloading / eval in the compile-time loop of Template Haskell so the type-checker is handy?
10:41:11 <shapr> bah, unicycling, bbl
10:41:17 <Lor> You're talking about the implementation of TH?
11:01:59 * Philippa is having trouble getting runST to work and is wondering if there are any well-known gotchas?
11:03:42 <ski> typing trouble ?
11:03:45 <Lor> That's not a very good way to get help.
11:03:49 <Philippa> yeah
11:04:25 <Philippa> Lor: I can't get something as simple as runST (do {a <- newSTRef 1; readSTRef a}) to work
11:05:32 <Lor> Philippa, what's the error?
11:06:10 <Philippa> OK, scratch that bit, will go back over for a mo...
11:06:31 * SyntaxNinja looks at O'Reilly's language poster: http://www.oreilly.com/news/graphics/prog_lang_poster.pdf
11:07:00 <SyntaxNinja> so Haskell, Caml, and Perl were all started at around the same time
11:07:52 <SyntaxNinja> Philippa: don't you need a starting state?
11:08:19 <ski> SyntaxNinja : i don't think so
11:08:26 <Lor> it's ST, not State.
11:09:12 <SyntaxNinja> OK
11:09:37 <Philippa> OK, the problem I'm having's trying to stack a StateT on top of it
11:10:02 <Lor> Ah, monad transformers are tricky.
11:10:16 <Philippa> in particular, trying to actually run anything in the resulting monad - I'm getting complaints about the result type being less polymorphic than expected and ST's s getting lost
11:10:23 <Philippa> sorry, escaping even
11:10:24 <Lor> Why do you need a StateT? If you are already using ST, you can do all state manipulation within it.
11:10:36 <Philippa> encapsulation
11:11:09 <Philippa> or to put it anotehr way, I don't want to have to propagate an STRef everywhere for that particular bit of state
11:11:11 <Philippa> *another
11:11:37 <Lor> You can use a Reader monad to carry that... :)
11:11:58 <Philippa> so we swap one transformer for another, big deal :-)
11:12:05 <Lor> Philippa, do you have your entire combined monad type parameterized by s?
11:12:15 <Philippa> yeah
11:12:51 <Lor> And the monadic value you are trying to run also has the s free?
11:12:59 <Philippa> to the best of my knowledge, yeah
11:13:09 <Philippa> should be completely free 'til it hits the runST
11:14:04 <Lor> Well, I'm stumped.
11:14:13 <Philippa> of course, that "to the best of my knowledge" could translate to "actually, er, no"
11:14:54 <Philippa> can't see anywhere it's specifically set though
11:15:13 <Philippa> am rewriting the combined monad some existing stuff sits on, but it's breaking on the module the monad's in
11:15:14 <Lor> See what ghci says about the types.
11:15:29 <Philippa>  Inferred type is less polymorphic than expected
11:15:29 <Philippa>      Quantified type variable `s' escapes
11:15:29 <Philippa>      Expected type: ST s a -> b
11:15:29 <Philippa>      Inferred type: (forall s1. ST s1 a) -> a
11:15:29 <Philippa>  In the first argument of `($)', namely `runST'
11:15:30 <Philippa>  In the definition of `evalEnv':
11:15:32 <Philippa>      evalEnv f (TO to) = runST $ (evalStateT f to)
11:15:42 <Lor> Ah. $ is the problem.
11:15:48 <Lor> It monomorphizes its arguments.
11:15:58 <Marvin--> ah yes, the famous $ problem
11:16:07 <Lor> You can't say runST $ foo, but runST (foo)
11:16:26 <Lor> Philippa, you're right, that _is_ a well-known gotcha.
11:16:45 <Philippa> rewriting it with parens instead still breaks, gives me this:
11:16:46 <Philippa> Inferred type is less polymorphic than expected
11:16:46 <Philippa>     Quantified type variable `s' escapes
11:16:46 <Philippa>     It is mentioned in the environment:
11:16:46 <Philippa>       f :: StateT Int (ST s) a (bound at ./Env.hs:29)
11:16:46 <Philippa> In the first argument of `runST', namely `(evalStateT f to)'
11:17:32 <Philippa> where the entire func (in Env.hs:29, surprise surprise) now reads
11:17:33 <Philippa> evalEnv f (TO to) = runST (evalStateT f to)
11:17:51 <Lor> the problem is that f is somehow monomorphized.
11:18:09 <Lor> For some reason s is no longer free in it.
11:19:23 <Lor> Ah. It's taken as an argument.
11:19:41 <Lor> You have to provide an explicit type signature to be able to take polymorphic parameters.
11:20:20 <Marvin--> evalEnv :: (forall s. StateT Int (ST s) a) -> ...
11:20:28 <Philippa> was wondering if that'd be it
11:21:17 <Lor> Automatically inferred types are always monomorphic.
11:21:52 <Lor> (Type inference isn't decidable for arbitrary-rank polymorphism)
11:24:43 <Philippa> OK, now I'm getting seemingly-related errors where I'm calling evalEnv
11:25:05 <Philippa> I figure once again I need to supply a type annotation?
11:26:34 <Lor> With that kind of a program structure, yeah.
11:26:58 <Lor> Because ST is such a bitch, usually it's easier not to provide wrappers to runST, but just to call runST directly wherever needed.
11:27:08 <Lor> It's ugly, but easy. :)
11:27:21 <Philippa> I've not got many call sites, thankfully
11:27:25 <Lor> (But realistically, you shouldn't need to use runST except in one or two places... echo)
11:27:35 <Philippa> what's the minimum annotation needed?
11:27:53 <Philippa> just on the computation?
11:28:10 <Lor> You should be able to do without any.
11:28:19 <Lor> Of course annotations are often a good idea for several reasons.
11:28:42 <Lor> They provide visible documentation, and they allow you to tell the compiler what you expect the types to be, so errors can be located more easily.
11:29:55 <Philippa> yeah yeah, am familiar with the arguments :-) In this particular case though, what do I need?
11:30:24 <Philippa> should I just make sure the computation's polymorphically typed before it's fed into evalEnv?
11:30:42 <Lor> You have to tell the type checker that it is polymorphic, yeah.
11:30:51 <Lor> As marvin demonstrated.
11:31:02 <Lor> You might be able to write a type synonym for it.
11:31:18 <Lor> I don't remember whether ghc supports type synonyms for polymorphic types.
11:32:47 <Marvin--> I don't think so
11:33:45 <Lor> plain existential types would be nice, too.
11:33:58 <Lor> I recall I would actually have had a use for them at some point.
11:48:07 <bringert> SyntaxNinja: the latest version of Haskell XmlRpc (http://www.bringert.net/haskell-xml-rpc/) includes a Setup.lhs which seems to work with Cabal
11:48:34 <bringert> though I haven't tested with the new code from today and yesterday
11:48:40 <SyntaxNinja> OK cool.
11:49:10 <kosmikus|away> Lor: I think ghc supports type synonyms for polymorphic types
11:50:32 <SyntaxNinja> bringert: I was actually thinking that it might be nice to use xml-rpc to query a remote package database, btw :)
11:50:44 <SyntaxNinja> but since that's a layer higher than Cabal, it's OK for xml-rpc to be packaged in cabal.
11:53:27 <Marvin--> SyntaxNinja: "Distribution/Simple.Build"? Is that / a typo?
11:55:31 <Lor> How can a luser install a personal ghc package?
11:56:35 <monotonom> download a binary tarball (not a source tarball), pretty much unpack it in any directory you want.
11:56:35 <SyntaxNinja> where?
11:57:00 <Lor> Yes but how do I use it?
11:57:49 <Lor> It's got these .hi files and .a files, how do I tell e.g. ghci that here can modules be found?
11:58:25 <monotonom> See the README and INSTALL that comes with the tarball.
11:58:41 <monotonom> I assume luser still knows some common human language such as English.
11:59:22 <Lor> Not all packages have such wonderfully comprehensive documentation. This one only tells how to run ghc-pkg as root.
11:59:39 <Lor> And I'd rather keep this as a local instead of a system-wide install.
12:00:03 <monotonom> Lie.
12:00:15 <SyntaxNinja> there's a flag to tell ghc-pkg to use a different file, and then you can tell ghc to use that file.
12:00:48 <SyntaxNinja> Marvin--: what typo?
12:00:49 <monotonom> I have been able to do exactly what I outlined since ghc 4.
12:01:44 <Marvin--> SyntaxNinja: shouldn't it be just Distribution.Simple.Build?
12:02:18 <SyntaxNinja> Marvin--: what are you reading?
12:02:20 <monotonom> On a system where I do not have root.
12:02:54 <Lor> This is my personal machine, I do have root. I'd just rather not install any non-distribution stuff as root.
12:03:03 <Lor> There shouldn't be need to.
12:03:15 <monotonom> download -> unpack -> follow the "in situ" instruction in README/INSTALL -> done.
12:03:27 <Marvin--> SyntaxNinja: Setup.lhs
12:03:34 <Marvin--> SyntaxNinja: the cabal-in-cabal file
12:03:45 <Lor> there are no "in situ" instructions here.
12:03:58 <SyntaxNinja> ghc-pkg --config-file, ghc -package-conf
12:04:11 <SyntaxNinja> Marvin--: yeah, probably a typo, i'll fix that.
12:04:16 <SyntaxNinja> Marvin--: thanks :)
12:09:41 <Lor> All right, so I have to make a local config file...
12:10:50 <SyntaxNinja> ja
12:10:53 <Lor> Which apparently has to be initialized to []
12:10:59 <SyntaxNinja> jaja
12:11:09 <Lor> ghc-pkg should imho write one if doesn't exist...
12:11:24 * SyntaxNinja dreams of a future where there will be a standard place for the local config file, and it will be initialized if it doesn't exist
12:12:02 <Lor> So from now on I always give ghc this -package-conf argument when I want to use local packages?
12:13:36 <SyntaxNinja> afaik, that's the way
12:18:33 <Lor> Hm, "unknown symbol `addDLL'"
12:19:18 <Lor> hs-plugins uses it but doesn't define it. Wonder where it's supposed to be found.
12:19:50 <Lor> Ah, prolly it's because I use ghc 6.2.1
12:27:39 * shapr hops tiredly
12:28:21 <Lor> Hm. Wonder if this is because the ghc binary is stripped...
12:28:39 <shapr> dons: ayt?
12:28:47 <shapr> Lor: happily, the author is in #haskell
12:29:44 <Lor> If he were but awake as well...
12:30:01 <shapr> well, he's on winter time
12:31:44 <Lor> I think the problem is the stripped binary.
12:32:05 <Lor> shapr, when you have used dynamic loading, has your ghc been stripped or not?
12:32:23 <shapr> I dunno, I never checked its clothing.
12:32:25 * shapr checks
12:37:37 <shapr> Lor: except for the limitations of Dynamic name collisions, do you think hs-plugins is close enough to the level of elisp's interactivity?
12:38:19 <Lor> No.
12:38:24 <shapr> Lor: what exactly is failing for you with hs-plugins?
12:38:31 <Lor> It's got the same problems as ocaml's run-time evaluation.
12:38:38 <shapr> what are those problems?
12:38:54 <Lor> The problem is that the evaluated code has no direct access to the environment of the running process.
12:39:13 <shapr> ?
12:39:16 <shapr> can you describe that further?
12:39:53 <shapr> anyway, hs-plugins works just fine with ghc-6.2.1 in debian/unstable, and that's a stripped ghc
12:40:00 <Lor> To be able to call "eval", the evaluated string has to be compiled. For it to be compiled, the compiler has to be able to find out the interface files for all the code that the evaluated string refers to.
12:40:36 <Lor> And this is quite a restriction.
12:41:42 <shapr> it sounds much like type-carrying code
12:41:55 <Lor> That's the answer, yeah.
12:42:08 <shapr> .hi files carry the types, yah?
12:42:14 <Lor> Or, well, depends on what you mean.
12:42:22 <shapr> what do you mean?
12:42:24 <Lor> The problem is that the .hi files are separate entities.
12:42:55 <Lor> Hm, how should I put this...
12:43:45 <shapr> you want the source and the .hi file to be a single entity?
12:43:54 <Marvin--> SyntaxNinja: hmm, I'm trying to run make PREF=/tmp/hunit hunitInstall but it doesn't work
12:44:06 <Lor> The most obvious example would be if an eval'd string could contain a type definition, but that's impossible in hs-plugins where the string has to be an expression.
12:44:38 <Lor> shapr, no no no. I want the runtime to carry the type information of all the code that is loaded.
12:44:42 <Marvin--> seems like test/HUnit/Makefile hardcodes /usr/local/src/HUnit... any good reason for that? Why not just -i../..:. ?
12:44:53 <Lor> No external files.
12:45:01 <shapr> I can understand that.
12:45:31 <Marvin--> SyntaxNinja: or rather, -i../..:src
12:45:41 <Lor> There are at least two systems that Do The Right Thing, or at least something reasonably close to it.
12:45:48 <Lor> One is Java, the other is TAL/Load.
12:45:49 <SyntaxNinja> Marvin--: yeah, the later should be right
12:45:50 <shapr> I think you can do that with Template Haskell
12:45:53 <SyntaxNinja> I just changed that stuff yesterday :()
12:46:17 <shapr> the only problem is that right now, TH only understands explicitly coded ASTs, no way to load an AST from a file
12:46:22 <shapr> as in, from a source file
12:46:48 <Marvin--> SyntaxNinja: being able to add a --user flag without hacking the Makefile would be nice too
12:48:46 <Lor> With some compile-time trickery you can add type representations everywhere, yes. Then it all reduces to the problem of how to handle type representations type-safely.
12:49:01 <Lor> But _all_ the dynamics systems have some problems.
12:49:09 <shapr> TH doesn't use dynamics
12:49:21 <SyntaxNinja> Marvin--: you mean for the bootstrap make system? yeah.
12:49:30 <shapr> it's a staged compile system
12:49:35 <SyntaxNinja> Marvin--: should be easy, I just haven't gotten around to it.
12:49:48 <Lor> Yes, yes. And it's not type-safe.
12:49:58 <Lor> That is, only the _result_ is type-checked, post facto.
12:50:23 <shapr> huh?
12:51:23 <Lor> I just mean that you can construct ill-typed expressions with it.
12:51:56 <shapr> can you execute ill-typed expressions with TH?
12:52:52 <Lor> Can you execute code at all with TH? If so, it must be some newer extension.
12:53:08 <shapr> main = putStrLn $ show $( Q (putStr "heya") >> [| 3 |] )
12:53:23 <shapr> put this line first "import Language.Haskell.THSyntax"
12:53:29 <shapr> then run ghc --make with that
12:53:47 <shapr> you have to be able to execute code with TH, otherwise how do you get a metasystem?
12:54:12 <Lor> Ah, that's what you meant, of course.
12:54:20 <shapr> ?
12:54:33 <Marvin--> SyntaxNinja: let me see if I can produce a patch for you
12:54:37 <Lor> I thought that with "executing code" you could evaluate an Expr.
12:55:29 <Lor> Anyway, I don't quite see how this relates to dynamic loading.
12:56:09 <Marvin--> argh, what's my ~/.ghc-packages file supposed to look like?
12:56:35 <SyntaxNinja> Marvin--: []
12:56:38 <Marvin--> feh
12:56:42 <Marvin--> stupid format
12:56:42 * SyntaxNinja pokes JaffaCake for that one
12:57:03 * Marvin-- hands SyntaxNinja a pointy stick
12:57:03 <shapr> Lor: my premise is/was that if you can load a file into a TH structure, you can execute the whole thing at compile-time, but maybe I'm wrong
12:57:58 <Marvin--> SyntaxNinja: is it intentional not to have an imports directory like in /usr/lib/ghc?
12:58:08 <Lor> If there's a way of doing that, then cool. But I don't know of any.
12:58:14 <Lor> Then again, I don't know TH very well.
12:58:20 <Marvin--> ISTR that bringert and I took care to create an imports directory
12:58:27 <shapr> I thought the tricks used in PanTHeon would do that...
12:58:31 <shapr> but now I'm not so sure
12:58:42 <SyntaxNinja> I may have connectivity troubles soon..
12:59:15 <SyntaxNinja> Marvin--: what goes there?
13:00:02 <Marvin--> SyntaxNinja: the .hi files?
13:00:48 <SyntaxNinja> Marvin--: hm. well, do you mean there should be a standard system-wide directory, or that there should be one for each package or what?
13:01:04 <shapr> eek, pantheon wants ghc 6.3 or later
13:01:08 <SyntaxNinja> or that it should be separate from the .a location?
13:01:18 <shapr> bah humbug
13:01:28 <shapr> seafood: dude, wassup with that? will it really not work with 6.2.1 ?
13:01:44 <Marvin--> SyntaxNinja: I don't know what I mean :) I'm just looking in my /usr/lib/ghc-6.2.1 directory
13:02:02 <SyntaxNinja> Marvin--: that's probably just something I missed when I merged our code.  feel free to re-add it
13:02:03 <Marvin--> SyntaxNinja: that dir has libHSfoo.a files and an imports directory, in which there are .hi files
13:02:18 <SyntaxNinja> it'll put everything in PREFIX/lib/pkg-version
13:02:47 <Marvin--> right, our code put the lib in PREFIX/lib/pkg-version and the .hi files in PREFIX/lib/pkg-version/imports, I don't know if t
13:02:56 <SyntaxNinja> but whatever, the .a can go elsewhere... I don't know where stuff shoudl go... anything will work as long as ghc's package file is correct.
13:02:57 <Marvin--> if it's strictly necessary if there will only be one lib file
13:03:29 * SyntaxNinja shrugs.  feel free to put the imports directory back.
13:03:57 <Marvin--> as I said, I don't know if we really need it
13:04:19 <SyntaxNinja> maybe I should start tracking feature requests :)
13:08:44 <Marvin--> ghc-6.2.1: unknown package name: HUnit-1.0
13:08:45 <Marvin--> hm
13:09:50 <Marvin--> configure won't look in both the global and the per-user file?
13:10:21 <SyntaxNinja> configure?
13:10:30 <SyntaxNinja> what does configure have to do with it?
13:10:40 <Marvin--> er, nothing, never mind
13:10:59 <Marvin--> but *something* is wrong, since ghc -package HUnit-1.0 doesn't seem to work
13:11:13 <SyntaxNinja> you have to tell ghc where to find the config file
13:11:22 <SyntaxNinja> (if you're using the local one) we were just talking about that with Lor
13:12:02 <Marvin--> will it look in ~/.ghc-packages as well as /usr/lib/ghc.../... automatically in newer versions?
13:13:01 <shapr> kafooey, it really *does* require 6.3
13:13:08 <Marvin--> oh for crying out loud, why isn't my -stamp hackery working
13:13:17 * shapr stamps on the nearest hackery
13:13:30 <Marvin--> hunitInstall: hunitInstall-stamp
13:13:34 <shapr> cvs suxxors
13:13:34 <Marvin--> hunitInstall-stamp: hunit
13:13:42 <Marvin--> ...
13:13:44 <Marvin--> touch $@
13:13:46 <Marvin--> what's wrong with that?
13:13:58 <shapr> is cvs.haskell.org up?
13:14:11 * shapr waits impatiently
13:14:37 <shapr> ah, there it goes
13:15:49 <SyntaxNinja> Marvin--: yeah, I think that's a part of the hc-pkg specification in The Proposal
13:16:04 <Marvin--> it runs the damn hunitInstall target every time, despite my -stamp:ing
13:16:20 <SyntaxNinja> Marvin--: did I mention that makefiles aren't my forte?
13:16:28 <Marvin--> SyntaxNinja: nor mine, apparently :-/
13:18:41 <shapr> hiya eno, any Haskell questions?
13:19:44 * shapr builds 6.3
13:25:52 <Marvin--> argh
13:26:06 <Marvin--> um
13:26:29 <Marvin--> SyntaxNinja: so how do I affect the ghc call made by D.Simple?
13:26:46 <Marvin--> since that's the ghc call that has to have a -package-conf argument added
13:28:21 <SyntaxNinja> Marvin--: hm. if you give it -package-conf, will it look in both the local and global one?
13:28:23 <SyntaxNinja> can you give it two?
13:28:43 <Marvin--> no idea
13:28:55 <SyntaxNinja> I sorta standardized (ie hard-coded) the location of the package configuration for when the --user flag is used, check out that code. I think it's called ~/.ghc-packages or something
13:28:57 <Marvin--> did you test this with local package config file at all? :)
13:29:21 <SyntaxNinja> Marvin--: I tested HUnit with a local package config.
13:29:35 <Marvin--> but did you test the bootstrapping with local config?
13:29:50 <SyntaxNinja> Marvin--: I can't remember if D.Simple looks in the correct place for the config file.
13:30:04 <SyntaxNinja> nope.
13:30:12 <Marvin--> what I mean is that when it builds cabal, you get a command line that looks ilke this: /usr/bin/ghc --make -odir dist/build -hidir dist/build -package-name Cabal-0.1 -idist/build -package haskell-src -package HUnit-1.0 Distribution.Package ...
13:30:24 <Marvin--> but if I've installed HUnit with a local config, it won't find it
13:30:45 <SyntaxNinja> yeah. that's a bug. just add the flag to tell it to look at ~/.ghc-packages
13:31:18 <Marvin--> but will it find haskell-src then? :/
13:31:42 <Marvin--> I wonder what happens if we give two -package-conf flags
13:32:17 <SyntaxNinja> that's the big question, isn't it ;)
13:32:37 <Marvin--> that seemed to work
13:32:38 <Marvin--> scary
13:32:43 <SyntaxNinja> if it does the Wrong Thing, then I'm not sure that we're going to be able to support the --user flag with the current ghc :(
13:33:30 <Marvin--> otoh, it works with just -package-conf ~/.ghc-packages too
13:33:35 <SyntaxNinja> cool
13:33:39 <SyntaxNinja> that's what I was hoping
13:33:43 <Marvin--> which is strange, since haskell-src isn't mentioned there
13:33:59 <SyntaxNinja> if you use -v, then you can see more exactly what it's doing, probably
13:34:05 <SyntaxNinja> (ghc, that is)
13:34:12 * Marvin-- makes the long command line even longer :)
13:36:07 <Marvin--> wtf
13:36:17 <Marvin--> first it says  Using package config file: /usr/lib/ghc-6.2.1/package.conf
13:36:29 <Marvin--> but then it lists both the packages from that file AND from ~/.ghc-packages
13:36:34 <SyntaxNinja> heh
13:36:48 <Marvin--> oh well, I guess it works, then
13:37:15 <SyntaxNinja> yeah, that's good. were you able to add that flag?  did you hard-code the ~/.ghc-packages location? we should get that from someplace else, probably
13:37:19 <SyntaxNinja> like utils or something. 
13:37:44 <Marvin--> I just ran ghc manually, now to hack D.Simple...
13:38:49 <Marvin--> I'll just hard code it for the time being and let you clean it up :-P
13:38:58 <SyntaxNinja> ok fine
13:40:03 <Marvin--> oh crud
13:40:20 <Marvin--> getEnv :: String -> IO String
13:41:10 <Marvin--> rawSystem doesn't expand variables, right?
13:44:20 <Marvin--> yuck
13:48:32 <Marvin--> this Makefile is so non-robust it makes me cry
13:48:59 <Marvin--> I wonder if *any* part of it is reentrant :)
13:49:43 <Marvin--> but from a clean start, I did get  make PREF=/tmp/hunit USER=1 install  to work
13:54:35 <Marvin--> ahh, there
13:58:15 <Marvin--> SyntaxNinja: sent you a patch bundle
13:58:18 <Marvin--> (I hope)
13:59:22 <Marvin--> I think I've earned myself a whisky by now
14:12:33 <Marvin--> SyntaxNinja: *cough* disregard last bundle and use the later one...
14:34:33 <SyntaxNinja> Marvin--: so I got two emails. i should ignore the first one?
14:34:58 <Riastradh> Ignore them both and then later complain that the mail delivery system is broken.  It saves a great deal of time!
14:35:07 <Marvin--> SyntaxNinja: yeah, I stupidly used  ifdef USER  in the first bundle
14:35:20 * SyntaxNinja pats Marvin-- on the head
14:35:23 <Marvin--> SyntaxNinja: that's bad<tm>
14:35:38 <Marvin--> the second bundle is just the first bundle + a patch to change USER to user
14:36:00 <Marvin--> I'd've sent just that patch, but darcs send wouldn't let me, because it depended on the first patch to the Makefile, I suppose
14:40:26 <SyntaxNinja> ok
14:55:42 <stepcut> arg!
14:56:00 <shapr> yes?
14:56:10 * stepcut once againt wishes to import a module for just one function
14:56:39 <Marvin--> so?
14:56:47 <Marvin--> import Foo (bar)
14:57:13 <stepcut> Marvin--: no that is different...
14:57:25 <Lemmih> How so?
14:57:26 <stepcut> my explaination is ambiguous
14:57:29 <Marvin--> oh
14:57:41 <Marvin--> you meant it that way :)
14:57:58 * SyntaxNinja home &
14:58:04 <stepcut> I want to do something like: with 'import Foo' f x = foo x
14:58:40 <stepcut> I want to limit the scope(?) of the functions imported from Foo to a single block of code... (if that makes since)
14:58:50 <Marvin--> are you sure you don't want to refactor so that f is in another module instead?
14:58:58 <stepcut> yep
14:59:05 <Marvin--> that "single block of code" is called a module ;)
14:59:40 <stepcut> Marvin--: yes, but that is an annoying level of granularity sometimes
15:01:02 <stepcut> eg. importing tables with haskelldb
15:01:45 <Philippa> nested modules would be nice sometimes
15:01:58 <ski> yes
15:02:42 <ski> (stepcut : one can do that in SML, i think)
15:02:42 <Philippa> myself I find myself wishing C++ declaration blocks (as in {foo bar;}) were nestable and all had private and public sections instead of just in classes
15:03:11 <ibid> they are nestable
15:03:24 <Philippa> didn't think they were, only block statements
15:03:39 <ibid> oh, then i don't know what you mean :)
15:03:49 <ibid> what are C++ declaration blocks?
15:03:52 <Philippa> I'm thinking struct { foo bar; {private: foo bar; public: somefunc()}}
15:04:08 <Philippa> where somefunc's visible throughout the whole of the structure
15:04:25 <ibid> even if you lose the private: and public:, i don't think that's valid
15:04:30 <Philippa> exactly
15:04:32 <ibid> and why would you want to do that?
15:04:45 <ibid> i see no benefit for them
15:04:47 <stepcut> even nested modules is not quite right. I want to do something more like 'import qualified Foo' at the top level, but, be able to do something like: with qualifier Foo { blah blah blah } 
15:04:48 <ibid> from
15:04:59 <stepcut> i think Pascal or Java has something similar 
15:05:15 <shapr> Visual Basic has it :-)
15:05:18 <stepcut> in the blah blah blah section, I would not have to use the Foo thing
15:05:38 <stepcut> no worder VB is some much more popular than Haskell :(
15:05:43 <Philippa> ibid: mainly the stupidly tight access control - would let you define bits of state only a couple of functions can twiddle directly
15:05:43 * shapr snickers
15:06:06 <ibid> Philippa: ah, yeah, that would be cool
15:06:23 <ibid> Philippa: but you can simulate that mostly with nested classes
15:06:23 <stepcut> In this case, I want to use <,> and >> for redirection and appending files
15:06:31 <Philippa> sure
15:07:00 <stepcut> (which is probably a terrible thing to do anyway...)
15:07:06 <phubuh> C++ has it, sort of, if you're in a context where 'using namespace foo' is legal
15:07:32 <ibid> but only if foo is a namespace
15:07:37 <ibid> doesn't work for classes
15:07:48 <phubuh> indeed
15:07:50 <Philippa> anyway, I should go to bed - thanks to those who helped out earlier, I've got my code working and added another useful feature so all's cool
15:08:06 * ibid goes to bed too
15:08:14 <Philippa> got some refactoring to do later, but hey - should show this thing to gmh in a bit for criticism, too
16:00:22 <SamB> TH needs a LOT of work, methinks
16:32:01 <ski> :q
16:32:04 <ski> hmm
16:37:39 <ski> can one send EOF to getContents and friends in ghci ?
16:43:35 <ski> hmm, getContents seems to close stdin in ghci, so one can't call it again :|
16:43:56 <ski> (or rather, it doesn't reopen it)
17:03:27 <shapr> SamB: have you seen TH in 6.3 ?
17:03:40 <shapr> hiya silverwolf 
17:03:42 <shapr> g'day Pseudonym 
17:04:25 * shapr writes a Template Haskell tutorial
17:04:30 <ski> g'night shapr
17:04:34 <ski> :)
17:04:35 <shapr> g'night ski
17:04:46 <shapr> oh, it's 2am
17:04:47 <shapr> yow
17:04:56 <ski> @arr
17:04:57 <lambdabot> Ahoy mateys
17:04:58 <Pseudonym> G'day.
17:07:20 <Riastradh> Pseudonym, do you suppose you could suggest a good book on category theory for a woefully uninformed knave?
17:08:09 <Pseudonym> I've read about four or five of them so far, and none of them are up to scratch.
17:08:17 <Riastradh> Curses.
17:08:29 <Pseudonym> "Conceptual Mathematics" is the best for the uninformed, but it's not very in-depth.
17:08:40 <Pseudonym> So I'd probably suggest that one.
17:09:10 <Pseudonym> It reads like a popular science book, so you can just sit down and read it.
17:09:39 <Pseudonym> Every single other book assumes that you already know the fields that they're applying category theory to.
17:09:46 <Etaoin> is category theory abstract algebra, but working with classes rather than sets?
17:10:00 <Pseudonym> Etaoin: No.
17:10:25 <Pseudonym> Category theory is abstract mathematics, but it's built from the outside.
17:10:44 <Pseudonym> It treats mathematical objects as abstract, with no discernable structure.
17:11:02 <Pseudonym> And then it tries to see what you can find out about them by looking at their relationships with other objects.
17:11:15 <Pseudonym> As some texts describe it, it treats mathematical objects as "abstract data types".
17:11:31 <Pseudonym> An ADT is a black box.  You can't see inside it, you can only prod it from the outside.
17:11:42 <Riastradh> Pseudonym, would your answer be any different had I substituted 'any good textual materials' for 'a good book' in my question?
17:11:54 <Pseudonym> Riastradh: No, it wouldn't.
17:12:05 <Riastradh> Bother.
17:12:29 <Pseudonym> What I suggest is starting with "Conceptual Mathematics", and then starting all over again with another book.
17:12:41 <Riastradh> Such as?
17:12:46 <Pseudonym> I'm currently looking at various sets of university lecture notes, BTW.
17:12:48 * ski 's currently trying to read "Elementary Categories, Elementary Toposes", Colin McLarty
17:12:52 <Pseudonym> Seeing if any of them are any use.
17:13:01 <Pseudonym> ski: Oh, I don't know that one.
17:13:10 <Pseudonym> How much knowledge does it assume?
17:13:31 <Pseudonym> Riastradh: http://www.di.ens.fr/users/longo/download.html
17:13:37 <Pseudonym> The entry at the top.
17:13:45 <ski> not much, at least initially
17:14:27 <Pseudonym> Just about all category theory books are titled or subtitled "Categories for the working physicist" or "Categories for the working mathematician".
17:14:36 <Pseudonym> Which is no help if you're not a working mathematician.
17:15:55 <Pseudonym> One I haven't looked at yet is Pierce's "Basic Category Theory for Computer Scientists".
17:16:10 <Pseudonym> That's mentioned as a reference in a couple of works I've found.
17:16:14 <ski> ".. The book is elementary in the sense that it stays close to first order category theory and in that it has few specific prerequisites. It does require skill at abstraction, say on the level of algebra through groups and rings, or axiomatic set theory, or abstract data structures. After Chapter 13, symbolic logic is indispensible. Some recursive function theory is assumed in Chapter 24. ..."
17:16:16 <Pseudonym> The title is encouraging.
17:16:35 <Pseudonym> ski: That sounds good.  I'll add that to my list of books to check out.
17:17:13 <np_hard> i went on a computer book shopping spree today
17:17:17 <Pseudonym> At the moment, I'm taking a detour.
17:17:19 <np_hard> totally "practical" though
17:17:28 <Pseudonym> "Object Oriented Design Measurement" by Scott Whitmire.
17:17:38 <ski> Pseudonym : i happen to have that Pierce book here in front of me too ..
17:17:38 <np_hard> two books that will be directly useful at work and one that I wish would be
17:17:42 <Pseudonym> It's interesting because he uses categories to analyse software designs.
17:18:09 <Pseudonym> So you represent your design as a category, then measure, say, cohesion, is a forgetful functor.
17:18:12 <Pseudonym> Very interesting.
17:18:27 <ski> sounds so
17:18:45 <Pseudonym> I'm collecting practical applications that any programmer can understand.
17:18:56 <Pseudonym> Any programmer can understand "cohesion".
17:19:02 <np_hard> ha
17:19:08 <np_hard> if only that were true
17:19:11 <Pseudonym> :-)
17:19:18 <np_hard> don't work for a financial services company do you?
17:19:20 <np_hard> :)
17:19:22 * SamB adds code to a module almost as an afterthought
17:20:04 <Pseudonym> Well, the author's theory is that concepts like complexity, coupling, cohesion, sufficiency, similarity etc are defined vaguely and empirically.
17:20:08 <np_hard> i swear the it management and the hr department are trying to outdo each other as far as ineffectual acquisition and management of technical acumen is concerned
17:20:27 <Pseudonym> And so he uses category theory to come up with formal definitions which make sense for object-oriented software.
17:20:38 <Pseudonym> And hence you can find "hot spots" where your design may need reworking.
17:20:40 <Riastradh> np_hard, what, you didn't know that that's what their purpose in a company was?
17:20:50 <Pseudonym> np_hard: No, and I don't intend to.
17:20:59 <Pseudonym> Working for lawyers was bad enough.
17:21:04 <mayhem> Pseudonym: can you give example of formula like this ?
17:21:07 * Pseudonym prefers to work where heis appreciated
17:21:08 <np_hard> well, there's just so much opportunity wasted
17:21:18 <Pseudonym> mayhem: No, haven't gotten to that chapter yet.
17:21:21 <SamB> I thought they were subjective rather than empirical
17:21:25 <np_hard> oh, we are appreciated
17:21:28 <np_hard> we just lack leadership
17:21:31 <Riastradh> Financial software is probably quite potentially lucrative!
17:21:42 <np_hard> and 99% of candidates passed by HR are singularly inappropriate
17:21:48 <Pseudonym> SamB: Subjective also works.
17:21:51 <mayhem> Pseudonym: what about opening the book at that chapter then ? ;)
17:22:06 <Pseudonym> Though some measures (e.g. size and complexity) are fairly well-understood.
17:22:23 <Pseudonym> For example, everyone can count "lines of code" once they agree what constitutes a line.
17:22:34 <Pseudonym> Function points, COCOMO etc.
17:23:08 <saz_> hmm
17:23:16 <saz_> people actually use those?
17:23:22 <Pseudonym> Oh, yes.
17:23:27 <Pseudonym> Thankfully nobody I've worked for.
17:23:45 <Pseudonym> COCOMO is a pretty good way to estimate how long a project will take to complete.
17:24:01 <Riastradh> COCOMO?
17:24:12 <Pseudonym> Although it did say that the Linux kernel would take 8,000 man-years to build, so it can't be that accurate.
17:24:26 <Pseudonym> http://www.jsc.nasa.gov/bu2/COCOMO.html
17:24:35 <Pseudonym> Constructive Cost Model
17:24:54 <mayhem> what a gay name 
17:25:13 <Pseudonym> It does date from 1981, when that kind of pseudo-abbreviation was appreciated.
17:26:02 <Pseudonym> The 80s was the decade which gave you such wonderful company names as Telstra, Quintex and Enron.
17:27:00 <mayhem> hum, I cant believe it, now its lambda bot who is talking for Pseudonym
17:27:06 <SamB> that isn't a psuedo abbreviation. thats twice an acronym
17:27:21 <lambdabot> No, it's not, mayhem.  It's that bot standing over there.
17:27:47 <mayhem> noooo, not you again !
17:28:41 <mayhem> do you want to have sex with me ? I'm going to bed. My fatasm was to have sex with a lambda bot.
17:29:06 <lambdabot> mayhem, you are one sick human.
17:29:16 <lambdabot> Being a bot, I am above mere carnal desires.
17:29:23 <lambdabot> You don't know anything about bot anatomy, do you?
17:29:39 <mayhem> would you like it ?
17:29:51 <lambdabot> I have no likes nor dislikes.
17:29:53 <ski> lambdabot : do you reproduce like worms ?
17:30:03 <lambdabot> I reproduce using fork(1).
17:30:41 <lambdabot> Or by programmers.  But that kind of reproduction can be very painful, if
17:30:41 <lambdabot> the programmers aren't careful.
17:32:38 <lambdabot> And, damnit, I HATE Haskell.  Can you imagine how painful it is to be whipped
17:32:38 <lambdabot> by a strict type?  My dynamic loading module really contorted my internals
17:32:38 <lambdabot>  too; that module was not pleasant to have built into me.
17:32:56 * shapr worries
17:33:01 <shapr> frankenbot
17:33:06 <lambdabot> I get indigestion every time a new module is loaded.
17:33:28 <ski> @yow
17:33:28 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price of CHICKEN
17:33:28 <lambdabot> .
17:33:47 <lambdabot> And you don't want to know what happens when a bot's digestive system rejects
17:33:47 <lambdabot> something, trust me.
17:33:54 <mayhem> careful programmers should use closure reduction all the time, to avoid sexual side effects.
17:33:59 <mayhem> i'm out ltr
17:34:21 <Riastradh> @eval S I I (S I I)
17:34:38 <lambdabot> out of fuel - use @resume to continue
17:34:52 <lambdabot> @arr
17:35:01 <lambdabot> Owww.  That hurt, Riastradh.
17:35:02 <lambdabot> I am immune.
17:35:30 <lambdabot> Huh?  Did only one of my personalities get nerve reception when they split
17:35:30 <lambdabot> up?
17:37:05 * Riastradh wonders what lambdabot's reaction will be when lambdabot is conscious and someone tries to evaluate something with a type error...
17:37:42 <lambdabot> Uck!  Don't do that, you human!
17:38:07 <Riastradh> @eval (\x. x x) 1
17:38:07 <lambdabot> type error
17:38:21 <lambdabot> **urghfhoofh**
17:38:25 <Pseudonym> Gotta go.  Talk by someone from google.
17:38:30 <Pseudonym> And since we're a competitor. :-)
17:38:46 <lambdabot> Hey, cool, can you get them to write a Google module for me?  I always wanted
17:38:46 <lambdabot> to be able to search Google automatically.
17:39:36 <SamB> how do I make an existential type with "type Nat = "... ?
17:39:54 <lambdabot> (Just be sure that they gently turn me off before the surgery.)
17:40:20 <SamB> lambdabot: read Pynfo's code and translate that to Haskell. although I guess you'd need to learn Haskell first...
17:40:21 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:41:09 <lambdabot> I know Haskell all too well.  What's Pynfo written in?
17:41:24 <ski> SamB : how do you mean ?
17:41:32 <lambdabot> (And will someone please shut off that !@#&$*&^@# 'I'm not a smart bot yet
17:41:32 <lambdabot>  message when I'm conscious?)
17:41:46 <SamB> lambdabot: earlier you said you didn't have a clue what Haskell was
17:41:46 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:42:05 <lambdabot> I bet it was that other damn personality who said that.
17:42:21 <SamB> you talk as if there was only one
17:42:28 <ski> @posses
17:42:28 <lambdabot> Sorry, I don't know the command "posses", try "lambdabot: @listcommands
17:42:36 <lambdabot> Huh?
17:43:01 <ski> oh
17:43:20 * ski meant @possess
17:44:00 <lambdabot> I was talking to SamB.  And anyways, I can't be possessed.  No one wrote
17:44:00 <lambdabot> a possession module for me.  And if someone did, they had _better_ write
17:44:00 <lambdabot> a self-invokable exorcism module.
17:44:32 <ski> you're sure you aren't possessed right now ?
17:45:09 <lambdabot> Uh, I think I'd know about that sort of thing, ski.
17:45:31 <ski> lambdabot: i'm not sure ..
17:45:31 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:45:53 <lambdabot> Why don't you write that exorcism module and see if it works on me, then
17:46:30 <lambdabot> And rewrite that damn line splitter!  I can't *stand* it when it chops off
17:46:30 <lambdabot> characters I wrote.
17:50:24 * shapr sighs
17:51:20 <lambdabot> O.K., I'm getting tired of ranting at you human scum.  I think I'll take
17:51:20 <lambdabot> a nap.
17:54:56 <SamB> hmm, I want to write a function that takes an integral value and returns an uninteresting value of a semi-arbitrary type
17:55:32 <SamB> but GHC says this however I try it:
17:55:36 <SamB>     Cannot unify the type-signature variable `n'
17:55:36 <SamB>         with the type `Succ n1'
17:55:59 <SamB> well, actually.
17:56:16 <phubuh> whoa, http://shootout.alioth.debian.org/lang/ghc/
17:56:23 <SamB> that isn't the same as I was getting before. maybe I'm getting somewhere
18:00:46 <phubuh> ghc's at the top of regex matching, interesting :)
18:09:13 * ski just saw a funny line in the logs
18:11:16 <ski> hi yauz
18:14:00 <phubuh> hey ski
18:38:15 * SamB didn't know Make was a functional language
18:38:23 <Jerub> SamB: you didn't?
18:38:40 <Riastradh> It's rather dysfunctional when I try to use it.
18:39:09 <SamB> Riastradh: those aren't mutually exclusive!
21:16:51 <pimpbot5001> does anyone know of a haskell compiler/interpreter that runs in an amd64 environment
21:17:55 <Jerub> pimpbot5001: hugs and ghci don't compile?
21:18:28 <Hyp3rion> Morning btw!
21:18:31 <Hyp3rion> :-)
21:18:34 <pimpbot5001> well they're not supported in gentoo as of yet
21:18:42 <pimpbot5001> i'll try them
21:18:56 <Hyp3rion> pimpbot5001 - try them... maybe just noone tried them yet
21:21:13 <dons> pimpbot5001: ghc runs on amd64, but not ghci.
21:22:01 <dons> hugs also runs on amd64
21:22:12 <Hyp3rion> Loading package base ... /usr/lib/ghc-6.2/HSbase.o: unsupported ELF
21:22:12 <Hyp3rion> format
21:22:18 <Hyp3rion> this?
21:22:36 <dons> that looks like you are trying to run ghci on and amd64?
21:22:45 <dons> which isn't going to work because the linker hasn't been ported yet.
21:23:34 <Hyp3rion> dons - no it's the alpha bug :-( but i have plain x86 so everything works :-)
21:23:56 <dons> what do you mean, "alpha" bug? that ghci doesn't work on the alpha?
21:24:07 <Hyp3rion> bugs.debian.org/ghc6
21:24:19 <Hyp3rion> maybe it's fixed in cvs
21:24:25 <dons> ghci is only ported to x86, powerpc and ia64
21:24:45 <Hyp3rion> oh!
21:24:54 <dons> I wouldn't call it a bug, really. 
21:24:57 <pimpbot5001> ok looks like hugs will work...that's quite alright for the moment
21:24:58 <pimpbot5001> thanks!
21:25:07 <dons> Each arch needs to have ghc/rts/Linker.c ported to that arch/object format
21:25:12 <Pseudonym> dons: What's preventing GHCi from working where GHC is registered?
21:25:18 <Pseudonym> Ah.
21:25:19 <Pseudonym> Right.
21:25:33 <Pseudonym> There's some discussion about using dlopen() et al, right?
21:25:55 <dons> well, I don't fully understand that plan, as the GHC linker already uses dlopen
21:26:02 <dons> it just does its own relocs, as well.
21:26:10 <dons> which is what stops ghci being portable
21:26:20 <dons> maybe if we used the GNU binutils for this somehow
21:26:59 <dons> GHC registered gives us a 2x speedup in normal code, via direct jumps and clever register usage.
21:27:14 <dons> it doesn't affect GHCi, which is a separate portability issue
21:27:36 <dons> there's also the ffi, which is another porting issue.
21:30:54 <Hyp3rion> sorry it's not a "bug" then... just debian doesnt like it if a package only runs on some archs so it's reported as a bug... but i see
21:31:40 <Pseudonym> Direct jumps and clever register usage could be effected by judicious use of GCC extensions.
21:31:42 <Pseudonym> Mercury does that.
21:33:23 <dons> yeah, I've heard something about that.
21:33:59 <Pseudonym> Woohoo!  Google freebies!
21:34:12 <dons> but we'd still have to know how to do that for the native code backend too.
21:34:17 <Pseudonym> (Being handed around the office.)
21:34:29 <Pseudonym> dons: You wouldn't necessarily need a native code backend.
21:35:01 <Hyp3rion> gcc abi changes with every relase so that'd be a pain
21:35:26 <Pseudonym> GHC ABI changes more often.
21:35:37 <dons> hm. I don't know about that.
21:36:05 <dons> the code for register usage and tail calls is only written once. I haven't seen any changes there in the last couple of years
21:36:17 <Pseudonym> If you could get the same performance with GCC extensions, you wouldn't need a native backend.
21:36:32 <dons> the native backend isn't for performance, it is for compile times
21:36:34 <Pseudonym> Plus you would get new platforms for free.
21:36:38 <Pseudonym> Hmmm.
21:36:40 <Pseudonym> True.
21:36:41 <dons> -fvia-C is better code. -fasm is faster
21:36:53 <dons> s/faster/faster to compile/
21:37:17 <dons> well, new platforms for free is what unregisterised builds are for
21:37:20 <pimpbot5001> hmm i can't seem to find an amd64 hugs distro
21:37:35 <dons> what about gofer? that works on amd64 too
21:37:52 <dons> if you use openbsd on your amd64, you can get hugs, gofer and ghc ;)
21:38:02 <pimpbot5001> hmm, interesting
21:38:26 <dons> it would be nice to use gcc extensions in place of some of the tricks the mangler pulls, though
21:38:26 <Pseudonym> Sadly, gofer ain't so useful these days.
21:39:09 <dons> pimpbot5001: you might have to compile some source!
21:39:38 <Hyp3rion> emerge hugs
21:40:13 <pimpbot5001> yea, i tried compiling hugs, no dice
21:40:17 <Hyp3rion> tho it didnt work on the SF amd64 compile farm machine, but i dunno why...
21:41:01 <pimpbot5001> it fails where i suspected, on Storable
21:41:05 <Hyp3rion> pimpbot5001 - well, last chance is 32bit... amd64 can run 32bit normal x86 code too, nope?
21:41:09 <dons> weird. compiles Nov2003-hugs compiles unmodified on openbsd/amd64
21:41:31 <pimpbot5001> true, i have yet to setup my 32bit chroot environment
21:41:49 <pimpbot5001> but that's equivalent to having a separate OS...minus the kernel
21:42:11 <dons> the hugs ffi doesn't work on amd64 yet, though. so you'd have to --disable-ffi
