00:11:45 <neologism> hi
00:11:57 <neologism> can someone tell me what "millners polymorphism" is?
00:17:13 <shammah> I would guess that is "Milner's Polymorphism", which would refer to Robin Milner the second half of Hindley-Milner Type Inferencing.
00:18:00 <shammah> It also probably referrs to the ad-hoc polymorphism you get when using good type-inferencing.
00:19:03 <shammah> anyway, do a google for milner's polymorphism and see what comes up.
00:19:24 <neologism> google is silent (thats why I ask here)
00:22:40 <Verbophobe> Try with only one 'l'
00:22:49 <shammah> www.rbjones.com/rbjpub/logic/log036.htm , www.seas.upenn.edu/~sweirich/ types/archive/1988/msg00127.html , www.lfcs.inf.ed.ac.uk/reports/92/ECS-LFCS-92-238/  <= first three links from google.  All contain the phrase "milner's polymorphism"
00:23:26 <neologism>     Web  Results 1 - 1 of 1 for millner's polymorphism. (0.26 seconds)
00:23:29 <neologism> strange ;)
00:23:31 <neologism> thnx anyway
00:23:37 <shammah> Granted none of them answer your question as such, but I believe the fourth (research.microsoft.com/Users/ luca/Papers/OnUnderstanding.A4.pdf) does.
00:23:37 <Verbophobe> One 'l', man.
00:23:41 <neologism> yes, I see now
00:29:58 <neologism> huh, thats quite big
00:30:15 <neologism> can you show me that polymorphism in haskells terms?
00:34:25 <ibid> my guess would have been that milner polymorphism is let-polymorphism inherent in hm typing
00:34:54 <ibid> (not having looked at the urls:)
00:35:42 <neologism> huh?
00:35:48 <neologism> I dont understand
00:36:45 <ibid> ie. generic polymorphism where generalization happens only in let (and its syntactic sugar variations)
00:37:16 <neologism> oh
00:37:20 <neologism> ie
00:38:42 <neologism> let c <- readLn::IO Int
00:38:46 <neologism> something like this?
00:38:54 <neologism> ie. that readLn has no infered type?
00:38:59 <ibid> that's let but not polymorphism :)
00:39:12 <ibid> no, that's not what i meant
00:39:29 <neologism> so, what you menat?
00:39:53 <ibid> do you know what generic polymorphism means?
00:40:02 <neologism> probably not
00:40:24 <neologism> does it mean that action is specialized on a type basis
00:40:25 <neologism> ?
00:40:42 <ibid> ok, in short, an expression is generically polymorphic if its type contains bound type variables
00:40:56 <neologism> ie. Tree a ?
00:40:57 <ibid> no, that's ad-hoc polymorphism
00:41:11 <ibid> close :)
00:41:12 <neologism> so show me an example pls
00:41:15 <ibid> more like id : a -> a
00:41:23 <neologism> oh
00:41:39 <neologism> that arguments (or result) type depends on a type of its arguments ?
00:41:45 <ibid> the idea is that the type should really be written id : forall a. a -> a
00:41:56 <neologism> yes, I think I get the idea
00:42:07 <ibid> hence the "bound"
00:42:11 <neologism> yes ;)
00:42:27 <neologism> so that is your let-polymorphism?
00:42:45 <ibid> no, that's generic polymorphism
00:42:55 <neologism> s/that/what
00:42:59 <neologism> I was asking a question
00:43:05 <neologism> so what is your let-polymorphism?
00:44:12 <ibid> in let-polymorphism \x -> x is NOT polymorphic; it's type is a -> a but here a is a free, not bound variable. it becomes polymorphic in let; for example, let id = \x -> x: now id : forall a. a -> a
00:44:41 <ibid> let-polymorphism is a restricted form of generic polymorphism where generalization (ie. introducing the forall quantifier) happens only in let
00:45:19 <ibid> it's not *my*
00:45:20 <ibid> :)
00:45:41 <neologism> I am afraid I dont understand the difference
00:45:52 <neologism> between \x -> x and let id = \x -> x
00:46:04 <neologism> one is anonymous (lambda) and second is just named
00:46:09 <neologism> but both the same, arent they?
00:46:20 <ibid> in let-polymorphism they are not the same
00:46:38 <ibid> in the more general generic polymorphism it is the same
00:47:46 <neologism> hm.... I am slowly getting the idea ;)
00:48:35 <ibid> the general version is of course more powerful and hence more desirable in itself but unfortunately type inference in it is undecidable
00:48:52 <neologism> ie (in a terms of oop) you INSTANCE the type so its not polymorphic
00:48:56 <neologism> am I correct (at least a bit) ?
00:49:41 <ibid> you can't think of it imn terms of oop
00:50:17 <neologism> I meant that a -> a is general idea
00:50:29 <neologism> but let id = a -> a is a instance (actually id) which is not general
00:50:42 <ibid> and i don't understand how i should interpret the oo term INSTANCE in this case so that it would make sense
00:50:54 <ibid> let id = a -> a makes no sense
00:51:02 <ibid> unless you have let type expressions
00:52:22 <neologism> yes, thats what I mean
00:52:34 <ibid> what's what you mean?
00:52:38 <neologism> under let-polymorphism
00:52:45 <neologism> its not general since its named
00:52:53 <ibid> ugh
00:52:59 <ibid> it's just the opposite
00:53:03 <ibid> the named one is more general
00:53:15 <ibid> in let-polymorphism
00:53:17 <neologism> huh, so I dont understand it
00:53:32 <ibid> okay
00:53:43 <ibid> you understand usual type expressions, Int, Int->Int etc
00:53:45 <ibid> right?
00:53:53 <neologism> yes
00:53:59 <ibid> and you understand the haskell notion of type variables, a -> Int etc
00:54:01 <ibid> right?
00:54:07 <neologism> yes
00:54:36 <ibid> a not-quite correct explanation is that the haskell version of generic polymorphism (when type classes are ignored) is let-polymorphism
00:55:22 <ibid> the more general version allows you to bind type variables inside type expressions, somewhat like in haskell extended with existential types
00:55:23 <neologism> may you give me some examples of what is and what isnt let-type?
00:56:07 <ibid> any haskell 98 type expression where there are no type classes mentioned is let-polymorphic. more or less
00:56:19 <ibid> type classes are an orthogonal extension
00:56:29 <neologism> a -> Int is let type?
00:57:21 <ibid> there is no such thing as a "let type"; let-polymorphism is a name for a particular, somewhat restricted mechanism for generating generic-polymorphic types
00:57:56 <ibid> the main thing is that a type like (forall a. a) -> Int is not expressible in let-polymorphism
00:58:07 <ibid> which is also not legal haskell 98
00:58:25 <ibid> (but might be allowed by a certain extension used by eg. ghc)
00:59:18 <ibid> if you want to know more about it, i suggest pierce's types book
00:59:57 <neologism> (forall a. a) -> Int is forbidden?
01:00:40 <ibid> ?
01:01:24 <neologism> isnt this the type of length ?
01:01:34 <ibid> benjamic c. pierce, "types and programming languages", mit press, 2002
01:01:37 <neologism> I think its allowed in haskell
01:01:41 <ibid> no, the type of length is [a] -> Int
01:01:44 <ibid> neologism: try it
01:01:57 <neologism> I dont see the difference between (lets say)
01:02:06 <neologism> (forall a. [a]) -> Int and [a] -> Int
01:03:15 <ozone> neologism: the latter has type "forall a. [a] -> Int"
01:03:20 <ozone> where you put the brackets is important
01:03:37 <ozone> the brackets restrict the scope of the forall quantifier
01:03:50 <ozone> beyond that, i think i'll be talking out of my arse
01:04:02 <ozone> i _think_ the type "(forall a. [a]) -> Int" is a rank-2 type
01:04:57 <ibid> i just tried it in ghci
01:05:11 <ibid> it thinks they are the same type, which i suppose makes sense
01:05:17 <neologism> if the brackets limit the scope
01:05:26 <neologism> why does it matter when in that Int there is no a?
01:05:45 <neologism> ah... I got it
01:05:52 <ibid> sorry, my mistake
01:06:06 <neologism> ?
01:06:13 <neologism> I think I got what I did wrong
01:06:14 <ibid> referring to my ghci comment
01:06:20 <neologism> am I mistaken again?
01:06:56 <ibid> i don't know
01:07:07 <ibid> you did not say how you got it :)
01:07:20 <neologism> I mean
01:07:36 <neologism> that there is a difference between (forall a. a -> Int)
01:07:37 <ibid> "my mistake" referred to my claim that ghci thinks they are the same type; my mistake was that i mistyped the forall one
01:07:43 <neologism> and (forall a. a) -> Int
01:07:47 <ibid> yeah
01:07:55 <neologism> now I see the difference
01:08:08 <ibid> try the following in ghci -fglasgow-exts:
01:08:09 <ibid> Prelude> let f :: (forall a.a) -> Int ; f = undefined
01:08:22 <ibid> Prelude> let g :: a -> Int ; g = undefined
01:08:28 <ibid> Prelude>  [f, g]
01:08:42 <ibid> if f and g had the same type, that list should be ok
01:09:51 <neologism> yes, I see
01:10:52 <ibid> i recommend the pierce book if typing interests you :)
01:11:11 <neologism> I think I'll try to get it
01:11:15 <neologism> (the book)
01:11:20 <ibid> :)
01:11:39 <ozone> that's on my amazon.com wishlist, which currently only has a mere USD$400 worth of stuff
01:12:23 <ibid> the difference between general generic polymorphism (essentially, System F and upward) and let-polymorphism is easier to appreciate in the context given by the book
01:12:40 <neologism> I'll see
01:19:58 <neologism> thnx a lot for help!
03:22:31 <musasabi> I am having problems with the Continuation monad, a simple readable example does not seem to work like it would with schme's call/cc.
03:22:41 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/Cont.hs demonstrates the problem.
03:23:29 <musasabi> Invoking a saved continuation does not seem to work properly.
03:24:05 <musasabi> How would I solve this in the right way?
03:35:41 <musasabi> Or are the continuations just simple escape without the power of first class continuations?
05:10:20 <musasabi> Any pointers?
05:27:16 <Cale> Why do you define str if you never use it?
05:32:02 <Cale> also, I'm not so sure that Cont r is an instance of MonadIO.
05:40:12 <musasabi> for the side effect (of course that can be either discarded or returned)
05:40:17 <musasabi> and it changes nothing
06:37:29 * shapr boings
06:37:38 <vegai> howdy!
06:37:45 <thebug> <clang>
06:38:04 <shapr> what's the clang for?
06:38:11 <shapr> good morning #haskell!
06:38:15 <vegai> cellular language
06:38:18 <thebug> 09:37  * shapr boings <- 
06:38:49 <thebug> it appears to be onomatopoeia morning in #haskell
06:38:52 <shapr> thebug: I don't have enough stuff in my pockets to clang when I boing. I do have three keys on a keyring, so there's a small clatter maybe
06:39:17 <thebug> more of a small cacophony of clink in that case, it sounds like
06:39:34 <shapr> ok, that is more accurate
06:40:06 <thebug> ;)
06:41:14 <shapr> right, so...
06:41:21 <shapr> any gtk2hs users here?
06:43:16 <Igloo> I think I've only used gtk+hs, and that a while ago
06:48:30 <shapr> it's magically delicious!
06:49:14 <vegai> you took a taste?
06:49:39 * shapr chews on his copy of gtk2hs
06:51:49 <shapr> y0 desrt, did your mission succeed?
06:53:18 * Igloo wrote some brainfuck yesterday. And accidentally made self-modifying BF by going past the beginning of the data array in a C BF interpretter
06:53:34 <thebug> hehe nice work Igloo
06:54:01 <shapr> haha!
06:54:03 <Igloo> I'm sure BF would be far cooler if the program and PC were part of the buffer
06:54:11 <Heffalump> yes
06:54:14 <shapr> that's a really really cool idea
06:56:33 * Igloo is sure it will already exist somewhere on the web
06:57:55 <shapr> @fortune
06:57:56 <lambdabot> :-) your own self.
06:57:56 <lambdabot>              -- Larry Wall in <199709261754.KAA23761@wall.org>
06:58:00 <shapr> @fortune
06:58:01 <lambdabot> This fortune would be seven words long if it were six words shorter.
06:58:09 <shapr> whoa, that's profound
06:59:00 <vegai> it would also be a dirty lie
06:59:07 <shapr> @fortune
06:59:08 <lambdabot> <Mercury> <CJ|BiZKiT-0-> i can upload to linux server tho
06:59:08 <lambdabot> <Mercury> <CJ|BiZKiT-0-> i got a shell account on one
06:59:08 <lambdabot> <Mercury> <Mercury> Whats it running?
06:59:08 <lambdabot> <Mercury> <CJ|BiZKiT-0-> umm
06:59:08 <lambdabot> <Mercury> <CJ|BiZKiT-0-> apache i think
06:59:09 <lambdabot> <Mercury> Help, please help..
06:59:11 <lambdabot> * Omni chuckles
06:59:45 <vegai> where did that come from?
07:03:53 <shapr> I have users like that sometimes.
07:04:00 <shapr> foo, emacs is using 261mb of ram
07:04:06 <shapr> I should close some files.
07:04:54 <shapr> hej dennisb 
07:09:27 <shapr> ah, closing a coupla hundred files helps
07:10:20 <thebug> (!)
07:11:17 <shapr> how many files do you have open at any given time?
07:11:41 <shapr> I still have 113 files open, and I closed at least two hundred just then.
07:12:08 <thebug> 5 or 6
07:12:19 <thebug> tops would be 40
07:12:29 <shapr> I've had 700 open at once
07:12:36 <shapr> and I was actually using most of them at the same time
07:13:26 <shapr> of course, that's easy to do if you use TAGS to bounce through the sources of linux kernel, or java apps
07:13:38 <shapr> like cruising through the J2EE sources...
07:14:18 <shapr> you could hide a commando team in the J2EE sources, complete with a C-130 Hercules for the emergency dustoff
07:14:56 <shapr> half of the J2EE sources are redundant anyway, lots of duplication of ideas
07:15:04 <shapr> greetings jeremy
07:15:46 * Philippa_ tries playing with existential types and multiparameter types classes (no prizes for guessing what I'm doing) and trips herself up on the instance declarations
07:16:07 <shapr> oh that reminds me...
07:16:18 <shapr> I want to see if I can get Pseudonym's physics code doing tricks
07:17:50 <shapr> hej polli 
07:26:19 <shapr> SyntaxNinj1: hey, how close is CABAL to generating deb skeletons?
07:26:39 <shapr> I could just pull the latest and look
07:26:57 <shapr> Igloo: oh, I like the (1/9) patches addition, thanks!
07:27:10 <SyntaxNinj1> shapr: it doesn't do that.
07:27:18 * Philippa_ finally groks the instance syntax for multiparm type classes and all makes sense...
07:27:29 <SyntaxNinj1> brb
07:27:40 <SyntaxNinja> oh. here I am
07:27:43 <shapr> Philippa_: oh, explain it to me!
07:27:46 <Igloo> heh
07:27:56 <Igloo> np, shapr
07:28:05 <SyntaxNinja> too many open windows
07:28:42 <Igloo> I need to write a script that looks in /proc for shells that have CWD=~ and then kills any that have no children
07:28:54 <Philippa_> shapr: you having problems with that too? I got tripped up trying to declare an instance of a simple two-parm class...
07:46:47 <shapr> oy, I thought GArrow.hs was a Gtk Arrow...
07:46:56 <shapr> it's an arrow *widget*
07:47:41 <Igloo> lol
07:47:55 <Philippa_> heh
07:48:23 * Arnia starts twitching at the mention of widgets
07:52:43 <kosmikus> :r
07:52:50 <kosmikus> argh
07:53:02 <kosmikus> irc is starting to look too much like ghci to me
07:53:32 <Igloo> At least you didn't start typing ML code at us or something  :-)
07:53:53 <SyntaxNinja> I kept typing @type into ghci the other day
07:54:23 <Igloo> hugs/ghci really need an @index equivalent
07:55:48 <Igloo> Hmm, is there a reason lambdabot doesn't use : as its control character?
07:56:45 <shapr> nope
07:56:56 <shapr> SyntaxNinja: haha!
07:57:11 <shapr> Igloo: want me to change it?
07:57:32 <Igloo> Sounds good. Could even make a :t alias?
07:57:56 <Igloo> And I think :r should kick the person from the channel and hope they have autorejoin enabled  :-)
07:58:06 <shapr> haha
07:58:37 <Philippa_> heh
07:58:40 * Igloo doesn't know what :e should do - ansers on a postcard
07:58:56 <Philippa_> that could catch out somebody answering "how the hell do I reload my code?!!?!?!1!?!" though
07:59:16 <shapr> actually, :r should be @dynamic-reload, right? :-)
07:59:30 * Igloo wasn't being serious  :-P
07:59:59 <Igloo> Oh, dynamically reloading all modules would be a sane thing for it to do
08:23:16 <Philippa_> what's the easiest way for me to get a hold of the old hslibs source?
08:25:06 <Heffalump> one obvious choice would be the GHC CVS repository
08:26:04 <Igloo> Or a GHC tarball if you don't need it to be absolutely up-to-date (not that I think it's changed recently)
08:26:29 <Philippa_> alternatively, are there any docs for hslibs/win32 still online?
08:27:07 <Igloo> Any docs there were ought to still be on the GHC docs page
08:27:35 <Philippa_> 'k, in that case it amounts to "read the source"
08:27:42 <Igloo> http://www.haskell.org/ghc/docs/latest/html/hslibs/sec-win32.html (although it's not very useful)
08:28:27 <Philippa_> would be nice if the libs source came in the win32 binary distro, though I guess this is about the only case where it's really needed
08:37:41 * Philippa_ grabs said source and develops a headache
08:41:37 <shapr> Igloo: you were right, michaelw would be happy to hand over c2hs
08:41:56 <Heffalump> so shapr is going to become a DD?
08:42:18 <shapr> it's possible :-)
08:43:28 <Igloo> oo
08:43:33 <Igloo> Cool
08:43:56 * Igloo wonders what ^AC does in screen
08:44:25 <Igloo> Oh, clears it. How...useful?
08:45:07 <thebug> Igloo: it is useful :)
08:45:20 <Igloo> Why?
08:45:25 <thebug> no, it doesn't clear the screen, it creates a new window
08:45:30 <Igloo> No, captial C
08:45:37 <thebug> ah, yeah :)
08:46:05 <thebug> well, you can clear it, then hit ^l to redraw it (if you're using a curses app)
08:46:43 <Igloo> Or just ^A^L to have screen redraw it (after a ^L if necessary)
08:47:45 <thebug> I'd guess that ^A^L just has screen send ^L to the window anyway
08:48:49 <Igloo> I doubt it - just as the app inside scren can get confused, so could screen itself
08:52:28 <thebug> ah, I see the difference
08:53:07 <shapr> could I make a protocol arrow out of the automaton arrow?
08:55:20 <shapr> an automaton arrow seems sort of like a case statesment that returns a continuation to execute
08:55:29 <shapr> that sounds like a good way to represent protocols
08:55:53 <shapr> finite automata are often used to describe protocols, yes?
08:57:44 <Codex> shapr: what's the difference between protocol arrow compared to automaton arrow?
08:58:49 <monotonom> The same difference between priority queue and binary heap.
08:58:51 <shapr> well, I'd assume a bit better integration with command/input parsing and IO stuff
08:58:55 <monotonom> (IMO anyway)
09:00:59 <shapr> gutentag basti_ 
09:01:12 <shapr> Codex: what do you think? any difference?
09:03:29 <shapr> monotonom: yah, I agree, an automaton can be used to express or describe a protocol, but not the other way around
09:04:13 <basti_> hmm
09:04:30 <basti_> you mean there's not an one-to-one relation between protocols and automata?
09:04:52 <shapr> no, not all automata are protocols
09:05:10 <basti_> yes sure...
09:05:11 <Codex> shapr: I dont see anything different. Maybe a small difference in level of abstraction; protocol arrow focuses on communication/contract between two parties, while automaton is more focused on behaviour of one entity.
09:05:24 <basti_> hmm
09:05:37 <basti_> not all automata are sensible protocols, that is ;)
09:06:17 <shapr> regular expressions can be easily expressed as automata, but I think they are unlike protocols
09:06:33 <shapr> Codex: but I see your point, I'm not sure if it would be worth it to have a separate procotol arrow
09:06:47 <monotonom> Another analogy I'll throw out is monad vs. list.
09:06:58 <basti_> hmm i think the notions "protocol" and "automaton" are far too different in the way they are used to judge this quickly...
09:07:16 <basti_> i mean, with a "protocol" you ususally imply that some form of communication is happening
09:07:25 <monotonom> Anyway, my general point is interface vs. implementation
09:07:37 <Codex> well, the "arrow" part of protocol description is pretty similar to arrow part of automata. Its what information(==io)you attach to the arrows that makes them different.
09:08:25 <basti_> i just wonder if that is a fundamental difference
09:08:40 <shapr> I dunno
09:08:47 <basti_> i think its possible to express this in another way
09:09:05 <shapr> but I'm sure I can get more enlightenment by trying to write an SMTP description with the automaton arrow from Ross Patterson's FoP chapter.
09:09:21 <basti_> hehe
09:09:29 <basti_> are you sure that's possible? ;)
09:09:43 <basti_> i heard that many protocols "out there" are not correctly specified
09:10:06 <shapr> I really don't know, but I bet it'll be fun to explore
09:10:08 <earthy> smtp is though
09:10:53 <basti_> i think its not that difficult, so theres not much space for errors
09:12:48 <basti_> im having a course in universal algebra this term... i hope we'll touch arrows and the like... anyway i still got a book which mentions monads (although it doesn't term them like this) and which explains coinduction, i hope that will enlighten me a little on this theme
09:14:02 <Codex> universal algebra sounds like fun.
09:14:28 <basti_> it is... though pretty abstract at times
09:14:57 <basti_> "we know now that every Variety of Algebras is HSP of the Term Algebra modulo the Equations that are valid in the Variety"
09:14:58 <basti_> huhu?
09:16:36 <basti_> and, i never thought i'd read the word "equalizer" in a math book.
09:16:53 <Codex> sounds like someone has invented yet another new terminology for the same thing.
09:17:07 <basti_> its mainly category theory
09:17:18 <basti_> in that book...
09:17:42 <basti_> it starts with general explanations about algebra and then elaborates on equations and why they are important (Birkhoff)
09:17:43 <Codex> equalizer is clearly from category theory.
09:17:52 <musasabi> evening
09:18:05 <basti_> it was used in a category theory context there too
09:18:17 <Codex> But I havent heard of "variety" in category theory.
09:18:26 <basti_> no thats the algebra stuff ;)
09:18:42 <basti_> a variety is a class of algebras which share a common type and the same equations.
09:19:31 <basti_> an important result is that a variety is its own closure under Products, Subalgebras and Homomorph images (in that order).
09:19:34 <basti_> so V=HSP(V)
09:23:14 <Codex> basti_: sounds like HSP(V) is like "isomorphisms" in category theory?
09:23:38 <Codex> (but that's just guessing based on your explanation above)
09:23:40 <basti_> hmm no not really
09:24:05 <basti_> its mainly knowing that the form of algebras is limited in some way
09:24:23 <basti_> theres no algebra in a type that is not an homo image of a subalgebra of a product of algebras we know.
09:24:41 <basti_> the category theory is just very handy to prove things
09:25:16 <basti_> c.t. "arrows" become homomorphisms
09:26:04 <basti_> and you usually reason over algebras of a given type... its hard to reason about algebras of different types at the same time...
09:27:54 <basti_> congurences is a beautiful thing... you can see if an algebra is expressible as a product just by looking at it's congruences
09:28:26 <basti_> and if it is, you can encode it in a simpler way. I guess i'll never need to do that, but its beautiful to look at ;)
10:05:18 <shapr> gah
10:06:05 <shapr> I'm not sure how to make the jump between Auto and SMTP
10:06:39 <shapr> I've written out a simplistic SMTP FSM
10:06:45 <Heffalump> Auto?
10:06:53 <shapr> data Auto a b = Auto (a -> (b, Auto a b))
10:07:03 <Heffalump> oh, the arrow?
10:07:13 <shapr> if you have fptools handy, it's in /testsuite/tests/ghc-regress/arrows/arrowex3.hs
10:07:48 <shapr> or http://shapr.homelinux.net/~shae/arrowex3.hs
10:08:09 <shapr> arrowex3.hs appears to have part (all?) of the arrow code from Ross Patterson's FoP chapter.
10:09:14 <shapr> I guess I could say data Auto Command Response, with both of those being aliases for String
10:09:21 <Igloo> Surely it's not a FA as you have the recipient list as additional state, for example?
10:09:46 <Igloo> Oh, or do you construct a new automaton from something paramerised by the state?
10:10:51 <shapr> I don't know?
10:11:11 <shapr> I was thinking of the states and commands in SMTP
10:11:40 <shapr> if you think of RCPT TO: as one command, then you don't have to think about the recip list (I think)
10:13:31 <shapr> does that sound right?
10:13:52 <Heffalump> yes
10:14:13 <Heffalump> the states of the automaton can be parameterised, anyway
10:17:04 <shapr> when I'm trying to trace through an arrow instance, I wish the data and instance declarations used the same single letters for positional inputs
10:17:08 <shapr> like, data Auto a b = Auto (a -> (b, Auto a b))
10:17:25 <shapr> then the instance would use a as if it would be that same a in the data line
10:17:42 <shapr> I think arrowex3.hs uses b instead
10:21:19 <Heffalump> probably because a is often used for the Arrow type
10:21:39 <shapr> even so...
10:26:26 <shapr> greetz stepcut 
10:27:28 <stepcut> greetz shapr
10:31:54 <saynte> hmm, is there any reason i can't make multiple types as the result of a case statement, knowing that they're all types of the same class? it seems to think the first type is the type for the whole case.
10:32:19 <Heffalump> which type class you are in is a static thing
10:32:30 <Heffalump> selecting a case from a case statement is dynamic
10:32:40 <Heffalump> you can use existential types to get round this, if you really need to
10:33:01 <saynte> existential types?
10:33:28 <Heffalump> with the type system normally, the actual type is not stored at runtime
10:33:45 <Heffalump> so if your case statement produced different types, then things that got that value would not know what real type it was and thus how to use it
10:34:08 <Heffalump> if you use existential types, the type gets stored at runtime so you have more flexibility, at the cost of a little efficiency
10:35:25 <saynte> hmmm, so this would get past my "cannot unify type" errors?
10:37:05 <Heffalump> yes, but it would be better if you explained more precisely what you are trying to do
10:37:19 <Heffalump> it may be that there is a better way than using existential types
10:38:15 <saynte> oh okay sure, basically i'm reading a tuple, first part being a string, the second part being the string representation of a type. i have a class "Editable" that has fromString/toString methods.
10:38:24 <saynte> strToEditable :: (Editable c) => (String,String) -> c
10:38:33 <saynte> strToEditable (editStr,editType) = 
10:38:41 <cgibbard> saynte: You might just want to make a sum type, the constructors of which you can pattern match against.
10:39:36 <saynte> cgibbard: so is this sum type a type which would wrap around the member-types of the editable class?
10:39:49 <Heffalump> this sounds like a typical use of an existential type
10:40:17 <cgibbard> data EditableThing = EditableString String | EditableInt Int | ...
10:40:23 <cgibbard> or some such :)
10:40:24 <Heffalump> btw, you will make your code non-Haskell 98 if you do this
10:40:37 <Heffalump> data MODULE = forall m. (Module m) => MODULE m
10:40:38 <saynte> ohhh thanks cale, awesome, i'll try that and then existential mayhaps...
10:41:14 <Heffalump> here Module is the type class and MODULE is the new type you make that wraps up any instance of that type class
10:41:30 <Heffalump> personally I think existential types, rather than sum types, are the most appropriate solution for this particular problem
10:41:50 <Heffalump> Sum types are just as inefficient at runtime, lead to a bit more code bloat; but OTOH they are Haskell 98.
10:42:07 <Riastradh> It boils down to the same thing, only existential types are likely to be implemented better.
10:42:21 * Heffalump disappears
10:42:52 <saynte> ohhhhh okay, i see. so for overall niceness with standards sum-types are the way to go, for perhaps a future/cleaner implementation then existential types may be better?
10:43:00 <cgibbard> Yeah
10:43:53 <saynte> goootcha, well i'll have a bash at both
10:44:40 <shapr> is SMTP the simplest commonly used protocol that comes to mind?
10:44:45 <shapr> should I be trying this with something simpler?
10:49:03 <shapr> is there some way to give kind constraints on a function/type/etc?
10:49:57 <shapr> foo :: ((Kind *) a) => a -> a
10:52:07 <kosmikus> on a function type?
10:52:12 <kosmikus> why would you need that?
10:52:31 <cgibbard> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#SEC-KINDING
10:52:34 <shapr> for Si\'s SOAP code, for stepcut's Unix pipes arrows, etc etc
10:53:07 <kosmikus> well, ghc allows kind annotations
10:53:31 <kosmikus> but I'd be surprised if you actually need them on the function level ...
10:53:51 <kosmikus> and if you do, I really would like to see a concrete example
10:54:09 <shapr> you know John Hughes problem with the CGI arrow?
10:54:20 <shapr> I was thinking you beat it with Generics and explicit * kind
10:54:21 <kosmikus> uhc has kind polymorphism and kind annotations, and we are always looking for "real world" examples ...
10:54:37 <kosmikus> shapr: no
10:54:46 <shapr> oh, what did I miss?
10:54:59 <kosmikus> shapr: I mean, no, I don't know the problem
10:55:04 <shapr> oh, ok
10:55:16 <kosmikus> link?
10:55:22 <shapr> the CGI arrow would save a continuation
10:55:30 <shapr> it's in his original paper "generalizing monads to arrows"
10:55:52 <shapr> but that would mean you have to add the Read and Show type constraints to the Arrow class itself
10:56:04 <shapr> obviously, that's not a good solution
10:56:15 <shapr> stepcut had the same problem with his Unix pipes as arrows
10:56:35 <shapr> Si\ wants to find a sane way of sending a SOAP proxy for a Haskell function
10:56:48 <shapr> I think that kind limiting could solve those problems
10:57:14 <kosmikus> what's kind limiting
10:57:33 <kosmikus> ?
10:57:40 <shapr> for the CGI example, I know I can't use Data.Generics save kind values of * -> * to a file
10:57:52 <kosmikus> I mean, in your example above  foo :: ((Kind *) a) => a -> a
10:58:05 <kosmikus> the constraint is completely superfluous, because a has to be kind * anyway
10:58:20 <shapr> type T (f :: * -> *) = f Int
10:58:31 <shapr> data Set (cxt :: * -> *) a = Set [a]
10:59:41 <kosmikus> these are kind annotations, and they're allowed by ghc; the first one is not necessary, though
11:00:11 <kosmikus> the Set type doesn't make sense to me
11:00:19 <shapr> JH couldn't save a CGI continuation because he couldn't add the Read and Show typeclass constraint to the Arrow class 
11:00:55 <shapr> maybe you could partially get around that by limiting some of the CGI type to Kind *
11:01:07 <kosmikus> I still don't understand
11:01:14 <shapr> I think you can safely assume that Data.Generics will always let you save and restore a Kind * value, yes?
11:01:15 <kosmikus> you make it sound like it wouldn't normally be limited
11:01:54 <kosmikus> I wouldn't say always; but values are *always* of kind *
11:03:27 <shapr> oh, maybe I'm confused then
11:03:47 <shapr> I was thinking that functions are of kind * -> *
11:03:52 <kosmikus> no
11:04:10 <shapr> yah, that would be too easy... :-)
11:04:58 <kosmikus> functions are of kind *
11:05:22 <kosmikus> all values, all well-types expressions even, are of kind *
11:05:35 <kosmikus> well, more precisely, they have a type that is of kind *
11:06:39 <shapr> is there some way of limiting a type to something 'lower' than a -> b ?
11:06:51 <shapr> er, a value
11:06:52 <shapr> whatever
11:08:27 <shapr> I guess a unification type of Char, Int, Integer, and lists thereof
11:08:39 <shapr> feels sort of manual though
11:08:43 <kosmikus> if I interpret your notion of "lower" correctly, then only by making it a constant type or by adding a class constraint
11:08:55 <shapr> oh, good point
11:09:03 <kosmikus> you're in a functional language, functions are nothing special!
11:09:07 * shapr grins
11:09:15 <shapr> they are when you try to save a value to disk
11:09:24 <shapr> I wish they weren't special that way
11:09:40 <Si\> Has anyone read the UUXML paper AND fully understood it all?
11:09:53 <shapr> which paper is that?
11:09:56 <kosmikus> oh, not really; there are other types that are hard to store
11:10:01 <SyntaxNinja> strange. shapr, I didn't see your email to the group & m. weber, but I saw his reply.
11:10:02 <kosmikus> Si\: yes, I have
11:10:05 <SyntaxNinja> your email is on the archives, though.
11:10:07 <SyntaxNinja> odd
11:10:19 <shapr> SyntaxNinja: I'll send you an email ping
11:10:28 <kosmikus> Si\: which doesn't necessarily imply that I still do, though
11:10:30 <shapr> sent
11:10:40 <Si\> shame
11:10:43 <shapr> what other types are hard to store?
11:10:53 <SyntaxNinja> shapr: Ihave that list sent to my gmail address
11:10:59 <Si\> you could do a DCC direct to my brain by any chance ;)
11:11:00 <shapr> oh
11:11:10 <kosmikus> shapr: anything that's abstract and hasn't a serialization provided
11:11:11 <SyntaxNinja> shapr: it's odd that I got one and not the other.
11:11:36 <shapr> man, I want brain-direct DCC too.
11:11:36 <kosmikus> shapr: one example would be something of type "IO Int"
11:11:42 <shapr> oh, good point
11:12:49 <shapr> I just thought of the ultra-cheesy solution of using hs-plugins and instance Saveable (\x y -> x + y) where save x = "(\x -> x + y)"
11:13:01 <kosmikus> Si\: what's your question?
11:13:10 <shapr> but that wouldn't work for saving "(\x y -> x + y) 1"
11:13:37 <kosmikus> (\x y -> x + y) is an expression, not a type
11:13:46 <kosmikus> so you cannot say "Saveable (\x y -> x + y)"
11:13:54 <shapr> right
11:14:16 <kosmikus> you could probably do something with TH to store the abstract syntax
11:14:22 <Si\> Basically I need to fully understand how to bind XML Schema to Haskell data-types, cleanly and complete
11:14:23 <shapr> that would be cool!
11:14:51 <shapr> but, I don't know how you can get the abstract syntax of a random function without building it manually
11:15:11 <kosmikus> but the point is that you do not want something like "show (\x y -> x + y)" to evaluate to the string "\x y -> x + y", because that would totally break referential transparency
11:15:41 <kosmikus> you would at least want to put such a function in the IO monad, I guess
11:16:56 <kosmikus> Si\: then you have a good paper to start with :) I think the translation is complete; if it is clean is a matter of taste, probably
11:17:17 <shapr> can you get the AST of a random function?
11:17:27 <shapr> Igloo: did I already ask you this?
11:25:21 <shapr> hej ticPalm
11:29:56 <ticPalm> hej
11:34:21 <Heffalump> Igloo is playing board games
11:49:03 <shapr> bonjour Lukhas 
11:49:34 <Lukhas> salut shapr & #haskell
11:50:39 <thebug> salut Lukhas
11:50:46 <thebug> comment ca va?
11:51:11 <basti_> dragosteadintei? ;)
11:51:47 <Lukhas> ça va, content de retrouver mon appart :)
11:51:57 <shapr> so, Luke Gorrie has challenged me to a unicycle race at the next EuroHaskell
11:52:04 <shapr> that should be entertaining.
11:52:32 <Lukhas> hehe
11:53:14 * Lukhas needs to work /hard/ on Haskell
11:53:26 <shapr> me too!
11:53:29 <Lukhas> a whole chapter of the Thompson's was above me
11:56:01 <shapr> me too!
11:56:06 <shapr> but I kept on hacking.
11:56:41 <shapr> I try to spend 60% of my time doing productive useful stuff I know how to do, and 40% of my time trying to do stuff I don't know how to do.
11:57:20 <Lukhas> :)
11:57:27 <Lukhas> for the moment, i'm just reading
11:57:39 <Lukhas> the few code i managed to produce is enough
12:17:28 <musasabi> evening
12:18:28 <musasabi> shapr: the WASH folks seem to think that a monad is a better representation for the CGI state than the proposed arrow implementation.
12:57:20 <SyntaxNinja> is there a way to ask ghci what threads it has forked?
12:57:34 <jemfinch> use the module Please.Ask.Nicely.
12:57:39 <jemfinch> :-P
12:58:25 <SyntaxNinja> it's kinda funny, I'm testing something, and have no termination condition (since I just hit C-c) and these threads are all apparently still around the next time I run main
13:35:10 <musasabi> Do debian packages of wash exist? 
13:35:24 <musasabi> If not how would one create debian packages for a haskell library?
13:36:45 <SyntaxNinja> musasabi: eeenteresting that you ask...
13:37:18 <musasabi> hmm?
13:37:25 <SyntaxNinja> musasabi: I was just about to look into making packages. I now have at least two complaints against p. thiemann
13:37:45 <SyntaxNinja> 1) that annoying dancing logo at the top of his web page and 2) 6 tarballs to build wash
13:38:04 <SyntaxNinja> musasabi: do you know how to make debian packages in general?
13:41:07 <musasabi> SyntaxNinja: yes, but no idea about how to make them to work with haskell.
13:41:17 <shapr> man, I love that logo
13:41:29 <musasabi> compiling wash seems easy enough
13:41:29 <shapr> but the six tarballs do suck
13:41:36 <shapr> and you have to build them in the right order no less
13:41:46 <musasabi> shapr: you can do a toplevel make.
13:41:58 <musasabi> (of course that requires few mv and symlinks)
13:42:01 <shapr> now that he's added WASHMake, yes
13:42:18 <SyntaxNinja> musasabi: well, there's no great standard for debian packages yet.  see the wiki page... but we're working on that
13:42:21 <SyntaxNinja> @wiki DebianUsers
13:42:21 <lambdabot> http://www.haskell.org/hawiki/DebianUsers
13:43:09 <Riastradh> I can't stand dancing logos.
13:44:13 <shapr> musasabi: are you on the debian-haskell list?
13:46:06 <musasabi> shapr: no.
13:46:12 <shapr> I think the WASH logo is hysterically entertaining.
13:46:29 <shapr> when I met Peter Thiemann at ICFP03, I had to tell him that :-)
13:46:45 <shapr> though I do agree with stepcut's thoughts that WASH is far too form oriented
13:46:57 * shapr reads stepcut's mind.
13:47:28 <SyntaxNinja> is it something worth packaging? mark carroll kinda wants it
13:47:59 <musasabi> Cabal talk seems interesting.
13:48:53 <SyntaxNinja> musasabi: fwiw, in a previous prototype, I had a cdbs-based skeleton generator for haskell pacakges
13:48:56 <shapr> I don't think there are any other options at the level of 'web toolkit'
13:49:17 <SyntaxNinja> does wash work for non-ghc stuff?
13:49:19 <Riastradh> shapr, are you talking about web toolkits for Haskell in specific there?
13:49:25 <shapr> Riastradh: yup
13:50:03 <SyntaxNinja> hmmmmmm
13:50:28 <shapr> I have some ideas in mind, but no code
13:50:28 * SyntaxNinja is pretty sure he doesn't want to package each component separately, but what version number should I use
13:50:33 <musasabi> well wash could be made to work with hrefs too.
13:50:37 <SyntaxNinja> shapr: do you use wash?
13:50:41 <shapr> yes I do
13:50:49 <musasabi> an approach like common lisp would be nice.
13:50:52 <shapr> for curryspondence among other things
13:51:01 <musasabi> wash + haskelldb would be nice to have in debian.
13:51:04 <shapr> I'd like to use wash more
13:51:05 <shapr> yes!
13:51:18 <shapr> curryspondence is a small demo of wash + haskelldb
13:51:36 <SyntaxNinja> musasabi: you're not a DD, are you?
13:51:42 <shapr> anyway, I'll start the DD process and fix up c2hs
13:51:50 <SyntaxNinja> shapr: try the other order.
13:51:56 <SyntaxNinja> fix up c2hs, then start the DD process
13:51:57 <shapr> er yes
13:52:02 <shapr> that's what I meant :-)
13:52:04 <SyntaxNinja> we can sponsor your uploads
13:52:12 <shapr> yayyy!
13:52:25 <shapr> that would be excellent kudos for my AM
13:52:27 <musasabi> SyntaxNinja: no.
13:52:29 <shapr> or whatever you call them
13:52:57 <musasabi> too many things not enough time.
13:54:16 <SyntaxNinja> musasabi: yeah
13:54:52 <SyntaxNinja> musasabi: do you want to maintain wash and have me sponsor it?
13:55:10 <SyntaxNinja> otherwise, I MIGHT maintain it, depending on how much time work is willing to give me to do so.
13:57:04 <Heffalump> shouldn't cabal make maintaining Debian Haskell packages really easy?
13:57:14 <musasabi> Heffalump: yes, in principle.
13:57:56 <musasabi> SyntaxNinja: I'll think about it. (tomorrow when I am awake too)
13:58:17 <SyntaxNinja> Heffalump: that's the idea.
13:58:49 <SyntaxNinja> musasabi: cool. let me know.
14:03:25 <SyntaxNinja> hm. so the registration and install steps are going to have to be separate
14:03:45 <shapr> ok, let's hope this doesn't kill apache on haskell.org ...
14:05:35 <shapr> greetings onceNull 
14:05:45 <shapr> I hope you now have value.
14:06:56 * sorrow is pondering to buy "The Haskell School of Expression"
14:07:18 <shapr> sorrow: it's good!
14:07:37 <SyntaxNinja> sorrow: DO IT!
14:07:47 <SyntaxNinja> sorrow: did you see my slashdot review? :)
14:07:59 <sorrow> No, I'm afraid, I didn't ;-)
14:08:07 <shapr> foo, what's the squid port?
14:11:50 <onceNull> shapr, hi
14:12:46 <shapr> onceNull: looking for Haskell info?
14:13:16 <onceNull> yes... I'm interested in functional programming
14:14:35 <shapr> have you found the learning page at haskell.org ?
14:14:39 <shapr> do you have any questions?
14:15:03 <onceNull> I'm looking at that
14:15:47 <onceNull> is Haskell similar to C syntax?
14:15:58 <shapr> not necessarily
14:16:02 <shapr> would you like to see a source demo?
14:16:12 <onceNull> sure
14:16:16 <musasabi> not really, but the syntax is quite easy to learn.
14:16:22 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
14:16:55 <earthy> Haskell isn't even close to C syntax
14:16:55 <sorrow> SyntaxNinja, having read I think I will buy it. :-)
14:17:09 <earthy> or semantics
14:17:39 <earthy> it does become second nature rather quicker than C does, however
14:17:54 <onceNull> yes, it seems friendly
14:18:10 * shapr volunteers to John Peterson to be the darcs admin for www.haskell.org
14:18:16 <earthy> don't. :)
14:18:22 <earthy> he's busy enough as it s.
14:18:24 <earthy> is
14:18:36 <shapr> no, I mean I'm volunteering to be the admin, but I'm volunteering myself.
14:18:52 <earthy> +to
14:18:59 * earthy needs sleep, obviously
14:19:06 <shapr> if www.haskell.org has the spare bandwidth to host darcs repos, it'd be nice
14:19:09 <earthy> but, yes, *good* idea
14:19:20 <shapr> or I could host them and point the dns to my colo box
14:19:26 <earthy> and it is at Yale, IIRC, so it'll have bandwidth. :)
14:19:31 <shapr> but I think ScannedInAvian may be moving ISPs soon
14:19:44 <earthy> (there is one darcs repo on it already though ;))
14:20:10 <shapr> yah, but I'd be happy to volunteer to do setup, maintenance, and GPG/email admin for the darcs repos
14:20:50 <shapr> (or more realistically, I'd volunteer to write a shellscript to do the hard bits, and then run those shellscripts on demand)
14:20:58 <earthy> uhuh
14:20:58 <SyntaxNinja> sorrow: cool! you should tell Hudak that I made him a sale :) 
14:21:06 <sorrow> heh. ;-)
14:21:27 <SyntaxNinja> shapr: what's wrong w/ using cvs.haskell.org?
14:21:39 <onceNull> Is haskell object oriented?
14:21:45 <shapr> I don't have an account on cvs.haskell.org
14:21:47 <earthy> onceNull: nope.
14:21:50 <shapr> but I got root on www
14:22:06 <SyntaxNinja> shapr: all we really need is to add a dns thing to source.haskell.org or something
14:22:06 <earthy> darcs get http://www.haskell.org/communities/
14:22:09 <earthy> that does work. :)
14:22:22 <SyntaxNinja> shapr: probably a better solution would be to get an account on cvs.haskell.org :)
14:22:30 <SyntaxNinja> that way we can keep the repos together.
14:22:46 <shapr> you'll also need a darcs admin, though it's not much work
14:23:04 <shapr> I volunteer myself, since I have experience doing that.
14:23:25 <shapr> onceNull: but you can use closures sort of like objects
14:23:31 <shapr> and objects can be used sort of like closures :-)
14:23:50 <onceNull> lol :)
14:24:15 <SyntaxNinja> shapr: well, I'm not sure what a darcs admin must do, or if it takes root access or what-have-you... I just think it would be best to have a "hacking" machine and a www machine. cvs.haskell.org has been the hacking machine, and the right people will tend to have accounts.
14:24:33 * onceNull is amused about "Quicksort in Haskell"
14:25:25 <shapr> SyntaxNinja: darcs admin just needs to deal with setup, and GPG key adding for email access
14:25:44 <SyntaxNinja> shapr: gotta run. drop me an email if you want to chat about it :) I'd be more than happy for whatever repos you want to live side-by-side w/ cabal on a hack-server :)
14:25:47 * shapr wishes *.haskell.org were debian
14:25:52 <shapr> sure!
14:26:09 <SyntaxNinja> l8r gaters
14:27:16 <blackdog> onceNull: amused how? that we've got the chutzpah to claim that it's a valid implementation of quicksort? :)
14:27:35 <shapr> g'day blackdog 
14:29:02 <blackdog> g'day shapr.
14:29:34 <blackdog> currently bitching about how nasty it is trying to do HOFs in sh. interpolate this, interpolate that... not everything's a string, dammit.
14:29:44 <musasabi> hmm what should hsql use - postgres, mysql, sqlite, all of them, separate packages?
14:29:56 <blackdog> and nested finds are just nasty
14:29:59 <jemfinch> musasabi: sqlite.
14:30:02 <Heffalump> separate packages
14:30:08 <jemfinch> it's easier to set up and distribute.
14:30:19 <Heffalump> everyone will want their own thing
14:31:28 <onceNull> blackdog, hehe
14:31:34 <musasabi> true, but if someone to use multiple then the separate packages approach won't work.
14:32:14 <musasabi> also consider hsql-{mysql,postgresql,sqlite}-{ghc5,ghc6,hugs} => 9 packages
14:33:36 <Heffalump> hsql-common, hsql-mysql etc
14:33:40 <shapr> I'd say build it as one package, but make sure it can run without the other libs installed
14:33:44 <shapr> or that
14:34:03 <Heffalump> is the model envisaged for Haskell lib packages one per compiler, then?
14:34:43 <musasabi> Heffalump: no it should not be, but currently seems to be.
14:34:57 <Heffalump> well, I'm not sure there is a sane alternative.
14:35:14 <Heffalump> I don't see a fundamental problem with masses of packages, anyway.
14:35:20 <Heffalump> But the Debian infrastructure might be unhappy.
14:35:23 <shapr> source packages can have one install per lib
14:35:48 <shapr> not that it works so well for gnu emacs and xemacs
14:37:08 <musasabi> shapr: it works quite well for common lisp.
14:37:54 * shapr disagrees
14:38:14 <shapr> I have a bunch of CL packages installed on ScannedInAvian
14:38:19 <shapr> (for one of my users)
14:38:47 <musasabi> "it works fine on my machines"(tm)
14:38:50 <shapr> and nearly every upgrade half the packages barf with one of the CL implementations installed
14:38:54 <shapr> ah, ok :-)
14:39:38 <musasabi> shapr: well then I would need to implement dummy functions for each backend with weak linkage at least (don't know if that is enough)
14:41:04 <shapr> hei ksandstr_
14:45:16 <musasabi> enabling a backend makes it generate references (undefined symbols) for it in the produced libraries.
14:45:40 <musasabi> now if it would use dlopen there would be no problem.
14:50:07 <ksandstr> oh hlo shapr
14:50:29 <shapr> ksandstr: how's code?
14:51:16 <ksandstr> shapr: incrementally better, most days :)
14:55:47 <cgibbard> The package system should be a monad somehow :)
14:58:31 <musasabi> I think the folks are trying to get to moon without having a simple working rocket.
14:59:00 <Riastradh> No, it should be a spear!
15:00:27 <musasabi> Seems like the folks at haskell-libraries want the system to be completely safe and read the users thoughts.
15:00:30 * Heffalump thinks build and package systems should all be functional
15:01:03 <musasabi> imho getting something with a good interface working should be the first priority.
15:01:29 <Riastradh> I don't care much about the packaging system as long as it Just Works slickly.
15:01:46 <np_hard> is this something like CPAN for haskell?
15:02:47 <SamB> was CHANell already taken ;-)?
15:03:22 <Riastradh> Chanell?
15:13:37 <SamB> er, I guess with another n :-(
15:13:51 <Riastradh> Channell?
15:14:25 <SamB> I dunno... I'm a bad speller. anyway, note the capitalization... 
15:14:25 <monotonom> "Chanell" would be neat.
15:16:01 <Heffalump> :-)
15:16:25 <Riastradh> There are no capital letters in 'channel'...
15:16:26 * Riastradh ducks.
15:17:23 <monotonom> I don't mind either "Chanell" or "chanell" as long as it's single-n, double-l, just like "haskell".
15:17:46 <monotonom> Perhaps double-n is fine too.
15:21:29 <np_hard> i thought there was a name?
15:21:30 <np_hard> cabal?
15:24:41 <monotonom> There are too many cabals.
15:24:42 * monotonom ducks
15:24:52 <Riastradh> I still like the LAB idea.
15:25:32 <monotonom> LAB = ?
15:25:58 <Riastradh> Library & Application Builder
15:26:08 <monotonom> Library of Abstract Beta-Reducibles? :)
15:26:10 <Riastradh> Combine with Haskell or Curry.
15:26:13 <np_hard> needs to be google-able though
15:26:27 <np_hard> that would do it
15:26:48 <SamB> Curry LAB? hmm. dunno if I want any of that curry...
15:26:56 <monotonom> "chanell" would be google-able.  You get a friendly nudge "are you sure you don't mean channel" but apart from that it obliges.
15:27:32 <Riastradh> Curried LABs would certainly be Googlable.
15:27:54 * monotonom looks at his curried abs.
15:31:14 <jemfinch> lol
15:55:34 <SamB> huh, somebody wrote a z-machine decompiler in Haskell...
15:56:27 <shapr> neat
16:00:15 <SamB> so presumably I could play with that more easily than writing my own code to parse machine code...
16:08:16 <TheHunter> anyone here from germany?
16:09:28 <SamB> arg, my copy of zork1 appears to be patched
16:11:19 <SamB> either that, or this md5 code is broken
16:12:17 <SamB> that seems unlikely, though, since the md5 code is apparantly in C...
16:44:26 <musasabi> How well does the Wash table_io stuff work?
16:46:26 <musasabi> And does it just seem to me or would an wiki-like app absolutely break wash?
16:59:34 <np_hard> muwahahahaha, sub zip_with {($f, $xs, $ys) = @_; return map { $f->($xs->[$_], $ys->[$_]) } (0..($#{@{$xs}} < $#{@{$ys}} ? $#{@{$xs}} : $#{@{$ys}})); }
17:00:07 <np_hard> anyone know enough about perl to make $#{@{$xs}} a little easier on the eyes? :)
17:00:19 <Riastradh> RSA?
17:00:47 <Riastradh> Oh, wait, no, that won't change it at all.
17:00:54 <np_hard> good one
17:00:59 <np_hard> i dunno
17:01:10 <np_hard> perl references and contexts throw me way off
17:01:19 <np_hard> i dunno why the language has that crap anyway
17:01:35 <Riastradh> s/has/is/1
17:02:15 <Pseudonym> Hysterical raisins.
17:02:15 <shrimpx> np_hard: what's $# again?
17:02:15 <SamB> np_hard: you can probably alter the parser dynamically by now...
17:02:25 <Pseudonym> It used not to have structures at all, only arrays, hashes and scalars.
17:02:32 <np_hard> length of an array i think
17:02:39 <shrimpx> i think it's length - 1
17:02:45 <np_hard> oh, but that function isn't quite right
17:02:47 <np_hard> you are right
17:03:04 <shrimpx> but that ugly thing is better written as @$xs - 1
17:03:04 <np_hard> needs to be +1 on all those $#{@{$x}}
17:03:13 <np_hard> ah
17:03:22 <np_hard> see, this is the stuff I was looking for 
17:03:35 <np_hard> I didn't know that was valid
17:03:49 <shrimpx> ya an array evaluates to its length in scalar context :)
17:03:57 <np_hard> but that is because I am not in the perl mindset
17:04:05 <np_hard> what's $# for, then?
17:04:26 <shrimpx> to say for (0..$#foo)
17:04:28 <shrimpx> it's dumb
17:04:47 <shrimpx> for $i (0..$#foo) { $foo[$i] ... }
17:05:08 <shrimpx> i hate perl
17:05:26 <np_hard> so I can't do something different in the code above?
17:05:37 <np_hard> I need (0..arraylen)
17:05:42 <shrimpx> i guess the designers of perl thought that too many off by one errors happened without $#? :)
17:05:53 <Pseudonym> foreach $f (@foo) { ... $f ... }
17:06:00 <Pseudonym> ?
17:06:22 <shrimpx> np_hard: so use @$foo
17:06:45 <shrimpx> as long as it's in scalar context it returns the length... if context is not clear you can say 'scalar @$foo'
17:07:18 <Riastradh> Pseudonym, you can't then assign the ith element in @foo.
17:07:54 <shrimpx> assignment?!
17:08:05 <shrimpx> you're in #haskell
17:08:22 <Heffalump> just think of perl as one big monad
17:08:24 <Riastradh> Yes, but we're discussing Perl.
17:08:39 <Heffalump> riastradh: well don't, you'll make the channel dirty
17:08:42 <Riastradh> Therefore we ought to blame & BURN NP_HARD!
17:08:55 * Riastradh gets out the stake.
17:09:13 <np_hard> much better
17:09:29 <Riastradh> Hmmm, where'd we put the gasoline?  I don't see it in any of the closets.
17:10:10 <Igloo> Don't be silly, the hardware is the monad. Perl is just an abstraction on top of it.
17:10:21 <np_hard> sub zip_with { ($f, $xs, $ys) = @_; return map { $f->($xs->[$_], $ys->[$_]) } (0..((@$xs - 1) < (@$ys - 1) ? (@$xs - 1) : (@$ys - 1))); }                   
17:10:25 <np_hard> now it is the paragon of readability
17:12:05 <shrimpx> didn't you say you wanted lengths there? not length-1s?
17:12:25 <np_hard> no, I need indexes
17:12:29 <np_hard> but all of the indexes
17:12:32 <np_hard> $# didn't get the last one
17:12:36 <np_hard> or rather
17:12:41 <np_hard> (0..$# didn't)
17:13:02 <Igloo> Isn't (@$xs - 1) = $#xs?
17:13:12 <Igloo> You don't need the -s before the ? at any rate
17:13:20 <np_hard> yeah except I don't think $#xs works on arrayrefs
17:13:37 <np_hard> i tried it, I think
17:13:46 <Igloo> Oh, sorry, I misread
17:14:00 <np_hard> no prob
17:14:09 <Cale> heheh - implementing the prelude in perl?
17:14:13 <np_hard> muwahah
17:14:13 <np_hard> :)
17:14:28 <np_hard> it strikes me that static typing makes this sort of thing a bit less frightening
17:14:34 <np_hard> and a bit more useful
17:14:39 <Riastradh> You ought to implement it in Perligata.
17:14:45 <np_hard> reduce is in list::util
17:14:53 <np_hard> map and grep are in the language
17:14:53 <Cale> Static typing makes everything a bit less frightening.
17:14:59 <np_hard> seems obvious to me ;)
17:15:25 <Igloo> You should be able to say $#$xs, though
17:15:31 <np_hard> oh geez
17:15:34 <np_hard> never thought of that
17:15:36 <np_hard> lemme try it
17:16:19 <shrimpx> try making cool ascii art with the sigils
17:17:11 <np_hard> thanks, Igloo!
17:17:29 * Igloo prefers @$xs[$_] too, but that's more a personal preference I think
17:18:08 <np_hard> won't it complain about that?
17:18:16 <np_hard> probably not
17:18:21 <np_hard> the context thing totally confuses me
17:18:24 <Igloo> About what?
17:18:38 <np_hard> but I know that @xs[$i] complains
17:18:55 <Igloo> Well yes, that refers to a completely different variable
17:19:00 <np_hard> I just don't have any but the most superficial understanding of the effects of @ $
17:19:05 <np_hard> that's my main issue
17:19:13 <Heffalump> what does @$xs[$_] mean?
17:19:19 <Heffalump> oh, in the map.
17:19:33 <Igloo> It means element $_ of the array xs points to
17:19:57 <Heffalump> yes, it was what context the $_ came from that was confusing me
17:20:13 <np_hard> @ is blowing my mind there
17:20:13 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
17:20:23 <np_hard> is that the same as @{$xs}
17:20:25 <Heffalump> I think -> notation is nicer when you have long chains to follow
17:20:36 <Heffalump> @{$xs} is the same as @$xs, yes
17:20:36 <lambdabot> Sorry, I don't know the command "{$xs}", try "lambdabot: @listcommands"
17:20:40 <np_hard> the {} helps my brain
17:20:41 <np_hard> ok
17:21:09 <np_hard> I think my superficial understanding of contexts is the issue here
17:21:24 <Igloo> This isn't really to do with contexts
17:21:39 <Heffalump> I think perl's ridiculously complicated set of implicit variables, types etc is the issue here.
17:21:41 <Igloo> The @ is explicitly causing the $xs to be dereferenced as an array
17:21:44 <np_hard> because in my mental model of the semantics @{$x}[$i] is no different than @y[$i]
17:21:58 <np_hard> but that's not the case.
17:22:02 <Igloo> What's y?
17:22:09 <np_hard> just a list, let
17:22:12 <np_hard> 's say
17:22:21 <Igloo> Did you mean to use the same letter where you used x and y?
17:22:26 <np_hard> no
17:22:33 <np_hard> lets say you did \@y to get $x
17:23:04 <Igloo> How are they different then?
17:23:15 <np_hard> well @y[$i] complains about deprecation
17:23:31 <Igloo> deprecation?
17:23:35 <np_hard> it wants $y[$i]
17:24:05 <Igloo> Oh, duh, sorry. Been too long since I wrote serious perl  :-)
17:24:12 <ozone> np_hard: perl wants $y[$i] because the whole expression evaluates to a scalar
17:24:21 <ozone> "the whole expression" == "$y[$i]"
17:24:36 <np_hard> no problem Igloo, I am being an ass for asking on #haskell
17:24:38 <ozone> if you write @y[$i], you're expecting the result to be an array
17:24:44 <np_hard> just was proud of figuring out zip_with in terms of map
17:24:56 <Igloo> OK, now I see why you find @$x[$i] so evil
17:25:15 <np_hard> not evil
17:25:19 <np_hard> does it produce the same warning?
17:25:24 <np_hard> I should have just coded it and saw
17:25:34 <np_hard> but perl has no convenient interactive interpreter :-P
17:25:52 * Heffalump gets confused. So @$x[$i] actually works and refers to a scalar?
17:25:59 <np_hard> not sure yet
17:26:02 <np_hard> I will check
17:26:20 <vajrabum> np_hard, don't you use perl -d? It's not quite what your asking for but it's close.
17:26:37 <np_hard> i always forget about that
17:26:48 * Igloo can't make perl complain about @foo[2]
17:26:48 <np_hard> debuggers don't excite me
17:26:55 <np_hard> perl -w
17:27:06 <Igloo> perl -de 1 -w is what I'm using
17:27:07 <ozone> Heffalump: if $x[$i] is a reference to an array, that'll work
17:27:16 <vajrabum> Then don't think of it that way. It's a weak interpreter instead.
17:27:21 <np_hard> heh, but it's not
17:27:26 <np_hard> really?
17:27:47 <np_hard> perl -w -e "@x=(1,2,3,4);print @x[1];"
17:27:47 <np_hard> Scalar value @x[1] better written as $x[1] at -e line 1.
17:28:05 <ozone> yep
17:29:06 <shrimpx> ironically, @x[1] is the syntax in perl 6
17:29:25 <np_hard> beautiful
17:29:27 <shrimpx> and %foo{bar}
17:29:31 <np_hard> absolutely beautiful
17:29:44 * Heffalump sets himself a target of migrating all his Perl code to Haskell by the time Perl 6 comes out.
17:30:02 <np_hard> it's almost as if Perl is deliberately trying to get one of the other languages to unseat it
17:30:07 <Igloo> perl -w -e '@x=(1,2,3,4); $y=\@x; print @$y[1], "\n";'    and    perl -w -e '@x=(1,2,3,4); $y=\@x; print $$y[1], "\n";'    both print 2 though
17:30:14 <shrimpx> omg pain
17:30:15 <Igloo> With no warning
17:30:33 <np_hard> $$y?
17:30:35 <Igloo> Heff  :-)
17:31:40 <Igloo> Hmm, if someone packages WASH and some Haskell DB thing I might be btempted to do that too  :-)
17:31:56 <np_hard> ok that does it
17:31:58 <Heffalump> want HSP.
17:32:12 <np_hard> @$ys seems equivalent to $$ys
17:32:12 <lambdabot> Sorry, I don't know the command "$ys", try "lambdabot: @listcommands"
17:32:22 <Heffalump> lambdabot: @leave #haskell
17:32:27 <np_hard> oops, sorry lambdabot :)
17:32:28 <Igloo> No, $$ys isn't an array
17:32:32 * Heffalump pats lambdabot on the head.
17:32:35 <np_hard> oops
17:32:48 <np_hard> @$ys[$i] seems equivalent to $$ys[$i]
17:33:00 <np_hard> that is just twisted
17:33:11 <shrimpx> tim toady
17:33:14 <np_hard> the antithesis of referential transparency
17:33:28 <Igloo> Heff likes writing semantics for non-designed languages, ask him to do perl when he's got a minute  :-)
17:33:37 <shrimpx> haha
17:33:46 * Heffalump fumes in Igloo's general direction
17:34:37 <shrimpx> i've always used -> syntax to deal with refs
17:34:41 <shrimpx> makes life simple
17:35:08 <np_hard> will -> be . in all cases in perl6?
17:35:15 <shrimpx> i think so
17:35:26 <np_hard> $x.[$i] ?
17:35:34 <shrimpx> not in that case...
17:35:39 <Igloo> lol
17:36:28 <np_hard> now, how do I package this up as a nice argument to ban perl for significant development in my company?
17:36:30 <np_hard> :)
17:36:43 <shrimpx> because i think an array is always a pointer, so @x[0] is equivalent to @x.get(0) or some crap
17:36:50 <ozone> np_hard: if you keep hating a language, it'll never love you back
17:37:00 <np_hard> I don't hate Perl at all!
17:37:07 <np_hard> I find it quirky and lovable.
17:37:22 <np_hard> Like someone who committed themself to a private institution
17:37:29 <np_hard> perhaps a good conversationalist
17:37:36 <np_hard> but not something to entrust with your business
17:37:46 <shrimpx> np_hard: become a ultra-sophisticated perl hacker and they won't be able to fire you
17:38:07 <np_hard> you actually don't need to be that sophisticated to get impenetrable code
17:38:19 <shrimpx> make sure you do stuff like munge symbol tables in modules as a cheap way of AOP
17:38:21 <np_hard> there's one guy on the team who has made a nice empire of cut-and-pasted code
17:38:57 <np_hard> I took the time to figure out one tiny block and re-implement it according to the coding standards we are attempting to finalize
17:39:02 <shrimpx> i quit my job and still get paid $75-$115/hr to fix code that i wrote
17:39:09 <np_hard> it was not particularly fun but quite doable
17:39:32 <shrimpx> and (in my opinion) i wrote really clean perl
17:39:56 <np_hard> did you use map, grep, and reduce?
17:40:03 <shrimpx> a lot
17:40:10 <np_hard> I have decided I am going to use that wherever it makes sense to
17:40:12 <np_hard> that's probably why then ;)
17:40:28 <shrimpx> they just made sense most of the time... dunno
17:40:31 <np_hard> for and foreach loops don't scare off the commodity coders
17:40:44 <np_hard> my rule is use map for the resulting list, use foreach for side effects
17:40:59 <shrimpx> hah i used map with side effects quite a bit
17:41:12 <np_hard> that's just not playing fair IMO
17:41:38 <np_hard> it's silly to use functional idioms and not think about functional paradigm ;)
17:41:38 <shrimpx> but i made sure the effects were very local. that's still clean, right?
17:41:46 <np_hard> i suppose if they were very very local
17:41:55 <np_hard> since you can't escape side effects in perl
17:42:06 <shrimpx> well i used map ass 'app' but i guess i should have documented
17:42:20 <shrimpx> s/ass/as/
17:42:50 <shrimpx> in conclusion, perl sucks 
17:42:55 <np_hard> pretty much
17:43:01 <np_hard> now about that haskell cpan
17:43:14 <shrimpx> heh
17:43:17 <np_hard> is it going to try to support all haskell implementations?
17:43:30 <np_hard> i think the scripting languages have an edge in being implementation-defined
17:45:41 <ozone> sorry, your "zip_with" function most definitely isn't clean perl
17:45:51 <ozone> and keep in mind that perl's map is destructive (updates in-place)
17:45:58 <ozone> so it's not purely functional anyway
17:46:40 <shrimpx> how is it destructive? doesn't it return a list?
17:46:54 <Igloo> It doesn't alter any of its arguments or any global values - how is it not purely functional?>
17:47:04 <np_hard> heh
17:47:10 <np_hard> a lot of my code is broken then
17:47:16 <np_hard> broken transparently
17:47:21 <shrimpx> it's destructive if you map { $_ = stuff } ...
17:47:22 <Igloo> Except $_ maybe - no idea how that works
17:47:35 <ozone> Note that $_ is an alias to the list value, so it can be used
17:47:35 <ozone>                to modify the elements of the LIST.  
17:47:38 <ozone> (from perldoc -f map)
17:47:49 <shrimpx> ozone: ya, what i said
17:47:50 <np_hard> yeah, but if you don't alter the elements of the list
17:47:54 <Igloo> But the list is (0..n) here
17:47:56 <np_hard> it doesn't alter the elements of the list
17:47:58 <shrimpx> but it's not destructive if you don't want it to be
17:48:05 <np_hard> you can program in a purely functional style
17:48:06 <ozone> sure
17:48:11 <np_hard> certainly map doesn't enforce it though
17:48:32 <ozone> programming in a purely functional style in an imperative language is asking for the wrath of all the other coders on your team
17:48:33 <np_hard> that's why my policy says use foreach in that instance
17:48:38 <np_hard> otherwise it is confusing for all concerned
17:48:40 <Igloo> The only thing I think it can affect is $_ of the caller, but I don't know how $_ works
17:49:00 <np_hard> ozone: when they can break their lines before 132 characters, then we can talk about common ground :)
17:49:04 <shrimpx> $_ is bound to each element of the list in turn inside the map block
17:49:10 <shrimpx> regardless of what the outer $_ is
17:49:18 <shrimpx> $_ sucks
17:49:30 <ozone> $_ rules!
17:49:33 <shrimpx> !
17:49:35 <ozone> $_ $_ $_ $_ $_
17:49:47 <np_hard> plus my programs aren't in purely functional style, only my maps and greps are :)
17:50:17 <np_hard> function calls are not optimized in perl, so it would be silly to be purely functional
17:51:01 <ozone> it would be silly to write purely functional C
17:51:46 <np_hard> heh
17:52:08 <np_hard> I would be happy if the other major Perl coder on the team would recognize that side effects should be monitored at all
17:52:09 <Igloo> Mmmm, imagine the types on that
17:52:15 <np_hard> the guy doesn't use perl -w or use strict;
17:52:23 <Igloo> Simple functino pointers are nasty enough  :-)
17:53:11 <ozone> now _that_ sounds foolish
17:54:14 <shrimpx> i think perl6 has the equivalent of use strict and use warnings enabled by default
18:01:24 <np_hard> HA!
18:01:31 <np_hard> #python gave me a challenge
18:02:08 <np_hard> sub zip_with {return map {$_[0]->($_[1]->[$_], $_[2]->[$_])} (0..($#{$_[1]} < $#{$_[2]} ? $#{$_[1]} : $#{$_[2]}));}
18:02:14 <np_hard> no sense cluttering up the symbol table
18:03:44 <Igloo> what challenge?
18:03:50 <np_hard> and now it is an expression, not a block
18:03:51 <np_hard> sub zip_with {return map $_[0]->($_[1]->[$_], $_[2]->[$_]), (0..($#{$_[1]} < $#{$_[2]} ? $#{$_[1]} : $#{$_[2]}));}
18:03:59 <np_hard> don't use the variable names
18:07:02 <SamB> huh, the all-in-one source/doc/lib tarball for inform 6.30 has an info file in it
18:11:46 <monotonom> Das ist nicht python. Das ist perl.
18:15:00 <np_hard> monotonom: we can all laugh at perl, can't we?
18:15:00 <np_hard> together
18:15:02 <np_hard> ?
18:15:20 <np_hard> actually zip_with will make sql query generation a lot nicer to look at
18:15:21 <np_hard> :)
18:16:02 <np_hard> what was a bunch of state can now be a zipwith, a connection function, and a join
18:16:02 <np_hard> :)
18:21:16 <np_hard> simple version, join(" AND ", zip_with(sub{"$_[0] = $_[1]"}, \@columns, \@values))
18:21:27 <np_hard> modulo any typographical errors 
19:00:03 <monotonom> yeah zipwith is neat.
19:24:39 <Igloo> Anyone know of a good number theory website listing lots of "common" results?
19:24:54 <Igloo> (and discussions/proofs)
19:26:34 * Igloo doesn't really know how an index on theorems would work for people who don't know theorem names, though
19:50:55 <Cale> Igloo: well, there's PlanetMath - not everything has a proof there, but they're working on it :)
