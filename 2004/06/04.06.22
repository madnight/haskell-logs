00:09:40 <wagle> there is a mercury .net
00:10:52 <clausen> yeah, MS paid our department $0.5M
00:10:59 <clausen> to do it
00:13:03 <SamB> how much will they pay for bf.net? unlambda.net?
00:13:25 <vegai> perhaps they'll sue if you implement those
00:13:40 <vegai> I'm not sure if I'm kidding there
00:14:04 <Pseudonym> It also killed the research imperative.
00:14:20 <SamB> have they got pascal.net? oberon.net?
00:14:30 <Pseudonym> And the Mercury guy who was the local Debian expert and CD distributor now works for Microsoft.
00:14:36 <Pseudonym> Scary times.
00:15:33 <Pseudonym> Was it only $0.5M?
00:15:42 <Pseudonym> Very cheap for half a dozen souls if you ask me.
00:17:20 <vegai> how much for haskell.net, then?
00:17:41 <SamB> maybe they would like cobol.net?
00:17:49 <clausen> vegai: didn't they do that in house?
00:18:00 <SamB> vegai: hmm, they actually hired people for that, didn't they?
00:18:04 <vegai> oh yeah, surely
00:18:11 <clausen> microsoft research has lots of haskell people
00:18:57 <SamB> like, microsoft should be scared, they have so many...
00:19:15 <earthy> why?
00:19:41 <earthy> they fully intended to hire them
00:19:44 <SamB> earthy: because it would be nice if they would be scared!
00:19:47 <earthy> ah.
00:19:55 <earthy> Wishful Thinking. ;)
00:21:41 <Hyp3rion> gates was talking about "programis wont be written but graphically designed"
00:22:04 <Hyp3rion> so maybe they are working on befunge now ^_^
00:22:19 <clausen> earthy: intend to hire who?
00:26:12 <earthy> Haskell luminaries
00:26:23 <clausen> earthy: they actually did hire them
00:26:34 <earthy> yes, as per their intentions
00:26:49 <earthy> so it'd be very odd for them to be afraid of the Haskell luminaries they hired
00:26:57 <clausen> hehe, yeah
00:27:02 <SamB> how about weird.net?
00:27:09 <earthy> which was what SamB was wishfully thinking
00:27:50 <SamB> maybe, they should just be afraid of all the linux users in their employ...
00:35:56 <earthy> nah. they should be afraid of losing developers for their platform
00:36:00 <earthy> they don't seem to be though
00:36:19 <earthy> which is a Good Thing, in a sense, for it will make them much more customer-focused in the end
00:36:26 <earthy> and less Evil in their ways
00:49:29 <Pseudonym> Or perhaps just more devious.
01:07:49 <Pseudonym> Must away.  Nytol!
01:16:17 <Lunar^> Hey #haskell !
01:16:55 <Lunar^> hello andersca :) How was the GNOME meeting  ?
01:17:07 <andersca> meeting?
01:17:10 <andersca> you mean the conference?
01:17:11 <Lunar^> conference
01:17:18 <andersca> ah, it starts next monday )
01:17:19 <andersca> :)
01:17:24 <Lunar^> urf... :)
01:19:09 <clausen> andersca: are gnome people desperate for complaints about how slow it is?
01:19:22 <clausen> andersca: or you're flooded with useful info already?
01:19:28 <andersca> clausen: are haskell programmers? :)
01:19:40 <andersca> clausen: we do have profile data and are working on it(tm)
01:19:52 <clausen> andersca: I think haskell programmers are aware of the problem ;)
01:20:10 <clausen> andersca: cool
01:20:28 <andersca> clausen: as usual, profiling is hard :/
01:20:30 <clausen> andersca: on my machine, galeon takes about 20 seconds to load, gnome-terminal takes about 10 seconds, etc.
01:20:40 <andersca> clausen: what machine?
01:20:46 <clausen> pentium 200, 256mb ram
01:21:00 <clausen> cpu bottleneck
01:21:05 <andersca> hmm, yeah...
01:21:32 <earthy> man, a Pentium 200 with 256 Mo RAM... that's a screamer
01:21:34 <clausen> clicking on the gnome-foot - about 2-3 second delay
01:21:41 <earthy> (or, at least, was, 7 years ago)
01:22:01 <clausen> earthy: ram was going REALLY cheap, so I got some ;)
01:22:32 <clausen> andersca: do you know roughly where all the cpu is being spent?
01:22:36 <clausen> andersca: syscalls?
01:22:46 <andersca> clausen: hmm, I bet there's a lot of IO going on as well
01:22:48 <earthy> somehow it is kind of silly that a machine with that much processing power is slow
01:23:00 <clausen> andersca: well, there is no hard disk activity
01:23:07 <earthy> video I/O?
01:23:25 <clausen> I guess so... only 1024x768
01:23:34 <clausen> I wouldn't expect that to be a bottleneck
01:23:53 <clausen> andersca: the bottleneck is definitely CPU
01:24:14 <andersca> clausen: hmm, I've heard that programs can be slow if your dns settings are fubar
01:24:16 <earthy> I'd expect gnome to do a lot if interprocess calls
01:24:42 <earthy> and those can be quite slow indeed
01:24:56 <andersca> earthy: not many...and those are done on demand
01:25:17 <clausen> andersca: know why?
01:25:25 <clausen> host `hostname` runs fast :)
01:25:32 <andersca> clausen: hmm, not really :/
01:26:08 <earthy> still, getting a terminal up on the screen shouldn't take 10 seconds
01:26:15 <clausen> andersca: I can understand that it would increase latency (waiting for timeouts)
01:26:15 <earthy> or is font rendering *that* slow?
01:26:19 <earthy> (it shouldn't be)
01:26:20 <clausen> andersca: but I'm getting full cpu load
01:26:50 <clausen> earthy: it takes 10-20 seconds to bring up a window... I think it's before it gets that far
01:27:32 <earthy> before the window can get drawn the fonts have to be rendered
01:27:38 <andersca> earthy: not really
01:27:39 <andersca> :)
01:27:56 <earthy> andersca: yeah, you could get the outline up earlier
01:27:59 <earthy> but not letters. :)
01:28:18 <earthy> (and only those letters that are actually drawn need rendering, ofcourse)
01:28:59 <clausen> apart from laziness, I have an old machine just to find performance problems
01:29:06 <clausen> I could afford a much faster machine now :)
01:29:30 <clausen> btw, my machine doesn't have an L2 cache
01:29:39 <earthy> ;)
01:29:44 <clausen> (it does have an L1 cache, though :)
01:29:59 <earthy> clausen: actually, it's a good thing to try and get OSS to run well on a P200
01:30:25 <earthy> then it'll positively fly everywhere else
01:30:33 <clausen> not to mention 3rd world countries
01:30:43 <earthy> don't underestimate their computing power
01:30:48 <clausen> if you can give away lots of really cheap computers...
01:31:20 <clausen> I have friends in 3rd world countries who find computers prohibitively expensive
01:31:28 <earthy> oh, yeah.
01:31:36 <earthy> but those that don't get reasonable computers
01:31:50 <earthy> not the fastest, but nowhere near dog slow either
01:32:01 <clausen> yep
01:38:56 <Lunar^> But GNOME isn't written in C which is supposed to be faster ? ;)
04:31:32 <shapr> good afternoon #haskell!
04:37:42 <shapr> @yow
04:37:43 <lambdabot> Being a BALD HERO is almost as FESTIVE as a TATTOOED KNOCKWURST.
04:45:07 <Lemmih> Good afternoon, shapr.
04:46:33 <shapr> hoi choong 
04:46:39 <shapr> hiya Lemmih, how's code?
04:46:43 <choong> hi :)
04:47:24 <choong> I've just recently learned about the existance of functional programming and I'd like to look into it
04:47:45 <choong> any tips? docs? stuff? to help me out? :)
04:49:40 <vegai> topic has a few
04:50:00 <vegai> better try things out and ask when problems arise
04:50:09 <vegai> umm, I mean s/when/if/
04:50:14 <sazzle> hehe
04:50:47 <choong> alright
04:50:48 <choong> thanks :)
04:52:52 <Cale> I recommend the tutorial called "Yet Another Haskell Tutorial"
04:53:33 <choong> alright, thank you all :)
04:53:41 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
04:53:46 <choong> found it
04:56:22 <Cale> Let us know if you have any trouble with it. Functional programming is rather different from imperative programming, so some people have a tendency to get a bit frustrated at first when things don't work the same way. Especially with IO (you don't want to start with "Hello, World" -- it's short, but not instructive, leave IO for once you understand types)
04:56:45 <choong> hmmm alright
04:56:56 <choong> I'll be sure to bother you guys when I run into things ;D
04:57:13 <firefly> The I/O thing is not a problem with strict functional languages.
04:58:40 <choong> is knowledge of logic important ?
04:58:52 <choong> I mean scientific logic, not the common sense logic
04:59:08 <choong> because I'm really lame at it ;)
04:59:20 <vegai> it certainly doesn't harm you
04:59:27 <firefly> As to understanding functional programs, it really helped me when I got two different views I could switch quickly between:  1) a completely static (but complicated) equation and 2) knowledge of how the compiler/interpreter would translate it to low-level code.  Once I had both views it got really easy to understand.
04:59:29 <choong> hmm okie :O
04:59:32 <vegai> but learning haskell might be an excellent way to learn logic
04:59:45 <firefly> scientific logic?  no, I don't think you need it.
04:59:47 <choong> hmm okie :)
05:00:26 <choong> thanks all, very kind of you to be nice to a beginner like me ;)
05:00:55 <firefly> understanding lambda calculus might help, however.
05:01:04 <choong> huh
05:01:09 <firefly> How good is your foundational math?
05:01:14 <choong> never heard of that.. actually I really really reaaaalllyyy suck at math
05:01:37 <choong> I got rejected as computer science student because my math was so lousy
05:01:42 <firefly> Well, mathematicians like to have something really, really simple at the bottom which they can build on top of.
05:01:54 <firefly> One foundation is to use sets.
05:01:55 <choong> now I study some economics stuff.. sigh... life's unfair ;)
05:02:06 <firefly> Natural numbers are just sets with different numbers of members.
05:02:28 <firefly> Another is lambda calculus which only has functions -- and those functions only operate on other functions.  It is really quite cool :)
05:02:44 <firefly> Don't you need lots of math in order to do proper economics?
05:02:50 * choong makes an 'OMG!' face
05:03:00 * firefly wonders why
05:03:02 <choong> nah, just some basic stuff
05:03:29 <choong> you just need to know a few formulas, fill in some values and weee there you go
05:03:37 <firefly> wonderful :/
05:03:51 <choong> no need for a deeper understanding or a 'good sense for numbers' or something
05:03:58 <firefly> great :/
05:04:19 <shapr> Haskell is easy
05:04:22 <shapr> just jump in
05:04:32 <vegai> yup. Better just hack around
05:04:40 <vegai> than think whether you're smart enough
05:04:41 <choong> alrighty
05:04:48 <shapr> then come ask us when you have questions
05:04:49 <choong> I'll give it a shot tomorrow :)
05:04:58 <firefly> yes, don't try too hard to prepare yourself until you feel you are ready and know enough.  Better to just start!
05:05:04 <choong> have to write a dumb report on economics for today :(
05:05:09 <choong> alright ;D
05:05:13 <shapr> economics are lots of fun
05:05:17 <firefly> Well, "just plug on some numbers", then ;)
05:05:18 <vegai> write a report generator!
05:05:21 <firefly> s/on/in/
05:05:23 <choong> haha ;)
05:05:26 <choong> if only I could
05:05:28 <shapr> economics is just about supply and demand
05:05:32 <choong> well I dont really study economics..
05:05:36 <shapr> simple stuff
05:05:39 <choong> it's more of a managament-thing
05:05:45 <choong> with some basic economics
05:05:49 <shapr> I don't study economics either
05:05:56 <shapr> well, not for school
05:05:58 <shapr> only for fun
05:05:59 <choong> hehehe
05:06:06 <firefly> ah - just do like the pointy-haired guy, then...
05:06:26 <shapr> actually, I never studied anything for school, I probably should have tried that when I was in college.
05:06:31 <choong> haha, if only it were that easy...
05:06:48 <choong> the pointy haired guy gets away with it because he has power.. I don't have such powers being a student ;)
05:06:57 <sazzle> heh
05:07:03 <sazzle> i did accounting for a semester
05:07:11 <sazzle> stayed away from commerce after that experience
05:07:15 <shapr> g'day sazzle, when do we get to see your other eye? or more sazzly spirals?
05:07:20 <choong> we get some accounting stuff too.. I hate it >.>;
05:07:55 <sazzle> shapr: sazzly spirals?
05:08:07 <shapr> yah, like on your website
05:08:16 <sazzle> hehe
05:08:31 <sazzle> i should update that thing
05:08:36 <sazzle> haven't touched it since first year!
05:08:37 <shapr> more spirals!
05:08:57 <sazzle> I'll get to draw after i finish my exams! :-)
05:09:04 <shapr> when's that?
05:09:23 <sazzle> well, i've got one tomorrow, one on friday, then tuesday, then one the week after that
05:09:27 <sazzle> so almost 3 weeks
05:09:39 <shapr> ok, then more spirals, right?
05:09:43 * shapr hOps
05:09:47 <sazzle> okay :)
05:09:52 * shapr boings happily
05:10:10 <shapr> choong: here's the jump in demo:
05:10:22 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
05:10:24 <earthy> accounting is useful
05:11:00 <sazzle> sure
05:11:00 <choong> I'm sure it is, but it's also boring .. I'd rather leave it to people who enjoy it
05:11:00 <vegai> anyone done a Wiki in haskell yet?
05:11:02 <sazzle> but also very dull
05:11:06 <vegai> Hiki ;D
05:11:12 <vegai> ("sweat" in Finnish)
05:11:13 <choong> hey cool
05:11:15 <choong> thanks sazzle :)
05:11:15 * earthy grins
05:11:17 <sazzle> i'd rather hire an accountant
05:12:07 <shapr> vegai: finnish is great for names. Paskalle is funny. So is Hiki.
05:12:24 <vegai> heh
05:12:57 <shapr> finnish is good for swearing also.
05:13:39 <vegai> yes, that's obvious
05:13:48 <shapr> sazzle: this looks like the Debian logo to me: http://shapr.homelinux.net/~shae/swirl2.jpg
05:14:27 <ozone> vegai: i was going to do a haskell wiki a long, long time ago ...
05:14:29 <shapr> choong: have you looked at the "jump in" demo?
05:14:40 <shapr> Sebastian Carlier wrote a wiki in Haskell
05:14:51 <shapr> a few other people have written wikis in Haskell also
05:14:55 <ozone> then i came to my senses and realised that an honours thesis would be better served doing something more substantial
05:14:59 <choong> lookin at it now
05:15:36 <shapr> sazzle: compare/contrast with http://www.debian.org/logos/openlogo-nd-50.png
05:16:23 <sazzle> shapr: hehe, i drew that before i even knew about debian :)
05:16:40 <choong> hmm
05:17:04 <choong> in the jump in demo...
05:17:42 <shapr> sazzle: btw, did you draw the keyhole iris pictures from someone you know? one of my cousins has a keyhole iris.
05:17:57 <choong> hmm nvm
05:18:14 <sazzle> shapr: keyhole iris?
05:18:17 <shapr> choong: feel free to ask any questions about that, I wrote it... so if it sucks you can bug me about it.
05:19:09 <sazzle> all the "artwork" on my website is 100% original crap from yours truely :-P
05:19:14 <shapr> sazzle: this looks like she has keyhole iris(es)? http://shapr.homelinux.net/~shae/girl.jpg
05:19:30 <sazzle> ooh
05:19:35 <sazzle> na.. i think i made that up
05:19:51 * sazzle has a habit of drawing lots of squiggly people like that on her friends note books
05:20:08 <shapr> anyway a keyhole iris is where the iris doesn't form quite right, it can end up looking like a cat's eye, or a keyhole, or other strange shapes.
05:20:25 <sazzle> ah
05:21:31 <sazzle> i see
05:21:38 <sazzle> (just googled)
05:21:51 <shapr> it looks very mysterious
05:23:02 <sazzle> it looks kinda teary
05:24:02 <shapr> did you find a pic?
05:25:11 <sazzle> yeah
05:25:22 <SyntaxNinja> Igloo: thanks for your post. i'll get to it asap
05:25:36 <sazzle> http://www.healthcentral.com/peds/fullsize/1130.jpg
05:25:41 <sazzle> just a drawing
05:25:41 <Igloo> Cool, ta
05:25:52 <Igloo> I just hope I wasn't missing /too/ many completely obvious things  :-)
05:26:07 <shapr> it looks *exactly* like a keyhole in my cousin's eye.
05:26:28 <Cale> http://vx.hn.org/art/
05:26:30 <shapr> very symmetrical well formed
05:26:41 <sazzle> exactly the same on both eyes?
05:26:44 <shapr> yup
05:26:57 <shapr> was *very* weird the first time I saw it.
05:26:57 <sazzle> does it affect her vision?
05:27:13 <shapr> I don't know, I haven't asked him.
05:27:28 <shapr> he's about seven years old now
05:27:36 <sazzle> ah
05:27:42 <sazzle> (sorry, him)
05:27:52 <shapr> well, I hadn't specified :-)
05:27:59 <SyntaxNinja> Igloo: probably not. I skimmed it last night, but didn't read it in detail.  we probably DO actually want a "clean" target. did you see the examples, btw?
05:28:19 <firefly> is this the place and time to draw attention to the scandinavian languages, where there actually is a difference?
05:28:26 <firefly> f?tter (faetter) = male cousin
05:28:31 <Igloo> Which examples?
05:28:32 <firefly> kusine = female cousin
05:28:36 <firefly> Very practical.
05:28:42 <sazzle> there's a difference in persian too
05:28:44 <shapr> firefly: sorry, we don't ever discuss scandinavian languages here :-P
05:28:55 * shapr is joking
05:29:02 <shapr> sazzle: oh, what's it like in persian?
05:29:22 <shapr> firefly: vi har #haskell.se också, om du vill talar svenska!
05:29:27 <shapr> hey Iter 
05:29:43 <firefly> jag pratar tyv?r inte svenska.
05:29:45 <SyntaxNinja> Igloo: the ones in the code, HUnit, Cabal, and "A"
05:29:46 <shapr> men kanske du trivs med dansk?
05:30:00 <firefly> Jep!  Det er meget sejere :)
05:30:06 <Igloo> No, then
05:30:10 <shapr> møøse!
05:30:19 <sazzle> well, maternal aunt is called 'khaleh', paternal aunt is called 'ammeh', maternal unkle is called 'daaii' paternal unkle is called 'amoo', and a daughter is 'dokhtar', son is 'pessar', so you just combine them, dokhtar khaleh is the daughter of your maternal aunt
05:30:35 <SyntaxNinja> Igloo: OK
05:30:35 <sazzle> s/unkle/uncle/
05:30:36 <ozone> dokhtar, i like that
05:30:48 <ozone> dokhtar saaaara
05:30:59 <shapr> does Sara have a PhD?
05:31:08 <ozone> no, but she should!
05:31:09 <shapr> Dr. Sara?
05:31:09 <sazzle> haha
05:31:12 <ozone> ozonebrowniepoints++
05:31:16 * shapr grins
05:31:16 * Igloo looks at A and continues to think that the "example" in 1.2 isn't actually an example at all
05:31:43 <sazzle> ozone: that almost means sara's daughter :-P
05:32:35 <Igloo> SyntaxNinja: The example uses sdist but the proposal talks about src-dist
05:32:59 <shapr> SyntaxNinja: I think the repo and the online aren't in sync
05:33:08 <firefly> Ok, say I want to hack on darcs.
05:33:11 <shapr> the docbook stuff
05:33:16 <shapr> firefly: then you should! cuz it's cool!
05:33:22 <shapr> Cale: nice art
05:33:29 <firefly> I like the fact that I can write darcs get http://abridgegame.org/repos/darcs.
05:33:31 <Cale> thanks :)
05:33:51 <firefly> What I don't like is the fact that it only uses one TCP connection and that it doesn't pipeline the GET requests.
05:34:05 <shapr> firefly: so hack in fsh support!
05:34:11 <shapr> err
05:34:16 <SyntaxNinja> Igloo: the repo and the "online"?
05:34:18 <shapr> dang, wrong protocol
05:34:19 <firefly> At least it only uses one connection, which stays open during the whole thing.
05:34:27 <Igloo> YM shapr
05:34:35 <firefly> (but it GETs the inventory file twice)
05:34:35 <ozone> DARCS_SSH=fsh darcs
05:34:37 <ozone> hax0red!
05:34:38 <shapr> SyntaxNinja: no, I said that... I think your docbook source and the current online html stuff aren't in sync
05:34:47 <shapr> ozone: is that really all it needs?
05:35:04 <SyntaxNinja> Igloo: yeah, I'll sync them up
05:35:09 <firefly> This gets kinda slow when you have almost 1700 patch files to receive...
05:35:11 <SyntaxNinja> (sdist, src-dist that is)
05:35:26 <ozone> shapr: most likely
05:35:30 <firefly> libcurl can handle more than one connection + can handle pipelining.
05:35:31 <shapr> hm, I gotta try that
05:35:41 <firefly> The trouble is how to integrate that into the darcs source code.
05:35:46 <SyntaxNinja> shapr: sorry... yeah, the CVS docbook version isn't deployed yet.  I have to make sure everyone's happy with it before I deploy it.
05:35:48 <ozone> firefly: hacking time
05:35:53 * Igloo uses http and mail currently as it seems easier to me
05:35:58 <Igloo> s/mail/signed mail/
05:36:06 <firefly> libcurl requires some sort of event loop if you want to use more than one connection or pipelining.
05:36:07 <SyntaxNinja> shapr: I wanted to get the parser for the file format written first.
05:36:41 <firefly> So how do you pump the libcurl event loop while your Haskell program is evaluating stuff lazily and possibly asynchronously?
05:37:06 <firefly> The easy ways out are to either do /all/ that stuff in C -- or to stuff all of it into the IO monad, right?
05:37:34 <firefly> The relevant files are: hscurl.c and Curl.hs (the copyUrl function)
05:39:01 <firefly> Oh, and Get.lhs and Repository.lhs (copy_repo_patches)
05:40:02 <firefly> A third way would be to use threads and pump the libcurl event loop in a separate thread -- but threading is hard and seems to have had problems on the mac.
05:40:16 <firefly> Apparently darcs used to use threads with libcurl.
05:44:26 <SyntaxNinja> does anyone have a procmail rule they can msg me which rejects =?windows subject lines? I don't think that I should trouble spamassassin with those.
05:45:04 <firefly> :0
05:45:23 <firefly> * ^Subject: .*=\?windows
05:45:31 <firefly> /dev/null
05:45:37 <firefly> Something like that should do the trick
05:46:58 <firefly> What about concurrent Haskell - does it require pthreads?  Or is it something internal to the run-time system, akin to the threading in Erlang?
05:52:04 <Cale> I believe it manages its threads internally.
05:52:07 <firefly> err... hello?
05:54:09 <firefly> Cale: without using pthreads or any other threading library?
06:05:01 <Iter> hey shapr.
06:05:42 <SyntaxNinja> firefly: thanks
06:06:06 <SyntaxNinja> firefly: you probably won't find a lot of people who know a lot about Concurrent Haskell
06:08:40 <firefly> :(
06:09:14 <Lunar^> firefly: it support both actually in GHC
06:09:30 <Lunar^> firefly: though the RTS itself is always single-threaded
06:10:11 <Lunar^> firefly: The best way to understand it, I think, is to read the scheduler source code
06:10:19 <Lunar^> firefly: ghc/rts/Schedule.c
06:10:23 <firefly> So there won't be any problems calling C code that might not be reentrant?
06:10:48 <Lunar^> firefly: If you use 'forkOS', I think it will be fine
06:12:01 <Lunar^> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html#v%3AforkOS
06:12:12 <Lunar^> "This means that you can use all kinds of foreign libraries from this thread (even those that rely on thread-local state), without the limitations of forkIO."
06:13:30 <firefly> Hmm... I am not sure I understand the implications of forkIO vs forkOS.
06:14:04 <shapr> TLS
06:14:11 <shapr> thread-local state
06:14:11 <firefly> I am trying to find the minimal, safe change to darcs to make it use HTTP pipelining and multiple parallel connections when it gets/pulls patches from a remote repository.
06:14:33 * firefly knows what tls is -- also at the kernel level.
06:14:36 <shapr> forkOS was first proposed after someone tried to use HOpenGL with threaded-runtime
06:14:50 <shapr> ok :-)
06:14:50 <Igloo> forkIO is cheaper when it works, I believe
06:15:12 <Iter> so shapr, how're things going on your half of the planet? 
06:15:18 <firefly> I seem to have deleted my ghc tarball :/
06:15:31 <shapr> Iter: warm and sunny, so I'm spending as much time outside as possible
06:15:34 <shapr> Iter: how's your half?
06:16:01 <Iter> far too cold.  We're getting minimums in single digits!!
06:16:33 <shapr> yow!
06:16:57 <Iter> heh.
06:19:37 <shapr> I'm tempted to setup #haskell oriented ScannedInAvian mirror of certain haskell sources
06:19:52 <firefly> would I want happy, haddock, and alex from ghc 6.2.1?
06:20:00 <shapr> sure!
06:20:06 <shapr> are you using debian?
06:20:21 <shapr> oh wait, you mean "what do I need to build darcs?" right?
06:20:21 <firefly> yes - I already have ghc installed from a .deb.
06:20:27 <shapr> apt-get source darcs
06:20:29 * Iter wonders what a Scanned-In-Avian looks like ;)
06:20:49 <firefly> I would like to play with building it myself - that's the way forward if one wants to hack, isn't it?
06:21:01 <SyntaxNinja> when I said "concurrent haskell", I meant it as a proper noun, fwiw, but I wasn't following the conversation, so I'm not sure if that's what firefly was asking about
06:21:06 <shapr> Iter: I'm canvassing for worthwhile images to put onto the front pages of ScannedInAvian.{com,org,net}
06:21:20 * shapr smacks SyntaxNinja with an MVar
06:21:26 <Lunar^> Igloo: It's the only choice when running a RTS without OS threads support
06:21:28 <firefly> shapr: no, I already have built darcs several times.  I even tried the (lousy) wx gui.
06:21:46 <SyntaxNinja> shapr: did you see the photo of me w/ a Haskell t-shirt?
06:21:57 <firefly> For an absolute beginner who doesn't really want to know about the haskell build tools it was not quite so simple to build wxhaskell ;)
06:21:58 <shapr> I saw one recently, you look stylish!
06:22:07 <shapr> firefly: SyntaxNinja is fixing that!
06:22:26 <firefly> Great!
06:22:39 <shapr> someone dropped the spoon of difficult Haskell installing, so SyntaxNinja flipped out and killed that problem!
06:23:00 <firefly> SyntaxNinja: the thing about needing the right configure option about opengl was not so nice.
06:23:01 <vegai> that lunatic!
06:23:17 <shapr> firefly: have you seen SyntaxNinja's nifty project named CABAL?
06:23:37 <SyntaxNinja> firefly: I'm not fixing darcs' particular build system, but trying to make it easier to build all haskell stuff.
06:23:43 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelld #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]' by shapr
06:23:47 <firefly> There was also something about a parameter that specified a file/directory where the currently installed haskell packages were listed.
06:23:58 <firefly> SyntaxNinja: again, building darcs is and was not a problem.
06:24:02 <firefly> Building wxhaskell was.
06:24:06 <Iter> shapr: Well how about a Moa, that'd probably have the advantage of confusing people ;)
06:24:11 <shapr> SyntaxNinja is taking the standard Haskell community approach, when in doubt, fix a more general problem.
06:24:31 <shapr> as opposed to the approach some other languages takes...
06:24:37 <SyntaxNinja> firefly: ahh
06:24:58 <firefly> (but I got it done anyway - it is not particularly nice that it takes huge compiles and links before one finds out that configure should have had a slightly different parameter)
06:25:09 <firefly> shapr: I like that approach :)
06:25:16 <shapr> me too
06:25:43 <firefly> Would I want objectio?
06:25:48 <firefly> Or threaded-rts?
06:26:33 <shapr> no to objectio
06:26:36 <shapr> yes to threaded-rts
06:26:40 <firefly> ok.
06:26:49 <shapr> though I think you don't have to specify either, I think those are the default settings
06:27:05 <firefly> what about hopengl?  Is it very particular about the kind of opengl libraries I have installed?
06:27:33 <shapr> it can be picky about that, building HOpenGL can become difficult in some cases
06:27:43 <shapr> if you use apt-get source ghc6 your life will be easier
06:27:56 <firefly> I don't want to ;)
06:28:04 <shapr> because then you'll get a source package that you know will build, and you can make changes to that
06:28:25 <shapr> it may be worthwhile if only to look at the build options that are used in the standard ghc6 debs
06:28:36 <shapr> courtesy of our motivated ghc6 maintainer
06:29:29 <shapr> I know I complained about HOpenGL at first (because I couldn't get it to build myself)
06:29:38 * Philippa_ wonders how hard it is creating bindings to C libs under win32
06:29:39 <shapr> when Igloo fixed it in the debs, I was thrilled
06:30:05 <Philippa_> or to put it another way: argh! *Another* tool that expects a *nix-like system during installation!
06:32:01 <JaffaCake> Philippa_: what tool is giving you grief?
06:32:35 <Philippa_> well, 'mcurrently looking at c->Haskell, though other suggestions would be appreciated
06:34:16 <JaffaCake> you might be able to get away with just hsc2hs & FFI, that's the usual way these days
06:34:42 <Philippa_> hrmm, how easy is it to get VC6 or VC.net to link against the RTS these days? Or does GHC spit it all out as source?
06:35:25 <JaffaCake> never tried... you're probably better off letting GHC do the linking
06:35:40 <Philippa_> in which case it'll probably screw up when I try to link against the win32 libs
06:35:43 <JaffaCake> (didn't understand the question about spitting it out as source)
06:36:16 <Philippa_> does GHC produce the RTS as C source when it's compiling via C?
06:36:32 <JaffaCake> no, the RTS is just another library
06:36:46 <Philippa_> 'cept under win32 you get two library formats to deal with
06:37:34 <JaffaCake> mingw comes with wrappers for all the win32 libraries, so you can just say -lole32 on the GHC command line and it works
06:38:10 <Philippa_> and if I want to work with another native lib that isn't one of that bunch?
06:38:49 <JaffaCake> then I think you have to make a .a version of it... you have reached the boundary of my knowledge on the subject :)
06:39:05 * Philippa_ nods
06:39:13 <Philippa_> figured
06:39:50 <Philippa_> OK, is there anywhere I can go request .lib versions of everything and possibly (stupidly?) offer a few cycles to compile 'em with?
06:40:23 <JaffaCake> you mean .lib versions of the GHC libs?
06:41:01 <Philippa_> yeah
06:42:01 <JaffaCake> Just looked at the docs for mingw, and it appears that ld can link in .lib libraries too
06:42:40 <Philippa_> 'k, wonder if it's possible to use it as a drop-in replacement for the MS linker in VC++...
06:43:09 <JaffaCake> you'd need to change the command line quite a bit
06:43:14 <firefly> What is the configure script /doing/ during "checking for DocBook CATALOG..." ?
06:43:20 <firefly> It took over 10 minutes!
06:45:34 <firefly> Note to self: when pressing ^Q to send an XON to a paused terminal, remember to click in the terminal window first :(
07:08:51 * shapr boings cheerfully
07:09:51 <shapr> hi Leimy
07:10:25 * SyntaxNinja bounces around shapr
07:10:47 * firefly bounces a round shapr
07:10:54 <shapr> hey, I'm not *that* round!
07:11:05 <earthy> let's do a groupbounce around shapr. :)
07:11:11 * shapr gets dizzy
07:11:16 <firefly> "Yo!  In your face!" ;)
07:11:46 <firefly> btw, what's the p stand for?
07:11:52 <shapr> eh?
07:11:58 <firefly> sha_p_r.
07:12:01 <shapr> shapr is short for shaper, I couldn't afford the vowel that day.
07:12:09 <shapr> oh, I see
07:12:12 <shapr> interesting
07:12:31 <shapr> shae is short for shapr, and shapr is short for shaper, and...
07:12:32 <shapr> oh whatever
07:13:22 <shapr> where does the nick 'firefly' come from?
07:13:42 <firefly> Marx brothers.
07:21:58 <shapr> hi ralf 
07:22:08 <shapr> how's Ohio?
07:22:30 <shaleh> morning all
07:23:13 <shapr> hiya shaleh, how's code?
07:24:19 * shapr pretends to be a screensaver
07:26:40 <shaleh> shapr: not had much time, work has been busy and we have been doing a fair amount of work at home. gardening, cleaning, etc.
07:26:54 <shapr> sounds like fun
07:26:58 <shapr> I like being outside in the sunlight
07:27:38 <shaleh> shapr: indeed. we have 3 massive squash plants and a little mini-forest of tomatoes. last night I was setting stakes and twine to prop up some peas.
07:28:00 <shaleh> some how programming seems less interesting (-:
07:30:30 <shapr> well, that's never happened to me
07:31:03 <shapr> instead I think about laptops and coding in the sunshine
07:31:33 <earthy> that doesn't work all too well
07:31:37 <earthy> you get drowsy too quickly
07:31:53 <earthy> especially if you sip your Pimm's
07:33:44 <edwinb> I tend to think of hiding in the basement away from the daystar...
07:33:50 <edwinb> or alternatively, finding a pub with a nice beer garden
07:35:02 <shaleh> oh, that is the other distraction -- prepping for mead making.
07:35:21 <shapr> earthy: pair programming! in the sunshine!
07:36:30 <earthy> shapr: you don't need laptops to do that
07:36:38 <shapr> argh, I just typed "file $ chase imapd.pem" into zsh
07:37:44 <shapr> chase turns a symlink into the actual file
07:37:44 <Igloo> That'll teach you to not use hsh
07:37:49 <firefly> what does $ do in Haskell?
07:38:10 <Igloo> Right associative loosely-binding function application
07:38:24 <Igloo> f $ g $ h x = f (g (h x))
07:38:39 <firefly> Ah, ok.  It's like o in ML.
07:38:48 <Igloo> Isn't o like .?
07:38:50 <firefly> So it is not function application but function composition.
07:38:51 <SyntaxNinja> igloo $ shapr $ firefly SyntaxNinja = igloo (shapr(firefly SyntaxNinja))
07:38:57 <Igloo> No, it is application
07:39:04 <firefly> ?!
07:39:08 <firefly> Ok, I'm confused.
07:39:15 <firefly> What is the difference between $ and . ?
07:39:19 <Igloo> (f . g . h) x = f $ g $ h x
07:39:29 <Igloo>  = f $ g $ (h x)
07:39:50 <Igloo> (f . g . h x) means \y -> f $ g $ h x y
07:39:56 <firefly> Is it just a question of syntax, i.e. binding tightness?
07:40:24 <firefly> Err... apparently not.
07:40:52 <shapr> gah, I can't make a shell script named $
07:42:09 <earthy> that makes sense
07:42:29 * shapr wants hsh
07:42:42 <earthy> as $ is used as a sort of escapecharacter
07:42:57 <Igloo> You can also use ($) when you want to pass function application as an argument, e.g. zipWith ($) [(+1), (*2)] [3, 4]
07:43:16 <shapr> firefly: is o used the same way in ML?
07:43:19 <firefly> Why would one want $ when . (plus parens) should be enough?  Is it the standard "because we can + it would be a cool paper"-haskell thing?
07:43:35 <shapr> ?
07:43:43 <firefly> o is just function composition in ML, similar to the math symbol.
07:43:47 <SyntaxNinja> hehe
07:43:49 * SyntaxNinja uses $ all the time
07:43:51 <firefly> Seems to be the same thing as . in Haskell
07:43:56 <Igloo> $ saves you two parens when you have the argument at the end, and also . and $ mean different things when passed as arguments to functions
07:44:05 <shapr> right, . /= $
07:44:45 <Igloo> Also you can say   wibble $ 1 + 2    to mean   wibble (1 + 2)
07:45:00 <Igloo> But I think that's rarer, and less easy on the eye
07:45:19 <shapr> I think $ is a lot easier to read
07:45:39 <shapr> noMimes msgs = filter isSinglePart $ map digestMessage $ msgs
07:45:58 <shapr> that's obviously a lazy pipeline
07:46:04 <shapr> well, obvious to me :-)
07:46:23 <firefly> Yes, it isn't strict!
07:46:43 * Igloo fails to reproduce a gcc segfault after 30 mins of CPU time, sighs, and wonders if it was caused by lack of memory
07:47:07 <firefly> Igloo: so the result would be [4, 8] ?
07:47:11 <Igloo> Yes
07:47:40 <firefly> And the only practical use of $ is to avoid some parentheses?
07:48:02 <Igloo> And to pass application as an argument
07:48:24 <firefly> Yeah, well, but how often is that used?  It is a neat trick, but...
07:48:29 <Igloo> The only practical use of . is to avoid a \ -> and parens though
07:48:33 <firefly> ... not something I would expect to see in much code.
07:48:34 <shapr> I use $ *lots*
07:48:39 <firefly> Or am I totally wrong there?
07:48:42 <shapr> mboxSplit instring = map unlines $ breakAll (isPrefixOf "From ") $ lines instring
07:48:44 <shapr> msgList msgstrings = catRight $ map parseMessageFromString msgstrings
07:48:46 <shapr> noMimes msgs = filter isSinglePart $ map digestMessage $ msgs
07:48:53 <firefly> shapr: but do you use for other purposes than to avoid some parentheses?
07:49:04 <shapr> I also use it as first class 'application'
07:49:33 <firefly> Let me see if I can rewrite your examples without $...
07:49:33 <shapr> but getting rid of parens is worthwhile to me
07:49:37 <SyntaxNinja> firefly: it's likely more clear (for reading) to most haskell programmers, since you don't have to count parens.
07:49:53 <Igloo> I think I probably use $ in cases analogous to where I use id, but I can't think of one OTTOMH
07:49:56 <earthy> it makes Haskell less lispy
07:50:17 <firefly> noMimes msgs = filter isSinglePart (map (digestMessage . msgs))
07:50:23 <shapr> let result = filter hasMsgid $ noMimes $ msgList $ mboxSplit conts
07:51:00 <firefly> msgList msgstrings = catRight map --- hmmm this isn't right, is it?
07:51:05 <Igloo> noMimes = filter isSinglePart . map digestMessage   would be the shortest way of writing it
07:51:17 <shapr> ah, point-free
07:51:18 <Igloo> I wouldn't have put the last $ of shapr's in
07:51:36 <shapr> I think I had something else there at some point
07:51:45 <Igloo> It's   filter isSinglePart (map digestMessage msgs), not what you wrote
07:51:51 <shapr> then it disappeared, but I forgot to take out the $
07:52:31 <firefly> Igloo: ah, right.  Misread on my part.
07:52:49 <firefly> So writing map $ f is kind of superfluous, isn't it?
07:52:56 <firefly> (instead of map f)
07:53:13 <shapr> usually
07:53:38 <earthy> it is quite useful for the IOHCC...
07:53:46 <Igloo> :-)
07:53:48 <firefly> so the msgList msgStrings = catRight map is correct?
07:54:04 <shapr> speaking of which, I really need to get up some IOHCC pages
07:54:12 <shapr> the old pages are getting some hits
07:55:12 * Igloo needs to think about an entry
07:55:57 <firefly> msgList msgstrings = catRight (map parseMessageFromString) msgstrings  ?
07:56:11 <firefly> let msgList = catRight (map parseMessageFromString) ?
07:58:20 <Igloo> No, msgList = catRight . map parseMessageFromString
07:58:45 <Igloo> In yours the msgstrings would be the second argument to catRight, not the second to map
07:59:09 <Igloo> Or   msgList msgstrings = catRight (map parseMessageFromString msgstrings)
07:59:29 <firefly> Ok, so $ does as much of an application as it can?  I thought it only applied one argument
08:01:05 <Igloo> ' ' is infixl 10. $ is infixr 0. Otherwise they are identical
08:01:36 <firefly> Thanks! :)
08:01:58 <firefly> $ is perhaps not the most beginner-friendly feature in Haskell ;)
08:02:15 <firefly> I think I've got it now, though.
08:06:32 <firefly> Something that will definitely take me a while to get used to is the where clause.
08:06:52 <sazzle> why?
08:06:59 <SyntaxNinja> where is WAY easier than $ :)
08:07:02 <firefly> If I read a function definition that refers to an identifier I don't know about yet, I expect to find it /earlier/ in the program source or in an included module.
08:07:02 <sazzle> i find myself using it in english a lot
08:07:18 <firefly> I /never/ expect it to be /below/ the point where I am currently reading.
08:07:35 <Igloo> How would you write this in ML then?
08:07:36 * jemfinch isn't particularly fond of where clauses for the same reason.
08:07:37 <sazzle> i see it as further explanation
08:07:39 <Igloo> let f x = g x + 1
08:07:42 <firefly> SyntaxNinja: sure, it is /very/ simple.  It is just hard to rewire my reading habits.
08:07:42 <SyntaxNinja> firefly: does defining functions out of order bother you too?
08:07:43 <jemfinch> Igloo: use either local or let.
08:07:45 <Igloo>    g y = f y * 2
08:08:17 <firefly> SyntaxNinja: yeah - I am used to prototypes in C, forward declarations in Pascal and the "and" keyword in ML.
08:08:29 <sazzle> like, |f==complicatedExpression = 5
08:08:31 <Igloo> jemfinch: But one of the two will always be first
08:08:40 <sazzle> where complicatedExpression = explanation of it
08:08:49 <jemfinch> Igloo: I answered before you sent both lines :)
08:09:11 <firefly> sazzle: yes, but the point is that I /never/ look downwards for that explanation.
08:09:11 <SyntaxNinja> firefly: so when using recursion, you kinda have to break your mental model of the functions in order to understand what's going on, right?
08:09:24 <SyntaxNinja> (in C or something)
08:09:32 <Igloo> where gives you a nice top-down view, anyway
08:09:46 <sazzle> Igloo: yeah, that's what i like about it
08:09:47 <SyntaxNinja> (mutual recursion, that is)
08:10:09 <Igloo> wibble x y = flibble x + bibble y, oh, and here's how you flibble and bibble in case you need to care about that at the moment
08:10:21 <firefly> I expect it to be introduced /above/ in the text.  When I read let ... in ... end in ML I don't try to understand the declared functions/vars, I just make a mental note of their existence and position.  After I see how they are used, I refer back to their definition (which I /know/ the position of).
08:10:24 <Igloo> But mostly you'll just want to know there's some flibbling and bibbling involved
08:11:13 <shapr> for me, it's often easier to get a high-level overview of an algorithm, and then have where show the gritty details of each step
08:11:22 <firefly> SyntaxNinja: I am not sure I follow you here?
08:12:48 <SyntaxNinja> firefly: so when you're trying to undersand code, do you go looking in the .h file for the type sig first, or do you look above for the definition first?
08:13:10 <firefly> shapr: yes, I do the same.  That's why I don't always read the definitions in the inner let in ML closely at first.  But I like the fact that they are presented beforehand, so I know where they are when I need them.  When I read the main expression in the function I don't have to go "oh, was this defined in a global function above?  Was it included from a module?  Hmmm... (scratches head)...Oh!  Right, it is defined down here!"
08:13:12 <SyntaxNinja> firefly: it's often used in cases where the value of the symbol / function is obvious
08:13:31 <SyntaxNinja> so you don't particularly need to go looking at the definition
08:13:37 <SyntaxNinja> hi alexj
08:14:52 <firefly> Depends.  It is often clear in C where the unknown functions come from (if the code is well-written).  The trouble is when I /don't/ immediately see where the symbols are defined.
08:15:25 <firefly> I know that this is mainly a matter of taste and experience but changing twenty-year-old habits can be hard, especially when they are so much below conscious control.
08:15:28 <sazzle> firefly: well, there's only 3 places to search for each identifier in a haskell function
08:15:39 <shapr> global, let, and where?
08:15:40 <sazzle> the where clause, other functions, imported functions
08:15:50 <firefly> And let?
08:15:52 <sazzle> oh, yeah, and let
08:15:56 <sazzle> so, 4
08:16:02 <firefly> And nice red uniforms.
08:16:08 <shapr> mmmm, Fetched 73.0MB in 35s (2071kB/s)
08:16:40 <shapr> hiya kowey, wassup?
08:16:48 <sazzle> and i find my haskell fns are shorter than my c functions
08:16:55 <sazzle> which makes it even easier
08:16:55 <kowey> hi shapr!
08:17:00 <firefly> Yes, of course :)
08:17:02 <kowey> something to show you folks in a minute
08:17:09 <shapr> ohh, code?
08:17:21 <kowey> eventually
08:17:22 <kowey> but not quite
08:17:26 <firefly> The `make-this-function-an-operator` trick is nice.
08:17:50 <firefly> The (make this operator into a function) is perhaps a bit too subtle.
08:18:14 <shapr> it feels orthogonal to me
08:18:41 <shapr> you also get (1 +) to do "turn this operator and one argument into a function"
08:18:45 <Igloo> Too subtle because parentheses have other meanings?
08:18:45 <SyntaxNinja> firefly: I bet that where won't be too hard to get used to, actually.
08:18:54 <firefly> Igloo: precisely.
08:19:47 <firefly> shapr: Well, that one is perhaps also a bit too subtle.  Any currying at all is hard to grasp for beginners, currying the other way around is even harder, I think.
08:20:06 <firefly> SyntaxNinja: I hope not.  And I also hope it won't contaminate my ML programming ;)
08:20:16 <shapr> huh, currying feels more natural to me than anything else
08:20:35 <Philippa_> sorta depends if your beginner's seen another language or not
08:20:35 * SyntaxNinja curses
08:20:43 <shapr> SyntaxNinja: ncurses? ;-)
08:20:56 <firefly> use slang instead.
08:21:02 <shapr> I really like the closure as poor man's object pattern.
08:21:09 <SyntaxNinja> there's a bug in my WM such that when I ALT-Tab to a window, it occasionally tries to switch to a window that's not there, and crashes the WM, presumably because it has over-shot an array boundtry
08:21:19 <firefly> (or write your own thing directly against VT100, it is not too hard)
08:21:20 <shapr> that's when currying and partial application become verry useful.
08:21:21 <SyntaxNinja> so then the WM restarts itself.
08:21:33 <SyntaxNinja> but I was in the middle of a dist-upgrade, and the WM isn't restarting for some reason
08:21:34 <firefly> closures are great!
08:21:37 <SyntaxNinja> so all I can do is IRC
08:21:48 <shapr> SyntaxNinja: that ok, we don't mind talking to you for hours on end
08:22:00 <kowey> http://www.loria.fr/~kow/deakowey.pdf
08:22:01 <sazzle> currying is cool
08:22:04 <sazzle> look at c++
08:22:05 <kowey> please see page iii
08:22:11 <sazzle> :)
08:23:53 <SyntaxNinja> great... I can't log into a console either
08:23:58 * SyntaxNinja wonders what's up
08:24:13 <shapr> kowey: yay cool! we got credits!
08:24:42 <kowey> thanks for all the help, guys!
08:25:05 <kowey> anyway, gotta run.... bye
08:25:26 <shapr> cool, we got printed credits for being friendly and helpful here on #haskell
08:26:33 <firefly> unsafeInterleaveIO ?
08:29:04 <firefly> mand ?  "monad and" ?
08:30:06 <firefly> Is there also a "mor" ?
08:30:17 <shapr> there's mplus
08:30:29 <shapr> the monad classes are useful idioms to know
08:30:31 <jemfinch> and mzero.
08:39:44 <shapr> greetz desrt 
08:39:57 <desrt> hey.  what up?
08:40:09 * desrt takin' a sick day :/
08:42:34 <Riastradh> You've come down with the monads, eh?
08:43:01 <desrt> feels more like the plague, i think
08:43:23 <Riastradh> You've got boils all over your skin?
08:43:54 <desrt> no.  but last night i felt really bad
08:44:00 <desrt> ...
08:44:17 <Leimy> heh I have a headache like crazy bad
08:44:27 <desrt> i had all the symptoms of a cold plus all the symptoms of a flu
08:44:29 <desrt> it sucked
08:44:29 <Leimy> no sick time for me... I work from home :)
08:44:41 <desrt> heh
08:44:44 <desrt> i work from home if i choose to
08:44:53 <Leimy> nice... I have no choice
08:44:55 <Leimy> I work from home
08:44:56 <Leimy> :)
08:45:06 <Leimy> no office but the one at home
08:45:22 <desrt> i like my office
08:45:35 <desrt> it's the same place as my school :)
08:45:37 <Leimy> i sometimes wish I had one
08:45:59 <desrt> summer job at school = r0x0r
08:47:34 <shapr> yah, I work from home too
08:47:43 * shapr is working right now
08:47:57 <desrt> your job is to irc?  sweet
08:48:06 <desrt> :)
08:48:08 <shapr> :-P
08:48:25 <shapr> my job right now is to figure out why these events have gone missing in this website
08:48:39 <shapr> that and sixty-seven other things
08:49:32 <shapr> desrt: how's the Haskell cluster doing?
08:49:42 <desrt> heh
08:49:45 <shapr> are you guys using hMPI?
08:49:50 <desrt> we were supposed to have a demo ready for friday
08:49:58 <desrt> ...
08:50:03 <desrt> we're nowhere near demoable yet
08:50:08 <shapr> my recent googling suggest that either hMPI or parr would be your best bets
08:50:18 <desrt> and the cluster doesn't run haskell... it runs a language we're creating
08:50:24 <shapr> ah, ok
08:50:25 <desrt> but the compiler for the language is in haskell
08:50:39 <desrt> and the language is functional
08:51:07 <desrt> the project is quite ambitious
08:52:17 <shapr> something like Sisal/FISh/etc?
08:52:58 <desrt> i don't know any of those
08:54:08 <shapr> obviously highly parallel, referentially transparent? explicit or implicit parallelism?
08:54:32 <shapr> what sort of parallel? SIMD? MIMD? MPMD?
08:55:04 <desrt> we're doing simd on each machine using altivec
08:55:14 <shapr> PPC?
08:55:16 <desrt> and multiprocessing on each machine because they have 2 cpus
08:55:18 <desrt> right.
08:55:24 <shapr> huh, a G5 cluster?
08:55:29 <desrt> plus we're clustering about 20 of the things
08:55:32 <desrt> mhmm
08:55:37 <shapr> wow, spiffy
08:55:47 <desrt> half of it was due to arive on june 8th
08:55:50 <desrt> it didn't
08:55:50 <desrt> ...
08:55:54 <shapr> yipe
08:56:09 <desrt> our bookstore sucks :P
08:56:25 * shapr used to sell Apple hardware in a bookstore
08:56:32 <desrt> heh
08:56:48 * desrt vents his current frustrations on you, then
08:56:52 <shapr> bah, we were great
08:56:56 <desrt> :)
08:57:05 <shapr> except when Apple themselves made our life difficult
08:57:24 <desrt> ya.  i think apple is probably at fault here
08:57:38 <shapr> we sold m68k apples when I started, so it's been awhile
08:57:44 <desrt> :)
08:58:04 * shapr still has a bunch of apple t-shirts
08:58:04 <desrt> i used to own a m68k
08:58:07 <desrt> performa 460
08:58:21 <desrt> one of the first 68ks with virtual memory :)
08:58:25 <andersca> shapr: I want one!
08:58:27 <shapr> I vaguely recall that the performa 636 was better
08:58:40 <desrt> shapr; it probably was
08:58:42 <shapr> andersca: they're heavily worn, but if you want, I'll send 'em
08:58:59 <desrt> heh.  apple sent us a couple of free tshirts
08:59:21 <desrt> and a  bunch of dvds and software
08:59:24 <desrt> and an invite to wwdc
08:59:29 <shapr> I also have tshirts from  macromedia, about.com, and a smattering of other places
08:59:35 <shapr> vendorware is my favorite
08:59:46 <desrt> i don't wear shirts that have writing on them
08:59:49 <desrt> or logos
08:59:55 <desrt> or really, anything that's not a solid colour
09:00:05 <shapr> I prefer to have as many logos and as much writing as possible on my tshirts
09:00:14 <desrt> freak.
09:00:24 <andersca> me too
09:00:40 <desrt> hmm
09:00:46 <shapr> desrt: we want your t-shirt!
09:00:49 <desrt> i think i am going to make some breakfast
09:00:52 <shapr> the apple t-shirt that is
09:00:53 <desrt> make some tea
09:00:58 <shapr> tea-shirt?
09:00:59 <desrt> shapr; it's not mine
09:01:05 <desrt> we got 2
09:01:11 <desrt> there are like 6 people working on the project
09:01:22 <shapr> so, cale gets one and anand(?) gets the other?
09:01:25 <desrt> so instead of deciding who gets the shirts we just put them on the shelf
09:01:37 <desrt> christopher
09:01:51 <desrt> well.. ya.  dr. anand
09:02:01 <shapr> I've only heard of Cale, desrt, and the boss prof
09:02:05 <shapr> yah, him
09:02:17 <desrt> we have a saaed, a rebecca and an andrew
09:02:42 <shapr> more haskellers?
09:02:46 <desrt> some
09:02:56 <desrt> saaed helps out cale or rebecca alternatively
09:03:15 <desrt> andrew is working on the physics side of thing (the initial primary purpose for this supercomputer is processing MRI data)
09:03:34 <shapr> oh neat
09:03:44 <desrt> and rebecca is working on improving the darwin operating system to make things like allocating huge chunks of memory and sending huge amounts of data over ethernet more efficient
09:03:59 <desrt> oh.  and gord.  he's working on the higher level language stuff right now
09:04:10 <shapr> sounds like a fun project
09:04:14 <desrt> it is.
09:04:28 <desrt> heh.  i'm the only one not getting paid :P
09:05:10 <desrt> (i'm getting paid by the department for other work that i'm doing... but not officially for working on coconut)
09:07:38 <desrt> now, of course... making breakfast means "i just poured some cereal into a bowl"
09:08:58 <shapr> my favorite
09:19:29 * desrt outside now
09:28:40 <SamB> hmm, how do you google for something like -fallow-undecidable-instances?
09:28:51 * SamB decides to grep his doc tree instead...
09:30:25 <Riastradh> "fallow undecidable instances" -- (with the quotes) that brings up quite a few hits.
09:33:28 <shapr> anyone have a clue about IMAP?
09:33:36 <desrt> shapr; i wrote an imap client once...
09:33:38 <saynte> is that like UHAUL?
09:33:39 <shaleh> shapr: some
09:33:55 <shapr> I'm trying to setup IMAP/SSL on my server, but I can't figure out how my email gets from /var/spool/mail into my ~/Maildir
09:33:58 <shaleh> desrt: brave man, that is one messed up spec.
09:34:02 <Lemmih> Is there an current (>=ghc6.2) version of this code: http://www.haskell.org/hawiki/HaskellUnixDaemon?
09:34:10 <desrt> shapr; install procmail
09:34:15 <desrt> shapr; and use it to deliver to your maildir
09:34:34 <desrt> put |/usr/local/bin/procmail in your ~/.forward
09:34:39 <shapr> oh, that's it?
09:34:42 <SamB> shapr: I hear IMAP has messy syntax
09:34:44 <desrt> that's what i did
09:35:10 <shaleh> why doesn't the IMAP server read directly from /var/spool/mail like the pop3 daemons do?
09:35:16 <desrt> in your .procmailrc file:
09:35:17 <shapr> yah, I was wondering that myself
09:35:17 <desrt> DEFAULT=$HOME/.maildir/
09:35:19 <saynte> desrt: hey how's it going? (still UT'ing? ;))
09:35:34 <desrt> UT?
09:35:35 <shapr> my .forward is already dealing with TMDA
09:35:41 <saynte> Unreal Tournament
09:35:45 <saynte> "You inverted the mouse?!"
09:35:46 <desrt> saynte; not so much, no
09:35:58 <shaleh> shapr: speaking of TMDA, did you fix the sender as I mentioned?
09:35:59 <desrt> ..
09:36:01 <saynte> saynte: ah well, i guess it had to run out sometime
09:36:04 <desrt> who are you? :)
09:36:07 <saynte> haha, scott
09:36:10 <desrt> hah.
09:36:16 <desrt> hi :)
09:36:21 <shapr> shaleh: nah, but I will
09:36:25 <saynte> hey therrrre
09:36:28 <desrt> i'm doing a little bit of working from home today too :)
09:36:30 <shapr> I think it's just using /etc/passwd
09:36:36 <saynte> so what's shakin? ah yeah? it's the way of the future
09:36:43 <desrt> get jabber, you freak :)
09:36:53 <saynte> haha
09:36:54 <SamB> hmm. there should be a way to have -fallow-*-instances but have ghc make noise about it...
09:36:58 <shapr> shaleh: ok, fixed
09:36:59 <saynte> jibba-jabba more like, foo ;)
09:37:10 <desrt> i like how people recognise "desrt" :)
09:37:15 <shapr> SamB: like, -fcomplain-*-instances ?
09:37:33 <SamB> shapr: does it have that or not?
09:37:35 <saynte> i prefer to think of it as "dessert". because food is delicious
09:37:39 <shapr> not that I know of
09:37:50 <SamB> shapr: something like that, yeah
09:38:04 <desrt> saynte; a friend of mine once modifed the 'dessert menu' at bahaus accordingly :)
09:38:17 <desrt> de s rt
09:39:00 <SamB> -fcomplain-nonstandard-instances would be a good name for a catch-all
09:39:02 <saynte> desrt: haha, ah yeah?
09:39:07 <saynte> desrt: what a kind gesture!
09:39:13 <desrt> saynte; boredom is a great motivator :P
09:39:21 <saynte> desrt: next only to hunger
09:39:30 * desrt just had breakfast
09:39:32 <desrt> mm.
09:39:42 <desrt> you know what the best thing ever is?  wifi
09:39:54 <firefly> cereal in a bowl, you mean.
09:40:02 <desrt> firefly; it's breakfast.
09:40:06 <saynte> breakfast? it's past noon! hehe
09:40:13 <desrt> when do you think i get up? :)
09:40:13 <saynte> wifi is preettttty nice
09:40:18 <saynte> oh wait! nm ;)
09:40:24 <desrt> ya
09:40:27 <desrt> wtf is up with the itb wifi?
09:40:29 <desrt> it's all borked
09:40:41 <desrt> from what i understand CIS came in and shut derrek down
09:40:43 <saynte> meh, i have no idea, i don't have any need of it now.
09:40:50 <saynte> what was derrek doing?
09:40:57 <desrt> providing superior wifi service
09:41:03 <desrt> it frickin ruled
09:41:11 <desrt> you went to talk to him and gave him your wireless mac address
09:41:26 <saynte> i never did do that....
09:41:28 <SamB> desrt: meanies!
09:41:28 <desrt> and he set you up with a static IP address on a private network that was natted onto the mcmaster network to an IP with no firewall restrictions
09:41:35 <desrt> ie: it was perfect
09:41:46 <saynte> oh, heeh, that is pretty cool
09:41:53 <desrt> but CIS has this big thing now about how they have 'license' to the wireless frequencies anywhere on campus
09:42:06 <SamB> hmm, the part about no firewall restrictions sounds like a no-no
09:42:21 <desrt> SamB; your IP is tied to your machine
09:42:24 <saynte> hmm, well as long as he's improving mcmaster, shouldn't they be happy that they didn't have to do any work to get that all set up
09:42:44 <desrt> saynte; i think they want to take the wifi network that they have setup in the musc/hsc (openport) and put it everywhere
09:42:48 <desrt> which is an admirable goal
09:42:54 <desrt> except that it sucks compared to derrek's network
09:43:03 <desrt> but at least it will be consistent....
09:43:13 <saynte> well I could play tribes on it ;)
09:43:21 <desrt> right.
09:43:30 <saynte> i remember a few lazy afternoons i just sat in the library playing tribes between class heh.
09:43:32 <desrt> you can hit other unauthenticated users on the network no problem
09:43:36 <SamB> desrt: how can you have an exclusive license to the wifi frequencies?
09:43:43 <desrt> samb; i said the same thing
09:43:54 <desrt> samb; except you have to realise that the university is private property
09:43:59 <saynte> yeah, exactly
09:44:04 <SamB> desrt: where is this?
09:44:04 <saynte> and well, his employer
09:44:10 <desrt> saynte; right again
09:44:17 <SamB> like, what country?
09:44:23 <desrt> if i drove my car onto campus with a wifi broadcaster inside there's not much they can do
09:44:33 <desrt> but they give derrek his paycheque... so they can pursuade him to stop :)
09:44:38 <desrt> samb; canada
09:44:39 <saynte> desrt: spike trap and armed security!
09:44:45 <shapr> I've thought about that, car + wireless AP with various interesting materials
09:44:49 <desrt> saynte; uhh.
09:44:50 <desrt> :)
09:44:57 <shapr> meatspace p2p
09:45:02 <desrt> hmm.
09:45:13 <SamB> if it was the US, I'm pretty sure you'd be allowed to use the wifi if they weren't...
09:45:18 <desrt> shapr; have you been paying attention to the latest happenings with the wrt54g and WDS?
09:45:24 <shapr> nah, what's up?
09:45:33 <desrt> SamB; it's really the same story here
09:45:57 <desrt> shapr; the box runs linux and linksys released the sourcecode
09:46:00 <shapr> Lemmih: what's wrong with the daemon code?
09:46:02 <shapr> oh, that one
09:46:08 <shapr> yah, I have some really interesting ideas for that
09:46:13 <desrt> so people are making mash networks out of these things now
09:46:16 <desrt> *mesh
09:46:21 <shapr> aka ad-hoc
09:46:25 <desrt> not quite
09:46:35 <desrt> mesh as in forwarding ala WDS (wireless distribution)
09:46:44 <shapr> ah, I thought ad-hoc implied that
09:46:44 <desrt> ie: one person in the neighbourhood buys a cable connection
09:46:46 <desrt> and everyone can use it
09:46:48 <shapr> right, I understand
09:46:54 <shapr> I've thought of running an ISP that way
09:46:57 <desrt> no.  ad-hoc is still only if you can directly see the person you're talking to
09:47:04 <desrt> no relaying
09:47:11 <shapr> stick up a city-wide free local mesh, only charge for to-internet traffic
09:47:18 <saynte> desrt: oh hey, i successfully accomplished a (probabaly) trivial task, I got gtkmozembed out of gtk+hs and into gtk2hs
09:47:28 <desrt> saynte; elite
09:47:31 <shapr> saynte: want copy!
09:47:35 <desrt> gtkmozembed is sweet :)
09:47:36 <shapr> galeon is pissing me off
09:47:46 <desrt> shapr; get ephy
09:47:56 <saynte> haha, well, it's pretty cruddy, and i have to clean it up some for kahl
09:48:01 <shapr> dude, I want a browser written in Haskell
09:48:05 <saynte> lol
09:48:11 <desrt> shapr; most of it's written in C/C++
09:48:33 <shapr> if it's just the renderer that's embedded, that's good enough for me
09:48:37 <saynte> yeah, you'd still have to have either firefox or mozilla, that's the part that's doing all the heavy lifting.
09:48:42 <desrt> shapr; and the network code
09:48:42 <saynte> hehe
09:48:49 <desrt> shapr; and the idea of being able to go places
09:48:50 <shapr> Lemmih: do you have a non-working daemon with that code?
09:48:57 <desrt> shapr; and everything else except the UI
09:49:07 <desrt> shapr; which would be implimented in GTK.... which is also written in C...
09:49:11 <shapr> there's Browser.hs
09:49:15 <desrt> so really haskell would just be 20 lines of glue :)
09:49:29 <saynte> but marvellous FP glue...
09:49:32 <shapr> desrt: as long it lets me glue stuff together in such a way that it doesn't crash, that sounds great
09:49:41 <desrt> saynte; they've obviously gotten to you!
09:49:43 <desrt> repent now!
09:49:50 <saynte> salvation!! not damnation!!
09:50:00 <shapr> saynte: hey, where can I get the gtk2hs version of juhp's gtkmozembed?
09:50:02 <saynte> desrt: no, that's just the party line i have to maintain
09:50:04 <desrt> C forever
09:50:10 <desrt> saynte; ah.  word
09:51:31 <desrt> i guess if you're getting paid... :)
09:51:31 <saynte> desrt: kahl is always watching... always...
09:51:31 <saynte> haha yeah
09:51:31 <desrt> hahah
09:51:38 * shapr tries to browse saynte's p2p Haskell source share
09:51:38 <desrt> btw
09:51:38 <desrt> about your table editing software
09:51:38 <desrt> i was thinking about you in the shower last night
09:51:38 <desrt> ...
09:51:38 <desrt> (seriously though.. i do a lot of thinking there)
09:51:38 <saynte> shapr: where? i dunno, who's juhp?
09:51:40 <saynte> yessir?
09:51:40 <desrt> remember in 2aa4 when wassyng was talking about tables and creating code from them?
09:51:40 <saynte> yep, i do recall
09:51:40 <desrt> and i asked if there existed software to create code from tables
09:51:40 <desrt> or even a compiler to create executable code
09:51:40 <saynte> yep, remember that too
09:51:45 <desrt> i've since become interested in creating such a thing
09:52:00 <desrt> how does your table editing software work, exactly?
09:52:11 <saynte> aha, fatal flaw, you're assuming it works at all!
09:52:16 <desrt> heh.
09:52:20 <desrt> ok.  better question
09:52:31 <desrt> what will you be able to do with it and what will the output format look like
09:52:35 * shapr lags horribly
09:52:37 <saynte> well basically right now it's very simple, it only works on regular 2d tables (and even it only uses cdata as the contents)
09:52:56 <desrt> by regular 2d tables you mean all cells are 1x1?
09:53:05 <saynte> i'm hoping to implement some expressions as cell/header contents as well
09:53:41 <desrt> for parnas tables you need cells that can be larger than other cells...
09:53:43 <saynte> regular 2d tables are 2d tables that have the same 2d headers
09:53:52 <saynte> these are kahl tables
09:54:06 <desrt> hah.  were you there when i called them wassyng tables and everyone laughed at me? :)
09:54:12 <shapr> saynte: psst, do you have a working gtk2hs version of gtkmozembed?
09:54:15 <saynte> ohh i forget
09:54:30 <saynte> shapr: i have a hacked version of the gtk+hs code
09:54:32 <desrt> i was either talking to you or viwien
09:54:38 <saynte> shapr: which i'm not sure works 100%
09:54:58 <saynte> hmm, well i think it was perhaps when we were outside last time, but i know understood
09:55:11 <shapr> saynte: I want a copy!
09:55:24 <saynte> shapr: i struggled with it for about a day, and when it finally worked i had to leave it behind, it was becoming too stressful to even think about ;)
09:55:25 <shapr> greetings hsd, looking for Haskell info?
09:55:42 <shapr> saynte: can you send me a copy?
09:55:50 <desrt> <hsd> i heard you guys were giving out free cookies to interested programmers?
09:55:51 <hsd> Yeah, why is it worth learning haskell?
09:55:56 <desrt> hsd; free cookies!
09:56:00 <saynte> shapr: alright, but i can guarantee it's ugly ;)
09:56:05 <shapr> saynte: that's fine with me
09:56:26 <shapr> hsd: the most useful reason is that you'll learn powerful ways of programming that you can apply in any language or job
09:56:44 <shapr> saynte: ack, I can't do DCC with this elisp client :-(
09:56:50 <shapr> do you have sendfile? or can you mail it to me?
09:56:57 <saynte> sure, i can do mailing
09:57:00 <shapr> hsd: for sheer niftiness, Haskell has lots of cool trix
09:57:11 <shapr> saynte: user is shae, hostname is Scanned In Avian dot com
09:57:20 <hsd> shapr: So it uses a different programming paradigm than the usual langs?
09:57:26 <shapr> since #haskell is logged, I try to give out my literal email addy
09:57:31 <shapr> hsd: yes it does
09:57:32 <hsd> What is the difference between haskell and lisp, scheme?
09:57:43 <desrt> shapr; give up and install a good spam filter
09:57:49 <shapr> the biggest difference is referential transparency
09:57:58 <saynte> desrt: lol
09:58:09 <desrt> hsd; lisp is impure.  it lets you cheat
09:58:12 <shapr> haskell works more like an equation, each function must return the same result for a given input
09:58:16 <desrt> (by allowing side-effects)
09:58:23 <saynte> shapr: scanned in avian, should that all be one word?
09:58:24 <desrt> so you can have non-deterministic functions
09:58:26 <shapr> saynte: yup
09:58:38 <shapr> saynte: merci!
09:58:48 <desrt> because of the deterministic and non-side-effect-causing nature of haskell functions you can have some interesting optimisations
09:59:00 <saynte> shapr: de rien!
09:59:11 <shapr> hsd: also, haskell doesn't have variables and loops as you know them, so you get other neat optimisations
09:59:26 <Riastradh> Haskell certainly has variables.
09:59:29 <shapr> it does, sure
09:59:30 <desrt> hsd; everything becomes a recursive algorithm :)
09:59:33 <Riastradh> It doesn't have _mutable_ variables.
09:59:36 <shapr> right!
09:59:39 <hsd> Are there any good books to get me started with haskell?
09:59:43 <Riastradh> Yes.
09:59:43 <desrt> Riastradh; he did say "...as you know them"
09:59:58 <shapr> hsd: sure, several good books, and some worthwhile online tutorials as well
10:00:25 <saynte> hsd: as a note, i found hudak's book.. not the best, if you're considering it. unfortunately that's the only one i've tried :)
10:00:28 <shapr> if you have a comfortable math background, I'd recommend Paul Hudak's "Haskell School of Expression"
10:00:32 <saynte> hehe
10:00:49 <saynte> but some people may have different opinions :)
10:01:02 <shapr> if you don't like algebra much, you could try Thompson's "Haskell : The Craft of Functional Programming"
10:01:26 <shapr> saynte: imho, the advantage of Hudak's book is that it doesn't point out monads as something different or scary
10:01:41 <shapr> you just use them
10:02:05 <hsd> Is haskell vast like C++ or is it fairly easy to pick up the syntax?
10:02:30 <saynte> shapr: I got lost about half way in, he had so much of his own types and functions built up that I got lost.
10:02:45 <shapr> hsd: I think it's small and simple, want to see a quick demo?
10:02:52 <hsd> Sure
10:03:08 * titanstar is waiting for qsort to appear
10:03:10 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellDemo
10:03:11 <titanstar> :)
10:04:15 <shapr> hsd: what do you think? easy to understand?
10:04:39 <shapr> hej Marvin-- 
10:05:04 <hsd> Yeah, seems pretty cool, too.
10:05:08 <Marvin--> whee, gmail
10:05:12 <titanstar> heh, no qsort
10:05:17 <titanstar> i'm amazed
10:05:41 <shapr> qsort isn't very representative, I think
10:05:53 <titanstar> no, it's not
10:05:59 <saynte> hsd: yep, it's very neat. but it was a very different way of thinking about things, to say the least :)
10:06:09 <desrt> bah
10:06:15 <desrt> my dog just hijacked my hands for a while
10:06:30 <shapr> saynte: oh, you probably got a bounce from my TMDA
10:06:34 <titanstar> it's more elegant because the canonical haskell version does a lot of space-wasting shortcuts compared to a typical imperative implementation
10:06:53 <saynte> shapr: TMDA?
10:07:05 <shapr> http://tmda.sourceforge.net/
10:07:36 <saynte> shapr: ohhh, gotcha
10:07:44 <saynte> shapr: well it hasn't come back yet
10:07:48 <shapr> if you have debian, sendfile is extraspiffy
10:07:55 <saynte> shapr: oh there itis
10:08:02 <shapr> then you can just 'sendfile shae@shapr.homelinux.net foo.hs'
10:08:16 <shapr> it's like DCC with extraspiffiness
10:08:21 <desrt> tmda seems like a good idea
10:08:28 <desrt> how do the special addresses work?
10:08:30 <hsd> Has Haskell been standarized?
10:08:42 <desrt> hsd; in 1998.
10:08:48 <shapr> hsd: yes, there's a Haskell 98 standard, which is the most recent in several versions
10:08:49 <shaleh> desrt: tmda only works if you have techie friends who do not mind helping you fight spam.
10:09:02 <shapr> desrt: send me an email, see how it works
10:09:03 <desrt> shaleh; huh?
10:09:15 <desrt> shapr; challenge/response.. right
10:09:19 <desrt> but i mean for the other addresses
10:09:21 <saynte> ohhh, got vlc working... me happy
10:09:22 <shaleh> desrt: it is confusing and partially annoying
10:09:34 <desrt> how you have an address that accepts mail only if "foo" is in the subject line?
10:09:49 <Marvin--> shapr: ohbtw, could you forward John's arrow code to me? I wanted to have a closer look at it
10:10:02 <shapr> Marvin--: yes, but I don't have the post-bug-fix code
10:10:09 <shapr> ski does though
10:10:10 <shapr> I think
10:10:13 <Marvin--> shapr: that makes it even more interesting, doesn't it? ;)
10:10:17 <shapr> heh, I guess so
10:10:34 <shapr> I'll forward it to you as soon as I figure out how to mix tmda and imap
10:10:59 <desrt> shapr; procmail is the ducttape equivilent for email :)
10:13:10 <saynte> shapr: did it come through?
10:13:26 <shapr> saynte: yes, thanks!
10:14:06 <saynte> shapr: comes with no warranty, cobbled together badly :) and mostly the work of the previous author
10:14:18 <shapr> previous author is most likely juhp 
10:14:21 <shapr> Jens Petersen
10:14:32 <Riastradh> How is the name 'Jens' pronounced?
10:14:49 <shapr> I think it's 'yens'
10:14:56 <shapr> I think juhp is from dk
10:15:43 <Taaus> Yeah, "yens" is a good approximation. 
10:16:00 <shapr> hiya Taaus
10:16:08 <Taaus> Hej shapr. :)
10:16:14 <shapr> vad händer?
10:16:24 <shapr> actually, I don't know any danks
10:16:26 <shapr> dansk
10:17:07 <Taaus> Hehe. I'll stick to English, then. My Swedish skills are pretty much one-way. (I.e. Swedish->Danish, and not the other way round)
10:17:49 <Taaus> As to what's up, I'm revising for an algebra/group theory exam tomorrow.
10:17:50 <Marvin--> don't worry, I've got Danish -> Swedish pretty well covered ;)
10:18:01 <shapr> mmm, group theory is nifty
10:18:04 <Taaus> Hehe :)
10:18:36 <Marvin--> "You are currently using 24 MB (2%) of your 1000 MB."
10:18:58 <Taaus> What's that? Gmail?
10:19:03 <Marvin--> yep
10:19:18 <Taaus> Ah.
10:19:47 <Marvin--> I've been uploading some mail so I can play with the labels and filters :)
10:20:18 <kosmikus|away> why is it that everyone seems to like gmail?
10:20:22 <Riastradh> I get _even_more_ space on my own mail server, and it, too, is totally for free.  It's also completely under my control, and hooked up with Akamai, just like Google...
10:20:36 <Riastradh> Oops, the 'my own mail server' gave it away.  Damn.
10:20:40 <shapr> *my* server has Haskell!
10:21:11 <Marvin--> *shrug* I don't have my own mail server
10:21:47 <Riastradh> Bah!  You're so totally unleet, Marvin--!
10:21:50 <Marvin--> yep
10:23:54 <Riastradh> (And I'm serious, by the way, about hooking it up with Akamai.  I bet none of you unleet dorks can beat _that_.)
10:25:06 <vegai> what's that?
10:25:34 <vegai> akamai.com?
10:25:42 <Riastradh> Akamai, uh...well...I can't think of a better way to describe it than 'speeds up the internet.'
10:25:55 <Marvin--> sounds like spam :P
10:26:28 <Riastradh> Web sites that are Akamaized are sped up by being cached all over the world; going to them just fetches the nearest cache.  There's also a DNS service.
10:26:35 <Marvin--> "Get 25% f@5t3r |nt3rn et FREE!!!11!!"
10:27:19 <Riastradh> The DNS services performs large-scale load balancing in DNS lookups...humph, Marvin--.
10:27:21 <vegai> apparently yahoo.com, msn.com, google.com and microsoft.com run through Akamai
10:27:21 <Marvin--> what does that have to do with e-mail?
10:27:25 <vegai> to mentain a few small enterprises
10:28:13 <Riastradh> I get _really_ good & fast DNS service.
10:28:23 <Riastradh> I also get lunch!
10:28:27 * Riastradh charges off to consume.
10:31:03 <Marvin--> tanstaafl
10:31:57 <vegai> oh dear: http://www.goatse.fi (it's not filthy)
10:32:24 <Marvin--> sure it isn't
10:32:25 <Marvin--> :)
10:32:41 <vegai> I wonder if they have a clue
10:33:18 <Marvin--> "I was wondering why we got the domain name so cheap" ;)
10:34:08 <vegai> that goat on the upper-right corner makes me wonder if that's a joke
10:35:16 <firefly> How slow is a ghc build with haddock, happy, alex for you guys?  my computer has been at it four close to four hours now :/
10:35:28 <shapr> GHC can take many hours to build
10:35:29 <Marvin--> vegai: well, seeing as I don't read Finnish...
10:35:44 <shapr> haddock is relatively speedy
10:35:53 <firefly> Great - and I have a K6-2 :(
10:36:00 <Igloo> What speed? And how much RAM?
10:36:13 <firefly> 500 MHz, 256 MB, slowish harddisks.
10:36:26 <shapr> yow
10:36:33 <Igloo> I'd estimate 6 hours
10:36:47 <shapr> it takes me a few hours on my dual Athlon MP 1.5GHz
10:36:52 <firefly> :(
10:36:58 <shapr> it's worth it though!
10:36:59 <Igloo> The dualness won't be used, though
10:37:05 <Igloo> What's the build doing now?
10:37:19 <firefly> why not?  can't you throw in a -j n somewhere?
10:37:31 <Igloo> The ghc build breaks if you do that I believe
10:37:45 <Igloo> And the rest are just noise
10:38:04 <firefly> Apparently running ar on libHSbase.a with a /huge/ number of .o files.
10:38:31 <Igloo> Oh, might take a bit longer than I thought then
10:39:11 <shapr> hsd: still there?
10:39:14 <Marvin--> shapr: come on with the arrow code already :)
10:40:02 <hsd> shapr: Yep
10:40:07 <shapr> Marvin--: right now I'm stuck with the command-line 'mail' program
10:40:13 <Marvin--> shapr: er
10:40:15 <shapr> hsd: any more questions about Haskell?
10:40:36 <hsd> Not yet, I'm still browsing amazon to find some books to pick up.
10:41:35 <Marvin--> shapr: why is that?
10:41:48 <shapr> is there some utility to pull all my /var/mail/shae into a Maildir setup?
10:41:49 <firefly> You shouldn't need to do that -- there's plenty of online stuff.
10:42:56 <shapr> Marvin--: I just got imap/ssl setup, so I have a huge /var/mail/shae that's been building up on the server since EuroHaskell
10:43:08 <Marvin--> yikes
10:43:25 <shapr> only 6mb atm
10:43:32 <Marvin--> oh, that's not so bad
10:43:40 <shapr> TMDA gets rid of the spam
10:44:01 <shapr> anyway, now I have to figure out how to go from /var/mail/shae into ~/Maildir
10:44:44 <shapr> aha, mb2md
10:45:14 <Marvin--> right
10:45:23 <ibid> TMDA is about throwing your garbage on the neighbour's lawn
10:45:39 <shapr> I say it's about saving the email system
10:45:51 <Igloo> What's the executive summary of TMDA?
10:45:58 <shapr> like I said before, it's either TMDA or I give up on push email entirely
10:46:17 <ibid> Igloo: it sends confirmation requests to unknown senders
10:46:24 <shapr> Igloo: mail comes from an unknown address, a confirmation is sent back to that address
10:46:28 <ibid> Igloo: hence, also to people who never sent the spam
10:47:04 <Igloo> Oh, ick
10:47:05 <ibid> shapr: well, it helps keep your lawn clean so why should you complain
10:47:53 <shapr> we could all switch to a pull system instead, then spam would be much less of a problem
10:48:16 <shapr> the cost of sending and storing an email is put onto the receiver right now
10:48:19 <ibid> how do you mean "pull"?
10:48:40 <shapr> if the cost of sending and storing were put onto the sender, the economics would change
10:48:46 <ibid> shapr: and so you send spam to innocent people
10:48:47 <firefly> or use a trust metric like thingy (per Raph Levien's phd work)
10:48:51 <shapr> ibid: http://shapr.homelinux.net/~shae/antispamserver.html
10:49:43 <shapr> greetings Si\, how's life?
10:50:26 <shapr> ibid: I say we write up that antispam server in Haskell. If that server is functional, I promise I will never use TMDA again :-)
10:50:33 <shapr> nor will I use any push email system
10:50:36 <ibid> :)
10:51:04 <shapr> anyway, I didn't come up with idea first, dj bernstein has a system called im2000 that's the same concept
10:51:07 <shapr> that being "switch to pull"
10:51:28 <ibid> i've heard of that
10:51:33 <shapr> what may also work is RSS notifications
10:51:58 <shapr> you receive a bunch of RSS notifies, then you load them into your RSS aggregator to see the actual emails.
10:52:01 <Igloo> shapr: Will that work without widespread adoption?
10:52:04 <shapr> if it's a spam, you blacklist that server
10:52:13 <shapr> Igloo: no, not without widespread adoption
10:52:14 <Igloo> (the thing in that URL)
10:52:53 <shapr> Heffalump made the point that the pull system I (or anyone) have proposed is difficult adopt transparently
10:52:59 <shapr> or maybe impossible
10:53:03 <Si\> sorry, I haven't responded for a bit shapr, I'm fine ty
10:53:11 <shapr> Si\: how's HAIFA?
10:53:18 <shapr> Si\: having a good summer?
10:53:25 <Si\> just started going again
10:53:53 <shapr> there's no good halfway point between SMTP/POP3 as we use them right now and a notify/fetch sender-storage system
10:54:06 <Si\> I'm hoping to write the Discovery Framework in the next few weeks, and hopefully I'll be able to publish my dissertation on the site
10:54:39 <shapr> I still think it's worth the jump. Mostly because the internet newbies are the ones who actually respond to spam, and this pull system lets us geeky people do more policing.
10:55:17 <shapr> Si\: spiffy, cooking your own meals
10:55:33 <ibid> i can see only one way such a system happens: the current system becomes so unusable that everybody stops using it. then there is a bit of chaos and eventually people converge on something
10:55:41 <Si\> the tricky part of writing the DF is that you have to be able to figure out which Haskell functions can be represented directly in other languages
10:55:48 <ibid> there is, of course, no telling whether the new system is any better
10:55:49 <shapr> I think that will happen, email is dying.
10:55:57 <shapr> ibid: so let's write it and start using it
10:56:03 <Si\> e.g. no higher-order, polymorphic or parametric types
10:56:04 <ibid> you can't write it
10:56:16 <ibid> you can only write a candidate for it
10:56:22 <shapr> anyway, I shall be unresponsive to TMDA complaints until there's a decent pull email system to use.
10:56:25 <ibid> there will be more than one
10:56:52 <ibid> i shall also be unresponsive to your emails as long as you use TMDA in a way that is obvious to me :)
10:56:55 <shapr> Si\: you could just represent the interfaces alone
10:56:58 <shapr> ibid: fair enough
10:57:00 <ibid> of course, it's not a big loss for you
10:57:26 <Si\> what you mean, represent the interfaces alone?
10:57:51 <ibid> shapr: i believe that email can still be saved, but there is a very clear risk that it fails
10:58:05 <ibid> much like the planet, i suppose :)
10:58:13 <shapr> for economic reasons, I do not believe an email push system can be saved.
10:58:35 <ibid> it can, if there is enough political will'
10:58:48 <ibid> its ubiquity makes it immensely valuable
10:58:49 <Marvin--> I, too, think email needs a gigantic overhaul
10:59:03 <shapr> ibid: ubiquity of a pull system would be much more valuable
10:59:12 <ibid> shapr: sure, but it's not there
10:59:18 <shapr> it is, sort of
10:59:23 <shapr> I think RSS is going ther.
10:59:24 <shapr> there
10:59:24 <ibid> shapr: ubiquity of the current system is, however
10:59:41 <ibid> RSS is a lot more like usenet than email
10:59:54 <shapr> but both usenet and email are push
10:59:58 <shapr> and so very spammy
11:00:12 <ibid> actually, usenet is flood :)
11:00:12 <shapr> it's much harder to spam an RSS feed
11:00:33 <ibid> and for some reason, spam prevention on usenet has been much more effective
11:00:45 <shapr> Si\: why do you need to directly represent a haskell function in another language? can you just have a proxy instead?
11:01:15 <Si\> you do, it's called WSDL
11:01:55 <Si\> but, WSDL can only represent basic first-order operations, so that the interface is language agnostic
11:03:29 <Si\> essentially what I have to do atm, is reject any functions not of the form "func1 :: Type1 -> Type2 ... TypeN -> (Output1, Output2, ... , OutputN)"
11:04:56 <Si\> any all the types must be first-order, record syntax types so that name data can be extracted.
11:06:17 <shapr> Marvin--: downloading 1386 messages
11:10:05 <Marvin--> well, I
11:10:13 <Marvin--> 'm off to watch the football game
11:23:10 <jemfinch> shapr: you in?
11:23:48 <shapr> yah, wassup?
11:26:15 <jemfinch> shapr: how do you make do in Haskell without "printf debugging"?
11:26:41 <shapr> unit testing?
11:27:03 <jemfinch> what do you use for unit testing?
11:27:12 <shapr> hei Esa
11:27:16 <shapr> how's life?
11:27:43 <esap> Fine, been coding a lot.
11:28:01 <firefly> quickcheck?
11:28:19 * jemfinch liked the idea of quickcheck.
11:28:21 <shapr> yah, quickcheck r0xx0rs
11:28:35 <shapr> it's hard to do test-driven-development with QC though
11:28:39 <shapr> at least, at the moment
11:28:42 <jemfinch> shapr: QC?
11:28:44 <jemfinch> oh, quickcheck.
11:29:05 <jemfinch> shapr: what do you use for unit testing?
11:29:17 <shapr> HUnit and Quickcheck
11:29:27 <shapr> and haskell-mode
11:29:48 <shapr> www.haskell.org/hawiki/HaskellMode
11:29:59 * esap hasn't much felt the need for unit testing; the type system already fixes 99% of all the problems...
11:30:09 <shapr> it doesn't fix my brain
11:31:11 <jemfinch> shapr: Parsec seemed...odd.
11:31:24 <shapr> I like Parsec, it's very concatenative
11:31:39 <jemfinch> explain :)
11:31:46 <mattam_> concatenative ? is that a neologism shapr ?
11:31:56 <shapr> I wrote some regex-style functions for Parsec, stuff like fromMtoN
11:32:00 <shapr> no, neologism is over there
11:32:04 <Lor> You can do printf debugging in Haskell, just use Hood.
11:32:17 <shapr> I haven't tried buddha yet
11:32:56 <jemfinch> Lor: what's Hood?
11:33:01 <jemfinch> shapr: What's Buddha?
11:33:19 <jemfinch> shapr: I wouldn't mind seeing some Parsec code, if you have any public examples.
11:33:34 <shapr> jemfinch: if you're an emacs user, you may be interested in the one-button-unit-test elisp code on HaskellMode there
11:33:57 <Lor> jemfinch, haskell.org/hood
11:34:38 <shapr> buddha: http://www.cs.mu.oz.au/~bjpop/buddha/
11:34:53 <shapr> speaking of which, I need to hook up bernie and haskell-experimental
11:36:33 <shapr> jemfinch: http://shapr.homelinux.net/~shae/RFC2822.hs
11:37:37 <shapr> imho, it more concatenative to do "manyN 5 (char 'a')" to mean "at least 5 of char a"
11:38:07 <Lor> Frankly, I think that the UU_Parsing combinator interface suits parsers far better than monads.
11:38:48 <shapr> show us!
11:38:57 <jemfinch> shapr: nice, thanks.  I'll take a look at it.
11:39:18 <jemfinch> shapr: I'd probably just call it "at-least" (at-least 5 (char #\a))
11:39:50 <shapr> there's manyN and manyNtoM
11:40:16 <jemfinch> at-least and between :)
11:40:37 <shapr> ok, if you like it :-)
11:40:52 <shapr> at_least = manyN ; between = manyNtoM
13:06:17 <jemfinch> what's with the freaky Haskell formatting of lists with the commas on the line following the actual item?
13:08:01 <stepcut> jemfinch: makes it easier to comment out lines...
13:08:21 <stepcut> jemfinch: specificially, the last line, because you don't have a trailing comma on the previous line
13:08:46 <stepcut> of course, then, the first line is problematic...
13:08:54 <stepcut> :p
13:14:58 <Riastradh> If you just used S-expressions, you wouldn't have the problem with _either_ of them, and you'd have no ugliness in comma placement...
13:15:06 <firefly> I prefer the Perl way of allowing an extra comma at the end ;)
13:15:46 * SyntaxNinja seems to think that import lists allow an extra comma
13:15:50 <SyntaxNinja> or export lists maybe
13:19:53 <stepcut> maybe the freaky haskell formatting just looks cool :)
13:29:18 <shapr> SyntaxNinja: lists should all allow an extra comma!
13:37:01 * SyntaxNinja hands shapr and ralf a few commas
13:43:42 <SyntaxNinja> is The Fun of Programming a book that can be acquired in the US?
13:43:42 <SyntaxNinja> (Or is it illegal or something ;) )
13:46:20 <Igloo> I imagine all th ephysical copies are in the UK, but I'm sure they are importable
13:47:49 <SyntaxNinja> any idea of this book is meant to be published some day? I'm confused by the info I find on the web
13:48:01 * Igloo is just looking
13:48:11 <Igloo> There is a physical book if that's what you mean
13:48:18 <Igloo> http://www.palgrave.com/products/catalogue.aspx?is=0333992857
13:48:53 <Igloo> Ah, and there's a link for USA peeps on the order page
13:48:55 <andersca> firefly: YAY, 2-2
13:48:56 <andersca> :)
13:49:47 <firefly> Yeah, there was a mistake in the 89th minute, wasn't there?
13:50:18 <firefly> Fedt at /Italien/ ikke kommer med! :)))
13:50:54 <andersca> firefly: I like that sweden just held the ball for ~1 minute :)
13:51:36 <SyntaxNinja> Igloo: hm. that link doesn't actually seem to have the book listed anywhere.
13:51:58 <SyntaxNinja> is there a non-physical book out there?
13:52:17 <firefly> ghc is still building, btw :/
13:52:42 <Igloo> You could try e-mailing them
13:52:57 <Igloo> Individual chapters may be available from the authors' webpages
13:53:32 <SyntaxNinja> yeah. I found one chapter that I liked so iwanted to check out more of the book. I was wondering if it was only sorta informally published and so the authors might not mind if it went on the haskell book-selling page
13:53:56 <Igloo> firefly: You're lucky, crest has been going for 5 hours and hasn't finished configure yet  :-)
13:54:22 <SyntaxNinja> btw, does anyone know why newtype ListMap i o = ListMap ([i] -> [o]) shouldn't be an arrow?  
13:54:35 <firefly> crest is?
13:54:36 <Igloo> I suspect the publishers have the rights for at least a period of time. Although given some chapters are on the web I could be wrong
13:54:52 <Igloo> crest is an m68k
13:54:58 * SyntaxNinja was able to write the class instance in a way that seems to make sense... but I assume that they violate some law
13:55:01 <firefly> "5 hours - isn't that a bit over the top?" ;)
13:55:04 * SyntaxNinja guesses one of the "first" laws
13:55:17 <Igloo> I'm sure they'll do their best to selllyou a copy if you e-mail them, anyway  :-)
13:55:33 <Igloo> m68k isn't the fastest arch in the world
13:55:51 <SyntaxNinja> Igloo: i'm sure they still have rights.  i'm wondering if you're suggesting I email the authors or the USA branch of the publisher. if nothing else, I'll get my brother to pick me up one while he's over there.
13:56:09 <Igloo> I meant the publisher
13:56:09 <firefly> It is actually not slow either.  It is scandalous that configure scripts are so slow.
13:56:11 <SyntaxNinja> mark had asked me to pick one up, but I was too over-loaded with stuff
14:01:57 * SyntaxNinja goes home
14:25:12 <cm> ho
14:44:01 * SamB wonders if he really wants a lexer
14:44:31 <Igloo> If you're not sure you'll probably find you did if you don't write one
14:46:01 <SamB> very well...
14:46:24 <SamB> even if lexing numeric literals seems almost like parsing...
14:47:03 <Igloo> lexing /is/ parsing, just with a less interesting output datatype
14:47:25 <SamB> do I want to use alex?
14:52:52 <SamB> hmm. how am I going to handle those pesky suffixes...
14:55:57 <SamB> is there a really nice set of lexing combinators somewhere?
14:57:46 <jemfinch> SamB: Parsec?
15:01:43 <SamB> jemfinch: well, then I wouldn't say I had a lexer.
15:02:58 <jemfinch> Then I would have to agree with Igloo.
15:03:04 <SamB> jemfinch: that was basicly what I was thinking of doing rather than having a lexer...
15:04:16 <Igloo> I use alex+happy for my lexing/parsing these days
15:13:10 <SamB> hmm. I think I'll do this in Parsec first...
15:18:15 <SamB> it will be easier to do it by C99 that way. too bad they don't give datatypes for the parse tree...
15:29:06 <shapr> wheee
15:32:22 <stepcut> wheeeee!
15:32:39 <stepcut> brriiiiiiinnggggeeeerrrrrttttt
15:33:39 <firefly> still building...
15:34:45 <stepcut> firefly: ghc?
15:34:51 <firefly> yes.
15:34:55 <stepcut> :)
15:35:14 <bringert> hi stepcut
15:35:24 <stepcut> well, it is (in all likelyhood) the largest haskell program ever written...
15:35:34 <stepcut> bringert: done with school yet ?
15:35:38 <bringert> how many LOC is ghc?
15:35:41 <bringert> yeah
15:35:55 <bringert> well, still have a thesis to do
15:35:57 <Igloo> firefly: How long's it been now?
15:36:01 <bringert> two actually
15:36:18 <firefly> almost nine hours.
15:36:30 * bringert gets paid to write haskell code!
15:36:48 * stepcut gets paid to write haskell code! (but sometimes has to write o'caml code :-/ )
15:36:54 <Igloo> Hmm. Presumably it's building stage2 stuff by now though?
15:37:04 <bringert> at least sometimes
15:38:42 <bringert> stepcut: is that haskell for your internal tools?
15:38:52 <stepcut> bringert: yeah
15:38:56 <firefly> yes.
15:40:12 <bringert> are you using haskelldb for any of that?
15:40:25 <stepcut> bringert: of course !
15:40:39 <stepcut> I use haskelldb for everything :)
15:40:41 <bringert> I think we wrote that in our project report so I was hoping it was true :)
15:40:50 <stepcut> :p
15:40:59 <firefly> ghc-6.2.1/libraries take up 264172K.  ghc-6.2.1/hslibs take up 63496K.  ghc-6.2.1/ghc 97632K.
15:41:05 <firefly> I think that's a bit extreme...
15:41:33 <firefly> (the /ghc directory is still growing)
15:42:20 <Igloo> It takes 800M-1.2G to build according to the Debian buildd logs I think, depending a bit on architecture
15:43:07 <bringert> how much work is creating a simple debian package?
15:43:14 <firefly> I'm only at 428544K at the moment - but I'm not building any opengl stuff.
15:43:22 <Igloo> Oh, that probably includes build=dependencies too though
15:43:22 <firefly> bringert: a simple one really is quite simple.
15:43:36 <bringert> we have configure, make, make install and an rpm already
15:44:14 <bringert> do debian packages work similar to rpms?
15:44:15 <firefly> The debian packaging basically consists of a debian/ directory with a very special makefile in it called "rules".
15:44:31 <stepcut> bringert: the only tricky part is updating the package list after the install (you need a postinst script)
15:45:27 <bringert> ok, thanks. any pointers to good tutorials on building debs?
15:45:57 <firefly> There is the complete spec and an easy introduction on the debian site.
15:46:18 <Igloo> I tend to start with /usr/share/doc/debhelper/examples/rules and the other files from another random package
15:46:21 <firefly> Unfortunately, there are (were?) also several different, conflicting older documents on the subject.
15:46:29 * stepcut agrees with Igloo
15:46:31 <Igloo> But you probably want a tutorial of some sort in addition to that
15:46:33 <firefly> I hope they got removed now :/
15:46:48 <stepcut> lintian is a good tool too
15:47:07 <stepcut> though it's very picky
15:47:16 <stepcut> you can ignore some errors
15:47:21 <Igloo> What happened with linda?
15:47:33 <stepcut> dunno, its still around...
15:48:05 <bringert> hmm, I guess I need a debian system to play with
15:53:44 <stepcut> bringert: there is a new linspire alpha coming out in a day or two. Its based on sid, so it will be easy to install, but you can just apt-get from sid
15:54:17 <bringert> maybe there is a spare machine somewhere at work that I can use
15:55:22 <Igloo> linspire?
15:55:42 <Igloo> bringert: You could just use a chroot on a random Linux box
15:56:07 <Igloo> But having a real Debian machine might ease the transition when you see the light  :-)
15:56:13 <bringert> :)
15:58:05 * bringert tried installing debian once
15:58:20 <bringert> guess I should have asked someone how to do it first
15:58:33 <firefly> The beauty is that only have to install it once :)
15:58:57 <firefly> bringert:  I think you should take a look at pbuilder.
15:59:01 <firefly> http://www.netfort.gr.jp/~dancer/software/pbuilder-doc/pbuilder-doc.html
15:59:13 <bringert> I managed to use debian stable, which apparantely uses really old stuff
15:59:25 <firefly> It looks like a better package builder for debian than the standard package builder.
15:59:36 <bringert> which is the debian you actually want?
15:59:43 <firefly> bringert: you could have edited /etc/apt/sources.list and used apt-get dist-upgrade.
15:59:49 <firefly> You want unstable.
16:00:10 <bringert> I should give it another shot when I have time
16:00:15 <firefly> But you can install stable first and then edit sources.list and do a dist-upgrade.
16:00:23 <bringert> last time was 1.5 years ago
16:00:38 <firefly> There is a newer, much improved installer in unstable (aka sid) but I haven't tried it.
16:00:47 <firefly> Really, *much* improved.
16:01:23 <firefly> The nice thing about pbuilder is that you can easily build packages for several different debian (and debian-like) systems on one machine.
16:01:43 <firefly> It is also very good at making sure you get the dependencies right because it does everything in a chroot jail.
16:01:57 <Igloo> There were a few tricks to using the old installer, e.g., don't use dselect to choose packages when it prompts you. Just do it later
16:02:01 <Igloo> I haven't used the new one
16:02:34 <bringert> guess I should hang around on irc for handholding when I get around to it
16:02:40 * Igloo debates trying to fix ghc6 on ia64 properly vs just hacking it
16:02:43 <firefly> If you want something similar for RPMs, it would be Thomas vander Sticheles mach, which lets you create packages for lots of different Red Hats (+ Fedora) and Mandrakes on a single machine - which doesn't even have to be a red hat machine :)
16:05:00 * Hyp3rion have installed his debian sid system 3 days ago with the jun18 daily d-i
16:05:15 <stepcut> bringert: I can review the package or answer any specific questions you may have
16:05:27 <firefly> Done! :)
16:05:34 <bringert> stepcut: thanks
16:05:35 <firefly> Slightly more than nine hours, then.
16:06:05 <bringert> dunno if I'll have time to do a debian package, but it would be nice to have one
16:06:34 <bringert> it's for GF, the program that shapr is currently on about :)
16:06:54 <stepcut> bringert: well, I might end up making one if you don't. I have been waiting around for the LIP stuff (or whatever that project is called) to be formalized, since that will ultimately affect packaging
16:07:29 <bringert> are you using GF?
16:13:47 * bringert realizes that he has been talking about both GF and haskelldb
16:14:30 <stepcut> :p
16:14:48 <bringert> anyway, haskelldb really should use cabal
16:15:47 <bringert> I can see a few problems with using Distribution.Simple, since I don't think there is a way to decide which modules to install based on the alreay installed modules
16:16:19 <stepcut> what is cabal, anyway. I keep hearing about it
16:17:03 <Hyp3rion> http://haskell.org/libraryInfrastructure
16:17:31 <stepcut> thanks
16:18:29 <bringert> cabal is LIP
16:18:43 <bringert> we should get haskelldb into a public repo
16:18:59 <stepcut> cool
16:19:25 <bringert> it's just that noone has sobered up yet
16:19:40 <stepcut> haha
16:19:43 <bringert> the semester ended less than a month ago
16:20:00 * bringert is getting tired of CVS
16:20:23 <bringert> it'd be nice to hav a darcs repo on cvs.haskell.org like Cabal has
16:20:42 <stepcut> yeah
16:21:03 <stepcut> I have a spotty arch mirror of the haskelldb releases 
16:21:20 <bringert> is there a way to import CVS version history into darcs?
16:21:31 <bringert> guess I should really ask in #darcs
16:21:32 <stepcut> no clue, I have only used arch/tla
16:22:04 <bringert> sounds like it wouldn't be to hard to write a script to do it if there isn't
16:22:21 <stepcut> actually, parsing cvs history is a major pain in the ass
16:22:23 <firefly> And somebody already has.  There should be a link somewhere on the darcs wiki.
16:22:38 <stepcut> the only way to do it is to run cvs rlog and parse the output, asaik
16:22:54 <bringert> http://www.abridgegame.org/pipermail/darcs-users/2004/000988.html
16:22:55 <bringert> maybe
16:23:26 <bringert> ah, http://www.scannedinavian.org/DarcsWiki/ConvertingFromCvs
16:25:46 <bringert> anyway, off to bed
16:25:46 <bringert> good night
16:25:46 <stepcut> night
16:40:54 <SamB> hmm, actually, it looks like I will have a lexer if I continue to follow the shape of C99 with my parser...
16:47:23 <det> you are parsing C99?
16:48:22 <SamB> det: yeah. I'm getting carried away with the parser for a toy C compiler I want to make.
16:49:41 <firefly> Is there a haskell debugger for non-aspergers, i.e. not something that in any way whatsoever resembles gdb?
16:50:05 <Riastradh> All I know of is Buddha.
16:50:09 <SamB> firefly: I'm just about positive there isn't one that looks the slightest bit like gdb.
16:50:14 <Igloo> There's also hat
16:50:34 <firefly> Something that will work sensibly with a 15000 line Haskell program?
16:50:38 <Igloo> Neither support as much of the language as I'd like, though  :-(
16:51:12 <firefly> I am not interested in seeing how a single evaluation of a simple expression takes place -- as far as I know hat doesn't do much than show the reductions step by step.
16:51:40 <Igloo> I've never really used it because of the above problem
16:52:22 <firefly> SamB: Are you sure?  I am looking for something that is as easy to start using as Borland's Turbo Debugger was.  Not something that pretends it is interesting enough to warrant an ugly learning curve and boot camp training courses.
16:52:43 <firefly> Igloo: so I am probably out of luck in any case?
16:53:09 <SamB> firefly: haskell debuggers can't be like C debuggers, anyhow
16:53:13 <firefly> I need support for foreign functions (in C), for example.  Oh, and I/O.
16:53:16 <firefly> SamB: of course not.
16:53:18 <SamB> or Pascal or what have you.
16:53:24 <firefly> I don't expect that either.
16:53:39 <SamB> making comparisons between them is probably not terribly usefull, either.
16:53:51 <firefly> All I am looking for is something that is not in the least inspired by the mindset that gave us monstrosities as auto* and gdb.
16:54:23 <firefly> SamB: why not?  I am talking about usability issues and complexity.  Shouldn't be hard to compare.
16:54:27 <SamB> hmm. I think gdb is easier to sue then auto*.
16:54:38 <SamB> use, rather.
16:54:50 <SamB> suing auto* would be fun
16:55:11 <firefly> Only if you are lucky enough to be able to stick to a handful of commands from a cheat sheet :(
16:55:28 <firefly> Even so, it has the problem that it doesn't display anything interesting unless you ask it to.
16:56:24 <firefly> I was hoping for a Haskell debugger that wasn't quite so, how shall I put it, written in state of the art sixties-style.
16:56:30 <SamB> I'd be willing to try any alternative debuggers that might be out there ;-)
16:56:56 <firefly> Are you also willing to help me write a debug symbol parser?
16:57:12 <SamB> but, anyway, haskell debuggers are hard to make.
16:57:19 <firefly> I know :)
16:57:55 * SyntaxLaptop complains about haskell debuggers
16:58:02 <SamB> because there is no obvious way for them to work ;-)
16:58:06 <firefly> Google for tdbr if you want to play with an assembly debugger.
16:58:32 <SyntaxLaptop> I actually wanted to go to grad school and write a haskell debugger
16:58:58 <SyntaxLaptop> I've become obsessed with testing since debugging Haskell is so frustrating
17:00:25 <Igloo> Why do you think going to grad school would help? Give you more free time or actually pay you to write it?
17:00:51 <Igloo> I don't think the latter is true, you see, or I expect hat would have got funding to do so
17:01:16 <firefly> Can ghc tell me what the result of its strictness analysis was, i.e. which functions/expressions are strict?
17:01:34 <Igloo> The problem with the academic world is you can get money to write a new sort of whatsit, but not to finish off the whatsit you've just written to support the whole language rather than a representitive fraction
17:01:40 <stepcut> firefly: i think there is a thread about that on the ghc users mailing list right now...
17:01:50 <firefly> stepcut: thanks!
17:01:56 <Igloo> Yes, if you -ddump-simpl and use your brain a bit
17:02:04 <SyntaxLaptop> Igloo: I know. at the time, I was intersted in the research. I suppose now-a-days I'd be more interested in the tool devel.
17:02:25 <firefly> Joy.  I had hoped for a simple .lst file or something.
17:02:41 <Igloo> Oh, research is interesting, it's the half-finished non-maintained tools that result that are frustrating
17:03:21 <SamB> Igloo: hmm. they should have to demonstrate that their techniques were maintainable!
17:03:34 <SyntaxLaptop> Igloo: I know :(
17:03:48 <SamB> well, rather, should be paid to do so.
17:04:07 <SyntaxLaptop> SamB: I don't think that has anything to do with it
17:04:15 <SamB> SyntaxLaptop: oh?
17:04:20 <SyntaxLaptop> SamB: even if they were maintainable, that doesn't mean they'd get paid to maintain them.
17:04:58 <SyntaxLaptop> that developing a solid tool is important to research apparently takes MS to figure out.
17:05:43 <Igloo> Oh, this discussion has reminded me I was going to ask about hat (and normal profiling) support in cabal. OTOH I should probably wait until you've released something usable rather than distracting you  :-)
17:05:47 <SamB> SyntaxLaptop: well, not really. but they are the ones who figured it out *and* have money.
17:06:32 <SyntaxLaptop> SamB: point.
17:07:12 <SyntaxLaptop> Igloo: yeahyeah... if I could get someone else to worry about crap like writing the clean rule and the parser, then I could worry about porting the preprocessor stuff I did w/ the hmake code
17:07:14 <SamB> probably, hardware rots less than software.
17:08:11 * Igloo didn't mean to sound like I was complaining that you were slacking or anything - sorry if I did...
17:08:25 <SyntaxLaptop> Igloo: not at all. I'm the one complaining :) but not at you, or anyone in particular.
17:09:51 <firefly> stepcut: that didn't leave me much wiser.
17:10:17 <firefly> But anyway, at least the strict parts should be easy to handle within a traditional debugger paradigm ;)
17:15:32 <stepcut> firefly: ah, I didn't actually read the thread...
17:15:57 <firefly> Funny, -fignore-asserts and -fno-ignore-asserts are listed twice in the man page under the "Language options" heading.
17:36:37 <firefly> sequence_ ?
17:37:48 <stepcut> ??
17:38:15 <firefly> What does it do?  It seems like it isn't something darcs defines.
17:38:45 <stepcut> ah
17:38:53 <stepcut> @type sequence_
17:38:55 <lambdabot> sequence_ :: forall m a. (Monad m) => [m a] -> m ()
17:39:17 <firefly> Nifty!
17:39:25 <firefly> @sequence
17:39:25 <lambdabot> Sorry, I don't know the command "sequence", try "lambdabot: @listcommands
17:39:29 <firefly> @type sequence
17:39:31 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
17:39:49 <stepcut> its useful if you did something like: map putStrLn ["a" , "b" , "c"]
17:39:58 <firefly> yes, I see.
17:40:04 <firefly> In this case it is:
17:40:24 <firefly> sequence_ $ map (\pn -> do putVorDot $ "Copying "++pn++"\n"
17:40:25 <stepcut> that will have the type [IO ()], sequence_ $ map putStrLn ["a","b","c"]  will have the return type IO ()
17:40:33 <firefly>                 copyFileOrUrl
17:40:47 <Cale> there's also mapM
17:40:48 <firefly>                   (realdir++"/_darcs/patches/"++pn)
17:41:09 <firefly>                  (out++"/_darcs/patches/"++pn)) pns
17:41:42 <stepcut> yeah, mapM = sequence $ map and mapM_ = sequence_ $ map 
17:41:44 <stepcut> i think...
17:41:48 <Cale> yeah
17:41:56 <firefly> @type mapM_
17:41:58 <stratocaster> I think you are right.
17:41:58 <lambdabot> mapM_ :: forall m a b. (Monad m) => (a -> m b) -> [a] -> m ()
17:42:04 <firefly> @type mapM
17:42:06 <Cale> well, sequence . map and sequence_ . map :)
17:42:06 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
17:42:20 <stepcut> cale: yaeh, that's what I meant :)
17:42:37 <firefly> Hah!  I am not alone ;)
17:42:56 <Cale> alone?
17:43:28 <firefly> @type app
17:43:30 <lambdabot> bzzt
17:43:42 <firefly> @type map_
17:43:44 <lambdabot> bzzt
17:43:50 <Cale> type Monad.app
17:43:53 <firefly> @type apply
17:43:54 <Cale> @type Monad.app
17:43:55 <lambdabot> bzzt
17:43:57 <lambdabot> bzzt
17:43:59 <Cale> heh
17:44:15 <Cale> @type Monad.ap
17:44:17 <lambdabot> Monad.ap :: forall b m a. (Monad m) => m (a -> b) -> m a -> m b
17:44:27 <firefly> @type ap
17:44:29 <lambdabot> bzzt
17:44:32 <saynte> Hey Cale, how's it going? (it's scott from the sometimes lab ;))
17:44:40 <Cale> hey
17:44:43 <Cale> pretty good
17:44:49 <saynte> good to hear, good to hear
17:45:11 <saynte> I think ryan was sick today
17:46:11 <Cale> We need to get the scheduler running within a couple of days -- it's currently in the middle of a complete rewrite. Chris and I hacked on it all day, and ended up with a few hundred lines of good code. It's turning out quite a bit nicer than it was.
17:46:31 <saynte> Oh well that's good. I think your work is leagues above me, I'm a simpleton :)
17:46:45 <Cale> And yeah, Ryan has a cold.
17:46:47 <saynte> You have a demo-deadline soon don't you?
17:46:50 <Cale> yeah
17:46:53 <firefly> Thank you for the help with sequence_ :)
17:46:54 <Cale> Friday
17:46:55 <saynte> 28th?
17:47:04 <Cale> yeah, about that
17:47:05 <Cale> :)
17:47:06 <saynte> Confident that you'll make it?
17:47:16 <firefly> Can anybody tell me what unsafeInterleaveIO is for?
17:47:18 <saynte> I ballpark it to the nearest month.
17:47:30 <Cale> well, if things keep going this well, the scheduler rewrite will happen in time, so we'll at least have that
17:47:38 <Cale> firefly: it's for breaking things
17:47:43 <Cale> heh
17:48:00 <Cale> @type unsafeInterleaveIO
17:48:01 <saynte> Oh wow, I shoudl use it then. I'm always looking for new and innovating ways to break things.
17:48:02 <lambdabot> bzzt
17:48:23 <firefly> @listcommands
17:48:23 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
17:48:23 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
17:48:23 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
17:48:23 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
17:48:23 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
17:48:24 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
17:48:25 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
17:48:27 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
17:48:29 <firefly> @hitchcock
17:48:30 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
17:48:55 <Cale> @type System.IO.Unsafe.unsafeInterleaveIO
17:48:57 <firefly> @hitchcock
17:48:57 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: forall a. IO a -> IO a
17:49:08 <firefly> @easton
17:49:16 <Cale> unsafeInterleaveIO :: IO a -> IO a
17:49:16 <Cale> unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see hGetContents.
17:49:28 <Cale> @type System.IO.Unsafe.unsafePerformIO
17:49:30 <lambdabot> System.IO.Unsafe.unsafePerformIO :: forall a. IO a -> a
17:49:52 <Cale> hGetContents is also quite evil :)
17:50:05 <saynte> Evil by association? :)
17:50:23 <Cale> no, it's really pretty unsafe
17:50:53 <Cale> If your program consumes the file slowly, and it changes on you, strange things can happen.
17:50:53 <saynte> What sort of unsafe things may happen?
17:50:58 <saynte> ohhhh
17:51:11 <Cale> It doesn't read the file until you use the string, and it's read lazily.
17:51:25 <saynte> Wow, that's almost tempting me to use it ;)
17:51:29 <Cale> @type hGetContents
17:51:31 <firefly> Ok, so it is lazy I/O he is after in read_patches_remote and read_repo_private.
17:51:31 <lambdabot> bzzt
17:51:39 <Cale> @type IO.hGetContents
17:51:41 <lambdabot> IO.hGetContents :: GHC.IOBase.Handle -> IO String
17:52:10 <firefly> liftM ?
17:52:16 <Cale> It's at least in the IO monad, but I tend not to use it. It's generally saner to just read the whole file in.
17:52:23 <Cale> @type Monad.liftM
17:52:25 <lambdabot> Monad.liftM :: forall r m a1. (Monad m) => (a1 -> r) -> m a1 -> m r
17:52:31 <firefly> ewww.
17:52:44 <Cale> (a -> b) -> (m a -> m b)
17:52:50 <firefly> What does => mean in this context?
17:52:58 <Cale> It means implies
17:52:59 <Riastradh> Typeclass constraint.
17:53:07 <firefly> Ah.
17:54:24 <firefly> Right, given a function from a to b and monad that wraps a, stuff b into the monad instead.
17:54:38 <saynte> I spent the past couple days restructuring my stupid program, lol. At least it's easier to add functions now
17:55:05 <firefly> I think functions like this are a little too magic for comfort:
17:55:13 <firefly> read_patches_local :: FilePath -> [PatchInfo] -> IO PatchSequence
17:55:14 <firefly> read_patches_local _ [] = return []
17:55:14 <firefly> read_patches_local dir (i:is) = do
17:55:14 <firefly>   mp <- unsafeInterleaveIO $
17:55:14 <firefly>         do s <- gzReadFilePS $ dir++"/_darcs/patches/"++make_filename i
17:55:14 <firefly>            return $ fst `liftM` (readPatchPS s)
17:55:16 <firefly>          `catch` \_ -> return Nothing
17:55:18 <firefly>   rest <- read_patches_local dir is
17:55:22 <firefly>   return $ (i,mp) : rest
17:55:24 <firefly> :(
17:56:50 <stratocaster> Which part of that is giving you trouble?
17:57:19 <Cale> liftM is just map
17:57:35 <Riastradh> So why does it exist?
17:57:42 <Cale> well, fmap
17:57:49 <firefly> I could probably handle any given individual piece of magic, but unsafeInterleaveIO, $'s, liftM, etc... it is a bit much.
17:57:57 <firefly> @type fmap
17:57:59 <lambdabot> fmap :: forall f b a. (Functor f) => (a -> b) -> f a -> f b
17:57:59 <Cale> because things have been designed strangely in that regard
17:58:21 <Igloo> Because you might not want to have to give a separate Functor instance
17:58:24 <Cale> every instance of Monad should automatically be an instance of Functor with fmap = liftM
17:58:25 <firefly> And I guess a Haskell functor has pretty much nothing to do with an ML functor?
17:58:38 <Pseudonym> It has more to do with a categorical functor.
17:58:41 <Cale> Haskell functors are just like mathematical functors.
17:58:44 <Igloo> And Monad m => Functor m would give you overlapping instances
17:59:25 <firefly> great - it's been two years since I read the beginning of Category Theory for Computer Scientists :/
17:59:48 <Pseudonym> A functor in ML is basically a typeclass in Haskell.
17:59:48 <Cale> Igloo: so there's no easy way to solve the problem? I think that Monad m => Functor m should be made to work.
17:59:55 <Pseudonym> More or less.
18:00:07 <Pseudonym> firefly: If it helps, there's a Haskell category.
18:00:25 <firefly> I am afraid it doesn't ;)
18:00:26 <Pseudonym> The objects are types, and the arrows are Haskell functions.
18:00:34 <firefly> ok.-
18:00:34 <Pseudonym> Ah, OK. :-)
18:00:36 <firefly> ok.
18:00:41 <Cale> Also, I can't understand why fmap isn't called map.
18:00:57 <Pseudonym> The "Functor" typeclass represents an endofunctor from the Haskell category to the Haskell category.
18:01:02 <Cale> We should use the general one by default :)
18:01:15 <Pseudonym> Cale: The reason is that this is Haskell 98, not Haskell 1.4.
18:01:24 <Pseudonym> Haskell 98 was a deliberate simplification.
18:01:33 <Cale> Hopefully they put things back for Haskell 2
18:01:35 <firefly> Maybe I'll skip on the functors until I have reread that Category Theory thing.
18:01:44 <Cale> firefly: it's actually pretty simple
18:01:58 <Pseudonym> And one of the simplifications made was that functions which undergraduates want to apply to lists only work on lists.
18:02:00 <firefly> You don't expect ordinary programmers to be able to understand this, do you?
18:02:08 <Pseudonym> More general versions were made for functors and monads.
18:02:09 <Cale> You can think of a functor as a container type with a form of map defined on it
18:02:15 <Pseudonym> It simplifies the type errors.
18:02:33 <Pseudonym> firefly: No, I don't.  The reason I brought it up is that you did say you'd read the start of that book.
18:02:39 <firefly> Cale: that sounds like a good explanation :)
18:02:39 <Pseudonym> :-)
18:03:02 <firefly> Pseudonym: two years ago.  And my memory was very bad back then.
18:03:11 <Pseudonym> Yes, a functor is a generalisation of a wrapper and a container.
18:03:24 <Pseudonym> You can think of type "wrappers", say wrapping a type with an annotation.
18:03:29 <Pseudonym> Or some extra information.
18:03:33 <firefly> yes.
18:03:43 <Pseudonym> And a container, which contains potentially more than one value.
18:03:50 <Pseudonym> Well, "map" makes sense on both of those.
18:04:10 <firefly> right, yes.
18:04:30 <Pseudonym> So that's what a functor is. :-)
18:04:32 <firefly> Except that in my world view one of them is purely compile-time magic in the type system and the other one is actual code.
18:04:46 <Pseudonym> Ah, well.
18:04:48 <firefly> But I guess that's just a small matter of mental stretching.
18:04:50 <Cale> not necessarily
18:05:05 <Pseudonym> See, in real generic programming there's a lot of code which gets compiled down to no-ops.
18:05:11 <firefly> sure
18:05:20 <Pseudonym> This is no exception.
18:05:37 <firefly> hmmm....
18:05:38 <Cale> You could have a type like data MyType a = MyData Int [a]
18:05:59 <Cale> and make this an instance of functor
18:06:05 <Pseudonym> Right.
18:06:26 <Pseudonym> You could also make a stack, or a queue, a functor.
18:06:30 <Cale> The Int is the annotation bit, and the list is the container bit
18:06:58 <Cale> Maybe is a functor
18:07:08 <Pseudonym> date NamedThing a = NamedThing String a
18:07:10 <firefly> Yes.  I'll need to revisit this in a few days, but it certainly seems possible to internalize it.
18:07:29 <Pseudonym> Maybe is a good example of a wrapper.
18:07:41 <Cale> data Maybe a = Nothing | Just a
18:08:29 <firefly> Well, isn't it just the equivalent of option in ML?  No magic there: it has two constructors, SOME and NONE (Just, Nothing).
18:08:31 <Cale> So a value of type Maybe a is either the value "Nothing", or a value of the form "Just x" where x is of type a.
18:08:43 <Cale> yeah
18:08:46 <firefly> Yes, no magic there.
18:08:55 <Cale> and so we have:
18:09:08 <Cale> fmap f Nothing = Nothing
18:09:18 <Cale> fmap f (Just x) = Just (f x)
18:09:27 <Cale> pretty simple
18:09:30 <firefly> (except for the type variable, but the disenchantment of type variables happened 6 years ago)
18:10:06 <firefly> Right.
18:10:07 <Cale> that definition of fmap makes Maybe an instance of Functor
18:10:12 <Cale> that's all there is to it
18:10:37 <firefly> And you could do the same with list, nil, and cons?
18:10:42 <Cale> yeah
18:11:22 <Pseudonym> It's harder to do with some containers.
18:11:26 <Cale> data [a] = a:[a] | []
18:11:28 <Pseudonym> A binary search tree, for example.
18:11:43 <Pseudonym> Because applying fmap might change the relative ordering of its elements.
18:11:43 <firefly> right.  rewiring ones brain is fun but there's no escaping that it takes some time.
18:12:19 <firefly> Currently I'm running on consciuos effort to handle this.  I'll have to wait a day or two before the rewiring is complete.
18:12:31 <firefly> Pseudonym: Ah, fun.
18:12:37 <Cale> Well, once you understand functors, you're very close to understandin monads.
18:12:42 <Cale> understanding*
18:13:01 <Riastradh> Pseudonym, not that hard with a binary tree.
18:13:08 <firefly> I think I almost understood them once - but there is this memory thing :/
18:13:17 <Cale> a monad is a functor that comes with a particular strategy of computation
18:13:33 <Cale> okay
18:13:44 <Cale> it's like a container, where you have two things:
18:14:02 <Cale> return :: a -> m a -- this puts one thing into the container
18:14:27 <Cale> and (>>=) :: m a -> (a -> m b) -> m b
18:14:52 <Pseudonym> Riastradh: Hard with a binary SEARCH tree.
18:14:59 <Pseudonym> In general you need to rebuild it.
18:15:17 <Cale> this takes a container of a's and a function which takes a single a, and produces a container of b's, and combines the containers it gets from applying that to all the a's somehow, so that in the end there's just one container of b's.
18:15:42 <firefly> Right!
18:16:15 <Riastradh> Pseudonym, you just need a binary tree merger.
18:16:52 <Pseudonym> I still maintain that it's "harder".
18:16:59 <Riastradh> Hardly.
18:17:10 <Riastradh> fmap f (Branch l r) = merge (fmap f l) (fmap f r)
18:17:56 <Pseudonym> Still O(n log n) at least, compared with O(n).
18:18:50 <Cale> firefly: so that makes sense? or was the "Right!" directed elsewhere?
18:19:02 <firefly> Yes, it makes sense.
18:19:08 <Cale> cool :)
18:19:17 <Cale> that's pretty much all there is to a monad
18:19:36 <firefly> Well, there's also defining ones own monads...
18:19:45 <Pseudonym> Sure, that's tricky.
18:19:54 <Pseudonym> And there's some syntactic sugar to know to use them well.
18:20:02 <firefly> the do-notation.
18:20:07 <Pseudonym> Right.
18:20:11 <Cale> it has to satisfy some basic laws, but they tend to come for free if you define your monad in whatever nonidiotic way any nonidiot would.
18:20:25 <Cale> :)
18:20:33 <Pseudonym> And being a nonidiot is a pre-requisite for writing your own monad.
18:20:46 <firefly> I knew /that/ :)
18:20:52 <Cale> Just keeping in mind what bind (>>=) and return are supposed to be doing.
18:21:00 <firefly> sure
18:21:13 <Pseudonym> It's tricky, but I don't think it's tricker than, say, writing your own STL-compliant container in C++.
18:21:25 <firefly> :)
18:21:39 <firefly> Well, maybe the compiler's error messages are simpler?
18:21:45 <firefly> In Haskell, I mean...
18:23:41 <Cale> and usually the code will be much shorter :)
18:23:42 <firefly> Yes, I have now understood the code I pasted here before.
18:24:03 <firefly> Except for the "scope" of interleavedness that unsafeInterleaveIO yields.
18:25:37 <firefly> @type withTemp
18:25:39 <lambdabot> bzzt
18:26:12 <Cale> withTemp isn't in the GHC libraries
18:26:25 <firefly> No, it is defined in Lock.lhs in darcs.
18:27:53 <firefly> It creates an empty file, runs its argument and deletes the file, returning whatever the argument returned.
18:27:56 <firefly> @type bracket
18:27:58 <lambdabot> bzzt
18:28:13 <Cale> yeah, it's similar to bracket :)
18:28:19 <Cale> @type IO.bracket
18:28:21 <lambdabot> IO.bracket :: forall c a b.
18:28:21 <lambdabot> 	      IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:28:24 <firefly> It is defined via bracket.
18:28:44 <firefly> Lock.lhs uses a funny import statement for bracket:
18:28:50 <firefly> import IO hiding ( bracket )
18:28:52 <Cale> yeah, I figured :)
18:29:06 <Cale> huh?
18:29:12 <Cale> hiding bracket?
18:29:17 <Cale> they use their own?
18:30:06 <firefly> Oh, right, I misread.  They import IO except for bracket and then get bracket (and other stuff) from Control.Exception.
18:30:16 <firefly> (catchJust, ioErrors, block, finally)
18:30:23 <firefly> @type Control.Exception.bracket
18:30:25 <lambdabot> Control.Exception.bracket :: forall c a b.
18:30:25 <lambdabot> 			     IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:30:45 <firefly> Is there a difference in how they handle exceptions?
18:30:56 <Cale> not sure
18:31:44 <stratocaster> Yea, there is. Catch and bracket and such in Control.Exception catch everything; the prelude ones don't.
18:32:22 <stratocaster> Well, "catch more", anyway :p I'm not sure of the specifics, really.
18:33:02 <Pseudonym> OK, I'm shocked.
18:33:11 * Riastradh unplugs Pseudonym.
18:33:11 <Pseudonym> Don't use IORefs in your inner loops indeed.
18:34:15 <Pseudonym> What a bizarre attitude.
18:34:40 <firefly> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/IO.html#v%3Abracket
18:35:01 <firefly> stratocaster: yes, the Control.Exception.bracket version handles all exceptions.
18:36:03 <firefly> Why are they defined as bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c instead of bracket :: IO a -> (a -> IO ()) -> (a -> IO c) -> IO c ?
18:36:14 <firefly> () means whatever you write for the unit type.
18:36:38 <Riastradh> Because that constrains it to return (), whereas any result would be acceptable.
18:37:01 <Pseudonym> Removing unnecessary constraints is almost always a good thing.
18:37:16 <firefly> well, it only constrains the "release resource" function.
18:37:18 <Riastradh> Sure it is, as long as they're unnecessary.
18:37:26 <Pseudonym> What you consider to be "unnecessary" is an open question.
18:37:49 <Riastradh> Well, I left the meaning of 'unnecessary' up to you, seeing as how you said it.
18:37:56 <Pseudonym> :-)
18:38:09 <Pseudonym> In this case, the result is unused, so requiring it to be a certain thing is unnecessary.
18:38:25 <firefly> sure, but that way lies dynamic typing ;)
18:39:02 <firefly> Pseudonym: what were you shocked about earlier?  Whose IORefs?
18:39:36 <Pseudonym> Oh, Simon P-J on the mailing list.
18:47:34 <firefly> Right, thanks for the help! :)
18:48:01 <firefly> I think I understand enough now that I can understand the code that fetches patches from remote repositories over HTTP.
18:48:23 <firefly> Expect the first version of a patch to darcs that uses parallel connections and pipelining tomorrow :)
18:56:33 <SamB> why do you suppose ANSI and ISO don't seem to offer free web access to specs?
18:57:07 <Pseudonym> That's a silly question.
18:57:27 <Pseudonym> Or was it rhetorical?
18:57:55 <SamB> well, I think it is a serious question too
18:58:10 <Pseudonym> A standard isn't like a law.
18:58:29 <Pseudonym> i.e. you can make money by selling copies of them
18:58:49 <lispy> i'm trying to create a simple interpreted scripting language, is it easier to do dynamic typing or static typing?
18:59:38 <Pseudonym> It's easier to implement dynamic typing.
18:59:53 <lispy> okay, thanks
18:59:59 <Pseudonym> Besides, if it's meant to be a simple scripting language, static typing will probably get in the way.
19:00:04 <Pseudonym> i.e. your scripts won't be simple any more
19:00:44 <lispy> why not?
19:01:21 <Pseudonym> If you need to put in type declarations, your scripts will look less simple.
19:01:24 <lispy> i was going to make it functional with named closures, some builting data types and that's about it
19:01:28 <lispy> ah
19:01:43 <lispy> s/builting/bultin/
19:01:51 <lispy> gah
19:01:56 <lispy> can't type, but you know what i mean
19:02:02 <dons> but you can do static typing with type inference. then the scripts stay simple
19:02:54 <lispy> dons: i was considering that, but i want to have some utility functions like map, which made me think i would need polymorphic type classes.  Which means things might get hairy
19:03:17 <lispy> other than one compiler for a class i took, this is my first compiler
19:03:43 <dons> you would want polymorphism. but don't need type classes.
19:04:57 <lispy> perhaps i'll do dynamic typing, and look into adding type inference later.  That would allow me to get some functionality working, and room to improve
19:05:07 <SamB> Pseudonym: well, rest assured that they didn't make any money off my copy.
19:05:13 <SamB> of C99, that is
19:05:33 <Pseudonym> There are copies online.
19:05:55 <lispy> thanks dons and Pseudonym 
19:06:17 <SamB> there are? are they supposed to be?
19:06:43 <SamB> regardless, I think I got mine from bookwarez
19:07:13 <clausen> Pseudonym: I think type declarations make development time shorter (even for scripting)
19:07:25 <Pseudonym> http://www.open-std.org/jtc1/sc22/wg14/www/standards
19:07:38 * clausen wonders if it is a testable hypothesis
19:07:47 <Pseudonym> Perhaps.
19:07:53 <Pseudonym> I think it depends what you're scripting.
19:08:23 <Pseudonym> If you're only doing text munging, for example, your type system would be fairly boring.
19:08:54 <lispy> this is for a game eventually
19:09:10 <dons> why not reuse an existing language then?
19:09:11 <lispy> at this point it's for learning, but i hope to use it when it's more mature
19:09:29 <SamB> well, if they don't want people to feel like they are in a grey area, they should improve their distribution techniques.
19:14:57 <SamB> hmm. the next C standard or revision thereof ought to use the term "computing" instead of "data processing"
19:57:03 <Leimy_> so I am trying to write a function that takes a list of functions and composes them all
19:57:08 <Leimy_> composeList
19:57:15 <Leimy_> and having a crap of a time with it :)
19:59:32 <SyntaxLaptop> sounds hard :)
19:59:37 <SyntaxLaptop> are they functions a -> a
20:00:01 <Leimy_> that's a good question
20:00:05 <Leimy_> yeah
20:00:07 <Leimy_> hmmm
20:00:45 <Leimy_> the exercise doesn't specify
20:00:57 <Leimy_> it's from Simon Thompson's book
20:01:44 <SyntaxLaptop> so it doesn't tell you the type of composeList?
20:01:54 <Leimy_> nope
20:01:55 * SyntaxLaptop suspects that's the only way to do it :) where's the problem?
20:02:00 <Leimy_> you have to figure that out
20:02:23 <SyntaxLaptop> well, can you see the problem if it's NOT a -> a?
20:02:34 <SyntaxLaptop> hm actually, maybe it's not a problem, mn
20:02:35 <SyntaxLaptop> nm
20:02:42 <Leimy_> mevernime
20:02:50 <Leimy_> d
20:03:00 <SyntaxLaptop> hehe
20:03:58 <Leimy_> so... that's trickyu
20:04:03 <Leimy_> er tricky
20:05:02 <SyntaxLaptop> yeah, figure out the type first :)
20:06:08 <Leimy_> kind of working on that :)
20:06:10 <dons> foldl (.) (id) [(+1), (*2)] $ 7
20:06:36 <Leimy_> that's cryptic to me :)
20:07:30 * SyntaxLaptop isn't sure how to be helpful without giving it away
20:07:36 <Leimy_> yeah
20:08:25 <monotonom> The type of each function has to be the same a->a
20:08:35 <Leimy_> yeah
20:08:40 <monotonom> Thus the list has to be of type [a->a].
20:08:41 <Leimy_> for the list of functions to exist :)
20:08:49 <Leimy_> lists can't have items of varying types
20:08:52 <Leimy_> iirc
20:10:27 <SyntaxLaptop> Leimy_: that's basically correct.  lists in haskell may contain only one type.
20:11:13 <monotonom> Well, list processing always falls into this thought pattern.  What to do with the empty list?  What to do with a non-empty list, in which case you can always say it is of the form f::rest, and you can always use recursion to process rest, so you just have to worry about the extra work to do for f?
20:11:19 <Leimy_> id returns
20:11:23 <Leimy_> poop
20:11:26 <Leimy_> composeList :: [a->a] -> a -> a
20:11:27 <Leimy_> ?
20:11:43 <SyntaxLaptop> :)
20:12:02 <Leimy_> is that the correct type basically?
20:12:12 <Leimy_> composeList :: forall a. [a -> a] -> a -> a
20:12:23 <monotonom> Yes it is the right type.
20:13:49 <Leimy_> composeList :: [a->a] -> a -> a
20:13:49 <Leimy_> composeList [] = id
20:13:49 <Leimy_> composeList (x:xs) = x . composeList xs
20:13:51 <Leimy_> ???
20:14:06 <Cale> that works
20:14:25 <monotonom> You are getting the hang of it.
20:14:30 <Leimy_> i understand the foldl version too
20:14:31 <Cale> what you're doing is replacing the : with a . and the [] with id
20:14:50 <Leimy_> but I keep forgetting foldr vs foldl :)
20:14:53 <Cale> so you can write it as foldr (.) id
20:14:54 <SyntaxLaptop> Leimy_: show us the fold version
20:15:04 <Leimy_> it's already been posted :)
20:15:05 <SyntaxLaptop> hehe nm
20:15:25 * SyntaxLaptop was going to point out foldl1 (.) if you still wanted to break it up by case
20:15:37 <Leimy_> foldl1?
20:15:39 <Leimy_> hmmm
20:15:42 <SyntaxLaptop> @type foldl1
20:15:44 <lambdabot> foldl1 :: forall a. (a -> a -> a) -> [a] -> a
20:15:46 <Leimy_> I've not messed with haskell in like amonth
20:15:48 <SyntaxLaptop> you have to have at least one element in the list
20:15:51 <Leimy_> and have forgotten some stuff :)
20:16:45 <Leimy_> SyntaxLaptop: that's neat
20:17:02 <Leimy_> ther eis a lot of stuff in Prelude that makes life easier
20:17:13 <SyntaxLaptop> it's only useful in rare occasions, since you have to make sure that the list is non-empty, but when it's good, it's good.
20:17:17 <Leimy_> It's like any other language's standard library
20:17:23 <Cale> that's why it's in the prelude :)
20:17:28 <Leimy_> heh
20:17:32 <Leimy_> right
20:17:36 <monotonom> It is the standard library.
20:17:59 <Cale> well, the standard library extends out a little farther
20:18:21 <monotonom> Alright, it is part of the standard library for haskell.
20:18:52 <SyntaxLaptop> Leimy_: have you seen the less-than-standard libraries? http://www.haskell.org/ghc/docs/latest/html/libraries/
20:19:40 <Leimy_> heh
20:20:13 <Leimy_> that's cool
20:20:16 * Leimy_ digs the ghc\
20:21:35 <Cale> things like Data.FiniteMap, Control.Concurrent, and Text.ParserCombinators.Parsec deserve pointing out :)
20:21:53 <Leimy_> regular expressions are cool too
20:28:57 <SyntaxLaptop> leimy_: how are you liking thompson's book?
20:29:08 <Leimy> it's quite cool
20:29:10 <Leimy> :)
20:29:16 <Leimy> switched  machines
20:35:51 <Pseudonym> If it helps, there are basically three things you should be thinking about if you have a problem with lists.
20:35:56 <Pseudonym> 1. List comprehensions.
20:36:02 <Pseudonym> 2. map/filter/fold
20:36:05 <Pseudonym> 3. Recursion.
20:36:13 <Pseudonym> Often any one of those will do.
20:36:18 <Leimy> list comprehensions are really nice :)
20:36:20 <Leimy> IMO 
20:36:44 <SyntaxLaptop> yes.
20:40:26 <Pseudonym> I suppose do-notation would also be appropriate.
20:40:56 <SyntaxLaptop> dija know that they automatically filter for non-matching patterns? like [x | Just x <- l] is catMaybes or something
20:41:37 <Pseudonym> And didja know you can do local definitions in them.
20:41:47 <Pseudonym> [ x | y <- ys; let { x = f y } ]
20:42:19 <SyntaxLaptop> "Ahh... Such a great language" -- Simon Peyton Jones
20:48:35 <Leimy_> indeed
20:48:58 * Leimy_ knows a wee bit o lisp and scheme
20:49:12 <Leimy_> and I understand "where" and "let"
20:57:49 * SyntaxLaptop bed &
20:58:36 <FlamingRain> i should actually learn some haskell
20:58:44 * FlamingRain grabs haskell book
20:59:59 <Cale> l
21:00:54 <Pseudonym> Yes, you should learn some haskell.
21:00:58 <Pseudonym> Learning haskell is good.
21:01:30 <FlamingRain> it's my first functional language, so, it's intersting to learn and begin to think in function terms
21:02:55 <Pseudonym> LOL!
21:03:10 <FlamingRain> ?
21:05:09 <SamB> haskell also makes quite a fine imperative language.
21:05:13 <Pseudonym> Oh, Fergus posted a wonderful rant to the Haskell mailing list.
21:06:44 <dons> that was a good one, yes :)
21:07:28 <monotonom> "Haskell is the finest imperative language in the world :-)"  --- Simon Peyton Jones
21:08:14 <Pseudonym> Tom Conway suggested the following reply to Fergus: "Well if you want Mercury, you know where to get it."
21:08:55 <clausen> Pseudonym: URL?
21:08:55 <SamB> imperatives are actually first class in haskell, which is *really* cool!
21:09:15 <dons> monotonom: we need a "spjquote" module for lambdabot
21:09:29 <monotonom> Yes.
21:09:49 <Pseudonym> We could replace monotonom with a small Haskell function.
21:09:56 * clausen wonders why computer scientists don't copy economists and do "NAJs"
21:10:02 <clausen> (Not-A-Journal)
21:10:05 <Pseudonym> So long as we can put in Perlis quotes too.
21:10:52 <Pseudonym> clausen: Here 'tis.
21:10:55 <Pseudonym> http://www.haskell.org//pipermail/haskell/2004-June/014239.html
21:11:01 <clausen> Pseudonym: great!
22:01:22 <Leimy_> so when will he start writing a debugger? :)
22:01:58 <clausen> Leimy_: I think he is happy with the mercury debugger ;)
22:02:57 <Leimy_> didn't see that part of the thread
22:03:26 <clausen> I'm saying that because I know him personally
22:03:32 <clausen> (not because of anything I read there)
22:03:49 <Leimy_> clausen is my favorite pickle brand :)
22:03:56 <clausen> hehe
22:04:02 <Pseudonym> I asked that the Mercury debugger be named MerDe, but I was overruled.
22:04:25 <Leimy_> is there an URL for Mercury?
22:04:28 <Pseudonym> My other suggestion was LogiFix, but nobody liked that either.
22:04:34 <clausen> www.cs.mu.oz.au/mercury
22:04:34 <Leimy_> and has it been ported to OS X?
22:04:51 <Pseudonym> Ah, yes, here it is.
22:04:53 <Pseudonym> http://www.cs.mu.oz.au/research/mercury/mailing-lists/mercury-developers/mercury-developers.9804/0024.html
22:05:47 <Leimy_> so mercury isn't a haskell debugger?
22:05:50 <Leimy_> oh well
22:07:52 <Leimy_> so what makes mercury so special vs haskell?
22:07:56 <Leimy_> just better tools?
22:08:11 <Pseudonym> Mercury is a logic language.
22:08:24 <clausen> mercury is to prolog what haskell is to lisp
22:08:24 <andersca> mercury is pretty neat
22:08:28 <Pseudonym> It has similar goals, in that it's meant to be a pure declarative language suitable for writing big programs in.
22:08:31 <Leimy_> prolo... nm
22:08:39 <Leimy_> oh that's pretty neat
22:08:55 <Pseudonym> Actually, Mercury is to Prolog what 1976-era ML is to Lisp, but that's another rant.
22:09:08 <Pseudonym> Bitter?  Moi?
22:09:49 <clausen> Pseudonym: why do you say that?
22:09:57 <clausen> (is your rant available?)
22:10:01 <Pseudonym> No.
22:10:07 <Pseudonym> My main beef is the syntax.
22:10:19 <Pseudonym> It's terribly archaic, and really gets in the way.
22:11:06 <lispy> Pseudonym: that goes for must popular languages though, (java, C#, C++ for example)
22:11:54 <Verbophobe> I actually got interested in Haskell originally because of its syntax...
22:12:00 <Verbophobe> It looked all cool, and shit.
22:12:07 <Pseudonym> Prolog's syntax is worst than most.
22:12:26 <Verbophobe> "I came for the syntax, I stayed for the <insert Haskell feature>"
22:13:07 <monotonom> I came for the typeclass, I stayed for the syntax. :D
22:13:13 <lispy> my favorite syntax is lisp, it's so regular and simple
22:13:23 <dons> Verbophobe: should be on a t-shirt
22:13:55 <monotonom> Dammit it isn't regular it's context-free!
22:14:28 <jemfinch> what isn't?
22:14:28 <Verbophobe> dons: Should be, but I wouldn't wear it...  It would suck to have to explain list comprehesions or whatever to everyone you met.
22:15:12 <lispy> monotonom: would you prefer consistent?
22:15:25 <Verbophobe> lispy) Really?  Your favourite syntax is lisp?  I can't believe that.  There are absolutely no obvious surperficial marks that would lead me to such a conclusion.
22:15:42 <monotonom> heh heh heh
22:15:47 <lispy> Verbophobe: yeah, funny dat
22:15:50 <jemfinch> what's not regular?
22:17:57 <lispy> jemfinch: i commented on lisp having a regular and simple grammar, but I meant regular as the opposite to irregular
22:18:07 <jemfinch> lispy: hah
22:18:12 <jemfinch> makes sense.
23:49:44 <blackdog> quiet as the grave here... i guess you're all happily hacking?
23:50:01 <Gahhh> I am not
23:50:21 <Gahhh> I have to admit I haven't done anything haskell related in over a month !
23:50:26 <Gahhh> *shame*
23:52:32 <blackdog> take 10 (repeat $ hail mary)
23:53:08 <Gahhh> lol I almost thought that was plain english
23:53:47 <Gahhh> damn these high level languages
23:54:08 <Gahhh> would have never happened with mov eax, edx
23:54:12 <blackdog> try confessing in assembler some day. :)
23:55:05 <Gahhh> I was just reading about a shootout between spam filters
23:55:07 <vegai> fetch ComfyChair
23:55:53 <Gahhh> I think I'd rather fix the problem underneath than combat the spammers
23:56:32 <vegai> indeedo
23:56:37 <vegai> talk to shapr 
23:57:18 <Gahhh> shapr ?
