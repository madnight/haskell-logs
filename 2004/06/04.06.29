00:57:49 <vegai> hmm, where's that bot again
00:58:02 <vegai> shapr: hilfe!
02:12:19 <musasabi> How expensive are lambdas and StablePtrs with GHC? Would an app design using 20000 stable pointers to lambdas "type VTrans = StablePtr (String -> IO ([String], Vtrans))" be sensible? What about garbage collection if they are frequently created and dumped?
02:17:04 <Lunar^> musasabi: Maybe you should ask this on glasgow-haskell-users ?
02:19:11 <musasabi> hmm, could make sense... or then just write a quick benchmark.
02:33:44 <Lunar^> musasabi: Both :)
03:20:37 <Lemmih> @arr
03:20:37 <lambdabot> Ahoy mateys
03:24:35 <shapr> @yow !
03:24:36 <lambdabot> I am NOT a nut....
03:30:59 <musasabi> How would I embed a GHC produced program inside a C program?
03:44:26 <musasabi> Or even how do I call haskell from inside the C program given a StablePtr value on the C side pointing to a haskell function?
03:46:56 <ozone> musasabi: i'm pretty sure that's just a function pointer.  just call from it from C as you would a usual function pointer
03:49:44 <musasabi> and to handle the monadic return value? an IO([String], StablePointer)
03:50:07 <musasabi> the manuals seem quite scarce on the C->H direction, while the otherone seems more supported.
03:50:52 <ozone> i wouldn't call them manuals so far as specifications
03:51:06 <ozone> you can't return an (IO [String], StablePtr)
03:51:19 <ozone> you have to return something which is in the Storable class
03:51:24 <ozone> i.e. IO CString
03:52:30 <musasabi> ok.
03:52:50 <musasabi> Does the monad make things different?
03:52:59 <ozone> nope
04:01:03 <seafood> musabi: You will need to initialise the runtime system from C then call the function.
04:03:22 <seafood> See Section 8.2.1.1 in http://haskell.cs.yale.edu/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html
04:06:18 <musasabi> seafood: thanks, that looks promising.
04:18:33 <vegai> about monads again...
04:19:06 <vegai> why is [] a Monad? Is the definition for its (>>=) the only one?
04:19:31 <vegai> hawiki suggests pondering how "data Tree a = Leaf a | Branch (Tree a) (Tree a)" would be made into a monad
04:19:35 <vegai> is there only one way to do that?
04:20:00 <seafood> vegai: Monads just have to satisfy certain laws.
04:20:22 <seafood> vegai: So if you can come up with another way to define >>= that satisfies those laws then it's still a monad.
04:24:46 <vegai> is there a single obvious answer to the Tree monad?
04:25:42 <musasabi> vegai: list as a monad is convenient, it could be equally well not a monad.
04:26:17 <vegai> what is the use of it being a monad?
04:26:31 <musasabi> vegai: it can be combined in nice ways.
04:27:07 <vegai> like [2,4,6] >>= (\a -> [a-1, a+1]) and so forth?
04:27:14 <vegai> hrm
04:27:30 <vegai> the people who invent new monads must be geniuses
04:28:17 <musasabi> the tree could be e.g. return a = Leaf a; bind a f = forest_to_tree (forall_nodes f a)
04:29:17 <musasabi> where forest_to_tree :: [Tree a] -> Tree a
04:29:54 <vegai> is it then normal that when I find a new monadized type, I cannot be sure what >>= does for it before looking at the code?
04:30:03 <musasabi> yes
04:30:15 <vegai> ah, that helps a lot!
04:30:21 <musasabi> at least I don't know any magic way to do that.
04:30:31 <vegai> musasabi: kiitoksia
04:30:40 <musasabi> np 
04:30:42 <vegai> arogaitou gozaimashita etc.
04:31:31 <vegai> for some reason, it seemed that >>= has to have only one definition for each type
04:52:52 <sorrow> Is it possible to define a datatype which only consist of a list of digits?
04:53:21 <earthy> sorrow: sure
04:53:36 <sorrow> What would it look like?
04:53:47 <earthy> data Digit = Zero | One | Two | Three | Four | Five | Six | Seven |Eight |Nine;
04:53:56 <earthy> type DigitList = [Digit]
04:55:15 <sorrow> Why does data Digit = 1 | 2  not work?
04:56:02 <Heffalump> because 1 and 2 are already defined
04:56:30 <earthy> what you *could* do is define fromInteger for Digit
05:01:29 <sorrow> I wanted to play with regular expressions to construct something like foo (Number:x) = .. where if you run foo "1234foo", "foo" would be in x.
05:02:14 * shapr sings Green Day
05:03:28 <Heffalump> Haskell pattern matching is too low-level to make that possible, IMO.
05:03:53 <Heffalump> s/, IMO// it's clearly impossible unless you pre-process the string first.
05:04:55 <sorrow> Bummer, could have been fun..
05:05:08 <shapr> sorrow: use HaRP!
05:05:21 <shapr> http://www.dtek.chalmers.se/~d00nibro/harp/
05:06:38 <sorrow> Thank you very much but I think I'd rather learn the "language basics" first. ;-)
05:11:25 <shapr> hej andersca 
05:11:35 <andersca> hej
05:12:49 <shapr> how's the far north?
05:13:12 <andersca> pretty good
05:13:16 <andersca> there's theora streaming!
05:14:13 <shapr> where?
05:14:49 <andersca> http://2004.guadec.org/wiki
05:19:59 * shapr looks for a theora player
05:22:02 <ozone> shapr: VLC's probably the easiest
05:22:14 <ozone> well, actually, any of the major ones will do :)
05:30:35 <blackdog> shapr: why HaRP? preprocessors are so yesterday...
05:35:12 <Cale> vegai: the usual definition for >>= on lists helps the list monad model nondeterministic computations (ones which may return multiple results, or none at all)
05:37:46 <Cale> you could make another definition for bind on lists, but it's hard to pick one which is quite as natural as the one which is used
07:41:04 * shapr preprocesses blackdog into an anime character!
07:43:10 <thebug> (!)
07:43:46 <thebug> huh, apparently I make Iter's connection fail
08:14:34 <shapr> any gtk2hs users here?
08:36:42 --- mode: irc.freenode.net set +n
08:48:24 <shapr> saynte: have you built gtk2hs on debian?
09:05:39 <saynte> shapr: nope, gentoo
09:11:24 <mattam> i can try...
09:11:50 <shapr> so far I've noticed I'm missing a bunch of -dev packages
09:12:41 <mattam> oh nm, i thought saynte had problems :)
09:25:32 <saynte> shapr: oh really?
09:26:24 <shapr> but I'm installing them now
09:26:46 <saynte> i didn't notice it needed anything obscure?
09:34:19 <Zhivago-> hello, I have a stupid question, which probably doesn't apply to haskell, but I'm interested in finding something which does static analysis and propagation of type _errors_.
09:34:54 <Zhivago-> ie, if you divide a number in the range 1-4 by a number in the range -2 to 2, you might potentially get a divide by zero error.
09:35:04 <Zhivago-> any pointers would be appreciated
09:37:18 <Smerdyakov> I don't know what you mean precisely by "propagates type errors."
09:37:40 <Zhivago-> well, um, given that we might be dividing by zero, it would be nice to know what region of code is therefore dodgy
09:37:49 <Smerdyakov> And what region is that?
09:38:15 <Igloo> Do you just want to make a call graph and propogate potential errors up it, OAIC?
09:38:48 <Zhivago-> igloo: well, the difference here is that I don't actually mind code which potentially produces errors
09:39:12 <Igloo> Java's exceptions do that, I believe, except they require you to actually write the possible exceptions in yourself and just complain if you don't
09:39:20 <Zhivago-> igloo: so I mostly want to be able to note what regions are affected, so that I can generate appropriate run-time checks
09:39:33 <Igloo> (based on a poor memory, so I could be completely wrong)
09:39:39 <Smerdyakov> Your notion of "regions" is underdefined.
09:39:41 <Zhivago-> well, I'm not running code at this point - just doing type analysis.
09:39:56 <Heffalump> Igloo is correct about Java's checked exceptions.
09:39:57 <Zhivago-> smerd: yes, I'm sure it is - which is one reason that I'm asking for pointers to research on this kind of thing.
09:40:19 <Igloo> Oh, if you just want to put runtime checks in you just do it at the point where you have the potential errors - I don't see what you mean about propogating things
09:40:44 <Heffalump> you might want to put them in only at the places where you might make an unsafe call
09:41:14 <Heffalump> e.g. you have a generic divide method called by lots of things, and you only want to put run-time checks in at the potentially dangerous callsites
09:41:15 <Smerdyakov> Zhivago-, maybe you are looking for the keyword "dependent type systems"? I really haven't understood you well enough yet to know what you want, though.
09:41:15 <Zhivago-> igloo: well, the things which depend on the code which has a potential error condition in it are now also uncertain of being invoked
09:42:04 <Zhivago-> heffa: that's part of it - but the other part is working out what downstream region is now no-longer guaranteed to be reached.
09:42:24 <Smerdyakov> Zhivago-, why do you care if a region is reached? To suppress further warnings?
09:43:19 <Zhivago-> smerd: well, it affects how the code can be reordered to some extent
09:43:30 <Zhivago-> smerd: but also to generate warnings about the extent of the possible damage
09:43:45 <Zhivago-> I don't know exactly what I want, which is why I'm looking :)
09:44:13 <Smerdyakov> I can't think of any static analysis that attempts to determine which code is unreachable because of runtime errors (or lack thereof).
09:44:29 <Zhivago-> hmm, fair enough
09:45:36 <Zhivago-> what I'm currently imagining is that if I say, 'work out the type of a/b', then I might get back a union of some numbers, and an error signal type
09:45:49 <Smerdyakov> It would probably be helpful if you gave us the concrete example that led you to want to investigate this.
09:45:51 <Zhivago-> but I haven't thought that through so it's probably a bit stupid
09:47:22 <Zhivago-> well, the concrete example is (/ (integer 0 4) (integer 0 4)) -> (or (rational 0 1) (signal divide-by-zero))
09:47:51 <Smerdyakov> What does that mean?
09:48:31 <Zhivago-> it means, the type of dividing an integer in the range 0..4 inclusive and an integer 0..4 inclusive is a ration 0..1 or a divide-by-zero signal
09:49:10 <Zhivago-> which is quite possibly a stupid idea
09:49:13 <Smerdyakov> OK. What makes you want to deduce this?
09:50:01 <Zhivago-> well, because it lets me determine what type of thing will result from this operation, so that I can work out what the consequences may be for whatever is invoking it
09:50:27 <Zhivago-> it's a bit problematic imho, because if you carry this though clearly you need to consider side-effects in general
09:50:42 <Smerdyakov> What is an example of something you would do with this information?
09:50:56 <shapr> I know that value types have been used in a variety of Haskell programs
09:51:06 <Zhivago-> well, I might decide on what class of instance I would like to use to represent that answer
09:51:15 <shapr> HaskellDB uses them to turn strings into varcharNNN for example
09:51:20 <Zhivago-> or I might decide on what method dispatches are possible based on it
09:51:45 <Zhivago-> I might also decide on if such a region is necessarily correct, possibly incorrect or necessarily incorrect.
09:51:54 <Zhivago-> and then tell someone about it
09:52:04 <Smerdyakov> Zhivago-, I sense you are coming at this from a very Lispy angle. "What class of instance to use" comes automatically from the function's return type in Haskell, for example.
09:52:23 <shapr> you could encode that information in the type system if you wish
09:52:28 <Zhivago-> well, the use of lisp syntax and type specifiers probably gave it away
09:52:45 <Smerdyakov> Zhivago-, yes, but it is also not clear to me that your problem is meaningful at all in Haskell.
09:53:07 <Zhivago-> well, as I said at the beginning, it probably isn't related to haskell
09:53:19 <Smerdyakov> And, if that's true, then what would prevent the answer: allow optional use of Haskell's type system ?
09:53:21 <Zhivago-> but I was hoping that static analysis fetishists would have some directions to point in :)
09:53:32 <shapr> you could create three different types, for negative, positive, and zero numbers, and use typeclasses and various tricks to do addition with them
09:53:43 <Zhivago-> smerd: well, I'm quite happy to copy haskell's type system where appropriate
09:53:59 * Heffalump wonders how you could do addition with them
09:53:59 <shapr> you could check for the impossibility of divide by zero, I think
09:54:05 <Smerdyakov> Zhivago-, so where isn't it appropriate? What is your counterexample to using that strategy?
09:54:11 <Zhivago-> smerd: but we're dealing with a largely dynamic system, with declared invariants for larger scale inference
09:54:53 <Zhivago-> smerd: well, how does haskell handle that case of a potential run-time error?
09:55:08 <Zhivago-> smerd: point me at something to read, and I'll go and do that
09:55:10 <Smerdyakov> Zhivago-, I think execution halts on such errors.
09:55:19 <Zhivago-> smerd: well, that's a problem for me :)
09:55:31 <vegai> exceptions?
09:55:45 <Smerdyakov> You can also implement an operator like divChecked :: Int -> Int -> Maybe Int
09:55:47 <Zhivago-> smerd: one of lisp's best features is the ability to run incorrect programs
09:55:59 <Smerdyakov> Which returns Nothing on an error, Just <result> otherwise.
09:56:17 <Zhivago-> smerd: well, I can handle that already with (or integer ...)
09:56:42 <Zhivago-> smerd: what I'm currently interested in is some kind of coherent integration of static analysis and run-time error inference
09:57:12 <Smerdyakov> We generally like to avoid "run-time errors" in the statically typed FP world. :)
09:57:14 <Zhivago-> smerd: (and side-effect analsysi)
09:57:16 <Zhivago-> yes, I know
09:57:35 <Smerdyakov> So I would say, "remove run-time errors from your language/API design."
09:57:58 <shapr> what was the question again?
09:58:09 <Zhivago-> well, I'd say that that's a silly suggestion, and if I were after that, I'd be using haskell and getting all of my errors at compile-time, like a good C programmer. :)
09:58:22 <shapr> you want to infer which areas of your code can have certain errors, yah?
09:58:37 <Zhivago-> shapr: what I'm looking for is some research on type analysis which can represent error conditions (ie, non-local flow control)
09:58:42 <Smerdyakov> Zhivago-, the idea of an "error" is rather ill-defined, but I certainly don't mean "all errors are proved impossible at compile time."
09:58:58 <Zhivago-> shapr: it's a bit esoteric, so any reference would be appreciated
09:59:05 <Smerdyakov> Zhivago-, I mean that those "errors" which are too hard to check for statically will be represented by special function return values, for instance.
09:59:15 <shapr> you mean represent error conditions in the type?
09:59:19 <Zhivago-> smerd: yeah, I'm familiar with that approach.
09:59:34 <Zhivago-> shapr: well, I'm not sure that that's sensible, but something like that, yeah.
09:59:35 <Smerdyakov> Zhivago-, so why don't you want to use it?
09:59:55 <Zhivago-> smerd: I'm not interested static functional systems.
10:00:17 <Zhivago-> smerd: except in terms of where they happen to be subsets of dynamic general systems.
10:00:34 <Smerdyakov> Zhivago-, and what makes you say that that isn't the case here
10:00:48 <Zhivago-> what I'm interested in is the continuum between the two extremes
10:00:54 <Smerdyakov> Why?
10:01:07 <shapr> There's Soft Typing and 'Firm Typing'
10:01:11 <Zhivago-> because I think that's where there interesting pay-offs are.
10:01:31 <Smerdyakov> How about an example to support your view?
10:02:09 <Zhivago-> smerd: how about getting your static functional system to redefine itself on the fly
10:02:30 <shapr> Zhivago-: something like this? http://c2.com/cgi-bin/wiki?SoftTyping ?
10:02:51 <SyntaxNinja> shapr: so types are like Tofu, it seems.
10:02:54 <Zhivago-> shapr: looks about right
10:03:02 <shapr> SyntaxNinja: with nice sauce
10:03:19 <Smerdyakov> Zhivago-, you are saying that allowing that sort of meta-redefinition precludes using a static type system to do some particular thing that you want?
10:03:21 <Zhivago-> syntax: well, more you end up with a type system which accepts the possibility of incorrectness, and makes it the programmer's problem
10:03:22 <shapr> Zhivago-: there's a citeseer url at the bottom, so that should get you onto the path you want
10:03:48 <Zhivago-> shapr: oh, lovely :)
10:04:13 <Zhivago-> smerd: pretty much
10:04:20 <Smerdyakov> Zhivago-, so what's an example of this?
10:04:25 <Zhivago-> smerd: I think that static typing is a nice optimisation
10:04:47 <Zhivago-> smerd: but you lose out on the general case by limiting yourself to a subset of potential systems.
10:04:58 <Zhivago-> smerd: well, how about a lisp system :)
10:05:24 <Smerdyakov> Zhivago-, something more specific than that, please. Present a program that you want a tool to analyze in a certain way, and explain how static typing won't work.
10:06:06 <Zhivago-> smerd: static typing will always work given a specific case with a specific working program.
10:06:27 <Zhivago-> smerd: you just take your program and rub off the degrees of type freedom until it becomes static
10:06:29 <Smerdyakov> So present a series of programs that gives an idea of why it won't work in general....
10:06:46 <Zhivago-> smerd: you didn't like the lisp system as an example, did you? :p
10:06:50 <Smerdyakov> I'm not being pedantic. I honestly have no idea what you're talking about.
10:07:08 <Smerdyakov> "A Lisp system" does not specify the problem.
10:07:17 <Smerdyakov> Clearly "most" analyses in some sense are undecidable.
10:07:21 <Zhivago-> smerd: why not? it's a dynamically self-extending program
10:07:23 <Smerdyakov> You have to specify the analyses you are looking to perform.
10:07:33 <shapr> Igloo: is debian's c2hs orphaned?
10:08:16 <Igloo> AFAIK Michal Weber(?) is still listed as maintainer, but I don't know if he has had time to look at it recently
10:08:23 <shapr> it requires ghc5
10:08:26 <shapr> so I think not
10:08:58 <Igloo> If you e-mail him I'm sure he'd be happy for you to take over as maintainer  :-)
10:09:04 <shapr> heh, scary thought
10:09:41 <shapr> I would like to maintain some haskell debs that I do use on a daily basis.
10:10:36 <shapr> bah, why not
10:11:20 <SyntaxNinja> shapr: you use c2hs?
10:11:28 <Zhivago-> shapr: yeah, that's the approach that I'm using at the moment - was hoping that he'd have some more interesting error handling, but it's a good starting point - thanks.
10:12:07 <shapr> Zhivago-: if I run across any more research related to soft typing I'll mention it to you
10:12:17 <shapr> SyntaxNinja: for gtk2hs only atm
10:12:47 <shapr> but I'm highly irritated at both galeon and firebird, so I'm investigating the difficulty of hacking GtkMozEmbed.hs into something generally usable
10:13:19 <Zhivago-> shapr: thanks, much appreciated :) goodnight
10:13:52 <shapr> let's see... do I know any Debian Developers?
10:14:16 <vegai> there must be a dozen at least on this channel ;)
10:14:24 <shapr> vegai: are YOU a DD?
10:14:58 <SyntaxNinja> speaking of which, I hope you guys all joined the new haskell-debian mailnig list
10:15:10 <vegai> no, not me
10:15:26 <vegai> not even a DU ;)
10:15:33 <shapr> I'm on it!
10:15:34 <shapr> I think
10:16:34 * Heffalump is on it. It's kind of quiet.
10:16:59 * shapr decides to make some noise
10:17:04 <Heffalump> it's debian-haskell, anyway
10:17:39 <shapr> debian-haskell at earthli right?
10:17:52 <Heffalump> lists.urchin.
10:17:56 <shapr> aha
10:18:06 * SyntaxNinja hands Heffalump a pendant
10:18:22 <Heffalump> well, you could email debian-haskell@earth.li, but your mail would either bounce or annoy Noodles.
10:18:34 <Heffalump> either outcome wouldn't help it get to the subscribers
10:18:34 <shapr> who's noodles?
10:18:52 <Heffalump> noodles are food. Noodles is the person who runs earth.li
10:19:30 <shapr> aha
10:19:59 <shapr> yay, my key is signed by Marvin-- 
10:20:06 <shapr> Marvin--: hey, is that your DD key?
10:20:44 <shapr> Marvin--: that's a very large list of key sigs.
10:21:03 <Heffalump> anyone good at licences?
10:21:08 <Heffalump> </completely off topic>
10:21:14 <shapr> what sort of license?
10:21:19 <Heffalump> GPL compatibility.
10:21:36 <shapr> you want to create one? or see if one is GPL-compat?
10:21:57 <Heffalump> I want to understand what it means to be GPL-compat.
10:22:12 <Heffalump> this may involve creating the Heffalump Public Licence as a thought experiment.
10:22:38 <shapr> my recent license epiphany came from the HESSLA license applied to Peekabooty
10:23:17 <shapr> I think the GPL and DFSG have different goals and may come into conflict at some point, if that helps any.
10:23:27 <Riastradh> Heffalump, you could ask GNU...
10:24:12 <Riastradh> Or would that solution be too easy?
10:24:19 <Riastradh> I guess it probably is.
10:24:22 <Heffalump> I could do, yes.
10:24:29 <Heffalump> I was hoping not to have to.
10:24:36 <Riastradh> Why not?
10:25:14 <Heffalump> it would waste their time to some extent, and it would be harder to discuss by email than by IRC
10:25:38 <SyntaxNinja> Heffalump: can I weigh in on the side of "please, god, not another license!"?
10:26:10 <Heffalump> it's only a thought experiment, to help me understand what it means :-)
10:26:52 <SyntaxNinja> Heffalump: my suggestion is to write your license, combine it with some GPL code, then try to get it into Debian.  That should get it debated ;)
10:27:09 <Heffalump> I can't write my licence, it would be a copyright violation.
10:27:23 <Heffalump> since it would be made by s/GNU GPL/Heffalump Public Licence/g on the GPL.
10:28:29 <firefly> It could be fun to see what a GPL-like license written from a UK-perspective instead of a US-perspective would look like.
10:29:09 <firefly> A variant based on continental European legal traditions (without all that case law) would be even more interesting.
10:29:45 <firefly> SoakingFire?
10:30:19 * shapr washes firefly with napalm
10:30:37 * firefly still bitches more about libwww
10:30:44 * Riastradh napalms libwww.
10:30:52 * firefly thanks Riastradh 
10:30:53 <shapr> bah, beat me to it
10:31:32 * Riastradh napalms shapr while he's at it.
10:31:57 <firefly> shapr: quick!  Bounce away from it!
10:32:25 * shapr slips in the vaseline and goes down!
10:32:47 <shapr> happily, my asbestos underwear keeps me cool.
10:32:55 * firefly doesn't want to know - but whatever two (or more) consenting adults do is ok and stuff.
10:33:18 <shapr> what about just one consenting adult?
10:33:27 * firefly really doesn't want to know
10:33:29 <shapr> I don't even want to know if that's a 'corner case'
10:33:38 * firefly really really doesn't want to know
10:38:20 <shapr> foo, c2hs doesn't register itself with ghc-pkg
10:38:28 <shapr> but it does leave the c2hs.conf lying around
10:42:19 <shapr> aha, fixed it
10:43:06 <shapr> saynte: where's fromGObject defined?
10:55:29 <shapr> fooey
10:55:42 <shapr> gtk2hs no longer uses GObjectClass
10:57:56 <shapr> hiya jemfinch 
10:58:02 <SyntaxNinja> hi jemfinch
10:58:12 <jemfinch> howdy, y'all.
10:58:28 <jemfinch> SyntaxNinja: do you still live in Columbus?
11:01:11 <SyntaxNinja> jemfinch: yeah
11:04:56 <shapr> saynte: did you hack the .chs or the .hs MozEmbed?
11:05:22 <jemfinch> I think I keep getting you mixed up with Walters.
11:05:24 <jemfinch> (and thinking you've moved, to Europe or something)
11:05:28 <jemfinch> (although yes, I know walters has only moved to Redhat...Boston?)
11:05:38 <shapr> and colin walters is a bit shorter, no?
11:07:20 <SyntaxNinja> jemfinch: right, he's in Boston. and no, colin walters isn't particularly shorter than me, we are just about exaclty the same height and weight, I'd suspect.
11:07:35 <shapr> oh
11:07:36 <SyntaxNinja> our tai kwon do teacher always used to get us mixed up too.
11:07:41 <jemfinch> why?
11:07:42 <SyntaxNinja> then he kicked me in the head and I stopped going
11:07:44 <jemfinch> Colin has long hair.
11:07:49 <jemfinch> you don't.
11:07:51 <shapr> he seems shorter than you in pix
11:08:10 <SyntaxNinja> shapr: maybe perspective or something, maybe he's slightly shorter, he could be slightly taller. i've never noticed.
11:08:14 <cgibbard> i need help
11:08:18 <cgibbard> this is desrt
11:08:18 <cgibbard> help me
11:08:25 <cgibbard> cale is designing a non-deterministic turing machine
11:08:27 <cgibbard> he's crazy
11:08:29 <shapr> cgibbard: ok, first try using /nick
11:08:30 <cgibbard> what should i do?
11:08:40 <cgibbard> i did try using /nick.   this dumb irc client sucks :P
11:08:40 <shapr> oh, not that kind of help.
11:08:45 <Heffalump> KILL HIM! KILL HIM NOW!
11:08:58 <cgibbard> brb.  killing cale
11:09:06 <shapr> heck all of the turing machines I've written were non-deterministic.
11:09:12 <shapr> mostly because I could never get the code to work right.
11:11:43 <shapr> hiya eno 
11:12:34 <eno> hi shapr
11:12:38 <shapr> how's code?
11:12:54 <eno> haven't done any, just get bored at work
11:13:02 <eno> and see what's up
11:14:17 <eno> i did read the "tour of prelude" over the weekend and enjoy it
11:14:18 <shapr> I'm trying to hack on GtkMozEmbed, I wonder how difficult it is to make a simple galeon clone in Haskell
11:15:01 <eno> hmm, never a GUI person myself
11:16:05 <shapr> neither am I, but I'm highly irritated at both galeon and firefox
11:16:13 <shapr> so I figure it worth the fifteen minute test.
11:16:36 <eno> what do you not like about firefox?
11:16:45 <shapr> keyboard focus problems
11:17:28 <shapr> but first, unicycling!
11:17:47 <eno> i c
11:18:20 <eno> i use elinks quite a bit
11:19:13 <eno> what do u mean by unicycling?
11:19:29 <shapr> er, I'm going to ride my unicycle for an hour or so
11:19:33 <shapr> it's good exercise.
11:20:14 <eno> i c, i thought it was a problem of firefox
11:35:55 <cgibbard> wow.
11:36:31 <desrt_> so *that's* why /nick didn't work
11:36:45 <desrt_> an error message would have been nice :)
11:37:26 <stepcut> desrt_: sometimes the error message is shown in the 'server window' instead of 'channel window'
11:38:06 <desrt_> right.  it was.
11:38:24 <stepcut> :p
11:40:03 <basti_> hi
11:45:15 <Marvin--> phew
11:45:26 * basti_ agrees
11:45:29 * Marvin-- tired
11:55:13 <firefly> I think I am going to win my epic battle :)
11:55:18 <basti_> against and for what?
11:55:21 * firefly bounces
11:55:25 <firefly> libwww
11:55:39 <firefly> (this should have been to the #darcs channel, sorry)
11:55:44 <basti_> i see.
12:08:56 <Marvin--> SyntaxNinja: ping?
12:23:56 <cgibbard> Actually, I'm designing a nondeterministic *algorithm* - it would run real nice on an NTM though. Uses the list monad heavily to keep things sane.
12:24:40 <basti_> hmm
12:29:57 <SyntaxNinja> hi Marvin--
13:05:51 * TheHunter thinks there should be an identity type constructor, so that (>>=) would become reverse application
13:06:11 <Riastradh> type Identity a = a  ?
13:06:16 <TheHunter> yepp
13:06:24 * Riastradh points at the identity monad.
13:06:45 <Riastradh> ...oh, that's not quite the same, never mind.
13:07:31 <TheHunter> like (->) and arrows
13:09:34 <shapr> I just realized that QuickCheck is a lot more about category theory than I thought
13:09:40 <shapr> at least, it can be
13:10:19 <shapr> the most common QC test I've seen reversibility, like read and show and "1" and 1
13:14:03 <Igloo> Hurrah; 5 days of compilation to find there is no bug
13:14:22 <thebug> what were you compiling Igloo ?
13:14:31 <Igloo> ghc
13:14:46 <monotonom> 5 days for proving ghc correct is cheap.
13:14:49 <thebug> 6.2.1?
13:15:05 <Igloo> Yup
13:15:16 <thebug> for woody/sarge/sid?
13:15:34 <Igloo> It's already in sid for most arches
13:15:39 <thebug> I'd be interested in a 6.2.1 for woody if you've got one :)
13:16:09 <saynte> shapr: I poked at both until something worked
13:16:10 * Igloo has too much to fix for sarge currently  :-(
13:45:12 <fl0wl3ss> what is haskell ?
13:45:54 <fl0wl3ss> ok
13:47:14 <shapr> it's a programming language
13:47:33 <shapr> would you like to learn Haskell?
13:48:01 <fl0wl3ss> errr no no, i am learning c at the moment :D its widely enough for me right now :) thanx anyways
13:48:33 <fl0wl3ss> what is haskell knows for ?
13:48:35 <fl0wl3ss> known**
13:49:06 <shapr> it's the most well know "purely functional" programming language.
13:49:12 <jemfinch> fl0wl3ss: being lazy.
13:49:24 <fl0wl3ss> purely functional ?
13:49:38 <shapr> oh yes, it's also know for its "non-strict semantics" also known as "lazy evalution"
13:49:53 <shapr> purely functional means that code in Haskell works more like an equation in math
13:49:58 <fl0wl3ss> ah ok
13:50:04 <shapr> if you set x to a certain value, it stays that way
13:50:31 <shapr> each function call must be totally described by its inputs
13:50:39 <fl0wl3ss> k
13:50:42 <shapr> no global variables, that sort of stuff
13:50:52 <lambdawar> whats the real performance issues with haskell, I mean comparing to C (of course you have more compile time expressivity in haskell)
13:50:59 <shapr> it's a very different approach than C
13:51:13 <fl0wl3ss> shapr what distro are you running ?
13:51:21 <shapr> lambdawar: from what I've read, Haskell is in general seven times slower than C
13:51:33 <shapr> but the speed of execution is not Haskell's great idea
13:51:44 <shapr> fl0wl3ss: I'm using Debian, what about you?
13:51:58 <fl0wl3ss> shapr, same :) which branch ?
13:52:01 <jemfinch> shapr: exactly 7x?  Not 6.5x or 8x?
13:52:04 <shapr> unstable
13:52:12 <shapr> jemfinch: "in general" :-P
13:52:25 <shapr> plus I haven't tested it lately
13:52:25 <fl0wl3ss> shapr, i've switched to debian yesterday
13:52:42 <shapr> Haskell executes programs faster than I can write them, so...
13:53:06 <shapr> I'm very fond of debian, if you have any debian questions, feel free to ask me
13:53:08 <jemfinch> shapr: asuffield was in here the other day (or was it #darcs?  Yeah, I think it was there) arguing that Haskell is the fastest functional programming language in existence.
13:53:40 * jemfinch always wants to spell his nick assuffield, for some reason.
13:54:17 <fl0wl3ss> shapr, if i insatll a package which doesnt come from apt-repositories, or a program i compiled from source, will it be upgraded when i apt-get dist-upgrade if that same program exists in the repositories ?
13:54:38 <jemfinch> Me: "O'Caml is faster than GHC."  Asuffield: "No, it isn't."
13:54:39 <Philippa> jemfinch: might that be true for laziness-bigot values of functional?
13:54:51 <jemfinch> I mean, honestly, what am I supposed to do there?
13:54:54 <Philippa> important point: faster at *what*?
13:55:06 <Philippa> OK, OK, most likely /everything/ on x86...
13:55:11 <shapr> jemfinch: from one viewpoint, OCaml isn't functional, but that just depends on your definition
13:55:12 <jemfinch> yeah, I was about to say :)
13:55:23 <fl0wl3ss> :)
13:55:27 <jemfinch> Philippa: I think there's very little if anything that Haskell would beat O'Caml in speedwise :)
13:55:36 <shapr> fl0wl3ss: no, those packages won't be upgraded, that's why it's best to use debs whenever possible
13:55:43 <shapr> er wait
13:55:46 <jemfinch> shapr: that viewpoint leaves about 3 functional languages in the whole world, thus making the term useless :)
13:56:09 <Philippa> Haskell, Clean, what's the other?
13:56:10 <jemfinch> I think Haskell is better described as an "applicative" language, perhaps.
13:56:13 <shapr> fl0wl3ss: yes, it *will* be upgraded, but user-built programs usually end up /usr/local, and deb programs in /bin and /sbin
13:56:15 <jemfinch> Philippa: ok, 2 :)
13:56:22 <jemfinch> Philippa: oh, Miranda.
13:56:24 <fl0wl3ss> ah it will be upgraded
13:56:25 <fl0wl3ss> ok
13:56:41 <Philippa> does Miranda have a decent approach to IO as well, then?
13:56:44 <Philippa> or does it just not do it?
13:56:49 <shapr> fl0wl3ss: so it can happen that you have both versions of a program installed at the same time, and weird problems can happen
13:56:54 <jemfinch> I don't know Miranda.
13:57:00 <jemfinch> I just remember that it's purely applicative.
13:57:02 <fl0wl3ss> ah k
13:57:07 <jemfinch> anyway, I gots to shower.
13:57:16 <fl0wl3ss> so in debian its best to install programs from apt repositories
13:57:23 <fl0wl3ss> using apt-get
13:57:32 <shapr> fl0wl3ss: on the good side, there's the alternatives system in debian that lets you swap the 'canonically correct' /bin/foo symlink between user and system binaries
13:57:57 <fl0wl3ss> shapr, i didnt understand this ^^
13:58:30 <eno> fl0wl3ss: i install sun's java this way
13:58:42 <shapr> for example, if you have both python2.1 and python2.3 installed at the same time, /bin/python probably points to /usr/etc/alternatives/python
13:59:05 <shapr> and you can use the command 'update-alternatives' to add python alternatives, and change which one is the default
13:59:12 <fl0wl3ss> ah
13:59:23 <fl0wl3ss> ok look
13:59:28 <fl0wl3ss> i am running testing
13:59:39 <fl0wl3ss> i can install xchat like this: apt-get install xchat ...
13:59:44 <shapr> right
14:00:05 <fl0wl3ss> but if i go to the xchat website and download the deb ... will it be the sid , woddy or sarge deb ? or none of em ?
14:00:24 <shapr> it can be any of those
14:00:41 <fl0wl3ss> and if its the sid package, i shoudlnt install it right ?
14:00:47 * Philippa tries to remember how the hell she needs to set up X on shortarse so it displays properly...
14:01:03 <Philippa> once I've got that sorted I may be back asking about DVDs and CSS ;-)
14:01:07 <shapr> when the app developer builds their own debs, sometimes they build it for one branch only, or for some custom setup no one has ever heard of
14:01:44 <fl0wl3ss> ah ok
14:02:07 <shapr> fl0wl3ss: if you want to get a later version of xchat than is already in testing, you can use 'apt-get source xchat' to get the original sources that were used to build the current binary
14:02:28 <shapr> that's also a good way to see if there's a bug you can fix or stuff like that
14:02:35 <fl0wl3ss> ah ok
14:02:42 <stepcut> apt-get source is great
14:02:52 <fl0wl3ss> shapr, if i install xchat frmo source it will be upgraded when i apt-get dist-upgrade right ?
14:03:25 <shapr> yes, the latest binary for your branch will be installed
14:03:48 <fl0wl3ss> :O
14:04:02 <shapr> but it will probably be missing whatever changes you made to your local source-built binary, unless you got the xchat deb maintainer to integrate your changes
14:04:18 <fl0wl3ss> the manual says that dist-upgrade upgrades all insatlled "packages"
14:05:01 <shapr> so, when you run apt-get update, it grabs the Packages.gz file(s) from your local mirror (or cdrom, or whatever)
14:05:40 <shapr> that holds a bunch of entries
14:05:53 <shapr> lemme see where it is in the filesystem, it's educational to look at it...
14:06:24 <fl0wl3ss> ok
14:07:49 <shapr> foo, I can't remember where the control files hang out...
14:08:06 <fl0wl3ss> its k
14:08:07 <fl0wl3ss> np
14:08:12 <shapr> anyway, a deb is an ar archive with two gzip'd files inside it
14:08:19 <fl0wl3ss> k
14:08:25 <fl0wl3ss> what's in those 2 ?
14:08:25 <shapr> oh, do you know about the file command?
14:08:32 <fl0wl3ss> the file command ?
14:08:48 <shapr> apt-get -uf install file
14:09:07 <fl0wl3ss> -uf ?
14:09:12 <SyntaxNinja>  /var/lib/apt/lists
14:09:30 <shapr> er, I think -u means "ask before installing stuff" and -f means "fix missing"
14:09:45 <fl0wl3ss> ah
14:09:48 <fl0wl3ss> hmm if i download a deb package that doesnt exist in the apt repositories .. and i have missing deps needed by this program.. where will they be downloaded from ?
14:10:15 <shapr> they won't be
14:10:22 <shapr> unless you've added an apt-source that does have them
14:10:23 <SyntaxNinja> if you downloaded a deb package, you have to use dpkg to install it, which doesn't handle dependencies
14:10:33 <fl0wl3ss> ah ok
14:10:36 <SyntaxNinja> apt is layered on dpkg
14:10:42 <fl0wl3ss> ok
14:11:08 <shapr> right, SyntaxNinja is a Debian Developer (thank you for your work SyntaxNinja :-)
14:11:24 <fl0wl3ss> SyntaxNinja, u a debian developper? 
14:11:27 <fl0wl3ss> kewl
14:11:38 <SyntaxNinja> fl0wl3ss: yes. there are several here.
14:11:46 <fl0wl3ss> ah
14:11:46 <shapr> so, if you have the less program installed, type in 'less /var/lib/apt/lists/<tab><tab>'
14:12:35 <shapr> the <tab><tab> means hit tab twice
14:12:43 <fl0wl3ss> i know :D
14:12:46 <fl0wl3ss> ok
14:12:47 <shapr> ok :-)
14:13:09 <shapr> each of the file in that dir came from one of your apt sources
14:13:09 <SyntaxNinja> it's important to consider that things you download outside of apt will not be considered by apt. that means that it won't upgrade it, it won't automatically install dependencies, etc.
14:13:14 <fl0wl3ss> shapr, what desktop env are you running ?
14:13:22 <fl0wl3ss> ok SyntaxNinja
14:13:28 <shapr> I use ion and emacs, but it's not for everyone :-)
14:13:46 <fl0wl3ss> SyntaxNinja, what if the stuff i downlaoded outside apt exist in apt at the same time ?
14:13:49 <shapr> if you're new to linux, I'd suggest you start with gnome or kde
14:13:53 <SyntaxNinja> also, if you install version 1 of package X by hand, then apt-get update, and if apt has a newer version, it'll probably try to upgrade it.
14:14:00 <Philippa> shapr: remind me how to reconfigure X under debian?
14:14:15 <fl0wl3ss> Philippa, dpkg-reconfigure xserver-xfree86
14:14:20 <shapr> Philippa: first, check the entrails of a local chicken...
14:14:22 * shapr grins
14:14:26 <Philippa> heh
14:14:29 <SyntaxNinja> fl0wl3ss: it all depends.  apt will check to see what's installed; if it has a newer version, then it'll install that.
14:14:35 <Philippa> yeah, funny that, guess why I need to reconfigure...
14:14:35 <fl0wl3ss> ah ok
14:14:38 <SyntaxNinja> (when you upgrade)
14:14:40 <fl0wl3ss> ok ok i see
14:14:53 <Philippa> just never got round to doing it right 'cos Shortarse is mostly a router
14:14:59 <fl0wl3ss> SyntaxNinja, and programs compiled from source that also exist in apt are upadted too right ?
14:15:03 <SyntaxNinja> now you can prevent apt from doing such things, but that's slightly more advanced :)
14:15:19 <SyntaxNinja> if there are newer versions, yeah. but you can "hold" packages, like I just mentioned.
14:15:54 <eno> shapr: another ion'er here
14:16:05 <shapr> eno: yah, tuomov r0xx0rs
14:16:40 <jemfinch> tuomov?
14:16:49 <shapr> fl0wl3ss: so, any more questions?
14:16:59 <fl0wl3ss> it should be ok ..
14:17:15 <fl0wl3ss> the first install of debian was a kind of test
14:17:20 * SyntaxNinja points out how 1337 Debian is
14:17:22 <shapr> jemfinch: http://iki.fi/~tuomov/
14:17:27 <fl0wl3ss> i tried everything, and messed a lot with the system , and installed lots of stuff
14:17:32 <shapr> aka Tuomo Valkonen
14:17:35 <fl0wl3ss> im going to do a new clean install in a while
14:17:53 <shapr> fl0wl3ss: good idea! that's the best approach to learning new stuff in my opinion
14:17:59 <fl0wl3ss> :D
14:18:09 <shapr> start with a setup where you have the freedom to break it horribly
14:18:19 <fl0wl3ss> that's what i did
14:18:29 <fl0wl3ss> i messed the system so much that it didnt boot anymore lol :p
14:18:32 <fl0wl3ss> i am in knoppix
14:18:36 <shapr> heh, cool!
14:18:45 <fl0wl3ss> i have the sarge 80 megs cd
14:18:52 <SyntaxNinja> fl0wl3ss: you should download darcs, fix one of the bugs, then darcs send me the patch and I'll apply it to the next version. it's a really easy bug to fix, but it'll teach you something.
14:18:53 <fl0wl3ss> i make a net install and install the packages 1 by 1
14:18:54 <shapr> I learned about hard drive parititions the first time by removing mine.. "never heard of it, I must not need it"
14:19:07 <fl0wl3ss> darcs ?
14:19:17 <fl0wl3ss> lol
14:19:19 <SyntaxNinja> a version control system (written in Haskell)
14:19:24 <fl0wl3ss> ah
14:19:33 <jemfinch> "I guarantee you that you will save yourself a great deal of time using a strictly typed language like SML over an alternative like...Lisp, where huge classes of errors go undetected until runtime, though they could have been caught by an ML compiler." <-- I wonder what sort of guarantee that is.  Do I get money if he's wrong?
14:19:40 <fl0wl3ss> you want ME to fix a bug ?
14:19:57 <fl0wl3ss> i barely know some c, im not going to college yet
14:20:05 <SyntaxNinja> apt-get install darcs; darcs get http://www.syntaxpolice.org/darcs_repos/darcs;cd darcs-*/debian/;less control 
14:20:07 <SyntaxNinja> (fix bug)
14:20:13 <SyntaxNinja> darcs send ijones@syntaxpolice.org
14:20:40 <SyntaxNinja> it's really easy. it's not a C or Haskell bug, it's just a little problem in the control file.
14:20:51 <SyntaxNinja> you can read about the problem on the debian bug tracking system (for the darcs package)
14:21:14 <fl0wl3ss> k ill check
14:21:45 <SyntaxNinja> fl0wl3ss: that'll teach you a lot about debian 1) control files 2) the bug tracking system 3) changelogs 4) debuild etc.
14:21:49 <SyntaxNinja> and darcs on top
14:21:53 <SyntaxNinja> but I have to go now.
14:22:14 <shapr> bye SyntaxNinja!
14:22:43 <SyntaxNinja> peace all. bye shapr
14:22:44 <fl0wl3ss> laterz SyntaxNinja
14:27:29 <fl0wl3ss> shapr, you use KDE ?
14:28:04 <shapr> no, I use ion
14:28:14 <shapr> but you should try both KDE and gnome and see what you like best
14:28:56 <fl0wl3ss> i prefer kde .. what is ion btw ?
14:29:01 * stepcut uses kde
14:29:13 <fl0wl3ss> stepcut, can i have a screenshot of your desktop please ?
14:29:42 <shapr> hi gini 
14:29:53 <gini> hi shapr
14:30:16 <stepcut> fl0wl3ss: it's screwed up right now -- the latest kdelibs in debian sid does not work properly with the button styles
14:30:41 <gini> I had a busy time but now I come back ..
14:31:06 <fl0wl3ss> ah ok
14:31:22 <fl0wl3ss> stepcut, look can you put the taskbar in a different panel ?
14:31:22 <shapr> I can show you my desktop, but it's not very exciting :-)
14:31:31 <fl0wl3ss> :p its ok forget it
14:32:31 <fl0wl3ss> mines kicks ass but there are some stuff that still need tweaking
14:32:36 <fl0wl3ss> and i cant find way to do it
14:32:47 <shapr> do you have a screenshot of your desktop?
14:33:16 <fl0wl3ss> right now i am in knoppix
14:33:32 <shapr> ah, ok
14:33:36 <fl0wl3ss> i am going to do a new debian install in a while and customize it again, ill send u screenshot 
14:33:41 <fl0wl3ss> look
14:33:44 <shapr> spiffy!
14:33:57 <shapr> any more questions?
14:35:19 <fl0wl3ss> yea
14:35:30 <shapr> ok!
14:35:48 <shapr> ?
14:37:22 <fl0wl3ss> look
14:37:28 * shapr looks
14:37:32 <fl0wl3ss> lol
14:37:39 <fl0wl3ss> i want to put the taskbar outside of the panel
14:37:51 <shapr> you can do that in gnome, I know
14:37:54 <shapr> I haven't tried it in KDE
14:37:59 <fl0wl3ss> errr
14:38:06 <fl0wl3ss> u know someone who might now ?
14:38:44 <shapr> no, but I'd suggest the #kde channel
14:39:19 <Lemmih> There isn't an official Haskell clan prefix, right? (Wondering if I could combine ass kicking in BZFlag with Haskell advertisement)
14:39:35 <fl0wl3ss> ok
14:39:47 <fl0wl3ss> thanx for your time answering my questions shapr
14:40:04 <shapr> sure, anytime
16:03:00 <saynte> anyone have any experience with converting the contents of a file to a haskell type?
16:03:56 <stepcut> saynte: sure...
16:04:10 <keverets> what kind of file?
16:04:28 <saynte> xml
16:04:44 <keverets> do you have a DTD or XML Schema?
16:04:47 <saynte> but the type in haskell could change
16:04:49 <saynte> a DTD
16:05:23 <keverets> use HaXml and DtdToHaskell
16:05:39 <saynte> alreayd using HaXml, but i'm running into a problem when I actually try to use fReadXml
16:05:57 <keverets> what problem?
16:06:13 <saynte> Ambiguous type variable `a' in the top-level constraint:     `XmlContent a' arising from use of `fReadXml' at Editor.hs:32
16:07:14 <keverets> could be in your use of fReadXml, then.  Gotta go.  will bbl.
16:07:19 <saynte> essentially i'm trying to create an xml document which conveys a certain structure, the content of that structure however should be interpreted as any number as types
16:07:20 <saynte> k
16:07:24 <saynte> thanks though!
16:09:02 <kosmikus> how does line 32 look like in your file?
16:09:37 <saynte> t5 <- fReadXml "table.xml"
16:10:01 <kosmikus> is it clear from the context which type t5 should have?
16:10:14 <saynte> not really!
16:10:17 <kosmikus> try to give a type signature for the right hand side
16:10:35 <kosmikus> t5 <- (fReadXml "table.xml" :: MyDTDType)
16:10:42 <kosmikus> oh no
16:10:47 <kosmikus> IO missing
16:10:58 <kosmikus> but you should get the idea
16:11:11 <kosmikus> or provide a type signature for the whole function
16:11:32 <saynte> ok that works
16:11:38 <kosmikus> if you read a value from a string, the compiler has to have some way to find out the result type; it cannot guess it
16:11:42 <saynte> well, i did it slightly differently
16:11:44 <saynte> but it compiles now
16:12:32 <kosmikus> good
16:12:50 <saynte> okay, so say I have this huge list of types in my program, and they all define an instance of some class C. and C has instances toString/fromString, so that it can readto/read from the xml file.
16:13:06 <saynte> how can I generalize my reader to type them properly?
16:14:28 <kosmikus> something like   reader :: (C a) => String -> IO a   ?
16:14:53 <dons> maybe you need something related to the Binary class
16:14:54 <dons> instance Binary Int8 where
16:14:54 <dons>   get h    = do w <- get h; return $! (fromIntegral (w::Word8))
16:14:54 <dons> instance Binary Int16 where
16:14:54 <dons>   get h    = do w <- get h; return $! (fromIntegral (w::Word16))
16:15:20 <dons> so for each type you have an instance of Binary
16:15:31 <dons> in your case, it would be slightly different.
16:16:21 <dons> class Binary a where
16:16:22 <dons>     get    :: BinHandle -> IO a
16:16:31 <saynte> yes, i kinda figured I'd have to define an instance for all types I want to use, but it's the part past that. As in, just reading from a file, at some point it has to decide what type the string should be converted to
16:17:28 <dons> hmm. unless you have a representation of the type stored in the file, you'll have to use knowledge of how to parse the file to construct the type
16:17:55 <dons> here's how I do it using Binary for .hi binary files:
16:17:56 <dons>     get bh = do
16:17:56 <dons>             version   <- get bh :: IO String
16:17:56 <dons>             build_tag <- get bh :: IO Word8
16:17:56 <dons>             pkg_name  <- get bh :: IO FastString
16:18:19 <dons> so I know beforehand the ordering of data in the file, so I can type each call to get
16:18:47 <kosmikus> Are you two really talking about the same thing?
16:19:07 <saynte> well he's relating my case to the case of Binary
16:19:16 <saynte> and I'm getting lost, but that's ok ;)
16:19:33 <dons> yep. I just happen to have had the same problem very recently, using Binary to parse untyped data from .hi files ;)
16:20:27 <saynte> it works if I explicitly type it, but that's not really optimal.
16:20:40 <kosmikus> ok, why not?
16:21:06 <saynte> well, it would be ok if i could automate the typing
16:21:12 <saynte> but I'm a newbie, and don't know how to do that :)
16:21:29 <dons> I don't think you can do that, unless you store a representation of the type in the data file
16:21:37 <saynte> that's ok, I'm open to that ;)
16:21:53 <dons> this is a standard problem with untyped data in strongly, statically typed languages
16:22:18 <saynte> *whew* i'll feel bad when I come into problems that people have NEVER had before :0
16:22:26 <kosmikus> "automate" it? but surely, you want to do something with the value later, so you know its type?
16:22:58 <dons> I'm assuming he means just: get bh = do v <- get; b <- get ...
16:23:10 <dons> without any explicit type constraints?
16:23:48 <saynte> well, lets say I have types a,b,c,d,e...z. And they all define an instance of class XmlReadable.
16:23:55 <kosmikus> ok
16:25:02 <dons> ok
16:25:28 <saynte> Optimally, I would like to be able to read those from an xml file (possibly with explicit typing within the file, that's fine if it's needed!) and return them
16:26:08 <dons> I can think of 3 ways. (1) explicit type constraints in the reader like above.
16:26:20 <dons> (2) the structure of the data file determines the type, like the Read class
16:26:33 <dons> (3) you store with each value in the data file a representation of the type
16:26:42 <dons> like "(v :: Int)"
16:27:01 <dons> which is like Data.Typeable
16:27:01 <saynte> ohhh, that 3 looks nice...
16:27:24 <kosmikus> so you want one function that is a wrapper around the method defined in XmlReadable that reads in a file and parses the contents and returns the value; and you want this function to work for all types of the class?
16:28:09 <kosmikus> I don't see what this has to do with dynamic typing; the types have to be pregenerated by HaXml anyway ...
16:28:13 <saynte> yep, maybe a bit of background might help. basically i'm editing table structures, where the headers and cells could be different types, strings, expressions, etc.
16:28:46 <kosmikus> sounds to me like you just need ordinary overloaded functions
16:28:53 <dons> it's like dynamic typing in that Haskell's Data.Dynamic stores a representation of the type (a TypeRep) with values so they can be checked at runtime.
16:29:14 <kosmikus> yes, but that is not needed here, as far as I can see
16:29:44 <kosmikus> or
16:29:47 <kosmikus> ok
16:29:57 <kosmikus> I think I have misunderstood the problem all the time
16:30:13 <saynte> don't worry, it's my problem and i don't even understand it :)
16:31:11 <saynte> dons: I think I'll read into the Data.Dynamic and Data.Typeable modules, see what they can offer/do
16:31:17 <kosmikus> so, you read the file at a point where you do not know which DTD it is?
16:31:38 <dons> saynte: I can see a couple of solutions that way, but it may be quite complex
16:31:48 <dons> considering Read offers much the same functionality
16:32:18 <dons> if you can represent each value differently, like 1, 'c', "foo", then you already know the type
16:33:13 <saynte> but they're all represented as strings in the Xml file
16:33:51 <saynte> this is the part where my brain fizzles :) I think I have to, at the very least, explicitly state the type within the Xml file. 
16:33:55 <dons> so you need to store them as pairs with a representation of their type. ("1","Int")
16:34:09 <dons> or store them as a Dynamic, which is the same.
16:34:30 <dons> this will be fun!
16:34:53 <saynte> hmmm, haskell is always fun. at least that's what my boss keeps telling me. and far be it from me to disrupt the party-line :0
16:35:05 <kosmikus> good luck! ... I'll get some sleep
16:35:13 <saynte> hee, thanks kosmikus!
16:35:50 <dons> Prelude> let a = 1 :: Int
16:35:55 <dons> Prelude Data.Dynamic> show (typeOf a)
16:35:55 <dons> "Int"
16:36:18 <saynte> oh wow, that' intense
16:36:51 <stepcut> :p
16:37:59 <saynte> so if I want to go the other way...?
16:38:22 <dons> back in? well, unfortunately it doesn't look like Data.Dynamic defines a read instance
16:38:37 <dons> so you need to write a typecase on strings, for example
16:38:45 <saynte> typcase?
16:39:00 <dons> case read ty of "Int" -> get v :: Int ?
16:39:12 <dons> isn't that roughtly where we are headed?
16:39:16 <saynte> ohhh gotch!
16:39:21 <saynte> yep, it certainly is
16:40:19 <dons> pretty heavy duty stuff, when class Read does similar things, though.
16:41:18 <saynte> yeahhhhh, when i first got on this problem i was thinking read would be good, but similar brain fizzle. still no idea how it can KNOW which type to convert to when all it's starting from is a string.
16:42:20 <saynte> it's all magic to me.
16:42:24 <dons> it's all about having enough information in the data file to reconstruct the type
16:42:43 <dons> whether by the grammar (like Read), or with explict type info
16:45:07 <saynte> is there any way I can specify an instance of the method? say a.Read b.Read ?
16:45:24 <saynte> a.read b.read i mean
16:45:30 <dons> method?
16:45:57 <dons> you could read the first 2-3 pages of "Dynamic Typing in a Statically Typed Language" for a good discussion of this problem
16:46:01 <dons> http://research.microsoft.com/Users/luca/Papers/Dyn.ps
16:46:28 <saynte> err, well, not sure of hte right language to say it, but if a and b are types, could i explicitly call one or the other's read calls?
16:48:51 <dons> sure. define a class for read, and provide instances. then the type information will make sure the correct read is called.
16:49:44 <dons> class MyRead where read :: Handle -> a; instance MyRead Int where read = ... ; ?
16:50:43 <saynte> hm, think that something like this would work?
16:50:45 <saynte> case str of
16:51:08 <saynte> "Int" -> (read str) :: Int
16:51:18 <saynte> "Exp" -> (read str) :: Exp
16:51:18 <saynte> ?
16:51:39 <dons> looks good to me. As long as you know how to read the type in correctly first.
16:52:05 <saynte> well it's not too hard using the HaXml library/module
16:52:10 <dons> except the "str" argument to read should probably be a handle to the source file
16:52:21 <dons> rather than the string you just read as a type
16:52:51 <dons> do ty <- readTy hdl ; case ty of "Int" -> myread hdl :: Int ; "Exp" -> ... 
16:52:59 <saynte> well, the str type is fine in this case, as the types I'm worried about will be encapsulated in another type, but it's just the general concept that I needed a hand with :)
16:53:28 <saynte> but this has been really good, thanks so much for all the help!
16:53:39 <dons> sure!
17:01:50 <dons> I wonder why TypeRep doesn't have a Read instance?
17:02:07 * stepcut wondered too
17:02:25 <saynte> for just this reason? :)
17:02:37 <dons> fair enough Dynamic, but TypeRep is just the canonical string name of a type
17:03:41 <stepcut> dons: yeah, I want some way to read a string that contains the type and the value, but alas...
17:05:07 <dons> well, if it is in binary form then Dynamic would work. you'd have to cast the pointer to the binary data to Dynamic, and then call fromDyn on the result
17:05:32 <dons> so if you could store Dynamics as binary data inside a string...
17:06:51 <stepcut> I want to serialize a few different data types to a string, and then be able to read them back without having to know which one I am reading before I start
17:07:31 <stepcut> I guess I could use something like Base64 to convert the binary to a string and back
17:08:37 <dons> nice idea.
17:09:34 <dons> it would be a good way to have dynamically typed values in textual form, rather than only as binary data
17:10:04 <stepcut> yeah, strings are very conveniant things some times
17:10:37 <dons> strings are very important things. rope is thicker, but strings are quicker!
18:58:19 <rubix^3> rubix
18:58:49 <rubix^3> oups
