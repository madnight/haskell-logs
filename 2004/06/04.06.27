03:28:04 * shapr boings
04:22:11 <Heffalump> morning.
04:37:02 <shapr> oh hey Heffalump 
04:37:13 <shapr> I have a sort-of working unit-quickcheck 
04:40:47 <Heffalump> cool.
04:41:04 <shapr> it's sort of hackish though :-/
04:41:25 <shapr> I added a new combinator "name" that sets a new prop_name field in the Result record
04:41:37 <shapr> otherwise you don't know which prop takes which seed
04:42:00 <shapr> also, when a prop_* fails, it dumps the prop_name and the seed into a line in a "failcases" file
04:42:23 <shapr> and the quickcheck wrapper script renames failcases into this_file.qc
04:42:43 <shapr> so failed cases from Test_Foo.hs end up in Test_Foo.hs.qc
04:43:06 <shapr> and the quickcheck wrapper script pulls lines out of that and adds them onto the front of the random tests
04:43:35 <shapr> it's not very elegant though.... any suggestions for improvement?
04:58:56 <shapr> heya Arnia, have you used QuickCheck?
04:59:52 <Arnia> Nope, sorry...
05:16:46 <shapr> hiya mattsd
05:17:47 <shapr> I'm looking for useful ideas or constructive suggestions relating to saving test cases in QuickCheck, I have an implementation, but it's not very elegant.
05:24:19 <mattsd> hello
05:28:40 <mattsd> I'm new to Haskell, working through intro docs. Is QuickTest a unit testing framework?
05:28:45 <shapr> mattsd: greetings from the arctic circle, how's code in the big city?
05:29:01 <shapr> HUnit is the standard Haskell Unit Testing framework
05:29:15 <shapr> QuickCheck is very different, and much cooler
05:29:47 <shapr> QC lets you assert properties that should hold true for your code, then QC can generate random test data and see if it really does hold true.
05:30:18 <shapr> one of the former downsides of that approach was that HUnit let you retest with failing data, and QC might not find the failing test case again.
05:30:33 <shapr> I've just added the ability for QC to save failing test cases
05:30:35 <shapr> so now it does both
05:30:37 <mattsd> shapr: greetings from Boston. Code here sometimes interesting, often mundane. 
05:31:20 <shapr> I'd be happy to tell you all about Quickcheck, I'm a huge fan of software testing.
05:32:03 <jemfinch> shapr: do you think quickcheck depends on static typing?
05:32:48 <shapr> jemfinch: no, Darius Bacon ported it to Python and Common Lisp
05:33:11 <shapr> jemfinch: http://www.accesscom.com/~darius/software/clickcheck.html
05:33:21 <jemfinch> oh, cool.
05:33:27 <shapr> I think that QC is easier to deal with in a referentially transparent language
05:33:53 <shapr> In Haskell, all state is explicitly passed. That means it's usually easier to manufacture a state to test with.
05:34:18 <shapr> In J2EE, it's so much trouble to set up testing that Cactus is an in-container test framework.
05:34:25 <mattsd> QC sounds interesting to me, as I am integrating test-driven development into my work style. 
05:34:40 <shapr> TDD is *awesome*
05:34:58 * jemfinch finds it somewhat boring sometimes.
05:35:14 <shapr> I wrote this code only because I wanted to find some way to mix TDD and QC
05:35:32 <shapr> if QC saves the first failing test case and then bails, I get TDD 'for free'
05:35:35 <jemfinch> if I do test-driven development, I like to have another person write the tests concurrently with me writing the code.
05:35:56 <shapr> that's doesn't sound like TDD?
05:36:16 <shapr> at least, not the way I know it.
05:36:28 <jemfinch> why not?
05:36:33 <jemfinch> the tests are still written before the code.
05:36:47 <shapr> I like the way test-first puts pressure on my API, and shows me more opportunities for refactoring.
05:36:58 <shapr> jemfinch: maybe I just never thought of it that way...
05:37:23 <shapr> jemfinch: let's try that sometime, then I'll have some actual feeling for it.
05:37:30 <mattsd> shapr: would it be useful for QC to save all test cases, in addition to failed ones? Then, QC becomes a test generator.
05:37:41 <shapr> QC already is a test generator
05:38:20 <shapr> Haskell makes test generators pretty easy.
05:38:31 <Heffalump> why does Haskell make it any easier than any other language?
05:38:32 <mattsd> In my experience, TDD is especially powerful when working on new code, ensuring API's are clear and objects nicely factored. 
05:39:12 <jemfinch> shapr: I find that it just relieves some of the boredom I feel when I write tests first -- then I feel almost like I'm writing the same code twice.  It also gets two minds into the problem, and kind of "debugs" the specification so if there are ambiguities, they're more likely to turn up earlier.
05:39:38 <shapr> I feel like the test is the question, and the code is the answer.
05:40:08 <jemfinch> but then again, most of the testing I've done is in-between unit testing and system integration testing.
05:40:16 <shapr> Heffalump: in my experience, it's more difficult to write randomly generated test data in procedural languages
05:40:53 <shapr> a unit test shouldn't duplicate the code that it's testing
05:41:03 <shapr> why do you feel like you're writing the code twice?
05:41:08 <jemfinch> because I do.
05:41:15 <jemfinch> (feel like I'm writing the same code twice)
05:41:27 <jemfinch> it just feels unnecessarily wordy sometimes.
05:41:44 <shapr> yah, it does feel that way to me sometimes too
05:42:07 <shapr> but then I find a strange bug, and my unit tests point it out in one or two minutes
05:42:24 <shapr> and then I find a strange bug in some non-tested code, and it takes much much longer to find the bugs.
05:42:26 <jemfinch> it's not, and Supybot's tests prove that.
05:42:26 <jemfinch> but that doesn't stop it from *feeling* that way.
05:42:35 <shapr> yah, I understand
05:42:55 <shapr> also, with TDD you have to make sure you slip the 'design and refactor' part into the process
05:42:59 <jemfinch> (Supybot is probably the most tested bot out there, which is very much the reason why, I think, we have so much functionality and so few bugginess)
05:43:30 <shapr> I've considered adding HUnit and QC tests to lambdabot to improve its ability to teach useful coding practices
05:43:34 <shapr> @fortune
05:43:36 <lambdabot> While you don't greatly need the outside world, it's still very
05:43:36 <lambdabot> reassuring to know that it's still there.
05:44:52 <shapr> Heffalump: have you hacked around inside QC? do you know of a good way to return failed cases to a 'top-level' rather than writing them directly to a file?
05:45:21 <shapr> oh, I bet I could move it to the done function
05:46:07 <jemfinch> shapr: you should take a look at Supybot's tests sometime.
05:46:09 <jemfinch> anyway, I gotta run.
05:46:17 <shapr> awright, have fun
05:47:55 <shapr> mattsd: are you using Hal Daume's "Yet Another Haskell Tutorial"?
05:54:52 <mattsd> shar: yah, and I like it quite a bit. 
05:58:00 <mattsd> in GHC, how do I load QC. I see it comes with the distribution in "imports", but haven't figured out how to load it.
06:03:12 <mattsd> shapr: I am also reading Hudak's "The Haskell School of Expression".
06:10:57 <shapr> mattsd: with GHC or GHCi?
06:11:22 <shapr> mattsd: http://www.scannedinavian.org/~shae/src/haskell/ProtoQuickCheck.hs
06:12:11 <shapr> you can load that file into Hugs or GHCi and run "quickCheck prop_RevApp" for example
06:13:42 <shapr> I like that book.
06:15:57 <mattsd> shapr: sorry, with ghci. just figured out: ghci -package QuickCheck works
06:19:25 <mattsd> now I'm confused. Loaded ProtoQuickCheck.hs but ghci complains, "Can't find module `QuickCheck'"
06:20:21 <shapr> ah, try changing "import QuickCheck" to "import Debug.QuickCheck"
06:20:39 <shapr> I have QuickCheck.hs in the same directory with my local copy of ProtoQuickCheck, so it's looking there
06:22:42 <shapr> mattsd: does that fix it?
06:23:12 <mattsd> shapr: that fixes import problem. Now new problem "ProtoQuickCheck.hs:82: Malformed context in instance header
06:23:13 <mattsd> Failed, modules loaded: none."
06:24:09 <shapr> oh, I bet line 82 looks like "instance (Arbitrary a,Arbitrary b)"
06:24:17 <shapr> you can comment out that line with -- at the beginning of the line
06:24:50 <mattsd> in my copy it's main 
06:24:50 <shapr> I'll make a non-extension-using version
06:24:51 <mattsd> main = putStr "yo"
06:24:56 <shapr> hm
06:26:01 <shapr> ok, I think it really is complaining about the instance line
06:26:29 <mattsd> ok, commented out instance line and it loads fine now.
06:27:22 <shapr> so now you can run "quickCheck prop_RevUnit"
06:28:07 <mattsd> "passed 100 tests". success.
06:28:45 <shapr> for a good failure example, look at  "reverse (xs ++ ys) == reverse ys ++ reverse xs" on line 11, and change the last part to "reverse xs ++ reverse ys"
06:29:13 <shapr> once you've saved the file, you can do :r to reload the file in ghci
06:29:24 <shapr> and quickCheck prop_RevApp should fail then
06:31:01 <shapr> do you see what property prop_RevApp is trying to assert?
06:35:53 <mattsd> yes, I see it now. Was manually entering expressions in GHCI to see what was going on.
06:37:32 <shapr> QC is surprisingly good at finding corner cases, off-by-one errors, missing base cases, and all that sort of stuff
06:38:14 <mattsd> That's very useful.
06:38:30 <shapr> Even so, once you start writing generators for your own data types, the quality of those generators is central to the quality of the testing.
06:38:44 <shapr> so it's "No Silver Bullet" just another step forward :-)
06:39:58 <shapr> I do think that generative/random testing can be superior to unit testing, but I'd much rather have both at the same time. 
06:40:11 <shapr> I think the technical term is "stochastic testing"
06:40:21 * shapr feels geeky
06:40:42 <shapr> I am stochastically testing my software!
06:41:03 <mattsd> I'm beginning to see what QC is doing. Now need to find exact words to describe it in my head :) But I like what I see...
06:41:25 <shapr> You might want to read the QuickCheck paper
06:41:56 <shapr> much of the nifty software in the Haskell world comes from academia, which gives some advantages, and some disadvantages.
06:42:06 <shapr> http://www.cs.chalmers.se/~rjmh/QuickCheck/
06:43:26 <shapr> on the good side, the research papers are chock full of ideas, implications, future directions, and lots of great stuff
06:43:58 <shapr> But it can take me a week of evening reading and experimenting to grasp a twelve page paper.
06:46:00 <mattsd> I've noticed academic background. It brings strong theoretical/mathematical basis. It was real revelation to see how mathematical expressions were so easily described in Haskell. 
06:46:09 <shapr> You know those machines that have coke, pepsi, etc "on-draft" ? Some research papers are like drinking the condensed jello pepsi instead of the jello plus carbonated water that we normally have.
06:47:02 <saynte> and there we have it: The Jello-Theory of Haskell :)
06:47:19 * shapr snickers
06:47:28 <shapr> saynte: have you seen my curried chicken theory of Haskell?
06:47:51 <shapr> or maybe you've heard of my in-progress paper on Spears, the generalization of Arrows?
06:47:54 <mattsd> Yah, I understand, and though rewarding and powerful, the power-shot jello can take a lot to digest. Have to be in mood to do it.
06:48:02 <saynte> shapr: that was awful! lol
06:48:13 * shapr grins
06:48:31 <shapr> instance Spear Britney where {}
06:48:39 <mattsd> yikes
06:48:48 * shapr snickers
06:49:06 <saynte> see what haskell does to you? see what you can become?!
06:49:15 <shapr> I don't think I count as an academic, just a highly enthusiastic programmer.
06:50:03 <mattsd> same here. 
06:50:06 <shapr> so, next steps are to collect failing cases in the done function, and try to act more like a unit test by bailing on the first failure of a 'unit' check.
06:55:43 <shapr> mattsd: have you read Kent Beck's TDD book?
06:58:41 <mattsd> shapr: yes
06:59:43 <shapr> I tried TDD early on when Kent first mentioned it on The Wiki, and I was hooked then. I'm glad he wrote the TDD book.
07:01:50 <mattsd> shapr: the book does good putting one in good mindset to approach TDD. 
07:01:56 * shapr agrees
07:03:39 <saynte> hmm, is there any way to have a type signature where the result is completely arbitrary?
07:03:46 <shapr> huh?
07:04:47 <saynte> hehe i guess i didn't phrase that very well, hmm
07:05:08 <saynte> uhm, like a -> b, where b could be a String or an Int
07:05:15 <saynte> i'm parsing an xml file
07:05:30 <shapr> myFoo :: (XML b) => String -> b
07:05:32 <shapr> ?
07:06:12 <saynte> reverse of that actually, using HaXml, [Content] -> a (it's for the instance of a HaXml class)
07:06:16 <det> saynte: you want it to return a sum type?
07:06:34 <saynte> det: what's a sum type specifically?
07:06:59 <det> shapr: please correct my Haskell syntax as necessary.
07:07:49 <det> saynte: data result = XMLInteger int | XMLString string
07:08:08 <det> I don't know what builting string/ints are alled in Haskell
07:09:45 <det> g'night #haskell
07:09:48 <saynte> det: ohhhh okay, gotcha. no i don't want a sum type. it's this certain table type i'm working with. the type being "T", then header and sub-table. so "T h t" is the type with ehad h, and subtable t. but the subtable could be n-dimensional. so T h (T h ()) would be a one dimensional table. but i need a way to return n-dimensional talbes if possible
07:09:50 <saynte> det: night!
07:54:27 <maihem> Are there functions that act on Int to asses/manipulate the state of bits in the twos-complement binary representation of that Int?
07:56:36 <shapr> @index shiftR
07:56:36 <lambdabot> Data.Bits,Foreign,Bits
07:57:14 <maihem> thanks
08:02:15 <Heffalump> is there a standard type class encompassing IORef and STRef?
08:02:20 <Heffalump> like MArray has IOArray and STArray
08:13:08 <Cale> saynte: would it be okay for the head to be another table?
08:24:38 * shapr bounces happily
08:25:01 <jemfinch> why's that?
08:25:14 <shapr> I found an easy way to fix a bug that I thought would take lots of extra work.
08:25:36 <jemfinch> oh, cool :)
08:25:42 <jemfinch> what was the bug?
08:26:05 <saynte> Cale: hmm, i'm not sure, i want to say yes, but in that case all the headers would have to be tables of the same type, of that dimension at least
08:26:08 <shapr> er, it's in Zope Archetypes where the String Widget couldn't handle URLs
08:26:24 <shapr> I wish I could do "vi `locate foo`[5]"
08:26:39 <shapr> or cd `locate foo`[5] to drop into the same dir as a file
08:26:56 <shapr> are there path and file combinators in the unix command line?
08:27:52 <neologism> foo=`locate bar`;foo[5]
08:28:05 <neologism> at least in tcsh
08:28:46 <shapr> nice, can I do that in point-free style without assignment?
08:28:55 <neologism> dunno
08:29:00 <neologism> probably not
08:29:13 <shapr> hm
08:29:15 <neologism> use function
08:29:48 <Cale> what exactly should that [5] mean?
08:29:59 <neologism> fifth item in a list?
08:30:21 <shapr> or sixth if you count from zero
08:30:30 <neologism> yes ;)
08:30:34 <saynte> or first if you count from 5.
08:30:44 <shapr> :-P
08:30:46 <neologism> you guys are funny ;)
08:31:01 <saynte> :D just offering options!
08:31:02 <Cale> write a script using head and tail to get exactly the nth line of input then
08:31:19 <shapr> good idea
08:31:22 <neologism> bad idea
08:31:26 <Cale> and then you can do   cd `locate foo | nth 5`
08:31:32 <neologism> thats what awk is for
08:31:44 <Cale> it doesn't matter how it's implemented
08:31:51 <neologism> of course it does
08:31:54 <Cale> just that it has a short name
08:32:01 <shapr> it should be in HASKELL!
08:32:19 * shapr waves the flag of fanaticism!
08:32:50 <shapr> then again...
08:32:57 <saynte> shapr is off his meds... ;)
08:33:01 <shapr> :-P
08:33:04 <Cale> I figured that since we were using the shell, the most natural thing would be to write a shell script like "head -n $1 | tail -n 1"
08:33:08 <neologism> drop (n - 1) $ take n :)
08:34:59 <shapr> saynte: I'm far more entertaining when off my meds, but I don't get much code written then.
08:35:17 <saynte> shapr: so this is a med-free sunday?
08:35:59 <saynte> then back to the med-loaded grind on monday? :)
08:36:15 <shapr> nah, actually I'm working.
08:36:32 <shapr> I've been trying a day-on day-off pattern lately, seems to make for a nice balance.
08:37:13 <shapr> cool, GFS has been open sourced. Anyone know if it's better than NFS/SFS/etc?
08:37:42 <neologism> isnt it something totally different to nfs?
08:37:48 <neologism> (dunno what sfs is)
08:37:53 <thebug> it's a cluster-style fs iirc
08:37:57 <neologism> yes
08:38:01 <neologism> but nfs isnt ;)
08:38:06 <thebug> so completely unlike nfs
08:38:11 <neologism> yes ;)
08:38:17 <thebug> other than the networked part, obviously :)
08:38:37 <shapr> I'd like to try something like that with Haskell
08:38:46 <neologism> in fact difference between nfs and gfs is just one letter!
08:38:53 <neologism> so it must be pretty the same :)
08:38:55 <shapr> Erlang has the totally distributed database, mnesia
08:39:38 <shapr> I wonder what a 'distributed' framework would look like, something that let you write a distributed/synchronized/failsafe database/filesystem/etc
08:40:05 <shapr> it'd probably look like a speedy darcs with some sort of push capability
08:40:37 <shapr> seems like darcs, gfs, and gnutella-style p2p services are all heading in the same direction
08:40:47 <Cale> import System 
08:40:47 <Cale> main = do
08:40:47 <Cale>     [n] <- getArgs
08:40:47 <Cale>     x <- getContents
08:40:47 <Cale>     putStrLn (lines x !! read n)
08:41:32 * shapr hugs Cale 
08:41:48 * Cale ghci shapr
08:41:54 * shapr laughs!
08:42:26 <saynte> man these one punny one liners will be the death of me.
08:45:59 <shapr> Cale: I assume that's GPL licensed? :-)
08:53:12 <Cale> that code?
08:53:15 <Cale> sure
08:54:45 <Cale> It's whatever license you'd like it to be, because I don't want to think about it.
08:57:37 <desrt> good morning scott, cale, shae..
08:57:58 <shapr> g'mornin desrt 
08:58:10 <saynte> hey desrt, how're you feeling?
08:58:15 <desrt> better.
08:58:27 <desrt> almost perfect.  not quite.
08:58:38 <desrt> radiohead helps :)
08:58:48 <saynte> helps you fall asleep ;)
08:58:54 <desrt> this is the bends
08:59:06 <desrt> hahah
08:59:11 <desrt> ironically, (nice dream) just came on :)
08:59:24 <desrt> this is serious sleep material
09:01:12 <desrt> scott; are you able to vote in hamilton?
09:01:27 <desrt> or do you have to mail a ballot north?
09:01:32 <saynte> desrt: i think i can vote here
09:02:01 <saynte> desrt: they sent me something last election regarding voting, like telling me where to go, so i assume i'm good to vote here
09:02:18 <desrt> you're voting, right?
09:02:33 <saynte> yep, i suuure am, are you?
09:02:40 <desrt> ya.
09:02:43 <desrt> by a slim margin :)
09:03:07 <saynte> hehe, not impressed with out choices?
09:03:13 <saynte> out=our
09:04:00 <desrt> no.  i'm decided who i am voting for very strongly
09:04:05 <desrt> i almost didn't get to vote, though :)
09:04:32 <saynte> oh really?? why, you've lived here quite a while?
09:04:35 <desrt> i'm a DRO
09:04:42 <desrt> so i'm working the entire time that the polls are open
09:04:49 <saynte> DRO ?
09:05:00 <desrt> so i can't go and vote at my normal poll... so i have to get a transfer certificate to vote at my new poll
09:05:05 <desrt> deputy returning officer
09:05:18 <saynte> ohhhhh gotcha, there is prevoting too isn't there?
09:05:23 <desrt> ya
09:05:31 <desrt> but they called me on friday and were like "want a job?"
09:05:40 <desrt> and the last prevote day was monday
09:06:18 <desrt> it was pretty rad.... we went to this training session
09:06:24 <saynte> hehe awesome. 
09:06:28 <desrt> and i asked a lot of questions... pretty dumb ones, i thought
09:06:44 <desrt> but the instructor guy was all like "this guy knows what he's talking about... make him a dro."
09:06:49 <saynte> well you know what they say, the only dumb question is the unasked
09:06:56 <desrt> correct!
09:07:08 <desrt> sometimes i think some of our professors sort of wished i shut up more :)
09:07:34 <saynte> haha, well it just sidetracks the lesson at times
09:07:40 <desrt> nod.
09:07:48 <desrt> hahah like wassyng
09:07:48 <saynte> and some of them are just a-holes ;)
09:07:49 <Cale> There was this guy in the Groups class last term that became well known for his stupid questions.
09:08:04 <saynte> haha but wassyng was so easy to side-track, anyone could do that ;)
09:08:07 <saynte> hehe
09:08:19 <desrt> cale; one day (toward the middle/end of the term) i asked wassyng 'so... who is this parnas guy, anyway?'
09:08:56 <desrt> and he responded with "hah.  i know you're trying to sidetrack me now and i won't fall for it"
09:09:02 <desrt> but ended up on a 15-minute tangent anyway
09:09:16 <Cale> heh
09:09:25 <saynte> haha yeah, there were some lecture-long side-tracks too, those were good.
09:09:34 <desrt> ya
09:09:38 <desrt> ask a question about darlington
09:09:45 <desrt> and that class was basically over
09:09:48 <saynte> haah
09:10:00 <desrt> but it was all good
09:10:02 <desrt> we learned a lot that way
09:10:09 <saynte> yeah, wassyng was the man
09:10:16 <desrt> and we all did quite fine on the final :)
09:10:19 <saynte> as well as ned, ned was super. funniest guy ever.
09:10:26 <desrt> ya.  ned is funny :)
09:10:36 <desrt> sharaez is working with him this summer
09:10:58 <saynte> really? cool, i saw him in the no frills one time, but forgot to ask what he was up to
09:11:39 <desrt> i love when he brought the final exam to class that day and someone asked "what if i were to just steal it..."
09:11:50 <desrt> and ned's all like "welll.... i wouldn't recommend it... i'm a pretty big guy"
09:12:04 <saynte> haha
09:12:08 <desrt> just the way he said it
09:12:46 <saynte> yeah, he has a certain way about him that's just funny. someone will ask if some certain thing would work, and he'll put on a big smile, nod, and say "nooo, i think that  would fail quite a lot" or something like that.
09:13:07 <desrt> he's understated
09:13:19 <saynte> truly
09:13:36 <desrt> he's like the opposite of wassyng/leduc
09:13:45 <desrt> wassyng will always find a way to make what you said sound right
09:13:50 <saynte> haha yeah
09:13:52 <desrt> leduc will always find a way to make what you said sound wrong
09:14:14 <saynte> nedialkov will always find a way to make what you said sound confusing
09:14:20 <desrt> heh.
09:14:40 <desrt> you know.  we rather lucked out.  we got a pretty good set of profs this year
09:14:53 <saynte> i thought so too, i didn't expect a lot of good ones.
09:15:15 <desrt> particularly 2nd term
09:15:25 <desrt> although... that could be because i wasn't around much for first term :)
09:16:06 <Cale> You realise, of course, that there are about 80 people in this channel who don't have the context of this discussion :)
09:16:08 <saynte> hah, yeah. well first term kahl was good
09:16:25 <desrt> cale; that's fine.  scott and i have the context :)
09:16:27 <saynte> Cale: well there are 2 people who do, that's pretty good. it's not zero! ;)
09:16:51 <desrt> plus.  you know kahl
09:16:57 <desrt> so it's slightly more than 2 :)
09:17:24 <desrt> saynte; now... earlier.. i just want to make sure
09:17:27 <desrt> were you making fun of radiohead?
09:17:43 <saynte> haha only slightly, i'm not a fan, but i don't have a problem with their music.
09:18:05 <desrt> crap.  my sisters are home.  sigh.
09:18:22 <Cale> I'm just one to stray on the side of staying on topic in a channel. :)
09:18:41 <desrt> saynte; kahl sure knows his haskell, eh?
09:18:51 <desrt> (see?  on topic.)
09:18:52 <desrt> :)
09:18:54 <saynte> desrt: i get that impression, knows more than me that's for sure ;)
09:19:24 <saynte> sisters = bad?
09:19:31 <desrt> loud and obnoxious
09:20:04 <saynte> ahhh, not a good combination
09:20:33 <desrt> one of them is babysitting this evil kid for the summer
09:20:40 <desrt> and they just all went to a park... but came home >:|
09:20:57 <saynte> including the evil child?
09:21:03 <desrt> right.
09:21:13 <desrt> example
09:21:21 <desrt> i have a great view of the backyard from where i currently am
09:21:36 <desrt> the kid just went outside and found dog poop and jumped all over it and kicked it around
09:21:50 <saynte> hey that kid's got moxy
09:21:58 <desrt> that kid's got something
09:22:12 <desrt> my sister already yelled at him once for it as she was cleaning it off his shoes
09:23:02 <desrt> oh.  and he pulls hair :)
09:23:10 <desrt> (and just did)
09:23:12 <saynte> hehe poop is the universal comdic element
09:23:16 <saynte> haha, what a brat
09:23:37 <desrt> i sort of hope my sister gives up
09:24:06 <saynte> and stuffs him down the well for lassie to find?
09:24:17 <desrt> we're lacking a well
09:24:30 <saynte> sewer?
09:25:10 <saynte> better not, i don't know if lassie's contract covers sewers.
09:25:12 <desrt> i think that what you're describing might be illegal
09:25:44 <saynte> pff you and your 'legal'
09:28:05 <desrt> ya.  crazy me not killing a kid.
09:28:42 <saynte> it wouldn't *kill* him, i mean there's more poop down there than on the lawn, i bet he'd have a blast.
09:29:38 <desrt> kitty...kitty...
09:29:51 <saynte> btw, i nicknamed your g5 work stations "operation extreme redundancy" :)
09:30:00 <desrt> hahah
09:30:10 <desrt> the xserves are coming in next week, it appears
09:30:31 <saynte> really for true? or is this like before?
09:30:40 <desrt> who knows :)
09:30:47 <saynte> ahh the mystery of life!
09:30:58 <desrt> the many many mysteries
09:32:14 <saynte> so for which portion of the gogonut are the xserves for?
09:32:36 <shapr> cute nickname
09:33:24 <saynte> it's my guess that the whole project is just for enhancing the ability of computers to play 'go'
09:46:11 <desrt> saynte; that would be a noble goal :)
09:46:25 <desrt> we've yet to find a computer that can put cale in his place
09:46:44 <saynte> haha, cale is really good at it eh?
09:46:51 <desrt> no.... not really
09:46:57 <thebug> go is an excellent game :)
09:46:59 <desrt> it's just that all computer algorithms work as follows:
09:47:08 <desrt> make_move( movenumber )
09:47:09 <desrt> {
09:47:16 <desrt>   if( movenumber < 20 )
09:47:26 <desrt>     place_stone_randomly();
09:47:31 <desrt>     movenumber++;
09:47:33 <desrt>   else
09:47:38 <desrt>     resign();
09:47:38 <desrt> }
09:47:40 <saynte> hehe
09:48:07 <firefly_> go is extremely hard - the search tree explodes much faster than in chess.
09:48:47 <desrt> firefly; it *is* quite good at determining favourable board position, however
09:49:06 <Cale> hm?
09:49:16 <Cale> No, that's what's so hard
09:49:24 <vegai> most Go AIs can beat _my_ ass easily, though
09:49:31 <desrt> cale; then how is it able to resign so effectively? :)
09:49:32 <vegai> so they are not at all worthless
09:50:03 <Cale> Well, it can evaluate its eyespace, but it will often drag things out quite a bit before realising that there's no hope.
09:50:16 <firefly_> how good is the best go program?  Around 5 kyo?
09:50:24 <desrt> kyo?
09:50:26 <desrt> kyo rules.
09:50:29 <Cale> kyu
09:50:33 <firefly_> how good is the best go program?  Around 5 kyu?
09:50:44 <saynte> we've reached a new level of computing when we've built despair into our AIs.
09:50:47 <firefly_> I usually make that mistake, also in speech :(
09:50:48 <desrt> oh yes... kyu.. the kick yourass unit
09:50:54 <Cale> Perhaps now. I thought they were around 7-8 actually.
09:51:09 <Cale> desrt: no, more kyu is worse
09:51:28 <desrt> Cale; hmm.
09:51:36 <Cale> It's like negative skill :)
09:51:38 <firefly_> I can easily write a go program that has 20 kyu ;)
09:51:38 <vegai> yes, kyus go from high to low
09:51:43 <vegai> dans from low to high
09:51:44 <desrt> can you have -ve kyu?
09:51:53 <vegai> after 1.kyu comes 1. dan
09:52:04 <desrt> ah
09:52:09 <Cale> dan is positive skill :)
09:52:34 <desrt> and 1=1 and is neutral?
09:52:41 <Cale> no
09:52:45 <Cale> there's just a missing 0
09:52:52 <desrt> 1=0?
09:53:08 <desrt> or where 0 kyu would be you just say 0 dan instead?
09:53:10 <firefly_> no, just not there.
09:53:26 <vegai> after 1.kyu comes 1. dan, period ;)
09:53:29 <desrt> eh. i don't really care too much :)
09:53:33 <desrt> oh
09:53:35 <desrt> ok.
09:53:48 <firefly_> the scale is 20,19,...,3,2,1 kyu followed by 1,2,3,... dan.
09:54:02 <vegai> oh, go starts at 20.?
09:54:08 <Cale> 30
09:54:09 <desrt> so 20 kyu is often abbreviated as 'desrt'?
09:54:10 <firefly_> 30?
09:54:13 <desrt> s/20/30/
09:54:13 <Cale> yeah
09:54:19 <vegai> 30? Wow. Lots'o'levels there
09:54:26 <Cale> people start out around 30 kyu after playing a couple games
09:54:27 <vegai> with martial arts, it usually starts with 6. or 9.
09:54:34 <desrt> vegai; if you've seen me play you'd understand why there needs to be 30 levels of suck
09:54:43 <vegai> heh
09:55:09 <vegai> is go a martial art?
09:55:11 <desrt> i play 3 stones against cale on a 9x9 board and get slaughtered
09:55:59 <desrt> cale; i'm going to start taking you up on games of go more often
09:56:05 <desrt> there's no way to get better if you don't play
09:56:07 <Cale> yay :)
09:56:18 <desrt> you need to teach me stuff though
09:56:22 <Cale> sure
09:56:34 <Cale> download kgs if you haven't already
09:56:47 <Cale> well, cgoban 2, really
09:56:51 <desrt> unless it's based on cocoa or gtk i'm unlikely to install it :)
09:57:06 <Cale> It's a java swing app.
09:57:33 <Cale> but it's probably the best go client
09:57:51 <desrt> hm
09:57:54 <desrt> will it work?
09:58:12 <Cale> It will if you have java installed.
09:58:23 <desrt> ok
09:58:24 <desrt> it's running
09:58:30 <desrt> but there's no "play against computer" button
09:58:37 <Cale> connect to kgs
09:58:44 <desrt> hm
09:58:52 <desrt> can i play with 9x9 at first?
09:58:55 <desrt> or does it only do 19x19?
09:59:12 <Cale> it does any size from 3x3 to 38x38
09:59:20 <desrt> 3x3 must be pretty boring
09:59:21 <thebug> (!) 38x38 (!)
09:59:30 <thebug> Olympic Go :)
09:59:42 <Cale> I had a fast 37x37 game at one point, and it took 5 hours.
09:59:53 <desrt> k
09:59:54 <desrt> i'm in
09:59:54 <thebug> I've never seen a 38x38 IRL
10:00:54 <desrt> hmm
10:01:05 <desrt> it says you disconnected, cale
10:01:07 <Cale> Sorry, accidentally quit :)
10:02:50 <Cale> nice, I appear to be massively lagged to kgs
10:02:59 <Cale> that or something is messed up
10:03:02 <desrt> shame this isn't a fps
10:03:19 <desrt> i'm waiting in the game, ok?
10:03:41 <Cale> grr
10:03:43 <desrt> any way to resize the board?
10:03:52 <desrt> oh.  there goes
10:04:05 <Cale> I play a stone and my client freezes.
10:04:09 <desrt> huh.
10:04:10 <Cale> this is unusual
11:07:52 <palomer> haskore has little to do with midi!
11:14:12 <vegai> yes, somewhat
11:22:54 <shapr> palomer: dude, get with the century, use MP4
11:24:54 <palomer> you're not being serious, right?
11:25:13 <palomer> anyways, I want to do midi input and output
11:26:02 <shapr> haskore can do midi input and output
11:26:16 <palomer> on all platforms?
11:26:19 <andersca> heyhey shapr
11:26:21 <palomer> can it query devices?
11:26:50 <shapr> it generates a .mid file
11:27:01 <palomer> that's not midi input/output!
11:27:12 <shapr> or csound (which is a large subset of mp4)
11:27:40 <shapr> hej andersca, wassup?
11:28:24 <shapr> andersca: how's Norway?
11:28:48 <andersca> shapr: expensive :)
11:28:57 <shapr> palomer: so write it
11:29:57 <palomer> shapr: that's really, really hard
11:30:18 <palomer> java is the only cross platform language that does it at the moment
11:31:24 <shapr> palomer: ok?
11:31:47 <palomer> ok.
11:32:02 <palomer> and im not a fan of java
11:32:07 <shapr> so, fix it?
11:32:31 <palomer> midi is _not_ trivial
11:32:38 <palomer> I implemented midi only on linux for C++
11:32:41 <palomer> what a pain in the butt
11:33:38 <shapr> Linux isn't trivial either.
11:34:38 <shapr> I work on things while I have the energy and interest, and try to end up with code that does something useful or interesting in the end.
11:35:08 <shapr> g'day gp 
11:40:47 <shapr> mailman: looking for RFC2822 libraries in Haskell?
11:41:15 <mailman> not really, I think
11:41:25 <shapr> how can we help you?
11:41:48 <mailman> first, what is that RFG2822 libraries
11:42:03 <shapr> it's email parsing
11:42:18 <mailman> ahh, nice
11:43:04 <mailman> second, 
11:43:11 <shapr> seems to fit your nickname
11:43:28 <mailman> :)
11:43:33 <mailman> yes
11:43:35 <shapr> are you learning Haskell?
11:43:38 <mailman> yes
11:43:41 <mailman> I'm a newby
11:43:43 <shapr> cool!
11:43:49 <shapr> Haskell is a fun language!
11:44:12 <mailman> you're right
11:44:50 <mailman> It's funnier than C
11:44:52 <mailman> at least
11:45:05 <mailman> is more focus in the problem than in the computer
11:45:13 <mailman> implementation
11:45:16 <shapr> yes, I agree
11:46:02 <mailman> I have a problem
11:46:09 <mailman> with a function
11:46:10 <shapr> maybe I can help
11:46:46 <mailman> inside my function, i use other function output and I compare it to a value
11:47:02 <musasabi> Haskell's makes it hard to hide implementation.
11:47:22 <mailman> If its bigger, equal o smaller I need to do different stuffs
11:47:36 <mailman> I done it with 2 if
11:47:52 <shapr> musasabi: I think monads are the most popular abstraction.
11:48:01 <mailman> hi musasabi
11:48:03 <shapr> mailman: have you tried pattern matching?
11:48:11 <mailman> case?
11:48:29 <shapr> also that
11:49:07 <mailman> I was thinking in using case, but I don't know how to write it
11:49:18 <mailman> what else could I use
11:50:20 <shapr> I can show you how to use case.
11:50:24 <mailman> comparar :: Integer -> Integer -> (Integer,String)
11:50:24 <mailman> comparar dividendo tope = if (divi dividendo [1..tope] == dividendo) then (dividendo,"Perfecto")
11:50:24 <mailman> 			else 
11:50:24 <mailman> 				if (divi dividendo [1..tope] > dividendo) then (dividendo,"Abundante")
11:50:24 <mailman> 				else (dividendo,"Deficiente")
11:50:34 <mailman> that's the function
11:50:44 <shapr> bim x = case x of
11:50:44 <shapr>                1 -> "it's a 1"
11:50:44 <shapr>                2 -> "it's a 2"
11:50:44 <shapr>                _ -> "it's something else"
11:50:56 <musasabi> hello mailman 
11:51:06 <musasabi> shapr: monads are the root of the problem.
11:51:13 <shapr> how so?
11:51:21 <mailman> I'll try it shapr
11:51:32 <musasabi> shapr: they are nontransparent to the surrounding code.
11:51:47 <musasabi> (we have had this discussion already a few times I think)
11:52:10 <shapr> we have?
11:52:18 <shapr> I've been hacking on Python all day long, I must have forgotten.
11:56:19 <musasabi> shapr: It stemms from haskell overusing IO, and thus making the implementation decisions propagate further than they should. 
11:57:14 <musasabi> shapr: Things like code having signatures like foo bar -> IO baz when it could be either foo bar -> baz (with ST) or (Monad m) => foo bar -> baz.
11:57:54 <shapr> what about using :: m baz and liftIO?
11:59:38 <musasabi> shapr: that is one more reason to dislike the current system. It should be lift, not liftIO ;)
11:59:58 <shapr> do you have an improved system in mind?
12:01:29 <musasabi> well making things more polymorphic would help. But it seems to be hard with monads.
12:04:22 <musasabi> From a more generic language perspective I would like to allow assigments as long as they don't break referential transparency.
12:04:23 <shapr> have you tried to refactor the existing system?
12:04:29 <shapr> if you have a prototype that's better, I'd like to try it.
12:04:40 <musasabi> but that is an another thing wholly.
12:04:51 <shapr> mutability is allowed in monads where it can be proven safe
12:05:00 <shapr> that's one of the neat tricks of monads
12:05:32 <musasabi> shapr: well if the mutablity can be trivially transformed into an equivalent functional program it is safe too.
12:07:12 <musasabi> Or rather than assigning binding is the correct term.
12:09:47 <musasabi> shapr: and monads are not the final answer. Uniqueness typing is better for a set of problems.
12:09:50 <shapr> personally, I wonder about switching to arrows as the central abstraction, and using the simplistic Kliesli interface as much as possible
12:10:25 <musasabi> simple polymorphic interfaces are very important.
12:14:28 <mailman> Sorry I bother you with this simple problem,  :) but how do I call my function output inside CASE.
12:14:28 <mailman> Its case (expresion) of
12:14:28 <mailman> 	 1 -> "it's something"
12:14:28 <mailman>  but if it's an output I have to compare ( bam x > x , for example) how I call the output of bam x inside the case to compare
12:15:37 <shapr> something like 'case (x > y) of True -> "x is bigger"; False -> "y is bigger"; _ -> "we should never get here!"' ?
12:15:54 <shapr> you could call your function in the case
12:16:02 <shapr> case (bam x > y) of
12:17:30 <mailman> I understand
12:17:37 <mailman> if its true
12:17:43 <mailman> i put an answer
12:17:55 <mailman> else
12:18:02 <mailman> i put another answer
12:18:28 <mailman> but in the case false, the expression could be equal or smaller
12:18:35 <mailman> am I right?
12:18:39 <shapr> yes
12:19:40 <shapr> mailman: so, how do you give three different answers? :-)
12:22:03 <mailman> yes
12:22:19 <mailman> how do I do that?
12:22:49 <shapr> can you do it with one case statement?
12:23:33 <mailman> I don't know
12:23:57 <shapr> can you get three different results from (x > y) ?
12:26:14 <shapr> mailman: have you used guards in Haskell?
12:27:10 <mailman> nop
12:27:26 <Cale> you could use compare
12:27:29 <shapr> ok, we'll stick with case
12:27:48 <mailman> ok
12:27:56 <shapr> @type compare
12:27:57 <lambdabot> compare :: forall a. (Ord a) => a -> a -> Ordering
12:28:03 <shapr> oh, that's nice
12:28:11 <Cale> compare x y is either LT, GT, or EQ depending on whether x is less than, greater than, or equal to y.
12:29:03 <mailman> And I put that on Case
12:30:23 <Cale> case x `compare` y of
12:30:30 <Cale>   LT -> ...
12:30:35 <Cale>   GT -> ...
12:30:40 <maihem> can lambdabot show a data definition (above, shapr used @type compare, is there a @data Ordering or some such?
12:30:52 <Cale> it would be nice :)
12:31:00 <shapr> @info Ord
12:31:01 <mailman> thank you
12:31:02 <lambdabot> -- Ord is a class
12:31:02 <lambdabot> class (Eq a) => Ord a where {
12:31:02 <lambdabot>     compare :: a -> a -> Ordering {- has default method -};
12:31:02 <lambdabot>     (<=) :: a -> a -> Bool {- has default method -};
12:31:02 <lambdabot>     (>) :: a -> a -> Bool {- has default method -};
12:31:02 <lambdabot>     (>=) :: a -> a -> Bool {- has default method -};
12:31:04 <lambdabot>     (<) :: a -> a -> Bool {- has default method -};
12:31:06 <lambdabot>     min :: a -> a -> a {- has default method -};
12:31:08 <lambdabot>     max :: a -> a -> a {- has default method -};
12:31:15 <shapr> thank you Mr. Data!
12:31:20 <shapr> that was too much info
12:31:23 <Cale> @info Ordering
12:31:24 <maihem> @info Ordering
12:31:24 <lambdabot> -- Ordering is a type constructor
12:31:24 <lambdabot> data Ordering = LT | EQ | GT
12:31:26 <lambdabot> -- Ordering is a type constructor
12:31:26 <lambdabot> data Ordering = LT | EQ | GT
12:31:31 <maihem> very cool
12:31:43 <maihem> @info compare
12:31:44 <vegai> works on private too
12:31:44 <lambdabot> -- compare is a method in class Ord
12:31:44 <lambdabot> compare :: forall a. (Ord a) => a -> a -> Ordering
12:31:50 <Cale> a nullary type constructor
12:35:24 <mailman> Thank you all for your help, I'll try them
12:35:25 <musasabi> btw http://www.nomaware.com/monads/html/index.html seems like a very readable.
12:35:38 <mailman> See you later folks
12:35:42 <shapr> see you!
12:35:52 <shapr> you can come back and ask more questions anytime
12:36:04 <mailman> I'll do
12:36:05 <mailman> :)
12:36:07 <musasabi> (and not linked from haskell.org)
12:36:12 <Cale> musasabi: yeah, it's a pretty good introduction to monads
12:37:43 <musasabi> the part III is the most valuable one, as those things are usually not in elementary tutorials and papers are not meant to be tutorials.
13:00:18 <ShaminoDC|FBK> i wrote a program and its working fine in winhugs but its not working with ghci any ideas ?
13:01:10 <shapr> how does it not work?
13:01:28 <shapr> we need details!
13:02:51 <shapr> hej Marvin-- 
13:02:57 <Marvin--> evening
13:03:53 <ShaminoDC|FBK> its says cant find module **** but the path to the module is ok
13:04:02 <ShaminoDC|FBK> and its working with winhugs
13:05:52 <ShaminoDC|FBK> well let me ask in an other way : where to have imported pakages have to be located when i m using ghci ?
13:05:54 <shapr> can you load the module itself in ghci?
13:06:31 <shapr> you can use :set -i/home/shamino/haskell/ 
13:06:38 <shapr> then ghci will see Foo.hs in that dir
13:07:07 <ShaminoDC|FBK> ill try that
13:22:42 <shapr> greetings karingo
13:26:44 <Marvin--> ouch, poor Denmark
13:38:09 <firefly_> @state
13:39:33 <shapr> @state Nebraska
13:39:38 <shapr> @hello
13:39:38 <lambdabot> Hello world. 
13:41:41 <firefly_> @state
13:41:41 <lambdabot> Nebraska
13:41:44 <firefly_> :)
13:45:09 * shapr grins
13:50:23 <firefly_> Marvin--: yeah, it was a bit sad.  Three-nil!
14:05:06 <musasabi> btw why do haskell collections not have a unified interface?
14:05:08 <Igloo> Hmm, I think I'm missing something obvious on https://spoj.sphere.pl:444/?a=problem&pcode=CMEXPR
14:05:18 <Riastradh> See Edison, musasabi.
14:05:36 <Igloo> Mainly because no-one can decide what it should be
14:06:04 <musasabi> Riastradh: I know that it exists, I am wondering why the standard library is so ugly.
14:06:48 <musasabi> It seems like "invent interface from zero for each new type".
14:06:54 <Riastradh> I know exactly what it should be.  You guys are all just wrong.
14:06:58 * Riastradh ducks.
14:08:27 <musasabi> Well there is certainly room to make some things simpler.
14:10:45 <musasabi> e.g. why do the refs have separate interfaces?
14:11:47 <musasabi> Data.IORef Data.STRef GHC.STRef...
14:15:14 <musasabi> Why not Data.Ref: newSTRef, newIORef, newWeakIORef, readRef, writeRef, modifyRef, ...
15:26:36 <Heffalump> musasabi: you can make a multi-parameter type class that pulls them together, if you want.
15:33:06 <Marvin--> oh my god, I thought I cleaned out the spam folder just recently
15:33:37 <Igloo> Anyone familiar qith QC about?
15:33:49 <Marvin--> forwarding all mail for both of my two most widely used mail accounts to my gmail account made me realize how much spam I get
15:34:03 <Marvin--> Igloo: yeah?
15:34:48 <Igloo> Can you explain the "liftM arbitrary" in the Arbitrary instance for Tree on http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html please?
15:35:34 <Igloo> Hmm, and the next line doesn't look like it'll even type check. Is it missing Leaf and Branch respectively?
15:35:47 <Marvin--> err, yes, that looks like a typo
15:36:22 <Igloo> OK, ta
15:36:31 <Marvin--> should be liftM Leaf and liftM2 Branch just like in the non-solution above
15:37:46 <Marvin--> I really wonder why my Strakt address gets so much spam
15:40:13 <Igloo> Is there an easy way to see a generated thing?
15:42:21 <Marvin--> a "generated thing"?
15:43:21 <Igloo> I've just made an instance to tell QC how to generate things, right? I want to see a couple of the things it generates to see if it looks sane
15:47:12 <Marvin--> Ah, the generate function should be exported
15:47:50 <Marvin--> generate :: Int -> StdGen -> Gen a -> a
15:48:14 <Igloo> Ta
16:03:39 <Igloo> Yay
16:03:50 * Igloo solves a real problem with QC
16:04:07 <Igloo> Well, the real problem is that I'm a muppet, and it didn't solve that. Just one instance of it.
16:06:27 <Marvin--> heh
16:06:36 <Heffalump> I used it to find a bug during the ICFP contest. The fact that Andres had already found the bug himself by the time I did is irrelevant.
16:07:23 <Igloo> :-)
16:07:45 <Igloo> I'm sure you(we)'ll get faster if we use it more
16:10:48 <Heffalump> yeah.
19:20:09 * stepcut is requesting a price guide for advertising in sky mall
