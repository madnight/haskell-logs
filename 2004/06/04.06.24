00:45:17 <andersca> @arr
00:45:58 <andersca> @arr
00:45:58 <lambdabot> Drink up, me hearties
00:51:09 <vegai> 'clean' is a horrible name for a programming language
00:51:52 <musasabi> Why does haskell probhibit mutation of variables. Why not just require functions to be referentially transparent?
00:52:35 <vegai> can functions be that if variables are mutable?
00:52:47 <musasabi> vegai: of course.
00:54:15 <musasabi> vegai: just make it nonaliased local variables ;)
00:55:28 <musasabi> like running a ST inside the func, only without the cruft. (evaluation order would need to be taken into account however)
00:59:20 <shapr> musasabi: I think it's because you know everything will get simpler
00:59:35 <shapr> and that makes certain properties provable
00:59:55 <shapr> at least, it makes it easier for me to think about closures as poor man's objects that way
01:00:26 <shapr> when you create an object instance, the possible 'future' of that object is unlimited, each variable can have its value changed
01:01:16 <shapr> with a closure of (foo 1) (from foo x y z = x + y + z for example) I know that y or z can be filled in, and in any order, but no more can happen
01:01:34 <shapr> musasabi: what do you think? sounds sensible?
01:03:57 <musasabi> it sounds sensible from a mathematical point of view
01:04:30 <musasabi> The problem is that it is not a very practical point of view
01:04:54 <musasabi> Of course side effects are ugly when looking at a language from a formal perspective.
01:05:40 <musasabi> but then again we don't have a simple beautifull (useless) monomorphic type system either.
01:06:04 <kosmikus> why would monomorphic be beautiful?
01:06:04 <shapr> god morgon bringert!
01:06:44 <bringert> good morning shapr
01:06:46 <musasabi> kosmikus: because it makes reasoning easier and the models more simple.
01:06:51 <shapr> musasabi: also, immutability makes GC easier
01:07:12 <musasabi> shapr: but the GC has less work with mutablity.
01:08:18 <musasabi> and since we are talking about mutating local variables this would occur most likely in leaf functions which would make the changes in younger generations and thus not create many nasty references to younger generations.
01:50:17 <shapr> aha, I think I found out where I can strip the PRNG seed out a QuickCheck generator
01:50:23 <shapr> but passing it back in a Result will be ugly
01:58:52 <andersca> unsafePerformQuickCheck
01:58:56 <shapr> haha
02:01:29 <det> at what point exactly does Haskell drive one nuts?
02:02:03 <shapr> det: when you get a C++ job after doing Haskell for a few months.
02:02:12 <shapr> the pain, the inhumanity!
02:02:15 <det> I see!
02:02:23 <det> Does anyone use irssi here?
02:02:44 <mwb> Yes.
02:03:23 <shapr> hiya mwb, are you a Haskell programmer?
02:03:37 <shapr> yay, QuickCheck displays the size and seed for a failing case!
02:03:55 <shapr> now to add saving the seed, and retesting with the seed
02:05:07 <det> ahh, nm figured it out
02:09:26 <shapr> @yow !
02:09:26 <lambdabot> I just heard the SEVENTIES were over!!  And I was just getting in touch
02:09:26 <lambdabot>  with my LEISURE SUIT!!
02:10:09 <shapr> wow, QuickCheck is elegant code
02:19:22 <vegai> hmm
02:19:23 <vegai> @yow
02:19:24 <lambdabot> I own seven-eighths of all the artists in downtown Burbank!
02:19:28 <vegai> @yow
02:19:30 <lambdabot> WHY are we missing KOJAK?
02:20:47 <andersca> @arr
02:20:47 <lambdabot> This is the END for you, you gutter-crawling cur!
02:33:22 <vegai> hmh, seems like an asynchronous event thingie can't be done without going imperative
02:34:17 <vegai> or complex in some other way
02:34:43 <dennisb> is it different from any other IO?
02:35:01 <shapr> @arr
02:35:01 <lambdabot> Aye
02:35:17 <shapr> vegai: what about continuations?
02:51:03 * vegai refreshes his memory.
02:52:55 <shapr> gutentag TheHunter
02:53:23 <TheHunter> Guten Tag, shapr
02:53:35 <shapr> how's code?
02:54:05 <TheHunter> it's ok, i'm not coding much
02:54:58 <TheHunter> i'm actually more interested in theoretical concepts and i don't have the time
03:42:09 <blackdog> det: still want a gmail account?
03:42:44 <shapr> anyone here who has hacked on QuickCheck internals?
03:43:05 <blackdog> shapr: i'm going to learn how to use xemacs a bit more expertly tonight - i've got access to the o'reilly site, is there a better resource?
03:43:16 <shapr> emacswiki.org is the best
03:43:18 <shapr> and #emacs
03:43:22 <blackdog> shapr: ooh, integration with HUnit? Luvverly...
03:43:30 <shapr> and EmacsNiftyTricks page on emacswiki.org
03:43:36 <shapr> blackdog: workin on it, sort of
03:43:55 <blackdog> okeydoke. no particular goals, just want to learn cool stuff.
03:44:09 <shapr> I'm trying to add the ability to QC to a) save a failed generated test case b) retest with those cases
03:44:54 <shapr> so you will be able to use QC like HUnit
03:45:17 <blackdog> ok. would you still run it within QC, or just generate HUnit-style tests?
03:45:37 <shapr> run within QC, so that if all your tests pass, QC can try to find some that don't
03:46:08 <shapr> also, this gives you test-driven-development, because QC can generate a test case from a property
03:48:39 <blackdog> Is QC fast enough to run on every compile?
03:48:44 <shapr> yup
03:48:48 <shapr> that's the idea :-)
03:49:05 <shapr> wire the unit tests into every --make
03:49:56 <andersca> in d-bus we have a make check
03:50:02 <blackdog> Ok. I was under the impression that you set it running for hours to try to find some hideous corner case. :)
03:50:02 <andersca> it's pretty good, but it takes a long while to run
03:50:17 <shapr> QC usually finds failing case *quickly*
03:50:32 <shapr> of course, it depends on your properties and your generators
03:50:36 <shapr> g'mornin Iter 
03:51:07 <shapr> blackdog: imho, QC > HUnit
03:51:28 <Iter> evening shapr.  how goes things?
03:51:49 <shapr> hacking on QuickCheck, trying to add the ability to save and retest on next run with failed cases
03:52:00 <Iter> ahh. cool.
03:52:38 <Iter> yes that would be very useful.
03:58:11 <det> blackdog: sure!
03:58:25 <blackdog> det: email?
03:58:36 <musasabi> Why are there functions like "failIO :: String -> IO a" when "fail :: String -> m a" exists?
03:59:17 <shapr> @index fail
03:59:18 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
03:59:18 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
03:59:18 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
03:59:22 <shapr> @index failIO
03:59:23 <lambdabot> GHC.IOBase
03:59:38 <shapr> I think maybe they have different purposes?
04:00:11 <shapr> oh, I have an idea, I want lambdabot to return an url to online docs for that name
04:01:09 <musasabi> shapr: so how are they different? FailIO seems just like fail except only for IO...
04:02:35 <shapr> ah, they are the same thing
04:02:48 <shapr> fail is a method of the Monad typeclass, and failIO is the implementation for the IO monad
04:02:53 <shapr> instance  Monad IO  where
04:02:58 <shapr>     fail s	= failIO s
04:03:02 <shapr> failIO :: String -> IO a
04:03:03 <shapr> failIO s = ioError (userError s)
04:04:47 <musasabi> so why is it exported? 
04:05:11 <shapr> I dunno
04:05:57 <musasabi> When looking at the api, dozens of useless functions make a newbie wonder, which should be used and why do they exist if they are the same...
04:06:14 <shapr> yah, that's a good point
04:08:03 <blackdog> hysterical raisins, perhaps
04:08:56 <det> blackdog: get PM?
04:10:03 <blackdog> yep. sorry, looking in another window. (irssi doesn't seem to notify you particularly visibly.)
04:11:35 <blackdog> det: sent
04:13:12 <det> blackdog: thanks!
04:22:25 <det> blackdog: how do you obain invited to give out?
04:23:55 <det> oh, n/m
04:24:22 <shapr> g'mornin firefly 
06:02:56 <blackdog> det: they send them to you, eventually. I haven't actually got any of my own yet - i asked a friend for an invite for my grilf, and he gave me 6. :)
06:25:56 <shapr> foo!
06:26:04 * shapr fights with QuickCheck
06:42:51 <blackdog> shapr: is emacscodebrowser or speedbar or semantic bovinator worth checking out for hacking haskell?
06:44:39 <shapr> blackdog: yes, I think so
06:44:51 <shapr> speedbar is fine for daily use if you like it
06:44:58 <shapr> ecb and bovinator are more specialized
06:45:07 <blackdog> what, they all are? i noticed a note from you that they overlap a bit
06:46:07 <blackdog> i should probably just practice basic editing before i get into the esoteric stuff.
06:46:21 <shapr> speedbar on the right: http://www.scannedinavian.org/~shae/screenie.png
06:46:37 <shapr> emacscodebrowser screenshot: http://www.scannedinavian.org/~shae/ecb.png
06:46:42 <blackdog> oh no, you're not tricking me into looking at that one again. :)
06:47:01 <shapr> semantic bovinator is an incremental parser generator written in elisp
06:47:17 <shapr> current modes are Java, Python, Erlang, Scheme, elisp, and a few others
06:47:46 <shapr> the ecb.png isn't my standard color-theme :-P
06:47:52 <blackdog> does it take parsers written in other language?
06:47:58 <blackdog> languages, rather.
06:48:12 <blackdog> actually, the ecb one is less hideous than the other
06:49:12 <shapr> @hello
06:49:13 <lambdabot> Hello world. 
06:49:40 <shapr> lambdawar: @hello
06:49:54 <lambdawar> yop yop
06:50:12 <shapr> blackdog: semantic takes a description and generates a parser. the parser is in elisp, and designed to work with the rest of semantic, CEDET, etc
06:50:23 <Lemmih> Lazy warfare?
06:50:57 <shapr> blackdog: semantic and others come from cedet.sf.net. even includes a UML design tool written in elisp, that can spit out Java source for your UML design.
06:51:00 <shapr> sick, eh?
06:55:23 <shapr> nifty, ping6 ff02::1 gets fifteen dupes
06:56:11 <shapr> hiya Arnia
06:56:13 <shapr> ltns
06:57:07 <Arnia> Hey shapr
07:01:25 * shapr tries to figure out how to get a block of IPv6 addresses allocated to him
07:01:52 <Arnia> shapr: Pretend to be a large company specialising in selling a new sort of confectionary called 'Fudgets'
07:02:10 <shapr> that might actually work...
07:03:08 <blackdog> shapr: yeah, that's mildly nauseating. :)
07:03:38 <Igloo> If you have an IPv4 address you already have a load I believe
07:05:05 <firefly> inden   tation i sfun.
07:05:45 <shapr> Igloo: I want something outside of those...
07:06:25 <firefly> entoothificament brings joy
07:08:02 <Igloo> How come?
07:09:18 <shapr> I want my own block of IPv6 addresses that does not require an IPv6 address, I want IPv6 native!
07:09:35 <shapr> Igloo: actually, I have an evil plan to run an ISP
07:12:52 <shapr> doh, the website of wm-data.se fails my browser, and so won't let me in.
07:13:04 <shapr> oh, I can skip past the intro
07:15:57 <blackdog> shapr: I've been half-thinking of becoming a wireless ISP for my apartment. I could finally afford better connectivity. :)
07:16:25 <shapr> yah, I'm thinking something along those same lines
07:17:30 <ozone> blackdog: i've got a spare wireless card if you want one.
07:17:40 <ozone> as in, it's sitting on my desk right now, and i ain't using it ...
07:17:44 <ozone> (and it works fine with linux)
07:22:01 <blackdog> ozone: That'd be good, actually. mad's not got one yet, and i could get rid of the damn blue cord...
07:22:41 <ozone> i'll email you about it
07:24:35 <shapr> hej polli 
07:24:52 <polli> hej shapr! 
07:26:35 <firefly> the way exception handling works in Haskell is... weird, to someone coming from an ML background.
07:26:48 <firefly> How long does it normally take to adjust for foreigners like me?
07:59:58 <Philippa> firefly: I've no idea how long it takes for ML users to adjust. Adjusting from C++ to Maybe/Either didn't take me too long if that's useful, I've not done anything risky in the IO monad yet
08:04:06 <firefly> Maybe is very similar to option (except that it is an instance of the class Monad).
08:04:43 <firefly> I am about to do something quite risky in the IO monad: pipelined HTTP GET over multiple connections, possibly with lazy interleaved i/o.
08:04:46 <ozone> firefly: how does ML exception handling work?
08:04:59 <firefly> First off, we don't have monads.
08:05:11 <ozone> yep, i knew that much :)
08:05:14 <firefly> This forces exception handling to become an integrated part of the language.
08:05:40 <firefly> Every expression can have 'handle <pattern> => exp' tagged on (without the ' of course).
08:05:58 <firefly> You can do standard pattern matching on the exceptions if you like.
08:06:24 <firefly> You can do a catch all with the _ pattern.
08:07:33 <ozone> i see
08:08:11 <firefly> You can also decide to catch an exception and rethrow it:  expr handle exc => raise exc
08:09:00 <firefly> You can carry information around with an exception; it is very much like ordinary value constructors.
08:09:23 <ozone> firefly: have you seen GHC's Control.Exception module?
08:09:34 <firefly> Exceptions are "open", though, in that any module can define new exception constructors.
08:09:36 <ozone> it's not quite the same
08:09:42 <ozone> but it's, well, kinda the same. :}
08:10:07 <firefly> And, let's see, exceptions are generative, but I've forgotten what that really means.
08:10:13 * firefly curses his lack of memory
08:10:38 <firefly> ozone: no, not yet.
08:11:11 <firefly> But this is why it throws me at first to think of catch as a function which then typically gets turned into an operator by a pair of back quotes.
08:11:14 <firefly> It just looks weird.
08:13:28 <ozone> firefly: well, it seems that Control.Exception has a 'handle' function too, and it's similar -- you can pattern match on the exception
08:13:51 <ozone> note that i've never used exceptions in hs before -- just glancing at the docs, which seem to be decent for once
08:17:15 <firefly> ozone: right, it uses a predicate instead of pattern matching.  It is more general but I still think I prefer pattern matching.
08:17:35 <firefly> Sigh, there are just too many things there.
08:18:07 <firefly> Why settle for catch when we can define handle, too?  Same thing but the arguments are swapped.
08:18:51 <firefly> And since catch is a function that catches any exception we need catchJust and handleJust.
08:20:41 <firefly> And then there's a bunch of standard predicates for matching different kinds of exceptions, something to map from one exception to another, dynamic exceptions (so we need catchDyn, throwDyn)... aargg!
08:21:14 <firefly> And the lack of defined evaluation order means we can't look at a piece of code and /know/ which of several exceptions will be thrown at run-time.  It depends.
08:21:37 <firefly> and then there are imprecise exceptions and asynchronous exceptions.
08:21:54 <firefly> Oh, and the catch defined in the prelude is not the same as the one in Control.Exception.
08:21:57 <firefly> Joy.
08:22:01 * firefly rants some more.
08:22:14 <firefly> I wonder how many rants it'll take to learn this language properly?
08:23:15 <firefly> Philippa: oh, and with some ffi thrown in, of course.
08:24:16 <firefly> If I remove -O from the ghc invocations, will my program go /much/ slower and/or use /much/ more memory?  I am getting tired of the time it takes to compile darcs on this 233 MHz laptop.
08:25:53 * JaffaCake works around MS's new IRC blocking policy
08:26:24 <Igloo> Heh
08:28:51 <Igloo> Is it actually targetted at IRC or just a casualty of a more global block?
08:29:11 <JaffaCake> who knows, perhaps somebody just screwed up the firewall config
08:29:43 <JaffaCake> I submitted a bug report, we'll see what happens ;-)
08:31:17 <SyntaxNinja> JaffaCake: you could always log into that sparc of mine and IRC from there ;)
08:31:33 <JaffaCake> hehe, thanks
08:32:03 <JaffaCake> I can do the same from haskell.org, or by SSHing into my home machine too
08:44:17 <firefly> It seems to compile faster without -O.  Still unbearably slow, though.
08:44:28 <firefly> What are your tricks for speeding up compilation?
08:46:00 <firefly> are imports slow?
08:46:48 <Igloo> Are you talking about the compile time when running the tests having committed something or during development?
08:46:55 <firefly> Is there a "project builder" I should know of, which manages recompilations and dependencies?
08:47:05 <firefly> It seems that whatever darcs is using, it recompiles too much.
08:47:23 <firefly> Igloo: during development.  I haven't run a single test yet.
08:47:26 <Igloo> If the latter then modularisation is good as only changed modules, and things that use changed exports from them, will be recompiled
08:47:33 <firefly> (from the test suite, that is)
08:47:49 <neologism> \a -> (a a)
08:47:53 <neologism> what can it be good for?
08:48:08 <neologism> its a nonsense, isnt it?
08:48:35 <Igloo> I think turning optimisation off will help a bit there as less information is in the interface file so the probability of module recompilation being necessary is lower, but Jaffa will be better informed there
08:48:46 <firefly> ok, thanks.
08:49:02 <firefly> I changed GHCFLAGS in the autoconf.mk file to not include the -O.
08:49:05 <JaffaCake> spot on, Igloo
08:49:06 <Igloo> neo: Well, it's not valid Haskell
08:49:15 <neologism> Igloo: I know
08:49:19 <neologism> but if it were
08:49:22 <neologism> what would it do?
08:49:25 <neologism> nothing
08:49:28 <firefly> I ran make, which thought for a while and told there was nothing to recompile.
08:49:36 <Igloo> It would apply its argument to itself
08:49:44 <firefly> Then I touched one of the smaller source files, External.hs, and ran make again.
08:49:44 <Igloo> (\a -> (a a)) id == id
08:49:49 <firefly> It is still running.
08:49:57 <neologism> Igloo: I see it as a recursion
08:50:07 <neologism> aplication of a to a
08:50:16 <neologism> which is forbidden (in this way)
08:50:20 <firefly> So compiling something without -O forces a recompilation of modules depending on the -O version of the first module?
08:50:51 <firefly> Is this because of the intermodule optimisations?
08:51:16 <Igloo> Yes - they become invalid now because the info isn't in the .hi file any more
08:51:30 <Igloo> But in the future, if you leave -O out, things will be recompiled less
08:52:02 <firefly> Good :)
08:52:46 <firefly> I hope ghc checks that only the part of the exported interface that is actually imported has changed, so as to recompile as little as possible.
08:53:10 <Igloo> It'll make feature development and bug fixes faster overall, but you'd probably want -O to find performance problems in the darcs code
08:54:00 <firefly> true, but right now I just need to be able to hack and the only performance problem I am trying to fix is the HTTP one :)
08:55:02 <firefly> Is there a way to make the linker use less memory?  I think that is what is slowing the linker down at the moment.
08:56:15 <Riastradh> Buy more RAM!
08:56:16 <Igloo> -optl--no-keep-memory might be faster if you're running into swap
08:56:26 <Riastradh> It'll make the linker use _relatively_ less memory!
08:56:45 <Igloo> I'd time it to see which is quicker, though
08:57:22 <firefly> Riastradh: for an old laptop?  on my budget?
08:57:31 <firefly> thanks, Igloo.
08:57:38 <Riastradh> Oh, then just get a new laptop.
08:57:55 <firefly> "on my budget?"
08:59:49 <firefly> Fun.  I got a linker error now everything is compiled without -O.
09:00:11 <firefly> Somebody forget to use #ifdef around some Win32 FFI code (send_email)
09:05:16 <basti_> hi
09:09:53 * Lemmih is confused.
09:10:36 * basti_ isn't
09:10:43 <firefly> Lemmih: about what?
09:11:01 <Lemmih> System.exitWith terminates GHCi if it's called after Graphics.UI.GLUT.Begin.mainLoop
09:12:21 <JaffaCake> that sounds bad
09:12:47 <firefly> Does the mainLoop perhaps install some sort of signal handler or something?  And that handler then uses an OS call to terminate, forgetting that it is actually running inside an interpreter that is not supposed to exit?
09:14:32 * Spark now has a 1st class degree
09:14:34 * firefly guesses wildly 
09:14:52 <basti_> but sounds reasonable.
09:14:53 <Spark> heh i did that
09:15:04 <Lemmih> It's kinda annoying...
09:15:13 <basti_> maybe the mainloop exits because an exception occurs?
09:17:04 <Philippa> Spark: cool, 'grats
09:17:17 <Philippa> Don't think I'm gonna get a first at this rate :-(
09:17:33 <basti_> what is a 1st class degree?
09:18:19 <Philippa> UK scheme for breaking down bachelors degrees, ranging from best to worst: 1st, 2:1, 2:2, 3rd
09:18:33 <Philippa> strictly speaking it's the class of honours on the degree
09:18:37 <basti_> i see
09:18:42 <basti_> then, congratulations
09:19:13 <basti_> i thought about some grouping of the education time (like, 2 ys study, 4 ys or something...)
09:39:25 <TheHunter> Hi, Huschi
09:48:29 <Huschi> hi
09:48:47 <Huschi> do you know me?
09:48:58 <TheHunter> i guess so
09:49:38 <Huschi> lass mich raten, du kannst auch deutsch :)
09:49:52 <TheHunter> richtig
09:50:07 <Huschi> jupp, ich weiﬂ auch wer du bist
09:50:22 <Huschi> du hier? wow es gibt doch noch leute mit verstand :)
09:50:37 <TheHunter> was machst du so?
09:50:56 <Huschi> studieren
10:04:52 <SamB> hmm. I wonder if I would have liked ruby if it had had a nice interactive interpreter, with something akin to Python's help() or hugs/ghci's :b/:i/:t
10:08:35 <desrt> :t rules
10:14:18 <Igloo> JaffaCake: Are you still here?
10:27:07 * shapr bOings
10:27:39 <Philippa> 'lo
10:27:46 <shapr> hiya Philippa 
10:27:53 * Philippa is scratching her head trying to read a type system...
10:28:15 <Philippa> largely because I've not got the knack of translating the usual way they're written into a set of algorithmic requirements...
10:28:19 <shapr> I'm trying to wiggle my brain into changing QuickCheck's Gen monad to return the seed value
10:28:27 <shapr> Philippa: oh oh try epigram!
10:29:00 <Philippa> this is the one I need xemacs for?
10:29:05 <shapr> yup, that one
10:29:10 <shapr> it's a really cool interface
10:29:20 <Philippa> well, I *think* I've got it installed...
10:29:59 <Philippa> yup. OK, will take a look then
10:30:25 <Philippa> beats reading spam talking about "Tee-n Fuc<"
10:30:26 <SamB> shapr: does it allow random-access unfreezing yet?
10:33:20 <shapr> SamB: no, not yet
10:33:21 <shapr> I wish
10:33:34 <shapr> the docs say that's high on the list though
10:34:32 <shapr> Philippa: ha, I read that as "Tee minus n applied to F<sub>uc</sub>, partially applied to the (<) operator"
10:35:42 <stepcut> hrm --> No instance for (Typeable ProcessStatus) arising from use of `throwDyn' at ./Nhlab/Arch/Tla.hs:45
10:36:38 <stepcut> is there someway to add 'deriving Typeable' to System.Posix.Process.ProcessStatus without modifying the standard libraries ?
10:37:30 <shapr> you could maybe rewrap it?
10:37:44 <Philippa> shapr: I think you've been coding a little too much :-)
10:37:54 <shapr> Philippa: too many hours of QuickCheck today...
10:38:48 <shapr> I'm still missing some vital part of understanding how this Gen monad works
10:39:09 <stepcut> shapr: hrm, If I understand you correctly, I don't think that would help, since 'deriving Typeable' requires everything "inside" to be an instance of Typeable...
10:39:32 <shapr> oh, good point
10:39:46 <shapr> too bad deriving can't be done after the fact like any other instance
10:40:00 <stepcut> :p
10:40:06 <shapr> I wonder what sort of magic deriving uses...
10:40:11 <shapr> would be nice if it were a function
10:40:27 <shapr> derive Typeable ProcessStatus
10:41:28 <SamB> shapr: wouldn't it be more like $(derive "Typeable" "ProcessStatus")?
10:42:35 <stepcut> well, I guess I can just 'show' the ProcessStatus for now, so that I have a string
10:43:06 <stepcut> but it would be nice to include a ProcessStatus in my exception
10:43:09 <shapr> SamB: sure, that's fine with me
10:43:41 <SamB> or perhaps something involving the word reify
10:46:09 <Philippa> shapr: epigram looks nice
10:46:31 <Philippa> am still working on being able to understand what's actually needed for an "ordinary" code implementation of rules like that though
10:46:45 <Philippa> to put it another way, I wanna know how epigram /works/ :-)
10:51:39 <Philippa> though come to think of it I ought to be able to hack it all up in Prolog
10:51:45 <Philippa> (the type rules, that is)
10:57:14 <Igloo> Philippa: http://research.microsoft.com/Users/simonpj/papers/putting/index.htm might help
10:57:57 <Philippa> thanks
11:00:15 <stepcut> catchDyn never seems to actually catch my exceptions :(
11:14:58 <shapr> hiya thebug, looking for Haskell info?
11:15:52 <thebug> just read FoxtrotUniform's post on haskell on perlmonks.org and I'm trying to figure out how to get some of his examples working in hugs
11:16:00 <thebug> I'm sure I'm doing something stupid
11:16:40 <SyntaxNinja> thebug: got any questions?
11:16:57 <shapr> thebug: which post is that?
11:17:03 <thebug> http://perlmonks.org/index.pl?node_id=369174
11:17:05 <SyntaxNinja> thebug: you usually can't introduce top-level bindings in hugs or ghci, so you should define things in a file and use :load to load the file.
11:17:31 <thebug> so I can't just type something like nats = [0..] and play with nats from there?
11:18:28 <SyntaxNinja> you'll run out of bits if you dot hat
11:18:45 <SyntaxNinja> nope. if you have ghci installed, you can say "let x = [0 ..]"
11:19:03 <SyntaxNinja> and you can say "let nats = foo in {- play with nats -}"
11:19:14 <thebug> that indeed works with ghci :)
11:19:24 <SyntaxNinja> but yeah, a lot of people seem to get caught up with that in hugs, so that's why I mentioned it
11:19:43 <SyntaxNinja> you also can't say "data Foo = Bar" (I don't think...) in the hugs interpreter. you have to load some definitions from a file.
11:19:54 <thebug> strange
11:20:06 <SyntaxNinja> it's neat to see that article on perlmonks.  I'm going to write an article that titled "You don't need to have a PhD in math to do IO in haskell" or something
11:20:09 <thebug> esp. if it's supposed to be interactive
11:20:17 <SyntaxNinja> ppl seem to get caught up on the IO thing.
11:20:36 <SyntaxNinja> thebug: well, you can introduce top-level bindings in the file and then play with them after loading the file.
11:20:48 <musasabi> imho IO is not the problem.
11:20:54 <musasabi> the rest of the monads are.
11:20:56 <SyntaxNinja> if you use emacs, there's a pretty OK haskell-mode where C-c C-l loads the file in hugs.
11:21:01 <thebug> so if I just have a text file, I can dump things like my nats = [0..], :load it, then play with it?
11:21:09 <SyntaxNinja> yeah
11:21:16 <thebug> thanks, that helps a bit
11:21:18 <Igloo> And :e in hugs to edit it
11:21:27 * SyntaxNinja didn't know about :e
11:21:34 <Igloo> Or :r to reload it if you prefer to edit it in another window
11:21:36 <thebug> :? shows :e
11:22:03 <SyntaxNinja> musasabi: well, at least IO is a good introduction to monads, and you can ignore the rest of monads for a while after you learn IO
11:22:28 * thebug would be interested in SyntaxNinja's article :)
11:22:54 <SyntaxNinja> thebug: haskell suffers from a bad reputation when it comes to IO... I've talked to ppl who actually beieve that haskell can't perform IO at all.
11:22:56 <thebug> as an objective, non-PhD endowed individual that is
11:23:04 <musasabi> SyntaxNinja: The problem is that most documentation about combining monads is quite advanced.
11:23:07 <shapr> I don't have a PhD either.
11:23:17 <shapr> but I like Haskell
11:23:17 <SyntaxNinja> musasabi: like what?
11:23:30 <maihem> SyntaxNinja: then you could write a damn good optimising haskell compiler ;)
11:23:48 <SyntaxNinja> maihem: baby steps...
11:23:50 <musasabi> SyntaxNinja: Getting IO to work in a simple way is easy. Combining IO, ST, Maybe, ... is an another story.
11:24:02 <maihem> ?
11:24:25 <SyntaxNinja> maihem: it seems like a big jump from writing an article on basic IO in haskell to writing a good optimizing haskell compiler.
11:24:25 <shapr> maihem: I think he means "walk before run"
11:24:34 <thebug> how would I take this one step further then and make it something I can compile with ghc?
11:24:55 <SyntaxNinja> module Main where\n\nmain = putStrLn "hello world" 
11:25:00 <maihem> no, I mean if haskell's reputation for not being able to do IO was true, you could write a good optimising compiler
11:25:02 <SyntaxNinja> ghc --make Hello.hs -o helloTest
11:25:13 <SyntaxNinja> maihem: ahhhhh. OK :)
11:25:24 <thebug> SyntaxNinja: thank you, that gives me a whole lot more area to play with :)
11:25:36 <SyntaxNinja> thebug: I recommend finding a tutorial, though :)
11:25:47 <SyntaxNinja> and read the manual for hugs or GHC side-by-side w/ the tutorial
11:25:51 <SyntaxNinja> @wiki LearningHaskell
11:25:51 <lambdabot> http://www.haskell.org/hawiki/LearningHaskell
11:26:11 <thebug> I'm reading the "A Gentle Intro to Haskell" tutorial
11:26:13 <SyntaxNinja> maihem: maybe I'll use that joke in my article :)
11:28:27 <shapr> thebug: any other questions?
11:28:55 <thebug> not at the moment, but thanks to everyone for answers to the horrible neophyte questions
11:29:52 <shapr> in my experience, Hal Daume's "Yet Another Haskell Tutorial" is easier to digest than "A Gentle Intro"
11:30:14 * thebug googles that
11:30:46 <shapr> if you think of more questions, feel free to ask them
11:30:55 <thebug> thanks, I will
11:31:01 * shapr hacks more on QuickCheck
11:31:40 <SyntaxNinja> shapr: are you trying to get the seed still?
11:31:45 <shapr> yes, still
11:31:53 <shapr> I thought I had it twice
11:32:01 <SyntaxNinja> sucks.
11:32:46 <shapr> if you're bored, you can look at the Gen monad in QuickCheck and tell me where the seed really *does* come from...
11:33:20 <SyntaxNinja> heh
11:33:28 <SyntaxNinja> thanks... I think I'll do something else :)
11:33:32 * shapr snickers
11:33:49 <Marvin--> shapr: what do you mean "really comes from"?
11:33:52 <shapr> cabal is more useful anyway
11:34:01 <shapr> at least, to more people...
11:34:08 <shapr> Marvin--: have you hacked on QuickCheck?
11:34:28 <shapr> Marvin--: I want the seed of failing tests to be returned
11:34:31 <Marvin--> generate takes a StdGen which is used in the Gen monad
11:34:54 <shapr> right, so I wrote generate'' size seed (Gen m) = m size (mkStdGen seed)
11:35:19 <shapr> and then generate returns (generate'' size seed g,(size,seed))
11:35:30 <shapr> where g is the (Gen m)
11:36:00 <shapr> and I print the size and the seed in the Just False case of tests -> otherwise
11:36:04 <shapr> but it doesn't work...
11:36:56 <Marvin--> uhh, how is that helpful? you pass size and seed as arguments and get them back as return values too?
11:36:59 <shapr> I wrote generate'' so that I can retest with failing values... but the size and seed don't generate the value that failed
11:37:50 <shapr> it would be easier to just save the failing value itself, but saving just the seed and the generator would take up a *lot* less space
11:38:44 <shapr> Marvin--: am I approaching this the wrong way?
11:39:59 <Marvin--> I don't understand what you're trying to gain by having generate return its arguments
11:40:12 <shapr> so that I can save them if the test fails
11:40:32 <shapr> I was going to stick them into the Result in fact
11:40:51 <Marvin--> but you're already passing them as *arguments* to generate, the callee already *has* those values, how else could it pass them to generate?
11:41:36 <shapr> well, I don't think I can pull the seed out of a StdGen, I think I can only pull out the result?
11:42:25 <Marvin--> I'm not following
11:42:34 <Marvin--> what does your generate look like?
11:43:40 <shapr> oh, so you're saying I should just put (size,rnd2) into the Result?
11:44:47 <Marvin--> probably, yes
11:44:57 <Marvin--> they're not likely to be *modified* by the call to generate, are they? :)
11:45:03 <shapr> no, probably not
11:47:11 <shapr> that sure is a much simpler approach
11:47:16 <shapr> :-)
11:47:56 * Marvin-- spanks shapr with the no-side-effects stick
11:53:07 <shapr> Marvin--: yay! thanks!
12:15:29 * Marvin-- pours a whisky and watches the football for a while
12:30:23 <stepcut> I want to write a process which will read two file handles, and interleave their output as a list of [Either String] -- attempting to preserve the order in which data was available
12:30:59 <stepcut> is this going to be some horrible bit of coding involving multiple threads and MVars, or can I just do a "select" and keep it simple
12:33:09 <stepcut> hrm, actually, I have an idea
12:33:17 <stepcut> no.. I take it back
12:35:13 <Verbophobe> What do you mean "preserve the order in which the data was available"?
12:35:49 <Verbophobe> As in when the data gets read from the disk and the OS passes it to the program?
12:36:42 <stepcut> Verbophobe: well, I am trying to capture stdout and stderr...
12:37:03 <Verbophobe> Oh..
12:37:17 <Verbophobe> Hrm...  I guess a select would do it.
12:37:33 <stepcut> even though there is no guarantee about when messages will appear on stderr in relation to stdout, most programs are written with the assumption that a specific ordering will take place
12:38:00 <stepcut> capturing stdout as one string, and stderr loses a bunch of potentially useful information
12:38:12 <Verbophobe> Ah...
12:39:06 <Verbophobe> Well, if the precision you need is lax enough, you could potentially timestamp each line.
12:39:25 <Verbophobe> But that wouldn't be a real solution.
12:41:01 <stepcut> the other problem is, it seems like I can lazily read stdout and stderr and retain any semblance of ordering
12:48:13 <Verbophobe> Maybe you could go at it by character...  Read a single character/line from each at a time.
12:51:38 * stepcut goes to lunch
13:06:17 <SyntaxNinja> I think several people have talked about it, but is there any implementation of concurrency using Arrows?
13:25:20 <Igloo> How can mipsel cause so much difficulty when mips was so easy?
13:25:27 * Igloo mutters darkly
13:49:05 <stepcut> tar has great error messages --> tar: image/dev/floppy/0u800: implausibly old time stamp 1969-12-31 16:00:00
13:54:01 <FlamingRain> XD
13:59:03 <stepcut> does ghc even have a select function ?
13:59:43 <Igloo> There's hSelect in hslibs, but you're "meant" to use the concurrent stuff these days
14:00:01 <Marvin--> hSelect is in hslibs
14:00:04 <Marvin--> d'oh, too slow :)
14:00:05 <stepcut> ok, current it is
16:23:33 * shapr yawns
16:29:27 <Heffalump> hiya
16:29:36 <shapr> hiiii Heffalump! how's the honey?
16:29:45 <Heffalump> my program doesn't typecheck.
16:29:54 <shapr> oh, that sucks
16:29:59 <shapr> you could use epigram
16:30:02 <Heffalump> I barely understand the type error.
16:30:10 <shapr> then you can figure out where exactly it does not typecheck
16:30:16 <Heffalump> that wouldn't help it type check, it'd just make it more likely to be correct when it did
16:30:33 <shapr> what's the program? what's the error?
16:30:35 <Heffalump> I'm trying to write a decompiler for the ICFP contest ants.
16:30:41 <shapr> oh
16:30:51 <shapr> I missed the ICFP contest.
16:31:03 <Heffalump> it was good.
16:31:04 <shapr> I was busy drinking beer.
16:31:12 <Heffalump> I didn't get much sleep.
16:31:17 <shapr> it looked like fun
16:32:47 <Heffalump> it was.
16:33:36 <shapr> that does sound like fun
16:34:23 <shapr> hey! I got partway into implementing your QuickCheck idea today
16:34:45 <Heffalump> GAH!
16:34:53 <Heffalump> all it needed was a sodding type signature
16:34:57 <Heffalump> what kind of stupid error message is that
16:35:05 <shapr> all I need to do now is figure out how best to recall failing cases
16:35:38 <Heffalump> I could have been doing useful coding all through watching the football if I'd figured that out.
16:35:45 <Heffalump> save the random seed?
16:50:20 * shapr was watching Agatha Christie's "Death on the Nile"
16:50:20 <shapr> yah, that one
16:50:20 <shapr> oh, today ff02::1 is my favorite IPv6 address.
16:50:20 <shapr> that's the link-local multicast address, I got fifteen DUPs!
16:50:22 <shapr> anyway, time to sleep
16:50:23 * shapr wanders off to dream about saving IPv6 addresses and testing them later
18:38:34 <firefly> @index liftM
18:38:34 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
18:38:34 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
18:38:34 <lambdabot> State,Control.Monad.Writer,Monad
18:40:08 <firefly> @state
18:40:08 <lambdabot> nothing yet
18:43:46 <firefly> @index hFileSize
18:43:47 <lambdabot> GHC.Handle,System.IO,IO
19:54:57 <SamB> okay. this Expression type is getting big and ugly...
19:56:23 <SamB> I'm definately going to refactor it after I get this to run...
19:59:51 <jemfinch> SamB: what are you doing?
20:00:00 <SamB> jemfinch: writing a C parser
20:00:16 <jemfinch> oh, blech.
20:00:23 <jemfinch> I just read something about parsing C.
20:00:41 <SamB> never fear. I'm not reading anything about parsing C.
20:01:10 <jemfinch> why not? :)
20:01:33 <jemfinch> (the link if http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&safe=off&selm=gNOSPAMat-3C6401.15004623062004%40nntp1.jpl.nasa.gov if you're interested)
20:03:12 <SamB> believe it or not, I'm just doing it for fun.
20:03:25 <SamB> well, not the fun of writing a parser, though.
20:07:48 <SamB> hmm, I'm not worried about what kind of parser it is that I am writing.
20:23:31 <SamB> hmm, I bet this parser would leak on certain IOCCC entries...
20:28:50 <dons> there's a C parser in c2hs, that would save you some time?
20:28:55 <dons> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
20:29:12 <SamB> dons: for all of C?
20:29:52 <dons> not sure. I think it would probably be as much as is feasible
20:31:00 <dons> --  language: Haskell 98
20:31:00 <dons> --
20:31:00 <dons> --  The parser recognizes all of ANCI C.  The parser combinators follow K&R
20:31:00 <dons> --  Appendix A, but we make use of the richer grammar constructs provided by
20:31:00 <dons> --  `Parsers'.  It supports the C99 `restrict' extension and `inline'.  The
20:31:02 <dons> --  parser is rather permissive with respect to the formation of declarators
20:31:05 <dons> --  in function definitions (it doesn't enforce strict function syntax).
20:31:08 <dons> --  Non-complying definitions need to be detected by subsequent passes if
20:31:10 <dons> --  strict checking is required.
20:32:08 <SamB> hmm. well, I don't expect I'll need C99, it is just what I had laying around ;-)
20:33:44 <dons> there would also be a full C parser in cmi, the cross-module inliner for C
20:33:45 <dons> http://www.cs.utah.edu/flux/knit/cmi.html
20:34:38 <dons> that probably supports all of gcc, since it is a gcc (external) frontend
20:35:40 <SamB> where were you when I asked about C Compilers written in Haskell?
20:35:43 <blackdog> nanyone know a good FP tutorial aimed at smart, experienced Perl hackers? I'm trying to convert a friend.
20:36:40 <SamB> blackdog: umm. well, I don't see why they need special treatment compared to other imperative programmers.
20:36:48 <blackdog> he's pretty much sold on closures already - i want to show him that static typesystems aren't all as bad as C's.
20:37:05 <monotonom> A Perl tutorial that emphasizes sub and map will do wonder.
20:37:09 <blackdog> SamB: Well, Perl's got some of the nice stuff. closures etc...
20:37:22 <SamB> blackdog: well, yeah.
20:37:32 <blackdog> yeah, he knows that stuff. It's the static typing he's skeptical about.
20:37:35 <SamB> I mean, I'll take your word for it.
20:37:38 <monotonom> Ah I can't help with the type system part.
20:37:43 <SamB> I'm not touching that myself.
20:37:55 <blackdog> Don't blame you.
20:38:12 <SamB> show him what "static" means in the context of Haskell.
20:38:34 <monotonom> Some actual code will help.  One can see easily that the code is not bogged down by annotations, yet it is type safe.
20:38:44 <SamB> make a type, give it some instance declarations, and use some standard library stuff on it...
20:40:02 <blackdog> on a related note - are there any projects people would recommend as shining lights of elegance?
20:41:15 <dons> well, on the TMTOWTDI http://www.willamette.edu/~fruehr/haskell/evolution.html
20:45:02 <blackdog> dons: do you ever take your tongue _out_ of your cheek?
20:46:02 <dons> sorry. feeling sick and am inclined to throw large source files at people :}
20:47:19 <SamB> dons: then, why did you throw me the webpage instead of the C parser?
20:48:04 <SamB> hmm. I'm not sure I'll be able to successfully complete the build process for C->Haskell... I don't know where to find green tea...
20:48:33 <dons> sorry. I was actually trying to be helpful in your case :)
20:49:03 <monotonom> I have a lot of green tea bags, both school and home.  Give me your postal address and I'll send you some.
20:49:20 <SamB> hmm. there might be some here, anyway...
20:50:16 <monotonom> Some of my green tea bags contain whole leaves, unshredded.
20:50:50 <SamB> hmm. come to think of it, my computer lacks /dev/nose, so I should be okay.
21:14:36 <gring0> can a formal demostration be done programmed in haskell and by induction like, for saying,.. in graphs?
21:15:13 <Riastradh> If it can be done on a Turing machine, it can be done in Haskell.
21:15:31 <desrt> what about a non-deterministic turing machine?
21:15:45 <gring0> yes, but in worse order
21:15:52 <gring0> but it can be done, anyway
21:16:17 <gring0> anyway.. I'm talking about formal proofs here
21:16:32 <Riastradh> Just use the nondeterminism monad!
21:16:58 <desrt> wow
21:17:00 <desrt> good answer :)
21:17:11 <desrt> i was expecting a "no"
21:17:26 <gring0> mm
21:17:28 <gring0> whose? :)
21:17:44 <Pseudonym> Actually, you want a slightly modified nondeterminism monad which uses breadth-first search.
21:18:04 <gring0> wtf is a monad?
21:18:14 <Riastradh> A generalization of a computation.
21:18:25 <Riastradh> The nondeterminism monad, therefore, is a generalization of nondeterministic computation.
21:18:36 <gring0> no idea
21:18:39 <gring0> anywayt
21:18:47 <gring0> my math formal proofs?????
21:19:11 <Riastradh> Your math formal proofs!!!!!
21:19:24 <gring0> :$
21:19:40 <blackdog> i formally proved your maths, all night long.
21:19:55 <gring0> where did it take you to?
21:20:00 <Riastradh> I can attest to that, too.  He kept me up all night.
21:20:12 <Riastradh> His proofs were made a terrible racket.
21:20:15 <Riastradh> Were?
21:20:18 <Riastradh> Hmmm.
21:20:40 * Riastradh wonders how that dastardly 'were' managed to sneak past his defences into the sentence.
22:08:59 <Riastradh> Glerk.
22:09:02 * Riastradh frumbles at GHC.
