01:13:48 <andersca> hmm, does duncan coutts come here?
01:20:22 <Heffalump> he does occasionally, I believe
01:20:22 <Heffalump> why?
01:20:32 <Heffalump> I've never seen him but Igloo said he did at least once.
01:20:37 <andersca> he sent a clueful mail to the d-bus list
01:20:44 <Heffalump> d-bus?
01:20:49 <andersca> dbus.freedesktop.org
01:22:01 <Heffalump> ah
01:23:04 <Heffalump> what's #haskelld?
01:28:26 <earthy> nothing?
01:33:08 <jemfinch> Heffalump: weren't you an SML person?
01:35:26 <Heffalump> earthy: what's it doing in the topic, then?
01:35:34 <Heffalump> jemfinch: I have been, yes
01:35:38 <Heffalump> why?
01:35:58 <jemfinch> I was just curious, I remembered you as an SML person, not a Haskell person.
01:36:21 <Heffalump> but surely you remembered me from _here_ as an SML person? :-)
01:36:35 <jemfinch> maybe...I don't remember entirely clearly.
01:36:40 <Heffalump> I guess I have inhabited #sml a bit
01:37:20 <jemfinch> oh well.
01:40:52 <det> cant you be both? :-)
01:43:11 <earthy> hef: ask shae
01:43:14 <earthy> he set the topic
01:43:53 <Heffalump> det: well, I am :-)
01:55:26 <Huschi> can anybody explain me, what the "m s | m -> s" part in "class MonadState m s | m -> s where" means?
01:57:23 <ibid> you probably want to ask what the "| m -> s" part means :)
01:57:32 <ibid> everything else is standard class syntax
01:57:56 <ibid> it is a functional depencency or some such, it's Deep Stuff even to me :)
01:57:58 <blackdog> does anyone know how to get ghci to quit with an errorcode?
01:58:13 <ibid> i think it means that s is determined by m
01:58:21 <ibid> but i don't know for sure
01:58:53 <JaffaCake> blackdog: no, there isn't a way to do that
01:59:11 <ibid> one could do ghci || true :)
01:59:29 <blackdog> Ok, fair enough. Thanks JaffaCake
01:59:54 <JaffaCake> well, not officially anyway - there are low-level hacks you could use
01:59:54 <blackdog> linking takes forever on my poor old box, i was just trying to get my compile cycle a bit shorter...
02:00:26 <Huschi> ok, thanks
02:00:43 <blackdog> should i sourcedive, or is there a more accessible source of info?
02:00:54 <JaffaCake> you can foreign import shutdownHaskellAndExit, and call that
02:01:27 <blackdog> cheers, i'll try that. every little bit helps, i'm conivnced this machine is steam-powered.
02:02:12 <blackdog> (I was almost reduced to 'system "killall -9 ghci"', which is less than elegant. ;)
02:02:16 <andersca> haha
02:02:23 <det> Heffalump: heresy
02:02:28 <det> Heffalump: SML is the one true way
02:02:33 <det> Heffalump: that was merely a witches test
02:13:18 <earthy> you are accused of heresy on three counts heresy by thought, heresy by word, heresy by deed and heresy by action.. fo.. four counts. now, you have one last chance. Confess the heinous sin of heresy, reject the works of the simo... two last chances, and you shall be... three last chances! you have three last chances!
02:14:51 * Heffalump suggests earthy come in again
02:15:18 <earthy> Nobody expects the standard ml inquisition!
02:15:44 * JaffaCake pokes earthy with the soft cushions
02:16:11 <earthy> Cardinal Hef, fetch hither the comfy chair!
02:16:22 * earthy laugs
02:16:23 <earthy> +h
02:17:43 <earthy> well, that goes to show that there is a certain danger in having Monty Python cd's ripped into your iTunes
02:18:46 <blackdog> hm. i was about to load feynman's lectures onto mine, but now I'm a bit chary...
02:34:20 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]' by shapr
02:34:32 <shapr> Heffalump: #haskelldb !
02:34:49 <Heffalump> ahhh :-)
02:35:47 <shapr> Heffalump: hey, aren't you an SML person?
02:35:53 * shapr grins evilly
02:35:58 * shapr ducks
02:36:23 <shapr> aren't I a Python person? :-/
02:36:49 <Heffalump> I entered the ICFP contest with Haskell, that's what counts :-p
02:36:55 <shapr> yay!
02:37:20 <shapr> I'd like to be a Haskell, Joy, Self, etc person.
02:38:32 <blackdog> shapr: why bother, you're already well-rounded... >:)
02:39:00 <shapr> man, I'm trying to unicycle more to get a little less rounded.
02:39:40 <shapr> look at Heffalump, he's svelte
02:40:14 <shapr> blackdog: or I could get into judo, how's it going for you?
02:40:16 <blackdog> i'm doing something similar, I'm just too embarrassed to tell you what it is.
02:40:50 <blackdog> shapr: haven't been for months, I've had a foot problem. Healed now, though, os i'll start going again.
02:41:32 <blackdog> can you get up to a steady speed on the unicycle, or is staying upright the problem?
02:41:49 <shapr> I can get up a steady speed just fine now
02:42:00 <shapr> but it's slow with such a small wheel
02:42:35 <earthy> svelte. nice word. ;)
02:44:06 <shapr> blackdog: you wanna learn to unicycle? I've decided I'll teach all those who are interested.
02:44:15 <shapr> so far that seems to be only my swedish teacher.
02:45:08 <blackdog> it'd be cool, but i don't have a unicycle
02:45:58 <shapr> mine cost a hundred bucks in the shop on the corner.
02:51:39 <blackdog> shapr=professional developer, blackdog=starving student. :)
02:52:06 <shapr> shapr=self-employed starving developer
02:55:04 <blackdog> dammit, i don't seem to be able to do foreign imports ath the prompt in ghci...
02:55:23 <blackdog> shapr: i think i might be veering off course - i'm optimising my compile command for speed.
02:55:52 <shapr> oh no!
02:56:51 <blackdog> <weak excuse> linking takes too long on my little machine... </>
03:09:00 <Heffalump> Duncan can unicycle.
03:15:14 <shapr> Heffalump: do you know Duncan Grisby?
03:18:13 <Heffalump> no, Coutts.
03:39:29 <shapr> well, it's time for that famous swedish holiday... midsommarafton
03:40:39 <earthy> wasn't that, like, supposed to be on the 21st?
03:41:33 <shapr> I think today is the longest day?
03:43:22 <earthy> http://www.erh.noaa.gov/er/box/equinox.html
03:43:41 <earthy> looks like it was last sunday
03:44:45 <shapr> hm, well
05:10:39 <Huschi> in a declaration like "data Point = { x, y :: Point }" how are x and y called?
05:11:12 <andersca> Huschi: you can't make x and y be of type point, can you?
05:11:27 <andersca> Huschi: anyway, if p is of type Point, you can get x and y by using x p and y p respectively
05:11:45 <norpan> hej anders
05:12:03 <Huschi> oh, i meant x, y:: Int
05:12:11 <norpan> Huschi: does that declaration really work?
05:12:30 <Lukhas> shapr: the longest was probably the 21st, as usual :)
05:12:37 <norpan> don't you need a type constructor as well
05:13:02 <Huschi> ok, i wanted to write "data Point = P { x, y :: Int }"
05:13:08 <Huschi> i hope it's correct now
05:13:20 <norpan> yes, then you can get x and y from p by x p and y p
05:13:38 <Huschi> but how are x and y called? construction functions, destructor functions, ...?
05:13:47 <Huschi> i meant constructor
05:13:57 <norpan> you mean _what_ are they called?
05:14:20 <norpan> selector functions maybe
05:14:26 <Huschi> ok, english is not my native language
05:14:43 <andersca> norpan: #haskell.se
05:14:45 <Huschi> oh yes, selector sounds goof
05:15:04 <Huschi> and i don't know any swedish word
05:36:51 <Cale> You *can* make them of type Point. It just doesn't make much sense in that context :)
05:39:00 <Cale> x and y are field labels
05:39:28 <Cale> P is a data constructor
05:39:59 <Cale> and Point is a type (if it were parametrised, it would be a type constructor)
05:40:26 <norpan> Cale: but x and y are more than labels, they are selector functions
05:41:38 <norpan> yeah, sure you can make them Point, you can even make them make sence, do something like let p = P { x = p, y = p } in p
05:41:44 <norpan> sense
05:42:46 <Cale> Labels are selector functions :) In fact, that's all they are in H98
05:42:57 <Cale> well, almost
05:43:03 <Heffalump> aren't they overriders too?
05:43:11 <Cale> there is some extra syntax related to them
05:43:37 <Cale> you can say  p { x=5 } to mean a point which is the same as p except that its x coordinate is 5
05:44:09 <norpan> yes
06:14:27 <Huschi> is there any geometry library available for haskell?
06:21:59 <Huschi> why don't you answer?
06:22:36 <Heffalump> I imagine that noone knows the answer.
06:22:45 <Huschi> ok
06:25:53 <earthy> Huschi: afaik: no. at least not one that has been in active development over the past 12 months
06:28:49 <Huschi> fuck
06:29:03 <Huschi> this means i need to develop one on my own
06:30:25 * earthy nods
06:41:40 <Huschi> is there anybody else who needs a geometry library and wants to develop one toghether with me
06:59:11 <Lemmih> Is the debian package for ghc-cvs-hopengl broken?
07:00:38 <Lemmih> I get "Could not find interface file for 'Graphics.Rendering.OpenGL.GL.PixelData'" when I try to compile an OpenGL program.
07:02:53 <Igloo> Did that exist in December 2003?
07:06:03 <Lemmih> Whoa... Didn't realize it was that old.
07:06:59 * Igloo doesn't plan on doing an update until I have ghc compiling on all arches again
07:18:31 <thebug> ghc6 from sarge works on PPC Igloo :)
07:20:22 <Igloo> Glad to hear it  :-)
07:20:28 <Igloo> Still only 6.2, though  :-(
07:22:55 <thebug> what's current?
07:23:02 <Igloo> 6.2.1
07:23:16 <thebug> could certainly be worse
07:45:54 <earthy> dang. time exceeded.
07:45:58 <earthy> need to think harder.
07:46:49 <Igloo> ?
07:46:51 <Igloo> Oh, the judge?
07:47:43 <Igloo> Hmm, if I actually want to do it properly I'll have to find time before spoilers make their way in here
08:43:18 <dready> elp
08:46:11 <mmorvant> hello
08:47:52 <mmorvant> anyone here?
08:47:56 <Riastradh> Yes.
08:48:00 <Heffalump> MEEE!
08:48:42 <mmorvant> I'm looking for some haskell help
08:49:07 <Heffalump> don't ask me, apparently I'm an SML person
08:49:24 <jemfinch> hah
08:49:29 <Igloo> *cough*Java hacker*cough*
08:49:39 <mmorvant> functional programming is sooo different from VB I just can't get it
08:49:41 <Heffalump> I *REALLY* need a supply of ammunition.
08:50:06 <Philippa> mmorvant: this may be because VB isn't a real language :-)
08:50:09 * thebug holds back comment on VB
08:50:16 <Philippa> anyway, what do you need help with?
08:50:22 <Philippa> thebug: too late :-)
08:50:27 <thebug> oops :)
08:50:38 <mmorvant> maybe not but it sure does pay alot
08:50:46 <Philippa> in fairness, VB1 was actually a good thing
08:51:04 <Philippa> but by VB6? Complete mess. I'm amazed people're actually /complaining/ about the shift to VB.net and a proper object model...
08:51:10 * Heffalump finds some and throws it rather ineffectually at Igloo
08:51:13 <mmorvant> Phillipa you actually started to help me out several months ago
08:51:15 <thebug> mmorvant: I think that's the only reason the language has been held forward
08:51:50 <Philippa> mmorvant: possibly, 'fraid I don't remember your nick though so may as well start from scratch?
08:51:52 <mmorvant> I am expanding in a couple of different direction C# on one side, and Haskell on the other
08:52:00 * Philippa nods
08:52:17 <Philippa> C#'s going to be better for employment, Haskell'll teach you a crapload about writing better code though
08:52:48 <mmorvant> To start from the beginning I am playing an internet game, full of programming/hacking challenges
08:53:30 <Philippa> carry on...
08:53:32 <mmorvant> One of the challenges was to open up a file protected by a delphi app, and extract a script
08:53:46 <Philippa> "protected by"?
08:53:49 <mmorvant> Then find out what the script was written in..turns out to be haskell
08:53:55 <Igloo> Where is the game OOI?
08:54:24 <mmorvant> basically just a zip file embedded inside an app protected by a password that I didn't know
08:54:59 <Philippa> so lemme guess, now you need to understand it?
08:55:05 <mmorvant> Once you get the file you are told that it has been modified to make sure it doesn't work
08:55:44 <mmorvant> I think I got some of it, but I am getting really stuck on the type definitions
08:56:08 <Igloo> I vaguely remember someone asking about something similar a while ago, actually
08:56:16 <Philippa> OK. So what don't you get? Any of it at all?
08:56:33 <Philippa> and have you found any relevant material (eg the tutorials available from haskell.org)?
08:56:52 <mmorvant> I understand what it is trying to do, mostly just a really complex regular expression
08:57:20 <Philippa> Sure. What /don't/ you understand?
08:57:38 <mmorvant> give me a sec and I will post it to a website
08:57:45 * Philippa sighs
08:57:53 <Philippa> no, I'm not going to look at code. What don't you understand in it?
08:58:16 <Heffalump> is C# actually useful for employment? I haven't really seen many jobs advertising it.
08:58:39 <Philippa> Heffalump: more so than Haskell atm, I would've thought. Something .net in general seems to be increasingly useful though
08:58:55 <Philippa> not as big as Java yet, sure
08:59:00 * thebug trying to grok CPS o_O
08:59:07 <Heffalump> yeah, true.
08:59:27 <mmorvant> I am using hugs as the compiler
08:59:29 <Heffalump> My current job has turned into Java hacking, as Igloo said.
08:59:37 <Heffalump> which is actually surprisingly fun
08:59:47 <jemfinch> Heffalump: why is it fun?
08:59:52 <thebug> I hated C# when I used it...it encompassed everything I hated about Java -and- VB
09:00:09 <thebug> and had a nice, bloated runtime to boot
09:00:16 <Philippa> Heffalump: all the opportunities for "// This would be so much easier if I could..."?
09:00:52 <Heffalump> mainly cos the thing I'm doing in it is fun, and Java isn't all that bad.
09:01:11 <mmorvant> It tells me that the type that I give is not the type that it expects
09:01:14 <musasabi> Oz is kind of nice, except for the syntax.
09:01:18 <Philippa> will have to take your word on that, sadly. Last time I had to really use it was the compilers coursework at uni, which was absolute hell in Java having used Haskell
09:01:30 <Heffalump> as it happens I am writing a compiler :-)
09:01:41 <Philippa> mmorvant: to put it another way, the program isn't correctly typed
09:01:50 <mmorvant> yes that is correct
09:02:02 <mmorvant> But I keep going in circles tyring to correct it
09:02:03 <Philippa> give or take the slightly different error messages due to Haskell's type system sporting inference...
09:04:06 <mmorvant> the script takes in an argument much like (-4^!2s4s%s!2s8!6ss%s564644vaus!!u93b3u4c*dvyeuun44vrd;!!&56vv&*)
09:04:20 <mmorvant> I assume that this is a String
09:04:40 <Philippa> be careful about assumptions like that...
09:04:56 <Philippa> it /probably/ is, but check the code that actually reads the argument in
09:05:12 <Philippa> 'cos it may well be something different by the time the bulk of the code is playing with it
09:05:46 <mmorvant> There is an initial check that has to do with the length of the argument
09:06:07 <mmorvant> it may equal mzero or call a secondary function
09:06:40 <mmorvant> Again I assume, by reading some of the parselib docs that mzero is always a failure
09:06:58 <Philippa> sorry, I'm going to have to go. IRL stuff and all that. Hope somebody else helps you out
09:07:28 <mmorvant> me too, thanks though
09:18:40 <Igloo> @index doesDirectoryExist
09:18:41 <lambdabot> System.Directory,Directory
09:30:08 <mmorvant> any other takers
09:30:29 <mmorvant> would $20 via paypal help?
09:31:22 <Igloo> If you explain the problem someone might try to help
09:31:38 <andersca> 7msg Igloo sssh, if we wait longer he might raise the offer
09:31:40 * andersca runs
09:31:42 <andersca> ;)
09:31:52 <mmorvant> not likely
09:31:56 <Igloo> :-)
09:32:00 <Igloo> (7?!)
09:32:12 <mmorvant> It is just that I have working on this on and off for over a year
09:32:12 <andersca> Igloo: shift-7 is / on a swedish keyboard
09:32:20 <Igloo> How peculiar
09:34:34 <musasabi> on finnish too.
09:34:56 <musasabi> although for programming an US layout + äöå begin AltGr is the best.
09:35:48 <mmorvant> http://www.bigfatreddog.com/haskell/ has the list of possible arguments and the haskell script
09:36:55 <mmorvant> as phillippa pointed out it is not properly typed, and I can not figure out how to make it so
09:37:47 <Igloo> Do you understand why the first error happens?
09:38:14 <mmorvant> The first type error?
09:38:20 <Igloo> Yup
09:39:01 <mmorvant> Not totally, I assume it sees a type of [(a,b)]  where i told it was String
09:39:36 <Igloo> And presumably it also tells you whereabouts in the file that happens?
09:40:13 <mmorvant> yes, but when I follow that course I get stuck in a circle of errors and I keep changing the same lines over and over again
09:42:13 <mmorvant> I canged line 7 to  [(a,b)] -> String and Hugs tells me that it is not general enough and inferrs [([Char],a)] -> String as the correct type
09:42:50 <mmorvant> So I change again
09:43:38 <Igloo> You need to understand what the code is trying to do in order to fix it
09:43:57 <Igloo> You can't just change the types as the code is wrong too
09:44:15 <mmorvant> oh, I thought I fixed it
09:44:25 <mmorvant> which was just guessing
09:45:50 <mmorvant> The basic gist of the program is to take a string from the possible file and see if it matches the pattern set forth by a series of parsers
09:47:48 <mmorvant> THere is a check of the length of the argument
09:48:23 <mmorvant> if it is 56 then it passes?
09:49:40 <mmorvant> wait thats not right
09:50:39 <mmorvant> x must be 49 characters long
09:52:08 <mmorvant> length (init (x ++ "p")) is the same as length(x)  .....  right?
09:54:41 <thebug> (!)
09:55:12 <thebug> won't x ++ "p" append 'p' to the end of the (I'm assuming it's a--) character array 'x'?
09:56:06 <mmorvant> x could be "-5-^!8cf84&!670*!a5&1c-105!&32&%*f52"
09:56:07 <Igloo> character list x, yes
09:56:23 <thebug> yes yes, apologies for incorrect terminologyu
09:56:30 <thebug> [Char], isn't it?
09:56:33 <Igloo> Yup
09:56:42 <Igloo> And what does init do?
09:56:45 <mmorvant> oops one of many mistakes
09:57:16 <mmorvant> everything except the last character??
09:57:25 <thebug> unless init removes the 'p' from the end of the list, I don't see how that expression could be the same as length(x)
09:57:43 <thebug> well, or does some other length-messing-with operation
09:58:21 <Igloo> Do you know what head and tail do? last and init are in a sense the opposite
09:58:33 <mmorvant> init is everything but the last element
09:58:42 <Igloo> Yup
09:58:55 <SyntaxNinja> Igloo: head & tail are like car and cdr
09:58:57 <SyntaxNinja> ;)
09:59:04 <Igloo> So init (x ++ "p") = ?
09:59:07 <thebug> ah, no I didn't know that last and init did that
09:59:39 <Igloo> Syn: I'll see you and raise you hd and tl  :-Ã¾
10:00:03 <mmorvant> but wrapped inside of length doesnt length(init(x ++ "p")) equal length( x )
10:01:03 <SyntaxNinja> Igloo: :)
10:01:56 <thebug> ok that equality makes more sense now :)
10:02:00 <Igloo> Bah, checkig removing $!s doesn't alter compiled code is a pain as evaluation orders all swap around
10:03:06 <mmorvant> (sum [product [1..4], product [2..4], 1])) == 49 yes
10:03:55 <thebug> too many parens for one thing
10:04:32 <mmorvant> sure are
10:05:05 <mmorvant> bad cut and paste
10:05:34 <mmorvant> forgot i can just excute inside hugs
10:07:51 <SyntaxNinja> has anyone seen Michael Moore's movie? I"m seeing it tonight
10:08:08 <mmorvant> hopefully tonight
10:20:02 <mmorvant> so i thought that the runIt function said that if the argument was not 49 characters in length then it would fail
10:21:07 <mmorvant> but when I perform a simple reg expr on all possibles that are 49 chars long, I don't see any that start with - digit - what is what the first parser (code2)  suggests
10:29:20 <mmorvant> if anybody else has any suggestions I can be mailed at mmorvant@bigfatreddog.com, i was serious about the paypal offer :-)
10:36:20 <mailman> hi, anyone can help me?
10:36:51 <mailman> im a newby in haskell
10:37:23 <basti_> like how? ;)
10:39:21 <shrimpx> no specifics, just pure, abstract help
10:39:36 * SyntaxNinja turns on eliza
10:39:38 <mailman> I have a function that gets info about a number, 
10:39:56 <mailman> but it always eats the first
10:39:58 <SyntaxNinja> mmorvant: did I miss something? what about paypal?
10:40:19 <mailman> i.e. it should return [1,2,3]
10:40:23 <mailman> i get [2,3]
10:40:26 <mailman> only
10:41:20 <basti_> mailman did you use pattern matching?
10:42:51 <mailman> yes, i think
10:44:06 <basti_> hmm
10:44:11 <SyntaxNinja> @wiki HaskellIrcPastePage
10:44:12 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:44:22 <basti_> well i would check it in this case ;)
10:44:38 <SyntaxNinja> mailman: you can post your function there {{{inside braces}}}, and someone might look at it.
10:44:58 <SyntaxNinja> mailman: is this for homework?  
10:46:33 <mailman> yes
10:47:55 <thebug> SyntaxNinja: he wanted to post 20$ to paypal for someone who helped him fix some script for some contest/game thing
10:49:07 <mailman> now it works, thanks to Lemmih, thanks to all of you. It's nice to know you people are out there to help 
10:49:48 <SyntaxNinja> thebug: heh
10:50:27 <SyntaxNinja> mailman: hope you have fun learning haskell :)
10:50:41 <mailman> sorry if my english isn't good. Im learning
10:50:50 <mailman> thanks SyntaxNinja
10:50:52 <mailman> :)
11:04:01 * Lemmih rants about outdated Happy packages.
11:07:20 <Igloo> Why is it an issue? Building CVS?
11:07:25 <Igloo> (GHC CVS, that is)
11:07:46 <Lemmih> yeah. I had to install Happy from source /-:
11:07:53 * SyntaxNinja continues campaign to acqurie 'the Fun of Programming"
11:08:09 <Igloo> Did you try e-mailing Palgrove?
11:08:34 <Igloo> Hmm, I think I'll try to do a happy update in the next few days
11:09:56 <SyntaxNinja> I emailed fop-info@comlab
11:10:00 <thebug> Igloo: which debian release tracks do you upload packages for?
11:10:06 <SyntaxNinja> the US branch of the publisher didn't reply
11:10:57 <Igloo> thebug: For unstable, but I hope everything I'm doing now will make it into testing before sarge releases, and hence will be in sarge
11:11:11 <thebug> ah, nice
11:11:26 <thebug> that'd be cool
11:12:37 <thebug> Igloo: if for some reason you need it, I can try building packages for you testing/ppc
11:12:39 <Igloo> nhc98's finally got the green light, all it needs is 6 or so days without a new bug to appear
11:13:13 <Igloo> Thanks, but I don't think ppc is causing any problems currently
11:14:24 <SyntaxNinja> Igloo: did you get that sparc thing worked out?
11:14:30 <SyntaxNinja> (for ghc)
11:14:36 <Igloo> Yeah, 3.3.4 magically fixed it
11:14:40 <Igloo> gcc 3.3.4 that is
11:14:56 <Igloo> And broke m68k at the same time. *sigh*.
11:15:02 <thebug> arr that's what bothers me about the gcc 3 series...things 'magically break and fix themselves'
11:15:15 <thebug> :/
11:28:39 <mmorvant> i'm back
11:33:46 <mmorvant> Igloo, are you still willing to help, or have I worn out my welcome
11:44:13 <SyntaxNinja> Igloo: my fop-info email bounced. who do you think I should email?
11:47:52 <Igloo> Oege.de.Moor@comlab.ox.ac.uk perhaps, but I imagine he'll just tell you to ask the publishers
11:48:31 <SyntaxNinja> we will see...
11:56:38 <firefly> shapr: why is lambdabot called lambdabot instead of simonbot?
11:56:53 <firefly> "Simonbot says, that ...."
11:59:24 <mmorvant> Igloo, you said earlier that I couldn't just change the type defs, because the code was wrong, can yoy help me understand where it is wrong?
12:07:04 <Igloo> mmorvant: Not right now, busy
12:07:37 <mmorvant> ok
12:29:13 <musasabi> well it is not only haskell that has problems with gcc 3.x
12:29:18 <musasabi> everything else too.
12:29:59 <musasabi> it seems that "try another 3.x version" seems to solve problems in most cases, but is of course of no help with end users.
12:30:06 <thebug> that's what I meant :)
12:32:32 <maihem> OT: Hsss, stinking Hsiffies.
12:33:40 <maihem> sorry, I got carried away.
14:04:06 <ski> @arr
14:04:07 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
14:04:17 <ski> @yow
14:04:17 <lambdabot> There's enough money here to buy 5000 cans of Noodle-Roni!
14:18:07 * Igloo writes CGI.pm code and pines for WASH debs
14:18:30 <Heffalump> can't you make some?
14:18:46 <Igloo> Lack of tuits
14:18:57 <Heffalump> for a second I thought you were abandoning mutt.
14:19:11 <Igloo> huh?
14:19:14 <ibid> round ones i presume?
14:19:18 <Igloo> Indeedy
14:19:56 <ibid> i wonder what would happen if i got a square tuit
14:20:21 <Heffalump> why are you writing CGI.pm code, OOI?
14:21:20 <Igloo> Just a small script to show buildd information per package rather than per state
14:25:52 <Igloo> Although I might have to give up for now due to latency
14:43:07 <mmorvant> anyone heard of hatchet?
14:46:33 <ShaminoDC|FBK> i got a function :
14:46:36 <ShaminoDC|FBK> func                             :: [(Na,Ve)] -> [(Na,Ve,Fg)] -> String
14:46:40 <ShaminoDC|FBK> and i call this one by
14:46:49 <ShaminoDC|FBK> func [(a,b)] [(c,d,e)]            = whatever
14:47:14 <ShaminoDC|FBK> how can i call it with a list of (a,b) s
14:47:30 <firefly> err, you just did?
14:47:33 <ShaminoDC|FBK> [((a,b):abs)] is not working
14:47:35 <ski> the type signature of "func" says that it only has one argument
14:48:00 <firefly> func [(a,b),(a,b),(a,b)] [(c,d,e), (c,d,e)]
14:48:47 <ShaminoDC|FBK> but what if (a,b) is read from a file that has amounts of (a,b) s
14:49:13 <firefly> Then that (a,b) list is in a variable, call it abs.  Func abs [(c,d,e)]
14:49:36 <ShaminoDC|FBK> the amount ob a , b is diffrent every time
14:49:36 <ShaminoDC|FBK> so i need something like [((a,b):abs)]
14:49:36 <ShaminoDC|FBK> any ideas ?
14:49:44 <firefly> [(a,b)] already /is/ a list.  It contains one element, namely the (a,b) pair.
14:49:59 <ski> use ((a,b) : abs)
14:50:03 <firefly> [((a,b):abs)] does not have the type you think it does.
14:50:05 <ski> no [ ]
14:50:11 <ShaminoDC|FBK> aaaaa
14:50:15 <ShaminoDC|FBK> good idea thx
14:50:34 <ski> @type [ ( ('a',True) : [] ) ]
14:50:36 <lambdabot> [ ( ('a',True) : [] ) ] :: [[(Char, Bool)]]
14:50:43 <ski> @type ( ('a',True) : [] )
14:50:45 <lambdabot> ( ('a',True) : [] ) :: [(Char, Bool)]
14:51:36 <firefly> welcomes.
14:53:00 * ski think the cmemes are bots
14:54:07 <firefly> buys.
14:55:01 <mmorvant> can someone point me to a document to help understand "result ((x,xs):ys) = x" without knowing sqat about functional language?
14:55:33 <firefly> err...no.  But maybe we can hash it out right now and right here?
14:55:41 <ski> do you want to learn about functional languages ?
14:55:51 <firefly> It looks to me like a function definition that uses pattern matching.
14:56:01 <mmorvant> i've been here a good part of the day, bothering folks
14:56:07 <firefly> result is a function, it takes a parameter that is a list.
14:56:11 <mmorvant> and showing my ignorance
14:56:23 <ski> no problem
14:56:28 <firefly> (x,xs) is the start ("head") of the list, ys is all the rest of the list ("tail").
14:56:39 <firefly> The tail may be empty - and the head is always exactly one element.
14:56:56 <firefly> (x,xs), the head, is a pair of two values.
14:57:18 <firefly> What exactly those values are -- and what /kind/ they are -- doesn't concern us at the moment.
14:57:21 <ski> [1,2,3] is syntactic sugar for (1:2:3:[]) (which is (1:(2:(3:[]))) )
14:57:44 <mmorvant> you are correct that it is a part of a function that uses pattern matching
14:58:11 <firefly> The ((x,xs):ys) is a socalled /pattern match/.  This is actually all you need to know about pattern matching in order to understand this function.
14:58:18 <mmorvant> please explain syntactic sugar for those of us (me) with fewer braincells
14:58:25 <firefly> Ok, now to the return value, i.e. what this function evaluates to.
14:58:32 <firefly> The return value is simply: x.
14:58:45 <ski> 'syntactic suger' is more or less the same thing as 'shorthand notation'
14:58:46 <firefly> In other words: it takes a list of pairs and returns the first element in the first pair on the list.
14:59:15 <mmorvant> where does the "list" come from
14:59:29 <firefly> I don't know - isn't that the caller's problem? ;)
14:59:36 <ski> the list is the argument to the function
14:59:46 <firefly> Maybe you mean to ask "how do you know that there's a list involved here?"
14:59:53 <firefly> Well, I can see that from the pattern match.
14:59:59 <firefly> The : is a dead give away.
15:00:21 <mmorvant> let me start off by explaining that I am participating in a game that solving a haskell program is part of
15:00:27 <firefly> And /now/ is perhaps the right time to introduce the syntactic sugar that ski mentioned earlier.
15:00:37 <ski> :)
15:00:39 <firefly> I know.  I saw your conversations earlier.
15:00:51 <mmorvant> good, don't need to re-explain
15:00:58 <mmorvant> I have some of it posted
15:01:47 <mmorvant> http://www.bigfatreddog.com/haskell/mod.txt is where the code that I have "fixed" is
15:01:53 <firefly> Just to make sure: do you understand the result function now?
15:02:24 <firefly> I am not going to take a look.  If we are going to do this, it is not by having me solve it for you, it is by /us/ having a conversation.
15:02:40 <mmorvant> that is fine, I DO want to learn
15:02:46 <firefly> Just to make sure: do you understand the result function now?
15:02:57 <mmorvant> Partially
15:03:04 <firefly> ok, what's left?
15:03:08 <stepcut> mmorvant: is that a pun ?
15:03:23 * firefly does not mention the currying.
15:03:53 <mmorvant> I understand the concepts of Head and Tail
15:03:57 <firefly> good.
15:05:09 <mmorvant> so if result is passed in 123 it would return 1?
15:05:20 <firefly> it would not run.
15:05:20 <mmorvant> thats not ight
15:05:26 <firefly> 123 is not a list of pairs.
15:06:23 <mmorvant> a pair would be (1,2)
15:06:30 <firefly> yes.
15:06:44 <firefly> ok, let's try a list, then.
15:06:48 <firefly> [] is the empty list.
15:06:56 <mmorvant> so it would require (1,2),(3,4) then
15:07:00 <firefly> [(1,2)] is a list containing a single element, namely the pair (1,2).
15:07:14 <firefly> [(1,2), (3,4)] is a list with two elements.
15:07:21 <firefly> (1,2),(3,4) is not a list.
15:08:17 <mmorvant> ok, that makes a list similar to an array
15:08:31 <firefly> if it helps you to think about it like that :)
15:08:47 <mmorvant> and a list of pairs like a 2d array
15:09:08 <mmorvant> I am trying to draw a parralell to the world i know
15:09:16 <firefly> You can't index directly into a list, you have to cut off an element at a time until you reach the one you are interested in.
15:09:24 <firefly> (there are functions to help you, though)
15:09:39 <ski> a list of pairs is not like a 2d array
15:09:48 <ski> it's like two arrays
15:09:49 <firefly> list of pairs like a 2d array?  In a very sortofish approximate like way.
15:09:52 <firefly> Kinda.
15:10:04 <mmorvant> that make the need for init head and tail functions more handy
15:10:08 <firefly> ski: you are confusing again, I fear.
15:10:21 <firefly> mmorvant: yes.
15:10:25 <ski> or like an array with struct elements, each having two fields
15:10:33 <mmorvant> don't feel bad it doesn't take much to confuse me at this point
15:10:42 <firefly> And there is the great pattern matching idiom, that does the head'ing and tail'ing automatically for you.
15:11:30 <firefly> The (...:...) thing you saw in result automatically takes the head of the argument and matches that with (x,xs) and the tail and matches that with ys.
15:11:33 <ski> firefly : hmm ?
15:12:02 <firefly> A successful match is like an assignment.  Yeah, just think of it as an assignment.
15:12:14 <firefly> (ski is bound to say something about Haskell not having assignments at this point)
15:12:25 <firefly> ski: ;)
15:12:28 <ski> haha
15:12:52 <ski> single-assignment is not a problem
15:13:10 <ski> (also known as 'initializing')
15:13:13 <firefly> ski: whatever you do, DON'T mention the currying ;)
15:13:14 <mmorvant> so going back to [(1,2),(3,4)]
15:13:18 <firefly> yes.
15:13:33 <mmorvant> result ((x,xs):ys) = x THAT would be 1???
15:14:19 <arjanb> yes
15:14:21 * ski 's a bit tired so please tell him if he speaks garbage sometimes ..
15:14:21 <firefly> If that is your result definition and you evaluate result [(1,2), (3,4)], yes :)
15:14:40 <firefly> ski: you don't, but your timing is not altogether pedagogical.
15:15:07 <ski> (i noticed. afterwards :
15:15:08 <ski> :)
15:15:39 * firefly mistakenly thought for a moment there was a second parameter to result.
15:15:50 <firefly> (hence the reference to currying)
15:16:00 <firefly> mmorvant: ok, it looks like you've got that.
15:16:17 * ski thinks mmorvant defined result with two args earlier
15:16:29 <firefly> There are lots of other interesting things we talk about just in that single function definition but it would probably not be a good idea right now.
15:16:38 <firefly> Let's go on to the next little problem.
15:17:35 <firefly> ski: no, we are confusing him with ShaminoDC|FCK who left just before mmorvant joined.
15:18:14 <firefly> ShaminoDC|FBK, actually.
15:18:57 <ski> mm, right
15:19:17 <mmorvant> ok
15:20:05 <ski> enough with meta
15:20:26 <mmorvant> the actual value being passed into the result function is the parser 
15:21:04 <mmorvant> there are four different parsers, I am sure meant to confuse
15:21:09 <firefly> well, functions are values too.  No discrimination here.  Haskell is an equal opportunities language :)
15:22:03 <mmorvant> the papply is a built in function that take a string as an argument and applies a Parser function, correct?
15:22:10 <ski> equal rights for functional objects !
15:22:38 <firefly> mmorvant: I don't know.  I only learnt Haskell this week.
15:23:09 <mmorvant> you know more than me and I''ve looked at it on and off for a few months
15:23:14 <ski> mmorvant : yes :  papply :: Parser a -> String -> [(a,String)]
15:23:15 <firefly> @index papply
15:23:16 <lambdabot> bzzt
15:23:26 <firefly> @index Parser
15:23:27 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Prim
15:23:37 <mmorvant> thats cool
15:23:42 * ski 's not sure ParseLib is in the GHC libs
15:23:47 <firefly> apparently not.
15:23:51 <mmorvant> I don't think it is
15:24:11 <mmorvant> but it is in hugs
15:24:21 <ski> right
15:24:34 <mmorvant> do{char '!';digit;char 's';many(do char 's');return "Suc"} +++ do{char '%';char 's';digit;many(do digit);return "Suc"}
15:24:37 <firefly> Ah, there is no FC1 package for hugs.
15:24:43 <firefly> lovely! :)
15:24:59 <mmorvant> this is one of the parser functions
15:25:00 <ski> mmorvant : you need to reindent that
15:25:13 * firefly takes pen and papir to write that nicely indented.
15:25:30 * ski distantly remembers seeing this code before ..
15:26:01 <mmorvant> it would not surpirse me if others came asking as well
15:26:04 <ski> mmorvant : do you have a long file which contain some kind of password and such ?
15:26:12 <mmorvant> yup
15:26:26 <ski> (the one i'm thinking of was some months ago, at least)
15:26:39 <mmorvant> whatever you do don't just tell me the anwer if you already know
15:26:50 <mmorvant> that would break the rules of the game
15:27:30 <mmorvant> that long ago, might have been me, I try again every once and a while
15:27:53 <firefly> @index (++)
15:27:53 <lambdabot> bzzt
15:27:57 <firefly> @index ++
15:27:58 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
15:28:07 <firefly> @info (++)
15:28:10 <lambdabot> -- ++ is a variable
15:28:10 <lambdabot> infixr 5 ++
15:28:10 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
15:28:14 <ski> mmorvant : iirc, we didn't solve it (but he might have solved it by himself later)
15:30:11 <firefly> mmorvant: I am confused.  Doesn't that evaluate to something of the type M String, where M is some monad?
15:30:29 <firefly> String is a Char list, but I don't see how that can be turned into a list of pairs.
15:31:01 <firefly> (but remember that I do not know Parsec, the parser library)
15:31:02 <mmorvant> that was where my initial question of where does the list come from... came from
15:31:20 <ski> the list given to papply ??
15:31:29 <firefly> Ah, I am silly.  You just told me about papply.
15:31:36 <firefly> @info papply
15:31:55 <mmorvant> result [papply code2 x]
15:32:04 <mmorvant> that is the originating call
15:32:09 <firefly> papply :: Parser a -> String -> [(a,String)]
15:32:24 <firefly> And you just showed us code2?
15:32:42 <mmorvant> actually that was code3
15:32:46 <firefly> Then it is easy :)
15:33:03 <mmorvant> I am trying to keep things easy to look at
15:33:04 <ski> papply gives a list of pairs, result takes a String (correct ?)
15:33:06 <firefly> Ok, Parser is a kind of tag put on types for parsers.
15:33:18 <firefly> result takes a list of pairs :)
15:33:23 <mmorvant> yes
15:33:44 <ski> so you cant pass [papply code2 x] to result
15:33:48 <firefly> The "kind of tag put on types" has the technical name monad.
15:34:02 <ski> and you can't pass (pappöy code2 x) to result, either
15:34:20 <mmorvant> i had a feeling i was going to have to learn what a monad was at some point
15:34:45 <ski> firefly : don't scare him off with Confusing Theoretical Words (TM) !
15:34:55 <ski> :)
15:35:01 <firefly> Right.  Back to the syntactic sugar.
15:35:37 <firefly> The do notation is short hand stuff for manipulating stuff inside monads.  The Hindley-Milner type inference makes sure that you don't have to actually specify what kind of monads, though.
15:35:46 <monotonom> "monad" is no more confusing or scarier than "priority queue".
15:36:23 <ski> a little bit more, i'd say  (it's more general)
15:36:26 <firefly> ;)
15:36:29 <mmorvant> ok
15:36:46 <mmorvant> what does the +++ mean
15:36:50 <firefly> monotonom: yes it is
15:36:59 <firefly> ++ is easy, that's just list concatenation.
15:37:13 <firefly> Strings in Haskell are lists of chars.
15:37:17 <mmorvant> I know what ++ is 
15:37:20 <mmorvant> what is +++
15:37:22 <ski> parser1 +++ parser2  gives a new parser
15:37:42 <ski> first parser1 tries to parse it's input
15:37:48 * firefly misread :(
15:38:02 <mmorvant> thats quite alright
15:38:26 <ski> if it succeeds, then what it has succeded in parsing is what the whole new parser succeeds in parsing
15:38:27 <firefly> Is many equivalent to + or * ?  My guess is *.
15:38:27 <ski> ok ?
15:38:38 <firefly> Simple combinator parsing ;)
15:38:50 <mmorvant> noting seems simple
15:39:10 <ski> ok
15:39:21 <ski> char :: Char -> Parser Char
15:39:34 <ski> so  char 'A'  is a parser
15:39:36 <ski> ok ?
15:40:14 <mmorvant> I thihk I have it
15:40:21 <firefly> ski: how do parsers fail - by throwing an exception?
15:40:39 <ski> you can think of it like that, yes ;)
15:41:01 <firefly> do you want me to think of non-deterministic monads instead?
15:41:29 <ski> wasn't it mmorvant that wanted help ? :):)
15:41:40 <firefly> sure, I am just here to confuse.
15:41:54 <ski> np
15:41:56 <ski> ;)
15:42:13 <mmorvant> I am just starting to understand, but I have to pick up my daughter soon
15:42:30 <ski> ok
15:43:00 <firefly> I just remembered that to be an instance of the Monad type class, one just has to implement a few functions (I think it was >>, >>=, and friends).  So that gives a nice place to put the test/fail/succeed stuff.
15:43:14 <ski> so if you try  papply (char 'A') "ABC"  you get  [('A',"BC")]
15:43:20 <firefly> What type class does Parser derive from?
15:43:30 <mmorvant> parselib
15:43:35 <ski> firefly : no
15:43:54 <mmorvant> nm
15:44:07 <ski> firefly : it's not a type class. (but it's an instance of Monad (and MonadPlus, i think))
15:44:28 <ski> mmorvant : you can try out that simple example in hugs, right ?
15:44:56 <mmorvant> i will sure try
15:45:25 <mmorvant> [('A',"BC")] 
15:45:38 <ski> (if you try such small examples out, i hope you can understand more what the functions mean ..)
15:45:42 <ski> right
15:46:03 <ski> so the parser has succeeded in eating a single char 'A' from the input string
15:46:17 <ski> so the rest of the input is "BC"
15:46:24 <ski> you see that ?
15:46:24 <firefly> ski: right, I was sloppy with my terminology there.
15:46:39 <ski> firefly : np :)
15:47:21 <ski> mmorvant : ok ?
15:47:29 <mmorvant> I understood that one
15:47:37 <ski> now you can try
15:47:50 <ski> papply (char 'B') "ABC"
15:48:11 <firefly> Is many equivalent to + or * in regexes?  My guess is * (i.e. "zero or more")...
15:48:26 <ski> firefly : *, yes
15:48:40 <mmorvant> []
15:48:49 <ski> firefly : many1 is like +  (one or more)
15:48:55 <ski> mmorvant : right
15:48:58 <firefly> ok, thanks.
15:49:08 <ski> this means that it can't parse the input
15:49:32 <ski> it expected the input to start with 'B', but it didn't
15:49:35 <ski> so it failed
15:49:47 <mmorvant> got that
15:50:02 <ski> the list that you get back from papply is the list of all possible ways to parse the input
15:50:19 <ski> so if that list is empty, then we can't parse the input in any way
15:50:35 <ski> try
15:50:49 <firefly> ski: how is that list ordered?
15:50:59 <ski> papply (char 'A' >> char 'B') "ABCD"
15:51:18 <ski> firefly : depth-first, left-to right, i think
15:51:24 <firefly> ok, thanks.
15:51:35 <ski> mmorvant : did i go to fast ?
15:51:57 <firefly> >> just means that we connect the expectation of the character 'A' with the expectation of the char 'B'.  First one, then the other.
15:52:12 <firefly> (in this snippet, anyway)
15:52:20 <mmorvant> like +++
15:52:36 <ski> not quite
15:52:47 <firefly> no, there is a subtle difference, but never mind.
15:53:20 <mmorvant> well I understand the >> example at leat
15:53:24 <mmorvant> or least
15:53:24 <ski> good
15:53:32 <ski> so we can try
15:53:49 <ski> papply (char 'A' +++ (char 'A' >> char 'B')) "ABCD"
15:54:31 <ski> do you see what that is supposed to do ?
15:54:32 <firefly> in order to connect this with concepts you already know, think of +++ as 'or' and >> as 'and'.
15:54:40 <ski> yes
15:54:49 <firefly> This is not /quite/ the right intuition in general but it is close enough for now.
15:54:50 <mmorvant> ok that makes sence
15:55:36 <mmorvant> so that is the same as papply (char 'A') "ABCD"
15:55:43 <ski> no
15:55:43 <firefly> depth first, you say?  [("AB", "CD"), ("A", "BCD")] or something like that ?
15:55:45 <ski> hmm
15:55:50 <ski> yes
15:56:09 <mmorvant> as long as papply(char 'A' >> char 'B') "ABCD" is valid
15:56:14 * ski just realized he forgot one thing
15:56:38 <ski> right
15:57:15 <ski> in   (p0 +++ p1)   if p0 succeeds in parsing, then we just ignore p1
15:57:34 <mmorvant> but if p0 fails then try p1
15:57:38 <firefly> ah, ok. Makes sense, but you said that we got /all/ the parses?
15:57:40 <ski> but if p0 fails to parse the input, only then do we try out parsing with p1
15:57:42 <ski> right
15:58:07 <mmorvant> p0 >> p1 and p0 fails don't bother with p1
15:58:07 <ski> firefly : i was thinking of using `mplus` . then you get all parses
15:58:13 <firefly> ok :)
15:58:31 <ski> mmorvant : no. if p0 fails, then we *bother* with p1
15:58:52 <firefly> maybe I should just look the remaining details up.
15:58:54 <mmorvant> i thought >> was like or
15:59:02 <mmorvant> i mean and
15:59:05 <ski> it's like (sequential) and
15:59:07 <ski> right
15:59:52 <mmorvant> wouldn't that make the outcome of p1 irrellevant
16:00:08 <firefly> ski: I think there is a typo there.
16:00:34 <firefly> we have p0 >> p1, p0 fails, then there is no reason to try p1.
16:00:37 <ski> so if you exchange +++ with `mplus` in that example above, then you get [('A',"BCD"),('B',"CD")] instead of [('A',"BCD")]
16:01:13 <mmorvant> thats what I thought
16:01:21 <ski> mmorvant : soory, i didn't read correctly :)
16:01:34 <ski> i was of course speaking of >>>
16:01:44 <ski> aargh ++
16:01:46 <mmorvant> I really enjoyed this but I have to go
16:01:46 <ski> +++
16:01:49 <ski> ok
16:01:54 <firefly> bye :)
16:02:00 <mmorvant> I hope to catch you guys later
16:02:08 <ski> you were correct about >>, anyway
16:02:11 <ski> ok, bye
16:02:22 <mmorvant> bye
16:03:11 <ski> firefly :  p0 +++ p1 = first (p0 `mplus` p1)   iirc
16:03:38 <firefly> neat :)
16:27:10 <firefly> I am looking through the "Wearing the hair shirt - A retrospective on Haskell" slides.
16:27:40 <ski> hmm ?
16:27:43 <ski> where ?
16:27:50 <firefly> On the slide with the heading "But..." (slide #20) Simon writes:
16:28:16 <firefly> "And it's not so bad only having \beta{}V instead of \beta|
16:28:17 * ski haven't seen those slides ..
16:28:20 <firefly> Does anybody know what he meant?
16:28:28 <ski> oh
16:28:29 <firefly> There's a link on his homepage.
16:29:04 <firefly> You can get them in powerpoint format or as pdf (1up) or pdf (2up).
16:29:20 <ski> i think he's referring to the beta_V and beta reduction rules in lambda calculi
16:29:32 <firefly> (I don't have the browser ready on this machine so I can't easily give you the link)
16:29:41 <firefly> beta_V ?
16:30:15 <firefly> I don't think it was on the course material I saw - but it's been 6 years or so :( -- and a brain crash, of course.
16:30:45 <firefly> are we talking about different degrees of eagerness/strictness?
16:31:13 <firefly> (and consequently, different termination properties...)
16:32:59 <ibid> never heard of beta_V
16:34:22 <ibid> google hints that plotkin uses beta_V for beta reduction using the call by value strategy (applicative order, iirc)
16:34:46 <firefly> thanks :)
16:35:21 <ibid> a phrase google shows often in this context is "call-by-value lambda calculus"
16:35:22 <ski> (\x. e) v  --beta_v--> e[x:=v]
16:35:38 <ibid> yeah, assuming that v is in normal form
16:35:46 <ski> beta-v only reduces lambda abstractions which are applied to values
16:36:10 <ski> (i.e. that argument must be reduced to a value before "calling" the function)
16:36:19 <firefly> great :)
16:36:26 <firefly> That /does/ explain everything :)
16:36:40 <ski> (\x. e0) e1  --beta--> e0[x:=e1]
16:36:48 <firefly> no need to elaborate.
16:37:20 <ski> here we can reduce e1 how much (or little) we want before "calling" the function
16:37:21 <ski> ok
16:38:50 <ibid> is there a beta-V-like name for normal-order beta reduction?
16:44:05 <ski> ibid : hmm ?
16:44:35 <ibid> ski: ?
16:45:08 <ski> what do you mean by a 'beta-V-like name' ?
16:45:42 <ibid> a name like beta-V
16:45:43 <ibid> :)
16:46:02 <ibid> a name like beta-V is for applicative-order beta reduction
16:49:19 <ski> hmm, bot sure there's such a thing
16:49:26 <ski> s/bot/not/
18:20:13 <mmorvant_> ski you still there
18:47:01 <Lemmih> Argh, the nehe lessons are getting advanced /-: I'm probably gonna read some theory before I continue.
21:13:14 <Crusoe__> Does GHC support O'Haskell features?
21:16:19 <Cale> No
21:16:37 <Cale> It would be nice if it had some of them.
21:16:54 <Cale> and O'Haskell is called Timber now.
21:17:13 <Crusoe__> I love Python, I like what I've seen of Haskell. I'd kill for a blend of the two... :/
21:17:45 <Cale> well, you can get a lot of object oriented patterns going in Haskell as is.
21:17:57 <Cale> especially with the addition of existential types
21:19:26 <Cale> Records in Haskell can have functions in them. :)
21:20:14 <Cale> There's no subtyping, but there are type constructors.
21:20:28 <Riastradh> I've found that typeclasses are generally much more useful for what I'd otherwise have used an object system for.
21:21:00 <Cale> yes, and typeclasses :)
21:21:54 <Cale> So everything is there in some fashion, it's just not collected together in the same way. The emphasis is different.
21:24:15 <Crusoe__> But see, Timber/O'Haskell had a nice system all set up to deal with interactive applications. The pure Haskell examples I've seen get lost in monad mangling... :/
21:25:51 <Cale> Timber/O'Haskell use monads too
23:15:22 <Verbophobe> Did everyone see Fahrenheit 9/11 yet?
23:26:18 <heatsink> no
23:29:20 <Verbophobe> Then allow me to mention that you're in for quite a show.
