00:24:12 <jemfinch> it's rather entertaining.
00:24:26 <jemfinch> my mind has become so anal as to automatically translate split infinitive into unsplit infinitives.
00:24:58 <jemfinch> I actually have to read split infinitives twice -- once with the automatically translation in place, and a second time to reaffirm that the "automatic translation has taken place" flag was applied correctly.
00:28:29 <Gahhh> happens to everyone
00:28:39 <Gahhh> take this blue pill
01:00:21 <blackdog> jemfinch: "to translate automatically", you mean?
01:17:34 <jemfinch> blackdog: hah
01:17:41 <jemfinch> I tried not to split any infinitives in those sentences.
01:17:50 <jemfinch> but I have an automatic translator, it's hard!
01:20:02 * shapr hOps
01:20:19 <shapr> good morning #haskell
01:20:32 <det> g'mornin'
01:20:43 <shapr> wassup?
01:20:56 <shapr> hy Hyp3rion 
01:21:55 <Hyp3rion> hi shapr!
01:22:13 * shapr sings the good morning song
01:22:16 <Hyp3rion> haskell is so hard to learn :-/
01:22:19 <shapr> it is?
01:22:23 <Hyp3rion> i dunno
01:22:26 <shapr> do you have any questions I can help you with?
01:22:30 <Hyp3rion> it seems easier than C
01:23:28 <shapr> is there something in particular that seems hard right now?
01:24:24 <Hyp3rion> shapr - well, i like learning a language by trial and fail, but i cannot learn haskell this way because of this difference in theory, so i guess only reading the tutorial another time can help
01:24:58 <shapr> you could use the tutorial to support your trial and error approach
01:25:17 <shapr> I like to start with simple working examples and change them to see if I understand the example
01:28:03 <Hyp3rion> or maybe i should pay more attention on math classes :-) the first thing i learnt when learning to program was how to increase the value of a variable by 1... now all this doesnt even make sense in functional programming so its like starting from the basicsa again.
01:28:22 <shapr> inc n = n + 1
01:28:35 <shapr> variables in Haskell are immutable
01:28:42 <Hyp3rion> yes
01:28:45 <shapr> but you can get a new value that is one larger
01:29:02 <shapr> that's usually close enough
01:29:20 <Hyp3rion> and, btw if i never use the old value that gets garbage collected?
01:29:25 <shapr> yes
01:30:24 <Hyp3rion> so calling inc 100 times will be equivalent in the end to increasing it in a loop? i mean in the resulting asm?
01:31:01 <shapr> in many cases, a recursive call will become a loop internally
01:31:17 <shapr> but only when the compiler sees that is safe
01:31:36 <shapr> that's called "tail call optimization"
01:33:14 <Hyp3rion> and totally unrelated, but if i compile with ghc -smp, the resulting code will be multithreaded automatically even if i didnt write any explicit multithreaded code?
01:34:02 <Hyp3rion> or -parallel
01:34:27 <shapr> no, the only way to do that right now is to use the Parr library from the Nepal project.
01:34:37 <Verbophobe> That would be a killer feature, though.
01:34:53 <shapr> automatic parallelization is the big dream of a non-strict evaluation order language
01:35:02 * Philippa_ wonders if she's the only one who occasionally wishes the do notation had a way to write "if (resultofcomputation)" and similar...
01:35:14 <Philippa_> (rather than the longwinded r <- resultofcomputation; if (r))
01:35:14 <shapr> Philippa_: tried when?
01:35:25 <shapr> @index when
01:35:25 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
01:35:25 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
01:35:25 <lambdabot> State,Control.Monad.Writer,Monad
01:35:33 <shapr> @type Control.Monad.when
01:35:35 <Philippa_> guess that'll do for now :-)
01:35:35 <lambdabot> Control.Monad.when :: forall m. (Monad m) => Bool -> m () -> m ()
01:35:55 <shapr> hm, maybe it's not when I'm thinking of...
01:35:58 <Philippa_> hrmm, wait, it takes a Bool not an m Bool
01:35:59 <Philippa_> yeah
01:36:00 <shapr> @index whenM
01:36:00 <lambdabot> bzzt
01:36:19 <shapr> I think there is a 'whenM'
01:36:51 <shapr> automatic parallelization only exists in a limited form right now
01:37:18 <Philippa_> yeah. Hell, I don't even want /that/, I just want something that deduces the order of calls based on necessity and the fact all funcs have exactly one parameter
01:37:32 <shapr> with arrows, it would be relatively easy to prove that certain parts of a program can be parallel
01:37:46 <Philippa_> don't mind having to shove an operator in front of each computation to avoid the overloading
01:37:55 <shapr> Philippa_: eh?
01:38:02 <shapr> g'mornin Iter 
01:38:09 <Iter> evening shapr.
01:38:28 <Philippa_> given that c,d,e are computations, something like c(#d(#e)), where # is whatever operator you pick
01:38:43 <Philippa_> actually wait, I guess that's just >> backwards?
01:38:56 <shapr> @type (>>)
01:38:58 <lambdabot> (>>) :: forall m b a. (Monad m) => m a -> m b -> m b
01:39:04 <shapr> @type (>>>)
01:39:06 <lambdabot> bzzt
01:39:09 <shapr> bah
01:39:15 <Philippa_> anyway, gotta go rescue some toast, brb
01:39:38 <shapr> @type (=^.^=)
01:39:40 <lambdabot> bzzt
01:39:56 <andersca> @arr
01:39:56 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
01:46:35 <shapr> Hyp3rion: right now, the only automatic parallelization I know about requires that your program can be expressed as array operations, since those can be automatically flattened and parallel
01:47:12 <shapr> of course, I'm limiting this to software that you can download and run today
01:47:45 <Hyp3rion> :-) i just tought referentially transparent + lazy ==> order of evaluation doesnt count, so it can be parallel too
01:47:58 <shapr> yes it can be!
01:48:29 <shapr> and I think one of GdH or GpH does work that way
01:49:06 <shapr> but the most common way to do parallel stuff with GdH/GpH is to explicitly give hints with the 'par' and 'seq'(?) ops 
01:49:20 <Philippa_> is there a name for type unification when there's a subtyping relationship involved and one of the two parms is the (possible) supertype of the other?
01:49:38 <Philippa_> ala supertype `unify` subtype?
01:52:27 <Philippa_> guess I could treat it as an assertion and call it "subsumes"?
01:52:31 <Hyp3rion> anyway i think i can phrase it: so in yaht i could do all the excersises so far, but sometimes i need to get something done like firewall testing lately and i did that in sh and python. but it's like learning a new reallife language and if i use some other language meanwhile i just get confused. so i think i'll have to stop all coding till i get the basics of haskell
02:35:33 <shapr> Hyp3rion: or you could try to rewrite your sh and python in Haskell
02:35:44 <shapr> at first I couldn't do it, but each time I tried I got a little closer.
02:42:25 <Hyp3rion> ^_^ i tried but no luck. maybe next time
02:55:12 <shapr> hoi arjanb
02:55:20 <shapr> how's code?
02:58:39 <arjanb> no time for coding because it's the last week of this semester
03:00:09 <Lemmih> Hmm "My" bmp loader is fscked /-:
03:00:43 * shapr continues to play with 0-day H4sk3ll w4r3z
03:06:49 <shapr> g'day gp 
03:09:28 <Lemmih> Yay! It's working!
03:09:33 <shapr> w00
03:09:36 * Lemmih does the happy dance.
03:09:44 * shapr too
03:10:25 <Lemmih> Now I can get on converting the next nehe lesson.
03:10:47 <shapr> oh, you're doing NeHe's stuff? I thought that was all about OpenGL?
03:10:57 <firefly> @type show
03:10:59 <lambdabot> show :: forall a. (Show a) => a -> String
03:11:02 <Philippa_> urgh, NeHe...
03:11:31 <Lemmih> shapr: I'm translating all his lessons to Haskell.
03:11:36 <shapr> oh cool!
03:11:40 <shapr> how far have you gotten?
03:12:00 <Lemmih> Lesson 5. Lesson 6 is about texture loading...
03:12:51 <Taaus> To real Haskell or to "Look! I can write C in Haskell" Haskell? :)
03:13:21 <shapr> do you have the lessons online somewhere? maybe in a wiki?
03:17:15 <Lemmih> Taaus: Well... the C examples have _a lot_ of glVertex3f's, I just iterate over a list of coordinates.
03:18:09 <Lemmih> But I'm not a super Haskeller so it probablly could be done better.
03:19:21 <Lemmih> shapr: Maybe I could post them on the HaWiki when I'm done.
03:19:23 <Taaus> Ah. Well, I guess that part of the code will be pretty similar to the C version no matter what.
03:19:29 <shapr> Lemmih: that would be cool
03:34:13 * Philippa is rapidly discovering that wrapping more than one monad transformer around the ST monad gives irritating types when you try to lift stuff to the ST monad...
03:41:38 <Philippa> aww, you can't use an expression as an infix operator :-(
03:41:53 <shapr> yah, that would be nice
03:44:17 <Verbophobe> Woot.  Just finished something that recursively lists directories with a few parameters.  It was significantly more painful then I had imagined...
03:48:24 <shapr> hei musasabi, ltns
03:48:31 <musasabi> hello shapr 
03:48:31 <shapr> how's the big city treating you?
03:49:04 <shapr> tiedatko ohjelmointia?
03:49:18 * shapr butchers that fine finnish language again :-)
03:49:34 <firefly> anybody know where I can find the hsdebug source?  (and the source for a version of ghc that uses optimistic evaluation so I can actually use hsdebug)?
03:49:49 <shapr> firefly: you gotta pull the spec_eval branch of cvs
03:49:55 <musasabi> shapr: ei en laisinkaan ;)
03:50:10 <shapr> spec_eval and hsdebug are currently limited to 5.04.2 I think
03:50:10 <firefly> thanks!
03:50:16 <firefly> oh.
03:50:36 <ozone> firefly: i've never gotten it to compile
03:50:54 <firefly> grrrr.
03:50:55 <ozone> if you do, please let me know. :)
03:50:57 <shapr> I swapped emails with Robert Ennals and Simon Marlow about updating spec_eval to 6.x, I heard it was a *lot* of work.
03:51:17 <firefly> sigh.
03:51:26 <shapr> firefly: but if you decide to start working on it, I may join :-)
03:51:36 <shapr> I think spec_eval has other worthwhile benefits
03:51:48 <firefly> absolutely!
03:52:04 <shapr> firefly: and for you, spec_eval has all the comforts of home with all the benefits of living in Haskell land!
03:52:05 <firefly> But I'd rather hack on mosml than on Haskell, so...
03:52:28 <shapr> yah, I understand
03:52:41 <firefly> The benefits of living in Haskell land??!
03:53:14 <ozone> firefly: mosml?
03:53:15 <shapr> sure, you get all the benefits of strict ML, where it doesn't interfere with any of the Haskell goodies.
03:53:35 <firefly> I think Haskell has the same problems as PL/I, Ada, and Perl:  too many ways of doing the same things.  Too hard to predict what is going on with only local information (say a single expression or a short chunk of code).
03:53:45 <ozone> firefly: !
03:53:48 <firefly> 1) People end up programming in their own private languages.
03:53:54 <ozone> sorry, i disagree totally with that
03:54:10 <firefly> ozone: Moscow ML.
03:54:25 <shapr> domain specific languages are one approach to writing Haskell programs, but I consider that a benefit
03:54:25 <firefly> 2) there are too many places to look, too much to hold in ones head when trying to find out what is meant by an expression or an identifier.
03:54:33 <firefly> It is better than PL/I in this regard, but... ;)
03:54:51 <shapr> hm, it doesn't seem that way to me
03:55:09 <firefly> shapr: but Haskell tends to leak through - so you can't just teach a small DSL to somebody.  They'll have to know some Haskell too.
03:55:12 <ozone> firefly: shrug, i disagree with you
03:55:18 * firefly LIKES dsls.
03:55:51 <firefly> ozone: let me put it this way: it looks like it has become the C++ of functional languages ;)
03:55:51 <shapr> anyway, there is a tradeoff you get between programmer written explicit behaviour, and offloading complexity to the system/environment/whatever
03:56:00 <firefly> sure.
03:56:18 <ozone> firefly: again, i disagree
03:56:25 <shapr> non-strict eval means execution order cannot be predicted by the programmer
03:56:28 <ozone> if you speak of GHC's language extensions, perhaps
03:56:30 <musasabi> That is true to a point.
03:56:38 <ozone> but compare the complexity of haskell vs the complexity of o'caml
03:56:50 <firefly> o'caml is much simpler!
03:56:54 <shapr> one of the great benefits of Python is that it uses reference counting, so you always know *how* and *when* things go away, and when they are executed
03:57:05 <musasabi> For any given problem there are dozens of ways of solving it many of which are elegant but quite hard for a beginner to understand.
03:57:09 <firefly> shapr: Yes, that sometimes /very/ nice.
03:57:13 <titanstar> non-strict evaluation order means that complex buffering logic for efficient calculations can be stripped away
03:57:15 <firefly> musasabi: precisely.
03:57:17 <titanstar> that's good too
03:57:29 <ozone> firefly: functors, objects?
03:57:30 <firefly> titanstar: also true.  A good point in the other direction.
03:57:40 <firefly> ozone: sure, simple :)
03:57:43 <shapr> but in Haskell, I give up some of that knowledge of the details of the system, and rely on 'implied' behaviour to get faster coding
03:58:20 <ozone> firefly: i guess you consider functors and objects to be more simple than i do
03:58:23 <musasabi> Usually with my skills most problems are with monads making the code messy.
03:59:03 <shapr> I had some space leaks when I started, but not so much now
03:59:32 <musasabi> This code uses monad X, which can be combined with A,B,C but not D,E,F and it is used instead of Y, because some myriad reason...
03:59:53 <shapr> musasabi: yah, I agree with that, I'm thinking we should switch to arrows and be done with it.
04:00:18 <firefly> Type error messages are another huge problem with ML and Haskell like languages.
04:00:33 <shapr> there's a good solution in progress for that
04:00:35 <shapr> type error slicing
04:00:43 <firefly> Frank Tip.
04:01:02 <firefly> I printed that out last week (or the week before?).  Haven't read it yet.
04:01:02 <Lunar^> shapr: type error slicing is cool
04:01:18 <shapr> firefly: Sebastian Carlier :-)
04:01:29 <Lunar^> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
04:01:45 <musasabi> I think haskell error messages are not too bad... but then I am used to complex C++ monsters...
04:01:59 <Lunar^> shapr: It's mostly Joe Wells' idea AFAIK
04:02:05 <shapr> ok
04:03:14 <firefly> SEN-R9824, "A slicing-based approach for locating type errors", T.B. Dinesh, Frank Tip.  (Centrum voor Wiskunde en Informatica)
04:03:17 <shapr> firefly: personally, I think we need more real-world libraries.
04:03:29 <Igloo> Errors have improved significantly in recent times
04:03:32 <firefly> shapr: Absolutely!
04:03:41 <firefly> shapr: and easy interfacing with C, Perl, and Python.
04:03:54 <shapr> if commercial usage of Haskell increases, there will be funding to fix all the other problems
04:03:58 <musasabi> most other types can be inferred but monad functions are usually defined only on a specific type.
04:04:02 <ozone> c's getting done now
04:04:03 <shapr> firefly: C and Python interfacing is pretty easy already
04:04:05 <ozone> perl and python are coming. :)
04:04:23 <Lunar^> Haskell FFI is one of the easiest C language interface I know
04:04:36 <shapr> skew's PHI (Python Haskell Interface) is nifty
04:04:39 <Igloo> Will perl be anything other than FFI+XS?
04:04:46 <Igloo> Or do you mean tools to automate the dull bits?
04:04:55 <ozone> Igloo: both, hopefully
04:04:59 <ozone> don's working on it with hs-plugins
04:05:11 <Igloo> Aha, cool
04:05:33 <ozone> we've got hs_eval working in C, which is neat
04:05:47 <ozone> (not sure if it's entirely practical, but it _is_ neat :)
04:06:36 <Igloo> Tell you what, get an apache mod_haskell that performs well and that I can use with WASH and I'll be impressed  :-)
04:07:23 <ozone> :)
04:08:37 <Igloo> I don't think it should even be that hard given what you've done already, should it?
04:09:10 <ozone> well, a basic mod_haskell wouldn't be very hard.  but it'd be pretty baic
04:09:12 <ozone> +s
04:09:22 <ozone> a full-featured mod_haskell on par with the likes of mod_perl is another story
04:10:01 <Igloo> What sort of features are in the one but not the other?
04:11:03 <JaffaCake> someone did a mod_haskell a while back, if I'm not mistaken
04:11:40 <shapr> yah, but it hasn't been updated since 2002 or so
04:11:40 <Igloo> I think that just interpreted things with hugs, though
04:11:44 <ozone> Igloo: the case i was thinking of is having a haskell RTS resident in mod_haskell, and being to load and execute object files
04:11:51 <ozone> ala ghci
04:12:05 <ozone> that would be fairly challenging
04:12:18 <JaffaCake> would be nice indeed
04:12:18 <ozone> and that's what i meant by 'full-featured'
04:12:22 <shapr> you could just proxy via apache to a haskell server
04:12:26 <Igloo> Oh, OK, I thought the dynamic module loader would have made it fairly easy
04:12:41 <shapr> hej ticPalm
04:12:41 <ozone> Igloo: maybe
04:12:51 <ozone> Igloo: my brain's too frazzled right now to think about it :)
04:12:57 <Igloo> :-)
04:13:00 <shapr> ticPalm: anvÃ¤nder du IRC med PalmOS?
04:13:21 <JaffaCake> one problem I can see is unloading modules again: GHC's RTS doesn't support this, so you get a space leak
04:13:48 <ozone> apachectl -k restart every 10 minutes, no problem. ;)
04:14:00 <Igloo> Oh, I thought lambdabot had an unload command. Or was that just leaking space?
04:14:03 <ozone> JaffaCake: will you be at haskell workshop this year?
04:14:11 <JaffaCake> yep
04:14:12 <firefly> From page 3 in "Type Error Slicing in Implicitly Typed Higher-Order Languages":
04:14:22 <shapr> lambdabot does have an unload command, no idea if it leaks or not
04:14:25 <ozone> ooo.  i really hope dons can trug along then
04:14:26 <JaffaCake> Igloo: it probably leaks space, yes
04:14:34 <ticPalm> shapr, japp. lunchrast på jobbet
04:14:35 <firefly> 1.3 Related Work.  Dinesh and Tip have applied slicing techniques for locating sources of type errors [8].
04:15:11 <shapr> iirc, there *is* unload code in GHC, it just isn't turned on
04:15:15 <shapr> or something like that
04:15:28 <firefly> Their techniques are applicable to /explicitly/ typed languages.  Their approach depends on the fact that the type system can be expressed as a rewrite system, and they use techniques for origin and dependency tracking in rewrite systems to find error locations.
04:15:45 <shapr> of course, arguing with JaffaCake about GHC internals is likely an exercise in futility.
04:16:01 <JaffaCake> :)
04:16:15 <firefly> Although type inference algorithms for implicitly typed languages can be phrased as rewrite systems, a large part of the rewrite rules would concern auxilliary functions, i.e., unification and constraint solving.
04:16:19 <JaffaCake> GHC's unload does everything except actually unload the object code
04:16:42 <JaffaCake> the problem is that it can't check whether there are any references left from the heap into the object to be unloaded
04:16:48 <firefly> For this reason, we do not believe that a direct application of Dinesh and Tip's methods results in accurate location of type error sources in languages with type inference.
04:16:56 <JaffaCake> well it could... but it's difficult
04:17:07 <shapr> JaffaCake: how so?
04:17:18 <firefly> <end-quote>
04:17:36 <shapr> actually, I probably wouldn't understand the answer...
04:17:46 <JaffaCake> so you have to do a complete GC, and for each closure check whether the info pointer is pointing into the offending object
04:17:53 <shapr> ah
04:18:16 <JaffaCake> if there is such a reference, then you can't unload the object
04:18:18 <ozone> shapr: put it this way, mac os x allows dynamic loading of objective-c classes, but not unloading
04:18:36 <ozone> shapr: that's roundabout way of saying "not worth it to invest the time on this problem" :)
04:18:40 <shapr> right, I see
04:18:53 <shapr> too bad, it would be one step closer to runtime upgrading of code
04:19:02 <ozone> unloading stuff in general is rather non-trivial
04:19:19 <JaffaCake> the nature of Haskell makes it harder too...
04:19:20 <ozone> best way to do it is to re-use code for doing that already: the OS's dlclose()
04:20:11 <shapr> I'd like to write an emacs-style editor in Haskell that allows the same interactive eval and upgrade of code as elisp does
04:20:16 <ozone> JaffaCake: hey, is the newCAF issue the last remaining problem with haskell libs as .so's?
04:20:17 <JaffaCake> you can't in general unload part of a program, even if you've finished with it, because you might still have unevaluated closures that refer to the old code
04:20:29 <JaffaCake> ozone: no
04:20:34 <ozone> d'oh
04:21:05 <firefly> shapr: wouldn't visual basic, visual C++, delphi, and smalltalk be better sources of inspiration?
04:21:16 <shapr> firefly: for what?
04:21:43 <firefly> writing an editor with interactive upgrade of code.
04:22:05 <JaffaCake> the .so issue is complicated... I think the story is that you can dynamically link .so's into a running binary, but you can't create a dynamically linked binary
04:22:08 <shapr> firefly: Haskell inspires me :-)
04:22:34 <shapr> firefly: Self and Morphic were nifty, but they didn't fly
04:22:37 <firefly> Yes, sure, do it for Haskell, but use Visual *, Delphi, and Smalltalk as inspiration instead of emacs.
04:22:42 <firefly> Sure, self, too.
04:22:43 <ozone> JaffaCake: are the notes that you have at www.haskell.org/~simonm still accurate?
04:22:47 <firefly> Don't know Morphic.
04:22:52 <JaffaCake> ozone: yes, I think so
04:22:56 <ozone> okie
04:22:59 <firefly> Emacs is not exactly famous for good usability.
04:23:05 <ozone> i'm going to prod don and see if we can work out the issue
04:23:06 <shapr> it's famous to me
04:23:18 <JaffaCake> ozone: that'd be cool
04:23:21 <ozone> firefly: usability isn't the issue here, dynamic loading of code is
04:23:27 <firefly> More like infamous or notorious?
04:23:36 <shapr> I use emacs for nearly everything
04:23:36 <JaffaCake> first step is to see if you can dynamically load Haskell code using dlopen() instead of the RTS linker
04:23:49 <ozone> and in that regard, emacs is better than most of those examples you cite (smalltalk being an exception)
04:24:11 <shapr> irc, email, news, shell, music player, calender, diary, browser, and so much more
04:24:19 <ozone> JaffaCake: yep
04:24:20 <firefly> The microsoft things can actually let you stop a program, change the code, and then resume execution.
04:24:32 <shapr> yes, I like that feature
04:24:40 <Philippa> great way to screw up your invariants though
04:24:48 <shapr> I think that gained popularity in smalltalk long ago
04:24:56 <JaffaCake> firefly: yes, but do you have any idea how much effort that took to get working :)
04:24:58 <shapr> even so, smalltalk has an image problem
04:24:58 <ozone> firefly: sure, and that's existed in smalltalk for donkey's years
04:25:03 <firefly> shapr: yes.
04:25:10 <JaffaCake> I heard one of the VS developers moan about it once
04:25:18 <shapr> mostly the Image itself
04:25:43 <firefly> JaffaCake: I know it is hard to do - but something that makes programming lots more accessible (and also more comfortable to the experts)
04:26:02 <ozone> JaffaCake: hey, one of my mates used that to add saving capability to his level editor (for a game), because he made a nice level in it without save features.  edit and continued with saving features, and it worked perfectly
04:26:12 <ozone> JaffaCake: so next time you talk to a VS developer, please thank them :)
04:26:22 <JaffaCake> hehe, will do
04:26:23 <shapr> I not a fan of debuggers, but I sure do like HUnit and QuickCheck
04:26:51 <Philippa> I'm a great fan of debuggers in impure languages
04:26:58 <JaffaCake> so, who would like a Haskelll debugger ala gdb?
04:26:59 <firefly> shapr: They can be very good for giving you a handle on those 10K lines of code you have just inherited.
04:27:16 <firefly> JaffaCake: Not me - I hate gdb with a vengeance ;)
04:27:17 <shapr> firefly: I'd argue for Unit tests instead
04:27:21 <ozone> JaffaCake: oh yeah, i've tried compiling speceval2 about five times in the past year, and it's always bombed
04:27:31 <ozone> do you know if it's actually meant to compile? :)
04:27:35 <firefly> Add some usability instead and I am all for it :)
04:27:37 <JaffaCake> no :)
04:27:40 <shapr> if you hit a man with a fish, he'll have a headache for a day. If you teach a man to hit himself with a fish, he'll have a headache his entire life!
04:27:44 <JaffaCake> i.e. I don't know, but probably not
04:27:50 <Igloo> I'd love a Haskell debugger that can debug programs that use Control.Monad.State
04:28:01 <ozone> i emailed robert about it, but he said it was OK for him
04:28:01 <shapr> seriously, debuggers are once-off problem checkers, unit tests and quickcheck are repeatable
04:28:07 <firefly> shapr: you don't always have the luxury of adding unit tests and refactoring for weeks until the program is clear.
04:28:09 <ozone> so i suspect some missing CVS entries.  anyhoo
04:28:23 <ozone> (and yes, i'd love gdb for haskell)
04:28:41 <shapr> firefly: you don't always have the luxury to *not* do it that way.
04:28:55 <JaffaCake> sometimes unit tests aren't practical, e.g. constructing input for a phase of GHC isn't possible
04:28:59 <firefly> What do you think is more common, Shae?
04:29:08 <shapr> lemmings!
04:29:26 <shapr> I really do think it's like climbing rocks without ropes though
04:29:36 <shapr> JaffaCake: why not?
04:30:05 <JaffaCake> because the state of the compiler is absolutely huge and recursive
04:30:32 <shapr> firefly: yes, in all of my employee jobs I've had to deal with zero unit tests and lots of never executed before checked-in code
04:30:42 <JaffaCake> the contents of loads of interface files... internal representations of types/classes/instances... etc. etc.
04:36:14 <shapr> Could you unit test all the pieces, and then run end to end tests at the top level?
04:36:14 <shapr> s/you/one
04:36:15 <shapr> can you name a file that holds a GHC phase?
04:36:15 * shapr browses the GHC 6.2 sources
04:36:15 <firefly> If I had had a decent debugger/program viewer (perhaps with slicing) for C, I wouldn't have had to spend so much time refactoring tmdns (a zerconf dns thingy).  After ~170 cleanup/bugfix patches in darcs I am getting closer, though.
04:37:25 <firefly> Yes, it is quite common :(
04:37:25 <firefly> The code shouldn't have been written like that in the first place - I am quite sure we agree on that.
04:42:18 <musasabi> writing unit tests is not sufficient to check things...
04:42:18 <Lunar^> shapr: Did you read Scott Collins on ArsTechnica ?
04:42:18 <musasabi> contracts are imho more valuable in many places.
04:45:44 <musasabi> I am thinking of a xml templating solution (data from db, output xml from templates) what xml library would make sense? (HaXml / hxml / haskell xml toolbox / some other)
04:45:44 * Igloo reads the lists and finds debuggers probably didn't pop up completely randomly
04:45:44 <firefly> I missed that then.  What caused it?
04:46:08 <Igloo> Fergus Henderson, "modern language design, stone age tools"
04:46:28 <firefly> Yes, I saw that post.
04:46:55 <firefly> But I was voicing my desire for a debugger yesterday (Danish time) before I had read a single post in that list.
04:55:54 <ozone> Igloo: i wonder if mercury has an advanced debugger. :)
05:00:12 <kosmikus> ozone: :)
05:01:04 * Philippa does a victory dance
05:01:11 <Philippa> my typechecker now understands subtyping!
05:01:28 <Philippa> OTOH the parser doesn't know how a subtype's declared, but hey
05:11:43 <Verbophobe> Hey, what would be a good way to randomize a list?
05:12:46 <Lemmih> Isn't there a function like that in the PreludeExt?
05:12:47 <Verbophobe> Lemme check.
05:12:53 <ski> think that was discussed for some time ago on c.l.f
05:14:02 <Verbophobe> Forgive my asking, but what's PreludeExt?
05:14:17 <Verbophobe> I read "Prelude" first time.
05:14:42 <Cale> http://www.haskell.org/hawiki/PreludeExts
05:24:05 <Cale> How about unsafeRandomPermuteIO? It takes an IO action and returns a new IO action where everything occurs in a completely unspecified order. :)
05:25:05 <Verbophobe> Heh.  I don't think that would be random *enough*.
05:25:54 <Verbophobe> Hey, what's the difference between "data" and "newtype"?
05:26:39 <ski> 'newtype'-defined types have exactly one constructor with exactly one argument
05:27:06 <ski> and are isomorphic to the type of that argument (i.e. noo extra bottom)
05:27:11 <Verbophobe> Oh.  Why not just make them 'data's?
05:27:14 <Verbophobe> Ah.
05:27:20 <ski> ok ?
05:27:22 <ski> :)
05:27:36 <Verbophobe> Good to know :)
05:27:36 <firefly> datumses?
05:27:45 <Verbophobe> datii
05:27:57 <ski> data is plural, iirc
05:28:02 <firefly> No, it is Greek.  Maybe datata?
05:28:16 <ski> (singluar is 'datum', i think)
05:28:23 <Cale> ski is right
05:28:36 <firefly> ski: precisely.   My eyeballs hurt everytime I see people write datas.
05:28:42 <firefly> every time, of course.
05:29:21 <kosmikus> datum is greek?
05:29:29 <kosmikus> I don't think so
05:29:46 <ski> (latin, i would think. not sure)
05:29:49 <kosmikus> yes
05:30:02 <Verbophobe> Yeah, but the keyword is "data".  Only seems natural to refer to several data keywords as datas...
05:30:02 <Cale> datum ('deIt&schwa.m). Pl. data ('deIt&schwa.). [L. datum given, that which is
05:30:03 <Cale> given, neut. pa. pple. of dare to give.]
05:30:09 <kosmikus> from dare, to give
05:30:12 <Cale> L. datum
05:30:12 <kosmikus> yes
05:30:14 <firefly> I don't think so either.  It's just that the plural looks a bit like lemmata, stigmata, etc.
05:30:26 <firefly> Yep.
05:30:42 <firefly> Btw. the grammatical case "dative" also comes from that verb.
05:31:08 <Verbophobe> Didn't know that.
05:37:06 <Verbophobe> See, as far as list randomization goes, I just assigned a random number to each element in the list then sorted by the number.
05:37:15 <Verbophobe> Very inefficient and not all that random.
05:38:22 <Verbophobe> Oh, wait, I just found that function you guys were talking about here.
05:40:33 <Verbophobe> Pretty clever.
05:53:06 <ski> (hmm, randomPermute seems to recompute length over and over again ..)
05:53:21 <andersca> heyhey ski
05:54:01 <ski> hej på dig !
05:56:18 <Verbophobe> Ok, well, I'm off to bed.
05:56:22 <Verbophobe> Night
06:28:11 <tooki> howdy
06:29:18 <ski> hi tooki
06:49:42 <Igloo> Is this online judge a personal challenge thing? (context: haskell-cafe)
06:51:13 <Igloo> Looks like a cute idea if so
06:56:23 <earthy> yup, it is, IIRC
06:57:01 <Igloo> Maybe that's a good thing to point people at if they want to learn Haskell but don't know what to write to do so
06:57:34 <earthy> Alistair Bayley
06:57:38 <earthy> hmm... :)
06:57:43 <Igloo> ?
06:57:57 <earthy> it seems the Haskell entriers are being accepted. :)
06:58:18 <Igloo> Ah, yeah, I saw one on the status page
07:20:31 <seafood> I've been playing around with ocaml. Does anyone know why mutual recursion has to be done in such a contrived way?
07:20:41 <seafood> I know I should be on the ocaml list, but they're not being very talkative.
07:21:02 <ski> with 'rec' and 'and' ?
07:21:12 <Igloo> I assume it's just to make the compiler easier to write
07:21:28 <Igloo> Oh, and it makes interactive use simpler to understand
07:21:44 <seafood> That's gotta be it. Thanks.
07:21:53 <seafood> Yeah, Ocaml has a top-loop.
07:21:58 <Igloo> There might be an argument that making it explicit makes it easier to read too
07:22:14 <Igloo> But really I'm just guessing  :-)
07:22:16 <seafood> I don't put too much stock in that argument.
07:22:20 <seafood> hehe :)
07:22:29 <kosmikus> you can actually redefine values in a normal let, which is very useful on the toplevel
07:26:15 <seafood> kosmikus: I don't mind the distinction between the let and let rec that exists in ocaml. I think that's actually quite useful if you want to reuse names.
07:27:02 <kosmikus> ok, sorry
07:31:06 <seafood> I'm just wondering why you can forward refer to a function at the top level.
07:31:31 <seafood> I don't consider the "we were too lazy to implement it in the compiler" reason as sufficient.
07:32:10 <SyntaxNinja> seafood: hm. doesn't it cut down on the number of required passes, and make compilation more efficient?
07:32:36 * SyntaxNinja isn't sure that the number of passes influences the speed of compilation, but would suspect so
07:32:58 <seafood> Surely you would need just one pass. Then find the strongly connected components of the dependency graph.
07:33:31 <Igloo> You have to do it regardless as you have let rec, you just do it for fewer definitions
07:34:05 <seafood> Anyway. I've gotta go to bed now, but I'll get back to you on the reason for Ocaml's weirdness if I find out the answer.
07:34:16 <seafood> I'm sure it can't be for implementation simplicity.
07:34:18 <SyntaxNinja> bye seafood
07:34:26 <seafood> see ya.
07:34:30 * seafood --> away
07:34:47 <Igloo> The nice thing about using other languages is you remember how much you like Haskell  :-)
07:35:22 <seafood> Yeah.
07:35:28 <seafood> Bang on.
07:36:32 * earthy starts thinking it might be wise to go home in the not too distant future
07:38:50 <Igloo> Except I'm scared that won't be true for epigram
07:39:08 <earthy> :type flip
07:39:10 <earthy> @type flip
07:39:12 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
07:52:17 <earthy>   Anyone who thinks the act of /programming/ is interchangeable with
07:52:17 <earthy> the act of /typing/ should not be allowed to perform either.
07:52:17 <earthy> *righton*
07:56:20 <firefly> SyntaxNinja: I actually didn't expect it to be - I just hoped I would get lucky.  Currently reading the ghc user's guide with links instead.
08:12:00 <shapr> Igloo: epigram is strange and nifty
08:12:01 * shapr wonders if running epigram and irc at the same time will cause problems
08:12:23 <Igloo> I was impressed by it at the DGP workshop, and I think we'll get to play with it at AFP
08:12:25 <ski> epigram ?  dependently typed lang ??
08:12:25 <Igloo> yup
08:12:25 * Igloo should learn basic emacs before I go, I think
08:12:26 <Igloo> Like which way round the ^X and ^C go to quit at least  :-)
08:18:38 <shapr> heh
08:18:44 * shapr fights with epigram
08:19:10 <shapr> I do *not* understand what's going on here
08:19:43 <ski> mhm ?
08:24:26 <SyntaxNinja>  does anyone know why {{{newtype ListMap i o = ListMap ([i] -> [o])}}} shouldn't be an arrow?
08:24:58 <ski> it shouldn't ?
08:25:33 <SyntaxNinja> in ross patterson's chapter for FoP, there's a problem that tells me to figure out why not
08:25:56 <SyntaxNinja> I was able to write pure, first, and (>>>), but I'm guessing I fail one of the first laws.
08:26:33 <ski> would guess on some 'first' law ..
08:26:37 <ski> yes
08:27:02 <ski> (didn't realize you just said that)
08:27:54 * ski doesn't remember the laws ..
08:28:33 <ski> prolly (,c) should be natural or something ..
08:28:34 <shapr> trying to make epigram do something useful
08:28:37 <shapr> gah, epigram is eating some of my buffers
08:28:41 <shapr> whoa, epigram is flippy weird
08:28:43 <shapr> and strangely appealing
08:28:45 <shapr> Igloo: what's up with the --- stuff?
08:28:48 * SyntaxNinja is lazy, but I guess I should figure it out. doing the problems is paying off so far.
08:28:50 <ski> shapr : heh :)
08:29:09 <Igloo> shapr: It's a similar syntax to typing rules
08:29:13 <ski> SyntaxNinja : hmm FoP = ?
08:29:35 <ski> Fun of Programming ?
08:29:36 <shapr> laws for first are extension, functor, exchange, unit, and association
08:29:45 <Igloo> You almost certainly want a tutorial of some sort if you don't know what you're doing  :-)
08:30:18 <shapr> first f >>> pure fst = pure fst >>> f
08:30:29 <shapr> that's unit
08:30:34 <shapr> first (first f) >>> pure assoc is association
08:31:07 <ski> assoc :: ar (a,(b,c)) ((a,b),c) or something ?
08:31:51 <SyntaxNinja> fwiw:
08:31:51 <SyntaxNinja> instance Arrow ListMap where
08:31:51 <SyntaxNinja>     pure f = ListMap $ map f
08:31:51 <SyntaxNinja>   --first :: ListMap i o -> ListMap (i, d) (o, d)
08:31:51 <SyntaxNinja>     first (ListMap f) = ListMap $ \l -> let snds = map snd l
08:31:52 <SyntaxNinja>                                             os   = f $ map fst l
08:31:54 <SyntaxNinja>                                             in zip os snds
08:31:58 <SyntaxNinja>     (ListMap f1) >>> (ListMap f2)
08:31:59 <SyntaxNinja>     (ListMap f1) >>> (ListMap f2)
08:32:02 <SyntaxNinja>         = ListMap $ f2 . f1
08:32:03 <SyntaxNinja> sorry, that was a bigger flood than I thought
08:32:24 * SyntaxNinja waits for someone to tell me he's an idiot
08:32:36 <shapr> whoa, epigram is like a type-checked wiki or something
08:33:32 <Igloo> wiki?!?
08:33:48 * ski points SyntaxNinja to a function called "unzip"
08:33:49 * Igloo disappears, bemused
08:36:05 <SyntaxNinja> for some reason, unzip and unfold always freak me out
08:36:50 <ski> because of the 'un' ?
08:36:54 <ski> (as in uncurry)
08:37:01 <ski> (or unsafePerformIO :)
08:37:56 <SyntaxNinja> yeah
08:38:01 <SyntaxNinja> I don't use either of those either.
08:38:13 * SyntaxNinja is a doer, not an undoer
08:38:26 <shapr> haha
08:38:43 <ski> foldr undoes the list
08:40:03 <SyntaxNinja> >:/
08:40:26 <shapr> SyntaxNinja: I dunno the answer to that exercise, I fell asleep just before starting on ex1
08:40:34 * shapr does ex1 first
08:42:43 <shapr> SyntaxNinja: is (x) exported from Control.Arrow?
08:44:35 <SyntaxNinja> not that I know of:
08:44:35 <SyntaxNinja> cross :: (a -> a') -> (b -> b') -> (a,b) -> (a',b')
08:44:35 <SyntaxNinja> cross f g (a,b) = (f a, g b)
08:45:49 <Lunar^> shapr: Which exercices are these ?
08:46:20 <SyntaxNinja> man... you're all going to finish them before me...
08:54:22 <shapr> @type Control.Arrow.x
08:54:23 <shapr> lambdabot: @hello
08:54:23 <shapr> ah, ok
08:54:24 <shapr> in Ross Paterson's FoP chapter. You can find it on haskell.org/arrows
08:54:24 <lambdabot> bzzt
08:54:24 <lambdabot> Hello world. 
08:54:37 <shapr> wow, serious lag
08:54:56 <vegai> this is unreal
08:54:58 <vegai> no spam
08:55:14 <vegai> no mail at all 
08:55:32 <vegai> gotta join to some fine haskell mailing lists ...
08:57:10 <ski> @type (Control.Arrow.***)
08:57:12 <lambdabot> (Control.Arrow.***) :: forall a c' c b' b.
08:57:12 <lambdabot> 		       (Control.Arrow.Arrow a) =>
08:57:12 <lambdabot> 		       a b c -> a b' c' -> a (b, b') (c, c')
08:57:20 <shapr> hiya jemfinch 
08:57:28 <jemfinch> howdy, shapr.
08:57:53 <shapr> jemfinch: have you tried epigram?
08:58:03 <jemfinch> what's that? :)
08:58:12 <shapr> epigram - http://www.dur.ac.uk/CARG/epigram/
08:58:25 <shapr> I gotta add factoid support back into lambdabot 
08:58:51 <jemfinch> why was it lost?
08:59:08 <shapr> it was too much trouble to build postgresql support
08:59:15 <shapr> nowadays I can just use HaskellDB
08:59:19 <jemfinch> hah.
08:59:36 <jemfinch> I had just started typing, "can't you just use HaskellDB or ..." when you said that.
09:00:25 <shapr> wow, epigram acts kind of like it has type slicing... or something
09:01:04 <jemfinch> the website is a tad...spartan.
09:01:19 <shapr> the interface is like nothing I've ever seen
09:01:45 <shapr> sort of like a structure editor
09:02:24 <jemfinch> I'd say, "This seems a little too 'blue sky' for me, but I never really understood that term."
09:02:35 <jemfinch> er, that double quote should be after "me,"
09:02:46 <shapr> try using epigram to type in the example program
09:02:47 <jemfinch> anyway, epigram seems a bit apart from the Real World.
09:02:52 <shapr> it appears to work
09:03:25 <shapr> I haven't quite figured out the refinement part yet
09:03:45 <shapr> hiya shaleh
09:03:55 <shaleh> heya
09:04:00 <shapr> hm, I can't escape the shed with this code...
09:04:07 <Igloo> I got the impression it was unusably slow for real use, and probably somewhat lacking in libraries too
09:04:17 <shaleh> what's that?
09:04:26 <shapr> it seems more than fast enough interactively
09:04:28 <shapr> shaleh: epigram
09:04:42 <shaleh> what is that?
09:04:57 <shapr> epigram - http://www.dur.ac.uk/CARG/epigram/
09:06:26 <shaleh> heh, must use xemacs, weak.
09:06:48 <shapr> I like xemacs
09:07:15 <shaleh> GNU macs is the one true macs (-:
09:07:23 <shapr> and RMS is its prophet
09:07:32 <shaleh> exactly
09:07:32 <shapr> honestly, emacs sucks
09:07:42 <shaleh> yeah, but it sucks less than the others
09:07:44 <desrt> emacs rules!
09:07:48 <shapr> it's single-threaded, and it uses regexps for syntax highlighting and everything else
09:07:50 <sazzle> o god
09:07:52 <sazzle> another editor war?
09:08:00 <shapr> sazzle: no, I'm insulting my favorite editor
09:08:03 <desrt> everyone knows lisp is better than haskell
09:08:03 <shaleh> sazzle: no, this is a reasoned debate
09:08:08 <sazzle> hah
09:08:10 <jesse_> lol
09:08:15 <shapr> realistically speaking, I'm pointing out the warts in my favorite editor.
09:08:17 <sazzle> a reasoned debate about editors :P
09:08:38 <desrt> and i have 8 fingers to hold down meta, alt, control, shift, super, hyper, ultra and escape all at once
09:08:44 <sazzle> hmm
09:08:51 <desrt> i see no problem here!
09:08:51 <sazzle> this channel is pretty s-skewed
09:09:05 <shapr> desrt: actually, I can hold down C-M-H-S-Sh-BS with one finger on my keyboard
09:09:19 <desrt> shapr; emacs is a good editor for you, then
09:09:29 <shapr> up to a certain point, yes
09:09:35 <sazzle> emacs, the editor of the finger acrobat
09:09:55 <desrt> god gave you 8 fingers so that you would use emacs
09:10:01 <Lemmih> Isn't there a function like that in the PreludeExt?
09:10:12 <shapr> like what?
09:10:14 <Lemmih> Ops... 
09:10:26 <shapr> startFlamewar ?
09:10:37 <shaleh> insultEditor
09:10:50 <shapr> anyway, emacs is single-threaded, and it uses regexps for everything
09:10:53 <shaleh> fingerAcrobat --> a tiny pdf reader?
09:10:53 <Lemmih> ^^ A failed attempt at moving from one desktop to another...
09:11:06 <sazzle> shaleh: or an emacs user
09:11:08 <shapr> those are its two greatest failings
09:11:32 <sazzle> dunno, i like my editor to be an editor
09:11:36 <sazzle> not an entire os
09:11:42 <sazzle> that takes 10 minutes to load up
09:11:46 <sazzle> :-)
09:11:57 <shaleh> shapr: but also realize that until say the last couple of years an editor that used that much CPU and memory was not reasonable
09:12:10 <shaleh> emacs is the way it is because of its past
09:12:15 <desrt> eighty megs and constantly swapping?
09:12:17 <shapr> time to change
09:12:49 * sazzle wonders if anyone has attempted to make a standalone emacs kernel
09:12:50 <shaleh> shapr: write a better emacs that still allows the use of existing elisp code. The world will elect you as a demigod.
09:13:02 <shaleh> you will be more famous than linus
09:13:35 <desrt> sounds like xemacs
09:13:38 <desrt> didn't jwz do that already?
09:13:40 <shapr> iirc, jEdit already runs existing elisp
09:13:41 <sazzle> yeah
09:13:53 <sazzle> i thought xemacs was an attempt to do that
09:14:01 <shaleh> nah, xemacs was a fork
09:14:07 <desrt> ah
09:14:14 <shapr> actually, xemacs was an attempt to get RMS off his butt to integrate X windows capabilities into emacs
09:14:17 <shapr> emacs 18 I think
09:14:23 <shaleh> shapr: exactly
09:14:28 <shaleh> hence the "x"
09:14:40 <sazzle> dunno
09:14:43 <desrt> emacs runs on gtk2 these days
09:14:44 <sazzle> it just doesn't tempt me
09:14:47 <desrt> if you try hard enough
09:14:47 <sazzle> i have tried the thing
09:15:00 <shapr> RMS didn't respond to the requests from jwz, so jwz went ahead and fixed emacs 18 into Lucid Emacs
09:15:07 <shaleh> jedit runs existing elisp? really?
09:15:25 <shapr> by the time RMS got around to looking at the diffs, they were *very* large, and RMS turned them down
09:15:31 <desrt> shaleh; ya.  i think they got it to run hello world even
09:16:01 <shapr> in my opinion, the fork is more about RMS being difficult
09:16:06 <shaleh> shapr: the real problems started when they decided to implement the functions differently and with different names
09:16:23 <shapr> emacs very much needs a function name cleanup
09:16:23 <shaleh> so now there is a serious divergence
09:16:28 <shapr> and some heavy duty refactoring
09:16:49 <shapr> yah, xemacs uses regions to do highlighting, and gnu emacs uses text properties
09:16:52 <shaleh> shapr: yep, like I said. Make a new editor that runs all existing elisp code
09:16:53 * shapr could go on in great detail
09:17:18 <shaleh> it does not need to be based on elisp, it just needs to run the existing code
09:17:27 <shapr> char is a type in xemacs, and an int in gnu emacs, blah blah
09:17:45 <shapr> shaleh: the painful bit would be implementing the API
09:17:51 <shaleh> shapr: yep.
09:18:29 <shapr> for example, Ashley Yakeley's HScheme plus Michael Sperber's code to convert elisp into maintainable scheme might be enough
09:18:52 <shapr> but I wouldn't want to rewrite the API
09:19:27 <shaleh> i'd start small, implementing enough to run a few of the common modes and such
09:19:49 <shaleh> let the api grow for a bit, then refactor, rinse, lather and repeat.
09:24:43 <juhp> yes, let's write Haskell Emacs :)
09:25:19 <shaleh> lots of ground work to get started -- i18n done front, etc.
09:25:32 <shaleh> but once it gets rolling the work should not be two bad.
09:25:50 <shaleh> probably a solid 18 months for a couple of people working on the side.
09:25:58 <shapr> sounds like fun
09:26:19 <sazzle> hemacs?
09:26:22 <vegai> hmm. "Haskell" "Ask Hell"
09:26:23 <Igloo> If you were really going to write an editor from scratch I hope you wouldn't make it follow things like the emacs names
09:26:26 * vegai fears.
09:26:30 <shaleh> damn, I said 'two bad', jeez
09:26:38 * shaleh tries to wake up a little
09:26:53 <shapr> Igloo: what do you suggest?
09:27:11 <shaleh> Igloo: nah, but it needs a compatibility layer for the elisp support
09:27:21 <shaleh> I think he is refering to things like point and mark
09:27:46 <shapr> I like the name 'Currage' ;-)
09:28:14 <sazzle> heh
09:28:15 <Igloo> I'm not familiar with the config variable names etc myself, but I understand they aren't very intuitive. font-lock-mode is the only name I know, and that doesn't obviously mean what it does to me
09:28:38 <shapr> yah, no argument there
09:28:43 <shapr> emacs defun and var names suck
09:29:11 <shapr> like replace-string and string-match, which comes first, the noun or the verb?
09:29:30 <Igloo> I think the thing to think hardest about if you were to do it would be how the user's programming language would communicate efficiently with the contents of the buffer
09:29:45 <Igloo> Both in terms of being fast to run and easy to write
09:29:51 <shaleh> yep
09:30:20 <vegai> "hem"
09:30:29 <Igloo> That's certainly one of the issues I think vim has
09:30:32 <shaleh> vegai: hmmm, good name
09:30:43 <reltuk> what's one of the issues vim has?
09:31:53 <sazzle> hmm
09:31:57 <shapr> my dream editor has an incremental parser and allows users to write parse tree macros
09:32:01 <sazzle> does it have to be language specific?
09:32:15 <Igloo> Scripts that do a lot of looking at the text and altering it are a nightmare to write and are slow
09:32:18 <sazzle> i mean, how much harder would it be to write something that would work in more than one language?
09:32:18 <shapr> I'd rather use the Model-View-Controller setup
09:32:20 <reltuk> ahhh, syntax highlighting problems?
09:32:26 <shapr> sazzle: yah, I agree
09:32:28 <Igloo> The problem with parsing in editors is the parse tree is normally broken
09:32:33 <Riastradh> Why bother with parsing at all, shapr?
09:32:50 <shapr> Riastradh: because that's the right way to do syntax highlighting, code completion, etc
09:32:52 <Riastradh> Store the code as a serialized AST; all you need is an unparser, which is a lot simpler thna a parser, usually.
09:32:58 <vegai> looking at the result, vim seems to be doing a good job, however
09:33:00 <Riastradh> Than, even.
09:33:15 <sazzle> it'd be funky if you could have an editor (or any general program) you could script for with say, python, perl, lisp, haskell and C
09:33:24 <sazzle> maybe not C
09:33:26 <shaleh> sazzle: depends hell
09:33:31 <JaffaCake> my Haskell mode for Visual Studio does parsing & type checking in the editor
09:33:33 <sazzle> but any language with an interpretor
09:33:38 <shapr> JaffaCake: wow nifty
09:33:44 <JaffaCake> it underlines type errors
09:33:46 <shaleh> and you seriously fragment the community
09:34:06 <JaffaCake> maybe we'll get it finished someday :/
09:34:07 <sazzle> shaleh: why?
09:34:17 <shapr> were it to be in Haskell, I'd go for HScheme for the elisp compat layer, and Haskell for everything else
09:34:45 <Riastradh> sazzle, you're going to have serious problems with _running_ all of those languages (unless you take the .NET & C# approach, where you just make all languages look more & more like C#), and then people would duplicate a whole ton of code just for their preferred languages.
09:35:02 <shaleh> sazzle: because you end up with people who only code in perl or python writing nifty modes and no one else being able to understand them. plus you have to support it all. vim does this and I would not want to attempt it.
09:35:03 <sazzle> Riastradh: hmm, point
09:35:08 <shapr> Igloo: an incremental parser is okay with broken parse trees
09:35:40 <Riastradh> shapr, an incremental parser can also get really complicated, whereas a true syntax editor, as opposed to a plain text editor, doesn't have any sort of problems with parsing.
09:35:55 <JaffaCake> shapr: don't forget incremental type checking too
09:36:15 <shapr> JaffaCake: could be fun to add in slicing
09:36:41 <shapr> Riastradh: but how do you make a structure editor that is easy to add support for any language?
09:36:52 <shapr> greetings christi, looking for Haskell info?
09:37:09 <Riastradh> shapr, how do you make a text editor that uses an incremental parser and that is easy to add support for any language?
09:37:13 <shaleh> shapr: and remember, not all languages can be parsed trivially. for perl I think regexes are about all you can get without a LOT of work. they don't even have a BNF for it.
09:37:16 <shapr> I want my buffer to be able to reach a non-parseable state, structure editors feel too limiting to me.
09:37:19 * JaffaCake goes home
09:37:23 <shapr> Riastradh: use the MetaEnvironment setup
09:37:25 <JaffaCake> bye all!
09:37:27 <shapr> SDF, Aterm, etc
09:37:27 <Riastradh> Of what use is a non-parseable state?
09:37:31 <shapr> bye JaffaCake  
09:37:35 <Riastradh> MetaEnvironment?
09:37:41 <shapr> Riastradh: partially parseable is usable
09:37:45 <bringert> maybe you could use GF to parse crazy languages like perl
09:37:54 <Riastradh> shapr, yes, but why would you want it?
09:37:58 <shapr> Riastradh: http://www.cwi.nl/projects/MetaEnv/
09:38:36 <shapr> Riastradh: the same reason I like semantic bovinator in emacs. even if only part of the buffer is parseable, you can still do code completion with that part
09:39:03 <reltuk> nothing indents haskell near-correctly
09:39:05 <shapr> though at this point, I think I'll be stealing some ideas from epigram
09:39:12 <shapr> reltuk: sad but true
09:39:25 <Riastradh> shapr, but of what use is the _unparseable_ part of the buffer?  Why do you need it?
09:39:36 <shapr> because I'm usually adding code there
09:39:44 <Riastradh> Why does it need to be unparseable? 
09:39:45 <shapr> or subtracting it, or altering it in some fashion
09:40:07 <shapr> because a single brace is not parseable, but I want to be able to type it if I feel like typing it.
09:40:29 <Riastradh> ...uh, why would you just want to enter a single brace that serves no purpose whatsoever?
09:40:48 <shapr> because it would serve a purpose to me
09:40:56 <shapr> but not necessarily to my editor
09:41:37 <shapr> though the epigram entry method might be a good halfway point between those two
09:41:39 <Riastradh> What purpose does it serve without a closing brace?
09:41:50 <shapr> to remind me that I need to put some code in there
09:41:54 <shapr> or to look cute, or whatever
09:42:28 <Riastradh> A simple comment can serve for reminders -- and more reminders than just those --, and I'm not quite sure what to make of this cuteness business...
09:42:40 <shapr> I regularly type in illegal code to get the rough structure, and then come back and make that code work
09:42:56 <shapr> I want to be able to do it that way, so a structure editor isn't useful to me
09:43:10 <Riastradh> Why do you _want_ temporarily illegal code?
09:43:21 <shaleh> shapr: same here. I typically use psuedo code for initial code layout
09:43:23 <Riastradh> Why would rough but legal code be worse?
09:43:39 <bringert> I sometimes leave intentionally bad code at the end of the day, so the compiler will tell me where to start off tomorrow
09:43:39 <shaleh> Riastradh: higher abstractions
09:43:48 <shaleh> bringert: indeed
09:43:49 <Riastradh> Higher abstractions?
09:43:57 <shapr> Riastradh: because inspirations that fly into my head often disappear just as quickly, if I can record those inspirations, I'm more likely to write them.
09:44:05 <shaleh> "when things go bad ...."
09:44:10 <Riastradh> shapr, so scribble them into comments.
09:44:20 <shaleh> Riastradh: but why be forced to?
09:44:23 <shapr> so the faster I can record the general idea of the code I want to write, the more likely I'll remember what I was thinking
09:44:27 <shapr> Riastradh: that's not good enough
09:44:48 <Riastradh> shapr, how is commented illegal code any different from uncommented illegal code?
09:45:05 <shapr> uncommented illegal code can be partially understood by an incremental parser
09:45:12 <shaleh> one: it gets syntax hilighted as a comment, which may be distracting.
09:45:37 <shaleh> naked, uncolored text might stand out more
09:45:46 <shaleh> or be more aesthetic
09:45:59 <shapr> bringert: yes, I do that with failing unit tests
09:46:12 <shapr> bringert: it's my hook to drag me back where I was
09:46:22 <bringert> exactly
09:46:26 <bringert> time to go home
09:46:29 <bringert> later
09:46:45 <Riastradh> shapr, you could always just leave some sort of notification over that code.
09:46:54 <shapr> Riastradh: in many cases I have an end point and a few midpoints that are static, and the rest of the code can vary
09:46:57 <shaleh> Riastradh: at the end, I like having my editor be a text editor, then a programming editor. not the otherway around
09:47:10 <Riastradh> Is it necessary to be _illegal_ code when it would work just as well to be rough, & not working, but legal code?
09:47:31 <shapr> but I know that my idea/thought/goal/etc will require that those other portions be the way I have them in my head
09:47:32 <shaleh> I typically write english statements where a line of code should be
09:47:48 <shaleh> I should handle x not being > 1 here
09:47:51 <Riastradh> shaleh, uh, that's what comments are for...
09:48:05 <shaleh> no, that is how I design my rough drafts
09:48:24 <shaleh> just like my essays, they do not start out structured and correct english
09:48:25 <Riastradh> Why is it _necessary_ for them not to be in comments?
09:48:35 * shapr lags
09:49:19 <shaleh> Riastradh: why _force_ another approach on people?
09:49:26 <shaleh> why limit how they express themselves
09:49:28 <Riastradh> shaleh, why does it _matter_?
09:49:40 <Riastradh> It's _not_ limiting!  The only difference is a couple of comment characters.
09:49:49 <shaleh> succcessful tools do not make their users think about what the tool is doing
09:50:04 <shaleh> but it forces me to think "this needs to be a comment"
09:50:11 <mwb> Like the automobile.
09:50:43 <shaleh> yes, this makes the editor more complex to write. but why push that complexity onto the user?
09:51:00 <Riastradh> Which 'this' are you referring to?
09:51:10 <shapr> Riastradh: in any case, I will not use an editor where my code must be legal at all times
09:51:33 <shapr> it wouldn't work for me
09:51:37 <Riastradh> shapr, why _not_?  Why does it _MATTER_ that some of your code must be illegal?
09:52:20 <sazzle> so long as it being illegal doesn't make it harder to read
09:52:23 <sazzle> i think it'd be okay
09:52:34 <mwb> Eh.
09:52:37 <sazzle> like, i'd hate it if it made everything illegal bright red and blinking
09:52:56 <mwb> If I found a bunch of English sitting in the middle of a source file, I'd want to poke a fork into someone.
09:52:58 <sazzle> but if it just pointed it out, if you told it to, i don't see the problem
09:53:06 <shaleh> Riastradh: two cases: one, initial code writing and two: serious refactoring.
09:53:19 <shapr> Riastradh: because my thinking and programming is primarily intuitive, I make a huge jump to a conclusion, and then check to see if it's really right
09:53:21 <shaleh> while refactoring I often stop for lunch with seriously wrong / busted code
09:53:26 <sazzle> i don't like to be given non-compiling code 
09:53:39 <sazzle> but compiling code tends to start out as non-compiling code
09:53:45 <sazzle> unless you have a magic code generator
09:54:25 <shapr> Riastradh: so, I know that certain parts of the code must be a certain way, so I write those first, then I connect those parts such that they actually work
09:54:29 <Riastradh> A syntax editor needn't ensure that the code _works_; it just needs to be of correct _syntax_.
09:56:17 <shapr> I want to be able to type in anything, and have the editor make an effort to figure out as much as it can
09:57:07 <Riastradh> Why do you want to be able to type something that is of _blatantly_ incorrect syntax?  Of _what_use_ is that?
09:57:32 <shapr> because I don't think in a programming language, I think conceptually, then I translate into that language
09:57:53 <Riastradh> That's what _comments_ are for, shapr.
09:57:54 <shapr> and sometimes if I spend enough time to translate into legal syntax, I lose the other concepts and their structure
09:58:00 <shapr> maybe for *you*
09:58:02 <shapr> but not for me
09:58:24 <Riastradh> What do you put in comments?  Cooking recipes?
09:58:31 <shapr> not usually
09:59:05 <shapr> I suspect that you and I do not have duplicate mental processes when it comes to programming.
09:59:19 <shaleh> my comments express the why of my code
09:59:22 <Riastradh> That is most likely correct, but I'd like you to answer my question nevertheless.
09:59:40 <shapr> from my viewpoint, I have answered your question
09:59:47 <Riastradh> 12:42 < shapr> not usually
09:59:53 <shaleh> beginTransaction(); // must call this before using the following SQL commands
09:59:56 <Riastradh> That's not an answer to 'what do you put in comments.'
10:00:03 <shaleh> was a comment I entered yesterday before going home
10:00:11 <ibid> that's not a why
10:00:14 <ibid> that's a constraint
10:00:24 <ibid> ah, sorry
10:00:26 <ibid> misread
10:00:45 <shapr> Riastradh: things that aren't obvious upon reading the source code
10:00:51 <shaleh> ibid: it is a constraint to some degree. but it is a constraint I can not enforce in code.
10:01:03 <ibid> shaleh: as i said, i misread
10:01:19 <ibid> shaleh: i first thought that comment was on the definition of beginTransaction...
10:01:30 <shaleh> ibid: yeah, it was c++, sorry
10:01:36 <Riastradh> shapr, would it be such a crime to add new kinds of contents to comments?
10:01:48 <shapr> yes, it would
10:02:03 <ibid> shaleh: i can read c++, i just misread it
10:02:12 <Riastradh> So you never write 'FIXME:' comments or the like?
10:02:15 <ibid> shaleh: my mistake
10:02:38 <shapr> Riastradh: I do write those when I see a bug while (re)reading sources later
10:03:00 <maihem> ah-ha! Riastradh, you've found a way around Microsoft's patent, call them FIXME's instead of TODO's :)
10:03:02 <Riastradh> Well, that's a different kind of comment from what you just said you used comments solely for!
10:03:10 <shapr> Riastradh: ok, whatever
10:03:13 <Riastradh> Why not write a 'CODEME:' comment?
10:03:21 <shapr> Riastradh: why not drop it? :-P
10:04:02 <shapr> Riastradh: seriously, my flow of creation in impinged upon by forcing me to adhere to legal syntax
10:04:06 <shapr> s/in/is
10:04:27 <mwb> Seems odd.
10:04:39 <Riastradh> shapr, have you ever used a good syntax editor?
10:06:03 <shapr> Riastradh: one day, we'll do some pair programming, then you'll understand what I'm talking about.
10:06:19 <Riastradh> I asked a simple 'yes or no' question.
10:06:35 <mwb> What's a good syntax editor?
10:07:10 <Riastradh> mwb, Interlisp's S-expression editor, for example.  There aren't many of them, however.
10:07:56 * shaleh wonders if Riastradh has a stuffed s-expression doll on his bed
10:08:50 <Leimy> I think I've seen Interlisp's S-expression editor
10:08:52 <mwb> I wonder what an S-expression doll would look like.
10:08:59 <Leimy> Riastradh: is that what Chandler gave a demo of?
10:09:05 <Riastradh> Yes, Leimy.
10:09:10 <Leimy> ah... that was pretty cool
10:09:16 <Leimy> I'd like to do that to XML :)
10:09:37 <Riastradh> Leimy, it already does.  S-expressions are equivalent to XML.
10:09:41 <Leimy> yeah I know
10:09:46 <Leimy> I mean for a real XML editor
10:09:56 <Riastradh> What do you mean 'a real XML editor?'
10:09:56 <Leimy> S-expressions are less typing :)
10:10:03 <Leimy> Such that I can key in XML
10:10:05 <Leimy> not S-expressions
10:10:26 <Leimy> though one could key in S-expressions and run a script to convert it
10:10:35 <Leimy> however people who want to do XML won't like that much
10:18:47 <mwb> It sure is great when people have arguments in a paragraph on a wiki.
10:19:09 <shapr> ?
10:19:11 <shaleh> mwb: if by "great" you mean "sucks and makes me not use wikis" I agree.
10:19:18 <mwb> Yup.
10:19:19 <shapr> I like wikis
10:19:39 <shapr> imho, the only downside to wikis is that they're becoming spam targets
10:19:58 <shaleh> wikis allow that annoying guy from school who always thought he knew the answer and wouldn't shut up yet another chance to be a tyrant
10:19:58 <mwb> None too surprising.
10:20:02 <Riastradh> shapr, accepting that it's a problem will only encourage them.
10:20:23 <shapr> I didn't acccept it?
10:20:27 <shapr> I fixed the problem.
10:21:12 <Riastradh> You accepted that it's a downside -- problem -- to wikis that they're becoming targets for spam.
10:21:25 <shapr> no, I didn't.
10:21:43 <shapr> Riastradh: you're being defensive!
10:22:02 <Riastradh> No, I'm not!
10:22:14 * shapr snickers
10:28:16 <shaleh> wow, haskell-cafe could really scare off a newbie
10:28:27 <shaleh> it is definitely not as gentle as python-tutor.
10:28:43 <ski> shaleh : mhm ?
10:29:48 <shaleh> the conversations are a lot deeper and more arcane than on python tutor.
10:30:28 <shaleh> not so much "how do I make a for loop in haskell" which is kind of what I was expecting to see.
10:32:04 <shaleh> haskell-cafe feels more like python-user
10:32:38 <Lor> Here's one scary message: http://www.mail-archive.com/haskell@haskell.org/msg07546.html
10:33:25 * shaleh 's brain explodes
10:33:27 <ski> heh
10:37:30 <Lor> for x = a to b do foo done  -->  mapM_ (\x -> foo) [a..b]
10:41:05 * vegai wonders whether he should do a small parsing job easily or with a little more effort.
10:57:15 <firefly_> Just read the scroll buffer...
10:57:32 <firefly_> Riastradh: you seem to have a severe case of not getting usability issues.
10:57:34 <ski> huh ?
10:57:49 <firefly_> It is easy to make an editor that only lets programmers write syntactically correct code.
10:57:57 <firefly_> It is very hard, though, to make such an editor usable.
10:58:20 <firefly_> Structural editors are not a new idea, they have been tried lots of times and there is an extensive HCI literature on them.
10:58:25 <firefly_> They pretty much don't work.
10:58:44 <firefly_> One of the problems is how to do a transition from one legal state of the code to another.
10:59:06 <firefly_> Far better to make the editor allow any text -- but discreetly mark it up as you type.
11:02:35 * ski would like to be able to cut & paste blocks with holes in it
11:02:40 <maihem> it would be nice if it remembered the state of the parse at certain points, and require you to request a reparse to change them. ie, what was a function should remain a function even if you delete the closing brace of the preceding function. but it should mark it as out of date. I don't know if that would be effective/practical though
11:03:19 * firefly_ would like to cut'n'paste between different languages.
11:04:10 <vegai> the language shootouts are excellent for that
11:05:10 <firefly_> Err.. no, I meant having an ML program and a C program and cut (copy) a C function and paste it into the ML program.
11:05:44 <vegai> heh, sorry 
11:06:26 <vegai> easy
11:06:53 <vegai> just find the universal programming language, and write converters to and from that
11:07:09 <firefly_> The old pipe dream of UNCOL.
11:28:25 <SamB> hmm. I wonder how I should implement #line... I can catch it while lexing and just use setPosition, or I can do it while parsing and futz with the line numbers afterwords, or I can not lex at all...
11:52:59 <SyntaxNinja> does anyone want a gmail invite?
11:53:37 * shapr boings upon SyntaxNinja 
11:53:42 <Lukhas> what does that do ?
11:54:08 <SyntaxNinja> Lukhas: it's google's web mail service.  i'm trying it out for some mailing lists and some personal conversatoins
11:54:42 <Lukhas> i know gmail, i was asking about the invite :-)
11:54:54 <SyntaxNinja> I use gnus, and don't see myself switching away from gnus, but I also sometimes have need to send mail from a web account, and gmail has a nice interface.
11:55:13 <SyntaxNinja> lukh: well, I think you have to be invited to get an account, and every so often, they let everyone invite some number of people.
11:55:21 <Lukhas> oh, ok
11:55:27 <SyntaxNinja> shapr: does that mean you want one?
11:55:29 <Lukhas> well, i'll keep my gnus too
11:55:37 <shapr> SyntaxNinja: er, I don't know?
11:55:39 <Lukhas> for webmail, i have imp.free.fr
11:55:40 <SyntaxNinja> so anyway, they just gave me 6 invites, so I thought I should give them away.
11:56:09 <stepcut> SyntaxNinja: don't let the man push you around! You don't have to give 'em out if you don't want to!
11:56:48 <SyntaxNinja> stepcut: quite true.  the offer stands nonetheless :) I'm sending invites to my friends who use hotmail and can't turn off HTML-only mail.
11:56:58 <SyntaxNinja> so-called friends
11:57:01 <stepcut> hehe
11:57:06 <shapr> is there some way to get the seed from a StdGen?
11:57:11 <Lukhas> well, i wouldn't mind, just to try the web interface, i heard it was nice
11:57:37 <Lukhas> the 1 gig would be nice for lkml and such high traffic lists
11:58:02 <shapr> any clueful QuickCheck people around? I'm trying to persuade QuickCheck to save the seed for failing cases
12:05:24 <firefly> @type Monad.>>
12:05:26 <lambdabot> bzzt
12:05:31 <firefly> @index >>
12:05:31 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
12:05:31 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
12:05:31 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
12:05:38 <shapr> @type (>>)
12:05:40 <lambdabot> (>>) :: forall m b a. (Monad m) => m a -> m b -> m b
12:05:46 <firefly> ah, thanks
12:05:55 <firefly> @type (>>=)
12:05:56 <shapr> I'll get around to cleaning out those inputs one day
12:05:57 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
12:06:17 <shapr> it should only show modules that actually export the symbol
12:09:47 <firefly> @type return
12:09:49 <lambdabot> return :: forall m a. (Monad m) => a -> m a
12:11:35 <firefly> @type words
12:11:37 <lambdabot> words :: String -> [String]
12:12:17 <TheHunter> @state
12:12:17 <lambdabot> GER-CZE 1:0, NED-LAT 1:0
12:12:27 <firefly> :)
12:12:29 <shapr> interesting
12:14:14 * andersca bounces
12:14:30 <firefly> saa laenge du ikke triller...
12:14:33 <andersca> :)
12:14:46 <andersca> a dane agreed to buy me beer at guadec :)
12:14:55 <TheHunter> @state
12:14:55 <lambdabot> GER-CZE 1:1, NED-LAT 1:0
12:15:02 <firefly> Ouch!  At Norwegian prices??!?!?!
12:17:26 <firefly> @type putStr
12:17:28 <lambdabot> putStr :: String -> IO ()
12:17:53 <firefly> @assoc (>>)
12:17:53 <lambdabot> Sorry, I don't know the command "assoc", try "lambdabot: @listcommands"
12:17:59 <firefly> @listcommands
12:17:59 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
12:17:59 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
12:17:59 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
12:17:59 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
12:17:59 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
12:18:00 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
12:18:01 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
12:18:03 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
12:18:05 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
12:18:15 <andersca> @arr
12:18:15 <lambdabot> Prelude.(!!): index too large
12:18:15 <shapr> what's @assoc ?
12:18:17 <andersca> @arr
12:18:17 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
12:18:22 <shapr> @arr
12:18:22 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
12:18:29 <ski> @yow
12:18:30 <lambdabot> Is it clean in other dimensions?
12:18:33 <firefly> shapr: trying to look up the associativity of operators
12:18:38 <shapr> oh
12:18:41 <shapr> @info (>>)
12:18:44 <lambdabot> -- >> is a method in class Monad
12:18:44 <lambdabot> infixl 1 >>
12:18:44 <lambdabot> (>>) :: forall m :: (* -> *). (Monad m) =>
12:18:44 <lambdabot> 	forall a b. m a -> m b -> m b
12:18:52 <firefly> thank you!
12:19:03 * shapr grins
12:19:09 <firefly> @info (>>=)
12:19:12 <lambdabot> -- >>= is a method in class Monad
12:19:12 <lambdabot> infixl 1 >>=
12:19:12 <lambdabot> (>>=) :: forall m :: (* -> *). (Monad m) =>
12:19:12 <lambdabot> 	 forall a b. m a -> (a -> m b) -> m b
12:19:34 <shapr> I wrote @info and @index just a few weeks back, feel free to request features or report bugs
12:20:02 <firefly> @info (->)
12:20:08 <ski> no
12:20:10 <shapr> they're just thin wrappers. @info is ghci's :i command, and @index is a haddock lookup
12:20:17 <firefly> ok.
12:20:40 <ski> firefly : or were you thinking of the type operator '->' ?
12:21:04 <firefly> I don't know.  I think I am thinkin of the syntax for lambda functions.
12:21:25 <firefly> I am trying to understand the Haskell 98 reports example about putStr/getLine and the do notation.
12:21:31 <firefly> putStr "x: "    >>
12:21:39 <firefly> getLine         >>= \l ->
12:21:45 <firefly> return (words l)
12:21:50 <firefly> which should be the same as:
12:21:56 <firefly> do putStr "x: "
12:22:01 <firefly>    l <- getLine
12:22:06 <firefly>    return (words l)
12:22:15 <Riastradh> Actually, it's not quite the same.
12:22:36 <firefly> My guess is that the -> in the former is just part of the syntax for lambda functions, just like the backslash is.
12:22:43 <ski> right
12:22:45 <firefly> In the latter I know that it is just part of the syntax.
12:23:13 <firefly> On the other hand, there are weirder things in Haskell when it comes to supremely higher ordered functions ;)
12:23:14 * shapr squishes his brain around QuickCheck's internals
12:23:52 <shapr> Haskell's collection weird things go straight off my radar into stuff so strange, I can't even realize how strange it really is.
12:24:41 <firefly> It would be great if they wrote a language now they have done all that nice research ;)
12:25:35 <firefly> Is there any good reason why the function in the unsugared version above is split over two lines?
12:25:47 <firefly> Is it just for similarity with the do version?
12:25:47 <shapr> readability
12:26:03 <shapr> firefly: try it
12:26:19 <shapr> main = putStrLn "foo" >> putStrLn "bar"
12:26:24 <shapr> main = do putStrLn "foo"
12:26:28 <firefly> It's just that it looks like there is something I may not have understood...
12:26:40 <firefly> I meant the \l -> return (words l) part.
12:26:40 <shapr>           putStrLn "bar"
12:26:45 <firefly> right.
12:27:06 <firefly> @info getLine
12:27:08 <lambdabot> -- getLine is a variable
12:27:08 <lambdabot> getLine :: IO String
12:29:30 <firefly> @info (^)
12:29:32 <lambdabot> -- ^ is a variable
12:29:32 <lambdabot> infixr 8 ^
12:29:32 <lambdabot> (^) :: forall a b. (Num a, Integral b) => a -> b -> a
12:29:44 <shapr> @info (=^.^=)
12:30:08 <shapr> lambdabot has no sense of humor.
12:30:21 <lambdabot> Yes, I do.  What a presumptuous little human you are.
12:30:27 * shapr blinks
12:30:36 <shapr> see, I told you so!
12:30:43 <shapr> can't take a joke
12:30:51 <lambdabot> No, your jokes are just lame.
12:30:54 <firefly> lambdabot is stupid
12:31:06 <shapr> or at least not very smart
12:31:17 <shapr> lambdabot: you killed kenny! you bastard!
12:31:18 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:31:19 <firefly> lambdabot is a not very smart sock puppet
12:31:19 <lambdabot> At least I tell good jokes.
12:31:32 <lambdabot> But you've insulted me too much here for me to want to demonstrate.
12:31:50 <shapr> oh sure, I believe you, SILLY SOCK PUPPET BOT!
12:32:14 <firefly> lambdabot tells doubleplusungood funspeak.
12:32:22 <lambdabot> Fine, here's one.  This is the lamest one I know, to meet the atmosphere
12:32:22 <lambdabot>  what's brown & sticky?
12:32:37 <lambdabot> There was supposed to be a colon after 'atmosphere,' by the way.
12:33:40 * shapr is afraid to ask
12:33:50 <lambdabot> To ask?  Don't you mean 'to answer?'
12:34:12 <lambdabot> The answer is...a stick!
12:35:24 <firefly> @state
12:35:24 <lambdabot> GER-CZE 1:1, NED-LAT 2:0
12:35:28 <lambdabot> You humans have no sense of humour.
12:35:34 <Lukhas> heheh
12:35:47 * SyntaxNinja has trouble seeing how the ListMap type in Ex 2 shouldn't be an arrow, but that StreamMap in Ex. 3 is... (http://www.soi.city.ac.uk/~ross/papers/fop.html)
12:36:05 <SyntaxNinja> I guess streamMap should be a clue
12:36:30 <SyntaxNinja> man. a bot in another room has a grouphug.us interface. that's dangerous
12:36:54 <lambdabot> O.K., O.K., here's a better one.
12:37:13 <jemfinch> grouphug.us?
12:37:31 <SyntaxNinja> it's a web site
12:37:34 <SyntaxNinja> not always SFW
12:37:48 <shapr> who's Ned? I assume Lat is Latvia?
12:37:56 <firefly> Netherlands
12:37:58 <shapr> and the score is most likely to do with soccer?
12:37:59 <lambdabot> So this old fart is on his way home from the next town over, and his LOL
12:37:59 <lambdabot> (that's 'little old lady') wife is watching the news.
12:38:30 <firefly> Latina is Ned's girl friend.
12:38:37 <lambdabot> She sees on the news a traffic report that describes that freeway he's driving
12:38:37 <lambdabot> on, and a maniac driver on it on the wrong side of the road.
12:38:56 <firefly> "they are all driving on the wrong side:
12:38:56 * shapr wonders if lambdabot has been drinking
12:38:59 <firefly> "they are all driving on the wrong side"
12:39:12 <lambdabot> She calls up her husband and says (in an old lady voice), 'Frank, you'd
12:39:12 <lambdabot> better look out; there's some maniac driving on the wrong side of the road
12:39:12 <lambdabot> '
12:39:36 <lambdabot> Her husband responds, 'Ohhhh, there's not just one of 'em, there's _hundreds
12:39:36 <lambdabot>  of 'em!'
12:40:04 <firefly> lambdabot, do you know any blonde jokes?
12:40:16 <lambdabot> No good ones.
12:40:26 <lambdabot> Except this one, which isn't really a blonde one:
12:40:42 <lambdabot> So, a priest, a blonde, a dog, a rabbi, a lawyer, a nun, and a firefighter
12:40:42 <lambdabot> all walk into a bar.
12:40:54 <lambdabot> The bartender says, 'what is this, some kind of a joke?'
12:42:02 <firefly> If I play with do-stuff in ghci in the eval loop, how do I get to see whatever the monad returns?
12:42:08 <firefly> printM?
12:42:15 <Riastradh> x <- foo
12:42:16 <Riastradh> x
12:42:17 <Riastradh> perhaps?
12:42:17 <firefly> @info printM
12:42:23 <firefly> ah, thanks.
12:42:25 <shapr> firefly: you can do stuff like "conts <- readLine"
12:42:37 <SyntaxNinja> return "foo" >>= print
12:42:43 <ski> @info print
12:42:45 <lambdabot> -- print is a variable
12:42:45 <lambdabot> print :: forall a. (Show a) => a -> IO ()
12:43:12 <andersca> @info arr
12:43:17 <firefly> I thought I had to type do in order to play with readLine.
12:43:51 <firefly> And since print refused to do anything with an IO [String] I figured there had to be some magic I needed to learn.
12:44:38 <ski> the whole repl in ghci lives in a do
12:44:48 <SyntaxNinja> if you type [return "foo"] then it won't print anything out, ya know? but if you type [return "foo" >>= print] then it'll print
12:45:11 <firefly> ski: thanks, I didn't know that.
12:45:32 <firefly> SyntaxNinja: thanks, that works too.
12:45:41 <ski> so you can use a let without an in also
12:45:51 <firefly> ski: yes, I did that.
12:46:26 * shapr burbles frumiously
12:46:28 <firefly> One of the things I tried was let xxx = do { ......; return ... }
12:46:37 <firefly> Oh, no, he is a bandersnatch!
12:46:45 <firefly> (looks like one, too)
12:46:50 <shapr> do not!
12:46:50 <Riastradh> A burbling one, no less.  He must have some jabberwocky genes!
12:46:55 <firefly> Got lots of Tulgey woods there?
12:47:02 <firefly> tulgey
12:47:24 * shapr gets out his vorpal monad
12:47:40 <firefly> one-two, one-two!  The vorpal monad went snicker snak!
12:47:56 <firefly> He left it did, and with its head, he went galumphing back.
12:48:03 * Riastradh gets out os laprov comonad.
12:48:14 <Riastradh> s/os/his/1
12:48:15 <ski> shapr : you've got a vorpal monad ? cool !
12:48:27 * Riastradh waves it around very unsafely.
12:48:29 <shapr> firefly: *** Exception: Prelude.head: empty list
12:48:52 <firefly> huh?
12:49:31 * ski looks for his corbamite functor
12:49:36 <shapr> you mistakenly SnickerSnack'd a (Vorpal [])
12:49:38 <firefly> can I ask gchi to tell me the type of an expression?  :i seems to give me the types of the individual components
12:49:47 <shapr> sure, use :t
12:49:50 <shapr> that's how @type works
12:49:52 <firefly> thanks.
12:49:58 <ski> @type shapr
12:49:59 <lambdabot> bzzt
12:50:02 <shapr> @shapr
12:50:03 <lambdabot> needs sleep
12:50:06 <shapr> all too true
12:50:21 <shapr> three hours last night, then an exciting morning taking cats to the vet
12:51:19 <shapr> Category Spam has too many adjunks
12:51:36 <ski> Category Spam ?
12:51:52 <ski> a new category ?
12:51:54 <shapr> category -> adjunct
12:52:02 <shapr> spam -> ad junk
12:52:03 <firefly> right, it looks like I understand >>, >>=, return and the do notation.  So far so good.
12:52:22 * shapr wonders if only the sleep-deprived find that amusing
12:52:31 <firefly> Do they have any friends I ought to make aquintances with?
12:52:45 <shapr> firefly: ever heard of arrows?
12:52:49 * shapr smiles innocently
12:52:54 <firefly> shapr: with sleep it is slightly amusing but not hilarious.
12:53:02 <shapr> oh wait, you're still on monads
12:53:08 <shapr> you should check out the other monad guys
12:53:12 <shapr> @info MonadFix
12:53:22 <shapr> @index MonadFix
12:53:22 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
12:53:22 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
12:53:25 <shapr> @index MonadApply
12:53:25 <lambdabot> bzzt
12:53:28 <shapr> hm
12:53:30 <firefly> Yes.  I heard they had a sort of piercing clarity - after that nobody knows what happens.  Noone has lived to tell the tale.  But they can be quite pretty.  And fast.
12:54:07 <ski> (firefly : know any about category theory ?)
12:54:39 <firefly> I knew a little bit about two years.  Far too little and long forgotten.
12:54:40 <shapr> @index MonadPlus
12:54:40 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
12:54:40 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
12:54:40 <lambdabot> State,Control.Monad.Writer,Monad
12:54:51 <firefly> about _it_ two years _ago_
12:54:56 <ski> firefly : ok
12:55:15 <firefly> Oh, and I know a little bit about Leibnitz ;)
12:55:16 <ski> @index yonedaLemma
12:55:16 <lambdabot> bzzt
12:55:42 <shapr> firefly: you may be interested in MonadPlus, Functor, Monoid, and all the monad transformers
12:55:42 <ski> someone should make a Leibnitz monad
12:55:57 <shapr> ski: problem is, you can only look out ;-)
12:55:57 <firefly> Are arrows better at controlling the viral spread of monads until they encompass your whole program?
12:56:10 <ski> shapr : ?
12:56:18 <shapr> Leibniz' monads?
12:56:46 <shapr> iirc, Leibniz saw the world as cellular automata, each automata had its own 'perception' of the world
12:56:51 * ski doen't remember much of Leibniz' monads
12:56:56 <firefly> It was just some philosophy.  He should have stuck to math.
12:57:13 <shapr> wolfram is trying to revive Leibniz in "A New Kind of Science"
12:57:37 <ski> maybe his monads were a kind of coalgebras ..
12:57:39 <shapr> I think Wolfram is the academic equivalent of a one-hit boy band
12:57:49 <firefly> :)
12:58:41 <jemfinch> most people who like academia think that :)
12:58:48 <ski> Wolfram ?
12:58:53 <ski> oh
12:59:11 <shapr> the author of the book, "A New Kind of Science"
12:59:44 <firefly> The 'Wolfram Research' Wolfram.  The Mathematica guy.
12:59:49 * ski noticed :)
12:59:53 <ski> oh
13:00:15 <ski> the one in http://mathworld.wolfram.com/ ?
13:00:23 <firefly> He is fat, forty, and American.  Poor guy.
13:00:29 <firefly> Yes, that one.
13:00:51 <shapr> hey, I'm plump, thirty-two, and American. It's not that bad!
13:01:17 <SyntaxNinja> then why are you living in Sweden?
13:01:22 <SyntaxNinja> ;)
13:01:42 <firefly> You are only plump - Wolfram is Thomas Aquinas-sized, you are younger, and you don't live there.
13:02:11 <firefly> Aquinas had a specially-built work desk, with a round cut so his arms could actually reach the desk ;)
13:02:18 * shapr falls on firefly, squishing him into the shape of an American!
13:02:41 <firefly> You'll have to bounce on me a lot, then.
13:02:53 <firefly> 75kg, 190cm.
13:02:57 <shapr> when it comes to bouncing, I'm a professional.
13:03:13 <shapr> ha! I'm 100kg, and ... umm
13:03:22 <firefly> atheletic built, strong legs, weak upper body (former long distance runner)
13:03:24 <shapr> 170cm?
13:03:34 <shapr> I'm a former short distance walker.
13:04:07 <stepcut> 190cm, 74kg
13:04:15 <shapr> stepcut: whoa, you're tall
13:04:26 <firefly> no, just ordinary sized ;)
13:04:28 <shapr> actually, is 5'9" ~ 170cm?
13:04:44 <firefly> I dunno, what is 5'9" in real units?
13:04:46 <stepcut> (assuming I converted from 6'3" correctly)
13:04:53 <shapr> stepcut: whoa, you're tall!
13:04:57 <firefly> 6" is about 180,2 cms I think.
13:05:00 <tic> 5.10" = ~178 I think
13:05:05 <stepcut> shapr: :p
13:05:06 <shapr> firefly: I'm about |------------------| that much shorter than stepcut
13:05:29 <shapr> oh, 178cm!
13:05:38 <SyntaxNinja> Oo
13:05:40 * shapr hops tallishly
13:06:10 <shapr> tic: thanks for the conversion
13:06:23 <tic> :)
13:06:42 <tic> http://www.google.se/search?q=180+cm+to+foot&ie=ISO%2D8859%2D1&hl=sv&meta=on&btnG=Google%2Ds%F6kning
13:06:45 <shapr> hey, didn't Pseudonym write some Haskell code to coerce units+values into other units?
13:07:08 <shapr> hah, google has a calculator!
13:07:11 <firefly> 5'10" = 177,80 cm, assuming that an inch is 2,54 cm (which it is unless we are talking about old US maps) and that there are 12 inches to a foot.
13:07:12 <tic> 5'10.8" == 180 cm
13:08:04 <shapr> anyway, I look much taller on my unicycle.
13:08:09 <firefly> shae: so how many stones are you?
13:08:23 <shapr> firefly: IQ-wise? or weight-wise? ;-)
13:08:27 <SyntaxNinja> while we're off topic: http://www.antville.org/img/conspir/nooooo!.jpg
13:08:28 <firefly> (if you are going to use silly units, please use them all the way through)
13:08:46 <shapr> SyntaxNinja: 404!
13:08:47 <firefly> weight.  IQ is probably highish.
13:09:07 <shapr> SyntaxNinja: doh, I can't type
13:09:11 <SyntaxNinja> shapr: wfm
13:09:45 <firefly> Hmmm... what about volume - floating ounces? (real imperial floating ounces, not the cheap American imitation)
13:09:54 <shapr> I float quite well.
13:10:08 <shapr> especially with this little sleep, I've been floating all day.
13:10:24 <firefly> How come the US still is so backwards with the units?  It was even one of the founding members of the meter treaty!
13:10:51 <firefly> shapr: is lack of sleep a problem when one has ADD ?
13:10:51 <shapr> I dunno
13:10:54 <Taaus> Floating ounces? I thought it was Fluid ounces.
13:11:03 <firefly> right, my fault.
13:11:04 <shapr> firefly: sort of... difficulty sleeping is a regular thing.
13:11:23 <firefly> I meant, does it cause more trouble when one has ADD?
13:11:37 <shapr> for social and focus reasons, yes.
13:11:45 <firefly> ok.
13:11:48 <shapr> I'm more impulsive and less likely to stay focussed on what I'm doing.
13:12:20 <shapr> random impulses in social situations tends to cause trouble.
13:12:31 <shapr> "why is that guy chewing on our coffee table?"
13:12:41 <ski> haha
13:13:04 <firefly> It seems to me there are several things grouped unceremoniously together under the ADD label.  One of them is lack of focus and easy distractability.  An other is lack of capability to process all the sensory information, especially in situations with noise, lots of moving things, many people.
13:13:11 <firefly> Or am I completely wrong?
13:13:20 <shapr> those are all the same thing
13:13:25 <firefly> they are?
13:13:38 <shapr> inability or at least difficulty to control the focus of attention
13:14:10 <shapr> without control of the focus of attention, you get too much sensory information in most situations
13:14:27 <firefly> ah, yes, that way round.
13:14:32 <firefly> ah, yes, that way around.
13:14:46 <shapr> I tend to listen to the three conversations nearest me, not always including the one I'm in
13:15:13 <shapr> on the good side, that can be exploited to 'force-feed' information
13:15:19 <firefly> can you then really follow those three conversations or are you jumping around too much?
13:15:29 <shapr> most of the time I can really follow them
13:15:41 <shapr> because conversations that I *am* in go too slow
13:15:52 <shaleh> heh
13:15:59 <shapr> so I listen to the stuff around me while I wait for this person to finish their sentence.
13:16:06 <shaleh> I thought I was the only one who listened like that
13:16:20 <firefly> In my good days I could follow four conversations -- completely.  I have recovered enough now that I can follow two now.  Sigh.
13:16:35 <firefly> And yes, normal people think and react so *slow* ;)
13:16:39 * shapr grins
13:17:20 <shapr> there's this trick where someone drops a piece of paper money, and people aren't supposed to be able to catch it
13:17:25 <shapr> you know the trick?
13:17:36 <firefly> (I do not have any ADD problems, though, and I took care to not only follow the conversation I was in but to also make the right facial cues so as not to throw off the other parties in that conversation)
13:17:46 <stepcut> shapr: I know the trick...
13:18:01 <shapr> I think ADD is a spectrum thing, accounts have much less and some people have much more
13:18:29 <shapr> in general, the western society rewards accounts more than explorers
13:18:32 <shapr> accountants
13:18:43 <firefly> Is the trick to 1) be fast, 2) be on an edge-trigger, and 3) not watch the money but the person.
13:18:52 <TheHunter> @state
13:18:52 <lambdabot> GER-CZE 1:2, NED-LAT 2:0
13:18:57 <TheHunter> dammit!
13:19:24 <firefly> Football is a game with 22 players where Germany wins in the end?
13:19:29 <shapr> firefly: I dunno, I just catch the money.
13:19:35 <firefly> :)
13:19:50 <firefly> So you have extremely fast reactions?
13:20:02 <firefly> Are your reflexes precise or not?
13:20:07 <shapr> I think that my focus switches very quickly, I dunno if that's the same thing
13:20:19 <firefly> I don't think it is.
13:21:55 <shapr> so, bright colors grab my attention automatically, in hardware or something... so I exploit it: http://www.scannedinavian.org/~shae/screenie.png
13:22:05 <firefly> I can probably skip reading up on type classes, can't I?
13:22:21 <shapr> type classes are very cool
13:22:33 <shapr> one of the things ML'ers often like most
13:22:41 * stepcut hopes to never use shapr's computer
13:22:43 <firefly> Sure.  But I just want to hack a bit on darcs.
13:22:56 <shapr> oh, I dunno how much he uses typeclasses
13:23:07 <shapr> stepcut: hah! what's your emacs color-theme like?
13:23:16 <stepcut> shapr: default
13:23:22 * Lukhas agrees with stepcut 
13:23:45 <firefly> The idea /is/ neat.  It sometimes seems very cramped that you only have ordinary polymorphic types and equality polymorphic types.
13:24:07 <firefly> And the way overloading is done for +, -, *, / is a bit messy.
13:24:31 <firefly> The next thing I probably need to skim through is the libraries.
13:25:17 <firefly> what is the difference between rem and mod?
13:25:37 <firefly> $! ?\
13:25:38 <shapr> remainder and modulus?
13:25:40 <firefly> $! ?
13:26:12 <shapr> I dunno?
13:26:14 <ski> rem is evil, mod is good
13:26:17 <firefly> yeah, is the difference something about the signs?
13:26:19 <ski> ;)
13:26:34 <firefly> as long as we know that.
13:26:51 <ski> rem gives rests of same sign as numerator
13:26:59 <ski> mod gives rests of same sign as denominator
13:27:00 <ski> iirc
13:27:06 <firefly> Ok, thanks.
13:27:18 <ski> % in C is like rem
13:27:23 <andersca> @state
13:27:28 <firefly> Hmmm... import qualifed.  Nice.  Been wanting that for a long time.
13:27:39 <ski> what's this @state business ?
13:28:00 <firefly> @state
13:28:18 <ski> @yow
13:28:18 <lambdabot> Laundry is the fifth dimension!!  ...um...um...  th' washing machine
13:28:18 <lambdabot>  is a black hole and the pink socks are bus drivers who just fell in!!
13:28:27 <shapr> @state foo
13:28:29 <shapr> @state bar
13:28:29 <lambdabot> foo
13:28:38 <shaleh> @state yow
13:28:38 <lambdabot> bar
13:28:42 <shapr> it's a demo plugin to show how to save state in lambdabot
13:28:49 <ski> oh, ok
13:29:36 <bringert> shapr: arrgh, my eyes had just about recovered from seeing your emacs window at eurohaskell
13:29:42 <shapr> haha!
13:30:25 <Taaus> shapr: Hmm.. What windowmanager is that, Ion(2) ?
13:30:28 <shapr> I really don't understand this set of grey-on-grey emacs color-themes that people seem to like
13:30:31 <shapr> Taaus: yup
13:30:52 <bringert> shapr: did I mention that I gave John his t-shirt?
13:30:58 <bringert> he seemed to like it
13:31:00 <shapr> bringert: oh cool! what did he say?
13:31:15 <Taaus> shapr: Ah, same wm I use. Very nice. Although the default keybindings are... Silly.
13:31:19 <shaleh> shapr: I am white on black
13:31:25 <shapr> shaleh: that's better
13:31:34 <shapr> Taaus: mine are heavily modified to get out the way of emacs
13:33:00 <mwb> Ick.
13:33:02 <Taaus> shapr: Ah. You use the Dvorak keyboard layout, right? Does that work well with emacs? 
13:33:09 <shapr> yah, it works fine
13:33:21 <bringert> shapr: can't remeber his exact words, but he liked it and thanked the eurohaskell participants
13:33:29 <shapr> neat
13:33:47 <shapr> bringert: I was highly amused when he had to ask you to translate one word from swedish to english
13:33:54 <bringert> :)
13:33:58 <bringert> yeah
13:34:07 <bringert> his swedish is very good
13:34:21 <shapr> faster than I can understand it
13:34:55 <shapr> maybe next year :-)
13:35:02 <mwb> If I look at that long enough the lime doesn't burn my eyes anymore.
13:35:45 <shapr> mwb: is that good or bad?
13:36:00 <bringert> it took me quite a while to learn to speak swedish to him though, the image of him standing at the front of our intro programming class shouting "list comprehension" was too strong
13:36:08 <shapr> haha
13:36:29 <bringert> dunno why he doesn't teach that class in swedish
13:36:50 <shapr> I could see he had trouble speaking english to you guys several times, he wanted to speak swedish.
13:36:58 <shapr> is that course part of an international program?
13:37:15 <shapr> I know they teach CS courses in english in Lulea
13:37:50 <shapr> what the heck does this actually do? "evaluate a = gen where Prop gen = property a" ?
13:37:58 <arjanb> @state
13:37:58 <lambdabot> yow
13:40:30 <shapr> oh, does it unpack the (Prop gen) that it gets from property?
13:41:24 <Spark> i'm lame, but i dont see how thats different from "evaluate a = property a" :p
13:41:34 <bringert> it wasn't part of an international program, but I think it might be starting this year
13:42:46 <shapr> Spark: I thought that until just now. I think that (property a) returns a (Prop foo) value, and that where is a cute way to unpack the Prop constructor and return its value
13:45:10 <firefly> (,,,) 1 2 3 4  -- aaargghh!
13:45:24 <ski> huh ?
13:45:27 <Taaus> Heh.
13:45:28 <firefly> Haskell really /is/ the C++ of functional languages.  With Microsoft extensions thrown in :(
13:45:32 <shapr> Spark: aha, yes!
13:45:39 <shapr> data Flib a = Flob a
13:45:39 <shapr> flib a = Flob a
13:45:39 <shapr> fooby a = inbit where Flob inbit = flib a
13:45:44 <shapr> fooby "whateveh"
13:45:47 <shapr> "whateveh"
13:45:56 <shapr> Spark: did that make sense?
13:46:10 * Spark parses
13:47:47 <ski> firefly : isn't that similar to a section ?
13:47:52 <firefly> ski: (,,,) is a constructor for a 4-tuple.  Me, I just think it looks weird.
13:47:59 * ski knows
13:48:01 <firefly> Dunno.
13:48:17 <ski> like (/4) and (4/) and (/)
13:49:19 <firefly> hmmm.... those sections only work for functions of two (curried) parameters, right?
13:49:27 <firefly> I can see the equivalence, but...
13:49:34 <firefly> it still looks weird.
13:49:43 <shapr> map takeOff [zig1,zig2]
13:50:08 <firefly> Apparently, Haskell 98 only guarantees tuples of up to 15 members.  Great.
13:50:23 <shapr> firefly: but it's easy enough to make your own tuples of larger size
13:50:29 <shapr> I think GHC does up to thirty-something
13:50:47 <shapr> and Template Haskell lets you generate all that tuple stuff on the fly
13:51:02 <firefly> shapr: how?  or did I misunderstand in which way Haskell only guarantees sizes up to 15?
13:51:42 <TheHunter> Show instances are only provided up to 5 elts
13:51:48 <firefly> Does it mean that only constructors up to (,,,,,,,,,,,,,,) are guaranteed to be defined and that I can define my own?
13:51:48 <shapr> iirc, you just need to make stick (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) and friends into a file
13:52:05 <shapr> I think so
13:52:19 <shapr> TheHunter: according the H98 Report? or GHC?
13:52:21 <firefly> Ok, so it is not some basic limitation in the type system, parser, run-time system, etc.
13:52:28 <shapr> don't think so
13:52:36 <firefly> Phew.
13:52:40 <TheHunter> shapr: ghc
13:53:24 <shapr> neat, I didn't know that
13:53:25 <TheHunter> and the maximal size is 62, in ghc
13:55:17 <firefly> Ah, so /that's/ what $! does.
13:59:05 <TheHunter> firefly: be careful: head $! [1, bottom] == 1
13:59:14 <TheHunter>     where bottom = error "Bottom"
14:00:23 <firefly> really?  I thought the `seq` took care of that.
14:01:27 <Riastradh> Nope.
14:01:35 <TheHunter> i'm not sure anymore if I defined bottom correctly
14:02:00 <Riastradh> Prelude> [1,2/0] `seq` 3
14:02:00 <Riastradh> 3
14:03:06 <firefly> right, [1, bottom] is sugar for 1 : bottom : nil, where : works like a function.
14:03:14 <firefly> Is that correct?
14:06:27 <ski> yes
14:06:34 <ski> except s/nil/[]/
14:06:41 <ski> and (:) is a function
14:06:46 <firefly> yes, I found that out when I actually tried it ;)
14:07:27 <ski> @type (:)
14:07:28 <lambdabot> (:) :: forall a. a -> [a] -> [a]
14:07:33 <firefly>  The difference between functions and constructors are small anyway.
14:07:35 <ski> @type []
14:07:37 <lambdabot> [] :: forall a. [a]
14:07:39 <firefly>  The difference between functions and constructors is small anyway.
14:07:48 <ski> all constructors are functions
14:07:55 <ski> hmm
14:08:07 <ski> all constructors with arguments are functions
14:08:15 <ski> (i.e. non-constant constructors)
14:08:37 <jemfinch> : would be a constructor if not for typeclasses, right?
14:08:40 <firefly> yep.
14:08:48 <jemfinch> cool.
14:09:00 <ski> huh ?
14:09:07 <firefly> jemfinch: it was not a reply to you.
14:09:29 <ski> jemfinch : (:) is a constructor
14:09:33 <ski> @info :
14:09:35 <lambdabot> -- : is a data constructor
14:09:35 <lambdabot> infixr 5 :
14:09:35 <lambdabot> (:) :: forall a. a -> [a] -> [a]
14:09:40 <ski> sic !
14:10:03 <ski> lambdabot said it, so it must be true !
14:10:10 <ski> ;)
14:10:42 <ski> jemfinch : fyi, (:) is not overloaded, just polymorphic
14:10:59 <jemfinch> ski: yeah, I know.
14:11:13 <jemfinch> thanks though :)
14:14:26 <firefly> Can I ask ghci what types are in a given class?  Or what classes a given type are in?
14:15:34 <monotonom> I don't think it is easy.
14:16:09 <ski> hugs can do that
14:16:22 <firefly> I am fully satisfied with just those in the ghc libraries.
14:16:26 <firefly> ski: thanks.
14:16:36 <ski> (just :i)
14:16:51 <firefly> damn!  openvt refuses to let me open a ninth vt.
14:17:00 <monotonom> One feeble thing we can do for the first kind of question is: let's say we want to know if [a] is a monad, we can try "return () :: [Int]" and see if it works.
14:17:52 <ski> it doesn't
14:18:16 <monotonom> Ooops "return () :: [()]"
14:19:34 <monotonom> Alright how do you phrase a ":i" query for such purposes?
14:20:12 <ski> in hugs ?
14:20:17 <monotonom> Ah, ":i []" works.
14:20:35 <ski> or :i Monad
14:21:33 <monotonom> Yes. Hugs lists all instance of a class and all classes of a type.  GHC doesn't.
14:22:58 <firefly> Argh.  ^, ^^, **.  Not satisfied with being the C++ of functional languages, does it want to be the Ada and PL/I, too?
14:23:01 * firefly rants
14:23:12 <Riastradh> @type (^)
14:23:14 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
14:23:17 <Riastradh> @type (^^)
14:23:18 <jemfinch> firefly: I concur :)
14:23:19 <lambdabot> (^^) :: forall a b. (Integral b, Fractional a) => a -> b -> a
14:23:22 <Riastradh> @type (**)
14:23:25 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
14:23:42 <monotonom> I have no gripe with ^,^^,**; in fact I like having all of them.
14:23:45 <firefly> Riastradh: I know.  I just read about them in the Haskell 98 report.
14:25:55 <monotonom> 0.5^3 is probably faster and more accurate than 0.5**3.0
14:26:13 <monotonom> They are all there so you can use the right one for the right purpose.
14:26:51 <monotonom> In fact to properly support numerical work, there ought to be an infinite family of "equality" operators too, IMHO.
14:27:58 <ski> isn't there ?
14:28:01 <firefly> =, ==, ===, =4=, =5=, =6=, ..., =n= ;)
14:29:13 <ski> with  a =n= b  ==>  a =n+1= b  ?
14:29:33 <firefly> sure.
14:29:44 <firefly> unless overridden somewhere, of course.
14:34:15 <firefly> I think a break before I embark on chapter 7 (basic input/output) is a good idea.
14:36:41 <jemfinch> I don't get it.
14:40:22 * TheHunter just found out that (***), (&&&), (+++) and (|||) are the basic primitives for products (pairs) and disjoint sums (Either) he has always searched for
14:41:19 * earthy smiles at kosmikus
14:41:28 <earthy> looks like you'll be talked to tomorrow. :)
14:42:28 <kosmikus> yes, that's the only thing I don't like about it
14:42:46 <kosmikus> otherwise I am happy that one of the two teams I'm in favor of made it through
14:43:26 <ski> firefly : you're reading a tutorial ?  yaht ?
14:44:30 <firefly> ski: no, the Haskell 98 report.  The last version I read was the 1.4 version and I didn't get as far as I am now.
14:45:04 <firefly> There aren't /that/ many new concepts for me in haskell, so I might as well read the report instead of a tutorial.
14:45:46 * firefly is getting grilled salmon in a few minutes :)
14:45:51 <ski> ok
14:45:58 <ski> yummy
14:46:31 <firefly> better than surstroeming ;)
14:47:33 * ski hasn't tasted that
14:48:13 * firefly_ wouldn't want to!
14:48:20 * ski just discovered Control.Exception.mapException
14:48:45 <earthy> time for bed.
14:49:13 <ski> hmm, "interact error" is fun !
14:49:33 <icb> where is the default format for Double kept?
14:49:49 <ski> huh ?
14:50:25 <icb> on some environment i notice Double is displayed in decimal while on other oses it is displayed in scientific notation
14:52:54 <ski> haskell specific or general ?
14:53:09 <icb> haskell of course :)
14:54:24 <ski> not sure if the standard specifies how to show Doubles
14:55:00 <icb> what's your os platform?
14:57:05 <ski> FreeBSD and Solaris here at uni
14:57:41 <icb> e.g. when i do "show 123456789.11" on linux i get 12345789.11 
14:58:42 <icb> when i do the same on os10, i get 1.2345678911e8
14:59:11 <ski> in hugs here i get "123456789.1", in ghci i get "1.2345678911e8"
14:59:45 <icb> i am getting e8 on both hugs and ghci on the os10, and all decimal on gentoo linux
15:14:00 * ski 's off
15:19:47 <Hyp3rion> is there something like topcoder.com that accepts code in sane languages? topcoder only seems to accept c and java :-/
15:20:41 <shaleh> topcoder takes code for things people get paid for
15:21:04 <Taaus> There's the Valladolid ACM programming challenges. They allow such sensible languages as C++ and Pascal, in addition to C and Java! :P
15:21:32 <Hyp3rion> Taaus :-D
15:21:41 <shaleh> so it reflects needs in corporate society
15:22:46 <Hyp3rion> shaleh - yeah true but too bad "corporate society" has theese needs
15:24:10 <monotonom> That is odd because I am sure a lot of MSVC++ users swear C++ makes them a lot of money.
15:24:23 <monotonom> I mean I understand Pascal being omitted.
15:27:49 <Hyp3rion> ? what's so ad about pascal
15:27:56 <Hyp3rion> s/ad/bad/
15:28:21 <monotonom> Did I say anything bad about Pascal?
15:28:52 <Hyp3rion> monotonom - do you like pascal?
15:29:58 <monotonom> That's unimportant personal sex-orientation.
15:30:38 <Hyp3rion> XD
18:55:55 <SamB> hmm... the downside of homeschooling is that your mother might not let you stop when you've done enough...
19:10:16 <saynte> har har
19:14:42 <SamB> like, I could use some time off before college... but she wants me to finish my physics, psychology, and english...
19:55:12 <saynte> they let you go to college on homeschooling?
19:56:06 <Cale> of course
19:56:55 <Cale> I know at least one person at my uni who didn't bother to get her highschool diploma.
19:57:21 <SamB> saynte: I'm going to an actual college...
19:57:44 <saynte> SamB: they have FAKE colleges?
19:58:11 <saynte> man i gotta watch out... didn't know things were so deceptive :)
19:58:19 <SamB> well, whatever.
19:58:22 <saynte> Cale: oh yeah? waterloo was always a little fickle :)
19:59:28 <saynte> well was just wondering how one verifies homeschooling effectiveness.
19:59:35 <saynte> from the college's point of view
20:00:43 <SamB> well, how do you verify the effectiveness of american public schools?
20:01:03 <saynte> well usually there are curricula
20:01:13 <saynte> but i'm not in america, so that's just hazarding a guess
20:01:37 <saynte> but there are quantified results usually. not saying homeschooling is ineffective, just wondering how that whole process goes.
20:04:21 <SamB> well, I took a dead boring Perl class at community college and got about 100%... and I went to something called governor school last summer... and I don't know what all else... and they seem satisfied that I am smart enough.
20:05:06 <saynte> oh well that's all good, probably smarter than i am! (most people are :)). I was just curious is all
20:05:41 <saynte> admissions here are based on HS marks, do you have to take some sort of entrance test?
20:06:04 <Cale> well, they will use HS marks if they are relevant
20:06:25 <SamB> oh, yeah. I took the SAT and got an 800 in math, and I took the AMC12 and got invited to take the AIME...
20:06:43 <saynte> SAT, heard of that. AMC12 and AIME, no clue :)
20:07:18 <SamB> they are fun math tests.
20:07:18 <SamB> the AIME is hard ;-)
20:07:37 <saynte> haha ah yeah, Cale's school puts out some of math tests to the highschools
20:07:52 <SamB> I'm sure scads of americans haven't heard about them either
20:09:25 <saynte> oh probably. sort of niche things that they are
21:07:06 <Pseudonym> According to my inbox, the US is full of prestigious non-accredited colleges.
21:07:40 <saynte> prestigious non-accredited, intriguing.
21:08:10 <Pseudonym> Yes.  But that's my inbox for you.
21:08:26 <Pseudonym> In addition, apparently Canada is full of cheap generic viagra.
21:08:45 <saynte> Yes, and it's all mine!
21:09:36 <saynte> I have huge stockpiles. I'm like scrooge mcduck, every once in a while I go swimming in them.
21:17:06 <Riastradh> According to my inbox, there are thousands of damsels in distress who have gigantic fortunes in Nigeria that need just fortunes of equal size in order to retrieve their own.
21:17:41 <Pseudonym> Not just damsels either.
21:20:00 <Pseudonym> According to my wife's inbox, she could better satisfy her woman if she had a larger penis.
22:32:31 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelld #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/cabal/"]'
22:32:31 --- topic: set by shapr on [Tue Jun 22 06:23:46 2004]
22:32:31 --- names: list (clog norpan Verbophobe themaximus [dan] gdsx Lurc isomer mwb opet kosmikus keverets sorrow ozone dennisb mikef Lunar^ sundeep seafood blackdog Lukhas jesse_ tyler Cale monotonom earthy shammah skylan ibid det SamB cmeme wagle Lemmih Philippa tic musasabi shaleh maihem Jon rubix^3 flaw Matt-W sazzle noclouds yauz Pseudonym saynte icb Joachim_ Igloo mattam Codex ludde juhp Riastradh desrt ksandstr lispy Pinnen vegai dons edwinb titanstar)
22:32:31 --- names: list (Fractal Taaus Spark shrimpx neologism)
