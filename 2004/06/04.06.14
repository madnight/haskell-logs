00:21:43 <earthy> .: unreadable
01:07:47 <Brandon> hello :)
01:57:10 <Lunar^> bringert: I would like sebc to proof-read them before putting them online
01:57:19 <Lunar^> bringert: But it was my plan
01:57:36 <Lunar^> btw, Limi is right: planes are a great place to work
01:57:52 <Lunar^> I have a proof of concept for the TH Intl module
03:09:15 <mbossa> PARTY
03:19:21 <mayhem> hi peoples
04:15:19 * shapr boings happily
04:58:06 <liiwi> sproing
04:58:20 * shapr bounces
05:00:21 <earthy> what's up, shapr?
05:00:31 <shapr> ceilings!
05:01:20 <shapr> my profundity is legendary.
05:01:35 <shapr> actually, I was just thinking about porting all my PLog entries over to BLob
05:02:20 <earthy> yes, you *are* quite extreme. ;P
05:04:41 <Lunar^> shapr: I wrote some code !
05:05:13 <shapr> yay!
05:05:16 <shapr> code is good!
05:05:19 <shapr> I haven't written any :-(
05:05:21 <Lunar^> shapr: During my trip to Paris actually
05:05:26 <shapr> awesome, what did you write?
05:05:36 <Lunar^> shapr: It's a proof of concept for an i18n framework
05:05:44 <shapr> cool, how does it work?
05:05:47 <Lunar^> shapr: The idea is that it uses Template Haskell to generate the POT file during compilation
05:06:39 <Lunar^> shapr: I still have the writer thing to do, but it actually parses PO, and makes a set of all strings
05:06:55 <shapr> sounds good, just like Plone's PTS
05:07:21 <Lunar^> The only problem is that you have to make sure to build ALL files, otherwise you can loose some strings
05:07:28 <shapr> but hopefully with better error messages (it'd take work to be worse)
05:08:01 <Lunar^> Anyway, we had this idea during our last lunch with bringrt and andersca
05:08:06 <shapr> cool!
05:08:18 <Lunar^> I'll try to finish that before the week-end
05:08:25 <Lunar^> Post it on haskell-cafe for comment
05:08:34 <shapr> I wish ghc handled utf in source files
05:09:17 <Lunar^> It's going to use Ian's TH printf
05:09:28 <Lunar^> All you'll have to do is replace 'printf' with 'tr'
05:09:36 <shapr> nifty!
05:09:37 <Lunar^> Or another function name if you have any
05:09:58 <Lunar^> The only problem, is really that ==> getText :: CString -> IO CString
05:10:44 <Lunar^> That means a lot of unsafePerformIO
05:10:56 <shapr> :-(
05:12:22 <shapr> hey anth
05:12:41 <shapr> bye anth
05:12:55 <shapr> re anth
05:15:05 <phubuh> this is just wild speculation, but perhaps the translation table could be loaded imperatively in main :: IO (), and then passed along as a purely functional data structure using implicit parameters
05:16:27 <shapr> or maybe tr could be partially applied to the msgid, and then applied to the lookup table impurely.
05:17:33 <shapr> I've realized that one of the big mental differences in Haskell is that (unlike procedural programming) you often end up *not* doing something yourself. You often whip up a function to pass to another function that's closer to being 'main'
05:17:43 <shapr> of course, I've seen that most explicitly in HaskellDB
05:18:25 <shapr> you don't do a query yourself in HaskellDB, you just write up the query code that takes a database and other parts, and then you pass that to 'main' HaskellDB loop.
05:19:33 <shapr> in essence, I'm agreeing with phubuh's idea, though I don't like implicit parameters much.
05:19:45 <shapr> phubuh: good idea!
05:19:52 * shapr hops randomly
05:20:10 <earthy> sounds like EuroHaskell was great :)
05:20:18 <phubuh> it was!
05:20:48 <shapr> I did a good job of not being random or disruptive at EuroHaskell (I think). I was relatively well focussed.
05:21:19 <shapr> it was FUN!
05:21:31 <shapr> I got to meet lotsa #haskell denizens.
05:21:46 <shapr> konichiwa ikegami-san
05:21:58 <ikegami> hi!
05:22:28 <shapr> how's code?
05:24:13 <Lunar^> The idea is actually to use $(tr "my string")
05:24:30 <Lunar^> and 'tr' to generate the needed code to do the translation
05:24:48 <Lunar^> Also, with gettext, you can't load all translations at once
05:25:06 <shapr> why not?
05:25:20 <shapr> too much ram?
05:25:55 <Lunar^> You just can't
05:26:07 <Lunar^> There's no functions that says "load all strings"
05:26:17 <Lunar^> Though you can always rewrite a .mo loader
05:26:26 <shapr> I think I saw a pure Haskell imp of gettext
05:26:34 <shapr> but I may be confused
05:27:55 <Lunar^> gettext does IO
05:28:08 <Lunar^> Though you could make it pure
05:28:22 <Lunar^> by loading it in main
05:37:12 <ikegami> does Haskell's i18n proceed?
05:37:36 <ikegami> I'm afraid that the current GHC cannot treat multibyte chalacters
05:38:54 <ludde> isn't Char 16 bits?
05:39:37 <ibid> 32 bits iirc
05:39:43 <ibid> enough to handle all of Unicode
05:40:05 <Lor> They're boxed, room to spare...
05:42:13 <ibid> ok, what about Char# :)
05:44:48 <ikegami> I have never heard Char#
05:44:56 <shapr> it's an unboxed Char
05:44:58 <ikegami> (I'm a newbee
05:45:04 <ikegami> oh
05:45:46 * shapr wonders if there's an explanation of unboxed on the wiki
05:47:24 <Lor> Actually, I think there is very little use for a Char data type in any context.
05:48:04 <Lor> It usually acts either as an efficient alternative for very short strings, or then as a binary octet.
05:48:37 <Cale> But you want to be able to treat strings as lists of Chars
05:48:44 <Lor> No.
05:48:50 <Lor> Not in any language.
05:49:16 <Lor> The concept of a character is very vague in any case, and English is one of the few languages where you can even do it without bigger difficulties.
05:49:21 <ibid> treating a string as a list of characters breaks in Unicode
05:49:32 <ibid> what Lor said :)
05:49:56 <Lor> There's been _huge_ amounts of discussion about this in comp.lang.scheme.
05:50:08 <Cale> Well, you want them to at least be typed in some monad :)
05:50:13 <Lor> It seems that everything breaks because of ﬂ.
05:50:36 <ibid> what monads have to do with it?
05:51:05 <Cale> it's convenient to be able to use map and such with strings.
05:51:20 <Lor> But you just can't do it. Not in general.
05:51:50 <Lor> Well, there are several ways in which you could iterate the components of a string.
05:51:50 <Cale> so what is something which doesn't work?
05:52:12 <ibid> in fact, i'd advocate against the name "string" in any case, as it suggests "string of characters" ie. "list of characters"
05:52:29 <Lor> Suppose you want to say (map toUpper str).
05:52:35 <ibid> my current language wip uses Text as the type name
05:52:56 <ibid> and there are no characters (except as short texts:)
05:53:13 <Lor> map toUpper "Weiﬂ"
05:53:13 <Lor> "WEI\223" :: [Char]
05:53:28 <Lor> Now, that is simply wrong.
05:53:43 <ibid> what's \223?
05:54:09 <Lor> It's ﬂ.
05:54:19 <ibid> ok, agreed on wrong then
05:54:36 <ibid> (actually, agreed on wrong in any case:)
05:54:49 <ibid> the correct version is of course WEISS, no? :)
05:55:37 <Lor> Yeah.
05:55:38 <Lor> http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt
06:01:16 * Philippa_ can think of exactly one good argument for string-as-list char which is that it's an aid to parsing. 'sabout all you get though
06:01:30 <shapr> it's elegant for pattern matching
06:02:47 <shapr> in any case, I'd rather have UTF
06:03:05 <ibid> which UTF?
06:03:15 <shapr> utf32 of coures!
06:03:17 <shapr> course
06:03:21 <ibid> UTF-7?  UTF-8?  UTF-16? UTF-32?:)
06:04:25 <Lor> The internal representation is just an implementation issue.
06:04:34 <Lor> (But UTF-8 seems like the most sensible one)
06:05:52 <ibid> at least when most of the string would be representable as ASCII
06:06:18 <Lor> You always have to make some assumption about the distribution of characters.
06:06:36 <Lor> It seems sensible to bias towards ascii.
06:07:16 <shapr> what's the exact tradeoff?
06:07:18 <ibid> it depends really on what application is being written
06:07:40 <ibid> shapr: UTF-8 is efficient on mostly-ASCII, UTF-16 on mostly-multibyte
06:07:47 <Lor> utf-16 is a bit shorter if you deal extensively with non-western characters.
06:07:58 <Lor> and utf-32 is not efficient for anything. :)
06:08:01 <shapr> seems easy enough to calculate how many high-bit chars in a string would make utf-16 more efficient
06:08:05 <ibid> Lor: heh
06:08:16 <ibid> high-bit chars?
06:08:21 <shapr> non-ascii
06:08:28 * SyntaxNinja bounces around shapr
06:08:34 <Lor> Of course, in utf-16 practically all the characters are of the same width, which may make things easier.
06:08:35 * shapr gets dizzy, falls over
06:08:40 <ibid> shapr is a 8-bit weenie :)
06:08:50 <Lor> On the other hand, UTF-8 has been designed to be very practical for string operations.
06:09:00 <ibid> UTF-32 has the nice property that all characters are easily addressable
06:09:06 <shapr> actually, I've been doing portuguese, czech, and some other non-ascii stuff lately.
06:09:33 <ibid> like i said, 8-bit weenie 
06:09:34 <ibid> :)
06:09:38 <ibid> (i'm one too)
06:10:55 <shapr> Voc√™ n√£o est√° autenticado
06:11:28 <earthy> Acho que voce fala portugues...
06:11:35 <shapr> :-P
06:11:40 <earthy> porque?
06:11:56 <shapr> anyway, I don't think e circumflex is ascii.
06:12:10 <earthy> it isn't. nor is a tilde or a accent aigu
06:12:23 * shapr beats ibid with a 16-bit character
06:12:27 <Lor> No accented characters are in ascii.
06:12:39 <shapr> hah! my character is bigger than yours :-P
06:12:43 <earthy> not even all accents are in ascii
06:12:58 <shapr> right, croatian/czech stuff is right out.
06:13:04 <earthy> it is, after all, the American Standard Code for Information Interchange
06:13:07 <shapr> like c smiley
06:13:14 <shapr> what the heck do you call the smiley on top of the c?
06:13:29 * shapr hops around randomly
06:13:30 <earthy> mezenek?
06:13:34 <shapr> really?
06:13:43 * shapr has never heard that word before
06:13:44 <shapr> @wn mezenek
06:13:45 <lambdabot> No match for "mezenek".
06:13:48 <earthy> something like that
06:13:51 <shapr> @all-dicts mezenek
06:13:52 <lambdabot> No match for "mezenek".
06:13:57 * shapr shrugs
06:14:16 <shapr> I believe you, I have no clue about such things like that.
06:17:39 <ibid> shapr: note that ASCII is a 7-bit code :)
06:18:08 <earthy> it's a caron
06:18:15 <earthy> and the other one is an ogonek
06:19:00 <earthy> (the comma slanted topleft-bottomright)
06:19:04 <shapr> bah
06:19:22 <earthy> http://wwwwbs.cs.tu-berlin.de/user/czyborra/charsets/
06:20:34 <shapr> bringert: hey, does BLob support pix?
06:21:03 * shapr browses the sources
06:22:35 <shapr> ah, of course it does. you just stick the <img> in there
06:24:37 <shapr> hi Brandon 
06:24:46 <shapr> are you also skew?
06:25:16 <shapr> if not, are you looking for Haskell info?
06:26:40 * shapr considers hacking PLog's various custom tags into BLob
06:29:08 <SyntaxNinja> Igloo: you've got mail
06:29:45 <shapr> I wish Parallel GHC were updated along with the standard GHC
06:30:25 <ikegami> why? for the performance?
06:30:56 <shapr> yes, I now have a dual-CPU machine, and I don't plan on purchasing any single-cpu machines in the future.
06:31:09 <ikegami> hehe
06:31:16 * shapr noticed an SMP laptop recently
06:31:35 <Igloo> Ta Syn
06:34:30 <ikegami> the parallel GHC is interesting for me, because I work a project to improve performance of a software which is written in Haskell
06:34:51 <ikegami> I wish that the parallel GHC helps
06:35:58 <shapr> me too
06:37:19 <Brandon> hi shapr
06:37:24 <Brandon> no, I'm not skew
06:37:45 <shapr> hi Brandon, do you have questions about Haskell?
06:38:12 <Brandon> to be honest, yes
06:38:51 <shapr> how may we assist you?
06:40:21 <Brandon> interesting that one of the few times I joined somewhere to see what the enviroment of people was like, and absorb a bit about the topic, but not with intent to talk much at first, etc...
06:40:39 <Brandon> they offer to allow me to ask questions :)
06:40:49 <Brandon> Okay, I'm tired of a lot of things in this world, to start.
06:41:08 <Brandon> I feel people aren't using their capabilities and I've had to deal with the resultant projects
06:41:38 <Brandon> Voice recognition is terrible, at least as far as I've experienced with the projects I've worked on.
06:41:58 <shapr> I agree, I'd like to work on voice recognition in Haskell.
06:41:59 <Brandon> The little bits of intelligence put into OS X seem like they should have been done a long time ago with OS's like windows, etc.
06:42:15 <Brandon> You hit a key and the windows size so you can see them all..
06:42:26 <Brandon> they have the summarize program which summarizes the text on the page
06:42:27 <shapr> yah, I like that feature.
06:42:32 <Brandon> with a slide-bar scale 
06:42:59 <Brandon> I've been coding in C for about 14 years
06:43:05 <shapr> ouch
06:43:18 <Brandon> I like how efficient it is .. not the coding, though.. that's not very efficient.. 
06:43:33 <Brandon> but I also coded in ASM and am acquainted with the end result machine language
06:43:34 <shapr> yah, my programming fetish is expressiveness
06:43:39 <Brandon> as far as 8086 asm goes
06:43:46 <shapr> speed is not very important to me
06:44:03 <shapr> I want to minimize development time, maximize abstraction, that sort of thing.
06:44:07 <Brandon> it has been to me because I've had to code a live high volume web service
06:44:28 <Brandon> I've also had to code multi-line bbs systems that ran on a very slow 386 or 486 and whatnot
06:44:31 <shapr> well, I've been using Plone/Zope, and they're much slower than both Haskell and C, but still fast enough for *many* users.
06:44:52 <SyntaxNinja> Brandon: which BBS software did you work on?
06:45:02 <Brandon> and, coming from asm, one learns how to be very efficient.. each line meant something, basically
06:45:13 <Brandon> that was even more important prior to asm :)
06:45:30 <Brandon> anyhow.. it becomes a part of ones way of thinking, so it comes naturally
06:45:33 <Brandon> the method of design includes it
06:45:39 <Brandon> it also includes sacrificing one thing for another
06:46:07 <Brandon> for instance, I traded disk space (using more diskspace) by generating many static HTML files many years ago.. hundred thousand of them.. 
06:46:20 <Brandon> so the front-end speed would be fast
06:46:27 <Brandon> made one of the faster shopping cart sites that way
06:46:36 <Brandon> got compliments from visitors and yadda yadda
06:46:41 <Brandon> in any case.
06:46:45 <Brandon> mbbs, syntaxninja
06:47:14 <Brandon> from the ground up I coded our public free messageboard system.. 
06:47:45 <Brandon> have about 40million hits per month, and about 180k forums total
06:48:10 <Brandon> and I got that to run on a relatively medium-end pc machine up until relatively recently
06:48:33 <Brandon> so.. now I'm just kind of tired of the C .. what do I call it
06:48:37 <Brandon> torturous labor?
06:48:47 <shapr> yup
06:48:49 <shapr> sounds familiar
06:48:57 <shapr> time to let the PC do the backbreaking labor :-)
06:49:00 <Brandon> It's great, and it's important to be able to have that control.. but I do not see why a language could not be just as efficient, but a bit more powerful
06:49:23 <Brandon> well, because some of my tasks are still going to require intensive processing, in most aspects
06:49:24 <shapr> from what I've heard, the average Haskell program is seven times slower than C
06:49:34 <Brandon> be it processing, disk speed, etc.  I still must be efficient
06:49:50 <shapr> if you need serious speed, you can write all the high level stuff in Haskell and wrap a few tuned C functions 
06:49:55 <Brandon> if we have two have 2 systems handle it now, that might be 10 servers otherwise..
06:50:05 <shapr> you can wrap them so that they appear to be normal Haskell functions, but are really speedy.
06:50:07 <Brandon> and hearing about some of these sites that have hundreds of machines.. or google that has 10,000 machines..
06:50:23 <Brandon> I see
06:51:08 <shapr> one of the (mostly unrealized) dreams of purely functional programming is the non-strict evaluation order allowing transparent parallelization
06:51:11 <Brandon> I'm very unfamiliar with haskell, aside from gazing at a haskell tutorial a few months ago
06:51:18 <shapr> would you like a quick demo?
06:51:33 <Brandon> evaluation of what?
06:51:35 <SyntaxNinja> Brandon: it should be very interesting to you, from your background.
06:52:02 <Brandon> one of the things I think would be useful to me (and it may not apply here, but I am just letting you know), is a lot of intelligence put into the compile-time
06:52:18 <Brandon> that is, optimizing it in advance so it is very efficient when it reaches the machine language point
06:52:34 <Brandon> I am used to a procedural language (that's what C is, right?  :)
06:52:38 <shapr> yes, that's C
06:52:55 <shapr> Haskell is (in general) not procedural.
06:53:06 <SyntaxNinja> or "Imperative"
06:53:11 <shapr> anyway, look at this handy demo: http://www.scannedinavian.org/AvianWiki/HaskellDemo
06:53:16 <Brandon> thanks
06:53:26 <SyntaxNinja> Brandon: GHC does a lot of optimizations.
06:53:33 <shapr> that demo is short and to the point
06:53:40 <SyntaxNinja> Brandon: one of the GHC authors hangs out on here, but he's been on vacation.
06:54:36 <earthy> there was once a very good Concurrent Clean that was real good at parallelizing stuff
06:55:26 <blackdog> shapr: it's a bit weird that there isn't an up-to-data parallel ghc. half the talks at IFL were on parallelising FPLs...
06:55:36 <blackdog> s/data/date/
06:55:36 <shapr> blackdog: yah, I agree. I want it.
06:55:50 <blackdog> i was hoping to use it for ICFP...
06:55:52 <shapr> imho, grid computing will be quite popular
06:56:26 <blackdog> Yeah. I don't have access to a supercomputer, but there are ~1000 unused lab machines each night at work... :)
06:56:39 <shapr> my wild prediction is that Moore's law will continue in a modified form, that CPUs may not gain more power, but instead drop in price and size. So I think SMP (actually NUMA) will become very common.
06:56:46 <blackdog> pentium 4s running nothing but xdm. Criminal.
06:56:57 <Brandon> You can see I like to talk a lot.. I'm reading right now, and reviewing the pages (demo and seeing what ghc was).. no need to explain, I have the site up
06:57:12 <shapr> Brandon: feel free to ask questions, I like to talk too :-)
06:57:32 <blackdog> quoting sean: "a little shae goes a long way"
06:57:37 * shapr laughs
06:57:46 <blackdog> did you catch up with peteg?
06:57:48 <shapr> blackdog: you should ask the EuroHaskellers what they think of that.
06:58:00 <Brandon> what was that about parallel evaluation?
06:58:06 <blackdog> YEah, how did that turn out, anyway?
06:58:08 <shapr> he was there for a bit, but I was in the midst of a tutorial of some flavor, so he had to bail.
06:58:21 <shapr> I only got to shake his hand and say "hi Pete".
06:59:02 <blackdog> Brandon: the idea is that you can evaluate a haskell program in any order. this makes it easier to split up programs and send them off to different processors... </oversimplifying>
06:59:47 <blackdog> it's hard to do with a C program, because there isn't a static guarantee that a function won't change the state of the world.
07:00:10 <shapr> every language has some strict and some non-strict semantics (ex: if doesn't execute both branches), Haskell is just a lot less strict.
07:00:23 <Brandon> I like that GHC has the variable nature in its compiling.. although now that I'm typing it.. now that I'm expressing it.. I realize optimization is the proper word to use, and thus I realize it's common and I am used to that being true.
07:00:29 <Brandon> so.. that's good :)
07:00:48 <Brandon> I don't recall ever pre-compiling perl so I don't recall the optimization capabilities :)
07:01:34 <Brandon> so how does haskell handle that?
07:01:45 <blackdog> handle what?
07:02:05 <Brandon> something like .. modification of variables which are used by multiple functions
07:02:14 <Brandon> or any other conflicts in parallel execution
07:02:32 <shapr> Haskell doesn't have variables :-)
07:02:34 <shapr> nor does it have loops
07:02:39 <blackdog> ah. can't do it, unless you're being bad.
07:02:50 <Brandon> My language for this would be closer to thread vocabulary/experience, btw.  ... So you know how to communicate with me
07:02:51 <shapr> but you do get shadowing, which ends up working the same way
07:03:05 <Brandon> no variables?
07:03:07 <Brandon> hmm
07:03:12 <blackdog> you do have mutable references, but you can't use them in an unconstrained way.
07:03:14 <shapr> single-assignment constants, and shadowing
07:03:33 <shapr> which sort of works like variables, and gives you a lot of other benefits
07:03:46 <Brandon> Have you not turned thy vision to thy Lord?
07:03:57 <Brandon> See how he doth prolongue the shadow?
07:04:20 <blackdog> our religion is confined to text editors. :)
07:04:30 <shapr> The lord is my sheperd, yay though I walk through the valley of mutability, I will fear no side-effects :-P
07:04:32 <Brandon> which is your preference?
07:04:43 <blackdog> ooh, i'm not getting into that again.
07:04:47 <SyntaxNinja> we all like emacs here.
07:04:56 <SyntaxNinja> anyone here who doesn't like emacs isn't really one of "Us".
07:05:23 * blackdog trudges off, sad and bewildered, clutching his unloved copy of vim close to his chest
07:05:26 * shapr looks pointedly at lambdabot 
07:05:29 <Brandon> <-- vim
07:05:33 <shapr> lambdabot doesn't like emacs.
07:05:37 <shapr> lambdabot: BAD bot!
07:05:37 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
07:06:39 <Brandon> I wouldn't mind emacs, probably.  But I prefer not moving my hands much.. I code very rapidly and use it for my normal text editing as well (letters, etc.)  However, emacs is capable of handling your personal wants and comforts, and can even, afaik, handle being modified to provide whatever conveniences one wishes of other editors
07:06:53 <blackdog> oh no...
07:06:58 <shapr> imho, vim increases hand moving, I don't like modes
07:06:59 * blackdog battens down hatches
07:07:07 <shapr> but hey, use what you like.
07:07:10 <n3cro> hi, i have problems with a function... can I post here that function ?
07:07:14 <Brandon> nevertheless, because vim fits my needs, and vi is on every machine, basically, and it's very teeny, etc.  I've preferred to stick with it.  Nevertheless, to each his own.  Whatever works for you.  :)
07:07:19 <shapr> n3cro: use the paste page on the wiki
07:07:40 <shapr> yes, vi is easier if you swap machines a lot
07:07:47 <Brandon> no.. vi has some irritating problems too.. :set ic   is lame.. just to turn on case insensitivity?  (ic == ignore case)
07:07:51 <shapr> I sit in front of the same keyboard all day long, so my .emacs is 1400 lines
07:07:58 <ikegami> or use viper-mode on emacs :)
07:08:07 <Brandon> so, again, one resorts to the capabilities of mapping keys, etc. in order to get what you want
07:08:27 <Brandon> You get a house, and you customize it according to your needs
07:08:32 <Brandon> one person might modify it more than another
07:08:36 <Brandon> so it is natural to do
07:08:43 * shapr modifies *everything*
07:08:48 <Brandon> it makes sense to start with one which suits your needs as much as possible
07:08:56 <blackdog> This may be a heretical opinion, but i tend to think that if you've got a powerful language, the abilities of your editor aren't as important.
07:09:13 <shapr> blackdog: only if your editor is scripted in that language :-P
07:09:18 <shapr> imho
07:09:19 <n3cro> what is wiki ?
07:09:22 <Brandon> sometimes that must go, a bit, and you must make due with what is available.. this might mean being a bit less comfortable.. it might mean you needing to adapt yourself to fit.. or it might mean modifying it, or yourself
07:09:26 <shapr> n3cro: oh, wikis are cool!
07:09:40 <Brandon> and I don't mean cutting off an ear to fit in a motorcycle helmet that's too small
07:09:41 <shapr> n3cro: http://www.haskell.org/hawiki/HaskellIrcPastePage
07:09:44 <Brandon> because that's all you could afford
07:09:58 <shapr> n3cro: click on the edit link, and see how other people fit their code into the curly braces and the #!syntax haskell part
07:10:36 <SyntaxNinja> Brandon: nice image
07:10:50 <blackdog> very chopperesque...
07:10:56 <Brandon> Anyhow, I'm tired of fighting and arguing.  The main problem I have with people on this issue is that people limit themselves, and then spread their judgements in ignorance.
07:11:00 <shapr> I always thought a chopper was a chopped *motorcycle*
07:11:29 <Brandon> I prefer it for a few reasons, and it may not be justifiable because I've not acquainted myself with the other (emacs)
07:11:34 <Brandon> not to limit the issue to editors
07:11:54 <shapr> I prefer to learn a whole bunch of different languages/editors/etc and try to remember their good points so I know when to use them.
07:12:00 <Brandon> and for others, they may merely not value the speed of motion and editing that I value
07:12:06 <Brandon> because I type 95wpm or whatever
07:12:14 <blackdog> Sorry, Oz reference. Mark "Chopper" Read is a famous criminal and standover man in australia who cut his ear off to avoid being killed in prison. Very good performance by ... uh, that dude who played the Hulk and Hector in Troy
07:12:15 <Brandon> and we shouldn't overlook that people think differently.. 
07:12:20 <Brandon> how different do they think?
07:12:26 <shapr> do you also use the ion window manager for example?
07:12:26 <n3cro> thanks shapr
07:12:37 <Brandon> and therefore, because of that difference, their environment and function might be much different.. so disputes about these things are silly, imo.
07:12:55 <Brandon> but my way is better than yours, because I've kept in mind your needs as well
07:12:58 <Brandon> ;)
07:13:22 <Brandon> that's a wink, although my font barely shows it
07:13:39 <blackdog> that's not a problem unless we're watching over your shoulder.
07:13:45 * shapr looks over blackdog's shoulder
07:13:46 <blackdog> Which we might be. don't look around...
07:13:49 <shapr> aha! look at that!
07:13:53 <blackdog> ah! don't do that!
07:13:58 <shapr> whoops
07:14:08 * shapr DCCs himself back to his desktop
07:14:24 <blackdog> distributed c compiler?
07:14:37 <Brandon> I code lots of utilities in perl
07:14:44 <shapr> nah, DCC is the standard way to transfer files on IRC. But sendfile/SAFT is better.
07:14:44 <Brandon> so you know I'm not a C fanatic
07:14:47 <Brandon> everything has a place
07:14:58 <Brandon> so I want to read this demo to see how haskell fits
07:15:16 <blackdog> Oh, Haskell's the One True Language. Everything else is just working its way up. :)
07:15:19 <Brandon> what's an anonymous function with a name?
07:15:24 <blackdog> confused?
07:15:29 <shapr> in Haskell, a function does not require a name
07:15:48 <Brandon> but what's the difference between an anonymous one with a name and a normal one with a name?
07:15:58 <shapr> nothing?
07:16:08 <Brandon> that is.. what's the (\ ... ) do to it?
07:16:12 <neologism> isnt something without name "anonymous" ?
07:16:30 <shapr> neologism: sure, but it doesn't pay to be overly picky when people are just learning
07:16:33 <blackdog> f = (\x y z -> x+y+z)
07:16:35 <Brandon> yeah.. but here they explicitly say they make an anonmymous one with a name
07:16:35 <blackdog> and
07:16:45 <neologism> shapr: :)
07:16:46 <shapr> Brandon: I wrote it, so complain to me if you find any problems
07:16:50 <blackdog> f x y z = x+y+z
07:16:51 <neologism> I am learning too
07:16:51 <Brandon> ahh, gotcha
07:16:54 <blackdog> are identical
07:17:07 <blackdog> just different ways of expressing the same idea
07:17:29 <shapr> yah, blackdog said it
07:17:43 <Brandon> what's the reason for having the same -> arrow syntax separating a return value type and the argument, and the multiple arguments (also being separated by ->)
07:17:54 <neologism> btw: wouldnt it be cool to have some "quick-into" url in topic?
07:18:09 <neologism> Brandon: currying?
07:18:12 <Brandon> what's the reasoning for that?  I kinda understand Int -> Int.. it makes sense.. btw, is the right or the left Int the return value?
07:18:15 <shapr> neologism: there is one!
07:18:36 <neologism> shapr: oh, I dont see after 80-chars wrap :)
07:18:39 <blackdog> the right one
07:18:40 <Brandon> I would think the right one is the return value, based on the direction of the arrow.. you send it in and the arrow points to what follows.. the return value follows
07:18:41 <shapr> ah, too bad
07:18:41 <neologism> mea culpa
07:18:46 <Igloo> Int -> Bool is the function that takes an Int and gives you a Bool
07:18:49 <shapr> neologism: I'll move the to the front then
07:18:53 <Brandon> ahh. I see
07:18:59 <neologism> shapr: thats not necessary
07:19:07 <Brandon> then -> -> also makes sense.  Thank you, Igloo
07:19:13 <neologism> as nearly noone uses text-based irc clients
07:19:15 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Donate your brain! - hawiki/UsingHaskellWikiMaterial","related channels #haskell.se #haskelld #darcs","http://www.haskell.org/hawiki/EuroHaskell","May 2004 HC&AR: http://www.haskell.org/communities/","http://www.haskell.org/libraryInfrastructure/"]' by shapr
07:19:18 <Igloo> The other thing you need to know is that Int -> Bool -> Char means Int -> (Bool -> Char)
07:19:22 <shapr> neologism: sure they do
07:19:31 <Igloo> So if f has that type then f 5 has type Bool -> Char
07:19:37 <blackdog> what would a non-text irc client be?
07:19:51 <neologism> blackdog: I mean classical PC text mode (80x25)
07:19:58 <Brandon> okay.. that hasn't sunk in yet.. give me a sec
07:20:12 <blackdog> Oh, right. I was picturing strange and beautiful spider languages. :)
07:20:36 <neologism> Brandon: each function of N args can be applied to x (x<=N) args givinh (N-x)-ary function
07:20:47 * shapr tries to parse that
07:20:52 <shapr> oh, I get it!
07:21:01 <neologism> in a case of N=x its the result itself :)
07:21:42 <Brandon> did I mention I've been coding since age 11 or 12?
07:21:46 <shapr> oh me too!
07:21:49 * shapr bounces happily
07:21:49 <Brandon> *maybe* 10
07:22:01 <Brandon> but it was basic, then C, then ASM
07:22:23 <neologism> Brandon: I see deep difference between "coding" and "programming"
07:22:26 <shapr> programming is a world of infinite niftiness
07:22:33 <Brandon> so I didn't get to experience the contemporary programming theory of "(N-x)-ary function"
07:22:38 * earthy was 9 when he first started. Basic, Pascal, ASM, C, Clean, C, Python, C, Haskell
07:22:43 <shapr> Brandon: that's ok, most people haven't
07:22:51 <neologism> you can be able to code "hello world" in zilion of languagfes but still not be programmer
07:22:54 <Brandon> so I have to try to use my math and physics experience to figure out what you're talking about, and it doesn't work so well
07:22:59 <shapr> in lambda calculus, *all* functions take one argument, that's the only way they work
07:23:05 <blackdog> just means "a function that takes (N-x) arguments"
07:23:17 <earthy> shapr: depends on the version of the lambdacalculus
07:23:22 <shapr> earthy: ok ok, fair enough
07:23:31 <earthy> but yeah, mostly true. ;)
07:23:47 <shapr> in this case, Haskell works that way, all functions really take one argument, not multiples
07:23:51 <earthy> brandon: don't. think of it in terms of higher order functions or, if you want, function pointers
07:23:57 <neologism> isnt it syntatic sugar (Lx.Ly.body = Lx y.body)
07:23:59 <neologism> ?
07:24:11 <shapr> sure, that's close enough
07:24:16 <earthy> neologism: in most versions of the lambdacalculus, yes.
07:24:24 <shapr> Brandon: have you worked with languages where a function can generate and return a new function?
07:24:37 <Brandon> no.. no self-modifying code
07:24:41 <Brandon> if that's what you mean
07:24:48 <earthy> not quite.
07:25:07 <Brandon> dynamic?
07:25:09 <blackdog> the effect is the same, but it's not quite as dangerous or mind-bending
07:25:12 <earthy> brandon, do you know the qsort(2) functions?
07:25:14 <Brandon> nothing so dynamic.. 
07:25:16 <shapr> well, think of the add function as something that takes *one* argument, and returns a new function that then can take another argument
07:25:17 <Brandon> yes
07:25:21 <Brandon> to the qsort
07:25:24 <neologism> earthy: I mean - it can be understand as sntactic sugar
07:25:34 <Brandon> I've used it (them?) periodically
07:25:46 <earthy> you give them a function pointer.
07:26:08 <Brandon> oh.. and my scriptlanguage.. its variables are replacable (for web cgi)
07:26:29 <Brandon> and it has a variable type which is really a string.. and it can be a string which is more of the script+html so it'll be automatically evaluated
07:26:37 <neologism> Brandon: f = add 1 so f 2 = 3
07:26:38 <earthy> so, the type signature for C's qsort, expressed as a Haskell type would be something like   qsort :: VoidPtr -> Int -> Int -> (VoidPtr -> VoidPtr -> Int) -> Void
07:27:28 <earthy> the thing between brackets is the compare function pointer that you hand to qsort
07:28:11 <Brandon> to your html/script you call the variable just like any other var.. which are called just like functions.. and just like a string, which would just be displayed.. but when it's the type vstr (for vhtml), it'll evaluate it.. in that way I have built some little runnable things, and I guess that's a distant step away from creating your own routines and returning them
07:28:15 <earthy> now, this is syntactic sugar for   qsort :: (VoidPtr -> (Int -> (Int -> ((VoidPtr -> VoidPtr -> Int) -> Void))))
07:28:55 <earthy> so, conceptually, qsort takes 1 argument, and returns a functionpointer
07:29:05 <blackdog> Brandon: the problem with that approach is that you can get evaluation errors at runtime pretty easily. This approach has better static guarantees.
07:29:07 <Brandon> okay.. so this is type definition syntax
07:29:07 <earthy> etc.
07:29:11 <earthy> yes.
07:29:49 <neologism> Brandon: try to read something about lambda calculus
07:30:00 <earthy> neologism: no need.
07:30:11 <earthy> he knows about functions, he knows about function pointers.
07:30:11 <Brandon> yes.. the code must be very clean, and my html+script parser is not lenient... it follows strict syntax
07:30:31 <neologism> earthy: surely no need... but its exciting and usefull
07:30:31 * chucky thinks it would be nice with standard functions for getting elements of three-tuples, ie fst3, snd3 and trd3
07:30:45 <Brandon> my template language stores function pointers and handles their parameters too
07:30:47 <shapr> chucky: Template Haskell can generate them  :-)
07:31:02 * earthy found \-calculus boring at first
07:31:21 <Brandon> must assign a void * to a function pointer as well.. in order to adapt the pointer reference into something C doesn't mind
07:31:23 <chucky> shapr: Nice idea actually
07:31:23 <Brandon> in any case
07:31:25 <SyntaxNinja> yeah, it's a mistake to make people think they need to grok lambda calculus in order to understand haskell.
07:31:27 <earthy> brandon: well, that's most that is to it.
07:31:56 <earthy> but in Haskell the type system is strong enough that you can dispense with void*
07:32:03 <Brandon> now.. I thought the rturn was at the right side?
07:32:08 <earthy> (almost completely)
07:32:12 <earthy> brandon: it is.
07:32:15 <Brandon> qsort :: (VoidPtr -> (Int -> (Int -> ((VoidPtr -> VoidPtr -> Int) -> Void))))
07:32:35 <earthy> qsort takes 1 argument and returns a pointer to a function
07:32:45 <Brandon> ohh, I see
07:32:48 <earthy> which takes 1 argument (of type Int) and returns a pointer to a function
07:33:00 <earthy> (etc, until the final function returns Void)
07:33:26 <Brandon> I thought qsort sorted a bunch of stuff.. one of its arguments being a function (pointer) 
07:33:37 * Brandon raises an eyebrow questioningly
07:33:47 <earthy> well, in C, yes.
07:34:12 <earthy> but if you would encode it in Haskell you get partial application for free
07:34:23 <Brandon> ahh.. what's the function do?  that is, the function which qsort returns, what's it do?
07:34:25 <neologism> Brandon: think of "plus" funciton and "inc" as inc = plus 1
07:34:48 <neologism> so (plus 1) is partially application of 1 argument to binary function plus
07:34:52 <neologism> giving unary function inc
07:35:00 <earthy> it is a function that takes the number of members, the size, and the comparison function and returns void (conceptually), sorting the block of memory that was given to qsort
07:35:09 <Brandon> neologism, cranberry is good for that
07:35:25 <Brandon> your "unary tract infection" as you call it
07:36:01 <neologism> Brandon: I am afraid I dont understand you
07:36:15 <Brandon> doctors differ on the way it works, but it's believed to function by either preventing the adherence of the bacteria to the bladder wall, or possibly binding to the bacteria's cell membrane or otherwise preventing their reproduction
07:36:20 <shapr> programmer humor :-)
07:36:49 <shapr> I thought it was just by changing the pH of the urinary tract?
07:36:53 <Brandon> we're mostly men here, so it's less common for it to be useful for us directly, but if you stretch that directly..
07:37:01 <earthy> *ouch*
07:37:02 <Brandon> shapr, that's possible too.. 
07:37:11 <shapr> actually, there are more females here than you might expect
07:37:15 <shapr> in any case
07:37:29 <shapr> if most means more than fifty percent, I suspect you are correct.
07:37:37 <neologism> did I say something or what?
07:37:50 <shapr> unary function inc
07:37:52 <Brandon> just a general tendency of programming.. no bigotry involved
07:38:07 <neologism> shapr: I am afraid I dont see the humour in it?
07:38:11 <neologism> can you explain?
07:38:21 <shapr> it's pun on unary being smudged to urinary
07:38:22 <Brandon> It makes sense, however
07:38:24 <neologism> unary = 1 argument?
07:38:29 <neologism> ah...
07:38:39 <Brandon> as society moved into industry, and then industry moved into technology
07:38:52 <shapr> too bad they haven't figured out what to do with that tech yet.
07:38:53 <neologism> Brandon: anyway - my example is correct :)
07:39:02 <Brandon> it carried along the "physical strength/stamina" tendencies of industry too
07:39:16 <blackdog> Brandon: historically, an awful lot of the early programmers were women.
07:39:24 <shapr> I think it's more likely that women tend to have social skills.
07:39:25 <Brandon> oh.. and women staying home to be housewives wasn't that far away in our recent history
07:39:45 <Brandon> nowadays it's almost the opposite, and that's bad too
07:39:50 <Brandon> people should be careful of extremes
07:39:58 <shapr> I went to EuroPython 2004 last week, there were six females and ~270 males.
07:40:01 <Brandon> and men should be more nurturing, imho :)
07:40:03 <earthy> `she must sicken worse ere she mends'
07:40:22 <blackdog> well, with a name like "python" ... :)
07:40:26 <Brandon> glass-blowing is also male dominated
07:40:36 <shapr> women don't like to suck molten glass into their lungs?
07:40:40 <Brandon> except in one place of the world, it seems, which happened to be the lab where I blew glass
07:40:55 <Brandon> then it was majority female
07:41:13 <shapr> in any case, urinary functions are quite pleasing at times.
07:41:17 <Brandon> shapr.. blowing, it is.. 
07:41:20 <neologism> what is (to) "blow glas"?
07:41:33 <shapr> neologism: to turn melted sand into things you can drink out of
07:41:35 <Brandon> although there are some techniques used where one does suck
07:41:49 <blackdog> don't worry, brandon, you'll get better. 
07:41:50 * shapr smacks Brandon with 20mg of methylphenidate
07:41:58 <neologism> so I have to admit I dont understand you boys
07:42:10 <Brandon> like, if you make a big bubble of glass on the end of your metal rod, and you heat up just the very bottom of it in the glory hole
07:42:15 <shapr> neologism: you know windows are made of glass?
07:42:23 <Brandon> then you suck.. the bottom will become concave
07:42:31 <neologism> shapr: yes
07:42:45 <neologism> I just see my english is not upto to be able tounderstand you
07:42:53 <Brandon> the normal technique is to hold your piece above the thick metal table and set it down gently on it
07:43:04 <Brandon> that curves the bottom in, giving a nicely shaped concave bottom
07:43:06 <neologism> and by "understand" I mean "to know what you are talkin about"
07:43:13 <shapr> neologism: originally, glass bottles were made by putting a ball of melted glass on the end of a tube and blowing hard into the tube
07:43:18 <earthy> sick, sick, sick.
07:43:20 <Brandon> what's methylphenidate?  :)
07:43:20 <neologism> shapr: I know
07:43:34 <shapr> Brandon: I'm not sure if you're being sarcastic or not ;-)
07:43:40 <neologism> but I just dont understand why my "unary function inc" have in common with glass blowing
07:43:43 <Brandon> originally, glass bottles were made by taking a stick and wrapping it with mud and other stuff like aligator dung, etc.
07:43:47 <Brandon> then dipping that into molten glass
07:44:01 <shapr> but the alligator dung turned out to make nasty colors in the glass
07:44:02 <earthy> Methylphenidate is a mild CNS stimulant.
07:44:08 <Brandon> shapr, about the chemical?  no, I'm not being sarcastic :)
07:44:24 <blackdog> neologism: we've bounced past that topic now.
07:44:34 <earthy> Indications
07:44:35 <earthy> Attention-Deficit Hyperactivity Disorder (ADHD), previously known as Attention-Deficit Disorder.
07:44:58 <neologism> blackdog: I see
07:45:02 <SyntaxNinja> Oo
07:45:05 <SyntaxNinja> I look away for one minute...
07:45:12 <Brandon> so, glass blowing is, generally, to take a metal rod and dip it in a furnace/pool of molten glass, turn the rod to gather the glass evenly, and then blow a bubble
07:45:20 <earthy> otherwise also known as `Ritalin'
07:45:20 <Brandon> it obviously gets more indepth than that
07:45:38 <shapr> neologism: actually, Brandon said that urinary jokes were okay because we were mostly guys here, so I said there's a surprising number of women here, and Brandon mentioned his mostly female glass-blowing lab. that's how we got here.
07:45:48 <Brandon> the first gather should be shaped and chilled on the surface so you can blow it evenly and cleanly
07:45:56 <neologism> shapr: thnx for explanation
07:46:00 <neologism> I'have understood it
07:46:10 <neologism> I am just wondering wheter OI am dreaming or not :)
07:46:12 <Lunar^> shapr: Should I get the PhD comics image one moe time ?
07:46:42 <blackdog> shapr: seen the hs-plugins paper dons/chilli/andre/sean did? some pretty cool stuff...
07:46:54 <Brandon> the properties of glass.. its cooling speed, etc. are very neat.  Because of them, you can exhale at a certain rate which allows it to cool more in the thin areas, therefore it becomes less liquidy in those areas.. it's that property which allows it to be done at all, I figure.
07:47:09 <shapr> blackdog: sure yah, you knows dons is on here lately? I've been chatting with him.
07:47:21 <Brandon> I said the urinary joke was okay because, *while* we were mostly guys in here, we can indirectly advice women as well
07:47:24 <shapr> Brandon: ah, but I'm trying to indoctrinate you into the world of purely functional programming :-P
07:47:31 <Brandon> it is probably more useful for the women
07:47:35 <shapr> Brandon: fair enough, I admit to paraphrasing
07:47:37 <Brandon> while many doctors debate over it even working at all
07:47:43 <Brandon> and others study it
07:47:44 <blackdog> didn't know that. don's usually too focused for IRC. :)
07:47:45 <shapr> methylphenidate works just fine!
07:47:46 <Brandon> it works well
07:47:58 <Brandon> s/advice/advise/
07:47:59 <neologism> Brandon: see that functional programming is wide area :)
07:48:10 <blackdog> shapr: i want to use it for a haskell shell.
07:48:11 <Brandon> yes, let's return to the programming!  B)  
07:48:22 <shapr> blackdog: oh, good idea!
07:48:30 <shapr> Brandon: it's just that you remind me of me.
07:48:39 <neologism> Brandon: did you get the idea I presented with that "unary func. inc" example?
07:48:43 <Brandon> "Be like a mirror, cleansed and pure."
07:49:02 <shapr> "be like a rubber ball, never anywhere for very long"
07:49:14 <Brandon> neologism, good question, let me go back to read it
07:49:37 <neologism> inc = add 1; but you can apply that lonely (add 1)
07:49:42 <neologism> ie. inc 2 = 3
07:49:44 <Brandon> does mirc have nick coloring
07:49:48 <Brandon> sigh..
07:49:54 <shapr> heck if I know, I stopped using windows years ago.
07:49:55 <neologism> and (add 1) 2 = 3 too
07:50:15 <neologism> where (add 1) gives you inc funciton in fact
07:50:25 <blackdog> shapr: still trying to work out what features are desirable for a shell... currently, i'm thinking I'll need a better concrete syntax for regexes, some implicit imports of modules ... 
07:50:36 <shapr> blackdog: use HaRP!
07:50:57 <shapr> yah, Data.List, Data.Char, and a few others
07:51:09 <shapr> you'll also probably want to hack in some utf8 support in place of standard libs that won't handle it
07:51:11 <Brandon> so give me a simple routine to make.. so I can test my very basic understanding
07:51:22 <blackdog> hm, cheers. looking it up now.
07:51:28 <Brandon> granted, I should probably read through this demo first, so my vocab is expanded and so I understand many of the basics 
07:51:41 <neologism> Brandon: hugs carries a lot of GOOD examples
07:51:46 <neologism> you should take a look at them
07:51:49 <shapr> Brandon: read the demo, it'll help
07:52:04 <shapr> Brandon: even better, paste the demo into a file and load that file into hugs/ghc/etc
07:52:10 <shapr> then you can execute it interactively
07:52:15 <blackdog> Brandon: maybe play around in ghci/hugs for a bit. play with filter/map on literal lists...
07:52:25 <neologism> yes, thats nice
07:52:28 <shapr> @eval (\x -> x + 1) 1
07:52:28 <lambdabot> 2
07:52:37 <shapr> @eval map (\x -> x + 1) [1,2,3,4]
07:52:37 <lambdabot> [2, 3, 4, 5]
07:53:17 <shapr> @eval map (\x -> '.' : x ) ["foo","bar","baz","quux"]
07:53:17 <lambdabot> [.foo, .bar, .baz, .quux]
07:53:31 <neologism> Brandon: 
07:53:31 <neologism> y f = f (y f)
07:53:32 <neologism> primes = y (\f (x:l) -> [x] ++ f (filter ((/= 0).(`mod` x)) l)) [2..]
07:53:36 <neologism> isnt it nice? :)
07:53:56 <blackdog> shapr: might have to hack HaRP a bit to use it - it's done as a preprocessor, so interactive use might a bit fiddly.
07:54:07 <shapr> oh, good point
07:54:28 <blackdog> neologism: do you always show your y combinator to new haskellers? :)
07:54:42 <neologism> blackdog: always!
07:54:50 <shapr> Brandon: one basic idea of Haskell is that functions are values just like integers or strings. you can use a function like a hammer, where you smack a whole row of nails at the same time.
07:55:16 <blackdog> shapr: it'd be nice to have a regex library in TH
07:55:24 <shapr> interesting thought
07:55:32 <shapr> I agree
07:55:36 <shapr> want to write it? ;-)
07:56:02 <shapr> the haskell tasks I've set myself at the moment are all "Fix Broken Windows" stuff
07:56:03 <blackdog> shapr: i want to write lots of things. my supervisor wnats me to write one thing. after 2.5 years, i can't say i blame him.
07:56:33 <shapr> rip out the haskell-libs cvs tree, break the darcs repos into per-'product' pieces, put up another gforge instance that uses darcs
07:56:36 <blackdog> what sort of tasks?
07:56:42 <blackdog> oh, ok. cool.
07:56:43 <shapr> write up a Haskell 98+ standard
07:56:58 <shapr> create a website auto-index for haskell.org
07:57:14 <blackdog> Man, I'm glad someone's happy to take that sort of thing on. I'm terminally lazy about process stuff.
07:57:21 <shapr> oh so am I
07:57:32 <shapr> but if I don't do it, who else will?
07:58:06 <shapr> anyway, I've written about how great it is to do goal-reaching stuff on my blog, so I have to either apply these ideas or publically call myself a hypocrite :-)
07:58:14 * shapr tries embarassment-oriented programming
07:59:37 <shapr> oh, and I have to swap the wiki to a new license
07:59:47 <shapr> what's the best choice? creative commons?
08:02:21 <Brandon> okay
08:02:22 <Lunar^> Has anyone manage to build Ian's printf with GHC 6.2.1 ?
08:02:28 <Brandon> finished reading once
08:02:36 <shapr> Brandon: questions? thoughts?
08:03:04 <Igloo> What problem do you have, Lunar?
08:03:13 <SyntaxNinja> Lunar^: is this a TH example?
08:03:24 <Lunar^> SyntaxNinja: http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Printf/
08:03:32 <Igloo> Syn: Have you noticed the new darcs release BTW?
08:03:50 <shapr> yah, 0.9.21 isn't it?
08:03:59 <Lunar^> It yells because of function Lifting
08:05:21 <Brandon> Okay, I'm ready for that first command
08:05:38 <SyntaxNinja> Igloo: no. thanks.
08:05:43 <Brandon> tell me to do something in haskell.. as the first example for me? :)
08:05:44 <SyntaxNinja> is libcurl fixed yet
08:05:52 <Igloo> No idea
08:06:02 <SyntaxNinja> Lunar^: ahh
08:06:05 <Igloo> Oh, just on the off chance, does anyone here have an Arm?
08:06:12 <shapr> Brandon: write a function that adds a character to a string?
08:06:26 <Brandon> Igloo, yes, in more than one way
08:06:30 <neologism> Brandon: sum of list of numbers?
08:06:47 <neologism> (beside sum [1,2,3] :) )
08:06:51 <Igloo> Brandon: Running what OS?
08:07:42 <shapr> hm, my unicycle is calling my name.
08:08:05 <Brandon> Oh.. I have arms.. Also, ARM is an organization (Association for Research of Myopathies) .. www.hibm.org.. I know the doctors who began it..
08:08:13 <Brandon> and also, the Arm of Maktab
08:08:30 <Igloo> I see  :-)
08:08:30 <shapr> I suspect Igloo was asking about the Debian distribution and its ARM cpu support.
08:13:36 <Brandon> okay, add :: Int -> Int        add x y = x + y     sum :: [] -> Int      sum [x:xs] = add x sum xs
08:13:51 <Brandon> I figure it's not proper.. but will throw it out there for correction
08:14:06 <Lunar^> SyntaxNinja: any ideea ?
08:14:09 <shapr> it's pretty close
08:14:27 <Brandon> Igloo, no.. not sure about the platform..
08:14:48 <Brandon> I've also got "the arm", as I'm used to calling it, on a ring
08:14:54 <neologism> I'd say its correct (beside syntax)
08:14:58 <SyntaxNinja> Lunar^: I wsas goign to suggest that the TemplateHaskell page on the wiki has a version of the printf example that works for my version of GHC
08:14:59 <Brandon> which my wife and I consider our rings
08:15:07 <shapr> Brandon: I'd suggest pattern matching, so 'sum [] = 0' would be the first line, and 'sum (x:xs) = x + sum xs' would be the second line
08:15:22 <SyntaxNinja> but It kinda looks like Igloo's printf is probably more sophisticated than that example, but I don't have time to look at it ATM.
08:15:42 <neologism> Brandon: also: sum :: [Int] -> Int
08:15:44 <Brandon> oh.. I figured I'd need the pattern matching in case someone handed me just one argument (or less)
08:16:06 <neologism> Brandon: pattern matchin is usefull even in this case
08:16:11 <SyntaxNinja> Igloo: if and when ghc gets fixed on sparc, we'll have to re-upload packages that depend on it in order to get them to rebuild?
08:16:11 <Brandon> oh.. we have + :)
08:16:18 <neologism> Brandon: look at the examples provided with haskell
08:16:22 <neologism> its VERY usefull
08:16:26 * SamB wonders how you refute a tuple
08:17:29 <blackdog> blind him with logic.
08:17:40 <shapr> Brandon: ok, now, how do you rewrite your sum function with foldr ?
08:17:42 <shapr> @type foldr
08:17:46 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
08:18:04 <Igloo> Syn: They should get rebuilt if they aren't already built, but it can be easier to just reupload if you want it to happen
08:18:09 * Brandon frowns
08:18:16 <SyntaxNinja> Igloo: OK
08:18:39 <Brandon> what's the period . do?
08:18:50 <Igloo> (f . g) x = f (g x)
08:18:50 <SyntaxNinja> Igloo: I was sorta wondering whether it would be easiest to see if GHC gets fixed in the short term  before uploading a new darcs :)
08:18:52 <neologism> Brandon: f . g x = f (g x)
08:20:07 <Brandon> . seems powerful
08:20:34 <Igloo> I'd do it anyway as a do-nothing upload is simple enough
08:21:10 <neologism> Brandon: . was defined by mathematicians a long time ago
08:21:14 <Brandon> shapr, dear, what's forall?  :)
08:21:20 <Brandon> neologism, dot product?
08:21:34 <Igloo> Oh, if there's a forall before the . it doesn't mean that
08:21:36 <shapr> Brandon: you don't need to worry about forall at the moment
08:21:39 <Brandon> multiplication?  :)
08:21:41 <neologism> Brandon: I dont know the term in english but itsnot dot product
08:21:44 <blackdog> no, just overloaded notation. :)
08:21:45 <neologism> nor multiplication
08:21:48 <Igloo> forall a . a -> a   means the same as a -> a in Haskell 98
08:21:50 <neologism> its application of function on function
08:22:27 <shapr> Brandon: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#foldr
08:22:57 <Brandon> they have concentrated cranberry.. in powder form.. so you can pop the gelatin capsule instead of drinking the bitter glass
08:23:37 <Brandon> I do believe I should read the urls.. because this demo/intro is very good, but I'm missing a huge amount of fundamentals of haskell still
08:23:42 <shapr> I rather like drinking cranberry juice.
08:24:00 <blackdog> shapr: because it feels so good when you stop?
08:24:08 <Brandon> I like the intro, shapr.. it plops me right into it without having to bother with deep discussion
08:24:09 <SyntaxNinja> heh
08:24:17 <shapr> Brandon: good idea, I'll go unicycle so I'll be ready for questions when you're done reading.
08:24:21 <Brandon> gets the mind reeling without laborous (laborious?) redundant details
08:24:35 <Brandon> oh, you unicycle!?  :)
08:24:37 <shapr> laborious says emacs
08:24:38 <shapr> sure
08:24:50 <shapr> http://ridley.csbnet.se/gallery/eurohaskell/p1010015
08:24:51 <Brandon> I tried a unicycle many times when I was young
08:25:00 <Brandon> never got much further than two houses down
08:25:03 <shapr> that's from last week at EuroHaskell
08:25:21 <shapr> I think it was thursday.
08:25:24 <Brandon> that is, passing across the next-door neighbor's house
08:25:32 <shapr> you can see several denizens of this channel in that gallery.
08:25:41 <shapr> but I'm the slightly plump one on the unicycle.
08:27:01 <Brandon> woohoo!  :)
08:27:39 <Brandon> it's a great shot too :)
08:28:09 <shapr> yah, Andersca is a great photographer
08:28:32 <Brandon> although some of my least flattering, imo, pictures were taken of me with extreme expressions on my face
08:28:33 <shapr> there he is now :-)
08:28:58 <shapr> andersca: I was just saying you're a great photographer :-)
08:29:16 <shapr> oh, I should probably include irc nicknames in my gallery comments
08:29:58 <andersca> oh
08:30:03 <andersca> I'm probably not ;)
08:30:35 <shapr> Brandon: there are lots more fun pix in that gallery, bringert trying the unicycle, John Hughes trying the unicycle, Jeremy Bobbio showing off hOp, the Haskell Operating System
08:31:00 <neologism> haskellOS? sounds cool!
08:31:10 <shapr> it is!
08:31:31 <shapr> oh, and pix of andersca's cool signs
08:31:42 <vegai> is it useful yet?
08:31:53 <shapr> it makes a wonderful wall clock.
08:32:01 <shapr> date works quite well.
08:32:10 <neologism> hOS might be strong argument for people says "OSes are C/asm thing"
08:32:22 <shapr> it has drivers for CMOS, PS2 mouse, and keyboard
08:33:23 <shapr> I'm interested in a network card driver next.
08:33:50 <Brandon> I want a database that clusters data on disk based on frequency of access
08:33:56 <Brandon> or maybe I just wish I had that
08:34:58 <shapr> write it!
08:35:17 <Lunar^> neologism: It's hOp, and it actually uses a lot of C, in fact
08:35:34 <shapr> I hope it uses less C in the future.
08:35:39 <cbus> sanoteuh
08:35:42 <shapr> a nice Haskell assembler :-)
08:35:42 <cbus> ;)
08:35:48 <shapr> cbus: yay dvorak!
08:35:54 <shapr> aoeuhtsn
08:35:55 <cbus> shapr: yeah kinda
08:35:59 <shapr> svorak?
08:36:03 <cbus> shapr: yepp
08:36:10 <shapr> det √§r bra
08:36:20 <cbus> normal svorak and not any variation of sv-dvorak
08:36:36 <shapr> I'll stick with boring dvorak and emacs x-symbol
08:36:47 <cbus> i only use dvorak while coding
08:36:48 <cbus> :)
08:36:50 <cbus> and svorak otherwise
08:37:22 <shapr> ok
08:37:49 <Brandon> what do you think about Caml?
08:38:02 <cbus> hmm think ill go and get some food soon
08:38:03 <cbus> later
08:38:09 <Brandon> bye, cbus.. :)
08:38:23 <cbus> bye bye
08:38:35 <cbus> shapr: would be fun with a keyboard with the keys placed as in svorak ;)
08:39:16 <shapr> Brandon: OCaml is not purely functional, but it is fast.
08:39:48 <shapr> Brandon: in my opinion, Haskell is more expressive but slower than OCaml, so code takes less time to write, but longer to execute.
08:39:56 <shapr> since OCaml can be faster than C in some cases.
08:40:22 <shapr> I've heard that Haskell is about seven times slower than C, which is still leaps and bounds faster than Perl, Python, etc
08:40:41 <neologism> imho it depens on situation
08:40:45 <shapr> yup, I agree
08:41:01 <neologism> ie. head some_brutally_slow_function_returning_list
08:41:13 <shapr> my choice is to write 99% of the code in Haskell, and if profiling shows a need for speed, write a C function and wrap it.
08:41:23 <neologism> shit, bad example
08:41:27 <neologism> I am tired today
08:42:16 * shapr runs off to unicycle
08:42:23 <Brandon> enjoy!  thanks for the info
08:42:24 <Brandon> :)
08:42:33 <Brandon> and sharing et al
08:43:02 <Brandon> actually, some people share cruelty
08:46:54 <vegai> tell me about it 
08:52:30 <Brandon> Hi, vegai
08:54:02 <vegai> howdy =)
08:57:15 <Brandon> :)
08:57:28 <Brandon> what's "right~"?
08:59:31 <Brandon> can webpages map keys?
08:59:53 <Brandon> I'm tired of clicking and want to be able to map the link that moves forward to be one of my keys
09:01:35 <vegai> not without some heavy scripting, I'm afraid
09:04:52 <Brandon> don't be scared
09:37:32 <shaleh> good day all
09:50:29 * SamB wonders why he didn't see any mention of -fparr in any of the docs that came with GHC
09:50:51 <bringert> SyntaxNinja: I have two small patches for Cabal that allow XmlRpc to compile again
09:51:12 <bringert> the problem now is depdendency resolution
09:51:33 <bringert> that is, the -package flags are not added
09:53:25 <ludde> hi bringert
09:53:29 <bringert> hi
09:53:34 <ludde> how do we do with the time documents
10:02:18 <SyntaxNinja> bringert: cool.
10:02:31 <SyntaxNinja> bringert: can you also send me a patch w/ your xmlrpc example?
10:04:48 <bringert> do you want the whole xmlrpc library?
10:04:48 <SyntaxNinja> bringert: is it very big?
10:08:01 <bringert> SyntaxNinja: almost 3000 LOC
10:09:09 <bringert> about the same size as the current cabal code :)
10:10:12 <SyntaxNinja> bringert: that's fine by me... I'd like to throw that in the repo as an example or test case, for now at least. we may not distribute it or anything... I haven't looked, would the license allow this?
10:11:13 <bringert> sure, it's BSD licensed
10:11:26 <Igloo> Is there a debian/ for a cabalised library supporting multiple compilers anywhere yet?
10:11:40 <SyntaxNinja> no
10:11:42 <shaleh> I am trying to write a directory walker.  How does one test if a an item return from getDirectoryContents refers to a file or a directory?
10:12:03 <Igloo> There's an obviously named function in IO I think
10:12:31 <SyntaxNinja> shaleh: I wrote a little function to turn a directory structure into a tree, though it probably breaks on circular symlinks or something
10:12:46 <Igloo> Oh, no, Directory.doesDirectoryExist
10:12:56 <Igloo> And doesFileExist
10:13:03 <Igloo> I don't think you can ask about symlinks with H98
10:13:33 <shaleh> Igloo: hmm, those are not in the ghc6 documentation for the Haskell98 libs.
10:13:46 <Igloo> They're in http://www.haskell.org/onlinereport/directory.html
10:14:00 <Igloo> Are you sure you aren't looking at hierarchial libs documentation? Although they should be in there too
10:14:09 <shaleh> never mind, I misread your post
10:14:16 <shaleh> do/does
10:14:22 <Igloo> Ah
10:14:57 <shaleh> I did not think "doesDirectoryExist" would be the right name.  I was expecting more like isDirectory or something
10:15:14 <shaleh> I already know it exists, I just want to know what it is.
10:15:16 <Igloo> Oh, Syn, did I tell you your TH requests are in the CVS HEAD now, BTW?
10:15:28 <SyntaxNinja> Igloo: oh, cool.
10:15:44 * SamB reads a document on the subject of -fparr which he found both on the web and in his GHC source tree (which he hasn't even tried to compile)
10:17:08 <titanstar> if i want to make a vector and matrix types, should i make them instances of the Num type class?
10:17:52 <shaleh> is there no direct hook into something like C's stat() function?
10:17:55 <titanstar> the problem as i see it is the abs function, which is required to be (Num a) => a -> a
10:19:01 <SamB> shaleh: you can import it if you don't mind not being able to load it in GHCi (or maybe even if you do?)
10:19:26 <SamB> titanstar: you could make it call error
10:19:33 <Igloo> shaleh: There might be what you want in a POSIX library in the hierarchial libraries somewhere
10:19:44 <titanstar> SamB: true
10:19:46 <SyntaxNinja> shaleh: wrt the directory stuff, I wrote this:
10:19:48 <SyntaxNinja>       -- FIX: probably better not to use "error" here, but rather let exception occur.
10:19:48 <SyntaxNinja>       pathIsDirectory :: FilePath -> IO Bool
10:19:48 <SyntaxNinja>       pathIsDirectory p = do existsP <- doesFileExist p
10:19:48 <SyntaxNinja>                              existsP2 <- doesDirectoryExist p
10:19:48 <SyntaxNinja>                              when (not (existsP || existsP2))
10:19:48 <SyntaxNinja>                                       (error $ "File does not exist: " ++ show p)
10:19:49 <shaleh> Igloo: hmm, I will keep looking then. thanks.
10:19:50 <SyntaxNinja>                              status <- getFileStatus p
10:19:52 <SyntaxNinja>                              return $ isDirectory status
10:20:01 <titanstar> and i could make it return a vector of size 1
10:20:21 <SyntaxNinja> import System.Posix.Files(getFileStatus, isDirectory)
10:20:22 <titanstar> if the vector size is not a part of the type
10:20:56 <shaleh> SyntaxNinja: thanks for the example and the module pointer
10:21:18 <titanstar> which brings me to the next question, is there a way to make a vector type so the number of elements in the vector is part of the type?
10:22:00 <titanstar> as it would be neat to have type checking to make sure you only multiply 4-element vectors with 4x4 matrices and so forth
10:22:19 <titanstar> nx4 matrices, that is
10:22:23 <Smerdyakov> Now you're getting fancy.
10:22:36 <titanstar> :)
10:22:40 <SamB> titanstar: I called error in fromInteger and toInteger for my Galois Fields implementation, which I have yet to actually use for anything
10:22:50 <SyntaxNinja> shaleh: check out the paste page
10:22:56 <shaleh> SyntaxNinja: k
10:22:56 <SyntaxNinja> @wiki HaskellIrcPastePage
10:22:56 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:22:57 <SamB> or maybe not toInteger.
10:22:57 <titanstar> SamB: okay, i guess that works
10:23:13 <titanstar> Smerdyakov: hey, the c++ version of this code had type checking on vector length :)
10:23:36 <SyntaxNinja> shaleh: I dont really know how using Posix impacts portability.
10:23:49 <Smerdyakov> The C++ compiler can't prove that the operation won't cause a segfault!
10:24:02 <SamB> SyntaxNinja: maybe you should read the header of the module?
10:24:17 <titanstar> that's okay, i have gdb and valgrind for such occations :)
10:24:35 <Smerdyakov> titanstar, are you sure you belong in this channel? >:O
10:24:56 <titanstar> heheh
10:24:59 <SamB> Smerdyakov: apparantly C/C++ compilers don't worry too much about segfaults when doing proofs.
10:25:08 <shaleh> SyntaxNinja: I only care about portability to Posix systems (-:
10:25:46 <titanstar> but okay, giving run-time errors on mismatched vector lengths could work, i guess
10:26:14 <SyntaxNinja> SamB: but I don't konw what systems are not posix.
10:26:27 * shapr hops cheerfully
10:26:36 <SamB> SyntaxNinja: well, generally *nixes are close enough
10:26:42 <Igloo> Hmm, I need a todo manager that can show things as a dag
10:26:45 <SyntaxNinja> what about windows / cygwin?
10:26:55 <SamB> SyntaxNinja: that probably sorta-works
10:27:04 <SamB> I mean, doesn't darcs use posix?
10:27:07 <SyntaxNinja> SamB: I see...
10:27:23 <SamB> I mean, cygwin only sorta works in the first place.
10:27:43 <SyntaxNinja> heh.  well if anyone really knows what systems support posix to what extent, that would be a nice thing to add to the module documentation :)
10:28:08 <SyntaxNinja> Igloo: I want that too.
10:28:52 <shaleh> SyntaxNinja: onless you are playing with symlinks, simple uses of the Posix stat() function should work on damn near any OS.
10:29:07 * Igloo is weighing up whether I would be writing a quick TODO viewer or spending hours trying to get lines and nodes to go in sensible places
10:29:22 <Igloo> I guess nodes could be draggable, but there's still the lines issue
10:29:46 <Igloo> And draggability would mean a GUI rather than just generating output...
10:31:17 * Igloo wishes someone had packaged a Haskell GUI library for Debian nicely
10:31:42 <shaleh> Igloo: are there such things to package?
10:32:15 <Igloo> One of wxhaskell, gtk+hs and gtk2hs would probably do
10:33:03 <Igloo> Last I look wxhaskell had some canvas drawing issues and I didn't like the OpenGL dependency, so the GTK ones would probably be better
10:33:10 <shaleh> Igloo: hmm, /me will have to look at how hard it is to package haskell stuff for Debian.  having buddha and the like packaged would also be nice.
10:33:48 <Igloo> buddah isn't very interesting for me until it supports things like Control.Monad.State
10:34:48 <shaleh> Igloo: do you have a super sekrit Debian decoder ring?
10:35:12 <Igloo> Err, I'm a Debian developer if that's what you mean?
10:35:22 <shaleh> Igloo: yes (-:
10:35:57 <shaleh> Igloo: as am I, although I have been a little on the quiet side this last year
10:36:37 <Igloo> Oh, cool - new troops in the Debian/Haskell packaging effort are always welcome  :-)
10:37:37 <SyntaxNinja> we need a mailing list :)
10:37:38 <shaleh> Igloo: I have tried functional programming twice already.  Once with lisp/scheme (ick) and once with (o)caml, again ick.
10:37:54 <shaleh> haskell hasn't made me puke yet.
10:37:56 <shaleh> (-:
10:38:10 <shaleh> although I am still not to the point I can easily code in it.
10:38:14 <Igloo> I was thinking of putting my Debian TODO list on the web somewhere, which is another reason a GUI wouldn't be as nice
10:38:28 <Igloo> shaleh  :-)
10:38:31 <shaleh> Igloo: people.debian.org is a good place to start.
10:38:33 <SyntaxNinja> Igloo: I want a connect-all-my-todo-lists program
10:38:44 <SyntaxNinja> that includes bug reports (at work and otherwise) appointments, etc.
10:38:48 <Igloo> The problem is generating it, not finding somewhere to host it  :-)
10:38:59 <SyntaxNinja> because an appointment also has an implicit todo "think about the appointment beforehand)
10:39:02 <SyntaxNinja> er
10:39:04 <shaleh> Igloo: post one item, "make a todo list" (-:
10:39:05 <SyntaxNinja> ")()"
10:39:11 <Igloo> :-)
10:39:19 <shaleh> I find starting the lists are the hard part.  once they exist they tend to fill up nicely.
10:40:27 <Igloo> I have a list of things to do, but they depend on each other, hence I want a DAG representation. Probably with colours or thicknesses or something to make importance and ease obvious, plus an obvious indicator of whether I'm waiting for someone else to do something or whether something is doable immediately
10:40:44 <SyntaxNinja> shaleh: FWIW, a big part of Cabal, in my mind, is to make packaging for Debian easier.
10:41:05 <Igloo> They're actually probably a tree, but if I was going to write something I'd want it to support DAGs anyway I think
10:41:51 <SyntaxNinja> Igloo: but you can easily have two high-level todos that are fulfilled by a single lower-level todo
10:42:44 <Igloo> Sure, I mean the current Debian TODO items probably form a tree
10:47:14 * Igloo disappears
10:49:25 <shaleh> is there a way to drop the IO from IO Bool or whatever?
10:49:39 <bringert> no
10:49:46 <bringert> well, there is
10:49:54 <bringert> but you don't wnat that :)
10:49:56 <SyntaxNinja> http://www.haskell.org/hawiki/ThatAnnoyingIoType
10:50:29 <shaleh> SyntaxNinja: thanks again (-: I knew this had to be a FAQ, it is just hard to search for.
10:51:27 <SyntaxNinja> shaleh: np
10:51:52 <SyntaxNinja> shaleh: that page could use some reorganization
10:54:28 <bringert> SyntaxNinja: I'm thinking of implementing listing installed packages for ghc in order to allow configure to figure out the dependencies
10:55:15 <bringert> any thoughts on where that code should go?
10:56:33 <shaleh> SyntaxNinja: yeah, a LOT of reorg.
10:56:50 <bringert> guess we need special magic for packages without versions in the name
10:57:09 <bringert> i.e. all the already installed packages
10:58:22 <TheHunter> Does anybody know whether the function type (a->b) can be defined by a universal property?
10:58:24 <SyntaxNinja> bringert: hm.... we were going to wait on the dependency stuff until all the compilers implement compiler-pkg 
10:58:56 <SyntaxNinja> bringert: which shouldn't be too bad, since I have a partial implementation, and since the compiler authors have all agreed to a standard interface for it.
10:59:23 <cbus> damn
10:59:30 <cbus> to bad you cant use $ the same way in c++ as in haskell .)
10:59:52 * SyntaxNinja hands cbus some parens
11:00:13 <cbus> but theni have to press home and end ;)
11:00:23 <bringert> SyntaxNinja: ok
11:00:24 <cbus> using shift 9 and shift 0 is hard ;)
11:00:31 * bringert runs away
11:01:39 <SyntaxNinja> bringert: don't let me discourage you, though :) :)
11:01:55 <SyntaxNinja> cbus: I know. it sucks, man.
11:02:09 <SyntaxNinja> cbus: maybe you could make your editor do it somehow.
11:03:04 <cbus> yeah could write some macro ;)
11:04:03 <shaleh> oh cry me a river
11:14:01 * bringert comes back
11:15:16 <SyntaxNinja> hi bringert!!
11:15:20 <bringert> SyntaxNinja: does your package listing code work with the current ghc?
11:15:27 * bringert was at the store
11:15:38 <SyntaxNinja> what package listing code?
11:15:48 <andersca> what did you store?
11:15:57 <bringert> andersca: :)
11:16:08 <SyntaxNinja> bringert: if you mean the haskell-pkg prototype, no... ghc doesn't read that package datafile.
11:16:15 <bringert> ah, ok
11:16:52 <bringert> andersca: type Store a = State [Food] a
11:17:36 <andersca> more like
11:17:46 <andersca> type Store a = State [Either Food Beer] a
11:18:53 <bringert> my fridge is pretty much State [Beer] a at this point
11:19:00 <andersca> not a bad thing
11:19:37 <SyntaxNinja> it is if you have to resort to unsafe IO to get it out...
11:23:05 <bringert> SyntaxNinja: like this: http://ridley.csbnet.se/gallery/eurohaskell/p1010060 ?
11:24:55 <andersca> hahaha
11:49:41 * SyntaxNinja hardware is evil &
11:55:57 * shapr pulls the latest library-infrastructure
11:57:27 <shapr> eek, darcs just got flippy
11:59:01 * shapr grumbles
11:59:11 * shapr deletes the dir and repulls
12:07:07 <shaleh> what is wrong with this code??
12:07:09 <shaleh> dirWalker   :: String -> IO ()
12:07:09 <shaleh> dirWalker s = do foo <- isDirectory (getFileStatus s)
12:07:09 <shaleh>                  if foo
12:07:09 <shaleh>                     then putStr $ "D: " ++ s
12:07:09 <shaleh>                     else putStr $ "F: " ++ s
12:07:21 * stepcut ponders
12:07:39 <stepcut> @type getFileStatus
12:07:40 <lambdabot> bzzt
12:07:44 <andersca> doesn't getFileStatus return IO something
12:07:45 <stepcut> !!
12:08:00 <shaleh> andersca: yes, hence the <-
12:08:12 <andersca> shaleh: what about isDirectory?
12:08:19 <shaleh> andersca: same
12:08:31 <andersca> you need to do
12:08:38 <andersca> status <- getFileStatus s
12:08:40 <shaleh> getFileStatus is IO Filestatus, isDirectory is IO bool
12:08:45 <andersca> foo <- isDirectory status
12:09:00 <andersca> or 
12:09:15 <andersca> status <- getFileStatus s >>= isDirectory
12:10:38 <shaleh>     Couldn't match `IO t' against `Bool'
12:10:38 <shaleh>         Expected type: IO t
12:10:38 <shaleh>         Inferred type: Bool
12:10:38 <shaleh>     In the application `isDirectory status'
12:10:38 <shaleh>     In a 'do' expression: b <- isDirectory status
12:10:49 <shaleh> when I tried the dual arrow approach
12:11:11 <andersca> are you sure isDirectory returns IO Bool?
12:11:58 <shaleh> andersca: I was sure, but then I read the docs again (-:
12:13:49 <shaleh> hmm, ghc just gave a bunch of linking errors, basically it can't find System.Posix.Files's C functions.  Do I need some command line option?
12:13:57 <andersca> -package posix
12:13:58 <andersca> I think
12:14:18 <shaleh> seems to have worked
12:17:57 <shapr> @index getFileStatus
12:17:57 <lambdabot> System.Posix,System.Posix.Files
12:18:17 <shaleh> @index sort
12:18:17 <lambdabot> Data.List,List
12:18:38 <shapr> I really gotta fix that code
12:19:07 <shaleh> shapr: what's wrong with it?
12:19:52 <shapr> it should only list the modules that export that function
12:20:06 <shapr> I think it lists too much right now
12:20:09 <shapr> @index foldM
12:20:10 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
12:20:10 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
12:20:10 <lambdabot> State,Control.Monad.Writer,Monad
12:20:13 <shapr> see what I mean?
12:20:19 <andersca> @index id
12:20:19 <lambdabot> GHC.Base,Prelude
12:21:24 <shapr> index uses the *.haddock.gz files that come with the debs to build a finitemap at startup
12:22:37 <shapr> hiya det
12:22:54 <det> hello :)
12:23:00 <shapr> wassup?
12:23:58 <det> nadda, just enjoying my days off
12:24:04 <det> You compete in ICFP?
12:24:11 <shaleh> well i guess I have been learning Haskell long enough to ask the most command FAQ of any language.
12:24:20 <shaleh> common
12:24:48 <shaleh> how do I do a case-insensitive string compare?
12:25:03 <shaleh> so SSS and sss match
12:25:09 <shapr> map toLower ?
12:25:14 <det> convery them both to lowercase first :)
12:25:36 <shaleh> ok, that works.  Just making sure I was not missing anything more obvious
12:26:36 <shaleh> hmm, lambdabot does not accept /msgs?
12:26:44 <shapr> he does
12:27:21 <shaleh> I tried /msg index and /msg help, he said he did not understand to both.
12:27:33 <shapr> you still gotta use the @index
12:27:52 <shapr> that's another good feature request, wanna fix it so that lambdabot doesn't require the at sign in privmsgs?
12:28:19 <shaleh> shapr: sure, I can handle that I think.
12:29:07 <shaleh> hmm, he doesn't know @help either
12:29:20 <shaleh> bots typically have a help so you know what commands they accept
12:30:07 <shapr> he should say "try @listcommands"
12:30:13 <shapr> a @help would also be good
12:30:30 <shaleh> is lambdabot in a darcs repo?
12:31:02 <shaleh> is there no stringToLower? do I really have to map toLower over each string?
12:32:06 <stepcut> shaleh: I believe so...
12:32:26 <stepcut> you could write a function: stringToLower = map toLowwer
12:32:47 <shaleh> stepcut: I was doing that (-:, just wanted to make sure there was not already such a wheel
12:33:09 <stepcut> shaleh: yeah, I know what you mean!
12:33:31 <shaleh> seems like there should be an equiv of Data.Char for Data.String.
12:34:50 <stepcut> shaleh: perhaps. But on the other hand, 'stringToLower' is longer to type than 'map toLower'
12:36:04 <shaleh> true, but it still feels weird to have to type that.
12:36:14 <stepcut> :p
12:39:19 <shaleh> shapr: what is the best way to get and hack on lambdabot? cvs, darcs?
12:39:23 <stepcut> i think it is pretty obvious what 'map toLower str' is doing, and has the advantage of not having to remember yet another function name...
12:39:53 <shaleh> stepcut: true
12:40:17 <shaleh> I guess what I really want is a pre-defined compare function I can pass to sortBy.
12:41:02 <shapr> shaleh: grab the 2.0 release from sf.net
12:41:23 <shapr> the haskell-libs cvs will soon disappear, I'm moving it to darcs
12:44:35 <stepcut> shaleh: even this is pretty short --> sortStrings = sortBy (\s1 s2 -> compare (map toLower s1) (map toLower s2))
12:45:10 <shapr> yes, lambdabot is in a darcs repo, but I'm not honestly sure whether cvs/darcs/local copies have any discrepancies.
12:45:20 <shaleh> stepcut: indeed.  Even defining the strLowCmp function was not that much work.
12:46:23 <shaleh> ok, since I am on a roll here ....
12:47:32 <shaleh> in imperative languages I typically code my functions so they test their input, return immediately if the input matches some cases otherwise do the functions work.
12:48:20 <shaleh> can / should I code this way in haskell?  I tend to dislike if else if else if else style code.
12:48:39 <det> shaleh: test their input for what kind of conditions?
12:48:46 <SamB> shaleh: depends. it is usually pretty enough, though.
12:50:14 <shaleh> for instance with dirWalker.  I would like to do nothing if the filename is "." or "..".
12:50:32 <shaleh> I have this code as if ... then return () else -- rest of the function here
12:51:09 <shaleh> is that a typical style? or would a case statement be more idiomatically correct?
12:52:14 <SamB> why don't you use patterns in the function definition?
12:52:48 <shapr> oy --> http://shootout.alioth.debian.org/lang/ghc/
12:52:49 <shaleh> SamB: no reason, that is why I am asking.  Part of learning a language is learning to think in that language.
12:53:11 <shapr> Doug Bagley's shootout has been resurrected by Brent Fulgham
12:53:45 <shaleh> I once worked with a guy whose perl code looked like a functional language.  All he did was make lists of actions and have a do_it() function.
12:53:46 <shapr> I have to ask, is this insane code or what? http://shootout.alioth.debian.org/bench/ary/ary.ghc
12:53:52 <Riastradh> It's still wildly inaccurate.
12:54:02 <Riastradh> (the shootout is, that is)
12:54:09 <Riastradh> Benchmarking considered harmful.
12:54:31 <shapr> of course, the count lines/chars/words code that uses a bunch of IORefs is far more painful.
12:54:38 <shaleh> hmm haskell did not fare too well in the benchs
12:54:50 <shapr> with code like this, it's no surprise
12:55:54 <det> he is actively accepting submissions
12:55:55 <vegai> I don't like the ocaml code in the shootouts
12:56:02 <shapr> det: spiffy!
12:56:18 <shapr> first of all, I'll suggest using -O2 and -fvia-C
12:56:25 <det> last I looked, their were several bugs with the benchmarking
12:56:56 <det> SML/NJ ranked 3rd *laugh*
12:57:28 * shapr wonders whether some specialization pragmas would help
12:57:56 <det> still broken
12:58:20 <vegai> det: when your multipliers are 1, 0, 0
12:58:22 <shapr> on lines of code Haskell gets six #1 ranks
12:59:32 <shaleh> ML beats C++, fun.
12:59:41 <vegai> the LOC rating is somewhat flawed (like with the ocaml code in my opinion)
13:00:35 <shapr> reverse a file: main = interact $ unlines . reverse . lines
13:01:09 <stepcut> I think I need to practice point-free style programming
13:01:12 <shaleh> shapr: hmmm, interact seems a poor choice there
13:01:37 <shapr> shaleh: yup, I totally agree.
13:02:39 <vegai> it might be a better idea to submit very terse but inefficient programs to the shootout
13:02:57 <vegai> since haskell can't compete on the cpu/memory level too well anyway
13:03:59 <shapr> unless Simon Marlow writes some benchmarks :-)
13:04:47 <shaleh> shapr: there isn't even a hello world for haskell!!
13:05:11 <shapr> I think there is...
13:05:20 <det> sure there is
13:05:23 <det> http://shootout.alioth.debian.org/bench/hello/hello.ghc
13:05:29 <shapr> though the object instantiation test is empty
13:05:50 <SamB> shapr: how do you test something like that?
13:06:17 <SamB> the compiler would probably cheat on you...
13:06:38 <shaleh> hmm, the hello world results page does not list haskell though
13:06:42 <shapr> Haskell doesn't have any objects, so it would be very challenging.
13:06:53 <stepcut> O'Haskell, maybe?
13:07:03 <shapr> hasn't been updated in years
13:07:03 <shaleh> lists it as ghc, not haskell
13:07:06 <shaleh> found it
13:07:10 <det> shapr: neither does SML, but they simulate them
13:07:37 <det> http://shootout.alioth.debian.org/bench/objinst/objinst.mlton
13:07:37 <shapr> hmm
13:08:27 <shapr> so, should we get esap to write an object emulator? ;-)
13:08:57 <det> Mlton ranks #1 in that test because it optimizes away everything :)
13:08:59 <stepcut> hehe
13:09:14 <shaleh> damn, ocaml does really well in the object instantiation test
13:09:24 <monotonom> "let object = ()" is object instantiation to me.
13:11:09 <shaleh> shapr: the C++ code is not too much better than the haskell code
13:11:23 <SamB> monotonom: the compiler would cheat, I tell you!
13:11:36 * shapr is tempted to wrap the C code into haskell FFI functions and rerun the test
13:11:50 <monotonom> Compilers are supposed to cheat.
13:11:51 <SyntaxLaptop> oh no! a Ninja!
13:11:54 * SyntaxLaptop runs away
13:11:59 <SamB> monotonom: oh.
13:11:59 <shapr> whoa
13:12:03 <shapr> that was interesting
13:12:11 <SyntaxNinja> :)
13:12:40 <monotonom> Suppose you write bubble sort code.  The compiler is supposed to recognize it and replace it with quicksort or mergesort.
13:14:20 <SamB> monotonom: you are silly!
13:14:29 <monotonom> I am just optimistic.
13:14:47 <SamB> if you wanted it to do that, you should have given it a RULE
13:16:36 * shapr boings
13:17:05 <shaleh> shapr: where is @index defined in lambdabot? I can not find it in the lambdabot2 tree.
13:17:09 <shapr> SyntaxNinja: so, two CABAL packages now, right?
13:17:17 <shapr> shaleh: welll, that's because it's not in there :-)
13:17:30 <shapr> thing is, @index requires a large portion of the Haddock source
13:17:30 <SyntaxNinja> shapr: you mean xml-rpc and gtk2hs?
13:17:38 <shapr> oh, I thought it was xml-rpc and HUnit
13:17:44 <shapr> gtk2hs is in CABAL form now??
13:18:00 <shaleh> Igloo: was asking for gtk2hs packages earlier
13:18:02 <SyntaxNinja> shapr: HUnit isn't there yet, and it may be that Marvin-- packaged gtk2hs, though I haven't seen it :)
13:18:10 <SyntaxNinja> shaleh: igloo wanted Debian packages :)
13:18:36 <shapr> huh, if gtk2hs is in there, we need deb skeleton code fast
13:18:36 <shaleh> heh
13:19:20 <SyntaxNinja> shapr: problem with HUnit is just that it has a bunch of duplicate modules.  I don't actually know why that is...
13:19:20 <SyntaxNinja> but it should be easy to package it now if we just pick certain modules.
13:19:55 <SyntaxNinja> (it has several Main modules and several HUnitLang modules, which can't coexist in one library)
13:20:28 <SyntaxNinja> and I haven't seen the xmlrpc library yet :)
13:20:54 <shapr> duplicates?
13:20:54 <shapr> hm
13:21:53 <shapr> that's odd
13:22:23 <SyntaxNinja> maybe I screwed something up and it was somehow just getting confused between packaging the HUnit library and including it in the Cabal itself, which is a fundamentally broken case :)
13:22:49 <SyntaxNinja> HUnit is the only thing we depend on outside base, so it's not a particularly good example.
13:22:58 <SyntaxNinja> (but it's supposed to be in base Real Soon Now)
13:23:30 <shapr> that's good to hear
13:23:42 <shapr> oh, I spoke to John Hughes about QuickCheck, he said "no progress"
13:23:43 <shapr> :-/
13:23:51 <stepcut> :)
13:23:56 <shapr> I want shrink and saving of failed cases
13:23:57 <SyntaxNinja> I really want to combine QC and HUnit
13:24:03 <shapr> yes! me too!
13:24:06 <SyntaxNinja> I wrote some code for work that lets me easily use both of them.
13:24:10 <det> someone just released a QC-like thing for SML
13:24:12 <shapr> saving of failed test cases is the way to do that
13:24:13 <SyntaxNinja> I'll have to ask if I can release it
13:24:21 <shapr> det: and for Python, and for Common Lisp, and for ...
13:24:49 <shapr> John said that QC could save the failing PRNG seed, and then you have an easy way to store the test case
13:24:54 <det> shapr: Haskell is quite progressive!
13:25:19 <shapr> I like the idea of having support for both prng + seed and literal test cases, so that you can change the generator and still keep fail(ed|ing) cases.
13:25:44 <shapr> I also want to integrate HUnit/QuickCheck and the darcs browser
13:25:58 <shapr> so you can get something like http://fit.c2.com/ and something like darcs trackdown
13:26:14 <shapr> but I don't have a clear mental picture of that thing yet
13:26:28 * shapr is repeating himself himself
13:30:21 <shapr> hi alexj, looking for Haskell info?
13:34:05 <SyntaxNinja> can I get a link to the eurohaskell photos again?
13:34:53 <shapr> it's on the EuroHaskell wiki page
13:36:19 <SyntaxNinja> @wiki EuroHaskell
13:36:19 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
13:40:09 <shapr> I'm tempted to post the link to the unsafePerformIO sign to haskell-cafe
13:40:29 <SyntaxNinja> you should totally
13:40:37 <SyntaxNinja> or just all the photos, with a particular link to that one.
13:41:03 <shapr> yah, good point
13:41:32 <shapr> I hope andersca's server can take it :-)
13:42:18 <SyntaxNinja> heh
13:42:34 <shapr> you've been haskell-dotted!
13:53:09 <shapr> actually, I think I'll ask andersca before I send such a mail.
14:09:50 <stepcut> "If you're one in a million, there are a thousand people in China just like you..."
14:10:13 <SyntaxNinja> hehe
14:15:43 <Jerub> o/~ she was one in a milliooon, yeah / so there's five more just in new south wales! o/~
19:47:34 <paganini_> hi shapr
20:22:27 <SyntaxLaptop> woot - HUnit is packaged w/ cabal now
20:22:32 <SyntaxLaptop> (just for you, shapr)
20:25:50 * SyntaxLaptop sleep &
21:02:49 * Cale notices a typo in http://haskell.org/aboutHaskell.html. Namely "applictaion" -> "application"
21:03:16 <Cale> also... what's with "Amoco subsequently transcribed the functional program into ... with encouraging results."
21:03:30 <Cale> "..." ?
21:05:35 <keverets> it's a mystery.
21:10:28 * Cale transforms his program into an ellipsis. ENCOURAGING RESULTS!
21:10:39 <Riastradh> Wow!  I'm ENCOURAGED!
21:10:44 <Riastradh> s/Wow/Yow/1
21:10:52 <Riastradh> @yow
21:10:53 <lambdabot> Let's all show human CONCERN for REVEREND MOON's legal difficulties!!
21:11:21 <keverets> @arr
21:11:21 <lambdabot> I heard andersca is a pirate
23:04:16 <shapr> yay, I'm taking my unicycle to swedish class today.
23:04:23 <Jerub> ;)
23:05:45 <stepcut> mmm, blender3d
