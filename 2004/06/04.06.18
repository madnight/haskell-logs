01:03:00 <Lemmih> Is there something like ocaml's output_value in Haskell? It doesn't have to be platform/implementation independent.
01:05:57 <dons> what does output_value do?
01:08:37 <Lemmih> "Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function {!Pervasives.input_value}."
01:09:51 <Lemmih> I'm trying to create a simple cache for arbitrary datatypes... but quite sure if it's possible.
01:10:15 <dons> hm, can you use show and read?
01:10:42 <dons> deriving (Show, Read) is useful for many purposes
01:13:21 <Lemmih> That's what I'm trying to circumvent.
01:15:32 <dons> GHC has a Binary class used to define a put and get function on data that derives Binary
01:15:41 <dons> it generates byte-level representations of values
01:15:56 <dons> you might also be able to do something with Storable
01:17:55 <Lemmih> thx.
01:20:24 <dons> nhc provides Binary too. that's where ghc's came from
02:00:09 <shapr> good morning #haskell!
02:00:29 <blackdog> and the rest of the day to you, shapr
02:04:58 * Lemmih is _soooo_ tired...
02:06:12 <JaffaCake> mornin'
02:07:09 <ski> good morning !
02:13:52 <shrimpx> hi
02:30:15 <JaffaCake> hey hey, ghc is moving up the list in the language shootout :)
02:30:37 <JaffaCake> can't believe Perl is still beating us, though
02:31:01 <shapr> JaffaCake: are you sending in new rewrites of the tasks?
02:31:12 <JaffaCake> I've sent in a few, yes
02:31:27 <shapr> your OpenGL rewrite on the HOpenGL list was inspirational
02:31:48 <JaffaCake> which one was that? can't remember
02:32:44 <shapr> was it GlxGears?
02:33:47 <JaffaCake> I vaguely remember commenting on someone's implementation of GlxGears
02:34:10 <JaffaCake> JaffaCake's tip of the day(TM)
02:34:14 <JaffaCake> if you can use mapM_ or sequence_ instead of mapM/sequence, then do so
02:42:18 <chucky> JaffaCake: Why do so instead? Performance or just beauty?
02:42:19 <shapr> the shootout is a bad way to compare languages, but it is a nice way to see code
02:42:52 <JaffaCake> chucky: performance
02:43:31 <JaffaCake> shapr: yes, but people will use this to compare languages
02:44:01 <JaffaCake> it paints an unfair picture of Haskell - most of the slow programs are due to the representation of Strings
02:44:58 <chucky> we should ask him to add something like "total lines of code" (for all the tests) as a test. Although that might give Perl an advantage over us
02:45:18 <shapr> total lines of code is one of the measurements
02:45:36 <shapr> and it does help :-)
02:45:38 <chucky> it is? I'm just babbling as usual then. :)
02:46:10 <JaffaCake> perl still beats us on lines of code, and so does ocaml
02:48:45 <shapr> I'm fond of String as [Char], it feels nice for pattern matching, recursion, and that sort of stuff.
02:49:01 <shapr> If I could do the same pattern matching and recursion with PackedString, I'd switch :-)
02:49:58 <JaffaCake> sure there are advantages... but performance sucks
02:52:00 <shapr> btw, is the IORef code in the count lines/words/chars speedier than the alternatives?
02:52:15 <JaffaCake> hang on...
02:52:32 <shapr> not a high priority question :-)
02:53:44 <JaffaCake> there is a faster way to do IORef of Int
02:53:46 <shapr> I wonder if various additions of $! and strict types would speed things up.
02:54:12 <JaffaCake> that program looks bad due to conversion from String to PackedString
02:54:24 <JaffaCake> and the implementations of wordsPS and lengthPS might be bad
02:54:38 <shapr> I also wonder how much -O2 -fvia-C would help
02:54:45 <JaffaCake> very little, probably
03:05:30 <det> JaffaCake: it's Haskell's fault it uses lists for strings
03:05:43 <shapr> I like it.
03:05:51 <det> why ? :)
03:06:05 <shapr> it fits into Haskell elegantly
03:06:10 <det> Why not have a Sequence type class and use whatever representation you want :)
03:06:21 <JaffaCake> but we don't even provide a good alternative if you want performance
03:06:22 <det> you dont even need to know how it is represented
03:07:11 <det> first and reset and then some optional combinators like foldl could be part of the class
03:07:15 <det> rest*
03:07:37 <det> does Haskell have such a type class?
03:07:47 <JaffaCake> what, for strings? no.
03:07:50 <det> no
03:07:53 <det> for Sequences
03:08:00 <JaffaCake> not yet, but it might soon
03:08:18 <det> so foldl only operates on  lists?
03:08:32 <JaffaCake> but if you want to instanstiate sequences for Strings, then you need the class to parameterise over the element type of the sequence too
03:08:55 <JaffaCake> @type foldl
03:08:57 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
03:09:13 <det> I *really* like Haskell's type classes
03:09:33 <det> but last I looked, they werent used anywhere near their potential
03:10:18 <det> shapr: How's life?
03:10:46 <shapr> trying to wake up right now
03:11:03 <shapr> thinking about algebraic datatypes, fmap, and unix pipes
03:11:32 <shapr> how's life with you?
03:13:06 <det> Good, thinking about combinator bases :)
03:13:56 <shapr> I talked with Jef Raskin at EuroPython, his presentation got me thinking.
03:14:38 <liiwi> squish
03:14:43 <shapr> hei liiwi 
03:14:51 <det> shapr: what was it about?
03:15:56 <shapr> same stuff he's been saying for years, that we should design application interfaces around cognitive psychology research results
03:17:18 <JaffaCake> hmm, that sounds like Larry Wall talking
03:17:54 <shapr> Jef has a somewhat different approach than Perl
03:18:02 <JaffaCake> good :)
03:18:55 <shapr> anyway, if you want the Jef Raskin intro here's the summary of his book: http://humane.sourceforge.net/humane_interface/summary_of_thi.html
03:19:54 <shapr> many of his ideas center around basic stuff like "eliminate distractions"
03:20:05 <liiwi> distractions bad
03:20:09 <JaffaCake> thanks, looks interesting
03:20:10 <shapr> some people talk about the accidental difficulties versus the essential difficulties of any task
03:20:32 <shapr> like type inference versus the Java approach to static typing
03:23:47 <shapr> The Pragmatic Programmer has a related principle called MindCrayon, http://pragmaticprogrammer.com/cgi-local/pragprog?MindCrayon
03:26:35 <shapr> det: have you read the Joy paper on combinator bases?
03:32:32 <det> shapr: yeah
03:34:31 <det> shapr: I really liked it
03:34:50 <det> shapr: It would be nice to have a languge based on combinators with fancy typing
03:36:30 <det> shapr: for example, linear types cant be an argument to K or C? (or is it B that is \f x . f x x)
03:36:41 <shapr> I've thought about a dynamic supercombinator language, where you only need to write the base in assembly or whatever, and then link in bigger/faster bits later.
03:36:54 <shapr> but maybe that's just forth :-)
03:37:48 <det> I think we should revise ASCII to include a lambda character
03:38:02 <det> I bet *that* would get people into functional programming :)
03:38:17 <shapr> or at least out into the streets rioting
03:40:04 <shapr> I'll skip the "let's get UTF8 into GHC" comment, because I know JaffaCake will say "great idea! go for it!"
03:40:09 <ski> det : isn't \f x . f x x  called W or something ?
03:40:44 <JaffaCake> great....  oh never mind :)
03:41:12 * shapr laughs
03:41:20 <det> ski: yeah W
03:41:51 <det> ski: I feel surpisingly ashamed I dont know my combinators by heart
03:41:52 <karingo> W is \x . x x
03:42:01 <det> hrmm, it seems lambda is a gay rights symbol
03:42:05 <det> I didnt know that
03:42:16 * ski vaguely seems to recall that the name is related to Weakening 
03:44:09 <det> ski: with a name like yours, i would expect you to correct my combinator statements :)
03:46:12 <earthy> wasn't WW equal to \Omega ? :)
03:51:02 <ski> det : heh
03:52:09 <ski> (B = \f.\g.\x.f (g x) and C = \f.\g.\x.f x g  or maybe 'twas the other way around ..)
03:59:04 <det> I wonder if there is a set of combinators without any reduncancy which can express all linear combinators and all non-linear combinators (for example, B C W K = all non-linear combinators (right?), B C I defined all linear combinators (right?), but I is redundant because it can be defined with W and K,  although required for linear combinators since they cant use W and K)
04:03:32 <ski> det : hmm
04:10:01 <det> I am not sure how well I expressed my thought there :)
04:12:17 <det> maybe I could express it better with some types
04:22:13 <det> ok, I think I have this right
04:22:43 <det> I want a set of combinators to express a linear type system
04:23:03 <det> here is an example failed combinator base
04:23:32 <shapr> hey Si\, ltns!
04:23:58 <det> I use 'a to express a non-linear polymorphic variable (just like ML 'a) and "a to express a linear polymorphic variable (cant be copied or destroyed)
04:24:05 <det> the types for this base are:
04:25:52 <det> erm, 1 sec
04:30:31 <det> change: ' means can be linear, " means cant be linear
04:30:54 <det> B = \f g x . f (g x) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
04:30:54 <det> C = \f x y . f y x : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
04:30:54 <det> W = \f x . f x x : ("a -> "a -> 'b) -> "a -> 'b
04:30:54 <det> K = \x y . x : 'a -> "b -> 'a
04:30:54 <det> I = \x . x : 'a -> 'a
04:31:51 <ski> hm
04:31:55 <det> but this doesnt work because I want it to have no redundancies. yet I can be defined in terms of W and K. But it is needed for the linear set where you dont have W and K
04:32:31 <ski> haven't you flipped the ' and " (at least in K) ?
04:32:58 <det> " means "cannont be a linear variable"
04:33:04 <det> since y gets destroyed
04:33:30 <ski> <det> I use 'a to express a non-linear polymorphic variable (just like ML 'a) and "a to express a linear polymorphic variable (cant be copied or destroyed)
04:33:37 <shapr> flip out!
04:33:45 <det> ski: yeah, read further :p
04:33:50 <det> ski: I cirected myself :)
04:34:09 <ski> oh
04:34:16 * ski feels stupid :)
04:34:21 * shapr feels random
04:34:49 <det> shapr: did you take your meds? :)
04:35:45 <det> I wonder if it is possible to have a combinator set like that
04:35:50 <det> and how complicated it would be
04:36:00 <shapr> det: yes, but not much effect today :-P
04:36:19 <shapr> I think I'll go unicycling instead.
04:36:26 <det> shapr: good idea!
04:36:33 <det> shapr: I have never unicycled
04:36:44 <det> shapr: are they popular in Finland?
04:36:52 <det> or Sweden
04:37:08 <shapr> not that I've seen
04:37:26 <shapr> did you see the pix of Me, bringert, and John Hughes unicycling at EuroHaskell?
04:37:53 <det> It would be neat to write a program where I could say "I want to express the following lambda expressions, and contain no redunandcies" and have it find a solution :)
04:38:03 <det> shapr: no!
04:38:34 <ski> det : express with combinators ?
04:38:53 <det> ski: yeah
04:39:03 <shapr> @wiki EuroHaskell
04:39:03 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
04:39:05 <det> ski: I am a terrible communicator
04:39:37 <det> shapr: ridley. appears to be down :(
04:41:16 <shapr> det: you can see a preview in my blog: http://shapr.homelinux.net/~shae/blog/2004-06-12.html
04:43:04 <det> which is in the grey shirt? :)
04:43:36 <det> nice:  trying to explain monads while riding a unicycle.
04:44:06 <shapr> oh, the plump person in the grey shirt is me
04:44:39 <shapr> the button down and slacks is John Hughes
04:55:20 <ski> det : you don't want some kind of of-course type-operator, then ?
04:55:42 <ski> how would you type
04:56:00 <ski> \f.\g.\x.\y.f (g x) (g y)
04:57:38 <ski> also, should your program give some kind of unique best solution ?
04:57:51 <det> ski: "of-course"?
04:58:06 <ski> like in Girard's Linear Logic
04:58:21 <det> I am not familiar
04:58:30 <det> ski: any kind of solution really
04:58:40 <ski> hm
04:58:53 <ski> e.g f : T0 -> T1
04:59:10 <ski> here f can't copy or discard it's element, right ?
04:59:11 <det> ski: ideally it wouldnt involve some kind of crazy 21 argument combinator though :)
04:59:24 <ski> s/element/argument/
04:59:31 <ski> heh
04:59:39 <det> what do T0 and T1 represent?
04:59:53 <ski> just arbitrary types, more or less
04:59:54 <det> and how is F defined?
05:00:03 <ski> f = \x. ...x...
05:00:24 <ski> so T0 could be Int
05:00:26 <ski> e.g.
05:00:28 <det> you are saying x appears only once ?
05:00:32 <ski> yes
05:01:17 <ski> in a wholly linear system all variables must be used exactly once
05:01:29 <det> I don't understand how I would know if f would copy or discard it's arguments, where am I getting that information?
05:02:31 <ski> you seemed to want to express linearity and nonlinearity by two kinds of type-variables above, right ?
05:03:04 <det> I really havent thought that through, but that was my initial idea to do it
05:03:15 <det> Is this how Clean's uniqueness types work?
05:03:25 <det> except without combinators
05:03:26 <ski> well, the 'of-course' idea works a bit different
05:03:31 <ski> which ?
05:04:13 <ski> this = two kinds of tyvars   or this = with of-course ?
05:04:37 <det> I am not sure how Clean works
05:04:52 <det> I only know it has "uniqueness" types which state that the varaible exsists only once
05:05:23 <det> havingonly 1 instance of a variable = linear, correct?
05:05:24 <ski> i'm not totally familiar with it, but i think i've got an approximate idea of it  (and it's related to of-course)
05:05:30 <ski> yes
05:05:58 <det> how does of-course work?
05:06:14 <ski> so, i guess one can take several views
05:06:40 <ski> the crudest, i think, is to say that all (data-)variables must be linear
05:06:50 <ski> (i.e. only one occurance)
05:07:16 <ski> (modulo 'then' and 'else' branches in if-expression and such things)
05:07:24 <ski> so
05:07:43 <ski> we have a type constructor '!' pronounced of-course
05:08:03 <ski> and we have some functions related to this
05:08:16 <ski> discard : !a -> 1
05:08:28 <ski> copy : !a -> !a * !a
05:08:36 <ski> extract : !a -> a
05:08:46 <ski> so you can say
05:09:09 <ski> \x. let (x0,x1) = copy x in ... extract x0 ... extract x1 ...
05:09:18 <det> type constuctor in the Haskell sense?
05:09:26 <ski> yes
05:09:35 <ski> like Maybe or IO
05:09:54 <det> discard returns "1" ?
05:09:59 <ski> so that function would have type like  !T0 -> T1
05:10:00 <det> like an Int ?
05:10:14 <ski> 1 is just unit or ()
05:10:17 <ski> the unit type
05:10:21 <det> ahh
05:10:24 <ski> * is pairing
05:10:41 <ski> (maybe i should've written it in haskellish syntax :)
05:10:54 <ski> discard :: !a -> ()
05:11:04 <ski> copy :: !a -> (!a,!a)
05:11:13 <ski> extract :: !a -> a
05:11:27 <det> I am more familiar with ML, so the * I understood :)
05:11:38 <ski> so discard explicitely discards a value of of-course type
05:11:50 <ski> while copy explicitely copies it :)
05:12:02 <ski> and extract allows you to get the actual value
05:12:25 <det> copy means "new reference to" ?
05:12:39 <ski> yes
05:12:52 <ski> one reference in, two references out
05:13:42 <ski> so of-course recovers the ability to work with nonlinear data, but in a restricted way
05:13:59 <det> I see
05:14:03 <ski> the usual function type could be defined as  !a -> b
05:14:35 <det> but how does it deal with values which you cant construct with !
05:14:40 <det> like the state of the world
05:15:00 <ski> you just can't apply those three function to such a value
05:15:13 <ski> because it's type is not !t for some type t
05:15:22 <ski> simple :)
05:15:56 <det> oh, so you dont actually have access the the ! constructor?
05:16:10 <ski> you can't have a general function
05:16:13 <ski> f : a -> !a
05:16:33 <ski> so you can't coerce things into of-course type
05:17:14 <det> This sounds like hat I was describing, except with my way, the combinators do the copying, discarding
05:17:18 <det> and there is no extract
05:17:58 <ski> but, writing all those explicit discarding,copying,extracting can be quite tiresome
05:18:32 <det> I bet
05:18:38 <ski> so one can modify the typesystem so that the system automatically infers where to insert thee (discard, ...)
05:18:41 <det> just give me lambda calculus, damnit :)
05:18:58 <ski> so we get a linear lambda calculus
05:19:06 <ski> with two kinds of variables
05:19:13 <ski> linear ones, and nonlinear ones
05:19:28 <ski> living in separate environments in the typesystem
05:19:43 <ski> e.g. one could perhaps write
05:19:54 <ski> \x. x + 1  :: Int -> Int
05:20:05 <ski> \!x. x + x :: !Int -> Int
05:21:25 <det> what is the point of making the second example x non-linear?
05:21:36 <ski> so we don't have to put all those tiring null operations explicitely
05:21:43 <ski> you add x to itself
05:21:50 <ski> using x two times
05:21:54 <ski> i.e. not linear
05:22:34 <ski> ok ?
05:22:48 <det> oh, right
05:22:51 <ski> of course 2 * x would have the same result, in this case :)
05:23:25 <det> although, * would take a ! type as well if we want church numerals :)
05:23:41 <ski> hmm
05:23:48 <ski> how do you mean ?
05:24:10 <ski> oh
05:24:23 <ski> mm, guess so
05:24:24 <det> if 2 the a chruch numeral repsentation of 2 then 2 * x must contain non-linerality _somewhere_
05:24:33 <ski> yes
05:25:12 <ski> one can actually coerce expressions into of-course type
05:25:18 <det> so, linear LC sounds like what I was describing which a nicer notation
05:25:27 <ski> but only if they have no free linear variable
05:25:41 <det> oh, I see
05:25:55 <det> example of an coercion ?
05:26:25 <ski> it'd have to be a syntactical construct and not a function
05:26:42 <ski> mayhaps
05:27:01 <ski> Gamma ; {} |- e : t
05:27:09 <ski> --------------------
05:27:34 <ski> Gamma ; {} |- !e : !t
05:27:43 <ski> or something
05:27:50 <det> oh
05:28:06 <ski> the typing judgements here look like   Gamma ; Delta |- e : t
05:28:26 <ski> with Gamma being nonlinear type env and Delta being linear type env
05:28:42 <det> is there really a need to coerce?
05:29:00 <ski> you wonder if it can be done implicitely ?
05:29:41 <ski> if so, then mayhaps, not sure  (possible that clean does that ..)
05:30:20 <ski> the other typing judgments are more or less obvious here, agree ?
05:30:32 <det> I mean, I wonder if a linear type ever nead to become a non-linear type in practice
05:30:48 <ski> top-level functions
05:31:00 <ski> one often wants to use them several times
05:31:40 <ski> (hmm, but if there is no linear variable bindings at top-level, then i guess this is automatically satisfied)
05:32:01 <ski> i think Clean doesn't allow linear variables at top-level
05:32:28 <earthy> ?
05:32:44 <det> ski: you are a great teacher!
05:32:52 <ski> (would prolly be a bit hard to ensure that at exactly one other module uses it up ..)
05:32:56 <ski> oh
05:32:57 <ski> ty
05:33:02 <ski> earthy : ?
05:33:16 <earthy> `linear variables' && Clean ?
05:33:27 * earthy knows uniqueness and strictness in Clean
05:33:28 <ski> yeah
05:33:45 <det> do uniqueness types vary from linear types in any way?
05:33:50 <ski> Start world = f world
05:34:16 <ski> it's more or less the same intuitive concept, AFAIU
05:34:24 <ski> those some details can differ
05:34:36 <earthy> lemme reread my backlog for a sec
05:34:57 <ski> (don't think Clean's get additive pairs, either .. :( )
05:35:03 <ski> *got
05:35:07 <ski> earthy : mm
05:35:13 <det> what is an additive pair?
05:36:13 <ski> many typeconstructors in ordinary (i.e. nonlinear) logic splits into two in linear logic (with of-course)
05:36:18 <earthy> 'kay, uniqueness types in Clean, as I understand, are indeed similar to the linear type stuff you mentioned
05:36:34 <ski> so ordinary pairs split into multiplicative and additive pairs
05:36:44 <ski> same with the 'either' types
05:37:16 <earthy> but, uniqueness typing allows duplication
05:37:19 <ski> earthy : yeah, except they don't have explicit of-course, and some more things ..
05:37:28 <ski> really ?
05:37:35 <ski> of the world ?
05:37:38 <earthy> yup. you just lose uniqueness on duplication
05:37:38 <det> earthy: then who does the type system guarentee it is really unique?
05:37:39 <earthy> yup.
05:38:03 <earthy> thing is, you can get non-unique read-only values out of a unique value
05:38:04 <det> earthy: what is the result of duplicating the world and doing IO to each copy of the world?
05:38:19 <earthy> you can only do I from each copy of the world. :)
05:38:21 <det> oh
05:38:22 <earthy> not O to. :)
05:38:43 <ski> AFAIR Clean doesn't allow duplication of linear variables
05:38:58 <ski> (though i might recall worngly)
05:39:21 <earthy> uniqueness is not calculated from arguments, but from results
05:39:28 <ski> hmm
05:39:41 <earthy> so, if the *result* of a function needs to be unique, there can be no non-uniqueness happening in the function
05:40:00 <earthy> to the thing that is returned
05:40:03 <ski> but if you duplicate the world, you can't actually write a whole program, right ?
05:40:17 <ski> (because Start returns exactly one world, not two or more)
05:40:26 * earthy nods
05:40:45 <earthy> however, you can split off the world into a unique copy and a non-unique copy
05:40:59 <ski> hmm
05:41:06 <earthy> and return the unique copy
05:41:26 <ski> but then the non-unique copy isn't forced, right ?
05:41:37 <earthy> right.
05:42:34 <ski> but can you pass that one on to another function which reads it and returns it and some result based on it (which are going to be forced) ?
05:42:46 <det> earthy: what can you do with a non-unique read-only world?
05:43:04 <ski> hmmm
05:43:16 <earthy> get all manner of stuff, such as file contents, and such
05:43:18 <ski> how does the type system know it's read-only ?
05:43:27 <earthy> ski: the type system doesn't
05:43:43 <earthy> it's just that there are no write functions that take a non-unique argument
05:43:45 <ski> hmm, almost guessed that :)
05:43:56 <ski> ok
05:44:24 <earthy> the fun is that if you just need to do input you don't need to think about uniqueness
05:44:34 <ski> i recall seeing something about opening files either uniquely for read-write or nonuniquely for just read
05:44:39 * earthy nods
05:45:01 <det> earthy: how can input not need to worry about uniqueness?
05:45:12 <ski> just shows that i should play around more with Clean :)
05:45:37 <ski> reads can be shared if there is no write
05:45:44 <earthy> what ski said
05:45:48 <ski> e.g. of files or of graphics bitmaps
05:45:57 <det> what if I am reading from a file
05:46:07 <earthy> that is being written to from a different program?
05:46:09 <det> first I copy the world
05:46:11 <earthy> tough luck. :P
05:46:16 <det> I read with the first world
05:46:24 <det> then I read with the second world
05:46:35 <det> it would require a seek to 0 to get the desired results
05:46:47 <earthy> yes, possibly. so?
05:47:22 <ski> a file in clean isn't like a handle in haskell
05:47:41 <ski> the File *is* the file
05:48:14 <ski> a reading operation takes the file and returns a new file value representing the unread parts
05:48:34 <ski> earthy : do i remember correctly ?
05:49:17 <det> ohh
05:49:26 <ski> det : so each File value contains it's own offset into the actual physical file
05:49:36 <det> so read doesnt need to world
05:49:48 <ski> first you open a file
05:49:58 <earthy> ski: you remember correctly.
05:50:02 <ski> and get back the file and the new world
05:50:06 <ski> earthy : ty :
05:50:08 <ski> :)
05:50:20 <det> that seems silly, read should take the world and a handle :)
05:50:31 <ski> it doesn't :)
05:50:43 <earthy> (at least, if I do, but I really feel I do, as I did half a year of very heavy I/O programming with Clean back in early 1995)
05:51:16 <earthy> det: why should read talk the world and a handle? why not just a file?
05:51:21 <earthy> s/talk/take/
05:51:28 <ski> this enables at bit more concurrency/commutativity of world modifications
05:52:20 <ski> you don't have to serialize *every* IO operation along a single linear path as in the IO monad (module Concurrent haskell and such, of course)
05:53:33 <det> earthy: because, unerneath the hood, that is what is happening
05:53:58 <det> earthy: each IO operation modifies the world
05:54:03 <det> earthy: + what ski said
05:54:12 <ski> det : reads from one file doesn't have to be synchronised with reads from another file
05:54:14 <earthy> det: ah, but it only modifies *part* of the world.
05:54:26 <ski> det : the IO operations was in haskell
05:54:31 <det> true
05:54:41 <earthy> and you get access to that fine grained granularity in Clean
05:54:45 <ozone> :: Int -> Int -> *Australia -> *Australia
05:54:56 <ski> writes to one file doesn't have to be synchronised with writes to another file
05:54:59 <ski> etc
05:55:00 <det> earthy: but it would be very difficult to express
05:55:06 <earthy> how so?
05:55:20 <earthy> start :: *World -> *World
05:55:56 <det> earthy: it would need to depend on the state of the file *and* the state of of things can change the state of any file
05:56:05 <det> earthy: such as truncate
05:56:16 <earthy> start w = closeFile f w  where  f = writeFile f'; f' = openFile "filename" w
05:56:17 <ski> not if one uses read and write locks
05:56:25 <earthy> (something like that at least)
05:56:26 <det> earthy: otherwise it is not safe to run concurrently
05:56:38 <det> earthy: or out of order
05:56:57 <ski> openFile gives a new world, i think
05:56:58 <det> ski: hmm
05:57:04 <earthy> ski: it does, indeed.
05:57:14 <det> ski: then it needs to depend on the state of the file and the state of the lock :)
05:57:18 <earthy> start w = closeFile f w'  where  f = writeFile f'; (f',w') = openFile "filename" w
05:57:24 <ski> start w0
05:57:37 <ski>   # (w1,f) = openFile "filename" w0
05:57:50 <det> ski: I wonder if there is a neat way to do all these state dependancies implicitly
05:57:59 <ski>   = closeFile f1 w1
05:58:06 <ski>   where f1 = writeFile f
05:58:09 <ski> or something
05:59:09 <ski> det : how do you mean ?
05:59:26 <ski> the w0,w1, etc .. ?
05:59:27 <det> where you dont have to pass around all these state variables
05:59:56 <earthy> det: monads! :)
06:00:06 <ski> one could perhaps have something like mercury state variable syntax ..
06:00:14 <det> earthy: hmmm :)
06:00:25 <earthy> there is *no* reason that you couldn't write a monad abstraction over Clean's uniquely typed world
06:00:39 <earthy> it's just that Clean doesn't do it that way
06:01:02 <det> earthy: I guess Clean sacraficies a full Unix file interface for simplicity in design with reguard to files and locking
06:01:03 <earthy> note by the way that Clean was developed mostly as Concurrent Clean for a while
06:01:08 <ski> iirc there's a return and bind function for a (unique :) state monad in some standard library
06:01:19 <earthy> det: it does (did? not sure how it's progressed)
06:01:31 <earthy> (it was bad enough that you didn't even have stat of getdirent)
06:01:38 <earthy> s/of/or/
06:01:39 <det> earthy: you can truncate an opened file?
06:01:48 <earthy> not sure anymore
06:02:04 <earthy> note: everything I said is based on Clean 0.8 knowledge. ;)
06:02:15 <det> or in any way modify an opened file?
06:03:10 <det> Some clean hackers need to submit missing tests to the revived shootout page
06:03:24 <det> so I can compare it's performance :)
06:03:26 <ski> doug's ?
06:03:48 <det> yes, but revived
06:03:59 <ski> where ?
06:04:04 <det> http://shootout.alioth.debian.org/
06:04:20 <ski> ty
06:04:59 <ski> i've heard said that it's quite efficient with numerical code and such
06:05:26 <ski> (prolly unique unboxed arrays help :)
06:06:05 <det> I am going to try to set a weight of 0 for the tests it is missing and look at the results
06:06:12 <ski> (anyway, iirc it doesn't have additive pairs)
06:06:35 <ski> (not that mercury has those either ..)
06:08:05 <det> wow, clean does very well when I disable it;s missing tests
06:08:19 <det> coming just below MLton in 5th place
06:09:43 <ski> nice
06:10:26 <earthy> Haskell comes in at 10th place if I disable its missing tests
06:10:56 <det> someone should write the missing tests :)
06:11:56 <earthy> (oh, I did enable linecounts. ;))
06:12:29 <det> ahh
06:12:37 <det> comes in 15th for me
06:12:56 <det> including disabling "List processing" for which some kind of error was happening
06:13:56 <earthy> ah, 'kay, disabling listprocessing, setting linecount to 2, disabling all tests that either haskell or clean fail on, Clean ends up 10th, ghc 11th.
06:16:11 <det> Nice talking to ya'll, g'night
06:16:17 <ski> mm
06:16:20 <ski> 'night
06:28:00 <SyntaxNinja> bringert: on your xml-rpc page, can you change the link to haskell.org/cabal?
06:28:11 <SyntaxNinja> (When we have a release, I'm going to announce the re-branding and all...)
06:32:56 <earthy> cabal? lip?
06:33:10 <earthy> (there is no cabal)
06:34:13 <SyntaxNinja> there will be Real Soon Now :)
06:36:20 <earthy> you may want to add a link to http://en.wikipedia.org/wiki/TINC and http://en.wikipedia.org/wiki/Cabal to the page. :)
06:37:57 <earthy> which may or may not exist ;P
06:39:46 <SyntaxNinja> hm. does anyone remmeber who came up with "Cabal"?
06:39:49 * SyntaxNinja feesl bad
06:40:06 <SyntaxNinja> also alexj came up with a good name for the meta-system: "Hackage" which I don't know why we didn't come up w/ that before
06:40:21 <SyntaxNinja> It starts with "H", sounds like "package" and has the word "Hack" in it.  perfect!
06:40:54 <Igloo> Why do you feel bad?
06:41:21 <SyntaxNinja> in other news, my laptop monitor is not working in X. it starts off working, but then gets wiggly, and it seems like a hardware problem because when I touch it right, it starts working again
06:41:29 <SyntaxNinja> but I'm surprised this only happens in X
06:41:44 <SyntaxNinja> Igloo: oh, I feel bad that I dno't remember whose idea it was, because I want to give them credit in the readme or something.
06:43:14 <Igloo> Ah, right
07:12:10 <TheHunter> hi, how can I easily determine from which function error gets called?
07:14:28 <Igloo> You can't
07:15:06 <Igloo> If you want to know for debugging then compiling for profiling and running with +RTS -xc might tell you, catually, but I'm not sure
07:15:51 <TheHunter> thx
07:16:15 <Igloo> Yup, look like it does
07:17:18 <Igloo> You want -prof -auto-all (and it'll probably only tell you which top-level function)
07:17:24 <ikegami> it looks ghc options
07:19:11 <TheHunter> it's just so weird. when you have an error like "(!!):Index too large" you should really be told which (!!) it was
07:21:16 <Marvin--> yes, Haskell's error handling could be better
07:24:20 <ski> (doh! machine rebooted)
07:26:08 * shapr hops distractedly
07:28:23 * ski wonders if this irc client is really epic
07:28:42 <shapr> it may just be classic rather than epic
07:29:17 <ski> i was thinking more of maybe mono ..
07:29:20 <shapr> my unicycling was cut short today by a vicious seabird defending its nest :-/
07:29:35 <ski> oh
07:29:45 <ski> where were the nest ?
07:29:56 <shapr> my pride was seriously injured when the bird dive bombed me
07:30:10 <shapr> actually, the nest was under a wooden box in a parking lot
07:30:17 <shapr> I was just unicycling past
07:30:21 <ski> ok
07:31:04 <ski> i've had seabirds attack me when distributing newspapers for some years ago
07:32:42 <ski> they seemed to think i was trespassing on their revire by entering the yard to get to the flats ..
07:33:05 <shapr> heh
07:33:30 <ski> (shapr : btw, epic/epi = epimorphism, monic/mono = monomorphism)
07:33:45 <shapr> hah
07:34:04 <shapr> I was thinking of epic versus classic, as in "this book is an epic" or "this book is a classic"
07:34:13 <shapr> I completely missed the morphism joke :-)
07:34:18 <ski> it's actually a bit scary when they come diving towards you from high altitude ..
07:34:23 <shapr> yes, I agree
07:34:28 <shapr> wait, the joke? or the birds? ;-)
07:34:35 <ski> birds
07:34:36 <ski> :)
07:35:09 <JaffaCake> there was a story in the news in the UK recently about a buzzard attacking cyclists by dive-bombing
07:35:19 <ski> (this irc client seems to be called epic or something like that ..)
07:35:39 <shapr> the bomb itself was particulary unappreciated in my case
07:36:10 <JaffaCake> hehe
07:36:25 <SyntaxNinja> shapr: did it actually hit you?
07:36:31 <shapr> yes, the bird was quite accurate
07:36:41 <shapr> I was at least miffed.
07:36:42 <vegai> ski: http://www.epicsol.org might help you brighten it up
07:36:53 <shapr> on the other hand, buzzards are big!
07:36:56 <Igloo> Jaffa: I was told by the gcc guys that the Debian package version I was build-depping on fixes the bug in http://gcc.gnu.org/PR7871 which is the one you were refering to I think?
07:36:58 <shapr> that must be really scary
07:37:43 <Igloo> I'm doing a build with 3.3.4 now to see if that works. It mentioned a sparc ICE in the changelog so there is hope...
07:37:52 * ski remembers some game in which one plays a bird and bombs people and cars on a street, also landing and eating some kind of food when there's red signals for the cars ..
07:38:33 <shapr> that sounds like a fun game
07:38:37 <SyntaxNinja> JaffaCake: speaking of the .command stuff, what would you think about having some more file handling utilities in one of the libraries, stuf flike "getExtension :: FilePath -> String" and "getFilename :: FilePath -> FilePath", "findBinary" (to search the $PATH variable), "pathJoin :: [FilePath] -> FilePath", and better copy support?
07:38:42 <SyntaxNinja> some of this is implemented for cabal
07:39:19 <ski> shapr : the cars can crash and such if you manage to bomb the front window correctly ..
07:39:26 <shapr> hah
07:39:27 <JaffaCake> sure, we should definitely have a library of that stuff
07:39:36 <JaffaCake> the tricky bit is keeping the interface portable
07:39:36 <Marvin--> SyntaxNinja: I've been wanting that for ages
07:39:38 <SyntaxNinja> I also find my self using "createDirIfNotExist" function which creates directories and its parents.
07:39:54 <SyntaxNinja> OK cool.  I'll do my best to package this as a library then :)
07:39:55 <JaffaCake> yup, we have that in GHC too
07:40:11 <SyntaxNinja> some of it is portable, some of it is posix
07:40:28 <SyntaxNinja> and putting it in the standard library will help all of us find a portable interface :)
07:40:32 <JaffaCake> then it should probably be two libraries...
07:40:38 <Marvin--> Python's os.path module works quite well
07:40:39 <SyntaxNinja> ok
07:40:45 <SyntaxNinja> ooh, I'll look at that.
07:40:56 <JaffaCake> we could add the portable stuff to System.Directory perhaps
07:41:01 <Igloo> Jaffa: Oh, when building ghc, if the current ghc uses gcc-2.95 but the compiler being built uses gcc-3.3 then will object files using the different compilers be linked?
07:41:31 <JaffaCake> Igloo: probably not
07:42:00 <JaffaCake> they shouldn't come into contact, anyway.  If they do it's probably a bug
07:43:43 <ski> la
07:43:54 * ski 's leaving now
07:44:06 <ski> bye
07:44:20 <shapr> bya!
07:44:20 <ikegami0> see you ;)
07:44:28 <ski> mm
07:45:25 <Marvin--> SyntaxNinja: stuff like python's expanduser and expandvars would be neat too
07:45:32 <Marvin--> but I might as well implement those myself
08:01:59 <shapr> echo '\nalias cvs=echo "cvs is so insecure it has been removed from this host"' >> /etc/bash.bashrc
08:02:31 * shapr adds a line about using darcs instead
08:02:55 <ikegami-> hehe
08:03:30 <Marvin--> yay, case expressions nested in case expressions
08:03:40 <Igloo> I don't think I'd put money on darcs being secure, nor GHC's RTS
08:05:13 <SyntaxNinja> Igloo: well, it was cvs's server that was broken, right?  darcs doesn't have such a component, which is probably a good thing.
08:05:26 <shapr> Igloo: it's going to be hard to find as many big security holes in darcs + GHC as in cvs
08:05:44 <ibid> don't count on it
08:05:48 <shapr> cvs has a long history of r00t exploits
08:06:09 <ibid> GHC runtime is probably fairly complex and not designed for security
08:06:29 <shapr> hopefully some patches will come out of galois for that
08:06:43 <ibid> of course, darcs does not need root :)
08:06:45 <ibid> galois?
08:06:49 <shapr> galois connections
08:06:54 <ibid> ?
08:07:01 <shapr> rumor has it that they have rewritten the RTS in Haskell for auditing purposes
08:07:18 <ibid> ok
08:07:49 <shapr> another rumor says they're doing it for a very large customer who may possibly want a full proof of security from GHC
08:08:08 <Igloo> Ouch
08:08:32 <shapr> then there's the rumor about the Simons having access to extra-terrestrial technology, but I'm not so sure of that one.
08:08:39 <ibid> :)
08:08:53 <shapr> see, I *knew* GHC was advanced technology!
08:09:00 <Igloo> I'd like to see the proof of correctness of the evil mangler  :-)
08:09:07 <shapr> scary thought
08:09:16 <Igloo> And you'd need a proof of correctness of gcc first, of course
08:09:37 <shapr> I think that was the idea behind a pure Haskell version
08:09:40 <ibid> Igloo: unless you use the native code generator
08:10:27 <Igloo> Yeah, if you restrict it to that it becomes a little less daunting. Still non-trivial I suspect, though
08:10:31 <shapr> anyway, it's all vaporware until I can download it.
08:11:32 <shapr> oh, Igloo, any random input on http://www.scannedinavian.org/AvianWiki/TemplateHaskellTutorial ?
08:11:56 <Marvin--> http://www.mdstud.chalmers.se/~md9ms/Stuff.hs ... comments, anyone?
08:12:08 <Igloo> Why isn't it on hawiki?
08:12:21 <shapr> because I just started it last night, and wasn't sure how far I was going to get :-)
08:12:32 <shapr> I'll move it over now.
08:13:44 <Igloo> Marvin: Do you mean $4A to mean ${4A}?
08:14:07 <Igloo> And ${{} to be the variable with name {?
08:14:12 <shapr> oh, I had a question about lift also. Is it feasible to lift functions as well? or just values?
08:14:40 <Marvin--> Igloo: I haven't really given that much thought to it
08:14:57 <shapr> I got hung up on defining AddTH, I couldn't figure out how to define it
08:14:59 <shapr> :-/
08:15:24 <Igloo> It seems odd the last two lines aren't liftM (v++) expandVariables ws
08:15:34 <Igloo> I'm not really sure what you were asking, though
08:15:52 <Marvin--> ooh, good point
08:16:31 <Igloo> shapr: You have some lower case letters starting sections
08:16:50 <shapr> ok
08:18:01 <Igloo> And a splice is a $ immediately followed by an atomic expression, it doesn't have to be $( ... ). e.g. it can be $foo
08:18:01 <Marvin--> how *is* $4A supposed to be handled?
08:18:04 <Marvin--> can you even setenv "4" "foo"?
08:18:39 <Marvin--> likewise, I don't know the correct way to handle ${{} so I'm leaving it undefined ;)
08:19:28 <Igloo> shapr: I'd use qIO (or whatever it's called in 6.2.1) rather than Q. And I'd probably use do notation too, but that one's more a style thing
08:20:15 <shapr> will the 6.3 version be out soon? should I be writing for it instead?
08:20:23 <Igloo> I'm not sure without looking at the spec whether 4A or } are valid variable names. 4 is certainly used in shell scripts as a variable name but zsh won't let me assign it a value
08:21:52 <Igloo> 6.4, and I don't think it's particularly imminent
08:23:09 <Igloo> "it works just like Quasi-Quotes" is a bit misleading I'd say
08:23:10 <shapr> ok
08:23:19 <Igloo> And your English generally isn't great, I think  :-)
08:23:19 <shapr> how is it different?
08:23:36 <shapr> bah, I speak American! (actually, mostly swedish lately)
08:23:40 <Igloo> lift (3 + 4) is equivalent to [| 5 |] for example
08:24:02 <Igloo> I believe even American English frowns on run-on sentences  :-)
08:24:03 <shapr> feel free to correct anything you see
08:24:07 <shapr> yah, that's true
08:24:26 <shapr> so does swedish
08:24:35 <shapr> I think only german encourages run-on sentences.
08:25:06 <neologism> what is "run-on" sentence/
08:25:07 <neologism> ?
08:25:32 <shapr> when you don't refactor your words
08:25:43 <shapr> hiya ralf, how's code?
08:25:56 <Igloo> Where you separate two separate sentences with a comma
08:26:05 <ralf> hi.  I'm ralf. 
08:26:09 <ralf> Code's okay. 
08:26:09 <shapr> nice ta meetcha ralf
08:26:18 <ralf> likewise.  Friend of syntaxninja. 
08:26:26 <shapr> aha, you're an Ohioite.
08:26:27 <ralf> actually, I have to go, but I'll be back in an hour and a half. 
08:26:28 <shapr> ?
08:26:31 <shapr> ok, cya ralf
08:26:34 <ralf> I'm meeting syntaxxe for lunch. 
08:26:35 <neologism> shapr: ie. ifyouspeaklikethis ?
08:26:38 <ralf> Yeah.  Ohio. 
08:26:59 <ralf> Am on page 60 of Haskell SOE.
08:27:23 <shapr> neologism: no it's where you have a sentence ending with a comma, you should really end your sentences with periods.
08:27:26 <Igloo> Does stringL exist? If so you should probably use it where you are otherwise using all smart constructors
08:27:46 <shapr> ralf: spiffage
08:27:59 <ralf> cya.  
08:27:59 <shapr> Igloo: yes it does
08:28:00 <shapr> good point
08:28:03 <Igloo> Oh, and wildP
08:28:24 <Igloo> You also don't demonstrate pattern matching on constructors
08:29:19 <shapr> well, I just got started last night :-)
08:29:32 <shapr> I got stopped on writing AddTH
08:29:37 <shapr> addTH = lamE [varP "x",varP "y"] lift((varE "x") + (varE "y"))
08:29:49 <shapr> what's wrong with this picture? ;-)
08:30:21 <shapr> I can see app, and I know I can use it to apply one Exp to another, but I haven't yet figured out where to go from there
08:30:23 <Igloo> Sure, looks good other than that. Sorry, didn't mean to be too negative  :-)
08:30:34 <shapr> oh, I'm happy to get constructive criticism :-)
08:30:44 <Marvin--> huh, twisted has been orphaned
08:30:48 <shapr> what??
08:30:51 <shapr> oh, the deb
08:30:52 <Igloo> Oh, the other thing you've left out, which is quite important, is writing actual template programs using $ inside of [| |]
08:31:00 <Marvin--> http://bugs.debian.org/254796
08:31:21 <shapr> yes, I wanted to get to mixing $ and [| |], but I haven't gotten there yet myself :-)
08:31:35 <Igloo> Reading up, you want to lift a function, right? That's not possible
08:31:53 <shapr> writing the tutorial is a good way for me to get to the point of really using TH.
08:32:00 <Igloo> And there are a number of things wrong with that picture  :-)
08:32:10 <shapr> which picture?
08:33:03 <Igloo> [| \x y -> x + y |]   and   lamE [varP "x",varP "y"] (infixE (Just $ varE "x") "+" (Just $ varE "y"))  (or something imilar - are names really strings in 6.2.1?) ought to do it
08:33:14 <Igloo> The one you just asked what is wrong with
08:33:21 <shapr> oh, heh
08:33:50 <Igloo> Your code was missing aprens around lift and requires ExpQ to be an instance of Num
08:33:53 <shapr> ohh, infixE "+"
08:34:03 <Marvin--> heh, "lamE"
08:34:04 <shapr> I shoulda thought of that
08:35:12 <Igloo> Generally the (smart) constructors should be a last resort, though - quasi-quotes are much nicer to write and read
08:39:21 <shapr> Igloo: you think I should mention the smart constructors lateron?
08:40:12 <Igloo> I thin the Template programming bit should be before them; they're already at end aren't they?
08:40:24 <shapr> ok, sounds good
08:41:15 <shapr> what's the difference between quasi-quotes and lift?
08:41:20 <shapr> oh, you just showed me that
08:42:32 <Igloo> lift lifts values, quasi-quotes quote code
08:48:12 <Igloo> Can anyone who would like to be on a Haskell Debian mailing list if one were to exist message me an e-mail address please?
08:49:27 <SyntaxNinja> Igloo: are you going to make one yourself, make it on d.org or make it on h.org?
08:49:40 * SyntaxNinja would prefer debian.org
08:51:33 <Igloo> John Goerzen just asked if there was one on debian-devel, which is what motivated me to get around to it. I was going to make it myself (well, ask someone who can more easily to do so) as it is simplest. If you want to get it created on one of those then that's fine, but I don't have the energy to do so
08:53:49 <Igloo> But can you tell me now if you're going to do so please as I won't bother if you're going to  :-)
08:55:52 <Igloo> Hmm, actually he asked about a "group", but I'm not sure what he meant by that
09:11:50 <Marvin--> http://craphound.com/msftdrm.txt <- very good read
09:19:05 <shapr> Marvin--: nice doc
09:21:05 <shapr> really nice doc
09:23:26 <ozone> die language shootout, die in the arse
09:24:08 <shapr> die in the arse?
09:24:17 <ozone> that's an australianism
09:25:06 <ozone> translated to non-aussie, it means "die a horrible, shitty death"
09:26:01 <shapr> ah, I understand that.
09:26:15 <ozone> (see my post to haskell list for some context)
09:27:01 <Marvin--> ozone: nice rant :)
09:28:00 <ozone> well, thought i had to write it.  the question was just too leading :)
09:28:34 <Marvin--> "So when your French DVD won't play in America, that's not because it'd be illegal to do so: it's because the studios have invented a business-model and then invented a copyright law to prop it up."
09:29:15 <shapr> ozone: nice
09:29:24 <Marvin--> "in Norway the studios put the local fuzz up to bringing him up on charges of *unlawfully trespassing upon a computer system.* When his defense asked, "Which computer has Jon trespassed upon?" the answer was: "His own.""
09:29:26 <Marvin--> this is priceless
09:31:10 <ozone> ok, sleeptime
09:31:12 <ozone> noight!
10:08:27 <SyntaxNinja> Igloo: idono... I don't care that much.
10:14:55 <jemfinch> ozone: what's the Haskell list where I can read your rant?
10:34:06 <stepcut> scary: http://info.linspire.com/RunLinspireSong/RunLinspire.swf
10:38:20 <Marvin--> sheesh
10:39:27 * shaleh is happy he does not have sound on this machine, nor a flash player
10:39:41 <jemfinch> Marvin--: do you know where the Haskell mailing list where ozone posted his rant is at?
10:39:59 <Marvin--> jemfinch: haskell@haskell.org?
10:40:30 <jemfinch> is there a web interface?
10:40:36 <Marvin--> http://haskell.org/mailman/listinfo/haskell
10:40:45 <jemfinch> ah, thanks :)
10:40:51 <SyntaxNinja> google "haskell mailing list archive"?
10:41:54 <shaleh> rant?
10:42:23 <jemfinch> shaleh: he said he ranted about the shootout.
10:42:26 <jemfinch> I think this is it: http://www.haskell.org//pipermail/haskell/2004-June/014215.html
10:42:38 <Marvin--> shaleh: re the revival of the shootout
10:43:10 <shaleh> ah
10:43:53 <vegai> I don't get his second paragraph
10:44:08 <vegai> especially "That's about it." after exaplining few very important points
10:46:04 <shaleh> vegai: in rants, one is allowed to be loose with the english language. it creates a better sense in the reader that the author is writing from a hightened emotional state.
10:46:23 <vegai> I'm not saying his language is poor
10:46:30 <shapr> bah, english sucks
10:46:30 <shaleh> if these were reasoned discourses, the term "rant" would not be applied to them.
10:46:42 <shapr> er, "fan, engelska suger"
10:46:56 <vegai> englantihan on kaunis kieli 
10:46:58 <shapr> "viitu, americalainen... " oh never mind
10:47:09 * vegai chuckles.
10:47:18 <vegai> that's double-t and "amerikkalainen"
10:47:24 <vegai> (not double-i)
10:47:29 <shapr> vegai: I'm buying into finnish humor lately, check out my humor section for today: http://shapr.homelinux.net/~shae/blog/2004-06-17.html
10:48:23 <shapr> vegai: oh, can you tell me what this one says? it looks totally bizarre: http://shapr.homelinux.net/~shae/LOL.jpg
10:49:01 * vegai laughs.
10:49:22 <vegai> "... that was my coke!"
10:49:26 <shapr> haha!
10:50:48 <shapr> oh, mun is short for minun?
10:50:49 <SyntaxNinja> "... Give me that damn camera!"
10:50:56 <vegai> slangy short
10:50:59 <shapr> ah, ok
10:52:01 <shapr> I think the frustrated blond chick has the perfect frustrated expression
10:52:28 <shapr> right, back to ranting :-)
10:52:38 * SyntaxNinja looks aroudn for blond chick
10:52:46 * SyntaxNinja guesses he should be looking in Sweden
10:52:51 <shapr> does anyone know how to call the TeachYourself.hs part of Aarne Ranta's Grammatical Framework?
10:52:57 <shapr> SyntaxNinja: in my latest blog entry
10:53:05 <shapr> SyntaxNinja: http://shapr.homelinux.net/~shae/blog/images/saatana.jpg
10:53:20 <SyntaxNinja> oh... I noly read blogs with RSS.  i really would read yours, though!
10:53:26 * shapr sniffles
10:53:31 <shapr> ok ok! I give in!
10:53:35 <shapr> I'll convert to BLob!
10:58:11 * shapr has the urge to go unicycling again.
10:58:19 <shapr> now that I have a clean shirt on...
11:00:37 <shaleh>  multilinguality <-- great word.
11:06:02 <jemfinch> shapr: so have you written anything else about Haskell?
11:07:26 <shapr> not that I can think of, what do you want to read?
11:08:01 <shapr> I'd be happy to hold forth at interminable length about the advantages of Haskell if you want :-)
11:08:50 <Marvin--> oh dear, now you've done it ;)
11:08:58 <jemfinch> your thoughts on Monads, compared to objects.
11:10:26 <shapr> eek, the wiki is gone?
11:10:31 <shapr> Ward's Wiki?
11:11:02 <shapr> half my brain has just disappeared :-(
11:11:19 <shapr> I was going to refer to Alistair Bayley's comments on the definition of OOP
11:12:23 <shapr> oh, I see someone wrote a spam script
11:12:34 <Marvin--> a "spam script"?
11:12:43 <jemfinch> shapr: Alistair Bayley?  I've not heard of him.
11:13:05 <shapr> Marvin--: yah, wiki spam is becoming common, look at this: http://c2.com/cgi-bin/quickChanges
11:13:58 <shaleh> shapr: yeah, looks like we need to go back to approved logins having permission.
11:13:58 <Marvin--> I guess it was just a matter of time before wikis would be abused
11:14:15 <shapr> it's sad :-(
11:14:26 <shapr> but I know the fix! sort of...
11:14:29 <Marvin--> much of what humans do is :)
11:14:36 <shapr> filesystem based wikis that are pull-only
11:14:41 <Marvin--> I forwarded another nigeria spam to the police today
11:15:32 <Marvin--> what was particularly scary about it was that they had taken the effort to pair up my name with my email address and use the same surname in the spam
11:15:47 <shapr> jemfinch: Alistair wrote some interesting stuff on http://c2.com/cgi/wiki?FpVsOo
11:15:49 <Philippa> jemfinch: my own view on monads and objects is that monads as used in Haskell seem to be a generalisation of classes in OO, albeit not reached that way
11:16:12 <shapr> oh, I want to hear Philippa's views
11:16:16 <shapr> she's smarter than me
11:16:22 <Philippa> heh
11:16:28 <Philippa> nah, I just figured I'd butt in :-)
11:16:42 <shapr> I really do want to hear what you think :-)
11:16:57 <Marvin--> so the subject was "To Martin Sjogren, Urgent Response." and the mail talked about some (fictitious) Williams Sjogren
11:17:20 <Marvin--> THEY'RE OUT TO GET ME!
11:17:34 <shapr> my spam filter flushes any email with urgent in the title
11:17:35 <Philippa> I think the way I reached this was that around when I was starting my degree I was beginning to think of class design as being like designing a mini-language - one defined by the semantics of the operations you can perform on objects of that class
11:17:37 <shapr> er subject
11:17:49 <shapr> yah, I agree with that
11:17:56 <Marvin--> shapr: yes, bea mentioned that in her EP talk :-)
11:18:00 <shapr> that fits my thoughts on humane interface and significant names
11:18:02 <shapr> Marvin--: bah :-)
11:18:25 <shapr> like, desiging OOP classes such that they're all subject.verb()
11:18:33 <Marvin--> anyway, I don't want to filter the nigeria fraud mails, I want to send them to the police, I want the bastards caught, convicted and preferrably quartered
11:18:40 <shapr> sounds good to me
11:18:52 <Marvin--> (well, perhaps not quartered)
11:19:08 <Philippa> to be able to treat a computation as an object, all you "really" need is a runFoo that returns both the state of the computation at that point (if it has any) and the result - you file the state away then fling more commands at it as appropriate
11:19:40 <Marvin--> embedded languages
11:20:01 <Marvin--> that's how Koen introduced monads in his advanced functional programming course over here
11:20:06 <Philippa> so you can get something scarily object-like by dumping all that on top of something like the ST monad in which you keep any intermediate stuff - in fact that way you get object-to-object communication, 'cos instead of the one state you can return the changes for everything involved
11:20:38 <Philippa> that's a good intro IMO, far better than the one gmh uses
11:21:17 <Philippa> oh, and I agree not quartered - 'stoo quick
11:22:06 <shapr> jemfinch: see the wisdom I just pasted at the bottom of http://www.haskell.org/hawiki/HaskellIrcPastePage
11:22:27 <shapr> Alistair mentioned some very interesting points
11:22:51 <shapr> the closures/objects dichotomy is spiffy
11:23:19 <shapr> one of the things I prefer about using closures as a poor man's objects is that immutable closures can only get simpler
11:23:22 <earthy> ozone seems to think strongly about the programming language shootout
11:24:07 <SyntaxNinja> I wish ozone wouldn't pull hi punches ;)
11:24:10 <stepcut> math nerds: Is there a 'mathematical notation' that might be good for representing process pipelines -- stuff like: 'ls -l | grep whee 2>&1'. Something that does not use < > >> and other things that have different meanings in haskell already ? I realize this is a bit of an open ended suggestion... just looking for ideas
11:24:41 <shapr> even with something as simple as a function that sorts a list of three tuples by your choice of first, second, or third part of the tuple, you can use partial application to have a pretend sorting object
11:24:54 <Lemmih> http://shootout.alioth.debian.org/bench/regexmatch/?? GHC 194 times faster than GCC?
11:24:56 <Philippa> stepcut: most of that stuff seems suspiciously like function application to me
11:25:20 <shapr> sortOn (\_ x _ -> x) becomes sortSecond
11:25:21 <Philippa> Lemmih: could be if the C regex implementation's lame
11:25:29 <earthy> stepcut: sounds like arrows are a perfect fit
11:25:46 <Philippa> earthy: point, yeah :-)
11:26:05 <stepcut> earthy: ALMOST!
11:26:20 <earthy> why not completely?
11:26:28 <shapr> but the difference between an immutable closure and an object is that the object has an infinite fan of "future possibilities" and the closure can only get simpler
11:26:45 <stepcut> earthy: because I can not figure out how to define 'arr' with out Read/Show constraints
11:26:46 <shapr> for me at least, immutable + closure is easier to think about
11:27:04 <shapr> same for pure FP keeping all the state in one place, rather than breaking it up into each class instance
11:27:07 <earthy> just a sec...
11:27:19 <stepcut> earthy: same problem Hughes had when he tried to do the CGI stuff with arrows
11:27:22 <shapr> stepcut: |> |>> <| ?
11:27:27 <shapr> they're pipes, right?
11:27:50 <shapr> oh hey, I got to hear Hughes actually describe the CGI problem in person
11:27:56 <shapr> that was spiffy :-)
11:28:13 <Philippa> shapr: I'm tempted in some current code to pass STRefs to state along, though that seems essentially-as-good in that you've still got all the state showing up in function types
11:28:14 <stepcut> shapr: hrm, that could work -- what would be good for just a standard | ?? 
11:28:32 <Philippa> is || in use?
11:28:40 <shapr> yes, all over
11:28:48 <shapr> it's logical or bitwise or, I forget which
11:28:54 <stepcut> as is |||
11:28:58 <shapr> as in, && || etc
11:29:06 <shapr> right, ||| is friends with +++ etc
11:29:19 <stepcut> i think |-> is also in use
11:29:23 <Philippa> ah, couldn't remember if that was one of the C-like operators I tripped up on not having at first (! being the major one)
11:29:46 <shapr> stepcut: maybe -|- ?
11:29:48 <stepcut> though, I might not need it, | might actually be >>=
11:30:00 <Philippa> very likely, I would've thought
11:30:08 <shapr> jemfinch: still there?
11:30:28 <stepcut> Philippa: that was my first thought
11:30:41 <shapr> Alistair's point about Haskell not having object identity was a real epiphany for me
11:31:39 * stepcut goes back to designing 
11:32:19 * shapr hOps
11:34:13 * earthy ponders about the trouble with arr
11:34:20 <earthy> and doesn't see it
11:34:49 <shapr> with CGI it was that saving required that the values be instances of Read and Show
11:35:02 * earthy nods
11:35:10 <shapr> to get that to work, you have to put it into the Arrow typeclass
11:35:18 <shapr> you can't put it into the data type itself
11:35:39 <stepcut> with Process arrows, the only way to get things to and from a process is via file handles, which implies strings...
11:35:42 <shapr> data (Read a,Show a) => myCGI a = ...
11:36:03 <shapr> there is constructor syntax that looks like that, but it does something else
11:36:43 <earthy> stepcut: either that or through a conversionfunction that encapsulates the read and show dependency
11:36:59 <shapr> John Hughes suggested extending the datatype syntax such that you could constrain the parameter to a parameterized datatype, but that ended up passing lots of empty dictionaries
11:37:02 <shapr> though I forget exactly why
11:37:29 <shapr> anyway, John Hughes is a great lecturer
11:38:04 <shapr> jemfinch: ping?
11:38:08 <stepcut> earthy: well, the wrapper function would still have to do something sensible for all the data types that are not Read/Show -- but I am not sure what that would be?
11:40:22 <earthy> write empty strings? or something like [unrepresentable]
11:40:31 <earthy> reading is impossible, obviously
11:41:13 <shapr> I had a bunch of random questions about GF, arrows, QuickCheck, etc that I forgot to ask Aarne Ranta and John Hughes
11:41:36 <stepcut> earthy: maybe, that introduces run-time 'errors' that should really be caught at compile time
11:41:55 <earthy> in that case the Read/Show restriction is something you *want* to have
11:42:06 <earthy> I still don't see the problem, really
11:42:17 <shapr> I don't want my shell to pass things as a list of lines
11:42:27 <shapr> I'd much rather it could pass non-linear algebraic datatypes
11:42:41 <shapr> like a tree
11:42:55 <shapr> or a DAG, or whatever
11:42:56 <stepcut> earthy: yep. But I can't place a Read/Show restriction on the 'arr' function if I use the standard Arrow classes
11:43:36 <stepcut> shapr: well, its not just the shell, its the applications your are calling... like grep, ls, etc
11:43:44 <shapr> right, they suck too :-)
11:43:50 <stepcut> shapr: I don't actually intend to involve bash in this at all
11:43:54 <earthy> shapr: have you ever seen Arjan van Weelden's Esther shell?
11:44:01 <shapr> no, does it suck less?
11:44:35 <earthy> stepcut: yes. a conversionoperator. so that arr doesn't get the restriction, but you simply have to add conversions at the appropriate places
11:44:35 <shapr> aha --> http://www.cse.unsw.edu.au/~pls/thesis-topics/functionalshell.html
11:45:28 <stepcut> earthy: hrm, so instead of calling 'arr' I would do something like:  (arr . conv)
11:45:35 * earthy nods
11:45:51 <Marvin--> arrrr
11:45:59 <shapr> Lunar^: oh, you should read this
11:46:00 <shapr> @arr
11:46:00 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
11:46:05 <stepcut> earthy: I will have to investigate that .. might work
11:46:58 <shapr> earthy: neat stuff!
11:47:16 <earthy> quite
11:47:52 <shapr> ok, I'm convinced
11:47:57 <shapr> let's write one for hOp
11:48:03 <shapr> along with a type-checked 'file-system'
11:48:15 <earthy> :)
11:48:20 <stepcut> hehe
11:50:24 <earthy> orthogonal persistence. whee
11:50:33 <stepcut> mmm, orthogonal persistence
11:50:45 <shapr> orthogonal (bounce) persistence
11:51:47 <earthy> capability-based access control
11:51:57 <shapr> capability arrow
11:52:13 <earthy> I'll stop dropping useful buzzwords now
11:52:26 * stepcut is working on a capabilities based website (though, its arguable a fine grained ACL system)
11:52:53 <vegai> will there be synergy?
11:53:33 <shapr> monergy!
11:55:55 <stepcut> earthy: ok, so currently my arrow is based on the following data type:
11:55:56 <stepcut> data TypedFd t = TypedFd Fd
11:55:59 <stepcut> data Process i o = Process (IO (ProcessID, TypedFd i, TypedFd o))
11:56:53 <stepcut> so, 'arr' needs to take a function of type (b -> c) and return an Arrow of type (Process b c)
11:58:43 <earthy> impossible.
11:58:53 <earthy> given your data Process
11:59:04 <stepcut> so, arr needs to some how apply f to a Fd discriptor and convert the return value to a file descriptor
11:59:30 <stepcut> earthy: agreed.
11:59:31 <SyntaxNinja> If I want to say "continuous" but turn it into a noun, do I say "continuity" or "continuousness"?
12:00:01 <Riastradh> Continuity.
12:00:10 <stepcut> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=continuous&x=23&y=11
12:00:26 * earthy nods to continuity
12:00:47 <earthy> but why do you want to have the associated noun?
12:01:12 <SyntaxNinja> I'm listing properties of something
12:01:15 <stepcut> merriam-webster claims: continuousness noun 
12:01:38 <Riastradh> Webster was a dork.
12:01:41 <stepcut> hehe
12:01:55 <Marvin--> Riastradh is eloquent as usual :)
12:02:58 <earthy> the cambidge advanced learner's doesn't come up with continuousness
12:03:03 <earthy> +r
12:03:17 <SyntaxNinja> what's a guy to do...
12:03:36 <shapr> learn swedish!
12:04:15 <stepcut> earthy, my idea for using arrows was to have to fork off each process (or function), and use the arrow syntax as a mechanism to hook all the fd descriptors together. So, once everything is off and running, "haskell" just waits around for it to finish
12:04:50 <SyntaxNinja> stepcut: I'd like to see that if you succeed :)
12:04:50 <earthy> stepcut: and do you want to inject functions into such a pipeline?
12:05:00 <earthy> (which is what arr would do)
12:05:17 <stepcut> earthy: yes, but that is pretty simple -- with the Read/Show contraint
12:05:41 <earthy> which you can't put on arr itself
12:05:45 <earthy> annoyingly
12:05:51 <stepcut> yeah
12:09:45 <earthy> hm. I'm not awake enough to really help there
12:10:16 * Riastradh sneaks up behind earthy, stabs him with a hypodermic needle, and injects adrenaline directly into his bloodstream.
12:10:45 <shapr> grr, I can't figure out why GF won't work :-(
12:10:49 <shapr> I want to use it to study swedish!
12:10:51 <stepcut> earthy: not sure if there is a solution
12:11:02 <earthy> thanks, I needed that. now I can work on my article again. :P
12:11:18 <earthy> I thought GF was your boss, shapr?
12:11:29 <shapr> heh
12:11:33 <shapr> oh, I figured it out, I think
12:11:34 <earthy> ;P
12:11:40 * shapr tries the windows solution
12:12:30 <shapr> gwahr
12:12:37 <shapr> at least I fixed part of it
12:13:21 <Marvin--> earthy: hahaha
12:13:24 <earthy> stepcut: I can see 2. one is to simply disallow using Haskell functions in the middle of process pipess 
12:13:27 <earthy> qs
12:14:08 <stepcut> earthy: so what would arr do then?
12:14:28 <earthy> take the function and generate the id process, ignoring the function itself. :)
12:14:41 <stepcut> :p
12:14:42 <Marvin--> yuck
12:15:19 <earthy> the other is somewhat impossible, in Haskell, if I'm right
12:15:50 <earthy> it'd need full dynamics, serializable to disk, and the possibility of spawning a process with such a dynamically written function.
12:20:23 * shapr swears fiercely
12:20:49 <shapr> what's the easy way to do a search and replace in a bunch of file at the same time?
12:21:40 <shapr> gahr, GF only looks for files with lowercase names even if they're specified with uppercase letters.
12:22:54 <shapr> oh, no, user erro
12:22:55 <shapr> r
12:23:01 <Marvin--> ohno
12:23:44 <Marvin--> oh look, the Italians finally got a goal
12:24:23 <Hyp3rion> for i in $(ls ...); do mv $i $i~; cat $i~ | perl -pe 's/.../...' > $i; done
12:24:40 <Hyp3rion> what is GF?
12:25:00 * shapr sees the challenge in rewriting that in Haskell :-)
12:25:05 <shaleh> shapr: I tend to use perl -pie for that kind of thing.
12:27:10 * shapr writes an email to Aarne in Swedish
12:31:23 <shapr> Hyp3rion: http://www.cs.chalmers.se/~aarne/GF/
12:31:27 <shapr> the Grammatical Framework
12:31:57 <shapr> which I would like to use to study Swedish. It might also be fun to plug it into WASH for a free online morphology test
12:32:53 <Marvin--> <Alanna> Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders
12:32:55 <shapr> for example, in english you say the plural is almost always the same:"dog, dogs" in swedish it's dependent on the article.
12:33:01 <shapr> Marvin--: yowch!
12:33:13 <Marvin--> below-the-belt humor, yay :(
12:33:18 <Philippa> Marvin--: you mean Java works nicely if you've got something to ease the pain?
12:33:24 <shapr> haha!
12:33:38 <shapr> so: bil bilar, and hus hus in Swedish
12:33:45 <Philippa> hrmm, any suggestions for what LUBE could stand for as a java extension?
12:33:50 <shaleh> Marvin--: nice analogy
12:34:02 <shapr> Hyp3rion: anyway, I'm sure that's way more information than you really wanted :-)
12:34:11 <Marvin--> I wonder if that's the Alanna I know
12:34:16 <Marvin--> or someone else
12:34:22 <shaleh> Lightweight Ultramodern Blog Extension?
12:35:00 <shaleh> Large Uncomfortable But-plug Extension?
12:35:10 <shapr> eek
12:35:52 <Hyp3rion> shapr - no! 8) i just dont know swedish and haskell
12:36:06 <shapr> Hyp3rion: no problem! they're both easy to learn.
12:36:16 <Hyp3rion> laser user-blaster extreme
12:36:25 <shapr> oh, it's freslog, not freslg
12:36:34 <shapr> this is why I need GF!
12:36:38 <Hyp3rion> yay s/user/ber/
12:37:27 <Marvin--> on the contrary, Swedish is quite hard to learn, I've heard :)
12:37:45 <shapr> Marvin--: there's a very easy introduction that makes Swedish incredibly easy...
12:38:06 <shapr> take a finnish course!
12:38:10 <Marvin--> heh
12:38:17 <Hyp3rion> is swedish like finnish?
12:38:26 <shapr> after that, you have enough perspective to separate easy from hard.
12:38:28 <Hyp3rion> i'm hungarian. and it's quite like finnish...
12:38:50 <Hyp3rion> >_<
12:39:01 <shapr> really?
12:39:10 <shapr> I thought Hungarian was a slavic language?
12:39:16 * shapr is not a linguist
12:39:32 <Marvin--> Swedish and Finnish have little in common
12:39:34 <Hyp3rion> same language family... uralic / finnougric or how is it in english...
12:39:53 <shapr> yah, that's it
12:40:28 <shaleh> shapr: looking for hot blonde women?
12:40:35 <Hyp3rion> oh! but swedish is germanic
12:40:39 <Hyp3rion> :-(
12:41:09 <shapr> shaleh: er, huh?
12:41:22 <shapr> shaleh: I live in Sweden, there're everywhere here.
12:41:25 <shaleh> shapr: a reason to learn swedish
12:41:42 <shapr> oh, I just want Swedish for useful stuff like talking to Swedes.
12:42:02 <shaleh> shapr: you part of the finnish minority in sweden?
12:42:05 <shapr> or maybe even understanding them
12:42:14 <shapr> nope, I'm part of the Alabamian minority in Sweden.
12:42:49 <shapr> you're in .au, right?
12:42:59 <shaleh> shapr: no, I am .us as well
12:43:02 <shapr> ah, ok
12:43:19 <shaleh> currently living in silly valley, formerly of Virginia.
12:43:26 <shaleh> What part of alabama?
12:43:32 <shapr> the big city
12:43:37 <shaleh> ah
12:43:39 <shapr> Birmingham
12:43:51 <shaleh> I used to live about an hour north west of there
12:44:14 <shapr> there's a lot of empty land thataway
12:44:21 <shaleh> indeed
12:44:43 <shapr> unless you take the rush-hour traffic into your time count, in which case you might be talking about Inverness.
12:44:50 <shaleh> Jasper
12:44:54 <shapr> oh :-)
12:45:35 <shaleh> my mom was married to a cracker when I was younger.  Made us live in that hell whole for about 18 months.
12:45:55 <shapr> So, I'm a country boy who left the big city and moved to the Arctic Circle.
12:45:58 <shapr> a cracker?
12:46:17 <shapr> safe cracker, box cracker, or what?
12:46:21 <Philippa> shapr: how does brum there compare to brum in the UK?
12:46:33 <shapr> Philippa: I'd be happy to tell you if you tell what brum is.
12:46:41 <Philippa> birmingham
12:46:44 <shapr> ohh
12:46:54 <shapr> it's b'ham where I grew up
12:47:07 <shapr> burminhayum
12:47:30 <Philippa> 'scloser to burmin'um here
12:47:49 <Hyp3rion> brum is the sound hungarian bears make :-/
12:48:17 <Philippa> the sound cars and motorbikes make here if you're about 5 years old
12:48:33 <Philippa> I think there was a series of kids' books or something
12:48:41 <Hyp3rion> same ;-)
12:49:29 <shaleh> shapr: how can you be from birmingham and not know what a cracker is (-:
12:49:52 <shapr> well, it can also be a name for someone of very light skin
12:50:26 <shapr> but it's not very complimentary in that case
12:50:32 <shaleh> shapr: or a derisive term to denote someone who is a good ole boy and believes women should be barefoot and pregnant and refers to black people as n*'s
12:50:45 <shapr> oh, I call that redneck or so
12:51:07 <shaleh> redneck is a related type, perhaps a supertype
12:51:18 <shapr> heh
12:51:48 <shaleh> rednecks are not inherently racist or stupid. The more common attribute is being poor.
12:52:12 <shapr> there's also the "poor white trash" classification
12:52:23 <shaleh> indeed
12:52:43 <shapr> in Sweden, nearly everyone speaks english
12:53:10 <shapr> I think the exposure to multiple cultures cuts down on the prejudice here.
12:53:29 <shapr> it's not completely gone, but it sure is better where I live
12:53:58 <shaleh> how did you get immigrant status?
13:03:47 <shaleh> welp, I am heading out early today
13:39:27 <jemfinch> shapr: What's "inclusional polymorphism"?
14:01:19 <shapr> jemfinch: subclasses are the same type as their superclass
14:02:56 <Marvin--> ... also known as subtyping
14:03:00 <shapr> jemfinch: do you have a website/blog/etc?
14:05:51 <jemfinch> shapr: not really.  I sorta use my lpl-devel mailing list for my programming language blogging ideas, though.
14:06:24 <shapr> are you not the same as jemfinch on livejournal?
14:07:07 <jemfinch> shapr: I am, but I moved my L blogging to lpl-devel, and I doubt you're interested in my theological blogging :)
14:07:14 <shapr> actually, I am
14:07:27 <jemfinch> oh, hah...well, I'll have to keep it up, then :)
14:07:37 <shapr> I'm thoroughly Baptist
14:07:49 <jemfinch> which kind?
14:08:00 <shapr> er, what are my choices? :-)
14:09:00 <jemfinch> independent and southern are the ones I'm most familiar with.
14:09:09 <shapr> I don't know the differences anyway
14:09:20 <jemfinch> there are also "anabaptists," but I'm not very familiar with their theology -- I think they're more toward the Amish end of the scale.
14:09:35 <shapr> but I'd be happy to discuss it (on another channel)
14:09:53 <jemfinch> what's an appropriate channel?
14:09:58 * shapr doesn't know
14:10:13 <Marvin--> hmm
14:10:14 <jemfinch> well, it's been registered, but #theology doesn't have anyone else in it right now.
14:10:24 <Marvin--> shapr: didn't moshez have moshez.org?
14:10:38 <shapr> yes, he did
14:10:46 <shapr> and moshez.geek if you followed the alternate roots
14:46:40 <ralf> I am reading the Haskell School of Expression. 
14:46:49 <ralf> Right now I am working on problems out of chapter 5
14:47:14 <Marvin--> I don't have HSoE :(
14:47:37 <shapr> I do!
14:49:16 <ralf> shapr: like it? 
14:49:34 <ralf> Marvin--, What haskell books do you like? 
14:49:39 <shapr> yah, I like it.
14:50:00 <SyntaxNinja> hi ralf!
14:50:11 * SyntaxNinja notes that ralf is in my house, but i'm not...
14:50:18 <shapr> ha
14:50:45 <ralf> Yea.  I'm in syntax's ralf. 
14:50:53 <ralf> shapr, Do you know syntax?  
14:50:57 <Marvin--> I actually only own one haskell book (Thompson's Craft of Functional Programming) but it's pretty good
14:51:06 <Marvin--> I really enjoyed Okasaki's Purely Functional Data Structures, though
14:51:10 <ralf> Yeah.  I think I've heard of that. 
14:51:13 <shapr> SyntaxNinja and I have slept in the same building for several weeks I think
14:51:32 <ralf> shapr, Did you ever meet him? 
14:52:06 <ralf> Marvin--, Books work for me so I will buy them if you give a strong enough recommendation. 
14:52:12 <shapr> yes, we even slept in the same room for several days.
14:52:21 <SyntaxNinja> ralf: I can bring home that Okasaki book to look at if you like.
14:52:23 <shapr> actually, Marvin-- and SyntaxNinja and I slept in the same room one night.
14:52:33 <Marvin--> one of which-... what shapr said
14:52:34 <SyntaxNinja> ralf: shapr was my host in Sweden.
14:53:25 <ralf> Woa.  And you guys never met?  That's so weird...
14:53:34 <Marvin--> ...
14:53:46 <SyntaxNinja> ralf: urdum
14:53:57 <ralf> yeah.  I'm just being stupid. 
14:54:04 <Marvin--> whoa, SyntaxNinja's speaking Swedish
14:54:11 <shapr> vad?
14:54:34 <Riastradh> Marvin--, bjarne!
14:54:50 * SyntaxNinja home &
14:54:57 <Marvin--> "urdum" = really dumb
14:54:57 <shapr> Marvin--: man, I love this Grabben i Graven Bredvid movie
14:55:02 <shapr> ha
14:55:07 <Marvin--> shapr: I haven't seen it
14:55:17 <shapr> it's extremely cute and romantic
15:03:08 <stepcut> shapr: do you remember that link where someone had written a Monad for dealing with unix processes and pipelines?
15:04:25 <shapr> http://www.volker-wysk.de/hsunix/ or http://www.electronconsulting.com/shell-haskell/ ?
15:05:13 <stepcut> i think it was hsunix, thanks!
15:05:33 * shapr goes off to sleep
15:06:38 <Marvin--> ralf: so, did you actually have any questions on chapter five of HSoE or did you just come here to make smartass remarks? :)
15:18:21 <ralf> I do have a compulsion to make smart-ass remarks.  Especially in new social situations (where it is least likely to be appropriate). 
15:18:37 <ralf> But yeah.  I could have some questions on chapter five.  I am still 
15:18:49 <ralf> having difficulty deciding when a question is worth asking. 
15:19:15 <ralf> Here's one: 
15:19:37 <ralf> Exercise 5.2  What is the principal type of each of the following exepressions: 
15:19:39 <ralf> map map
15:19:43 <ralf> foldl foldl
15:19:46 <ralf> map foldl
15:20:06 <ralf> I haven't a clue.  I am writing out the types of map and foldl and trying to put them together.  
15:20:07 <monotonom> These are fun questions.
15:20:28 <monotonom> Yes, some kind of unification/resolution job.
15:20:28 <ralf> is it (map map) or would it be map (map f l)
15:20:29 <ralf> ? 
15:20:48 <Igloo> The first argument to map is map
15:21:18 <Igloo> map :: (a -> b) -> a -> b so the first argument has type a -> b
15:21:22 <ralf> Oh.  See.  You just have to think about it for a minute. 
15:21:24 <monotonom> It is easier to rename variables to avoid name clashes and variable captures.
15:21:25 <ralf> I think I can get it now. 
15:21:35 <np_hard> irc is a social situation?
15:21:46 <ralf> I was just thinking about that. 
15:21:47 <np_hard> what a time to be alive
15:21:58 <Igloo> Remember that a -> b -> c -> d = a -> (b -> (c -> d)), i.e. types bracket to the right
15:22:12 <monotonom> Think of map :: (a -> b) -> [a] -> [b], map :: (s -> t) -> [s] -> [t].
15:22:30 <kosmikus|away> Igloo: the function space constructor, not types ...
15:22:36 <Igloo> Oh, err, yeah, you'll want to use the correct type for map too  :-)
15:22:39 <monotonom> Then a=s->t, etc.
15:24:04 <np_hard> so, is there a good argument for learning about HoFs when confronted with "comfortable" Java programmers?
15:24:41 <monotonom> The "Command" design pattern = HoFs.
15:25:31 <np_hard> ah
15:25:37 <monotonom> "Would it be cool to write (fun () -> body) instead of new Runnable() { public void run() { body } }?"
15:25:45 <np_hard> but you don't get to make an object! :)
15:26:21 <np_hard> that's just an anonymous function :-P
15:26:28 <np_hard> i mean map, fold, filter, etc
15:26:54 <np_hard> a coworker was pretty confused by my use of map in Perl
15:26:59 <np_hard> and it wasn't just because it was perl
15:27:05 <np_hard> he had never considered map
15:27:41 <jemfinch> map is really fast in Perl.
15:27:44 <monotonom> For map and friends, a few Java programmers are already tired of writing Iterator i = mylist.iterator(); while (i.hasNext()) { ... i.next() ... }
15:27:46 <jemfinch> (as far as Perl iteration goes, that is)
15:27:47 <arjanb> foreach is good example to start with
15:28:18 <det> jemfinch: what is so fast about it?
15:28:42 <det> jemfinch: for what reason would it be faster than map in Python?
15:28:46 <monotonom> Bottomline: you can sell HoFs to a programmer iff he is fed up with repetitive coding.
15:29:00 <np_hard> i wrote a zipWith for perl too
15:29:12 <det> jemfinch: or are you compaing to other iteration constructs implemented or pure Perl ?
15:29:13 <jemfinch> det: that's why I said, "as far as Perl iteration goes, that is"
15:29:20 <monotonom> If a programmer doesn't see the problem with Iterator i = mylist.iterator(); while (i.hasNext()) { ... i.next() ... }, don't bother --- he is not ready.
15:29:21 <det> oh
15:29:24 <jemfinch> I'm comparing it to other Perl iteration constructs, like foreach, for, etc.
15:29:34 <np_hard> monotonom: that's probably a good plan
15:29:42 <jemfinch> map is faster than those for the same reason that map is faster than for in Python -- it's bytecode interpretation versus a single C function.
15:29:44 <det> jemfinch: IOW, C is faster than perl :p
15:29:46 <np_hard> monotonom: what irks me is he always yammers on about "abstraction"
15:29:52 <jemfinch> det: yup.
15:29:55 <np_hard> and "general solutions"
15:29:58 <np_hard> and he means
15:30:10 <np_hard> "letting the Java IDE write everything for you"
15:30:36 <monotonom> Haha that is a tough one
15:30:51 <np_hard> i think map is faster than for in python only for builtins :)
15:31:02 <monotonom> You can try "HoF = IDE with text UI" :D
15:31:17 <jemfinch> np_hard: you're thinking of the comparison to list comprehensions.
15:31:18 <np_hard> you give it an arbitrary lambda expr and it will not be faster than the equivalent for loop
15:31:24 <np_hard> aah, ok then
15:31:26 <det> np_hard: I doubt it :)
15:31:37 <jemfinch> np_hard: I could be wrong, though.
15:33:03 <np_hard> monotonom: but that's not nearly as advanced!
15:33:14 <np_hard> :)
15:33:26 <np_hard> i don't want to think he's beyond hope
15:33:51 <np_hard> i guess I can just let him be comfortable with all of his powerdesigner and websphere studio silliness
15:34:44 <np_hard> but it makes it rough to collaborate with him
15:36:08 <monotonom> Open-minded programmers are nice to work with and talk to.  I don't really mind if he says "wow this is cool, though I think I'll stick with what I have for now".  At least he does not completely dismiss it.
15:37:31 <monotonom> Closed-minded ones will say "I don't understand map" and *that* is hopeless.
15:37:55 <np_hard> yep
15:38:02 <jemfinch> I wouldn't mind working with closed-minded programmers, as long as I got to have an open-minded boss :)
15:38:15 <np_hard> and they are thinking the same thing when you say "I don't understand why you used gotos everywhere"
15:38:16 <np_hard> :)
17:24:43 <Igloo> There isn't any way to create my own Handle, right?
17:27:16 <phubuh> i don't think so.  but if you find a way, i think shapr's interested as well :)
20:10:13 <Cale> Is there a way to get hugs to be able to evaluate expressions using things from multiple modules at once without having import declarations in those modules?
20:11:06 <jemfinch> why is Haskell so much faster than C in the shootout regexp benchmark?
21:58:40 <blackdog> B[B[B[B
21:58:58 * blackdog blushes
21:59:01 <blackdog> sorry.
22:00:17 <Riastradh> Keep blushing, harder & harder.
22:00:22 <Riastradh> I want to see your face explode.
22:06:17 <blackdog> i look like falstaff already. show some pity, please.
22:06:36 <dons> oh, blackdog!
22:07:03 * blackdog thinks to himself: it's sure lucky no-one knows my real name...
22:07:33 <dons> btw, SY rock ;
22:07:40 <dons> )
22:08:23 <dons> blackdog: what you up to?
22:08:59 <blackdog> I'll be sure to tell Ben that. He missed Manitoba and Four Tet here as well, and apparently missed Trans Am in Boston by needing to be on a plane halfway through the concert...
22:09:07 <blackdog> oh, and SY is touring america after he leaves. :)
22:09:15 <dons> hehe
22:09:15 <Riastradh> SY?
22:09:30 <blackdog> setting up unit tests with xemacs. i'm a perpetual fence-sitter, i flip back and forth.
22:09:37 <blackdog> Sonic Youth
22:09:55 <dons> unit tests with xemacs?
22:10:04 <blackdog> finest purveyors of well-aged indie dissonance in the northern hemisphere
22:10:23 <blackdog> dons: yeah. HUnit and one-button testing, from shae's page. he gave me a good talking-to. :)
22:10:23 <dons> dissonance is right!
22:10:36 <dons> ah. ok.
22:10:43 <blackdog> well-aged is more right. they're, like, 80.
22:10:51 <dons> hmm.
22:11:36 <blackdog> I don't have your work ethic, don, or your facility with sed & friends. I need stuff to just work (TM), otherwise i get bored and go off to play chess.
22:12:30 * jemfinch never bothered learning sed & friends because he learned Perl.
22:12:58 <dons> that's like saying you never learnt lambda calc cause you learnt Haskell
22:13:13 * blackdog is still waiting for a statically typed, concise scripting language that doesn't look like line noise
22:13:18 <jemfinch> dons: yes, and? :)
22:13:32 <jemfinch> blackdog: you probably won't find a statically typed scripting language.
22:13:43 <jemfinch> (although I think Pike "can be" statically typed)
22:13:43 <blackdog> jemfinch: I might if i write one. :)
22:13:58 <jemfinch> blackdog: static typing is somewhat contrary to the whole "scripting language" phenomenon.
22:13:59 <blackdog> jemfinch: ugh. not that kind of static typing. The good kind.
22:14:13 <blackdog> How so?
22:14:31 <jemfinch> blackdog: the good kind still requires planning.
22:14:43 <blackdog> dons: or like saying you never listened to the pixies because you listened to nirvana
22:14:44 * jemfinch doesn't waste time talking about the bad kind of static typing.
22:15:38 * Riastradh learned sed & friends, as well as Perl, and never finds any reason to use them or anything based much on them, because he has scsh.
22:15:40 <blackdog> jemfinch: i'm not really convinced. Barring stuff like 'eval', I think you could type most practical perl programs
22:15:54 <jemfinch> blackdog: even the good form of static typing requires a design stage where the goal is broken down into types which are then manipulated.  The main idea in Scripting languages is to elide the design stage.
22:16:22 <jemfinch> blackdog: typing perl programs would require functions that dispatch on what time is *requested*
22:16:25 <Riastradh> (by the way, scsh is based on Scheme48, which performs static type analysis, but you'd be really stretching it if you said that that static type system restricted scsh in any way)
22:16:27 <blackdog> Riastradh: what's it like? I keep hearing about scsh, and never got around to trying it out properly...
22:16:31 <jemfinch> (i.e., wantarray+friends)
22:16:54 <jemfinch> blackdog: have you heard of Starkiller for Python?
22:17:17 <Riastradh> blackdog, that's a kind of general question...
22:17:30 <blackdog> jemfinch: but I can write useful programs in Haskell just using lists and primitive types.
22:18:00 <jemfinch> blackdog: I'm not saying you can't.
22:18:03 <blackdog> Riastradh: I guess I'm looking for an aesthetic judgement. Whenever I use perl, I get cranky and start throwing things at people, and my cubicle mates get upset...
22:18:11 <blackdog> dons: it'll heal, i promise.
22:18:22 <dons> :p
22:18:26 <Riastradh> scsh, being Scheme, is obviously _vastly_ more pleasant than Perl.
22:18:43 <blackdog> jemfinch: so if i can do that, i don't need to define types beforehand: it'll just tell me if i'm trying to do something abysmally stupid.
22:18:46 <jemfinch> All I'm saying is that enforced static typesystems hinder exploratory programming to some varying degree, and scripting languages are all about reducing the hindrances to exploratory programming.
22:19:14 <jemfinch> blackdog: all you really need, then, is a good string and process manipulation library for Haskell.
22:19:41 <dons> "exploratory programming" is an interesting phrase
22:19:43 <blackdog> jemfinch: yep, that would suit me down to the ground. hs-unix is a good start.
22:20:07 <dons> when you're just saying that you don't care if things crash
22:20:12 <jemfinch> blackdog: Programming involves some percentage of "thinking," and some percentage of "coding."  The goal of most scripting languages is to reduce the "thinking" and increase the "coding."  Static types are generally opposed to that idea.
22:20:13 <blackdog> Working as a sysadmin, I'm most interested in making sure my scripts are correct.
22:20:21 <dons> i think we still care if stuff crashes.
22:20:31 <jemfinch> dons: yes, you don't care if things crash.  You don't care if things are efficient.  All you care is to try new ideas out.
22:20:39 <jemfinch> and new ideas often crash and are often inefficient.
22:21:09 <dons> type inference lets you try things out cheaply, and even gives you hints about what you should be doing better
22:21:13 <blackdog> jemfinch: I don't buy that at all. I spend the least amount of time thinking when i code in C, because most of it is boring rote code. I spend the most time thinking when i write haskell or shell, because you have powerful primitives.
22:21:43 <jemfinch> blackdog: well, I don't buy that at all :)
22:21:48 <dons> scripting languages are just ghc with type checking turned off
22:21:53 <blackdog> sigged!
22:21:56 <jemfinch> I'd say the issue is that you're doing boring things in C and interesting things in Haskell or sh.
22:21:58 <dons> maybe we should add such a flag for crazy people
22:22:30 <blackdog> jemfinch: not really. It was compiler hacking in both cases.
22:23:13 <blackdog> coding haskell's like having a janitor, a personal coach and a butler following you around all the time. :)
22:23:41 <blackdog> coding C, you clean up your own messes.
22:25:13 <blackdog> so to continue the analogy, in a scripting language you have the janitor, but not the personal coach.
22:25:39 <jemfinch> blackdog: I find your analogy uninteresting :)
22:25:48 <jemfinch> it's just a creative restatement of your opinion.  It makes no argument.
22:25:51 <blackdog> jemfinch: yeah, it's starting to stretch a little now. :)
22:27:05 <jemfinch> blackdog: you've been programming in Haskell for a long time now?
22:27:09 <blackdog> i guess it boils down to whether you find the type system helps you or hinders you. Haskell's type system very rarely gets in my way, and it catches most of my dumb mistakes very quickly.
22:27:40 <blackdog> blackdog: only 4 years.
22:27:40 <dons> it's all about limiting the broken programs that will actually get to runtime
22:27:49 <blackdog> there i go again, talking to myself.
22:27:53 <jemfinch> hehe
22:28:09 <jemfinch> blackdog: Out of curiosity, how often to you find yourself writing code that the compiler rejects?
22:28:33 <dons> how often do you write code that crashes at runtime?
22:28:41 <dons> which is better, compile error or runtime segfault?
22:28:55 <blackdog> pretty often. i rarely get syntax errors (the sort of thing python might catch, for instance), but i get type errors reasonably frequently.
22:29:08 <jemfinch> blackdog: ah, well your experience is different than mine.
22:29:31 <blackdog> generally it points to a problem in my understanding of the question: in a dynamically typed language, i wouldn't catch it till runtime.
22:29:37 <jemfinch> blackdog: I found after programming in O'Caml for a bit over a year and SML for several months after that, that I simply didn't make very many type errors at all.
22:29:42 <Riastradh> dons, run-time segfault?  In a decent scripting environment, you would be shown a coherent error and be thrown into a debugger.
22:30:20 <dons> ok. so runtime error or compile error. they're all errors, and one is just sooner than the other
22:30:36 <Riastradh> At which point you'd modify the code, send it back to the REPL, and restart the computation from whichever point is most convenient.
22:30:41 <blackdog> jemfinch: that's quite surprising to me. Do you use higher-order functions, monads, that sort of thing? I'd have a terrible time threading them together without a bit of support from the typechecker.
22:31:31 <jemfinch> blackdog: not monads, but quite a few higher-order functions.
22:31:44 <jemfinch> my biggest problem was the stupid argument-reversing O'Caml does with fold_left and fold_right.
22:31:54 <jemfinch> SML, since it's sane, doesn't have that problem.
22:32:09 <blackdog> Riastradh: but if your program's running 24/7 on a remote server, you'd really prefer to get paged about a runtime error than spend a little more time upfront satisfying the type-checker that you've covered all the angles?
22:32:18 <jemfinch> blackdog: The training I received from ML was extremely valuable, but after awhile I found that I didn't need a typechecker because I didn't make very many (if any) type errors.
22:32:38 <jemfinch> blackdog: remember that those two aren't mutually exclusive.
22:32:38 <Riastradh> blackdog, that sort of thing isn't a dynamic development environment.
22:32:57 <jemfinch> blackdog: for instance, both PLT scheme and Erlang have "offline typecheckers" which can do type checking.
22:33:14 <jemfinch> it's just that you don't have to convince the compiler that your entire program is typesafe in order for it to compile it.
22:33:29 <blackdog> I thought the attempt to add type-checking to Erlang was a bit of a disappointment...? Didn't SPJ do something on it?
22:33:41 <dons> simonm, I think
22:33:45 <Riastradh> Static type analysis is certainly useful, but not enough to be restrictive.
22:33:49 <jemfinch> blackdog: I never saw released code, just some interesting stats on it.
22:33:59 <jemfinch> Riastradh: exactly.
22:34:20 <jemfinch> blackdog: there are very useful features languages that don't have to prove type safety can have.
22:34:44 <Riastradh> Indeed, no decent optimizing compiler for a dynamically-typed language performs no static type analysis.
22:35:22 <jemfinch> blackdog: the argument about typing isn't so much whether it's useful, but when it should be done, and whether programs that aren't provably typesafe should be allowed to run.
22:35:33 <blackdog> it depends on how you view it, i suppose - it's the error-catching that sells it for me, not the performance benefits.
22:36:07 <blackdog> I'd be interested to see some useful programs that can't be type-checked. I know there are some, but it'd be interesting to see how prevalent they are.
22:36:22 <Riastradh> It tends to be a lot harder to restart a compiler in the middle of compiling a file with a new expression that is correctly typed than to resend a definition to a REPL during execution and restart a stack frame.
22:36:24 <jemfinch> blackdog: any program with variadic functions, for one :)
22:37:05 <blackdog> jemfinch: TH can help a fair bit with that sort of thing - you can implement printf, for instance.
22:37:16 <jemfinch> TH?
22:37:19 <Riastradh> Template Haskell
22:37:32 <jemfinch> ah, does that allow dependent types?
22:37:42 <jemfinch> blackdog: have you read "Functional Unparsing"?
22:37:44 <Riastradh> blackdog, that's not what jemfinch was talking about.  The issue with printf was statically verifying the types in a format string.
22:38:08 <blackdog> perhaps I've misunderstood - what do you mean by a variadic function?
22:38:10 <Riastradh> s/verifying the types in/determining types from/1
22:38:15 <blackdog> no, i haven't.
22:38:41 <jemfinch> blackdog: variadic functions have a variable number of arguments.
22:39:54 <Riastradh> ssh campbell@autodrip.bloodandcoffee.net
22:39:59 <Riastradh> Uh, wrong window!
22:40:17 <Riastradh> Good thing it was for that line and not the next one...
22:40:54 <Verbophobe> Wait, with variadic functions...  Couldn't you just do something like this:
22:40:56 <blackdog> jemfinch: printf's variadic, isn't it?
22:40:57 <Verbophobe> data PrintfStuff = PrintInt Int | PrintString String| Etc...
22:40:57 <Verbophobe> printf :: [PrintfStuff] -> String -> IO ()
22:41:11 <jemfinch> blackdog: it is.
22:41:19 <Riastradh> Verbophobe, yup, that would work too.
22:41:25 <Verbophobe> Ah, cool.
22:41:29 <jemfinch> blackdog: to implement printf properly requires dependent types.
22:41:34 <Verbophobe> Wouldn't it be simpler than mangling the types?
22:41:50 <Riastradh> Verbophobe, yup, that would be easier to implement too.
22:41:51 <jemfinch> does any bot here do google?
22:41:55 <blackdog> jemfinch: i get the feeling i keep missing the issue. i'll go read the paper.
22:41:57 <Riastradh> @google foo
22:41:58 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands
22:42:01 <Riastradh> Nope, jemfinch.
22:42:01 <Verbophobe> Neat.  Back to idling.
22:42:08 <jemfinch> Verbophobe: Google for "functional unparsing"
22:42:12 <Verbophobe> Ok.
22:42:25 <Riastradh> Verbophobe, personally, I don't see why people still bother with template string-based formatting.
22:42:32 <jemfinch> it's a far better solution than most, and definitely better than the one you proposed (no offense to you, of course, just noting :))
22:42:41 <Riastradh> Indeed, heh.
22:43:00 <Verbophobe> Sounds enlightening...  I'll have a read.
22:43:03 <Riastradh> Compare these two lisppastes:
22:43:10 <Riastradh> http://www.common-lisp.net/paste/display/537
22:43:16 <Riastradh> http://www.common-lisp.net/paste/display/542
22:43:40 <Riastradh> The first one is CL's FORMAT gone horribly, horribly wrong (but it's still correct code.)
22:44:15 <jemfinch> Riastradh: CL's format is crazy beyond all reason, though.
22:44:15 <Riastradh> The second one is an example of a proposal for a different mechanism for formatting, more like what you described, Verbophobe; it (mythically) does the same thing as the first one.
22:44:49 <blackdog> jemfinch: i think i understand it now. You need dependent types if you want an honest-to-goodness arbitrary format string at runtime. If it's set in the code, you can use funky template haskell tricks like Igloo used to reduce it to a garden-variety function.
22:44:59 <Riastradh> (It helps to have familiarity with SRFI 42 to understand ITERATE in the second one, by hte way.)
22:45:20 <jemfinch> blackdog: you can also use funky tricks like O'Caml does for literal printf formatting strings.
22:45:32 <Riastradh> jemfinch, ugh, don't make me think about that hack!
22:45:37 <jemfinch> :)
22:45:43 <jemfinch> Riastradh: have *you* read "Functional unparsing"? :)
22:45:47 <Riastradh> No.
22:45:52 <blackdog> I've never actually seen a non-literal format string in C code, so i'm unconvinced that it's of much use... can anyone suggest a useful variadic function that it's really difficult to do in an HM system?
22:45:59 <jemfinch> you should read it.  I'm curious how it would work in Scheme.
22:46:08 <Verbophobe> Ouch...  I'm not too good in LISP.  Lucky you explained it.
22:48:30 <blackdog> let me rephrase that in a more incendiary fashion: why haven't all you lisp people switched to haskell yet? :)
22:48:51 <Riastradh> Verbophobe, don't worry if you don't understand the first one...that was the intent.  With the second one, ITERATE is probably the most confusing bit; think of (ITERATE (:LIST <pattern> (INDEX <i>) <list>) <body>) somewhat like [BODY | (PATTERN, I) <- zip LIST [0..]]; with :LIST-PAIRS, PATTERN matches on not the element of the list but each pair in the list.
22:49:16 <Riastradh> blackdog, why haven't _you_ switched to Lisp, varlet!?!!
22:49:39 <blackdog> because i can't cope without my type-checker.
22:49:46 <jemfinch> blackdog: I can :)
22:50:12 * Riastradh brandishes Scheme48's static type analyzer menacingly at blackdog.
22:50:51 <blackdog> Riastradh: serious question underneath the smartarsery, though: I know lots of clever hackers who use Lisp without online static type analysers. There is presumably a reason for it:
22:51:05 <jemfinch> blackdog: there are significant philosophical differences between Lisp and Haskell, and I fall on the Lisp side.
22:51:09 <blackdog> 1. real hackers don't need no steenking type system holding their hands
22:51:25 <jemfinch> blackdog: don't equate a lack of static enforcement to a lack of a type system.
22:51:31 <jemfinch> Lisp has a type system, it's just not statically enforced.
22:51:39 <blackdog> 2. the offline ones are comprehensive enough to give you a good guarantee
22:51:50 <Verbophobe> Ah...  OK, makes sense :)
22:52:13 <blackdog> 3. it's annoying to lose static guarantees, but it's worth it because Lisp lets you do $RANDOM_COOL_THING
22:52:32 <blackdog> any of these, or have i missed the turnip entirely?
22:52:35 <jemfinch> blackdog: 4. Static guarantees aren't all that useful.
22:53:10 <dons> I'm not letting anyone program lisp into my pace maker
22:53:20 <blackdog> jemfinch: close enough to #1, then
22:53:30 <Riastradh> Static _type_ guarantees aren't necessarily all the guarantees that would eliminate run-time errors, and fixes to type errors in a good dynamic development environment are easy enough.
22:53:39 <blackdog> dons: be fair. do you want lazy evaluation in your pacemaker, either?
22:53:50 <Verbophobe> dons) Well, due to the limitations of the current generation of pacemakers, it's either LISP or COBOL.  It's a tough choice, I know.
22:53:59 <jemfinch> dons: Let's take a moment to compare the number of pacemaker programs versus, say, the number of file-munging scripts or webpage generators.
22:54:45 <dons> the point is that static guarantees are extremely useful if you want to reduce the chance of something crashing
22:54:55 <blackdog> Riastradh: sure. but anything that alerts you to errors earlier in the production of software is good, right? You can always ignore the warnings in haskell by inserting a few 'undefined's around the place.
22:55:02 <Riastradh> dons, sure, static guarantees are nice.
22:55:13 <jemfinch> blackdog: for programs that need to run nuclear power plants or pacemakers or space shuttles, static guarantees might be useful, because one failure is catastrophic.  For other programming (which, I would claim, is far more prevalent), they're not so useful.
22:55:25 <jemfinch> dons: static guarantees come at the expense of ease of programming.
22:55:34 <dons> that I dispute
22:55:40 <Riastradh> But they're no substitute for a good dynamic development environment, and, as far as I know, there isn't a very good one for Haskell.
22:56:01 <jemfinch> dons: you can disagree, but that doesn't make you right :)
22:56:04 <blackdog> jemfinch: ok, fine. But I don't have to show that they're better than sex: i just have to show that they're marginally useful, and don't cost me anything. If you can show me that they do cost me something, then I have to reconsider.
22:56:20 <jemfinch> blackdog: it's the "and don't cost me anything" that gets you.
22:56:42 <jemfinch> blackdog: heterogeneous lists are an excellent example.
22:56:59 <jemfinch> you can't do heterogeneous lists in a HM typesystem.
22:57:17 <blackdog> I never understood that argument. How do you know what you can do to each element of a list if it could contain anything?
22:57:32 <Verbophobe> ...but you can wrap it in a datatype if you really really need it...
22:57:37 <jemfinch> blackdog: you could, say, transform it into something else.  Like, you know, defmacro does :)
22:57:55 <Riastradh> (Note that even typeclasses with fundeps require dynamic type data.)
22:58:05 <jemfinch> Verbophobe: conceivably, but that makes things significantly harder (i.e., more verbose) to work with.
22:58:11 <Verbophobe> Of course.
22:58:15 <dons> Haskell does have a Dynamic type, too.
22:58:44 <Verbophobe> But, then again, I've never found a situation where I needed heterogenous lists.
22:58:49 <jemfinch> dons: yeah, and it forces you to jump through hoops to do anything with Dynamics.
22:58:54 <Verbophobe> Well, apart from printf above, of course.
22:59:06 <blackdog> jemfinch: once you start talking about defmacro stuff, the appropriate thing to compare it to is Template Haskell. If that's your argument for heterogeneous lists being useful, you'd have to show that defmacro can do something that TH can't. Is there something?
22:59:11 <Verbophobe> Pardon my noobishness...
22:59:13 <jemfinch> dons: those hoops sap programmer productivity just like type errors discovered dynamically sap programmer productivity.
22:59:40 <jemfinch> the difference is that with dynamically enforced type systems, you pay the cost only if you have errors.  In statically enforced type systems, you pay the cost whether you have errors or not.
23:00:20 <Verbophobe> Arguably, the errors are easier to find in a static system.
23:00:32 <Verbophobe> Thus saving you from utter insanity.
23:01:00 <blackdog> I think Riastradh's made the best point so far: hot-upgrading pieces of code is a really nice feature.
23:01:10 <jemfinch> Verbophobe: "utter insanity" isn't something that happens to good programmers in dynamic systems.
23:01:23 <jemfinch> blackdog: and it's possible with statically-typed systems, it just isn't something the implementors of such systems are concerned with.
23:02:47 <Riastradh> blackdog, and with hot code upgrading, the line between a type error and some other kind of error is blurred; you can dynamically fix either.  That's _way_ more important than getting static type verification, which verifies hardly the only kind of error that can occur in such a big system that blackdog referred to above.
23:02:52 <blackdog> well, dons has done some nice stuff with it. At the moment, though, it's something that you have to build into your system from the beginning, rather than being a bonus.
23:03:15 <Riastradh> Erlang pretty much just got this right.
23:03:35 <Riastradh> And it's used for the kinds of big systems that blackdog earlier referred to.
23:03:40 <jemfinch> (using a mechanism that any FPL could really use)
23:03:57 <jemfinch> Any FPL that can dynamically load code can do what Erlang does.
23:04:14 <Riastradh> ...but Haskell has a hard time dynamically loading code, because of the restrictive static type system!
23:04:30 <jemfinch> Riastradh: it works in SML.
23:04:30 <blackdog> dons? Come back, dammit, you know more about this than me...
23:05:29 <blackdog> Riastradh: have you seen dons hs-plugins stuff? I'd be interested to know what you think.
23:05:53 <blackdog> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-1.html
23:06:46 * blackdog goes off to socialise with NZ cousins twice removed.
23:07:19 <jemfinch> man, why is everything on recursive descent parsing so freaking mathematically oriented?
23:08:45 <Riastradh> blackdog, that still depends on contortions with typeclasses to circumvent restrictive typiness.
23:09:19 <dons> dynamic loading?
23:11:04 <blackdog> yep
23:11:30 <blackdog> i think you only need to derive Typeable - it's not much of a contortion, i think.
23:11:45 <dons> there are no contortions.
23:12:02 <dons> and no circumvention, either.
