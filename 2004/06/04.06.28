01:37:12 <musasabi> How are edison vs ddata? 
02:07:58 <vegai> I wonder where the Clean community is...
02:15:58 <earthy> vegai: good question
02:16:18 <earthy> I'd guess: at Nijmegen University. however, I know that to be untrue. :)
02:16:31 <earthy> (students at Nijmegen University tend to have a strong dislike of Clean)
02:17:39 <vegai> are they forced to learn it?
02:19:07 <vegai> they obviously selected a rather poor name for the language
02:19:10 <vegai> not very googlable
02:20:17 <earthy> yes, they are. :)
02:20:31 <earthy> (in the first programming course, even)
02:21:19 <vegai> yup
02:24:48 <vegai> terrible shame if that language whithers away
02:24:54 <sazzle> i think people either love or hate their first language, esp if it's a language that's not preceived 'useful' (ie, used in industry)
02:26:00 <earthy> well, in this case it has more to do with the people writing the language
02:26:15 <vegai> s/whither/wither/
02:26:57 <earthy> prof. Plasmeijer is not the best teacher, to put it subtly
02:26:59 <arjanb> i think people appreciate functional languages more if they only know a limited language like java
02:27:51 <sazzle> i really started appreciating haskell when i tried doing the same sorta things in c++
02:27:56 <earthy> ;)
02:28:07 * earthy does not dislike Clean itself. it's actually pretty good
02:28:21 <earthy> it's just that the group developing it... well... *ahum*. :)
02:33:08 <musasabi> I am considering a scheme where I will have lots of preparsed data templates that need to be stored on disc and then quickly interpreted. What would be a good way to store them on disc?
02:33:26 <vegai> earthy: is it forkable?
02:33:50 <earthy> not sure
02:34:28 <earthy> nope, they still haven't changed that
02:34:37 <vegai> GNU LGPL, apparently
02:35:23 <earthy> oh, wait, right.
02:35:26 <earthy> they *did* change that. :)
02:39:20 <ozone> i thought the license was ... weird
02:39:32 * ozone goes to check before speaking about shtuff he's bound to get wrong
02:39:57 <ozone> ah, that's right.  dual-licensed under LGPL + commercial
02:47:36 <earthy> it used to be commercial only
02:49:04 <norpan> LPGL is good enough
02:50:43 <blackdog> I heard a vague rumour that there's a clean compiler that can handle most of haskell... can anyone confirm or deny?
03:06:53 <musasabi> What would be a good way to generalize a monadic value? Like:
03:06:55 <musasabi> -- generalize a monad
03:06:55 <musasabi> maybeToM :: (MonadPlus m) => Maybe a -> m a
03:06:55 <musasabi> maybeToM Nothing   = mzero
03:06:55 <musasabi> maybeToM (Just x)  = return x
03:09:11 <musasabi> I think there should be a cleaner way to do this, but don't remember how to do it.
03:13:58 <Heffalump> I don't get the general idea behind what you're trying to do
03:15:10 <musasabi> Just combining Maybe and List.
03:15:57 <earthy> blackdog: that is indeed a vague rumour, substantiated in the Haskell Communities and Activities Report
03:16:15 <Heffalump> musasabi: do you know about monad transformers?
03:16:24 <earthy> in short: it translates that subset of Haskell that is also handled by Clean
03:16:37 <earthy> and comes with an implementation of the Haskell standard lib in Clean
03:16:42 <Heffalump> but what you are doing above is more like treating Maybe as a submonad of List
03:17:30 <musasabi> Heffalump: yes, but was thinking that this could be solved without them.
03:18:16 <Heffalump> I guess you need to make a typeclass from each monad
03:18:34 <Heffalump> and then write implementations for each other monad. I can't see a completely general framework for doing that.
03:18:47 <Heffalump> IMO monad transformers are quite simple, though.
03:19:24 <musasabi> hmm, well I'll try them instead.
03:35:39 <shapr> w00h00
03:35:41 * shapr bounces
03:36:05 <shapr> goood morning #haskell!
03:36:22 <JaffaCake> mornin' shapr
03:36:45 <shapr> anyone writing nifty Haskell code today?
03:36:55 <shapr> JaffaCake: do you get to spend all of your time writing Haskell code?
03:37:15 * JaffaCake writes more email than Haskell code :(
03:37:29 <shapr> administrivia?
03:37:45 <JaffaCake> mailing-list stuff mostly
03:38:07 <JaffaCake> and the GHC bits I'm working on don't involve much Haskell stuff at the mo
03:38:17 <shapr> the Haskell mailing list posts you write are very valuable to the community
03:38:31 <JaffaCake> thanks :)
03:38:47 <shapr> I think that translation of a C program into closely matching Haskell code was high humor.
03:38:57 <JaffaCake> hehe, yeah I enjoyed that
03:39:20 <earthy> not only high humor, also high enlightenment value
03:39:45 <shapr> yes, it's on the QuotesPage along with your guide to optimizing Haskell programs.
03:40:03 <earthy> (it actually is somewhat stricter and cleaner than the C code)
03:40:06 <JaffaCake> I noticed!  that's a fun page
03:45:17 <shapr> hola jao. ¬øcomo est as?
03:46:03 <jao> hola sharp. muy bien, y tu?
03:46:10 <shapr> bien
03:46:23 <jao> are you learning spanish?
03:46:37 <musasabi> Is there any cache library? String->IO Maybe a lookup, finite size, and a user suplied function to fetch missing things from disc
03:47:05 <shapr> nah, I learned some spanish years ago. Nowadays I'm learning Swedish, and I'm hoping to really learn Finnish after that.
03:47:12 <shapr> min√§ puhun vahan suomea
03:47:25 <musasabi> kiva kuulla ^_^
03:47:35 <shapr> musasabi: there's a memo library that can memoize Ints, but it uses pointer equality
03:47:42 <jao> heh. i'm afraid my swedish is rather weak :)
03:47:44 <shapr> you may want to use a FiniteMap instead
03:47:50 <musasabi> finnish irc is nasty as we use iso-8859-1[5] instead of utf-8.
03:47:51 <shapr> jao: well, that was finnish
03:48:06 <jao> lol
03:48:31 <jao> my finnish also needs improvement, you see
03:48:36 <shapr> finnish is to most european languages as Haskell is to C, Java, Python, Perl
03:48:51 <vegai> hm ;)
03:48:54 <jao> really? how so?
03:49:30 <musasabi> shapr: I need it to be of finite size, as I will potentially have ~200mb of the cacheable data and want only to keep ~10mb in memory.
03:50:05 <musasabi> Svenska ‰r svÂrigt.
03:50:12 <shapr> jao: take for example "√§l√§ r√§√§kk√§√§k√§√§n kissaa"
03:50:13 <musasabi> (or is that svÂrt)
03:50:24 <shapr> which means something like "don't tortune the cat"
03:50:26 <musasabi> don't torture the cat ;)
03:51:09 <jao> shapr, i would. but the first part of it looks like garbage on my irc client.
03:51:22 <shapr> ok, what about a nice palindromic finnish word: Saippuakippokukkakivikakkukoppikauppias
03:51:42 <shapr> hoi wouter, hoe gaat het met jou?
03:51:51 <jao> wow. that's impressing. what does it mean?
03:52:09 <earthy> it's more impressive than parterretrap, that's for sure
03:52:33 <shapr> the parts I understand look like "health cup shop"
03:53:14 <vegai> soap cup flower stone cake (umm) shopkeeper
03:53:19 <shapr> ah, thanks
03:53:26 <vegai> koppi would be... umm
03:53:37 <vegai> a shack?
03:54:09 <musasabi> soap cup flower stone cake booth seller
03:54:15 <vegai> yeah, booth
03:54:26 <jao> hm. but is it a sentence? a noun?
03:54:34 <musasabi> a noun
03:54:48 <vegai> usually just "saippuakivikauppias", since that almost means something
03:55:16 <musasabi> soapstone seller seems almost sensible in english too.
03:56:11 <shapr> jao: so, do you now understand why the finnish grammar checking software industry is not overly large?
03:57:03 <jao> shapr, sure :)
03:57:55 <vegai> ls
03:58:00 <vegai> oops
03:58:06 <shapr> HelloWorld.hs
03:58:46 <shapr> I'd also like to learn a Baltic language like Lithuanian.
03:59:03 * jao is trying to learn japanese
03:59:16 <firefly_> shapr: go for Latin, Greek, and Sanskrit first.
03:59:17 <shapr> oh, how do you like it?
03:59:24 <shapr> firefly_: bah, lots of people know those
03:59:48 <firefly_> nullo modo
04:00:00 <shapr> lojban is fun too
04:00:10 <jao> shapr, it's interesting. i specially like the kana and kanji. the grammar is a little bit, hm, limited.
04:00:49 <jao> but it looks so beautiful :)
04:01:12 <shapr> does japanese also have vertical writing, or is that only chinese?
04:01:26 <vegai> japanese writing goes to every direction ;)
04:01:41 <vegai> that wasn't a joke 
04:01:43 <shapr> right to left? down to up?
04:01:50 <vegai> right to left or left to right
04:01:55 <jao> as far, i've only seen left-to-right japanese.
04:01:55 <vegai> or down to up or up to down
04:02:15 <jao> vegai, and how do you know which way to go?
04:02:25 <vegai> jao: I have no idea
04:02:33 <vegai> by the context, probably
04:02:56 <vegai> I haven't witnessed this first-hand, mind you
04:03:05 <vegai> just something my japanese teacher told us
04:03:09 <jao> since kana are syllabic, that will give rise to interesting ambiguities.
04:03:21 <vegai> certainly
04:11:49 <musasabi> it goes either (top-down and right-left) or (left-right and top-down)
04:12:34 <sazzle> a bottom-up scripture would be rather strange
04:12:58 <sazzle> musasabi: isn't traditional top-down, right-left, and modern L-R, T-D?
04:13:26 <vegai> musasabi: oh, ok
04:13:50 <vegai> though I remember she insisted that the direction can be to any which way
04:13:58 <vegai> on newspapers and magazines, that is
04:18:16 <musasabi> vegai: yes, they tend to take liberties.
04:18:31 <musasabi> btw is Binary available for ghc?
04:20:15 <shapr> there are two libraries named Binary
04:20:37 <shapr> one replaces the Read/Show way of saving a value
04:20:48 <shapr> one is for chopping up binary files like images
04:21:23 <shapr> stepcut ported Hal Daume's version of the Binary value saving library to ghc 6.2
04:21:33 <shapr> I have a copy here if you want it.
04:22:23 <shapr> hi Verbophobe 
04:22:49 <musasabi> shapr: that would be nice.
04:22:59 <Verbophobe> Hey
04:23:01 <musasabi> shapr: via www or mail?
04:23:54 <shapr> musasabi: http://shapr.homelinux.net/~shae/NewBinary.tgz
04:23:59 <musasabi> thanks ^_^
04:24:15 <shapr> I just tarred up everything in that dir, so you got .o and .hi files too, shouldn't be hard to pick them out
04:27:21 <musasabi> "make clean" seems to work fine.
04:30:35 <shapr> JaffaCake: what sort of magic is used with "deriving" ? could it also be a function so that magic deriving instances could be outside of the original .hs file?
04:30:56 <JaffaCake> hmmmm
04:31:09 <JaffaCake> not sure I follow you
04:31:23 <shapr> I'd like to use deriving on datatypes that come with GHC, for example
04:31:34 <JaffaCake> oh, I see
04:31:42 <shapr> <stepcut> is there someway to add 'deriving Typeable' to System.Posix.Process.ProcessStatus without modifying the standard libraries ?
04:31:48 <JaffaCake> using Data.Generics is one way
04:32:11 <JaffaCake> no there isn't
04:32:28 <JaffaCake> it's a problem with the language, I suppose
04:33:06 <Marvin--> an even bigger problem is that "deriving" is something of a hack :-) isn't the whole deriving thing hardwired into the compiler?
04:33:26 <JaffaCake> well, yes
04:33:38 <shapr> is Data.Generics more general?
04:33:46 <JaffaCake> but back when it was designed, generic programming hadn't been invented
04:33:47 <shapr> could Data.Generics be used in nhc or hugs?
04:33:51 <Marvin--> right
04:34:12 <Marvin--> couldn't TH replace deriving?
04:34:29 <JaffaCake> I'm not sure if nhc & Hugs support Data.Generics ATM, but I don't think there's any fundamental reason why they shouldn't
04:34:41 <shapr> yah, but TH doesn't work outside GHC
04:35:11 <Marvin--> well, I'm thinking HaskellTwo anyway
04:35:15 <shapr> I'm thinking about organizing notes for a new Haskell standard
04:35:17 <shapr> heh
04:35:44 <Marvin--> Sometimes I wonder what Haskell would've looked like if we had a BDFL like Python
04:35:46 <shapr> or at least Haskell98 Plus
04:36:35 <shapr> from what I've seen, SPJ is the closest Haskell has to a BDFL, and he's much nicer than Guido
04:37:03 <Marvin--> mmm, spinach
04:38:00 <shapr> (for the non-python programmers here, BDFL = Benevolent Dictator For Life, Guido van Rossum's role for Python)
04:44:46 <jemfinch> shapr: it's a lot easier to be nice when the community is smaller.
04:46:22 <shapr> jemfinch: I think Guido was the same when python 1.5 was in alpha.
04:47:58 * Marvin-- reads PEP 328 and goes "ooh"
04:49:04 <jemfinch> Marvin--: what's 328 again?
04:50:03 <Marvin--> getting rid of relative imports, or rather, inventing a new syntax for relative imports
04:50:44 <jemfinch> ah.
04:50:44 * jemfinch thinks he'll write a @pep command for Supybot.
04:51:20 <Marvin--> from . import foo,  from .module import bar
04:52:29 <Marvin--> Haskell could use some relative imports too
04:52:49 <shapr> I still want the hierarchical libs to work like Python
04:53:09 <Marvin--> shapr: the thing is that with pep 328, python's libs won't work like that any more :)
04:53:33 * shapr is tempted to look at PEP 328
04:53:36 <Marvin--> because  "import foo"  will only be absolute import
04:53:49 <shapr> huh?
04:54:46 <Marvin--> it will only look in sys.path
04:55:01 <shapr> that doesn't sound very useful
04:55:31 <Marvin--> on the contrary, "import foo" is way too ambigous
04:55:51 <Marvin--> you don't know whether it's a top level import or a package-level import
04:56:26 <Marvin--> and as I said, there will be another syntax for relative imports
04:59:55 <Lemmih> Good morning, Haskellers.
05:00:03 <Cale> morning
05:00:46 <firefly_> God middag, David :)
05:40:57 <Marvin--> JaffaCake: has anyone ever told you how annoying it is that your mails don't have any In-Reply-To headers? :)
05:41:03 <musasabi> Is there an easy way of giving each arm of an algebraic datatype a small corresponding number?
05:41:08 <JaffaCake> Marvin--: yes
05:41:46 <musasabi> Trying to serialize a such datatype...
05:41:58 <shapr> musasabi: Data.Generics? :-)
05:42:18 <Heffalump> somebody should hack the mailing list software to infer and insert them :-)
05:42:21 <JaffaCake> I can get in-reply-to headers, but I have to send my email via SMTP (instead of Exchange), which requires selecting an option, and when sending vai SMTP I get strange line-wrapping behaviour
05:42:22 <shapr> greetings mattsd
05:42:50 <Heffalump> does the Exchange team not care about interop at all, OOI?
05:42:55 <JaffaCake> I have submitted this as a bug to the Exchange team, though :)
05:43:12 <Heffalump> I got the impression when I was an intern in Redmond that they didn't care about performance or about people actually being able to use their email.
05:43:19 <mattsd> shapr: hi
05:43:49 <JaffaCake> Heffalump: I think attitudes probably differ between management and engineers
05:44:00 <Heffalump> as ever :-)
05:44:00 <shapr> I mentioned the same bug to one of the higher ups in Asian Sales, and he mentioned it to the Exchange team...
05:44:03 <shapr> that was some years back
05:44:37 <JaffaCake> I actually got a reply from the Exchange team, and they committed to fix it (can't remember if that's in the next version, or the one after that)
05:45:07 <shapr> mattsd: any new questions?
05:45:52 <Marvin--> the problem's been around for ages :(
05:49:12 <mattsd> shapr: not yet. I'm trying to get my head around "point free" programming notation in Daume.
05:49:22 <musasabi> shapr: thanks, that looks nice.
05:52:23 <shapr> hi Abbyboy 
05:52:52 <shapr> looking for info on pure programming?
05:53:23 <Heffalump> apparently not.
05:53:36 <vegai> wow, uniqueness types seem quite nice
05:53:49 <vegai> I wonder what their warts are
05:54:42 <Marvin--> how do uniqueness types work again?
05:55:29 <musasabi> uniqueness types are nice, untill you try to think about them in complex scenarios.
05:55:39 <Heffalump> would a function that did something like runST $ do { a <- newArray ; f a ; return $ unsafeFreeze a } be safe?
05:55:51 <vegai> if I got it at all right, they guarantee that your parameters are referred to only once
06:00:19 <Cale> Heffalump: it sounds that way, as it certainly looks like there's no way that the mutable array will be accessed after the freeze. You might like to give newArray some parameters though :)
06:02:42 <Heffalump> naah, that'd be no fun :-)
06:03:12 <Heffalump> the runST guarantees that you can't even do anything evil like making the array an element of itself, doesn't it?
06:08:22 <vegai> yeah, looks like linear types are very close to unique types
06:08:57 <shapr> Abbyboy: HI
06:10:08 <Heffalump> eeek, who killed me?
06:10:16 <shapr> ?
06:10:31 <Heffalump> I got unhered.
06:10:34 <Heffalump> oh, netsplit.
06:18:42 <shapr> I think the #sml people are spying on us
06:18:57 <shapr> that's why those strange people are jumping into the channel and disappearing again.
06:19:45 <Verbophobe> Hrm...  If you /whois some people, you'll notice that they're in every "leet" channel they can find...
06:20:06 <Verbophobe> [noclouds] #c #c++ #gcc #scheme #lisp #elinux #haskell #python #emacs #vim #latex #ustc #ustclinux
06:20:25 <shapr> maybe that person is just easily bored?
06:20:31 <Verbophobe> Perhaps.
06:20:52 <Verbophobe> They're rather interested in their boredom.
06:21:09 <sazzle> hmm
06:21:16 <sazzle> noclouds hasn't actually left the channel...
06:21:16 <shapr> hiya sazzle!
06:21:36 <sazzle> hi shapr 
06:21:44 <sazzle> hm, i should go to bed~
06:21:49 <sazzle> exam first thing tomorrow :(
06:22:01 <shapr> I should wake up.. I'm doing paying work.
06:22:02 <musasabi> Got gshow/gread to work, but they are not very optimal... back to the start.
06:22:32 * shapr whacks sazzle with the stick of unconsciousness
06:22:46 <shapr> I'm such a helpful person.
06:22:51 * sazzle flops on her keyboard
06:22:59 * shapr snickers
06:23:36 <Heffalump> are gshow and gread just direct Haskell implementations of what deriving Show and Read would do?
06:28:02 <musasabi> Heffalump: http://www.cs.vu.nl/boilerplate/library/Text.hs
06:28:56 <musasabi> not very nice when I need to store e.g. 200kb binary data strings.
06:33:02 <musasabi> Of course I could compress the files (with a small zlib binding), but I fear that reading would be too lazy.
06:34:26 <musasabi> a generic "blob" datatype could solve things, just a binary object that can be read/written to file handles.
06:38:07 <shapr> palomer``: have you written that MIDI code yet?
07:25:38 <shapr> foo, where's Pseudonym when I want to ask him about his code.
07:25:53 <Heffalump> code in what?
07:26:01 <shapr> his physics code
07:26:06 <shapr> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/physics/
07:26:16 <shapr> I'm trying to define meter, foot, and some other stuff like that
07:26:21 <shapr> and then test doing useful ops with those
07:27:05 <Heffalump> oh wow, he encoded dimensionality in type classes
07:27:14 <shapr> and in fundeps
07:27:16 <Heffalump> I always knew he had a sick mind :-)
07:27:21 <Heffalump> fundeps are part of type classes
07:28:03 <shapr> this is research for part of my book "Encoding Information in the Hindely-Milner Type System in a Nutshell"
07:28:07 * shapr sniggers hysterically
07:28:58 <shapr> anyway, do you see how to make a meter?
07:29:02 <Heffalump> where is amountOfSubstance defined?
07:29:40 <Heffalump> PhysicalUnit 1 :: Length is one metre
07:29:53 <Heffalump> I'm assuming that the whole thing is grounded in SI units.
07:30:21 <Heffalump> oh, amountOfSubstance is a variable. I don't quite see what it does.
07:31:00 <Heffalump> hmm, I get it. Bit of a broken concept, IMO.
07:31:53 <Heffalump> anyway, assuming SI units, PhysicalUnit 1 :: Length = 1m, and PhysicalUnit (12*2.54/100) :: Length = 1 foot
07:33:04 <shapr> you know of a better way of doing it?
07:33:32 <SyntaxNinja> so I know I asked this the other day, but has anyone had any success in making a nice concurrency abstraction via arrows?
07:33:56 <Heffalump> shapr: better way of doing what?
07:33:58 <shapr> RP's paper talks about parallel arrows
07:34:07 <Heffalump> RP?
07:34:13 <shapr> Heffalump: you said "broken concept" so I wonder, what's a non-broken concept?
07:34:15 <shapr> ross patterson
07:34:20 <Heffalump> Have you seen Koen Claessen's poor man's concurrency monad paper?
07:34:22 <SyntaxNinja> shapr: the FoP paper?
07:34:27 <shapr> yah, the FoP paer
07:34:28 <shapr> paper
07:34:57 <Heffalump> shapr: I would just leave out the amountOfSubstance parameter. You can't have dimensionality for scalars.
07:34:59 <shapr> I asked JH about arrows with commutable properties, he said it's just an implementation detail
07:35:34 <Heffalump> wdym by 'commutable properties'?
07:36:25 <shapr> iirc, I was asking about both darcs-style commutable checking, and concurrency stuff
07:36:37 * Heffalump causes a mini-avalanche on his desk trying to pull out his copy of FoP.
07:36:44 <shapr> kaboom!
07:37:05 <shapr> down the hall, Igloo is flooded with various printouts of research papers
07:37:21 <Heffalump> Ross Paterson's stuff talks about doing parallel stuff in hardware with arrows.
07:37:26 <Heffalump> So that's sort of concurrency.
07:37:32 <Heffalump> Igloo is opposite me, not down the hall :-)
07:37:33 <shapr> Mount Hefverest has exploded!
07:37:41 <Heffalump> I can even throw things at him when he insults me.
07:37:51 <Igloo> I have a defensive wall of scrap paper, though
07:37:55 * shapr snickers
07:37:57 <Igloo> For the avalanche, not hte projectiles
07:38:10 * Heffalump unprepares the projectile he was preparing to prove Igloo wrong
07:38:20 <SyntaxNinja> hey oxford guys, be forewarned that my brother is going to be in Oxford in a small number of weeks.
07:38:29 <SyntaxNinja> I might send him on a mission to acquire FoP for America.
07:38:39 <shapr> SyntaxNinja: what sort of concurrency abstracton do you want?
07:38:40 <Heffalump> the problem with Igloo's defensive wall is that it's just as high as my pile of books, and quite likely to collapse on him under the weight of my pile of books
07:38:44 <Heffalump> is FoP not available in the US?
07:38:53 <SyntaxNinja> Heffalump: can't find it :(
07:38:57 <Igloo> Tell him to break into comlab and look under a copy of the JVM spec
07:39:03 <Heffalump> that's bad, try emailing the editors to ask about it
07:39:14 * Heffalump hides his FoP
07:39:22 <Heffalump> badly
07:39:39 <Heffalump> are you going to ICFP?
07:39:40 <shapr> just make sure Mount Hefverest is delicately balanced.
07:39:41 <SyntaxNinja> shapr: well, basically something where each thread is an arrow, and they communicate via streams.
07:39:48 <neologism> huh, it seems like mine Bc. thesis will be about Haskell ;)
07:39:53 <SyntaxNinja> Igloo: I'm offended that you think my brother would touch the JVM spec.
07:40:05 <shapr> neologism: neat!
07:40:05 <SyntaxNinja> Heffalump: hm. not sure yet. probably.
07:40:08 <Igloo> :-)
07:40:19 <earthy> FoP... FoP... what was that again? :)
07:40:22 <Heffalump> I'm offended you consider the JVM spec dirty.
07:40:25 <neologism> shapr: it really is ;)
07:40:25 <SyntaxNinja> Heffalump: depends on how Aetion feels about me going off to another conference when most of the others haven't gone to any.
07:40:26 <Igloo> Fun of Programming
07:40:40 <shapr> SyntaxNinja: do they need to sync on the streams? or can they deal with it whenever they get to it?
07:40:59 <earthy> (reminds me too much of the course we had called `FUN'... short for `Functional Programming')
07:41:03 <Igloo> SynL Point out you can report back on what's happening  :-)
07:41:12 <SyntaxNinja> Heffalump: I remember trying to implement the "required assignment check" based on the spec, and I had the strong feeling that they based the spec on the implementation ;)
07:41:14 <earthy> (+ comma after the had)
07:41:56 <SyntaxNinja> Igloo: yeah... that's worked so far. we'll see.
07:42:09 <Heffalump> I think they based the spec on the obvious simple-minded reaching definitions analysis.
07:42:19 <Heffalump> i.e. one that's easy to implement
07:42:27 <Heffalump> you have to specify _something_ precisely
07:42:31 <shapr> SyntaxNinja: do you have any non-working attempts?
07:44:42 <SyntaxNinja> shapr: nah. I didn't want to implement something if anyone else had a working or non-working attempt they could show me.
07:44:57 <SyntaxNinja> shapr: my real goal is to get this into Yampa, but I figured I should try to figure out what it mgiht look like first ;)
07:45:36 <shapr> greetings wnewman 
07:45:48 <SyntaxNinja> Heffalump: yeah... it's been a few years, but I seem to remember that we implemented the passes in a different way (using the visitor pattern or something?) and it made it annoying to read the spec where it clearly wanted a particular implementation.
07:46:54 <Philippa> <earthy> (reminds me too much of the course we had called `FUN'... short for `Functional Programming') <- Nottingham does that too...
07:46:54 * wnewman looks at keyboard suspiciously, thinking "hello shapr" but mentally deeply traumatized by dozens of sent-to-the-wrong-IRC-channel incidents.
07:47:11 <shapr> wnewman: hiii, who are you?
07:47:20 <shapr> I'm Shae Erisson, programmer-savante.
07:48:25 <wnewman> William Newman, programmer in Dallas, TX; mostly a Common Lisper, but I like functional style where it fits.
07:48:48 <shapr> ah, my allegiance is towards programming, or maybe even just notions of computation
07:49:12 <shapr> so I'm not picky, though I tend to enjoy new paradigms and friendly user communities
07:50:38 <shapr> wnewman: so, have you started learning Haskell?
07:51:01 <shapr> Haskell has many nifty and worthwhile features, would you like an intro?
07:51:47 <neologism> shapr: I would like an intro ;)
07:52:00 <shapr> ok!
07:52:05 * thebug sits back for this one :)
07:52:16 * neologism sits next to thebug ;)
07:52:28 * saynte gets some popcorn
07:52:33 <shapr> oboy
07:52:45 * saynte yells rudely: "DOWN IN FRONT!"
07:52:48 <wnewman> I've learned enough Haskell that my language ignorance isn't the obstacle to understanding _Purely Functional Data Structures_, and hacked out a few hundred lines of toy code. I've ignored most of the seriously twisty stuff like monads though.
07:53:14 <neologism> I also dont understand monads at the level I like
07:53:52 <saynte> anyone here intimately familiar with the UPS parcel tracker?
07:53:53 <shapr> well, I can tell you about monads, but my explanation won't be as good as this one: http://www.nomaware.com/monads/html/index.html
07:54:26 <shapr> my summary is: monads are an abstraction, like objects in OOP are an abstraction
07:54:36 <neologism> shapr: I am afraid I have read it
07:54:41 <shapr> abstractions let you hide some of the implementation details for easy usage
07:54:47 <neologism> still dont understand
07:55:01 <neologism> hows that possible that I can sequence with monads?
07:55:18 <shapr> neologism: in that case, I recommend this next: http://www.cs.fit.edu/~satkin/monads.html
07:55:20 <Philippa> same way it's possible you can sequence with seq
07:55:59 <shapr> and I recommend that you load, alter, and hack on each step of those examples till you understand those examples.
07:56:15 <neologism> shapr: the problem is that I undestand examples
07:56:18 <neologism> I know how to use it
07:56:23 <neologism> but dont undestand the concept
07:56:26 <neologism> ok
07:56:33 <neologism> I'll read the urls you pointed out
07:56:35 <neologism> and then return asking
07:56:36 <neologism> ok?
07:56:39 <shapr> ok!
07:56:53 <saynte> I learn by reading the headers to the sections, and just guessing at the actual content.
07:56:56 <Pinnen> wazaaa? :-)
07:57:00 <Philippa> neologism: what part(s) of the concept do you understand, JOOI?
07:57:08 <neologism> what is "jooi" ?
07:57:14 <Philippa> Just Out Of Interest
07:57:14 <shapr> y0 Pinnen, howzit hangin homey?
07:57:35 <shapr> I thought it was like "1 0wn j00"
07:57:36 <Pinnen> shapr: hehe, It's just hanging :-)
07:57:37 <neologism> Philippa: I undestand that I can
07:57:37 <neologism> do
07:57:45 <neologism> c <- getLine
07:57:48 <neologism> putStr c
07:57:48 <Pinnen> shapr: n you?! :)
07:57:52 <neologism> nothing more ;)
07:57:57 <shapr> Pinnen: bara bra!
07:58:01 <Pinnen> shapr: kanon! :-)
07:58:02 <Philippa> hrmm, do you understand what the do notation translates into?
07:58:06 <shapr> kanin!
07:58:10 <Pinnen> :)))
07:58:16 <Philippa> you might find that helps understand the sequencing aspect, at least
07:58:31 <shapr> Pinnen: kanin! http://shapr.homelinux.net/~shae/blog/images/kanin.jpg
07:58:45 <neologism> Philippa: a bit
07:58:47 <Pinnen> shapr: HAHAHAHahahahHAH :D
07:58:58 <Pinnen> shapr: stiligt! :)
07:59:16 <shapr> truly
07:59:30 <Philippa> it sort of helps if the IO monad isn't your reference point too, 'cos it's something that can't itself be written in Haskell (on account of, uh, doing IO)
07:59:47 <shapr> yah
08:00:08 <shapr> it's better to understand the monads Maybe, List, State
08:00:33 <firefly> but they are no fun.
08:00:39 * firefly likes Forth
08:00:39 <shapr> neologism: what does a monad actually *do* ?
08:00:56 <shapr> for that matter, what does an object actually *do* ?
08:00:58 <Philippa> shapr: um, that's a really, really evil question to ask somebody :-)
08:00:59 <neologism> shapr: as I understand it it separes the actual action and the result given frm that action
08:01:08 <Philippa> though actually, a monad /does/ "do" something...
08:01:11 <firefly> or what does a type do?  What does a Char do, for example?
08:01:43 <firefly> neologism: the trick is in the >>, >>= things.
08:01:48 <shapr> you can describe a monad as a first class action
08:01:53 <neologism> huh
08:01:59 <neologism> dont understrand what "first class action" is
08:02:08 <shapr> what's first class function?
08:02:26 <neologism> you mean "add a b = a + b" type of functions?
08:02:29 <neologism> am a bit confused
08:02:36 <firefly> first-class "as in first-class value, first-class object".  Something you can treat as a full citizen in the language and for example pass around and store in lists.
08:02:54 <neologism> btw: what ISNT first class ?
08:02:56 <neologism> hof?
08:02:58 <firefly> or return from functions, for that matter.
08:03:06 <Philippa> neologism: functions in C aren't first class
08:03:07 <firefly> neologism: lots of stuff in most languages ;)
08:03:15 <neologism> in haskell?
08:03:32 <neologism> what isnt first class in haskell
08:03:37 <Philippa> hrmm. Types?
08:03:44 <shapr> yah, types aren't first class
08:03:55 <shapr> that's why we end up using phantom types
08:04:04 <neologism> ok
08:04:09 <neologism> I think I see the difference
08:04:18 <shapr> neologism: 'first class' means to me that I can stuff that thing into a variable
08:04:22 <shapr> let x = 1
08:04:24 <neologism> yes
08:04:25 <neologism> I see
08:04:27 <shapr> let x = \a -> a
08:04:32 <Philippa> neologism: mind if I take a different tack explaining what a monad is/does for a moment?
08:04:37 <shapr> let x = putStr "foo"
08:04:44 <shapr> but I can't do let x = :: Int
08:04:51 <neologism> Philippa: feel free to do so
08:04:57 <neologism> shapr: ok, I've understood
08:05:00 <shapr> oh oh, listen to Philippa, she's good at explaining and understanding this
08:05:19 <Philippa> 'k. Are you familiar with the concept of semantics? "The meaning of..." etc?
08:05:30 <saynte> I'm having a crisis, i'm starting to hate Haskell
08:05:41 * shapr feeds ritalin to saynte 
08:05:53 <neologism> Philippa: I am afraid I am not
08:06:01 <neologism> at least by the name
08:06:06 <neologism> can you explain it a bit?
08:06:19 <saynte> I'm turning into the "Incredible Haskell-Hulk". Haskell makes me angry and I go on a mean-green rampagel
08:06:30 * shapr feeds gamma-rays to saynte 
08:06:34 <Philippa> yeah. Imagine we've got a language for a moment, and that we understand how it's put together - the syntax
08:06:48 <neologism> yes
08:07:01 <saynte> haha, unless these gamma-rays help my brain solve haskell problems they won't help ;)
08:07:05 <Philippa> the semantics say what all of that actually means - for example, in a programming language they determine how to run or evaluate a program written in that language, effectively determining what the result of doing so will be
08:07:17 <neologism> yes
08:07:18 <firefly> saynte: I know how you can dissolve your brain.  Easy! :)
08:07:20 <neologism> I undestrand this
08:07:33 <neologism> ie. I know what semantic is
08:07:41 <saynte> firefly: aarrrg, different solve! lol
08:07:56 <neologism> Philippa: carry on (with the previous explanation)
08:07:58 <Philippa> OK, cool. Monads are used to provide a bridge between two sets of semantics, eg Haskell's semantics and Haskell-with-state semantics
08:08:15 <neologism> hm... thats what I have known before
08:08:23 <neologism> but - hows that achieved?
08:08:25 <Philippa> in particular, they let you embed bits of Haskell in Haskell-with-state (that's how you get Haskell-with-state) and vice versa
08:08:33 <neologism> yes yes
08:08:40 * jemfinch has always looked at monads as a way to thread something through computations.
08:08:41 <saynte> I'm trying to load data from an Xml file and the whole concept is making me loupy.
08:08:50 <neologism> but I dont see the link between (monad x) >>= and that bridge
08:09:41 <Philippa> That's because the bulk of that work is actually in return. >>= is used for carrying out stuff within the set of semantics on the other side of the bridge, as are all the operations used with the monad (eg all the IO operations in the IO monad)
08:10:25 <Philippa> return dumps bits of Haskell into the monad, and what you get out is a value of type "monad <foo>", which is your Haskell representation of what's going on on the other side of the bridge
08:10:26 <neologism> by (monad x) I meant return ;)
08:10:43 <neologism> so - may I think monad as "something" what carries state?
08:10:58 <neologism> state and the value itself
08:11:25 <Philippa> you can do, yeah. It's not a bad view from an implementation point of view - jemfinch's "threading something through computations"
08:11:46 <neologism> hm.. I finish reading that docs shapr posted
08:11:50 <neologism> lemme do so ;)
08:12:13 <Philippa> np. It's certainly useful understanding why the IO monad isn't "cheating", if that makes sense
08:12:36 <neologism> more: it carries state + algorithm which defines (based on that state) whats going on
08:12:44 <neologism> is this correct?
08:12:54 <Philippa> hrmm, sort of. The monad offers bits of code to operate on the internal state, yeah
08:13:04 <neologism> I mean abstractly
08:13:09 <Philippa> it's not quite an object or a class though, which is what that would suggest
08:13:17 <Philippa> actually, myself I reckon monads /generalise/ classes
08:13:27 <neologism> ie. that on a state of monad given value it depends what is to happen
08:14:07 <Philippa> kinda, yeah. It can decide to not bother carrying out stages of the computation for example, which is sort of how the Maybe monad works
08:14:26 <neologism> yes, thats what I meant
08:14:43 <neologism> ok, Iam finisgin my reading (thnx for help, I surely ask for more ;) )
08:14:50 <Philippa> np :-)
08:16:08 <jemfinch> shapr: so here's the $64,000 question: when you're writing in languages that are no Haskell, do you use Monads?
08:16:20 <Philippa> heh
08:16:40 * Philippa does near-approximations in C++ often, using classes to implement sets of semantics to an extent
08:16:57 <Philippa> but C++ doesn't have the machinery for monads proper. Would be tempted to in something like SML
08:17:06 * Heffalump uses monad-like code in SML
08:17:17 <Heffalump> and sort of in Java but not really
08:17:36 <shapr> Oleg has some nice monadic Scheme code on okmij.org
08:17:37 <jemfinch> Heffalump: lemme see!
08:17:39 <Philippa> actually, I really *really* want a strict language with good monad support atm, though that's sort of not all I'd like to come out of it
08:17:52 <Heffalump> not online anywhere, sorry
08:18:09 <Heffalump> Haskell 2 should be strict by default :-)
08:18:16 <jemfinch> Heffalump: well, in that case, can you define "monad-like code"?
08:18:18 <Heffalump> jemfinch: and only state/list monad type stuff, nothing deep.
08:18:31 <Heffalump> so just the pattern of passing state in and out, or using concatMap type things
08:18:42 <Philippa> come to think of it, my old memory management regime in C++ was looking a bit like the ST monad
08:18:44 <shapr> SyntaxNinja: you could make an Functor instance for FilePath
08:18:45 <jemfinch> Philippa: why does C++ not have the machinery, but SML does?
08:18:55 <Philippa> jemfinch: no HOF (that I can stomach to use)
08:19:11 <jemfinch> Philippa: objects with operator() aren't good enough?
08:19:22 <shapr> SyntaxNinja: actually, I just realized that's an excellent idea, I may write that tonite
08:19:27 <Heffalump> monads themselves just require type classes + special syntax
08:19:27 <jemfinch> shapr: where's Oleg's monadic code?
08:19:32 * jemfinch just sees a directory listing.
08:19:43 <Heffalump> but SML has neither of those, so writing generic monadic stuff in SML isn't really feasible (unless you use functors)
08:19:44 <Philippa> jemfinch: sort of survivable, but most of the time it's easier to just bodge it a little
08:19:54 <Philippa> Heffalump: you don't /need/ the special syntax...
08:20:13 <Philippa> 'snot overly pleasant without though
08:20:14 <Heffalump> no, but that's a large part of what 'monad support' in Haskell actually is
08:20:17 <jemfinch> why am I not seeing anything by SyntaxNinja?
08:20:28 <saynte> anyone have any direction they can give me on loading arbitrary types from a file?
08:20:30 <Heffalump> our course on Interpreters uses monads without the special syntax
08:21:38 <jemfinch> what's concatMap?
08:21:42 <Heffalump> it works ok, but they're quite simple interpreters
08:21:44 <neologism> may I ask for something more?
08:21:49 <Heffalump> concat (map f xs)
08:21:53 <neologism> (given that I roughly know what monads are)
08:22:02 <Heffalump> it's the way you implement bind in the List monad
08:22:05 <Philippa> neologism: sure
08:22:06 <jemfinch> Heffalump: why does it need its own function?
08:22:18 <Heffalump> convenience, nothing more
08:22:26 <neologism> Philippa: 1) what is "arrow" 2) what is "cathegory theory" ?
08:22:31 <neologism> in a few sentences
08:22:41 <Heffalump> I never actually use it, I just said it that way for simplicity.
08:22:44 <jemfinch> hah
08:22:45 <SyntaxNinja> jemfinch: shapr is replying to something I ust posted on a mailing list
08:22:47 <jemfinch> "in a few sentences"
08:22:52 <jemfinch> SyntaxNinja: oh, ok.
08:22:54 * jemfinch should subscribe.
08:22:59 <jemfinch> where do I subscribe at?
08:23:02 <Heffalump> Category theory is a huge overarching theory of algebra that encompasses things like sets, groups etc.
08:23:16 <Philippa> and happens to be good at describing semantics and the like
08:23:17 <SyntaxNinja> shapr: cool. do please :)
08:23:17 <Heffalump> Arrows are a abstraction that are more powerful and more complex than monads.
08:23:46 <neologism> ah...
08:23:52 <SyntaxNinja> jemfinch: I think you should subscribe to haskell, haskell-cafe, and libraries. just google for "haskell mailing list archives" or something
08:23:56 <neologism> whats the difference between arrow and monad?
08:23:56 <Philippa> I'm not convinced they're that more complex than monads actually, they seem to me to mostly be monads without the restriction that you have to support certain mechanisms (branching, recursion etc)
08:24:20 <Heffalump> arrows? They have more laws.
08:24:27 <Heffalump> (that you have to prove)
08:24:33 <jemfinch> SyntaxNinja: anyway, what did you just propose?
08:24:39 <Heffalump> they also subsume monads, which is evidence they are more complex
08:24:52 <SyntaxNinja> shapr: I posted that "walk" code to tickle people, since it's the kind of thing that I think people won't be able to resist implementing.
08:25:28 <SyntaxNinja> jemfinch: basically a haskell library for sysadmin type functions, kinda like OS.Path in python (in fact, that's what I'm calling it right now) with the idea that it'll go into the standard libraries later.
08:25:34 <Philippa> um, subsuming something doesn't necessarily imply complexity. Often it implies simplicity, but with the result that the implementation of whatever they subsume is more complex
08:25:46 <SyntaxNinja> me & simonMar talking about how we keep re-implementing a handful of things.
08:26:04 <Heffalump> philippa: agreed, but in this case it does imply complexity, IMO.
08:26:09 <Heffalump> certainly complexity of use and understanding
08:26:13 <saynte> (F => T) <=> T
08:26:43 <Philippa> yeah, that's fair enough. You can't give a lot of the ignoring-category-theory explanations you can with monads
08:27:12 <jemfinch> SyntaxNinja: that's the problem with small languages :)
08:27:22 <Heffalump> I don't really understand category theory and I roughly understand arrows.
08:28:05 <Philippa> hrmm, I thought that a year back. Mind you, I don't understand /much/ category theory now, I just have a reasonable intuition regarding categories and functors
08:28:10 <SyntaxNinja> jemfinch: what is?
08:29:01 <Heffalump> are you doing a PhD in category theoryish stuff?
08:29:28 <Heffalump> I have a reasonable intuition of categories and functors, and I once understood natural transformations. I got lost about the point of adjunctions, though.
08:29:36 <jemfinch> SyntaxNinja: that you end up rewriting things a lot.
08:29:50 <Philippa> nope. Got some notes from the Midland Graduate School intro course my dissertation supervisor wrote, meditated a little, avoided actually /doing/ any of it
08:30:05 <Philippa> the notes were very much geared towards compsci
08:30:19 <SyntaxNinja> you mean writing them from scratch? or duplicating effort because they're not in the standard.  I guess every language has to reimplement things, but in smaller languages fewer people have to implement them.
08:30:38 <Philippa> will go back next time I need the insight into something I'm doing, I guess
08:31:18 <jemfinch> SyntaxNinja: this is why I'm not a fan of standardized languages :)
08:31:19 * Heffalump wonders why the MGS needed a course on functional programming
08:32:05 <Philippa> heh. Well, I'd never deliberately used a functor for programming purposes, people taught SML courses won't've used lazy evaluation...
08:32:15 <Philippa> so I guess there's some point in providing some unifying ground
08:32:29 <Heffalump> though Graham's course seems to have been entirely about Haskell
08:32:59 <Philippa> which would be fairly typical of Graham :-)
08:33:03 <Heffalump> well, yes :-)
08:33:24 <Philippa> actually, it looks rather a lot like he just lifted everything from the course he teaches first years...
08:33:42 <Heffalump> and added some more research-oriented stuff
08:34:52 <Philippa> haven't leafed through the notes - but the countdown problem bit's something you could hand the smarter first years, and the compiling exceptions correctly bit most folks'll ignore the actual proof
08:35:30 <Philippa> bloody hell, the take-home exam was the coursework he gave for G51FUN
08:36:07 <Heffalump> :-)
08:38:48 * Philippa laughs at Conor McBride's description of his dependantly typed programming course
08:39:19 <Heffalump> Conor McBride is great.
08:39:36 * Igloo is looking forward to his bit of AFP
08:39:40 <Heffalump> he really should have got the job at Nottingham.
08:40:22 <neologism> where can I found definition of IO () monad ?
08:40:35 <Heffalump> definition in what sense?
08:41:05 <neologism> hm... something where is written how it works
08:41:12 <Igloo> It's just a state monad with magic state and magic builtin primitives
08:41:17 <neologism> ie. IO x = 
08:41:24 <Heffalump> and exceptions
08:41:40 <Smerdyakov> neologism, it has to be implemented outside of Haskell. There is no "IO x = ..." for it.'
08:42:18 <Philippa> you could probably "cheat" an implementation and have IO x = IO x somewhere, but it wouldn't be meaningful, it's all primops
08:42:20 <Igloo> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))   is GHC's definition, but I doubt that's particularly helpful to you
08:42:39 <neologism> there must be something defining >>= etc. 
08:42:42 <neologism> sint?
08:42:46 <neologism> isnt?
08:42:49 <Smerdyakov> neologism, it's all implemented in C.
08:42:55 <Igloo> Yes, the same as for a state monad
08:42:56 <Smerdyakov> neologism, or at least all the interesting stuff is.
08:43:05 <Heffalump> with exceptions!
08:43:19 <neologism> ok
08:43:21 <Igloo> There's nothing about exceptions in the code that defines >>=
08:43:45 <Heffalump> the code that defines >>= doesn't *ACTUALLY* pass around the RealWorld either.
08:43:49 <Heffalump> It's just a token representing it...
08:44:05 <Philippa> neologism: easier to look at an example state transformer monad, or something else actually implementable in Haskell
08:44:06 <Heffalump> so the implementation is not the same as a state monad.
08:44:15 <Heffalump> So there.
08:44:33 <Heffalump> Igloo smells, and I'm right and he's wrong.
08:44:47 * thebug notes that it hath been said many a time that the IO monad is a bad example
08:45:01 <thebug> Bad Example (TM)
08:45:25 <neologism> Philippa: I am just studying State.hs
08:45:52 <neologism> thebug: IO monads is something I will be using the most so its natural choice
08:46:14 <Igloo> Oh, http://www.cl.cam.ac.uk/users/am/ claims to be working on optimistic evaluation. I wonder if that's up-to-date
08:46:15 <Philippa> FWIW, I tend to trip myself up over the type system at least 5 times each time I sit down to implement a monad from scratch (which hasn't been often, monad transformers are a good thing)
09:04:04 <wnewman> Make sure you have good backups of your firstborn.
09:04:23 <wnewman> sorry rwong channel as per premonition earlier
09:05:32 <Smerdyakov> Off with his head!
09:11:52 <shapr> greetings mmorvant 
09:12:00 <mmorvant> hey
09:12:15 <shapr> have any Haskell questions?
09:12:38 <mmorvant> I was hoping to thank a few of the guys who helped me out on friday
09:12:52 <thebug> how did that turn out, btw?
09:13:00 <mmorvant> got what I needed
09:13:10 <thebug> cool
09:13:30 <mmorvant> the key peice was that +++ mostly means OR
09:14:39 <mmorvant> after learning that I was able to convert the parsers to perl regexprs
09:16:09 <mmorvant> i'll try and pop back by later I see i just missed firefly
09:16:16 <mmorvant> bye
09:21:00 <shapr> it's amazing, he's the second guy who actually came back days later and said thanks.
09:58:00 <Igloo> I swear GHC works by magic
09:59:26 <Igloo> int2Integer#/Int2IntegerOp doesn't seem to be defined anywhere. Hmm, perhaps it all just works once it's bootstrapped
10:00:03 <Igloo> But I still don't really see how
10:00:04 <thebug> :)
10:00:31 <thebug> gremlins would be my guess
10:01:37 <Igloo> Oh, actually, I think my built tree might be incomplete
10:32:21 <musasabi> Is h{Get,Put}Array really the only way of doing efficient binary IO for opaque data?
11:03:45 <Igloo> Aha, it all makes rather more sense once you remember that # will be zh in some cases
11:05:09 <cgibbard> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf is interesting
11:28:16 <shapr> hiya reffie 
11:28:48 <stepcut> greetings shapr!
11:28:57 <shapr> y0 stepcut, wassup?
11:29:00 <thebug> (!)
11:30:42 <stepcut> shapr: not much. I have made some progress on the unix pipes stuff. I actually some working code, now I just need to clean things up, and patch up all the lose ends 
11:31:03 <stepcut> loose ends even
11:32:06 <SyntaxNinja> stepcut: does this happen to have something to do with pipes and arrows?
11:32:57 <stepcut> SyntaxNinja: could not figure out how to implement 'arr' without the Read/Show constraint
11:34:22 <stepcut> SyntaxNinja: It's the final outcome of that attempt -- just no arrows
11:34:25 <SyntaxNinja> stepcut:  are you planning to publish this somewhere?
11:34:32 <SyntaxNinja> oh, no arrows. ahwell :)
11:34:41 <SyntaxNinja> so what's the goal, ooi?
11:35:10 <stepcut> SyntaxNinja: its in my public arch archive, but I plan to document and make a formal release eventually
11:36:34 <shapr> greetings oligarca 
11:37:11 <shapr> cgibbard: is all that code dumped out into .hs files somewhere?
11:37:46 <oligarca> howdy
11:39:05 <shapr> oligarca: have any Haskell questions?
11:39:58 <oligarca> hum. don't think so. shapr with his usual eagerness to clarify haskellers! :-P
11:40:39 <SyntaxNinja> stepcut: cool.
11:41:20 <shapr> oligarca: well, you were just sitting there, looking like no one had been friendly to you...
11:42:24 <oligarca> lol! a haskellady in distress!
11:42:33 <shapr> cgibbard: I have a request....
11:43:04 <shapr> I want to make a collection of "most visually impressive diagrams in research papers."
11:43:33 <shapr> like that diagram from Chakravarty and SPJ's recent paper on class-local stuff
11:44:09 <shapr> anyway, if you happen to run across any, I'm interested.
12:06:36 <palomer``> shapr: midi code? hah!
12:08:48 <shapr> palomer``: what? you're not done yet?
12:20:24 <palomer``> heh
12:20:34 <palomer``> don't hold your breadth 
12:21:28 <reffie> hi shapr 
12:21:58 <jemfinch> how does TCO interact with lazy evaluation?
12:38:07 <stepcut> hehe: Y is recursion so self-referential?
12:38:40 * shapr grins
12:38:45 <shapr> nice poem, eh?
12:38:49 <stepcut> :p
12:49:08 <cgibbard> shapr: is all what code dumped out into .hs files?
12:49:18 <shapr> in that paper
12:50:54 <cgibbard> ah, not sure
12:53:32 <cgibbard> http://www.math.uwaterloo.ca/~dmjackson/publications/ -- ought to be some visually impressive diagrams (if not equations) in Prof. Jackson's papers.
12:57:38 <cgibbard> For example, I think page 19 of the paper on the quadrangulation conjecture for orientable surfaces is quite neat.
13:00:46 <cgibbard> and the entire map catalogue is pretty neat :)
13:42:39 * vegai shudders at the monads.
13:45:28 <shrimpx> heh
13:47:02 <vegai> every time I read more about them I think I understand them
13:47:49 <shrimpx> i think most literature is confusing on purpose
13:47:52 <vegai> when I really don't
13:47:56 <vegai> on purpose?
13:48:21 <wagle> cgibbard: which paper for page 19?
13:48:32 <vegai> no, I think this technique is too complex to be teached in a simple way
13:48:40 <shrimpx> dunno, i think i get the just of monads, and now when i look at literature it seems unnecessarily contrived. especially when it starts mentioning category theory and crap
13:49:34 <vegai> well... some of them are. I've found a couple pragmatic ones too
13:50:07 <vegai> the problem is, even those lead me to thinking that monads are the last thing people should be doing in computer programs
13:50:26 <vegai> or wondering whether
13:50:29 <shrimpx> also a bunch of authors think it's useful to keep blabbering about the Maybe monad, like it contains the essence of the condept
13:50:32 <shrimpx> concept
13:50:44 <cgibbard> wagle: http://www.math.uwaterloo.ca/~dmjackson/publications/quad.ps
13:50:48 <Heffalump> I think the state and maybe monads are the best examples.
13:51:59 <cgibbard> A monad is a kind of container with two associated functions:
13:52:25 <cgibbard> return, which given an element returns a container containing that element
13:53:18 <vegai> yes, I've read that a dozen times at least, cgibbard ;)
13:53:25 <Codex> For learning monads, the monadic parser combinators is probably the best source. (especially if you already know formal languages..)
13:53:28 <cgibbard> and bind (>>=), which given a box full of a's and a function from a's to boxes of b's, applies the function to each of the a's in the box, and collects the boxes together into one
13:54:27 <cgibbard> it is this collecting process which is the interesting part
13:54:49 <vegai> yes, nothing of this is new in theory
13:55:08 <cgibbard> right, just trying to put it in another light :)
13:55:22 <cgibbard> this is all there is to monads
13:55:37 <cgibbard> every monad is a functor - so it might be good to understand those first
13:55:59 <shrimpx> hah he said functor
13:56:31 <Codex> category theory is useful to understand :-)
13:56:33 <cgibbard> a functor is just a container type which supports map
13:56:50 <cgibbard> You don't even have to understand it from the category theory perspective.
13:57:02 <monotonom> I think http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm is a fine explanation.
13:58:12 <shrimpx> i think the finest explanaition comes from the intuition you gain by coding with monads and frustrating yourself to death until it works and you understand why :)
13:58:29 <shrimpx> at least that worked for me
13:58:35 <shrimpx> from a pragmatic point of view anyway
13:58:48 <cgibbard> Yes, actually using monads is the easiest way to get a good perspective on them.
13:58:56 <monotonom> I also think that actually Phil Wadler's explanations are free of all the problems being complained about here.
14:01:47 <shrimpx> and i at least partially understand the connection between monads and CT monads, but i've convinced myself that that knowledge is close to useless wrt programming. it's fun brain exercise tho :)
14:02:05 <vegai> CT monads?
14:02:11 <shrimpx> category theory
14:02:14 <vegai> ah
14:02:28 <cgibbard> The connection between haskell monads and category theory monads is a pretty short jump.
14:02:42 <cgibbard> Look at Monad.join, first of all.
14:02:55 <cgibbard> Since this is part of the CT definition of a monad.
14:03:05 <vegai> anyway, it soon seems like not worth the effort
14:03:29 <cgibbard> If you understand the Haskell definition, you already understand the CT definition
14:03:32 <vegai> Paul Graham's texts are making more sense every day ;)
14:03:46 <monotonom> http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs
14:05:22 <monotonom> The finest application of the list monad as a nondeterminism monad. :)
14:05:34 <cgibbard> Stare at http://planetmath.org/encyclopedia/Monad.html, replacing T with m, eta with return, and mu with join.
14:05:40 <cgibbard> and that's it
14:07:24 <vegai> anyway, the point is that I've been (though passively) trying to understand them for about a year
14:07:57 <monotonom> That sounds about right. It also took me roughly one year passively.
14:08:08 <vegai> I have learnt a great deal, of course, but I feel they shouldn't be that hard
14:08:24 <cgibbard> They really shouldn't :)
14:08:39 <monotonom> I also want to note that the idea of ADT took ten years to take off.
14:08:58 <monotonom> (And OO, another ten years.)
14:09:27 <vegai> ah, well... good to know. Thanks, monotonom 
14:10:16 <vegai> cgibbard: can they be improved, do you think?
14:10:34 <cgibbard> Monads themselves, or the explanations thereof?
14:10:58 * vegai shrugs.
14:11:05 <cgibbard> I think that a lot of the explanations are unnecessarily complicated.
14:11:19 <monotonom> Every small step of abstraction takes a programmer individually a year to learn, and the programmer community as a whole a decade to be convinced.
14:11:53 <cgibbard> It takes that long just to formulate a good explanation. :)
14:12:25 <cgibbard> I think the problem in this sort of thing is mostly a pedagogical one.
14:13:53 <cgibbard> I have this idea in my head - it comes out of lots of other complicated ideas, but is itself quite simple. Currently it's expressed in terms of those complicated notions - how do I translate it into English?
14:14:20 <monotonom> First translate it into mathematics, preferrably category theory.
14:14:38 <cgibbard> Well, see - here the complicated language is category theory.
14:14:53 <monotonom> I am not kidding.  If you use CT wrong, of course all troubles abound.  If you use CT right, it simplies.
14:15:51 <cgibbard> Sure - but most programmers (even real programmers) don't know category theory, and despite what good it might do them, it is quite a lot to swallow at once.
14:16:16 <cgibbard> And CT is brutally hard to comprehend without lots of good examples of categories.
14:16:33 <monotonom> Well the other venue --- bad science IMO, but it buys you popularity --- is to translate it into program code.  Monkey's don't understand math or English, but they can read code, oh-so-open-source, etc.
14:17:03 <monotonom> And note that monkeys don't understand English anyway.
14:17:46 <opet> monkeys, no ' needed
14:17:53 <opet> :)
14:17:57 <cgibbard> I'm not even talking about the monkeys here :)
14:18:27 <Riastradh> http://angryflower.com/bobsqu.gif
14:18:36 * vegai smirks.
14:18:51 <cgibbard> However, I've had quite a bit of success teaching my friends here what monads are about. It seems that a whiteboard and some pictures go a long way.
14:18:58 <monotonom> It was a typo.  I actually understand English.
14:19:16 <Riastradh> monotonom, yeah, but it's still fun to paste that URL at people.
14:19:22 <monotonom> Yes
14:19:40 <monotonom> ObLaughter: Hahahahaha....
14:21:54 <monotonom> I don't understand where people get the idea that category theory is complicated.  Set theory is ten times more complicated, and people grok it.
14:21:56 <vegai> anyway, to sum up, I don't understand monads, so I hate them ;)
14:22:09 <cgibbard> monotonom: Mathematicians grok it :)
14:22:42 <monotonom> Well coders also grok it.  Just look at java.util.Set.
14:22:56 <Riastradh> Category theory has a lot of obscure- & arcane-sounding terminology that sounds way too abstractily confusing to most people.
14:22:57 <cgibbard> That's finite sets :)
14:23:04 <cgibbard> hehe
14:23:39 <Smerdyakov> vegai, what is there not to understand?
14:24:08 <monotonom> Category theory is more abstract, not more complicated.  Set theory is more concrete.  People are dysfunctional when it comes to abstractions, that's the reason.
14:24:30 <Riastradh> Indeed.
14:24:40 <vegai> Smerdyakov: I don't understand why.
14:24:46 <Smerdyakov> vegai, why what?
14:25:02 * Codex have been trying to learn CT as a better/simpler set theory.
14:25:09 <vegai> why they are
14:25:59 <monotonom> Not to say that all abstractions are appropriate.
14:26:13 <monotonom> err, not to say that all abstractions are appropriate all the time.
14:26:49 <Smerdyakov> vegai, do you mean "why monads are used for IO in Haskell"?
14:27:02 <cgibbard> Category theory can make complex things easy to understand, but it can also confuse simple things unnecessarily.
14:27:03 <vegai> rather "Why use monads at all"
14:27:14 <Riastradh> vegai, why compute at all?
14:27:20 <Smerdyakov> vegai, clearly an answer to what I said is an answer to that, eh?
14:27:26 <cgibbard> To say that something is a monad is not saying much.
14:27:37 <Riastradh> Monads are just generalizations of computation.
14:27:42 <monotonom> For example if you really want a kind of membership notion, then trying to add enough axioms and operators for that is herculean --- may as well just use set theory.
14:27:43 <Codex> vegai: monads are there to preserve equational reasoning while still being able to do IO.
14:28:04 <vegai> no, monads are not about IO
14:28:14 <Riastradh> No one claimed that, vegai.
14:28:35 <cgibbard> The list monad is I think the best example to understand first.
14:28:53 <cgibbard> Until you understand the list monad, don't bother looking at anything else.
14:29:02 <monotonom> I like the list monad very much.  http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs
14:29:33 <cgibbard> Just comprehend what it is that return and bind do. For extra points, have a look at join as well.
14:29:55 <vegai> cgibbard: it seems like I understand all the isolated examples, but can't see the big picture (if any?)
14:30:53 <Riastradh> vegai, why have abstraction?
14:31:04 <Marvin--> I think the state monad is a good example
14:31:06 <Riastradh> Monads are just abstraction across computation.
14:32:10 <Marvin--> oohboy
14:32:12 * Marvin-- is nervous
14:32:36 * Riastradh sneaks up behind Marvin-- and does something.
14:32:41 <Marvin--> eek!
14:32:48 <Marvin--> not the something!
14:33:01 * Riastradh cackles evilly as he stalks away.
14:33:05 <Codex> vegai: what do you think about side effects in functional languages?
14:33:32 <Marvin--> tomorrow is the big salary discussion thingy
14:33:37 <cgibbard> Suppose that I have a box of dollars, and suppose that for a dollar, you will give me a box of apples. If I give you my box of dollars, you can pour all the boxes of apples you would have given me into a large box, and give me that.
14:34:12 <Marvin--> whoa, large box
14:34:20 <cgibbard> (which is also a box)
14:34:40 <vegai> Codex: icky!
14:34:56 <vegai> also in less functional languages =)
14:35:09 <Riastradh> Pay up, cgibbard!
14:35:14 <cgibbard> This is the bind operation on a monad. The monad is "boxes of real world objects".
14:35:34 * Riastradh readies a truckload of apples.
14:35:39 <Codex> vegai: monads solve that problem about side effects -- with a little cost of complexity. :)
14:35:41 <cgibbard> You are a function from dollars to boxes of apples.
14:36:09 <vegai> Codex: I'm not so sure if the cost is little. Also, monads aren't the only solution to that problem
14:36:21 <cgibbard> It's sort of a Zen problem, this explaining.
14:36:52 <Marvin--> cgibbard: are you going to work Mu into this too? :-)
14:36:53 <Riastradh> Monads solve no problems about side effects.
14:37:06 <cgibbard> Hehe
14:37:08 <Codex> vegai: yes, most languages just ignore the problem :)
14:37:22 <Codex> rias: they dont?
14:37:26 <Marvin--> (too much Hofstadter)
14:37:31 <vegai> Codex: from a first glance, unique types seem more elegant
14:37:31 <Riastradh> They can, when emulating side effects, alleviate a little difficulty often caused by 'true' side effects, but only to a short extent.
14:37:52 <vegai> Codex: I will look into them more later certainly =)
14:38:05 <cgibbard> But it's true - to explain an abstraction is difficult, because your student has to throw away the example.
14:38:13 <vegai> (sleep now)
14:38:31 <Riastradh> Uniqueness types are certainly of interest.
14:38:46 <Riastradh> They solve an entirely different problem from monads, however.
14:38:48 <cgibbard> What is a container?
14:38:56 <Riastradh> Monads tend not to 'solve a problem,' indeed.
14:39:08 <Marvin--> why is container?
14:39:39 <Marvin--> okay, I will stop making fun of Zen now :)
14:39:58 <Codex> wouldnt "m u" be a container? (from Hofstadter)
14:40:14 <cgibbard> I think the view of monads as just a special kind of container with a couple of methods defined on it is the most practical one for programming.
14:40:36 <monotonom> I concur.
14:40:37 <cgibbard> Understanding what return and bind are supposed to do isn't all that hard.
14:40:46 <cgibbard> Or even return and join.
14:41:42 <cgibbard> If you understand what an instance of Functor is - just a homogeneous container - then you're already most of the way there.
14:44:54 <cgibbard> Sure, the container might have a label on it (like with state), it might be limited in the number of objects it contains (like with Maybe) and you might not be able to get things back out of it once you put them in (like with IO), but these are things which are best dealt with in the context of those specific examples.
14:46:42 <Codex> modus ponens. :)
14:52:25 <thebug> hmm ... ghc 5 does not have the 'network' package?
15:04:01 <Marvin--> thebug: isn't it called 'net'?
15:05:29 <thebug> hmm
15:52:38 <stratocaster> Given a sorted list of Enums, I want to return a list containing all consecutive sequences within that List. ['a', 'b', 'b', 'c', 'e', 'f'], for example, should return ["abc", "abc", "ef"] (probably after reversing each of the sublists). Is there a particularly straightforward way to do that?
15:57:00 <stratocaster> I know about 'succ', for what it's worth. Just wondering if there's some 'magic' (liftM?) way to do this.
16:02:03 <Lemmih> stratocaster: I'm not quite sure I understand what you wanna do.
16:02:32 <Smerdyakov> I am quite sure that I don't understand.
16:04:27 <wagle> a -1-> b -1-> c
16:04:34 <wagle> e -1-> f
16:05:14 <stratocaster> What are those '-1->', wagle?
16:05:26 <wagle> length 1 connection
16:05:46 <wagle> (wondered if it would be obvious... guess not)
16:06:23 <keverets> why is it not ["abc", "ef"] then?
16:06:38 <keverets> (assuming the missing 'd' is why the list is split)
16:07:03 <stratocaster> keverets: Right, the missing 'd' is why it's split. I want "abc" twice because 'b' occurs twice.
16:09:03 <stratocaster> The situation is, I'm making a card (poker) game, and want to scan an arbitrary-sized hand for 'straights', where straights are any two-or-more card sequences (for my purposes). [C Two Hearts, C Two Clubs, C Three Spades] should return two different 'straights'.
16:10:00 <wagle> i'm thinking [a,b,b,c,e,f] => [[a],[b,b],[c],[e],[f]] => [[[a],[b,b],[c]],[[e],[f]] => ...
16:11:52 <stratocaster> Yea, that's an improvement.
16:12:52 <wagle> where the list monad/comprehension should be able to turn [[a],[b,b],[c]] into [[a,b,c],[a,b,c]]
16:13:16 <stratocaster> Right.
17:54:16 * np_hard wrote zip_with in Perl at work today
17:57:02 <blackdog> funky
17:57:51 <np_hard> yeah, it was pretty funky
17:57:57 <np_hard> with map grep and reduce
17:58:03 <np_hard> seemed like Perl was missing something
17:58:41 <np_hard> a lot of HOFs seem a little less useful with no type system though
17:58:51 <np_hard> or at least a bit more rash
17:59:18 <blackdog> Yeah. I wouldn't dare build castles in the air without a solid typing foundation.
18:01:34 <blackdog> if you know how it works in haskell already, though, you can usually transliterate into perl without losing too much comprehensibility
21:18:35 <lambdawar> morning
21:20:33 <Pseudonym> G'day.
21:54:34 <blackdog> anyone got any recommendations for doing regular expressions in Haskell? 
21:58:40 <ozone> there's john meacham's regex library, which he based off my =~ playing
21:59:28 <ozone> http://www.mail-archive.com/haskell@haskell.org/msg14421.html
22:01:25 <blackdog> that's right, i remember seeing the reference to Andrew Pang. :)
22:03:10 <blackdog> hm, this looks dead sexy. I may drop Text.Regex after all...
22:03:44 <ozone> that's Andre, mrak
22:04:13 <blackdog> Not according to that message...
22:04:22 <blackdog> But he said sorry, so I guess it's ok.
22:04:39 <ozone> that's OK, i got called 'Andrea' once
22:05:05 <ozone> at least i got vindicated yet again
22:05:10 <ozone> (syntactic sugar is the goods)
22:06:02 <ozone> the regex matching on lists (as opposed to just strings) is really nice
22:07:17 <blackdog> looks worth checking out... might dive into code for an hour or so. (coding for SS is sweet. :)
22:09:02 <ozone> coding for multimedia is more leet!
