00:00:30 <Maddas> how good would Haskell be to implement, say, a board game, concerning the libraries needed for the GUI thingies?
00:01:00 <saz> well
00:01:05 <Cale> Maddas: I suspect it would be alright - you could even use hopengl
00:01:12 <saz> a first year assignment I was involved in made a board game
00:01:18 <Maddas> heh
00:01:19 <saz> and had a web interface
00:01:29 <Maddas> I'd want a "proper" interface though, since it'll be networked
00:01:29 <saz> that was fun... :)
00:01:42 <Maddas> I'd love to do it in Haskell to learn :)
00:02:18 <jiwon> saz: me, too. although I was only allowed to use Java. :/
00:02:28 <saz> erk, java
00:02:39 <Cale> hmmm... I wonder how easy it is to combine wx stuff and hopengl stuff. I suspect that it shouldn't be too hard.
00:02:58 <Maddas> I thought about doing it in Java, which would probably be rather easy (having many GUI libraries), but I don't like the language much
00:03:40 <Cale> Yeah, Java is annoying to use. It's far too verbose to be fun.
00:03:55 <saz> my complaint exactly
00:04:16 <cleverdra> WhirlyGig wg = (WhirlyGig) generateWhirlyGig();
00:04:17 <Maddas> Certainly
00:04:21 * Maddas ponders looking at Nice
00:04:30 <Cale> Considered python?
00:04:34 <Maddas> no
00:04:34 <saz> Nice?
00:04:35 <jiwon> saz: um, about 'not able to define function in shell', does that apply to ghci, too?
00:04:41 <saz> jiwon: yes
00:04:51 <Maddas> saz: Sounds like a souped-up Java, generates compatible bytecode and lets you use Java libraries
00:04:54 <jiwon> ah..., how inconvient...
00:04:55 <saz> jiwon: i'd use ghci over hugs anyway though
00:05:01 <saz> Maddas: ah
00:05:01 <cleverdra> Maddas - like pizza?
00:05:03 <Darius> jiwon: But you can use 'let f x = x + 3' in GHCi.
00:05:11 <Maddas> pizza?
00:05:18 <cleverdra> you can also do 'x <- getChar' in GHCi.
00:05:31 <jiwon> ok. I'll use ghci. :)
00:05:46 <saz> well
00:05:47 <Maddas> I think I'll stick to Haskell or Java for practical reasons though (I'll have to learn more Java anyway later on, and I'm already learning Haskell)
00:05:50 <saz> hugs makes a great calculator
00:05:56 <saz> it's faster to load than ghci
00:06:01 <saz> and easier to use than say, BC
00:06:34 <Darius> Maddas: Odersky and some others have also made a new language that works nicely with Java.
00:07:18 <Cale> If I had to use Java, I'd probably use Nice.
00:07:21 <Darius> But I'd imagine wxHaskell has the GUI things you'd want.
00:07:26 <Cale> Yeah
00:07:38 <Cale> wxHaskell is rather easy to use.
00:08:50 <Maddas> Darius: sounds cool.
00:09:13 <clausen> Cale: you're needed on #math :p
00:09:24 <Cale> heh - okay
00:09:44 <Maddas> I think I'll give wxHaskell a try then
00:09:49 <Maddas> But first, I should go on learning Haskell :-)
00:20:08 <jiwon> hm, what does "and1 :: Bool -> Bool -> Bool" mean?
00:20:21 <jiwon> I thought it should be "and1 :: Bool Bool -> Bool"
00:20:27 <Maddas> and1 takes two arguments of the type Bool and returns a Bool
00:20:30 <jiwon> (I'm a beginner, I'm reading tutorial..)
00:20:39 <jiwon> ah...
00:20:44 <Maddas> I think :)
00:21:15 <cleverdra> and2 = and1 True
00:21:34 <cleverdra> isTrue = and2
00:22:05 <Darius> isTrue = id
00:22:49 <cleverdra> (isTrue False) has surprising results, with that definition.
00:23:10 <Darius> False?
00:23:25 <cleverdra> Perhaps I should've named it 'truep' =)
00:24:38 <Cale> jiwon: yeah, the point is that you can think of and1 either as a function which takes two bools and returns a bool, or as a function which takes one bool and returns a function from bool to bool.
00:25:29 <jiwon> Cale: ok, and that means, I can declare and1 as "and1 :: Bool Bool -> Bool"?
00:25:54 <jiwon> or do I have to take the latter view?
00:26:10 <Maddas> Aren't both views equivalent?
00:26:12 <Cale> well, that's not syntactically correct. You could define it as being and1 :: (Bool, Bool) -> Bool
00:26:26 <Cale> i.e. it takes a pair of bools and returns a bool
00:26:33 <Cale> but this is less flexible
00:26:50 <Darius> And ugly ;)
00:26:53 <jiwon> in that I should call it with tuple argument?
00:27:06 <Maddas> yes
00:27:28 <jiwon> ok.. thank you all. :)
00:27:33 <jiwon> haskell is very interesting!
00:27:37 <Maddas> Yes
00:27:42 <Maddas> Certainly :-)
00:27:55 <det> can someone send a test message for me ?
00:28:03 <det> email, that is
00:28:09 <Maddas> sure
00:28:24 <Maddas> If you tell me your e-mail address, that is :0
00:28:26 <Maddas> s/0/)/
01:27:02 <earthy> damn snow
01:29:15 <bring> same here
02:37:47 <shapr> @yow
02:37:47 <lambdabot> Where's SANDY DUNCAN?
02:38:07 <shapr> good morning #haskell!
02:38:22 <ski> good morning
02:38:30 <shapr> hej ski, vad hÃ¤nder?
02:38:57 <ski> fixar runt med tcshrc och sånt
02:39:35 <shapr> andvÃ¤nder du #haskell.se ocksÃ¥?
02:39:45 <ski> hm, nej
02:40:01 <ski> denna client är console-baserad
02:40:09 <shapr> ah, okej
02:40:14 <ski> hittar inte xchat
02:40:48 <ski> (finns förmodligen nån annan gui-irc)
02:41:21 <ski> hmm, fast man kan kanske joina flera iaf
02:58:35 <ski> hello skew
02:58:44 <skew> ski:hello
02:59:03 <ski> heard about haskell ?
02:59:12 <skew> I guess talking by name is a bit overkill in here.
02:59:37 <ski> (depends on talk load)
02:59:39 <skew> I guess I was thinking #python, which is also quiet at the moment
03:00:13 <ski> mm
03:01:01 <ski> have you coded anything in haskell ?
03:01:34 <skew> sure
03:01:39 * ski is just trying to not be so quiet RN
03:02:11 <ski> what do you think about it ?
03:02:16 <skew> most recently, a TCP client and server we had to write in Java for a class
03:02:29 <skew> The inability to define exception handling combinators in particular bugged me
03:02:49 <ski> skew : you had to do it in Java, but did it in haskell ?
03:03:14 <skew> no, I did it in java, then did it again in Haskell, and in python because I wes bored and annoyed
03:03:22 <ski> ok
03:03:37 <skew> Twisted wins for the server
03:03:56 <ski> hmm, what's twisted ?
03:04:05 <skew> It's a networking framework for python
03:04:11 <ski> (i see there is such a channel)
03:04:19 <ski> mhm
03:04:25 <skew> It's all asynchronous, based on events for which you register callbacks
03:04:58 <skew> And some objects representing deferred results for communication.
03:05:15 <ski> ?
03:05:21 <skew> It could stand an interface using monads, or at least continuations though
03:05:38 <skew> You have a Deferred, which says 'A result will arrive here at some point'
03:06:06 <ski> or, perhaps there'll be nothing, if the network connection was broken, right ?
03:06:18 <skew> You attach callbacks to the deferred object, which will fire whenever somebody feeds a value into it (usually some server waiting for more data)
03:06:20 <ski> (perhaps an exception, then ?)
03:06:34 <skew> Well yes, you also attach a function to call in case of error.
03:07:18 <skew> And then you chain on lots of functions (an error return from either the normal or error handler of one stage goes to the next 'errback', similarly normal results from either go to the next 'callback')
03:07:29 <skew> I'm just learning - the code was my first
03:07:36 <ski> so the callbacks will run when(if) the result has actually been transmitted ?
03:07:55 <skew> Well, it's more general than that. These things are first class, so you can use them for whatever
03:08:06 <ski> ?
03:08:52 <skew> For a connection you have an object with a function the framework calls whenever data comes in
03:09:22 <skew> As well as some more for the connection being established, failing to be established, and being lost
03:09:30 <ski> also, is the Deferred a stand-in, that will become the result, or must one still extract it, after the transmission ?
03:09:51 <skew> You don't extract results from it, you attach more callbacks to it.
03:10:04 <skew> kind of like IO
03:10:06 <ski> ok
03:10:45 <ski> well, that could well be a monad (as you said)
03:11:03 <skew> like some_random_server.lookup_a_webpage(args).addCallback(print_value).addCallback(lambda value: value + 12), etc.
03:11:11 <skew> I'm not sure it's quite a monad
03:12:24 <skew> Maybe more like an arrow?
03:12:46 <ski> not sure. what makes you think it's not exactly monad ?
03:13:00 <ski> return ?
03:13:02 <skew> Hmm, I guess error handling is just either
03:13:18 <skew> each return is chained into the next callback, so that's not a problem
03:13:30 <skew> exceptions are also packaged up into an error description, I think
03:14:08 <ski> i guess return should given a deferred that can't fail (prolly immediately satisified, also)
03:14:28 <ski> s/given/give/
03:15:01 <skew> if you add callbacks to a deferred that's already been realized they execute immediately
03:15:12 <skew> modulo some special trickery
03:15:39 <skew> I guess it probably is a monad.
03:15:50 <ski> that seems ok  (modulo trickery i don't know :)
03:17:10 <ski> any link to api ?
03:17:21 <skew> It's at twistedmatrix.com
03:18:44 <skew> Let's see, we'll want a type like Deferred a b, containing an (a -> IO b) or so.
03:18:50 <ski> hh, which module/package is the deferred stuff in ?
03:18:55 <ski> hm
03:19:01 <skew> twisted.internet.defer, I think
03:19:28 <skew> Then we want to be able to stick on a (b -> IO c), which would be Deferred b c. Smells more like an arrow
03:19:48 <skew> (Well, there should be appropriate Either types on all this)
03:20:06 <skew> By the way, no need to play 
03:20:11 <skew> "greet the newbie"
03:20:33 <skew> If anything, more "grab his feet and drag his head out of the clouds"
03:20:35 <ski> hm, so one doesn't stick on a function from b to something .. ?
03:20:59 <skew> Well, you are chaining them all together.
03:21:31 <ski> hm, so next added will get the result of the previous as input ?
03:21:42 <skew> Yeah, it's not just a reader
03:22:08 <skew> Or, Reader
03:22:27 <ski> can one add (after-the-fact) one more call-back which accesses the original value ?
03:22:40 <skew> Not that I know of, but I haven't used them much.
03:28:56 <skew> well, there is something like chainDeffered which branches the callback chain from what I understand of the description
03:31:27 <ski> mm
03:49:05 <ludde> is there some way to load two modules at the same time in GHC, so I can access functions from both of them from the command line
03:50:04 <ludde> nevermind, it's just me that's stupid
03:51:08 <skew> A niftyness is that Haskell will complain that some name is ambigous between the imports, but only if you use it
03:51:43 <ski> ludde : in ghci ?
03:51:48 <ludde> ski: yea
03:51:56 <ludde> ski: but i figured it out, i was stupid
03:52:02 <ski> i've wanted that too
03:52:21 <skew> ski: huh?
03:52:43 <ski> (well, actually i was using hugs then)
03:53:47 <ludde> i just made a toplevel module and wrote import there
03:53:50 <ludde> and loaded it
03:54:30 <skew> between :m <list of modules>, and :m + <more modules I want>, and :m - <modules I want to remove from the working set>, ghci makes it pretty to import some modules
03:54:48 <ski> but you can't access internals of both that way  (or does ghci not allow access to module internals like hugs ?)
03:54:56 <skew> I don't remember quite how it goes with getting at the internals
03:55:09 <ski> skew : hmm, isn't that the case in Ada too ??
03:55:25 <skew> the import stuff? I wouldn't know
03:55:25 <ski> skew : (the name clash complaint)
03:55:55 <skew> it certainly seems nicer than either taking the latter or disallowing the mixture of imports even if you never make an ambigous reference
03:57:12 <ski> sure
04:03:22 <skew> :load file1 file2 will load both files, and if both are interpreted you will have access to any top level expressions
04:05:43 <ludde> ah
04:05:48 <skew> Hmm, at least the guide claims.
04:05:57 <skew> I'm having some trouble trying it out
04:07:22 <skew> okay, got it
04:08:04 <skew> yeah, :load Test.hs Test2.hs will leave you working in the toplevel of Test,
04:08:29 <skew> but then if you type :m + *Test2, or :m *Test *Test2 you will have all toplevel declarations of both.
04:08:36 <skew> This only works for interpreted modules though
04:08:48 <skew> The "*" means something like "open
04:08:54 <skew> or "working at top level"
07:07:20 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/", "ghc 6.2 is out", "ghc rpms: http://haskell.org/~petersen/rpms/ghc/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html"]'
07:07:20 --- topic: set by shapr on [Sat Jan 24 08:38:50 2004]
07:07:20 --- names: list (clog ski Slashdog bring Igloo smkl kaol SyntaxNinja jameson el_diego apmuf Darius shawn `John Taaus-dvorak forester gdsx gene9 Matt-W andersca Maddas reltuk lumm0x naren Cale debug gebner ludde mattam cmeme tic nerdlor jiwon CrewdenX wax jagular keverets pilsnerman1en ejt xkb malik Riastradh Lunar^ kosmikus|away lambdabot esap isomer dennisb emu norpan polli e-dawg skylan themus saz liiwi shrimpx_ asmodai ned cleverdra det jasonw rubix)
07:07:20 --- names: list (shapr phubuh earthy ecraven yazirian Segora)
07:13:09 <shapr> Slashdog: I think it's standard haskell
07:13:17 <shapr> and I can probably find an example ,if you give me a moment
07:14:02 <shapr> ok, I found some.
07:15:21 <shapr> but nothing simple
07:16:16 <shapr> Slashdog: partitionM uses "~(ts, fs) <- partitionM p xs" http://www.haskell.org/hawiki/PreludeExts 
07:20:12 <Lunar^> bring: I'm happy about the fast coding session of yesterday
07:20:26 <bring> me too
07:20:47 <shapr> me three
07:21:10 <Lunar^> bring: I'm keeping a background thread about transactions
07:21:13 <shapr> that is, if you include the XmlRpc stuff in that fast coding session
07:21:23 <bring> sent your patch to Krasimir, we'll see if he wants to include it in the upcoming release
07:21:25 <ski> me for
07:21:33 * shapr grins
07:21:38 <Lunar^> bring: I saw the mail :)
07:21:46 <bring> shapr: I enjoyed that too
07:23:21 <shapr> Slashdog: http://www.haskell.org/tutorial/patterns.html - section 4.4 "called a lazy pattern, and has the form ~pat"
07:28:07 * bring has finally found something where Caps Lock is useful
07:29:23 <Lunar^> bring: ?
07:29:33 <bring> autoconf macros
07:29:41 <bring> they are all upper case
07:29:46 <Lunar^> urg
07:30:15 <bring> almost half of my configure.ac seems to be upper case
07:30:56 <Lunar^> X-Spam: 38.0 ;)
07:31:03 <bring> :)
07:32:42 <bring> wtf, VAR=val is ok, but not VAR = val
07:32:52 <bring> stupid macro language
07:42:08 <yazirian> I have a hatred for GNU autoconf/automake that knows no boundaries of space or time.
07:42:45 <yazirian> This is probably a hatred borne of my prior exposure to distutils.
07:54:40 <Slashdog> thanks shapr
07:55:42 <andersca> bring: what are you autoifying?
07:56:01 <bring> HaskellDB configuration
07:56:27 <bring> anyone know a better solution than autoconf?
07:56:50 <bring> that doesn't require the user to install loads of stuff just to run configure?
07:56:51 <andersca> nope
07:56:58 <andersca> what do you need to install?
07:57:02 <andersca> just sh afaik
07:58:28 <bring> oh, I meant that the other solution shouldn't require stuff
07:58:46 <bring> that is, that it should require as little stuff as autoconf
07:59:02 <bring> hmm, I feel verbally challenge
07:59:04 <bring> d
07:59:21 <bring> have trouble getting that sentence understandable
08:00:19 <andersca> ah, now I understand
08:01:03 <Lunar^> bring: Is there a dev. page for HaskellDB fresher than haskell.org/haskellDB/ ?
08:01:16 <bring> no, it's not up yet
08:01:24 <bring> very soon now...
08:01:28 <Lunar^> :)
08:02:33 <bring> just need to get configuration, documentation, webpage and that sort of thing done
08:03:37 <Lunar^> But it's working ?
08:05:58 <bring> mostly, yes
08:06:21 <Lunar^> :)
08:06:30 <bring> we are still working on a few things, for example date and time types
08:07:43 <Lunar^> hard ones
08:08:05 <bring> some other things will probably not be in the first release, like lazy row retrieval
08:09:31 <Lunar^> It's not a big deal
08:10:00 <Lunar^> I will be able to clean a lot of bad code from my project
08:10:20 <bring> you mean it's not important or it's not difficult?
08:12:07 <Igloo> How will lazy row retrieval of multiple selects work with a limited number of cursors (is that the word I want)?
08:12:27 <Igloo> ISTR there is generally either 0 or 1
08:13:26 <bring> we're not sure, that's one of the reasons we haven't written it yet :)
08:14:01 <Igloo> :-)
08:14:16 <bring> you might have to limit it to some given number of open queries at a time, but that would be ugly
08:14:22 <Igloo> Can you tell if it's being lazy? i.e. would insertions/updates alter what is returned?
08:15:00 <Igloo> If not laziness would just be a space optimisation and could be done whenever possible, but ignored if not
08:15:37 <bring> I guess that it would be the same as if you did a normal query, then an insert, then fetched the results from the query, all strict
08:15:50 <bring> that is, no, insert wouldn't change the results
08:16:02 <Igloo> Although you'd probably want a way for the programmer to hint whether a new select should be non-lazy or if an existing one should be forced and the new one made lazy
08:16:17 <bring> I was only thinking of laziness in terms of svaing space, yes
08:17:15 <bring> what we are thinking is that there should be a strictQuery and a lazyQuery, that's how the original HaskellDB did it
08:19:13 <Igloo> Would lQ fail if no cursors are available?
08:19:45 <bring> not sure, it's all a matter of choice I guess, we haven't really thought to much about that yet
08:19:51 <bring> what do you think?
08:20:50 <Igloo> I think either it should fail or there should be a function you can ask whether it will succeed
08:22:04 <Igloo> And that there should be a query that tries lazy and if it fails does strict instead
08:22:28 <Igloo> I should point out I've never used HDB, nor do I have immediate plans to, though  :-)
08:22:33 <bring> :)
08:24:08 <ski> hmm, dunno, but could there be 'infinite queries' (like infinite lists) ?
08:24:38 <ski> perhaps depends on underlying DB system ?
08:25:35 <Igloo> I don't think you could construct such a query with standard SQL
08:25:54 <Igloo> Oh, with the programming stuff you might be able to. Dunno if that's part of the standard or not.
08:26:41 <ski> what standard ?  SQL ?
08:26:58 * esap blinks.
08:27:10 <Igloo> Yup
08:27:50 <ski> programming stuff in HDB or other ?
08:28:56 <Igloo> I mean things like the perl/python support in databases. There's generally a simple procedural language, but I don't know if it's the same in all of them.
08:29:32 <ski> ok, hmm
10:42:53 * bring hates autoconf
10:47:25 <andersca> hehe
10:47:45 <andersca> bring: I know just the thing for you
10:47:56 <bring> beer?
10:48:24 <andersca> http://www.cafeshops.com/leuksman.7112875?zoom=yes
10:49:21 <bring> haha
11:02:01 <bring> autoconf seems impossible to debug, you just have to get it right from the start
11:02:23 <andersca> usually I just copy the macros
11:02:36 <andersca> and lookup stuff in the autoconf book if I get into more trouble 
11:02:49 <bring> yeah, but I couldn't find any for checking for haskell modules
11:03:06 <andersca> hmm, good point
11:03:07 <bring> do you understand the quoting rules for writing macros?
11:03:21 <andersca> no, I've never had to write one :)
11:03:45 <bring> the autoconf manual is not very helpful
11:04:32 <andersca> http://sources.redhat.com/autobook/
11:04:34 <andersca> seen this?
11:06:27 <bring> nice, thanks
11:17:18 <rubix> maybe you could look at the autoconf macros used in other haskell projects
11:29:49 <bring> good point, I just have to find some package that requires another haskell package
11:30:51 <ski> bring : why 'req. another package' ?
11:31:11 <ski> (haskell package)
11:31:23 <bring> that's what I'm working with, I need to find where HSQL is and what drivers are included
11:31:57 <bring> so I'm checking if the Database.HSQL.{ODBC,MySQL,PostgrelSQL] modules are available
11:32:42 <bring> I've written macros to do that for GHC and Hugs, but since I don't know m4, I seem to have quoting problems all over the place
11:32:58 <ski> hmm, i really dunno, but darcs is written in haskell and seems to have an autoconf generated configure. perhaps it looks for some other haskell package ?
11:33:37 <bring> I'll have a look
11:33:38 <Igloo> Why do you need to know where it is? For ghc at least it should be registered, no?
11:34:01 <Igloo> So all you have to do is try to compile something with -package whatever and see if it succeeds
11:36:08 <bring> yes, but I want to be able to compile against a non-installed HSQL
11:36:17 <bring> kind of stupid I guess
11:36:31 <bring> but nice for development
11:37:09 <bring> darcs has some macros that look useful
11:37:19 <bring> thanks, ski
11:37:43 <ski> mm
11:37:51 <Igloo> For development could you not just have a copy in the current directory?
11:38:15 <Igloo> Or would it complain about duplication rather than overriding?
11:38:24 <bring> well, that could work
11:38:47 <bring> but I like to have a working copy of haskelldb and one of hsql sitting side by sidde
11:39:04 <bring> that way I can edit either, recompile, test
11:39:07 <bring> and commit
11:39:48 <Igloo> If they have different namespaces then that ought to work fine
11:40:17 <bring> actually the finding where it is part is ok, its getting the compilation macros quoted right is the problem for me
11:40:22 <Igloo> ./HaskellDB/ checked out, ./HSQL checked out, ./Test.hs
11:41:01 <bring> well, then you'd still have to tell ghc/hugs to look in HaskellDB for HaskellDB stuff and HSQL for HSQL stuff
11:41:20 <bring> since the modules have names like Database.HSQL.ODBC etc.
11:41:36 <Igloo> ./Database/HSQL/ checked out then
11:42:14 <Igloo> As long as they're separate trees it should work fine
11:42:42 <bring> true
11:44:06 <bring> but my problem is really with the simple 'try to compile and see if it works'
11:44:34 * bring should stop whining an learn m4
11:45:32 <bring> I can't seem to get the quoting right
11:46:49 <Igloo> What do you have that isn't working?
11:56:58 <bring> hmm, great, I don't think it's the macros, I removed them all, still the same thing
11:57:48 <bring> Igloo: I'm trying to find what the problem is, do you have any tips on how to debug autoconf files?
11:59:56 <Igloo> No, sorry
12:04:53 <monotonom> You should not debug an autoconf file. You should start from the specification and derive the autoconf file correctly by stepwise refinement and algebraic laws.
12:04:55 * monotonom ducks
12:05:16 <bring> :)
12:26:58 <phubuh> what the hell
12:27:24 <phubuh> http://www.phubuh.org/~phubuh/Skeden.hs -- does this file work in ghci for anyone?
12:27:39 <phubuh> I get this three times: Skeden.hs:9: Data constructor not in scope: `Ã'
12:27:50 <forester> bring: how's your autoconfing working out?
12:28:15 <bring> actually got it working about 2 seconds ago
12:28:29 <forester> ohh, cool
12:28:31 <bring> it was a bunch of different things
12:28:52 <forester> are they for the release tarball?
12:28:52 <phubuh> heh, it worked when I reinserted the definition... some strange characters must've slipped in
12:30:23 <bring> the autoconf stuff?
12:30:51 <forester> yuepp
12:31:07 <bring> yeah
12:31:32 <bring> it's not finished, but there's not too much left
12:33:47 <phubuh> I wonder if I could use Template Haskell to generate Show definitions for arbitrarily large tuples?
12:34:07 <bring> hey, that would be nice
12:34:41 <bring> I could use that to support arbitary size hetergenous arrays and structs in XmlRpc
12:35:12 <bring> well, now Show, but if Show works, it should work for XmlRpcType too
12:35:19 <bring> anyone know if that works?
12:42:00 <SyntaxNinja> phubuh: does my example on the wiki make things any more clear?
12:44:01 <phubuh> SyntaxNinja: the ones on TemplateHaskell?  those might come in handy :)
12:45:04 <shurik> I'm reading and reading and can't see what is all fuss about Haskell
12:46:24 <shurik> all problems given in tutorials could be easily solved using imperative languagges
12:47:33 <Maddas> shurik: tutorials aren't there to solve problems
12:47:34 <Maddas> they are to teach
12:48:31 <Maddas> there to, even
12:49:30 <phubuh> shurik: but those imperative languages don't give you the safety and reasonability of purely functional programs
12:50:07 <shurik> safety of what?
12:50:18 <monotonom> All imperative languages have a pure functional subset. Thus all problems in the world can be solved easily in such imperative languages.
12:50:27 <Maddas> haha
12:51:15 <shurik> 1st year computer science if a problem can be solved using one language it could also be solved using any other programming languigae
12:51:21 <shurik> you are missing the point
12:51:30 <phubuh> yes.  does that mean all programming languages are equally good?
12:52:35 <shurik> in fact, when you have a problem , you usually need to give the program some external data and get the output, real world problem, Haskell doesn't address these problems well
12:52:52 <SyntaxNinja> shurik: that is a common misconception.
12:52:59 <SyntaxNinja> (about whether or not Haskell handles it well)
12:53:14 <phubuh> since you're knowledgeable to make that kind of statement, I assume you can tell me what's wrong with Haskell's IO system?
12:53:44 <shurik> I didn't say it doesn, it just I've been readingh tutorial for several days and can'twhere Haskell could be usefull
12:54:28 <shurik> to prove correctness of the program?
12:54:36 <SyntaxNinja> shurik: do you know several other languages?  for instance, do you know C and C++ (imperative and OO)?
12:55:21 <shurik> can't say I know other langugaes well but I've been using C/C++/Java/Ada95 and Perl
12:55:29 <shurik> in the past
12:55:58 <shurik> Perl adopted some features from functional languages
12:56:02 <SyntaxNinja> so in each of those languages, you end up thinking in a somewaht different way. you express the problems differently, right?
12:56:20 <SyntaxNinja> it's not about what the languages _can_ do, it's about what they help you to express
12:56:51 <shurik> wrong on both counts
12:57:14 <esap> expressing things is important
12:57:17 <shurik> it's about which language is easier to use to solve a particular set of problems
12:57:36 <esap> shurik: that doesn't work for large problems
12:57:54 * bring realises he hasn't had lunch yet
12:58:05 * bring realises it's 10 pm
12:58:16 <shurik> you divide a projects to a number of problems and solve it the way you want
12:58:26 <SyntaxNinja> shurik: you don't express the problem differently depending on the language?
12:58:26 <shurik> anyway
12:58:42 <shurik> I'd read a bit more and see if find something special about Haskell
12:58:55 <phubuh> don't get hung up on the no side effects thing; I don't actually care about it very much.  it's pretty much a necessity with lazy evaluation, though.  I like Haskell because of how expressive it is compared to the other languages I've tried
12:58:57 <esap> shurik: yes, but if your subproblems do not have easily expressible semantics, you cannot combine them, and thus your solution doesn't work.
12:59:51 <shurik> how do you think big projects are solved?
13:00:02 <shurik> esap what are on about?
13:00:50 <esap> shurik: well big projects are built in small steps.
13:01:30 <esap> shurik: each steps adds new functionality to the system.
13:03:07 <SyntaxNinja> shurik: maybe the ultimate point is that if you want to find the "special" things about haskell, it's not the tutorials you should be reading.
13:05:06 * esap suggests Wadler for good intro.
13:06:22 * phubuh suggests a less hostile attitude.  it's just a language!
13:06:42 <SyntaxNinja> heh
13:14:31 <shurik> where did you see hostility?:>
13:15:03 <shurik> I guess you are right, it's just a language and there's no point to go and waste my money on a book
13:18:46 <SyntaxNinja> shurik: you consider language books a waste of money?
13:19:01 <SyntaxNinja> I guess much of what one needs to know is on the internet.
13:20:38 <shurik> I considered to buy a book on "Haskell programming language'
13:20:48 <shurik> which could be a waste of money
13:20:55 <shurik> now don't make things up
13:21:27 * esap learned Haskell by reading from the H98 report.
13:21:53 <esap> In particular, standard prelude is very good for learning to write programs in Haskell.
13:22:05 <phubuh> I haven't read any books on Haskell either, and I'm doing okay... so yeah, you might not want to bother.  I bet you could learn it faster with some educational textbook, though...
13:24:55 <SyntaxNinja> shurik: maybe you misunderstood me when I said that tutorials are not the place to look? I wasn't suggesting that you buy a book.
13:28:32 <SyntaxNinja> that was somewhat surreal
13:29:00 <Maddas> yeah
13:44:01 <phubuh> hmm.
13:45:05 <phubuh> I want to generate an instance definition for (Foo a, Foo b) => (a, b), for any number of tuple elements
13:45:16 <phubuh> (using Template Haskell, that is)
13:45:40 <phubuh> there's a type constructor tupleT, but it takes an Int, and not, say, a list of types
13:49:18 <phubuh> ah, I apply it, like (,,) Int Char, right?
13:54:02 <ADEPTOmatto> hi
13:54:06 <phubuh> hi hi!
13:54:18 <ADEPTOmatto> do you know ylwbr???
13:54:31 <phubuh> I don't think so
13:54:36 <phubuh> what/who is it?
13:54:39 <ADEPTOmatto> yellobird....
13:54:45 <ADEPTOmatto> my friend....
13:54:56 <ADEPTOmatto> yellowbird
13:55:06 <Riastradh> I know swlabr, though.
13:55:17 <ADEPTOmatto> no...
13:55:24 <ADEPTOmatto> can you help me?
13:55:40 <Riastradh> It would help us to help you if we knew what you needed help with.
13:56:13 <ADEPTOmatto> do you know the server address for bosk???
13:56:14 <SyntaxNinja> Riastradh: yello :: bi -> rd
13:56:31 <ADEPTOmatto> yes... yellowbird...
13:56:47 <SyntaxNinja> !!
13:56:54 <ADEPTOmatto> ...for bo2k!
13:56:58 <Riastradh> yellow !! (bi + rd)
13:57:10 <SyntaxNinja> ADEPTOmatto: did you try nslookup?
13:57:14 <ADEPTOmatto> do you know him?
13:57:30 <ADEPTOmatto> what is nslookup?
13:57:40 <SyntaxNinja> it tells you server addresses!
13:57:50 <SyntaxNinja> its deprecated though, use "host" instead
13:58:00 <Maddas> err, bo2k as in the trojan Back Orifice 2000?
13:58:10 <ADEPTOmatto> yes...
13:58:14 <SyntaxNinja> !!!
13:58:20 <ADEPTOmatto> i dont understand...
13:58:29 <SyntaxNinja> ADEPTOmatto: ask yellowbird
13:58:30 <ADEPTOmatto> what the server address?
13:58:44 <ADEPTOmatto> do you know yellowbird?
13:59:36 <SyntaxNinja> ADEPTOmatto: does yellowbird have b02k?
14:00:07 <ADEPTOmatto> i dont know...
14:00:22 <SyntaxNinja> hmm
14:00:22 <chris`laptop> Isn't yellowbird the old version? Raggeddog is the updated format
14:00:33 <Maddas> Today must be the day of weird visitors
14:00:35 * phubuh is lost
14:00:52 <Maddas> either that or I am hallucinating
14:01:05 <ADEPTOmatto> but... ydo you know him?
14:01:07 <chris`laptop> I suspect the latter
14:01:39 <ADEPTOmatto> ??
14:01:44 <Maddas> chris`laptop: That would explain why my shoes are talking.
14:01:52 <chris`laptop> Maddas: Mine do that too
14:04:42 <SyntaxNinja> darn
14:04:53 <SyntaxNinja> I was hoping I'd get to kick him after making fun of him some more.
14:04:56 * Maddas shrugs helplessly
14:05:15 <chris`laptop> I still liked the idea of sending him haskell named "virus-kit..exe"
14:05:30 <SyntaxNinja> yeah, that probably would have been the best thing to do, but I was too lazy
14:05:47 <SyntaxNinja> I guess it's not too late...
14:09:08 <SyntaxNinja> so anyway... haskell... yeah.
14:11:47 <phubuh> haha
14:14:01 <bring> that haskell thing you guys are always talking about, is this it: http://www.haskells.net/ ?
14:14:57 * Maddas nods emphatically
14:18:15 * phubuh looks all over that page and still has no clue what the fuss is over the Haskell
14:18:16 <SyntaxNinja> haha
14:20:09 <Maddas> phubuh: maybe you shouldn't buy a book about it! 
14:21:03 <phubuh> "Sorry, no matches were found containing yellowbird."
14:21:08 <phubuh> this the Haskell stuff is truly useless
14:27:41 <phubuh> ghc-6.2: panic! (the `impossible' happened, GHC version 6.2):
14:27:41 <phubuh>         Malformed predicate
14:27:43 <phubuh> :(
14:28:02 * phubuh isn't very good with Template Haskell
14:29:19 <phubuh> http://www.phubuh.org/~phubuh/ShowTuples.hs is completely insane, isn't it?
14:30:32 <det> phubuh: what do you expect from an academic toy!?
14:31:02 <phubuh> bah!
14:34:57 <phubuh> the advocates promised me that when it type checked, it'd work! :(
14:36:07 <det> haha
14:36:26 <det> with all their fancy "proofs" and "theorys"
14:36:57 * clausen loves fancy proofs and theorems :)
14:37:57 <phubuh> do you guys "know" template haskell?  ShowTuples.hs is a mostly cut-n-paste hack from http://www.haskell.org/pipermail/glasgow-haskell-users/2003-July/005467.html, which uses some crazy moon version in which all the names are different, so I'm pretty sure about everything is wrong
14:38:54 <clausen> no :)
14:39:20 <phubuh> it's supposed to generate instance (Show a, Show b) => Show (a, b) where show (a, b) = show a ++ "," ++ show b, when given 2, and (a, b, c) when given 3, etc
14:41:35 <SyntaxNinja> phubuh: I put all my TH knowledge onto the wiki and then forgot it :)
14:41:52 <phubuh> ah, -ddump-splices is useful :)
14:41:57 <phubuh> SyntaxNinja: haha :)
14:48:37 <Darius> phubuh: Since you are tied to GHC anyways, in Control.Monad there is a handy replicateM function.
14:49:23 <phubuh> oh, nifty.  so I could do names <- replicateM n (gensym "a")?
14:49:24 <Darius> sequenceQ should just be sequence by the way
14:49:29 <phubuh> oh, whoops
14:49:48 <Darius> phubuh: It's not wrong, it's just overspecific.
14:49:52 <phubuh> ok :)
14:51:38 <phubuh> oh, and (foldl1 appT (map varT names)) is very wrong, I think
14:51:53 <phubuh> it should be something like (foldl appT (tupleT n) (map varT names)), no?
14:53:20 <Darius> Yes.
14:53:59 <phubuh> by the way, the error message with -ddump-splices is:
14:54:04 <phubuh>     deriveTupleShow 5
14:54:05 <phubuh>   ======>
14:54:05 <phubuh>     instance (Show a'0, Show a'1, Show a'2, Show a'3, Show a'4) =>ghc-6.2: panic! (the `impossible' happened, GHC version 6.2):
14:54:05 <phubuh>         Malformed predicate
14:54:59 <Darius> phubuh: The functions at http://www.haskell.org/pipermail/template-haskell/2003-September/000176.html may be useful.
14:56:03 <Darius> Also I think you just want return instead of sequence at the end of deriveTupleShow minus the outermost []'s.
14:56:23 <Darius> (Well, it would be more sensible looking that way, it should do the same thing).
14:56:59 <phubuh> that gives Couldn't match [Dec] against DecQ
14:57:32 <phubuh> ah, there are some useful tuple functions in there, thanks
14:58:52 <Darius> Ah, you don't want the return or the []'s.
14:59:17 --- mode: zahn.freenode.net set +b *!*@206.169.168.190
14:59:32 <Darius> instanceD already returns an DecQ
14:59:57 <phubuh> shouldn't deriveTupleShow return a Q [Dec] though?
15:00:19 <phubuh> DecQ is just Q Dec
15:01:02 <Darius> Meh, I guess if it works.
15:01:14 <phubuh> it doesn't, but it type checks :)
15:02:25 <Darius> One thing you may want to do is put an example instance declaration in [d| |] brackets and print the (runQ-ed) result to see what form things should have.
15:03:48 <phubuh> hmm, alastair's code seems to be written for some old version of TH, too.  it looks easy to translate, but I'm stuck on (ConTag (TupleTag n), ...), because ConT expects a String
15:07:43 <phubuh> oooh, clever
15:09:25 <Darius> Yeah, the name changing is annoying.
15:09:50 <Darius> And now there's supposed to be a bigger change in the whole way it works.
15:11:10 <phubuh> ghc-6.2: panic! (the `impossible' happened, GHC version 6.2):
15:11:10 <phubuh>         Failed binder lookup: a {- tv a10j -}
15:11:11 <phubuh> baaaaaaah
15:11:55 * phubuh cries
15:11:55 <phubuh> I don't even need this thing!
15:11:55 <phubuh> I'll postpone it :-)
15:49:29 * bring is done with the autoconf stuff after only about 9 hours
15:57:34 <forester> bring: that's great
15:58:18 <forester> I've been looking into the cddb format, not too hard to parse
15:58:31 <bring> cool
15:58:49 <bring> so when do we get out 10GB database?
15:58:54 <forester> haven't written anything cool yet, just some library handling
15:59:01 <andersca> isn't the IMDB data available too?
15:59:02 <forester> bring: :)
15:59:08 <andersca> that would be a good test case 
15:59:39 <forester> andersca: yeah, and then you could use it to pick up your fancy movies?
15:59:43 <bring> yes, and it would be cool to use that with phubuh's DC client
16:00:00 <forester> bring: :)
16:00:47 <forester> i was thinking about the internal representation while parsing and inserting
16:01:43 <forester> i mean, it can't be strict, well maybe by using your newly installed RAM...
16:02:01 <andersca> doesn't it have to be strict?
16:02:03 * andersca knows nothing
16:02:13 <phubuh> it could have a command for automatically viewing all the movies on IMDB's top 100 in order :-)
16:02:27 <phubuh> without intermissions
16:02:32 <bring> well, you'd only get in trouble if you try to list all the songs
16:02:46 <bring> as long as you do some specific query you'd be fine
16:03:02 <bring> but, you're right, we need lazy queries
16:03:13 <andersca> oh, lazy queries
16:03:13 <andersca> neat
16:03:43 <forester> mm, need to look into that till next release then
16:03:55 <forester> that would be some fine upgrade at least
16:04:45 <forester> andersca: 6 am sharp tomorrow?
16:05:37 <andersca> if by 6 you mean 9 then sure
16:06:12 <forester> andersca: maybe breakfast at my place, i need to get rid of some food before leaving
16:07:28 <andersca> might work
16:07:41 <forester> and then i figured you could do the dishing while im gaming :)
16:08:23 <forester> well see you tomorrow guys, good night
16:08:47 <andersca> night
16:11:02 * bring is going to bed
16:11:05 <bring> good night
17:52:42 --- mode: capek.freenode.net set +b *!*@206.169.168.190
17:56:43 --- mode: capek.freenode.net set +b *!*@206.169.168.190
23:10:45 <shapr> good morning #haskell!
23:10:55 <Maddas> morning, shapr!
23:11:10 <Maddas> shapr: you look like Neo :P
23:13:59 <shapr> I do?
23:14:17 <shapr> people tell me I look like Faramir
23:14:18 <Maddas> I think so
23:14:32 <Maddas> heh, I didn't watch any LOTR other than 1
23:15:15 <shapr> I think Keanu has a narrower face than I do.
23:15:42 <Maddas> Possibly, but you certainly have something that he has
23:15:59 <shapr> starey eyes?
23:16:03 <Maddas> haha
23:16:07 <Maddas> I'm not sure what :-)
23:16:20 <shapr> a manic passion to find out what the matrix really is? ;-)
23:16:41 <shapr> horrendous sleep schedules?
23:16:46 <Maddas> heh, if that reflects in the look, maybe ;)
23:16:55 <shapr> are there pictures of you online?
23:16:55 <Maddas> oh, who doesn't have horrendous sleep schedules.
23:17:00 <Maddas> no
23:17:04 <Maddas> Luckily :-)
23:17:13 <shapr> I woke up at 7am today, after only eleven hours of sleep.
23:17:34 <Maddas> Heh. Ok, you have horrendous sleep schedules
23:17:48 <Maddas> How can you sleep eleven hours? I would feel too much like wasting my time
23:18:10 <shapr> I've been going on four or five hours of sleep for a week or so.
23:18:34 <Maddas> Ah, ok.
23:19:13 <shapr> well, I'll take that Neo similarity as a compliment.
23:19:54 <shapr> so, written any cool code lately?
23:20:08 <shapr> or have any digital pictures of yourself you want to send me? :-)
23:20:42 <Maddas> Haha
23:20:45 <Maddas> Neither :-)
23:22:00 <Maddas> In fact, the only picture of me that I could think of being on the net is a bad parody on some funny picture of David Hasselhoff and another boy
23:23:02 <Maddas> And I didn't write any code at all, lately
23:24:54 <shapr> I want to write some basic XmlRpc tests today, checking basic functionality between Haskell and Zope.
23:25:13 <Maddas> ooh, using Haskell with Zope?
23:25:29 <shapr> yes, bring wrote the XmlRpc lib
23:25:46 <Maddas> Sounds interesting
23:25:55 <shapr> forester: good morning!
23:26:16 <Maddas> (Even though I know no Python and hardly any Haskell yet)
23:26:17 <shapr> http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/
23:26:46 <shapr> well, if you grab a copy of that, you can use it to call a basic demo I wrote
23:27:07 <shapr> import XmlRpcClient
23:27:10 <shapr> main = do resp <- remote "http://shapr.homelinux.net:9673/" "pyhello" "Haskell"
23:27:13 <shapr>           putStrLn resp
23:27:40 <Maddas> That's it?
23:28:17 <shapr> yup
23:28:38 <Maddas> Heh. Sounds easy enough to try :-)
23:28:47 <shapr> it's just a remote proceduce call mechanism
23:30:34 <shapr> you can fill in your own name for "Haskell" if you want slightly more entertaining output
23:34:11 <Maddas> hrm, HaXml doesn't like my `ld' binary
23:34:35 <Maddas> or rather, my `ld' binary doesn't like a parameter HaXml passes it. :)
23:35:22 <Maddas> (away for a few minutes)
23:39:23 <shapr> hi monotonom 
23:39:28 <monotonom> hi
23:39:44 * shapr bounces happily
23:42:47 <shapr> Hipo: nice squirrel
23:51:38 <shapr> god morgon bring!
23:51:43 <shapr> hur mår du?
23:52:02 <andersca> shapr: we're covering the swedish in #haskell.se, don't add to the confusion ;)
23:53:08 <shapr> bah, confusion is my métier
23:53:12 <shapr> :-)
23:54:58 <shapr> confusion is my native language
