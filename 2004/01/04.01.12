01:13:59 <Lunar^> shapr: here ?
01:20:39 <shapr> Lunar^: yah
01:22:43 <Lunar^> shapr: Did you find why zip was unavailable under Zope's PyScripts ?
01:22:55 <shapr> no, I didn't
01:23:06 <phubuh_> hey shapr, could you abuse your administrative powers in #haskell.se?
01:23:07 <phubuh_> :-)
01:23:36 <Lunar^> shapr: Thanks anyway :)
01:23:55 <shapr> phubuh: how so? want me to get rid of jihaaaq?
01:24:34 <shapr> phubuh: I don't have any power in #haskell.se
01:26:03 <phubuh_> oh, never mind then.  I'll just slap him in real life :-)
01:26:39 <shapr> phubuh: I'll ask jdahlin for powers next time he joins, he's the founder of #haskell.se
01:28:26 <phubuh_> I'll tell him to join next time I see him
01:45:53 <shapr> @fortune
01:45:59 <shapr> fooey
02:14:00 * shapr yawns
02:14:03 <shapr> good morning #haskell!
02:19:40 <shapr> hi TripleDES
02:51:19 <shapr> g'day zoyd 
02:51:28 <shapr> learning Haskell?
02:51:29 <zoyd> 'lo
02:51:33 <zoyd> yup:)
03:11:48 <shapr> zoyd: got any questions?
03:12:51 <zoyd> whats a monad ?:)
03:13:13 <shapr> the short answer is, it's an interface
03:13:40 <shapr> the two primary parts of the interface are >>= called bind or bindM, and return
03:14:26 <shapr> the longer answer is that a monad also has some simple commutativity laws it needs to satisfy
03:14:41 <shapr> and in Haskell, a monad is a typeclass with three methods, it also has fail
03:16:45 <ham[kell]> hiho
03:17:29 <shapr> dang, what's the nomaware url?
03:17:47 <zoyd> but the laws are up to the programmer to uphold arent they?
03:17:51 <shapr> that's true
03:18:26 <shapr> if you claim something is a monad but it doesn't follow the laws, weird things will happen.
03:19:06 <shapr> zoyd: this seems to be the best monad tutorial: http://www.nomaware.com/monads/html/index.html
03:19:23 <zoyd> thanks for that
03:25:23 <zoyd> have you studied in category theory yourself?
03:25:25 <zoyd> any
03:25:41 <shapr> zoyd: oh, six or eight pages in this category theory book I ordered.
03:25:51 <zoyd> nod
03:26:06 <shapr> several people on #haskell have that same book
03:26:10 <shapr> @wiki StudyGroup
03:26:10 <lambdabot> http://www.haskell.org/hawiki/StudyGroup
03:26:18 <zoyd> ah yeah?
03:26:57 <shapr> though I think phubuh and SyntaxNinja have read past the first chapter.
03:27:28 <zoyd> ive been reading a few , although theyre all very hard going (to me);)
03:28:09 <shapr> I just wish for more time.
03:31:51 <shapr> zoyd: are you at unsw?
03:33:35 <shapr> hi ham[kell], how's code?
03:34:24 <ham[kell]> shapr thanks im still on it :) but i read a book along so i am writeing kind of haskell pseudo code for my stuff and then go through all that stuff
03:34:46 <ham[kell]> but haskell has a really cool syntax which looks quite like what i had in mind
03:41:10 <shapr> yes, haskell is nifty
03:42:10 <ham[kell]> is there anything that relate the haskell constructs to CT?
03:42:18 <ham[kell]> do you know the rydeheart book?
03:42:27 <ham[kell]> http://www.cs.man.ac.uk/~david/
03:42:47 <ham[kell]> its CT for ML it would be really cool to get something like that for haskell
03:43:44 <shapr> you may be able to port it to Haskell
03:43:49 <shapr> since ML is very similar
03:44:01 <ham[kell]> true
04:23:51 <phubuh> shapr, I haven't gotten my book yet
04:25:32 <shapr> oh, ok
04:28:41 <shapr> yay
04:28:42 <shapr> http://gforge.scannedinavian.org/
04:29:07 <shapr> urk, it's taken over www.scannedinavian.org also
04:30:09 <shapr> dangit, gforge is trying to take over my whole domain.
04:37:05 <Heffalump> whowhatwhich?
04:45:35 <earthy> gforge.scannedinavian.org could not be found
04:49:20 <shapr> hmm
04:49:46 <shapr> suckage
04:50:23 <shapr> dns will take some time to update it seems
04:50:25 <earthy> but www.scannedinavian.org neatly redirects to it. >:)
04:50:31 <shapr> unhappily for me
04:50:37 <shapr> since I wanted to put other stuff there
04:50:41 <shapr> but I'll fight with it later
04:50:42 <earthy> owhyah, dns can take up to 48hrs to propagate
04:53:34 <Heffalump> that depends entirely on the TTLs
04:58:32 <earthy> not really
04:59:14 <Heffalump> you what?
05:01:47 <earthy> it's not really only the TTLs: the cache policies of the different providers may be set to ignore TLLs < 1 day, e.g.
05:02:01 <earthy> (and they are at big sites)
05:02:59 <Heffalump> really? Doesn't that make for a terrible interaction with dynamic DNS?
05:04:47 <earthy> yes. ;)
05:05:22 <earthy> b'sides, oftentimes people set the TTL to some safe value
05:06:00 <earthy> then, sometime before the cached entry expires, the zone gets updated
05:06:08 <earthy> it'll take until the expiration for it to be taken up
05:06:19 <earthy> and there are zones with TTL's in the order of days, e.g.
05:06:26 <earthy> (not often, but they exist)
05:06:42 <earthy> (oh, and dynamic DNS is a nasty hack and ought te be shot :))
05:14:18 <Heffalump> yes, I always did think having really low TTLs (except occasionally in preparation for zone changeovers) was an abuse of the system
05:29:18 <shapr> y0 SyntaxNinja 
05:29:26 <shapr> SyntaxNinja: gforge is sort of up
05:30:21 <SyntaxNinja> shapr: cool :)
05:32:29 <Heffalump> shapr: btw, if you're having reliability problems urchin.earth.li would be available to host Haskell-related stuff (could point a subdomain of scannedinavian at it if you wanted)
05:32:51 <shapr> the most recent reliability problems were caused by a CPU fan that locked up.
05:34:37 <shapr> gforge.ScannedInAvian.org might be slow, but it should be okay unless it uses lots of drivespace.
05:43:44 <shapr> so, anyone want to try registering new users/projects on gforge.scannedinavian.org ?
05:49:25 <shapr> I've submitted and approved a haskell-stuff project, seems to work.
05:49:52 <cm> hello :)
05:49:55 <shapr> hello cm
05:52:20 <shapr> Arnia: it's off-topic on #plone, want to talk about it here?
05:53:20 <cm> shapr, how are you doing?
05:53:37 <Arnia> Right :)
05:53:43 <shapr> I'm doing fine, I just installed a 'demo' gforge site on gforge.scannedinavian.org
05:54:00 <shapr> http://www.scannedinavian.org works also (though it shouldn't)
05:54:18 <shapr> Arnia: it seems nice, though I'm not so thrilled about it using so much PHP
05:54:30 <shapr> Arnia: it doesn't support darcs, so I'll probably have to hack on the PHP to fix that.
05:54:41 <cm> interesting
05:55:30 <Arnia> Hmm... interesting
05:55:44 <shapr> it looks like a generic flavor of sourceforge
05:56:07 <shapr> also, it recommends that cvs and postgresql hosts be separate from the main gforge host, but as I only have one box...
05:56:34 <Arnia> This for security I take it?
05:56:41 <shapr> or maybe performance?
05:57:07 <Arnia> Yeah... hmm... but why php
05:57:20 * Arnia wishes for a Zope/Plone sf clone ;)
05:57:26 <shapr> anyways, it's running on a 600MHz box with 512MB of ram and 9GB of drivespace, so it can't be a 'real' host without some upgrades.
05:57:35 <Arnia> No
05:57:40 <shapr> I don't know why it's PHP
05:58:45 <shapr> if anyone here wants to create a user account, I can add you to the haskell-stuff project so you can do testing
05:58:52 <shapr> or you can request your own project and I'll approve it
06:00:05 <shapr> I'd like to suggest gforge for haskell.org, so if anyone sees any bugs, problems, or has any suggestions, I'd like to hear it.
06:02:26 <shapr> gforge has some neat features
06:03:33 <SyntaxNinja> shapr: hmm. it says 5 projects, but I can't actually get to any of them.
06:04:06 <shapr> do you get an error? or is it DNS?
06:05:18 <shapr> SyntaxNinja: http://gforge.scannedinavian.org/projects/haskell-stuff/
06:05:48 <cm> (they are not categorized in the project tree, it seems)
06:06:01 <shapr> right, I'll categorize haskell-stuff
06:06:24 <shapr> I added Programming Language : Haskell
06:07:55 <shapr> anyone want to hack up a lambda logo? :-)
06:10:25 <earthy> yall? :)
06:10:42 <cm> Riastradh, are you around?
06:16:39 <shapr> hm, maybe the trove stuff is updated periodically, since I've changed haskell-stuff, and it still doesn't show up.
06:17:47 <Igloo> Ewww, that white on cyan really doesn't work
06:18:11 <shapr> Igloo: if you mean gforge, it has themes, which I've installed but don't know how to switch.
06:18:17 <Igloo> :-)
06:18:23 <Igloo> Oh, cool, you renamed it
06:19:10 <Igloo> Hmm, but shouldn't the whole thing be haskell-stuff with each thing having its own project?
06:19:40 <shapr> yes, just a demo project :-)
06:20:06 <Igloo> Right, OK
06:20:46 <ham[kell]> does someone of you use weblogs?
06:21:09 <shapr> I have a livejournal
06:21:21 <ham[kell]> whats that?
06:21:37 <Igloo> It's a disease
06:21:39 <shapr> http://www.livejournal.com/
06:21:40 <shapr> Igloo: hah
06:21:41 <ham[kell]> i just try to figure out what viewer is good (atm for win)
06:21:42 <Igloo> Reasonably infectious
06:21:53 <shapr> it's true, Heffalump has a livejournal also
06:22:07 <Igloo> Approximately 25% of the population seems to be susceptible IME
06:22:07 <shapr> I want to try PLog, the Haskell blogger
06:22:27 <ham[kell]> ah sec let me have a look at that
06:22:49 <shapr> livejournal doesn't have an easy way to slurp off all of my journal entries, so I want to switch
06:22:49 <ham[kell]> i just want to use that for all that science news sites like newscientist etc
06:23:00 <shapr> oh, you want an RDF collector?
06:23:22 * Arnia bounces
06:23:23 <Arnia> Yes yes yes
06:23:28 <Arnia> Please please please :)
06:23:43 <Arnia> oh, mis-read what was asked for
06:23:47 <ham[kell]> yep
06:24:06 <ham[kell]> sry i thought that weblogs were the same as an rdf collector
06:24:09 * Arnia thought shapr meant a bug collector
06:24:15 <ham[kell]> :)
06:24:33 <Arnia> An RDF-based bug collector :)
06:24:35 <Arnia> Mmm...
06:24:43 <Arnia> All your triples belong to us :)
06:30:02 <adept> what
06:30:19 <adept> what's the current "darcs-pullable" hlibs repo?
06:31:11 <shapr> adept: http://www.scannedinavian.org/repos/hlibs I hope
06:31:26 <shapr> argh, gforge stole www
06:31:34 <adept> "darcs get  http://www.scannedinavian.org/repos/hlibs" just bgrought me empty dir
06:31:48 <shapr> ahem, just a moment while I discipline gforge.
06:31:54 <adept> :)
06:36:43 <SyntaxNinja> what are "Lists"? mailing lists?
06:36:48 <shapr> SyntaxNinja: should be
06:38:41 <shapr> it wanted to install mailman as well, though I don't think mailman is working yet
06:39:06 <SyntaxNinja> why bother? we've already got mailmain at haskell.org
06:39:48 <shapr> each project could have their own mailing lists?
06:40:02 <shapr> I'm not picky one way or the other.
06:40:30 <SyntaxNinja> yeah. maybe a good idea, but maybe not. I see the main target audience as a bunch of small projects who shouldn't be bothering with all their little web pages
06:40:45 <SyntaxNinja> maybe they don't need mailing lists?
06:40:49 <shapr> maybe not
06:41:05 <SyntaxNinja> anyway, so with mailman interface you can create a mailing list for each project through the gforge web interface? that's a nice feature.
06:43:39 <SyntaxNinja> what exactly is the extent of the interface w/ CVS?
06:43:50 <shapr> I'm not sure, I haven't tried it yet.
06:45:36 <SyntaxNinja> does it use SQL or what?
06:45:51 <SyntaxNinja> what do you think are the prospects of messing with it for a while and then moving it to haskell.org once it has some momentum?
06:46:02 <SyntaxNinja> (ie once we can prove its usefulness :)
06:46:02 <shapr> it does, it appears to store most of its info in postgres
06:46:03 <SyntaxNinja> )
06:46:25 <shapr> the debs seem nice, and well supported via #gforge
06:46:37 <shapr> installation on something other than debian could be painful
06:47:24 <shapr> since the requirements are impressive ( LDAP, postgres, cvs, mailmain, php4, many php extensions )
06:50:55 <shapr> I suspect that someone will need to maintain gforge once it's setup, at least for approving project. I don't know how much work that is.
06:52:09 <shapr> I haven't used/maintained PHP or LDAP before, but the other bits of software seem straightforward enough.
06:52:33 <SyntaxNinja> Igloo: oooh, thanks for hte notes!
06:52:46 <SyntaxNinja> I think I got simonMar to install TLA to check out the code :)
06:53:17 <SyntaxNinja> Igloo: what do you do about tabs? I sorta trust haskell-mode to tkae care of it, which it usually does OK, but do you want all spaces or what?
06:53:24 <SyntaxNinja> shapr: I made an acocunt.
06:53:51 <shapr> SyntaxNinja: spiffy
06:55:04 <SyntaxNinja> ooh, I like "MyPage"
06:55:57 * shapr smacks vim
06:57:51 <shapr> adept: ok, I think it's back
06:58:17 <shapr> adept: pushing to hlibs darcs doesn't work just yet, some sort of gpg problem.
06:58:21 <SyntaxNinja> shapr: I created a new project, can you approve it?
06:58:23 <shapr> sure
06:58:33 <SyntaxNinja> shapr: does gforge create user accounts?
06:58:48 <SyntaxNinja> ie did you just give me a login to your machine? :)
06:59:04 <adept> shapr: hm. so what can I do with my changes, if I cant push them to repo ? :)
06:59:24 <shapr> SyntaxNinja: I'm not quite sure.
07:00:01 <shapr> adept: at worst, I can apply them, but hopefully I can fix the gpg thing soon.
07:00:18 <shapr> adept: actually, there was just a darcs-server upgrade today, you should try pushing.
07:00:44 <SyntaxNinja> shapr: well, if so, I hope you have a new kernel :)
07:01:13 <shapr> I don't think I have brk or mremap patched in the current kernel
07:01:15 * shapr checks
07:01:48 <Igloo> All spaces
07:01:49 <shapr> oh, maybe brk is fixed in 2.4.23, but I think 2.4.24 is required for the second fix
07:02:10 <adept> shapr: I tried. Patch is sent :)
07:02:50 <SyntaxNinja> Igloo: changing it will make for a butt-ugly diff
07:02:53 <SyntaxNinja> :P
07:03:13 <Igloo> But beautiful source  :-)
07:03:47 <SyntaxNinja> it'll tkae some gettign used to, but I'll try to fix it; I wish haskell-mode helped out a bit more
07:04:08 <shapr> SyntaxNinja: you can tell emacs not to use tabs, but instead spaces
07:05:14 <Smerdyakov> You can tell emacs to use only 'a'.
07:05:23 <SyntaxNinja> shapr: OK. will do
07:07:24 <shapr> SyntaxNinja: I use (setq-default indent-tabs-mode nil)
07:08:01 <SyntaxNinja> noted 
07:12:53 <shapr> adept: yay! it works for me now!
07:13:13 <shapr> I upgraded darcs-server, and I chown'd allowed_keys to hlibs
07:14:08 <shapr> adept: did you get a successful patch reply also?
07:14:30 <shapr> adept: if you got a gpg error, try it again, I think I just fixed the GPG problem.
07:18:21 <SyntaxNinja> shapr: I uploaded a document but it didn't show up. see any errors?
07:18:41 <shapr> uploaded a doc where?
07:18:54 <SyntaxNinja> to libraryInfrastructure
07:19:13 <SyntaxNinja> I love when users complain that they've been working on a problem for 2 days but don't spend a good 5 minutes explaining wtf the problem is :)
07:20:48 <shapr> SyntaxNinja: uploaded into documentation? or what?
07:21:06 <shapr> adept: did it work?
07:21:23 <SyntaxNinja> shapr: yeah
07:22:18 <shapr> crap, darcs is creating pushed patches with u+rw only
07:22:24 * shapr tries to figure out where upload docs go to
07:23:14 <shapr> SyntaxNinja: name of file?
07:24:20 <SyntaxNinja> libraryInfrastructure.pdf
07:27:50 <shapr> SyntaxNinja: looks like it's pending, check out "Document Manager : Administration"
07:28:15 <SyntaxNinja> shapr: if it's a PIA to move, maybe we could make projects.haskell.org point to your server?
07:28:25 <shapr> SyntaxNinja: I have considered that.
07:28:28 <shapr> seems likely
07:28:52 <SyntaxNinja> ahh, sorry for the false alarm. I set myself as an admin, so I'm surprised to have to approve it
07:29:13 <shapr> I already checked with my ISP to see if that would be okay, response was "as long as you don't use too much bandwidth, no problem"
07:29:35 <Igloo> Don't you pay for bandwidth?
07:29:39 <shapr> no :-)
07:29:44 <Igloo> Cool - how come?
07:30:31 <shapr> because the guy who owns the ISP has been my friend for several years, and I do lots of free software/OSS/programming/etc consulting for him.
07:31:07 <shapr> he's interested in setting up gforge as well, so I'll be able to help him out there, for example.
07:31:21 <Igloo> Neat
07:32:24 <shapr> I'm also researching IPv6 for him, it could be useful for him to switch his ISP to native IPv6 internally, and offer it to his clients.
07:34:05 <shapr> are default permissions defined per-user somewhere?
07:35:23 <shapr> for a file, that is
07:35:56 <shapr> I'm trying to figure out why darcs is creating patches that aren't u+r o+r
07:37:42 <Igloo> They're made as requested but masked with the umask (or its negation, I forget) if you mean UNIX rather than something gforge specific
07:37:44 <adept> shapr: man umask. and yes, "darcs get" did work
07:37:57 <shapr> adept: did darcs push also work?
07:38:22 <adept> shapr: yep. It said "patch send to <email> successfully"
07:38:30 <shapr> yay!
07:41:55 <shapr> Igloo: yes, I mean unix rather than gforge
07:58:49 <shapr> hrm, how can I persuade darcs to make sure created patches are world readable?
08:00:21 <shapr> is that a postfix or procmail problem?
08:02:12 <adept> shapr: educated guess: procmail. postfix has nothing to do with local delivery
08:07:49 <shapr> I wonder if darcs should set the umask itself.
08:09:55 <Igloo> postfix will do local delivery if you aren't using a procmail-a-like, surely?
08:10:13 <Igloo> (and if you are then giving it to procmail /is/ the locally delivery from its PoV)
08:10:40 <Igloo> shapr: It might just be a case of setting the umask in the darcs startup script. I don't know how it works, though
08:10:47 <shapr> I have postfix and procmail installed.
08:22:38 <cm> re from school ;)
09:23:00 * shapr yodels
09:24:04 <ham[kell]> ?:)
09:24:29 <shapr> work code breakthrough
09:24:35 <cm> :)
09:24:38 <cm> what are you working on?
09:25:01 <shapr> creating custom Archetypes for the CMF Framework of Zope
09:25:12 <shapr> Bea is yodeling also because she found the problem
09:25:21 <shapr> and she doesn't even write Python :-)
09:26:26 <phubuh> hee hee
09:27:53 <ham[kell]> heh do you know the programming language chef?
09:28:32 <ham[kell]> http://www.dangermouse.net/esoteric/chef.html
09:30:42 <ecraven> are there any haskell wallpapers?
09:30:49 <shapr> I think there are
09:30:56 <ham[kell]> oh really cool :)
09:33:57 <shapr> http://www.willamette.edu/~fruehr/logos/intro.html
09:34:33 <ham[kell]> i need one of those tangas ;)
09:34:41 <ham[kell]> and the propper girl for such a tanga
09:35:15 <shapr> I really like Fritz' pix, http://www.willamette.edu/~fruehr/logos/PNGs/100pure.png
09:35:22 <shapr> actually, Fritz is a really cool guy also.
09:35:33 <shapr> I met him at ICFP
09:35:40 <ham[kell]> ic?
09:35:44 <shapr> I met kosmikus there too, he snuck in our window.
09:35:55 <shapr> International Conference on Functional Programming.
09:36:12 <phubuh> is this Fritz a swede named johan?
09:36:25 <ham[kell]> ah and whats wrong with :=?
09:36:29 <shapr> no, Fritz Ruehr, of "Evolution of a Haskell Programmer" fame
09:36:35 <phubuh> ah
09:36:37 <shapr> ham[kell]: it's mutable
09:36:40 <ham[kell]> heh that one is funny
09:36:43 <ham[kell]> mutable?
09:37:24 <shapr> Haskell 'variables' are immutable.
09:37:42 <ham[kell]> what do you mean with mutable?
09:38:21 <shapr> in a function, if you write "a = 1" you cannot later write "a = 2" in the same function.
09:38:21 <phubuh> it changes the value of a variable
09:38:46 <ham[kell]> hm ok
09:39:00 <ham[kell]> we in our math course use that for definitions
09:39:37 <ham[kell]> so that = is like a one time bind or so?
09:39:49 <ham[kell]> this symbol is that thing once and for all
09:42:45 <shapr> in that function
09:42:47 <Heffalump> Haskell = is much more like the Mathematics definitional = than the assignment of many other languages
09:43:14 <Heffalump> (it doesn't change static scoping, you can still override a definition in a subscope, but that's a static property not a runtime one)
09:44:49 <ham[kell]> hm
09:46:05 <ham[kell]> can someone explain me that banana bracket thing?
09:46:29 <Heffalump> in what context?
09:46:32 <shapr> you gotta read Erik Meijer's papers
09:46:41 <shapr> bananas, lenses, barbed wire, etc
09:46:48 <ham[kell]> ok is that anything linked from the haskell site?
09:46:59 <shapr> yes
09:47:16 <shapr> it's about anamorphisms, catamorphisms, hylomorphisms, and I forget the rest of them
09:47:23 <ham[kell]> heh ;)
09:47:28 <shapr> each of them has a symbol, banana, barbed wire, lens, etc
09:47:36 <ham[kell]> ist that a banana ... ;)
09:48:36 <ham[kell]> and where can i read up on that := thing?
09:48:57 <shapr> ham[kell]: http://citeseer.nj.nec.com/meijer91functional.html
09:49:08 <shapr> it's actually a *very* cool paper.
09:49:31 <ham[kell]> sounds like real fun if i look at the funny posters ;)
09:49:38 <shapr> in short, you can't easily prove properties about recursive functions, so factor out the recursion into an explicit combinator
09:49:46 <ham[kell]> is that a banana in your pocket or are you programming with catamorphisms :))
09:49:50 <shapr> right, exactly
09:51:22 <ham[kell]> what do you write in haskell if you have something that needs definition but that cant be transformed in the other direction?
09:52:57 <ham[kell]> i havent got an example at hand but we used that in math when ever you need a definition of something
09:53:07 <shapr> I don't understand the question.
09:53:10 <phubuh> I don't understand what you mean
09:53:17 <Heffalump> ham[kell]: why do you want to know about them?
09:53:18 <ham[kell]> sec ill search for an example
09:53:35 <ham[kell]> because on that poster is a not( := )
09:53:57 <ham[kell]> but i use that in math :)
09:54:55 <ham[kell]> ah there is an example from my script
09:55:55 <ham[kell]> phi(x,y) = det(a^1,...,a^(i-1),x,y,^(i+2),...,a^n)
09:56:00 <ham[kell]> er
09:56:04 <ham[kell]> phi(x,y) := det(a^1,...,a^(i-1),x,y,^(i+2),...,a^n)
09:57:18 <ham[kell]> so what is the difference in semantics there?
10:05:46 <shapr> hi Darius 
10:09:56 <shapr> ok, now to see if this umask trick fixes the patch permissions for darcs
10:22:57 <ham[kell]> isnt := something like let?
10:23:28 <Smerdyakov> ham[kell], what are you talking about? What is "your script"?
10:23:54 <ham[kell]> im talking about that logo
10:24:06 <ham[kell]> http://www.willamette.edu/~fruehr/logos/PNGs/100pure.png
10:24:22 <ham[kell]> and i just try to understand the difference between := and =
10:24:41 <Smerdyakov> ham[kell], oh. := is assignment to a mutable cell.
10:24:43 <shapr> ham[kell]: I would guess that := is possibly a Pascal reference
10:24:49 <Smerdyakov> (in ML)
10:24:54 <Smerdyakov> (and also Pascal)
10:25:25 <shapr> and in Pascal, you can do a := 1; a := 2
10:25:29 <ham[kell]> hm so that := in that logo is not that := in math?
10:25:36 <shapr> I doubt it.
10:25:41 <ham[kell]> ah ok
10:25:42 <Smerdyakov> ham[kell], I think that is right.
10:26:02 <ham[kell]> cause i asked a mathematician and he told me that := was something like let
10:26:22 <ham[kell]> now i can go on to the bananas ;)
10:26:45 <ham[kell]> also that gives the code monkey phrase a new kind of flavor ;)
10:26:57 <shapr> I'm a web monkey.
10:27:02 <Darius> shapr: Sorry; reading backlog.
10:27:03 <shapr> my banana has ads.
10:27:16 <shapr> Darius: irc is asynchronous as always.
10:27:33 <ham[kell]> ads?
10:27:39 <Darius> shapr: Indeed. Some people need to realize that.
10:28:27 <shapr> ham[kell]: as in, my web monkey banana has ads from servedby.advertising.com
10:28:45 <ham[kell]> ah
11:08:10 * shapr chortles merrily
11:17:24 <Igloo> What ya up to, Shae?
11:19:57 <shapr> my earlier code breakthrough is turning out quite well, looks like I might be able to get this done a month and a half early.
11:20:14 <shapr> programming is great when it works :-)
11:20:24 <ham[kell]> ;)
11:20:56 <ham[kell]> do you do haskell at work?
11:21:26 <Igloo> Nifty
11:21:48 <Darius> The point-free-fu is strong with this Set definition.
11:22:04 <ham[kell]> point free fu?
11:23:04 <shapr> ham[kell]: only one so far.
11:23:21 <ham[kell]> shapr one task at work?
11:27:39 <shapr> only one paying Haskell task so far
11:28:06 <ham[kell]> ah ok so you are a freelancer?
11:36:49 <shapr> ham[kell]: yup, my woman and I own our own company. We mostly build websites, and we have clients in three countries.
11:37:36 <ham[kell]> cool
11:37:44 <shapr> I'd like to do more paying Haskell work, since I think Haskell is a powerful solution to most tasks.
11:38:03 <Smerdyakov> You'd like to do it, but you do nothing to make it happen. :P
11:38:04 <ham[kell]> id like to do games again with haskel and lispp ;)
11:38:14 <ham[kell]> but you cant get everything
11:38:49 <Igloo> Using darcs is something he's doing to make it happen in the long term, I believe
11:39:19 <shapr> Smerdyakov: obviously you don't actually read this channel.
11:39:20 <ham[kell]> darcs?
11:39:31 <Smerdyakov> shapr, maybe. What makes me wrong?
11:41:55 <shapr> Smerdyakov: I'm sure you can figure it out. I don't have time to explain.
11:42:23 <Heffalump> Smerdyakov: what do you think he should be doing, then?
11:42:48 <ham[kell]> does someone of you know casl?
11:45:12 <Smerdyakov> Heffalump, maybe looking for work writing Haskell code? :D
11:45:29 <Smerdyakov> Heffalump, which does not generally come in the form of contracts, as I understand things.
11:45:45 <Heffalump> how do you know he hasn't?
11:46:10 <Smerdyakov> Because he's doing web dev. :)
11:46:34 <Heffalump> which excludes him from having looked for jobs doing other things?
11:47:32 <Smerdyakov> It excludes him from having been successful in looking for other jobs, and I believe he lives in an area with enough opportunities that he should have been successful if he tried.
11:47:40 <Smerdyakov> And this might include getting a degree.
11:49:42 <SyntaxNinja> shapr: in your travels, have you seen free software for e-commerce type applications?
11:51:00 <Heffalump> where do you think he lives?
11:51:18 <Smerdyakov> Scandanavia
11:51:31 <Heffalump> are you aware how large Scandinavia is?
11:51:47 <Smerdyakov> A lot smaller than the USA.
11:52:11 <Smerdyakov> I am assuming that it is reasonable to relocate.
11:52:31 <Heffalump> and if it wasn't, or if it wasn't reasonable to spend n years on a degree, you'd consider this evidence that he hadn't tried hard enough?
11:53:08 <Smerdyakov> I would consider it as evidence that he had decided to ignore some substantial opportunities to reach a stated goal.
11:54:26 <shapr> Smerdyakov: I think you're just trolling
11:54:37 <Smerdyakov> Not that I'm aware of.
11:58:54 <shapr> Smerdyakov: being critical without supplying useful suggestions or corrections counts as trolling for me, since it uses up my time with no benefit to me.
11:59:20 <Smerdyakov> shapr, haven't I implicitly suggested getting a CS degree?
11:59:39 <ham[kell]> ok i need to go to bed now
11:59:49 <ham[kell]> read you tomorrow
11:59:57 <ham[kell]> me -> (me,bed)
12:02:11 <shapr> SyntaxNinja: I've seen a bit of OSS e-commerce stuff for Zope once, but I haven't investigated it. I do have one client asking me about that right now, so I should know more soon.
12:04:59 <SyntaxNinja> shapr: cool. let me know what you think. apt-cache search turns up one or two things, but I thought I'd run it by you.
12:06:10 <SyntaxNinja> Smerdyakov: not to butt in or anything, but IMO shapr makes a comfortable living and is in a good situation.  he may have a goal of using more Haskell in his work, but somehow I suspect that it's not worth completely changing his life over.  I know few people who would change their life around for ANY programming language ;)
12:10:32 <Smerdyakov> But what about changing to get away from web dev? ;P
12:28:30 <shapr> hello CyberTNT 
12:28:33 <CyberTNT> hey
12:28:41 <shapr> looking for Haskell info?
12:28:47 <CyberTNT> yeah ;p
12:29:04 <shapr> @learning
12:29:04 <lambdabot> Sorry, I don't know the command "learning", try "lambdabot: @listcommands"
12:29:08 <shapr> oops
12:29:09 <shapr> @learn
12:29:09 <lambdabot> http://www.haskell.org/learning.html
12:29:17 <shapr> that's a good place to start
12:29:19 <CyberTNT> if i have a list [2,3,4,5] and i want to know the position of the 4 whats the command for that?
12:29:31 <CyberTNT> well i already started, we are doing it at university
12:29:32 <shapr> @type index
12:29:32 <lambdabot> index :: Ix a => (a,a) -> a -> Int
12:29:36 <shapr> err
12:29:38 <shapr> hmm
12:29:40 <Darius> @typ find
12:29:41 <lambdabot> Sorry, I don't know the command "typ", try "lambdabot: @listcommands"
12:29:49 <Darius> @type elemIndex
12:30:01 <CyberTNT> @type find
12:30:04 <Darius> *sigh* it's in the List module.
12:30:16 <shapr> @type Data.List.elemIndex
12:30:19 <Darius> @ghci :t List.elemIndex
12:30:20 <lambdabot> Sorry, I don't know the command "ghci", try "lambdabot: @listcommands"
12:30:24 <shapr> heh
12:30:28 <shapr> not just yet :-)
12:31:15 <CyberTNT> shapr index is for ordered lists only? i want a command for any list like [2,3,1,4,9,3] as well
12:31:24 <shapr> CyberTNT: try it out
12:31:34 <CyberTNT> i did try index
12:35:07 <Darius> elemIndex is probably what you want (actually that may not be true as indexing is fairly rare)
12:36:42 <CyberTNT> why doe sit say "Just 2" or whatever number with elemIndex
12:36:50 <CyberTNT> cant it just return the number?
12:38:58 <Darius> What if you do elemIndex 3 []?
12:39:27 <CyberTNT> probably return nothing?
12:39:48 <Darius> Try it.
12:41:07 <CyberTNT> hm i found another way
12:41:21 <CyberTNT> head (elemIndices whatever) works
12:43:51 <jasonw> What if the element isn't in the list?
12:44:38 <CyberTNT> another question i want to write a function "splitn" that splits a list in n lists and returns them in a list. so splitn [1,2,3,4,5] 5 would return [[1],[2],[3],[4],[5]]. how would i do that with splitAt recursivly ?
12:57:14 <Heffalump> what would splitn [1,2,3,4,5] 3 return?
13:00:56 <CyberTNT> [[1,2],[3,4],[5]]
13:01:19 <Heffalump> ah
13:01:30 <CyberTNT> the length of them shouldnt differ more than one
13:01:32 <Heffalump> no particularly nice solution jumps out at me
13:01:45 <CyberTNT> hehe as longs as it works ;o
13:01:50 <Heffalump> and since this obviously your homework, I wouldn't tell you if I had one anyway :-)
13:01:56 <Heffalump> s/this/this is/
13:02:08 <CyberTNT> ok
13:02:12 <Heffalump> someone with more free time might help you work out how to solve it yourself
13:02:19 <Heffalump> but I'm afraid I'm busy
13:07:00 <SyntaxNinja> CyberTNT: do you have any ideas about how you might start this problem?
13:16:04 <Riastradh> cm: ping
14:15:23 <cm> hey Riastradh :)
14:17:23 <cm> Riastradh: i was wondering about how you would model values of a scheme interpreter in haskell. like, suppose i have a SExpression data type. is that a reasonable choice, and how would you combine that with other values such as closures?
14:18:39 <cm> Riastradh: "combine" as in, would you make a closure part of the data type s-expressions belong to (and maybe call that "Value"), would you create a higher level data type as in Value = SEXpression EXpression | Closure ...
14:18:55 <Riastradh> cm, I'd have a SchemeValue typeclass that supported such operations as eq_p, equal_p, the disjoint type predicates, et cetera.
14:20:47 <cm> oh, i see.
14:21:22 <Riastradh> A subclass of that might be SchemeNumber.
14:21:37 <Riastradh> A subclass of that might be SExpression.
14:22:32 <Riastradh> Er, a subclass of SchemeValue might be SExpression, that is.
14:23:00 <cm> pragmatic question, can you have polymorphic lists (as in, "a list of SchemeValues"?)
14:23:11 <Riastradh> Of course.
14:23:39 <Riastradh> data List = Nil | forall a. SchemeValue a => Pair a List
14:23:50 <Riastradh> Actually, that wouldn't be very good.
14:24:11 <Riastradh> It would be better to have   data Nil = Nil  and  data Pair = forall a, b. SchemeValue a, SchemeValue b => Pair a b
14:24:51 <cm> how would you define a vector in that scheme?
14:25:32 <Riastradh> data Vector = WhateverTheHaskellArrayTypeIs (forall s. SchemeValue s => Location s)    where Location is a mutable location type.
14:27:57 <Riastradh> My second attempt at a Pair type was dumb, too.  It should be:
14:28:19 <Riastradh> data Pair =
14:28:23 <Riastradh>     Pair (forall car. SchemeValue car => Location car)
14:28:33 <Riastradh>          (forall cdr. SchemeValue cdr => Location cdr)
14:31:08 <Riastradh> Argh.  The forall shouldn't even be there; it should be inside the Location type.
14:31:14 <Riastradh> But you get the idea.
14:31:52 <Riastradh> (This of course requires -fglasgow-exts.)
14:32:16 <Darius> WhateverTheHaskellArrayTypeIs is, quite surprisingly, Array
14:32:28 <Riastradh> Gee.  I'd never have thought of that one!
14:33:32 <cm> i think i'm getting you, thanks.
14:34:26 <Riastradh> cm, it may help you to read the R5RS denotational semantics.
14:34:40 <Riastradh> Although it has nothing to do with what I was just talking about, it will probably help you elsewhere.
14:34:41 <Darius> They translate readily to Haskell.
14:34:46 <Riastradh> Or Scheme.
14:35:42 <cm> Riastradh: true. i like "lisp in small pieces"' denotational semantics chapter, too.
14:36:25 <Riastradh> cm, briefly, what I was thinking of when I said that, was about the fact that a Scheme computation is a computation, easily represented as a monad, with three state values: the current continuation, the current environment, and the current store.  (You could also extend this to have the current dynamic environment, for procedures such as CURRENT-INPUT-PORT & CURRENT-OUTPUT-PORT, and the current wind points.)
14:39:58 <Darius> ContT o (ReaderT r (IO a))
14:43:00 <cm> i understand. i suppose the cc could be modelled as Location -> SchemeM [Location], environments as a data typ consisting out of Symbol -> Location bindings and the parent environment and the current store of a list of Locations. wonder whether the latter is really necessary (supposed i got it correctly)
14:43:46 <Riastradh> No, the current continuation would better be modeled as [forall s. SchemeValue s => s] -> answer.
14:44:19 <Darius> Riastradh: Wouldn't you want a store in there.
14:44:41 <Riastradh> Er.  Yes, you would, and an environment.
14:44:56 <Riastradh> Actually, duh, you wouldn't include the current continuation at all.
14:45:01 <Riastradh> ...if you did it monadically.
14:49:46 * Riastradh arghs.
14:49:57 <Riastradh> cm, curse you.
14:50:15 <Riastradh> Now I'm interested in thinking too much about this.  (That's the reason for randomly spewing out what I was thinking about the matter.)
14:51:48 <cm> :-)
14:52:17 <Riastradh> That increases my pressing projects for me to...*counts*...*loses count*...*grumbles*...
14:52:43 <cm> what are you working on, currently?
14:53:04 <Riastradh> 'Yes.'
14:54:54 <esap> Hmm.. anyone tried aldor? I tried to write a Hello world in it, but failed :-(
15:00:01 <Riastradh> cm, what's your Scheme-in-Haskell called?
15:01:04 <andersca> hascheme
15:01:31 <Riastradh> Is that really a Scheme-in-Haskell, or is it just what you stole from me telepathically?
15:01:40 <Riastradh> ...an existing one, that is.
15:08:26 <cm> Riastradh: Lispy *g*
15:08:51 <Riastradh> cm, do you have any code to show for it, or did you just start it a couple days ago?  (hence your recent question)
15:09:48 <cm> Riastradh: basically all i got is the alex/happy lexer/parser for s-expressions
15:10:15 <cm> [and the c++ hack which i did for some quick testing ;)]
15:10:50 <Darius> esap: I've -heard- of Aldor and slightly looked (no touch) at it.
15:10:54 <cm> (hence my questions, yeah)
15:11:51 <esap> darius: heh, I wrote a hello world, and found out I can't seem to get it to output a newline :-) Hmm. And no matter what I do, I can't get the compiler output any errors [I thought it had type checking :-)]
15:55:25 <Riastradh> cm, actually, I screwed the Pair definition up again.  It should have a boolean field, too.
15:57:05 <cm> what is the meaning of that boolean?
15:57:18 <Riastradh> It specifies whether or not the pair is mutable.
15:57:37 <Riastradh> Those created with QUOTE are not.
15:58:43 <Riastradh> This is both what R5RS specifies (though it allows for literal constant pairs to be mutable; it just says 'is an error') and allows you to safely recycle literal constant pairs.
15:59:06 <cm> ahh
16:04:07 <cm> i'll try to catch some sleep, good night. thanks for your advise
16:08:11 <Riastradh> @type id
16:08:11 <lambdabot> id :: a -> a
16:08:36 <emu> astonishing
16:08:41 <Riastradh> Indeed.
16:09:53 <SamB> @type fetch
16:16:02 <Riastradh> Funny.  If you write foldl and foldr in CPS, with two continuations to kons -- a 'continue' continuation and a 'terminate' continuation --, foldl becomes strict and foldr becomes lazy and tail-recursive.
16:16:09 <Riastradh> Er.
16:16:18 <Riastradh> I mean the other way around.
16:16:23 <Riastradh> And without anything about tail-recursion.
16:16:47 <Riastradh> I ought to edit my comments before I send them.
16:17:00 <Riastradh> And this is just an artifact of CPS being a control flow controller.  Duh.
16:17:54 <Riastradh> You can all safely ignore everything that I've said here since that 'Funny.'
16:20:51 * Riastradh rediscovers the fun of MTL and readers.
16:22:05 <Pseudonym> ML is indeed fun.
16:22:08 <Pseudonym> MTL
16:22:23 <Riastradh> ML is not, when you've got Haskell, Scheme, and Erlang.
16:22:32 <Pseudonym> No, ML is not fun.
16:22:40 <Pseudonym> Though I'm told that O'Caml can be fun.
16:22:57 * SamB hasn't a clue what to do with Scheme
16:23:08 <Riastradh> Nah.  OCaml is no more fun than SML, and it has a crapular object system thrown in as well.
16:23:21 <Riastradh> OCaml doesn't even have call/cc, while several SML implementations do.
16:23:30 <Riastradh> SamB, um, hack, perhaps?
16:23:41 <Pseudonym> I have a suspicion that SML's requiring explicit recursion to be declared in a mutual letrec makes it less fun than O'Caml./
16:23:51 <Pseudonym> Sorry, requiring mutual recursion.
16:23:54 <Pseudonym> Not explicit recursion.
16:23:57 <Riastradh> OCaml requires that, too.
16:24:03 <Pseudonym> Does it?  Oh.
16:24:06 <Pseudonym> Well, crap.
16:24:11 * Pseudonym won't touch THAT, then
16:24:13 <Riastradh> let rec f x y z = ...g a b c...
16:24:22 <Pseudonym> No, I meant function definitions.
16:24:25 <Riastradh>     and g p q r = ...f i j k...
16:24:33 <Riastradh> Those _are_ function definitions.
16:24:35 <Pseudonym> It's not called "letrec" in SML.
16:24:36 <Heffalump> the really nasty thing about SML is the restrictions on datatype declarations
16:24:41 <Heffalump> along with aliases
16:24:54 <Heffalump> in some cases, you end up having to inline the aliases just because of the syntactic restrictions
16:25:03 <Riastradh> OK, SML's data type definition stuff is a lot less fun than OCaml's, but OCaml's is dumb, too.
16:25:47 <Riastradh> OCaml has one syntax for defining types: 'type'
16:26:09 <Pseudonym> This is what I don't like:
16:26:09 <Riastradh> It gloms type aliases, records, polymorphic variants, and algebraic data types all in that one thing.
16:26:18 <Pseudonym> fun f x = ... g ...
16:26:27 <Pseudonym>     end
16:26:32 <Pseudonym> and g x = ... f ...
16:26:34 <Pseudonym>     end
16:26:37 <Pseudonym> I don't like the "and".
16:26:41 <Riastradh> Same thing in OCaml.
16:26:45 * Pseudonym nods
16:26:55 <Pseudonym> OK, then.  No O'Caml for me.
16:27:23 * Pseudonym believes there is no excuse for this crapulence in a modern language
16:27:38 <SamB> it didn't look like it had any real features to me, anyway
16:27:40 <Pseudonym> I would like instantiable modules, though.
16:28:13 <Pseudonym> Erlang comes close to that.
16:28:53 <Pseudonym> It occasionally gets proposed for Haskell but never implemented.
16:29:04 <Riastradh> The only good module system I _really_ like, with the only problems I have with it not related to the fundamental concepts of it, is that of Scheme48.
16:31:23 <Pseudonym> Oh?
16:32:47 <Riastradh> How am I supposed to respond to that question?
16:33:07 <Pseudonym> Well, what do you like about it?
16:33:10 <Pseudonym> What are its good features?
16:33:17 <Riastradh> It's not about 'features.'
16:42:29 <Riastradh> It's about the basic design of it.
16:42:37 <Pseudonym> OK.  Can you elaborate?
16:42:47 * Pseudonym doesn't like Haskell's module system
16:43:10 <Pseudonym> It's very rudimentary.
16:43:12 <Riastradh> Most module systems try to glom module code, i.e. metadata about how to interpret the source code, and the source code, the code that actually does stuff, together.
16:43:27 <Riastradh> Indeed, in some, modules are first-class at the level of the source code.
16:43:34 <Pseudonym> Yes.
16:43:58 <Riastradh> This is the Wrong Thing.  Module metadata is instruction to the compiler about how to interpret the source code; the source code should have nothing to do with it.
16:44:15 <Smerdyakov> Riastradh, example?
16:44:31 <Smerdyakov> Riastradh, does this criticism apply to ML?
16:44:33 <Riastradh> Smerdyakov, example of what?
16:45:14 <Igloo> I think what I'd most like is an export-to-friends; one definition of friends might be things in the same subtree of the HL
16:45:19 <Riastradh> Smerdyakov, somewhat.  It should be noted that the Scheme48 module system is based on the SML module system.
16:45:27 <Riastradh> Igloo, 'export-to-friends?'
16:45:47 <Smerdyakov> Riastradh, then can you explain a flaw of the SML module system that is related to your criticism about metadata vs. source code?
16:46:07 <Igloo> exporting "internal functions", but not to users of the module, only to other bits of the implementation
16:46:12 <Igloo> Like private in Java maybe?
16:46:15 <Igloo> Or protected?
16:46:24 * Igloo can't remember what any of them mean, if I ever knew
16:46:28 <Riastradh> Smerdyakov, source code and module code are too intricately intwined.  You don't have bodies of source code, and then elsewhere, bodies of module code that tell the compiler to use that source code.
16:46:41 <Pseudonym> One example which came up on the mailing list recently is code exported to a unit test suite but not to the "application".
16:46:50 <Smerdyakov> Riastradh, and why is that bad?
16:46:52 <Riastradh> Igloo, that isn't necessary.  I certainly agree that the application of it is useful, of course.
16:46:54 <Igloo> I don't know anything about the ML module system to know if there's more things I would like in Haskell's
16:47:18 <Riastradh> Smerdyakov, it's deceptive.  It looks like the module code and the source code are almost at the same level, when in fact they're definitely not.
16:47:27 <Smerdyakov> Riastradh, why aren
16:47:32 <Smerdyakov> 't they if I define things that way?
16:47:42 <Riastradh> Smerdyakov, rephrase, please.
16:47:49 <Igloo> Exporting to test code is a good example of when it's useful, yes
16:47:49 <Pseudonym> Perhaps I can expand here.
16:47:58 <Pseudonym> In Haskell, a module is identical with a compilation unit.
16:48:02 <Igloo> Otherwise you either have to have the tests in the same file or export everything
16:48:04 <Riastradh> Igloo, with Scheme48's module system, you simply define multiple structures with the same set of clauses but with different interfaces.
16:48:13 <Pseudonym> With Main being the one exception.
16:48:23 <Pseudonym> This is not always desirable.
16:48:24 <Smerdyakov> Riastradh, actually, I think I'll ask you to rephrase. What is module code and what is source code is irrelevant to software engineering. I need to see a concrete reason why I lose out by using a module system with the properties you are criticizing.
16:48:38 <Riastradh> For this sort of thing, define a FOO structure and a FOO-INTERNAL structure.  The test suite opens FOO-INTERNAL; the users open FOO.
16:49:12 <Riastradh> The only difference between the two structures is their interface; indeed, they have the same underlying 'package.'  (top-level environment)
16:49:38 <Smerdyakov> ML supports giving the same code different interfaces very easily.
16:49:42 <Riastradh> Smerdyakov, do you agree that module metadata and source data are entirely separate concepts?
16:49:44 <Igloo> I don't think I need that. If it let you rename things on the way out it might be a nice way of supporting multiple versions of interfaces, but other than that i don't think I'd use it
16:49:58 <Smerdyakov> Riastradh, OK
16:50:01 <Igloo> (where use it = use it more than I described above)
16:50:58 <Riastradh> Igloo, 'export-to-friends' is less general than multiple structures sharing a package.
16:51:02 <Pseudonym> Another example that came up with Edison was with container interfaces.
16:51:18 <Igloo> Yes, I'm saying I don't think I'd use the extra generality
16:51:19 <Pseudonym> Consider a standard Haskell list implementing a stack.
16:51:43 <Igloo> And if I don't have it then I don't have to worry about modules importing interfaces they aren't allowed
16:51:46 <Pseudonym> This actually supports any operation that you can think of on a "container", including append-to-end and random access.
16:51:51 <Riastradh> Igloo, you don't think you'd ever use it in your entire lifetime, and it is thus useless and the less general solution is inherently better?
16:51:54 <Pseudonym> Some of them are slow, some of them are fast.
16:52:27 <Pseudonym> So this data structure is a general container, and it's useful as a general container.
16:52:42 <Riastradh> Smerdyakov, sorry, it's hard to keep track of two conversations at once, especially in the same channel.
16:52:46 <Pseudonym> But it's also a stack.  The stack ADT only supports push, pop, top etc.
16:52:49 <Igloo> The less general system has an additional safety property that I want. I don't think I'd really gain much for the increased complexity of the other
16:52:55 <Pseudonym> So actually you want one module with two interfaces.
16:53:03 <Pseudonym> The stack is just a simple example.
16:53:08 <Riastradh> Igloo, what increased complexity?
16:53:30 <Pseudonym> Sorry, I'll stop now.  One conversation is hard enough to follow. :-)
16:53:33 <Smerdyakov> Pseudonym, have the two things you've listed been meant to illustrate a problem with the ML module system, or just Haskell's?
16:53:37 <Riastradh> It's very simple.  You just use DEFINE-STRUCTURES instead of DEFINE-STRUCTURE:
16:53:39 <Igloo> Have you actually got examples of where it is useful OOI?
16:53:47 <Riastradh> (define-structures ((foo foo-interface) (foo-internal foo-internal-interface))
16:53:51 <Riastradh>   ...clauses...)
16:54:11 <Pseudonym> Smerdyakov: I think of it as a problem with Haskell's, though there's an wasy workaround in this case.
16:54:23 <Riastradh> Igloo, in exactly the situation you mentioned.  I also point out every use of DEFINE-STRUCTURES in the Scheme48, Pre-Scheme compiler, and scsh sources.
16:54:29 <Smerdyakov> Pseudonym, the best workaround is splice in the ML module system. :)
16:54:48 <Igloo> But do you have examples of where you want more than friends and the world?
16:54:57 <Pseudonym> In Haskell, I use "facade" modules as thin layers on top of a common implementation.
16:55:00 <Smerdyakov> Who could want more than friends and the world, Igloo??
16:55:45 <Pseudonym> Igloo: Sometimes you don't know in advance who you want as a friend.  In addition, you might want different classes of friend.
16:55:47 <Riastradh> Igloo, scheme/vm/package-defs.scm, line 125, from the Scheme48 source.  There are three structures defined there.
16:56:05 <Igloo> Pseudonym: I'm defining friend to be in the same subtree of the HL
16:56:24 <Riastradh> HL?
16:56:30 <Igloo> hierarchial libraries
16:56:32 <Pseudonym> That's another thing I take issue with, the identity of a directory with a "package".
16:56:44 <Pseudonym> It's analogous with file == module, I suppose.
16:57:09 <Smerdyakov> I think forcing each file to define a module is a good idea, as long as you can create all the submodules you want within them.
16:58:10 <Riastradh> Smerdyakov, why do you want to equate files and modules?
16:58:26 <Riastradh> Igloo, friends aren't necessarily all in the same hierarchy.
16:58:27 <Smerdyakov> It's a convenient way of clarifying what a compilation unit is.
16:58:49 <Riastradh> ...and why do you want to equate files and compilation units?
16:59:06 <Smerdyakov> Because that's a natural granularity for a compiler to use.
16:59:19 <Riastradh> Oh?  What makes it natural?
16:59:29 <Pseudonym> One thing it does is contributes to executable bloat.
16:59:32 <Smerdyakov> Tradition, at the very least. :)
16:59:34 <Pseudonym> Unused code ends up in binaries.
17:00:38 <Riastradh> Why is tradition relevant?
17:00:50 <Pseudonym> It's not tradition in C or C++.
17:00:59 <Riastradh> And, if it's the very least, then surely you could get something that holds more weight than it.
17:01:02 <Smerdyakov> Here's one reason: Existing popular source control systems make it easier to have different people modify different files.
17:01:27 <Riastradh> I fail to see how that is relevant.
17:01:45 <Smerdyakov> The "compilation unit" is a way of splitting up a project.
17:01:50 <Smerdyakov> When you split, you can delegate.
17:02:10 <Riastradh> What would be wrong with splitting one module into several files?
17:02:46 <Smerdyakov> Nothing, and it's easy to do and compatible with treating each file as a module.
17:03:05 <Pseudonym> OK, Smerdyakov, what you're saying here is that a module is a unit of assigning work to programmers.
17:03:05 <Riastradh> ...um, no it isn't, because each files is only a _part_ of a module, not a whole module.
17:03:23 <Riastradh> Pfhood is getting cold, so I'll return to this conversation in a few minutes.
17:03:35 <Smerdyakov> Riastradh, it's easy to construct modules from modules.
17:03:43 <Smerdyakov> Riastradh, there is no fundamental savings from allowing non-module files.
17:10:13 <Pseudonym> Constructing modules from modules might be easy, but it might just as easily be misleading.
17:10:35 <Pseudonym> People may be misled into thinking that a module is for use, when in fact it's the agglomerated module which is for use.
17:11:55 <Smerdyakov> They can't use it if you don't make it available to them.
17:12:12 <Smerdyakov> Not in terms of the code for it, but in terms of the interface you give.
17:12:21 <Pseudonym> How do you enforce availability of a module?
17:12:32 <Pseudonym> I believe that it can be done.  Just curious how you'd do it.
17:13:20 <Smerdyakov> You can look at the SML/NJ library system.
17:14:31 <Smerdyakov> Which is a sort of confusing thing for me to say, since OCaml does a-file-is-a-module, while SML does not.
17:15:12 <Pseudonym> OK.  I have FooPart1 and FooPart2, separate files-as-modules, which I want to agglomerate into Foo.
17:15:21 <Pseudonym> I want clients to have access to Foo, but not FooPart1 or FooPart2.
17:15:56 * Pseudonym isn't sure if "agglomerate" is the correct term here
17:16:06 <Smerdyakov> So your library specification doesn't include FooPart1 or FooPart2.
17:16:08 <Pseudonym> I'm not familiar with module system jargon.
17:16:16 <Pseudonym> No, it doesn't.
17:16:30 <Smerdyakov> That was the answer to "how to do it." :)
17:17:01 <Pseudonym> :-)
17:17:16 <Pseudonym> So your answer to "how do I declare this type" is "make it part of the specification"?
17:17:29 <Pseudonym> YOu should be a Lisp programmer!
17:17:45 <Smerdyakov> I mean a formal machine-parsed specification.
17:18:16 <Pseudonym> Ah, OK.  All right, I'll be prepared to accept this.
17:18:16 <Smerdyakov> Just a list of modules to make visible to the outside world
17:18:46 <Pseudonym> If you can hide modules from the outside world, then that is indeed equivalent to splitting a module across files.
17:18:58 <Pseudonym> Oh, and if you can agglomerate modules, obviously.
17:21:47 <Smerdyakov> You should peek more at SML's module system. It's very nice.
17:22:28 <Smerdyakov> An easy way to do that is to read Part III of http://www-2.cs.cmu.edu/~rwh/smlbook/
17:26:41 <GreyLensman> The SML module system is very nice.  Its one flaw if I remember correctly is that you can't compile sigs separately from structs.  ie you always need the source implementation.  Smerdyakov correct?
17:27:24 <Smerdyakov> I don't think so.
17:27:42 <Smerdyakov> Of course, the SML Definition has no mention of compilation, so I can't even say exactly what you mean.
17:29:21 <Heffalump> Moscow ML certainly compiles sigs without the associated structure.
17:31:21 <Smerdyakov> I would prefer to say without _an_ associated structure, to make it even clearer that signatures are not slaves to structures. :)
17:33:02 <GreyLensman> I'm looking for the exact issue.  I think I saw it in SML2000 doc or "Whats wrong with SML" by several of the SML authors.  Looking....
17:35:31 <Heffalump> yes, that was what I meant too
17:35:34 <Heffalump> I just failed to say it :-)
17:43:40 <GreyLensman> "... the shortcoming of SML with respect to separate compilation.  In SML, the information known about a structure is not expressive as a source-language signature; precise module interfaces can only be dreived from their implementations"
17:44:17 <GreyLensman> Is this still valid?  This is from the ML2000 1999 doc.  Appel, Harper et al.
17:46:12 <Smerdyakov> Probably.
17:46:28 <Smerdyakov> Does it have an example?
17:47:27 <GreyLensman> looking but I don't think so.  
17:52:09 <Riastradh> Pseudonym, read Olin Shivers' introduction to the Scheme48 module system -- http://www.scsh.net/docu/post/modules.html --, the Scheme48 manual -- http://s48.org/0.57/manual/s48manual.html --, and scheme/*packages.scm & scheme/*interfaces.scm in the Scheme48 source.
17:52:27 <Riastradh> er, and _browse_ scheme/*packages.scm & scheme/*interfaces.scm, that is.
17:54:15 <Riastradh> (and ignore the post script in Olin's introduction; that feature was taken out, though I don't know why)
18:02:02 <Riastradh> Oh!  The comment I made earlier about foldl becoming lazy and foldr becoming strict _is_ relevant, actually.
18:02:50 <Riastradh> It's _not_ relevant that I rewrote it to use CPS.
18:24:11 <Riastradh> Is there anything in the Haskell standard libraries like SRFI 1's LIST-TABULATE?
18:26:35 <Darius> What does list-tabulate do?
18:27:08 <Riastradh> (list-tabulate F N) = (list (F 0) (F 1) (F 2) ... (F (- N 2)) (F (- N 1)))
18:27:39 <Riastradh> (actually, in SRFI 1, the arguments are unfortunately & erroneously swapped)
18:28:07 <Darius> so map f [1..n-1] ?
18:28:16 <Riastradh> ...oh.
18:28:47 <Riastradh> Laziness scares me at times when I don't like to think of consing intermediate lists.
19:45:51 <SamB> Riastradh: what makes you think intermediate lists get consed?
19:46:50 <Riastradh> SamB, nothing, because of Haskells lack of strictness.  But most of my code is in Scheme, where writing something like that conses intermediate lists.
19:47:14 <SamB> oh, right, scheme.
19:48:28 <SamB> fusion would be a lot more work in scheme, I guess
19:48:39 <Riastradh> Haskell's, even.
19:48:51 * Riastradh has made many grammatical errors today.
19:49:06 * Riastradh is embarrassedly startled.
19:49:13 <SamB> Riastradh: hey, this is no SAT II Writing test
19:49:35 <Riastradh> You obviously don't know me.
19:49:50 <SamB> no, I don't.
19:51:00 <Riastradh> Arrays in Haskell are such a bother.
19:51:31 <SamB> You can say that again.
19:51:35 <Riastradh> Arrays in Haskell are such a bother.
19:51:51 * SamB was wondering if he would do that
19:58:18 <pimpbot5000> could anyone help me anylize why my code is running so slowly?  
19:58:21 <pimpbot5000> here it is:
19:58:30 <Riastradh> Analyze, pimpbot5000, not 'anylize.'
19:58:39 <pimpbot5000> matrixMult :: DblMortonMtx -> DblMortonMtx -> DblMortonMtx -> DblMortonMtx
19:58:39 <pimpbot5000> matrixMult c a b = mm c (root::AhnenIx) (root::AhnenIx) (root::AhnenIx) 0
19:58:39 <pimpbot5000>    where 
19:58:39 <pimpbot5000>    {-# INLINE mm #-}
19:58:39 <pimpbot5000>    mm c0 cIx aIx bIx lvl | (lvl' > ((getDepth c0) - 3)) = 
19:58:40 <pimpbot5000> 			     doDblMortonBaseCaseMult c0 a b cIx aIx bIx
19:58:42 <pimpbot5000> --                             setMtx c0 cIx ( (getMtx a aIx) * (getMtx b bIx) + (getMtx c0 cIx) )
19:58:44 <pimpbot5000> 			 | otherwise =
19:58:46 <pimpbot5000>                              let c1 = mm c0 (nw cIx) (nw aIx) (nw bIx) lvl'
19:58:48 <pimpbot5000>                                  c2 = mm c1 (nw cIx) (ne aIx) (sw bIx) lvl'
19:58:50 <pimpbot5000>                                  c3 = mm c2 (ne cIx) (nw aIx) (ne bIx) lvl'
19:58:52 <pimpbot5000>                                  c4 = mm c3 (ne cIx) (ne aIx) (se bIx) lvl'
19:58:54 <pimpbot5000>                                  c5 = mm c4 (sw cIx) (sw aIx) (nw bIx) lvl'
19:58:56 <pimpbot5000>                                  c6 = mm c5 (se cIx) (se aIx) (sw bIx) lvl'
19:58:58 <pimpbot5000>                                  c7 = mm c6 (se cIx) (sw aIx) (ne bIx) lvl'
19:59:00 <pimpbot5000>                                  c8 = mm c7 (se cIx) (se aIx) (se bIx) lvl' in
19:59:02 <pimpbot5000>                                       c8
19:59:04 <pimpbot5000> 			 where lvl' = lvl + 1
19:59:06 <pimpbot5000>    stripeBounds = reverse (mkStripeBnd (getOrder c))
19:59:08 <pimpbot5000> oops, typo
19:59:45 <pimpbot5000> this code is generating a huge number of heap allocations... is there a way to avoid this?
19:59:55 <Riastradh> Paste-o, too.  Use
20:00:02 <Riastradh> @wiki HaskellIrcPastePage
20:00:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:00:04 <Riastradh> next time.
20:00:14 <pimpbot5000> ok cool
20:00:18 <Riastradh> Don't allocate.
20:01:13 <pimpbot5000> don't allocate?
20:01:33 <Riastradh> Yes.  That's the way to avoid large quantities of heap allocation.
20:02:36 <pimpbot5000> right...well here's the thing.  i put this same code into a monad, it doesn't have all the heap allocations
20:06:37 <Riastradh> So keep it that way; it fixed it!
20:07:35 <pimpbot5000> well i'm trying to avoid using monads...in any case, i want to understand what's causing this inefficiency
20:07:53 <Riastradh> Monads are your friends.
20:08:02 <Riastradh> Haskell is hard enough to reason about space in anyways.
20:09:03 <Riastradh> OK, sorry, I'll go back to what I was doing and let someone else answer this, as I'm too busy to expend a brain cell thinking about this.
20:09:03 <SamB> pimpbot5000: why would you want to avoid monads?
20:10:00 <pimpbot5000> this is a research question about lazy languages
20:10:03 <Darius> Presumably the base case is an array update, which means you copy the array 8 times for every level of recursion in mm.
20:10:06 <SyntaxLaptop> Igloo: alive?
20:10:31 <pimpbot5000> there is no copying though, the update is made in place
20:10:32 <SyntaxLaptop> igloo: I don't understand this "Personally I derive foo' from foo, so your use seems backwards to me."
20:11:25 <Darius> pimpbot5000: How, the above function isn't monadic.  Haskell is a pure language.
20:11:56 <SamB> pimpbot5000: you can't do stuff in place without some way to assure that you have the only reference to something...
20:12:11 <pimpbot5000> it's hard to explain..i can if you want, but you could just trust that the array is single-threaded
20:12:30 <SamB> pimpbot5000: but does the compiler know that?
20:12:38 <Darius> pimpbot5000: It's not a matter of what you or we think.
20:12:43 <pimpbot5000> no, it's an operational solution
20:13:39 <pimpbot5000> the updates work in place because each time one is side-effected, it is destroyed
20:14:00 <Darius> 1) No it isn't and 2) no it isn't.
20:14:10 <pimpbot5000> huh?
20:14:33 <Riastradh> pimpbot5000, Haskell is pure.  You can't do in-place updates without using monads.
20:15:39 <pimpbot5000> true, but GHC is certainly not pure.  also, this is an experiment which is specific to lazy functional languages, not necesarily haskell
20:15:56 <Riastradh> What do you mean by 'GHC is certainly not pure?'
20:16:00 <pimpbot5000> i'm using haskell because of ghc
20:16:06 <pimpbot5000> you can side-effect with ghc
20:16:24 <Riastradh> You can do side effects _by_using_monads_, the _interface_ to which _is_ pure.
20:16:41 <Pseudonym> Or you can use one of the functions explicitly labelled "unsafe".
20:16:44 <pimpbot5000> yes, but there are primitive types available
20:16:45 <pimpbot5000> yes
20:27:13 <SyntaxLaptop> phear: http://www.syntaxpolice.org/anna/annaRussianPics/disk1/107.html
20:28:19 <SyntaxLaptop> (that's me & shapr, btw)
20:29:02 <pimpbot5000> are you in a grad program?
20:29:18 <pimpbot5000> im interested in where good haskell related programs are
20:31:56 <Smerdyakov> pimpbot5000, do you limit yourself to a particular geographic area?
20:33:07 <pimpbot5000> not really
20:33:31 <pimpbot5000> although im not familiar with european schools admissions, etc
20:35:28 <Smerdyakov> I honestly know of, not just one school in the USA that can be said to have "Haskell related programs," but only one professor's group: Paul Hudak's at Yale.
20:35:58 <pimpbot5000> yea i applied there
20:36:13 <Smerdyakov> Functional programming is not an accepted research area in the USA.
20:36:16 <pimpbot5000> ive heard oregon graduate institute has a good program too
20:36:47 <Smerdyakov> These are both not very well regarded as overall CS programs go.
20:36:53 <Smerdyakov> So you might want to consider widening your interests.
21:20:41 <`John> apart from linear programming what is the minmal subset of haskell language features needed to program an interactive opengl application?
21:22:47 <Smerdyakov> I don't think you are using "linear programming" in a standard sense, since it's not something associated with graphics.
21:27:59 <`John> opps, sorry linear math.
21:28:01 <`John> hehe.
21:28:08 <`John> typo :P
21:28:19 <Smerdyakov> "Linear algebra"?
21:28:24 <`John> thats it.
21:28:26 <`John> hehe.
21:28:52 <Pseudonym> Linear programming is very useful in graphics.
21:29:06 <Pseudonym> Constraint solving is often used for physical simulation.
21:29:27 <Smerdyakov> I don't consider physical simulation to be "graphics."
21:30:00 <Pseudonym> You should have a look through a SIGGRAPH periodical some time.
21:33:06 <Smerdyakov> Well, I assume that you are right and I am wrong. Let's just say hobbyists don't tend to use LP with graphics. :)
21:54:53 <SamB> Smerdyakov: well, its more physics then graphics, but when you have both, they tend to be closely related
22:02:28 <Pseudonym> It actually depends what you're doing.
22:02:44 <Pseudonym> Engineers and physicists tend to care about accuracy.
22:03:16 <Pseudonym> However, Hollasch's law applies: Computer graphics is the only area of science where if it looks right, it is right.
22:03:37 <Pseudonym> In the entertainment industry, for example, speed and control trump accuracy every time.
22:03:51 <Pseudonym> So long as it's stable and it looks right.
22:06:40 <SamB> I never said the physics logic would be accurate
22:18:20 --- mode: brunner.freenode.net set +o Riastradh
22:18:22 --- mode: ChanServ set -o Riastradh
