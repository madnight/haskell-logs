00:04:39 <shapr> gutenmorgen ecraven 
00:05:21 <ecraven> hey :)
00:05:57 <Gavino> hey
00:06:02 <bring> god morgon shapr
00:06:04 <Gavino> does haskell wrok on websites?
00:06:19 <shapr> Gavino: for some definition of wrok, yes.
00:06:20 <Gavino> like is there a haskell webserver?
00:06:25 <shapr> yup, sure is.
00:06:28 <Gavino> haskell prevalence layer?
00:06:35 <Gavino> haskell absed object database?
00:06:36 <shapr> what's a prevalence?
00:06:46 <Gavino> www.prevayler.org
00:07:00 <Gavino> objects in ram onyl database with serialized commands
00:07:04 <Gavino> ram goes down
00:07:15 <Gavino> run command log against last snapshot to get it up to date
00:07:33 <shapr> I haven't heard of such a thing in Haskell.
00:07:34 <Gavino> 9000 times faster tahn oracle
00:07:42 <shapr> I do like HaskellDB
00:07:44 <Gavino> what do you use haskell for?
00:07:51 <Gavino> waht si haskelldb?
00:08:18 <shapr> I'm a self-employed web developer, I'm just starting to move some of my Zope logic out of zope into Haskell via xmlrpc
00:09:21 <shapr> I've did a year or so of J2EE before switching to Zope.
00:10:05 <Gavino> ok
00:10:08 <Gavino> what is zope
00:10:16 <Gavino> is it an app server or a database
00:10:27 <Gavino> and waht is xmlrpc
00:10:33 <Gavino> xml remote procedure call?
00:10:40 <shapr> Gavino: I don't think you can make a heavy duty production website in pure Haskell right now, though that may change soon.
00:10:42 <shapr> yup
00:11:03 <shapr> Zope is short for the Z Object Publishing Environment, it's roughly equivalent to J2EE in Python
00:11:30 <shapr> it's a web application server, but it includes lots of features that aren't in J2EE by itself.
00:11:58 <shapr> for example, automatic cataloging and searching, built in object database, many other goodies.
00:12:36 <shapr> Simon Marlow wrote a high throughput Haskell Web Server, it's in the HWS subdirectory of the fptools cvs tree
00:13:06 <shapr> Martin Sjögren modified hws to use runtime loadable apache-style plugins
00:13:38 <shapr> Peter Thiemann wrote WASH - Web Authoring System Haskell - (awesome logo - http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/ )
00:14:44 <shapr> Haskell is very powerful if you do XML processing, it has two different xml processing kits, HaXml and HxmlToolbox
00:15:34 <shapr> do you want more detail on any of this? or is that enough for now?
00:15:45 <Gavino> holy shit
00:15:55 <shapr> ?
00:15:57 <Gavino> is wash better than hws
00:15:59 <Gavino> ok
00:16:01 <Gavino> wait
00:16:14 <Gavino> hws stands for?
00:16:25 <Gavino> haskell web server?
00:16:27 <shapr> wash is sort of like CGI library, and hws is a 'haskell web server', they're not the same thing
00:16:28 <shapr> right
00:16:35 <Gavino> ok
00:16:53 <Gavino> so if I want to run a LAMP like combination of dataabse linux and werbserver to deliver busiiess apps
00:16:58 <Gavino> in haskell
00:17:06 <Gavino> what do i use as the database?
00:17:13 <shapr> I'd use Postgresql
00:17:18 <shapr> but that's because I prefer it
00:17:23 <Gavino> I heard that is the strongest
00:17:32 <shapr> HSQL has drivers for ODBC, MySql, and Postgresql that I know of.
00:17:34 <Gavino> open database
00:17:42 <bring> Martin's hws modules, they're written in Haskell I take it?
00:17:43 <Gavino> hsql?
00:17:50 <shapr> bring: yup
00:18:15 <shapr> HSQL is in the CVS tree of http://sf.net/project/htoolkit/
00:18:23 <bring> would be cool to write an xmlrpc module, that way you could have an all-haskell standalone xml-rpc server
00:18:31 <shapr> yah, it would
00:18:48 <shapr> you know Martin?
00:19:00 <shapr> I can never tell which gbg people know which others.
00:19:22 <bring> not by name anyway, he might be in one of my classes
00:19:43 <shapr> he's Marvin-- on freenode, and MarVin on gimp.net
00:19:54 <shapr> oh, that probably doesn't help you :-)
00:20:09 <shapr> Gavino: any other questions?
00:20:17 <Gavino> what si an xml=rpc server?
00:20:40 <shapr> rpc is short for "remote procedure call"
00:20:43 <Gavino> What is an xml-rpc server?
00:20:45 <Gavino> ok
00:21:04 <Gavino> that means?
00:21:09 <Gavino> instead fo a webserver
00:21:13 <Gavino> html
00:21:13 <shapr> you can do rpc is a variety of ways, COM and DCOM are standards on windows...
00:21:16 <Gavino> u serve xml
00:21:34 <shapr> no, rpc means programs can request and serve data to each other
00:21:42 <Gavino> ok
00:21:50 <Gavino> accross different servers?
00:21:52 <shapr> right
00:21:56 <Gavino> ok
00:21:58 <Gavino> so
00:22:00 <shapr> or on the same computer as well
00:22:05 <Gavino> then u dont need webserver
00:22:19 <Gavino> hmm
00:22:21 <shapr> a good rpc mechanism doesn't care whether it's local or remote, the transport layer should worry about that.
00:22:28 <Gavino> ok
00:22:36 <Gavino> so then u can build online apps
00:22:40 <shapr> a webserver is usually for serving xml or html
00:22:41 <liiwi> squish
00:22:49 <shapr> hei liiwi, mitta kuuluu?
00:22:52 <Gavino> can common web browsers request info from rpc servers?
00:23:02 <liiwi> aamupÃ¤ivÃ¤Ã¤
00:23:25 <bring> Gavion: not as far as i know
00:23:31 <shapr> most web browsers can download javascripts and execute them, and java applets and execute them.
00:23:40 <bring> true
00:23:54 <shapr> Java has its own RPC mechanism, and I think you can use it with applets
00:24:04 <shapr> but it's expensive in terms of runtime resources
00:24:25 <liiwi> hrm, is 40GB of javascript out of 1.5TB per month a lot?
00:24:28 <shapr> I think Java RPC uses CORBA, and IIOP as the transport
00:24:29 <Gavino> so how can one use simply haskell to deliver web apps?
00:24:32 <shapr> liiwi: ouch
00:24:47 <Gavino> similar to the LAMP combination of linux mysql php apache
00:25:10 <shapr> well, the P can also be Perl, Python, or other things
00:25:17 <Gavino> yes yes
00:25:22 <Gavino> or haskell I suppose
00:25:29 <shapr> lamh ?
00:25:31 <liiwi> and this is not even doing anything complicated, just glueing pages, doing some browserchecks and menus
00:25:39 <Gavino> but something seems overcomplicated abot the LAMP combination
00:25:56 <shapr> like what?
00:26:04 <Gavino> i dot know
00:26:15 <Gavino> for example in mysql you must qrite sql
00:26:18 * liiwi prefers LAPP or LPT
00:26:19 <Gavino> write
00:26:25 <shapr> oh, there are solutions for that
00:26:27 <Gavino> then u msut put thsoe queries into you php
00:26:33 <shapr> Python has SQLObject, Haskell has HaskellDB
00:26:34 <Gavino> and then set apache si run
00:26:35 <Gavino> etc.
00:26:51 <Gavino> it seems oen should eb able to run web apps with simply the OS and 1 programming language
00:27:00 <shapr> you can also use SQLRelay to get generic SQL working with many flavors of databases.
00:27:06 <Gavino> what is haskellDB
00:27:22 <bring> "Haskell has HaskellDB", you are very confident that we will deliver :)
00:27:29 <shapr> bring: I am, it's true.
00:27:41 <shapr> plus if you can get the Trex stuff working, and you open source it
00:27:55 <shapr> then I'm sure someone (me) will keep working on it.
00:28:06 <bring> we actually got rid of Trex
00:28:11 <shapr> I'm so happy to hear that.
00:28:43 <shapr> Gavino: HaskellDB and SQLObject both give a 'language native' view of a SQL Table, Row, type, etc
00:29:41 <shapr> Python has objects, so its SQLObject library creates objects and methods that represent and operate on the underlying data.
00:29:55 <bring> for HaskellDB's purposes, it's easy enough to simulate extensible records using multi-parameter type classes
00:30:14 <shapr> to me, this means you have already delivered :-)
00:30:58 <shapr> I think SQL is older than me.
00:31:08 <bring> :)
00:31:14 <shapr> IBM's Project R in 1970 maybe?
00:31:27 * shapr googles
00:31:36 <shapr> oh, System R
00:31:45 <shapr> http://www.mcjones.org/System_R/
00:31:58 <bring> I think autoconf is older than most of us (need to bash it some more, still a little pissed off)
00:32:04 * shapr laughs
00:32:16 <shapr> I liked the t-shirt andersca found.
00:32:26 <shapr> hey, have you seen the Hindley-Milner T-shirt?
00:32:33 <shapr> Gavino: any other questions?
00:33:07 <shapr> oh, I still didn't really explain HaskellDB
00:33:19 <bring> no
00:33:40 <Gavino> ?
00:33:44 <Gavino> ok
00:33:55 <shapr> Haskell's 'native view' is algrebraic datatypes, so HaskellDB gives you set theory operations on SQL tables,rows, etc
00:33:56 <andersca> I also like http://www.cafeshops.com/doitmonad.7154442
00:33:56 <Gavino> does haskell db replace postgresql?
00:34:12 <shapr> no, HaskellDB is a layer on top of postgresql
00:34:25 <shapr> it generates SQL to send to the underlying database.
00:34:46 <shapr> one great advantage there, is that *you* don't have to write all the SQL
00:35:01 <shapr> I've written way too much SQL in the last twelve years or so
00:36:09 <shapr> bring: http://www.cafeshops.com/skicalc.6225368
00:36:25 <shapr> the image on the back is great
00:36:39 <shapr> designed and cafepress'd by Riastradh 
00:36:54 <shapr> Gavino: anything else?
00:37:55 <bring> haha
00:37:58 * shapr sings the "let in snow" song
00:38:01 <bring> they're both excellent
00:38:04 <shapr> er "let it snow"
00:38:09 <saz> haskell db? I should try that one day
00:38:20 <shapr> saz: as soon as its released ;-)
00:38:32 <shapr> bring and forester are doing the GHC conversion.
00:38:38 <saz> oh! heh, I'll keep an eye out then :)
00:38:42 <shapr> g'day saz, what's up?
00:38:48 <bring> coming next week, to a compiler near you
00:38:48 <saz> not a whole lot
00:38:51 <saz> lots of moving
00:39:18 * bring needs to go to class soon
00:39:26 * shapr needs to go to work soon
00:39:43 * saz got home from work 2:20 ago
00:40:40 <bring> shapr: got to work, what does that mean? switching to another virtual desktop?
00:40:48 <andersca> haha
00:40:52 <Gavino> ok
00:41:01 <Gavino> so your saying that haskell can do more than sql?
00:41:08 <Gavino> but how does it store tables?
00:41:12 <shapr> almost any language can do more than SQL
00:41:18 <shapr> SQL was designed for a very specific purpose
00:41:21 <Gavino> hmmm
00:41:32 <shapr> but, SQL is really good at what it was designed to do
00:41:39 <Gavino> ok what makes you prefer haskell over say lisp or perl?
00:41:59 <shapr> I think the safest answer is that Haskell fits the way I think.
00:42:11 <andersca> and haskell is strongly typed!
00:42:12 <bring> haskelldb generates SQL queries that are sent to a database like postgresql
00:42:23 <bring> haskelldb doesn't store the table itself
00:43:03 <bring> as shapr said, it's a layer on top basically any relational database that uses sql
00:43:06 <shapr> bring: yes, going to work mostly means killing the #haskell buffer in emacs, otherwise #haskell is too distracting (by means of being far too interesting)
00:43:16 <bring> hehe
00:43:19 <Gavino> ahh
00:43:21 <Gavino> ok
00:43:32 <bring> to bad going to class isn't like that...
00:43:40 <bring> actually I quite like my classes
00:43:50 <shapr> which classes do you have?
00:43:58 <shapr> have you had anything with John Hughes?
00:44:29 <shapr> Gavino: lisp and perl are both powerful languages, I think you should try to use lots of different languages and see what fits the way you think.
00:44:38 <bring> I have one with him in a couple of hours
00:44:43 <shapr> cool
00:44:46 * andersca too
00:44:49 <shapr> I'd like to take classes with him.
00:44:55 <andersca> and next week it's lennart augustsson
00:44:56 <andersca> iirc
00:44:58 <shapr> w00!
00:45:01 <bring> he's also the advisor for the haskelldb project
00:45:05 <shapr> wow, nifty
00:45:21 <shapr> lennart has an impressive reputation in the hacker community.
00:45:42 <bring> oh, John is the advisor, not Lennart
00:45:48 <shapr> yah, I understand
00:46:08 <bring> I have never met Lennart, andersca, have you?
00:46:10 <shapr> too bad I didn't get to talk to John at ICFP.
00:46:14 <andersca> bring: nope
00:47:41 <shapr> Gavino: each language has some advantages and disadvantages when compared with other languages. I can describe the basic strength and weaknesses of Haskell and Perl, but I haven't used Common Lisp enough to give you a decent overview.
00:49:14 <shapr> I can also ramble on for days on a variety of programming language oriented subjects :-P
00:55:39 <shapr> bonjour kowey 
00:55:45 <shapr> comment ça va?
00:56:31 <kowey> bonjour
00:56:42 <kowey> ca va bien, et vous?
00:57:02 <shapr> pas mal
00:57:17 <shapr> bien mais je travailler
00:57:35 <shapr> are you looking for information about Haskell?
00:57:39 <kowey> moi aussi... but work means "learn haskell"
00:57:45 <shapr> oh! that's great!
00:57:58 <kowey> so far, none in particular, i've got Hal Duame's very nice intro
00:58:03 <shapr> yes, it is nice.
00:58:14 <shapr> have you installed GHC?
00:58:25 <kowey> exercises are such gifts to newbies, that's what i'm using
00:58:29 <Gavino> hmm
00:58:32 <kowey> seems he uses hugs in his examples
00:58:39 <Gavino> im intimidated about learning 1 language let aloen 4
00:58:47 <kowey> 4?
00:58:51 <shapr> Gavino: nah, it's not that hard.
00:58:54 <Gavino> i was unix admin
00:58:57 <shapr> me too!
00:58:58 <Gavino> kinda a monkey
00:59:00 <Gavino> ok
00:59:02 <Gavino> well
00:59:02 <kowey> ook
00:59:03 <shapr> I was a unix admin
00:59:07 <shapr> Oook!
00:59:09 <Gavino> good night folks
00:59:18 <Gavino> solaris 7
00:59:19 <shapr> good night Gavino, come back soon!
00:59:21 <Gavino> linux oh my
00:59:24 <Gavino> ok
00:59:26 <Gavino> cool I will
00:59:30 <Gavino> thx 4 linx
00:59:33 <shapr> sure
01:00:00 <shapr> kowey: Hugs is an interpreter written in C, GHC is a compiler written in Haskell
01:00:24 <shapr> so Hugs is fast and doesn't use much ram, and GHCi is slower, but GHC makes binaries
01:00:26 <kowey> written in Haskell? (grins)
01:00:45 <kowey> why is this? can't compilers optimise any better?
01:00:46 <shapr> yes, it makes more sense to write Haskell compilers in Haskell.
01:01:07 <shapr> Hugs runs on the Sharp Zaurus 
01:01:22 <kowey> is there some theoretical reason why haskell has to be slower than C? doesn't make sense
01:01:23 <Darius> GHCi is the GHC interpreter and it likely runs -code- faster, but it itself is rather large and (relatively) slow.
01:01:53 <shapr> I think it's a practical reason, specifically billions of dollars of research into making C fast
01:02:11 <Darius> And as GHC compiles via C... ;)
01:02:17 <kowey> hmmm...
01:02:26 <shapr> I'm looking forward to the new C-- backend.
01:02:43 <kowey> i've always been wondering if there's been anybody trying to write "real world" stuff like OS components in Haskell
01:02:47 <shapr> oh, if you want fun Haskell toys, lambdabot has many neat features.
01:02:57 <kowey> nod, thanks
01:03:03 <shapr> there is a neat project to get GHC running on the bare metal
01:03:13 <shapr> hOp for haskell Operating system
01:03:24 <shapr> Sebastian Carliér is the main guy on that.
01:03:34 <kowey> sounds fun
01:03:42 <shapr> yes, I agree
01:03:59 <shapr> hoi earthy 
01:04:15 <earthy> morning
01:04:56 <shapr> the largest problem with Haskell (in my opinion) is that space leaks that come from laziness can be hard to find.
01:05:21 <shapr> on the other hand, that's a really small problem compared to the problems in many other languages.
01:06:26 <shapr> have you already seen the learning Haskell page in the channel topic?
01:06:37 <shapr> heya Darius, what's up?
01:06:43 <kowey> made a mental note
01:07:28 <kowey> speaking of learning haskell: would some of you be interested in writing a wikibook?
01:07:36 <shapr> I would
01:07:45 <kowey> i was thinking "Introduction to Functional Programming" using Haskell as the vehicle
01:07:59 <shapr> there's a lot of stuff on the Haskell wiki already
01:08:16 <kowey> ooh, if it's GFDL, we could just import it right in
01:08:23 <kowey> http://wikibooks.org/wiki/Main_Page
01:08:28 <shapr> I don't think it's specifically licensed
01:09:08 <Darius> shapr: I hacked a bit more on my virtual machine and noticed Helium updated.
01:09:13 <Gavino> so haskell can do web sites 
01:09:15 <Gavino> cool
01:09:51 <shapr> think you'll have a release of your virtual machine sometimes soon?
01:10:29 <shapr> wow, haskell is mentioned in the beginning of the computer programming wikibook
01:10:48 <kowey> that was me
01:11:33 <Darius> shapr: As a virtual machine it seems to work fine.  I want to set up a script to run it through Daan's LVM tests.
01:12:05 * shapr fixes spelling in the programming wikibook
01:12:07 <Darius> But what I really need for the kind of things I want to use it for is a code generator, preferably running on LVM.
01:12:20 <Darius> I'm trying to think of the easiest way to do that.
01:14:13 <Gavino> ok
01:14:35 <Gavino> man i love girls with big titties
01:16:31 <Darius> shapr: What would make it really easy (though likely tedious) is if Helium could compile itself.
01:18:33 <shapr> I thought helium was 100% interpreter?
01:20:01 * shapr looks
01:20:46 <shapr> it looks like helium 1.2 is the package name, but helium 1.1 is the announcement version
01:22:36 <Darius> Helium is a bytecode compiler.
01:23:26 <shapr> oh, I get it now.
01:23:35 <shapr> yay, Helium builds quickly
01:23:36 <Darius> Or rather it outputs a core format and the lvm code has a core->lvm compiler.
01:23:55 <Darius> And wordcode would be closer than bytecode.
01:24:36 <Darius> Which, if I ever get somewhere with this and Daan hasn't handled it already, I'd probably talk to Daan about.
01:24:54 <shapr> I think he'd be interested in what you already have.
01:27:51 <Darius> At this point about all I have is a strange, slower, less featureful version of lvmrun.
01:28:20 <Darius> Though it does have the benefit that it's generated from (somewhat ugly) Haskell.
01:28:48 <shapr> as I understand it, one of your goals is something that does dynamic loading of modules better than anything else, right?
01:28:49 * Darius wonders if modifying NHC's backend to produce LVM might be the quickest way forward.
01:30:11 <shapr> I sent some really simple Parsec questions to Daan when I was learning it, he was immediately helpful, it seems to me he'd be much more interested in higher level questions, he may have already thought of something related to what you're doing.
01:30:53 <shapr> I wonder if anyone is maintaining Parsec, it could really use some of the extended combinators I've seen floating around.
01:31:01 <Darius> shapr: I guess that's a way to put it.  I'm aiming at something that can be used for an image-based Haskell and as an embedded (as in Guile) Haskell.
01:31:56 <shapr> as you know, I'd be very interested in such a thing, since it'd make Hemacs worthwhile.
01:32:06 <Darius> In both of those scenarios dynamic loading of code would be the norm (and likely only possible way).
01:32:30 <shapr> imho, until Haskell can be as dynamic as elisp, Hemacs isn't worthwhile.
01:34:52 <shapr> In person, Daan can be very entertaining. Especially after a beer :-)
01:35:23 <kowey> a very lazy stub: http://wikibooks.org/wiki/Programming:Functional_programming
01:35:32 <kowey> and eric gets back to learning haskell :-)
01:41:21 <shapr> sometimes I think Haskell would take over the world if we could extend ICFP an extra week and furnish beer, internet, and hardware, and just put "hacking" on that part of the schedule.
01:42:28 <shapr> this is interesting: http://lambda.weblogs.com/discuss/msgReader$10683?mode=topic
01:42:37 <shapr> from andrew cooke's message to haskell-cafe
01:43:55 <shapr> seems like a thread esap would want to read.
01:53:28 <shapr> ooh, the evil strikes: http://www.microsoft.com/education/?ID=SecurityPosters
01:55:12 <Maddas> err
01:59:55 <shapr> @yow
01:59:56 <lambdabot> I'm pretending I'm pulling in a TROUT!  Am I doing it correctly??
02:07:29 <Darius> shapr: What it says on the Hacker's Ahead one is amusing.
02:07:48 <shapr> yup, I think I'll stick that one on my office door.
02:11:03 <Maddas> haha
02:17:48 <shapr> silly question, does the debian spiral have its own name?
02:20:02 <shapr> http://letters.oreilly.com/graphics/parodies/puis.gif
02:36:43 <Lunar^> shapr: Debian spiral ?
02:36:50 <Lunar^> shapr: Swirl ?
02:37:50 <shapr> is that its name?
02:38:10 <shapr> google says yes
02:39:19 <ned> this could be the name :) :
02:39:20 <ned>                _sudZUZ#Z#XZo=_
02:39:20 <ned>             _jmZZ2!!~---~!!X##wa
02:39:20 <ned>            .<wdP~~            -!YZ,
02:39:20 <ned>      _    .mX2      _%aaa__     XZ[   _     _
02:39:23 <ned>     | |   oZ[    _jdXY!~?S#wa   ]Xb. | |   (_)
02:39:25 <ned>   __| |  _#e'   .]X2(     ~Xw|  )XX. | |__  _  __ _ _ __
02:39:28 <ned>  / _` |  .2Z`   ]X[.       xY|  ]oZ. | '_ \| |/ _` | '_ \
02:39:30 <ned> | (_| |  .2#;   )3k;     _s!~  jXf`  | |_) | | (_| | | | |
02:39:33 <ned>  \__,_|   1Z>   -]Xb/    ~   __#2(   |_.__/|_|\__,_|_| |_|
02:39:35 <ned>           -Zo;   +!4ZwaaaauZZXY'
02:39:38 <ned>           `*#[,   ~-?!!!!!!-~
02:39:40 <shapr> aieee
02:39:40 <ned>             XUb;.
02:39:43 <ned>              +3#bc,
02:39:45 <ned>                ~~~~
02:39:46 <Maddas> er
02:39:55 <shapr> ned: looks nice, I want a copy
02:40:11 <ned> www.debian-fr.org with text-navigator
02:40:21 <shapr> though unexpected ascii art on IRC channels is usually considered impolite
02:40:36 <ned> 'k, didn't know, sorry
02:40:38 <ned> :)
02:40:39 <shapr> no worries
02:40:47 <shapr> I think I'm going to rip out @moo for the same reason
02:41:02 <Maddas> heh :)
02:41:27 <shapr> I found this also: http://lists.debian.org/debian-devel/2001/debian-devel-200107/msg00686.html
02:41:46 <shapr> that one looks really nice
02:41:51 <shapr> I think I'll steal it for my /etc/issue
02:42:02 <ned> yeah !
02:42:28 <shapr> there's a nice reformat of it here : http://lists.debian.org/debian-devel/2001/debian-devel-200107/msg00691.html
02:43:12 <shapr> hi strat
02:52:02 <shapr> when do you seen issue.net? only with telnet?
02:53:09 <shapr> oh, anything using getty
03:18:57 <det> shapr: apt-get install linuxlogo, that ascii art is shamelessly ripped!
03:22:22 <shapr> aw, I wanted to hear about Hipo's squirrel.
03:23:31 <shapr> det: linuxlogo isn't as good as the pretty ascii logos mentioned earlier
03:24:02 <shapr> plus it makes me want to buy more ram :-)
03:36:10 <det> yes, linuxlogo is a evil conspiracy by the  hardware manufactuers to shame you into buying new hardware :)
03:52:14 <shapr> I have only 512mb, I really *need* another 2GB, I promise!
04:22:51 <shapr> ack, I can't think in Python anymore.
04:23:23 <shapr> mmm, cheese
04:23:38 <shapr> hi cheese, what's up?
04:24:00 <swisscheese> Greetings. Ready for another stupid question?
04:24:47 <shapr> sure
04:25:15 <swisscheese> data Tree = Board [Tree]
04:25:15 <swisscheese> newMoves :: Tree -> Board -> [Board]
04:25:15 <swisscheese> newMoves (b t) brd = ...
04:25:15 <swisscheese> Why error "unexpected symbol "t"
04:25:41 <ski> b isn't a constructor
04:26:21 <shapr> you can say "newMoves (Board t) = ..."
04:26:25 <ski> perhaps you want "newMoves (Board t) brd = ..."
04:27:02 <shapr> right, that unpacks the Tree and assigns the list of Tree inside it to the var named t
04:27:22 <ski> (s/assigns/binds/  :)
04:27:26 <swisscheese> Maybe my data is wrong - I want a tree where each node is a pair of board with tree.
04:27:31 <shapr> right, bind
04:27:54 <ski> swisscheese : yes, you type isn't that
04:27:57 <ski> try
04:28:09 <ski> data Tree = Node Board [Tree]
04:28:39 <shapr> oh, I thought of a case where double colons could happen in an XmlRpc call!
04:28:42 <shapr> aha
04:28:51 <ski> the first thing "Node" is a tag/label (known as constructor), the following two things are the type of the two parts
04:29:07 <shapr> this is probably a perfectly legal url --> http://::1:9673/
04:29:16 <shapr> heck that's three colons
04:29:17 <swisscheese> OK - got it but it seems strang to name it twice - once with Tree and once with Node.
04:29:50 <shapr> yow, galeon does *not* like that url.
04:30:03 <ski> swisscheese : that's because you could have different variants of a tree
04:30:32 <shapr> is it illegal to put ipv6 addresses into an url?
04:30:37 <ski> swisscheese : i.e. "data Tree = Node Board [Tree] | AnotherNode String Tree"
04:30:55 <ski> shapr : i dunno
04:31:12 <swisscheese> OK, thanks, will try.
04:32:07 <ski> swisscheese : with that datatype definition, a tree can be either a Node of a Board and a list of Trees, *or* it could be AnotherNode of a String and just a single Tree
04:33:34 <ski> swisscheese : simpler case of multiple variants : "data Season = Winter | Spring | Summer | Autumn"  (in this case none of the constructors has any parts/arguments)
04:37:04 <swisscheese> OK, thanks.
04:37:40 <ski> You see what the tags/labels/constructor names are for ?
04:39:14 <ski> If one is sure that a datatype is only going to have one variant, then somepeople call it the same as the type itself. (This can be confusing to read, if one's not aware of it.)
04:39:16 <swisscheese> Yes i think so - I am revamping the code now.
04:39:30 <shapr> swisscheese: http://www.scannedinavian.org/AvianWiki/HaskellDemo
04:39:31 <ski> e.g. "data Tree = Tree Board [Tree]"
04:39:41 <shapr> might be interesting
04:40:28 <shapr> oh, I gotta try haddock as a moinmoin processor
04:40:30 <ski> (also, IIRC, it's then not possible to export the type-name but not the constructor-name, from the module)
04:41:25 <shapr> meaning you can't make factories then
04:41:34 <shapr> that's neat, I hadn't thought of that.
04:41:57 <ski> factories ?   function replacement for constructor ??
04:42:07 <shapr> yup
04:42:58 <ski> well, one could of course still make them, but not hinder anyone from using the real constructor  (but perhaps that's implicit in the factory concept ?)
04:42:59 <shapr> the first factory that comes to mind in Java is the X.509 certificate stuff, it returns a Certificate, but that's an abstract superclass, with concrete subclasses of PKCS12Certificate, etc
04:43:58 <shapr> I can't think of a good reason to use factories in Haskell, but I know I've seen it done before
04:44:24 <ski> i haven't used them (yet) so i don't know very much about it
04:44:58 <ski> was it something about putting the factory in an updatable location, so one could update running things ??
04:45:41 <shapr> I don't remember
04:45:52 <ski> ok, no matter
04:46:06 <shapr> when I see it again, I'll tell you about it.
04:46:12 <ski> thanks
04:46:17 <shapr> so if you get a random email from me six years from now, don't be surprised ;-)
04:46:29 * ski chuckles
04:49:02 <ski> hmm, i would like local modules, i think
04:49:07 <shapr> what's that?
04:49:47 <ski> i'm not so fond of writing EThis and EThat as constructor names, just because another type (in the same) module has constructors TThis and TThat
04:50:06 <shapr> yah, I understand that.
04:50:13 <Darius> ski: module Foo ( Tree ) should only export the type, if not I'm pretty sure module Foo ( Tree() ) would.
04:50:32 <ski> or things like MyCurrentProjectThisFunction and MyCurrentProjectThatConstant
04:51:05 <ski> Darius : hmm, ok. you may well be right about that
04:51:41 <ski> shapr : of course one can split the module into separate ones, and use qualified input
04:52:06 <ski> though sometimes that seems a bit overkill (perhaps that's just me)
04:52:36 <ski> s/input/import/
04:53:09 <ski> (also, this might invoke mutually recursive modules)
04:53:15 <ski> (i think)
04:56:04 * isomer is away: work
04:59:56 <shapr> can I cheeze haddock into using stdin as input and stuffing html onto stdout?
05:02:08 <swisscheese> Thanks - gotta go to work. Bye for now.
05:02:22 <shapr> bah, I don't think haddock deals with stdin or stdout at all.
05:02:27 <ski> bye swisscheese
05:02:31 <shapr> cya swisscheese 
05:14:23 <shapr> aha
05:17:57 <ski> ?
05:21:21 <shapr> I think I've got a cheezy solution to the haddock thingy
05:21:29 <shapr> doesn't quite work though
05:21:44 <shapr> I need a module name regex
05:24:35 <shapr> it doesn't quite work: http://www.scannedinavian.org/AvianWiki/HaddockTest
05:29:14 <shapr> I don't know how to give it a good reference to the haddock.css
05:31:03 <shapr> anyways, it's a cute hack
05:39:08 <kowey> anyone here use vim?
05:39:17 <Maddas> I'm sure some people do
05:39:43 <kowey> was wondering if anyone knew how to make vim indentation haskell friendlier
05:41:09 <ski> kowey : perhaps this is appopriate ?  : http://www.haskell.org/libraries/hs.vim
05:41:15 <Maddas> oh, heh, I don't know, I wish I would
05:41:48 <kowey> will take a look, thanks
05:42:01 <Maddas> The default vim haskell.vim is a newer version
05:42:08 <kowey> it does syntax highlighting fine, btw, just indentation... hmmm
05:42:10 <Maddas> At least mine says " Last Change:  2003 May 04
05:42:20 <Maddas> (same author)
05:42:56 <Maddas> I heard the emacs-mode has really good indentation
05:42:58 * Maddas ponders
05:43:39 <shapr> aha, I improved it: http://www.scannedinavian.org/AvianWiki/HaddockTest
05:44:36 <ski> shapr : hmm, should that really display "Util" ?
05:44:51 <shapr> where?
05:44:57 <ski> you link
05:44:59 <ski> your
05:45:22 <shapr> nah, it's just wikified Haskell source.
05:45:34 <shapr> also, I *really* need to fix the module name finding code
05:45:35 <kowey> that's what the Duame tutorial says on xemacs
05:45:37 <ski> "Util .. Synopsis .. join :: [a] -> [[a]] -> [a] ...."
05:46:00 <kowey> wish emacs and vim communities would standardise on default indent behaviours
05:46:12 <shapr> ski: click on the EditText link at the bottom and look at the source
05:46:47 <Maddas> kowey: I think the problem isn't the idea of the behaviour, just lack of consistent implementation
05:47:47 <kowey> maddas: the kind of thing that couldn't be fixed by editing the hs.vim file?
05:48:16 <kowey> it's like in C++ (vim indents public/protected/private, emacs doesn't... arrrrgh)
05:48:24 <Maddas> kowey: I don't know. :-)
05:48:36 <kowey> :-)
05:48:44 <kowey> thanks for the links
05:48:47 * kowey skips along
05:48:49 <Maddas> Maybe they just didn't know how to fix the indentation properly! ;)
05:50:15 <shapr> ski: if click EditText on that page you'll see the module is named Util
05:50:34 <ski> mm, see that, ok
05:50:45 <ski> which func.s ?
05:50:54 <shapr> ?
05:51:23 <ski> sorry, which function(s) implemented your "cheezy solution" ?
05:51:57 <shapr> oh, my code says "find the second line, cut off the first eight characters, assume the rest is the name of the module"
05:52:07 <shapr> er, first seven
05:52:56 <ski> hmm , don't see it
05:56:37 <shapr> ok, I put the python source for the processor at the bottom of that page
05:57:37 <ski> aha, sorry, i thought you meant that it was (or should be) in that haskell file
06:05:06 <shapr> I guess I could write a regex to apply to successive lines until it matches
06:18:51 <Maddas> hm, shapr can type spaces
06:19:27 * Maddas is confused
06:23:12 <SyntaxNinja> where's yellowbird?!
06:24:31 <Maddas> haha
06:24:48 <Maddas> what si the bo2k server?
06:25:32 <SyntaxNinja> Maddas: onlly ylowbrd knowxors!
06:26:15 <Maddas> shapr: don't you use a Kinesis Ergo keyboard?
06:26:54 <shapr> yes, I do
06:27:14 <shapr> SyntaxNinja: that whole conversation was quoteworthy
06:27:38 <Maddas> shapr: do they have a space key? I don't see any on the homepage's pictures
06:27:53 <shapr> Maddas: http://www.kinesis-ergo.com/images/adv_pclyt.gif
06:28:01 <shapr> SyntaxNinja: hey, did you see my haddock wiki hack?
06:28:11 <shapr> hej bring 
06:28:19 <bring> hey
06:28:26 <Maddas> oh, it's the "0" on http://www.kinesis-ergo.com/images/layoutem.gif
06:28:27 <Maddas> thanks :-)
06:28:36 <bring> back from class
06:28:47 <bring> andersca, what did you think of the lecture?
06:28:51 <shapr> oh, that's the embedded layout, which I never use
06:29:22 <Maddas> ok :)
06:35:12 <bring> shapr: IPv6 addresses, yikes
06:35:42 <shapr> they'll probably become common at some point.
06:36:17 <bring> so, how can you tell if the last part is a port or just the final part of the address?
06:36:18 <shapr> of course, GHC doesn't support IPv6 yet, though that's something else I'd like to investigate.
06:36:24 <shapr> I have no idea.
06:36:34 <shapr> in my copious spare time I'll ask on #ipv6
06:37:23 <ski> shapr : hmm, so the separator isn't . ?
06:39:10 <shapr> nope, try /whois shapr
06:39:16 <shapr> and you'll see my IPv6 address.
06:39:23 <ski> did that
06:39:31 <shapr> 3ffe:bc0:8000:0:0:0:0:237b
06:39:45 <ski> is there some prob with using . ?
06:39:47 <bring> and you can leave som of the colons out, right?
06:39:57 <shapr> for contiguous zeros, yes
06:40:13 <shapr> 3ffe:bc0:8000:0::0:237b or maybe 3ffe:bc0:8000::237b
06:40:15 <shapr> I forget which
06:40:31 <shapr> but you can only do it for one chunk of zeros
06:40:40 <bring> that should make it pretty hard to know if there is a port number at the end
06:40:57 <shapr> or maybe ipv6 port numbers use a dot :-)
06:41:04 <shapr> that would be sufficiently bizarre.
06:41:12 <bring> haha
06:41:16 <shapr> 3ffe:bc0:8000::237b.9673
06:43:53 <andersca> bring: cool stuff
06:44:49 * ski wonders how dependent types mix with continuations ...
06:48:06 <shapr> man, I want a help command in GHCi and Hugs
06:48:24 <bring> that prints the haddock doc for a function?
06:48:26 <ski> :h
06:48:29 <shapr> yes
06:48:30 <ski> :)
06:48:39 <shapr> python has a nice one
06:48:40 <bring> that would be nice
06:48:46 <ski> that would be nice
06:48:50 <shapr> I'd also like haddock support for running unit tests
06:48:52 <ski> bring : :)
06:48:58 <shapr> something like http://fit.c2.com/
06:49:00 <bring> :)
06:49:57 <ecraven> shapr: so you got one of those kinesis ergo kbds?
06:50:01 <SyntaxNinja> shapr: what's your haddock wiki hack?!
06:50:13 <ecraven> how do continuations mix with lazy languages??
06:50:43 <ski> ecraven : i'm not sure how it would mix with call-by-need
06:50:45 <shapr> SyntaxNinja: http://www.scannedinavian.org/AvianWiki/HaddockTest
06:50:56 <shapr> ecraven: sure, I've had a kinesis for years.
06:51:30 <ecraven> shapr: and you like it?
06:51:40 <shapr> wouldn't switch back to flat keyboard
06:51:52 <shapr> the only better keyboard I've seen isn't in production (and may never be)
06:51:53 <ecraven> shapr: i've been looking into more useful keyboards, i like the data hands, but 1k is a bit.. expensive..
06:52:17 <shapr> yah, I've never been rich enough to try datahand
06:52:33 <shapr> plus I'd want two hands, not one.
06:52:37 <ecraven> shapr: do you know if there's any real difference between the models? i can do macros in software, so the cheapest should be ok, right?
06:52:45 <shapr> kinesis is cheap at ~$300
06:52:46 <ski> ecraven : i think there is a CPS transformation for call-by-name, though
06:52:52 * Darius needs to find his Toxicity CD.
06:53:02 <SyntaxNinja> shapr: very intersesting!!
06:53:04 <shapr> ecraven: that's what I did, I got the cheapest and remapped everything in software.
06:53:25 <Darius> ski: What do dependent types and continuations have to do with each other?
06:53:32 <shapr> SyntaxNinja: for my next trick, I'm going to alter haddock to allow inline unit tests, and thereby enable FIT-style unit testing.
06:54:08 <ecraven> shapr: k, tx a lot :) i'll look into getting one of those.. though eur250 isn't cheap either..
06:54:25 <shapr> SyntaxNinja: here's an example of FIT testing - http://fit.c2.com/wiki.cgi?SimpleExample
06:54:59 <shapr> if you zip down to the bottom of that page, you'll see the http:run.cgi link
06:55:01 <ski> Darius : i dunno. but i was thinking about what dependent sum and coexponential would be  (as opposed to ordinary dependent product and function/exponential)
06:56:39 <ski> Darius : (and perhaps they would introduce a cominuation variable into the type ...)
06:56:55 <ski> aargs s/cominuation/continuation/ !
06:57:15 * ski wasn't thinking of komintern or something like that ..
07:01:15 <SyntaxNinja> shapr: cool :)
07:06:18 <ecraven> :( why is it so hard to get hardware in europe
07:06:29 <shapr> otherwise it'd be easyware
07:06:41 * shapr ducks
07:06:54 <ecraven> :)
07:07:18 <ecraven> there's no reseller for the cheapest one in europe, only the most expensive...
07:07:45 <shapr> they used to ship for free to europe, since they have no reseller other than .nl
07:08:01 <shapr> I guess at some point they realized that was a nice free 72e or so
07:08:22 <Maddas> I don't know if the datahand is good
07:08:30 <Maddas> It moves all the work to your fingers
07:08:45 <ecraven> i want to try one of those kbds before buying it..
07:08:52 <Maddas> that, too :)
07:09:11 <ecraven> i found a reseller for the datahands in austria, maybe i can try them.. can't buy them anyway though.. :(
07:09:13 <ski> shapr : 72e ?
07:09:21 <bring> @type (:)
07:09:21 <lambdabot> (:) :: a -> [a] -> [a]
07:09:38 <Maddas> hm, I would have to use the kinesis one for at least a month before deciding, luckily you can :)
07:09:47 <bring> can lambdabot give precedence info?
07:09:54 <ecraven> Maddas: but i found their idea good.. i think the datahands are a nice concept, but i'd have to try them to say whether i really want to work with them..
07:10:05 <ecraven> Maddas: you can?
07:10:09 <ecraven> Maddas: can you send them back?
07:10:20 <ski> bring : hmm, don't think so
07:10:22 <Maddas> shapr mentioned something of 30 days back (or even 60?)
07:10:27 <shapr> I think so
07:10:55 <Darius> @ghci could
07:10:55 <lambdabot> Sorry, I don't know the command "ghci", try "lambdabot: @listcommands"
07:10:56 <ecraven> hm.. i'll write them a mail
07:10:57 <ecraven> tx
07:11:06 <shapr> Darius: if only there were a nice way to make it safe
07:11:25 <Darius> shapr: What's needed is a foolproof way.
07:11:30 <shapr> right
07:11:33 <shapr> you have any ideas?
07:11:35 <Maddas> ecraven: let me know if they answer!
07:12:30 <ski> shapr : well, i suppose one could include an @info, right ?
07:12:36 <shapr> sure
07:12:48 <shapr> but even better would be the @ghci plugin with some foolproof safety mechanism
07:12:55 <ski> yes
07:13:00 <shapr> tom moertel's prelude dictd was nice
07:13:10 <ski> some sandboxy-like thing
07:13:14 <shapr> it converted haddocks into dictd format
07:13:38 <shapr> Is there a way to ensure that a command is pure?
07:14:30 <ski> hmm, are there more potential leaks than IO and unsafePerformIO ?
07:14:51 <Darius> Anything unsafeCoerce#-y
07:15:29 <ski> you mean for crashing-kind of unsafe
07:16:01 <ski> ?
07:16:22 <Darius> If you can violate type-safety almost all bets are off.
07:16:44 <ski> hmm, yes
07:16:58 <shapr> I wonder if Hampus has a later version.
07:18:13 <ski> could one make that ghci use a customized library, either with the bad things removed(/not exported/accessible) or with them replaced to some harmless thing ?
07:18:32 <shapr> probably so, maybe with -no-prelude or whatever
07:19:05 <shapr> maybe this is a good question for ghc-users
07:19:07 <ski> well, it'd be nice to still have the prelude
07:19:21 <shapr> right, but if you instead import SafePrelude.hs
07:19:52 <ski> ok, hm
07:22:00 <Darius> What if you set euid to Nobody or whatever before executing a command (or just when GHCi starts)?
07:22:53 <ski> (what's euid ?  e? user identification ?)
07:23:01 <Darius> effective
07:23:06 <shapr> might work
07:23:09 <ski> k
07:23:09 <bring> hmm, a program could still write to world-writable files and dirs
07:23:29 <shapr> and nice 20 ghc
07:23:35 <bring> and do exponential forking and that sort of thing
07:23:55 <shapr> resource limiting would help
07:24:03 <bring> and possibly run local root exploits
07:25:05 <shapr> so, user mode linux? :-)
07:25:17 <bring> hehe
07:25:43 <shapr> it's worth trying
07:25:45 <bring> what if you just strip down the standard libs, removing all IO functions
07:26:14 <shapr> how do you get your output?
07:26:30 <bring> it'd have to be the result of you function I guess
07:26:47 <bring> or maybe you could leave only putStr in
07:28:05 <bring> shapr: we're thinking of setting up a #haskelldb channel, for the development team, and anyone else who is interested
07:28:11 <shapr> cool!
07:28:17 <bring> would it be possible to use lambdabot for that?
07:28:24 <shapr> I would be privy to the inner workings
07:28:29 <shapr> sure
07:28:46 <shapr> @join #haskelldb
07:32:42 <det> haskelldb?
07:32:56 <shapr> it's spiffy
07:32:57 <det> db written in haskell OR bindings for a db ?
07:33:03 <shapr> neither actually
07:33:13 <shapr> it's SQLObject for Haskell
07:34:55 <shapr> det: google can find the HaskellDB homepage, bring and forester (and more?) are porting HaskellDB to GHC
07:35:35 <shapr> oh, someone on #ipv6 said urls should look like [ipv6::1]:port
07:37:29 * andersca ponders
07:37:34 * shapr lakers
07:38:42 <shapr> yay, ipv6!
07:39:16 <shapr> cool, I can ping6 to you.
07:39:32 <shapr> oh, I heard somewhere that AAAA is now A6 for DNS records.
08:00:51 <Lunar^> shapr: I read that when searching for DNS stuff
08:01:34 <shapr> do you know if true multicast really works with the Linux ipv6 drivers?
08:10:55 --- mode: truong.freenode.net set +b *!*@206.169.168.190
08:30:40 <eixei> Hi everyone
08:30:57 <ski> hi eixei
08:31:13 <shapr> hello eixei 
08:32:23 <Vulpyne> Hi.
08:33:03 <ski> eixei : do you know any haskell ?
08:33:21 <eixei> Well, let me put it this way, I am learning it :-)
08:33:32 <ski> ok, that's just fine :)
08:33:59 <ski> if you have any questions, you can always ask them here ..
08:34:05 <eixei> Thanks a lot :-)
08:44:52 <det> shapr: looks neat
08:45:04 <det> shapr: host -t AAAA me!
08:47:53 <det_> IPv6 with reverse, yo ;)
08:48:24 <Vulpyne> I have that too!
08:48:57 <shapr> hah
08:49:31 <shapr> isn't there a way to declare singleton types or something to use the type system to limit number sizes or string sizes?
08:50:00 <det> limit a string to a certain length ?
08:50:27 <shapr> right
08:50:47 <det> haskell strings are lists, yes ?
08:50:50 <shapr> they are
08:51:10 <det> well, then you'd have a tuple, yes ?
08:51:13 <Vulpyne> 'h':'i':[]
08:51:31 <Igloo> You'd probably have undecidability problems in useful programs if you tried that
08:51:40 <det> I dont imagine you can limit an infitite type toa certain length
08:51:46 <shapr> Igloo: is there a better way to limit string input sizes?
08:52:03 <det> shapr: test them ?
08:52:10 <Igloo> What do you do with these strings?
08:52:11 <det> shapr: why do you need to do this ?
08:52:16 <ski> shapr : hmm, guess one could perhaps use dependent types for that
08:52:23 <Darius> shapr: You couldn't use the type system to control their sizes at runtime.
08:52:41 <shapr> hej chucky_ 
08:52:45 <Igloo> You can make an abstract type and have the constructor check the size, but that would become a pain if you use a lot of standard list functions on them
08:53:21 <shapr> the question was, can you use the type system to increase input checking on varchar(16) or that sort of thing.
08:53:58 <det> shapr: I think it is a unamious "no" :(
08:54:25 <shapr> yah, sounds like it.
08:54:29 <ski> shapr : what's varchar(16)  (my man can't find it. umm, that sounds strange :)
08:54:30 <det> does haskell have exceptions ?
08:54:34 <Igloo> I don't think you could do much without declaring around 256 types
08:54:37 <det> ski: database stuff
08:54:44 <shapr> ski: it's SQL-specific, it means 0 to 16 characters
08:54:48 <det> ski: a string of at most 16 characters
08:54:56 <ski> ok, got it
08:54:59 <shapr> sure, Haskell has exceptions
08:55:10 <bring> I'm working on doing it by simulating dependent types
08:55:11 <Igloo> (and that assumes your DB only supports up to varchar(256) or so)
08:55:23 <Igloo> IM 255
08:55:24 <ski> (now that you say it, i do seem to vagueally remember it)
08:55:27 <det> shapr: at some point you must convert to a C string, if it is greater than 16 then raise an exception or truncate it ?
08:55:56 <bring> well, that's actually not a problem, the DB will do that for you, but without an exception
08:55:56 <shapr> yah, that's straightforward, but I was hoping for a cute type system trick if possible.
08:55:58 <Igloo> The DB will probably do one of those for you
08:56:47 <shapr> I've seen some discussion about using the type system for value checking with singleton types, but I've never gotten to learning what that means.
08:57:10 <det> I thougt a singleton type was a value that exists only once
08:57:12 <shapr> bring: do you have the dependent type code demo online?
08:57:17 <ecraven> Maddas: the 60 days money back is mentioned on their homepage, and they seem to have refurbished keyboards (still 2 years warranty and the 60 days) cheaper..
08:57:20 <bring> in a sec
08:57:35 <Maddas> ecraven: refurbished?
08:58:30 <Maddas> oh, ok
08:58:33 <ecraven> no idea :) i'm just writing them an email
08:58:36 <Maddas> ecraven: Sounds interesting, thanks! 
08:58:50 <bring> it's just a very quick hack inspired by a lecture on dependent types I went to today:
08:58:51 <Maddas> oh, cool. Any pricing for the refurbished keyboards?
08:58:52 <bring> http://www.dtek.chalmers.se/~d00bring/misc/BoundedList.hs
08:58:54 <shapr> refurbished should mean broken, sent in, and repaired
08:59:06 <Vulpyne> Learning a new keyboard layout would be a good excuse for switching to dvorak. :)
08:59:16 <shapr> yes, dvorak is cool!
08:59:21 <Maddas> I could live with that, shapr, as long as the warranty is there 
08:59:25 * Maddas furiously agrees with shapr 
08:59:28 <Vulpyne> shapr: You use it?
08:59:31 <shapr> yes, since 1992
08:59:42 <Vulpyne> Longer than me. :)
08:59:54 <ecraven> Maddas: 190 for the essential
09:00:06 <Maddas> USD, I assume
09:00:24 <Maddas> Sounds like it's worth a try!
09:00:25 <ecraven> Maddas: http://www.kinesis-ergo.com/Merchant2/merchant.mv?Screen=CTGY&Store_Code=KS&Category_Code=CKBDR
09:00:34 <ecraven> i wrote an email, asking about a reseller in the EU..
09:00:38 <Maddas> ecraven: thanks!
09:02:08 <bring> basically the programmer would have to do 'trunc str' which would truncate the string to the right length, and give the result a type that has a bound
09:03:45 <shapr> so you have to assign a safe type to the string?
09:03:53 <bring> yes
09:04:11 <bring> basically just making the programmer do the truncation explicitly
09:04:29 <bring> hopefully first checking the length too
09:04:38 <bring> oops, there's a bug in my trunc
09:04:48 <bring> no case for []
09:05:24 <ski> wondered about that
09:06:00 <bring> *Main> trunc "apapa" :: BoundedString (Succ (Succ (Succ Zero)))
09:06:02 <bring> L "apa"
09:06:06 <bring> fixed now
09:06:09 <bring> uploading...
09:08:08 <ski> would be nice if one could do this as a subtype of lists (in some imaginary typesystem)
09:08:21 <bring> hmm, yes
09:08:32 <ski> perhaps as a refinement type..hm
09:19:48 * esap blinks.
09:20:07 <bring> ok, wrote a function: checkSize :: Trunc n => [a] -> Maybe (List a n)
09:20:38 <bring> that returns Nothing if the list is too long, and gives the list a bound otherwise
09:20:46 <bring> seems to work
09:20:52 <shapr> hei esap 
09:21:10 <shapr> hyvää ihlta
09:21:14 <shapr> or something like that
09:21:22 <esap> hyvää iltaa
09:21:27 <shapr> yah, that one!
09:21:43 <ski> is 'iltaa' evening ?
09:21:48 <shapr> yup
09:21:49 <esap> yes
09:22:10 <shapr> that reminds me, I have swedish homework.
09:22:15 <ski> päive (or something like that) is day, right ?
09:22:22 <shapr> paiva ?
09:22:30 <esap> ski: päivä.
09:22:32 <bring> shapr: come on over to #haskell.se then
09:22:42 <ski> i haven't seen it spelled, only pronounced
09:23:19 <shapr> bring: my homework likes #haskell.se
09:23:57 <shapr> my teacher is suprised that my reading and writing of swedish is so much better than my spoken and listening.
09:24:09 <bring> :)
09:24:16 <ski> shapr : what kind of homework ? glossary, spelling, etc ?
09:24:39 <shapr> I think we're doing prepositions at the moment.
09:24:46 <ski> ok
09:24:47 <shapr> åt appears untranslatable.
09:25:27 <ski> it sometimes means rougly the same as 'till'
09:25:37 <ski> (i.e. to)
09:25:57 <shapr> I think it can also mean "in the place of"
09:26:04 <shapr> but I don't quite get that.
09:26:13 <ski> 'Ge filen åt GHC !'
09:26:28 <shapr> give the file in the place of GHC?
09:26:39 <ski> give the file to GHC
09:26:42 <shapr> oh
09:26:54 <shapr> neat
09:27:24 <ski> hmm, 'göra något åt någon' 'do something on someone's behalf'
09:27:35 <ski> hmm
09:27:36 <shapr> right, I've seen that one before
09:28:00 <ski> well, the specific phrase 'göra något åt' has different connotations
09:28:12 <ski> 'do something about'
09:28:24 <shapr> swedish is simple and easy in many ways, but it has a large number of prepositions
09:28:53 <ski> (often 'do something about
09:28:56 <shapr> my favorite difference so far is "sin"/"hans" versus "his" in english.
09:29:07 <ski> (often : do something about something bad)
09:29:39 <shapr> he drives his car in english can mean either "han kör sin bil" or "han kör hans bil" in swedish.
09:30:00 <Igloo> What's the difference?
09:30:10 <shapr> sin means very specifically "his own"
09:30:16 <ski> yes
09:30:21 <shapr> and hans means "his" as in some other male
09:30:29 <Igloo> Oh, right
09:30:32 <shapr> shapr takes Igloo's car
09:30:47 <ski> or "<the one we're talking about>s own"
09:31:38 <shapr> it's fun to see ways that my native language is not as exact as another language.
09:31:46 <ski> although i suppose one doesn't usually say thing like "han kör hans bil" at all
09:31:59 <shapr> what would you say?
09:33:29 <ski> well, "<the persons name or profession or whatever> kör hans bil" or the other way around
09:34:18 <ski> though i think "han kör hennes bil" or "hon kör hans bil" is more usual
09:34:46 <shapr> interesting, I think I understand why too.
09:35:19 <ski> shapr : if we have two 'han' in the same sentence, it could be hard to tell if the first one is, say, Peter, and the second is Johan, or if it is the other way around
09:35:32 <shapr> right, that makes sense.
09:35:44 <ski> so it's quite a bit ambigous
09:35:46 <bring> guess you could say "han[pointing at guy #1] kör hans[pointing at guy #2] bil"
09:35:55 <ski> yes
09:36:02 <shapr> oh, I have a nifty related bit of trivia
09:36:38 <shapr> when deaf people in the USA have a conversation, they point to a certain angle in front of them to signify a spatial pronoun for each person they're referring to in that conversation
09:37:08 <bring> so first they establish who's at what angle then?
09:37:14 <shapr> right
09:37:51 <shapr> so if you have three pronouns, 45° left would be one person, 90° straight ahead would be another, and 45° right would be the third
09:37:54 <ski> 'spatial pronoun' ?  like <the person standing to the right in front of me> ?
09:38:09 <ski> ok
09:38:14 <ski> interesting
09:38:18 <shapr> no, it's a spot about one hand's length in front of the 'speaker' and at a certain angle.
09:39:04 <ski> so they can't refer so someone standing a bit away with that ?
09:39:15 <shapr> I don't know
09:39:41 <shapr> I spent some time in the deaf community in Seattle, I only learned some bits and pieces.
09:39:47 <ski> ok
09:40:07 <shapr> the strangest thing was that they don't value hearing at all, many of them would prefer that their children were also deaf.
09:40:18 <shapr> anyways, back to Haskell ;-)
09:41:11 <ski> (ok)
09:41:33 <shapr> so ski, what have you been writing with Haskell lately?
09:45:37 <ski> well, this compiler i've begun with (for the course)
09:46:11 <ski> (and i've been writing some pseudo-haskell also)
09:49:38 <shapr> sounds like fun
09:49:40 <ski> (trying to express some Category Theory)
09:49:49 <ski> yes
09:49:56 <shapr> there's a big discussion about Category Theory on lambda.weblogs.com
09:50:05 <shapr> did you see andrew cooke's message to the haskell mailing list?
09:50:17 <ski> (well, except for the shell script and makefile twiddling)
09:50:26 <ski> now ?
09:50:36 <ski> no, i didn't
09:50:55 * shapr digs about
09:52:03 <ski> shapr : Type classes confusion ??
09:52:11 <shapr> http://lambda.weblogs.com/discuss/msgReader$10683?mode=topic
09:53:07 <shapr> anyways, andrew cooke seems to think the freely downloadable CT book is good.
09:53:24 * Darius wishes this multivariable calculus book used geometric algebra.
09:53:41 <Darius> Category Theory for the Working Computer Scientist?
09:54:12 <ski> shapr : which cooke msg to haskell mailing list ?
09:54:30 <shapr> ski: it gives the url I pasted above
09:54:58 <ski> umhm, ok
09:58:29 <esap> fokkinga has written some good papers, though some of them are somewhat needlessly obscure.
10:00:43 <ski> i think Conceptual Mathematics is quite good
10:01:27 <esap> I haven't read that one, I wish I had read more Lawvere.
10:02:08 <ski> though there seems not to be anything about adjunctions or natural transformations, and not very much on functors
10:02:28 <esap> heh, what does he talk about then :-)
10:03:29 <ski> well
10:04:14 <ski> he first goes though the basic things, quite slowly
10:05:45 <ski> objects,morphisms,identity,composition,identity cancellation,composition associativity
10:05:53 <Darius> How can a Category Theory book not have something about natural transformations?
10:06:38 <esap> natural transformations are, I believe, the reason why category theory exists :-)
10:07:05 <ski> he also talks about mono,epi,inverse,iso,retrations and sections and retracts
10:07:21 <Darius> Yes, Mac Lane invented Category Theory to study natural transformations.
10:07:44 <ski> yes
10:08:21 <ski> (well, at least they explicitely doesn't talk about nat. transf. or adj. (IIRC))
10:09:14 * esap thinks adjunctions are basically the same thing as inverses.
10:09:52 <ski> and they don't introduce functor formally either IIRC, though they use them here and there (and has infomal descriptions)
10:10:47 <ski> (hmm, well, i just remembered that i have the book with me, so i can check it)
10:11:32 <ski> hmm, well, of course they talk about UMPs (products, sums,terminal,initial,exponential)
10:11:58 <ski> and sub-object classifier (is that a cone or cocone concept ??)
10:12:00 <esap> yea, no category theory introduction can avoid limits and colimits.
10:12:49 <ski> actually, they start in the first chapter with products, before defining category !
10:12:59 <ski> (infomally of course)
10:13:17 <ski> "SPACE = PLANE x LINE"
10:14:20 <ski> hmm, and in the beginning chapters they mostly talk about the category of sets, though they mention upfront what is generally applicable and what's not
10:15:25 <ski> Ch. 10 is about Brouwers theorems (topology)
10:15:25 <esap> does it talk about covariance and contravariance?
10:16:20 <ski> then, as pet example categories, they use the category of endomaps and the category of graphs (and some subcategories and variants)
10:16:33 <ski> not where i've seen
10:16:49 <Darius> Category of graphs or graphs as categories?
10:17:23 <ski> Category of graphs   (possible they mention the other somewhere too, can't remember right now)
10:18:27 <ski> my brother has calculated part of an exponentiation table for some graphs
10:20:50 <ski> distributive law of product over sum. linear categories. cat of pointed sets. binary operations, actions and Cantors diagonal argument, map objects (as i said)
10:21:36 <ski> exponent laws. cartesian closed. subobjects, logic and truth. some on toposes
10:22:08 <esap> sounds very much like a lengthier version of the 'categorical primer'.
10:23:51 <ski> in the beginning part they talk quite a lot on equations f = g . h, and what sols. it can have if some of f,g,h are given. also with restrictions of domains or codomains to be equal to some of the other ones
10:24:40 <ski> (oh, idempotents and automorphisms too)
10:26:59 <ski> (as Darius must have noticed)
10:41:00 <ski> hi NeuNeu
10:41:08 <NeuNeu> hello
10:41:50 <ski> what brings you here to this wonderful channel ? ;)
10:41:56 <NeuNeu> Haskell seems sooo difficult to learn...
10:42:15 <NeuNeu> for a little guy like me..
10:42:25 <ski> bah, just forget most of c and python and so on  :)
10:42:25 <shapr> what's difficult?
10:42:46 <ski> (except pythons significant whitespace)
10:43:42 <NeuNeu> hehe i'm a newbie in programming world... All I know is some VB and Python... there is so much to learn...
10:43:56 <ski> the basics is actually pretty simple   (well, maybe not if you think simple algebra is very hard)
10:44:43 <ski> yes, there is :)
10:44:52 <ski> and much of it is fun fun !
10:45:29 <Darius> Meh, we've only been going at it 40-50 years, there can't be that much relatively.
10:45:32 <ski> hmm, well, if you're a newbie to programming, then it could be that haskell is easier to learn for you
10:45:59 <NeuNeu> really?
10:46:21 <shapr> yes!
10:47:00 <ski> yes, because people who have learned one programming paradigm well often has trouble unlearning things they have taken totally for granted
10:48:18 <ski> and the still more or less dominant paradigm is the imperative one (tell/order the computer what to *do*)
10:48:34 <NeuNeu> that's may be true... but Haskell seems to be a bit hard for a newbie...
10:48:54 <NeuNeu> so little code that do so much...
10:49:02 <Vulpyne> Might be easier if you already know a lot of math.
10:49:18 <NeuNeu> (sorry for my bad english... i'm french)
10:49:25 <shapr> pas de problem
10:49:26 <ski> yes, that's often good for readability
10:49:37 <NeuNeu> :)
10:50:28 <Darius> Vulpyne: About all the math you need to know for (the idea of) Haskell's semantics is some middle school level algebra.
10:51:18 <shapr> plus we have @eval
10:51:24 <shapr> and that can explain almost everything
10:51:30 <shapr> @eval 1 + 1
10:51:31 <lambdabot> 2
10:51:39 <shapr> see the power of Haskell at work!
10:51:47 <NeuNeu> i'm not really a maths man... I love programming, always want to know more about programming language, but maths argg...
10:51:52 <ski> @eval reverse {1,2,3]
10:51:52 <lambdabot> (line 1, column 9):
10:51:52 <lambdabot> unexpected "{"
10:51:52 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
10:51:57 <ski> oh
10:52:03 <ski> @eval reverse [1,2,3]
10:52:04 <lambdabot> [3, 2, 1]
10:52:05 <ski> :)
10:52:14 <Darius> New syntax for a partially ordered set ski?
10:52:20 * shapr grins
10:52:32 <ski> Darius : well, that could be interesting :)
10:52:34 <Vulpyne> Darius: Heh, I don't really know that. :)
10:53:24 <ski> NeuNeu : well, it's not like you need to know calculus or linear algebra or such to understand haskell
10:53:55 <NeuNeu> anyway.... sorry for disturbing... but someone know Adele Goldberg and smalltalk?
10:54:00 <shapr> @eval (+ 1) 1
10:54:00 <lambdabot> (line 1, column 2):
10:54:00 <lambdabot> unexpected "+"
10:54:00 <lambdabot> expecting simple term
10:54:03 <NeuNeu> !ping
10:54:14 <shapr> @eval (\x -> x + 1) 1
10:54:14 <lambdabot> 2
10:54:25 <shapr> @eval map (\x -> x + 1) [1,2,3,4]
10:54:25 <lambdabot> [2, 3, 4, 5]
10:54:45 <ski> NeuNeu : no, who's she ?   (smalltalk i know some)
10:54:54 <shapr> I've read about Goldberg
10:57:16 <ski> NeuNeu : hmm ?
10:58:04 <NeuNeu> she worked on smalltalk...
10:58:29 <ski> (ok, i almost guessed that :)
10:58:37 <NeuNeu> and i'm doing an "exposé" on her.. (don't nkow how we say this in english)
10:59:29 <ski> some sort of essay ?
10:59:59 <NeuNeu> heu... yes an "oral essay"
11:00:09 <ski> ok
11:00:31 <ski> so, you have to find material on her then, guess
11:01:53 <NeuNeu> minutes plz... i have big difficulties to explain myself.. sorry
11:02:04 <ski> no problem
11:02:04 <shapr> NeuNeu: http://c2.com/cgi/wiki?AdeleGoldberg
11:02:58 <shapr> and click on the page title to see the backlinks
11:04:43 <NeuNeu> thanx shapr 
11:05:28 <shapr> http://c2.com/cgi/wiki is the very first wikiwiki
11:05:43 <shapr> content-wise it's strong on Smalltalk and Extreme Programming
11:06:19 <shapr> that's partially because Extreme Programming came out of the Smalltalk community on c2.com 
11:06:42 <NeuNeu> but it's not what i'm searching for :) i'm trying to make something on "her" in what way she was a "revolutioner" in the world of language..
11:08:15 <shapr> from what I've read, several people on the wiki knew her, and have written some about her.
11:08:33 <NeuNeu> but thanx anyway! haskell community is alwase trying to help... :D
11:08:37 <shapr> of course!
11:10:43 <ski> hmm, roughly how much haskell do you know ?
11:13:38 <NeuNeu> :) praticly nothing... I'v heard about a compleate functional language named haskell 2 months ago...
11:13:50 <ski> ok :)
11:14:58 <ski> perhaps y'would like to look at http://www.scannedinavian.org/AvianWiki/HaskellDemo
11:15:04 <NeuNeu> hope it's not a shame for me...
11:15:07 <NeuNeu> yes
11:15:12 <ski> (if yer interested, i.e.)
11:15:38 <NeuNeu> of cours i'm interested, thanks
11:16:04 <ski> the lines beginning with -- are just comments, so that's nothing to be afraid of ;)
11:16:30 <NeuNeu> yea :P
11:17:40 <ski> so the way in a haskell source file to define most things is with an = sign
11:18:14 <NeuNeu> ok...
11:18:14 <ski> both constants and functions and types  (e.g.)
11:18:59 <ski> name to the left (with parameters/arguments also, if it is a function), an =, and then what that is defined to be/return
11:19:13 <NeuNeu> ok... but it's seems to be variables... and there's no variable concept in haskell... ?
11:19:26 <ski> well
11:19:52 <ski> there is. but it is not the same one as in imperative languages (like Python or VB)
11:20:54 <ski> actually many people think that the kind of variables in functional programming languages (FPLs) is more similar to the ones in math, than the imperative ones are to the math ones
11:21:06 <ski> (including me :)
11:21:42 <NeuNeu> okay...
11:21:52 <ski> so, a variable is a name that stands for a (fixed) value  (note that functions are also values)
11:22:01 <Darius> ski, likely everyone who has an opinion one way or the other thinks that.
11:22:17 <Darius> (well, I guess that wouldn't have the "other" way)
11:22:23 <ski> Darius : yes, i would guess so ;)
11:23:38 <ski> but, now you perhaps think "how can functions be called with different values (e.g. 3 and 4) as arguments, if variables can't change value"    :)
11:23:58 <ski> NeuNeu : or do you have some other question or comment ?
11:25:40 <ski> or shall i explain the add1 definition instead ?
11:25:44 <ski> :)
11:26:12 <NeuNeu> year.. let's try the add1 def..
11:26:19 <ski> ok
11:26:24 <ski> that's fine
11:26:40 <ski> so, usually in math we would write that as :
11:26:46 <ski> add1(x) = x + 1
11:26:57 <ski> this is also possible to do in haskell
11:27:07 <ski> it means the same
11:27:12 <NeuNeu> ok
11:27:32 <ecraven> Maddas: i got a reply, saying something about a discount on shipment if i order a new one.. i'll keep you informed :)
11:27:50 <ski> do you understand this line, i.e. what it is supposed to mean
11:28:42 <NeuNeu> it' s like fuction in maths... (if i've understand)
11:28:49 <ski> @eval add1(8)
11:28:49 <lambdabot> 9
11:28:53 <ski> yes
11:29:08 <NeuNeu> but...
11:29:12 <ski> yes ?
11:29:38 <NeuNeu> you need to define this "add1" fuction before using it, no?
11:29:46 <ski> yes
11:30:08 <ski> do you mean how i got lambdabot to respond like that ?
11:30:27 <NeuNeu> when have u did it here?
11:30:34 <NeuNeu> yes
11:30:52 <ski> oh, ok. one thing at a time
11:31:19 <ski> lambdabot isn't really @eval:ing haskell but something that looks quite similar
11:31:59 <ski> so perhaps i shouldn't drag how lambdabot works into this
11:32:22 <ski> i just wanted to show how one could call this function (add1)
11:32:45 <NeuNeu> ok..
11:32:51 <ski> perhaps better if i instead paste such things from a real haskell interpreter
11:33:06 <NeuNeu> perhaps...
11:33:17 <ski> (in which one can interactively type a function call and have it evaluate it for you)
11:33:26 <ski> anyway ...          :)
11:34:12 <ski> about the (noncomment-)line above the line we spoke about
11:34:22 <ski> i.e. "add1 :: Int -> Int"
11:34:41 <NeuNeu> yes?
11:35:08 <ski> this says that add1 is a function (thats the arrow '->') that takes an integer (the first Int), and gives/returns an integer (the second one)
11:35:47 <NeuNeu> ok..
11:35:51 <ski> we could imagine adding a line above "somenumber = 1" which would then say "somenumber :: Int"
11:36:25 <NeuNeu> understand
11:36:51 <ski> (actually it (mostly) doesn't matter where you put the line, but it's quite often put above the thing to be defined)
11:37:28 <ski> so, the '::' thing is pronounced 'has type' or 'belongs to' or 'is a(n)'
11:38:15 <ski> this sign separates the name of the thing and the general desciption of it that is called it's type
11:38:27 <ski> ok ?
11:38:31 <NeuNeu> continue
11:38:40 <ski> ok
11:39:05 <NeuNeu> (are u some kind of teacher? becoz u teach very well:)
11:39:07 <ski> for someString the type signature (it's called that) would be "someString :: String"
11:39:21 <ski> NeuNeu : no, i'm just a student :)
11:39:59 <NeuNeu> ok ok continue... student :))
11:40:04 <ski> yes :)
11:40:09 <ski> so ..
11:40:30 <ski> what do "add1 x = x + 1" really say ?
11:40:57 <ski> actually it doesn't (strictly mathematically explicitely) define a function
11:41:23 <ski> it says "For *any* x, add1(x) is defined to be x + 1"
11:41:57 <NeuNeu> yes
11:41:58 <ski> though mathematicians (and others) are mostly so used to this so they usually doesn't notice
11:42:48 <ski> note, that, with this indirect way of defining functions, there is no way of expressing a function without giving it a name
11:43:26 <NeuNeu> heu... minute! just testing if i have correctly understand for now.. :
11:43:38 <NeuNeu> add1 :: Int -> Int
11:43:46 <NeuNeu> add1 x = x + 1
11:44:26 <NeuNeu> whith this i have a working function..
11:44:26 <ski> NeuNeu : sure
11:44:31 <NeuNeu> ?
11:44:37 <ski> yes
11:44:53 <NeuNeu> ok.. continue... :)
11:45:03 <gwschuet> ok
11:45:16 <gwschuet> can haskell make online databases?
11:45:19 <ski> (actually you don't need the type signature, but it can be nice to have)
11:46:00 <NeuNeu> ok so haskell is a really inteligent interpretr :)
11:46:03 <bring> gwschuet: what do you mean by online databases?
11:46:12 <gwschuet> like u know amazon.com
11:46:22 <ski> gwschuet : dunno, perhaps you want to look at HaskellDB, or perhaps some other person can answer better  (i.e what do you mean by online (db) ?)
11:46:35 <gwschuet> doing business over the web man
11:46:38 <gwschuet> the name of the game
11:46:42 <bring> you could write something like that, yes
11:46:49 <gwschuet> cool
11:46:54 <gwschuet> would it be fast
11:47:03 <ski> NeuNeu : yes, that's a good way to think of it. only much generalized ! :-)
11:47:21 <gwschuet> would it be scalable and updatible
11:47:38 <ski> NeuNeu : ok..
11:47:55 <NeuNeu> ski: that's ok..
11:47:59 <ski> NeuNeu : (about naming functions : compare with <1,2> e.g. which is the ordered pair of 1 and 2. see !, i didn't have to name the pair something to use it !)
11:48:22 <bring> it would definitely be updatable, it is very easy to write general, reusable code in haskell
11:48:46 <shapr> lambdabot has had a postgresql interface in the past, and shall have one again in the future.
11:48:52 <ski> NeuNeu : so, can we write/use a function without naming it ?
11:48:53 <shapr> as soon I get around to reinstalling HSQL
11:49:16 <ski> NeuNeu : (that was a rhetorical question :)
11:49:58 <NeuNeu> heu... without naming it? no.... 
11:50:11 <ski> NeuNeu : well, have you heard of function composition ?  (otherwise, don't despair, i'll tell you and it's quite simple ;)
11:50:27 <shapr> yes, both scalable and updatable
11:50:46 <shapr> Haskell has SMP and distributed versions as well, though I haven't tried them myself.
11:50:59 <ski> NeuNeu : consider "f(x) = x * 2" and "g(x) = 5 + x"
11:51:11 <NeuNeu> ski: function composition in maths or in programming languages?
11:51:25 <ski> NeuNeu : it's the same ;)
11:51:42 <shapr> gwschuet: what sort of features are you looking for?
11:51:57 <NeuNeu> ohh... in maths it's seems very more difficult.. hehe... in fact i havnt did it in maths..
11:52:22 <ski> NeuNeu : so we can of course define "h(x) = (5 + x) * 2"
11:52:33 <ski> ok
11:52:37 <NeuNeu> ski: yes..
11:53:21 <ski> if you want, i can skip it for now (i just wanted to give a hopefully perhaps familiar way of using a function without naming it)
11:53:47 <ski> shall i continue with function composition ?
11:54:09 <ski> (it's not essential to grasp the basics)
11:54:23 <NeuNeu> yes continue... if it's really too difficult for me, i will say u
11:54:38 <ski> (e.g. func. comp. is not essential to ...)
11:54:42 <ski> ok
11:54:53 <NeuNeu> but do what u think is better..
11:54:54 <ski> so you saw the new h function above
11:55:01 <NeuNeu> yes
11:55:35 <ski> notice that this first adds five to its input (x), and then multiplies that by 2
11:55:42 <ski> ok ?
11:55:45 <NeuNeu> ok
11:56:18 <ski> also notice that f is the "add 5"-function and g is the "multiply by 2"-function
11:56:56 <ski> so "h(x) = f(g(x))"
11:57:01 <ski> do you follow ?
11:57:23 <ski> (i.e. that last statement quoted is true)
11:57:25 <NeuNeu> yep
11:57:52 <ski> now, there is a notation for this kind of stucking together" functions
11:58:18 <ski> you guessed right ! It is the function composition notation ;)
11:58:51 <ski> but how does it look like ?   (another rhetoric, unless you want to answer)
11:59:23 <NeuNeu> in haskell?
12:00:02 <ski> in math one writes that roughly like "h(x) = (f o g)(x)"  where the "o" is really a small circle at the same height as e.g. +
12:00:36 <ski> in haskell one writes "h(x) = (f . g)(x)"
12:00:41 <cleverdra> aye.  SML copies that notation.
12:00:48 <ski> or just "h x = (f . g) x"   :)
12:00:59 <ski> cleverdra : yes
12:01:35 <ski> ok, so ...  what is "f . g" ?
12:01:48 <ski> is it an integer ?                    ;)
12:02:06 <NeuNeu> maybe...
12:02:09 <ski> (or "(f . g)" if you like)
12:02:24 <ski> well, f is a function, right ?
12:02:38 <NeuNeu> it's the same type as x?
12:02:44 <NeuNeu> yes
12:03:12 <ski> (i.e. something (a machine e.g.) with one IN hole and one OUT hole, that when you put something IN, something comes OUT)
12:03:28 <ski> yes, f is a function ! :)
12:03:48 <ski> and g is too
12:03:58 <ski> so we stick them together
12:04:24 <ski> being careful to align the OUT hole of g to the IN hole of f
12:04:57 <cleverdra> if f(x)=x+1 and g(x)=x+1, (f o g)(x)=f(g(x))=f(x+1)=(x+1)+1=x+2
12:05:11 <NeuNeu> i take some notes :)
12:05:22 <ski> so, we get a new thing, with one IN hole, and one OUT hole.  what could *that* be ? :))
12:07:17 <ski> NeuNeu : shall i continue ?
12:07:46 <NeuNeu> minute... how f(g(x))=f(x+1) ?
12:08:05 <cleverdra> neu - g(x)=x+1
12:08:11 <ski> well, cleverdra defined some other f and g, not the same as mine
12:08:13 <NeuNeu> no no... i havnt say anything :)
12:08:40 <NeuNeu> thats ok..
12:09:05 <Darius> "Axial vector" *sigh*
12:09:39 <ski> well
12:09:41 <NeuNeu> ski: u can continue if u want...
12:09:44 <ski> ok
12:10:18 <ski> so you can picture the functions as boxes with one input and one output
12:10:32 <NeuNeu> yes
12:10:58 <ski>  /----/
12:10:59 <ski> <  f <
12:10:59 <ski>  \----\
12:11:02 <ski> e.g.
12:11:14 <ski> and
12:11:14 <ski>  /----/
12:11:14 <ski> <  g <
12:11:14 <ski>  \----\
12:11:20 * cleverdra tends to dislike such descriptions, since people tend to use them instead of explaining variables and equivalency.
12:11:44 <ski> cleverdra : i'll come to that :)
12:12:12 <cleverdra> OK =)
12:12:12 <ski> so we want to put together these :
12:12:12 <ski>  /----/     /----/
12:12:12 <ski> <  f <    <  g <
12:12:12 <ski>  \----\     \----\
12:12:41 <ski> NeuNeu : you understand my little pictures ?
12:12:53 <NeuNeu> yep:)
12:13:05 <ski> ok, so then we get this :
12:13:06 <ski>  /----/----/
12:13:06 <ski> <  f <  g <
12:13:06 <ski>  \----\----\
12:13:26 <ski> also known as :
12:13:26 <ski>  /---------/
12:13:27 <ski> <  f .  g <
12:13:27 <ski>  \---------\
12:13:53 <NeuNeu> ok!
12:14:00 <ski> do you see how "." (function composition) works now ?
12:14:11 <NeuNeu> yes
12:14:17 <ecraven> are there still authors that put the order of f.g the other way around?
12:14:23 <NeuNeu> (and thank u for that)
12:14:33 <andersca> ski: why aren't you in #haskell.se? :)
12:14:38 <ski> ok, then : must we give this "f . g" thing a name on it's own to use it ?
12:14:58 <NeuNeu> no
12:15:44 <ski> andersca : well, this client is console-based and i could read #haskell properly when there was much talk in #haskell.se earlier this day.  just that
12:15:55 <ski> NeuNeu : and you are right ! :)
12:16:06 <ski> of course we don't
12:17:13 <ski> when we *gave* it a name above (h), we used it (on the right-hand-side of the "=") without giving it a name !  ;) ;)
12:17:25 <ski> i.e. we did "h(x) = (f . g)(x)"
12:17:41 <ski> there we use "f . g" at the right-hand-side
12:17:47 <ski> agree ?
12:18:27 <NeuNeu> yess
12:20:10 <ski> ok, so this thing about func. comp. was perhaps a bit of a side-track, but it (i.e. func. comp.) is still practically useful in haskell, so if you hadn't any problem getting it now, there's no problem
12:20:42 <NeuNeu> hope it's true
12:20:44 <ski> i wanted to show you that not all functions are always named
12:22:51 <ski> (another example is inverse functions. if "g(x) = 5 + x", then the inverse of g is defined as "g^-1 (x) = x - 5". (the ^-1 thing is supposed to mean an -1 in the exponent). note that you can't however defined this is haskell :(  )
12:23:18 <ski> (ignore previous remark if it seems to hard/irrelevant/whatever)
12:23:24 <ski> ok
12:23:45 <NeuNeu> ok
12:24:17 <ski> anyway, this way (e.g. function composition and inverse) of defining a function works "on the outside" of some function(s)
12:25:05 <ski> but when we say "f(x) = x * 2" we really are saying how f works on the inside  (i.e given it's argument, what does it do/compute)
12:25:56 <ski> so
12:27:00 <ski> is there now any way of expression a function, by telling how it "works on the inside", but without (necessarily) naming it ?
12:27:13 <ski> and, of course, there is :)
12:27:45 <ski> it's called a "lambda-expression" or "anonymous function"
12:27:58 <NeuNeu> ...
12:28:23 <ski> in haskell one can define that f above as "f = \x -> x * 2"
12:29:04 <NeuNeu> "\" is the lambda expression?
12:29:14 <ski> in math the commonest notation is "f = \x.x * 2" (where the \ should be the lower case greek letter lambda)
12:29:40 <ski> "\x -> x * 2" is the lambda expression/anonymous function
12:30:33 <NeuNeu> but why using lambda expression when we can name theme?
12:30:33 <ski> do you (more or less) get it ?
12:30:53 <ski> we don't always want to name them :)
12:31:03 <phubuh> NeuNeu: in some situations, it is just annoying to name a function
12:31:42 <NeuNeu> ok...
12:31:46 <phubuh> for example, "map" is a function that applies another function to a list of values, and returns all the results, e.g.:
12:31:49 <phubuh> Prelude> let addOne x = x + 1
12:31:49 <phubuh> Prelude> map addOne [1, 2, 3]
12:31:49 <phubuh> [2,3,4]
12:32:07 <ski> but, you're partly right. "normally" (whatever that means :) you name functions, even in _functional_ programming languages like haskell
12:32:42 <phubuh> but we can also write this as:
12:32:46 <phubuh> Prelude> map (\x -> x + 1) [1, 2, 3]
12:32:46 <phubuh> [2,3,4]
12:34:02 <phubuh> which can be more convenient some times
12:34:17 <ski> NeuNeu : (i.e. in simpler(?) words : map is a function that does *something* with every element of a list, giving you back the new list. you decide what the *something* is gonna be ! (by passing your own do-something function as an argument to map))
12:35:01 <ski> do you see ?
12:35:30 <NeuNeu> "map (\x -> x + 1)" I understand this part... but this"[1, 2, 3]"...
12:35:35 <ski> oh
12:35:44 <ski> that's a list
12:36:00 <ski> (an ordered list, to be precise)
12:36:34 <pnm> guys: v quick question - do you have to escape quotation marks within strings in haskell?
12:36:40 <NeuNeu> yes... but how haskell know that he need to apply x + 1 to the list?
12:36:49 <ski> map is a function that takes two arguments, 1 : a function which does *something*, 2 : a list of some things
12:37:13 <ski> pnm : yes, like  "abc\"quoted\"def"
12:37:27 <pnm> ski: ah, got it. many thanks
12:37:31 <NeuNeu> so "[1, 2, 3]" is just an argument?
12:37:36 <ski> yes
12:37:55 <NeuNeu> ok ok
12:38:13 <ski> in math you would probably be more familiar with a notation like "map((\x . x + 1),[1,2,3])"
12:38:23 <NeuNeu> yes
12:38:34 <ski> *phew*
12:38:58 <ski> now we can explain what the line defining add2 on the HaskellDemo page means, right ?
12:39:32 <ski> (so we can begin to talk more directly useful stuff :)
12:39:51 <NeuNeu> now i understand the add2 line..yes
12:40:11 * ski isn't implying though that map and passing functions as argument is directly useful
12:40:42 <NeuNeu> :)
12:41:01 <ski> so, actually the notation used in the line with add1 is just a short-hand notation for the notation (lambda-expr.) used in the line defining add2
12:41:15 <ski> umm
12:41:17 <ski> soory
12:42:00 <ski> (of course replace "is directly useful" with "isn't directly useful"  :) :)
12:42:17 <ski> map *is* useful !
12:42:53 <ski> ok ?
12:43:04 <NeuNeu> i'd understand...
12:43:15 <NeuNeu> lets go back to our demo
12:43:46 <ski> ok, so add (on that page) is an example of how one usually does multi-argument functions is haskell
12:44:13 <ski> i.e. just put in a space and write the next argument
12:44:21 <NeuNeu> so "add     :: Int -> Int -> Int" meen "add" take 2 arguments and return one...
12:44:22 <andersca> haskell makes me happy
12:45:05 <ski> if the argument is complicated, you might though have to enclose *it* in paranthesis
12:45:09 <ski> like
12:45:30 <ski> f (x + 2) (g (3 * 3))
12:45:44 <ski> do you see how to read that ?
12:46:14 <NeuNeu> i think..
12:46:46 <ski> in ordinary math one would probably write "f(x + 2,g(3 * 3))"
12:47:45 <NeuNeu> thats ok
12:47:53 <ski> fine
12:48:46 <ski> so "add x y = x + y" just says that add is the function that takes two integers and return/give-as-a-result their sum
12:49:16 <ski> the line above that (add's type signature)
12:49:23 <ski> add :: Int -> Int -> Int
12:50:09 <ski> read this as "the function add takes two integers (the first two Int's) and returns an integer (the last Int)"
12:50:35 <NeuNeu> fine
12:50:41 <ski> (this notation might feel a little strange)
12:50:43 <ski> ok
12:51:35 <ski> so, roughly, the last thing (type) in the "->" separated list of words/symbols is the return type, the previous ones are argument types
12:51:55 <ski> the first Int corresponds to the first argument, and so on ...
12:52:21 <NeuNeu> if the function need to return more than 1 argument?
12:52:36 <ski> wait a bit :)
12:52:56 <NeuNeu> ok:)
12:53:08 <ski> first i'll explain why this is (a bit) different from the "f(x,y)" notation in math
12:53:18 <NeuNeu> k
12:53:44 <ski> if we use lambda-expressions/anonymous functions, we can rewrite add as :
12:53:52 <ski> add = \x y -> x + y
12:53:57 <ski> ok ?
12:53:57 <NeuNeu> (i'm burning cigaretts after cigaretts:)
12:54:11 <ski> NeuNeu : hehe :)
12:54:41 <ski> mm ?
12:55:09 <ski> are you with me ?
12:55:10 <NeuNeu> yes but if us lambda expression here how can we use our fuction fater if it hasn't have a name?
12:55:23 <ski> ok
12:55:26 <NeuNeu> we use
12:55:50 <ski> the thing "\x y -> x + y" is a lambda-expression. so it is an expression, ok ?
12:55:58 <NeuNeu> heyes
12:56:17 <ski> (like "1 + 2" is an expression, "3 - f (x * 4)" is an expression")
12:56:46 <ski> NeuNeu : heyes ?
12:57:10 <NeuNeu> yes:) (typping error)
12:57:17 <ski> ok
12:57:50 <ski> so, expressions haven't names, "on their own"
12:58:04 <ski> "1 + 2" haven't a name
12:58:13 <NeuNeu> yes..
12:59:08 <ski> (of course the value of it is 3, but we haven't here given *that* particular expression a name. and even if we had, the expression wouldn't have a nam "on it's own" anyway.    nuderstand any of that ? ;)
12:59:32 <NeuNeu> understand
12:59:36 <ski> fine
12:59:58 <ski> so if we say "three = 1 + 2" then we have named it, right ?
13:00:13 <NeuNeu> right..
13:00:47 <ski> so if we say "add = \x y -> x + y" we have given a name to a function(-expression) that hasn't got a name "on it's own"
13:01:08 <NeuNeu> yes
13:01:25 <ski> ok, now that bit about different from "f(x,y)" things
13:02:10 <ski> the function f in "f(x,y)" takes two arguments, *both* *at* *the* *same* *time*
13:02:19 <NeuNeu> yep
13:02:28 <ski> the function add in "add 2 3" *doesn't* !
13:02:42 <ski> it takes them one at a time, from left to right
13:03:13 <ski> so if we given a first argument to add, e.g. 2   i.e. "add 2"
13:03:43 <ski> then the function *is* *still* *waiting* for it's *second*
13:03:59 <NeuNeu> yes
13:04:02 <ski> argument before it's gonna do anything (i.e return something)
13:04:10 <ski> or
13:05:50 <ski> more properly phrased : the function add takes one argument *and* *returns* a new *function*, which, when it gets *it's* argument (usually called add's first argument), is going to return the sum of those two arguments
13:06:12 <ski> tricky, eh ? :)      (don'
13:06:33 <ski> (don't worry. it's not *so* hard, i hope :)
13:07:14 <ski> do you follow (more or less) ?
13:07:31 <NeuNeu> it's ok (i think)
13:07:55 <ski> (hmm, no sorry, replace "add's first argument" with "add's *second* argument", of course :)
13:08:12 <ski> good
13:08:45 <ski> so, remember the type of add ?  (the type signature is the whole line with the "::", the type is what is on the right of "::")
13:08:53 <ski> add :: Int -> Int -> Int
13:09:25 <ski> this really means :
13:09:34 <ski> add :: Int -> (Int -> Int)
13:10:20 <NeuNeu> wow
13:10:23 <ski> i.e. add "really" takes just one argument (an integer), and then returns a second function, which wants an integer argument, and which returns an integer. finally !
13:10:55 <ski> so strictly speaking : all haskell functions take exactly *one*
13:10:59 <ski> argument
13:11:44 <ski> but, usually one still talks of add's second argument, and add's first argument
13:12:01 <ski> because it is easier to say
13:12:16 <NeuNeu> ok ok.. understand.... but why it's like this?
13:12:33 <ski> but it can sometimes be good to remember this way of thinking
13:12:42 <ski> ok, coming to that :)
13:12:47 <NeuNeu> i meen why haskel's functions take just one arguments?
13:12:52 <ski> ok
13:12:55 <ski> first
13:13:10 <phubuh> it makes the language simpler, is one reason
13:13:20 <phubuh> and it lets you do "partial application"
13:13:34 <ski> it very possible to say that the f in "f(x,y)" *also* takes just one argument !   (confused yet ? ;)
13:13:52 <SyntaxNinja> shapr: what's the low-down on database stuff for haskell? are there multiple implementations to database APIs for free things like mysql?
13:14:02 <ski> we could have written add like this instead :
13:14:09 <ski> add :: (Int,Int) -> Int
13:14:13 <ski> add (x,y) = x + y
13:14:23 <phubuh> for example, if add x y = x + y, then add x = \y -> x + y, and that means we can do:
13:14:24 <phubuh> Prelude> map (add 10) [1, 2, 3]
13:14:25 <phubuh> [11,12,13]
13:14:47 <ski> this other add would accomplish more or less that same thing  (but the type is *not* the same)
13:15:30 <ski> NeuNeu : yes, see what phubuh is doing with add ?
13:15:54 <ski> note especially "add x = \y -> x + y"
13:16:56 <NeuNeu> dont understand the "->" here...
13:17:04 <ski> "add x y = x + y" is the same as "add x = \y -> x + y" is the same as "add = \x -> \y -> x + y" is the same as "add = \x y -> x + y" our old friend
13:17:07 <ski> ok
13:17:39 <ski> first, see that add is a function that takes x as an argument   (in "add x = \y -> x + y", i.e.)
13:18:00 <ski> what does it return/give you back ?
13:18:15 <ski> what kind of thing is "\y -> x + y" ?
13:18:28 <NeuNeu> a function?
13:18:32 <ski> yes ! :)
13:19:16 <shapr> anyone seen an mbox parser written in Haskell?
13:19:16 <ski> so here you see quite clearly that add really is a function that takes one argument (x) and returns another function, do you agree ?
13:20:21 <ski> shall i take it again, more slowly ?
13:20:45 <NeuNeu> ok ok i understand now...(i need to reed the line a bit more than one time)
13:20:55 <NeuNeu> read
13:21:00 <ski> sure, no problem :)
13:21:38 * ski seems to recall that he needed that too, to grasp one-argument-at-a-time
13:21:58 <ski> ok
13:22:15 <ski> so what function is, say, "add 5" ?
13:22:43 <NeuNeu> ok we can continue but "add = \x y -> x + y" seems more natural than "add = \x -> \y -> x + y"
13:22:50 <ski> yes, it is
13:23:01 <ski> the former is shortcut for the latter
13:24:42 <ski> (because instead of pulling all the arguments off the left-hand-side of "=" at one time (putting them in a "\"-expression at the right-hand-side), one can also pull them "across", one at a time, and then (if you do it strictly :) you get the "\x -> \y -> ..." thing)
13:25:28 <ski> ok, anyway "add 5" is the function that adds five ! :)
13:25:57 <NeuNeu> adds 5 to what?
13:25:58 <ski> we called it g, a bit above (defined with "g(x) = 5 + x")
13:26:02 <NeuNeu> :)
13:26:05 <ski> to it's input
13:26:07 <shapr> man, mbox parsing is about as hard as falling off a log.
13:26:13 <heatsink> can I think of an IO datatype as like a delayed evaluation that needs to be explicitly forced?
13:26:14 <ski> it is the adding-five function
13:26:18 <NeuNeu> okok
13:26:47 <shapr> heatsink: yah, you can think of IO actions as first class actions, one step above first class functions.
13:27:26 <NeuNeu> u can continue ski
13:27:56 <ski> heatsink : roughly :)  yes, it's delayed in the sense that the IO action wont e.g. occur yet if you e.g. store the action in a list. you need to *execute* it, using do-notation (or return and (>>=))
13:28:02 <ski> yes, will do :)
13:28:29 <heatsink> ok
13:28:31 <ski> so now we know how the addOne function is defined, right ?
13:29:00 <heatsink> I'm trying to determine whether all filenames in a list exist... so I do:
13:29:03 <ski> addOne :: Int -> Int
13:29:07 <ski> addOne = add 1
13:29:08 <heatsink> filesExist s          = all (\filename -> do b <- doesFileExist filename; return b) s
13:29:09 <NeuNeu> right
13:30:00 <ski> heatsink : hmm, don't think you can do it exactly that way ...
13:30:05 <ski> yes
13:30:08 <heatsink> But this won't compile... it says: Couldn't match `Bool' against `t t1' In the lambda function
13:30:26 <heatsink> I can't figure out what's wrong with it, or what type `t t1' is
13:30:30 <ski> you see why it get's the type it does, NeuNeu ?
13:31:01 <NeuNeu> yes
13:31:36 <ski> heatsink : that seems like a poor error :(  i suspect t is in this case IO and i1 is Bool (only the typechecker stumped on the error before it discovered that)
13:32:32 <ski> yes, because add returns a function of type Int -> Int, and addOne is defined as whatever add returns when given 1, so add must also have type Int -> Int
13:34:02 <NeuNeu> yep
13:36:55 <ski> sorry, wait a few moments
13:37:51 <NeuNeu> no problem... but I think I need some sleep (its 1:40 am here)
13:38:18 <ski> heatsink : can you wait a little ?
13:38:21 <ski> ok
13:38:52 <heatsink> alright
13:39:09 <ski> well, should i just explain Temp and Season  (i think it's going to be faster)
13:39:27 <ski> (faster to explain i.e.)
13:39:34 <NeuNeu> ok let's try
13:39:40 <ski> ok :)
13:39:59 <ski> well, you've probably noticed that Int is a *type*
13:40:05 <ski> then, what is a type
13:40:35 <ski> it is a collection of "things" that "belong together" (in some sense)
13:40:53 <NeuNeu> yes...
13:41:25 <ski> so the integers (0,1,2,3, ... and also -1,-2,-3,...) belong to Int  (well there's one catch, but we can skip that for now)
13:41:37 <ski> "Int -> Int" is a type
13:41:55 <ski> it is the type of functions taking an integer and giving an integer
13:41:56 <NeuNeu> yes
13:42:14 <ski> now, these types are all predefined in haskell
13:42:44 <NeuNeu> but u can make your own type...
13:42:44 <ski> but we can make new types (in certain ways), for our own purposes
13:42:46 <ski> yes
13:43:09 <ski> and these types are going to have completely user-defined values, in them
13:43:25 <ski> (i.e. we define what their value will be)
13:43:53 <ski> we do this with a (so-called) "data(type) declaration"
13:44:00 <ski> e.g.
13:44:08 <ski> data Temperature = Cold | Hot
13:44:27 <NeuNeu> "data Temp = Cold | Hot" : "temp" is a type, but what are "Cold" or "Hot"?
13:44:42 <ski> this defines a new type Temperature, and it has two values, written Cold and Hot, respectively
13:45:08 <ski> so "Cold :: Temperature" is true
13:46:23 <ski> the Season type definition is similar  (the "deriving Show" means that we want haskell to automatically define a way to print the values of the types)
13:46:48 <ski> do you understand ?
13:47:18 <NeuNeu> " print the values of the types" what do u meen by that?
13:47:41 <ski> we can just list names of values we want our new type to have, at the right-hand-side of the "=", separated by "|"
13:47:48 <ski> well
13:48:23 <ski> the words Summer and so on in the source code file stands for internal names of the value
13:49:47 <ski> if we want (in the program) to print these (internal) values, the program must convert them to a string (which is just a list of characters, like 'a', 'Z', '7', '(', '+', ' ', and so on
13:50:18 <NeuNeu> ok..
13:50:46 <ski> so, we could, if we wanted, make the program to print the value Summer as the string "Sure this is the Hottest season here 000!!!"
13:51:23 <NeuNeu> :)
13:51:35 <ski> but with "deriving Show", it automatically defines a way to Show the values of this type just like the characters the words are built up from
13:51:52 <NeuNeu> understand
13:51:59 * phubuh thinks Haskell should be able to derive the "... Hottest season ..." definition automatically
13:52:08 <ski> :)
13:52:20 <ski> ok
13:52:41 <ski> now we can of course use these new values in our program
13:52:49 <ski> e.g. look at mySeason
13:52:54 <ski> mySeason :: Season
13:52:54 <ski> mySeason = Summer
13:53:03 <ski> very simple
13:53:20 <ski> i hope you understand it ?
13:53:22 <NeuNeu> yes
13:53:26 <phubuh> you can think of Int as "data Int = ... -2 | -1 | 0 | 1 | 2 | ..."
13:53:26 <ski> good :)
13:53:31 <ski> yes
13:54:06 <ski> we can also write functions that use this new type
13:54:11 <NeuNeu> k
13:54:16 <ski> example comes here :
13:54:27 <ski> nextSeason :: Season -> Season
13:54:35 <ski> nextSeason Winter = Spring
13:54:42 <ski> nextSeason Spring = Summer
13:54:50 <ski> nextSeason Summer = Autumn
13:54:59 <ski> nextSeason Autumn = Winter
13:55:07 <ski> *phew*
13:55:19 <ski> this is a new thing !
13:55:35 <ski> this is a function that is defined by several different cases
13:55:53 <ski> do you understand what it is supposed to do ?
13:56:17 <NeuNeu> yep
13:56:20 <NeuNeu> but who haskell know if we can (or cant) do operation between these new type?
13:56:21 <ski> good
13:56:29 <ski> easy to read, eh ?
13:56:49 <NeuNeu> yep
13:57:18 <ski> (you can note, if you like, that this function is defined for every kind of season)
13:57:56 <ski> we can of course also make this kind of function definition for integers
13:58:07 <ski> isZero :: Int -> Bool
13:58:11 <ski> isZero 0 = True
13:58:18 <ski> isZero x = False
13:58:35 <NeuNeu> wait..
13:58:44 <NeuNeu> add1 :: Season -> sSeason
13:58:52 <ski> (we would have trouble writing down a case for all integers, right ? :)
13:58:54 <ski> yes
13:59:08 <NeuNeu> add1 x = x + Winter
13:59:29 <NeuNeu> what haskell will return here?
13:59:32 <phubuh> that's a type error, because Winter is not a number
13:59:34 <ski> that is not (at least directly) possible
13:59:44 <ski> yes
13:59:45 <phubuh> it will say something like "No instance of Num found for Winter"
14:00:02 <ski> (Num stands for number, roughly)
14:00:18 <NeuNeu> ok...
14:00:23 <ski> ok
14:00:26 <phubuh> it doesn't speak directly of Int, because there are lots of other numbers, like rationals
14:01:22 <ski> note that i used a variable (x) in the above def. at the same time as using 0 as the argument in another definition line
14:01:54 <NeuNeu> i noticed
14:02:06 <ski> in math, the order of presenting these two definition lines usually don't matter
14:02:11 <ski> in haskell, they do !
14:02:32 <NeuNeu> oh
14:03:54 <ski> (you can think of it like) haskell reads from top-to-bottom, trying each line, seeing if it fits with the arguments, and starts computing the right-hand-side of the first line that matches (if any indeed do)
14:04:23 <ski> so, first we check, is the input equal to 0, then return True
14:04:32 <ski> otherwise we go on downwards
14:05:01 <NeuNeu> ok
14:05:04 <ski> so if the input wasn't 0, we say that it matches x, and the second line is selected
14:05:18 <ski> (because all values match a variable)
14:05:32 <ski> (just the value 0 match 0 ! :)
14:06:22 <ski> so, isZero would be a different function if we changed the order of the lines  (it would actually *always* return False !)
14:07:03 <NeuNeu> true..
14:07:05 <ski> NeuNeu : (please tell when you think it is enough for this time :)
14:07:08 <ski> yes
14:07:35 <ski> you perhaps noted that i sneaked in the type Bool above ? :)
14:07:59 <NeuNeu> yes
14:08:29 <NeuNeu> 0 or 1... true or false
14:08:34 <ski> it is the type of boolean values
14:08:35 <ski> yes
14:08:45 --- mode: truong.freenode.net set +b *!*@206.169.168.190
14:08:56 <ski> (though in haskell False and True isn't numbers like 0 and 1)
14:09:06 <ski> Bool is defined as :
14:09:14 <ski> data Bool = False
14:09:18 <ski>           | True
14:09:37 <ski> (You don't have to write it all on one line)
14:09:48 <ski> ok ?
14:10:03 <NeuNeu> with "deriving show"...
14:10:11 <ski> yes ;)
14:10:20 <NeuNeu> ok!
14:10:21 <ski> (and some other deriving also :)
14:10:34 <NeuNeu> arg!
14:10:50 <ski> you don't have to worry about those yet :)
14:11:28 <ski> so, this type has a special expression connected to it
14:11:47 <ski> it looks like this "if ... then ... else ..."
14:11:59 <ski> (where the ...'s are some expressions)
14:12:26 <NeuNeu> i understand this.. :)
14:12:35 <ski> e.g. "if 5 < 8 then Summer else Winter" gives you the value Summer
14:13:48 <ski> so, either, the value of the "then-branch" is (evaluated and) returned or the value of the "else-branch" is (evaluated and) returned
14:13:49 <shapr> hi apmuf, looking for answers?
14:14:10 <NeuNeu> heu... so in haskell we dont have if..then or loop?
14:14:47 <ski> right, no if-then, just if-then-else. and no (explicit) loop :)
14:15:15 <ski> we still have no problems writing usable programs ! :)
14:15:41 <phubuh> hey Marvin-- 
14:15:46 <Marvin--> evening
14:15:53 <NeuNeu> with  a LOT of practice and big brain... that may be possible :))
14:16:19 <gwschuet> whats bette rhaskell or java?
14:16:19 <ski> NeuNeu : well, shall we talk about lists or tuples now. tuples are a bit simpler ?
14:16:33 <apmuf> :P
14:17:00 <ski> NeuNeu : no ! you just need some practice and no prejudies (about this :)
14:17:04 <NeuNeu> heu.. iwould really like... but it's bit late here... can we continue another time?
14:17:12 <ski> yes
14:17:13 <Marvin--> gwschuet: what's better, apples or oranges?
14:17:19 <gwschuet> ok
14:17:19 <ski> no problem
14:17:22 <phubuh> gwschuet: I don't think you'll get an objective answer to that here.  but the answer is, of course, Haskell
14:17:23 <gwschuet> oranges btw
14:17:26 <gwschuet> :)
14:17:34 <gwschuet> hey can haskell be used for websites?
14:17:51 <gwschuet> like amazon.com?
14:17:51 <Marvin--> of course it can
14:17:51 <gwschuet> how
16:41:12 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/", "ghc 6.2 is out", "ghc rpms: http://haskell.org/~petersen/rpms/ghc/","cryptolib 1.1.2 - http://www.haskell.org/crypto/ReadMe.html"]'
16:41:12 --- topic: set by shapr on [Sat Jan 24 08:38:50 2004]
16:41:19 <ski> they do the same thing (but more generally, for any Monad, respectively Functor)
16:41:36 <ski> clog : hi, so you were gone ?
16:41:39 <Riastradh> What monads don't have equivalent functors?
16:41:48 <heatsink> Okay, it generates a monad that evaluates a = (force io_a), then evaluates (f a)
16:41:57 <ski> Riastradh : none, i think
16:42:24 <ski> heatsink : roughly, yes
16:42:39 <heatsink> or delay(a = (force io_a); (f a))
16:42:52 <ski> yes
16:43:16 <ski> if you did this in an ML, it would look something like that
16:43:24 <heatsink> what is ML?
16:43:34 <ski> a programming language
16:43:42 <heatsink> Man, haskell is hard, I don't know why anyone programs in it ;p
16:43:53 <ski> the one that started using type inference (IIRC)
16:44:20 <ski> nowadays, it's split it at least SML and Caml and O'Caml
16:45:03 <ski> heatsink : you don't know anyone on this channel ?
16:45:24 <heatsink> Well I kinda know riastradh, he's in sisc
16:46:49 <heatsink> liftIO f io_a = do a <= io_a; return (f a)
16:47:01 <heatsink> filesExist s = liftIO and (mapM doesFileExist s)
16:47:04 <ski> change <= to <-
16:47:14 <heatsink> oh, right
16:47:43 <Marvin--> oh dear god, they're making a Swedish version of Fab5
16:47:56 <ski> (heatsink : i hope you know you can use indenting of do, instead of ";")
16:48:08 <ski> Marvin-- : what's that ?
16:48:10 <heatsink> but the compiler says expected [Bool] -> [Bool], inferred [Bool] -> Bool in the first argument of liftIO, namely 'and'
16:48:37 <heatsink> ski: yes, but I use ; to reduce the number of lines typed in irc
16:48:48 <ski> what type signature have you got for filesExist ?  none ?
16:48:56 <ski> heatsink : sure
16:48:59 <heatsink> oh... d'oh
16:49:01 <Marvin--> ski: you don't want to know
16:49:17 <heatsink> okay, now it's [String] -> IO Bool
16:49:25 <ski> filesExist :: [String] -> IO [Bool]  ?     ;)
16:50:01 <ski> does it compile ?
16:50:02 <heatsink> ski: filesExist returns an IO Bool, right?
16:50:08 <heatsink> no
16:50:10 <ski> yes
16:50:16 <ski> it should
16:50:27 <ski> type error ?
16:50:48 <heatsink> Expected IO Bool, inferred IO [b], in mapM doesFileExist s
16:50:55 <heatsink> oh wait
16:51:02 <heatsink> That was a junk line, I forgot to comment it out
16:51:09 <ski> ok
16:51:13 <heatsink> yes, it compiles :)
16:51:32 <heatsink> Thank you for all your help
16:51:41 <ski> praise be to the functional gods !
16:51:58 <heatsink> Yes, I'm feeling quite prostrate right about now
16:51:59 <ski> heatsink : just fun
16:52:44 <heatsink> bye, dinner time
16:52:44 <ski> don't let the false god of efficiency decieve you into an all-consuming-worship
16:52:53 <ski> ko
16:52:55 <ski> ok
16:58:21 <ski> hmm, anyone knows if "Sacrificing the calf of flexibility on the alter of reliability", Peter J. Denning, is online ?
17:00:46 * ski wonders what the god of safe highways are like ...
17:02:07 <Marvin--> I'm off for a date with the goddess of sleep
17:02:47 <ski> well, i'll guess i'll be obliged to do the same ...
18:31:48 <heatsink> How do I make an IO monad that does nothing?
18:35:21 <Riastradh> (return () :: IO ())
18:35:36 <heatsink> ok
19:34:07 * phubuh giggles at the previous conversation with joey
19:34:18 <phubuh> school has a special way of making student hate nice things
19:34:27 <phubuh> students, even
19:35:21 <phubuh> by now, I hate about three foreign languages, most of the sciences, mostly all mainstream aesthetical subjects, and my own native language
19:35:54 <stratocaster> heh
19:36:47 <phubuh> and psychology.  I hate that with a passion.
19:44:44 <cleverdra> phubuh - do you hate Chinese?
19:45:09 <phubuh> I haven't taken that yet, so nope!
19:45:16 <cleverdra> ah, good.
19:54:47 <Riastradh> phubuh, um, perhaps that's an indication that you're at the wrong school.
20:14:17 <phubuh> Riastradh: yeah, possibly.  I don't have much of a choice, though.
20:14:54 <phubuh> sam-: hi B)
20:15:52 <sam-> hi phubuh :)
23:12:00 --- mode: tenn.freenode.net set +b *!*@206.169.168.190
