01:32:05 <ham[kell]> hiho
01:38:58 <ham[marubi]> bk
01:39:11 <ham[marubi]> where can i get a network lib for hugs and or ghc?
01:41:47 <ham[marubi]> and how can i build a type like that ? data foo = Int | NA
02:07:29 <earthy> ham[marubi]: type foo = Maybe Int
02:09:53 <earthy> ham[marubi]: and the networking stuff is in  import Network  and import Network.Socket  and stuff
02:10:02 <earthy> (see the GHC docs for more info on that)
03:53:12 <Heffalump> morning all
05:06:23 <mattam> @help
05:06:24 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
05:07:22 <mattam> hmmm, isn't /msg lambdabot supposed to work ?
05:07:56 <mattam> nm, it does
05:40:16 <ham[marubi]> thank you
07:05:37 <shapr> good morning #Haskell!
07:06:49 <shapr> did I miss anything?
07:12:52 <steveh> me trying to pick up haskell again ;)
07:12:55 <steveh> working on IO now
07:13:13 <steveh> what's a hugs error "PreludeIO.readIO: no parse" mean in general?
07:13:48 <shapr> what code caused that error?
07:14:09 <shapr> I'd guess it was something like 'read "5" :: IO Int'
07:14:35 <steveh> main :: IO ()
07:14:35 <steveh> main = do
07:14:35 <steveh>        phrase <- readLn
07:14:35 <steveh>        putStrLn phrase
07:14:35 <steveh>        main
07:14:39 <steveh> which I am sure is wrong
07:14:40 <shapr> but instead it got something other than the type it was expecting, such as 'read "a" :: IO Int'
07:14:49 <steveh> but I never did learn IO correctly ;)
07:15:47 <steveh> it's weird because I got a more complicated program doing simple IO working fine
07:16:02 <shapr> @type readLn
07:16:03 <lambdabot> readLn :: Read a => IO a
07:16:53 <shapr> that has something to do with calling read
07:17:15 <shapr> try using getLine instead of readLn
07:17:22 <shapr> @type getLine
07:17:23 <lambdabot> getLine :: IO String
07:17:32 <steveh> ah
07:17:33 <steveh> ok]
07:17:43 <steveh> the other code needed readLn because it was expecting IO Int
07:18:06 <steveh> thanks!
07:18:13 <shapr> seems to fix it when I try
07:18:17 <steveh> hmm
07:18:31 <steveh> now to puzzle out why the other code worked with readLn
07:19:16 <shapr>        phrase <- (readLn :: IO Int) ; putStrLn $ show phrase
07:19:22 <steveh> getGuess :: IO Int
07:19:22 <steveh> getGuess = putStr "? " >> hFlush stdout >> readLn
07:19:25 <shapr> *Main> main
07:19:25 <shapr> 5
07:19:25 <shapr> 5
07:19:25 <shapr> 79
07:19:25 <shapr> 79
07:19:26 <steveh> is what I had that worked
07:19:26 <shapr> foo
07:19:28 <shapr> *** Exception: user error (Prelude.readIO: no parse)
07:19:43 <shapr> you can tell read which type you expect to get back
07:20:08 <steveh> I think I tried that first ... let me see why I didn't go with it
07:20:09 <shapr> readLn combines getLine and readIO
07:20:58 <steveh> arg
07:21:04 <shapr> steveh: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AreadLn
07:21:10 <steveh> upgrading software is hogging IO
07:21:53 <steveh> stupid gcc build
07:22:06 <shapr> I'll stick with binary distros
07:22:28 <steveh> it was fine until it install-sh 's everything
07:22:40 <steveh> emacs is entirely flustered
07:24:24 <Darius> @type putStrLn
07:24:24 <lambdabot> putStrLn :: String -> IO ()
07:24:47 <Darius> When you write do phrase <- readLn;putStrLn phrase, phrase has to be a string so read -parses- a string from the input
07:25:03 <Darius> I.e. it expects the user to type in something like, "foo\nbar"
07:25:20 <steveh> hold on, emacs still not recovered, even though install is done
07:25:23 <steveh> gotta kill it
07:25:24 <steveh> :)
07:26:25 <steveh> ok
07:26:30 <steveh> I had this first
07:26:35 <steveh> since I forgot about getLine
07:26:38 <steveh> import IO
07:26:38 <steveh> main :: IO ()
07:26:38 <steveh> main = do
07:26:38 <steveh>        phrase <- readLn :: IO String
07:26:39 <steveh>        putStrLn phrase
07:26:41 <steveh>        main
07:26:50 <steveh> gave me the user error, parse error error
07:26:57 <steveh> so I have a confusion about something somewhere
07:30:04 <steveh> hoping someone can set me straight on it :)
07:30:07 <steveh> oddly enough
07:30:09 <steveh> main = do
07:30:09 <steveh>        phrase <- readLn :: IO Int
07:30:09 <steveh>        putStrLn (show phrase)
07:30:09 <steveh>        main
07:30:12 <steveh> does what you expect
07:32:04 <Darius> readLn reads in a String then parses that String into a value of whatever it returns.  If the return type is String it's external representation will have quotes around it etc.
07:32:40 * shapr installs DOS
07:32:57 <steveh> Darius: Thanks!
07:33:32 <steveh> Darius: That explains it ... readLn was expecting something that would parse as a String in a haskell program, i.e. something with " " around it?
07:34:37 <steveh> experimentally that seems to be the case anyway
07:34:58 <steveh> not sure what is actually going on behind the scenes of the reading and returning of typed values
07:36:05 <door> has anyone of you guys a haskell enabled emacs-config? i just started using emacs and need an example config to look at (not only the haskell part)
07:36:45 <steveh> my emacs is doing haskell, but I don't really know what you are looking for outside of the haskell part
07:37:22 <door> anything that one would like to put in one's config to make life easier :)
07:37:37 <steveh> ha
07:37:46 <steveh> my .emacs is pretty disgusting that way
07:38:02 <steveh> do you have syntax coloration turned on?
07:38:14 <steveh> that is pretty key and gnu emacs has it off by default IIRC
07:38:35 <door> it's bound to be better than mine since mine is non-existant :$
07:39:04 <door> hm, btw. do you know whether there is some kind of dvorak mode for emacs?
07:39:15 <steveh> (setq transient-mark-mode 1) ; highlight selected regions
07:39:32 <steveh> ; Enable syntax coloration
07:39:32 <steveh> (setq font-lock-maximum-decoration t)
07:39:32 <steveh> (if (fboundp 'global-font-lock-mode)
07:39:32 <steveh>     (global-font-lock-mode 1))
07:39:34 <steveh> etc
07:39:40 <steveh> look at http://www.emacswiki.org
07:39:46 <steveh> it will answer all questions for you]
07:39:52 <steveh> including the Dvorak one which I do not know
07:40:40 <door> aok, thanks :)
07:41:20 <Darius> door:  Well if you can get shapr's attention he should be able to comprehensively answer your questions.
07:41:44 <door> ok.. shapr! :)
07:42:37 <Darius> steveh: The general rule for Read and Show is that they should be inverses.  So things that use 'read' expect what they read to be in the same format as 'show' produces.
07:43:29 <Darius> So if you write 'putStrLn (show "hello world")' at the GHCi prompt (assuming you're using GHCi) the format that is output is the format read expects.
07:43:58 <steveh> well, this is hugs but I think I am following you
07:44:44 <steveh> getLine pretty much accepts any possible user input, because it comes without a "read" attached ?
07:45:17 <steveh> and I am hard pressed to think of some user input that isn't a String
07:45:38 <steveh> as far as command-line input goes
07:48:37 <Darius> getLine reads in a list of characters.  It doesn't try to interpret what they mean.  readLn reads in a list of characters and then tries to interpret them. (not interpret in an eval way, but in the general meaning of the word)
07:49:12 <Darius> For example, how do you propose to input at say a keyboard the String containing a NUL character or a '\n'?
07:49:55 <steveh> good question
07:49:59 <shapr> door: y0
07:50:10 <steveh> I think I've got the hang of getLine vs. readLine now
07:50:18 <steveh> scuse me, readLn
07:50:39 <steveh> I was just confused at how readLn :: IO Int worked the way I wanted it but readLn :: IO String did not
07:50:41 <door> yo :) i would like to see your emacs config, if that's ok
07:50:41 <shapr> door: there is in fact a dvorak mode for emacs, though I'm not quite sure what it does. I think it remaps a qwerty keyboard to dvorak, or maybe it lets you use qwerty keycombos on a dvorak keyboard
07:50:54 <steveh> but now I see how read vs show is working
07:50:55 <steveh> thanks
07:51:06 <shapr> door: sure, it's online here:http://kungens.kemi.fi/~shae/src/elisp/
07:51:23 <door> oh, ok. google did find me something like that, im going to look at it
07:51:25 <shapr> 1400 lines last I checked.
07:51:29 <door> ah, thanks shapr 
07:51:50 <shapr> do you have any specific questions? it might be shorter to ask rather than traipse through my config files.
07:52:15 <steveh> wow
07:52:16 <shapr> hej hampus
07:52:16 <steveh> 1400 lines
07:52:20 <steveh> how much is comment?
07:52:34 <shapr> steveh: dunno, not too much
07:52:38 <steveh> more importantly, how long does emacs startup take
07:52:38 <steveh> ;)
07:52:42 <door> shapr: nah, just needen something to base my own config upon :)
07:52:48 <hram> shapr: hejsan
07:53:00 <shapr> steveh: quite some time, since I'm using desktop
07:53:13 <shapr> gotta go be social, bbl
07:53:24 <steveh> bye
07:58:42 <phubuh> $ wc -l /home/phubuh/.emacs
07:58:43 <phubuh> 944 /home/phubuh/.emacs
07:58:45 * phubuh feels inferior
08:00:39 <hram> what kind of twisted minds have more than ~200 lines of .emacs!?
08:04:07 <Darius> There's a page on Ward's wiki about people who have -less- productivity using emacs because they spend all their time configuring it.
08:04:19 <phubuh> I used to be like that
08:04:25 <steveh> there's a page on Ward's wiki about a lot of things
08:04:31 <phubuh> I've spent countless hours configuring Emacs
08:04:31 <steveh> ;)
08:04:39 <phubuh> it paid off though :-)
08:04:58 <steveh> my config file is nearly all just setting up things
08:05:06 <steveh> no remapping of keys or defining macros or anything
08:05:29 <steveh> ; Put the scrollbar on the normal side
08:05:29 <steveh> (if (fboundp 'set-scroll-bar-mode)
08:05:29 <steveh>     (set-scroll-bar-mode 'right))
08:05:30 <steveh> ;)
08:05:51 <steveh> ; NO BLINKING CURSOR FOR CHRISSAKES!
08:05:52 <steveh> (if (fboundp 'blink-cursor-mode)
08:05:52 <steveh>     (blink-cursor-mode -1))
08:05:54 <steveh> stuff like that
08:06:22 <phubuh> is there a nifty unix command to read a bunch of lines of numbers, and sum them?
08:07:42 <steveh> sounds like awk
08:08:14 <phubuh> hacked it up with perl :P
08:08:22 <phubuh> 166300 total lines of emacs lisp
08:08:23 <steveh> that's what people do nowadays
08:08:25 <steveh> awk
08:08:32 <steveh> is what used to do that, far less expensively
08:08:33 <steveh> ;)
08:08:58 <phubuh> I heard awk was remotely similar to Perl, and I don't want to go through learning that again ;)
08:11:17 <steveh> awk '{sum = sum + $1} END {print sum}'
08:11:32 <phubuh> oh, nifty
08:11:36 <steveh> will sum all numbers in the first column of a file
08:11:42 <steveh> and print the resul
08:11:43 <steveh> t
08:12:56 <steveh> is that stat about your own code, or everything that gets loaded above and beyond vanilla emacs?
08:13:20 <phubuh> the latter
08:13:26 <steveh> whew
08:13:53 <steveh> at work they use Eclipse, so I can't really hack emacs like I would like
08:16:59 <ham[kell]> does anyone in here know of a geometric algebra system written in haskell?
08:17:08 <ham[kell]> does anyone in here know of a geometric algebra system written in haskell?
09:06:19 <ham[kell]> i want to write a function ifthenelse that does soemthing like
09:06:52 <ham[kell]> ifthenelse :: Bool -> a -> (a -> b) -> (a -> c) -> ?
09:07:11 <ham[kell]> where x is either the first or second function
09:07:32 <Heffalump> b and c would have to be the same type
09:07:40 <ibid> x?
09:07:46 <ham[kell]> hm
09:07:56 <ham[kell]> i want something like that formaly
09:07:59 <Heffalump> ifthenelse :: Bool -> a -> (a -> b) -> (a -> b) -> b
09:08:31 <ham[kell]> T = lambda x y. x
09:08:35 <ham[kell]> F = lambda x y. y
09:08:46 <ham[kell]> and then you have an expression like that
09:09:06 <ham[kell]> if something fn1 fn2
09:09:29 <ham[kell]> such that something selects the function
09:10:19 <ham[kell]> so that b should be a new type like     type foo = b | c
09:10:29 <ham[kell]> ifthenelse :: Bool -> a -> (a -> foo) -> (a -> foo) -> foo
09:11:26 <ham[kell]> such that this foo is somthing like a disjoint sum right?
09:12:15 <Heffalump> yeah, that'd work
09:12:31 <ham[kell]> fine that fits just fine :)
09:13:20 <ham[kell]> oh but
09:13:30 <ham[kell]> ifthenelse :: Bool -> a -> (a -> b) -> (a -> c) -> foo
09:13:34 <ham[kell]> that wont work right?
09:14:31 <earthy> yes it will
09:15:04 <earthy> as long as you package stuff into the disjoint sum correctly
09:15:18 <ham[kell]> super cool i just love haksell
09:16:55 <Darius> Churchify Either = forall r.(a -> r) -> (b -> r) -> r
09:17:34 <ham[kell]> ?
09:19:20 <kosmikus> since when do we have operators on #haskell?
09:20:12 <Heffalump> oh, someone was trolling and I thought might need kicking
09:20:33 <Heffalump> I think many of the regulars are registered with channel services so they can get ops if needed
09:21:54 <Darius> The Church encoding of the type Either (data Either a b = Left a | Right b) has type 'type CEither a b = forall r.(a -> r) -> (b -> r) -> r'
09:22:21 <Darius> For the most general use of CEither it needs rank-2 types.
09:22:59 <ham[kell]> but doesnt this make a difference in the domain?
09:24:31 <Darius> "In the domain"?
09:24:50 <ham[kell]> f: A -> B
09:24:58 <ham[kell]> g: C -> B
09:25:14 <ham[kell]> A and B the domains and B the codomains
09:25:44 <Smerdyakov> s/A and B/A and C/ ?
09:26:47 <ham[kell]> ? hm
09:28:20 <Darius> The type is the type of the a value of type CEither which is isomorphic to Either.
09:29:21 <ham[kell]> but that 
09:29:35 <ham[kell]> CEither make a difference in what gets into the function
09:29:41 <Darius> It is represented similarly to an applied use of 'either'
09:29:56 <ham[kell]> and what does that forall r do?
09:30:07 <Darius> @type either
09:30:08 <lambdabot> either :: (a -> b) -> (c -> b) -> Either a c -> b
09:30:37 <Darius> @type \e f g -> either f g e
09:30:37 <lambdabot> \\e f g -> either f g e :: Either a b -> (a -> c) -> (b -> c) -> c
09:31:35 <ham[kell]> so Either a c -> b      is like either f or g in what i have written right?
09:31:47 <ham[kell]> cant i write something like 
09:31:58 <ham[kell]> Either a c -> Either b d ?
09:32:14 <ham[kell]> or something like
09:32:17 <Darius> Sure
09:32:31 <ham[kell]> a -> Either b c that would be what i wanted above right?
09:32:37 <Darius> @type \e f g -> either (Left . f) (Right . g) e
09:32:37 <lambdabot> \\e f g -> either (Left . f) (Right . g) e :: Either a b -> (a -> c) -> (b -> d) -> Either c d
09:32:51 <Darius> @type \f g -> either (Left . f) (Right . g)
09:32:51 <lambdabot> \\f g -> either (Left . f) (Right . g) :: (a -> b) -> (c -> d) -> Either a c -> Either b d
09:33:35 <ham[kell]> :) thats really cool
09:33:48 <ham[kell]> either is a build in type?
09:34:13 <Heffalump> yes
09:35:10 <Darius> Not really "built-in", more "standard".
09:36:19 <ham[kell]> ah ok
09:36:32 <Darius> If it wasn't predefined it would be straightforward to define it.
09:36:43 <ham[kell]> i cant understand that haskell is not more commonly used
09:36:48 <ham[kell]> yep
09:42:03 <Heffalump> it's not easy enough to learn
09:42:17 <Heffalump> and the majority of programmers aren't really that smart
09:42:24 <Heffalump> (to be elitist about it :-)
09:43:43 <ham[kell]> ;)
09:43:58 <ham[kell]> i think fn programming is a lot easier then c++
09:44:09 <ham[kell]> and it has a propper foundation in math
09:44:17 <Igloo> You can't write things that happen to pretty much work in Haskell
09:45:02 <Smerdyakov> I think there's good evidence that people with no prior programming experience learn Haskell quite readily.
09:47:04 <Heffalump> the proper foundation in Maths is as irrelevant to most people as it is in other walks of life
09:47:12 <Heffalump> people who understand Maths see why it matters, but they're in a minority
09:48:18 <ham[kell]> :)
09:48:30 <ham[kell]> especially in CS i think
09:51:10 <Heffalump> I think most people just don't think in a mathematical way.
09:51:21 <Heffalump> and that's not something we can change in a hurry
09:51:24 <Heffalump> if ever
09:52:17 <phubuh> I certainly don't
09:53:43 <Heffalump> think mathematically?
09:54:38 <phubuh> yup
09:54:57 <Heffalump> but you still like Haskell?
09:55:32 <phubuh> sure, but I find it a little tedious sometimes
09:56:05 <phubuh> but that's a general artifact of computer programming :-)
10:00:05 * esap likes artifacts of programming :-)
11:29:48 <TripleDES> hiya
12:11:25 --- topic: '["We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","Learning Haskell - http://www.haskell.org/learning.html","http://www.syntaxpolice.org/haskell-experimental/haskell-experimental.html","new HC&A Report - http://www.haskell.org/communities/", "ghc 6.2 is out", "ghc rpms: http://haskell.org/~petersen/rpms/ghc/","cryptolib 1.0.1 - http://www.haskell.org/crypto/ReadMe.html"]'
12:11:25 --- topic: set by shapr on [Sat Jan 10 03:53:16 2004]
12:11:25 --- names: list (clog GreyLensman opet TripleDES Matt-W Arnia isomer keverets esap tez CrewdenX gim ham[kell] det Darius troon mattam el_diego_ dnm ksandstr ecraven seafood stepcut lambdabot shapr phubuh Smerdyakov jasonw Cale dennisb door smkl galority @Heffalump @Riastradh tic shawn Segora ned malik cmeme wuuru kosmikus xkb Lunar^ asmodai earthy skylan gdsx Igloo wax ibid shrimpx norpan)
12:22:42 <Igloo> Is there a nice way of writing something like and of type [IO Bool] -> IO Bool without explicitly coding the shor circuiting?
12:27:53 <Riastradh> What do you mean 'without explicitly coding the shor [sic] circuiting?'
12:29:23 <Igloo> Well,    do x <- sequence [return True, do putStrLn "Foo"; return True]; print $ and x    prints Foo whereas I don't want it to
12:29:56 <Riastradh> ...what do you want it to do?
12:30:30 <Igloo> I want it to look at the first one, see it's True and ignore the rest of the list
12:30:42 <Riastradh> Did you mean 'or,' then?
12:30:55 <Igloo> Oh, yes, sorry
12:31:50 <Riastradh> foldr (\x y -> x >>= (|| y)) False
12:32:07 <Riastradh> Er, no.
12:32:31 <Riastradh> x >>= (return . (||y))
12:32:47 <Riastradh> Something like that.
12:37:48 <Igloo> Maybe I'm being slow, but I can't see how something like that isn't going to end up running all the IO computations
12:39:50 <Riastradh> foldr is lazy, remember?
12:40:15 <Riastradh> y doesn't get evaluated unless (||) decides to evaluate it.
12:40:34 <Igloo> Yes, but where you have False it's really (return False), right? The whole thing is in the strict IO monad
12:40:34 <Riastradh> Or I'm hallucinating.  But you should at least try it.
12:40:56 <Riastradh> Oh.  Right.
12:41:24 <Riastradh> Well, you could do something like:
12:41:57 <Riastradh> foldr (\x y -> x >>= \z -> if z then return True else y) (return False)
12:44:06 <Igloo> Right, I was just hoping there was a more compact solution without explicitly coding the short circuiting I was missing
12:45:12 <Riastradh> You could misuse another Greek letter to define another monad combinator to do this for you.
12:45:17 <shapr> Igloo: liftM takeWhile ?
12:45:19 <Darius> Isn't there an untilM or somesuch
12:45:47 <shapr> er, takeUntil
12:46:09 <shapr> @type takeUntil
12:46:19 <Riastradh> @type dropWhile
12:46:19 <lambdabot> dropWhile :: (a -> Bool) -> [a] -> [a]
12:46:40 <Riastradh> takeUntil = dropWhile . (not .)
12:46:46 <Riastradh> ...or something like that.
12:47:02 <Riastradh> Er.
12:47:07 <Riastradh> Ignore my ramblings.
12:47:24 * Igloo can't see an untilM or similar
12:48:35 <andersca> @type takeWhile
12:48:36 <lambdabot> takeWhile :: (a -> Bool) -> [a] -> [a]
12:48:48 <cm_> hey
12:48:48 <shapr> actually, liftM dropWhile $ (not . id) ?
12:49:09 <cm_> is there a possibility to catch an error in the enclosing IO monad?
12:49:12 <Riastradh> (not . id)?  Um, why not just not?
12:49:18 <Igloo> To do liftM you have to have sequenced, by which point it's too late
12:49:21 <shapr> Riastradh: that would be too easy.
12:49:39 <shapr> Riastradh: see, not . id checks them for driver's licenses.
12:49:50 <cm_> (like, i thought catch should work as "error" seems to raise an ErrorCall Exception)
12:50:21 <Darius> foldM (\b m -> if b then m else return b) True
12:50:21 <ham[kell]> good night
12:50:31 <Riastradh> Haskell's exception system needs reworking in general.
12:50:31 <shapr> good night ham[kell] 
12:53:06 <Darius> cm_: In Haskell 98 there are many exceptions you can't catch.
12:54:27 <Darius> You'd use ioError . userError instead of error if you want to catch something in the IO monad.
12:54:44 <Darius> Or if you don't mind restricting yourself to GHC (and maybe Hugs?), it has a more powerful catch.
12:54:52 <Heffalump> what's wrong with error, OOI?
12:57:19 <cm_> Darius: thanks
12:57:38 <cm_> trying to understand the monad wrapper of Alex atm :)
13:00:19 <cm_> Darius: i can restrict myself to GHC, though. how would catching an "error" work there?
13:02:43 <Igloo> If you're using a monad with alex you ought to be able to just pass your errors around as values in the monad, avoiding Haskell exceptions/errors completely
13:03:31 <cm_> yeah. i'm not sure whether i want to rewrite my alex actions, tho.
13:04:04 <cm_> what i want is basically the simplest way to get a scanner String -> Maybe [Token]
13:05:10 <Igloo> lexer :: String -> Either String [Token]
13:05:10 <Igloo> lexer str = runAlex str $ do
13:05:10 <Igloo>   let loop = do tok <- alexMonadScan
13:05:10 <Igloo>                 case tok of 
13:05:10 <Igloo>                     TEOF -> return [] 
13:05:12 <Igloo>                     _ -> liftM (tok:) loop
13:05:15 <Igloo>   loop
13:05:23 <Igloo> Is what I have, which you could treat as the same
13:06:31 <cm_> oh alright
13:06:39 * Igloo doesn't know if that's hideously inefficient, mind. When I get to caring about that I'll look into getting it to work with happy's monad stuff
13:07:13 <cm_> so TEOF would just be another token i would add
13:07:20 <cm_> how about errors, would i use "fail" for those?
13:07:38 <Igloo> alexEOF :: Alex Token
13:07:38 <Igloo> alexEOF = return TEOF
13:08:05 <Igloo> I never wanted errors, alex just made some for me
13:08:23 <Igloo> Why do you want them?
13:09:21 <cm_> hrm, i'm trying to lex scheme :)
13:09:30 <Igloo> alexError :: String -> Alex a    it looks like
13:09:30 <cm_> and it has those character literals #\a or #\a
13:09:53 <Riastradh> cm_, you're writing an S-expression lexer?
13:09:55 <cm_> hrm actually, nevermind.
13:10:03 <cm_> Riastradh: yeah ;)
13:10:06 <Igloo> Surely it doesn't have tokens you can't match with regexps?
13:10:15 <cm_> no it doesn't, i just realized.
13:10:17 * cm_ slaps himself
13:10:19 * Igloo doesn't know about such char literals
13:10:37 <Riastradh> cm_, to do that, I'd suggest that you pass around a table of octothorpe reader macros; the one for \ would read a character literal.
13:10:41 <Igloo> And if there's a difference in the above I can't see it
13:11:20 <cm_> Igloo: never mind, i forgot about \\ \# [Ss] [Pp] [Aa] [Cc] [Ee] (not sure whether that can be put simpler in regexps)
13:11:33 <cm_> Riastradh: you mean, similar to the CL reader?
13:11:49 <Riastradh> cm_, possibly; I'm not very familiar with how CL works in that regard.
13:12:19 <cm_> i think it has some reader table, each character dispatching onto a reader function. can't quite remember, though.
13:12:47 <cm_> (i did it a similar way in c++, though, when i wanted to parse s-expressions for a toy interpreter)
13:13:53 <cm_> (http://217.28.101.185/test.png ;)
13:14:53 <Riastradh> Quibble!  Vector literals should be quoted.
13:15:41 <cm_> oh yeah?
13:15:52 <Riastradh> Ew.  The SET!s to introduce variables look gross.
13:16:56 <cm_> yup, indeed.
13:17:21 <cm_> and a third point -- it is horribly slow :)
13:17:42 <cm_> but i'm confused about the vector literals.. do you really have to quote those?
13:17:50 <cm_> that would be different to CL then, hrm.
13:17:52 <Riastradh> You ought to, by R5RS.
13:19:22 <cm_> thanks.
13:36:09 <cm_> Igloo: works like a charm, btw ;)
13:59:00 <cptchaos> Could anyone tell me the difference between the ST Monade and the StateT monad with an IORef as State-Type?
14:03:42 <Darius> In what way do you think they are the same?
14:04:13 <cptchaos> I am writing a sort of message dispatcher
14:04:36 <Heffalump> ST/STRef is essentially a subset of IO/IORef
14:04:54 <Heffalump> whereas StateT uses purely functional code to do its work
14:05:11 <cptchaos> and needed a infinite loop over an statemonad
14:06:04 <cptchaos> where the statemonad encapsulates the IO monad, i.e somethik like \s -> IO(a,s)
14:07:23 <cptchaos> after looking around a while I realizized that mfix ist not the think I was looking for, becaus I wanted to pass the states between the loopsteps
14:08:45 <cptchaos> sorry for my bad english ...
14:09:22 <cptchaos> so far I have written somthing like:
14:09:33 <cptchaos> type IOS a = StateT SysState IO a
14:09:33 <cptchaos>                                                                                 
14:09:33 <cptchaos> loop :: SysState -> IOS () -> IO ()
14:09:33 <cptchaos> loop s sm = do sRef <- newIORef s
14:09:34 <cptchaos>                loop' sRef
14:09:36 <cptchaos>  where
14:09:38 <cptchaos>   loop' :: IORef SysState -> IO ()
14:09:40 <cptchaos>   loop' sRef = do s <- readIORef sRef
14:09:42 <cptchaos>                   (_,s') <- runStateT sm s
14:09:44 <cptchaos>                   writeIORef sRef s'
14:09:46 <cptchaos>                   performGC
14:09:48 <cptchaos>                   loop' sRef
14:10:35 <cptchaos> this works, but looks ugly
14:11:34 <cptchaos> and I thought of the ST monade as a Statemonad passing around its States with IORefs
14:13:53 <cptchaos> I wanted to know if, reimplementig this with the ST monade would get more effective, than reimplementing this with type IOS a = StateT (IORef SysState) IO a
14:14:55 <cptchaos> Heffalump: thanks
14:15:33 <Heffalump> so you'll do a fixpoint computation using runST if you redo it wih ST?
14:16:06 <Heffalump> you probably can't performGC in ST.
14:16:36 <cptchaos> hm, I wantet to get rid of performGC at all ...
14:17:42 <Heffalump> one view of ST is that it's a subset of IO that just has the state references, and thus allows you to have a run command, if you obey some additional conditions to stop references leaking between ST invocations
14:18:25 <cptchaos> the first thing I thought of was indeed a fixpoint computation, but I am not shure if the state then gets passed around correctly
14:19:25 <Heffalump> are you actually computing a fixpoint, or just repeating the same operation?
14:20:04 <cptchaos> I am repeating the same operation, i.e. handling networkrequests, and similar
14:20:29 <cptchaos> and the amount of open connetions are part of the state
14:20:47 <cptchaos> (along with other things)
14:21:08 <Heffalump> don't you need IO for that bit?
14:21:20 <Heffalump> once you're using IO anyway, there's no point in trying to avoid it
14:21:46 <Heffalump> wrapping StateT on top to keep track of the IORef is handy, though
14:22:45 <cm_> lightning.. odd
14:23:07 <cptchaos> it akutally makes the scheduler code readable
14:23:22 <cptchaos> or better readable
14:25:05 <Darius> There's little reason to have a reference in a State monad.
14:25:19 <Darius> It'd be better to use a Reader monad.
14:26:20 <Darius> That said, I don't see what you're trying to accomplish with it anyways.
14:26:31 * cptchaos is looking  up reader monads
14:28:59 <Darius> ignoring performGC, loop is equivalent to loop s sm = do s' <- execStateT sm s; loop s' sm.  Whether having a State monad at all is useful depends on what the passed in 'sm' values do.
14:30:17 <Heffalump> oh, yes, sorry (re Reader/State)
14:35:31 <cptchaos> Darius: you loop does not need the performGC, at least on my system
14:38:50 <cptchaos> Darius: I thougt, that the Refentce in the StateMonad would make the loop more efficient, but I guess thats not really the case
14:39:46 <cptchaos> Because I had to wirte replacements for get and put to gain the same funktionality
14:40:44 <Darius> The reference isn't the state that's being passed by the state monad. Another reference may but not the one allocated in loop.
14:41:33 <cptchaos> yes
14:42:30 <cptchaos> I had the Idea to optimise with 
14:42:30 <cptchaos> type IOS a = StateT (IORef SysState) IO a
14:43:11 <cptchaos> then put and get would correspended to readIORef and writeIORef
14:45:14 <Darius> Optimize what?
14:45:39 <cptchaos> the Memory-Futprint, and executiontime of the Loop
14:45:53 <cptchaos> s/Futprintt/Footprint/
14:50:08 <cptchaos> Darius: Thanks a lot, I will go to Bed now, your loop version is at least readable
16:06:46 <shapr> everyone is running off to sleep now.
16:06:51 <shapr> ok, not quite everyone
16:06:54 <Pseudonym> More fool them.
16:07:05 <shapr> g'day Pseudonym 
16:07:07 <Pseudonym> G'day.
16:07:12 <shapr> how's life?
16:07:24 <Pseudonym> I feel like I should sleep, but it's 11am and I'm at w*rk so this isn't an option.
16:07:49 <Pseudonym> Been playing with 3D character rigging in Maya lately.
16:07:55 <shapr> oh?
16:08:18 <shapr> rigging meaning giving a puppeteer like structure?
16:08:26 <shapr> Pseudonym: have you seen Hudak's Dance language?
16:08:30 <Pseudonym> Yes, kind of.
16:08:34 <shapr> do you know anything about machinima?
16:08:42 <Pseudonym> No, I haven't, but I've read mamers going back to the 80s about similar languages.
16:09:03 <Pseudonym> Rigging is... OK.  When you model a figure, you basically have a 2D surface.
16:09:06 <Pseudonym> Infinitely thin shell.
16:09:26 <Pseudonym> Rigging is everything between than and having something that an animator can use.
16:09:48 <Pseudonym> I'm finding it interesting.  There's a lot of constraint solving that goes into it.
16:09:58 <Pseudonym> I've heard about machinima.
16:10:10 <shapr> I've thought that something like Dance could be used so that a digital character could walk and move by itself, and the programmer could move up to 'director'
16:10:14 <Pseudonym> Haven't seen any.
16:10:26 <shapr> Red vs Blue is a wonderful machinima series
16:11:32 <Pseudonym> At the moment, I'm dealing with the basics.  Haven't gotten to actual animation yet.
16:11:59 <Pseudonym> Things like how to do squash and stretch, or to handle both dynamics and controls in the same model.
16:12:18 <Pseudonym> I spent a lot of time last night stepping through the special features on my copy of "Ice Age".
16:12:34 <shapr> yah, Ice Age was inspirational for me also
16:12:52 <Pseudonym> I discovered some interesting stuff just by looking through the images.
16:12:56 <shapr> like what?
16:13:01 <Pseudonym> The rig for the mammoth, for example, has two trunks.
16:13:06 <shapr> ??
16:13:09 <Pseudonym> Yup.
16:13:13 <Pseudonym> Just the rig, not the model.
16:13:13 <shapr> what for?
16:13:32 <Pseudonym> Reading between the lines, one is animatable and one is dynamic.
16:13:40 <shapr> what's the difference?
16:13:43 <Pseudonym> The dynamic one just behaves like a thick dangling rope.
16:13:47 <shapr> ohh
16:13:51 <Pseudonym> The computer works out all the physics.
16:13:55 <shapr> I see
16:14:02 <Pseudonym> The animatable one is fully under the animator's control.
16:14:13 <Pseudonym> And presumably there's a control to smoothly interpolate between them.
16:14:25 <shapr> would make sense
16:14:54 <Pseudonym> This is a common technique, for example, to switch between FK and IK models, or to do squash and stretch.
16:15:27 * shapr considers that
16:15:48 <Pseudonym> I actually did squash and stretch in Maya yesterday, so I know this. :-)
16:16:22 <shapr> I'd like to mix Yampa and HOpenGL
16:16:33 <shapr> Hudak's Dance language has a very basic simulator that does that
16:16:39 <Pseudonym> Interesting.
16:16:44 <shapr> yah it is
16:17:10 <shapr> Dance is to control humanoid robots using a labanotation based framework
16:17:20 <shapr> so it has both dynamic and static bits
16:17:24 * Pseudonym nods
16:17:26 <shapr> worth reading
16:35:19 * SamB wonders whether a monad is a type or an object
16:35:49 <Pseudonym> A type is a set of objects.
16:35:56 <Pseudonym> A typeclass is a set of types.
16:36:13 <Pseudonym> "Monad" is technically a typeclass, but it makes sense to call a type and an object a "monad" if it's a member.
16:36:59 <Riastradh> A monad is any value upon which the operations bind, return, and fail are defined.
16:37:56 <Smerdyakov> Nope. It has to satisfy the laaaaaaws!
16:38:14 <Riastradh> Nope.  All Haskell cares about is that those three operations are defined on it.
16:38:33 <Pseudonym> No, all Haskell cares about is that there is a declared typeclass instance.
16:38:35 <Smerdyakov> But you are being a jackass if it doesn't satisfy that, and it's not a monad mathematically, either.
16:38:45 <Pseudonym> If the operations are defined, that doesn't matter if there's no declared instance.
16:39:26 <Riastradh> Nope.  If the >>= method in specific of the Monad typeclass is defined, then the typeclass must be defined.
16:39:47 <Riastradh> Haskell cares if it isn't defined, too; you'll get an error about that somewhere.
16:39:57 <Riastradh> Er, if it isn't defined but there's a typeclass instance, that is.
16:40:13 <Riastradh> Er.  I said above 'the typeclass must be defined,' and I forgot to say 'instance' after 'typeclass.'
16:40:28 <Pseudonym> Ah, that's something different.
16:40:47 <Pseudonym> There's no reason why I can't define (in a module other than the prelude, obviously) an operation called >>= which does something completely different.
16:41:04 <Riastradh> No.  I'm referring to the generic >>= operation that the Monad typeclass defines.
16:41:16 <Pseudonym> Well, then, you agree with me, then. :-)
16:42:05 <Riastradh> No, because you're saying the fundamental concept is that an instance of Monad is defined, where it's really that any of those operations are defined, because if an instance of Monad is defined, then those operations may not be defined, and you'll get an error if you try to use objects of that instance as monads.
16:42:22 <Pseudonym> No, I'm saying what Haskell cares about.
16:42:28 <SamB> hmm, when you talk about threading a monad through something, that doesn't seem to indicate anything about the monad that comes out having the same value as comes in. this is what makes me wonder.
16:42:41 <Pseudonym> The "fundamental concept" is what Smerdyakov said.  You must have the operations AND the laws satisfied.
16:42:52 <Riastradh> OK, sorry, the fundamental concept of what Haskell cares about.
16:43:23 <Pseudonym> BTW, defining an operation as "error" or "undefined" is fine.  Haskell won't care.
16:43:28 <SamB> Pseudonym, Riastradh: I know what Haskell thinks about the monads. I'm talking more about the english usage
16:43:39 <Riastradh> Haskell cares that the operations are defined.  If they're not, something will go wrong somewhere.  If they are, then the typeclass instance must be defined, but not necessarily the reverse.
16:43:40 <Pseudonym> SamB: Yes, we're just being obtuse.
16:43:51 <Riastradh> Pseudonym is being wrong and I'm being pedantic, you mean.
16:44:11 <Pseudonym> No, I'm being right and you're being confusing.
16:44:39 <Pseudonym> For something to be a monad, it must be an instance of Monad.  End of story.
16:45:03 <Pseudonym> Well, that's all that Haskell cares about, anyway.
16:45:14 <Pseudonym> To be a mathematical monad, that's a different issue.
16:45:21 <Riastradh> Wrong.  The three operations must be defined.  If they are, then it must be an instance of Monad.  If they aren't, then you'll get an error about the operation being undefined or an error about error having been called, which is what Haskell cares about to indicate that something went wrong.
16:46:19 <Pseudonym> If you try to use something as a monad (e.g. using do-notation) without the instance being defined, any conforming Haskell implementation will complain.
16:46:41 <Pseudonym> The operations are a necessary prerequisite for there to be an instance.
16:46:45 <Riastradh> The instance being defined is provable by the operations having been defined, but not vice versa.
16:46:53 <SamB> a mathematicaly correct monad type could not be an instance of Monad, and vice versa. But the latter would be evil, in most cases.
16:46:56 <Pseudonym> But no instance, no Monad.
16:47:20 <Riastradh> No, Monad still exists, regardless of whether or not your type has an instance of it.
16:47:52 <Pseudonym> OK, yes, that's true.
16:48:03 <Riastradh> Now, if the operations are undefined, then Haskell will inform you at some point that something went wrong, which is due to it not being a monad.  But If the operations _are_ defined, then the typeclass _must_ have an instance, whereas the converse is _not_ true.
16:48:09 <Pseudonym> But that's a separate issue.
16:48:13 <Riastradh> SamB, what was your question, again?  I wasn't paying attention.
16:48:49 <Pseudonym> It depends what you mean for operations to be defined.  I can make a module and define return, >>= and fail in there without mentioning the Monad typeclass once.
16:48:51 <Riastradh> Pseudonym, no, it's not!  If there is an instance, then the operations might still be undefined, which Haskell cares about when you use an object as a monad.  But if the operations _are_ defined, then there must be a typeclass, and Haskell is happy when you try to use it as a monad.
16:49:02 <Pseudonym> It may be a mathametical monad, but it won't be a Haskell Monad.
16:49:05 <Riastradh> I'm talking about what return, >>=, and fail refer to in Prelude.
16:49:57 <Pseudonym> How can you make an instance without defining the operations?
16:50:04 <SamB> really, I'm just wondering if the monad that goes into a monadic computation is the same one that comes out. Otherwise, "the IO Monad" doesn't make sense to me.
16:50:14 <Riastradh> by simply not having definitions for them.
16:50:27 <Riastradh> SamB, what do you mean by 'the same?'
16:50:36 <SamB> Pseudonym: under protest
16:51:19 <SamB> Riastradh: I mean, it seems like people think of it that way.
16:51:38 <Riastradh> SamB, fail "I don't see how that relates to my last question."
16:51:42 <Riastradh> (oops, you didn't define fail!)
16:52:04 <Riastradh> (And so you aren't a monad; Haskell will signal an error about that, and you'll crash.)
16:52:23 <Riastradh> (But if you _had_ defined the operation, then you must have also defined the typeclass, and you'd be able to do something about the failure.  See?)
16:53:21 <Pseudonym> OMG, you can too.
16:53:22 <SamB>     fail :: forall a. String -> m a {- has default method -};
16:53:29 <Pseudonym> When did they add that to the language?
16:53:43 <Pseudonym> And who wanted this "feature"?
16:54:01 <Pseudonym> Riastradh: OK, you're right.  But you shouldn't be.
16:54:31 <Riastradh> Zigackly.  Haskell is wrong but because of Haskell's wrongness I'm right.
16:54:38 <Riastradh> Or I just know Haskell better than you do.  Nyah.
16:54:48 <Pseudonym> I don't know H98 as well as many do.
16:55:18 <Pseudonym> H98 was actually a cut-down version of previous versions.
16:56:10 <Pseudonym> OK, I shall reword what I was saying in the light of this ugliness.
16:56:21 <Pseudonym> To be a Monad, Haskell requires the instance.
16:56:34 <Pseudonym> To _use_ it as a monad, you also need the operations... sort of.
16:56:47 <Riastradh> Yes, to be a value whose type has an instance of Monad, your type needs to have an instance of Monad.
16:56:55 <Pseudonym> If, for example, you use do-notation but never have a failing pattern, in theory you shouldn't need fail.
16:57:08 <Riastradh> Isn't circular logic great?
16:57:17 <SamB> to be usefull, there must be return and >>=
16:57:17 <Pseudonym> I suspect it would depend on the implementation as to whether or not you did need that.
16:57:48 <SamB> Riastradh: last I checked, it resulted in a quick bottom
16:58:08 <Pseudonym> Sometimes it results in a blown stack.
16:58:22 <SamB> in GHC, anyway
16:58:45 <Pseudonym> True.  On a Turing machine, the stack is infinite.
16:58:48 <Riastradh> A blown stack would imply that it were not tail-recursive.
16:59:21 <Pseudonym> On Hugs, it sometimes exhibits as a blown heap.  Especially if you use CAFs.
16:59:25 <Riastradh> In this case it is, so the implementation's idiotic lack of TCO is at fault, even if Pseudonym is not a particularly concretely defended logician.
19:12:52 <SyntaxLaptop> hm. so I'm not much of an NHC user, but I'm trying to compile a not-very-big piece of code, and it says
19:12:53 <SyntaxLaptop> ======  Errors when renaming:
19:12:53 <SyntaxLaptop> Identifier putStrLn defined 2 times.
19:12:53 <SyntaxLaptop> No line number, nothing.  Also, I'm obviously not defining that function anywhere.  Any ideas?
19:13:27 <Pseudonym> It might be a transitive import problem.
19:13:38 <SyntaxLaptop> is there a wa yto do the equivalent of --make with nhc?
19:13:39 <Pseudonym> You're importing two modules, each of which re-exports it.
19:13:48 <Pseudonym> Dunno.
19:14:14 <SyntaxLaptop> I should clarify that the code compiles w/ ghc just fine.
19:14:14 <SyntaxLaptop> hmm
19:18:17 <SyntaxLaptop> I'll use hmake :)
19:48:40 <SyntaxLaptop> shapr, Igloo: you've got Mail :)
19:49:11 <Pseudonym> SyntaxLaptop, can you be my biff too?
19:51:37 <SyntaxLaptop> Pseudonym: yes.  I only go off once a week, though, and only tell you whether or not you have new mail that week. :P
19:52:09 <keverets> if you spam filtr, that might also be useful.
19:53:08 <Smerdyakov> Your country's intelligence service uses radiation detectors stationed around your home to determine when you have e-mail and notify you be deporting you to Syria for questioning.
19:53:46 <SyntaxLaptop> keverets: you have spam.
19:54:11 <SyntaxLaptop> Smerdyakov: not possible, my computer has a tinfoil hat
19:54:50 <Pseudonym> Smerdyakov: Caught you.  My country's intelligence service is six guys who meet in the Attorney General's basement.
20:12:08 <SyntaxLaptop> g'night, #haskell
21:43:40 <`John> hello anyone here?
22:19:29 <`John> if hopengl is for windows why does it only include .gz? how  does one untar and install?
22:22:04 <Cale> `John: you'd want to get a newer copy of ghc - hopengl now comes with it.
22:22:17 <Cale> (though perhaps it needs to be compiled in)
22:22:20 <`John> ah
22:22:23 <`John> okay.
22:22:32 <`John> all I have though is mingw to compile.
22:24:02 <Cale> hmm... does the installer provided on the GHC site for version 6.2 seem to include it?
22:24:33 <`John> let me check.
22:25:13 <Cale> it doesn't say on the site, but you could install it and see if it makes the GL libraries available.
22:28:52 <`John> there are .hi files and a opengl gl glut directories, don't see hopengl though.
22:29:07 <Cale> try using hopengl
22:30:28 <`John> you mean the .tar?
22:32:44 <Cale> I mean the library. Try one of the demos or something.
22:33:57 <Cale> like grab http://www.tfh-berlin.de/~panitz/hopengl/examples/src/HelloWindow.hs and see if it compiles
22:34:03 <`John> what's the quick way of doing that? :)
22:34:17 <Cale> ghc -package GLUT -o HelloWindow HelloWindow.hs
22:34:22 <`John> k
22:34:34 <Cale> or rather, ghc -package GLUT -o HelloWindow.exe HelloWindow.hs
22:34:39 <Cale> since you're on windows.
22:46:06 <`John> c:/ghc/ghc-6.2/libHSGLUT.a(Window__53.o)(.text+0x85):ghc14736.hs: undefined reference to 'glutCreateWindow@4'
22:52:15 <Cale> it's partially there then - that's a linker error
22:52:46 <Cale> I don't have a windows machine to try it on though.
22:54:03 <`John> maybe ghc isn't installed properly.
22:54:21 <`John> or perhaps a path missing.
22:58:19 <`John> bbl
