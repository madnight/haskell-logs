02:44:10 <kosmikus> shapr: ping
03:55:21 <ham[kell]> hiho
03:55:30 <ski> hi
04:43:52 <ski> @arr
04:43:53 <lambdabot> I heard andersca is a pirate
04:44:14 <phubuh> :O
04:44:15 <ski> andersca : you are ?  :)
04:50:54 <phubuh> a function of the type a -> a can only be identity or bottom, right?
04:51:14 <ski> yes (if universally quantified)
04:51:23 <phubuh> universally quantified?
04:51:42 <ski> aka (parametric) polymorphic
04:52:31 <ski> a -> a  really stands for  forall a. a -> a  but the first part is implicit
04:53:14 <phubuh> oh
04:53:25 <ski> (though one can use it explicitely in some extensions in e.g. hugs & ghc. (don't you know this ? :) )
04:53:56 <phubuh> nope
04:54:17 * ski thought everybody did              ;-)
04:54:29 <phubuh> haha
04:55:49 <Maddas> function composition is good
04:57:01 <ski> haskell implicitely adds the forall at the top-level of the type, and thereby binds all (free) type-variables. the idea comes from Hindley-Milner type-systems, first used in ML. IIRC
04:57:08 <ski> Maddas : yes
04:58:08 <ski> phubuh : (of course one can think of existentially quantified type variables, also :)
04:58:12 <phubuh> why would one want to explicitly declare that unbound variables are whatever?
04:58:34 <ski> huh ?  "are whatever" ?
04:58:42 <phubuh> are of any type :)
04:58:45 <ski> aha
04:58:52 <ski> think of a type like :
04:59:13 <shapr> god morgon #haskell.se!
04:59:15 * shapr grins
04:59:20 <ski> (forall a. [a] -> [a]) -> ...something...
04:59:37 * shapr le
04:59:41 * Jerub waves to shapr
04:59:46 <shapr> ler?
04:59:53 <shapr> g'day Jerub, what's up?
04:59:56 <ski> shapr : morgon ?  hur laenge sover du dao ?  ;)
05:00:04 <shapr> jar har just nu vaknat
05:00:09 <ski> shapr : ler
05:00:12 <phubuh> yeah, shapr le is an imperative :)
05:00:19 <shapr> smile! now!
05:00:22 * shapr snickers
05:00:25 * phubuh ler
05:00:34 * shapr laughs
05:00:46 * ski tries not to smile
05:00:49 <shapr> kosmikus: you called?
05:00:52 <ski> and fails
05:01:04 <Jerub> shapr: various linkages across the etherweb brought me back to #haskell
05:01:16 <shapr> all roads lead you to roam
05:01:19 <shapr> isn't that the quote?
05:01:38 <Maddas> haha
05:01:41 <Jerub> shapr: #twisted->radix->del.icio.us->darius bacon->ifcp'01->#haskell
05:01:57 <ski> isn't rome in latin 'roma', i.e. almost rome ?
05:01:58 <shapr> I don't know del.icio.us
05:01:59 <Jerub> (there's a loop in there, but thats the basic path)
05:02:27 <phubuh> what do you guys think of using arrows to represent remote functions?
05:02:28 <shapr> Darius Bacon is a cool guy, he show up here sometimes.
05:02:36 <Jerub> shapr: I know, demoncrat
05:02:40 <ski> (s/rome/roam/)
05:02:46 <shapr> he's changed nicks, he's darius- now
05:02:47 <Jerub> he's also a scheme nut.
05:02:50 <Jerub> ahh.
05:03:03 <phubuh> having a darius- and a Darius is pretty confusing
05:03:26 <Jerub> phubuh: Darius is a Derek, Darius- is a Darius ;)
05:03:57 <shapr> and darius- flew up from san francisco to seattle to spend a weekend pair programming with me, so I tend to remember who he is.
05:04:38 <shapr> del.icio.us is interesting
05:04:40 <Jerub> crazy
05:04:52 <Jerub> shapr: del.icio.us/jerub
05:04:53 <Jerub> :)
05:05:05 <shapr> neat
05:05:25 <ski> there is a Dariusz at the program for CW'04, also
05:05:42 * shapr is reminded of the Simons
05:06:39 <shapr> Jerub: have you seen darius-' CL and Python ports of QuickCheck?
05:06:42 <liiwi> break! coffee and bagels for everybody.
05:07:02 <shapr> liiwi!
05:07:09 <ski> where, where ?
05:07:19 <shapr> hiii liiwi!
05:07:31 <Jerub> clickcheck?
05:07:35 <shapr> yah, clickcheck
05:07:41 <Jerub>  ;)
05:07:52 <Jerub>  ;)
05:07:58 <Jerub> stupid firebird
05:08:06 <Jerub>  ;)
05:08:09 <Jerub> gah!
05:08:12 * shapr grins
05:08:12 <Jerub> nevermind
05:08:31 <liiwi> heh
05:09:28 <shapr> ski: hey, I didn't mean to distract you from "why would someone want to declare that unbound variables are of any type?"
05:09:48 <ski> shapr : no prob :)
05:10:23 <ski> phubuh : you wanna hear more ? :)
05:10:35 <phubuh> sure :)
05:11:12 <ski> do you understand _why_ polymorphism is related to _universal_ quantification ?
05:11:30 <shapr> liiwi: come back to learn Haskell? :-)
05:11:44 <phubuh> yes, I think so
05:12:24 <ski> mm, should i say something about existensials, or about what i began above ?
05:12:25 <phubuh> I just don't understand the point of using those extensions you talked about, that let you type the forall explicitly
05:12:26 <Darius> (not unbound variables, unbound -type- variables)
05:12:38 <phubuh> yeah
05:12:39 <liiwi> shapr: let's just say that I'm exposing myself to different flows.
05:13:03 <shapr> liiwi: good idea
05:13:17 <Darius> phubuh: For the cases that correspond to Haskell 98 there isn't, it's just allowed for consistency.
05:13:33 <Darius> (isn't any point)
05:13:39 <phubuh> oh
05:14:12 <ski> well
05:14:15 <Darius> For a type like (forall a. a -> a) -> b -> b, the forall is necessary.
05:14:27 <ski> as well as for  (forall a. [a] -> [a]) -> ...something...
05:14:44 <Darius> You could also write, forall b.(forall a. a -> a) -> b -> b, but the first forall is unnecessary but allowed with GHC.
05:14:49 <phubuh> I don't understand that type
05:15:24 <kosmikus> shapr: never mind, I wanted to discuss whether you think gforge is up to host the just announced release of lhs2tex, but I decided against it for now ...
05:15:34 <ski> phubuh : if you don't write them explicitely, the system is implicitely gonna put them (the univ. quantifiers) at the outermost level of the type
05:15:59 <ski> phubuh : which type don't you understand ?
05:16:02 <earthy> `just announced' he says
05:16:09 <shapr> kosmikus: okay
05:16:11 <earthy> and the minute I read that my mailbox updates. :)
05:17:18 <phubuh> foo :: (forall a. a -> a) -> b -> b
05:17:19 <phubuh> foo _ = id
05:17:19 <phubuh> bar :: (a -> a) -> b -> b
05:17:19 <phubuh> bar _ = id
05:17:20 <phubuh> those both work
05:17:45 <ski> but they have different types
05:17:45 <earthy> phubuh: but they are different types.
05:17:45 <Darius> foo f = (f 3,f True)
05:18:03 <ski> Darius : thanks. (was going to show that next :)
05:18:30 <ski> or maybe  foo f = (f (f 3),f True)  is pedagogically better ?
05:18:47 <earthy> however,  bar f = (f 3, f True)  would be badly typed.
05:18:50 <earthy> ski: no
05:19:11 <ski> earthy : why ?
05:19:23 <earthy> it opens yet another can of worms. :)
05:19:24 <ski> think about   bar id
05:20:16 <earthy> ski: think about  bar id   in what context?
05:20:56 <ski> what does your intuition say about what it should evaluate to ?  does it invoke any runtime errors, e.g. ?
05:21:17 <phubuh> Darius: ah!
05:21:56 <ski> phubuh : think you can write a correct type for bar, now, eh ?  :)
05:22:11 <earthy> ski: my intuition is that the typechecker should fail if I define   bar :: (a -> a) -> b -> b; bar f = (f 3, f True)
05:22:24 <earthy> and then us  bar id
05:22:27 <earthy> +e
05:22:28 <ski> earthy : you are correct
05:23:16 <ski> and "(a -> a) -> b -> b" is equiv. to "forall a b.(a -> a) -> b -> b"   do you see this ?
05:23:26 <earthy> yes, you said that. ;)
05:24:10 <ski> how about "forall b.(forall a. a -> a) -> b -> b", or shorter "(forall a. a -> a) -> b -> b"
05:24:11 <earthy> and I see where in a programming language that would be the best interpretation
05:24:32 <earthy> *blink*
05:24:33 <ski> um, well, s/b/(Int,Bool)/ actually
05:24:37 * earthy autolarts. :)
05:24:49 <ski> for the actual bar example
05:24:54 <earthy> ski: yeah.
05:25:43 <ski> but, of course, there aren't that many interesting functions of type "forall a. a -> a"
05:26:03 <ski> forall a. [a] -> [a]   is more interesting
05:26:49 <earthy> what had me thrown was that in Haskell a and b can never be existing types but must always be type variables.
05:26:50 <ski> the only things functions of this type can do is drop, duplicate and reorder elements the list
05:27:25 <earthy> in typed lambda calculi that syntactic distinction isn't usually made
05:27:27 <ski> earthy : what do you mean by "existing" ?  existential ?  instantiated ?
05:27:44 <earthy> existing, as in defined. :)
05:28:25 <ski> hmm, still don't understand your remark..
05:28:34 <earthy> lemmethink
05:28:48 <Darius> concrete
05:28:58 <Darius> or fixed
05:29:02 <earthy> if I specify a type  a -> b  in Haskell, I know *syntactically* that both a and b are variables.
05:29:23 <phubuh> I think earthy originally meant "... if I define bar :: (a -> a) -> B -> B ..."?
05:29:54 <earthy> if I specify   A -> B   I know for a fact, again syntactically, that A and B are *not* variables.
05:30:01 <ski> yes
05:30:22 <earthy> this syntactic distinction is not usually made in lambda calculi
05:30:54 <earthy> so   a -> b   in and of itself signifies the equivalent of my   A -> B  example
05:30:57 <ski> simply typed polymorphic lambda calculus ?
05:31:02 <earthy> ski: e.g.
05:31:16 <earthy> yes.
05:32:37 <phubuh> I don't understand why \f -> (f 3, f True) can't be typed Num b => (a -> a) -> (b, Bool)
05:33:02 <ski> phubuh : tried in hugs/ghci ?  :)
05:33:05 <phubuh> yeah
05:33:45 <ski> well, only let-bound variables can be polymorphically typed       (understood anything of that ? :)
05:34:19 <ski> hm
05:34:22 <earthy> phubuh: because, in order to have f apply to both 3 and True, you need f to have *both* the types Int -> Int and  Bool -> Bool   at the same time
05:34:22 <ski> waitasec
05:34:24 <phubuh> no :)
05:34:26 <Darius> phubuh: You use f on a Bool therefore f can't be a -> a, it must b Bool to Bool.
05:34:55 <earthy> Prelude> :type \f -> (f 3, f True)
05:34:58 <earthy>     No instance for (Num Bool)
05:35:01 <earthy> *hm*. :)
05:35:16 <Darius> @type \f -> (f 3,f True)
05:35:30 <shapr> lambdabot: @hello ?
05:35:30 <lambdabot> Hello world. ?
05:35:31 <Darius> @type \f -> f True
05:35:31 <lambdabot> \f -> f True :: (Bool -> a) -> a
05:35:44 <Darius> shapr: it doesn't say anything when it fails to typecheck.
05:35:50 <shapr> that sucks
05:35:51 <ski> Darius : (why didn't i think of that ? :)
05:36:24 <shapr> not only that, but it leaves a zombie process around for each @type call
05:36:41 <Darius> earthy,phubuh: Using 'a' and True should give "type not polymorphic enough"
05:37:23 <phubuh> earthy: I thought that was what (a -> a) would give -- a variable that is Int -> Int and Bool -> Bool and Whatever -> Whatever, at the same time
05:37:30 <phubuh> err, a function
05:37:35 <phubuh> err, a value
05:37:36 <phubuh> bah!
05:38:19 <ski> phubuh : it depends on *where* the quantification is
05:38:35 <Darius> phubuh: It gives you a function that will work on -any- -particular- a -> a, not a function that takes a function that will work on any a and return a.
05:39:19 <ski> say    BlahaBlaha -> (a -> a)   now you can specialize this type to e.g.  BlahaBlaha -> (Bool -> Bool)
05:40:24 <ski> of course you could specialize a to any other type, so in this case you can say that the a in (a -> a) stands for any type
05:41:26 <phubuh> ah
05:41:33 <phubuh> oh
05:41:38 <ski> i.e. the function returned from the above has type (a -> a), *for all* a
05:41:54 <ski> or IOW it has *the* type "forall a. a -> a"
05:42:05 <ski> mm ?
05:42:35 <earthy> ski: but that makes sense, due to the quantor being implicit around every type that contains variables.
05:42:41 <ski> yes
05:43:38 <ski> so "BlahaBlaha -> (a -> a)" really is "forall a.BlahaBlaha -> (a -> a)", but if a doesn't occur inside BlahaBlaha, this type is logically equivalent to "BlahaBlaha -> (forall a. a -> a)"
05:43:50 <phubuh> forall a. (a -> a) -> (Int, Bool) gives one function for every a
05:44:00 <ski> yes
05:44:50 <ski> but "forall a. (a -> a) -> (Int, Bool)" is *not* logically equiv. to "(forall a. a -> a) -> (Int, Bool)"
05:44:53 <earthy> ski: it has to be, due to any application of  BlahBlahBlah -> (a -> a)  having type  a -> a  with the implicit quantor around it
05:45:01 <phubuh> but we want a function that can take an instance of every (a -> a)
05:45:14 <ski> yes
05:45:21 <phubuh> I get it now, I think, thanks :-)
05:46:18 <earthy> no probs. :)
05:46:37 <ski> we want, so to speak, not to pass one particular function of type (a -> a), for some type a, to the above func, but, in a way, pass one function of type (a -> a), one for *every* type a
05:46:49 <ski> good
05:46:55 <phubuh> yeah
05:47:28 <ski> (and this is accomplished by passing a true polymorphic function)
05:48:50 * earthy ponders adding typevariables to Algol 68
05:49:27 <ski> is anyone still using it ?
05:50:02 <ski> (or do you mean : just thinking how to fit it into the system. hmm, prolly)
05:51:04 <earthy> ski: :)
05:51:05 <ski> hi raver, do you rave a lot ?                          :)
05:51:24 <earthy> and yes, there is still weirdos writing Algol 68
05:51:43 <ski> is there any standardisation still going on ?
05:52:06 <earthy> (Marcel van der Veer, e.g., http://www.xs4all.nl/~jmvdveer/algol.html )
05:52:14 <earthy> ski: not that I know
05:52:30 <earthy> even though IFIP WG 2.1 still has a standing responsibility for the language.
05:52:33 <ski> heh
05:55:26 * earthy guesses people won't be too mad for him installing GHC 6.2 instead of 5.0.4 on the faculty systems
05:55:28 <earthy> let's *try* :)
05:56:18 <earthy> 5.04.3 that is
05:56:50 <shapr> hey earthy, can you check gforge.scannedinavian.org now?
05:57:10 <earthy> yup, works.
05:57:15 <earthy> updated the serialno?
05:57:22 <shapr> yup
05:59:40 <phubuh> http://www.cs.uu.nl/~andres/lhs2tex/ seems interesting
05:59:58 * earthy notes the code snippet category list needs *heavy* updating before gforge is ready as projects.haskell.org. ;)
06:01:18 <earthy> (I'd categorize the codesnippets not by language but by intended purpose, as the idea is that all code snippets are haskell code snippets anyway)
06:01:46 <shapr> I can see useful C snippets though, calling Haskell from C for example
06:01:55 <shapr> though maybe that would be better as a combo of various snippets.
06:02:50 <ski> you could make an FFI category
06:02:56 <shapr> good point
06:03:02 * earthy nods
06:03:42 <shapr> anyways, that sort of thing gets more interesting after I've heard what the Simons and haskell.org maintainers think
06:04:10 <shapr> they may suggest running it on haskell.org hardware and bandwidth
06:04:19 <earthy> 219 KB/s for downloading the Haskell sources.
06:04:25 * earthy likes university networks. :)
06:11:40 <earthy> @yow
06:11:41 <lambdabot> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like
06:11:41 <lambdabot>  RICARDO MONTALBAN'S HAIR!
06:11:48 <earthy> @yow
06:11:49 <lambdabot> I am having a pleasant time!!
06:11:57 <ski> me too !
06:12:08 <ski> (R)
06:12:25 <ski> @moo
06:12:26 <lambdabot>          (__)
06:12:26 <lambdabot>          (oo)
06:12:26 <lambdabot>    /------\/
06:12:26 <lambdabot>   / |    ||
06:12:26 <lambdabot>  *  /\---/\
06:12:27 <lambdabot>     ~~   ~~
06:12:29 <lambdabot> ...."Have you mooed today?"...
06:21:29 <ham[kell]> is the monad closely related to a coalgebra?
06:22:35 <ski> ham[kell] : (F-coalgebra ? :)
06:23:11 <ham[kell]> sec
06:24:32 <ski> ham[kell] : ?
06:24:51 <ham[kell]> have to help someone
06:24:58 <ski> mm
06:25:03 <ham[kell]> but i got a paper but its in german
06:25:13 <ham[kell]> and it looks kind of similar to me
06:25:24 * ski 's german is not so good
06:26:02 <Igloo> Bah. I change to using a name generation monad and my FMP pictures start working. Oh for scoped names...
06:26:12 <shapr> FMP?
06:26:15 <shapr> oh
06:26:20 <shapr> functional metapost
06:26:24 <Igloo> Yup
06:26:31 <ski> what's that ?
06:26:56 <Igloo> It's like metapost but a little bit more sane to use
06:27:06 <Igloo> metapost is like metafont but for pictures rather than just characters
06:27:10 <ski> what's metapost ?
06:27:15 <Igloo> metafont is Knuth's font description language
06:27:26 <ski> what's .. oh ok :)
06:29:22 <ham[kell]> @arr
06:29:23 <lambdabot> Yeh scurvy dog...
06:29:28 <shapr> @arr
06:29:31 <lambdabot> Aye
06:29:31 <Igloo> Yo Syn
06:29:52 <ham[kell]> what that bot needs is that word duell thing from monkey island
06:30:00 <shapr> write it!
06:30:59 <ski> ham[kell] : You fight like a dairy farmer !
06:31:11 <ski> Answer ?!
06:31:23 <ham[kell]> er at least i am no llama :)
06:31:25 <ski> :)
06:31:36 <shapr> la-la-la-llama!
06:31:53 <ski> you could at least say "I'm rubber, you are glue." :)
06:32:12 <earthy> hm. functional metapost seems cool
06:33:21 <ham[kell]> ski sry i have to clue :)
06:33:31 --- mode: herbert.freenode.net set +b *!*@206.169.168.190
06:33:44 <ski> ham[kell] : :)
06:34:01 <ski> You fight like a cow !
06:34:07 <shapr> moo!
06:34:17 <shapr> monkey island is so much fun
06:34:32 <andersca> I have all the monkey island games
06:34:33 <andersca> original
06:34:38 <shapr> someone gave me a copy they'd played to death, I installed it one evening just to see the intro
06:34:42 <shapr> and finished it the same night
06:34:47 <shapr> and was very tired at work the next day
06:34:47 <ski> :)
06:35:01 <ham[kell]> :)
06:35:13 <shapr> I think I've only played one
06:35:24 <ski> shapr : which ?
06:36:08 <shapr> um
06:36:08 <shapr> the one with the tofu mask, where you dump spicy cheese into the volcano
06:36:29 <ham[kell]> ah mi3
06:36:31 <ski> ah, MI3
06:36:36 <ham[kell]> 4 is a lot better
06:36:37 * shapr grins
06:36:37 <ski> :)
06:36:51 * rubix has only played monkey island 1
06:36:54 <ham[kell]> and 2 is supercool though the gfx is not uptodate
06:37:27 <ski> ham[kell] : i thought the 3d model looked a bit ugly
06:37:44 <ham[kell]> i liked the look
06:37:50 <ham[kell]> it was more mi then 3:)
06:37:52 <shapr> darcs question, is there some way I can keep my .zshrc etc in darcs? should I just run inittree in my home dir?
06:40:58 <ski> shapr : hmm, why don't i see anything at http://www.scannedinavian.org/repos/hlibs/lambdabot/ ?
06:42:40 <ski> am i looking at the worng place ?
06:43:46 <shapr> um
06:44:03 <shapr> the repo browser can see it
06:44:05 <shapr> http://www.scannedinavian.org/cgi-bin/darcs?hlibs*
06:44:43 <ski> thanks
06:44:49 <shapr> I am highly confused. where did these haddocks come from? http://www.scannedinavian.org/repos/hlibs/lambdabot/Util.html
06:45:21 <ski> God ?
06:45:33 <shapr> well, I did give him root
06:45:47 <Igloo> Is something fishy going on?
06:46:00 <shapr> not that he needed it, since he's the equivalent of uid -1, more power than root
06:46:11 <shapr> I don't know, does darcs autogenerate haddocks?
06:47:55 <shapr> oh my, serious user error
06:47:55 * shapr blushes
06:48:04 <shapr> ski: anyways, "darcs get http://www.scannedinavin.org/repos/hlibs" should let you check out the source
06:48:45 <shapr> and if you've given me your public gpg key, you should be able to commit code with darcs push (after darcs record)
06:49:32 <ski> weeell, i haven't got any :(
06:49:41 <ski> shame on me
06:50:11 <shapr> it's easy to make one
06:50:50 <ski> and how do i use darcs ?  (haven't ever use any revision control system or similar)
06:51:05 <shapr> darcs is *really easy* compared to cvs
06:51:08 <ski> should i install something at home box
06:51:10 <ski> ?
06:51:17 <ski> (i guess :)
06:51:24 <shapr> have you already installed the darcs client?
06:51:30 <ski> nonono
06:51:36 <ski> i haven't
06:51:48 <shapr> if not, you'll need either ghc 6.0 or 6.2 to build it
06:52:04 <shapr> or use the debian packages
06:52:17 <ski> well, i see 6.0.1 is here at uni now
06:53:39 <shapr> oh, there are gentoo packages also
06:53:45 <shapr> and freebsd
06:55:17 <Igloo> Cool, changes to support using GHC as a library
06:57:24 <cm_> hi shapr 
06:58:48 <ski> shapr : hmm, where do i find the client ?
07:01:48 <shapr> http://www.abridgegame.org/darcs/
07:02:07 <shapr> darcs as tarball, deb, gentoo, freebsd
07:02:17 <shapr> gutentag cm_
07:02:35 <shapr> Igloo: what sort of stuff would that allow? access to GHC parse trees?
07:02:50 <ski> shapr : is both client and server in that ?
07:03:07 <Igloo> Well, it's presumably being done as part of the VS integration
07:03:11 <cm_> shapr :)
07:03:38 <shapr> I wonder if the various GHCi plugins for lambdabot would have any useful code or ideas for the VS integration guys.
07:04:05 <Igloo> So I'd guess types first of all, but possibly also more semantic information for variable completion and refactoring tools
07:04:15 <shapr> ski: yes, it's all in there
07:04:15 <phubuh> that's awesome
07:04:32 * phubuh dreams of Emacs integration
07:04:48 <shapr> ski: you need apache to allow other people to pull patches from your repo
07:06:08 <Darius> Likely people working on dynamic loaders would want module dependency information.
07:06:33 <ski> shapr : i haven't considered starting a repo myself :)
07:07:14 <ski> shapr : or is that required ?
07:12:24 <ski> shapr : mm ?
07:17:18 <xkb> Hi.. is it possible to throw exceptions that are other than strings?
07:19:37 <ham[kell]> x/0/y is that a division by 0?
07:19:50 <ski> see DynException @ http://www.haskell.org/ghc/docs/6.2/html/libraries/base/Control.Exception.html
07:20:09 <ham[kell]> since x/(0/y) = (x/0)/y and the letter is div0 right?
07:20:19 <xkb> ski Thanks
07:21:17 <ski> in haskell x/0/y means (x/0)/y
07:21:54 <Igloo> You can also use an error monad or the ErrorT monad transformer
07:23:17 <Igloo> It's division by zero either way for traditional types
07:23:40 <ham[kell]> thanks
07:24:09 <phubuh> either way it's evaluated it's a division by zero, since 0/y == 0
07:24:17 <ham[kell]> yep
07:24:24 <ham[kell]> someone claims that mathlab evals that
07:24:36 <xkb> Is Control.Exception based on the design by SPJ? The one he wrote a paper of?
07:24:36 <ham[kell]> plot(X,sin(F/(2*pi)*X*T/P))
07:24:47 <ham[kell]> with x = 0 .. P
07:27:49 <earthy> ErrorT monad transformer?
07:29:18 <earthy> hm. reading material
07:29:23 * earthy off consuming
07:30:37 <xkb> :)
07:39:20 * shapr boings
07:39:41 <shapr> ski: still there?
07:54:08 <earthy> time to go home
07:59:31 <shapr> Darius: you busy?
07:59:45 <shapr> I'm wondering about the template haskell @ghci workaround you found
08:00:47 <shapr> I was wondering if you could make a truly type-safe runtime loader by running the whole program in the Template Haskell compilation loop.
08:13:22 <shapr> y0 SamB 
08:13:23 <shapr> wazzup?
09:02:42 --- mode: jordan.freenode.net set +b *!*@206.169.168.190
09:17:26 <ski> @arr
09:17:27 <lambdabot> I'll keel haul ya fer that!
09:18:34 <shapr> @arr
09:18:35 <lambdabot> Aye
09:21:53 <SyntaxNinja> is this function defined anywhere:allOf :: (Enum a, Bounded a) => [a]
09:21:53 <SyntaxNinja> allOf = enumFrom minBound
09:23:20 <Igloo> [minBound..] or [minBound..maxBound] is arguably nicer
09:23:25 <Igloo> I don't think it has a name, though
09:23:41 <ski> could perhaps be called domain
09:24:14 <SamB> somebody really needs to come up with a search-by-unification tool...
09:24:24 <Igloo> allOf is a poor name IMO because it looks like it should take an argument (allOf xs). all would be better except it already exists
09:24:49 * Igloo can't think of anything better than domain
09:25:01 <SamB> enumInBounds ?
09:25:13 <ski> dunno if elements or inhabitants is better
09:25:46 <ski> perhaps there should be a class for this
09:26:56 <SamB> ski: why? its not like enumFrom minBound is going to be inefficient 
09:27:13 <ski> hm
09:27:39 <ski> what about Integer
09:28:06 <ski> or some bigint Natural thingy
09:28:26 <SamB> that isn't Bounded, is it?
09:28:35 <ski> it isn't
09:29:00 <SamB> oh, I see what you are getting at...
09:29:30 <ski> perhaps we'd like to use diagonalizing for (a,b)  (at least if both a and b are infinite)
09:30:28 <ski> so the class should probably contain some info re the type is (countable, of course) infinite or finite
09:30:29 <SamB> I think it would probably be better to just use .. for infinite ranges...
09:30:55 <ski> [..] ?
09:30:58 <ski> :)
09:31:40 <ski> do you mean [minBound..] ?
09:31:41 <SamB> no, I mean that it would be better to use it the normal way, rather than add lots special cases...
09:32:16 <SamB> the "no" referring to your "[..]"
09:32:18 <ski> use what ?  and what's the normal way ?          (sorry, lost you)
09:34:20 <SamB> possibly infinite enumerations are a different beast from finite enumerations, thats all.
09:34:27 <ski> ok
09:34:30 <ski> mm
10:10:39 <shapr> ha, haskell in the news: http://builder.com.com/5100-6375-5136747.html
10:11:37 <phubuh> I wound up with a job working on the Glasgow Haskell Compiler (GHC), which is a fabulous compiler for a fabulous programming language </shameless plug>
10:11:39 <Maddas> cool
10:11:39 <phubuh> hee hee!
10:11:51 <Maddas> phubuh: haha
10:12:42 <shapr> He also talks a bit about Haskell on the next page.
10:13:35 <phubuh> Valgrind is only useful because C and C++ are such crappy programming languages.
10:13:39 <phubuh> hee hee
10:14:01 <Maddas> heh, "Around that time we got a cat and named him Heimdall instead.
10:14:02 <Maddas>  
10:16:07 <shapr> I wonder if hugs has been valground
10:16:16 <Maddas> Valgrind sounds very useful
10:16:28 <phubuh> yeah, it is
10:16:32 <shapr> I think cachegrind is its sibling app
10:16:55 <phubuh> actually, kcachegrind is built upon valgrind
10:17:16 <ecraven> if a lambda expression binds an identifier, is it bounded or bound?
10:17:19 <shapr> oh, I didn't know that.
10:17:25 <phubuh> the executable called "valgrind" uses Valgrind to analyze memory errors
10:17:39 <phubuh> the executable called "kcachegrind" uses Valgrind to analyze cache hits/misses
10:17:41 <phubuh> (I think)
10:18:54 <ski> 'valground' looks weird
10:19:07 <ski> ecraven : bound, i'd say
10:19:28 <phubuh> yeah, bound
10:19:46 <shapr> bounded means it has edges
10:19:53 <shapr> bound means it's attached to something
10:20:52 * shapr valgrinds GHC
10:29:57 <ski> hmm, if a function uses unsafePerformIO to change some state but it's result doesn't depend on the state, would that be impure ?
10:30:40 <whiskas> Hello.
10:30:46 <ski> hi whiskas
10:30:49 <shapr> y0 whiskas 
10:30:57 <phubuh> I don't think it would be pure, but I think it would be referentially transparent
10:31:09 <shapr> the only errors valgrind found so far are in /lib/ld-2.3.2.so
10:32:40 <ski> phubuh : mhmm. (reading Peter Van Roy on modularity through state)
10:32:43 * shapr smacks himself
10:33:51 <whiskas> shapr: Was that good?
10:33:52 <Maddas> Whatever turns you on! *grin*
10:33:56 <whiskas> :-)
10:34:07 <shapr> whiskas: what what good?
10:34:20 <whiskas> Smacking yourself :-P
10:34:33 <shapr> I deserved it.
10:34:40 <shapr> hm, lambdabot won't start now.
10:35:34 <ski> why ?
10:35:43 <shapr> I don't know.
10:35:56 <shapr> aha
10:36:07 <whiskas> Was that a lightbulb?
10:36:11 <whiskas> Yes, it was :-)
10:36:21 <ski> lambdabot : @hello
10:36:32 <ski> lambdabot: @hello
10:36:33 <lambdabot> Hello world. 
10:36:39 <shapr> @listmodules
10:36:39 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
10:37:03 <whiskas> shapr: That looks alot like rubot.
10:38:04 <shapr> what's rubot? ruby bot I assume?
10:38:18 <whiskas> Yup.
10:38:35 <whiskas> @state
10:38:36 <lambdabot> nothing yet
10:38:40 <whiskas> @topic
10:38:41 <lambdabot> Sorry, I don't know the command "topic", try "lambdabot: @listcommands"
10:38:45 <whiskas> Hmm.
10:39:18 <shapr> so far, valgrind has found nothing wrong with ghc or the binaries it produces.
10:39:34 <shapr> this could be because the author of valgrind wrote part of GHC, who knows.
10:39:46 <whiskas> :-))
10:41:56 <shapr> ok, I've tried everything but the cache miss checker. I suspect ghc doesn't fit much into the cache.
11:20:34 <ham[kell]> http://codemages.sf.net/homotopy1.hs :)
11:20:48 <Darius> Who doesn't know what Valgrind is?
11:20:55 <Darius> Or at least the general ballpark?
11:21:05 <ski> the pope ?
11:21:53 * ski 's just joking
11:23:52 <shapr> ham[kell]: neat
11:24:10 <ham[kell]> i think i may try to make a small demo :)
11:24:29 <ham[kell]> first thing is that the ham[kell] morphs to has[kell] :)
11:24:37 <ham[kell]> ham[kell] has kell :))
11:25:09 <ski> has[kell] has kell !
11:25:31 * shapr grins
11:25:43 * ham[kell] have kell :)
11:25:44 <Maddas> humpty dumpty sat on a wall
11:25:50 * Maddas hops away
11:37:39 <ski> um, why does mozilla say that a bookmark folder has "-1 object(s)" ?
12:05:39 * shapr boings furiously
12:06:10 <shapr> SyntaxNinja: any decision on ITP'ing darcs?
12:09:39 <shapr> so, any recent news in the world of Haskell?
12:23:00 <SyntaxNinja> shapr: well, the darcs upstream wants the debian stuff hosted in darcs, so I asked david r. if he would host the public repository and he hasn't gotten back to me.
12:23:24 <SyntaxNinja> i didn't feel like hosting a public repository for just that, but OTOH, maybe I'll use darcs to host all of my debian changes or something
12:23:39 <SyntaxNinja> i don't keep that stuff in version control, but maybe I should
12:32:04 <shapr> I can host a darcs repo if you want.
12:38:00 <shapr> SyntaxNinja: want me to pull a copy of the canonical darcs repo onto ScannedInAvian?
12:39:51 <ecraven> is there any reason not to learn haskell if i want a pure functional language?
12:40:06 <Maddas> ecraven: You might become addicted
12:40:10 <SyntaxNinja> shapr: maybe, not yet :)
12:40:20 <shapr> ok
12:40:23 <SyntaxNinja> ecraven: I don't know if there's ever a reason not to learn haskell :)
12:40:46 <shapr> I think addiction is the primary risk.
12:41:03 <ecraven> :) i've done a bit of clean, and i love scheme.. so i'll do some haskell before trying to do a scheme interpreter ;)
12:41:18 <Maddas> monadic parser combinations sound fun
12:41:34 <shapr> monadic parsers are *spiffy* have you read the paper?
12:42:51 <Maddas> No, I just read that they are spiffy :-)
12:43:05 <Maddas> I just started with the monad tutorial on nomaware.com
12:43:18 <Maddas> So I don't feel quite ready for a paper yet.
12:43:39 <ecraven> i'd like haskell with scheme's syntax :)
12:43:47 <shapr> many of the academic papers are flat out fun to read.
12:44:28 <SyntaxNinja> ecraven: haskell syntax is pretty great actually
12:44:31 <Matt-W> argh!
12:44:34 <shapr> Matt-W: yes?
12:44:38 <Maddas> shapr: if you understand them, I bet :)
12:44:39 <shapr> oh wait, that's not my name.
12:45:25 <Matt-W> shapr: haskell with scheme's syntax
12:45:28 <Matt-W> horrible thought
12:46:09 <shapr> diffrent strokes and all..
12:46:20 <Matt-W> I suppose
12:46:22 <shapr> Ashley Yakeley uses the brace and semicolon syntax of Haskell exclusively.
12:46:39 <ski> Maddas : you can read some of them without understanding all of them. that's how i learned what i know about type theory, e.g.
12:46:43 <shapr> Daan likes it for parts of Parsec
12:47:08 <shapr> Maddas: yes, I started reading academic papers by accident long ago when I was working in a library.
12:47:29 <Maddas> shapr: eh, heh, sounds like a weird way to stumble across them :-)
12:47:41 <shapr> writing academic papers yourself isn't that hard, just takes practice, like anything.
12:47:55 <Maddas> And you need something to write about
12:48:03 <shapr> oh there's *lots* to write about
12:48:14 <Maddas> ok, something you know about :-)
12:48:31 <shapr> sure, but if you've gotten this far into programming, you already know about lots of stuff
12:49:01 <Maddas> shapr: heh, so one would think. ;-)
12:49:08 <ski> Maddas : first time i saw an inferencing rule for type systems i though it was some weird analog/extension of division :)
12:49:42 <shapr> bonjour fanou 
12:50:02 <shapr> :-P
12:50:04 <Maddas> shapr: I know a little bit about a lot, but there's nothing (programming-wise) I know a lot about
12:50:08 <Maddas> haha
12:50:21 <shapr> bonjour?
12:50:35 <fanou> shapr: hellow
12:50:37 <fanou> -w
12:50:40 <shapr> hi!
12:51:00 <shapr> have you gotten into Haskell far enough to have questions?
12:51:23 <fanou> shapr: yes
12:51:37 <shapr> ok! what are those questions?
12:51:50 <fanou> shapr: =)
12:52:37 <fanou> shapr: well ...actually i read the tutorial
12:52:49 <fanou> shapr: and this week end i wanted to study it more deeply
12:53:08 <shapr> sounds good
12:53:13 <fanou> shapr: for the moment i got no question, well no "interesting" questions to ask you, sorry
12:53:28 <shapr> ok, if you think of some, feel free to ask me.
12:53:55 <fanou> shapr: thank you :)
12:54:01 <shapr> :)
12:54:03 <ski> me me !
12:54:09 <ski> :)
12:54:17 * shapr skis
12:54:27 <shapr> yes, ski is a good answer man
12:54:47 * ski shaprens something
12:54:52 <Maddas> heh. Sounds like a fitting job description, answer man. :-)
12:55:05 <ham[kell]> http://codemages.sf.net/homotopy1.hs
12:55:10 <ham[kell]> the full morph :)
12:55:23 <ham[kell]> though the alphabet is a pick er shitty :)
12:55:37 <ham[kell]> but you can concat spline letters now and morph the words
13:02:55 <Maddas> hm, monadic bind (>>=) reminds me of Perl 6's pipe operator (==> and <==)
13:03:07 <shapr> what does pipe do?
13:03:24 <Maddas> hook together list generators with list consumers, to quote the apocalypse
13:03:34 <Maddas> 1,2,3 ==> stuff @foo
13:03:48 <shapr> sounds like the compose operator
13:03:52 <shapr> hej andre
13:03:57 <Maddas> The compose operator?
13:04:03 <Maddas> Do you mean <-?
13:04:06 <shapr> er just .
13:04:10 <Maddas> oh, duh.
13:04:12 <shapr> @type (.)
13:04:13 <lambdabot> (.) :: (a -> b) -> (c -> a) -> c -> b
13:04:19 <Maddas> Yeah, I used it already
13:04:27 <andre> hey shapr :-)
13:04:34 <shapr> ham[kell]: I only see an S on the screen, is that correct?
13:04:49 <Maddas> It reminded me of monads passing around things with >>= though 
13:04:52 <Maddas> Is that very far-fetched?
13:04:53 <ham[kell]> shapr ?
13:05:02 <ham[kell]> sec thats kinda wrong
13:05:26 <shapr> andre: learning Haskell?
13:05:42 <ham[kell]> shapr got the newest version?
13:05:47 <shapr> I think so, lemme check
13:05:58 <shapr> oh, duh
13:06:01 <ham[kell]> i just updatet
13:06:11 <shapr> wget made homotopy.hs.1
13:06:11 <andre> shapr : yes, have been reading and coding all day
13:06:19 <ham[kell]> i will now write a function String -> splineword :)
13:06:29 <shapr> andre: have some questions?
13:07:12 <shapr> ham[kell]: oh, that's neat!
13:07:23 <andre> nothing that i can think of right now, but ill be sure to ask when something hard comes along :)
13:07:43 <shapr> hamkell morphs into haskell
13:07:45 <ham[kell]> shapr if i had more letters i could morph whole sentences :)
13:08:05 <shapr> how do you get your letters?
13:08:34 <ham[kell]> i have splines for each letter
13:08:39 <shapr> oh
13:08:46 <ham[kell]> and they are setup by lists of points
13:08:58 <ham[kell]> and to form a word i just concat the lists by ++
13:09:06 <ham[kell]> and then build a spline over the new list
13:09:39 <shapr> spline fonts.. interesting.
13:09:46 <ham[kell]> :)
13:09:57 <ham[kell]> and you can already scale them
13:10:01 <ham[kell]> and move them around
13:10:45 <shapr> I admit, I wanted to grab that string with my mouse and pull on it, then watch it snap back.
13:11:14 <ham[kell]> :)
13:11:42 <ham[kell]> hm i could use something like that to build letters
13:12:06 <ham[kell]> oh and now i will write a function that makes the words bend around :)
13:14:03 <shapr> oooh
13:14:23 <shapr> gee, now I want hasklets.
13:14:54 <ham[kell]> hasklets?
13:14:55 <Riastradh> Hasklets?
13:14:58 <ham[kell]> heh
13:15:10 <Maddas> Haskell servlets?
13:15:32 <shapr> well, some way to run small haskell programs in my browser
13:17:05 <ski> wasn't there some browser written with fudgets that had such things ?
13:17:13 <shapr> that sounds familiar
13:17:43 <shapr> yes - http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html
13:17:45 <shapr> bottom of the page
13:17:58 <ski> (and didn't someone, perhaps a couple of days ago, ask about browsers in haskell ?)
13:18:04 <shapr> yes, they did
13:18:23 <shapr> I wonder if it's been updated since 1994
13:19:26 <ecraven> is the integer type called Int or Integer?
13:19:36 <ski> Integer
13:19:51 <ecraven> why does the gentle introduction mention Int?
13:19:58 <ski> Int is integer modulo some non-negative integer n
13:20:15 <ecraven> ah, tx
13:20:27 <phubuh> Integer is an arbitrarily large integer, Int is something that fits in a machine int
13:20:40 <ecraven> ah, ok
13:20:48 <ski> (often a power of 2, e.g. 2^29 or something)
13:21:11 <ecraven> 2^32 seems obvious ;)
13:21:39 <ski> not neccesarily with GC
13:22:14 <Riastradh> There are typically a few type bits.
13:22:55 <ecraven> in haskell? what for?
13:23:00 * ski never remembers how the nesccse.. word is spelt :(
13:23:03 <Riastradh> ...oh, right.
13:23:24 <phubuh> necessarily
13:23:28 <ecraven> hm.. if : were left associative, i would have lists that let me append to their end, right?
13:23:33 <ski> phubuh : thanks
13:23:42 <Riastradh> ecraven, no, you'd have type problems.
13:24:04 <phubuh> you already have lists that let you append to their end
13:24:09 <phubuh> @type (++)
13:24:09 <lambdabot> (++) :: [a] -> [a] -> [a]
13:24:13 <ecraven> why can't i do []:1:2:3
13:24:40 <phubuh> because 1, 2, and 3 aren't lists, and : expects a list as its second argument
13:24:43 <phubuh> @type (:)
13:24:43 <lambdabot> (:) :: a -> [a] -> [a]
13:24:46 <ecraven> phubuh: i mean append in O(1)
13:24:50 <phubuh> oh
13:24:55 <Maddas> You can't
13:25:00 <ecraven> i meant i'd write another operator..
13:25:01 <Maddas> I just read about that before :-)
13:25:09 <ecraven> call it {} and ;
13:25:11 <Maddas> ecraven: It won't work with normal lists
13:25:13 * Maddas looks for the page
13:25:13 <Riastradh> Append in O(1) is impossible without _both_ destructive update and all lists keeping references to their last cons cells.
13:25:26 <ecraven> ((({};1);2);3)
13:26:00 <Riastradh> Then fetching the first element of a list would take O(n) time.
13:26:05 <ecraven> yes ;)
13:26:07 <Riastradh> Why not just build up your lists in reverse?
13:26:32 <ecraven> i was just wondering.. ;)
13:26:59 <Maddas> ecraven: http://haskell.org/hawiki/ListMutation :)
13:27:56 <det> Riastradh: or using a structure other than a list!
13:29:08 <Riastradh> det, you still won't get append in O(1).
13:30:45 <det> data Tsil a = Lin | Snoc (Tsil a) a 
13:30:54 <ecraven> appending on both sides without mutation should be impossible in O(1), right?
13:31:22 <phubuh> yes
13:31:48 <ski> data Listsil a = Nilin | Cons a (Listsil a) | Snoc (Listsil a) a
13:32:19 <ski> but that isn't usually seen as a list
13:40:48 <ecraven> the gentle introduction says a->a is a correct typing for head.. is this true?
13:41:06 <ski> re ghc : is .hc files used for hand-written code to interface with .hs (or something) or does ghc internally generate .hc from .hs when compiling (prolly -fvia-C ?)
13:41:19 <ski> ecraven : no !
13:41:32 <ecraven> that's what i thought..
13:41:41 <ski> @type head
13:41:41 <lambdabot> head :: [a] -> a
13:41:41 <ecraven> [b] -> a would be ok, but too general..
13:43:29 <ski> (re ghc : retract that. doc says it's intermediate)
13:44:02 <shapr> and .hi is the interface
13:44:08 <ecraven> wee, i can really write [a] as []a ?? cool
13:44:39 <ski> i would prolly put a space in between
13:44:56 <shapr> right, because future language changes can do strange things otherwise
13:45:11 <ski> could they ?
13:45:12 <shapr> the addition of template haskell changed $ for example
13:45:36 <Riastradh> Bah!  Syntax!
13:45:42 <ski> :)
13:45:43 <shapr> yah, suddenly $(foo) didn't mean the same thing
13:46:05 <ecraven> so [] is basically two things? type constructor for lists and empty list?
13:46:27 <ski> yes, but in different syntactic categories
13:47:08 <ski> (hmm, does cayenne have built-in list syntax ? ..)
13:48:16 <ecraven> syntactic categorie ~=~ namespace?
13:48:47 <ski> no
13:49:29 <ski> expression is a synt. category, types is another
13:52:35 <Darius> Namespace is a perfectly fine way of thinking about it.
13:53:18 <ski> but can't one have multiple namespaces in a synt. cat. ?
13:53:33 <ski> or none (if it hasn't got names)
13:54:35 <Darius> Let me be clearer, different namespaces is a perfectly fine way of thinking about the original issue.
13:54:51 <ski> ok
13:54:55 <ecraven> ski: ski like the combinators?
13:55:30 <ski> ecraven : yes, ski likes the combinators                ;)
13:56:02 <ecraven> cool ;)
13:58:10 <Darius> @eval S (S K I) (S K I) (S (S K I) (S K I))
13:58:30 <lambdabot> out of fuel - use @resume to continue
14:00:50 <Riastradh> @resume
14:01:03 <Riastradh> @yow
14:01:09 <lambdabot> out of fuel - use @resume to continue
14:01:09 <lambdabot> Okay..  I'm going home to write the ``I HATE RUBIK's CUBE
14:01:09 <lambdabot>  HANDBOOK FOR DEAD CAT LOVERS''..
14:01:31 <shapr> hello psymaster 
14:01:42 <shapr> looking for Haskell info?
14:01:44 <ski> Darius : 's that Omega ?
14:05:02 <Darius> ski: What it isn't obvious?
14:05:52 <ski> i thought it was, but i'm not so fast at de-ski-ing in head
14:06:29 <Riastradh> How silly that you used I there.
14:06:55 <ski> Riastradh : how so ?
14:07:06 <Riastradh> You ought use S or K instead and not use (S K I) where I would have been sufficient.
14:07:13 <Riastradh> @eval S I I (S I I)
14:07:20 <Darius> ski: You could be -really- clever and say your name is an indirect meta-reference like "Pseudonym" but much more clever.
14:07:27 <lambdabot> out of fuel - use @resume to continue
14:07:38 <Riastradh> @eval S (S K S) (S K S) (S (S K S) (S K S))
14:07:57 <lambdabot> out of fuel - use @resume to continue
14:08:01 <ski> Riastradh : ok, i see
14:08:02 <Riastradh> @eval I 5
14:08:02 <lambdabot> 5
14:08:05 <Riastradh> @eval (S K I) 5
14:08:06 <lambdabot> 5
14:08:10 <Riastradh> @eval (S K S) 5
14:08:10 <lambdabot> 5
14:08:13 <Riastradh> @eval (S K K) 5
14:08:13 <lambdabot> 5
14:08:16 <Darius> @eval S K (S I I (S I I)) 3
14:08:16 <lambdabot> 3
14:08:32 <ski> @eval (S K "ski") 945
14:08:36 <lambdabot> 945
14:08:37 <Riastradh> @eval S K FROBOZZ 3
14:08:37 <lambdabot> 3
14:08:50 <ecraven> why does this not work as expected:
14:08:50 <ecraven> quicksort (x:xs) = (quicksort [y | y<-xs, y<x]) ++
14:08:50 <ecraven> 		   [y | y<-xs, y==x] ++
14:08:51 <ecraven> 		   (quicksort [y | y<-xs, y>x])
14:08:52 <Riastradh> @eval S K THISISSURELYUNDEFINED 3
14:08:52 <lambdabot> 3
14:09:00 <ecraven> sorry about the tabs
14:09:09 <ski> @eval (S K (S I I (S I I))) 276
14:09:10 <lambdabot> 276
14:09:31 <Darius> ecraven: what is expected and how is it not meeting it?
14:10:08 <ecraven> applied to [4,3,7,2,2,1] it only returns [2]
14:10:28 <ski> heh
14:10:31 <ski> i see it
14:10:38 <ski> um
14:10:39 <ecraven> if i change the middle line to [x] and in the last line put y>=x instead of y>x it works..
14:11:29 <Darius> You've already removed the element you are filtering from the list so it (usually) isn't there to be filtered.
14:12:06 <ecraven> ?
14:12:23 <Darius> try it on [2,2,1]
14:12:37 <ski> what's quicksort [3,2,1]
14:12:45 <ecraven> got it, thanks! :)
14:12:58 <ecraven> (x:[y | y<- ..])++ works
14:13:03 <ecraven> sorry for disturbing ;)
14:13:19 <ski> ecraven : you don't need parens
14:13:57 <ecraven> i'm used to them :) scheme..
14:16:30 <ski> @eval decaySequence 12
14:16:32 <lambdabot> [12, 16, 15, 9, 4, 3, 1, 0]
14:16:47 <ski> @eval decaySequence 945
14:16:54 * shapr smells smoke
14:17:05 <lambdabot> out of fuel - use @resume to continue
14:17:08 <shapr> whew
14:17:10 <ski> @resume
14:17:27 <lambdabot> out of fuel - use @resume to continue
14:17:31 <ski> shapr : stove on fire ?
14:17:39 <shapr> nah, lambdabot  ;-)
14:17:58 <ski> i think this should converge
14:18:10 <ski> don't recall how long it was though
14:18:53 <ski> btw 945 is the first odd number that decays upward (beta-decay)
14:20:09 <ski> @eval decaySequence 945
14:20:25 <lambdabot> out of fuel - use @resume to continue
14:20:26 <ski> @resume
14:20:44 <lambdabot> out of fuel - use @resume to continue
14:20:45 <ski> @resume
14:20:52 <lambdabot> [945, 975, 761, 1, 0]
14:20:56 <ski> yes !
14:21:40 <shapr> what's beta-decay?
14:22:00 <shapr> @get-definition decaySequence
14:22:01 <lambdabot> decaySequence = \n.n : unfoldr (\n.if n == 0 then Nothing else (\m.Just (Pair m m)) (decay n)) n
14:22:01 <ski> @eval take 10 (decaySequence 25)
14:22:03 <lambdabot> [25, 6, 6, 6, 6, 6, 6, 6, 6, 6]
14:22:13 <shapr> @get-definition decay
14:22:13 <lambdabot> decay = \n.sum (factors n) - n
14:22:26 <shapr> that's neat
14:22:38 <ski> @eval take 10 (decaySequence 220)
14:22:55 <lambdabot> out of fuel - use @resume to continue
14:22:57 <ski> @resume
14:23:15 <lambdabot> out of fuel - use @resume to continue
14:23:15 <ski> @resume
14:23:16 <lambdabot> [220, 284, 220, 284, 220, 284, 220, 284, 220, 284]
14:23:33 <ski> that's the first pair of amicable numbers :)
14:23:42 <shapr> nifty trix
14:24:44 <ski> supposedly known already by the Jacob in Tanach ([Genesis..Deuteronomy])
14:25:07 <shapr> hm, neat
14:25:40 <ski> @eval take 6 (decaySequence 12496)
14:25:56 <lambdabot> out of fuel - use @resume to continue
14:25:58 <ski> @resume
14:26:16 <lambdabot> out of fuel - use @resume to continue
14:26:17 <ski> @resume
14:26:34 <lambdabot> out of fuel - use @resume to continue
14:26:36 <ski> @resume
14:26:54 <lambdabot> out of fuel - use @resume to continue
14:26:56 <ski> @resume
14:27:13 <lambdabot> out of fuel - use @resume to continue
14:27:14 <ski> @resume
14:27:34 <lambdabot> out of fuel - use @resume to continue
14:27:35 <ski> @resume
14:27:53 <lambdabot> out of fuel - use @resume to continue
14:27:54 <ski> @resume
14:28:12 <lambdabot> out of fuel - use @resume to continue
14:28:14 <ski> @resume
14:28:31 <lambdabot> out of fuel - use @resume to continue
14:28:32 <ski> @resume
14:28:50 <lambdabot> out of fuel - use @resume to continue
14:28:50 <ski> @resume
14:29:08 <lambdabot> out of fuel - use @resume to continue
14:29:10 <ski> @resume
14:29:33 <lambdabot> out of fuel - use @resume to continue
14:29:33 <ski> @resume
14:29:39 <Igloo> Is this necessary?
14:29:51 <lambdabot> out of fuel - use @resume to continue
14:30:05 <ski> well, the result is interesting
14:30:08 <ski> @resume
14:30:26 <lambdabot> out of fuel - use @resume to continue
14:30:27 <ski> @resume
14:30:44 <Darius> you can message the 'bot
14:30:46 <lambdabot> out of fuel - use @resume to continue
14:30:52 <ski> @resume
14:30:52 * shapr thinks that's a hint ;-)
14:31:10 <lambdabot> out of fuel - use @resume to continue
14:31:47 <ski> Darius : will it reply the answer publically or not, then ?
14:31:50 <Igloo> Or you could compile code to do it, run it in a fraction of the time and tell us the answer  :-)
14:32:11 <ski> what would be the fun of that                                   ;)
14:40:46 <ski> shapr : beta-decay is when the resulting number is larger
14:41:02 <ski> alfa is downwards
14:41:32 <ski> (dunno if this is widespread terminology, or just my elder bro' invented it)
14:48:32 <ham[kell]> why are the haskell programs so big when compiled?
14:51:16 <Darius> GHC programs are big, not Haskell programs.
14:51:46 <Darius> And I believe GHC statically links quite a bit, certainly the runtime.
14:51:51 <Darius> and have you stripped the executable/
14:52:17 <ham[kell]> stripped ? how do i do that?
14:52:37 <Igloo> The standard libraries too
14:52:54 <phubuh> can you tell GHC to link stuff dynamically?
14:52:58 <Riastradh> _All_ of them??
14:52:58 <Igloo> strip whatever, under Linux at least
14:53:17 <Igloo> The bits of the ones you use. That's why it does the object splitting
15:11:48 <shapr> lambdabot is half the size after stripping.
15:12:04 <shapr> does -split-objs work in linux?
15:14:04 <shapr> seems not
15:14:12 <Igloo> ?
15:14:19 <Igloo> With x86 Linux, among others, it should
15:14:33 <Igloo> You'll need to use -fvia-c I think
15:15:37 <shapr> oh, I was using --split-objs
15:18:53 * SamB thinks correcting CiteSeer entries is kind of fun
15:21:48 <ski> well, the answer is [12496,14288,15472,14536,14264,12496]
15:22:41 <ski> so 12496 is a member of a 5-cycle
15:23:06 <ski> hi esap
15:26:13 <esap> hi
15:26:37 <ski> reading your reply now..
15:26:55 <esap> which reply?
15:27:05 <ski> on hawiki
15:27:58 <esap> you mean the MessageDispatching one?
15:28:02 <ski> mm
15:28:38 <ski> do you include state in your "data as a resource" ?
15:29:40 <esap> Well state is a resource.
15:29:57 <esap> or rather, a storage for storing state is a resource
15:30:14 <ski> but imperative implicit state ?
15:30:28 <esap> well it doesn't matter if it's implicit or not.
15:30:36 <esap> but yes, it includes that.
15:31:45 * SamB just linked a document with seven citations ;-)
15:31:56 <ski> hmm, what do you mean by "aggregation hierarchy" ?
15:34:08 <esap> well the UML concept of aggregation/composition. A hierarchy of those is just a tree whose links are the 'part of' relationship.
15:34:49 <ski> i don't get it. example ??
15:36:07 <esap> well in Haskell it's easy: data X = X (Maybe Integer). Now obviously, a value of type X _contains_ a value of type Maybe Integer. A value of type Maybe Integer contains [perhaps] a value of type Integer. That 'hierarchy' is just linear.
15:36:49 <ski> mm, ok. an AND/OR tree then ?
15:37:37 <esap> well the aggregation relationship is an acyclic relationship where each link represents "A contains B" or "B is-part-of A".
15:37:57 <ski> ok
15:38:16 <ski> hm
15:39:12 <ski> and in DAR, can't objects contain (refs to) other objs ?
15:39:45 <ski> (DAR = 'data as resource')
15:40:00 <esap> yes, but references do not produce aggregation relationships.
15:40:18 <esap> because you can form a loop with references.
15:40:22 <ski> hmm, C++ style contains ?
15:40:26 <esap> yes
15:41:28 <ski> i'm not sure i get why this is relevant for coalgebras
15:42:04 <esap> destructors associated with coalgebras are the same as methods in OO.
15:42:10 <ski> yes
15:42:15 <ski> agreed
15:42:38 <ski> and the same as selectors for records, no ?
15:43:10 <ski> (ignoring implicit state, here)
15:43:21 <esap> yes
15:43:55 <ski> so what is your diff between records and coalgebras ?
15:44:24 <esap> you can create a record from any data, but a coalgbra enforces invariants that must hold before you can construct it.
15:44:41 <ski> invariants ?
15:44:59 <ski> what's the invariant for Stream ?
15:45:33 <ski> (e.g.)
15:45:49 <esap> the invariant for stream is that you can always take 'tail' of the stream.
15:45:54 <esap> and head as well.
15:46:43 <ski> but haven't we already our hands of these operators ?  the only invariant i see is in the type-system
15:46:44 <esap> so [1,2,3] is not a stream, because after three elements, you cannot take 'tail' any more.
15:46:53 <ski> mm
15:47:15 <esap> but let x = [1,2,3]++x in x is a stream.
15:47:47 <ski> but let Head (from n) = n; Tail (from n) = from (n+1) in from 0  is a stream
15:48:09 <esap> yes.
15:48:21 <ski> isn't that a list (possibly infinite)
15:48:47 <esap> well, there is a difference between a list and a stream. A list can be both infinite and finite. A stream can only be infinite.
15:49:01 <esap> Because a finite stream would not satisfy the invariant.
15:49:08 <ski> well, if you redefine to  (++) :: [a] -> Stream a -> Stream a  then i agree, of course
15:49:20 <ski> yes
15:49:38 <ski> "finite stream" ?  another type ! (?)
15:49:59 <esap> yes, but that is not a coalgebra, it's an algebra.
15:50:19 <ski> so i wouldn't call it XXX stream
15:50:31 <esap> right, it's a list.
15:51:36 <ski> we could of course imagine adding invariants to a coalgebra, just as we could to an algebra (e.g. group)
15:52:51 <ski> but i don't see any present in (the coalgebra) stream
15:54:10 <ski> (i'm trying to get what you mean)
15:54:17 <esap> any invariants? One invariant is: "for every instance of a stream, it's possible to use 'tail' and get another stream which satisfies the same invariant". In the invariant it's important that destructors _preserve_ the invariant.
15:54:45 <Darius> The invariants are structural and exist just as much for initial algebras.
15:57:17 <ski> "for every integer list, it is possible to use 'cons' on all pairs with any integer as first element and that list as second element and get another integer list which satisfies the same invariant"
15:57:44 <ski> Darius : well, as long as it's symmetrical
15:58:17 <esap> ski: exactly. But note that 'cons' is a constructor. That kind of condition would be associated with destructors for coalgebras.
15:58:29 <ski> yes, of course
15:59:19 <ski> i still don't get where you disagree ..
15:59:47 <esap> ok, the original point was that there are two ways to view data.
15:59:59 <esap> One is where you think of data as an interface.
16:00:31 <esap> So you can pass data through such interface, and that interface is useful for separating two different functions from each other.
16:00:52 <ski> (hmm, firstly i though you meant coalgebras by 'data as an interface'. that's what i thought was natural interpretation)
16:00:55 <esap> consider f . g. Here, you obviously pass data produced by g into f.
16:01:24 <esap> so the data can be thought of as an interface between f and g there.
16:01:33 <ski> esap : separating how ?  by non-unifyable types ?
16:01:42 <ski> mhmm
16:01:59 <ski> i guess so
16:02:38 <esap> like f :: B -> C and g :: A -> B.  Then B (the type) describes the structure of data that is passed from g to f. So 'B' is an interface between those two functions.
16:02:50 <ski> ok
16:03:33 <esap> ok, the "data as resource", in contrast has interfaces that look like Java interfaces, with methods named by something they _do_.
16:04:04 <ski> is that dependant on implicit state to work ?
16:04:04 <esap> there the data itself is "stored in the object" and thus can be considered as a resource that can be accessed via that interface.
16:05:24 <esap> In OO, objects _depend_ on each other, which means that one object uses another object's interface. The interface has similar function in the "data as resource" thing as the B in the above example between those two functions.
16:05:42 <ski> mhm
16:06:51 <ski> (given no imp. state) i think the object is similar to a record  (where some field often are functions)
16:06:53 <esap> but those are different, because one uses "data" as the interface, and the other uses "behaviour" as the interface. Very different.
16:07:44 <esap> You have to have dependencies between objects. Think of 'import', that's the same relationship.
16:08:10 <ski> are you thinking of (implementation) inheritance ??
16:09:04 <esap> well inheritance is also a dependency, so in a sense, yes.
16:09:36 <esap> but it's not the only kind of dependency.
16:09:59 <ski> well, i'm not (ATM) considering inheritance. (and if i were i probably also would consider it for algebras)
16:10:09 <ski> hmm
16:11:12 <esap> The aggregation hierarchy that I talked about is all about the dependencies.
16:11:48 <ski> hmm, you said the link should not be general refs
16:12:09 <ski> s/link/links/
16:12:21 <esap> right, because a reference does not necessarily create a dependency to the referred thing.
16:13:00 <ski> why, if you derefer along it, don't you depend on how it reacts ?
16:13:24 <ski> what's the kind of dependency you're after ?
16:13:26 <esap> but you can have a reference to an interface, and you can access the object behind the interface via that reference.
16:13:46 <esap> such reference only creates a dependency to the interface, but not to the referred object.
16:13:47 <ski> mustn't you have that ?
16:14:23 <ski> hmm
16:14:47 <ski> is this dep. similar to e.g. the DIP principle ?
16:14:50 <esap> yes.
16:15:14 <esap> exactly the same concept.
16:15:46 <ski> but in my mind a coalebra in e.g. in java is an interface (not a class)
16:16:04 <esap> an interface?
16:16:09 <ski> of course
16:16:18 <esap> I think the type of the coalgebra is the interface.
16:16:37 <ski> i think the type is the coalgebra
16:16:46 <ski> s/is/*is*/
16:17:02 <esap> ok, I think an _object_ is the coalgebra.
16:17:15 <ski> (well, perhaps we should add the deconstructors also)
16:18:12 <ski> so i guess you think like : [1,2,3] is an algebra, and [Int] is not
16:18:14 <ski> ?
16:19:31 <ski> not ?
16:20:26 <esap> well no, not exactly, I think it's more like you need both; the [Int] part describes the constraints associated with that object, and the [1,2,3] is the object itself. So the algebra is more like the way those two are related.
16:20:40 <ski> mhmm
16:21:49 <ski> (so [1,2,3] :: [Int] is an algebra ?)
16:21:59 <esap> no, I don't mean '::' would be an algebra :-)
16:22:39 <ski> (or exists t = [Int].[1,2,3] :: t ?)
16:23:03 <esap> I mean, consider class Algebra f a | a -> f where { create :: f a -> a }
16:23:12 <ski> i.e. "exists t = [Int].([1,2,3] :: t)"
16:23:47 <ski> mm
16:23:57 <ski> yes ?
16:24:18 <esap> the relationship between 'f' and 'a' in there is what I mean.
16:24:39 <ski> the Algebra relation
16:24:53 <esap> and values of type 'a' in that are the objects.
16:26:22 <esap> and 'f' describes the 'interface' to the algebra.
16:26:24 <ski> so there's just one Algebra relation, no ?  which ones are the algebras (plural) ?  each specific instance of that relation  (roughly corr. to fact in prolog or row in relational database)
16:26:42 <ski> ?
16:26:47 <ski> hm
16:27:30 <esap> there can be many instances of that class. But that is different from the objects [which have type 'a'].
16:27:41 <ski> yes
16:30:33 <esap> for coalgebras, the same is: class Coalgebra f a | a -> f where { destroy :: a -> f a }
16:30:41 <ski> (hmm, i would think of a coalgebraic datatype like "Stream Int" as similar to an interface im java (i.e. not fixing an implementation)
16:30:46 <ski> yes, agree
16:31:03 <esap> no, the 'Stream' part there is like an interface in Java.
16:31:10 <esap> but 'Stream Int' is not.
16:31:22 <ski> say "IntStream", then
16:31:47 <esap> Stream Int is more like a Java class.
16:32:00 <esap> it's a concrete data type.
16:32:06 <ski> head :: IntStream -> Int,tail :: IntStream -> IntStream
16:32:14 <ski> no, don't agree
16:32:37 <esap> no, you have something like: class Stream s where { head :: s -> Int ; tail :: s -> s }
16:32:38 <ski> a java class has a fixed implementation
16:32:42 <ski> (only one)
16:33:19 <esap> for an interface, you must have more than one possible implementation.
16:33:20 <ski> hm
16:33:26 <Darius> esap: Your algebra classes don't make sense.
16:33:34 <esap> darius: why?
16:33:55 <ski> Darius : perhaps f needs to be a functor ?
16:34:07 <esap> yes, of course.
16:35:09 <Darius> First, the functor is determined by the category, but fixing to just the category of Haskell values, there are several f a -> a functions that constitute algebras, e.g. several [Int] -> Int functions.
16:35:11 <ski> hmm, the Stream and IntStream i mentioned about were types
16:35:39 <ski> yes !
16:35:53 <esap> darius: but that's why 'a' has to determine 'f' uniquely.
16:36:05 <ski> hm
16:37:00 <Darius> esap: There are many instances of Algebra Int [] that are correct, the functional dependency doesn't even need to factor in.
16:37:22 <Darius> What you'd want is an initial algebra class that provided a fold function.
16:37:22 <ski> s/Int []/[] Int/
16:38:03 <Darius> Any function [Int] -> Int is an algebra for [] at Int.
16:38:14 <ski> hmm, is esap thinking of general algebras or just initial ones ?
16:38:29 <ski> (i'm thinking of the initial variety, i think)
16:38:33 <esap> darius: hmm.. actually, I'm not sure I might have algebras and coalgebras mixed up, because I can build unfold for the Algebra thing and fold for the coalgbera thing :-)
16:38:50 <ski> hmm ?
16:38:57 <Darius> If he's thinking general ones then a typeclass at all is too restrictive, if he's thinking initial ones the important thing is the fold function, that's what distinguishes it from any other algebra.
16:39:05 <esap> fold f = f . fmap (fold f) . destroy   and unfold f = create . fmap (unfold f) . f
16:39:24 <ski> Dariues : yes, just remembered that
16:39:52 <Darius> esap: Yes, that's the proof that the morphism part of the initial algebra is a isomorphism.
16:41:08 <esap> but together these and the type classes, doesn't this define initial algebras and final coalgebras?
16:41:34 <ski> esap : hmm, so really the -> in the classes should be ~== (i.e. isomorphic), but maybe we can be satisfied with the reversed direction (the unique thing of the (co)limits)
16:42:19 <Darius> The universal property of the initial algebra is the existence and uniqueness of a function fold f to any other algebra.
16:43:32 <ski> hmm, where does the reversability of the construction fit in ?
16:43:43 <Darius> reversability?
16:43:54 <ski> pattern-matching
16:44:34 <Darius> Be more specific.  An initial algebra doesn't provide pattern matching (directly though you can calculate it using fold).
16:44:55 <ski> you can't patternmatch on "a + b" e.g., but you can pattern-match on "x:xs" (and giving of course a case for [] simultanously)
16:45:14 <esap> I think you mean the thing that's in the instance declaration for those type classes.
16:45:33 <ski> yes, it should be reversible, i think
16:45:47 <Darius> ski: foldr encapsulates all the pattern-matching.  The "natural" way of processing lists viewed as algebras would be using foldr.
16:46:03 <Darius> You can define a caseList-like function in terms of foldr.
16:49:23 <ski> hmm
16:49:58 <ski> it's quite possible i've messed it up a bit in my memory
16:52:08 <ski> hmm at p 17 at http://citeseer.nj.nec.com/jacobs97tutorial.html they say that the construction : T(U) -> U is an iso
16:52:15 <esap> oh btw, I read the Hagino's thesis, and I think it's exactly the thing I've been looking for for some time :-)
16:52:55 <ski> esap : which is it ?
16:53:43 <ski> "A Categorical Programming Language" ?
16:53:46 <esap> yes
16:53:50 <Darius> ski: Yes it is, I said that above.
16:54:05 <Darius> Assuming you mean the morphism part of the initial algebra.
16:54:16 <Darius> (initial T-algebra)
16:54:21 <ski> Darius : wasn't that what it said (as well, then) ?
16:54:27 <ski> Darius : yes, initial
16:54:35 <Darius> Yes, I was agreeing.
16:55:14 <esap> actually, page 50 of Hagino's thesis explains exactly the concept I was talking about in the wiki page.
16:55:32 <Darius> ski: Proving it is easy.
16:55:44 <ski> Darius : but you meant/emphasized that the UMP is the iso of the fold. and the iso of the construction follows from that ???
16:56:27 <ski> esap : is it on web ?   (can't remember if i've looked at it before)
16:56:32 <Darius> No, the emphasis of the UMP is the -existence and uniqueness- of a function fold -f- for each other algebra f.
16:56:48 <Darius> Isomorphism is simply a consequence of the definition of algebra and initiality.
16:56:58 <Darius> (The isorphism)
16:57:10 <Darius> Well, that word was butchered.
16:57:18 <ski> Darius : hmm, sorry to confuse things up
16:57:41 <esap> ski: http://www.tom.sfc.keio.ac.jp/~hagino/index.html.en
16:58:55 <ski> esap : hmm, was it him who was related to charity ?
16:59:23 <esap> ski: I don't know.
17:00:40 <esap> ski: I think charity was made by uni of Calgary, Canada
17:01:28 <ski> esap : hmm, that seems to ring a bell
17:01:54 <ski> esap : still recognise 'hagino' name from somewhere
17:02:29 <esap> ski: yes, he's famous :-) He's written many good papers on category theory view to OO.
17:02:39 * esap remembers at least one :-)
17:08:15 <ski> hm, well, can't seem to find the paper
17:08:37 <esap> which one?
17:09:05 <esap> the thesis?
17:09:08 <ski> yes, exactly that ?
17:09:13 <ski> which one ?
17:09:26 <ski> don't think so
17:09:53 <ski> the paper where i recall his name from
17:10:05 <ski> (i think it was from some paper)
17:10:16 * esap guesses: Erik Poll's papers, he refers to Hagino, at least :-)
17:10:26 <ski> could well be..
17:11:11 * ski sometimes wonder how he can remember anything
17:11:55 <esap> heh, I once didn't remember the name of my boss after half a year of working for him :-)
17:12:08 <ski> :)
17:12:16 * ski grins
17:12:45 * esap doesn't remember non-essential things...
17:13:09 <ski> i don't remember how old i am. i have to recompute it each time, based on birth date and current date
17:13:33 <esap> but that's easy to forget, because it changes all the time...
17:13:36 <ski> is that weird ?
17:13:59 <ski> yes, exactly !  ;-)
17:15:15 <ski> well, guess i'll have another try at understanding your paragraphs
17:15:36 <Darius> esap: Another issue is fold :: Coalgebra f a => (f b -> b) -> a -> b doesn't make much sense as you wouldn't typically fold over an (infinite) stream and fold doesn't give a definition principle for coalgebra morphisms.
17:16:44 <ski> Darius : but if you reverse the arrows in the classes  (prolly more correct to change to the iso type) ?
17:17:56 <ski> Darius : because we have the construction for any algebra, but it's inverse just for initial ones      (is that correct ?)
17:18:06 <esap> darius: well I've thought it like this: the fold requires that the (f a -> a) [which is an algebra] also satisfies the Coalgebra rule to enforce that it's an initial one.
17:19:08 <ski> esap : is it both an algebra and a coalgebra ?
17:19:54 <esap> yes, what I thought of that is that to get an initial algebra, you have something that is an algebra and also satisfies _one_ way of getting a coalgebra from it
17:20:07 <Darius> How does "satisfying" the coalgebra rule make it initial?
17:20:09 <ski> hm
17:20:17 <esap> because coalgebra is dual to algebra.
17:20:23 <Darius> So?
17:20:53 <ski> esap : so what should the type of fold be ?
17:21:15 <esap> fold :: (Coalgebra f b) => (f a -> a) -> b -> a
17:21:26 <ski> that's feels weird to me
17:21:50 <ski> where does it say that it folds an (initial) algebra ?
17:21:58 <ski> hmm
17:22:33 <esap> it folds any algebra, as long as it also satisfies the coalgbra thing. But if I can write a fold for it, then why wouldn't it be an initial one? :-9
17:23:24 <ski> esap : hmm, perhaps you should rename Coalgebra to InitialAlgebra and destroy to unCreate, and mutatis mutandis
17:23:48 <Darius> Because it doesn't satisfy the uniqueness conditions.  But if you could write a fold, it still has little to do with coalgebras.
17:24:00 <ski> Darius : yes
17:24:01 <Darius> (necessarily satisfy)
17:24:37 <esap> yea, you may be right, I named those classes like that because of the type of create and destroy.
17:24:40 <ski> esap : is this better names ?
17:24:59 <ski> which gives you the wrong associations
17:25:02 <esap> ski: yes, probably.
17:25:06 <Darius> You don't want a create and destroy function.  -Every- function of the form f a -> a is an algebra.
17:25:17 <ski> yes
17:25:41 <ski> so the class InitialAlgebra would provide an inverse for create
17:26:09 <ski> Darius : is it interdefinable in the way i suggest ?
17:26:38 <Darius> No it should provide a function that takes another algebra (function from f b -> b) and provides a function a -> b such that the diagram for algebra morphisms commutes.
17:26:50 <ski> Darius : (it = algebra with fold  and  algebra with create iso)
17:27:37 <esap> darius: yes, fold does that.
17:27:50 <Darius> esap: Yes, that's the point.
17:28:06 <ski> Darius : what about to put both fold and unCreate in the class, and interdefine them with defaults.  would that work ?
17:28:16 <Darius> -That-, -fold-, is what needs to be provided to say "hey, I'm initial".
17:28:53 <esap> ok, I could define fold in the class as default.
17:29:46 <Darius> ski: With the structure that haskell provides I believe it would be fine.  But the fold usually encapsulates a recursion.
17:29:46 <ski> Darius : i'm wondering if there are more than one 'presentation' of the initial algebra concept, interdefinable.  (hmm, think of {map,unit,join} versus {unit,extend})
17:30:25 <esap> so the class becomes: class (Functor f) => InitialAlgebra f a | a -> f where { unCreate :: a -> f a ; fold :: (f a -> a) -> b -> a ; fold f = f . fmap (fold f) . unCreate }
17:31:04 <ski> Darius : do you mean that it is possible, "with enough external bakcground context" (of the right kind), but not generally ?
17:31:28 <ski> esap : yes, something like that
17:31:44 <ski> esap : was what i thought of
17:31:54 <Darius> I don't know if it is generally.  Providing an isomorphism for the "in" function is effectively pattern-matching, but that doesn't give you recursion.
17:32:44 <ski> so what part of haskell's semantics allows this def. of fold ?
17:32:49 <ski> the recursion ?
17:32:53 <Darius> There isn't too much of a point in providing "unCreate" except as a slight convenience, and at any rate you should definitely have a default for it.
17:32:53 <ski> (i guess)
17:33:08 <Darius> ski: Yes, the general recursion available.
17:33:28 <ski> Darius : (yes, i thought to have defaults for both)
17:34:14 <ski> so unCreate + recursion <-> fold  roughly ?
17:34:42 <esap> Yes, the Rec thing is even better I guess, wouldn't require the class at all.
17:34:47 <ski> (or maybe createIso instead of unCreate)
17:35:17 <ski> esap : how do you mean ?  the Rec type (constr.) ?
17:35:40 <esap> ski: yes, Rec and In.
17:35:47 <ski> Darius : ok
17:35:52 <Darius> ski: Well X ~= F X is what the isomorphism says.
17:37:52 <ski> Darius : hm, so you mean the recursion is in that equation ?
17:38:17 <ski> (recursive domains ...)
17:39:26 <ski> esap : you mean you'd specialize the class so that a always is Ref f ?
17:40:04 <esap> ski: well I can write an instance where f is Rec for both of those classes.
17:40:31 <esap> no, actually, f is not Rec, a is Rec f for every choice of f :-)
17:40:33 <ski> ?
17:40:50 <ski> Rec :: (* -> *) -> *    f :: * -> *
17:41:06 <esap> right.
17:41:21 <Darius> ski: It suggests it. 
17:41:24 <esap> so the instance is InitialAlgebra f (Rec f)
17:42:01 <esap> and similarly for the coalgebra thing.
17:42:10 <ski> but e.g. Rec Maybe ~= Nat, right ?
17:42:15 <esap> yes.
17:42:50 <ski> but haskell uses name equiv. of datatypes so we'd have to declare Nat separately as an instance
17:42:57 <ski> yes ?
17:43:12 <Darius> You would use NatFix x = Z | S x
17:43:20 <Darius> I.e. Maybe
17:43:23 <ski> yes
17:43:24 <Darius> And that would work.
17:43:35 <esap> yes
17:43:36 <Darius> The instance for Rec would work for all functors 
17:43:49 <Darius> as long as the target was Rec f
17:44:22 <ski> but if we want to use the type Nat  (data Nat = Zero | Succ Nat), we'd have to separately declare an instance for that
17:44:28 <Darius> Yes.
17:44:39 <ski> mm
17:44:57 <Darius> Actually, it wouldn't fit the instance.
17:44:58 <esap> that's the convenience.
17:45:06 <esap> it would.
17:45:07 <Darius> (Unless you mean the constant functor)
17:45:31 <ski> instance InitialAlgebra Maybe Nat  ?
17:45:35 <Darius> Yeah, I wasn't thinking.
17:45:51 <Darius> I was (obviously) thinking (? Nat) ? 
17:46:18 <esap> but due to the functional dependency, that would obviously conflict with the Rec f instance.
17:46:35 <ski> (i thought you might be thinking of  instance InitialAlgebra Nat' (something))
17:46:42 <Darius> No, Nat would decide f
17:47:11 <Darius> You wouldn't have InitialAlgebra Nat (Rec Nat) (maybe that was what I was thinking before)
17:47:24 <ski> esap : 'twould ?
17:47:35 <Darius> Er dammit. 
17:47:45 <Darius> I keep mixing f and a up.
17:47:46 <esap> but if you have InitialAlgebra f (Rec f)  then this conflicts with   InitialAlgebra Maybe Nat
17:48:05 <esap> because a -> f dependency
17:48:18 <Darius> The issue is the fact that it's only up to isomorphism.
17:48:26 <ski> esap : don't see it
17:48:49 <ski> Rec f determines f, right. and Nat determines Maybe
17:49:05 <Darius> Rec Maybe is isomorphic to Nat and so they are both initial algebras for Maybe.
17:49:09 <esap> ski: but f is anything, you can choose f=Maybe.
17:49:18 <ski> (so we couldn't have instance Initi.. NatFix Nat at the same time)
17:49:42 <ski> esap : so ?  wasn't it a -> f, and not f -> a ?
17:49:59 <Darius> Rec f is a.
17:50:03 <ski> yes
17:50:22 <esap> there can't be two different 'a''s that resolve to the same f.
17:50:30 <ski> we have a function, that given (Rec f) yields f
17:50:39 <ski> and given Nat yields Maybe
17:50:59 <esap> (Rec Maybe) -> Maybe    and Nat -> Maybe.
17:51:08 <ski> esap : why ?  must it be injective ?
17:52:49 <Darius> Wait that's fine, I wasn't crazy after all.
17:52:54 <ski> doesn't a -> f mean that for any a, there must be at most one f ?
17:53:09 <Darius> a decides f.
17:53:12 <ski> yes
17:53:35 <esap> oh maybe I'm confused here. I have to think which way it was again :-)
17:53:47 <ski> ;-)
17:53:51 <Darius> Damn functional dependencies appear to do that.
17:55:15 * ski grins big
17:55:18 <esap> if a decides f, then can you have two different a's that go to the same f?
17:55:29 <ski> i would think so
17:55:45 <ski> but one a can't go into two different f's
17:56:46 <ski> correct ?
17:57:00 <Darius> f doesn't decide a, therefore (Algebra Maybe a) would be ambiguous.
17:57:17 <ski> yes, of course
17:58:17 <ski> (cuz, a could be both Rec Maybe and Nat)
17:59:05 <esap> hmm.. ok, actually then this works better than I thought :-)
18:00:19 * ski almost says "what did i tell you ?"  ;->> (evil grin)
18:01:41 <esap> I thought this InitialAlgebra stuff would just be an approximation of what I want :-) I guess it's actually very close to being exactly the correct one....
18:02:23 <ski> nice
18:02:46 <esap> what about the "up-to-isomorphism" stuff?
18:02:57 <ski> i dunno
18:03:04 <Darius> Yeah, I was thinking about that, but it might be fine.
18:03:09 <ski> what up-to-iso ?
18:03:25 <esap> uniqueness is only up-to-isomorphism there.
18:03:36 <Darius> You can have multiple initial objects for a category of F-algebras.
18:03:41 <ski> the iso of all initial algebras (in the cat where they are inital objects) ?
18:03:45 <Darius> But that seems to be just what the fundep says.
18:04:16 <Darius> 0 -> 0' -> 0 = id 0' -> 0 -> 0' = id
18:04:41 <ski> yes
18:05:23 <ski> (though i'm not sure i see how the fundep says that, yet)
18:05:39 <esap> yea, I guess so. Hmm.. this is actually very good.
18:05:51 <Darius> Well, it doesn't actually give the isomorphism, but it seems not to restrict it to a particular representative of the isomorphism class.
18:06:30 * esap points to the Adjunction type class :-)
18:07:46 <Darius> Actually, it does give the isomorphism.
18:07:49 <ski> what if create :: f a -> a is included in the class  (+ axiom that create is inverse of unCreate) ?
18:07:56 <ski> Darius : hmm ?
18:08:07 <ski> how ?
18:08:28 <ski> hmm
18:08:58 <Darius> given 0 and F 0' -f-> 0', fold f : 0 -> 0', and similarly for the inverse.
18:09:35 <Darius> Of course, it's not a -proof- because there isn't a proof that the algebras are initial.
18:09:47 <ski> f : 0 -> 0' = unCreate >.> map f >.> something   ?
18:11:10 <ski> ( (>.>) = flip (.) )
18:11:14 <Darius> f is just the algebra, for Rec it would just be In.
18:12:01 <Darius> f isn't 0 -> 0'
18:12:09 <Darius> fold f is, f is F 0' -> 0'.
18:12:26 <ski> mhmm, ok
18:13:19 <ski> where do we get f from ?
18:13:41 <ski> is it the create above ?
18:14:22 <Darius> It's part of the data of the algebra (any algebra for the most part it -is- the algebra) and yes that's what esap called it above.
18:14:39 <ski> so we could perhaps have
18:14:44 <Darius> type Algebra f a = f a -> a
18:15:13 <ski> class Functor f => Algebra f a where { create :: f a -> a }  ??
18:15:38 <ski> (and inherit InitialAlgebra from that instead)
18:15:43 <ski> hmm
18:15:44 <Darius> No, because there are infinitely many instances for say [] Integer.
18:16:07 <ski> mm, ok, yes
18:16:12 <ski> right
18:16:55 <ski> the thing with initial algebras was that there is at most one a (up-to-iso) given f ?
18:17:19 <ski> hmm
18:17:31 <Darius> Yes.
18:17:49 <ski> good
18:18:22 <Darius> Adding create to InitialAlgebra may be useful I think.
18:18:38 <Darius> Not very though.
18:19:08 <ski> hmm, otherwise how do we know which create we are talking about ?
18:19:43 <esap> the inverse of the create is useful, because it's unique by the uniqueness of fold.
18:20:16 <ski> esap : so we can construct the fold from it + recursion
18:20:37 <esap> ski: well I guess recursion and fmap is enough.
18:20:57 <esap> but yes.
18:21:45 <Darius> Obviously, Rec f is an initial object for any algebra so yes, we can define any other instance of InitialAlgebra in by using the isomorphism and recursion in the Rec instance.
18:24:00 <ski> "Rec f is an initial object for any algebra", for some f ?
18:25:42 <Darius> Yes.
18:25:49 <ski> mm
18:26:54 --- mode: capek.freenode.net set +b *!*@206.169.168.190
18:26:54 <esap> But also, Rec f is a final object (which is interesting and counter-intuitive :-). At least I can implement both InitialAlgebra and FinalCoalgebra classes for  it.
18:27:06 <Darius> Yes, it's both.
18:27:17 <ski> why's that ?
18:27:20 <Darius> Both terminal and initial algebras are fixpoints.
18:27:56 <ski> doesn't they say that one is a least fixpoint and the over is a greatest ?
18:28:11 <Darius> Yes.
18:28:52 <ski> so isn't the least fixpoint "operation" different from the greatest ?  (this is prolly very vague talk)
18:28:55 <esap> you just have to be careful with the strictness annotations.
18:29:20 <Darius> ski: Not necessarily.
18:29:20 * esap is not sure I've done it correctly.
18:29:26 <ski> i seem to recall something about recursion and co-recursion (iteration ?)
18:29:35 <esap> yes, those are dual.
18:29:41 <ski> Darius : mhm
18:30:17 <ski> so i thought one had to do with least and the over with greatest fixpoint ..
18:30:26 <ski> s/over/other/
18:30:28 <Darius> As a side note, I seriously doubt that Rec is available for all categories of F-(Co)Algebras.
18:30:46 <esap> hmm.. interesting. Why?
18:30:54 <Darius> Yes, initial algebras are the least fixpoints of their functor terminal ones are the greatest.
18:31:08 <ski> esap : you speaking to me ?
18:31:09 <Darius> esap: It seems to unfold it you'd need fix/Y.
18:31:22 <Darius> To define the fold and unfolds.
18:32:26 <esap> darius: ok, hmm. Is it clear that fix is not definable after you have algebras?
18:33:18 <ski> Darius : "It seems to unfold ..." ?
18:33:21 <Darius> Well, if you have -all- initial/final (co)algebras, it may always be (though I think there'd be cases where you still couldn't make the right functors).
18:33:38 <Darius> ski:  That was a little poorly worded.
18:34:31 <ski> and what "may always be" ?
18:35:45 <Darius> You may always be able to define a fix like function as the initial/final algebra of some Rec F like object.
18:36:35 <ski> inital *and* final ?
18:36:43 <esap> yea, of course that might be restricted to that one specific type, and not 'generic' fixed point.
18:37:02 <ski> hmm
18:37:09 <Darius> I'm not sure.
18:38:09 <Darius> Hmm, perhaps more precise would be the underlying category would have a fix point if all endofunctors had initial/final F-(Co)Algebras.
18:38:15 <Darius> But I'm thinking that that's false.
18:38:16 <ski> so that (endo)functor has a fixed point, but not all ?
18:39:18 <Darius> Actually, all wouldn't be necessary.  I'm wondering if having the initial and/or final (co)algebra for F X = X -> X (with the underlying category having exponentials) would be enough.
18:39:30 <esap> darius: I think the definition of F,G-dialgebra from Hagino might actually be interesting to think about from this point of view.
18:39:50 <esap> darius: because it seems to be some kind of generalization of both algebras and coalgebras.
18:40:02 <Darius> Or whether that would be too restricted, I'm thinking it would still be too restricted, you'd need certain elements of that object that wouldn't need to exist.
18:40:19 <Darius> Darius: I'm pretty sure he explicitly states that it is, as well as of adjunctions.
18:40:57 <Darius> DAlg(F,Id) = FAlg,DAlg(Id,G) = G-CoAlg
18:41:11 <ski> Darius : talking to yourself ? :)
18:41:16 * esap has a good characterization of F,G-dialgebra in terms of OO programming :-)
18:42:10 <Darius> I was hoping to be able to got a better understanding of adjunctions in terms of either initial or final (co)algebras, but the instance is a DiAlgebra.
18:43:45 <ski> hmm, which dialgebra concept is it ?  (think i've seen several somewhat similar, though perhaps not all called dialgebra)
18:44:11 <ski> the one which consists of an algebra and a coalgebra ?
18:44:31 <ski> esap : you have ?
18:45:09 <ski> Darius : hmm, seems like that, i guess
18:45:27 <esap> I think the F,G-dialgebra may be (generalization of) OO terms for "layering" and "data flow"  in the [F(A) -> G(A)] diagram in the Hagino pg. 50, F identifies one layer and G identifies another. [A and B identify data and F(A) -> F(B) represents a computation that transforms A to B.
18:47:41 <esap> anyway, DAlg(F,G) represents somehow a "category of a piece of code delimited by layers F and G"
18:48:28 <ski> hmm, example of an op in a dialgebra ?
18:49:38 <ski> remove : a * Bag a -> 1 + Bag a  ??
18:53:08 <Darius> You can code naturals as a dialgebra without a coproduct.
18:53:26 <esap> so in a sense, the DAlg(F,G) category could be used to represent OO-style design, such that objects in that category are pair of an object and a dependency, and arrows are data flows betweek objects at the same layer.
18:53:28 <Darius> F N = (1,N) G N = (N,N)
18:53:45 <heatsink> I'm reading an example usage of 'let'... is it conventional to name local functions with an apostrophe at the end?
18:54:08 <Darius> It's common, for related functions. 
18:54:16 <Darius> Or especially values.
18:54:17 <ski> Darius : what would the ops be ?  (is it a meaningful/relevant question ?)
18:54:35 <heatsink> ok
18:54:50 <Darius> The algebra would be (N,(zero,succ)).
18:54:53 <ski> heatsink : quite often
18:55:38 <ski> and the coalgebra ?
18:56:15 <ski> (i'm trying to get how this dialgebra thing works/what it means)
18:56:17 <Darius> It's not a coalgebra and algebra stuck together.  That'd be the dialgebra.
18:56:45 <ski> sorry ? What's not a coalgebra and ... ?
18:57:10 <ski> (thought we were talking about dialgebras)
18:57:31 <Darius> I said the "algebra would be" then you asked  about "the coalgebra", by "algebra" in my sentence I meant dialgebra.
18:57:51 <ski> ah, ok.
18:58:34 <ski> so what's the type of zero and succ ?
18:58:47 <ski> hmm
18:58:54 <Darius> zero : 1 -> N, succ : N -> N
18:59:05 <ski> is zero the algebra op and succ the coalgebra op ?
18:59:11 <ski> mhm
18:59:17 <esap> no
18:59:29 <ski> no ?
19:00:58 <Darius> There is no Algebra part and CoAlgebra part.
19:01:34 <ski> then i must confuse it with something which consisted of an algebra and a coalgebra (and maybe something more)
19:02:00 <esap> yea, I guess there are many concepts called dialgebras.
19:02:11 <ski> but, it at least consists of two functors, right ?
19:02:28 <esap> no, it's a category.
19:03:01 <ski> (i don't see dialgebra in front of me as i (hopefully more or less correct) sees (co)algebra)
19:03:21 <esap> category DAlg(F,G) has objects are pairs <A,f>  and arrows are morphisms h: <A,f> -> <B,g>
19:03:23 <ski> now, i'm more confused
19:03:33 <ski> :-)
19:03:57 <esap> read the definition in pg. 50 of Hagino (or better, read the whole thesis :-)
19:03:57 <ski> aha, ok, thanks
19:04:01 <Darius> coalgebras and algebras are what you get by instantiating a dialgebra for certain functors.
19:04:23 <ski> i thought it was something on the same scale/level as (co)algebra
19:05:26 <ski> (or do you mean that an (F-)algebra is a cat, namely, the one in which initial algebras are initial objects ?)
19:05:46 <ski> (or something like that ?)
19:06:11 <ski> Darius : ok, hmm
19:07:11 <heatsink> How do I access the command line arguments passed to a compiled haskell program?
19:07:14 <esap> "DAlg(T,I) is the category of T-algebras and DAlg(I,T) ist the category of T-coalgebras"  [I is the identity functor]
19:07:38 <ski> heatsink : getArgs  (in IO or System i think)
19:08:05 <heatsink> System.getArgs ... thx
19:08:16 <ski> esap : ok, thanks.
19:09:09 <ski> heatsink : note, it does not include program name
19:09:29 <esap> I think of it like this: DAlg(A,B) is some kind of "range" from A to B. Similarly you could think of an F-algebra as a range from F to I.
19:09:41 <ski> hmm
19:10:45 <ski> Darius : is the dialgebra example you gave trivial (i.e. an algebra or a coalgebra  (one functor the identity)) ?
19:10:53 <esap> and F-coalgbra as the similar range from I to F.
19:11:46 <ski> (hmm, are DAlg(F,G) morphs is some cat with objs like F and G ? :)
19:11:54 <Darius> No, F was N |-> (1,N) and G  N |-> (N,N).  The algebra for it would be F  N |-> 1+N
19:12:18 <ski> hm
19:12:26 <Darius> (well the corresponding functor not the algebra)
19:12:41 <ski> mm
19:14:04 <ski> how does one derive the type of zero and succ from that ?  changing the (,) to -> ?
19:14:04 <Darius> (1,N) is a little redundant.
19:14:25 <Darius> The object are: (A,f : F A -> G A)
19:14:53 <Darius> f : (1,N) -> (N,N)
19:15:12 <ski> so f : ..  , yes, ok
19:15:43 <Darius> Hmm, this may very closely correspond to a coalgebra though.
19:15:48 * ski i seem horrible slow-thinking RN
19:16:26 <Darius> (1,N) ~= N, so it would be N -> (N,N) so F could be Id, except in the paper, Hagino uses the initial dialgebra.
19:16:36 <ski> hmm is (,) product ?   (comma bifunctor ??)
19:16:50 <Darius> Yes, x
19:17:02 <Darius> Just using a more Haskelly syntax.
19:17:05 <ski> ok
19:19:01 <ski> what two numbers does f return ?
19:19:24 <esap> darius: F and G were functors from C -> CxC, I guess that can't be Id, can it?
19:20:38 <Darius> They aren't.  F is C -> D and G is C -> DxD
19:20:50 <Darius> If we have D be C, then F can be Id.
19:21:11 <Darius> 0 and (1+)
19:21:27 <ski> Darius : mustn't F and G have mathcing (co)domains ?
19:21:41 <Darius> Yes.
19:21:44 <esap> hmm.. "Let C and D be categories and both F and G be functors from C to D. We define the F,G-dialgebra as..."  The first sentence of definition 3.1.2.
19:22:00 <Darius> So G takes it to D as a product in D.
19:22:10 <esap> and then later D is chosen to be CxC.
19:22:38 <ski> Darius : so really F : C -> DxD, then ?
19:22:39 <Darius> Whatever makes it work out is the type.
19:23:07 <Darius> So I guess esap is right, it can't be Id.
19:23:14 <ski> esap : ok, sounds nice
19:23:35 <ski> ok, so F : C -> CxC ?
19:23:42 <Darius> But that makes things easier as a terminal algebra didn't see right.
19:23:46 <Darius> Yes.
19:24:02 <Darius> (seem)
19:25:15 <ski> Darius : then the (,) above really isn't * (product) but pairing, right ?
19:26:49 <ski> (since a0 : a, b0 : b |- (a0,b0) : a * b)
19:28:13 <Darius> It goes from C -> CxC, what seems loose is the 1 seems to be the terminal object of C not Cat.
19:28:50 <Darius> Of course, it's completely superfluous.
19:28:57 <ski> shouldn't we have an 1 that is a cat ?
19:29:20 <Darius> Yes there is, but that wouldn't make sense (it wouldn't have the right types).
19:29:27 <ski> (so it can be unit to  x  over cats)
19:30:07 * esap has to get some sleep. (5am already)
19:30:09 <ski> hm
19:30:37 <ski> esap : you'll be back later ?
19:30:42 <esap> yes.
19:31:12 <ski> esap : cuz, i still don't understand all of your paragraph on hawiki
19:31:24 <esap> heh :-)
19:31:33 <esap> ok see you later
19:31:41 <ski> of course i want to understand what you are saying
19:31:45 <ski> :9
19:32:03 <ski> i might not be back here until monday
19:32:15 <ski> esap : ok, bye
19:33:13 <ski> Darius : we want some 1 st  1xA ~= A
19:33:27 <ski> hmm
19:33:41 <ski> no (1,A) ~= A
19:34:06 <ski> is that right ?
19:34:29 <ski> Darius : perhaps you're also tired. i know i am
19:35:05 <ski> should we call it a stop ?
19:35:19 <Darius> I was reading the GA tutorial.
19:35:25 <ski> m,ok
19:35:36 <ski> (GA ?)
19:35:41 <ski> oh
19:35:48 <ski> Geometry algebra
19:35:56 <Darius> s/the/this/
19:36:55 <ski> 'sit interesting ?
19:37:56 <Darius> Yes.
19:40:45 <ham[kell]> oh
19:40:48 <ham[kell]> what ga tut?
19:42:27 <ski> http://www.science.uva.nl/~leo/clifford/dorst-mann-I.pdf ?
19:42:47 <ski> GABLE ?
19:42:50 <Darius> Well, right now the one on conformal 3d geometric algebra that goes with GAViewer.
19:50:36 <ham[kell]> is there any good introduction paper to GA?
19:50:40 <ham[kell]> or a good book?
19:51:39 <ski> ham[kell] : i dunno. look around the site, e.g.
19:51:56 <ski> U have url ?
19:52:07 <ham[kell]> ?
19:52:38 <ski> Do you have to Uniform resource Locator ?
19:52:51 <ski> s/to/the/
19:52:57 <ham[kell]> which?
19:53:04 <ham[kell]> of that paper you gave me?
19:53:05 <ski> http://carol.science.uva.nl/~leo/clifford/
19:53:10 <ham[kell]> ah
19:53:11 <ham[kell]> no
19:53:30 <ski> http://www.science.uva.nl/ga/viewer/ can be found from that page
19:53:31 <ham[kell]> thanks
19:53:49 <ski> i haven't look much at it yet, though
19:54:41 <ski> so ask Darius
19:55:02 <ham[kell]> :)
19:56:18 <ham[kell]> Darius can you point me to any good book or script?
19:56:20 <ski> ski : look, you're so tired you can't ever choose correct verb-forms. go home and get some sleep !
19:57:03 <Darius> I've only looked at the things on the site for the most part.
19:57:09 <ski> ski : but, i'm reading an interesting thread
19:57:23 <ski> ski : stop that
19:58:24 <ski> ski : can't i read it to the end. please, it's only a few msgs left ?
19:59:00 <ski> ski : look, you're talking to yourself, how sane is that ?
19:59:25 * ski grumbles
20:39:21 <ski> well, i'm outta here !
22:53:10 <stepcut> join #hprog
22:53:14 <stepcut> oops :)
