01:56:34 <fanou> SamB: do you have a preference between Python and Haskell ?
01:57:26 <durnew> that's an odd comparison
01:57:39 <fanou> durnew: why ?
01:58:23 <durnew> i just don't often see those languages compared to eachother
01:58:30 <durnew> as they're quite different
01:58:35 <fanou> durnew: even if there are different, you can tell if you have preference for carotts or peas
01:59:13 <durnew> i usually divide my favorites up into categories
01:59:19 <fanou> durnew: i'm not asking if one is better, just Samb's preference
01:59:19 <durnew> those two being in different categories
01:59:23 <durnew> okay
01:59:37 <explodey> Haskell & Perl are very different but there is still some rivalry there
02:00:22 <ham[ogoblin]> has anyone of you done something with hopengl? i need some help on "converting" my own vectors to vertices for hogl
02:14:56 <ham[ogoblin]> how can i convert a Float to a GLfloat?
02:16:41 <cptchaos> hm, due to the documentation of ghc 6.2 
02:16:49 <cptchaos> type GLfloat = Float
02:17:13 <cptchaos> GLfloat is just an alias for float
02:17:18 <ham[ogoblin]> hm
02:17:40 <ham[ogoblin]> sec
02:18:52 <ham[ogoblin]> ah cool
02:19:05 <ham[ogoblin]> got the error :)
02:20:58 <cptchaos> is OpenGL in haskell fast?
02:21:23 <cptchaos> or fast enough to write small demos?
02:22:22 <ham[ogoblin]> hm i dont expect too much 
02:23:12 <cptchaos> ok :-)
02:23:15 <ham[ogoblin]> but since you can compile it to binary files
02:23:20 <ham[ogoblin]> well see :)
02:47:10 <TripleDES> hi
02:59:53 <det> does haskell really need to be very fast for opengl stuff ?
03:00:03 <det> most of the work is in the video card, yes ?
03:23:00 <ham[ogoblin]> can someone help me to get a cycling value into my code?
03:23:01 <ham[ogoblin]> http://rafb.net/paste/results/B2173271.html
04:42:17 <phubuh> ham[kell]: hmm, what do you mean?
04:59:22 <ham[kell]> i did it :)
04:59:37 <ham[kell]> i needed a value that i can coherently change over time
05:00:33 <ham[kell]> a global variable if you want i did that with IORef
05:02:03 <phubuh> oh
05:04:01 <ham[kell]> can i do something like this in haskell?
05:04:26 <ham[kell]> require some algebraic stucture over a type to process it?
05:27:59 <ham[kell]> can someome of you give me an example of a coalgebraic comultiplication?
06:31:43 * shapr awakens
06:31:53 <shapr> yow, I've adopted ham[kell]'s sleep schedule.
06:32:07 <ham[kell]> :)
06:32:07 <shapr> bonjour fanou, comment ça va?
06:32:31 <shapr> it's 15:32, that's a bit late for morning.
06:33:28 <ham[kell]> time is relative :)
06:33:51 <shapr> yes, but my woman awakens at the same time everyday +- 10 minutes
06:34:07 <mgoetze> shapr: i wish i could do that...
06:34:10 <shapr> for me, it's +- 10 hours
06:34:24 <shapr> yah, me too
06:34:44 <ham[kell]> i just try to listen what my body tells me
06:34:48 <ham[kell]> if i am tired i sleep
06:34:56 <ham[kell]> if i am not i dont
06:35:06 <shapr> I just try to listen to what my woman tells me ;-)
06:35:22 <ham[kell]> thats natrual and important to live on :)
06:35:28 * shapr laughs
06:35:53 <ham[kell]> men have some extra device in their ear to achieve that
06:36:12 <shapr> listening? or ignoring?
06:36:29 <ham[kell]> :) it does both
06:37:01 <ham[kell]> dependant on your testosterone level ;)
06:39:46 * shapr grins
06:41:15 <shapr> I like the ranked_powerset on PreludeExts
07:17:20 <shapr> PreludeExts is growing
07:17:25 * shapr bounces cheerfully
07:17:39 <shapr> hello d2004xx, are you learning Haskell?
07:18:00 <ham[kell]> :)
07:18:34 <shapr> well, this is a good time to hack on gforge
07:26:49 --- mode: sterling.freenode.net set +b *!*@206.169.168.190
07:38:25 <shapr> yow!
07:40:04 * shapr discovers two things waiting for admin approval on gforge.ScannedInAvian.org
07:44:42 <shapr> has anyone here tried kernel 2.6.0 ? any problems?
07:45:17 <Igloo> Only if you count the security hole as a problem...
07:45:42 <Igloo> 2.6.1 is OK AFAIK
07:45:46 <shapr> I wonder if kernel-patch-debian-2.6.0 fixes that
07:45:58 <Igloo> Ah, quite possibly
07:46:37 <phubuh> 2.6 is cool
07:46:56 <shapr> I've heard it's faster on SMP than 2.4
07:47:21 <phubuh> by the way, do any of you use Jabber?  I'd like to see if it works
07:49:44 <shapr> SyntaxNinja uses it
07:49:47 <shapr> for irc also
07:49:59 <shapr> grr, ftp.se.debian.org is having problems the last coupla days
07:52:34 <steveh> I think some corporate solutions are based on Jabber, e.g. Sametime
07:59:24 <shapr> Igloo: changelog says kernel-patch-debian-2.6.0 fixes mremap, so it should be okay
08:00:16 <phubuh> I wish topcoder let you code in Haskell
08:00:24 <shapr> me too
08:00:37 <shapr> we could always start _|_coder
08:00:43 <phubuh> haha
08:01:00 * shapr snickers
08:16:30 <shapr> y0 raver, wazzup?
08:32:43 <shapr> hi gim 
08:33:00 <gim> hello
08:33:08 <shapr> how's code?
08:33:32 <gim> what code?
08:33:41 <shapr> any code you're working on :-)
08:34:24 <gim> ah.. smells like spaghetti :-(
08:34:30 <shapr> hehe
08:35:15 <gim> just smells, but is not delicious
08:35:26 <shapr> that's much better than starving
08:35:38 <gim> good point.
08:36:09 <shapr> are you learning Haskell?
08:36:26 <gim> just interested from years. :-(
08:36:38 <shapr> oh, you have experience using Haskell?
08:37:22 <shapr> I know it took me a few years to get around to learning Haskell.
08:37:53 <gim> actually, I often use ML like languages, but Haskell little.
08:38:15 <Riastradh> Neither significant ML has typeclasses.  Blech!
08:38:32 <shapr> of course, compared to C, ML and Haskell are at least cousins
08:39:11 <gim> yeah, I hate ML's void of typeclasses.
08:39:26 <shapr> do you use ML at your job?
08:40:04 <Maddas> Oh, Riastradh. Scheme 48 parses pre-Scheme, and the rest of Scheme is implemented in pre-Scheme, right?
08:40:10 <gim> No, I use functional language just for fun and study.
08:40:28 <gim> In my company, THEY use C++
08:40:52 <gim> (unfortunately)
08:41:25 <shapr> well, programming is cool
08:41:25 <Riastradh> Maddas, no...the Scheme48 VM is written in Pre-Scheme, and the rest is Scheme.
08:41:33 <shapr> though admittedly, I prefer functional programming
08:42:42 <Maddas> Riastradh: Oh, ok.
08:42:55 <gim> I wish, Operating system allow higher order and polymorphic type system.
08:43:19 <shapr> I wonder how that would work
08:43:28 <shapr> use hOp maybe :-)
08:43:34 <gim> hOp?
08:43:41 <gim> what's that?
08:43:55 <shapr> Sebastian Carlier is working on getting GHCs runtime system on bare hardware
08:44:08 <Maddas> shapr: That sounds very cool
08:44:15 <shapr> lots of languages are getting their runtime systems on bare hardware, jNode is one example
08:44:38 <shapr> I found out at HIM that some very large organizations are interested in Haskell running on bare hardware
08:44:47 <Maddas> Hmm
08:45:08 <shapr> these large organizations would like to do end-to-end system verification
08:45:38 <shapr> if it's the organization I think it is, it just might have the resources to do an end to end system proof.
08:46:04 <shapr> now *that* would be spiffy
08:46:14 <Maddas> Yeah
08:47:22 <SamB> shapr: they better prove the hardware correct too
08:47:41 <shapr> might be able to do that too, with something like BlueSpec
08:48:23 <shapr> of course, as an application programmer, I would be far too intimidated to actually write applications for a system like that
08:48:37 <shapr> if your system has proof of correctness from the electron to the mouse
08:48:48 <shapr> any errors in your programs are obviously yours =)
08:49:20 <shapr> I sort of wonder if Gödel might sneak in there somewhere
08:49:56 <SamB> shapr: how do they know if the specs are right?
08:50:04 <shapr> good question
08:50:18 <shapr> my knowledge of mathematical proofs is nearly zero
08:50:30 <shapr> though I'm pretty handy with unit tests
08:52:37 <shapr> SamB: I know Lava, Hawk, BlueSpec etc can be used to do some proofs of correctness of hardware
08:52:56 <shapr> I've read various Haskell books that use induction proofs to prove various things about Haskell source
08:53:31 <shapr> but any sort of system proof sounds like a Herculean task to me.
08:54:06 * shapr imagines cleaning the stables of Argh!ea
08:54:37 * shapr tries to remember the twelve labors of Hercules
08:57:29 <shapr> sucky life - http://www.pantheon.org/articles/h/hercules.html
09:43:49 * shapr hacks PHP
09:45:41 <Riastradh> Ewwwww.
09:46:12 <shapr> Riastradh: well, gforge is the best option I've found, and it's written in PHP
09:46:32 <shapr> if you can find a sourceforge clone written in a better language, I'll consider it.
09:58:16 <shapr> hello kokank 
09:58:29 <shapr> Riastradh: do you know of any non-PHP sourceforge clones?
09:58:40 <kokank> hi ! 
09:58:47 <kokank> hi all 
10:20:35 <Riastradh> shapr, no.
10:21:00 <shapr> neither do I :-/
10:21:23 <shapr> though I admit, looking at PHP sources is great motivation to write one in pretty much any other language.
10:21:32 <shapr> I could make a nice one with Zope/Plone
10:27:23 <Riastradh> Or with WASH/CGI or SUrflets.
10:27:51 <shapr> I haven't used WASH/CGI much
10:28:29 <shapr> I'll use WASH/CGI a lot more when HaskellDB works in GHC with postgresql
10:29:00 <mattam> what's SUrflets ?
10:29:01 <shapr> I should email the chalmers guys HaskellDB guys
10:29:14 <shapr> seems to be a scheme web thingy, according to google
10:30:45 <shapr> looks like it uses the "continuations to model web interactions" idea
10:30:56 <shapr> I'd like to try designing website that use that idea
10:31:33 <mattam> WASH/CGI uses the same technique IIUC
10:32:25 <mattam> i'd like to be able to write such a thing in caml :)
10:41:56 <Riastradh> mattam, http://www.scsh.net/resources/sunet.html -- scroll down
10:43:33 <shapr> w00h00, snippets now have a Haskell category
10:43:39 <shapr> that was easier than I expected
10:56:26 <phubuh> haha
10:56:29 * phubuh just played topcoder for the first time
10:57:39 <shapr> did you win?
10:57:54 <phubuh> nope
10:58:03 <phubuh> I failed miserably
10:58:09 <shapr> I know Logan made a lot of money with topcoder
10:58:21 <shapr> though I think the prizes have gotten smaller since then
10:59:02 <phubuh> I used C++ :(
10:59:08 <shapr> PHP is the definition of "tightly coupled"
10:59:11 <phubuh> I was in such a hurry, my code turned out to be so ugly and horrible
10:59:17 <phubuh> http://www.phubuh.org/~phubuh/b.cc
10:59:19 * phubuh shivers
10:59:20 <shapr> well,that's a good place to start
10:59:53 <shapr> oh, did you see the neat article on slashdot about making mistakes?
11:00:00 <phubuh> hmm, nope
11:01:09 * shapr gets url
11:01:21 <shapr> it matches my personal philosophy, so I like that
11:01:52 <shapr> huh, maybe it wasn't on slashdot
11:01:53 <ham[marubi]> bk
11:02:22 <shapr> darcs
11:02:40 <Igloo> Some people never learn
11:02:58 <shapr> haha
11:03:16 <shapr> that was punny, since it could easily apply to several of the last few lines
11:03:27 <shapr> phubuh: http://slashdot.org/articles/03/12/27/0516211.shtml?tid=185&tid=187
11:03:34 <shapr> scarily, that article is on msdn
11:04:50 <shapr> anyways, I think it's a great practice
11:05:44 <shapr> I'd rephrase it as "regularly try things you're not sure will work, as long as those things failing will not affect the core stability of your income."
11:18:02 <shapr> oh, nice nickname
11:18:16 <shapr> hello bottom, how are you?
11:18:18 <_|_> thanks  :-)
11:18:42 <_|_> Fine, how are you?
11:19:05 <shapr> hacking on PHP, but it's for Haskell purposes, so...
11:19:06 <ham[marubi]> heh
11:19:40 <shapr> I assume from your nickname that you already have some understanding of functional programming
11:20:10 <_|_> Sure.  I've been aquainted with Haskell for at least a couple of years.
11:20:47 <shapr> ah, spiffy, do you use Haskell at work?
11:20:55 <ham[marubi]> what do you use as bottom elements in FP?
11:20:58 <_|_> I wish.
11:21:03 <shapr> yah, me too
11:21:21 <_|_> Bottom represents non-termination.
11:21:39 <_|_> Bottom is a value of every type.
11:21:54 <ham[marubi]> hm how so?
11:22:02 <ham[marubi]> ah is A val of every
11:22:05 <ham[marubi]> ok :)
11:23:17 <phubuh> _|_: Matt Harden?
11:23:26 <_|_> Yes.
11:23:33 * shapr quickly googles
11:24:02 <shapr> were you at ICFP?
11:24:28 <_|_> shapr: no; I'm not anybody important in FP, just a hack.
11:24:57 <shapr> same for me, but I went to ICFP because I was in the same country.
11:25:47 <_|_> When was it?
11:25:56 <shapr> august 2003, I think
11:26:16 <shapr> next year I think it's in Utah
11:26:38 <shapr> I doubt I'll make it to that one, unless I'm already visiting the US for other reasons.
11:27:07 <shapr> I found out that you used to have a website with Haskell sources on it, do you still have such a thing?
11:27:36 <_|_> I assume you mean the Haskell version of Mersenne Twister?
11:27:37 <shapr> http://members.primary.net/~matth/ is 404
11:27:42 <shapr> yup
11:28:43 <_|_> My old ISP sold us out to Mindspring.  Let me see if the page is there.
11:29:22 <shapr> I'm always in the market for OSDL-compatible licensed Haskell sources of which I don't have a copy.
11:31:33 <_|_> shapr: It's at http://www.mindspring.com/~matth/mt19937.hs
11:32:21 <shapr> cool
11:32:31 <_|_> Thanks! :-)
11:32:45 * shapr adds a copy to the hoard
11:32:54 <_|_> The hoard?
11:33:17 <shapr> yes, I have a hoard of Haskell sources.
11:33:41 <shapr> at the moment it's sf.net/projects/haskell-libs
11:34:19 <shapr> it's mine actually
11:34:19 * _|_ checks out the hoard
11:34:50 <shapr> er "it's *not* really mine"
11:34:59 <shapr> very little of the code was actually written by me
11:35:37 <shapr> at the moment I'm editing PHP code because I'd like to suggest a sourceforge-style website specifically for Haskell
11:35:42 <ham[marubi]> btw i have finished my homotope spline :) http://rafb.net/paste/results/Tu490349.html
11:36:28 <shapr> the demo for such a site is at http://gforge.scannedinavian.org/
11:36:33 * shapr tries ham's spline
11:36:52 <ham[marubi]> :) its not spectacular though
11:37:36 <ham[marubi]> but i think it would be fun to abstract it further more and then have homotope mapping on abstact data
11:37:41 <shapr> oooh, nifty!
11:37:55 <ham[marubi]> it doesnt look really special
11:38:01 <phubuh> wheee
11:38:15 <phubuh> I have no clue what that is, but it looks cool
11:38:16 <ham[marubi]> but its quite cool you can get a homotope spline and that is what you see
11:38:29 <ham[marubi]> that whole thing is one spline spline so to say
11:38:45 <shapr> looks cool to me, do you plan on adding more features?
11:39:09 <shapr> I immediately wanted to drag the string around with my mouse
11:39:11 <ham[marubi]> yes i want to try to do some more topological stuff
11:39:21 <ham[marubi]> at least the stuff that is visualizable
11:39:25 <ham[marubi]> :)
11:39:38 <ham[marubi]> nah thats not intedet since
11:39:52 <ham[marubi]> that function h wich is homotope looks like that
11:39:58 <shapr> your comments look like a lot like mine
11:40:26 <ham[marubi]> h(x,t), h(x,0) = firstspline x, h(x,1) = secondspline x
11:40:38 <ham[marubi]> heh :) thats because i copied the ogl stuff ;)
11:40:43 <ham[marubi]> im a lazy bastard ;)
11:40:59 <shapr> actually, I was talking about your "--shitty prelim solution" comment
11:41:14 <ham[marubi]> oh :)
11:41:17 * shapr grins
11:41:23 <ham[marubi]> thats a bit strange in that line
11:41:39 <ham[marubi]> when i use l==1 it gets out of the list bound
11:42:05 <ham[marubi]> though 1 should be reached when i use 0+x*0.1
11:42:09 <shapr> _|_: if you're new to #haskell, the local touristy sights are lambdabot, the HaWiki, and haskell-libs and its accompanying darcs repository.
11:42:24 <phubuh> comparing Floats with == is generally a bad idea
11:42:25 <ham[marubi]> heh ;) to the right you see the bot ;)
11:42:49 <ham[marubi]> phubuh oh ? so what would i have to do in order to achive something like that?
11:42:49 <shapr> and on the left we have the wiki and the coffee shop
11:43:15 <_|_> shapr: I have posted to the wiki before, but was not aware of lambdabot & haskell-libs
11:43:25 <phubuh> since Floats are inexact, it's better to fuzzily compare them with a threshold, in most cases
11:43:52 <shapr> _|_: oh, and I'm Shae Erisson IRL (in real life), I've posted to the wiki and the mailing lists.
11:44:12 <ham[marubi]> hm ok or i make a minorrewrite and use ints as sections
11:44:46 <_|_> shapr: Hi Shae, pleased to make your acquaintance.
11:44:52 <shapr> nice to meet you too
11:45:00 <phubuh> Prelude> (4.1 - 4.0) == 0.1
11:45:01 <phubuh> False
11:45:41 <ham[marubi]> ok is there any idea behind that to make that fail?
11:45:50 <phubuh> Prelude> 4.1 - 4.0
11:45:52 <phubuh> 9.999999999999964e-2
11:45:52 <phubuh> :)
11:45:53 <_|_> phubuh: floating point rounding.  If you use Ratios it will be exact.
11:46:06 <phubuh> yup
11:46:15 <ham[marubi]> how do i do that?
11:46:26 <_|_> Really, you should never use (==) on floats or doubles.
11:46:32 <ham[marubi]> k
11:46:40 <shapr> oh, I should also mention than this channel is logged, and that anything you say will show up on google, and on the log site: http://tunes.org/~coreyr/
11:46:51 <ham[marubi]> as i suppose that as a feature i would like to know why
11:47:08 <_|_> shapr: I noticed that in the channel topic.
11:47:13 <phubuh> it's not a feature, it's a consequence of the limited size of floating point numbers
11:47:42 <phubuh> you can only get so much precision with 32 bits :)
11:47:44 <ham[marubi]> but symbolically this should be perfeclty fine
11:47:59 <Maddas> phubuh: feature sounds more motivating :-)
11:48:17 <ham[marubi]> :)
11:48:34 <Maddas> ham[marubi]: Limited floating-point precision is inherent in all languages using a finite number of bits to represent numbers
11:49:08 <Maddas> It's really a limitation, not a feature :)
11:49:13 <ham[marubi]> so other langs implicitly round?
11:49:25 <Maddas> Hm? Using a float?
11:49:37 <shapr> IEEE-754 is the reason, yes?
11:49:51 <phubuh> symbolically, 2**32/2 == 2**31 too, but that doesn't hold in a lot of languages, like C
11:49:51 <Maddas> shapr: I guess :)
11:50:18 <phubuh> it does hold in Haskell, because its Integers can be as large as your memory
11:50:32 <phubuh> but Floats have a fixed size, and a rather small one at that
11:50:34 <Maddas> I really like that property :)
11:50:44 <shapr> Double Float is larger, but still inexact
11:50:59 <Maddas> Yeah, it'll be closer to 0.1, that's all.
11:51:20 <ham[marubi]> ok so you are not intended to compare floats precisely since they are not precise?
11:51:30 <phubuh> precisely!
11:51:34 <ham[marubi]> :)
11:51:41 <Maddas> Indeed
11:52:08 <ham[marubi]> thats not too nice
11:52:20 <ham[marubi]> then i will rewrite it
11:52:39 <phubuh> you could see if it's equal +-0.01, or something like that
11:52:49 <ham[marubi]> in a way that i generate that number and keep track of the incrementation
11:53:06 <ham[marubi]> yep but what if you change the stepping
11:53:17 <shapr> ieee-754 float is a 23 bit mantissa 8 bits of exponent, and 1 sign bit
11:53:30 <_|_> ham[marubi]: You may want Rationals if you want precision
11:53:58 <phubuh> Prelude GHC.Real> fromRational ((realToFrac 4.1 - realToFrac 4.0) :: Rational) :: Float
11:53:59 <phubuh> 0.1
11:53:59 <shapr> double float is 52 bit mantissa and 11 bit exponent
11:55:00 <phubuh> Rational stores rational numbers as a quotient of two Integers
11:55:08 <shapr> the history of IEEE-754 is quite interesting
11:56:05 <ham[marubi]> k then i will rewrite it with rationals 
11:56:05 <_|_> (4.1 :: Rational) - 4.0 == 0.1
11:56:05 <ham[marubi]> :) next update will include homotope spline surfaces :)
11:56:05 <_|_> But Rationals can start to get very large (in terms of memory) very fast if you're not careful.
11:56:05 <ham[marubi]> hmhmhm
11:56:39 <shapr> I've heard Pseudonym talk about a way to factor Rationals so that they take less memory
11:57:13 <shapr> he's also written some exact real code that he's put into haskell-libs
11:58:22 <shapr> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/exactreal/
11:59:35 <_|_> Hey that's neat; I can't represent pi as a Rational, but he's got pi as an exact real!
12:01:03 <phubuh> maybe it's lazily evaluated :-)
12:01:51 <_|_> Dissapointing: it looks like an estimate to me; something to do with sqrt(10005).
12:04:06 <_|_> shapr: Is there a paper somewhere on the exact reals?
12:06:40 <_|_> I can't make heads or tails of the code.
12:09:15 <_|_> What is lambdabot?
12:10:38 <_|_> lambdabot: help
12:10:39 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:10:46 <_|_> lambdabot: @listcommands
12:10:47 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","more","msg","part","prelude","quit"
12:12:00 <_|_> lambdabot: definitions
12:12:00 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:12:09 <_|_> lambdabot: @definitions
12:12:09 <lambdabot> ["Arrow"]
12:12:09 <lambdabot> ["B","Branch"]
12:12:09 <lambdabot> ["C","Cons"]
12:12:09 <lambdabot> ["False","Forall"]
12:12:09 <lambdabot> ["I"]
12:12:10 <lambdabot> ["Just"]
12:12:12 <lambdabot> ["K"]
12:12:14 <lambdabot> ["Leaf","Left"]
12:12:16 <lambdabot> ["MonadError","MonadLP","MonadParser","MonadReader","MonadState","MonadWriter","MonadWriter_"]
12:12:18 <lambdabot> [30 @more lines]
12:12:50 <phubuh> @eval take 5 primes
12:12:51 <lambdabot> [2, 3, 5, 7, 11]
12:13:11 <_|_> thanks phubuh
12:14:04 <phubuh> this is a really useful one
12:14:08 <ayrnieu> lambdabot: @karma+ lambdabot
12:14:08 <lambdabot> lambdabot's karma has been incremented.
12:14:12 <_|_> my IRC window word wraps, but the response to listcommands comes out as one word, and I can't see past "dynamic-load"
12:14:18 <ayrnieu> lambdabot: @karma lambdabot
12:14:18 <lambdabot> lambdabot has a karma of 1
12:14:26 <ayrnieu> bah, too much overhead to use.
12:14:28 <phubuh> @type flip . (+ 1)
12:14:52 <ayrnieu> lambdabot: @type flip . (+ 1)
12:14:53 <phubuh> err.
12:15:01 <ayrnieu> lambdabot: type flip
12:15:02 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:15:06 <ayrnieu> lambdabot: @type flip
12:15:06 <lambdabot> flip :: (a -> b -> c) -> b -> a -> c
12:15:12 <ayrnieu> lambdabot: @type (flip .)
12:15:13 <lambdabot> (flip .) :: (a -> b -> c -> d) -> a -> c -> b -> d
12:15:18 <ayrnieu> lambdabot: @type (flip . (+ 1))
12:15:26 <_|_> Heh.
12:15:39 <_|_> I don't think you can flip (+1).
12:15:40 <phubuh> shapr: help!
12:15:44 <ayrnieu> lambdabot: @type (flip (+ 1))
12:15:47 <_|_> @type (flip (+))
12:15:48 <lambdabot> flip (+) :: Num a => a -> a -> a
12:16:06 <ayrnieu> | - well, you can flip (+1) about as much as you can flip what (x+1) evaluates to =)
12:17:01 <_|_> Prelude> :type (flip . (+1))(flip . (+1)) :: forall a b c.                 (Num (a -> b -> c)) =>                 (a -> b -> c) -> b -> a -> c
12:17:39 <_|_> So if (a->b->c) is a Num, then I can do (flip . (+1))
12:17:47 <phubuh> hee hee
12:18:41 <_|_> @help define
12:18:41 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
12:18:53 <phubuh> @type GHC.Base.max
12:20:51 <_|_> lambdabot: @hello
12:20:51 <lambdabot> Hello world. 
12:21:06 <phubuh> @type Hugs.Observe.observe
12:21:37 <phubuh> oh
12:21:41 <phubuh> lambdabot: @type GHC.Base.max
12:21:56 <phubuh> lambdabot: @type Hugs.Observe.observe
12:21:59 <ayrnieu> lambdabot: @dummy
12:21:59 <lambdabot> dummy
12:22:01 <phubuh> bah!
12:22:32 <_|_> @eval (4.0 :: Rational) + 4.1
12:22:32 <lambdabot> (line 1, column 7):
12:22:32 <lambdabot> unexpected ":"
12:22:32 <lambdabot> expecting simple term
12:22:57 <_|_> @eval (toRational 4.0) + 4.1
12:22:57 <lambdabot> type error
12:23:07 <phubuh> the language used in @eval isn't Haskell, though it's pretty close for basic things
12:23:07 <_|_> @type toRational
12:23:08 <lambdabot> toRational :: Real a => a -> Rational
12:23:53 <phubuh> it's dynamically typed, I think, and it uses \x.y syntax for lambdas
12:23:54 <_|_> @eval (toRational 4.0)
12:23:54 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:24:35 <_|_> @eval 40 % 10
12:24:35 <lambdabot> (line 1, column 4):
12:24:35 <lambdabot> unexpected "%"
12:24:35 <lambdabot> expecting operator, simple term or end of input
12:25:20 <phubuh> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/lambdabot/EvalModule/ is probably the best documentation you'll find :-)
12:25:25 * shapr returns
12:25:30 <phubuh> oh hi
12:25:45 <shapr> Darius wrote the EvalModule
12:25:57 <shapr> it's a lambda calculus interpreter, with the ability to make definitions
12:26:08 <shapr> it also has some other neat tricks
12:26:23 <shapr> @eval (\x -> x x)(\x -> x x)
12:26:43 <lambdabot> out of fuel - use @resume to continue
12:26:51 <phubuh> @eval toRational 0 4.0
12:26:51 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:27:02 <phubuh> @eval toRational 1 2 3
12:27:03 <lambdabot> unbound variable: toRational
12:27:15 <phubuh> oh, haha
12:27:18 <phubuh> @eval 1.0
12:27:19 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:27:28 <shapr> @eval 1
12:27:28 <lambdabot> 1
12:27:33 <shapr> @eval 1.0 + 1
12:27:33 <lambdabot> type error
12:27:41 <shapr> @eval 1.0 + 1.0
12:27:41 <lambdabot> type error
12:27:42 <phubuh> 1.0 is (.) 1 0
12:27:46 <shapr> ohh
12:27:48 <shapr> doh
12:27:50 <_|_> Oh!
12:27:50 <phubuh> :)
12:28:09 <shapr> @listmodules
12:28:09 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
12:28:16 <shapr> @listcommands eval
12:28:17 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","del-definition","dump","set-fuel","resume"]
12:28:36 <phubuh> I wonder if this stuff is left
12:28:38 <shapr> line wrapping for too long lines is on the TODO list
12:28:43 <phubuh> @get-definition mersennePrimes
12:28:44 <lambdabot> mersennePrimes = (filter isPrime (map (\\x. pow 2 x - 1) (enumFrom 1)))
12:28:48 <phubuh> oh, yay
12:29:07 <shapr> actually, I think Hampus recently wrote that sort of line wrapping, but I haven't installed it yet.
12:29:47 <shapr> anyways, making plugins for lambdabot is pretty simple
12:30:04 <shapr> especially since polli rewrote the plugin system
12:30:21 <_|_> @definitions
12:30:22 <lambdabot> ["Arrow"]
12:30:22 <lambdabot> ["B","Branch"]
12:30:22 <lambdabot> ["C","Cons"]
12:30:22 <lambdabot> ["False","Forall"]
12:30:22 <lambdabot> ["I"]
12:30:23 <lambdabot> ["Just"]
12:30:25 <lambdabot> ["K"]
12:30:27 <lambdabot> ["Leaf","Left"]
12:30:29 <lambdabot> ["MonadError","MonadLP","MonadParser","MonadReader","MonadState","MonadWriter","MonadWriter_"]
12:30:31 <lambdabot> [30 @more lines]
12:30:43 <_|_> @more
12:30:44 <lambdabot> wrong type (<<[] Char>>) in ModuleState
12:30:47 <shapr> oops
12:30:51 <shapr> I thought that was fixed
12:31:03 * phubuh goes to pick up pizza
12:31:25 <_|_> @get-definition Branch
12:31:25 <lambdabot> Branch = \\l k r lk bk.bk l k r
12:31:26 * shapr tries to refix @more
12:31:32 <shapr> @get-definition c
12:31:32 <lambdabot> c not defined
12:31:39 <shapr> @get-definition a
12:31:39 <lambdabot> a = map (either bad fst . runMonad MonadParser parseRule) ["lookup(cons(pair(K,V),T),K,V).","lookup(cons(P,T),K,V) :- lookup(T,K,V)."]
12:31:46 <shapr> @definitions c
12:31:46 <lambdabot> ["car","cat","cata","catchError","cdr","chAnd","chFalse","chIf","chNot","chOr","chTrue","char","charToDigit","choice","comma","concat","concatMap","cons","const","curry","cycle"]
12:31:49 <shapr> ah, there it is
12:32:37 <_|_> @definitions R
12:32:38 <lambdabot> ["Right"]
12:32:58 <_|_> @get-definition toRational
12:32:58 <lambdabot> toRational not defined
12:33:45 <shapr> the number of eval built-ins is very small, I've learned a lot watching Darius build up the functionality as definitions
12:34:09 <_|_> How would one define a new type?
12:34:24 <shapr> a new *type* or a new definition?
12:34:45 <_|_> A type like List or Maybe
12:34:56 <shapr> @definitions l
12:34:56 <lambdabot> ["last","lcFalse","lcIf","lcTrue","length","lexeme","liftLP","liftS","list","listen","local","lookup","lookupDef","lookupRef","lookupTree"]
12:35:00 <shapr> @definitions L
12:35:00 <lambdabot> ["Leaf","Left"]
12:35:21 <_|_> @get-definition list
12:35:21 <lambdabot> list = \\c n l.l c n
12:35:25 <shapr> ah
12:35:43 <shapr> @eval map (\x -> x + 1) [1,2,3]
12:35:43 <lambdabot> [2, 3, 4]
12:36:00 <_|_> @type [1]
12:36:01 <lambdabot> [1] :: Num a => [a]
12:36:12 <shapr> ah, but the @type plugin calls Hugs with the :t command
12:36:15 <shapr> so it's not the same thing
12:36:20 <_|_> Oh yeah.
12:36:41 <_|_> :definitions f
12:36:48 <_|_> @definitions f
12:36:48 <lambdabot> ["fac","fact","factors","factorsOLD","failed","fibs","filter","first","fix","flip","foldTerm","foldl","foldl1","foldr","foldr1","followLinks","free","freevars","from","fromList","fromThen","fromThenTo","fromTo","fst"]
12:37:05 <_|_> @eval [1..4]
12:37:05 <lambdabot> (line 1, column 4):
12:37:05 <lambdabot> unexpected "."
12:37:05 <lambdabot> expecting simple term
12:37:23 <_|_> @eval foldr (+) 0 [1,2,3,4]
12:37:23 <lambdabot> (line 1, column 8):
12:37:23 <lambdabot> unexpected "+"
12:37:23 <lambdabot> expecting simple term
12:37:42 <shapr> @eval fromThenTo 1 4
12:37:43 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:37:45 <shapr> hm
12:37:52 <shapr> @definitions enum
12:37:52 <lambdabot> ["enumFrom","enumFromThen","enumFromThenTo","enumFromTo"]
12:37:59 <_|_> @eval enumFromTo 1 4
12:38:00 <lambdabot> [1, 2, 3, 4]
12:38:23 <shapr> Fun, eh?
12:38:42 <shapr> and it's really good for explaining functional programming stuff on irc
12:38:54 <_|_> I can imagine
12:39:02 <_|_> @eval factors 100
12:39:09 <shapr> there are two lambdabot plugins that wrap GHCi, allowing you to send commands directly to GHCi
12:39:26 <_|_> @get-definition factors
12:39:40 <_|_> whappen?
12:39:48 <shapr> @hello
12:39:56 <shapr> oh, he's still doing factors 100
12:40:13 <shapr> or his host went down
12:40:35 <_|_> sorry, I didn't think factors 100 would be hard
12:41:31 <shapr> might be something else
12:41:37 * shapr checks
12:42:05 <shapr> yah, I think he lost 'net connectivity
12:42:17 <phubuh> you should add a check for algorithms that dont' terminate
12:42:34 <shapr> hopefully it'll come back soon, since lambdabot runs on the same box as gforge
12:46:03 * shapr waits impatiently
12:46:09 <shapr> _|_: have you seen darcs?
12:46:21 <_|_> No, I was going to ask about that.
12:46:33 <shapr> http://www.abridgegame.org/darcs/
12:46:39 <shapr> it's a source code control system written in Haskell
12:46:59 <_|_> Cool!
12:47:27 * _|_ emerges darcs
12:47:33 <shapr> the coolest thing about it is the patch theory behind it
12:49:01 <shapr> it's also cool because you can pull the repository with http, and push changes with email
12:50:22 <Riastradh> Is there no other way to push changes?
12:50:28 <shapr> there are other ways
12:50:36 <shapr> ssh is one
12:50:39 <shapr> I've forgotten the others
12:50:56 * shapr looks
12:51:00 <_|_> shapr: will you use darcs instead of cvs in your gforge?
12:51:21 <shapr> I'd like to say "as well as"
12:51:33 <shapr> since I doubt everyone will want to use darcs 
12:51:42 <_|_> good point
12:51:44 <shapr> I know that kosmikus uses subversion
12:51:49 <shapr> and SyntaxNinja uses arch
12:51:59 <shapr> phubuh uses arch also, last I heard
12:52:03 <phubuh> yup
12:52:14 <phubuh> I haven't tried darcs though
12:52:41 <shapr> I'd like to encourage darcs use on a Haskell sourceforge site,  since that would directly contribute to Haskell, imho
12:53:02 <shapr> plus you don't have to create user accounts to let people commit to darcs
12:53:07 <shapr> so it feels safer to me
12:53:48 <steveh> hey, I've got a query for people ... I have this thing that I do in Haskell and I am wondering if there is a name for it and if there are any performance or storage pitfalls
12:54:16 <steveh> I more or less stumbled onto it on my own but I am sure it is common in FP
12:54:32 <shapr> of course, darcs committers can still commit to the repository test code, so they have as much privelege as a standard user account
12:54:41 <shapr> steveh: what is it?
12:56:11 <steveh> generally, it is "(foldr1 (.) (map insert vals)) empty" , to build a data structure with an empty value and an insert :: a -> Collection a -> Collection a
12:56:33 <steveh> and a list of vals for input
12:57:55 <_|_> steveh: why not foldl insert empty vals?
12:57:58 <Riastradh> foldr insert empty vals
12:58:00 <Riastradh> Heh.
12:58:17 <_|_> Jinx!
12:58:23 <Riastradh> Ploink!
12:58:24 <steveh> oh there is a reason for that
12:58:28 <steveh> let me see what it was
13:00:02 <Riastradh> You wanted to make sure that vals was not empty?
13:00:10 <steveh>  Occurs check: cannot construct the infinite type: a = h a
13:00:10 <steveh> 	Expected type: a -> h a -> a
13:00:10 <steveh> 	Inferred type: a -> h a -> h a
13:00:10 <steveh>     In the first argument of `foldl', namely `insert'
13:00:30 <Riastradh> ...?
13:00:57 <_|_> foldl (flip insert) empty vals
13:01:09 <Riastradh> @type foldl
13:01:10 <shapr> Riastradh: direct, ssh, and email - http://www.abridgegame.org/darcs/manual/node4.html#SECTION00450000000000000000
13:01:13 <Riastradh> ...
13:01:20 <shapr> sorry, lambdabot is taking a break
13:01:30 <_|_> I have to go now.  :-(
13:01:34 <shapr> _|_: nice to meet you
13:01:38 <shapr> come back soon!
13:01:51 <_|_> Thanks, see ya!
13:01:52 <Riastradh> Prelude> :t foldl
13:01:52 <Riastradh> foldl :: (a -> b -> a) -> a -> [b] -> a
13:01:52 <Riastradh> Prelude> :t  foldr
13:01:52 <Riastradh> foldr :: (a -> b -> b) -> b -> [a] -> b
13:01:54 <steveh> _|_: rock!
13:01:59 <steveh> now to figure out what flip does
13:02:09 <shapr> swap args
13:02:11 <Riastradh> Prelude> :t flip
13:02:13 <steveh> gah!
13:02:22 <steveh> i figured out that's what I needed to do
13:02:28 <Riastradh> flip :: (a -> b -> c) -> (b -> a -> c)
13:02:30 <steveh> but still ran into bizarre typing
13:02:39 <steveh> that makes me feel better
13:02:43 <ayrnieu> flip f a b = f b a
13:03:00 <Riastradh> But you don't need to do the flip for foldr.
13:03:27 <Riastradh> [[foldr insert empty vals]] should work just as well as [[foldl (flip insert) empty vals]], except that foldr is lazy.
13:03:28 <steveh> you're right
13:03:46 <steveh> I need a good book on all this stuff
13:03:52 <steveh> I tried Hudak but it didn't do much for me
13:03:57 <Riastradh> http://www.haskell.org/onlinereport/
13:04:10 <steveh> no no, I need a book
13:04:22 <ayrnieu> steve - on all what stuff?
13:04:51 <steveh> just the basics of functional programming in a lazy language with pervasive currying like Haskell
13:05:13 <steveh> the online docs are like a good russian-english, english-russian dictionary
13:05:14 <ayrnieu> the Gentle Introduction works well enough, I suppose.
13:05:31 <steveh> comprehensive in scope but still a freaking foreign language
13:05:52 <Riastradh> Your collection should have an unfold, by the way.
13:05:54 <shapr> well, throw down code till you find things you don't understand, then ask here.
13:05:57 <shapr> that's what I do.
13:05:58 <steveh> the introduction is good but it's not that good
13:06:12 <shapr> have you looked at YAHT?
13:06:26 <steveh> Riastradh: it does. I was just fooling around with the Okasaki book's classes
13:06:34 <ham[marubi]> shapr ftp.uni-heidelberg.de/incoming/texturf.pdf
13:06:45 <steveh> I don't think I have seen YAHT yet
13:06:48 <ham[marubi]> shapr your paper
13:07:04 <shapr> ham[marubi]: thanks!
13:07:05 <steveh> I really respond better to printed materials, books, the more in-depth the better
13:07:14 <steveh> but most of those things approach the theoretical side of FP
13:07:21 <shapr> I'm a learn-by-doing kind of guy.
13:07:23 <steveh> I would like a handle on practical things
13:07:27 <ham[marubi]> shapr your welcome
13:07:44 <shapr> ham[marubi]: looks like I can't read from incoming
13:07:51 <ham[marubi]> hm dang
13:07:52 <steveh> Riastradh: That one was actually "NaiveHeap" :)
13:08:05 * shapr tries again
13:08:11 <steveh> I just wanted to work on how to work with classes and types in haskell
13:08:19 <ham[marubi]> i need a pub ftp folder does someone know one?
13:09:04 <shapr> ham[marubi]: you could zip it and email it to me
13:09:29 <ham[marubi]> what i really would like to see is a book that covers the hardcore math side plus gives nice programming examples since most of the things arent that tough really
13:09:35 <steveh> ah
13:09:40 <steveh> I know why foldr didn't work out for me
13:09:42 <ham[marubi]> shapr k sec ill try that
13:09:49 <steveh> for some reason it was the first thing I tried
13:09:59 <steveh> but I didn't give "empty" an explicit type
13:10:24 <ham[marubi]> shapr what was your addy again?
13:10:32 <steveh> so GHC helpfully sent me chasing down a type inference ambiguity in another part of the code
13:10:42 <shapr> shae at scanned in avian com
13:10:49 <ham[marubi]> ?:)
13:10:59 <shapr> scanned in avian dot com
13:11:48 <steveh> which I could not resolve
13:12:33 <steveh> but now after talking here I have figured out a better way
13:12:35 <steveh> Thanks all :)
13:12:41 <ham[marubi]> hm shit i got mail probs sec
13:25:03 <ham[marubi]> shapr ok i hope it worked was quite a pain :)
13:35:40 <shapr> man, something weird happening on my box
13:35:52 <ham[marubi]> ?
13:35:57 <shapr> processes dying by themselves
13:35:59 <ham[marubi]> shapr got the mail?
13:36:00 <shapr> worrisome
13:36:13 <shapr> no, my mail host has dropped off the net for a bit
13:36:18 <shapr> but I'll check as soon as it comes back
14:17:15 <shapr> g'day awox 
14:17:20 <awox> aaaargh.
14:17:27 * shapr blinks
14:17:51 <Heffalump> hah.
14:17:59 <shapr> hey Heffalump, wassup?
14:18:38 <shapr> On the good side, at least awox puts periods at the end of his sentences.
14:20:58 <Heffalump> :-)
14:22:15 <Heffalump> anyone seen Smerdyakov?
14:22:35 <shapr> not since I banned him.
14:22:49 <shapr> he's on #ocaml and #sml though
14:22:52 <Heffalump> ah, that'd explain his absence :-) What on earth did he do?
14:24:00 <shapr> accumulated being a pain in the ass is probably the most accurate way to decribe it
14:24:27 <Heffalump> He can be a bit of a twat, I guess.
14:24:45 * Riastradh nods in agreement.
14:25:14 <ayrnieu> Don't let him think of you as an American, or he'll start talking about cow-milking and such.
14:25:31 <Heffalump> He does know useful stuff about FP, though.
14:25:42 <Riastradh> ...um, Smerdyakov is an American, ayrnieu.
14:25:55 <ayrnieu> Riastradh - what does that have to do with anything?
14:25:55 <shapr> he does know stuff about FP, no argument there
14:26:25 * Heffalump reads logs
14:26:37 <phubuh> http://www.cnn.com/2004/TECH/internet/01/14/internet.cyborb.ap/index.html
14:27:02 <ayrnieu> I've only ever had trouble with Smerdy in #hprog
14:27:59 <shapr> well, I talked to him in privmsg many times, without much effect
14:28:01 <Heffalump> hmm, refusing to conform to the parameters you laid out for a conversation isn't really unreasonable
14:28:20 <Heffalump> I agree he was being annoying about you and jobs and degrees some days ago
14:28:52 <shapr> neither of those had much to do with it
14:29:47 <shapr> it's really that he tends to find something that he considers wrong, and then hound someone about it if they don't agree
14:30:01 <Heffalump> true.
14:30:18 <Riastradh> And he deems it irrelevant how small the issue is.
14:30:22 <shapr> right
14:30:29 <Heffalump> I can do that too, you know, just ask Igloo :-)
14:30:42 <shapr> at least one person who had just joined the channel some moments before was driven off because of that behaviour
14:31:19 <Riastradh> I'm a pedant, too, but at least I don't hound everyone on every issue, and especially when it's clear that they're getting annoyed.
14:31:31 <shapr> right, agree to disagree is important
14:31:57 <Riastradh> (although lately I've decided to exempt Smerdyakov from that 'everyone')
14:32:18 <ayrnieu> wooh, first try: http://tunes.org/~nef/logs/haskell/04.01.12
14:33:12 <shapr> ?
14:34:15 <earthy> still talking about smerdyakov I see.
14:34:43 <shapr> well, the ISP hosting my gforge server is down... so...
14:34:58 <shapr> hey Heffalump, have you seen PreludeExts.hs?
14:37:51 <shapr> earthy: written any cool code lately?
14:38:15 <earthy> not really
14:38:25 <shapr> ok, written *any* code lately?
14:38:27 <earthy> some testharnesses for the assignments students've handed in.
14:38:35 <earthy> but that's just nasty shell scripting.
14:39:06 <earthy> niw, almost in Nijmegen, time to get off the train.
14:40:14 * shapr is happy to see PreludeExts is popular
14:40:23 <Maddas> Are there any (preferrably not too hard) papers about the Hindley-Milner type interference algorithm?
14:40:41 <shapr> Riastradh made a really cool t-shirt
14:40:52 <Maddas> shapr: I saw that, yeah :)
14:40:52 <Riastradh> http://www.cafeshops.com/ski_calc
14:40:55 <Riastradh> Or skicalc.
14:40:57 <Riastradh> I don't remember.
14:40:59 * shapr grins
14:41:14 <Maddas> Actually, that's the reason I asked. A friend wants to know more about it :)
14:41:29 <phubuh> Maddas: I learned a lot about it (I think) from the class slides and machine problems of CS321 (or maybe CS123) at University of Urban-Champaigne
14:41:56 <phubuh> urbana-champaigne
14:42:20 <phubuh> http://www-courses.cs.uiuc.edu/~cs321/current/
14:42:38 <Maddas> phubuh: Thanks!
14:43:00 <phubuh> whoops, that site looks pretty broken :(
14:43:21 <Maddas> Yeah, links seem to be somewhat broken
14:43:35 <Maddas> I'll poke around and see if I still find anything, though :)
14:43:46 <phubuh> http://www.google.se/search?q=cache:swGTuwbN4L4J:www-courses.cs.uiuc.edu/~cs321/current/lectures/TypeDeriv/7-Slides-Lect.pdf+&hl=sv&ie=UTF-8 :-)
14:44:05 <Maddas> heh, google cache to the rescue. Thanks again :)
14:47:24 <phubuh> I also learned to resolve parsing ambiguities by stratification, and how to implement an interpreter for an ML-like language with continuations and lazy evaluation :D
14:47:35 <phubuh> it was a great course
14:47:40 * phubuh hugs the Internet
14:47:46 <Maddas> Sounds very interesting
14:47:47 * shapr grins
14:52:48 <earthy> ah. home, sweet home, where the wifi is
15:19:02 <Heffalump> PreludeExts.hs?
15:19:07 <shapr> @wiki PreludeExts
15:19:12 <shapr> ack
15:19:38 <ham[marubi]> shapr mail server ok again?
15:19:38 <shapr> um, http://www.haskell.org/hawiki/PreludeExts
15:19:42 <shapr> ham[marubi]: no, not yet
15:19:55 * shapr is getting irritated
15:20:09 * SamB notices a _|_ in the channel
15:20:13 <Riastradh> shapr, what mail server do you use?
15:20:35 <shapr> the one on my colocated box, or another one at the same ISP
15:20:43 <shapr> but that ISP has temporarily dropped off the 'net
15:20:43 <Heffalump> what's wrong with it?
15:20:46 <Heffalump> ah.
15:20:47 * SamB sees that this _|_ has been talking a lot while he was gone
15:20:47 <Riastradh> 'Yes.'
15:21:20 * shapr resolves (ha) to get backup MX
15:21:43 <Riastradh> shapr, I was asking what mail server software you used.
15:22:01 <shapr> oh, postfix on my colo box
15:22:08 * phubuh does Topcoder problems in Haskell
15:22:08 <Heffalump> there's too much in there that's too specialised
15:22:13 <Heffalump> shapr: I can provide that if you want
15:22:45 <shapr> det has also offered backup DNS and MX
15:22:45 * Darius agrees with Heffalump
15:23:15 <shapr> afaiu, I can't actually check mail sent to a backup MX, they just accumulate there until the primary MX comes back, yes?
15:23:22 <Heffalump> correct.
15:23:30 <Heffalump> Without special work at the backup MX host
15:23:37 <shapr> right, ok
15:24:08 <shapr> maybe we should renamed that page HaskellPowerTools
15:24:35 <Heffalump> many of the things do belong in a "super prelude"
15:24:44 <phubuh> much of it is prelude-worthy
15:24:48 <Heffalump> I was just struck by the specialised category theoretic stuff near the beginning
15:25:37 <shapr> I found a bunch of fun stuff locally by doing "locate Util.hs"
15:27:22 <shapr> do you have any code you'd like to contribute?
15:27:34 <ham[marubi]> slightly offtopic but can someone of you help me to prove det( lambda * I - AB ) = det( lambda * I - BA ) ?
15:27:57 <Heffalump> shapr: maybe, but not right now.
15:28:00 <shapr> ok
15:28:07 * phubuh wonders if flip (.) is PreludeExts-worthy, and what to call it
15:28:21 <Heffalump> if you don't have a good name for it then it's probably not.
15:28:41 <Heffalump> though I imagine some mathematical program construction type person will have a name for it
15:28:52 <phubuh> no, not that kind of name
15:28:59 <phubuh> something like (-->) or something :-)
15:29:29 <Heffalump> I didn't mean a rude name, I meant something like "before".
15:30:44 <phubuh> readFile "foo" >>= head 5 --> lines --> reverse --> unlines --> print is more indicative of the natural data dependency and evalution order than its (.)-using friend, imho
15:31:13 <phubuh> well, not that it works
15:31:16 <Heffalump> actually, doesn't >>> from the Arrows class do just that for pure Arrows?
15:31:17 <shapr> ooh, lm_sensors is in 2.6.0
15:31:34 <shapr> I think it does
15:32:06 * shapr tries
15:32:34 <shapr> err, it's not -farr
15:32:55 <Heffalump> -farrows?
15:33:06 <phubuh> oh, (...) is definable
15:33:07 <shapr> aha
15:33:29 <shapr> still can't do :t (>>>)
15:33:38 <shapr> which sucks
15:33:56 <Heffalump> if it's arrows syntax, rather than a class member, it doesn't have a type
15:34:01 <Heffalump> it's like trying to do :t (<-)
15:34:04 <shapr> yah
15:36:37 <shapr> shouldn't "foo x y = x >>> y" compile?
15:36:41 * shapr suspects user error
15:36:55 <Darius> phubuh: So is -->
15:37:04 <Heffalump> if >>> is just arrows syntax, you'd need a proc to introduce a usage of it
15:37:12 <Darius> >>> isn't
15:37:28 <Heffalump> did you :l Arrows or whatever, then?
15:38:32 <shapr> it has its own module?
15:38:47 <Darius> Control.Arrow(s)
15:38:57 <shapr> doh
15:39:11 <shapr> (>>>) :: forall a d b c. (Arrow a) => a b c -> a c d -> a b d
15:39:28 <Darius> @type let f --> g = g . f in readFile "foo" >>= take 5 --> lines --> reverse --> unlines --> print
15:39:38 <shapr> lambdabot is on vacation for the moment
15:39:39 <Darius> oh yah
15:39:53 <Heffalump> ok, so it has the same type as (.) for the pure arrow
15:40:27 <phubuh> Darius: yeah, I've used --> for it in the past
15:41:05 <shapr> ord >>> chr :: Char -> Char
15:41:06 <shapr> interesting
15:43:09 <shapr> so >>> does work like flip (.)
15:43:16 <shapr> neat, I learned something
15:43:32 <phubuh> that's nifty
15:44:31 <phubuh> its precedence doesn't play nice with >>= though
15:44:35 <phubuh> > readFile "/etc/passwd" >>= lines >>> reverse >>> unlines >>> print
15:44:36 <phubuh>  
15:44:36 <phubuh> <interactive>:1:
15:44:36 <phubuh>     precedence parsing error
15:44:36 <phubuh>         cannot mix `(>>=)' [infixl 1] and `(>>>)' [infixr 1] in the same infix expression
15:44:44 <shapr> ah, too bad
15:46:30 <shapr> and <<< is .
15:47:34 <shapr> now you just need an infix lifter
15:52:34 <phubuh> infix lifter?
15:53:12 <shapr> err, I was trying stuff with `liftM`
15:53:30 <shapr> lines >>> reverse >>> unlines >>> print :: String -> IO ()
16:16:25 <whiskas> Hello
16:16:39 <shapr> hi whiskas 
16:16:52 <shapr> what's up?
16:17:00 <whiskas> Well
16:17:13 <whiskas> I've been wanting to learn FP for quite some time
16:17:17 <whiskas> But dunno how to start
16:17:21 <shapr> @learn
16:17:25 <phubuh> now's the best time to start
16:17:26 <shapr> ack, the bot is gone
16:17:36 <shapr> http://www.haskell.org/learning.html
16:17:36 <whiskas> From what I've learnt, Ocaml and Haskell seems to be the most popular FP languages
16:17:47 <whiskas> I've tried my luck with Ocaml, but got nowhere
16:17:56 <whiskas> So I said to myself, "What the heck, let's try Haskell"
16:18:09 <whiskas> Though I must admit Ocaml has some appealing features...
16:18:14 <shapr> and yourself said "yah!"
16:18:36 <whiskas> So it seems, so it seem
16:18:37 <whiskas> s
16:18:52 <shapr> Haskell has a few differences from OCaml
16:19:22 <whiskas> I've tried to learn many languages so far, but whatever I do, I find myself returning to C++
16:19:34 <shapr> well, if that fits your head
16:19:37 <whiskas> (Which makes some kind of FP possible)
16:20:05 <shapr> I've learned many languages, and every once in a while I find one I really love.
16:20:19 <whiskas> Ooh? Care to share?
16:20:25 <shapr> Python and Haskell so far
16:20:38 <whiskas> Humm, have you tried Ruby?
16:20:39 <phubuh> FP in C++ is ... interesting.  I spent like 50 lines of code implementing the compose operator :-)
16:20:43 <shapr> I have tried Ruby
16:21:02 <shapr> I think Ruby is more OO than Python, and more dynamic, but explicit END seems a great waste to me
16:21:13 <shapr> significant whitespace appeals to me
16:21:19 <shapr> both Python and Haskell have that
16:21:20 <SamB> >>> is in Control.Arrow
16:21:26 <whiskas> Aah, then we're not on the same ground here
16:21:34 <whiskas> Anyways, let's return to FP :-)
16:21:36 <shapr> right
16:21:38 <Heffalump> phubuh: why did it need 50 lines of code? What was your first-class representation of functions?
16:21:44 <SamB> oh, you found it, nevermind...
16:22:19 <shapr> whiskas: anyways, I've learned a lot of neat tricks from various languages, Self and JavaScript do prototype rather than object oriented
16:22:25 <whiskas> The problem to me learning FP it's that it seems it doesn't fit my mind
16:22:28 <shapr> and Joy and PostScript are stack-based
16:22:33 <ayrnieu> and LSD.
16:22:42 <phubuh> Heffalump: it composed two of any type that supports the () operator, into a struct with an overloaded operator()
16:22:49 * SamB used to LOVE python, but that was before Haskell bit him
16:22:54 <shapr> SamB: same here
16:23:10 <phubuh> I'm probably exaggerating a bit by 50, it was probably closer to 20
16:23:10 <shapr> now I just like Python a whole lot, but LOVE Haskell.
16:23:14 <Heffalump> ok :-)
16:23:30 <phubuh> it was fun to do though, in a befunged sort of way :-)
16:23:33 <shapr> whiskas: FP really does require a different mental approach
16:23:54 <shapr> how much code did you write in OCaml?
16:24:08 <ayrnieu> whiskas - what programming style fits your mind?
16:24:11 <whiskas> Well, like ~100 lines
16:24:15 <whiskas> ayrnieu: OO, definitely
16:24:19 <whiskas> ayrnieu: So far, that is
16:24:32 * ayrnieu shrugs.
16:24:42 <Riastradh> whiskas, typeclasses are typically what you really want when you think you want an object system.
16:24:50 <phubuh> I used to love OO
16:24:52 <shapr> I think I had to write several hundred lines of Haskell before I started getting it
16:24:53 <whiskas> Typeclasses?
16:25:00 <shapr> yah, typeclasses rock
16:25:08 <phubuh> but now I'm disgusted by it
16:25:14 <phubuh> which you can see as a warning if you want :-)
16:25:14 <whiskas> Ohh?
16:25:19 <whiskas> :-))
16:25:23 <ayrnieu> A nifty Mercury 'battleship challenge' exists designed to get people to use typeclasses in that language.
16:25:41 <shapr> whiskas: http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
16:25:45 <ayrnieu> It mostly corresponds to Haskell.
16:25:51 <whiskas> Ok, let's take a look
16:26:16 <shapr> that's just a dive-in intro to Haskell, it shows off a few basic features
16:26:23 <shapr> down near the bottom there are typeclasses
16:26:46 <phubuh> would it be bad if Show was derived automatically?
16:26:49 <whiskas> Hmm, so is ML the grandfather of FP?
16:27:03 <shapr> actually FP was the first, I think
16:27:07 <shapr> ML was the second
16:27:26 <SamB> is LISP the grandfather?
16:27:38 <shapr> probably
16:27:50 <ayrnieu> Lisp has little do with FP and everything to do with itself.
16:28:00 <SamB> s/is/was/
16:28:08 <Riastradh> Most Lisps, ayrnieu.  Scheme is pretty arguably a functional language.
16:28:31 <SamB> scheme has lots of !s and no cool type system
16:28:53 <ayrnieu> Riastradh - I find it more interesting a 'lisp-like' language than a 'functional language', particularly since the function languages that interest me have a great deal more common to them.
16:29:00 <Riastradh> Lots of !s?  Let's see...SET!, SET-C{A,D}R!, and {VECTOR,STRING}-SET!.
16:29:13 <ayrnieu> also, interestingly.
16:30:16 <shapr> whiskas: got to the typeclasses part?
16:30:46 <whiskas> shapr: Not really :-(
16:30:51 <whiskas> I really need a good intro
16:31:05 <ayrnieu> whiskas - a good intro to what?
16:31:15 <whiskas> To Haskell, of course
16:31:22 <shapr> whiskas: what parts of that file do you have questions about?
16:31:22 <ayrnieu> whiskas - www.haskell.org references tutorials.
16:31:37 <whiskas> shapr: Don't ask :-(
16:31:43 <ayrnieu> whiskas - I'd suggest that you get GHC and start walking through a number of tutorials.
16:31:45 <Darius> shapr: Your "complex type" isn't very complex, especially compared to the Tree above.
16:31:45 <shapr> well, how else can I help you?
16:31:55 <whiskas> I'd rather start digging into the docs on haskell.org
16:31:59 <whiskas> Don't you think?
16:32:14 <shapr> whatever you think works best for you
16:32:19 <shapr> different people learn different ways
16:32:26 <shapr> Darius: suggestions?
16:32:44 <whiskas> Hmm, do you think that FP goes well with listening to Floyd? :-P
16:32:46 <Darius> shapr: delete the People data type.
16:33:34 <shapr> ok
16:33:56 * Darius has hacked Haskell listening to Bad Religion, Jimmy Eat World, Alkaline Trio, Sublime and Red Hot Chili Peppers... no Floyd.
16:34:14 <whiskas> Heh, O.K.
16:34:27 <whiskas> Was just a (rather stupid) joke
16:34:29 <shapr> see, I think FP fits with Steve Reich, The Distillers, Nine Inch Nails, Led Zeppelin, Jimi Hendrix
16:34:48 <ayrnieu> whiskas - I'd suggest some nice Chinese pop music.
16:34:50 <shapr> Ani DiFranco is really better suited to Python though
16:34:59 <whiskas> Hold it, now, Led Zepp and Jimi Hendrix don't go well with NIN
16:35:15 <shapr> but all three of them go well with FP
16:35:52 <shapr> see... FP crosses boundaries, unifies disparate categories, etc
16:36:10 * shapr particularly enjoys sneaking in category theory jokes
16:36:18 <whiskas> :-))
16:36:23 <shapr> maybe I should have mentioned adjunctions or something
16:36:35 <Heffalump> do you know enough category theory to do this?
16:36:52 <shapr> I understood Esa's description well enough
16:37:01 <shapr> not sure if that counts
16:37:37 <whiskas> What the heck is category theory?
16:38:00 <Riastradh> The theory of categories.
16:38:36 <ayrnieu> whiskas - something that you needn't concern yourself with, for the most part.
16:38:39 <shapr> Darius: I don't know Sublime and Alkaline Trio, do they have free mp3s available?
16:38:40 * shapr googles
16:38:43 <whiskas> ayrnieu: I see
16:39:17 <Darius> You don't know Sublime?  I don't believe you.  I think you only don't know that you know Sublime.
16:39:21 <Darius> I can see Alkaline Trio though.
16:39:46 <whiskas> Ha haha
16:39:52 <whiskas> "What I've got..."
16:39:58 <Riastradh> Sublime?
16:40:09 <Darius> Santaria
16:40:14 <Riastradh> Santaria?
16:40:30 <shapr> Darius: could be. my exposure to the world outside of computers isn't very high at the moment
16:40:32 <whiskas> Rather, Santeria
16:40:38 <shapr> @listmodules
16:40:38 <betabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","ghci","hello","karma","more","quote","seen","state","system","topic","type"]
16:40:43 <shapr> oh, neat
16:40:47 <shapr> @listcommands ghci
16:40:47 <betabot> Module ghci provides the following commands: ["ghci"]
16:41:10 <whiskas> @learn
16:41:10 <betabot> http://www.haskell.org/learning.html
16:41:21 <ayrnieu> whiskas - people enjoy supposing that functional programming requires knowledge of all sorts of random stuff like 'category theory' because such offer useful ways of looking at programs written in a functional programming language.
16:41:43 <shapr> but really FP just requires that you use functions like hammers
16:41:58 <shapr> @eval map (\x -> x + 1) [1,2,3]
16:41:59 <betabot> [2, 3, 4]
16:42:05 <Heffalump> the concept of a higher-order, or even just first-class, hammer worries me.
16:42:15 <whiskas> Wouldn't that require a more Mathematical-inclined mind
16:42:31 <shapr> whiskas: nah, I never made it through calculus, but I'm doing fine in Haskell.
16:42:31 <ayrnieu> whiskas - you'll hear people supposing that you should learn about 'monads' just to do IO in Haskell -- don't let them fool you!
16:42:38 <Darius> Heffalump: Well, I guess blacksmiths could use a hammer to hammer a hammer.
16:42:44 <Heffalump> hmm.
16:42:58 <whiskas> shapr: Well, Maths are more that calculus :-P
16:42:59 <shapr> first class hammer - http://www.estwing.com/
16:43:24 <shapr> yah, there is a bit more that qualifies as math
16:43:33 <Darius> just a bit
16:43:38 * ayrnieu does math all the time, to calm himself.
16:43:40 <whiskas> :-))
16:44:12 <shapr> anyways, you don't even require calculus to do Haskell
16:44:19 <whiskas> So is there any Haskell standard?
16:44:25 <_|_> whiskas: a mathematical mind helps with all programming, but a mathematical mind will be less frustrated with FP than with imperative programming
16:44:28 <Riastradh> http://www.haskell.org/onlinereport/
16:44:56 <whiskas> Right on time, Riastradh
16:45:41 <whiskas> Well, I have decided: I want to become a Haskell/Ocaml guru :-P
16:45:50 <_|_> excellent!
16:46:08 <shapr> yay!
16:46:15 <whiskas> (And I'm pretty serious about it, now that I've mentioned it)
16:46:28 <_|_> you'll be glad you did.
16:46:38 <ayrnieu> oh, but not also a Mercury guru?  well, OK.
16:46:49 <Heffalump> is there an O'Caml standard then?
16:46:51 <whiskas> Mercury?
16:47:03 <whiskas> Heffalump: Not that I know of, but AFAIK< there's only one implementation
16:47:07 <whiskas> So that would be the standard
16:47:09 <shapr> mercury is more of a logic/constraint language
16:47:14 <ayrnieu> Heffalump - an SML standard exists (hence the name: 'standard ML').  O'Caml defines itself by its implementation.
16:47:16 <Heffalump> that's true
16:47:18 <_|_> What I love about FP is that my programs work the first time MUCH more often
16:47:25 <ayrnieu> shapr - not really, but OK.
16:47:36 <Heffalump> ayrnieu: I'm aware of that, but thought I might have missed someone deciding to publish a spec or something.
16:47:42 <whiskas> So, getting back to FP, can I do networking, UIs, and stuff like that?
16:47:42 <shapr> I like the raw, unbridled, power you get from FP
16:47:47 <ayrnieu> whiskas - yes.
16:47:50 <Riastradh> Heffalump, there's the manual and that's it.
16:47:50 <shapr> whiskas: betabot is written in Haskell
16:48:01 <shapr> ham[marubi] wrote an OpenGL thingy today
16:48:02 <whiskas> Aha
16:48:05 <whiskas> @version
16:48:06 <betabot> Sorry, I don't know the command "version", try "lambdabot: @listcommands"
16:48:13 <ayrnieu> whiskas - GHC, in particular, makes for very easy networking.  Use its concurrency modules.
16:48:16 <Riastradh> whiskas, and there's this allegedly nifty library called 'fudgets' that has some cool techniques for GUI manipulation.
16:48:25 <shapr> there are wxHaskell bindings
16:48:28 <whiskas> Hmm
16:48:43 <shapr> gtk 1 and 2 bindings
16:48:44 <ayrnieu> whiskas - take a look at concurrent-haskell.ps
16:48:46 <whiskas> If I change the implementation, would that limit my portability?
16:48:54 <whiskas> Or I shouldn't worry about that?
16:48:54 <ayrnieu> whiskas - I don't understand your question, sorry.
16:48:58 <whiskas> Well
16:49:31 <whiskas> You said that GHC makes for very easy networking; would that mean that the same code won't work with HUGS?
16:49:48 <shapr> I don't think hugs has network support
16:49:48 <ayrnieu> whiskas - eh, 'Hugs'.
16:50:02 <shapr> not sure about hbc or nhc
16:50:09 <Riastradh> Is there anyone except for beginners who even uses anything but GHC?
16:50:09 <whiskas> Well, pardon my silly questions, but I'm new
16:50:19 <shapr> Riastradh: LVM!
16:50:22 <whiskas> That's why I asked if there is a Haskell standard
16:50:22 <Riastradh> LVM?
16:50:25 <Darius> HBC isn't even Haskell 98
16:50:26 <shapr> there's Helium, and it's looking interesting
16:50:30 <ayrnieu> whiskas - Concurrent Haskell in particular allows for easy networking.
16:50:31 <Heffalump> the Haskell standard doesn't include networking libraries
16:50:34 <Heffalump> (IIRC)
16:50:40 <shapr> there's also the new compilers uu.nl is working on...
16:50:44 <shapr> what's it called again?
16:50:46 <Heffalump> UHC.
16:50:48 <Riastradh> uu.nl?
16:50:48 <Heffalump> and Helium.
16:50:50 <shapr> yes, that one
16:50:53 <Heffalump> www.cs.uu.nl
16:50:55 <ayrnieu> whiskas - many extensions to the standard exist, such as Concurrent Haskell, Template Haskell, and such.
16:50:56 <shapr> UHC and Helium
16:50:59 <Darius> Actually, I'd recommend either Helium or GHC for beginners.
16:51:11 <ayrnieu> I wouldn't recommend Helium, but OK.
16:51:12 <Darius> (I'd probably also recommend NHC, but I know very little about it)
16:51:22 <whiskas> Ok, I'm totally lost, I have to admit
16:51:30 <shapr> whiskas: install GHC, grab a tutorial
16:51:33 <shapr> ask questions here
16:51:36 <whiskas> With - say C++ - things would be a lot easier if I were a begginer
16:51:42 <ayrnieu> whiskas - start by getting GHC and going through tutorials on haskell.org, as I suggested a while ago.
16:51:45 <ayrnieu> whiskas - not really.
16:51:50 <shapr> whiskas: I dunno, I tried to learn C++ once
16:51:56 <whiskas> Well, that's how I felt
16:52:03 <ayrnieu> whiskas - C++ wins in that everyone says "go buy a book" instead of "read all the fine online documentation"
16:52:25 * whiskas is downloading GHC
16:52:32 <ayrnieu> whiskas - C++ has poor online documentation for the most part, and this hurts it because it defines an incredible baroque syntax.
16:52:37 <ayrnieu> also, incredibly.
16:53:02 <shapr> it's a funny old world
16:53:08 * shapr has been rereading terry pratchett
16:53:15 <ayrnieu> shapr - yay.  Reading what?
16:53:31 <shapr> I'm going through the discworld series for the ... third or fourth time
16:53:45 <shapr> I'm on Small Gods right now
16:53:48 <whiskas> Grr, you're so smart for me
16:53:58 <ayrnieu> I still have only read a small subset of the discworld series.
16:54:07 <ayrnieu> whiskas - er, what?
16:54:09 <shapr> I haven't read the most recent one or two
16:54:18 <ayrnieu> whiskas - who do you speak to?
16:54:28 <shapr> he's speaking to GHC, I'm sure.
16:54:32 <shapr> I say that too
16:54:34 <whiskas> :-))
16:54:51 <shapr> @ghci "too smart for me!"
16:54:56 <betabot> "too smart for me!"
16:55:20 <ayrnieu> @ghci x <- getChar; putChar x
16:55:24 <betabot> <interactive>:1: parse error on input `;'
16:55:40 <shapr> @ghci putStrLn "foo"
16:55:42 <betabot> You aren't allowed to execute that statement.
16:55:42 <ayrnieu> @ghci getChar >>= \x -> putChar x
16:55:45 <betabot> You aren't allowed to execute that statement.
16:55:52 <shapr> it doesn't like IO types
16:55:57 <Riastradh> Eta-reduce, ayrnieu, eta-reduce!
16:55:58 <shapr> for safety reasons of course
16:56:14 <Darius> Riastradh, the Schemer, says it.
16:56:20 <whiskas> Hmm, nice MSI installer for GHC
16:56:49 <Riastradh> Darius, but I'm not talking about Scheme.
16:57:07 <ayrnieu> oh, on windows?  a nice COM client system with Hugs exists for you.  I've written something to control MS Word, with it.
16:57:08 <Darius> I know, in that case it would be fine for Scheme to.
16:57:16 <opet> hey whiskas 
16:57:32 <whiskas> opet: What are you doing here? :-P
16:57:43 <opet> ghc 6.2 doesn't work on freebsd 5.1 :(
16:57:48 <whiskas> Too bad
16:57:49 <ayrnieu> @ghci let _ = unsafePerformIO (getChar >>= \x -> putChar x) in 10
16:57:49 <betabot> You aren't allowed to execute that statement.
16:57:56 <opet> whiskas: I'm always in here. I do that idling thing
16:57:57 * ayrnieu sticks his tongue out.
16:58:06 <shapr> ayrnieu: Darius found several ways around it
16:58:19 <ayrnieu> shapr - nifty.  What ways?
16:58:27 * shapr looks
16:58:30 <opet> obraun compiled the boostrap compiled on 5.2-current and it breaks on a non-dynamic 5.1
16:58:31 <_|_> @ghci :t unsafePerformIO
16:58:31 <betabot> You aren't allowed to execute that statement.
16:58:34 <opet> boo wah
16:58:40 <_|_> @ghci :t 1
16:58:44 <betabot> 1 :: forall t. (Num t) => t
16:58:54 <_|_> heh
16:58:55 <ayrnieu> @ghci :t putChar
16:59:00 <betabot> putChar :: Char -> IO ()
16:59:10 <Riastradh> @ghci :t IO.unsafePerformIO
16:59:11 <betabot> You aren't allowed to execute that statement.
16:59:13 <Heffalump> @ghci putStrLn "foo"
16:59:15 <_|_> @ghci let x = 3 in x
16:59:15 <betabot> You aren't allowed to execute that statement.
16:59:20 <betabot> 3
16:59:20 <_|_> bah
16:59:34 <_|_> oh.  too many cooks.
16:59:37 <ayrnieu> @ghci :t x <- putChar 'x'
16:59:41 <betabot> not an expression: `x <- putChar 'x''
16:59:50 <shapr> see, should I give away Darius' answers to the puzzle? or should I let you guys explore some?
17:00:02 <ayrnieu> @ghci :t x <- getChar
17:00:06 <Heffalump> he found a way of doing unsafePerformIO?
17:00:06 <betabot> not an expression: `x <- getChar'
17:00:11 <SamB> @ghci :t funsafety
17:00:12 <Heffalump> :t do x <- getChar
17:00:16 <betabot> Variable not in scope: `funsafety'
17:00:22 <Heffalump> @ghci :t do x <- getChar
17:00:27 <betabot> <interactive>:1: The last statement in a 'do' construct must be an expression
17:00:27 <shapr> Heffalump: he found several different ways
17:00:33 <SamB> @ghci :t unsafeNothing
17:00:37 <betabot> Variable not in scope: `unsafeNothing'
17:00:44 <Darius> As long as they don't "explore" -certain- possibilities with betabot...
17:00:44 <ayrnieu> @ghci :t let x = putStr "foo" in x
17:00:49 <betabot> let x = putStr "foo" in x :: IO ()
17:00:57 <shapr> first he used :def, so that got disabled
17:01:06 <Heffalump> @ghci let x = unsafePerformIO
17:01:07 <betabot> You aren't allowed to execute that statement.
17:01:23 * Heffalump goes to bed instead
17:01:29 <Darius> Heffalump: I found six different ways of performing arbitrary IO.
17:01:44 <shapr> see, I think that's worth a haskell-cafe post at least
17:01:45 <Heffalump> oh, arbitrary IO, rather than just doing an unsafePerformIO?
17:02:00 <ayrnieu> Did I just find one with 'let x = putStr "foo" in x' ?
17:02:15 <Heffalump> @ghci let x = putStr
17:02:24 <Heffalump> @ghci x "foo"
17:02:27 <betabot> You aren't allowed to execute that statement.
17:02:29 <Darius> ayrnieu: It'd need to execute it, otherwise it's no fun.
17:02:45 <Heffalump> oh, it checks the type, right
17:02:52 <Heffalump> I think I'll go to bed instead.
17:03:24 <SamB> while we are checking types, how about apropos-by-type?
17:03:30 <shapr> @ghci $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
17:03:34 <betabot> heyaheya3
17:03:42 <ayrnieu> ah, nifty.
17:03:47 <shapr> yah, I was impressed
17:03:56 <shapr> SamB: haddock can do it
17:04:07 <Darius> I'm wondering why it prints "heya" twice.
17:05:10 <shapr> @ghci $( Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") [| putStr "heya" |] )
17:05:14 <betabot> heya()
17:05:21 <ayrnieu> @ghci $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| |] )
17:05:26 <betabot> <interactive>:1: parse error on input `|]'
17:05:31 <ayrnieu> @ghci $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| 0 |] )
17:05:35 <betabot> heya
17:05:35 <betabot> heya
17:05:35 <betabot> 0
17:06:10 <ayrnieu> did you write the go-between in Haskell? =)
17:06:29 <shapr> it's a lambdabot plugin that calls ghci
17:06:40 <SamB> so, why is template haskell turned on?
17:07:02 <Darius> so people can do things like
17:07:11 <shapr> -fglasgow-exts -fno-th left it on
17:07:12 <Darius> @ghci :t let ?foo = 3 in 5
17:07:13 <shapr> strangely
17:07:16 <betabot> let ?foo = 3 in 5 :: forall t. (Num t) => t
17:07:32 <ayrnieu> @ghci let x = $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| 0 |] )
17:07:34 <shapr> that's not an implicit parameter?
17:07:37 <betabot> heya
17:07:43 <ayrnieu> @ghci x
17:07:47 <betabot> 0
17:07:52 <shapr> aha
17:07:58 <shapr> ayrnieu: interesting!
17:08:12 <shapr> very weird, but interesting
17:08:17 <Darius> It's already been spliced by the time x is used.
17:08:28 <Darius> It's performing the IO at "compile"-time.
17:08:54 * shapr has evil dreams of writing typesafe runtime loaders that work that way
17:09:24 <ayrnieu> But this lets you avoid the repetition and the return value, anyway.
17:09:35 <ayrnieu> @ghci let _ = $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| 0 |] )
17:09:39 <betabot> heya
17:09:53 <SamB> @ghci $( Language.Haskell.THSyntax.Q [| putStr "hello" >> return () |] )
17:09:54 <shapr> so why is it repeating in the first place?
17:09:56 <betabot> You aren't allowed to execute that statement.
17:09:56 <Darius> @ghci let True = False
17:10:37 <ayrnieu> @ghci let _ = $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| putStrLn "there-a" |] )
17:10:38 <SamB> @ghci $( Language.Haskell.THSyntax.Q return putStr >> [| \f -> f "hello" >> return () |] )
17:10:42 <betabot> heya
17:10:46 <betabot> <interactive>:1:
17:10:46 <betabot>     Couldn't match `Language.Haskell.THSyntax.Q a' against `t -> t1'
17:10:46 <betabot> 	Expected type: Language.Haskell.THSyntax.Q a
17:10:46 <betabot> 	Inferred type: t -> t1
17:10:47 <betabot>     Probable cause: `Language.Haskell.THSyntax.Q' is applied to too many arguments in the call
17:10:49 <betabot> 	(Language.Haskell.THSyntax.Q return putStr)
17:10:51 <betabot>     In the first argument of `(>>)', namely
17:10:53 <betabot> 	`Language.Haskell.THSyntax.Q return putStr'
17:11:05 <ayrnieu> who did that?
17:11:06 <ayrnieu> @ghci let _ = $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| putStrLn "there-a" |] )
17:11:10 <betabot> heya
17:11:19 <SamB> @ghci $( Language.Haskell.THSyntax.Q return putStr "hello" >> [| return () |] )
17:11:23 <betabot> <interactive>:1:
17:11:23 <betabot>     Couldn't match `Language.Haskell.THSyntax.Q a' against `t -> t1'
17:11:23 <betabot> 	Expected type: Language.Haskell.THSyntax.Q a
17:11:23 <betabot> 	Inferred type: t -> t1
17:11:24 <betabot>     Probable cause: `Language.Haskell.THSyntax.Q' is applied to too many arguments in the call
17:11:26 <betabot> 	(Language.Haskell.THSyntax.Q return putStr "hello")
17:11:28 <betabot>     In the first argument of `(>>)', namely
17:11:30 <betabot> 	`Language.Haskell.THSyntax.Q return putStr "hello"'
17:11:46 * SamB decides to learn TH before trying that again
17:11:52 <shapr> :-)
17:11:52 <ayrnieu> wise.
17:12:02 <ayrnieu> me too =)
17:12:11 <ayrnieu> @ghci $( Language.Haskell.THSyntax.Q (putStrLn "heya") >> [| putStrLn "there-a" |] )
17:12:13 <betabot> You aren't allowed to execute that statement.
17:12:34 <Darius> @let doIt e = Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") e
17:12:34 <betabot> Sorry, I don't know the command "let", try "lambdabot: @listcommands"
17:12:42 <Darius> @ghci let doIt e = Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") e
17:12:59 <ayrnieu> @ghci doIt $ putStrLn "hello!"
17:13:02 <betabot> You aren't allowed to execute that statement.
17:13:04 <Darius> @ghci $(doIt [| putStr "hi" |])
17:13:08 <betabot> hi()
17:13:31 <ayrnieu> @ghci :import Network
17:13:36 <betabot> unknown command `:import'
17:13:36 <betabot> use :? for help.
17:13:47 <Riastradh> @ghci :m Network
17:14:10 <shapr> that looks scary
17:14:17 <Darius> @ghci let doIt = $( Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O" )
17:14:23 <Riastradh> That looks like a big, gaping hole.
17:14:40 <Darius> @ghci doIt (putStr "heya")
17:14:45 <betabot> heya()
17:14:50 <ayrnieu> For someone here to write a 'hello server' in!
17:15:05 <Darius> Riastradh: What's wrong with loading a module if you couldn't perform IO.
17:15:20 <Darius> It's not like, :m /etc/passwd would do anything.
17:15:55 <shapr> Lunar^ wrote a GHCiModule first
17:16:10 <shapr> Hampus Ram wrote this GHCiModule, with some safety mechanisms
17:16:21 <SamB> Darius: what if you also somehow get a module containing calls to the likes of unsafePerformIO into the heirarchical libs?
17:16:37 <ayrnieu> @ghci :m System.Posix.Files
17:16:40 <Darius> You can just access them through qualified names anyways.
17:16:51 <Lunar^> shapr: It's another one ?
17:16:54 <Darius> @ghci :t GHC.Base.lazy
17:16:59 <betabot> GHC.Base.lazy :: forall a. a -> a
17:17:00 <shapr> Lunar^: yes, it's another one
17:17:11 <shapr> it has some access control
17:17:20 <ayrnieu> @ghci doIt (fileExist "/etc/passwd")
17:17:25 <betabot> True
17:17:32 <Lunar^> Seems so... but Darius knows too well TH
17:17:41 <Darius> Only two were TH solutions.
17:17:46 <Lunar^> urg
17:17:49 <Darius> There's one very simple one.
17:17:59 <Darius> And one very scary one.
17:18:08 <shapr> oh, do the unsafeCoerce trick!
17:18:17 <ayrnieu> @ghci :m System.Posix.Directory
17:18:24 <_|_> @ghci :!ls -l /etc/passwd
17:18:25 <betabot> You aren't allowed to execute that statement.
17:18:27 <SamB> shapr: oh. yeah. like we want to see him crash it...
17:18:33 * shapr grins
17:18:53 <Lunar^> shapr: I'll be glad to have a copy of the source if it's possible
17:18:58 <ayrnieu> @ghci doIt (getWorkingDirectory >>= \x -> putStrLn x)
17:18:59 <Lunar^> (even with the holes)
17:19:01 <SamB> why do we call them statements and not imperatives?
17:19:03 <betabot> /home/shae/build/haskell/darcs/hlibs/hlibs/lambdabot
17:19:03 <betabot> ()
17:19:15 <Darius> One brutal coercion based one crashed, the other seemed to work and should always work.
17:19:29 <shapr> Lunar^: sure!
17:19:41 <Darius> Of course, I tested these on a local GHCi not on betabot first.
17:20:00 <Riastradh> SamB, because people were idiots a while ago.  Statement would make most sense in a logic language, but nooo, someone had to decide it means an imperative in programming.
17:20:02 <Darius> doIt (getWorkingDirectory >>= putStrLn)
17:20:10 <shapr> Lunar^: http://shapr.homelinux.net/~shae/GhciModule.hs
17:20:28 <shapr> not sure if that's the latest version
17:20:34 <ayrnieu> @ghci :m Control.Concurrent Network
17:20:45 <SamB> Riastradh: but this is FP. most of what you call statements are in fact statements, in FP. or at least declarations.
17:23:40 <shapr> @ghci GHC.Base.I# (GHC.Base.getTag (Just 3))
17:23:41 <_|_> @ghci :t xIOx
17:23:45 <betabot> 1
17:23:45 <betabot> You aren't allowed to execute that statement.
17:23:53 <ayrnieu> doIt (readFile "/etc/hostname" >>= \x -> putStrLn x)
17:24:04 <ayrnieu> xIOx ?
17:24:05 <shapr> :t GHC.Base.getTag
17:24:18 <shapr> @ghci :t GHC.Base.getTag
17:24:23 <betabot> GHC.Base.getTag :: forall a. a -> GHC.Prim.Int#
17:24:33 <_|_> @ghci "IO"
17:24:35 <betabot> You aren't allowed to execute that statement.
17:24:44 <_|_> That shouldn't be illegal
17:24:50 <shapr> yup, I agree
17:25:07 <shapr> any suggestions for a truly type-based checker?
17:25:42 <ham[marubi]> damn that proof gives me the creeps
17:26:05 <SamB> shapr: it could wait until after the :: to start checking types, at least?
17:26:08 <ayrnieu> ham - which proof?
17:26:16 <ham[marubi]> slightly offtopic but can someone of you help me to prove det( lambda * I - AB ) = det( lambda * I - BA ) ?
17:26:31 <shapr> SamB: that's a good point
17:26:48 <Darius> @ghci let uPST (GHC.ST.ST st) = case st GHC.Base.realWorld# of (# _,a #) -> a
17:26:54 <SamB> no quotation  marks to confuse it after the :: ;-)
17:26:58 * shapr wonders if types are instances of Eq
17:27:00 <ham[marubi]> I = identity, A B matrices which can be not invertable
17:27:22 <shapr> realWorld# is scary
17:27:27 * shapr prefers IRC
17:27:33 <SamB> Darius: ghci doesn't like unboxed tuples, last I checked
17:28:00 <shapr> @ghci :t uPST
17:28:05 <betabot> uPST :: forall a. GHC.ST.ST GHC.Prim.RealWorld a -> a
17:28:09 <Darius> @ghci let coerce a = uPST (Data.STRef.writeSTRef r a >> Data.STRef.readSTRef r) where r = uPST (Data.STRef.newSTRef undefined)
17:28:15 <Darius> @ghci :t coerce
17:28:20 <betabot> coerce :: forall a a1. a1 -> a
17:28:33 <Darius> shapr: -That- is scary.
17:28:35 <SamB> Darius: how did you get away with an unboxed tuple?
17:28:47 <shapr> I'm not really sure what it does.
17:28:49 <Riastradh> @ghci (coerce 42) :: (Int,Int)
17:29:05 <shapr> heheh!
17:29:08 <Darius> SamB: I imagine it doesn't like dalling with them as a result.
17:29:13 <Riastradh> @ghci 42
17:29:14 <shapr> Riastradh: Fail: <file descriptor: 5>: hGetChar: end of file
17:29:18 <Darius> Riastradh: you likely just crashed it
17:29:22 <shapr> yah, it's dead
17:29:31 <shapr> @dynamic-unload ghci
17:29:37 <shapr> oh, it's *dead*
17:29:57 <Darius> s/dalling/dealing/
17:30:17 <Darius> @ghci let uPST (GHC.ST.ST st) = case st GHC.Base.realWorld# of (# _,a #) -> a
17:30:27 <Darius> @ghci let coerce a = uPST (Data.STRef.writeSTRef r a >> Data.STRef.readSTRef r) where r = uPST (Data.STRef.newSTRef undefined);toRiastradh = "don't mess with me"
17:30:34 <ayrnieu> @ghci 1
17:30:39 <betabot> 1
17:30:41 <SamB> @ghci id (# 1, 2 #)
17:30:46 <betabot> <interactive>:1:
17:30:46 <betabot>     Couldn't match `*' against `#'
17:30:46 <betabot>     When matching types `a' and `(# t, t1 #)'
17:30:46 <betabot> 	Expected type: a
17:30:46 <betabot> 	Inferred type: (# t, t1 #)
17:30:48 <betabot>     In the first argument of `id', namely `(# 1, 2 #)'
17:31:04 <Darius> @ghci case (# 3,4 #) -> (# a,b #) -> a+b
17:31:09 <betabot> <interactive>:1: parse error on input `->'
17:31:12 <Darius> @ghci case (# 3,4 #) of (# a,b #) -> a+b
17:31:17 <betabot> 7
17:31:26 <SamB> @ghci (# 1, 2 #)
17:31:31 <betabot> <interactive>:1:
17:31:31 <betabot>     Couldn't match `*' against `#'
17:31:31 <betabot>     When matching types `a' and `(# t1, t #)'
17:31:31 <betabot> 	Expected type: a
17:31:32 <betabot> 	Inferred type: (# t1, t #)
17:31:34 <betabot>     In the first argument of `print', namely `it'
17:31:43 <Darius> @ghci uPST (coerce (putStr "heya") :: GHC.ST.ST GHC.Prim.RealWorld ())
17:31:48 * SamB remembers unboxed tuples aren't polymorphic
17:31:49 <betabot> heya()
17:32:05 <ham[marubi]> shapr mailserver ok again?
17:32:06 <SamB> that is, they don't work with polymorphic functions
17:32:07 <Darius> @ghci let coerce = ()
17:32:09 <ayrnieu> @ghci let hello (h, _, _) = (hPutStrLn h "Hello, world!" >> hClose h)
17:32:10 <shapr> ham[marubi]: still not
17:32:16 <betabot> <interactive>:1: Variable not in scope: `hPutStrLn'
17:32:16 <betabot> <interactive>:1: Variable not in scope: `hClose'
17:32:36 <ayrnieu> @ghci :m Network IO Control.Concurrent
17:32:37 <betabot> You aren't allowed to execute that statement.
17:32:37 <SamB> @ghci (\x -> x) (# 1, 2 #)
17:32:43 <betabot> <interactive>:1:
17:32:43 <betabot>     Couldn't match `*' against `#'
17:32:43 <betabot>     When matching types `a' and `(# t, t1 #)'
17:32:43 <betabot> 	Expected type: a
17:32:43 <betabot> 	Inferred type: (# t, t1 #)
17:32:45 <betabot>     In the first argument of `print', namely `it'
17:32:51 <ayrnieu> @ghci let hello (h, _, _) = (IO.hPutStrLn h "Hello, world!" >> IO.hClose h)
17:32:52 <betabot> You aren't allowed to execute that statement.
17:32:59 <SamB> @ghci (\(# x, y #) -> x, y) (# 1, 2 #)
17:32:59 <ayrnieu> aw.
17:33:05 <betabot> <interactive>:1: Variable not in scope: `y'
17:33:07 <Darius> Any string with "IO" in it is considered "bad"
17:33:17 <shapr> yah, if you check the source, it just does a string match
17:33:17 <Darius> Which is overly restrictive.
17:33:19 <SamB> @ghci (\(# x, y #) -> (x, y)) (# 1, 2 #)
17:33:24 <betabot> (1,2)
17:33:28 <shapr> and underly restrictive in other ways
17:33:36 <ayrnieu> @ghci [$I,$O]
17:33:41 <betabot> <interactive>:1: parse error on input `$'
17:33:47 <SamB> shapr: does that mean we can do tricks with ST monads?
17:33:48 <ayrnieu> @ghci ['I','O']
17:33:50 <ayrnieu> (oops =)
17:33:53 <betabot> "IO"
17:34:08 <shapr> SamB: probably, I've tried to think of some way to do it with runST
17:34:10 <ayrnieu> @ghci "This string contains ``" ++ ['I','O'] ++ "''"
17:34:16 <betabot> "This string contains ``IO''"
17:34:35 <Darius> Input strings.  It would just be stupid to restrict output.
17:34:46 <Darius> ... well in that way ...
17:35:10 <Darius> You could with unsafeIOtoST but you disallow "unsafe" as well.
17:35:16 <ham[marubi]> ok i am off to bed
17:35:17 <shapr> yes, det figured out that output strings need to have at least one restriction
17:35:22 <shapr> good night ham[marubi] 
17:35:24 <ham[marubi]> see you later
17:35:44 <ayrnieu> shapr - what restriction?
17:36:22 <shapr> det figured out @eval "\CRPRIVMSG #haskell hello: world"
17:36:31 <shapr> or something to that effect
17:36:49 <ayrnieu> oh, I remember that.
17:37:07 <shapr> so now \r is cleaned out of the output string
17:37:19 <ayrnieu> @eval "\CRPRIVMSG #haskell :hello world"
17:37:20 <betabot> PRIVMSG #haskell :hello world
17:38:03 <Riastradh> @eval "\r\nPRIVMSG #haskell :hello world"
17:38:04 <betabot> PRIVMSG #haskell :hello world
17:38:13 <Riastradh> @eval "\\r\\nPRIVMSG #haskell :hello world"
17:38:14 <betabot> \\r\\nPRIVMSG #haskell :hello world
17:38:21 <ayrnieu> @eval "\015PRIVMSG #haskell :hello world"
17:38:22 <betabot> PRIVMSG #haskell :hello world
17:38:31 <shapr> it's fun to find security holes in lambdabot
17:38:32 * ayrnieu yawns.
17:38:33 <Riastradh> @eval "\015\012PRIVMSG #haskell :hello world"
17:38:34 <betabot> PRIVMSG #haskell :hello world
17:38:36 <shapr> since I'm sure there are bunches
17:38:57 <ayrnieu> @eval "\05" ++ "5,3Test"
17:38:58 <betabot> 5,3Test
17:39:50 <betabot> yow!
17:40:05 <shapr> @yow
17:40:05 <betabot> Here is my refrigerator full of FLANK STEAK...and over there is my
17:40:05 <betabot>  UPHOLSTERED CANOE...I don't know WHY I OWN them!!
17:40:10 <shapr> @arr
17:40:11 <betabot> Drink up, me hearties
17:40:24 <shapr> time for sleep for me
17:40:35 <shapr> and I'm not leaving betabot around for you guys to abuse ;-)
17:40:39 <shapr> betabot: @quit
17:40:41 <ayrnieu> g'night.
17:40:48 <ayrnieu> aw, meanie.
17:40:52 <shapr> :-P
17:40:54 * shapr disappears
17:41:36 <ayrnieu> FWIW, @eval "\0115,5Hello mIRC colors."
17:42:05 <Darius> @eval \0115,5Hello mIRC colors
17:42:10 <Darius> @eval "\0115,5Hello mIRC colors"
17:42:19 <Darius> oh yeah
17:42:20 <SamB> Darius: it works better with a bot
17:42:23 * Darius is slow today.
17:44:24 * Darius has an extremely twisted idea.
17:46:46 <ayrnieu> Darius - what idea?
17:48:39 <Darius> Pointer arithmetic in Haskell.
17:50:05 <SamB> Darius: how do you propose to do such a thing?
17:55:23 <Darius> There are already some somewhat sane pointer arithmetic things in the FFI libraries, but I'm trying to use the magic of unsafeCoerce#.
18:09:59 <Darius> "Many of these exercises (but not the incorrect ones) are taken from Johnstone ... None of them are meant to be hard (except the incorrect ones) ..."
18:51:55 * phubuh is in awe of the Evil Mangler
18:52:59 * Darius has never really looked at the Evil Mangler.
18:53:31 <phubuh> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/driver/mangler/ghc-asm.lprl?rev=1.106&content-type=text/plain
18:54:29 <phubuh> sub init_FUNNY_THINGS {
18:54:29 <phubuh>     %KNOWN_FUNNY_THING = (
18:54:29 <phubuh> 	# example
18:54:29 <phubuh> 	# "${T_US}stg_.*{T_POST_LBL}", 1,  
18:54:29 <phubuh>     );
18:54:30 <phubuh> }
18:54:41 <phubuh> the GHC authors' humor is quite peculiar
18:55:25 <Darius> It's throughout the GHC sources.
19:36:27 <stepcut> the glorious haskell compiler
20:24:31 <SamB> is that PERL???!?!?
20:25:17 <phubuh> yup!
20:25:30 <phubuh> to paraphrase someone somewhere, it's not called the Evil Mangler without a reason
20:26:00 <Riastradh> What does it mangle?
20:27:42 <phubuh> gcc-outputted assembly
20:27:58 <phubuh> there's a description it somewhere, hmm
20:28:08 <phubuh> ah, http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/mangler.html
20:28:17 <SamB> why do they use a PERL program? was their a lack of entropy in the system?
20:28:45 <phubuh> well, it is just a huge ugly imperative text munging script
20:29:48 <SamB> PERL is good for munging text, is it?
20:30:07 <ayrnieu> Please stop calling it 'PERL'.
20:30:13 <SamB> I'm afraid I don't see how I could accomplish that in PERL.
20:30:13 <phubuh> yup.  at least that's what I hear
20:30:14 <ayrnieu> 'Perl' for the language and 'perl' for the implementation.
20:31:00 <SamB> okay, I'll stop calling it PERL.
20:31:05 <phubuh> maybe it was written in Haskell first and referred to as the Not-so-good Mangler, but Evil is better than Not-so-good
20:31:36 <phubuh> because Not-so-good sounds like it tries to be good, but fails, whereas the Evil Mangler completely lives up to its goal
20:32:10 <SamB> and how do you run a .lprl script?
20:33:16 <phubuh> no idea
20:34:06 <SamB> is this just an insentive to not use -fvia-C?
20:35:56 --- mode: carneiro.freenode.net set +b *!*@206.169.168.190
20:51:43 --- mode: jordan.freenode.net set +b *!*@206.169.168.190
20:52:27 * SamB laughs at the "Background" subsection of "Theory of patches"
20:52:40 --- mode: bradbury.freenode.net set +b *!*@206.169.168.190
