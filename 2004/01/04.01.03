00:04:29 <`John> ayrnieu, if you feel like typing ibase=16 obase=10 and getting wrong, one way results then by all means!
00:05:01 <ayrnieu> John - I have absolutely no clue what you meant to communicate, just now.  Sorry.
00:06:12 <`John> :)
00:09:11 <`John> >>anyway, as I've never used bc.<<
00:09:25 <`John> thats what I'm talking about. :P
01:31:36 * shapr boings
01:33:06 <andersca> hey shapr
01:33:11 * andersca is happy about his afp grade
01:33:11 <andersca> :)
01:33:17 <shapr> hej andersca 
01:33:28 <shapr> yah, vg is "very good" right? :-)
01:34:47 <andersca> yes, the highest grade
01:34:58 <andersca> if you want you can have my 'report'
01:35:15 <shapr> it's in swedish?
01:35:29 <andersca> no
01:35:49 <shapr> oh, the end paper you wrote?
01:35:52 <shapr> yes, I'd like to see it.
02:34:55 <shapr> is the POWER cpu available? or is it insanely expensive like the Itanium?
02:38:06 <shapr> oh, I came up with a new quote over christmas "I encourage my competitors to use Windows"
02:38:30 <shapr> lemme guess, that's been around forever?
02:41:56 <shapr> gutentag pesco 
02:42:21 <shapr> wassup?
02:44:32 <shapr> g'day saz
02:44:56 <shapr> isn't it just reaching evening in the warm lands down under?
02:45:07 <saz> hi shapr!
02:45:17 <saz> the sun set a couple of minutes ago
02:45:22 <shapr> saz: were you at ICFP?
02:45:30 <saz> no
02:45:35 <shapr> oh, too bad
02:45:49 <shapr> maybe next year
02:45:58 <saz> maybe
02:46:25 <shapr> so, how's code treating you?
02:46:46 <saz> haven't touched haskell for a while
02:46:57 <saz> starting out with python atm
02:47:03 <shapr> ah, it's a nice language
02:47:27 <saz> yeah, it looks pretty practical
02:47:31 <pesco> good morning shapr!
02:47:59 <shapr> goood morning pesco!
02:54:25 <shapr> ack, my color-theme is whacked
02:54:27 <shapr> brb
03:10:55 <shapr> so, more excitement?
03:11:04 <shapr> pesco: you ever written a network server in Haskell?
03:12:51 <ayrnieu> shapr - I have (to an extent).  Why do you ask?
03:13:23 <shapr> I'm trying to figure out how to structure a pop3 server
03:13:52 <shapr> it's more difficult than I expected, I keep coming up with OOP structures :-)
03:14:36 <ayrnieu> Yeah, I have lots more fun thinking up concurrency-oriented designs =)
03:15:54 * Cale is in the middle of writing another irc bot :)
03:16:03 <shapr> Cale: which language?
03:16:14 <Cale> Haskell, just doing it for fun
03:16:22 <shapr> cool!
03:16:33 <Cale> and to run mathematica on #math
03:16:44 <Cale> since I currently have a shell script doing it
03:16:58 <Cale> and it's slowly becoming a pain to maintain
03:17:20 <ayrnieu> Cale - start by writing an intermediary between the bot and the server so that you can update the bot without disconnecting from IRC =)
03:17:48 <shapr> yah, dynamic reloading in lambdabot 
03:17:51 <Cale> ah, good point. I was using netcat for that before.
03:17:52 <shapr> @arr
03:17:52 <lambdabot> I heard andersca is a pirate
03:18:10 <shapr> andersca: lambdabot is talking about you.
03:18:17 <Cale> heheh
03:18:28 <andersca> :)
03:18:58 <Cale> Perhaps I should write a generic irccat which simply handles pongs and otherwise passes the streams on cleanly.
03:20:02 <Cale> I'm going to have to deal with running a program and hooking into its IO anyway (for math'ca) so it wouldn't be any extra trouble.
03:22:44 <Cale> hmm... it would be nice to have something that took an IO action, and grabbed all of its usage of stdin/stdout/stderr and remapped them to Handles of your choice
03:22:50 <Cale> is this possible?
03:22:54 <shapr> shell-haskell
03:23:11 <shapr> http://www.electronconsulting.com/shell-haskell/
03:23:37 <Cale> ah
03:23:42 <shapr> Lunar^ used that to make a GHCiModule for lambdabot 
03:23:48 <shapr> works perfectly
03:24:00 <Cale> yeah, I've been playing around with it a bit.
03:24:09 <shapr> the GHCiModule?
03:24:17 <Cale> shell-haskell
03:24:19 <shapr> ah
03:26:16 <Cale> It would just be cool to take those handles and hook them up to some code that already did the right thing with the usual IO calls (rather than the ones that take handles)
03:26:25 <shapr> eh?
03:27:00 <Cale> i.e. something like withHandles (i,o,e) do { blah }
03:27:27 <Cale> where blah is some IO stuff that would normally go to stdin/out/err
03:27:31 <shapr> oh
03:27:33 <shapr> that would be handy
03:27:51 <shapr> I've wanted that for unit testing by faking socket reads
03:27:56 <ayrnieu> Cale - interesting.  I've already written TcpUtil.hs to return sockets instead of socketToHandle'd handles from some Network functions.
03:27:58 <Cale> yeah, me too :)
03:28:14 <Cale> sort of
03:28:19 <shapr> it's called StringIO in Python
03:28:20 <ayrnieu> Cale - something that didn't have to reimplement library functions would work =)
03:28:31 <shapr> lets you pretend a string is a file and allows you to read/write/seek/etc
03:29:07 <Cale> another thing that I've wished for is the ability to join multiple handles into one
03:29:20 <shapr> what should that do?
03:30:01 <Cale> so if I have handles a and b, then (joinHandles a b) would be a handle where IO would be done from both Handles
03:30:20 <Cale> i.e. if I print to it, output goes to both a and b
03:30:23 <shapr> oh
03:30:35 <shapr> you can already do that with Concurrent and channels, can't you?
03:30:44 <Cale> possibly, but I don't know about it :)
03:30:57 <shapr> read the Concurrent paper
03:30:59 <shapr> it's short, but meaty
03:31:09 <Cale> alright
03:50:42 <Cale> this is a rather elegant design :)
03:54:36 <shapr> concurrent?
03:55:10 <shapr> greetz Arnia 
03:55:16 <Cale> yeah
03:55:33 <shapr> I'd like to get the full version of the paper :-/
03:55:39 <shapr> publishing partial versions online sucks ass
03:56:11 <Cale> What journal is it in?
03:56:35 <shapr> http://lambda.weblogs.com/discuss/msgReader$10453?mode=topic&y=2004&m=1&d=2
03:56:46 <shapr> I don't know
03:56:59 <Cale> hmm... perhaps I can look for it
04:00:57 <shapr> oh, this sounds like me: http://www.faqs.org/docs/artu/ch16s01.html
04:02:41 <shapr> saz: enjoying Python?
04:03:45 <saz> shapr: so far so good, I've only started programming in it this afternoon
04:04:15 <shapr> it took me about four days to become totally converted from Java to Python
04:04:25 <Cale> odd, my connection to the ACM journals through my library's proxy seems down
04:04:38 <shapr> ooh, research warez?
04:04:44 <shapr> um, I mean... 
04:04:46 <Cale> sort of :)
04:05:05 <Cale> I get access to lots of journals from my uni.
04:05:08 <shapr> nice
04:05:19 <shapr> that's a good reason to join a uni now that you mention it
04:08:01 <saz> so far it's much nicer than java :)
04:08:53 <shapr> first time I showed some java-only coders the equivalent Jython code, I heard cries of amazement.
04:09:22 <saz> haven't looked at jython yet..
04:09:32 <shapr> "you don't have to declare that ahead of time?" "where did you cast that?" "that's like a loop that isn't there"
04:10:11 <saz> heh, java does have a lot of syntactical crud
04:10:29 <shapr> for not much benefit, imho
04:10:57 <saz> yeah
04:11:20 <saz> hmm
04:11:27 <saz> haven't programmed in java for a while actually
04:11:30 <shapr> all the benefits that Java claims to have, appear in Haskell for less mental cost.
04:11:34 <saz> hope it stays that way :)
04:11:37 <shapr> yah, same here
04:11:54 <shapr> but I have years of experience with Java, so I'll probably get conned into writing more for some chunk of cash.
04:11:59 <TripleDES> hi
04:12:07 <ejt> hi
04:12:09 <shapr> hello TripleDES, are you feeling cryptic?
04:12:23 <shapr> g'day Mr Thornber.
04:12:42 <ejt> v. formal
04:12:51 <shapr> well, time for something different :-)
04:13:00 <shapr> how's code treating you?
04:13:00 <saz> well, the boss at work had a fairly lousy experience with java, so I hope he doesn't make me code in it.  
04:13:28 <shapr> it's not so bad if your boss doesn't mind that you use Jython
04:13:54 <shapr> imho, Jython is the correct interface to the Java libs :)
04:15:25 <saz> so far I'm just scripting
04:15:28 <saz> so python does the trick
04:15:37 <saz> and it's slightly more extensible than sh
04:15:45 <shapr> yah, just a little...
04:16:03 <saz> ;-)
04:16:19 <shapr> 99% of my income the last year or two is from Python
04:16:40 <Cale> How goes the abstract mid-level UI front for Haskell?
04:16:42 <saz> hmm
04:16:50 <saz> most of mine's been from haskell I think
04:16:53 <shapr> Cale: GUI?
04:16:58 <Cale> yeah
04:17:06 <shapr> saz: oh, I want that too!
04:17:25 <shapr> Cale: wxHaskell is the officially encouraged binding
04:17:30 <Cale> ah
04:17:51 <shapr> though I haven't gotten it to build correctly with the latest GHC6.2 debs
04:18:33 <saz> shapr: then again, I earn what I earnt in a week with haskell in a day just doing boring shell scripting
04:19:43 <shapr> Cale: at least, SPJ et al chose wxHaskell in the most recent HIM
04:19:52 <shapr> saz: I'd still choose weeks of Haskell
04:20:46 <shapr> er, what's the notation for binary numbers in GHCi? 0b111?
04:21:37 <Cale> you'd think, but it doesn't work
04:21:45 <shapr> I thought it did work before
04:22:02 * shapr checks the h98 report
04:22:16 <shapr> saz: if you want to contract out your Haskell work, I'm willing to take it :)
04:22:32 <Cale> integer 	 -> 	 decimal
04:22:32 <Cale> 	| 	0o octal | 0O octal
04:22:32 <Cale> 	| 	0x hexadecimal | 0X hexadecimal
04:22:43 <Cale> no binary, it seems
04:22:46 <shapr> suckage
04:23:22 <shapr> hi elmex 
04:27:10 <elmex> hi
04:35:36 <Cale> yeah, there seems to be something wrong with linking wxHaskell and parsec
04:37:38 <shapr> I think it can't find Parsec now that it's split into its own package
04:39:11 <shapr> dunno how to fix that though
04:39:22 <Cale> setting HCFLAGS didn't work
04:40:41 <Cale> oh wait
04:41:01 <Cale> yeah, looks like this is working
04:41:15 <Cale> config/config.mk
04:41:25 <Cale> set HCFLAGS to -package parsec
04:42:55 <shapr> whee!
04:43:13 <shapr> looks like a patch worth submitting
04:45:06 <Cale> heh. I think my kernel just killed the compiler for running out of memory.
04:45:10 <shapr> whoops
04:49:59 <shapr> yay, it built for me
04:50:38 <Cale> killed a couple of daemons and retrying. I think I'm past the huge-memory-usage part :)
04:52:28 <Cale> there we go :)
05:01:25 <Lunar^> Mac-On-Linux rulez
05:02:13 <Lunar^> (maybe it wasn't the best channel to say that... but excitement, you know...)
05:02:17 <shapr> heh
05:02:25 <shapr> if you're having fun, that's great
05:02:37 <Lunar^> I'm not having fun.. but I'm seeing the end of the tunnel
05:02:45 <shapr> I'm trying to write a point-free 7-bit binary to ascii converter
05:02:59 <Lunar^> point-free ?
05:03:03 <Cale> heh
05:03:10 <shapr> combinator
05:03:49 <shapr> take 7 $ iterate (2 **) 0 -- doesn't do what I expected
05:03:59 <Lunar^> Look at Data.Bits
05:04:01 <Lunar^> works great
05:04:46 * shapr tries that
05:05:21 <Darius> @type (^) would probably be a better choice.
05:05:26 <Darius> @type (^)
05:05:27 <lambdabot> (^) :: (Num a, Integral b) => a -> b -> a
05:05:37 <Darius> as opposed to 
05:05:40 <Darius> @type (**)
05:05:42 <lambdabot> (**) :: Floating a => a -> a -> a
05:05:55 <shapr> > take 5 $ iterate (2 ^) 0
05:05:55 <shapr> [0,1,2,4,16]
05:06:05 <shapr> why isn't that 2,4,8,16 ?
05:06:12 * shapr thinks
05:06:31 <Darius> my remark was not about correctness (so much) as efficiency and clarity.
05:06:45 <Darius> (^ 2)
05:06:57 <Darius> er (* 2) starting at 1
05:07:02 <Darius> (or 2)
05:07:23 <Darius> @definitions i
05:07:24 <lambdabot> []
05:07:43 <shapr> take 7 $ iterate (* 2) 1 -- works
05:07:58 <Darius> or take n $ map (2^) [0..]
05:08:09 <shapr> yah, that's clearer
05:08:11 <Darius> (though the iterate version would be quicker)
05:08:32 <shapr> I'm just looking for short cheesy code that turns 1100101 1100101 1101000 1110111 into ascii
05:08:46 <shapr> so speed isn't so important
05:09:10 <shapr> cuteness is, of course :-)
05:12:10 * shapr boings cheerfully
05:12:19 <shapr> Haskell is so much fun to play with
05:15:46 * esap just saw a TV remote control that had a "magic" button on it. :-)
05:16:06 <shapr> magic?
05:16:17 <esap> yes, it says "magic".
05:16:22 <shapr> is that like Jef Raskin's HumaneInterface stuff?
05:16:31 <esap> I have no idea what it does.
05:16:43 <Igloo> It's probably for tuning the (universal) remote to the device you have
05:17:01 <shapr> hi Igloo!
05:17:06 <Igloo> Hi
05:17:12 <shapr> how's life?
05:17:28 <Igloo> s'OK  :-)
05:18:03 * esap btw wrote a lot of things to HaskellWishList page in wiki.
05:19:31 * shapr looks
05:21:48 <shapr> oh, once or twice I've wanted that sort of case thingy
05:24:13 <esap> which part? The splitting?
05:24:55 <shapr> the first part
05:25:46 <shapr> hm, linking problems building the wxHaskell samples
05:26:13 <shapr> Cale: have you tried to build the samples?
05:26:23 <Cale> yeah
05:26:30 <shapr> works for you?
05:26:36 <Cale> no
05:26:38 <Cale> :)
05:26:56 <shapr> looks familiar? --> /usr/lib/libwxc-0.4.so: undefined reference to `wxGLCanvas::SwapBuffers()'
05:27:02 <Cale> yes
05:27:06 <Cale> that's what I get
05:27:09 <shapr> I get .o and .hi files, but the link barfs
05:27:19 <shapr> hmm
05:27:20 <Cale> I'm going to try compiling wxWindows myself
05:27:30 <Cale> it was probably built without GL support
05:27:41 <shapr> ohh
05:30:31 <shapr> there's some sort of canvas in libwxgtk2.4-contrib, maybe that'll work
05:31:03 <shapr> nope
05:33:36 <shapr> err, how would I check to see if those symbols are in /usr/lib/libwx_gtk_gl-2.4.so ?
05:34:03 <Cale> objdump -something /usr/lib/libwx_gtk_gl-2.4.so
05:34:12 <shapr> thanks
05:34:12 <Cale> let me check
05:34:31 <Cale> -t or -T
05:35:15 <shapr> and it seems I need to use the .a file rather than the .so
05:35:32 <shapr> looks like those calls are in that file
05:35:58 <shapr> hej Marvin-- 
05:36:05 <Marvin--> ello ello
05:36:14 <shapr> yes, they're in the .a file, now how do I tell them to get included?
05:36:41 * shapr looks at the GHC manual under "linking"
05:37:13 <Cale> hmm, I dunno
05:38:02 <shapr> Marvin--: hey, how can I tell ghc to look in some random .a file for a certain call?
05:38:13 <shapr> we're trying to get wxHaskell working happily with GHC 6.2
05:38:30 <Marvin--> uhm, can't a static lib just be passed along on the command line when linking?
05:38:55 <shapr> I don't know, how would I do that?
05:38:59 <shapr> just -i it?
05:39:00 * Marvin-- is playing with the combination of WriterT and list monads
05:39:17 <Marvin--> no, I mean, just ghc -o foo a.hs b.hs libfoo.a
05:39:31 <YveDeLarc> hi
05:39:48 * shapr tries that
05:39:52 <shapr> bonjour YveDeLarc 
05:39:54 <Cale> shapr: -T is for the .so and -t for the .a -- I can't seem to find anything to do with glcanvas in either.
05:40:05 <shapr> huh, that works
05:40:29 <shapr> no, it doesn't
05:40:31 * shapr is confused
05:40:49 <Cale> I mean - with objdump
05:41:26 <shapr> I can find it in /usr/lib/libwx_gtk_gl-2.4.a
05:41:34 <Cale> ah, hmm
05:42:08 <shapr> same thing
05:42:13 <shapr> foo
05:42:19 <Marvin--> argh
05:42:22 * Marvin-- got bitten by $i
05:42:40 <shapr> I get bitten by -$ :)
05:42:55 <Marvin--> that's what I get for throwing in random  lift.lift$  chunks
05:43:43 <shapr> Cale: seems that it's looking for those calls in /usr/lib/libwxc-0.4 + something, and that's listed in the extra_libraries part of ghc-pkg -s wxcore
05:44:09 <shapr> therefore, I would guess that libwx_gtk_gl should probably be listed in extra_libraries also
05:44:41 <shapr> is there some way to see what -package foo expands to?
05:45:36 <shapr> oh, neat, GHCi has Python's _ variable
05:45:53 <shapr> but named "it"
05:45:53 <Cale> what is that?
05:46:08 <shapr> try 1 + 2 at the GHCi prompt
05:46:16 <shapr> then "it * 2" as the next line
05:46:29 <Cale> ah, yeah
05:46:31 <shapr> just binds the last result to "it"
05:48:14 <Cale> which I suppose is somewhat like perl's $_
05:48:27 <shapr> yah
05:48:41 <shapr> I'd like to try GHC on amd64, that would be cool
05:49:32 <shapr> whoa, I got it to work!
05:49:45 <shapr> just add -lwx_gtk_gl-2.4
05:49:51 <Cale> ah, cool
05:49:59 <ejt> how do I get a list of available packages with ghc ?
05:50:06 <shapr> ejt: ghc-pkg -l
05:50:41 <ejt> thx
05:50:54 <shapr> argh, wxWindows is gtk1
05:51:12 <Cale> another reason to rebuild it :/
05:51:22 <shapr> I want a gtk2 version
05:51:29 <Cale> but I think that since it works, I'll just leave it for now.
05:51:41 <Cale> My gtk/gtk2 themes are almost identical
05:51:41 <shapr> yah, same here
05:51:50 <shapr> I'm using 6nome
05:52:01 <Cale> I'm using Industrial
05:52:03 <Lunar^> shapr: I think this is Debian specific
05:52:14 <shapr> ah, ok
05:52:36 <Cale> Yeah, it probably is. When you compile wxwindows, there's options to turn on gtk2 and opengl
05:52:52 <Cale> (and a bunch of other things)
05:53:33 <Cale> anyway, this is good - I'll have to learn to use it and make nice GUIs for the small programs that I've written.
05:53:42 <shapr> yah, same here
05:53:48 <shapr> where's the tutorial?
05:54:05 <Cale> I'm not sure
05:54:25 * shapr checks mailing list archives
05:55:07 <Cale> It would be cool to have something like haskell-glade
05:57:51 <Marvin--> that should be doable, shouldn't it?
05:58:07 <Cale> theoretically :)
05:58:18 <Marvin--> lots and lots of work, sure, but doable :)
05:58:28 <Marvin--> I agree, it would be cool
06:03:40 * Marvin-- shakes his head in disgust at his code
06:04:28 <ayrnieu> data Spot = Red | Black | Empty
06:04:43 <Cale> hehe
06:04:54 <ayrnieu> data Column = Column(Spot, Spot, Spot, Spot, Spot, Spot, Spot)
06:05:09 <ayrnieu> data Board = Board(Column, Column, Column, Column, Column, Column)
06:05:19 <Marvin--> when do we get to C Spot Run?
06:05:37 <Cale> also reminds me of scientology :)
06:05:58 <Marvin--> ayrnieu: why tuples?
06:06:02 <Cale> Spot a spot. Spot spot spot.
06:06:14 <ejt> ayrnieu: what does the code do ?
06:06:17 <ayrnieu> We don't -- we get to me writing code exactly like this in Mercury to implement a silly little 'connect 4' game using classes for the players, and then screaming in horror 30 minutes later =)
06:06:22 <Cale> I'm guessing connect 4?
06:06:31 <Cale> yeah
06:06:47 * Marvin-- feels stupid for not knowing what "connect 4" is
06:07:04 <ayrnieu> I don't know why I thought that as a good idea -- I wrote it as 'newbie wanting to make things complicated'
06:07:07 <Cale> it's a game where you drop red and black chips into a grid
06:07:17 <ayrnieu> Marving - join #cf for a bit and we can play it.
06:07:25 <ayrnieu> also, Marvin.
06:07:32 <ayrnieu> A cute child's game.
06:07:35 <dennisb> Marvin--: fyra-i-rad
06:07:39 <Marvin--> d'oh
06:07:45 <Cale> they're pulled by gravity to the bottom, and whoever first makes a row of 4 of their colour wins
06:07:49 <Marvin--> yeah
06:07:56 <Marvin--> just didn't know the English name for it
06:08:06 * Marvin-- has forgotten the appropriate min-max algorithm for it anyway
06:08:16 <Cale> I like the variant where you choose your opponent's colour on each turn
06:08:42 <Cale> (and he has to try to make 4 with what you give him)
06:09:03 <Cale> There's some twisted tactics to it.
06:09:08 <ayrnieu> Marvin - well, someone solved it.
06:10:23 <shapr> connect-four would be an amusing lambdabot plugin
06:10:26 <ayrnieu> I actually got as far as code to add new Red|Black pieces to the board.
06:10:30 <ayrnieu> shapr - indeed.
06:11:03 <Cale> that sounds like something fun to do with wxHaskell or HOpenGL
06:11:38 * Marvin-- has only done it in java+swing :-(
06:11:43 * Marvin-- is scarred for life
06:12:15 <ayrnieu> I got pretty far, actually -- it only occured to me that I'd done something very stupid when I thought about the game-over checker.
06:12:38 <shapr> Cale: sure, networked HOpenGL, with 1234 and q being useful keybindings
06:14:57 * Marvin-- really likes the writer monad
06:15:02 <ejt> shapr: how do I get lambdabot instructions again ?
06:15:15 <shapr> @listmodules
06:15:15 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
06:15:22 <shapr> @listcommands eval
06:15:22 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition","definitions","del-definition","dump","set-fuel","resume"]
06:15:26 <shapr> is that what you mean?
06:15:35 <shapr> or do you mean documentation for the internals of lambdabot?
06:15:38 <ejt> is the chess game still in there ?
06:15:43 <shapr> not at the moment
06:15:47 <ejt> fine
06:16:11 <ayrnieu> @listcommands dummy
06:16:11 <lambdabot> Module dummy provides the following commands: ["dummy"]
06:16:20 * ayrnieu emits suspicion.
06:16:20 <ejt> @dummy
06:16:20 <lambdabot> dummy
06:16:23 <shapr> if you want to run an instance of lambdabot, the #joy channel is where most lambdabot testing happens
06:16:28 <ayrnieu> JUST AS I THOUGHT
06:16:39 <shapr> ?
06:16:47 <ayrnieu> shapr - referring to 'dummy', sorry.
06:16:51 <shapr> oh
06:17:17 <ayrnieu> much tiredness and much caffeine mixing.  Sorry about the caps.
06:17:42 <Marvin--> yEah, uSe MoRe stUdlY caPs inStEad
06:18:56 <ayrnieu> Marvin - I'd like to, but first I'd have to write an irc client and then I'd have to write a 'studly cap' plugin and by the time I got that far I'd've gone to sleep at least once =)
06:19:16 <shapr> erc does those sorts of tricks
06:20:24 <Marvin--> what, you mean you don't have a studly caps key on your keyboard? :)
06:26:05 <shapr> gah, how do I match Either ParseError (IO Username) with IO (Either ParseError Username) ?
06:28:11 * shapr fights the type monster
06:28:58 <Marvin--> what do you mean match?
06:29:20 <shapr> I want to turn the first into the second
06:29:53 <Cale> you're mixing caffeine and tiredness too?
06:29:58 <Cale> hehe
06:30:19 <shapr> looks like
06:30:29 <Marvin--> how about   case e of { Left _ -> return e ; Right m -> do { u <- m ; return (Right u) } }
06:30:35 <ksandstr> umm... x@(Left _) -> do return x; Right u -> (do n <- u; return (Right n)) ? i'm sure this won't compile though
06:30:35 <ejt> shapr: that looks straight forward ?
06:30:51 <shapr> maybe I've just been staring at this code too long :-)
06:31:21 <Cale> heh, @yow should be searchable -- sometimes you're looking for a particular non-sequitur
06:31:25 <shapr> yup
06:31:29 <shapr> fortune works like that
06:31:32 <Cale> yeah
06:31:33 <shapr> would be a good feature to add
06:31:51 <Cale> also I like the irony in it
06:36:48 <ejt> do people use QuickCheck much ?
06:37:16 <Cale> I haven't used it, but I think it's a great idea.
06:39:23 <Marvin--> I use it all the time
06:46:07 <shapr> Darius Bacon just wrote Python and Common Lisp implementations recently
06:46:16 <shapr> I use QuickCheck, it's very spiffy
06:46:38 <Darius> Marvin--: What are you using the Writer monad for?
06:47:57 <Marvin--> Darius: in this case, traversing through an expression tree, collecting variable substitutions
06:58:01 <Marvin--> combining WriterT with the list monad is extra fun
06:58:10 <shapr> how so?
06:58:22 <shapr> the python version of quickcheck is fun
06:58:38 <shapr> I gotta try it in my Zope stuff
06:59:15 <Marvin--> because you get multiple states with very simple code
07:00:53 <Marvin--> got a url?
07:01:07 <shapr> um, looks like the page isn't up yet
07:01:12 <Marvin--> oh
07:01:19 <shapr> Darius Bacon wrote it last night, I got to test it
07:01:44 <shapr> the common lisp version looks okay, but makes my eyes glaze over
07:06:13 <shapr> is there some cheezy way to make <- do double duty for a pair of IO (Maybe a) calls?
07:06:48 <shapr> basically, unwrap the IO, or fail?
07:07:29 <Marvin--> I don't understand you
07:07:37 <Darius> Just x <- ioAction ?
07:07:39 <shapr> check_username :: Handle -> IO (Maybe Username)
07:07:41 <shapr> check_password :: Username -> Handle -> IO (Maybe Username)
07:07:53 <Darius> (well that will fail in the wrong way)
07:07:58 <Darius> (I think
07:08:13 <shapr> if it were just Maybe a in both cases, the <- gets around a bunch of if tests
07:08:39 <shapr> with IO, I get to pretend the value from a <- is pure 
07:09:38 <shapr> so I was wondering if it would work to do "do { exist_user <- check_username sockHandle ; auth_user <- check_password exist_user sockHandle }"
07:11:14 * shapr thinks about that
07:13:00 <Darius> I don't think there are any functions that would straightforwardly handle that.
07:14:03 <Darius> I'd probably use maybe.
07:14:15 <Marvin--> it all comes down to how you want it to fail, I guess
07:15:17 <shapr> gee <- <- doesn't work ;-)
07:16:37 <Marvin--> maybe some clever use of liftM?
07:18:29 <Cale> auth_user <- do { eu <- exist_user; return (check_password eu) sockHandle } ?
07:18:41 <Cale> oops
07:18:45 <Cale> bracketing
07:19:05 <Cale> but does that work (once you move the sockHandle in)?
07:19:12 * shapr tries
07:20:26 <Marvin--> eh, won't you have something like Maybe (IO (Maybe ...)) there?
07:21:16 <Darius> You could use nested do's (or >>=) but I think that that would be more complicated to read and write than more straightforward code.
07:21:21 <shapr> yah, probably so
07:21:26 <Marvin--> that's what I was thinking too
07:31:46 * Marvin-- ponders how to restructure this code to get rid of all the **** duplicate code
07:32:12 <shapr> HaRe!
07:32:33 <Darius> theCode ==> \duplicateCode -> theCode'
07:35:12 <Cale> calling the variable duplicateCode as well, I think is a great idea.
07:35:14 <Cale> heh
08:18:25 * shapr throws monads
08:23:06 * Cale throws comonads at them, causing pretty explosions.
08:23:27 * andersca throws arrows instead
08:23:30 <andersca> they're sharper
08:23:34 <shapr> that's true
08:24:01 * Darius reads (abbreviated): "ZFC Set theory is like Windows, Topos theory is like the 'open source' movement"
08:24:43 <Cale> hahah
08:25:08 <Cale> that's pretty good - where is that coming from?
08:25:53 <Darius> Good 'ole John Baez, http://math.ucr.edu/home/baez/this.week.html
08:27:24 <Darius> "I used to find it fearsomely difficult and dry. Now I don't, which is sort of scary." (about TTT).
08:27:28 * Darius is at the first clause.
08:30:00 * Darius will have to remember "mind-blowing bombshells of abstraction"
08:30:20 <Smerdyakov> Better write it on your hand
08:30:59 <shapr> I like the regular influx of geeky pundits that came from blogging.
08:32:40 <Cale> Actually, I find ttt to be medium as far as dryness is concerned. I've seen much dryer treatements of the material.
08:33:37 <Darius> Parts of it are cool.  Other parts are... less cool, at least right now for me.
08:34:48 <Cale> I haven't gone too far through it yet. Doing the exercises and going slowly, bouncing off other texts from time to time seems to be helping.
08:39:34 * shapr chortles
08:39:38 <shapr> "We are training our PhD students who are then likely to take jobs at universities whose libraries cannot afford to take the journals to which we send our papers. This is crazy."
08:40:34 <Darius> Cale: I haven't read all of it.
08:41:09 <shapr> I'm just mentioning that because the Concurrent paper that I downloaded specifically mentions what parts I could have read, if I had the full version.
08:41:48 <shapr> Springer-Verlag is just a thin front for Microsoft Press, we all know it.
08:41:53 <ibid> our uni does not currently get JFP
08:42:11 <shapr> price reasons?
08:42:13 <ibid> but it just got springerlink access to LNCS, hurrah
08:42:25 <ibid> shapr: unlikely
08:42:43 <ibid> shapr: more like, i'm probably the only one who really wants it here
08:43:02 <ibid> shapr: and the fact that nobody seems to know around here who makes the decisions regarding new journals :)
08:43:08 <shapr> even so, if JFP prices were about the same as the Linux Journal, your library could afford to buy it for you anyway.
08:43:12 <ibid> new subscriptions, that is
08:43:22 <ibid> i could buy it for myself
08:43:25 <shapr> yah, exactly
08:43:28 <ibid> which i might do anyway
08:43:33 <ibid> depending :)
08:43:37 <shapr> I'm not a member of any university, so it cuts down my options.
08:43:49 <shapr> I propose we start an e-zine of Functional Programming.
08:43:56 <ibid> there is one
08:43:59 <shapr> really??
08:44:04 <shapr> hi lummox 
08:44:10 <ibid> journal of functional and logic programming or some such
08:44:11 <shapr> ibid: where where?
08:44:16 <shapr> wow, spiffy
08:44:23 <lummox> joi
08:44:26 <lummox> -j+h
08:44:41 <shapr> oh, hoi
08:44:46 <shapr> hoe gaat het met jou?
08:44:49 <ibid> http://danae.uni-muenster.de/lehre/kuchen/JFLP/
08:45:06 <shapr> spiffy
08:45:08 <shapr> is it free?
08:45:11 <ibid> seems so
08:45:21 <ibid> "JFLP is available for free on these web pages. The published articles can be accessed whithout subscription"
08:45:31 <shapr> awesome!
08:47:01 <shapr> cool, a Hinze paper
08:48:10 <shapr> this doesn't look like the sort of journal where they'd want a paper discussing runtime reloading of code in functional languages
08:48:30 <shapr> hm, maybe
08:48:43 <ibid> "JFLP is interested in all aspects of declarative programming."
08:48:44 <ibid> :)
08:48:52 <ibid> http://danae.uni-muenster.de/lehre/kuchen/JFLP/areas.html
08:49:09 <shapr> well, that's cool
08:52:27 <shapr> hi harsha123!
08:52:37 <shapr> did you have Christmas holidays?
08:55:40 <harsha123> hello shapr !
08:55:57 <harsha123> holidays, yes...
08:56:18 <harsha123> and got my emacs to use vm too
08:56:22 <harsha123> :)
08:57:06 <shapr> yay!
09:00:54 <harsha123> whats with you shapr ?
09:00:57 <harsha123> whats new?
09:01:09 <shapr> still coding on the mailserver in Haskell
09:01:21 <shapr> did you have relaxing holidays?
09:01:54 <harsha123> mail server ? what about the spam thing?
09:02:06 <shapr> yah, that's what I'm working on
09:02:45 <harsha123> so you must have read paul graham's articles..acutally they are pretty intersting
09:02:52 <shapr> yes, I agree.
09:03:23 <harsha123> some good pointers on writing spam software
09:04:56 <shapr> yah, and not that hard to implement
09:08:59 <ejt> Data.bits seems to be missing ffs
09:09:34 <shapr> ejt: it's missing?
09:09:49 <ejt> Find First Set
09:09:59 <shapr> oh
09:10:04 <ejt> v. useful
09:10:15 <shapr> ffs usually means something else on irc
09:10:32 <andersca> fast file system?
09:10:32 <andersca> :)
09:10:36 <shapr> uh, no
09:10:47 <ejt> abusive ?
09:10:51 <shapr> yah
09:11:05 <ejt> k, I'll avoid that one in future
09:13:00 <ejt> bethesda congeal godfrey dragnet                                                haploid second accordion lion shareown oughtn't                                 pressure equidistant marrow lollipop concoct implant arise
09:13:07 <shapr> ?
09:13:09 <ejt> arse
09:13:30 <ejt> sorry, am using silly laptop
09:13:38 <ejt> not too good with the mouse
09:13:45 <shapr> stegonagraphy?
09:13:46 <ejt> (my iBook broke)
09:14:06 * shapr wonders if it's really stegonography
09:14:10 <shapr> ah, whatever
09:14:21 <ejt> I think that's the word list in a spam email, I was telling my girlfriend about bayesian filters a while ago
09:14:27 <shapr> oh, okay
09:27:55 <shapr> hi flippo, how's code?
09:28:29 <flippo> shapr: still spending my time with those old crufty languages 
09:28:48 <shapr> ah well
09:28:51 <flippo> shapr: but I'm doing interesting numerical work
09:28:54 <shapr> it'll get better, I'm sure
09:29:05 <shapr> that's good, like what?
09:29:12 <flippo> shapr: seismic tomography
09:29:17 <shapr> wow, neat
09:29:52 <flippo> shapr: I get to play with differential equations a bit, and solve big sparse equations
09:30:23 <flippo> shapr: a little abstraction is required, but not much functional programming
09:30:37 <shapr> as long as you're having fun
09:31:10 <flippo> shapr: oh yes, it's pleasant work
09:31:20 <Smerdyakov> shapr is a man who has his priorities on straight.
09:31:25 <flippo> shapr: what are you working on?
09:31:43 <shapr> same old, mail server in Haskell. pop3 at the moment.
09:32:06 <flippo> I wrote a pop3 client in an inferior language.  I use it every day
09:32:20 <shapr> so far, this only handles USER and PASS
09:33:05 <flippo> Recently I had to rewrite my SMTP client because the old one was omiting too many headers. Servers were beginning to drop my email silently 
09:33:21 <shapr> WASH has a nice SMTP client library
09:33:31 <shapr> does MIME and some other nice stuff
09:33:42 <flippo> I'm not familiar with WASH
09:33:52 <Smerdyakov> flippo, I could tell from the smell of you.
09:34:00 <flippo> yuk, yuk
09:34:06 <Smerdyakov> LOLOLOLOL
09:34:48 <flippo> Web Authoring System Haskell?
09:34:50 <shapr> this is the url, but I'm not getting a response from the server, http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
09:34:51 <shapr> yup
09:35:16 <flippo> google has a cache
09:35:16 <shapr> maybe uni-freiburg is being slashdotted
09:35:44 <flippo> everyone seems to be writing for web servers these days, except me
09:36:17 <shapr> for some subset of tasks, the browser is becoming the desktop
09:36:39 <flippo> that's what Netscape used to say, and I didn't believe it
09:36:53 <shapr> I'm a web developer, so I may be biased.
09:37:14 <Smerdyakov> That's some guts, admitting something like that here, shapr.
09:37:29 <shapr> it's true, I'm often biased!
09:37:38 * shapr sniffles
09:38:01 <flippo> The browser is a darn good desktop, compared to some of the old overengineered ones
09:38:37 <flippo> Ever try to use any of the SAP interfaces?  Oh lordy.
09:38:50 <shapr> only heard rumors
09:39:10 <flippo> My office still uses a horrible interface for bug reports and support calls, called Scopus
09:40:14 <flippo> There's some bad interface design out there, still making money.  Give me a browser instead please.
10:04:26 * Darius finally knows what NHC stands for.
10:06:13 <shapr> Not a Haskell Compiler ?
10:07:40 <Darius> That's not too far from the original meaning, 'Nearly a Haskell Compiler'.
10:07:44 <shapr> oh
10:07:50 <Darius> Of course, it's not "nearly" anymore.
10:08:30 <Darius> So now it's "aNother Haskell Compiler".
10:08:41 <shapr> aha
10:08:43 <shapr> makes sense
10:10:32 <shapr> hi kokank, looking for Haskell info?
10:13:40 <kokank> nope! just came to hang out and see what discussion is goin on 
10:13:59 <harsha123> hey kokank
10:14:05 <harsha123> shapr: kokank  is my good friend
10:14:16 <shapr> hello kokank, nice to meet you
10:14:26 <shapr> are you also a programmer?
10:14:39 <harsha123> shapr: we studied together
10:14:40 <kokank> ya .. me too
10:14:40 <kokank> Hi all 
10:15:03 <shapr> harsha123: you must be a very social person :-)
10:15:24 <harsha123> shapr: heheh..am actually anti-social ;-)
10:15:29 <shapr> kokank: have you tried functional programming before?
10:15:34 * shapr grins
10:16:02 <kokank> nope 
10:16:10 <kokank> I will soon .. shapr 
10:16:13 <shapr> ok
10:16:34 <harsha123> shapr: kokank is interested in Artificial Intelligence.. he plan to do his Ph.D very soon
10:16:50 <flippo> AI almost demands functional programming
10:17:00 <shapr> cool, what sort of AI? neural nets? expert systems? genetic algorithms?
10:17:09 <kokank> harsha: I gotta to my masters before my Ph. D .. I guess
10:17:19 <harsha123> hehehe. kokank speak for yourself.. :p
10:17:20 <flippo> Learning Bayesian networks?
10:17:42 <harsha123> Machine Learning, I guess
10:17:43 <kokank> flippo: ya .. thats why I am hanging here
10:18:16 <flippo> kokank: I'm reading a fun book on those, by Richard Neapolitan
10:18:18 <kokank> I am more interested in learning .. read about reinforcement learning 
10:19:08 <kokank> flippo: which book is that ? 
10:20:28 <flippo> kokank: google is resisting.  It's from Prentice Hall, title "Learning Bayesian Networks"  Copyright 2004
10:21:14 <flippo> Oh, I was searching google news.  Duh.
10:21:29 <harsha123> flippo: is that book lot of Math?
10:21:54 <flippo> harsha123: yes, theorems and proofs, very rigorous, but still oriented to algorithms.  Very useful
10:22:19 <flippo> well, moderately rigorous
10:22:28 <flippo> He cites others for the hard proofs
10:22:33 <harsha123> ok
10:22:40 <kokank> flippo: sorry .. I got disconnected. you were telling me about a book.
10:22:59 <harsha123> kokank: google is resisting.  It's from Prentice Hall, title
10:22:59 <harsha123>          "Learning Bayesian Networks"  Copyright 2004
10:23:14 <harsha123> harsha123: yes, theorems and proofs, very rigorous, but still
10:23:14 <harsha123>          oriented to algorithms.  Very useful
10:23:42 <flippo> http://www.amazon.com/exec/obidos/tg/detail/-/0130125342/103-2935027-8220612?v=glance
10:24:32 <harsha123> flippo: are you on erc?
10:24:36 <flippo> here is the author's page http://www.neiu.edu/~reneapol/
10:24:45 <flippo> harsha123: don't know what erc is
10:25:03 <harsha123> the emacs chat client
10:25:16 <flippo> harsha123: no, just silly old xchat
10:25:22 <harsha123> :)
10:25:48 <flippo> I should try erc sometime
10:26:05 <harsha123> you on #emacs too , right?
10:26:19 <flippo> harsha123: yep, it's my editor
10:26:37 <harsha123> ok..:)
10:47:05 * shapr thinks deeply
10:47:09 * shapr snores quietly
10:51:15 <Darius> what time is it over there shapr?
10:51:33 <shapr> nearly 8pm
10:51:37 <shapr> what time is it for you?
10:52:37 <Darius> Almost 2pm
10:53:08 <shapr> hello naren 
10:53:32 <naren> shapr: hello shapr.
10:53:45 <cm> hiho
10:53:54 <shapr> I had a cold over Christmas, I was definitely in weak head abnormal form then.
10:54:16 * shapr attempts lowbrow lambda calculus jokes
10:54:56 <Cale> heh
10:55:03 <Cale> that's actually not so bad
10:55:52 <shapr> it really needed one of those ba-bum drum hits at the end
10:57:06 <shapr> @eval take 5 $ iterate (\x -> x pow 2)
10:57:06 <lambdabot> unbound variable: take
10:57:09 <shapr> um
10:58:09 <Cale> there should be a lambdabot plugin that evaluates things using ghci
10:58:16 <shapr> there is!
10:58:17 <Cale> (if there isn't already)
10:58:19 <Cale> ah
10:58:20 <shapr> GHCiModule
10:58:22 <shapr> but it's way scary
10:58:28 <Cale> really?
10:58:33 <shapr> yah, it's the full GHCi
10:58:37 <Darius> shapr: You need to put the definitions file where it needs to go.
10:58:39 <Cale> oh
10:58:43 <shapr> Darius: oh, okay
10:58:46 <Cale> why not just talk to ghc?
10:58:50 <Cale> i
10:58:51 <Cale> *
10:59:27 <shapr> Lunar^ wrote it, it uses shell-haskell to give full GHCi access
11:00:04 <shapr> it's nifty, but I don't know how to whack file access out of GHCi, so I'd rather not leave it plugged in.
11:01:42 <Cale> yeah, that's troublesome :)
11:02:05 <shapr> @get-definition take
11:02:05 <lambdabot> take not defined
11:02:26 <Cale> there's also ghc -e
11:02:45 <shapr> lambdabot: @quit
11:02:55 <Cale> ghc -e 'expr' evaluates expr and returns a result before quitting
11:03:23 <Cale> I suppose you could run lambdabot on an account with few priveleges
11:03:42 <shapr> yah, I could chroot it to /tmp or something
11:04:28 <shapr> that's probably a good idea anyway
11:04:48 <harsha123> nite all
11:04:51 <harsha123> bye shapr
11:04:53 <Cale> 'night
11:04:54 <shapr> bye harsha123 
11:05:00 <harsha123> nite Cale
11:05:00 <kokankII> bye shapr
11:05:03 <kokankII> bye all 
11:05:04 <Darius> "ghc -e ':t '"++input would be better than the current @type
11:05:05 <shapr> cya kokankII 
11:05:11 <Cale> bye kokankII
11:05:14 <shapr> Darius: wanna fix it? :-)
11:05:25 <shapr> you're right, it would be
11:12:41 <Darius> shapr: What's the web-view access to the haskell-libs darcs repository?
11:13:27 <shapr> none at the moment, but I have the new box installed and ready to take to my ISP
12:29:13 <andersca> what's the way to do multiline comments again?
12:29:20 <shapr> {- foo -}
12:29:45 * andersca is adding haskell support to gedit
12:29:49 <shapr> cool
12:30:17 <andersca> hmm, what keywords exist
12:30:21 <andersca> data, newtype, if
12:30:23 <andersca> case
12:30:24 <andersca> of
12:30:34 <shapr> where let
12:30:53 <shapr> if then else
12:31:04 <shapr> do
12:31:44 <andersca>   <keyword-list _name = "Keywords" style = "Keyword" case-sensitive="TRUE">
12:31:44 <andersca>     <keyword>case</keyword>
12:31:44 <andersca>     <keyword>data</keyword>
12:31:44 <andersca>     <keyword>do</keyword>
12:31:44 <andersca>     <keyword>else</keyword>
12:31:46 <andersca>     <keyword>if</keyword>
12:31:48 <andersca>     <keyword>let</keyword>
12:31:50 <ayrnieu> import as hiding module where let case of if else data newtype type class pragma (?)
12:31:50 <andersca>     <keyword>newtype</keyword>
12:31:52 <andersca>     <keyword>then</keyword>
12:31:54 <andersca>     <keyword>where</keyword>
12:31:56 <andersca>   </keyword-list>
12:32:19 <andersca> there's pragma?
12:32:23 <Marvin--> surely there's a list in the report?
12:32:29 <ayrnieu> what a uniquely disgusting mode of specification -- I hope you generate that from s-expressions or something.
12:33:15 <ayrnieu> (keywords-list :name "Keywords" :style "Keyword" :case-sensitive t (case data do else if let newtype then where))
12:33:30 <Igloo> "qualified", "as" and I think another are "keywords" if they appear in an appropriate place only
12:33:34 <andersca> ayrnieu: it's called 'xml'
12:33:42 <ayrnieu> andersca - it looks horrible.
12:33:49 <ayrnieu> andersca - RSI-seeky.
12:34:05 <andersca> ayrnieu: don't worry, I use cut and paste
12:34:12 <Marvin--> Igloo: hiding?
12:34:12 <andersca> ayrnieu: I've had rsi problems, not pleasant
12:34:36 <Riastradh> andersca, yes, the bad reinvention of the S-expression wheel is called 'XML.'
12:34:36 <Igloo> Ah, yes, probably
12:34:40 <shapr> class instance too
12:34:51 * ayrnieu radiates 'die xml die die die' into the atmosphere.
12:35:02 <ayrnieu> yes, instance.
12:35:18 <ayrnieu> andersca - just look at haskell-mode.el =)
12:35:24 <shapr> that's what I'm doing :-)
12:35:28 <andersca> ah, instance
12:36:02 <andersca> type names always start with a capital letter, right?
12:36:11 <shapr> yop
12:36:12 <ayrnieu> andresca - yes.
12:37:07 <andersca> hmm, I wonder how you can type that in regexp
12:37:09 <shapr> stepcut`````: nice ticks
12:37:59 <Riastradh> andersca, [A-Z]
12:38:33 <andersca> Riastradh: what about "stuff might follow"
12:38:52 <Riastradh> [a-zA-Z0-9_]
12:39:04 <Riastradh> (or whatever else you can have in type names)
12:39:06 <andersca> then * right?
12:39:09 <Riastradh> Yes.
12:40:54 <andersca> hmm
12:41:01 <andersca> Riastradh: I need to specify that there has to be whitespace first
12:41:05 <andersca> or the beginning of a line
12:42:01 <ayrnieu> andersca - I don't really understand your question, sorry.  What do you want to match?
12:42:14 <andersca> type names
12:42:31 <ayrnieu> You already know how to match type names.  [A-Z][a-zA-Z0-9_]*
12:42:46 <andersca> ayrnieu: the problem is that this will match 'While' in dropWhile
12:43:19 <ayrnieu> andersca - er, so?  have [a-zA-Z0-9_]* (non-types) match first.
12:43:42 <ayrnieu> andersca - or if gedit can't handle that, see if it accepts \w[A-Z][...]*
12:43:51 <ayrnieu> also, \W
12:43:59 <ayrnieu> or \b, even.
12:44:49 <ayrnieu> or \<, depending on the regex system =)
12:45:03 <andersca> ayrnieu: the thing is that I don't want to match on things that aren't types then
12:45:11 <andersca> hmm, is there a way to say "not prefixed by foo"?
12:45:14 * andersca sucks at regexp
12:45:54 <Riastradh> Typical regexp sucks, too.  Go SRE!
12:46:03 <andersca> I dunno what's supported here
12:46:05 <ayrnieu> andersca - easy as pie in Perl regular expressions.  In Emacs-style regular expressions you want to talk about word boundaries.  In vim you just match that space with something else first, since vim'll let you not match the same space twice for syntax coloring.
12:46:14 <andersca> what's SRE?
12:46:26 <Riastradh> Symbolic Regular Expressions.  Regexps in S-expressions.
12:46:30 <andersca> ayrnieu: how do you do it with perl?
12:46:32 <andersca> Riastradh: interesting
12:46:50 <ayrnieu> andersca - (?<!foo)bar matches 'bar' when 'foo' does not precede it.
12:47:07 <Riastradh> http://www.scsh.net/docu/html/man-Z-H-7.html
12:47:44 <andersca> so (?<![0-9a-z]) could work then?
12:47:52 <ayrnieu> and CL has cl-ppcre, which apparently beats Perl's regular expressions sometimes for execution speed -- but I haven't looked at the benchmarks.
12:48:19 <ayrnieu> andersca - (?<![0-9a-z])foo would match 'foo' when [0-9a-z] does not precede it, yes.
12:48:36 * andersca tries
12:51:05 <andersca> doesn't work
12:51:08 <andersca> looks like it uses GNU regexp:
12:51:10 <andersca>  We build and use
12:51:11 <andersca> them for platforms not based on the GNU C library because we use some
12:51:11 <andersca> features only present in GNU regexps, like word boundary operators.
12:51:55 <ayrnieu> andersca - try \<[A-Z][a-zA-Z0-9_]*
12:52:37 * Riastradh mutters incomprehensibly at regexp-based syntax highlighters.
12:53:45 <andersca> yay, it worked
12:53:48 <andersca> thanks a lot ayrnieu!
12:53:56 <shapr> hello stepcut!
12:53:58 * andersca tries loading Prelude.hs
12:54:02 <shapr> what is a stepcut anyway?
12:54:58 <stepcut> stepcut, spiral, and fade
12:55:12 <stepcut> haircuts offered by the local barber
12:55:28 <stepcut> but, I always thought they sounded like styles of electronic music
12:55:50 <shapr> truly
12:56:14 <stepcut> i imagine stepcut to be a derivative of drum and bass
12:56:38 <esap> Here's a language-design question: Do you think allowing use of algebraic and coalgebraic data structures with the same language construct is a good idea [um, like in Haskell algebraic data types]?
12:56:43 <andersca> oh!
12:56:46 <shapr> something that's a touch slower than D&B but more striking, more treble
12:56:49 <andersca> we've forgotten infixr and infixl 
12:56:55 <shapr> good point
12:57:08 <Riastradh> And isn't there a plain 'infix,' too?
12:57:19 <Marvin--> yes
12:57:24 * andersca adds
12:57:59 <Darius> esap: Why not?
12:58:08 <Riastradh> esap, either way, you're thinking to arcanely, absurdly, and obscurely mathematically.
12:58:10 <Darius> (Not that that's necessarily a good reason)
12:58:28 <Marvin--> heck, I don't even know what a coalgebraic data structure is
12:58:29 <Riastradh> Too, even.
12:58:30 <shapr> can you show me examples of alg and coalg structures?
12:58:41 <shapr> right, I have no idea what that means, or I'd offer at least a vague opinion
12:58:48 <esap> darius: because those two will result in two different designs. Mixing both "as if they were same" doesn't sound like a good idea.
12:59:04 <esap> shapr: algebraic: Maybe. coalgebraic: Stream.
12:59:23 <Marvin--> Stream?
12:59:28 <Riastradh> esap, where Stream is defined as...?
12:59:36 <Darius> esap: Uh, I misread the question or managed to miss most of the second line.
12:59:38 <esap> marvin: data Stream a = Stream a (Stream a)
13:00:17 <Riastradh> ...how is that 'coalgebraic?'  (or: what's 'coalgebraic,' then?)
13:00:18 <ejt> the recursion makes it _co_ algebraic ?
13:00:21 <shapr> so, if it's recursive?
13:00:49 <andersca> hmm, does haskell support 
13:00:51 <andersca> octal numbers
13:00:55 <Darius> Yes.
13:00:55 <andersca> or hexadecimal numbers
13:00:58 <Darius> Yes.
13:01:02 <Darius> Both.
13:01:02 <esap> Well both algebraic and coalgebraic types can be recursive. The point of coalgebraic side is that destructors never fail. The point in algebraic side is that _constructors_ never fail.
13:01:20 <Marvin--> hexadecimal are 0x as usual, but I don't know about octal
13:01:24 <Darius> 0a
13:01:27 <Darius> er 0o
13:01:39 <Marvin--> ah
13:01:53 <Riastradh> Marvin--, no, oh.
13:02:17 <Marvin--> Riastradh: ?
13:02:18 <Riastradh> esap, how could Stream (the constructor) fail there?
13:02:26 <Riastradh> Marvin--, it was a pun.  0o, not 0a; oh, not ah.
13:02:34 <Marvin--> Riastradh: right
13:02:36 * Marvin-- is tired
13:02:39 <esap> riastradh: you can't produce enough elements.
13:02:58 <Riastradh> Is [] both algebraic and coalgebraic?
13:02:59 <Darius> Don't worry Marvin--, noone else knew what the heck Riastradh was talking about either.
13:03:05 <Marvin--> Darius: :)
13:03:12 <esap> riastradh: no, only algebraic.
13:03:41 <Riastradh> I blame shapr for having induced me to make unnoticable puns after the one he made in #joy.
13:03:45 <Marvin--> but what do you mean fail?
13:03:55 <Marvin--> I mean, whnf and all...
13:03:59 <ejt> esap so is data Tree = Node a Tree Tree | E coalgenraic ?
13:04:21 <Riastradh> esap, what about data Foo a b = Bar a (Foo b a) | Baz b (Foo b a)?
13:04:48 <andersca> hmm, what about "one character"
13:05:11 <Darius> All algebraic data type with (exposed) alternatives could fail.
13:05:38 <esap> riastradh: that's a difficult one, I think that's somewhat both. I'd say it's coalgebraic.
13:06:05 <Riastradh> Marvin--, destructuring a list may result in either of two possibilities; the [] constructor might fail if it's a pair.
13:06:16 <Riastradh> ...er.
13:06:26 <Riastradh> ...er, ignore that '...er.'
13:07:09 <Riastradh> ...er, maybe don't ignore it.  I used odd terminology there.  Destructuring a list may result in the nil destructurer failing, if it's a pair, or the pair destructurer failing, if it's nil.
13:07:24 <esap> riastradh: actually, whether your example is coalgebraic depends on whether all public destructors work without failing [it's not immediately obvious in that case whether that's possible].
13:07:28 <Marvin--> s/pair/cons/ ?
13:07:38 <Riastradh> Pair, cons cell, whateve.r
13:07:42 <Riastradh> Whatever., even.
13:07:52 <mattam> how does a constructor fail ?
13:07:59 <Igloo> Spot the LISPer  :-)
13:08:00 <ejt> I just changed a simple 'if' expression to a 'case' and my program sped up significantly, is this expected ?
13:08:04 <Darius> Riastradh's Schemeliness showing through.
13:08:32 <Darius> ejt, unless you changed it to case bool of True -> ...; False -> ...; it's not too surprising.
13:08:34 <Riastradh> mattam, case (a:b) of [] -> ... | (x:y) -> ... -- the first case, the first destructurer, fails; the second one succeeds.
13:09:15 <Riastradh> s/first destructurer/nil destructurer/1
13:09:15 <mattam> yeah, a destruction can fail, i understand that. Now a construction ?
13:09:18 * ejt goes on an 'if' hunt
13:09:50 <Riastradh> What happens when you write a list->stream function for the base case, nil?
13:09:54 <Riastradh> You can't construct a stream.
13:09:58 <Riastradh> It just doesn't work.
13:10:01 <Riastradh> It fails.
13:10:01 <andersca> hmm, I wonder if I should add things like "::" and "->" as keywords
13:10:17 <mattam> well, you can't, so YOU fail
13:10:22 <mattam> somehow
13:10:59 <Riastradh> Actually, in that case, you could have the problem of the destructurer failing -- you just don't have a [] clause -- or the constructor failing -- you can't convert [] to a stream --.
13:11:01 <Darius> Assuming you had something like if foo == bar then ... else ..., it has to do lookup the polymorphic (==) and do whatever that might be.  If bar is an constructor call then it needs to build that too.
13:11:05 <esap> listToStream (a:ra) = Stream a (listToStream ra) ; listToStream [] = error "empty list". 
13:11:12 <Darius> (to ejt)
13:11:44 * Riastradh blinks.
13:11:55 <Riastradh> I suddenly understand some of the arcane mathematical lingo that esap speaks in.
13:12:00 <Riastradh> Burma!
13:12:10 <Marvin--> potatoes!
13:12:13 * esap jumps in surprise.
13:12:21 <Marvin--> we are playing wild associations, right?
13:12:27 <Riastradh> And...and...I'm explaining it, too!
13:12:38 <Riastradh> Marvin--, no, I paniced.
13:13:32 <Riastradh> (Or is it panicked?  I can never remember which forms get the 'k.')
13:14:03 <Darius> I was going to remark about whether it was panicked.
13:14:05 <mattam> hmmm, and when you deconstruct list 'Stream a (Stream b c) = listToStream [1]' you say the construction of a stream from [] failed then...
13:14:29 <mattam> and not that a destruction failed
13:14:53 <Marvin--> "panicked", surely?
13:15:38 <esap> mattam: yes, because the reason for the failure is that the input to the constructor was not accepted by the constructor.
13:16:17 * Marvin-- pours a cognac and returns to his degree project
13:16:41 <mattam> do coalgebraic types have some interresting mathematical particularities ?
13:17:51 <esap> mattam: yes, they're the basis of OO thinking :-) You can easily express state machines, for example, with coalgebraic data types.
13:18:06 <Marvin--> OO thinking?
13:18:09 <Marvin--> go stand in the corner!
13:18:10 <mattam> OO as object oriented ?
13:18:15 * esap nods.
13:18:33 * esap thinks OO became first though.
13:18:54 <mattam> no relation to category theory ?
13:19:28 <esap> mattam: Heh, well sure. Coalgebraic data types are dual to algebraic data types.
13:20:08 <mattam> hmmm got to review my notion of duality :)
13:21:23 <mattam> state machines like: "type Automata s t = A s [(t, Automata s t)]" ?
13:22:19 <Riastradh> Methinks you mean 'data' or 'newtype,' not 'type.'
13:22:35 <Darius> data
13:22:42 <esap> mattam: yes, that sounds right.
13:23:20 <Riastradh> I can never remember: what's the difference between 'data' and 'newtype,' other than that 'data' can have multiple constructors?
13:23:33 <mattam> sorry, my haskell is young
13:23:44 <esap> mattam: though I'm wondering about the use of [] there (should probably use 't -> Automata s t'.
13:24:21 <Darius> newtype is a figment of the typechecker's imagination so the constructor should simply wrap an existent type.
13:24:21 <mattam> yeah, these seems more CoAlgebraic as you defined it earlier
13:24:30 <mattam> s/these/this/
13:24:42 <Darius> To write Automata as a newtype you'd have to explicitly use a tuple.
13:25:19 <mattam> Darius: like ?
13:25:47 <Darius> esap: As you said earlier, or at least I was thinking and figured you were too, you need to specify the destructors.
13:26:22 <esap> darius: right.
13:26:23 <Darius> mattam: newtype Automata s t = A (s,[(t,Automata s t)])
13:26:53 <esap> Destructors (or projection functions) are the important thing in any coalgebra anyway.
13:30:07 <mattam> Darius: hmmm, good to know
13:30:09 <esap> newtype Automata s t = A (s, t -> Automata s t) ? Then every element of 't' has to be covered somehow.
13:31:52 <Marvin--> add a monad ;)
13:32:09 <esap> It's a matter of whether you want the automata to include all cases or only those that do not describe the default case.
13:33:01 <Darius> Well, t -> Automata s t makes it impossible for the automata to ever reach a final state.
13:33:41 <esap> Well final state is any state for which all transitions point to the same state.
13:34:21 <Riastradh> esap, how were you defining OO above?
13:34:26 <esap> Well you might want to have a separate destructor for telling when you're at a final state.
13:35:40 <Darius> How would the destructor know given that representation.
13:37:17 <esap> riastradh: well OO is the paradigm where you have objects with identity, state, behaviour, and where you invoke methods to make changes to those objects [and as a results, those objects may perform some operations]. In the sense, the Java kind of OO.
13:37:48 <esap> darius: it can't. You have to extend that representation for that. Could be part of 's' though.
13:40:32 <Darius> Not without limiting the type of s.
13:40:58 <esap> of course. So maybe better add a Bool flag for whether the state is final or not.
13:42:05 <esap> It's not the same as list of (t,Automata s t) though even if you add the final state indication, because the state transition function would still have to be defined fully.
13:44:02 <esap> which is important to ensure coalgebraic semantics.
13:45:06 <Riastradh> esap, s/Java/Smalltalk/1.  Mumble.
13:45:30 <esap> riastradh: I don't have that much experience with smalltalk, so I'm not very good at talking about it :-)
13:45:48 <esap> But I guess it's very close.
13:46:07 <Riastradh> esap, Smalltalk is really, really simple.  There are objects.  You can send messages.
13:46:51 <Riastradh> That pretty much sums up the basics of Smalltalk.
13:46:51 <mattam> there are closures called blocks iirc
13:46:57 <shapr> on the other hand, the smalltalk metaclass object is an instance of an instance of itself.
13:47:01 <Riastradh> No, blocks aren't closures, necessarily.
13:47:04 <esap> riastradh: is the assumption there that the messages carry _changes_ to the objects; or can you construct an object based on a message that is not sent anywhere?
13:47:25 <Riastradh> What do you mean 'that is not sent anywhere?'
13:48:17 <Riastradh> Oh, there's also instance variable assignment, _.  (Which is supposed to be displayed a bit like '<-')
13:48:24 <mattam> Riastradh: but there are closures right ?
13:48:28 <Riastradh> mattam, nope.
13:48:41 <mattam> hmm
13:48:44 <esap> I mean, often objects are constructed by sending the representation of an object to a factory.
13:48:48 <Darius> Riastradh: There is a bunch of class nonsense.  Self: There are objects. You can send messages.
13:49:07 <Riastradh> Darius, remember, I said the _basis_ of Smalltalk.
13:49:13 <esap> But I'm not sure how object creation works in smalltalk.
13:49:21 <mattam> i thought you could send i :do (*2), nm
13:49:25 <Riastradh> esap, you send #new to an object.
13:49:33 <Riastradh> Er.
13:49:46 <Riastradh> s/Er.//1
13:50:09 * Riastradh has collected a habit of randomly saying 'Er.' after random messages.
13:50:17 <Riastradh> That object will generally be a class.
13:50:28 <Riastradh> Classes, of course, are still objects.
13:51:05 <esap> ok I guess it's the same. Then you are sending "change to a class" asking it to create a new object. I guess the class keeps track of which objects exist?
13:51:24 <Riastradh> 'Change to a class?'  What change is taking place?
13:51:40 <Smerdyakov> A change to a class.
13:51:43 <esap> A class is a "collection" of objects with similar properties.
13:51:50 <Riastradh> I don't think the class keeps track of all its instances...that would get weird with collection classes.
13:53:00 <esap> That kind of thing is great for reflection. You can ask a class for some of its instances by id.
13:54:46 <Riastradh> Yaaagh.
13:55:01 * Riastradh just thought of something too meta for his brain not to explorb and implode.
13:55:40 <Smerdyakov> Nice jorb.
13:56:48 <Riastradh> A metaclass would keep an instance variable containing a collection object, say a Set instance, containing all its instances...the class Set is within that set...and that collection object's class is Set...gaaaah...
13:59:51 <esap> of course, something has to be primitive :-)
14:00:10 <Riastradh> Yes, of course a lot of the methods are implemented as VM primitives.
14:03:36 * Igloo starts work on the TH prettyprinter and remembers why it wasn't a class to start with
14:05:58 <shapr> I'm primitive!
14:06:58 * esap wonders what is the dual of a primitive, maybe a variable?
14:07:18 <Marvin--> oh stop with the duals :)
14:10:24 <Darius> Igloo: that is?
14:11:10 <Riastradh> esap, not everything has duals.  (What's the dual of a dual?)
14:11:32 <shapr> bottom!
14:11:39 <esap> riastradh: things can be self-dual.
14:11:54 <Igloo> Darius: All the fiddly special cases
14:12:14 <Marvin--> I hate fiddly special cases
14:12:19 <Igloo> e.g. bodies need to know if they should be using = or -> for each guard, lots of little things like that
14:12:36 <Igloo> Plus a number of things are tuples rather than real datatypes still, although less than used to be the case
14:13:33 <mattam> esap: an example of a self-dual ?
14:14:24 <esap> mattam: identity functor, I think.
14:14:38 <mattam> too easy
14:16:54 <esap> other examples are hard, I guess some fixed point things are like that [and the functor taking an object into its dual, but that was mentioned already]
14:17:23 <esap> Maybe things like (+) and (*), I'm not exactly sure.
14:18:19 * esap thinks not.
14:23:59 <esap> Self-dual things have to have one kind of symmetry property.
14:24:09 <mattam> yep
14:46:02 <ejt> can anyone think of a neater way to write this please ? ...
14:46:07 <ejt> capture sq = maybe [] (\p -> promote sq (Just p)) $
14:46:13 <ejt> maybe Nothing (\p -> case colourOf p == c' of
14:46:19 <ejt> True -> (Just p)
14:46:23 <ejt> False -> Nothing) $ pieceAt bd sq
14:46:45 <ejt> I feel there must be a way to use >>= with the Maybes
14:49:19 <Darius> fromMaybe [] $ do p <- pieceAt bd sq;guard (colourOf p == c');promote sq p
14:49:55 <ejt> ooh, guard is new to me
14:50:16 <Darius> It's in module Monad (or Control.Monad).
14:50:43 <ejt> k
14:50:44 <Darius> It's (conceptually) the interpretation of... well guards in list comprehensions.
14:51:39 <ejt> thinking ...
14:52:35 <Darius> Given monad comprehensions, you could write the above do as: [promote sq p | p <- pieceAt bd sq, colourOf p == c']
14:52:39 <ejt> *sigh*, I used to think I was pretty bright until I started learning haskell
14:53:33 <mattam> ejt: at least it's challenging!
14:53:45 <ejt> oh I'm enjoying it
14:53:52 <ejt> (most of the time)
14:54:52 <esap> The thing with Haskell is that you find immediately whether your ideas work or not [at least up to a point]
14:55:02 <ejt> so guard is returning the zero element from the monad plus class if the predicate fails ?
14:56:15 <Darius> yes.
14:56:24 <ejt> k, neat
14:56:27 <ejt> thanks
15:01:45 <ejt> are monad camprehensions supported by ghc ?
15:02:07 <ejt> s/camp/comp/
15:04:45 <esap> they were once, at least. maybe there is still some way to enable them? I'd suggest just using the do notation.
15:04:54 <ejt> k
15:20:51 <Marvin--> I really really like the list monad
15:21:08 <andersca> :)
15:21:11 <andersca> what now
15:21:17 <ejt> you've discovered what happens when you sequence a pair of lists ;)
15:21:27 <Marvin--> no, not that evilness :)
15:21:37 <Marvin--> but WriterT [w] [] is cool :-)
15:22:32 <Marvin--> (though right now I have a type that consists of stacking WriterT on StateT on ListT on another StateT on a ReaderT)
15:22:50 <Marvin--> insane type, but the code is pretty
15:22:58 <andersca> what are you doing :)
15:23:17 <Marvin--> working on ye olde degree project
15:23:33 <Marvin--> this particular code takes care of case expressions
15:24:42 <Darius> What are the operations you perform with the inner StateT?
15:25:09 <Marvin--> the ReaderT is just an environment with flags, the ListT is because a case expression will translate to multiple clauses, and the WriterT collects information per clause
15:25:34 <Marvin--> Darius: for this particular code, nothing, it's used elsewhere
15:26:01 <Marvin--> basically, I have a StateT stacked on a Reader that's used throughout the entire module
15:26:13 <Marvin--> and the WriterT/StateT/ListT is just used for the case expression processing
15:26:21 <Darius> Okay.
15:27:57 <Marvin--> you should've seen this code when it didn't use monads
15:28:09 <Marvin--> screenfuls of list comprehensions with explicit state passed around
15:28:14 * Marvin-- shudders
15:29:58 <Darius> Do you have it as a previous revision?
15:31:52 <Marvin--> yeah, let me see if I can dig up two revisions
15:32:33 * Darius was thinking that you could use it as an advertisement for Haskell and monadic programming.
15:33:06 <Smerdyakov> On national television.
15:33:19 <Smerdyakov> With a bunch of geeks standing around cracking category theory jokes.
15:33:59 <Marvin--> heh
15:43:06 <ejt> wheee, a seg fault :)
16:11:00 <Marvin--> I so do not understand Gummo
17:44:07 <Cale> hehe, I made a little wxHaskell gui for my chord-manipulating program. That was fun.
17:44:55 <Cale> quite a nice library, actually.
17:46:56 <Cale> http://vx.hn.org:8000/autoshare/chordGUI.hs if anyone wants to see it. Just don't look at replaceMaximals :) (I'm probably going to have to rewrite that at some point)
18:01:45 <cm> Cale: wxhaskell, where to get? does it work with ghc 6.2?
18:02:23 <Cale> yeah, it does, though you have to tack -lwx_gtk_gl-2.4 -package wx onto the ghc commandline
18:02:29 <Cale> http://wxhaskell.sourceforge.net/
18:03:00 <Cale> it works with just -package wx with older ghc releases
18:04:01 <cm> did you use the source release? cvs or tarball?
18:04:01 <Cale> also, we found that there was one slight change to the build config to get the libraries to compile with ghc 6.2
18:04:13 <Cale> source tarball
18:04:20 <cm> thanks :)
18:04:23 <cm> which change would that be?
18:04:26 <Cale> together with debian's copy of wxWindows
18:05:14 <Cale> in config/config.mk, edit the HCFLAGS= line to read HCFLAGS=-package parsec
18:05:27 <Cale> (since parsec is now in its own package)
18:06:22 <Cale> (that is, after running configure)
18:06:29 <cm> ta :)
18:06:47 <Cale> np :)
18:06:57 <Smerdyakov> fu >D
18:07:10 <Cale> haha
18:07:20 <cm> ;)
18:13:27 <cm> *compiling*
18:25:37 <cm> Cale: works, cool :]
18:25:44 <cm> (-lwx_gtk2_gl-2.4 in my case)
18:26:13 <Cale> yeah, the wx that comes with debian is compiled for gtk1 :/
18:29:08 <Igloo> Is wx a package?
18:29:20 <Cale> seems to be
18:29:46 <Igloo> The -lwhatever should probably be in extra_ld_opts or somesuch in the package.conf then
18:31:16 <cm> where is that package.conf?
18:31:30 <Cale> /usr/lib/ghc-6.2
18:32:48 <Cale> yeah, that works, thanks Igloo!
18:33:56 <cm> works, cool :)
18:34:24 <Cale> we'll have to let shapr know about that
21:18:09 <mattam> hmmm, where are network-related functions ?
21:18:39 <Cale> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
21:18:54 <mattam> thx
21:18:58 <Cale> and there's some more if you start from here: http://haskell.org/ghc/docs/latest/html/libraries/index.html
21:19:24 <mattam> i suppose hugs has nothing like this ?
21:20:10 <Cale> I'm not sure
21:20:20 <Cale> I think the new hugs probably does
22:28:14 <kokankII> Here is an interesting link : http://news.bbc.co.uk/1/hi/health/1058526.stm ( Warning: not related to Func Prog ) 
22:52:57 <ToronTo> Someone say something.
