00:10:24 <ayrnieu> OK, I wrote a simple client for a simple connect4 server written by a #C fellow.  Lots of fun =)
00:11:34 <ski> (in haskell ?)
00:11:49 <ayrnieu> Of course.
00:12:14 <Maddas> hrm
00:12:17 <ayrnieu> He wrote the client and server in C -- I implemented a Haskell version of his client -- all in the last hour or so, in between games.
00:12:28 <Maddas> ayrnieu: heh!
00:12:36 <ayrnieu> Well, he started the C parts a bit earlier.
00:12:45 <Lunar^> Anyone has any idea where I could find something that can help looking at an XUpdate fragment ?
00:12:51 <Maddas> Phubuh's DC parsing library looks way smaller and simpler in Haskell than in C, too
00:13:37 <Lunar^> (similar to Wikis' view changes page)
00:13:38 <ayrnieu> My client works fairly well, except that I have to start caring about exception handling and interthread communication if I don't want to have to kill the OS process every time I want to take the client down =)
00:15:31 <Maddas> hm
00:17:04 <ayrnieu> Maddas - I've two threads: one to listen on the socket and handle everything coming from the server and one to listen on stdin and handle everything coming from the user.  The server thread dies when its reader fails -- but I haven't implemented a way for it to kill off the stdin thread.
00:17:30 <Lunar^> found it :)
00:17:42 <ayrnieu> Maddas - optimally, I need to have both threads take care with exceptions and have a third thread destroy everything on command.
00:17:49 <Maddas> ayrnieu: Isn't there any simple way to listen to the things in a non-blocking way?
00:18:29 <ayrnieu> Maddas - yes, Control.Concurrent
00:18:32 <ski> tryTakeMVar or something like that ?
00:18:36 <Maddas> Why not use that, ayrnieu?
00:18:55 <ayrnieu> Maddas - I've said 'threads' several times, I mean Concurrent Haskell threads, not OS threads.
00:19:02 <Maddas> Oh, ok
00:19:15 <ayrnieu> I don't even know how to do OS threads in Haskell -- I've never needed or desired them.
00:19:15 <Maddas> I should just keep quiet and keep reading :-)
00:27:31 <ski> hmm, can one use retracts to define a type as a section of some implementation type ?
00:32:38 <ski> (perhaps ensuring the automorphism associated to the retract really is an idempotents is hard in a Haskell-like language)
00:33:00 <ski> oh s/auto/endo/ of corse
00:35:30 <Darius> In what way do you mean "define"?
00:37:42 <ski> well, can't one recover an isomorphic object to the one object in a retraction&section pair, given the other object and the idempotent over it ?
00:39:05 <ski> see e.g. page 117 in "Conceptual Mathematics" (if you have it)
00:39:14 <Darius> I don't.
00:39:39 <Darius> The "idempotent" being the inverse(s) to the retraction/section?
00:40:18 <Darius> Also what are the "types" (using dummies or illustrative examples) of the retraction and section?
00:41:00 <ski> "Given only an endomap alfa : X -> X find an A and j, p satisfying p.j = 1 and j.p = alfa. Such a pair p, j is called a splitting for alfa. Unless alfa is idempotent, there cannot be a splitting for alfa."
00:41:21 <ham[kell]> moin
00:42:16 <ski> the idempotent being the reatraction&section pair of morphism, composed the 'other' way, yes
00:43:03 <ski> oh, in the text above j : A -> X  and  p : X -> A
00:44:42 <ski> so e.g. assume that X is Integer*Integer and the idempotent cancels the gcd of both numbers from them both
00:45:22 <ski> isn't A Rational, then ?
00:45:47 <ski> ham[kell] : "moin" ?
00:46:41 <ham[kell]> its a northern german shortform of guten morgen (good morning)
00:47:17 <ham[kell]> can someone of you give me an example of a comultiplication in haskell code and an application?
00:47:33 <ski> comultiplication ?
00:47:53 <ham[kell]> the multiplication in a coalgebra
00:48:05 <Darius> idempotent being p.j?
00:48:07 <ham[kell]> c*: A -> A x A
00:48:20 <ski> ham[kell] : morn yourself, btw :)
00:49:20 <ham[kell]> idempotence is just that an operartion p repeatedly applied is the same as the single applocation
00:49:27 <Darius> I know that.
00:49:33 <ski> Darius : no p.j = 1, j.p = alfa, the idempotent, ok ?
00:50:08 <ham[kell]> but in that case p != j so how can they be idempotent?
00:50:44 <ski> ham[kell] : well perhaps a split operation for a random seed/generator ??
00:51:05 <ski> no j.p is an idempotent (over X)
00:51:06 <ham[kell]> ski: hm
00:51:11 <Darius> ski: Yeah, I see now.
00:51:17 * Darius wasn't thinking/reading.
00:52:13 <Darius> ski: Well, you've given a candidate for A, so what are j and p?
00:52:47 <ski> well, hm
00:53:10 <ski> can we set one of them to 1 ?
00:53:28 <Darius> That would make alpha 1
00:53:39 <Darius> and the other 1 as well
00:53:46 <Darius> (the other being p or j)
00:55:16 <ski> (i was thinking along the two methods : either use equivalence classes of the impl. type and ensure that members of same class can't be separated, or use some canonical forms, i.e. really a subtype of X
00:56:14 <ski> i was thinking we could see the canonical forms as fixedd point of alfa over X
00:56:50 <ski> or else the sectioning of X is the equivalence classes
00:56:54 <ski> hmm
00:57:46 <Darius> Well a retraction could be used to show how one type can be faithfully represented by another type.
00:57:47 <ski> ham[kell] : re comultiplication : should it satisfy some laws ?  coassociativity ??
00:58:12 <Darius> What is multiplication of -(co)algebras-?
00:59:46 <Darius> Or do you just mean the product of algebras (i.e. "pairing" them)?
00:59:53 <ham[kell]> retraction in terms of topology?
01:00:08 <ham[kell]> thats what i try to find out
01:00:17 <ski> I was thinking that maybe we could separate the implementation type from the type we really want, and sort of relate them via the retraction and idempotent, instead of just hiding the implementation and relying on observational equivalence of values in the same equiv. class
01:00:20 <ham[kell]> i havent found any good examples for a coalgebra
01:01:07 <ski> Darius : I though ham[kell] was thinking of some specific coalgebra, perhaps the dual of a semigroup ??
01:02:14 <ski> (guess it's confusing to discuss two different things at the same time)
01:02:40 <ski> ham[kell] : well, did you mean any specific coalgebra ?
01:02:49 <ham[kell]> nope
01:03:15 <ham[kell]> i just want to see an application field and a semantic for that mul in a co algebra
01:03:38 <ski> what mul ?
01:03:41 <Darius> Do you mean the product algebra or is this some special multiplication?
01:03:47 <ham[kell]> comultiplication
01:04:11 <Darius> In other words, I've never heard of "(co)multiplying" (co)algebras.
01:04:27 <ham[kell]> a coalgebra is a vectorspace over K with an operation d: A -> A x A
01:04:33 <earthy> darius: but that's not really what he was asking, was it?
01:04:47 <ham[kell]> www.planetmath.org
01:04:48 <earthy> he was asking for a comultiplication *in* a coalgebra, IIRC
01:05:10 <ski> isn't that a specific coalgebra, ham[kell] ?
01:05:11 <ham[kell]> yes
01:05:18 <ham[kell]> and yes
01:05:25 <ski> it sure seems to have a concrete signature
01:05:43 <earthy> unfortunately, I know too little about coalgebra's to be of help, ham[kell]
01:05:54 <earthy> (it's one of the things on my `to learn' list)
01:06:06 <ski> ham[kell] : i guess that was what i was asking you about ;/
01:06:19 <Darius> earthy: His statement was for an example of "comultiplication in haskell" it's not obvious from that whether he means in or of coalgebras.
01:06:30 <Darius> nm
01:06:37 <Darius> he clarified later.
01:06:59 <ski> so ham[kell], does this coalgebra has any other operation(s) (or special objects) ?  or laws ?
01:07:09 <ham[kell]> i just wanted to get something like an implementation of that in haskell terms
01:07:21 <ham[kell]> a e-unit
01:07:27 <ski> ?
01:07:39 <ham[kell]> but i think its better if you look it up on plnetmath
01:07:49 <Cale> http://planetmath.org/encyclopedia/Coalgebra.html
01:07:58 <ham[kell]> thanks
01:08:37 <ski> is the x a (categorical) product ?  or just some bifunctor ?
01:09:57 <Cale> I'd think that would be the tensor product of vector spaces.
01:09:57 <ham[kell]> i think x is the product
01:10:44 <ham[kell]> what is the tensor product?
01:11:12 <Cale> let me get a definition
01:11:17 <ski> i don't know enough about tensor product to tell if it is a categorical product, perhaps it doesn't matter
01:11:51 <ski> it sure looks like a bifunctor, judging from the pics, though, methinks
01:12:19 <Cale> http://planetmath.org/encyclopedia/TensorProduct.html
01:12:35 <ski> hmm, must the K really be a field ?
01:13:21 <ham[kell]> that retraction thing how is that defined?
01:13:30 <ham[kell]> is that in topological terms?
01:14:19 <ham[kell]> in topology its something like this
01:14:58 <ham[kell]> p|f : A -> X , p \in A
01:14:58 <Cale> ski: no: http://www-texdev.mpce.mq.edu.au/Quantum/Sect7/Sect7.html
01:15:55 <Cale> so it need not be a vector space either.
01:15:58 <ski> ham[kell] : well, (as far as i know) retractions belong in category theory. so if j : A -> X and p : X -> A and p.j = id, then j is called a section and p a retraction, and A is called a retract of B
01:16:30 <ski> ham[kell] : understood anything ?
01:16:35 <ham[kell]> er p|f : X -> A, f(x) = id_A 
01:17:06 <ham[kell]> ok that sounds at least somewhat similar
01:17:08 <ski> Cale : ok
01:17:28 <ham[kell]> A subset of X
01:17:43 <ski> Cale : now it sounds like it must be a ring ??
01:18:08 <Cale> yeah - at least a ring
01:18:21 <ski> why ?
01:18:40 <ham[kell]> and if you can find a homotpy of that f and the id_X fn plus it preserves all the As in that homotopy then its a strong deformation retraction
01:18:42 <ski> i don't see any ring properties used in the definition
01:18:47 <Cale> Well, you want something to work with usually. Rings are difficult enough to talk about.
01:19:08 <ham[kell]> rings are defined over a vector field arent they?
01:19:24 <Cale> rings are sets together with addition and multiplication
01:19:34 <ham[kell]> they are VF + a multiplication over the vectors
01:19:47 <Cale> that's an algebra
01:19:48 <ski> (sorry s/B/X/ above)
01:20:16 <Cale> an algebra is a vector space, or possibly a module, where an additional ring structure is imposed.
01:20:52 <Cale> i.e. Quaternions are a 4-dimensional algebra over the reals.
01:21:09 <ski> ham[kell] : now you lost me with 'homotopy', i'm afraid :)
01:21:38 <ham[kell]> a homotopy is a function h: [0..1] x X -> Y
01:21:49 <ham[kell]> and f,g: X -> Y
01:22:05 <ham[kell]> then h(0,x) = f(x), h(1,x) = g(x)
01:22:22 <Cale> homotopy is essentially: "these things can be continuously bent into one another without cutting"
01:22:30 <ham[kell]> yep
01:22:42 <ham[kell]> i got some code for homotope splines
01:22:50 <Cale> so for instance, a coffee cup is homotopic to a torus
01:23:01 <ham[kell]> and am working on homotopy for spline meshes
01:23:04 <ski> is an algebra a vector space ??
01:23:26 <Cale> ski: yes, usually - sometimes it's generalised a bit further to a module
01:23:26 <ham[kell]> a VS + multiplication of vectors
01:23:33 <ski> e.g. [Bool] ?
01:24:08 <Cale> that's an odd vector space, but I suppose, under the right conditions
01:24:16 <ski> or Natural ?
01:24:23 <Cale> not Natural
01:24:33 <Cale> think "complex numbers"
01:24:43 <Cale> or "quaternions"
01:24:46 <ski> but i thought Natural was an initial algebra ?
01:25:01 <Cale> that might be a different usage than this
01:25:16 <ski> then, if it is, surely it must then be an algebra
01:25:34 <Cale> you'd think, but "algebra" has a few meanings
01:26:13 <ham[kell]> its rather fields isnt it?
01:26:23 <ham[kell]> or a ring
01:26:49 <Darius> ski: Algebra as in abstract algebra, groups, rings, ideals not as in F-algebra.
01:27:17 <Darius> Of course, F-algebra is what I thought ham[kell] was talking about in the first place.
01:27:29 <Cale> "algebra" also might also mean a collection of subsets of a set satisfying certain properties under intersection and union
01:27:39 <Cale> er, - one of those alsos
01:29:03 <Cale> here - I'll grab a definition
01:29:11 <ham[kell]> lattices?
01:29:16 <ski> Darius : ok. i don't know very much about groups, rings, etc ... but i was under the impression that they were instances of F-algebras (with laws ?)
01:29:52 <ski> i was thinking about algebras as in http://citeseer.nj.nec.com/jacobs97tutorial.html
01:30:26 <ski> what about lattices ?
01:31:25 <ski> ham[kell] ?
01:31:50 <ham[kell]> Cale: said intersection and union
01:32:02 <ham[kell]> a structure closed under these opeartions
01:32:21 <Cale> http://planetmath.org/encyclopedia/Algebra2.html
01:32:28 <ski> ham[kell] : the homotopy h must be some sort of smooth ot continuous map, right ?
01:32:33 <Cale> that's the one that I know of with sets
01:32:45 <Cale> ski: yeah
01:33:30 <Cale> sigma-algebras are related to that definition and impose somewhat stronger conditions
01:34:01 <ham[kell]> ski: continous
01:34:16 <ski> surely boolean algebras is an algebra, also ?         :)
01:34:37 <ski> ham[kell] : thanks, wondered about the spelling
01:35:09 <Cale> the funny thing is that there are a whole bunch of mostly unrelated definitions of algebra
01:35:23 <Darius> ski: (responding to earlier) Probably, but that doesn't help you if you don't know what F is (i.e. the many laws that it satisfies).
01:35:57 <ski> Darius : but isn't that a part of F ?, just like the bare signatures ?
01:36:43 <ski> (or at least a part of the info defining a specific F-algebra. whatever the terminology is)
01:36:50 <Darius> Yes, that's the point.  You without knowing what the F is you can only make very general statements.
01:37:23 <ski> but that's true of the signatures as well, isn't it ?
01:37:27 <Darius> Algebra as in abstract algebra means a pretty specific thing and apparently there are other "algebras" too.
01:39:03 <Cale> Boolean algebras are sort of off on their own. There's algebras in the sense of sigma algebras used as the foundation structure for measure and probability theory, and then there's the more prominent module-with-ring-structure definition.
01:39:25 <Darius> Module with ring is what I mean by Abstract algebra algebra.
01:39:29 <Cale> yeah
01:40:06 <ski> Darius : is the word duplication intensional ?
01:40:13 <Darius> Yes.
01:40:20 <Darius> ski: Since F more or less describes the signature, then yes... ?
01:40:33 <ski> huh ? what ?
01:41:48 * Cale is away: sleeping.
01:42:14 <ski> anyway, the counit laws of that specific coalgebra thing seems like it has a type error, in my eyes..  ?
01:43:03 <ski> hmm, or is K a sub-something of A ??
01:43:09 <Darius> For an F-Algebra (as in category theory), the functor F usually holds the information of signature for the algebra.
01:43:42 <ski> what about the laws (for the non-anarchic ones) ?
01:44:30 <ski> are they contained in the functor ?  are they expressed by equalizers ???
01:45:29 <Darius> I think it can handle the laws on it's own.
01:46:02 <ski> ham[kell] : well, if we should find such a coalgebra example in haskell, what should the tensor product be ?  the pair type constructor ?
01:46:10 <ski> ok
01:46:14 <Darius> Or a more general definition of algebra in category theory may.
01:46:17 <ham[kell]>  i dont know
01:47:44 <ski> should the K be a sub-whatever of A ?
01:48:23 <ski> then perhaps we need some inclusion function
01:48:37 <det> an inclusion fucntion would destroy coassocitivity!
01:48:54 <ski> 'twould ?
01:49:11 <ham[kell]> det: so do you know an example for a coalgebra?
01:49:46 <det> ham[kell]: i am just crazy and clueless, did what I say actually make any sense? :)
01:49:59 <ski> what do they mean when they say "A coalgebra is a vector space A over a field K ...", isn't the over some sort of sub-relationship ??
01:50:15 <ham[kell]> nope
01:50:19 <ski> det : i have no idea
01:50:23 <ski> :)
01:50:27 <ham[kell]> the elements of the vectors are K
01:50:32 <ham[kell]> of K
01:50:41 <ski> ok
01:50:45 <ham[kell]> the scalars that is
01:51:22 <ski> and it is vector as in sequence of specified number of things, ok ?
01:52:10 <ski> (dunno if there are many different vector concepts from the one i know)
01:52:19 <ham[kell]> i dont know how to impose a vector field on number only
01:52:56 <ski> ?
01:53:17 <ham[kell]> what is the scalar multiplication then
01:53:18 <Darius> ski: Technically, in this case, a vector is an element of a vector space and that only has to satisfy the laws of the vector space.
01:53:40 <ski> sigh ;)
01:53:47 <ham[kell]> :)
01:54:26 <Darius> ham[kell]: If you mean "a vector field on a number only" as opposed to over a n-tuple, then scalar multiplication could just be multiplication.
01:54:46 <ham[kell]> yes but not with a single number
01:54:59 <ham[kell]> the scalar and the vector cant be of the same type
01:55:11 <ski> why not ?
01:55:22 <ham[kell]> cause then its a field
01:55:26 <ski> can't they even be isomorphic
01:55:29 <ski> ?
01:55:37 <ski> no
01:55:53 <Darius> So? You can have real scalars to real vectors.
01:56:07 <ski> only if you require that additionally structure ( = laws ), right ?
01:56:23 <ham[kell]> i mean 
01:56:38 <ham[kell]> a * b , a \scalar , b \in vectors
01:56:53 <ham[kell]> if a and b was of the same type its not a scalar multiplication
01:57:01 <Darius> Why not?
01:57:17 <ski> so ? i don't se what hinders the types of a and b to be identical
01:57:20 <Darius> The vectors could just happen to be scalars.
01:57:23 <ham[kell]> say it was both R
01:57:40 <ham[kell]> would yu then say its a scalar multiplication?
01:57:46 <Darius> Yes.
01:57:46 <ski> why not ?
01:58:23 <ham[kell]> ok R is bad
01:58:32 <ham[kell]> since it then would form a filed
01:58:40 <ski> the vector space would be a record, and it's two type fields would just contain the same type, no ?
01:58:46 <ham[kell]> with the * and +
01:59:20 <Darius> Well the scalars do need to form a field.
01:59:28 <ham[kell]> yes
01:59:44 <ham[kell]> but if the scalar multiplication is the same as in the field
01:59:46 <ski> so the records contains proof of that in another field
01:59:56 <ham[kell]> then its no information gain
02:00:07 <ski> what info gain ?
02:00:28 <Darius> So?  Just because you don't gain anything doesn't make it not a vector space.
02:00:34 <ham[kell]> if the scalar mul *_s = *_f
02:00:53 <ham[kell]> ok then any field also forms a vektor space?
02:00:58 <ham[kell]> -k+c
02:01:33 <ski> if all the laws are satisfied i would think so, yes
02:01:41 <ham[kell]> sec
02:02:02 <ham[kell]> x_s: S x V -> V
02:02:12 <ham[kell]> x_f: S x S - >
02:02:17 <ham[kell]> x_f: S x S -> S
02:02:28 <ham[kell]> now if V = S
02:02:47 <ham[kell]> x_s: S x V -> V => S x S -> S
02:02:59 <ham[kell]> and then its the same as x_f
02:03:09 <ski> at least same type
02:03:35 <ham[kell]> naturally the * would be the same
02:03:39 <ski> couldn't S be a field in two different ways ?  is that possible ?
02:03:48 <Darius> Typically, I don't think that's forced.
02:04:05 <Darius> (responding to ham[kell])
02:04:21 <ham[kell]> Darius: ok you can define another * on that but i think that very unnatrual for number that form a * already
02:04:36 <ski> i dunno
02:05:03 <Darius> It depends on what you are doing, if you just wanted to show that it's a vector space then yes that'd be the straight-forward way.
02:05:17 <ski> at least we can have interesting sets which are groups in two diff. ways, IIRC
02:06:55 <Darius> A field doesn't characterize the behavior I'm pretty sure, so it should be possible to find an example.
02:08:01 <ski> hmm, how can  (epsilon (x) id) o Delta = id  ?  (re that coalgebra again)
02:08:23 <ham[kell]> Darius: you have read the topics i have put down for my thesis havent you?
02:08:39 <ski> it seems the that  lhs : A -> K (x) A  to me ..
02:09:06 <Darius> ham[kell]: No.
02:10:07 <ski> (on http://planetmath.org/encyclopedia/Coalgebra.html i.e.)
02:10:58 <ham[kell]> Darius: http://codemages.sf.net/thesis.tex
02:11:19 <ski> ham[kell] : what's the type of the (x) in the laws ? isn't it a bifunctor map ?
02:11:20 <Darius> ski: Presumably k (x) A = kA or some such.
02:11:52 <ski> hmm
02:15:36 <ski> ham[kell] : what's graep ? some software system ??
02:16:45 <ski> ham[kell] : shouldn't it be 'concatenation' ?
02:16:53 <ham[kell]> its something i want to write my thesis about
02:17:04 <ham[kell]> oh yes :) its full of tyopos
02:17:20 <ski> but what *is* graep ?          :)
02:17:32 <ham[kell]> that what the thesis will be about
02:17:44 <ham[kell]> the idea is that you can process graphs
02:17:51 <ski> i have no idea what 'graep' means
02:17:56 <ham[kell]> and use then for representation
02:18:00 <ski> mhm
02:18:10 <ham[kell]> graph representation/processing
02:18:38 <ski> ahm
02:19:16 <ham[kell]> gra p(rosessing), g(raph) rep(resentation)
02:19:19 <ski> 'defninition'
02:19:25 <ski> :)
02:21:53 <ski> directed graphs, i guess
02:29:47 <ski> Darius : busy ?
02:31:43 <Darius> not really
02:34:21 <ski> re the retracts again, if s : A -> B and r : B -> A and r.s = id_A, surely we can e.g. set s to some inclusion of A into B (the fixpoints of the idempotent), so then r essentially becomes the idempotent ?
02:35:13 <Tensor> hello, i'm totally new to haskell and i'm intrigued, are thre any free ebooks on haskell available ?
02:36:22 <ski> and this would perhaps correspond to approximating a type by some subtype (canonical elements) of some (probably structurally simpler) "larger" type ?
02:36:24 <Darius> To learn Haskell?
02:36:27 <ski> Tensor : hi
02:36:35 <Tensor> yep
02:36:55 <ski> hmm, i dunno about any ebooks
02:36:58 <Darius> There are some sizeable tutorials
02:37:03 <ski> yes
02:37:25 <Tensor> hmmm, ok, i'll just check on the tutorial links on the haskell site
02:37:26 <Tensor> thanks
02:37:28 <ski> and some real dead-tree-books as well
02:37:52 <ski> Tensor : have you programmed in any functional language before ?
02:38:23 <Tensor> nope, just "imperative" languages, as you might call them
02:38:26 <ski> ok
02:38:45 <ski> well, you can always ask questions here, of course
02:39:05 <ski> and there is a wiki at http://www.haskell.org/hawiki
02:39:06 <Tensor> yeah, but i got to have some base first
02:39:12 <ski> yeah
02:39:23 <Darius> ski: If s were an "inclusion" that would imply that B is "larger" than A, but the properties of the retraction pair imply that A is "larger" than B, that would mean A and B would be the same "size" and likely isomorphic.
02:39:43 <ski> hmm, some people have said that the socalled "Gentle" introduction isn'
02:39:49 <ski> isn't so gentle
02:39:56 <ski> i dunno
02:40:34 <Darius> It assumes you're somewhat familiar with functional languages and it's rather short so it'd have to move fast.
02:40:44 <ski> Tensor : just so you know you're not an idiot if you should find it difficult ;)
02:41:45 <ejt> Tensor: if you enjoy the tutorials I suggest you buy a copy if Bird sooner, rather than later (I left it late which was a mistake)
02:41:48 <Tensor> hah! good thing you mentioned that, was starting to feel moronic
02:41:59 <ski> Darius : umm ?, we have r.s : A --> B --> A = id_A, wasn't it B which were bigger than A ?  have i misunderstood ?
02:43:47 <Tensor> ski: what's Bird?
02:45:08 <ski> Tensor : Bird's a textbook IIRC
02:45:25 <Darius> More like he wrote a book...
02:45:38 <Tensor> ok, check, brb guys
02:45:50 <ski> Tensor : on http://www.haskell.org/bookshelf/
02:46:53 <ski> Darius : well ?
02:47:13 <Darius> ski: Er, yes, you're right.
02:47:33 <Darius> I think.  (or maybe there's a lack of that, I'm somewhat tired).
02:49:15 <Darius> Yes you're right.  When I think retraction I think more of the retraction pair and of a retractable morphism.
02:49:30 <ski> ok
02:50:38 <Darius> I'd think s would usually be an "inclusion" like function, it is a mono.
02:50:52 <ski> aha
02:50:56 <Darius> s/function/morphism/
02:51:01 <ski> mm
02:52:07 <Darius> I've got myself more oriented so I should say stupid stuff less often.
02:52:45 <ski> "retracttype A = R {S :: B} with idempotent = ..."
02:52:48 <ski> hmm
02:53:34 <ski> perhaps R could act as some sort of constructor, and S as a deconstructor
02:53:59 <ski> with R . S = id  and S . R = idempotent
02:55:28 <ski> e.g. one could perhaps imagine R always applying the idempotent (canonicalization) before storing the value of implementation type B inside, and then S is just an extractor
02:57:36 <ski> or R could just store the value of type B and S would be the 'active' one, applying the idempotent
02:58:01 <Darius> The thing is you could use s to send to B do some B operations then what would r do if it's outside the range of s?
02:58:25 <ski> this second way would correspond more to the equivalence class impl. method i think
02:58:47 <ski> um ?
02:59:39 <ski> are you talking of the first or second impl. method above or otherthing ?
03:00:30 <Darius> It should be an issue in general.  The retraction is only a "retraction" if you are talking about things in the range of the section.
03:00:31 <ski> (1st : R is active,S is passive. 2nd : R is passive,S is active)
03:01:04 <ski> how could we come outside B ?
03:02:00 <ski> huh ?
03:02:08 <Darius> Assume A is Int16, B is Int32, s converts an Int16 to an Int32 and r converts values between min/maxBound :: Int16 in Int32 to Int16.
03:02:33 <Darius> such that s;r = id_(Int16)
03:02:57 <ski> and how is r defined for the other values in Int32 ?
03:03:20 <Darius> That's the issue.  It being a retraction says nothing about what it does on other values.
03:03:44 <ski> if r is some sort of (total) function, it must map all values of Int32 to Int16, right ?
03:04:19 <ski> to some values in Int16
03:04:28 <Darius> Who says it's a total function and so what?  It could take any out of range value to any in range value.
03:04:53 <Darius> So, r (s maxBound + 100) could be anything.
03:05:04 <ski> and then if we map then back with s, then we are within the min/maxBound of Int16 inside Int32, no ?
03:05:39 <Darius> Yes.
03:06:15 <ski> yes
03:06:20 <ski> i agree
03:06:31 <ski> but what about it ?
03:07:49 <ski> ?
03:07:58 <Darius> Probably nothing.  I only said less stupid stuff not no stupid stuff.
03:08:58 <Darius> Anyways, so where were you?
03:09:27 <ski> i'm not entirely happy with the 2nd, though
03:10:29 <Darius> I'd have s do the work.
03:10:39 <ski> i was thinking that one should be able to choose, when writing the definition/implementation of the type A, which of the two methods it should use
03:11:00 <Darius> In fact, s would have to do the work I'd think.
03:11:43 <ski> isn't it sometimes best to use the canonical version, and sometimes the equiv. class one ?
03:11:55 <ski> or is one always better ?
03:12:23 <Darius> Using the Int16/Int32 example, effectively this would be implementing Int16s in terms of Int32s.
03:12:52 <ski> hmm, if s would do the work, then this is the equiv class version (2nd above)
03:13:01 <Darius> Er r will always have to do the work.
03:13:10 <ski> ?
03:13:13 <ski> why ?
03:13:46 <Darius> Give me a sec, I should write down r and s.
03:13:47 <ski> can't we say that the points of A are equivalence classes over B (with the idempotent)
03:14:10 <ski> s : A -> B  r : B -> A  r.s = id_A
03:15:00 <ski> and then, if A's points are equivalence classes, we could implement them by a member of that equiv class
03:15:24 <Darius> The way I'd think of it is we'd want to use the operations of the implementation type B as-is.
03:15:56 <ski> yes
03:16:22 <ski> either on canonicalized elements, or on elements living in equiv classes
03:16:30 <ski> hmm
03:16:41 <Darius> s is just an inclusion, it doesn't really do anything.
03:16:56 <ski> in 1st, yes
03:17:23 <ski> in 2nd it could canonicalize, so to speak, in the last minute
03:17:51 <Darius> Yes, I guess that's reasonable.
03:18:47 <ski> but, can we do things like  (n0,d0) == (n1,d1) = n0*d1 == n1*d0  ?
03:18:51 <Darius> The thing that was making me think otherwise would be other operations, but they'd really be "implementation" type operations so you'd use s anyways to ever observe an A.
03:18:52 <ski> hmm
03:19:10 <ski> yes
03:20:36 <ski> hmm, wonder if there is any middle-stage between 1st and 2nd (i.e. both s and r nontrivial implementations) ?
03:24:31 <ski> retracttype Rational = ToRat {FromRat :: (Integer,Integer)} with idempotent (n,d) = (n `div` f,d `div` f) where f = gcd n d
03:24:37 <ski> hm
03:25:36 <ski> or perhaps "... with FromRat (ToRat (n,d)) = ..."
03:31:51 <Darius> Okay.  Now that you have this what are you going to do with it?
03:32:01 <ski> well, i dunno :)
03:32:10 <ski> think more on it i think
03:32:30 <Darius> Hmm, what if the idempotent isn't idempotent?
03:32:39 <ski> yes
03:32:46 <ski> that's a problem, of course
03:33:04 <ski> we could do just like with the typeclasses
03:33:16 <ski> i.e. programmer proof obligation
03:33:36 <ski> (monadic laws and such)
03:34:19 <ski> or if we had some way of specifying laws as types and their proofs as values, we could always do like that
03:34:48 <ski> (but i think that would probably require something like dependent types, no ?)
03:35:39 <ski> http://www.mdstud.chalmers.se/~md9slj/code/Retracts.hs
03:38:08 <ski> or can one weaken dependent types sufficiently ?
03:38:16 <ski> (but not too much)
03:38:52 <Darius> You'd be attempting to prove the equality of arbitrary functions
03:39:31 <ski> no, not arbitrary, just the ones that one uses in the implementation
03:40:10 <ski> (i'm thinking along programmer writes proof, machine checks it. not general theorem proving)
03:40:14 <Darius> Which can be arbitrary functions.  Unless you restrict the form of idempotent I'm not sure how much a decideable type system would help.
03:40:59 <ski> hmm
03:41:06 <Darius> What would be just enough to say that f . f = f?
03:41:33 <ski> sorry, i don't understand
03:42:25 <Darius> I'm wondering what's the least amount of proof that you could give in general to prove f.f=f.
03:42:38 <ski> for specific f's
03:42:52 <ski> hmm, not sure
03:44:51 <ski> for the Rational case, for the idempotent of it, we'd have to prove that if we cancel out the gcd of the numerator and denominator, then the new ones have 1 in gcd
03:45:28 <ski> (so if we cancel out 1, we get the same num. and denom.)
03:45:46 <ski> agree ?
03:46:09 <Darius> Yes
03:47:21 <Darius> A more clear statement of what I was thinking is what is the least powerful logic that could prove f.f=f if that were the only form of equations it had to handle.
03:47:28 <ski> that of course means we're gonna need "primitive" proofs of various things regarding Integers and such
03:47:41 <ski> aha
03:47:42 <ski> ok
03:48:00 <ski> i was thinking of some equational logic
03:48:22 <ski> but we perhaps don't need all that machinery for this..
03:50:03 <Darius> Hmm, perhaps a better question is what is the least amount of information about f that we could use to derive f.f=f short of having that as an axiom.
03:50:31 <ski> hmm
03:51:43 <ski> I was gonna say that if we know r.s = id then we know that s.r is an idempotent, but it's s and r we're trying to construct, so that idiotic plan doesn't work ;)
03:55:15 <Darius> Well a different question aiming more for convenience is whether and how often we could derive idempotency from the properties like associavity, commutativity, units, idempotency of the operations in the implementation.
03:56:03 <ski> umhmm
03:58:17 <ski> well, at least the idempotent should be checked somehow, perferably
03:58:23 <Darius> Well it seems for the rational example you'd need to know that dividing by the GCD will make to numbers relatively prime which is rather specific information and not likely to follow from coarse properties of the operations in the implementation of gcd.
03:58:40 <ski> yes
03:59:06 <Darius> ski: You could generate the proper QuickCheck specification trivially.
03:59:13 <ski> perhaps unique factorization modulo ordering or something like that
03:59:35 <ski> well, yes i can :)
03:59:53 <ham[kell]> bk
04:00:08 <ski> hmm, have people used that for checking, say monadic laws ?
04:00:30 <ski> or say, laws for the Eq/Ord/Num classes ?
04:00:46 <ski> ham[kell] : hi
04:00:53 <ham[kell]> isnt an algebra over lists a bialgebra?
04:01:01 <Darius> ski: I'd think so.
04:01:08 <ski> ;)
04:01:15 <Darius> ham[kell]: Specify "algebra".
04:01:44 <ham[kell]> something like *: AxA->A
04:01:54 <ham[kell]> that is prepend an element
04:02:00 <ham[kell]> and in the coalgebra
04:02:06 <ham[kell]> A->AxA
04:02:13 <ski> Darius : hmm, wouldn't the (==) in my file also need a proof, really ?
04:03:11 <ski> Darius : (because I don't check equality after applying the idempotent, but rather 'short-cutting')
04:05:14 <ski> ham[kell] : with a unit also ?  (u : 1 -> A)
04:05:25 <ski> (or whatever)
04:05:47 <ham[kell]> hm
04:05:51 <Darius> ski: If pattern matching ToRat is equivalent to applying fromRat shouldn't it be canonicalized?
04:05:56 <ham[kell]> rather the empty set
04:06:15 <ski> Darius : yes, i'm thinking about that .. :(
04:07:06 <ski> hmm, i forgot, was fromRat or ToRat the section ?
04:07:28 <Darius> fromRat
04:07:31 <ski> yes
04:09:12 <ski> so pattern-matching ToRat (n',d') on the value ToRat (n,d) would probably mean the same as (n',d') = fromRat (ToRat (n,d))
04:09:33 <ski> yes
04:09:45 <ski> fromRat . ToRat is the idempotent
04:10:49 <Darius> Since the only thing you can do to a Rational is convert it to the implementation type, yes it would always be of that form.
04:11:03 <ski> so, unless we also provide some kind of dirty variant of pattern-matching it seems like we can't define == as we want. hmm :(
04:11:52 <Darius> Just intepret pattern matching ToRat as applying fromRat.  It will be trivial when you canonicalize eagerly.
04:13:05 <ski> intuition says that if we prove that == doesn't discern/separate elements of the same equiv. class, then we ought to be authorized to look at the representant of the equiv. class, nakedly
04:13:25 <Darius> Yes, but then you need to prove it.
04:13:55 <ski> yes, and i don't see how it justifies the naked view, although it feels right :(
04:16:06 <ski> hmm, for (+) and so on we want the language process to understand that because we hide the num.s and denom.s again behind a ToRat, it doesn't have to canonicalize
04:16:25 <Maddas> Hm, typeclasses are awesome
04:16:36 <ski> perhaps one could have something similar to restricted type synonyms
04:16:54 <ski> Maddes : yes, they're nice :)
04:17:10 <ski> s/process/processor/
04:17:28 <Darius> Well you'd get that with the most straightforward implementation assuming toRat did the work.
04:17:40 <ski> ?
04:17:51 <ski> sorry again ?
04:19:14 <ski> Maddas : you're using them now ?
04:19:27 <Maddas> ski: Learrning, but I used them the first time, yeah
04:19:29 <Maddas> learning, even
04:19:35 <Maddas> They seem 
04:19:39 <Maddas> err, they seem very useful
04:19:59 <Darius> You could simply translate each retracttype into it's own module as an ADT.  The private functions could use a ToRat construct/pattern matching directly which doesn't canonicalize and expose a toRat function which did.
04:20:15 <Maddas> Is there any documentation on the functions in core/Pervasives?
04:21:36 <ski> Darius : yes, hmm. . . Don't you think something like restricted-type-synonyms could worrk
04:21:39 <Darius> Prelude/Standard functions?
04:21:53 <ski> Maddas : talking ghc ?
04:22:16 <Maddas> ski: I don't know, just some place to look up what a function does
04:22:27 <Maddas> Doesn't need to be elaborate, just a brief description will do :-)
04:22:41 <Darius> www.haskell.org/learning has a references section.
04:22:51 <Maddas> Ok, thanks :)
04:23:27 <Darius> ski: Yes it would work fine as well.
04:23:45 <ski> how did you envisage it ?
04:24:39 <ski> how should the system know not to use the idemp. ?
04:24:52 <ski> just by being an ADT ?
04:26:09 <ski> i was thinking that if one used a restr.-type-syn. version then we wouldn't (i think) use the constructor ToRat in the patterns and bodies at all
04:27:12 <ski> hmm
04:27:29 <Darius> It simply wouldn't perform the translation rat@(ToRat _) => fromRat rat for the functions that are in the same module and it would be the programmer's job to make sure everything is fine.
04:27:49 <ski> ok
04:27:52 <ski> mhm
04:35:03 <Darius> Well this should work if fromRat does the work too though it would be a different trade-off.
04:35:55 <ski> um
04:37:19 <ski> do you mean s/fromRat/ToRat/ ? or do you mean like fromRat is active also in internal operations
04:37:37 <ski> probably latter (?)
04:38:05 <Darius> I mean that fromRat does the canonicalization (i.e. lazy canonicalization).
04:38:16 <ski> ok
04:38:22 <ski> yes
04:44:25 <Maddas> Hm
04:44:55 <Maddas> I don't want to be a nuisance, but I really can't get my head to wrap around reads
04:45:12 <ski> well, i thought that the retract concept had something to do with this kind of appoximating types by making equivalence classes ..   seems like it's quite interesting
04:45:21 <ski> ok
04:45:24 <Maddas> Or rather this function that uses it
04:45:31 <ski> which ?
04:45:35 <Maddas> Sorry for interrupting your discussion, ski :-)
04:45:40 <Maddas> just a second
04:45:42 <ski> oh
04:46:01 <ski> no. was just talking to myself. no problem ;)
04:46:02 <Maddas> readTree ('<':s) = [(Branch l r, u) | (l, '|':t) <- readsTree s, (r, '>':u) <- readsTree t ]
04:46:09 <Maddas> readsTree s       = [(Leaf x, t)     | (x, t)     <- reads s]
04:46:24 <Maddas> basically, it parses a string of the format "<<10|20>|30>"
04:46:34 <Maddas> Not necessarily integers though, just some type :-)
04:46:44 <ski> yes, i see
04:47:01 <Maddas> It creates a Tree out of them, defined as data Tree a = Leaf a | Branch (Tree a) (Tree a)
04:47:08 <Maddas> (yes, I didn't get very far in the meantime :-))
04:47:09 <ski> 'twould perhaps look a bit nicer as a monad
04:47:35 <Maddas> It said that monadic parser combinations are more elegant, but I'd like to understand this :)
04:47:57 <ski> yes
04:47:57 <Maddas> I don't get how it traverses the data structure
04:47:58 <ski> :)
04:48:13 <ski> do you know list comprehension ?
04:48:17 <Maddas> The string, that is. In fact, I don't get how the whole function works (sorry)
04:48:34 <Maddas> The [(something, else) | foo <- bar ] thing?
04:48:39 <ski> yes
04:48:55 <Maddas> A little :-)
04:49:19 <Maddas> I understand it for simple cases, say [(x,y) | x <- [1,2,3], y <- [1,2,3], x /= y]
04:49:50 <ski> Prelude> [ ('a',x,x*x) | x <- [1..20] , x <= 5 || x >= 15 , odd x ]
04:49:50 <ski> [('a',1,1),('a',3,9),('a',5,25),('a',15,225),('a',17,289),('a',19,361)]
04:50:01 <Maddas> The (l, '|':t) <- readTree s simply calls readTree s and assigns the 
04:50:04 <Maddas> value to (l, '|':t), not?
04:50:23 <Maddas> Sorry for excessive newlines, I always accidentally hit the newline shortcut. Annoying keyboard 
04:50:39 <ski> no prob
04:50:42 <Maddas> ski: Yeah, I understand that
04:50:47 <ski> :)
04:51:17 <ski> well, it calls readTree s, yes
04:51:47 <Maddas> I think what causes the problems is the second call
04:51:58 <ski> and since we have faith in recursion, we belive that it will try to parse a tree
04:52:01 <Maddas> I'm not sure what that returns when it's called (and on what it is called)
04:52:05 <Maddas> Haha :-)
04:52:18 <ski> Prelude> :i ReadS
04:52:18 <ski> -- type constructor
04:52:18 <ski> type ReadS a = [Char] -> [(a,[Char])]
04:52:32 <ski> Prelude> :i reads
04:52:33 <ski> reads :: Read a => ReadS a
04:53:03 <ski> so actually reads :: Read a => String -> [(a,String)]
04:53:29 <Maddas> hm, :i, I didn't know that. Thanks :)
04:54:29 <ski> um, think that works in ghc, but not totally sure
04:55:09 <Maddas> Using HUGS for now
04:55:43 <ski> well, um. yes, waitagain. readTree :: Read a => ReadS (Tree a)  right ?
04:55:54 <Maddas> Yup
04:56:19 <ski> i.e. readTree :: Read a => String -> [(Tree a,String)]
04:56:43 <ski> so we of course see that the arg of readTree is indeed a String
04:56:43 <Maddas> Ok
04:56:51 <Maddas> Yup
04:57:19 <ski> but, yes, the recursive call, "readTree s", this gives a list of pairs of trees and strings
04:57:29 <ski> what can this type mean ?
04:58:02 <Maddas> I know that it's a parser because I read it, but I'm not sure what else you mean
04:58:37 <ski> i mean, what *is* this list of pairs of trees and strings we get back from readTree s
04:58:48 <ski> how does it look like ?
04:58:56 * Maddas does a test run
04:58:58 <ski> what should we do with it ?
04:59:26 <ski> well, actually it's not so tied in to readTree
04:59:50 <Maddas> readesTree "<10|<20|30>>" gives Unresolved overloading
05:00:03 <ski> we need to understand what the type (constructor) ReadS *is*, right ?
05:00:09 <Maddas> Yeah
05:00:10 <ski> uh
05:00:52 <ski> try  readTree "<10|<20|30>>" :: [(Tree Int,String)]
05:00:56 <ski> (i think)
05:01:12 <Maddas> Yup
05:01:15 <ski> does it work
05:01:17 <ski> ok
05:01:31 <Maddas> It returns [(<10|<20|10>>,"")]
05:02:00 <ski> (i think it complained because it didn't know what kind of thing it should try to parse as the leafs of the tree)
05:02:05 <ski> yup
05:02:14 <Maddas> Hm
05:02:32 <Maddas> I see there are some examples of reads later on, maybe I should skip this one and read up, and try again later
05:02:34 <ski> try  "<10|<20|30>><0|0>"  :: [(Tree Int,String)]
05:03:12 <Maddas> I see, it seperates the trees
05:03:28 <ski> now try  "<10|<20|30>>jkdhsfjkhhkfj"
05:03:42 <ski> (or something similar)
05:04:03 * Maddas nods
05:04:08 <ski> you see ?
05:04:26 <ski> also try  "<10<20|30>>"
05:04:38 <ski> what do you get this time ?
05:05:02 <Maddas> An empty string instead of jkhkhsfksjkk
05:05:06 <ski> yes
05:05:14 <ski> um
05:05:18 <ski> no
05:05:25 <ski> didn't you get [] ?
05:05:30 <Maddas> No
05:05:34 <ski> ok
05:05:42 <ski> lemme see what you got
05:05:50 <Maddas> readsTree "<10|<20|30>>":: [(Tree Int, String)]
05:05:52 <Maddas> [(<10|<20|30>>,"")]
05:05:57 <ski> ah
05:06:00 <ski> ok
05:06:09 <ski> i said try  "<10<20|30>>"   :)
05:06:16 <ski> see ?
05:06:22 <Maddas> Oh, missed that :-)
05:06:33 <Maddas> Yeah, I see
05:06:49 <ski> good
05:07:17 <ski> well, the list represents all possible different ways of parsing in whatever we were parsing
05:07:58 <ski> most often the list is either empty or has exactly one solution (i.e. i mean element)
05:08:26 <ski> sometimes it's useful to have several different ways of parsing in something
05:08:42 <ski> R U with ?
05:09:05 <Maddas> Yes
05:10:14 <ski> but, to parse in something big and complex, one usually eats a little from it at a time, beaking off characters from the left of the string
05:10:38 <ski> ok ?
05:10:59 <ski> s/beaking/breaking/
05:11:27 <Maddas> Yeah, I understand
05:11:38 <Maddas> But how does it read the things exactly, that's what I don't understand
05:11:44 <Maddas> First, it checks for a beginning <
05:11:45 <ski> e.g. in readTree, first we just try to patternmatch away a '<', but then we try to eat a whole /sub-)tree
05:11:47 <ski> yes
05:11:50 <ski> exactly
05:12:17 <Maddas> Then, it gets a bit confusing :-)
05:12:19 <Darius> let [(t1,s)] = reads "<10|<20|30>><0|0>foobar" in (t1,fst (head (reads s)))
05:12:44 <ski> so, after the first subtree is gone from the list, we still have the rest of the string to consume
05:13:14 <Maddas> I think I should just take a piece of paper and write things down
05:13:36 <Maddas> Step by step :)
05:13:49 <ski> yes, i know it can be a little confusing to keep in mind both the many-solutions-thing *and* the not-eaten-all-of-it-yet-thing :)
05:14:58 <Maddas> I think this constant background noise (ventilator) and the terrible heat in this room together with the people walking around isn't helpful either
05:15:47 <ski> perhaps you could get some fresh air or something if you feel tired ..
05:16:05 <Maddas> Not tired, just annoyed. But yes, I will have a proper look at it when I'm home again
05:16:20 <Maddas> Thanks :-)
05:17:59 <ski> perhaps it would be easier if you tried to make a version of readTree which always gave one solution, not a llist of them  (calling error if it couldn't parse correctly)
05:18:05 <ski> i'm not sure
05:18:33 <ski> ok
05:31:06 <Maddas> I'll have a look at it later :)
05:31:17 <ski> mm
07:07:22 * Maddas dances happily
07:07:26 <Maddas> ski: I think I understood it now.
07:08:02 <Maddas> ski: My problem was that I did not understand typeclasses properly, which was why I didn't understand reads.
07:11:24 <ski> aha
07:11:26 <ski> ok
07:11:29 <ski> nice :)
07:14:24 <Maddas> Yes, I'm happy about it
07:20:17 <ski> ok, wanna talk anymore ?  (i'm leaving quite soon i think)
07:21:02 <Maddas> No, I'll be ok, thanks
07:31:42 <ski> hi shapr
07:32:24 <shapr> hej ski, vad händer?
07:32:24 * Maddas bonks shapr 
07:32:31 * phubuh arrives
07:32:42 * shapr zoinks Maddas 
07:32:44 * Maddas bonks phubuh too while he's at it
07:32:49 <ski> hej
07:32:55 <Maddas> heh :-)
07:33:05 * shapr explorbs Riastradh 
07:33:06 <ski> jag ska precis cykla hem
07:33:18 <shapr> det är bra, motions verkar
07:33:19 <shapr> um
07:33:24 <shapr> what's the motions exercise thingy?
07:33:36 <shapr> it's -27°C here at the moment
07:34:01 * ski slasps Maddas with a big retract
07:34:30 <ski> well, i think it's somewhere around 0C here
07:34:56 <ski> "motions exercise thingy" ?
07:35:07 <Maddas> Retract? Hm
07:35:10 <shapr> there are two kinds of swedish exercise
07:35:15 <shapr> motions and something else
07:35:31 <ski> ok, didn't know that
07:35:33 <phubuh> motion and trÃ¤ning, maybe
07:35:42 <shapr> ah, probably so
07:35:45 <ski> :-P
07:35:59 <shapr> phubuh: yes, I think that's it, thanks.
07:36:16 <phubuh> motion is stamina excercise, trÃ¤ning is ... well, mostly every other kind of excercise, I think
07:36:34 <ski> Maddas : you can always slasp someone else if you feel grumpy :)
07:36:50 <shapr> slasp? what's that?
07:36:58 <Maddas> ski, heh
07:37:49 <ski> slasp ?
07:38:45 <ski> well, my brother and some others used that word a lot at some #allegro, and i think the word sound fun
07:38:51 <shapr> heh, ok
07:38:57 <shapr> I make up my own words also.
07:39:20 <shapr> for the last decade or so, I have insisted that those things that control TVs/VCRs/etc are etomers
07:39:36 <ski> they had slasp-fests at times :)
07:39:44 * shapr grins
07:39:48 <ski> etomers ?
07:40:01 <ski> sounds weird
07:40:02 <shapr> reverse $ init "etomers"
07:40:27 <ski> a-ha !
07:40:48 <Maddas> Is $ just used to change precedence?
07:40:49 * ski says that out alound
07:41:04 <ski> yes, and to write less parens
07:41:04 <Maddas> (Or rather: Is it ok if I just use it for that without knowing about what else it does/can do?)
07:41:16 <phubuh> Maddas: yeah, it's like the "whitespace operator", but it binds really really loosely
07:41:18 <ski> @prelude ($)
07:41:19 <lambdabot> ERROR: connect: does not exist (Connection refused)
07:41:23 <Maddas> cool, I like that
07:41:24 <ski> doh
07:41:32 <phubuh> yeah, it's great
07:41:32 <Maddas> (Just like I like pretty much else that I understand about Haskell)
07:41:36 <phubuh> hee hee :-)
07:41:41 <shapr> @type ($)
07:41:41 <lambdabot> ($) :: (a -> b) -> a -> b
07:41:55 <shapr> @type (reverse init "foo")
07:42:00 <shapr> @type (reverse $ init "foo")
07:42:01 <lambdabot> reverse $ init "foo" :: [Char]
07:42:08 <phubuh> @type (reverse . init "foo")
07:42:15 <Darius> @type map ($ 3)
07:42:16 <lambdabot> map (flip ($) 3) :: Num a => [a -> b] -> [b]
07:42:17 <phubuh> @type ((reverse . init) "foo")
07:42:18 <lambdabot> (reverse . init) "foo" :: [Char]
07:42:30 <Maddas> Oh, the . operator is just the opposite?
07:42:34 <shapr> lambdabot is a great teaching tool
07:42:44 <phubuh> no, dot is functional composition
07:42:49 <Maddas> Ah, ok
07:43:02 <ski> @type reverse . init $ "foo"
07:43:02 <lambdabot> reverse . init $ "foo" :: [Char]
07:43:03 <phubuh> reverse . init is a function that takes an argument, passes it to init, passes the result of that to reverse, and returns that
07:43:06 <shapr> I'm tempted to add :t as an alias for @type
07:43:15 <Maddas> Cool
07:43:28 <phubuh> it's definable in ocaml as let compose f g x = f (g x)
07:43:28 <Darius> @type (.) . (.)
07:43:29 <lambdabot> (.) . (.) :: (a -> b) -> (c -> d -> a) -> c -> d -> b
07:43:42 <Maddas> phubuh: Yeah, I see
07:43:49 <ski> yes, thats also fun
07:44:02 <ski> (and useful)
07:44:04 <Maddas> @type (.) (.)
07:44:04 <lambdabot> ((.) .) :: (a -> b -> c) -> a -> (d -> b) -> d -> c
07:44:06 <Maddas> :->
07:44:20 <shapr> actually, that's a useful operator
07:44:35 <ski> shapr : Maddas' ?
07:44:41 <shapr> it lets you compose multi-arg functions, iirc
07:45:19 <shapr> oh hey
07:45:22 <Darius> @type (.) . (.) . (.)
07:45:23 <lambdabot> (.) . (.) . (.) :: (a -> b) -> (c -> d -> e -> a) -> c -> d -> e -> b
07:45:36 <Maddas> reverse . init "foo" is equivalent to reverse $ init "foo", isn't it?
07:45:36 <Darius> @type ((.) . (.)) . (.)
07:45:37 <lambdabot> ((.) . (.)) . (.) :: (a -> b) -> (c -> d -> e -> a) -> c -> d -> e -> b
07:45:38 <shapr> Ninja Jones and I have been working on the projects.haskell.org proposal
07:45:47 <ski> Maddas : yes
07:45:52 <Maddas> Ok :)
07:46:00 <ski> um
07:46:04 <Darius> no
07:46:08 <andersca> shapr: http://www.cs.chalmers.se/~josefs/tapl/
07:46:09 <phubuh> Maddas: no, you need parens
07:46:09 <Maddas> Hm, ok.
07:46:12 <andersca> shapr: I'm tempted to take this course
07:46:21 <Maddas> I see. I still need to learn about precedence :)
07:46:22 <phubuh> (reverse . init) "foo" is equivalent to reverse $ init "foo"
07:46:25 <ski> no  reverse . init $ "foo"  is equiv to reverse $ init "foo"
07:46:36 * Maddas nods
07:46:38 <phubuh> yeah, that too
07:46:47 <shapr> and I wanted to ask for input from #haskell
07:47:20 <Darius> @type (.) . ((.) . (.))
07:47:20 <lambdabot> (.) . (.) . (.) :: (a -> b) -> (c -> d -> e -> a) -> c -> d -> e -> b
07:47:22 <phubuh> andersca: I've heard great things about TAPL the book
07:47:30 <phubuh> shapr seems to like it at least :-)
07:47:39 <shapr> yes, I do like it.
07:47:46 <Maddas> Can you study (and pass) at Chalmers without knowing Swedish?
07:47:46 <shapr> it's fun!
07:48:10 <shapr> jag vet inte, men jag tror du måste ha svenska for Luleå Teknisk Uni
07:48:32 <andersca> Maddas: there's an international master's programme
07:48:35 <shapr> or, in engelska, I dunno, but I bet you need it for the uni next to me
07:48:48 <Maddas> andersca: I see
07:52:14 <ski> well, time to go
07:52:18 <ski> bye
07:52:27 <shapr> cya
07:55:46 <polli> b
07:55:48 <polli> ops
07:59:25 <ham[kell]> Darius: still there?
08:01:01 * Darius checks.
08:01:12 * shapr wonder if the reality check bounced
08:01:31 <ham[kell]> Darius: i found an example for some comultiplication thing i think
08:01:57 <ham[kell]> when you have an automaton you have two functions
08:01:57 <shapr> ok guys, I'd like feedback : http://www.scannedinavian.org/AvianWiki/HaskellProjects
08:02:17 <ham[kell]> delta: S x D -> S
08:02:34 <shapr> both SyntaxNinja and I have worked on that, and the spiffy quote from the HC&R report was found by Darius 
08:02:42 <ham[kell]> and bla: S -> D 
08:03:31 <ham[kell]> then you can define delta as d(s,e) = d(s)(e) , delta': S -> S^D
08:04:02 <shapr> if you have any suggestions for improving the text on that page, I'd like to hear it.
08:04:04 <ham[kell]> and on both od these new functions alpha: S -> D x S^Sig
08:04:07 <ham[kell]> then you can define delta as d(s,e) = d(s)(e) , delta': S -> S^Sig
08:04:27 <shapr> If not, I'm going to send it off
08:05:44 <Maddas> shapr: I really like the idea!
08:06:19 <shapr> that's great, any content or editing suggestions for the article?
08:07:09 <Maddas> Nope
08:12:16 <shapr> anyone else?
08:12:31 * shapr waves the 'comments requested' flag
08:14:12 <shapr> hello! anyone awake?
08:14:25 * SyntaxNinja waves the 'look at shapr's flag' flag
08:14:28 * Maddas snores loudly
08:14:31 * shapr laughs
08:15:29 <shapr> Igloo: ayh?
08:15:50 <shapr> kosmikus: not away?
08:15:54 * shapr pokes and prods
08:16:02 <Igloo> Yup
08:16:30 <Igloo> I think the green really brings out your eyes
08:16:37 * shapr snickers
08:16:41 <earthy> kosmikus is away
08:16:46 <earthy> I just saw him leave.
08:16:50 * Igloo spots what you actually wanted comments on
08:17:00 <shapr> earthy: ah, but *you're* awake
08:17:17 <earthy> er, yeah?
08:17:44 <shapr> could you take a moment to give any content or editorial feedback on http://www.scannedinavian.org/AvianWiki/HaskellProjects ?
08:17:53 <earthy> just looking at it. :)
08:17:57 <shapr> thanks!
08:18:36 <Igloo> I think the hws bit etc could be worded more along the lines that we could move ot them as and when they provide the necessary features and stability (unless they already do)
08:19:05 <Igloo> My reading of that page implies to me anyone would be able to edit any project
08:19:11 <shapr> ah, hm
08:19:14 <shapr> that's a good point.
08:19:15 <earthy> yup.
08:19:40 <shapr> rewordings hws, etc won't be hard
08:19:41 <earthy> besides, it presupposes knowledge of sourceforge
08:19:51 <shapr> oh, that's also a point I hadn't thought of
08:20:19 <shapr> where is it implied that project access is wiki-like?
08:20:21 <Igloo> Installation problems aren't really an issue if yuo're going to be doing it or helping the person who does it and you know how to overcome them
08:20:30 <earthy> and it assumes that gforge should be used to host all development, whereas it could be used for releasing only
08:20:31 <shapr> is it the bitrot item?
08:20:46 <earthy> no, the John Peterson item
08:21:11 <shapr> earthy: oh, and a sourceforge summary at the top would solve that, right?
08:21:21 <Igloo> Is making a new project possible without your intervention?
08:21:32 <earthy> and I *still* can't access gforge.scannedinavian.org itself, from here
08:21:37 <shapr> at the moment the site admin has to approve new projects
08:21:51 <earthy> (i.e. cs.uu.nl )
08:21:55 <shapr> but I don't have to be the only site admin
08:22:00 <earthy> (but methinks I have to kick the sysadmins for that)
08:22:04 <shapr> it would be easier/better if I weren't
08:22:19 <shapr> earthy: well, I'm not a bind expert, it's possible I've misconfig'd something
08:22:23 <Igloo> After reading "You're welcome to create a dummy project and play around" I'd be disappointed to find I had to wait, I think
08:22:49 <Igloo> BIAM
08:22:58 <earthy> shapr: could be
08:22:59 <shapr> that's another good point
08:23:34 * shapr connects to shell accounts in texas, greece, and finland to see if they can find gforge.scannedinavian.org
08:23:37 <earthy> (but I don't think that's the case, as I can reach it from home and from xs4all, and that's through 2 large dutch ISPs)
08:24:52 <shapr> works from finland and greece, so I think it's your sysadmins
08:24:59 <shapr> I can't get to texas at the moment.
08:25:22 <earthy> shapr: exactly. I've kicked them. :)
08:25:29 <shapr> ok :)
08:26:10 <earthy> oh, I think the blurb on the gforge entrance should be fixed to better reflect that this particular gforge is intended for haskell schtuff
08:26:35 <shapr> yes, excellent point
08:26:40 <SyntaxNinja> has anyone ever seen code with _too many_ comments in it?
08:26:48 <earthy> yes
08:26:51 <Maddas> SyntaxNinja: yes
08:27:50 <earthy> x = 1; /* Initialize our loop counter for the x-axis of the picture */
08:28:10 <earthy> while (x < maxX)  /* As long as we are within the picture */
08:28:12 <earthy> {
08:28:31 <SyntaxNinja> heh
08:28:34 <ejt> I've seen:
08:28:45 <earthy>     blur(x); /* Blur the column at x */
08:28:58 <ejt> (* start the server *)
08:29:02 <ejt> server_start();
08:29:03 <earthy>     x = x + 1;  /* Advance the loop counter by one to get to the next column */
08:29:03 <earthy> }
08:29:09 <Maddas> haha ejt 
08:29:23 <earthy> (obviously, this code was fabricated, but I've seen the likes)
08:29:28 <SyntaxNinja> I'm sticking verbose explanations on a very complex list of input params. the problem is the verbosity of them, not so much the over-abundance of redundant ones
08:29:33 <SyntaxNinja> ejt: hehe
08:30:13 <ejt> comments should be aimed at someone competant in the language
08:30:32 <Maddas> earthy: I have simple (image-processing) code where the comments are up to two times as long as the functions, and contain many factual errors too
08:30:43 <earthy> syntaxninja: if the list of input parameters is that complex, maybe you're doing something wrong
08:30:56 <earthy> maddas: yup, that's why I made the example like I did. :)
08:30:59 <SyntaxNinja> earthy: could be, but it's not my code, so that's OK :)
08:31:02 <shapr> there's lots of this sort of discussion on WardsWiki
08:31:03 <earthy> syntaxninja; :)
08:31:18 <earthy> but I was deciding to cancel an order
08:31:22 <shapr> most people seem to think that code should refactored rather than commented, except in extreme cases
08:31:46 <shapr> (and most of those people don't believe extreme cases exist)
08:32:00 <Maddas> shapr: heh
08:34:21 <shapr> earthy: you think a summary of sf.net would get across that gforge isn't a source-wiki ?
08:34:46 <earthy> shapr: I think a link would suffice
08:35:51 * earthy thinks a bit
08:36:19 <earthy> the paragraph after the quote of john peterson might be rewritten to more clearly reflect the use of gforge
08:36:35 <earthy> add a sentence or maybe two to clarify what it is
08:36:55 <earthy> and I don't know who you're writing this for
08:36:57 <SyntaxNinja> shapr: Description: Collaborative development tool - meta-package
08:36:57 <SyntaxNinja>  GForge provides many tools to help collaboration in a
08:36:57 <SyntaxNinja>  development project, such as bug-tracking, task management,
08:36:57 <SyntaxNinja>  mailing-lists, CVS repository, forums, support request helper, web
08:36:57 <SyntaxNinja>  page / FTP hosting, release management, etc.  All these services are
08:36:57 <SyntaxNinja>  integrated into one web site and managed via a nice web interface.
08:37:08 <SyntaxNinja> (from apt-cache show gforge)
08:37:39 <earthy> (the `Installation is simple, though not trouble free' part seems to not jive with the rest of the text)
08:39:12 <SamB> so, what do you use in Haskell when you would use Twisted in Python?
08:40:09 <SyntaxNinja> what is twisted?
08:41:37 <SamB> SyntaxNinja: it is an asynchronous networking framework
08:45:23 <SamB> I think the point of Twisted is to avoid threads
08:45:53 <SamB> because they can be dangerous
08:46:28 <SamB> and Python's aren't exactly nimble
08:51:47 * earthy hits shpar
08:51:49 <earthy> shapr even
08:52:07 <earthy> dude! you seem to have aggresive negative caching on the domain
08:52:11 <earthy> (way too short TTL's)
08:52:20 <earthy> and, you might wanna increase the serial number
08:52:35 <earthy> in the SOA record for scannedinavian.org
08:54:49 <shapr> aggressive negative caching??
08:54:53 <shapr> ohhh
08:55:02 <shapr> I bet it's the standard gforge config
08:55:03 <shapr> grr
08:55:29 <shapr> SamB: nah, twisted is about async, not even non-threading
08:56:37 <shapr> don't MVar's give you all the same benefits of twisted? well, not callbacks... hmm.
08:56:43 <SamB> hmm
08:57:12 <shapr> y0 dan
08:57:20 <yazirian> word
08:57:24 <shapr> wazzup?
08:57:36 <yazirian> playin with SWT today
08:57:54 <yazirian> not exactly on #topic but since you ask ;)
08:58:10 <shapr> earthy: ok, I'll clean out the installation description, that's probably only true for debian anyway
08:58:22 <shapr> and I'll stick in the gforge package description
09:01:49 <shapr> SWT looks speedy, but it's still java...
09:02:56 <yazirian> java is dictated, sorta
09:02:59 <yazirian> its workstuff
09:03:11 <yazirian> besides
09:03:19 <yazirian> object-oriented is the only worthwhile paradigm
09:03:23 <yazirian> ;)
09:03:39 * shapr quickly makes yazirian an instance of the PHB typeclass
09:03:50 <yazirian> hahaha
09:04:02 <SamB> uh huh... tell that to the people who program microwaves
09:04:47 <cptchaos> apropos  object-oriented, does anyone here have experience with ocaml?
09:05:02 <SamB> ocaml didn't look very interesting
09:05:05 <yazirian> I think I wrote hello world with it once
09:05:32 <yazirian> ocaml reminds me of... well, its like functional's answer to C++
09:05:37 <shapr> ocaml is fast
09:05:43 <shapr> much faster than Haskell
09:05:46 <shapr> but not as expressive
09:05:48 <yazirian> "We can make a language that does everything, but does it difficult, too!"
09:05:53 <cptchaos> i was looking for a good language to write small demos
09:05:58 <SamB> I don't care how fast a program I can't write runs.
09:06:02 * shapr grins
09:06:04 <yazirian> hahaha
09:06:07 <shapr> SamB: that's my thoughts exactly
09:06:16 <SamB> at least, not in choosing a language to write in myself ;-)
09:06:20 <shapr> I'm much more likely to write a program that's easier to write...
09:06:24 <shapr> if that made any sense.
09:06:29 <yazirian> I got it.
09:06:42 <shapr> anyways, some people prefer ocaml
09:06:46 <shapr> and that's cool with me
09:06:50 <shapr> whatever fits your head
09:07:11 <Maddas> I like O'Caml, I just wish it had typeclasses, list comprehensions... and everything it doesn't and Haskell does :-)
09:07:15 <shapr> ok, I've made some updates, any others content or editorial suggestions? http://www.scannedinavian.org/AvianWiki/HaskellProjects
09:07:46 <cptchaos> hm, I like the expressiveness of haskell a lot
09:07:55 <shapr> earthy: you think the pasted in gforge decription helps?
09:09:17 <shapr> earthy: target audience is the haskell mailing lists I guess. I'd like to hear *any* compelling arguments for or against a projects.haskell.org or gforge.haskell.org, or whatever.
09:11:48 <reltuk> prefered editor for haskell is emacs?
09:12:24 * yazirian heads for the bunker!
09:12:42 <cptchaos> reltuk: i use vim :-)
09:12:50 <shapr> reltuk: both vim and emacs have support, I use emacs and can give help with it.
09:13:00 <shapr> I'd say it's about half and half vim/emacs here.
09:13:11 <Maddas> yazirian: haha
09:13:25 <shapr> yazirian: any content or editorial comments about that HaskellProjects page?
09:13:28 <reltuk> oh, that's cool...I use them both, so I'll see which mode I like best
09:13:51 <shapr> yah, it's whatever *you* prefer.
09:14:17 <yazirian> The first thing I thought of when I saw it was how much I would've liked to have someplace to go to find xml tools, a few months ago when I was looking at those.
09:14:37 <shapr> that's a plus point, I like to hear that.
09:15:26 <shapr> whether people actually host their source or just their releases on such a site, it would be a good place for people to find tools.
09:16:32 <shapr> anyone else?
09:16:41 * shapr looks at cptchaos 
09:17:03 <SyntaxNinja> shapr: I think you should mention that the owners of a project will still have control over who gets to modify their project.
09:17:11 <shapr> ok
09:17:20 <SyntaxNinja> (one problem now, I assume, is that many projects are hosted on university computers wher ethe owners can't actually decide who has access to those machines!)
09:17:25 <SyntaxNinja> (so this is an improvement upon that)
09:17:31 <shapr> that's a good point.
09:17:42 <shapr> what about political questions like license?
09:18:03 <shapr> for example Yampa is far from DFSG or OSDL compatible.
09:18:17 <SyntaxNinja> I dno't see how that fits with this email.
09:18:31 <shapr> ok
09:18:41 <SyntaxNinja> when we announce it to the community proper, we might decide what kinds of projects belong.
09:19:12 * cptchaos have been learning a bit about ocamel
09:19:46 <cptchaos> s/have/has/
09:21:19 * cptchaos looking at the HaskellProjects page
09:21:35 <shapr> maybe a gforge howto with links to a demo project on the new site would be a good further step if this email goes over well.
09:21:51 <SyntaxNinja> yeah
09:23:49 <cptchaos> before writing an real demo, I will have to finish my current exams ...
09:23:51 <shapr> cptchaos: any thoughts or comments?
09:29:03 <cptchaos> hm, thoughts: why do I need to sleep ...
09:29:20 <cptchaos> i can not acces http://gforge.ScannedInAvian.org/ 
09:29:27 <rey[lx]> hiho
09:30:40 <shapr> cptchaos: there are some DNS problems with the gforge config
09:31:47 <shapr> yow, refresh is four minutes
09:31:48 <shapr> sheez
09:32:30 <cptchaos> shapr: ok
09:33:45 <cptchaos> at the moment I am writing some kind of genral unix High avaibillity toolkit in haskell
09:34:07 <shapr> oh that sounds nifty
09:34:11 <shapr> what sort of features?
09:35:42 <cptchaos> the original idea was to extend those heardbeat programms 
09:36:15 <cptchaos> i had to set up an replecated MySql Server with IP take-over
09:37:11 <cptchaos> and used the Linux-Ha heartbeat program, but that seems to be flawfull, and is bad documetated
09:38:13 <cptchaos> my idea now ist to write an toolkit that specifies an dependency graph, of nodes its interfaces and its services
09:38:49 <shapr> I wonder if the FGL has something like that.
09:38:58 <cptchaos> each dependency shuld be checkt with an small (extern) program
09:39:48 <cptchaos> i took a look at FGL, but i think it is too generic, much more than I need
09:41:39 <cptchaos> if a dependency-check fails, the graph itself should define alternative configurations, and call an eventhandler, that initialisizes the alternative configuration
09:43:14 <cptchaos> but at the moment, I do not have a lot time to write code,
09:43:24 <Lunar^> 8
09:43:29 <Lunar^> oops
09:43:31 <shapr> Lunar^: 16
09:45:38 <Lunar^> shapr: troll :p
09:45:48 <shapr> troll == 32?
09:45:52 <Lunar^> lol
09:45:53 * shapr grins
09:45:56 <cptchaos> so you should be able to build ub any ha system, by writing some simpel checkprogrms, and configurations scrips for your HA system
09:46:14 <shapr> cptchaos: that would be a useful tool
09:47:16 <cptchaos> shapr: I guess, the first release will be this summer ...
09:47:35 <shapr> I think beowulf cluster admins would like that
09:48:55 <cptchaos> nerver did something with beowulf, but I aiming to write an interface to nagios
09:51:41 <cptchaos> I have to go shopping, before the shops close, till later
09:51:48 <shapr> cya!
09:53:48 <shapr> earthy: hey, I've changed some stuff in the dns records, hopefully they're more sane now.
09:57:22 * Cale is back (gone 08:15:34)
10:10:12 <shapr> y0 zwork 
10:10:26 <shapr> want the #haskell intro?
10:10:38 <zwork> hey
10:10:56 <zwork> a _very_ short one would be cool, yeah
10:11:21 <shapr> hey bcsaller 
10:11:24 <bcsaller> hey
10:11:36 <shapr> ok, the short Haskell intro...
10:12:00 <shapr> if you like map, lambda, reduce, and filter in Python
10:12:10 <shapr> a lot of haskell code works like that
10:12:17 <zwork> yeah i like them
10:12:34 <shapr> you *also* get pattern matching, partial application, and some other neat tricks
10:12:41 <shapr> pattern matching looks like:
10:12:47 <zwork> slick
10:12:50 <shapr> mylength [] = 0
10:13:01 <shapr> mylength (x:xs) = mylength xs + 1
10:13:16 <shapr> partial application looks like:
10:13:20 <zwork> ehhhh
10:13:21 <shapr> add x y = x + y
10:13:28 <shapr> addOne = add 1
10:13:31 <zwork> does that remind me of prolog?
10:13:35 <shapr> then you can do addOne 2 to get 3
10:13:50 <bcsaller> currying?
10:13:53 <shapr> Haskell is a multiparadigm language (whatever that means :-)
10:13:55 <shapr> bcsaller: you got it
10:14:02 <SamB> would this be a good time to re-ask if anyone is coming up with an asynch framework for Haskell?
10:14:14 <shapr> here's the jump right in and play with it demo file I wrote - http://www.scannedinavian.org/AvianWiki/HaskellDemo
10:14:25 <shapr> could probably be better, if you have any questions, ask me
10:14:44 <shapr> instead of objects, haskell has typeclasses for polymorphism
10:14:57 <SamB> shapr: multiparadigm in Haskell's case means it supports both imperative and functional styles, and can keep imperative code contained
10:15:11 <shapr> they work a lot like java's interfaces, but you can define them long after both the interface and type have been defined
10:15:24 <shapr> and it supports some logic/constraint stuff as well
10:15:38 <zwork> sounds cool
10:15:49 <shapr> partial application give some of the same functionality as instances
10:16:10 <shapr> typeclasses give a lot of the same functionality as inheritance
10:16:31 <shapr> if you want to see a semi-real haskell program, lambdabot is written in Haskell
10:16:37 <shapr> @fortune
10:16:38 <lambdabot> There's no use in having a dog and doing your own barking.
10:16:43 <shapr> @listmodules
10:16:45 <lambdabot> I have the following modules installed: ["base","dict","dummy","dynamic","eval","hello","karma","more","quote","seen","state","system","topic","type"]
10:17:14 <shapr> bcsaller: one reason I like Haskell is that it abstracts state differently than OOP
10:17:17 <zwork> data People = Person Name Age                   is such a class def?
10:17:26 <shapr> zwork: nah, that's a type def
10:17:36 <shapr> class defs are further down in the file
10:17:40 <bcsaller> shapr: the datastuctures are persistent?
10:17:52 <shapr> which datastructures?
10:18:08 <zwork> i see:
10:18:10 <zwork> class CharExts a where
10:18:10 <zwork>     isVowel     :: a -> Bool
10:18:11 <zwork>     isConsonant :: a -> Bool
10:18:12 <bcsaller> any you define, I remember something of the sort from looking at ocmal
10:18:30 <shapr> OOP cuts state into instances, if you've done J2EE, you know you have to line up the state in a bunch of different instances to get everything working right, any one being wrong will screw the whole thing
10:18:41 <shapr> with Haskell, all the state is in one place
10:19:03 <SamB> zwork: that is actually a rather silly example ;-)
10:19:07 <shapr> it's *much* easier to test referentially transparent code
10:19:20 <SamB> CharExts, I mean.
10:19:30 <zwork> iSamB: I just passted it from the tutorial :)
10:19:41 <shapr> you could do the same in Zope for example, but very little of the code has the state passed in, look at all the code that gets implied  info from REQUEST
10:21:02 <shapr> monads are powerful, they're an abstraction mechanism. objects and OOP are a completely different abstraction mechanism, but they're both abstractions made from a certain interface
10:21:29 <shapr> um, any questions?
10:21:47 <zwork> yeah:
10:21:51 * phubuh uses lists and folds and maps in compile-time in C++
10:22:00 <shapr> bcsaller: if you import a datastructure, it's there, is that what you mean?
10:22:24 <zwork> can you give a sample of the difference in state handling OOP <-> Haskell ?
10:22:42 <Igloo> phubuh: Are you the person who was trying to get ghc working on Debian/powerpc?
10:22:44 <SamB> phubuh: you know C++ templates don't have garbage collection?
10:23:07 <shapr> OOP state handling looks like myInstance.setMyProperty(myValue)
10:23:20 <phubuh> Igloo: nope, I don't think I've ever even used a PowerPC
10:23:25 <phubuh> SamB: yes :)
10:23:28 <Igloo> Ah, OK, sorry
10:23:44 <Igloo> Who am I thinking of, shapr?
10:23:56 <zwork> shapr: ok, i understand
10:23:59 <shapr> pesco? er, no..
10:24:05 <shapr> Igloo: I'll think of it in a bit.
10:24:13 <shapr> Haskell state handling is completely explicit
10:24:14 <SamB> haskell makes it hard to mutate something without making it obvious that you are doing so.
10:24:27 * bcsaller nods
10:24:44 <shapr> if you wanted to write a calculator that had a single memory button
10:25:15 * shapr tries to think of a good structure
10:25:40 <SamB> a single memory button? do you mean cell?
10:25:48 <shapr> yah
10:26:00 <SamB> and of course an accumulator?
10:26:06 <shapr> ok, sure :-)
10:26:36 <shapr> I'm trying to think of how to convert a monadic calculator into a simpler explicit one
10:27:21 * shapr looks for good demo in his home dir
10:28:33 <shapr> zwork: usually, there's one single really big chunk of statefulness that you carry in a 'real' haskell program
10:28:58 <shapr> I can't find an easily digestible example right now, I'll find one later.
10:29:17 <zwork> ok ;)
10:29:37 <shapr> under the hood the copy-and-replace is often turned into in-place mutation, but the fact that it is explicit in the program gives lots more opportunities for optimization
10:29:41 <SamB> hmm, I guess you would also need some kind of input buffer...
10:30:19 <shapr> well, any other questions about Haskell?
10:30:27 <shapr> while I look for a good stateful example? :-)
10:30:47 <shapr> ah, here's something...
10:31:51 <shapr> http://www.scannedinavian.org/AvianWiki/HaskellEvaluator
10:32:15 <shapr> I dunno if that's easy to digest or not...
10:33:43 <shapr> C can have data as values, Python can have functions as values, Haskell can have calls to functions with data as values
10:33:49 * shapr isn't sure if that's well-explained
10:34:01 <shapr> it's the next step the first-classedness :-)
10:34:40 <shapr> the HaskellEvaluator there is explicitly passing in the state to each computation.
10:34:58 <shapr> the 0 at the very end of the source is the starting state
10:35:30 <shapr> ok well, comments, questions?
10:35:52 * zwork glances at the wiki
10:36:02 <shapr> is that Evaluator digestible?
10:36:47 <bcsaller> doesn't fit my brain so well
10:36:59 <SamB> do you at least like the syntax highlighting?
10:37:05 <bcsaller> heh
10:37:05 <Maddas> haha
10:37:09 * shapr grins
10:37:46 * zwork drinks a glass of whisky for digesting the Evaluator sample
10:37:47 <Cale> Is there currently a library for haskell with IO actions to save/load images in png?
10:38:18 <shapr> Cale: check out Pan, Pancito, or PanTHeon, they have have png support.
10:38:25 <shapr> er "may have"
10:38:34 <SamB> Pan is under an evil MS license, no?
10:38:45 <shapr> is it?
10:38:57 <Cale> pancito seems to have ppm support
10:39:19 <shapr> bcsaller: does that Evaluator make any sense at all? any specific parts of it that are difficult?
10:40:01 <bcsaller> shapr: I see what its doing, I just don't think I would want to write it that way. It could just be inexp. with the mental model though
10:40:04 <shapr> the state gets passed as the x on the left hand side of the two eval patterns.
10:41:07 <shapr> bcsaller: in my opinion, that sort of stuff is as powerful as OOP, possibly more powerful. but it does take some brain twisting to go from years of C/Python/Java to doing it this way.
10:41:25 <shapr> It sure took me some time fighting my habitual thinking.
10:41:46 <zwork> yeah its like learning japan, you have to retwist your brain
10:42:04 <zwork> anyhow wife is caling me to dinner
10:42:10 <bcsaller> I agree that the matching is nice and useful, but I don't know there is enough gain to rewire my brain 
10:42:17 <shapr> zwork: ok, hope this was interesting
10:42:28 <yazirian> bcsaller: I know that nick!
10:42:32 <SamB> bcsaller: theres a lot more to it then the matching!
10:42:56 * Maddas plans learning Japanese
10:43:02 <bcsaller> yazirian: hey
10:43:02 <zwork> shapr, i think i will peek around in the wikis later
10:43:09 <yazirian> fancy meetin' you here!
10:43:11 <shapr> bcsaller: yah, there's a bigger learning curve from procedural/OOP to pure FP, but if you get the urge, you may want to try it. 
10:43:16 <zwork> thanks for the intro...
10:43:21 <shapr> zwork: sure!
10:43:33 <bcsaller> yeah, thanks shapr
10:43:36 <shapr> :-)
10:43:57 <shapr> ok, back to working on Plone for me..
10:44:04 * shapr doesn't yet have a job writing Haskell.
10:44:19 <yazirian> Not many people do.
10:44:33 <shapr> some people on this channel do
10:44:59 * Igloo looks up from his Functional Metapost window  :-)
10:45:02 <yazirian> and we must guard daily against envy turning to hatred ;)
10:45:26 <Igloo> It needs an embedded functional TeX, though
10:45:43 <shapr> just keep workin on getting that Haskell job... one day it'll happen.
10:46:20 <shapr> I'm hoping projects.haskell.org will bring more of the right people together.
10:46:59 <SamB> Igloo: that is a very hard thing to imagine
10:47:35 <yazirian> Heh, well at this point I think I'd be happy just doing something non-banal, regardless of the toolset. 
10:47:38 <Igloo> I have a feeling F Tex itself exists
10:47:48 <yazirian> Although I do have my limits (i.e. visual basic)
10:48:49 <shapr> I did VB for awhile, still have the scars.
10:48:56 <yazirian> I am so sorry.
10:48:58 <yazirian> I didn't know.
10:49:02 <Cale> heh
10:49:04 <SamB> I tried vb, but I never figured out what it was for.
10:49:13 <Maddas> haha
10:49:36 * shapr grins
10:50:23 <phubuh> bcsaller: with some extra incantations, eval could be written 
10:50:24 <phubuh> eval (Con a) = return a
10:50:24 <phubuh> eval (Div t u) = do a <- eval t
10:50:24 <phubuh>                     b <- eval u
10:50:24 <phubuh>                     incrementCounter
10:50:24 <phubuh>                     return (a `div` b)
10:51:14 <yazirian> whitespace-significant languages are so CHEEKY! :)
10:51:31 <shapr> type parametization was surprising to me
10:51:52 <shapr> too many years of declaring Java types I guess
10:51:56 <Maddas> yazirian: do { a <- eval t; b <- eval u; incrementCounter; return (a `div` b) ; }
10:51:59 <Maddas> (That shoul be the same, shouldn't it?)
10:52:06 <Maddas> should, even.
10:52:13 <phubuh> yup
10:52:20 <phubuh> I'm not sure if the last ; is allowed though
10:52:32 <Maddas> oh, yes, that wasn't meant to be there
10:52:38 <yazirian> heh, 'declaring Java types'
10:52:53 <yazirian> thats like saying "too many years of pointing at Shermans and saying "Look! A Pinto!""
10:53:04 * shapr snickers
10:53:16 <phubuh> or eval t >>= \a -> eval u >>= \b -> incrementCounter >> return (a `div` b) :)
10:53:55 <bcsaller> phubuh: I think I liked your first version best
10:54:38 <shapr> that's the 'real' monadic version
10:55:25 <phubuh> is liftM2 (,) (eval t) (eval u) >> incrementCounter >> return (a `div` b) correct?
10:55:31 <phubuh> err
10:55:31 <phubuh> haha
10:55:38 <phubuh> that's the dumbest anything ever
10:55:43 <yazirian> hahahaha
10:55:43 * phubuh slaps himself repeatedly
10:56:31 <Maddas> are Int and Integer the same?
10:56:37 <Cale> nope
10:56:41 <yazirian> ah HA!
10:56:49 <yazirian> so there IS a way haskell sucks like Java ;)
10:56:52 <phubuh> Integer is a bignum, Int is 2^31 or something like that
10:56:54 <phubuh> yazirian: eh?
10:56:59 <Maddas> Ah, ok
10:57:12 <yazirian> phubuh: Maddas> are Int and Integer the same?
10:57:13 <yazirian> hehehehe
10:57:16 <phubuh> oh, haha
10:57:17 <shapr> yazirian: nah, we have fromIntegral, and it just does The Right Thing(tm)
10:57:30 <phubuh> and we can use both Int and Integers as Nums
10:57:46 <phubuh> @type \x -> x + 1
10:57:46 <lambdabot> \x -> x + 1 :: Num a => a -> a
10:57:47 <Maddas> And I don't need more than 2^31 anyway! Ever! 
10:57:49 <Maddas> :-)
10:57:53 <yazirian> well, talk the C# team into implementing it, so it'll be in Java 1.6
10:57:53 <shapr> right, java doesn't have a Number interface
10:57:59 <phubuh> @type (\x -> x + 1) (1 :: Int)
10:57:59 <lambdabot> (\x -> x + 1) 1 :: Int
10:58:00 * yazirian rimshots.
10:58:03 <phubuh> @type (\x -> x + 1) (2 :: Int)
10:58:04 <lambdabot> (\x -> x + 1) 2 :: Int
10:58:10 <phubuh> err.
10:58:11 <Cale> heh, I wrote a program where Integer was actually needed :)
10:58:12 <phubuh> @type (\x -> x + 1) (2 :: Integer)
10:58:12 <lambdabot> (\x -> x + 1) 2 :: Integer
10:58:33 <Maddas> Cale: I can imagine it being very handy for maths
10:58:41 <Maddas> I assume it is quite a bit slower, though
10:58:54 <shapr> Python has always had typeclasses actually
10:58:54 <SamB> who holds the trademark The Right Thing?
10:58:56 <yazirian> scientists might need it
10:59:02 <Cale> It was a simple thing to compute the number of permutations with a given pattern of ups and downs (< and >=)
10:59:10 <shapr> Python is now formalizing it into an "Interface"
10:59:12 <phubuh> shapr: because it doesn't do any type checking at all, so you just send the messages and hope for the best? :-)
10:59:14 <Cale> it's actually not much slower at all
10:59:24 <shapr> phubuh: actually, yes, we called it "the honor system"
10:59:26 <Maddas> Cale: ok, cool
10:59:28 <phubuh> hee
10:59:34 <shapr> so if your code said it required "a file-like object"
10:59:56 <shapr> then your object only needed to implement enough of the file methods so that nothing would hurk at runtime
11:00:03 <yazirian> multiply something by a mole sometime, for example
11:00:19 <shapr> I think there's code for that in haskell-libs
11:00:28 <SamB> yazirian: don't they use floating point for that?
11:00:41 <yazirian> float is imprecise
11:00:52 <yazirian> some people (like me) don't care
11:00:53 <SamB> so is measurement
11:00:53 <Taaus> shapr: That sounds like the Smalltalk way. Duck typing :)
11:00:59 <yazirian> hehehe
11:01:33 <yazirian> hahaha, speaking of which, I just got this from python:
11:01:33 <shapr> ah, here it is: http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/physics/
11:01:33 <yazirian> >>> 6.02 * (10**23)
11:01:33 <yazirian> 6.0199999999999993e+23
11:01:39 <yazirian> case in point :)
11:01:49 * phubuh just learned about moles and stÃ¶kiometri (what's the english word?) in school
11:02:00 <Maddas> yazirian: That's pretty normal
11:02:03 <shapr> Taaus: Python has string similarities to both Smalltalk and Lisp
11:02:08 <phubuh> > 6.02 * (10 ** 23)
11:02:08 <phubuh> 6.019999999999999e23
11:02:12 <shapr> if it's possible to do those both at the same time
11:02:16 <Cale> http://vx.hn.org/autoshare/pattern.hs
11:02:23 <monotonom> Integer is useful for number theory problems, such as factoring a 100-digit number.
11:02:42 <Cale> 100 imaginary points to anyone who can figure out how that algorithm works.
11:02:46 <SamB> phubuh: how do you do that without importing Prelude?
11:03:03 <Taaus> shapr: Indeed... I tried implementing Squeak Morphic in Python (with wxPython)... Unfortunately, Python isn't _that_ close to Smalltalk :/
11:03:07 <phubuh> I had a bunch of other modules loaded that I didn't want to paste :)
11:03:26 <shapr> what was the problem?
11:03:49 <Maddas> yazirian: even 4.2-4.1 should do it
11:04:21 <yazirian> I figure just about everything does, it's just personal amusement at floating-point approximation :)
11:04:32 * SamB spots an empty browser window, wonders what he was going to search/look for.
11:04:33 <Maddas> heh.
11:04:36 <Taaus> shapr: To be honest, I don't remember anymore... It may have been something with single/multiple inheritance.
11:04:57 <yazirian> I'm sure that at any given moment, some scientist, somewhere, is annoyed about it too.
11:05:01 * SamB remembers he was going to look for functional metapost
11:05:27 <Maddas> yazirian: probably
11:05:33 <SamB> Taaus: squeak doesn't *have* multiple inheritance
11:05:40 <shapr> python does
11:05:54 <Taaus> SamB: And Python does. Hence the problem... Python doesn't have a "super" keyword.
11:06:09 <Taaus> (Not an elegant one, anyway.)
11:06:14 <SamB> Taaus: oh, that. it has a super function.
11:06:15 <shapr> you've got self.__class__.bases though
11:06:24 <SamB> but yeah, its not pretty.
11:07:56 <SamB> hey, google doesn't seem to know how to read \LaTeX out of PDF files ;-)
11:08:12 <Taaus> I wonder if I still have the code somewhere... I made a cute little program for editing polygons and moving them around :)
11:08:53 <shapr> I want an OpenGL Morphic3D and in Haskell!
11:09:10 <Taaus> Hehe.
11:09:21 * shapr fanatacizes messily
11:09:23 <Taaus> Like Croquet?
11:09:26 <shapr> yah, exactly
11:09:39 <shapr> I never did get that working on Squeak
11:09:54 <Taaus> Ah... I tried the demo... It was... An experience.
11:10:01 <Taaus> (Not a particularly fast one, though)
11:12:02 <shapr> I think that's the right idea, 3D IRC
11:12:25 <Taaus> Hmm...
11:13:06 <shapr> I've used Self once or twice with someone else across the 'net, that was awesome.
11:13:50 <Taaus> Ooh. Yes. I used Squeak with... I think it was called Kansas... Two people in the same Squeak session. 
11:14:13 <shapr> Nebraska
11:14:17 <Taaus> Ah.
11:14:20 <shapr> I couldn't get that working either.
11:14:34 <shapr> Kansas is just Self :-)
11:14:41 <yazirian> couldn't you use screen for that?
11:14:42 <Taaus> Oh. Hehe :)
11:14:47 <yazirian> and do that with pretty much anything?
11:14:59 <shapr> nah, it's not the same
11:15:28 <shapr> I really want to do VirtualPairProgramming, but there aren't any really good ways to do it.
11:16:15 <bcsaller> http://www.codingmonkeys.de/subethaedit/ ?
11:16:18 * SamB wishes emacs was as good at indenting haskell as it is at indenting Lisp
11:16:24 <Maddas> Is networking nice in Haskell? (Good libraries, etc.)
11:16:51 <Tirador> hello
11:16:52 <shapr> bcsaller: that's spiffy
11:16:55 <shapr> hi Tirador 
11:17:05 <shapr> what can we do for ya?
11:17:55 <shapr> bcsaller: Self aka Kansas is spiffer, since everything you see on the screen is an object, whose behaviours you can directly modify.
11:18:20 <Tirador> I've to implement a function that gets an element of a double 2d array of lists: e.g. getElement 0 0 [[1,2],[3,4]] gives out 1
11:18:24 <shapr> I'd be willing to try subethaedit on Linux though :-)
11:18:53 <Maddas> bcsaller: have you ever used it?
11:19:01 <Tirador> with my code I'll get a pattern match failure and I don't see the error :(
11:19:08 <Tirador> can I paste the code here?
11:19:19 <shapr> Tirador: if it's five lines or less
11:19:34 <bcsaller> Maddas: nope, not a mac user, but I hear ok things about it
11:19:55 <phubuh> @wiki HaskellIrcPastePage
11:19:56 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:19:59 <Tirador> getElem :: Int -> Int -> [[a]] -> a
11:20:00 <Tirador> getELem 0 y (z:zs) = getElement' y z
11:20:00 <Tirador>                     where getElement' 0 (f:fs) = f
11:20:00 <Tirador>                           getElement' y (f:fs) = getElement' (y-1) fs
11:20:00 <Tirador> getElem x y (z:zs) = getElem (x-1) y zs
11:20:31 <Cale> getELem ?
11:20:55 <Tirador> for example: getElem 0 0 [[1,2],[3,4]] gives out 1
11:21:04 <Tirador> if it would work
11:21:06 <Cale> look at the capitalization there
11:21:18 <Cale> getE*L*em 0 y (z:zs)
11:22:14 <Taaus> Hmm... Couldn't you just use (!!) twice? :)
11:22:25 <Tirador> lol
11:22:32 <Tirador> Cale, thanks :)
11:22:57 <Cale> Taaus: hehe
11:24:36 <Cale> yeah, getElement n m xs = xs !! n !! m -- is a bit more concise :)
11:25:47 <Tirador> !! <-- what does that mean?
11:26:02 <Cale> it's an operator which takes the nth element of a list
11:26:22 <bcsaller> and you were thinking "line noise"
11:26:42 <Cale> [1,2,3,4,5,6] !! 3 == 4
11:26:50 <Tirador> I had to implement it without implemented functions
11:27:07 <shapr> bcsaller: ya know, there really is the +++ operator in Haskell...
11:27:29 <shapr> maybe this is why Haskell never got popular till after people stopped using modems
11:27:29 <bcsaller> shapr: whats +++ do? do I want to know? ;)
11:27:29 <phubuh> and >>>, and >>=, and <|>, and <?>
11:27:33 <phubuh> :-)
11:27:48 <bcsaller> shapr: heh
11:28:43 <shapr> +++ is called mplus, and in parsers it means try the left then the right if the left fails to match
11:29:49 * shapr checks that
11:30:31 <shapr> oh, +++ is for arrows
11:30:55 <bcsaller> whats for slings?
11:31:16 <shapr> small rocks?
11:31:24 <bcsaller> ...
11:31:32 <shapr> that's not an operator!
11:31:41 <bcsaller> oh... good
11:31:43 * shapr grins
11:32:05 <shapr> you can make your own operators in haskell
11:32:29 <shapr> we once came up with the cat operator =^.^= 
11:32:45 * Cale defines a *.*..@... operator.
11:32:51 <bcsaller> anything to make sure you can come back to the code in 6 months
11:33:08 <Cale> Operators inspired by nethack
11:33:20 <shapr> .@.d.
11:33:24 <bcsaller> heh
11:33:37 <shapr> a boy and his dog
11:33:58 <Taaus> One man and his droid.
11:34:22 <Cale> *.*..@... is called the left stones operator
11:34:22 <shapr> .@.--D.
11:34:44 <Maddas> Reminds me that I really, really need to buy an external numpad for the laptop.
11:35:14 <Maddas> Nethack with Dvorak without numpad is unplayable
11:35:24 <ecraven> :) dvorak is nice though..
11:35:40 <Maddas> ecraven: Don't tell me, tell the nethack developers :-)
11:35:51 <shapr> nethack-el makes it easier for dvorak
11:36:12 <ecraven> Maddas: i only have to learn how to use the numbers row, then i can touch type most stuff..
11:36:17 <Maddas> What does it do, shapr?
11:36:29 <shapr> wraps nethack into an emacs interface
11:36:37 <Maddas> ecraven: What do you mean? I don't understand
11:36:47 <shapr> it's quite nifty, all the fun of nethack and all the customizability of emacs
11:36:47 <Maddas> shapr: heh, can you move with c-n and c-p et al?
11:36:58 <ecraven> i can touch type all three character rows, but i have to check the keys for numbers and all the special characters
11:36:58 <shapr> I don't remember the standard keys :-)
11:37:07 <shapr> much like I've completely forgotten qwerty
11:37:20 <Maddas> ecraven: ah, ok
11:37:22 <ecraven> i have to look at the keyboard to be able to type..
11:37:36 <shapr> I wish my numbers and F-keys had braille on them or something
11:38:07 <Maddas> heh, I don't really have problems with numbers, but the F-keys are weird on the laptop (no empty space after every four keys)
11:38:26 <ecraven> ;) i want some more modifier keys.. is it possible to hack my keyboard and build some more keys into it?
11:38:29 <shapr> kinesis f-keys are like small pieces of chewing gum, only really bad feature on this keyboard
11:38:34 <Maddas> ecraven: I doubt it
11:38:38 <shapr> yes it is!
11:38:43 <shapr> I've added Hyper and Super
11:38:45 <Maddas> It is?
11:38:48 <Maddas> Haha
11:38:50 <ecraven> shapr: how?
11:38:58 <Maddas> shapr: did you change the hardware though?
11:39:01 <shapr> I remapped home and pgup to Super, and end and pgdn to hyper
11:39:04 <shapr> no, same hardware
11:39:20 <Maddas> Ah, I thought ecraven wants to add physical buttons
11:39:23 <shapr> just xkeycaps
11:39:27 <ecraven> that's what i want..
11:39:28 <shapr> oh, is that what you want?
11:39:31 <ecraven> physical buttons..
11:39:41 <shapr> let's petition lego to expand into keyboards
11:39:51 <ecraven> i'll just have to find one of those space cadet boards and hack them to work on ps/2 or usb..
11:39:53 <Maddas> ecraven: I guess that can't be done easily
11:39:54 <Maddas> shapr: haha
11:40:09 <shapr> lego keyboards would rock
11:40:31 <ecraven> Maddas: i am not so sure.. it could be possible to just extend the matrix by some more contacts.. one of these days i'll just try it.. got an old keyboard here anyway
11:40:49 <Maddas> heh, let me know if you succeed
11:45:03 <ecraven> i will ;) 
11:45:24 <ecraven> i can mass-produce them if i succeed :) who wouldn't want alt-meta-super-hyper-ctl :)
11:45:42 <shapr> with shift and altgr
11:45:47 <Maddas> In fact, I'm wondering if I need any more modifiers right now
11:47:41 <ecraven> shapr: front is nice too
11:48:01 <shapr> what's front?
11:48:40 <ecraven> on some kbds there's symbols on the front of the keys.. front+l is lambda, front+shift+l is uppercase lambda etc..
11:48:48 <shapr> ohh
11:48:59 <ecraven> or a key labeled GREEK would be nice too :)
11:51:05 <Maddas> I think I'm actually lacking things to map, not keys :-)
11:51:55 <shapr> you use emacs?
11:52:03 <Maddas> Nope
11:52:08 <yazirian> 8=====D -- the 'this code is screwed' operator
11:52:10 <shapr> oh
11:52:15 * shapr grins
11:52:37 <Maddas> yazirian: I wonder what it'd do :)
11:52:48 <ecraven> Maddas: :) i use the kbd more and more, window manager etc.. 
11:53:00 <yazirian> Maddas: I don't know, the more I play with it, the harder it gets
11:53:12 <rey[lx]> re
11:53:24 <ecraven> btw. does anyone know how i can assign e.g. ctl-alt-l to input lambda under xfree?
11:53:46 <shapr> xkeycaps?
11:55:20 * bcsaller waves
11:56:04 <yazirian> I used to work with him.
11:56:15 <yazirian> shapr: I gather now you do? 
11:56:54 <shapr> no, I just use software he's written.
11:57:14 <shapr> specifically, archetypes
11:57:20 <phubuh> work with whom?
11:57:25 <yazirian> Plone confuses me. I blame Zope. :)
11:57:28 <shapr> where did you guys work?
11:57:33 <yazirian> appliedtheory
11:57:38 <yazirian> now defunct and good riddance
11:57:54 <shapr> haven't heard of it.
11:58:27 <yazirian> I discovered just the other day, for example, that you can't be logged into a Plone site as one user, and the ZMI with another.
11:58:37 <shapr> you can
11:58:39 <yazirian> So if you have to tweak your installation, and then test the change, God help you.
11:58:55 <yazirian> Well, if you can, then it's not by default/.
11:58:59 <shapr> I login to localhost:9673 and 127.0.0.1:9673
11:59:08 <shapr> since auth is cookie-based...
11:59:08 <yazirian> heh, trickssy
11:59:41 <yazirian> I just opened another browser
11:59:53 <shapr> yah, same thing
11:59:58 <yazirian> it still threw me for a loop for a minute though
12:00:11 <yazirian> "Wait, wasn't I just logged in as... and now I'm... I AM LOSING MY MIND!!"
12:01:02 <shapr> now if we had one written in Haskell...
12:01:37 <shapr> actually, HaskellDB on GHC might make that road just flat enough
12:01:38 <yazirian> all I'll say on the topic is, it damn well better play nicer with apache than zope does :)
12:05:38 <yazirian> anyway, my point was, it violates the principle of least surprise that I'd have to trick zope at the protocol level to let me log into two totally separate things at the same time
12:05:54 <yazirian> but I'm cranky that way :)
12:06:11 <shapr> http and authentication don't usually mix well
12:06:20 <rey[lx]> uhm, i am new to haskell and i have a little problem with ghci.. i just wanted to toy arround a little bit with ghci, triyng some things, but i cant even declare a variable like a :: Int
12:06:32 <rey[lx]> <interactive>:1: Variable not in scope: `a'
12:06:38 <ecraven> is there anything like xkeycaps for the xkb-extension?
12:06:50 <shapr> rey[lx]: declarations must be given in a file
12:07:10 <shapr> rey[lx]: if you use emacs, haskell-mode has C-c C-l to dump the current haskell buffer into a ghci emacs buffer
12:07:14 <rey[lx]> ah ok, so i can only execute functions and things already declared in a file!?
12:07:16 <shapr> I'm not sure if vi has the same sort of thing
12:07:39 <shapr> you can define new functions with let
12:07:42 <Maddas> shapr: Sounds like a useful thing at least
12:08:20 <shapr> let addOne = (\x -> x + 1)
12:08:26 <Maddas> shapr: Do you have any overview of useful things your .emacs/emacs-mode in English?
12:08:56 <shapr> useful things in my personal emacs settings?
12:09:20 <shapr> rey[lx]: oh, you can do this with let
12:09:38 <shapr> let addTwo = (\x -> x + 2) :: Int -> Int
12:09:51 <shapr> let a = 5 :: Int
12:09:53 <Maddas> shapr: elisp thigs
12:09:56 <Maddas> things, even.
12:10:08 <Maddas> Making everyday life with Haskell easier :-)
12:10:44 <shapr> well, one-button unit testing I wrote up on the HaskellMode wiki page
12:10:45 <ecraven> shapr: i only have to M-x haskell-mode and then C-c C-l ?
12:11:06 <shapr> ecraven: you may need to also do M-x turn-on-haskell-ghci
12:11:15 <yazirian> eclipse needs a haskell perspective ;)
12:11:23 <shapr> I've rumors of such
12:11:30 <ecraven> shapr: still doesn't work :)
12:11:38 <ecraven> what is C-c C-l bound to?
12:11:52 <shapr> haskell-ghci-load-file
12:13:11 <shapr> Maddas: standard emacs does many things, standard haskell-mode extends those into haskell-specific goodies
12:13:46 <shapr> I've bound H-c to "comment-region" so I can select a bunch of code and comment it out with one keycombo
12:14:03 <shapr> and C-u H-c will uncomment the region
12:14:11 <phubuh> M-; does comment-region by default, if you have a region
12:14:16 <yazirian> you actually have a Hyper key?
12:14:17 <phubuh> and uncomments if it is already commented :-)
12:14:45 <shapr> sure, I used xkeycaps to turn home,end,pgdn,pgup into S,H,H,S
12:15:00 <shapr> with kinesis, that's elegant
12:15:06 <yazirian> heh, not a bad idea
12:15:22 <yazirian> I like pgdn and pgup too much, but in emacs, home and end serve little purpose to start with
12:15:24 <ecraven> shapr: aren't those keys far away from where you can easily reach them?
12:15:43 <ayrnieu> x <- getChar :: IO Char -- or (x :: Char) <- getChar :: IO Char -- with GHC extensions.
12:16:07 <shapr> ecraven: http://www.kinesis-ergo.com/images/adv_wht.jpg
12:16:10 <Ria|kaffee> hallo hat jmd zeit und kann deutsch?
12:16:25 <ecraven> ja
12:16:26 <Maddas> shapr: I guess I'll just look at what haskell-mode provides additionally
12:16:28 <Ria|kaffee> juhu
12:16:55 <shapr> rey[lx]: does the let trick work for you?
12:18:10 <rey[lx]> fine sofar
12:18:14 <rey[lx]> so far
12:18:20 <shapr> spiffy, any other questions?
12:18:31 <rey[lx]> thx
12:18:44 <shapr> ecraven: sexy keyboard puts modkeys closer to fingers: http://www.kinesis-ergo.com/contoured_usb.htm
12:18:56 <shapr> man I want one of those black models
12:19:44 <yazirian> your radical keyboard confuses and frightens me
12:20:10 <shapr> it follows my "I am not a koala" theory.
12:20:23 <shapr> they have two thumbs, I only have one.
12:20:41 <Maddas> you have one thumb?
12:20:45 <shapr> chording should be done with the thumb holding down the modifier, while the fingers press the other keys.
12:20:48 <shapr> Maddas: per hand
12:20:49 <phubuh> sorry about that dude, what happened?
12:20:52 <phubuh> oh! :-P
12:20:54 <Maddas> ok :)
12:21:04 * shapr laughs
12:21:21 <yazirian> heh
12:21:38 <Maddas> shapr: I agree
12:21:46 <Maddas> If only the laptops would come with those keyboards
12:22:01 <Maddas> Oh well, Tab mapped to control is already much better.
12:22:31 <shapr> my plan for the ultimate laptop is a nano-pc that fits inside my kinesis.
12:22:56 * Maddas hugs his powerbook
12:23:08 <yazirian> mmm, at least it's a tasty laptop
12:23:39 <Maddas> shapr: Changing hands would be so much easier than changing all the laptops :-)
12:25:03 <ecraven> wee, i'd like those foot-switches
12:26:29 <yazirian> pffft
12:26:55 <yazirian> if no special drivers are required, why do I need to know it's compatible with "macos 8.6 or higher, windows 98 or newer"?
12:29:43 <kosmikus> shapr: I'm no longer away
12:29:54 <ecraven> hm.. linux 2.6.0 is newer than win98
12:30:14 <shapr> yow
12:30:24 <shapr> kosmikus: do you have time to look at the HaskellProjects url I pasted?
12:30:30 <shapr> hi Bocephus_, looking for Haskellers?
12:30:37 <shapr> ecraven: excellent point
12:31:15 <kosmikus> have you changed it since 17:00?
12:31:42 <shapr> three hours ago
12:32:25 <shapr> changes, but minor changes
12:35:12 <kosmikus> shapr: looks fine to me
12:35:33 <kosmikus> shapr: but you probably want me to start supporting it immediately by moving my projects there, right?
12:38:57 <kosmikus> shapr: interestingly, the gforge webpage does not display correctly with my Firebird 0.7 ...
12:39:17 <shapr> can you try reloading the page?
12:40:24 <shapr> I'm not sure it's ready for projects yet, don't put up anything you don't have backed up elsewhere.
12:40:40 <kosmikus> no, it's displayed too wide
12:41:21 <kosmikus> The "Lates news" fill 95% of the screen width, and I get a horizontal scrollbar at the bottom
12:41:25 <shapr> sometimes I get that when I first view the page, and reloading fixes it for me. (galeon 1.3.11a)
12:41:47 <kosmikus> If I resize the window (i.e. make it larger) then I see the whole page, but after reloading I have the same effect again
12:41:48 <shapr> I'll try it with firebird in debian, later tonite
12:41:53 <shapr> weird
12:41:54 <kosmikus> it's okay with Konqueror
12:42:11 <shapr> I'll see if there are updates to the debs, and if not, ask on #gforge
12:42:58 <kosmikus> hmm, if it's not up for projects yet, what sort of comments are you interested in?
12:43:26 <shapr> well, as it says at the bottom
12:43:27 <kosmikus> I think this is a sort of proposal that does not have to be agreed upon, but must just attract enough users to become standard
12:43:48 <shapr> "We'd like you all to take a quick look at the site, and to give us your thoughts. You're welcome to create a dummy project and play around, or look at the library infrastructure project, or any other projects that are there. Do you think this is an appropriate and helpful tool for the Haskell community?"
12:44:10 <kosmikus> okay
12:44:27 <shapr> that's a good point
12:44:27 <kosmikus> well, the project categories seem a bit too overwhelming for my taste
12:44:42 <shapr> want me to rip out some of it?
12:44:47 <kosmikus> it's not likely that it will host more than, say, 100 projects in the near future
12:44:52 <shapr> right
12:45:56 <kosmikus> personally, I've never used sourceforge, but I think one of the services they have is some kind of automated building on different platforms ... is that right?
12:46:11 <shapr> yes, but they have the hardware for that, I don't
12:46:25 <shapr> although...
12:46:31 <SyntaxNinja> can we change the project categories? because if so, we definitely should.
12:47:03 <shapr> yes, it's a table in postgres
12:47:22 <SyntaxNinja> we have a much more limited hierarchy. we don't want everyone listing everything under "programming language" :)
12:47:46 <kosmikus> right
12:48:10 <kosmikus> btw, the display problem seems to occur *only* on the "Home" page, all others show correctly
12:48:41 <SyntaxNinja> FYI it renders fine in my Glaeon
12:48:43 <SyntaxNinja> galeon
12:49:07 <kosmikus> how safe are the passwords?
12:49:17 <shapr> not very safe until I fix ssl
12:50:46 <shapr> user info is kept in LDAP, if that's what you mean
12:51:09 <kosmikus> I'll use a low security password for now which I will probably forget :)
12:51:22 <shapr> good idea
12:51:23 <kosmikus> so maybe it's higher security after all :)
12:52:21 <shapr> gforge is designed to have separate postgres, cvs, and primary hosts, and you can separate it far more, since it's a fork of sf.net
12:52:51 <shapr> running it all on one host should be interesting, but I don't think 100 projects will take much.
12:54:25 <shapr> kosmikus: if the build on other hardware bit is a useful feature, maybe we could persuade people to host other hardware on their own nets for build hosts
12:54:26 <kosmikus> Why really is it necessary to have a dependency on CVS or anyway such a limited number of version control tools, i.e. how difficult is it to support tla, darcs, subversion, ...
12:55:14 <shapr> darcs support should be easy enough
12:55:23 <shapr> the debian packager is adding subversion support
12:56:07 <kosmikus> subversion would be great for me, I'd definitiely not move Generic Haskell back to CVS ...
12:56:08 <shapr> sf.net's scm stuff is supposedly designed to be pluggable, but I don't know if anyone has tried it.
12:56:31 <kosmikus> lhs2TeX is still on CVS, I will try to put that on Gforge now
12:57:08 <shapr> ok
12:57:57 <kosmikus> are these confirmation mails not sent immediately?
12:58:02 <shapr> they should be
12:58:11 <kosmikus> did not get one yet ...
12:58:35 <shapr> log says it was sent
13:00:10 <kosmikus> strange, the address works for me ... I just sent myself a mail to that address successfully
14:28:48 <shapr> ick, perl and php
14:31:42 <Riastradh> Ick.
14:31:47 <Maddas> Ick!
14:32:10 <cptchaos> ick?
14:32:30 <SyntaxNinja> cptchaos: yes. ick.
14:32:38 <Riastradh> What are you doing with Perl and PHP?
14:32:58 <shapr> hacking on gforge
14:33:31 <shapr> ssh auth isn't working, means no shells and no cvs
14:33:52 <cptchaos> @listcommands
14:33:53 <lambdabot> I react to the following commands: ["all-dicts","arr","define","definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","learn","leave","listchans","listcommands","listmodules","lojban","moo","more","msg","part","pre
14:34:03 <Riastradh> @devils lexicographer
14:34:04 <lambdabot> *** "LEXICOGRAPHER" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
14:34:04 <lambdabot> LEXICOGRAPHER, n.  A pestilent fellow who, under the pretense of
14:34:04 <lambdabot> recording some particular stage in the development of a language, does
14:34:04 <lambdabot> what he can to arrest its growth, stiffen its flexibility and
14:34:05 <lambdabot> mechanize its methods.  For your lexicographer, having written his
14:34:07 <lambdabot> dictionary, comes to be considered "as one having authority," whereas
14:34:09 <lambdabot> his function is only to make a record, not to give a law.  The natural
14:34:11 <lambdabot> servility of the human understanding having invested him with judicial
14:34:13 <lambdabot> [31 @more lines]
14:34:20 <shapr> yikes
14:34:23 <Riastradh> @johnson lexicographer
14:34:24 <lambdabot> Sorry, I don't know the command "johnson", try "lambdabot: @listcommands"
14:34:26 <Riastradh> Bah.
14:34:38 <Riastradh> Fine, I'll fill in for lambdabot:  lexicographer, n.  A harmless drudge.
14:34:47 <cptchaos> @dict ick
14:34:47 <lambdabot> Supported dictionary-lookup commands:
14:34:47 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @prelude @vera @web1913 @wn @world02
14:34:47 <lambdabot> Use "@dict-help [cmd...]" for more.
14:35:37 <cptchaos> @all-dicts ick
14:35:38 <lambdabot> No match for "ick".
14:35:45 <cptchaos> ???
14:35:52 <Riastradh> Humph!  There's no OED in that list?
14:36:30 <SyntaxNinja> @devils alcohol
14:36:31 <lambdabot> No match for "alcohol".
14:36:39 <Riastradh> @devils bride
14:36:40 <lambdabot> *** "BRIDE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
14:36:40 <lambdabot> BRIDE, n.  A woman with a fine prospect of happiness behind her.
14:37:10 <Igloo> OED isn't freely available
14:37:34 <Riastradh> Igloo, yes it is.
14:37:46 <Igloo> Oh, I suppose old versions might be
14:37:48 <Riastradh> It was quite recently made available on the web.
14:37:53 <Igloo> Really?
14:38:33 <Igloo> http://dictionary.oed.com/ says "New lower prices for OED Online individual subscriptions" which doesn't seem to agree
14:39:04 <Riastradh> Hmmmm.  I could swear I was pointed to a working link to a definition in the OED.
14:39:37 <Heffalump> people who can browse it can create links to particular definitions for anyone to use
14:39:41 <Heffalump> not sure how long they last
14:39:51 <Heffalump> quite a nice feature, given it's non-free
14:40:20 <SyntaxNinja> @devils husband
14:40:21 <lambdabot> *** "HUSBAND" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
14:40:21 <lambdabot> HUSBAND, n.  One who, having dined, is charged with the care of the
14:40:21 <lambdabot> plate.
14:41:20 <Igloo> I'd guess they decided people would copy+paste anyway so they may as well have it as a branded page with their hostname in the URL
14:43:07 <Heffalump> good point
14:43:29 <Heffalump> though also I suspect that OUP is not your average evil corporate body
14:45:12 <shapr> anyone have a clue about pam_ldap.conf or libnss-ldap.conf ?
14:46:27 <Igloo> I set such things up aaages ago, but couldn't tell you much at all OTTOMH
14:48:49 <shapr> maybe I'll use Dominic's LDAP client for figuring this stuff out
15:01:05 <reltuk> so are most people here down on imperative languages?
15:01:47 <shapr> I get paid to write imperative code.
15:01:57 <shapr> plus Haskell is the world's best imperative language anyway.
15:02:31 <Heffalump> apart from the issues with execution efficiency...
15:03:38 <shapr> reltuk: what about you? are you down on imperative languages?
15:04:16 <reltuk> I'm only really familiar with imperative languages...
15:04:38 <reltuk> I've done about a semesters worth of coursework in ocaml, but other than that, not a lot of functional programming expierience
15:04:48 <reltuk> I'm working on expanding my horizons
15:05:00 <shapr> sounds great
15:05:09 <shapr> Heffalump: just minor details :-)
15:06:41 <shapr> reltuk: have any questions?
15:07:10 <reltuk> shapr, not yet, but I just started looking at haskell  :)
15:07:32 <shapr> ok, feel free to ask any questions if you find some
15:08:40 <reltuk> thanks
15:37:04 <reltuk> I'm walking through Yet Another Haskell Tutorial, and do I need to tell the interpreter that I want to use a package in interactive mode?
15:37:22 <shapr> which interpreter are you using? Hugs? ghci?
15:37:28 <reltuk> hugs...
15:37:40 <shapr> well first, I'd suggest ghci
15:37:47 <shapr> and second, probably
15:37:54 <shapr> try :m Data.List
15:38:08 <shapr> your interpreter prompt will probably change to show you that that module is in scope
15:38:16 <reltuk> "Cannot find module..."
15:38:31 <reltuk> the ghc download finished, so I'll just install taht  :-p
15:38:35 <shapr> ok
15:40:35 <Taaus> Why do you prefer ghci, shapr? 
15:40:55 <Heffalump> faster and more ghc compatible
15:41:00 <Heffalump> on the other hand, hugs loads quicker
15:41:09 <shapr> and hugs runs on resource-poor boxes
15:41:27 <shapr> ghc can be a hog, but it's very featureful
15:41:34 <Heffalump> and on more architectures
15:41:37 <Heffalump> (I'd assume)
15:42:15 <shapr> I think Hugs runs on more architectures, isn't Hugs written in C?
15:42:20 <Taaus> How do they measure up, user-friendlyness-wise?
15:42:26 <shapr> or maybe that's what you were saying...
15:42:46 <Heffalump> shapr: yes
15:42:53 <Heffalump> taaus: ghci provides nicer error messages
15:43:02 <Heffalump> apart from that, about the same
15:43:15 <Taaus> Ah, okay.
15:43:25 <monotonom> You can define new functions/values online in ghci: let x=1
15:43:27 * Taaus emerges ghci
15:43:41 <Heffalump> oh yes, that too
15:43:45 <Heffalump> that's a big win
15:43:46 <reltuk> ahhh...ghci does it
15:46:02 <shapr> on other hand, only nhc98 runs on PalmOS
15:46:24 <shapr> I wonder if they ever released that
15:47:34 <reltuk> hehe, palmos
15:48:23 <reltuk> yet another haskell tutorial goes a bit out of order on the excersizes :-p
15:49:09 <reltuk> "write a function using a fold that will return the maximum value in a list"...but I don't know how to write functions yet  :-p
15:49:39 <shapr> myadd x y = x + y
15:49:54 <shapr> mymax x y = if x > y then x else y
15:50:03 <shapr> g'day Pseudonym 
15:50:07 <Pseudonym> G'day.
15:50:14 <reltuk> yeah...that's pretty straightforward...
15:52:07 <shapr> hey Pseudonym, have you seen the pretty colors? http://www.scannedinavian.org/AvianWiki/HaskellEvaluator
15:53:15 <shapr> enscript's haskell.st isn't very featureful, but it's not black and white either.
15:54:20 <Taaus> shapr: That looks suspiciously like one of the examples from Philip Wadlers monad papers ;)
15:54:43 <Pseudonym> Oooh!  Shiny!
15:54:50 <shapr> could be, it's from Steve Atkin, but I just wanted to show off the nifty syntax highlighting plugin
15:55:27 <shapr> Pseudonym: oh, if you have any content or editorial comments about http://www.scannedinavian.org/AvianWiki/HaskellProjects
15:55:30 <shapr> I'd like to hear them.
15:55:59 <shapr> reltuk: for the jump right in kind of person, http://www.scannedinavian.org/AvianWiki/HaskellDemo
15:57:50 <Heffalump> I don't see how gforge helps with making more of haskell.org updatable by the community.
15:58:30 <shapr> for stuff like haskell.org/HOpenGL  /HaXML /hircules etc
15:58:51 <Heffalump> YM maintain it in CVS?
15:58:54 <Heffalump> (or darcs)
15:59:23 <Heffalump> or DYM make them each gforge project pages?
15:59:27 <Heffalump> IMO those are ugly and offputting.
15:59:30 <shapr> gforge is a sourceforge fork, so you get all the website/mailing list/cvs/shell/etc code
16:00:00 <shapr> color-wise? functionality-wise? or what?
16:00:13 <Heffalump> they all look the same, and are too cluttered
16:00:33 <shapr> what all looks the same?
16:00:48 * SyntaxNinja goes home
16:00:48 <SyntaxNinja> peace
16:00:52 <shapr> cya SyntaxNinja 
16:00:59 <Heffalump> sourceforge project pages
16:01:12 <kosmikus> Heffalump: you still can have own home pages
16:01:19 <shapr> yup
16:01:41 <Heffalump> which don't have any boilerplate?
16:01:45 <kosmikus> I think that the idea is that if the code is hosted in a central place, and automatically world-readable, then it is guaranteed that no code will be lost as long as the repo is up
16:01:58 <shapr> http://haskell-stuff.gforge.scannedinavian.org/
16:02:04 <shapr> totally blank, you put anything you want there
16:02:18 <Heffalump> fair enough. Perhaps you could explain that then.
16:02:22 <shapr> sure
16:02:24 <Heffalump> (I would, but I'm lazy :-)
16:02:28 <shapr> heh, ok
16:02:45 <shapr> I think a feature walkthrough would be nice.
16:09:20 <shapr> Heffalump: ok, is that better?
16:10:26 <Heffalump> you should probably put an actual page at that webpages URL
16:10:30 <Heffalump> and move it to the top of the list
16:11:28 <shapr> you can move it in the list, I'll make a webpage after I've fixed SSL and the mailing lists.
16:12:53 <Heffalump> done
16:13:20 <shapr> yay, first docs online - http://gforge.scannedinavian.org/docman/?group_id=8
16:14:04 <shapr> kosmikus: thanks for bug finding on gforge
19:29:03 <jasonw> He always wears clothes that remind me of a High School track coach.
19:29:09 <jasonw> whoops,ww,sorry.
20:16:37 <reltuk>  /j #opengl
20:23:46 <Pseudonym> Like I said, she  was dead when I got there.
20:23:49 <Pseudonym> Whoops!  Sorry!
20:24:49 <monotonom> Did you call the police then? :)
20:25:18 <Pseudonym> Never mind.  It was completely out of context.
20:28:17 <Darius> That's two in a month or so's time.
20:39:46 * SamB wonders why more people don't publish their papers in dvi format as well as ps/pdf
20:40:33 * Pseudonym has spent half an hour waiting for metafont to compile up fonts while viewing DVIs he got from other people
20:40:40 <Pseudonym> Mind you, this was ten years ago.
20:40:43 <monotonom> If I use uncommon fonts (and often I do), the dvi will be useless to you.
20:41:02 <Pseudonym> This is precisely what PDF is for.
20:41:08 <Pseudonym> And almost what PS is for.
20:42:10 <monotonom> But I have a better idea. I publish my tex/latex file. You can then even fix typos yourself when you see one.
20:42:27 <reltuk> but the dvi's always look better
20:42:48 <monotonom> ps looks as good as dvi
20:42:59 <reltuk> really?
20:43:03 <SamB> Pseudonym: well, I'm on 56k and a 450 MHz PII. I think that my shift things a bit.
20:43:03 <SamB> s/my/may/
20:43:09 * reltuk doesn't use ps, thinks ghostview looks ugly as a program  :-p
20:43:19 <monotonom> pdf looks as good as ps if the correct generator program is used (e.g., pdflatex, dvipdfm, BUT NEVER ps2pdf)
20:43:31 <Pseudonym> Right.
20:43:43 <Pseudonym> PS files generated from DVIs use bitmap fonts, right?
20:43:54 <reltuk> I've never seen a pdf that looked as good as a dvi coming straight out of tex...
20:44:08 <monotonom> I make good pdf's all the time.
20:44:24 <Pseudonym> My pdfs are better than your pdfs!
20:44:41 <SamB> TeX's pdfs sometimes look sorta wrong to me, as if the letters are dancing up and down. Just sometimes.
20:45:00 <monotonom> Indeed please take a look at http://www.cs.utoronto.ca/~trebla/fp/
20:45:03 <Pseudonym> Not pdftex's, though.
20:46:02 <monotonom> (On my page, "pdf for printer" will be bad because I have to psnup and then ps2pdf. But "pdf for screen" is good.)
20:46:19 <reltuk> ahh, yes...pdf's at the pink provided look good
20:47:03 <reltuk> s/pink/link
20:47:51 <SamB> why do you provide different versions for print and screen? are the viewers unable to handle high resolution fonts well?
20:48:24 <reltuk> his print versions are 4up
20:48:29 <SamB> oh
20:48:33 <monotonom> By "pdf for printer" I mean 4 slides on one single sheet of paper, to save printing paper
20:49:03 <monotonom> Also though they look horrible on the screen, once printed out they look just fine. :)
20:49:22 <reltuk> yeah, the fonts look bad on the screen...I imagine it doesn't matter when printing though
20:50:05 <SamB> seeing as print is several times the resolution...
20:50:24 <monotonom> I suppose this problem has to do with bitmap vs. raster fonts, and it is solvable with some work reconfiguring ps2pdf
20:50:53 <SamB> you know, this would be more impressive if it was upside up
20:52:09 <shapr> ozone: that's what she said, uhuh
20:52:16 <shapr> whoops, sorry
20:53:03 <reltuk> for some reason, my 2ghz p4 notebook has problems multitasking
20:53:10 <reltuk> my 1ghz p3 desktop seems more responsize...
20:53:20 <reltuk> I used to think it was the disk subsystem, but I'm not so sure...
20:53:20 * SamB wishes for a way to mix the size of dvi with the work-almost-anywhere-nes of ps/pdf
20:53:50 <Pseudonym> Yes, that would be good.
20:53:53 <SamB> windows?
20:53:55 <Pseudonym> Though it helps if you use standard fonts.
20:54:08 <reltuk> yeah, but I get the same thing in 2.6 linux
20:54:09 <SamB> i1586? what?
20:54:21 <shapr> when moving a file from one place to another in Haskell, is there anything better than just reading the contents, saving them in the new place, and deleting the old file?
20:54:41 <shapr> reltuk: maybe your desktop has more cache?
20:55:10 <reltuk> shapr, maybe...but it's a p4 desktop processor in the notebook...
20:55:13 <SamB> what in the world is i1586
20:55:30 <reltuk> and it's major problems multitasking...like windows will not redraw for about 5 seconds at a time
20:55:37 <shapr> something's wrong with that
20:55:46 <SamB> hot?
20:55:53 <shapr> you sure you're power management isn't on ten second timeout?
20:55:58 <shapr> uh "your"
20:56:01 <shapr> man I'm sleepy
20:56:15 <reltuk> heh, power management is fine
20:56:23 <reltuk> running at about 63C right now...so yeah, it's hot
20:56:36 <shapr> anyways, that's the best way to copy a file in Haskell?
20:56:50 <Pseudonym> shapr: Don't you have access to POSIX link/unlink?
20:56:55 <shapr> err, I dunno
20:57:00 <Pseudonym> Or is that Unix only?
20:57:01 <shapr> ah, this guy doesn't
20:57:05 <shapr> windows
20:57:08 <Pseudonym> Ah.
20:57:14 <shapr> I'm looking at the wiki
20:57:16 <monotonom> shapr: On certain implementations, "renameFile" in "Directory" will work.
20:57:33 <shapr> hm, interesting
20:57:51 <SamB> is there no posix support?
20:57:51 <reltuk> SamB, think it would speedstep at 60C?
20:57:58 <Pseudonym> I seem to remember writing a portable thing to do this once.
20:58:13 <Pseudonym> Basically, there is no easy way to do it under Windows apart from what you say.
20:58:15 <monotonom> If you can assume posix support, by all means take advantage of it, of course.
20:58:32 <reltuk> heh, I don't know haskell yet, but I wouldn't have pegged it as a language to write file-processing programs in
20:58:42 <Pseudonym> And it's not reliable to test if the file you're copying is a named pipe or something, especially over a SMB connection.
20:59:25 <shapr> monotonom: are you at columbia.edu ?
20:59:31 <monotonom> No.
20:59:33 <shapr> oh
20:59:34 <shapr> ok
20:59:44 <SamB> reltuk: I don't know. I just doubt a P4 would like being hot.
20:59:46 <Pseudonym> Toronto?
20:59:57 <monotonom> Yes Toronto
21:00:05 <Pseudonym> shapr: I can read URLS.
21:00:08 * Pseudonym points up a bit
21:00:09 <reltuk> i1586 must be a pentium 4 tag or something...
21:00:14 <monotonom> heh heh heh
21:00:15 <shapr> where's the url?
21:00:23 <Pseudonym> <monotonom> Indeed please take a look at http://www.cs.utoronto.ca/~trebla/fp/
21:00:23 <shapr> oh
21:00:27 <shapr> ya know
21:00:36 <shapr> I'm obviously asleep
21:00:39 <shapr> I dunno why I'm at the computer.
21:00:42 <shapr> geez it's 6am
21:00:44 <reltuk> I should upgrade RAM from 256MB anyway...
21:00:46 <shapr> I'm outta here
21:00:48 <Pseudonym> Yes, you're dreaming that you're on IRC.
21:00:54 <Pseudonym> Night.  Or morning.
21:00:55 <shapr> if it's in the logs, it's not a dream....
21:00:58 * shapr disappears
21:01:04 <reltuk> but I'm not sure I'll be using the laptop much more...if I can land a job, I'm going for one of those 17" powerbooks :)
21:01:17 <reltuk> adios shapr, it was nice to meet you
21:01:24 * Pseudonym thinks . o O ( This acid's really good.  It feels like I'm on IRC. )
21:02:18 <reltuk> this graphics book they have us using in my computer graphics course is relatively subpar in my opinion...
21:02:25 <Pseudonym> Which one?
21:02:27 <reltuk> but maybe that's because it doesn't touch on stuff that I'm really interested in
21:02:45 <reltuk> it's called "Interactive Computer Graphics: A Top-Down Approach Using OpenGL"
21:03:00 <Pseudonym> What are you interested in?
21:03:33 * SamB upgraded to 256 MB not so long ago
21:03:47 <reltuk> I think I'm just being negative...it's not really so bad...
21:04:04 <Pseudonym> I'm asking because I may be able to suggest a better book.
21:04:32 <reltuk> I was looking at "Real-Time Rendering"...it's a pretty broad survey of relatively advanced topics
21:04:42 <Pseudonym> That's quite a good book, yes.
21:04:49 <Pseudonym> Have you seen the web site?
21:05:02 <reltuk> nope   /me googles  :)
21:05:25 <Pseudonym> http://www.realtimerendering.com/
21:05:28 <Pseudonym> Easy to remember.
21:05:43 <Pseudonym> The links are fabulous.
21:06:12 <reltuk> wow, nice page
21:06:57 <reltuk> what was your recommendation going to be?
21:07:07 <reltuk> you do graphics programming I'm guessing?  in haskell even?
21:08:56 <Pseudonym> I used to.
21:09:15 <Pseudonym> Visual effects.  Offline rendering stuff.
21:09:19 <Pseudonym> Not in Haskell, though.
21:10:07 <reltuk> heh, haskell isn't something I would expect to see graphics programming in either
21:10:30 <Pseudonym> It depends.
21:10:44 <Pseudonym> Non-realtime graphics uses a surprising array of technologies.
21:11:09 <Pseudonym> There are a lot of steps which aren't performance-sensitive.
21:11:27 <reltuk> yeah, I didn't mean from a speed perspective
21:11:36 <Pseudonym> As in, getting a good answer is better than getting a fast answer.
21:12:17 <reltuk> haskell have advantages in "getting a good answer" arena?
21:12:19 <Darius> Isn't it more efficient to partially evaluate/compile raytracing scenes to scene specific renderers
21:13:13 <Pseudonym> Not really.
21:13:33 <reltuk> non real-time stuff can look so much pretty, I'm almost more interested in it...
21:13:45 <Pseudonym> The two biggest hits in raytracing are: 1) incoherent access to the geometry database, and b) the cost of intersection tests.
21:13:54 <reltuk> but then you've got thing like pixel and vertex shaders in the realtime side that kick up it's cool factor
21:13:58 <Pseudonym> 1 and b
21:14:04 * Pseudonym can't count
21:14:04 <reltuk> lol
21:14:07 <Pseudonym> Anyway.
21:14:08 <reltuk> getting late for you too?
21:14:25 <Pseudonym> Yeah, 4pm on a Friday afternoon is always too late.
21:14:29 <SamB> reltuk: I dare not. There lie patents.
21:14:51 <det> Pseudonym: obviously you are either a) tired or 2) crazy
21:15:08 <Pseudonym> b) is generally solved by tesselating geometry, but that just increases the size of the database, making problem 1) even worse.
21:15:37 <Pseudonym> 1) was only recently solved by using multiresolution geometry caches.
21:15:57 <Pseudonym> Even so, it's not very L1 cache friendly.
21:16:36 <SamB> Pseudonym: you can count. you just can't keep track of how to format the counter.
21:19:31 <reltuk> Pseudonym, my simplistic solution to that would be bigger l1 caches!
21:19:58 <Pseudonym> :-)
21:20:08 <Pseudonym> One of the benefits of scanline rendering is that it is very cache friendly.
21:20:11 * reltuk sees aztec3d for the first time...
21:20:38 <Pseudonym> Which is why most of the offline rendering that you see is scanline, at least for the first "hit".
21:20:54 <Pseudonym> And, of course, all of the real-time rendering. :-)
21:20:58 <reltuk> doom3 uses ultrashadows...
21:21:32 <Pseudonym> What are ultrashadows?
21:21:58 <Pseudonym> Don't know very much about real-time OpenGL stuff, sorry.
21:22:08 <Pseudonym> Especially not the latest stuff that they stuff into graphics cards.
21:22:19 <reltuk> " NVIDIA has also introduced ultrashadows (used by Doom 3), which helps trim the amount of fill needed for shadow volume computation."
21:22:24 <reltuk> it's on the real-time rendering site...
21:22:34 <Pseudonym> Ah, OK.
21:22:40 <reltuk> I don't know what they are either...I know what shadow volume calculations for the shadows are...
21:23:10 <Pseudonym> Yes, I know that too.
21:23:21 <Pseudonym> Generally, offline renderers use shadow maps.
21:23:43 <Pseudonym> Occasionally you get raytraced shad.
21:23:48 <Pseudonym> shadows
21:23:53 <reltuk> yeah, but there have been advancements recently...I don't know enough to say what they are...
21:24:05 <Pseudonym> And very occasionally, you get shadow photon-based approaches.
21:25:39 <reltuk> http://www.flipcode.com/cgi-bin/msg.cgi?showThread=11-12-2002&forum=iotd&id=-1
21:26:26 <reltuk> that's from 2002...I wonder if he continued working on it...
21:26:38 <reltuk> 20fps on a celly 1200 software rendered...that's pretty neat
21:27:20 * reltuk downloads
22:15:52 <Pseudonym> " But by what criteria do you decide when threads are the right solution?"
22:16:01 <Pseudonym> That's from LtU.
22:16:12 * Pseudonym is still trying to work out if it's a loaded question or not
22:19:21 <reltuk> if the problem is easily serializable?
22:19:47 <Pseudonym> What I said was that threads are the right answer for many concurrency problems.
22:19:51 <Pseudonym> Invariably, the hard ones.
22:20:20 <Pseudonym> If your problem is easily serialisable, or effectively serialised, then obviously you want to use serial code or coroutines.
22:20:39 <Pseudonym> If your problem is easily separated, then multiprocessing is often a better design.
22:20:55 <Pseudonym> If your problem is hard (i.e. not one of the easy cases), then you need threads.
22:21:40 <Pseudonym> Multithreaded programming is hard for one of two reasons: 1) it's overkill for your problem, or 2) the problem you're solving is inherently hard.
22:22:15 <Pseudonym> In case 2), the difficulty of the solution matches the difficulty of the problem.
22:23:20 <reltuk> wow
22:27:09 <Pseudonym> Wow?  Did you get that OpenGL thing running?
23:06:49 <reltuk> Pseudonym, I got a software renderer of the quake 3 maps running...pretty impressive stuff...
23:07:01 <Pseudonym> Oh, cool.
23:07:22 <reltuk> yeah, I'm walking through some opengl tutorials and reading some math stuff now
23:30:16 <Pseudonym> Nytol
