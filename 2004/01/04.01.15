00:13:19 <adept> harsha123: 
00:17:53 * shapr yawns
00:17:57 <shapr> good morning #haskell!
00:18:08 * ayrnieu yawns
00:18:11 <ayrnieu> good night #haskell!
00:19:52 * adept just yawns :)
00:21:16 <adept> Does anyone by chance had a look at nice.sourceforge.net?
00:23:54 <shapr> does anyone have a copy of Asperti & Longo's book "Categories, Types, and Structures" ?
00:33:06 <Maddas> Does anybody know the programming language FISh by chance?
00:33:42 <Maddas> adept: interesting
01:06:30 <earthy> moinz
01:44:26 <shapr> @arr
01:44:27 <lambdabot> Avast!
01:46:28 * shapr considers adding the @skämt command
01:47:12 <shapr> Maddas: I've heard of FISh, I think I've even chatted with one of the authors on irc at some point.
02:09:31 <shapr> captain ... chaos!!
02:10:04 <cptchaos> yes?
02:10:08 <shapr> good morning!
02:10:39 <cptchaos> thanks
02:11:44 * shapr bounces cheerfully
02:11:49 <cptchaos> good mornig,as well
02:12:44 <shapr> read any neat code lately?
02:13:43 <cptchaos> hm, no read some papers about recusive do 
02:13:59 <shapr> oh, what's the secret to mdo?
02:14:05 <shapr> I don't really get it.
02:14:25 <shapr> something about using variables that haven't been bound yet?
02:15:03 <shapr> which papers did you read? do you have the urls?
02:15:17 <cptchaos> yes, you can use Variables like in an let experssion
02:16:03 <shapr> do you have a short example handy?
02:16:19 * cptchaos is looking up the urls
02:17:03 <shapr> hi troon
02:17:09 <cptchaos> the shortest exaple I found was:
02:17:09 <cptchaos> justOnes = mdo xs <- Just (1:xs)
02:17:09 <cptchaos>                return xs
02:17:40 <shapr> that's nifty
02:17:42 <cptchaos> give Just [1,1,1,1,1, ...]
02:18:11 <cptchaos> but to me that did not really explain what mdo is
02:18:16 <shapr> in which cases is mdo really more useful or more elegant than do?
02:18:48 <cptchaos> if you want do make fixpoint computations in an monad
02:19:20 <shapr> I've only needed to do that once
02:19:36 <shapr> I wonder if more of my code could be expressed as fixpoint computations
02:20:23 <shapr> have you used mdo in any of your code?
02:21:10 <cptchaos> actually not, after reading a lot, i figured out, that this was not the thing I needed
02:22:08 <cptchaos> the best paper I read was at http://www.cse.ogi.edu/PacSoft/projects/rmb/
02:22:34 <cptchaos> named "Recursive Monadic Bindings"
02:22:54 <shapr> I'll read that, thanks.
02:24:27 <shapr> I know that arrows have the same thing, but they use the "rec" combinator
02:25:05 <cptchaos> I have read about arrows but not used them jet
02:25:15 <shapr> I haven't either
02:25:43 <shapr> I think I finally understand monads as a datatype and a continuation
02:25:48 <shapr> but I'm not sure how to relate that to arrows
02:25:53 <shapr> Riastradh: do you know?
02:26:51 <shapr> I know that John Hughes uses arrows to overcome space leaks, but I wonder what other advantages they have over monads
02:27:58 <cptchaos> hm, that is the reason, why I actually never used arrows
02:28:25 <cptchaos> but I thing you could write more complicated compinators with arrows
02:30:27 <cptchaos> so I will have breakfast ...
02:30:32 <cptchaos> :-)
02:31:07 <shapr> yes, always a good idea
02:53:51 <raver> y0!
03:33:02 <ham[kell]> hiho
07:02:21 <shapr> y0 y0
07:02:29 <door> yo yo!
07:02:44 <door> what is up shapr?
07:03:23 <shapr> I'm reading about mdo
07:03:36 <shapr> cptchaos mentioned it earlier today, I'm trying to figure out what it's good for
07:04:28 <Heffalump> any recursive monadic computation
07:04:34 <Heffalump> did you read Erkok et al's paper?
07:05:34 <shapr> Heffalump: in process
07:05:53 <shapr> thing is, how can I tell a recursive monadic computation when I see it?
07:06:27 <shapr> the only time I've wanted mdo is when lambdabot was trying to init modules after connecting but before logging in to irc
07:06:53 <shapr> Pseudonym said that mdo would fix that problem, but I don't understand why.
07:08:03 <shapr> door: what's up with you?
07:08:21 <door> i
07:08:24 <door> ops
07:08:40 <door> i am experimenting with gpsim, a pic simulator
07:09:36 <door> i'm programming a pic as "project work" in school :)
07:09:42 <shapr> oh neat
07:09:56 <shapr> have you seen the various hardware programs written in Haskell?
07:10:07 <shapr> Lava, BlueSpec, Hawk, etc?
07:10:11 <door> why, no
07:10:26 <door> where can i learn more about those? google? :)
07:10:33 <shapr> that's where I'd look first.
07:10:42 <Smerdyakov> One of my undergrad classmates works on BlueSpec now.
07:10:47 <shapr> but I can find urls if you need help.
07:11:04 <shapr> I'd like to work with Lennart Augustsson
07:11:24 <door> i'm reading about bluespec now
07:12:33 <Heffalump> shapr: any situation where you want to refer to a value earlier than you bind it in a do, is a potential use of mdo
07:15:40 <shapr> I haven't found any situations where I'd want that. Not that I'm aware of, at least.
07:16:17 <Heffalump> surely that paper has some examples, though?
07:16:22 <shapr> it does
07:16:46 <kosmikus> there's a reason that it only recently has been added to the language; you don't need it that often
07:18:21 <Heffalump> shapr: you're keen on arrows which are another infrequently required extension of monads, I'm sure you can find a use for mdo too :-)
07:18:40 * shapr mdoes some arrows
07:18:48 <shapr> actually, rec is the recursive arrow combinator
08:09:58 <SyntaxNinja> http://www.syntaxpolice.org/pics/DiverseRobot.png
08:10:43 <phubuh> haha, beautiful
08:11:25 * SyntaxNinja bows
08:12:43 <shapr> SyntaxNinja: does that robot scientist use Aetion software?
08:12:59 <SyntaxNinja> no. I wish :)
08:13:05 <SyntaxNinja> but we're thinking of hiring a robot
08:13:56 <SyntaxNinja> phubuh: the funny thing about that picture was 1) there was a blank whitespace where the robot goes, and 2) the background above the robot was already that color
08:14:25 <phubuh> haha
08:15:57 <shapr> hi esap 
08:16:02 <esap> Hi!
08:16:05 <shapr> what's up?
08:16:33 <esap> Not much, just came home from work, haven't started doing anything yet.
08:16:40 <shapr> what do you do at work?
08:16:57 <esap> software architecture
08:17:25 <esap> telecom
08:17:30 <shapr> oh
08:17:35 <shapr> erlang?
08:17:41 <esap> no.
08:18:10 <esap> I wish we used functional languages :-)
08:18:28 <shapr> seems to work for Ericsson
08:19:20 <shapr> or maybe not, since they moved away from erlang
08:19:29 <esap> heh :-)
08:19:37 <Igloo> Oh, that's a pity
08:25:55 <shapr> Igloo: actually, there were benefits since Erlang is now completely open source
08:26:45 <Igloo> OK, not all bad then
08:27:32 <shapr> the way I heard it, Ericsson decided they couldn't afford maintaining and extending their own custom language.
08:28:19 <esap> Maintaining a language is not cheap, takes lots of effort.
08:29:50 <ham[kell]> one quick question to the ones who wrote lambdabot does the sender of a string to irc also receive it from the server?
08:30:03 <Igloo> No
08:30:30 <ham[kell]> dang
08:30:50 <ham[kell]> that way my bot cant do recusions
08:31:03 <ham[kell]> recursions
08:32:03 <shapr> yup
08:32:05 <shapr> I am actually thankful to microsoft for paying the Simons
08:32:21 <ham[kell]> simons?
08:32:40 <shapr> the Simons are Simon Peyton-Jones and Simon Marlow
08:32:55 <ham[kell]> and what do they do?
08:33:26 <shapr> pretty much everything
08:33:36 <ham[kell]> heh :)
08:33:53 <shapr> what do you mean your bot can't do recursions?
08:34:17 <ham[kell]> shapr that thesis i told you about
08:34:36 <ham[kell]> i write a bot that evals whats on the commandline that is on an irc channel
08:35:04 <shapr> oh, lambdabot has two examples of that
08:35:11 <ham[kell]> something like (channel,run,data) -> (someotherchannel,somefunction,data)
08:35:25 * shapr blinks
08:35:41 <ham[kell]> ?
08:36:01 <shapr> I don't understand what you're asking.
08:36:13 <ham[kell]> if i send a message with my bot
08:36:26 <ham[kell]> to the same channel he is in he doesnt get his own line
08:36:43 <ham[kell]> that is what that function returns and thus he cant process the data further
08:38:09 <shapr> I think you will get the message back
08:38:35 <shapr> automated services on irc should use NOTICE rather than PRIVMSG according to the IRC RFC
08:38:47 <shapr> but no one's gotten around to fixing lambdabot 
09:09:38 <shapr> y0 stepcut, how's code?
09:26:06 <shapr> @yow
09:26:11 * shapr cackles evilly
09:50:09 <esap> Hmm.. does standard prelude or some library have something like: fzip f x y = fmap (\a -> fmap (f a) y) x ?
09:53:32 <shapr> zipWith ?
09:53:58 <esap> not quite the same, is it?
09:54:10 <esap> fzip :: (Functor f, Functor g) => (a -> b -> c) -> f a -> g b -> f (g c)
09:54:55 <shapr> looks like leftZip or something
09:55:04 <shapr> zipWithFst
09:55:22 <esap> fzip (+) [10,20,30] [1,2,3] == [[11,12,13],[21,22,23],[31,32,33]]
09:56:00 <shapr> zipWithPermutations ?
09:58:04 <esap> it's basically a cross product combined with zipWith, I guess.
09:59:06 * esap thinks I mean cartesian product :-)
09:59:35 <shapr> so you want permutationsWith, right?
10:00:48 <esap> Well I'm not sure this experiment has any goal :-) It just occurred to me that this kind of function might be useful, so I wrote it :-)
10:03:39 <shapr> er, permutations seems to include order
10:03:48 <shapr> hmm
10:04:27 <esap> try 'fzip (,)'
10:04:28 <shapr> cartesian product, yes
10:04:37 <shapr> you've got me interested now...
10:05:04 <shapr> I'm trying to see if I can do it with zip and a cartesian product function
10:05:21 <shapr> lots of these little functions would be really handy
10:05:27 <shapr> let's write a Postlude.hs
10:05:46 * esap has already lots of things that could be part of such thing.
10:05:50 <shapr> yes, so do I
10:05:59 <phubuh> that's a great idea
10:06:05 <shapr> I'm sure lots of people here on #haskell have those bits of code
10:06:12 * shapr creates a wiki page
10:06:43 <shapr> any better names than Postlude ?
10:06:48 <shapr> maybe Interlude ? :-)
10:06:51 <phubuh> I don't think that's possible :-)
10:07:04 <esap> PreludeExts?
10:07:35 <shapr> that's very literal, might be the best choice.
10:07:44 <esap> or NonStdPrelude
10:07:52 <shapr> heh!
10:08:48 <shapr> I think PreludeExts is the best candidate for the moment
10:08:56 <shapr> no one can misunderstand that name.
10:09:21 <esap> Is there a problem with PreludeExts that Prelude-prefixes are used by the real prelude?
10:09:25 <shapr> people *still* misunderstand the haskell-libs name, and think it's the official haskell libraries sourceforge site.
10:10:15 <shapr> esap: not that I know of, but Igloo or Heffalump may know.
10:11:17 <Igloo> Should be fine AFAIK
10:11:45 <shapr> Igloo: do you have any useful bits you think would fit into PreludeExts?
10:12:26 <Igloo> box x = [x] ro whatever the standard name for it is
10:13:10 <shapr> ?
10:13:28 <Igloo> ? Have I misunderstood the point?
10:13:40 <shapr> box x = [x]
10:13:41 <shapr> ?
10:13:47 <shapr> what's the ro ?
10:13:54 <phubuh> s/ro/or/
10:13:55 <shapr> oh, it's a misspelling for "or"
10:13:56 <Igloo> It's "or" with the letters transposed
10:14:03 <shapr> sorry, I'm low on sleep the last coupla nights
10:16:56 <shapr> @wiki PreludeExts
10:16:56 <lambdabot> http://www.haskell.org/hawiki/PreludeExts
10:17:15 <shapr> I wonder what other useful bits and bobs I could track down on the mailing lists
10:17:21 <shapr> any suggestions or pointers?
10:18:25 <esap> DeepSeq? fold? Rec? In? the cartesian product?
10:18:37 <shapr> cartesian product would be very useful
10:18:46 * esap can edit it there, hold on.
10:18:54 <shapr> also split that lets you split a string on a string
10:19:22 <shapr> tmoertel wrote that for lambdabot, it's been used in quite a few places, I suspect it's sufficiently useful
10:19:58 <shapr> what's Rec and In ?
10:20:16 <esap> data Rec f = In (f (Rec f))
10:21:21 <shapr> what do you do with that?
10:21:46 <shapr> ok, I'll add tmoertel's code
10:21:59 <esap> You can build recursive data structures with that.
10:22:23 <shapr> show me?
10:22:34 * shapr is happy to learn stuf
10:22:55 <esap> Rec Maybe  is basically a natural number.
10:23:19 <esap> With 'In Nothing' as zero, 'In (Just (In Nothing))' as one etc.
10:25:50 <esap> hmm.. maybe fzip name could be better. Any ideas?
10:26:14 <shapr> cartesianWith ?
10:26:22 <esap> ok, sounds good.
10:26:46 <Smerdyakov> That's a terrible name.
10:26:54 <Smerdyakov> It doesn't compute anything like a cartesian product.
10:26:55 <shapr> Smerdyakov: that wasn't the question.
10:27:37 <esap> cartesian_product_with?
10:27:43 <esap> too long?
10:27:50 <Smerdyakov> esap, but there is no Cartesian product involved!!
10:27:53 <shapr> I'd go with cartesianWith just because it follows Prelude naming
10:28:04 <esap> ok, what to call that then?
10:28:06 <shapr> Smerdyakov: the question was "do you have any better naming ideas"
10:28:20 <Smerdyakov> shapr, I do not claim to be responding to the question.
10:28:39 <shapr> ah, in that case, you're distracting us from collecting useful code.
10:29:07 <Smerdyakov> I don't care.
10:29:19 <Smerdyakov> I am helping esap avoid using a confusing name.
10:29:35 <shapr> I do care.
10:32:01 <Smerdyakov> As I've said before, I've made no committment to help you write programs, and distraction is really the essence of IRC.
10:32:15 --- mode: ChanServ set +o shapr
10:32:22 <opet> hooray for IRC :)
10:32:56 * phubuh tries to think of a name for flip (map . flip ($)), also known as \fs x -> map ($ x) fs
10:33:02 <Smerdyakov> What are you doing, shapr?
10:33:11 <shapr> Smerdyakov: that's called a hint in many circles.
10:33:27 <Smerdyakov> And why is a hint appropriate here?
10:34:41 <shapr> because part of the purpose of #haskell is that it is a clubhouse where we produce software. Haskell is software.
10:34:50 <Smerdyakov> esap, shapr thinks it is appropriate to kick/ban me because I do things like say that the name you suggest is bad without suggesting alternatives. Does this make sense to you?
10:35:23 <shapr> Smerdyakov: you don't actually *write* haskell code, why do you distract others from doing it?
10:36:00 <esap> I think the suggestion that the name is bad was a good one. All opinions are good, as long as they add new relevant information to the discussion.
10:36:07 <Smerdyakov> shapr, you are picking a funny example. I was the 2nd most helpful person in terms of advising esap on picking a name.
10:36:44 <esap> But of course, it would be even better if someone finds a good name. Prelude names have to be good.
10:37:21 <Smerdyakov> shapr, I'm not doing anything other than following the usual social standards of IRC.
10:37:36 <shapr> Smerdyakov: no, you don't follow the usual social standards of #haskell
10:38:04 <Smerdyakov> Well, how about doing some research to find out who agrees with you on that and who doesn't?
10:38:16 <shapr> I have actually.
10:38:27 <phubuh> I agree
10:38:29 <Smerdyakov> shapr claims that any talk here that doesn't directly support production of Haskell software is bad.
10:39:31 <Smerdyakov> While the usual IRC standard for a programming language channel is that it's a place for people with a shared interest in a language, not a committment to support any particular person or group's development efforts.
10:39:36 <Cale> Wait, there *isn't* a Cartesian product there? The fzip that I saw above looked like a Cartesian product followed by mapping a function over the resulting pairs?
10:39:36 <shapr> no, my claim is that detracting from people who are in supporting Haskell is bad for the community, and the channel.
10:39:40 <esap> hmm.. btw, how does the wiki handle concurrent updates?
10:39:52 <shapr> esap: semi-intelligently last I checked
10:40:00 <ca> um, can i draw on peoples expertise.. how ugly is this, and how would you improve it:
10:40:04 <ca> prettyRowRep :: Vector -> String
10:40:04 <ca> prettyRowRep (v:vs) = "|" ++ (show (init vs)) ++ "|"
10:40:16 <shapr> Smerdyakov: each community is unique, there is no standard.
10:40:20 <Smerdyakov> Cale, it was 3 elements X 3 elements, and the end result also had 3 elements.
10:40:25 * earthy smothers shapr and smerdyakov with a pillow
10:40:59 <Cale> ah, oops - it's a dot product
10:41:13 <Cale> of matrices
10:42:39 <phubuh> we talk about non-Haskell stuff often, but you, Smerdyakov, seem to have a penchant for taking things too seriously, being annoying, and just generally annoying
10:42:55 <phubuh> whoops, that's a double annoying
10:43:41 <phubuh> I get nervous when I'm not being very nice :(
10:43:50 <shapr> yah, me too
10:43:54 <shapr> but I think it's necessary.
10:44:29 <Smerdyakov> I don't in any way disrupt the reasonable operation of this channel.
10:44:41 <shapr> I strongly disagree.
10:44:58 <phubuh> your presence does, even though it might not always be your fault.  just look at this derail
10:44:59 * earthy starts waving the pillows again
10:45:07 <earthy> *pillowfight!*
10:45:12 <shapr> :-)
10:45:37 <ca> ok, that code didnt work anyway .. so nm
10:45:39 <Smerdyakov> phubuh, did you look at the beginning of this conversation? You honestly think a suggestion against a particular function name is a BAD, UNDULY NEGATIVE thing to say?
10:45:52 * earthy doesn't
10:45:56 <esap> I added Adjunction type class to the page.
10:46:20 <earthy> however, standing your ground and not offering thought on the problem later can be considered annoying
10:46:58 <Smerdyakov> earthy, unless I happen to be checking in on the channel from time to time and responding to what I see, instead of committing to a brainstorming session....
10:47:11 <earthy> and I *always* consider it socially unacceptable to claim not to want to think
10:47:22 <earthy> which it seemed like you were doing
10:47:30 <phubuh> Smerdyakov: no; actually, I would speak out myself if I knew what a Cartesian product was -- but I wouldn't have expressed myself as "That's a terrible name."
10:47:33 <earthy> (I think I know better than that, but it seemd like it :))
10:47:54 <shapr> ok, I haven't heard any better suggestions
10:47:58 <Smerdyakov> phubuh, you don't think a name that uses a precise mathematical term that doesn't actually apply is worthy of the name "terrible"?
10:48:09 <Smerdyakov> phubuh, in terms of its ability to confuse users?
10:48:22 * SamB wonders why microsoft research exists
10:48:24 --- mode: shapr set +b *!*@206.169.168.190
10:48:31 --- kick: Smerdyakov was kicked by shapr (Kicked by shapr)
10:48:54 <ca> oh boy :P
10:49:20 <phubuh> it had to be done eventually.  thanks shapr :-)
10:49:26 <earthy> !sigh
10:49:33 <phubuh> now, where were we...
10:49:37 <shapr> sorry for the drama, I've talked with him several times in private, to no result
10:49:50 <shapr> we were finding bits for PreludeExts
10:49:59 <earthy> phubuh: somewhere 'round fzip, methinks. >:)
10:50:56 <SamB> shapr: that was drama?
10:51:22 <shapr> SamB: I really don't like banning people.
10:51:51 <Igloo> SamB: Some projects from MSR move into the commercial bit after they mature
10:52:27 <Igloo> Other algorithms and suchlike will of course likely be used at some point somewhere, not neccessarily in MS
10:53:06 <phubuh> stuff from ivory tower functional programming always finds its way down to mundane programming :-)
10:53:28 <SamB> I guess I have to say I find it surprising to see Free software on microsoft.com ;-)
10:53:38 <earthy> not very.
10:53:50 <Igloo> Open Source, not Free
10:53:53 <earthy> if they want the best researchers, they have to
10:55:03 <SamB> Igloo: A rose by any other name would smell as sweet.
10:56:57 <phubuh> I added pam to PreludeExts, the name of which is also kind of tacky
10:58:12 * SamB wonders what the language in cayenne/agda/alfa is called
10:58:30 <shapr> pam is cute
11:02:04 <shapr> SamB: do you have any suggestions for PreludeExts ?
11:02:10 * SamB is not impressed by what Smerdyakov was saying before he entered
11:02:28 <SamB> shapr: I'm looking at the log
11:02:43 <shapr> ok
11:02:45 <earthy> okay, time to get some dinner
11:03:30 <SamB> pam is not an obvious name. rmap?
11:04:00 <phubuh> I like rmap
11:04:08 * earthy nods in full agreement
11:04:36 <esap> I added Rec, fold etc.
11:06:26 <Taaus> fzip (,) isn't quite a cartesian product... It needs flattening.
11:06:44 * esap then forgot to add (Functor f) to the type signatures of fold&unfold :-(
11:06:52 <SamB> Taaus: flattening?
11:07:23 <Taaus> SamB: It produces a list of three lists (of three elements each). It should produce a single list of nine elements.
11:07:43 <Taaus> In the example.
11:08:03 <Taaus> (From earlier... fzip (,) [1,2,3] [4,5,6] , say)
11:09:34 <shapr> so what does it produce now?
11:09:50 <phubuh> Prelude> fzip (,) [1, 2] [4, 5]
11:09:50 <phubuh> [[(1,4),(1,5)],[(2,4),(2,5)]]
11:10:01 <phubuh> the cartesian product would be the concatenation of those lists
11:10:04 <SamB> Taaus: that wouldn't work very well with (fzip (,) [1,2,3] (Just 4))
11:10:30 <esap> so should use 'join' on the result of the 'fzip (,)' to get real cartesian product, hmm..
11:11:14 <esap> Then you need both Monad and Functor classes for it.
11:12:14 <esap> And it would be somewhat more restricted. Maybe both are useful.
11:12:18 <Taaus> SamB: Good point... Hmm...
11:12:25 <SyntaxNinja> is it wrong to love good coffee?
11:13:20 <SamB> I haven't actually noticed a kind of Functor that wasn't also a kind of Monad. Does anybody know of any offhand?
11:13:55 <esap> I think I have some examples, hold on.
11:14:12 <SyntaxNinja> esap: add 'em to the wiki :)
11:15:04 <ca> whats the difference btw (**) and (*) ?
11:15:13 <SamB> ca: ** is power
11:15:27 <ca> ok, ty
11:16:25 <esap> SyntaxNinja: Hmm.. maybe "(,) a"  is one example. It's definitely a Functor with fmap f (x,y) = (x, f y), but I guess return might be hard to implement [you'd need to use 'undefined', which is not good]
11:19:59 <SamB> esap: thats reasonable example, I suppose.
11:20:16 <esap> did someone just break the front page of the wiki?
11:20:40 <phubuh> haha
11:20:40 <SamB> yes
11:20:41 <phubuh> owned indeed
11:20:59 <ca> was it the person who got kicked?
11:21:03 <SamB> phubuh: yeah right
11:21:25 <phubuh> ca: I strongly doubt it
11:21:33 <phubuh> though that would be an interesting twist!
11:21:33 <esap> ca: no I think this has happened before from the same person from brazil.
11:21:52 <phubuh> ok, restored
11:22:29 <ca> esap: okay
11:22:31 <SamB> anybody should know you can't own a wiki in one edit...
11:22:49 <SamB> a wiki page, even
11:24:21 <det> shapr: hello
11:25:45 * SamB thinks fzip sounds like Functor f => f a -> f b -> f (a, b)
11:27:49 <SyntaxNinja> that happens to the front page every so often.
11:29:24 <esap> should find a good name for fzip.
11:30:37 <shapr> hello det 
11:30:42 <shapr> heya Darius 
11:31:11 <det> shapr: you interested in the backup MX still ?
11:31:37 <shapr> sure
11:32:06 * SamB wonders if it would be reasonable to store wikipages as literate haskell
11:32:34 <shapr> hm, FrontPage is gone again
11:33:07 <SamB> again, he edits only once!
11:33:57 * shapr fixes
11:34:55 <Darius> shapr: heya.  I read the logs to see what esap was responding to and found quite a bit more.
11:35:40 <shapr> yes, today's drama
11:35:43 <shapr> as the stomach turns ;-)
11:38:17 <esap> oh btw, are my names for leftAdjunct and rightAdjunct reversed? I never checked which way it should be :-)
11:39:49 <Maddas> hm
11:41:13 * mgoetze just now notices that Marvin-- submitted something of his to a funny quotes page, over a year ago...
11:53:49 <esap> Hmm.. I just found two papers by different authors who both use lad and rad in opposite ways. Hmm...
11:54:30 <shapr> mgoetze: you're famous!
11:56:10 <SamB> so, how is it that both f and g uniquely determine the other?
11:56:34 <esap> that's what Adjunction does.
11:57:38 <esap> Maybe I could add an example of an instance of an adjunction.
11:57:42 <mgoetze> shapr: well, let's put it this way, a google search for "mgoetze" is at least still mostly about me.... as opposed to one about "Michael Goetze".... ah, those were the days
11:58:56 <mgoetze> you know, if i ever have kids, i'm going to give them really funky names just so google gives them mostly relevant results when they... you know...
11:59:06 <shapr> yah, me too
11:59:16 <ca> :)
11:59:17 <shapr> though I'm currently on the losing end of the weird/normal names argument.
11:59:20 <shapr> hi ca
11:59:35 <esap> Ok, I added an example of an instance of Adjunction.
11:59:44 <ca> hey shaprs .. i agree with you kicking that guy, you are far too nice to be cranky 
12:00:07 <shapr> I get cranky, I just try to do it away from people ;-)
12:00:16 <mgoetze> shapr: you mean there's an active discussion going on about that topic in your household?
12:00:27 <shapr> mgoetze: yes
12:00:38 <shapr> mgoetze: I'm older than you, remember? ;-)
12:00:52 <shapr> ca: thanks for the vote of confidence
12:01:03 <shapr> ned: hey, are you awake?
12:01:04 <mgoetze> shapr: oh, right :) still the nice german girl?
12:01:11 <shapr> yes, very nice
12:01:20 <ca> you are welcome .. anywho the clock just hit 4am,  goodnight from me. 
12:01:25 <shapr> goodnight!
12:01:37 <SyntaxNinja> shapr: is bea expecting?
12:02:04 <shapr> no, but we're discussing names
12:02:27 <SyntaxNinja> OK. just checking ;)
12:02:30 <shapr> :-)
12:02:48 <shapr> esap: yes, adjunct example!
12:02:57 <mgoetze> well, the way my grandparents did it is, my grandmother got to name the girls and my grandfather the boys
12:03:08 <shapr> oh, good idea, I'll suggest that.
12:03:14 <mgoetze> that's why my aunts all have really weird names, just like my mom...
12:03:31 <Maddas> What's her name?
12:03:38 <shapr> Darius: do you have any code that would fit into PreludeExts ?
12:03:54 <mgoetze> my mom is swanhild, and my aunts are dietlinde, roswitha, mechthild and adelheide...
12:04:02 <shapr> whoa, nifty
12:04:09 <shapr> mechthild is especially cool
12:04:13 <Maddas> Roswitha and Adelheide sound like standard names
12:04:18 <Maddas> the others, well, I don't know :-)
12:04:41 <mgoetze> adelheide is probably the most standard of the batch... and yet i still haven't met anyone else called adelheide ;)
12:05:11 <Maddas> a former neighbour of mine is called Roswitha
12:05:22 <Maddas> well, it's her name, hence her being called like that
12:07:12 <esap> ack, my Adjunction example has a problem: I'm not sure how to properly make ((,) a) and ((->) a) instances of Functor, because some GHC libs do that, but std prelude doesn't .-)
12:08:32 <SamB> esap: yeah, I just stumbled into that 
12:09:13 * esap added instances for Functor for those into the page. But beware of GHC libs.
12:09:16 <SamB> well, the the part where std prelude doesn't
12:09:31 <shapr> anyone have more code suggestions for PreludeExts?
12:10:44 <SamB> why is (flip (map . flip ($))) still spelled pam?
12:11:07 <mgoetze> shapr: well no, but i suggest that you might deop yourself now ;)
12:11:13 <shapr> oh, right
12:11:16 --- mode: shapr set -o shapr
12:11:49 <mgoetze> btw, i'd like to announce that haskell no longer qualifies as the "weirdest language i have learned/am learning"
12:12:00 <shapr> yay!
12:12:13 <mgoetze> i started on finnish ;)
12:12:17 <shapr> haha!
12:15:53 <SamB> haskell wierd?
12:16:01 <SamB> weird, even?
12:21:11 <mgoetze> SamB: sure... the it doesn't even have singular and plural!
12:21:38 <mgoetze> (as in: $rabbit, @rabbit)
12:22:18 <SamB> mgoetze: I hardly think that qualifies as an example of a normal language
12:22:52 <mgoetze> SamB: nor does english, but we tend to compare everything to it anyway ;)
12:23:25 <SamB> does english really warp your mind so that everything becomes wads and wads of duct tape?
12:24:16 <mgoetze> SamB: no, i'll leave that to languages with words like 'määväärä'
12:30:50 * shapr googles for worthwhile additions to PreludeExts
12:30:56 <shapr> oh, it might be useful to see what utility modules other Haskell projects have factored out.
12:35:36 * esap is browsing through my codebase for some other good additions.
12:41:32 <esap> Hmm.. DeepSeq from the mailing list?
12:42:04 <shapr> for some reason I thought DeepSeq was a standard module.
12:42:14 <esap> I don't think so.
12:42:38 <esap> I think even GHC libraries don't contain it.
12:42:43 <shapr> yup, I agree.
12:42:52 <Darius> There's the Strategy library that has rnf.
12:44:06 <shapr> where is Strategy?
12:44:13 <shapr> hi maihem
12:44:37 <maihem> hello shapr
12:44:55 <shapr> what's up?
12:48:00 <esap> darius: I guess you mean this: http://www.haskell.org/pipermail/glasgow-haskell-users/2002-July/003772.html
12:48:08 <shapr> the windows special filenames discussion on libraries@haskell.org is entertaining
12:48:40 <SyntaxNinja> shapr: yeah, that was a big surprise to me
12:48:50 <shapr> oh, so Strategy comes with GHC
12:49:03 <shapr> is it still there?
12:49:19 <phubuh> does the prelude have anything like for :: IO a -> (a -> Bool) -> (a -> IO a) -> (a -> IO ()) -> IO ()?
12:49:36 <ddarius> SyntaxNinja: Aren't you (and Abe) the one to blame for that? ;)
12:50:14 <shapr> looks like it may have changed names to rwhnf
12:50:21 <SyntaxNinja> ddarius: heh. well, abe wrote all that code.  I analyzed the FGL for our needs and wrote up a list of things I wanted, asked the original author about htem, then farmed them off to abe.
12:50:48 <ddarius> shapr: It doesn't seem like it is (still there).
12:50:56 <ddarius> rwhnf is just seq
12:51:20 <esap> where is it in GHC libs?
12:51:43 <esap> sorry.
12:51:51 <ddarius> It used to be in package concurrent.
12:51:56 <shapr> esap: ghci -syslib concurrent then ":b Strategies"
12:52:11 <shapr> I really wish ghci and -c would work together
12:52:54 <shapr> or that I knew how to write the equivalent ghci ":foo" commands in -c
12:53:02 <ddarius> phubuh: No, but usually (monadic) list processing functions do much of the same.
12:53:23 <ddarius> phubuh: and of course, you could always write it (and there's little or no reason to limit to IO)
12:53:47 <phubuh> yeah, I did write it, and I hadn't even considered not limiting it to IO :-)
12:53:48 <phubuh> thanks!
12:54:06 * SamB wonders why "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" uses foldr backwards
12:54:37 <shapr> I'll solicit additions to PreludeExts on libraries once I've looked around a bit for obvious candidates.
12:54:53 <shapr> DeepSeq sounds like a good one
12:55:41 <phubuh> hmm, if I use an arbitrary Monad m instead of IO, what should I use instead of IO ()?
12:56:25 <SamB> m ()?
12:57:11 <cptchaos> I would say "m ()" too
12:57:23 <ddarius> shapr: It seems many people would like the Prelude reduced or restructured rather than extended.
12:58:59 <shapr> I think that's a good idea, but probably requires a separate wiki page.
12:59:43 <shapr> ddarius: do you know of a list of prelude changes off the top of your head?
13:00:16 <ddarius> No
13:04:12 <Igloo> Refactoring Num etc is one that comes to mind
13:04:36 <Darius> Moving many functions that could (should) be in (Data.)List is another one.
13:04:56 <esap> there was actually a proposal for refactoring Num, I think [with things like AbelianGroup etc.]
13:05:23 <shapr> I saw a recent mention of typeclasses for (+) (-) etc
13:05:55 <Darius> www.haskell.org/development
13:07:30 * SamB wonders what would happen if you tried to feed GHC a wrong, but still unary, type definition for []
13:09:22 <ham[kell]> good night
13:09:31 <shapr> good night ham[kell] 
13:09:45 <ham[kell]> thx bye
13:15:41 <shapr> locate Util.hs is useful
13:16:31 <Igloo> SamB: What do you mean by type definition?
13:17:38 <SamB> Igloo: in GHC.Base there appears a line that begins "data [] a ="
13:19:02 <SyntaxNinja> I think I'm going to name all of my Util type files Aux from now on :)
13:19:37 * shapr snickers
13:19:39 <Igloo> And put smart constructors in Con?  :-)
13:19:55 <SyntaxNinja> yup
13:20:03 <Darius> phubuh: What is your definition of for?
13:20:05 <shapr> -main-is Nul.main
13:20:15 <phubuh> for :: Monad m => m a -> (a -> Bool) -> (a -> m a) -> (a -> m ()) -> m ()
13:20:16 <phubuh> for init test iter body = do x <- init
13:20:16 <phubuh>                              loop x
13:20:16 <phubuh>     where loop x = do if (test x)
13:20:16 <phubuh>                          then do body x
13:20:16 <phubuh>                                  x' <- iter x
13:20:19 <phubuh>                                  loop x'
13:20:20 <phubuh>                          else return ()
13:20:43 <Igloo> SamB: You might need to call the module GHC.Base to be allowed to do it. I suspect the list syntax wouldn't obey scope rules and would still be the internal ones, though
13:22:06 <SamB> Igloo: -fno-implicit-prelude?
13:22:49 <Darius> Okay.  It's likely better to have test be something like a -> Maybe a as often the test code does something that the body code will need to do as well.
13:23:26 <Darius> Also stylistically, the do in loop is unnecessary and 'when' is the same as that if.
13:23:28 <Igloo> Do you not still get lists with that?
13:25:29 <phubuh> ah, the do is a remainder from ye olde times when it was needed
13:25:30 <phubuh> thanks :-)
13:27:31 <Darius> Which reminds me of something that might be useful for PreludeExts, an if function and boolToMaybe/maybeToBool functions
13:28:44 <Igloo> Where True === Just ()?
13:29:07 <Igloo> Or taking another argument?
13:29:11 <Darius> I'd probably have two, one that provides a value and one that uses undefined.
13:29:30 <Darius> Or maybe just the former as the latter would just be a partial application of it.
13:30:28 <Darius> Don't know what to call the if function though.
13:36:46 <esap> Isn't there already 'maybeToBool', called 'isJust'.
13:39:25 <Darius> Yes
13:40:05 <esap> and 'boolToMaybe' is called 'guard'.
13:40:27 <Darius> Not with an extra parameter.
13:40:42 <esap> extra parameter?
13:41:03 <Darius> \x -> guard p >> return x would do it
13:41:29 <Igloo> guard? Is that in H98?
13:41:47 <esap> In Monad.
13:41:50 <Darius> module Monad
13:43:39 <Darius> Also guard's type is a bit restrictive
13:43:44 <Igloo> Oh, OK. I didn't remember it and only checked Maybe
14:05:34 * SyntaxNinja pounds head against wall
14:05:57 <shapr> Lunar^: found another pure haskell regex module, RE.hs by Joe English. This one seems unusually nifty.
14:07:04 <shapr> stupid question... can I use Control.Monad.Fix.fix to actually find the fixpoint of something like sin?
14:07:51 <SyntaxNinja> damn. a long time back, I was translating some imperative code to Haskell
14:08:21 <SyntaxNinja> there was a big section like x := foo x {BIG COMPLEX EXPRESSION WITH A BUNCH OF X} end
14:08:52 <SyntaxNinja> which, I translated to something like y := foo x {BIG COMPLEX EXPRESSION WITH A BUNCH OF Y EXCEPT THAT IN ONE CASE I ACCIDENTALLY PUT X AND THAT'S WHY I'M POUNDING MY HEAD AGAINST THE WALL}
14:08:58 <phubuh> hey shapr, how did you prevent @ghci _ <- print "hello" ?
14:09:05 <SyntaxNinja> (sorry for the shouting ;) )
14:09:15 <shapr> phubuh: @dynamic-unload ghci
14:09:28 <phubuh> oh :-)
14:10:01 <shapr> actually, hampus checked the type of everything, and wouldn't execute it if the string "IO" was in the type.
14:10:17 <shapr> I think I have the hampus' latest GHCiModule.hs handy, if you want a copy.
14:10:42 <shapr> SyntaxNinja: that's amusing, mostly because it's not me, but it has been me, and will be me again sometime in the future.
14:11:38 <Igloo> shapr: unsafePerformIO...
14:12:24 <shapr> Igloo: hampus checked for IO in the input string as well.
14:12:40 <shapr> Darius came up with a small menagerie of ways around that.
14:13:01 <shapr> that is in fact, how I found out that -fglasgow-exts -fno-th still turns on Template Haskell
14:13:11 <Igloo> :-)
14:13:14 <Igloo> Any non-TH ways?
14:13:17 <shapr> oh yes
14:13:32 <Igloo> Might be one using ST - I'm not familiar with it
14:13:42 <shapr> Darius: do you still have those? I'd actually enjoy writing a journal entry about that.
14:13:54 * SyntaxNinja dances around
14:14:05 <SyntaxNinja> the program looks like it totally works, and fixes a problem that I thought was unrelated too :)
14:14:17 <SyntaxNinja> this program is so complicated. I've been debugging this stupid thing since yesterday morning
14:14:23 <shapr> let's see, one that used unsafeCoerce#, one that used Generics maybe?
14:14:25 <Igloo> What is it, Syn?
14:14:26 <SyntaxNinja> and I fixed some unrelated problems.
14:14:33 <shapr> SyntaxNinja: unit tests! quickcheck tests!
14:14:46 <SyntaxNinja> Igloo: it's a simulation environment, solves systems of equations over time.
14:14:47 <shapr> manual debugging massively sucks
14:14:51 <SyntaxNinja> doesn't use FRP, but maybe some day it will.
14:15:02 <Igloo> :-)
14:15:11 <SyntaxNinja> shapr: this was my first big haskell program, and I didn't write good unit tests from the beginning.
14:15:22 <SyntaxNinja> now it's a matter of fixing that.
14:15:44 * shapr tries not to think about lambdabot's lack of unit tests
14:23:11 * shapr finally discovers that ln does not require the link name
14:24:52 <Darius> shapr: I should have the log, I can email it to you if you'd like.
14:25:19 <shapr> Darius: yes please!
14:36:21 <shapr> hej jagular 
14:36:25 <jagular> hej hej
14:36:31 <shapr> vad händer?
14:37:07 <jagular> hm.. jag äter vindruvor. :)
14:37:12 <jagular> vad gör ni här inne då?
14:39:48 <shapr> jag söker för bra research papers för att framställa (inkjet print?)
14:40:25 <shapr> jagular: har du sett #haskell.se ?
14:41:44 <Darius> Okay I sent it a minute or two ago.
14:41:59 <shapr> Darius: thanks
14:42:58 <shapr> jagular: long time no see, how's code treating you?
14:43:10 <det> A SML datatype without using references can never have cycles, right ?
14:48:10 <phubuh> isn't 'cycle' a meaningless word without references?
15:35:54 * SamB does not see the point of the circled plus in the bananas/lenses/etc notation, which is always rebound right afterwords anyway -- why not just write the function there in the first place?
15:41:34 * SamB wonders what the point of explicit envelopes is
15:50:38 <Darius> (responding to your earlier comment) In the paper it's likely just to emphasize that it fits the pattern.  Anyways the circled plus has no inherent meaning it's just an identifier and writing the functions in in-place would be ugly.
15:51:49 <Darius> I don't get your second comment.
15:52:15 <SamB> Darius: I didn't mean they should write in a lambda abstraction
15:52:54 <SamB> oh, with the second one, I'm probably just thinking too much like a programmer.
16:00:25 <det> well ..
16:00:26 <det> ocaml has "let rec a = 0 :: []"
16:00:43 <det> but sml happily informs me that:
16:00:45 <det> - val rec a = 0 :: [];;
16:00:47 <det> stdIn:1.9-1.20 Error: fn expression required on rhs of val rec
16:20:58 <shapr> yow!
16:23:43 <ham[kell]> hiho
16:25:04 <shapr> it's night time!
16:25:34 <ham[kell]> heh
16:25:38 <ham[kell]> i wish
16:25:49 <shapr> it's 1:30am in our timezone.
16:26:08 <ham[kell]> i am in the same time zone as you are
16:27:16 <shapr> yup
16:28:08 <ham[kell]> i think i have to stay awake till this evening
16:28:20 <shapr> yikes
16:28:38 <ham[kell]> i need to get into a better sleep rythm again
16:28:55 * shapr gets out the sleep drums
16:29:04 <ham[kell]> heh :)
16:37:59 <shapr> g'day Pseudonym 
16:38:04 <shapr> @wiki PreludeExts
16:38:04 <lambdabot> http://www.haskell.org/hawiki/PreludeExts
16:38:06 <Pseudonym> G'day.
16:38:29 <Pseudonym> Cool.
16:38:47 <shapr> got any additions?
16:39:15 <shapr> or changes, refactoring, etc?
16:39:19 <Pseudonym> I don't like "box".
16:39:28 <Pseudonym> When (:[]) or "return" do the job.
16:39:52 <Pseudonym> Let me have a look through my libraries, hang on.
16:39:55 <shapr> ok
16:39:58 * Pseudonym is kinda enthused at the moment
16:40:00 * shapr bounces happily
16:40:08 <shapr> oh, what are you enthused about?
16:40:10 <Pseudonym> Looks like there might be some interest in getting a decent unified collections library.
16:40:19 <shapr> yah, I've seen it on the libraries list.
16:40:35 <Pseudonym> I'd be more than happy to turn Edison into something else, if everyone else can decide what that something else should be.
16:40:46 * Pseudonym hasn't worked on it lately because nobody wants it
16:41:04 <shapr> sometimes I think we should have rotating Haskell advertisement signatures "try the Haskell irc bot, lambdabot! http://lambdabot.sf.net/"
16:41:28 <Pseudonym> I somehow think it might only be relevant to people here.
16:42:02 <shapr> yes, but it could also advertise Edison, FGL, or other stuff
16:43:28 <Pseudonym> I think we should put factorial in the Prelude to make undergraduate students' lives easier.
16:43:33 <shapr> haha!
16:43:37 <Pseudonym> Oh, and "infinite list of primes".
16:44:48 <ham[kell]> ?
16:45:05 <ham[kell]> infinite list of primes?
16:45:21 <Pseudonym> Yes.  Didn't you have to do that at one point?  (Assuming you studied Haskell, that is.)
16:45:48 <ham[kell]> nope
16:45:52 <Pseudonym> Ah, OK.
16:46:06 <ham[kell]> i didnt do haskell at school or uni
16:46:13 <shapr> I didn't either.
16:46:19 <shapr> my school offered COBOL and Pascal
16:46:25 <ham[kell]> :)
16:46:27 <shapr> and the Pascal class was new =)
16:46:58 <ham[kell]> then you are quite old :)
16:47:30 <SamB> Pseudonym: I thought about doing it, but haven't thought of a use for it yet.
16:47:38 <Pseudonym> When I was an undergrad, the language taught was Pascal, but they were testing out this new language, Miranda.
16:47:54 <Pseudonym> Everyone who knew Pascal got to do that instead.
16:48:22 * shapr falls over asleep
16:51:06 <emu> hascal, the unholy union
17:13:04 * SamB thinks n-ary tuples is a misfeature
17:13:28 <Pseudonym> Why?
17:14:51 <SamB> Pseudonym: well, they can't be instances of arbitrary classes, for one.
17:14:57 <Riastradh> 'N-ary tuples?'
17:15:17 <Pseudonym> Sure they can/.
17:15:35 <Pseudonym> instance Foo (a,b,c) where
17:16:36 <SamB> what I mean is, well, you can't make them ALL instances of an arbitrary class
17:17:07 <Pseudonym> What class did you have in mind?
17:17:47 <SamB> well, Eq and Ord would be good, for starters ;-)
17:17:55 <Pseudonym> They're already members of those.
17:18:03 <Pseudonym> If they're not, that's a bug in your implementation.
17:21:52 <SamB> what is this, then? Data.Tuple says (inside #ifdef __GLASGOW_HASKELL__):
17:21:53 <SamB> data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o = (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o deriving (Eq, Ord)
17:21:53 <SamB> data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p = (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
17:21:53 <SamB> data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
17:21:53 <SamB>  = (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
17:22:13 <Pseudonym> A bug.
17:22:46 <Darius> SamB: The tuples aren't related.  Saying you want to "make them ALL instances" of some class is like saying you want to make 'data Foo = ...,data Bar = ..., etc' ALL an instance of a class.
17:24:20 <Pseudonym> This is straight from the H98 report, section 6.1.4:
17:24:23 <Darius> However, you can represent n-tuples as nested 2-tuples and () and then you -can- make instances for all n-"tuples" at once.
17:24:25 <Pseudonym> "All tuples are instances of Eq, Ord, Bounded, Read, and Show (provided, of course, that all their component types are)."
17:25:16 <SamB> Pseudonym: thats a special case, and its not good to special case.
17:25:39 <Pseudonym> The "deriving" keyword is a special case, too.
17:26:02 <SamB> Pseudonym: in the standard it is, yes
17:27:52 <Pseudonym> Ah, I see.
17:27:55 <Pseudonym> "There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples."
17:28:08 <Pseudonym> There you go.  It's not a bug.
17:29:47 <Pseudonym> Incidentally, if you need a fancy class with automagic derivations, Template Haskell can probably do it.
17:33:25 * SamB wonders why you can't section tuples
17:36:10 <Pseudonym> It would be kinda handy.
17:36:20 <Pseudonym> (a,) means \b -> (a,b)
17:36:29 <Darius> That can be done.
17:36:31 <Darius> (,) a
17:36:38 <Darius> @type (,) a
17:36:48 <Darius> @type (,) 3
17:36:48 <lambdabot> (3,) :: Num a => b -> (a,b)
17:36:49 <Pseudonym> Yeah, but it needs parentheses.
17:37:07 <Pseudonym> (,,) (f a) (g x y) compared with (f a,g x y,)
17:37:21 <Pseudonym> Oh, interesting.
17:37:23 <Pseudonym> @type (3,)
17:37:40 <Darius> Yeah, I didn't notice that.
17:37:41 <Pseudonym> Odd.
17:37:53 <Darius> Hugs' crazy internal representations.
17:37:56 <Pseudonym> :-)
17:38:51 <Darius> @type flip (,) 3
17:38:52 <lambdabot> flip (,) 3 :: Num a => b -> (b,a)
17:39:41 <Pseudonym> @type \a b -> (a,b)
17:39:41 <lambdabot> \\a b -> (a,b) :: a -> b -> (a,b)
17:39:49 <Pseudonym> @type \b -> (a,b)
17:39:55 <Pseudonym> @type \b -> (2,b)
17:39:56 <lambdabot> \\b -> (2,b) :: Num a => b -> (a,b)
17:40:06 <Pseudonym> @type (,,) 1 2
17:40:06 <lambdabot> (1,2,) :: (Num a, Num b) => c -> (b,a,c)
17:40:11 <Pseudonym> There you go.
17:40:16 <Pseudonym> @type (,,) 'a'
17:40:17 <lambdabot> ('a',,) :: a -> b -> (Char,a,b)
17:40:28 <Pseudonym> Cool!  Why can't we have that at the language level?
17:40:36 <Darius> @type (,,) 'a' 3
17:40:36 <lambdabot> ('a',3,) :: Num a => b -> (Char,a,b)
17:42:32 <SamB> may I assume that lambdabot refuses to do things whose names start with unsafe?
17:42:49 <Darius> You could, but it wouldn't be true.
17:43:02 <Pseudonym> @type unsafePerformIO
17:43:12 <Pseudonym> Hmmm.
17:43:15 <Darius> unsafePerformIO is not part of the Prelude
17:43:21 <Pseudonym> Right.
17:43:31 * Pseudonym figured that right after he got no response
17:43:43 <Darius> Something I've wanted is ('a':'b':'c':)
17:43:59 <Darius> @type ('a':('b':))
17:44:46 <SamB> Darius: with fusion and all, ("abc"++) should be okay. I think.
17:48:07 <Darius> Probably, but I've programmed in C++ more than any other language, and I like assembly.
17:51:20 <SamB> Darius: I also tend to worry about the details, but I prefer them to fall into place
17:54:22 <Riastradh> @type (('a':) . ('b':))
17:54:22 <lambdabot> ('a' :) . ('b' :) :: [Char] -> [Char]
17:55:33 <Darius> @type ('a':) . ('b':) 
17:55:34 <lambdabot> ('a' :) . ('b' :) :: [Char] -> [Char]
17:59:29 <SamB> @info Monad
17:59:29 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
18:41:27 <SamB> so much for trying to make lists based om (,)...
18:47:11 <Darius> You can make heterogenous lists whose length is determined and enforced at compile tim using pairs and ().
18:47:38 <Darius> Though you have to express functions over them as type classes.
18:47:55 <Darius> Alternatively, (Dynamic,Dynamic) is roughly a Lisp cons.
20:41:42 <SamB> shapr: there are some reasonably high-powered proof-checkers-as-type-systems, aren't there?
21:00:30 <det> Pseudonym: hiya
21:02:01 <det> Darius: length know at compile time, why not just use a tuple
21:24:29 <SamB> you know, its refreshing to see mathematicians using programming terms like Cons
21:32:17 * isomer is away: zozo
22:14:15 <Darius> det: The length is calculated at compile-time.
22:26:41 <Pseudonym> det: Belated G'day.
22:31:56 <SamB> what, pray tell, is an unnatural function?
22:33:39 <Darius> Pseudonym: You didn't run that code (PreludeExts) through a compiler did you?
22:33:53 <Pseudonym> No, of course not.
22:34:13 <Pseudonym> I get other people to do my debugging for me.
22:34:24 <Darius> I was going to say that a second ago about the fmap, but then I looked at the ListS newtype.
23:32:47 <Pseudonym> Nytol.
