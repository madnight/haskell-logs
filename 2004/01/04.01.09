01:25:30 --- mode: brin.freenode.net set +n
03:32:28 <ham[let]> hiho
03:53:09 <shapr> @yow
03:53:13 <shapr> um
03:53:22 <ham[let]> ?:)
03:53:27 <shapr> hmm
03:53:33 <ham[let]> hiho shapr
03:53:47 <shapr> hello ham[let] 
03:53:49 <shapr> @yow
03:53:49 <lambdabot> Is this an out-take from the ``BRADY BUNCH''?
03:53:52 <Heffalump> 'lo
03:53:58 <shapr> hello Heffalump 
03:54:02 <raver> y0 mates!
03:54:09 <shapr> g'day raver 
03:54:26 <raver> yeah good day
03:54:41 <raver> sun is shining in Leicester...
03:54:49 <raver> :)
03:54:52 <Heffalump> Leicester?
03:54:56 <raver> UK
03:54:57 <ham[let]> raver what are you studying there?
03:55:05 <raver> Computing Science
03:55:09 <shapr> the snow is shining near the arctic circle
03:55:14 <Heffalump> oh, it was just the fact that you're connected from a .com address that confused me
03:55:25 <raver> shapr lol
03:55:28 <shapr> now, lessee if I can quickly recover my bind files from the old drive...
03:55:28 <Heffalump> someone I know used to be a CS lecturer there
03:55:53 <ham[let]> raver ive seen a report on a project at you uni about augmented reality
03:55:57 <ham[let]> quite interesting
03:56:03 <raver> Heffalump what subject?
03:56:12 <Heffalump> security I guess, not sure
03:56:16 <Heffalump> it was a few years back
03:56:26 <raver> i will do security next semester
03:56:29 <raver> ;)
03:56:43 <raver> ham[let] there a lot of computing students here
03:57:02 <raver> but i'm a newbie here i know nothing about that project
03:57:14 <raver> :(
04:00:05 <shapr> @fortune
04:00:05 <lambdabot> PIZZA!!
04:00:13 <shapr> @arr
04:00:14 <lambdabot> Yeh scurvy dog...
04:03:04 <door> which textbook would you guys consider being the best introduction to lambda, for someone who's already done some (limited) functional programming in lisp and likes the more-or-less functional aspects of python? :)
04:04:24 <shapr> lambda calculus?
04:04:35 <shapr> or functional programming? or Haskell? what's your goal?
04:05:47 <shapr> argh, apache is broken in unstable
04:09:55 <door> err
04:10:14 <door> i dunno why i said lambda, i meant haskell
04:10:27 <door> sorry, just woke up :)
04:10:43 <darius-> door - the haskell school of expression probably
04:10:49 <door> mentally that is
04:11:00 <door> okay
04:11:40 <darius-> at least, i'm a lisper and i liked it
04:12:27 <door> Rather than using the conventional mathematical examples commonly found in other programming language textbooks <- i like mathematics though.. :)
04:12:43 <shapr> door: then SOE is for you.
04:13:02 <shapr> the other contenders are less math oriented
04:13:26 <door> okay. that was from http://www.haskell.org/soe/ though
04:13:54 <shapr> I have SOE and "The Craft of Functional Programming"
04:14:00 <door> is there perhaps as example chapter to read somewhere?
04:14:02 <shapr> if you like math, you'll prefer SOE.
04:14:03 <door> an*
04:14:08 <door> shapr: ok
04:14:59 <shapr> if you're a student of a swedish uni, you should be able to find both books in your local library.
04:15:41 <shapr> I try to glance through a book at a library before I buy it. I tend to purchase programming books so I can argue with the authors via notes in the margin.
04:16:03 <darius-> obviously they should publish them as wikis instead then ;0
04:16:06 <darius-> er :)
04:16:13 <shapr> truly
04:16:40 <door> shapr: not a uni but a gymnasium :)
04:17:04 <shapr> do you have a uni within traveling distance?
04:17:28 <door> yah.. i live in sthlm
04:18:08 <shapr> you could at least look at the books beforehand then.
04:18:42 <door> ok, thats a good idea. thanks
04:19:10 <shapr> you may also get to look at Richard Bird's Haskell textbook, of which I've forgotten the name.
04:19:27 <shapr> I haven't seen it, so I have no opinion.
04:19:41 <door> Introduction to Functional Programming using Haskell?
04:19:47 <shapr> that sounds right
04:19:58 <shapr> yes, that's the one
04:20:09 <shapr> this lists another one: http://www.haskell.org/learning.html
04:20:22 <shapr> oh, the other one was published 1992
04:20:53 <shapr> I'd still recommend SOE. (and liberal use of #haskell to ask questions :-)
04:21:00 <door> ok :)
04:21:33 <door> hm. btw, do you reckon gymnasium math will be enough to comprehend soe? 
04:21:43 <shapr> door: if you want to just jump right in, look at this: http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
04:22:08 <door> shapr: yeah, i already had a look at that one :)
04:22:14 <shapr> oh, ok
04:22:40 <shapr> iirc, the early SOE questions involve basic algebra
04:22:41 <door> and i've read parts of a tutorial, whatsitsname..
04:22:51 <shapr> YAHT, Yet Another Haskell Tutorial ?
04:23:00 <shapr> or maybe The Gentle Introduction ?
04:23:11 * shapr grabs SOE to look at the questions
04:23:23 <shapr> door: see, if you lived in Boden, I could loan you my copy ;-)
04:23:27 <door> hm, no. twoDznQ.ps and answers :)
04:23:31 <door> darn :)
04:24:09 <shapr> who knows, maybe you'll visit boden after your gymnasium.
04:24:38 <door> nope, not doing civil service :/
04:24:43 <shapr> I've noticed that many Swedish males do that.
04:24:51 <shapr> oh, how'd you get out of lumpen?
04:25:05 <door> bad knee :)
04:25:20 <shapr> ah, ok
04:25:53 <door> it was fairly temporary though, so i was lucky
04:26:00 <shapr> lessee, page 33 talks about using trapezoids to compute the area of a polygon
04:26:14 <shapr> yah, that is lucky.
04:26:48 <shapr> page 44 talks about sierpinski's triangle
04:27:19 <shapr> I think SOE won't be particularly scary when it comes to math.
04:27:25 <ham[let]> shapr do you know of any l-system implementation in haskell?
04:27:37 <door> i suppose i can acquire that sort of information on the net too
04:27:48 <shapr> I'm not exactly sure what an l-system is?
04:28:00 <ham[let]> its an iteraftive fractal system
04:28:07 <shapr> oh
04:28:15 <ham[let]> invented by a guy named lindenmayer who was a biologist
04:28:20 <ham[let]> and mathematician
04:28:21 <shapr> I've seen some mandelbrot code
04:28:32 <ham[let]> mostly used for rendering plants and such
04:28:52 <door> shapr: is YAHT good btw?
04:28:54 <shapr> yah, I know l-system in the context of fractals, but it could mean anything when applied to haskell
04:29:08 <shapr> door: yah, it's okay.
04:29:32 <shapr> could be better
04:29:35 <door> okay, i'll have a look at it then :)
04:29:56 <shapr> actually YAHT got started because I whined on the mailing list that the Gentle Intro felt like a brickbat.
04:30:05 <door> heh
04:30:24 <shapr> then I was one of the contributors, but didn't really write that much, and it lost some momentum.
04:30:38 <shapr> hal daumé III wrote 95% of it
04:30:48 <door> haskell.org should link to it (if it doesn't already do?)
04:31:08 <door> that*
04:31:32 <shapr> it's linked on the learning page
04:32:06 <door> ok, must've missed it then
05:00:35 <ejt> hi
05:00:45 <shapr> g'day joe
05:00:49 <shapr> how's code?
05:01:23 <ejt> slowly, got time for yet another question ?
05:01:47 <shapr> of course!
05:02:18 <shapr> bien sûr, monsieur!
05:02:27 <ejt> I've (eventually) been able to define a multiparameter class and a couple of instnces:
05:02:41 <shapr> uhoh, mptc
05:02:47 * shapr has only vague clues about mptc
05:04:02 <ejt> > class Ord k => Cache c k where
05:04:02 <ejt> >      empty :: c k v
05:04:02 <ejt> >      lookup :: k -> c k v -> Maybe v
05:04:02 <ejt> >      insert :: k -> v -> c k v -> c k v
05:04:26 <ejt> now I'm trying to use it:
05:04:28 <ejt> data (Cache c) => SearchInfo c = SearchInfo {nodeCount :: Int, cache :: c}
05:04:59 <ejt> now obviously the constraint (Cache c) => is wrong, but I don't know what is the right thing ?
05:07:31 * shapr thinks
05:08:15 * shapr looks on the wiki
05:08:28 <darius-> i don't know this stuff, but did you try filling in the k parameter there?
05:10:22 <ejt> ABEval.hs:48: Type variable not in scope: `k'
05:11:07 <ejt> I could nail down the type more, since I know the cache is a Word64 -> Line map
05:11:29 <lummox> i know that this is no haskell question but i don't know where else to ask.. so.. can someone explain me what "guilty pleasures" are?
05:12:05 <darius-> ejt - i mean on both sides
05:12:21 <darius-> lummox - pleasures you feel guilty about!
05:13:26 <lummox> but for me a pleasure is something good.. how can i feel guilty about smth good 
05:13:28 <ejt> darius-: then I get 'type variable not in scope' twice :)
05:14:39 <darius-> heh, sorry
05:14:47 <shapr> lummox: what if stealing made you feel good?
05:15:24 <darius-> ejt - i was thinking i read somewhere about partially-applied mptc's being illegal because they'd make typechecking uncomputable
05:15:35 <lummox> hmm :P .. so such thing is a guilty pleasure?
05:15:49 <darius-> shapr - then obviously stealing is good
05:16:06 <shapr> lummox: I think so, but I'd have to see the whole context to be sure.
05:16:17 <darius-> ejt - i'm probably full of crap though
05:16:35 <shapr> ejt: http://www.haskell.org/pipermail/haskell/2003-June/011980.html
05:16:49 <shapr> that shows MPTC definitions and instances.
05:17:12 <lummox> "[...] A chillingly effective and suspenseful tale, complete with moral ambiguities and guilty pleasures of such vigilante dreams as 'Death Wish'."
05:18:25 <ham[let]> can you add an arrow with a functor to a category in CT?
05:18:33 <darius-> lummox - c hacking is a guilty pleasure sometimes
05:18:35 <shapr> I think they're saying that vigilantes get revenge outside of the law
05:19:11 <lummox> hmm.. i think this book is too high leveled for me :\
05:21:08 <lummox> okay.. i think i have understand it.. .thank u
05:21:19 <lummox> "i understood it"
05:21:59 <lummox> ah.. pfft.. shitty language :[
05:23:13 <ham[let]> ?
05:26:12 <lummox> ..
06:14:10 <shapr> hej ram
06:14:26 <shapr> vad hÃ¤nder?
06:15:22 <shapr> SyntaxNinja: box is online, reconfiguring, hopefully gforge will be back by monday.
06:16:53 <hram> hänger bara...
06:17:07 * shapr switches back to latin-1
06:17:53 <shapr> hram: I've seen you post on the mailing lists, but I don't remember if you've been to #haskell before.
06:17:59 <SyntaxNinja> shapr: sweeeet
06:18:11 <hram> nope, never here before
06:18:30 <hram> shapr: not much of an irc-dude...
06:18:48 <shapr> SyntaxNinja: also, it's possible gforge.haskell.org could be hosted on ScannedInAvian.org, but I'd need to buy another drive
06:19:09 <shapr> hram: well then, welcome to the world of text chat!
06:19:46 <shapr> notable features here are #haskell.se, our handy irc 'bot, lambdabot, written in Haskell, the HaWiki, and haskell-libs.sf.net
06:20:02 <shapr> and of course, all the cool people here on the channel
06:20:21 * SyntaxNinja bows
06:20:48 <SyntaxNinja> shapr: OK, well lets set up a prototype and mess with it first, and we'll cross the 'where to host it' bridge when we get there.
06:21:19 <hram> shapr: what can LambdaBot do? Anything nifty out of the ordinary?
06:21:59 <shapr> lambdabot has a lambda calculus interpreter and a type signature checker.
06:22:09 <shapr> @eval map (\x -> x + 1) [1,2,3]
06:22:10 <lambdabot> [2, 3, 4]
06:22:15 <shapr> @type (!!)
06:22:16 <lambdabot> (!!) :: [a] -> Int -> a
06:22:37 <shapr> lambdabot also has a bunch of other features, some of which aren't so useful
06:23:08 <shapr> lambdabot does have a plugin api, and dynamic runtime reloading of plugins
06:23:27 <shapr> @listcommands dummy
06:23:28 <lambdabot> Module dummy provides the following commands: ["dummy","wiki"]
06:23:35 * shapr quickly edits
06:23:49 <hram> shapr: well thats something most irc-bots cannot do :)
06:24:37 <shapr> lessee if this works...
06:24:44 <shapr> @dynamic-reload dummy
06:24:44 <lambdabot> module reloaded
06:24:48 <shapr> @listcommands dummy
06:24:49 <lambdabot> Module dummy provides the following commands: ["dummy","wiki"]
06:24:56 <shapr> oops, user error
06:25:04 <hram> shapr: but somewhat dangerous.. what if someone does eval infinite loops or something?
06:25:13 <shapr> @dynamic-reload dummy
06:25:13 <lambdabot> module reloaded
06:25:15 <SyntaxNinja> @arr
06:25:15 <lambdabot> Yeh scurvy dog...
06:25:24 <SyntaxNinja> @yow
06:25:24 <lambdabot> I wonder if I should put myself in ESCROW!!
06:25:25 <shapr> @listcommands dummy
06:25:25 <lambdabot> Module dummy provides the following commands: ["dummy","wiki","learn"]
06:25:31 <SyntaxNinja> @learn shapr
06:25:32 <lambdabot> http://www.haskell.org/learning.html
06:25:34 <shapr> ok, now lambdabot has a new command
06:25:35 <SyntaxNinja> ahh
06:25:37 <hram> shapr: Yeah, dynamic loading... written a pile of modules for that stuff...
06:25:39 <shapr> hram: try it
06:25:54 <SyntaxNinja> @wiki LearningHaskell
06:25:55 <lambdabot> http://www.haskell.org/hawiki/LearningHaskell
06:26:14 <shapr> hram: the only sucky part about runtime reloading in GHC is that statically compiled and dynamically loaded types can never meet.
06:26:24 <darius-> ah, but can lambdabot post to the wiki?
06:26:43 <shapr> darius-: no, but the plugin API is very simple, want to volunteer? ;-)
06:26:56 <darius-> perhaps later :)
06:27:00 * shapr grins
06:27:05 <hram> shapr: How do you mean? Dynamics?
06:27:57 <shapr> what's the standard overflow lambda combinator?
06:28:06 <shapr> @eval (\x -> x x)(\x -> x x)
06:28:11 <lambdabot> out of fuel - use @resume to continue
06:28:46 <hram> ah, smart.
06:29:05 <hram> @eval let x = x in x
06:29:06 <lambdabot> (line 1, column 7):
06:29:06 <lambdabot> unexpected "="
06:29:06 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
06:29:58 <shapr> it's not a full implementation of Haskell
06:30:05 <darius-> you oughta implement ed inside lambdabot
06:30:06 <shapr> @get-definition let
06:30:07 <lambdabot> let not defined
06:30:12 <shapr> @get-definition first
06:30:12 <lambdabot> first = head
06:30:12 <darius-> to get the full tty experience
06:30:14 <hram> shapr: So I noticed :)
06:30:44 <shapr> darius-: isn't ed that editor that eats your files? lambdabot has some, uh, 'features' like that.
06:31:06 <darius-> no, no, ed only eats your files when you tell it to.  even if you didn't mean to.
06:31:40 <shapr> hram: the runtime loading in lambdabot uses the same stuff as GHCi
06:32:14 <shapr> hram: afaiu, the static and dynamic parts have separate type tables, and so are unable to talk to each other.
06:32:18 <hram> shapr: yes, of course, but GHCI only has problems with the Dynamics types? No?
06:32:49 <shapr> I think all lambdabot per-plugin state is stored as Dynamics
06:33:03 <hram> shapr: or rather problem arises only when you typeRep stuff?
06:33:13 <shapr> if you know of a better way
06:33:40 <shapr> I'd like to hear it.
06:34:06 <hram> shapr: I don't know a better way since I do not know the problem... :)
06:34:50 <shapr> gotta do some work, bbl
06:35:05 <darius-> later
06:38:14 <hram> @eval [1..]
06:38:15 <lambdabot> (line 1, column 4):
06:38:15 <lambdabot> unexpected "."
06:38:15 <lambdabot> expecting simple term
07:13:16 <Darius> @eval take 10 $ from 1
07:13:16 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
07:13:43 <ham[let]> Darius are you a bit familiar with category theory?
07:13:49 <Darius> a bi
07:13:53 <Darius> +t
07:14:04 <ham[let]> i wonder if i can add an arrow to a category
07:14:12 <ham[let]> with a functor for example
07:14:39 <ham[let]> Darius did you write the interpreter of that lambdabot ?
07:14:58 <Darius> Sure, though since a category is (partially) defined by it's arrows I'd imagine that would be a functor to a different category.
07:15:11 <Darius> and yes
07:15:57 <ham[let]> right but isnt it necessary for a functor to be a morphism? such that you cant add something out of nothing
07:16:14 <ham[let]> Darius is that interpreter code open?
07:17:59 <Darius> Sure, it's distributed with the lambdabot sources.
07:18:36 <Darius> ham[let]; A functor isn't a morphism of the category it acts on.
07:18:38 <ham[let]> which are on the haskell.org site right?
07:19:10 <ham[let]> so a functor can have arguments beside the category itself ? cause i havent seen such a structure yet
07:20:06 <mattam_> Darius: well, a morphism is an endofunctor isn't it ? 
07:20:37 <Darius> mattam: No.  Though perhaps it could represent an endofunctor.
07:21:00 <ham[let]> an endomorphism doesnt nevessarily preserv anything
07:21:06 <ham[let]> it just maps to the same domain
07:21:15 <ham[let]> f: V -> V eg
07:21:17 <Darius> ham[let]: You should be able to find the sources in CVS at haskell-lib.sourceforge.net
07:21:27 <mattam> hmmm, let me check where i read that
07:21:49 <Darius> I'm not exactly sure where to find the most up-to-date lambdabot sources nowadays.  You'd have to ask shapr.
07:21:54 <ham[let]> there are many morphisms
07:22:29 <ham[let]> Darius cause maybe if i am able to read that code i will use haskell for my thesis instead of lisp
07:23:13 <ham[let]> or both :)
07:23:41 <darius-> what's your thesis about?
07:24:22 <ham[let]> i want to integrate graphs, programming and ai
07:24:23 <Darius> I was playing around with the ideas from "Monad Transformers and Modular Interpreters" and similar papers, so the code could likely be greatly simplified.
07:24:44 <ham[let]> that is you kind of write programs with graphs (which are like categories)
07:24:54 <ham[let]> like automatons
07:25:08 <Darius> Though then you wouldn't be able to make it a continuation passing, non-deterministic lambda-calculus interpreter with only minor modifications :P
07:25:16 <darius-> darius - heh
07:25:21 <darius-> that was a neat paper
07:25:22 <ham[let]> but i also allow what i call 'splits' such that you can write things like neural nets
07:25:53 <ham[let]> and mix asyncronous and syncronous processes
07:25:54 <darius-> hamlet - cool
07:26:10 <ham[let]> and i would be able to mix programming languages
07:26:22 <darius-> graphs-like-categories sounds promising since so much of programming is representation and transformations thereof
07:26:27 <ham[let]> since the arrows in these programs are nothing but interpreters
07:26:50 <ham[let]> and i use channels for the nodes which allows me to distribute the programs
07:27:13 * Darius should also modify it to use ST as the current situation is pretty ugly.
07:27:17 <ham[let]> plus program graphs are also data such that you can have higher order programs
07:28:13 <ham[let]> that is why i asked if you can add arrows with a functor
07:28:29 <ham[let]> cause i would need that for stacks and such
07:28:33 <darius-> my CT is shamefully weak
07:28:58 <ham[let]> so is mine :) but i think its a cool thing to at least think about how to get it into there
07:29:07 <darius-> i've been intimidated ever since the first day of class in Intro to Abstract Algebra when the prof marches to the blackboard at 8am and starts writing the CT axioms
07:29:17 <ham[let]> also i want to be able to reason about the programs with the structure
07:29:33 <ham[let]> by graph rewriteing and stuff like casl
07:30:14 <ham[let]> does that sound at least a bit reasonable and interesting?
07:30:38 <ham[let]> i will start at the end of this semester to write at least a small outline
07:30:40 <darius-> it sounds like a lot
07:30:54 <ham[let]> the thesis will just cover the math basis
07:31:08 <ham[let]> and i will implement a neural net and an automaton
07:31:11 <mattam> Darius: ha you're right, nm
07:31:13 <darius-> time to get cracking on category theory then :)
07:32:02 <ham[let]> the only thing i really worry about is an editor
07:32:23 <mattam> in the article i read about CT, the guy says functors are also called arrows
07:32:30 <ham[let]> cause editing and debuggin in these programs will be real fun
07:32:44 <darius-> ed, man! !man ed
07:32:55 <ham[let]> i see functors as arrows in a category of categories
07:32:59 <Darius> I'm no expert, but abstract algebra seems like a branch of math that's especially prone to be overcomplicated by beginners.
07:33:12 <Darius> mattam: That's odd.
07:33:38 <darius-> darius - or fields medalists... i bailed that class pretty quick
07:33:40 <Darius> ham[let]: They are.
07:33:46 <ham[let]> my prof saied to me that you quickly start to do abstract nonsense when you do abstract algebra ;)
07:33:53 <mattam> oh no, that's morphisms, i misread again
07:33:53 <Marvin--> is there a collection of "functional pearl" articles somewhere online?
07:34:02 <Marvin--> I mean, aside from in the JFP
07:34:07 <ham[let]> but i have something to model so its not much of abstraction in there
07:34:20 <mattam> well, that's where +24hours without sleeping leads to
07:34:31 <ham[let]> i even use irc for the channels ;)
07:36:21 <darius-> hm, that suggests an irc programming language for some reason
07:36:25 <ham[let]> hm if i would write the structure of that graph as a haskell file i would be able to check on the syntax of it at least
07:36:48 <ham[let]> i just use irc because i dont want to write a new server app
07:36:56 <ham[let]> and its easy to debug programms then
07:36:57 <darius-> i wonder if anyone's designed a language with lol and rotfl, etc., as keywords
07:37:04 <ham[let]> you just join the channels
07:37:20 <ham[let]> ;)
07:39:40 <ham[let]> did anyone constraint programming with haskell in here?
07:44:11 <hram> darius-: http://ceu.fi.udc.es/SAL/G/2/ROTFL.html
07:46:35 <darius-> argh
07:46:55 <Marvin--> darius-: serves you right
07:47:18 <hram> darius-: a websearch tells me that lots of people want to have "rotfl" in their languages...
07:50:40 <shapr> that's a depressing thought.
07:51:59 <shapr> the latest lambdabot sources should be available from the darcs repo on ScannedInAvian.org (as soon as I sync it with my local repo)
07:52:38 <shapr> I also have a tgz available on my local machine
07:52:59 <shapr> http://shapr.homelinux.net/~shae/lambdabot.tar.bz2
07:57:17 <darius-> damn web, always stealing my ideas
07:57:41 <Darius> darius-:  I was going to make the language "whitespace" but someone stole it first.
07:57:55 <Marvin--> shapr: nitpick: that's not a tgz :P
07:57:59 <darius-> the hegemony of the invisible hand
08:00:24 <hram> shapr: You guys dislike directories or what! (messy lambdabot)
08:00:58 <Marvin--> shapr: oh, btw, Koen was not entirely unhappy about my writings ;)
08:01:22 <Marvin--> I guess that qualifies as "progress"
08:03:06 <Marvin--> now where's Igloo when I need him :)
08:03:37 <Igloo> Search me
08:03:51 <Marvin--> whee
08:05:10 <Marvin--> Igloo: remember my old let floating problem? I finally picked up that thread again and rewrote the code using Data.Generics
08:05:19 <Igloo> Ah, yes
08:06:28 <Marvin--> now, instead of combining a transformation and a query, I use monadic transformations and tack on a writer monad because writer monads are cute *cough*
08:06:53 <Marvin--> but it feels like I'm using a silly amount of helper functions
08:08:22 <Marvin--> I'm wondering if I could merge some stuff *ponder*
08:08:49 * Igloo can't visualise this
08:09:24 <Marvin--> well, duh. I'm just cleaning up the code a bit, there were a bit too many f:s, g:s and h:s
08:09:55 <Marvin--> http://sjogren.ost.sgsnet.se:8080/Let.hs
08:12:00 <Marvin--> I guess, strictly speaking, a reader monad isn't really needed either
08:12:19 <hram> Marvin--: I wouldn't call that a silly amount anyhow....
08:12:22 <Igloo> This is lifting every let to the top level, right?
08:12:36 <shapr> hram: actually lambdabot was better nested in directories, but it made the nested module loading really painful
08:12:38 <Marvin--> Igloo: right
08:12:55 <shapr> hram: feel free to fix anything you see in lambdabot and send me diffs :-)
08:13:25 <shapr> hram: or if you have questions about the two plugin APIs, I'd be happy to write up something resembling documentation.
08:13:26 <Marvin--> hram: no, I guess not, you should've seen the old code with a dozen mutually recursive functions and explicit state passing  :-)
08:15:11 <hram> shapr: perhaps you should use my module for dynamic loading that used hierarchical libraries?
08:15:26 <hram> "use" not "used"...
08:15:52 <shapr> hram: heck yeah, where is it?
08:16:55 <hram> shapr: www.dtek.chalmers.se/~d00ram/dynamic
08:17:35 <hram> quite untested and supposed to be put into upcomming HSP-implementation so it might not suit all needs...
08:17:45 * Igloo doesn't think anything is crying out to be inlined, but I think you want lots of comments if this will be seen by people not familiar with how it works
08:17:51 <shapr> hram: is HSP using HWS-WP?
08:18:08 <Marvin--> Igloo: and your old version of it wouldn't? ;)
08:18:17 <Marvin--> Igloo: but yeah, you have a point
08:18:24 <hram> Not the implementation I'm refering to.
08:19:26 <Igloo> But my old version was for you, and you'd spent longer looking at it than me  :-)
08:19:28 <Marvin--> cute tricks aside, what I really like about Data.Generics is that changing your data types doesn't mess up 90% of your code, only 10%
08:20:57 <hram> shapr: Marvin--: hear, hear! (just sitting with a small project that needs some ~500 type signatures changed (but no code) to compile)
08:21:00 <Marvin--> Igloo: this code is looking more complicated than it has to, what I'm trying to do is figure out if I can do both the renaming and the floating at the same time... if I don't, it'll be two completely separate functions (one using runWriter and one using runReader) and it'll be much clearer
08:21:20 * hram cannot irc!
08:21:31 <Igloo> Ah, I see
08:22:07 <Marvin--> the floating is almost a oneliner
08:22:55 <shapr> hram: is this your first day using IRC?
08:23:10 <Marvin--> you'd have  f (ELet ds e) = tell ds >> return e ; f e = return e ; float = runWriter . everywhereM (mkM f)  or something like that
08:23:42 * shapr swears at Zope
08:23:45 <hram> No, but I use it quite sporadic.
08:23:51 <shapr> oh, ok
08:24:02 <Igloo> 2 completely separate passes would make it easier to explani/understand
08:24:39 * shapr cuts it off at the first pass
08:24:59 <Igloo> Intuitively I can't see why you shouldn't be able to do it all in one, but I can't remember exactly how it all works now to be sure
08:26:25 * shapr reads DynamicLinker Haddocks
08:28:16 <Marvin--> Igloo: I think it comes down to bottom-up vs top-down... if the declarations are floated before renamed, you screw things up
08:28:54 <shapr> hram: oh, did you see the problem with typeRep in lambdabot?
08:29:24 <Igloo> You're essentially doing   everywhere foo . everywhere bar  right? Which intuitively is the same as everywhere (foo . bar)
08:29:42 <hram> shapr: No, haven't looked to much. A pointer to it and I'll look now.
08:30:56 <shapr> hram: it's all about "data ModuleState = forall a. (Typeable a) => ModuleState a" so that IRCRWState {} can have "ircModuleState :: FiniteMap String (IORef ModuleState),"
08:31:33 <shapr> lines 56 and 165 in IRC.hs
08:32:29 <hram> just about now I feel the need for a program that converts Haskell-code to nice flowcharts...
08:33:37 <shapr> hram: BaseModule.hs and IRC.hs are the essence of lambdabot 
08:35:50 <shapr> flowfully, lambdabot is a typeclass where you can hook callbacks into any irc signal. statefully it's a r/w monad IRCRWState, holding a r/o monad, IRCRState, both of those are state monad transformers holding records
08:37:09 <Marvin--> Igloo: for everywhere, perhaps, but for everywhereM? I dunno...
08:38:22 <Igloo> I could be wrong. Regardless I think 2 passes is nicer unless you really need that extra efficiency
08:39:12 <Marvin--> yeah, I know, efficiency isn't an issue, I'm just trying to figure out if there's an elegant solution to it all :)
08:39:56 <hram> shapr: so the problem really lies in that all module's states are passed to every module?
08:41:21 <shapr> hram: hm, maybe so. I hadn't thought of that.
08:41:33 <shapr> hram: could it be done differently?
08:42:11 <hram> shapr: that I will tell you tomorrow :)
08:42:15 <shapr> heh, ok :-)
08:42:38 * shapr thinks about that
08:45:11 <hram> shapr: you have a link to the (ghc-bugs?) message about static/dynamic type problems?
08:47:52 <shapr> it's been reported separately in relation to GHCi
08:50:30 <hram> shapr: yes, but I need to refresh my memory on the finer details (without consulting the source...)
08:51:01 <shapr> hram: the problem as I've seen it before is that the only way to store heterogenous types is to dynamicize them.
08:51:38 <shapr> or put them into a tuple, but in that case, each module would have to change the type signature of the tuple somehow. (maybe TH?)
08:53:48 <hram> shapr: Yes, but the question I want an answer to is whether it is dangerous to use them with dynamic loading... :)
08:55:34 <shapr> it is, but the only details I remember are that the static and dynamic parts each have their own type table
08:56:47 <hram> shapr: I really meant "... with lambdabot" too :) Only the dynamic side fiddles with the state as far as I can see and then it should be safe. But perhaps each dynamic module has its own table?
08:57:15 <hram> shapr: answer to myself: no, why should the be separte for each module...
08:57:33 <shapr> the @more command has been the only problem
08:58:29 <hram> @more
08:58:41 <shapr> @jargon hacker
08:58:44 <lambdabot> *** "hacker" jargon "Jargon File (4.3.0, 30 APR 2001)"
08:58:44 <lambdabot> hacker n. [originally, someone who makes furniture with an axe] 1. A
08:58:44 <lambdabot>    person who enjoys exploring the details of programmable systems and how
08:58:44 <lambdabot>    to stretch their capabilities, as opposed to most users, who prefer to
08:58:45 <lambdabot>    learn only the minimum necessary. 2. One who programs enthusiastically
08:58:47 <lambdabot>    (even obsessively) or who enjoys programming rather than just theorizing
08:58:49 <lambdabot>    about programming. 3. A person capable of appreciating {hack value}. 4.
08:58:51 <lambdabot>    A person who is good at programming quickly. 5. An expert at a
08:58:53 <lambdabot> [29 @more lines]
08:59:03 <shapr> @more
08:59:03 <lambdabot> wrong type (<<[] Char>>) in ModuleState
08:59:14 <Marvin--> whoops
08:59:40 <hram> shapr: so, the problem occurs when they want to talk with eachother...
09:01:37 <shapr> ?
09:01:37 <shapr> @more
09:01:37 <shapr> hmm
09:01:37 <shapr> fooey, the ipv6 server died again
09:02:02 <hram> shapr: well, really the problem is that a part of the dynamic more-module isn't dynamic...
09:02:44 <shapr> hram: yes, that is the problem.
09:03:30 <shapr> the MoreModule incorporates an evil hack in ircPrivmsg
09:05:16 <shapr> I wonder if BaseModule.hs could be loaded dynamically...
09:07:00 <hram> shapr: why shouldn't it be possible?
09:07:21 <SyntaxNinja> is there a way to bind a value within a list comprehension?  I have a function like this:
09:07:27 <SyntaxNinja> [(l, f a b c d e g) | complicatedExp, isJust $ f a b c d e g]
09:07:36 <SyntaxNinja> which I could write:
09:07:37 <SyntaxNinja> [(x,y) | (x, Just y) <- [(l, f a b c d e g)
09:07:37 <SyntaxNinja> 			 | complicated expression here] ]
09:07:46 <Heffalump> yes, you can just do that, can't you?
09:07:51 <SyntaxNinja> I'd like to bind the f a b c d e f to something
09:07:54 <SyntaxNinja> yeah, but it's ugly
09:07:58 <Heffalump> any binding construct can be a pattern match
09:08:01 <Heffalump> so what do you mean?
09:08:18 <Igloo> You can have lets in list comprehensions
09:08:18 <shapr> hram: I don't know, maybe it is, I'll try it a bit later.
09:08:50 <SyntaxNinja> [(l, y) | let y = f a b c d e g in complicatedExp, isJust y] ?
09:08:51 <Heffalump> is this the MoreModule dynamic loading thing?
09:09:11 <Igloo> let, not let...in
09:09:25 <Marvin--> er, is complicatedExp a generator, or what?
09:09:26 <shapr> Heffalump: yes, same old. question is, can BaseModule be dynloaded?
09:09:36 <Heffalump> errm, dunno. What does it do?
09:09:42 <shapr> everything?
09:09:46 <Heffalump> I could download the code onto my laptop and have a look on the train.
09:10:05 <shapr> I could just try it...
09:10:14 <Marvin--> hrm, where's the hlibs darcs repo again?
09:10:22 <Igloo> Prelude> [ y | let x = 6, y <- [x, x+1, x+2] ]
09:10:22 <Igloo> [6,7,8]
09:10:25 <SyntaxNinja> Marvin--: it's going to give us the values for a b c d e g
09:10:33 <SyntaxNinja> Igloo: ahh :)
09:10:51 <shapr> Marvin--: offline until tomorrow, but I have a handy tbz of lambdabot, and can tbz everything else
09:10:54 <Igloo> (Oh, and you can use x on the LHS)
09:11:00 <Marvin--> shapr: ah, nah, never mind
09:11:14 <shapr> Marvin--: why do you ask?
09:11:33 <SyntaxNinja> Igloo: cool. glad I asked:)
09:11:44 <Marvin--> shapr: because I just ran darcs pull and it complained :)
09:11:50 <shapr> heh, good point
09:12:16 <shapr> the drive died and I just got the new box online this morning, it's not configured yet.
09:15:46 <Darius> SyntaxNinja: List comprehensions have much the same syntax as do-notation since they are almost identical.
09:16:20 <Marvin--> exactly
09:18:53 <Heffalump> in fact you used to be able to use list comprehension syntax with any MonadPlus (or was it MonadZero)
09:19:01 <Heffalump> but they thought it made the type errors too confused and removed this
09:19:22 <Heffalump> shapr: tbz?
09:19:36 <Marvin--> it isn't available with -fglasgow-exts any more?
09:19:53 <shapr> Heffalump: http://shapr.homelinux.net/~shae/lambdabot.tar.bz2
09:20:01 <SyntaxNinja> Darius: that's a scary thought... I don't really grok how they are similar to do notation?
09:20:14 <Heffalump> that's the only current version of lambdabot sources?
09:20:19 <Marvin--> SyntaxNinja: lists are monads too, you know
09:20:22 <SyntaxNinja> because you bind things in each of the comma-separated things?
09:20:33 <shapr> Heffalump: I have a local darcs repo, but it's not remotely reachable
09:20:36 <SyntaxNinja> Marvin--: I've heard that, but never really understood how to use it to my advantage ;)
09:20:57 <shapr> Heffalump: I need to sync sf.net and the darcs repo
09:21:04 <Heffalump> cvsps is the way to go
09:21:16 <Heffalump> does the darcs repo have more patches in it than sf.net?
09:21:23 * SyntaxNinja us using arch. in fact, I have a repo that I put online yesterday for you guys to check out Real Soon Now :)
09:21:38 <Marvin--> SyntaxNinja: nondeterminism!
09:21:46 <Marvin--> backtracking
09:21:58 <SyntaxNinja> oh my
09:21:59 <shapr> Heffalump: yes, the darcs repo has some patches that aren't in sf.net
09:22:05 <SyntaxNinja> Marvin--: where can I read about this?
09:22:28 <Marvin--> SyntaxNinja: for the list monad, mzero = [], so any "branch" of a computation that fails will sort of silently disappear in the grand scheme
09:22:36 <Marvin--> SyntaxNinja: hmm, good question
09:22:44 <Heffalump> but that tarball is an up to date copy?
09:22:45 <SyntaxNinja> I think I'm kinda stuck on monads as something to store state and act like imperative code
09:22:53 <SyntaxNinja> and I'm afraid I'm making the same mistake with arrows
09:22:54 <Igloo> I'd be tempted to drop CVS support, or just haveb a CVS frontend if such a thing exists
09:23:11 <SyntaxNinja> you guys should all read the arch tutorial today, btw.
09:23:18 <SyntaxNinja> @google arch meets hello world
09:23:18 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands"
09:23:23 <SyntaxNinja> you get the idea :)
09:23:27 <Heffalump> SyntaxNinja: why today?
09:23:30 <phubuh> http://regexps.srparish.net/tutorial-tla/arch.html
09:23:34 <phubuh> arch is nifty
09:23:44 <Heffalump> I prefer darcs' patch-oriented view
09:23:47 <SyntaxNinja> Heffalump: because arch is cool, and it's an easy read
09:23:56 <shapr> Heffalump: that tarball might be missing the anti-det patch, but not much else
09:24:21 <Igloo> Ugh, GFDL, and Invariant sections no less!
09:24:32 <Marvin--> SyntaxNinja: anyhoo, a monadic binding   x <- m   is equivalent to a list comprehension generator  x <- m
09:24:33 <SyntaxNinja> Heffalump: I don't really grok darcs, but arch is pretty heavily into patches as well. in fact colin walters wrote a "patch queue manager" for developers who get a lot of patches
09:24:34 <Marvin--> Igloo: eww
09:24:51 <Igloo> YA reason to prefer darcs over arch  :-)
09:25:02 <SyntaxNinja> Igloo: why?
09:25:06 <SyntaxNinja> oh, the license?
09:25:07 <Igloo> Why what?
09:25:08 <Igloo> Yes
09:25:30 <Marvin--> don't tell us you've missed all the flaming between Debian and FSF over the GFDL? :)
09:25:39 <shapr> I missed it, can I get a recap?
09:25:45 * shapr dons his asbestos underwear
09:25:53 <Heffalump> anti-det?
09:26:07 <SyntaxNinja> if I had to put my money on a vc system to become the new Free "Standard", i'd put it on Arch, not darcs.
09:26:12 * Igloo can't remember much about either now, but licences and encouraging wider spread use of Haskell software are 2 good reasons by themselves in my opinion
09:26:17 <Heffalump> yeah, cos arch has more of a following
09:26:21 <SyntaxNinja> but that's probably more of the activity I see from the community
09:26:24 <SyntaxNinja> Marvin--: no, I didn't miss it.
09:26:26 <Heffalump> but darcs is Haskell and isn't maintained by an arrogant git
09:26:40 <shapr> Heffalump: I added a filter for \r so that @eval "\CRPRIVMSG #haskell :foo" would no longer work.
09:27:01 <Heffalump> ah :-)
09:27:03 <Heffalump> no fun
09:27:18 <shapr> I was hoping it would encourage det to look for other holes, as I'm sure they exist.
09:27:22 <SyntaxNinja> Heffalump: what encoding was that message you just sent?
09:27:29 <Darius> SyntaxNinja: Specifically the connection between list comprehensions and do-notation: [f x | a <- as,let xs = h a,x <- xs,isFoo x] == do a <- as;let xs = h a;x <- xs;guard (isFoo x);return (f x)
09:27:31 <Heffalump> message I sent where?
09:27:47 <SyntaxNinja> about one minute ago, the message you sent to the channel
09:28:01 <Heffalump> no idea, ISO-8859-1 I guess
09:28:01 <SyntaxNinja> gaim just tells me it can't display it so I should change my encoding
09:28:07 <Heffalump> but it didn't have any non-ASCII characters, did it?
09:28:12 <Heffalump> you sure that wasn't shapr?
09:28:22 <SyntaxNinja> (12:26:26) Heffalump: (There was an error converting this message.  Check the 'Encoding' option in the Account Editor)
09:28:30 <SyntaxNinja> OK gotta run. ttyl
09:28:37 <Heffalump> the one about darcs being in Haskell?
09:28:38 <Igloo> It didn't have a £?
09:28:41 <shapr> I'd like to see a comparison of the way darcs and arch think of repositories
09:28:43 <SyntaxNinja> Igloo: funny :)
09:28:55 <Igloo> Oh, you mean IRC, not e-mail
09:28:59 <SyntaxNinja> don't talk about VC until I get back
09:29:00 <SyntaxNinja> :)
09:29:04 * SyntaxNinja &
09:29:05 <Heffalump> when will you be back?
09:29:24 <shapr> I know how darcs works, but how does arch work?
09:29:57 <phubuh> it thinks of a repository as a first revision and a set of patches, published in any way
09:30:08 <phubuh> http, ftp, heck, e-mail
09:30:23 <shapr> sounds like darcs to me
09:30:27 <Heffalump> doesn't it insist on naming every revision, though?
09:30:34 <phubuh> no
09:30:41 <Heffalump> oh, right.
09:30:51 <shapr> if they're the same, I'll choose the one that uses Haskell :-)
09:30:52 <Marvin--> phubuh: tell me about this "heck" publishing, it sounds interesting :)
09:31:03 <Heffalump> the thing I didn't like about what I saw of it was it seemed to have this rigid sequence of releases names in each branch
09:32:00 <phubuh> the first revision is called base-0, the patches are called patch-n, where n is just an integer incremented for every patch
09:33:04 <Heffalump> oh, I guess from that pov the names of the revisions are just the names of patches and nothing more.
09:33:38 <shapr> oh, didn't zooko do an arch/darcs comparison?
09:33:54 <shapr> yes he did...
09:34:14 <shapr> http://zooko.com/revision_control_quick_ref.html
09:34:14 <phubuh> darcs seems pretty close to arch
09:34:32 <shapr> notice the last link on that page
09:35:24 <Igloo> Is "a little slow on large projects" still true?
09:35:35 <phubuh> You mention that the manual says it's "a little slow on large projects",
09:35:35 <phubuh> and alas that is still true.  However, since I wrote that I have speed
09:35:35 <phubuh> darcs up by perhaps a factor of ten, so progress is being made, and I am
09:35:35 <phubuh> hopeful.  Actually, I think there may have been a speed regression
09:35:35 <phubuh> recently, at least for the linux kernel, which is my test case of a large
09:35:37 <phubuh> project.  Lazy languages sure can make it tough to track down efficiency
09:35:40 <phubuh> problems.
09:35:42 <phubuh> from http://www.abridgegame.org/pipermail/darcs-users/2003/000143.html
09:36:05 <shapr> last I heard it took several hours to import the linux kernel sources, but I don't remember when that was.
09:37:12 <Igloo> Does darcs build with nhc98?
09:37:14 <Darius> hram: (Reading the AFP paper related to dynamic loading) Couldn't you simply use unsafePerformIO to get a global "dynamic loading" lock (MVar).
09:37:14 <shapr> it looks like the most recent patch in arch depends on all the previous patches, but that darcs patches can slide past other patches
09:37:51 <shapr> phubuh: do you know if that's so? can I pull later arch patches without getting some earlier patches?
09:38:08 <phubuh> I don't think so, no
09:38:32 <phubuh> but I might be wrong
09:38:46 <Marvin--> whoa, DuckTales on TV
09:39:50 <phubuh> !!! in Sweden?
09:39:56 <Heffalump> AFP paper?
09:40:18 <Marvin--> phubuh: SVT1
09:40:33 <phubuh> whee
09:40:52 <Marvin--> heh
09:41:07 <Igloo> SVT?
09:41:12 <shapr> from a non-Haskell-bias standpoint, 'cherry-picking' of patches probably isn't much of an advantage over arch, though I sure would like to have it for the linux kernel.
09:41:18 <Marvin--> Igloo: Sweden's national television
09:41:30 <shapr> what's the V stand for?
09:41:37 <shapr> Sverige V Television?
09:41:45 <Marvin--> heck if I know
09:41:46 <dennisb> SVerige
09:41:50 <shapr> oh
09:41:51 <Igloo> Is that what you get if you press 1 on the remote control?
09:41:54 <Marvin--> ST was too boring, I guess
09:42:05 <Marvin--> Igloo: ... yes, if programmed correctly, I suppose? :)
09:42:16 <Igloo> Under normal programming I mean  :-)
09:42:18 <shapr> can anyone think of cases where commutability of patches is a big advantage?
09:42:27 <Heffalump> any merging problem
09:42:34 <shapr> hm, good point.
09:42:42 <Heffalump> it's absolutely essential for doing it correctly
09:42:50 <Heffalump> I'm sure arch does it under the hood, or in star merge somewhere.
09:42:51 <Igloo> Merging fixes to stable branches is the obvious one
09:43:06 <Heffalump> But darcs comes out up front in the manual and talks about the underlying algebra.
09:43:12 <Heffalump> I don't like his notation, but at least he does it
09:43:38 <Marvin--> heh
09:46:58 <shapr> from what David says in the url phubuh pasted, you can pull arch patches in any subset of a repo, but it can't calculate the dependencies.
09:47:00 * shapr doesn't understand
09:48:01 <Igloo> Has darcs got a stable repository format now?
09:48:24 * Igloo tries to resist being drawn into the temptation to try to package it for sarge
09:48:35 <shapr> I don't think it's stable yet, but convert-repo is always included :-)
09:48:57 * shapr reads arch docs for comparison
09:49:28 <Igloo> Hmm, well, I certainly don't have the time to handle updates nicely ATM
09:50:59 <shapr> ok, in the case of cherry picking changes, darcs handles dependencies itself, with arch, it depends on "clean changesets" as mentioned here: http://regexps.srparish.net/tutorial-tla/cherrypicking-changes.html#Cherrypicking_Changes
09:52:05 <shapr> so darcs is better if you want to pull random patches from other forked repos
09:53:17 <shapr> the advantages of arch over darcs are multiple implementations, community momentum, anything else? (emacs support? :-)
09:55:13 <shapr> Heffalump: hram's SmartLinker appears to do the BotConfig.getFileRequires stuff itself
09:55:20 <Heffalump> sorry?
09:55:39 <shapr> http://www.dtek.chalmers.se/~d00ram/dynamic/
09:55:54 <shapr> http://www.dtek.chalmers.se/~d00ram/dynamic/haddock/SmartLinker.html#v%3AaddDependency
09:56:22 <Heffalump> oh, a smart linker, cool.
09:56:39 <Heffalump> the lambdabot dynamic loading should definitely be ported to that
09:56:56 <Heffalump> (unless someone did this already?)
09:56:56 <shapr> okay
09:57:49 <shapr> no, I didn't know about it before today.
09:58:43 <phubuh> it's cool that darcs has a notion of pushing to a server by just e-mailing the patches -- with arch, unless you use shared repositories, I think you must coordinate stuff like that yourself
09:59:14 * Heffalump wgets it
09:59:58 <phubuh> actually, mailto:foo@bar might be a valid archive mirroring target
10:01:03 <shapr> speaking of which, I hope I can recover the hlibs GPG pub keyring from the old drive
10:02:14 * phubuh considers using darcs instead of arch
10:02:36 <shapr> what's crisp loading?
10:03:02 <Igloo> Hurrah!
10:04:08 <Darius> shapr: It explains it later.
10:04:14 <shapr> ok
10:04:37 <Heffalump> does the smart linker build on o3's linker, or start again?
10:05:16 <shapr> Heffalump: I got the impression that the SimpleLinker was very close to o3's linker
10:05:29 <shapr> aha, crisp loading!
10:05:34 <shapr> heck yeah, I want that.
10:06:12 <Darius> Both (o3's and DynamicLinker not SmartLinker) are supposedly little more than wrappers around the functionality provided by GHCi
10:08:56 <Heffalump> true
10:12:13 <Marvin--> hey, I just realized it's Friday today
10:12:25 <Heffalump> WEEKEND!
10:12:37 <Heffalump> I get to see my girlfriend, which is good.
10:12:44 <shapr> yay!
10:12:50 <Marvin--> eh, the week days kinda blur together when all you do is work on a stupid degree project every day
10:13:31 <Marvin--> good for Heff, though :)
10:14:22 * Heffalump goes to get on a train and do so
10:15:45 <shapr> have a good weekend Heffalump!
10:25:08 <hram> Darius: SmartLinker/DynamicLinker are just as you say little more than wrappers around GHCi.
10:25:39 <hram> Darius: Hard to do it otherwise without ending up with a new GHCi...
10:26:09 <Darius> Well, SmartLinker is a little bit more than just a wrapper.
10:27:13 <Darius> Did you see my earlier question about locking?
10:27:17 <hram> Darius: Well, yes, but it doesn't acctually find dependencies by itself as would be best :)
10:27:24 <hram> Darius: No,
10:29:39 <Darius> <Darius> hram: (Reading the AFP paper related to dynamic loading) Couldn't you simply use unsafePerformIO to get a global "dynamic loading" lock (MVar)?
10:30:55 <hram> Yes, I see no problem with that.
10:33:10 <golya> Hi! Just a dummy Q: any practical haskell tutorials? I'm looking for sg. like "haskell for dummies", which tells me HOW to use the language. Theoretical papers are ok, but I'd like to USE it...
10:33:48 <shapr> @learn
10:33:49 <lambdabot> http://www.haskell.org/learning.html
10:33:52 <hram> golya: total beginner?
10:34:22 <golya> hram: not the programming part I'm the beginner, but I don't know how to try things out.
10:34:23 <shapr> golya: http://kungens.kemi.fi/~shae/src/haskell/Demo.hs
10:35:32 <hram> Darius: We'll perhaps I should rewrite it and use a single "unsafe:d" state. But I really do not like unsafePerformIO :)
10:35:36 <golya> So in haskell I must write a hs file and load it and then use it, no interactive environment? (I know hugs, but it seems to me, that I must edit external files...)
10:36:03 <hram> golya: You can use hugs and ghci in an interactive manner.
10:36:21 <Darius> hram: You could simply use a MVar () as a lock, if you don't want to stick the whole state in it.
10:37:01 <hram> Darius: Yes, but that wouldn't help really would it? Then I'd just have to put the state somewhere else...
10:38:20 <shapr> golya: you can define functions interactively, but for larger functions it's easier to define functions in a file and load them.
10:38:25 <Darius> I'm just responding to the comment in the paper that you couldn't guarantee only one MVar is made, thus thread safety and likely correctness is less guaranteed.
10:39:03 <SyntaxNinja> back :)
10:39:04 <shapr> golya: I usually write small functions, load them into GHCi, then try them out.
10:39:19 <shapr> golya: also, you can import lots of the system libraries and try them out
10:39:36 <shapr> @eval map (\x -> x + 1) [1,2,3]
10:39:36 <lambdabot> [2, 3, 4]
10:39:52 <shapr> SyntaxNinja: the discussion is over!
10:39:54 <Darius> golya: Also many (probably most) Haskell programmers are multi-"lingual" so typically use general purpose editors (vim, emacs, etc) as an IDE and have GHCi/Hugs running in a different window/buffer.
10:40:05 <shapr> SyntaxNinja: actually, darcs does have one advantage over arch
10:40:17 <golya> So, eg in hugs, how to define add1 fun, which returns parameter + 1?
10:40:36 <SyntaxNinja> shapr: wha'ts that
10:40:56 <SyntaxNinja> shapr: say something w/ strange Swedish letters so I can test my encoding :)
10:40:59 <shapr> SyntaxNinja: getting patches out of order without managing dependencies yourself
10:41:26 <hram> Darius: Well I think your suggestion about just putting it all in a caf is a good solution to that problem and using MVar () really doesn't do any good.
10:41:26 <shapr> SyntaxNinja: jag måste sover nu.
10:41:34 <SyntaxNinja> seems to work
10:41:40 <SyntaxNinja> dependencies between patches?
10:41:43 <shapr> SyntaxNinja: want me to switch to utf-8 and try it?
10:41:47 <SyntaxNinja> nah
10:41:49 <shapr> ok
10:41:51 <golya> Darius: It's ok, I've no fear from vim, I'm using it, but for example ruby has an interactive interpreter...
10:42:15 <Marvin--> SyntaxNinja: men det hÃ¤r Ã¤r utf-8
10:42:28 <Darius> You can put 'add1 a = a + 1' in a file and load it (some module stuff may be necessary) or you can type 'let add1 a = a + 1 in <some expression using add1>' if you only need it temporarily.
10:42:45 <shapr> SyntaxNinja: http://zooko.com/revision_control_quick_ref.html has a link at the bottom, which led me to 
10:42:50 <SyntaxNinja> Marvin--: it came out at least :)
10:42:54 <Darius> GHCi also allows you to write 'let add1 a = a + 1' and add1 will be available from that point on (until you reload).
10:42:54 <shapr> <shapr> ok, in the case of cherry picking changes, darcs handles dependencies itself, with arch, it depends on "clean changesets" as mentioned here: http://regexps.srparish.net/tutorial-tla/cherrypicking-changes.html#Cherrypicking_Changes
10:43:24 <hram> golya: I.e. you can do most stuff in hugs, just not definitions...
10:43:39 <Darius> hram: You just have every function that needs to be thread-safe takeMVar the MVar before doing anything then put it back when done.
10:44:07 <Darius> You can keep the state in an IORef.
10:44:33 <Darius> This should also allow concurrent accesses to the state when they don't need to be protected from each other.
10:44:36 <SyntaxNinja> shapr: IC
10:44:43 <hram> Darius: Yes, and that is pretty much what I do now. But I still need the state and that I get too in the process.
10:45:18 <hram> Darius: So moving the state fully to a caf is better than passing it around...
10:45:30 <shapr> SyntaxNinja: that's a big benefit if you have multiple projects forked from a common base
10:46:10 <shapr> and would be beneficial in cases like the linux kernel where you don't always want to pull all the patches.
10:46:23 <SyntaxNinja> right
10:46:31 <SyntaxNinja> how does darcs fix this?
10:47:29 <shapr> darcs knows which patches commute
10:47:40 <shapr> and iirc, can split a single patch into smaller patches where parts of it can commute
10:49:03 <hram> Darius: Well you always want them to be protected from eachother...
10:51:05 <Darius> Two operations that just consult the state shouldn't need to be protected from eachother.  But there is little point in allowing more concurrency as this is unlikely to be a bottle-neck.
10:51:09 <shapr> SyntaxNinja: it's worth reading the theory of patches if you want to really understand how darcs does it: http://www.abridgegame.org/darcs/manual/node7.html
10:51:25 <SyntaxNinja> shapr: I will read that sometime :)
10:51:26 <SyntaxNinja> I swear.
10:52:21 <shapr> heh, ok
10:52:33 <shapr> I warn you though, you may want to switch to darcs after that :-)
10:52:39 <hram> Darius: Well, I only have one that only reads the state so...
10:53:20 <Darius> golya: On a side note, despite what www.haskell.org/implementations.html says, Hugs would be my last suggestion as an implementation for beginners.
10:53:39 <Darius> (well, at least beginners with former programming experience in other languages)
10:54:02 <Darius> hram:  Yeah, that's also an issue ;)
10:54:35 <ejt> anyone know what the compose (.) equivalent is in ML ?
10:55:14 <Igloo> o
10:55:17 <hram> Darius: But thanks for the great suggestion. hacking away :)  (and I will spend some time on lambdabot I think)
10:55:29 <Igloo> (spit spit)
10:56:04 <shapr> hram: want write access to the darcs repo?
10:56:23 <shapr> Igloo: heheh
10:57:30 <hram> shapr: Well, lets wait with that for a while until I've produced something :)
10:57:37 <shapr> ok, fair enough
10:59:47 <hram> Someone using emacs that has fixed the evil let in-bug in indentation?
11:00:12 <shapr> not that I know of
11:00:34 <shapr> I wish the ghci prompt regex would get fixed
11:01:06 <hram> the todo-list keeps getting bigger :)
11:01:11 <phubuh> ejt, let compose f g x = f (g x) -- at least in o'caml, there is no preludian or builtin operator for functional composition
11:01:13 <shapr> I have a fix for the prompt regex
11:01:16 <phubuh> preludic?
11:01:23 <shapr> phubuh: standard?
11:01:33 <phubuh> well, ok :-)
11:02:20 <hram> f.g?
11:03:29 <ejt> am I going to regret trying to learn ocaml after haskell ?
11:03:46 <Smerdyakov> No
11:04:00 <shapr> don't do it!
11:04:05 <shapr> save yourselves!
11:04:26 <ejt> I thought I'd try and write the same program in both, and then make an educated choice
11:04:36 <shapr> oh, that's a good idea.
11:04:37 <ejt> so far I miss Haskell
11:04:50 <shapr> Haskell has typeclasses also.
11:04:53 <hram> ocaml at least has a good compiler according to benchmarks...
11:04:54 <Smerdyakov> You won't if you measure runtime efficiency.
11:05:12 <ejt> shapr: (which you don't know how to use ;)
11:05:28 <shapr> ejt: no, that was only the multiparameter typeclasses :-)
11:05:45 <Igloo> I prefer Haskell syntax. I don't know enough of ML things like functors to know which feature set I prefer, but I do like purity and laziness.
11:06:17 <ejt> to be honest I think mptc are going to be the norm for me, and I couldn't get them to work :(
11:06:21 <Smerdyakov> I think it's a tough choice comparing ML's module system and Haskell type classes.
11:06:27 <ejt> hence the high frustration levels
11:06:36 <Smerdyakov> I think you lose something nontrivial by leaving out either, though.
11:06:46 * Igloo suspects Haskell would come out on top for me if I was fully informed, but it would be more clear cut if its module system was redone
11:07:52 <Smerdyakov> Is anyone here thinking of going to the Software Security Summer School at U. Oregon this summer?
11:08:47 <ejt> I think the biggest problem is going to be switching from Lazy thinking to strict
11:36:27 <Marvin--> ejt: what was your problem with mptc?
11:44:09 <ham[let]> how come that haskell is on the 19th place at this language shoot out? and ml is at the 2nd?
11:45:12 <Smerdyakov> Because ML is better suited to efficient compilation.
11:45:27 <Smerdyakov> (strict vs. lazy)
11:46:03 <Smerdyakov> And this inherent superiority motivates compiler writers to try harder to make kick-ass optimizing ML compilers :)
11:46:04 <Igloo> Lazy IO going via [Char] is probably a significant factor
11:47:25 <Darius> Because if the examples I've seen of Haskell programs in the shootout are representative, they are poorly written Haskell code or at least misleading.
11:48:25 <ham[let]> ok thanks
11:58:02 <Darius> A particularly pointed example is: http://www.bagley.org/~doug/shootout/bench/ary3/ary3.ghc
12:00:09 <Marvin--> ah yes, "functional languages aren't as good as imperative languages at doing imperative things"?
12:01:22 <Darius> Which makes -thousands- of arrays.  A while back I rewrote it to use STUArrays and the result was less than two (or maybe three) times slower than C.
12:01:44 <Igloo> Why didn't you send it in?
12:02:37 <Darius> http://www.bagley.org/~doug/shootout/news.shtml
12:02:57 <Igloo> Oh, that sucks
12:03:26 <Marvin--> wow, two years ago
12:04:13 <Igloo> Could submit it to http://dada.perl.it/shootout/ - I'm not sure if he does just Windows or both
12:04:28 <Igloo> Hmm, looks like just Windows
12:05:44 <phubuh> I stumbled upon the The Languages section and for a moment, I thought they were in order of performance
12:18:15 <Marvin--> hrmm, now where did I put those language semantics notes
12:21:07 <Marvin--> I'm pretty sure I had Pitts' lecture notes somewhere here
13:06:50 <Marvin--> hmm
13:07:06 <Marvin--> in LaTeX... what would be the best way to mix typewriter text with math mode?
13:07:29 <ham[let]> ?
13:07:37 <Igloo> \mathtt{foo}
13:08:30 <ham[let]> Igloo what mode is that?
13:08:35 <Marvin--> I mean, I almost want something like verbatim, you know, preserving line breaks and other whitespace, but I also want to insert indices and stuff
13:08:56 <Igloo> what mode?
13:08:58 <hram> shapr: Solving the more-problem was easy, just load it dynamically and everything works just fine without any other modification.
13:09:21 <Marvin--> like in the haskell report, where they have haskell code in typewriter font and "holes" as italics with indices and everything
13:09:29 <Igloo> Marvin: Do the indices have to be the same width as everything else?
13:09:42 <Igloo> \alltt in the alltt package might be what you want
13:10:04 <Marvin--> I don't want the holes to be fixed width at all
13:10:07 * Igloo AFKs for a minute
13:10:15 <Igloo> Then the above should do it
13:11:07 <Marvin--> nice, thank you
13:12:47 <ham[let]> Igloo do you also happen to know a good picture for these mathematical diagrams?
13:14:32 <Igloo> picture? these?
13:14:39 <Marvin--> Igloo: err... _ doesn't seem to produce an index though
13:14:58 <ham[let]> Igloo these diagrams with the arrows and such
13:15:54 <Igloo> Marvin: You'll need something like \mbox{${}_{whatever}$} I suspect, although you could \def\index#1\mbox{${}_{#1}$} or something
13:16:09 <Igloo> Or you could probably edit the alltt source to have _ do it
13:16:31 * Igloo doesn't understand what diagrams you mean
13:16:35 <Marvin--> ah, wait, \sb
13:17:34 <Igloo> What does that do?
13:17:40 <Marvin--> subscript :)
13:17:46 <Marvin--> e\sb{1}
13:17:50 <Igloo> Ah
13:17:53 <ham[let]> Igloo sec
13:17:55 <Marvin--> now to get the text centered
13:18:54 <ham[let]> Igloo like that
13:18:55 <ham[let]> http://planetmath.org/encyclopedia/Monad.html
13:19:04 <Darius> commuting diagrams?
13:19:33 <Igloo> Ah, I'd probably use metapost for something like that
13:19:50 <Darius> XYpic would probably be the best choice.
13:19:54 <ham[let]> metapost?
13:20:05 <ham[let]> sec let me search for these
13:23:05 <ham[let]> thanks a lot
13:23:19 <Marvin--> argh, stupid LyX inserting extra line breaks
13:24:28 <Smerdyakov> Marvin--, you get what you deserve for using LyX.
13:25:47 <Marvin--> yeah, I guess
13:26:09 <Marvin--> I was lazy when I started writing
13:26:28 <SyntaxNinja> "my name is Smerdyakov. You used LyX. Prepare to have extra line breaks inserted"
13:27:08 <Marvin--> :(
13:29:36 <Marvin--> I really wonder why it inserts extra linebreaks in a verbatim environment though
14:00:40 * Heffalump appears
14:00:53 * Heffalump pokes shapr hopefully
14:12:07 <hram> mutt
14:12:22 <hram> mhmh... too many windows :)
14:16:53 <Marvin--> Heffalump: so much for seeing the girl? :)
14:17:06 <Heffalump> she's lying on the bed
14:17:20 <Heffalump> talking to me
14:17:23 <Heffalump> so :-p
14:17:47 <Marvin--> fair enough :)
14:19:28 <SyntaxNinja> Heffalump: did you just indicate that you're talking to a girl who's lying on a bed and you're.... talking on IRC?
14:21:36 <Marvin--> his priorities do seem a bit off, don't they?
14:21:42 <Heffalump> bah.
14:21:53 <Heffalump> she's reading a book.
14:22:07 <Marvin--> no wonder, when you're here ;-)
14:22:10 <SyntaxNinja> ;)
14:22:35 <SyntaxNinja> Heffalump: does she keep saying things like "This book.... it's so boring..."
14:23:18 <Heffalump> it's quite hard to shake her from reading when she has her nose in a book
14:23:40 * Heffalump throws a cat at her
14:24:12 * Marvin-- wishes he had a cat to throw at people
14:24:23 <Heffalump> s'not a real cat.
14:24:23 <SyntaxNinja> Marvin--: you should keep one under your coat at all times.
14:31:55 <Marvin--> aiih, Xena's not on until another two hours?!
14:31:58 * Marvin-- sighs
14:33:02 <Heffalump> I need to teach my girlfriend temporal logic.
14:33:30 <Marvin--> how so?
14:33:47 <Heffalump> she seems to have problems with the "until" operator.
14:34:47 <Marvin--> heh
14:37:06 <SyntaxNinja> can I put that on the quotes page?
14:37:08 <SyntaxNinja> :)
14:37:25 <Heffalump> if you must :-)
14:37:32 <SyntaxNinja> @wiki IrcQuotes
14:37:32 <lambdabot> http://www.haskell.org/hawiki/IrcQuotes
14:37:46 <SyntaxNinja> make that @QuotesPage
14:39:18 <SyntaxNinja> Heffalump: you've been immortalized.
14:40:02 <Marvin--> "ideology overflow", heh
14:49:42 <Darius> So Heffalump, are there any online pictures of this vixen?
14:50:55 <Smerdyakov> Vixens have many uses.
14:55:13 <Heffalump> darius: yes
14:55:19 <Heffalump> if you try hard you could probably even find some :-)
14:59:12 <Smerdyakov> Heffalump, Slashdot is your favorite web site?
15:06:36 <Heffalump> not really, no
15:06:42 <Heffalump> but I had to paste that result, really
15:07:10 <Igloo> ?
15:07:57 <Heffalump> he's referring to the bottom of my homepage
15:10:17 <Igloo> Ah, lol
15:10:56 <Igloo> Is it updated or have I never gone much beyond the photos before?
15:11:07 <Heffalump> it's been like that for ages
15:12:19 <Igloo> astronomy?
15:12:49 <Heffalump> yes.
15:12:56 <Heffalump> (think steganography)
15:13:18 <Igloo> Do you mean to have cause to move large amounts of data about?
15:13:25 <Heffalump> indeed.
15:44:29 * Marvin-- sighs
15:44:41 <Igloo> ?
15:44:47 <Marvin--> the tickets for the film festival are released tomorrow, time to make some decisions
15:47:12 <ham[let]> night ppl
15:47:27 <ham[let]> me |-> (me,bed:)
15:47:45 <Heffalump> what language is that?
15:47:45 <Marvin--> night hamletrec
15:47:57 <ham[let]> rec?
15:48:25 <Marvin--> letrec
15:48:27 <Marvin--> recursive let
15:49:07 <ham[zzz]> ah right
15:49:09 <ham[zzz]> let*
15:53:55 <cm> hello
15:54:05 <Heffalump> 'lo
16:06:02 <Marvin--> hm... something chinese perhaps
16:11:34 <cm> w00t :]
16:12:30 <cm> http://www.leetspeak.org/regexp.hs.html :>
16:14:52 <Marvin--> fun fun
16:16:05 <cm> slow as hell, i suppose.. and no transformation into a DFA either, but oh well :)
16:31:24 * Marvin-- ponders
16:31:48 * cm is hungry
16:35:52 <Marvin--> why not... you know... eat?
16:36:50 <cm> not sur what i want to eat.. affluent society, you know
17:37:42 <stepcut> meow
