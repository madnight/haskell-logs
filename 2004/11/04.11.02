01:09:44 <mayhem> 'lo
01:10:14 <musasabi> Is there a database caching layer in haskell for some sql databases?
01:13:58 <wolfman8k> hey kids
01:15:27 <wolfman8k> hello?
01:16:09 <arjanb> hey
01:21:03 <wolfman8k> i'm gonna write my first haskell program
01:21:20 <wolfman8k> but i don't know how
01:21:32 <musasabi> have you read a tutorial?
01:21:50 <wolfman8k> yeah
01:21:56 <wolfman8k> i've read enough. it's now time to start coding :)
01:22:06 <wolfman8k> i have a specific question
01:22:16 <musasabi> please ask then
01:22:22 <wolfman8k> i'm gonna write a raytracer
01:22:40 <wolfman8k> i figure this is good for a functional programming language since the entire program is a single evaluation of a function
01:22:50 <Jan_w> wolfman8k: nice, as a first program, i'd suggest a "hello world" :)
01:22:52 <wolfman8k> it takes as input the scene description, and it returns the images
01:23:01 <wolfman8k> Jan_w: i've already done that :)
01:23:19 <wolfman8k> i'm gonna start with a function that takes a ray and sphere as arguments, and returns the intersection of them
01:23:26 <Jan_w> ok
01:23:29 <wolfman8k> problem is that i don't know what kind of data types to use
01:23:36 <wolfman8k> should the sphere be a tuple (x, y, z, radius) ?
01:23:45 <musasabi> wolfman8k: you will want to talk to Boegel, he is doing ray tracing in haskell.
01:23:48 <Jan_w> wolfman8k: you dicide
01:23:58 <wolfman8k> Jan_w: what would you do?
01:24:10 <wolfman8k> musasabi: hm.... i'm just gonna do something really simple though
01:24:17 * musasabi would probably use a data declaration rather than bare tuples
01:24:26 <wolfman8k> musasabi: how would that work?
01:24:41 * Jan_w whould just make a type Sphere
01:25:22 <musasabi> data Sphere = Sphere { sphereX :: Int, sphereY :: Int, ... }
01:25:39 <wolfman8k> hm...
01:25:59 <wolfman8k> i think i also may need a "Vector3" type
01:26:19 <wolfman8k> and then the Sphere would just be a Vector3 + radius
01:26:21 <musasabi> I haven't done raytracing so I don't know how things are best represented internally, but try to make representations abstract if you can.
01:26:26 <Jan_w> wolfman8k: But if you don't know types, maybe it's not yet time to start coding :)
01:27:07 <wolfman8k> Jan_w: i know the syntax for them, but i don't know how to decide which to use
01:27:10 <wolfman8k> Jan_w: i'm used to OOP :'(
01:27:23 <wolfman8k> another thing
01:27:29 <musasabi> data P3 = P3 !Int !Int !Int deriving(Eq,Show)
01:27:47 <wolfman8k> hm... that looks good i guess
01:27:56 <musasabi> instance Num P3 where ...
01:28:31 <wolfman8k> P3 is almost like complex, but you can't multiply two P3 together
01:28:32 * Jan_w is learning new syntax as musasabi speaks :)
01:29:16 <musasabi> wolfman8k: Complex is not very nice.. You cannot use it very well for 2d points either ;)
01:29:59 <wolfman8k> musasabi: so should i make my P3 type part of Num class? i don't think i need to since i won't need to use P3 in numerical functions other then my own
01:30:22 <musasabi> wolfman8k: then all is good and you can omit it ;)
01:30:34 <wolfman8k> cool
01:33:37 <wolfman8k> ok, so i have made a P3 type like you said
01:34:04 <wolfman8k> now how can i make a function that will allow you to do x + y for P3 values?
01:35:55 <musasabi> well there is an evil way.. and a boring and easy way.
01:37:04 <wolfman8k> hm...
01:43:31 <wolfman8k> ok... now i have a big problem
01:44:13 <musasabi> the ways are:
01:44:38 <musasabi> define a little bit more general P3 which works with various points (ints, doubles, ...)
01:44:41 <musasabi> data P3 t = P3 !t !t !t deriving(Show)
01:44:59 <wolfman8k> hm...
01:45:03 <musasabi> define a lift2 operator for it:
01:45:04 <musasabi> lift2 f (P3 x1 y1 z1) (P3 x2 y2 z2) = P3 (f x1 x2) (f y1 y2) (f z1 z2)
01:45:18 <musasabi> and addition:
01:45:20 <musasabi> plusP3 = lift2 (+)
01:45:34 <musasabi> Of course you could also write:
01:45:42 <musasabi> plusP3' (P3 x1 y1 z1) (P3 x2 y2 z2) = P3 (x1+x2) (y1+y2) (z1+z2)
01:47:19 <wolfman8k> ok thanks
01:47:24 <wolfman8k> but now i have another problem
01:47:55 <wolfman8k> i need my ray-sphere intersection function to return a value that indicates whether there is or is not an intersection, and if so, the intersection point
01:48:08 <wolfman8k> i think i need to pattern match the return value or something
01:48:16 <wolfman8k> but what return value should i use?
01:49:42 <musasabi> if you want to maybe return one result use Maybe, if you want to return zero or more results use a list.
01:50:07 <wolfman8k> i want 0 or 1 result. so i should use Maybe?
01:51:28 <musasabi> yes..
01:51:38 <wolfman8k> ok thanks... another problem
01:51:48 <wolfman8k> i have
01:51:51 <wolfman8k> data Ray = Ray {origin :: P3, direction :: P3}
01:52:07 <wolfman8k> now i want to have a function that takes a Ray value as a parameter
01:52:22 <wolfman8k> but i don't want to have to split each P3 into it's components
01:52:27 <wolfman8k> because then i end up with 6 little variables
01:52:44 <wolfman8k> and then i can't call functions that take P3 as argument with them, without reconstructing them back into a P3
01:52:49 <wolfman8k> i hope i am making some sense :/
01:53:08 <musasabi> you don't have to decompose things if you don't need that.
01:53:48 <wolfman8k> f (Ray r) = 0 doesn't work :/
01:53:57 <musasabi> you can have something like foo aa (P3 x y z) cc@(P3 _ _ z3) = ...
01:54:14 <musasabi> why not simply f r = 0
01:54:30 <wolfman8k> how will it know that r should be a Ray value?
01:56:24 <musasabi> well you can write a type signature, or just let the compiler infer it if you use it as a Ray.
01:56:36 <wolfman8k> hm... cool thanks. @ seems to be key
01:56:41 <musasabi> f :: Ray -> Int
01:56:44 <musasabi> f r = 0
01:57:10 <musasabi> Sometimes type signatures are also good for documentation if you use haddock ;)
01:57:31 <wolfman8k> i don't need docu =]
01:59:00 <peti> Yo.
02:01:40 <musasabi> hello peti.
02:02:02 <musasabi> where was postmaster again, I would like to look at it..
02:02:25 <peti> musasabi: http://postmaster.cryp.to
02:02:56 * peti is experimenting with an API for the mailer backends right now.
02:03:13 <peti> SP arrows look *cool*, but they seem to have weird performance behavior.
02:03:29 <peti> Has anyone ever done anything with SP? 
02:04:24 <peti> For some unfathomable reason, with SP arrows an hGetContents version is _faster_ than one reading with hGetBufNonBlocking directly into a Ptr Word8 buffer. I have no idea how that is possible.
02:10:09 <musasabi> have you profiled?
02:10:21 <peti> No, not yet.
02:10:45 * peti is scared of profilers. :-)
02:11:00 <peti> Haven't used one for all my "career" yet.
02:13:09 * musasabi profiles nearly all of his haskell code
02:13:30 <peti> I understand the profiler isn't that much use unless you can read Core?
02:13:36 <peti> Is that true?
02:13:40 <musasabi> no
02:13:49 <peti> Hmmm.
02:13:53 <musasabi> It just displays how much time/memory was spent in each function
02:14:42 <musasabi> then you can notice things like "hmm I seem to spend 90% of time in a single function, maybe I should look into it"
02:15:13 <peti> musasabi: I see. 
02:15:31 <peti> Maybe I should look at that feature after all.
02:16:00 <peti> It feels wrong, though. I'd like to understand it _myself_. Not with the help of some dump compiler feature. :-)
02:16:15 <peti> Uh, dumb compiler feature ... not dump. :-)
02:17:03 <wolfman8k> it's impossible to understand performance without profiling
02:17:15 <wolfman8k> unless you do lots and lots of well thought out benchmarks
02:17:21 <musasabi> well the question is many times "how clever is this compiler version today"
02:18:12 <peti> musasabi: That's a valid point. That's why I thought you'd need to read Core to really get something out of the results.
02:18:41 <peti> wolfman8k: "Impossible" is a rather strong word, don't you think? People have written fast programs without profiling anything for decades.
02:18:42 <musasabi> no, usually you see where the problem is and it is usually quite easy to fix it.
02:19:10 <musasabi> peti: haskell makes that harder than most languages, as performance is very counterintuitive with lazyness.
02:19:15 <peti> musasabi: Alright. I'll take a look at it. Thanks for the encouragement. :-)
02:24:45 <wolfman8k> sweet it works!
02:24:58 <wolfman8k> i don't believe it.... coding in haskell really is pretty rapid
02:25:10 <wolfman8k> my entire program is only 30 lines :O
02:25:45 <wolfman8k> anyway... gotta eat thanks for help everyone bb soon
02:30:08 <Boegel> hello everyone
02:31:08 <TheHunter> morning Boegel 
02:32:35 <Boegel> no mail back from Meurig Sage yet... I think he's tired of answering questions on FranTk :)
02:34:17 <Boegel> @seen mitchkov
02:34:18 <lambdabot> I haven't seen mitchkov
02:49:41 <Boegel> are there any americans in here ?
02:56:32 <xkb> is FranTK that functional ui lib?
03:05:28 <musasabi> yes
03:15:09 <wolfman8k> how can i use libcaca from haskell? http://sam.zoy.org/projects/libcaca/
03:18:46 <Boegel> xkb, why do you ask? :)
03:19:10 <xkb> Im busy creating a gui atm
03:19:16 <xkb> wxHaskell
03:19:32 <Boegel> we'll, I've been told to use FranTk because of it's pure functional syntax
03:19:59 <xkb> I must say the pure functional part of it is interesting
03:20:26 <Boegel> but it's not up to date, and that's a real shame
03:20:35 <xkb> 2 bad indeed
03:20:49 <xkb> perhaps someone can restart the project, perhaps within a universitry
03:20:50 <xkb> -r
03:21:23 <Boegel> i unfortunatly don't have the time for it
03:21:24 <wolfman8k> are there any tutorial or documentation for HGL?
03:21:34 <Boegel> but I'm very mutch interested in it
03:21:41 <Boegel> I've always like graphical stuff
03:23:35 <Boegel> I'm planning to use the FranTk library for my thesis, and maybe but a slightly more up to date version with some extra documentation online
03:23:50 <Boegel> but i would like to get response from Meurig, because it still is his project
03:26:15 <peti> musasabi: Did you fetch the Postmaster sources with Darcs?
03:26:27 <peti> musasabi: If you did, you might want to pull again. I just committed some fixes.
03:37:40 <musasabi> ok, I'll fetch a new version.
03:38:17 <musasabi> I have a beginning of a text mode UI toolkit in haskell, which would need a week of work...
03:38:32 <wolfman8k> ncurses?
03:38:46 <musasabi> no, plain ansi escape sequences.
03:42:14 * shapr awakens
03:43:09 <shapr> dash: hey, I think Yampa could handle twisted reality.
03:43:11 <peti> Yo shapr.
03:43:26 <shapr> good afternoon peti 
03:43:28 <peti> shapr: I've experimented with SP as Internet components. It's beautiful code!
03:43:35 <shapr> SP...
03:43:40 <shapr> ?
03:43:45 <arjanb> streamprocessors?
03:43:49 <shapr> aha
03:43:50 <peti> shapr: The internetLib you referred me to used them, too.p 
03:43:56 <shapr> stream processor arrows?
03:44:01 <peti> shapr: Yup.
03:44:09 <peti> shapr: It's quite simple once you've got it. :-)
03:44:12 <shapr> could I see your code?
03:44:19 <shapr> that sounds *very* cool.
03:44:23 <peti> shapr: Sure. Gimme a second.
03:44:32 <peti> shapr: There is a catch though. Can you guess what it is?
03:44:37 <musasabi> peti: how are you incorporating time with stream processors? That was my own largest problem.
03:44:49 <shapr> I can think of several possible catches...
03:44:49 <peti> shapr: It begins with 'p' and ends with 'erformance'. :-)
03:44:53 <shapr> haha
03:45:11 <shapr> I think that's the easiest one to fix
03:45:27 <peti> musabi: I've made the SP type "restartable". It behaves like a state monad, basically, but the state is hidden in the SP type.
03:45:45 <shapr> have you read the Yampa papers?
03:45:50 <peti> musasabi: When you "runSP sp", then you get the output and the transformed SP.
03:45:56 <peti> shapr: A part of it.
03:46:19 <shapr> I've thought about arrows like (dll >>> tcp >>> ftp) and (dll <<< tcp <<< ftp) the other way.
03:46:33 <shapr> I think it would work with the Yampa arrow collections.
03:46:35 <wolfman8k> argh... i can't get HGL working :(
03:46:44 <shapr> yah, HGL is a pain in the butt to install.
03:46:49 <shapr> which OS?
03:47:29 <wolfman8k> gentoo linux
03:47:48 <musasabi> peti: yes I can do that.
03:48:02 <musasabi> but many times I would need timeouts for real implementations.
03:49:05 <shapr> maybe we need a wiki page, "Crazy Arrows Ideas - What Will And Won't Work" and code samples.
03:49:19 <wolfman8k> shapr: is the haskell SDL stuff easier to install?
03:49:48 <shapr> HGL requires HSX11 and greencard
03:50:06 <shapr> wxHaskell requires wxWidgets and various supporting libs
03:50:33 <shapr> all of the Haskell SDL binding I've seen are partial bindings at best.
03:50:34 <wolfman8k> i just need the easiest way to draw images
03:50:53 <peti> musabi: You have to hide the timeout stuff in the SP that does the I/O and feeds the stream.
03:51:06 <peti> musasabi, shapr: Check out <http://peti.cryp.to/sp-test.tar.gz> if you're interested.
03:51:20 <peti> "make test" is what you'd like to do. :-)
03:51:37 <wolfman8k> shapr: what i really want to use is libcaca
03:51:48 <musasabi> peti: yes, that works, but is not very pretty.
03:52:07 <musasabi> That is I find that in the end monadic code was more readable which is kind of frustratring.
03:52:43 <peti> musasabi: I'm implementing timeouts the same way in BlockIO, and I didn't think it was uncomfortable to use or anything. Check out the readerSP. If you put the timeout into that thing, it should be transparent for the rest of the stream.
03:53:19 <peti> One problem is that you'll sooner or later need the Arrow notation. And then Haddock won't work anymore because it can't parse it. :-(
03:53:42 <shapr> haddock can be fixed
03:54:18 <shapr> I'll have to look at this after coffee
03:54:19 <musasabi> peti: not that, but rather timeouts inside the protocoll which interact with the rest of the computation.
03:54:54 <peti> musasabi: Then feed a "Timeout" event type through the SP when it happens.
03:55:13 <musasabi> to put it bluntly monad+thread+exceptions seems simpler than the arrow-syntax.
03:55:15 <wolfman8k> ok i have another big problem guys...
03:55:34 <wolfman8k> i'm doing this raytracer... so i want a function that takes a list of spheres, and returns an image
03:55:41 <wolfman8k> problem is i don't know what kind of value to use for the image
03:56:01 <peti> musasabi: I am undecided yet. So far, monadic style gives me about 20 times the performance! I think that beats all arguments for or against SPs for the moment. :-*
03:56:07 <peti> But the code looked beautiful.
03:56:14 <musasabi> peti: no it is rather then something like timeOut :: a i o -> Timeout -> a i (Either () o)
03:56:38 <musasabi> and then I get to the arrow style conditionals etc
03:56:42 <peti> Hmm.
03:57:18 <peti> What's speaks against "data Token = Data String | ReadTimeout Handle | WriteTimeout Handle | ...." and then writing a "SP Token foo"?
03:57:42 <musasabi> reusablity
03:57:52 <peti> data Token a = ... 
03:58:11 <musasabi> which is the same as Either really..
03:58:11 <peti> Then it's reusable.
03:58:24 <peti> Hmm.
03:58:31 <peti> You may be right. :-)
03:59:06 <musasabi> I know why arrows are better than monads for parsers, but I am trying to grasp why they are better for protocolls.
03:59:25 <peti> musasabi: I'm not convinced they are. 
03:59:43 <peti> musasabi: In Postmaster, for instance, the protocol engine is _pure_. No monad, no arrow, nothing.
04:00:20 <peti> I'm interested in abstracting block-i/o from the user -- and SPs seem to be good for that. And slow.
04:00:41 <musasabi> but you can do SPs without arrows.
04:01:39 <peti> musasabi: Currently I use State monads. But that cumbersome at times. The SP has the advantage that the "state" is  implicitely constructed by plugging the SP instances together, whereas in a State monad (or StateT) I have to define the state explicitely.
04:01:48 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/SP.hs vs http://www.cs.helsinki.fi/u/ekarttun/haskell/SPArr.hs
04:03:02 <musasabi> I have quite a lot of protocol code with a combination State+Io which works nicely.
04:03:32 <peti> musasabi: The SP definition you have there _is_ the SP arrow.
04:04:25 <musasabi> peti: look at them, they are different.
04:04:34 <musasabi> one uses arrow notation, the other does not.
04:05:01 <peti> Sure, but you because you don't define (>>>) doesn't make the type any less an arrow. :-)
04:05:16 <peti> peti: My SP uses the exact same definition.
04:05:20 <musasabi> well you could claim that pure code is arrows too ;)
04:05:35 <peti> Every function is an arrow. :-)
04:06:00 <musasabi> I know but that makes it hard to talk about things.
04:06:19 <peti> The problem is Haskell is that there are a million *cool* ways of doing things, and you re-write and re-write your code to make it even cooler, but in the end it's all equivalent anyway. :-)
04:06:36 <musasabi> Thus it is imho better to limit oneself to actually using Control.Arrow (or something similar) when talking about arrows.
04:07:07 <peti> musasabi: Well, I think that if a type supports a generic API like (>>>), then you should use it.
04:08:05 <xkb> Is there a simple step by step howto for wxHaskell?
04:08:09 <peti> But you are right, of course. You can implement SPs in many different ways. What I am looking for is the best way for my problem. And I won't find it. :-(
04:09:10 <musasabi> peti: note also that Control.Arrow makes it hard to place limitations on the types which is hard for many things.
04:09:27 <peti> musasabi: That's true. 
04:10:11 <peti> Perhaps I'd rather write a generic wrapper for StateT based SPs and be done with it ...
04:10:16 <peti> I hate design decisions.
04:37:57 <Oejet> xkb: Try http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lectures/GUIs%20for%20Haskell/GUIs%20for%20Haskell.pdf
04:38:13 <xkb> thank you! :D
04:38:19 <xkb> looks great
04:39:30 <xkb> hehe nice quote at the end
04:39:48 <xkb> "If you think wxHaskell is complicated, wait till you learn Java"
04:40:21 <tuomov> all widget sets are overly complicated
04:40:37 <tuomov> (and the wrong abstraction level to write apps in the first place)
04:42:45 <mornfall> hello
04:42:53 <Oejet> toumov: Can you elaborate on that?
04:44:21 <tuomov> One rather general html+css:ish idea can be found at http://iki.fi/tuomov/vis/
04:44:39 <tuomov> But anything that doesn't require the user to deal with individual widgets per se would be much better than the current crap
04:47:41 <tuomov> s/user/programmer/
04:50:24 <Philippa_> you're going to have to at some point. But yeah
04:51:48 * kosmikus does use ion3 on his laptop since yesterday
04:58:35 <xkb> whats ion anyway
04:59:41 <tuomov> http://iki.fi/tuomov/ion/
05:01:21 <Oejet> xkb: A more technical document is http://www.cs.uu.nl/~daan/download/papers/wxhaskell.pdf.
05:02:24 <xkb> Oejet: that's the one Im reading now
05:02:50 <xkb> tuomov: ion looks nice.. 2 bad i'm a mac user
05:02:59 <xkb> tuomov: did you write it?
05:03:16 <tuomov> yes. And it can be compiled on osx and be used to manage X apps there :)
05:03:27 <xkb> really? Nice!
05:03:34 <tuomov> quite a few people use it so to my knowledge
05:03:50 <wolfman8k> how can i "cast" an Int to a Double?
05:04:12 <xkb> As im a laptop user I really like  keybinding ui's
05:05:31 <TheHunter> @type fromIntegral
05:05:32 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
05:05:48 <wolfman8k> hm....
05:05:56 <wolfman8k> i don't understand :(
05:06:20 <TheHunter> fromIntegral (4 :: Int) :: Double => 4.0
05:06:26 <xkb> tuomov: do I need to use X11?
05:06:56 <xkb> or is it also usable with Aqua whatever the ui layer is called on the mac
05:06:57 <tuomov> yes, of course.
05:07:09 <tuomov> I don't think so.
05:07:31 <tuomov> It would be a nice hack to manage aqua apps by an x wm, though...
05:07:50 <wolfman8k> TheHunter: thanks
05:08:26 <tromp> @eval 0::Double
05:08:26 <lambdabot> (line 1, column 3):
05:08:26 <lambdabot> unexpected ":"
05:08:26 <lambdabot> expecting simple term
05:09:56 <tuomov> But from the fact that special apps have special decorations, I'd suspect that there's no actual window manager in aqua, but each program manages its windows itself (with a default implementation in a library)
05:10:26 <tuomov> and this could require quite awful kludges to make the apps seem icccm-compliant
05:10:41 <tuomov> (by the icccm the wm always has the final say in window sizes and such)
05:12:32 <xkb> aha
05:12:45 <xkb> that explains behaviour of os x apps
05:12:56 <xkb> and window placement etc
05:12:57 <tuomov> does an app hanging hang its window too?
05:13:01 <tuomov> it does in windows.
05:13:14 <tuomov> but not in x11.
05:13:23 <xkb> hmm.. I can't really remember
05:13:32 <xkb> Dont have alot of hanging apps :D
05:13:45 <xkb> I think I can still move its windows
05:13:50 <xkb> not sure though
05:14:55 <tuomov> that would give hope that there's a separate wm, and there are x apps that mostly try to override the wm (e.g. xmms), but then again, the window management routines could be a separate thread too
05:14:58 <xkb> you can't focus a window of a "beachballing" alppp
05:15:05 <xkb> alppp = app
05:15:08 <xkb> darn keybaord
05:15:10 <xkb> aargh
05:15:12 <xkb> keyboard
05:15:15 <xkb> :)
05:15:26 <tuomov> you can't do that in x either if the wm respects all changes requested by the app
05:15:43 <tuomov> ion's tiled workspace obviously don't
05:18:52 <xkb> I cant find a windowmanager like task yet
05:18:57 <xkb> with ps wuax
05:19:16 <xkb> ah
05:19:20 <xkb> there is WindowServer
05:20:37 <tuomov> but is it more like a compositing manager? Server top-level windows for apps (afaik osx only supports top-level windows in its window system)
05:20:45 <tuomov> s/server/serves/
05:21:43 <tuomov> I guess it would be documented somewhere if one were to start browsing apple's pages
05:21:56 <xkb> I guess so
05:22:06 <xkb> 2 bad this part of os x isnt open source :d
05:22:11 <xkb> like darwin
05:22:45 <wolfman8k> is there a way to do normal loops in haskell?
05:24:11 <wolfman8k> hm... nm i think i just realized the functional way to do this
05:24:15 <tuomov> looping is dirty recursion
05:24:16 <Lemmih> wolfman8k: Haskell is a purely functional language with no procedural features.
05:24:28 <Oejet> wolfman8k: repeatM?
05:24:44 <wolfman8k> it just seems that for some things loops are cleaner then recursion
05:25:36 <tuomov> simpler perhaps
05:25:39 <Oejet> wolfman8k: Yes, like starting 10 threads: repeatM_ 10 (forkIO (do something)).
05:25:55 <wolfman8k> actually i think that i can use map in my case
05:26:32 <Oejet> What do you whant to do?
05:27:58 <wolfman8k> alright, it compiles =D
05:28:21 <wolfman8k> map and lambda functions are pretty sweet
05:31:03 <wolfman8k> how can i print out each string in a list of strings?
05:31:16 <peti> wolfman8k: mapM putStr [...]
05:31:28 <wolfman8k> peti: hm... where can i read about mapM?
05:32:09 <peti> wolfman8k: <haskell.org/tutorial/>, I think.
05:32:14 <wolfman8k> peti: thanks
05:32:21 <peti> wolfman8k: Or the reference documentation at haskell.org/ghc/
05:32:29 <wolfman8k> hm... how does one write the constant value "-1.0" ?
05:32:38 <peti> in brackets
05:32:42 <wolfman8k> haskell seems to think that i want to perform subtraction :(
05:32:55 <wolfman8k> hm.... brackets?
05:32:58 * shapr is almost awake
05:33:01 <peti> (-1.0)
05:33:03 <shapr> óla LAPA 
05:33:09 <wolfman8k> oh cool danke
05:33:10 <shapr> LAPA: are you learning Haskell?
05:33:10 <Lemmih> Good morning, shapr.
05:33:16 <Oejet> wolfman8k: I have this page bookmarked: http://haskell.org/ghc/docs/latest/html/libraries/doc-index.html
05:33:18 <shapr> greetings Lemmih 
05:33:38 * peti has to write a CV for a job application. 
05:33:40 <peti> Bah.
05:33:58 <peti> I never know what to include and what to leave out.
05:35:41 <Oejet> peti: How about asking them?
05:35:46 <tuomov> both the jobs I've had they didn't want cv for.. and the times I've applied to one that required a cv I haven't got past the initial interview :)
05:36:19 <peti> Oejet: As the company would know. :-| They'll just say "yeah, well, the usual things".
05:37:29 <Oejet> peti: He, then they might not use the CV anyway ;-)
05:37:29 <wolfman8k> hm... i don't get mapM... i haven't learned monads yet :/
05:38:46 <shapr> monads are very cute
05:38:48 <wolfman8k> ok here's the thing. my program isn't giving me the expected output. how can i put "printf" calls inside pure functions so that i can examine the internal results of various functions?
05:38:48 <peti> Oejet: In those interviews I had, I had the impression the guys hadn't read the CV anyway. Honestly, they asked me questions I had explained in great detail on the first page! I don't know what these things are good for. As you you could judge someone from a piece of paper.
05:38:50 <shapr> they're a nifty design pattern
05:39:17 <shapr> I think the best job interviews involve beer and code
05:39:58 <peti> shapr: That would be a rather effective interview. :-)
05:40:29 <tuomov> sigh. I should get forward with my job-avoidance plan
05:42:28 <wolfman8k> how can i convert a Double to Int?
05:42:42 <shapr> the beer relaxes people, and the code shows what everybody really understands.
05:43:15 <shapr> because, the prospective employee should be just as carefully checking out those who hire...
05:43:36 <tuomov> supposing[*] one wanted to do graduate studies in some math/theoretical aspects of fp, what were the places to do so? ([*] Still haven't decided if I want to continue with analysis/stochastics that I mostly studied for my m.sc, jump to some more cs related math, or to some kind of theoretical cs)
05:44:07 <peti> wolfman8k: Don't you think it would be better to learn a bit of the language before writing code in it? Asking on the IRC channel for every little detail can't possibly be an effective way of getting software written. :-)
05:44:22 <wolfman8k> peti: this is my way of learning =)
05:44:35 <wolfman8k> peti: i probably could use a good haskell book, but right now that's not an option for me
05:44:41 <peti> tuomov: Chalmers?
05:44:45 <wolfman8k> peti: so this channel is the next best thing :P
05:44:51 <peti> wolfman8k: haskell.org/tutorial/
05:45:02 <wolfman8k> peti: i've read that
05:45:04 <tuomov> that's one possibility, although the research seems more of the practical nature there
05:45:10 <shapr> For the haskell branch of FP, chalmers, edinburgh, ogi.edu, oxford, imperial college, unsw, freiburg, u of singapore come to mind
05:45:11 <tuomov> at least there shouldn't be tuition fees..
05:45:26 <shapr> do you have any particular countries you prefer?
05:45:33 <wolfman8k> maybe what i need is a #haskell-n00bas channel :|
05:45:33 <shapr> or branches of FP?
05:45:38 <shapr> wolfman8k: this is it!
05:45:49 <shapr> I was a n00b when I joined this channel too!
05:46:04 <Lemmih> Didn't you create this channel?
05:46:04 <tuomov> not really. perhaps in the eu though, and not too big tuition fees.
05:46:10 <shapr> Lemmih: well, yes.
05:46:16 <tuomov> and the more theoretical/mathy stuff
05:46:22 <shapr> but that didn't mean I had a clue beforehand.
05:46:23 <tuomov> if there's anything more to be done there
05:46:32 <wolfman8k> shapr: coolness, so how does one convert Double to Int? :)
05:46:41 <peti> wolfman8k: I think the function 'floor' is what you want.
05:46:47 <wolfman8k> peti: thanks dude
05:47:48 <bourbaki> moin
05:49:16 <shapr> Lemmih: just meant that a) I knew I wanted a clue and b) I was going to get a clue no matter what it required.
05:49:16 <shapr> Philip Wadler is at Edinburgh, and he's the guy who got monads into Haskell in the first place.
05:49:16 <shapr> Ross Paterson seems to be the guy most involved in further study/use of arrows, he's at London's City University.
05:49:16 <shapr> Hughes and Claessen have good ties to the circuit design folks in gothenburg, which is at once highly theoretical and useful enough to pay well.
05:50:16 <shapr> tuomov: there's a *lot* of theoretical stuff left to do... category theory? complexity theory? duality of call-by- strategies? There's *lots* going on.
05:50:42 <shapr> Epigram has bleeding edge type system stuff.
05:50:48 <bourbaki> duality of call by strategies?
05:51:01 <tuomov> Yeah, I've been reading a little on type theory lately.. interesting stuff
05:51:02 <shapr> yah, like Wadler's recent call-by-value paper.
05:52:22 <shapr> The way I see it, you nearly every FP research paper I've read recently mentions a few avenues of research that just aren't being explored because there's so many things to explore compared to the number of researchers.
05:52:54 * wolfman8k thought computer science was dead
05:53:05 <shapr> Java is dead.
05:53:12 <shapr> that's not computer science though =)
05:53:25 <wolfman8k> c# is alive
05:53:32 <xkb> hey..java is my livelyhood
05:53:32 <shapr> if you say so.
05:54:03 <wolfman8k> c# is at least better then java, and it's more functional
05:54:25 <xkb> hmm "better" is quite a dangerous word in this context
05:54:37 <xkb> but let's not start a holy war here :D
05:54:39 <shapr> CS is very much alive, but doubt you'll get it from software sold as a product.
05:55:08 <Oejet> xkb: Undertakers make a living of dead people. That's a good thing.
05:55:13 <xkb> lol
05:55:30 * peti thinks that the appreciation for the theoretical foundations of software development are dead -- at least in most of the industry.
05:55:41 <tuomov> Things like Vis could do with some more research... but I'd rather do a phd on more mathy/theoretical stuff
05:56:23 <Oejet> peti: Has there anytime been an appreciation for the theoretical foundations?
05:56:30 <shapr> type theory, category theory, evaluation strategies, monadic/arrow patterns...
05:56:42 <shapr> Which world would you like to explore today? =)
05:56:49 <wolfman8k> so is there anyway to put "printf" calls inside of functions, for debugging?
05:57:06 <shapr> wolfman8k: the easiest way is to run your functions in GHCi
05:57:06 <tuomov> trace
05:57:11 <bringert> @type Debug.Trace.trace
05:57:12 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
05:57:22 <wolfman8k> shapr: hm...
05:57:24 <shapr> hej bringert!
05:57:27 <bringert> hej
05:57:31 <shapr> ok, trace is better.
05:57:39 * bringert is playing with dependent types
05:57:42 <shapr> oooh!
05:57:46 <shapr> epigram?
05:57:50 <bringert> oh, cake, bbl
05:57:54 <shapr> :-)
05:58:02 <xkb> gimme some :D
05:58:13 <peti> Oejet: I had the impression there used to be. In the very beginning, at least.
05:58:52 <shapr> Speaking of CS research, Aarne Ranta and Mark Forsberg's  Grammatical Framework and Functional Morphology is very cool linguistics stuff that uses the HM type system as its skeleton.
05:59:53 <shapr> type error slicing would be great for IDEs
06:00:09 <Oejet> peti: That could be said about string theory, nano technology and maybe some other fields too.
06:00:38 <shapr> I'd like to have modular type systems, something that can be applied the same way laziness and strictness is applied now.
06:01:13 <shapr> So part of my program would be in the HM typesystem, and another part would use System F, and sew that together on the top level somehow.
06:02:05 <shapr> Maybe I should just epigram more.
06:05:15 <kang> lo
06:05:42 <kang> ive a basic question.. how do you rewrite the signum function without using iteration in haskell ? :)
06:06:43 <xkb> without using explicit recursion?
06:07:00 <shapr> what's a signum?
06:07:11 <kang> without using stuff like | x > 0  = 1
06:07:30 <kang> (its what i call iteration)
06:07:40 <kang> signum is a function u have in haskell
06:07:50 <kang> it does that:
06:08:00 <kang>  signum x |  x >  0        =   1
06:08:05 <kang>        |  x == 0        =   0
06:08:11 <kang>        |  x <  0        =  -1
06:08:22 <bourbaki> isnt a sigmoid function something like tanh(x) ?
06:08:35 <bourbaki> what you are talking about kang is a step function
06:08:45 <tuomov> signum==sign
06:08:48 <kang> well signum returns 1 for positive, 0 for 0 and -1 for negative
06:08:49 <kang> ok
06:08:51 <kang> i dont' know :)
06:08:54 <kang> im trying to help a friend
06:09:00 <kang> but i never did functional programming nor haskell
06:09:01 <shapr> is this homework?
06:09:03 <tuomov> signum is the correct name
06:09:07 <kang> so ive read docs a bit
06:09:07 <bourbaki> ah sry
06:09:30 <bourbaki> i take back what i said and state the opposite ;)
06:09:44 <wolfman8k> what about sigmoid?
06:09:47 <kang> i thought i could ask the answer since it looks "simple" and deduce how its done or what are other syntaxse ^^
06:09:58 <shapr> sigmoids, that's the programmer's altoids, right?
06:10:14 <wolfman8k> i thought that sigmoid is a "smooth" step function
06:10:17 <kang> (and i know you can use abs to rewrite this signum too)
06:11:11 <shapr> ok, I still don't really understand the question.
06:11:40 <kang> well, one should rewriet signum using the abs function, without iteration
06:11:43 <kang> rewrite*
06:14:37 <kang> shapr: is that understandable?
06:15:19 <shapr> Not to me, but maybe I'm the only lost one?
06:16:09 <Lemmih> kang: Why do you want to rewrite it?
06:17:36 <kang> Lemmih: well, its a friend doing some kind of homework i think, not that im really knowing haskell but i tried to understand it reading docs/tutorials but i don't really understand how to do it
06:18:03 <kang> shapr: i wouldn't ask if i wasn't myself anyway ^^ 
06:18:59 <shapr> I don't think that the three separate cases count as iteration, that's what confuses me.
06:19:50 <kang> well for me | thing is an iteration but maybe its the wrong term, im just french afterall
06:20:02 <kang> i just want to do it another way than with | if you understand better
06:20:16 <shapr> you could use case, or pattern matching
06:20:24 <shapr> but they end being the same thing under the hood
06:20:32 <Oejet> kang: signum x = if x == 0 then 0 else x / abs x ?
06:20:33 <kang> well for case yeah
06:20:41 <kang> pattern matching, ive to read about it again ^^
06:20:51 <kang> Oejet: that sounsd good
06:21:00 <kang> but
06:21:06 <kang> not sure she can use if then else
06:21:07 <tuomov> there's still two cases..
06:21:31 <tuomov> it's just | x == 0 = .... | otherwise written otherwise
06:21:52 <kang> oki, wel l with abs ;)
06:22:01 <kang> how do you do wit with pattern matching ?
06:22:18 <Oejet> signum 0 = 0
06:22:18 <Oejet> signum x = x / abs s
06:22:44 <Oejet> s/s/x  :-)  
06:23:10 <kang> Oejet: now that looks good :)
06:23:22 <kang> now ive to understand it^^ 
06:23:42 <Oejet> Yeah, I saw what you were asking for. ;-)
06:23:49 <kang> but thanks :)
06:24:35 <kang> i didn't thought it would be this way somehow
06:24:35 <kang> lol
06:25:01 <tuomov> of course, internally, that's still the same thing
06:25:26 <kang> yeah but np, i think its what she wanted/needed to do
06:27:21 <dash> hello, haskelloids
06:28:14 <xkb> hmm how do you retrieve the value of a textEntry upon an event in wx?
06:28:37 <Lemmih> Hey dash.
06:30:12 <xkb> I guess I need to read the event in some way
06:31:34 <Oejet> xkb: Wild guess: "get".
06:32:20 <dash> So, to reiterate the problem I was having yesterday
06:33:42 <wolfman8k> let x = x+1 <- is that allowed?
06:35:03 <Lemmih> Yes.
06:35:23 <dash> Actually, I will try some different code instead of asking, first. :)
06:35:35 <wolfman8k> Lemmih: hm... it seems to cause an infinite loop
06:35:40 <Lemmih> Indeed.
06:36:08 <wolfman8k> that's not too useful then i suppose
06:36:36 <Lemmih> x = x+1 => x+1 => x+1+1 => x+1+1+1 ...
06:36:52 <wolfman8k> right
06:37:27 <bringert> shapr: GF is actually Martin-Löf, not HM
06:37:33 <bringert> anyway, cake was good
06:38:23 <wolfman8k> allright! my raytracer works!!!!!!!!!
06:38:26 <wolfman8k> screenshot: http://rafb.net/paste/results/L2ZBBN74.html
06:39:18 <Oejet> wolfman8k: Nice.
06:39:25 <shapr> bringert: oh, sorry
06:39:52 <shapr> wolfman8k: sexy =)
06:40:07 <wolfman8k> ok... i really need to get HGL working :|
06:40:19 <bringert> though since it's implemented in haskell, you could say that it's got HM at the core
06:40:39 * bringert should go now
06:40:43 <wolfman8k> maybe i'll fool around with some ascii a bit more though
06:40:52 <shapr> wolfman8k: hey, my first haskell program was a text mandelbrot fractal generator
06:40:56 <shapr> whoa check it out guys - http://www.darcs.net/logos/logo.png
06:40:57 <dash> Hah, i fixed it, yay. 
06:40:58 <wolfman8k> shapr: cool
06:40:59 <shapr> darcs has a new logo
06:41:12 <dash> COntinuation-passing programs don't work so hot when you forget to call the continuation somewhere.
06:44:00 <tuomov> hmm.. that figure isn't so good. it looks like a centralised system at first sight
06:44:10 <shapr> heh
06:45:40 <tuomov> but how to draw a decentralised system while not making not look like drawn by a three-year-old..
06:46:11 <shapr> use the six pointed star of chaos
06:46:14 <shapr> that's all too fitting =)
06:46:22 <shapr> actually
06:46:31 <shapr> I think I'll make my own darcs logo that looks like that =)
06:46:32 <dash> 6, not 8?
06:46:38 <shapr> er, eight
06:46:42 <dash> Main> run "(progn 1 2 3)"
06:46:42 <dash> 3
06:46:43 <shapr> look man, it's chaos...
06:46:53 <dash> this is a lot better answer than '1', which it was telling me yesterday
06:46:55 <shapr> sometimes some of the pointy bits break off
06:47:01 * shapr snickers
06:47:08 <tuomov> eh?
06:47:18 <tuomov> 6 not 5?
06:47:25 <shapr> eight actually
06:47:33 <dash> shapr: 7a.
06:47:38 <tuomov> or what star is this..
06:48:43 <shapr> http://www.warpartefacts.com/acatalog/info_A4412.html
06:48:48 <dash> OK! emboldened by this success, i am considering going forth to implement global environments and such
06:48:56 <tuomov> maybe the ring in that logo should be outside the blobs
06:49:00 <tuomov> but it might not look that good
06:49:14 <shapr> well, it's david's software.
06:50:07 <shapr> ohh, they have a Khorne symbol.
06:50:12 <shapr> I gotta buy that.
06:50:37 <shapr> I've always thought that would make a lovely tie-clip. I could wear it with my tux to the upcoming gala
06:53:22 <shapr> crap, I've forgotten how to write a cron-job
06:53:46 <shapr> how many stars again?
06:59:19 <shapr> hej svens 
06:59:27 <svens> hi
06:59:31 <shapr> how's code?
07:00:01 <svens> im testing an irc client for emacs... ;-)
07:02:19 <svens> hmm... there is also an irc client written in haskell... :)
07:02:36 <shapr> an irc client emacs? what's it called?
07:02:48 <svens> riece
07:02:56 <shapr> have you tried zenirc or ERC?
07:03:37 <svens> i tried erc, but riece has a nicer window management.
07:03:43 <svens> (imho)
07:04:22 <shapr> I haven't tried riece.
07:04:31 <shapr> I do like erc so far.
07:05:51 <wolfman8k> is there an easy way to save a png or jpeg image?
07:06:42 * juhp don't like the way erc only shows one buffer at a time
07:06:56 <juhp> perhaps it is just a matter of window session management?
07:06:59 <svens> shapr: riece has no "/" commands. every irc command is bound to a special key...
07:07:42 * peti wonders what John Goerzen meant in his reply on *.cafe.
07:07:52 * juhp used liece for a while and quite liked it (before I wrote hircules:)
07:07:53 <peti> Can't make heads or tails of what he's saying.
07:08:11 <juhp> he even
07:08:18 <shapr> juhp: hey, I'm planning on hacking Yi into an irc client sometime soon...
07:08:51 <juhp> shapr: really?  cool!
07:09:42 <juhp> it could be the first vi that support irc too ;-p
07:09:49 <juhp> supports
07:10:16 <shapr> once I can edit and do irc inside Yi, I'll completely stop using emacs.
07:10:48 <wolfman8k> i gotta find a way to do graphics with haskell :/
07:10:57 <shapr> wolfman8k: write out xbm files?
07:11:03 <Cale> wolfman8k: I made a binding to Imlib2 at one point.
07:11:07 <shapr> or, grab boegel's code and see how he did it?
07:11:09 <wolfman8k> shapr: hm.....
07:11:16 <wolfman8k> Cale!
07:11:27 <wolfman8k> boegel's code?
07:11:30 <Cale> It doesn't do any of the X interface stuff, but it works if you just want to load and store images.
07:11:54 <wolfman8k> Cale: i just want to show an image on the screen... this one:
07:11:55 <wolfman8k> http://rafb.net/paste/results/L2ZBBN74.html
07:11:55 <Cale> http://vx.hn.org/haskefl/Imlib2.hs
07:12:02 <Cale> oh, hmm
07:12:49 <Cale> well, my binding would be good if you wanted to save it to a png or something
07:13:16 <wolfman8k> that would also work i guess... how hard is it to make a binding for a C library?
07:13:19 <Cale> There ought to be some calls you can make in wxHaskell to display it
07:13:30 <wolfman8k> it would be really sweet if i could use libcaca http://sam.zoy.org/projects/libcaca/
07:13:33 <Cale> It's not so bad -- depends on the size of the C library
07:13:51 <wolfman8k> i think i just need like 5 functions
07:14:06 <bourbaki> who was that iwth the barcode again?
07:14:39 <Cale> Oh, pretty trivial then.
07:17:13 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:18:03 <Cale> You basically just need a foreign import line for each call you want to bring in.
07:18:33 <Cale> Occasionally, it's more convenient if you wrap things a bit, for example, converting between C and Haskell strings.
07:18:51 <Cale> but basically everything you need is provided.
07:21:28 <wolfman8k> only problem is that this library seems to work with raw arrays
07:22:21 <wolfman8k> void caca_draw_bitmap(int x1, int y1, int x2, int y2, struct caca_bitmap const *bitmap, void *pixels);
07:22:48 <wolfman8k> i'd like to be able to pass a haskell list for pixels
07:31:01 <wolfman8k> Cale: sweet, your code compiled!
07:36:58 <wolfman8k> Cale: now how to use it? :)
07:56:48 <bourbaki> anyone in here from the us?
07:56:58 <dash> yeah
07:56:59 <bourbaki> or in the us to be precise
07:57:09 <bourbaki> when does the election stuff start?
07:57:14 <dash> today, i guess
07:57:24 <bourbaki> yes but when :) what hour
07:57:51 <dash> which stuff do you mean 
07:58:10 <wolfman8k> is Adrian Hey here?
07:58:26 <bourbaki> broadcasting of the outcomes etc
07:58:46 <dash> probably it will be 8-12 hours from now
07:59:21 <bourbaki> wargh ok then i wont watch it
07:59:55 <psi_> perhaps in a month or so ;)
08:00:12 <Oejet> Yeah, they ought to put the election at a more EU friendly time.
08:00:31 <bourbaki> Oejet :)
08:00:46 <bourbaki> id watch it but ive got a lecture in the morning hours tomorrow
08:08:14 <CosmicRay> good morning
08:08:21 <Lemmih> Hey CosmicRay
08:20:10 <wolfman8k> anyone use Multimedia.SDL.Core?
08:22:25 <musasabi> Has autoincrement support been added to HaskellDB?
08:39:58 <Oejet> xkb: Any progress on your WxHaskell program?
08:40:38 <xkb> Oejet: some..not enough though..Im having problems reading a value from another element upon an event..
08:40:48 <xkb> anway,,  I gotta go. brb
08:43:36 <maihem> I'm looking at ordering a good book, would anybody recommend "The Haskell School of Expression" (as it is cheap in paperback and amazon will dispatch it in only 24Hrs)?
08:47:23 <kosmikus> it's ok
08:48:48 <maihem> Is there anything I would be better off spending my money on (In your opinion)?
08:50:02 <kosmikus> probably not -- I know, most of the other books are more expensive
08:50:19 <kosmikus> School of Expression is not bad at all, but it depends a bit on what you're looking for
08:51:12 <kosmikus> SOE is relatively application-oriented, having lots of examples involving graphics etc.
08:52:23 <maihem> I'm looking for productivity with reasonable performance knowledge. So I can translate my imperative ideas into functional code to take advantage of non-strictness, instead of fighting it.
08:55:27 <kosmikus> my impression is that all the books out there aren't doing a particularly good job when it comes to performance
08:56:51 <maihem> Well, I just want to figure out how to write functions that describe what I want to do, and then to (I think the word is) "lift" a monad up into the function to act as a cache - as a recent attempt of mine has so far proved fruitless
08:56:54 <kosmikus> the reason being that many performance-related issues require the use of libraries that are not part of the Haskell 98 standard (the FFI is still a relatively recent addendum, and the Haskell libraries have grown considerably during the last two years), or even GHC extensions (unboxed types, for instance)
08:57:02 <maihem> and that sort of thing
08:58:50 <maihem> I'm not looking for HPC stuff, just how to give my functions the time and space complexity I want, and to transform them from a simple logical description of an algorithm to a more complex one that fits other cases and hopefully some semblance of cache locality - without obfuscating the original code.
08:59:34 <maihem> So I can just, sort of, "dig in" without studing type theory.
09:10:31 <wolfman8k> ok i have a major problem
09:10:33 <wolfman8k> or not
09:10:43 <wolfman8k> how do i extract the first element from a tuple?
09:11:23 <emu> #1
09:11:27 <emu> or pattern match
09:11:31 <wolfman8k> #1?
09:11:34 <emu> oops, wrong lang
09:11:35 <emu> pattern match
09:11:42 <Igloo> If it's a pair you can use fst
09:12:01 <wolfman8k> Igloo: thanks!
09:12:32 <wolfman8k> how can i take 2 lists and make a new list that contains tuples of both lists?
09:12:40 <dash> zip!
09:12:44 <emu> zippity do da
09:12:52 <wolfman8k> [0,1,2] ['a','b','c'] ==> [(0,'a'),(1,'b'),(2,'c')
09:12:59 <wolfman8k> hm... zip
09:13:17 <wolfman8k> cool!
09:13:18 <tromp> zip [0..] mylist
09:13:48 <wolfman8k> tromp: sweet syntax! that's exactly what i need
09:14:02 <emu> they don't call it syntactic sugar for nothing
09:14:31 <wolfman8k> that's more then just syntax sugar. i think it's also lazy evaluation
09:15:00 <emu> semantic sugar
09:16:08 <emu> too much sugar, must go lo-carb!
09:16:16 <wolfman8k> :o
09:18:22 <wolfman8k> here goes nothing...
09:18:36 <wolfman8k> it works!
09:18:39 <wolfman8k> but it's shit slow~
09:19:54 <Igloo> What is it?
09:20:36 <wolfman8k> a raytracer
09:20:59 <wolfman8k> so much for my hopes for realtime :\
09:25:52 <wolfman8k> if i want to do some sort of summation, should i make a list with all the values and call sum on it, or calculate the sum as part of a recursive function?
09:27:20 <Igloo> If you wnt clarity, the former. For efficiency a recursive function with an accumulating parameter will probably be best
09:27:55 <Igloo> You might get a significant speedup if you switch to using strict datatypes. Also, profiling might help.
09:28:05 * Igloo doesn't have the time to give more detailed advice right now
09:29:31 <wolfman8k> k thanks
09:29:47 <wolfman8k> shouldn't the compiler be able to theoretically generate the same code though from both approaches?
09:31:04 <Igloo> No - they are semantically different
09:38:00 <wolfman8k> hm...
09:38:26 <wolfman8k> i think it's possible :D
09:40:41 <Igloo> In your particular case it might be possible to see everything is used by whole-program analysis, but it would be a fragile and probably slow analysis
09:42:45 <emu> wolfman8k: unless you already have the list, computing the list is an extra step that involves allocating yet more memory
09:43:51 <wolfman8k> right... right now i'm more worried about good coding practices then performance though
09:44:31 <Igloo> emu: The list may be optimised away, though
09:44:32 <wolfman8k> it just seems to me that strict evaluation means there is a lot of room for compiler optimization
09:45:11 <emu> Igloo: that really depends on whether it can be proven not to be closed over, and if "sum" has a compiler transform
09:45:52 <Igloo> "closed over"?
09:46:46 <maihem> wolfman8k, non-strict evaluation means that (if you code it right) the compiler can move part of one function into the middle of another, so the compiler can compose you simple and logical functions into complex performant functions. I just haven't figured out how to acheive it yet - looking for a good book.
09:47:43 <maihem> it just also means that the compiler can fill in a load of stuff to make a function allocate memory to be able to do what you asked without you realising how much memory your algorithm requires
09:48:05 <wolfman8k> that's the way it should be ;)
09:48:59 <emu> Igloo: in a closure
09:54:14 <maihem> perhaps complexity annonations would be helpful. Warning: composition "blah" at line thing breaks complexity target at line wotsit. But I dunno how reasonable it is for a compiler to work that out.
10:16:49 * CosmicRay peeks back in
10:33:09 <SyntaxNinja> hi CosmicRay
10:34:02 <CosmicRay> hello SyntaxNinja 
10:34:21 <CosmicRay> your code is in sid, so I can start sending you bug reports, bwahahaha :-)
10:34:31 <CosmicRay> oh wait, already have... :-)
10:34:36 <SyntaxNinja> yup
10:34:43 <SyntaxNinja> and I fixed it too, actually, but I have to upload it...
10:35:05 * SyntaxNinja fixed it in darcs, and just released an unversioned snapshot
10:35:11 <SyntaxNinja> s/just/last night
10:35:23 <CosmicRay> btw if you haven't downloaded 0.1-4.2, please make sure you start from that version
10:35:41 <CosmicRay> there was a bug in 0.1-4.1 that prevented it from building properly on !i386
10:36:23 <SyntaxNinja> ok
10:36:24 <CosmicRay> I think 0.1-4.1 is the one I e-mailed to you.
10:36:33 <CosmicRay> or you can just remove the build-dep on ghc5 yourself
10:36:45 <CosmicRay> I think that was just a remnant from earlier testing that I had forgotten to remove
10:37:49 <SyntaxNinja> np.
10:38:01 <SyntaxNinja> I am done with my move, mostly, so I should be able to hack more often
10:38:07 <SyntaxNinja> but then again I don't have internet access at home, sot hat's a bit of a PIA
10:38:24 <CosmicRay> moving always sucks
10:38:39 <CosmicRay> my wife and I hope to be in our current house for the next 60 years :-)
10:39:05 <Maddas> Won't moving suck even more in 60 years? :-P
10:39:09 <CosmicRay> heh
10:39:19 <CosmicRay> by then we won't be alert enough to notice :-)
10:39:41 <SyntaxNinja> heh
10:39:49 <SyntaxNinja> your kids will just "move" your stuff for you
10:39:58 <Maddas> heh
10:41:10 <SyntaxNinja> did all you americans vote yet?
10:41:15 <CosmicRay> I voted last week
10:41:40 <SyntaxNinja> hm. I fear that I'm going to have to release a new cabal version to do this right.
10:41:49 <CosmicRay> scary.
10:41:54 <dash> SyntaxNinja: not i
10:42:27 <CosmicRay> pfft dash
10:42:29 <CosmicRay> go vote
10:42:40 <dash> neither one of them is qualified
10:42:48 <dash> i don't know which oen will make me worse off
10:42:54 <CosmicRay> one of them?
10:42:58 <CosmicRay> candidates for president, you mean?
10:43:01 <dash> right
10:43:07 <CosmicRay> there's a lot more on the ballot than that
10:43:36 <dash> if there was anything i could vote against, i'd do it
10:43:42 <CosmicRay> everything from president to county commission, school board, township trustee in most places
10:43:59 <jadrian> hello
10:44:07 <dash> it'd be 4 hours' drive for me anyway
10:44:07 <CosmicRay> dash: if you truly think all the candidates for every office suck that much, you should run for office.
10:44:14 <CosmicRay> a 4-hour drive to vote?
10:44:15 <dash> CosmicRay: why?
10:44:23 <CosmicRay> dash: to make things better.
10:44:41 <dash> CosmicRay: Running for office can't make things better.
10:44:43 <CosmicRay> I could imagine a 4-hour drive if your method of transportation is a horse.
10:44:47 <CosmicRay> dash: why not?
10:45:13 <dash> CosmicRay: Because salvation does not come from the law.
10:45:26 <CosmicRay> salvation?
10:45:32 * CosmicRay never mentioned salvation
10:45:36 <dash> CosmicRay: well, hwoever you want to phrase it
10:45:37 <CosmicRay> I just mentioned improving things
10:45:42 <dash> right
10:45:51 <dash> that doesn't come from government either
10:46:05 <CosmicRay> the government certainly has a role
10:46:09 <tuomov> improving things means tearing down all current governments and other hierarchical authorities, if you ask me
10:46:13 <CosmicRay> they pave the road by the house
10:46:18 <dash> it does, but it isn't making things better
10:46:21 <CosmicRay> run the water
10:46:22 <CosmicRay> etc.
10:46:36 <CosmicRay> dash: well then, change it
10:46:43 <dash> CosmicRay: I'm doing what I can. :)
10:46:53 <CosmicRay> tuomov: you think anarchy is better than republicanism?
10:46:55 <Igloo> SyntaxNinja: Does cabal make it easy to build profiling versions of libraries too?
10:46:56 <dash> CosmicRay: Short version: democracy is a religion and I do not believe in it.
10:47:01 <CosmicRay> dash: sitting on your ass and not voting? :-)
10:47:07 <Igloo> I realised Debian needed that the other day
10:47:09 <dash> CosmicRay: heh
10:47:13 <tuomov> CosmicRay: yes, but people are not yet ready for it. they need to want to be free first.
10:47:23 <dash> tuomov: i want cookies
10:47:28 <dash> tuomov: does that count
10:47:32 <SyntaxNinja> Igloo: not in particular, no. you shoudl be able to just add it as a flag in the desciprtion file.
10:47:40 <CosmicRay> tuomov: I think it's been pretty well established that a successful large-scale anarchist society is but a utopian dream
10:47:47 <SyntaxNinja> dash: can I pick who you vote for, then?
10:47:58 <dash> SyntaxNinja: huh?
10:48:01 <dash> SyntaxNinja: no
10:48:04 <Igloo> SyntaxNinja: But it shouldn't /only/ build profiling libraries...
10:48:06 <tuomov> CosmicRay: no it hasn't. 
10:48:08 <CosmicRay> dash: I'm interested in your perspective.  Can you develop that "not a religion" comment a bit?
10:48:22 <dash> CosmicRay: eh? it _is_ a religion :)
10:48:48 <tuomov> in the current system people expect to be given order from above, and the system doesn't encourage people to decide everything for themselves
10:49:10 <tuomov> people should start taking matters more into their own hands
10:49:26 <CosmicRay> tuomov: what sort of matters?
10:49:53 <CosmicRay> dash: OK, let's grant you that for now, but what I don't follow is how you get from "democracy is a religion" to "dash doesn't vote" :-)
10:50:02 <dash> CosmicRay: well, first
10:50:06 <tuomov> authoritarian corporations should be replaced with more cooperative self-managed workplaces and so on
10:50:32 <dash> CosmicRay: what is the likelihood that my vote will affect the outcome of any of these elections? Practically zero.
10:50:35 <CosmicRay> tuomov: OK, I have no problem with that, but of course in an anarchist society, authoritarian corporations would be allowed to exist too
10:50:58 <tuomov> it would not be anarchist society then. No anarchist would want to work for a master.
10:51:02 <SyntaxNinja> Igloo: I haven't really thought about this much; if you send me a proposal, I can probably implement it in short order.
10:51:21 <dash> CosmicRay: So clearly, it is not practical calculation about the outcome of the election that would encourage me to vote
10:51:22 <tuomov> and that's the social transition that is needed.
10:51:30 <CosmicRay> tuomov: but how can you ensure that everyone is an anarchist without compulsion?
10:51:36 <Igloo> OK - I have a few more cabal things noted down to send you too. I'll try to do that tonight
10:51:57 <dash> CosmicRay: If I thought that there was anything near a possibility that I could cast a deciding vote in something, I'd take it seriously
10:52:09 <tuomov> of course there are always people who want to oppress others, but if the society in general doesn't condone such behaviour, what can they do?
10:52:25 <dash> CosmicRay: but there isn't, so I don't see a reason to do so 
10:52:30 <wolfman8k> sweet, my raytracer now does diffuse lighting!
10:52:32 * CosmicRay must afk
10:52:42 <tuomov> What can an anarchist do in the current society but work for a capitalist master?
10:52:47 <tuomov> it's no different
10:53:00 <tuomov> currently most people just go on with the system, even if it sucks
10:53:49 <tuomov> and people have really hard time accepting that alternatives are possible
10:53:58 <tuomov> it is natural of humans to resist change
10:54:47 <tuomov> but given the time, all kinds of changes happen
10:55:52 <maihem> most changes happen about every 50 years - as the policy setters that learned their policies 50 years ago start to retire or die
10:58:45 * CosmicRay returns briefly
10:59:15 <wilx> Huh.
10:59:35 <wilx> Thinking that your vote doesn't influence anything is wrong.
10:59:38 <wilx> It is not true.
10:59:53 <dash> it does not decide the election
10:59:56 <CosmicRay> tuomov: Of course alternatives are possible.  However, it seems anarchists always have a hard time defining how you keep the bad guys from running rampant
10:59:58 <dash> what other things are you thinking of?
11:00:15 <CosmicRay> dash: actually, I think it's hard to really agree with you with any philosophy
11:00:30 <dash> CosmicRay: hmm, how so
11:00:33 <tuomov> votes have very little influence in general policies. Even if representatives meant good, they can not always make the right decisions
11:00:40 <wolfman8k> lazy evaluation kicks butt!
11:00:45 <CosmicRay> dash: rule utiltarianism -- which would say that you ought to always act in accordance with the things that, as a rule, bring about greatest happiness -- would of course suggest you cast your vote for the best candidate
11:01:04 <CosmicRay> dash: act utilitarianism would suggest the same, unless there is some way that not voting would bring greater happiness
11:01:13 <CosmicRay> which would be hard to find, really
11:01:18 <tuomov> Finland does what Nokia says, etc.
11:01:23 <dash> CosmicRay: how about _your_ philosophy? ;)
11:01:37 <CosmicRay> I generally follow an act utilitarian point of view
11:01:37 <dash> (utilitarianism is silly, as i'm sure you know)
11:01:44 <CosmicRay> it has its faults
11:01:47 <CosmicRay> just like anything else
11:01:54 <CosmicRay> but it has the advantage of being more surely quantifiable
11:01:58 <dash> hah
11:02:04 <tuomov> Nokia says that they'll take their headquarters somewhere else if corporate taxes aren't lowered, and so Finland must lower taxes
11:02:18 <tuomov> it's not really in the hands of elected representatives
11:02:36 <wilx> Hm.
11:02:38 <wilx> Must?
11:02:56 <tuomov> Nokia makes a big part of Finland's gdp
11:03:07 <CosmicRay> dash: under which philosophy is it best to not vote?
11:03:15 <CosmicRay> and three whacks if you start quoting Marx :-)
11:03:19 <wilx> They can decide that they don't want to but usually lower corporate taxes means better environment for all companies thus better growth.
11:03:29 <dash> CosmicRay: if i start quoting Marx, just kill me now, k?
11:03:34 <CosmicRay> hehe
11:03:50 * Maddas scratches his head
11:03:51 <maihem> CosmicRay, the problem with most such philosophies is that they require global knowledge (ie, you need to know *which* candidate will actually make people happy)
11:04:06 <CosmicRay> true
11:04:12 <dash> CosmicRay: anyway, it's not even a philosophical issue yet
11:04:32 <dash> CosmicRay: because I am pointing out that my vote will not determine the outcome of the election
11:04:39 <CosmicRay> maihem: actually, that's a more general problem with utilitarianism (that one must have enough knowledge to calculate the happiness)
11:05:01 <CosmicRay> dash: but it is still a philosophical issue, especially to the rule utilitarian or some non-consequentialists
11:05:09 <dash>  
11:05:13 <tuomov> CosmicRay: ideally most bad guys would be kept in control by social pressure. Nobody will have to work for someone who would oppress them. Of course, dangerous people (who should mostly be insane people in a more equal society) may still have to be locked up.
11:05:17 <CosmicRay> dash: the rule-utilitarian is concerned with "what if everyone did foo"
11:05:34 <maihem> And I believe as long as there exists an ego we will not have anarchy, because *someone* will get more guns than you, then they are in charge of you, and there is a heirarchy (as opposed to the lack of rule: anarchy)
11:05:49 <CosmicRay> tuomov: indeed, and that implies a power, an authority to decide who is dangerous, and a detaining facility
11:05:50 <dash> CosmicRay: heh
11:06:03 <dash> CosmicRay: which is even sillier
11:06:14 <maihem> only in oblivion is there peace.
11:06:14 <CosmicRay> dash: so a rule-utilitarian would ask "what if everyone skipped voting", conclude the consequence is bad, and go vote.
11:06:26 <tuomov> CosmicRay: but there's no hierarchical authority. The community of the dangerous person decides what to do with him.
11:06:53 <dash> CosmicRay: I bet the rule utilitarian would never go to the beach, either
11:07:03 <CosmicRay> dash: grin
11:07:04 <tuomov> anarchy is bottom-up instead of top-down
11:07:10 <dash> because he would think "what if everyone went to the beach" and realize that it would be way too crowded
11:07:14 <dash> and so stay home 
11:07:24 <CosmicRay> tuomov: one could argue that a pure democracy is indistinguishable from that scenario
11:07:45 <CosmicRay> dash: perhaps he would just ask "what if everyone went to a beach" :-)
11:08:00 <tuomov> sort of. of course, anarchists also oppose the concept of property and other capitalist mechanisms.
11:08:11 <dash> CosmicRay: now you're changing the rules! ;)
11:08:14 <dash> CosmicRay: anyway
11:08:25 <mflux> "what if everyone went to my home"
11:08:33 <wolfman8k> check out my first haskell program, a 3d raytracer renderer:
11:08:33 <wolfman8k> http://img15.exs.cx/img15/9854/haskell-raytrace-01.png
11:08:35 <tuomov> property is not to be confused with personal possessions
11:08:38 <CosmicRay> tuomov: the problem with anarchists is that anarchy can only be successful if everyone is a good little anarchist
11:08:48 <dash> CosmicRay: let's try again. why should I vote? :)
11:08:49 <tuomov> not everyone, but most people
11:08:51 <maihem> anarchy is the absence of authority. If one person has more guns, more muscle, or more brains, there will be an authority, which will tend to structure itself until it causes its own demise, at an unpredictable time and with unpredictable effect. much like a sand dune collapsing as it builds up
11:09:00 <wilx> Yay! for the picture.
11:09:06 <dash> tuomov: so how do you calculate usage of secondary capital factors?
11:09:11 <flaw> anarchy, by any other name, would still smell like shit. (;
11:09:11 <wolfman8k> wilx: :D
11:09:22 <CosmicRay> dash: There is power in numbers.
11:09:35 <tuomov> maihem: in an anarchy, the population in general would not condone such 
11:09:36 <CosmicRay> dash: You, together with your peers, can make a difference.
11:09:36 <dash> CosmicRay: Explain?
11:09:41 <dash> CosmicRay: How so?
11:09:45 <Maddas> um
11:09:50 <wilx> When will I see classical three glass spheres on chessboard?
11:09:56 <CosmicRay> dash: example: the vietnam war.  
11:10:06 <wolfman8k> wilx: soon :D
11:10:11 <Maddas> wilx: The one they play in some Star Trek? :-)
11:10:14 <CosmicRay> dash: lots of discontent was brewing, but before the peace marches, nothing really got done about it
11:10:16 <wolfman8k> wilx: don't know how to chessboard though :/
11:10:19 <Maddas> Oh, no, those aren't spheres
11:10:24 <CosmicRay> dash; it's not that more people were dissatisfied
11:10:31 <Maddas> oh, I'm talking about something completely different anyway
11:10:32 <dash> CosmicRay: OK, but peace marches aren't the same as voting
11:10:33 <maihem> tuomov, there is no anarchy. The children answer to their parents. their parents answer to the local thugs, the local thugs answer to the rich guy that supplies them the drugs.
11:10:34 <wolfman8k> Maddas: ?
11:10:39 <CosmicRay> dash: rather that those that were dissatisfied were banding together to do something.
11:10:40 <tuomov> no society will stand up unless the majority of the people are good adherents to the dogmas of that society
11:10:51 <CosmicRay> dash: but it's what led to Nixon's election
11:10:52 <dash> CosmicRay: if you're going to argue that i should round up my friends and go march somewhere then that's one thing
11:10:57 <CosmicRay> heh
11:10:59 <dash> CosmicRay: but we're talking about voting, _per se_
11:11:06 <CosmicRay> yes
11:11:09 <tuomov> maihem: that's hierarchy, not anarchy
11:11:24 <maihem> yes, tuomov, I believe there is no anarchy.
11:11:35 <CosmicRay> voting does make a difference.  We had a situation here where a statewide race was decided by less than 20 votes 2 years ago
11:11:36 <maihem> besides total destruction of all ego.
11:11:42 <CosmicRay> that's a pretty small number
11:11:46 <dash> CosmicRay: so. do you grant that my vote, one way or another, will not influence the outcome?
11:11:50 <CosmicRay> no
11:11:55 <wilx> Hm, everybody should vote. I think that when you don't vote you have no right to later complain about anything.
11:12:02 <dash> wilx: Why not?
11:12:16 <CosmicRay> dash: because if I grant that about your vote, then I most grant that about every individual vote, and that is obviously false
11:12:21 <CosmicRay> (barring vote-rigging or fraud, of course)
11:12:47 <wilx> Because voting is like saying "I don't care."
11:12:53 <wilx> Ooops.
11:12:56 <dash> wilx: yep, and i do care
11:12:58 <wilx> Not voting of course.
11:12:58 <dash> so i don't
11:13:02 <dash> >:D
11:13:14 <wolfman8k> wilx: do you know how to render a checkerboard pattern?
11:13:16 <dash> CosmicRay: come, now, think of it economically. only the votes at the margin matter :)
11:13:36 <Maddas> wilx: No, it isn't. Voting might also be saying "I don't know which is better for me."
11:13:49 <CosmicRay> dash: pfft, economists are so wishy-washy :-)
11:14:00 <Maddas> dash: No
11:14:03 <dash> CosmicRay: most economists are govt thugs, true
11:14:11 <dash> Maddas: hmm?
11:14:13 <maihem> dash, your vote could decide democrat or republican. but it can't change the president's policy
11:14:14 <mflux> maddas, in that case, vote blank/invalid, and be a number?
11:14:22 <Maddas> heh
11:14:23 <CosmicRay> dash: either that, or they dream of the day when they can be a govt thug :-)
11:14:30 <tuomov> maihem: it is capitalism that destroys all real "ego" and individuality by making making money the goal of every human activity
11:14:31 <Maddas> dash: Why should only votes at the margin matter?
11:14:33 <wilx> Maddas, how so? Voting is like saying "I think this is the best for me and my future."
11:14:42 <maihem> unless you vote for the person that has no chance because his policy is too different.
11:14:48 <Maddas> wilx: Yes, and what if you don't know which is best?
11:14:57 <dash> CosmicRay: there are some serious economists who aren't wedded to the dole
11:15:03 <dash> http://mises.org/, etc
11:15:03 <wilx> Maddas, hence the "I think..."
11:15:08 <CosmicRay> dash: yeah I know
11:15:21 <wolfman8k> shouldn't you all be in #politics?
11:15:26 <mflux> wilx, so if you don't think you know which is the best, you could just toss a coin?
11:15:30 <dash> wolfman8k: heh heh
11:15:34 <Maddas> What mflux said
11:15:36 <CosmicRay> wolfman8k: we're too lazy.  This is haskell, remember :-)
11:15:41 <wolfman8k> har har
11:15:48 <maihem> tuomov, then you must kill everybody and institute a race of robot beings, with intellect far greater than our own :P
11:15:54 <Maddas> wilx: What if I am sure that I have no idea of which would be better? 
11:16:05 <CosmicRay> Maddas: I would suggest you should not vote in that case
11:16:07 <wilx> wolfman8k, I have zero knowledge about rendering. It is just that I remember this scene as being something classic :)
11:16:19 <wilx> Maddas, such situations don't happen.
11:16:20 <Maddas> CosmicRay: That's my suggestion too :-)
11:16:25 <wilx> It has never happened to me.
11:16:27 <maihem> money is not the goal, stability, power and idolism are
11:16:28 <wolfman8k> wilx: do you know about the classic "cornell box"?
11:16:34 <Maddas> wilx: I find myself in such a situation.
11:16:45 <Maddas> I have emotions about which I would like more, but I have no informed opinion.
11:16:49 <wilx> Even if either choice is not good there is usually one that is less evil.
11:16:53 <Maddas> (Of which would be what I would consider better)
11:16:54 <tuomov> maihem: no great intellect is needed. Just a real desire for freedom, for not to be told what to do all the time.
11:17:06 <dash> CosmicRay: anyway, i still can't answer the question "why should I vote when I cannot influence the outcome of the election"
11:17:08 <Maddas> wilx: of course there is a better choice, but what if I don't know which that is?
11:17:37 <dash> CosmicRay: in a local election where the voting pool is smaller and the race may be tight and I care who wins, then I can certainly see a reason to vote
11:17:51 <dash> CosmicRay: but in, say, the presidential election, i _know_ my vote will be meaningless
11:17:57 <wilx> Maddas, you can never be fully informed. My opinion is that you can never make fully qualified decision in anything as there will always be something that you won't know.
11:18:17 <maihem> tuomov, then you must cleans the earth of humanity, cos you ain't gonna get it. A more moderate policy designed to humour the egotistical may be effective.
11:18:17 <wilx> Think of some metrics that says who is better vote.
11:18:21 <Maddas> wilx: Sure, with "I don't know which that is" I mean something like "I have really no idea" :-)
11:18:27 <wilx> If that means that you will have to toss a coin then do it.
11:18:28 <flaw> bleh, every little helps, I say.
11:18:30 <wilx> But always vote.
11:18:55 <tuomov> maihem: so you think..
11:19:07 <Maddas> wilx: If I care about voting, I won't vote based on the toss of a coin.
11:19:12 <maihem> wilx, or deface your ballot to mark your dissatisfaction.
11:19:17 <Maddas> haha
11:19:29 <wilx> :)
11:20:07 <wilx> Maddas, think harder, there must be something that decides for you and it not being the coin.
11:20:24 <maihem> if all those people that didn't vote actually cared enough to go to the polling station and deface their ballot, everybody that was dissatisfied would feel validated. Then change could be effected. Ironically only by *not* voting
11:20:33 <wilx> The preferences are never really 1:1.
11:20:38 <wilx> It is too unlikely.
11:20:43 <wilx> Just decide.
11:20:43 <dash> maihem: why is that better than staying home?
11:20:45 <wolfman8k> is there a paste site that supports haskell?
11:20:46 <tuomov> the current situation where a majority of humanity is reduced to wage slavery for most of their lives is intolerable
11:21:04 <dash> wilx: well, the presidential race is a good example. i think they both dserve to lose
11:21:05 <dash> but one of them will have ot win
11:21:16 <maihem> dash, because everybody that thinks the same will realise that there are other people dissatisfied... perhaps enough to do something.
11:21:28 <flaw> tuomov: intolerable? by whom?
11:21:29 <tuomov> in the history, people weren't such heavily controlled as now
11:21:30 <dash> maihem: Eh? How so? 
11:21:59 <dash> maihem: why will they not realise this if don't go in the voting booth
11:22:06 <Maddas> wilx: The harder I think the more confident I am that me voting might do just as much harm as good.
11:22:06 <arjanb> wolfman8k: http://haskell.org/hawiki/HaskellIrcPastePage
11:22:09 <wilx> Is there any other candidate for president like than the tow?
11:22:13 <tuomov> flaw: everyone put the few percent at the top?
11:22:16 <wolfman8k> arjanb: thanks
11:22:18 <maihem> because it will be news, it will make people talk about "How come so many people want neither of you?" instead of "How can we make them come to the polls?"
11:22:25 <Maddas> wilx: Actually, it is *more* likely to do harm :-)
11:22:34 <Maddas> wilx: Although I am obviously not even sure about that.
11:22:48 <wilx> How can it make harm?
11:22:58 <flaw> tuomov: I would think that is incorrect. I think the majority of people are quite content as long as they get their check at the end of the week.
11:22:59 <Maddas> Voting for something I wouldn't want to
11:23:18 <Maddas> And whether I want to or not, well, I do at least want to be a little informed about politics before deciding that
11:23:31 <wilx> Bah.
11:23:34 <wilx> Go get informed.
11:23:37 <wilx> Then decide.
11:23:40 <musasabi> Voting for third parties is imho the most sensible thing to do in the US.
11:23:40 <maihem> the media thinks the lack of turn out is because people aren't bothered. if they aren't bothered then why change. invalidating you ballot (and getting others to do the same) shows that you *do* care.
11:23:41 <wilx> It is your future.
11:23:42 <tuomov> flaw: because they're too tired from endless toiling to do anything about it.
11:23:49 <Maddas> wilx: Oh, yes, I do plan to do that.
11:24:05 <Maddas> (Not meant sarcastically)
11:24:12 <wilx> :)
11:24:34 <flaw> tuomov: they are content because they are too tired?
11:24:37 <Maddas> I do also think that most voters out (t)here are even less informed than me, though :-)
11:24:46 <Maddas> Or at least many.
11:24:48 <maihem> flaw, worked for the matrix
11:24:54 <tuomov> flaw: it's easier to go along with the system
11:25:33 <flaw> tuomov: the system has been at least 2000 years in the making, of course it is.
11:25:45 <dash> maihem: there's no reason to believe it would get reported in the media
11:25:50 <tuomov> the current wage slavery system has been around less than 200 years
11:26:13 <tuomov> before that, there were more free peasants and artisans
11:26:32 <tuomov> guess why marxism and anarchism etc. was born in the 1800's?
11:26:52 <maihem> dash, here in the UK, elections are reported with votes for each candidate, and invalid ballots. A massive number of invalid ballots with the same message on them would certainly get reported because the reporters want prestige
11:26:57 <tuomov> and back the, people were really opposed to wage slavery.. now everyone just takes it for granted
11:27:01 <tuomov> s/the/tne/
11:27:11 <dash> maihem: america is broken 
11:28:00 * CosmicRay returns
11:28:38 <CosmicRay> tuomov: you think that being a peasant in the 1700s was better than being a "wage slave" today?
11:28:50 <flaw> hehe
11:29:04 <tuomov> in the sense that you weren't subject to so much authority every day, yes
11:29:19 <CosmicRay> tuomov: I'm not sure that's true, really.
11:29:28 <tuomov> of course the situations aren't directly compatible with much less technology around those days and so on
11:29:33 <CosmicRay> tuomov: you piss off your duke and things coudl be pretty dire
11:29:35 <tuomov> s/compatible/comparable/
11:29:36 <flaw> tuomov: what part of authority do you dislike? specifically? not just the feeling that you are controlled..?
11:29:47 * flaw is curious
11:29:54 <dash> well. i do think we'd be better off without the concept of 'nation-state'
11:30:02 <tuomov> CosmicRay: now there's state and workplaces. then there was just the state.
11:30:25 <tuomov> and much earlier, even the state didn't matter much.
11:30:30 <CosmicRay> tuomov: state really sucked back then.  and workplaces existed too.
11:30:42 <CosmicRay> tuomov: state has existed for thousands of years
11:30:45 <dash> tuomov: ever heard of guilds? :)
11:30:48 <CosmicRay> greece?  babylon?
11:30:50 <CosmicRay> rome?
11:30:53 <CosmicRay> egypt?
11:30:56 <CosmicRay> china?
11:30:58 <CosmicRay> mongolia?
11:31:25 <musasabi> state has been really different and more distant from the people in the past.
11:31:40 <CosmicRay> musasabi: no, it just took a different form
11:31:51 <CosmicRay> less centralized, surely
11:32:13 <tuomov> flaw: all hierarchical authority. 
11:32:27 <flaw> tuomov: huh?
11:32:29 <CosmicRay> but if you failed to pay your taxes in ancient Jerusalem, you're still at risk of losing a life and limb because the Romans will find out
11:32:41 <CosmicRay> even though their power was derived from an extremely remote location
11:32:42 <tuomov> flaw: the fact that someone has a right to tell you what to do backed by a police force
11:33:36 <bourbaki> The whole problem with the world is that fools and fanatics are always so certain of themselves, but wiser people so full of doubts.
11:33:48 <flaw> tuomov: you didn't care for your parents much, as a child, eh?
11:33:51 <tuomov> the fact that I practically much work for a corporation where I have no say in the content of my work
11:33:56 <CosmicRay> tuomov: but let's say that your anarchist community, that acts as police officer, judge, jury, and executioner in your hypothetical dealing-with-really-bad-guys example, decides it's in their best interests to nominate a few from their number to fill those rules on behalf of the hole
11:33:58 <tuomov> s/much/must/
11:34:05 <wilx> Huh.
11:34:06 <CosmicRay> tuomov: you get very close to what we really have
11:34:10 <wilx> This is bs.
11:34:23 <wilx> You can go and be homeless and unemployed.
11:34:30 <bourbaki> anarchy is something against human nature
11:34:31 <wilx> Or you can start your own company.
11:34:36 <tuomov> wilx: zand that's a real alternative, right
11:34:56 <wilx> Also who backed by police force forces you to do what?
11:35:04 <wilx> tuomov, it isn't?
11:35:12 <wilx> Or are you just too lazy?
11:35:19 <Maddas> Maybe tuomov was forced to say that ;-)
11:35:38 <Maddas> (never mind me)
11:36:29 <Maddas> I didn't mean to kill conversation...
11:36:32 <wilx> Also if you don't like being told what to do in any company try to reach for such post to be the one who decides the course.
11:36:38 <tuomov> CosmicRay: those few can leave the community. and if they're prevented from doing that. Well, then other communities as they find out should do something about that or else they do not really value anarchy
11:37:03 <CosmicRay> tuomov: you speak as if anarchy is an end in itself
11:37:14 <tuomov> the authorities can do the same sort of game right now
11:37:16 <CosmicRay> tuomov: when in reality, the only reason to embrace it is as a means towards happiness
11:37:52 <monochrom> jolism: the -ism of being joly
11:38:01 <bourbaki> :)
11:38:59 <bourbaki> Reality is merely an illusion, albeit a very persistent one.
11:39:25 <CosmicRay> tuomov: if it happens that a nonpure form of anarchism brings about greater happiness -- perhaps because society as a whole is relieved of a burden they are poor at performing -- then it would make sense that an uncontrolled society would gravitate towards it
11:39:39 <maihem> tuomov, those other communities will not permit themselves to tell another community what to do as that would not be anarchy. It won't work. Acts of pure human kindness create heirarchies.
11:39:45 <CosmicRay> thus true anarchy can only have a fleeting existance so long as society does not think of things to make their life better.
11:40:01 <tuomov> anarchy is not written in stone. it is something that is when there are no hierarchical authorities present
11:40:09 <maihem> maybe you are looking for a polyarchy
11:40:23 <maihem> We have a polyarchy now, but it means putting up with war.
11:40:33 <bourbaki> the brain is structured top down buttom up
11:40:48 <bourbaki> so its quite natural for society to do the same
11:41:16 <maihem> Locally to the USA there is a oligarchy (the money rules, essentially, but there is a better description that I am nnot capable of providing)
11:41:19 <tuomov> maihem: huh? it is anarchy of the other community is not hierarchically above the other
11:41:55 <maihem> if the other community can *free* the anachists from the first, then it *is* heirarchically above the other (or you have a polyarchy and war)
11:41:56 <bourbaki> the prob is knowledge and money
11:41:57 <tuomov> s/of/if/
11:42:21 <dash> mmm, irc arguments about religion
11:43:37 <tuomov> maihem: no. the other community has no inherent authority over the other. No person has authority backed by some greater force over another. 
11:44:25 <Philippa> can't happen
11:44:31 <Philippa> somebody'll be physically more capable
11:45:44 <tuomov> CosmicRay: of course, if everyone could be happy in some other kind of system, it would be a worthy goal... no-one has proposed such a system. 
11:45:51 <wolfman8k> who puts the funk in funktion?
11:46:10 <SyntaxNinja> HASKELL! HASKELL!
11:46:20 <maihem> If one community has the ability to enforce a law (like "you must free those people") then it has an inherent authority over the other. Otherwise you have a polyarchy. Only when the anarchists organise themselves into a simple mob that just happens to work together would it actually be an anarchy
11:46:31 <maihem> heh
11:46:33 <maihem> sorry
11:49:28 <wolfman8k> haskell puts the funk in malfunktional
11:50:05 <tuomov> maihem: If the other community constantly wants to involve itself in the matters of the other, and has the power to do so. Then, yes, we have hierarchy. But if it can't (because other communities would not watch it) or won't (because it doesn't care as long as no human is oppressed), it is anarchy
11:50:22 <maihem> tuomov, I will happily continue in PM
11:51:11 <CosmicRay> SyntaxNinja: data gvmt = Anarchy | Despotism | Monarchy | Republicanism | Democratic deriving (Eq, Ord, Show)
11:51:26 <maihem> actually, no, sorry, I'm bored.
11:51:28 <CosmicRay> heh
11:51:40 <dash> see, this is why i don't like haskell
11:51:45 <dash> types are not extensible at runtime 
11:52:03 <SyntaxNinja> CosmicRay: don't try to drag me into this discussion
11:52:07 <CosmicRay> heh
11:52:27 <wolfman8k> dash: can you emit new code at runtime?
11:52:34 * CosmicRay idly wonders what the effect of a cabal on an anarchistic society would be.... <grin>
11:52:54 <maihem> dash, that is what mapping types are for.
11:53:18 <maihem> I think. no... The ST monad, yes?
11:53:20 <dash> wolfman8k: in haskell? probably not
11:53:27 <dash> wolfman8k: another unfortunate thing!
11:53:35 <CosmicRay> dash: I don't think that's bad.
11:53:44 <dash> CosmicRay: OK
11:54:02 <dash> i still want it
11:54:16 <tuomov> maihem: if you have anything more to say, please PM
11:54:20 <maihem> The only thing adding types does is let you get OO style polymorphism (with vtables). You can do that with the ST monad.
11:54:58 <wolfman8k> anyone wanna see my raytracer code? it's only 70 lines of functional haskell
11:55:16 <maihem> wolfman8k, yes please
11:55:28 <wolfman8k> http://rafb.net/paste/results/om3kWc20.html
11:55:30 <dash> maihem: well, you kinda need it if you're going to add code at runtime too 
11:55:54 <dash> or modify existing code
11:56:10 <wolfman8k> speaking of OO style polymorphism....
11:56:28 <wolfman8k> my raytracer has a "raytrace" function that takes as a parameter a Scene value
11:56:43 <wolfman8k> my Scene value has a field that is a list of Sphere values
11:56:55 <wolfman8k> the thing is, i want to add new geometry types, Box, Triangle, Plane
11:57:14 <wolfman8k> but i don't want to litter my Scene data structure with the details of each type
11:57:30 <wolfman8k> is there a way to use OO style polymorphism, and have the Scene value contain a list of abstract "Shape" types?
11:57:54 <dash> maihem: hell me about the ST monad
11:57:56 <dash> s/h/t/
11:58:10 <maihem> wolfman8k, data (Shape a, Shape b) => CSG a b = Union a b | Diff a b | Intersect a b;
11:58:22 <wolfman8k> maihem: hm....
11:58:26 <wolfman8k> maihem: btw, did you see the screenshot?
11:59:13 <maihem> maihem I don't know a lot, but you bassically use something like do { a <- newSTRef 5; b <- readRef a; writeRef a b; } or something like that, I forget the details.
11:59:24 <wilx> Hm, is there a reason not to use (**)?
11:59:56 <maihem> "newSTRef type" makes a thing that when given as an argument to readRef evaluates to an "ST type"
12:00:03 <maihem> it's sort of a "special" monad
12:00:28 <dash> that doesn't really reduce my confusion :)
12:00:34 <wolfman8k> maihem: incase you missed it: :)
12:00:35 <wolfman8k> http://img15.exs.cx/img15/9854/haskell-raytrace-01.png
12:01:14 <wilx> In e.g. squaredDistanceP3?
12:01:15 <maihem> wolfman8k, nicely done
12:01:30 <wolfman8k> wilx: hm... hm?
12:01:34 <wolfman8k> maihem: danke
12:01:41 <wilx> Why don't you use **?
12:01:51 <wolfman8k> exponent?
12:01:55 <wilx> Yes.
12:02:07 <wolfman8k> wasn't sure about performance
12:02:11 <wilx> Oh.
12:02:25 <wilx> Well, did you profile? </anal>
12:02:55 <wilx> Though I am no Haskell guru. Just that it seems strange to me :)
12:03:11 <wolfman8k> no, but i figure that exponent operator probably uses an expensive algorithm
12:03:23 <wolfman8k> wilx: btw, i tryed to use function composition in distanceP3
12:03:35 <wolfman8k> wilx: but couldn't get it to work :/
12:05:03 <maihem> dash, check the functions, but if you do: do { a <- newSTRef 5; b <- readRef a; writeRef a (b+1); readRef a; } you make a thing that you can access via the name "a" initialised with 5, then you read the value and refer to it with the name b, then you save its increment into the then that a refers to, then you can read from a and get the new value (which this example just returns out of the do)
12:05:11 <Oejet> wolfman8k: If you haven't already tried it, then find out how to profile. It's very easy.
12:05:52 <wolfman8k> Oejet: i think i will need to. this app runs dog slow :(
12:06:35 <wolfman8k> and this is only with 4 spheres and 2 lights!
12:06:44 <Oejet> wolfman8k: ghc -profile -auto-all. Then run with: a.out +RTS -p.
12:06:52 <wolfman8k> i don't know what's gonna happen when i have reflections and refractions and hundreds of objects :O
12:07:12 <wolfman8k> Oejet: cool i'll try it
12:08:42 <Oejet> wolfman8k: Try "-O2". Could you post timings with and without strictness annotations (!Double)?
12:09:13 <wolfman8k> Failed to load interface for `Multimedia.SDL.Core'
12:10:05 <wolfman8k> Oejet: ok, but i'm gonna disable the graphical output first
12:10:22 <wolfman8k> Oejet: have the IO of the program consist only of a single print call
12:18:23 <Lemmih> Hey Boegel
12:18:39 <arjanb> Boegel: you have a concurrent in wolfman8k :)
12:19:28 <wolfman8k> how can i force a value to be computed, without printing it?
12:20:44 <Boegel> arjanb, why ?
12:21:44 <arjanb> he is making a raytracer too
12:21:45 <wolfman8k> arjanb: huh?
12:22:37 <wilx> Hmmm...
12:22:40 <maihem> wolfman8k, seq, I think
12:23:00 <wilx> You can't use . because it only takes functions that take one parameter...
12:23:04 <wilx> I guess.
12:23:26 <jadrian> wolfman8k: depends on the value
12:23:28 <wolfman8k> what is Word8 type?
12:23:45 <Philippa> an 8 bit word
12:23:51 <jadrian> wolfman8k: what are you computing?
12:24:02 <wolfman8k> Boegel: i coded today my first haskell program, a raytracer! :D
12:24:22 <Oejet> wolfman8k: You should profile your complete program. This way you'll know if the printing is signifficant.
12:24:23 <wolfman8k> Philippa: where does it come from?
12:24:37 <wolfman8k> wilx: i see. cool thanks
12:24:40 <Philippa> can't remember exactly. Probably something like Data.Word...
12:24:46 <Philippa> flick through the docs for the hierarchical libs
12:24:47 <Boegel> wolfman8k, are you really coding a raytracer ?
12:24:50 <wolfman8k> jadrian: it's a list of a list
12:25:02 <jadrian> wolfman8k: then seq alone won't help you
12:25:08 <Spark> heh
12:25:12 <wolfman8k> Oejet: right now i want to focus on the actual calculation performance though, not the input/output performance
12:25:29 <wolfman8k> Boegel: yeah, here is a screenshot of my first version, from earlier today:
12:25:31 <jadrian> wolfman8k: seq just reduces the value to head normal form
12:25:37 <wolfman8k> http://rafb.net/paste/results/L2ZBBN74.html
12:25:50 <jadrian> wolfman8k: make a search on deepsec
12:25:56 <wolfman8k> jadrian: right now i am printing the value, but it's huge! it's 16 MB of text!
12:26:09 <Boegel> wolfman8k, you're doing a text based raytracer ? :)
12:26:22 <Philippa> somebody been calculating fac 2^1024?
12:26:23 <Oejet> wolfman8k: Could you just render to screen and exit at once?
12:26:25 <wolfman8k> Boegel: no, that was before i was able to get any graphics libs working. here's what i now have:
12:26:29 <wolfman8k> http://img15.exs.cx/img15/9854/haskell-raytrace-01.png
12:26:40 <wolfman8k> Oejet: yeah, but my rendering code is slow i think
12:26:51 <Boegel> wolfman8k, that's your first time in Haskell?
12:27:13 <wolfman8k> Boegel: yes
12:27:19 <maihem> wolfman8k, for printing long arrays, mapM_ is handy - provided that you can calculate the first bits first, and the last bits last.
12:27:24 <wilx> Hm, is it a good style to use sequences of lets?
12:27:27 <maihem> s/arrays/lists
12:27:31 <Boegel> wolfman8k, have you written a raytracer before ? or is this your first ?
12:27:46 <wolfman8k> Boegel: first
12:27:57 <Boegel> wolfman8k, omg, you're going fast with this :)
12:27:58 <wolfman8k> Boegel: but i've done lots of graphics programming
12:27:58 <Philippa> wilx: depends what you're doing
12:28:03 <wolfman8k> Boegel: here is the code:
12:28:06 <Boegel> wolfman8k, oh, like that :)
12:28:07 <wolfman8k> http://rafb.net/paste/results/om3kWc20.html
12:28:11 <wilx> Looking at wolfman8k's raytracer.
12:28:25 <Philippa> where reasonably possible I tend to dump stuff in a where below the toplevel dec and mebbe parameterise a bit, but YMMV
12:28:34 <Philippa> "good style" can be summed up as "is it clear what the code does?"
12:28:41 <maihem> Heh, I wrote one in Visual Basic... Then Matlab. The ironic thing was that I just traced triangles in the matlab one, when it couldv'e done spheres and whatnot for me, really quick
12:29:27 <Boegel> wolfman8k, looks neat :)
12:29:39 <wolfman8k> Boegel: thanks
12:29:50 <Boegel> wolfman8k, can you give me the coordinates of the 3 spheres in your image + the info on the light ?
12:30:03 <Philippa> wilx: ah, the nesting doesn't seem necessary there
12:30:08 <Boegel> I'll try it in my ray tracer, because the lighting seems a bit odd in your image
12:30:23 <Philippa> looks like it's written by an ML coder who doesn't realise Haskell's let is ML's letrec ;-)
12:30:29 <wolfman8k> Boegel: i think the lighting is correct
12:30:54 <Boegel> wolfman8k, probably, since you're used to writing graphics stuff, but I'm not, so maybe my lighting isn't correct :p
12:30:59 <wolfman8k> Philippa: are you talking about my code?
12:31:04 <Boegel> wolfman8k, which shading model do you think on using ?
12:31:18 <wolfman8k> think on?
12:31:32 <wolfman8k> right now it's using standard diffuse
12:31:36 <Boegel> wolfman8k, you'll go on with this ? now you only have diffuse reflection...
12:31:37 <Spark> gourard :s
12:31:39 <Spark> aw
12:31:44 <wolfman8k> Boegel: right
12:31:47 <Spark> bump map it
12:31:52 <Boegel> wolfman8k, there's Phong, there are others ...
12:31:55 <Spark> that looks shit hot in doom3
12:31:56 <wolfman8k> Boegel: right
12:32:13 <Boegel> wolfman8k, which one will you be using ? or won't you continue with this ?
12:32:15 <wolfman8k> Boegel: i'm thinking of implementing a shading language for materials
12:32:29 <Philippa> wolfman8k: you don't have to use a new let statement for each declaration
12:32:33 <wolfman8k> Boegel: but for now i will stick with diffuse
12:32:38 <Philippa> even if one of the declarations depends on one of the others
12:32:47 <wolfman8k> Philippa: hm...
12:32:57 <wolfman8k> Boegel: i'm gonna try adding reflections and refractions
12:33:23 <wolfman8k> Philippa: vim doesn't seem to indent haskell code, so that's why the layout might be a bit messy
12:33:23 <Philippa> wolfman8k: let foo = bar
12:33:27 <Philippa>     baz = quux in ...
12:33:30 <Philippa> works fine
12:33:31 <Boegel> wolfman8k, what about specular reflection ?
12:33:48 <Boegel> and shadows ?
12:34:01 <wolfman8k> Boegel: shadows i will do. they are easy i think. don't know about soft shadows though
12:34:09 <wolfman8k> Philippa: cool thanks
12:34:27 <wolfman8k> Boegel: i don't plan on making this a proffesional raytracer, i just started it to learn haskell :D
12:34:31 <Boegel> wolfman8k, neither do I (about the soft shadows)
12:34:43 <Boegel> wolfman8k, do you know what I'm doing ?
12:34:47 <wolfman8k> Boegel: no
12:34:55 <Philippa> wolfman8k: fair enough, I figure you're finding it easier to work with than C++?
12:35:08 <wolfman8k> Philippa: it's "different" :P
12:35:25 <Boegel> wolfman8k, I'm writing a raytracer in Haskell for my thesis
12:35:31 <wolfman8k> Boegel: cool
12:36:37 <Boegel> wolfman8k, how long have you been working on this ?
12:37:44 <emu> Boegel: thesis? what degree?
12:37:53 <wolfman8k> Philippa: do you know how i can make it so that i can do: x+y instead of x `plusP3` y for P3 values?
12:38:02 <wolfman8k> Boegel: maybe 8 hours total
12:38:12 <wolfman8k> Boegel: but a lot of that time was spent on stupid little things
12:38:31 <wolfman8k> Boegel: and a lot of it was spent trying 3 different graphics libraries, and finally getting SDL to work, then figuring out how to use it :)
12:38:35 <Boegel> I worked longer than that to get where you are now
12:38:50 <Boegel> wolfman8k, SDL ?
12:39:02 <wolfman8k> Boegel: yeah, it's the only thing i could get working
12:39:21 <wolfman8k> http://homepages.nildram.co.uk/~ahey/HLibs/Multimedia.SDL.Core/
12:39:42 <wilx> Hmm, I guess that P3 would have to by instance of Num and that has some functions that are hard to define for vectors.
12:39:48 <wolfman8k> i've done lots and lots of graphics programming before though in c/c++/c#
12:39:55 <wolfman8k> wilx: hm...
12:40:34 <wilx> Iirc the usual solution is to use own set of operators.
12:41:02 <wolfman8k> like |+| or something?
12:41:08 <wilx> I guess so.
12:41:34 <wilx> Damn, I shouldn't be giving advices to anybody, I really haven't done anything in Haskell yet.
12:41:50 <wilx> I've been walking around it like 4 years now.
12:42:07 <wilx> But never really have done anything.
12:42:41 <Oejet> wilx: Do a raytracer! It only takes about eight hours. ;-)
12:42:46 <wilx> :))
12:42:57 <wilx> I know nothing about ray tracing :)
12:43:04 <dash> wilx: i would like your advice
12:43:06 <Maddas> I haven't done anything either yet.. ;-)
12:43:21 <Oejet> wolfman8k: How's the profiling coming along?
12:43:32 <wolfman8k> Oejet: almost got it working i think
12:45:10 <wilx> Only recently, like the day I have joined here, I have grassped on the concept of monads.
12:45:21 <Boegel> wolfman8k, how do you use SDL in your raytracer ?
12:45:51 <wolfman8k> Boegel: i have a "master" raytrace function that returns a list of lists of RGB values
12:46:17 <wolfman8k> Boegel: i apply each of these to the screen as a pixel
12:46:28 <Boegel> wolfman8k, so do I
12:46:45 <Boegel> but I write an image, using a writePPM function that creates a PPM file for me
12:49:02 <wilx> dash? :)
12:49:57 <Oejet> Boegel: What was the result of your profiling?
12:50:46 <Boegel> Oejet, I haven't really profiled since i continued with writing (diffuse reflection, shadows, ...)
12:50:47 <dash> wilx: i am working on some code that i started in 2002 and i can't see the problems with the style anymore. :)
12:50:54 <Boegel> I should do it again
12:51:19 <Boegel> but when I had no lighting yet, the most used function was createPPM, the function which writes the image file
12:52:06 <Boegel> anyway, I'm going to bed
12:52:57 <dash> wilx: http://ghostwheel.ddts.net/~washort/arnis.hs
12:53:06 <Oejet> It's 22:00 at your place right Boegel?
12:53:19 <dash> wilx: the parser is my fault, but the interpreter below is from Queinnec :)
12:54:22 <Boegel> Oejet, idd
12:54:28 <wolfman8k> Boegel: i would have settled for a function like that :)
12:54:39 <wolfman8k> Boegel: it was really frustrating trying to get HGL to work
12:55:01 <wolfman8k> Boegel: and them i tried using these Imlib2 bindings that supported saving an image
12:55:05 <wilx> Huh.
12:55:07 <Boegel> wolfman8k, I don't understand you got diffuse reflection working that well in such short period of time
12:55:10 <wilx> *confused*
12:55:28 <wolfman8k> Boegel: it's a pretty simple formula i guess :/
12:55:46 <wolfman8k> Boegel: anyway, the cool thing about using SDL is that i can see the image get rendered
12:55:46 <dash> wilx: keep in mind that i am a lisp and python hacker and that i am porting this interpreter from scheme :)
12:55:54 <dash> wilx: tell me what confuses
12:55:59 <Boegel> wolfman8k, I know, but I try to write the program is such a way that I can expand it easily
12:55:59 <wolfman8k> Boegel: it looks like a browser downloading an image :)
12:56:12 <Boegel> new objects, new shading abilities, and so on
12:56:16 <wolfman8k> Boegel: yeah, my code write now is not very expandable
12:56:20 <Boegel> wolfman8k, that's really nice
12:56:28 <wilx> Just tell me how have I become Haskell style specialist :)
12:56:35 <Boegel> wolfman8k, I would love something like that...
12:56:49 <wolfman8k> but what really impressed me was that i didn't have to modify my raytracing code so that it would progressively render. haskell's lazy evaluation does it automatically!
12:57:03 <Boegel> wolfman8k, but I'm planning to use the FranTk library, I'll have to see how that is possible in that library
12:57:12 <Boegel> wolfman8k, nice :)
12:57:25 <Boegel> wolfman8k, that's a good point for my thesis :)
12:57:27 <dash> wilx: you have known haskell for 4 years!
12:57:32 * Boegel takes a pen :p
12:57:36 <wilx> Hehe.
12:57:48 <wilx> Well, I also said that I haven't really done anything :)
12:58:22 <shaleh> hey all
13:00:06 <Lemmih> Hello shaleh
13:00:23 <CosmicRay> good afternoon
13:06:11 <Boegel> good night everyone ! and wolfman8k, good luck with your raytracer
13:06:16 <Boegel> I'm jealous already ;à
13:07:05 <Boegel> wolfman8k, http://studwww.ugent.be/~kehoste/thesisPublic/website
13:07:24 <Boegel> some images from my ray tracer :)
13:10:13 <Boegel> out now :)
13:17:00 <wagle_gone> wolfman8k: you are using unsafe io?
13:17:14 <wolfman8k> wagle_gone: i don't think so
13:17:52 <wagle_gone> then why would lazy evaluation progressively render?
13:18:21 <wagle_gone> you using monads?
13:18:36 <wolfman8k> yes
13:18:39 <Etaoin> rendering involves no IO probably
13:18:42 <wolfman8k> i think
13:18:57 <wolfman8k> Etaoin: it actually does
13:19:03 <Etaoin> wolfman8k: doing what?
13:19:33 <wolfman8k> Etaoin: i'm using SDL in a way that's not optimal
13:19:42 <wolfman8k> Etaoin: i'm doing individual pixel writes
13:19:48 <wolfman8k> Etaoin: instead of block data transfers
13:20:03 <wagle_gone> if laziness is whats ordering the rendering effects, i >think< you are using unsafe io..  if your monads are whats ordering things, then thats much more satisfactory
13:20:07 <wolfman8k> Etaoin: but overall the overhead is minimal compared with the performance of the rest of the app
13:20:19 <wolfman8k> wagle_gone: my monads are indeed what is ordering things
13:20:40 <wolfman8k> wagle_gone: my io code simply plots each pixel of the image in sequence
13:20:41 <wagle_gone> so laziness has "nothing" to do with it..
13:20:48 <jadrian> wagle_gone: by the way I forgot to mention this: http://users.aber.ac.uk/afc/stricthaskell.html
13:20:51 <jadrian> opssss
13:21:01 <wolfman8k> wagle_gone: thanks to laziness, the rendering is progressive instead of one-shot
13:21:05 <jadrian> wolfman8k: by the way I forgot to mention this: http://users.aber.ac.uk/afc/stricthaskell.html
13:21:42 <jadrian> wolfman8k: see the section on seq, deepSeq and strategies
13:21:48 <Etaoin> well the calculation for what color a specific pixel should be can be completely lazy, no?
13:21:51 <wolfman8k> jadrian: hm... interesting thanks
13:22:00 <wolfman8k> Etaoin: yes
13:22:07 <wolfman8k> Etaoin: the final image is simply a list of pixels
13:22:13 <wagle_ungone> wolfman8k: oic
13:22:36 <wolfman8k> if none of the values in the list are used, then the entire render operation is lazilly nothing
13:22:52 <wolfman8k> but as each pixel is plotted, some calculations are performed
13:24:10 <wolfman8k> brb
13:25:20 <Oejet> wolfman8k: Show us the profiling. :-) I can help you interpret the result.
13:31:26 <wolfman8k> Oejet: this damn Word8 type is holding me back. i don't know what to import to make it available
13:31:40 <Lemmih> Data.Word
13:31:45 <Lemmih> @index Word8
13:31:45 <lambdabot> Data.Word,Foreign,GHC.Word,Word
13:32:10 <wolfman8k> so what should i import then?
13:32:22 <Lemmih> You should import Data.Word
13:32:41 <wolfman8k> ah, ok thanks
13:33:21 <wolfman8k> Oejet: bbias and then i give hyou the result
13:39:58 <dash> hmm. i wish there was an unzipWith :)
13:40:40 <dash> i have a Binding type with Name and Val fields and would like to turn a list of them into a list of names and a list of vals
13:40:50 <dash> shoudl i just give up and change it to be a tuple? :)
13:44:59 <Oejet> dash: blob :: [Binding] -> [(Name, Val)]
13:46:10 <Oejet> blob l = map (\{name, val} -> (name,val) ) l
13:46:51 <Oejet> Here {name, val} is the constructor for your Binding type.  How is Binding defined?
13:48:16 <Oejet> dash: Sorry, I must be getting tired. But you can use the idea maybe.
13:48:25 <dash> well it's an obvious idea
13:49:24 <dash> i just didn't feel like writing yet another function ;D
13:49:29 <wolfman8k> Oejet: problem
13:49:31 <Etaoin> ooooh, snap!
13:49:31 <wolfman8k> hrayt.o(.text+0x1b): In function `__stginit_Main_':
13:49:32 <wolfman8k> : undefined reference to `__stginit_Prelude_'
13:49:32 <wolfman8k> hrayt.o(.text+0x25): In function `__stginit_Main_':
13:49:32 <wolfman8k> : undefined reference to `__stginit_DataziWord_'
13:49:47 <dash> wolfman8k: mmmm linker errors
13:50:47 <wilx> Is the module where your main is named Main?
13:50:58 <wolfman8k> wilx: hm.... dunno
13:51:34 <wolfman8k> weird, it worked now
13:51:36 <wilx> Err, maybe it is not the cause... I thought it was the same I had problems with too.
13:52:00 <wolfman8k> Oejet: ok, i'm ready to roll
13:54:19 <Oejet> wolfman8k: Remember how?
13:54:26 <wolfman8k> Oejet: no
13:56:47 <Oejet> ghc -prof -auto-all -o Main Main.hs
13:56:52 <Oejet> ./Main +RTS -p
13:57:11 <wolfman8k> Oejet: ok, it created a .prof file
13:57:19 <Oejet> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
13:57:32 <Oejet> Look inside.  :o
13:58:08 <wolfman8k> holy momma!
13:58:15 <wolfman8k>         total time  =       15.90 secs   (795 ticks @ 20 ms)
13:58:16 <wolfman8k>         total alloc = 1,876,062,356 bytes  (excludes profiling overheads)
13:59:48 <Oejet> Look at the section just under that one.
14:00:08 <Oejet> COST CENTRE          MODULE     %time %alloc ...
14:00:16 <wolfman8k> should i paste the top 5 here?
14:00:26 <Oejet> Shure.
14:00:29 <wolfman8k> squaredDistanceV3              Main                  17.6   24.6
14:00:29 <wolfman8k> raytracePixel                  Main                  16.1   13.8
14:00:29 <wolfman8k> intersectRaySphere             Main                  15.8   12.5
14:00:29 <wolfman8k> CAF                            Main                  13.7   12.9
14:00:29 <wolfman8k> dotV3                          Main                  10.5   11.4
14:00:48 <wolfman8k> what about using the -O compile option?
14:01:10 <Oejet> Optimization.  Like in GCC.
14:01:18 <wolfman8k> should i use it then?
14:01:23 <Oejet> Yes.
14:01:38 <wolfman8k> -On or something? or just -O
14:01:47 <Oejet> -O2
14:02:06 <Oejet> http://haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
14:02:49 <wolfman8k> sped things up a tiny bit. now total time = 14.52 secs
14:03:25 <Oejet> Negible improvement.
14:03:44 <Oejet> Try removing the ! in !Double.
14:03:50 <wolfman8k> everywhere?
14:04:04 <Oejet> Yes.
14:04:57 <wolfman8k> total time  =        5.14 secs
14:05:06 <wolfman8k> 300% perf!!!
14:05:09 <Oejet> :-)
14:05:19 <wolfman8k> i thought that ! was supposed to make things _faster_!
14:05:29 <Oejet> :D  Me too.
14:05:37 <Igloo> It makes things faster if you actually use all the values
14:05:46 <jadrian> maybe you didn't need some o fthe doubles
14:06:36 * Oejet should go into consulting and take percentages of client code improvement.
14:07:12 <Oejet> wolfman8k: How does top five look now?
14:07:39 <wolfman8k> intersectRaySphere             Main                  32.3   21.6
14:07:40 <wolfman8k> raytracePixel                  Main                  28.8   32.3
14:07:40 <wolfman8k> CAF                            Main                  12.5   25.6
14:07:40 <wolfman8k> normalV3                       Main                   7.4    8.0
14:07:40 <wolfman8k> main                           Main                   6.6    0.0
14:08:47 <Oejet> wolfman8k: Done any profiling before?
14:09:01 <wolfman8k> Oejet: minimal
14:09:41 <Oejet> wolfman8k: I bet you will do it alot more in Haskell. ;-)
14:10:06 <wolfman8k> i think that a haskell compiler should be able to generate totally fast code
14:10:39 <wolfman8k> i think someone should modify the compiler so that it uses genetic algorithms to try to find the best optimization approach for each program given a set of typical inputs :)
14:11:19 <Oejet> So you wan't the compiler to replace a bad algorithm with a better one?
14:11:44 <wolfman8k> no
14:11:59 <wolfman8k> i'm gonna think about this some more though
14:12:20 <wolfman8k> i've been wanting to try some artificial intelligence programming though =D
14:12:55 <Oejet> I think you could optimize intersectRaySphere and raytracePixel more.
14:13:14 <wolfman8k> here's the thing
14:13:28 <wolfman8k> i'm counting on lazy evaluation to do it's thing for intersectRaySphere
14:13:58 <wolfman8k> raytracePixel i should be able to optimize a bit by optimizing out an unneeded list operation
14:14:03 <wolfman8k> but it'll be a bit tricky
14:15:21 <Oejet> Oh, in raytracing isn't the bottleneck typically solving a quadratic equation?
14:16:03 <wolfman8k> for some shapes that is necessary, like a torus(doughnut)
14:16:06 <wolfman8k> but not for spheres
14:17:02 <wolfman8k> i wonder how much performance gain i will get from switching to Float instead of Double
14:17:21 <Oejet> Try.  :-)
14:19:37 <wolfman8k> not much,  total time  =        4.26 secs
14:20:31 <wolfman8k> i'm gonna stick with Double though
14:20:51 <wolfman8k> i wonder if i should try to put back ! into some of the places
14:20:57 * Oejet thinks that wolfman8k likes to profile.
14:21:22 * wolfman8k doesn't like waiting around 10 seconds to see the output of his app :)
14:25:17 <wolfman8k> Oejet: hm... i have some strange news
14:25:58 <Oejet> wolfman8k: Yes?
14:26:31 <wolfman8k> Oejet: i've put back all of the ! and total time is still under 5 sec
14:26:54 <wolfman8k> Oejet: the difference between 5 sec and 15 sec seems to be the -O2 compiler flag
14:28:33 <Oejet> Hm, that wasn't the impression I got from the first runs (see above).
14:29:40 <wolfman8k> well, i'm looking at the results right now, and i'm sure of it
14:29:44 <wolfman8k> i think what happened is
14:29:54 <wolfman8k> hm... i don't know
14:30:32 <Oejet> Cached results?   I don't know either.
14:33:27 <Oejet> wolfman8k: So there are two ways to improve the program: Make the expensive functions less expensive or call them fewer times. I don't know if the second one is eligible.
14:33:59 <wolfman8k> Oejet: well, right now i'm not really concerned about performance. i want to add more features first :)
14:34:58 <Oejet> wolfman8k: I'm going to bed now. It's been fun to see your raytracer.
14:35:17 <wolfman8k> Oejet: cool night man
14:35:25 <wolfman8k> Oejet: might not see you again for a while
14:35:37 <wolfman8k> Oejet: i'm leaving tomorrow night for 3 weeks vacation
14:36:09 <Oejet> wolfman8k: I wish that was me. :-)
14:36:22 <wolfman8k> i'm gonna try to get shadows working now =)
15:23:44 <Pseudonym> Spam subject: perfrect girdls with perfect aszses
15:23:48 <Pseudonym> I originally parsed that as "perfect grids with perfect sizes"
15:23:50 <Pseudonym> Which would be handy, actually.  I need some decent-sized grids.
15:25:56 <Lemmih> @index userError
15:25:56 <lambdabot> GHC.IOBase,Prelude,System.IO,System.IO.Error,IO
15:26:00 <Lemmih> @index isUserError
15:26:00 <lambdabot> System.IO,System.IO.Error,IO
15:26:55 <Lemmih> @index throw
15:26:55 <lambdabot> Control.Exception,GHC.Exception,GHC.IOBase
15:48:52 <wolfman8k> sweet, i think i have shadows working
15:48:57 <Lemmih> Yay
16:06:01 <marcot> Good evening.
16:06:27 <wolfman8k> saweeet! i think reflections work
16:06:49 <Lemmih> Isn't it late in brazil?
16:07:18 <dons_> not too late, I think
16:07:21 <dons_> hey marcot
16:07:38 <marcot> dons_: hello... have you get my Nano.hs file?
16:07:49 <dons_> marcot: it's in Yi/Keymap now :)
16:08:01 <wolfman8k> is there a good scripting language that can be embedded inside haskell?
16:08:04 <marcot> dons_: cool... any change in it since then?
16:08:22 <dash> embedded scripting languages are usually a bad idea
16:08:30 <dons> no. except I've fixed yi so that you can get \^C and \^S and friends
16:08:40 <wolfman8k> dash: what's the alternative?
16:08:41 <dons> there's also a beginning emacs mode, which might be useful to you
16:08:53 <dash> wolfman8k: extending some language with your code
16:09:08 <wolfman8k> dash: what do you mean?
16:09:13 <dons> "scripting" languages in Haskell are usually known as EDSLs in this field
16:09:13 <dash> wolfman8k: i am primarily familiar with this from a Python perspective
16:09:37 <dons> there's a whole area of research in how to design other languages inside Haskell
16:10:00 <marcot> dons: you can use somethings of the nano mode for the emacs one.
16:10:08 <dash> what dons is talking about is probably more reasonable than what i'm familiar with, but i cannot help but feel that it is a fundamnetally restrictive approach
16:10:19 <wolfman8k> i want users to be able to write scripts that will be loaded at runtime and parsed
16:10:29 <dons> yeah, I think Simon (the guy who wrote the emacs mode) began with that
16:10:37 <dons> wolfman8k: you want hs-plugins!
16:10:48 <wolfman8k> dons: hm?
16:10:52 <dons> look at yi, it uses config scripts written in haskell, loaded at runtime
16:10:57 <dons> so does riot
16:11:05 <wolfman8k> i guess i also should mention that i want the simplest thing possible
16:11:19 <dash> wolfman8k: yeah, see, i'm more inclined to think that code like that should be a library that can be loaded from some language
16:12:06 <dons> marcot: to use the nano mode now, you just add "import Yi.Keymap.Nano" to Config.hs
16:12:09 <dons> which is nice
16:12:16 <wolfman8k> here's my situation
16:12:21 <wolfman8k> i have this raytracer program
16:12:28 <wolfman8k> and i want users to be able to write scene description scripts
16:12:53 <wolfman8k> the scripts will basicly say "put a sphere at x,y,z with radius r, and put a light here, and put a plane here..."
16:13:00 <dons> wolfman8k: there's a large area of research into using Haskell as a 2 and 3-d descripting language for rendering programs
16:13:09 <dons> see for example, Pan, PanTHeon and similar
16:13:29 <wolfman8k> dons: i really want something simple though. i don't think i want to use haskell as the scripting lang
16:13:52 <dons> what is the app written in?
16:13:55 <wolfman8k> the simplest possible would be just a simple text file where each line is an object with position + attributes
16:13:58 <wolfman8k> dons: haskell
16:14:35 <dons> PanTHeon is a Haskell app for rendering 2-D animations. It uses a Haskell library to implement the Pan image description language.
16:14:44 <dons> user's write Pan scripts, which are loaded and executed
16:14:56 <wolfman8k> hm....
16:14:57 <dons> now, if you don't want that, then you have to design your own small language
16:14:58 <wolfman8k> what about xml?
16:15:02 <dons> which might be reinventing the wheel
16:15:09 <dons> or use read/show. that would be easy too
16:15:19 <wolfman8k> read/show would work
16:15:51 <dons> but you should look into the Pan-related stuff. it is very similar, and well researched
16:15:59 <wolfman8k> but it would be really cool if the language had just a little power so you could create interesting scenes by using simple formulas, to arrange objects in mathematical structures
16:16:31 <dons> that's how Pan works, I think.
16:18:30 <dons> check out: http://www.haskell.org/libraries/#graphics
16:18:42 <wolfman8k> check it out btw:
16:18:42 <wolfman8k> http://img15.exs.cx/img15/9854/haskell-raytrace-01.png
16:18:49 <wolfman8k> dons: yeah, i've read a bit about some of those
16:19:20 <wolfman8k> and here are the new shadows and reflections!
16:19:22 <wolfman8k> http://img79.exs.cx/img79/7291/haskell-raytrace-02.png
16:19:25 <dons> PanTHeon is at http://www.cse.unsw.edu.au/~sseefried/files/snapshots/
16:20:17 <dons> marcot: if you'd like to write more of the nano binding, now that you have access to all the control chars, that would be nice ;)
16:20:37 <marcot> dons: Actually I don't know any more.
16:20:52 <marcot> dons: what I could do is correct the '\^K' thing.
16:21:23 <dons> ok. that's good too.
16:21:23 <marcot> dons: but unfortunatly I don't have time.. =(
16:21:31 <dons> ok, sure. :)
16:21:36 <marcot> dons: but I'll do it as soon as I have some.
16:22:20 <dons> great! thanks.
16:25:21 <jadrian> dons: pan is windows only right?
16:25:40 <dons> pan might be. panTHeon is a reimplementation that isn't
16:26:05 <dons> there's a couple of other reimplementations too that might have different deps
16:27:41 <jadrian> hmm no homepage
16:27:49 <dons> panTHeon?
16:28:01 <jadrian> ywap
16:28:03 <jadrian> yeap
16:28:13 <dons> it's been around for a year or so, but the first release was a week ago
16:28:14 <wolfman8k> can i embed guile in haskell?
16:28:25 <dons> there should be a couple of papers, and the code is at the link above
16:28:31 <dons> wolfman8k: that's crazy.
16:28:36 <dons> why embed scheme in haskell.
16:28:39 <dons> just use haskell in haskell
16:29:03 <wolfman8k> hm...
16:29:07 <Lemmih> wolfman8k: hscheme.sf.net
16:29:22 <wolfman8k> maybe some imperative language like python or lua would be best :/
16:29:32 <wolfman8k> i really don't need anything fancy :/
16:30:02 <dons> they're all hard to write in than haskell...
16:30:14 <dons> think of the users ;)
16:31:49 <dash> wolfman8k: python or lua is fancier than haskell, in this case
16:32:11 <wolfman8k> maybe i will just have the program read the objects line by line from stdin
16:32:24 <wolfman8k> then people can use whatever language they want and pipe the formatted output to the raytracer
16:32:52 <dons> that's a good idea. what language will stdin be in?
16:33:24 <wolfman8k> Sphere 0.0 1.0 2.0 10.0
16:33:36 <wolfman8k> PointLight 3.0 4.0 5.0 0.2 0.6 0.1
16:33:44 <wolfman8k> ...
16:33:57 <dons> cool. so they'd have to generated Haskell edsl calls. which is very easy, since Haskell's a great scripting language ;)
16:34:19 <wolfman8k> hm... i don't think so
16:34:54 <tuomov> How complicated is c->haskell calling?
16:35:25 <dons> pretty easy. there's ffi support
16:35:37 <dons> you write "foreign export" instead of "foreign import"
16:35:48 <dons> and ghc generates a .h for you
16:35:54 <tuomov> nice.
16:36:12 <tuomov> Then it should be quite easy to write the lua wrappers in c
16:36:19 <dons> the EvalHaskell.h in hs-plugins is an example of this.
16:36:24 <wolfman8k> ok, i have a really important question now
16:36:25 <dons> cool. that's a good idea.
16:36:30 <tuomov> but even easier would be to just use hs-plugins
16:36:32 <wolfman8k> different subject
16:36:59 <wolfman8k> hm.... i forgot what i wanted to ask :\
16:37:42 <dons> tuomov: direct function calls are easy, but you can even eval strings from C these days
16:37:45 <dons> p = hs_eval_s("show $ let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20");
16:38:03 <dons> that's from examples/eval/foreign_eval1 in hs-plugins
16:38:33 <dons>   hs_init(&argc, &argv);
16:38:34 <dons>   p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
16:38:37 <dons>   if (p == NULL)
16:38:39 <dons>       printf("failed!\n");
16:38:42 <dons>   else
16:38:44 <dons>       printf("%d\n",*p);
16:40:09 <dons> so I don't think there's any excuse for using another language to script a Haskell app these days
16:40:35 <wolfman8k> here's my problem:
16:41:03 <wolfman8k> i have this data type Scene, which has a field that is a list of spheres, and a field that is a list of lights
16:41:12 <wolfman8k> now i want to add materials
16:41:23 <wolfman8k> the question is, should each sphere be tupled with a material value
16:41:25 <wolfman8k> or
16:41:47 <wolfman8k> should the scene have a seperate list of materials, and then each sphere is tupled with an index in the material list?
16:42:04 <wolfman8k> i think the first way is the functional way to do it, but i'm not sure
16:42:05 <tuomov> I'd go with the latter
16:42:13 <Pseudonym> The first way is the functional way.
16:42:22 <tuomov> for storage
16:42:36 <Pseudonym> tuomov: It's just an extra pointer per geometric primitive.
16:42:52 <Pseudonym> As opposed to an extra index.
16:43:09 <tuomov> I'm thinking of a file format here
16:43:13 <tuomov> you don't want dupes there
16:43:26 <Pseudonym> How big is a material description anyway?
16:43:43 <tuomov> size is not the issue, but the same material occuring only in one place to modify it
16:44:20 <Pseudonym> How many different objects using an identical material description do you expect to find in a typical scene?
16:44:22 <wolfman8k> has a few values for diffuse color, specular color, ambient color, reflectivity, glossiness, specularity, emmission color, opacity, refraction index, maybe some texture info
16:44:42 <wolfman8k> Pseudonym: maybe 5:1 ratio between object count and material count
16:45:06 <Pseudonym> I'd disagree with that, but it might depend on what kind of scenes you have.
16:45:21 * Pseudonym used to work in visual effects
16:45:44 <Pseudonym> Typically, you have a 1:1 ratio between geometric primitive and shader instance.
16:45:53 <Pseudonym> Note that's shader _instance_.
16:46:13 <Pseudonym> So you write a shader, and it might get reused on different materials, but the instance data is typicall unique.
16:46:33 <Pseudonym> If you have identical materials, chances are pretty good that the object itself is instanced too.
16:46:50 <wolfman8k> well, right now i'm only working with spheres :)
16:47:07 <wolfman8k> http://img79.exs.cx/img79/7291/haskell-raytrace-02.png
16:47:12 <Pseudonym> The counter-example is when you have big background shots or crowd shots or something.  
16:47:22 <Pseudonym> But in that case, you tend to render in layers.
16:47:43 <Pseudonym> The other thing, of course, is that assigning shaders to gprims is the modelling software's job.  You don't write scene files by hand.
16:47:54 <Pseudonym> So how it's physically organised is kinda moot.
16:48:02 <Pseudonym> wolfman8k: Nice.
16:48:16 <wolfman8k> well, i actually do plan on writing scene files by hand =)
16:48:51 <tuomov> wolfman8k: how long does it take to render that?
16:49:03 <wolfman8k> tuomov: a long time
16:49:07 <tuomov> :)
16:49:23 <Pseudonym> Do you have any good bug pictures?
16:49:26 <wolfman8k> tuomov: i rendered it at 1000x1000 resolution and sampled it down
16:49:34 <wolfman8k> Pseudonym: no, that's the only pic i have, and this one:
16:49:38 <wolfman8k> http://img15.exs.cx/img15/9854/haskell-raytrace-01.png
16:49:47 <wolfman8k> Pseudonym: i just started coding this today! it's my first haskell program
16:49:53 <wolfman8k> tuomov: it took about a minute i think
16:50:02 <Pseudonym> Ah, cool!
16:50:11 <tuomov> that's not bad then
16:50:16 <Pseudonym> This is my best bug picture so far: http://andrew.bromage.org/dof.png
16:50:49 <Pseudonym> It's meant to be a depth-of-field test.
16:51:02 <Pseudonym> But for some reason, the lens jittering was correlated.
16:51:21 <wolfman8k> cool
16:51:55 <Pseudonym> Oh, that's not raytraced, BTW.  It's a reyes-based renderer.  And it's not in Haskell.
16:52:14 <wolfman8k> ok
16:52:22 <heatsink> ooh, pretty... the first one
16:53:47 <Pseudonym> http://andrew.bromage.org/haskrt.png
16:53:53 <Pseudonym> That's raytraced, and written in Haskell.
16:54:03 <Pseudonym> Took an hour or so to render.
16:54:13 <Pseudonym> But it's a big image.
16:54:34 <wolfman8k> nice!
16:54:36 <wolfman8k> you made that?
16:54:39 * Pseudonym nods
16:54:57 <wolfman8k> how did you do the sky?
16:55:55 <Pseudonym> Erm... just put in a default case for the trace function.
16:56:25 <wolfman8k> but it's not a constant color
16:58:00 <Pseudonym> No, I used the final ray direction in world space or something like that.
16:58:03 <Pseudonym> Been a while since I wrote this.
16:58:09 <wolfman8k> ah, makes sense
16:58:19 <wolfman8k> i guess using a huge skydome would give the same effect
16:58:25 <Pseudonym> No doubt, yes.
16:58:39 <Pseudonym> This was just a test to see if the motion blur was working.
16:58:48 <wolfman8k> it looks really good
16:59:01 <Pseudonym> Two main reasons why it looks good.
16:59:15 <Pseudonym> 1. Proper filtering.  Most people who write toy renderers don't filter propertly.
16:59:24 <Pseudonym> 2. Fresnel reflection.
16:59:43 <Pseudonym> Like real dielectric surfaces, the spheres reflect less if you're looking straight-on.
16:59:50 <Pseudonym> They reflect more if you look at them from a glancing angle.
16:59:59 <wolfman8k> nice, do you also do fresnel refraction?
17:00:33 <Pseudonym> No, the spheres aren't refractive.
17:00:37 <Pseudonym> Not at the moment, anyway.
17:00:43 <Pseudonym> Refraction is kinda overrated.
17:01:08 <Pseudonym> Very few "real world" scenes have refraction in them, and the few that do can be faked convincingly most of the time.
17:01:36 <wolfman8k> doom3 glass looks really nice with its refraction effect =D
17:01:47 <Pseudonym> Yeah, but it's not raytraced, is it.
17:02:00 <wolfman8k> well, it almost is
17:02:45 <Pseudonym> Not really.  Ray tracing in real-time is impractical, and will remain so for a long time yet.
17:03:03 <wolfman8k> it just does pixel lookups from the framebuffer
17:03:09 <Pseudonym> Right.
17:03:15 <wolfman8k> but ray tracing is possible in real time if you have quad cpu :D
17:03:20 <Pseudonym> Nope.
17:03:28 <Pseudonym> Not realy.
17:03:33 <Pseudonym> OK, let me rephrase.
17:03:44 <Pseudonym> Ray tracing in real-time is impractical for any scene that anyone cares about.
17:03:57 <Pseudonym> That's an important qualification.
17:04:25 <wolfman8k> but for monster scenes, with hundreds of millions of triangles, ray tracing can be even faster then hardware rasterization
17:04:54 <Pseudonym> Only for artificial scenes.
17:05:19 <Pseudonym> For truly monster scenes, like 2Gb gzipped, the fact that you can't hold the whole scene in RAM effectively kills ray tracing.
17:05:33 <Pseudonym> The problem is memory coherence.
17:05:48 <wolfman8k> that will kill all rendering techniques i think
17:05:55 <Pseudonym> No, not really.
17:06:11 <Pseudonym> Any rendering technique which doesn't require holding the entire scene in memory at once should be fine.
17:06:19 <Pseudonym> And which lets you throw away geometry once it's processed.
17:06:36 <wolfman8k> you could do raytracing also in several passes
17:06:55 <Pseudonym> Not necessarily.
17:07:29 <Pseudonym> If you have lots of inter-reflection, for example, you can't just hand off half the geometry to another pass.
17:08:12 <Pseudonym> Generally speaking, you'd only choose ray tracing if a) the scene/pass is small enough, or b) you need the whole geometry present.
17:08:18 <wolfman8k> right, reflection makes things complicated i guess
17:08:23 <Pseudonym> The latter case is important for global illumination, reflection etc.
17:09:52 <dons> what's the emacs equiv of the cmd line arg "+linenum" in vim?
17:11:11 <Pseudonym> It's the same.
17:11:16 <Pseudonym> Ah, no.
17:11:20 <Pseudonym> Sorry, misparsed the sentence.
17:11:32 <Pseudonym> Yes, it's the same.
17:11:35 <Pseudonym> :-)
17:12:24 <Pseudonym> The problem with ray tracing is Blinn's Law.
17:12:59 <Pseudonym> Audience expectation rises at the same speed as Moore's Law.
17:13:14 <Pseudonym> Which means that just working harder isn't enough.
17:13:27 <wolfman8k> i thought you were going to say something about Blinn shading :P
17:13:36 <Pseudonym> No. :-)
17:13:40 <Pseudonym> Jim Blinn is very quotable.
17:15:02 <Pseudonym> Hollasch's Law is even more critical: Computer graphics is the only area of science where if it looks right, it is right.
17:15:09 <tuomov> I've never been happy with the looks of 3d games... hand-drawn graphics are so much prettier
17:15:33 <Pseudonym> It follows that the most important skill in graphics is the ancient and noble art of Chi'Ting.
17:15:42 <wolfman8k> tuomov: did you not play doom? or myst?
17:15:59 <Pseudonym> tuomov: There's a reason for that.
17:16:16 <tuomov> doom? it was very primitive
17:16:16 <Pseudonym> When you have a 3D environment, the artist doesn't get to pick the camera placement.
17:16:45 <Pseudonym> So compositionally, artist-chosen scenes are always going to be more appealing than user-chosen scenes.
17:16:52 <dash> a good example these days is Prince of Persia
17:17:12 <dash> I replayed that game because it was so pretty
17:17:26 <heatsink> the old dos game? Or the new one?
17:17:42 <dash> The new one.
17:17:57 <dash> (actually I hear they're doing a sequel pretty soon. i'll have to go get that)
17:22:48 <wolfman8k> sweet.... i have a new render in progress
17:22:51 <wolfman8k> this one is taking a while :)
17:24:37 <wolfman8k> SHIT!
17:24:41 <wolfman8k> infinite recursion!
17:32:02 <wolfman8k> halfway done...
17:36:21 <wolfman8k> done!
17:36:24 <Lemmih> Yay
17:36:44 * Pseudonym is waiting...
17:36:47 <Pseudonym> Lemme see!
17:37:00 <wolfman8k> http://img22.exs.cx/img22/9137/haskell-raytrace-03.png
17:37:28 <Pseudonym> Pretty.
17:37:31 <wolfman8k> it could use some antialiasing love
17:37:43 <Pseudonym> Yes.  Only one sample per pixel, I note.
17:37:58 <wolfman8k> yeah, the reflections look really bad
17:39:00 <Pseudonym> How many lines of code, BTW?
17:39:10 <wolfman8k> about 100
17:39:19 <wolfman8k> less even
17:39:22 <Pseudonym> http://andrew.bromage.org/rt.hs
17:39:25 <Pseudonym> Feel free to grab it.
17:39:42 <wolfman8k> i'm actually coding this in order to learn haskell :)
17:39:44 <Pseudonym> Most of that is code to drive the stochastic sampling/filtering.
17:39:55 <Pseudonym> Very little of it is actually ray tracing.
17:40:17 <wolfman8k> that's been buggin me
17:40:17 <Pseudonym> So I figured you might be able to raid it so that's code you don't have to write. :-)
17:40:36 <wolfman8k> how do you do random noise in a funtional function?
17:40:45 <Pseudonym> I don't. :-)
17:41:04 <Pseudonym> I generate a list of samples inside IO code first, then call the non-IO part from that.
17:41:50 <wolfman8k> this is why the lisp people say that haskell sucks i think
17:42:03 <Pseudonym> Lisp people also don't like static types.
17:42:26 <Pseudonym> i.e. they think ML sucks for much the same reasons
17:42:45 <dash> yeah, if you're going to use ML you might as well give up and use lisp :)
17:43:12 <Pseudonym> BTW, when you're implementing materials/shaders, wolfman8k, you might want to consider implementing it as an actual function.
17:43:30 <Pseudonym> A material takes information about the environment, information about the incident ray and returns a colour.
17:43:32 <wolfman8k> Pseudonym: yeah, i've been thinking of that
17:44:26 <wolfman8k> i've also been thinking of defining geometry in terms of a tuple of appropriate functions
17:44:32 <Pseudonym> Oh, I can't claim credit for all of rt.hs, BTW.  Someone on this channel, not sure who, wrote the actual ray tracing part.
17:44:39 <wolfman8k> sort of an emulation of OO type polymorphism
17:44:40 <Pseudonym> I wrote the materials and sampling stuff.
17:44:54 <Pseudonym> Oh, good idea.
17:44:55 <wolfman8k> the dude who is doing a raytracer for his thesis?
17:45:06 <Pseudonym> No.  His is much better than this,.
17:45:13 <Pseudonym> Well, as far as design goes, anyway.
17:45:26 <Pseudonym> I think the sampling in mine is better. :-)
17:45:41 <wolfman8k> this is really bugging me though about random noise
17:45:50 <wolfman8k> i'm also interested in doing some genetic algorithms coding in haskell
17:45:58 <wolfman8k> and also there you need randomness for mutations and stuff
17:46:00 <Pseudonym> Oh, and if you're feeling adventurous...
17:46:03 <Pseudonym> http://graphics.stanford.edu/papers/trd/
17:46:22 <Pseudonym> Well, if you need randomness in non-IO code, there's also the lazy list approach.
17:46:37 <Pseudonym> randomNumbers :: [Int]
17:46:46 <Pseudonym> Where the list is potentially infinite.
17:46:55 <Pseudonym> That might be appropriate.
17:47:32 <wolfman8k> it just seems like a pain to have to keep track of that though
17:47:40 <Pseudonym> Right, so you hide it.
17:47:46 <wolfman8k> monad?
17:47:51 <Pseudonym> That'd work.
17:47:56 <wolfman8k> arrow?
17:48:09 <Pseudonym> Arrows are probably overkill unless you need them.
17:48:19 <wolfman8k> thing is
17:48:22 <heatsink> Pseudonym: how do you create and use an infinite list of IO operations?
17:48:31 <wolfman8k> if a monad is used, then won't that fix the evaluation order of various things?
17:48:48 <wolfman8k> and then it will make the compiler less able to optimize
17:49:34 <Pseudonym> Well, you can use unsafeInterleaveIO.
17:49:38 <Pseudonym> However, it'
17:49:54 <Pseudonym> s probably best not to use the built-in random number generator if you want to use the infinite list approach.
17:50:09 <wolfman8k> haskell should simply have a few builtin noise functions
17:50:15 <wolfman8k> and it should treat them as if they were strict
17:50:20 <wolfman8k> even though they aren't
17:50:31 <Pseudonym> Why built in?
17:50:55 <wolfman8k> that's the only way to have it possible to call them from pure functions
17:53:02 <Pseudonym> You mean impure functions.
17:53:10 <Pseudonym> No, that'd be bad.
17:53:13 <Pseudonym> Impure functions break things.
17:53:41 <Pseudonym> One of the nice things about Haskell is that people have resisted this sort of thing, which means that people have come up with much more interesting solutions.
17:53:41 <wolfman8k> it would techincally be impure, but it would pretend and act like pure
17:54:04 <Pseudonym> Constraints fuel creativity, I think.
17:54:10 <dash> yes
17:54:16 <dash> just look at all the websites done in PHP
17:54:24 <heatsink> >_>
17:54:45 <Pseudonym> Indeed.
17:54:53 <Pseudonym> That's a very good example, BTW.
17:55:01 <Pseudonym> PHP was designed as a very thin layer of glue.
17:55:10 <wolfman8k> the thing is
17:55:10 <tuomov> hmm.. a stochastic programming language.. that would be cool
17:55:24 <wolfman8k> i want to completely abstract sequencing
17:55:29 <heatsink> There was a stochastic esolang I think
17:55:34 <dash> Pseudonym: and, like glue, every bit of crap that came near it stuck
17:55:43 <Pseudonym> People have been using it as thicker and thicker glue, and people have come up with all sorts of interesting and creative ways to get around the language limitations
17:55:47 <tuomov> if you could get a random element for each instance of function evaluation with different parameters
17:56:30 <tuomov> f x = do_something_with (random f x)
17:57:46 <tuomov> with random initialised at program startup or something
18:07:44 <wolfman8k> Pseudonym: do you know if metaballs can be done with raytracing, without using marching-cubes?
18:10:39 <wolfman8k> tuomov: you are the Vis dude?
18:11:19 <tuomov> vis, ion, and whatnot
18:11:26 <wolfman8k> cool
18:15:37 <peti> Duh! sharp is not on the channel. The world as we know it has ended.
18:16:26 <Lemmih> @seen shapr
18:16:26 <lambdabot> I saw shapr leaving #haskell 10 hours 44 minutes 9 seconds ago.
18:18:46 <peti> Some day I have to find out what this bot can all do. :-)
18:19:01 <wolfman8k> @quote
18:19:01 <lambdabot> Sorry, I don't know the command "quote", try "lambdabot: @listcommands"
18:19:54 * peti goes to bed now. 
18:20:03 <peti> Good night, everybody. Or whatever time it is where you are. :-)
18:24:21 <wolfman8k> done!
18:24:23 <wolfman8k> http://img40.exs.cx/img40/3051/haskell-raytrace-04.png
18:31:21 <heatsink> nice.
18:31:25 <heatsink> now add radiosity :3
18:34:43 <wolfman8k> i've uploaded the hi res version of the pic since it looks way better:
18:34:44 <wolfman8k> http://img19.exs.cx/img19/951/haskell-raytrace-05.png
18:34:54 <Pseudonym> wolfman8k: Yes, metaballs can be ray traced.
18:35:09 <wolfman8k> i'd like to metaball these suckers :)
18:35:18 <Pseudonym> Eeek, radiosity.  Yuck.
18:35:23 <Pseudonym> Photon mapping is the future.
18:35:28 <Pseudonym> (And the present.)
18:35:53 * heatsink wants meatballs
18:36:03 * monochrom got a seafood sub
18:36:12 * Pseudonym got sushi
18:36:31 * monochrom is broke, otherwise he would get sushi etc
19:16:07 <nTfirewall> http://www.nomorepasting.com/paste.php?pasteID=24012
19:16:20 <nTfirewall> could some one please help me with my code
19:16:36 <nTfirewall> i am trying to do a while function
19:22:54 <Lemmih> nTfirewall: Is there some reason you can't use 'until'?
19:23:27 <nTfirewall> i have to use while
19:24:16 <nTfirewall> | t == True  = while t (f n)   < i tried this as well
19:24:18 <Lemmih> Why do you test for '0' in the first case?
19:24:33 <nTfirewall> input cud be 0
19:25:08 <Lemmih> It could also be 'c' for example.
19:25:22 <nTfirewall> yea
19:25:42 <nTfirewall> but it should be integer
19:26:35 <Lemmih> So you wanna limit it to numeric input?
19:27:36 <nTfirewall> ya coz lessthan10 function is checking if input is less then ten , if it is it will keep doubling it 
19:28:07 <nTfirewall> but i am not allowed to change type of the funtion 
19:28:11 <kosmikus> btw, (t == True) == t
19:28:52 <Lemmih> nTfirewall: Good. But checking if n is zero is wrong.
19:29:33 <nTfirewall> ok i will take it out
19:29:58 <nTfirewall> it still gives me error
19:34:41 <Lemmih> It shouldn't.
19:35:05 <kosmikus> yes, it should
19:35:13 <kosmikus> there's a type error in the code
19:35:24 <nTfirewall> bool
19:35:28 <Lemmih> 't n   = while t (f n) n'
19:36:03 <kosmikus> Lemmih: ?
19:36:14 <Lemmih> And I don't think you should apply f to n when t n fails.
19:36:56 <Lemmih> kosmikus: That how the first pattern guard should look like.
19:37:04 <Lemmih> *That's
19:37:10 <kosmikus> no
19:37:18 <nTfirewall> it does not work
19:37:23 <Lemmih> kosmikus: No?
19:37:42 <Lemmih> *'t n   = while t f (f n)'
19:37:55 <kosmikus> better
19:38:06 <kosmikus> but it wasn't your job to solve it ;)
19:39:51 <nTfirewall> there is still a glitch but i will try to solve it my self
19:39:55 <nTfirewall> thank you guys
19:41:31 <kosmikus> but I also don't understand why you're not using until ...
19:41:38 <Lemmih> Having working code is the first step to understanding it.
19:41:53 <nTfirewall> in the otherwise case it should only be n not f n :)
19:42:33 <kosmikus> Lemmih: learning to understand type error messages is pretty important as well; you cannot always just guess until your program passes the typechecker
19:42:34 <nTfirewall> kosmikus .. because i am not been taught that function
19:43:06 <kosmikus> nTfirewall: about the otherwise case ... Lemmih told you
19:43:18 <nTfirewall> he did ?
19:43:32 <kosmikus> yes, < Lemmih> And I don't think you should apply f to n when t n fails.
19:44:27 <nTfirewall> when i got 32 instead of 16 i thought something was wrong 
19:45:01 <nTfirewall> are you guys studying in university
19:46:07 <Lemmih> I'm not. /-:
19:46:42 <nTfirewall> too young to be in univ or too old ?
19:46:48 <nTfirewall> :)
19:47:10 <Lemmih> Too young. I'm seventeen.
19:47:42 <nTfirewall> koool 
19:57:39 * kosmikus is old and still at a university ...
20:01:34 <desrt> go hug a californian
20:01:53 <desrt> they just contributed 55 votes for kerry.  they quite possibly have saved the planet.
20:03:14 <dons> hehe
20:04:30 <wolfman8k> Pseudonym: ping
20:06:46 <Lemmih> desrt: Where do you get this info?
20:06:58 <desrt> http://www.nbc4.tv/elex2004natl/index.html
20:07:02 <desrt> very good site
20:12:25 <heatsink> What do you see when you click on CA?
20:12:47 <heatsink> Do you think they'll ask for a recount? ;)
20:14:22 <heatsink> In ME, apparently John ge W. Bush got 0 votes.
20:15:55 <Pseudonym> Sorry, back.
20:16:02 * Pseudonym is at w*rk
20:16:07 <Pseudonym> Are we discussing politics?
20:17:12 <heatsink> I was only identifying bugs in the online election results website.
20:17:36 <heatsink> Unless someone else speaks up, the answer would be "no".
20:17:44 <Pseudonym> I find it interesting that the libertarians are outpolling the greens.
20:17:48 <Pseudonym> Probably because of Nader.
20:19:05 <wolfman8k> Pseudonym: hey
20:19:11 <wolfman8k> Pseudonym: i have a question about soft shadows
20:19:14 <Pseudonym> OK.
20:19:18 <wolfman8k> Pseudonym: let's say my light source is a sphere
20:19:25 <Pseudonym> Right.
20:19:45 <wolfman8k> Pseudonym: so am i supposed to make with the base at the sphere, and the tip at the geometry point?
20:19:53 <wolfman8k> Pseudonym: and then i have to figure out how much area is blocked?
20:20:22 <Pseudonym> What I suggest you do is for each shadow ray, pick a random point on the sphere.
20:20:38 <Pseudonym> And just treat it as a normal vanilla shadow ray.
20:20:56 <wolfman8k> yeah, that works, but the "correct" way would be what i said? :)
20:20:58 <Pseudonym> Because you'll want more than one sample per pixel, you'll end up with an estimate of blocked area.
20:21:13 <Pseudonym> Well, define "correct".
20:21:23 <wolfman8k> mathematically
20:21:26 <Pseudonym> If you wanted something that was _really_ correct, you'd take into account diffraction.
20:21:43 <Pseudonym> See Hollasch's Law for details. :_)
20:22:02 <wolfman8k> head ache :|
20:22:15 <Pseudonym> But yes, you want to know what percentage of the light from the source illuminates the sample point.
20:22:36 <Pseudonym> Or, more correctly, you want to know how many photons leave the light source and hit the sample area.
20:23:54 <wolfman8k> right
20:24:07 <wolfman8k> whoah, this new render rocks!
20:24:21 <Pseudonym> Don't leave us in suspense.
20:24:48 <wolfman8k> http://img87.exs.cx/img87/8392/haskell-raytrace-06.png
20:25:39 <Pseudonym> Ooh, nice.
20:27:33 <heatsink> How long does it take to render?
20:28:10 <wolfman8k> this one took maybe 8 minutes
20:28:46 <wolfman8k> i could probably give it a massive speedup by organizing the objects in a spatial structure
20:29:01 <dash> that can't be a raytraced picture
20:29:02 <dash> where are the checkerboards!
20:29:36 <heatsink> :D
20:29:45 <dash> i thought there was a rule that raytraced pictures had to have checkerboard patterns in them 
20:30:01 <heatsink> under the teacup
20:30:19 <dash> right
20:30:33 <dash> well, i think I finally understand what " http://img87.exs.cx/img87/8392/haskell-raytrace-06.png
20:30:36 <dash> errr
20:30:45 <dash> well, i think I finally understand what " http://img87.exs.cx/img87/8392/haskell-raytrace-06.png
20:30:51 <dash> i do so hate windows.
20:30:53 <dash> ANYWAY.
20:31:00 <dash> i understand monads now i think
20:31:14 <dash> and in particular what m a -> (a -> m b) -> m b means
20:31:27 <dash> the IO monad is a terrible red herring
20:31:46 <dash> for the longest time i thought all monads were one-way like that, that you couldn't get data out of them 
20:32:12 <heatsink> oh, yea
20:33:01 <heatsink> You can actually get data out of the IO monad, you just can't call any methods on that datatype :)
20:35:05 <dash> that isn't data, then ;D
20:37:05 <heatsink> sures.
20:43:45 <Pseudonym> dash: http://andrew.bromage.org/absolut.jpg
20:44:15 <heatsink> nice :)
20:44:20 <Pseudonym> And the odd thing is, it isn't raytraced.
20:44:45 <shrimpx> it's real?!
20:44:55 <Pseudonym> No, no, nothing that drastic.
20:45:00 <shrimpx> :)
20:45:16 <Pseudonym> This kind of image is customarily raytraced.
20:45:20 <wolfman8k> it's only been pixel arted
20:45:32 <Pseudonym> It's actually done entirely scanline.
20:46:00 <Pseudonym> Apart from the text, which is obviously done in post.
20:46:08 <desrt> when is the location of ICFP decided?
20:49:12 <wolfman8k> alright, i'm going to sleep.... i'm gonna let a mega scene render now
20:49:45 <wolfman8k> if haskell runs out of memory or something will it crash my computer?
20:49:56 <dash> Pseudonym: Cute.
20:51:11 <Pseudonym> wolfman8k: Doubtful.
20:51:15 <heatsink> wolfman8k: yes, but it will clear your bank account and donate it to the  campaign first.
20:51:21 <Pseudonym> Unless you have your heap size set insanely high.
20:51:27 <Pseudonym> Vote 1 Haskell!
20:51:28 <heatsink> wolfman8k: *yes, but it will clear your bank account and donate it to the Nader campaign first.
20:51:50 <dash> wolfman8k: depends on the computer, i imagine 
20:52:11 <dash> and the virtual memory implementation
20:52:34 <dons> no, they specifically design ghc to crash and delete files in this circumstance
20:52:42 <dons> to teach you a space-leak lesson
20:53:01 <Pseudonym> And donate your bank balance to a third party candidate.
20:53:04 <Pseudonym> Don't forget that.
20:53:12 <dons> yes. that too :)
20:53:52 <wolfman8k> alright, i've started the render. hopefully it'll be alright. i can sleep
21:17:51 <Cale> wolfman8k: which direction is the camera pointed? Toward positive z?
21:19:40 <Cale> oh, sleeping
21:37:23 <musasabi> morning
21:52:13 <dash> so i've got a function 'meaning'
21:52:41 <dash> whos type is basically Expr -> Env -> Cont -> Store -> Val
21:53:00 <dash> all this code is written in CPS
21:53:17 <dash> i'd like to untangle it a bit by writing some monadic stuff
21:53:37 <heatsink> yeah...
21:53:52 <dash> so my first thought was to rewrite 'meaning' to Expr -> ST Interpreter Val
21:53:56 <dash> does that make sense?
21:54:10 <dash> (where Interpreter is (Env,Cont,Store))
21:54:26 <heatsink> How would you do call-cc?
21:54:42 <dash> wasn't planning on doing call/cc
21:54:54 <dash> but if it's convenient to include i may do so 
21:55:32 <wagle_ungone> dont you need Store -> Store?
21:56:38 <dash> wagle_ungone: hmm, where?
21:56:45 <heatsink> I'm undecided whether Cont would go better in Interpreter or in the monad definition itself.
21:57:03 <dash> heatsink: hm. explain "in the monad definition itself"? :)
21:57:13 <wagle_ungone> Expr -> Env -> Cont -> Store -> Ans where Ans = (Val, Store)
21:57:23 <wagle_ungone> or somesuch..  (I could be confused)
21:58:24 <dash> Hmm
21:58:28 <wagle_ungone> I'm assuming that Cont = Val -> Store -> Ans 
21:58:45 <dash> well, it's val -> store -> val right now
21:59:00 <heatsink> For example, backtracking monads (call/cc could be considered a kind of backtracking) don't necessarily pass older states around. Instead, the >> operator encapsulates the backtracking behavior.
21:59:01 <wagle_ungone> Store doesnt change?
21:59:56 <dash> wagle_ungone: hrm 
22:00:05 <dash> i'm not sure i understand
22:00:09 <wagle_ungone> I assuming something like Store = Ide -> Val
22:00:22 <dash> yeah
22:00:30 <dash> maps an integer to a value
22:00:52 <wagle_ungone> (Ide == "identifier")
22:03:04 <wagle_ungone> i havent done one of these for awhile..  cant recall off the top of my head why Ans contains the result Store
22:04:20 <wagle_ungone> hmm..  maybe if the semantics is fully cps, you dont need to compose state functions
22:05:15 <wagle_ungone> i havent gotten around to fully monadifying such an interpreter either, so that might change things too..
22:06:02 <wagle_ungone> i was half asking because you might already know why Ans = Val, and not (Val, State) like i suggested
22:08:11 <wagle_ungone> ...  i guess if you compose continuations, then you want to know what the result states are
22:08:35 <wagle_ungone> ...  as I said i'm confused (and very sleepy)
22:10:32 <dash> yeah, that's pretty much it, you extend the continuation to include the new store
22:10:43 <dash> and i am realizing i implement list quoting wrong
22:10:50 <dash> so it's not time to get too fancy yet
