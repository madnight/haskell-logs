01:05:57 * Lemmih wonders why there hasn't been a new greencard release in the last 17 months.
01:25:11 <Boegel> hello everyone
01:25:37 <Lemmih> Hey Boegel
01:26:26 <Boegel> did you see that guy who was also writing a raytracer ? how's his progress ?
01:31:43 <Lemmih> I have no idea.
01:33:26 <musasabi> hello Boegel 
01:35:27 <Boegel> hello musasabi
02:20:40 * Boegel signs off
04:30:46 <tromp> http://www.isthe.com/chongo/tech/comp/calc/calc-whatis.html
04:31:23 <tromp> seems calc and ghci disagree on value of ( 2^23209-1 ) `mod` ( 2^127-1 )
04:32:32 <Philippa_> do you know what type each of them's doing the arithmetic with?
04:33:25 <dv> hugs gives 39614081257132168796771975167
04:33:39 <tromp> both use arbitrary precision integers
04:34:01 <tromp> ghci also gives 39614081257132168796771975167
04:34:59 <tromp> ah! i figured it out
04:35:06 <tromp> the web page is misleading
04:35:22 <tromp> it first gives one example, then another
04:35:40 <tromp> and then refers to "the last results"
04:35:53 <tromp> which shld actually refer to 1st example
05:02:56 <kosmikus> dblhelix: ping
05:27:25 <Maddas> Is there any documentation for lambdabot other than the readme and the source?
05:27:46 <Maddas> Or should I look at something else if I were to write my own bot :-)
05:28:40 <kosmikus> I don't think there's documentation.
05:29:20 <kosmikus> I looked at lambdabot a bit recently, I find most of the code well understandable.
05:30:19 <kosmikus> ... and documentation patches are certainly welcome ;)
05:31:41 <Maddas> Ok :-)
05:32:47 <earthy> :)
06:04:44 <shapr> Good Morning #Haskell!
06:05:36 <shapr> dons: ayh?
06:06:20 <shapr> Maddas: hey, if you want to patch lambdabot, use the darcs repo, send me some patches.
06:06:37 <shapr> if you send cool patches, then you get commit privs to the repo
06:07:58 <thebug> 'morning shapr :)
06:08:39 <shapr> Greeting Mr. Entomologist.
06:09:23 <shapr> I stared at Patch.lhs today, and I have the vague suspicion that it could be faster if patch ops used arrows.
06:13:09 <arjanb> shapr: trying to solve all problem in the world with arrows? :-)
06:13:17 <shapr> heck yeah
06:13:26 <shapr> at least until I've found the edges of the uses of arrows
06:29:37 <Lemmih> shapr: Yo.
06:30:06 <thebug> @yow
06:30:07 <lambdabot> These PRESERVES should be FORCE-FED to PENTAGON OFFICIALS!!
06:30:08 <Lemmih> shapr: I'm still very much interested in installing Hackage on haskell.org
06:30:45 <shapr> cool, I might have time to set it up this weekend
06:31:03 <Lemmih> Great.
06:34:33 <thebug> I see lambdabot is alive and well ;)
07:07:49 <rillig> hi. Can you give me some hints how to build ghc from source?
07:07:57 <rillig> I already have the files from CVS.
07:08:18 <rillig> Then I ran "autoreconf -i" and tried to "gmake".
07:09:17 <rillig> And then I got this:
07:09:18 <rillig> gmake[2]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop.
07:15:47 <Oejet_> rillig: Did you read the Using from CVS page: http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html and the Building page: http://www.haskell.org/ghc/docs/latest/html/building/sec-building-from-source.html ?
07:17:27 <rillig> I have read the former at atm am reading the latter.
07:21:50 <shapr> dons: http://www.scannedinavian.org/YiWiki/
07:21:57 <shapr> dons: no content yet.
07:25:30 <shapr> hoi jyp, hoe gaat het?
07:25:42 <jyp> hello
07:25:52 <shapr> how's code?
07:26:19 <jyp> Just dropping to say that I'm sorry to have disc'ed w/o explanation the other day... Technical problems.
07:26:41 <shapr> no worries
07:27:07 <shapr> irc requires either a relaxed attitude or high blood pressure medication....
07:27:42 <jyp> haha ;) To be sure, my name is Jean-Philippe Bernardy.
07:27:51 <shapr> oh!
07:28:03 <shapr> salut!
07:28:03 <jyp> You might have seen some of my babbling on the mailing list
07:28:09 <shapr> Yes, I have :-)
07:31:58 <shapr> I'm Shae Erisson, you may have seen some of my babblings too.
07:32:23 <jyp> Indeed I have
07:33:17 <jyp> I understand you keep the wiki alive (among other things)
07:39:02 <shapr> I do have responsibility for the wiki, but Cale, TheHunter, and others put more work into it than I do.
07:40:46 <shapr> jyp: google turns up some rather interesting things about you :-)
07:40:53 <shapr> Cobol??
07:40:54 <shapr> yow!
07:42:48 <jyp> Does it *blush* ? I might have done mistakes in my youth ;)
07:42:59 * shapr laughs
07:44:12 <shapr> You use emacs, yes? Have you seen Yi?
07:44:28 <jyp> Emacs user, positive.
07:44:46 <jyp> I don't know what "Yi" is.
07:45:21 <shapr> Yi is an editor written in Haskell, darcs get http://www.cse.unsw.edu.au/~dons/yi
07:45:47 <shapr> you can see the mailing list archives for more info - http://lists.scannedinavian.org/pipermail/post-emacs/
07:46:35 <shapr> Hopefully, Yi will become an emacs-like (and vim-like, joe-like, etc) editor scripted in Haskell.
07:46:50 <jyp> That sounds really cool
07:47:03 <shapr> c'est tres interessante
07:47:25 <shapr> intressante? french classes were so long ago...
07:47:51 <thebug> ceci ce n'est pas une pipe :)
07:47:53 <thebug> |
07:48:23 <jyp> I'm afraid I can't return the courtesy... My Norsk is non-existant ;)
07:48:23 <shapr> sure looks like one to me
07:48:52 <jyp> c'est tres interessante = it's very interesting
07:49:05 <thebug> nope, it's only the pixellated ASCII representation of a pipe :)
07:49:13 <shapr> My swedish is minimal as well. I'm originally from Alabama.
07:49:39 <rillig> pourquoi pas "c'est tres interessant" ?
07:49:40 <shapr> spreekt u nederlants ook?
07:49:43 <jyp> Your name doesn't betray your origin ;)
07:49:55 <rillig> shapr: Ich jedenfalls nicht.
07:50:06 <shapr> ich habe keine ahnung!
07:50:26 <jyp> I understand dutch somewhat but don't speak it
07:50:35 <jyp> Same for german
07:51:13 <shapr> I enjoy the hard g from dutch. It's fun to say.
07:52:01 <jyp> The prononciation varies alot. It's much softer here in Brussels.
07:52:26 <shapr> Nijmegen Dutch is nice. Maybe they only have heavy smokers in Nijmegen?
07:52:27 <jyp> Alot like English "h"
07:54:08 <shapr> technical difficulties :-)
07:54:45 <earthy> shapr: you made 2 mistakes in the `Spreekt U ook Nederlands'. :)
07:55:56 <shapr> whoops, thanks.
07:56:07 <shapr> hoi earthy, how's code?
07:56:11 <earthy> annoying
07:56:27 <earthy> but that's more to do with trying to build coproducts with mediating morphisms that need class constraints
07:56:51 <earthy> which is, basically, impossible. ;)
07:57:02 <shapr> I take your word for it...
07:57:33 <shapr> I'm sticking with arrows lately.
07:57:35 <earthy> (or you'd have to be able to give class constraints as parameters to functions...)
07:57:37 <shapr> And paying work, of course.
07:57:51 <shapr> Speaking of which, arrows have that same problem.
07:58:05 <shapr> Can you use GADTs to beat the class constraints?
07:58:12 <earthy> haven't thought of that yet
07:58:27 <earthy> might have to look into that... hm.
07:58:28 <earthy> thanks :)
07:58:46 <shapr> it doesn't work for arrows because you need to be able to change the class constraints on the class definition.
07:59:09 <shapr> But for what you're talking about, GADTs might fix it.
07:59:20 <earthy> I doubt that
07:59:40 <earthy> anyway, I need to know how to work around it in any case :)
08:00:23 <shapr> GADTs let you put class constraints on datatypes, and functions that go along with those datatypes.
08:02:07 <earthy> aha
08:02:25 <earthy> no. that won't fix my problem. :)
08:03:14 <TheHunter> shapr, i've had that (though gadts'd solve it only on one side of the arrow). Turns out, it doesn't work (unnecessary dictionarys would have to be passed around, i guess).
08:03:55 <TheHunter> hmm, idea needs to be somewhere in that sentence...
08:08:22 <kosmikus> well, in principle, you don't need classes anymore when you GADTs, are content with closed classes, and are willing to write all type arguments explicitly
08:08:43 <kosmikus> there's a "have" missing somewhere in that sentence ...
08:12:11 <earthy> hm.
08:12:17 <earthy> still won't solve the base problem :)
08:12:53 <shapr> kosmikus: what? can you explain that?
08:12:53 <shapr> greetings WebGuest 
08:13:51 <shapr> so, you're saying, it's possible to write an explicit arrow GADT for each datatype?
08:14:15 <shapr> hey, who here has a weblog?
08:14:38 <WebGuest> anyone seen Boegel?
08:14:57 <shapr> I've started collecting Haskell weblog links, in preparation for a Planet Haskell.
08:15:03 <shapr> @seen Boegel
08:15:03 <lambdabot> I saw Boegel leaving #haskell 5 hours 54 minutes 28 seconds ago.
08:15:17 <earthy> good. time to go.
08:15:37 <shapr> Anyone know of any haskell-related weblogs with RSS feeds?
08:16:06 <shapr> I have SyntaxPolice, Peter Gammie, and me.
08:16:33 <shapr> Ah, I could add ibid too.
08:16:55 <thebug> does lambda-the-ultimate count as a weblog, or a forum?
08:17:10 <WebGuest> if anyone sees Boegel, please hook him up with this image: http://img49.exs.cx/img49/8617/haskell-raytrace-09.png
08:17:14 <thebug> might add that
08:17:29 <WebGuest> thanks later all
08:17:49 <shapr> WebGuest: nice, where's that from?
08:17:55 <thebug> awesome pic
08:18:08 <shapr> dang, I want source for that...
08:19:00 <shapr> LtU is only sort of haskell related.
08:19:23 <thebug> I realize that, but it is very interesting site :)
08:20:02 <kosmikus> shapr: sure, I can explain it :)
08:21:12 <kosmikus> but maybe not now ... have so much still to do today; please remind me tomorrow or on Monday
08:21:22 <shapr> though LtU hasn't had much traffic the last week or so
08:21:25 <shapr> sure, I'll remind you
08:21:32 <shapr> if I remember ...
08:22:37 <shapr> I should probably go back to work...
08:22:56 <shapr> At least the new antispam stuff on HaWiki seems to be working.
08:23:33 <kosmikus> well, maybe I'm actually thinking too complicated here; you can always simulate type classes as datatypes/records, and instances as values of that type, and the only extension you need for that to work is polymorphic fields in datatypes
08:23:48 <kosmikus> I think you need GADTs to simulate functional dependencies, though
08:24:09 <shapr> I shall save that and chew on it later.
08:24:29 <shapr> Right now, I have twelve hours of Python hacking ahead of me.
08:34:18 <shapr> Ã³la masm 
08:34:32 <shapr> cute nickname.
08:40:18 <masm> Is it?
08:57:40 <shapr> sure, masm.exe was an early macro assembler.
08:58:08 <shapr> I don't know if it's still around.
08:58:15 * shapr reads http://www.dreamsongs.com/WorseIsBetter.html
08:58:20 <thebug> it can be had around the internet
08:59:17 <thebug> actually, it's still a part of vs.net [at least .net studio 2002]
08:59:25 <shapr> neat
09:01:33 <shapr> Reading Christopher Alexander's introduction to "Patterns of Software: Tales from the Software Community" makes me want to stand up and put my hand over my heart, or salute or something.
09:35:40 <shapr> hoi goron 
09:39:05 <shapr> blackdog: installed curryspondence or BLob?
09:42:18 <skuggi> shapr: what is the book about?
09:42:39 <skuggi> and what does the introduction say?
09:47:47 <shapr> skuggi: read it - http://www.dreamsongs.com/NewFiles/PatternsOfSoftware.pdf
09:47:52 <shapr> I'm reading stuff here - http://www.dreamsongs.com/WorseIsBetter.html
09:48:00 <shapr> I'm also writing a blog entry about it.
09:48:29 <shapr> But I'm having a hard time putting into words a crystal-clear realization that I had some weeks ago about Worse is Better.
09:48:30 <skuggi> k
09:48:44 <shapr> Maybe I can try it here some
09:49:33 <shapr> Worse is Better is about Unix being simpler than VMS code-wise, so it means that apps have to do more for themselves, but it means that unix got ported everywhere long before VMS did.
09:49:52 <skuggi> k..
09:50:00 <shapr> So, Worse in one sense means that the App shouldn't have to do stuff that the OS should be doing for you.
09:50:17 <shapr> But in another sense, the OS that can be ported more easily is clearly superior.
09:50:29 <shapr> So, maybe 'worse is better' ?
09:50:36 <shapr> I've been thinking about that for years.
09:50:54 <dv> maybe it's an irrelevant question
09:51:32 <shapr> And I realized: "Simplicity of implementation is the number one goal in all code. That *is* The Right Thing."
09:51:55 <shapr> Of course, that statement is maybe not so surprising unless you've read all the various papers Gabriel has written about 'Worse is Better'
09:52:26 <shapr> Monads were the real shock to me, they're so simple, and yet they do just as much as objects.
09:52:31 <shapr> Maybe even more.
09:53:00 <shapr> Python was my first step on this path towards combining simplicity and The Right Thing
09:53:48 <shapr> As language tradeoffs go, Python has both simplicity and power that becomes more than the sum of most of the other languages I've used.
09:54:22 <shapr> I've always thought that simplicity and power were direct tradeoffs, and that is also the premise of "Worse is Better" but now I realize, they're not direct trade-offs.
09:54:52 <shapr> In fact, simplicity is power in many cases.
09:55:26 <shapr> Haskell and monads are good examples of that.
09:56:36 <shapr> So I've realized that with the correct choice of pieces and ways to combine those pieces, you can have a far more expressive system than the 'sum of the parts' or whatever.
09:56:55 <shapr> Any thoughts on this?
09:57:18 <shapr> I think esap is following that path, I think Category Theory holds some of these secrets.
09:57:54 <dv> hey a while back someone gave a link that described category theory in simple words and pictures, would you still happen to have that link?
09:58:54 <kosmikus> hmm, category is just simple words ("object","arrow") and pictures (i.e., commutative diagrams). seriously, I'd still like to know a really good book on CT myself ...
10:00:37 <Philippa_> shapr: monads /do/ do more than objects. But yeah. I'm v.much working on that in the small in terms of how Flippi's structured and how it can be configured, for example
10:00:46 <Philippa_> and I'd love time/money to do more on it in the large
10:01:14 <Philippa_> kosmikus: somebody on clf recommended something like "computational category theory", I need to fire up my DLed copy again and carry on reading...
10:01:18 <shapr> dv: http://www.xp123.com/wwake/dissertation/model.shtml
10:01:20 <Philippa_> it looked like it had real potential though
10:02:09 <dv> shapr: thanks
10:02:59 <Philippa_> http://www.cs.man.ac.uk/~david/categories/ <- the one I mentioned
10:03:37 <kosmikus> thanks
10:03:42 * esap suggests Lawvere: Sets for mathematics for a good intro to category theory (via set theory).
10:04:35 <Philippa_> shapr: I really do think arrow types correspond to metaclasses in some deep and meaningful way
10:04:51 <esap> philippa: metaclasses?
10:05:00 <shapr> esap: do you have a webpage, blog, or other online repository of your explorations?
10:05:37 <esap> shapr: not all of it, for sure. I wish I had.
10:05:43 <Philippa_> esap: literally "the class of a class", there're all sorts of funky things you can do with them in Smalltalk or Python that look a lot like things you can do with arrows and monads
10:06:06 <shapr> For example, metaclasses define things like inheritance, delegation, etc
10:06:07 <esap> philippa: I know what metaclasses are. But I'm not sure how arrow types relate to them.
10:06:12 <shapr> ah
10:07:39 <Philippa_> esap: sorry for the patronisation then. But yeah, arrows and monads define the semantics a system works in - in particular, they kinda govern instantiation of stuff within the arrow or monad (return/pure etc etc), they can do delegation on stuff that's within the arrow or monad...
10:07:45 <shapr> esap: Do you have anything online that I can link to from my blog?
10:08:50 <esap> shapr: hold on, I do have something. Not very much and clearly not the most interesting parts of what I've been doing, but I suppose that's better than nothing :-)
10:08:53 <Asta> hello
10:08:56 <shapr> hi Asta
10:08:59 <Asta> what kind of file is this:
10:09:00 <Philippa_> that feels a lot like the sorts of things you do with metaclasses - "classes behave like this"
10:09:00 <Asta> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/parser/Parser.y.pp
10:09:12 <Asta> hi shapr        
10:09:22 <Philippa_> ~= "from one level of abstraction up, everything in the system behaves like..."
10:09:33 <Asta> is that "Happy", "Parsec"? 
10:09:40 <Philippa_> probably happy
10:09:49 <Philippa_> parsec's a library, parsec parsers're plain haskell 98 code
10:09:50 <esap> philippa: Ah you mean how the arrow types and operations on them can define the abstractions to be used (or the "language").
10:09:56 <Philippa_> yeah
10:09:56 <Asta> oh
10:10:05 <Asta> which do you recommend, happy or parsec?
10:10:07 <shapr> Asta: look at the comment near the top
10:10:22 <shapr>  * We must expand these macros *before* running Happy, which is why this file is
10:10:22 <shapr>  * Parser.y.pp rather than just Parser.y - we run the C pre-processor first.
10:10:30 <Philippa_> depends what you want. Personally I'm a parsec fan - speed's not a priority for me, readability and not having to mess about with code generation /are/ priorities
10:11:02 <Philippa_> esap: in particular the level of "language" they define
10:11:21 <Philippa_> in that it's a level more abstract than datatype+algebra on that type
10:11:32 <Philippa_> which kinda corresponds to class, IYSWIM
10:11:49 <Asta> shapr: yes... you're right, I should have pasted Parser,y
10:12:05 <Philippa_> not unless you wanted to get yelled at for flooding :-)
10:12:06 <Asta> Philippa_: speed is not important for me either
10:12:16 <Asta> I just looked at Happy yet
10:12:22 <Philippa_> Parsec's worth looking at
10:12:41 <Philippa_> if you're familiar with BNF et al, it's beautifully easy to work with
10:12:52 <esap> shapr: Have you seen http://www.kotiposti.net/epulkkin/summary.dvi ?
10:12:55 <Philippa_> well, assuming you grok monads to an extent, anyway
10:13:01 <Asta> seemed easy to use but it has no lexer and catching errors didn't seem trivial
10:13:18 <Asta> yes I get along with monads
10:13:23 <Philippa_> alex would be happy's lexer counterpart
10:13:25 <Asta> do not master them completely yet
10:13:33 <Asta> oh I didn't know about alex
10:13:43 <Philippa_> 'k. Look into Parsec then - it's in the hierarchical libs these days
10:13:58 <Asta> nice
10:14:21 <Philippa_> plus if you learn it you can contribute new syntax to Flippi ;-)
10:14:30 <Asta> :)
10:15:05 <Philippa_> esap: so, er, conversation worth continuing with? Does it make sense? If so, is it any news? Does it very much not make sense?
10:15:16 <Asta> Hmm seems like Parsec is also a Fast-paced multiplayer cross-platform 3D Internet space combat...
10:15:28 <xkb> yeah :)
10:16:01 * Philippa_ is increasingly getting the urge to go out and redefine OO in FP-like terms in a prominently public place, but hey :-) I should add coinheritance to tyop...
10:16:21 <esap> philippa: Yes, it's worth continuing. I'm still thinking what you said.
10:16:29 <bourbaki> moin
10:16:59 <esap> philippa: I think you refer to layering, or to the abstractness of types.
10:17:11 <shapr> esap: I haven't seen that before, and I don't understand it on the first reading either.
10:17:46 <Philippa_> hrmm, possibly. It sort of feels like an inversion of at least some of the layering I'd typically see in an OO design though, if that makes sense.
10:17:52 <esap> shapr: It's a bit old in that I've changed the design of my language a lot since that.
10:18:03 <esap> shapr: But the basic idea about the control operator is still there.
10:18:46 <Philippa_> or possibly an inversion of (some of) the dependencies in the layering
10:18:55 <esap> philippa: what kind of inversion? You mean the distinction between "containment" and "inheritance"?
10:19:48 <esap> philippa: Or duality between functions and layers?
10:20:10 <Philippa_> possibly. Or maybe I'm getting things skewed a little. Maybe the difference between inheritance, composition and being in communication with
10:20:34 <Philippa_> composition probably being containment in your sense
10:21:03 <esap> philippa: ok I think I see what you mean.
10:21:07 <Philippa_> I think most of "what I'm thinking" is that I would be unlikely to see something like the list monad in an OO language
10:22:38 <Philippa_> in fact, I'm not sure how you'd go about expressing it
10:23:16 * shapr finishes off the blog entry.
10:23:20 <Philippa_> of course, my reaction to Smalltalk was that it felt like a wilfully impure ML, so I could just be weird :-)
10:24:23 <xkb> shapr: where's your blog?
10:25:00 * esap is thinking about the list monad in OO. Pretty difficult actually.
10:25:49 <shapr> xkb: http://www.ScannedInAvian.com/
10:26:03 <xkb> ah thanks :)
10:26:14 <Philippa_> it'd be trivially doable in Smalltalk FCVO "doable", but that's only because Smalltalk's the world's most impure functional language
10:26:29 * shapr quickly quotes that
10:26:40 <Philippa_> I thought you might like that :-)
10:26:49 <thebug> yay Smalltalk :)
10:27:20 <esap> philippa: I suppose the corresponding thing in OO would use circular lists, not finite lists.
10:28:03 <esap> philippa: OO is not good on algebraic datatypes, usually you'd replace it with its dual (coalgebraic datatypes).
10:28:25 <esap> philippa: though the effect is somewhat different semantically.
10:28:51 <Philippa_> yeah, I *hate* having to patternmatch in OO code
10:29:42 <shapr> Isn't that called the Visitor pattern?
10:29:55 <Philippa_> yeah. That, or "extreme masochism"
10:30:02 <esap> philippa: though maybe just a stateful list (e.g. something like list<X> with push_back would do similar things, with the list being passed as argument.
10:30:06 <Philippa_> our compilers course at uni was taught in Java
10:30:18 <Philippa_> and we were given an existing codebase to modify
10:30:25 <Philippa_> I had bad enough depression at the time /anyway/...
10:30:44 <bourbaki> is there a package for haskell for for finding eigenvalues and other matrix stuff?
10:30:52 <esap> Visitor pattern, is btw, similar to fold.
10:31:13 <shapr> but more similar to pattern matching...
10:31:18 <shapr> bourbaki: probably
10:31:29 <shapr> if you find one, I want to know :-)
10:31:44 <bourbaki> heh
10:31:53 <bourbaki> i guess ill write one then
10:31:59 <Philippa_> yeah. Only more painful - I mean, it makes (unfortunate) sense if you're stuck with extensible types, but having to put all the visiting code inside the classes as a result feels... wrong
10:32:14 <shapr> bourbaki: I think I've seen one or two, but I don't remember for sure. Google will know.
10:32:19 <Philippa_> but yeah. Shall we find a different example before I conclude that the visitor pattern proves OO is EBW? :-)
10:32:29 <esap> EBW?
10:32:33 <shapr> EBW?
10:32:44 <Philippa_> Evil, Bad & Wrong
10:32:47 <bourbaki> do you remember the freggles? what was the name of that talking all knowing trash place?
10:32:57 <shapr> Egregarious Bad Waste?
10:33:08 <shapr> I loved the fraggles.
10:33:13 <esap> philippa: well OO is not EBW. I think using OO to build applications is EBW.
10:33:17 * shapr sings "Down at Fraggle Rock"
10:33:18 <Philippa_> heh
10:33:28 * shapr laughs
10:33:32 <shapr> another good quote.
10:33:36 <Philippa_> yeah, OO makes a lot of sense for simulations and for systems with serious levels of IO
10:33:49 <Philippa_> the thing there is you use it to model the entire system, not just the computational bit...
10:34:01 <esap> philippa: OO makes a lot of sense when you're requirements are reuse. Basically for platform code, OO is ok.
10:34:09 <shapr> bourbaki: the dozers were so cool... making edible sculptures all the time. What were they made of? Rutebagas? Turnips? I forget.
10:34:27 <bourbaki> shapr in german that talking trash thing is called the allknowing trashplace and i refer to the internet with that name ;)
10:34:39 <shapr> What's the name in german?
10:34:53 <bourbaki> shapr die allwissende muellhalde :)
10:35:07 <Philippa_> esap: even then I'm inclined to be snarky about it. That said, did I explain how a friend commented that the arrows framework sounds a lot like one particular model of OO?
10:35:14 <bourbaki> the internet knows anything also and its also trash ;)
10:35:22 * shapr agrees
10:35:45 <esap> philippa: no, I haven't heard that. Which model of OO?
10:36:07 <Philippa_> probably easier to describe how I'd explained arrows to him
10:36:20 <bourbaki> thats why i keep asking here cause i get better answers here usually then google will bring up usually :)
10:36:40 * shapr grins
10:36:53 * stepcut is hacking KDE right now, and not loving OO
10:37:29 <Philippa_> which was as a bunch of black boxes - some of which are the combinators in the relevant signiatures, some are the extra operations provided by the particular arrow type, some of which are bits of user-supplied wiring provided by pure and some of which're just amalgamations of other black boxes - all wired together by lots and lots of >>>
10:37:50 <esap> philippa: OO is about black boxes.
10:38:01 <Philippa_> and about the wiring between 'em. Yeah.
10:38:09 <Philippa_> well, FP's /all/ about wiring...
10:38:10 <shapr> and stateful boxes...
10:38:17 <shapr> which is very much arrows.
10:38:43 <Asta> so far I've just used arrows with pairs, to simplify point free style definitions
10:38:52 <Asta> I wonder how much I'm missing
10:39:23 <Asta> stepcut: working KDE bindings for Haskell? :)
10:39:26 * shapr starts talking trash about hylomorphism expressed via Freud categories
10:39:49 <Philippa_> what's a Freud category? One with a phallic-looking diagram?
10:39:49 <stepcut> Asta: no, that comes later
10:39:50 * Asta googles freud categories
10:39:58 <stepcut> Asta: I am fixing the samba exporting dialog
10:39:59 * shapr laughs
10:40:12 <shapr> Asta: I'm joking...
10:40:15 <esap> philippa: Yes, I agree, FP is about relationships and wiring. OO is about *what* is connected by the relationships.
10:40:22 <Asta> stepcut: oh so it might actually come sometime?
10:40:27 <Asta> shapr: ah
10:40:40 <shapr> Asta: first of all, they're really "Freyd categories" Freud Categories is something else entirely =)
10:41:01 <Asta> shapr: hmm I never heard of fryed categories either...
10:41:04 <Philippa_> hence the "phallic-looking diagram" comment :-)
10:41:09 <Philippa_> freyd categories = arrows, basically
10:41:12 <shapr> Philippa_: very snappy comeback
10:41:35 <Philippa_> as it were
10:41:40 <shapr> aiee
10:41:50 <shapr> evil puns
10:42:06 <shapr> If I save a freud category diagram joke about arrows... will anyone ever get it?
10:42:34 <stepcut> the warriors did it!
10:44:26 <Philippa_> shapr: I imagine somebody will
10:45:32 <Philippa_> esap: stupid question - how easy is it to implement a comonad in an OO setting?
10:45:40 <Etaoin> if a cost center has 50% of the allocation, is that why it has 60% of the time?
10:45:46 <Philippa_> I mean, aside from having to /understand/ comonads? :-)
10:46:22 <Philippa_> Etaoin: I couldn't speak for Haskell code, it'd be pretty likely in, say, C++ though
10:47:33 <esap> philippa: I think it should be pretty easy. I haven't worked on the details.
10:48:49 <esap> philippa: If I'm not mistaken, I think comonads should represent an inheritance hierarchy.
10:49:30 <Philippa_> comonads, or stacks of comonad transformers on top of an identity?
10:49:31 <esap> hmm.. actually, I'm not sure.
10:51:12 <esap> philippa: anyway, comonads are closely related to manipulating (abstract) input.
10:51:33 <esap> philippa: just as monads are related to manipulating output.
10:52:21 <Asta> hmm monads are about manipulating output?
10:52:50 <esap> think of "IO a" as a "type of computation that produces output of type a"
10:53:06 <Asta> ok
10:53:14 <Philippa_> or possibly "type of computation that produces an output of type a plus a load of IO"
10:53:29 <Asta> could you give an example with comonads too?
10:53:33 <Philippa_> though that doesn't generalise so well to eg the list monad
10:53:34 <Asta> to understand the difference...
10:53:56 <Philippa_> did anybody ever figure out how to define an OI comonad? :-)
10:54:01 <esap> philippa: The "IO" part describes which layer of output is produced.
10:54:20 <Asta> Philippa_: I usually think of the list monad as a non-deterministic computation
10:54:43 <Philippa_> Asta: sure. It makes a great counterexample to overly-specific analogies about monads though
10:54:59 <Asta> yeap
10:55:06 <esap> philippa: I think parallel computation is needed for OI, though I think it's not really compatible easily with referential transparency.
10:56:00 <Philippa_> esap: "layer" starts to feel a bit iffy, though I guess in fairness a Haskell program kinda develops a "semantic stack" if you consider IO as the default rather than pure
10:56:42 <esap> philippa: heh, there are many kinds of layers. Every tree-shaped structure has layers.
10:57:02 <Philippa_> right, and the semantic-stack-over-time is a tree
10:57:24 <Philippa_> at which point I now feel actually /comfortable/ with your description :-)
10:57:58 <Philippa_> that said, in this particular case it's not unknown for a piece of code to use two or more layers of the stack
10:58:22 <Philippa_> eg just about anything of type IO (m a)
10:58:24 <esap> philippa: I'm not quite sure what you mean by 'semantic stack'.
10:58:37 <esap> philippa: because there are so many things I could mean with that.
10:59:01 <Philippa_> a stack whose values are sets of semantics that programs run in
10:59:15 <Philippa_> eg the bottom of the stack in any Haskell program is the semantics corresponding to the IO monad
10:59:36 <esap> philippa: what's the next upper level after IO?
10:59:37 <Philippa_> from there you might "push" pure semantics by returning a load of stuff, and from there you might push something else with a runFoo
10:59:59 <Philippa_> returning as in the monadic return function
11:00:16 <shapr> well, back to work for me...
11:00:20 <Philippa_> you might even runBarT inside the Foo monad for a more interesting example
11:00:48 <esap> philippa: ok, I think you mean the aggregation hierarchy defined by functors?
11:01:05 <esap> philippa: basically anything that has kind * -> *
11:01:08 <Philippa_> er, maybe
11:01:28 <Philippa_> but that as applied to "languages" in the sense that monads and arrows form them
11:02:02 * stepcut kicks C++ in the nads
11:02:14 <Philippa_> if C++ had monads it'd be a lot easier to cope with ;-)
11:02:23 <TheHunter> esap: hmm, stupid question, what's \\ supposed to mean?
11:02:34 <esap> TheHunter: subtraction.
11:02:39 <Philippa_> though I guess it's better than Java. I mean, you can't kick Java in the nads, it doesn't have any (or any other genitalia)
11:03:13 <esap> TheHunter: See "Crolard: Subtractive Logic" for a good intro.
11:03:16 <xkb> err. that's n odd statement :D
11:03:26 <TheHunter> esap: ok, thanks
11:03:36 <Philippa_> xkb: I'm suggesting that Java as a language is castrated :-)
11:04:18 * Philippa_ wonders what coinheritance would've been called if inheritance hadn't been discovered first
11:04:30 <esap> TheHunter: The semantics is close to coroutines and close to continuations.
11:04:36 <xkb> Philippa_: I kinda like working with java :D
11:04:50 <xkb> not so much because of the language
11:05:04 <xkb> more due to the frameworks
11:06:25 <bourbaki> TheHunter moin
11:06:25 <Philippa_> quite
11:06:33 <Philippa_> I'd like to have better frameworks in better languages than Java
11:07:00 <TheHunter> hmm, maybe, that's an instance of the worse is better dilemma: in java, you don't have polymorphism, so the IDE can figure out much more what you're trying to do and offer autocompletion etc.
11:07:11 <TheHunter> moin, bourbaki 
11:07:21 <esap> Java is too much based on its libraries. The problem is, the libraries are very badly designed due to problems with the language.
11:07:53 <esap> The language imposes a way of thinking that's harmful.
11:08:11 <esap> And too narrow
11:08:16 <bourbaki> esap this phenomenon also has a name :) bulb paradoxon
11:09:15 <esap> strange name, I've never heard that one.
11:09:53 <bourbaki> i think ive even read it in one of the articles linked form haskell.org
11:10:06 <esap> bourbaki: do you have a reference?
11:10:39 <bourbaki> esap sec i try to find the article again
11:11:46 <Philippa_> esap: one of my pet hates about the Java libs is that often you get an actually quite good decomposition of the problem domain, then no good way to recombine it if you have one of the simple cases...
11:12:29 <esap> philippa: Java only has half of a good solution, but it totally lacks the other half.
11:12:49 <Philippa_> quite
11:12:54 <esap> philippa: that is, Java only has OO, but not FP :-)
11:12:59 <bourbaki> esap http://www.haskell.org/complex/why_does_haskell_matter.html
11:13:00 <xkb> lol
11:13:02 <Philippa_> the problem is I tend to be in need of the half it doesn't have more than the half it does
11:13:23 <Philippa_> I'm not sure which of Lisp or Smalltalk I'd prefer had I been born 20 years earlier, mind
11:13:33 <esap> philippa: then you're writing applications in Java? :-9
11:13:34 <Philippa_> only I'm too big on static typing for either now
11:13:38 <bojohan> "The Blub Paradox", paul graham
11:13:50 <bourbaki> right
11:14:02 <Philippa_> esap: Thankfully no. But I'll give you one guess what the main language is at uni
11:14:26 <Philippa_> I really, really don't like assignments where we can't pick an appropriate language for the task, because IMO as a /language/ Java is inappropriate for pretty much anything :-)
11:15:03 <esap> philippa: I suppose it's good for writing platforms :-) But what do you use the platform for, if you can't write the application in the same language....
11:15:49 <bourbaki> esap http://store.yahoo.com/paulgraham/avg.html
11:16:28 <Philippa_> esap: it's a shitty way to write a platform too IMO. Even the platform needs to be wired together properly
11:16:48 <Philippa_> and yampa beats the crap out of most "game simulation" classes I've seen, for example
11:17:21 <bourbaki> is yampa more then a simple state machine
11:17:21 <bourbaki> ?
11:17:40 <esap> philippa: ah but for platform wiring, inheritance, aggregation and subtyping are quite sufficient.
11:18:24 <Philippa_> bourbaki: bingo, the parallel switching stuff's plenty sufficient to add a growing-and-shrinking set of state machines within it
11:19:00 <Philippa_> esap: you mean you've never written something a bit like map at the platform level? :-)
11:19:08 <esap> bourbaki: In that article, Paul graham is saying that power equals good.
11:19:12 <Philippa> esap: you mean you've never written something a bit like map at the platform level? :-)
11:19:17 <Philippa> bourbaki: bingo, the parallel switching stuff's plenty sufficient to add a growing-and-shrinking set of state machines within it
11:20:48 <esap> philippa: well I have, though it's not problem for the platform, it's problem for the users of the platform :-)
11:21:08 <esap> philippa: including the next layer of the platform, I suppose .-)
11:22:20 <esap> philippa: The problem is, a map that doesn't use parametrization is restricted to being very narrow in its applicability.
11:22:41 <Philippa> and to 1 in, let's be charitable, 100 implementations being broken
11:22:44 <Philippa> but yeah
11:24:51 <Philippa> half the reason I get bitchy about OO is I'm fed up of having to fix all the mistakes it invites me to make
11:25:18 <tuomov> never having really programmed in java, I'm appalled by the bloatedness of its libraries
11:25:29 <esap> philippa: mistakes? If OO is used for what it's intended for, I suppose it's not that easy.
11:26:09 <esap> philippa: Though I have very strict view of what OO is.
11:26:25 <bourbaki> anyone of you familiar with startistics and linear algebra?
11:26:29 <stepcut> so, this class has two methods, 
11:26:30 <stepcut> setValue (const QString & name, const QString & name );
11:26:45 <stepcut> setValue (const QString & name, bool value );
11:26:56 <Philippa> C++, I take it?
11:26:59 <stepcut> (that second name shoud be a value in the first method)
11:27:18 <stepcut> I called, setValue("guest ok", "no"), which, of course, invoked with second method
11:27:37 <stepcut> and since "no" gets cast to true, it did the opposite of what I wanted :)
11:27:44 <stepcut> nice, eh ?
11:27:49 <esap> stepcut: That's a problem with overloading and conversions.
11:28:02 <stepcut> esap: indeed it is
11:28:18 <Philippa> I used to like C++. I've since decided that tacnuking my foot isn't fun.
11:28:30 <stepcut> esap: I know *why* it happened, but that does not mean I could anticipate what would happen
11:28:49 <tuomov> I've always been appalled by c++'s abuse of operators for two very different things
11:28:55 <tuomov> esp <<
11:29:14 <Philippa> tbh that's the least of it most of the time
11:29:14 <tuomov> it's a bit shift!
11:29:25 <esap> overloading is really good for optimizing code for performance.
11:29:29 <Philippa> though sometimes you do need esp to use <<...
11:31:24 <earthy> :)
11:32:48 <esap> tuomov: I think the overload of << is not that bad. Bit-shifting is not that important operation anyway.
11:33:48 * esap lost interest in C++ once I understood how 'sizeof' operator worked.
11:34:31 <stepcut> heh
11:35:42 <esap> Sizeof can be used to do things the type system wasn't designed to do.
11:36:13 <Philippa> yeah, I've used it for that in conjunction with arrays
11:36:30 <Philippa> though there're other things that it looks like you can do at first and can't on grounds of alignment and packing
11:36:43 <esap> I mean combining overloading, enums and sizeof of a function call.
11:37:18 <esap> and templates, obviously.
11:38:01 <Philippa> *erk*
11:38:22 <Philippa> yeah, templates are not exactly the nicest metaprogramming system ever
11:38:33 <esap> philippa: exactly.
11:41:41 <esap> philippa: Here's the example: http://www.kotiposti.net/epulkkin/instructive/base-class-determination.html
11:42:41 * esap hates to admit writing such evil code :-)
11:42:52 <Philippa> *vomits*
11:43:10 <Philippa> I mean really, why not just have such a thing as evaluated-at-compile-time-const?
11:45:53 <esap> I suppose the problem is that the consequences and interactions of different C++ features were not investigated properly, and they don't fit at all well together.
11:46:38 <Philippa> well, it was fine until somebody turned templates into satan's own prolog
11:46:58 <earthy> 2/me grinsi/me grins
11:46:58 * earthy grins evilly
11:48:35 * esap is much happier with Haskell's feature interaction.
11:49:09 * esap is constantly surprised at how well Haskell's features work together.
11:50:58 <Philippa> I'm not - largely because it's possible to simultaneously comprehend them all
11:51:07 <Philippa> C++ *is* too big
11:51:55 * earthy doesn't quite comprehend all of Haskell's features simultaneously
11:51:59 <esap> philippa: I think it's possible to understand them, though it takes a lot of work.
11:52:02 <kristnjov> haskell is the only way, the REAL way :)
11:52:17 <Philippa> or at least the rational way
11:52:22 <earthy> but that may have a little something to do with the corner cases where I run up to limitations... ;)
11:52:24 <kristnjov> and btw, does anyone know any id3 module for haskell?
11:53:39 <esap> earthy: limitations? where? :-)
11:56:27 <earthy> well, there are a number in the type system
11:56:38 <earthy> it is not as general is theoretically possible. ;)
11:56:46 <earthy> s/is t/as t/
11:57:26 * esap is using something like one-week old version of ghc, and I see no limitations :-)
11:57:52 <earthy> tsk
11:57:53 <earthy> :)
11:58:11 <esap> oh maybe one, I once got ghc to crash.
11:58:22 <esap> I mean, go to an infinite loop.
11:58:49 <earthy> you must not push ghc much then :P
11:59:32 <earthy> it tends to consistently tell me things are not possible, lately
11:59:44 <earthy> ofcourse, it is mostly right
11:59:45 <earthy> but still
12:00:06 <earthy> that means that the maths doesn't do what I want it to do
12:00:40 <earthy> although I know it would be possible to do it if only I had just an extra layer of type-indirection
12:00:46 <earthy> oh well
12:01:37 <esap> well I know one restriction in ghc that I don't know how to solve well, the lack of global variables. Though global variables are bad, they have some uses as well.
12:01:43 <kosmikus> argh -- the html converter cannot deal with optional arguments?!
12:03:14 * esap points to the discussion in haskell-list.
12:04:17 <esap> earthy: what do you mean by type-indirection?
12:06:49 <earthy> kosmikus: nope, it can't
12:07:18 <earthy> esap: oh, I do some calculations at the type level
12:07:47 <earthy> and if only I had more access to the kind level I'd be quite happy ;)
12:09:02 <esap> earthy: types are not intended for computing.
12:09:56 <esap> earthy: types are intended for expressing restrictions.
12:10:06 <esap> earthy: and possibilities.
12:10:39 <earthy> esap: yes. and I want to combine the restrictions and possibilities out of partial restrictions and possibilities
12:11:30 <kosmikus> esap: I don't agree
12:11:37 <esap> kosmikus: why?
12:11:45 <earthy> (I've been spoiled on \C
12:11:49 <earthy> )
12:12:00 <kosmikus> esap: that's a view that stems from Haskells inadequacy in this respect
12:12:24 <kosmikus> esap: types, more generally, are there to express static properties of your programs
12:12:59 <kosmikus> if these properties become complex, you need to have abstraction mechanisms to write them down -- in other words, you must be able to compute them
12:13:23 <kosmikus> and Haskell already has features to do so, namely type classes and functional dependencies
12:13:32 <earthy> but those are quite restrictive
12:13:34 <kosmikus> only problem is, it's one of the ugliest parts of the Haskell language
12:14:03 <kosmikus> yes, and even though they are already so ugly, they are still quite restrictive
12:14:17 <kosmikus> go Epigram!
12:14:27 <kosmikus> :)
12:14:28 <esap> kosmikus: I agree you need to be able to express complex constraints.
12:14:31 <earthy> as soon as you try to do really interesting things, it breaks down
12:14:37 <earthy> yeah! go Epigram! :)
12:14:50 <earthy> (but I'm not reformulating my stuff in Epigram)
12:15:21 <earthy> (even though I'll probably have to completely redo the stuff of the past two weeks over the coming weekend)
12:15:47 <kosmikus> two weeks in one weekend isn't bad
12:16:13 <esap> kosmikus: Though I don't think abstraction mechanisms amount to computation. I think once you start getting equivalence classes of types, then you need computation for types.
12:16:17 <earthy> oh... but it is... I've got the gf coming over and expecting me to do other stuff. :P
12:18:00 <esap> kosmikus: computation is really about reduction and equivalence classes.
12:19:26 <earthy> and you cannot do that at the type level why?
12:19:30 <kosmikus> esap: if I want to express (and statically verify) that "permutations n" is a list with "fac n" elements, I have to be able to compute at the type level
12:19:52 <kyo_gutsu> guys can someone help me with my homework, I have a homework on haskell consisting of 5 questions and I am trying to understand it but it's too difficult for me so a friend gave me the answers to question 1 and I am trying to understand it 
12:20:14 <earthy> 'kay
12:20:20 <kosmikus> you're trying to understand an answer?
12:20:22 <kosmikus> that's ok
12:20:27 <earthy> show us the solution, and we'll try to deduce the question :)
12:20:44 <esap> kosmikus: I think I see what you mean, yes, from that point of view, you have computation for types.
12:21:11 <kyo_gutsu> thanks I will show you both
12:21:23 <esap> kosmikus: OTOH, types express *static* properties of the programs, not *dynamic* properties, and computation is something dynamic :-)
12:21:48 <kyo_gutsu> Series 1:: [10 points] Basics I: Manipulating Lists of Integers
12:21:48 <kyo_gutsu> Write the following functions for handling simple lists in the Haskell programming language. 
12:22:06 <kyo_gutsu> > entryExists :: Int -> [Int] -> Bool
12:22:06 <kyo_gutsu> Given an integer and a list of integers decides whether or not the given integer occurs in the list.
12:22:29 <kyo_gutsu> > addEntry :: Int -> [Int] -> [Int]
12:22:30 <kyo_gutsu> Given an integer and a list of integers adds the integer in the list if it was not already inside the list.
12:22:43 <kyo_gutsu> > dropEntry :: Int -> [Int] -> [Int]
12:22:44 <kyo_gutsu> Given an integer and a list of integers removes the integer from the list if it was ther otherwise leaves the list unchanged
12:22:56 <kyo_gutsu> > joinLists :: [Int] -> [Int] -> [Int]
12:22:56 <kyo_gutsu> Given integer lists, this function combines the two lists removing any duplicate values.
12:22:57 <esap> kosmikus: I'm making strict distinctions between phases.
12:23:08 <kyo_gutsu> > filterEntries :: (Int -> Bool) -> [Int] -> [Int]
12:23:08 <kyo_gutsu> Given a predicate and an integer list, this function should remove from the list all the values that do not satisfy the predicate. For example, if the predicate is "isEven :: Int -> Bool" and the list is "[1..10]", filterEntries should return the result "[2,4,6,8,10]".
12:23:22 <kyo_gutsu> that's is the first question
12:23:53 <kyo_gutsu> and this is the answer from my friend which I don't understand
12:23:57 <earthy> kyo: have you read/heard about lists at all?
12:24:02 <kosmikus> esap: depends; there is no problem to compute some things at compile time, it's even desirable
12:24:58 <kyo_gutsu> module S1 where
12:24:59 <kyo_gutsu> entryExists :: Int -> [Int] -> Bool
12:24:59 <kyo_gutsu> entryExists e [] = False
12:24:59 <kyo_gutsu> entryExists e (a:as) = if e == a then True else entryExists e as
12:25:02 <kosmikus> esap: your view has advantages, but then functional dependencies should be removed from Haskell again
12:25:21 <esap> kosmikus: heh, I'm not against functional dependencies.
12:25:34 <kyo_gutsu> umm yeah but I think am not good at those
12:26:12 <kosmikus> esap: then you're somewhat inconsequent; you're saying, I should not compute -- I allow you to, but I'm making it awkward and difficult so that only brilliant and clever people such as oleg can actually do it
12:26:15 <esap> kosmikus: in fact, I'd hope even data statements had the corresponding feature.
12:26:30 <kyo_gutsu> addEntry :: Int -> [Int] -> [Int]
12:26:30 <kyo_gutsu> addEntry e [] = [e]
12:26:30 <kyo_gutsu> addEntry e (a:as) = if e<a then e:(a:as) else if e==a then a:as else a:addEntry e as
12:26:36 <esap> kosmikus: s/statment/declaration/
12:26:36 <gui> hey there! how can I do something like: instance A String where [error: no type synonyms] or instance A [Char] where [error: expecting variable] ? thanks.
12:26:48 <kyo_gutsu> dropEntry :: Int -> [Int] -> [Int]
12:26:49 <kyo_gutsu> dropEntry e [] = []
12:26:49 <kyo_gutsu> dropEntry e (a:as) = if e == a then as else a:dropEntry e as
12:26:58 <kosmikus> kyo_gutsu: please stop pasting
12:27:12 <kyo_gutsu> joinLists :: [Int] -> [Int] -> [Int]
12:27:12 <kyo_gutsu> joinLists [] [] = []
12:27:12 <kyo_gutsu> joinLists (a:as) [] = a:as
12:27:12 <kyo_gutsu> joinLists (a:as) (b:bs) = if a<b then a:b:joinLists as bs else if a>b then b:a:joinLists as bs else b:joinLists as bs
12:27:35 <kyo_gutsu> filterEntries :: (Int -> Bool) -> [Int] -> [Int]
12:27:35 <kyo_gutsu> filterEntries u [] = []
12:27:35 <kyo_gutsu> filterEntries u (a:as)|u a = a:filterEntries u as |otherwise = filterEntries u as
12:27:42 <kyo_gutsu> ok
12:28:40 <earthy> kyo_gutsu: try reading http://personal.vsnl.com/erwin/recursion.htm
12:28:44 <kyo_gutsu> If anyone can describe the procedure of the answers
12:28:57 <esap> kosmikus: no, I mean, what is the intention behind computing with types? If it's for building bigger types, then that's ok. If it's for expressing complex constraints, then that's ok. But if it's just for joining the type level with the term level, then I don't agree with that.
12:29:03 <kosmikus> gui: do you really want to do something special for strings, or do you want to do something for all lists, and use strings as an example
12:29:04 <kyo_gutsu> ok I will read that earthy, thanks
12:29:38 <kosmikus> esap: the point is that joining the term and type levels is the only sane way of adding computation to the types
12:29:40 <earthy> kyo_gutsu: then, think about how lists are defined recursively (or, rather, inductively, but don't bother yourself with terminology)
12:29:54 <kosmikus> esap: the motivation is that you want to build bigger types or express more complex constraints
12:30:08 <earthy> kyo_gutsu: that is, a list is *either* empty, or it consists of a head element, and a tail list
12:30:14 <esap> kosmikus: The problem is, term and type levels cannot be joined without breaking the system.
12:30:23 <kosmikus> esap: at the same time, you already have a nicely working term-level language to express computations, so you don't want to add a new level with different syntax
12:30:24 <earthy> esap: but they can. :P
12:30:45 <kosmikus> esap: depends how you define "breaking", but yes, they can
12:31:31 * esap defines breaking as "will cause the run-time system to be able to perform invalid/undefined operations, or the compiler to get in an infinite loop".
12:32:44 <kyo_gutsu> earthy that link has 5 chapters, which chapter shall I study in order to solve this homework in haskell, I am short on there are only 26 hours left till the deadline
12:32:48 <esap> I mean, I require that compilers are decidable.
12:33:02 <esap> and terminate in finite time.
12:33:08 <earthy> chapter 1. :)
12:34:29 * kosmikus wonders if it's easier to understand this converter or to rewrite it
12:35:20 <kyo_gutsu> thank you earthy, I'll study chapter 1 know I hope that this chapter is easy to follow
12:35:33 <kyo_gutsu> *now
12:37:07 <kosmikus> esap: I don't. But even if you do, you can still achieve that by disallowing general recursion in type-level computations.
12:37:59 <kosmikus> esap: you can do that by tagging partial or possibly nonterminating computations in much the same way as Haskell tags IO operations
12:38:12 <kosmikus> esap: then you can require all computations on the type-level to be total
12:38:23 <esap> kosmikus: yes, that's basically what I'm doing.
12:39:37 <earthy> kosmikus: I'd go for rewriting the converter, in your case
12:40:09 <kosmikus> in my case?
12:40:09 <esap> kosmikus: ok, I suppose you're right that you can allow _some_ computation with types, just not all of it.
12:40:41 <earthy> I didn't want to invest the time, you might ;)
12:42:14 <kosmikus> earthy: I'll try to adapt it without understanding it so that it can produce some result, and put it on my todo list for the next edition to rewrite the converter, or to investigate using an existing converter
12:42:44 <kosmikus> I don't want to delay the report for a week just because I want to rewrite the converter
12:44:07 <kosmikus> esap: I think we could agree on that, although I'd say that you can allow all computation on the type level, and make it the programmers responsibility that the compiler doesn't loop; after all, it's the programmers responsibility already to make sure the program doesn't loop
12:46:05 <esap> kosmikus: of course, the programmer needs to be able to put the responsibility on the compiler [and then he gets additional restrictions].
12:47:19 <esap> kosmikus: I usually think that the programmer should be able to do anything, except he must not be inconsistent with his own wishes.
12:47:43 <esap> kosmikus: And types are there to ensure that.
12:49:00 <kosmikus> esap: yes
12:49:04 <esap> kosmikus: But types are not useful if the compiler can't find where the problem is.
12:49:14 * Igloo jumps up and down on nhc and gcc
12:49:27 <kosmikus> ah, trying that again?
12:49:54 <kosmikus> I've given up on that a while ago, but I'm interested in any successes you might have
12:50:16 <Igloo> The last thing got fixed didn't it?
12:50:32 <kosmikus> ah, right, I remember you sent something
12:50:44 <Igloo> But m68k just failed to build the same thing as last time
12:50:44 <kosmikus> but that never made it into an *official* patch, or did it?
12:50:59 <Igloo> I have no idea. I wish Malcolm would make a release
12:51:08 <kosmikus> yes, that's what I think
12:51:18 <Igloo> Yes, it did, because he didn't like my nicely formatted perl so squashed it onto one line
12:51:36 <kosmikus> really?
12:51:48 * kosmikus checks the homepage
12:51:50 <Igloo> Yeah - to make it easier to disable with a hacky config script
12:52:02 <Igloo> Oh, it went into CVS - not sure if he actually made it available as a patch
12:52:35 <Igloo> I guess I could try packaging CVS instead, but the Debian release folks might get a bit upset if I did that
12:52:35 <kosmikus> right, that's it
12:52:53 <kosmikus> the version that's available from the homepage is currently not usable without further patching
12:53:35 <Igloo> And not even with the patches on the download page applied, from the look of it
12:53:40 <Igloo> *sigh*
12:53:52 <Igloo> Well, if you put together a petition for a release I'll sign it  :-)
12:54:04 <kosmikus> but Malcolm says in his HCAR entry "[...], but a bug-fix refresh version 1.18 is imminent."
12:54:08 <kosmikus> Let's hope it's true.
12:54:26 <Igloo> Ah, cool
12:55:00 * Igloo heads homewards
12:55:27 <kosmikus> I should finally write that review ...
13:10:49 <Maddas> Hmhm
13:16:51 <Maddas> I got lambdabot2.tar.gz from Sourceforge, when I execute 'make' I get errors. Might anybody here be able (and willing) to help?
13:17:41 <Lemmih> @seen shapr
13:17:42 <lambdabot> I saw shapr leaving #haskell 2 hours 17 minutes 26 seconds ago.
13:18:21 <Maddas> :-)
13:19:11 <thebug> which GHC are you using?
13:19:28 <Maddas> 6.2
13:20:08 <Maddas> Should I upgrade?
13:20:15 <thebug> hmm, there was something specific you needed to compile lambdabot, but I don't remember what it is ...
13:21:29 <Maddas> Well, the first error I get is even earlier: "Makefile:70: depend: No such file or directory". After "Linking ...", I get "ld: can't locate file for: -lHShaskell98" and then make fails :-)
13:52:33 <dons> moin
13:52:42 <Lemmih> Good morning dons.
13:55:17 <Maddas> Ok, I upgraded ghc and it works now. I think my old installation was broken anyway :-) 
14:00:25 <Lemmih> Maddas: Yay.
14:00:46 <Maddas> Indeed :-)
14:14:31 <kyo_gutsu> guys can someone explain this function and give me it's code in haskell
14:14:33 <kyo_gutsu> > findPath :: Vertex -> Vertex -> [Edge] -> [Vertex]
14:14:33 <kyo_gutsu> Given two vertices, finds the list of vertices that form a path from the first to the second.  If no path exists between them an empty list is returned.
14:16:10 <Lemmih> Maybe you should do your homework yourself.
14:16:17 <dons> give you its code... hmm :(
14:17:55 <kyo_gutsu> well I hope that I can understand it, then I would solve the home work instead of writing the question here
14:19:15 <kyo_gutsu> or if someone has a good tutorial on function other than http://www.haskell.org/tutorial/functions.html cause I didn't find many of the functions I want
14:20:09 <Lemmih> Sometimes you have to code the functions yourself.
14:20:21 <dons> have you looked in the hierarchical libraries. specifically the Data.Graph library?
14:21:21 <arjanb> you can't understand haskell without trying to write code yourself
14:21:23 <kyo_gutsu> well lemmih I'm not that experinced in haskell if you ask me in something i Understand then I'll do it gladly 
14:21:42 <kyo_gutsu> but I don't know how to do it
14:21:53 <kyo_gutsu> I tried
14:22:10 <kyo_gutsu> and it's always giving me this error
14:22:32 <kyo_gutsu> Type :? for help
14:22:32 <kyo_gutsu> S1>
14:22:32 <kyo_gutsu> S1> :r
14:22:32 <kyo_gutsu> S1>
14:22:32 <kyo_gutsu> S1> main
14:22:33 <kyo_gutsu> ERROR - Undefined variable "main"
14:22:35 <kyo_gutsu> S1>
14:22:37 <kyo_gutsu>                        
14:23:42 <kyo_gutsu> now it's been more than 14 hous in the front of the monitor and I really cannot take it anymore
14:24:02 <dons> go and get some sleep them ;)
14:24:08 <kyo_gutsu> or atleast can someone explain what I am doing wrong
14:24:12 <Lemmih> kyo_gutsu: Did you define 'main' in the file you're trying to load?
14:24:35 <kyo_gutsu> I can't there is 5 marks which I need
14:24:53 <kyo_gutsu> no
14:25:49 <kyo_gutsu> actually in the code I have, there is no main method in it
14:26:47 <Lemmih> What is it you don't understand then?
14:27:16 <kyo_gutsu> in german site I found a code which I understood it
14:27:17 <kyo_gutsu> module Main where
14:27:17 <kyo_gutsu> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
14:27:17 <kyo_gutsu> main = print $ take 20 fibs
14:27:59 <kyo_gutsu> but when I try to use the same approach in my homework it gives me that damn error :(
14:31:36 <Lemmih> Yay. I fixed greencard.
14:32:40 <dons> cool
14:35:49 <TheHunter> kyo_gutsu: you didn't define a function main in the file you were loading.
14:43:59 <Lor> Native English-speakers: how appropriate is it to use the s-genitive for inanimate abstract concepts such as "expression" or "metavariable"?
14:45:31 * dons looks up what an s-genitive in his native language is
14:45:36 <dons> hehe
14:45:42 <kyo_gutsu> thehunter: I am not sure  If I defined a main method I am still a newibe in haskell
14:46:10 <TheHunter> kyo_gutsu: if you have a line main = ... somewhere in your code you've defined it.
14:46:53 <marcot> Good evening all.
14:46:59 <TheHunter> each function you define there can be called from hugs by simply typing the name and the arguments, eg sum [1,2,3]
14:47:01 <Lemmih> Hello marcot
14:47:11 <dons> Lor: expression's something?
14:47:12 <marcot> Lemmih: hello... how are you?
14:47:19 <dons> hey marcot
14:47:22 <Lor> dons, yeah.
14:47:26 <dons> that's fine
14:47:27 <marcot> dons: hey! =D
14:47:40 <Lemmih> I'm fine, thanks.
14:48:02 <dons> "The expression's form was regular"
14:48:09 <Lor> I have understood that using "of" would usually be slightly more preferable in these cases.
14:48:20 <tuomov> I would prefer that too
14:48:33 <dons> ah. "The form of the expression was regular". Perhaps that is nicer
14:48:49 <dons> slightly more formal
14:48:58 <Lor> I often find the latter alternative to feel much, well, heavier.
14:49:18 <Lor> Also, the different word order possibly puts the emphasis on different things.
14:49:45 <dons> hmm. emphasis on the 'form', rather than the 'expression'
14:50:23 <Lor> Yeah, in the latter form it kind of feels like "the _form_ of the expression was regular (but some other part of it maybe wasn't)"
14:51:38 <dons> oh, possibly. you'd have to look at the surrounding context to be sure. but I agree with that
14:52:04 <dons> because the emphasis is on the part, rather than the whole
14:53:01 <dons> I would have no problem using "expression's form" in a paper
14:53:13 <Lor> That's good enough for me.
14:54:18 <Lor> I.e. I'm not going to do a global search and replace for s-genitives in my thesis. :)
14:54:46 <dons> hehehe
14:56:10 <Lor> No, really, my advisor just hinted that he wasn't fully comfortable with my uses of the s-genitive.
14:57:32 <Lor> Then again, he doesn't claim to know English nuances any better than I do, so it's ok if I just say "no, I think it's fine this way".
14:57:59 <dons> just looking through my hs-plugins paper, I've got: "application's address space", "compiler's runtime system", "library's C language binding"
14:58:03 <dons> all in the introductionn
14:58:22 <dons> "plugin's interface"
14:58:40 <dons> "language's eval operator"
14:59:17 <Lor> Right. Fair enough.
14:59:46 <Lor> I'm never ever going to write anything substantial in plain latex again, though...
15:00:29 <dons> what's been the problem?
15:00:42 <Igloo> latex (well, really tex) causes me much pain too
15:00:44 <Lor> latex is the problem. :)
15:00:49 <Lor> No, tex is ok.
15:00:55 <dons> we need hstex!!
15:01:02 <Lor> tex does what it's meant to do and does it well.
15:01:11 <Igloo> I find latex a nice abstraction. The problem is the underlying language is horrible
15:01:13 <Lor> latex tries to do a gazillion things that the tex language is completely unsuited for.
15:01:22 <Lor> latex? _abstraction_?
15:01:54 <dons> and there are people who write code in tex. (see the haskell lexer in tex by patrykz)
15:03:11 * Igloo is hoping nonpareil (from the guy who brought you lout) will be nicer than both, although there will still be the conference style issue to overcome
15:03:44 <Lor> tex is ok. There just needs to be something neat that generates tex.
15:03:47 <Igloo> I think the basic idea is a domain specific functional language
15:04:20 <kosmikus> ah, a discussion for me ;)
15:04:26 <dons> yep. hmm.. something someone should write for us in .hs
15:04:32 <Igloo> TeX is horrid once you try to do anything "complicated", like verbatim text in a subfigure
15:05:23 <kosmikus> actually, many things can be done quite nicely and cleanly in TeX, but LaTeX essentially prevents you to do so
15:05:40 <kosmikus> ConTeXt solves some of these issues, but not all of them, because it's basically a one-man show
15:05:41 * Igloo can't think of other concrete examples of things that have given me headaches
15:06:25 <tic> Is there a good way of generating figures directly from LaTeX? I'd rather not include EPS files generated from xfig.
15:06:33 <tic> s/from/with
15:07:01 <Lor> Is there some vector format for figures that can be imported both when generating ps or pdf?
15:07:04 <Igloo> The design of TeX also suffers from the assembly-language-style-thinking that was around at the time it was started, where you have to worry more about memory and suchlike
15:07:07 <kosmikus> otoh, many of the other systems I have seen aren't any better, and I doubt there will be a suitable replacement for TeX anytime soon
15:07:20 <kosmikus> tic: use metapost
15:07:22 <dons> Igloo: certainly
15:07:32 <tic> kosmikus, package?
15:07:49 <kosmikus> Lor: metapost produces postscript output that can be included in pdf directly because it's suitable well-behaved
15:07:56 <kosmikus> tic: it's a separate program
15:08:03 <tic> kosmikus, m'kay.
15:09:20 <kosmikus> for once, to design a better TeX, you don't just have to understand the problems of the TeX language, but you have to understand typography as well; furthermore, it helps if you have a good knowledge of XML, pdf, font formats and the like
15:09:46 <Maddas> I'm doing my first things with Monads and I'm not sure about how to do something
15:10:01 <kosmikus> then, there is the problem that TeX can produce nearly any *result* you want nearly perfectly, so you can spend lots of time on a more cleanly designed system which still doesn't produce results that can compete with TeX
15:10:08 <Maddas> How do I 'partially lift' a function into the IO Monad? e.g. only 'lift' the return type into IO
15:10:15 <kosmikus> return
15:10:22 <Maddas> oh.. duh :-)
15:10:30 <Maddas> (Thanks!)
15:18:45 <joao> Hello
15:18:51 <joao> (World)
15:19:38 <Etaoin> hi
15:19:51 <joao> Does anyone have experience with wxHaskell?
15:22:21 <Lemmih> Yes.
15:24:25 <kosmikus> Igloo: nonpareil looks at least interesting
15:25:19 <joao> Lemmih, have you ever mixed state monad with IO ?
15:26:27 <Lemmih> joao: Not while using wxHaskell.
15:27:05 <Maddas> Hm, I don't understand the type of what (liftM map) returns.
15:28:50 <Maddas> ..oh, never mind :-)
15:29:25 <TheHunter> @type liftM map
15:29:27 <lambdabot> bzzt
15:29:44 <joao> where is function liftM ?
15:29:50 <Maddas> Monad
15:29:54 <dons> @type (Control.Monad.liftM map)
15:29:55 <lambdabot> (Control.Monad.liftM map) :: forall a b m.
15:29:55 <lambdabot> 			     (Monad m) =>
15:29:55 <lambdabot> 			     m (a -> b) -> m ([a] -> [b])
15:30:02 <Maddas> I just noticed that I should have been using liftM2 :-)
15:30:23 <Maddas> (Which clears up the confusion)
15:30:35 <dons> @type (Control.Monad.mapM)
15:30:36 <lambdabot> (Control.Monad.mapM) :: forall b m a.
15:30:36 <lambdabot> 			(Monad m) =>
15:30:36 <lambdabot> 			(a -> m b) -> [a] -> m [b]
15:31:01 <joao> Lemmih, I've mixed IO and State and have done some IO (putStr, getLine, etc) and updated state in the same do expression; but I don't know how to do it using wxHaskell
15:31:15 <Maddas> That isn't the same, though, dons
15:31:19 <Maddas> (Or is it?)
15:31:37 <Maddas> @type (Control.Monad.liftM2 map)
15:31:38 <lambdabot> (Control.Monad.liftM2 map) :: forall a b m.
15:31:38 <lambdabot> 			      (Monad m) =>
15:31:38 <lambdabot> 			      m (a -> b) -> m [a] -> m [b]
15:32:02 <Lemmih> joao: How is it different?
15:36:39 <joao> Lemmih, well, all functions are IO, but we need to use start function (IO a -> IO x)
15:36:51 <Maddas> What would an example of a thing with the type m (a -> b) be? (Sorry for being slow)
15:37:03 <joao> The existence of that function kills the way I'm doing things
15:37:45 <Maddas> ah, got it.
15:44:55 <kosmikus> joao: why? you have to have a main program of type IO (), all you need to do is to wrap that main program using wxhaskell's run function
15:49:51 <joao> kosmikus, ok. how do you mix IO and State in the same do expression?
15:52:37 <kosmikus> you can't, one do is always for one monad
15:52:53 <kosmikus> but I thought you said you had already done it
15:54:51 <kyo_gutsu> guys is this code is right 
15:54:55 <kyo_gutsu> module S1 where
15:54:56 <kyo_gutsu> entryExists :: (Int,Int) -> [(Int,Int)] -> Bool
15:54:56 <kyo_gutsu> entryExists e [] = False
15:54:56 <kyo_gutsu> entryExists e (a:as) = if e == a then True else entryExists e as
15:54:56 <kyo_gutsu> addEntry :: (Int,Int) -> [(Int,Int)] -> [(Int,Int)]
15:54:56 <kyo_gutsu> addEntry e [] = [e]
15:54:58 <kyo_gutsu> addEntry e (a:as) = if e<a then e:(a:as) else if e==a then a:as else a:addEntry e as
15:55:00 <kyo_gutsu> dropEntry :: (Int,Int) -> [(Int,Int)] -> [(Int,Int)]
15:55:02 <kyo_gutsu> dropEntry e [] = []
15:55:04 <kyo_gutsu> dropEntry e (a:as) = if e == a then as else a:dropEntry e as
15:55:06 <kyo_gutsu> joinLists :: [(Int,Int)] -> [(Int,Int)] -> [(Int,Int)]
15:55:08 <kyo_gutsu> joinLists [] [] = []
15:55:10 <kyo_gutsu> joinLists (a:as) [] = a:as
15:55:10 <kosmikus> didn't I tell you not to paste?!
15:55:12 <kyo_gutsu> joinLists (a:as) (b:bs) = if a<b then a:b:joinLists as bs else if a>b then b:a:joinLists as bs else b:joinLists as bs
15:55:14 <Lemmih> kyo_gutsu: Please stop spamming the channel.
15:55:15 <kyo_gutsu> filterEntries :: ((Int,Int) -> Bool) -> [(Int,Int)] -> [(Int,Int)]
15:55:17 <kyo_gutsu> filterEntries u [] = []
15:55:19 <kyo_gutsu> filterEntries u (a:as)|u a = a:filterEntries u as |otherwise = filterEntries u as
15:55:36 <kyo_gutsu> sorry
15:55:36 <joao> kosmikus, of course you can :)
15:55:42 <kosmikus> don't do that again
15:55:47 <kyo_gutsu> ok
15:55:53 <kosmikus> joao: well, yes, by lifting one monad into the other
15:55:59 <joao> kosmikus, and that's the problem; combining them will give problems with start function
15:56:01 <joao> kosmikus, exactly
15:56:25 <kosmikus> joao: the point is, somewhere on the outside you have to run your state monad anyway
15:56:36 <kosmikus> otherwise you wouldn't have been able to have a "main" function before
15:56:53 <kosmikus> and my point is, if you can have "main", you can also "run" it
15:57:23 <kosmikus> so all you have to do is to rename your old main to main' and define main = run main'
15:58:32 <joao> Hmmm.
15:58:36 <joao> Can I paste an example?
15:58:41 <joao> In private, maybe?
15:59:07 <kosmikus> kyo_gutsu: no, your code is not correct, at least if I remember the exercises correctly
15:59:39 <kosmikus> there are paste pages for pasting, this channel even has one on the Haskell Wiki
16:00:56 <joao> Ok.
16:01:17 <kyo_gutsu> well the question was to write a variant of
16:01:19 <kosmikus> joao: I guess if it's <=4 lines it's ok here as well
16:01:28 <kosmikus> kyo_gutsu: I checked the questions
16:01:38 <kyo_gutsu> each of the above mentioned
16:02:12 <kosmikus> at least addEntry and joinLists are incorrect
16:02:19 <kyo_gutsu> fuuction to work on a list of pairs of integers
16:02:26 <kyo_gutsu> humm
16:02:42 <kosmikus> oh yes, why pairs of integers suddenly?
16:03:05 <kosmikus> in the exercises you gave a few hours ago, it was [Int]
16:05:37 <kyo_gutsu> yes that was only a part of the homework wcich I wanted to understand
16:06:09 <kyo_gutsu> to be able to solve te 90% remaining of the homework
16:07:20 <kyo_gutsu> in part 3 the question becomes on vertex instead of integers
16:07:35 <kyo_gutsu> and other things that I do not understand
16:10:11 <kosmikus> well, for the original questions, with [Int], the two functions are already not correct
16:10:27 <kosmikus> have to leave .. good night
16:11:44 <kyo_gutsu> kosmikus before you leave you said there is paste pages
16:12:16 <kyo_gutsu> where I can find them I feel like I wanna die because of this homework
16:20:32 <kyo_gutsu> it looks like that no one want to help me in solving the homework
16:23:37 <kyo_gutsu> bye guys
16:36:52 <Lemmih> Welcome back shapr
16:37:19 <shapr> greetings Lemmih
16:37:24 <shapr> I'm taking a break from work.
16:44:50 <dons> yay. got the lazy lexer fully working :D
16:45:08 <dons> now we have a keymap dsl
16:45:20 * dons is happy
16:46:13 <shapr> yay!
16:46:26 <dons> keymaps for all!
16:51:45 <shapr> hej bojohan
16:51:57 * shapr reads logs
16:52:22 <bojohan> hejsan, hejsan
16:52:31 <shapr> sounds like this kyo_gutsu person left their homework till the last moment and tried to learn Haskell the night before the due date.
16:52:56 <shapr> dons: is that in the repo?
16:53:04 <bojohan> which person?
16:53:41 <shapr> the kyo_gutsu person who was on #haskell before I joined.
16:53:43 <dons> shapr: very soon
16:53:46 <shapr> yay
16:54:04 <dons> btw, simon winwood implemented undo/redo for emacs mode. that's in the repo now
16:54:09 <shapr> hey, I put a YiWiki on ScannedInAvian.org. Or would you rather host it at unsw?
16:54:20 <dons> no. that's cool. i'll link to it.
16:54:36 <dons> the undo/redo stuff is cool.
16:54:47 <dons> what's the wiki url?
16:54:51 <shapr> I'm going to specifically put a bsd license on the YiWiki content ahead of time.
16:55:02 <dons> good idea.
16:55:03 <shapr> http://www.scannedinavian.org/YiWiki
16:55:21 <shapr> no logo yet
16:55:33 <shapr> I still haven't found a font that contains the Yi char
16:55:45 <dons> ah. we need that, don't we :)
16:55:59 <Igloo> Have you tried ttf-freefont?
16:56:15 * shapr checks
16:56:42 <stepcut> shapr: fixed has it
16:56:49 <Igloo> Oh, I think I'm talking rubbish
16:57:05 <dons> fixed font has a yi char??
16:57:06 <Igloo> Ah, yes, it was one of my uxterm fonts that had it
16:57:15 <stepcut> dons: i think so, what is the unicode number ?
16:57:25 <Igloo> 1D321
16:57:28 <dons> umm.. that's  it
16:57:43 <stepcut> hrm, I am thinking of the old name then
16:57:58 <stepcut> The 7fA9 or something...
16:58:19 <stepcut> 1D321 - that is utf-16 or something ?
16:58:41 <Igloo> It's unicode
16:58:53 <Igloo> You can use whatever encoding you want
16:59:50 <dons> oh, this new keymap language is fun. vim's :map is just beautiful now
16:59:54 <stepcut> kcharselect won't let me enter more than 4 hex digits
17:00:26 <dons> it's a nice dsl over essentially the transition tables stepcut was creating
17:00:31 <Igloo> Search for 1D321 in gucharmap
17:01:26 <shapr> it claims to be the tetragram for change
17:01:40 <dons> that was the old name, wasn't it?
17:01:57 <stepcut> dons: I hope to look at the stuff this weekend
17:02:01 <dons> stepcut: also, with the new lexer, you can pass around arbitrary state as a param
17:02:05 <Igloo> Oh, I've obviously missed something
17:02:36 <stepcut> dons: yeah, that sounds like it might do the trick
17:02:38 <Igloo> What's the new one then?
17:02:55 <stepcut> dons: especially if the arbitrary state was an hlist or something extensible like that...
17:03:12 <shapr> the new name is Yi
17:03:20 <shapr> 7fA9
17:03:21 <Igloo> There are at least 4 characters called that
17:03:23 <dons> stepcut: hlists. hmm. that's what sjw (simon winwood) was talking about too.
17:03:52 <dons> Igloo: lazy lexer combinators, with meta actions, from the ctk lexer library
17:04:04 <dons> tweaked to work in interactive situations
17:04:11 <dons> plus, you get regexes for free
17:04:12 <Igloo> dons: Sorry, I meant character, not keymap
17:04:20 <dons> oh. oops
17:05:08 <shapr> Man, I can't find any of my installed fonts that has this defined. Not with gucharmap at least.
17:05:18 <shapr> I need a unicode tutorial.
17:05:28 <stepcut> so, is the character 7fa9 or 1d321 ?
17:05:48 <Igloo> I see a glyph in Sans, which is apparently from Kochi Gothic
17:06:43 <Igloo> CJK Ideograph. "right conduct, righteousness" pronounced LANG2 YI4, GI, YOI YOSHITOSURU YOKU or UY depending on what language you are speaking
17:06:57 <dons> ah. sounds good
17:08:29 <stepcut> I can't figure out how to get emacs to insert 7fa9...
17:08:36 <stepcut> ucs-insert won't do it
17:08:57 <Igloo> Try capitals?
17:09:48 <stepcut> Igloo: no, it says, character can not be decoded to UCS
17:22:39 <blackdog> morning #haskell
17:23:00 <blackdog> or afternoon... damn, slept in again
17:23:21 <dons> heya blackdog
17:24:37 <shapr> g'day blackdog 
17:28:26 <blackdog> 'lo. how's yi going?
17:28:45 <blackdog> shapr: haskelldeb is sucha  bear to get going... :(
17:29:00 <blackdog> haskelldb, sorry
17:30:08 <dons> blackdog: using ctk lazy lexer as keymap dsl. dynamically updateable lexers are fun
17:32:11 <dons> finally making progresss on that front, after a couple of days of stalling
17:32:21 <blackdog> ctk?
17:32:32 <dons> chak's compiler tool kit
17:32:47 <blackdog> oh, right. yeah, i've looked through that...
17:33:05 <blackdog> so what's still to be done?
17:33:13 <dons> to yi?
17:33:17 <blackdog> apart from native MacOS bindings. :)
17:33:20 <blackdog> yeah\
17:33:36 <dons> oh.. more primitive ops. syntax hl.
17:33:42 <dons> more code.
17:34:22 <blackdog> ah, that's right. still doing the structured rep for the buffer?
17:35:26 <dons> i'm not sure what you mean by structured?
17:35:59 <shapr> blackdog: it's easier to get it moving on debian, especially since I can help you get it moving there.
17:36:01 <blackdog> weren't you going to parse it as you go?
17:36:12 <dons> oh, for syn hl?/
17:36:33 <blackdog> shapr: oh, ok. I can run it on debian... from syntaxpolice's experimental archive?
17:36:42 <blackdog> dons: ja
17:37:02 <dons> yep. have to parse as we go. igloo had a nice proposal for this, i recall
17:37:21 <blackdog> dons: and syntax-aware folding, refactoring, blah blah blah. :)
17:37:59 <dons> lots of syntax-level stuff.
17:38:05 <dons> all after v0.1
17:38:14 <dons> though we may get some syn hl going before then
17:40:08 <shapr> blackdog: apt-get -uf install postgresql-dev is the best the debian packages give you
17:40:33 <shapr> after that, grab HSQL, run ./configure --enable-postgres && make 
17:40:42 <shapr> assuming that works, then do the same thing with haskelldb
17:40:46 <shapr> and tell me if you have any problems
17:41:04 <blackdog> ok, i'll try that. I was tryinMySQL before, but i'm not dogmatic.
17:41:09 <blackdog> shall do.
18:39:36 <shapr> blackdog: had any problems so far?
18:39:57 <blackdog> nope. just grabbing haskelldb...
18:40:07 <blackdog> hsql compiled fine this time, thanks.
18:41:07 <shapr> cool
18:42:28 <Igloo> Um diddle eye
18:42:35 <blackdog> cvs the best idea, right?
18:42:56 <Igloo> Nah, darcs is bett...oh, right, I see  :-)
18:43:44 <blackdog> oh, igloo, you're just a tool of the powerful and shadowy quantum physicist/haskell hacker axis.
18:44:27 <Igloo> That's what they /want/ you to think
18:45:01 <blackdog> <voice = "Les Claypool">Who is theeeeyyyy?</>
18:45:53 <blackdog> shapr: seen this?
18:46:01 <blackdog> /usr/bin/ghc -M -optdep-f -optdep.depend.hsql -package hsql -fglasgow-exts -fallow-overlapping-instances   -i./build/ghc -package-name haskelldb build/ghc/Database/HaskellDB/HSQL/Common.hs build/ghc/Database/HaskellDB/HSQL/PostgreSQL.hs
18:46:05 <blackdog> build/ghc/Database/HaskellDB/HSQL/Common.hs: can't locate import `Database.HaskellDB.FieldType'
18:56:41 <shapr> nah, haven't seen that one
18:56:48 <shapr> is that CVS or the latest release?
19:00:02 <blackdog> CVS - the page said there was a problem with the current release. I'll try it anyway, i guess.
19:01:47 <shapr> did you grep for FieldType?
19:14:58 <shapr> aha, make -j3 fails with HSQL
19:40:42 <shapr> blackdog: I get the same erro
19:40:43 <shapr> r
19:42:15 <shapr> oh, I think I see the problem
19:45:17 <shapr> the problem is either that not all files get copied into the build dir, or that the original source dir isn't on the include path
19:48:46 <blackdog> that's what i figured - i just don't know which is the right way to fix it.
19:49:38 <shapr> putting -i./src into GHCFLAGS in config.mk helps
19:50:58 <blackdog> ok. cheers.
19:52:05 <shapr> it doesn't fix all of it though
19:54:06 <shapr> what's up with the next error?
19:54:36 <shapr> oh, I see
19:54:47 <blackdog> i took the easy way out and went back to 0.9...
19:56:19 <shapr> the makefile deps are wrong
19:56:26 <shapr> it's trying to build the last .o before all the others
19:56:35 <shapr> that's why it can't find FieldType.o
19:56:46 <shapr> manually calling all the build command works :-/
19:59:13 <shapr> yay, it built
20:00:39 <blackdog> cool.
20:00:47 <shapr> now to try it out
20:01:05 <blackdog> the tests won't run with 0.9...
20:01:49 <shapr> did you create the database structure first?
20:02:35 <blackdog> no, it said you can do it automatically. it just can't find genericConnect... weird, because the haskelldb library loks ok in package.conf
20:03:20 <Lemmih> Are the tests importing Database.HaskellDB.GenericConnect?
20:03:48 <shapr> are you using ./run-all-tests PostgreSQL $server $database $userid $password 
20:03:49 <blackdog> Thanks Lemmih, that was it. 
20:05:11 <blackdog> so now i just need postgres itself, and robert's my mother's brother.
20:05:35 * Lemmih thinks GreenCard is really amazing.
20:05:48 <shapr> what's cool about GreenCard?
20:06:16 <Lemmih> It's so easy to use compared with other tools I've tried.
20:06:43 <Lemmih> It takes case of all the marshalling by itself.
20:07:42 <shapr> oh, it's not creating the tables...
20:09:01 <Lemmih> And checking for NULL can be done by changing the return value from 'a' to 'Maybe a' (-:
20:09:28 <Lemmih> But I miss some of Hsc's features.
20:15:11 <Lemmih> shapr: Aren't you up a little late?
20:16:07 <shapr> Aren't *you* up a little late? :-)
20:16:37 <shapr> *fssht* This is Pot, calling Kettle. Come in Kettle! *fssht*
20:17:41 <shapr> ok, I give up, I will go to sleep.
20:19:27 <Lemmih> blackdog: You might also wanna check out the tutorial at:
20:19:31 <Lemmih> @wiki HaskellDbTutorial
20:19:31 <lambdabot> http://www.haskell.org/hawiki/HaskellDbTutorial
20:20:03 <shapr> I learned a lot about HaskellDB while writing that tutorial.
20:20:56 <shapr> and of course, Lemmih wrote the New Tutorial.
20:21:14 <shapr> Probably more Haskell libs could use a nice tutorial like that.
20:22:35 <shapr> foo, I almost got BLob to build too :-/
20:22:44 * shapr gives up, goes to sleep
20:22:59 <Lemmih> I just I had a nickle for every time I tried to save a wiki page with C-xC-s...
20:23:15 <shapr> heh, me too
20:23:46 <Lemmih> *If
20:24:28 * heatsink has closed windows with C-w several times
20:27:47 <blackdog> I thought you emacs guys did all your wiki editing from inside emacs anyway...
20:33:16 <Lemmih> I should stop playing with greencard and start working /-:
21:59:52 <Lemmih> genericConnect from HaskellDB caches connections right?
