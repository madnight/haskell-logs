01:36:16 <wolfman8k> morning
01:43:00 <Oejet_> Hello, wolfman8k.  Nice to see you again.  Excited about the vacation?
01:43:21 <wolfman8k> yeah
01:43:31 <wolfman8k> this is what rendered during the night:
01:43:33 <wolfman8k> http://img16.exs.cx/img16/5872/haskell-raytrace-07.png
01:44:38 <Oejet_> Nice.
01:44:56 <wolfman8k> i think i should have added more spheres though
01:44:58 <Oejet_> Did you profile that?
01:45:01 <shrimpx> how long did it take
01:45:10 <wolfman8k> i don't know
01:45:13 <wolfman8k> Oejet_: no
01:46:02 <Oejet_> wolfman8k: You seem to be rather comfortable in Haskell allready.
01:46:47 <wolfman8k> just the basics i think
01:48:03 <Oejet_> Did you extend your program to build that picture?
01:48:29 <wolfman8k> it's actually the same program as the one that created this:
01:48:40 <wolfman8k> http://img79.exs.cx/img79/7291/haskell-raytrace-02.png
01:48:44 <Oejet_> Got to go.
01:56:42 <juhp> Emacs bindings!  yay!
02:00:05 <juhp> argh
02:01:16 * juhp says something unkind about Ctrl-w in gaim...
02:03:13 <juhp> hmm, C-f gives "Stack space overflow: current size 1048576 bytes.
02:03:13 <juhp> Use `+RTS -Ksize' to increase it." ;)
02:03:46 <shrimpx> in gaim?
02:04:08 <juhp> no, yi with Emacs binding...
02:04:33 <xkb> yimacs
02:04:39 <xkb> ;)
02:04:52 <juhp> yeehah
02:05:31 <juhp> nm
02:05:48 <juhp> only really needs keymap = Emacs.keymap
02:06:28 <juhp> thought that was only for a personal Emacs.hs
02:06:35 <juhp> s/only/oh/
02:09:44 <juhp> nope
02:10:55 <juhp> ah well will try again later
02:11:51 <dons> what's up?
02:12:18 <juhp> dons: Emacs keybindings is give me stack overflow?
02:12:21 <juhp> giving
02:12:34 <dons> haven't tried it myself. I'll investigate...
02:12:44 <juhp> thanks :)
02:12:56 * juhp tries Nano
02:13:19 <juhp> seems to work
02:13:55 <dons> cool :)
02:19:11 <juhp> yi doesn't seem to like inserting chars on the right edge of windows
02:19:28 <juhp> Fail: user error (Curses[-1]:wmove)
02:19:45 <juhp> sorry, wish I had time to contribute some code soon
02:19:48 <dons> hmm. that doesn't sounds right.
02:19:51 <dons> in which mode?
02:19:59 <juhp> vi and nano
02:20:02 <dons> ah. the right edge. ok...
02:20:40 <dons> hmm. off by one, I bet
02:20:47 <juhp> ah
02:23:06 <juhp> dons: btw any thoughts on having support for a toolkit at some point?  like gtk2hs, wxHaskell, etc
02:23:46 <dons> yep. wxHaskell certainly
02:24:37 <juhp> ok.  that will need some abstractions I guess
02:25:11 <dons> at the top level the editor just calls UI.drawWindow, and a couple of others.
02:25:26 <dons> so if the lower-level binding provides this functionality, 
02:25:39 <dons> it shouldn't matter how it is implemented underneathe
02:25:59 <dons> so abstraction shouldn't be too hard 
02:26:23 <dons> oh. I'm moving the cursor too far to the right. got it :)
02:26:37 <dons> thanks for spotting that ;)
02:26:43 <juhp> :)
02:27:54 <juhp> dons: I guess I actually need to read the code to comment ;)
02:28:35 <dons> we have been discussing multiple uis -- it is certainly in the grand plan (tm)
02:28:51 <juhp> oh there is a ml now? :)
02:29:16 <dons> post-emacs@ :)
02:29:19 <dons> let me find the ref..
02:29:33 <dons> mostly on #haskell though
02:29:40 <juhp> ok
02:31:04 <dons> can't find the link. shapr's running post-emacs though
02:32:15 <juhp> google found it for me :)
02:32:35 <juhp> http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
02:33:37 <dons> that's the one
02:41:18 <dons> ciao
02:45:44 <juhp> dons: thanks - better now
02:50:45 <dons> battery went flat.
02:51:01 <dons> the emacs stack overflow will have to wait till tomorrow. too tired atm
02:51:42 <earthy> nightnight dons
02:55:27 <juhp> night, dons
03:18:36 <Oejet> Hi.
03:21:59 <bourbaki> moin
03:44:29 <Oejet> wolfman8k: Could you show me your raytracer again?
03:44:49 <wolfman8k> the code?
03:45:05 <Oejet> Yes.
03:45:07 <wolfman8k> http://rafb.net/paste/results/dNQL3V69.html
03:51:40 <Oejet> Thanks.
03:53:13 <wolfman8k> Cale made some small modifications to support color
03:53:23 <wolfman8k> http://vx.hn.org/autoshare/colours.png
03:53:29 <wolfman8k> http://vx.hn.org/autoshare/colours-2.png
03:54:19 <Oejet> That looks like the inside of a brain on drugs.
03:55:03 <Oejet> Oh, :o  it's just reflections. :-)
03:55:39 <wolfman8k> hehe
03:57:20 <tuomov> inside of a brain indeed
03:57:27 <tuomov> quite cool effect
03:59:15 <wolfman8k> you can see how he set up the scene:
03:59:16 <wolfman8k> http://vx.hn.org/autoshare/RaytraceIO.hs
04:00:24 <wolfman8k> the 3 spheres that you see in the middle are actually a reflection
04:00:37 <wolfman8k> you can see the objects they are reflecting at the edges of the image
04:01:01 <wolfman8k> and the scene has 3 colored lights, red green and blue
04:02:12 <wolfman8k> gonna eat now
04:53:17 <xs> hi! is it possible to do this in haskell? it works with ghc, but gives errors with hugs and nhc98:
04:53:20 <xs> class Foo f where
04:53:22 <xs>     Bar :: f
04:56:47 <marcot> Good morning.
04:57:22 <arjanb> xs: try bar instead of Bar
04:58:39 <Igloo> Why does GHC allow that?
04:58:42 <xs> oh! oops. yay. thanks.
05:00:37 * Igloo can't find a way to then do anything useful with Bar
06:16:22 <Lemmih> @seen shapr
06:16:23 <lambdabot> I saw shapr leaving #haskell 22 hours 44 minutes 21 seconds ago.
06:17:37 <tintin`> thats strange isnt it ?
06:17:45 <tintin`> 22hours is a long time
06:18:10 <tintin`> maybe he was glued to the television screen
06:18:54 <Oejet> tintin`: Maybe the v word. :o
06:19:23 <Oejet> (vacation)
06:19:47 <tintin`> did he mention it in here ?
06:22:05 <bourbaki> moin
06:22:18 <Lemmih> Hey bourbaki.
06:25:20 <bourbaki> anyone in here familiar with image processing?
06:29:54 <Oejet> bourbaki: Like image analysis?
06:32:38 <bourbaki> Oejet yep
06:43:51 <maihem> somewhat
06:44:52 <bourbaki> maihem can you join #ai for a sec then i dont have to tell it twice
07:19:54 <tromp> how does one emote?
07:20:54 <Oejet> tromp: Emote means...?
07:22:06 <tromp> my name appearing on the right
07:22:56 <Oejet> Like this, tromp?
07:22:59 <tromp> it's called that in MUDding
07:23:08 <tromp> no, oejet
07:23:13 <Igloo> Do you mean "/me runs away"?
07:23:29 <Oejet> He, I'm not into MUDding.
07:23:39 * Oejet is not into MUDding.
07:23:49 <wolfman8k> finally, it finished rendering!!!
07:23:52 * tromp runs
07:23:58 <tromp> ah! thx, Igloo
07:24:19 <tromp> and now why i needed it...
07:24:23 <wolfman8k> http://img8.exs.cx/img8/8587/haskell-raytrace-08.png
07:24:25 * tromp curses at grep
07:24:50 * tromp wants to grep for capitals in a file
07:25:18 <Igloo> wolfman8k: How many reflections do you follow?
07:25:26 <tromp> seems grep ignores case by default
07:25:29 <wolfman8k> Igloo: unlimited
07:25:49 * Igloo tries to work out if those are spheres
07:26:00 <wolfman8k> yep, only spheres
07:26:01 <Igloo> Ah, err, so can't you recurse infinitely if you get unlucky?
07:26:17 <Igloo> tromp: No it doesn't
07:26:17 <wolfman8k> yeah, it happened once, with scene even :)
07:26:29 <wolfman8k> Igloo: the sphere is directly in front of the camera
07:26:36 <wolfman8k> Igloo: and there is another sphere directly behind the camera
07:26:36 <tromp> well, mine does:(
07:26:46 <wolfman8k> Igloo: so a ray bounces between both these spheres infinitely :)
07:27:04 <wolfman8k> Igloo: i fixed it by nudging the sphere a tiny bit to the side :)
07:27:06 <Igloo> :-)
07:27:58 <wolfman8k> Igloo: check out a nice color image:
07:27:59 <wolfman8k> http://vx.hn.org/autoshare/colours-3.png
07:29:07 <tromp> maybe i dont understand what grep "[A-B]" should do...
07:29:14 <Igloo> Nice
07:29:58 <Igloo> $ echo -e "A\na\nB\nb" | grep [A-B]
07:29:58 <Igloo> A
07:29:58 <Igloo> B
07:29:58 <Igloo> $ 
07:30:26 <Igloo> That pick reminds me of the Mandelbrot set
07:31:05 <Igloo> Hmm, I wonder if there is a raytraced image equivalent. I suspect not a nice one.
07:31:22 <tromp> (haskell 1069) grep "[A-B]"
07:31:23 <tromp> b
07:31:23 <tromp> b
07:32:01 <tromp> same without the "
07:32:55 <tromp> funny enough grep "B" works fine
07:33:39 <Igloo> Urgle
07:36:11 <tromp> (haskell 1079) echo "a" | grep [A-B]
07:36:12 <tromp> (haskell 1080) echo "b" | grep [A-B]
07:36:12 <tromp> b
07:36:12 <tromp> (haskell 1081)
07:37:27 <Igloo> What does    echo abAB | od -t x1     say?
07:37:45 <tromp> 0000000 61 62 41 42 0a
07:37:45 <tromp> 0000005
07:37:59 <kosmikus> is this some strange shell you're using?
07:38:03 <Igloo> And   grep --version   ?
07:38:03 <tromp> bash
07:38:23 <tromp> grep (GNU grep) 2.5.1
07:38:31 <Igloo> echo grep [A-B]    ?
07:38:47 <tromp>  echo grep [A-B]
07:38:52 <tromp> grep [A-B]
07:39:37 <Igloo> Oh, what's the output of locale?
07:39:53 <tromp> LANG=en_US.UTF-8
07:39:53 <tromp> LC_CTYPE="en_US.UTF-8"
07:39:53 <tromp> LC_NUMERIC="en_US.UTF-8"
07:39:53 <tromp> LC_TIME="en_US.UTF-8"
07:39:53 <tromp> LC_COLLATE="en_US.UTF-8"
07:39:54 <tromp> LC_MONETARY="en_US.UTF-8"
07:39:56 <tromp> LC_MESSAGES="en_US.UTF-8"
07:39:58 <tromp> LC_PAPER="en_US.UTF-8"
07:40:00 <tromp> LC_NAME="en_US.UTF-8"
07:40:02 <tromp> LC_ADDRESS="en_US.UTF-8"
07:40:04 <tromp> LC_TELEPHONE="en_US.UTF-8"
07:40:06 <tromp> LC_MEASUREMENT="en_US.UTF-8"
07:40:08 <tromp> LC_IDENTIFICATION="en_US.UTF-8"
07:40:10 <tromp> LC_ALL=
07:40:32 <tromp> makes no sense to treat a and b differently
07:40:40 <Igloo> Set LC_COLLATE to C
07:40:56 <tromp> as environment var?
07:41:02 <Igloo> I recommend LC_NUMERIC=C LC_TIME=C LC_COLLATE=C LC_MONETARY=C LC_MESSAGES=C
07:41:03 <Igloo> Yup
07:41:25 <kosmikus> if I set my locale to tromp's it still works for me
07:41:42 <Igloo> kosmikus: Do you have LC_ALL set?
07:41:47 <kosmikus> no
07:42:06 <Igloo> Oh, you probably don't have that locale built so it'll be falling back to C anyway
07:42:14 <tromp> ah, that fixes it
07:42:19 <kosmikus> ah, that could be
07:42:42 <tromp> how does LC_COLLATE affect gre?
07:42:47 <tromp> grep
07:43:59 <Igloo> It sets the lexicographical ordering of characters
07:44:49 <tromp> so A-B was somehow evaluated to {B} ?
07:45:36 <tromp> weird
07:45:56 <Igloo> No, A-D meant AbBcCdD
07:46:17 <Lemmih> Yay. hs-plugins rocks!
07:47:02 <tromp> aha
07:48:31 <Lemmih> mod_haskell is now capable of loading haskell plugins (-:
07:54:16 <Philippa> cool. How much work'd it take to get it running Flippi?
07:58:24 <keverets> LC_TIME=en_DK.UTF-8
07:58:28 <keverets> It's the only sane way.
08:00:15 <Philippa> heh, that reminds me, I need to figure out what's involved in getting Flippi speaking UTF-8, too
08:00:20 <Oejet> keverets: Huh?
08:00:46 <Lemmih> Philippa: It would be very easy.
08:01:07 <Philippa> Lemmih: specifics?
08:01:28 <Philippa> (Flippi's just a Network.CGI hook w/parsec for parsing, so I figure I just need to frig with the IO in a few places)
08:02:34 <Lemmih> Philippa: It could be done just by changing the CGI wrapper.
08:03:00 <Philippa> hrmm, I imagine I'd need to alter the file IO as well though, given GHC's default encoding isn't anything unicode
08:03:01 <Lemmih> ei. no changes in your code.
08:03:21 <Lemmih> *ie
08:04:10 <keverets> Oejet: the only English locale that uses ISO 8601 date format.
08:04:53 <Lemmih> But it's not quite done yet.
08:09:03 <Oejet> Kelt: Is today then Wednesday 3/11-2004?
08:09:16 <Oejet> keverets: Ups.
08:16:48 <maihem> I can't for the life of me find anything about square root in http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:16:55 <maihem> any hints?
08:17:16 <kosmikus> @type sqrt
08:17:17 <lambdabot> sqrt :: forall a. (Floating a) => a -> a
08:17:21 <Lemmih> @eval sqrt 4
08:17:22 <lambdabot> 2
08:17:56 <Lemmih> @index sqrt
08:17:57 <lambdabot> GHC.Float,Prelude
08:18:03 <maihem> thanks, where can I find a definition of its behvaiour (ie, what happens if I do sqrt (-1) ? and such
08:18:08 <maihem> ah, thanks
08:18:24 <Oejet> @eval sqrt (-1)
08:18:24 <lambdabot> (line 1, column 7):
08:18:24 <lambdabot> unexpected "-"
08:18:24 <lambdabot> expecting simple term
08:18:39 <monochrom> That's odd
08:18:42 <Lemmih> @eval sqrt (1-2)
08:18:42 <lambdabot> divide by zero
08:18:43 <kosmikus> @eval sqrt (negate 1)
08:18:43 <lambdabot> unbound variable: negate
08:18:52 <monochrom> woah
08:19:05 <Lemmih> @index negate
08:19:06 <lambdabot> GHC.Num,Prelude
08:20:29 <maihem> hm, so doing sqrt of a negative number fails in the IO Monad for the computation that uses the function?
08:21:26 <kosmikus> doesn't have to do anything with the IO monad; it fails at runtime
08:21:30 <Lemmih> sqrt (-1) => NaN
08:22:11 <kosmikus> hmm, right, hugs causes a runtime error, though
08:22:13 <maihem> so the program exits ?
08:22:28 <Lemmih> maihem: Not in GHC.
08:26:54 <maihem> so the behaviour I can expect from GHC is that the result is the special NaN value, and I can test for that, etc. ?
08:27:06 <tromp> not really
08:27:13 <tromp> you better test the input to sqrt
08:27:36 <maihem> But my program is well typed.
08:27:54 <maihem> I think
08:27:59 <tromp> so is head []
08:28:31 <tromp> that doesn't prevent exceptions or failed patterns
08:28:44 <maihem> ah-ha, how do I catch exceptions?
08:28:48 <kosmikus> too bad Conor isn't here ;)
08:29:10 <tromp> NaN is not an exception
08:29:17 <tromp> just an exceptional value:(
08:29:28 <tromp> that you can't test for
08:29:33 <tromp> AFAIK
08:29:59 <maihem> uh-huh. Did they actually plan haskell, or did they find it down the back of the sofa ?
08:30:02 <tromp> *Lambda> sqrt (-1) == sqrt (-1)
08:30:02 <tromp> False
08:30:22 * maihem feels dejected
08:30:35 <tromp> why not test the input??
08:32:03 <maihem> tromp, because I then have to be fully aware of *every* case where sqrt may or may not fail. That's fragile. I should just be able to go "nope, that didn't work"
08:32:54 <maihem> sure, sqrt will only fail on negative numbers. But there are other functions that have more complex failure conditions.
08:33:59 <monochrom> So you write up your function, throw it at a highschool student, and ask "what is the domain of this function".
08:34:14 <dash> highschool students lie
08:34:40 <monochrom> You can also give it to a highschool math teacher and say "use it on your test hehehehe"
08:34:58 <tromp> you have a strange notion of fragile, maihem:)
08:35:15 <Lemmih> @type isNaN
08:35:17 <lambdabot> isNaN :: forall a. (RealFloat a) => a -> Bool
08:35:29 <tromp> guards to inputs make your code more robust
08:36:13 <maihem> tromp, I mean it is easy to break it as you make changes to your program. Even C handles floating point numbers better than that (you can test for NaN at the end of a whole slew of floating point operations, and say "Nope, that wasn't defined for this case")
08:36:20 <tromp> assuming the output is correct cause it didn't throw an exception is fragile
08:36:24 <maihem> Lemmih, :)))
08:36:48 <tromp> there's a mantra that goes like
08:36:53 <tromp> test early, test often:)
08:37:36 <tromp> thx for proiving me wrong, lemmih :)
08:37:56 <maihem> tromp, that works when you know the domain of the function for sure, or are happy with providing your own restriction. When using type inference, it doesn't work so well.
08:38:03 <tuomov> release early, release often. Let the thousands of nerds who want to live on the bleeding edge test it.
08:39:07 <maihem> eg, some function could be undefined for negative numbers because it is a -> a, but if I give it a complex number that has a zero imaginary part, it can calculate the result.
08:39:53 <monochrom> That doesn't happen.  Static typing.
08:39:57 <maihem> So I need to be able to write code that just works like that. Now I know about the isNaN functions, so I'm happy.
08:40:24 <tromp> well i'm happy you're happy:)
08:40:41 <Oejet> I'm happy tromp is happy.
08:40:55 * maihem attempts to give 91 people a hug
08:41:10 <maihem> monochrom, I don't understand?
08:42:28 <monochrom> a is fixed as either Double or Complex Double after compilation.
08:42:45 <monochrom> If it is fixed as Double, the program won't let you enter a complex number.
08:43:14 <monochrom> If it is fixed as Complex Double, the point is moot.
08:43:59 <maihem> yes, that's okay, but if I use the function for Double, and then change my program to use Complex Double, I would have been dumb if I had put in tests that the number wasn't negative real.
08:44:19 <maihem> because then I'd have to trawl through the program looking for all the tests
08:44:50 <tromp> i'd think a test c<0 for complex c makes no sense
08:45:26 <tromp> not unless u change it first to (realPart c) < 0
08:45:27 <maihem> so if I tested early and often, I'd have to go through and remove all those tests when I change the program to use complex instead of real.
08:46:37 <maihem> hm, but I see that isNaN has the same problem.
08:50:40 <maihem> I'll have to define a new class with a testing function that returns false on complex instance , and isNaN on realfloat.
08:50:45 <maihem> That should work
09:09:20 <SyntaxNinja> :'(
09:10:19 <syntax_syntax> this is my very simple "mean" function: mean :: [Integer] -> Float
09:10:19 <syntax_syntax> mean list = fromIntegral(sum list) / fromIntegral(length list
09:10:22 <syntax_syntax> oops. sorry.
09:10:26 <syntax_syntax> http://rafb.net/paste/results/XAQ9lS69.html
09:10:47 <syntax_syntax> how can I make a mean function that takes noninteger lists as well?
09:10:53 <maihem> What's up SyntaxNinja 
09:10:59 <SyntaxNinja> hi syntax_syntax
09:11:03 * syntax_syntax is not SyntaxNinja.
09:11:16 <syntax_syntax> heh. I've been syntax_recorded, recorded_syntax and the like at dalnet forever.
09:11:17 <SyntaxNinja> there can be only one!
09:11:29 <SyntaxNinja> maihem: just bummed about the election
09:11:37 <SyntaxNinja> but I'm _almost_ too old to get drafted so...
09:11:40 <maihem> Ah Kerry supporter, or Nader?
09:11:41 <syntax_syntax> it's kinda sad, yes.
09:12:11 <SyntaxNinja> maihem: kerry, I guess.
09:12:22 <maihem> ah, "Anybody but him"
09:12:47 <EviL_DORK> prolly why he lost
09:12:58 <EviL_DORK> wish the dems picked a better candidate
09:17:20 <syntax_syntax> ERROR "c:\stata.hs":6 - Instance of Integral Float required for definition of st
09:17:21 <syntax_syntax> d    
09:17:25 <syntax_syntax> what does that mean?
09:17:33 <syntax_syntax> Integral Float?
09:17:59 <syntax_syntax> http://rafb.net/paste/results/880tO875.html <-- the code
09:18:52 <maihem> I think you are trying to apply to a Float a function that refuses anything that doesn't satisfy the Integral predicate (class).
09:19:06 <syntax_syntax> not the case.
09:19:35 <tromp> too bad the Dems cldn't put up an anonymous candidate
09:19:55 <syntax_syntax> the function "std" calls the function "mean" I defined myself, and it's a [Float] -> Float function
09:20:04 <tromp> someone called "Anything but Bush"
09:21:09 <maihem> syntax_syntax, I think you should be using ** rather than ^
09:21:38 <syntax_syntax> hmm.
09:22:12 <syntax_syntax> it works. Thanks.
09:22:50 <syntax_syntax> but why am I getting negative std deviations? :-D
09:23:55 <syntax_syntax> is there a set of simple statistical functions built in haskell already?
09:25:23 <syntax_syntax> grrr.
09:29:41 <maihem> goddam computer, goddam SiS chipset.
09:32:48 <SyntaxNinja> I bootstrapped cabal on hugs last night :)
09:32:59 <syntax_syntax> map ((**) 2) [1,2,3] leads to [2**1, 2**2, 2**3]
09:33:06 <syntax_syntax> but what I want is [1**2, 2**2, 3**2]
09:33:16 <syntax_syntax> how do I "map to the right" ?
09:33:55 <Igloo> map (** 2) [1,2,3]  will do it
09:34:06 <syntax_syntax> oh.
09:34:08 <syntax_syntax> hmm.
09:34:20 <Igloo> That's slightly magical
09:34:33 <syntax_syntax> why does that work?
09:34:37 <Igloo> map (flip (**) 2) [1,2,3]   is less magical
09:34:48 <Igloo> As is   map (\x -> x ** 2) [1,2,3]
09:34:52 <maihem> 1 ** 2 = (**) 1 2
09:34:55 <Igloo> The first is sugar for the third
09:34:56 <tromp>  (** 2) is a so called section
09:35:05 <tromp> short for \x -> x ** 2
09:35:33 <syntax_syntax> oh ok.
09:35:33 <tromp> just like (2 **) is short for \x -> 2 ** x
09:35:34 <maihem> you did the second by putting the ** in parentheses
09:35:40 <syntax_syntax> so lambda expressions are always the safe way to map.
09:36:10 <syntax_syntax> I keep on getting strange numerical results.
09:37:19 <Igloo> It's not safety, it's just which you are familiar with
09:37:59 <syntax_syntax> I'm not familiar with anything ;-)
09:38:08 <syntax_syntax> And I keep on getting different results in haskell code and matlab code.
09:57:46 <stepcut> hrm, I can't bind anything to C-c in YI 
10:06:21 <mitchkov> hi, anyone knows how to change the heapsize compiling with ghci, the standard heapsize can't handle the size of list i'm working with... 
10:07:11 <stepcut> i think there is a runtime flag??
10:07:41 <wilx> I bet it is in the manual.
10:08:16 <stepcut> http://web.mit.edu/ghc/www/users_guide/runtime-control.html#RTS-HOOKS
10:08:25 <mitchkov> thx a lot
10:10:15 <stepcut> But I think the heap is supposed to grow dynamically, so if you are running out of heap, then maybe something more sinister is wrong
10:10:35 <stepcut> ?
10:12:09 <mitchkov> really dunno, i m looking if i have the error somewhere
10:13:49 <stepcut> I was guess that it is something related to recursion
10:14:11 <stepcut> s/was/would/
10:15:21 <stepcut> certain recursion patterns will cause lots of unevaluated thunks to be pushed into the heap, sucking up all your RAM :)
10:17:44 <mitchkov> this is the error:  Garbage collection fails to reclaim sufficient space; nothing but a huge list in my code
10:21:34 <stepcut> mitchkov: hrm. dunno...
10:21:38 <stepcut> how big is this list ?
10:21:47 <mitchkov> really big
10:22:05 <stepcut> a million elements? A billion elements ?
10:22:32 <mitchkov> no not that big
10:22:36 <mitchkov> 25 000 element
10:22:55 <stepcut> what type is each element ?
10:23:03 <mitchkov> double
10:23:30 <stepcut> at the command-line ,you can try, ./myprog -H100M and see if that helps...
10:23:53 <mitchkov> ok i'll try that
10:23:56 <mitchkov> thx for the help
10:46:06 <wilx> Might that be that you are running out of stack rather than heap space?
10:46:19 <maihem> If you were doing an operation with 2 vectors: v1 * v2, would the asterisk look like a dot product, cross product, or something else?
10:46:25 <CosmicRay> dash: hmm, voter turnout was decisive yesterday.... :-)
10:47:12 <stepcut> CosmicRay: I think you mean divisive
10:47:35 <CosmicRay> nah, decisive... dash wasn't voting because he thought it didn't matter if people didn't vote.
10:48:59 <stepcut> if you don't vote third party, you are just throwing your vote away ;)
10:49:19 <CosmicRay> heh
10:49:36 <dash> CosmicRay: i didn't say that
10:49:39 <dash> I never said that
10:49:47 <dash> I said it didn't matter if _I_ didn't vote
10:50:05 <CosmicRay> yes, well your vote is not specially irrelevant :-)
10:50:45 <stepcut> it may make a difference that I voted... the mayoral vote is really close in san diego...
10:50:46 <maihem> depends if hes a democrat in Texas
10:50:59 <dash> lemme put it this way. Whether or not I voted yesterday, the outcome would still be the same 
10:51:16 <wilx> Omg!!
10:51:45 * wilx resorts to violence on dash.
10:51:47 <stepcut> dash: on all ballot measures and candidates ?
10:54:06 <dash> stepcut: Dunno, but I'm 4 hours' drive from where i'd have to vote (i am working out of town)
10:54:28 <dash> stepcut: so maybe i should've voted for some dude in a local election, but who? :)
10:54:31 <dash> wilx: why violence
10:54:36 <dash> wilx: violence sucks
10:54:51 <dash> wilx: am I wrong?
10:55:11 <stepcut> dash: the winner, of course :)
10:55:24 <dash> stepcut: Meh
10:55:33 <dash> that's not even funny
10:55:37 <stepcut> otherwise you are just throwing your vote away
10:56:01 <dash> stepcut: voting for the winner is throwing your vote away too ;)
10:56:13 <maihem> Slightly less OT but still OT: what is the name of the operation on vector (a,b,c) and vector (a',b',c') that is equal to vector (a*a',b*b',c*c') ?
10:56:35 <dash> hmm. is that dot product?
10:56:44 <stepcut> dash: not voting is just throwing your vote away
10:57:16 <dash> stepcut: what _isn't_ throwing your vote away
10:57:31 <maihem> no, dot product is scalar a*a' + b*b' + c*c'
10:57:40 <dash> oh right
10:58:12 <stepcut> dash: voting twice !
10:58:40 <dash> stepcut: for different people? :)
10:58:43 * dash pokes wilx
10:59:46 <dash> stepcut: so who should I have voted for?
10:59:48 <stepcut> well, if you voted for someone that is not the winner, then atleast you can say "Don't blame me, I voted against him"
11:00:30 <dash> stepcut: how is that different from "don't blame me, I didn't vote for him"?
11:00:31 <peti> Yeah, but if you voted for someone who turns out to be an idiot, then you have to say: "OMG, I voted for that guy!" :-)
11:02:11 <stepcut> dash: the difference is one person tried to do something about it, the other person did nothing. 
11:02:25 <stepcut> peti: right, that is why you should vote third party :)
11:02:51 <dash> stepcut: yeah, OK, in a small local election I can believe that
11:03:17 <dash> stepcut: but in a national election like this, though, where individual votes make practically no difference, what's the point?
11:03:20 <wilx> dash, I think that everybody should go vote.
11:03:24 <dash> wilx: Why?
11:03:29 <dash> wilx: actually no wait
11:03:34 <peti> My impression is that getting rid of a politician by voting _another_ politician doesn't help matters. :-)
11:03:35 <dash> wilx: Vote for whom?
11:04:39 <wilx> Your thinking is wrong. Every vote counts and the amount of people who think like you is huge. If they would really vote maybe they would have changed the outcome.
11:04:41 <keverets> Oejet: no, today would be 2004-11-03
11:04:44 <wilx> dash, your choice.
11:04:59 <wilx> The one who you think will lead your country better.
11:05:08 <dash> wilx: so let me get this straight
11:05:33 <dash> wilx: if you and I were voting in the same election, you would prefer that I vote against your choice, rather than not voting at all?
11:05:47 <wilx> Yes.
11:06:02 <dash> OK, I don't understand that at all. Why?
11:06:41 <dash> why are _you_ voting, if not to attempt to get your guy into office?
11:07:35 <dash> if that is your goal, then it would seem to me that you would want as few opposing votes as possible
11:08:46 <stepcut> dash: There are reasons to vote other than the outcome of the count
11:09:24 <dash> stepcut: OK, that's what I was guessing, because otherwise it makes no sense
11:09:25 <wilx> Sure but it is no life/death situation so I think that the accuracy of the vote is more important than the outcome itself. I vote, you vote, there are more supporters for your course, you win.
11:09:42 <dash> stepcut: Tell me about them.
11:09:47 <dash> wilx: "accuracy of the vote"?
11:10:01 <wilx> Ummm, I mean, the overall opinion of nation.
11:10:36 <wilx> Well, I must say that I don't have completelly rational reasons for what I say.
11:10:58 <dash> wilx: No, I don't expect you do; voting is a religious activity
11:14:56 <dash> stepcut: so what are the other reasons
11:15:28 <stepcut> dash: can you guess ?
11:15:44 <syntax_syntax> I have Yet Anoter Annoying Noob Question.
11:16:24 <dash> stepcut: well, my guess is "Democracy is a religion and voting is its sacrement"
11:16:31 <dash> er, sacrament
11:16:46 <stepcut> dash: what does that even mean ??
11:16:53 <Lemmih> syntax_syntax: great.
11:17:44 <dash> stepcut: One of the fundamental things religion does is provide legitimacy for a society's laws
11:18:24 <wolfman8k> check out the new render!
11:18:25 <wolfman8k> http://img49.exs.cx/img49/8617/haskell-raytrace-09.png
11:18:28 <syntax_syntax> http://rafb.net/paste/results/Ku1H5B45.html
11:18:34 <syntax_syntax> All functions work okay, till "cov".
11:18:39 <dash> stepcut: by having a public ritual for the nation to participate in, community is created and the authority of the lawgivers is upheld
11:18:46 <syntax_syntax> Then I get an error: "ERROR "c:\stata.hs":14 - Instance of Num [Float] required for definition of cov "
11:18:51 <mornfall> wazzap?
11:19:20 <Lemmih> wolfman8k: Wow.
11:19:27 <wilx> Nice pic.
11:19:50 <arjanb> syntax_syntax: you are trying to multiply lists
11:20:26 <syntax_syntax> oh yeah. I wanted to multply "sex list", not "xex list".
11:20:28 <syntax_syntax> I'm dumb.
11:20:35 <wolfman8k> wilx: is it better then a checkerboard? :)
11:21:03 <syntax_syntax> I need better function names.
11:21:05 <wilx> Oh, now I see, the spheres are on the sides...
11:21:13 <wilx> Hm, looks good too :)
11:21:46 <wolfman8k> it even rendered pretty fast
11:21:56 <wolfman8k> that image took only about 20 seconds
11:24:04 <Oejet> wolfman8k: How's the profile of that?
11:24:21 <syntax_syntax> I also need to know how to do a bivariate "map".
11:24:44 <syntax_syntax> I mean, I have two lists, I want a third list that contains the vectorial product of them
11:25:02 <syntax_syntax> list1 = [a,b,c] , list2=[d,e,f] ===> list3 = [ad, be, cf]
11:25:51 <Lemmih> syntax_syntax: You can use zip together with map for that.
11:26:02 <arjanb> zipWith (*)
11:26:05 <syntax_syntax> oh.
11:26:08 <syntax_syntax> zipWith. Pretty.
11:27:27 <wolfman8k> Oejet: hehe
11:27:39 <SyntaxNinja> CosmicRay: I uploaded a new cabal
11:27:49 <CosmicRay> SyntaxNinja: excellent
11:28:19 <syntax_syntax> sorry for all the annoying beginner questions 
11:28:22 <syntax_syntax> thanks :)
11:28:22 <CosmicRay> SyntaxNinja: I'll wait for the buildd's to get a chance to build and install it, then find some reason to release a new hunit so they build it
11:28:48 <Si\> how can I stop "*** WARNING: . is writable by someone else, IGNORING!" from appearing?
11:28:49 <SyntaxNinja> c00
11:29:06 <CosmicRay> Si\: what's generating that?
11:30:36 <Si\> GHCI, when I try to use a .ghci which is in a directory which is writable by others
11:30:51 <Si\> it's a collaborative effort so it has to be
11:38:52 <CosmicRay> huh..   you might want to write to the glasgow mailing list
11:41:00 <syntax_syntax> hmm. 
11:41:04 <syntax_syntax> this can be a little inefficient.
11:41:36 <syntax_syntax> I'm normalizing a list. That is, for each element I subtract the mean and divide by the standard deviation.
11:42:03 <syntax_syntax> The thing is, defining things functionally, it calculates the standard deviation of the whole list for each element. 
11:42:09 <syntax_syntax> As opposed to doing it once and getting on with life.
11:42:18 <syntax_syntax> That can build up quickly.
11:43:48 <Oejet> syntax_syntax: How do you know that?
11:44:39 <syntax_syntax> because I'm doing it?
11:44:55 <syntax_syntax> It 'll take longer and longer for each element.
11:45:08 <syntax_syntax> If I try to normalize [-100..100], it takes two seconds for each element.
11:45:57 <syntax_syntax> this is un-smart.
11:46:11 <dash> yeah, sounds like you need to calculate the mean and stddev first
11:46:30 <syntax_syntax> I was trying to do it the functional way.
11:46:33 <syntax_syntax> But.
11:46:46 <arjanb> what's the code you have now?
11:46:55 <dash> well, you can't really do it in an un-functional way in haskell, i'd think :)
11:47:10 <syntax_syntax> http://rafb.net/paste/results/4LtSSn47.html
11:47:58 <syntax_syntax> do you see the problem?
11:51:40 <wolfman8k> later people! i'll be back in 3 weeks
11:53:29 <Oejet> wolfman8k: Try to relax.
11:54:29 <wolfman8k> Oejet: i'll do some mental profiling on my trip :]
11:55:10 <Oejet> wolfman8k: :-P Now you are hooked. I can see it in your smile: :]
11:55:16 <syntax_syntax> the democrats need to get their act together.
11:56:01 <wolfman8k> i'm going to bush-land!
11:56:57 <dash> first thing that comes to my mind is "norm x = map (flip (/) stddev . flip (-) meanVal) list where {stddev = std list; meanVal = mean list;}"
11:57:03 <dash> or something like that
12:00:09 <dash> syntax_syntax: how's that?
12:00:14 <Oejet> syntax_syntax: Maybe a let x = blob in f(x).
12:00:56 <dash> the fun part of haskell is that you don't need lambdas a lot of the time 
12:02:01 <dash> hmm, except "\x -> x^2" is shorter than "flip (^) 2" :)
12:03:26 <tic> flip a b = b a?
12:04:00 <CosmicRay> tic: (flip x) b a = x a b
12:04:17 <tic> Hrm.
12:04:31 <tic> Ah, right. Now I see
12:08:04 <bojohan> dash: well, (^2) is even shorter
12:08:38 <dash> true, i just noticed this.
12:08:57 <dash> unfortunately, it doesn't look like you can do (- mean)
12:09:13 <dash> you can do (+ -mean), i bet >:D
12:09:19 <bojohan> minus is a bit nasty
12:09:31 <kristnjov> hi guys... is there any id3 module for haskell out there?
12:09:33 <Maddas> dash: haha
12:15:16 <dash> so then. "norm x = map ((/ stddev) . (+ -meanVal)) x where {stddev = std x; meanVal = mean x;}"
12:29:48 <kristnjov> when i'm compiling my hs file with GHC, some putStr's aren't printed out, why's that?
12:32:16 <Lemmih> Maybe the output is stuck in the buffer. Did you print a newline or flush the buffer?
12:32:41 <kristnjov> well this is the first time i'm using GHC, i've only been using hugs before
12:32:48 <kristnjov> 	  putStr "Album name: "
12:32:48 <kristnjov> 	  album <- getLine
12:32:52 <kristnjov> that's a code snippet
12:34:56 <Lemmih> stdout is line buffered. You need to flush it after the 'putStr' or set it to NoBuffering.
12:35:16 <kristnjov> i've never heard about such things before :/
12:35:43 <Maddas> Maybe that's because you're using GHC for the first time :-)
12:36:05 <kristnjov> probably, yes :)
12:36:13 <kristnjov> how do i flush the stdout?
12:36:30 <kristnjov> and why don't i have to flush in hugs?
12:36:43 <Lemmih> @index flush
12:36:44 <lambdabot> Graphics.UI.GLUT,Graphics.Rendering.OpenGL,Graphics.Rendering.OpenGL.GL
12:36:44 <lambdabot> Graphics.Rendering.OpenGL.GL.FlushFinish
12:36:47 <Lemmih> @index hflush
12:36:47 <lambdabot> bzzt
12:37:17 <Lemmih> @index hFlush
12:37:18 <lambdabot> GHC.Handle,System.IO,IO
12:37:26 <Lemmih> @type System.IO.hFlush
12:37:27 <lambdabot> System.IO.hFlush :: GHC.IOBase.Handle -> IO ()
12:38:23 <Lemmih> 'hFlush stdout' or 'hSetBuffering stdout NoBuffering'
12:38:35 <kristnjov> after every putStr?
12:39:00 <kristnjov> and hugs doesn't seem to be able to handle System.IO.hFlush or something
12:39:08 <kristnjov> i get syntax error in declaration
12:40:05 <Lemmih> @wiki HaskellIrcPastePage
12:40:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:41:26 <Lemmih> Showing us the code will make it easier to debug.
12:43:00 <kristnjov> Lemmih, okay i pasted the code now
12:46:32 <Lemmih> kristnjov: Just add 'hSetBuffering stdout NoBuffering' before the first 'putStr'.
12:46:42 <Lemmih> kristnjov: And import System.IO
12:47:05 <kristnjov> thanks
12:47:08 <kristnjov> i appreciate it
12:47:13 <Lemmih> No problem.
13:21:27 <tromp> @index when
13:21:27 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
13:21:27 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
13:21:27 <lambdabot> State,Control.Monad.Writer,Monad
13:49:24 <Lemmih> Yay 100 people in #haskell!
13:49:59 <stepcut> heh
13:50:09 <yeti> hehe
13:50:12 <yeti> if i leave now...
13:50:13 <yeti> :p
13:51:38 <Lemmih> No, don't go!
13:54:13 <stepcut> hrm, I need to write a show function for characters that shows things in an emacs like manner
13:54:26 <stepcut> C-c instead of \ETX
13:54:38 <stepcut> cuz, what the help does ETX mean anyway ?
13:56:30 <Lemmih> stepcut: That's shouldn't be hard.
13:56:43 <Lemmih> *That
13:58:01 <stepcut> maybe just a big case statement :p
14:02:22 <Lemmih> myShowString string = concatMap myShowChar string
14:02:23 <Lemmih> myShowChar c
14:02:23 <Lemmih>     | ord c < 26 = ['C','-',chr $ pred (ord 'a') + (ord c)]
14:02:23 <Lemmih>     | otherwise = [c]
14:03:55 <stepcut> thanks
14:04:11 <stepcut> what is the license on that code ?
14:04:44 <stepcut> don't forget '\000'
14:05:43 <earthy> hmnz.
14:05:53 <earthy>     Context reduction stack overflow; size = 21
14:05:53 <earthy>     Use -fcontext-stack20 to increase stack size to (e.g.) 20
14:06:03 <earthy> that'll have to wait until tomorrow
14:06:08 <earthy> g'night all ;)
14:06:16 <Lemmih> Bye earthy
14:06:24 <stepcut> earthy: just use the flag...
14:06:37 <earthy> (nope, it's an infinite recursion at the type level ;))
14:06:55 <stepcut> earthy: ah... with HaskellDB, that error is legit
14:07:11 <stepcut> (i think it was haskellDB atleast)
14:07:46 <earthy> oh yeah, but in this case the context stack starts repeating itself after the 3rd item on the stack
14:07:52 <earthy> alternating between two types
14:08:09 <earthy> and yes, it's a fundamental problem in my code that I really ought to fix ;)
14:08:16 <earthy> (or not, and lose show functionality... ;))
14:08:31 <stepcut> are C-i and tab identical ?
14:09:37 <Lemmih> They are indeed.
14:10:18 <stepcut> I think I need to put is some special cases then
14:10:42 <Lemmih> isSpace c = [c]?
14:10:52 <stepcut> but I can just stick them before the c < 27 line
14:11:12 <stepcut> well, I want tab to show TAB and escape to show ESC
14:12:28 <Lemmih> Oh /-:
14:14:39 <Lemmih> Btw, mod_haskell is almost usable. I just need to parse the query.
14:17:52 <Marios> hello,im a beginner tryin to write a function that given a list of numbers and another list with items returns a list with elements the items that their positions are the numbers in the first list.can u help?
14:18:11 <Marios> ive done it workin if i have only one number and a list but 
14:18:22 <Marios> cant get it work like that
14:18:43 <Marios> is there any helpful function i can use?
14:19:15 <Lemmih> I'm not sure I know what you're trying to achieve.
14:19:26 <Marios> for example:
14:20:05 <tuomov> Marios: you might want to try 'map' on your single-number function
14:20:27 <Marios> given [1,3] [table,chair,apple,orange] will return [table,apple]
14:20:50 <tuomov> (properly partially evaluated)
14:22:10 <Marios> tried map maby im doin somethin wrong
14:22:42 <tuomov> what are you doing?
14:24:02 <Marios> want to see the function its 3 lines?
14:24:19 <tuomov> just your map attempt
14:26:35 <Marios> pino :: Int -> OneResult -> OneResult
14:26:35 <Marios> pino z ((a),(b,c),(d,e)) = if z==a then ((a),(b,c),(d,e)) else ((0),("",0),("",0))
14:26:35 <Marios> pianoMia :: Int -> Results -> Results
14:26:35 <Marios> pianoMia z (h:[]) = ((pino z h):[])
14:26:35 <Marios> pianoMia z (h:t) = (pino z h:pianoMia z t)
14:26:46 <Marios> ive deleted the thing with the map
14:27:51 <Marios> i think it will be easier if u can tell me in general wot to do with this
14:29:32 <tuomov> eh. that doesn't seem to do any sort of lookup..
14:30:38 <Marios> yeh with this one i get the list back with all the elements of the list ((0),("",0),("",0)) except the one i want 
14:31:08 <Marios> and then i was thinkin to delete all these 0 elements to leave the one i want
14:31:13 <bojohan> that's not a list
14:31:29 <Marios> yeh
14:31:44 <Lemmih> Marios: You might wanna look at (!!) and map.
14:31:46 <Marios> a list will consist of many of those
14:32:13 <tuomov> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
14:32:17 <Lemmih> @eval ["hello","world"] !! 0
14:32:17 <tuomov> there's lots of useful functions there
14:32:17 <lambdabot> (line 1, column 19):
14:32:17 <lambdabot> unexpected "!"
14:32:17 <lambdabot> expecting operator, simple term or end of input
14:33:16 <Lemmih> Someone should make a hs-plugins module for lambdabot so it can learn Haskell.
14:34:08 <Marios> thank u,ill have a look, ill let u know if i made any progress
14:43:26 <Lemmih> Hello marcot
14:44:58 <marcot> Lemmih: Good evening.
14:45:12 <marcot> Lemmih: are you working in yi's development?
14:45:35 <Lemmih> #haskell is getting mighty crowded.
14:45:55 <Lemmih> No.
14:45:58 <dash> "haskell is 67% full, please delete anyone you can"
14:46:07 <Lemmih> haha
14:46:22 <Pseudonym> Don't be silly.  We just garbage collect anyone who isn't live.
14:46:43 <dash> gc isn't enough
14:46:58 <tuomov> but because we're lazy, there's some space leak
14:47:06 <dash> as i'm sure you know! you have to kill off people who aren't relevant anymore
14:47:14 <marcot> dons: are you in there?
14:47:33 <dash> marcot: he must not be! quick, GC him.
14:48:05 <marcot> dash: =)
14:48:57 <marcot> dash: is your nick from the Debain Almquist Shell?
14:49:01 <marcot> Debian.
14:49:25 <shapr> g'day Pseudonym 
14:49:26 <stepcut> hey shapr
14:49:27 <Lemmih> Hey shapr.
14:49:32 <skew> hi shapr
14:49:36 <Lemmih> Where have you been?
14:49:36 <shapr> greetings!
14:49:44 <shapr> I have meditating on the vagaries of paying work.
14:49:48 <Pseudonym> G'day.
14:50:28 <dash> marcot: when i chose this nick, it was still 'ash' :)
14:50:47 <dash> hello shapr
14:50:49 <shapr> Cale: btw, I just setup AntiSpamGlobalSolution on HaWiki
14:50:52 <shapr> greetings dash 
14:50:55 <marcot> dash: =)
14:51:00 <marcot> hello shapr 
14:51:12 <shapr> Cale: and I turned off the entire banlist, so we'll quickly see whether it works or not.
14:51:19 <skew> dash, did you knock that parser into line?
14:51:25 <dash> skew: yep
14:51:38 <dash> skew: and i think i've even got the interpreter to have reasonable semantics
14:51:53 <dash> skew: now i am thinking it needs to get coverted to a monadic form 
14:51:56 <shapr> so, did I miss anything exciting?
14:52:02 <shapr> ohh, he said monadic.
14:52:11 <skew> that's nice. where are you getting your semantics from?
14:52:31 <dash> skew: i'm starting from Queinnec's "Lisp in Small Pieces"
14:53:20 <dash> i am trying to condence it into a form where i can add new semantics and have it be relatively clear what's going on
14:53:34 <dash> right now it's pretty CPS-heavy
14:53:44 <Lemmih> shapr: mod_haskell is very close to be usable.
14:53:47 <skew> are you supporting continuations?
14:53:55 <dash> skew: no call/cc yet
14:53:58 <skew> Oh, you need to thread the state anyway
14:54:03 <skew> stupid state :)
14:54:06 <dash> skew: haven't decided if i want to or not 
14:54:26 <dash> skew: Meh. state is a non-localizable phenomenon :p
14:54:27 <shapr> Lemmih: cool
14:54:33 <Lemmih> shapr: ie. everything is working except the query parsing which I'm probably gonna steal from some CGI library.
14:54:38 <skew> well, monads are very good at hiding that sort of plumbing. I was going to suggest using some the last time I was on
14:55:11 <dash> skew: yeah, now that the simple version works, switching to that will be doable i think
14:55:27 <shapr> PLog's RSS support is really minimal.
14:57:16 <shapr> Lunar^: salut!
14:58:03 <shapr> Lunar^: hey, I saw this unicyclist who reminds me a lot of you.
14:58:10 <shapr> so, what's the cool code of the day?
14:59:02 <dons> moin
14:59:09 <shapr> g'day dons, how's code?
14:59:29 <kosmikus> hi there
14:59:36 <dons> good, good. so much to do, so little time
14:59:50 <shapr> greetings kosmikus, did you get more HC&AR entries than last time?
15:00:06 * kosmikus finds it funnier to play with possible layouts for the HCAR than to prepare the actual content ...
15:00:11 <dons> hehe
15:00:40 <kosmikus> well, earthy did the previous one, so I don't have exact numbers
15:01:32 <kosmikus> I got a lot of contributions, I'd say, including some really new stuff; however, some classics are not updated (yet)
15:03:35 <shapr> I look forward to reading it.
15:04:04 <kosmikus> I'm also wondering if/how I should mention the contest, since no impartial person has written a statement about it
15:04:17 <shapr> ICFP?
15:04:27 <kosmikus> yes
15:09:25 <dash> shapr: want to look at this interpreter code and help me think about how to restructure it monadically?
15:09:27 <Philippa_> d'oh, forgot to submit an updated one on flippi
15:09:39 <dash> http://ghostwheel.ddts.net/~washort/arnis.hs
15:09:42 <Philippa_> oh well, the thing I did submit contains mostly up-to-date info anyway, just wants to mention that 0.03's out now
15:09:56 <shapr> At the moment I'm trying to fix my blog...
15:10:07 <dash> shapr: OK!
15:10:09 <skew> dash: want to see a simple monadic interpreter I put together?
15:10:12 <shapr> greetings Philippa_, any more thoughts on {template} ?
15:10:14 <dash> skew: I do.
15:10:33 <kosmikus> Philippa_: just do it
15:10:50 <stepcut> shapr: I have beginning emacs bindings for YI, though I need to refactor it a bit because its too confusing to write the bindings
15:11:21 <dons> cool
15:11:36 <dons> have you seen the initial emacs binding already in Keymap/Emacs.hs?
15:11:41 <dash> skew: i've seen a good bit of modular monadic interpreters, but they look like they've got a whole lot of plumbing to support the modularity. a non-modular one would be handy :)
15:11:55 <dons> it was contributed a couple of days ago, just to get people started
15:11:56 <stepcut> dons: except I can not bind to C-c because it never gets pass to keymap
15:12:11 <dons> I just tested this, it works. I fixed that 2 days ago. 
15:12:15 <stepcut> dons: ah, I think I may be out of date
15:12:23 <dons> raw mode :)
15:12:34 <stepcut> :p
15:12:36 <shapr> dash: http://www.cs.fit.edu/~satkin/monads.html
15:13:42 * dash nods
15:14:20 * stepcut is checking out the other emacs binding keymap
15:14:23 <dash> so pretty obviously, 'unit' is for quoting values and 'bind' is for sequencing the evaluation of expressions
15:14:27 <dons> stepcut: also, now to use an alternate keymap, you can just 'import Yi.Keymap.Emacs' in Config.hs
15:14:53 <dons> stepcut: feel free to hack the code up, or adapt it.
15:16:23 <stepcut> looks similar to what I did (nested finite maps), though I choose to explicitly pass the keymap around instead of using an IORef...
15:16:41 <dons> how do you pass the map back to the main loop?
15:17:30 <stepcut> dons: I don't...
15:17:34 <dons> or, how are you storing the state between calls, then
15:18:03 <dash> skew: can i see your code? =)
15:18:18 <stepcut> dons: state, like C-x- ?
15:18:40 <shapr> stepcut: do you have a repo I can pull from?
15:18:55 <stepcut> shapr: no, I can email it around
15:19:03 <dons> yeah. send it out
15:19:14 <stepcut> maybe I will send it to post-emacs ?
15:19:26 <shapr> fine with me
15:19:34 <dons> I think the IORef soln is so that you can update the map. How do you do this?
15:20:08 <stepcut> I have a recursive cmd function with the type signature:
15:20:13 <stepcut> cmd :: FiniteKeyMap -> FiniteKeyMap -> Char -> IO Keymap
15:20:23 <dons> ah.. now we get to the fun :)
15:20:32 <skew> dash: just a minute, I'm checking that it still works and has reasonable comments
15:20:38 <stepcut> where FiniteKeyMap is:
15:20:38 <stepcut> data FiniteKeyMap = FKM (FiniteMap Char (Either FiniteKeyMap (FiniteKeyMap -> IO Keymap)))
15:20:43 <dash> skew: <3
15:20:47 <dons> hmm. so do you ever return to the main loop?
15:21:24 <stepcut> the first argument to cmd is the global key, and the second argument is the context specific one (for example, valid things you can press after C-x)
15:21:31 <stepcut> dons: i suspect I do not, is that bad ?
15:21:45 <dons> I'm not sure. I have to think about it :)
15:21:51 <dons> it's a nice way to keep the state, though
15:22:03 <dons> well. for one, if an exception is thrown, you get dumped back into the main loop
15:22:13 <dons> so you'd lose any new bindings?
15:22:22 <Marios> thanx for ur help earlier lemmih it was very helpful,i managed to finish it
15:22:23 <stepcut> I suspect I would
15:22:58 <dons> I general mechanism for passing arbitrary state to and from the keymap is needed
15:23:05 <stepcut> yeah
15:23:17 <dons> so that we don't resort to hacking: IORefs, and taking over the main loop
15:23:36 <shapr> does the main loop carry around any state right now?
15:23:42 <dons> no.
15:23:52 <dons> so what's the type of the state a lexer can return?
15:24:10 <shapr> what about a Chan?
15:24:16 <stepcut> I guess one question is, how do per buffer keymaps work ?
15:24:41 <dons> my idea there was to locally bind a Keymap to a buffer.
15:24:52 <dons> so on switching focus, the current keymap is switched too
15:24:59 <dons> should be fairly easy.
15:25:05 <stepcut> and, when a unload a 'mode', how do I invalidate those key bindings
15:25:46 <dons> it would be nice to revert to a previous mapping, in such a case, wouldn't it?
15:26:12 <stepcut> well, it is not necessarily a stack
15:26:28 <stepcut> I might enable mode1, mode2, mode3, and then disable mode2...
15:26:32 <shapr> yah
15:26:33 <stepcut> but still want mode1 and mode3
15:26:39 <shapr> like major and minor modes in emacs
15:26:59 <dons> I'm not sure if the major/minor mode distinction is necessary, however
15:26:59 <shapr> is Yi multithreaded at the moment?
15:27:14 <dons> we could just have modes, that can be overlaid
15:27:26 <Lemmih> Marios: That's great. (-:
15:27:31 <dons> shapr: not yet. syn hl will probably be the introduction of that
15:27:31 <stepcut> dons: yeah, that is what I am thinking
15:28:00 <shapr> what if the gui and the key input are in separate threads?
15:28:12 <stepcut> dons: also, I may only want a keymap active in certain contexts in the buffer, for example, when editing a .lhs file or a .php file where two different languages appear in the same buffer...
15:28:31 <dons> yeah. that's on the agenda too.
15:28:34 <shapr> and possibly the 'backend' in a separate thread too, for painfully slow GUIs 
15:28:36 <dons> math mode in .tex is another one
15:29:06 <dons> shapr: breaking off the ui would be fairly easy. 
15:29:26 <shapr> would that mean the 'main loop' would no long have to worry about passing around keymap state?
15:30:45 <dons> can you expand?
15:31:59 <dons> btw, i'm cooling on the whole lazy lexer data type for keymaps, in favour of FMs and igloo's regex code
15:32:15 <dons> the lexer syntax is pretty heavyweight
15:32:15 <shapr> yah, I agree.
15:32:42 <shapr> I found some bits I didn't like while reading the paper.
15:33:17 <dons> it's quite nice for writing lexers:
15:33:18 <dons> inlinecomment = string "--" +> anyButNL `star` char '\n'
15:33:18 <stepcut> dons: the lexer stuff seemed neat, but I could not figure out how to modify keymaps on the fly without editing the .hs
15:33:18 <dons>     `lexmeta` \_ p cs -> (Nothing, retPos p, cs, Nothing)
15:33:53 <dons> stepcut: you mea like the keymap function in Vi.hs?
15:34:03 <shapr> the way I see it, the GUI has the keymaps, and a Chan of incoming chars, once it matches a char to command, it fires the command off to the 'core'
15:34:09 <dons> there's no way if the keymap is just a function.
15:34:37 <shapr> or maybe I'm suffering from emacs-centric thinking....
15:34:50 <stepcut> dons: yeah, the vi one
15:34:52 <dons> but if we treat the lexer as data, then it's easy to update mappings. that's how the tabular ctk lexer workds
15:35:15 <dons> but this turns out to be much the same as nested FMs anyway
15:35:16 <stepcut> dons: that is why I had to seperate the bindings into a seperate data-structure
15:35:26 <tuomov> hmm.. but if keypress was a patch..
15:35:39 <dons> hmm.. thinking...
15:36:07 <dons> stepcut: bindings as data structures may be needed for undo/redo too.
15:36:11 <tuomov> would seem to make implementing prefix maps complicated, though
15:36:24 <stepcut> with the current Vi one, I could write a new function that checks for a specific new binding, and if no match is found, then fall through to the old binding...
15:37:12 <stepcut> but that does not solve the problem of having to compile something...
15:37:21 <dons> yeah. but the table-based system is more general.
15:37:42 <dons> also, the table couldn't be read/showable, so we could have new bindings persist
15:38:11 <stepcut> couldn't be or could be ?
15:38:16 <shapr> hoi jyp 
15:38:20 <dons> could be
15:38:28 <stepcut> ack, bbiab
15:38:55 <jyp> hey
15:39:06 <shapr> jyp: are you new here?
15:39:43 <shapr> dons: nested FMs sounds pretty straightforward
15:39:48 <dons> yep.
15:39:49 <jyp> Sort of... I've checked a year ago, back now
15:39:59 <dons> easy to bind such a map to a window, or buffer
15:40:18 <shapr> jyp: so you already know Haskell?
15:40:25 <jyp> For sure ;)
15:40:26 <shapr> dons: emacs has global and local bindings
15:40:54 <shapr> that sounds like the easiest approach here, a buffer local FM and a global FM
15:41:21 <tuomov> hmm..
15:41:27 <tuomov> but you have mode-specific bindings too
15:41:33 <dons> begin with the global fm, and then buffers can load in modes over the top
15:41:53 <tuomov> no, modes should be under the global
15:41:58 <bojohan> emacs has many different kind of maps
15:42:04 <tuomov> I hate it when modes override my excellent bindings in jed
15:42:15 <shapr> modes are buffer-specific usually.. 
15:42:35 <dons> we are using the term 'mode' to denote 'set of key bindings'?
15:42:39 <shapr> I think so
15:42:46 <shapr> though it could be a lot more
15:42:54 <Pseudonym> Oh, good quote on /.
15:43:00 <dons> yeah. more attributes etc. but that's all yi has for now
15:43:02 <Pseudonym>  Emacs is an all right OS, but it lacks a decent editor.
15:43:14 * dash attacks Pseudonym 
15:43:19 <dash> Pseudonym: That is not a good quote.
15:43:21 <dash> It is a stupid quote.
15:43:33 <dons> tuomov: so you'd not want a mode to clobber your global custom keys?
15:43:40 <tuomov> of course not
15:43:57 <dons> yeah. that's fairly easy to deal with
15:44:00 <tuomov> infact, there should perhaps be some mode prefix key exported by the main keymap
15:44:13 <dons> prefix?
15:44:45 <shapr> jyp: have any questions? looking for any info?
15:44:48 <tuomov> perhaps the main keymap should just pass control to the mode maps when it wants to
15:44:54 <shapr> dash: dude, we're all friends here...
15:45:14 <shapr> here in #haskell, vim users chat freely with emacs users...
15:45:26 <dons> as long as we all promise to switch to yi
15:45:26 <shapr> C fanatics get lynched... but that's okay.
15:45:45 <jyp> hello
15:45:56 <dash> shapr: i am both an emccs and a vim user 
15:46:19 <jyp> I'm still struggling with my IRC client so don't take everything I say literally ;)
15:46:40 <bojohan> does yi have an irc mode yet?
15:46:47 <shapr> not yet
15:46:54 <dons> no. but I'm thinking about it
15:47:01 <shapr> though I'm already thinking about how to shoehorn lambdabot into yi
15:47:17 <dons> it seems to me that embedding programs in yi is just writing a fancy keymap too
15:47:36 <shapr> there's a bit more there
15:47:41 <bojohan> then you can try to shoehorn gnus in there
15:47:43 <tuomov> a fancy transformation..
15:47:50 <shapr> for example, how should a separate thread send input to a buffer?
15:47:58 * bojohan gives shapr a 
15:48:03 <shapr> bojohan: I've been thinking about which parts of gnus I want too =)
15:48:03 <bojohan> bah
15:48:14 <dash> bojohan: if it would barely fit, you could call the new version "snug"
15:48:23 <dons> threads, threads... not yet.
15:48:41 * bojohan gives shapr a gargantuan shoehorn
15:48:54 * dons might hack up a little ghci mode
15:48:55 <dash> The kind with teeth?
15:49:08 <shapr> lambdabot is just a typeclass, with one method for each IRC signal
15:49:18 <shapr> and it has a Chan in, and a Chan out
15:49:29 <Pseudonym> Lambdabot is actually shapr typing really fast.
15:49:41 <shapr> This is how the great Haskell coder, Pseudonym wrote lambdabot in the first place.
15:49:57 <Pseudonym> No it wasn't.
15:50:03 <shapr> well, ok.. it was close.
15:50:05 <Pseudonym> That was a later hack-up.
15:50:14 <Pseudonym> Can't recall if I did that or not.
15:50:30 <Pseudonym> But the first incarnation definitely didn't have the big typeclass.
15:50:32 <shapr> you had one function for each signal, and a catchall that complained about unimplemented signals.
15:50:37 <Pseudonym> Yes.
15:50:53 <Pseudonym> That sounds more like it.
15:50:56 <Pseudonym> Hmmm.
15:51:01 <Pseudonym> Or was it a big case expression?
15:51:33 <shapr> might have been.
15:53:28 <skew> dash: okay, the code again compiles, and a webserver again runs. Grab haskell.tar.bz2 and CUAN.tar.bz2 from http://page-148.caltech.edu/
15:55:27 <dash> skew: Hmm, that index page has awfully familiar formatting ;D
16:07:58 <dash> skew: this is pretty evil :)
16:12:32 <maihem> Regarding the power of lazyness. If I only take the head of the result of sort, can I expect to get it in O(n) time? Or is that an unreasonable burden on the implementation?
16:13:07 <skew> I think you get that
16:13:47 <skew> at least, lots of natural looking implementations should do that
16:14:41 <maihem> cool, and if I then took the second element, could I expect to get it in O(n-1) time or better? And if I apply a filter to the result to only pass elements > 0, could I expect them to be simply ignored in the original list, and not effect running time?
16:15:18 <maihem> Ie, it wouldn't be *worse* than O(n-1)
16:15:20 <skew> no, filting elements from the result won't save time
16:15:41 <maihem> I'd have to filter the input list?
16:15:43 <skew> at least, I don't think it will. I'm looking for a Random.shuffle to do some tests
16:16:38 <skew> Not that anything in the standard prevents a sufficiently intelligent compiler from optimizing that...
16:16:38 <maihem> I'm thinking that the implementation might be able to pull the filter up through the sort and apply it to the input list - which would allow the code to be structured better.
16:17:03 <skew> but read "impossibly" for "
16:17:07 <skew> "sufficiently"
16:17:43 <skew> to pull the filter through the compiler would need to be able to prove that sort and filter commute, and even worse, decide that's interesting to look at in the first place
16:17:58 <maihem> ah, skew - that's the main thing I'm looking for - is it reasonable (ie, calculating if an optimisation can be done is guaranteed to terminate in a polynomial time with respect to the complexity of my program)
16:18:44 <skew> I don't know if it's feasible. I'm pretty sure it hasn't been done. It might make a good PhD
16:20:49 <maihem> mainly, prove that sort outputs an element for each element of the input list, and that those elements have one or more counterparts in the original list. That shouldn't be difficult for a builtin sort impl since the library could be annotated to that effect.
16:20:55 <maihem> I suppose
16:21:19 <skew> nah, the hard part (if you want to make it at all general) is figuring out what properties are interesting to prove
16:21:39 <maihem> yeah, I agree for generality.
16:22:25 <maihem> If a haskell impl can do that sort of optimisation, I reckon it will compete with Ocaml and C for speed and core size.
16:47:46 <mast> skuggi: :D
16:48:06 <skuggi> mast: !!!!!
16:48:08 <shapr> hej mast 
16:48:14 <mast> hej :)
16:48:16 <skuggi> shapr: HEJ!!!:D:D:D
16:48:26 <skuggi> jag och mats r berusade =(((
16:48:39 <mast> va
16:48:45 <mast> nn
16:48:49 <shapr> heh
16:49:01 <shapr> in that case, why are you on IRC?
16:49:07 <skuggi> i dunno
16:49:16 <shapr> isn't it more fun to talk to real people when inebriated?
16:49:16 <skuggi> rounding off the night..
16:49:19 <mast> vi ska bara generera lite hga primtal
16:49:31 <skuggi> shapr: they've all gone to bed
16:49:34 <skuggi> mast: !!
16:49:59 <skuggi> nu ska jag ta och dricka lite vatten, s att jag inte blir s jvla bakfull imorrn
16:50:14 <shapr> yes, good idea
16:50:27 <mast> well... yes
16:50:32 <shapr> since a hangover usually comes from dehydration.
16:50:46 <mast> but... the high primes will always be there
16:50:49 <skuggi> shapr: right..
16:51:00 <skuggi> shapr: someone in #asm in reminded me of it
16:51:01 <shapr> swedish discussions usually happen on #haskell.se
16:51:10 <skuggi> mast: ofcourse..
16:51:27 <mast> may the primes be with you
16:51:28 <shapr> I don't drink much alcohol, so I make sure to drink water when I do... I'm not used to the pain.
16:52:05 * shapr kicks PLog
16:52:50 <mast> gm... welll
16:53:05 <shapr> I will fix this RSS code!
16:53:07 <mast> shapr: what's the highest prime you know?
16:53:15 <shapr> 4
16:53:18 <mast> oh
16:53:21 <mast> i know 7
16:53:26 * shapr snickers
16:53:30 <mast> SHIT
16:53:32 <bojohan> is this homework?
16:53:32 <mast> :/
16:53:34 <skuggi> that's not very higt :(
16:53:35 <mast> yes
16:53:39 <mast> :/
16:53:47 <mast> 977
16:53:48 <Pseudonym> 2^24036583-1 is pretty high
16:53:48 <mast> !
16:53:50 <skuggi> bojohan: no.. just some talk on the fylla!
16:53:51 <mast> oh
16:53:57 <skuggi> Pseudonym: quite
16:54:00 <mast> Pseudonym: you'r in teh lead
16:54:15 <Pseudonym> It's only 7.2 million digits long.  That's actually not that long.
16:54:33 <mast> no.. but's rather higher than 7
16:54:34 <mast> :/
16:55:01 <Pseudonym> @eval isPrime (2^24036583-1)
16:55:01 <lambdabot> (line 1, column 11):
16:55:01 <lambdabot> unexpected "^"
16:55:01 <lambdabot> expecting digit, operator, simple term or ")"
16:55:05 <Pseudonym> Damn.
16:55:42 <shapr> @eval 2^24036583-1
16:55:42 <lambdabot> (line 1, column 2):
16:55:42 <lambdabot> unexpected "^"
16:55:42 <lambdabot> expecting digit, operator, simple term or end of input
16:55:48 <shapr> @eval 2 ** (24036583-1)
16:55:49 <lambdabot> (line 1, column 4):
16:55:49 <lambdabot> unexpected "*"
16:55:49 <lambdabot> expecting simple term
16:55:52 * shapr shrugs
16:56:04 <Pseudonym> Parentheses in the wrong place.
16:56:15 <Pseudonym> Believe it or not, I know all of the prime factors of 2^(24036583-1)
16:57:12 <skuggi> that fucking but
16:57:17 <skuggi> bot*
16:57:20 <skuggi> it sucks
16:57:22 <mast> what
16:57:27 <shapr> skuggi: then fix it!
16:57:38 <skuggi> it cant even eval a simple thing like that! ;(((
16:57:41 <skuggi> shapr: i will!
16:57:46 <shapr> good idea!
16:57:46 <mast> skuggi fixes everything!
16:57:58 <mast> "as always"
16:58:03 <shapr> darcs get http://www.ScannedInAvian.org/repos/lambdabot
16:58:18 <skuggi> shapr: decode the brainwave matrix and encode it like "data f = 32 * f" that will do the trick
16:58:50 <shapr> if you submit cool patches, you get commit privs to the repo
16:59:32 <skuggi> right
16:59:48 <skuggi> i have no fucking idea what you're taling abouy
17:00:01 <shapr> the lambdabot darcs repo - http://www.scannedinavian.org/cgi-bin/darcs.cgi/lambdabot/lambdabot/?c=annotate
17:01:28 * shapr fights the code
17:02:18 <skuggi> fight the phuture!!!!!!!!!!!!!!!!!!!!!!!!1
17:02:29 <skuggi> WRSCH TEH PHUTURE!!!!!!!!!!!!!1
17:02:36 <mast> VRACH TEH PHUTURE
17:04:03 <skuggi> mast: !!!
17:04:09 <mast> skuggi: !!!
17:04:38 <skuggi> !!!!!!11111111111111
17:05:41 <mast> !11
17:05:49 <shapr> Pseudonym: tried Yi?
17:07:36 <mast> shapr: you like to be king in teh bar?
17:08:16 <shapr> huh?
17:08:35 <shapr> I don't usually go to bars.
17:08:52 <mast> no... we say the memory between 1 and 16 MB
17:09:02 <mast> that's quite sexy
17:09:20 <shapr> huh?
17:09:30 <mast> oh.... i didn't say anytinh :)
17:09:35 <mast> forget it :)
17:09:43 <mast> love you anyway
17:09:48 <shapr> thank you
17:09:53 * shapr hugs mast 
17:10:01 <mast> :D
17:11:19 <dons> anyone know where igloo's regex lib lives?
17:11:54 <Igloo> Will a darcs repo URL do?
17:11:59 <Igloo> Yes, of course it will, yi is in darcs
17:12:04 <dons> yes please :)
17:12:23 <Igloo> http://urchin.earth.li/darcs/ian/regexp
17:12:31 <dons> thank you
17:13:56 <Igloo> It should be cabal-friendly and do what you want unless you want fancy perl features
17:15:15 <Igloo> Bug reports etc welcomed  :-)
17:15:27 <dons> oh sure! I'll send them in :)
17:16:44 <shapr> Open source programming is the ultimate multiplayer game.
17:17:57 <Igloo> Oh, that reminds me, with the advent of cabal are we abandoning the user.email.address.backwards.* library hierarchiy scheme?
17:17:59 <shapr> Open Source Programming is the ultimate *massively multiplayer online game.*
17:18:22 <skuggi> shapr: i love you as well
17:18:30 <shapr> skuggi: thank you
17:18:41 * skuggi hugs shapr 
17:18:49 * shapr hugs skuggi 
17:18:55 <skuggi> :D
17:22:32 <maihem> I'm planning on writing a PNG library in Haskell. I wonder what is the best way to implement reading and parsing. Data tends to not be just unlimited length sequences of characters with specified delimiters, but have headers indicating the size of a section.
17:23:02 <skuggi> maihem: do it counte-clockwise!
17:23:52 <shapr> maihem: you could check out Pan and Pancito
17:23:59 <shapr> hi donnex 
17:25:00 <maihem> ah, excellent. thank you shapr
17:28:33 <Spark> heh binary formats
17:28:44 <mast> oh, for mats?
17:29:39 <shapr> hej donnex, vet du om #haskell.se oxa?
17:29:56 <mast> donnex: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!:FDDDDDDDDDDDDD
17:29:58 <mast> DONNEX
17:30:05 <skuggi> donnex r inge riktig haskellare :/
17:30:12 <skuggi> jag knner honom
17:30:18 <mast> MMmm
17:30:19 <skuggi> vi sp i lrdags tillsammans
17:31:00 <donnex> jag kan haskell jo
17:31:07 <bojohan> crazy chalmerists
17:31:08 <shapr> spiffy
17:31:14 <shapr> I like Haskell.
17:31:15 <donnex> funktionsanrop r framtiden
17:31:18 <shapr> I like Swedish too.
17:31:39 <shapr> gngga is my favorite swedish word so far.
17:32:01 <donnex> men nu ska jag titta p lite mer porr och tnka p haskell!
17:32:06 <mast> donnex: !!!
17:32:10 <mast> din knarkare
17:32:21 <donnex> oj vad nu!?
17:32:29 <mast> was
17:32:30 <skuggi> donnex: nog att du kan
17:32:36 <shapr> um
17:32:43 <donnex> skuggi: vad kan jag inte?!
17:32:45 <shapr> I don't think I've learned all those words yet.
17:33:00 <skuggi> donnex: haskell, du bara ltsas .(
17:33:00 <donnex> shapr: din mammas pappas far suger!
17:33:05 <shapr> psst guys, take the swedish to #haskell.se
17:33:27 <donnex> i am a l337 haskell hacker!
17:33:32 <shapr> cool!
17:33:35 <bojohan> shapr: good for you
17:33:59 <skuggi> donnex: i tried to explain it to you on saturday but you didn't understand.. you just ragged on the 7-eleven girls, and the vktare :(((
17:34:23 <donnex> :((
17:34:35 <donnex> i will dizz your mum skuggi !
17:34:59 <skuggi> no you will not! because you are too dlig and kass!
17:35:22 <shapr> d00d, swedish on #haskell.se
17:35:26 <skuggi> sorry
17:35:36 <skuggi> couldn't find the english words for it :(
17:35:42 <skuggi> too waste :(
17:35:47 <skuggi> +d
17:36:22 <shapr> don't drink and irc... you never know what you might say...
17:36:31 <shapr> hiya CosmicRay, how's code?
17:37:07 <CosmicRay> shapr: been a slow week for me
17:37:16 <skuggi> shapr: tru dat
17:37:22 <CosmicRay> shapr: actually, a very busy week, but slow haskell-wise.
17:37:22 <skuggi> shapr: but it's still much fun
17:38:09 <shapr> I only drink alcohol when I very much need to unstress, and I use irc to assist my coding, so I never really mix the two.
17:38:40 <shapr> CosmicRay: have you played with Flippi any? 
17:38:49 <CosmicRay> shapr: nope
17:39:03 <CosmicRay> shapr: not presently really having any need to host a wiki
17:39:18 <CosmicRay> shapr: though at some point I will look into the various web services stuff out there for haskell
17:39:18 <shapr> still fun to hack on...
17:39:35 <CosmicRay> eh, I don't get excited by web stuff
17:39:42 <shapr> speaking of which, I should ask Si\ about hws-wp
17:39:43 <CosmicRay> glad that other people do :-)
17:39:54 <shapr> there is webstuff worth getting excited about.
17:40:05 <shapr> you know fit.c2.com / fitnesse.org ?
17:40:34 <CosmicRay> never heard of it
17:40:46 <skuggi> shapr: too bad... it's great fun :D:D:D
17:40:47 <shapr> in a nutshell, unit tests + wiki
17:41:13 <CosmicRay> whew, microscopic fonts
17:41:20 <shapr> skuggi: I don't really enjoy drinking alcohol. Stimulants I do like.
17:41:23 <CosmicRay> this looks like about 4-point :-)
17:41:32 <CosmicRay> hmm that's an interesting idea
17:41:58 <skuggi> shapr: stimulants?
17:42:28 <shapr> caffeine, chocolate, energy drinks -  battery, red bull, etc
17:42:45 <shapr> CosmicRay: http://fit.c2.com/wiki.cgi?SimpleExample click on http:run.cgi near the bottom
17:42:55 <skuggi> shapr: ah..
17:43:02 <skuggi> shapr: that's good for coding :)
17:43:10 <shapr> yes, and good for thinking
17:43:54 <shapr> CosmicRay: anyway, I'm trying to hack up a simple implementation of that with Flippi
17:44:12 <skew> does anyone know of a nice linear algebra library for Haskell?
17:44:25 <shapr> I've thought about doing that with darcs.cgi somehow
17:44:58 <shapr> at least viewing "darcs test" results
17:45:00 <skew> I coded some neural network stuff in Python with numarray the other day
17:45:01 <CosmicRay> shapr: hmm
17:45:38 <CosmicRay> skew: http://www.google.com/search?q=haskell+linear+algebra&ie=UTF-8&oe=UTF-8
17:45:39 <skuggi> shapr: alcohol is good for the damp ;)
17:45:49 <skuggi> for having fun :D
17:45:53 <CosmicRay> skew: looks like hblas at least is a candidate for you
17:45:56 <CosmicRay> may be others too
17:46:09 <CosmicRay> never underestimate the power of the google
17:46:11 <shapr> I have less fun with alcohol.
17:47:04 <skew> I had a lot of trouble trying to figure out what order to evaluate everything for backpropagation
17:47:28 * shapr tries to remember how backprop works
17:47:43 <shapr> hm, least squares or something...
17:48:05 <skew> The time it finally worked I was almost frustrated enough to rewrite everything as an attribute grammer and let let lazy evaluation sort it out
17:48:14 <shapr> =)
17:48:47 <skew> you calculate the derivative of training error with respect to each of the network coefficients, then do some kind of gradient descent
17:49:26 <skew> you need to keep around the outputs from a forward pass to use when tracing the derivatives back
17:51:03 <skew> With strict evaluation the only connection between a forward pass and the backward pass are some array indices
17:54:19 * shapr grabl HBlas
17:56:24 <shapr> let's see if I can actually build HBlas...
17:56:41 <stepcut> shapr, dons, etc, I sent my keymap to post-emacs, if you are lucky, it might even get through
17:57:04 <shapr> hopefully my mail server actually works now =)
17:57:13 <shapr> hey skew, heard of post-emacs and the yi editor?
17:57:48 <skew> not much
17:58:00 <skew> I've heard in #haskell that yi is some sort of editor
18:00:27 <mast> *hugs*
18:00:47 <mast> (i think that's a bad one)
18:01:14 <skuggi> :(
18:02:14 <dons> stepcut: thanks. I'm working on a better keymap system to make writing emacs bindings easier right now
18:02:32 <Igloo> What's the plan now?
18:03:14 <dons> same overall design. except the keymap will explicitly be a table, that is passed around
18:03:22 <dons> rather than a function
18:04:17 <Igloo> Hmm, OK
18:04:18 <stepcut> dons: any ideas on how a user actually specifies the bindings?
18:04:57 <dons> how they add their own extra bindings?
18:05:42 <stepcut> in emacs you can do something like (set-global-key "C-c" "some-function"), but that means that there needs to be a mapping between a function and its name as a string
18:06:04 <stepcut> I am wondering how something like that might work in yi
18:06:05 <shapr> hs-plugins' eval?
18:06:11 <dons> that's one way
18:06:28 * shapr gives up on building HBlas
18:06:29 <dons> maybe there's a easier way just using a lookup table
18:07:16 <dons> but eval would work fairly simply, I think
18:07:16 <stepcut> in emacs, functions that can be bound to keys have to be specially declared
18:07:26 <shapr>  keymap :: FiniteMap (keymap | action) ?
18:07:27 <stepcut> (defun sgml-xhtml-mode ()
18:07:27 <stepcut>   "This version of html mode is just a wrapper around sgml mode."
18:07:27 <stepcut>   (interactive)
18:07:27 <stepcut>   (xml-mode) ... )
18:07:45 <dons> oh, so they get a help string too?
18:07:59 <stepcut> yes, that is part of the self documenting feature
18:08:04 <dons> sharp: that's where we're heading
18:08:05 <shapr> and per-args docs too
18:08:19 <dons> stepcut: wonder if we could use haddock docs for that
18:08:25 <shapr> oh that would be smooth
18:08:28 <stepcut> dons: hrm, that could be neat
18:08:50 <shapr> yes, that would be great!
18:09:12 <dons> yeah. sounds like a plan
18:09:14 <shapr> lambdabot's @index is a minor hack of haddock's index building code
18:09:27 <shapr> and I've had so many ideas for improvement =)
18:09:44 <dons> yep. @index is what I was thinking of too
18:09:44 <shapr> that would be perfect for an in-editor dynamic doc system
18:09:49 <stepcut> does hs-plugins have a way to add new functions without writing them to a file first ?
18:10:02 <stepcut> shapr said something about eval ?
18:10:04 <dons> eval. writes the module out for you
18:10:19 <dons> eval :: Typeable a => String -> IO (Maybe a)
18:10:42 <shapr> I wish ghc had Python's StringIO, then you don't even need a filesystem.
18:11:12 <dons> stepcut: http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-6.html#node_chap_5
18:11:43 <shapr> I wonder how to implement C-x C-e in Haskell...
18:11:53 <shapr> 'eval-last-sexp'
18:11:54 <Igloo> What is that?
18:12:06 <dons> what does it do?
18:12:19 <shapr> one cool thing about an emacs irc client is that you can execute code in an irc buffer
18:12:30 <bojohan> evaluates the preceding expression
18:12:36 <stepcut> shapr: heh
18:12:47 <shapr> if you have (setq gtk-version-string "whatever") and you put your point at the end and hit C-x C-e, it immediately executes.
18:13:03 <Igloo> So it needs the cursor to be on the closing ')'?
18:13:07 <shapr> yup
18:13:19 <bojohan> or somewhere after it
18:13:20 <Igloo> Hmm, that's tricky
18:13:29 <shapr> could just use a selected region
18:13:40 <dons> yeah
18:13:50 <Igloo> Or everything frmo the previous blank line to current cursor pos
18:14:00 <dons> seems doable
18:14:08 <shapr> you might have blank lines in a function
18:14:15 <Igloo> It's not a technical problem anyway, just a "what should it mean" one
18:14:20 <dons> yep
18:14:21 <shapr> you could say from the previous top-level def
18:14:25 <Igloo> Yeah, but if you do then you wouldn't use that  :-)
18:14:25 <shapr> right
18:14:53 <shapr> a real parser wouldn't have trouble with it anyway
18:14:59 <stepcut> ocaml mode has a few C-c C-e type bindings
18:15:06 <stepcut> might be a place to look for inspiration
18:15:36 <dons> oh. good idea
18:15:46 <Igloo> I think it'd be a bit easier in ocaml as it uses "and" to join declarations IIRC
18:16:06 <Igloo> And ;; after each statement for that matter
18:16:19 <shapr> one reason I'd like to switch to SILCnet is for MIME messages.
18:16:21 <stepcut> the ;; are optional in .ml files
18:16:29 <Igloo> Ah, OK
18:16:44 <shapr> too bad irc can't send mime messages
18:20:27 <stepcut> ok, i am going home now
18:20:36 <shapr> I'm going to sleep.
18:21:20 <stepcut> try to dream up some good ways to do the emacs-like dynamic keybinding/documentation stuff while you sleep
18:21:23 <stepcut> @shapr
18:21:23 <lambdabot> Sorry, I don't know the command "shapr", try "lambdabot: @listcommands"
18:21:25 <stepcut> :p
18:22:05 <shapr> well
18:22:06 <shapr> hmm
18:22:20 <shapr> could be hard to do...
18:22:22 <shapr> or maybe not...
18:23:19 <shapr> I'm sure it's just my lack of sleep and general addiction to arrows, but I wonder if function name and docs would be interesting static properties worth lifting pure functions into an arrow
18:23:30 * shapr chortles sleepily
18:26:04 <bojohan> how are commands represented?
18:26:42 <skuggi> in bytes
21:05:21 <Lemmih> Grr stupid Apache!
21:11:47 <blackdog_> dons: around? I want some lsd code... :)
21:12:17 <Pseudonym> Woah, dude.  Must be all the Lisp I did in the 60s.
21:14:21 <blackdog_> just never closed that final bracket... the real world's waiting out there somewhere
23:33:00 <dons> here's some fun. get all of the key stroke input to yi lazily:
23:33:01 <dons> lazyRead = unsafeInterleaveIO $ do
23:33:01 <dons>                 c  <- getcE
23:33:01 <dons>                 cs <- lazyRead
23:33:02 <dons>                 return (c : cs)
23:33:26 <dons> then the key maps can use String pattern matching
