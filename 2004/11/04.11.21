01:24:42 <ned> xerox: shapr: i see that you talked about my GoOnCube :)
01:25:00 <ned> xerox: i'm working on a second version
01:25:20 <ned> xerox: http://nm.nerim.net/goCube2.0.hs
01:31:15 <ned> xerox: and i'm some times on kgs, if you want to play :)
01:48:25 <tromp> hello ned
01:53:23 <ned> hello
02:01:14 <tromp> nice to see go players here:)
02:14:04 <ned> hehe :)
02:14:12 <ned> you're on kgs too ?
02:14:21 <ned> we can make a haskell room :)
02:17:18 <rhw> What kind of projects would be better to code in Haskell than other programming languages ?
02:17:39 <Lor> Compilers.
02:17:45 <tromp> i'm an admin there
02:18:34 <tromp> trying to get your go program to work, but can't get greencard running
02:18:40 <Lor> Bah, there are no Free kgs clients? Just the cgoban2 jar?
02:19:03 * esap uses igs.
02:19:11 <tromp> i use webstart for KGS
02:19:42 <tromp> i can only use igs as a guest
02:31:00 <xkb> kgs?
02:31:12 <xkb> ah go software?
02:40:22 <tromp> kgs is a go server. you can connect with an applet, with webstart, or with a jar
02:41:53 <xerox> go go go go
02:59:28 <Lunar^> ned: Do you have a ZZstructure implementation in Haskell, finally?
02:59:36 <dd__> Is there some shortcut for toInteger and fromIntegral? I'm ending up with stuff like this: xor (toInteger n) (toInteger m) -- where n and m are Nums -- and this: fromIntegral (length s) / 2
03:02:00 <wilx> You can define your own short for it :)
03:02:11 <shapr> good morning #haskell!
03:02:22 <flodin> morning shapr
03:02:25 <Lor> There's List.genericLength
03:02:29 <Lunar^> shapr: morning :)
03:02:47 <Lor> But it seems pretty uncommon to want to xor something that is not an instance of Bits.
03:04:11 <dd__> How do I even get an instance of Bits? I have Ints and Nums so far, and I'll have Chars shortly
03:04:41 * shapr boings cheerfully
03:04:55 <wilx> I bet you can find it in the documentation :)
03:05:19 <shapr> One thing I like about waking up early is that I can sing and the neighbors just have to live with it.
03:05:27 <shapr> good code going on today?
03:07:57 <wilx> Hmm...
03:08:52 <shapr> rhw: compilers, interpreters, logic, programs for teaching, anything that needs lots of abstraction.
03:14:27 <tromp> has anyone got greencard to work?
03:14:41 <shapr> I've gotten it to work on debian/unstable.
03:14:54 <tromp> by rpm or source?
03:14:59 <tromp> uhm, right
03:14:59 <shapr> source I think
03:15:08 <tromp> my compile failed
03:15:15 <shapr> What was the problem?
03:15:20 <tromp> ghc-6.2.1: unrecognised flags: -fno-prune-tydecls
03:15:31 <shapr> oh, I just whacked that flag.
03:15:35 <Lemmih> I just deleted that flag.
03:15:47 <shapr> seemed to work.
03:15:55 <tromp> which version did u compile? 3-01?
03:16:10 <shapr> whatever is the latest.
03:16:25 <xerox> 'morning
03:16:32 <shapr> hiya xerox 
03:17:46 <tromp>     Failed to load interface for `Prelude':
03:17:51 <tromp>         Could not find interface file for `Prelude'
03:18:14 <tromp>     Failed to load interface for `Foreign':
03:18:17 <tromp>     Failed to load interface for `Foreign.C':
03:18:27 <shapr> I think I fixed that too, but I don't remember how.
03:18:56 <tromp> so not exactly a smooth install:(
03:19:06 <shapr> nope
03:19:46 <tromp> do you still have your fixed Makefiles ?
03:19:53 * shapr looks
03:20:04 <shapr> greetings derelm, looking for Haskell info?
03:20:32 <derelm> hi everyone
03:20:59 <Lemmih> Hey derelm
03:21:19 <shapr> tromp: I have gc 3.01 installed, so I must have gotten it to work...
03:22:03 <tromp> hope you didn't remove the installation files
03:22:06 <derelm> this is rather a stupid question, as i seem to have found the answer, filter needs a function that returns a bool, right? :)
03:22:16 <tromp> yep, a predicate
03:22:20 <tromp> (a -> Bool)
03:22:21 <Lemmih> @type filter
03:22:26 <Lor> gc?
03:22:30 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
03:22:30 <shapr> greencard
03:22:31 <tromp> greencard
03:22:37 <Lor> Ah, right.
03:22:47 <Lemmih> Man, lambdabot is getting slow.
03:22:54 <shapr> lambdabot is slow because I'm upgrading ScannedInAvian
03:23:53 <Lemmih> What a lovely sunny day. I better go unicycle before it starts snowing again.
03:24:05 <shapr> yes, same here!
03:24:14 <shapr> it's -20Â°C and the sun is shining brightly!
03:25:13 <shapr> tromp: I can't find my fixed files. But I'll help you install it after I come back from unicycling.
03:25:53 <Lemmih> shapr: Are you good at jumping? Like can you jump far? I can't seem to make any progress at all in that field.
03:26:06 <shapr> I can't jump far, no.
03:26:18 <Maddas> heh.
03:26:21 <shapr> and it's hard to practice when there's a bunch of snow and ice.
03:26:44 <tromp> enjoy the ride! ps, i'll prolly be gone by then:(
03:26:49 <shapr> :-(
03:26:55 <shapr> ok, time for uni...
03:26:58 * shapr disappears
03:27:30 <Lemmih> tromp: I don't recall to meet any other errors than the -fno-prune-tydecls flag.
03:40:13 <derelm> i have a rather simple function, still i don't know why it fails "g zahl = if (even zahl) then zahl/2 else zahl-1" entering g 4 will create a warning/error... but why?
03:41:46 <Lor> Because it loops infinitely.
03:42:30 <derelm> why?
03:42:37 <Lor> Well, where would it end?
03:43:03 <Lemmih> When zahl is not even?
03:43:18 <Lemmih> Or when it's even. (-:
03:43:19 <Maddas> huh?
03:43:21 <derelm> i enter a number it gets checked if it is even and then either then number will be divided by 2 or it'll be decreased by one
03:43:25 <Maddas> Yes :)
03:43:46 <derelm> or am i wrong?
03:43:55 <Lor> Ah, sorry, I misread it. Do you get an error about an ambiguous type?
03:43:59 <tromp> u never stop recursing
03:44:03 <derelm> yes
03:44:15 <Lemmih> derelm: There are many types of numbers. You have to specify which type you want to use.
03:44:16 <tromp> instead of /2 try `div` 2
03:44:39 <Lor> It's pretty hard to find a type that's an instance of both Fractional and Integral. :)
03:44:45 <tromp> @index (/)
03:44:46 <lambdabot> bzzt
03:44:51 <derelm> Lemmih: err, i don't know how it would make a difference
03:44:52 <Lemmih> Lor: But it's not impossible (-:
03:44:54 <Maddas> @type (/)
03:44:57 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
03:45:05 <tromp> @type div
03:45:07 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
03:46:00 <derelm> i am sorry, i am really new to haskell ... so still i don't know why it doesn't work and what to chage to make it work
03:46:30 <Lor> derelm, do what tromp said.
03:46:46 <derelm> using  div instead of /
03:47:02 <bourbaki> hi
03:47:05 <Lemmih> Hey bourbaki
03:49:29 <musasabi> morning
03:55:27 <bourbaki> hi TheHunter 
04:00:31 <derelm> argh, i need to create a function that applies a function to a given list and afterwards compares it to the source-liste (the argument) if both are the same break, else keep on appling the function
04:00:38 <derelm> and i am rather clueless
04:01:09 <derelm> so basically i'll have to use map
04:01:31 <derelm> but how can i compare source and "working" list?
04:02:03 <TheHunter> hiya bourbaki 
04:07:48 <musasabi> a quick (and inefficient) solution would be, mapEqs fun lst = map fst $ takeWhile (==) $ zip lst (map fun lst)
04:08:14 <musasabi> that need curry too.
04:09:00 <derelm> would that do the same as : test x y = if x /= map (y) x then test x (y) else True
04:09:06 <derelm> which is my first solution?
04:10:31 <derelm> musasabi: arghs, i hardly can understand your solution, that'll take some time to understand
04:10:37 <musasabi> so you want to test whether the function is identity for all map elements?
04:10:51 <musasabi> (it seems I am understanding your questions a little bit off)
04:11:05 <derelm> well sorry, i try to explain it
04:12:07 <derelm> i have a function taking to arguments, one a liste (e.g. [1..99]) the other argument is a function of my choice that makes changes to the list (maybe) (e.g abs)
04:13:17 <derelm> now my fununction should compare the "original" list with the functions (second argument) result of the list 
04:13:42 <derelm> if they are same, break, we're done
04:14:10 <derelm> if they differ keep on using the second arguments function on the list
04:15:03 <musasabi> I would do that with explicit recursion myself.
04:16:07 <derelm> err
04:16:11 <derelm> ?
04:16:36 <musasabi> ls []     _ = []
04:16:36 <musasabi> ls (x:xs) f = let x' = f x in if x == x' then x:xs else x':ls xs f
04:23:23 <Lor> ls l f = let (a,b) = span (uncurry (/=)) (zip (map f l) l) in map fst a ++ b
04:23:43 <Lor> Not sure if that's a very sensible way of doing it.
04:24:08 <Lor> ... ++ map snd b
04:25:20 <Lor> Or, if you don't mind recomputation:
04:25:21 <Lor> ls l f = let (a,b) = span (\x -> f x /= x) in map f a ++ b
04:28:14 <Lemmih> sun + snow = ice, ice + unicycle = pain.
04:28:28 <musasabi> but isn't that less readable?
04:28:59 <Maddas> Lemmih: Ouch :)
04:29:11 <musasabi> here it is about 15cm powder snow and sunshine.. very nice to be outside (-5C is quite ideal too)
04:29:14 <musasabi> .c
04:29:50 <Lor> As I said, I'm not sure if my way is very sensible. :)
04:37:59 <shapr> ow ow oww, my toes are coming back to life.
04:38:33 <shapr> Lemmih: do you have a unicycle blog?
04:39:01 <shapr> Lemmih: I can almost one-foot, and my rolling hop is getting better. I can almost do seat-forward too.
04:39:21 <Lemmih> seat-forward?
04:39:51 <shapr> you stand up, pull the seat out in front of you, and hold the seat in front of you, or hold it to your stomach while you go.
04:40:20 <shapr> Feels weird at first, I can only do one revolution that way before I fall off.
04:47:08 * shapr slowly defrosts
05:13:43 <TheHunter> ok, i'm gonna do it. Wipe windows off my hard drive (3 GB are an awful lot for an OS I haven't used in a year).
05:13:58 * TheHunter types rm -R i386 windows Programme
06:51:42 * shapr boings cheerfully
06:58:22 <vegai> shapr: hey
06:58:38 <shapr> heipaa hei!
06:58:52 <vegai> shapr: yi tarvitsee melko uuden hs-plugins'n, eikö?
06:58:59 <shapr> aiee
06:59:15 <shapr> man, you gotta switch to UTF-8
06:59:17 <vegai> shapr: yi requires a rather recent hs-plugins, doesn't it?
06:59:24 <vegai> yeah, perhaps
06:59:25 <shapr> yes
06:59:29 <shapr> to both
06:59:31 <shapr> nightly
06:59:43 <shapr> uuden - new?
06:59:49 <shapr> tarvitsen - need
06:59:53 * shapr slowly works through it
07:00:04 <shapr> melko - much
07:00:26 <vegai> sorry for using idiomatic expressions :-P
07:01:16 <shapr> doesn't make much of a difference...
07:01:18 <vegai> hmm, I wonder what I meant by that
07:01:39 <shapr> you need the hs-plugins nightly to get :reboot to work.
07:02:11 <np_hard> TheHunter: purged now?
07:02:22 <vegai> shapr: would it compile with something less recent?
07:02:30 <shapr> don't think so
07:02:39 <shapr> but it's easy enough to build the nightly
07:05:06 <vegai> have you considered decoupling an irclib or something from lambdabot?
07:05:36 <vegai> (damn, where _is_ hs-plugins)
07:05:56 <vegai> ah, there
07:06:02 <TheHunter> np_hard, yep it was a matter of a few seconds.
07:06:56 <TheHunter> feels good (though i've paid a lot of money for that stupid windoze)
07:11:48 <np_hard> I have a Mac
07:11:56 <np_hard> and a homebuilt FreeBSD machine
07:12:00 <shapr> vegai: truly, an irclib would be sensible.
07:12:05 <np_hard> so I don't really pay the MS tax
07:14:18 <shapr> vegai: you want to hack it out and send me patches? =)
07:18:53 <vegai> I *want* to
07:19:10 <vegai> but I'm wary about promising much at this point
07:19:13 <shapr> send me your GPG key, I'll give you commit privs on the lambdabot darcs repo.
07:19:29 <shapr> then you can just send in any changes you make.
07:21:00 <vegai> ok
08:16:40 * shapr grumbles
08:17:51 <shapr> BLob needs [XmlRpc,HaskellDB] HaskellDB needs HSQL, XmlRpc needs HaXML...
08:26:54 <shapr> gwahr!
08:30:18 <xerox> i understood quicksort in haskell!
08:30:24 <xerox> not so much work in fact :P
08:30:33 <shapr> yay!
08:30:45 * xerox & haskell - part
08:30:46 <xerox> 1
08:30:52 <shapr> Once you understand haskell, algorithms start to look a lot easier.
08:31:14 <xerox> is there a big difference betwreen haskell and erlang ?
08:31:37 <shapr> Yeah, I think so.
08:31:50 <shapr> They're closer to each other than they are to C or Java, but they're still not that similar.
08:31:50 <xerox> okie :)
08:32:08 <xerox> that is more or less what i thought
08:32:28 <shapr> erlang has some *very* cool features.
08:32:29 <Lor> quicksort in haskell is a pretty silly example.
08:32:43 <xerox> Lor don't say that :)
08:32:51 <xerox> shapr like?
08:33:03 <shapr> just a moment...
08:34:04 <Lor> Some of erlang's features feel too specialized.
08:34:44 <shapr> Erlang is the ultimate p2p programming language. You can build software that is distributed across multiple computers. If you build that software correctly, then computers can drop out and get added to the set of those running the software, and it works just fine.
08:35:16 <Riastradh> I'd not say 'the ultimate p2p programming language.'
08:35:24 <Riastradh> E is 'right up there,' too.
08:35:49 <shapr> ok, fair enough.
08:36:13 <shapr> But, erlang doesn't do static compilation. And it doesn't have much of a type system at all.
08:36:29 <shapr> E is really nifty, but its only implementation requires the JVM.
08:36:35 <Riastradh> Erlang doesn't do static compilation?  What do you mean?
08:36:46 <wilx> JVM?
08:36:52 <shapr> java virtual machine
08:36:53 <wilx> I think that they have their own VM.
08:37:04 <shapr> there's a real E implementation now?
08:37:06 * shapr looks
08:37:09 <shapr> Riastradh: correct me!
08:37:26 * Riastradh corrects shapr.
08:37:27 <Riastradh> Happy?
08:37:32 <shapr> I thought that Erlang was bytecode only.
08:37:37 <tuomov> what's E? enlightenment?-)
08:37:42 <shapr> nah, erights.org
08:37:43 <wilx> Iirc it is.
08:37:45 <Riastradh> E is a programming language.
08:37:46 <wilx> But not on JVM.
08:37:47 <shapr> capability security.
08:38:04 <xerox> back
08:38:07 <xerox> let me read
08:38:14 <shapr> salut jyp
08:38:18 <Riastradh> shapr, compilation to byte code still counts as 'static compilation.'
08:38:20 <jyp> hey
08:38:31 <shapr> Riastradh: ok. What about Erlang's type system?
08:38:44 <Riastradh> wilx, shapr is saying that E, not Erlang, has only one implementation, built on the JVM.
08:39:01 <wilx> Oh!
08:39:10 <Riastradh> It doesn't have a static type system, but there is still a type system.
08:39:11 <wilx> Well, what is the difference between E an Erlang?
08:39:20 <wilx> I thought E means Erlang.
08:39:23 <Riastradh> wilx, uh, what's the difference between C & Java?
08:39:29 <Riastradh> They're two entirely different programming languages.
08:39:36 <wilx> I see.
08:39:47 <shapr> E is something else entirely. read http://erights.org/
08:39:47 <Riastradh> Notice the difference between erlang.org & erights.org.
08:44:36 <shapr> hey, silly question...
08:44:45 <shapr> How could you make a design by contract monad?
08:45:04 <shapr> The only way I could find was to make a separate monad transformer for each separate set of conditions.
08:45:09 <shapr> But that can't be right.
08:45:53 <shapr> Any ideas?
08:46:02 <shapr> Maybe I should ask the scary Oleg.
08:46:22 <jyp> I'll say ;)
08:46:38 <shapr> Has anyone here actually met Oleg Kiselyov?
08:46:53 * shapr wonders if that's how his name is spelled.
08:47:10 <shapr> hiya gpciceri 
08:47:50 <gpciceri> hello sh
08:47:52 <gpciceri> hello shapr
08:48:25 * shapr boings cheerfully
08:48:46 <shapr> There must be an easier way to make a design by contract monad.
08:52:53 <Riastradh> I've met him.
08:53:19 <Riastradh> I believe you've spelled his name correctly, too.
08:53:38 <Riastradh> Although he rarely puts his last name, if any part of his name at all, on anything.
08:54:22 <Oejet_> Greetings.
08:54:25 <Riastradh> Hi.
08:54:27 <shapr> hiya Oejet_ 
08:54:29 <xerox> Hello
08:54:45 <shapr> Guten abend svens. How's code?
08:55:25 <xerox> is it japanese?
08:55:35 <svens> hi shapr
08:55:37 <shapr> Is what japanese?
08:55:52 <svens> sounds like german. :)
08:55:59 <xerox> dunno :)
08:56:33 <shapr> Guten abend is german for good afternoon.
08:56:54 <Oejet_> That is good evening.
08:57:13 <shapr> close enough :-)
08:58:33 * xerox wants to learn japanese
08:59:29 * shrimpx too
09:00:10 <xerox> then go to japan, play go all day long, getting payed for doing it
09:00:17 <xerox> </dream>
09:00:52 <shrimpx> i have a friend who did that. he got american university to send him there for a year
09:01:18 <xerox> lucky boy.
09:01:49 <Oejet_> Any of you know some online language "tutorials"/classes?
09:02:14 <shapr> for what language?
09:03:10 <Oejet_> Russian and Japanese.
09:04:59 <jyp> Anyone know tutorials for Cantonese?
09:05:22 <wilx> Can you really learn a human language without a tutor?
09:06:14 <jyp> You can learn to read/write it; it not to speak/write it
09:06:31 <jyp> s/; it/; if
09:06:36 <Oejet_> wilx: It will be hard, but what if that tutor is only seldom available and/or has a limited patience? :-)
09:06:45 <wilx> :)
09:07:22 * jyp should learn to type correctly in the first place
09:19:46 <dash> Crud
09:20:01 <dash> @type foldr
09:20:02 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
09:20:23 <dash> why does it gotta be a->b->b
09:21:05 <dash> i thought i could do (foldr Pair nil items) to get a nice representation of conses
09:21:48 <Riastradh> Where Pair & nil are what?
09:22:28 <dash> Pair is a constructor for the type Val, nil is a different Val
09:22:38 <dash> wait no
09:23:27 <dash> that's right, it isn't. it's a Loc, the address of the nil object; Pair has two Loc fields and 'items' is a list of addresses
09:23:49 <Riastradh> What are their types?
09:24:39 <dash> (Pair :: Loc->Loc->Val), (nil :: Loc), (items, :: [Loc])
09:25:20 <Lor> Right. You need something to convert a Val to a Loc.
09:25:22 <Lor> I.e. to allocate storage.
09:25:39 <dash> yeah, got that
09:25:50 <dash> oh, duh
09:25:55 <Lor> That probably involves some monad, so maybe you ought to use foldM.
09:25:55 <dash> i'm not allocating each cons
09:27:53 <dash> somehow i missed that, thanks ;)
09:28:07 <Riastradh> ...what are you writing?
09:28:45 <Lor> Looks like an interpreter or compiler for a scheme/ml-like language.
09:30:07 <dash> yep
09:30:16 <dash> experimental lisp interpreter.
09:31:52 <dash> right now i am just warming up with basic lisp stuff but i'm going to add linear objects to it
09:33:26 <dash> because as far as I know, no one's ever written such a thing, despite the various papers produced on the topic
09:34:28 <Lor> What are linear objects?
09:35:07 <dash> linear objects have a reference count that is always 1
09:35:35 <dash> thus they can be mutated without side effects and can be allocated and deallocated safely without GC
09:35:53 <Lor> You intend to achieve this with run-time checks?
09:36:07 <dash> Mmmm, possibly some runtime checks
09:36:17 <dash> I believe a large amount of it can be checked statically though.
09:36:27 <Lor> Uh, we are talking about _lisp_ here.
09:36:30 <dash> Sure.
09:37:07 <dash> I suspect that static linearity checking won't interfere with the flexibility of dynamic type checking
09:37:08 <Lor> So you want to do static linearity analysis, but not static type analysis?
09:37:11 <dash> Yeah.
09:37:43 <Lor> But isn't linearity a property of a type?
09:37:53 <dash> You could look at it that way, sure.
09:38:38 <Lor> If you have higher-order functions, you have to know statically how callbacks treat their arguments.
09:39:10 <dash> Mmmm. good point
09:39:25 <dash> well, like i said, it's an experiment. ;)
09:39:56 <dash> I don't think I'll be able to get away with only static checking
09:40:17 <dash> function calls would be the obvious place that runtime checks would be required.
09:40:50 <Lor> Even then, could you notice an error before there is an actual duplicate reference?
09:41:31 <dash> A good question. I don't know.
09:42:52 <Lor> I think you will end up with something like a contract system.
09:43:03 <dash> http://home.pipeline.com/~hbaker1/Use1Var.html <-- the main paper i'm working from 
09:43:04 <Riastradh> dash, you don't think Alan Bawden has done anything in this regard?
09:43:17 <dash> Riastradh: I know he has
09:43:25 <dash> Riastradh: but I haven't seen any of his code
09:44:43 <dash> Lor: well, my current thinking is that static analysis will suffice to check if a linear variable is used more than once in a function 
09:45:58 <dash> Lor: and then the only dynamic check you'd have to make is whether a function's lambda list expects a linear or shared variable
09:46:39 <dash> i think it makes sense to allow shared objects to be bound to linear parameters, but to prevent linear objects from being bound to shared parameters
09:46:45 <Lor> And you'd encode that as a tag in the closure itself?
09:46:50 <dash> right
09:47:05 <dash> (defun foo (x (linear y) z) ...)
09:47:35 <Lor> shared objects to be bound to linear parameters?
09:47:59 <Lor> Uh, isn't the point that a linear parameter can be treated as "owned" by the one using it, so it can then be mutated destructively?
09:48:37 <Lor> Certainly it is not safe to give a shared object as an argument to someone who will then mutate it.
09:49:42 <dash> sure, but that's not a major concern yet AFAICT
09:49:54 <dash> i may find out differently :)
09:50:32 <dash> hmm
09:50:37 <dash> but yes, i do see the problem 
09:51:10 <dash> so. linear variables for linear objects, shared variables for shared objects
09:59:05 <xerox> how to do quit ghci from inside it?
09:59:17 <vegai> ctrl+d?
09:59:25 <vegai> oh, you meant..
09:59:41 <xerox> C-c C-d worked (eshell->ghci)
09:59:43 <xerox> thanks
10:22:20 <shapr> hej hram 
10:23:34 <shapr> dash: have you seen the pic of hbaker on his unicycle?
10:24:11 <tromp> i saw a picture of a 35m tall unicycle
10:24:22 <shapr> Si\: hey, is the hws-wp in haskell-libs the latest and greatest?
10:25:06 <Si\> probably
10:25:11 <shapr> :-)
10:25:15 <shapr> I like that answer.
10:25:19 <Si\> I'm putting together a HTTP Server from scratch anyway
10:25:21 <shapr> flippo: y0 y0
10:25:24 <shapr> Si\: oh really?
10:25:28 <Si\> HWS-WP is way too deprecated
10:25:37 <shapr> yah, it's pretty fuzzy.
10:25:47 <shapr> hws itself needs a lot of cleanups.
10:26:18 <tromp> do u have time to waste on greencard, shapr?
10:26:23 <shapr> is your server source online?
10:26:30 <Si\> I've written a basic server using Network.HTTP as a basis
10:26:32 <shapr> tromp: not at this moment, no. I'm about to do some editing.
10:26:44 <tromp> ok:)
10:26:48 <shapr> but I'll be back after I've checked these translations.
10:26:50 <Si\> doesn't do anything, but handles all the types of HTTP requests that the client library can
10:27:24 <shapr> I'm gathering components for a serious haskell web app server.
10:27:52 <dash> shapr: I have not seen that picture
10:27:52 <shapr> Someone is already working on one, least I can do is give pointers to the best code I can find for that purpose.
10:28:01 <dash> he can't be all bad if he can ride a unicycle, eh?
10:28:19 <jadrian> hello
10:28:22 <Si\> I'm currently engaged in a project to produce a process algebra based Web-Service interaction model in Haskell
10:28:47 <shapr> dash: http://home.pipeline.com/~hbaker1/gratuitous.html
10:29:02 <shapr> anyway, I'm off to edit..
10:29:11 <dash> Hah, that must be new
10:30:09 <jadrian> anyone familiar with the listings package, for literate programming?
10:36:15 <Nioate> what's the best way to coerce a Num to a Floating?
10:44:36 <jadrian> realToFrac ?
10:45:40 <jadrian> wouldn't work for all Nums though...
10:46:31 <jadrian> hmm ignore my sugestion...
10:56:00 <palomer> viva la baskell
10:57:57 <Cale> won't be possible in general. If it's integral, you can do fromIntegral, and then apply any Floating function to it.
10:58:13 <Cale> Num allows for things with no obvious conversion to Floating.
10:58:45 <bourbaki_> is there any free shell with haskell on it?
11:12:29 <themaximus> brb.
11:19:32 <musasabi> ghc takes ages to recompile :-(
11:29:01 <Maddas> dash: Linear Lisp sounds cool
11:58:47 <bourbaki_> when i build my own binary infix functions how can i take influence on the priority of execution?
12:02:22 <palomer> bourbaki_, do you mean precedence?
12:03:16 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.4.2
12:04:29 <bourbaki_> thanks and palomer i think yes :)
13:23:18 <Boegel> hello #haskell
13:25:08 <Nioate> hi
13:26:51 <edi> hello
13:30:01 <jeff2> array ((1,1),(2,2)) [((1,1),1),((1,2),1),((2,1),1),((2,2),3)] <- is there a more readable way to print matrices than this?
13:30:27 <edi> i hope so ^__^
13:31:10 <jeff2> even something like [[1,1],[1,2]] would be preferable
13:32:51 <edi> dunno really.
13:34:44 <jeff2> hm
13:35:31 <norpan> jeff2: use listArray instead
13:35:35 <Igloo> You can write a function to print them out any way you like
13:36:03 <norpan> listArray ((1,1),(2,2)) [1,1,1,3]
13:36:16 <Igloo> He's talking about printing, not construction
13:36:40 <norpan> it looked like he was talking about construction though
13:37:00 <norpan> printing is no problem, just print them any way you like
13:37:19 <Igloo> The above is what the Show instance will give you IIRC
13:37:22 <jeff2> listArray might be easier to deal with, ill look into iit
13:37:49 <norpan> Igloo: ah
13:41:59 <jeff2> so basically an n-dimensional array is a list of pairs of indices and elements
13:42:25 <jeff2> interesting
13:50:27 <Igloo> It's not really an n-dimensional array. It's a 1-d array where the offsets are commonly calculated from n-tuples
13:52:24 <jeff2> Igloo: would [(0,[(0,00),(1,01)]),(1,[(0,10),(1,11)])] (for example) be considered a 2d array?
13:52:38 <jeff2> rather
13:53:24 <jeff2> listArray (0,1) [listArray(0,1) [00,01], listArray(0,1) [10,11]]
13:54:34 <Igloo> Ermm, if you think you want a 2D array you probably do what what you had originally
13:54:54 <jeff2> ok
13:56:19 <jeff2> both seem to work, one uses a!(x,y) to access elements, the other a!x!y
14:05:54 * jadrian had bad experiences with arrays performence-wise...
14:06:10 <jadrian> is Manuel Ch. still working on fast arrays for haskell?
14:06:42 <jadrian> he was working on them a few years ago, but there are no updates in his homepage
14:08:34 <palomer> how fast?
14:11:15 <jadrian> I don't remember the details, but it was quite fast :)
14:12:58 <jadrian> palomer: http://www.cse.unsw.edu.au/~chak/papers/CK03.html
14:16:22 <GreatQ> 4,1|0,2G0,4Q4,1|0,0,2,2,04,02che loco habla alguien aca?2,2,0,0.4,1|0,4G0,2Q4,1|
14:16:23 <GreatQ> 4,1|0,2G0,4Q4,1|0,0,2,2,04,02..2,2,0,0.4,1|0,4G0,2Q4,1|
14:16:41 <edi> what's going on?
14:16:47 <Lemmih> Please don't use colors, GreatQ.
14:16:48 <Pseudonym> Hey!  Stop trying to hack my IRC client!
14:17:02 <GreatQ> ..
14:17:12 <GreatQ> alguno habla castellano?
14:17:17 <jadrian> no
14:17:23 <GreatQ> ah bien
14:17:24 <GreatQ> ..
14:17:37 <jadrian> castellano es muy complicado
14:17:56 <GreatQ> jaa
14:18:17 <Pseudonym> Mi ne komprenas.  Cxu vi parolan Esperanton?
14:18:30 <jadrian> Nice
14:18:41 <jadrian> I don't know esperanto but seems easy to understand
14:19:04 <GreatQ> queria preguntar algo =\ porque en el haskell me aparece un error y no se porque....... Syntax error in type expression (unexpected comma)
14:19:09 <Pseudonym> It's not too bad.  There are one or two gotchas.
14:19:17 <jyp> check this out: http://www.interlingua.com/
14:19:41 <jadrian> Pseudonym: one is that you can't really go to some country and practice it
14:19:55 <Pseudonym> It depends.
14:20:04 <jadrian> GreatQ: mostra la expression? 
14:20:06 <Pseudonym> If you speak Esperanto, you never want for a place to stay wherever you travel.
14:20:11 <Pseudonym> Not that I've tried.
14:20:30 <Pseudonym> People are apparently so desperate to practice that they let you stay.
14:20:34 <GreatQ> jadrian m? a ver..
14:20:51 <tuomov> esperanto would be cool to learn..
14:21:02 <GreatQ> repartir::[(Int,Char)]->[String]->Int->[String,[(Char,Int)]]
14:21:04 <GreatQ> ahi creo que es el error
14:21:08 <tuomov> hmm.. I wonder if there's some #let's-speak-esperanto channel
14:21:09 <jadrian> Pseudonym: right :)
14:21:36 <jadrian> I've heard it is a nice basis for learning other languages
14:21:36 <jyp> repartir::[(Int,Char)]->[String]->Int->[(String,[(Char,Int)])]
14:21:42 <Riastradh> How about just #esperanto, tuomov?
14:21:54 <tuomov> maybe, haven't tried
14:21:58 <GreatQ> aaaaaaaaaaaaaah
14:21:59 <jyp> GreatQ: ( ) were missing
14:22:04 <GreatQ> =P
14:22:06 <tuomov> seems to exist at least
14:22:33 <Pseudonym> OK, this is bizarre.  Their topic: Ne krokodilu sen motivo. Dankon.
14:22:42 <Pseudonym> Translation: No crocodiles without reason.  Thanks.
14:22:59 <GreatQ> jyp gracias capo
14:23:01 <Pseudonym> Actually, it's "Do not crocodile without reason.  Thanks."
14:23:11 <jadrian> do you know about http://www.mylanguageexchange.com
14:23:11 * Pseudonym shrugs
14:23:24 <jyp> GreatQ: no problem ;)
14:23:30 <Pseudonym> Nope.
14:23:38 <jadrian> you can use it to find people to practice languages with
14:24:27 <Pseudonym> Cool.
14:30:25 <palomer> god I hate debugging
14:30:39 <Pseudonym> So prove your programs correct.
14:30:58 * Riastradh quotes Knuth aptly.
14:31:03 <tuomov> and debug your proofs :)
14:33:10 * shapr bounces
14:35:01 <shapr> @yow !
14:35:01 <lambdabot> Ha ha   Ha ha  Ha ha   Ha  Ha  Ha  Ha  -- When will I EVER stop HAVING
14:35:01 <lambdabot>  FUN?!!
14:42:59 <Lenny1729> hi all
14:43:16 <Lemmih> Hey Lenny1729
14:58:23 <edi> haskell.org recommends hugs for newbies
14:58:33 <edi> is that much different from GHCi ?
14:59:25 <monochrom> Yes.
14:59:42 <Cale> I think GHCi is nicer, personally
15:00:01 <monochrom> True.
15:00:34 <edi> i have it, should i install Hugs for first tries or go ahead with GHCi ?
15:01:13 <monochrom> Then I recommend using GHCi.  If you don't get fed up with it, there is no need to try another interpreter.
15:01:31 <ayrnieu> Hugs may start and compile faster than GHCi, if those aspects of the latter bother you.
15:01:47 <shapr> hiya ayrnieu, ltns
15:02:13 <ayrnieu> shapr, howdy
15:02:45 <edi> ayrnieu, they doesn't, thx
15:04:34 <jadrian> nice, HGL now works with GHC :)
15:11:08 <Lemmih> HGL?
15:11:55 <Lemmih> Binding to OpenGL?
15:12:34 <Igloo> Hugs Graphic Library
15:12:47 <Lemmih> Oh.
15:14:27 <Pseudonym> OK, that's interesting.
15:14:59 <Pseudonym> To "crocodile" is to speak ones native language in front of Esperantists when you can speak perfectly good Esperanto.
15:15:12 <Pseudonym> That I did not know.
15:22:06 <shapr> What if esperanto is your native language?
15:22:16 <jadrian> errr
15:22:18 <shapr> Does that still count?
15:22:24 <jadrian> native?
15:22:24 <Pseudonym> Dunno.
15:22:29 <jadrian> esperanto?
15:22:29 <ibid> are there any?
15:22:35 <shapr> I think so.
15:22:46 <Pseudonym> Yes there are.
15:22:53 <jadrian> there are?
15:22:55 <Pseudonym> There are children who grow up multi-lingual.
15:22:57 <jadrian> now I'm confused
15:23:00 <jadrian> where?
15:23:10 <Pseudonym> Canada, for example.
15:23:14 <edi> a friend of mine who studies languages has told me that esperanto is in fact a dead/bad experiment
15:23:28 <jadrian> canada is English + French 
15:23:30 <Pseudonym> If your parents speak Esperanto, then it's possible for you to speak it natively.
15:23:31 <jadrian> not esperanto
15:23:32 <ibid> edi: worse is better
15:23:34 <edi> made by people who doesn't studied languages
15:23:46 <edi> so there was another experiment called InterLingua or something like that
15:23:46 <ibid> jadrian: we are not talking about official languages
15:23:48 <shapr> anyway... class tomorrow
15:23:52 <Pseudonym> You asked where there are children who grow up multi-lingual. :-)
15:23:57 <Pseudonym> edi: Your friend is about half right.
15:24:02 <shapr> edi: look up lojban.org for another interesting viewpoint
15:24:16 <edi> i'm not really sure, he told me while ago :)
15:24:17 <Pseudonym> It was not made by people who did't study languages.
15:24:29 <Pseudonym> That's the major mistake in his reasoning.
15:24:36 <ibid> edi: there are a lot of conlangs, none of which has attained anything close to the popularity of esperanto
15:24:38 <jadrian> ibid: well we are talking about native
15:24:40 <ibid> except, perhaps, klingon:)
15:24:49 <ibid> jadrian: yes, and that has nothing to do with official
15:24:52 <shapr> I like klingon.
15:24:53 <Pseudonym> OTOH, for being a supposed international language, Esperanto is a very good modern Polish.
15:25:03 <shapr> I like lojban too.
15:25:10 <jadrian> ibid: yeap and does anyone natively speaks esperanto in Canada?
15:25:16 <shapr> But I've been thinking of a better design for a conlang =)
15:25:17 <ibid> jadrian: i have no idea
15:25:20 <Pseudonym> jadrian: There must be one or two.
15:25:24 <jadrian> eh :)
15:25:30 * shapr goes to sleep
15:25:34 * ibid too
15:25:36 * ayrnieu doesn't expect that Esperanto will grow very popular outside of Europe, himself.
15:25:39 <Pseudonym> There must be, somewhere in Canada, a child who was brought up speaking Esperanto.
15:25:55 <Pseudonym> As well as English and French, presumably.
15:26:26 <jadrian> I have many doubts about esperanto
15:26:44 <Pseudonym> ibid: I think that's the main point.  Except for languages which are "official" for some country, Esperanto is still the most popular conlang.
15:26:45 <ibid> i find it hard to believe that a child could become effectively native in a conlang as long as they don't live in a neighbourhood where it's the dominant language and where the parents are not native speakers
15:26:51 <jadrian> I mean I think it's a good idea, but would it be worth it for me to learn it?
15:26:57 <Riastradh> There exist people who speak Esperanto as their native language.  There are not many of them, however, I'm sure.
15:27:01 <Pseudonym> ibid: The parents don't have to be "native" speakers./
15:27:09 <Pseudonym> They just have to speak it around home.
15:27:09 <ibid> Pseudonym: i would think that klingon is gaining :)
15:27:25 <Riastradh> jadrian, if everyone has that mindset, then no, of course not.
15:27:26 <Pseudonym> Esperanto is in the top 5% of languages by speaker.
15:27:29 <vegai> Pseudonym: that's not enough
15:27:31 <Pseudonym> Klingon isn't even close.
15:27:33 <ibid> Pseudonym: yes, if the neighbourhood is dominantly esperanto
15:27:46 <ibid> Pseudonym: but if both are lacking, i doubt it
15:27:49 <vegai> Pseudonym: though it depends on what level of sophistication you classify as "native"
15:27:53 <Pseudonym> Or if they were carted along to local Esperanto society meetings or something.
15:27:55 <jadrian> I only see 2 advantages in esperanto, and many disadvantages
15:28:02 <jadrian> 1. it is a neutral language
15:28:06 <ibid> Pseudonym: not enough
15:28:27 <jadrian> 2. from what I've heard, it's very well built, easy to learn, and will make it easy for you to learn other languages
15:28:33 <jadrian> disadvantages
15:28:36 <ayrnieu> jadrian - lojban seems to criticize point 1.
15:28:42 <Pseudonym> First off, it's not a neutral language.
15:28:43 <ibid> Pseudonym: kids don't learn their non-conlang traditional languages very well when the only exposure is home and school
15:28:50 <ayrnieu> or rather, lojban people dispute point 1.
15:28:50 <Riastradh> Esperanto is very European.
15:28:54 <Pseudonym> It's very Euro-centric, and even then it's very Polish.
15:29:01 <ibid> Pseudonym: so why should they learn a conlang any better?
15:29:02 <Pseudonym> Some of the sounds are hard even for English speakers.
15:29:16 <Pseudonym> Point 2 is mostly correct.
15:29:16 <jadrian> ok, so there goes point 1 out the window :)
15:29:27 <Pseudonym> But some more advantages:
15:29:31 <tuomov> to me esperanto seems very spanish..
15:29:31 <vegai> lojban is highly terran-centric :-P
15:29:31 <jadrian> like?
15:29:41 <Pseudonym> 3. It's the most popular of the possible alternatives.
15:29:50 <tuomov> but I like what little I've studied it
15:29:50 <ibid> if i should learn one conlang, it'd be klingon
15:29:51 <jadrian> possible alternatives to what?
15:29:51 <Pseudonym> 4. It's very stable, having been around for over 100 years.
15:29:56 <tuomov> seems very easy to learn
15:30:01 <jadrian> but stable is good?
15:30:08 <Pseudonym> jadrian: Possible alternative "international" languages.
15:30:08 <jadrian> new terms appear all the time
15:30:31 <Pseudonym> That's true, but in very new languages, there aren't words for some concepts.
15:30:31 <jadrian> and languages are being updated all the time
15:30:38 <tuomov> lojban is too weird :)
15:30:39 <ayrnieu> jadrian - English seems fairly stable, in the sense that it will take more than a couple of nuclear wars to bury it.
15:30:45 <Pseudonym> A friend of mine who translated some of the plays of Shakespeare into Klingon ran into this problem.
15:30:48 <jadrian> ayrnieu: not really
15:30:51 <jadrian> ayrnieu: far from it
15:30:52 <tuomov> english is not easy
15:30:56 <Riastradh> Pseudonym, you have strange friends.
15:30:57 <jadrian> ayrnieu: floppy disk?
15:31:00 <ned> tromp: did you manage to install greencard ?
15:31:02 <jadrian> ayrnieu: zip drive
15:31:05 <Pseudonym> Klingon doesn't have a word for "jealousy".
15:31:06 <ayrnieu> jadrian - human speakers?
15:31:11 <jadrian> ayrnieu: all new terms
15:31:12 <ibid> Pseudonym: well, what your friend was doing is how the vocabulary is expanded ;)
15:31:14 <Pseudonym> He had to translate it "I feel acid".
15:31:20 <jadrian> ayrnieu: huh?
15:31:22 <Riastradh> C++ committee members, combination Klingon & century-old-entertainment fans...
15:31:22 <ibid> but i really should sleep
15:31:24 <ayrnieu> jadrian - er, please listen to my actual full argument instead of the first four words.
15:31:33 <Pseudonym> ibid: Except that different translators will do it in different ways, making the language a little unstable.
15:31:35 <Riastradh> s/century/centuries/1
15:31:54 <Pseudonym> This friend of mine used to have his home page in eight languages.
15:31:54 <ibid> Pseudonym: new words are always shaky at first, in any language
15:32:09 <jadrian> ayrnieu: ok, re-read it, now I just think it doesn't make sense
15:32:12 <Pseudonym> Yes, but words like "jealousy" should be fairly stable.
15:32:18 * ibid wrote a cpp
15:32:23 <ayrnieu> jadrian - that satisfies me.
15:32:25 <ibid> Pseudonym: it's getting there :)
15:32:27 <jadrian> ayrnieu: because stable as nothing to do with the fact that it is going to last
15:32:37 <ayrnieu> jadrian - well, yes it does.
15:32:43 <vegai> "That depends on what your definition of "is" is."
15:32:45 <Pseudonym> I think his page was in English, Latin, Modern Greek, Classical Greek, Esperanto, Klingon...
15:32:49 <tuomov> stability is overrated
15:32:51 <ayrnieu> jadrian - stable thing.  Strong wind.  stable thing still there.
15:32:51 <Pseudonym> Can't remember the other two.
15:33:05 <ibid> biologists have a special word for 'stable': dead
15:33:13 <tuomov> ibid: indeed
15:33:22 <ibid> (an oooold joke)
15:33:33 <Pseudonym> Ahm abd Lojban.  Only seven.
15:33:34 <jadrian> ayrnieu: yes the language will stay there
15:33:35 <Pseudonym> http://www.tlg.uci.edu/~opoudjis/
15:33:39 <jadrian> ayrnieu: doesn't mean people use it
15:33:40 <Pseudonym> For the curious.
15:33:44 <ayrnieu> jadrian - so I think that 'stable' has at least two useful meanings as applied to (programming) languages.
15:34:01 <ayrnieu> jadrian - the language is not there if people don't use it.
15:34:13 <jadrian> ayrnieu: you agree that latin is stable, right?
15:35:00 <ayrnieu> jadrian - stable in the sense of dead.  Do you understand the concept of qualifications to words?  If you disagree with my assertion that 'stable' has more meaning than 'little-changing' as applied to languages, we can't really discuss this.  I hope that you can at least understand the point I meant to make in the context of the definitions I support.
15:36:42 <jadrian> ayrnieu: could you just tell me what you mean by stable then?
15:37:12 <jadrian> ayrnieu: because the " Strong wind.  stable thing still there." lead me into thinking it was, "not going to change"
15:37:45 <ayrnieu> jadrian - I did.  I'm not going to talk to you any more about this -- you've the preceeding log.  If I didn't have any faith in your ability to understand my meaning from the first thing I said in isolation, I would've hesitated to say that at all.
15:38:05 <jadrian> ayrnieu: ok
15:48:10 <psi> 23a.com] has quit [Read error: 110 (Connection timed out)]
15:48:19 <psi> 22:40 -!- lordhib [~Unknown@ad-f2-133.finet.se] has quitoops.
15:48:32 <psi> sorry about that.
16:29:22 <edi> 'night
16:50:00 <Janni> G'evening
16:50:18 <Pseudonym> G'day.
17:04:12 <blackdog> 'lo, all
17:19:43 <dons> hey blackdog
17:22:58 <aFlag> i'm writting a chess game with a friend. We are having trouble in keeping track of the moves people do over network
17:24:03 <ayrnieu> aFlag - why do you have trouble?
17:24:10 <aFlag> i mean, we can't change the board and there isn't any recursion while getting data from the handler created by the socket
17:24:33 <aFlag> the code is in http://tonhao.no-ip.org/~marcot/xadrez
17:24:38 <aFlag> we're using darcs
17:25:50 <aFlag> http://tonhao.no-ip.org/~marcot/xadrez/Conexao.hs more specificly
17:25:58 <ayrnieu> and servidor
17:26:43 <aFlag> yes
17:27:46 <aFlag> i'm looking at the code there and actually the first servidor was the first one i made, then my friend tried to make it work in the following trials and then we had trouble trying to get it back to the state it was hehe
17:27:47 <ayrnieu> aFlag - what does servidor return to?
17:29:10 <ayrnieu> oops, OK, I see it.
17:29:19 <aFlag> it returns to nothing
17:29:30 <aFlag> IO ()
17:30:42 <ayrnieu> aFlag - do you only have one client connecting to the server?
17:31:17 <aFlag> i was connecting using telnet but we'll do a client
17:31:25 <aFlag> that's what the cliente function is there for
17:31:29 <ayrnieu> How many clients connect to the server, aFlag ?
17:31:39 <aFlag> it's also not in the original state, it's the changed one
17:31:40 <aFlag> one
17:31:58 <aFlag> it's 2 programs talking to each other
17:34:07 <ayrnieu> aFlag - two chess-playing programs?  I got confused by your testing definition of main.  What do the programs say to each other?
17:35:20 <ayrnieu> but without really getting what you're doing, here, I'd suggest that servidor return IO Tabuleiro
17:36:32 <aFlag> the main just sets the servidor so i could test it using telnet
17:36:43 <aFlag> a2 a3 is the move
17:37:04 <aFlag> one program communicates the player moves to the other
17:37:08 <ayrnieu> I don't understand "sets the servidor", aFlag.
17:37:35 <aFlag> it calls the servidor function
17:37:44 <aFlag> which stays there getting data
17:38:03 <aFlag> i think the reason it's never over is because of haskell lazyness
17:38:40 <aFlag> in the first servidor function it seems to hang at
17:38:49 <aFlag> hPutStr h (f movDele)
17:38:55 <aFlag> it keeps calling f over and over
17:39:10 <ayrnieu> aFlag - OK.  I would suggest you use hGetLine instead of hGetContents, and recur with a Tabuleiro on each line read.
17:39:43 <aFlag> hum... i didn't realise i could use hGetLine
17:41:38 <ayrnieu> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html describes what you can do with Handle types
17:41:45 <ayrnieu> a Handle
17:43:25 * ayrnieu & food
17:44:01 <aFlag> ayrnieu, yeah, now it's more what i want, thanks ayrnieu 
20:11:25 <trinity> hi
21:47:11 <Pseudonym> Saluton.
21:47:21 * Pseudonym oscedas
21:51:03 <Pseudonym> Dankeme, estas tempeto gxis hejmon.
21:53:11 <Pseudonym> Hmmm, sorry, wrong channel.
21:54:08 <Pseudonym> Bonan vorton.
21:54:42 * Pseudonym memoros tion
21:55:39 <Pseudonym> I must be tired.
21:55:40 <stepcut> â Î±. Î± â Î²
21:56:27 <stepcut> ongwray annelchey
22:09:16 <shuttlecock> hi, i am a haskell newb -- was having trouble with running some stuff that looked very basic from the haskell tutorial at haskell.org
22:09:16 <shuttlecock> in either of ghci or hugs
22:09:28 <shuttlecock> it said to define a function like this..
22:09:32 <shuttlecock> inc n = n+1
22:09:41 <shuttlecock> but both of those interpreters don't allow that
22:09:53 <Pseudonym> You'll need to put that in a script.
22:10:04 <shuttlecock> am i doing something wrong or just misinterpreting that this is a command?
22:10:05 <Pseudonym> Or you can say this:
22:10:13 <Pseudonym> let inc n = n+1 in inc 5
22:10:14 <Pseudonym> Or something.
22:10:34 <shuttlecock> alright
22:10:35 <Riastradh> It is a top-level definition, shuttlecock; however, the REPL expects expressions, such as what Pseudonym showed.
22:10:39 <shuttlecock> looks like ocaml
22:10:55 <Riastradh> GHCi also lets you write this in the REPL:
22:11:00 <Riastradh> let inc n = n + 1
22:11:00 <ayrnieu> shuttlecock - GHCi will let you say: let inc n = n+1 -- alone
22:11:48 <shuttlecock> alright
22:12:42 <shuttlecock> so
22:13:15 <shuttlecock> in ocaml i could say 'let add = fun x y -> x+y' and then type add and see its type...is there something similar in ghci?
22:13:34 <ayrnieu> :help
22:15:24 <dons> let add = \x y -> x + y  ; :t add
22:28:07 * shapr dynamically reloads his brain using code dons wrote.
22:29:03 <dons> good morning shapr
22:29:23 <shapr> good morning dons!
22:31:16 <dons> have you tried :reload?
22:31:23 <shapr> not yet
22:31:32 <dons> open up yi on ~/.yi/Config.hs, change some colour specs, :reload ...
22:32:34 <dons> I'm building yi on an ia64 atm. so slow...
22:33:41 <stepcut> emacs keymays are going very slow (due to lack of time) :(
22:33:48 <stepcut> keymaps
22:34:58 <dons> cool. but at least you're working on them.
22:35:37 <dons> stepcut: feel free to send patches for even a few key binds, you don't have to write 500 lines to get a commit ;)
22:36:06 <shapr> oops, segfault
22:36:15 <dons> yikes
22:36:32 <dons> make sure you clean , before :reboot. 
22:36:46 <shapr> I didn't even get started.
22:36:52 <dons> though I haven't seen any segfaults recently
22:37:11 <shapr> stepcut: truly, any emacs you got, I'd like to try
22:37:39 <shapr> I copied examples/Config.hs into ~/.yi/
22:37:47 <stepcut> shapr: so far I only have self-insert and next-line working with the ctk lexer :p
22:37:48 <shapr> then ./yi-inplace ~/.yi/Config.hs
22:37:57 <shapr> stepcut: even so
22:38:04 <shapr> I'd like to try it.
22:38:21 <dons> shapr: that's all? and it crashed?
22:38:25 <shapr> yup
22:38:27 <dons> are you up to date?
22:38:32 <shapr> yes
22:38:43 <dons> also, make sure no old ~/.yi/*.{hi,o} are around
22:38:44 <shapr> maybe I should make clean
22:38:58 <shapr> oh, that might be it
22:39:16 <ayrnieu> justice?  Righteousness?  That's a wild name for an editor =)
22:39:21 <shapr> nope, still segfault
22:39:25 <stepcut> shapr: on the other hand, I did get my first halipeto site working: http://n-heptane.com/n-heptane
22:39:57 <shapr> stepcut: nice!
22:40:01 * stepcut goes to bed
22:40:13 <shapr> I like j_pink
22:40:14 <dons> shapr: no idea. examples/Config.hs works for me
22:40:25 <shapr> very multi-universe.
22:40:40 <stepcut> heh
22:40:58 <stepcut> Now that I finally have descent gallery software, I should put some more pictures up
22:41:02 <musasabi> morning
22:41:09 <shapr> are you going to release your halipeto gallery?
22:41:17 <shapr> I'm sure andrew would like that.
22:41:23 <shapr> I really like halipeto.
22:41:27 <dons> shapr: build with -debug, and then fire up gdb on the core. tell me where it died
22:41:45 <shapr> ok, after I come back from swedish class. I still have to do my homework before class starts =)
22:41:57 <shapr> och jag har ingen aning!
22:41:59 <stepcut> shapr: yeah, I am going to release it, I just need to clean it up a bit, it still has half the stuff from pancito in it still :p
22:42:07 <shapr> like my website :-)
22:42:17 * shapr runs off in search of education
22:42:26 <stepcut> I don't actually *use* the code,  I just haven't removed it yet ;)
22:42:29 * stepcut really goes to bed
22:50:33 <dons> ooh. 64 bit yi :)
22:55:15 <musasabi> when would it be a good time to write a second GUI for yi?
22:56:05 <dons> I don't see why now wouldn't be good? :)
22:56:27 <dons> what where you thinking about?
22:57:52 <musasabi> ok...
22:58:35 <dons> musasabi, do you have some ideas?
23:00:12 <musasabi> dons: I think I will do fltk to minimize dependencies (of course that will be more of an example to other people)
23:01:16 <dons> hmm this sounds promising. a light gui would be fun
23:01:51 <dons> atm, the ui on needs to provide 3 or 4 functions.
23:01:59 <dons> we could typeclass the ui, in fact.
23:02:13 <dons> otherwise, the ui programmer has full control over how things are renderrred
23:02:33 <musasabi> nice ^_^
23:02:55 <dons> so should be fairly easy, if you know this fltk api, already
23:03:28 <dons> i'll have to think of a nice way to plug in separate uis.
23:04:00 <dons> maybe they should come as separate HSfoo.o libs.
23:05:56 <musasabi> well if they are plugins isn't that enough?
23:07:07 <dons> yep. they should be plugins. I was thinking that each ui gets a dir in yi/ and generates a plugin of the form HScurses.o , for example
23:07:22 <dons> currently, the curses ui is part of the Yi core plugin
23:07:30 <dons> but it should be separate, of course
23:08:13 <dons> might create this hierarchy tonight, I think
23:08:30 <dons> and the type class stuff too, now I know what a ui needs to provide.
23:09:33 <dons> btw, musasabi, that suggestion to use Chan's for the lexer was just right :)
23:09:45 <dons> all my lazyRead stuff we just a reimplementation of Chans :}
23:14:30 <musasabi> ^_^
23:34:07 <dons> hmm. one issue will the name of known keys, like keyBackspace. We need to abstract over the various defns provided by the different uis
23:39:03 <musasabi> true, that is quite painfull.
23:40:58 <dons> anyway, just having a second ui should make it clear what is required
23:49:23 <dons> shapr: maybe you have old .o files lying around from files that have been mv'd.
23:49:29 <dons> getting linked in
