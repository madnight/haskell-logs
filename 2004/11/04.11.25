00:08:23 <musasabi> What is the preferred method to sending patches to Cabal?
00:34:25 <shapr`> oh no, darcs is being /.'d? I hope my server survives.
00:35:52 * shapr laughs at musasabi's and dons' opinion of slashdotters.
01:03:57 * asmodai tickles shapr 
01:04:09 <asmodai> shapr: Yea, I just read the osdir thing
01:04:42 <asmodai> musasabi: *just* today?
01:05:04 <kosmikus> is there a method to use string gaps in Haskell with gcc/cpp 3.4?
01:05:14 <asmodai> Finding well constructed arguments and informed opinions on slashdot is like seeking truffels
01:06:34 <musasabi> asmodai: I don't look at it very often ;)
01:06:52 <asmodai> musasabi: Good for keeping yourself sane.
01:07:14 <asmodai> musasabi: in general that crowd is the armchair general crowd, occasionally some enlightened people post
01:07:17 <musasabi> patched cabal, sent it to isac, released new hs-fltk => shopping
01:34:27 <magicuser> hello everyone
01:35:30 <TheHunter> hello magicuser 
01:36:16 <magicuser> I was reading about functional programming
01:36:26 <magicuser> I do not yet program anything but bash
01:36:28 <magicuser> ;)
01:36:33 <magicuser> and came accross haskell
01:36:38 <magicuser> and lisp
01:36:44 <xkb> a good way to start programming :D
01:36:50 <magicuser> im looking at the page on haskell db now
01:36:52 <magicuser> hmm
01:37:08 <magicuser> what is a combinator?
01:37:22 <xkb> a function to combine other functions
01:37:39 <xkb> in newbie terms
01:38:35 <magicuser> can it be called a macro?
01:38:50 <magicuser> I admit to have read some stuff on paul grahams site
01:38:57 <magicuser> code writing code
01:39:00 <magicuser> seems neat
01:41:24 <TheHunter> no, it's not a macro. A macro is a source-to-source translation, but a combinator (as a function) doesn't have access to the implementation its arguments, i.e. it can only call these functions.
01:44:25 <magicuser> hmm
01:44:34 <magicuser> is it at all like pipe ing
01:44:42 <magicuser> like take one function
01:44:48 <magicuser> and pipe results to another?
01:45:10 <TheHunter> i think we need an example. A typical higher order function (combinator, if you wish) is map.
01:45:34 <TheHunter> map takes a function and a list and applies the function to each element of the list.
01:45:48 <TheHunter> so map (+1) [1,2,3] ==> [2,3,4]
01:45:49 <magicuser> ok
01:45:57 <magicuser> i understand so far
01:46:02 <TheHunter> where (+1) is the function that adds one to a number.
01:46:11 <magicuser> ok
01:46:29 <TheHunter> we implement map like this:
01:46:34 <TheHunter> map f [] = []
01:46:47 <TheHunter> that is the empty list is mapped to the empty list under every function.
01:46:58 <TheHunter> map f (x:xs) = f x : xs
01:47:12 <TheHunter> err, map f (x:xs) = f x : map f xs
01:47:32 <magicuser> you brainfucked me
01:47:45 <magicuser> implement?
01:47:57 <TheHunter> if we have a list consisting of a head and a tail, we apply f to the head of the function, and map f to the rest of the list.
01:48:12 <TheHunter> implement = program
01:49:00 <magicuser> ok
01:49:25 <magicuser> say we have a list of customer names
01:49:28 <TheHunter> the interesting observation is that f is a function, not just a value.
01:50:00 <TheHunter> and in contrast to macros, f is evaluated at runtime, not at compile-time.
01:50:02 <magicuser> so you apply the function to each entry in a list
01:50:32 <TheHunter> yep.
01:51:50 <TheHunter> the general consesus in this channel should be that for usual tasks, higher order are sufficient, and cases where you'd actually need macros in a well-designed language are very rare.
01:52:33 <TheHunter> (i guess paul graham wouldn't agree with that)
01:53:13 <magicuser> woa
01:53:37 <magicuser> I don't even know the definition of a macro
01:53:53 <magicuser> but graham said 30% of his killer app was macro
01:54:12 <magicuser> your saying macros aren't that great?
01:54:32 <magicuser> what is higher order?
01:54:40 <TheHunter> map is higher order.
01:55:02 <TheHunter> You could imagine a language in which map could be viewed as a macro.
01:55:33 <TheHunter> Then map (+1) [1,2,3] would mean that the same action takes place at compile time.
01:56:16 <TheHunter> haskell doesn't have macros ;)
01:56:32 <TheHunter> and macros are very hard to implement in a typed setting.
01:57:05 <TheHunter> however, there is template haskell which is an extension that sort of does the same thing.
02:02:42 <kowey> hey haskellers, could anybody explain what you're supposed to do with an hsc file?
02:03:09 <kowey> i'm trying to use simon marlow's System.Process (http://www.haskell.org/hawiki/ExternalCommands), which comes as an hsc file among other things...
02:03:11 <TheHunter> kowey, http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
02:03:25 <kowey> reading now, thx
02:06:43 <kowey> ok, i don't mean to be dense, but
02:07:00 <kowey> i can produce a .hs file, 
02:07:10 <kowey> i assume that i'm supposed to compile this and put it somewhere
02:07:27 <kowey> but the linker complains about undefined symbols
02:08:13 <magicuser> anyone throw me a link about haskells version of php mysql web apps?
02:09:13 <TheHunter> kowey, hmm, are there any .o left in that directory that might interfere?
02:09:30 <kowey> no, i got rid of them
02:10:17 <kowey> there are 3 files that this comes with:
02:10:31 <kowey> anonPipe.{c,h} System/Process.hsc
02:11:27 <kowey> http://www.haskell.org/~simonmar/process/process.tar.gz
02:13:15 <TheHunter> sorry, i'm not running windows.
02:13:51 <kowey> actually, i'm on a mac, but yes, i just noticed a bunch of windows-specific stuff in there
02:14:11 <kowey> hmm... sorry, all i wanted to do was to run a process, feed some stuff to in on stdin, get some stuff back on stdout
02:15:47 <kowey> well... nevermind, i have some code that forks and does all that stuff, don't remember why i was trying to use this
02:15:50 <kowey> thanks anyway
02:20:37 <magicuser> awesome
02:20:42 <magicuser> wash
02:20:49 <magicuser> a haskell web service framework
04:01:18 <juhp> hmm, yi configure keeps giving me:
04:01:28 <juhp> config.status: creating mk/config.h
04:01:29 <juhp> config.status: error: cannot find input file: mk/config.h.in
04:01:48 <juhp> ah
04:01:56 <magicuser> ok
04:02:12 <magicuser> does anyone here have a working website powered by haskell?
04:02:15 <magicuser> ;)
04:02:18 <magicuser> :)
04:02:22 <magicuser> I can look at
04:02:49 <juhp> autoreconf...
04:05:29 <Lemmih> magicuser: Not currently online.
04:06:23 * Lemmih isn't a fan of WASH even though it has some interesting features.
04:07:01 <Lemmih> Oh actually I do. Check out: http://www.scannedinavian.org/cgi-bin/hackage/hackage
04:11:02 <Lemmih> Build with Hemplate and HaskellDB.
04:19:16 <Lemmih> Hemplate is almost the same as Halipeto. Just a little more consistent and a lot faster (-:
04:26:52 <kosmikus> is hemplate available?
04:30:25 <Lemmih> Not as an individual package but you can get the entire thing here http://www.scannedinavian.org/~shae/Hackage.tgz
04:31:09 <Lemmih> (Be warned! It's completely without documentation/comments)
04:31:15 <kosmikus> ok
04:45:10 <TheHunter> yay! the type variable scoping mess gets addressed!
05:02:36 <tromp> Haskell on slashdot, courtesy of darcs!
05:31:58 * juhp puts out a ghc622 fedora core pkg finally
05:32:08 <juhp> and newer darcs packages
05:32:17 <juhp> http://haskell.org/fedora/
05:33:57 <musasabi> home
05:34:55 <Muad_Dibber> morning all
05:36:43 <Lemmih> Hey Muad_Dibber
05:37:15 <Muad_Dibber> :)
05:42:14 <Roey|away> hey guys
05:42:27 <musasabi> hello
05:42:36 <Roey|away> what do you think of OCaml? is it functionally the same as Haskell?
05:42:43 <Roey|away> or does it address different goals
05:45:40 <musasabi> ocaml feels lower level, but produces very good code
05:58:41 <musasabi> What timezone does Isaac Jones live in?
06:30:52 <kosmikus> Muad_Dibber: thanks for the report on GH
06:31:12 <Muad_Dibber> kosmikus, i havent used it yet  :)
06:31:48 <kosmikus> which version have you tried?
06:31:55 <Muad_Dibber> the svn trunk
06:32:00 <kosmikus> ok
06:34:51 <Muad_Dibber> i bet you have some nice GH program bigger than our excersises you want me to test? ;)
06:35:17 <kosmikus> not really
06:35:28 <kosmikus> you can run the tests that are included
06:35:51 <kosmikus> i.e. go into the tests/ subdirectory and call "testGH --silent"
06:35:52 <dmitri83> shapr: salut
06:37:46 <Muad_Dibber> i will :)
06:37:55 <cm-> hello world
06:38:14 <Lemmih> hello cm-
06:38:20 <cm-> :)
07:05:51 * Lemmih throws a shuriken at his C++ generator.
07:08:02 <Muad_Dibber> kosmikus? i cant run the tests
07:21:27 <kosmikus> Muad_Dibber: why not?
07:22:07 <Muad_Dibber> well, it seems like it wants to use a nonexistant file /usr/local/gh-1.41/bin/gh
07:22:15 <Muad_Dibber> i suppose it shoud use gh-bin there
07:23:14 <shapr> whee
07:23:35 <kosmikus> hmm, let me check
07:24:01 <Lemmih> Greetings, shapr.
07:24:14 <shapr> musasabi: Isaac Jones, aka SyntaxNinja, lives in Portland, Oregon
07:24:32 <shapr> y0 y0 Lemmih!
07:24:55 <kosmikus> Muad_Dibber: oh, I see ... atm, testGH implicitly assumes an in-place installation
07:25:00 <musasabi> so he is a night critter... (from my perspective)
07:25:06 <kosmikus> because that's what I use most of the time during development
07:25:12 <kosmikus> it's a bug, I should fix it ;)
07:25:14 <Muad_Dibber> hehe
07:25:36 <Muad_Dibber> then disable the other installation ;)
07:26:24 <kosmikus> Muad_Dibber: no, that's not good; for a normal user, a installation in /usr/bin is ok
07:27:22 <musasabi> Is it possible to return a haskell exception from a C function ?
07:27:31 <musasabi> or throw it?
07:28:48 <shapr> Roey|away: yah, I agree with musasabi, OCaml requires you to write more source code than Haskell to accomplish the same thing, but usually turns out faster executables. Personally, I want to write less code because I think it's easier to write correct code that way.
07:30:20 <Muad_Dibber> kosmikus, well you dont have to fix it just for me ;)
07:30:50 <Muad_Dibber> since i will not run these tests very often 
07:38:09 <shapr> Yow, my webserver transferred 85mb today as opposed to 15mb yesterday. Think this is related to hosting DarcsWiki?
07:38:51 <shapr> guten abend nuckinucki1236 
07:40:20 <arjanb> shapr: darcs interview was on slashdot..
07:40:38 <shapr> yah, I saw that this morning.
07:41:11 <shapr> My webserver got 22k hits between 9am and 3pm
07:42:54 <xerox> shapr !
07:43:27 <kosmikus> Muad_Dibber: true, but I want it to work anyway ;)
07:43:38 <xerox> Rank:               VeryGood            VeryGood
07:43:42 <xerox> Score:              533                 508
07:43:47 * xerox wins again
07:44:46 <Muad_Dibber> kosmikus, good good  :)
07:44:49 <xerox> shapr want to play? ;)
07:47:29 <shapr> play what?
07:47:36 <xerox> typespeed !
07:47:38 <shapr> xerox: want to play crack-attack?
07:47:46 <xerox> what is it
07:47:59 <shapr> it's an extremely addictive and very simple OpenGL game.
07:48:13 <xerox> i do like addictive games.
07:48:47 <shapr> using debian?
07:49:06 <xerox> win32 at the moment :(
07:49:11 <shapr> oh
07:49:18 <xerox> no other workstation available, only a win32 laptop
07:49:18 <shapr> I don't know if crack-attack runs on win32
07:49:24 <xerox> id does!
07:49:48 <shapr> ah, so it does
07:50:52 <shapr> You may want to practice some before you play against me.
07:51:12 <xerox> i know the kind of game hehe
07:51:28 <shapr> http://www.scannedinavian.org/~shae/crack5246.jpg
07:52:56 <KiMoS> what is wronge in here
07:52:57 <KiMoS> bevatCijfer :: String -> Bool
07:52:57 <KiMoS> bevatCijfer n = any isDigit 'n'
07:53:20 <KiMoS>  Undefined variable "isD
07:53:20 <KiMoS> igit"                                                     
07:53:28 <xerox> is it possible to put the "swapper" vertically?
07:53:41 <KiMoS> do i need to import isDigit ? 
07:53:50 <TheHunter> @index isDigit
07:53:50 <lambdabot> Data.Char,GHC.Unicode,Char
07:54:00 <TheHunter> import Data.Char
07:54:01 <boegel> hello
07:54:04 <TheHunter> hey boegel 
07:54:17 <TheHunter> and it should be n instead of 'n'.
07:54:20 <boegel> would someone like to look at an image of mine, and help me with some doubt-stuff ?
07:55:12 <tromp> how bout naming it anyIsDigit instead of bevatCijfer:-?
07:55:25 <boegel> this is the image: http://studwww.ugent.be/~kehoste/thesisPublic/website/24_11_2004/3.png
07:55:57 <boegel> I think there's something strange with te reflection... the reflection of the bottom of the sphere's, apears to be 'raised' a bit...
07:56:14 <Igloo> Does anyone have a good URL on converting CPP macros to C functions?
07:56:59 <xerox> shapr argh, i did 52..
07:57:08 <musasabi> doing it by hand is easiest most of the time.
07:57:14 <musasabi> as macros can be very diverse.
07:57:18 <xerox> it's not my game
07:58:08 <Igloo> I don't want an automated whatsit, I want to know things like which modifiers (is that the right word? things like const) I should use, whether having an argument   char *foo   is the same as (char *)foo in the macro body, that sort of thing
07:58:41 <KiMoS> TheHunter  i importted it   and changed it to n  but i get now another error
07:59:01 <KiMoS> ERROR - Unresolved overloading
07:59:02 <KiMoS> *** Type       : Num [Char] => Bool
07:59:02 <KiMoS> *** Expression : bevatCijfer 89 
07:59:48 <shapr> xerox: so now that you've practiced, want to play against me?
08:00:15 <xerox> shapr ...
08:00:59 <xerox> yet another haskell tutorial.pdf is waiting ^_^
08:01:17 <Muad_Dibber> lol
08:01:34 <musasabi> Igloo: well that is more or less C.. (if you have something specific, please paste a link...)
08:01:58 <TheHunter> xerox, you rock! i did 34
08:02:23 <TheHunter> @type isDigit
08:02:24 <lambdabot> bzzt
08:02:29 <TheHunter> @type Data.Char.isDigit
08:02:31 <lambdabot> Data.Char.isDigit :: Char -> Bool
08:02:42 <TheHunter> KiMoS, the error is somewhere else in your code
08:03:06 <KiMoS> any idea what is the error?
08:03:41 <TheHunter> involving some arithmetic functions, probably
08:03:56 <xerox> TheHunter!!
08:04:14 <TheHunter> oh, i see you can't call bevatblub with argument 89
08:05:28 <KiMoS> even with just  1 argument i get an error
08:09:57 <TheHunter> Prelude> let bevatCijfer n = any Char.isDigit n
08:09:57 <TheHunter> Prelude> bevatCijfer "abcde3"
08:09:57 <TheHunter> True
08:09:57 <TheHunter> Prelude> bevatCijfer "abcde"
08:10:03 <TheHunter> False
08:10:26 <TheHunter> xerox, 92! guess it's not my kind of game either.
08:10:27 <KiMoS> oh " "
08:10:49 <KiMoS> thanks TheHunter  i got it working
08:14:28 <xerox> i stopped it hunter
08:14:28 <xerox> :D
08:14:31 <xerox> err, gone.
08:21:19 <boegel> can anyone explain the blue glow in this image? : http://studwww.ugent.be/~kehoste/thesisPublic/glow.png
08:21:28 <shapr> aliens...
08:21:31 <boegel> there's one light in the scene
08:21:35 <shapr> boegel: are you programming near area 51?
08:21:39 <boegel> Shammah, :D
08:21:45 <boegel> oh, I mean shapr :D
08:21:55 <boegel> shapr, not really
08:22:18 <shapr> xerox: I just got 3651 in the game I just finished.
08:22:40 <xerox> grrr
08:22:47 <xerox> what's your best in typespeed'
08:22:53 <shapr> I don't know.
08:22:57 <xerox> ? (english dictonary)
08:22:59 <xerox> :D
08:23:14 <shapr> I'll try it.
08:23:29 <shapr> the nice thing about crack-attack is that it's multiplayer.
08:23:37 <shapr> dash: hey you play crack-attack, right?
08:23:48 <xerox> typespeed too :D
08:23:52 <shapr> oh really?
08:23:56 <boegel> shapr, any idea if the blue glow is supposed to be there ? I think it doesn't, because I can't explain it
08:23:56 <xerox> YES.
08:24:02 <shapr> oh wow!
08:24:05 <xerox> Head2Head Mode!
08:24:09 <shapr> awesome
08:24:13 <xerox> big fun.
08:25:05 <shapr> boegel: well, if you're doing a 100% correct simulation, then it may just be a minor bug.
08:25:22 <shapr> spheres do in fact have a spot of brightness on the opposite side of the light source
08:25:27 <shapr> but that's 'real physics'
08:25:46 <boegel> shapr, I want to make sure if it's a bug, before I start looking for a bug which isn't there
08:26:11 <boegel> shapr, on the opposite side ? there's no light there, how can there be a highlight there then ?
08:28:04 <shapr> iirc, it's because the surface refracts a tiny bit of the light anyway.
08:28:10 <shapr> I forget the physics behind it (ha)
08:28:45 <shapr> xerox: good, 457 with my first try
08:30:40 <boegel> without the strange glow the reflection isn't shaped as a circle, so I'm starting to think it's normal... maybe a glitch of the ray tracing algorithm
08:31:21 <shapr> boegel: oh of course it's normal, I know what it is =)
08:31:40 <boegel> you do?
08:31:44 <shapr> yes
08:32:11 <xerox> Shammah yeah
08:32:13 <xerox> wops
08:32:16 <xerox> shapr yea!
08:32:46 <shapr> boegel: have you figured it out?
08:33:42 <boegel> shapr, no :s
08:33:53 <shapr> ok, what do you see?
08:34:21 <shapr> what objects are in the scene?
08:34:24 <xerox> shapr, http://www.emacswiki.org/elisp/typing.el :D
08:34:51 <boegel> shapr, are you aiming for the reflection of the plane in the sphere, which is reflected in the plane again?
08:35:03 <shapr> the blue glow is the plane
08:35:31 <shapr> if you turn down the reflectiveness on the sphere, I think it'll go away
08:35:38 <boegel> shapr, that makes sense, but why is the glow visible outside of the reflection of the sphere ? that doesn't make sense...
08:36:00 <shapr> it isn't outside the reflection of the sphere.
08:36:14 <shapr> if you put a light source behind the sphere, you'll see that.
08:36:14 <boegel> I know the part in the reflection of the sphere is the relfection of the plane in the sphere
08:36:27 <boegel> but it is visible outside of the sphere too... that's what's bugging me :
08:36:29 <boegel> :)
08:36:50 <shapr> I don't think it is outside the sphere.
08:37:34 <shapr> put a light source behind the sphere and retrace it.
08:38:53 <shapr> boegel: I'd guess that the plane is behaving as if it has its own illumination
08:40:22 <boegel> shapr, the whole plane is illuminated by the light source, because the shadow is behind the object..
08:40:28 <boegel> that might be an explenation
08:41:23 <shapr> the whole plane is acting as if it is a faint light source
08:41:50 <shapr> I've been playing with my shiny steel balls long enough to know how it maps backwards :-)
08:41:54 <shapr> contact juggling is fun.
08:42:30 <boegel> shapr, I'm having trouble reproducing the glow result again...
08:42:59 <boegel> so I think it's a quite unusual kinda thing...
08:45:58 <boegel> shapr, don't ask me how I managed to pull this : http://studwww.ugent.be/~kehoste/thesisPublic/hehe.png :D
08:46:51 <boegel> oh, I know... the light source which is behind the object is located just where the planes passes... cool effect :)
08:47:42 <shapr> whoa, nifty
08:48:17 <boegel> shapr, most of my cool scenes where rendered by accident ;)
08:50:16 <shapr> dang, debian/unstable doesn't have ControlMaster yet in ssh.
08:50:24 <Roey|away> shapr:   what do people mean, by the way, when they say that Haskell programs are 'mathematically provable' ?
08:51:01 <shapr> That means that, with enough work, you can turn your program into a mathematical proof.
08:51:10 <boegel> Roey, you can prove things about them, like you would im mathematics
08:51:17 <boegel> you can't do that in imperative languages
08:52:29 <boegel> shapr, I'm starting to believe you're right with the plane reflection stuff... I've lost my time again with a "its not a bug, it's a feature" problem
08:53:05 <shapr> even so, understand is the greatest gain...
08:53:11 <shapr> "understanding"
08:53:21 * shapr is spending too many CPU cycles elsewhere to type correctly
08:53:24 <boegel> shapr, true
08:54:03 <boegel> I hope I can get transparency to work tomorrow or this weekend... I can continue then on a simple parser, and let you guys render your own scenes :√†
08:54:21 <shapr> neat!
08:54:34 <Roey> boegel:  can you give me an example (however small)?
08:54:35 <shapr> you may want to write some QuickCheck tests to check your code.
08:54:39 <boegel> shapr, that won't be for another week or 2
08:54:46 <shapr> ok
08:54:59 <boegel> Roey: http://studwww.ugent.be/~kehoste/thesisPublic/website -> have fun :)
08:55:06 <Roey> thanks
08:55:07 <boegel> shapr, what are those ?
08:55:16 <shapr> boegel: I think he's talking about code proofs.
08:55:40 <boegel> shapr, oh :s
08:55:53 <boegel> sorry Roey, you won't find any code proofs on there :s
08:56:20 <shapr> boegel: http://www.cs.chalmers.se/~rjmh/QuickCheck/
08:56:41 <Roey> boegel:  yeah it says on the page :)
08:56:56 <Roey> I just wanted an example of what there is to prove, and how it can be verified with haskell
08:57:25 <boegel> shapr, I'm planning to do that in the functional system FunMath
08:57:38 <shapr> length [] = 0
08:57:47 <shapr> length (x:xs) = 1 + length xs
08:57:57 <shapr> That function is relatively easy to prove via induction.
08:58:22 <Roey> btw I'm a Python/C/C++ programmer at heart.  Python has functional statements, and that piqued my curiosity about functional languages (of which haskell I understand is the archetype)
08:58:42 <shapr> an empty list is of length zero, a non-empty list is of length 1 plus the length of all list items except the first 
08:58:50 <Roey> ok
08:58:54 <shapr> I also came to Haskell from Python.
08:58:57 <Roey> :)
08:59:33 <Roey> right so how does your previous statement prove the code by induction?
08:59:44 <boegel> Roey, it doesn't
08:59:47 <Roey> ok
09:00:00 <boegel> induction is mathematical, and Haskell syntax is similar to math
09:00:03 <Roey> I mean I understand how the code works (hehe)
09:00:04 <Roey> ok
09:00:06 <Roey> aaah ok.
09:00:15 <Roey> I can see that it looks like a mathematical statement
09:00:20 <boegel> so you can use the Haskell syntax in an induction proof
09:00:26 <Roey> ok
09:00:42 * Roey always sucked at MI
09:01:10 * shapr has never tried writing a proof
09:01:21 <Roey> so I think statements of the form  blahblahblah(head:tail) = 
09:01:24 <Roey> are very very common
09:01:27 <Roey> correct?
09:01:36 <shapr> yes
09:01:39 <Roey> ok
09:01:46 <Roey> I mean there are no loops... you use recursion instead
09:01:51 <Roey> as far as I can tell about haskell
09:01:51 <shapr> right
09:01:53 <Roey> ok
09:01:59 <Spark> recursion is sufficient for writing broken programs :)
09:02:01 <shapr> it's a lot simpler to use recursion.
09:02:07 <Roey> Spark:   :)
09:02:44 <Roey> it's sort of mind bending to me because after mentally evaluating the base case (the 'h' in the 'h:t'), I have to zoom all the way to the end case and then work backwards
09:02:52 <Spark> heres a question: assuming mycroft type assignment was decidable, would it be better than milner type assignment?
09:05:11 <shapr> Roey: the base case is the the end case
09:05:24 <Roey> hmm
09:05:29 <Roey> I thought it is the first case
09:05:34 <shapr> with this sort of recursion, you have 1. how to do the last step 2. how to get one step closer to the last step
09:05:42 <Roey> ah ok
09:05:46 <Roey> so I was almost right then
09:05:49 <Roey> in evaluating
09:06:01 <shapr> the two different lines use pattern matching
09:06:02 <Roey> this sort of confusion always tripped me up in compsci courses
09:06:35 <shapr> Roey: well, once you use it a bit, it's crystal clear
09:06:54 <Roey> ok
09:07:00 <shapr> pattern matching gets internally rewritten to a case statement
09:07:01 <boegel> it's really fun to make strange scenes: http://studwww.ugent.be/~kehoste/thesisPublic/strange.png
09:07:33 <Roey> shapr:  so are there *any* imperative constructs that a haskell programmer may possibly need?
09:07:39 <shapr> sure!
09:07:44 <Roey> like what?
09:07:52 <shapr> Haskell is a wonderful imperative programming language.
09:07:54 <Roey> (I mean monads and all)
09:07:59 <Roey> procedural I mean
09:08:03 <shapr> that too
09:08:08 <Roey> oh?
09:08:20 <Roey> so say there are sequential things we need to get done:
09:08:26 <Roey> 1.  build the window
09:08:29 <Roey> 2. populate the window
09:08:41 <shapr> ok, I'll explain monads to you... but you have to promise to believe me when I say they're really that simple.
09:08:48 <Roey> 3. notify someone that we finished rendering the window
09:08:51 <Roey> ok
09:08:52 <KiMoS> what is wronge in here  
09:08:53 <KiMoS> NumberofInt :: String -> Int
09:08:53 <KiMoS> NumberofInt n  = length (filter anyIsdigit n)
09:09:04 <Roey> shapr:  can it be in a few minutes?  
09:09:13 <shapr> yes, how about .. three minutes?
09:09:17 <Lemmih> KiMoS: What's the type of anyIsdigit?
09:09:18 <Roey> shapr:  I have to go pick up some things from the drug store
09:09:19 <KiMoS> anyIsdigit :: String -> Bool
09:09:20 * Roey snickers
09:09:22 <Roey> drug store
09:09:23 <Roey> hehe
09:09:39 <Roey> (atually just benzoyl-peroxide cream and floss)
09:09:42 <shapr> A monad is a partially filled in type and two functions.
09:09:51 <Lemmih> KiMoS: It should have the type Char -> Bool.
09:10:07 <Lemmih> @type filter
09:10:08 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
09:10:26 <shapr> one of those functions puts something into the type, another of those functions puts together two values of the already filled in type.
09:10:33 <shapr> tada, that's a monad.
09:11:03 <Lemmih> KiMoS: 'n' is a [Char] so the first argument to filter must have the type: (Char -> Bool).
09:11:35 <shapr> Si\: hey, do you have any hws-wp code other than that which is in the haskell-libs cvs repo?
09:12:03 <KiMoS> i changed anyIsdigit to   Char -> Bool but i get another error now lemmih
09:12:06 <shapr> Si\: if you have any further development, I'm about to create a canonical hws-wp darcs repo
09:12:19 <KiMoS> *** Expression     : any isDigit n
09:12:19 <KiMoS> *** Term           : n
09:12:19 <KiMoS> *** Type           : Char
09:12:19 <KiMoS> *** Does not match : [a] 
09:12:30 <shapr> and I'd like to include any improvements you've made since the last version.
09:12:45 <Lemmih> KiMoS: anyIsdigit is not what you wanna use.
09:13:02 <shapr> Of course, a full upgrade of hws-wp would use hs-plugins.
09:13:04 <boegel> I'm out, dinner and girlfriend :)
09:13:05 <boegel> bye !
09:13:24 <Lemmih> KiMoS: Try this: filter even [1..10]
09:13:27 <shapr> boegel: have a life!
09:13:31 * shapr snickers
09:13:32 <KiMoS> anyIsdigit :: String -> Bool
09:13:32 <KiMoS> anyIsdigit n = any isDigit n
09:14:17 <KiMoS> Limmeh that gonna filter the even numbers from 1 to 10...
09:14:22 <Lemmih> KiMoS: That function checks if there's a digit in a string. What you need is a function which checks if a Char is a digit.
09:14:32 <xerox> Char.isDigit
09:14:32 <xerox> ?
09:14:59 <Lemmih> xerox: I was actually hoping he would figure it out by himself but yeah (-:
09:15:32 <xerox> wops.
09:15:42 <shapr> Yah, I like to give hints rather than solutions. That way you leave that person the thrill if discovering the answer themselves.
09:15:44 <Si\> I haven't touched it beyond the patch I sent you shapr
09:15:49 <shapr> ok, thanks.
09:16:38 <xerox> i'm sorry
09:16:40 <KiMoS> Char.isDigit  instead isDigit?  :O
09:17:19 <KiMoS> Undefined qualified var
09:17:19 <KiMoS> iable "Char.isDigit" 
09:17:31 <shapr> xerox: no worries, sometimes a full answer is better :-)
09:17:56 <Lemmih> KiMoS: 'isDigit' instead of 'any isDigit'
09:18:28 <xerox> Variable not in scope: `Char.isDigit' wops :)
09:19:22 <KiMoS> Lemmih  but if i remove the any  it wont work if i give a string with more then 1 element.. ?
09:19:41 <xerox> @Index Char
09:19:41 <lambdabot> Sorry, I don't know the command "Index", try "lambdabot: @listcommands"
09:20:01 <xerox> @Char
09:20:01 <xerox> ?
09:20:02 <lambdabot> Sorry, I don't know the command "Char", try "lambdabot: @listcommands"
09:20:08 <xerox> query :P
09:20:37 <Lemmih> KiMoS: 'filter' will apply it to every Char in the String by itself.
09:21:18 <Lemmih> KiMoS: You shouldn't touch nor use the function anyIsdigit.
09:22:19 <KiMoS> i got it 
09:22:37 <KiMoS> man i am thinking harldy and its easy
09:23:24 <Muad_Dibber> @lambdabot
09:23:24 <lambdabot> Sorry, I don't know the command "lambdabot", try "lambdabot: @listcommands
09:23:27 <Muad_Dibber> bah
09:23:31 <Muad_Dibber> @listcommands
09:23:32 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
09:23:32 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
09:23:32 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
09:23:32 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
09:23:32 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
09:23:33 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
09:23:35 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
09:23:36 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
09:23:39 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
09:23:50 <Muad_Dibber> it should do that in a private msg :P
09:24:09 <Lemmih> Aren't some of the '\"' missing?
09:24:33 <Muad_Dibber> ?
09:24:57 <Muad_Dibber> yeah
09:24:59 <Lemmih> ,"define \n,"definitions"...
09:25:18 <Muad_Dibber> prolly a bug in the newline placer :)
09:25:19 <shapr> Yow, my webserver had 3964 hits yesterday, and 41983 hits today. darcs hit slashdot and slashdot hit DarcsWiki.
09:25:39 <Muad_Dibber> but now i still dont know where to get lambdabot :P
09:25:50 <Muad_Dibber> @info
09:25:52 <lambdabot> syntax: `:i <thing-you-want-info-about>'
09:25:52 <shapr> he comes in small doses...
09:26:05 <shapr> three easy payments of 99.95
09:26:13 <shapr> bits, that is.
09:26:24 <Muad_Dibber> and is he worth it? :)
09:26:26 <Muad_Dibber> or she?
09:26:31 <shapr> I'm not sure yet.
09:26:52 <dash> "darcs hits slashdot; slashdot hits back"
09:26:57 <Muad_Dibber> it's a he right?
09:27:05 <Lemmih> Muad_Dibber: http://sourceforge.net/projects/haskell-libs
09:27:07 <Muad_Dibber> he has a thingy hanging between is leg :P
09:29:39 <xerox> KiMoS did you got it?
09:29:41 <xerox> *get
09:30:01 <Lemmih> Muad_Dibber: Its gender isn't evaluated yet (it's too lazy).
09:30:08 <KiMoS> yees its working thanks :)
09:30:20 <Muad_Dibber> Lemmih: well, i'd swear it's a he
09:30:22 <Muad_Dibber> look at his lambda
09:30:23 <Muad_Dibber> i mean
09:30:29 <Muad_Dibber> no roundings (breats)
09:30:43 <Muad_Dibber> but to the left, some manly part seems to be there :P
09:31:02 <xerox> KiMoS can you show me? but don't tell anyone! :D ghgh
09:31:23 <Muad_Dibber> and it does only do hugs when really nesecary, while women do that all the time :P
09:31:51 <KiMoS> xerox     numberofInt :: String -> Int
09:31:51 <KiMoS> numberofInt n  = length (filter isDigit n)
09:33:24 <xerox> Variable not in scope: `isDigit'
09:33:24 <xerox> mmh.
09:33:34 <Lemmih> xerox: It's located in Data.Char
09:33:53 <KiMoS> you have to import Data.Char
09:34:13 <xerox> uh.
09:38:25 <ned> so, i've to ask something, about my go game ..
09:38:33 <xerox> Go! what a game.
09:38:39 <ned> actually, for the play by network
09:38:52 <ned> it works but after playing,
09:39:04 <ned> you can,t do anything until the partner answers
09:39:11 <ned> cause i have
09:39:21 <ned> made it like this :
09:39:29 <ned> i open a socket
09:39:44 <ned> then i have a display thread, and a command thread
09:40:26 <ned> and when you play (command), i insert hPutStr & hGetLine
09:40:45 <ned> and obviously hGetLine waits for the answer
09:41:00 <ned> blocking evrything
09:41:04 <shapr> salut ned 
09:41:11 <ned> re-salut shapr 
09:41:13 <ned> :)
09:42:01 <ned> perhaps can i do a parallel thread which cheks every second for a socket answer
09:42:13 <ned> but it seems to me a bit ugly
09:43:30 <Lemmih> @index hWaitForInput
09:43:31 <lambdabot> GHC.IO,System.IO,IO
09:43:37 <ned> hum
09:43:40 <ned> sounds good
09:43:41 <Lemmih> @type System.IO.hWaitForInput
09:43:42 <lambdabot> System.IO.hWaitForInput :: GHC.IOBase.Handle -> Int -> IO Bool
09:43:52 <ned> great !
09:44:03 <ned> Lemmih: love you ;) will check that
09:46:07 <tromp> i'm still struggling to get greencard to work:(
09:46:36 <Lemmih> ned: The documentation is a little wrong. It only blocks other threads if 't' is positive.
09:46:52 <Lemmih> tromp: Same problem as before?
09:47:31 <tromp> yep
09:47:59 <tromp> ghc -package-name greencard -cpp -fglasgow-exts -prof -c Foreign/GreenCard.hs -o Foreign/GreenCard.p_o -hisuf p_hi
09:48:00 <tromp>  
09:48:00 <tromp> Foreign/GreenCard.hs:7:
09:48:00 <tromp>     Failed to load interface for `Prelude':
09:48:00 <tromp>         Could not find interface file for `Prelude'
09:48:01 <tromp>         (use -v to see a list of the files searched for)
09:48:28 <Lemmih> Are you sudo'ing make?
09:48:57 <tromp> doesn't make a difference
09:49:05 <tromp> before i did, now i didnt
09:49:51 <Lemmih> What does it say with -v?
09:50:06 <Lemmih> Welcome back KiMoS
09:50:12 <KiMoS> thx sorry i was dc
09:51:25 <tromp> Foreign/GreenCard.hs:7:
09:51:25 <tromp>     Failed to load interface for `Prelude':
09:51:25 <tromp>         Could not find interface file for `Prelude'
09:51:25 <tromp>         locations searched:
09:51:25 <tromp>             Prelude.p_hi
09:51:27 <tromp>             Prelude.hi-boot-6
09:51:29 <tromp>             Prelude.hi-boot
09:51:31 <tromp>             /usr/lib/ghc-6.2.1/imports/Prelude.p_hi
09:51:46 <tromp> and then many more like it
09:52:04 <shapr> oh it's fun to read David Roundy's responses to slashdot comments. Uinformed comments will politely be laughed at.
09:52:58 <Igloo> You need to install ghc6-prof or equivalent
09:54:10 <shapr> Everytime I read a comment about "I tried X, it works great. I won't use anything else." I feel sorry for the poor suckers.
09:55:02 <shapr> If you've never tried the software but you make a comment that you'll never use it because something else works, how can you ever be sure you made the right choice?
09:57:34 <mflux> let's say one were to pick a picture gallery software.. you would try each and every one from freshmeat.net or try a couple and pick one of those?-) (..or write a new one..)
09:59:19 <shapr> I'd at least try each  and every one in the debian repository.
10:00:50 <shapr> And, If I were going to make a comment on a slashdot article about a particular piece of gallery software, I would definitely try the software first.
10:01:32 <mflux> well that's of course a good approach a take and I too avoid commenting on stuff I don't know about ;)
10:01:46 <shapr> slashdot may not be a collection of geniuses, but when they mention a piece of software, I usually try it.
10:01:46 <mflux> s/ a / to /2
10:03:34 <shapr> Plus, it's not like the number of SCMs even approaches that of image galleries.
10:03:48 <shapr> anyway...
10:03:56 <shapr> off the soapbox and onto the unit tests =-)
10:04:06 <mflux> no, but trying an scm is propably more effort than trying out a gallery
10:04:53 <shapr> Well, I'd say you can find about fifteen SCMs if you look hard. Since it's such a basic tool to open source development, I think it's worth investing the effort.
10:05:37 <shapr> I also think that's true of editors, filesystems, and some other facets of OSS development. But then, I spend a lot of time on my soapbox ;-)
10:05:59 <mflux> like I would bother trying out some other editor than (x)emacs? no way ;)
10:06:17 <shapr> heh
10:08:23 <shapr> (x)emacs has its own set of warts that need fixing.
10:08:31 <mflux> yes, I agree
10:08:42 <mflux> but it would be a big effort to reimplement everything that works in it..
10:09:05 <mflux> ..maybe an editor with a elisp/xemacs subsystem, hmm..
10:10:38 <shapr> I think there's a much better approach. write a new editor in Haskell!
10:10:49 <Muad_Dibber> lol
10:11:00 <Muad_Dibber> an editor connected to ghc/hugs
10:11:06 <Muad_Dibber> that interprets right away what you are typing :P
10:11:21 <shapr> I think the strengths of emacs are obvious enough that they can be built into a new editor that doesn't have those same warts.
10:12:22 <Muad_Dibber> what's keeping you? :)
10:12:41 <shapr> Muad_Dibber: you just haven't checked out the source yet.
10:13:04 <Muad_Dibber> :)
10:13:08 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi/
10:13:33 * Muad_Dibber husses :)
10:13:47 <mflux> well for example I like xemacs' capability of opening terminal and x-window from the same instance, c-scope-module, and of course I have some scripts and configuration I've written myself for it
10:14:07 <shapr> I live in xemacs.
10:14:57 <mflux> writing a better xemacs would definitely take a large hunk of ones spare time. perhaps you or someone else will integrate some xemacs-like features to yi?-)
10:15:00 <shapr> I use it for irc, email, usenet, shell, music player, programming in several languages, and a bunch of other stuff I can't think of at the moment.
10:15:33 <mflux> I used to use it for news, but the slow speed begun to bug me too much.. lately I haven't read news much ;)
10:15:55 <xerox> i started using emacs for gnus too..
10:15:58 <shapr> the slow speed bugs me too. especially the blocking sockets hanging my irc, or irc blocking my news, etc.
10:16:10 <xerox> then i dropped using gnus for thunderbird and used emacs for all the rest, hehe :D
10:16:48 <shapr> happily, Yi is both compiled and dynamic.
10:17:20 <xerox> ciao rep
10:17:25 <xerox> wops wrong window
10:17:37 <shapr> ciao xerox :~)
10:17:43 * shapr wonders who rep is...
10:18:30 <shapr> anyway, I'm binging on Fermat's Last Margin tonight and tomorrow, social stuff on saturday, and yi sprinting here on #haskell on sunday.
10:18:56 <xerox> :D
10:19:02 <xerox> shapr reffie ;)
10:19:26 <shapr> mflux: I've written a lot of elisp code (1400 lines in my ~.emacs) , I don't like elisp. It just happens. If I start living inside of Yi instead, I know I'll write a lot more Haskell code than that.
10:20:07 <shapr> should be both fun and easy to hack lambdabot into a yi irc client.
10:20:19 <shapr> a bunch of the lambdabot plugins would be handy in a haskell editor.
10:20:48 <shapr> stuff like @index
10:21:10 <xerox> there isn't an @index in GHCi or something similar?
10:21:37 <tuomov> actually, that would be handy in ion F1 man page query..
10:22:04 <tuomov> I don't live in an editor; I live in ion
10:22:15 <xerox> i used it for a long time
10:22:35 <xerox> then passed to fvwm2, *so much* customizable
10:23:00 <xerox> i think you can make fvwm act as ion..
10:23:26 <Spark> yeah ive added loads of bindings to ion
10:23:28 <Spark> and i dont even know lua
10:23:37 <Spark> i have a screenshot button and such
10:23:42 <Spark> stuff for volume control
10:23:54 <Spark> cpu fan speed :)
10:23:57 <xerox> ion-devel ?
10:24:00 <Spark> ion2
10:24:05 <shapr> ion3!
10:24:08 <Spark> i havent got round to ion3 yet
10:24:09 <xerox> O_O
10:24:13 <xerox> THREE?
10:24:24 <Spark> yeah its been about for yonks
10:24:27 <tuomov> 3 is the current development branch
10:24:37 <shapr> I heard rumors that ion3 is nearing release
10:24:40 <tuomov> the versioning is quite non-standard
10:24:43 <xerox> it was 2 the development branch when i used it O_o
10:25:03 <tuomov> it was nearing release, but less than I planned has happened during the last two months
10:25:17 <shapr> oh
10:25:35 <Spark> pesky social lives
10:25:41 <tuomov> I thought I could finish it before next spring
10:25:44 <tuomov> but now I'm not so sure
10:25:53 <tuomov> what social life?
10:27:28 <tuomov> the reason why nothing is happening is that I have lots of other thinking to do that isn't going anywher
10:27:34 <tuomov> sigh
10:28:12 <Spark> heh
10:28:20 <shapr> you could a write a program to make the right decision.
10:28:22 <Spark> this msc is quite challenging
10:28:33 <shapr> Something like a hidden markov model.
10:28:42 <Spark> shapr: im sure there is some halting problem argument that will show that that is not possible :)
10:29:29 <tuomov> I'm interested in studying too many things
10:30:24 <shapr> you could try to match your options and your interests.
10:30:25 <xerox> i should make an haskell-multiplayer-typespeed
10:31:06 <tuomov> there are lots of potential options
10:31:16 <Spark> too many interests is bad
10:31:17 <Spark> unfortunately
10:31:21 <KiMoS> i need help again  what is wronge in here:
10:31:22 <KiMoS> cijferIndex :: String -> Int
10:31:22 <KiMoS> cijferIndex n = head n
10:31:22 <KiMoS> | bevatCijfer n
10:31:22 <KiMoS> | otherwise n = -1
10:31:54 <KiMoS> this should return  the first argument of the string when the first argument is an int  otherwise it return -1
10:32:21 <xerox> shapr: http://sominfo.syr.edu/facstaff/dvorak/blackburn.html
10:32:21 <xerox> hehe!
10:32:27 <KiMoS> bevatCijfer is a function that check of n  have int or not
10:33:23 <KiMoS> oops  it return the first arguemtn of n  if n have an int
10:33:35 <KiMoS> otherwise   -1
10:34:55 <Lemmih> KiMoS: You can't use pattern guards like that.
10:35:05 <tuomov> browsing around the web looking for options makes things even worse as you discover new interesting things
10:35:17 <tuomov> ignorance is a bliss.
10:43:08 <tuomov> What I should do is contact some profs and see if they have any ideas and if there are any that are willing to supervise... but I'd rather know more exactly what I want to do before that 
10:43:26 <tuomov> but that's probably not going to happen..
10:44:03 <tuomov> and how to randomise those profs..
10:44:52 <Spark> you will probably be interested more on the practical / pragmatic side of things rather than the theoretical side, no?
10:45:03 <tuomov> I don't know.
10:45:14 <Spark> e.g. software engineering rather than type theory :)
10:45:19 <tuomov> some days I'm interested in hard core theory, and some times slightly more practical things
10:45:24 <Spark> heh
10:45:30 <tuomov> no, not software engineering
10:45:33 <Spark> whats your academic background?
10:45:34 <tuomov> my m.sc is in maths
10:45:37 <Spark> ah
10:45:45 <Spark> then you are probably more theoretically tuned than i am
10:46:41 <Spark> what grade did you get for your msc?
10:46:42 <tuomov> most of the days I want to do something at least slighly mathematical, many days at least try hard core stuff even if I were not really up to it, and on the bad days I think it might just be best to implement Vis
10:47:13 <Spark> vis would be a huge project to do properly
10:47:15 <Spark> you couldnt do it alone
10:47:48 <tuomov> the grading is 1-5; the weighted average for all the courses was 4.36 iirc and 4.6+ for maths and other related interesting stuff (there's lots of totally uninteresting shit ina u of tech curriculum)
10:47:58 <tuomov> the thesis was 4, which is rather standard
10:48:07 <Spark> hm right
10:48:13 <tuomov> depending on the department, they don't give a 5 if you have not made publication in a totally worthless conference
10:48:14 <Spark> is 5 better than 1 then
10:48:21 <tuomov> of course
10:48:32 <Spark> its the other way round here, 1 is the best :)
10:48:37 <Spark> followed by 2:1 2:2 and 3
10:48:54 <Spark> although my msc postgrad course is either 'pass' or 'with distinction'
10:49:14 <Spark> the latter being >=70% each for each piece of assessed work
10:49:20 <tuomov> I have "with distinction" in my diploma
10:49:33 <tuomov> it doesn't say much more iirc
10:49:51 <Spark> you shouldnt have much problem finding a supervisor though, if you can convince them of your interest
10:50:20 <tuomov> if I could just convince myself of my interest :)
10:50:26 <Spark> :)
10:50:32 <Spark> i have no idea what i will do my thesis in
10:50:36 <Spark> ill leave that until later
10:53:37 <KiMoS> Lemmih  how should i do it then?
10:54:11 <KiMoS> using where?
10:56:09 <Lemmih> KiMoS: What's the type of bevatCijfer?
10:56:19 <KiMoS> bevatCijfer :: String -> Bool
10:56:33 <KiMoS> it only check if a string have an int or not
10:58:02 <Lemmih> cijferIndex n | bevatCijfer n = read [head n] | otherwise = -1
10:59:31 <KiMoS> Program error: Prelude.read: no parse    
10:59:59 <KiMoS> if i enter  cijferIndex "sdf3asf" 
11:13:08 <Lemmih> KiMoS: cijferIndex (filter isDigit "jallabat2")
11:15:45 <KiMoS> yes...
11:19:51 <KiMoS> Lemmih what you gave works correct expect when u u enter a string with an int in the middle
11:19:56 <Spark> is there something pleasant somewhere i can read about haskell's type system
11:20:22 <Spark> where pleasant means a lot of intuition, compared to mere statements of rules and algorithms :)
11:21:50 <tuomov> the latter is pleasant if you have it on dead tree, a sofa, and time to think
11:22:22 <Lemmih> KiMoS: The location of the digit shouldn't matter since all other characters are filtered out.
11:23:08 <Spark> tuomov: some of the papers ive had to have read recently, are not pleasant in the presence of an excess of sofa and dead tree :)
11:23:23 <Spark> actually i would have been ok if i hadnt been reading <= as 'subtype' and subtype as 'subtyle
11:23:27 <KiMoS> yea but cijferIndex should return the first element of any giving string containing an int  no mather where the in is located
11:23:29 <Spark> s/subtyle/subtype/
11:23:46 <Spark> and then subconciously joined them together, and getting very confused
11:26:52 <Lemmih> KiMoS: Then you should probably define it as: cijferIndex [] = -1 \n cijferIndex (x:xs) | isDigit x = read [x] | otherwise = cijferIndex xs
11:29:03 <KiMoS> Syntax error in input
11:29:03 <KiMoS> (unexpected backslash (lambda))                            
11:29:33 <KiMoS> oh
11:29:35 <KiMoS> sorry
11:31:05 <KiMoS> Lemmih  this return 4    when cijferIndex "caa4aaa"  and it have to return the c 
11:32:43 <Lemmih> But 'c' isn't an Int.
11:34:03 <KiMoS> i know but the function must return the first element (even strings) of a list that contain an int
11:35:02 <Lemmih> Then it should have the type: String -> Char
11:37:14 <KiMoS> yes that true i think i will leave it like this  thanks Lemmih 
11:37:47 <Lemmih> And how should it behave when applied to a string which doesn't contain a digit?
11:38:55 <KiMoS> what u gave was what i was looking for  im sorry that i have confused you 
11:52:13 <Lemmih> Greetings, fellow countryman.
11:52:49 <Oejet_> Labas vakaras, Lemmih (LT).
11:52:59 <Oejet_> Kak dela? (RU).
11:53:41 <Oejet_> Godaften, Lemmih.  Hvordan gÂr det? (DK)
11:55:37 <Oejet_> Lemmih, correcting reports in the course languages and parsing held by Michael R. Hansen at DTU.
11:56:00 <jdrake> Does one know why I might be getting this error while compiling hugs? ld: Undefined symbols:   _doubleFromParts   _part1Double  _part2Double
11:57:44 <Lemmih> Det g√•r fint. Er lige igang med at ryde up p√• mit v√¶relse.
11:58:05 <Oejet_> NÂÂÂÂ. :-P
11:58:44 <Lemmih> s/up/op/
11:59:48 <Lemmih> jdrake: Sorry, haven't seen that before.
12:00:31 <jdrake> Seems to happen every time I compile, on MacOSX, regardless of what my configure settings are
12:00:56 <jdrake> Fink, the local package manager, only has feb2001 in there, not Nov2003
12:01:13 <jdrake> Hugs was the baby better for learning the language correct?
12:01:14 <Lemmih> Urg. What about GHC?
12:01:50 <jdrake> Looks like fink has 6.2
12:03:29 <Lemmih> Hugs is lighter than GHC (ie. it boots and compiles faster but GHC has many cool language extensions).
12:05:01 <det> Lemmih: no Swedish/Finnish while I am present please
12:05:08 <det> Lemmih: it conufses me IRC client
12:05:31 <xerox> are there the lambda calculus operators like Y or I ?
12:05:40 <Lemmih> det: It was Danish actually (-:
12:05:50 <det> Lemmih: "det" is a popular word
12:06:12 <Oejet_> det, det var da ikke sÂ godt. :-P
12:06:14 <Lemmih> Det kan du ha' ret i d-:
12:06:20 <psi> det st‰mmer :)
12:06:23 <det> I speak none of it!
12:07:09 <det> on some IRC networks I can get like 10 messages a day from people /msg'ing and sentences starting with "det" and forgetting the nick
12:07:44 <tuomov> if it 'det' and not non-ascii that is confusing your irc-client, then I can safely speak finnish
12:08:24 <det> tuomov: I thought det is both Swedish and Finnish?
12:08:30 <Oejet_> So it's very  det erministic?
12:09:03 <tuomov> no
12:09:08 <Oejet_> And Danish!
12:09:22 <tuomov> 'det' is 'it' in swedish/danish/norwegian(?)
12:09:37 <tuomov> finnish is quite different kind of language from those
12:09:46 <tuomov> and 'd' is actually quite uncommon a character
12:09:53 <kristnjov> 'den' or 'det' depending on the word...
12:10:01 <tuomov> yeah, stupid genders..
12:10:02 <Oejet_> ykxiii kaakksiii kkolllmiii.
12:10:13 <kristnjov> we don't split words up into GENDERS really...
12:10:23 <kristnjov> we don't split them up at all really, we say what sounds good
12:10:27 <tuomov> well, not as much as in e.g. german/french 
12:11:13 <kristnjov> "ett tr‰d" sounds good, which means "a tree".. so then we say "DET tr‰det.."
12:11:15 <kristnjov> THAT tree
12:11:34 <tuomov> to my ears both en and ett sound good :)
12:11:50 <kristnjov> yeah but you're a foreigner ;P~
12:11:57 <musasabi> en and ett is pure evil.
12:12:01 <kristnjov> "tr‰den" would be "the trees"
12:12:13 <musasabi> although so are der/die/das (but they are a little more regular)
12:12:28 <tuomov> "regular"
12:12:34 <tuomov> you still need to know a lot about the words
12:12:38 <kristnjov> i can honestly say i don't know any rules for when to use en/ett in swedish
12:12:39 <tuomov> at least a/an is completely regular
12:13:08 <tuomov> well, as much as english pronunciation is :)
12:13:09 <Lemmih> Like in an hour? d-:
12:13:12 <kristnjov> heh yeah
12:13:13 <kristnjov> :)
12:13:16 <kristnjov> thought about "hour" as well :)
12:13:24 <Lemmih> And a unicorn.
12:13:45 <tuomov> but it is easy compared der/die/das/en/ett/la/le
12:13:54 <kristnjov> very easy
12:14:13 <Roey|brb> shapr left, arg.
12:14:35 <tuomov> but even easier is to do away with definite/indefinite articles :)
12:15:07 <tuomov> not to say that languages without those wouldn't have other complexities
12:17:57 * Lemmih wonders why most of the mailing-list traffic have been about buggy or missing features in Haskell.
12:19:44 * Oejet_ wonders if Haskell is buggy and featureless.
12:23:54 * Oejet_ also wonders why his head always explodes, when he writes concurrent programs in Java.
12:24:51 * Lemmih wonders why Oejet_ writes programs in Java.
12:25:31 * Oejet_ wonders why the parallel programming course chose Java as an implementation language.
12:25:35 * Roey wonders if Java why not Python, then.
12:25:47 * boegel wonders why every is using /me
12:26:02 <Roey> let's take the more active voice, then.
12:26:11 * vegai says "why not?"
12:26:22 * boegel doesn't agree with Roey :p
12:26:28 <Roey> that compsci courses use java seems to me very contrived
12:26:46 <Roey> I note that many people don't agree with me
12:26:51 <Roey> :)
12:27:18 <Roey> as politics go I am a very unpopular person here on Freenode ;)
12:30:09 <vegai> as much as any pathetic fumble can be contrived
12:30:19 <Lemmih> Anyone got a DSL for generating C++ functions lying around?
12:31:10 <bojohan> "Basically what I like about Java is that it lets you rapidly do fun stuff without getting bogged down in details like many other languages force you into. [...] Java's high-level abstraction seems very appealing to most of the researchers who like to feel as if they're manipulating ideas and concepts, not pieces of code."
12:31:42 <arjanb> heh
12:31:48 <bojohan> -- some dude at stanford
12:32:00 <boegel> tell me about politics Roey 
12:32:20 <boegel> bojohan, he has a point
12:32:34 <boegel> we get a _lot_ of java at uni
12:32:39 <bojohan>  /me explodes
12:32:44 <Roey> :)
12:33:16 <Roey> bojohan:  that's why I like python... talk about /rapid/...
12:33:26 <Roey> java seems to be a replacement for C++ with a badly conceived standard library
12:33:28 <Roey> to me
12:33:38 <boegel> bojohan, it is higher in level of abstraction than C++ is (garbage collection, 'pointer' checking)
12:33:39 <Roey> I mean.. just to open a freaking file you have to go through several layers.
12:34:22 <bojohan> mmm, "higher in level of abstraction than C++"...S W E E T
12:34:23 <boegel> Roey, they have made some mistakes in Java which bother them now, and they can't get rid of
12:34:27 <boegel> but so does C++
12:34:37 <boegel> bojohan, ?
12:35:26 <bojohan> </sarcasm>
12:36:02 <Roey> this file thing got to me.
12:36:26 <Roey> also the design of that java for cell phones kit.
12:36:28 <Roey> J2ME
12:36:31 <Roey> *arg*
12:36:31 <boegel> sorje, are they making such a big mistake then by teaching Java at uni ?
12:36:48 <boegel> Roey, it used a lot
12:36:49 <Roey> why don't they spread python if they want pupils to learn compsci?
12:36:54 <boegel> s/it/it's
12:36:59 <Roey> boegel:  I know.
12:37:16 <Roey> boegel:  we had to use it in our compsci course (security)
12:37:22 <Roey> boegel:  I half-got it working.
12:37:28 <Roey> brb
12:37:35 <boegel> Roey, because Python isn't a industry standard, and Java is >
12:37:41 <boegel> it's the same with OS's
12:38:04 <boegel> everybody knows that linux is far better, but most people still use Windoze
12:38:36 <tuomov> scheme might be a good first language, even if I don't like it
12:38:44 <tuomov> but I don't like java or c++ either
12:39:30 <tuomov> but nowadays cs programs seem more like engineer assembly lines for industry than programs that should teach people to think
12:39:55 <tuomov> so, java or c++
12:40:18 <Spark> heh
12:40:23 <Spark> one sec ill get you a url about that
12:40:42 <Spark> http://philip.greenspun.com/teaching/undergrad-cs
12:42:50 <boegel> very true! : Students who come to the university with pre-existing excellent study habits will still get an excellent education. Students who managed to hop over the low hurdles of junior high and high school despite poor study habits may get minimal benefit from college.
12:47:51 <tuomov> my experience from industry work is that none of what I learned in uni is required
12:47:59 <tuomov> I could've done the work straight out of secondary school
12:48:06 <boegel> nice :)
12:48:16 <tuomov> and been perhaps slightly less dissatisfied then
12:48:18 <boegel> I'm still in doubt of what I'll do next year
12:48:48 <KiMoS> what do they mean if they ask if a list have a square true or false?
12:48:54 <boegel> get to work or do a Phd...
12:49:21 <tuomov> I want to do phd studies (and maybe a phd eventually) as long as I have money for that
12:49:30 <tuomov> but I have trouble deciding in what exactly
12:50:14 <Roey> boegel:  what makes java industry standard?
12:50:24 <Roey> boegel:  large library support?
12:50:33 <Roey> I'm sick of this java crap.
12:53:53 <boegel> Roey, many companies use it... at least, that's what they tell us :)
12:54:11 <Nioate> it's industry standard because it's taught at universities everywhere?
12:54:27 <boegel> our health insurance computer system is writtin in Java (J2EE), or atleast they tell us that it is
12:54:41 <Roey> heh
12:54:46 <boegel> Nioate, no, universities teach it because a lot of companies use it
12:55:01 <Nioate> boegel: why can't they both be true?
12:59:36 <boegel> Nioate, I have _no_ experience with Java being used in companies or so
12:59:42 <boegel> so I can't tell
13:00:00 <boegel> this is my dream (for my Haskell raytracer), supporting these things: http://www.povray.org/community/hof/
13:04:31 <boegel> I'm out... bye everyone !
13:09:50 <bojohan> "He said that mathematicians proceed by inventing a perfectly simple, understandable object and then writing it up. Invariably someone comes along a year later and says `you weren't thinking straight; your idea is just a special case of x.' Things go on like this until we have things like category theory that no one can really understand, but which have the effect of being the most general generalization of everything."
13:10:59 <jdrake> with :type sum, what is the Num a in "sum :: Num a => [a] -> a"
13:15:05 <bourbaki> moin
13:15:28 <tooki> jdrake , it means that class NUM is defined for type a
13:15:52 <tooki> e.g. '+' must be defined for a
13:28:43 <Janni> Hello
13:28:44 <xerox> things under "where"
13:28:49 <xerox> should go on the same line as where
13:28:51 <xerox> or indented way more ?
13:28:51 <musasabi> hello
13:28:52 <musasabi> -c
13:29:13 <Janni> xerox: same is fine (if where has its own line)
13:29:22 <xerox> perfect.
13:29:24 <xerox> thank you
13:30:30 <psi> i do where foo = bar and align the rest under foo
13:30:59 <xerox> that's nice
13:33:41 <xerox> a little question
13:33:54 <xerox> what does this "where" means:
13:33:54 <xerox> module Main
13:33:56 <xerox>     where
13:33:59 <xerox>    
13:34:06 <xerox> ... rest of the code ...
13:35:19 <musasabi> xerox: it is a part of the module header
13:35:34 <xerox> it's *needed* ?
13:35:46 <bojohan> yes
13:35:53 <musasabi> [module <name> [(export_spec)] where]
13:36:00 <xerox> thanks
13:59:50 <Lenny1729> hi all
14:01:26 <xerox> hello
14:14:51 <Lenny1729> Is it possible to have a type that is Fractional and Integral?
14:15:35 <xerox> si there any opensource directory like sourceforge / berlios, that uses *darcs* as scm ?
14:16:23 <musasabi> Lenny1729: what does Integral mean? (same for fractional)
14:18:17 <Lemmih> Lenny1729: Yes but it's not desirable.
14:21:05 <Muad_AFK> g'night all
14:21:21 <Lenny1729> cya
14:21:33 <xerox> gnight Muad_AFK
15:13:14 <Janni> I'm importing a data type called Foo from module Bar. In the current module I'm defining another data type also called Foo. What I find strange is, that I need to call the second Foo by it's fully qualified name Current.Foo if I don't want make a qualified import for Bar.
15:14:25 <musasabi> import Bar hiding(Foo)
15:14:36 <musasabi> import qualified Bar (Foo)
15:14:47 <Janni> Thanks for the first
15:15:04 <musasabi> you can use them both if you need to.
15:15:13 <Janni> The second doesn't help, because I'm importing a lot of stuff and I don't want to call it all Bar.*
15:15:25 <Janni> Oh
15:15:39 <Janni> I maybe should read some documentation sometime...
15:17:23 <musasabi> Janni: the idea with the two lines is that you import everything but Foo unqualified and then you import Foo qualified.
15:17:34 <musasabi> Thus you can use them all 
15:18:00 <Janni> musabi: I understood. Thanks
16:07:48 <dons> morning Pseudonym
16:09:03 <Pseudonym> G'day.
16:11:08 <Pseudonym> I hope everyone was waving the flag on slashdot.
16:11:45 <dons> :)
16:11:56 <dons> it made it on to darcs@ and haskell@
16:16:10 <dons> I wonder if the use of Int for file points in Yi will ever be a limitation
16:17:00 <Pseudonym> What's a file point?
16:17:03 <Cale> why not make a type declaration?
16:17:19 * Pseudonym has implemented diff in Haskell before, so give me the gory details
16:17:43 <Pseudonym> Is it a byte offset or a line number?
16:17:52 <dons> a file point is a numeric offset from the start of a buffer, mostly used to keep track of the current insertion point.
16:17:57 * Roey supposes diff would be an ideal application for haskell... yes?
16:18:08 <dons> well, byte offset if the buffer is a byte buffer
16:18:08 <Pseudonym> Depends on the algorithm.
16:18:17 <Pseudonym> Right.
16:18:30 <Pseudonym> Then I'd say "yes".  I'd make it a typedef, currently to Word64.,
16:18:39 <ayrnieu> roey - depends on what you mean by 'ideal', of course.
16:18:54 <dons> yeah. think so. should have used Word64 from the start
16:19:17 <dons> but we'll see if it is ever feasible to edit a file larger than 4G ..
16:19:18 * ayrnieu still disliking /part-messages.
16:20:17 <Pseudonym> The Myers diff algorithm, which GNU diff uses, might be amenable to Haskell.
16:20:29 <Pseudonym> Though it would be hard to use the heuristics.
16:20:35 <dons> btw, new GHC backend has an (unused) Word128
16:20:50 <Pseudonym> Ah, handy if you're using ZFS.
16:20:55 <Pseudonym> Or IPv6, I suppose.
16:21:27 <Roey> ayrnieu:  well isn't diff implemented with an NFA or a DFA or some such construct?
16:21:35 <Pseudonym> Not really, no.
16:21:40 <Roey> what not really
16:21:44 <dons> yeah. no code gen for this type though, I think. Unless Wolfgang did something..
16:21:44 <Roey> not really to whom, me?
16:21:48 <Pseudonym> It's not based on an algorithm like that.
16:21:57 <Roey> Pseudonym:  do whom are you answering?
16:22:03 <Pseudonym> To you.
16:22:06 <Roey> ah, ok.
16:22:25 <ayrnieu> roey - I think you widely missed the point, but OK =)
16:22:47 <Pseudonym> Any algorithm based on dynamic programming is going to be easier in Haskell.
16:22:57 <Roey> Pseudonym:  I thought that maybe it would be easy in haskell to set the conditions for a regexp match and let the haskell runtime make out the execution path on its own (given the predicates)
16:23:01 <Pseudonym> Lazy evaluation rocks for that.
16:23:08 <Roey> right what I just said.
16:23:11 <Pseudonym> Right.
16:23:28 <Pseudonym> However, all of the dynamic programming algorithms for diff have O(n^2) worst-case complexity.
16:23:29 <Roey> So again, isn't haskell ideal for 'diff' given this?
16:23:33 <Pseudonym> It usually doesn't approach that in practice.
16:23:37 <Roey> oh, ok.
16:23:46 <Roey> how did you find that out?
16:23:51 <Pseudonym> So "real" diff algorithms have techniques for limiting the work.
16:23:56 <Pseudonym> I told you, I implemented it once. :-)
16:24:00 <Roey> and what is a dynamic programming algorith?
16:24:01 <Roey> ah :)
16:24:29 <Roey> Pseudonym:  how old are you, btw? I am 24 (you're probably some 21-year old kid in college but anyway :)
16:24:34 * Pseudonym is 31
16:24:45 <Roey> ah ok, that makes me feel much better.
16:24:47 <Pseudonym> :-)
16:24:48 * Roey gets jealous easily.
16:25:01 <Roey> heh
16:25:21 <Pseudonym> Anyway.  Example dynamic programming algorithm.
16:25:31 <Roey> last thing I need is someone younger than me showing me stuff that goes way over my head; it makes me feel incompetant ;)
16:25:32 <Pseudonym> Suppose you have two files, and you want to diff them.
16:25:33 <Roey> *ent
16:25:41 <Pseudonym> Yeah.
16:25:44 <Roey> ok
16:25:49 <Roey> and you want to diff them, ok.
16:26:07 <Pseudonym> Now the question that we'll ask is: what's the _size_ of the diff?
16:26:15 * dons sometimes wishes he could use $ in type decls
16:26:18 <Pseudonym> (Generalising this to compute the actual diff is left as an exercise.)
16:26:35 <Roey> ok
16:26:42 <Roey> size of the diff... in terms of what
16:26:47 <Roey> what is the size of the output?
16:26:52 <Pseudonym> In terms of number of insertions plus number of deletions.
16:27:10 <Roey> thre's a hard limit on that isn't there?
16:27:22 <Roey> assuming all lines are different
16:27:45 <Roey> you would delete a line from DST, then you would insert a line from SRC into DST
16:27:51 <Roey> er
16:27:55 <Roey> I think.
16:28:08 <Pseudonym> If there are no lines in common between the files, for example.
16:28:50 <Pseudonym> OK.  Now we compare the first line of each file.
16:28:58 <Pseudonym> The first line of file a vs the first line of file b.
16:29:28 <Roey> ok
16:29:28 <Pseudonym> If they're the same, we can remove the first line from each file and compute that diff.
16:29:31 <Pseudonym> And it's the same diff.
16:29:35 <Roey> ok
16:29:38 <Pseudonym> Make sense?
16:29:42 <Roey> yes
16:29:44 <Pseudonym> OK.
16:30:08 <Pseudonym> If they're different, then there's an edit here.
16:30:28 <Pseudonym> Could be an insertion, could be a deletion.
16:30:34 <Pseudonym> We don't know for sure yet,.
16:30:59 <Pseudonym> So what we do is remove a line off file a, and compute the diff of the files that remain.
16:31:08 <Pseudonym> Then we add the line back, remove a line off file b, and compute the diff of that.
16:31:21 <Roey> ok
16:31:24 <Pseudonym> The minimum of those two diffs, plus one, is the size of the minimal diff.
16:31:40 <Roey> so you are asking what the lowest upper bound is on the size of the diff?
16:31:47 <Pseudonym> And, of course, there are base cases, like when one file is empty.
16:31:55 <Roey> ah ok
16:31:56 <Pseudonym> Right.
16:31:58 <Roey> ok
16:32:09 <Pseudonym> Now if we implemented this directly, it would take exponential time.
16:33:24 <Roey> ok
16:33:37 <Pseudonym> Kind of like the "obvious" algorithm for computing fibonacci numbers.
16:33:38 <Roey> directly in a functional language you mean?
16:33:42 <Pseudonym> fib 0 = 1
16:33:43 <Roey> ah, got it.
16:33:43 <Pseudonym> fib 1 = 1
16:33:49 <Pseudonym> fib n = fib (n-1) + fib (n-2)
16:33:52 <Roey> right.
16:34:06 <Roey> but it's different.. with fib you use a lookup table and that speeds things up.
16:34:18 <Roey> it's not the same kind of problem here.
16:34:22 <Pseudonym> Sure it is.
16:34:28 <Pseudonym> Let's implement diff with a lookup table.
16:35:31 <Roey> what would we have to look up??
16:35:40 <Roey> rather,
16:35:47 <Roey> what would we have to look up multiple times?
16:35:56 <Pseudonym> HAng on.
16:36:11 <Roey> a lookup table with fibonacci works because you look up the same values in the lookup table many many times
16:38:31 <Pseudonym> Sorry, at w*rk.
16:38:42 <Pseudonym> Right, try computing the diff of [a,b] and [c,d]
16:38:59 <Pseudonym> That requires computing the diff of [b] and [c,d] as well as the diff of [a,b] and [d]
16:39:16 <Pseudonym> They will _both_ require computing the diff of [b] and [d].
16:39:17 <Pseudonym> Right?
16:40:17 <Roey> right
16:40:28 <Roey> ah. alright.
16:40:31 <Pseudonym> Right.
16:40:50 <Roey> so this reduces it to a square runtime?
16:40:59 <Pseudonym> So the simple solution in this case is: make a m*n array, where m is the lenth of file a and n is the length of file b.
16:41:09 <Roey> ok
16:41:16 <Pseudonym> Then in each array element, put in a function call which computes the diff, calling back to the array to compute the suboperations.
16:41:29 <Pseudonym> Then just evaluate the (0,0) element of the array and Haskell takes care of the rest.
16:41:45 <Pseudonym> Like I said, in the worst case it's O(n^2).
16:42:10 <Roey> oh... ok
16:42:16 <Roey> that's why the ^2.
16:42:19 <Pseudonym> Right.
16:42:25 <Roey> because of the two-dimensional aspect of it.
16:43:53 <Pseudonym> Now there are some heuristics that you can kind of apply to this.
16:44:05 <Pseudonym> But they don't fit well.
16:44:34 <Pseudonym> But the algorithms that you can apply heuristics to aren't based on dynamic programming.
16:46:13 <Roey> ok
16:46:36 <Roey> ok now you say dynamic programming as if it is nondeterministic
16:46:41 <Roey> "let haskell figure it out", etc.
16:46:54 <Cale> that's not what nondeterminism is
16:47:01 <Pseudonym> NO, it's not nondeterministic.
16:47:04 <Roey> but.. how is any less dynamic than being in a loop and reacting to specific cases?
16:47:07 <Roey> eh?
16:47:16 <Roey> then what is it?
16:47:24 <Pseudonym> What lazy evaluation gives you is the semantics such that once you've evaluated it, it stays evaluated.
16:47:30 <Roey> (how is dynamic programming not nondeterministic)
16:47:34 <aj> Roey: dynamic programming is a term of art; it means something specific and technical
16:47:34 <Roey> ok
16:47:40 <Pseudonym> Right.
16:47:46 <Pseudonym> Dynamic programming is a specific technique.
16:47:53 <Pseudonym> Basically, it's a kind of memoing.
16:48:04 <Pseudonym> Which is pretty much what is happening here.
16:48:09 <Pseudonym> The "diff" function is being memoed.
16:48:18 <Pseudonym> Much like the fibonacci number is being memoed in the previous example.
16:50:14 <Roey> ok
16:50:23 <Roey> memoing meaning stored
16:50:24 <Roey> ok
16:50:27 <Roey> cached.
16:50:30 <Pseudonym> Right.
16:50:46 <Pseudonym> Dynamic programming is a very common approach to certain problems.
16:50:59 <Pseudonym> It's used a lot in modern compilers, for example, for code generation.
16:51:38 <Roey> what /is/ it?
16:52:03 <Roey> I understand programming where you declare your predicates and then say 'go!' and let the runtime figure it out
16:53:03 <Pseudonym> http://www.sbc.su.se/~per/molbioinfo2001/dynprog/dynamic.html
16:53:09 <Pseudonym> That might help the explanation.
16:53:12 <Pseudonym> G'day shapr.
16:53:32 <shapr> greetz Pseudonym 
16:53:46 <Pseudonym> That's a diff-like problem, showing how you'd implement it in a non-lazy language.
16:53:52 <Pseudonym> I think you'll agree it's easier in Haskell.
16:53:55 <Pseudonym> Once you've read that, anyway.
16:55:14 <Roey> shapr:   hi
16:55:21 <Roey> shapr:  you were explaining gonads to me
16:55:32 <Roey> *monads, sorry
16:55:34 <Roey> slip of the keyboard.
16:55:44 <Pseudonym> Paging Dr Freud!
16:55:58 <Roey> nono I did it on purpose;
16:56:03 <Roey> monads sounds like gonads.
16:56:06 <Roey> I think it's a stupid name
16:56:09 * Pseudonym figured you were
16:56:11 <Roey> even though it is an acronym
16:56:24 <Pseudonym> No, it's a Greek word.
16:56:28 <Roey> oh. ok
16:56:36 <shapr> Roey: well, I gave you the whole explanation.
16:56:36 <Roey> I thoguht it was an acronym.
16:56:47 <Pseudonym> No.
16:56:47 <Roey> shapr: lemme scroll, one sec.
16:56:55 <Pseudonym> It's the Greek equivalent of "element".
16:57:04 <Pseudonym> It refers to something that's indivisible.
16:57:19 <Pseudonym> @wn monad
16:57:23 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
16:57:23 <lambdabot> monad
16:57:23 <lambdabot>      n 1: an atom having a valence of one
16:57:23 <lambdabot>      2: a singular metaphysical entity from which material
16:57:23 <lambdabot>         properties are said to derive [syn: {monas}]
16:57:25 <lambdabot>      [also: {monades} (pl)]
16:57:47 <Pseudonym> What did you think it stood for?
16:57:59 <Roey> <shapr> one of those functions puts something into the type, another of those functions puts together two values of the already filled in type.
16:58:05 <Roey> <shapr> tada, that's a monad.
16:58:11 <Roey> <shapr> A monad is a partially filled in type and two functions.
17:00:09 <shapr> Roey: Except for the monad associative and id laws, that pretty much covers it.
17:01:36 <shapr> hiya Jerub 
17:01:47 <shapr> Roey: monads aren't complicated, they just do a lot of stuff.
17:02:04 <shapr> Roey: seeing some actual monad instances is more interesting than just knowing the definition.
17:02:10 <Pseudonym> I'm thinking that we should never have dropped monad comprehensions.
17:02:14 <Pseudonym> People understand list comprehensions.
17:02:15 <shapr> why?
17:02:21 <shapr> oh, maybe so.
17:02:34 <Pseudonym> And generalising that to monad comprehensions seems like a smaller step.
17:02:34 <Roey> shapr:  I looked up the IO monad.
17:02:44 <Roey> shapr: http://www.syntaxpolice.org/lectures/haskellTalk2/slides/x68.html
17:02:44 <shapr> Roey: that's a tough one to start with.
17:02:59 <shapr> the maybe monad, or the list monad, those are good starters.
17:03:00 * ayrnieu adds shapr's one-line definition to his list.
17:03:11 <Roey> shapr:  ok, I will look those up then.
17:03:18 <Jerub> yeah, monad comprehensions are used in alot of the older papers I read, and I understand them :)
17:03:25 <Pseudonym> Yeah.
17:03:26 <shapr> Roey: http://www.nomaware.com/monads/html/
17:03:27 <Roey> I definitely need to start adding other language types to my reportoire.
17:03:29 <Roey> thanks
17:03:32 <Pseudonym> I understand why they were removed.
17:04:03 <Pseudonym> They make error messages more cryptic, and the first lab exercise that an undergrad does when first learning Haskell is list comprehensions.
17:04:15 <Pseudonym> Seeing error messages littered with monad references would be awful.
17:04:35 <Pseudonym> So I think the transition should be:
17:04:38 <Pseudonym> 1. List comprehensions.
17:04:42 <Pseudonym> 2. The same thing in do-notation.
17:04:55 <Philippa> 3. IO
17:04:57 <Pseudonym> 3. Now let's see what's going on under the covers.
17:04:59 <Philippa> 4. The World!
17:05:02 <Pseudonym> 4. Now IO.
17:05:05 <Pseudonym> 5. Profil!
17:05:09 <Pseudonym> Profit!
17:05:12 <Roey> :)
17:05:13 <Philippa> :-)
17:05:57 <Roey> are lisp, prolog, and ocaml imperative in the same way as Haskell?
17:06:10 <Pseudonym> No.
17:06:20 <Roey> are they all functional languages?
17:06:21 <Pseudonym> Lisp, Prolog and O'Caml are impure.
17:06:25 <Roey> oh, ok.
17:06:27 <Pseudonym> prolog isn't.
17:06:29 <Roey> impure in that what?
17:06:30 <ayrnieu> roey - those are all completely different languages.
17:06:41 <Pseudonym> The others are technically functional, but they're quite different.
17:06:47 <Roey> ayrnieu:  different in terms of what (syntax? yes I know how they look like :)
17:06:52 <Roey> ok
17:06:54 <ayrnieu> roey - although you can much more easily compare O'Caml with Haskell the other two with Haskell.
17:06:54 <Pseudonym> In the same way that C and Modula-3 are different.
17:06:59 <ayrnieu> Roey - no, they are completely different languages.
17:07:21 <Roey> Pseudonym:  that's just a syntax difference.  modula-3 and c are both procedural.
17:07:36 <Pseudonym> And Smalltalk and Java are both technically object oriented.
17:07:42 <Pseudonym> But their differences go deeper than syntax.
17:07:43 <Nioate> Roey: lisp, prolog, and ocaml have side-effecting functions
17:07:45 <Roey> and both are procedural.
17:07:50 <Roey> Nioate:  oh... right right
17:07:56 <Roey> Nioate:  I read that about Haskell
17:08:06 <Roey> Nioate:  that pure functions do not change their parameters 
17:08:08 <Nioate> er, actually I don't know about prolog
17:08:14 <Roey> Nioate:   and that C++'s const comes close to this
17:08:26 <Pseudonym> Prolog is a logic language, not a functional language.
17:08:34 <Roey> Nioate:  isn't a C++ function with all const params a pure function?
17:08:51 <Roey> Pseudonym:  ok.
17:08:56 <ayrnieu> and its having first-class functions doesn't make it a 'functional language' for a useful meaning of that term.
17:09:23 <Jerub> Roey: no! because the c++ function can just affect globals. ;)
17:09:34 <Roey> ah, right right.
17:09:35 <Nioate> Roey: I don't know enough c++ to tell you
17:09:49 <Jerub> Roey: *especially* C++, because you just call someobj.somefunc(); and it has side effects. :)
17:09:57 <Jerub> no arguments at all!
17:10:00 <Roey> Jerub:  right...
17:10:05 <Roey> Jerub:   even if the param is const.
17:10:12 <Jerub> Roey: what param ? ;)
17:10:12 <Roey> Jerub:   it can still be affected like that
17:10:23 <Philippa> Jerub: you're reminding me of my somewhat jokey description of Smalltalk a while back :-)
17:10:34 <Jerub> Philippa: what was that?
17:10:40 <Philippa> "The world's most impure functional language"
17:10:40 <Roey> Jerub:  void func( Object& obj ) { obj.incrementInsanity(); }
17:11:03 <Roey> er
17:11:16 <Roey> void func( const Object& obj )  { obj.incInsanity(); }
17:11:17 <Roey> that
17:11:35 <Roey> that LOOKS like it doesn't modify the parameter, but int he code you se ethat it does.
17:12:09 <Philippa> well, that's C++ for you. Every time the type system makes a guarantee, the language provides a way to break it just in case you know better than the type system
17:12:41 <Roey> perhaps java is better in this respect.
17:12:58 <shapr> I have no respect for Java!
17:13:01 <Roey> :)
17:13:21 <Roey> If someone has to sink to Java, I'd rather they go with Python then.
17:13:26 <Philippa> Java just has a pissweak type system that forces you to poke holes in it anyway
17:13:33 <Roey> right.
17:13:41 <Philippa> I'd love something resembling statically-typed Smalltalk if I had to go OO
17:14:12 <shapr> wow, #darcs is up to 28
17:14:15 <shapr> awesome
17:14:18 <Roey> 29
17:14:27 <ayrnieu> statically-typed Sma... sma... /me collapses onto the floor and jerks randomly as his brain fries.
17:14:43 <shapr> of course, #haskell is 101 :-)
17:14:49 <Nioate> statically typed smalltalk?
17:14:54 <Roey> =)
17:15:06 <jadrian> is there a function/operator   comp' f g a b = f (g a b)  ?
17:15:13 <Philippa> ayrnieu: think about it a moment. I mean, I'd want a /good/ static type system that allows some serious well-typed dynamic friggery...
17:15:20 <jadrian> (f .) . g  works... but I don't really like it...
17:15:26 <ayrnieu> philippa - ow, no, please stop
17:15:27 <Nioate> I thought being dynamic was one of the defining parts of smalltalk
17:15:44 <Philippa> Nioate: one of, yeah, though most of the fun there is the metaclass-type dynamicity
17:16:10 <Philippa> of course, Haskell in the IO monad resembles statically-typed Smalltalk rather a lot
17:17:49 <Pseudonym> It doesn't have the message-passing of Smalltalk.
17:17:57 <ayrnieu> jadrian - er, could you give me an example of where you'd like to use comp' ?  I can't seem to think of one, right now.
17:18:02 <Pseudonym> What you really want is a statically typed Erlang.
17:18:10 * ayrnieu sobs.
17:18:28 * Pseudonym is the world's foremost expert on what you really want
17:18:51 <ayrnieu> philippa - I wish that you could elucidate on the weird aspect of smalltalk that interests you instead of contining to talk about a 'statically-typed' smalltalk.
17:19:11 <ayrnieu> continuing.  Because I don't think that you could really possibly mean that.
17:19:26 <Pseudonym> jadrian: You could use a lambda expression.
17:19:32 <Pseudonym> Or is that too obvious?
17:19:39 <Philippa> Pseudonym: GHC-Haskell in the IO monad = statically typed erlang? ;-)
17:19:42 <Pseudonym> Some people seem to have an aversion to points.
17:19:45 * ayrnieu would use 'f', but perhaps that is too obvious.
17:19:50 <Philippa> though not as well implemented
17:19:50 <Pseudonym> Philippa: True!
17:20:08 <Pseudonym> Philippa: Though Haskell-ports seems a little cleaner than GHC's concurrency stuff.
17:20:28 <Philippa> ayrnieu: Smalltalk does all its looping via tail recursion. So small snippets of Smalltalk code look like extremely side-effect-heavy "functional" code (cf lisp)
17:21:05 * Roey is away: taking off lenses.
17:21:12 <arjanb> couldn't haskell have a magic dot? so that you can write  f . g  no matter how much arguments g takes
17:21:29 <Jerub> arjanb: doesn't haskell have a magic dot?
17:23:03 <dons> @type (.)
17:23:05 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
17:23:40 <jadrian> Pseudonym: that's what I'm using...
17:24:35 <jadrian> Pseudonym: when I need it in the middle of some expression anyway
17:24:56 <Pseudonym> There comes a point, IMO, where you just don't need to give everything a name.
17:25:17 <jadrian> Pseudonym: yeap but sometimes I could use it just to "simplify" function definitions, I like point free style
17:25:33 <jadrian> newfun a b = f (g a b)
17:25:35 <Pseudonym> I agree sometimes.
17:25:42 <jadrian> not going to use a lambda there :)
17:26:01 <Pseudonym> But you know, I sometimes find point-free style more incomprehensible than the equivalent lambda.
17:26:13 <jadrian> yeap
17:26:17 <Pseudonym> I couldn't have told you what (f .) . g did without a lot of head scratching.
17:26:30 <jadrian> yes I understand :)
17:27:26 <jadrian> this is quite readable...   newfun a b = f (g a b)    
17:28:49 <jadrian> still, I wouldn't mind if there was some point free style readable def 
17:29:14 <Pseudonym> Well it's not too bad in SK combinators:
17:29:16 <jadrian> I could come up with my own composition of course, but I'd like to stay with standard operators
17:29:17 <Pseudonym> B (B f) g
17:29:27 <Pseudonym> Where B is (.)
17:29:37 <Pseudonym> It actually makes more sense in prefix form.
17:29:59 <jadrian> (.) ((.) f)
17:30:03 <jadrian> (.) ((.) f) g 
17:30:20 <jadrian> maybe with a B it looks nice
17:30:31 <Pseudonym> And the three-argument version is B (B (B f)) g
17:31:02 <jadrian> hmmm
17:32:05 <jadrian> so this is when types get in your way right 
17:32:14 <arjanb> putting things around f because g has more argument is not neat
17:32:14 <jadrian> in the sense that I cannot do something like
17:32:37 <jadrian> take a list of (.)
17:32:43 <jadrian> and apply them to f
17:34:18 <jadrian> Pseudonym: well this looks nice too  ((f .) .) g
18:13:14 * jemfinch|lambda is bored.
18:13:34 * shapr pounces on jemfinch|lambda 
18:13:48 <jemfinch|lambda> howdy, shapr.
18:13:54 <jemfinch|lambda> when I'm bored, I think of language design.
18:14:10 <jemfinch|lambda> do you happen to know that paper about monadic interpreters?
18:14:19 <shapr> which one?
18:14:40 <Jerub> I love language design.
18:14:42 <jemfinch|lambda> there are many?
18:14:46 <shapr> yes, many.
18:14:50 <jemfinch|lambda> Jerub: spoken like a true Haskellite :)
18:15:03 <jemfinch|lambda> well, I'd gladly accept pointers to the best ones :)
18:17:02 <jemfinch|lambda> maybe I'll write an IRC bot in Haskell or SML.
18:17:09 <Jerub> nooo!
18:17:23 <jemfinch|lambda> Jerub: why not?  It's always fun writing IRC bots.
18:17:42 <shapr> jemfinch|lambda: hack on Yi
18:17:44 <Jerub> jemfinch|lambda: at least document what you do to make it less fun for people following in your footsteps.
18:18:21 <jemfinch|lambda> Jerub: I prefer just to make the code so good that other people feel dumb writing another one.
18:18:26 <jemfinch|lambda> of course, we can see how well *that's* worked out.
18:18:30 <jemfinch|lambda> shapr: what's Yi?
18:18:39 <dash> also, what's wrong with lambdabot
18:18:44 <dash> other than an excess of sarcasm 
18:18:52 <jemfinch|lambda> dash: probably the same thing that's wrong with most programs.
18:18:53 <shapr> jemfinch|lambda: http://www.cse.unsw.edu.au/~dons/yi.html
18:18:57 <jemfinch|lambda> not enough abstraction.
18:18:58 <shapr> dash: haha!
18:19:05 <dash> jemfinch|lambda: you didn't write them? ;)
18:19:07 <jemfinch|lambda> I've got a fever, and the only prescription is...more abstraction!
18:19:29 * shapr adds that the QuotesPage
18:19:31 * dons is trying to get yi-static built with nhc98
18:19:42 * jemfinch|lambda should install darcs.
18:19:43 <shapr> g'day dons!
18:19:48 <dons> surprisingly little gla-exts in there
18:19:50 <dons> hey shapr!
18:19:58 <jemfinch|lambda> I wish the automatic-installation-of-*nix-software didn't suck so much on OSX.
18:20:05 <Jerub> I love espresso stories
18:20:09 <shapr> there's a darcs fink, yeah?
18:20:23 <Jerub> "One more day in this office and I'll go crazy," larry thought. The next day, he did.
18:20:25 <jemfinch|lambda> dash: have you heard of cells?
18:20:39 <jemfinch|lambda> (the library for CL)
18:20:58 <Igloo> dons: Is that yi without hsplugins?
18:21:29 <dons> yep.
18:21:49 <shapr> would be good for running Yi on PalmOS
18:21:50 <jemfinch|lambda> shapr: what's the ideal way to install darcs and a haskell compiler on my OSX box?
18:21:55 <dons> yi-static builds everywhere we've got ghc. and almost is just h98 + ffi
18:21:58 <shapr> heck if I know
18:22:06 <dons> trying to kill off the last couple of import GHC.*'s
18:22:07 <shapr> ask Lunar^ if he's around
18:23:38 <jemfinch|lambda> hmm, I think I'll install MLTon on my laptop.
18:23:40 <shapr> I'm still amazed that hits on the DarcsWiki server went from 4k to 50k after the slashdot article.
18:24:01 <shapr> jemfinch|lambda: darcs is way sexy. You gotta try it.
18:25:56 <shapr> jemfinch|lambda: especially if you want to use Fermat's Last Margin!
18:27:27 <jemfinch|lambda> I plan to.  I just would somewhat like to compile it from source.
18:27:31 <jemfinch|lambda> which means a haskell compiler.
18:28:00 <dash> jemfinch|lambda: no i have not heard of cells
18:28:21 <dash> looks vaguely interesting though
18:29:12 <jemfinch|lambda> dash: yeah, I was thinking of doing a bit of metaclass hacking in Python to have something similar.
18:34:58 <dons> hmm. does ghc have a -98 option? I'm a little surprised I haven' found it yet..
18:35:26 <shapr> -fnoglasgow-exts maybe?
18:35:31 <dons> we've got -fno-glasgow-exts, I guess
18:35:40 <Igloo> -fglasgow-exts is the equivalent of hugs' -98 isn't it?
18:35:54 <dons> -fno-.. you mean?
18:35:59 <dons> nhc has -98 too
18:36:07 <Igloo> Doesn't hugs do things the sensible way round?
18:36:28 <dons> hang on.. are you saying hugs uses -98 to mean -fglasgow-exts ?
18:36:31 <Igloo> "Restart with command line option -98 to enable extensions" "Restart with command line option +98 for Haskell 98 mode"
18:36:38 <dons> ah. ok
18:36:42 <dons> nutty
18:36:53 <Igloo> No, that's sane. It's only unfortunate + is shifted
18:37:02 <Igloo> Ideal would be = and + turn things on, - turns things off
18:37:05 <dons> it's sane, certainly
18:37:11 <Igloo> (well, ideal given + is shifted)
18:37:40 <Igloo> But back to the point, ghc is fairly H98 if you don't turn extensions on, isn't it?
18:37:40 <dons> pity -98 was agreed upon across the board. that would make things easier
18:38:52 <dons> I guess the idea with ghc is that you get H98 by default
18:38:55 <jemfinch|lambda> meh, I guess I'll do some maintenance on Supybot.
18:39:29 <shapr> jemfinch|lambda: bah, make the leap!
18:39:47 <jemfinch|lambda> shapr: what leap is that?
18:40:08 <shapr> into getting Haskell working on OSX
18:40:23 <jemfinch|lambda> nah.  I don't think I really want to write in Haskell.
18:40:27 <shapr> ok.
18:40:57 * shapr goes back to Fermat's Last Margin
18:41:02 <jemfinch|lambda> what's that?
18:41:19 <shapr> it's a research paper margin sharing app
18:42:06 <shapr> have you ever wanted to read the margin notes that other people made on their copy of the monadic interpreters paper?
18:42:39 <dons> oh, this nhc error msg is too cryptic
18:43:14 <jemfinch|lambda> grr.
18:43:17 <jemfinch|lambda> I want a new program to write.
18:43:27 * jemfinch|lambda tries to think of a problem that needs solved.
18:59:46 * shapr loves test-driven-development
19:02:06 <jemfinch|lambda> shapr: even in Haskell?
19:02:16 <shapr> yup
19:02:20 <shapr> that's what I'm doing right now.
19:02:25 <jemfinch|lambda> that's odd.
19:02:40 <shapr> I think it's quite even.
19:02:48 <jemfinch|lambda> heh
19:02:53 <shapr> You should see my test-driven-development version of QuickCheck.
19:02:59 <jemfinch|lambda> let's see it.
19:03:07 <shapr> That is so even it's nearly 2 itself.
19:03:26 * shapr looks for the tgz
19:03:32 <shapr> Have you used QuickCheck?
19:03:38 <jemfinch|lambda> I know of it.
19:03:47 <shapr> know how it works?
19:04:52 <shapr> You create generators that produce test data that should satisfy certain conditions. You'd be surprised how quickly it can find corner cases.
19:05:02 <jemfinch|lambda> yeah.
19:05:08 <jemfinch|lambda> I tried to do a similar thing in SML once.
19:05:13 <jemfinch|lambda> it never really got off the ground.
19:05:16 <jemfinch|lambda> but then I stopped using SML.
19:05:54 <shapr> Thing is, you'd like to know that formerly discovered bugs get fixed and stay fixed. So I added in some code to save the seed that generates failing inputs, and then retest with that at the beginning of later test runs.
19:06:09 <Jerub> oh.
19:06:10 <Jerub> btw.
19:06:12 <Jerub> mysql sucks.
19:06:23 <Jerub> I used to defend it, please consider everything I said about it moot.
19:06:38 <jemfinch|lambda> Jerub: why would you defend such a horrible piece of software?
19:06:49 <shapr> Well, I know mysql sucked when I tried to build it on Irix 5.3. Ever since then I've stayed away from it.
19:06:50 <np_hard> because no one else will!
19:06:57 <shapr> hiya np_hard 
19:07:01 <np_hard> hiya
19:07:06 <np_hard> which software is this?
19:07:08 <np_hard> mysql?
19:07:17 <jemfinch|lambda> shapr: Irix isn't exactly a heavenly operating system itself.
19:07:27 <shapr> jemfinch|lambda: anyway, I can now do test-driven-development with random aka stochastic testing! Is that cool or what?
19:07:32 <jemfinch|lambda> personally, if I were a piece of software, I'd refuse to compile on Irix out of spite alone.
19:07:45 <jemfinch|lambda> shapr: that's pretty cool :)
19:08:01 <np_hard> luckily it's not up to the software, or things on Windows would be broken all the time
19:08:05 <np_hard> ... oh wait ...
19:08:07 <Pseudonym> I remember when Silicon Graphics (as they were called at the time) announced they were considering porting Irix to the IA32.
19:08:32 <Pseudonym> One person commented "We use Silicon Graphics machines _despite_ Irix, not _because_ of it."
19:08:41 <shapr> jemfinch|lambda: you gotta try generative TDD, it's way spiffy.
19:08:57 <Pseudonym> MySQL isn't actually too bad so long as you understand what it is.
19:09:18 <Pseudonym> It's like the JET engine, only it's a server.
19:09:38 <Pseudonym> And sometimes, that's all you need.
19:09:39 <shapr> irix had some nifty points. XFS was great for recovering from a power outage.
19:09:48 <Pseudonym> Oh, definitely.
19:09:58 <Pseudonym> It had some cute stuff in it.
19:10:03 <shapr> but now that open source journaling filesystems abound...
19:10:07 <Pseudonym> But the real selling point was the hardware.
19:10:21 <Pseudonym> And the user-space libraries, like libdmedia.
19:10:27 <jemfinch|lambda> shapr: well, (a) I'm fairly good at writing the test cases for corner cases, and (b) for complex functions (i.e., the ones most requiring testing) the test data, I find, is rarely generable.
19:10:37 <jemfinch|lambda> (at least in my experience with Supybot)
19:11:57 <shapr> It's simpler to write a good generator. And I believe that test data is generable more often than you might think.
19:12:33 <Pseudonym> Personally, it's not the corner cases that I have problems with.
19:12:36 <Pseudonym> It's the complex cases.
19:12:38 <jemfinch|lambda> shapr: well, feel free to look at Supybot's tests and let me know which ones you think would be generable.
19:12:57 <Pseudonym> I test it with some small examples, and it works.  Then I try a big example and it breaks.
19:13:03 <shapr> Also, a good generator only requires knowledge of the datatype, whereas being fairly good at checking corner cases means you need to understand the code you're testing.
19:13:31 <shapr> So, a good generator is something other developers can use later to test their code that you didn't foresee.
19:13:39 <jemfinch|lambda> perhaps.
19:13:52 <jemfinch|lambda> shapr: so what are three things you'd add to Haskell if you got the chance?
19:14:03 <jemfinch|lambda> (i.e., if you could snap your fingers and they'd be added)
19:14:10 <shapr> 1. Advertising
19:14:18 <shapr> 2. Funding
19:14:25 <jemfinch|lambda> I meant the language :)
19:14:28 <shapr> oh
19:14:30 <shapr> Well,
19:14:31 <jemfinch|lambda> surely you don't think it's perfect :)
19:14:33 <shapr> doesn't that count?
19:14:42 <jemfinch|lambda> no, that's just the community.
19:14:46 <shapr> oh, no I don't think it's perfect.
19:15:01 <jemfinch|lambda> Haskell will never have the same popularity as Python, while the average IQ of programmers remains the same.
19:15:16 <shapr> I think programmers IQs are not the problem.
19:15:20 <jemfinch|lambda> I do.
19:15:23 <Pseudonym> I'd sooner hire a Python programmer than a Java programmer, nonetheless.
19:15:26 <jemfinch|lambda> when was the last time you took a CS class?
19:15:32 <jemfinch|lambda> Pseudonym: well, yes :)
19:15:33 <shapr> I've never taken a CS class.
19:15:36 <jemfinch|lambda> Pseudonym: I'm for hire, btw.
19:15:37 <jemfinch|lambda> :-P
19:15:43 <Pseudonym> :-)
19:15:49 <Pseudonym> Pity I don't have any capital.
19:15:57 <shapr> But I've worked with a bunch of programmers.
19:16:15 <np_hard> is someone hiring?
19:16:15 <np_hard> :)
19:16:18 <Pseudonym> My in-my-head business that I want to start some day when I have enough funding will require one or two Haskell programmers.
19:16:27 <shapr> Most of them did just fine once they understood something, but few of them put in the effort to learn new things and improve their existing skills.
19:16:46 <jemfinch|lambda> Pseudonym: I can't imagine a business needing more than a couple or three Haskell programmers.
19:16:57 <Pseudonym> Right, because they'd be so productive.
19:17:02 <jemfinch|lambda> exactly.
19:17:02 <np_hard> unless
19:17:07 <shapr> So, I posit that if Haskell had advertising and funding, it could easily be as popular as Python.
19:17:18 * jemfinch|lambda may not like some things about Haskell, but he'd still pick a job programming in Haskell over just about any other language.;
19:17:20 <np_hard> it was a consulting firm :)
19:17:28 <jemfinch|lambda> shapr: no, it couldn't.
19:17:35 <Pseudonym> If I could give anything to Haskell, it'd be a rewrite of GHC.
19:17:39 <shapr> jemfinch|lambda: you haven't convinced me.
19:17:46 <Pseudonym> Remove all the cruft, make it easier to build and bootstrap.
19:18:07 <jemfinch|lambda> shapr: I'm taking a graduate-level CS class right now with 20-30 other CS students.  We're going over Lisp and Scheme.  Not even the *professor* gets this crap right.  It took him an *entire* class to explain dynamic scoping.
19:18:16 <np_hard> you don't think the pure functional mindset represents a significant barrier that Python doesn't share?
19:18:30 <jemfinch|lambda> shapr: I'm serious, most programmers simply aren't smart enough to learn, let alone use, Haskell.
19:18:34 <np_hard> jemfinch|lambda: where do you go to school so I never go there?
19:18:35 <np_hard> :)
19:18:42 <Pseudonym> Actually, jemfinch does have a point.
19:18:47 <shapr> ??
19:18:58 <Pseudonym> Most programmers who use OO languages don't actually program in an OO style.
19:19:11 <Pseudonym> They program in an imperative style with objects as glorified modules.
19:19:15 <monochrom> I'm an elitist.  I couldn't care less what the bottom 99% can and cannot understand.
19:19:26 <shapr> I think that many workers try to get away with as little effort as will let them keep their job.
19:19:31 <Pseudonym> So it could be argued tht most programmers aren't smart enough to use OO languages effectively either.
19:19:40 <shapr> For those people, IQ does not matter, they will only know enough to stay hired.
19:19:44 <np_hard> Pseudonym: we've got one of those at work, thinks Java is the bee's knees and doesn't do any sort of real OO design
19:19:44 <Pseudonym> It's just that you can fake it better in, say, Java than in Haskell.
19:19:45 <jemfinch|lambda> monochrom: your lack of care, unfortunately, does not reduce the impact of that majority.
19:20:08 <Pseudonym> np_hard: You don't have to do formal OO design, of course.
19:20:21 <Pseudonym> You need to be able to think that way, though.
19:20:21 <jemfinch|lambda> Pseudonym: because there's more rote busywork to be written in Java than in Haskell.
19:20:21 <monochrom> I am not interested in reducing its impact.
19:20:41 <jemfinch|lambda> monochrom: yes, but what we're talking about is the impact.
19:20:55 <shapr> I believe that programmers who are willing to make an effort to find better ways of using their existing tools will do just fine with Haskell.
19:20:59 <monochrom> Alright, I'll listen.
19:21:29 <Pseudonym> Even if I never get paid for writing a single line of Haskell, knowing Haskell has made my other programming better.
19:21:50 <jdrake> how long does it take to compile ghc? Its been going for about 6 hours now on a 700mhz g4
19:21:52 <jemfinch|lambda> Pseudonym: I feel the same about O'Caml.
19:22:01 <jemfinch|lambda> I write typesafe code in Python now because I learned and used O'Caml for a couple years.
19:22:02 <Pseudonym> Yes, I can certainly believe that.
19:22:06 <np_hard> pseudonym: oh sure, you don't need to go whole-hog Rational process
19:22:28 <monochrom> Pseudonym puts it well.  I write more Java+C++ then *ml+haskell, but the latter proves to improve my former.
19:22:43 <np_hard> Pseudonym: but I would expect to see a modicum of understanding about interface vs extending classes, design patterns, polymorphism, etc
19:22:44 <shapr> jemfinch|lambda: I believe that motivation is the limiting factor, not IQ.
19:22:56 <jemfinch|lambda> shapr: well, I disagree :)
19:23:06 <jemfinch|lambda> anyway, I think that when I write a compiler I might target MLTon.
19:23:11 <np_hard> jdrake: GHC takes a hella long time on my Mac
19:23:18 <Pseudonym> np_hard: Right.
19:23:29 <Pseudonym> Actually, I think that's true, shapr.
19:23:43 <Pseudonym> An interested person will beat an uninterested smart person.
19:23:47 <jdrake> think I might just apt-get it
19:23:50 <ayrnieu> Haskell certainly seems to suggest a more thoughtful way of looking at programs -- I've done a great deal of work, on paper, just writing down type definitions.
19:23:52 <jemfinch|lambda> Pseudonym: I disagree.
19:24:21 <ayrnieu> Or a differently-thoughtful way, if you like =)
19:24:31 <shapr> Practiced skill beats raw talent everytime.
19:25:04 <monochrom> I am a data point in support of Pseudonym's claim.  I am an interested and not-so-smart person.  I have beated smarter persons, e.g., my supervisor. :)
19:25:14 <np_hard> monochrom: good show :)
19:25:17 <ayrnieu> An assertion either way smacks of religion, shapr, like saying "Justice will always prevail." =)
19:25:54 <shapr> ayrnieu: well, sometimes you meet the Leonardo of whatever you're doing, and in that sort of case, raw talent nukes every bit of skill you have.
19:26:02 <np_hard> the ECMAScript I write for my Real World(tm) job would probably throw my co-workers for a loop ... luckily since that language is surprisingly expressive there isn't much of it to read
19:26:05 <shapr> happily, that's rare.
19:26:18 <ayrnieu> I imagine that even Leonardo had a bit of motivation and developed skill.
19:26:45 <shapr> Yes, he worked hard at developing his natural talent.
19:26:48 <monochrom> smart+motivated+diligent people are *dangerous*
19:26:54 <shapr> truly.
19:27:12 <np_hard> monochrom: hey, you've stumbled on the raison d'etre of public schooling
19:27:20 <shapr> I think I'm motivated, and definitely not diligent. And somedays I think I'm smart.
19:27:38 <np_hard> let's keep those kinds of people to a minimum and give them a sense of entitlement and investment in the status quo
19:27:38 <ayrnieu> monochrom - hence the role of all societies in attacking their own frightfully tenacious smart people.
19:28:09 <Pseudonym> My wife is an art major.  Her field is full of examples.
19:28:20 <Pseudonym> People who think they're artists but who don't want to study art.
19:28:38 <Pseudonym> Imagine if musicians thought that way.
19:28:42 <shapr> jemfinch|lambda: thing is, I did high school with several people who were significantly smarter than me. Two become farmers, one offed herself, one got a job doing machine work, etc etc
19:28:46 <np_hard> don't they?
19:28:58 <np_hard> have you seen MTV recently, Pseudonym?
19:28:59 <np_hard> :)
19:29:05 <Pseudonym> Uhm... no.
19:29:12 <Pseudonym> a) We don't get it here.
19:29:18 <ayrnieu> I haven't seen MTV in *years*, np_hard.
19:29:30 <Pseudonym> b) MTV is about shiny things, not music.
19:29:36 <shapr> jemfinch|lambda: that was in a graduating class of thirty-nine people...
19:29:36 <ayrnieu> three to four years, actually.
19:29:38 <np_hard> well, it doesn't take much to imagine if musicians thought they were musicians without studying music.
19:30:23 <ayrnieu> I didn't get particularly interested in music until I happened to see a (probably on VH1, possibly on MT) show on Nirvana.
19:30:29 <monochrom> Lots of teenage pop singers in Hong Kong are like that.  The record companies there are to be blamed.
19:30:54 <Pseudonym> True.
19:31:01 <Pseudonym> I was thinking about classical musicians.
19:31:01 <shapr> Then you hear someone like Norah Jones, who has gobs of talent, and you see her improve her skills each year.
19:31:11 <monochrom> Those singers can't sing!  (Nevermind knowing the most basic music theory.)  They just have cute faces.
19:31:22 <Pseudonym> Though jazz and blues are good examples.  You have to be good to do that.
19:31:42 <np_hard> lots of the jazz and blues greats didn't study much music
19:32:06 <np_hard> I think the arts are different from science and engineering
19:32:32 <shapr> jemfinch|lambda: I think you overestimate the difficulty of Haskell. I can't think of anything that I have learned that was actually *difficult* to understand. 
19:32:34 <np_hard> you can get away with knowing less about what came before, since the arts are very contextual anyway
19:32:49 <np_hard> shapr: I agree, for what it's worth
19:32:50 <Pseudonym> Actually, no you can't.  Not really.
19:33:02 <Pseudonym> Unless you're a really good self-promoter.
19:33:10 <np_hard> Good point
19:33:35 <Pseudonym> Which is what those Java weenies are trying to be.
19:33:50 <Pseudonym> Look at me!  I know the currently trendy technology!  I'm With It(tm)!
19:33:52 <shapr> There may be understandings that really are hard enough that only a few percent of humans can handle them. Maybe stuff like the theory behind superconductors. But even then, I suspect there are just a few basic principles that interact in unexpected ways.
19:34:12 <Pseudonym> Britney Spears understands that stuff.
19:34:28 <Pseudonym> http://britneyspears.ac/lasers.htm
19:34:58 <Pseudonym> Oh, you said superconductors, not semiconductors.
19:34:59 <Pseudonym> Still.
19:35:18 <monochrom> hahahaha
19:35:37 <shapr> Haskell just isn't that complicated.
19:36:10 <monochrom> How does superconduction help you understand Haskell?! :D
19:36:14 * ayrnieu wonders, idly, at the possible workings of an art school directed at programming as an art.
19:36:46 <shapr> In many ways Haskell is simpler than procedural programming. Code behaviour doesn't change, for example.
19:36:49 <Pseudonym> Programming is a craft, not an art.
19:36:53 <Pseudonym> Personal opinion.
19:37:05 <Pseudonym> We're artisans, not artists.
19:37:33 <shapr> I think we're artificers.
19:37:35 <Pseudonym> Our purpose is not to reflect reality in ways that make people think or understand something better.  We make things for people to use.
19:37:50 <monochrom> I think there are enough people treating programming as an art.
19:38:11 <shapr> Yes, they get the brush-off from me.
19:38:16 <shapr> I'm canvassing against them.
19:38:28 <shapr> They keep painting themselves into corners.
19:38:40 * shapr gives up on the art jokes
19:38:41 <ayrnieu> Pseudonym - I guess we can't really have a school for it, then.  I'll go back to Guido's programming-as-one-of-four-R'.
19:38:49 <ayrnieu> 'R's.
19:39:21 <shapr> Sometimes I think programming is most like extemporaneous speaking.
19:40:16 <shapr> You require a large amount of background knowledge, and you often don't know the subject matter before you have to create a structure communication on that subject.
19:40:40 <Pseudonym> ayrnieu: I agree, actually.  Unlike Computer Science and Software Engineering, mere programming should be taught as an apprenticeship.
19:40:53 <monochrom> I also think most places teach programming as an art (they tell you what tools you have, then you're on your own figuring out when to/not use them), though not competently (they don't make you read good code enough).
19:41:01 <ayrnieu> I could agree without the 'mere', Pseudonym.
19:41:12 <shapr> jemfinch|lambda: anyway, come up with some proof for that hypothesis or be accused of elitism.
19:41:20 <Pseudonym> By "mere programming", I refer to the mere writing of programs.
19:41:26 <Pseudonym> Not analysis, not design, not engineering.
19:41:39 <ayrnieu> and I won't try to keep up with the moving post of elitist neologisms for 'programming' -- and accept that I already use that to sneer at 'coding' and 'code monkeys'.
19:41:48 <Pseudonym> It's not what I do, and it's probably not what you do.
19:42:00 <Pseudonym> I'm talking about Visual Basic script kiddies.
19:42:17 * shapr goes to sleep
19:42:26 <Pseudonym> Night.
19:42:47 <Pseudonym> And I'm not being elitist, either.
19:42:58 <jemfinch|lambda> shapr: I'm fine being accused of elitism.
19:42:58 <monochrom> What hypothesis did jemfinch|lambda make that requires evidence?  I thought I was the only elitist here. :D
19:43:02 <Pseudonym> Apprenticed trades people make good money.  Sometimes better than I do.
19:43:20 <jemfinch|lambda> shapr: come up with some proof for *your* idea or be accused of naivete :)
19:44:00 <np_hard> the issue is there is no professional or trade organization devoted to doing this kind of training, apprenticeship, licensure
19:44:19 <np_hard> the organizations that are there are beholden to academia and/or industry
19:44:35 <np_hard> which have different priorities than making programmer more effective
19:45:06 <monochrom> Sun has exams to certify Java coders... :)
19:45:13 <np_hard> exactl
19:45:17 <np_hard> er, exactly
19:45:39 <np_hard> Hardware and software vendors are the last people you want to entrust this to
19:46:14 <np_hard> imagine if every HMO had their own USMLE
19:46:29 <np_hard> or every law firm had their own boards
19:46:50 <np_hard> substitute US for appropriate country in USMLE
19:46:50 <np_hard> :)
19:46:55 <monochrom> This is so Dark Age.
19:49:04 <ayrnieu> wikipedia says that Europe had guilds about three hundred years before the 'dark ages', however.
19:49:16 <monochrom> OTOH watching this rather strange industry unfold its history is sometimes rather comedic, cf. the soap opera a few years ago of Apple sues Microsoft, then Xerox sues Apple.
19:49:22 <ayrnieu> er, no, nevermind =)
19:49:29 <dash> "dark ages" is a silly term :)
19:49:39 * ayrnieu learns to read more than the first few words of the first sentence of a wikipedia entry.
19:49:50 <monochrom> Yes ayrnieu that means our age is even worse than the Dark Age.
19:49:52 <ayrnieu> guilds arose during the dark ages, then.
19:51:16 <ayrnieu> "In cosmology's Big Bang theory, the term *dark ages* refers to periods of comparatively little starlight emission, during the early formation of the universe. This would have occured after decoupling and before the first burst of star formation."
19:54:09 <Pseudonym> How long did that last?
19:55:04 <monochrom> 100 million years
19:59:57 <cm> does the wxhaskell author happen to idle in here? :-)
20:00:07 <cm> [hello world]
20:00:39 <dons> nope, don't think so
20:01:52 <cm> myum
20:03:02 <cm> ghci seems to crash when I call "start" twice
20:03:42 <dons> mm. I actually think i've had a conversation with Daan about that. I might be wrong, but I think there is no way around it
20:04:15 <Jerub> they're trying to take my linux machine away from me. :(
20:04:45 <cm> dons: aww :(
20:05:10 <cm> dons: can't he hack ghci so that the REPL is evaluated inside the "start"? ;-)
20:05:35 <dons> bah
20:07:12 <cm> do you see a better way?
20:07:40 <cm> it's kinda sad.. wxhaskell+ghci would be very nice for prototyping :)
20:08:15 <dons> I'm sure Daan would welcome patches
20:08:30 <tintin> hello all 
20:09:20 <cm> dons: so do you have a solution in mind?
20:10:07 <dons> you've got the bug .. you write the patch. the law of oss
20:10:21 <tintin> OT: is ocamal a functional programming language ?
20:10:51 <dons> yep
20:11:25 <cm> dons: i don't mean a meta-solution. but I guess "there is no way around it" says you don't.
20:12:45 <dons> as I said "I think" I know the bug, and "I might be wrong"
20:12:57 <cm> fair enough
20:13:44 <dons> I don't use wxHaskell, but the one conversation I've had with the author was  when I think he mentioned this very issue.
20:14:19 <dons> cool. yi has undo!
20:14:31 <dons> bout time, too, says I.
20:15:11 <cm> kk
20:15:12 <cm> nice :)
20:15:34 <jdrake> Is there anything you could not do with haskell
20:16:01 <cm> bring peace to the world ;)
20:16:08 <dons> in what sense? is Haskell turing complete, you mean?
20:16:12 <jdrake> hmm, i should rephrase
20:16:15 <cm> dons: where can I get yi?
20:16:28 <dons> http://www.cse.unsw.edu.au/~dons/yi.html
20:16:31 <jdrake> Is there any program you could not do with haskell
20:17:22 <cm> thx
20:17:23 <jesse98> how do you write a non-deterministic program in haskell? for example a server that doesnt know how many clients will send requests to it?
20:17:51 <dons> you break out of pure functionality, and into the real world.
20:17:57 <tintin> yes a time critical algorithm would still be in c ...
20:18:03 <dons> how else could we do getChar..
20:18:03 <cm> IO, and the stuff in the hierarchical libs
20:18:32 <dons> tintin: but it doesn't mean you _couldn't_ write a time critical app in Haskell (or Erlang, for example)
20:19:08 <dons> jesse98: there are maybe half a dozen web servers written in Haskell, these days
20:19:10 <tintin> dons: yes i completely agree but for a while longer programmers will be expendable ... no cpu ...
20:19:15 <Jerub> erlang is soft-realtime apparently.
20:19:16 <jesse98> but IO is in some sense determinsitic because monads bundle up the state of the world preserving referenrial transparency
20:19:21 <jdrake> To be completely hypothetical... In 1000 years and all the progress one might infer from that - Would there be any reason not to use Haskell or its decendants... 
20:19:33 <jesse98> and they rely on external c code dons?
20:20:27 <dons> they might reuse C libraries, I'm not sure. There are a couple of OSs written in Haskell, including the device drivers
20:20:45 <dons> you can poke bits around. that's all you need, right?
20:21:02 <jdrake> If in a book one wanted to describe what language or languages were being used in the far future would it be presumable that functional languages such as haskell would be more in use
20:21:20 <Pseudonym> There's a difference between time-critical and real-time.
20:21:30 <Pseudonym> Every program is time-critical in some sense.
20:21:33 <jesse98> i dont understand monads well enough to have a good sense of how well they can handle sticky stuff like non-determinism
20:21:50 <Pseudonym> If the program is going to take more than two years to run, you're better off waiting a year and buying a faster computer, for example.
20:22:08 <jesse98> i guess exceptions (as flow of control) is another place where functional languages have problems
20:22:21 <Pseudonym> And a program that computes the monthly payrolls must take less than a month to run.
20:22:29 <cm> jesse98: how so?
20:22:35 <wossname> pseudonym, how about running the program for a year, suspending the state and injecting it into the next computer?
20:22:51 <jesse98> exceptions expose order of evaluation which screws up ref trans
20:22:52 <Pseudonym> wossname: If you plan to do that, then I guess that'd work.
20:23:15 <Pseudonym> jesse98: We have a cure for that.
20:23:22 <Pseudonym> In Haskell, exceptions may only caught in the IO monad.
20:23:38 <jesse98> yeah, emasculating exceptions so that they aren't a control flow operator...
20:23:46 <Pseudonym> Well, they're not.
20:23:59 <Pseudonym> Exceptions are a mechanism for handling undesired events.
20:24:08 <Pseudonym> They're not a general control flow operator.
20:24:23 <jesse98> i think they are: they're a way for a (nested) function to cleanly report that it cant proceed
20:24:55 <jesse98> having to propagate exception info thru every function in the call chain isnt clean imo
20:25:44 <tuomov> dependent types could be used to make most errors in purely functional code obsolete
20:26:23 <jesse98> there will always be real world errors, network errors for example
20:26:31 <Pseudonym> If you're planning to use "exceptions" as a general control flow operator, then you can do that.
20:26:43 <Pseudonym> It's not like Java where you have to say what kinds of exceptions may be thrown.
20:26:46 <tuomov> yes, in IO code there will be errors
20:26:49 <cm> jesse98: but exceptions propagate themselves. and i think you can use them for general control flow.
20:26:50 <Pseudonym> It's a binary decision: Exceptions or no exceptions.
20:26:52 <jesse98> how can that be done without breaking ref trans Pseudonym?
20:27:09 <cm> jesse98: for instance, doing it inside the IO monad
20:27:14 <Pseudonym> You can do it in the same way that you can do IO without breaking referential transparency.
20:27:28 <Pseudonym> You could use continuations, for example.  Or an error monad.
20:27:29 <tuomov> but thinks like 'foo _ = error "We can't handle this pattern."' would be much rarer with dep.types
20:27:29 <jesse98> but then you have to use monads for every function in the call chain
20:27:58 <Pseudonym> No, only for every function through which you're planning to use exceptions as a general flow operator.
20:28:05 <Pseudonym> As opposed to using exceptions as exceptions. :-)
20:28:07 <jesse98> so a local change (introducing an exception) has these awful global effects on the code
20:28:42 <Pseudonym> Actually, it's not referential transparency or purity that's the problem here.
20:28:46 <Pseudonym> The problem is laziness.
20:28:58 <Pseudonym> You can return a data structure with unevaluated parts.
20:29:05 <jesse98> that just compounds the problem
20:29:13 <cm> jesse98: but it has those too in Java.
20:29:21 <tuomov> no, the problem isn't laziness, it's partial evaluation
20:29:22 <Pseudonym> And the exception doesn't get raised until you actually evaluate it, which could be anywhere.
20:29:32 <Pseudonym> tuomov: I'm not sure about that.
20:29:33 <cm> jesse98: exception specifiers which propagate etc..
20:29:36 <Pseudonym> ML has first-class continuations.
20:29:37 <jesse98> you have the same problem with an eager language unless you completely specify the order of evaluation everywhere which sucks
20:29:48 <Pseudonym> And an exception system much like jesse98 wants.
20:30:05 <jesse98> ML isnt pure functional either...
20:30:11 <Pseudonym> It's not pure, no.
20:30:34 <Pseudonym> But it could be made pure.
20:30:48 <Pseudonym> The only thing stopping it being pure is historical baggage.
20:31:08 <jesse98> doesn't ML have ref cells?
20:31:14 <jdrake> oui
20:31:20 <Pseudonym> Yes, but you could remove those.
20:31:33 <Pseudonym> And ML could still have exceptions and first-class continuations.
20:31:38 <Pseudonym> And no ref cells and pure IO.
20:31:50 <Pseudonym> And everything would be fine.
20:31:57 <tuomov> hmmm.. well.. lazyness and partial evaluation are quite the same thing..
20:32:00 <jesse98> you'd have to nail down order of evaluation everywhere tho
20:32:30 <jesse98> for example function args always have to be evaluated left to right, expressions can only be evaluated in this order, etc
20:33:14 <jesse98> the classic example is, (1/0) + raise "urk"
20:33:18 <tuomov> the problem is infinite data structures; otherwise exceptions would be equivalent to lifting everything to Maybe and testing for Nothing
20:33:40 <jesse98> if the catch handler does something different depending on what was thrown you break ref trans
20:33:44 <tuomov> but you can't check if building part of an infinite data structure fails
20:34:09 <Pseudonym> Hang on, what do you mean by "referential transparency"?
20:34:34 <jesse98> if I call f with x, f always returns the same value for the same values of x
20:34:38 <Pseudonym> Right.
20:34:48 <Pseudonym> So you don't need to nail down evaluation order, you just need to make it consistent.
20:34:52 <arauko> anyone knows a good usenet server?
20:35:16 <jesse98> consistent how?
20:35:59 <Jerub> arauko: groups.google.com ;)
20:36:08 <Pseudonym> Hmmm.
20:36:12 <Pseudonym> Let me think about that.
20:36:36 <cm> what's the problem with just using "the same evaluation order every time"?
20:36:52 <Pseudonym> Even in imperative languages, though, there's a lot of freedom to choose evaluation order even if it's fixed.
20:37:04 <cm> (wouldn't that be ref trans wrt to a given implementation?)
20:37:05 <Pseudonym> Because it's often easy to prove that two operations can be reversed in order.
20:37:08 <jesse98> it overly constrains the optimizer and rules out techniques like parallalel or speculative evaluation
20:37:33 <cm> jesse98: as long as you optimize at compile time, that's no problem?
20:38:11 <Pseudonym> It doesn't rule them out at all.
20:38:18 <jesse98> no, it's a big problem, for example I think it'd make common subexpression evaluation impossible
20:38:24 <Pseudonym> Even imperative compilers do parallel and speculative evaluation.
20:38:31 <Pseudonym> It's critical for superscalar CPUs, in fact.
20:38:46 <jesse98> that's because imperative compilers dont worry about preserving ref trans
20:39:12 <Pseudonym> They do if the language says so.
20:39:25 <jesse98> then its not an imperative language...
20:40:43 <cm> nn
20:41:01 <Pseudonym> It could be.
20:41:23 <Pseudonym> Some imperative languages, for example, let you tag functions as "pure".
20:41:45 <Pseudonym> But speculative evaluation and parallel evaluation is even more critical at the assembly level.
20:41:56 <Pseudonym> Where referential transparency is already dealt with.
20:41:58 <jesse98> and which of those let you catch exceptions in a pure function?
20:43:34 <Pseudonym> That problem is finessed at the assembly level.
20:43:43 <Pseudonym> The only exceptions you can get there are hardware traps.
20:44:00 <Pseudonym> And most superscalar CPUs allow you to speculatively execute stuff which doesn't trap.
20:44:01 <jesse98> asm language doesnt even enter into it Pseudonym
20:44:07 <Pseudonym> Sure it does.
20:44:18 <jesse98> it's a completely different discussion
20:44:23 <Pseudonym> Compilers which compile to assembly language do speculative and parallel execution.
20:44:36 <Pseudonym> It's the only way to compile for an Itanium, for example.
20:45:02 <jesse98> i'm talking about speculatively evaluating high-level expressions in a separate thread which is *wholly* different from whatever the processor may do
20:46:22 <Pseudonym> Understood, but it's still speculative execution.
20:46:48 <Pseudonym> Obviously if the compiler is allowed to create new _threads_ at will, that's a different kettle of fish.
20:47:13 <jesse98> but it can in a pure functional language...
20:48:30 <Pseudonym> So riddle me this.  You're doing speculative execution, and you find an exceptional condition.
20:48:32 <Pseudonym> What do you do?
20:49:06 <jesse98> that's the point Pseudonym, exceptions as flow of control are hosed in pure functional languages
20:49:26 <Pseudonym> Well, what would you do in any language which supported it?
20:49:48 <Pseudonym> Whether the language is pure or not.
20:50:22 <jesse98> well you have to save the result of that thread, if it threw an exception you'd save the exception. and raise it when the original thread tried to get the value
20:50:49 <Pseudonym> Right.
20:51:01 <Pseudonym> So how is this any different in a pure language?
20:51:40 <jesse98> it's not, but it does mean that compilers aren't free to re-order expressions
20:52:12 <Pseudonym> Yes they are, so long as the re-ordered expression is treated as speculative.
20:52:55 <jesse98> you cant just speculatively evaluate every damned thing, too much overhead
20:53:08 <Pseudonym> No, you can't, but my point is this:
20:53:19 <Pseudonym> Imposing an evaluation order doesn't mean you have to stick to that evaluation order.
20:53:24 <Pseudonym> It just means it has to look like you do.
20:54:11 <Pseudonym> If you have, in the canonical evaluation order, F followed by G, then you can compute G followed by F, so long as G is speculative.
20:54:51 <Pseudonym> The other saving grace is that it's easy to optimise for, since you expect that throwing exceptions is the uncommon case.
20:54:59 <jesse98> yeah, and exceptions *expose* the order the compiler chooses
20:55:04 <jesse98> which breaks ref trans
20:55:07 <Pseudonym> No they do not.
20:55:21 <Pseudonym> You speculatively execute G.  If it throws an exception, you save it.
20:55:37 <Pseudonym> You then execute F.  If it succeeds, you throw the exception that G raised.
20:55:46 <jesse98> sure, but you're introducing a *lot* of overhead all over for a rare case
20:56:07 <Pseudonym> Throwing exceptions is the rare case.  Or it should be.
20:56:20 <Pseudonym> If you throw no exceptions, you execute G then F.
20:56:49 <jesse98> you still need code to save those exceptions
20:56:59 <jesse98> even if they aren't actually thrown
20:57:11 <Pseudonym> Which you have to do anyway if your language does speculative execution.
20:57:20 <jesse98> and code to ensure that they are thrown from the correct place
20:57:46 <jesse98> like I said spec exec isnt something thats going to happen a lot due to overhead
20:57:49 <Pseudonym> I don't think you'd need much code.  Surely it could be handled in a common part of the run-time support system.
20:59:09 <jesse98> when you're talking about expressions and sub-expressions any additional code can be important
20:59:49 <Pseudonym> Well exception handling should impose more or less no run-time overhead to non-exception-throwing code.
21:00:42 <jesse98> if you're spec evaluating every damn expression you will have lots of overhead
21:01:05 <Pseudonym> Ah, but you're only doing that if, for some reason, you want to reorder two expressions that you can't see inside of.
21:01:15 <Pseudonym> I don't know why a compiler would want to do that.
21:01:24 <jesse98> compilers want to reoder expressions all the time
21:01:37 <Pseudonym> Yes, but not ones they know nothing about.
21:02:56 <jesse98> sure they do, a compiler can easily merge common sub-expressions for example
21:03:14 <Pseudonym> Ah, now common sub-expressions are slightly different.
21:03:20 <jesse98> if p f(g(x), a) else h(g(x), b)
21:03:39 <Pseudonym> No, they're not common subexpressions.
21:03:53 <Pseudonym> Well, they're not _redundant_ subexpressions.
21:04:25 <Pseudonym> Hoisting the common g(x) actually reduces the amount of straight-line code in that example.
21:04:36 <Pseudonym> And it doesn't remove any redundancy along any execution path.
21:04:48 * jesse98 rolls his eyes
21:05:36 <Pseudonym> Here's a better example:
21:05:46 <Pseudonym> f(if p then g(x) else 1, g(x))
21:05:54 <Pseudonym> g(x) is partially redundant there.
21:06:39 <jesse98> you've lost the plot Pseudonym
21:07:00 <Pseudonym> No, I haven't.  Actually, I'm being fairly pragmatic.
21:07:20 <Pseudonym> Compilers don't want to reorder expressions at will.
21:07:21 <jesse98> no, you're picking nits
21:07:25 <Pseudonym> They only want to do it when they think it'll help.
21:07:42 <jesse98> the point is that they *do* want to re-order expressions
21:07:42 <Pseudonym> That's actually a fairly important principle.
21:07:50 <Pseudonym> Yes, but not _all_ expressions.
21:08:02 <jesse98> doesnt matter
21:08:07 <Pseudonym> And, in particular, they don't want to re-order expressions they don't know anything about.
21:09:07 <jesse98> they are perfectly free to reoder expressions as long as they can prove they will stil terminate (which is why I wrote my snippet as I did)
21:09:15 <Pseudonym> Ahhhhh.
21:09:24 <Pseudonym> Now here's a critical thing about Haskell.
21:09:47 <Pseudonym> It's also true of strongly-deterministic logic languages, incidentally.
21:10:20 <Pseudonym> A raised exception is identical to non-termination in non-IO code.
21:10:30 <Pseudonym> In the sense that it has the same semantics.
21:10:40 <Pseudonym> Not the same operational semantics, since non-termination can't be caught.
21:10:40 <np_hard> bottom
21:10:43 <Pseudonym> Right.
21:10:57 <Pseudonym> So when you say "they are perfectly free to reoder expressions as long as they can prove they will stil terminate"...
21:10:58 <jesse98> somehow I suspect that that definition would irk programmers
21:11:10 <Pseudonym> Haskell doesn't make the distinction between non-termination and raising exceptions.
21:11:21 <Pseudonym> In the static semantics sense.
21:11:43 <jesse98> haskell doesnt have flow-of-control exceptions either so I dont see how appealing to haskell's definition of exception helps matters
21:11:46 <Pseudonym> From a programming language semantics POV, it's actually very clean.
21:12:05 <Pseudonym> Well, Haskell is a good example of a pure language with exceptions which causes no semantic issues.
21:12:11 <Pseudonym> Because you can only catch exceptions in IO.
21:12:29 <jesse98> I agree, but I dont think it's a sound method from an enginnering stand-point
21:13:10 <jesse98> just like the lambda calculus is elegant and clean, but not something you want to use for real work (unadorned)
21:13:56 <Pseudonym> I don't know what kind of code you write, but I typically find that my exceptions are caught at a very high-level.
21:14:09 <jesse98> yes
21:14:10 <Pseudonym> For example, in a server, I'd typically catch them in code which is handling the network connection.
21:14:14 <Pseudonym> Where IO is available.
21:14:38 <jesse98> but requiring that all of the intervening code use monads just for the sake of exceptions seems to me pretty bad
21:14:49 <Pseudonym> Which you don't need to.
21:14:57 <tuomov> you should try to mimimise IO usage
21:14:57 <Pseudonym> Because you only need IO where you _catch_ the exception.
21:15:02 <Pseudonym> Not where you _raise_ it.
21:15:30 <jesse98> no? if some deeply nested function wants to raise an exception every guy between that point and where the exception is handled needs to use a monad, correct?
21:15:39 <tuomov> no
21:15:40 <Pseudonym> No.
21:15:59 <tuomov> but in non-IO could exceptions should be very exceptional
21:15:59 <Pseudonym> You need to be in the IO monad at the point where the exception is handled.
21:16:07 <Pseudonym> That's it.
21:16:09 <jesse98> well how the hell does it work? if he doesnt return a monad wtf does he return?
21:16:25 <Pseudonym> No restrictions on the point where the exception is raised.
21:16:28 <dons> @type Control.Exception.throw
21:16:29 <lambdabot> Control.Exception.throw :: forall a. GHC.IOBase.Exception -> a
21:17:02 <Pseudonym> Note also
21:17:05 <Pseudonym> @type undefined
21:17:07 <lambdabot> undefined :: forall a. a
21:17:25 <tuomov> throw'll just return bottom which will cause any intervening stuff to not be evaluated, and store the exception somewhere
21:17:34 <dons> yep. or error, fail, etc.
21:17:42 <Pseudonym> Not fail necessarily.
21:17:45 <Pseudonym> Depends on the monad.
21:18:07 <dons> ah, true. fail :: forall m a. (Monad m) => String -> m a
21:19:58 <jesse98> do exceptions carry any state?
21:21:53 <jesse98> nver mind, i think i get it now
21:22:05 <Pseudonym> Ah, so we were talking cross-purposes all this time.
21:22:23 <jesse98> to a large extend
21:23:34 <jesse98> i dont think my haskell book talks about exceptions at all\
21:23:52 <Pseudonym> No, they're not standard Haskell.
21:24:42 <jesse98> that's pretty cool now that I understand how they work
21:24:56 <jesse98> doesnt seem to suck at all, really
21:25:16 <Pseudonym> There is one situation where it might be not what you want.
21:25:24 <Pseudonym> If you had to _repair_ an exceptional situation.
21:25:30 <Pseudonym> Rather than just cope.
21:25:40 <Pseudonym> Report and abort is the common case.
21:25:58 <Pseudonym> But there are some situations where you might have to take action and try to fix things.
21:26:08 <jesse98> yeah, eiffel has that
21:26:12 <Pseudonym> Right.
21:26:26 <Pseudonym> Now in most situations, you can do this at the IO level.
21:26:38 <Pseudonym> For example, if you're writing a database server, and you run out of disk space.
21:26:49 <Pseudonym> Then you can free some space, and then just restart the whole operation.
21:27:04 <jesse98> i guess that would be more of a limitation in haskell because you cant simply add try/catch blocks willy nilly
21:27:11 <Pseudonym> However, if there are real-time constraints, restarting the whole operation might not be an option.
21:27:22 <Pseudonym> In which case, Haskell might not be a good language choice.
21:27:24 <Pseudonym> Not yet, anyway.
21:29:12 <jesse98> i'm still stuck on non-determinism though, like for threading
21:33:13 <jesse98> seems like there might be performance issues with that model of exceptions too: a function that returns an int cant simply return an unboxed int
21:37:04 <tuomov> hardware should have bottom and pointer-type bits..
21:48:35 <Pseudonym> tuomov: Yes, but that's not necessarily true of what a function returns.
21:48:51 <Pseudonym> In most cases, it is, though.
21:49:07 <Pseudonym> Because in a lazy language, evaluating a function almost always results in an update.
21:49:26 <Pseudonym> Because it's overwriting its own thunk.
21:50:12 <Pseudonym> The only case where you can return an unboxed int is if the result is a) not shared, and b) used in further unboxed operations.
21:50:26 <Pseudonym> In which case, you can usually return an unboxed int by optimisation.
22:04:35 <Pseudonym> must away.  Nytol!
22:44:38 <musasabi> morning
