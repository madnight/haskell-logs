00:02:14 <musasabi> How should C functions returning a reference to a static buffer be called from haskell?
00:03:04 <musasabi> "myForeignFunc >>= peekCString" seems quite unsafe (think about a thread switch occuring in the wrong place)
00:43:02 <Freejack> Anyone here use ghci?
00:44:57 <musasabi> yes...
00:46:09 <Freejack> musasabi: Trying to figure out how to set it up so I can work through the tutorials as thier presented on the web sites.
00:47:06 <musasabi> using it inside emacs can be fun if you are so inclined..
00:47:12 <musasabi> but console is fine too.
00:47:28 <musasabi> Freejack: any specific problem?
00:47:32 <Freejack> musasabi: More of a vi person. Heh.
00:48:14 <Freejack> musasabi: Well, the example   inc n = n+1  gives a parse error when typed in exactly.
00:48:30 <musasabi> let inc n = n + 1
00:49:11 <Freejack> musasabi: So basically I have to prefix all the example snippets with "let"?
00:50:48 <Freejack> Or just the ones that "declare" new functions?
00:51:59 <psi> you should probably do the exercises in a file and then load them in ghci
00:52:24 <musasabi> if you have lots of source just put it in a file and :l[oad] it
00:52:33 <Freejack> psi: I'll try that.
00:52:49 <psi> this is very convienient in emacs :)
00:52:50 <Freejack> Not a lot of source yet. Haskell newbie.
00:53:20 <musasabi> Freejack: open gvim for the file and a console with "ghci File.hs"
00:53:44 <musasabi> when you have edited the file, :w it, and say :r in ghci which tries to reload it.
00:54:14 * Freejack nods
00:55:03 <Freejack> That works.
00:56:22 <Freejack> ghc is one big ass environment.
00:56:39 <Freejack> But nothing I'm not used to.
01:00:25 <Freejack> brb
01:39:10 <musasabi> Any ideas howto propagate exceptions to haskell from FFI?
03:22:13 <dblhelix> @yow
03:22:15 <lambdabot> I'm in DISGUISE as a BAGGAGE CHECKER....I can watch the house, if it's
03:22:15 <lambdabot>  ORANGE...
03:45:04 <Itkovian> having no experience with the fltk, and certainly not with the haskellinterface to it, i am wondering if more educated minds think implementing the /ui for this game (http://www.dyson.co.uk/game/playgame.asp) would be feasible. I do know haskell (not all the fancy stuff, but still...)
03:46:34 <musasabi> no flash here.
03:46:48 <Itkovian> dang :-)
03:46:48 <musasabi> Itkovian: if you wish to use hs-fltk you can count on my support ;)
03:47:20 <Itkovian> in any case the UI toolkit should be cross-platform ...
03:50:41 <musasabi> well fltk should be crossplatform, only I don't have access to any windows machines.
03:51:03 <Itkovian> neither do i ;-)
03:51:14 <Itkovian> I do have a vmware lying around
03:51:25 <Itkovian> which more or less amounts to the same
03:59:52 <musasabi> Does ghc work with wine?
04:00:37 <musasabi> that could be one avenue..
04:00:51 <musasabi> but installing mingwin under wine would a little bit...
04:11:56 <flodin> musasabi: from what i can tell ghc already exists for unix, why run it in an emulation layer
04:21:27 * dblhelix is away: out to lunch
04:23:33 <musasabi> flodin: of course.
04:23:38 * TheHunter is away: I'm busy
04:23:40 * TheHunter is back (gone 00:00:01)
04:24:00 <musasabi> flodin: but if I want to make my libraries compatible with windows, and I don't have windows.
04:24:19 <flodin> ask someone with windows to do it for you :P
04:27:06 <tuomov> tell windows users to use cygwin
04:27:20 <tuomov> or switch os
04:40:20 <Philippa> tuomov: ain't happening
04:40:49 <Philippa> some of us have good reasons for sticking with this OS, much as it's often an irritating pile of crap
04:47:24 <Itkovian> musasabi: you don't know anyone who can 'lend' you a vmware key and a windows cd?
04:47:45 <Itkovian> we have vmware here, and it works really great
04:48:36 <Itkovian> so  great that i'd be tempted to install linux running a vmware on my mother-in-law her machine ... so I can maintain the damn thing and if she messes up, just put the original vmware image back
04:48:44 <Itkovian> no hassle, no fuss
04:49:07 <musasabi> Itkovian: principles ;)
04:49:41 <Itkovian> yeah ... i understand that very well, but the majority of humankind is still sold to microsoft
04:50:07 <Itkovian> i refuse using it, except in utmost emergencies (such as being obliged to use this or that package)
04:50:16 <Itkovian> then it works great
04:51:12 <musasabi> and I don't think that I could install windows on many machines at home...
04:51:22 <musasabi> as most are discless clients from a fileserver..
04:51:29 <musasabi> *diskless
05:00:15 <Itkovian> ok
05:09:17 <Spark> musasabi: same
05:34:26 <KiMoS> morning
05:35:11 <Lemmih> Good morning, KiMoS.
05:35:37 <KiMoS> good morning to you Lemmih :)
05:37:36 <KiMoS> how do you check if a list contain a square or not ?
05:37:58 <KiMoS> [Int] -> Bool
05:38:01 <Lemmih> square?
05:38:35 <xerox> hello!
05:38:41 <Lemmih> Hey xerox
05:39:24 <KiMoS> square yes
05:39:32 <KiMoS> Hey xerox
05:39:52 <KiMoS> like  [2,4]  is true becouse  square 2 is 4
05:40:04 * dblhelix is back (gone 00:41:39)
05:40:28 <xerox> foo (i*i) = .. ? :D
05:40:34 <jadrian> KiMoS: do you know how to check if a number is a square?
05:41:28 <KiMoS> no..
05:41:50 <jadrian> KiMoS: you should start there then
05:42:23 <jadrian> KiMoS: then you can define your function as:  any isSqr
05:42:39 <jadrian> kig: where isSqr checks if you number is a perfect square
05:42:41 <jadrian> opss
05:42:46 <jadrian> KiMoS:  where isSqr checks if you number is a perfect square
05:43:52 <KiMoS> what is a perfect square?
05:44:00 <jadrian> a square :)
05:44:20 <xerox> @index isSqr
05:44:20 <lambdabot> bzzt
05:44:34 <jadrian> no no, he has to implement "isSqr"
05:44:42 <xerox> AH..
05:45:22 <KiMoS> square is a number with sqrt n * sqrt n = that number then it is a square 
05:45:28 <KiMoS> is that correct?
05:45:32 <jadrian> kind of
05:45:52 <jadrian> you got to be careful with types
05:46:00 <Itkovian> hmm, recall that the signs of sqrt can be different if you express it like that
05:46:33 <jadrian> ?
05:46:38 <jadrian> signs of sqrt?
05:46:41 <Itkovian> in a mathematical sense
05:46:53 <tuomov> that definition assumes that sqrt is defined
05:46:54 <xerox> jadrian how to check if a number is an integer ?
05:47:10 <KiMoS> isDigit ?
05:47:13 <tuomov> square is a number n so that there exists a for which n = a*a
05:47:16 <jadrian> xerox: you don't...
05:48:19 <jadrian> I'm not sure what i sthe idea of the exercise, but there are (at least) two different approaches
05:48:38 <jadrian> 1. use integer functions only and some number theory knowledge
05:49:34 <KiMoS> and 2 ?
05:49:50 <jadrian> 2. convert your int to float /double, apply sqrt, back to integer (carefull with how you do that), and then check if its square is the original number
05:51:08 <KiMoS> why convert to float/double?   i thought sqrt can work with int's ..
05:51:36 <tuomov> @type sqrt
05:51:40 <lambdabot> sqrt :: forall a. (Floating a) => a -> a
05:51:46 <jadrian> well the codomain could never be Integral
05:52:04 <jadrian> it would be undefined for most integers then
05:52:34 <tuomov> it's easy to find the integer closest to what would be the square root by bitwise search
05:53:07 <KiMoS> bitwise search?
05:53:46 <Itkovian> can anybody give me the url for hs_fltk, google seems to be at loss
05:53:55 <Itkovian> binary search perhaps?
05:54:05 <Itkovian> taken log(sqrt(a)) steps imo
05:54:07 <tuomov> Say n is k bits. Start checking whether 1^k is too big to be a square root and so on
05:54:18 <tuomov> s/1/2/
05:54:21 <Itkovian> hmm
05:54:44 <Itkovian> you can also use a newton-raphson approach
05:54:55 <Itkovian> as you work in [0,+inf[ 
05:55:09 <Itkovian> ok, forget that
05:56:32 <Itkovian> maybe it'd work ...
05:56:48 <jadrian> Itkovian: yes of course you could use Newthons method
05:57:06 <Itkovian> yeah well, i'm at loss, my brain is overloaded, and it's been years ;-)
05:57:07 <jadrian> Itkovian: but that means using floatings to find the sqrt
05:57:10 <Itkovian> true
05:57:25 <Itkovian> a binary search in the integer field could be feasible
05:57:30 <KiMoS> how do u convert from int to float?
05:57:35 <jadrian> Itkovian: so unless he really wants to code it, he would be better of using sqrt
05:57:41 <jadrian> KiMoS: fromIntegral
05:57:53 <Itkovian> yeah, use srqt and trunc the damn result
05:58:06 <jadrian> Itkovian: no!
05:58:08 <tuomov> no you don't need floats
05:58:12 <jadrian> Itkovian: don't trunc
05:58:22 <tuomov> there's a integer-only newton method in a cryptography lecture notes I have
05:58:33 <tuomov> but the binary search is quite nice
05:58:52 <KiMoS> im gonna sqrt the list and then try to check every member of the list * the same member is equal to the orginal one.. would that be a good apporach?
05:59:53 <Itkovian> hmm
06:00:06 <jadrian> Itkovian: you should round 
06:00:15 <jadrian> Itkovian: trunc is an unnecessary risk
06:00:53 <Itkovian> ture. i was going to say trunc and trunc + 1 :-)
06:01:14 <jadrian> Itkovian: just round it then ;)
06:01:24 <Itkovian> and then what? how to determine is your sqrt is actually the integer, and not simpluy a roundoff error that's to big?
06:01:37 <jadrian> Itkovian: ?
06:02:00 <Itkovian> e.g. sqrt(35.99999) = 5.9999999999999 -> round => 6, of yes, nice
06:02:06 <Itkovian> or did he start with integers?
06:02:14 <KiMoS> with int
06:02:18 <Itkovian> ah, ok.
06:02:20 <jadrian> Itkovian: he's starting with integers of course
06:02:33 <KiMoS> [int] :: bool
06:02:37 <jadrian> Itkovian: it doesn't make sense for real numbers! what is a perfect square in real numbers :)
06:03:06 * Itkovian slaps himself with a large foam bat
06:03:23 <jadrian> brb
06:03:33 <tuomov> plus equality isn't decidable with reals
06:03:38 <xerox> KiMoS i'd better like to have a Int -> Bool and then a list-processing function
06:04:12 <KiMoS> but i want to check a list xerox
06:04:31 <KiMoS> i must have [int] -> Bool
06:04:32 <xerox> i think dividing problems is better :)
06:04:44 <jadrian> xerox: but that is exactly what I told him first
06:04:56 <jadrian> xerox: implement  isSqr :: Int -> Bool
06:05:08 <xerox> jadrian, oh. Btw i'm stuck with isSqr :: Int -> Bool
06:05:20 <jadrian> xerox: then it's just:   any isSqr 
06:05:32 <xerox> yep.
06:05:38 <jadrian> xerox: any :: forall a. (a -> Bool) -> [a] -> Bool
06:06:02 <xerox> i dont know that yet :)
06:06:10 * jadrian is away now
06:06:19 <xerox> bye :)
06:09:14 <KiMoS> isSqrt is  this
06:09:15 <KiMoS> isSqrt :: Int -> Bool
06:09:15 <KiMoS> isSqrt n = sqrt n * sqrt n == n
06:09:18 <KiMoS> ?
06:09:35 <KiMoS> n = sqrt n * sqrt n  == n   
06:10:17 <tuomov> sqrt is defined for floats only
06:10:32 <KiMoS> ohh i have to convert 
06:11:34 <xerox> how to conert?
06:11:37 <xerox> *convert
06:14:06 <KiMoS> fromInteger n :: Float   ?
06:21:32 <Lemmih> Time to unicycle!
06:22:52 <tromp> mysqrt n = approxSqrt n where
06:22:53 <tromp>   approxSqrt s = let q = n `div` s in
06:22:53 <tromp>                  if q >= s then s else approxSqrt ((s+q) `div` 2)
06:26:04 <xerox> what's the ` around `div` ?
06:27:00 <tromp> make it infix operator
06:30:25 <KiMoS> how can i use the  frominteger in here
06:30:26 <KiMoS> isSqrt :: Int -> Bool
06:30:26 <KiMoS> isSqrt n = sqrt n * sqrt n ==  n
06:30:56 <KiMoS> it say frominteger require integer and not int
06:33:05 <KiMoS> Instance of Floating I
06:33:05 <KiMoS> nt required for definition of isSqrt 
06:35:49 <tromp> use mysqrt instead of sqrt
06:35:58 <jadrian> tromp: nice, does that method have a name?
06:36:03 <tromp> or call it intSqrt
06:36:12 <tromp> that's just Newton-Raphson
06:36:23 <jadrian> tromp: it is?
06:36:50 <tromp> or, what N-R simplifies to
06:38:05 <jadrian> tromp: since you used div and not / I expected it to be something else... 
06:39:19 <jadrian> tromp: never gave thought about it really, but doesn't seem a trivial change (in the sense that you will have the closest integer for sure)
06:39:54 <tromp> it is always sqrt n rounded down
06:40:16 <KiMoS> its nice
06:41:01 <tromp> better is:
06:41:02 <tromp> intSqrt 0 = 0
06:41:03 <tromp> intSqrt n = newton 1 where
06:41:03 <tromp>   newton s = if q >= s then s else newton (s+q `div` 2) where q = n `div` s
06:41:11 <tromp> otherwise 0 fails
06:42:22 <jadrian> in this case, since his purpose is to find if he has a perfect square
06:42:32 <jadrian> he could also return both s and q 
06:42:46 <jadrian> if they are equal then he has a perfect square
06:43:06 <jadrian> (it would just avoid one multiplication which is not much...)
06:43:19 <KiMoS> isnt  sqrt n * sqrt n == n  alot easier?
06:43:31 <jadrian> well 1st it doesn't work
06:43:33 <jadrian> :)
06:43:51 <KiMoS> what does not work  ?
06:43:57 <jadrian> what you just wrote
06:44:00 <jadrian> doesn't type check
06:44:02 <KiMoS> why ?
06:44:07 <xerox> having an isInt would be nice..
06:44:47 <KiMoS> it check only if the int is square or not and then i use any on it
06:45:01 <jadrian> KiMoS: I told you ages ago, you cannot apply sqrt to integral values
06:45:20 <KiMoS> but someone else said you can convert it...
06:45:38 <jadrian> yes
06:45:44 <jadrian> you can
06:46:00 <tromp> btw, the code above is bugged:(
06:46:13 <KiMoS> how to use frominteger?
06:46:21 <tromp> intSqrt 0 = 0
06:46:21 <tromp> intSqrt n = newton n where
06:46:21 <tromp>   newton s = if q >= s then s else newton ((s+q) `div` 2) where q = n `div` s
06:46:40 <tromp> what do u want to use it for?
06:46:55 <KiMoS> to convert the int to float and use the sqrt
06:47:35 <jadrian> what tromp is giving you is a "sqrt" on ints
06:47:39 <KiMoS> btw tromp what type is intSqrt  ?   Int -> Bool ?
06:47:41 <tromp> what do u need sqrt for?
06:47:53 <tromp> yes, KiMos
06:47:56 <jadrian> is function does all the work
06:48:01 <jadrian> s/is/his
06:48:03 <xerox> foo n = sqrt m
06:48:03 <xerox>     where m = fromInteger n :: Float
06:48:03 <xerox>  ?
06:48:26 * jadrian is out again
06:50:36 <KiMoS> xerox  
06:50:37 <KiMoS> foo :: Int -> Float
06:50:37 <KiMoS> foo n = sqrt m
06:50:37 <KiMoS> where m = fromInteger n :: Float
06:50:53 <KiMoS> unexpected keyword "where" 
06:50:57 <xerox> foo n = s*s == f
06:50:57 <xerox>     where f = fromInteger n :: Float
06:50:57 <xerox>           s = sqrt f
06:51:02 <xerox> but it doesn't work mmh..
06:53:22 <xerox> that's "strange" (at least to me)
06:53:23 <xerox> > (sqrt 3)^2
06:53:23 <xerox> 2.9999999999999996
06:53:28 <xerox> > (fromInteger 3 :: Float)
06:53:28 <xerox> 3.0
06:53:37 <xerox> > (sqrt 3)^2 == (fromInteger 3 :: Float)
06:53:37 <xerox> True
06:54:25 <KiMoS> i got  (sqrt 3)^2
06:54:25 <KiMoS> 3.0   
06:54:43 <xerox> o you can't do it this way :(
06:54:59 <KiMoS> why? 
06:57:46 <KiMoS> let m = fromInteger n :: Float in sqrt m   ?
06:58:25 <KiMoS> if you only can tell me how to convert it it will work hopefully :)
07:00:08 <xerox> mmh
07:05:07 <KiMoS> tromp your code have an error..
07:16:03 <tromp> which code?
07:18:14 <KiMoS> [15:46:03] <tromp> intSqrt 0 = 0
07:18:14 <KiMoS> [15:46:03] <tromp> intSqrt n = newton n where
07:18:14 <KiMoS> [15:46:03] <tromp>   newton s = if q >= s then s else newton ((s+q) `div` 2) where q = n `div` s
07:18:14 <KiMoS> [15:46:23] <tromp> what do u want to use it for?
07:18:41 <KiMoS>  Undefined variable "n"
07:19:21 <tromp> works fine for me
07:20:38 <KiMoS> im getting Undefined variable
07:20:49 <tromp> what compiler?
07:20:51 <KiMoS> intSqrt :: Int -> Bool     
07:20:57 <KiMoS> hugs
07:21:20 <tromp> i don't
07:21:56 <tromp> try save those 3 lines to a file 
07:22:07 <tromp> and run hugs on it
07:23:02 <KiMoS> ok
07:24:30 <tromp> still get error?
07:25:49 <vardhan> AbsoluteNewBieQ: I defined ' data Thing = Thing Integer', how do i define Show on it ?
07:26:20 <Igloo> data Thing = Thing Integer deriving Show
07:26:43 <Igloo> Or instance Show Thing where show (Thing i) = "foo"
07:27:01 <vardhan> but how do i convert `integer` i to string ?
07:27:26 <Lemmih> @type show
07:27:29 <lambdabot> show :: forall a. (Show a) => a -> String
07:27:32 <Igloo> With show
07:27:59 <vardhan> thx. 
07:28:17 <tromp> you showed him, Igloo:)
07:28:27 <vardhan> :)
07:29:16 <monochrom> haha
07:43:11 <vardhan> how can a function  'test :: Bool'   (taking nothing and returning bool) use  print/putStrLn ?
07:43:28 <musasabi> it cannot.
07:44:08 <vardhan> musasabi: what should be the signature ? 'test :: IO Bool' ??
07:44:51 <Igloo> yes
07:51:01 <KiMoS> what do i need to import to use (fromInt 3)::Float
07:57:04 <Igloo> You want fromIntegral
07:58:56 <xerox> KiMoS did you get it? (:
08:19:01 <xerox> KiMoS, wops, conn troubles, did you get it? :)
08:21:52 <xerox> can someone point me to some haskell tips about indenting?
08:24:33 <Lemmih> @wiki HaskellStyle
08:24:33 <lambdabot> http://www.haskell.org/hawiki/HaskellStyle
08:28:15 <jadrian> Lemmih: nice stuff there
08:30:52 <Igloo> Eeek, people who seem not to know about the existence of id have been hacking on darcs
08:31:33 <Lemmih> id?
08:32:01 <Igloo> As in \x -> x
08:39:19 <vardhan> What'll be haskell equiv of 'class Foo  is derived from class Bar' in Types ... I'm finding thinking in Haskell hard.
08:41:02 <Lemmih> Type classes in Haskell aren't the same as classes in most OO languages.
08:41:48 <tromp> the closest thing is extending interfaces
08:42:01 <Lemmih> But you could do: class (Bar a) => Foo a
08:42:19 <tromp> interface Foo extends Bar
08:42:36 <vardhan> ok
08:43:08 <tromp> but that example is extended Haskell i think
08:43:35 <tromp> standatd haskell would require a type constructor on the right
08:44:20 <tromp> oops , I have it mixed up with instance declarations:(
08:44:30 <vardhan> another thing: (forgive my stupidity) : if a program has to open several files ( like MH mail system ), will Haskell be a bad choice ? Will majority of functions end up IO ?
08:45:26 <tromp> could be that only 10 lines of source end up in IO
08:45:49 <vardhan> ok .. thanx  for not letting me off the track (-:
08:45:50 <tromp> depends entirely on application
08:46:29 <vardhan> tromp: depends on the application or the architecture of the program ?
08:47:06 <tromp> on application's functionality
08:48:18 <vardhan> hmm ... any figures on what %age of darcs functions are IO ?
08:49:14 <tromp> no idea
08:50:00 <tromp> download source and check:)
08:50:28 * Lunar^ is asking himself : shouldn't GHC 6.3 become 7.0 once stable ?
08:51:15 <vardhan> grep :: *.lhs | wc  --> 1244  & grep :: *.lhs | grep IO | wc --> 336
08:51:32 <Igloo> Lunar^: Why?
08:51:50 <Lunar^> Igloo: new backend, new package system, GADT...
08:52:14 <Igloo> Hmm, true
08:52:44 <Lunar^> I think this will be quite buggy and incompatible with a lot of current code base
08:52:55 <Lunar^> at least for packages
08:53:05 <Igloo> Being buggy isn't a reason to call it 7.0
08:53:19 <Lunar^> ok, maybe
08:53:25 <vardhan> tromp: darcs has almost 27% functions as IO !!
08:53:34 <Igloo> And AIUI it will be backwards compatible
08:53:48 <xerox> *My_Map> my_map Char.toUpper "Hello"
08:53:48 <xerox> "HELLO"
08:53:53 <Igloo> Big new features, both visible and backend, are reasons to call it 7.0
08:53:54 * xerox making progress ^_^
08:54:02 <tromp> it has 27% lines of source containing IO
08:54:04 <Lunar^> Igloo: looking at SM last commits, I'm not sure
08:54:04 <Igloo> xerox: Cool  :-)
08:54:13 <Lunar^> Igloo: anyway, the new backend really rocks
08:54:16 <tromp> that's suspiciously high
08:54:38 <vardhan> tromp:  grep :: *.lhs ... :: should be only in function type declarations
08:55:00 <tromp> oh, right
08:55:28 <tromp> it may have many more functions with implicit typing
08:55:29 <Lunar^> tromp: Why suspicious ? darcs is a lot about IO
08:55:52 <Igloo> I don't think darcs has been written by Haskell experts, so you shouldn't necessarily take it as an example of a well-architected Haskell program
08:56:09 <vegai> has anything been written by Haskell experts?
08:56:31 <Igloo> GHC has, but its evolution means it might not be one either  :-)
08:56:39 <Lunar^> Yi is quite nice
08:56:42 <Igloo> Whatever UHC is called today might be one?
08:56:51 <Lunar^> Igloo: EHC ?
08:57:02 <Igloo> Could be
08:57:02 <tromp> i just expect even IO intensive programs to be able to keep 80% of functionality outside of IO
08:57:04 <Lunar^> vegai: throw an eye on http://haskell.org/communities/
08:57:06 <vegai> darcs is definitely the most usable Haskell application today
08:57:34 <tromp> ghc is no less usable:)
08:57:35 <Lemmih> vegai: I would say that GHC is also quite usable...
08:58:06 <vegai> yes, ok :)
08:58:10 <Philippa> less widely applicable though
08:58:30 <Igloo> Less widely applicable? With GHC you can do anything you want  :-)
08:58:38 <vegai> Lemmih: but that wasn't true before there were other usable Haskell applications :-)
08:58:47 <vegai> until*
08:59:03 <Philippa> tromp: I don't think Flippi quite manages that high a percentage, though a CGI script is sorta the definition of IO intensive in one regard
08:59:10 <Philippa> most of the non-IO code's parsing
08:59:24 <Philippa> Flippi's /tiny/ though :-)
09:00:49 <vardhan> As a haskell-newbie, can I take that if data-on-disk will be much more than data-in-memory for a particular application, then haskell may not be a very wise choise ?
09:01:29 <tuomov> no.
09:01:38 <tuomov> it depends on your access pattern
09:02:04 <Philippa> hell, any access pattern can be made to work, it's just that the more time you spend in the IO monad the less benefit you get from Haskell's purity
09:02:06 <tuomov> haskell is perfect for a filter that reads stdin and writes to stdout
09:02:16 <xerox> *My_Map> (my_map . my_map) Char.toUpper ["Hello", "How", "are", "you?"]
09:02:17 <xerox> ["HELLO","HOW","ARE","YOU?"]
09:02:17 <xerox> *My_Map> 
09:02:20 <xerox> WOPS, sorry
09:02:41 <Lunar^> vardhan: Even when doing 100% IO computations you still have strong typing and high-order functions benefits
09:02:43 <vardhan> toumov: what about sorting a large file where we need to create 'n' temporary files and merge them ?
09:03:19 <Philippa> it'd be suitable for that, yeah, you'd just have to learn a bit more about how IO works
09:03:22 <tuomov> there there might not be a huge benefit
09:03:54 <tuomov> because the bulk of the code is io operations
09:04:23 <Philippa> though odds are you'd get fairly easy code to read and maintain writing it in haskell
09:04:27 <Philippa> certainly compared to C
09:05:04 * Philippa is one of the "Haskell is my favourite imperative language" crowd :-)
09:06:06 <vardhan> Philippa: does ML family makes it easier to do IO  ? C++ with boost ain't that bad.
09:07:41 <Philippa> vardhan: not coded much in the MLs, can't see it being any easier than Haskell though. C++ with boost is still pretty horrible IMO :-)
09:07:52 <tuomov> c++ is horrible.
09:08:05 <shapr> chikky chock
09:08:06 * shapr boings
09:08:12 <Lemmih> Hey shapr (-:
09:08:25 <shapr> good balance to you Lemmih 
09:09:00 <shapr> how's code?
09:09:47 <Lemmih> It's OK. Could be better since I'm not doing what I wanna do but it's still Haskell.
09:09:54 <shapr> I understand that.
09:10:06 <tuomov> hmm... actually, haskell implementation of that file sorting would be much prettier than one I can think of in an imperative language
09:10:10 <tuomov> lazy io lists rule!
09:10:14 <shapr> yay!
09:10:23 <Lemmih> I've decided to buy a digital camera so I need money.
09:10:34 <shapr> I want a digital video camera for unipurposes.
09:10:39 <xerox> hello shapr!
09:10:41 <shapr> I need money also.
09:10:46 * xerox needs money too
09:10:46 <shapr> good copy to you xerox!
09:10:51 <Philippa> Damien wants a digital camera too, though I doubt it's uni he has in mind
09:10:53 <xerox> every time...
09:10:58 <Philippa> and yeah, money would be good here
09:10:59 <Lemmih> They are _so_ expensive!
09:10:59 <shapr> Lemmih: too bad we don't live in the same town, we could have a uni-camera co-op :-)
09:11:16 <shapr> How expensive are they?
09:11:40 <Lemmih> Several thousand kroners.
09:11:44 <shapr> yow
09:12:01 <shapr> I spent a coupla hours investigating video editing with Linux. I still at the "I have no clue" stage.
09:12:37 <shapr> bea has an ov511 webcam, which does passable video via usb. That and a laptop usb port would be sufficient.
09:12:44 <Philippa> we're probably looking at a lil' bit over a hundred quid here for what Damien's after
09:13:26 <Lemmih> Unicycling with a laptop? :)
09:13:30 * shapr grins
09:13:48 <shapr> I was hoping to find an assistant to film my uni-tricks.
09:14:31 <shapr> Most of the homemade films on gallery.unicyclists.org are filmed by a single person aiming their camera at the right place and then doing tricks there.
09:15:17 <Lemmih> How's the quality?
09:15:32 <shapr> of the ov511? or the online films?
09:15:57 <Lemmih> Both actually.
09:16:26 <shapr> ov511 quality varies according to the application used. Films seem to vary only according to the editor. It seems that dedicated digital video hardware nearly always turns out excellent pictures.
09:16:49 * Lemmih would appreciate some crystal clear 800x600 unicycle movies.
09:16:58 <shapr> There does seem to be a 'convention' to unifilms that's so universally followed as to be nearly a rule.
09:17:09 <Philippa> "include at least one crash"?
09:17:26 <shapr> I'm going to try to host some torrents of high quality Yoggi films. If I can get Yoggi to let me, that is.
09:18:05 <shapr> Philippa: actually, yes. The first three quarters or so is the cool tricks and impressive stuff, and the last quarter is the truly painful wipeouts.
09:19:29 <shapr> Lemmih: if I feel rich enough, I'm going to order the various Kris Holm films. Everyone says they're awesome.
09:19:46 <shapr> But I'd rather spend money on equipment I'll actually use while unicycling.
09:20:15 <shapr> Anyway, how's code treating everyone?
09:20:22 <shapr> I'm fighting darcs integration with Flippi
09:20:29 <vardhan> thanx all.
09:20:42 <shapr> unit testing calls that shell out to darcs is a pain.
09:20:50 <Philippa> I'm not really coding atm, more playing with ideas and working on that article I told you 'bout
09:21:14 <Philippa> adding type classes to tyop is probably my next coding project
09:49:09 <KiMoS> what is wronge in here
09:49:09 <KiMoS> foo :: Int -> Float
09:49:10 <KiMoS> foo n = sqrt((fromInt n)::Float )
09:49:46 <KiMoS> Undefined variable "fr
09:49:46 <KiMoS> omInt"  
09:49:53 <stepcut> fromIntegere
09:49:55 <stepcut> eek
09:49:58 <stepcut> fromInteger
09:50:04 <stepcut> maybe ?
09:50:36 <KiMoS> but my input is int  and not integer
09:51:00 <stepcut> true
09:51:06 <Lemmih> KiMoS: It's talking about the Integral type.
09:51:11 <Lemmih> @type fromInteger
09:51:13 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
09:51:22 <stepcut> fromIntegral then ?
09:51:27 <Lemmih> @type fromIntegral
09:51:28 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
09:53:26 <KiMoS> Limmih i dont need integral...
09:53:35 <Lemmih> Yes you do.
09:53:49 <Lemmih> Or don't you?
09:54:04 <Lemmih> Yes you do!
09:54:06 <KiMoS> i need to convert int to fload
09:54:18 <Lemmih> Indeed.
09:54:36 <Lemmih> @type fromIntegral (10::Int) :: Double
09:54:37 <lambdabot> fromIntegral (10::Int) :: Double :: Double
09:55:21 <KiMoS> ohh your right
09:55:31 <Lemmih> Double and Float are instances of Integral.
09:56:23 <KiMoS> i thought fromintegral   have something to do with integrating  :)
09:56:29 <KiMoS> thx Lemmih 
09:57:07 <Lemmih> I wonder if I'm using the correct terminology.
09:58:29 <jadrian> ?
09:58:38 <jadrian> <Lemmih> Double and Float are instances of Integral. ?
09:59:39 <jadrian> Lemmih: not really
10:00:39 <jadrian> Lemmih: fromIntegral converts from Integrals (Int, Integer,..) to Nums, and Floats/Doubles are Nums
10:01:39 <Lemmih> Bzzt
10:01:44 <jadrian> no?
10:02:16 <jadrian> define Bzzt :)
10:02:19 <Lemmih> That is correct.
10:02:24 <jadrian> ah
10:02:55 <Lemmih> 'Bzzt' is brainfart on my part.
10:03:01 <jadrian> lol k
10:04:54 <Lemmih> Isaac!
10:10:13 <SyntaxNinja> y0 Lemmih
10:10:16 <SyntaxNinja> how's it going?
10:12:49 <Lemmih> Fine I guess. I'm wondering if we will ever get Debian on haskell.org
10:14:09 <vegai> If you have any trouble sounding condescending, find a Unix user to show you how it's done.
10:14:15 <vegai> oops :)
10:14:21 <vegai> mispaste
10:15:07 <SyntaxNinja> heh
10:15:09 <musasabi> evening
10:15:13 <SyntaxNinja> I think he's talking about you, Lemmih ;)
10:15:26 <SyntaxNinja> "ooh, you use Debian, the cool kids version of Linux..."
10:15:34 <vegai> there was an author for that quote... 
10:15:37 <vegai> -- Scott Adams Dilbert newsletter 3.0, 1994
10:15:50 <np_hard> here's a nickel kid
10:16:00 <np_hard> buy yourself a real computer
10:16:04 <SyntaxNinja> Lemmih: has anything happened in the last few days? my laptop is broken and I can't really read email :(
10:16:05 <vegai> ;-)
10:16:10 <SyntaxNinja> np_hard: :)
10:16:20 <SyntaxNinja> debian haskell users are even worse
10:16:24 <np_hard> you'd be fools to ignore the anti-binary least squares approach
10:17:21 <Lemmih> SyntaxNinja: No. It has kinda dead-locked. We still need another box to do the switch.
10:18:16 <SyntaxNinja> Lemmih: and it needs to be at yale or what?
10:18:33 <SyntaxNinja> do they have rackspace? we could always just put it on a box and ship it to them or something
10:18:59 <SyntaxNinja> did you guys see david roundy advertising haskell in an interview? :) it ruled.
10:19:40 <KiMoS> can i apply any to a list?
10:19:44 <Lemmih> Time to eat!
10:20:04 <SyntaxNinja> @type any
10:20:05 <lambdabot> any :: forall a. (a -> Bool) -> [a] -> Bool
10:20:15 <SyntaxNinja> KiMoS: you have to!
10:20:42 <KiMoS> have a good meat Lemmih :)
10:21:05 <np_hard> I did see that, about darcs
10:22:54 <jadrian> I still didn't decide wether to move on to darcs or subversion
10:23:27 <SyntaxNinja> jadrian: we should vote on it here
10:23:34 <jadrian> SyntaxNinja: eh :)
10:23:40 <jadrian> ops phone
10:24:22 <SyntaxNinja> jadrian: subversion is much better that CVS, but it uses the same old model.  that's a plus for some people who don't want to learn a new way of doing things, but darcs allows for distributed development, which svn doesn't.
10:24:31 <SyntaxNinja> and darcs isn't hard to learn
10:24:52 <dash> svn allows for distributed development
10:25:03 <dash> it just requires a central repo
10:25:26 <np_hard> dogfood, though
10:25:47 <dash> which overall seems like a plus, to me
10:26:15 <SyntaxNinja> dash: no more than CVS.  darcs and tla can use central repositories, and you would always have an "official" repository.
10:26:36 <dash> right
10:26:49 <dash> which is why i don't see the advantage of non-official repos
10:27:12 <SyntaxNinja> well, so let's say that you have a customer or another open source hacker who has access to your source code
10:27:17 <SyntaxNinja> who wants to make modifications of their own
10:27:28 <SyntaxNinja> but you don't want to give them commit access to the repository.  you want to approve any changes from thenm.
10:27:43 <SyntaxNinja> in CVS or SVN, there's no way to do this.
10:28:02 <SyntaxNinja> they have to hack on a flat tree, and they can't commit unless they just initialize their own repository.
10:28:10 <dash> sure, but access control in svn is pretty easy
10:28:13 <SyntaxNinja> this has bitten me before.
10:28:23 <SyntaxNinja> well, but let's say that you don't want to give someone an account on your machine
10:28:24 <dash> you can give people commit access to their own dir
10:28:38 <dash> still not a problem 
10:28:43 <SyntaxNinja> it's on your internal network and customers can't use it
10:28:58 <dash> heh
10:29:04 <dash> so don't put it there :)
10:29:25 <vegai> If you have any trouble sounding condescending, find a Unix user to show you how it's done.
10:29:29 <vegai> argh!
10:29:33 <SyntaxNinja> I'm serious :)
10:29:39 <stepcut> dash: non-official repositories are good for long lived, unofficial forks, like linspires 'fork' of kde
10:29:52 <vegai> that still wasn't intentional, even if it might've suited the situation :P
10:30:03 <SyntaxNinja> like I was hacking on apt, and they weren't going to give me commit access to the repository, they've neve rheard of me, they weren't oing to give me access to their machine.
10:30:21 <b0l0k> hi alll
10:30:22 <SyntaxNinja> so I just created my own subversion repository, but syncing with them was a huge pain
10:30:23 <jadrian> back
10:30:27 <SyntaxNinja> jadrian: convinced yet? :)
10:30:50 <jadrian> well it's not really about capabilities darcs seems quite nice for me
10:30:53 <SyntaxNinja> dash: don't get me wrong. I like subversion and use it. I like arch too, but I like darcs the best
10:30:59 <dash> SyntaxNinja: i'm not so convinced that's bad
10:31:01 <jadrian> I like the fact that it is not file oriented
10:31:04 <jadrian> that is cool
10:31:21 <jadrian> it more because I might miss some tools
10:31:30 <jadrian> like web frontends
10:31:41 <SyntaxNinja> dash: why's that? the RC system artificially creates second-class citizens (as tom lord calls them) out of outside contributers and customers.
10:31:43 <jadrian> and that kind of stuff
10:31:49 <SyntaxNinja> jadrian: it has a web front-end
10:31:59 <jadrian> nice I didn't know that
10:32:01 <Philippa> ease of synchronisation once a merge has been approved is good
10:32:10 <dash> SyntaxNinja: heh, tom lord
10:32:13 <Philippa> sure, you want the security to stop somebody fucking you over, and you /have/ that...
10:32:24 <np_hard> don't they say that darcs has trouble scaling wrt svn and cvs ?
10:32:37 <vegai> it has a slow GET
10:32:46 <vegai> and you do one GET per project, right?
10:33:16 <np_hard> per project per person yes :)
10:34:05 <xerox> @expand Y
10:34:05 <lambdabot> Sorry, I don't know the command "expand", try "lambdabot: @listcommands
10:34:24 <vegai> darcs suits at least *my* purposes better than anything else. That is, maintaining my own little projects and pieces of data
10:34:59 <xerox> @eval Y
10:34:59 <lambdabot> <<EM Dynamic -> EM Dynamic>>
10:35:14 <xerox> @definitions Y
10:35:14 <lambdabot> ["Y"]
10:35:43 <xerox> @get-definition Y
10:35:44 <lambdabot> Y = \f.U(\g.f(U g))
10:35:51 <xerox> @get-definition I
10:35:51 <lambdabot> I = \x.x
10:43:14 <Nioate> @get-definition U
10:43:14 <lambdabot> U = \f. f f
10:54:06 <KiMoS> mod only work for integer ?
10:54:34 <KiMoS> @mod
10:54:35 <lambdabot> Sorry, I don't know the command "mod", try "lambdabot: @listcommands"
10:54:43 <xerox> *Main> :t mod
10:54:43 <xerox> mod :: forall a. (Integral a) => a -> a -> a
10:54:55 <xerox> @get-definition mod
10:54:56 <lambdabot> mod = \n d.n-(n/d)*d
10:54:58 <xerox> :)
10:55:24 <KiMoS> i found what is a square numbers   its a number that  sqrt (n)  mod 1 = 0  
10:55:35 <xerox> UH.
10:55:39 <xerox> right-
10:55:51 <KiMoS> been looking all day :)
10:56:48 <KiMoS> now im stuck again with the converting to float to use the sqrt and back to int to use the mod 1 == 0
10:57:03 <xerox> hehe
11:01:04 <KiMoS> :(
11:01:09 <KiMoS> isSqrt :: Int -> Bool
11:01:09 <KiMoS> isSqrt n = ( sqrtInt n `mod` 1 ) == 0
11:01:31 <xerox> do it works ?
11:01:33 <KiMoS> why does it say it:   Instance of Integral F
11:01:33 <KiMoS> loat required for definition of isSqrt 
11:01:40 <tromp> whawt's wrong with intSqrt?
11:01:47 <TheHunter_> KiMoS, you have to understand one thing about floating point numbers.
11:01:58 <TheHunter_> They're almost never exact, only approximations
11:02:00 <tromp> intSqrt 0 = 0
11:02:00 <tromp> intSqrt n = newton n where
11:02:00 <tromp>   newton s = if q >= s then s else newton ((s+q) `div` 2) where q = n `div` s
11:02:09 <KiMoS> tromp i dont want to use if else then
11:02:43 <tromp> you don't have to; you can use guards instead:)
11:02:56 <KiMoS> how
11:02:56 <TheHunter_> isSquare n = (== n) . last . takeWhile (<= n) . map (^2) $ [1..]
11:03:37 <KiMoS> TheHunter_  thats the type of isSquare ?
11:04:14 <TheHunter_> @type \n -> (== n) . last . takeWhile (<= n) . map (^2) $ [1..]
11:04:16 <lambdabot> \n -> (== n) . last . takeWhile (<= n) . map (^2) $ [1..] :: forall a.
11:04:16 <lambdabot> 							     (Ord a, Num a, Enum a) =>
11:04:16 <lambdabot> 							     a -> Bool
11:04:33 <tromp> you forgot to handle 0 :)
11:04:47 <TheHunter_> ohhh
11:05:36 <tromp> also, it's just a tad slow for n == 1965478316
11:05:45 <tromp> :-P
11:06:57 * shapr boings
11:08:16 <KiMoS> how does your code work TheHunter_  
11:08:29 <KiMoS> its working correctly but i want to understand it
11:08:31 <TheHunter_> KiMoS, you have to read it from right to left
11:08:51 <TheHunter_> the f . g . h $ x notation means essetially:
11:09:07 <TheHunter_> apply h to x then apply g to the result then f.
11:09:25 <TheHunter_> it first creates an infinite list [0..]
11:09:39 <xerox> $ is ?
11:09:57 <TheHunter_> then it squares each element of the list, so map (^2) [0..] evals to [0,1,4,9,16,..]
11:10:11 <arjanb> xerox: f $ a = f a
11:10:26 <TheHunter_> $ is a right associative low-precendence application
11:10:41 <TheHunter_> so f . g $ x === f (g x)
11:10:54 <xerox> (f . g) x
11:11:02 <xerox> === f (g x) 
11:11:04 <xerox> ?
11:11:11 <TheHunter_> xerox, yep
11:11:43 <TheHunter_> KiMoS, the next thing we do is only take elements from the list which are smaller than n
11:12:02 <TheHunter_> (for n >= 0 this is always terminates)
11:12:11 <jadrian> TheHunter_: map (^2) $ [0..]  --->  scanl (+) 0  (take i [1,3..])
11:12:18 <jadrian> TheHunter_: should be faster ;)
11:12:58 * Lemmih boings in the direction of shapr.
11:12:59 <TheHunter_> jadrian, well, tromp's solution is even faster but less clear.
11:13:04 <xerox> why "map (^2) $ [0..]" != "map (^2) [0..]" ?
11:13:15 <shapr> hiya Lemmih!
11:13:24 <TheHunter_> xerox, that's currying
11:13:24 <jadrian> TheHunter_: yeap 
11:13:32 <xerox> uh ?
11:13:41 <shapr> it's hard to beat the rush of a newly passing unit test
11:13:44 <TheHunter_> xerox, wait a sec.
11:13:47 <xerox> sure!
11:14:27 <TheHunter_> KiMoS, we wanted to check if n is a square, that is whether there's a number x such that x^2 == n
11:14:36 <KiMoS> yes
11:15:07 <TheHunter_> if there is such a number, then the last element of the list is n, otherwise it's a number strictly less than n
11:15:30 <TheHunter_> so we only need to check if the last element of the list is n.
11:15:52 <TheHunter_> to handle negative numbers, we should write
11:16:10 <TheHunter_> isSquare n | n >= 0 = (as above)
11:16:17 <TheHunter_>        | otherwise = False
11:16:38 <KiMoS> no need to negative numbers
11:17:29 <TheHunter_> KiMoS, but it's always better to handle them, otherwise, if you later change your code, you might end up with a hard to find bug.
11:17:49 <TheHunter_> if you're sure there'll be no negative numbers, you might also return an error for negative numbers.
11:17:51 <KiMoS> your right
11:18:56 <TheHunter_> xerox, in haskell, functions of more than one arguments doesn't really exist.
11:19:05 <xerox> ugh O_
11:19:45 <TheHunter_> for example (+) is a function of one argument that, when applied to 4, returns a function that increases a number by 4
11:20:25 <xerox> i see
11:20:36 <xerox> yep!
11:20:37 <TheHunter_> an alternative would be to create a function which maps a pair to a result, e.g.
11:20:49 <TheHunter_> myPlus (x, y) = x + y
11:21:14 <TheHunter_> there are to functions which translate between these two representations, curry and uncurry.
11:21:17 <TheHunter_> @type curry
11:21:19 <lambdabot> curry :: forall c b a. ((a, b) -> c) -> a -> b -> c
11:21:20 <TheHunter_> @type uncurry
11:21:22 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
11:21:51 <TheHunter_> so myPlus is the uncurried form of (+) and might be defined as myPlus = uncurry (+)
11:21:58 <xerox> i don't really understand the meaning of all the ->
11:23:05 <TheHunter> a function of one argument has type for example
11:23:06 <TheHunter> @type id
11:23:08 <lambdabot> id :: forall a. a -> a
11:23:16 <xerox> yes i understand it
11:23:39 <TheHunter> the type of a "two argument" - function is more interesting.
11:23:46 <TheHunter> consider (+)
11:23:53 <xerox> yup
11:24:06 <Nioate> -> is either right or left associative (I forget which) so a -> b -> c is actually a -> (b -> c). in an abstract sense, functions always have one argument. is that what you mean?
11:24:13 <TheHunter> it is a function that takes an Int and returns a function Int -> Int, so has type Int -> (Int -> Int)
11:24:21 <xerox> ok.
11:24:47 <TheHunter> Nioate, yep, I was just about to say that.
11:25:27 <TheHunter> -> is right associative, so instead of Int -> (Int -> Int) you can write Int -> Int -> Int
11:25:57 <xerox> so a -> a -> a -> a  means a -> (a -> (a -> a)) ?
11:26:10 <TheHunter> exactly
11:26:14 <KiMoS> TheHunter the last element of the list u made is a square ?
11:26:16 <xerox> mmh..
11:26:46 <TheHunter> KiMoS, one of the intermediate lists is the lists of all squares.
11:27:21 <xerox> @get-definition $
11:27:21 <lambdabot> $ not defined
11:29:35 <xerox> map :: forall b a. (a -> b) -> [a] -> [b]
11:29:36 <xerox> mmmh..
11:29:47 <xerox> where's the "function" argument?
11:29:55 <xerox> map "function" "list"
11:30:02 <TheHunter> (a -> b) is a function from a to b
11:30:21 <xerox> ah!
11:30:39 <KiMoS> alright i got it now  thx :)
11:33:57 <xerox> TheHunter btw, it's kind of difficult to get used to.. it's starting seeming to me that haskell is a language for a mathematical elite :)
11:35:22 <KiMoS> yes i have the same idea :)
11:36:01 <TheHunter> it's different from imperative languages, but I don't think the ideas are more difficult to grasp.
11:36:16 <xerox> -> it's starting fooling me :)
11:36:22 <KiMoS> me 2 
11:36:39 <KiMoS> i mean with java i would done my problem in 2 min
11:36:44 <xerox> argh.
11:36:44 <KiMoS> (maybe)
11:37:06 <Philippa> you'll soon find things you can do in two minutes flat in Haskell that take piles of work in Java, don't worry
11:37:22 <TheHunter> it'd have taken me 10 minutes in java vs. 15 seconds in haskell...
11:37:38 <KiMoS> yea i already found  
11:37:50 <KiMoS> thats why i liked haskell
11:38:17 <xerox> i should stop making consideration until finishing the book :)
11:38:27 <KiMoS> is haskell easy to use with other languages?
11:38:47 <musasabi> well it provides a very clean FFI interface.
11:38:55 <shapr> I've heard Haskell doesn't integrate well with COBOl.
11:39:10 * TheHunter laughs.
11:39:42 <Riastradh> I've heard that COBOL doesn't integrate well with human sanity.
11:40:06 * shapr grins
11:42:24 <KiMoS> i want to check if a list is Strictly Organized  that is when every element (expect the last one) is smaller then the next element
11:42:34 <KiMoS> any idea how ?
11:43:40 <KiMoS> sOrginized xs is true as each element (except of the last) smaller is then its successor 
11:44:13 <jemfinch|lambda> KiMoS: shouldn't you be able to use foldl1?
11:44:25 <jemfinch|lambda> (somehow :))
11:44:30 * Philippa was a very happy bunny when she found foldl1 :-)
11:44:36 <andersca> :)
11:44:43 <Philippa> very, very useful function
11:44:56 <KiMoS> i need to check it first
11:45:11 <Philippa> I mean, it's all over my uglyprinters :-)
11:45:29 <TheHunter> jemfinch|lambda, i'd suggest zip + all
11:45:46 <Philippa> foldl1 (<) seems a good definition to me
11:46:02 <TheHunter> @type foldl1 (<)
11:46:04 <lambdabot> foldl1 (<) :: [Bool] -> Bool
11:46:36 <Philippa> d'oh
11:46:38 <Lemmih> or perhaps, organized x = x == sort x
11:46:42 <xerox> @get-definition foldl1
11:46:43 <lambdabot> foldl1 = \f l.foldl f (head l) (tail l)
11:46:50 <Philippa> Lemmih: overly costly
11:46:56 <Philippa> I mean, it's an elegant definition...
11:47:30 <Lemmih> Philippa: It works and you shouldn't optimize unless it's a problem. (-:
11:47:35 <Philippa> heh
11:47:41 <TheHunter> organized xs(_:t) = and $ zipWith (<) xs t
11:47:57 <KiMoS> zipWith ?
11:48:06 <TheHunter> @type zipWith
11:48:08 <lambdabot> zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:48:52 <TheHunter> takes a function and two lists and applies the function to certain pairs of elements of the two lists
11:49:13 <KiMoS> @type organized xs(_:t) = and $ zipWith (<) xs t
11:49:15 <lambdabot> bzzt
11:49:23 <TheHunter> zipWith f [x1,x2,x3] [y1,y2,y3] ==> [f x1 y1, f x2 y2, f x3 y3]
11:49:44 <desrt> @type (\xs(:_t) -> and $ zipWith (<) xs t)
11:49:46 <lambdabot> bzzt
11:49:51 <TheHunter> oh, sorry i forogot an @
11:49:53 <Riastradh> @type (\(xs@(_:t)) -> and $ zipWith (<) xs t)
11:49:54 <lambdabot> (\(xs@(_:t)) -> and $ zipWith (<) xs t) :: forall a.
11:49:54 <lambdabot> 					   (Ord a) =>
11:49:54 <lambdabot> 					   [a] -> Bool
11:50:28 <desrt> is there any a->a function that isn't id?
11:50:48 <Riastradh> No, id is the only possible function with that type.
11:50:49 <TheHunter> desrt, well there is undefined :: a -> a
11:50:52 <Lemmih> succ,pred, (1+)
11:50:58 <desrt> hm
11:51:06 <desrt> Lemmih; no.  that's Enum a => a -> a
11:51:34 <Riastradh> TheHunter, that's only because undefined :: b and b unifies with a -> a.  undefined is a somewhat special case.
11:52:11 <Philippa> yeah, top and bottom types can do funfunfun things to type systems :-)
11:52:39 <desrt> so by :: b do you mean bottom or <generic type variable>?
11:53:32 <Philippa> the latter. Bottom's just an element of all types in haskell, though other type systems consider it as the bottom of the type hierarchy or similar
11:54:07 <Philippa> similarly, Top is essentially the Object class in many OO languages
11:54:26 <desrt> but not java :)
11:54:36 <Philippa> right, because java sucks :-)
11:54:50 <TheHunter> yeah, and it's a shame that (undefinded :: Int -> Int -> Int) 2 returns an error instead of a fucntion that returns an error for each argument.
11:55:11 <desrt> you're talking about partial ordering on classes, though
11:55:19 <desrt> not on results
11:56:16 <desrt> with the 'extends' operator being the partial order
11:56:58 <Philippa> well yeah, as best you get "results are elements of types"
11:57:00 <Philippa> *at best
11:57:07 <desrt> mm
11:57:23 <desrt> this is possibly confusing
11:57:30 <Philippa> as opposed to the cpo the value bottom's part of. 'sthe only valid value of the bottom type though
11:58:20 <Philippa> which means the type bottom is the type of things that don't evaluate - neat?
11:58:31 <desrt> so your partial order really is 'extends or instanceof'
11:59:03 <Philippa> yeah. Interfaces always were a form of MI
11:59:06 <desrt> treat the 'class a extends b' relation is being the same thing as declaring 'b a;'
11:59:42 <KiMoS> man im tired today im gonna try to find the solusion tommorow for the sorgonized  
11:59:49 <KiMoS> thanks for the help guys 
12:00:00 <Philippa> KiMoS: if you don't mind primitive recursion, it's fairly simple
12:00:24 <Philippa> and I like the add $ (a<b<c...) type solutions, they have good operational behaviour
12:00:27 <KiMoS> what is primitive recursuion?
12:00:33 <Philippa> that which you do by hand
12:00:46 <Philippa> as opposed to letting a HOF sort it out for you
12:00:59 <KiMoS> i dont need to sort it
12:01:25 <KiMoS> just check if the list element the one is smaller then the otther expect for the last one
12:03:07 <bourbaki> moin
12:03:08 <Philippa> yeah, I know
12:03:11 <TheHunter> nabend bourbaki 
12:03:17 <Philippa> Lemmih just gave that as an "obvious" implementation
12:03:19 <bourbaki> thanks :)
12:03:26 <Philippa> an isSorted predicate, basically
12:03:41 <bourbaki> im in the industry again :)
12:05:17 <KiMoS> Philippa  do you mean   organized x = x == sort x
12:10:58 <xerox> @index sort
12:10:58 <lambdabot> Data.List,List
12:11:00 <KiMoS> sort sort a list in ascending order
12:11:23 <xerox> reverse . sort x ? :D
12:11:29 <xerox> dinner time, later :)
12:13:33 <Philippa> KiMoS: yeah
12:13:42 <Philippa> heh
12:14:40 <KiMoS> x = x == reverse sort x  ?
12:14:55 <KiMoS> and first i have to take the last element i think
12:17:37 <Philippa> yup. Or you can try this little horror:
12:18:50 <Philippa> and isSorteds where isSorteds (a:b:cs) = (a < b):isSorteds (b:cs); isSorteds _ = [];
12:19:17 <Philippa> there really, really ought to be a function in List for that pattern
12:20:01 <KiMoS> sort should work   but i got ERROR - Undefined variable "sort"   
12:21:17 <Philippa> import List
12:21:23 <KiMoS> that horror function doesnt work Philippa :)
12:21:41 <Philippa> OK, write it out over three lines instead
12:21:49 <Philippa> and isSorteds where
12:22:02 <Philippa> or rather, foo = and isSorteds where...
12:22:11 <Philippa> and then the isSorteds defs over two lines with indentation
12:22:40 <KiMoS> im so confused lol
12:22:56 <Philippa> basically I was messing about trying to get three lines on one and messed up on the not buggering up layout
12:23:47 <KiMoS> but Philippa   xs = xs == reverse sort xs  should work fine?
12:23:56 <KiMoS> oh it not
12:24:12 <KiMoS> Does not match : a -> b -> c 
12:25:03 <Lemmih> reverse (sort xs)
12:26:48 <KiMoS> yes its working now
12:31:00 <shapr> gwargh!
12:31:08 <shapr> the injuns are coming! feersum injuns!
12:31:48 * shapr restarts his injun
12:31:51 <shapr> vroom!
12:31:52 * stepcut runs!
12:32:12 * shapr screeches around the corner and tries to squitch stepcut!
12:32:12 * stepcut writes an xml->wbxml  converter
12:32:19 <shapr> yuck
12:32:35 <shapr> binary xml... why didn't they just go full ASN.1?
12:32:45 <stepcut> beats me
12:32:57 <shapr> I had a wbxml converter in Python. It wasn't that hard to write.
12:33:02 <shapr> er, it was in Jython
12:33:05 <stepcut> but since wbxml is what is supported, that is what I will use :)
12:33:54 <Philippa> shapr: you been reading Banks?
12:34:06 <shapr> not recently
12:34:09 <stepcut> yeah, I am debating between a native haskell version versus bindings to an existing one -- but I figure it will be easier to write a native converter than write the bindings
12:34:12 <shapr> only baen.com/library
12:34:53 <stepcut> plus haskell needs more native libraries :p
12:35:01 <shapr> wbxml is really simple
12:35:12 <stepcut> indeed
12:35:14 <shapr> iirc, it's something vaguely like huffman encoding the xml source
12:35:39 * stepcut has only read the first paragraph so far...
12:35:50 <KiMoS> thats it for today   thanks everyone and see you maybe tommorow  :)   bye 
12:36:03 * shapr quickly sorts KiMoS before he escapes!
12:36:04 <jesse99> hey shapr, do you have a tool you use to index research papers?
12:36:18 <KiMoS> :)
12:36:22 <shapr> KiMoS: I dub thee "KMSio"
12:36:28 * shapr laughs
12:36:46 <shapr> jesse99: try scholar.google.com if you want to search lots of papers.
12:36:46 <KiMoS> is there a thee called KMSio ?
12:36:55 <desrt> shapr; where do you live?
12:37:10 <shapr> As for indexing your own collection, Fermat's Last Margin is not yet ready for release, but it might be in a few days.
12:37:30 <jesse99> well, I was thinking it'd be cool to have a tool to index local papers and maybe selected web sites
12:37:31 <stepcut> I am hoping to have a simple haskell app that uses wap push to deliver ringtones by sunday night
12:37:39 * KiMoS too tired to think :) bye
12:37:46 <shapr> bye KiMoS!
12:37:58 <jesse99> are you writing Fermat's Last Margin shapr?
12:37:58 <shapr> desrt: 800km north of Stockholm, Boden, Sweden
12:38:04 <shapr> yes, I am.
12:38:16 <shapr> have you seen the napkin prototype?
12:38:22 <jesse99> no
12:38:23 <desrt> oh.  for some reason i always assumed you were an american.  very sorry :(
12:38:30 <shapr> http://www.scannedinavian.org/RandomWiki/AnnotationMockup
12:38:32 <shapr> desrt: I am!
12:38:42 <shapr> desrt: what u be talkin bout willis?
12:38:45 <desrt> oh.  very sorry :(
12:38:56 <shapr> I'm from Alabama
12:39:01 <desrt> are you going to school in europe?
12:39:06 <shapr> um, no.
12:39:11 <stepcut> mmm, epigram
12:39:23 <shapr> desrt: I'm 100001 years old.
12:39:28 <shapr> (in binary)
12:39:36 <desrt> wow.  it's like you have this whole life that i don't know about
12:39:56 <Philippa> *sniggers*
12:40:00 <Philippa> a lot of folks in here do...
12:40:13 <shapr> what, you mean... studying nuclear physics, reactor design, computer art, archaeology, and then moving to Europe?
12:40:24 <desrt> i'm a crossdresser.  i pretend to like haskell but really i'm hardcore C
12:40:32 <Riastradh> Heretic!
12:40:34 <Riastradh> BURN HIM!
12:40:46 <shapr> does he float like a block of wood?
12:40:52 <desrt> shapr; ya.  moving to europe for no reason seems odd :)
12:41:00 <stepcut> desrt: at least you don't pretend to like haskell but really prefer ml ;)
12:41:03 <tuomov> I'm both harcore C and harcore haskell :)
12:41:08 <shapr> well, I met this chick on ICQ (50,000 words omitted) and now I live in Sweden.
12:41:14 <tuomov> anything between sucks :)
12:41:14 <desrt> tuomov; this is an attitude i can relate to :)
12:41:16 * Philippa can't stand C, but can code in it well enough
12:41:22 <desrt> shapr; ah!
12:41:22 <Philippa> shapr: hehehe
12:41:45 <ayrnieu> shapr - sounds like a decent enough 50,013-word novel.
12:41:48 * Philippa writes a note - "get the guys to move to where you live, not the other way round"
12:41:53 <desrt> i know a briton who is currently living in georgia by a very similar story
12:41:59 <shapr> jesse99: so, that's the basic idea behind FLM. imagemagick creates images for document pages, you add notes to your wiki, and then other people sync to your darcs repo.
12:42:32 <xerox> desrt "he had to"
12:42:34 <shapr> jesse99: now that you mention it, it would be really cool if I can rip the text out of each page and index that as well! But I'll save that for version 2.0
12:42:36 <xerox> gee :)
12:43:31 <jesse99> I wsa thinking of something rather different: a simple database that allowed you to add items with keywords probably exposed via an html server
12:43:47 <jesse99> with optional full text searches and maybe web site searching
12:43:48 <shapr> in that case, swish++ is probably a good approach.
12:44:07 <xerox> jesse99 that would be really nice
12:44:12 <shapr> Thing is, I'm more interested in where to jump to from here than I am in exact text searching.
12:44:35 <shapr> Like, what's the best thing to read after reading Meijer's monadic parsers paper?
12:44:35 <jesse99> I just want a way to easily find papers I have cached
12:45:14 <shapr> well, you know citeseer, yes?
12:45:15 <Philippa> "the parsec manual" :-)
12:45:19 <tuomov> I want that trust metric based news  aggregation system
12:45:21 <jesse99> yeah shapr
12:45:34 <tuomov> "news"
12:45:58 <jesse99> but citeseer wont index email I've saved, stuff I pulled down from a newsgroup, or anything I acquired elsewhere
12:46:05 <shapr> I'd suggest that you download files from citeseer, and keep them with the same name, because it's easy to search citeseer.
12:46:12 <shapr> oh, in that case, try dashboard.
12:46:18 <arjanb> knowing what to read before would be handy too
12:46:20 <shapr> Even that's not perfect though.
12:46:25 <shapr> I've wanted what you're asking for...
12:46:56 <shapr> I called my idea 'Mercenary' and it used bayesian statistics built from which documents you'd viewed recently, ps, pdf, email, web pages, etc
12:47:18 <shapr> one feature I want is a bayesian google client
12:48:05 <shapr> If I've read six monadic parser papers in the last day, Mercenary should do a 'bayesian google' that night and suggest web pages, other research papers, etc the next morning.
12:49:02 * xerox falls blown by the ai-ness of this idea
12:49:13 <shapr> xerox: it would n't be hard to write
12:49:22 <shapr> just no one's done it yet.
12:49:24 <stepcut> shapr: check out this bike I saw today: http://www.n-heptane.com/nhlab/pics/bigwheel.jpg
12:49:35 <stepcut> (sorry its blurry)
12:49:44 <shapr> I think we should each have our own trained search agents that slowly crawl documents for us.
12:50:06 <shapr> stepcut: cool! that's a penny-farthing :-)
12:50:16 <xerox> shapr that would be so much overhead..
12:50:23 <shapr> xerox: no it wouldn't!
12:50:26 <xerox> !_!
12:50:36 <shapr> every linux box run updatedb anyway
12:50:44 <xerox> "every" ^_^
12:50:48 <Philippa> bloody hell, so it is. Haven't seen one of those for ages, and that was in a museum
12:50:54 <Philippa> (re the bike)
12:51:02 <shapr> and a trickle version of that same thing could be niced down to 19 so it doesn't eat your foreground task
12:51:20 <shapr> xerox: really, it would be pretty simple, not cost much cpu, and wouldn't use much disk space
12:51:37 <xerox> maybe you first need a decent disk organization
12:51:39 <shapr> if you want extra effectiveness, you could use hidden markov models or the crm114 classifier instead.
12:51:48 <shapr> I don't think so, bayesian stats are quite effective.
12:51:48 <xerox> to be able to search sightfully
12:51:52 <xerox> uh, ok
12:51:56 <xerox> DO IT!
12:52:05 <shapr> hah, after I'm done with FLM :-P
12:52:23 <shapr> I've already written a bayesian spam filter in Haskell, adding web searching capability to it would be nifty
12:52:29 <xerox> in real life you would never say "FLM"! hehe
12:52:49 <shapr> xerox: of course, the next step would be to do bayesian stats on #haskell so you can filter out the boring people like lambdabot!
12:53:04 <shapr> lambdabot never says anything really interesting about haskell :-P
12:53:10 <Lor> flm?
12:53:12 <xerox> bayesian-with-exceptions is highly preferred
12:53:19 <shapr> Lor: Fermat's Last Margin
12:53:21 <xerox> Lor i was asking myself too :)
12:53:27 <shapr> xerox: do it!
12:53:30 * shapr grins
12:53:33 <xerox> *G*
12:53:58 <xerox> shapr today -> drove me crazy
12:54:08 <musasabi> today is a baking day.
12:54:09 <xerox> -> <-
12:54:11 <shapr> today drove you crazy?
12:54:20 <xerox> ouch.
12:54:30 <xerox> '->' is the subject
12:54:42 <shapr> aha
12:54:43 <tuomov> *squeeze*
12:54:58 <Lor> The function arrow or the lambda arrow?
12:55:30 <xerox> in multiple "-> -> ->" it's kind of difficult to get what is it the arguments and what the return values
12:55:42 <shapr> stepcut: http://www.coker.com/store/customer/product.php?productid=18283&cat=303&page=1
12:55:59 <shapr> xerox: that's because there's always one arg, and always one return
12:56:00 <xerox> like, map.
12:56:15 <shapr> under the hood, every function only takes one argument.
12:56:18 <xerox> (a -> b) -> [a] -> [b]
12:56:22 <shapr> and then returns a new function
12:56:27 <shapr> well, sometimes
12:56:53 <shapr> stepcut: of course, I really want this one - http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
12:57:26 <Lor> The formatting of longer function types can be confusing, too: http://www.haskell.org/pipermail/haskell-cafe/2002-November/003617.html
12:57:27 <shapr> xerox: have you seen HaskellDemo?
12:57:30 <musasabi> Is the function arrow (->) a first class citicen?
12:57:32 <shapr> @wiki HaskellDemo
12:57:32 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:57:37 <xerox> shapr some of it
12:57:40 <xerox> *part
12:58:00 <Philippa> musasabi: no, it's a type
12:58:17 <Lor> musasabi, it's a type constructor of kind * -> * -> *
12:58:28 * shapr has wondered about that
12:58:44 <Lor> (And in the above, "->" is a kind constructor.)
12:58:45 <xerox> o_O
12:58:57 <musasabi> Lor: so it takes two values of the kind * and produces one value of the kind * ?
12:59:05 <Lor> Yeah.
12:59:09 <shapr> then there's ->>- which is an unkind constructor...
12:59:13 <musasabi> thanks.
12:59:22 * shapr viciously stabs someone with an unkind constructor.
12:59:34 <Lor> It is a "real" type constructor in the sense that you can say "instance Arrow (->) where ..."
12:59:35 <xerox> what's the meaning of the dash in:
12:59:36 <xerox> ackermannoutput left in -
12:59:36 <xerox>  n = ack n n
12:59:37 <xerox> ?
12:59:49 <shapr> Lor: that's always mystified me
12:59:53 <shapr> hiya autechre_ 
12:59:59 <autechre_> hi
13:00:04 <Philippa> shapr: |====) is a fun constructor, then?
13:00:05 <shapr> how's code?
13:00:10 <Lor> shapr, how is it mysterious?
13:00:10 <autechre_> tricky :)
13:00:16 <shapr> Philippa: looks sort of like a shovel
13:00:29 <stepcut> shapr: I take it you saw this one: http://www.conferencebike.com/
13:00:30 <shapr> |===|_>
13:00:34 <Philippa> heh
13:00:41 <Philippa> well, there're variants...
13:00:43 <shapr> stepcut: yah, I saw it.. I wouldn't get close to it.
13:00:50 <Philippa> |=()=()=) is fun, for example
13:00:50 <autechre_> question - i have a list, and i want to generate another list consisting of only the odd array indices of the first
13:00:51 <Lor> _ is not a legal character in infix symbols, sorry.
13:01:46 <shapr> stepcut: the unicyclists say that conferencebikes are a danger to themselves and anything nearby.
13:01:53 <stepcut> shapr: haha
13:02:04 <autechre_> so, wrongly - something like   [x | x <- mylist !! n, odd n]
13:02:51 <stepcut> shapr: the fermats last margin mockup looks neat
13:03:08 <Lor> "odd array indices"?
13:03:16 <shapr> yes, I hope it's as neat to actually use.
13:03:33 <Lor> You mean you want every other element of the original list?
13:03:46 <autechre_> yes, so given [1,6,4,7,8,1] i want a list [1,4,8]
13:03:51 <autechre_> yes :)
13:03:56 <shapr> stepcut: my use case so far is that you put the url to the pdf or ps into a top level page for that paper, and subpages for each document page are generated, and notes you make on those pages are saved to your darcs repo
13:03:59 <Lor> I don't think list comprehensions can do it neatly.
13:03:59 <autechre_> and another list, with the "even" indices
13:04:11 <stepcut> shapr: neat!
13:04:35 <ayrnieu> evenOf (x:xs) = oddOf xs
13:04:38 <shapr> and then anyone can pull from your FLM repo to update their own
13:04:42 <jadrian> autechre_: one way to do it is simply
13:04:44 <jadrian> odds (x:y:xs) = y:odds xs
13:04:44 <jadrian> odds _ = []
13:05:11 <|m0rph|> hy!!
13:05:17 <ayrnieu> jadrian - [1,2,3]
13:05:17 <|m0rph|> i need help
13:05:18 <shapr> greetings |m0rph| 
13:05:19 <Lemmih> Hey |m0rph|
13:05:22 <|m0rph|> with read
13:05:22 <shapr> I need help too!
13:05:26 <jadrian> ayrnieu: ?
13:05:34 <|m0rph|> can you help me ?
13:05:43 <jadrian> ayrnieu: the first pos is 0
13:05:47 <jadrian> ayrnieu: ;)
13:05:48 <shapr> n0t until you ask a questi0n!
13:06:07 <jadrian> ayrnieu: which is even
13:06:09 <Lemmih> |m0rph|: Probably.
13:06:14 <|m0rph|> how do i use the read class to "read" a tuple ?
13:06:33 <Lor> From where?
13:06:40 <|m0rph|> i want to be able to read something like this "[(1,'a',2),(2,'b',c)]
13:06:47 <|m0rph|> readList doenst work ...
13:07:21 <Lemmih> |m0rph|: 'read' should do it.
13:07:24 <wagle> you prolly have to explicitly typecast the readList?
13:07:37 <|m0rph|> Lemmih: let me test ok ?
13:08:04 <jadrian> |m0rph|: "[(1,'a',2),(2,'b',c)]" <--   2 and c in the last position of the tuples
13:08:14 <jadrian> |m0rph|: how are you supposed to read that...
13:08:18 <wagle> umm..  actually, it occurs to me that i've never actaully tried, though i've gathered a bag of tricks to solve it once i do try
13:08:22 <|m0rph|> ops
13:08:26 <|m0rph|> my mistake
13:08:35 <|m0rph|> "[(1,'a',2),(2,'b',5)]"
13:08:41 <|m0rph|> Int,char,int
13:09:02 <jadrian> *Main> read "[(1,'a',2),(2,'b',5)]" :: [(Int,Char,Int)]
13:09:02 <jadrian> [(1,'a',2),(2,'b',5)]
13:09:03 <Lemmih> @type read "[(10,'c',20)]" :: [(Int,Char,Int)]
13:09:04 <lambdabot> read "[(10,'c',20)]" :: [(Int,Char,Int)] :: [(Int, Char, Int)]
13:09:49 <|m0rph|> it works
13:09:54 <|m0rph|> quite simple eh ? :)
13:10:19 <|m0rph|> i'm quite enjoing haskell
13:10:37 <|m0rph|> cata ana hylo morphism
13:10:49 <jadrian> what about para?
13:10:54 <|m0rph|> never heard
13:10:55 <|m0rph|> ;)
13:11:00 <jadrian> nobody likes paramorphisms...
13:11:13 <|m0rph|> i've studied it i think
13:11:18 <jadrian> logo vi :)
13:11:24 <|m0rph|> ai ? ? P
13:11:25 <jadrian> braga?
13:11:36 <wagle> NOUN:
13:11:36 <|m0rph|> yah
13:11:38 <wagle> Structural alteration of a mineral without change of chemical composition
13:11:53 <jadrian> whenever someone talks about cata ana hylo morphisms I have to check if their from Braga :D
13:11:58 <|m0rph|> lol
13:12:00 <Cale> homo- endo- auto- epi- mono- iso- morphism as well :)
13:12:11 <wagle> braga?
13:12:23 <jadrian> wagle: portuguese city
13:12:25 <|m0rph|> braga is a city ..
13:12:46 <jadrian> Cale: well I guess those are different kinds of classifications no?
13:13:22 <Cale> they're still classifications of functions
13:13:24 * wagle waits for genuine faux morphisms
13:13:45 <jadrian> Cale: yeap (of morphism actually) :)
13:14:09 <jadrian> Cale: by the way
13:14:15 <Cale> yeah, they're related by the fact that they're classifications of structure preservation
13:14:52 <jadrian> Cale: it is correct to say endo-catamorphism, right?
13:15:17 * stepcut wishes someone would write 'The haskellers guide to *morphism"
13:15:46 <|m0rph|> and to monads
13:15:47 <|m0rph|> :P
13:15:50 <|m0rph|> state mondas
13:15:55 <jadrian> Cale: for a catamorphism that produces an object of same type
13:16:01 <musasabi> state monads are quite easy.
13:16:03 <wagle> mondo's
13:16:14 <musasabi> |m0rph|: have you read the nomaware tutorial?
13:16:21 <Cale> endo means that it is a mapping from a domain to itself
13:16:28 <shapr>  hi Cale!
13:16:29 <stepcut> endo-hylo-cata-ana-expi-ali-docious
13:16:31 <shapr> how's code?
13:16:36 <jadrian> Cale: exactly
13:16:38 * shapr quickly quotes stepcut 
13:16:38 <|m0rph|> musasabi: nop
13:16:47 <|m0rph|> where can i get it ?
13:16:52 <wagle> yeah..  i was going to recommend nomaware too
13:16:56 <Cale> It's okay -- haven't written much code lately. I'm at uni, studying pure math :)
13:16:59 <wagle> http://www.nomaware.com/monads/html/index.html
13:17:12 <Cale> there's also my article on monads :)
13:17:36 <shapr> oh hey, is there any theory on quasi-tiles applied to three dimensions?
13:17:50 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
13:17:54 <shapr> who was that guy who wrote the 40-variable equation for n-dimensional tiled shapes?
13:18:15 <Cale> I'm afraid I haven't really studied much on tilings.
13:18:21 <wagle> i know roger penrose does tiling stuff, but thats all i know
13:18:44 <shapr> yah, but did his theories get generalized to n-dimensions?
13:19:17 <wagle> as he is a physicist, I would expect him to have tried
13:19:23 <shapr> Cale: hey, did you read my blog entry on Internal Computing?
13:19:36 <Cale> Nope, where is it?
13:19:38 <Philippa> don't think I saw that - gastric CPUs?
13:19:49 <Philippa> "damn, I just crapped out my mail server"
13:19:51 <shapr> I'm looking for ways to extend powerful programming patterns into human thinking patterns...
13:19:56 <Philippa> ah :-)
13:20:05 <Cale> ah
13:20:07 <Cale> hmm...
13:20:17 <shapr> Cale: http://www.scannedinavian.com/2004-11-08.html
13:20:17 <Cale> I think I recall you mentioning something about that.
13:20:30 <Philippa> got any (semi-)examples?
13:20:42 <shapr> Vedic maths, slide rules, spoken crypto
13:21:02 <wagle> i get a bunch of googlehits for "3-D tiling"
13:21:02 <shapr> monads seems like such a simple and regular pattern that it probably could be used in speech
13:21:18 <shapr> I'm not yet sure how, but I suspect I'll figure out something.
13:21:59 <wagle> shapr: take a gander at "diagrammatic reasoning"?
13:22:06 <shapr> never heard of it
13:22:07 * shapr googles
13:22:31 <shapr> ah
13:22:40 <shapr> ah, this is interesting.
13:23:02 <Cale> Speech is almost monadic.
13:23:10 <shapr> how so?
13:23:21 <shapr> context gets piped implicitly?
13:23:34 <Philippa> yeah. Plus more generally, the "merging trees into something linear" of it
13:23:50 <Philippa> or possibly merging in graphs, which is what arrows typically do
13:23:52 <Cale> yeah, I was thinking of it more in the sense of trees
13:24:26 <wagle> http://216.239.57.104/search?q=cache:Fd9W3lUkiEoJ:hltheses.elsnet.org/ESSLI/shan.pdf+natural+language+monad&hl=en
13:24:47 <shapr> huh, ccshan
13:25:04 <shapr> wagle: nice find :-)
13:25:35 <wagle> googled for natural language monad
13:25:39 <Cale> http://hltheses.elsnet.org/ESSLI/shan.pdf
13:25:59 <xerox> a question
13:25:59 <xerox> main = do
13:26:00 <xerox>   hSetBuffering stdin LineBuffering
13:26:05 <xerox> c:/ex3_10.hs:5: Variable not in scope: `hSetBuffering'
13:26:07 <xerox> ?
13:26:14 <Cale> import IO
13:26:18 <shapr> @index hSetBuffering
13:26:19 <lambdabot> GHC.Handle,System.IO,IO
13:26:20 <xerox> pff i'm sorry.
13:27:40 <shapr> on a vaguely related subject, I've been thinking about a drop-dead simple spoken programming language. I haven't gotten past lexing, but I thought maybe I could find the N most common sounds humans make, and use those for 'chars'
13:27:59 <wagle> you seen loglan?
13:28:09 <shapr> xu do tavla mi bau la lojban
13:28:36 <shapr> problem is, loglan and lojban already have a bunch of structure, they're really for communication
13:28:42 <shapr> @cmafihe xu do tavla mi bau la lojban
13:28:43 <lambdabot> xu <UI6> [yes/no?] do <KOhA3> [you] tavla <BRIVLA> [talk] mi <KOhA3> [I
13:28:43 <lambdabot>  me] bau <BAI> [in language] la <LA> [ ] lojban <CMENE> [] 
13:29:13 <shapr> But I really want spoken ascii, and no predefined structure on top of it.
13:29:32 <shapr> For example, Lojban is really too complicated for a spoken assembly language.
13:29:40 <wagle> ooo...  i dunno what sidetracked me from actually getting around to learning loglan
13:30:08 <shapr> I like the predicate-based structure, but it's still not really that good for communicating with computers.
13:30:21 <wagle> my mac comes with speech recognition, but i havent gotten around to playing with it yet
13:30:27 <shapr> especially not if I want to hack up the speech recog software myself.
13:31:13 <tuomov> my phone has some voice recog. stuff and it only gets things right half of the time
13:31:13 <shapr> I got RSI, and it comes and goes, but I don't like spending so much time away from coding to make it go.
13:31:26 <tuomov> as if it only reacted to sound levels or something
13:31:31 <shapr> So I figure, if I can find an easy way to bootstrap a simple spoken lang, I can get around that problem.
13:32:13 <wagle> i think you and the speech recognition program want to train each other
13:32:41 <wagle> you both fiugure out that you find hard and what you find easy
13:32:58 <wagle> then you evolve from there
13:33:11 <tuomov> yeah.
13:33:14 <shapr> hm, interesting approach.
13:33:55 <tuomov> I have 'kalenteri' for calender and ajastin for 'stopwatch' and what it cares about is "kAzzzzzz" and "Ajzzzzzz"
13:34:28 <tuomov> and the 'ka' must be very strong or it will default to 'ajastin'
13:35:13 <shapr> hm
13:36:26 <wagle> the duration of a k is pretty short [and noisy?], unless you emphasize (lengthen, etc) it
13:36:35 <shapr> well, that's another fun thing to investigate after FLM is released.
13:36:41 <wagle> flm?
13:36:51 <shapr> Fermat's Last Margin
13:37:16 <shapr> shared research paper notes
13:37:37 <wagle> oh yeah, that is what you calling that
13:37:41 <shapr> yup
13:37:52 <shapr> maybe I need a more memorable name.
13:38:08 <wagle> i remembered the name, but not what it was
13:38:20 <shapr> maybe I need a more memorable project =)
13:38:25 * shapr snickers
13:38:25 <wagle> seemed a reasonable name, though
13:38:51 <shapr> anyone used HUnit with test fixtures?
13:39:04 <shapr> I'm trying to find a less-than-ugly way to test my darcs integration.
13:39:08 <tuomov> fermat's last tick. that would abbreviate to flt
13:39:12 <tuomov> and everyone knows what is flt
13:39:20 <shapr> what is flt?
13:39:26 <tuomov> fermat's last theorem?-)
13:39:31 <shapr> oh duh =)
13:39:36 * shapr snickers
13:40:16 <Cale> or Fermat's Little Theorem
13:40:23 <Cale> :)
13:40:59 <wagle> i'm still waiting for an explanation of WGBP
13:41:25 <shapr> ?
13:41:40 <shapr> Wagle's Giant Big Project?
13:42:16 <wagle> Wiles Great Big Proof
13:42:22 <xerox> fst and snd doesn't work on tuples, am i right?
13:42:26 <wagle> closest i'm seen is
13:42:28 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/0123392519/qid=1101505273/sr=8-2/ref=sr_8_xs_ap_i2_xgl14/104-1620051-1126362?v=glance&s=books&n=507846
13:42:41 <wagle> @type fst
13:42:42 <lambdabot> fst :: forall a b. (a, b) -> a
13:43:39 <wagle> you could use records instead of tuples, and access by field name
13:45:05 <xerox> mmh
13:45:21 <xerox> or use ((a, b) c) :)
13:45:28 <xerox> ((a, b), c)
13:45:30 <wagle> hmm..  i think i saw that template haskell had a way to generate generalized accessors..  8) 8/
13:45:55 <xerox> but in fact i only need to store numbers, so a list would be enough
13:45:59 <wagle> will you be able to read that code in 9 months?
13:47:21 <wagle> tuples have some notoriety for being clumsy in haskell
13:48:29 <Cale> http://www.fen.bilkent.edu.tr/~franz/ta/ta-flt.pdf -- there's a little overview
13:50:02 <wagle> hey, cool, i whole new crop of "FLT for ordinary mortals" books have been released since I last looked
14:06:04 <xerox> why "map (print) [1,2,3]" doesn't work?
14:06:24 <TheHunter> it returns a list of actions
14:06:46 <TheHunter> to execute them you can either sequence this list or use mapM in the first place.
14:07:05 <xerox> nice
14:07:08 <TheHunter> @type sequence
14:07:10 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
14:07:40 <TheHunter> so, sequence [print "foo", print "bar"] is the same as print "foo" >> print "bar"
14:08:01 <xerox> '>>' ?
14:08:22 <TheHunter> you know monads?
14:08:35 <xerox> mmh
14:08:48 <xerox> it's my first monad execise, i know 'do'
14:09:12 <TheHunter> ok x >> y is the same as do {x; y}
14:09:23 <xerox> ah!
14:10:48 <xerox> is there a clean way to reverse the order of a list?
14:10:54 <monochrom> Hudak's book has the translation between "do ..." and ">>, >>="
14:11:10 <TheHunter> @type reverse
14:11:10 <monochrom> reverse [1,2,3,4,5]  will do wonders.
14:11:11 <lambdabot> reverse :: forall a. [a] -> [a]
14:11:15 <xerox> uh.
14:11:23 <xerox> @get-definition reverse
14:11:23 <lambdabot> reverse = foldl (\x y.y:x) []
14:11:32 <xerox> i thougth it was foldl!
14:12:11 <monochrom> @get-definition putStrLn
14:12:12 <lambdabot> putStrLn not defined
14:12:21 <monochrom> Bummer!
14:12:38 <wagle> @get-definition Bummer!
14:12:38 <lambdabot> Bummer! not defined
14:12:55 <wagle> why you interested in reverse?
14:12:58 * monochrom boogles
14:13:00 <xerox> show (reverse (tail (tail res))) != show . reverse . tail . tail res
14:13:01 <xerox> ?
14:13:30 <monochrom> note the operator precedences
14:13:40 <xerox> wagle because of an exercise
14:13:53 <xerox> Exercise 3.10 -- Write a program that will repeatedly ask the user for numbers until she types in zero, at which point it will tell her the sum of all the numbers, the product of all the numbers, and, for each number, its factorial.
14:13:59 <wagle> == (s . r . t . t) res
14:14:14 <xerox> monochrom oh, that is..
14:14:17 <monochrom> There is no reverse in the problem.
14:14:24 <xerox> i know
14:14:31 <xerox> let me finish it and i'll show you my version
14:14:48 <monochrom> NO! I don't want to see a suboptimal solution.
14:15:05 <xerox> so close eyes ^_^
14:17:08 <onyx> Hi guys if I have a type IO Something and I need it to be converted in Something how do you do it?
14:17:20 <TheHunter> you don't
14:17:33 <onyx> hahah that's what i was affraid of
14:17:37 <TheHunter> @hawiki ThatAnnoyingIOType
14:17:37 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
14:17:42 <TheHunter> @wiki ThatAnnoyingIOType
14:17:42 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
14:18:18 * Lunar^ freaks out
14:18:28 <Lunar^> ./ kills
14:18:39 <Lunar^> (read ./)
14:18:55 <Lunar^> (re-read /.)
14:19:14 <wagle> no, @wiki ThatAnnoyingIOType is http://www.haskell.org/hawiki/ThatAnnoyingIoType
14:19:19 <monochrom> You never ask how to convert IO x to x.  You keep refactoring your program until you feel no such need.
14:19:32 <TheHunter> oops, sorry
14:19:45 <kristnjov> onyx: return foo
14:19:48 <monochrom> Extreme Programming dictates that you refactor your program everyday.
14:19:51 <wagle> @wiki ThatAnnoyingIOType is http://www.haskell.org/hawiki/ThatAnnoyingIoType
14:19:52 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType is http://www.haskell.org
14:19:52 <lambdabot> hawiki/ThatAnnoyingIoType
14:19:53 <xerox> ok
14:20:16 <wagle>  @wiki ThatAnnoyingIOType
14:20:24 <wagle> @wiki ThatAnnoyingIOType
14:20:24 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
14:20:48 <wagle> arghhhhh
14:20:58 <xerox> http://151.41.164.9/haskell/ex3_10.hs
14:21:11 <wagle> @help
14:21:11 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
14:21:17 <wagle> @listcommmands
14:21:17 <lambdabot> Sorry, I don't know the command "listcommmands", try "lambdabot: @listcommands
14:21:25 <wagle> lambdabot: @listcommands
14:21:26 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
14:21:26 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
14:21:26 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
14:21:26 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
14:21:26 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
14:21:27 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
14:21:28 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
14:21:30 <onyx> thanks guys, i was doign that perfectly for certain parts of program but the trouble arises when i apply that same fucntion again, kinf of hard to explain i guess
14:21:30 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
14:21:32 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
14:21:43 <kristnjov> ...
14:22:01 <xerox> monochrom is it that bad ?
14:22:33 <Lunar^> wagle: Please don't do that
14:23:00 <monochrom> I was kidding.  Thought an appeal to some "best practice" buzzwords would support my argument. :)
14:23:04 <wagle> Lunar^: like i expected that
14:24:02 <kristnjov> lambdabot: @quit
14:24:03 <lambdabot> not enough privileges
14:24:06 <Nioate> xerox: you know there are product and sum functions, so all you have to do is accumulate the list of numbers
14:24:07 <kristnjov> :)
14:24:18 <xerox> Nioate you're right!! ...
14:24:28 <kristnjov> lambdabot: @fortune
14:24:29 <lambdabot> Our [softball] team usually puts the other woman at second base, where the
14:24:29 <lambdabot> maximum possible number of males can get there on short notice to help out
14:24:29 <lambdabot> in case of emergency.  As far as I can tell, our second basewoman is a pretty
14:24:29 <lambdabot> good baseball player, better than I am, anyway, but there's no way to know
14:24:29 <lambdabot> for sure because if the ball gets anywhere near her, a male comes barging
14:24:29 <lambdabot> over from, say, right field, to deal with it.  She's been on the team for
14:24:31 <lambdabot> three seasons now, but the males still don't trust her.  They know, deep
14:24:33 <lambdabot> in
14:24:35 <lambdabot> their souls, that if she had to choose between catching a fly ball and saving
14:24:38 <lambdabot> [3 @more lines]
14:24:47 <Nioate> xerox: also, using lists for returning s p and l is a bit icky
14:24:58 <kristnjov> ..
14:24:59 <kristnjov> lambdabot: @fortune
14:25:00 <lambdabot> Rincewind had generally been considered by his tutors to be a natural wizard
14:25:00 <lambdabot> in the same way that fish are natural mountaineers.  He probably would have
14:25:00 <lambdabot> been thrown out of Unseen University anyway--he couldn't remember spells
14:25:00 <lambdabot> and
14:25:00 <lambdabot> smoking made him feel ill.
14:25:00 <lambdabot> 		-- Terry Pratchett, "The Light Fantastic"
14:25:01 <monochrom> Is that a combinatorics question?
14:25:19 <monochrom> Why are these fortune lines all so long?
14:25:31 <Lemmih> @more
14:25:31 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
14:25:32 <kristnjov> that's what i was thinking
14:25:35 <Nioate> xerox: is there any reason not to use a tuple?
14:25:42 <xerox> Nioate no really
14:25:51 <xerox> i didn't tought about sum and product funcions
14:35:47 <wagle> what is a "Thing With Identity"?
14:36:55 <xerox> Nioate, what do you think now?
14:36:58 <xerox> http://151.41.164.9/haskell/ex3_10.hs
14:38:07 <Nioate> xerox: it works
14:38:12 <xerox> it does
14:38:29 <xerox> (any improvements, tips, things to know that i'm doing "wrong" again?)
14:39:04 <xerox> for example the reverse .. ?
14:39:06 <Nioate> you could move reverse into askNumber
14:39:14 <xerox> mmh
14:40:05 <xerox> is that covenient?
14:41:05 <Nioate> it removes a line of code
14:41:18 <Nioate> it doesn't matter too much though
14:55:26 <wagle> askNumber might return (reverse l)
14:55:35 <xerox> okie
14:56:13 <xerox> http://151.41.164.9/haskell/ex3_10.hs
14:56:15 <xerox> it cleans up.
14:56:15 <wagle> could refactor askNumber so it doesnt reverse the list in the first place..  (exercise for reader)
14:57:25 <xerox> i tought about it
14:57:34 <xerox> foldl during recursive call ?
15:04:38 <wagle> you are using tail recursion..  you might want to do that, but you dont have to
15:05:46 <xerox> i did it like the previous examples from the book
15:06:00 <wagle> which book?
15:06:01 <xerox> how can i do it differently?
15:06:06 <xerox> "yet another haskell tutorial"
15:06:42 <wagle> do you know what i mean by "tail recursion"?
15:06:48 <xerox> yep!
15:07:00 <wagle> do you see what the tail call is?
15:07:07 <wagle> do you see where the tail call is?
15:07:19 <xerox> yes
15:07:26 <xerox> last line :D
15:07:46 <wagle> do you have a whiteboard i can use?  8/
15:08:00 <xerox> haha!
15:08:33 <wagle> have you heard the term "procedural accumulator"?
15:09:09 <xerox> what do you mean?
15:09:26 <wagle> you know the term "accumulator"?
15:09:30 <xerox> yep
15:10:12 <wagle> a variable foo is an accumulator if you keep using its old value (in particular ways) to compute its new value
15:10:21 <wagle> for example:  foo = foo + 1
15:10:54 <xerox> do you know scheme ?
15:10:57 <wagle> in that example foo :: Int
15:11:01 <wagle> yes
15:11:07 <wagle> yes, i know scheme
15:11:13 <xerox> wait a second
15:11:38 <xerox> (define reverse!
15:11:38 <xerox>   (lambda (s)
15:11:38 <xerox>     (let loop ((s s) (r '()))
15:11:38 <xerox>       (if (null? s) r
15:11:38 <xerox> 	  (let ((d (cdr s)))
15:11:39 <xerox>             (set-cdr! s r)
15:11:40 <xerox> 	    (loop d s))))))
15:11:48 <xerox> r = procedural accumulator
15:11:48 <xerox> ?
15:12:43 <wagle> not what i mean
15:12:47 <xerox> ok
15:12:58 <wagle> suppose foo :: Int -> Int
15:13:13 <wagle> i can still use foo as an accumulator:
15:13:39 <wagle> for example  foo = (\x . foo x + 1)
15:13:57 <xerox> mmh
15:14:03 <xerox> foo x = foo x + 1
15:14:03 <xerox> ?
15:14:29 <wagle> it isnt a recursive definition
15:14:41 <xerox> i don't know the (\x .. form
15:14:50 <Lemmih> Haddock can't handle files processed with 'ghc -E -cpp'?
15:14:56 <wagle> the new binding of foo is defined in terms of the old binding of foo
15:15:22 <wagle> haskell (\x -> x) == scheme (lambda (x) x)
15:15:23 <xerox> btw i tought one can't change values or whatelse
15:15:59 <wagle> i'm shadowing the old binding of foo with a new binding of foo
15:16:21 <wagle> this is easier in scheme, using its "let"
15:16:33 <xerox> okie
15:17:17 <wagle> so if i input the values, a, b, c, d 
15:17:50 <wagle> I want the list [a, b, c, d]
15:18:06 <xerox> yep
15:18:07 <wagle> but that is a : b : c : d : []
15:18:17 <xerox> yes!
15:18:23 <wagle> but that is a : (b : c : d : [])
15:18:26 <xerox> i think i got what you're thing to say
15:18:30 <wagle> but that is a : (b : (c : d : []))
15:18:34 <wagle> but that is a : (b : (c : (d : [])))
15:18:48 <wagle> but that is a : getnextnumber
15:18:56 <wagle> ...
15:19:58 <wagle> the problem you have is that you are trying to construct the complete list as you go
15:20:25 <wagle> taking a : b : c : d : []
15:20:43 <wagle> to something like (a : b) : c : d : []
15:20:51 <wagle> to something like ((a : b) : c) : d : []
15:20:52 <wagle> ...
15:21:05 <wagle> but that doesnt work
15:21:09 <xerox> i first have []
15:21:14 <wagle> so you gotta reverse
15:21:58 <wagle> you are inductively creating a list, starting with the simplest list [], and producing longer and longer lists
15:22:33 <xerox> mmmmmmh
15:22:48 <wagle> since you are receiving the elements of the list from first to last, you necessarily have to reverse it to inductively create the list
15:23:24 <xerox> it seems
15:23:50 <TheHunter> wagle, are you implying there's anything wrong with xerox's code?
15:23:57 <TheHunter> because i think it is perfectly fine.
15:24:26 <xerox> i've got an idea let me try it
15:24:36 <wagle> not wrong, just that there is another way to do it, and the required use of reverse is "unsatifying"
15:24:53 <TheHunter> wagle, i don't think so.
15:25:03 <wagle> i'm just saying that he should understand both ways
15:25:16 <xerox> yeah!
15:25:19 <xerox> i'll show you
15:25:44 <TheHunter> there's no way you can avoid having to save all the (processed) input anyway.
15:25:44 <xerox> http://151.41.164.9/haskell/ex3_10.hs
15:25:53 <wagle> eep..  now its O(n^2) or so?
15:27:02 <wagle> i'm thinking something like if ... then return [] else num : ask
15:27:45 <TheHunter> wagle, (num:) `fmap` ask
15:28:09 * xerox is lost
15:28:16 <xerox> what about the foldr thing? :)
15:29:06 <wagle> if you input a list of a billion numbers, how many :'s do you do?
15:29:16 <xerox> ouch.
15:29:53 <wagle> i should only do a billion :'s
15:30:09 <wagle> reverse does an extra billion
15:30:35 <wagle> tail recursion does two billion :'s
15:31:00 <TheHunter> (which doesn't matter because it's a constant factor)
15:31:03 <wagle> my alternative does one billion :'s, but at the cost of generating a billion stack frames
15:31:37 <xerox> so it was better before
15:31:42 <wagle> i do real time..  constant factors arent always ignorabe
15:31:42 <xerox> with reverse and : ?
15:31:56 <wagle> you are using tail recursion
15:32:21 <wagle> you create the reversed list, then reverse it..  each : happens twice
15:33:00 <xerox> yes
15:33:57 <wagle> my gedanken experiment creates a stream who's first element is the first element of the correct answer, and so forth
15:35:25 <xerox> wagle so how to.. ?
15:35:32 <wagle> when you do a stream "right", the prefix of the list can be garbage collected as you proceed down the list
15:36:14 <xerox> mmh
15:36:15 <wagle> if the recursive call is of the form "num : askNumber"
15:36:30 <xerox> but i need all the list in the end
15:36:44 <xerox> or i should save the sum/producs/! values
15:37:47 <wagle> and the termination is of the form "[]" (or return [])
15:38:21 <wagle> as TheHunter notes, your code was fine
15:38:33 <wagle> i'm just going after an alternative
15:38:52 <xerox> good :D
15:39:16 <wagle> i think the main thing is that you've combined several aspects into a single procedure
15:39:25 <xerox> i didn't understand if it was better with : and reverse, or now with foldr
15:39:38 <wagle> foldr isnt helping
15:40:01 <xerox>     then (return . reverse) l
15:40:02 <xerox>     else askNumber (num:l)
15:40:03 <xerox> ok.
15:40:45 <wagle> i think your foldr is the equivalent of "l ++ [num]"
15:42:02 <wagle> i think your foldr is the equivalent of "[num] ++ [l]""
15:42:11 <wagle> umm.. does that code "work"?
15:42:23 <wagle> i can never keep foldr straight
15:42:34 <xerox> it does!
15:42:45 <xerox> *Main> main
15:42:46 <xerox> Give me a number (or 0 to stop): 1
15:42:46 <xerox> Give me a number (or 0 to stop): 2
15:42:46 <xerox> Give me a number (or 0 to stop): 3
15:42:46 <xerox> Give me a number (or 0 to stop): 0
15:42:46 <xerox> The sum is 6
15:42:49 <xerox> The product is 6
15:42:50 <xerox> 1
15:42:52 <xerox> 2
15:42:54 <xerox> 6
15:43:11 <wagle> well, i suspect its doing O(n^2) :'s
15:43:54 <xerox> why?
15:44:11 <TheHunter> the point is, you're doing (essentially) l ++ [num], which is bad, as the first argument of (++) should be small.
15:45:40 <xerox> why?
15:45:46 <TheHunter> [] ++ ys = ys
15:45:50 <wagle> add an argument to count the : operations
15:45:51 <Lemmih> shapr: Yo?
15:46:00 <TheHunter> (x:xs) ++ ys = x : (xs ++ ys)
15:46:24 <xerox> TheHunter mmh, yes
15:46:48 <TheHunter> so no matter how short ys is, you have to traverse the whole list xs which might be long.
15:47:12 <xerox> ah!
15:47:18 <wagle> if length l == 1000000, how many :'s does the foldr do?
15:47:40 <xerox> without side-effects is difficult to test?
15:47:50 <TheHunter> therefore, (++) is right associative, so xs ++ ys ++ zs means xs ++ (xs ++ ys) which is faster than (xs ++ ys) ++ zs
15:48:41 <xerox> xs ++ ys ++ zs means xs ++ (ys ++ zs) ?
15:48:45 <wagle> given l, write a function that computes how many :'s foldr (:) _ l does
15:49:32 <xerox> wagle i think (lengh l)
15:50:37 <TheHunter> xerox, yeah, that's what i meant.
15:50:46 <xerox> TheHunter oh, ok :D
15:51:15 <wagle> could also use "foldr (\_ y -> y + 1) 0 l"
15:51:40 <xerox> _ has some obscure meanings in your expressions wagle?
15:51:48 <wagle> have to do a little more to actually count the :'s for askNumber
15:52:05 <musasabi> _ means that it is ignored
15:52:09 <wagle> _ is the "i dont care" variable name
15:52:26 <xerox> i know that as the pattern thing that match everything 
15:52:29 <xerox> ok.
15:52:37 <monochrom> (_ -> 10) (0/0) is 10. :)
15:52:40 <wagle> i'm being fast and loose
15:53:00 <monochrom> (Don't try this at home with your ordinary eager language! :)
15:53:14 <xerox> mhmh
15:53:16 <xerox> let's try :D
15:53:42 <xerox> (\_ -> 10) (0/0) actually is, correct ?
15:53:48 <monochrom> Yes.
15:54:03 <monochrom> Oops now I see I had a typo.
15:54:51 <xerox> ! :D
15:58:45 <Lunar^> monochrom: hehe :)
16:00:22 <xerox> very sleepy
16:00:31 <xerox> 00:58 <xerox> very sleepy
16:00:35 <xerox> g'night :)
16:00:41 <Nioate> bye
16:00:42 <xerox> (thanks everybody)
16:01:54 <wagle> g'night..
16:02:15 <monochrom> 19:00 here. I'm sleepy too.
16:02:36 <wagle> 4pm here..  and i'm sleepy..  wtf?
16:02:50 <TheHunter> night everybody!
16:03:00 <monochrom> The witch has cast the sleep spell.  Only a prince will save us now!
16:03:56 <wagle> how about a prints?
16:04:27 <monochrom> Can a prints kiss?
16:05:06 <wagle> Keep It Simple, Stupid?  depend on its implementation
16:07:23 <wagle> is a joke funny until someone looks at it?
16:08:51 <stepcut> I think 'Strongly typed heterogeneous collections' has permanently warped me
16:09:11 <wagle> how does that work?
16:10:39 <wagle> http://homepages.cwi.nl/~ralf/HList/slides-dgp-2004/slide1.html
16:12:05 <wagle> yet another weak approximation of subtypes?
16:12:25 <stepcut> I keep wanting to stick dependant types in all my haskell code
16:13:33 <stepcut> wagle: I take it you have not read the paper?
16:13:44 <stepcut> http://scholar.google.com/url?q=http://homepages.cwi.nl/~ralf/HList/paper.pdf
16:14:03 <wagle> no..  looking at the slides, in my prematurely sleepy state
16:15:09 <stepcut> It is my (perhaps wrong) understanding that they use the haskell type classes to define dependantly typed lists, and from that they can build extensible records, subtyping, etc
16:15:49 <stepcut> and make guarantees like 'this list has at least one element' or 'every type in this hetregeneous list appears exactly once'
16:17:15 <stepcut> in a related paper, they use the hlist extensible records to write object-oriented programs, where object-oriented can be whatever that means in your favorite OO language ...
16:17:20 <redhatPT> hi there
16:18:43 <Lemmih> hackagebot: @quit
16:19:40 <stepcut> hehe
16:19:43 <wagle> yeah, i think its dependent types in pure types (ie, no values)
16:19:58 <stepcut> yeah
16:20:25 <stepcut> its power is very sexy -- its type error messages are obscene though ;)
16:20:47 <wagle> TAANSTAAFL
16:20:53 <stepcut> but it really makes long for a practical version of epigram
16:22:50 <wagle> their html slides seem to be dropping chars
16:23:53 <wagle> does it use some (implied) newtype trickery under the covers?
16:24:37 <wagle> nm
16:25:26 <wagle> i bet you cant define Hlist streams?
16:25:50 <stepcut> streams ?
16:27:01 <wagle> i'm still poking through the slides..  i have the impression that they must be tracking the complete type of the heterogeneous values at "compile time"  (type checking time), so you couldnt have unbounded values)
16:27:17 <wagle> maybe i should free-associate here
16:27:23 <wagle> maybe i shouldNT free-associate here
16:27:57 <stepcut> ah, I understand 
16:28:21 * stepcut ponders
16:29:52 <stepcut> I think you might be able to do streams -- depends on what you want to be enforced..
16:30:04 <musasabi> I think you can have streams but you have to statically determine the contents on the type level.
16:30:27 <wagle> wouldnt that require an infinite type?
16:30:54 <musasabi> no stream communication should definitely be finite ;)
16:31:01 <musasabi> *no, 
16:31:17 <musasabi> but that makes it unsuitable for real apps.
16:31:32 <wagle> finite, but unbounded
16:31:44 <wagle> or something like that
16:31:57 <dons> this is quite an interesting idea, I think we'd have to read the hlist paper again
16:32:07 <stepcut> wagle: If the stream had a repeating type pattern, it might be possible to extend hlist to suppor that (Int, Char, Float, Int, Char, Float, Int, Char, Float)
16:32:11 <dons> the other, more common, soln is to send Dynamics down the stream
16:32:30 <wagle> regular expressions
16:32:30 <dons> stepcut: yeah, that sounds possible
16:32:42 <wagle> pumping lemma
16:32:47 <dons> regex on the type level?
16:33:02 <stepcut> wagle: Or you say, the order is uknown, but I know it will be one of these types, Int, Char, or Float..
16:33:31 <wagle> i think you have to know the type BEFORE you look at it
16:33:35 <stepcut> wagle: the hlist support supports mixing static and dynamic 'typing' in a heterogeneous list
16:33:58 <wagle> ahh..  ok, i thought they were tagless, static
16:34:01 <musasabi> stepcut: then you would create an algebraic datatype.
16:34:02 <dons> so you'd still have to typecase the value on arrival?
16:34:07 <musasabi> data Foo = I Int, ...
16:34:33 <stepcut> wagle: so rather than an all or nothing, you can have some portions of list statically known, and other portions dynamically known
16:35:32 <wagle> does the polymorphic constructor turn into a different tag for each variant?
16:36:01 <stepcut> wagle: what do you mean by that ?
16:36:19 <CosmicRay> @index mplus
16:36:19 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
16:36:19 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
16:36:19 <lambdabot> State,Control.Monad.Writer,Monad
16:38:20 <wagle> if you have Hcons (::Number) (:: _) and Hcons (::Char) (:: _), it might generate two tags...
16:39:38 <wagle> so that Hlist has a Hcons constructor for each variant of Hcons
16:39:57 <stepcut> wagle: no, I don't think so...
16:40:14 <wagle> i'm too sleepy to concentrate on the paper..  sigh
16:40:19 <stepcut> wagle: the paper (not the slides) explain everything in gory detail though :)
16:40:25 <stepcut> and I mean gory
16:41:50 <wagle> they do this all in standard haskell?
16:42:40 <stepcut> yes
16:42:51 <stepcut> well, it uses functional dependencies
16:43:14 <stepcut> so its not quite haskell98, but it does work in both hugs and ghci (without overlapping instances)
16:48:33 <wagle> what option in hugs?
16:49:47 <jadrian> well 
16:49:54 <wagle> ooops, second to last paragraph sez it doesnt work in hugs
16:50:01 <jadrian> if it uses functional dependencies it also uses multi parameter classes
16:50:14 <jadrian> which are also not haskell 98
16:50:57 <wagle> hugs has multi param classes... dunno about functional deps
16:53:00 <jadrian> wagle: yeap
16:53:04 <wagle> hmm.. i've been wanting a completely static sort of subtyping (no "wrong tagm, stupid" errors at run-time)..  this'll have to go on my list
16:53:07 <jadrian> http://cvs.haskell.org/Hugs/pages/users_guide/class-extensions.html#FUNCTIONAL-DEPENDENCIES
16:53:39 * musasabi boings around fervently
16:54:03 <redhatPT> humm can anyone help me? how can I convert map (\x div x 3) [5,6,23,3] to compreension ?
16:54:56 <jadrian> [div x 3 | x<-[5,6,23,3]]
16:55:34 <jadrian> redhatPT: e suse  melhor :P
16:56:57 <redhatPT> jadrian !? :P eh nada
17:10:08 <Lemmih> @hackage Haddock Author
17:10:08 <lambdabot> Sorry, I don't know the command "hackage", try "lambdabot: @listcommands
17:10:09 <hackagebot> Haddock.Author: Simon Marlow
17:11:20 <Lemmih> First working prototype of the Hackage lambdabot module!
17:11:44 <Igloo> Neat  :-)
17:13:57 <Lemmih> hackagebot: @update-hackage
17:13:58 <hackagebot> Download successful. Found 4 packages.
17:14:10 <Lemmih> @hackage HOpenGL License
17:14:11 <hackagebot> HOpenGL.License: BSD-style
17:14:11 <lambdabot> Sorry, I don't know the command "hackage", try "lambdabot: @listcommands
17:14:21 <Lemmih> hackagebot: @hackage HOpenGL Author
17:14:22 <hackagebot> HOpenGL.Author: Svend Panne
17:14:44 <Lemmih> I'm not talking to you, lambdabot!
17:15:01 <dons> hmm. Svend?
17:15:23 <Lemmih> hackagebot: @update-hackage
17:15:24 <hackagebot> Download successful. Found 4 packages.
17:15:27 <Lemmih> hackagebot: @hackage HOpenGL Author
17:15:28 <hackagebot> HOpenGL.Author: Sven Panne
17:16:57 <dons> :) 
17:20:51 <Lemmih> Good morning, dons.
17:22:14 <dons> morning Lemmih
17:22:22 <Lemmih> How's yi?
17:23:16 <dons> good good. just ironing out  undo/redo atm.
17:23:47 <dons> and working on buiding with nhc98.
17:27:33 * Igloo has found that half the macros in the nhc98 code are untypable
17:27:50 <Lemmih> How will syntax highlighting differ from vim and emacs?
17:29:46 <dons> Igloo: oh, that's lovely :}
17:30:40 <dons> well, the main point will tbe that syn hl is specified by a hasekll parser. not a regex macro lang
17:31:53 <dons> so it will be more accurate, and lets us do things like good indent modes
17:33:13 <jadrian> dons: that could be nice for refactoring tools too right?
17:33:42 <dons> yes, probably. you'd be able to write your own transformations, I guess. but I was planning HaRe support too
17:34:15 <dons> rather than just write :s/a/b/ type transformations, you could write transformations over the abs syn. interesting.
17:35:05 <wagle> aieee..  a real parser!  
17:35:07 <jadrian> I wonder how HaRe works, they must have some kind of parsing too, no?
17:35:19 <dons> I would think so.
17:35:33 <wagle> what do you do for syntactically incorrect stuff?
17:35:40 <Igloo> Yeah, they use programatica to do stuff like that for them I believe
17:36:31 <jadrian> wagle: error "your program is syntactically incorrect" ? :)
17:37:10 <wagle> i was assuming that this is an editor..  i'm missing context
17:37:35 <jadrian> yes, and it is coded in haskell... 
17:37:47 <jadrian> so that could be an option...
17:37:49 <jadrian> nevermind :)
17:38:04 <wagle> well, when I'm typing in a program, it will initially be syntactically incorrect
17:39:02 <jadrian> yeap I know, this is my 1:34am sense of humor :-| 
17:39:06 <jadrian> back to work
17:45:01 <wagle> jadrian: some of the readings in this list contain various solutions to the question i posed (though I suspect its not your main concern)
17:45:04 <wagle> http://www.cse.ogi.edu/PacSoft/projects/perspectives/readingPast.html
17:48:44 <jadrian> wagle: actually I'm interested in specification
17:48:58 <wagle> of what?
17:49:08 <jadrian> wagle: software
17:49:23 <jadrian> wagle: algebraic specification
17:50:02 <jadrian> wagle: that web page seems to have a few things on the subject, but that's probably not what you were referring too...
17:50:15 <jadrian> "A Framework for Expressing the Relationships Between Multiple Views in Requirements Specification"
17:50:19 <wagle> i'm trying to figure out how to specify what the stuff outside the cpu chip is doing..  8/
17:50:50 <jadrian> oh I haven't played with hardware spec yet...
17:51:43 <jadrian> the only tools I've used were some OBJ dialects like CafeOBJ and Maude
17:52:45 <wagle> oh yeah..  talcott talked me into getting interested in maude, then i forgot
17:53:00 <jadrian> wagle: don't even think about CafeOBJ 
17:53:09 <jadrian> wagle: I had a very bad experience with it
17:53:41 <jadrian> wagle: the language seems nice, but documentation and community is non-existent, the tool is buggy.. a shame :-/
17:53:50 <jadrian> maude seems more active
17:55:32 <wagle> one of the things i think important is being able to, when necessary, reason about what machine instruction interleavings are doing
17:56:23 <wagle> this doesn't seem to happen when you do all your reasoning in the (high level) source language
17:59:56 <wagle> since I want to make code self-repairing, prevention is assumed to not be completely possible
18:00:14 <wagle> which, in general, is true
18:07:56 <jadrian> interesting
18:08:33 <jadrian> I know very little about hardware, wouldn't hurt me to study more about it
18:08:39 * shapr boings
18:08:44 <jadrian> hei shapr  
18:08:59 <shapr> la jadrian 
18:09:20 <jadrian> shapr: isn't it kind of... very late... in sweden? :)
18:09:29 <shapr> it's only 3am
18:09:50 <jadrian> hmm I thought you were 2h ahead of me
18:10:00 <musasabi> morning shapr
18:10:04 <musasabi> 4am here.
18:10:11 <shapr> jadrian: no, just two hours above you ;-)
18:10:21 <jadrian> :)
18:10:23 <dons> morning shapr!
18:10:28 <jadrian> 2am here
18:10:28 <shapr> y0y0!
18:10:32 * shapr bounces cheerfully
18:10:45 <jadrian> and I think I already need to get some sleep
18:11:00 <wagle> loosen the string to sit and spin?
18:11:11 * jadrian has his parser and printing functions working... or so it seems
18:11:17 <wagle> i think thats what i am doing..  8/
18:12:16 <shapr> hiya sjc
18:12:29 <jadrian> lava seems nice, I should try it sometime
18:12:41 <jadrian> should I look into VHDL before Lava?
18:12:55 <shapr> wagle: oh, I have a plan for incremental parsers for Yi
18:13:01 <shapr> jadrian: nah, not needed
18:13:14 <shapr> at least, not with the tutorial I've read by Satnam Singh
18:13:19 <wagle> there's a live volcano 50 miles north of me
18:13:33 <jadrian> let me google that name
18:13:45 <jadrian> wagle: how live?
18:13:48 <shapr> sjc: are you new to #haskell? Haven't I seen you here before?
18:14:05 <sjc> yeah first time
18:14:08 <wagle> http://news.google.com/news?q=st+helens&hl=en&lr=&sa=N&tab=nn&oi=newsr
18:14:46 <shapr> sjc: Greetings! Welcome to the world of non-strict referentially transparent programming! What can we do for you?
18:15:39 <wagle> jadrian: does that url work?
18:16:09 <shapr> sjc: Are you learning Haskell? Maybe just checking it out to see if you like it? You want the short intro?
18:16:33 <jadrian> wagle: yeap... ouch, it says "fast growing" there...
18:16:35 <sjc> Just getting started in it really. Working through a couple of tutorials. 
18:16:48 <sjc> When I was at Uni the only functional language they taught us was Hope
18:16:59 <shapr> Oh neat, isn't Hope thoroughly parallel?
18:17:15 <shapr> I think I've read it uses Linda's tuple thingies?
18:17:29 <sjc> I have not idea. Didn't do too well in that subject :-)
18:18:21 <shapr> Well, now you have another chance to tour the world of functional programming!
18:18:25 <jadrian> well off to bed!
18:18:27 <Spark> mirrors are weird
18:18:33 <wagle> g'night
18:18:45 <shapr> g'night wagle 
18:18:53 <shapr> whoops
18:18:55 <shapr> g'night jadrian =)
18:19:04 <jadrian> bye wagle, shapr  
18:19:07 <wagle> need some smoke with the mirrors?
18:19:07 * jadrian is out
18:19:33 <shapr> @wiki HaskellDemo
18:19:33 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
18:19:33 <hackagebot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
18:19:44 <Lemmih> hackagebot: @quit
18:20:05 <shapr> sjc: that HaskellDemo url and http://www.haskell.org/learning.html are good places to start.
18:20:08 <wagle> wagle: get_rich
18:20:13 <wagle> ...  darn
18:20:22 <wagle> wagle: @get_rich
18:20:29 <wagle> ... still didnt work
18:20:36 <shapr> are you using hircules?
18:20:44 <Lemmih> I think it's dependent on the Work module...
18:20:49 * shapr laughs
18:21:57 <wagle> hmm..  hadnt hird of hircules before
18:22:43 <shapr> hircules is a fork of lambdabot, that's why I thought you were using lambdabot commands.
18:24:30 <wagle> need to work some on getting them (correctly) implemented
18:24:57 <shapr> sjc: do you have any questions?
18:25:50 <sjc> Not really
18:25:59 <stepcut> @stepcut
18:25:59 <lambdabot> Sorry, I don't know the command "stepcut", try "lambdabot: @listcommands
18:26:04 <stepcut> :(
18:27:20 <wagle> haha/sigh..  Hope is bitrotted
18:28:05 <shapr> gee, I hope I didn't overwhelm him.
18:28:11 <wagle> oh there we go:
18:28:13 <wagle> http://www.soi.city.ac.uk/~ross/Hope/
18:28:23 <shapr> ross paterson, huh
18:28:38 <wagle> you were a (little) bit overwhelming (overwelcoming?)
18:29:04 * shapr opens the window to chill out
18:29:25 <shapr> it's amazing how many people call me hyperactive.
18:29:34 <dons> shapr needs to be more whelming, and less over whelming
18:30:09 <dons> a nice even whelming is what is required
18:30:24 <shapr> I think 'intense' is more tactful. Though Sean Seefried put it quite tactfully too ;-)
18:30:41 <shapr> he said "A little of Shae goes a long way."
18:30:46 <dons> hehehaha
18:31:06 * shapr grins
18:31:59 <wagle> you were requiring a response from him
18:32:18 <wagle> when he probably had no clue what he wanted
18:32:43 <shapr> good point.
18:32:53 <wagle> "feel free to ask questions" vs "do you have any questions"..
18:33:14 <wagle> even the first phrasing can be construed as the second..
18:33:24 <shapr> hm, yes.
18:36:15 <shapr> thanks for the advice :-)
18:39:42 <wagle> bummer..  newsgroups are dead?
18:39:49 <shapr> which newsgroups?
18:40:05 <wagle> i just discovered the comp.lang.functional faq, and its apparently 2 years dead
18:40:45 <shapr> I stopped reading usenet, too much noise.
18:42:31 <SyntaxNinja> someone should hang a sign on usenet
18:42:46 <shapr> what should the sign say?
18:43:11 <shapr> last two ISPs I've had don't have usenet feeds.
18:43:13 <SyntaxNinja> idono... just something to let people know that usenet used to be cool but is now useless and it should be a lesson to us or somethin
18:43:14 <wagle> comp.lang.functional doesnt look too noisy
18:43:42 <wagle> googlenews
18:44:21 <wagle> (probably more pain than its worth)
18:45:09 <wagle> i still have an account at Indiana University, which gives me access to news..  which i've largely stopped reading..  due to the noise...  8) )
18:48:27 <shapr> I'd like to stop using push communication.
18:48:31 <wagle> hahaha..  graham hutton maintained the faq until 2002, but the common one to find on the web in from 1999
18:49:31 <wagle> its all about balance, and knowing when to push and when not to..  do what i dont, since i have no clue
18:49:50 * shapr grins
18:53:51 <wagle> SIGDINNER
18:55:06 * shapr reads about SASL
19:04:15 <Nioate> is there a general way to tell whether a monad has failed?
19:06:23 <shapr> @info Monad
19:06:25 <lambdabot> -- Monad is a class
19:06:25 <lambdabot> class Monad m :: (* -> *) where {
19:06:25 <lambdabot>     (>>=) :: forall a b. m a -> (a -> m b) -> m b;
19:06:26 <lambdabot>     (>>) :: forall a b. m a -> m b -> m b {- has default method -};
19:06:29 <lambdabot>     return :: forall a. a -> m a;
19:06:30 <lambdabot>     fail :: forall a. String -> m a {- has default method -};
19:06:32 <lambdabot>     }
19:08:48 <Nioate> bleh
19:09:00 <Nioate> Parsec's GenParser isn't a MonadError instance
19:09:18 <shapr> doesn't it return an Either type?
19:09:28 <Nioate> when you parse it does
19:10:00 <Nioate> the parser monad itself isn't a MonadError
19:11:32 <Nioate> I built up what I needed from Parsec.Combinator.option
21:21:24 * stepcut can now generate wbxml files for wap push Service Indicator 
21:26:50 <Nioate> yay
21:53:34 <Spark> ahahahahahaha
22:13:59 <shapr> it's late
22:14:44 <dons> good morning shapr
22:14:46 <shapr> but I've nearly got SASL working.
22:14:51 <shapr> hiya dons
22:15:11 <dons> 7am?
22:15:19 <shapr> ya know, I very nearly hacked up a cgi patche accepter rather than actually fixing my server
22:15:23 <shapr> yes, it's just after 7am
22:15:32 <shapr> um darcs cgi patch accepter
22:15:34 <shapr> it wouldn't be hard
22:15:42 <dons> nah. not too hard
22:16:03 <shapr> and I would have to deal with learning the ins and outs of server-side smtp auth
22:16:14 <shapr> er "wouldn't"
22:16:17 <dons> got a nice undo/redo "linear, restricted undo" about to commit to yi == smile :)
22:16:19 <shapr> gah, I obviously need sleep
22:16:21 <shapr> w00!
22:16:33 <dons> and discovered there's a whole world of undo/redo theory
22:16:37 <shapr> hah
22:16:42 <shapr> I'm not surprised
22:16:42 <dons> very interesting.
22:17:05 <dons> undo-history editing, for example. concurrent-undo-history editing. etc..
22:17:52 <dons> modal undo history, both flat and 2-d
22:17:53 <shapr> sounds interesting
22:18:13 <dons> the advanced stuff is more like an rcs model
22:18:16 <shapr> I've wanted to save undo history and play it back later like a movie
22:18:20 <shapr> I thought that would be nice for teaching.
22:18:57 <shapr> even better, export it to dynamic html so you can view it in your browser
22:19:12 <dons> that'd be fun
22:19:33 <shapr> ok, I've got server side tls working, now to figure out sasl itself, and then client-side sasl, I think.
22:22:24 <shapr> oh hey, I have a yi question
22:22:37 <dons> shoot.
22:22:38 <shapr> how long does :reboot take?
22:22:49 <dons> about .2s..
22:22:52 <shapr> could it happen after every keystroke if necessary?
22:22:54 <shapr> ah, sounds like it.
22:23:09 <dons> it could happen.. what're you up to?
22:23:40 <shapr> just something Darius Bacon mentioned to me
22:23:50 <shapr> I'm so sleepy I don't remember details actually...
22:23:55 <shapr> but I'll get back to you :-)
22:24:07 <dons> ok. sounds strange and unusual
22:24:22 <shapr> do I make any other kind of suggestion? ;-)
22:24:59 <shapr> crap, sun's coming up
22:25:20 <dons> watch out for the sun!!
22:43:07 <sajiimori> hey all, can somebody help me with a boring newbie question re: classes?
22:44:21 <Nioate> only if you ask it
22:45:06 <sajiimori> heheh... well, i'm trying to implement a function 'clip' that takes low and high boundaries and restricts a value to that range
22:45:17 <sajiimori> i want it to work on Ord as well as things like vectors
22:45:49 <sajiimori> so i made a class Clip with the clip method
22:46:23 <sajiimori> and i can make Vector an instance of it, as well as specific members of Ord like Int, but can i make all members of Ord instances of Clip?
22:46:51 <Nioate> sure
22:47:02 <sajiimori> i haven't figured out the syntax for it, could you show me?
22:47:44 <Nioate> instance Ord a => Clip a where
22:48:34 <sajiimori> Hugs says "Syntax error in instance head (constructor expected)"
22:50:08 <Nioate> hm
22:50:32 <Nioate> I am not expert, but apparently, that is not in the haskell98 standard
22:50:49 <Nioate> you can get hugs to do the right thing with the -98 command line option
22:50:50 <sajiimori> ah, that would explain it
22:51:04 <sajiimori> ok, i'll try that out
22:52:15 <sajiimori> cool, it worked!  thanks a ton ^_^
22:52:52 <Nioate> you're welcome
23:31:47 * stepcut dances around
23:32:25 <stepcut> I can now generate the udh+wsp for sending a wap push service indicator
23:32:55 <stepcut> tomorrow, I need to write the API for interacting with clickatell, and *then* at long last I will be able to send a friggin' ringtone :)
