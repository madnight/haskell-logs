01:12:09 <bourbaki> moin
02:06:08 <magical1> hello all
02:06:13 <Guest1409250472> hi
02:06:38 <dblhelix> hi magical, hi Guest1409250472
02:06:44 <Guest1409250472> err
02:07:02 <magical1> I've just started learning Haskell can anyone help please?
02:07:06 <dblhelix> have to admit: I like that better
02:07:13 <dblhelix> off course, magical1
02:07:15 <Muad_Dibber> stupid mirc :P
02:07:19 <magical1> lol
02:07:31 <dblhelix> do you have any concrete problems you're struggling with?
02:07:33 * Muad_Dibber fighting with ghci :P
02:07:35 <magical1> I can't get my head around the I/O
02:08:03 <dblhelix> ouch ... yes, that's understandable
02:08:33 <dblhelix> you have to realize that I/O does not fit into the functional paradigm well
02:09:02 <dblhelix> that's the reason why I/O is not that straightforward in Haskell
02:09:11 <tuomov> you just have to think it in a different way, and it becomes clear and understandable
02:09:11 <Muad_Dibber> dblhelix, one quick question: which is the package i need to load the functions from the hugs prelude in ghci?
02:09:13 <magical1> okay, it seems to break all the rules with regards to lazy evaluation
02:09:26 <tuomov> I like the 'constructing instructions for an IO interpreter to interact with the real world' explanation
02:09:50 <dblhelix> Muad_Dibber: I'm sorry, I don't know ... haven't used Hugs for about five years now
02:10:07 <Muad_Dibber> okay
02:10:07 <tuomov> so 'main' is actually a function that constructs such an IO program, not a program itself
02:10:12 <Muad_Dibber> where do i find the chr funciton? :)
02:10:20 <dblhelix> In 
02:10:32 <dblhelix> Muad_Dibber: import Char
02:10:36 <dblhelix> @index chr
02:10:37 <lambdabot> Data.Char,GHC.Base,Char
02:10:43 <musasabi> actually I am starting to think IO in haskell is more intuitive in haskell than in C.
02:10:54 <musasabi> Muad_Dibber: :mod +Char
02:11:33 <musasabi> *actually I am starting to think IO in haskell is more intuitive than in IO C.
02:12:00 <dblhelix> magical1: laziness is not the greatest concern, although it does play a role; but the primary issue is purity
02:12:28 <tuomov> intuitiveness is highly dependant on one's past training
02:12:51 * magical1 hides his java experience .......
02:13:18 <magical1> okay
02:14:20 <dblhelix> just read a post on comp.lang.functional from someone claiming that a functional style is utterly strange when observed from an OO point of view ... and someone claiming the that an OO style is utterly strange when observed from a functional point of view
02:15:10 <magical1> I was trying to write a tic tac toe game, I was thinking that I could use a 3x3 matrix and preform transformations for pattern matching but I can't get my head around both the syntax and the IO thing
02:16:00 <dblhelix> OO-programmers always seem to want to transfer OO idoms to a functional setting when they program in Haskell ... and functional programmer, well, they just don't touch OO languages anymore, so there's no issue there :)
02:16:54 <tuomov> well, there are languages that support both OO and functional style
02:16:57 <tuomov> (python, lua)
02:17:23 <dblhelix> OCaml to a high degree
02:18:01 <dblhelix> magical1: do you realize that I/O is only a small portion of the task for implementing such a game
02:18:07 <tuomov> ocaml is still mostly considered a function language while the two above are not
02:18:18 <tuomov> but still do have higher-order/first-class functions and stuff
02:18:36 <dblhelix> tuomov: that's absolutely true of course
02:18:36 <magical1> dblhelix: yes, I do ......
02:19:03 <tuomov> and while python is an "oo language", lua is not even an oo language; it just supports that kind of programming through other lower-level constructions in a rather convenient manner
02:19:04 <magical1> dblhelix: my big problem is getting my head around the syntax
02:19:07 <musasabi> of course there is oz too...
02:19:09 <tuomov> and a little syntactical sugar
02:19:29 <dblhelix> magical1: you mean the do construct?
02:19:33 * musasabi wonders what paradigm oz is not.
02:20:06 <dblhelix> tuomov: I'm not familiar with lua
02:20:06 <musasabi> magical1: you probably want to have a pure function calculating things and print them closer to the toplevel.
02:20:14 <magical1> dblhelix: the lambda notation =(
02:20:52 <dblhelix> magical1: but that has nothing to do with I/O, i.e. monads
02:21:00 <tuomov> Lua is a wonderfully simple language. It only has a single data structure: the table (hash table that can have anything from functions to other tables and atomics as keys and values)
02:21:25 <tuomov> OO can be implemented by assigning a meta-table to a table, that instructs how to look up unknown keys
02:21:30 <dblhelix> magical1: you understand that id x = x and id = \x -> x are just two ways to define the same (identity) function?
02:21:47 <magical1> i know dblhelix but it's all part of the problem, I'm not use to writing functions recursively
02:21:57 <magical1> yes
02:22:09 <tuomov> and the syntactical sugar foo:bar(baz) -> foo.bar(bar, baz) make oo-style programming convenient too
02:22:14 <tuomov> functions are first-class values, of course
02:22:38 <dblhelix> magical1: but recursion is not related to notation
02:22:41 <tuomov> it is a dynamically typed language, though
02:22:54 <dblhelix> magical1: not to lambda notation, anyway
02:23:30 <dblhelix> and any ruby adepts here? I've never used it, but it seems to be quite popular
02:23:45 <musasabi> ruby is nice.
02:23:53 * musasabi used it quite a lot before haskell
02:23:55 <tuomov> ruby doesn't have first-class functions..
02:23:56 <magical1> maybe it's just the way they explained it at the seminar that has me so confused
02:24:04 <tromp> ruby used to be my fave language
02:24:15 <tromp> until i learned haskell...
02:24:31 <vegai> what language is your favourite now, then? =)
02:24:32 <tuomov> lua is still my favourite "scripting" language
02:24:49 <dblhelix> magical1: can you give us a small, isolated example of a function that you're having trouble to write with? maybe we can help
02:25:07 <dblhelix> magical1: you're a cs student?
02:25:17 <magical1> ICT
02:25:37 <dblhelix> magical1: which uni/school?
02:25:59 <magical1> Haskell isn't part of my course work though, it's just something that looks interesting TCD
02:26:11 * mikael is a huge ruby fan
02:26:15 <magical1> Trinity College Dublin
02:26:22 <mikael> tuomov: sure it does
02:26:55 <dblhelix> magical1: ah, okay, I thought you were taking a course, because  you mentioned a seminar
02:27:06 <tuomov> mikael: it does?
02:27:24 <tuomov> the { |x| ...Â } construct is not a lambda, it is more like a "coroutine"
02:27:49 <tuomov> to my limited knowledge
02:28:20 <magical1> nagh I wish, then I might understand it, there was a series called Haskell in 6 lectures that I attended and now I' confussed
02:28:44 <mikael> tuomov: yeah, but you can create real closures from those, with lambda
02:28:56 <mikael> e.g., lambda { |x| x * 2 }
02:29:07 <tuomov> but can you call them in a normal way?
02:29:14 <magical1> I like the idea of the Language because it seems to be more streamline and cleaner than most languages I'e come accross
02:29:20 <tuomov> another ruby programmer told me you need awful object encapsulation
02:29:34 <tuomov> so the syntax isn't exactly the same
02:29:36 <mikael> well, yeah, closures are objects, so you call the #call method
02:29:42 <dblhelix> magical1: I think all of us here agree with you on that :)
02:29:45 <magical1> I started out with Scheme almost 15 years ago ........
02:29:49 <mikael> function call syntax isn't the same as method call syntax, no :)
02:30:26 <magical1> ... but that was back in School and only lasted 2 months
02:30:59 * musasabi hasn't really used ruby much as haskell solves problems in a nicer way
02:31:11 <musasabi> and if I need just a quick script then perl is shorter.
02:31:24 <dblhelix> magical1: if you are looking for a good introduction, I can recommend Paul Hudak's book
02:31:30 <tuomov> perl is only usable as a slightly clearer sed :)
02:31:33 <mikael> shorter, sure, but more painful to write & extend :)
02:31:42 <dblhelix> magical1: The Haskell School of Expression
02:31:58 <tuomov> per -p -i -e 's/.../.../' what's about what I use perl for
02:32:05 <musasabi> yes.
02:32:06 <tuomov> and for that it is really handy
02:32:09 <magical1> it' not in the college library I already checked
02:32:14 <musasabi> it is incredibly usefull for that.
02:32:22 <musasabi> although usually s//g ;)
02:32:26 <musasabi> *+/
02:32:35 <mikael> tuomov: I very seldom use first-class functions in Ruby -- blocks are usually sufficient -- so the syntax doesn't bother me
02:32:49 <dblhelix> magical1: and for concrete programming questions you can always bump into this room
02:32:52 <mikael> though the dichotomy between blocks and first-class functions is a bit odd
02:33:25 <tuomov> the "blocks" are a bit like coroutines in lua
02:34:03 <dblhelix> magical1: however, for more general questions/problems, like e.g. having trouble with I/O, I think it's hard to get solutions here
02:34:09 <tuomov> which are also in lua handy for iterators
02:34:15 <mikael> I really appreciate that ruby has call/cc :D
02:35:02 <magical1> cool thanks dblhelix 
02:35:13 <musasabi> yes, that is something haskell is lacking.
02:35:27 <dblhelix> magical1: you're welcome
02:35:30 <tuomov> for k in coroutine.wrap(function() for k=1,10 do coroutine.yield(k) end end) do print(k) end
02:35:43 <tuomov> that prints 1..10 in a rather complex manner
02:36:31 <mikael> (1..10).each &(lambda do |k| puts k end) is the (contrived) ruby version
02:36:38 <tuomov> of course, the inner function is anonymous there. but it could be named too
02:37:06 <tuomov> (1..10).each {[k] puts k}
02:37:14 <tuomov> err. [] -> |
02:37:20 <tuomov> shouldn't that work?
02:37:55 <tuomov> but that (1..10).each is like that coroutine
02:37:57 <magical1> dblhelix: Is it possible to write a text based application, erm I mean one that doesn' have to use any fancy graphics packages?
02:38:21 <tromp> (1..10).each is like a higher order function
02:38:44 <dblhelix> magical1: of course it is
02:38:44 <tuomov> isn't there also a yield that it should call for that construct to work?
02:38:53 <magical1> cool
02:39:01 <tromp> it expects a function (called block in Ruby) which it calls at will
02:39:17 <dblhelix> magical1: actually, I only use graphics in a haskell program twice a year or so :)
02:39:50 <magical1> dblhelix: what sort of things have you used Haskell to programme?
02:40:35 <mikael> tuomov: yeah, that works too
02:40:40 <dblhelix> magical1: I'm very much focussed on compiler technology
02:41:11 <mikael> tuomov: and it's the way anyone sane would do it :)
02:41:22 <dblhelix> magical1: right now, I'm involved in the Gener ic Haskell project, which is about extending Haskell with generic-programming capabilities
02:41:30 <mikael> tuomov: the each method contains the yield
02:41:45 <magical1> cool
02:41:46 <tuomov> so it's like that lua example using coroutines
02:41:55 <tuomov> except couroutines are more implicit in ruby
02:41:59 <dblhelix> magical1: yes, it is :)
02:42:01 <mikael> yeah
02:42:02 <tromp> yield is what calls the block argument
02:42:31 <mikael> class Range; def each; for i = start to begin; yield i; end; end; end
02:42:38 <magical1> well I' going to head off and see if I can find that book, is it okay to mark myself away and stay idle here?
02:42:50 <mikael> for syntax is probably off; I haven't ever used it :-)
02:43:10 <dblhelix> magical1: that's okay (by me, anyway)
02:43:18 <magical1> cool
02:43:24 <musasabi> magical1: most people idle here for most hours.
02:43:49 <dblhelix> magical1, musasabi: yeah, sometimes we actually try to get some work done :)
02:43:58 <magical1> thanks musasabi, dblhelix, I'll BBL.
02:44:00 <magical1> lol
02:44:26 <dblhelix> magical1: okay, cu then
03:05:34 * dblhelix is away: out to lunch
03:46:15 <aj> hrm, how do you use "either" or "try" ?
04:12:53 * dblhelix is back (gone 01:07:19)
04:14:15 <dblhelix> @type either
04:14:17 <lambdabot> either :: forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
04:14:34 <dblhelix> aj: either is to Either what if-then-else is to Bool
04:16:09 <dblhelix> so, it checks the third argument: if it's a Left value, it applies the first argument function to the inner value of the Left value; if it's a Right value it applies the second argument function to the inner value of the Right value
04:16:40 <dblhelix> either f g (Left a) ==> f a
04:16:54 <dblhelix> either f g (Right b) ==> g b
04:24:23 <aj> so "either f g x" is like "then f else g if x"?
04:26:19 <tuomov> case x of { Left a -> f a; Right b -> g b; }
04:39:01 * dblhelix is away: out for a walk
04:59:57 * dblhelix is back (gone 00:20:56)
06:22:31 <boegel> hello #haskell
06:31:03 <Lemmih> Hey boegel
06:31:15 <Lemmih> Time to unicycle!
06:31:20 <boegel> check my website, I've put some transp images on it
07:22:11 <musasabi> hmm shapr is somewhere away...
07:36:19 <tarantul> Hi, ppl
07:36:28 <tarantul> I need some example
07:37:14 <tarantul> example of reading/writing binary objects in haskell
07:37:49 <tarantul> where I can find help?
07:38:21 <Lemmih> What are you trying to achieve?
07:39:57 <tarantul> Lemmih: for example - parse binary protocols
07:41:02 <tarantul> In any case I need experience in haskell IO
07:43:44 <Lemmih> tarantul: http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html
07:45:37 <CosmicRay> good morning
07:45:50 <CosmicRay> does anybody know why ghc has no problem with the following line but hugs complains:
07:45:53 <musasabi> tarantul: I have some simple example protocolls if you are interested.
07:45:53 <CosmicRay> type CPResult a = MonadError CPError m => m a
07:46:06 <CosmicRay> hugs says: Syntax error in input (unexpected `=>')
07:47:07 <TheHunter> hugs is picky
07:47:25 <CosmicRay> how do I make it happy?
07:48:31 <TheHunter> i don't think it's possible here.
07:48:38 <CosmicRay> hmm.
07:48:39 <tarantul> musasabi: can you send sources by e@mail?
07:48:43 <CosmicRay> why is it OK with ghc but not hugs?
07:49:04 <TheHunter> because ghc supports more extensions.
07:49:14 <CosmicRay> what ghc extension am I using here?
07:49:21 <musasabi> tarantul: I can post a link ;)
07:49:24 <tromp> try extra parentheses?!
07:49:25 <CosmicRay> or, alternatively, is there an alternative way I could express this?
07:49:27 <CosmicRay> heh
07:49:43 <tarantul> musasabi: in private, please
07:50:37 <TheHunter> CosmicRay, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
07:50:43 <TheHunter> 7.4.1.3. Liberalised type synonyms
07:51:35 <TheHunter> well, i guess newtype/data? would work.
07:51:56 <TheHunter> or expand the types using a preprocessor.
07:52:44 <tarantul> and ppl, what you can say about Clean ?
08:00:17 <aj> what're the last two arguments to exec()? (they're both FilePaths)
08:00:50 <wli> wow
08:01:12 <wli> I've been sitting on #haskell on EfNet for years and this thing has materialized under my nose.
08:01:33 <ibid> this thing is a few years old too :)
08:02:38 <Lemmih> aj: exec? From which module?
08:02:44 <aj> Exec
08:03:00 <aj> which is a darcs module not a haskell one, duh :)
08:03:49 <wli> I don't have a good idea of when apart from "before 2000". I rather distinctly recall checking here and finding no one.
08:04:32 <wli> looks like sometime in 2000 or 2001 which makes it not long after I remember checking
08:05:30 <CosmicRay> wli: heh
08:05:54 <CosmicRay> wli: I hadn't even been aware that efnet was still around and anything useful :-)
08:06:08 <CosmicRay> wli: I switched to this network back when it was linpeople, and now hang out here and oftc
08:06:32 <CosmicRay> wli: it's refreshing to have an irc network with no op wars, channel takeovers, etc. because there isn't a need for it :-)
08:07:15 <wli> never bothered me much
08:07:40 <wli> I'm still vaguely wondering how this channel could have escaped my notice for 3.5+ years
08:07:54 <tuomov> the significant software-related channels seem to be on freenode, while on ircnet I'm on more geographically oriented channels (friends and stuff)
08:07:58 <wli> especially since I've made numerous passing mentions of the EfNet channel on haskell-cafe etc.
08:08:22 <CosmicRay> huh
08:08:24 <CosmicRay> I've missed 'em
08:08:41 <wli> was this thing announced ever/anywhere?
08:08:57 <CosmicRay> shapr may know
08:09:02 <CosmicRay> I'm pretty sure it's on the wiki at least
08:09:07 <CosmicRay> and I think I've seen it mentioned in cafe
08:09:10 <Igloo> CosmicRay: To do the above in H98 you'd have to make m an argument of CPResult and do the MonadError CPError m => at each point of use, I think
08:09:11 <wli> I remember shapr
08:09:14 <CosmicRay> but irc channels don't always tend to be announced
08:09:22 <tuomov> on ircnet losing ops because of splits and server deaths is a constant annoyance
08:09:23 <CosmicRay> Igloo: rats.  I was afraid of that.
08:09:40 <tuomov> at least once a month channels becomes opless and takes another to get the ops back
08:09:50 <Igloo> wli: It's been mentioned in HC&R I think
08:10:44 <wli> I'll have to bug shapr
08:11:43 <wli> well, if a #mercury has materialized somewhere without my knowing it it's not on this network
08:11:55 <wli> hmm
08:11:58 <wli> actually, it has
08:11:59 * Igloo thought you'd been in here in the last year, but maybe I'm confused
08:12:02 <wli> but it's 8 weeks old
08:12:34 <wli> I was probably complaining about being surprised about this existing while EfNet got ignored same as today and merely forgot.
08:16:18 <wli> What's HC&R?
08:16:57 <Lemmih> From topic: The Nov 2004 HC&A Report is released! - http://haskell.org/communities/
08:18:14 <wli> anyway, "discovering" this will doubtless be a refreshing change from the usual EfNet state where monochrom and I are literally the only ones fielding all the questions.
08:18:29 <arauko> wli, how long have you been programming in haskell?
08:18:55 <arauko> wli, yes, do your searchs on freenode before going to another netwrok :-)
08:19:59 <wli> since before I graduated from college
08:20:13 <wli> started the EfNet IRC channel about the same time
08:20:30 <wli> sometime during or before 1999
08:20:31 <arauko> Sounds like it was long long ago.
08:20:37 <arauko> Ah ok.
08:20:52 <wli> almost definitely before 1999 but no firm idea
08:20:54 <arauko> hah, and you din't know about this channel until now?!
08:21:15 <wli> I've been sitting around answering questions on EfNet's #haskell that entire time.
08:21:33 * Igloo was in there a bit in 1999/2000, I think, but it tended to be dead
08:21:37 * arauko thinks wli must be really surprised (and probably excited) about his discovery
08:22:08 <wli> Igloo: it mostly is except during the influx of frosh
08:22:17 <wli> Igloo: largely from UNSW
08:22:35 <wli> arauko: no, mostly annoyed
08:22:47 <arauko> hahah, why?
08:23:08 <CosmicRay> wli: haven't I seen you in #debian-devel on this network before?
08:23:12 <CosmicRay> wli: heh
08:23:25 <wli> arauko: Because I sat in obscurity for years.
08:23:31 <wli> CosmicRay: yes
08:23:44 <CosmicRay> you should do a /list periodically :-)
08:23:48 <arauko> wli, Be happy, you found the _light_!
08:23:50 <Godeke> exit
08:24:45 <wli> Well, back to Haskell, I banged out a permutation calculator for bonehead abstract algebra problems recently. Maybe I should make a code drop or something.
08:29:29 <wli> Things sure got quiet.
08:29:33 <wli> Oh well.
08:32:56 <CosmicRay> it happens.
09:14:02 <SyntaxNinja> aj: are you a haskell expert yet?
09:17:46 <aj> i can write over ten lines of code in a day!
09:18:07 <aj> not only that, i can manage some vague, uneasy confidence that they might perhaps sometimes do what they're meant to do!
09:19:05 * aj :: Maybe (HaskellExpert)
09:19:44 <SyntaxNinja> hehe
09:19:55 <SyntaxNinja> 10 lines of haskell code, though, is like, at least 1000 lines of C++ ;)
09:20:28 <kristnjov> and then you realised that higher-order functions are the reason to live and wrote ten more lines of code, just a thousand times more efficient.
09:20:28 <kristnjov> yep
09:20:29 <kristnjov> that's why haskell is TEH WIN
09:20:56 <aj> eh, i don't write C++ code, and i generally don't write 1000s of lines of code either...
09:20:57 <Helic> yay python 2.4 is out
09:20:58 <ibid> aj: that allows aj = Nothing :)
09:21:13 <aj> ibid: s/allows/implied/ pretty much :)
09:21:23 <SyntaxNinja> aj: :)
09:21:32 <ibid> aj: it also allows Just a, where a :: HaskellExpert :)
09:21:41 <ibid> aj: hence no implication :)
09:22:08 <ibid> aj == Just simonPeytonJones? :)
09:22:14 <aj> ibid: aj, Just a HaskellExpert? Pretty implausible :)
09:23:15 <aj> the real question is, will i be able to implement versioned timestamps for darcs by the new year
09:23:29 <ibid> what happens if you are not?
09:23:48 <aj> i don't get to put my blog in darcs 'til after the new year
09:23:53 <ibid> heh
09:23:59 <SyntaxNinja> aj: that would rule.
09:24:14 <Igloo> versioned timestamps?
09:24:39 <aj> so darcs get --partial etc reliably sets the timestamp of the files in the repo
09:24:57 <aj> tres important for blosxom blogs
09:25:20 <SyntaxNinja> aj: fwiw: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System.Posix.Files.html#12
09:25:31 <Igloo> Ah, so is the issue that files last changed before the checkpoint get their date set to the checkpoint date?
09:25:33 <SyntaxNinja> not sure if he's using the posix library though
09:25:57 <aj> Igloo: nah, if you get --partial, your timestamps are all set to the current time
09:26:20 <Igloo> Oh. But without --partial they are set to the last changed time?
09:26:46 <aj> Igloo: they're set to the same time as in the source repo if you're doing it locally
09:26:57 <aj> Igloo: otherwise i dunno, and i don't trust unversioned data anyway
09:27:47 <aj> pulling from a darcs-repo/darcshive repository certainly won't get you the right timestamps; darcs apply won't either i'm pretty sure
09:28:18 <aj> err, they're the same issue obviously, so either both work or neither :) silly aj :)
09:29:14 <aj> speaking of silly aj, night all
09:29:32 <Igloo> g'night
09:29:34 <SyntaxNinja> 'night
09:30:12 <ibid> the night is young :)
09:30:18 <ibid> night, tho
09:35:41 <shapr> wli: y0
09:35:45 <Lemmih> Hey shapr (-:
09:35:49 <shapr> greeting Lemmih 
09:35:58 <Lemmih> How's the mail server?
09:36:51 <shapr> SASL is $QUESTIONABLE_ANCESTRY $DENIGRATING_COMMENT difficult.
09:38:00 <monochrom> haha
09:38:36 <shapr> I'm beginning to suspect that the sasl support in the postfix package was built improperly, is broken, or something.
09:40:08 <shapr> monochrom: I quoted your alternate history in my blog, it's great :-)
09:41:14 <shapr> wli: written any Haskell code lately?
09:41:41 <shapr> wli: do you still have those snippets of lazy series that had geometric and greater complexity?
09:42:33 <shapr> Man I love unicycling. It's so much fun =)
09:42:51 * SyntaxNinja pats shapr on the back, hoping this doesn't send him head-over-heals
09:43:01 * shapr grins
09:43:16 <shapr> y0 SyntaxNinja, how's code? Do you have your laptop back?
09:43:35 <wli> shapr: yes I've written Haskell code lately
09:43:51 <wli> shapr: I have no idea what you're talking about wrt. lazy series with geometric and greater complexity
09:44:29 <shapr> About three years ago you wrote some really cool snippets that I still wish I had a copy of.
09:45:25 <wli> like ramanujan = [r|r@(_,rs)<-[(n,concat [[(i,j)|j<-[1..i],i^3+j^3==n]|i<-[1..ceiling((fromIntegral n)**(1/3))]])| n<-[1..], let n' = n `mod` 7 in n' /= 3 && n' /= 4],length rs > 1, any (\((i,j),(h,k)) -> foldr1 gcd [i,j,h,k] == 1) (concat $ take (length rs) (map (takeWhile (uncurry (<)) . zip rs) $ tails rs))] ?
09:45:47 <SyntaxNinja> shapr: not yet
09:45:52 <SyntaxNinja> code is OK
09:45:57 * shapr blinks and tries to read that
09:47:16 <wli> shapr: well, my latest and greatest is http://holomorphy.com/~wli/Permutation.hs
09:47:28 <wli> shapr: it's a permutation calculator for bonehead abstract algebra stuff
09:47:48 <shapr> nifty
09:48:51 <wli> shapr: the long snippet pasted is Ramanujan numbers
10:01:46 <musasabi> shapr: ping
10:01:49 <shapr> pong!
10:02:04 <musasabi> About FLM - how versitale is it?
10:02:24 <shapr> huh?
10:02:35 <shapr> in what sense? document formats? OS? or what?
10:02:39 <musasabi> I am thinking of wanting to distribute metainformation about many files not just papers.
10:02:49 <shapr> hm
10:02:53 <shapr> got some user stories?
10:03:05 <musasabi> user stories?
10:03:21 <shapr> can you give me specific instances of what you're saying?
10:04:24 <musasabi> shapr: e.g. we have a group of friends all having their photo-collections and we wish to share things like comments about the photos but don't want to setup galleries each with it's own user interface.
10:04:35 <shapr> oh
10:04:49 <shapr> well, that could work.
10:05:00 <wli> I wonder what happened to lava
10:05:10 <shapr> Satnam Singh moved to microsoft
10:05:25 <wli> killed the whole project, then?
10:05:28 <shapr> Xilinx took down the version he had online from them, though the tutorials are still up.
10:05:43 <wli> archived anywhere?
10:06:02 <musasabi> mainly that is Database = [{filereference,key,value,signature}] 
10:06:08 <shapr> Singh told me a few days back that there's a whole new rewrite of Lava coming up. I think he's talking Peter Gammie's Lustre successor.
10:06:44 <shapr> I wanted to compile Haskell to Xilinx FPGAs. And I wanted a 100% open source toolchain.
10:07:23 <wli> I'm not sure I really care as long as gates come out of something less cumbersome than VHDL/Verilog
10:07:23 <shapr> musasabi: I think you're talking about a distributed server-less wiki.
10:07:42 <wli> but I guess if I'm stuck waiting, I'm stuck waiting
10:08:03 <shapr> Singh said that the new version should work with Xilinx tools.
10:08:08 <shapr> or something to that effect
10:08:13 <shapr> I can check my email if you want more details.
10:08:34 <wli> Don't bother, I can hold out for the announcement.
10:08:47 <shapr> musasabi: in that case, it is a shared gallery with a set user interface, just that interface is a darcs-wiki.
10:09:45 <musasabi> yes, more or less.
10:10:27 <shapr> I think that's a worthwhile idea, that was my original idea with the wikiwiki darcs repo on ScannedInAvian.org
10:10:55 <musasabi> actually I don't need a way to transfer the real content just answer the questions: what metainformation is there about file X, what files match metainformation pattern X ?
10:11:43 <shapr> In Flippi, I made a WikiPage a directory, so content is PageName/text and attachements are PageName/filename
10:11:55 <shapr> That's how MoinMoin works, and it seemed like the easiest thing to do at the time.
10:12:11 <kristnjov> moinmoin = morninmornin!
10:12:15 <shapr> yup
10:12:43 <musasabi> I had PageName/Version with PageName/current a link to the correct one.
10:12:46 <shapr> That's the dropdead simple and totally cross-platform way to associate metadata with a file, just turn the file into a directory.
10:13:06 <shapr> I don't know a good way to go the other direct, matching metainfo to file.
10:13:19 <musasabi> shapr: but I don't have canonical filenames
10:13:26 <shapr> I would very much like that though. I am still irritated that BBDB can show user info per email, but can't show email per user info.
10:14:19 <shapr> From the vague bits I've read about the latest reiser filesystem, it's much more a database than a real 'filesystem' so that might make your life easier.
10:14:36 <shapr> Won't be very portable though.
10:14:38 <musasabi> shapr: e.g. I have ~20000 pics so naming them is not very nice..
10:14:49 * shapr thinks about that
10:15:26 <musasabi> and when catogorizing them I want to make them searchable by metainformation
10:15:30 <shapr> Well, SubPages might help some.
10:15:54 <shapr> that is' PageName/SubPage PageName/OtherSubPage as works in MoinMoin and Flippi
10:16:41 <shapr> musasabi: what sort of metainfo?
10:18:36 <shapr> you could use the wiki backlink categorization system
10:18:49 <shapr> that's pretty good for even up to twenty or so categories
10:19:23 <shapr> you could use symlinks to a small set of metainfo properties, though I don't know if there's an easy way to trace back along a symlink. 
10:19:39 <musasabi> hmm wiki backlinks help up to point but I really need a command line interface to the thing.
10:20:36 <musasabi> currently I am maning some 500 files in a metainfo symlink hell and that does not appear very nice.
10:20:44 <shapr> yah, I understand that.
10:21:44 <musasabi> but e.g. if I get a set of 200 pics from an event I probably want to automatically tag them all - so I need some other interface than a wiki.
10:21:53 <shapr> another manual but easy to search approach would be files as directories, and put all the the metainfo into a given filename like DirName/metainfo 
10:22:12 <CosmicRay> re shapr
10:22:27 <CosmicRay> shapr: Igloo helped me solve my monad combination problem, I think
10:22:31 <shapr> y0 CosmicRay, have you discovered the secrets of "More than Meets the Eye" ?
10:22:41 <shapr> ah, good to hear.
10:22:41 <CosmicRay> shapr: I may pick your brain on one final topic in the next day or so
10:22:54 <shapr> oh, do I get a preview?
10:22:56 <CosmicRay> hmm, I don't think I've heard of "more than meets the eye"
10:23:09 <CosmicRay> shapr: OK :-)
10:23:10 <shapr> It's the motto of the Transformers toys :-)
10:23:30 <CosmicRay> shapr: let's say I have a function foo :: FilePath -> IO (Either ErrorType GoodType)
10:23:42 <CosmicRay> and I'm using it in a combined IO/Error ErrorT monad
10:23:46 <shapr> musasabi: this is really starting to sound like a database. 
10:23:51 <CosmicRay> I say val <- liftIO $ foo bar
10:23:58 * wli suspects he may be able to hit ppl up for monad-fu
10:24:03 <CosmicRay> now val holds an Either, not a GoodType
10:24:14 <CosmicRay> I'll still have to do realval <- val to get the GoodType
10:24:21 <CosmicRay> is there some magic shortcut I'm missing?
10:24:32 <musasabi> shapr: yes it *is* a database.
10:25:04 <musasabi> but somehow one wants to distribute those bits of metadata with different people,
10:25:22 <musasabi> (I have got some code to do things with a simple metadata format)
10:25:38 <shapr> CosmicRay: I think you could use ap, but you still have to choose what you want your 'top level' <- to mean.
10:25:39 <musasabi> could FLM help with that part?
10:26:01 <CosmicRay> shapr: I want it to get the GoodType out of the Either
10:26:15 <CosmicRay> shapr: how might I use ap in this instance?  (it's still somewhat confusing to me)
10:26:56 <monochrom> My current hobby functional programming projects:  I am writing a toy for the "mu-calculus" in ocaml, and gradually wondering if I should use haskell instead.  I am also writing some slides to explain monads to people who already like list comprehensions.
10:27:21 <Philippa_> good call, that catches most folks with a bit of set theory...
10:27:35 <shapr> musasabi: I think it might, but I'd have to play with some concrete data to figure out if there's a good generalization between my original idea of FLM and what you're talking about now.
10:27:58 <shapr> I think there probably is a good generalization where FLM will be a special case of what you want.
10:28:05 <shapr> But I don't know what it is yet.
10:28:48 <waltz> Am I correct in assuming a 'functional' programming language is different from an 'object-oriented' programming language?
10:28:48 <wagle> werent comprehensions removed for everything except the list monad?
10:29:27 <wagle> waltz: yes.  functional uses functions, and oo uses objects..  *<8-o
10:29:27 <shapr> waltz: not necessarily, but usually. Mostly because OOP wants identity equality checking, and pure FP ignores identity and focusses on value.
10:29:34 <monochrom> Yes wagle.
10:30:15 <waltz> Very interesting.
10:30:16 <wli> I could probably use a bit of monadology
10:30:17 <shapr> CosmicRay: I think you can use ap to 'unwrap' a monadic call.
10:30:18 <wagle> waltz: what sort of thing do you want to know?
10:30:43 <CosmicRay> shapr: yeah, but my confusion lies with how it interacts with liftIO and how to get something out of the IO
10:30:44 <waltz> wagle, nothing at the moment.
10:30:48 <shapr> wli: The nomaware tutorial is the best thing going - http://www.nomaware.com/monads/html/
10:30:58 <CosmicRay> liftIO is still not entirely transparent to me
10:31:06 <shapr> @type liftIO
10:31:07 <lambdabot> bzzt
10:31:15 <shapr> @type Control.Monad.liftIO
10:31:16 <lambdabot> bzzt
10:31:19 * shapr sighs
10:31:21 <shapr> @index liftIO
10:31:22 <lambdabot> Control.Monad.Cont,Control.Monad.Error,Control.Monad.List,Control.Monad
10:31:22 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Trans,Control
10:31:22 <lambdabot> Monad.Writer,GHC.IOBase
10:31:22 <Philippa_> CosmicRay: do you understand the more general lift funcs?
10:31:23 <wagle> i've seen people claim that the modularization of an fp program is orthogonal to the modularization of a oo program...
10:31:27 <CosmicRay> @type Control.Monad.Error.liftIO
10:31:28 <lambdabot> Control.Monad.Error.liftIO :: forall m a.
10:31:28 <lambdabot> 			      (Control.Monad.Trans.MonadIO m) =>
10:31:28 <lambdabot> 			      IO a -> m a
10:31:49 <Philippa_> wagle: sort of true in a twisted kinda way, yeah
10:32:01 <CosmicRay> so I *think* what I'm getting out of liftIO is essentially m (m a)
10:32:09 <CosmicRay> where m is the ErrorMonad
10:32:14 <Philippa_> though sadly there's no good way to do both modularisations at once unless you have an editor/IDE with good metadata
10:32:28 <Philippa_> CosmicRay: liftIO is like return, only instead of a pure function it takes an IO operation
10:32:38 <CosmicRay> and I need to unwrap it, but ap doesn't seem quite right since it just puts something back in m
10:32:45 <wagle> Philippa_: i think they are doing that
10:33:03 <Philippa_> well yeah. Hell, I was at this talk Ted Nelson did...
10:33:31 <CosmicRay> Ah!
10:33:39 <CosmicRay> @type Control.Monad.join
10:33:40 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
10:33:43 <CosmicRay> would that do it?
10:33:52 <shapr> if it's the same monad
10:34:06 <CosmicRay> Hmm.  I think it is.
10:34:11 <wagle> wli: yeah, i recommend the nomaware tutorial
10:34:14 * CosmicRay will try
10:34:25 <musasabi> shapr: ok, I'll wait and see...
10:34:32 <CosmicRay> shapr: I hate it when people make me explain something and then realize the answer while I'm explaining the problem :-)
10:34:54 <shapr> CosmicRay: This is known as rubber-ducking, cardboard analyst, etc
10:34:58 <CosmicRay> heh
10:35:02 <monochrom> 90% of a problem is in formulating it.
10:35:11 <CosmicRay> how about "drunken shapr"?
10:35:12 <CosmicRay> :-)
10:35:20 <shapr> That's one of my proofs of the Sapir-Whorf hypothesis btw.
10:35:27 <Philippa_> Sapir-Whorf?
10:35:28 <CosmicRay> I should just explain my problems to Eliza
10:35:44 <monochrom> Eliza is intelligent.
10:35:47 <Philippa_> CosmicRay: shapr and I bounce ideas off each other pretty often, seems we often complement each other's thought patterns
10:35:51 <shapr> Philippa_: roughly "how you speak limits how you can think"
10:35:58 <Philippa_> ah, that one
10:35:58 <waltz> Would one be recommended Haskell for non-mathematics oriented programming and software application design?
10:36:10 <tuomov> sure
10:36:11 <shapr> waltz: I surely think so.
10:36:11 <Philippa_> have to admit, speaking maths or a programming language does help things
10:36:17 <waltz> :)
10:36:20 <Marvin--> lo and behold, I'm back online :)
10:36:25 <shapr> Did you see my last post to the Haskell mailing list?
10:36:28 <shapr> Marvin-- !!
10:36:30 * shapr hugs Marvin-- 
10:36:32 <shapr> ltns!
10:36:41 <Marvin--> finally got that darned adsl thingy
10:36:43 <Philippa_> waltz: give or take issues talking to foreign libraries (it's not too bad, but not as easy as C), Haskell's great for it
10:36:44 <shapr> yay!
10:37:07 <Philippa_> I've got a wiki clone and an IRC client in the works, the former having two releases so far. I suspect implementing an FPL counts as maths-oriented.
10:37:25 <CosmicRay> ah ha.  join did it.
10:37:29 <shapr> waltz: http://www.haskell.org/pipermail/haskell-cafe/2004-November/007750.html
10:37:33 <Philippa_> Haskell kicks the most arse IMO when you start playing with impure semantics in it
10:37:43 <shapr> Yah, I find that amazing.
10:37:54 <wagle> wha?
10:38:04 <Philippa_> wagle: what do you think monads're about? Or arrows?
10:38:29 <wagle> sounded initially like you were advocating unsafeIO
10:38:33 <Philippa_> heh
10:38:42 <Philippa_> unsafeIO is... unsafe, funnily enough :-)
10:38:57 <monochrom> the author of darcs and the author of yi would, I bet, recommend haskell for non-mathematical applications.  darcs is a version control system; yi is an extensible editor.  "Real" applications, nothing mathematical (on the surface).
10:38:59 <Marvin--> except the few cases were it's safe in an unsafe kind of way
10:39:00 <Philippa_> though there're times FFI helps a lot, which is the same kind of cheat as it were
10:39:20 <Philippa_> Marvin--: unsafe != guaranteed to fuck you over
10:39:28 <Marvin--> I know :)
10:39:38 <Philippa_> or to put it another way, unsafe != suicide, just risky
10:39:44 <wagle> i dunno..  i want to know when i have correctly forced a state monad to modify in place
10:40:33 <Philippa_> right. If you can fit it in a monad interface, there's no reason not to implement it via FFI. The whole point there is that Haskell isn't a closed language, you can use things in it you can't express in it
10:40:40 <Philippa_> otherwise there goes your IO
10:41:03 <wli> most of the tutorials are pretty useless as far as "building things with monads" goes
10:41:10 <edi> hello shiny people
10:41:11 <Philippa_> yeah, I'm inclined to agree
10:41:20 * Marvin-- has noticed one thing that's nice with "working in industry" compared to being a student
10:41:25 <shapr> Greetings oh shiny edi.
10:41:29 <Marvin--> I can afford buying books
10:41:32 <Marvin--> lots and lots of books
10:41:34 <wli> intuition for how to properly use them is much more subtle
10:41:35 <shapr> Marvin--: yay! what have you bought?
10:41:40 <Philippa_> tbh, the way I look at it is that if things'd be easier if I could write my own minilang then it may be time to look at a monad
10:42:01 <wagle> wli: there are some example programs in the libraries of, say, hugs
10:42:06 <Marvin--> shapr: not all that much yet, but I bought new bookshelves this weekend and now I gotta start filling them ;)
10:42:11 <shapr> Marvin--: btw, heart probs all fixed?
10:42:13 <Philippa_> basically, if you want a different set of semantics then find a way to implement it (which monads often are)
10:42:14 <wagle> like a prolog interpreter
10:42:17 <monochrom> working in industry ==> enough money to buy books /\ no time to read books ?
10:42:22 <Marvin--> shapr: still on medication
10:42:26 <Marvin--> monochrom: there is that
10:42:27 <shapr> monochrom: oh, truth! 
10:42:33 <Philippa_> monochrom: student life can be worse for time consumption though
10:42:45 <Philippa_> I mean, not always, but you're less likely to have to pull an all-nighter on something in industry
10:43:08 <shapr> It's like being self-employed, you have either way too much free time and not enough money, or enough money and negative free time.
10:43:37 <monochrom> I have a great idea.  Those of you working in industry should sacrifice 90% of your income (before tax!) to those of us holy students so we can buy and read expensive books!
10:43:41 <shapr> Philippa_: you haven't worked in the USA =)
10:43:51 <Philippa_> shapr: I have no intention of doing so any time soon either
10:44:07 <shapr> I did quite a few all-nighters at my first job. Unsurprisingly, I left after a year.
10:44:10 <Philippa_> here, if a mangler thinks crunch mode is good I can do them for disability discrimination on the way out
10:44:42 <monochrom> Yeah I had American programming life in mind too.  Didn't know about Europe.
10:44:53 <Philippa_> (for medical reasons I really can't cope with crunching as well as most, not that most cope well - can you say constructive dismissal?)
10:45:06 <shapr> I actually don't mind all-nighters if it's writing cool code, solving a really neat problem, etc. But all-nighters where you have to do something stupid and irritating and worthless just sucks too much.
10:45:11 <monochrom> (Horror stories from Microsoft and EA employees.)
10:45:27 <Philippa_> I got the impression MS tend not to force it so much, though the culture there may well do
10:45:30 <Marvin--> feh, we're merging with an American company, that sure is going to be interesting from a workday perspective
10:45:52 <shapr> I knew a bunch of microserfs when I lived in Seattle, it was a very weird culture.
10:46:00 <monochrom> Right, in Microsoft it's peer pressure and sheer competitiveness.
10:46:05 <Marvin--> they seem to be quite insane, sleeping just three hours a night and stuff like that
10:46:13 <Philippa_> monochrom: I can live with that kind of thing
10:46:15 <monochrom> In EA it's a boss thing.
10:46:45 <Marvin--> Microserfs was a so-so book, I liked the first part, but it kinda lost focus towards the end
10:46:50 <Philippa_> yeah. EA I wouldn't survive, MS I would (I'm comparatively immune to suicidal culture having had to debunk enough of it to remain vaguely comfortable in my life)
10:47:06 <shapr> The microserfs I knew were really smart, and at the same time, completely clueless. They had very little connection with the rest of theworld. It was strange to talk to them.
10:47:19 * wagle gets started on the list: http://www.guardian.co.uk/uk_news/story/0,3604,1361676,00.html
10:47:38 <monochrom> And they talk about us "the ivory tower"!
10:47:51 <shapr> These ms workers could crank out code and solve problems, but they didn't have much initiative. It was odd.
10:48:22 <tuomov> to have initiative you need to have time to think
10:48:41 <monochrom> They don't have time to read books. That's my theory. :)
10:48:44 <wagle> they invented the same thing we did about the time we first published it, and using exactly the same variant of the algorithm
10:50:06 <shapr> wagle: who, microsoft?
10:50:08 <Philippa_> shapr: y'know, I think you've hit on something - largely why so many silicon valley types seem to have completely fucked up ideas about sociology and economics
10:50:18 <wagle> shapr: yeah
10:50:44 <wli> I'm in industry. Neither the money nor time are there.
10:50:53 <wagle> oh..  it didnt actually show up in visual C++.net until 4 years later
10:51:26 <tuomov> I was in industry and while there wasn't much to do at work, there wasn't much quality free time and the money wasn't that good either
10:51:43 <shapr> Philippa_: My problem with the microsofties was they couldn't abstract. They solved problems that were in front of them, but they didn't try to put all the problem they'd ever solved together to find general solutions.
10:51:47 <Philippa_> industry + commuting sucks
10:52:00 <tuomov> commuting sucks.
10:52:04 <Philippa_> shapr: that'd lead to the sociology and economics stuff
10:52:13 <Philippa_> well yeah, but you generally don't need to commute for other reasons
10:52:25 <Philippa_> commuting + 9-5 = fuck all useful time left the rest of that day
10:52:27 <wagle> need non-abelian industry then
10:52:33 <tuomov> I commuted 7 years 20km to school
10:52:40 <tuomov> before uni
10:52:41 <Philippa_> bah, that's not real commuting
10:52:43 <tuomov> I've had enough of that
10:52:51 <shapr> wagle: as in, cainian versus abelian?
10:52:54 <Philippa_> mate of mine was biking back and forth from brum to snotts each day last year
10:52:58 <Philippa_> that's a 2 hour ride each way
10:53:09 <shapr> industries that doen't kill their siblings? =)
10:53:17 <Philippa_> cain was the killer
10:53:26 <Philippa_> and I say we kill moron manglers ;-)
10:53:30 <shapr> bad, screw up a cheesy joke with facts :-P
10:53:36 <shapr> er "bah"
10:53:42 <monochrom> me = commuting + 5-9 :D
10:53:43 <shapr> sheesh, I can't type today.
10:53:59 * Marvin-- commutes 5 minutes by foot to work every morning...
10:54:19 * shapr commutes thirty centimeters to his couch every afternoon.
10:54:33 * tuomov just rots at home
10:54:41 * shapr grins
10:55:02 * wli works remote == 3AM-1AM workday
10:55:02 * Cale is noncommutative.
10:55:03 <Philippa_> campus is a mile from here, that's no biggie for me
10:55:43 * Igloo has a 30 min fast walk
10:55:56 <Cale> yeah, my walk is about 30 mins as well
10:56:18 <tuomov> distributiveness and associativeness are important too
10:56:22 <Cale> yeah
10:56:28 <Cale> I was about to suggest that :)
10:57:03 <shapr> wli: hey, can I ask you a kernel question about asymmetric multiprocessing? Or is that work and I should only ask you when you're on the clock?
10:57:45 <shapr> I'm not very associative, no one around here wants to talk about type theory.
10:58:11 <monochrom> I have two routes home->school.  southbound bus; westbound subway.  westbound bus; southbound subway.  They take about the same time.  It is a commuting diagram!
10:58:45 <shapr> oooh, a commuting square!
10:58:55 <wagle> are you the ame person each way?
10:58:58 <monochrom> Did you also know that distributivity and associativity are special cases of commuting diagrams?
10:59:01 <wagle> are you the same person each way?
10:59:19 <monochrom> up to isomorphism yes I'm the same person either way.
10:59:36 <wagle> how so with associativity?
10:59:58 <wagle> i think i've seen the distributivity 
10:59:59 <monochrom> Oops, my bad.  Just distributivity.
11:00:11 <shapr> I'm trying to get to the other end of a mesomorphism.
11:01:12 <wagle> darn..  i've been trying to wrap my brain around just wtf associativity "is"..  i never thought it a terribly important constraint until i took category theory
11:01:48 <wagle> i understand it syntactically, just fine..  i just wanna know what it _means_
11:01:58 <monochrom> Don't work too hard.
11:02:25 <wagle> it doesnt help that noone else understands what the big deal is
11:02:55 <monochrom> My bet is it is not too profound.  It is just there to make life convenient.
11:03:36 <wli> category theory has defied my efforts (though they've never been particularly intense) for years
11:03:40 <wagle> a lot of the proofs in category theory hinge on associativity, but i cant visualize it, and i'm primarily a visual thinking
11:03:48 <wagle> s/thinking/thinker/
11:04:03 <wli> I suspect I'll never get enough free time to ever put sufficient effort toward it
11:04:08 <wagle> category is bass ackwards
11:04:36 <wagle> category ... theory ... is bass ackwards
11:04:48 <wagle> but in a very interesting way
11:04:51 * shapr grins
11:05:34 <wagle> pierces book is the shortest intro..  lawvere is the most elementary
11:05:35 <tuomov> category theory is making simple things incomprehensible.. but I like it
11:06:18 <wli> Lost cause. I didn't pick it up while I had the free time to focus on anything. I'll never get the free time to focus on anything again.
11:06:21 <monochrom> Look at this sequence: A -> B -> C -> D -> E.  See I don't bother to add parentheses "to clarify which arrows bind tighter than the others".  That is because it doesn't matter.  That is associativity: the license to flatten out a sequence.  That's all it is.
11:06:58 <wagle> but type arrows arent associativethats not associ
11:07:04 <wagle> but type arrows arent associative
11:07:33 <monochrom> Right.  Mine are not type arrows.  Mine are morphism arrows.  My sequence is maybe e.g. part of a commutating diagram.
11:07:44 <shapr> wli: I can't focus anyway, with or without free time, so I take the approach that I'm "eroding away the frontiers of my knowledge."
11:08:06 <wagle> i did say i understood associativity just fine _syntactically_
11:08:32 <monochrom> But the sequence A -> B -> C -> D -> E is _visual_!  It is part of a commuting _diagram_!
11:08:49 <wagle> i probably did not clearly state what i mean by "means", though..  8/
11:09:02 <wagle> thats syntactic
11:09:03 <monochrom> So I say, associativity is what enables you to effectively carry out visual reasoning over diagrams.
11:09:34 <wagle> ok
11:10:09 <wagle> thats a pixel of light for a picture of a lightbulb
11:11:18 <monochrom> I'll think about it more.  I don't know what visual reasoning you have in mind; my hunch is that it is enabled by presuming associativity.
11:11:51 <wagle> i hated induction for being syntactic ("you can prove things without understanding them!") until i saw its mapping to and from ordinals and cardinals
11:12:36 <Philippa_> tbh, I /like/ syntactic proofs
11:12:43 <Philippa_> they tell me that it's valid to extend my intuitions
11:14:06 <wagle> ("tgh"?)
11:14:11 <wagle> ("tbh"?)
11:14:15 <shapr> to be honest
11:14:53 * shapr plays with the Emacs keymap for Yi
11:14:53 <wagle> thx
11:15:10 <shapr> Yay Yi! w00!
11:15:22 <Philippa_> that's the sort of thing I like about category theory and the likes - they allow me to identify situations I already have good intuition for
11:15:30 <shapr> tuomov: what's metaM do?
11:15:33 <Philippa_> granted, I'm one of these evil types that don't show all their working...
11:16:15 <shapr> y0 stepcut, wazzup?
11:16:25 <wagle> no longer eliminated?
11:16:37 <stepcut> "I've been sitting around #haskell on EfNet for something like 5 years and wondering why no one ever came by."
11:16:45 * shapr points to wli 
11:16:45 <Philippa_> heh
11:16:47 <Philippa_> yeah, I saw that
11:17:04 * stepcut waves hi
11:17:37 <stepcut> yo shapr! Not much -- more C++ programming today (but haskell tonight!)
11:17:50 <shapr> Once again, that's a good way to keep perspective.
11:18:01 <Marvin--> that gave me a laugh too :)
11:18:06 <Muad_Dibber> morning
11:19:47 <shapr> hoi Muad_Dibber, hoe gaat het?
11:19:53 <wli> Most of the variety I get is assembly for different architectures.
11:20:10 <Muad_Dibber> goed, met u sh?
11:20:19 <shapr> bout the same
11:20:24 <Muad_Dibber> :)
11:20:51 <stepcut> shapr: No, its just a good way to keep my landlord happy and belly full :)
11:22:36 <tuomov> shapr: eh?
11:23:14 <tuomov> I don't  know anything about any yi emacs keymap if that's what you're looking info on
11:23:37 <shapr> tuomov: I dunno, you were mentioned in the most recent patch in connection with metaM, just curious what that was about.
11:24:04 <tuomov> hmm..
11:25:24 <tuomov> ah, it seems to allow switching the keymap
11:25:49 <tuomov> or, rather, what the yi core considers a keymap
11:26:11 <tuomov> so as to allow branching user input processing dependent on editor state and not just user actions
11:26:28 <tuomov> before that Yi couldn't handle e.g. a replace query
11:26:54 <tuomov> that would only be displayed if there was anything left to replace
11:45:30 <tuomov> ../Yi.hs:32: parse error (possibly incorrect indentation)
11:45:33 <tuomov> hmm..
11:45:47 <shapr> works for me
11:46:04 * shapr plays with the Nano keymap
11:48:25 <tuomov> ah. Wrong Yi.hs
11:49:25 <tuomov> ok, metaM works, although I think it is uglier than my proposed solution
11:50:40 <shapr> wli: you might like Yi - http://www.cse.unsw.edu.au/~dons/yi.html 
12:29:41 <wli> what's Yi?
12:30:06 <Riastradh> Go to the page & find out.
12:30:10 <shapr> It's an editor written in Haskell. I claim it's more dynamic than emacs.
12:31:06 <blackdog> 4~roo
12:31:19 <edi> what a claim! ;)
12:31:26 <shapr> hej bringert 
12:31:33 <blackdog> and i have the frenzied notes to back it up, too. :)
12:33:15 <wli> chasing URL's is not something I have time for, I have several URL's flying past me every second
12:36:49 <shapr> y0 jemfinch|lambda, we never finished that discussion.
12:36:59 <jemfinch|lambda> which one?
12:37:05 <shapr> about plone + haskell
12:37:26 <jemfinch|lambda> Ah, I didn't remember that we'd really started it, if you answered the question initially, I missed it :|
12:37:40 <shapr> I don't think I did, I pushed it to a thunk and forgot to eval it.
12:38:01 <jemfinch|lambda> hehe
12:38:17 * musasabi gets yi for a change
12:38:47 <musasabi> Is the scannednavian repo updated frequently?
12:38:53 <shapr> once every midnight.
12:38:57 <shapr> I can turn that up if you wish.
12:39:05 <musasabi> no that should be enough.
12:41:18 <bringert> hej shapr
12:54:10 * shapr loves #haskell
12:54:37 <shapr> There's nothing like being exposed to idiocy in other programming channels to improve my appreciation of #haskell
12:55:08 <Lor> Yet you still frequent them?
12:55:16 <shapr> I started them.
12:55:16 * shapr cries
12:55:48 <chucky> I can be idiotic here as well if it makes you feel any better. :)
12:55:54 <shapr> no, please no!
12:58:55 <CosmicRay> which channels, shapr?
12:59:17 <shapr> Which channels have I started? or which ones am I embarassed to have started?
12:59:42 <CosmicRay> which ones have you started and frequent
13:03:35 <shapr> I'm contact for concatenative, erights, epigram, haskell, jython, darcs, joy, and some other non-programming channels.
13:04:56 <CosmicRay> of those, I've probably visited only jython and darcs
13:05:03 <shapr> CosmicRay: I frequent haskell, darcs, and concatenative.
13:05:12 <shapr> yah, #jython is usually dead.
13:05:41 <boegel> hello everyone
13:05:48 <shapr> hoi!
13:05:57 <CosmicRay> hmmph.  I've got a bunch of functions that take a certain data type as an argument.  I've been making it the first arg, figuring it makes it easy to curry.  But now I'm seeing that it would be better served as the last arg, to make it easier to use with >>=.
13:06:08 <CosmicRay> shapr: any standard advice to pass along in that situation?
13:06:20 * shapr makes an advice monad
13:06:36 <CosmicRay> heh
13:07:07 <CosmicRay> I wonder suddenly if that is why some FiniteMap functions put the map first and others put it last
13:07:19 <shapr> you've always got flip
13:07:30 <CosmicRay> most of my functions take more than 2 args
13:07:47 <Riastradh> I prefer to be consistent and put the main data structure first.
13:08:38 <shapr> well, you can write scramble wrappers, or you can partially apply and use flip
13:08:54 <CosmicRay> what's a scramble wrapper?
13:09:06 <shapr> just something that changes the argument places
13:09:20 <CosmicRay> oh, so I could have set and set_, for instance
13:09:28 <shapr> like myFunction x y z = ... and then myFunction' z y x = myFunction x y z
13:09:36 <shapr> right
13:15:54 <CosmicRay> that just seems so inelegant.
13:18:22 <shapr> it just depends, you may be able to partially apply the other stuff before that, or maybe you could rearrange the args ahead of time.
13:19:13 <CosmicRay> well here's an example
13:19:15 <CosmicRay> set :: ConfigParser -> SectionSpec -> OptionSpec -> String -> CPResult ConfigParser
13:19:21 <CosmicRay> I've got a lot of functions like that
13:19:22 <bringert> I think I wrote some type class hacks at some point that allowed you to use a function with any argument order
13:19:32 <bringert> which is pretty much useless
13:19:41 <CosmicRay> I take a ConfigParser, do somthing to it, and return, loosely, an Either CPError ConfigParser
13:19:46 <CosmicRay> error monad is great for that
13:20:00 <CosmicRay> but >>= makes it a lot easier to make the input ConfigParser the last arg to set
13:20:13 <bringert> since the argument types all have to be unique
13:20:36 <CosmicRay> actually SectionSpec and OptionSpec are just strings right now
13:20:52 <CosmicRay> ahh
13:21:00 <CosmicRay> misread you, sorry bringert
13:21:39 <blackdog> does haskell have any kind of keyword arguments? I know you can have keywords in datatypes, but that's not quite the same...
13:21:53 <CosmicRay> blackdog: no, it doesn't
13:22:06 <CosmicRay> blackdog: it also lacks optional arguments
13:22:14 <CosmicRay> both of which vex the Python and OCaml in me :-)
13:22:47 <bringert> can't you do something like that with implicit arguments?
13:22:49 <Philippa> you can fake optional arguments if you really really need them, mind
13:23:01 <Philippa> probably, but I always got an icky feeling about those
13:23:18 <bringert> me too, that's why I don't know
13:24:02 <CosmicRay> I haven't heard of imlicit args in haskell
13:24:05 <CosmicRay> where can I read about them?
13:24:51 <bringert> CosmicRay: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#IMPLICIT-PARAMETERS
13:25:26 <Igloo> CosmicRay: I'd say most people use do notation so order for >>= doesn't matter
13:25:59 <CosmicRay> Igloo: I have a situation here where it is quite useful to use >>= -- basically there is a common scenario where people perform a serious of modifications
13:26:06 <CosmicRay> each "mod" returns a new, modified object
13:26:19 <CosmicRay> so >>= is a lot easier than a ton of local variables bound with <-
13:26:58 <Igloo> *nod*
13:27:23 <CosmicRay> hmm, it sems like this implicit parameter system is not so much an optional or default arg as it is a scoping manipulation
13:27:27 <CosmicRay> or am I missing someting?
13:28:04 <Igloo> It's evil onna stick, that's what it is
13:28:15 <CosmicRay> good, that's what my gut feeling was
13:28:44 <CosmicRay> it seems to break the fundamental promise of a pure function, namely returning the same thing every time it's called with the same args
13:28:48 <CosmicRay> since its result depends on who calls it
13:28:49 <jadrian> CosmicRay: somehow related to that, I implemented a function  composeM [f1,..., fn] a = \x->f1 x >>= (\x->f2 x >>= ... >>= \x->fn x) a   which I find quite useful
13:29:12 <Marvin--> at first glance it looks really neat, but when you dig into it you realize what havoc it wreaks with the type system and then it's not so fun anymore
13:29:40 <jadrian> CosmicRay: so I just put everything inside a list and compose it
13:30:02 <CosmicRay> jadrian: hmm....  /me ponders
13:30:16 <CosmicRay> Marvin--: actually I don't think it looks really neat even at first glance
13:30:25 <Marvin--> heh
13:30:55 <Igloo> jadrian: But that assumes you have the "other" argument ordering
13:31:08 <CosmicRay> Marvin--: the whole thing seems superfluous.  To use the ghc example, if I was wanting to set cmp to a particular function with sort, I could either "let cmp = blah; sort foo" or "let mysort = sort blah; mysort foo"
13:31:15 <CosmicRay> doesn't seem all that much superior
13:32:08 <jadrian> Igloo: you mean the fs in composeM [f1,..., fn]  ?
13:32:13 <Igloo> yup
13:32:18 <jadrian> Igloo: yeap
13:38:37 <shapr> salut Lunar^ 
13:39:24 <jadrian> CosmicRay: not that simple CosmicRay 
13:39:30 <CosmicRay> oh?
13:39:34 <jadrian> CosmicRay: (the implicit parameter stuff)
13:39:39 <CosmicRay> what did I miss?
13:40:08 <jadrian> CosmicRay: well you just used one single function in your example
13:40:08 <CosmicRay> (well other than chaining up the stack...)
13:40:32 <jadrian> CosmicRay: I'm refering to the "the whole thing seems superfluous." part
13:40:38 <jadrian> and the example
13:40:50 <CosmicRay> I suppose, if it follows the stack up, it could save some parameter passing
13:40:54 <CosmicRay> is there anything else?
13:41:05 <jadrian> it's parameter passing but not just that
13:41:48 <jadrian> for instance, something I just helped a friend with
13:42:14 <jadrian> it was chemistry stuff so in a module everything depended on Pressute Temperature and Volume
13:42:21 <jadrian> yeap it did save a lot of parameter passing
13:42:39 <jadrian> but some of the stuff that depended on those values "became" constants
13:43:01 <jadrian> for instance you have   Sigma that just depends on those 3 values
13:43:18 <jadrian> Sigma is used by 10 other functions
13:43:41 <jadrian> if you didn't use implicit parameters sigma would be a function
13:43:55 <jadrian> (of temperature, pressure and volume)
13:44:05 <jadrian> so it would be recalculated each time you need to use it
13:44:07 <CosmicRay> so it's a compiler optimization since the values are known at build time?
13:45:04 <jadrian> they are not known at compile time
13:45:16 <jadrian> these values may be introduced by the user
13:45:44 <jadrian> in this case it is a useful generalization of scooped functions
13:45:51 <jadrian> and that's how I mostly use them
13:46:35 <jadrian> the only alternative I can think of for that module would be putting all the functions inside a main function
13:47:03 <jadrian> that has those values (temp, press, and volume) at top level
13:47:05 <CosmicRay> right
13:47:15 <jadrian> but that is quite nasty 
13:47:30 <jadrian> you cannot test any of the subfunctions seperatly for instance
13:57:06 <shapr> greetz bloomberg 
13:57:22 <jadrian> hi shapr  
13:57:23 <bloomberg> hey
13:57:49 <shapr> Ã³la jadrian
14:02:47 <boegel> @seen micthkov
14:02:47 <lambdabot> I haven't seen micthkov
14:02:51 <boegel> @seen mitchkov
14:02:51 <lambdabot> I saw mitchkov leaving #haskell 2 days 4 hours 1 minute 3 seconds ago.
14:04:08 <shapr> @seen Boegel
14:04:08 <lambdabot> Boegel has changed nick to boegel.
14:04:08 <lambdabot> boegel is in #haskell.
14:04:22 <boegel> shapr: :)
14:04:46 <boegel> I should change my nick settings on my desktop... then I won't log in as Boegel...
14:04:52 * shapr grins
14:05:34 <shopr> @seen Boegel
14:05:34 <lambdabot> Boegel has changed nick to shopr.
14:05:34 <lambdabot> shopr is in #haskell.
14:05:41 * shapr snickers
14:05:46 <shopr> smart lambdabot :p
14:05:57 * shopr snickers
14:07:17 * sh0pr hops
14:08:08 <jadrian> that John Meacham msg about adding derived instances breaking invariants was pretty insteresting
14:08:11 * shapr laughs
14:08:15 <HET2> Program error: pattern match failure: sumCarry "111" "111" (Num_fromInt instNum_v30 0) <- can anybody give me a hint as to what haskell might be complaining about?
14:08:17 <jadrian> it had never crossed my mind
14:08:18 * shopr goes unicycling
14:08:21 <shapr> this is too scary!
14:08:28 <jadrian> lol
14:08:31 * sh0pr hops on his unicycle
14:08:37 * shapr laughs
14:08:50 * shopr bounces
14:08:57 * shapr laughs more
14:09:07 <HET2> oh
14:09:10 <HET2> i figured it out
14:09:13 <sh0pr> hello shopr! any questions about haskell we can answer ?
14:09:14 <musasabi> evening
14:09:32 * shapr rolls on the couch laughing
14:09:41 <shopr> hey sh0pr, how about a tour ?
14:09:45 <CosmicRay> sh0pr: I think you should give him the haskell tutorial.
14:09:47 <CosmicRay> heh
14:09:57 <sh0pr> shopr: of the language or the channel ?
14:10:02 <CosmicRay> haha
14:10:14 <shopr> sh0pr: first, we have lambdabot
14:10:18 <shapr> they've warezd my script! ohno!
14:10:19 <shopr> @seen shopr
14:10:20 <lambdabot> shopr is in #haskell.
14:10:21 <shopr> @seen shopr
14:10:21 <lambdabot> shopr is in #haskell.
14:10:22 <shopr> a
14:10:26 <shopr> @seen shapr
14:10:26 <lambdabot> shapr is in #haskell.se, #darcs and #haskell.
14:10:28 <shopr> @seen sh0pr
14:10:29 <lambdabot> sh0pr is in #haskell.
14:10:53 <shapr> I've never been parodied before, this is cool =)
14:11:16 <shopr> sh0pr: I think we sould kick shapr, we don't need him anymore :p
14:11:19 <tromp> isn't that the sincerest form of flattery?
14:11:28 <shapr> tromp: sometimes?
14:11:32 <sh0pr> so, I am writing the program using GF to parody myself...
14:11:34 <wli> noisy stuff
14:11:36 <edi> haha
14:11:39 --- mode: ChanServ set +o shopr
14:11:42 --- mode: ChanServ set +o sh0pr
14:11:43 <vegai> that gets old soon
14:11:45 <edi> yes, that's good i suppose
14:11:56 * shopr bounces around rapidly
14:12:04 <vegai> ok, I take it back. Please keep on amusing us ;-P
14:12:22 * vegai cowers.
14:12:29 <CosmicRay> shopr: I'm looking for some Haskell code to process a reiser filesystem as a string in constant time, portable across ghc and hugs.  I need it to be able to fit in an x86 boot sector and resize the filesystem in 10 lines of code or less.  Could you point me at some code someone's written that does that?
14:13:03 <shopr> CosmicRay: maybe lambdabot can help you with that, let me show you
14:13:12 <shopr> @index reiser
14:13:12 <lambdabot> bzzt
14:13:16 <shopr> @index reiserSystem
14:13:17 <lambdabot> bzzt
14:13:17 * CosmicRay lol
14:13:19 <tromp> @index panic
14:13:19 <lambdabot> bzzt
14:13:27 <shopr> @arr
14:13:27 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
14:13:33 <tromp> @index DON'T PANIC
14:13:33 <lambdabot> bzzt
14:14:29 * shapr whews
14:14:30 <boegel> anyway, I should go :p
14:14:32 <CosmicRay> heh
14:14:37 <CosmicRay> that was great, boegel
14:14:40 <CosmicRay> heh
14:14:42 <boegel> ah here we go :)
14:14:47 <shapr> it was very funny =)
14:15:11 <edi> @index bzzr
14:15:11 <lambdabot> bzzt
14:15:13 <edi> err
14:15:17 <edi> @index bzzt
14:15:18 <lambdabot> bzzt
14:15:26 <edi> finally makes sense.
14:15:33 <boegel> edi: :)
14:15:38 <edi> ^_^
14:15:43 <shapr> :-)
14:15:54 * vegai applauds.
14:16:02 * shapr applauds too
14:16:22 * edi takes photos
14:16:56 * boegel is printing the log file of this to hang it on his wall
14:17:03 * shapr grins
14:19:04 <boegel> I'm out... I have class tomorrow at 8.30, so that means getting up at 6.30 :(
14:19:29 <shapr> have fun!
14:19:39 * musasabi does not try to follow
14:19:46 <boegel> shapr: I will :p it's fuzzy set theory
14:23:28 <boegel> sleep tight everyone
14:23:36 <musasabi> night.
14:23:40 <edi> goodnigh boegel!
14:24:02 <edi> s/h/ht/
14:41:29 <edi> goodnight!
15:01:22 <np_hard> the haskellification of my one-off scripts continues
15:01:28 <shapr> yay!
15:02:03 <np_hard> now here's something to ponder
15:02:15 <np_hard> why isn't String a typeclass?
15:02:34 <shapr> there's been a recent long mailing list thread about that.
15:02:58 <np_hard> or, a less philosophical question which led to that big one:
15:03:06 <np_hard> why is there splitPS but no splitString ?
15:03:09 <tromp> to allow use of all List functions
15:03:42 <np_hard> I bet you can guess what my one-off scripts used to be written in
15:03:55 <np_hard> hint, the languages start with "P"
15:04:09 <shapr> Python?
15:04:11 <shapr> Pascal?
15:04:12 <musasabi> perl.
15:04:15 <shapr> doh
15:04:19 <musasabi> sorry.
15:04:25 <shapr> :-)
15:04:56 <tromp> PDP-11 assembly:-?
15:05:05 <np_hard> python and perl
15:05:07 <np_hard> no pascal
15:05:09 <np_hard> :)
15:05:36 <tromp> postscript!
15:06:08 <derelm> i have an expression "let k a = (\a -> a) (\b -> a) in k 2 4" and i wonder why it results in 2 and not in 4, can anyone explain that to me?
15:06:25 <np_hard> can't strings be both in String and List?
15:06:54 <np_hard> oh wait, list isn't a typeclass either
15:08:26 <Lor> It would be nice to have a class for strings.
15:08:43 <Lor> String literals would be overloaded for them, just like number literals are overloaded.
15:09:18 <Marvin--> derelm: (\a -> a) (\b -> a)  is equal to  \b -> a, so basically you have  k a b = a
15:10:33 <derelm> Marvin--: ah ok
15:15:44 <Lunar^> Did anyone build GHC HEAD lately ? 
15:17:00 <derelm> hmm, i have the expression "let k a = (\a -> a) (\b -> a) in k (let x = 2 in x) 4" and i should remove the "derived forms" ("syntaktischen zucker" in german) and substitute them by adequate lambda-expressions... i am quite lost...
15:18:35 <derelm> what i would do is: substitute (let x = 2 in x) with simply 2 or write it as (\a -> 2)
15:19:42 <derelm> hmm, the latter doesn't work though :(
15:22:02 <monochrom> (\a -> 2) ()
15:22:19 <monochrom> (\x -> x) 2
15:23:31 <monochrom> The last one is serious.  Generally "let x = y in z" = (\x -> z) y
15:24:17 <derelm> hmm
15:26:27 <derelm> so that would be the "clean" version? let k a = (\a -> a) (\b -> a) in k ((\x -> x) 2) 4
15:27:04 <monochrom> There is still another let to eliminate, if you don't mind.
15:27:58 <derelm> hehe, well i don't mind, but i am not quite sure if i am ment to eliminate the first let ...the text describing the todo is rather blurry
15:28:40 <monochrom> first translate "k a = stuff" to "k = (\a -> stuff)" of course.
15:30:14 <jadrian> hmmm maybe you're supposed to simplify the whole expression?
15:30:16 <derelm> k = (\a -> ((\x -> x) 2))?
15:30:36 <derelm> i can't really tell you from what i have as describtion! :(
15:30:44 <jadrian> those \a->a  and  \x->x are irrelevant
15:31:28 <jadrian> k = (\a -> ((\x -> x) 2))  ...  k = \a->2
15:32:10 <monochrom> I think the exercise is in desugaring "let", that's all. 
15:32:18 <jadrian> right
15:32:24 <derelm> well ok...
15:32:46 <derelm> but wouldn't k = \a -> 2 be different frfrom the initial term?
15:33:12 <jadrian> I just looked at what you just wrote last
15:33:14 <derelm> hmm, well guess not as the result is the same, only now it is really static
15:33:32 <jadrian> and those to expressions are the same
15:33:35 <jadrian> \a -> a is id 
15:34:27 <derelm> hmm, wait i'll try to translate the exercises description...
15:38:23 <derelm> transform (desugar) the expression "let k a = (\a -> a) (\b -> a) in k (let x=2 in x) 4" into an expression without functiondefinition using let. use adequate lambda expressions instead. then i am to "rename the variables" and evaluate the changed expression using the rules we got during the lectures...
15:39:15 <derelm> so if i end up in k = \a -> 2 there is not much to do left? evaluating and writing down what haskell internally does is a rather short thing, right?
15:39:16 <monochrom> Yes, so first desuger (eliminate let) but do nothing else.  Then simplify.
15:40:00 <derelm> monochrom: so you think i should eliminate both let's ?
15:40:05 <monochrom> Yes.
15:43:04 <derelm> hmm, well k = \a -> 2 is reduced to k = 2 so my evaluation of the function is really short, i doubt that it's meant to be so short... argh
15:52:58 <jadrian> "hmm, well k = \a -> 2 is reduced to k = 2"
15:53:00 <jadrian> no
15:53:11 <jadrian> k = \a -> 2   ...  k a = 2
15:58:31 * shapr bounces cheerfully
15:58:38 <melah> .
15:58:43 <shapr> hiya melah 
15:58:46 <melah> hi
15:58:53 <shapr> How's code treating you?
15:58:58 <melah> is everyone here experts at haskell?
15:59:04 <melah> i'm just learning
15:59:24 <shapr> There's the whole range here, from complete newbie up to very experienced.
15:59:51 <melah> i see
15:59:59 <shapr> Do you have any particular questions? I might be able to help.
16:00:15 <melah> i'm currently looking at infinite list
16:00:35 <shapr> Do you like 'em?
16:00:37 <melah> and still confused how to use 'map' in place
16:00:51 <melah> :) do i like lists? erm not really i am so bad at it
16:01:00 <melah> i'm really new
16:01:10 <shapr> I was there too, I know what it's like.
16:01:42 <shapr> Frustrating at first, and then the rush when you realize you're suddenly a slighly better programmer.
16:01:46 <Igloo> What do you mean by "in place"?
16:02:37 <monochrom> I'll ignore "in place" and just say how to use map period.
16:02:44 <melah> oh i mean .. like.. for eg .. you are suppose to be able to use 'map' in place of 'iterate' or something like that?
16:02:53 <np_hard> or the slight twinge you feel when noticing your perl code looks like map {...} grep /..../, @junk
16:03:30 <monochrom> If you have [x, y, z, ...] and you would like to produce [f x, f y, f z, ...] instead, just try map f [x, y, z, ...]
16:03:33 <melah> sorry if my question was stupid erm i guess i am confused with all these new commands
16:03:59 <melah> ok that i understand monochrom, but how do you use map in infinite list?
16:04:06 <melah> map f [1..]
16:04:09 <np_hard> same as a finite one
16:04:11 <monochrom> [x, y, z, ...] is an infinite list.
16:05:00 <melah> what about if you have for eg iter = iter (tail iter)
16:05:20 <melah> can we use map to mean the same thing?
16:06:12 <jadrian> you can use map with any list to mean the same thing
16:06:17 <monochrom> Type checking
16:06:17 <monochrom> ERROR "whatever.hs":1 - Type error in application
16:06:17 <monochrom> *** Expression     : tail iter
16:06:17 <monochrom> *** Term           : iter
16:06:17 <monochrom> *** Type           : b -> c
16:06:17 <monochrom> *** Does not match : [a]
16:06:25 <monochrom> That's for iter = iter (tail iter)
16:07:07 <monochrom> I don't know how to produce the same type error using map, sorry.
16:07:40 <jadrian> o/me read the question wrong...
16:07:51 <melah> oh that's ok thanks 
16:08:53 <melah> what I really mean is to say.. i've seen in books that some function definition (for infinite list) can be rewritten using 'map' in it.. i cannot remember any examples off my head but didn't understand the book
16:09:18 <Igloo> map can't make an infinite list unless you give it one to start with
16:09:36 <melah> can anyone give me some examples with explaination?
16:09:50 <melah> Igloo can you explain more?
16:09:56 <Igloo> [1..] is the infinite list of positive integers
16:10:03 <melah> yes i agree
16:10:09 <Igloo> map (\x -> 2 * x) [1..] is the infinite list of even positive integers
16:10:27 <melah> wat is \x ?
16:10:47 <Igloo> \x -> 2 * x is the function that takes an argument x and returns 2*x
16:11:18 <Igloo> It sounds like you probably want a good book or online tutorial or somesuch
16:11:18 <Cale> \ is supposed to look like lambda -- \x -> 2*x is the function which maps a number x to twice the number, 2*x
16:11:46 <melah> yes... i am really new , not just to haskell but to programming in general
16:12:04 <melah> any good books on haskell to recommend? something easy for beginners like me?
16:12:29 <jadrian> depends on what you wanna learn
16:12:43 <jadrian> or how you want to learn
16:12:48 <jadrian> I like Richard Birds book
16:13:02 <jadrian> but it has plenty of theory
16:13:06 <melah> i have that book
16:13:12 <melah> yes that's what i thought too
16:13:17 <monochrom> xs = 0 : map f xs
16:13:35 <resiak> melah: The theory is not necessarily a bad thing.
16:13:38 <jadrian> then there is the Haskell School of Expression
16:13:39 <monochrom> That will result in xs = [0, f 0, f (f 0), f (f (f 0)), ...]
16:13:57 <jadrian> Paul Hudak ?
16:14:01 <melah> Oh i see
16:14:01 <monochrom> For example if you define f x = x + 1, you get xs = [0, 1, 2, 3, ...]
16:14:17 <jadrian> which uses some multimedia examples which you might like
16:15:09 <melah> paul hudak? ok i will look out for it...
16:15:13 <melah> monochrom thanks
16:16:09 <monochrom> "xs = 0 : map f xs" is intermediate level, not beginner stuff.  You shouldn't worry about it.
16:16:34 <melah> I am also confused with this: data Tree a = leaf a | fork (Tree a) (Tree a)
16:16:48 <melah> how can you use a (Tree a) here?
16:16:49 <jadrian> melah: you need to use uppercase for leaf and fork
16:16:55 <monochrom> And there are much easier, more readable way of making infinite lists than that, and without loss of generality.
16:16:57 <jadrian> melah: (1st letter that is)
16:17:02 <melah> oh yes upper case
16:17:24 <jadrian> melah: it just means that a Tree is eithat a Leaf with one element
16:17:40 <jadrian> melah: or a fork (node) with two subtrees
16:18:03 <jadrian> melah: Leaf 1   is a tree
16:18:08 <melah> ok i see now... 
16:18:21 <jadrian> melah: and since Leaf 1 is a tree so is   Fork (Leaf 1) (Leaf 1)
16:18:42 <melah> i find it strange that haskell allows (Tree a) for data Tree a definition
16:19:10 <resiak> melah: It's just a recursive definition.
16:19:49 <dons> you can't get anwywhere without recursive types
16:19:59 <melah> looks like i'm really too new  here :)
16:20:10 <monochrom> How can it be strange, especially since you're new to programming in general? :)  Perhaps everything else is just as strange...
16:20:16 <melah> are other programming languages similar in that they allow recursive types too?
16:20:24 <monochrom> YES!
16:20:35 <melah> i had thought that data definiton is simply saying this data means this and this
16:20:37 <monochrom> C++ and Java certainly have them.
16:20:47 <melah> ok.. :)
16:21:02 <melah> i'm learning all this on my own by the way...
16:21:11 <melah> from books if you like.. 
16:22:10 <melah> what about the difference between 'Hugs' and GHC? 
16:22:24 <jadrian> I wonder why so many languages have products (records) but so few have co-products
16:22:33 <jadrian> is there such a thing in Java by the way?
16:22:46 <Riastradh> melah, they're simply different implementations of Haskell.
16:23:20 <jadrian> how do you express  something like   data A = B Int | C Char   in java?
16:23:49 <jadrian> in C/C++ there are unions
16:23:58 <monochrom> class A {}
16:24:04 <jadrian> in Pascal records with conditional fields can be used
16:24:12 <monochrom> class B extends A { int i; }
16:24:22 <monochrom> class C extends A { char c; }
16:24:34 <jadrian> right
16:24:40 * jadrian never got to learn Java
16:24:48 <monochrom> One can show that B and C are disjoint.  Thus A is a disjoint union of B and C.
16:24:57 <jadrian> yes
16:25:27 <jadrian> I know this isn't a Java channel :) but how do you "pattern match" then latter?
16:25:34 <jadrian> that is
16:25:49 <jadrian> if you have some A
16:25:59 <jadrian> how can you know if it is a B or a C?
16:26:17 <monochrom> Object Obfuscation Pomposity means that you emulate all programming constructs by classes or objects.  For example there is no higher-order functions in Java, but there is the Command pattern.
16:26:21 <Riastradh> if (a instanceof B) { ... } else if (a instanceof C) { ... }
16:26:35 <jadrian> right
16:27:02 <jadrian> guess I'll stick to haskell...
16:27:06 <dons> hehe
16:27:08 <monochrom> You don't bloody pattern-match.  You tell the IDE to generate template code of Riastradh
16:27:42 <shapr> hi big 
16:27:44 <shapr> g'day dons 
16:28:00 <dons> hey shapr
16:29:15 * Igloo bounces
16:29:20 <shapr> Igloo: ?
16:29:33 <Igloo> Nothing in particular
16:29:47 <shapr> I know that feeling.
16:29:50 <Philippa> monochrom: in fairness, the Command pattern would be excusable with an Interpreter class. Not to mention look a bit like monads.
17:00:09 <big> ??
17:00:18 <Lemmih> Huh?
18:07:53 <Crusoe> Is there a O'Haskell implementation outside of O'Hugs?
18:12:56 <Cale> Crusoe: O'Haskell is called Timber now, from what I can tell
18:13:12 <Cale> but I don't know if there's a publicly available implementation of Timber yet.
18:40:30 <wagle> the grant that funded timber ended about a year ago..  i think johann is still privately poking at it, but only for personal pride purposes
18:40:44 <wli> what's timber?
18:41:05 <wagle> reactive oo subtyped haskell
18:41:13 <wagle> quasi realtime
18:41:28 <wagle> the "quasi" is me
18:41:41 <wagle> does edf scheduling
18:41:47 <wli> apart from "subtyped" I have no idea what any of that means, particularly not the "oo" part since "oo" is a flaming bag of useless ill-posed crap
18:42:26 <Riastradh> It adds some different kind of generic dispatch to Haskell as well as supertyped (not subtyped!) algebraic data types.
18:42:37 <Riastradh> (Different from typeclasses, that is.  Dynamic dispatch may be involved.)
18:43:10 <wagle> the word supertype was never used in my presense in the timber meetings
18:43:22 <Helic> afaik, doesn
18:43:25 <Helic> err
18:43:30 <wagle> of course, the subtypeing stuff was downplayed
18:44:05 <Helic> afaik, doesnt fp promote computing without states ? Dont OO extensions go in the other direction ?
18:44:38 <wagle> timber was never really real..  for some reason they wanted to go directly from a very buggy interpreter to a full fledged compiler
18:46:03 <wagle> i was strongly discouraged from diving into its guts, and my supply of round tuits and rainy days got applied elsewhere, so i never did anyway
18:46:45 <wli> subtyping would by far be the most interesting part
18:46:51 <Riastradh> wagle, I was referring to the construction of algebraic data types that were supersets of other algebraic data types, not the subtyping of records or structs or whatever.
18:48:07 <wli> structural subtyping looks *very* useful
18:48:37 <Riastradh> Defining new subtypes of existing algebraic data types was not, as far as I can tell, a part of O'Haskell or Timber or whatever it's called; defining new supertypes of existing types was.
18:50:16 <wli> not sure why you'd need to define them; given a set of constructors you get a minimal type they're canonical injections into...
18:51:10 <wagle> the subsuperduperwhatever types were downplayed in timber
18:51:32 <wli> well, it already sounds like they were based on an entirely different concept from the ones I like
18:52:26 <wli> ah, there are record subtypes
18:52:28 <wagle> i programmed the timbot using other means while waiting for timber to get real enough to run on it
18:52:47 <wli> field name in the opposite direction wrt. inclusion
18:55:04 <wli> there was some huge dissertation about how to do type inference for the things as extensions of Standard ML
18:55:09 <wagle> hmm..  i might not have tracked the timber-compiler mailing list when it moved hosts about a year ago
18:55:22 <wli> NFI how or if any of it applies to Haskell
18:55:36 <wagle> whose dissertiation?
18:55:56 <wli> looking
18:58:05 <wagle> nordlander's thesis built ohugs.. which is haskell..  but he might have gone for explaining ML, since its semantics is formalized...
18:58:57 <wagle> though that might be odd..  i seem to keep failing to read that dissertation..  8/
19:00:28 <wagle> i think that nordlander's postdoc work was, in part, to turn ohugs into timber
19:00:38 <Philippa_> Riastradh: is the supertyping the sort of thing I'm doing with Tyop?
19:00:43 <Philippa_> as in, it's noi
19:00:45 <Philippa_> er
19:00:59 <Philippa_> nominally subtyping, only you don't add new subtypes at random, you add new supertypes?
19:01:08 * Philippa_ reads up
19:01:10 <Philippa_> yep
19:01:21 <Philippa_> it's pretty obviously all you can sanely do with ADTs
19:02:18 <Philippa_> anything else interesting in timber's type system?
19:02:57 <Philippa_> eg how do they have supertyping and type classes interacting?
19:03:06 <Philippa_> (yes, I have given thought to the issue myself)
19:03:15 <wagle> they tried to add temporal annotations to constrain the real-time behavior
19:03:37 <wagle> but i never saw them do anything other than really basic stuff
19:04:14 * Philippa_ is starting to worry that somebody may've beaten her to some cool ideas :-)
19:04:31 <wagle> the concentration was on real-time, and su*typing was downplayed
19:04:38 <Philippa_> though if they had I suspect there'd be a big fuss about it, they're /really/ cool ideas
19:05:01 <Philippa_> is there a spec anywhere?
19:05:29 <wagle> in johann's head, i think
19:05:35 <Philippa_> heh
19:05:45 <Philippa_> guess I get to race him to publish then? :-)
19:05:50 * Philippa_ <- undergrad
19:06:18 <wagle> i played whack-a-mole for a while, trying to pin it down, then gave up..  hence my lack of useful amounts of information
19:06:27 <Riastradh> http://www.google.com/search?q=o'haskell
19:06:38 <Philippa_> supertyping + type classes can do some very cool things in combination, but you need a few things to make it work right
19:06:39 <wagle> at the rate he's going, you might win..
19:06:46 * wagle grabs some popcorn
19:07:23 <wagle> i want to statically do dimensional analysis..
19:07:40 <wagle> which i've thought requires subtypes..
19:08:39 <wagle> ie, (x :: Inch) = (1 :: Meter) should work 
19:08:52 <wagle> but (x :: Inch) = (1 :: Liter) shouldnt
19:09:26 <wagle> and the type checker should be complaining in the second case, and automatically generating conversion code in the first..
19:10:31 <wagle> i used liang's OR class to do this a while back, but then discovered that its VERY dynamic..  all type checks happened at run-time.  (AIEEE)
19:10:51 <Philippa_> having read a doc, it looks like I'm doing something different
19:10:57 <Philippa_> which is good, I'm pretty sure tht
19:11:05 <Philippa_> er, damn this laptop keyboard :-)
19:11:16 <Philippa_> I'm pretty sure that what I'm doing is cooler :-)
19:12:04 <Philippa_> ooh, in fairness this report is from 2002, they may've got further
19:12:23 <Philippa_> I hope so. I mean, I'd almost be saddened to've spotted something Mark Jones didn't
19:15:39 <wagle> you got a working implementation/prototype yet?  *<8-)
19:16:06 <Philippa_> not for type classes
19:16:25 <Philippa_> believe me, I'll be celebrating loudly when I have that
19:16:43 <wagle> well, the effort was to do real-time, not su*types
19:16:48 <Philippa_> I have H-M + ADT supertypes
19:16:50 <Philippa_> yeah
19:17:11 <Philippa_> type classes on top of that is... interesting
19:17:30 <wagle> what school you at?
19:17:31 <Philippa_> I think it should be reasonably straightforward, once you deal with the coherance issue
19:17:37 <Philippa_> University of Nottingham
19:19:11 <wagle> i've been meaning to follow up on what the crazy stuff doing logical programming in the type system, which seemed to involve type classes
19:19:31 <Philippa_> yeah, fundeps
19:19:32 <wagle> ... on what the crazy stuff _is_ that does...
19:20:32 <Philippa_> I'd like fundeps in Tyop, it'd allow some nicely symmetric things in the type system
19:20:40 <Philippa_> what goes for sums goes for products, kind of thing
19:21:07 <wli> wagle: incoming DCC
19:21:51 <wagle> wli: i have no clue how to retreive that from irssi
19:22:10 <wli> Massive irritation
19:22:22 <wli> massive
19:23:22 <wli> emailed, assuming 510K can pass the smtpd
19:27:28 <wagle> i only asked who's dissertation..  not for the dissertation
19:28:54 <Philippa_> wli: any chance I can see too?
19:29:05 <Philippa_> only this sounds rather a lot like my undergrad project :-)
19:29:31 <wagle> Philippa_: from the evidence, i (tentatively) came to the conclusion that overlapping instances were implemented (in hugs anyway) using dynamic type checking..  are you up on overlapping instances (why you do or dont want them, and how to implement them)?
19:30:14 <wagle> also seemed that they were a bit clumsy
19:30:28 <Philippa_> am reading the 'exploring the design space' paper atm, I only really grokked some of the more involved stuff with type classes recently
19:31:16 <Philippa_> I suspect I want them for Tyop, I'm taking a look at the tradeoffs
19:31:43 <wagle> wli sent me the dvi file for http://www.lfcs.inf.ed.ac.uk/reports/98/ECS-LFCS-98-403/
19:32:23 <Riastradh> Tyop is too ironic a name.
19:32:57 <wagle> Philippa_: sounds like a cool project..  i want a ticket to its premiere
19:33:12 <Philippa_> heh
19:33:24 <Philippa_> Riastradh: there's a reason it was picked :-)
19:34:06 <Philippa_> wagle: damn, that really /does/ look like what I'm doing - will have to grab and read
19:34:38 <Philippa_> and yeah, the Tyop interpreter'll be available for download once it hits a decent state in terms of usability and features
19:34:48 <Philippa_> I'd love to start speccing out a base library as well, but hey
19:35:13 <Philippa_> it's an undergrad project, even if it /will/ have had 4 years behind it by the time it's done
19:35:42 <wagle> keep the project small enouigh to actually finish..  8)
19:36:13 <Philippa_> oh, I can call it done at any point
19:36:19 <Philippa_> only I've another 18 months...
19:38:13 <Philippa_> type classes of any sort good
19:38:28 <Philippa_> but if I get fundeps, I get to do sweet things with records as well
19:38:50 <wagle> heh: 09:48:06 <Philippa> "tyop" (there's a prize for the first person to guess the origin)
19:39:18 <Philippa_> the prize was a PRIVMSG btw :-)
19:39:48 <Philippa_> still haven't told gmh it's called that yet, wonder how he'll react...
19:39:52 <Philippa_> (my supervisor on this)
19:41:08 <wagle> hah.  i was trying to find a newer version of his comp.lang.functional faq just a day or tgwo ago
19:41:56 <Philippa_> oh good, somebody who knows who I mean :-)
19:42:23 <Philippa_> I mentioned the NG a while back and he asked if there were anything interesting on it again yet
19:43:05 <wagle> didn't look too noisy from the titles, any way
19:43:27 <Philippa_> yeah, I think he was more bored with the same old same old
19:43:33 <Philippa_> much more interesting conversation in here
19:43:44 <Philippa_> damn, better shut this down soon and let my b/f go to sleep...
19:43:55 <Philippa_> (yes, I'm IRCing in bed - sad, isn't it?)
19:44:01 <wagle> hahahaha
19:44:39 <wagle> its 3am?
19:44:39 <Riastradh> ...in bed _with_ someone else and you're IRCing?
19:44:49 <Philippa_> we've been going out over a year and living together most of it
19:45:08 <Philippa_> 'sides, we played around earlier :-)
19:45:45 <jadrian> is there a short for   "retrurn ()"
19:45:59 <Philippa_> not unless you wanna define one
19:46:03 <Philippa_> I suggest "done"
19:46:06 <jadrian> k thanks
19:46:27 <jadrian> Philippa: yeah, I even thought that was defined, I've seen it around before I'm sure
19:46:45 <jadrian> Philippa: maybe Richard Bird book...
19:46:49 <Philippa_> mebbe
19:47:06 <jadrian> I'm using monads more and more
19:47:32 <jadrian> no expert yet, but it's funny, I still remember just trying to understand them for IO
19:47:34 <Philippa_> I mean, you only really use it for the base case in a recursively-defined "iteration"
19:47:39 <jadrian> and now I find it really usefull :)
19:47:41 <wagle> "return ()" seems pretty short to me
19:47:49 <Philippa_> yeah
19:48:00 <Philippa_> anyway, sleep. Damien's complaining loudly now
19:48:09 <wagle> g'night
19:48:15 <jadrian> bye Philippa 
19:48:44 <jadrian> wagle: it's short yes, just not that "understandable"...
19:49:11 <jadrian> "success" as opposed to "fail" seems to read better, for instance
19:49:24 <jadrian> "done" is not bad either
19:49:25 <wagle> fail is already defined
19:49:29 <jadrian> yeap
19:49:47 <jadrian> I know, that's why I meantioned "success" as opposed to "fail" :)
19:49:52 <wagle> oh...  <re-read successful>
19:50:25 <wagle> except it doesnt always mean success
19:50:34 <wagle> hmm
19:50:36 <jadrian> indeed it doesn't...
19:50:41 <jadrian> well neither does fail probably
19:51:03 <jadrian> of course I can define it myself
19:51:04 <wagle> well, play with variants until you realize that return is the reasonable compromise..  8) 8/
19:51:13 <jadrian> :)
19:51:52 <wagle> "can others read your code?" and "will you be able to read it in 9 months?"
19:52:12 <jadrian> wagle: want an honest answer...
19:52:24 <jadrian> wagle: "I don't care, I want this done"
19:52:28 <jadrian> or I shouldn't care
19:52:41 <jadrian> but I always end up nitpicking
19:52:52 <jadrian> ah just one more thing
19:52:57 <wagle> then use return //  get used to it
19:53:03 <jadrian> "play with variants until you realize that return is the reasonable compromise"
19:53:30 <wagle> ok?
19:53:33 <jadrian> well this "success"/"done" keyword would be 
19:53:36 <jadrian> return ()
19:53:45 <jadrian> so it's not an alternative to return at all...
19:53:58 <jadrian> just return ()
19:54:45 <wagle> i personally don't like the name of "return", but i'm resigned to the fact that that name was chosen, and that there aint nuttin' i can do about it
19:55:00 <jadrian> yeap
19:55:11 <jadrian> oh well, guess I'll just use return
19:55:12 <wagle> success is an alternative for return ()
19:55:54 <wagle> the trained eye will pick out "return", but not "success".. for whatever use that fact is
19:56:02 <jadrian> yeap
19:56:26 <jadrian> opss brb
19:56:39 <wagle> and the monad laws specify the behavior of return
20:31:13 * wagle runs out of battery
22:58:35 <vegai> seems like Haskell is doing much better at Alioth's shootout these days
23:09:15 <setuid_w00t> I am just learning a bit of haskell.  I wrote a function (source here http://pastebin.ca/2520) that hugs doesn't like.  I suspect I have formatted incorrectly.  Any ideas?
23:10:05 <setuid_w00t> ohh and line 60 is the one that starts with "let prime = "
23:11:13 <Cale> I think you need to make sure the let starts after the end of the where
23:11:25 <dons> your if-then-else isn't too good. the 'else' should be past the 'if'
23:11:48 <Cale> perhaps that's it
23:12:00 <dons> could be the 'where' though
23:12:46 <setuid_w00t> Cale: you mean the horizontal position of the 'l' in let needs to come after the last 'e' in where?
23:12:47 <Cale> the normal idiom for layout of if-then-else is
23:12:50 <Cale> if foo
23:12:54 <Cale>     then blah
23:13:04 <Cale>     else bar
23:13:14 <Cale> setuid_w00t: yeah
23:14:14 <Cale> It would be nice to have an editor that placed light vertical bars showing where the offside rule puts blocks
23:14:46 <dons> that's a nice idea
23:15:25 <setuid_w00t> so should my line be like this:    where helper l = let prime = findFirstTrue l
23:15:46 <Cale> you could
23:16:04 <setuid_w00t> How would it typically be written?
23:16:13 <Cale> if you're going to have the let there, it ought to be indented more than helper
23:16:26 <Cale> because it's inside the definition of helper
23:17:18 <Cale> make sense?
23:17:31 <setuid_w00t> let me try it
23:18:15 <Cale> I need to go to sleep
23:18:25 <Cale> but I'm sure others here will help out
23:18:28 <setuid_w00t> was this what you mean?
23:18:30 <setuid_w00t>     where helper l =
23:18:30 <setuid_w00t>           let prime = findFirstTrue l
23:18:45 <Cale> at least one more space :)
23:19:14 <Cale> that's actually probably what I originally said, but it's also probably wrong :)
23:19:29 <Cale> the let is inside the def for helper
23:19:42 <Cale> so it needs to be tabbed in more than the def for helper
23:19:44 <setuid_w00t> ok.  Does haskell generally have different levels of indentation?  What I mean is that in C you generally have 4 or 8 spaces or a tab.
23:19:56 <dons> in the above example, the compiler will think there is a ';' after 'help l ='
23:20:21 <Cale> Most haskell programs I've seen use all sorts of indentation levels
23:20:30 <Cale> Emacs has a nice mode to make it easy
23:20:31 * wli uses 8-space tabs
23:20:36 <dons> 4  spaces is pretty common
23:20:50 <wli> 8-column tabs, more properly. Hard tabs, as in '\t'
23:21:10 <dons> tabs can be tricky when mixed with spaces in Haskell programs. The Haskell defn says tabs must be treated as 8 spaces, too.
23:21:46 <dons> all tabs would be fine. 8-space tabs is fine too
23:21:53 <Cale> I make sure that there are no tabs in any file I produce. :)
23:21:55 <ozone> still discussing tabs vs spaces in the year 2004
23:22:02 <setuid_w00t> hehe
23:22:25 <dons> maybe we should add a function to GHC to disable the Tab key
23:22:34 <Cale> heheh
23:23:07 <Cale> make it generate \a :)
23:23:30 <setuid_w00t> yay, it works
23:24:12 <dons> setuid_w00t: just make sure you indent bodies of defns further to the left
23:24:32 <setuid_w00t> dons: you mean right?
23:24:39 <dons> sorry, of course
23:25:38 <setuid_w00t> Is there a document on haskell.org that describes how indentation works?
23:26:27 <dons> it's in the Haskell98 Report
23:26:52 <dons> http://www.haskell.org/definition/haskell98-report.ps.gz
23:27:04 <magicuser> hey boys
23:27:10 <magicuser> hows the haskelling?
23:27:57 <setuid_w00t> dons: thanks.  wgetting now
23:56:00 <aj> hey, l33t, i think i can do monads now
