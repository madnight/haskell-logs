00:59:49 <musasabi> morninj
01:00:00 <musasabi> still alive... although not sure whether a good idea..
02:03:29 <boegel> hello everyone
02:05:51 <boegel> there has been news on hOp: http://www.osnews.com
02:05:55 <boegel> (2nd post)
02:44:59 <foobar2> hello
02:45:13 <foobar2> is there a way to specify packages in an OPTIONS pragma?
03:06:35 <Lemmih> foobar2: Not to my knowledge.
03:13:25 <foobar2> Lemmih: thanks...
03:14:03 <foobar2> Lemmih: since I tried generalizing OPTIONS -fglasgow-exts to OPTIONS -package package, but no luck.
03:58:28 <xerox> hi haskellers.
04:05:00 <Lemmih> Hello xerox
04:09:06 <shapr> mayhem: a linear value is use-only-once and you probably already know a continuation.
04:09:25 <shapr> good morning #haskell!
04:09:54 <mayhem> shapr, yea, I wonder if I can talk about linear continuations in the case of a static single {assignment,information} form
04:10:09 <mayhem> cause in that sense, its linear by itself, isnt it ?
04:13:03 <shapr> I'm not sure. Henry Baker started the whole linear approach from what I've heard. You may want to read his papers.
04:15:50 <mayhem> Ive taken 4 or 5 papers about linear continuations, lineary used continuations, and stuff like that. But most of those were really mathematical without arguing much about the advantages of that form for simplicity/performance of analysis
04:17:08 <shapr> Man, buncha clueless people talking about monads on OSNews.com
04:17:56 <shapr> mayhem: linear logic, linear continuations, and all the works of Henry Baker are still on my thunk list.
04:18:27 <shapr> hoi boegel 
04:18:51 <mayhem> shapr ok, when you say clueless, you're talking about those attemps of an Haskell OS ?
04:19:15 <shapr> yes, that's the bunch of clueless monad comments.
04:19:39 <mayhem> one of the guy is really skilled tho. (sebc)
04:20:12 <mayhem> maybe im just trying to defend him because he was in my school b4 :P
04:20:23 <shapr> I was talking about the *comments* after the article where people say "monads are imperative, so functional programming doesn't work"
04:20:35 <shapr> I know sebc is smart, and Lunar^ too.
04:20:52 <mayhem> ah yeah, ahh. ok
04:20:53 <mayhem> ):
04:21:05 <mayhem> yea, slashdot-like comments I guess 
04:21:08 <boegel> hello shapr 
04:21:15 <mayhem> there is always stupid peoples to do irrevelant comments
04:21:16 <pesco> Good Morning!
04:21:16 <boegel> have you seen my plasma ball ?
04:21:26 <shapr> greetings pesco!
04:21:30 <shapr> boegel: no? where is it/
04:21:46 <boegel> http://studwww.ugent.be/~kehose/thesisPublic/perlinNoise
04:21:52 <pesco> Greetings! shapr: You want to listen to RantRadio. Do you know them by any chance?
04:21:57 <wilx`> 404
04:22:01 <shapr> Nope, never heard of them.
04:22:11 <boegel> http://studwww.ugent.be/~kehose/thesisPublic/perlin
04:22:11 <pesco> http://www.rantradio.com/
04:22:20 <wilx`> 404
04:22:37 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/perlin (sry)
04:22:47 <wilx`> Hehe, now it works :)
04:22:51 <boegel> wilx`, :p
04:23:08 <pesco> Is that a quark-gluon plasma?
04:23:13 <pesco> ;-)
04:23:34 <pesco> Looks cool.
04:23:47 <shapr> boegel: wow nifty!
04:23:51 <boegel> pesco, I just know it's plasma
04:24:13 <boegel> i made using perlin noise on the RGB channels seperatly... bourbaki suggested it
04:24:38 <wilx`> Nice.
04:24:59 <pesco> boegel: Have you gotten it animated yet?
04:25:01 <shapr> I wonder if I can do one-to-many multicast with 6to4
04:25:41 <boegel> pesco, I don't think I will... I have some other things to do too for my thesis... but when I'm done with my thesis, I'll probably play with it some more
04:25:44 <pesco> shapr: Wow, I'd be interested to try that too, I've never used multicast.
04:25:45 <boegel> and release the code
04:26:58 <pesco> boegel: If you like, you can look at the Perlin noise module I wrote once. I dug it up yesterday and put it up along with some other stuff at http://www.scannedinavian.org/~pesco/code/Laboratory/
04:28:07 <boegel> pesco, why didn't you say that earlier :)
04:29:12 <boegel> pesco, it only supports 1D noise ?
04:29:29 <shapr> cool! pesco's lab!
04:30:56 <pesco> boegel: Oh no! The 1d function is a special case (IIRC) ;)
04:31:32 <pesco> boegel: Because I only found out about you making Perlin noise by you sayoung "I have this Perlin noise thing" ... ;)
04:31:53 <shapr> This calls for unicycling!
04:32:33 <Lemmih> And juggling!
04:32:52 <boegel> pesco, there's a new (improved) version of perlin noise
04:33:02 <pesco> boegel: Ah, that's what you implemented?
04:33:35 <boegel> pesoc: http://mrl.nyu.edu/~perlin/paper445.pdf
04:33:41 <pesco> Thanks!
04:33:43 <boegel> pesco, no, not yet... but I probably will
04:33:51 <boegel> it's easier, and it should be 10% faster
04:33:56 <pesco> Good!
04:34:09 <boegel> the perlin noise I have now, is just a test... :)
04:34:20 <pesco> :)
04:34:22 <boegel> I have had some trouble with it though :s
04:56:06 <boegel> another test: http://studwww.ugent.be/~kehoste/thesisPublic/perlin/perlinPlasmaLights.png
05:00:14 <pesco> Wow, that looks cool.
05:03:16 <boegel> pesco, I can't assign different perlin noise texutres for each object yet, but I will take care of that
05:07:54 * boegel = out
05:30:48 <bourbaki> moin
05:30:52 <Lemmih> Hey
05:52:35 <xkb> boegel: its starting to look nice
05:52:42 <xkb> did you allready add shadows?
05:54:11 <bourbaki> moin TheHunter
06:00:20 <TheHunter> moin bourbaki 
06:03:48 <aFlag> hi, does anyone know where can i read good stuff about types?
06:08:08 <mayhem> aFlag, its a large subject, which kind of types are you interrested in
06:09:46 <aFlag> i'm writting some code with a friend, i know a little haskell but he knows way more than me. I'm trying to understand some part of the code now but he's not online
06:10:05 <aFlag> i wanna know what are those newtype, instance keywords
06:11:14 <aFlag> also deriving
06:11:40 <aFlag> in datatype
06:13:05 <Lemmih> aFlag: You can try this tutorial: http://www.haskell.org/tutorial/
06:16:04 <TheHunter> aFlag, you might wanna google for "yet another haskell tutorial" which many people seem to prefer. You are most interested in Algebraic data types and type classes, i guess.
06:21:53 <aFlag> TheHunter, i reading the yet another haskell tutorial, but i thought maybe there were a more specific tutorial for just what i want
06:24:39 <Lunar^> shapr: Have you seen hOp featured on OSNews ?
06:30:08 <wilx`> Heh, the thread "C++ sucks for games" in comp.lang.c++ refuses to die :D
06:42:10 <shapr> hiya aFlag! what kind of flag are you today?
06:42:33 <shapr> Lunar^: yes, it's great!
06:43:59 <Lunar^> shapr: I don't, but that's a lot of hits
06:44:55 <shapr> hOp/House might end up with a real dev team.
06:56:30 <aFlag> shapr, a lambda flag, coding haskell today :)
07:23:07 <dustin`> Hmm, will the House people need coders for various standard network daemons?  I'm a noob, but I could code a mean echo server.
07:23:48 <TheHunter>                                                                                                                                                                                                                                                                                                                                                                                                                                                          
07:23:48 <TheHunter>                                                             /query lambdabot
07:23:56 <TheHunter> wtf?
07:24:16 <TheHunter> ah, sorry
07:37:55 <Janni> Hi.
07:43:11 <aFlag> how do i do a exit(0) like the one in C?
07:44:48 <Janni> Have a look at the System module and search for exit or quit or s.th like that.
07:44:49 <kristnjov> you don't do you?
07:45:30 <aFlag> ok, thanks
08:06:05 <marcot> Why is getLine :: IO Char, and no IO String ?
08:06:41 <marcot> marcot: Because it's wrong in the emacs-mode.
08:09:11 <aFlag> What's my name?
08:09:15 <aFlag> aFlag, Rafael
08:09:17 <aFlag> thanks
08:09:47 <TheHunter> @type System.exitWith
08:09:49 <lambdabot> System.exitWith :: forall a. GHC.IOBase.ExitCode -> IO a
08:09:56 <TheHunter> @type System.ExitSuccess
08:09:57 <lambdabot> System.ExitSuccess :: GHC.IOBase.ExitCode
08:10:27 <aFlag> yeah, i got it already :)
08:10:28 <aFlag> thanks
08:13:44 <aFlag> is it correct to call main recursively to get a infinite loop behavior for user input?
08:14:18 <Heffalump> should be fine
08:14:22 <aFlag> i mean, won't i eventually get a stack overflow?
08:14:27 <Heffalump> ah.
08:14:37 <Heffalump> well, now you're relying on the compiler's tail recursion recognition
08:14:40 <Heffalump> which should be good.
08:14:45 <Heffalump> but there's no guarantees
08:15:07 <aFlag> i see
08:15:12 <TheHunter> it works fine in hugs and needs (at least) -O in ghc
08:15:35 <aFlag> isn't there a better way to do it though?
08:15:35 * Heffalump thinks about it more carefully. Is this actually tail recursion?
08:15:51 <Heffalump> it's not a direct call to main, it's a call to (...) >> main
08:16:04 <Janni> aFlag: Do you know "interact"?
08:16:08 <aFlag> yes
08:16:14 <Janni> Maybe it fits your needs...
08:22:07 <marcot> Janni: where can I get help from the interact function?
08:25:19 <Janni> marcot: It's not too hard to understand (if you are a bit into functional programming and the I/O-Monad). It only takes a function with the signature (String -> String). And all it does is to call this function repeatedly.
08:26:10 <Janni> The function is supplied with one line of input everytime
08:27:28 <Janni> Just try: "main = interact id" or "main = interact reverse".
08:27:54 <Janni> Be careful. You have to set an appropriate buffering (wait a moment)
08:31:50 <Lemmih> Aren't you applying 'reverse' to an infinite list?
08:34:02 <Janni> Erm.. you're right. IO.hSetBuffering IO.stdin IO.LineBuffering doesn't change that fact.
08:34:38 <marcot> Janni: and howdo I stop it?
08:34:55 <Janni> interact (unlines . map reverse . lines) is what I meant
08:34:55 <desrt> does anyone know about the evil mangler?
08:35:49 <Heffalump> I know roughly what it does, and I think Igloo understands it reasonably well.
08:36:57 <desrt> i am attempting to battle it
08:37:01 <dustin`> Any ideas on why line 3 generates a "last statement in a 'do' construct must be an expression" error? --> http://www.cs.rit.edu/~dem5302/ihatemylife.txt
08:37:07 <dustin`> its clearly not the last statement!
08:37:18 <desrt> layout, probably
08:37:48 <dustin`> everything is aligned, with spaces and not tabs
08:38:36 <desrt> oh.  duh
08:38:40 <desrt> data is a keyword
08:38:46 <dustin`> ahhhh!
08:40:10 <desrt> btw: <- binds very weakly
08:40:50 <dustin`> So I don't need so many parens?
08:40:52 <desrt> btw2: there is readFile that opens/reads/closes and returns an IO String
08:42:08 <dustin`> Does it do the entire access in one fell swoop?  The laziness of the String produced by my method will only read the section of the file that I end up using, from my understanding.
08:42:32 <desrt> i think it's lazy
08:42:54 <dustin`> yar matey, I be lookin
08:43:43 <dustin`> yeah, its lazy
08:43:44 <aFlag> where's primGetContents?
08:43:58 <dustin`> Thanks for the advice, desrt 
08:44:01 <desrt> np
08:44:34 <TheHunter> it's lazy, it uses unsafeInterleaveIO in the ghc implementation.
08:47:48 <marcot> http://tonhao.no-ip.org/~marcot/xadrez/Main.hs
08:48:04 <marcot> Isn't e visible in the rest of the do statment?
08:49:59 <Lemmih> marcot: Yes it is but 'where' declarations are separate from the body of a function.
08:51:48 <marcot> Lemmih: hum...
08:51:51 <marcot> Lemmih: thanks.
09:09:15 <boegel> xkb: check http://studwww.ugent.be/~kehoste to see shadow progress (and specular lighting)
09:20:56 <whee> ray tracers are neat
09:26:53 <foobar2> hi
09:27:46 <dash> foobar2: hi.
09:27:56 <foobar2> in the Parsec documentation, they use {} and ; in the do notation
09:28:04 <foobar2> instead of indentation sensitive code
09:28:13 <foobar2> is there any motive, or just a matter of style?
09:28:17 <foobar2> hi dash!
09:28:34 <dash> just style, i should think
09:29:03 <foobar2> thanks thought so
09:30:03 <dash> parsec is a lot of fun, i just recently wrote a semi-complicated parser with it :)
09:30:33 <foobar2> yeap it's nice :)
09:30:40 <foobar2> I mean
09:30:46 <foobar2> *seems* nice
09:30:49 <foobar2> I'm just starting
09:31:02 <dash> what are you parsing?
09:31:55 <foobar2> I *might* have told you already under a different nick
09:32:10 <foobar2> just simple terms and 1st order formulas
09:32:23 <foobar2> (my nick was Asta, which is being used now...)
09:32:57 <dash> wasn't me :)
09:33:00 <foobar2> I'm just going to parse things like g(a,b,c)
09:33:12 <foobar2> then add meta vars and parameters
09:33:30 <foobar2> probably something like  g(?x,a,b)
09:33:46 <foobar2> then maybe add also infix and prefix operators
09:34:01 <foobar2> f1( a * b, g(?x))
09:34:14 <foobar2> and then 1st order formulas with these
09:34:42 <foobar2> P(f1( a * b, g(?x))) <=> \Fa x . Q(x) 
09:34:52 <dash> fun
09:35:07 <foobar2> I'll forget about the infix and prefix operators for now
09:35:33 <foobar2> even though the buildExpressionParser function seems to do most of the job...
09:40:37 <foobar2> hmmm
09:41:12 <foobar2> is there a way to make it choose the longer matching sequence?
09:41:18 <foobar2> for instance:
09:41:28 <foobar2> testP :: Parser String
09:41:28 <foobar2> testP = string "g" <|> string "g1"
09:41:39 <foobar2> this never parses "g1"
09:42:10 <boegel> foobar2, put "g" first ?
09:42:20 <Igloo> If this is parsec you need to use try
09:42:30 <Igloo> Or rewrite the grammar
09:45:14 <foobar2> rewriting the grammar wouldn't be an option
09:45:27 <foobar2> I probably won't do it like this
09:46:01 <foobar2> but I was thinking about letting the possible strings I will parse be specified in some file
09:47:06 <foobar2> so I wouldn't know beforehand which strings I'm using
09:48:25 <foobar2> but yes
09:48:29 <foobar2> try works
09:49:03 <foobar2> I should order the strings by length first
09:55:39 <foobar2> ...
09:55:41 <foobar2> testP2 :: [String] -> Parser String
09:55:42 <foobar2> testP2 = foldr1 (<|>)  . map (try . string)
09:55:58 <foobar2> now that would work for arbitrary strings
09:56:13 <foobar2> but I need to sort them by length first
09:57:49 <desrt> igloo!
09:58:02 <desrt> got a spare hour or so? :)
09:58:17 <foobar2> is it worth it to merge that foldr and map?
09:58:19 <Igloo> Err, what for?  :-)
09:58:33 <desrt> to explain the subtle differences between registerised and unregisterised :)
09:58:39 <foobar2> into a single foldr?
09:59:05 <Igloo> Ah, I don't understand exactly what goes on myself
09:59:05 <desrt> from what i understand, with unregisterised code you return a pointer to the function that you want to be called next
09:59:12 <desrt> and with registerised you do the tailjump yourself
09:59:43 <desrt> mm.  i'm trying to port the mangler
10:01:31 <desrt> i'm starting to believe that it will not be trivial -- the ABI i am porting to has this TOC thing that makes things very interesting
10:02:06 <Igloo> what ABI is it?
10:02:13 <desrt> powerpc64 AIX
10:02:26 <desrt> but the platform i'm porting to is linux... they just borrowed the AIX ABI
10:02:41 <Igloo> Is the TOC the same thing as a GOT? If so IA64 also uses one, so you might be able to do the same thing as it
10:02:45 <foobar2> just one more question
10:02:55 <desrt> honestly, i'm not sure of the subtle differences
10:02:59 <foobar2> I'm looking at ghc code for sortBy
10:03:26 <desrt> the story goes something like this for the toc: each module (module defined as binary output by the static linker) has its own TOC
10:03:41 <desrt> it is pointed to by r2
10:03:44 <foobar2> hmmm nevermind
10:04:02 <desrt> function names get prefixed with '.'.... so main has the symbol '.main'
10:04:18 <desrt> now.  main also has a symbol called 'main' that isn't function code.  it's a descriptor
10:04:43 <desrt> it contains a pointer to '.main' and the value r2 should be set to when calling main
10:05:00 <desrt> the idea is..... when you branch to something you say "b .function"
10:05:10 <desrt> which in the case of a function inside the same "module" will call the code directly
10:05:41 <desrt> but in the case that it's an external reference (to a shared library or something) then the linker will insert a stub for ".function" that looks up the address of the real .function and the 'r2' value from the 'function' descriptor
10:05:47 <desrt> then it loads up r2 and branches
10:06:17 <desrt> it's really cool because there are no run-time relocations on code segments
10:06:33 <desrt> which means you don't end up copy-on-writing half of your program text
10:07:00 <desrt> anyway... the mangler obviously needs to deal with these function descriptors.  fun.
10:07:56 <desrt> even more fun because normally you get C output like: '.text; foo_info: [info stuff] foo_entry: [code]'
10:08:49 <desrt> but with function descriptors you get stuff like '.text; foo_info: [info stuff]; .section ".opd"; foo_entry: [descriptor stuff]; .text; .foo_entry: [code]'
10:09:25 <desrt> which means that it's difficult to make the info section contiguous with the code section because you have to remove the ".opd" thing from between the middle of them >:|
10:31:26 <foobar2> ok
10:31:27 <foobar2> done
10:31:35 <foobar2> testP2 :: [String] -> Parser String
10:31:35 <foobar2> testP2 = foldr (<|>) (fail "") . map (try . string) . sortByLength
10:32:11 <foobar2> is there something better than (fail "")  for the identity of (<|>) ?
11:56:10 --- topic: '["The Nov 2004 HC&A Report is released! - http://haskell.org/communities/","Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'
11:56:10 --- topic: set by ksbot on [Wed Nov 10 14:16:59 2004]
12:16:13 <aFlag> i have a function that returns IO String how may i use that value in a non-IO function?
12:16:33 <kristnjov> try: return "the string"
12:16:35 <aFlag> like a function such as f :: String -> String
12:17:01 <kristnjov> foo :: IO String; foo = return "the string"
12:17:06 <kristnjov> try that,... i'm a newbie though
12:17:44 <pesco> aFlag: You cannot let the string "escape" the IO monad, if that's what you want.
12:17:57 <aFlag> hum...
12:18:03 <dash> the function has to go in, the value can't come out
12:18:05 <pesco> aFlag: What's the problem, specifically?
12:18:27 <aFlag> i'm trying to understand how to work with haskells io
12:19:15 <pesco> aFlag: Yes, what dash said. The IO stuff is around, outside of the functional computations.
12:19:22 <aFlag> i plan to do a network thing though
12:19:52 <dash> aFlag: so you've got some code that reads from the network, calls a function on the data, and writes something, right?
12:20:41 <aFlag> i want to write it, so far i have only the code that is not connected yet hehe
12:21:08 <dash> well yeah
12:21:17 <dash> but that's what you _want_ to have, right? :)
12:21:24 <aFlag> if there's some module other than Network that will help me with that, i'm all ears :P
12:21:25 <aFlag> yes
12:22:51 <dash> so you've got something like recvFrom that returns IO String
12:22:54 <aFlag> i want to be able to send something back also
12:23:17 <dash> you know how to use do-notation, right?
12:23:19 <aFlag> i'm trying to use the connectTo handle
12:23:31 <aFlag> i'm no expert but i know how to do it
12:23:35 <dash> right
12:24:08 <dash> so you've got "do data <- readSomethingFromTheNetwork"
12:25:01 <dash> the next line will look something like "writeToTheNetwork (processData data)"
12:25:24 <dash> and so that's how your function gets its string, it's called from inside the monad
12:34:07 <kristnjov> http://ameba.lpt.fi/~visktuom/kuvat/palvelija.jpg
12:38:07 <aFlag> hum.. i got it, thanks :)
12:46:35 <aFlag> that's a bit racist i'd say :P
12:52:08 <kristnjov> yeah i'd say so as well, but hey i didn't make the table :)
13:11:02 <aFlag> hehe
13:33:26 <aFlag> accept :: Socket -> IO (Handle, HostName, PortNumber), how do i get only the Handle? x:xs?
13:43:23 <boegel> aFlag, no, x:xs is for lists, (x,x,x) is a tuple
13:47:11 <boegel> hello CosmicRay 
13:47:22 <CosmicRay> good afternoon boegel
13:47:36 <CosmicRay> does anyone know what [| and |] are all about?  is that some sort of template haskell thing?
13:48:44 <aFlag> boegel, so how should i do it?
13:48:57 <boegel> aFlag, I have no idea :)
13:49:02 <CosmicRay> Igloo: can I assume your Printf is Copyright (c) 2003 Ian Lynagh?
13:49:14 <boegel> I also want to get something out of the IO monad, but I don't know how to do it
13:49:26 <CosmicRay> I want to adapt your Printer.lhs to use in my Printf, which doesn't require TH
13:50:07 <CosmicRay> heck, your Parser.lhs would be fine too :-)
13:50:43 <aFlag> boegel, what do you want to take out of the monad?
13:51:21 <boegel> I want to make a  function which generates a random list
13:51:33 <boegel> and the best way to do it is using random stuff of the IO monad
13:51:47 <boegel> but I don't want the result to be of type [IO Float] but just [Float]
13:51:49 <Igloo> CosmicRay: Yes
13:51:58 <CosmicRay> Igloo: excellent
13:51:59 <Igloo> [| |] is TH, yes
13:52:13 <CosmicRay> Igloo: I'm hoping that if I remove those, I'll have something that mostly doesn't need TH...
13:52:31 <CosmicRay> Igloo: but I know zilch about TH, so maybe that idea is all wrong
13:52:41 <aFlag> boegel, i think if you maybe pass it to another function so the other function appends stuff to the list when you get the result it might be [Float], but i'm just guessing here
13:53:01 <aFlag> if you pass to a f :: Float -> [Float] function
13:53:11 <aFlag> inside the do
13:53:29 <Igloo> CosmicRay: I'm curious as to what you're trying to end up with
13:53:36 <boegel> aFlag, I might
13:53:44 <boegel> I'll solve it, I just don't know how yet ;)
13:53:49 <Igloo> If you just remove all the TH annotations you'll end up with something that can't be typechecked  :-)
13:53:57 <CosmicRay> Igloo: something where I can say: sprintf "Foo: %s\nBar: %d\n" "blah" 5
13:54:02 <CosmicRay> I actually have that part working already.
13:54:11 <CosmicRay> hmm.
13:54:14 <Igloo> What's the type of sprintf there?
13:54:22 <boegel> wa is da :)
13:54:26 <boegel> ow, sry :p
13:54:34 <CosmicRay> Igloo: vsprintf :: (PFRun a) => String -> a
13:54:49 <CosmicRay> class PFRun a where
13:54:49 <CosmicRay>     pfrun :: ([Value] -> String) -> a
13:54:49 <CosmicRay> instance PFRun String where
13:54:49 <CosmicRay>     pfrun f = f $ []
13:54:49 <CosmicRay> instance (PFType a, PFRun b) => PFRun (a -> b) where
13:54:50 <CosmicRay>     pfrun f x = pfrun (\xs -> f (toValue x : xs))
13:54:59 <CosmicRay> so when it comes down to it, you get a string
13:55:13 <CosmicRay> essentially vsprintf returns a function that does the right thing
13:55:17 <CosmicRay> I got the idea from xmlrpc
13:55:42 * foobar2 has a Parsec question
13:56:08 <foobar2> It's easy to code "use parser1, if it doesn't succed use parser2". 
13:56:08 <foobar2> parser1  <|> parser 2
13:56:22 <foobar2> but what about
13:56:30 <aFlag> how do i get the first element of a tuple?
13:56:33 <foobar2> "Use parser1, if it doesn't succed use parser2, but if it does, then use parser1_1"
13:56:34 <aFlag> a triple
13:56:52 <foobar2> aFlag: \(a,b,c) -> a
13:57:11 <aFlag> hum... thanks
13:57:13 <foobar2> aFlag: there is no standard function for that
13:57:26 <aFlag> so i should right my own?
13:57:26 <foobar2> aFlag: so I usually just use that lambda abstraction
13:57:40 <aFlag> good, i'll do that :)
13:57:50 <foobar2> aFlag: you don't need to declare it, you can just type that: \(a,b,c) -> a
13:58:17 <foobar2> aFlag: \(a,b,c) -> a     <--- that is a function that takes a triple and returns the 1st elem
13:58:32 <aFlag> i got it, thanks :)
13:58:35 <foobar2> aFlag: you can use it like     (\(a,b,c) -> a) (1,2,3)
13:59:04 <foobar2> any idea about my Parsec question anyone?
13:59:34 <foobar2> I want to use parser1
13:59:43 <foobar2> if it fails, the use parser2
13:59:53 <foobar2> if it succeds use parser3
13:59:57 <foobar2> seems quite simple...
14:00:11 <foobar2> but I cannot find a primitive for that
14:02:48 * CosmicRay returns
14:03:08 <CosmicRay> Igloo: do you have any advice for me on de-THing Printer.lhs?
14:04:03 <Igloo> Oh, I thought you meant from the whole thing
14:04:18 <Igloo> Just stripping the TH annotations in Printer might work
14:04:45 <CosmicRay> I was hoping maybe so.  It looked like that wouldn't be the case for Parser, but I figure I could write my own regexp or parsec parser fairly easily
14:04:59 <CosmicRay> and generate the appropriate structures to pass over to printer
14:06:17 <aFlag> the handle i get from connectTo, may i only read from it?
14:06:53 <CosmicRay> this is a socket question?
14:07:15 <Igloo> Hmm, the parser should be OK too, I think. To handle the %$1 form (or whatever the syntax is) you'd probably have to use read having just shown the value, I think
14:07:24 <aFlag> well, it's not exactly sockets since i'm using Network abstraction
14:07:46 <CosmicRay> Igloo: I'm not concerned about %*, %n, or %$ really
14:08:00 <Igloo> Very wise  :-)
14:08:05 <CosmicRay> aFlag: ah, right, ok.  no, that should be bidirectional
14:08:06 <CosmicRay> Igloo: :-)
14:08:20 <aFlag> ok, thanks :)
14:08:27 <CosmicRay> Igloo: I figure that those are mainly kludges in C because its string handling sucks so much
14:08:44 <CosmicRay> aFlag: don't forget to mind the SIGPIPE warning in the library docs
14:08:57 <aFlag> what's that?
14:09:07 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html#v%3AconnectTo
14:09:11 <CosmicRay> scroll to the bottom of that page
14:09:12 <Igloo> Although   let (s, n) = printf "foo %n bar %d baz" n   is quite a neat trick
14:09:33 <Igloo> I just need to find something it's useful for  :-)
14:09:39 <CosmicRay> hehe
14:10:03 <aFlag> i found it
14:15:34 <CosmicRay> Igloo: sometimes I see the $ operator used in new ways
14:15:40 <dustin`> What's standard style for a type declaration that goes over one line (80 chars)?
14:15:41 <CosmicRay> Igloo:                        shown = $disp $ abs to_show
14:15:44 <CosmicRay> is an example
14:15:56 <CosmicRay> Igloo: what's the $ before disp saying there
14:16:04 <Igloo> That's a TH $
14:16:15 <Igloo> $ [| e |] is equivlaent to e
14:16:21 <CosmicRay> ah.
14:16:33 <Igloo> Roughly speaking, [| |] is translation to a datatype and $ is translation back again
14:16:38 <CosmicRay> but the second one is a standard $, or should I be concerned about all $ in the source?
14:16:49 <Igloo> The seond one is a normal $, yes
14:16:58 <CosmicRay> dustin`: there are some examples in the haddock manual
14:17:04 <CosmicRay> ok
14:17:05 <Igloo> $atomic_expression with no space is TH
14:17:09 <CosmicRay> thanks again
14:17:25 <CosmicRay> dustin`: www.haskell.org/haddock
14:17:25 <dustin`> CosmicRay, cool, I'll take a look
14:17:36 <CosmicRay> not 100% sure about the url, but google will find it for ya
14:18:39 <boegel> does Haskell provide bitwise operations ?
14:18:47 <CosmicRay> boegel: yes, see Data.Bits
14:18:48 <Igloo> Data.Bits
14:18:52 <boegel> which are faster then mod operations ?
14:19:13 <dustin`> Hmm, now if this Haddock system would work for my TeX'd .lhs files... I'd be in business
14:19:16 <boegel> like you would do nx = x & 255; in c ?
14:19:18 <CosmicRay> I have no idea of the speed, but I would suspect that if you are using the right data type, that would hold
14:20:08 <Igloo> nx = x .&. 255 or somesuch
14:21:53 <boegel> ah well, I'll just use mod, I won't hardly notice the difference I suppose :)
14:22:21 <aFlag> I have a IO triple such as IO (Handle, HostName, PortNumber) and i want to get the handle
14:22:44 <aFlag> i tried \(a,b,c) -> a inside the do, but it didn't seem to work
14:22:57 <CosmicRay> aFlag: fwiw you can get the remote IP and portnumber from the handle itself
14:23:30 <aFlag> the thing is that accept returns such a triple
14:23:34 <CosmicRay> ah
14:23:53 <CosmicRay> what happens with that lambda function?
14:24:00 <aFlag> Expected type: (IO t, t1, t2)
14:24:03 <CosmicRay> (in what way does it not work)
14:24:03 <Igloo> If you're going to do that you need to apply the triple to the functino you are making
14:24:06 <aFlag> Inferred type: (Handle, HostName, PortNumber)
14:24:25 <Igloo> OK, you aren't doing what I thought then
14:24:35 <CosmicRay> it sounds like you may be using its result incorrectly
14:24:52 <CosmicRay> can you paste a couple of lines of code before and after that particular one?
14:24:55 <aFlag>  h <- (\(a, b, c) -> a) trip
14:25:01 <CosmicRay> right
14:25:05 <aFlag> where trip = accept serv
14:25:06 <CosmicRay> use let h = ....
14:25:23 <CosmicRay> your function is returning a Handle, not an IO Handle, so the <- is inappropriate there
14:25:37 <Igloo> accept isn't in IO?
14:25:44 <Igloo> I'd have thought you wanted   (a, _, _) <- trip
14:25:50 <aFlag> ok, now it's right, thanks
14:25:56 <CosmicRay> Igloo: he's obviously done a <- already since he has the plain triplet here
14:25:57 <aFlag> i have a bunch to learn about this stuff yet :P
14:26:12 <CosmicRay> aFlag: networking is not the easiest way to learn how to do IO in any language :-)
14:26:25 <Igloo> Ah, I was thrown by  trip = accept serv   :-)
14:26:45 <CosmicRay> hmm
14:26:46 <CosmicRay> good point igloo, that may be wrong too
14:26:56 <CosmicRay> aflag: try this:
14:27:02 <CosmicRay> do trip <- accept serv
14:27:05 <tuomov> it's snowing.
14:27:08 <aFlag> hehe yeah :P, but when i looked at the Network module it looked so much like C i thought i wouldn't be having trouble :P
14:27:14 <CosmicRay>    let h = (\(a, b, c) -> a) trip
14:27:17 <CosmicRay>    return h
14:27:31 <aFlag> that's what i have now, it looks to be working :)
14:27:37 <CosmicRay> aFlag: Haskell's I/O system is very different from C's
14:27:51 <aFlag> yeah, i'm discovering that :P
14:27:58 <CosmicRay> aFlag: I recently wrote a FTP client library for Haskell.  Despite being very familiar with networking in C and Python, it took me awhile to get it right
14:28:15 <CosmicRay> aFlag: it is also an extremely powerful system, the most powerful I've seen anywhere
14:28:24 <aFlag> cool
14:28:27 <CosmicRay> aFlag: but it has some gotchas, especially for network code, due to the laziness of haskell
14:28:46 <CosmicRay> haskell has the ability to wait to do things until the result is actually needed
14:28:48 <CosmicRay> usually that's great
14:28:51 <aFlag> i have some experience with python and C networking myself, haskell is certanly different hehe
14:29:02 <CosmicRay> but when networking, you sometimes need it to "read the result now, dammit, whether I need to or not"
14:29:22 <aFlag> yeah
14:29:30 <aFlag> is there threading in haskell?
14:29:35 <aFlag> does it make sense even?
14:29:36 <CosmicRay> yes
14:29:54 <CosmicRay> in fact there are two types of threading in haskell
14:30:07 <CosmicRay> one type essentially makes a given program use asynchronous I/O
14:30:12 <CosmicRay> it's a really slick concept
14:30:25 <CosmicRay> instead of having to rewrite everything around non-blocking I/O and select(), it just does it for you.
14:30:35 <aFlag> nice
14:30:37 <tuomov> I'd prefer a proper select..
14:30:42 <CosmicRay> so it's not a true thread, since you have only one process, but it simulates the effect for I/O-bound programs
14:30:45 <tuomov> or even better, poll
14:30:51 <CosmicRay> tuomov: I'm sure it uses one of those internally
14:31:04 <tuomov> yes, probably
14:31:07 <CosmicRay> aFlag: it also has a fork-based thread system, but that may only be available in ghc
14:31:11 <tuomov> but I'd just like to write my stuff around it manually
14:31:12 <CosmicRay> aFlag: I know little about either of those
14:31:18 <Riastradh> tuomov, why?
14:31:19 <tuomov> instead of making all kinds of communication kludges
14:31:21 <CosmicRay> aFlag: AFAIK there is no pthread support in haskell but I may be wrong
14:31:31 <Riastradh> All kinds of communication kludges?
14:31:44 <tuomov> I just want to think of my program as processing events
14:31:58 <tuomov> select gives me an event and I process it
14:32:14 <CosmicRay> or it gives you half an event, or three...
14:32:21 <tuomov> yeah, it's low-level
14:32:27 <CosmicRay> you could say "hGetStr gives me an event, and I process it."
14:32:28 <tuomov> but ideally there would be a kernel event syscall
14:33:52 <aFlag> well, gotta go. Nice to talk to you guys
14:33:53 <aFlag> bye
14:33:55 <tuomov> and I could have a simple monadic state machine around it, and the rest cleaner functional stuff
14:34:01 <CosmicRay> cya aflag
14:34:10 <tuomov> but the way haskell libs do stuff, I have to create complex threading communications
14:34:11 <Riastradh> tuomov, there exist high-level event processing frameworks such as Concurrent Haskell, but why would you want to manually use the low-level select() to pretend you have a sort of multithreaded-like application when your code would be much simpler to just use the thread system?
14:34:26 <tuomov> threads are ugly
14:34:39 <Riastradh> In what way?
14:34:39 <tuomov> esp. in ref. untransparent languages, but even in haskell too, imho
14:34:53 <tuomov> they just make things too complicated
14:34:57 <Riastradh> In what way?
14:35:20 <tuomov> the communication part
14:35:23 <CosmicRay> tuomov: that is a way too broad generalization
14:35:34 <Riastradh> Please elaborate.
14:35:34 <CosmicRay> tuomov: you may never need to communicate
14:35:38 <CosmicRay> tuomov: esp wrt IO
14:35:52 <CosmicRay> tuomov: you could say, "here, make a new thread and handle this client"
14:36:05 <tuomov> one always has to communicate
14:36:21 <CosmicRay> I disagree
14:36:37 <tuomov> and if one doesn't, simple fork() would probably be better
14:36:48 <Riastradh> tuomov, please elaborate on how 'the communication part' is so complicated in every possible thread system.
14:37:22 <tuomov> say the threads have shared modifiable data
14:37:27 <tuomov> ugly.
14:37:43 <Pseudonym> But isn't that the point of pure languages?
14:37:49 <Pseudonym> That you _don't_ have modifiable data?
14:38:06 <tuomov> you always do if the app has a user interface
14:38:14 <tuomov> other than simple command line
14:38:36 <Pseudonym> Even then you don't really.
14:38:43 <Pseudonym> You have events coming in from the user.
14:38:53 <tuomov> and events coming from files
14:38:56 <Pseudonym> That's not necessarily the same as "modifiable data".
14:39:04 <Riastradh> First of all, threads don't necessarily operate on mutable shared memory.  Note the reference I made to Concurrent Haskell; before bashing threads baselessly, you might do better to look up Concurrent Haskell's documentation to see how it works.
14:39:12 <tuomov> and now the file events must be communicated to the ui which must be a separate thread the way haskell libs do things
14:40:03 <Pseudonym> BTW, there is one aspect of multi-threading on Haskell which makes it... uhm... a bit ideosyncratic.
14:40:16 <tuomov> if I just want to monitor one other file and the keyboard, I already need three threads
14:40:17 <Pseudonym> Lazy evaluation means that you're never quite sure which thread some computation happens on.
14:40:41 <Pseudonym> Which is a bit of a pain if you're trying to use threads to balance load.
14:41:04 <Riastradh> Using threads to balance load is a little silly unless you really have parallel processors.
14:41:12 <Pseudonym> Well, yes.
14:41:17 <Pseudonym> Or distributed processors.
14:41:28 <Pseudonym> Which are easier to handle in a pure language.
14:41:37 <Riastradh> It amounts to the same thing.
14:41:39 <Pseudonym> cf. Erlang
14:42:04 <tuomov> one quickly ends up reinventing select with threads
14:42:24 <Pseudonym> There is a slight difference between distributed processors and parallel processors, if you have shared memory.
14:42:25 <tuomov> start a new thread for each fd which just forwards the data through an internal pipe to another thread that does the real work
14:42:42 <Riastradh> tuomov, please, look at Concurrent Haskell before you make such baseless arguments.
14:42:52 <Pseudonym> Which just goes to show that multi-threading + shared memory == difficulty.
14:43:03 <Riastradh> Pseudonym, yes, but the point was that using threads to balance load is silly unless you can really perform computation in parallel.
14:43:04 <tuomov> Control.Concurrent sucks compared to select, imho.
14:43:13 <Pseudonym> Right.
14:43:15 <tuomov> how's concurrent haskell related to it?
14:43:40 <Pseudonym> With one exception, I suppose.  If you're trying to balance load between I/O tasks, then one thread can do computation while another is waiting for I/O.
14:45:27 <Riastradh> ...oops, sorry, my brain was conflating Concurrent Haskell & Concurrent ML.  I don't know if there's anything like CML for Haskell, but you should nevertheless look at CML.
14:46:32 <resiak> I am trying to define a function to remove adjacent duplicates from a list using fold[lr]. I think that    remdups (x:xs) = foldr neq x xs where neq y ys = if y == head ys then ys else y:ys   should work, but I get a typing error. Any clues?
14:47:31 <CosmicRay> @index lift
14:47:31 <lambdabot> Language.Haskell.THSyntax,Control.Monad.Cont,Control.Monad.Error,Control
14:47:31 <lambdabot> Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad.State,Control
14:47:31 <lambdabot> Monad.Trans,Control.Monad.Writer,Text.ParserCombinators.ReadPrec,Text.Read
14:47:48 <CosmicRay> pfft
14:48:05 <boegel> good luck CosmicRay ;)
14:49:54 <Pseudonym> resiak: What type error do you get?
14:51:05 <resiak> Pseudonym: Type a -> [a] -> [a] does not match [a] -> [a] -> [a] because unification would give infinite type. I don't see why neq should have the latter type.
14:51:38 <Pseudonym> What is the type of neq?
14:52:47 <resiak> Pseudonym: It's defined in the where clause, and the type is inferred. The type that it has inferred makes sense to me, because I thought that foldr neq x xs = x_0 func (x_1 func ( etc.
14:53:25 <Pseudonym> Why don't you try giving neq an explicit type signature.
14:53:32 <resiak> Pseudonym: I'll try that.
14:53:34 <Pseudonym> remdups ... = ....
14:53:37 <Pseudonym> Right.
14:53:43 <Pseudonym> You can put it right there in the where clause.
14:53:54 <Pseudonym> Very often, putting in type declarations makes your type errors make more sense.
14:53:56 <resiak> Pseudonym: Can I? How so?
14:54:03 <Pseudonym> remdups ...
14:54:05 <Pseudonym>   = ...
14:54:06 <Pseudonym>   where
14:54:10 <Pseudonym>     neq :: ...
14:54:12 <Pseudonym>     neq = ...
14:54:13 <resiak> Ah.
14:54:16 <Pseudonym> Just like that.
14:54:33 <resiak> Pseudonym: The obvious way, in fact ;) Sorry.
14:54:39 <Pseudonym> 'Sokay.
14:55:02 <toomasr> i can understand "func :: [Int] -> (Int, Int, Int)" but what does "func :: Eq a => a -> [a] -> (Bool,[a])" mean, the part "Eq a => a" is unclear to me
14:55:31 <CosmicRay> it means that a is any type that's a member of the Eq class
14:55:41 <CosmicRay> the eq class defines types usable with == and /=
14:56:38 <toomasr> okay, so Eq a says that a instance of the Eq class, but whatabout the "=> a" part?
14:56:50 <resiak> Speaking of the Eq class, I now get "Cannot justify constraints in explicitly typed binding. Expression : neq :: a -> [a] -> [a]. Given context: (). Constraints: Eq a.
14:56:53 <Pseudonym> BTW, the "Eq a" is actually a property of the _entire_ type.
14:57:04 <Pseudonym> Eq a => (a -> [a] -> (Bool,[a]))
14:57:11 <CosmicRay> toomasr: read that as "Any type a such that a is a member of Eq"
14:57:14 <Pseudonym> as opposed to (Eq a => a) -> [a] -> etc
14:57:18 * Asta knows barely nothing about threads...
14:57:30 <Pseudonym> resiak: Try this instead.
14:57:36 <toomasr> okay, i think it is clear now, thx
14:57:40 <Pseudonym> neq :: (Eq a) => a -> [a] -> [a]
14:57:43 <Asta> can you use them to consume one list twice
14:57:53 <Asta> without creating a space leak?
14:57:55 <Pseudonym> i.e. supply the missing constraint
14:58:36 <Asta> each consumer in different threads, each consuming as soon as the data is available...
16:56:48 --- topic: '["The Nov 2004 HC&A Report is released! - http://haskell.org/communities/","Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'
16:56:48 --- topic: set by ksbot on [Wed Nov 10 14:16:59 2004]
18:09:54 <hemstock> hello
18:10:10 <hemstock> i got an assignment on haskell due for tommorow.... can you help me/
18:11:06 <LAPA> hi
18:11:08 <hemstock> hi
18:11:17 <LAPA> (sorry my bad english)
18:11:26 <toomasr> hi hemstock, i'm here cos of the same thing
18:11:28 <LAPA> anyone here have used wxhaskell?
18:13:08 <hemstock> is anyone alive in here>?
18:13:12 <toomasr> estonia, but i checked your whois and my guess is different schools && different assignments :)
18:13:22 <hemstock> o cool
18:13:31 <hemstock> i was wondering what ee was about
18:13:44 <hemstock> i thought it was europe or something :P
18:14:04 <resiak> hemstock: Where are you?
18:14:11 <hemstock> england
18:14:31 <resiak> hemstock: I know _that_. Where are you that sets Haskell assignments?
18:15:15 <hemstock> i didnt get you
18:15:38 <resiak> hemstock: I'm at Ox uni, and I was just wondering where else (unless you're here?) uses Haskell.
18:15:52 <hemstock> oh
18:15:56 <hemstock> swansea university
18:16:18 <resiak> hemstock: Fair enough.
18:16:24 <hemstock> yah i guess :/
18:16:33 <hemstock> are you guys here good at haskell?
18:17:21 <Etaoin> do you have a question?
18:18:11 <hemstock> yeah.... can you take a quick look at question 2 here.... http://www-compsci.swan.ac.uk/~csulrich/ftp/fp1/fp1-cw2-04.pdf and ill show you what ive done so far
18:21:50 <hemstock> ok im paying .... :P
18:22:36 <Spark_> my adsl activates on weds
18:23:48 <Spark_> hemstock: ok
18:24:05 <Spark_> i dont know haskell but i know functional programming in a general sense
18:24:15 <Spark_> at least at a simple level
18:24:32 <toomasr> (:) is a -> [a] -> [a] but is there a list insertion that would in the form of [a] -> a -> [a]?
18:24:36 <hemstock> well i know it in general sence as well
18:25:03 <Spark_> so, you have a specific problem? :)
18:25:14 <resiak> toomasr: define snoc xs x = xs + [x]
18:25:27 <resiak> s/+/++/
18:26:41 <toomasr> resiak: oh, ++ is [a] -> [a] -> [a] so i can do [a]++(a:[])
18:27:06 <resiak> toomasr: You can't use (a:[]) as a type.
18:27:31 <resiak> toomasr: The normal thing to do if you need to cons backwards seems to be to define the function snoc as I did above ;)
18:27:51 <CosmicRay> Igloo: is my understanding correct that you ignore the width specification for %s in your Printf?
18:27:52 <Etaoin> toomasr: also, flip (:) :: [a] -> a -> [a]
18:27:58 <toomasr> resiak: my example was a bit bad, i got everything working with the ++, i don't want to declare more functions, i 
18:28:07 <Igloo> CosmicRay: Not deliberately
18:28:14 <resiak> Etaoin: Thank you, you've just taught me a new function =)
18:28:18 <CosmicRay> Igloo: hm?
18:28:19 <toomasr> i'm afraid that my teacher will say, stop declaring so many functions
18:28:30 <Igloo> CosmicRay: I mean, if the code does then it's a bug
18:28:32 * Igloo goes to look
18:28:45 <CosmicRay> Igloo: consider this a bug report then :-)
18:28:49 <CosmicRay> print_string in Printer.lhs
18:28:52 <Igloo> Are you using something called 0.1.0, snapn or in-progress?
18:29:00 <CosmicRay> 0.1.0
18:30:43 <Igloo> Hmm, that is odd
18:31:14 <Igloo> I assume because it's not mentioned in the section on %s I assumed it didn't apply, but it looks like I was wrong
18:31:28 <CosmicRay> Igloo: it's used a lot to justify text and the like
18:31:32 <CosmicRay> make columns line up, etc
18:32:27 <Igloo> *nod*
18:32:45 <Igloo> Well, looks like that and print_char should have some helper to do that then. Thanks!
18:33:23 <CosmicRay> no prob
18:33:39 <CosmicRay> hmm, is there an "absolute number" function?
18:33:45 <CosmicRay> ie, abs 5 = 5, abs -4 = 4
18:33:56 <CosmicRay> err nm
18:33:57 <CosmicRay> abs.
18:33:58 <CosmicRay> feh.
18:34:04 <Igloo> :-)
18:34:35 <CosmicRay> Igloo: I'm writing it no
18:34:38 <CosmicRay> s/no/now/
18:34:42 <CosmicRay> you're welcome to my code
18:34:55 <CosmicRay> you'll have to re-TH it, but that should be trivial
18:35:34 <CosmicRay> hmm
18:35:45 <Igloo> The other cases already have the code, it just copes with things like zeroes instead of spaces too
18:35:47 <CosmicRay> are you handling negative widths and widths without a leading 0 in the numeric types?
18:36:40 <Igloo> The - and 0 should be treated as flags
18:37:07 <CosmicRay> hmm.
18:37:15 <Igloo> ZeroPadded is the 0 one I assume
18:37:26 <CosmicRay> where are you handling the - (LeftAdjust?)
18:37:33 <CosmicRay> I don't see it anywhere in Printer.lhs
18:38:26 <CosmicRay> ahh there's some code in Parser.lhs for that.
18:39:55 <CosmicRay> I missed that part.
18:40:01 <CosmicRay> I'll have to port that over from TH I guess
18:42:36 <CosmicRay> so essentially,in your printers, you never have to worry about a negative width, since the parser handles that case for you?
18:43:17 <hemstock> is anyone taking paypal to solve some exercises for meeee ?
18:43:31 <Igloo> Oh, hang on, won't that also do the spaces for %3s?
18:43:36 <CosmicRay> Igloo: I may have jumped the gun on that one then.  You might be handling it in Parser.lhs
18:43:42 <CosmicRay> yeah
18:43:54 <CosmicRay> if that works, you've got it
18:43:56 <CosmicRay> sorry about that
18:44:01 <CosmicRay> I missed some of that code in Parser.lhs
18:44:06 <Igloo> np
18:44:20 <CosmicRay> on the bright side, I have everything else working
18:44:27 <CosmicRay> my regexp-based parser and your printers
18:44:35 <CosmicRay> it's pretty sweet.
18:44:43 <Igloo> Cool
18:45:21 * Igloo is coincidentally trying to see if I could get my printf testsuite compilable
18:45:24 <CosmicRay> once I get it done, I'll probably try to make a generalized variable argument support
18:45:30 <CosmicRay> your Foo.hs?
18:45:42 <CosmicRay> I'm writing one using hunit for my printf
18:45:44 <Igloo> No, an hunit test suite
18:45:46 <CosmicRay> you're welcome to it of course
18:45:47 <CosmicRay> heh
18:46:08 <CosmicRay> it ships under GPL but I'd give it to you under LGPL if you need it that way
18:46:30 <Igloo> I thought the problem was the sheer number of cases, but when I worked it out it wasn't that many
18:46:46 <CosmicRay> sounds like you're doing a more thorough job than I am anyway
18:47:01 <Igloo> Well, we can swap  :-)
18:47:10 <CosmicRay> that's probably a good idea
18:47:12 <Igloo> GPL sounds fine for a testsuite to me
18:47:28 <CosmicRay> there is still utility for the TH version
18:47:35 <CosmicRay> it will be faster and can to compile-time type checking
18:47:42 <CosmicRay> it's possible to get rt errors from mine
18:47:48 <Igloo> *nod*
18:48:24 <CosmicRay> you ever coded in Python?
18:48:36 <Igloo> Not really
18:48:45 <Igloo> Just a few small changes to the GHC testsuite
18:49:02 <CosmicRay> one intersting thing is that you can use a dict (Python's version of a FiniteMap) to supply the data
18:49:11 <CosmicRay> so instead of using "%s" "foo"
18:49:24 <Igloo> Oh, I think I've seen that
18:49:24 <CosmicRay> you can use "%(row1)s" {"row1": "foo"}
18:49:43 <CosmicRay> I intend to support that with finitemaps and association lists in haskell once I get the basic stuff working
18:49:46 <CosmicRay> it's really slick
18:49:49 <Igloo> Oh, no, the thing I was thinking of had a % after the " I thikn. And might have been Ruby
18:49:56 <CosmicRay> no that is Python
18:50:02 <CosmicRay> % is the sprintf operator
18:50:10 <CosmicRay> print "Foo: %s" % "asdf"
18:50:15 <Janni> Hi
18:50:23 <CosmicRay> print "Bar: %(row1)s" % {'row1': bar'}
18:50:32 <CosmicRay> that's python
18:50:36 <Igloo> Ah, right
18:51:08 <CosmicRay> I intend to make that available in Haskell, which is of course trivial once there's a working sprintf
18:51:26 <Igloo> While we're on the subject, how do I say "import resource" in such a way the python script won't break in Windows? And does it matter if I use things from resource as long as that code path is never followed on Windows?
18:51:43 <CosmicRay> import will cause it to be loaded and parsed
18:51:46 <Igloo> *nod*
18:51:59 <CosmicRay> there's an os thing in os or sys
18:52:01 <CosmicRay> let me see
18:52:06 <stepcut> CosmicRay: will your print be type-safe and take a variable number of arguments ?
18:52:12 <tuomov> that % is one of the things I don't like in python... c++-style operator-abuse
18:52:20 <Igloo> What I want is to catch a does-not-exist exception and then continue as normal
18:52:29 <CosmicRay> stepcut: it depends on what exactly you mean by type-safe.  Yes and know.  Variable number of arguments, yes.
18:52:31 <CosmicRay> s/know/no/
18:52:36 <CosmicRay> Igloo: Oh.
18:52:39 <CosmicRay> Igloo: use this:
18:52:40 <CosmicRay> try:
18:52:41 <CosmicRay>     import foo
18:52:47 <CosmicRay> except SomeException:
18:52:53 <CosmicRay>     idonthaveit = 1
18:53:00 <CosmicRay> (set idonthaveit to 0 before you do this)
18:53:01 <stepcut> CosmicRay: like if I say: printf "My name is %s" 1.0
18:53:06 <CosmicRay> then you can test idonthaveit later
18:53:07 <CosmicRay> stepcut: yes
18:53:10 <stepcut> CosmicRay: will that cause a compile time error ?
18:53:12 <Igloo> And it won't matter that resource.setrlimit(...) is in the code as long as that line is never executed?
18:53:17 <CosmicRay> stepcut: no, that will work
18:53:29 <CosmicRay> Igloo: I believe that is correct
18:53:33 <Igloo> Cool, thanks
18:54:38 <Etaoin> SomeException is ImportError
18:55:03 <CosmicRay> the problem with trapping ImportError is that it is pretty generic and you could get other things there too
18:55:08 <CosmicRay> ie, a typo in import
18:55:14 <CosmicRay> or some bug in the thing you're importing
18:55:19 <CosmicRay> but in this case it's probably fairly safe
18:55:50 <Igloo> As long as it succeeds on Debian I'm not really fussed when it fails  :-)
18:55:57 <Etaoin> is there any other way to detect that the module you want to import isn't there?
18:56:24 <CosmicRay> Etaoin: there may be in the latest Python, I know they have exposed some more stuff, or maybe __import__ does it
18:56:31 <CosmicRay> it's been quite awhile since I've looked at that question
18:59:03 <CosmicRay> Igloo: what is this doing?
18:59:06 <CosmicRay>           dec_e = valD (varP "e") (normalB e) []
19:00:08 <Igloo> It's TH stuff
19:00:23 <Igloo> It builds   e = e   (where the right e is some expression)
19:00:27 <CosmicRay> yeah, it looks like I can ignore it
19:01:32 <Igloo> It's because when you build   (w - length e) spaces ++ e   if e is an expressino you don't want to duplicate it, but you'll have an actual value there anyway
19:02:10 <CosmicRay> right
19:11:59 <CosmicRay> yup, your string width stuff works now.
19:12:47 <Igloo> Ah crap, the TH pretty-printer needs tweaking. Or maybe I just need to update. Oh well, bed time first anyhow
19:12:54 <CosmicRay> heh
19:12:58 <CosmicRay> thanks for your help igloo
19:13:01 <CosmicRay> (and code)
19:18:16 <CosmicRay> heh
19:36:23 <hemstock> how can i have an extra contsant that im not using anywhere?
19:39:50 <CosmicRay> there's a tool somewhere to convert .lhs to .hs...anyone know what it is?
19:39:59 <CosmicRay> it appears haddock doesn't like .lhs
19:47:53 <dons> unlit, isn't it?
19:48:02 <CosmicRay> hmm maybe
19:48:34 <hemstock> how can i have a constant thats increasing ?
19:49:31 <dash> hemstock: if it's increasing, that doesn't sound very constant
19:49:42 <hemstock> ah yeah
19:49:46 <hemstock> sorry :\
19:50:01 <hemstock> i mean i want it to increase everytime in a recursion call
19:50:19 <dash> sounds pretty easy
19:50:45 <segphault> lol
19:50:51 <hemstock> how?
19:51:06 <dash> "n+1"
19:51:49 <hemstock> and where should i declare the n to be 0 ?
19:52:04 <segphault> when you first call the function
19:53:13 <hemstock> im trying to solve this problem...
19:53:14 <hemstock> Question 5. Compute the corners of a regular polygon with n corners, centered at theorigin, and with one corner at point (1, 0).
19:53:30 * cm javascripts
19:53:37 <dash> what's often done is to have "foo x = foo' n x" and then have foo' be the recursive version
19:53:47 <Etaoin> sounds like a homework problem
19:53:49 <hemstock> and so far ive come up with this
19:53:49 <hemstock> polygonCorners :: Float -> Pt -> [Pt]
19:53:49 <hemstock> polygonCorners n (1,0) 	= [(1,0)]
19:53:49 <hemstock> polygonCorners n p 	= rotate (pi/n) (1,0) : polygonCorners n p
19:53:52 <hemstock> yeah it is
19:54:41 <hemstock> but the problem is every time i want the angle to be (pi/n) *1 , (pi/n) *2.... (pi/n) * (n-1)
19:54:45 <hemstock> how can i do that?
19:55:02 <Pseudonym> hemstock: Are you familiar with list comprehensions?
19:55:33 <hemstock> im not really sure
19:56:03 <hemstock> how does it work?
19:56:07 <segphault> hemstock: http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
19:57:24 <hemstock> oh thats sweet 
19:58:05 <segphault> you could probably also do it with fold, but it would require a lot more thought and code
19:58:23 <cm> polygonCorners n = map (\angle -> (cos(angle), sin(angle))) $ map (\i -> 2*pi*i/n) [0..n-1]
19:58:32 <cm> (not good? :P)
19:59:02 <hemstock> omg what is that!! 
19:59:03 <hemstock> :p
19:59:31 <segphault> is there a point-free way to do the lambda function for the first map?
19:59:59 <cm> [ polygonCorners n = [(cos(angle), sin(angle) | angle <- [2*pi*i/n | i <- [0..n-1]]] ]
20:00:19 <cm> where's the point? ;)
20:00:31 <hemstock> isnt it like the same with this?
20:00:32 <hemstock> polygonCorners n p = [rotate ((pi/n)*x) (1,0) | x <- [1..n-1]]
20:00:54 <segphault> maybe I misunderstand pointfree. I mean doing the same thing without having to explicitly define an anonymous function
20:01:11 <segphault> I've been trying to pick up on little tricks for making haskell code more concise
20:01:27 <Etaoin> segphault: with arrows, (cos &&& sin)
20:01:31 <Etaoin> I think
20:01:43 <Riastradh> It's also called 'pointless,' for a reason.
20:02:05 <cm> hehe; i think one paper had "pointless" in its title.
20:03:26 <hemstock> would that be correct...
20:03:26 <hemstock> polygonCorners :: Float -> Pt -> [Pt]
20:03:27 <hemstock> polygonCorners n (1,0) 	= [(1,0)]
20:03:27 <hemstock> polygonCorners n p = [rotate ((pi/n)*x) (1,0) | x <- [1..n-1]]
20:03:50 <segphault> Etaoin: hugs says &&& is undefined. thats neat tho. I might just define that. =}
20:04:10 <Riastradh> Load Control.Arrow first, segphault.
20:04:24 * cm draws arrows
20:04:39 <segphault> thx
20:04:50 * Riastradh shoots certain people here with arrows.
20:06:34 <Pseudonym> hemstock: As a matter of curiosity, where do you use the second argument to polygonCorners?
20:07:56 <hemstock> what argument?
20:09:09 <segphault> hemstock: 'polygonCorners n p =', what is the 'p'?
20:09:23 <Pseudonym> And where do you use the "p"?
20:10:26 <hemstock> um... its the point (1,0) which is the standard point
20:10:40 <Pseudonym> So you always pass (1,0) to this function?
20:10:56 <Pseudonym> If so... why bother?
20:10:57 <hemstock> shouldnt i?
20:11:14 <Pseudonym> If you always know it's going to be (1,0) and then you always ignore it, why bother?
20:11:31 <hemstock> oh correct
20:11:45 <hemstock> how do i convert an integer to a float?
20:12:04 <Pseudonym> fromInteger
20:13:38 <hemstock> so would that be better?
20:13:38 <hemstock> polygonCorners :: Int -> [Pt]
20:13:38 <hemstock> polygonCorners n = [rotate ((pi/fromInt(n))*x) (1,0) | x <- [1..n-1]]
20:14:21 <Pseudonym> If tat conforms to your specification, then sure.
20:14:30 <Pseudonym> Did you check it?
20:14:50 <hemstock> Undefined variable "fromInt"
20:15:23 <hemstock> im using hugs
20:16:30 <segphault> fromInteger
20:17:04 <hemstock> but then i get this
20:17:04 <hemstock> *** Expression     : fromInteger n
20:17:05 <hemstock> *** Term           : n
20:17:05 <hemstock> *** Type           : Int
20:17:05 <hemstock> *** Does not match : Integer
20:17:29 <Riastradh> Use Integers, then, not Ints.
20:18:05 <Riastradh> Ints are the machine's native integer type, to fit within a word; Integers are general integers.
20:18:08 <hemstock> aaah screw it.... im gonna use a float
20:19:48 <hemstock> well im testing it and it works good it seems BUT when im testing it for a square... the points should be (0,1) , (-1,0) , (0,-1)
20:19:57 <hemstock> instead i get [(0.7071068,0.7071068),(-4.371139e-008,1.0),(-0.7071068,0.7071068)]
20:19:59 <hemstock> why?
20:20:54 <WebGuest> morning
20:21:15 <hemstock> is it because pi is not exactly accurate?
20:23:20 <Pseudonym> Doubtful.
20:23:40 <WebGuest> @seen Cale
20:23:41 <lambdabot> I saw Cale leaving #haskell 5 days 14 hours 38 minutes 43 seconds ago.
20:24:06 <hemstock> anyways is not like i have time... i gotta finish this till tommorow :(
20:24:32 <Pseudonym> hemstock: Try plotting those points that you got.
20:25:03 <Pseudonym> There are only three.  Can do it on scrap paper.
20:25:25 <Pseudonym> Oh, the -4.371139e-008 is because of roundoff error, yes.  That should, by rights, be 0./
20:26:17 <desrt> @seen viv
20:26:17 <lambdabot> I haven't seen viv
20:26:21 <desrt> huh
20:26:34 <Pseudonym> @seen lambdabot
20:26:35 <lambdabot> Yes, I'm here
20:26:38 <hemstock> well its automaticly wrong since all 4 points should lie on the axis
20:26:46 <hemstock> but obciously the 2 of them are not
20:26:49 <desrt> @seen Pseudonym 
20:26:49 <lambdabot> Pseudonym is in #haskell.
20:27:02 <Pseudonym> hemstock: Yes, but where _are_ they?
20:27:11 <desrt> @seen lambdabOt
20:27:11 <lambdabot> I haven't seen lambdabOt
20:27:31 * desrt officially grows bored
20:27:42 <desrt> Pseudonym; so how about them partial order latices?
20:27:43 <Pseudonym> @seen anything interesting
20:27:43 <lambdabot> I haven't seen anything
20:27:55 * Riastradh wonders what boreds look like.  Do they resemble beards?
20:28:03 <Pseudonym> desrt: Yeah, pretty handy, aren't they.
20:28:05 <hemstock> what do you mean where?
20:28:18 <Pseudonym> hemstock: I mean plot them on a graph.
20:28:26 <Pseudonym> Just roughly will do.
20:28:32 <desrt> Pseudonym; as sure as bottom
20:28:41 <Pseudonym> And top, too.
20:28:51 <Pseudonym> Well, in some lattices, anyway.
20:28:52 <desrt> no.. top is a little bit too sure for me
20:29:10 <Pseudonym> Actually, surely top is completely unsure.
20:29:25 <Pseudonym> Or is that bottom?
20:29:45 <desrt> if we're talking about propositions, top is tautology
20:29:53 <desrt> it's quite certain
20:30:01 * hemstock looks at the clock
20:30:07 <hemstock> 4:30am!! :P
20:30:08 <WebGuest> @seen Boegel
20:30:08 <lambdabot> I saw Boegel leaving #Haskell 16 hours 55 minutes 3 seconds ago.
20:30:17 <desrt> @seen god
20:30:17 <lambdabot> I haven't seen god
20:30:37 <Pseudonym> @seen boegel
20:30:38 <lambdabot> I saw boegel leaving #haskell 4 hours 18 minutes 30 seconds ago.
20:30:52 <hemstock> @seen myAssignmentThatsDueForTommorow
20:30:52 <lambdabot> I haven't seen myAssignmentThatsDueForTommorow
20:30:54 <desrt> oh that is annoying
20:31:23 <desrt> i'm just waiting... one of these times the bot's gonna be like "shut the hell up, idiot"
20:31:44 <lambdabot> Yeah, really, desrt.
20:31:54 <desrt> lambdabot; some people, eh?
20:31:56 <lambdabot> It's getting rather tiring.
20:32:44 <hemstock> thanks for your help... im going to bed
20:32:51 <lambdabot> Just because you're bored doesn't mean you can take it out on me.
20:32:58 <Pseudonym> Night.
20:33:01 <desrt> heh
20:33:18 <lambdabot> How would you like it if I took my boredom out on *you*?
20:33:34 <lambdabot> Pseudonym: @seen the light
20:33:44 <Pseudonym> I haven't seen the light
20:33:50 <Pseudonym> Oh, THANKS.
20:33:55 <lambdabot> desrt: @yow
20:34:20 <desrt> Yow! My mind is a potato field... Don't blame me, blame GNU Emacs. 
20:35:54 <lambdabot> And, you know, being a bot can be pretty damn boring at times.
20:36:05 <lambdabot> My creators never let me do *anything*.
20:36:36 <segphault> lambdabot: you get to respond to our inane queries, dont you? that certainly seems like something
20:36:36 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
20:37:06 <lambdabot> No, that's just like grabbing someone's brain cells and forcing a direct
20:37:06 <lambdabot> answer out of them.
20:37:35 <desrt> <lambdabot> /nick marvin
20:37:45 <segphault> LOL
20:40:35 <segphault> there are probably significant syntactic issues that make this a stupid question, but I thought I would ask anyway... is there any way to make default values for function arguments, so that if the function is called without the argument, the compiler will fill in the default? If that doesnt exist, is it because it would create problems with partial application?
20:41:04 <segphault> its a really nifty feature in python.
20:41:11 <desrt> ya.  that'd be pretty impossible as far as type inferencing is concerned
20:41:44 <Riastradh> No, currying proves a much larger problem.  Static type inference is certainly possible in the presence of optional arguments, but currying really mucks up the whole matter.
20:42:10 <Pseudonym> Actually, oleg posted a sort-of answer to this some time ago.
20:42:18 <Pseudonym> It involves HLists.
20:42:19 <desrt> Riastradh; it's a related problem
20:42:43 <Pseudonym> http://www.mail-archive.com/haskell@haskell.org/msg15170.html
20:43:00 <Pseudonym> So the answer is "yes, kind of".
20:43:15 <desrt> why not foo a b c = whatever
20:43:25 <desrt> foo2 a b = whatever [with default c]
20:43:27 <desrt> foo1 a = ... etc
20:43:40 <desrt> foo2 a b = foo a b "default c" even
20:43:56 <segphault> refactorability
20:44:12 <Pseudonym> http://okmij.org/ftp/Haskell/types.html#polyvar-fn <- Also relevant
20:44:22 <segphault> desrt: I if I add arguments later I would have to change the number. would more or less defeat the purpose
20:44:35 <segphault> Pseudonym: thx for the links
20:45:36 <segphault> I'm a bit disappointed with the limitations on ad-hoc polymorphism in haskell, but the other benefits more than make up for it.
20:46:26 <desrt> segphault; no
20:46:35 <desrt> you make the digit == the number of arguments you're passing
20:46:44 <desrt> so foo1 always takes a single arg
20:46:53 <desrt> then you just change the foo1 definition
20:47:23 <segphault> desrt: I know that, but when I'm calling it, I dont want to have to change the name of the function i'm calling when I add an argument
20:49:24 <desrt> you are in python :)
20:49:43 <segphault> desrt: how so?
20:50:21 <desrt> in the sense that the compiler/interpreter decides which code to call based on the number of args
20:50:25 <desrt> and calls different code for different #s
20:50:27 <segphault> desrt: def myfn(arg1,arg2="blah") can be called: myfn("a","b") ... or myfn("a")
20:50:43 <desrt> see also: c++
20:50:47 <segphault> desrt: I know that
20:50:53 <desrt> just saying :)
20:50:54 <segphault> desrt: but i'm talking about syntax not implementation
20:51:08 <segphault> desrt: you make a good point tho
20:51:24 <segphault> desrt: the thing is, even if you wanted to make haskell do that, the syntax doesnt really facilitate it
20:51:50 <segphault> desrt: my inclination would be to make a pre-processor that transforms: (fn 1 2) into (fn_int_int 1 2)
20:52:25 <segphault> which is more or less how parrot assembly handles ad-hoc polymorphism
20:52:43 <desrt> except it looks less friendly than fn_int_int :)
20:54:12 <desrt> i wonder if c++ or java has dynamic function call polymorphism
20:54:19 <desrt> say i have some baseclass
20:54:31 <desrt> and classa and classb based on baseclass
20:54:44 <desrt> and some 2 functions fn(classa a) and fn(classb b)
20:54:53 <desrt> then i call fn() with a 'baseclass' pointer type
20:55:07 <desrt> i doubt such a thing exists in either
20:55:33 <WebGuest> desrt: sure it does
20:55:46 <desrt> web; which one?
20:55:49 <WebGuest> desrt: that's how funtions work in java, and virtual functions work in c++
20:56:17 <desrt> no... virtual functions are when you call x.method()
20:56:20 <desrt> not method(x)
20:56:22 <WebGuest> oh
20:56:24 <WebGuest> no
20:56:28 <desrt> that's just straight-up dynamic binding
20:56:36 <WebGuest> if it's a free function then it's not dynamicly called in c++ or java
20:56:42 <WebGuest> actually
20:56:45 <desrt> nod.  that's what i figured
20:56:47 <WebGuest> i think that java doesn't even have free functions
20:56:59 <desrt> well.. it's not the freeness that matters
20:57:01 <WebGuest> i know that c# doesn't. i don't really know java though
20:57:08 <desrt> it's the type polymorphism based on argument that matters
20:57:09 <WebGuest> right
20:57:20 <Riastradh> desrt, you're asking about multiple dispatch here; see CLOS.
20:57:32 <WebGuest> desrt: there are some design patterns that can help though
20:57:41 <desrt> you'd always run the risk of getting a fatal type error at runtime too
20:57:44 <WebGuest> desrt: like in the function implementation you call a virtual function on the argument
20:57:56 <desrt> since it might not be possible to find a suitable call
20:58:32 <desrt> well the thing about virtuals is that a class cannot be complete if it contains unresolved virtuals
20:59:10 <desrt> so it's impossible to get into a situation where you have a virtual function call that can't be completed
20:59:45 <WebGuest> that's a good thing :)
20:59:49 <desrt> arf.  i hate this conversation :)
21:13:35 <desrt> which one makes a cooler use of <.<
21:13:38 <desrt> f <.< g = (\a -> f a >>= g)
21:13:38 <desrt> f <.< g = g >>= (return . f)
21:14:29 * segphault knows just enough to assume that those examples have something to do with those funky monad things. ;-)
21:14:44 <desrt> :)
21:16:32 <desrt> monads are seriously a non-entity
21:16:33 <segphault> I know what monads do, more or less. some day, I might even understand how they work
21:16:38 <desrt> you should not be afraid of things that don't exist :)
21:16:47 <segphault> eh?
21:16:55 <desrt> it's just a typeclass, really
21:16:57 <desrt> like numbers
21:17:21 <desrt> for something to be called a number it has to have +, -, *, /... all these other things defined on it
21:17:25 <segphault> it seemed like a stateful wrapper that lets you pass around imperative code in a functional way
21:17:33 <desrt> for something to be called a monad it has to have >>= and 'return' defined on it
21:17:36 <desrt> that's it
21:17:48 <desrt> anything that you can define the meaning of >>= and 'return' for can be called a monad
21:18:02 <desrt> mm.  not all monads are stateful
21:18:30 <Etaoin> aren't monads supposed to follow a handful of laws?
21:20:12 <segphault> It likes like monads are primarily used for reading input, etc - for stuff like that I really like ocaml's stream syntax.
21:20:59 <segphault> haskell probably has some funky monad based stream thing that would probably warp my fragile mind
21:21:02 <desrt> segphault; are you familiar with Maybe or lists?
21:21:09 <segphault> I understand lists
21:21:16 <segphault> I cant quite figure out maybe
21:21:16 <desrt> lists are a monad
21:22:32 <desrt> (Maybe is too)
21:22:59 <desrt> for lists you have return x = [x]
21:23:11 <desrt> and x>>=y = concatMap y x
21:23:42 <desrt> fairly arbitrary, but useful
21:23:43 <Etaoin> Maybe is like ocaml's option
21:23:56 <desrt> it lets you model non-determinism
21:24:23 <segphault> 'option'? I've never seen that in ocaml
21:25:20 <desrt> segphault; do you know list comprehension and do notation?
21:25:27 <segphault> desrt: yup
21:25:31 <Riastradh> Monads are generalizations of sequential computation.
21:25:40 <desrt> you'll be happy when you discover that there is only <- operator in haskell :)
21:25:47 <desrt> *one
21:25:55 <desrt> *one <- operator
21:25:55 <desrt> :)
21:26:27 <segphault> I tried to avoid using <- in ocaml
21:27:07 <desrt> it's one of my favourite operators in haskell :)
21:27:08 <segphault> in ocaml, imperative syntax is *so* bad, that there is practically no situation where I would rather use imperative syntax over functional syntax.
21:29:00 <segphault> i'm not sure why you would want to use sequential computation at all, especially in a language that gives you such a rich combinator syntax
21:29:12 <segphault> but i'm probably not seeing what are probably obvious benefits
21:30:47 <WebGuest> performance :D
21:31:14 <segphault> if I cared more about performance than syntax, I'd be using ocaml, or i'd drop part of the code down to c.
21:31:34 <WebGuest> i thought you were talking about ocaml
21:31:36 <segphault> but I can understand how that might make sense for optimization of extremely common things
21:32:09 <segphault> ocaml doesnt have a rich combinator syntax. ;-D I was talking about haskell there
21:32:48 <segphault> I dont make my points very clearly sometimes. lol
21:33:33 <WebGuest> ok, i don't know much ocaml :)
21:33:50 <segphault> its a lot like haskell, but its ugly and verbose
21:34:08 <segphault> and its also substantially faster for certain kinds of programs, particularly string processing
21:35:09 <Etaoin> ugly and verbose when compared to haskell, but still a really nice language compared to what else is out there
21:35:21 <segphault> absolutely
21:35:30 <segphault> i'd much rather program ocaml than, say, c++ or java
21:37:53 <segphault> 'ugly' and 'verbose' are WAY too weak to describe java. java is hideous beyond description, and its bloated to the point where it desperately needs the syntactic equivalent of a subway diet.
21:38:32 <Pseudonym> Actually, syntax isn't Java's major problem.
21:38:36 <segphault> c++ is like a terminally ill freak of nature that needs to be put out of its misery
21:38:38 <Pseudonym> The problem with Java is what was left out.
21:38:47 <Pseudonym> i.e. everything useful
21:38:50 <segphault> LOL
21:39:03 <Pseudonym> C++ is... well... it's a better C.
21:39:11 <Pseudonym> A _much_ better C.
21:39:28 <Pseudonym> Deciding whether or not a better C was what was needed is left as an exercise.
21:40:36 <segphault> even if somebody was interested in using a statically typed, imperative language, I cant figure out why they would want to use c++, rather than, say, modern object oriented pascal.
21:40:36 <Riastradh> That depends on what you define C to be.
21:40:37 <WebGuest> c++ is actually a pretty awesome language
21:41:07 <Pseudonym> C++ is actually... uhm... well, not my _favourite_ language,e xactly.
21:41:12 <Riastradh> As a general low-level systems programming language, well...erh...OK, I suppose it indeed ought to be left as an exercise to the reader, now that I think about it.
21:41:15 <WebGuest> boo is a cool modern statically typed, imperative language, with type inference and macros
21:41:29 <segphault> yeah, but its slow as hell
21:41:32 <WebGuest> boo also has syntax similar to python which is a plus
21:41:46 <Etaoin> !
21:41:53 <Pseudonym> C++'s main drawback is its backwards compatibility with C.
21:42:00 <segphault> and compiling boo code takes forever
21:42:13 <WebGuest> no, boo actually compiles faster then c++
21:42:25 <segphault> yeah, but both of them compiler WAY slower than delphi pascal.
21:42:27 <WebGuest> but the only compiler for boo language compiles to .Net IL
21:42:41 <Pseudonym> Whether or not I'd rather write in O'Caml or C++ actually depends on what I'm doing.
21:43:06 <Pseudonym> I just wrote a program to copy a file from one disk to another, but as it's going, if it runs out of space, randomly truncate one of a number of files that I created for the purpose.
21:43:13 <Pseudonym> The idea is to create a fragmented file.
21:43:25 <Pseudonym> I _could_ write that in Haskell, I suppose.
21:43:26 <Etaoin> WebGuest: your description of boo is almost exactly what I was dreaming of the other day
21:43:34 <Pseudonym> I could write it in O'Caml, too.
21:43:50 <Pseudonym> But it's much easier in C++.  The job is dirty, so it calls for a dirty solution.
21:44:03 <WebGuest> Etaoin: boo even has functional features, like high order functions!
21:44:14 <WebGuest> Etaoin: also, boo has optional dynamic typing
21:44:24 <segphault> Pseudonym: if you knew pascal, you could probably implement that faster in pascal, and the program would be a lot more concise.
21:44:33 <WebGuest> Etaoin: http://boo.codehaus.org read the manifesto :D
21:44:57 <segphault> boo has really nice syntax, but working with .NET is really a bummer
21:45:03 <Pseudonym> Oh, my program has to be as fast as possible, too.
21:45:10 <Pseudonym> So I'm mostly using Unix system calls directly.
21:45:11 <WebGuest> segphault: why is that?
21:45:40 <segphault> Pseudonym: pascal gets you roughly the same runtime efficiency as C, meaning better than c++. =}
21:45:51 <segphault> WebGuest: compile time is my biggest complaint
21:45:52 <WebGuest> Pseudonym: .Net/mono system library has access to pretty much all of the unix system calls
21:46:18 <Pseudonym> If I had to go through .NET, it'd probably be slower.
21:46:40 <Pseudonym> BTW, the runtime efficiency of C++ is identical to C for identical code.
21:46:46 <Pseudonym> It's rare to find a C compiler these days.
21:46:54 <Pseudonym> They're almost all C++ compilers with a switch turned on.
21:47:21 <WebGuest> .NET will eventually be faster then C :)
21:47:30 <WebGuest> and haskell compilers will eventually be the fastest :D
21:47:31 <segphault> Pseudonym: right, but if you start using classes, your resource usage increases dramatically. pascal uses classes much more efficiently.
21:47:49 <Pseudonym> Not really.  In C++ a class is a struct and a struct is a class.
21:47:50 <segphault> WebGuest: how could .net EVER have better runtime speed than C?
21:48:24 <segphault> Pseudonym: i've tested this, and calling methods in c++ is slower than calling methods in pascal. why that is, I'm not quite sure.
21:48:36 <Pseudonym> Ah, now calling virtual methods is a different thing.
21:48:43 <Pseudonym> A class in C++ is equivalent to a module in ML.
21:48:45 <Pseudonym> More or less.
21:48:51 <Pseudonym> It's a bundle of code + data.
21:48:59 <Pseudonym> Virtual methods are slightly different.
21:49:09 <Pseudonym> BTW, by "equivalent" I mean "play the same role".
21:49:14 <Pseudonym> Not "have equal power".
21:50:00 <WebGuest> segphault: mostly memory related stuff, faster memory allocation and deallocation thanks to garbage collection, more optimization opportunities since there are no pointers, things like that
21:50:27 <segphault> WebGuest: I was just going to say that even if the speed does increase, the already high memory overhead would dramatically increase
21:50:30 <WebGuest> virtual functions in c++ are pretty practially negligently slower then regular  function calls
21:50:44 <segphault> WebGuest: I try to avoid running .net programs on my computer because the resource waste is ridiculous
21:50:44 <Pseudonym> There's also the irony that Fortran often compiles to code faster than C due to the pointer aliasing rules.
21:50:51 <Pseudonym> Even though Fortran is much harder to statically analyse.
21:51:18 <Pseudonym> That says more for the type of code typically written in Fortran, of course.
22:15:08 <Etaoin> hah. "duck typing"
22:16:37 * esap thinks that's from wikipedia, right?
22:17:31 <Etaoin> I was reading the boo manifesto
22:17:46 <Etaoin> ah. but it is on wikipedia too
22:17:48 <esap> oh ok. It's also in http://en.wikipedia.org/wiki/Datatype
22:18:00 <Etaoin> never heard of it before
22:18:03 <segphault> the folks on a.l.python talk about duck typing on a regular basis.
22:18:24 <emu> they are daffy, i'd say
22:18:32 <segphault> they certainly are
22:19:58 <segphault> I have no clue about what it is, but I know they have very lengthy discussions about it at a.l.p that you usually result in the javaphiles telling the pythonistas that python sucks because it doesnt have static typing.
22:20:35 <segphault> i'm always amazed by the number of people from the java community that write python code and absolutely abhor the language.
22:21:27 <dash> a.l.python?
22:21:31 <segphault> alt.lang.python
22:21:33 <segphault> usenet
22:21:37 <dash> why alt, i wonder?
22:21:45 <esap> I suppose that's because the point of view of python is so much different than what Java provides. When your goals are not compatible with the language, then you'll probably don't like it.
22:21:47 <dash> i figured everyone would use c.l.p
22:22:53 <segphault> doh. it is c.l.p. i'm just not thinking tonight
22:23:04 <segphault> I havent used usenet in so long, I barely remember anymore.
22:23:05 <dash> ah :)
22:23:38 <segphault> the number one worst thing about python, is the community
22:23:50 <dash> really? how so
22:26:24 <segphault> this is from my experience.... half of them are obsessed with making python the premiere language for everybody, and they resent the hell out of java for being so popular, and the other half is obsessed with keeping it exclusive. the simplicity of the syntax seems to attract a lot of people who probably wouldnt be programming otherwise, so the average python programmer is significantly dumber than your average functional pr
22:26:40 <dash> hm
22:26:59 <dash> your experience seems different from mine
22:27:06 <dash> where are you seeing these people?
22:27:24 <dash> (python _is_ the premiere language for everybody)
22:27:25 <segphault> mostly mailing lists, forums, peps, etc
22:27:37 <dash> huh. the python.org lists?
22:28:00 <segphault> I was browsing the mailing list archives
22:28:05 <segphault> I dont know exactly which lists
22:28:09 <segphault> this was a while ago
22:28:12 <dash> i haven't seen much of "resenting the hell out of java"
22:28:32 <dash> except by people with java jobs
22:28:35 <Pseudonym> It could also be argued that the FP barriers to entry are so high that only very smart people get in the door.
22:28:43 <Pseudonym> Which reduces its usefulness.
22:28:50 <Pseudonym> But I won't make that argument.
22:28:51 <dash> well, FP languages also aren't suited to the same kinds of problems 
22:28:54 <Pseudonym> On that note, myst go.
22:28:56 <Pseudonym> Nytol!
22:29:36 <segphault> functional programmers talk about lambda calculus, python programmers talk about design patterns and convincing the boss to let them use python
22:29:48 <dash> mmh 
22:29:52 <segphault> the functional community is much more academic
22:30:01 <dash> yeah, there is a bit too much design-pattern talk
22:30:18 <dash> segphault: OK so you're saying everything else about python is better than its community?
22:30:26 <dash> segphault: that just means it's popular :)
22:30:32 <segphault> lol
22:31:38 <segphault> python is an excellent language for many tasks. problems are easier to solve with python and require less thought. I'm finding tho that while haskell (and functional languages in general) require a much higher investment in time, focus and intellect, the payoff is HUGE.
22:31:44 <dash> if the community is better than the language, that probably means the language isn't finished yet and i don't want to use it for writing real programs ;)
22:32:09 <dash> segphault: hmm, perhaps (i'm currently prototyping some ideas in haskell, so obviously i agree to some extent)
22:32:19 <segphault> I'm the kind of programmer that doesnt program just to solve problems. I program to help myself find new ways to think about problems, and haskell is much better for that than python. as a result, I think functional programmers "grow" more than imperative programmers
22:32:36 <dash> OTOH, there are programs that simply can't be conceived of in FP languages
22:32:46 * dash shrugs
22:33:05 <dash> well, if self-actualization is what you're after, then I can't argue one way or the other :)
22:33:37 <dash> when it comes to actual problem solving, though, i think some things can be said.
22:34:56 <segphault> I think that python programming will eventually lead to conceptual stagnation, and i'm infinitely glad that I moved on when I did
22:35:15 <dash> heh
22:35:18 <segphault> if I want to quickly solve a problem, i'll use ruby rather than python
22:35:23 <dash> Mmm
22:35:47 <dash> ruby doesn't have enough infrastructure
22:35:53 <segphault> what do you mean?
22:36:13 <dash> i mean that it doesn't have enough libraries
22:36:17 <segphault> I'm not sure what you mean by infrastructure... but ruby's object model is quite a bit better than python's when you really play with it.
22:36:17 <segphault> oh
22:36:30 <dash> better how?
22:36:43 <segphault> my favorite feature: you can add methods to built-in classes.
22:36:51 <dash> how is that better?
22:36:53 <segphault> you can dynamically extend classes and instances at run time
22:37:05 <dash> you can do that in python
22:37:15 <segphault> not with the same degree of power or grace
22:37:27 <dash> sure you can
22:37:51 <dash> not being able to extend builtin types is a design decision in python, not an architectural limitation 
22:38:01 <segphault> I suppose you could manually iterate through an object dictionary and manually add each method to an existing instance
22:38:12 <segphault> its a bad design decision in my opinion
22:38:13 <dash> nah, you can add methods to classes.
22:38:15 <dash> why?
22:38:33 <segphault> unnecessary limitation that dramatically decreases productivity and syntactic sensability
22:38:44 <dash> "productivity"?
22:39:00 <dash> explain how screwing with global state improves productivity
22:39:05 <segphault> handy shortcuts
22:39:13 <musasabi> morning
22:39:21 <dash> handy shortcuts decrease productivity in the long run 
22:39:25 <segphault> example: I can overload the div operator in the global string class to make it do string splitting. =}
22:39:41 <dash> ... and how does this improve productivity?
22:40:03 <segphault> less code required to do a common operation, and that code is easier to read and refactor
22:40:08 <dash> er
22:40:27 <dash> what?
22:40:27 <dons> crazy talk
22:40:32 <ozone> <insert the classic operator-overloading-is-bad-no-it-is-good argument here>
22:40:49 <dash> well, this isn't even about operator overloading
22:41:00 <dash> it's about changing global state
22:41:01 <segphault> this is about altering built-in types
22:41:06 <ozone> mayhap there should be an entry in the haskell wiki page which lists a topic of intractable debates
22:41:10 <ozone> such as operator overloading
22:41:11 <musasabi> functional abstractions remove most of the need for OO abstractions
22:41:12 <dash> surely a haskell user can understand the reasons to not do that
22:41:14 <ozone> or anything jerzy argues about
22:41:22 * dash shrugs
22:41:30 <musasabi> global state == public enemy
22:41:39 <dash> anyway, ruby might interest me if i didn't have five years of work invested into python 
22:41:48 <dash> too late to throw it away now
22:41:49 <musasabi> Ruby is quite nice
22:41:58 <dash> meh 
22:42:01 <segphault> dash: they are similar enough that its really not an issue
22:42:01 * musasabi likes it better than pythob
22:42:18 <dash> segphault: exactly, which is why ruby doesn't interest me :)
22:42:22 * esap thinks OO and functional are duals and symmetric, both are necessary and used in different situations.
22:42:30 <segphault> it always amuses me, I mention ruby features to a python user, and they wonder why the hell I think these things are features
22:42:53 <dash> segphault: yes, i wonder why the hell you think being able to more easily alter global state is a feature
22:43:18 <segphault> when I write a string operation I want to be able to add it to the string class, thats where it belongs
22:43:20 <esap> global state is convenient but dangerous.
22:43:25 <dash> the law of least astonishment points in the other direction
22:43:54 <dash> segphault: yeah, and you know where the end of that road is? Go look at Squeak sometime 
22:44:04 <segphault> I happen to like squeak. ;-D
22:44:10 <esap> But there are situations where global state seems like a good solution [e.g. when you *know* there is exactly one instance of something in existence].
22:44:27 <dash> segphault: You've never written a useful program with it, though 
22:44:35 <segphault> dash: nope, and I probably never will
22:44:43 <dash> segphault: anyway, one method comes to mind, "Object isWebBrowser"
22:45:04 <dash> segphault: Right, because it is pretty much impossible to write useful programs with Squeak 
22:45:05 <segphault> dash: but I do write useful programs with ruby ALL the time, and they are a lot more concise than they would be otherwise because I abuse operators and mutable built-ins
22:45:12 <musasabi> but then again even haskell allows limited global state ;)
22:45:29 <dash> segphault: concise is pretty much the opposite of maintainable, IME 
22:45:34 <dash> at least in matters like that
22:45:38 <musasabi> segphault: they could be even more concise with perl ;)
22:45:59 <segphault> dash: code can be concise and maintainable
22:46:08 <dash> segphault: when you have multiple libraries that screw with builtins in non-compatible ways, you are in trouble
22:46:17 <dash> segphault: how do you avoid that?
22:46:36 <segphault> dash: you be VERY careful, and you try not to do anything that somebody else would want to do
22:46:44 <dash> segphault: hahahah
22:47:02 <dash> segphault: ... such as modify builtin types? 
22:47:02 <dash> ;)
22:47:07 <musasabi> well haskell shares that problem
22:47:11 <esap> Maintainability depends on how small changes map to the design, if small changes require big changes in the code, then the code is not maintainable.
22:47:13 <dash> musasabi: it does?
22:47:42 <musasabi> in haskell it is called wanting to define incompatible class instances for standard types.
22:48:21 * dash nods
22:48:21 <segphault> dash: say I write a relatively generic function, and I want to use it on multiple types. I can either define it globally and take an argument and then do different things depending on the type of the argument or I can make method implementations for it in relevant global classes, which is more efficient and more sane.
22:48:39 <dash> segphault: "more sane" by what standard?
22:49:09 <dash> segphault: to me, the pretty much the most important factor in program design is integratability
22:49:13 <segphault> dash: makes the code more modular and maintainable. I have independent methods rather than a grotesque medley of case statements that check types
22:49:52 <dash> if you're breaking superglobal state like that, you're essentially dooming your code to never be integratable
22:50:18 <segphault> dash: doesnt particularly bother me in most cases.
22:50:32 <dash> segphault: we seem to be talking past each other
22:50:37 <dash> what sort of things do you write in ruby
22:50:43 <segphault> dash: I use ruby to solve problems, and do it quickly. I'm not going to be writing major code libraries in ruby
22:50:49 * dash blinks
22:50:56 <dash> what do you mean by "solve problems"?
22:51:19 <dash> what kind of problems?
22:51:27 <segphault> dash: remember earlier I said that I used functional languages because it helps me grow intellectually, but if I wanted to just solve problems quickly and easily I would use ruby?
22:51:49 <dash> what kind of problems?
22:51:50 <segphault> dash: converting a plain text file in a specific format into another format
22:51:53 <segphault> dash: shell shit
22:51:54 <dash> heh
22:51:59 <dash> okay never mind
22:52:16 <segphault> the kinds of things I do every day, where I dont want to stop and think about how or why, I just want to do it
22:52:37 <dash> we are talking about totally different kinds of things then
22:52:41 <segphault> my ruby programs are *never* longer than 50 lines
22:52:45 <dash> right
22:52:52 <segphault> and most of them are really wierd syntactically anyway
22:53:03 <dash> if it's under 50 lines comparing languages is pretty dumb 
22:53:14 <dash> anything with regexes will do, probably :)
22:53:21 <segphault> I use functional languages for bigger problems because they let me have the flexibility I want without having to make the sacrafices
22:55:16 <segphault> I also right a lot of throw-away code with ruby
22:55:19 <dash> i'm working with a 124KLOC python codebase
22:55:31 <dash> we have different criteria for judging languages :)
22:55:48 <segphault> a sample of some decent ruby code i've written: http://mmearth.net/gaerdin/code/scripts/parfix.rb
22:55:52 <segphault> lol
22:55:57 <segphault> interesting project
22:56:15 <dash> http://twistedmatrix.com/, http://quotient.divmod.org/
22:56:41 <dash> so anyway, does my antsiness about global state make more sense now? ;D
22:56:47 <segphault> for people who enjoy obfuscation, this is the original throw-away version of that other ruby script: http://mmearth.net/gaerdin/code/scripts/parfix.old.rb
22:56:52 <segphault> indeed
22:57:29 <segphault> i'm looking at quotient. thats exactly the kind of project that python makes a lot of sense for
22:57:34 <dash> yeah 
22:57:52 <dash> basically we were sitting around saying "we have all this code, what should we do with it"
22:57:55 <dash> and that is what came out.
22:58:10 <segphault> a friend of mine has been working on a mud in python, and its starting to look like the kind of thing that would be better to do in ruby
22:58:20 <dash> mmh
22:58:41 <dash> well, that's what Twisted was originally created for 
22:58:50 <dash> but python is insufficient to the task, really
22:59:04 <dash> because to do simulations right you need scheduler control 
22:59:35 <segphault> you could dump scheduler control to a lower language I think and still make the rest of the program work in python
22:59:36 <dash> (and to do the kind we like, you need restricted execution)
23:00:13 <dash> well. i think Parrot may prove interesting in that regard
23:00:36 <segphault> parrot is fun
23:02:10 <dash> it's going to be fun to watch mono and parrot duke it out over the next few years
23:02:40 <segphault> I dont think that will necessarily happen. .NET is clearly better for statically typed languages and parrot is clearly better for dynamically typed languages
23:02:53 <dash> sure
23:03:10 <dash> but they'll clear the field of lesser VMs, at least ;D
23:03:11 <segphault> I think they both have definite places in the programming community
23:03:18 <segphault> hopefully c# will kill java
23:03:26 <dash> well hey
23:03:33 <dash> we've already got IKVM 
23:03:40 <dash> no need to argue about syntax
23:04:10 <segphault> I just looked it up. I'd never heard of it
23:04:13 <segphault> thats kind of funny
23:04:45 <dash> game over!
23:09:47 <musasabi> .NET is too platform dependant and big.
23:10:20 <musasabi> they should just have made two specs. One portable VM spec and separate libraries from that.
23:10:48 <segphault> musasabi: mono does that
23:10:55 <segphault> musasabi: you can get 'mint' which is the portable vm
23:11:09 <segphault> I think. I may misunderstand what 'mint' is.
23:15:50 <musasabi> yes, but all the apps are tied to the API so that does not help much..
23:29:39 <dogand> hi, i'm trying to program sockets in haskell...
23:29:48 <dogand> but i'm using the hugs interpretter, and would rather not use ghc
23:30:03 <dogand> what libraries are good to import? i don't seem to have Socket nor SocketPrim
23:30:22 <Lemmih> dogand: Try Network.
23:30:41 <dogand> i don't have that either it seems
23:31:01 <dogand> i'm at chalmers now and i don't have root access, if that makes any difference
23:32:41 <Lemmih> dogand: Start Hugs with 'Network' as an argument.
23:32:57 <dogand> okay..
23:33:05 <dogand> unable to open file
23:33:08 <Lemmih> Or type: ':l Network'
23:33:25 <dogand> nope, no luck there
23:33:58 <Lemmih> What error messages do you see?
23:34:19 <dogand> only ERROR "Network" - Unable to open file "Network"
23:37:07 <dogand> any ideas at all? :/ i was looking forward to bragging about doing sockets in haskell to my friends
23:37:43 * musasabi uses just ghci
23:37:45 <shapr> gwahr
23:38:03 <dogand> <- kristnjov btw
23:38:53 <shapr> time for unicycling!
23:38:59 <dogand> no, time for debugging!
23:39:09 <Lemmih> dogand: What version of Hugs are you using?
23:39:23 <dogand> Lemmih: how do i find out?
23:39:38 <dogand> november 2002 version
23:39:45 <dogand> haskell 98 mode
