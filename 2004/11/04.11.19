00:34:41 <musasabi> hmm kosmikus seems to have it up on dev.g.o
03:11:51 <Spark> mm combinator systems
03:11:57 * Spark licks lips
04:29:11 <strib> Hello all y'all.
04:31:19 <Lemmih> Hey
04:31:33 <Lemmih> musasabi: What's the URL for hs-fltk again?
04:32:50 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
04:34:06 <strib> My darcs pull is taking aeons; when I give it a -v flag, it seems to be stuck at the "diffing dirs..." stage. Got any ideas?
05:14:41 <Itkovian> can you give an unbiased opinion on darcs vs. subversion, cvs ? not too long, but preferably longer than 'it's better'  :-)
05:14:59 <Itkovian> disadvantages of both?
05:15:05 <Itkovian> well, all three...
05:15:11 <Itkovian> that you might have encoutered
05:26:17 <musasabi> Itkovian: well darcs is very simple to use.
05:26:51 <musasabi> Itkovian: it does not suffer from the deficiencies of cvs (neither does subversion) but it is not very well known.
05:26:54 <Itkovian> so i gathered ...
05:27:15 <Itkovian> i shall check it out (no pun intended)
05:27:18 <musasabi> also distributed development with darcs is very easy ^_^
05:27:49 <Itkovian> erm ... in what does it differ from subversion in that respect?
05:27:56 <musasabi> which is nice even in one developer projects if you work with many machines.
05:28:27 <musasabi> Itkovian: does not need any setup, while setting up subversion server is quite involved.
05:28:33 <Itkovian> true
05:28:57 <Itkovian> but once it has been set up ... ah well
05:29:19 <Itkovian> tell me, does darcs keep a local 'state' like cvs, svn?
05:29:24 <musasabi> it works. just like darcs work without the setup madness.
05:29:38 <musasabi> please define local state a little bit.
05:29:52 <musasabi> (so my answer won't be too far off)
05:30:30 <Itkovian> well, the .svn dir, CVS dir ... it would be nice to be able to e.g. check out a cvs repository, modify the stuff and keep a darcs repository of the changes, e.g. for stuff one has no submit ights to
05:30:45 <earthy> itkovian: darcs does keep local change repositories, yes
05:30:58 <earthy> in fact, every darcs checkout is a full repository
05:31:13 <earthy> i.e. you can then check out from that again
05:31:28 <Itkovian> I tinker a lot in the Jikes RVM, which I keep updated from the main CVS repository, and I am looking for a way to keep track of my own addiditons other than cvs -diff and storing that somewhere
05:31:57 <Itkovian> I hope I'm making myself clear  ...
05:32:02 <earthy> yes, you are
05:32:06 <earthy> darcs will allow you to do that
05:32:09 <Itkovian> woot!
05:32:16 <Itkovian> let's emerge it then :-)
05:32:35 <earthy> you don't have to push all your local changes upstream, while still being able to pull changes from there
05:32:38 <musasabi> Itkovian: yes, that is very painfull with cvs. (I had local branches + cvs before switching to darcs)
05:33:06 <Itkovian> it's just that I wish to keep my local code in sync with the IBM cvs stuff
05:33:28 <earthy> well, keep two darcs repositories locally
05:33:30 <Itkovian> and I have no idea how to proceed with cvs or subversion to make it painless ... so any other system is quite welcome
05:33:34 <earthy> one that you keep in sync with cvs
05:33:39 <earthy> one that you keep your own stuff in
05:33:40 <Itkovian> certainly if it;s mostly haskell code ;-)
05:34:00 <Itkovian> earthy: but syncing those two can be a pain in the arse
05:34:15 <earthy> no, that's the beaut
05:34:29 <musasabi> Itkovian: no actually that works quite nicely.
05:35:05 <musasabi> of course that does not make cvs history from the main repository transfer over to your working repository, but all the changes do.
05:35:45 <Itkovian> I'm at loss now ... call me a moron if you like, but how can you easily transfer the changes?
05:36:00 <Itkovian> I guess you could alter the CVSROOT ...
05:36:15 <musasabi> Itkovian: you have two repositories, lets call them "dcvs" and "work"
05:36:20 <Itkovian> yes.
05:36:41 <Itkovian> ok ok ...
05:36:49 <musasabi> now you run "cvs update" in dcvs to get all the changes from the main project.
05:37:02 <Itkovian> hmm
05:37:53 <musasabi> then you just "darcs record -a" to save changes to them (do a "darcs whatsnew -l" to find new files)
05:38:07 <Itkovian> all rightie
05:38:22 <Itkovian> yes ... that's using darcs ... i was talking just using cvs ...
05:38:40 <musasabi> then just "darcs pull" from dcvs to work to get all the changes in the project.
05:39:01 <Itkovian> ok.
05:39:06 <Itkovian> let me copy 'n paste that :-)
05:40:02 <musasabi> (you can create work with a simple "darcs get path/to/dcvs" and fetch the updates with "darcs pull" in work as it uses the previously used location by default.
05:40:39 <musasabi> the only small issue is to remember to ignore CVS directories in dcvs as you won't probably want to bother with them.
05:40:44 <musasabi> &c
05:40:51 <Itkovian> ok.
05:40:53 <Itkovian> thx
05:42:22 <Itkovian> i'll try to pull this off over the weekend ... after my roof is fixed ...
08:14:07 <marcot> Hello, how can I compile or interprete an gofer project, .gp ?
08:15:01 <marcot> Does the Text class work with hugs?
08:16:03 <dustin`> Text.Regex does not, but I'm not sure of anything else
08:16:36 <marcot> dustin`: ok, thanks..
08:20:02 <Igloo> Text.Regex does
08:20:38 <dustin`> Oh?  I could swear I was yelled at when I tried to import it
08:20:54 <Igloo> Text.* is a hierarchy, BTW. There's no standard Text class AFAIK, though, so you probably meant hierarchy anyway
08:21:13 <Igloo> nhc98 doesn't support it - don't know if that's what you were thinking of
08:21:30 <Igloo> And hugs (or ghc) on Windows might not have it, I don't know
08:26:40 <musasabi> Is there a darcs repository of fptools (in particular GHC) available?
08:27:42 <Igloo> NAFAIK
08:28:07 <Igloo> I don't think the cvs2darcs scripts aren't mature yet, so I'm not sure it would be very useful?
08:29:33 <gui_> hey there
08:29:36 <musasabi> hello
08:29:39 <Lemmih> Hey gui_
08:30:16 <gui_> :-) this chatroom is really friendly, lol. has anyone trying hopengl with mac os x?
08:31:31 <gui_> *tried
08:32:15 <Lemmih> Are you sure your problem is Mac specific?
08:34:18 <marcot> b
08:34:29 <marcot> sorry, wrong window.
08:36:46 <dottedmag> I think gui_ was unsure :)
08:42:18 <Lemmih> Anyone got a C++ parser lying around?
08:42:43 <dash> http://gccxml.org/
08:43:20 <musasabi> Lemmih: I have something that parses C++ headers with parsec.
08:43:39 <musasabi> not "proper" but working
08:43:50 <Lemmih> musasabi: That sounds great. Is it available on the web?
08:44:09 * dottedmag unsure it will parse complex enough code
08:44:41 <dash> this is why gccxml got written ;)
08:45:07 <dottedmag> oh, yeah. seems to be a great tool...
08:45:41 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/Parser.hs
08:49:27 <TheHunter> good evening, shapr!
08:49:54 <shapr> greetings TheHunter!
08:50:13 <shapr> Thanks for your Wiki Gardening.
08:50:33 <shapr> It's nice to see positive changes on my RSS feed rather than spam :-)
08:51:30 <TheHunter> yaeh, there's a lot spam lately because of that filter.
08:52:00 <shapr> From what I've seen, the filter seems to be a better solution than IP blacklisting.
08:52:15 <shapr> Hey, do you have privs to edit LocalBadContent?
08:52:55 <TheHunter> nope
08:53:16 <shapr> I'll fix that...
08:54:55 <shapr> Which wiki login do you use?
08:55:15 <TheHunter> I changed it to ThomasJaeger.
08:55:29 <shapr> ok, I'll add you to the AdminGroup
08:55:44 <TheHunter> cool, thanks!
08:56:14 <shapr> ok, now if you're logged in as ThomasJaeger, can you edit BadLocalContent ?
08:56:20 <shapr> er LocalBadContent, oops
08:56:38 <TheHunter> yep, works fine.
08:56:45 <shapr> spiffy
08:58:20 <shapr> That page is just a list of regexes. If any of them match, no one can submit that change. Spammers tend to use the same hostname several times. foo.bar.com quux.bar.com bazzy.bar.com, so I put in bar.com
08:58:38 <shapr> It also does lookup from the global MoinMoin page.
08:58:42 <shapr> That's it.
08:59:01 <TheHunter> nifty.
08:59:19 <shapr> Yes, I agree. It's a sensible approach. I think it'll start being used for blog spammers soon.
09:00:19 <shapr> I think spammers will have to start using ip addresses and the zillion legal forms of ip urls soon, but that can likely be caught with a minor addition.
09:05:22 <Lemmih> gccxml is great!
09:06:40 <shapr> what's that?
09:06:49 <shapr> mmm new release of HaRe
09:07:24 <shapr> gcc that outputs xml?
09:08:23 <Lemmih> shapr: It outputs parsed C++ code as XML.
09:20:50 <SyntaxNinja> 'mornin
09:20:56 <Lemmih> Hey SyntaxNinja.
09:21:27 <SyntaxNinja> how's life, Lemmih
09:23:42 <Lemmih> Not bad. Not bad at all. Shapr's movies has boosted my unicycle training.
09:24:22 <SyntaxNinja> haha
09:24:29 <SyntaxNinja> we will all learn to unicycle some day
09:28:23 <Lemmih> Will you be present at the next euroHaskell?
09:32:26 <SyntaxNinja> do I look euro to you? :)  probably not... maybe we could hold it in the US?
09:37:09 <Igloo> You want to hold euroHaskell in the US?
09:37:15 <Lemmih> haha
09:37:16 * Igloo scratches his head
09:37:52 <SyntaxNinja> Igloo: well, it's not fair to hold it in europe all the time
09:38:14 <Strx> hi 
09:38:18 <Lemmih> Hello Strx
09:38:25 <Strx> when trying to compile HaRe I get 
09:38:27 <Igloo> SyntaxNinja: You can have something in the US, but it can't be euroHaskell  :-)
09:38:31 <Strx> /usr/bin/ld: cannot find -lreadline
09:38:42 <Strx> but I do have readline-4.3-105
09:38:42 <SyntaxNinja> Igloo: OK, let's call it... 'galois' :)
09:38:48 <Strx> any idea?
09:40:25 * Igloo probably won't make anything in the near future in either the US or Sweden that isn't next to a conference I'm going to  :-/
09:43:26 <musasabi> Sweden is quite convenient.
09:45:46 * Strx just fixed it
09:46:15 <SyntaxNinja> Strx: what was the problem?
09:47:29 <Strx> SyntaxNinja: in /lib there was only libreadline.so.4  and libreadline.so.4.3
09:47:51 <Strx> SyntaxNinja: I made a symlink to libreadline.so and ran ldconfig
09:47:59 <Strx> and it compiled fine afterwards
09:48:09 <SyntaxNinja> cool
09:48:18 * Strx is out
09:48:19 <Strx> bbl
09:50:54 <musasabi> Is there something to fix such errors in general?
09:51:43 <musasabi> I get them most of the time when specifying a lib in Cabal Extra-libs, and they are all fixable by creating those symlinks.
09:53:17 <SyntaxNinja> musasabi: what about /usr/lib?
09:54:26 <marcot> Hello, I'm trying to load some code with hugs, but I'm getting the error message:
09:54:41 <marcot> ERROR "TempDB.hs":14 - Cannot justify constraints in instance member binding
09:54:41 <SyntaxNinja> maybe I need to automatically add $libdir to the library_dirs field
09:54:49 <SyntaxNinja> musasabi: do you have an example where that problem happens?
09:55:19 <musasabi> SyntaxNinja: stdc++ ?
09:55:56 <Igloo> musasabi: Do you have the -dev package for the libraries installed?
09:55:58 <SyntaxNinja> musasabi: huh?  do you have an example cabal package where  this happens? what platform are you on?
09:56:18 <musasabi> SyntaxNinja: wait a moment I'll try to generate a simple example.
09:56:31 <SyntaxNinja> musasabi: c00
09:57:16 <marcot> the code is at www.dcc.ufmg.br/~marcot/TempDB.hs
09:57:52 <marcot> There's also www.dcc.ufmg.br/~marcot/DataBase.hs
09:58:09 <marcot> I can't understand why it's giving this error message.
09:58:47 <SyntaxNinja> marcot: I get an error if I try to get that first file.
10:02:27 <marcot> SyntaxNinja: sorry...
10:02:42 <marcot> SyntaxNinja: Reload..
10:03:29 <marcot> instance (Databases TDB o t) => IDs (TDB o t) where
10:03:35 <marcot> It gives an error here.
10:04:13 <musasabi> SyntaxNinja: http://www.cs.helsinki.fi/u/ekarttun/haskell/foo.tar.gz
10:05:25 <musasabi> that fails on Debian (sid) after installation because there is no libstdc++.so, no the other hand gcc (in C mode) will resolve -lstdc++ correctly (as can be tested with the c file included).
10:05:44 <marcot> *** Expression    : getID
10:05:51 <marcot> *** Type          : IDs (TDB a b) => TDB a b -> ID
10:06:01 <marcot> *** Given context : IDs (TDB a b)
10:06:07 <marcot> *** Constraints   : Databases c a b
10:06:10 <musasabi> sauna, brb ~60min
10:06:15 <kolmodin_> in wxhaskell, I want to do an animation with a lot of lines. is there any smarter way than to redraw all lines on every paint?
10:06:23 <marcot> What does it mean?
10:07:42 <marcot> In the instance declaration I sad that TDB o t is an instance of Databases.
10:09:10 <SyntaxNinja> musasabi: builds for me
10:11:51 <kolmodin_> currently I have set a "on paint" property on a panel but it clears the DC before I get it so I have to draw everything again. any ideas?
10:12:05 <shapr> I love unicycling. It sure is cold out there though.
10:16:09 <marcot> What this message means at all:  Cannot justify constraints in instance member binding.
10:17:08 <shapr> sounds like you're trying to make a typeclass instance without the requirements
10:18:27 <marcot> shapr: but in the signature of instance, I said that the TDB a b is an instance of the class Databases.
10:18:51 <marcot> So, what is he trying to tell me? That TDB should be and instance of Databases?
10:18:59 <marcot> an instance
10:19:55 <TheHunter> marcot, try to compile it with ghci, that usually gives better error messages.
10:20:22 <marcot> TheHunter: I'll do it.
10:31:41 <SyntaxNinja> musasabi: I don't know why there's no .so file... the reason gcc is working is that it does have a library that it knows about that's not in /usr/lib
10:41:55 <goron> @index scanFile
10:41:56 <lambdabot> bzzt
10:45:17 <Lemmih> scanFile?
10:46:31 <goron> Yes, I already found it...
10:49:06 <goron> It seems the result of ghc interpreter=/compiler. Pretty weird..
10:51:58 <goron> putStrLn "something" followed by putStr "something else" only gives "something" in the compiled version. The interpreted version gives both. 
10:52:45 <TheHunter> seems to be a linebuffering issue.
10:53:01 <TheHunter> hSetBuffering stdout NoBuffering should do the trick.
10:53:18 <goron> Isn't it a *bug*?
10:53:48 <TheHunter> i don't think so.
10:53:53 <goron> I would say that the interpreted semantics should be equal to the compiled semantics.
10:54:50 <goron> Don't you agree?
10:55:09 <Lemmih> goron: Defaulting to NoBuffering is not very efficient.
10:56:09 <TheHunter> you should be able to do all sorts of things from ghci (like printing infinite lists). A compiled programm doesn't need that functionality, usually.
10:56:57 <TheHunter> i didn't test it, but if the performance difference is small, buffering should be changed to NoBuffering even in compiled programs.
10:57:05 <CosmicRay> I have a question about datatypes with named fields.  If one of the fields is a function, is there a way for that function to refer to the "self" object?
10:57:17 <CosmicRay> that is, one of the functions operates on the data of that type itself
10:57:32 <CosmicRay> TheHunter: performance difference of doing that can be huge
10:57:41 <Lemmih> I don't see why it should change the buffering at all.
10:58:41 <TheHunter> CosmicRay, functions as named fields a weird in a way.
10:58:54 <TheHunter> You can't even do Foo {bar x = x * x}.
10:59:18 <CosmicRay> but I could do Foo {bar = \x -> x * x}, right?
10:59:33 <TheHunter> so you have to use let ... in (sadly, even where doesn't work).
10:59:57 <CosmicRay> that's not my problem... let me paste a small snippet
11:00:02 <CosmicRay> data ConfigParser = ConfigParser 
11:00:02 <CosmicRay>     { content :: CPData,
11:00:02 <CosmicRay>       optionxform :: (String -> String),
11:00:02 <CosmicRay>       defaulthandler :: (ConfigParser -> String -> String),
11:00:02 <CosmicRay>       usedefault :: Bool
11:00:02 <CosmicRay>     }
11:00:26 <CosmicRay> In this example, is there a way that I could get the ConfigParser out of the args for defaulthandler?  Ie, defaulthandler could somehow figure out the ConfigParser that it's a part of?
11:00:48 <TheHunter> ah, I see the problem.
11:01:02 <Lemmih> That's not possible, afaik.
11:01:06 <goron> I see ghci for developing applications and ghc for compiling something that's exactly the same only faster.
11:01:40 <CosmicRay> ok, thanks
11:02:14 <CosmicRay> @index lower
11:02:15 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
11:02:29 <CosmicRay> @index toLower
11:02:29 <lambdabot> Data.Char,GHC.Unicode,Char
11:05:01 <Lemmih> goron: Do you understand why the interpreter uses line buffering?
11:05:40 <TheHunter> goron, maybe ghci should behave as a compiled program you type main.
11:07:30 <Lemmih> s/line buffering/NoBuffering/
11:07:33 <TheHunter> (or even for everything that uses IO)
11:08:36 <musasabi> back.
11:09:39 <Lemmih> TheHunter: I'm not sure it would be wise to add additional complexity to solve something which really isn't a problem.
11:09:48 <goron> Lemmih: yes, it makes some sense for simple expressions, but for IO expressions it does not, imho.
11:10:21 <TheHunter> Lemmih, I know, but programs behaving differently in ghc and ghci doesn't seem rigth either.
11:10:24 <goron> TheHunter: :?
11:10:57 <goron> TheHunter: 21:05
11:11:44 <TheHunter> goron, i kinda changed my mind.
11:12:05 <TheHunter> i don't have an opinion anymore, that is.
11:12:39 <goron> TheHunter: Well, I just didn't understand you. But now I now what you meant. :)
11:13:53 <goron> Is there some command to say in ghci: precompile everything?
11:14:05 <TheHunter> NoBuffering is essential for interactive evaluation of expressions.
11:14:14 <goron> I had to write some scripts to do it. 
11:14:33 <goron> last now->know
11:14:38 <Lemmih> goron: ghc --make, perhaps.
11:15:43 <goron> Lemmih: I meant inside ghci. My approach was ghc --make, but I had to include a lot of paths. 
11:16:03 <goron> And it seems something useful. 
11:18:15 <Lemmih> Agreed.
11:18:41 <Lemmih> But unfortunately I haven't heard of such feature.
11:19:01 <TheHunter> Yep, would be immensly useful.
11:40:14 <goron> Can I copy this last piece of conversation into SF? 
11:42:35 <Lemmih> SF? SourceForge?
11:45:36 <goron> yes
11:45:57 <goron> To make a feature request.
11:46:33 <Lemmih> I'm OK with it.
11:46:47 <goron> TheHunter: ?
11:47:34 <Spark> i just watched a fight in macdonalds!
11:48:09 <flaw> someone didnt get cheese on their cheese burger?
11:48:17 <Spark> nah
11:48:22 <Spark> want the full story?
11:48:43 <flaw> hrm, how long?
11:48:47 <Spark> fiarly
11:48:50 <Spark> i shall summarise
11:48:57 <goron> "The Full Story"- now featuring on #haskell
11:48:58 <Spark> customer is leaning over the counter, unsupervised
11:49:02 <flaw> hehe
11:49:05 <Spark> manager sees and tells him to get out
11:49:20 <Spark> customer is all full of attitude and 'i wasnt doing anything, i told you what happened'
11:49:27 <Spark> manager is just repeating 'get out'
11:49:47 <goron> Manager gets machine gun...
11:49:55 <goron> splatters...
11:49:55 <Spark> customer is getting agitated and in the guys face, and one of them touches / pushes the other
11:50:02 <flaw> say hello to my little friend
11:50:11 <Spark> eventually the customer punches the manager in the face, more like a slap though, not very hard
11:50:14 <Spark> so the manager NUTS HIM
11:50:20 <goron> AUCH!
11:50:23 <Spark> by which time there are more staff about
11:50:31 <Spark> and theyre all hugging each other like boxers
11:50:38 <Spark> someone calls the police...
11:50:40 <SyntaxNinja> so there's not a counter in between them?
11:50:46 <Spark> nah the manager comes round
11:50:46 * SyntaxNinja has been picturing this wrong
11:50:55 <Spark> when he starts telling him to get out
11:50:59 <Spark> hes on the customer's side
11:51:04 <SyntaxNinja> got it
11:51:20 <Spark> so this goes on for a bit, and the guy realises hes probably on camera or something and starts to leave
11:51:30 <Spark> and hes all 'ill be back, 30 minutes' and the manager is agreeing
11:51:30 <SyntaxNinja> and Spark NUTS HIM
11:51:45 <flaw> hehe
11:51:53 <Spark> but hten the manager baits him to come back
11:51:58 <Spark> and theyre at it again
11:52:09 <Spark> and for some reason the staff take him round the back, like dragging him
11:52:19 <Spark> and he drops to the floor to make it difficult, but this is behind the counter so i cant see
11:52:28 <Spark> and hten the manager re-emerges covered in blood
11:52:37 <Spark> under his eye
11:52:42 <Spark> sounds a bit suss doesnt it
11:52:56 <SyntaxNinja> who gets dragged 'round back?
11:53:00 <Spark> the customer
11:53:01 <flaw> his blood or the other guy's blood?
11:53:05 <Spark> his blood
11:53:18 <Spark> the manager was never gonna win
11:53:49 <Spark> i guess thats all the interseting bits
11:53:51 <flaw> why was he getting on the customer's case?
11:53:56 <Spark> eventually police come and stand about aimlessly
11:53:58 <TheHunter> goron, you can quote me. I guess `immensly' actually should have meant just `very', though.
11:54:23 <Spark> cos the customer was leaning over the counter, and he assumed he was stealing money
11:54:35 <Spark> so he asks him to leave, which is reasonable i guess since you obviously cant trust him any more
11:54:50 <Spark> but then he fights back, which is what i'd call "unprofessional"
11:54:56 <flaw> right
11:55:09 <Spark> i wish i'd had my camera
11:58:53 <goron> TheHunter: I referred to you as "Somebody else". 
11:59:40 <TheHunter> goron, ok.
12:09:39 <det> Spark: who dragged the customer around back?
12:09:46 <Spark> the manager
12:09:49 <Spark> and the staff
12:10:04 <det> And then the Customer beat the hell out of the manager?
12:10:18 <Spark> he got 1 good hit in
12:10:20 <Spark> somehow
12:10:26 <Spark> even though he was on the floor
12:10:30 <Spark> i couldnt see that bit
12:10:36 <det> The staff was participating in this other than dragging?
12:10:55 <Spark> they were very pacified, except the manager
12:11:11 <det> Where do you live? :)
12:11:11 <Spark> they were just standing about but quite close
12:11:16 <Spark> clapham, london, uk
12:12:14 <Spark> its a bit of a seedy area, but often populated by middle class city types because it has an interesting night life of bars and such
12:34:02 <mayhem> hi
12:34:32 <CosmicRay> heh
13:35:10 <shapr> d00d
13:37:41 <Lemmih> What's up, shapr?
13:39:07 <shapr> Um.
13:39:08 <shapr> Nothing at the moment.
13:39:14 <shapr> Trying to get started coding.
13:39:17 <shapr> What's up with you?
13:39:24 <mayhem> hey
13:39:27 <shapr> I've tried to learn one-footing since you mentioned you can do it :-)
13:39:48 <shapr> I'm doing better than I expected, but I still can't really do it.
13:42:00 <shapr> Is php5 in debian?
13:42:59 <Lemmih> shapr: I'm working on a cpp2hs project and it's going really well.
13:43:06 <shapr> nifty!
13:44:37 <Lemmih> HaXml and DtdToHaskell rocks, btw (-:
13:54:07 <shapr> Yes, I agree.
14:11:19 <Cale> finally, back online
14:11:24 * shapr cackles happly
14:11:31 <shapr> greetz Cale! wassup?
14:12:05 <Cale> Just got reconnected. My roommate neglected to pay the 'net bill for long enough that our ISP lost our line.
14:12:10 <shapr> doh
14:12:28 <shapr> have you carefully disciplined your roomie?
14:12:36 <Cale> What's worse is that line got taken, so we couldn't get reconnected.
14:12:44 <shapr> yow!
14:12:48 <shapr> extreme suckage.
14:13:04 <Cale> 100ft of ethernet cable later, we're using our neighbour's DSL modem to log in.
14:13:22 <Cale> (at the same time as them, thankyou packetised connections)
14:13:34 <shapr> =)
14:14:11 <shapr> I've always wanted to live with enough geeks in the same place to do chaffed load-balanced connections.
14:39:18 * shapr boings
14:45:45 <wagle> is seq used for anything other than improving space behavior?
14:46:25 <shapr> seq forces weak head normal form. I don't know if whnf has any other advantages.
14:46:46 <shapr> It could also improve execution behaviour I assume.
14:46:51 <shapr> But that's pretty much the same thing.
14:47:01 <shapr> Greetings wagle, how's the great northwest treating you?
14:47:13 <esap> seq can also be used to make time usage worse.
14:47:17 <wagle> heh..  looking for a job..  8/
14:47:36 <shapr> PacSoft isn't hiring?
14:47:53 * esap doesn't think that's an advantage, but it's its behaviour.
14:47:58 <wagle> ogi is dead.  long live portland state university
14:48:12 <shapr> PacSoft is going down?
14:48:22 <wagle> no money
14:48:25 <shapr> :-(
14:48:48 <wagle> pacsoft is pretty much at portland state university now (pdx.edu)
14:49:56 <shapr> Scary. Reid Consulting shut down and Alistair went to work for ARM. PacSoft is going down. I've heard rumors that the Epigram folks aren't exactly rich either.
14:50:19 <wagle> nah, pacsoft lives on at pdx
14:50:40 <wagle> but grant money is very scarce
14:50:54 <shapr> I sent out my resume to aetion and galois offering to do Haskell telegrunt work. Why do I get the feeling it won't help...
14:51:46 <shapr> On the other hand, we got an offer to be the technical partner in an upcoming EU project. If we can afford to become a limited company, we may actually do that =)
14:52:29 <shapr> And, if we're the tech partner, *we* get to choose and execute the tech part of the grant. Guess what language I'll use? =)
14:53:11 <shapr> I really do wish I could get a Zope replacement in Haskell. 
14:53:18 <shapr> Zope is a lot of trouble.
14:53:56 <wagle> whats zope?  (heard the name, dunno what it is)
14:54:06 <shapr> web app server written in Python.
14:54:29 <wagle> hahaha.  is there anything good about python?
14:54:32 <shapr> It tightly integrates database, web server, ftp server, cataloguing of every object, web publishing, etc etc
14:54:41 <shapr> Sure, Python is a great language.
14:55:04 <wagle> every brittle app i've used lately has been written in python
14:55:20 <shapr> Python is very easy to learn, and scales up to real applications as well.
14:55:34 <shapr> Sadly, Guido is adding more and more features to the language, it's getting a lot harder to learn.
14:55:46 <shapr> Also, it's easy to write bad code in any language :-/
14:55:48 <wagle> heat death
14:56:32 <shapr> Python was my first inkling that 'Worse is Better' is a false dichotomy.
14:56:33 <wagle> i actually liked perl 4..  perl 5 was a bad move
14:56:49 <shapr> 'Know when to stop'
14:56:57 <shapr> I think the Pragmatic Programmer says that.
14:57:38 <wagle> shark must keep swimming or suffocate
14:58:12 <wagle> there's a mentality that if you don't grow, you are dead
14:58:15 <wagle> sigh..
14:58:29 <shapr> Sometimes growing means taking away the bad.
14:58:41 <shapr> Guten abend Lenny1729, what can we do for you?
14:58:43 <wagle> cancer happens when cells dont know when you stop 
14:58:55 <Lenny1729> hi shapr
14:59:24 <wagle> on the other hand, gpl means no code ever dies.  8/
15:00:05 <shapr> Lenny1729: hey, you're a Python programmer, aren't you?
15:00:46 <shapr> Lenny1729: no one told me :-)
15:00:52 <shapr> Your name sounds familiar.
15:01:00 <shapr> Were you at EuroPython 2004 maybe?
15:01:46 <wagle> anywho
15:01:57 <shapr> Lenny1729: I used to read a lot of Python mailing lists, maybe you've posted to them?
15:02:14 <wagle> seq (and bottom) causes problems with the monad laws
15:02:26 <shapr> how so?
15:03:00 <esap> wagle: I think seq and _|_ cause lots of other problems as well. Though I'm not exactly sure which monad law is broken by seq.
15:03:01 <wagle> someone else here finds that the proofs fall apart..  
15:03:46 <wagle> apparently seq being able to distinguish between bot and \x.bot is a pronlem..
15:03:59 <wagle> i'm not completely on top..  trying to get there.
15:04:23 <esap> I don't think it's a problem. \x . undefined  explicitly says that evaluation should be delayed [lambda does that].
15:04:30 <wagle> i'm wanting to implement seq differently to see if that would fix things
15:05:01 <wagle> bot::a->a and \x.bot
15:05:21 <esap> a -> a?
15:05:45 <wagle> of some functional type
15:05:53 <wagle> a->b
15:05:58 <esap> (\x -> undefined) :: a -> b
15:06:49 <wagle> being able to distinguish bot :: a->b and \x.bot is a problem for the monad laws, apparently
15:06:59 <wagle> i could be very confused
15:07:26 <esap> I'm wondering if you mean bot :: a and \x.bot :: a -> b
15:07:53 <wagle> i mean a expression that diverges while trying to compute a function value
15:08:59 <wagle> sorry that i cant explain it better
15:09:01 <esap> hmm.. how would that work? I think \x.y is supposed to be in normal form for every y.
15:09:31 <wagle> seq bot 1 == 1
15:09:50 <wagle> seq bot 1 == bot
15:10:00 <wagle> seq \x.bot 1 = 1
15:10:39 <wagle> (what type is seq?  a -> b -> b or a->a->a?)
15:10:55 <monochrom> @info seq
15:10:56 <lambdabot> -- seq is a variable
15:10:56 <lambdabot> infixr 0 `seq`
15:10:56 <lambdabot> seq :: forall a b :: ?. a -> b -> b
15:11:03 <wagle> heok
15:11:05 <wagle> hokeh
15:11:17 <Igloo> esap: The two bots aren't the same, so the type sig is just making the point they have the same type (IIUC)
15:11:44 <wagle> what you want is for seq x y == y, no matter what x is
15:12:11 <esap> wagle: then what's the difference between seq and flip const?
15:12:12 <wagle> but now, if x is bottom, then seq x y = bottom
15:12:42 <Igloo> wagle: The only definition of seq that can satisfy that is   seq _ y = y
15:12:49 <wagle> seq is strict in its first argument
15:13:01 <Igloo> Given Turing completeness, the halting problem etc
15:14:09 <wagle> problem is that seq bot _ = bot
15:14:15 <esap> wagle: exactly. But if you want seq x y == y, then seq = flip const.
15:14:40 <wagle> no, want seq to evaluate the first argument, unless it diverges
15:14:57 <wagle> because doing so reduces space leaks
15:15:22 <Igloo> "unless it diverges" is undecidable
15:15:27 <esap> wagle: so you want a seq that would first solve the halting problem, then evaluate everything but the infinite loop?
15:15:27 <wagle> i'm wonder if there is anything other than space leaks
15:16:19 <wagle> umm..  you are the one decidiing that solving the halting problem is the answer
15:16:26 <TheHunter> esap, i think wagle was trying to say that for some monads to satisfy the monad laws you needed something like seq x y == y. Right?
15:17:05 <wagle> i'm just stating the problem, and wondering what, if anything besides "reduce space leaks", is a purpose for seq
15:17:37 <Igloo> That can lead to better runtime, and it also fixes stack overflows
15:17:59 <TheHunter> i think that's about the only reason for seq, but i could be wrong.
15:18:02 <wagle> i'm confused about how related the seq problem is to the the monad laws problem
15:18:07 <esap> thehunter: hmm.. how does that follow? it might be wagle is saying that, hmm...
15:18:34 <TheHunter> brb
15:18:55 <esap> Ok, I've always thought the type of seq is not quite right.
15:20:14 <Igloo> What type do you think it should have?
15:20:48 <wagle> well, the assumption for seq x y is that evaluating x improves the evaluation of y..  i want to try various ways of enforcing that assumption, or somesuch
15:21:17 <wagle> if x diverges, then the computation certainly wasnt improved
15:21:50 <wagle> could try running x and y in parallel...
15:22:10 <wagle> but that has problems
15:22:54 <esap> Maybe what you want is let x = ... in e   [such that the system starts to evaluate x only if e uses it, and then only evaluates it once]
15:23:38 <wagle> my x and y were metavariables..
15:24:39 <wagle> one example is a state monad where the state will keep growing unless you look at it, with, say, seq
15:25:00 <Igloo> esap: That's what you'd get without seq...
15:25:24 <esap> igloo: assuming the system understands you're sharing things.
15:26:02 <Igloo> Which it does  :-)
15:26:43 <esap> if you write f (complex-thing) (complex-thing)  [with two copies of the code, I think it doesn't]
15:27:15 <wagle> suppose that while evaluating y, it stops needing the value of x, and the computation of x can be garbage collected..
15:27:20 <Igloo> No, but if you seq (complex-thing) y then the result of (complex-thing) won't be shared either, so you'll just be making your program slower
15:27:37 <Igloo> seq is only useful if the seqed thing is being shared
15:27:49 <esap> right.
15:28:30 <esap> maybe seq should bind a variable that would be guaranteed to be in normal form?
15:29:08 <wagle> do { statestuff ; more_state stuff ; seq readState () ; even_more statestuff }
15:29:38 <wagle> x<-readState ; seq x ()
15:29:46 <wagle> ...
15:31:00 <wagle> (i dunno what the actual example is..)
15:31:33 <wagle> i want to either fix seq, or replace it with something that is less like micromanaging the evaluation)
15:32:06 <wagle> "I want the state to use constant (bounded?) space"
15:32:29 <wagle> say what you want rather than how to achieve it
15:34:34 <esap> You'd get very close to wanting OOP as well :-)
15:34:45 <wagle> ?
15:34:48 <wagle> how so?
15:34:53 <TheHunter> esap: i assumed wagle was talking about http://www.haskell.org/pipermail/haskell/2002-May/009622.html .
15:34:58 <esap> OOP is based on the notion that you want to control the amount of space usage of your program.
15:35:54 <esap> as opposed to controlling the execution time.
15:36:50 <wagle> thats an unusual defn of OOP
15:36:56 <TheHunter> hmm esap, i've got a question about duality and evaluation order.
15:37:06 <esap> that's not a definition of OOP, it's a consequence of it.
15:37:22 <wagle> is there a browser that renders that url?
15:38:01 <TheHunter> wagle: click on next message, it's quoted correctly there.
15:38:54 <esap> thehunter: what's the question?
15:38:54 <TheHunter> to which of both worlds does lazy evaluation belong?
15:39:42 <wagle> so you meant "OOP is a result of the notion that ..."
15:39:53 <TheHunter> because it seems to me that it should be more on the oop side that on the fp side.
15:39:57 <esap> thehunter: I think lazy evaluation belongs to the functional world, the same one that has lambda (because lambda delays evaluation).
15:40:09 <wagle> but many OOP languages use garbage collectors
15:40:40 <wagle> lazy doesnt mix well with side-effects
15:41:33 <TheHunter> but laziness allows infinite data structures, which terminal coalgebras contain, but initial algebras don't.
15:41:38 <shapr> @index assert
15:41:38 <lambdabot> Control.Exception,GHC.Base
15:41:43 <shapr> @index assertEqual
15:41:43 <lambdabot> bzzt
15:41:48 * shapr blinks
15:42:01 <wagle> @index bzzt
15:42:01 <lambdabot> bzzt
15:42:08 <wagle> fixpoint!
15:42:09 <esap> thehunter: hmm.. interesting point.
15:42:55 <TheHunter> (i think you have to disallow general recursion for that argumentation to make sense)
15:43:10 <shapr> wagle: =)
15:43:19 <shapr> I thought HUnit was part of the standard libs. Hm.
15:43:38 <esap> thehunter: ok I suppose pattern matching requires evaluation, so pattern matching works like 'seq'.
15:44:22 <wagle> i guess i'm trying to get infinite (and cyclic) datastructures without full-fledged laziness
15:45:04 <esap> wagle: I think you need pointers for that.
15:46:05 <wagle> thats the common conclusion
15:46:09 <esap> wagle: something like data Ref a = forall f. (Functor f) => Ref (f a)
15:46:17 <TheHunter> the other thing i was wondering is if you're already programming oo, if you're using existential types (maybe even typeclasses)
15:46:39 <esap> thehunter: yes.
15:47:20 <esap> thehunter: type classes, subtyping and existential types work pretty well together.
15:47:25 <wagle> but note that lazy evaulation is only done once, so there is already an implied "set box" hidden away
15:51:17 <esap> thehunter: and I think strict evaluation fits there as well. The link between "strict evaluation world" and "lazy evaluation world" is both references and coroutines (I think).
15:52:18 <esap> thehunter: in the sense that coroutines go from lazy to strict and references go from strict to lazy.
15:52:23 <TheHunter> interesting. is there stuff that inevitably excludes each other?
15:52:38 <shapr> The GPL really is a viral license, but that's because it's a vaccine.
15:52:42 * shapr cackles evilly.
15:53:15 <wagle> i once created a single implemention of a pure scheme interpreter that was parameterized by the implementations of cons, car, and cdr to provide either an eager or lazy functional language
15:53:22 <esap> thehunter: I'm not exactly sure what you mean, the answer is obviously yes. :-)
15:54:22 <TheHunter> heh, i meant features commonly found in fp and oop languages.
15:55:26 <wagle> i've heard people describe the modularity of oop and being orthogonal to that of fp
15:55:27 <TheHunter> well, forget it, still not specific enough...
15:55:30 <esap> thehunter: My understanding is that duals are pretty much incompatible [from category theory point of view, they're always in different categories]
15:56:00 <esap> wagle: OOP and FP are I think orthogonal.
15:56:42 <wagle> i meant "the way you modularize programs"..  what do you mean?
15:57:08 <esap> wagle: that, and the symmetry between OO and FP.
15:57:42 <esap> wagle: which is basically the symmetry between space and time.
15:58:35 <wagle> 3 dimensions vs 1 dimension
15:58:36 <esap> wagle: say, algebraic datatypes are symmetric with type classes.
15:58:47 <esap> wagle: both space and time have 1 dimension.
15:58:57 <esap> wagle: since computer memory has 1 dimension.
16:01:14 <esap> wagle: I already mentioned the symmetry between references and coroutines. Then there is functions and layers, records and alternatives, case and pair etc. Lots of symmetries.
16:01:58 * shapr cackles happily at Ron Jeffries' latest email.
16:02:09 <esap> shapr: which mail?
16:02:52 <shapr> Ron Jeffries is talking about not using a bug tracking system at all, and using 3x5 cards intsead:
16:03:06 <shapr> "One of my pithier sayings compares the two things to the difference between cyber and love. And yes, I have known both. In both domains, real personal contact wins out."
16:03:38 <shapr> He has an interesting point.
16:04:45 <esap> I guess the point he's trying to make is that those long shielding layers between customer and the developers are not useful?
16:05:03 <shapr> Yes, I think that's part of it.
16:05:39 <shapr> But, I think he's also saying that communication via computer can not approach the bandwidth of in-person interaction.
16:06:21 <esap> shapr: I diagree with that. The goal is different. Bandwidth is not always important, sometimes reachability is more important.
16:07:54 * esap points out that IRC doesn't have much bandwidth, but I suppose it's still useful :-)
16:08:04 <shapr> Yes, I agree.
16:08:20 <shapr> For project development, IRC isn't as good as in-person sprints.
16:08:34 <esap> true.
16:09:19 <wagle> where is Ron saying this?
16:09:34 <shapr> on The Pragmatic Programmers' mailing list.
16:09:41 <shapr> Shockingly high signal-to-noise ratio there.
16:10:02 * arjanb doesn't like mailing lists without public archives
16:10:05 <shapr> With the occasional glob of complete stupidity.
16:10:39 <shapr> pragprog uses yahoogroups, which I think requires an account.
16:10:40 <esap> Though I think if your customer base is large, then personal communication might be too hard [one person just can't reach millions of customers at the same time :-) a web page can. ]
16:11:02 <wagle> yahoogroups is evvvvillll
16:11:32 * wagle looks for power
16:11:45 <shapr> crap, I had a nice new name for the concept "notions of computation" earlier today, but I forgot the word.
16:11:59 <shapr> I should have written it down.
16:12:09 <shapr> Any name suggestions?
16:12:21 <shapr> I wonder if it's the same as "computer science."
16:12:32 <shapr> No, it's not.
16:12:46 <shapr> Because Vedic Maths fit into this same concept.
16:13:05 <TheHunter> good night, everyone
16:13:11 <shapr> g'night TheHunter
16:13:36 <wagle> in what context did you hear this new word?
16:13:44 <shapr> I made it up.
16:14:25 <wagle> oops
16:14:38 <shapr> It was relatively cute too ... dang.
16:14:51 <wagle> info, cyber, ...
16:15:21 <wagle> you including rna, cell, membrane, quantum, ...?
16:15:40 <shapr> They can be used for computation.
16:16:01 <shapr> I had a word that contained those too.
16:16:09 <wagle> yeah, thats why i mentioned them..  8)
16:16:11 <shapr> I wonder what it was.
16:16:23 <wagle> english word?
16:16:29 <shapr> Someone demonstrated some years ago that computation can happen with intersecting laser beams too.
16:16:38 * esap is not good at finding fine-sounding english words.
16:16:47 <shapr> I remember I chopped up parts of two other words and stirred.
16:17:41 <wagle> causal chaining
16:17:51 <shapr> hm
16:17:53 <shapr> that's a good one.
16:18:05 <esap> "task-oriented"?
16:18:54 * esap said I'm not good at this, I should first understand what you mean with 'notion of computation' :-)
16:19:21 <shapr> lambda calculus and turing machines are the most basic models of "computation"
16:19:32 <esap> ah ok.
16:19:46 <shapr> http://www.scannedinavian.com/2004-11-08.html
16:20:09 <wagle> rewriting
16:21:16 <shapr> abacus, dna computing, quantum computing, Babbage's difference engine... all those are ways to do computation.
16:21:51 <wagle> duction
16:21:54 * esap would use the word "interpreter", "system", "computer", "model", "theory" or "platform" for that.
16:22:01 <shapr> oh, I think duction might have been part of the word
16:22:07 <shapr> compuduction?
16:22:12 <shapr> er, I don't think it had compu in there.
16:22:21 <wagle> infoduction
16:22:26 <shapr> oh, I like that.
16:22:27 <wagle> cyhberduction
16:22:55 <wagle> duckshin
16:23:07 <tuomov> dataflow
16:23:14 <wagle> dadaduction
16:23:21 <shapr> spoken cryptography, vedic maths, and slide rules are all computation also.
16:23:42 <wagle> cryptoduction
16:23:49 <wagle> semioduction
16:24:01 <shapr> interesting thought
16:24:24 <wagle> multiduction
16:24:34 <shapr> if physics is the study of the physical world, maybe datics is the study of data interactions?
16:25:20 <wagle> metaduction
16:25:33 <wagle> transduction
16:25:36 <tuomov> computatics
16:25:42 <shapr> hej flodin
16:25:48 <flodin> hej ;)
16:25:51 <esap> funtroduction
16:25:58 <shapr> :-)
16:26:02 <wagle> ooduction
16:26:14 <wagle> tapeduction
16:26:23 <shapr> zoosuction, the study of vacuums and mice =)
16:26:39 <wagle> viaduction
16:26:48 <shapr> that's a neat word :-)
16:26:53 <flodin> I'm reading Paul Hudak et al's haskell introduction and have a question about the quicksort function they define. Why is its type not [a] -> [a] ?
16:27:04 <shapr> what's the function source?
16:27:11 <shapr> is it less than four lines?
16:27:16 <shapr> if so, you can paste it here on the channel.
16:27:40 <wagle> isnt is something like Ord a => [a] -> [a]
16:27:42 <flodin> oh wait I think I get it. Because I'm doing a comparison in the code, it adds a constraint that a must be ordered
16:27:51 <shapr> ah, you asked about the constraint.
16:28:29 <flodin> so => has lower priority than -> ?
16:28:40 <shapr> They mean different things.
16:33:29 <flodin> Main> map (\x -> x+1) [1 2 3]
16:33:29 <flodin> ERROR - Cannot infer instance
16:33:29 <flodin> *** Instance   : Num (b -> c -> a)
16:33:29 <flodin> *** Expression : map (\x -> x + 1) [fromInt 1 2 3]
16:33:41 <flodin> what does it refer to by "instance"?
16:33:47 <flodin> the function instance?
16:33:53 <wagle> i've been looking for this word for years...  i want to compare and contrast "newtonphysics in newtonspace" with "cyberphysics in cyberspace", but am happy with neither prefix
16:34:45 <flodin> wagle: how about contrasting "newtonian physics in euclidian space" with "cyber physics in cyberspace" :)
16:35:12 <esap> wagle: How about just physics vs. computing or physics vs. concepts
16:35:28 <shapr> what about datics?
16:35:29 <wagle> i'm talking more about "computers in the physical world" vs "computers in the logical world"
16:35:47 <shapr> The interactions of data are very different from, but often based on, physics
16:36:17 <flodin> ironically, simulating physics on computers is one of the most difficult things you can do
16:36:23 <esap> it's the classic distinction between physics and mathematics, just applied to computers.
16:36:46 <shapr> Yes
16:36:51 <flodin> esap: except computers have rounding errors and have to work with discrete time :)
16:36:58 <wagle> flodin, how many elements does the list [1 2 3] have?
16:37:06 <flodin> wagle: three?
16:37:09 <wagle> no
16:37:18 <esap> flodin: rounding errors?
16:37:34 <esap> flodin: floating point has rounding errors, not computers :-)
16:37:37 <flodin> wagle: whoops. Sorry, python damage :)
16:37:42 <flodin> no wait
16:37:45 <shapr> even python requires commas =)
16:37:46 <flodin> not python... matlab?
16:37:54 <flodin> yeah, let's say matlab. :)
16:38:16 <wagle> the conversion to [fromInt 1 2 3] was a hint
16:38:21 <shapr> Joy doesn't require commas, I think.
16:38:21 <flodin> actually i've been spending the past two months with a lisp-like syntax
16:38:44 <wagle> might also try different interpreters for different error messages..  hugs was more informative
16:38:54 <flodin> wagle: this is hugs :)
16:39:06 <wagle> Prelude> map (\x -> x+1) [1 2 3]
16:39:06 <wagle> ERROR - Illegal Haskell 98 class constraint in inferred type
16:39:06 <wagle> *** Expression : map (\x -> x + 1) [fromInt 1 2 3]
16:39:06 <wagle> *** Type       : (Num a, Num b, Num c, Num (b -> c -> a)) => [a]
16:39:16 <flodin> odd
16:39:29 <flodin> this is from november 2003
16:40:20 <wagle> -rwxr-xr-x  1 root  3371  627040 16 Jun  2003 /sw/bin/hugs
16:40:29 <wagle> oh ok
16:40:36 <flodin> i meant :version output
16:40:50 <wagle> -- Hugs Version February 2001 
16:40:56 <wagle> oooo.
16:41:07 * wagle shoots fink again
16:41:09 <flodin> you're more than two years old laddie :P
16:41:19 <flodin> *behind
16:41:32 <wagle> its fink's fault!
16:42:03 <wagle> fink screwed up my x11 installation, then broke itself
16:42:24 <flodin> then went back in time and upgraded your hugs installation
16:42:55 <wagle> i finally (this week) got to the point that i can back myself up so i can try to unmangle my system from the damage fink did
16:43:08 <shapr> I've had good experiences with apt.
16:43:49 <wagle> they claim that X11 must overwrite the /etc/X11 and /usr/bin/X11 directories
16:55:38 <shapr> Lunar^: tout le monde est fou ...
16:58:02 <flodin> so "cannot infer instance" basically means type mismatch
16:58:34 <shapr> yah, pretty much.
16:58:42 <shapr> if you consider typeclasses as types.
16:58:54 <flodin> ok
16:59:50 <dons> I guess we could replace ghc's confusing error msgs with "type error, pretty much" ;)
16:59:58 <flodin> i don't really see the need for a distinction of typeclasses and types. Saying Num x -> Num x would work fine for me, rather than Num x => x -> x
17:00:21 <flodin> errr
17:00:26 <flodin> I mean, Num -> Num
17:00:46 <Igloo> How do you write Num a, Num b => (a, b) -> (a, b)?
17:01:02 <flodin> ah. :)
17:02:34 <flodin> that fibonacci function definition makes me feel like my brain is turned inside out
17:02:47 <flodin> who needs drugs when you have haskell
17:03:03 * shapr agrees
17:03:11 <shapr> Haskell gives a better high anyway.
17:03:17 <flodin> fib = 1 : 1 : [a + b | (a, b) <- zip fib (tail fib)]
17:03:50 <shapr> The major downside of long-term Haskell addiction is a red-faced, screaming dissatisfaction with the current software industry.
17:03:51 <dons> I like: let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20
17:04:00 <wagle> oh thats straightforword
17:04:29 <flodin> dong what's the !! 20 do?
17:04:45 <shapr> it's [1,2,3][5] in Python
17:04:48 <dons> s/ !! 20$//
17:04:58 <shapr> just item index
17:05:15 <flodin> ok, so it gets the 20th fibonacci number?
17:05:25 <shapr> yup
17:05:34 <wagle> >>> [1,2,3][5]
17:05:34 <wagle> Traceback (most recent call last):
17:05:34 <wagle>   File "<stdin>", line 1, in ?
17:05:34 <wagle> IndexError: list index out of range
17:05:37 <flodin> er, 21st
17:05:41 <dons> list comprehensions are too comprehendible ;)
17:05:48 <shapr> wagle: ah, but it mentions list index =)
17:05:59 <shapr> personally, I like "memoize' f range = ((map f range) !!)"
17:06:48 <flodin> hm, i thought haskell did memoization automatically as it saw fit
17:07:15 <shapr> That would suck in the cases where the result is large and recalculation is cheap.
17:08:03 <flodin> well, then it just needs to figure out when the result is large and recalculation is cheap ;)
17:09:18 * shapr hops cheerfully
17:09:23 <shapr> test driven development r0xx0rs
17:10:00 * shapr hugs lambdabot 
17:10:03 <dons> shapr: haRe support in yi. what do you think?
17:10:09 <shapr> hell yes!
17:10:27 <shapr> that would kick butt =)
17:10:30 <shapr> oh hey
17:10:32 <dons> I reckon!
17:10:40 <shapr> I noticed Sdf2Haskell in the HC&AR
17:10:54 <shapr> I haven't investigated yet, but it sounds nice...
17:11:19 <shapr> I'd like to investigate doing synhl with some sort of BNF-style parser generator code.
17:11:27 <shapr> What options are there?
17:12:02 <dons> hmm. sdf2haskell seems interesting
17:12:05 <shapr> Sdf2Haskell and BNFC that I know of...
17:12:26 <dons> I think synhl will be fairly flexible. 
17:12:35 <dons> though I'm not committed to any design yet
17:13:02 <dons> rough idea: synhl runs in forkIO thread, writing a parse tree to an mvar
17:13:10 <shapr> I like it.
17:13:17 <dons> the ui can consult the tree when it gets updated
17:13:37 <flodin> hee hee, stack overflow
17:13:44 <shapr> incremental anything can wait for v2.0
17:13:46 <dons> some how need to map buffer ranges to parse tree elems
17:13:50 <dons> yep.
17:14:10 <dons> also.. simonM doesn't use incrememtal parsing in his visual studio pluginn
17:14:24 <dons> he just runs the full haskell parser in a thread
17:14:38 <dons> which sounds promising
17:14:40 <shapr> I think incremental will be good at some point, but working code that's easy to change is the first priority.
17:14:55 <dons> yep.
17:14:56 <shapr> you've been hitting him up for expert advice? :-)
17:15:01 <shapr> smart
17:15:16 <dons> well, we don't want to duplicate uneeded effort
17:15:37 <shapr> I thought his code was closed source with a, um, 'difficult' license?
17:15:58 <dons> yes it is. I haven't seen the source. just rumours of how it works ;)
17:16:31 <flodin> wouldn't you need fairly smart error recovery to avoid ruining highlighting at the first syntax error
17:16:51 <flodin> unless your grammar produces a superset of the language
17:17:35 <dons> probably not too smart. most syn hl code in, say vim, gets away without anything fancy
17:17:50 <flodin> yes vim uses basically regexps
17:17:51 <dons> also. if there's an error, you're allowed to ruin the highlighting
17:17:55 <shapr> I have some fairly fancy ideas, but no point in repeating them.
17:18:11 <shapr> I think I've described them six or seven times here, and at least once on the mailing list.
17:18:16 <dons> yep
17:18:22 <flodin> shapr: time to implement, then ;)
17:18:27 <shapr> not yet :-)
17:18:27 <Igloo> Most syn hl code in vim and emacs breaks horribly even when the input is valid IME  :-)
17:18:33 <shapr> still a bit of the editor left yet to write up.
17:18:51 <shapr> regex based synhl code is ...less than adequate.
17:19:17 <Igloo> Incremental isn't so important if you're doing it in separate thread, although starting from the middle would be nice, and knowing you can stop before the end will save some cycles
17:19:36 <dons> yi is already multithreaded, so it won't be too hard at all
17:19:51 <dons> the ui and input reader run in their own threads right now
17:19:54 <shapr> I've read six or ten papers about incremental parsing, bunches of different strategies available.
17:19:55 <Igloo> But parser-based syn hl also has issues unless you have some nice error recovery
17:20:24 * shapr shrugs
17:20:35 <dons> but there's nothing to big that would break this approach, I think.
17:20:46 <shapr> imho, parser based modes have more pros than cons
17:21:06 <Igloo> Especially given the layout rule, where a parse error will change the implicit layout. Dear god  :-)
17:21:06 <shapr> but hey, feel free to submit code for regex based synhl =)
17:21:45 * Igloo will if no-one else has done by the time i get some time, but I have a lot of other things that need finishing off first
17:21:57 <dons> sure.
17:22:22 <dons> atm I'm just trying to work out a good way to get from a synhl abs syn tree to a 2d ui with colours
17:22:46 <Igloo> That's the other thing - the parser has to keep all the white space around
17:22:48 <dons> how to inspect the abs syn, for the colours of the chars on the screen
17:23:23 <dons> Igloo. maybe. or maybe we can consult both the lexer and parser. not sure
17:23:33 <shapr> The parse tree nodes should keep their input position?
17:24:03 <dons> certainly.
17:24:43 <shapr> or, as you said.. consult both and stick them together into an output
17:24:49 <shapr> I like that approach
17:24:53 <tuomov> lazyness should pretty much remove the need for stopping optimisations
17:25:03 <shapr> hei tuomov
17:25:13 <dons> that's easy. now, given a point in the buffer, find the coloured token that the point lives inside
17:25:14 <shapr> How's the sunny south treating you?
17:25:15 * shapr grins
17:25:33 <tuomov> sunny?
17:25:44 <Igloo> tuomov: That's not the sort of stopping I meant
17:25:47 <tuomov> -6.0C, cloudy
17:26:00 <shapr> Well, you guys get more sun at this time of year.
17:26:18 <tuomov> dark comes at around 16:00
17:26:18 <shapr> -20C, clear because all the clouds froze right outta the sky =)
17:26:31 <shapr> we get it about 14:30 or so
17:26:34 <Igloo> I meant that if last time you produced 1,2,3,4,5 for the input "abcde", then the text is changed to "axcde", if you find the new output starts 1,8,3 then you know that the 4,5 hasn't changed
17:26:53 <shapr> But then, noon isn't exactly blinding this time of year.
17:26:55 <Igloo> Where the numbers represent lexer/parser states
17:27:28 <dons> good point. that's a bit tricky
17:29:05 <Igloo> For the parser you pretty much have to be able to stop and start for something like lhs with tex
17:29:33 <tuomov> well, if you take my theory of buffers approach.. :)
17:29:48 <tuomov> you have separate paths for the two languages
17:29:52 <Igloo> (or reject a set of programs as unreasonable and parse function by function)
17:30:09 <Igloo> "paths"?
17:30:15 <dons> tuomov: I just don't have a good way to implement that from where we are now.
17:30:23 <Igloo> Oh, you mean treat it as 2 interleaved streams of lines? Hmm
17:30:37 <tuomov> yeah, it would need some more thought
17:30:53 <tuomov> it isn't something that is quickly hacked together
17:30:55 <Igloo> No, I think for just syn hl it would just work well
17:31:05 <tuomov> I mean the whole theory of buffers
17:31:20 * Igloo still hasn't read that
17:31:30 <shapr> I think we should start just being able to synhl a buffer of only one flavor.
17:31:48 <Igloo> Although it would be a bit harder to get right in more complicated interleavings, like JS and HTML
17:31:57 <tuomov> yes, and then write combining parsers
17:32:12 <tuomov> text-lp, cpp etc.
17:32:17 <tuomov> -
17:32:18 <Igloo> Remind me what licence yi is under?
17:32:18 <tuomov> t
17:32:31 <dons> combining parsers  may not be too hard (we currently can combine ctk lexers with >||<)
17:32:53 <dons> so, depending on which parser you use, it may not be too hard.
17:32:53 <shapr> if you have a javascript parser, just plug it into the  <script></script> tag parser.
17:33:14 <dons> yi is gpl
17:33:17 <shapr> yay
17:33:23 * shapr cheers for the GPL
17:33:50 <Igloo> shapr: the difficult case is where the JS engine is in the middle of parsing something from the previous script tag, though (dunno if that's possible in that case)
17:33:57 <Lunar^> shapr: pourquoi dis-tu que " tout le monde est fou " ?
17:33:59 <Igloo> ta
17:34:00 <shapr> btw, what's the path towards editing the code of yi in yi and dynamically reloading the whole thing without losing editor state?
17:34:20 <shapr> Lunar^: je lis ton blog
17:35:00 <Lunar^> shapr: yesterday's quote from Knuth is cool, isn't it ?
17:35:01 <shapr> Igloo: true
17:35:06 <shapr> vraiment =)
17:35:11 <shapr> c'est chouette
17:35:19 <Lunar^> Wikipedia is such a huge project
17:35:20 <Igloo> Knuth quote?
17:35:27 <dons> there's a fairly easy path to reload stuff. maintaining state should be possible (j.launchbury asked me this at icfp) as long as all the relevant state can be captured somehow
17:35:44 <Lunar^> I plan to contribute to the french Haskell page, it's pretty lossy currently
17:35:58 <shapr> Lunar^: http://c2.com/cgi/wiki?ProgrammingIsForNighttime
17:36:05 <dons> i'm not sure if we really want to dyn reload yi-core though.
17:36:09 <Igloo> Should be easy enough for each module to be told to do its bit, with a helper module to abstract the commonness
17:36:14 <shapr> yes we do!
17:36:32 <Lunar^> dons: Maybe that could be a good argument for the current thread about module IORefs
17:36:35 <shapr> How else to edit yi core?
17:37:13 <Igloo> Isn't yi-core meant to be teeny weeny?
17:37:15 <dons> well. i guess we just reload HSyi.o
17:37:18 <shapr> the other alternative is to write Yi in a 'scripting' language and recompile the core
17:37:18 <dons> not too hard
17:37:41 <shapr> if HSyi.o can really be reloaded, Yi is actually *more* dynamic than emacs.
17:37:54 <shapr> Once that works, I will gloat horribly on #emacs
17:38:02 <shapr> well, maybe viciously
17:38:06 <shapr> not horribly
17:38:15 <Igloo> It's not that useful, anyway. If all the modules can store and load their state then you can just do a mass store, rerun the executable and mass-load
17:38:19 <dons> well, it currently is dyn loaded. I haven't played too much with reloading libs though, just modules. but there's no obvious problem there
17:39:10 <shapr> Is there a keybinding for hs-plugins make?
17:39:33 <dons> not yet. i've got a yi branch for the make/eval stuff yet to be integrated
17:39:38 <shapr> er, I mean... something like hs-plugins make <module>
17:39:45 <shapr> Can I try that branch? =)
17:40:00 <dons> i'll merge it in a few days
17:40:02 <shapr> ok
17:40:06 <Lunar^> ok, enough Zelda playing, I'm bulding yi
17:40:13 <dons> what do you want to do with make() ?/
17:40:22 <dons> just compile a module?
17:40:24 <shapr> The make/eval part is exciting.
17:40:34 <shapr> I want to be able to edit parts of Yi, and then 'reload' them.
17:40:51 <shapr> like elisp in emacs, I can completely rewrite emacs while it's running.
17:41:03 <dons> ok. looks like linking hell for me, then.
17:41:06 <shapr> Of course, my past attempts usually result in a non-working editor very quickly, but hey...
17:41:22 <shapr> linking hell?
17:41:25 * shapr grins
17:41:26 <shapr> sounds painful
17:42:00 <dons> nah. you just either end up loading a library twice, or a module twice, due to some dependency issue that I hadn't thought about
17:42:11 <shapr> what sort of dependency issue?
17:42:42 <shapr> Is the dynamic vs static type-table problem?
17:42:54 * shapr doesn't think so
17:43:20 <dons> for example, loading a piece of yi into itself, again, loads some module Foo. which depends on HSyi.o, which is  dutifully loaded. but then the rts crashes because it was HSyi.o that did the load in the first place, so it got loaded twice.
17:43:35 <dons> the problem is that hs-plugins' load() is sometimes to smart
17:43:36 <shapr> oh
17:43:37 <dons> too smart
17:43:51 <shapr> so, you have to save state to disk and rebootstrap?
17:43:54 <shapr> or what?
17:43:57 <dons> so we go a bit lower down and control the individual loads by hand, easy enough
17:44:17 <shapr> a load scheduler that can't be reloaded?
17:44:32 <dons> that's a good idea.
17:44:39 <Lunar^> dons: is this an hs-plugins limit or an RTS limit ?
17:44:45 <shapr> sounds like JVM's class loader
17:44:52 <dons> rts limit.
17:45:01 <dons> not really a limit. 
17:45:07 <Lunar^> dons: It should keep track of currently loaded module ?
17:45:20 <shapr> From one viewpoint, the class loader is the most basic part of the JVM. You can change everything but that.
17:45:26 <dons> hs-plugins does. but not currently loaded libraries.
17:45:47 <dons> shapr: yep. so a similar thing would be a good way to go.
17:45:49 <shapr> Additional class loaders can be unloaded and reloaded, but the 'boot' loader is inviolate.
17:46:21 <dons> well, our boot loader is always there. we could always jump back to it, I guess
17:46:32 <shapr> Hm, neat idea.
17:46:41 * Lunar^ reads the hs-plugins paper
17:46:41 <shapr> Yes, I like that.
17:46:44 <dons> then restoring state somehow. hmm. sounds nasty
17:46:58 <shapr> the boot loader loads something sensible like Boot.hs, which lists the modules to load?
17:47:00 <shapr> well, maybe
17:47:07 <dons> but we could at least reload HSyi.o the nice way.
17:47:08 <shapr> yah, state restoring is the scary part.
17:47:53 <dons> but all the state is in the Editor.environment value (all the important stuff anyway)
17:47:55 <shapr> Unless yi modules require serializable statefulness
17:48:02 <dons> I could probably restore that fairly easily
17:48:20 <dons> you'd get back your open files and windows, at least
17:48:26 <shapr> that would be cool
17:48:31 <shapr> Quite cool
17:48:58 <Lunar^> Where does yi name come from, btw ?
17:48:59 <shapr> So you could hit the reload button, and if HSyi.o is involved the editor 'reboots' and comes back where you left it.
17:49:19 <dons> yes.  I think it could be done.
17:49:19 <shapr> We were talking about recursive names like HURD and GNU
17:49:32 <shapr> dons: that is a sexy feature =)
17:49:45 <shapr> and I will gloat viciously on #emacs when it works
17:50:08 <dons> we unload the library, and enter the "Starting up dynamic haskell ..." code. hmm. sounds good
17:50:10 <shapr> oh you can't edit the C part of your editor without manual recompilation? I'm so sorry.
17:50:13 * shapr cackles evilly
17:50:37 <shapr> Lunar^: @eval Y I
17:50:56 <dons> @eval Y I
17:51:16 <dons> oh. it worked before. hmm
17:51:21 <lambdabot> out of fuel - use @resume to continue
17:51:23 <shapr> It's still working =)
17:51:26 <dons> there we go ;)
17:51:31 <shapr> I could see lambdabot 93% on top
17:51:38 <Lunar^> what's I already ?
17:51:40 <shapr> @get-definition I
17:51:41 <lambdabot> I = \x.x
17:51:48 <shapr> @get-definition Y
17:51:48 <lambdabot> Y = \f.U(\g.f(U g))
17:52:00 <shapr> So, if you like recursive names...
17:52:10 <Lunar^> yeah :)
17:52:19 <shapr> Pseudonym suggested yi
17:52:45 <shapr> Also, yi is much like vi, and yi is the Confucian "Source of all Righteousness" as discovered by tuomov 
17:52:59 <Igloo> @get-definition U
17:52:59 <lambdabot> U = \f. f f
17:53:07 <dons> i'll work out a little design for this core-reloading. actually seems easier than other kinds of dyn loading we could do (as I already know how to load the core). fun fun
17:53:18 * shapr bounces cheerfully
17:53:29 <shapr> I bet chilli loves this.
17:53:30 <Lunar^> Is lambdabot CBN or CBV ? 
17:53:41 * shapr doesn't know.
17:54:13 <Lunar^> That's really cool :)
17:54:30 <shapr> have you tried yi yet?
17:54:47 <Lunar^> darcs just came back with code
17:54:48 <shapr> I suggested Yi on the epigram mailing list, where they don't want to write their own editor.
17:55:20 <dons> oh. any feedback?/
17:55:22 * Igloo gets confused by copyrights
17:55:39 <Igloo> If I get a BSD program from X, can I give it to Y under the GPL?
17:56:08 <shapr> nah, the epigram guys didn't say anything yet.
17:56:36 <Lunar^> Igloo: IIRC, yes
17:57:03 <shapr> Can't you only relicense something that you own the copyright on?
17:57:03 <Igloo> But the BSD3 says "Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer."
17:57:14 <dons> you would have to keep the bsd copyright.
17:57:30 <Igloo> But http://www.gnu.org/licenses/gpl-faq.html#TOCMereAggregation says "If either part is covered by the GPL, the whole combination must also be released under the GPL"
17:57:48 <shrimpx> it's a VIRUS
17:57:54 <shapr> It's a vaccine =)
17:58:18 <Igloo> Why does it all have to be so complicated?
17:59:01 <shapr> Because programmers didn't design the system.
17:59:11 <Lunar^> Igloo: beacuse lawyers need to eat
17:59:17 <shapr> haha
17:59:27 <Igloo> I've seen some things designed by programmers...
17:59:36 <shapr> Even the cheapest patent litigation can cost $500,000
17:59:48 <shapr> that's a quote from "The Patent Game" by ... oh I forget.
17:59:53 <shapr> but I have the reference.
18:00:12 <shapr> Igloo: ok, SPJ didn't design the copyright/patent system :-P
18:00:19 <Igloo> "cheapest [...] can cost" reads wrongly to me
18:00:22 <Igloo> :-)
18:00:59 <shapr> ah right, "The Cost of a even a simple patent litigation suit may exceed $500,000." -- The Patent Guide by Carl W. Battle
18:01:43 <Igloo> Ah, that way round sounds better. Well, worse, but it makes more sense  :-)
18:01:45 * Lunar^ builds hs-plugins
18:01:55 <shapr> let's see, we start a fund to get SPJ to design a simple combinatoric intellectual property language....
18:02:22 <Lunar^> shapr: cloning would be better
18:02:45 <shapr> Then we carefully apply Gdel's Incompleteness theorem to find the most demonic license possible, and apply that to all of our sources.
18:03:17 <shapr> "Even seeing the text of this license from a distance means that you agree to ..."
18:03:29 <dons> hehe.
18:03:35 <Igloo> There are already recursive licences. I think the CC ones are examples
18:03:41 <Lunar^> shapr: Ever read Krivine's papers on how Gdel's theorem is a decompiler when used towards Curry-Howard isomorphism ?
18:03:56 <shapr> No, but I'm not sure I would survive the experience.
18:04:10 <shapr> Even so, it sounds like the ultimate mental roller-coaster.. I want URLs!
18:04:24 * shapr googles
18:04:27 <Lunar^> shapr: I have this only on real paper (and in french too)
18:04:40 <Lunar^> http://www.pps.jussieu.fr/~krivine/
18:04:42 <shapr> je lis un peu franais!
18:05:20 <Lunar^> Nothing on what I am talking though
18:05:30 <shapr> Of course, any paper that's discussing the connection between Gdel's Incompleteness Theorem and the Curry-Howard Isomorphism is probably beyond my *english* much less my french.
18:06:16 * dons starts hacking reloadable-yi
18:06:21 <tuomov> I don't like it when people mention this kind of interesting things!
18:06:23 <shapr> Lunar^: what's the title?
18:06:27 <tuomov> It adds to my already huge reading list
18:06:31 <Lunar^> http://www.afia.polytechnique.fr/node.php?lang=en&node=246
18:07:00 <Lunar^> He had compared it with fsck that time
18:07:11 <shapr> huh?
18:07:36 <Lunar^> shapr: fsck checks for file completeness, isn't it ?
18:07:57 <shapr> err, sort of...
18:08:02 <shapr> consistency
18:08:04 <shapr> not really completeness
18:08:54 <shapr> Maybe I should ask bea to translate this for me.
18:08:58 * shapr chuckles evilly.
18:09:10 * shapr already knows the answer she'd give.
18:10:09 <Lunar^> :)
18:10:19 <shapr> What's the title of the hardcopy paper you have?
18:11:24 <shapr> la dm||| 
18:11:58 <dm|||> ola
18:12:16 <dm|||> i'm actually a dm's friend we were having a dm day in other channel :P
18:12:37 <Lunar^> shapr: http://www.pps.jussieu.fr/~krivine/articles/ens_prv.pdf
18:12:40 <Lunar^> got it
18:13:02 * Lunar^ got hs-plugins
18:13:36 <dons> what OS you on?
18:13:45 <dons> (just likes to know)
18:13:56 <Lunar^> dons: Mac OS X right now
18:14:01 <Lunar^> plugs works
18:14:10 <dons> cool. then it should all run fine
18:14:38 <dons> it gets tested quite well on the mac by seafood
18:14:41 <Lunar^> dons: I think that the magical Wolfgang added support for GHCi on Linux/PPC
18:14:59 <dons> true. cool. one more platform!
18:15:14 <Lunar^> dons: I should try to build GHC CVS next time I boot in Linux
18:15:21 <shapr> huh, this is quite readable.
18:15:52 <Lunar^> autoreconf made a lot of warnings :)
18:16:00 <shapr> I don't know if I'd compare mathematicians to bugs though.
18:16:03 <Lunar^> I hate autotools
18:16:53 * shapr likes french
18:17:13 <shapr> Lunar^: what's preuves ?
18:17:13 <dons> a lot of warnings. hmm. yi or hs-plugins?
18:17:16 <shapr> proofs?
18:17:26 <tuomov> would seem so
18:17:41 <Lunar^> dons: hs-plugins' make install doesn't register the plugins package with GHC ?
18:17:46 <Lunar^> dons: yi
18:17:49 <dons> nope. 'make register'
18:18:07 <Lunar^> (should have I read the doc before? ;) )
18:18:29 <dons> ok. hasn't been tested on the mac with the new autoconf stuff. you could send me the output of ./configure, if you'd like.
18:19:00 <dons> have to separate 'make install' and 'make register' for port tree installation
18:19:31 <Lunar^> dons: all about underquoted definitions for the warnings
18:20:02 <dons> oh. weird. please send the configure output then.
18:20:24 <dons> it's quite a simple configure script, so nothing too hard to fix
18:20:30 <shapr> what's the theory de ensembles? the theory of togetherness? This sounds like an environmentalist movement.
18:20:51 <shapr> oh, I think I seee
18:20:58 <Lunar^> shapr:  ensembles  is "sets" 
18:21:02 <shapr> it's the pursuit of Russell and Whitehead..
18:21:04 <shapr> ah, ok!
18:21:45 <tuomov> the text is surprisingly readable with me rusty and small knowledge of french
18:21:48 <shapr> I probably have a french dictionary around here somewhere, I could use it =)
18:21:49 <tuomov> s/me/my/
18:21:53 <shapr> yah, I was thinking the same thing.
18:21:57 <tuomov> I have access to online dictionary
18:22:05 <Lunar^> tuomov: Krivine is a good writer, really
18:22:49 <Lunar^> ranlib libHSyi.a
18:22:50 <Lunar^> ranlib: file: libHSyi.a(CWString_hsc.o) has no symbols
18:22:52 <Lunar^> strange
18:23:14 <shapr> wasn't that mentioned on one of the mailing lists? or maybe here on #haskell?
18:23:22 <shapr> something about running ranlib manually maybe?
18:23:43 <dons> yeah. on the mac. who was that?
18:23:44 <shapr> j'oublie
18:23:49 <shapr> I forget
18:23:59 * shapr thinks oubliette is such a cool word.
18:24:06 <Lunar^> dons: I did it for libHSplugins.a and other before
18:24:31 <shapr> then it was probably Lunar^ who said that.
18:24:44 <dons> leimy
18:25:05 <dons> he sent a patch :)
18:25:12 <Lunar^> yi-static runs
18:25:16 <Lunar^> yi-inplace failds
18:25:37 <Lunar^> The "help" command is unknown. :)
18:25:51 <dons> ok. yi-inplace: that's the dyn loader. leimy mentioned that too.
18:26:04 <dons> there's no help. there's a lot of vim though
18:26:22 <dons> well, a lot of vi
18:26:31 <dons> with some vimish behaviour
18:26:54 <dons> 2d3} etc
18:27:06 <Lunar^> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
18:27:07 <Lunar^>    __module_registered
18:27:10 <Lunar^> definitely
18:27:17 <dons> yep. that's what leimy said too. 
18:27:33 <dons> unknown cause. but something funny about how HSyi.o is built
18:27:37 <Lunar^> The Mach-O object leading is such a mess
18:27:43 <Lunar^> loading
18:28:10 <dons> doesn't happen when ghc builds it's .o archives, though. so seems fixable
18:28:49 <dons> just need access to ozone's mac.
18:28:59 <Lunar^> Is there already undo support ?
18:29:17 <dons> nope. soon, soon.
18:29:23 <dons> i've got a plan for it
18:29:37 <Lunar^> I always wondered what was an efficient representation for undos
18:29:49 <dons> there's an alternative undo design in Emacs.hs
18:30:51 <dons> there's so many tasks building an editor. i'm writing 5 patches a day for 37 days, and there's still heaps to do.
18:30:54 <Lunar^> chan and threads, like hOp's drivers :)
18:31:08 <dons> but at least we've got most of vi in around 500 lines of lexer code
18:31:14 <Lunar^> :)
18:31:20 <dons> whereas vi is 18,000 lines of C
18:31:31 <Lunar^> great work, anyway
18:32:05 * Lunar^ hopes Wolfgang makes PIC really working quite soon
18:32:15 <dons> yes! that would be great
18:32:24 <dons> but it already works for the mac.
18:32:34 <Lunar^> because the 18,000 line of C make a really small executable whereas it's not yi's case
18:32:52 <dons> it's around 600k on linux. how big on the mac?
18:33:19 <Lunar^> 1M
18:33:26 <dons> hello-world with wolfgang's PIC on the mac was 6k I think.
18:33:31 <Lunar^> \o/ :)
18:34:13 <dons> yep. most of yi is libraries. so PIC would be nice. would make some of hs-plugins obsolete
18:34:14 <Lunar^> I wonder how did Malcom Wallace for embeded systems
18:34:30 <Lunar^> but he was not using GHC though
18:34:33 <dons> nhc98 generates smaller binaries anyway.
18:34:43 <Lunar^> what part ?
18:35:09 <dons> hello world is 128k with nhc98 on linux
18:35:20 <dons> so that's about 1/4 of ghc's size
18:35:21 <Lunar^> uh that's far better
18:36:01 <Igloo> portable PIC would be even nicer, though  :-/
18:36:23 <Lunar^> Igloo: portable accross ?
18:36:51 <Igloo> I mean so PIC works without special code on different arch/OSs
18:37:27 <dons> this is scary. I've jumped into dynamic land in yi, now I'm going to jump back to static land to reboot the dynamic code.
18:37:39 <Lunar^> :)
18:39:36 * shapr cheers
18:40:22 <Lunar^> dons: This is great code ! Really easy to understand
18:40:57 <dons> oh, great :) what are you reading?
18:41:02 <Lunar^> Core.hs
18:44:05 <shapr> Ya know, the curl and zlib bindings in darcs would be really handy if separated out.
18:44:36 <dons> I was hoping you'd say FastBuffer.hs (shapr used to say it was scary, as at one point I was throwing unsafeCoerce# all over the place)
18:44:53 <Lunar^> tuomov: I've tried riot, btw
18:45:36 <Lunar^> tuomov: Have you planed other features on top of what it is today ?
18:45:42 <shapr> I am impressed with FastBuffer.hs
18:45:56 * Lunar^ jumps on FastBuffer.hs
18:46:31 <dons> it's much nicer, and 20% faster to load 64M files :)
18:47:06 * shapr wants Wget.hs
18:47:41 <dons> you could use that http module that's in the lambdabot fork I've got
18:47:41 <shapr> hm, I think darcs just flipped out.
18:47:51 <shapr> ah, good point!
18:48:20 <dons> I should update that repo. my local bot does a lot of other things these days
18:48:31 <dons> hmm. goes on the todo list
18:48:40 <shapr> I should add your gpg key to the lambdabot repo...
18:48:52 <shapr> once I update the repo with the patches you sent me last =)
18:49:18 <shapr> I got partway into that and got distracted, as usual.
18:49:37 <dons> oh yeah. they're not even darcs patches though. I should send some nice darcsian patches now
18:49:57 <dons> MiniHTTP.hs, that's it
18:50:01 <shapr> would mean you'd have to integrate what you've got with the existing repo
18:50:19 <Lunar^> dons: shouldn't 2048 magic number be named ?
18:50:26 <dons> yep, it should be
18:50:34 <shapr> Lunar^: fix it! send in a patch!
18:50:37 <dons> it's there to remind me to kill it
18:50:54 <dons> it's an arbitrary number though, not really magic
18:51:16 <dons> just how much bigger than the file we'd like the buffer max to start at
18:51:48 <shapr> who wrote MiniHTTP?
18:51:53 * shapr grins at "-- not written by sjw or dons"
18:52:04 <dons> hmm. New Zealander... let me see..
18:52:06 <shapr> Haven't I seen sjw on #haskell once or twice?
18:52:11 <shapr> Oh, Warrick Grey?
18:52:19 <shapr> the HTTP.hs guy
18:53:04 <dons> on post-emacs, anyway. he's an OS microkernel hacker, now working on OS-support for language safety
18:53:31 <shapr> "OS-support for language safety" ?
18:53:36 <dons> he's using Haskell to write a binary rewriter atm. It turns an ELF binary into one where the jumps are statically safe
18:53:43 <shapr> oh cool!
18:54:13 <shapr> Is he investigating region allocation a la MoscowML also?
18:54:15 <dons> so jumps are rewritten into jumps to code that checks the address in some way
18:54:23 <Igloo> Rejecting binaries that play nasty rewriting tricks and suchlike, presumably?
18:54:35 <dons> yep. 
18:54:40 <Igloo> Ah, so dynamically safe really?
18:55:05 <dons> yeah, I should have said that. his work is the dynamic safety for stuff the compiler can't check
18:55:09 <shapr> Region allocation is a cool efficiency trick, but more importantly it should improve safety.
18:55:48 <shapr> Things like region allocation support my disagreement with "Worse is Better".
18:55:55 <wagle> i dont "get" region allocation..  what if the thing i want to overrun is in my region?
18:56:14 <Lunar^> dons: There is no downward resize for fastbuffer, currently ?
18:56:15 <shapr> wagle: huh?
18:56:19 <dons> he also wrote a GHC Core implementation in the twelf theorem prover
18:56:34 <shapr> dons: wow, his rep must be as good as yours...
18:56:35 <dons> it was the slowest implementation that ever ran :)
18:56:52 <wagle> dons: who did?
18:57:10 * shapr first heard about dons at ICFP03
18:57:15 <dons> sjw, Simon Winwood. 
18:57:26 <dons> http://www.cse.unsw.edu.au/~sjw/
18:57:43 <dons> scary, shapr. I didn't go to '03
18:58:07 <dons> oh good. he's got the twelf code for Core up.
18:58:35 <Lunar^> dons: FastBuffer is not scarry. It's low level Haskell code, I'm used to it now. What are the FFI functions for?
18:58:37 <dons> Lunar^: no.
18:58:42 <dons> no way to downsize
18:58:54 <dons> it used to be scary ;)
18:58:59 <dons> it's tame now
18:59:11 <shapr> unsafeCoerce# gives me nightmares.
18:59:16 <dons> there were 5 unsafeCoerces#
18:59:46 <dons> sometimes we need to recalculate the current line, so they just zip around the buffer using a C ptr loop
18:59:52 <Lunar^> unsafeCoerce# are like C casts, there's plenty in every applications you are currently using :)
19:00:37 <shapr> I keep the wires for my computer inside a pretty case... ;-)
19:00:47 <Lunar^> dons: so FFI calls are replacing unsafeCoerce#s ?
19:01:18 <dons> Ptr replacess unsafeCoerce# of MutableByteArray#
19:01:28 <dons> more ffi, less unsafeCoerce#, yep
19:01:43 * shapr blows off steam at heatsink 
19:01:47 <wagle> grrrrrr..  the tarball unpacks into a completely different dir that the name of the tarball
19:01:59 <Lunar^> dons: IIRC, FFI calls are not really fast
19:02:21 <Lunar^> dons: But anyway, even FastBuffer is quite readable now
19:02:33 <heatsink> shapr hot under the collar?
19:02:43 <dons> sure. but when walking a 64M buffer, the cost is negligible
19:02:52 <dons> they're not called very often
19:02:53 <shapr> heatsink: well, not really... 
19:03:12 <wagle> "the GHC intermediate format based on system F"?  whoa
19:03:23 <tuomov> Lunar^: there are some plans, but I don't know when I'll next get into a coding mood.. too much other thinking to do atm
19:03:29 <shapr> Core is going away though, what's the new IL?
19:04:14 <dons> Core is going away?
19:04:19 <Lunar^> tuomov: I know that feeling. :) But I was planing to code a TODO manager some day, but riot doesn't really is what I want : I can't see any real advantage toward a simple text file
19:04:33 <Lunar^> tuomov: Anyway, the name gave thrills to some friends :)
19:04:41 <shapr> dons: I thought so... Josef Svenningson mentioned that on ghc-users, didn't he?
19:04:58 <dons> hmm. something about dependent types?
19:05:32 <Lunar^> dons: Using a Lexer for keys, how cool
19:05:34 <shapr> oh, external core
19:05:43 <dons> oh, that was it.
19:05:55 <dons> yes, chalmers is going to take over ext-core
19:05:58 <dons> very good news
19:06:09 <wagle> i want a todo manager that uses a graph insteaad of a tree
19:06:17 <shapr> me too
19:06:22 <shapr> a DAG
19:06:23 <dons> Lunary^: glad you like it. I think it is great too :)
19:06:37 <Lunar^> dons: I should use that for hOp
19:06:49 <wagle> i deliberately avoided saying sdag for some reason
19:06:56 <wagle> i deliberately avoided saying dag for some reason
19:06:58 <dons> we end up with comprehensible descriptions of key bindings for, say, vi.
19:07:13 <dons> whereas they just have textual descriptions otherwise.
19:07:20 <Lunar^> dons: That's exactly what I was trying to get
19:07:39 <Lunar^> Yi could make a great shell
19:07:41 <Lunar^> dammit :)
19:07:45 <shapr> wagle: reminds me ... At EuroPython 2004 I was talking to a guy who built a make replacement in Python, I asked him if he used DAGs, and he said "I didn't use any heavy theory."
19:08:12 <Lunar^> shapr: lol
19:08:17 <dons> oh. a shell. that's interesting. we need a cmd-line gui.
19:08:28 <dons> then you just write a binding for, say, sed 
19:08:28 <wagle> alas poor softwarecarpentry.org...
19:08:40 <tuomov> I want to start coding again, but I really should decide What To Do Next, and so I don't get around to coding
19:08:56 <shapr> I was thinking "This guy has a four year degree in CS, and I nearly finished my two year degree in computer art..."
19:09:08 <Lunar^> Anybody ever eard on a ZZstructures impl. for Haskell ?
19:09:26 <Lunar^> I think ned was working on one, but I don't know how far he got
19:09:43 <wagle> they had a contest for people to come up with the best replacements for make, automake, etc..  they announced the winners, then the funding agency had them remove everything
19:09:54 <shapr> SCons won that contest.
19:10:01 <shapr> but I think maak might be better.
19:10:10 <shapr> maak is written in Haskell of course =)
19:10:22 <Lunar^> dons: I wonder how to get FastBuffers working with color highlighting though
19:10:27 <shapr> but I haven't gotten it to compile recently...
19:10:54 <dons> Lunar^: that's in the ui, atm.
19:11:17 <dons> the syn hl thread wouldn't write to the buffer
19:11:36 <wagle> anything that doesntg use "heavy theory" is likely doomed to failure / repetion-of-history
19:11:41 <Lunar^> mhhh yeah text files 
19:11:43 <dons> but you could write a ColouredBuffer on top of a FastBuffer, I guess
19:11:54 <Lunar^> WeakPointers !
19:11:58 <shapr> wagle: I agree
19:12:13 <wagle> so whats the best toolkit for slamming together guis in haskell?
19:12:25 <dons> but we need parse trees anyway, for indent mode. So the parser/synhl output will be stored else where
19:12:26 <Lunar^> wagle: WxHaskell?
19:12:41 <shapr> I was actually just trying to make polite conversation with the guy, I thought he'd enthusiastically discuss the pros and cons of DAGs as applied to make replacements.
19:13:18 <Lunar^> dons: using WeakPointer, I think we could manage to get it quite well on memory foot print
19:13:57 <shapr> Quite a few people asked me if I was giving a presentation at EuroPython. After seeing all the talks this time, I think I might give a talk next year. I'll try not to get lynched...
19:14:18 <dons> Lunar^: oh.. good idea. I need to think about this.
19:14:20 <Lunar^> shapr: Bea did'nt :)
19:14:36 <Lunar^> shapr: But she might be the lyncher :)
19:14:40 * shapr laughs
19:14:59 <Lunar^> dons: reclaimable lazyness
19:15:12 <Lunar^> dons: If you see what I mean
19:15:13 <shapr> my talk would probably be on how Python needs to go back to the good old days of simplicity of use, if not simplicity of implementation.
19:15:55 <shapr> I would get rid of +=, list comps, etc etc
19:16:23 <tuomov> lua has managed to stay quit simple, and even get simpler by the time
19:16:27 <shapr> I know they're useful, but power users aren't the most important audience for Python.
19:16:27 <Lunar^> shapr: They would argue to remove lambdas !
19:16:38 <shapr> yah, getting rid of lambdas would be stupid.
19:17:02 <dons> so what would the key and value of the weak pointer be?
19:17:16 <shapr> I really liked Python 1.5, I learned it in something less than eight hours.
19:17:26 <dons> do parser trees map to buffers, or tokens to buffr ranges. or is it the other way around. hmm
19:17:57 <shapr> 9:00am - Java is my favorite language. 9:30am - I decide to investigate Python. 5:00pm Python is my favorite language.
19:18:15 <heatsink> *lol*
19:18:17 <tuomov> synhl . parser . buffer = colouredbuffer
19:19:08 <dons> that's true. and there's a lexer in there. some languages only need lexers to get good synhl
19:19:47 <tuomov> parser=parser+lexer
19:20:23 <Lunar^> dons: value is the parsed tree, for sure
19:20:46 <wagle> hmm..  wxhaskell appears to be less than on friendly terms with macosx
19:21:02 <shapr> Lunar^: have you spoken to Jerzy IRL?
19:21:22 <dons> ok. so this is just to get the nice association. and we can use ranges in syn tree fields to map back to colours of buffer portions
19:21:24 <Lunar^> dons: I'm used to Java's WeakPointers where there is nothing like this key
19:21:42 <Lunar^> shapr: once, in his office, like 4 years ago
19:21:58 <Lunar^> shapr: It was one hour of great talk, he's really kind
19:22:12 <shapr> Is he as funny in speech as in email?
19:22:18 <Lunar^> yeah
19:22:34 <shapr> Makes me wish I could understand french well enough to get all his jokes.
19:23:44 <wagle> what do you guys think of fudgets (and in comparison to wxhaskell)?
19:24:12 <shapr> imho, fudgets is more about reactivity than about widgets
19:24:27 <Lunar^> dons: mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k) -- A specialised version of mkWeak, where the key and the value are the same object
19:24:39 <shapr> Fudgets is more like wrapping Yampa around wxHaskell.
19:25:03 <shapr> wxHaskell is a widget toolkit binding, Fudgets has a whole philosophy.
19:25:05 <wagle> hahaha..  what is yampa?
19:25:13 * wagle starts googling
19:25:20 <shapr> http://www.haskell.org/yampa/
19:25:34 <shapr> It's the most recent incarnation of AFRP/FRP/etc
19:25:41 <Lunar^> dons: Then it's just having a parse tree with weak pointers at place we can safely rebuild the tree in a context independant way
19:25:42 <shapr> "reactive functional programming"
19:26:39 <Lunar^> dons: What do you think ?
19:26:41 <wagle> yeah
19:26:55 <dons> interesting. I have to work out how to use this.
19:27:06 <wagle> welp, almost out of battery
19:27:12 <shapr> g'bye :-)
19:27:13 <dons> but it sounds reasonable.
19:28:20 <Lunar^> history with weak pointers could be cool too
19:28:48 <Lunar^> like you can specify Yi to retain at least the 100 last actions, but if it can store more...
19:30:08 <dons> hmm. ok. i have to think about this. i haven't used weak ptrs at all, so I can't say how they'll fit it.
19:31:04 <Lunar^> I wonder if anyone ever used that in Haskell
19:31:21 <Lunar^> it's not much used in Java's world, so...
19:40:14 <shapr> salut matju
19:43:20 <dons> Lunar^: can you send me the ./configure output of yi on the mac?
19:44:44 <dons> zgrep -h dons@ _darcs/patches/* | sed -n 's/\*.*$//;1p'  ;)
19:44:59 <Lunar^> dons: autoreconf you mean ?
19:45:23 <dons> did that produce errors? if so, yes please. and ./configure too.
19:45:28 <Lunar^> uhhhhh
19:45:38 <Lunar^> It's not in any way related to Yi !
19:46:03 <Lunar^> My fink tree is just too old for the latest autoconf
19:46:08 <Lunar^> sorry
19:46:08 <dons> oh. ok.
19:46:19 <Lunar^> Should have read better last time :)
19:46:20 <dons> so I should set a autoconf version limit in ./configure.ac
19:46:42 <dons> what autoconf version do you have?
19:46:59 <Lunar^> dons: Don't worry about my crappy set up
19:47:31 <Lunar^> autoreconf (GNU Autoconf) 2.59
19:47:31 <dons> sigh. someone else will just complain about the same errors, though... 
19:47:40 <dons> hm. ok. 2.59 should be fine :)
19:47:46 <Lunar^> /sw/share/aclocal/esd.m4:175:
19:47:53 <Lunar^> That's my setup, really
19:48:21 <dons> ok. anything interesting missing or reported by ./configure?
19:48:53 <matju> asmodai: hi
19:48:59 <matju> shapr: hi too
19:49:08 <Lunar^> dons: nothing
19:49:40 <dons> ok. we can forget it then :)
19:49:46 <Lunar^> sorry
19:50:09 <Lunar^> 5 am again
19:50:11 <dons> i'll have to check out thee mac yi-inplace  issue soon though, I think. since 2 mac users report the same thing
19:50:17 <Lunar^> I'm such a real life looser lately
19:51:26 <dons> oh, it's not that bad :} just autotools
19:58:09 <Lunar^> I was talking of being awake at 5 am :)
19:58:20 <shapr> I think it's 5am now.
20:01:25 <dons> hmm. why isn't there a strstr-like List function
20:01:42 * stepcut is working on yi again :)
20:01:51 <dons> yay!
20:01:53 <stepcut> Fail: failed to read patch in get_extra:
20:01:53 <stepcut> Thu Nov 11 14:57:24 PST 2004  Don Stewart <dons@cse.unsw.edu.au>
20:01:53 <stepcut>   * Even cleaner colours
20:01:53 <stepcut> Perhaps this is a 'partial' repository?
20:01:59 <stepcut> not yay! :(
20:02:04 <dons> hmm. that's no good.
20:02:16 <dons> maybe when I upgraded to darcs1.0.0rc4
20:02:42 <dons> I think Lunar^ just got the repo fine, though
20:03:10 <dons> no. you can 'get' just fine.
20:03:11 <dons> maybe try that
20:03:20 <stepcut> 1.0.0rc3-2
20:03:22 <stepcut> I will upgread
20:04:03 <dons> if you're working on emacs bindings, look at the vim lexer. it is quite feature-rich now.
20:04:04 <Lunar^> 0.9.20
20:04:09 <dons> whoa
20:04:24 <stepcut> dons: I always look at the vim lexer first :)
20:04:30 <dons> so maybe a 'pull' issue between versions
20:04:59 <Lunar^> sleep mode on
20:05:11 <dons> stepcut: you can do things like "3d}"     (3 * delete by paragraphs movements)
20:05:37 <dons> so there's nice movement-paramaterised editing now.
20:05:43 <dons> 2d3j etc.
20:06:02 * dons thinks maybe this means nothing to stepcut
20:06:12 <dons> emacs is a strange world
20:06:29 <stepcut> heh
20:07:48 <stepcut> darcs get seems to work, but it seems like pull fails for me a lot
20:08:19 <dons> hmm. not good. I guess I push and send mostly.
20:08:37 <dons> but noone else has complained, though. so maybe it isn't too bad
20:10:04 <dons> does anyone know why we have isPrefix,isSuffix but no isSublist ?
20:10:14 <shapr> I thought we did?
20:10:43 <shapr> though a different name I think.
20:11:12 <dons> Eq a => [a] -> [a] -> Bool
20:12:01 <dons> ah. maybe union and such will work
20:12:50 <stepcut> ack, no battery life or power supply
20:13:31 <dons> hmm. not sure if we have this function.
20:48:06 <shapr> crap,what happened to writeBinaryFile ?
21:00:54 <dons> darcs is warping my memory of cvs commands. it's a VIRUS!
21:05:55 <shapr> whoa nifty! http://cvs.haskell.org/darcs/
21:06:26 <dons> cool cool
21:34:21 <jeff2> why does [y|y<-[1], y / 1 == 1] == [1.0]?
21:34:47 <jeff2> (instead of 1)
21:37:33 <Nioate> probably because of the /
21:37:50 <Nioate> you could change it to `div`
21:38:00 <Nioate> or add an explicit type signature
21:38:05 <jeff2> ah
21:41:11 <jeff2> but how does the condition change y?
21:42:31 <jeff2> or is y defined as a float because / acts on it?
21:44:33 <sjanssen> the second description is most accurate
21:46:39 <sjanssen> Haskell is 'smart' when figuring out numeric values, and it tries to give them the broadest definition possible
21:47:10 <Nioate> the type inferencer picks a type which can do all of the things you have done with y. the literal 1s you typed don't convey any type information, other than it's a member of the Num class
21:49:38 <jeff2> I see
21:49:54 <dons> wow. yi can now reboot itself. thanks for the hint shapr
21:49:54 <shapr> so um...
21:49:54 <shapr> is the code up?
21:50:20 <shapr> I know, sanity dictates that I go to sleep before the sun returns, but I want to try the new yi =)
21:50:23 <dons> ok. give me an hour or two to debug this. you'll need thhe latest hs-plugins too, when I put it up in a few mins
21:50:32 <shapr> ok
21:50:39 <dons> youu can sleep in the knowledge that it seems to work
21:50:43 <shapr> heh, ok
21:50:51 <dons> it's scary though
21:50:55 <shapr> how so?
21:51:00 <shapr> what design did you end up with?
21:51:19 <dons> when we boot up, we pass to the dynamic code a reboot function, which you can bind to.
21:51:28 <shapr> ah
21:51:30 <dons> then, if you call it, we unload all the modules, reload them, and reboot
21:51:37 <shapr> nifty!
21:51:48 <shapr> INT19 for the RTS =)
21:52:00 <dons> so, atm, you end up back in the state you where when you first started up.
21:52:06 * desrt knows int19
21:52:15 <desrt> bootstrap procedure restart :)
21:52:55 <dons> but this is kind cool. we'll be able to develop yi without ever quitting yi
21:53:00 <shapr> yes!
21:53:06 <desrt> ...
21:53:17 <shapr> Significantly more than just cool. That totally kicks ass!
21:53:20 * shapr hugs dons 
21:53:36 <shapr> I owe you more beer!
21:53:36 <desrt> is yi runnable yet?
21:53:50 <dons> so, really, our core is just the 100 lines of Boot.hs
21:53:58 * shapr cheers
21:54:11 <dons> more beer. it goes on the tab ;)
21:54:15 <dons> desrt: runnable?
21:54:19 <desrt> emerge: there are no ebuilds to satisfy "yi".
21:54:23 <desrt> hm....
21:54:27 <dons> haha
21:54:32 <desrt> dons; can i use it to edit stuff? :)
21:54:46 <dons> day 38 of the project: desrt wonders if it has an ebuild entry
21:54:54 * shapr laughs
21:55:00 <shapr> you should keep a yi journal.
21:55:13 <dons> you can edit stuff. probably not too much fun without undo though.
21:55:18 <shapr> day 40 - Simon Marlow begins to use yi
21:55:23 <dons> hehe.
21:55:30 <dons> quits visual studio in disgust
21:55:33 <desrt> day 41 - simon PJ begins
21:55:36 * shapr laughs
21:55:53 <dons> ok. back to hacking
21:56:02 <desrt> you guys are so hardcore
21:56:03 * shapr cheers and then falls over asleep
21:56:04 * desrt hugs you both
21:56:18 <dons> it's a yi-love-fest
21:57:21 <dons> hmm. probably should kill those threads input threads first...
22:13:42 <jeff2> when I save [[y,x]|[x,y] <- [[1,2],[3,4]]] to a file and run it with: hugs98 inverse.hs, it unexpects '|', but it works fine from the interpreter at the Prelude> prompt. why?
22:17:23 <desrt> it expects you to give it a function name if it is in a file
22:17:35 <desrt> myfunc = [[y,x]|....
22:18:34 <jeff2> ah.. but why doesn't that work in the interpreter?
22:19:13 <desrt> in the interpreter i think you need to use let
22:20:00 <dons> yep. it's a do-loop. so you use the same notation
22:20:07 <jeff2> as in? Main> let inverse = [[y,x]|[x,y]<-[[1,2],[3,4]]]
22:21:31 <jeff2> desrt: hugs gives me an unexpected end of input for that :(
22:22:50 <desrt> odd
22:22:55 <desrt> that's what the syntax is for ghci
22:23:02 <desrt> perhaps with hugs you need to put all functions in the file
22:23:50 <dons> paprika$ ghci
22:23:50 <dons> Prelude> let inverse = [[y,x]|[x,y]<-[[1,2],[3,4]]]
22:23:50 <dons> Prelude> inverse
22:23:50 <dons> [[2,1],[4,3]]
22:24:40 <jeff2> suppose I should install ghci
22:25:19 <desrt> ghci really is quite a lot better
22:25:31 <dons> hugs:
22:25:32 <dons> Prelude> let inverse = [[y,x]|[x,y]<-[[1,2],[3,4]]] in inverse
22:25:46 <dons> [[2,1],[4,3]]
22:25:52 <desrt> dons; is there any way to throw the definition into the global scope, though?
22:26:22 <dons> that's what I don't know.
22:27:14 <dons> i'm surprised though. even hbi can do that.
22:27:49 <dons> $ hbi 
22:27:49 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
22:27:49 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
22:27:49 <dons> Type "help;" to get help.
22:27:49 <dons> > let x = 1;;
22:27:51 <dons> x :: (Prelude.Num a) => a
22:27:54 <dons> > x;;
22:27:57 <dons> 1
22:28:04 <dons> hbi is so much fun
22:28:28 <dons> i love the "200 types" message
22:29:37 <desrt> what is yi going to use to interpret?
22:30:11 <dons> in what sense do you mean "interpret"?
22:30:23 <desrt> yi supports evaluation of haskell
22:30:31 <desrt> (or will?)
22:31:03 <dons> well, it already lets you write config files in haskell. it loads and runs them
22:31:10 <desrt> right.  how?
22:31:16 <dons> with hs-plugins
22:31:26 <desrt> that's a ghciism, right?
22:31:33 <desrt> *ghcism
22:31:43 <dons> it needs ghc's rts
22:31:52 <desrt> i like the rts
22:32:23 <dons> and i've got a branch of yi that basically supports new haskell code to be typed at the editor prompt, using hs-plugins' eval() function
22:32:50 <dons> really though, I'd like ghci underneath. because it is faster than eval().
22:32:57 <dons> to do that, we need to use -package ghc.
22:33:02 <dons> which won't be too long
22:35:00 <jeff2> i used to invest in a stock called ghci
22:42:25 <jeff2> when I save "let inverse(x) = [[y,x] | [x,y] <- x]
22:42:49 <jeff2> (minus ") to a text file and run ghci inverse.hs, it fails to compile with: parse error (possibly incorrect indentation)
22:43:50 <jeff2> what am I doing wrong?
22:44:00 <sjanssen> skip the 'let'
22:45:10 <jeff2> weird. in files, function definitions cannot have let, but interactively, they must?
22:45:43 <Riastradh> The REPL is evaluated as if it were a sequence of 'do' commands; it is not the same as a module top-level.
22:45:51 <Riastradh> s/is evaluated/evaluates/1
22:46:26 <jeff2> oh. that's what dons was talking about
22:46:57 <jeff2> anyways, i'll stop bugging you guys for a while, and try to learn this on my own
22:47:15 <sjanssen> dons: yi's 'make html' seems to be broken due to some unescaped '/' characters
22:48:44 <sjanssen> switching line 22 of Yi/Keymap/Vi.hs to "-- Based on version 1.79 (7\/14\/97) of nex\/nvi" fixes that
22:49:16 <dons> oh yeah. that always happens. I'll fix it now. thanks!1
22:50:43 <dons> done.
22:50:52 <sjanssen> good deal
23:05:20 <dons> ah. threadDelay. just the trick
