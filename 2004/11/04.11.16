01:03:12 <mitchkov> hi, how can i fix a simple typecast from Int to Double ?
01:04:35 <dons> that's a function, really. Use fromIntegral
01:07:16 <dons> it's just a C cast in the generated code, though
01:07:36 <mitchkov> just need a function : IntToDouble
01:08:37 <dons> yep. use fromIntegral. it is defined to int2double for Int -> Double coversions
01:09:00 <dons> int2Double :: Int -> Double
01:09:00 <dons> int2Double   (I# x) = D# (int2Double#   x)
01:09:32 <mitchkov> thx a lot
01:10:22 <Lemmih> Btw, only data types and data constructures are capitalized.
01:12:19 <dons> and type constructors and modids ;)
01:13:37 <dons> I guess that's what you mean by data type, though
01:17:51 <mitchkov> idd, but i quit don't understand the function, i'm a newbie and never worked with those #'s and my compiler throws an error "unexpected symbol '#' "... 
01:20:25 <Pyoko> anyone got any good sites to read up about lamba calculus?
01:24:15 <Oejet_> mitchkov: Is this what you want: "d = fromIntegral(i::Int)::Double" ?
01:25:33 <mitchkov> i guess; i'm working with a Int and need to call a function using doubles
01:29:56 <Oejet_> mitchkov: What I have understood the function fromIntegral picks one of the "internal" compiler functions at compile time, which matches the types of fromIntegrals argument and value.
01:31:43 <mitchkov> what does this mean:  Instance of Fractional Int required
01:32:48 <Oejet_> It means that you need a value of type Fractional Int.  Can you show the expression?
01:35:37 <mitchkov> fromIntegral((1/n)::Int)::Double
01:36:32 <Lemmih> Maybe you should write: '1 / fromIntegral n'
01:36:57 <mitchkov> i find it very strange: n is an Int, but I need 1/n, why doesn't 1/n becomes automaticly a Double ?
01:37:30 <xkb> Anyone from Universiteit Utrecht here?
01:37:48 <xkb> or someone with experience on the AG-library
01:38:16 <Lemmih> mitchkov: (/) requires two Fractional values and Int is not an instance of Fractional.
01:38:58 <Oejet_> @type (/)
01:38:59 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
01:39:11 <mitchkov> thx !
01:39:16 <Lemmih> You can use 'div' if you want integer division.
01:40:31 <xkb> mitchkov, from a mathematical viewpoint you can only devide 2 integers if the results forms an integer, unless you want to take into account other number domains like R
01:41:19 <dogand> hi again
01:41:21 <dogand> !
01:41:26 <Oejet_> @eval let n = 10 in fromIntegral(1/n)::Double
01:41:26 <lambdabot> (line 1, column 7):
01:41:26 <lambdabot> unexpected "="
01:41:26 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
01:41:26 <lambdabot>  "(", operator, simple term or end of input
01:41:29 <Lemmih> Hey dogand
01:41:41 <dogand> i'm doing sockets in haskell now and i need to know how to "convert" an Integer to PortNumber! any ideas?
01:42:03 <dogand> tried read port::PortNumber, but there doesn't seem to be such a thing for PortNumber
01:42:08 <Lemmih> dogand: Integer to PortID?
01:42:09 <xkb> whats the constructor of PortNumber?
01:42:10 <Oejet_> @eval fromIntegral(1/10) :: Double
01:42:10 <lambdabot> (line 1, column 21):
01:42:10 <lambdabot> unexpected ":"
01:42:10 <lambdabot> expecting simple term
01:42:17 <dogand> Lemmih: no, PortNumber 'tis
01:42:20 <xerox> mornin'
01:43:13 <xkb> Oejet_: lamdabot's eval is not haskell ( I thought)
01:43:29 <dogand> see i'm trying to make a simple irc client and depending on if the user puts a port number in the server address or not, it picks the port.
01:43:38 <Lemmih> dogand: From where did you import that data type?
01:43:44 <dogand> Lemmih: Network
01:43:57 <xkb> @index PortNumber
01:43:57 <lambdabot> Network,Network,Network.BSD,Network.Socket
01:43:58 <Oejet_> xkb: I know.  Just trying to find out how much Haskell it's not.
01:44:04 <xkb> ok :D
01:44:20 <xkb> its a lambda calc. evaluator
01:44:55 <dogand> PortNumber :: PortNumber -> PortID
01:44:56 <Lemmih> dogand: Then you probably mean PortID. '\n -> PortNumber n' should do it.
01:44:57 <dogand> :P
01:45:20 <dogand> okay.. i'll try it out later, i've got some other stuff to do :/
01:45:23 <dogand> haskell rocks
01:46:06 <Lemmih> Time to unicycle.
01:46:13 <xerox> whoa!
03:58:05 * shapr chortles merrily
04:01:41 * musasabi finishes lunch
04:03:56 * shapr begins elevenses
04:05:25 <musasabi> a new word, nice..
04:09:09 * Lemmih has finished watching all the movies.
04:10:02 <shapr> Lemmih: *all* the movies?
04:10:19 <shapr> I would explode =) I usually have to go unicycle after every three or four movies
04:12:57 <shapr> Lemmih: which ones are your favorites?
04:17:03 <Lemmih> 11_Au_TAQUET_10Mo.wmv I think. I don't really like the unicon's.
04:24:09 <Lemmih> I think I'm gonna go unicycle now.
04:26:04 <shapr> yes, Au_Taquet is my favorite also.
04:46:43 <smilodon> hello every1 :)
04:47:18 <Lemmih> Hey smilodon
04:48:08 <Lemmih> I gotta find a way to chat while unicycling /-:
04:48:38 <shapr> hehe
04:48:48 <shapr> guten tag smilodon, learning Haskell/
04:48:49 <shapr> ?
04:49:04 <smilodon> yes
04:49:15 <smilodon> well, trying to get an overview
04:49:32 <smilodon> im more used to imperative languages
04:50:12 <xkb> @index apply
04:50:12 <lambdabot> bzzt
04:50:14 <xkb> @index aply
04:50:15 <lambdabot> bzzt
04:50:16 <Lemmih> Then Haskell will be good for you.
04:50:17 <xkb> err
04:50:47 <smilodon> lemmih: why will it be? :)
04:50:53 <xkb> isnt apply :: ( a -> b ) -> a -> b
04:50:54 <xkb> ?
04:51:11 <Lemmih> Learning new ways to thinking about programming is always good.
04:51:13 <arjanb> @type ($)
04:51:15 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
04:51:26 <xkb> ah
04:51:38 <xkb> now lets find out if we have that in clean 2.
04:52:45 <shapr> smilodon: http://www.haskell.org/learning.html
04:52:57 <shapr> syntax demo - http://www.haskell.org/hawiki/HaskellDemo
04:53:15 <shapr> smilodon: you might like this for an overview -  http://www.haskell.org/complex/why_does_haskell_matter.html
04:54:03 <smilodon> shapr: thx
04:54:22 <shapr> Lemmih: I'm looking forward to EuroHaskell, believe it or not, I've never seen anyone unicycling in person, only on videos!
04:55:02 <shapr> I once saw someone unicycling far away about twenty years ago.
04:55:07 <Lemmih> Heh. I've been thinking about joining Copenhagen Unicycle Club but I'm somewhat reluctant.
04:56:01 <shapr> I have some balance problems that I think could be helped by comparing with other unicyclists.
04:56:10 <musasabi> What would be a nice function name for a infix attribute getter? e.g. instead of "get foo label" "foo <symbol> label" ?
04:56:12 <shapr> smilodon: do you have any specific questions?
04:56:35 <Lemmih> musasabi: (#), perhaps.
04:57:27 <shapr> musasabi: um, `dot` or `get` hey, `o` is used in OCaml I think. Maybe  `slot` or `msg` or ...
04:57:54 <smilodon> shapr: hmm yes, maybe u can help me
04:57:56 <Iter> evening shapr.
04:58:06 <shapr> greetings Iter 
04:58:40 <Lemmih> smilodon: Just cry out your problems and we will all try to help (-:
04:59:27 <smilodon> shapr: i want to define a function hkCurry, which transforms a function f::(x,y)->z into a function f'::x->y->z (the value of f for (x,y) should be the same as for f' with the arguments x and y), and an inverse function hkUncurry, which does the opposite
04:59:49 <smilodon> i think theres something like curry and uncurry!?
05:00:00 <shapr> yes
05:00:05 <shapr> @type curry
05:00:06 <lambdabot> curry :: forall c b a. ((a, b) -> c) -> a -> b -> c
05:00:09 <musasabi> # seems nice..
05:00:10 <Iter> shapr: what do the !'s in 'data RealFloat a => Point2 a = Point2 !a !a deriving Eq' mean?
05:00:24 <shapr> Iter: strict
05:01:01 <Iter> isn't Point2 a type constructor?  how can it be strict?  
05:01:15 <shapr> the 'fields' can be strict.
05:01:15 <musasabi> only that does not seem to be a valid function name.
05:02:35 <TheHunter> hmm, why have I never noticed that ($) is a special case of id???
05:02:38 <Lemmih> Time to unicycle!
05:04:14 <smilodon> shapr: thats the signature i guess :)
05:04:25 <shapr> @type (uncurry (+))
05:04:26 <lambdabot> (uncurry (+)) :: forall b. (Num b) => (b, b) -> b
05:04:38 <shapr> @type (curry (uncurry (+)))
05:04:40 <lambdabot> (curry (uncurry (+))) :: forall b. (Num b) => b -> b -> b
05:04:53 <shapr> smilodon: any other questions?
05:04:54 <kosmikus> TheHunter: you never write (+) `id` 21 `id` 21 ? ;)
05:07:11 <smilodon> shapr: do i need to work with fst/snd to filter out x and y or am i thinking in a wrong way?
05:07:58 <TheHunter> kosmikus: no, but i think it's not that rare that such a notation actually makes sense.
05:08:30 <TheHunter> awesome
05:10:30 <kosmikus> smilodon: pattern matching is easier
05:24:31 <smilodon> oki thx ++
05:41:43 <boegel> hello everyone
05:42:14 <boegel> Pseudonym was right... perlin noise returns a value in the [-1,1] interval
05:42:36 <boegel> but the -1 and 1 will probably never be reached... that's why I don't get dark/bright values in my image... :)
05:42:45 <shapr> Pseudonym is often right.
05:45:28 <boegel> I should apologize to him...
05:45:42 <boegel> I got reply from Perlin quite fast :)
05:46:20 <boegel> within 30 min's :)
05:48:05 <shapr> From what I've seen, Pseudonym is one of the most knowledgable people I've met when it comes to functional programming and computer graphics.
05:48:18 <boegel> and I doubted him :s
05:48:34 <shapr> Well, it's always good to check for yourself.
05:48:49 <shapr> No one is perfect :-)
05:49:23 <boegel> true, but I don't like these situations :(
05:49:57 <boegel> anyway, now I can complete my perlin noise function like I should :)
05:51:48 <Lemmih> Heh. I actually hurt my self this time. Jumping from the pedals to the wheel isn't as easy as it looks (-:
05:52:09 * shapr agrees
05:52:31 <shapr> I'm buying leg armor with my next paycheck, then I'll be brave enough to try some of the scarier stuff.
06:00:33 <Igloo> What you need to do is perfect the being pulled by a car thing and then buy a crossbow, length of rope and a magnet
06:04:23 * Igloo chases the last error
06:14:34 <Igloo> Bah, why can't I "call" a field _? Silly language
06:32:21 <bourbaki> moin
06:37:28 <KiMoS> how to make a script that calculate the sum of the given interger and the integer must be n >= 0  
06:37:48 <KiMoS> i thought its something like this
06:37:49 <KiMoS> cijfersom  :: Int -> Int    
06:37:49 <KiMoS> cijfersom n = sum x + sum xs
06:38:00 <KiMoS> but this dossnt work
06:39:17 <psi> what is the sum of a single integer?
06:39:51 <KiMoS> ?
06:40:01 <arjanb> do you mean sum of the digits?
06:40:42 <KiMoS> i mean  u type 1234  and the answer is  10   (1+2+3+4)
06:43:22 <psi> well.. if it is one digit, the answer is that digit
06:43:35 <psi> otherwise the last digit is n `mod` 20
06:43:41 <psi> oops, 10
06:43:54 <psi> and the other digits n `div` 10
06:44:09 <psi> so you could use recursion based on that
06:50:16 <KiMoS> why using mod and div?
06:51:53 <psi> well, it's a method to get the individual digits in a number
06:52:41 <psi> an int is not a list, so you need a different method
06:53:02 <KiMoS> oh 
06:53:05 <br1> You could convert the int to a String and sum the value of the chars
07:25:09 <musasabi> Any ideas to the Cabal c-sources problem?
08:34:14 <marcot> Hello, Good Afternoon.
08:34:17 <musasabi> hello
08:34:31 <TheHunter> hello
08:34:57 <marcot> I'm trying to understande the code from Medak's thesis, but it's in Gopher.
08:35:05 <marcot> Where can I get a gopher interpreter?
08:35:14 <marcot> And documentation about this dialect?
08:35:21 <dash> hm. gofer's pretty ancient
08:35:24 <marcot> Is it very different from haskell?
08:35:32 <dash> you have some gofer code you're trying to run?
08:35:45 <marcot> dash: yes.
08:35:51 <TheHunter> marcot: it's almost identical.
08:36:07 <dash> marcot: are you sure there isn't a modern version of it? :)
08:36:41 <marcot> dash: I don't know for sure..
08:36:57 <marcot> dash: but it sais here that this is gofer.
08:37:02 <dash> what is it
08:37:11 <marcot> When I try to compile hugs gives me:
08:37:21 <marcot> ERROR "intro.hs":1 - Haskell 98 does not support multiple parameter classes.
08:37:26 * musasabi got hs-fltk packaged with cabal
08:37:35 <TheHunter> marcot: try hugs -98
08:37:43 <musasabi> marcot: try "hugs -98"
08:38:22 <marcot> TheHunter: hum.. now it worked.
08:38:43 <marcot> TheHunter:  musasabi: Thanks.
08:38:55 <marcot> But what is this multiples parameter classes?
08:39:06 <dash> classes with multiple parameters ;D
08:39:06 <musasabi> type classes with multiple parameters.
08:39:33 <marcot> class Points p a where
08:39:43 <marcot>     getX :: p a -> a
08:40:00 <marcot> data Point a = Pt a a
08:40:06 <marcot> instance Points Point a where
08:40:13 <marcot>     getX (Pt b c) = b
08:40:28 <marcot> So, the first parameter is the constructor?
08:40:35 <marcot> the p in class Points p a?
08:41:57 <marcot> What's the utilitie of that?
08:41:57 <TheHunter> because `p a' is used in the signature of getX, the compiler figures out that p must be of kind * -> *, ie. a data type that needs a type parameter such as Points.
08:43:03 <marcot> Why is it not in haskell yet?
08:43:54 <TheHunter> multiparameter typeclasses are not in the haskell 98 standard, but hugs and ghci support it (and many other extensions) for quite some time now.
08:44:27 <marcot> Is it very used?
08:44:42 <TheHunter> typeclasses with parameters of kind * -> * are in haskell 98, btw.
08:44:42 <marcot> Why it's not on the standard? Is there a reason for it?
08:45:20 <dash> heh
08:45:21 <TheHunter> it's used quite often. It's quasi-standard.
08:45:28 <dash> hugs and ghc support it! what else matters
08:45:32 <TheHunter> and it will be in haskell two, definitely.
08:46:20 <marcot> TheHunter: ok, thank you. But why didn't they put it in h98?
08:46:35 <TheHunter> marcot: notice that if it were
08:46:40 <TheHunter> class Points p where
08:46:45 <TheHunter>   getX :: p a -> a
08:46:54 <TheHunter> then the thing would be haskell 98.
08:48:00 <marcot> TheHunter: ok.. so the difference is about the context? Is it the only difference that you can make a context for a?
08:49:05 <TheHunter> the difference is quite huge: in your example you get different behaviour for Point Int and Point Char if you provide different instances for Points Point Int and Points Point Char
08:49:18 <TheHunter> s/get/can get/
08:49:29 <marcot> TheHunter: hum.. I understand.
08:50:47 <TheHunter> multiparameter type classes are most useful together with functional dependencies, the first paper on which is from 2000, perhaps that counts as a reason why they're not haskell98.
08:51:01 <tromp> hoi folks
08:51:12 <TheHunter> hoi tromp 
08:51:36 <marcot> TheHunter: and what's this funcional dependencie stuff? 
08:51:47 <marcot> TheHunter: Can you give a link maybe, or a simple explanation?
08:51:48 <TheHunter> @hawiki FunDeps
08:51:48 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
08:51:52 <TheHunter> @wiki FunDeps
08:51:53 <lambdabot> http://www.haskell.org/hawiki/FunDeps
08:51:55 <tromp> is there a simple way to print numbers with leading zeroes in fixed field width?
08:52:24 <musasabi> tromp: MissingH.Printf ;)
08:52:25 <tromp> as in printf("%03d",i)
08:54:16 <tromp> i currently use
08:55:02 <TheHunter> hmm, that could lose some parens.
08:55:04 <tromp> reverse $ take 3 $ reverse $ '0':'0':(show i)
08:57:23 <marcot> TheHunter: ok, thanks. I think this discussion is too advanced for my haskell knowledge. Maybe some time latter I'll try to read this paper with more time.
09:00:14 * TheHunter can barely withstand the temptation to write Vector `id` (+) a1 a2 `id` (+) b1 b2.
09:03:09 <CosmicRay> what is the list indexing operator in Haskell?
09:03:37 <bringert> @type (!!)
09:03:38 <lambdabot> (!!) :: forall a. [a] -> Int -> a
09:03:46 <CosmicRay> thanks
09:03:55 <CosmicRay> is there one that lets me modify a particular element?
09:04:16 <CosmicRay> ie, list (blah) 5 10 would return a new list, with element 5 set to 10?
09:04:46 <Igloo> take 6 . drop 4
09:04:57 <bringert> the standard library reference at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html is quite good
09:04:59 <CosmicRay> heh, ok
09:05:12 <CosmicRay> yeah but it's hard to find operators when you don't really know what to call them
09:05:17 <bringert> true
09:05:22 <CosmicRay> especially in Prelud
09:05:28 <CosmicRay> but I do have that page bookmarked
09:06:12 <Igloo> Oh, I totally misread what you wrote
09:06:44 <Igloo> The above's for a slice
09:07:23 <Igloo> take 4 xs ++ [10] ++ drop 6 xs. But it sounds like arrays might be the wrong datatype fo ryou
09:07:29 <SyntaxNinja> w00t
09:07:42 <Igloo> Yo Syn, wassup?
09:07:49 <bringert> @eval (\xs i x -> [ if n == i then x else xs!!n | n <- [0..length xs - 1] ]) [1..5] 2 10
09:07:50 <lambdabot> (line 1, column 39):
09:07:50 <lambdabot> unexpected "!"
09:07:50 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character
09:07:50 <lambdabot>  "[", string, "(", operator, simple term, "," or "]"
09:07:57 <bringert> guess not
09:08:16 <SyntaxNinja> hi Igloo nomuch... got broadband at home now, so I can hack more regularly :)
09:08:37 <Igloo> Excellent!
09:08:46 <Igloo> bringert: That'd have worse sharing, too
09:09:08 <Igloo> Not to mention quadratic performance - mmm  :-)
09:09:14 <dash> CosmicRay: arrays have // defined on them which sorta do that
09:09:22 <dash> (DiffArray is awesome)
09:09:50 <dash> arrays would be awesomer if they were resizeable though
09:10:16 <bringert> Igloo: yeah, I know, it's crap
09:11:39 <Igloo> :-)
09:12:36 <derelm> can someone please tell me if in haskell internals things like " 4 `div` 2" get transformed to " div 4 2 " or if they get evaluated directly?
09:12:49 <dash> derelm: what's the difference?
09:13:51 <derelm> well, in our course we're told to count transformations, to see how the evaluation in haskell works. but i dont know if using a function like diff makes a difference
09:14:10 <derelm> funtion like div
09:14:14 <derelm> +c
09:14:16 <derelm> grr
09:14:24 <Igloo> It'll get translated
09:14:47 <Igloo> But at compilation time rather than run time
09:15:29 <derelm> so if i have something like "main = 4 `div`4" it will first get translated to "main = div 4 4 " and then it'll be evaluated?
09:15:48 <bringert> well, the compiler might optimize it for you :)
09:16:05 <bringert> and translate it to main = 1
09:16:07 <derelm> thats exactly the question
09:16:13 <derelm> in the end, yes
09:16:20 <marcot> Here I have a class IDs i where ... 
09:16:29 <Igloo> I'd say don't count "4 `div` 4" -> "div 4 4" as a step, then find out what the official answer is and do that in the exam
09:16:41 <derelm> hmm...
09:16:42 * bringert agrees
09:16:42 <derelm> ok
09:16:55 <derelm> when run in hugs there is a difference
09:17:07 <marcot> The he uses classe IDs (o t) => Objects o t where ..
09:17:15 <marcot> What does this (o t) means?
09:17:40 <marcot> Is o an data constructor?
09:17:45 <bringert> derelm: I wouldn't count that as a transformation, regardless of whether it's run in an interpreter
09:18:30 <Igloo> No there isn't
09:18:48 <Igloo> Type :? for help
09:18:48 <Igloo> Prelude> div 4 4
09:18:48 <Igloo> 1
09:18:48 <Igloo> (84 reductions, 178 cells)
09:18:48 <Igloo> Prelude> div 4 4
09:18:49 <Igloo> 1
09:18:55 <derelm> Prelude> :s +s
09:18:55 <derelm> Prelude> div 2 2
09:18:55 <derelm> 1
09:18:55 <derelm> (84 reductions, 178 cells)
09:18:55 <derelm> Prelude> 2 `div` 2
09:18:56 <derelm> 1
09:18:57 <Igloo> (77 reductions, 103 cells)
09:18:58 <derelm> (77 reductions, 103 cells)
09:18:59 <Jan_w> I though a 'div' b was just another way to say div a b, doesn't the difference for haskell end somewhere right after parsing that ?
09:19:02 <Igloo> Type :? for help
09:19:02 <Igloo> Prelude> 4 `div` 4
09:19:02 <Igloo> 1
09:19:02 <Igloo> (84 reductions, 178 cells)
09:19:02 <Igloo> Prelude> 4 `div` 4
09:19:04 <derelm> ah, i was about to post that ;)
09:19:04 <Igloo> 1
09:19:06 <Igloo> (77 reductions, 103 cells)
09:19:25 <dash> so clearly "div 4 4" gets transformed instead
09:19:38 <Igloo> It's just not evaluating from scratch each time unless you restart hugs
09:20:20 <derelm> now what would you say, should i count that transformation or shouldn't i? ;)
09:20:25 <tromp> how do you make hugs report reductions?
09:20:30 <derelm> :s +s
09:21:14 <tromp> cool
10:06:43 <kang> anyone ever wanted to save a life ?
10:06:54 <Jan_w> kang: sure
10:06:57 <Jan_w> kang: word up
10:07:03 <kang> well that involve much
10:07:19 <kang> something like.. explaining a question which is "homework"
10:07:21 <kang> :/
10:07:30 <Jan_w> hehe
10:07:37 <kang> but you don't save a life so easily :/
10:08:09 * Jan_w wants to hear you out, i'll be back in a hour, i'm a student myself, so if I can help you, i'll help
10:08:17 <kang> lol
10:08:18 <kang> :)
10:08:19 <Jan_w> see you later.
10:08:24 <kang> you go ?
10:08:46 <Lemmih> There are others here who can help you.
10:09:06 <kang> but i heard homework related questions weren't allowed;p
10:09:47 <kang> actually im as usual trying to help a friend with haskell, not really for me, but hmm well I guess if that goes on i should really just learn haskell ;p
10:10:08 <kang> i just know imperative programming and hm my maths are far away ^^ and haskell is much maths functions
10:10:13 <kang> i guess looks simple when u know it
10:11:28 <kang> but when your brain size equals mine ....
10:11:45 <Lemmih> Questions are always welcome, but we're not gonna do your homework for you.
10:12:09 <kang> well its not mine, else i guess i would get a better clue about what it means ^^
10:12:12 <kang> but still
10:12:23 <kang> it seems to be all about functiosn
10:12:25 <kang> like
10:12:27 <kang> maths functions
10:12:28 <kang> of course
10:12:59 <kang> it should do a function transfert/transform from f::(a,b)-> into f'::a->b->c
10:13:15 <kang> and value of f should be equal to f'
10:13:26 <kang> this function should be called haskellcurry ;)
10:13:36 <kang> (like the built in curry)
10:13:56 <Lemmih> What have you tried so far?
10:15:33 <kang> well, tried reading ^^
10:16:09 <kang> i don't really know much that's why it sucks to be me right now ^^ or to be her i guess lol
10:16:27 <kang> i mean
10:16:30 <kang> eg
10:16:38 <kang> i forgot how is done transfert/transform in maths
10:18:22 <Lemmih> You are supposed to create a function with type '((a, b) -> c) -> a -> b -> c'?
10:18:33 <kang> yes
10:18:57 <kang> in fact it should be equivalent to the built in curry function i think, but without curry
10:18:58 <Igloo> Ack
10:19:10 * Igloo finally works out how to give type sigs in O'Caml and recoils in horror
10:19:31 <Lemmih> kang: Do you know how to create a tuple?
10:20:28 <kang> hm
10:20:34 <kang> readng about it on wikipedia now (tuple)
10:21:27 <Lemmih> @type (,)
10:21:28 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
10:22:25 <Lemmih> In Haskell you can create tuples with the (,) operator.
10:22:48 <kang> ok
10:23:25 <Lemmih> kang: Your haskellcurry function should take a function and two variables. Then it should pack the variables in a tuple and apply it to the function.
10:24:47 <kang> hm
10:25:27 <kang> so... you apply a tuple to the function
10:26:54 <bringert> well, the other way around
10:27:40 <kang> a function to a tuple ^^
10:27:58 <Lemmih> Ehm yes. Apply the function to the tuple.
10:29:27 <Lemmih> Anyhow, I'm off to find food.
10:29:31 <kang> oki
10:34:04 <kang> hm oki
10:34:07 <kang> so what i need to know
10:34:23 <kang> is to know the real diff between f x y z and f(x,y,z) ;D (yes, im stupid)
10:34:52 <boegel> hello everyone !
10:35:39 <Philippa> kang: define "real" - f x y z is three function applications, f(x,y,z) is one
10:35:42 <boegel> I'm having some random problems... I want to make a marble texture with perlin noise, but I looks to structured, because I always use the same random permutation of [0..255] (I think)
10:35:49 <Philippa> however, (x,y,z) is all one value
10:36:23 <Philippa> the tupled form is less flexible, you can't do partial application with it
10:36:43 <boegel> I need a random generator, but not with using (mkStdGen n), where n is a number, because that always returns the same random generator, and because of that the same permutation of [0..255]
10:36:49 <kang> so hm
10:37:01 <kang> f x y z is multi argument function, a tuple f(y,x,z) is single argument
10:37:16 <Philippa> yeah
10:37:34 <kang> not that i completely get the "argument" definition right now, unless its just like my_function(argument) in imperative ^^
10:37:55 <Philippa> we write f x for what C folks would write f(x)
10:37:55 <kang> but with , in imperative would be 3 args still, but hm k, more or less lol
10:37:59 <kang> ok
10:38:02 <boegel> I could use getStdGen, but ...
10:38:02 <Philippa> all our functions take exactly one argument
10:38:09 <boegel> @type Random.getStdGen
10:38:10 <lambdabot> Random.getStdGen :: IO System.Random.StdGen
10:38:26 <boegel> that of type IO something, how do I pull it out of IO ?
10:38:28 <kang> so hm f x y z (f taking 3 arguments), that's invalid, so you need to make tuples, right ?
10:38:29 <boegel> or isn't that possible ?
10:38:32 <Philippa> what we get, which the imperative folks don't, is this: (f x) y z = f x y z
10:38:46 <Philippa> nope - see the line I just wrote :-)
10:38:50 <Philippa> (f x) is a function
10:39:02 <kang> hm
10:39:08 <Philippa> this bit will prolly break your brain for a moment, so I'll give an example
10:39:19 <kang> would be f x (y) z be like f x y z too ?
10:39:21 <Philippa> (+) :: Int -> Int -> Int (this is a slight lie btw, but don't worry about it)
10:39:35 <Philippa> yes, but there'd be less significance to saying so
10:39:51 <Philippa> more explicitly: (+) :: Int -> (Int -> Int)
10:40:00 <kang> hm i'm sorry
10:40:07 <Philippa> that is, the + operator is a function that takes an Int and returns (a function that takes an Int and returns an Int)
10:40:27 <Philippa> that's how you get functions that take more than one parameter in Haskell, and how partial application works
10:40:31 <kang> as i said above its really not my homework so i don't know very much about haskell ;) althought i know what you are typing should be a function signature (=definition for me)
10:40:38 <Philippa> eg the "add one" function could be written (+) 1
10:40:47 <Philippa> it's a type
10:40:51 <kang> ok
10:40:52 <Philippa> a :: b means "a has type b"
10:41:04 <Philippa> a -> b is the type "function from a to b"
10:41:06 <kang> so (+) has type int->int->int
10:41:07 <Philippa> and parens do what you think they do
10:41:10 <Philippa> yep
10:41:19 <Philippa> which is shorthand for Int->(Int->Int)
10:41:31 <kang> can i ask what is (+) ?
10:41:33 <kang> err im reading
10:41:47 <Philippa> it's how you write the addition operator when you want it to be a function like any other
10:41:55 <kang> ok
10:42:01 <kang> hey
10:42:03 <kang> i understand a bit
10:42:06 <kang> ;D
10:42:23 <boegel> hey xkb_ 
10:42:43 <boegel> nobody can help me with my random IO problem ?
10:43:15 <Philippa> kang: you can define C++'s ++ operator (give or take side-effects) like so: (++) = (+) 1
10:43:26 <Philippa> well, you could, only the Prelude defines ++ as something different
10:43:26 <kang> so ok, thx
10:43:41 <kang> i don't know prelude anyway ^^
10:44:04 <kang> hm
10:44:07 <Philippa> you don't need to, you just need docs for it. It's the bit of the standard library that every program includes automagically
10:44:15 <kang> ok
10:44:36 <kang> this is a whole another world (<> imperative)
10:44:43 <Philippa> somewhat, yeah
10:44:50 <Philippa> after you've been doing it a while you'll start to see more links
10:45:09 <Philippa> in a twisted way, the two paradigms're sort of dual. You can exploit that
10:46:41 <kang> @type curry
10:46:42 <lambdabot> curry :: forall c b a. ((a, b) -> c) -> a -> b -> c
10:46:49 <kang> @type uncurry
10:46:50 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
10:46:58 <Spark> @type theory
10:47:00 <lambdabot> bzzt
10:47:03 <Spark> heh
10:47:06 <boegel> @index theory
10:47:06 <lambdabot> bzzt
10:47:14 <boegel> Spark, ?
10:47:23 <Lemmih> haha (-:
10:47:35 <boegel> Lemmih, can't you help me with my random IO stuff ?
10:47:45 <Lemmih> Sure.
10:47:49 <boegel> okay
10:47:53 <boegel> I'll explain it again :)
10:48:01 <Spark> the eurostar is passing my house
10:48:03 <Spark> its FUCKING lng
10:48:12 <Spark> it takes almost 30 seconds at however many miles per hour
10:48:38 <boegel> currently, I'm using mkStdGen to get an RandomGenerator which I use to scramble up [0..255]
10:48:58 <boegel> the problem is, because I use (mkStdGen n), with n some number, I always get the same result
10:49:31 <boegel> I could use getStdGen or newStdGen to get a different RandomGenerator every time, only, it is of type IO StdGen, and I just want StdGen
10:49:45 <boegel> can I 'pull' getStdGen out of IO somehow ?
10:50:08 <Lemmih> Yes but you probably don't want to.
10:50:37 <Philippa> Data.Unique or whatever it was?
10:50:47 <boegel> Lemmih, why not ?
10:51:06 <jadrian> hello
10:51:08 <Lemmih> As you probably know Haskell is a purely functional language.
10:51:11 <boegel> hello jadrian 
10:51:15 <jadrian> hi boegel 
10:51:17 <boegel> Lemmih, I do know that
10:51:52 <boegel> jadrian, new ?
10:51:56 <jadrian> hi Philippa, I went for Parsec and yes I like it better than Happy so far 
10:52:07 <jadrian> boegel: playing with parsec
10:52:09 <boegel> ows, not new ;)
10:53:56 <kang> im more for the "give solution and explain questions about it afterwards" ;D
10:54:15 <boegel> Lemmih, was that it ? :p
10:54:16 <Lemmih> boegel: You can use getStdGen at a top level and then parse it down to every function which needs random numbers.
10:54:19 <boegel> ows, sry
10:54:35 <Philippa> jadrian: 'sa beauty, innit? :-)
10:54:41 <boegel> Lemmih, and how would I do that ?
10:54:46 <boegel> using do ?
10:54:52 <tuomov> or you could create a random state monad
10:55:11 <Lemmih> Exactly like how you would use data from a file.
10:55:42 <boegel> Lemmih, but how do I get a random generator of type StdGen, in stead of type (IO StdGen)
10:56:02 <kang> how do you hmm .. f::(a,b)->c into f'::a->b->c ; i mean, how do you extract the a and b at all ? if i can ask some hint on it
10:56:50 <boegel> I have to go now, I'll be back within the next 2 hours, bye
10:56:53 <Lemmih> boegel: Haven't you dealt with IO before?
10:57:02 <boegel> Lemmih, not really
10:57:14 <Philippa> kang: f' a b = f (a,b)
10:57:33 <Philippa> 'skinda hard to give a hint for that without giving the entire answer really :-)
10:57:47 <Philippa> alternatively, f' = \a->\b->f (a,b)
10:57:52 <Philippa> or 101 variants on the same theme
10:58:17 <jadrian2> opss back...
10:58:20 <jadrian2> I hope
10:58:24 <Etaoin> or using curry
10:58:26 <Lemmih> Welcome back jadrian (-:
10:58:35 <jadrian2> thanks Lemmih :)
10:58:48 <jadrian2> Philippa: yeap pretty cool
10:58:49 <kang> Philippa: yeah well u can give me the answer i won't hurt ^^ jk
10:59:00 <kang> Philippa: hm, wht is  \ for ?
10:59:17 <Philippa> it's ASCII for a lambda
10:59:27 <jadrian2> Philippa: Just two things that bother me a little. The 1st one is that it's really a nice example of why parameterized modules would be handy
10:59:35 <Philippa> \x.e is a function taking a parm x and returning whatever e evaluates to
10:59:58 <Philippa> yeah, though you've got equivalent expressiveness available
11:00:16 <kang> i guess you need \ to translate f a b to eg f a->b or something ?
11:00:19 <Philippa> kang: in \x.e, e will be some expression that may or may not contain x (but probably does)
11:00:43 <Philippa> kang: you need it to write functions, 'sjust there's syntactic sugar that translates into stuff with lambdas
11:01:08 <Philippa> f' a b = <foo> is a function (f') defined using pattern-matching
11:01:15 <kang> Philippa: you're loosing me on this one (i feel stupid lol)
11:01:41 <jadrian2> Philippa: the 2nd one is how it deals with identifiers, you can only define one kind of identifier, and there is no function to make ident. lexers from other parsers
11:01:57 <Philippa> jadrian2: just skip that bit and write your own lexer then?
11:02:19 <Philippa> it's /all/ parsec, after all - the lexing bits're just a convenience
11:02:32 <jadrian2> Philippa: yeap, did that, but I ended up copy pasting quite a bit from Parsec sources, it's reinventing the wheel
11:02:59 <jadrian2> the thing is that when lexing ids you should also check for reserved words
11:03:00 * Philippa nods
11:03:00 <Philippa> PITA, I know
11:03:16 <Philippa> I sorta cheat on that when I write my grammars
11:03:33 <Philippa> I assume all the reserved words are potentially valid identifiers and thus sort it out at the grammar level, basically
11:04:14 <kang> Philippa: you think its possible to have an example of a function like f::(x,y) translating into f::x->y as an example  ?
11:04:24 <kang> i wrote example one time too much
11:04:26 <kang> ;)
11:05:14 <Philippa> kang: no, it's not
11:05:28 <musasabi> sauna ^_^
11:05:29 <Philippa> f::(x,y) tells me that f isn't a function, it's a value
11:05:48 <kang> i mean a function transforming the values then
11:06:07 <kang> like
11:06:30 <kang> in the exercise, you've to change f::(a,b)->c to f'::a->b-C
11:06:32 <kang> ->c
11:06:38 <kang> then f and f' are values too
11:06:40 <kang> with the::
11:06:59 <Philippa> kang: a -> b is a function
11:07:03 <Philippa> (a,b) is not
11:07:07 <kang> ha
11:07:13 <kang> ha! lol
11:07:17 <kang> that explains things.
11:07:34 <Philippa> (a,b) is a pair containing an a and a b :-)
11:07:44 <kang> oki:)
11:07:45 <kang> and 
11:08:23 <kang> a->-b->c means that you have a function from a to b and from this to c ?
11:08:39 <Philippa> sort of
11:08:50 <Philippa> it's shorthand for a->(b->c) - can you read that one off OK?
11:09:21 <kang> ok
11:09:25 <jadrian2> Philippa: yeap, that's one way to get around one deta
11:09:27 <kang> i understood it reversely i think
11:09:27 <jadrian2> opss
11:09:36 <kang> like (a->b)->c
11:09:40 <jadrian2> Philippa: detail*
11:09:43 <jadrian2> Philippa: but there are others
11:10:01 <kang> hm, does it also means that for a->b a will become b after a function is applied or that's something else ?
11:10:08 <Philippa> kang: that one takes a function from a to b, then returns a c
11:10:24 <Philippa> kang: you're in functional land now, we never /change/ values, just generate new ones :-)
11:10:40 <kang> ok so a is changed to be b in a->b ?
11:10:46 <Philippa> jadrian: got any in mind? I've not really used the parsec tokenising stuff
11:10:49 <jadrian2> Philippa: for instance, you need to take into account wether your language is case sensitive or not when lexing/parsing identifiers
11:11:02 <Philippa> kang: it takes an a and returns a b. Nothing "changes"
11:11:22 <kang> ok ok lol, i meant
11:11:25 <kang> a doesn't changes
11:11:31 <kang> but an operation is done with it
11:11:34 <kang> and result is b
11:11:36 <Philippa> jadrian2: do {i <- (pattern); return (frigCase i)} :-)
11:11:41 <Philippa> yeah
11:11:43 <jadrian2> Philippa: all of this is taken care of for you, when you use the ParsecToken.identifier function
11:11:46 <kang> oki thx
11:12:13 <Philippa> any others I haven't seen?
11:12:36 <Philippa> I mean, I can see the expression parser stuff being very very useful indeed...
11:12:51 <jadrian2> Philippa: yeap, but in the end, we are rewriting the definition of the whole ParsecToken.identifier function fore each kind of identifier
11:13:01 <jadrian2> Philippa: which is not that small
11:13:06 <Philippa> you shouldn't be
11:13:10 <Philippa> OnceAndOnlyOnce and all that
11:13:19 <Philippa> if they can factor it out, so can you, right?
11:13:55 <jadrian2> ?
11:13:59 <jadrian2> who can factor it out?
11:14:31 <Philippa> those who wrote ParsecToken
11:15:04 <Philippa> an "obvious" split might be pattern/postprocessing (with which you can eg frig with the case)
11:15:18 <jadrian2> well ParsecToken.identifier is defined in terms of your parsing rules for the head and tail of an identifier
11:15:35 <kang> Philippa: i think i still miss something to understand exactly how i can translate from (a,b)-> to an equivalent a->b->c :/ 
11:15:53 <jadrian2> if you do have more than one type of identifiers, you'll end up having to rewrite those definitions (since none of it is exported)
11:15:54 <bourbaki> moin
11:16:01 <bourbaki> anyone into physics here?
11:16:16 <Philippa> kang: you want to take the two parms, bundle them into a tuple then pass the tuple to your (a,b)->c func
11:16:27 <Philippa> not seriously, though I wouldn't mind knowing more
11:16:32 <jadrian2> Philippa: not sure how can you post process
11:16:42 <jadrian2> Philippa: identifier lexing is done using try
11:16:51 <Philippa> jadrian2: run something like toUpper or toLower on the result once you have a match
11:17:15 <jadrian2> Philippa: if you make it succed you can't go back to use that input again
11:17:27 <kang> Philippa: will try, ill come back here if i can't figure it out myself still, and thanks for all the help already!
11:17:52 <Philippa> right, you do the postprocess at the point you know it's succeeded. It's a valid identifier already (the "pattern"), now convert it into the form your symbol table wants
11:18:07 <Philippa> kang: I've already shown you the code that does it :-)
11:19:07 <Philippa> hint: given a func f (foo::a) (bar::b) = (baz :: c), f::a->b->c. baz can be an expression containing foo and/or bar.
11:26:29 <jadrian2> Philippa: so, to try an haskell constructor you would  (pseudocode) try $ do { s <- identifier; if isUpperCase (head s) then s else fail ""}
11:26:53 <Philippa> no
11:27:24 <Philippa> I'd write the more precise pattern
11:27:55 <Philippa> my postprocessing's for things like case insensitivity, where you may want to mangle tokens to a canonical form (eg all upper/lower case)
11:30:23 <jadrian2> sorry I don't understand...
11:30:36 <Philippa> suppose we're parsing case-insensitive identifiers...
11:30:40 <jadrian2> no no
11:30:47 <jadrian2> I'd really prefer this example
11:30:55 <Philippa> that example has no postprocessing
11:31:06 <jadrian2> exactly
11:31:15 <jadrian2> what you have in this case is:
11:31:18 <shuttlecock> what haskell interpreter/compiler/whatever should i use on debian linux?  im a ocaml/scheme user who wants to learn haskell since i keep on hearing about it
11:31:21 <Philippa> I didn't say my split solves /everything/, did I?
11:31:31 <jadrian2> nope :)
11:31:32 <Philippa> shuttlecock: GHC is good
11:31:58 <jadrian2> but my question was about this, mor ethan one kind of identifiers with diferent rules
11:32:25 <Philippa> Sure. And we come back to factoring it all out so you've got useful combinators to build it all with
11:32:51 <Philippa> I mean, most of the time you're taking your identifier chars from one or more known groups of characters you'll use over and over, yeah?
11:33:10 <Philippa> do {c <- upper; cs <- many letter; return (c:cs)}
11:33:24 <jadrian2> that is the parser for constructors yes
11:33:37 <jadrian2> now you need to turn that parser into the lexer
11:34:03 <Philippa> no, I don't. I just don't use the Token lib, I call that parser direct
11:34:09 <Philippa> constructor = ...
11:34:35 <Philippa> you can abstract out the "one of these then many of those" pattern if you want, that's no biggie
11:34:49 <jadrian2> no you need more than that
11:34:56 <jadrian2> you need to apply lexeme
11:35:00 <Philippa> if you want to used bits of Token, build a partial definition and use what you get out wrapped in names to suit your grammar
11:35:00 <jadrian2> because of whitespace
11:35:08 <jadrian2> you need to use try to parse it
11:35:21 <jadrian2> you need to check for clash with identifiers
11:35:28 <Philippa> do {c <- upper; cs <- many letter; whitespace; return (c:cs)}
11:35:56 <jadrian2> yes Philippa, but my point is, you need *everything* that is in ParsecToken.identifier
11:36:11 <Philippa> then build more'n'one set of lexers. No biggie
11:36:15 <Philippa> (I don't need everything, FWIW)
11:37:04 <Philippa> it's not been worth my while to use ParsecToken so far, simple as that
11:37:05 <jadrian2> well, what I did was make a function that turns the identifierParser into the identiferLexer
12:10:54 <Spark> can anyone tell me what a proper subset is?
12:13:42 <Spark> ah
12:13:55 <Spark> proper subset is to subset what < is to <=
12:14:05 <Spark> god bless teh intraweb
12:22:15 <boegel> hello xkb
12:22:24 <boegel> Lemmih, care to give it another try ? :)
12:23:52 <Lemmih> Sure.
12:24:35 <boegel> why is it a problem if I would use getStdGen as if it were of type StdGen in stead of (IO StdGen) ?
12:25:10 <boegel> doesn't getStdGen just use my system clock to generate the numbers?
12:26:02 <Lemmih> Perhaps but Haskell is a purely functional language which means that there aren't any side effects.
12:26:26 <boegel> meaning ?
12:26:44 <Lemmih> http://haskell.org/hawiki/ThatAnnoyingIoType
12:27:58 <monochrom> Haskell wouldn't let you use getStdGen as if it were of type StdGen.
12:28:04 <boegel> Lemmih, so I don't have to adjust the type of getStdGen ?
12:28:30 <monochrom> Yes it takes a look at the system clock, and it is that look that is an IO command, not a pure function.
12:28:47 <boegel> but if I use getStdGen to produce a RandomGenerator in my function, I will get [IO INt] in stead of [Int]
12:28:52 <boegel> that's the problem for me...
12:29:00 <Lemmih> Bed time. *puff*
12:29:06 <monochrom> A pure function is supposed to give reproducible results.  But different looks at the clock gives different results.
12:29:18 <boegel> monochrom, I know that
12:29:34 <boegel> I _want_ that, but I also want the result of the function to be of type [Int]
12:29:43 <monochrom> Why would you get [IO Int]?  I would think you'll get IO [Int]
12:29:44 <Riastradh> No, for the same inputs it always gives the same results.
12:30:09 <Riastradh> It happens that there is an implicit input, hidden by a monad: the state of the entire world.
12:30:22 <boegel> Riastradh, I get that, thats not my problem...
12:30:31 <Riastradh> I was responding to monochrom.
12:30:36 <Riastradh> Perhaps I ought to have made that clearer.
12:30:45 <boegel> oh, sorry then ;)
12:31:06 <Riastradh> @type sequence
12:31:07 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
12:31:16 <Riastradh> That's the operation you want, boegel.
12:31:21 <boegel> monochrom, and if I get IO [Int], I can just adjust it using the 'do' trick on the page which Lemmih showed me ?
12:31:38 <monochrom> Yes.
12:31:48 <boegel> okay, let's try that then...
12:34:09 <monochrom> My philosophy of writing useful Haskell programs: http://www.google.ca/groups?selm=4uit5o6ebt.fsf%40vex.net&output=gplain
12:35:30 <boegel> nicely put monochrom 
12:35:42 <monochrom> Thanks.  Hope it helps.
12:36:40 <boegel> it does :)
12:37:01 <bourbaki> boegel any progression?
12:37:34 <boegel> bourbaki, I'm trying to get nice marbly textures out of perlin noise...
12:37:48 <boegel> I know for sure now the range of the noise function is in [-1,1], because I asked Perlin :)
12:38:07 <boegel> monochrom, I'm afraid I have another problem now :)
12:38:25 * monochrom makes a joke about zero-knowledge proofs and Perlin noise. :)
12:38:50 <boegel> I don't need just one RandomGenerator for the, but several... :s
12:39:12 <boegel> so my problem doesn't get fixed this way I'm afraid :s
12:39:47 <monochrom> You can consider Random.split
12:39:56 <boegel> @type Random.split
12:39:58 <lambdabot> Random.split :: forall g.
12:39:58 <lambdabot> 		(System.Random.RandomGen g) =>
12:39:58 <lambdabot> 		g -> (g, g)
12:40:06 <boegel> oh, nice :)
12:41:02 <monochrom> The statistical niceness of split (or rather, how to implement split with statistical niceness) is still an under-explored problem.
12:41:52 <monochrom> But I don't think it hurts you for now.  You are just doing pleasing graphics, not certifiably fair casino games.
12:43:35 <boegel> idd, monochrom, I see that the first element of 2 lists are the same sometimes... but that's no biggy :)
12:43:51 <boegel> this helps me a lot :)
12:43:53 <boegel> thx !
12:45:02 <monochrom> You're welcome.
12:46:12 <jadrian2> I did a few tests on the integer random generator and it did quite fine
12:47:43 <jadrian2> IIRC I tried Chi Square tests for 2D and 3D, runs up test and a few correlation tests
12:51:47 <kang>  f = (a,b)->c  =>  f'=\a->\b->f(a,b)->c  ? ^^
12:52:25 <monochrom> syntax error
12:52:36 <kang> where who !
12:52:41 <kang> :)
12:53:02 <kang> it took me some time to get to that already ^^
12:53:19 * kang cries
12:54:07 <boegel> kang, I think you make it too hard on yourself
12:54:22 <kang> monochrom: i try to get a prog working to do from f:: (a,b) -> c to f':: a->b->c
12:54:27 <kang> boegel: yeah ^^
12:54:34 <kang> boegel: and its not even for me ^^
12:54:43 <kang> my life is unfair ^^
12:55:06 <monochrom> Alright so you shouldn't write "f = (a,b)->c" at the beginning.  = is not ::
12:55:20 <boegel> @wiki HaskellIrcPastePage
12:55:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:56:01 <monochrom> f' a b = f(a,b)
12:56:12 <kang> monochrom: i don't know why i wrote = i wanted to write ::
12:56:47 <boegel> monochrom, check the PastePage, anyway I can get that to work?
12:56:57 <boegel> how do I make gen visible in the where clause ?
12:57:37 <Igloo> Use let instead of where
12:57:38 <boegel> I know this example is just plain stupid, but it's a light version of my (main) function
12:57:43 <monochrom> yuck, there is no way.  You have to use let.
12:57:58 <monochrom> I hate to do that too.
12:58:15 <Igloo> Or have something take it as an argument
12:58:22 <kang> monochrom: can you help me ? :) where is your paypal ? :) ;p
12:58:40 <boegel> monochrom, why do you hate that ? :)
12:59:01 <monochrom> I hate to use let when my instinct tells me to use where.
12:59:25 <Philippa> because it forces you to write things in the opposite order to the one you intended
12:59:33 <Philippa> it cramps the coder's style
12:59:38 <kang> hey Philippa 
12:59:53 <kang> my qi is under 50 ;p
13:00:30 <monochrom> do { gen <- getStdGen; let something = getRandomList (fst $ split gen) 10; putStr $ show something ++ "\n" }
13:00:58 <monochrom> I just don't like it, but I will live with it.
13:01:55 <Spark> i'd like to know if all untypeable terms involve self application
13:02:06 <Spark> and if all unnormalizable terms involve self application
13:02:22 <kang> haskellCurry :: Int -> (Int -> Int)
13:02:23 <kang> haskellCurry = \a->\b->f (a,b)
13:02:24 <kang> :<
13:02:42 <monochrom> That works.
13:02:46 <kang> mh
13:02:57 <kang> haskellCurry :: Int -> (Int -> Int) -> Int
13:03:15 <kang> haskellCurry = \a->\b->f (a,b) -> c 
13:03:19 <kang> or now all wrong ? ;D
13:03:38 <monochrom> that obviously makes no sense.  (what is -> ?)
13:03:49 <kang> well nothing is obvious for me ^^
13:04:07 <kang> unfortunately ^^
13:04:29 <musasabi> btw most of the time one writes \a b -> instead of \a -> \b ->
13:04:44 <kang> ok
13:05:01 <Spark> what is that feature called?
13:05:03 <Spark> i keep forgetting
13:05:05 <Spark> inline functions?
13:05:13 <boegel> monochrom, I updated the paste page, but now it says "the last statement in a 'do' construct must be an expression"
13:05:20 <kang> how do i write it to have f::(a,b)->c  f'::a->b->c instead of just a and b ?;)
13:05:30 <monochrom> you have haskellCurry = \a->\b->f (a,b)  and it works fine.  I don't understand why you have to make your life hard.
13:05:35 <HET2> Spark: lambda statements i believe
13:05:41 <Spark> oh how dull
13:05:52 <Philippa> kang: don't bother typing in types
13:05:55 <Philippa> Spark: pattern matching
13:05:57 <kang> monochrom: well, my life is hard ^^
13:06:00 <musasabi> s/statement/expression/
13:06:01 <Philippa> lambdas in Haskell take patterns
13:06:11 <kang> ok so the c is hm
13:06:12 <HET2> Spark: uh saying that is like saying turing machines are dull when talking about descriptive languages
13:06:17 <Spark> oh do they really
13:06:20 <Spark> thats interesting
13:06:21 <kang> not important here because it'll stay there ?;)
13:06:25 <Spark> you end up with a partial function though?
13:06:26 <monochrom> boegel: delete "in "
13:06:41 <Spark> or can you specify an abstraction body for each possible pattern
13:06:46 <Philippa> kang: don't bother giving type annotations in Haskell for now. The compiler or interpreter will figure the types out on its own
13:06:56 <Spark> how is that advantageous compared to just using 'if'
13:06:57 <Philippa> Spark: potentially partial function, yeah
13:07:00 <monochrom> Inside a "do" block you can have "let" without "in".
13:07:19 <Philippa> you can't do that, that'd be \foo -> case foo of ...
13:07:27 <monochrom> In fact if you insist on including "in" you have to set up the indentation differently.
13:07:31 <Philippa> or you'd define it using where or let
13:07:41 <monochrom> So I'd just omit "in" and be happy.
13:07:42 <Philippa> heh
13:07:53 <Philippa> unless, of course, you don't want the scope to go that far
13:08:51 <boegel> monochrom, i thought let was always supposed to be used with in ? 
13:09:08 <Philippa> boegel: there's syntactic sugar in the do notation that avoids it
13:09:18 <monochrom> The rules for "do" blocks are different. :)
13:09:21 <kang> Philippa: but this function isn't converting exactly my f into f' no ?
13:09:30 <boegel> ok, thanks
13:09:52 * boegel feels trouble coming when he needs to write this in FunMath
13:10:12 <Philippa> kang: er, which function again?
13:10:17 <boegel> hmm, it takes forever now to render :s
13:10:48 <monochrom> "forever is a long, long time..."
13:10:50 <kang> Philippa: f::(a,b)->c  f'::a->b->c and the function is the one above with our life hard.
13:10:53 <kang> ups
13:10:57 <kang> scrolled when i copied :p
13:11:11 <Philippa> <kang> haskellCurry = \a->\b->f (a,b) <- that one?
13:11:18 <kang> haskellCurry = \a->\b->f (a,b) -> c
13:11:22 <kang> without c
13:11:24 <kang> yes
13:11:38 <Philippa> that's f', yeah
13:11:44 <boegel> monochrom, well, it's still rendering :s
13:11:50 <kang> hm but signature is still right ?
13:11:54 <boegel> and that for a 320x240 image
13:12:00 <boegel> :|
13:12:04 <Philippa> yes, f'::a->b->c
13:12:13 <Etaoin> kang: do you know that there is already a function that does that?
13:12:16 <kang> haskellCurry :: Int -> (Int -> Int) ?
13:12:21 <kang> Etaoin: its curry yes
13:12:29 <Philippa> you can check the type with hugs or ghci by typing :t <foo> where <foo> is an expression
13:12:46 <Philippa> Etaoin: I think this is an academic exercise somehow
13:13:04 <boegel> ow damn, I've made a mistake... I regenerate a random list _every_ time a pixel is shaded :s
13:13:09 <boegel> that can't be right :)
13:14:26 <boegel> hmm, I'm really doing this totally wrong :)
13:17:03 <monochrom> kang is unclear on a point.
13:17:23 <kang> monochrom: which?
13:17:29 <monochrom> Two possible interpretations.
13:17:51 <monochrom> 1. f is already given.  kang just needs to implement f'
13:18:18 <Philippa> 2. f is not given, but is to be a parameter to a curry function
13:18:28 <monochrom> Right.
13:23:59 <kang> what would be uncurry then ?
13:25:33 <monochrom> converts f' to f
13:26:00 <monochrom> curry converts f to f', uncurry goes the opposite way.
13:29:07 <kang> hm
13:32:17 <kang> i do'nt really konw how to make a -> to a  (,) ^^ 
13:32:42 <kang> f(a,b)->\a->\b ? ;D ok not ;)
13:36:51 <kang> hmm
13:38:06 <monochrom> That is the wrong way of thinking about it.
13:41:47 <kang> can u give a little push to my thinking so that it gets in the right way ? ^^
13:42:44 <tromp> is this the homework hour?
13:42:52 <kang> not really 
13:43:03 <kang> itss been more than one hour
13:43:18 <kang> in fact
13:43:46 <kang> my real prob is that its hard to do without knowing how it works previsouly and im not really a genius so i don't understand that fast ;D
13:44:04 <kang> so im trying to understand it so that i can explain it to a friend whom needs it..
13:44:13 <kang> that's... hmm.. well.. ^^
13:44:59 <kang> can't she ask me C or something ^^
13:47:15 <tromp> u mean like: how to swap two ints x and y without using additional variables?
13:47:25 <kang> well
13:47:46 <kang> we did the curry function for f::(a,b)->c to f'::a->b->c
13:47:51 <kang> now trying the reverse way
13:48:35 <kang> but obviosuly im clueless i guess 
13:50:49 <tromp> or you don't know where the Prelude is:(
13:51:04 <kang> i don't know what is prelude about;)
13:51:38 <kang> tromp: but if you can step me in the right direction ^^
13:51:55 <tromp> google?!
13:52:04 <kang> oh, he cant;)
13:54:43 <Etaoin> the Prelude is a bunch of stuff that's already defined for you. you've already said you don't want to use curry and uncurry, though.
13:58:02 <kang> Etaoin: indeed
14:01:25 <boegel> I just heard my friend was here this morning
14:01:35 <boegel> anyone talked him ? (mitchkov)
14:01:42 <boegel> <insert> to
14:10:16 <jadrian2> sequence[lower, many letter]  looks way much better than  do {l<-lower; cs <-many letter; return (l:cs)}  doesn't it?
14:12:43 <bourbaki> for all who wanna see our cool toy robot :) http://amy.informatik.uos.de/autorob/
14:14:42 <boegel> bourbaki, my friend was here this morning... you missed him
14:14:52 <bourbaki> heh i was at uni
14:14:55 <bourbaki> once again :)
14:15:03 <boegel> he'll come back probably
14:15:08 <boegel> but he has too much work now
14:15:53 <bourbaki> boegel have a lok at the video :)
14:16:14 <boegel> bourbaki, which coded is it ?
14:16:22 <boegel> I'm not sure if I'll be able to read it
14:16:32 <bourbaki> divx
14:16:37 <bourbaki> winamp can
14:16:39 <boegel> I'll give it a try
14:16:43 <boegel> I'm in linux :)
14:16:57 <boegel> maybe totem will be able to handle it
14:17:17 <bourbaki> mplayer can also :)
14:19:16 <boegel> it doesn't work, I don't have the divx coded
14:19:21 <boegel> s/coded/codec
14:19:58 <bourbaki> why dont you install mplayer?
14:22:53 <boegel> bourbaki, because I'm working on my perlin noise... you'll have lot's of nifty images in a few minutes ;)
14:24:26 <bourbaki> heh be quick im about to go to bed
14:24:45 <kang> uncurry = snif
14:25:02 <boegel> bourbaki, give me ten minutes or so
14:25:56 <bourbaki> boegel ok hurry though im tired already
14:28:32 <monochrom> f (a,b) = f' a b
14:28:35 <bourbaki> moin Pseudonym
14:29:07 <Pseudonym> G'day.
14:31:04 <boegel> bourbaki, uploading now
14:31:10 <bourbaki> kk
14:31:18 <bourbaki> stupid internet be more fast
14:31:28 <boegel> bourbaki, http://studwww.ugent.be/~kehoste/thesisPublic/website/
14:32:04 <bourbaki> how did you do the rescale now?
14:32:21 <boegel> using +1/2
14:32:40 <boegel> I don't get the very dark or very bright values, but that's just noise's fault, not mine ;)
14:33:02 <bourbaki> heh ;)
14:33:10 <boegel> I'm trying to get marble and wood working now
14:33:19 <boegel> but I think I'll better leave that until tomorrow...
14:34:30 <bourbaki> :)
14:34:45 <boegel> I think you can see the difference between the several techniques quite good, am I right ?
14:36:27 <bourbaki> yep
14:36:38 <bourbaki> are you gonna introduce more then these objects?
14:37:05 <bourbaki> it would be cool if we could merge my spline stuff with your raytracer
14:39:06 <boegel> bourbaki, maybe later on...
14:39:30 <boegel> I have to do some other stuff with this for my thesis... like writing a GUI, and proving some stuff about it
14:39:47 <boegel> I'll probably add cubes, piramids, stuff like tha
14:39:48 <boegel> t
14:40:00 <boegel> but probably after I finished my thesis
14:40:08 <bourbaki> aha well add polynomail surfaces :)
14:40:47 <boegel> bourbaki, all I have to do is add a intersection test and a getNormal function for each object i want to support, so it shouldn't be too hard
14:41:09 <boegel> the rest should happen as if it is magic ;)
14:41:11 <bourbaki> ah well the latter i can give you already
14:41:25 <bourbaki> i have to think about how to do the ray intersection though
14:41:40 <bourbaki> if im gonna write it you can just throw it in?
14:42:01 <boegel> yes
14:42:06 <boegel> if you respect my types
14:42:12 <boegel> it shouldn't be a problem
14:42:15 <bourbaki> hah im a rebel :)
14:42:34 <boegel> but I shouldn't show you any ofmy code until I finished my thesis
14:42:43 <bourbaki> im gonna lookinto that another day then id like you to render my surfaces
14:42:46 <boegel> that's until June 2005 :)
14:42:50 <bourbaki> ah dang
14:43:03 <bourbaki> until that day ill have written my own raytracer
14:43:13 <boegel> I can show you one function (intersectWithSphere) or so, but not the whole code
14:43:27 <boegel> I could be accused of just stealing the code of someone then...
14:44:26 <bourbaki> sure
14:45:26 <marcot> Hello folks.
14:46:08 <boegel> hello marcot 
14:46:18 <marcot> boegel: how are you?
14:47:52 <bourbaki> ah hi marcot :)
14:48:03 <marcot> bourbaki: hello!
14:48:03 <bourbaki> marcot had a look at the paper i send to you via boegel?
14:48:21 <marcot> bourbaki: humm... what paper?
14:48:31 <bourbaki> marcot that sound synthesis paper
14:48:46 <boegel> bourbaki, you are talking to the wrong guy :)
14:48:51 <bourbaki> ok
14:48:54 <bourbaki> as usual
14:48:55 <marcot> bourbaki: I think you're thinking about somebody else.
14:48:55 <boegel> my friend is mitchkov, not marcot:)
14:49:00 <bourbaki> most of the time i talk to myself :)
14:49:03 <boegel> heh
14:49:04 <marcot> boegel: it's similar.. (=
14:49:10 <bourbaki> all these names with m
14:49:21 <marcot> all these with bs.
14:49:33 <bourbaki> bs?
14:49:43 <marcot> But where can I get documentation about networking with haskell in a simple way?
14:49:51 <stepcut> hrm, apparently my Depends line can not be longer than 32k or apt will barf :(
14:50:00 <marcot> Like, with examples and stuff..
14:51:01 <boegel> bourbaki, mitchkov is coming !
14:51:18 <boegel> and I have a class in 8.5 hours, so I should get to bed :s
14:51:30 <bourbaki> i have one in 8h :)
14:51:44 <bourbaki> hi mitchkov :)
14:51:57 <mitchkov> @bourbaki: thx for the paper you send me :)
14:51:57 <bourbaki> got the paper i send to you via boegel?
14:51:57 <lambdabot> Sorry, I don't know the command "bourbaki:", try "lambdabot: @listcommands
14:51:57 <marcot> I'm actually with a working code in networking, but I can't connect it to my program. d=
14:52:20 <bourbaki> mitchkov np :)
14:52:21 <mitchkov> idd :) it was very helpful implementing a better definition for reverb
14:52:36 <marcot> http://tonhao.no-ip.org/~marcot/xadrez/Conexao.hs
14:52:43 <bourbaki> mitchkov can you use that stuff to synthetisise language as well?
14:52:48 <boegel> mitchkov, I told you coming here would help you ;)
14:52:56 <mitchkov> if you know a lot of that stuff, you really can help me a lot
14:53:26 <bourbaki> maybe id like to tinker a bit with that stuff to synthetizise langauge
14:54:04 <mitchkov> uhu
14:54:30 <bourbaki> would just have to come up with a good representation for a neural net
14:55:17 <mitchkov> what do you mean with "synthesise language" ?
14:55:33 <bourbaki> that you plug in some word and he spells it
14:55:35 <boegel> bourbaki, I don't no either :)
14:56:59 <aFlag> what's up marcot?
14:57:03 <boegel> bourbaki, you mean like speech recognision ?
14:57:23 <monochrom> A neural network will exhibit all kinds of shortcomings the human race is famous for.  For example: local minimum (aka "learning the wrong habits").
14:57:23 <bourbaki> boegel no the other way around
14:57:34 <boegel> oh like that
14:57:37 <bourbaki> synthetization of speach not recognizeing it
14:58:44 <bourbaki> maybe if one couples the synthetization to the surrounding letters and the context of a text you could have a really cool synthesizer
14:59:19 <boegel> bourbaki, that's no easy task
14:59:27 <bourbaki> boegel why is that?
14:59:46 <boegel> 'the context' is quite difficult to recognize I think
15:00:42 <bourbaki> yes but you could just do a naiive bayes
15:01:13 <boegel> damn, I can't get this marble effect to work :(
15:03:06 <boegel> this is the best I can do so far: file:///home/boegel/thesis/website/16_11_2004/perlinMarbleTest.png
15:04:44 <boegel> and it should look something like this: http://www.noisemachine.com/talk1/23.html
15:04:49 <boegel> anyways, I'm going to bed
15:04:56 <boegel> I'll work on it tomorrow
15:06:48 <boegel> bye !
15:07:37 <wagle> anything new with subtypes in haskell? 
15:07:53 <Etaoin> I wrote a cooperative multitasking framework with the continuation monad, but it's leaking memory somehow :(
15:08:58 <wilx> Yay!!!
15:08:59 <Philippa> wagle: I'm starting to suspect I'm crazy enough to try taking my dissertation project as far as Haskell 98 + supertyping (I choose to express it that way round for a reason)
15:09:13 <wilx> How are we supposed to access his file:// :D
15:09:20 <Philippa> granted, one of the reasons I'm that crazy is I've ended up with four years to do the project in
15:09:24 <Etaoin> it sucks, because when there's one process, it doesn't leak, but when there's two or more it does.
15:09:48 <wagle> why haskell 98?
15:10:04 <wagle> (i find myself alway turning off 98)
15:10:21 <wagle> what do you mean by supertyping?
15:10:36 <Philippa> it's the same relationship looked at the other way, if that makes sense
15:10:52 <Philippa> in particular, you're free to add a new supertype to a type, but not a new subtype (because it fucks up pattern matching no end)
15:11:11 <Philippa> and 98 because it's that or having to take into account all the extensions as well
15:12:55 <wagle> so fix pattern matching
15:12:58 <wagle> >)
15:15:19 <Philippa> you can't, that's the point
15:15:22 <wagle> why use epicycles?
15:15:25 <Philippa> adding a subtype implies adding a constructor
15:16:18 <Philippa> because I'm not doing so? I'm just doing something that's dual to the traditional OO/interface subtyping thing that typeclasses already capture
15:16:46 <Philippa> you even get a dual of inheritance, which looks likely to interact well with typeclasses
15:16:47 * wagle is thinking
15:17:22 <Philippa> in that it stops you creating a scary unpredictable situation with them where the subtype cast to a supertype acts differently to the subtype as-is
15:17:23 <bourbaki> off to bed nighto
15:18:30 <wagle> (you do get to claim that pattern matching subtypes is analogous to epicycles)
15:19:36 <wagle> the controlled scientific "experiment" is to try it both ways, and find out which is objectively better
15:19:51 <wagle> (that i'd like to see)
15:20:10 <Philippa> I've got something that works but it's just H-M plus this and the interpreter doesn't do IO
15:20:40 <wagle> of course, i've only been thinking about sub/sup types and pattern matching for a few minutes
15:21:26 <Philippa> if you allow "open" subtyping on ADTs, pattern-matching gets broken fast - you can never know you've written a total function because some bastard could've added a new constructor you don't know about
15:22:00 <wagle> whats "open"?
15:22:06 <Spark> opposite of closed :)
15:22:27 <Philippa> where you can add new subtypes at will (eg most OO systems)
15:24:34 <Philippa> if you think for a moment, with ADTs adding a subtype is extending the interface of all its supertypes
15:24:54 <wagle> as i recall, java computes method and instance offsets at load time..  seems like that sort of thing might help (unless I'm more confused than i think)
15:25:23 <Philippa> yeah, you are. You don't need any of that crap, because ADTs don't carry methods in the first place
15:25:40 <Philippa> you're not subtyping structs, you're subtyping unions
15:25:51 <wagle> i was thinking of methods as being analygous to constructors
15:26:34 <wagle> ok, its surprising that supertypes gain the constructors of the sub-types
15:26:36 <Philippa> Sort of. Only all you actually need at runtime is a big pile of tags
15:26:41 <Philippa> is it?
15:26:56 <Philippa> the supertype contains all the values that're in the subtypes
15:27:45 <Pseudonym> As a matter of curiosity, what's the analogue of inheritance in this scheme?
15:27:57 <wagle> yeah, but i imagine them as being inaccessible when cast as supertype..  (mind you I'm thinking of my subtyping experiment in java here (informed by system F))
15:29:18 <Philippa> Pseudonym: functions defined on the supertype pinch cases from those defined on the subtype
15:29:46 <Pseudonym> So you can use a function defined on a subtype with the supertype.
15:29:48 <Philippa> works nicely for typeclasses, you just outlaw overriding and you get consistent behaviour
15:30:09 <Philippa> no, just as part of the coinherited function on the supertype
15:30:30 <wagle> in java, (if i recall correctly, its been a while, but is on top of my job list to find it again)i used interface's to force the subtypes to share methods in a sort of controlled multiple inheritancec
15:31:01 <Pseudonym> Hmmm.
15:31:16 <Pseudonym> Still trying to work out what that would look like.
15:33:26 <wagle> i implemented a sort of semantics of scheme in java, but grew discouraged when I got a big soup of little tiny one-liner methods (reduced all conditionals to virtual method dispatch)..  it was only later that i found out that I had done it right
15:34:35 <wagle> (the helloworld program for schemeheads is to write a scheme interpreter in each new language)
15:35:50 <Philippa_> I gathered :-)
15:35:55 <Philippa_> Java is... shall we say not my favourite language?
16:18:52 <wagle> Philippa_: haha
16:32:35 <xerox> a question
16:32:46 <xerox> is there a big difference between haskell and ocaml?
16:34:46 <juhp> xerox: yes - Haskell uses lazy evaluation for example
16:34:55 <Pseudonym> And Haskell is pure.
16:35:08 <Pseudonym> But they do have substantially similar goals.
16:35:24 <pflanze> Hello. Can you recommend a wiki written in haskell?
16:35:30 <xerox> what does lazy evaluation means?
16:35:59 <Pseudonym> Philippa wrote one.
16:36:43 <Pseudonym> http://www.flippac.org/projects/flippi/
16:36:47 <juhp> xerox: late evaluation by need
16:36:53 <Pseudonym> Never used it, so I don't know how complete it is.
16:38:53 <juhp> pflanze: I tried it a little while back - seemed to work pretty well though it is probably not as featureful as some of the better known ones
16:39:29 <pflanze> I need version history/handling, and a bit of formatting.
16:39:50 <pflanze> Multiple pages, but that's about it.
16:41:13 <juhp> pflanze: there is a demo wiki on the above site I believe
16:43:13 <stepcut> xerox: type classes!
16:43:27 <xerox> what?
16:45:30 <Riastradh> OCaml lacks type classes.
16:46:56 <ows> is there some modelling lang available to model Haskell lang projects?
16:47:30 <Pseudonym> Ideally, you shouldn't need it.
16:48:50 <Pseudonym> Haskell, being multi-paradigm, supports just about any on-paper modelling system.
16:49:13 <ows> I don't think so.. If you are going to do a big project (with probably 10 modules) how can you manage all that things without a model?
16:49:28 <Pseudonym> Unless it's an exclusively OO system.  Haskell's OO support isn't so good.
16:50:51 <Pseudonym> First off, 10 modules isn't that big, but I'm sidestepping your point here.
16:51:11 <Pseudonym> The answer to your question is: The same way you would in any other language.
16:51:20 <ows> no!
16:51:28 <Pseudonym> Analysis happens primarily in the problem domain, not the solution domain, surely?
16:51:43 <ows> with OO langs we have UML.. and about functional lang?
16:52:00 <Pseudonym> Well we've had functional decomposition for over 30 years.
16:52:06 <ows> do we have an universal modelling lang?
16:52:26 <Pseudonym> No, we don't.
16:52:31 <ows> so...
16:52:34 <Pseudonym> We also don't have a universal programming language/
16:52:42 <ows> yeah, right
16:53:06 <ows> but this modelling lang help you so much managing the project all the time
16:53:18 <wagle> i see people make diagrams where the oo approaches modularizes things vertically, and functional approach horizontally (ie, orthogonally)
16:53:42 <Pseudonym> It's my bias, BTW.  I'm an agile programming advocate.
16:53:45 <whee> UML has always gotten in the way for projects I've been involved in
16:53:53 <whee> the second we create those diagrams, they're out of date :P
16:53:55 <Pseudonym> And Haskell definitely supports agile programming.
16:54:22 <Pseudonym> Over here, we do R&D as opposed to just D.
16:54:29 <wagle> ok..  what is "agile" programming?  (just realized that i've never gotten around to figuring that out)
16:54:35 <Pseudonym> And if you know what you're doing before you start, it's not research.
16:54:44 <ows> (My point of view)
16:55:08 <Pseudonym> wagle: Agile programming basically teaches that requirements, deadlines and budgets change, and you need to be able to adapt as you go.
16:55:28 <wagle> yeah, but you gotta make the case that you WILL figure it out if they give you the money
16:55:28 <Pseudonym> Doing a big design up front is, therefore, often a waste of time.
16:55:36 <Pseudonym> Yes, that's true.
16:56:01 <Pseudonym> And in some domains (e.g. safety-critical or mission-critical), the "big design" is still the way to go.
16:56:31 <wagle> so agile programs are unreliable?  >)
16:56:42 <Pseudonym> Actually, no.  They're often more reliable.
16:57:00 <xerox> how is called that thing that not permises runtime errors?
16:57:16 <Pseudonym> The idea of agile programming is constant correction as you go.
16:57:33 <Pseudonym> And you start off a small thing, add to it, and then redesign (i.e. refactor).
16:57:43 <Pseudonym> Eventually, the design takes shape as you go.
16:57:45 <xerox> over.. ?
16:57:48 <wagle> agile programming is the "constant refactoring" part of extreme programmng?
16:57:59 <Pseudonym> Agile programming is a superset of extreme programming.
16:58:15 <tuomov> too strict plans are always doomed to failure.
16:58:26 <Pseudonym> Most open source projects, for example, aren't XP, but most of the ones that go anywhere are agile.
16:58:32 <tuomov> better just have some loose big picture of what you might want, and then start from the bottom
16:58:46 <Pseudonym> tuomov: That's not _always_ true.
16:58:52 <Pseudonym> You can't write avionics software that way.
16:59:01 <Pseudonym> Hence my qualification.
16:59:51 <Spark> what is a lambda model?
16:59:55 <tuomov> and most of all, it is not fun writing to strict specs
17:00:29 <tuomov> awful bureucracy if you want to change a small aspect
17:00:52 <Pseudonym> Interestingly, I was just reading the Holub articles on getters and setters.
17:00:55 <Spark> specs are usually nonsense anyway
17:01:02 <Spark> since they are written by people who dont understand
17:01:03 <wagle> what does agile programming include that extreme programming doesnt?
17:01:19 <Spark> wagle: i have a course that covers it, do you want me to point you to the page?
17:01:26 <whee> Spark: government specifications are the best :)
17:01:27 <Pseudonym> Agile programming is a philosophy.  Extreme programming is a specific methodology.
17:01:35 <wagle> i just wanted a short soundbite (about to take off)
17:01:51 <Spark> http://www.doc.ic.ac.uk/%7Esue/475/lec%209%20-%20agile%20-%20no%20jokes.pdf
17:01:53 <Spark> for later then :)
17:01:59 <wagle> heh
17:02:06 <Spark> print it and tkae it with you
17:02:18 <Pseudonym> Anyway, I suppose I still haven't addressed ows' question.
17:02:20 <wagle> no printer in this coffee shop..  8)
17:02:21 <Pseudonym> :-)
17:02:54 <Pseudonym> UML is very OO-specific.
17:03:07 <Pseudonym> You wouldn't use UML to model, say, a relational database problem.
17:03:33 <ows> yeah that's true
17:03:41 <Pseudonym> But we actually have a whole bunch of older methods, some of them dataflow-based or functional-based, which still apply if you need them.
17:03:45 <Pseudonym> However.
17:03:46 <ows> you use ER to databases and UML to software
17:03:53 * wagle is gone
17:03:59 <Pseudonym> The theory of higher-level programming is that you can say a lot with less code.
17:04:14 <Pseudonym> So older methods are somewhat subsumed.
17:04:29 <Pseudonym> What used to be a design method, or a modelling method, is now built into the programming language.
17:04:45 <Pseudonym> So a "module" in Haskell is actually a higher-level concept.
17:04:59 <Pseudonym> It's even higher level than a "class" in UML.
17:05:18 <Pseudonym> The individual things in a module, such as algebraic data types, are often their own models.
17:05:35 <Pseudonym> An algebraic data type, for example, _is_ a concrete implementation of a universal algebra model.
17:06:35 <Pseudonym> The _real_ reason why we don't have a modelling language for Haskell is that to be of any use, it'd have to be higher level than UML, and we don't really know how to describe that yet.
17:06:50 <Pseudonym> This is one reason why you see category theory and functional programming go together a lot.
17:07:14 <Pseudonym> Not only does category theory provide a nice way to describe FP, it's also the only way we currently know how to go to model it.
17:07:47 <Pseudonym> So the short answer is: No, we don't have a modelling language as such.
17:07:57 <Pseudonym> But the longer answer is: You're actually not as likely to need one at the moment.
17:09:02 <Pseudonym> Did that help?
17:09:13 <Pseudonym> BTW, I'm _still_ probably not answering your question. :-)
17:09:31 <Pseudonym> Because we do actually have mechanisms (now) for modelling things at levels higher than UML.
17:09:39 <Pseudonym> Component-based programming, for example.
17:09:57 <Pseudonym> We have CORBA and COM, which provide mechanisms for understanding components in the large.
17:10:03 <Pseudonym> Without looking inside them.
17:11:40 <ows> so, do you mean that haskell is more abstract that lisp?
17:12:16 <Pseudonym> Yes.
17:12:35 <Pseudonym> Lisp, for all its strengths, actually doesn't have many mechanisms for abstraction.
17:13:01 <Pseudonym> Modern Lisp has great ways to organise code.
17:13:14 <Pseudonym> But it still doesn't really have a way to describe a type.
17:13:14 <Riastradh> What 'methods of abstraction' does Haskell have that Lisp doesn't?
17:13:24 <ows> How do you order main languages with their level of abstraction?
17:13:34 <ows> (asm, haskell, lisp, java, c)
17:13:37 <Pseudonym> Riastradh: It is statically checked, for once.
17:13:40 <Pseudonym> ows: I don't.
17:13:57 <Riastradh> Mandated static verification implies more abstraction?
17:14:16 <Pseudonym> Abstraction, IMO, doesn't even follow a single dimensional continuum, let alone discrete strata.
17:14:34 <Pseudonym> Riastradh: Not in and of itself.
17:14:59 <Pseudonym> But the static verification mechanisms guarantee, to a first approximation, that some construct satisfies an abstract interface.,
17:15:24 <Pseudonym> The abstract interface is one of the building blocks of Haskell's abstraction mechanisms.
17:15:55 <ows> well, you have english lang as your highest level of abstraction...
17:16:02 <Pseudonym> Hardly. :-)
17:16:04 <Riastradh> Hah.  Certainly not.
17:16:07 <Pseudonym> English is horribly imprecise.
17:16:21 <ows> so... U only have to translate them to UML
17:16:25 <ows> and after to OO code
17:16:30 <Pseudonym> We usually don't notice until we try to implement a badly worded specification or file a lawsuit.
17:16:50 <tuomov> english is the highest level of obfuscation
17:16:56 <tuomov> (or whatever natural lang)
17:16:58 <Pseudonym> UML doesn't describe a problem, though.  It describes a solution.
17:17:11 <Pseudonym> You can't specify TCP (say) using UML.
17:17:25 <Pseudonym> You can specify how a TCP stack might be written.
17:17:29 <monochrom> UML is horribly ambiguous too.
17:17:32 <Pseudonym> (In an OO language.)
17:17:48 <monochrom> Right! UML doesn't describe problems.
17:18:01 <Pseudonym> I haven't used UML, so I can't comment on how handy it is for what it's designed to do.
17:18:44 <monochrom> To have true abstraction you must be able to say: what problem your program solves.  You cannot describe what strategy you use to solve it.  You must describe the problem itself alone.
17:18:55 <tuomov> I think it is just bullshit so that managers have one more buzzword to talk about and can draw figures :)
17:19:24 <Pseudonym> Actually, management is the key reason for most of these big-M Methodologies, and not for the reason that you think.
17:19:40 <Pseudonym> They describe ways to hand out work packages and ways to measure progress.
17:20:25 <Pseudonym> Personally, I prefer the agile understanding, where you measure progress by features implemented.
17:20:32 <Pseudonym> Rather than modules written.
17:21:31 <Pseudonym> Riastradh: This is one reason that I personally prefer Haskell to, say, Lisp.
17:21:45 <Pseudonym> Static typing fits my biasses better.
17:22:07 <Pseudonym> I believe in agressive refactoring, and static typing makes aggressive refactoring easier.
17:22:20 <Pseudonym> IMO
17:22:38 <Riastradh> I couldn't help but notice the way in which 'biasses' could be misread to completely change the meaning of that sentence.
17:22:48 <tuomov> that's quite true. out-of-datedness related bugs easily seep into dynamic code
17:23:11 <monochrom> Static verification itself does not cause abstraction.  But it can be a catalyst in the right circumstance.  If you try to make static verification scalable, you will have to add abstraction mechanisms and encourage people to use them, because compositional reasoning is your only hope.
17:23:20 <tuomov> not to mention C casts...
17:23:40 <tuomov> just subtyping would make C a lot safer language
17:23:42 <Pseudonym> The fact is, you can do agile programming in any language.
17:23:44 <Riastradh> I don't disagree about static type analysis, but the rigidity of Haskell's & ML's is what bothers me.
17:23:57 <Pseudonym> Riastradh: That's understandable.
17:24:18 <Pseudonym> The price you pay is that writing small programs, or small additions to a program, may be more expensive.
17:26:21 <Pseudonym> A small change can have large ripple-like consequences.
17:28:37 <Pseudonym> But in a large program, the consequences might still be there in a more dynamically-typed language, only you're less aware of it at compile time.
17:28:48 <Pseudonym> I'm sometimes shocked by how big an effect a small change has.
17:28:54 <monochrom> A small change can have large avalanche consequences, but is true of programs written in any form anyway.  My naive philosophy is: I actually want some computer to yell at me about it, and I understand that some people feel their ego hurted when a computer yells at them.
17:29:16 <Pseudonym> And discovering how big the effect is is often a good reality check on the change.
17:29:37 <Pseudonym> monochrom: I don't think that Riastradh was necessarily disagreeing with that.
17:29:52 <Pseudonym> I think his point was that Haskell or ML's static checking isn't a "sweet spot".
17:30:01 <Pseudonym> Which is a perfectly defensible position.
17:30:03 <monochrom> Understood.
17:30:40 <Riastradh> I certainly don't deny the effectiveness of static correctness analysis; indeed, I dislike its absence.  But it's rigidity of limited static correctness analysis (such as strict type inference) that people cite so grandly and that drastically limits the actual set of correct programs.
17:31:09 <monochrom> I have the dynamic-type (Perl, Python) bigots in mind.  I think they are cowards who refuse to admit that the computer is superior to them.  Sorry I've been reading too much of Asimov's robot novels lately. :D
17:31:40 <Pseudonym> Riastradh: It also drastically limits the set of non-robust programs.
17:32:11 <Riastradh> Sure.  But so does a non-rigid static correctness analysis.
17:32:23 <Pseudonym> It depends, I think.
17:32:40 <Pseudonym> Ideally you want to match the analysis with the stringency of your "correctness" metric.
17:32:52 <Riastradh> No static analysis is omniscient, but neither is a lack of static analysis ideal.
17:33:03 <Pseudonym> Haskell and ML, for example, provide just the right amount of correctness analysis to write a compiler for Haskell or ML.
17:33:34 <Pseudonym> But it's probably not the right amount to write a telephone exchange.
17:34:23 <Riastradh> To continue the analogy monochrom mentions of the computer being smarter than the programmer, it is my opinion that the computer should say 'duh!' to the programmer when the programmer is being stupid, but that the computer should not say 'hmmm, I don't know about this -- ehhhhh!' if the static analysis is merely inadequate in power.
17:34:40 <Riastradh> ('Power' was probably the wrong term.  Oops.)
17:34:54 <Pseudonym> I actually don't see the computer as being smarter than me.
17:35:00 <Pseudonym> Actually, the opposite is true.
17:35:04 <Riastradh> I don't either.
17:35:23 <Pseudonym> Haskell's static analysis makes me explain my thoughts in more detail so that even a stupid computer can "get it".
17:35:33 <Pseudonym> And like a teddy bear, the act of talking to it makes me feel better.
17:35:37 <Riastradh> It's the computer that is being dumb when it says 'this program is incorrect' due to its inadequacy in correctness analysis.
17:35:41 <Pseudonym> It helps me straighten out what I'm thinking.
17:36:30 <Pseudonym> I'm an assertive programmer, as Weinberg would say.  So I tend to think high, lofty thoughts and occasionally miss the trees while I'm trying to describe a forest.
17:37:27 <Pseudonym> I'd say 98% of errors that a Haskell compiler reported to me was due to me writing a bug.
17:37:41 <Pseudonym> Maybe 1% was due to the type system being inadequate.
17:37:59 <Pseudonym> My percentage is probably higher than most because I like to live life on the edge, so to speak.
17:38:56 <Pseudonym> Actually, that's not entirely true.
17:38:58 <Riastradh> Scheme48's simplistic static type system often suffices for me for common errors (and only if they really are errors!), though it is extremely rudimentary.
17:38:59 <blackdog_> Riastradh: could you point me to a correct program in a dynamically typed language which is really difficult to render in Haskell?
17:39:20 <Pseudonym> Maybe 20% is due to be writing a bug and 78% is due to me making a change whose consequences haven't been rippled through fully.
17:39:22 <Riastradh> blackdog_, anything involving run-time type conditionalization.
17:41:23 <blackdog_> Riastradh: sorry, I don't understand exactly what you mean. Would the sort of runtime plugin support hs-plugins offers be what you're talking about?
17:42:19 <Pseudonym> Actually, a good example is the kind of problem that Philippa is trying to solve with supertypes.
17:43:00 <Pseudonym> Where you have a conceptual data type which you want to be able to extend.
17:43:01 <dons> is "runtime type conditionalisation" just typecase?
17:43:21 <Riastradh> Anything involving testing run-time type tags, which Haskell's static type system does not represent.
17:43:30 <Pseudonym> And you don't want to centralise all of the possible "constructors" (for lack of a better term) in one place.
17:43:35 <Riastradh> Right.
17:44:11 <Riastradh> I don't claim that Haskell can in no way have dynamic type information (indeed, constructors really are that), but rather that its static type system is inadequate to express all run-time type flow.
17:44:12 <dons> testing runtime type tags is done via dynamics, however. which work quite well in Haskell. there are a variety of ways to do it, too.
17:44:20 <dons> that''s not really a problem in Haskell at all
17:44:48 <Pseudonym> dons, the problem isn't that you can't express it.
17:44:55 <Pseudonym> The problem is that you can't express it cleanly enough.
17:45:01 <Riastradh> I'm not claiming it is.  I'm pointing out that Haskell's _static_ type system is merely inadequate to express run-time type dataflow.
17:45:25 <Riastradh> You can gloss over the details of it with dynamics, but that's not expressing it.
17:45:45 <tuomov> dynamics don't work with type classes..
17:45:45 <Pseudonym> that's a good way of describing it, actually.
17:46:01 <Pseudonym> Right.  You can't dynamically recover a typeclass instance at run-time.
17:46:11 <Pseudonym> You can recover a concrete type, but not a typeclass instance.
17:46:37 <dons> yep. a limitation in dynamics in Haskell. I wonder if it matters. Maybe you shouldn't be writing this kind of code
17:47:10 <Pseudonym> dons: That may well be, but you should at the very least have a proposed solution to the types of problem where this customarily turns up.
17:47:18 <dons> just like we don't like gotos, or self-modifying code either. dynamics might be on the edge of what is decent
17:47:29 <tuomov> it seems rather essential if you want to have an extensible program
17:47:47 <tuomov> so you can just plug in new kinds of objects and stuff
17:47:52 <Riastradh> For Haskellers, fine, dons, but I'm a Lisper.
17:47:55 <Pseudonym> Reading Philippa's discussion earlier, I think she is heading in the right direction.
17:48:05 <dons> tuomov: this may be true. i'm not sure yet
17:48:10 <Pseudonym> Though I reserve judgement until I actually try out her solution.
17:48:19 <blackdog_> so why can't you recover instances of typeclasses dynamically? Is it an inherent problem?
17:48:27 <Pseudonym> blackdog_: Yes.
17:48:33 <Riastradh> blackdog_, only if you keep typeclass tables around at run-time.
17:48:54 <dons> it was so nice to throw away all type information at runtime though, sigh
17:49:21 <Pseudonym> I think of it in the same way as global state.
17:49:27 <Pseudonym> We threw away global state.  SO far, so good.
17:49:41 <Riastradh> Type information is not thrown away at run-time in Haskell anyway.  It is just lessened in scale; constructors, after all, do contain dynamic information.
17:49:44 <Pseudonym> But now we need a way to solve problems where global state is arguably useful.
17:50:20 <Pseudonym> So we introduce monads, and other tools like that.
17:52:15 <Pseudonym> Constraining yourself enhances creativity.
17:52:15 <tuomov> quite true
17:52:15 <Pseudonym> I'm optimistic that the solution to this problem that we come up with will be much, much better, and more widely applicable, than simply making the type system less static.
17:52:16 <Pseudonym> And I'm only basing that on past experience with other problems, not with this problem specifically.
17:52:16 <Riastradh> Monads are a clumsy way to do it: you have to pass around the world whenever you use it.  Similarly, dynamics are clumsy in their interaction with the static type system: you just gloss over the detials without actually expressing run-time type dataflow well.
17:52:16 <Pseudonym> In the mean time, you know where Scheme is if that's what you want. :-)
17:52:47 <Pseudonym> I'm not going to defend GHC's dynamics.
17:53:15 <Pseudonym> Riastradh: That's true, but then we have other solutions, such as the implicit configuration solution.
17:53:21 <Pseudonym> I'd love to see that built-in, BTW.
17:53:27 <Pseudonym> So you can do it without the space leak or serialisation.
17:53:28 <Riastradh> Mmmmmmm.  Discussing these matters with a non-inflammatory crowd is so nice after having had arguments about them with no one but Smerdyakov for months.
17:53:30 <tuomov> it is possible to solve this problem to some type with existentials
17:53:34 <tuomov> but you need a wrapper instance
17:53:44 <tuomov> s/type/extent/
17:53:57 <Pseudonym> I also think that GHC's dynamic type thingy is a gross hack.
17:54:22 <Pseudonym> It's sadly necessary sometimes, but it's not a complete solution.
17:54:39 <Pseudonym> At least it's less of a hack than unsafePerformIO.
17:54:58 <tuomov> and writing that wrapper instance can be a lot of mechanical work
17:55:11 <dons> no. it's not a hack. encode types to the value level, is all. we encode values in the type level all the time these days, so why is the other way around a hack?
17:55:12 <tuomov> maybe if haskell supported generating that wrapper automagically
17:55:14 <Pseudonym> Though template haskell will help there, if it ever gets fully integrated.
17:55:34 <Pseudonym> Automatically derived typeclasses are a bit of a wart on the language.
17:55:34 <dons> tuomov: do you mean deriving Typeable ?
17:55:39 <tuomov> no
17:55:58 <Pseudonym> Some kind of TH-like system would help a great deal.
17:56:05 <tuomov> class Foo a where ... ; data AnyFoo = forall a. Foo a => AnyFoo a; instance Foo AnyFoo where ...
17:56:15 <dons> ok. 
17:56:20 <tuomov> having to manually write that instance is what should be automatic
17:56:27 <tuomov> but of course there are practical problems there
17:57:16 <Spark> what is a lambda model?
17:57:17 <tuomov> otherwise that way I can have [AnyFoo Bar, AnyFoo Baz]
17:57:31 <Pseudonym> Spark: Context?
17:57:32 <Spark> the internet wont tell me :(
17:58:26 <Pseudonym> dons: Actually, the mechanisms that we have to encode values in the type level are also a bit hacky.
17:58:44 <dons> ah well. at least they are statically checked ;)
17:58:47 <Pseudonym> It'd be nice if we had one systematic way to encode a value at the type level.
17:58:58 <Pseudonym> That always worked, was efficient, and didn't leak.
18:00:02 <Spark> Pseudonym: "Let M = <D,.,[[]]> be a lambda-model..."
18:00:12 <Spark> type theory
18:00:28 <Pseudonym> Does it mean "model of lambda calculus"?
18:02:50 <Spark> dunno
18:02:56 <Spark> i have no idea what M is
18:03:04 <Spark> later on, it refers to D
18:03:31 <Spark> invents a function from the set of all type variables to the powersetof(D)
18:04:01 <Spark> oh, simple semantics?
18:04:09 * Spark loops up [8]
18:04:43 <Spark> hindley the completeness thereom for typing lamda-terms
18:04:46 <Spark> 83
18:05:02 <Spark> apparently simple semantics is from that
18:05:26 <Spark> they really throw me in the deep end, reading papers that are older than i am, that assume knowledge that i dont have
18:15:29 <tuomov> and of course the knowledge is in some other obscure old paper that is nowhere available
19:09:10 <Spark> yeah
19:09:15 <Spark> i cant even find the paper im reading online
19:46:21 <Spark> i want a voodoo doll in the shape of a lambda that i can stick pins into
19:55:46 <heatsink> how about arrows?
20:13:17 <karingo> o
20:37:30 <SyntaxNinja> hi segphault
20:37:48 <segphault> hello
20:41:51 <segphault> has anybody been up to anything interesting?
20:42:41 <Pseudonym> Found an interesting piece of behaviour on Solaris.
20:42:51 <Pseudonym> Nothing to do with Haskell.
20:43:03 <segphault> what version? have you tested the trial of solaris 10?
20:43:12 <Pseudonym> Yes, I'm using Solaris 10.
20:43:19 <segphault> what do you think of it?
20:43:20 <Pseudonym> On Sparc.
20:43:25 <Pseudonym> dtrace rocks
20:43:28 <Pseudonym> It really, REALLY rocks.
20:43:34 <segphault> hehehe well, I figured that much
20:43:38 <Pseudonym> I don't have ZFS, sadly.
20:43:44 <segphault> I was just going to ask.
20:44:06 <segphault> they actually managed to make this version *sound* appealing, and I was very curious about how it performed
20:44:09 <Pseudonym> Anyway, the interesting piece of behaviour is that at least on a UFS filesystem, if you try to create a file on a full disk, you get ENOSPC... except for one situation.
20:44:15 <segphault> I heard they made some serious mods to the tcp stack
20:44:41 <Pseudonym> That one situation is if the system needs to extend the directory entry where the file is being created.
20:44:57 <Pseudonym> In that situation you get a different error.
20:45:01 <Pseudonym> So that's interesting.
20:45:06 <Pseudonym> It's probably not technically a bug.
20:45:23 <segphault> I didnt know that many people still used ufs
20:45:35 <segphault> is it common in the solaris world?
20:45:35 <Pseudonym> We don't have a Veritas licence.
20:45:45 <Pseudonym> It depends what you're doing.
20:45:58 <Pseudonym> UFS is the "workhorse" filesystem, but you tend to use Veritas if you can.
20:46:05 <Pseudonym> Though ZFS should replace that.
20:46:13 <segphault> zfs sounded really cool
20:46:37 <Pseudonym> The reason I found this out, by the way, is I have to do some R&D into the effect of fragmentation.
20:46:44 <Pseudonym> So I had to make a database as fragmented as I could.
20:46:49 <segphault> hahahahaha
20:46:53 <segphault> interesting project
20:46:58 <Pseudonym> Yes, it is interesting.
20:47:05 <Pseudonym> Only how do you deliberately fragment a file?
20:47:36 <segphault> one can only wonder. maybe if you download large movie files it will do the trick. ;-D
20:47:43 <segphault> worth a try at least.
20:47:46 * segphault chuckles
20:48:28 <Pseudonym> After some false starts, it turns out that the best way is to load your data onto a different disk, then fill the target disk with lots of files, then when the data is loaded, copy the files over one at a time with a custom program which frees space as it goes.
20:48:37 <Pseudonym> And that's when I discovered this problem.
20:49:07 <segphault> interesting
20:50:14 <segphault> so are you trying to quantify some kind of correlation between database retrieval latency and disk fragmentation?
20:50:39 <Pseudonym> I also discovered that the fcntl() call, F_FREESP, doesn't work.
20:50:41 <Pseudonym> Right.
20:50:49 <Pseudonym> Not just retrieval.
20:50:55 <Pseudonym> We write a database server.
20:51:06 <segphault> ah
20:51:10 <Pseudonym> It's a text database system, so it doesn't quite work the same way as a SQL relational system.
20:51:22 <Pseudonym> Search, sort and retrieving records are all different operations.
20:51:35 <Pseudonym> Plus some more like ranking and index scanning.
20:51:52 <segphault> is it a commercial product, or something that you use internall?
20:51:55 <segphault> *internally?
20:52:00 <Pseudonym> It's commercial.
20:52:04 <Pseudonym> http://www.teratext.com.au/
20:52:30 <Pseudonym> And you probably can't afford it.
20:52:43 <segphault> I wouldnt want or need it
20:53:05 <segphault> I dont think i've ever seen a database system that was designed specifically for text tho
20:53:31 <Pseudonym> You've probably used them before, though, and I don't just mean Google.
20:53:37 <Pseudonym> Library catalogues work this way.
20:54:01 <segphault> ah. that makes sense
20:54:26 <Pseudonym> We do a lot of legislation work.
20:54:52 <Pseudonym> Legislation is interesting because you have a constantly changing body of text (i.e. the law), and you often want to search at a specific point in time.
20:55:05 <Pseudonym> Because the law is the law as it was at the time the deed was performed.
20:55:10 <heatsink> so you've got some sort of RCS?
20:55:19 <Pseudonym> Not quite.
20:55:25 <Pseudonym> It's structural.
20:55:28 <Pseudonym> SGML-based.
20:55:38 <segphault> I was just noticing that. Thats really neat
20:55:52 <Pseudonym> We also work with other kinds of difficult text problems.
20:56:19 <Pseudonym> Sometimes you have a whole bunch of documents each of which is slightly different.
20:56:25 <Pseudonym> Or have parts in common.
20:56:34 <Pseudonym> Like a set of manuals for a family of products.
20:57:11 <Pseudonym> Say you make refrigerators.  Then some of your different models will have things in common.
20:57:25 <Pseudonym> And if it changes in one manual, it should change in all the others too.
20:57:37 <heatsink> In bioinformatics they have algorithms for that
20:57:49 <heatsink> To compare gene sequences.
20:57:59 <Pseudonym> Yeah, but that's not quite the same thing.
20:58:12 <Pseudonym> Bioinformatics is about discovering information.
20:58:52 <Pseudonym> Whereas the refrigerator manuals example is more about creating structure to begin with, and propagating changes appropriately.
20:59:26 <heatsink> ok
20:59:41 <Pseudonym> There are similar text problems, like data mining.
21:01:10 <Pseudonym> The refrigerator is actually a trivial example.
21:01:22 <Pseudonym> We actually worked on a similar project, only it was a fleet of warships.
21:01:46 <Pseudonym> The ships were being built over an eight year period, so some parts became unavailable and others became available.
21:02:10 <Pseudonym> So the maintenance manuals for these ships were all slightly different in various subtle ways.
21:02:39 <heatsink> The manuals were in a linear format, and you structured them?
21:03:00 <Pseudonym> Well, the manuals were broken down in some kind of structure.
21:03:17 <Pseudonym> We just wrote the software.  Our customers handled the actual manuals.
21:05:16 <Pseudonym> And I've just spent a year working out how to sort things.
21:05:30 <heatsink> How do you come up with test inputs for the software?
21:05:30 <Pseudonym> You wouldn't think that sorting was a hard problem, but it is.
21:05:56 <Pseudonym> Oh, sample stuff from the customer.  Educated guesswork based on requirements.
21:05:59 <Pseudonym> Stuff like that.
21:06:04 <heatsink> That works
21:06:13 <segphault> sounds a bit tedious
21:06:23 <Pseudonym> What sounds tedious?
21:06:33 <segphault> a year writing sorting algorithms.
21:06:42 <Pseudonym> Most of it wasn't sorting algorithms.
21:06:50 <Pseudonym> The problem wasn't the algorithm.
21:07:12 <Pseudonym> The problem was we were working in an environment where actually getting at a sort key is very expensive.
21:07:46 <Pseudonym> Think for a moment about how a typical SQL database system works versus how Google works.
21:07:48 <heatsink> Computationally expensive, you mean?
21:07:53 <heatsink> ok
21:08:11 <Pseudonym> With SQL, the main internal data structure is a stream of tuples.
21:08:27 <Pseudonym> Where a tuple contains data.
21:08:37 <Pseudonym> Every SQL operation can be thought of as operating on these tuples.
21:08:42 <Pseudonym> Conceptually.
21:09:08 <Pseudonym> So a database table, for example, is basically an array of tuples.
21:09:15 <Pseudonym> A query extracts tuples.
21:09:22 <Pseudonym> When you do a join, you join two streams of tuples.
21:09:26 <Pseudonym> Tuples all the way down.
21:09:35 <heatsink> :)
21:09:36 <Pseudonym> And when you sort, you sort a stream of tuples.
21:09:42 <Pseudonym> So far, so good.
21:10:09 <Pseudonym> Oh, and when you actually get data back from the database, you get tuples.
21:10:17 <Pseudonym> Now think about Google.
21:10:32 <Pseudonym> When you query Google, what you get back isn't tuples exactly.
21:10:35 <Pseudonym> It's a set of records.
21:10:59 <Pseudonym> Everything is geared to manipulating a sequence of record numbers or record identifiers.
21:11:22 <Pseudonym> So when you query, you get record identifiers.  You rank, you sort... you're manipulating record identifiers.
21:11:49 <Pseudonym> The reason for this is that the things that you manipulate and the things you eventually want to extract are different.
21:12:01 <Pseudonym> You almost never want to find "all documents where the body text is precisely this".
21:12:29 <Pseudonym> Generally, you search by word, you sort by date or title or something, and then you present the body text back to the client.
21:12:40 <Pseudonym> And you might only want to present some subset of that data.
21:12:53 <Pseudonym> Say, you want to view a set of summaries, and then only extract the full data for one or two.
21:13:07 <Pseudonym> If you stored your data as tuples, you'd waste resources extracting information that you didn't need.
21:13:09 <Pseudonym> With me?
21:13:46 * heatsink looks at segphault
21:14:06 <segphault> yeah
21:14:11 <Pseudonym> OK.
21:14:20 <Pseudonym> So when you sort, you are given a set of record numbers/identifiers.
21:14:46 <Pseudonym> To get a sort key (say, title), you have to access the record on disk, decode it and extract the title field.
21:15:00 <Pseudonym> Which is computationally expensive.
21:15:36 <Pseudonym> Moreover, in a large database, a query might have millions of results, not all of which are relevant.
21:15:42 <Pseudonym> (e.g. the stuff down on page 20 of Google)
21:15:51 <Pseudonym> But you still have to sort it.
21:15:59 <Pseudonym> And somehow get sort keys for all of them.
21:16:19 <Pseudonym> And then you have the problem of remote databases on a server farm.
21:16:37 <Pseudonym> It's tricky stuff.
21:16:54 <Pseudonym> In the end, the solution we came up with was to introduce new on-disk data structures.
21:16:58 <Pseudonym> We called them "sortdexes".
21:17:12 <Pseudonym> Analogous to indexes.  An index means you don't have to grep every record to perform a query.
21:17:20 <Pseudonym> A sortdex means you don't have to read every record to sort.
21:17:44 <Pseudonym> Anyway, it was kinda interesting.
21:18:26 <heatsink> Interesting solution
21:18:30 <segphault> that does sound interesting. a lot more to it than I initially suspected
21:18:43 <Pseudonym> Oh, we also implemented what we call "first-N" sorting.
21:18:58 <Pseudonym> Where rather than sort the whole result set, you only sort, say, the top 1000.
21:19:09 <Pseudonym> Which is potentially a lot less expensive.
21:19:47 <Pseudonym> If you use a radix-like sort, you can just fetch enough information to do the first bucketing pass.
21:19:51 <heatsink> Textbook says can be O(n) instead of O(n log n) 
21:19:54 <Pseudonym> And then you throw away the buckets you don't need.
21:20:11 <Pseudonym> First-N sorting is O(n log k) where k is the number of records you want.
21:20:20 <heatsink> ah
21:20:21 <Pseudonym> If you use comparison-based sorting.
21:20:28 <heatsink> right.
21:20:39 <Pseudonym> If you use radix sort, it's O(n log k) where k is the "size" of the key.
21:20:54 <Pseudonym> Whhich is a constant for, say, integers.
21:20:56 <Pseudonym> But not for strings.
21:22:29 <SyntaxNinja> does anyone use two-way sync w/ cvs for darcs?
21:22:34 * heatsink looks... yes, the website has a search feature :)
21:26:22 <Janni> G'morning
21:26:45 <segphault> good morning
21:57:51 <dash> hello, haskellians
22:13:37 <dash> help a poor CL refugee. does haskell have an equivalent to maplist?
22:16:45 <dons> hmm. map ?
22:16:57 <dash> haskell's map is CL's mapcar
22:17:07 <dash> which maps over the head of the list
22:17:19 <dons> what is the type of maplist? it is hard to tell from the name..
22:17:21 <dash> maplist in CL calls a function on successive tails
22:17:38 <heatsink> @type map
22:17:39 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
22:18:12 <heatsink> (a -> b) is the function to apply to each element of [a]
22:18:17 <dons> "successive tails"?
22:18:32 <dash> sucessive sublists, i mean 
22:18:51 <dons> oh, map over a list of lists?
22:18:55 <dash> no
22:19:22 <dons> map over a list of lists constructed from each sublist of a list
22:19:38 <dash> "maplist f [1,2,3]" would return "[f [1,2,3],f [2,3],f [3], f []]"
22:20:09 <dons> @type Data.List.tails
22:20:10 <lambdabot> Data.List.tails :: forall a. [a] -> [[a]]
22:20:12 <Etaoin> tails in Data.List maybe?
22:20:47 <dash> huh. OK! was looking in there but didn't see it :)
22:24:42 <dons> you got the hiearchical library docs?
22:25:11 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
22:31:28 <dash> yep
22:31:32 <dash> good readin'
22:58:28 <musasabi> morning
23:22:04 <vegai> g'morning
23:22:23 <vegai> I was wondering, is the problem described here solved? http://www.haskell.org/pipermail/glasgow-haskell-bugs/2004-March/003955.html
23:33:28 <SyntaxNinja> vegai: there's been some work on a tool, cpphs, but I don't know if it's being integrated into ghc yet
23:34:08 <dons> not integrated yet
23:34:27 <dons> but cpphs is pretty solid now
23:37:05 <SyntaxNinja> more and more, I hate the idea of CPP in Haskell code... yeah, I know that it's necessary for the time being, but I think it's a clear case of good-enough being a drawback in the long-run.
23:37:32 <dons> yep. cpp is hell
23:37:41 <SyntaxNinja> I mean, Haskell is so nice to read until you suddenly run into some C ifdefs in the middle of your functions
23:39:13 <SyntaxNinja> I think that I'm going to reimplement cpp in Cabal where instead of adding the -cpp flag, it administers an electric shock to the author.
23:39:33 <dons> hehe. i like that
23:42:54 <heatsink> infixl 3 /*, */
23:43:13 <heatsink> Hmm, I didn't know my code went through cpp
23:45:12 <dons> it doesn't unless you turn on -cpp
23:45:58 <heatsink> ok
23:47:04 <SyntaxNinja> heatsink: so the problem is that you're happily using your /* operator when suddenly you need cpp, or you need some code that uses cpp, and so you employ the -cpp flag, and your code breaks.
23:47:38 <dons> yep. it sucks having a haskell-unaware preprocessor
23:47:43 <SyntaxNinja> so this causes folks to not use stuff that might get eaten by cpp
23:49:54 <Spark> doesnt haskell have its own macro thingy
23:50:12 <heatsink> it does have preprocessor directives
23:50:22 <dons> we have TH, but it doesn't get used for general textual preprocessing 
23:50:24 <Spark> #ifdef and such?
23:50:30 <dons> that's cpp ;)
23:50:31 <heatsink> I think they have the format {-#something#-}
23:50:39 <Spark> yeah but something that implements the same funcitonality
23:50:41 <heatsink> I guess that's not preprocessor
23:50:42 <dons> and they're compiler pragmas
23:50:50 <heatsink> yeah, that's the right name for 'em
23:52:08 <heatsink> Spark: an optimizing compiler _should_ be able to produce the same results as #ifdef #else #endif without any special directives
23:52:31 <heatsink> x = False
23:52:43 <heatsink> y = if x then {...} else {...}
23:53:01 <dons> cpp mainly gets used for testing ghc verions, when dealing with imports
23:53:12 <dons> and also for dealing with foreign imports
23:53:48 <dons> #if __GLASGOW_HASKELL__ > 620 ... then import some new library ..
23:54:14 <SyntaxNinja> or compatibility between ghc, nhc, & hugs
23:54:47 <dons> yep. you see a lot of that in the hier libs
23:55:13 <SyntaxNinja> heatsink: but you can't use if statements in imports or in function definitions
23:55:24 <dons> but i hope people aren't using it for C-like macro substitution :( scary
23:56:06 <heatsink> good point
