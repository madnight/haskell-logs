00:05:59 <musasabi> morning
00:10:36 <dblhelix> morning, musasabi, how's life?
00:13:35 <musasabi> slept 3 hours, loud guests in the house, and so on..
00:13:40 <musasabi> my dream morning
00:13:42 <musasabi> &c
00:14:02 <dblhelix> sound like fun :)
01:03:01 * dblhelix is away: for groceries
01:15:16 * musasabi waits for a cabal update anxiously
01:51:28 * dblhelix is back (gone 00:48:28)
02:11:25 <musasabi> Deleted dependency to libstdc++ from hs-fltk.
02:11:48 <musasabi> Now evil linker hacks don't kill me ^_^
02:21:21 * musasabi is thinking of posting an announcement to haskell (or would libraries be better) when Isaac gets his computer working again and updates the cabal repository
02:30:45 <boegel> hello everyone
02:31:05 <musasabi> hello boegel 
02:33:49 <dblhelix> hello boegel
02:36:39 <boegel> I've put a reflection depth test on my website, for those who want to see it...
02:37:38 <dblhelix> boegel: url?
02:37:57 * musasabi is on a text console.. so no pretty pictures..
02:38:12 <musasabi> Is it possible to get cabal working with hugs?
02:40:02 <boegel> http://studwww.ugent.be/~kehoste -> click the link there
02:40:21 <boegel> I really should put some more stuff on my website... (more links I mean)
02:43:32 <kristnjov> you should really consider hiring someone to design that for you
02:53:06 <bourbaki> moin
02:58:49 <TheHunter> moin
03:00:33 <bourbaki> moin
03:00:51 <kristnjov> naomi
03:15:37 <boegel> hey bourbaki, check my website for an update of reflection (I don't think you've seen it have you ?)
03:16:43 <bourbaki> nope url plz
04:04:53 <boegel> damn, he out again, and I didn't give him the url :s
04:15:03 <boegel> if he shows up again, would someone give this url to him (bourbaki): http://studwww.ugent.be/~kehoste
04:16:18 <ayrnieu> boegel - you could always use that freenode-wide 'memoserv' thing.
04:16:23 <ayrnieu> even though nobody uses it.
04:16:32 <boegel> ayrnieu, how does that work ?
04:17:06 <ayrnieu> I don't know, boegel, I've never used it.  /msg memoserv help
04:17:49 <boegel> ah, there he is :)
04:17:58 <boegel> bourbaki: http://studwww.ugent.be/~kehoste
04:22:00 <boegel> I have to go now, I have a train to catch
04:22:01 <boegel> bye !
04:30:31 <KiMoS> i want to get the lenth of the int's in a string but forexample "aaaa11aa22" gives  length 2 becouse  11 is one number and 22 is another number so total is 2 
04:30:43 <KiMoS> using isDigit will return 4 in that case
04:31:42 <KiMoS> thats what i have but its wronge
04:31:42 <KiMoS> numberofInt :: String -> Int
04:31:43 <KiMoS> numberofInt n = length (filter isDigit n)
04:32:45 <musasabi> numberIfInt = nof 0 False
04:32:59 <musasabi> nof n _ [] = n
04:34:01 <musasabi> nof n False (c:cs) | isDigit c = nof (n+1) True cs
04:34:36 <kristnjov> another way would be to count the amount of True's in (map (\a -> isDigit a) n)
04:34:37 <musasabi>                     | True = nof n False cs
04:35:30 <musasabi> nof n True  (c:cs) = nof n (isDigit c) cs
04:36:03 <musasabi> .
04:36:14 <kristnjov> length (filter (\a -> a == True) (map (\a -> isDigit a) "aa11aa22")) == 4
04:36:50 <kristnjov> don't you just love higher order functions?
04:37:09 * musasabi loves readablity
04:37:16 * kristnjov doesn't
04:40:41 <KiMoS> kristnjov what you did is exactly like what i have  the answer is still 4
04:40:54 <KiMoS> and it have to be 2  becouse 11 and 22 are 2 numbers
04:41:19 <kristnjov> oh heh, didn't quite understand the question then
04:41:53 <kristnjov> use nub
04:42:13 <kristnjov> nub "aa22" == "a2"
04:42:25 <kristnjov> i.e. it removes all duplicate elements
04:42:33 <TheHunter> numberofInt n = length . filter id . map head . group . map isDigit $ n
04:42:47 <kristnjov> so the solution would be: length (filter isDigit (nub n))
04:43:08 <KiMoS> i cant use nub  becouse what if the input is  aaa12aa32
04:43:12 <musasabi> kristnjov: not if he wants "a1234bbb5678c" = 2
04:43:17 <KiMoS> 12 arent dublicate
04:43:21 <KiMoS> yes
04:43:27 <musasabi> KiMoS: see my solution.
04:43:50 <kristnjov> uhh, alright...
04:43:55 <kristnjov> you want a very odd thing.
04:46:04 <kig> with a scan function that collects all matches to regexp from the str it'd be length . scan [0-9]+ str
04:46:06 <KiMoS> what is nuf  musasabi  i cant find it 
04:46:40 <KiMoS> i got it working now thx guys
04:46:42 <musasabi> kig: moi ;)
04:46:58 <musasabi> 14:29 < musasabi> numberIfInt = nof 0 False
04:46:58 <musasabi> 14:29 < musasabi> nof n _ [] = n
04:46:58 <musasabi> 14:31 < musasabi> nof n False (c:cs) | isDigit c = nof (n+1) True cs
04:47:13 <musasabi> 14:31 < musasabi>                     | True = nof n False cs
04:47:13 <musasabi> 14:32 < musasabi> nof n True  (c:cs) = nof n (isDigit c) cs
04:47:28 <KiMoS> @type nuf
04:47:31 <lambdabot> bzzt
04:47:35 <KiMoS> @type nof
04:47:37 <lambdabot> bzzt
04:47:42 <kristnjov> KiMoS, he made nof himself¨
04:47:47 <KiMoS> ohh
04:47:53 <musasabi> KiMoS: if you look carefully you will see nof defined there ;)
04:48:59 <kig> moi musasabi 
04:50:23 <xerox> musasabi nof definition can be "embedded" in a where block, am i right?
04:50:42 <musasabi> xerox: yes, because typing the indentation in irc would be painfull
04:50:56 <xerox> agreeable :)
04:50:59 <musasabi> if I would be in emacs it would live in a where block probably ;)
04:52:26 <xerox> is there a filterM ?
04:52:44 <xerox> mmh, probably my question has no meaning..
04:52:48 <xerox> nm.
04:52:52 <musasabi> @type filterM
04:52:54 <lambdabot> bzzt
04:52:59 <TheHunter> @type Control.Monad.filterM
04:53:01 <lambdabot> Control.Monad.filterM :: forall a m.
04:53:01 <lambdabot> 			 (Monad m) =>
04:53:01 <lambdabot> 			 (a -> m Bool) -> [a] -> m [a]
04:53:06 <kristnjov> i don't get monad
04:53:07 <kristnjov> s
04:53:08 <xerox> ah!
04:53:31 <musasabi> filterM :: forall a m. (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:53:52 <xerox> so if the elements not filtered are actions filterM will "call" them ?
04:53:52 <musasabi> why does lambdabot not look there by default?
04:54:20 <musasabi> xerox: filterM is for the case where the filter predicate is monadic.
04:54:33 <xerox> musasabi can you give me an example?
04:54:54 <musasabi> foo :: Bar -> IO Bool
04:55:17 <musasabi> filterM foo [mybar1, ... , mybarN]
04:55:44 <TheHunter> subLists = filterM (const [False,True])
04:56:35 <KiMoS> what does the  .  do
04:56:54 <TheHunter> composition: (f . g) x === f (g x)
04:57:16 <KiMoS> oh
04:57:35 <TheHunter> like in the example we had yesterday.
04:57:41 <KiMoS> yes i remember
04:58:41 <xerox> :D
04:58:52 <TheHunter> wahee, that subLists definition is even shorter than foldM (\xs x -> [xs, x:xs]) []
04:59:02 * goron is actually installing Perl modules...
04:59:03 <xerox> TheHunter finally what was the $ ? something like (f . g) x === f (g x) === f . g $ x
04:59:20 <TheHunter> xerox, right
04:59:36 <xerox> uh. that's *nice*
04:59:49 <TheHunter> the other use pattern is f $ longExpression
05:00:38 <TheHunter> filter (>3) $ [1,2] ++ map (+2) [1,2]
05:00:41 <xerox> putStrLn . show . (+) $ 1 1 <- why doesn't work ?
05:01:34 <KiMoS> TheHunter the code u just wrote about numberofInt  it filter the int's and it group them  ?
05:01:40 <musasabi> putStrLn $ show $ 1 + 1
05:02:23 <TheHunter> numberofInt = length . filter id . map head . group . map isDigit
05:02:36 <KiMoS> $ n
05:02:40 <musasabi> or even: putStrLn . show $ (+) 1 1
05:02:54 <TheHunter> KiMoS, we have a string "12fe3"
05:02:58 <xerox> musasabi ah!!
05:03:37 <TheHunter> isDigit decides wheather the elements are digits, so map isDigit "12fe3" is [True,True,False,False,True].
05:03:50 <KiMoS> yes
05:04:10 <TheHunter> the next thing that line does is group equal elements together, we get [[True,True],[False,False],[True]]
05:04:38 <TheHunter> where True-Blocks mean that the original string contained digits and False-Blocks are non-Digit-blocks.
05:04:49 <TheHunter> so we need to count the True-blocks.
05:05:37 <TheHunter> map head gets the first element of each block, filter id filters all trues, and finally length computes the number of True-blocks, that is the number of ints.
05:05:50 <musasabi> that is a nice solution.
05:05:59 <KiMoS> indeed i liked it
05:06:17 * TheHunter is away: brb
05:06:32 <xerox> KiMoS what's the purpose of the function ?
05:06:55 <KiMoS> return how many int's you have in a string  
05:07:17 <KiMoS> but  aa11aa  is 1  becouse 11 count as one number and not 2
05:07:50 <kristnjov> but what you want is NOT to return the amount of integers in a string.
05:07:56 <kristnjov> you want to return the amount of blocks of integers in a string
05:08:00 <xerox> ah!
05:08:16 <KiMoS> yes your right
05:08:40 <KiMoS> but now i want to return the max amout of the blocks of integer  
05:09:00 <xerox> @index group
05:09:00 <lambdabot> Data.List,List
05:09:29 <xerox> group is magical.
05:09:54 <kristnjov> perhaps he needs groupBy?
05:10:08 <xerox> is there any reference?
05:10:16 <kristnjov> to what?
05:10:27 <xerox> to find useful function like group
05:10:37 <xerox> by themself, instead of begging in the channel, hehe
05:10:48 <kristnjov> i'm not sure what you're asking
05:10:58 <xerox> mmh
05:11:01 <KiMoS> i think if i manage to change a bit of TheHunter code   i can get the max length
05:11:16 <xerox> a "list" of the functions in Prelude .. or something like that
05:11:23 <xerox> (with descriptions!)
05:11:27 <Lemmih> xerox: http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:11:54 <xerox> GHC docs, perfect!
05:12:11 <Lemmih> And http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
05:13:07 <xerox> nice.
05:13:09 <KiMoS> i followed yet another tutorial
05:13:25 <xerox> KiMoS i'm reading it too!
05:13:48 <KiMoS> but it doesnt learn recursion function alot  
05:13:56 <KiMoS> it just show how
05:14:03 <KiMoS> a few examples
05:14:25 * TheHunter is back (gone 00:08:07)
05:32:00 <KiMoS> TheHunter im trying to make 2 function the one return the maximum block of int and the other return the highist number (block of int) in a string  i want to use your code but now im stuck at the filtering
05:32:54 <KiMoS> if you have [True,True,True][False,False,False]etc..  u can filter the True and get the maximum lenth of thos lists
05:33:11 <KiMoS> length*
05:33:37 <KiMoS> group . map isDigit $ n  it group the True False 
05:41:01 <Lemmih> Good morning, #haskell.
05:42:21 <KiMoS> Good morning Lemmih
05:49:57 <xerox> KiMoS
05:50:01 <xerox> what about: foldl max 0 $ map length $ map (dropWhile (==False)) $ List.group $ map Char.isDigit "aa11aa"
05:50:11 <xerox> + or - :)
05:53:44 <KiMoS> xerox its nice but i need to understand it can u please explain how it work
05:54:16 <xerox> KiMoS, i try
05:54:31 <xerox> *Main> List.group $ map Char.isDigit "aa11aa"
05:54:32 <xerox> [[False,False],[True,True],[False,False]]
05:54:35 <xerox> you know that
05:54:41 <KiMoS> yes
05:55:45 <KiMoS> it drop the False and map the True and get the max lengh
05:55:51 <xerox> *Main> map (dropWhile (==False)) . List.group . map Char.isDigit $ "aa11aa"
05:55:51 <xerox> [[],[True,True],[]]
05:55:57 <xerox> it drops the False
05:56:13 <xerox> then maps length to get [0,2,0]
05:56:33 <xerox> and then max works on 2 arguments
05:56:34 <KiMoS> its clear now thx xerox
05:56:36 <xerox> so i used fold
05:56:46 <xerox> you can't map max 
05:56:51 <xerox> okie :) np, it's fun
06:06:30 <scode> I'm reading http://www.haskell.org/tutorial/goodies.html and there is one thing I don't get. There is an example "data Point a = Pt a a". Afterwards it is stated that the type of Pt is a -> a -> Point a, But I thought Pt was a pre-existing data constructor. So how does that fit? For starters if Point is not pre-existing I don't see how Pt's type can involve Points. Plus, the way I understand it the types Point and Pt would be mutually recursive in that case...
06:07:19 <scode> And for that matter - I assume "a -> a -> Point a" is equivalent to "a -> (a -> Point a)"?
06:07:46 <xerox> it is exact
06:08:43 <scode> Hmm. What is exact, and what does exact mean in this context?
06:09:09 <Muad_Dibber> a -> a -> Point a is equivalent to a -> (a -> Point a) i think
06:09:18 <Muad_Dibber> so that part you assumed right i assume ;)
06:09:29 <kristnjov> HIGHER-ORDER FUNCTIONS IS THE WAY
06:09:45 <scode> Muad_Dibber: Ok ;)
06:10:04 <Muad_Dibber> but, i dont see your point?
06:10:37 <scode> Muad_Dibber: Well. If Pt is defined in terms of Point and Point is defined in terms of Pt - would not that translate into an infinitely recursive type definition?
06:10:54 <TheHunter> xerox, KiMoS foldr1 max === maximum
06:11:20 <Muad_Dibber> scode, they are not the same, sinc Pt is not defined in terms of Point, but as something of type Point
06:11:33 <Muad_Dibber> whereas Point is defined as having a constructor named Point
06:11:44 <xerox> TheHunter foldr0 maybe ?
06:11:50 <KiMoS> TheHunter we can use maximum ?
06:12:10 <Muad_Dibber> scode, like this line states: Type constructors such as Point and data constructors such as Pt are in separate namespaces. This allows the same name to be used for both a type constructor and data constructor, as in the following
06:12:22 <TheHunter> xerox, foldr0 doesn't exist
06:12:24 <Muad_Dibber> if it would be done how you suggest it, it would be impossible either way, right?
06:12:43 <Muad_Dibber> because then saying Point a = Point a a would be completly nonsense :P
06:12:47 <xerox> TheHunter but the longest block of digits in "aaabbb" is 0 not 1
06:12:51 <Muad_Dibber> or somebody thinks i'm talking crab here?
06:13:11 <scode> Muad_Dibber: Yeah it would be impossible, hence my confusion :) But okay; so Pt is a data constructor and Point the type constructor. Got it. But then I still don't see how Pt's type is a -> a -> Point a
06:13:24 <TheHunter> xerox, ok, you're right, maximum fails for empty lists.
06:13:56 <TheHunter> i didn't think abut that, sorry
06:14:05 <KiMoS> maybe i can use maximum to get the highist number of the string?
06:14:17 <Muad_Dibber> well
06:14:21 <scode> Muad_Dibber: That is, if Pt is a data constructor that given two "pieces of data" (instances, objects - dunno what they are called in haskell?), returns a function of type a -> Point a, then ... argh. ;)
06:14:22 <Muad_Dibber> it's about types, right?
06:14:58 <Muad_Dibber> it says this: Pt a a, so Pt would need two arguments to be a normal constructor
06:14:59 <Muad_Dibber> right?
06:15:09 <Muad_Dibber> well, to be a correct value of type Point
06:15:35 <Muad_Dibber> agree?
06:15:43 <scode> It needs two arguments, I'm with you so far. But I just don't see how Point is involved.
06:16:10 <Muad_Dibber> okay, so you agree that Pt's type is at least a -> a -> something?
06:16:22 <KiMoS> what is wronge in this one 
06:16:24 <KiMoS> interSects :: String -> String
06:16:24 <KiMoS> interSects  n m = intersect (nub n) (nub m)
06:16:29 <scode> Muad_Dibber: Not really. I take that to mean it maps from data to functions.
06:16:38 <scode> Muad_Dibber: But that does not make sense if data Point = Pt a a
06:16:43 <KiMoS> the intersectiong of 2 given strings
06:16:50 <scode> Muad_Dibber: Given that Points are not functions.
06:16:55 <Muad_Dibber> well no
06:17:09 <Muad_Dibber> but i suppose you programmed in like c or c++ or java,
06:17:13 <Muad_Dibber> you have constructors there
06:17:19 <Muad_Dibber> those constructors are functions too
06:17:26 <Muad_Dibber> so you can see this as an implicit constructor
06:17:31 <scode> Muad_Dibber: lisp, ruby, smalltalk, java, etc.
06:17:43 <Muad_Dibber> a constructor for a data Point a
06:18:06 <scode> Muad_Dibber: That makes perfect sense as long as no one claims the type of the constructor is a -> a -> Point a ;)
06:19:09 <scode> I mean, given that the type of Pt is a -> a -> b, this means that Pt, given an object of type a, evaluates to a function of type a -> b
06:19:27 <xerox> scode the thing is that function with more than 1 argument doesn't really exist in haskell
06:19:39 <scode> But then "data Point = Pt a a" no longer makes sense to me, since Points are not functions.
06:19:44 <scode> xerox: Hmm.
06:19:57 <scode> xerox: Okay. So what does the "Pt a a" notation mean?
06:19:59 <Muad_Dibber> scode, you have hugs?
06:20:06 <scode> Muad_Dibber: hugs?
06:20:15 <Muad_Dibber> ghc? :P
06:20:16 <xerox> btw, if you are (like me) an haskell newbie, i suggest you to close "Gentle introduction .." that is not so *gentle* and pick something like "Yet another Haskell tutorial"
06:20:33 <scode> Muad_Dibber: Oh. Well, almost. ;) Failed to compile. At the moment I'm mostly just reading up on it.
06:20:34 <Muad_Dibber> heh
06:20:35 <xerox> in that book polymorphic types are on pg 52,  instead of "gentle"'s 2 :D
06:20:40 <Muad_Dibber> i'm not a newby, but a noob ;)
06:20:46 <Muad_Dibber> scode, hugs is an interpreter
06:20:48 <Muad_Dibber> i'd suggest it
06:20:57 <Muad_Dibber> not to use for real
06:21:05 <scode> xerox: Hehe. Well, I have no problems with the rest of the 'tutorial'; i just dont get that specific part of it.
06:21:06 <Muad_Dibber> but i think its great for educational purposes
06:21:07 <Philippa> ghci's just as good as an interpreter IMO though
06:21:18 <Muad_Dibber> Philippa, well, might be, i'm not used to it
06:21:26 <Muad_Dibber> and it wont work on an amd64 system yet i think?
06:21:31 <Philippa> most of the time it behaves like hugs
06:21:35 <Muad_Dibber> and besides, i'm not going to discuss it
06:21:41 <Muad_Dibber> does it handle :t Philippa?
06:21:43 <Philippa> if you can run plain x86 code still, it'll work
06:21:45 <Philippa> yes
06:21:48 <xerox> http://www.isi.edu/~hdaume/htut/
06:21:50 <musasabi> "data Point a = Pt a a " defines three things. A type construcor Point, a function (=constructor) Pt :: a -> a -> Point a, and an "unconstructor" for pattern matching.
06:21:52 <xerox> if you change idea :D
06:22:06 <Muad_Dibber> hehe
06:22:26 <scode> Maddas: Wait. So Pt is not pre-existing?
06:22:29 <scode> Err.
06:22:34 <scode> musasabi: ^^
06:22:40 <Philippa> trust me, when I advocate ghci over hugs it's because I've used both and ended up with ghci for serious dev work :-)
06:22:52 <musasabi> scode: no. it is simply a name.
06:23:00 * musasabi likes ghci better
06:23:10 <xerox> it can be MakePoint
06:23:14 <scode> musasabi: So "data Point x = Blaha a a" would be equally valid in a vanilla haskell environment?
06:23:24 <Philippa> not quite
06:23:24 <musasabi> scode: yes.
06:23:29 <musasabi> no.
06:23:39 <Philippa> "data Point a = Blaha a a" would be
06:23:40 <musasabi> scode: data Point x = Blaha x x
06:23:52 <scode> Err, sorry. I mean a not x.
06:23:56 <Philippa> otherwise it doesn't know where this type variable a came from :-)
06:23:59 <TheHunter> abcde
06:24:11 <TheHunter> oops, sorry
06:24:34 <scode> But all other type definitions have followed the pattern "data X = <valid values of X, directly or indirectly through other types>"
06:24:43 <kig> is there a less verbose way to write this: http://fhtr.org/code/scan.hs
06:25:00 <scode> But if there is no such thing as "Pt" (because its just a random name), how can "data Point a = Pt a a" be a valid type definition, if the HAskell compiler has never seen Pt before?
06:25:11 <Philippa> because that also defines Pt
06:25:30 <musasabi> kig: yes.
06:25:40 <Philippa> "a Point a is a Pt, which takes an a and an a"
06:26:39 <jemfinch|lambda> scode: "Point" is the name of the type.  "Pt" is a constructor for that type.
06:28:30 <xerox> Point type constructor Pt data constructor ?
06:28:36 <scode> So I can then write (Pt 1 2) for a point? Ok, if that is the syntax I suppose I'm with you. Almost. Does this also mean then that with only the definition "data Point a = Pt a a", a point created is not actually usable because there is nothing that can be done with it?
06:28:38 <xerox> invert it, wops.
06:29:47 <scode> I mean; how does the compiler know that a Point carries the two values as its data.
06:29:59 <scode> If all you've said is that the contructor is named Pt and it takes two arguments.
06:30:07 <scode> (But not what is done with those arguments)
06:30:21 <Philippa> because that's all that can be done with them
06:30:38 <scode> So a constructor can never take a value that is thrown away?
06:30:41 <Philippa> right
06:30:44 <musasabi> kig: youzen.b2.fi/~musasabi/t.hs
06:30:46 <scode> Ah, okay.
06:31:11 <scode> In that case I believe everything makes sense. ;)
06:31:13 <Philippa> in fact, the values a constructor takes, coupled with which constructor it is, uniquely define the resulting value
06:31:17 <Philippa> which is why pattern-matching works
06:32:05 <kig> musasabi: ooh, nice. thanks
06:32:53 <scode> Philippa: Okay.
06:32:59 <scode> Thanks people. Will continue reading other material. ;)
06:33:31 <musasabi> the lack of easy identity is a pity.
06:33:44 <jemfinch|lambda> what's that?
06:34:43 <musasabi> structural identity is not enough in some circumstances (mutually recursive datastructures)
06:34:53 <KiMoS> how do you define a function with as input 2 strings ? 
06:35:13 <musasabi> foo :: String -> String -> Bar
06:35:15 <KiMoS> function n m = blabla ?
06:35:21 <musasabi> foo a b = foobar
06:36:24 <KiMoS> ok thanks
06:37:01 <xerox> foo :: String -> (String -> Bar)
06:37:16 <xerox> mmh nothing.
06:37:18 <xerox> :)
06:38:22 <musasabi> xerox: but then we would have to talk about kind constructors which is not really relevant.
06:38:40 <xerox> dunno really
06:38:59 <xerox> i was asking myself what parens would have meant in that context
06:39:34 <musasabi> xerox: well they are implicitely there.
06:40:05 <xerox> yep, i first tought of it like String -> (String, Bar) then i corrected myself
06:52:13 <KiMoS> disjun  must return the elements that are not in both strings
06:52:16 <KiMoS> disjun :: String -> String -> String
06:52:16 <KiMoS> disjun n m =  map filter (intersect (nub n) (nub m))
06:52:33 <KiMoS> there is something wronge again :)
06:56:07 <TheHunter> how bout disjun n m = nub (n++m) \\ intersect n m ?
06:57:13 <KiMoS> i just thought that but useing concat 
06:57:29 <KiMoS> concat n m  then drop the intersect
06:57:48 <TheHunter> @type concat
06:57:49 <lambdabot> concat :: forall a. [[a]] -> [a]
06:58:05 <TheHunter> you'd have to use concat [n, m], but that's really n ++ m
06:58:24 <KiMoS> yes its the same as ++  
06:58:52 <xerox> @get-definition nub
06:58:53 <lambdabot> nub = nubBy (\x y.x==y)
06:59:27 <xerox> ?
06:59:33 <xerox> oh,ok
06:59:42 <KiMoS> take the doubles out of a list
07:00:15 <KiMoS> TheHunter  do i have to use nub twice there ?   \\ intersect (nub n) (nub m)    ?
07:00:39 <KiMoS> or the first nub is also aplied to the second n m  ?
07:01:03 <xerox> @index nub
07:01:03 <lambdabot> Data.List,List
07:01:24 <TheHunter> no, you don't have to use nub there (it might be faster, though)
07:01:43 <KiMoS> ok
07:02:14 <TheHunter> (actually if speed were a concern, you'd use Data.Set)
07:02:58 <TheHunter> intersect n m is bigger than intersect (nub n) (nub m), so you're removing some elements more than once which gives the same result
07:03:16 <KiMoS> indeed
07:03:19 <redhatPT> hi there
07:03:23 <redhatPT> jadrian :)
07:04:00 * shapr grumbles at SASL
07:32:53 <Maddas> Hm
07:38:11 <Muad_Dibber> Philippa?
07:38:25 <Philippa> yeah?
07:38:41 <Muad_Dibber> i noticed your remark about ghci and i think it very much true :)
07:39:06 <Philippa> you mean you tried it? :-)
07:39:06 <Muad_Dibber> but as i said, i havent used ghci and at uni they use hugs, and they say for educational it might be better or easier or whatever to do hugs :P
07:39:27 <Philippa> it's not particularly tbh
07:39:35 <Muad_Dibber> but it doesnt really matter
07:39:50 <Muad_Dibber> since as i stated, both ghci and hugs dont run on 64 bits yet i htink
07:39:54 <Muad_Dibber> and i still can use ghc :)
07:40:04 <Philippa> perhaps not natively, I'd be surprised if neither runs at all
07:40:28 <Philippa> if you can use GHC, surely you can use GHCi?
07:40:38 <Philippa> it's just the interactive mode of GHC
07:42:13 <Lemmih> shapr: How's code?
07:43:48 <Muad_Dibber> Philippa, there were bugposts, and its been said in here before :)
07:44:00 <Philippa> OK, fair enough
07:44:12 * Philippa shrugs
07:44:19 <Philippa> shame, I figure it'll get fixed sooner or later though
07:46:16 <Muad_Dibber> yup
07:46:20 <Muad_Dibber> but by some smart guys
07:46:24 <Muad_Dibber> which excludes me :)
07:51:10 <redhatPT> what is the diference between Int and Integer ?
07:51:21 <xerox> 4 letters!
07:51:27 <redhatPT> woa thx
07:51:28 <redhatPT> :P
07:52:03 <Philippa> Integer's an arbitrary-size integer, Int is likely whatever the local C compilers think an int is
07:52:32 <xerox> <interactive>:1:
07:52:32 <xerox>     Couldn't match `Int' against `Integer'
07:52:32 <redhatPT> ohh ok, thats different 
07:52:34 <xerox> doh.
07:52:36 <redhatPT> k thx
07:54:30 <KiMoZ> kick KiMoS he was dc and im the orginal one  :)
07:55:57 <xerox> /ns ghost him!
07:55:58 <xerox> :)
07:56:59 <KiMoZ> :)
07:58:24 <KiMoZ> there he goes 
08:07:53 <KiMoS> i want to return the intersectiong of 2 strings   but it must return only the elements that come precisely in the first string as much as the second string
08:08:18 <KiMoS> like:       programmeren software 
08:08:18 <KiMoS> 	=> oa
08:09:35 <tromp> not oare?
08:09:47 <KiMoS> becouse the o and a comes  only one time in software   and didnt return the r becouse it comes more then one time in programmeren
08:09:59 <KiMoS> no not a normal intersecting tromp
08:11:01 <Lemmih> tromp: How's greencard?
08:11:21 <arjanb> KiMoS: how would you splitup this problem?
08:11:48 <KiMoS> hmm
08:11:57 <tromp> i read that a new version of HOpenGL is supposed to not depend on greencard
08:12:01 <tromp> but cant find it
08:12:19 <KiMoS> i dont know arjanb 
08:12:52 <Lemmih> tromp: It's a part of GHC now.
08:13:13 <tromp> fancy that!
08:13:26 <Lemmih> tromp: Get GHC from CVS or wait for GHC 6.4
08:14:15 <tromp> what's ETA of latter?
08:14:24 <arjanb> KiMoS: you could start with a function that counts a char in a string
08:14:40 <tromp> or start with  group . sort
08:14:41 <Lemmih> Some time in december, I think.
08:14:57 <tromp> @eval group . sort $ "software"
08:14:57 <lambdabot> unbound variable: sort
08:15:26 <bourbaki> does anyone happen to know a free function plotter for windoze maybe with haskell?
08:15:41 <musasabi> 6.4 was supposed to be in november, but I think that means december.
08:16:05 <KiMoS> whats the idea of sorting or grouping them ?
08:16:20 <Igloo> HOpenGL is in released GHCs already
08:16:43 <Lemmih> Igloo: Isn't that 1.5?
08:17:09 <Igloo> No idea
08:17:31 <Lemmih> I'm pretty sure it is.
08:18:46 <tromp> intersect (group . sort $ "software") (group . sort $ "programmer") -> ["a","e","o"]
08:22:20 <tromp> i wonder how much work it is to port 500 lines of java to haskell...
08:24:07 <KiMoS> can haskell actualy drow lines ?
08:24:12 <KiMoS> and colors
08:24:43 <musasabi> KiMoS: gui toolkits ;)
08:24:56 <kristnjov> yeah.. wxHaskell or something
08:25:06 <KiMoS> are thos like java toolkits?
08:25:23 <KiMoS> u can show images etc.. ?
08:26:00 <KiMoS> i thought its only functional programming langauge...
08:27:45 <Riastradh> What, do you have some irrational misconception that functional programming languages are only academic toys that can't actually do anything?
08:28:24 <KiMoS> prolog :)
08:28:31 <jemfinch|lambda> prolog is a logic programming language.
08:28:49 <Riastradh> Prolog is hardly a functional language at all.
08:28:53 <KiMoS> yea true 
08:29:36 <KiMoS> @type intersect (group . sort $ "software") (group . sort $ "programmer") 
08:29:37 <lambdabot> bzzt
08:29:57 <KiMoS> what is the type of it tromp ?
08:30:07 <Riastradh> [String]
08:30:28 <KiMoS> indeed :)
08:30:36 <KiMoS> how do you see that ?
08:31:31 <Riastradh> @type intersect
08:31:33 <lambdabot> bzzt
08:31:36 <Riastradh> @type List.intersect
08:31:37 <lambdabot> List.intersect :: forall a. (Eq a) => [a] -> [a] -> [a]
08:39:30 <KiMoS> thx
09:37:33 <stepcut> besides, some prolog implementations also have nice GUI bindings too...
09:50:49 * musasabi ponders whether to hack images for hs-fltk next...
09:51:22 <musasabi> Will ghc 6.4 ship with Cabal?
10:37:40 <jemfinch|lambda> what's Cabal?
10:38:22 <musasabi> jemfinch|lambda: haskell.org/cabal
10:45:15 <ibid> it's a shame we can't say any more "there is no cabal" :)
10:48:52 <jemfinch|lambda> did you formerly?
10:53:32 <ibid> jemfinch|lambda: it's a standing joke in debian-land
10:53:38 <jemfinch|lambda> hehe
10:54:34 <ibid> probably caused by the regular outcries against a claimed "debian cabal"
10:54:53 <Philippa_> variants on it're common elsewhere
10:54:58 <Philippa_> eg the nonexistant-honest lspace cabal
10:55:01 <ibid> sure
10:55:29 <ibid> i believe the phrase may have originated during the ages-old usenet cabal era
10:55:35 <Philippa> most likely
10:56:00 <ibid> lspace?
10:56:02 <Philippa> of course, the lspace cabal has usenet ties like, er, alt.fan.pratchett
10:56:07 <Philippa> www.lspace.org
10:56:24 <ibid> ah, ok
10:57:35 <ibid> (the accusation of a debian cabal probably is true, but not really due to any malice or power-hungriness of the members)
10:57:41 * Philippa nods
10:58:05 * ibid was a try-out member once :)
10:58:11 <ibid> decided it was too much work
10:58:24 <ibid> (i was one of the ftpmasters for a year or so)
11:01:07 * Philippa sniggers at a claim in #afp: <labrat> male afpers are all innocent!
11:01:36 <ibid> afp?
11:01:44 <Philippa> alt.fan.pratchett
11:01:53 <Philippa> (not on this network)
11:01:59 <ibid> ah
11:02:14 <Philippa> suffice to say it's a little hard for a male afper to remain innocent in the presence of the average female afper :-)
11:02:19 <Spark> heh
11:02:24 <Spark> is it like anime
11:02:32 <ibid> never read any, though i'm sure you'll be glad to be added to the list of people who have said "you should" :)
11:02:33 <Spark> full of 14 year old sluts
11:02:36 <Spark> </generalisation>
11:03:01 <Philippa> nope, afp's got an older crowd than that
11:03:25 <Philippa> and there's not the equivalent of the 20-odd y/o male geeks watching animé aimed at little girls thing
11:03:39 <Spark> i was talking to some 15 year old goth girl last friday night, who was trying to make the argument that although she'd had sex with 8 men, she wasnt a whore because she'd never done oral / anal
11:03:40 * Philippa thinks half of UoW's #compsoc and TSFS
11:03:48 <Spark> lol yes
11:03:56 <Spark> anime = paedophilia
11:04:02 <Philippa> I wouldn't go that far
11:04:03 <kristnjov> true.
11:04:11 <kristnjov> anime IS softcore paedophilia
11:04:14 <Philippa> I've seen some decent stuff, I'm just no rabid fangirl
11:04:33 <Philippa> only a certain subset of it
11:04:40 <Philippa> granted it's the most /popular/ subset...
11:04:40 <Spark> all the paedophiles i know like anime :)
11:04:45 * Philippa sniggers
11:04:51 <kristnjov> Spark, you know paedophiles? O_o
11:04:51 <Philippa> I know one who doesn't AFAIK...
11:04:52 <Spark> ok, all 2 of them
11:05:10 <kristnjov> well, in a sense i myself am a paedophile, i'm dating a 14 year old... the legal age in sweden is 15
11:05:14 <Philippa> though I only know him online. And he avoids relevant stimuli like the plague
11:05:25 <ibid> kristnjov: and your age is?
11:05:29 <kristnjov> 18 :/
11:05:36 <kristnjov> but hey she'll be 15 in a month!! ;)
11:05:40 <Spark> heh
11:05:44 <Spark> 3-4 years
11:05:56 <Philippa> I hope for your sake you know how to avoid it hurting too much
11:06:03 <Philippa> not to mention for /her/ sake
11:06:03 <Spark> when i was 21 i dated an 18 year old, thats the worst i think
11:06:12 <Spark> hell i am still 21
11:06:13 <kristnjov> Philippa, well i kind of don't know. i've only had sex once and that was intoxicated.
11:06:22 <Spark> mm
11:06:30 <Philippa> lubrication and going slowly are the main points
11:06:31 <Spark> these girls tend to me no strangers to sex though, am i right?
11:06:52 <tautologico> have I joined the wrong channel ? :)
11:06:53 <kristnjov> and suddenly this channel turned into sex ed!
11:07:05 <Philippa> depends. Not /every/ 15 y/o girl who's happy with the idea of a boyfriend is a junior chavette
11:07:06 <musasabi> uhms
11:07:21 <musasabi> just look outside the channel for 15mins...
11:07:24 <Philippa> kristnjov: you're the one who indicated you need it...
11:07:31 <tautologico> ok, let's talk about sexy types
11:07:46 <Philippa> yeah, starting with buzzy types :-)
11:07:50 <Spark> i want to read about the haskell type system
11:07:54 <Spark> from a type theory perspective
11:08:04 <Spark> but not full on maths, slightly more chilled than that :)
11:08:14 <Philippa> essentially it's H-M + type classes as far as that goes
11:08:19 <Philippa> so read up on type classes
11:08:26 <ibid> sexy types? ((),())
11:08:27 <Spark> what is the hindley mindler system?
11:08:30 <Spark> precicely
11:08:33 <Spark> erm
11:08:37 <Spark> hindley milner :)
11:08:38 <Lemmih> ibid: haha
11:08:48 <Spark> hinley mindler
11:09:10 <tautologico> Sexy Types in Action - http://portal.acm.org/citation.cfm?id=997142
11:09:15 <Philippa> Spark: let-polymorphism, basically
11:09:21 <Philippa> you got the brick book?
11:09:23 <Spark> hm right
11:09:25 <ibid> with type reconstruction
11:09:27 <Spark> yeah
11:09:32 <Spark> but i know of that as just 'the ml type system'
11:10:05 <Spark> so curry + type constants + quantified types, right?
11:10:17 <ibid> no
11:10:30 <Lemmih> Hello Isaac.
11:11:04 <SyntaxNinja> hihi
11:11:04 <Spark> ibid: can you elaborate on that? :)
11:11:44 <ibid> Spark: as i understand your description, that applies to System F and many other systems as well, not just the haskell system
11:11:48 <Philippa> quantifiers're only introduced at specific points
11:12:28 <ibid> Spark: the main thing that is different is that in HM, there are no quantified types per se, only quantified type schemes
11:13:03 <Spark> a scheme is like a type comprised of syntactic subtype right?
11:13:04 <Spark> like arrow
11:13:24 <ibid> Spark: a type scheme is either a type or a type with quantifiers in front of it
11:13:37 <Spark> right so thats the 'bottom' layer then
11:13:42 <ibid> Spark: but a type scheme cannot be used in place of a type in type expressions
11:14:35 <Philippa> to put it another way, all quantifiers go on the left
11:14:57 <ibid> yeah
11:15:00 <Spark> right, thats the same as the 'ml system' defined in my course notes here :)
11:15:14 <ibid> yeah, the haskell system is the ml system + additions
11:15:28 <ibid> HM is the "technical" name of the ml system
11:15:46 <ibid> (type classes being the most important addition)
11:15:58 <Spark> ah right
11:16:06 <Spark> so milner never came up with it by himself...
11:16:41 <tautologico> what do you mean "by himself" ?
11:16:51 <Spark> i.e. not 'with hindley'
11:17:02 <ibid> Spark: they were not working together
11:17:04 <Spark> cos my lecturer hasnt mentioned hindley once in this course :)
11:17:05 <tautologico> nope
11:17:19 <Spark> ahh was it an independent but simultaneous thing
11:17:24 <ibid> Spark: hindley did some work in logic that milner based the HM system on
11:17:26 <ibid> Spark: no
11:17:39 <ibid> and then damas made it work in practice :)
11:17:51 <tautologico> damas & milner
11:17:55 <ibid> yeah
11:18:27 <ibid> i sometimes call HM typing Hindley-Milner-Damas typing
11:18:56 <tautologico> and system F was worked on independently by girard and reynolds
11:19:04 <ibid> yeah
11:19:06 <Spark> ah yeah
11:19:10 <Spark> thats the more general version right
11:19:19 <Spark> the one that is very hard to work with?
11:19:38 <Spark> and was discovered to be undecidable in 92 or something
11:19:41 <tautologico> the problem is that it's undecidable in general... for inference and etc
11:19:41 <ibid> Spark: System F is the standard theory of universally quantified types
11:20:04 <ibid> System F is tractable but it has no type reconstruction algorithm
11:20:35 <ibid> Spark: the main difference is that System F requires type declarations and can go a little further than HM
11:20:41 <Spark> is system f the same as 'the polymorophic lambda calculus'?
11:20:51 <ibid> could be
11:21:02 <ibid> depends on what "the polymorophic lambda calculus" is
11:21:05 <ibid> :)
11:21:06 <tautologico> it's a typed second-order, polymorphic lambda calculus
11:21:12 <Spark> sigma ::= thi | sigma->tau | forall thi.sigma
11:21:17 <dblhelix> especially rank-n types are dramatic for inference
11:21:43 <ibid> thi, sigma, tau?
11:21:57 <ibid> ah, thi is a type variable?
11:21:58 <Spark> ok thi ranges over type variables, sigma and tau range over types
11:22:02 <Spark> yeah :)
11:22:02 <ibid> ok
11:22:18 <ibid> do you have \thi.epsilon?
11:22:34 <ibid> where epsilon ranges over terms and \ is lambda?
11:22:44 <Spark> as a type scheme?
11:22:48 <ibid> no
11:22:50 <ibid> as a term
11:23:11 <Spark> and thi in that context is a term variable?
11:23:16 <dblhelix> type application on the value level -- to instantiate type variables
11:23:17 <Spark> thats just the lambda abstraction isnt it? :)
11:23:18 <ibid> no, type variable
11:23:33 <ibid> as you said above
11:23:43 <Spark> hm a term with a lambda type variable stuck on the front
11:23:50 <Spark> dont think so, how does that reduce?
11:24:19 <ibid> if e : T then \a.e : forall a . T
11:24:36 <dblhelix> (/\t :: * . \x :: t . x) Int 5 ==> 5
11:24:42 <ibid> you of course have a corresponding type application
11:24:50 <ibid> term
11:24:59 <Spark> hm right
11:25:19 <ibid> dblhelix: /\?
11:25:35 <ibid> uppercase lambda?
11:25:44 <Spark> so is that like church's typing of the bound variable in an abstraction?
11:25:50 <dblhelix> using an upper case lambda for type abstraction, ibid ;)
11:26:21 <ibid> dblhelix: yeah, i figured
11:26:59 <Spark> theres nothing like that in this, though :)
11:27:35 <Spark> just the type syntax i specified above, and the rules ax, forall introduction/exclusion, and arrow introduction/exclusion in their usual forms
11:28:03 <ibid> get the pierce book :)
11:28:11 <Spark> heh ok its on my shelf
11:28:21 <Spark> i never got far enough into it to get at the juicy bits though
11:28:22 <dblhelix> yeah,it's excellent
11:28:23 <ibid> ok, read the pierce book :)
11:28:35 <ibid> Spark: it has a chapter on system f
11:28:59 <Spark> it doesnt have a chapter on intersection types, which is annoying :)
11:29:14 <ibid> it does mention them
11:29:17 <Spark> yeah
11:29:18 * dblhelix is away: dinner
11:29:25 <Spark> but not really to explain them in any detail
11:29:33 <Spark> i dont think it explains the type inclusion ratio either
11:29:44 <ibid> it's coverage of HM is also disappointing
11:29:45 <Spark> s/ratio/relation/
11:30:06 <Spark> since his phd was 50% about intersection types, its a bit suprising really :)
11:31:09 <ibid> type inclusion relation?
11:32:46 <Spark> "<="
11:33:01 <Spark> i got highly confused reading a paper because i transparently married "subtype" and "<=" as i read it
11:33:12 <Spark> so my supervisor suggested calling it that (i think)
11:33:40 <ibid> if it's different from subtype (in the subsumption sense), then i don't know what it means
11:34:00 <Spark> subsumption is like... an instantiation or substitution isnt it?
11:34:52 <ibid> subsumption is the rule that subtype can act for the supertype in every context
11:34:58 <Spark> when he uses 'subtype' he means it like "sigma is a subtype within the type sigma -> tau", so an entirely syntactic thing
11:35:02 <ibid> roughly speaking :)
11:35:03 <Spark> ah right yeah
11:35:10 <Spark> thats what i read as <=
11:35:24 <ibid> that's called subtype by most people :)
11:35:34 <Spark> things like tau&tau <= tau  and tau <= tau&sigma
11:35:38 <Spark> if im not being spacky
11:35:43 <ibid> and i've seen people use <: for it
11:35:55 <Spark> for sumsumption relation?
11:36:00 <Spark> i think i may have too actually
11:36:02 <ibid> for subtype
11:36:05 <Spark> its all a bit misty
11:36:21 <Spark> subtype as in... :)
11:36:30 <Spark> why do humans overload terminology
11:36:34 <wagle> what about covariant vs contravariant?
11:36:36 <ibid> as in the subsumption sense
11:36:41 <Spark> ah right ok
11:36:45 <ibid> i haven't heard it used in any other sense
11:36:59 <ibid> (except perhaps, if we separate out coercion subtyping)
11:37:15 <Spark> so <= <: subsumption relation and tentatively 'subtype relation' as long as theres no confusion
11:37:31 <Spark> the rule that uses it is called 'the subsumption rule' isnt it?
11:37:45 <ibid> what's the subtype relation you meant?
11:38:04 <ibid> Spark: subsumption rule yes, the relation is subtyping relation ;)
11:38:06 <Spark> the alternative meaning for it is like a subterm
11:38:10 <ibid> ah
11:38:12 <ibid> right
11:38:21 <Spark> you see hte problem :)
11:38:22 <ibid> i never get confused by that, i wonder why
11:38:35 <Spark> let me find something quickly
11:39:02 <Spark> do you have "principal type scheme and unification for intersection type discipline" - ronchi della rocca '88 i think
11:39:15 <ibid> not at hand, no
11:39:30 <Spark> i seem to remember it being a nightmare to find on the net but ill have a go
11:40:37 <ibid> reading comp.lang.c, i came across this funny bit:
11:40:44 <ibid> >> ANSI C does not define a distinction between warning (produces executable anyway), error (no executable produced), severe error (compiler deletes offending source code) and catastrophic error (compiler kills offending programmer)
11:41:16 <ibid> and it continues:
11:41:20 <ibid> >> void main() should come under the "catastrophic error" heading, but ANSI C does not insist on it.
11:42:00 <kristnjov> good thing haskell doesn't even make possible catastrophic code
11:42:33 <wagle> integer overflow
11:42:33 <ibid> i have one word for you: uPIO ;)
11:42:58 <wagle> unsafeatanyspeedIO
11:44:05 <Spark> void main probably causes less global distress than other invalid c though :)
11:44:11 <Spark> although it is unforgivably wrong
11:44:48 <ibid> i imagine it has killed a few c instructors in its time ;)
11:45:10 <ibid> (of exasperation:)
11:45:26 <wagle> i blame the compiler, not the programmer
11:45:39 <wagle> ..  i blame the programmer of the compiler
11:45:58 <Spark> i blame the manager of the programmer of the compiler
11:46:03 <wagle> why the heck should void main compile?  link?
11:46:12 <wagle> manager?  whazzat?
11:46:36 <wagle> hey man this is open sores!
11:46:57 <wagle> hmm.. i seem to be in sorehead mode today
11:47:08 <Spark> sigh firefox is so wank
11:47:20 <Spark> ooh it just segfaulted, no i can run it again
11:47:25 <Spark> and it'll be fast again...
11:47:41 <wagle> version 1.0..  qed
11:48:32 <wagle> see..  its self repairing..  if it never segfaulted, you wouldnt have that feature!
11:50:32 <Spark> grr
11:50:34 <Spark> http://portal.acm.org/citation.cfm?id=55086
11:50:39 <Spark> well thats it, but i have no idea how to actually get it
11:51:18 <tautologico> acm digital library subscription
11:51:20 <Spark> but it used <= and 'subtype' to mean different things in the same context with no explicit differentiation between them
11:51:37 <Spark> my department probably has that
11:51:42 <ibid> Spark: don't worry, i can get it from there :)
11:51:50 <Spark> heh ok
11:51:52 <ibid> no, actually couldn't
11:51:56 <ibid> that's not an acm publication
11:51:58 <tautologico> I can get it from the library
11:52:26 <ibid> the publisher link is http://dx.doi.org/10.1016/0304-3975(88)90101-6
11:52:28 <ibid> (elsevier)
11:52:29 <tautologico> by the way, does anyone has "a theory of type polymorphism in programming" by milner ? :)
11:52:39 <Spark> definition 2.8 anyway
11:52:53 <Spark> ooh that'd be nice too
11:52:54 <ibid> tautologico: is it _the_ paper?
11:52:59 <Spark> yeah
11:53:05 <tautologico> ibid: yep
11:53:06 <ibid> if so, i have it in our library
11:53:08 <Spark> where he introduces it all
11:53:19 <ibid> the acta informatica paper?
11:53:33 <Spark> its cited everywhere, and i even cited it in my ugrad project, but ive never ever seen it :)
11:53:47 <ibid> we don't apparently have a subscription to that number of tcs
11:54:07 <ibid> i mean the elsevier one;)
11:54:14 <ibid> i have even read it :)
11:54:18 <ibid> the milner paper
11:54:21 <Spark> heh
11:54:33 <Spark> these things are so much hassle to get hold of
11:54:39 <Spark> why arent they just available via the web
11:54:52 <Spark> its not like there are copyright issues, this is science, we should be promoting the sharing of knowledge :)
11:55:01 <tautologico> well, it's available for only 30 dollars :)
11:55:05 <wagle> scan it in, make it available
11:55:25 <ibid> oh yeah, sorry, not ai but jcss
11:55:31 <Spark> same with language standards and stuff...
11:55:33 <wagle> i knew the guy who ..typed.. in plotkin's classic paper
11:55:35 <Spark> you have to pay to get them :)
11:55:38 <tautologico> ibid: yep
11:55:49 <ibid> but i still have it :)
11:55:54 <tautologico> wagle: "cbv, cbn and the lambda calculus" ?
11:56:12 <tautologico> ibid: my department doesn't have access to this volume of jcss
11:56:28 <Spark> volume.. 17 is it
11:56:32 <tautologico> I think so
11:56:36 <ibid> our library has a paper copy of the number
11:56:36 <tuomov> scientific publication is a huge extortion system
11:56:57 <tuomov> the publishers reaping all the benefits of others' work
11:57:06 <tautologico> journals are insanely priced
11:57:20 <wagle> tautologico: i'm spacing the title..  something about domains
11:57:39 <Spark> im going to put a pizza on
11:57:59 <Spark> :o
11:58:06 <ibid> pizza as clothes?
12:01:52 <wagle> darn hugo herbelin is the wrong hugo and he does stuff with plotkin
12:07:34 <wagle> crud..  cant find it
12:07:58 <Spark> yep
12:08:02 <Spark> you can wear a pizza
12:08:12 <wagle> i have a copy of the hand written version somewhere
12:08:25 <wagle> oops..  the hand tossed version, that is..  8)
12:11:24 <wagle> the guy who did it was japanese, called himself hugo for a year i knew him, then he went back to his japanese name, which i cant remember..  heh/sigh
12:16:14 <Spark> heh
12:25:37 * dblhelix is back (gone 00:56:20)
13:00:17 * Igloo declares darcs' silly_maybe_possibly the function name of the day
13:00:48 <musasabi> sounds like a plan
13:22:54 <tromp> anyone here have a 64 bit machine?
13:24:30 <kristnjov> word is that 64 bit cpus aren't that much better than the 32 bit ones
13:24:34 <kristnjov> don't ask me why
13:25:37 <tromp> they said the same of 32 bit cpus when 16 bit was mainstream:)
13:25:46 <kristnjov> i suppose so
13:26:47 <Riastradh> tromp, why do you ask?
13:27:20 <tromp> i'm collecting results for the new version of my benchmark
13:27:45 <musasabi> tromp: I have an alphastation.
13:27:56 <tromp> wonderful! my favorite cpu
13:28:29 <tromp> Alpha CPU does 64 integer divide in a few cycles
13:28:40 <tromp> if you divide by a constant
13:28:57 <tromp> by changing it to a 64x64->128 multiplication
13:29:20 <tromp> what clockspeed, musasabi?
13:29:42 * Riastradh would like to acquire an Alpha, but he has not one now.
13:30:12 <tromp> i wished all the money sunk into the Itanic had gone into improving Alpha
13:30:14 <musasabi> 233 
13:30:16 <musasabi> iirc
13:30:47 <tromp> does it have 512MB+ memory?
13:30:56 <musasabi> no
13:31:03 <tromp> how much then?
13:31:08 <musasabi> 128mb
13:31:21 <tromp> ok, then you'll have to change the benchmark a bit
13:31:46 <tromp> it's at www.cwi.nl/~tromp/c4/fhour.html
13:31:59 <musasabi> never bothered to get more RAM for it as I didn't do anything heavy with it.
13:32:47 <tromp> just change TRANSIZE to something like 19999999
13:37:49 <musasabi> can you ask me to do it tomorrow? no ssh in and the monitor has been moved to an another room
13:39:15 <tromp> sure:0
14:26:06 <bourbaki> how can i make a .hs file a pdf or ps file?
14:27:55 <musasabi> hmm
14:28:04 <musasabi> hs or lhs ?
14:28:27 <tromp> enscript
14:28:33 <musasabi> that is are you asking "how can I print a haskell file" or "how can I pretty print a literate script file" 
14:28:40 <musasabi> vim does it too.
14:28:48 <musasabi> :hardcopy > a.ps
14:31:03 <bourbaki> .hs file
14:31:36 <bourbaki> the question is how can i keep the layout i have in the file and convert it to a ps or pdf file
14:32:33 <tromp> what do you mean by layout?
14:33:10 <xerox> "TeX"-it ! ?
14:33:38 <bourbaki> i mean when i just copy it to tex then you wont be able to read the code anymore
14:33:40 <tromp> postscript will have to map every textfragment to (textfragment) 59.5 332.4 ms
14:33:47 <jemfinch|lambda> where is lambdabot's source code?
14:33:48 <bourbaki> i want it to look like haskell code still
14:33:50 <tromp> or something like that
14:34:24 <tromp> don't see how that's possible
14:34:30 <musasabi> jemfinch|lambda: on scannedavian
14:34:37 * jemfinch|lambda googled.
14:34:53 <musasabi> jemfinch|lambda: shapr is responsible for it.
14:35:25 <jemfinch|lambda> yeah, I know :)
14:35:42 <tromp> at best you get every "line of text" replaced by (line of text)m
14:36:36 <tromp> where m is defined to position each next line on the page
15:06:44 * Lemmih is slightly bored.
15:07:00 <Lemmih> Anyone hacking something spiffy?
15:07:23 <Riastradh> No.
15:10:15 * musasabi is the second day in fever..
15:10:32 <musasabi> Too tired to code anything serious, too hyperactive to sleep
15:37:05 <redhatPT> hi, how can I get this working? 
15:37:06 <redhatPT> 	maximos' :: [(Double,Double)] -> [Double]
15:37:06 <redhatPT> 	maximos' [(x,y)] = max x y
15:38:06 <dons> you're taking a list of pairs, but only pattern matching on a list with a single element
15:38:34 <dons> [(x,y)] matches a list with 1 pair in it, which doesn't look correct
15:38:53 <dons> max x y returns a Double, not a [Double]
15:39:10 <dons> you need to apply your function to each element of the list, most likely.
15:39:17 <dons> look at map
15:41:47 <redhatPT> maximos' l = map (max) l does not work ...
15:42:58 <dons> no, because max takes 2 arguments, and you're giving it a single argument as a pair
15:43:49 <dons> you could look at Data.Tuple, and try out the uncurry function...
15:44:07 <dons> there are always bonus points for using uncurry/curry :)
15:44:07 <jadrian> redhatPT: hey
15:44:14 <jadrian> eh :)
15:44:42 <jadrian> dons: uncurry is exported by Prelude
15:44:58 <dons> oh, true. of course it is :}
15:45:32 <dons> too much time staring at libraries/base/Data/* code..
15:45:37 <jadrian> :)
16:10:21 <Nioate> is there some secret way to get haddock to ignore a subset of names that it cannot resolve?
16:26:49 <musasabi> Nioate: cpp 
16:29:18 <Nioate> musasabi: what's that
16:29:34 <Nioate> c preprocessor?
16:29:46 <musasabi> wrote to the wrong window.. yes.
16:29:50 <musasabi> 02:24 <@musasabi> haddock does not use cpp, but you can make ghc use it {-# OPTIONS cpp #-}
16:29:53 <musasabi> 02:24 <@musasabi> now think about:
16:29:56 <musasabi> 02:25 <@musasabi> -- /* 
16:29:58 <musasabi> 02:25 <@musasabi> {-
16:30:01 <musasabi> 02:25 <@musasabi> -- */
16:30:03 <musasabi> 02:25 <@musasabi> my code 
16:30:06 <musasabi> 02:25 <@musasabi> -- /*
16:30:08 <musasabi> 02:25 <@musasabi> -}
16:30:11 <musasabi> 02:25 <@musasabi> -- */
16:31:35 * cm shapes shapr 
16:32:11 <Nioate> neat, but I don't see how to use that to do what I want. haddock keeps wanting to reference things like FilePath Show Eq Ord Int String Maybe Bool Integer Double which are not defined in any of my code. so it spits out a warning that gets in the way of warnings that might be important
16:33:52 <musasabi> there was a flag for that iirc
16:50:45 <jadrian> hmm nice
16:50:54 <jadrian> the new emacs mode is quite good
16:51:06 <jadrian> but it's going to take a while to get used to the new key-bindings
16:58:26 <cm> which features do you like the mot?
16:58:28 <cm> most
17:01:49 <musasabi> hmm where (new mode) ?
17:39:09 <jadrian> musasabi: http://www-perso.iro.umontreal.ca/~monnier/elisp/
17:39:55 <jadrian> It's not possible to override an instance declaration, is it?
17:42:49 <jadrian> hello Igloo 
17:44:06 <Lemmih> He tricked you.
17:44:29 <jadrian> he probably knows I have a question...
17:44:36 <musasabi> jadrian: thanks.
17:44:43 <jadrian> musasabi: np ;)
17:46:58 <Igloo> Hi
17:49:14 <stepcut> yahoo! Life is good -- there exists a cabalized http library !
18:31:28 * jadrian ----> bed
18:31:49 <bloomberg> ok so im in haskell fiddling about with mazes. I have a function hasWall to test whether an (x,y) co-ordinate in a maze has a wall in a specified direction, say hasWall (0,0) N = True. Now the walls are stored in four separate lists listN = [(0,0)] in this case. i want to define hasWall pos dir = pos 'elem' list where list will be listN if dir = N, listS if dir = S etc. ive tried a convert :: Dir -> String function, ie convert n = "listN" but i cant se
18:35:06 <Lemmih> bloomberg: Try to simplify the problem.
18:35:32 <stepcut> agreed!
18:35:52 <bloomberg> well i have it working if everything is written out in full; just want to shorten the code if possible
18:36:13 <Lemmih> bloomberg: You probably want: convert N = listN ; convert S = listS ...
18:36:38 <bloomberg> yes, so you cannot continue indefinately trying to avoid writing things out!
18:37:32 <Lemmih> I think refactoring will solve must of it.
18:37:34 <Lemmih> *most
18:38:56 <bloomberg> right so convert :: Direction -> [a]?
18:39:34 <Lemmih> What's the type if the lists?
18:39:50 <Lemmih> *of
18:39:56 <bloomberg> technically [Place] where Place :: (Int,Int)
18:40:35 <Lemmih> Then :: Direction -> [Place] would be more readable IMO.
18:42:12 <bloomberg> so is there any way i can define Listd without doing ListN = .., ListS = ..., etc
18:43:25 <Lemmih> list d = ...
18:44:49 <bloomberg> hang on, list(space)d? I don't want List to be a function...the lists need to be separate, as in ListN, ListS etc
18:45:10 <Lemmih> bloomberg: You're up pretty late. Is it homework due to tomorrow? (o:
18:45:32 <Lemmih> ListS should be a type?
18:45:44 <bloomberg> no...Monday...as I say this is only to make it shorter, ive done e nough
18:46:01 <bloomberg> gd thinking
18:47:34 <Lemmih> Wouldn't 'list N = [(0,0)] ; list S = [(1,1)] ...' work?
18:49:10 <bloomberg> ok there are several mazes and the walls are stored with each maze. I'm writing a standard module that can take any name of amaze and a list of its walls and return the actual maze
18:50:53 <Lemmih> @wiki HaskellIrcPastePage
18:51:04 <Lemmih> lambdabot?
18:51:30 <Lemmih> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:53:03 <bloomberg> ok r u asking me 2 paste the code?
18:54:42 <Lemmih> Yes. I don't understand your description of the problem. Looking though the code might help.
18:55:01 <bloomberg> k
18:55:32 <bloomberg> id rather send u the code if thats ok
19:15:49 <cm> dons: btw, in Windows wxHaskell's "start" can be invoked multiple times without apparent problems :)
19:17:27 <dons> yep. I think it was a linux-only bizarro issue
19:46:19 <bloomberg> anyone feel like helping debug some code?
19:47:44 <dons> the usual custom is to ask questions, and if people feel inclined, you'll get answers ;)
19:50:53 <bloomberg> k well code is on http://users.ox.ac.uk/~worc2122/Main2.lhs, involves mazes and lists of walls, compiles fine, but logical errors exist which I can't seem to trace
19:51:07 <bloomberg> sorry that should be interprets
19:58:09 * stepcut remembers playing a-maze-ing on the ti 99/4A
20:02:05 <stepcut> http://www.oriole.net/~rworne/ti99-4a/tiamazei.jpg
20:11:30 <stepcut> hrm, nintendo was founded in 1889
20:13:19 <Nioate> oh?
20:14:09 <stepcut> yep
20:14:35 <stepcut> early nintendo game -> http://www.oriole.net/~rworne/hanafuda/ 
20:33:02 <bloomberg> k not 2 worry this thing works now
20:33:30 * stepcut just sent an sms to his phone from haskell :p
20:33:45 <dons> yay!
20:34:40 <stepcut> if all goes well, I should be able to send a ringtone tomorrow :)
20:41:37 <Nioate> send a ringtone?
20:41:57 <cm> cell phones -_-
20:42:17 <Nioate> sometimes I wish I could search the stdlib for a type signature
20:42:33 <cm> highly OT: what's the worst that can happen when you connect a power adapter designed for 240V to a 110V power plug?
20:46:08 <Nioate> I don't remember seeing (and can't find) a monad operator :: Monad m => m a -> m b -> m a which is like >>, but the contents of the second monad is discarded instead of the first. is there one?
20:46:48 <dons> that's interesting. I was wondering about a constM operator today, myself
20:47:01 <dons> to get around appending return () to things
20:47:20 <dons> @type const
20:47:39 <dons> bot?
20:48:19 <dons> Prelude> :t Control.Monad.liftM2 const
20:48:19 <dons> Control.Monad.liftM2 const :: forall a1 a2 m.
20:48:19 <dons>                               (Monad m) =>
20:48:19 <dons>                               m a1 -> m a2 -> m a1
20:48:41 <dons> let constM = liftM2 const
20:49:28 <dons> > :t const
20:49:29 <dons> const :: forall a b. a -> b -> a
20:50:27 <Nioate> woah
20:50:53 <Nioate> I was just going to do
20:50:54 <Nioate> a `something` b = a >>= (\val -> b >> return val)
20:52:30 <dons> we already have: const x _ = x
20:52:36 <dons> you just want that lifted, right?
20:53:03 <Nioate> yes
20:53:22 <dons> liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:53:33 <Nioate> I understand it
20:53:54 <dons> I think they're identical, in fact
20:53:56 <Nioate> but using just >>= and >> and lambdas is probably easier to understand
20:54:37 <dons> but do .. is sugar for: m1 >>= \x1 -> m2 >>= \x2 -> return (const x1 x2)
20:55:08 <dons> now, why don't we already have constM I wonder
20:55:44 <Nioate> I don't know
20:55:58 <dons> I guess liftM2 const is pretty easy to write ;)
20:58:11 <Nioate> so is liftM2
20:58:15 <Nioate> and so is const
20:58:27 <Nioate> so why both putting either of them in the standard libraries either?
20:58:53 <dons> ah. the family of liftM? functions are very useful, though
20:58:57 <Riastradh> liftM2 & const are each vastly more useful than the combination of the two.
20:59:10 <dons> and const is one of the first functions defined in the prelude == very important
20:59:42 <dons> just after (), and just before flip :)
21:00:39 <dons> I just made that up. It's really just after id, lazy, and assert. and before (.) and fliip
21:23:41 <vdrab> hello ppl, a quick one about the emacs haskell mode. haskell-decl-scan.el scans your code for top-level declarations, but what is the emacs function/command again for jumping to the function declarations again?
21:26:56 <vdrab> anyone know? wrong #channel?
21:31:12 <stepcut> are you sure there is a command ?
21:31:18 <stepcut> I think you just go in the menu ??
21:31:29 * stepcut is ignorant
21:31:40 <vdrab> oh really?
21:32:35 <vdrab> thought there was some kind of M - x jump-to .... function associated with it... i mean, it's emacs, right :-)
21:32:48 <vdrab> could be wrong though... thanks anyways
21:33:37 <vdrab> and if they are accessible through the menu there *has* to be some elisp function doing the jumping behind the scenes
21:34:08 <vdrab> well, it's not of vital importance really...
23:45:58 <dblhelix> morning
23:46:20 <dblhelix> up early again, musasabi? :)
