00:06:09 <musasabi> morning
00:06:44 <Lemmih> Morning? Oh darn.
00:06:52 * Lemmih goes to sleep.
00:10:11 <musasabi> 10:05 AM here
00:55:11 <Boegel> hello everyone
01:27:28 <musasabi> hello Boegel
01:29:58 <Boegel> hello musasabi :)
01:35:33 <musasabi> Any tips how to represent database search queries in haskell so that they can be optimized?
02:51:40 <musasabi> What is the simplest way to execute a process and capture stdout in haskell?
03:03:09 <Boegel> hmm musasabi , i think everybody is still asleep :p
03:04:46 <maihem> I've been awake since midnight (now 1106am), I just don't know the answer ;)
03:06:07 <Boegel> why don't you go to sleep maihem ? or why did you get up at that hour ?
03:06:38 <maihem> I got up at midnight because I fell asleep at 6pm, and I only sleep 6hours
03:07:44 <Boegel> sounds like a f*cked up biorithm
03:10:30 <maihem> yep :) I'm unemployed and don't bother to either go out or open the curtains. but I have been a bit unwell and sleeping more frequently than normal this week.
03:13:41 <Boegel> maihem, if you don't bother to go outside or even open the curtains, it's normal that you feel unwell...
03:13:52 <maihem> :-P
03:13:58 <Boegel> you need fresh air dude :)
03:14:12 * Boegel -> dinner
03:28:29 <tuomov> fresh air is over-rated
03:43:31 <wilx> It isn't :)
03:43:53 <wilx> Only that that you breathe is probably not fresh :)
03:44:50 <musasabi> Using System.Process seems good, but how to do it properly?
03:56:16 <bourbaki> moin
03:58:22 * Boegel -> back
03:58:32 * Boegel -> gone :)
03:58:50 <Boegel> bye everyone, I'm going to get me some fresh a >:)
03:58:55 <bourbaki> ?
03:59:01 <bourbaki> fresh air?
03:59:09 <Boegel> yes (there goes my joke :p)
03:59:28 <bourbaki> joke?
03:59:32 <Boegel> bye ;)
03:59:38 <maihem> =D
05:26:50 <shapr> @yow !
05:26:51 <lambdabot> I've got a COUSIN who works in the GARMENT DISTRICT...
05:36:48 <shapr> gwahr!
05:36:50 <shapr> this calls for unicycling!
05:37:53 <kristnjov> i'd bet it does
05:38:07 <kristnjov> but shapr, before you leave, do you know of any id3 module for haskell?
05:38:15 <shapr> I do not.
05:38:18 <shapr> why don't you write one?
05:38:18 <kristnjov> alright
05:38:34 <shapr> it's easier than you think...
05:38:35 <kristnjov> well i felt like it was easier not having to learn the basic structures of id3
05:39:17 <shapr> probably is easier to not learn that sort of stuff.
05:39:38 <shapr> but if you want to be a wizardly hacker, it's good to learn new structures on a regular basis.
05:39:46 <kristnjov> i suppose so
05:39:49 <shapr> also increases your ability to be hired
05:40:02 <kristnjov> but for example, how do i read the bytes in the range 1024-2048 in a file?
05:40:09 <shapr> I try to learn a new data format each month.
05:40:23 <Philippa> if they're all XML, you're cheating
05:40:26 <shapr> min l√§xa
05:40:27 <shapr> :-)
05:40:31 <kristnjov> :)
05:40:42 <shapr> hey Philippa 
05:40:47 <Philippa> 'lo
05:40:50 <shapr> nah, I'm talking about binary formats
05:40:56 <shapr> anyway, unicycling... bbl
05:41:08 <Philippa> so, if they're all binary bastardisations of s-expressions you're cheating :-)
05:51:26 <bourbaki> can anyone help me on ffi for a sec?
06:09:13 <musasabi> bourbaki: hmm?
06:09:38 <bourbaki> musasabi ive got some windoze structures like
06:10:25 <bourbaki> well like something :) what do i do with them? i just go and copy them into my interface.h and rewrite the types of them as in HSFFI.h?
06:10:34 <bourbaki> like that
06:10:35 <bourbaki> typedef struct tagRGBQUAD {
06:10:35 <bourbaki>   HSChar    rgbBlue; 
06:10:35 <bourbaki>   HSChar    rgbGreen; 
06:10:35 <bourbaki>   HSChar    rgbRed; 
06:10:35 <bourbaki>   HSChar    rgbReserved; 
06:10:37 <bourbaki> } RGBQUAD; 
06:10:48 <musasabi> Well most of the time you just manipulate pointers to structures.
06:11:23 <bourbaki> right
06:11:30 <musasabi> you can represent structures as arrays but then you are left alone with alignment constraints.
06:11:40 <bourbaki> PBITMAPINFO capture(void){
06:11:48 <bourbaki> this is the function i want to call
06:12:04 <musasabi> so what kind of type is PBITMAPINFO ?
06:12:11 <bourbaki> musasabi would you mind if i send you my interface.h?
06:12:17 <bourbaki> or sec
06:12:22 <bourbaki> ill paste it to no paste
06:12:27 <Philippa> it's a Pointer to a BITMAPINFO judging by typical MS code
06:13:10 <bourbaki> http://rafb.net/paste/results/CguLSK40.html
06:13:15 <bourbaki> right
06:13:33 <bourbaki> ive retyped the structures in that interface file
06:13:42 <bourbaki> so i dont have to include the windoze files
06:16:36 <musasabi> So PBITMAPINFO is a pointer to the BITMAPINFO struct.
06:16:43 <bourbaki> right
06:16:54 <musasabi> You can handle that as a (Foreign)Ptr
06:17:17 <musasabi> If you need a finalizer (to free it) use ForeignPtr, if not Ptr is fine.
06:17:26 <bourbaki> so this header surfices the needs for an interface?
06:17:57 <musasabi> well I all interfaces are optional...
06:18:21 <bourbaki> ?
06:18:50 <bourbaki> ok but i need to compile that header to get the object file
06:19:59 <musasabi> well you can define foreign import ccall/stdcall "capture" capture :: IO (Ptr BitMapInfo)
06:20:34 <musasabi> the haskell side does not really care where and how you implement the C func.
06:20:37 <bourbaki> thats all?
06:20:47 <musasabi> yes, more or less.
06:22:00 <bourbaki> ok and how do i get the structures into the haskell side?
06:25:43 <musasabi> well generally you would define accessors as C functions.
06:26:03 <musasabi> of course you can just mutilate raw memory if you want and are confident about that.
06:26:14 <musasabi> also there are automated tools to generate such things.
06:26:49 <bourbaki> accessors as c finctions?
06:27:41 <bourbaki> is there an example somewhere around i havent been able to come up with one through google and the ffi docs arent showing an example in detail
06:28:34 <LAPA>  hi
06:29:44 <musasabi> int getFooX(struct foo*foo) { return foo->x; }
06:30:09 <bourbaki> is that a c function?
06:30:11 <musasabi> foreign import ccall "getFooX" fooX :: Ptr Foo -> IO Int
06:30:43 <musasabi> there are generators to do stuff like this if you need it.
06:31:05 <bourbaki> i was confused about that in the doc also
06:31:10 <musasabi> personally I have stumbled mostly on apis which consists of only functions with primitive values.
06:31:12 <bourbaki> whats that ? thats not c and not haskell code
06:31:36 <musasabi> e.g. c2hs
06:32:00 <musasabi> the second one? that is a haskell declaration getting the C func into scope.
06:32:05 <musasabi> but have to go..
06:32:11 <bourbaki> dang
06:32:16 <musasabi> angry gf watching behind my back
06:32:25 <bourbaki> return foo->x;  i mean this is not c is it?
06:32:28 <bourbaki> :)
06:33:10 <musasabi> yes that is C.
06:34:33 <bourbaki> *cough* ive never seen a -> in c
06:34:48 <bourbaki> ah er ok ihavent said anything :)
06:35:08 <dv> a->b = (*a).b
06:35:15 <bourbaki> yeah
06:35:25 <bourbaki> nm i just am a little dumb today :)
06:37:07 <shapr> f
06:37:11 <shapr> doh
06:37:14 <bourbaki> and this Ptr Foo gets generated by a tool?
06:37:18 <bourbaki> @arr
06:37:18 <lambdabot> Smartly me lass
06:37:20 <shapr> lambdabot stack overflow again today...
06:49:44 * Philippa is having... "fun" trying to write threaded wxHaskell code
06:53:23 * Philippa decides to RTFFAQ and discovers there's a reason for this
06:53:24 <Philippa> oh well
06:56:42 <maihem> I'm having fun looking at exceptions... In principle, it seems that every function is in a special "invisible" monad (ie, every "Int" is actually a "InvisibleMonad Int"), and thus an exception can be passed all the way up, short circuiting everything, until catch in the IO monad is reached.
06:56:45 <maihem> Does this sound right?
06:57:42 <maihem> Is there a way to catch these exceptions using my own monad, or must I write a monad with a fail implementation to do the same thing as exceptions, and put everything I want into that monad?
06:57:56 <Philippa> your own monad could wrap the IO monad, but that's about it
06:59:03 <maihem> so I can't catch these exceptional cicumstances, like divide by zero closer to where they occur, and do something else instead.
07:00:31 <Philippa> not without access to the IO monad, no
07:00:32 <maihem> I know I can handle NaN on Floating numbers okay, as well, I think, as +/- Inf - since floating point numbers have testing functions and I can wrap them up. But Integer operations don't seem to behave so nicely
07:01:05 <Philippa> if you imagine that the IO monad's return is called "eval" for a moment, it's the evaluator that might have side-effects rather than the functions it evaluates if that makes sense
07:07:25 <maihem> I'll have to wrap numbers up in a "data Safe a = DivideByZero | PosInf | NegInf | Num a" so I can make instances of the relevant classes to define things like "(/) _ (Num 0) =DivideByZero" and then "inversetangent DivideByZero = Num (Pi / 2)", sort of thing
07:08:35 <Philippa> mebbe unsafePervert^WPerformIO might help?
07:08:46 <maihem> Aarrrgh!
07:08:58 <Philippa> :-)
07:09:21 <maihem> I've only trusted myself to use that when I'm looking for bugs/excessive evaluation
07:09:45 <maihem> IMHO "Safe" numbers should be in the library
07:09:52 <Philippa> I've not actually used it and would prefer to avoid it like the plague...
07:10:01 <Philippa> yeah, that would be good
07:10:10 <maihem> And happen automatically (so literals were just safe)
08:04:23 <Philippa> yay!
08:04:33 * Philippa figured out a way to do multithreaded wxHaskell code
08:04:39 <Philippa> granted it involves more than one OS thread, but hey
08:46:47 <kasparoV> hi there
08:48:14 <kasparoV> is x==y expression in C equal in haskell ?
08:48:42 <dv> for numbers
08:49:13 <kasparoV> dv help me out plz, I got this code:
08:49:24 <kasparoV> minLista [x] = x
08:49:25 <kasparoV> minLista l = minListaAC l 1
08:49:25 <kasparoV> 	where minListaAC (x:xs) ac = if(x<ac) then (x==ac) else minListaAC(xs) ac
08:49:35 <kasparoV> to get the lower number 
08:49:51 <kasparoV> and I cant get it working
08:49:51 <dv> you want the lowest number?
08:49:57 <kasparoV> yes
08:50:52 <dv> import List
08:50:59 <dv> minLista = head . sort
08:51:15 <kasparoV> :P can¥t do it by that way
08:51:16 <kasparoV> :P
08:52:12 <arjanb> @type minimum
08:52:13 <lambdabot> minimum :: forall a. (Ord a) => [a] -> a
08:53:03 <kasparoV> arjanb neither by that way :(
08:54:07 <Etaoin> kasparoV: what exactly is (x==ac) supposed to be?
08:54:47 <maihem> I think he's trying to assign
08:54:57 <kasparoV> I have to change the value of ac if it is bigger than x
08:55:20 <maihem> kasparoV, you don't change the value, consider recursion
08:55:47 <kasparoV> hum?
08:55:50 <maihem> oh wait you *are* recursing
08:56:18 <maihem> Do you know what the type of the expression x==ac is?
08:57:15 <kasparoV> Lol Bool
08:57:18 <kasparoV> lame lame lame
08:57:20 <kasparoV> thx
08:57:25 <maihem> np
08:59:10 <kasparoV> humm and when I change "then(x=ac)" it says that is a parse error 
08:59:11 <kasparoV> :|
08:59:27 <maihem> whay is the type on minLista supposed to be?
08:59:35 <maihem> s/whay/what
08:59:51 <kristnjov> http://attenuation.net/files/iq.htm
09:00:41 <kasparoV> [Int] -> Int
09:01:10 <dv> kristnjov: that's most likely fake
09:01:16 <kristnjov> dv i know
09:02:00 <maihem> so what is the type of minListaAC supposed to be?
09:02:36 <dv> i think also the initial value of ac is going to be a problem
09:02:39 <kasparoV> same
09:02:40 <kasparoV> :|
09:02:54 <kasparoV> dv why
09:02:55 <kasparoV> ?
09:02:58 <dv> what if you have a list whose minimum value is 3? your function will return 1
09:03:04 <maihem> oh yeah :)
09:03:11 <dv> mini  l  = min_ l 1
09:03:11 <dv>         where   
09:03:11 <dv>                 min_ (x:[]) y = if x < y then x else y
09:03:11 <dv>                 min_ (x:xs) y = if x < y then min_ xs x else min_ xs y
09:03:29 <kasparoV> humm
09:03:49 <kasparoV> but I need to use one "acumulator"
09:04:04 <kasparoV> sorry my bad english
09:04:06 <kasparoV> :\
09:04:27 <dv> assuming you're going to use Ints only you could use their maximum value (2^31?)
09:04:35 <Lemmih> You should apply the first element of l to min_ and mini should fail if l is empty.
09:04:46 <maihem> kasparoV, accumulators are implemented by passing the new value in on the next recursion
09:05:41 <kasparoV> but I need to use them
09:05:42 <kasparoV> :|
09:05:46 <Lemmih> mini (x:xs) = min_ xs x
09:06:09 <dv> oh right, yeah that'll work
09:07:22 <kasparoV> humm gonna try
09:08:53 <kasparoV> lol it works
09:09:02 <kasparoV> but now I have to understand it
09:09:03 <kasparoV> :P
09:09:13 <kasparoV> brb
09:11:44 <Lemmih> It's not very different from your version.
09:13:00 <kasparoV> that I figured out but why doesn¥t mine work?
09:13:50 <maihem> kasparoV, you only recurse when x is not less than the current minimum, you should recurse on both, but always pass the smaller of the two
09:16:51 <kasparoV> humm gonna try again
10:18:02 <shapr> d00d
10:18:13 <shapr> it's oh so quiet...
10:18:26 <Lemmih> Indeed.
10:18:50 <Lemmih> How's code, shapr?
10:19:27 <shapr> creative and lightly buzzed
10:20:26 <Maddas> :-)
10:23:50 <kyoguts> guys why when I try to put the word Vertex in haskell the colour does not change to orange
10:24:50 <kyoguts> like Int or Bool
10:25:31 <kyoguts> Anyone to have a look on my code on private?
10:25:32 <Lemmih> kyoguts: Syntax highlighting is not a formal part of the Haskell language. It's completely dependent on the editor you're using.
10:25:59 <kyoguts> Hugs 98: Based on the Haskell 98 standard 
10:26:01 <kasparoV> use gvim for that, works fine here
10:27:10 <kyoguts>  Anyone care to have a look on my code on private?
10:28:37 <kasparoV> i'm not the best person to do that... kinda n00b
10:30:31 <musasabi> Has anyone used System.Console.SimpleLineEditor ?
10:30:42 <musasabi> It does not appear to reset terminal settings correctly...
10:36:00 <kasparoV> maihem are u there?
10:39:06 <kasparoV> dv ?
10:39:34 <Lemmih> kasparoV: Got problems?
10:40:06 <kasparoV> just to check if the code is "good"
10:40:19 <kasparoV> it works, but I would like to have another opinion
10:40:53 <kasparoV> its a function that calculates the product of the elements of a list
10:40:54 <kasparoV> like
10:41:07 <kasparoV> [1,2,3,4] -> 1*2*3*4 -> 24
10:41:11 <kasparoV> can I PM ?
10:41:20 <Lemmih> Sure.
10:43:10 <dv> there's already product in Prelude
10:43:30 <kasparoV> dv :P got to create one new
10:43:30 <kasparoV> :P
10:43:47 <kasparoV> university exercises, can't cheat :(
10:43:55 <dv> you know, the easiest way to do this would be to look at the Prelude sources
10:44:03 <dv> product = foldr (*) 0
10:44:04 <dv> heh
10:44:13 <dv> er, 1 not 0
10:44:32 <kasparoV> cant do it :P
10:46:01 <dv> at least your uni uses haskell. mine uses C++ and java (ugh)
10:46:45 <kasparoV> lol haskell and C in the 1st year
10:46:59 <kasparoV> haskell C and prolog in the second
10:47:09 <kasparoV> haskell C and Assembly on the third
10:47:21 <kasparoV> and c and Java in the 4th and 5th
10:47:49 <arjanb> that's quite a lot of programming
10:48:09 <xerox> wow.
10:48:47 <Lynx> could you suggest me any doc, even an url, that show how somebody should benefit programming in haskell?
10:49:07 <kasparoV> translated to english is Systems and Informatics Eng.
10:49:30 <xerox> .pt is ?
10:50:03 <kasparoV> Eng. Sistemas e Informatica
10:51:07 <Lemmih> Lynx: http://www.haskell.org/complex/why_does_haskell_matter.html
10:51:15 <Lynx> tnx
10:51:54 <Lemmih> Lynx: And http://www.md.chalmers.se/~rjmh/Papers/whyfp.ps
10:58:22 <Lynx> is the second about fp in general?
10:59:39 <Lynx> I have programmed long time ago in scheme, a dialect of scheme. I don't know Haskell so in my experience I think that most elegant and expressive language is scheme. So Haskell is interesting for me as it's an fp language. 
11:00:23 <Lynx> scheme, a dialect of Lisp
11:03:33 <dv> well for one thing, haskell doesn't have nearly as many parenthesis
11:04:06 <Etaoin> irrelevant
11:04:27 <dv> heh not to me 
11:12:12 <Lemmih> Yay. 100 clients. Haskell is getting popular.
11:12:51 <Etaoin> defining the instance (Num b) => Num ((->) a b) is fun
11:19:11 <kasparoV> humm how does the error function works?
11:19:32 <kasparoV> or ERROR
11:19:34 <kasparoV> dunno
11:19:34 <kasparoV> :|
11:23:38 <Lemmih> kasparoV: error throws an ErrorCall.
11:37:55 <Nomius> http://rafb.net/paste/results/5AQiM662.html   <---- is it there a sintax error?
11:39:13 <dv> else esprimos x n-1 <-- ?
11:39:17 <Nomius> I get: "ERROR "a.hs":2 - Instance of Num Bool required for definition of isprime" in HUGS
11:39:32 <Nomius> dv, sorry, I forgot in the translation :)
11:39:39 <Nomius> is: isprime x n-1
11:39:41 <Etaoin> you need some parentheses
11:39:42 <Etaoin> (n-1)
11:39:46 <dv> well basically you can't have the function return both Bool and Int
11:40:13 <Etaoin> otherwise, it thinks you want (esprimos x n) - 1
11:40:38 <Nomius> Etaoin, it is esprimos x (n-1)
11:41:35 <Nomius> but I'm getting the same error
11:43:51 <Nomius> well... I'm getting a different error now: ERROR "a.hs":8 - Instance of Fractional Bool required for definition of prime
11:45:38 <Etaoin> parentheses again?
11:45:49 <Etaoin> (x/2)
11:46:50 <Nomius> no, I have already put parentheses in there...
11:47:20 <dv> isprime x n = if x`mod`n == 0 then False
11:47:21 <dv>               else esprimos x n-1
11:47:23 <dv> you can't do that
11:47:43 <Nomius> dv why?
11:48:36 <Nomius> how is the integer divition? <--- I think I'm failing there...
11:49:48 <dv> actually, i was wrong, you just need to use integer divison
11:49:56 <dv> sorry. use x`div`2
11:50:08 <Nomius> yeah! thanks earthy
11:50:16 <Nomius> brrr dv!
11:50:21 <dv> btw you only need to check up to sqrt(x) not x/2
11:51:00 <Nomius> it works now :)
11:51:02 <Nomius> thanks dv
12:02:17 <Nomius> it it there a function called mkInt (mkint) or something like that that makes a Int from a String?
12:02:38 <dv> read
12:03:04 <dv> read "2" :: Integer => 2
12:04:26 <Nomius> main = getLine >>= \numstr -> read numstr >>= \num -> prime num >>= \str -> putStr str          <-------------- any error in there?
12:05:54 <tromp> read numstr doesn't produce a monadic value, does it?
12:05:58 <dv> are you aware of this thing called the 'do notation' ?
12:08:00 <Cale> getLine >>= \numstr -> print (prime (read numstr))
12:08:56 <Nomius> Cale, thanks
12:09:02 <Cale> unless prime returns a string, in which case  getLine >>= \numstr -> putStrLn (prime (read numstr))
12:09:29 <Nomius> <tromp> read numstr doesn't produce a monadic value, does it?   <--- how can I know when a function produce a monadic value?
12:09:39 <Cale> You look at its type
12:09:54 <Nomius> in the prologe?
12:10:01 <Cale> getLine :: IO String
12:10:04 <Nomius> brrr, prelude
12:10:26 <Cale> you can use ghci:  ":t getLine" will give you the type of getLine, for instance
12:13:20 <Nomius> thanks Cale! :)
12:13:43 <Cale> no problem
12:14:07 <Nomius> where or how can I see the function read?
12:14:23 <Cale> in the prelude
12:14:33 <Cale> It's defined differently for different types
12:14:34 <Nomius> and where is it?
12:15:09 <Cale> section 8.2
12:15:12 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
12:23:00 <Nomius> how would it be the != or <> (not equal)?
12:24:22 <Lemmih> @type (/=)
12:24:23 <lambdabot> (/=) :: forall a. (Eq a) => a -> a -> Bool
12:35:56 <Nomius> lambdabot, Lemmih thanks
12:49:18 <thebug> hehe
13:02:11 * TheHunter is away: I'm busy
13:02:11 * TheHunter is away: I'm busy
13:02:17 * TheHunter is back (gone 00:00:05)
13:19:47 * TheHunter is thinking about the problem of the next permutation
13:24:43 <TheHunter> well it's probably impossible to do it in a nice way without space leaks
14:15:05 <segphault> I'm an ocaml programmer who has grown weary of ocaml's lack of expressiveness. Can anybody point me in the direction of a haskell tutorial that is geared towards people who already know ocaml?
14:17:31 <segphault> or failing that, a haskell tutorial that doesnt presuppose academic understanding of math/logic.
14:20:59 <Lemmih> YAHT is pretty good. http://www.isi.edu/~hdaume/htut/
14:21:15 <marcot> Good evening.
14:24:12 <segphault> Lemmih: looks good. thanks.
14:26:00 <Cale> hmm -- Multimedia.SDL.Core works when compiling, but has problems linking when I try to use it from ghci:
14:26:03 <Cale> Loading package Multimedia.SDL.Core ... linking ... /usr/local/lib/ghc/Multimedia.SDL.Core/pkg/Multimedia.SDL.Core.o: unknown symbol `atexit'
14:26:48 <Cale> atexit is defined okay in libc
14:26:53 <Etaoin> segphault: this might be useful: http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html
14:27:41 <segphault> Etaoin: very cool. This is what I was looking for. Thanks! =}
14:28:05 <musasabi> Evening
14:28:42 <Etaoin> segphault: you might want to familiarize yourself with functions in the Prelude. it's like ocaml's Pervasives
14:29:23 <segphault> is there an api browser for haskell, like ocaml's ocamlbrowser?
14:29:41 <musasabi> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:30:09 <Etaoin> that sounds like a good idea
14:30:23 <segphault> musasabi: thanks
14:31:06 <segphault> Etaoin: it probably wouldnt be hard to write for haskell, if you can wrap the parser and use it to extract the necessary information.
14:36:44 <Etaoin> I usually just use a web browser and the link musasabi pasted
14:37:19 <segphault> it looks like haskell is substantially slower than ocaml when it comes to string processing and math
14:37:25 <segphault> I wonder how it compares to python
14:38:18 <Etaoin> well strings are represented differently
14:38:30 <segphault> it looks like haskell treats strings as lists.
14:38:35 <Etaoin> yes
14:38:36 <segphault> which is a very interesting approach
14:38:59 <segphault> i'm not sure if I like that.
14:39:05 <shapr> it feels nice
14:39:13 <shapr> haskell is generally faster than Python
14:39:38 <segphault> I've been looking for a good middle-ground between ocaml and python, and it looks like haskell might fill that need.
14:39:50 <musasabi> segphault: in general I have found that it is easy to make any single piece of haskell code quite fast.
14:40:08 <cm> i've no idea how haskell is a middleground between those :)
14:40:09 <Etaoin> in some cases, the math stuff can go faster if you give it an explicit type signature (so that it doesn't have to produce general-case code)
14:40:10 <shapr> My priority is expressiveness alone, thus my journey from Python to Haskell.
14:40:24 <cm> but if that's a reason for you to use haskell, go ahead! :)
14:40:34 <segphault> shapr: you think haskell is more expressive than python?
14:40:52 <cm> yeah
14:40:54 <shapr> Yes, I do.
14:40:56 <Etaoin> yes
14:41:03 <segphault> wow.
14:41:17 <shapr> And I've been using Python since 1.5beta2 or so.
14:41:31 <segphault> I had accepted as an axiom, that no functional language could ever be as clear or expressive as python. I guess there is a lot more to haskell than meets the eye
14:41:36 <musasabi> haskell performance is mostly about profiling and making small changes.
14:42:17 <tuomov> some things require a lot more code to express in imperative languages
14:42:47 <shapr> segphault: I don't have time to discuss it in great detail right now, but I might have time tomorrow :-)
14:42:48 <tic> what's "expressiveness"?
14:43:06 <tuomov> being able to express things compactly and readably?
14:43:23 <tuomov> all general-purpose language are turing-complete anyway
14:43:28 <segphault> I like haskell's list comprehension syntax. thats very nice. I had to add a creepy hack to ocaml to get it to support that kind of thing.
14:43:28 <tic> ah.
14:43:55 <shapr> quick question, does everyone see the darcs logo here? http://www.scannedinavian.org/DarcsWiki/RecentChanges
14:44:02 <segphault> do any of the major haskell compilers support complete redefinition of the syntax a la camlp4?
14:44:04 <tic> I feel back-bound by Haskell's lack of keeping state as easy as in an imperative language.
14:44:35 <cm> can you use camlp4 to generate haskell?
14:44:36 <musasabi> shapr: a round logo left of darcs.
14:44:36 <shapr> tic: in my opinion, no state is an advantage.
14:44:51 <shapr> musasabi: ok, thanks... that means it does work.
14:45:05 <segphault> cm: thats a good point. I probably could.
14:45:17 <tic> shapr, so what'd you do when you want to pass along something from the command line?
14:45:31 <musasabi> segphault: well ghc supports syntax redefinition to a limited degree and sometimes cpp is used to mangle source.
14:45:37 <segphault> if you wanted to make a simple syntactic extension to haskell tho, do any haskell compilers provide a mechanism to do so?
14:45:43 <segphault> ah
14:45:45 <Cale> shapr: I do
14:46:15 <musasabi> segphault: you would write a preprocessor that would transform your dialect into standard haskell.
14:46:17 <shapr> tic: put it in a monad.
14:46:31 <tic> shapr, ... if I only understood them... ;)
14:46:58 <musasabi> segphault: as there are many tools that e.g. generate documentation from the source and they need to understand the source too.
14:47:11 <shapr> monads aren't that difficult, but I'm about to sleep, so I can't explain them right now.
14:47:11 <musasabi> tic: have you read the nomaware tutorial?
14:47:26 <musasabi> shapr: good night.
14:47:57 <musasabi> tic: and you can have global mutable variables in haskell if you really really want.
14:48:02 <shapr> g'night all...
14:48:04 * shapr disappears
14:48:10 <tuomov> monads get a bit dirty when you start needing monad transformers..
14:48:32 <tic> musasabi, nope, haven't.
14:48:39 <tic> musasabi, a mutable? oh?
14:48:51 <tic> musasabi, I know you can fake immutable globals in haskell.
14:48:55 <musasabi> tuomov: or beatifull ;)
14:49:00 <tic> musasabi, what's the URL to the nomaware tutor?
14:49:12 <segphault> I appreciate all the comments here. I was thinking about using haskell to prototype my ocaml programs, but it sounds like it might be feasible to use it as a general language.
14:49:25 <musasabi> tic: myGlobal = unsafePerformIO (newIORef initialValue)
14:49:43 <segphault> I find the absence of side-affects to be a particularly appealing feature.
14:49:54 <tic> musasabi, and then, myGlobal = "whatever" from wherever I want to?
14:50:14 <tuomov> unsafePerformIO $ readIORef
14:50:16 <musasabi> tic: writeIORef myGlobal "whatever"
14:50:27 <tuomov> or write
14:50:41 <tuomov> but it's really really ugly
14:50:49 <tic> yeah.
14:51:01 <tic> if you are to write haskell code you might as well do it right.
14:51:10 <Etaoin> wouldn't writing be really unsafe since you can't know when it will be written?
14:51:12 <musasabi> but most of the time you don't want things like that.
14:51:37 <musasabi> yes write cannot be done with unsafe.
14:51:53 <tuomov> Etaoin: well, if you e.g. write the ref at start of program in the io monad, and later only read it, it should be quite safe
14:52:01 <tuomov> but it is still ugly
14:52:20 <musasabi> tic: I would advise you to look at the nomaware tutorial when you have time, it is quite good and inspirational.
14:53:51 <tic> musasabi, url?
14:53:55 <tuomov> hmm. parametrised modules would solve this config var case more elegantly
14:54:36 <cm> bbl
14:55:22 * jadrian sugested parameterised modules once...
14:55:27 <musasabi> http://www.nomaware.com/monads/html/
14:55:30 <jadrian> but I got no answer :-|
14:56:10 <tic> musasabi, thanks
14:56:46 <tuomov> I'm not sure if you can do parametrised modules without making them first-class objects..
14:56:53 <tuomov> and it's not that simple afaik
14:58:10 <jadrian> tuomov: it wasn't something that elaborated
14:58:24 <jadrian> tuomov: http://www.haskell.org//pipermail/haskell/2004-June/014125.html
14:59:23 <tuomov> well, yeah, you can statically parametrise modules of course
14:59:28 <jadrian> I don't think that is *the* way to do it of course
14:59:31 <tuomov> but that doesn't solve the config var problem that I had in mind
14:59:49 <jadrian> why not?
15:00:20 <tuomov> you want to read them from a file and at which point that can be done, the modules have already been set up
15:00:51 <jadrian> not really
15:01:12 <jadrian> did you read the whole thing? this isn't about associating values with modules at compile time
15:02:11 <jadrian> most of it (or all of it, depending on how far you want to go) can be seen as syntatic sugar for implicit parameters
15:02:40 <jadrian> right now I deal with your problem by reading the values, the using them as implicit parameters
15:02:55 <jadrian> this would simplify the syntax a lot
15:03:17 <tuomov> but how do you instatiate the parameters from values read from a file?
15:03:27 <tuomov> (or entered by the user which is really the same thing under *nix)
15:04:14 <jadrian> do 
15:04:16 <jadrian> parameters <- getParsFromFile
15:05:01 <jadrian> return mainFunction where ?par=parameters
15:05:16 <jadrian> ...
15:05:24 <jadrian> I just get what I need from a file
15:05:35 <tuomov> ah.
15:05:38 <jadrian> then use those values as the implicit parameters
15:05:57 <jadrian> it's a pain because you have to list them in every function context
15:05:58 <tuomov> missed that part.
15:06:11 <jadrian> so what I usually do is group them in a record
15:07:15 <jadrian> then define a constant (that is implicitly parameterized) for each part of the record
15:07:24 <jadrian> now this would be much easier
15:08:01 <tuomov> I wonder what are the implications of this to the type system..
15:08:32 <jadrian> you can check the paper on implicit parameters
15:08:48 <tuomov> I've read one. It was quite awful a kludge, imho.
15:08:52 <jadrian> :)
15:08:56 <jadrian> opss brb phone
15:09:31 <Lemmih> Hey Oejet_
15:16:28 <segphault> how often do major improvements of the haskell language transpire?
15:17:08 <tuomov> I haven't been around so long to be able to say how often things happen, but e.g. GADTs are quite recent
15:17:26 <musasabi> segphault: well each major version has something new usually ;)
15:17:41 <segphault> how much time generally elapses between major versions?
15:17:53 * musasabi would like a haskell2 standard more than Yet Another Language Feature
15:18:10 <segphault> is that likely to happen any time in the near future?
15:18:13 <Oejet_> Hello, Lemmih.
15:23:23 <musasabi> segphault: well people are generally more interested in making the language better than standards.
15:27:36 <segphault> how do you define a new operator in haskell?
15:28:40 <tuomov> just like a function
15:29:08 <tuomov> it will know to infix it based on that it uses operator characters
15:29:12 <Lemmih> jadrian == Adrian Hey?
15:29:20 <tuomov> x <+> y = x + y
15:29:26 <tuomov> or something like that
15:29:36 <segphault> hm
15:30:41 <tuomov> if you want to change precendence and stuff, you need some more
15:31:06 <segphault> thats a lot like ocaml.
15:31:23 <segphault> in ocaml you do something like: let (+) x y = x + y
15:32:00 <tuomov> yeah, (<+>) would work too
15:32:18 <tuomov> the name of the operator is <+> above
15:33:31 <segphault> oh. its not a redefinition of addition. I see.
15:35:22 <segphault> I generally like having my own operators for things like mapping and filtering, but it looks like not using operators makes more sense syntactically in haskell because you can reduce parens with $
15:35:51 <tuomov> $ is nice, although at first I thought it very confusing..
15:36:51 <segphault> It took me a few minutes to figure out how it was different from composition
15:37:15 <jadrian> back
15:37:32 <jadrian> Lemmih: not really...
15:37:51 <Lemmih> You can also use 'normal' functions as infix operators with `'s. Like: show `map` [1..10]
15:37:57 <jadrian> Lemmih: sorry
15:38:56 <segphault> I noticed that. That will really cut down on the number of anonymous functions I need to write for map/filter operations
15:39:05 <segphault> I can cheat and infix a function and then use application
15:39:21 <dash> yeah, $ is the same as parens
15:39:26 <gui> hey there
15:39:32 <Lemmih> Hey gui.
15:39:35 <dash> composition is a way to avoid writing lambdas :)
15:39:37 <gui> :-)
15:40:41 <gui> how can I make "instance A String where ..."
15:40:57 <musasabi> uhm, you don't
15:40:58 <gui> because String is a type synonym, he won't let me
15:40:59 <jadrian> dash: may be hard in some instances due to the order of the arguments though ;)
15:41:06 <musasabi> gui: string is a type not a type class.
15:41:17 <dash> jadrian: well hey that's what 'flip' is for ;D
15:41:32 <Cale> musasabi: he wants to make String an instance of the class A
15:41:48 <musasabi> Cale: noticed, a little bit slow this time of the night.
15:41:58 <gui> eh eh eh 
15:41:59 <musasabi> gui: there is no really good solution. 
15:42:03 <gui> argh
15:42:12 <gui> i was afraid you would say that
15:42:23 <gui> because he won't let me do [Char] either
15:42:23 <musasabi> The standard library does with defining a member function to the type class for lists separately.
15:43:53 <jadrian> dash: that would only work for binary functions
15:43:59 <dash> jadrian: Yes.
15:44:55 <jadrian> is there any argument against having: f _ b c   <=> \a -> f a b c 
15:45:09 <gui> musasabi: because i don't want to treat [Char] and [anything else] the same way...
15:45:45 <musasabi> gui: yes, I know the problem.
15:46:20 <musasabi> you can hope for the best with overlapping instances, but I don't remember whether it is enough.
15:46:38 <jadrian> gui, musasabi: it's funny that the std libs face the same problem
15:46:44 <musasabi> gui: Show solves the problem with the list approach.
15:46:48 <jadrian> exactly
15:46:55 <jadrian> that's what I was thinking about
15:47:46 <gui> where can i find that particular piece of code, then? std prelude?
15:48:01 * gui goes there
15:48:05 <jadrian> yeap
15:48:27 <jadrian> eventually List library... not sure where the definition is
15:50:19 <TheHunter> jadrian: What would g (f _ b c) mean then? I think you need additional brackets if you want to do something like this.
15:50:54 <jadrian> TheHunter: g (\a -> f a b c)
15:51:24 <tuomov> yeah, _ would only work if you had parantheses around function arguments
15:51:29 <tuomov> otherwise it is ambiguous
15:51:45 <jadrian> ?why?
15:51:51 <tuomov> f _ y x =? (\z -> f z y) x
15:51:51 <tuomov>         =? (\z -> (f z y) x)
15:55:50 <jadrian> you just need a default association
15:56:11 <jadrian> don't we have that in functions too?
15:56:25 <jadrian> f a b c = ((f a) b) c
15:56:41 <jadrian> The 1st option is not what we want
15:56:54 <jadrian> f _ y x =? (\z -> f z y) x   <=>  f x y
15:57:55 <jadrian> the rule seems simple
15:58:49 <jadrian> just use the standard function assossiativity to gather the arguments of f, then "move the "_"s out"
15:59:02 <jadrian> s/assossiativity/associativity
15:59:07 <tuomov> what are the arguments of f?
15:59:14 <tuomov> we don't really know the number of arguments
15:59:45 <tuomov> f x y :: a -> b
15:59:53 <tuomov> but b could be of kind * -> *
16:00:05 <tuomov> and that's what f x y z :: a -> (b -> c) really means
16:00:22 <tuomov> but I could be mistaken on how these things work
16:00:22 <jadrian> I think you're wrong
16:00:27 <jadrian> functions have kind *
16:00:38 <jadrian> anyway I got your point
16:00:43 <tuomov> oh, well, forget the kind stuff
16:00:46 <jadrian> yeap :)
16:00:51 <tuomov> they're for different things
16:00:54 <jadrian> yes
16:01:03 <jadrian> they work at the type level
16:01:05 <jadrian> anyway
16:01:11 <jadrian> I understand what you mean
16:01:28 <jadrian> I know that  f :: a -> b -> c  <=>  f :: a -> (b -> c)
16:01:35 <jadrian> but I don't see how that makes a difference
16:01:35 <heatsink> (is kind for type inference?)
16:01:46 <tuomov> in the f(_, x, y) notation we know what are the arguments to f
16:02:04 <jadrian> that wouldn't work
16:02:28 <jadrian> you are applying f to a truple
16:02:32 <jadrian> triple
16:02:47 <jadrian> (that was a cross of a triple with a tuple :))
16:02:49 <tuomov> no, this is not haskell notation
16:03:03 <jadrian> oh
16:04:18 <heatsink> tuomov: so if f(_, x, y) is correctly typed, then is f(_, x) incorrectly typed? IOW is partial application still allowed?
16:04:53 <tuomov> well, you could allow leaving out parameters in which case it would be same as setting them to _
16:05:58 <jadrian> tuomov: I'm not following you...
16:06:09 <heatsink> ok
16:06:22 <jadrian> tuomov: can you give me an example of a function with that f _ a b notation that would be ambiguous?
16:06:40 <tuomov> wait a moment
16:07:22 <jadrian> if you have   f :: a1 -> a2 -> ... -> an 
16:07:27 <tuomov> Here we emphasize that f is a function of two parameters that retuns a function
16:07:29 <tuomov> f :: a -> b -> (a -> b)
16:07:29 <tuomov> f _ x y = f y x :: a -> b 
16:07:40 <tuomov> But g is a function of three parameters that retuns a value
16:07:43 <tuomov> g :: a -> b -> a -> b
16:07:44 <tuomov> g _ x y = \z -> g z x y :: a -> b
16:08:05 <tuomov> Both make sense
16:08:38 <jadrian> ...
16:08:42 <jadrian> no they wouldn't
16:08:51 <jadrian> what happens if you do
16:09:01 <jadrian> f x1 x2 x3
16:09:46 <jadrian> (you'd get a type error)
16:10:05 <jadrian> f _ x y  would be parsed as 
16:10:24 <jadrian> \z -> f z x y
16:10:32 <jadrian> which doesn't typecheck
16:10:51 <tuomov> yes it does
16:11:16 <jadrian> oh yes it does :)
16:11:32 <tuomov> maybe I can think of a clearer example..
16:11:41 <jadrian> so it would be fine
16:11:50 <jadrian> I think I understand your point
16:12:00 <jadrian> but I don't think it's an issue
16:12:26 * heatsink thinks this could be done with TH
16:12:27 <jadrian> just like with function application you just have to define parsing rules and stick to them
16:15:14 <jadrian> f _ x _ y  <-- reads, f applied to the 1st argument of lambda, then applied to x, then to the 2nd argument of lambda, then to y
16:15:22 <jadrian> I don't see how that can be ambiguous
16:15:31 <jadrian> _ <- just stands for a lambda argument
16:15:32 <arjanb> i think  f _ x y  meaning something different than  (f _ x) y  can be confusing
16:16:06 <jadrian> good point
16:16:21 <dash> that would  confuse _me_ :)
16:16:23 <jadrian> I have no argument for that
16:16:33 <jadrian> thanks for killing my idea
16:16:36 <jadrian> I was doing so well
16:16:42 <jadrian> :)
16:18:08 <arjanb> in languages with parentheses in functions calls it's a great alternative to currying
16:18:23 <jadrian> yeap
16:18:54 <jadrian> I still think it's not a terrible idea
16:19:18 <jadrian> for instance
16:19:41 <dons> moin
16:20:10 <jadrian> (f x1 _ x2 _ x3 x4) a b   seems quite easy to ready
16:20:14 <jadrian> maybe easier than
16:20:21 <tuomov> f :: Int -> [List a] -> a
16:20:21 <tuomov> f _ varlist x           -- requires g _ x y == (g _ x) y to make sense  
16:20:21 <tuomov> f _ funclist y =?       -- But here the other interpretation would make
16:20:21 <tuomov>                         -- sense for consistency.
16:20:37 <jadrian> (\a b -> f x1 a x2 b x3 x4) a b
16:20:43 <jadrian> (f x1 _ x2 _ x3 x4) a b
16:20:51 <jadrian> wait to close...
16:20:54 <jadrian> ---
16:20:56 <jadrian> (f x1 _ x2 _ x3 x4) a b
16:20:56 <tuomov> hmm.. scatch that extra List.
16:20:58 <jadrian> ---
16:21:02 <jadrian> (\a b -> f x1 a x2 b x3 x4) a b
16:21:27 <jadrian> I think the 1st notation is easier to read, just place the "arguments" in the spaces
16:21:51 <jadrian> but yeah it can be confusing... since it's not that consistent with std haskell notation
16:22:57 <tuomov> and what would g x y _ w v mean?
16:23:26 <jadrian> tumm: reading your example... 
16:23:50 <jadrian> f _ varlist x  ---->  \z -> f z varlist x 
16:23:59 <jadrian> doesn't typecheck
16:24:14 <jadrian> so yeah it needed the (), doesn't have them, it's wrong
16:25:03 <jadrian> f _ funclist y   ----> \z -> f z funclist y     (how is it different?)
16:25:31 <jadrian> if funclist is a function it also doesn't typecheck...
16:25:50 <jadrian> f z :: [a] -> a
16:26:19 <ibid> f _ varlist x means f y varlist x, as lon as y does not appear in the function body
16:26:34 <arjanb> maybe one can get used to these significant parentheses, sectioning looks odd at first too
16:26:36 <ibid> i think you are looking at it way too complicatedly
16:26:41 <heatsink> How do I find out which ghc packages are in my system?
16:27:39 <jadrian> arjanb: I honestly can't say it's a great idea, I have doubts about the parentheses thing too...
16:27:45 <heatsink> ah, ghc-pkg --list-packages
16:28:05 <ibid> +g
16:29:13 <jadrian> arjanb: but on the other hand, it seems easier to read then the respective trivial lambda functions
16:29:17 <heatsink> When I import Language.Haskell.THSyntax, my program won't link
16:29:56 <heatsink> Main.o: In function `__stginit_Main_': undefined reference to `__stginit_LanguageziHaskellziTHSyntax_'
16:30:38 <heatsink> Do I need to add something to the command line, aside from -fth, to use template haskell?
16:30:40 <dons> maybe you need -package template-haskell ?
16:30:49 <dons> depending on which ghc you're using
16:30:58 <heatsink> that's not in the list of packages. I'll try it.
16:31:14 <heatsink> unknown package name
16:31:30 <heatsink> It's ghc 6.2
16:31:33 <dons> you must be using ghc < 6.3
16:31:52 <jadrian> 6.3?
16:31:59 <jadrian> is there a 6.3?
16:32:06 <dons> how about -package haskell-src
16:32:25 <heatsink> Ah, that works. Thanks. :)
16:32:26 <jadrian> brb
16:32:31 <dons> jadrian: odd minor numbers indicate cvs only versions
16:33:02 <dons> heatsink: you can work out the relevant package with grep 'MyziSym" lib/ghc-6.2.x/*
16:33:13 <dons> $ grep LanguageziHaskellziTHSyntax *
16:33:14 <dons> Binary file HShaskell-src.o matches
16:33:28 <jadrian> dons: right, I seemed to remember having 6.1... guess I'm mistaken then
16:33:31 <heatsink> oh, alright
16:33:34 <jadrian> brb
16:33:49 <dons> 6.0.1 or 6.2.1 maybe
16:35:29 <tuomov> Oh well. lambda also requires parentheses to appear around it, so maybe it could be taken that expressions with _ must be parsed to end of the containing block
16:36:27 <tuomov> and if there are too many parameters to fit the signature of the function with _:s instantiated, it's an error
16:37:07 <ibid> functions with _'s are nothing special
16:37:37 <tuomov> we were talking of other kind of _ than the current haskell usage
16:37:54 <tuomov> f _ x =\z -> f z x
16:44:02 <ibid> ahh
16:44:03 <ibid> ok
16:44:14 <ibid> that makes little sense :)
16:48:49 <tuomov> actually, it makes a lot of sense this way. I don't know why I'd thought it couldn't work before.
16:49:02 <jadrian> :)
16:49:31 <tuomov> maybe I just wanted to use it in too many ways
16:51:13 <tuomov> all you do is when you encounter <beginning of block>... _ ..., you transform it as <beginning of block>\newvar -> ... newvar ...
16:51:44 <tuomov> and the rules for lambda apply
16:51:45 <arjanb> some practical experience with this would be useful..
16:51:48 <jadrian> yeap, I think it's easy to parse
16:53:06 <heatsink> Hmm, _ is a pattern, not a variable
16:53:20 <heatsink> Maybe it can't be done without modifying the parser
16:54:27 <tuomov> of course it can't
16:55:33 <jadrian> I thought about making a preprocessor for it
16:55:46 <jadrian> that and the module initialization thing
16:56:18 <tuomov> you require explicit type sigs for module parameters?
16:56:36 * desrt[4Curry] hugs shapr 
16:57:04 <desrt> wow.  i haven't been on irc since tuesday night.  freaky.
16:57:32 <jadrian> tuomov: not really... why?
16:58:14 <tuomov> I was thinking it might be necessary, but I've forgotten why exactly and I'm getting too sleepy..
16:59:01 <jadrian> tuomov: well pre-processing would be moving the implicit parameters from the "module context" to the context of the functions in module 
16:59:52 <jadrian> since those parameters don't need to be explicitly typed I don't see why the module ones would
17:01:20 <tuomov> hmm.. I think I'm just trying to achieve too much again ;)
17:01:33 <jadrian> :)
17:11:09 <TheHunter> jadrian: oh, sorry for commenting on your _ thing and not explaining my point.
17:11:18 <TheHunter> anyway, g'night, you all
17:13:52 <heatsink> ghci said "Urk!"
17:14:15 <heatsink> Urk! Inventing strangely-kinded void TyCon:
17:14:15 <heatsink>     ZCt {- tc aXw -}
17:14:15 <heatsink>     (* -> *) -> * -> *
17:16:20 <stepcut> haha
17:19:26 <heatsink> There should be an elegant way to convert a maybe to a list, but I can't figure out what that would be. Nothing == mzero == [] .... Just x == return x == [x]
17:19:34 * heatsink uses a case statement
17:21:03 <stepcut> @type maybeToList
17:21:04 <lambdabot> bzzt
17:21:11 <stepcut> @type Data.Maybe.maybeToList
17:21:12 <lambdabot> Data.Maybe.maybeToList :: forall a. Maybe a -> [a]
17:21:37 <heatsink> thx
17:52:19 <heatsink> I got a kludgey version of tuomov's propsal working with template haskell
17:52:34 <heatsink> main = do print $ $(lfy [|someMath  l  3.3  l  6.6|])  2.2  4.4
17:53:02 <heatsink> the "l" gets converted to a lambda variable
17:53:26 <heatsink> so it prints the same thing as (someMath 2.2 3.3 4.4 6.6)
17:54:50 <heatsink> Source --> http://www.rafb.net/paste/results/2VZ8qp86.html
17:57:47 <heatsink> erm, I mean jadrian's proposal
18:00:54 <jadrian> :)
18:01:04 <jadrian> I wonder why is there a Data.Maybe.isJust but not a Data.Either.isRight :-|
18:02:03 <heatsink> isRight = not . isLeft
18:02:15 <jadrian> heatsink: that looks nice
18:02:25 <jadrian> hmm is there a isLeft...
18:02:30 <heatsink> no :)
18:02:34 <jadrian> ah
18:30:11 <Lemmih> @index sleep
18:30:11 <lambdabot> System.Posix,System.Posix.Unistd
18:32:03 <dons> @type let now = 0 in System.Posix.sleep now
18:32:04 <lambdabot> let now = 0 in System.Posix.sleep now :: IO Int
18:34:44 * Lemmih wonders how many half done SDL binding there already is for Haskell.
18:39:32 <Cale> http://homepages.nildram.co.uk/~ahey/HLibs/ seems to work well apart from the fact that it doesn't seem to play nicely with ghci
18:42:16 <Lemmih> That library doesn't use any kind of marshalling tools and it's published under GPL. /-:
18:42:30 <segphault> does haskell have syntax for logical short-circuiting? (I think the equivelant in c would be the "? :" operators)
18:43:39 <Cale> the haskell equivalent of the C ternary operator is just if .. then .. else ..
18:44:08 <Cale> logical operators are of course short circuited by default.
18:44:28 <segphault> ah
18:44:36 <dons> lazy by default
18:46:56 <segphault> types and classes in haskell are very different from what i'm used to. Doesnt seem at all intuitive.
18:47:18 <dash> what are you used to?
18:47:36 <Cale> Classes aren't what they are in other languages.
18:47:37 <segphault> python, ocaml, ruby, pascal
18:47:41 <dash> well, like some smart guy said, "the only intuitive interface is the nipple"
18:47:50 <segphault> lol. very true
18:48:05 <Lemmih> Aren't types in haskell pretty much the same as in Ocaml?
18:48:18 <dash> "classes" means something totally different in haskell. coming over from python, it got me a bit confused too :)
18:48:32 <dons> you mean "type classes" though
18:48:39 <segphault> haskell types are similar to ocaml types, but this subtyping stuff is funky
18:48:44 <dash> but that's no big surprise, "type" and even "function" mean different things here :)
18:50:56 <dons> Haskell comes out of 80 years (could argue more) of research, so it is not surprising that it has its own lexicon.
18:51:15 <dash> well, all languages have their own lexicon, to one degree or another
18:51:31 <esap> I think type classes actually mean what other languages have *intended* to do, but failed :-)
18:51:38 <dons> other languages essentially borrow, in a corrupted form, defns from the Haskell history (e.g. `type' in C)
18:51:53 <dash> a lot of heated debate and bad code have come from assuming that things with the same name in two different languages implement the same idea
18:52:06 <dons> yeah. certainly. very silly
18:52:47 <dons> just look at the semantics. oh .. wait. there is no semantics for the large majority of langs
18:52:55 <dash> dons: sure there is
18:53:00 <segphault> most of the imperative oo languages that I know have very similar concepts of what classes and methods are. functional languages seem to be a lot more unique
18:53:18 <dash> well, the biggest and worst case is the word "object" :D
18:53:53 <segphault> I really wish there was a consistent vernacular for programming concepts
18:54:41 <esap> I think there is, though to see it you need to understand very many different concepts and see beyond the differences and hacks.
18:55:04 <dash> well, it _is_ possible to discuss things across languages
18:55:27 <dons> very much so. the fundamentals are all there. 
18:55:34 <dash> but to do so effectively requires all parties being aware that some terms are more ambiguous than others :)
18:55:55 <esap> Understanding a concept requires understanding of how vague it is intended to be.
18:56:12 <segphault> a friend of mine was a c++ programmer, and he started learning python. he refused to acknowledge python classes as classes because there were really "hashes with syntactic sugar"
18:56:21 <dash> snee hee
18:56:33 <dash> right. and C++ classes are what, exactly? ;D
18:56:45 <dash> structs with icing
18:56:48 <segphault> data structs with virtual function table pointers I think, but I wouldnt know
18:57:18 * dash throws up his hands in frustration and yells "It's all just zeroes and ones! raaar!"
18:57:22 <esap> dash, segphault: I think the difference is run-time vs. compile-time thinking. Python is very much dynamic (run-time) in its concepts, whereas C++ has very strong tradition of compile-time concepts.
18:59:16 <esap> In general, you need to understand both.
18:59:35 <esap> ... and their connection.
19:02:04 <esap> C++ classes are not that far removed from type classes, really. They seem very different, but the basic idea behind both is the same.
19:06:18 * jadrian misses subtyping...
19:06:25 <esap> The thing is, C++ classes map to three or four different concepts in Haskell.
19:06:37 * esap has subtyping.
19:06:43 <jadrian> you do?
19:06:58 <jadrian> can you lend me some :)
19:06:59 <esap> type classes have subtypes.
19:07:21 <esap> class (Monad m) => MyMonad m where { ... }   is subtyping.
19:07:23 <jadrian> no, they have subclasses
19:07:49 <jadrian> that's subclassing
19:07:58 <jadrian> a MyMonad is a Monad
19:08:27 <esap> I think subclassing would be the one in instance declarations.
19:08:47 <esap> instance (Monad m) => MyMonad Z where { ... } is subclassing, I think.
19:10:48 * esap means instance (Monad m) => MyMonad (Z m) where ...
19:11:45 <jadrian> oh
19:11:55 <jadrian> ... subtyping is a partial order on types, right?
19:12:09 <esap> yes.
19:12:58 <esap> consider the types (Monad m) => m a  and (MyMonad m) => m a
19:13:19 <jadrian> yes
19:13:45 <jadrian> now give me two different types which are related 
19:13:52 <jadrian> type1 < type2
19:14:11 <jadrian> every function on type2 should work on type1
19:14:38 <jadrian> that's how all the definitions of subtyping I've seen work
19:15:32 <esap> The definition of subtyping is based on *operations* on the type, not anything intrinsic on the types themselves.
19:15:42 <jadrian> yes
19:16:02 <jadrian> wait
19:16:05 <esap> So you don't attach subtyping directly to types either. It comes from the definition of *behaviour* of those types.
19:16:06 <jadrian> define operations
19:16:08 <esap> Type classes do that.
19:17:14 <esap> The reason normal treatment of subtyping talks about types is because they usually only have subtyping for existential types.
19:18:11 <esap> Which, in Haskell, is written something like: data X a = (Monad m) => X (m a)
19:18:20 <jadrian> my concept of subtyping come from algebraic specification
19:18:53 * esap means data X a = forall m . (Monad m) => X (m a)
19:19:29 <jadrian> without subtyping all you have is a pair (S,Sigma) of sorts and operations defined on those sorts
19:19:49 <jadrian> this would map into Haskell as types and functions
19:20:09 <jadrian> with subtyping you have ((S,<), Sigma)
19:20:33 <esap> Right, but there you don't consider abstraction at all.
19:20:56 <jadrian> in which sense?
19:21:14 <esap> Are your sorts abstract or concrete?
19:21:27 <jadrian> abstract
19:22:03 <jadrian> you can have models for those algebras
19:22:05 <esap> ok, but then you shouldn't talk about types, types are concrete.
19:22:15 <jadrian> fs/algebras/signatures
19:22:19 <jadrian> exactly
19:22:49 <jadrian> types and functions are one possible Sigma-algebra
19:23:08 <jadrian> for the signature (S,Sigma)
19:23:32 <esap> Ok, I'm somewhat confused about the concept of abstract you mean.
19:23:46 <jadrian> maybe I didn't understand...
19:23:53 <jadrian> what is your concept of abstract?
19:25:11 <esap> Well there are two: One is like it's used in the concept of "abstract data type" and another is like it's used in "datatypes are abstract".
19:25:32 <esap> big difference.
19:25:55 <jadrian> 1st one
19:26:33 <esap> ok, then S is a set of type *names* or type variables or whatever, not a set of types.
19:27:08 <jadrian> yes
19:27:32 <jadrian> I used the term "sorts"
19:27:41 <jadrian> for that concept
19:27:54 <esap> ok, so it maps to type classes, e.g. class X a b where ... defines a relationship between type variables a and b.
19:28:26 <jadrian> does it
19:28:35 <esap> yes.
19:28:45 <jadrian> doesn't it map to types?
19:29:12 <jadrian> ok so we have sorts and operations
19:29:38 <esap> Note that the relationship that the type class defines is about the *operations* part.
19:29:55 <esap> not about the type part.
19:30:01 <jadrian> right
19:30:14 <esap> but that's what subtyping is also about.
19:30:25 <jadrian> but!
19:30:33 <jadrian> the partial order is on S (sorts)
19:30:45 <jadrian> so if you map sorts to type classes
19:30:58 <jadrian> you are maping that partial order over classes
19:31:01 <esap> ok, not quite
19:31:01 <jadrian> not types
19:31:55 <esap> It's not over classes.
19:32:31 <esap> Because classes represent relationships.
19:32:45 <esap> it's over the type variables, not over concrete types.
19:34:14 <jadrian> that doesn't make much sense... (at least according to the concepts I'm used to...)
19:34:36 <jadrian> when you have a signature Sigma = (S,Op) 
19:35:01 <esap> Do you consider implementations of a signature?
19:35:33 <jadrian> you can define Sigma-Terms over sets of variables
19:36:07 <esap> what is an implementation of a single type variable?
19:36:41 <jadrian> implementations = interpretations right?
19:36:49 <jadrian> that is, the mapping...
19:36:54 <jadrian> right?
19:37:03 <esap> yes, but there is an implementation for both the type variables and the operations.
19:37:40 <jadrian> you're right...
19:37:51 <jadrian> I was messing things up now
19:37:52 <esap> Types are implementations of the type variables and sigma-terms are implementations of the operations (If I understood you correctly)
19:38:54 <jadrian> no not really, either that or I don't know what you mean by implementations
19:39:21 <esap> if you have a type class, say Monad, then each instance declaration is an implementation of the Monad type class.
19:39:38 <jadrian> sigma-terms are just the language you generate with operations and sorts
19:40:15 <jadrian> by defining a mapping of sorts and operations in some algebra
19:40:17 <esap> oh, user-side implementation?
19:40:26 <jadrian> you can extend that map for the sigma-terms too
19:41:16 <jadrian> a simple example would be mapping a signature into some mathematical structure (sorts->types, operations-> functions)
19:42:04 <esap> ok, I think I'm talking about different side of the signature. Signature is an interface between two things (I call them 'client' and 'server' :-)
19:42:32 <jadrian> if S = {INT} and Op = {s:INT->INT, zero:->0} 
19:42:48 <esap> Such that 'client' side is the one who uses the operations of the signature, and server side is who implements the operations of the signature.
19:43:40 <jadrian> yes I understand
19:43:56 <jadrian> to me signature is just abstract nonsense
19:44:13 <jadrian> then I can have propreties for the signature
19:44:16 <jadrian> (specifications)
19:44:19 <esap> jadrian: yes I agree. The type classes actually express signatures.
19:44:31 <jadrian> which define propreties 
19:45:09 <jadrian> and then I can have implementations of those specifications, which are the spec-algebras
19:45:26 <jadrian> sigma algebras would be similar (but without the specification part)
19:45:35 <esap> class IntegerLike i where { succ :: i -> i ; zero :: i }
19:46:07 <jadrian> right
19:46:56 <jadrian> I was using this concepts because they provide one definition of subtyping
19:47:27 <esap> it's ok, the same concept is used with type classes.
19:47:36 <jadrian> so now the operations are the class operations
19:47:40 <jadrian> and yeap
19:47:42 <jadrian> you're right
19:47:54 <jadrian> the sorts are mapped to the type vars
19:48:29 <jadrian> and that's where the partial order relation is defined
19:48:37 <esap> right.
19:49:04 <jadrian> I still don't like it though...
19:49:12 <esap> why?
19:49:37 <jadrian> because type variables just make sense in the definition of the class
19:49:57 <jadrian> what is the difference between defining a partial order among the type variables
19:50:11 <jadrian> and defining a partial order among the classes?
19:50:21 <jadrian> or in other words
19:50:48 <jadrian> if I ask you for 2 related elements of the partial order
19:50:53 <jadrian> what would you give me?
19:51:07 <jadrian> in Haskell, considering the std classes
19:51:15 <jadrian> can you give me 2 elems of the partial order?
19:52:09 <esap> (Monad m) => m Integer  and (MonadPlus m) => m Integer
19:52:41 <jadrian> what is the difference between that and
19:52:47 <jadrian> Monad and MonadPlus
19:53:38 <esap> Monad is the relationship m --> m. Consider multi-parameter type classes.
19:54:21 <jadrian> oh
19:54:22 <esap> class Adjunction f g where { ... }. Now, Adjunction is a relationship between f and g.
19:54:33 <jadrian> but that is a different thing
19:55:04 <esap> Right, the class itself is the operations part of the signature, and the type variables are the sort part.'
19:56:07 <esap> The relationship defines the operations.
19:57:06 <jadrian> so the partial order is now in the type variables 
19:57:12 <esap> yes.
19:57:16 <jadrian> and when I asked you for two elements
19:57:18 <esap> it's not between classes.
19:57:19 <jadrian> related ones
19:57:30 <jadrian> you gave me (Monad m) => m Integer  and (MonadPlus m) => m Integer
19:57:38 <jadrian> this are not type variables
19:57:45 <jadrian> these*
19:57:59 <jadrian> and that's why I don't like it
19:58:20 <jadrian> these type variables only make sense with their respective operations
19:58:26 <esap> The reason is that m has kind * -> *. It's a functor really there. 'm Integer' is an abstract type.
19:58:53 <jadrian> ok so the kind of m is the arity of an operation
19:59:00 <esap> And (Monad m) => part defines that it has to satisfy the signature
19:59:14 <jadrian> op --- maps to ---> class
19:59:27 <jadrian> op arity -------> class kind
19:59:30 <bourbaki> moin
19:59:52 <jadrian> so for that to makes sense 
19:59:58 <jadrian> there is only one sort
19:59:58 <esap> jadrian: I think yes, though I'm not exactly sure what you mean with arity (I think I know at least two different concepts called arity)
20:00:28 <jadrian> esap: I probably mean rank actually
20:00:56 <esap> ok
20:02:28 <bourbaki> rank of a matrix?
20:02:45 <jadrian> Now I'm getting confused...
20:03:05 <jadrian> because seems to me like according to that definition
20:03:08 <esap> bourbaki: no, not related to matrix, we're talking about signatures and type classes.
20:03:20 <jadrian> there would be only one sort
20:03:24 <jadrian> {*}
20:03:56 <jadrian> a simple (easier) example 1st
20:04:47 <jadrian> consider S = {INT} and Op = {s:INT->INT, zero:->INT}   Sigma=(S,OP)
20:04:59 <jadrian> a possible interpretation is
20:05:34 <jadrian> A = |N   Aop = { +1 : |N -> |N, 0:->|N}
20:05:43 <jadrian> and the obvious evaluation function
20:05:56 <jadrian> so it would map    zero --> 0
20:06:13 <jadrian> and   s(zero) ---> 0+1 = 1
20:06:22 <esap> right.
20:06:33 <jadrian> I only have one sort there
20:06:48 <jadrian> the interpretation is a set ( |N )
20:06:55 <jadrian> which contains many elements
20:07:09 <jadrian> to which I can apply the mapping of s
20:07:11 <jadrian> ...
20:07:24 <jadrian> so in our example seems to me that
20:07:58 <jadrian> if Monad is the mapping of an operation
20:08:11 <jadrian> then it's sort should be  * -> *
20:08:25 <jadrian> s/sort/rank
20:08:47 <jadrian> so there is only one sort involved  --->  *
20:09:08 <jadrian> and as "elements" of  * you have types and type variables
20:09:54 <esap> With your notation, Monad could be defined as:   S = { M }  Op = { (>>=) : m(a) x (a -> m(b)) -> m(b) ; return : a -> m(a) }, Monad = (S,Op)
20:10:29 <esap> s/M/m/
20:10:49 <jadrian> nope
20:11:01 <esap> something like that I suppose.
20:11:29 <jadrian> problem is that you need to define the operations over sorts
20:11:51 <jadrian> if you have sort  S={a,b,c}
20:11:58 <jadrian> then you can have for ops
20:12:33 <jadrian> OP = {F : a b -> c,  G : -> a,  R : a a a -> a}
20:12:36 <jadrian> but
20:12:53 <jadrian> OP = { F :  r y -> a}
20:12:55 <jadrian> makes no sense
20:13:10 <esap> what do you mean a b -> c?
20:13:40 <jadrian> I'm not using haskell notation
20:13:58 <esap> I'm wondering whether your signatures have * -> * things at all
20:14:04 <stepcut> ls
20:14:07 <stepcut> ack
20:14:14 <stepcut> stupid focus swaping
20:14:45 <jadrian> esap: no signatures have nothing, like I said, they are abstract nonsense
20:14:53 <jadrian> esap: then you can map them to stuff
20:15:05 <esap> jadrian: type variables of kind * -> * are abstract as well
20:15:27 <jadrian> esap: and I was using them because it's one of the ways to get a formal definiton if subtyping
20:15:33 <jadrian> esap: yes of course
20:15:54 <bourbaki> nighto
20:16:24 <jadrian> esap: signatures only give you a set of sorts, the operations  and you can define terms over those ops, that's it
20:16:38 <jadrian> esap: with subtyping you get that partial order
20:16:45 <esap> ok, no collections of sorts?
20:17:00 <jadrian> esap: "set of sorts"
20:17:12 <esap> eh, one :-)
20:17:16 <jadrian> esap: my interpretation would be
20:17:41 <jadrian> Sorts ---> types 
20:17:46 <jadrian> operations functions
20:18:23 <jadrian> op : a1 a2 an-1 -> an    --->    [[op]] :: a1 -> a2 -> ... -> an
20:18:23 <esap> but signatures only describe interfaces, not implementations.
20:18:26 <jadrian> yes
20:18:54 <jadrian> but why do you need the implementations?
20:19:02 <jadrian> for defining subtyping...
20:19:03 <esap> I don't need, but types are implementations.
20:19:13 <esap> type variables are not
20:19:52 <jadrian> I don't see where to fit that concept, in here...
20:20:18 <jadrian> I do have the concept of Variables of a certain sort
20:20:28 <jadrian> but it's lost on the algebra side
20:20:34 <jadrian> opssss
20:20:41 <jadrian> sorry got to go!
20:20:46 <esap> ok
20:20:49 <jadrian> fast!
20:20:52 <esap> see you later.
20:20:53 <jadrian> see ya!
20:24:31 <segphault> in c, you can overload functions by making different versions with arguments of different types.... is this possible in haskell?
20:25:18 <maihem> segphault, yes, using classes =D, but you do not have the same freedom as C++
20:25:41 <segphault> is there a good, simple, trivial example of this somewhere?
20:25:57 <Etaoin> show?
20:26:23 <segphault> where can I see the implementation of show?
20:27:03 <Lemmih> class Show a where show :: a -> String -- simplified version.
20:28:15 <maihem> also just a function itself can be like a C++ template function, almost automatically.
20:30:05 <maihem> segphault, a class like Show is a predicate. anything that satisfies the predicate has its own implementation "instance Show MyType where show MyCotr1 = "MyCtor1" ...
20:33:17 <maihem> then any function blah :: Show a => a -> String can use the show function on it: blah x = show x, the predicate Show a says what operations this function will use so it allows you to use any instance of that. Overloading is just a hack in C++ because template functions can be unpalatable.
20:34:45 <segphault> I'm liking this. It reminds me of python.
20:35:48 <maihem> I don't know if you can have a function Pred a b => a -> b, and have an instance of pred where b is a Foo -> Bar, that would be cool :)
20:36:08 <Etaoin> heh. I'm curious. how is it like python?
20:37:11 <segphault> in python, you can do x.blah() on any instance whose class defines a blah method.
20:37:45 <segphault> if i'm understanding this correctly, in haskell you can do 'blah x' on any instance that... uh... inherits blah. I think.
20:38:45 <maihem> segphault, think of classes as a predicate like: doesaddition(a,b). A function that tries to add its two arguments requires that they satisfy the predicate doesaddition
20:39:51 <maihem> so you would have a class DoesAddition a b where whatever (this gets a bit more complex). then you can say instance Int Int where ...
20:40:05 <maihem> that says that you can add an Int to an Int
20:41:07 <maihem> so the function that requires its arguments to satisfy that predicate now "JustWorks" on two Ints
20:41:16 <darkt3ch> ay, i been looking for a free shell for a while now anyone got any recommendations? tried a few but i need one with gcc and access to internet
20:41:45 <maihem> A free shell in this day and age? :/
20:41:56 <maihem> savannah?
20:42:41 <segphault> darkt3ch: if you just need it for programming, why not try a live cd linux distribution?
20:43:04 <maihem> doing some |-|4x0rr1n9 ?
20:53:18 <darkt3ch> nahh cause i need it to run linux apps from... which require internet
21:24:04 <segphault> hehehe.... [1..1/0]
21:24:11 <Lemmih> (-:
21:28:41 <Cale> you can also just do [1..], but the 1/0 coerces the type nicely :)
21:33:58 <dons> :t 1/0
21:34:01 <dons> @type 1/0
21:34:02 <lambdabot> 1/0 :: forall a. (Fractional a) => a
21:36:23 <dons> helps the type inference out, rather than coerce
21:42:26 <segphault> the way that haskell uses separate functions for pattern matching is kind of interesting
21:43:09 <segphault> seems like unnecessary verbosity. Is there any good reason to do it that way?
21:43:28 <dash> as opposed to what?
21:43:54 <segphault> what you folks call 'guards' ocaml calls pattern matching
21:44:13 <heatsink> guards are a particular pattern matching syntax
21:44:46 <heatsink> Haskell has guards, and patterns
21:44:57 <segphault> they both do the same things, right?
21:45:04 <heatsink> No
21:45:37 <heatsink> f x | g x == 2 = bla bla -- Can't be done with pattern matching
21:45:54 <dons> guards are just sugar for patterns
21:46:00 <heatsink> sure
21:46:15 <segphault> ok. thats what I thought.
21:46:25 <segphault> why use normal pattern matching if guards make it more concise?
21:46:26 <dons> f x | g x == 2  ==> f = \x -> case g x == 2 of True -> ... ; False -> ....
21:46:40 <dons> sometimes normal patterns are more conncise
21:46:46 <segphault> ah
21:47:14 <dons> all pattern matching desugars to case statements in haskell
21:47:45 <dons> f (_:cs) = ..  ==>> f = \x -> case x of (_:cs) -> ..
21:47:48 <dons> and so on
21:48:06 <segphault> spooky. I didnt even know haskell had a 'case' keyword
21:48:17 <dons> it's all just case and let.
21:48:33 <heatsink> dons: I seem to recall on hawiki that there is a difference between f Nothing = ... and f x = case x of {Nothing -> ...}
21:48:47 * heatsink tries to find it
21:50:24 <dons> f Nothing = ... ===> f = \x -> case x of Nothing -> ...C[C[C
21:50:36 <dons> anyway. it's in the h98 report how the desugaring works
21:51:21 <heatsink> I think it was that putting the pattern in the function definition allows the compiler to do additional optimizations
21:51:35 <heatsink> s/function definition/lhs/
21:51:57 <dons> oh, sure. there's probably heaps of tricks that can be exploited
21:57:16 <segphault> do if/then/else statements get converted into cases by the compiler?
21:57:22 <heatsink> yea
21:57:24 <dons> yep. of course
21:57:53 <dons> all haskell is just let, case, function application, lambda, literals, constructors
21:58:02 <dons> and a few extra bits like types ;)
21:58:37 <heatsink> And constructors are just functions that can't be evaluated :)
21:58:45 <dons> let does thunk allocation (i.e. laziness). case evaluates a value, and lets you inspect its structure. 
21:58:52 <dons> it's all you need
21:59:27 <dons> and constructors also have to be applied saturated.
22:00:00 <heatsink> what does that mean?
22:00:19 <dons> you can't partially apply a constructor
22:00:42 <dons> it must be 'saturated' with its arguments
22:00:43 <heatsink> So (Either 3) compiles to (\x. Either 3 x)?
22:00:54 <Etaoin> hm?
22:01:21 <dons> nope. that's a sum type. it only has one or the other args
22:01:32 <dons> your confusing the type and its constructors
22:01:42 <dons> Left 3, Right "y".
22:01:42 <heatsink> oh.. yea
22:01:47 <dons> but theree is no "Left"
22:01:56 <heatsink> >_<
22:02:32 <heatsink> Interesting.
22:02:53 <Etaoin> dons: isn't it possible to partially apply a constructor?
22:03:46 <dons> not in Haskell, afaik. provide an example
22:03:59 <dons> @type Left
22:04:01 <lambdabot> Left :: forall b a. a -> Either a b
22:04:15 <dons> :type is silly
22:04:36 <Etaoin> I just did it with ghci
22:04:47 <dons> hm. me to
22:04:59 <dons> maybe I'm thinking of the type-level
22:05:27 <dons> or, maybe there is no partially applied constructors in Core
22:07:26 <segphault> is there a way to get the last value of a list?
22:07:27 <dons> you can partially apply data constructors. h98 says so
22:07:35 <heatsink> @type tail
22:07:37 <lambdabot> tail :: forall a. [a] -> [a]
22:08:04 <dons> "partial applications of data constructors are allowed", pg16
22:08:10 <heatsink> last
22:13:12 <dons> and you can partially apply newtypes too
22:15:49 <dons> ah. got it. in STG code, GHC's backend, "all constructors and primops are saturated"
22:16:01 <heatsink> ok
22:16:10 <dons> this simplifies the operational semantics of the stg machine
22:16:30 <heatsink> so (Left, 3) does compile to (\x -> Left x, 3)
22:16:34 <dons> yep.
22:16:56 <dons> in fact they add "extra lambdas around unsaturated constructors"
22:17:17 <segphault> shouldnt this not work: [1..((1/0) - (1/0))]
22:17:33 <dons> this is from "Implementing lazy functional languages on stock hardware", SPJ
22:18:24 <heatsink> segphault: it seems to work fine
22:18:42 <segphault> heatsink: yeah, it does, but mathematically, that shouldnt be doing that... right?
22:19:01 <heatsink> mathematically, it does not exist
22:19:03 <dons> isn't it going to give an empty list?
22:19:13 <segphault> I thought it would give an empty list, but it doesnt
22:19:25 <heatsink> therefore it is neither doing that, nor not doing that... mathematically :)
22:19:33 <dons> does on my machine.
22:19:42 <dons> Prelude> [1..((1/0) - (1/0))]
22:19:43 <dons> []
22:19:49 <segphault> in hugs, on my machine, it does the same thing as: [1.0..]
22:19:57 <dons> oh. interesting...
22:20:00 <dons> not in ghci
22:20:04 <segphault> interesting
22:20:11 <heatsink> does it in hugs for me, too
22:20:17 <heatsink> and not in ghci
22:20:17 <dons> yeah.
22:20:36 <dons> nhc gives []
22:20:40 <heatsink> hugs has a couple other number bugs.
22:20:49 <dons> so does hbi
22:20:57 <dons> so hugs is 1/4 here
22:21:08 <dons> that's not good
22:21:29 <heatsink> segphault: what is returned by (decodeFloat $ fromIntegral 1/0) in hugs?
22:21:36 <dons> hmm. maybe that's a hugs-bug, in fact
22:21:50 <dons> then again, floating point is hell
22:21:51 <segphault> (./,),(-*,(,-53)
22:21:55 <heatsink> yup
22:21:58 <dons> yeah. that is a known one
22:22:20 <heatsink> (actually, the fromIntegral is superfluous)
22:22:37 <dons> lesson: get away from hugs
22:23:03 <segphault> ghci seems slower for interactive stuff
22:23:37 <dons> really? hmm. not much. they're both interpreted
22:23:45 <dons> unless you're playing tricks with static code
22:26:18 <segphault> lol. it hangs on: [1..1/0] == [1..1/0]
22:26:50 <segphault> thats really a bummer. you cant do equality checking on infinite lists
22:26:52 <dons> hangs?
22:27:12 <dons> why wouldn't it be difficult?
22:27:29 <segphault> hm?
22:27:40 <dons> I'm surprised you're surprised
22:28:04 <segphault> when you do comparisons on ranges does it check every single item in both ranges?
22:28:12 <dons> how is Eq defined for [a]
22:28:17 <heatsink> A range is a list.
22:28:35 <segphault> i'm used to ruby where a range is a high level abstraction
22:29:21 <heatsink> You could also think of it as an iterator.
22:30:26 <segphault> in ruby, because ranges are actually objects, something like: (1..100000000000000000) == (1..100000000000000000) evaluates instantly
22:31:14 <segphault> I suppose that if I wanted to, I could set up a range type like that in haskell too
22:31:56 <heatsink> I think haskell programmers do less array stuff than C or Python or Ruby programmers, so ranges are less useful
22:32:14 <segphault> thats probably the case
22:32:26 <segphault> in ruby and python, its possible to overload range accessors for all classes
22:36:13 <segphault> i'm disappointed that .. isnt a normal operator in haskell. It has behaviours for characters and numbers, but would it be possible to make it have behaviour for some arbitrary type? myvalue..myothervalue
22:36:26 <heatsink> use deriving(Enum)
22:36:32 <segphault> oh. cool.
22:36:58 <segphault> and deriving enum also lets you override how the !! operator works on it, right?
22:37:37 <heatsink> @type (!!)
22:37:38 <lambdabot> (!!) :: forall a. [a] -> Int -> a
23:48:09 <musasabi> morning
