00:01:17 <tuomov> but maybe branches would be enough..
00:01:34 <tuomov> it's no longer a tidy list, but quite close
00:02:00 <dons> I think it would be fairly simple to have an action that returns a keymap based on the result of an action
00:02:32 <dons> essentially an IO form of the `meta` op I showed earlier.
00:03:11 <tuomov> the ActStreams...
00:03:13 <dons> this is a good problem, I think
00:03:17 <dons> yep.
00:03:17 <tuomov> lots of similar layers there
00:04:05 <tuomov> infact, ActStream might be a monad..
00:04:08 <tuomov> hmm..
00:09:12 <tuomov> well, lista are monads too
00:09:40 <tuomov> but Branch is similar to IO >>= 
00:09:54 <tuomov> it's just broken into pieces
00:10:06 <dons> yep.
00:29:27 <musasabi> Why does GHC seem to use utf-8 internally?
00:29:54 <musasabi> and not export that anywhere ;)
00:30:40 <dons> there's GHC.Unicode
00:31:01 <dons> but ghc only reads and writes bytes, in the end
00:32:21 <musasabi> well it uses GHCziBase_unpackCStringUtf8zh_closure for literals
00:32:48 <dons> oh! I haven't seen that
00:32:58 * dons takes a src-dive
00:34:00 <dons> hmm. there you go. GHC.Base.unpackCStringUtf8# :: Addr# -> [Char]
00:34:18 <musasabi> yes that is the exact function/
00:34:37 <musasabi> (I am looking at Base.lhs too)
00:44:14 <Itkovian> musasabi: could you paste the hs_fltk link (google is not very cooperative)
00:44:24 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
00:44:40 <Itkovian> thx
01:17:15 * dblhelix is away: brb
02:34:55 <Itkovian>  hmm ... Fl_Widget.cc:4:26: FL/Fl_Widget.H: No such file or directory (hs_fltk) and ageorges@kweekvijver ~/downloads/hs-fltk-0.2.1 $ find . -name "Fl_Widget*"
02:34:55 <Itkovian> ./cc_src/Fl_Widget_Misc.cc
02:34:55 <Itkovian> ./cc_src/Fl_Widget.cc
02:35:08 <Itkovian> any ideas?
02:41:17 <Itkovian> nevermind
02:41:41 <Itkovian> some bloody thing dropped it in /usr/include/fltk-1.1/FL ... grmbl
02:56:43 <musasabi> Itkovian: are you using gentoo?
03:13:44 <musasabi> Itkovian: gentoo puts libraries and headers outside the default paths needing a little bit support. To make linking succeed you should use patched cabal (the patch will be integrated into the official distribution in a few days). I am currently using it on gentoo and it works fine.
03:23:10 <Itkovian> musasabi: where can I find this patch? or can I add the Extra-Lib-Dirs myself? (I think that is what the problem is now, right?
03:23:55 <Itkovian> Anyway, I can change the makefile in the cc subdir to include /usr/incluse/fltk-1.1 ...
03:25:57 <Itkovian> I removed that line (from the darcs hs_fltk repos) and I seem to be getting somewhere ... not all the way. but still
03:26:22 <Itkovian> /opt/ghc/bin/ghc cc_src/misc.s -odir dist/build/cc_src -hidir dist/build -c
03:26:22 <Itkovian> ghc-6.2: file `cc_src/misc.s' does not exist
03:26:52 <musasabi> Itkovian: see the homepage.
03:27:08 <musasabi> and pull.
03:27:34 <Itkovian> i used get to check the stuff out, should be sufficient, no?
03:28:04 <Itkovian> ok, done
03:28:18 <musasabi> now it should build fine.
03:28:19 <Itkovian> groovy!
03:28:22 <Itkovian> thx!
03:28:34 <musasabi> The cabal patch is at http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/cabal.patch
03:29:23 <musasabi> It just adds the correct -L/usr/lib/fltk-1.1 to the ghc package file.
03:29:43 <Itkovian> Maybe add something similar for -I/usr/include/fltk-1.1 ?
03:29:56 <Itkovian> it's not required right now it seems, but it would be cool, imo
03:30:15 <Itkovian> do you develop cabal?
03:30:58 <musasabi> no, Isaac (SyntaxNinja) does. I created that patch and he promised to apply it but his laptop is broken :-(
03:31:25 <musasabi> Should be only a few days before he commits it though.
03:31:42 <Itkovian> the time required to buy a new laptop ;-)
03:32:11 <musasabi> you shouldn't need to have the -I - it should work automatically.
03:32:28 <Itkovian> i saw that ...
03:33:26 <Itkovian> any ideas on how I can add packages (ghc) locally, without it needing to change ghc config files?
03:33:57 <Itkovian> I mean, right now, I'm on my own machine, where I have root access, but that need not be the case ...
03:34:56 <musasabi> Well you can do that. 
03:35:23 <musasabi> ./setup --help gives many options.
03:36:30 <musasabi> but most of the time I find myself with ghc inside my home directory so local package config files are not an issue. (you can however have them too)
03:36:40 <Itkovian> ok
03:36:46 <Itkovian> let's see if this works
03:37:29 <musasabi> ./setup configure --prefix=/foo/bar && ./setup build 
03:37:37 <musasabi> and so on.
03:41:50 <dons> Itkovian: you could use the -package-conf foo.conf flag to help ghc see extra package spec files
03:42:34 <Itkovian> ok
03:45:46 <Itkovian> no cookie
04:09:45 <Itkovian> gotta go, emergency ... ttyl
04:11:43 <musasabi> bye
04:33:36 <shapr> good morning #haskell!
04:53:25 <xkb> morning shaper
04:54:28 <xkb> eoops
04:54:30 <xkb> typo
06:47:01 <boegel> hello #haskell
06:47:19 <boegel> wolfman8k, sorry about yesterday, my internet just stopt working
06:47:29 <boegel> s/stopt/stopped
06:49:38 <Lemmih> Note to self: Database.HaskellDB.GenericConnect.genericConnect don't cache connections.
06:49:55 * dblhelix is back (gone 05:32:39)
06:52:37 <shapr> Lemmih: which ones do cache connections?
06:52:44 <shapr> my internet died last night too
06:53:29 <Lemmih> shapr: I had to implement it myself.
06:53:40 <shapr> oh, neat
06:53:50 <shapr> did you submit a patch for connection caching?
06:55:12 <Lemmih> It's not really usable for the general public. It's a part of Hemplate (I'm using its state to avoid unsafeIO).
06:55:35 <shapr> oh
06:55:36 <shapr> neat
06:55:39 <edi> hi!
06:55:43 <Lemmih> Hackage will get a real boost when I update it.
06:55:48 <shapr> hiya edi
06:57:01 <Igloo> Did someone do s/^./h/ on your dictionary?  :-)
06:57:53 <shapr> Hhat ho hou hean?
06:59:37 <delYsid> interesting, yesterday must have been the day of the dead connectivity or something, my IPv6 was offline the whole day...
07:04:15 <shapr> grußgott delYsid 
07:20:07 <boegel> delYsid, probably some huge virus or so
07:22:20 <Roey> hello all
07:22:28 <edi> hi!
07:22:32 <dblhelix> hello Roey
07:22:39 <Roey> =)
07:45:46 <Roey> hi, a little while ago I asked what the difference is between C++ and Haskell's const.
07:46:19 <wilx> Haskell has const?
07:46:23 <Roey> and I was told that with C++ you cannot guarantee that a function will not change its parameter (by calling a method of the parameter object, which happens to change the object).
07:46:26 <Igloo> They're not at all alike
07:46:32 <Roey> but you can do this in C++:
07:46:40 <Roey> ret func(object&) const;
07:47:03 <wilx> Huh.
07:47:08 <wilx> Go ask in a different channel.
07:47:09 <Roey> and that prevents func() from calling any method in the object& that was not also declared 'const;'
07:47:13 <wilx> Like #C++.
07:47:15 <Roey> I asked about it...
07:47:21 <Roey> asked here and there.
07:47:22 <wilx> Or better, learn C++ :)
07:47:26 <Roey> (actually #kde-devel)
07:47:27 <Roey> I know C++
07:47:35 <dash> wilx: i don't see how that could be better than anything ;)
07:47:35 <Roey> I'm just curious 
07:47:42 <Roey> I'm not trying to berate anything here
07:47:54 <wilx> Hmm.
07:47:57 <dash> Roey: what do you mean by "haskell's const"?
07:47:59 <Igloo> Just because they have the same name doesn't mean it is sensible to compare them
07:48:05 <Igloo> const x _ = x   in Haskell
07:48:05 <Roey> dash:  ok, remember when I was here last time?
07:48:10 <dash> Roey: Nope, sure don't
07:48:13 <Roey> dash:  arg, ok.
07:48:31 <wilx> Declaration of method: T foo (Object const & o) const; 
07:48:43 <Roey> There was one place in the Haskell documentation that said that one can guarantee that a statement will not modify its parameter
07:48:48 <wilx> First const means that you cannot modify the o object.
07:49:01 <Roey> and it said something about C++'s const not measuring up to this ability of Haskell
07:49:05 <Roey> and that's why I asked here...
07:49:08 <wilx> The second const measn that you cannot modify "this" object.
07:49:11 <wilx> Two different things.
07:49:17 <dash> Roey: well, haskell is call-by-name, for one thing
07:49:19 <Roey> ok
07:49:20 <wilx> Go read some tutorial or faq about it.
07:49:25 <Igloo> Roey: In Haskell you can /never/ modify parameters
07:49:27 <dash> Roey: for another, nothing ever changes in haskell
07:49:33 <Roey> ok
07:49:51 <Roey> that's interesting
07:52:56 <Roey> oh and also
07:53:02 <Roey> after reading a tutorial about monads,
07:53:36 <Roey> (Ill read more, but for right now) I think I get the gist of them:  monads constitute discrete 'cells' of computation.
07:53:37 <Roey> right?
07:53:52 <Philippa_> er. Depends what you think constitutes a monad
07:54:21 <Philippa_> the terminology is a bit broken here, but it sounds like you're talking about 'monadic values' or 'computations' - eg values of type IO a
07:54:21 <Roey> er
07:54:33 <Roey> that's what I looked at, right. IO monads.
07:54:56 <dash> yeah, a monadic value is an abstract representation of some computation
07:54:57 <Philippa_> there's only one IO monad in common use in Haskell
07:55:10 <Roey> ok
07:55:29 <Muad_Dib> isnt monad the most complex thing in haskell? :)
07:55:33 <Roey> :)
07:55:35 <Philippa_> the monad is the overall structure (eg the IO type and associated instance declarations)
07:55:39 <Roey> I'm really interested in this.. 
07:55:44 <shapr> nah, the type system gets more complicated than monads.
07:55:48 <Roey> ok
07:55:52 <Philippa_> it's effectively a bridge between two sets of semantics (eg Haskell and "Haskell + IO")
07:56:03 <dash> it's a pity everyone has to start with IO
07:56:16 <Roey> that's what the monad tutorial started with
07:56:16 <musasabi> hmm
07:56:17 <shapr> the maybe monad is a lot easier
07:56:18 <shapr> or the list monad
07:56:20 <dash> because it's not the most clear example of monads :)
07:56:27 <dash> yeah, Maybe is good
07:56:42 <Muad_Dib> Maybe Nothing :P
07:56:44 <Philippa_> and list's good as an example for busting over-specific ideas of what a monad is
07:56:46 <musasabi> Maybe is easy but IO is not the most difficult monad.
07:56:56 <Philippa_> no, but IO has a habit of confusing newbies
07:57:03 <musasabi> List, Cont and ST can be hard.
07:57:04 <Roey> bbiab
07:57:05 <dash> it confused _me_....
07:57:12 <dash> yeah, what's ST good for
07:57:13 <shapr> My opinion of monads is that they're a way of making added together pieces of a program behave in a deterministic manner, just like objects or subroutines oor other abstractions. But monads are a lot more explicit about it.
07:57:22 <Igloo> I'd say State is easiest, and IO is simple after State
07:57:24 <Philippa_> largely because IO and ST are the only commonly-used monads that can't be implemented in Haskell
07:57:44 <musasabi> dash: think of IO as just as accumulating a list of actions and main running that list.
07:57:56 <dash> musasabi: well yeah i understand it now
07:58:11 * Philippa_ doesn't like that idea of IO
07:58:18 <Philippa_> after all, main's just Yet Another IO Action
07:58:20 <dash> musasabi: but only by studying monads that i could get values out of, for starters :)
07:58:26 <Philippa_> it's the RTS that's running it
07:58:41 <shapr> monads are just so elegant :-)
07:58:55 <dash> so... what's ST
07:58:59 <Philippa_> seen IORefs?
07:59:07 <tuomov> main is the main function that constructs instructions for the IO interpreter to interact with the real world
07:59:08 <Philippa_> ST supports a similar reference type, and that's it
07:59:17 <dash> Philippa_: i haven't
07:59:19 <Philippa_> tuomov: only coincidentally though
07:59:33 <Philippa_> main is only special from the POV of the interpreter and people who know what the interpreter does
07:59:46 <tromp> IO is ST RealWorld
07:59:57 <Philippa_> tromp: no, that's a GHC implementation detail
08:00:19 <tromp> of course, RealWorld is not a user accessible type
08:00:48 <tromp> but this view helps understand the relation between IO and ST
08:01:06 * dash is further confused ;)
08:01:12 <Philippa_> ST RealWorld + the IO actions, sure
08:01:40 <Philippa_> dash: read up Data.IORef, then the matching stuff for STRefs and the ST monad
08:04:09 <Philippa_> basically, IORef implements ML-style references in the IO monad - you can create a new reference by supplying a value for it to refer to, you can read from the reference and you can write to it
08:04:13 <Philippa_> mutable data cells
08:06:22 <vdrab> i'm grappling with the whole monad thing too. I understand the problem doing IO in a lazy functional language, and i sort of understand monads (i think), but i have trouble seeing how monads solve the problem... is that weird?
08:06:31 <Philippa_> not overly
08:06:39 <Philippa_> OK, the most basic way to solve the problem is this:
08:06:44 <dash> vdrab: the IO monad cheats, basically
08:06:46 <Philippa_> IO is done by functions of type World->World
08:06:48 <shapr> heh
08:06:52 <shapr> it doesn't really cheat
08:07:03 <shapr> IO is both purely functional and does side-effects
08:07:17 <shapr> that works just fine as long as you have 'one-way' monads
08:07:18 <Philippa_> only there's a slight issue with that - if you have World->World functions without any limitations you can do daft stuff like duplicating the World value
08:07:25 <Philippa_> which is great if you have quantumn computers...
08:07:31 * shapr grins
08:07:32 <Philippa_> does that much make sense?
08:07:43 <vdrab> that's another thing, that metaphor of "passing the world around". lol.
08:07:50 <Philippa_> it's not just a metaphor
08:07:53 <Philippa_> at the type level, that's what's going on
08:07:58 <vdrab> hmpf
08:08:01 <vdrab> hehe
08:08:21 <Philippa_> you start with a given state-of-the-universe and a set of parms to the computation. You end up with a state-of-the-universe and a result
08:08:45 <Philippa_> bingo, a perfect mathematical model of what computation with IO involves
08:09:12 <shapr> any questions? =)
08:09:35 <Philippa_> then you just use a state monad around the state-of-the-universe to stop yourself from accidentally creating a second universe :-)
08:10:15 <shapr> ok, anyone who doesn't understand monads raise your hand
08:10:39 <vdrab> yes, i think i get the big picture of what it is that monads give you.... i still haven't gotten around to messing with them so i can connect the philosophy with the practical
08:10:47 <Philippa_> go mess, then :-)
08:10:50 <vdrab> shapr: oh, here, me
08:11:24 <musasabi> shapr: sometimes ConT escapes me - mainly how to make elegant readable code with it.
08:11:31 * Philippa_ sniggers
08:11:32 <shapr> I'm a big fan of Cale's 'monads as container' explanation. I think it's easy to understand.
08:11:52 <Philippa_> I know the explanation I like, but of course YMMV
08:12:13 <dash> musasabi: anything that uses callCC is gonna be funny-lookin'
08:12:17 <Philippa_> I just prefer being hit with all of the big picture including the detail needed to understand it simultaneously
08:12:28 <shapr> Thing is, there are about six good 'lies for teaching' that explain useful facets of monads. But they're all not really monads.
08:12:37 <vdrab> i agree, but i'm still at the level of "ehm... worlds... bind ... return... universe... that's deeeeep"
08:12:45 <Philippa_> right
08:12:49 <vdrab> in a very james brown kind of way
08:12:53 <Philippa_> it *is* deep. Now go play with it ;-)
08:12:57 <shapr> imho, IO isn't a good training monad
08:13:05 <shapr> maybe is much more sensible
08:13:14 <musasabi> mainly I tried to implement code saving continuations but failed in each attempt.
08:13:15 <Philippa_> it's an awful one, you've got to deal with the whole "you mean the language isn't sufficient to express everything in it?" deal
08:13:17 <shapr> http://www.nomaware.com/monads/html/maybemonad.html
08:13:30 <shapr> musasabi: you got me there, but if you figure it out, I want to know how you did it.
08:13:39 <shapr> I haven't gotten around to playing with ContT yet.
08:13:41 <vdrab> 'maybe' is a lot newbie-friendlier, that's true
08:14:34 <Philippa_> one of the problems with IO is that it's sort of "backwards" compared to most monads
08:14:49 <Philippa_> it can be argued that really you're embedding Haskell in IO rather than IO in Haskell with it
08:15:12 <Philippa_> unlike eg Maybe where you're embedding sort-of-continuations in Haskell
08:15:55 <musasabi> I think the problem is that they are only escape continuations where-as I want to have fully re-entrant ones.
08:17:24 <musasabi> But are monads powerfull enough for first class continuations?
08:17:56 <musasabi> as the rest of the computation is a function and you cannot really do much with them.
08:18:09 <shapr> arrows should do it.
08:18:35 <Philippa_> are there any known restrictions on first class continuations that the call/cc model removes?
08:18:43 <Philippa_> that'd be a hint that arrows might work where monads fail
08:18:50 * vdrab runs off to go bug a monad or two ...
08:19:18 <musasabi> Philippa_: the call/cc continuations suffer from a number of problems.
08:19:29 <shapr> I dunno about that, but I do know that Yampa saves running signal functions and restores them. I think they'll be re-entrant.
08:19:30 <musasabi> There is a paper about "subcontinuations" which discusses that.
08:19:38 <Philippa_> sure, I know they're nominally the more specific model
08:19:57 <musasabi> shapr: but how to do that without resorting to C?
08:19:59 <Philippa_> often the specificity lifts some restrictions where some property you need isn't guaranteed true in the general case
08:20:22 <shapr> I don't know, I'd probably look at Yampa and see what they've done.
08:20:35 <Philippa_> ah, you want to save/restore in the middle of a pure function evaluation?
08:20:55 <Philippa_> pseudo-concurrency style?
08:21:27 <Philippa_> (cue pure-code-should-be-another-arrow argument)
08:22:15 <musasabi> Philippa_: no inside a monadic thing.
08:23:05 <Philippa_> so return and >>= are sufficient points to do all the work at. OK, lemme think...
08:23:08 <musasabi> I want an "save-this-continuation-to-memory-and-start-processing-next-user-request-invoking-a-continuation-from-the-memory-database"
08:23:22 <Philippa_> sounds a bit like a poor man's concurrency monad with blocking?
08:25:21 <musasabi> Philippa_: but I want to make it possible restart things from the savepoints
08:25:37 <shapr> I'd like that too
08:26:22 <kristnjov> om man ska gå och vara hyperspecifik i alla lägen kan man väl säga att venom är det enda riktiga black metal-bandet :P
08:26:30 <musasabi> btw is there a nice library to draw simple charts (with bars) in haskell?
08:26:47 <Philippa_> surely that bit's just a branch? If you gimme some example usages I'll have a think about a possible implementation
08:27:30 <musasabi> kristnjov: and if one wants to be specific one can say in any case that venom is the only true black metal-band?
08:27:57 <kristnjov> uhh
08:28:00 <kristnjov> wrong channel
08:28:02 <musasabi> Philippa_: scheme continuation based webapps.
08:28:03 <kristnjov> to say the least
08:28:27 <Philippa_> musasabi: I need specific examples, I've not tried it myself so I need to see what the relevant usage patterns look like
08:28:55 <shapr> what about a loop that doesn't even use 'recursion' ?
08:29:03 <shapr> but instead a restartable continuation?
08:29:44 <shapr> or what about a partially applied continuation where I can change the 'loop value' ?
08:30:07 <shapr> myCont >>= 1 
08:30:31 <musasabi> Philippa_: wash does it more or less, but it cheats.
08:30:36 <shapr> A 'big' example would be saved continuations for a web browser.
08:31:19 <shapr> guten abend TheHunter
08:31:37 <Philippa_> musasabi: ah, the whole "replaying everything that's happened" of it, yeah?
08:32:23 <Philippa_> so we really are simulating blocking-heavy concurrency, it's just the savepoints as an extra, right?
08:32:43 <musasabi> yes.
08:33:18 <Philippa_> OK, I'm pretty sure the poor man's concurrency monad (see paper) could be modified to support that
08:33:38 <musasabi> even pre-emption is extra.
08:33:51 <musasabi> Philippa_: so if it is that easy why does WASH not use it?
08:33:52 <Philippa_> yeah, I'd figured, PMCM is co-operative :-)
08:34:14 <Philippa_> to allow itself to run as simple CGIs?
08:34:21 <Philippa_> saving the database to disk is a whole other problem
08:34:53 <musasabi> nah, it can be done quite easily if you are willing to step into C-land.
08:35:14 <Philippa_> yeah, but who wants to do that? :-)
08:37:34 <Philippa_> anyway, the paper's by Koen, it's an old functional pearl from 93
08:37:56 <Philippa_> it's prolly easiest if you flick through it then tell me I'm on crack or otherwise
08:43:02 <musasabi> Is there some library to draw pictures with Haskell ?
08:43:07 <TheHunter> good evening, shapr
08:43:08 <Philippa_> pan?
08:43:50 <musasabi> "Before using Pan#, you must install the Microsoft .NET Framework on your computer."
08:44:02 <shapr> ick
08:44:05 <shapr> pancito!
08:45:01 <musasabi> hmm there is an older version too.. 
08:45:17 <musasabi> Just want to get simple graphs.
08:45:59 <Igloo> You could write a quick PPM producing thing
08:46:10 <shapr> Igloo wrote one of those once, I think.
08:46:17 <Igloo> Or gtk*hs/wxhaskell might be what you want
08:46:29 <shapr> I want a gnuplot binding
08:47:15 <musasabi> generating png:s would be ideal, and have to run that as a server app.
08:49:01 <musasabi> Is there a newer version of http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hdirect/examples/gd/ ?
08:50:04 <boegel> musasabi, I use a simple PPM function
08:50:08 <boegel> for now
09:03:31 <boegel> hey mornfall 
09:03:50 <mornfall> hey hey, boegel, *
09:23:43 <boegel> hey xkb monochrom gintas 
09:48:21 <boegel> heya kpk sond goron WilX 
09:50:38 <sond> hi
10:05:35 <goron> hi
10:34:10 <CosmicRay> OK, I have an Either/IO theory question.
10:34:19 <CosmicRay> I have some functions that parse strings into objects
10:34:45 <CosmicRay> they return a CPResult, where type CPResult = Either CPError CPData (and CPError is an instance of Error, so I can use it in the Error monad.)
10:34:59 <CosmicRay> Now, I have some more functions that parse files into these same objects
10:35:18 <CosmicRay> Would it make sense to have them return an IO CPResult?
10:35:35 <CosmicRay> Or is there some better way of combining the error monad into the IO monad?
10:36:16 <Philippa> ErrorT might help
10:36:39 <CosmicRay> I've read a bit about it, but...  I'm confused and not sure where to start.
10:36:45 <CosmicRay> monad transformers are still a black art to me
10:37:18 <Philippa> fair enough
10:37:26 <Philippa> I'm feeling too braindead to explain properly right now, sorry :-(
10:37:46 <Philippa> er, basically there'll be some runErrorT func that does (ErrorT m a) -> (m a) conversions, you run the error-based stuff in that
10:37:57 <Philippa> then liftIO to do IO
10:38:20 <CosmicRay> so my final result type is IO CPData?
10:38:43 <CosmicRay> @index liftIO
10:38:43 <lambdabot> Control.Monad.Cont,Control.Monad.Error,Control.Monad.List,Control.Monad
10:38:43 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Trans,Control
10:38:43 <lambdabot> Monad.Writer,GHC.IOBase
10:39:02 <tromp> why not just getContents of those files in IO monad, and then hand result to your parser?
10:39:03 <Philippa> read through Control.Monad.Error
10:40:15 <CosmicRay> tromp: because this is going through Parsec, and it can do some things nicer if it gets a filename directly (filename and position in error messages, for instance)
10:40:28 <CosmicRay> tromp: yes, I could fake all that, but I also want to provide a convenience function to do this
10:40:41 <CosmicRay> Philippa: I have but its documentation is mostly non-existant
10:42:35 <CosmicRay> Philippa: oh, yuo mean the source?
10:42:58 <Philippa> I meant the docs, they're just about enough to figure out from the types and eg the Nomaware monads tut
10:43:18 <CosmicRay> that's assuming that I'm not confused about the types
10:43:23 <CosmicRay> which I am :-)
10:43:29 <Philippa> ah
10:43:33 <Philippa> 'fraid I've stuff to do
10:43:45 <Philippa> hope somebody else is suitably helpful - if not, work through the types by hand?
10:43:50 <Philippa> (IO CPResult seems sane, FWIW)
10:44:01 <CosmicRay> if that makes sense then I'll just do it
10:44:07 <CosmicRay> I've got that happening manually already
10:44:24 <CosmicRay> I was just checking to see if I should be converting my Either into an IOError for returning an IO value
10:44:39 <CosmicRay> basically an inquiry on what the conventional way of handling this is :-)
11:09:03 <CosmicRay> @index lift
11:09:03 <lambdabot> Language.Haskell.THSyntax,Control.Monad.Cont,Control.Monad.Error,Control
11:09:03 <lambdabot> Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad.State,Control
11:09:03 <lambdabot> Monad.Trans,Control.Monad.Writer,Text.ParserCombinators.ReadPrec,Text.Read
11:16:42 <Igloo> Control.Monad.Trans is its real home
11:23:55 * Philippa just had a stupid thought and could use having it kicked around a bit
11:24:24 <Philippa> Wadler muses about an equivalent of memoisation for call-by-value. Could the equivalent in fact be inlining?
11:25:44 <dash> eh? why do you need an equivalent, memoization works fine for call-by-value languages
11:25:52 <Igloo> Not if two calls with the same value come from different places
11:26:03 <jemfinch|lambda> why not?
11:26:03 <dash> hence all the memoization examples in lisp, python, etc
11:26:06 <CosmicRay> @index liftM
11:26:06 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
11:26:06 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
11:26:06 <lambdabot> State,Control.Monad.Writer,Monad
11:26:09 <monochrom> inlining with lots of let-expressions maybe.  An important aspect of memoisation is "evaluate only once".
11:26:34 <esap> I think the equivalent of memoization for call-by-value has something to do with how inputs to functions behave. Maybe dynamic programming is close analog?
11:26:51 <monochrom> ok, smart compilers doing smart common subexpression elimination can provide for that.
11:30:54 <wagle> memoization works in pure languages because each evaluation has the same result
11:31:08 <wagle> cbv languages tend to be impure
11:31:41 <wagle> its hard to be impure in lazy languages
11:32:52 <esap> Maybe cbv assignment/read from  global variables in a method in a cbv language corresponds to memoization. Both have similar problems :-)
11:33:27 <wagle> hmm..  partial evaluation provides a perspective where you do the static part of the computation "as much as you can" while leaving the dynamic part to be redone each time
11:35:51 <wagle> i think the original memoization paper was more about dynamic programming sorts of things
11:36:09 * esap tries to understand memoization via duality.
11:36:31 * Lor doesn't understand why anyone prefers dynamic programming over memoization.
11:36:38 <Lor> memoization is just so much more convenient.
11:37:09 <wagle> i might not understand dynamic programming, but i thought memoization was its chief tool
11:38:27 <monochrom> I have once written a few paragraphs explaining dynamic programming.  It boils down to "top-down recursion" -> "top-down recursion with memoisation" -> "do it bottom-up to save a few tests".  A seasoned instructor praises "I've never seen a clearer explanation before!"
11:38:31 <wagle> i dont understand more about memoization than that its a mechanism to cause a (pure?) computation to be done only "once"
11:40:04 <esap> right, dynamic programming actually depends on memoization.
11:40:53 <monochrom> So I'm thinking the popular way of teaching dynamic programming --- as an isolated method unrelated/incoherent with other methods --- over-mystifies it and makes it look deeper than it is.
11:40:53 <wagle> (i once had a lazy language that gained efficiency by not using locks to insure that a uncomputed memo was computed only once..  (parallel scheduled environment, and only a timeslice or so would be wasted on the redundant computation)
11:42:23 <wagle> so i'm rephrasing what's memoization in a CBV language to what's memoization in an impure language?
11:43:20 <esap> Ok, memoization is a mechanism for a *function* to remember its inputs and their associated outputs and optimize time usage based on that, right?
11:43:21 <wagle> i'm feeling (in plato's cave) that this might be an opposite of grabbing a continuation..  but
11:44:02 <monochrom> esap's sentence sounds like an opening sentence on a patent application. :)
11:44:14 <wagle> i'm seeing memoization merely as an efficiency hack.. you dont need it..
11:44:26 <dash> monochrom: he's probably reading it off of a patent
11:44:34 <dash> wagle: maybe _you_ don't
11:44:37 <dash> i am in a hurry!
11:44:46 <esap> monochrom: heheh
11:44:50 <shapr> man I love unicycling.
11:45:02 <wagle> dash: you wrongly assume that i dont like efficiency hacks
11:45:37 * shapr hops tiredly
11:45:54 <Lor> From a symmetric point of view, a function takes a value and a continuation and ties them together.
11:45:56 <esap> But the point is, dualize that, you get a *layer* that remembers what signals and their responses have occurred and optimizes space usage based on that.
11:47:02 <wagle> ok..  <connect_dots> memo's are hopefully computed once..  initial and final objects have a oneness to them...
11:47:35 <shapr> as Lor once said, memoize' f range = ((map f range) !!)
11:47:37 <esap> So actually, I think virtual memory sounds like the dual for memoization.
11:47:50 <monochrom> That is bordering on postmodernism.
11:48:24 <esap> or maybe it's swapping to disk...
11:49:07 <wagle> the imposition of linearly bounded automata?
11:50:22 <Lor> shapr, except that a linear-time memo lookup isn't very useful...
11:50:51 <wagle> hmm..  that PSPACE should be equal to NPSPACE?  8)
11:54:10 <gpciceri> hi all, anyone here using ghc on windows that tried dll ?
11:55:02 <gpciceri> I've problems with the first sample in docs/6.2.1/html/users_guide/win32-dlls.html
11:55:18 <gpciceri> here the user guide says a 4K executable
11:55:42 <gpciceri> but if I try to reproduce I've an executable 180K bytes long :-(
11:58:37 <Philippa> yeah, the user guide's likely not been updated in a while
11:58:43 <Philippa> does the executable do the right thing still?
11:59:01 <gpciceri> yes, but I think it's statically linked
11:59:43 <gpciceri> if I add -static the compilation produce a same-size executable
12:20:07 * shapr bounces cheerfully
12:20:10 <shapr> unicycling is GREAT!
12:20:51 <stepcut> apparently...
12:21:32 <shapr> hiya stepcut!
12:21:37 * shapr bounces hoppily
12:21:50 <shapr> how's code in the big city?
12:22:06 <stepcut> today, its crappy C++ stuff :)
12:22:16 <stepcut> but yesterday, it was glorious Haskell
12:22:42 <stepcut> neat stuff with dependent types (or some approximation of them)
12:22:43 <shapr> That's a nice balance. You a nice perspective on both sides.
12:22:52 <shapr> er "you keep"
12:23:27 <shapr> neat, 107 in #haskell
12:23:31 <stepcut> heh
12:23:34 <shapr> I think our high was 108 or 110
12:23:47 * shapr tries to remember his address
12:23:47 <stepcut> does lambdabot keep track ?
12:23:54 <shapr> um, no
12:23:56 <shapr> but he should!
12:24:12 <shapr> @stats-max-users
12:24:12 <lambdabot> Sorry, I don't know the command "stats-max-users", try "lambdabot: @listcommands
12:24:18 <stepcut> heh
12:24:39 <stepcut> @learn-new-trick @stat-max-users
12:24:39 <lambdabot> Sorry, I don't know the command "learn-new-trick", try "lambdabot: @listcommands
12:24:43 * shapr grins
12:25:00 <shapr> I could switch lambdabot over to using hs-plugins, but I'd rather hack on your keymap
12:25:01 <Muad_Dib> stepcut, you need to pay him first :P
12:25:06 <stepcut> shapr: heh
12:25:45 <shapr> I wish we could get rid of cpp in the Haskell world.
12:26:01 <Muad_Dib> shapr: only in the cpp world?
12:26:05 <Muad_Dib> *haskell world?
12:26:14 <shapr> It would be a good start.
12:26:39 <Muad_Dib> it's like smoking :P
12:26:45 <Muad_Dib> you can decrease the amount you use it
12:26:52 <Muad_Dib> but the best way is to quit it all at once :)
12:26:58 <shapr> I quit smoking a few years back.
12:27:08 <shapr> I never really started with cpp.
12:27:13 <Muad_Dib> lol
12:27:16 <Muad_Dib> me neither :)
12:29:03 <SyntaxNinja> cpp! vile! evil!
12:29:15 * shapr agrees
12:29:25 <shapr> I wish there were some way to do it right in Haskell.
12:29:55 <CosmicRay> hey shapr.
12:30:04 <CosmicRay> shapr: I am stuck on monad transformers and ErrorT
12:30:09 <shapr> greetz CosmicRay, how's your monad dreamquest?
12:30:14 <shapr> ah, I see.
12:30:18 <CosmicRay> shapr: good, except for that :-)
12:30:30 <CosmicRay> shapr: specifically, I am trying to use Either stuff in an IO monad
12:30:32 <shapr> well, do you remember the ap combinator?
12:30:44 <CosmicRay> I have seen it, but I don't understand it
12:30:48 <CosmicRay> I've never used it
12:31:00 <CosmicRay> basicallly, what I've got is...
12:31:10 <shapr> I think the ap combinator is the next step towards understanding monad transformers.
12:31:16 <CosmicRay> I rewrote some code to run in the Either monad instead of raise exceptions (this is pure functional code)
12:31:18 <shapr> @index ap
12:31:18 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
12:31:18 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
12:31:18 <lambdabot> State,Control.Monad.Writer,Monad
12:31:25 <shapr> yow, that's too much!
12:31:29 <CosmicRay> I guess that's the Error monad.
12:31:31 <CosmicRay> anyway, that worked great.
12:31:38 <shapr> @type Control.Monad.ap
12:31:39 <lambdabot> Control.Monad.ap :: forall b m a.
12:31:39 <lambdabot> 		    (Monad m) =>
12:31:39 <lambdabot> 		    m (a -> b) -> m a -> m b
12:31:41 <CosmicRay> but now I'm trying to combine it with reading/writing files, etc.
12:31:51 <CosmicRay> can't quite work out the magic recipe.
12:32:05 <CosmicRay> hmm.  
12:32:24 <CosmicRay> @type >>=
12:32:25 <lambdabot> bzzt
12:32:29 <CosmicRay> @type (>>=)
12:32:31 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
12:32:40 <shapr> do you know how to execute a pure function on a monadic input?
12:32:44 <SyntaxNinja> did you guys notice ross's drug peddling on the libraries list, "Just a little bit of cpp would be so great in cabal... everybody's doing it"
12:32:53 <shapr> SyntaxNinja: yes, that's why I said it.
12:32:55 <CosmicRay> shapr: yes, I would use >>= or do with a <-
12:33:22 <stepcut> cpp is for losers! Real men use TH!
12:33:26 <shapr> CosmicRay: ok, how do you execute a pure function on a monadic value, by altering only the function?
12:33:29 <wagle> cpp with a haskell tokenizer?
12:33:46 <SyntaxNinja> stepcut: not if you're CPPing for portability to hugs and nhc :)
12:33:52 <stepcut> ;)
12:34:14 <CosmicRay> shapr: alter its type?  
12:34:21 <CosmicRay> (I'm not sure I understand what you're after)
12:34:41 <wagle> ohhhh..  what if the thing you are memoizing is a function / monadic-computation?
12:34:42 <shapr> how can you generically alter the type of any input function so that it works on a monadic value? What function already does that?
12:35:03 <CosmicRay> isn't that (>>=)?
12:35:10 <shapr> @type liftM
12:35:11 <lambdabot> bzzt
12:35:12 <jemfinch|lambda> shapr: Why do you think there aren't any Haskell things similar to Plone?
12:35:28 <shapr> @type Control.Monad.liftM
12:35:30 <lambdabot> Control.Monad.liftM :: forall r m a1.
12:35:30 <lambdabot> 		       (Monad m) =>
12:35:30 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
12:35:47 <CosmicRay> ah.
12:36:06 <shapr> for various reasons, liftM works only for one arg, liftM2 for two args, etc
12:36:09 <CosmicRay> that requires no change to the function at all, and also addresses its output
12:36:29 <desrt> ah.  <.<
12:36:40 <CosmicRay> liftM f seems similar to >>= return . f
12:36:49 <CosmicRay> is that right?
12:36:57 <desrt> CosmicRay; quite.
12:37:23 <CosmicRay> ok, I've got liftM.
12:37:50 <shapr> now, you realize you can lift a value into Either, and then lift it into IO, and keep on lifting while you have layered monads?
12:37:50 <CosmicRay> actually I've used the return . f pattern all over in my code.  Time for a little sed :-)
12:37:51 <desrt> you might say datatype <- (liftM read (readFile "foo"))
12:38:06 <CosmicRay> shapr: yes, that makes sense
12:38:32 <shapr> ok, after that, a bunch of people put some serious brainwork into finding a more generic way to do that.
12:38:41 <shapr> it's called, *drum roll* monads transformers.
12:38:52 <shapr> you stack up monads on top of each in effectively the same way.
12:38:55 <CosmicRay> never say shapr lacks pizaaz in his irc tutorials :-)
12:39:03 * shapr grins
12:39:11 <dash> i lack pizzas
12:39:14 <wagle> you blew out my speakers!
12:39:16 <CosmicRay> heh
12:39:23 * desrt orders some 30minutes-or-free for dash 
12:39:32 <dash> desrt: excellent
12:39:34 <CosmicRay> shapr: ok, that concept makes sense
12:39:44 <wagle> i'm next door to a pizza place
12:39:48 <dash> desrt: i _know_ i'm more than 30 minutes from a pizza place
12:39:57 <shapr> I'm next door to some snow.
12:40:01 <shapr> Lots of snow in fact.
12:40:04 <desrt> dash; i also know that the pizza i ordered for you will not ever arrive.
12:40:08 <wagle> snow?  whazzat?
12:40:09 <desrt> dash; but at least it's free
12:40:14 <dash> desrt: for free!
12:40:15 <CosmicRay> shapr: the trouble with a bunch of liftM seems to be ugliness -- having to go in and out of different monads all the time
12:40:16 <dash> yes!
12:40:19 <shapr> Unicycling in snow is challenging.
12:40:34 <wagle> studs or chains?
12:40:46 <desrt> shapr; i wasn't aware that snow was capable of such locality
12:40:51 <shapr> CosmicRay: yes! that's why people came up with monad transformers, because lifting required you to remember order and do it again yourself and stuff
12:41:01 <shapr> desrt: visit me, you will learn.
12:41:20 <desrt> shapr; maybe next summer, but then there will be no snow
12:41:23 <shapr> wagle: um, I may be a stud, but... ;-)
12:41:25 <stepcut> shapr: maybe you need a snow unicyclemobile
12:41:32 <CosmicRay> shapr: ok.  the mechanics of the transformers are still opaque to me.  For instance, I haven't been able to get any useful result out of runErrorT :-)
12:41:37 <dash> shapr: but are you a boss
12:41:43 <CosmicRay> actually I havne't been able to get anything to *compile* for it
12:42:04 <shapr> dash: as opposed to being a stud? that makes sense.
12:42:30 <dash> i seem to recall some dictionary defining "boss" as "an ornamental stud"
12:42:35 <shapr> CosmicRay: I have social interaction being requested, I shall return after talking to my woman, but I hope you're getting the idea :-)
12:42:41 <CosmicRay> shapr: ok :-)
12:42:49 <shapr> CosmicRay: the nomaware tutorial talks about monads transformers... read that section again!
12:42:50 <dash> CosmicRay: i have some code that uses monad transformers a bit
12:42:51 * shapr disappears
12:43:03 <dash> i can't promise that I understand it, but it may prove useful :)
12:43:11 * CosmicRay hopes nobody here wonders what sort of "social interact" shapr is having with "his woman"
12:43:23 <desrt> CosmicRay; dinner... a movie...
12:43:30 <CosmicRay> bah, so uninteresting :-)
12:43:43 <CosmicRay> dash: you are a quick study
12:43:44 * desrt plucks your mind, swiftly, from the gutter
12:43:53 <CosmicRay> dash: didn't you just learn Haskell last week? :-)
12:44:05 <dash> nah
12:44:14 <dash> i learned it in like 2001 or so
12:44:21 <CosmicRay> oh
12:44:27 <CosmicRay> you are the Twisted guy, right?
12:44:32 <dash> one of 'em ;)
12:44:38 <CosmicRay> right :-)
12:44:43 <dash> http://ghostwheel.ddts.net/~washort/arnis.hs
12:44:50 <CosmicRay> you do realize that Haskell makes the whole impetus for Twisted obsolete, right? :-)
12:44:55 <dash> nope
12:45:03 <wagle> Twisted?
12:45:09 <dash> http://twistedmatrix.com/
12:45:25 <dash> CosmicRay: twisted is primarily designed to address stuff that haskell is poor at
12:45:29 <CosmicRay> dash: forkIO turns any synchronous IO code into asynchronous code using select internally
12:45:35 <CosmicRay> dash: oh?  what parts?
12:46:06 <dash> CosmicRay: yeah, and so does greenlets or continuations or erlang processes 
12:46:23 <dash> the language-level solution to the problem is well-known, just very expensive at this point
12:46:25 * esap just noticed that the expression 'ap ap' is valid :-)
12:46:38 <wagle> you seen ohaskell?
12:46:47 <dash> wagle: heard of it
12:46:54 <CosmicRay> dash: hmm.  I would have thought forkIO internally is similar to the posix twisted reactor internally
12:46:54 <dash> but it's still statically typed, isn't it?
12:46:58 <CosmicRay> dash: am I mistaken there?
12:47:21 <dash> CosmicRay: they are related somehow, i am sure
12:47:43 <CosmicRay> dash: what is it about the language-level abstration that makes it more expensive than the twisted reactor?
12:47:49 <dash> CosmicRay: politics
12:47:56 <CosmicRay> politics?
12:48:09 * CosmicRay always knew it.  Haskell hackers are republicans.
12:48:12 <CosmicRay> :-)
12:48:21 <dash> it's a lot easier to convince people to use a library for python than to convince people to use a new language that is almost but not quite python
12:48:28 <CosmicRay> ah.
12:48:29 <CosmicRay> I see.
12:48:45 <CosmicRay> by "expensive" you didn't mean in terms of machine resources, but developer resources?
12:48:49 <dash> right
12:49:12 <dash> anyway. the thing haskell seems poor at to me, that twisted addresses, is simulation
12:49:14 <wagle> everyime i encounter a brittle gui, its written in python 
12:49:21 <CosmicRay> wagle: not perl?
12:49:22 <stepcut> heh
12:49:41 <CosmicRay> dash: simulation.  Hmm.  I don't think I've done that with twisted.  You mean things like unit testing?
12:49:43 <dash> wagle: really! i keep tripping over ones written in C++
12:49:43 <esap> Every time I encounter a brittle gui, it's running on windows; go figure :-)
12:49:56 <dash> CosmicRay: errrrmm well no not exactly
12:50:00 <wagle> heh
12:50:15 <CosmicRay> I hate those (Perl|Windows) GUIs that give me error boxes that say "Error reading (whatever): Success"
12:50:20 <CosmicRay> argh those are the most annoying
12:50:24 <CosmicRay> learn to use errno, people!
12:50:26 <dash> CosmicRay: i guess i should say "twisted is useful for a simulationist view of system design"
12:50:42 <CosmicRay> and I don't know what that means :-)
12:50:42 <esap> what is this twister reactor thing?
12:50:44 <wagle> errno is hard.  lets go shopping.
12:50:56 <esap> s/twister/twisted/
12:51:19 <dash> esap: twisted is a framework for integrating various concurrent services, mostly networkish stuff
12:51:38 <dash> CosmicRay: well, a big example is the app we're developing at work
12:51:38 <CosmicRay> easp: it's based around async I/O and uses a system of callbacks for most everything
12:51:44 <dash> http://quotient.divmod.org/
12:51:45 <esap> dash: ah ok, I thought that was describing some variation on the reactor pattern :-)
12:51:59 <dash> esap: yeah, it uses the reactor pattern internally for the event loop
12:54:59 <wagle> Sound assertion "0 != err" failed in "AppleLegacyAudio/AppleTexas2Audio/AppleTexas2Audio.cpp" at line 960 goto Exit
12:55:51 <dash> for example, our app includes an IMAP server and client, POP3 server and client, web server, stateful SIP proxy, RPC system, DNS server, and SMTP server
12:56:23 <dash> so far as I know, haskell doesn't have /any/ of these
12:57:10 <wagle> haskell has been a very bad language
12:57:14 <wagle> for shame
12:57:33 <dash> well, my point is that these are the reason twisted isn't obsolete ;)
13:00:11 <dash> (not to mention the object database or web form generation system)
13:00:21 <wagle> write a twisted interpreter in haskell.  apply PE fu.  there ya go.
13:01:07 <dash> "PE fu", eh
13:01:13 <dash> can we bottle that?
13:01:29 <dash> anyway perhaps those things could be written in haskell eventually; it wouldn't surprise me 
13:01:44 <wagle> bottle in front of me?
13:02:11 <dash> haskell's weakness, AFAICT, is in simulation design
13:02:12 <dash> for example
13:03:06 <dash> http://www.python.org/pycon/papers/twisted-reality.html
13:03:19 <dash> this is the kind of stuff i have no clue how to do in haskell
13:06:03 <wagle> the problem being solved isn't clearly stated in the intro?
13:06:45 <HET2> is there a simple conversion of a string to an integer in haskell?
13:07:08 <wagle> @type read
13:07:09 <lambdabot> read :: forall a. (Read a) => String -> a
13:07:30 <HET2> thanks
13:08:22 <HET2> wagle: uhm do you mind giving me a hint as to what this is?
13:08:53 <wagle> Prelude> read "123" :: Int
13:08:53 <wagle> 123
13:09:12 <wagle> what what is?
13:09:18 <HET2> oh
13:09:36 * HET2 has still not quite grasped haskell's type system :)
13:10:27 <wagle> yeah..  you need to put the read <string> expression in a context where the type of the result can be deduced
13:12:02 <wagle> there are classes named "Show" and "Read", uses to convert values to and from strings
13:13:16 <HET2> thanks a bunch
13:15:13 <stepcut> <wagle> bottle in front of me? <-- better than a frontal lobotomy...
13:15:35 <wagle> trvth
13:25:44 <shapr> dash: what sort of simulation design?
13:26:17 <shapr> CosmicRay: actually, the social interest was that she just came back from a business meeting and now we might get more work.
13:27:59 <shapr> dash: dude, have you seen Yampa?
13:28:06 <shapr> hoi goron
13:29:04 <dash> shapr: no wossat
13:29:16 <shapr> it's Haskell's answer to simulation.
13:29:32 <shapr> http://www.haskell.org/yampa/
13:29:40 <shapr> you know arrows? the generalization of monads?
13:29:53 <dash> hmmmmm
13:30:00 <dash> i have a feeling this is a different kind of thing
13:31:06 <shapr> I think yampa is a lot like twisted.
13:32:06 <dash> it's going to take someone smarter than me to explain how you'd do the human-level sim stuff we want in haskell
13:32:28 <shapr> oh, I read that paper and I had some ideas...
13:32:36 <dash> we can't even figure out how we want it to work in python, though, so...
13:33:05 <shapr> I may not be smarter than you, but I am far less connected to reality, so maybe I can still come up with a solution ;-)
13:33:15 <dash> Heh
13:34:28 <dash> the essential problem is "how do you model simulation objects in a way that new properties can be added incrementally with well-defined interactions with existing properties"
13:34:44 <shapr> I remember thinking about multimethods the first time I read this.
13:34:48 <dash> Yeah
13:34:53 <dash> multimethods are a similar idea
13:35:14 <dash> except here we want to control dispatch order and stuff too
13:37:05 * CosmicRay returns
13:37:44 <CosmicRay> anyway shapr, the all about monads doc is still rather opaque to me on the question of combining Error with IO
13:38:09 <CosmicRay> I think my question comes down to how to code up a do block in the combined ErrorT monad
13:38:32 <CosmicRay> I like the feature of the Error monad where the first Left result will ignore the remaining function bindings and return the error immediately
13:38:44 <shapr> I am too fluffy.
13:38:45 <CosmicRay> I can't seem to make that play nicely with, for instance, things that return IO ()
13:38:56 <shapr> why not?
13:39:14 <CosmicRay> it complains that putStrLn is of type IO () instead of type Either Foo Bar
13:39:31 <shapr> If I use too much conditioner, I resemble a dandelion when my hair dries.
13:39:41 <CosmicRay> heh
13:39:47 <shapr> can you put your code on the paste page?
13:40:02 <CosmicRay> yeah, url?
13:40:11 <shapr> @wiki HaskellIrcPastePage
13:40:11 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:40:31 <shapr> Did you check out the transformers example21.hs in the nomaware tutorial?
13:41:03 <shapr> @index liftIO
13:41:04 <lambdabot> Control.Monad.Cont,Control.Monad.Error,Control.Monad.List,Control.Monad
13:41:04 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Trans,Control
13:41:04 <lambdabot> Monad.Writer,GHC.IOBase
13:41:16 <shapr> @type Control.Monad.Error.liftIO
13:41:17 <lambdabot> Control.Monad.Error.liftIO :: forall m a.
13:41:17 <lambdabot> 			      (Control.Monad.Trans.MonadIO m) =>
13:41:17 <lambdabot> 			      IO a -> m a
13:42:46 <CosmicRay> ok it's pasted
13:42:51 <CosmicRay> at the very bottom
13:43:28 <shapr> have you tried liftIO?
13:43:37 <CosmicRay> yes, I saw that example, but the mechanics of the Cont thing are obscure, and I'm not understanding how to translate it into ErrorT
13:43:45 <CosmicRay> yes, in every possible permutation I could think of
13:43:54 <shapr> hm
13:44:46 <CosmicRay> for instance:
13:44:50 <CosmicRay>               liftIO $ putStrLn "In the test"
13:44:52 <CosmicRay> dosen't help :-)
13:45:01 <shapr> is ConfigParser in the latest MissingH deb?
13:45:07 <CosmicRay> no
13:45:13 <CosmicRay> would you like me to dcc it to you?
13:45:27 <dash> CosmicRay: try (liftIO putStrLn) "etc"
13:45:34 <CosmicRay> there are some other functions in there I kludged around
13:45:37 <dash> oh wait
13:45:43 <dash> never mind i'm thinking of something else i think
13:46:02 <shapr> I don't have DCC
13:46:18 <CosmicRay> shapr: I could e-mail it to you
13:46:21 <shapr> ok, sure
13:46:55 <CosmicRay> shapr: what address?
13:47:54 * CosmicRay just assumes your usual then :-)
13:48:13 <CosmicRay> shae@
13:51:04 * Lemmih is impressed by the large number of Haskellers in #haskell.
13:52:11 <boegel> Lemmih, the community is growing !
13:55:01 <dash> Lemmih: what
14:00:36 <boegel> wolfman8k, are you there ?
14:02:24 <boegel> @seen mithckov
14:02:25 <lambdabot> I haven't seen mithckov
14:07:58 * shapr hops happily
14:08:19 <shapr> bloomberg: hiya! Are you new here? Do you want the intro?
14:08:23 * CosmicRay backs away from shapr slowly
14:08:32 * Lemmih bounces with shapr.
14:08:36 <stepcut> two wheels bad, one wheel good!
14:08:48 <bloomberg> yeh; dont mind
14:09:00 <shapr> CosmicRay: I was practicing my unicycle hopping today. I had some passing pedestrians really worried.
14:09:21 <CosmicRay> wow
14:09:24 <CosmicRay> that does sound a little scary :-)
14:09:30 * boegel gives CosmicRay a push in the back, so he bumps into shapr
14:09:36 <CosmicRay> heh
14:09:36 <shapr> bloomberg: Are you learning Haskell, or a long time user? As in, do you want so the intro to Haskell, or the intro to the channel itself?
14:10:02 <bloomberg> err probably not a long time user; doing it as part of a FP course
14:10:16 <shapr> Ah, ok then. So you probably already know some Haskell.
14:10:27 <Lemmih> There's an intro to this channel?
14:10:32 <shapr> In that case, the handy features are lambdabot, the Haskell Wiki, and the channel logs.
14:10:36 <bloomberg> oh yeh..been at it for 8 weeks
14:10:41 <shapr> Lemmih: sure, you want the intro too?
14:10:54 <bloomberg> this intro sounds quite good!
14:10:55 <Lemmih> I would like that, yes.
14:11:07 <shapr> lambdabot has useful features like @index @type and @info
14:11:19 <shapr> if you can't remember which module to import to get a certain function...
14:11:27 <shapr> @index isAlpha
14:11:28 <lambdabot> Data.Char,GHC.Unicode,Char
14:11:46 <shapr> or you want to know the type of some function
14:11:58 <edi> hiya all!
14:12:02 <shapr> @type Data.Char.isAlpha
14:12:03 <lambdabot> Data.Char.isAlpha :: Char -> Bool
14:12:07 <boegel> hey edi 
14:12:12 <shapr> @info Eq
14:12:13 <lambdabot> -- Eq is a class
14:12:13 <lambdabot> class Eq a where {
14:12:13 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
14:12:13 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
14:12:13 <lambdabot>     }
14:12:28 <shapr> the info and type commands are the same as in GHCi
14:12:50 <shapr> index uses haddock's index.
14:13:32 <shapr> On to the next feature of the tour, the Haskell Wiki has a bunch useful stuff...
14:13:35 <shapr> @wiki FundamentalConcepts
14:13:35 <lambdabot> http://www.haskell.org/hawiki/FundamentalConcepts
14:13:49 <shapr> and pages like HaskellNewbie, and more
14:14:11 <bloomberg> heh: "Recursion": see "Recursion"
14:14:15 <CosmicRay> grin
14:14:15 <shapr> the logs of channel discussion over the last three years or so are mentioned in the channel topic.
14:14:30 * shapr grins
14:14:33 <derelm> hi everyone! i am stuck with a thing i have to do for my course: using lamda-expressions i should build a function like this: f(f,g,anyop,x) -> f(x) anyop g(x)   where anyop may be anything like (++) or just (+)
14:14:53 <shapr> ok, that was the intro, do you have any questions?
14:14:56 <Igloo> CosmicRay: Did you work out the liftIO problem?
14:15:09 <dash> i have a question
14:15:12 <bloomberg> yes whats lambadot? (being very ignorant probably)
14:15:14 <CosmicRay> igloo: not yet, I'm waiting for shapr to finish his tour so I can bug him about it :-)
14:15:16 <shapr> dash: you don't count :-P
14:15:23 <dash> is unicycling mandatory
14:15:24 <CosmicRay> Igloo: however I take help from anyone :-)
14:15:26 <shapr> dash: oh ok, you can ask a question.
14:15:29 * shapr laughs
14:15:44 <shapr> bloomberg: lambdabot is an irc bot written in Haskell.
14:16:15 <CosmicRay> Igloo: my basic problem is: how do I maintain the useful "stop everything now if I get a Left" property in a situation where some things might return an Either and others might return an IO ()?
14:16:32 <shapr> dash: No, unicycling is not mandatory. If I'm talking about it too much, I can take it to another channel =)
14:16:38 <dash> shapr: heh :)
14:16:38 <CosmicRay> Igloo: I have found that I have basically been doing things the "old" way by using the equivolent of liftM various places
14:16:40 <derelm> well what i tried to solve the problem described above, i used: myfunc = \func1 func2 anyop value -> (func1 value) anyop (func2 value)
14:16:53 <derelm> but that only seems to raise a rather large exception :(
14:17:08 <dash> derelm: well, anyop is a function
14:17:20 <dash> derelm: so call it like a function
14:17:22 <Lemmih> derelm: You can specify infix operator like this: `func`
14:17:23 <derelm> ?
14:17:29 <derelm> yes
14:17:41 <shapr> lambdabot sources are online if you want a copy.
14:17:41 <derelm> i tried that aswell, doesn't work
14:18:13 <Igloo> CosmicRay: Are you trying to use ErrorT CPError IO?
14:18:17 <wolfman8k> boegel: yo
14:18:37 <Igloo> If so, d and get need to return things in that monad
14:19:08 <Lemmih> derelm: Works for me.
14:19:10 <derelm> when i enter "myfunc (abs) (abs) (++) 5" i get "Occurs check: cannot construct the infinite type: ..."
14:19:13 <Igloo> If you write them with throwError and return then you should be able to give them types for anything in the MonadError class
14:20:09 <Lemmih> derelm: (++)?
14:20:14 <derelm> Lemmih: to be honest, now i changed my version to that one using the ``s and now it says: No instance for (Num [a])"
14:20:38 <derelm> Lemmih: ok (++) was a bad example :)
14:20:52 <Lemmih> derelm: (+) would probably be better (-:
14:21:05 <boegel> wolfman8k, can I show you some images of transparency tests I'm doing ?
14:21:09 <dash> derelm: it is telling you that numbers aren't lists :)
14:21:12 <wolfman8k> boegel: yes
14:21:14 <derelm> Lemmih: well, yes there are a whole lot of operators that would be better ;)
14:21:24 <derelm> dash: i just noted that, thanks ;)
14:21:39 <Lemmih> derelm: [1,2] ++ [3,4] = [1,2,3,4]
14:22:06 <derelm> now my question, if my functions would be using lists (and return them as well) would (++) work?
14:22:07 <boegel> wolfman8k, I'll put them on my website, as a intermediate result... but there's still something wrong with it though...
14:22:20 <wolfman8k> boegel: ok
14:22:22 <wagle> derelm: try it aqnd find out!
14:22:22 <resiak> derelm: Yes.
14:22:38 <wagle> aqnd == and
14:23:38 <wagle> derelm: what is :t myfunc?
14:24:00 <derelm> h :: forall t t1 t2 t3.
14:24:00 <derelm>      (t1 -> t3) -> (t1 -> t2) -> (t3 -> t2 -> t) -> t1 -> t
14:25:03 <wagle> h' f g x = h f g (++) x
14:25:15 <wagle> what is :t h'?
14:25:39 <CosmicRay> Igloo: yes
14:25:42 <derelm> err?
14:25:52 <CosmicRay> Igloo: (to  ErrorT CPError IO)
14:26:24 <wagle> derelm: which error?
14:26:42 <wagle> gotta put the defn of h' in the file with h
14:26:47 <derelm> by saying err i really meant "what do you mean" ;)
14:27:33 <wagle> then reload, then ask :t h'
14:28:06 <derelm> h' :: forall a t. (t -> [a]) -> (t -> [a]) -> t -> [a]
14:28:28 <Igloo> CosmicRay: See my previous 2 lines then  :-)
14:28:39 <wagle> .. so it restricted the type of f and g not quite as much as you asked?
14:29:05 <CosmicRay> Igloo: hmm.  But I want them to be usable in the more general Error monad
14:29:11 <derelm> i am sorry, i can't really interpret what :t h(') told me ... too much of a beginner i am
14:29:15 <CosmicRay> Igloo: so I can use them in the absence of IO as well
14:29:34 <CosmicRay> Igloo: is there a magic type signature that would do that?
14:29:39 <wagle> derelm: you asked: 14:21 < derelm> now my question, if my functions would be using lists (and 
14:29:42 <wagle>                 return them as well) would (++) work?
14:30:15 <derelm> yes, but how do i read that from the type? i got problem seeing that
14:30:22 <wagle> i had you defined a new function, h', that was h with the op argument being (++)
14:30:29 <derelm> yes
14:30:52 <Igloo> Hmm, are you allowed to say MonadError CPError m => String -> m e ConfigParser?
14:30:54 <wagle> from the type of h', what is the type of f?  of g?  of x?
14:32:13 <Igloo> It can be infered if not, anyway
14:36:36 <boegel> wolfman8k, almost ready :)
14:36:40 <wolfman8k> boegel: ok
14:37:20 <CosmicRay> hmm.
14:37:28 <edi> goodnight
14:37:35 <boegel> there are some strange 'rings' in my images, and I don't know if they're supposed to be there
14:37:44 <boegel> goodnight edi 
14:38:05 <CosmicRay> Igloo: maybe, but I'm not sure how that does it :-)
14:38:23 <Igloo> Oh, I meant "MonadError CPError m => String -> m CPError ConfigParser"
14:39:07 <wagle> derelm: am i still losing you?
14:39:33 <boegel> wolfman8k, check my website, I'm uploading the images now
14:39:35 <derelm> wagle: oh, sorry, what should i be doing? guess i didn't get you 
14:39:56 <derelm> wagle: you wanted the type of the functions i use as an argument?
14:39:59 <boegel> if you look at depth 3 and 4 with transparency, the transparent sphere has 'rings' on it... any idea what they are ?
14:40:21 <Igloo> On http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.Error.html you can see "Error e => MonadError e (Either e)" and "(Monad m, Error e) => MonadError e (ErrorT e m)" under instances
14:40:49 <CosmicRay> to be sure a lot of things on that page have me a little confused
14:40:58 <boegel> wolfman8k, do you have the url to my website ?
14:41:04 <derelm> f :: Integer -> Integer; g :: Integer -> Integer      <- well these are rather easy to understand
14:41:07 <CosmicRay> I think I'm getting better at it, but reasoning about monads is not second nature to me yet
14:41:12 <Igloo> So if e = CPError then you can substitute the two m's you care about and find they both satisfy the requirements
14:41:16 <wolfman8k> boegel: it's around somewhere
14:41:16 <wagle> derelm: you wanted to know what happened when the op argument of h was (++)..  h' answers that question if you can decipher it
14:41:20 <CosmicRay> Igloo: that would be slick.
14:41:32 <boegel> wolfman8k, http://studwww.ugent.be/~kehoste/thesisPublic/website
14:41:43 <CosmicRay> Igloo: so, having done that, I could have: do {x <- get cp "foo" "bar"; putStrLn x; y <- get...; etc} ?
14:41:53 <derelm> wagle: well, yes but i am unable to, guess i will have to practice reading type defn
14:41:54 <Igloo> liftIO $ putStrLn x
14:41:58 <CosmicRay> ah.
14:42:06 <CosmicRay> but with that one change, it should work?
14:42:10 <Igloo> Yup
14:42:13 <CosmicRay> sweet.
14:42:15 <CosmicRay> thanks
14:42:32 <wagle> derelm: types are essential to understand
14:42:46 <Igloo> Everything in that do block must be in the ErrorT CPError IO monad. liftIO there has type IO a -> ErrorT CPError IO a
14:43:17 <derelm> wagle: well, yes, still they're not that easy to read :(
14:43:18 <wolfman8k> boegel: hm... i have no idea what that is
14:43:42 <boegel> wolfman8k, it shouldn't be there ?
14:43:57 <wolfman8k> boegel: i don't know
14:44:05 <wagle> derelm: if foo has type a -> b -> c, how many arguments does it take?
14:44:06 <derelm> wagle: do you know any easy intro to types? maybe that would help me
14:44:12 <boegel> wolfman8k, also, the second image (depth 1), isn't right, is it ?
14:44:15 <derelm> wagle: guess 2
14:44:37 <wagle> i dont know of an intro to types.  anyone?
14:44:47 <wolfman8k> boegel: i'm not sure
14:45:16 <derelm> wagle: type a -> b -> c  would have 2 arguments and c would be the return type, right?
14:45:20 <wagle> derelm: correct.  whats the type of the first argument?  the second?  the result?
14:45:21 <boegel> this transparent thing is the hardest bit I've done so far... you have to take so much stuff into accoutn
14:45:33 <boegel> like reversing the normal when inside a sphere, and so on
14:45:34 <wagle> derelm: what was the type of h'?
14:45:57 <derelm> h' :: forall a t. (t -> [a]) -> (t -> [a]) -> t -> [a]
14:46:13 <wagle> how many arguments does h' take?
14:47:20 <derelm> wagle: well, i do know it takes 3 but i think i wouldn't know when reading the type. that parenthesis somehow "disturbs" me, i am not quite sure what it means...
14:47:30 <monochrom> You can ignore "forall a t." for the moment.
14:48:28 <wagle> a -> b -> c is not the same type as (a -> b) -> c..
14:48:51 <wagle> a -> b -> c IS the same type as a -> (b -> c)
14:48:52 <derelm> wagle: i guess it means that a and b somehow relate
14:49:04 <boegel> wolfman8k, do you have any hints for me on working with transparency ?
14:49:17 <monochrom> If you understand a->b then you understand (a->b)->c
14:49:26 <derelm> monochrom: sure? ;)
14:49:58 <wagle> derelm: what is the type of the first arg of h'?  the second arg?  the third?  the result?
14:49:58 <wolfman8k> boegel: best thing i can say is try looking at the code in that flipcode raytracing tutorial
14:50:23 <derelm> wagle: reading from the type defn above?
14:50:31 <wagle> derelm: yes
14:50:39 <monochrom> In the same way if you understand a/b then you understand (a/b)/c
14:50:53 <derelm> wagle: first and second arg: (t -> [a] third would be t
14:51:11 <boegel> wolfman8k, I did that :)
14:51:17 <wagle> ok..  now "t" is a type.  dunno which one yet.
14:51:24 <derelm> ok
14:51:31 <wagle> "a" is also a type, dunno which one yet.
14:51:40 <boegel> that helped me with solving my problem with the mirror effect (i wasn't reversing the normals inside the sphere's)
14:51:42 <derelm> but why has it a special parenthesis?
14:51:54 <derelm> i mean [a] and not just a
14:52:08 <monochrom> parentheses are seldom special
14:52:16 <wagle> but whatever type "t" is, its the type that f accepts, that g accepts, and what the value of "x" is
14:52:24 <monochrom> Oh that one. Lists of type-a contents.
14:52:51 <wagle> ahh..  "[a]" means "list of elements of type a"
14:53:16 <monochrom> [True, False, False, True] has type [Bool]
14:53:18 <derelm> ah ok
14:53:35 <derelm> so trying to read the def again:
14:53:52 <wagle> so we know that f and g return lists, AND that they BOTH return lists of elements of type a, even if we dont know what a is yet
14:54:13 <derelm> it says whatever type you'll be using in first and second arg, the result well be of the very same type (and the arg will need to have the same type) ?
14:54:52 <wagle> yes, f and g will have the same type
14:55:05 <derelm> thus the result will be of that type
14:55:19 <wagle> .. each time you apply h'..
14:55:45 <derelm> leading to: if i input lists (and my functions are able to handle these) i'll get a list as output?
14:56:04 <wagle> .. but different applications of h' might give f and g a different "same type", modulo the t->[a] constraint
14:56:27 <wagle> does the type "t" need to be a list?
14:56:56 <derelm> guess it doesn't need to be a list, but it might be a list
14:57:08 <derelm> argh
14:57:09 <derelm> wait
14:57:28 <derelm> the output needs to be a list ( [a] )
14:57:33 <monochrom> t may be anything
14:57:38 <derelm> yes
14:57:51 <derelm> monochrom: thanks you waited :)
14:58:02 <monochrom> A haskell function of type t->[a] doesn't seem to do very interesting things.
14:58:16 <wagle> (:[])\
14:58:21 <derelm> so t may be anything, but the result will be a list  ([a]) ?
14:59:18 <wagle> f x = r where r = x : r
14:59:31 <wagle> hmm..
14:59:38 <wagle> f x = x : f x
15:00:11 <wagle> f x = x : f x
15:00:12 <derelm> sorry, my clclient died unexpectedly :(
15:00:24 <monochrom> @type let f x = x : f x in f 0
15:00:31 <lambdabot> let f x = x : f x in f 0 :: forall a. (Num a) => [a]
15:00:42 <monochrom> @type let f x = x : f x in f
15:00:44 <lambdabot> let f x = x : f x in f :: forall a. a -> [a]
15:00:58 <monochrom> This is different from t->[a]
15:01:28 <wagle> so i made t == a
15:01:31 <wagle> eh
15:01:49 <wagle> f x = [x] : f x
15:01:53 <boegel> g'night everyone !
15:02:02 <boegel> and wolfman8k , thanks for the help
15:02:02 <monochrom> That's untypable.
15:02:06 <wagle> f x = read x : f x
15:02:09 <derelm> i think i missed the linking text, feeling pretty lost, can you please repost from "A haskell function of type t->[a] doesn't seem to do very interesting things."?
15:02:30 <monochrom> @type let f x = read x : f x in f
15:02:31 <lambdabot> let f x = read x : f x in f :: forall a. (Read a) => String -> [a]
15:02:32 <wolfman8k> np
15:02:44 <monochrom> String->[a] is still different from t->a
15:02:49 <wagle> derelm: i'm busy vaguely/sorta disagreeing with that statement
15:03:06 <wagle> so String = t?  SO WHAT?
15:03:19 * np_hard actually used haskell at work today
15:03:48 <derelm> well as i understand t-> [a] t might as well me String-> [a] or Num -> [a]
15:03:55 <derelm> be
15:03:58 <monochrom> Alright let me make myself clear.  (forall t a. t->[a]) is different from (forall a. String->[a]).
15:04:24 <wagle> blue is different from color
15:04:29 <derelm> in the way, that the former is more general?
15:04:52 <wagle> (flip wagles last statement to "color is different from blue"
15:04:54 <wagle> )
15:05:00 <monochrom> And my statement needs a corresponding clarification.  A haskell function of type (forall t a. t->[a]) doesn't seem to do very interesting things.
15:05:35 <wagle> where were we discussing such a function?
15:06:02 <monochrom> h' takes such a thing as parameters.
15:06:19 <wagle> no it doesnt
15:06:41 <wagle> the forall is on the outside
15:07:01 <monochrom> I see what you mean.
15:08:05 <wagle> to wit, f and g and x all share the same instantiation of t
15:08:24 <derelm> yes
15:08:41 <Lemmih> np_hard: Yay!
15:08:46 <derelm> to put it in simple english: they need to be of the same type
15:09:56 <wagle> well, i'm trying to indicate that you can follow h' f g 1 with h' f g "a"
15:10:56 <wagle> the two different applications of h' can instantiate [?] t to different types
15:11:40 <wagle> (i'm using the word instantiate, even though i'm not sure thats the correct word for the concept these days)
15:11:52 <derelm> i don't mind ;)
15:12:58 <wagle> (t -> [a]) is a general thing..  instantiating t to Integer produces the type (Integer -> [a]), but still leaves you free to later instantiate t to Char
15:13:19 <derelm> ok
15:14:16 <wagle> so i'm using the word instantiate to emphasize that I'm not throwing the general type out when I get specific for typechecking and evaluating a particular expression
15:14:59 <derelm> ok
15:15:05 <wagle> so..  noone out there knows of any tutorials on haskell types?
15:15:11 <derelm> :)
15:15:28 <derelm> i think you're doing a great job
15:15:49 <monochrom> It's easier to find a tutorial on a*(b+c) = a*b + a*c
15:16:24 <derelm> @type abs
15:16:25 <lambdabot> abs :: forall a. (Num a) => a -> a
15:16:28 <resiak> wagle: My uni course ;)
15:16:30 <wagle> derelm: except i'm supposed to get some work done..  8)
15:16:39 <derelm> wagle: oh, yes...
15:17:06 <wagle> derelm: with h', i tried to show you how to answer your own question..
15:17:24 <wagle> i hope you can interpret the answer now
15:17:26 <derelm> wagle: i noticed that! thanks
15:17:59 <derelm> now in type abs i see "=>" what does that mean?
15:18:00 <wagle> derelm: you should try sending all sorts of things at :t 
15:18:35 <derelm> wagle: i really should do so. whenever i wrote a function ... to train reading tyapes
15:18:36 <wagle> "with the constraint that "Num a", this is of type ..."
15:18:44 <np_hard> yep, used it where I would have otherwised used perl or python, generating code from a csv
15:19:17 <derelm> ah ok
15:20:12 <wagle> so abs will operate on any type a that is currently an instance of the Num class 
15:20:39 <wagle> @info Num
15:20:40 <lambdabot> -- Num is a class
15:20:40 <lambdabot> class (Eq a, Show a) => Num a where {
15:20:40 <lambdabot>     (-) :: a -> a -> a {- has default method -};
15:20:40 <lambdabot>     (*) :: a -> a -> a;
15:20:40 <lambdabot>     (+) :: a -> a -> a;
15:20:41 <lambdabot>     negate :: a -> a {- has default method -};
15:20:43 <lambdabot>     signum :: a -> a;
15:20:45 <lambdabot>     abs :: a -> a;
15:20:47 <lambdabot>     fromInteger :: Integer -> a;
15:21:37 <wagle> you should also play with the :i command (ie, without flooding the irc channel 8) )
15:21:51 <wagle> ":i Num"
15:22:28 <resiak> Is it not considered good practice to type functions with :: oneself?
15:24:18 <monochrom> http://www.cs.utoronto.ca/~trebla/fp/lecture-06.ps explains type classes (shameless plug)
15:50:45 <Cale> resiak: It's usually considered good documentation to provide type signatures in code.
15:51:19 <resiak> Cale: Okay, fair point.
15:53:29 <dons> in fact, -Wall -Werror will enforce this quite well.
15:53:51 <dons> (a long with a lot of other linting)
15:58:31 <dons> tuomov: ping?
15:58:52 <dons> hmm. maybe too late
16:01:11 <wagle> @seen tuomov
16:01:11 <lambdabot> tuomov is in #darcs and #haskell.
16:01:33 <wagle> @last tuomov
16:01:33 <lambdabot> Sorry, I don't know the command "last", try "lambdabot: @listcommands"
16:02:48 <wagle> @listcommand
16:02:49 <lambdabot> Sorry, I don't know the command "listcommand", try "lambdabot: @listcommands
16:02:52 <wagle> @listcommands
16:02:52 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
16:02:52 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
16:02:52 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
16:02:52 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
16:02:52 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
16:02:54 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
16:02:56 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
16:02:58 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
16:03:00 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
16:03:15 <wagle> (tried to do that privately, no go)
16:05:14 <dons> you can msg lambdabot, and run commands privately
16:06:05 <wagle> my /msg was rejected
16:06:37 <resiak> wagle: /msg lambdabot @listcommands works perfectly.
16:06:56 <wagle> i tried that and got an error
16:07:00 <dons> you have to supply an arg to \/msg
16:07:10 <wagle> shrug
16:07:18 <dons> otherwise, I have no idea. seems odd
16:07:40 <wagle> i'll try harder next time
16:07:50 <dons> of course, if you msg \bot privately, shapr can hack your box...
16:08:03 <wagle> @seen tuomov
16:08:03 <lambdabot> tuomov is in #darcs and #haskell.
16:08:17 <wagle> man, i'm tired
16:08:57 <dons> I wonder why posix signals aren't mapped to exceptions, by default
16:09:15 <wagle> out of band
16:09:17 <dons> SignalExceptions, for example
16:10:57 <wagle> signals arent exceptions
16:11:30 <wagle> i resume where i left off..  i dont unroll the stack looking for a signal handler
16:11:43 <wagle> the current code is not terminated..
16:12:02 * wagle SIGKILL's his rambling
16:12:17 <dons> ok. sure. but at least in yi I want to either ignore, or clean up nicely and quit
16:12:28 <dons> which is very exception-ish behaviour
16:12:33 <dons> darcs does the same thing
16:12:37 <wagle> could have the signal handler generate an exception
16:12:55 <dons> yes. exactly. that's what I do, and darcs too. a dynamic exception
16:13:06 <wagle> but note that the signal handler is supposed to syscall a "i'm done"
16:13:10 <dons> but if we've both implemented this, I wonder how common the pattern is
16:13:49 <wagle> sometimes, this is automatic (see the gorey details in the man page)
16:14:08 <dons> yeah, maybe it is automatic. I don't think there is any haskell code to do this
16:14:31 <wagle> i seem to remember the kernel poking a "i'm done"
16:14:46 <wagle> code out to user space
16:15:02 <wagle> its been too long
16:15:13 <monochrom> In my opinion, unix signals were invented in a medieval time.  People back then haven't discovered exceptions and continuations.
16:15:50 <wagle> jonathan shapiro (EROS, etc) thinks they are fundamentally broken
16:15:52 <dons> ah. there's some magic rts code for dealing with catching
16:16:24 <wagle> but signals ARE asynchronous, and exceptions are synchronous
16:16:36 <dons> except for asynchronous exceptions..
16:16:51 <wagle> something else is signalling you, you are generating your own exceptions
16:17:38 <wagle> i never finished figuring out how asynchronous exceptions could even be possible
16:17:57 <wagle> (ie, low-latency interrupts)
16:18:41 <wagle> how can you interrupt a haskell program between any two machine instructions?
16:19:30 <Igloo> Err, what are you trying to achieve here?
16:19:39 <monochrom> Ah, I see my mistake.
16:19:40 <wagle> shall i just start reading again, or is there a short pithy explanation?
16:20:37 <wagle> (i gotta learn to put papers i have open in viewers on my job list or else they get lost when my machine or view client crashes)
16:21:03 <dons> crashes!?
16:21:28 <dons> I can't remember the last time my machine crashed
16:21:38 <wagle> you never update?
16:21:55 <wagle> you never backup?
16:21:58 <dons> I live on cvs. but anyway,  maybe it is a different os
16:23:11 <wagle> actually my machine crashed when the battery decided to fall out while the machine wasnt suspended.. 
16:23:38 <dons> ok.. that's reasonable :)
16:23:51 <wagle> good  B)
16:27:15 <Lunar^> GHC RTS schedule a new thread for each signal received
16:27:24 <Lunar^> (with a registered signal handler)
16:28:32 <Lunar^>     scheduleThread(createIOThread(RtsFlags.GcFlags.initialStkSize,
16:28:33 <Lunar^>             (StgClosure *) *deRefStablePtr(next_pending_handler));
16:28:43 <Lunar^> in Signal.c
16:29:34 <wagle> in the other universe, there would be no C code..  
16:29:57 <Lunar^> wagle: C-- is maybe one of the answer
16:30:11 <Lunar^> wagle: I would be glad for an assembler producing Monad also :)
16:30:13 <jadrian> hello
16:32:21 <jadrian> must I declare derived instances together with the data declaration, or is there some way to derive them elsewhere?
16:32:51 <Lunar^> jadrian: with the data declaration
16:32:57 <jadrian> :(
16:33:16 <Lunar^> jadrian: Fun enough, there is a thread ongoing about this on haskell-cafe
16:33:23 <jadrian> oh yeah?
16:33:25 <Lunar^> jadrian: Which class is it for ?
16:33:27 <jadrian> I must have missed it
16:33:41 <jadrian> Lunar^: Show Eq and... let me see
16:34:00 <Lunar^> jadrian: last John Meacham message
16:34:00 <jadrian> Lunar^: Show, Eq and Ord
16:35:11 <Lunar^> jadrian: Couldn't you change the original source code ? Or implement the type  class yourself ?
16:36:34 <jadrian> Lunar^: got it, I'm not following that thread
16:36:58 <jadrian> Lunar^: not really
16:37:44 <jadrian> Lunar^: in one of the cases I'm using the module where data is defined in more than one program
16:37:58 <jadrian> Lunar^: in some I want a custom Show
16:38:08 <jadrian> Lunar^: Eq, etc
16:38:33 <jadrian> Lunar^: in others I want to use the usual derived instances
16:38:47 <wagle> i think i did a overlapping instances trick once, where once instance was derived, and the other explicit
16:38:49 <jadrian> Lunar^: but if I derive them, then I cannot override them afterwards
16:39:22 <wagle> i wanted strings to display without the quote marks..
16:39:30 <jadrian> wagle: nice :) I try to stay away from overlaping instances :)
16:39:40 <jadrian> some other times it's just a matter of organization
16:39:57 <jadrian> I may want all the instance definitions in some file
16:40:47 <wagle> deriving is a hack..  dunno what The Right Way [TM] is, though
16:41:53 <wagle> need access to the deriving machinery
16:42:10 <wagle> or something..
16:42:57 <Lunar^> wagle: Template Haskell, DRiFT
16:43:17 <wagle> i was trying to avoid saying template haskell..  8)
16:44:13 <arjanb> maybe generic haskell can be combined with deriving somehow..
16:44:41 * jadrian is off to bed!
16:45:06 <wagle> google is dead to me.  what is DRiFT?
16:46:02 <wagle> google lives!  nevermind
16:47:36 <dons> DrIFT is a preprocessor for automatically deriving classes. it's very good
16:47:58 <dons> the Binary class GHC uses for parsing .hi files is generated by DrIFT
16:48:56 <jadrian> bye all
16:48:59 <dons> an ELF .o obj parser a colleague uses was also derived from DrIFT, I believe
16:49:59 <dons> http://repetae.net/john/computer/haskell/DrIFT/
16:51:25 <wagle> yeah, that's whay google finally gave me after timing out the first three tries
16:56:08 <wagle> s/whay/what/
16:59:58 <wagle> does vim handle unicode?
17:01:39 <dons> :help utf8
17:01:44 <Crewden> wagle: :help unicode ?
17:02:17 <wagle> nm..  i couldnt get xemacs to do it, but now i find that i cant get anything to do it
17:02:58 <wagle> what does this look like:â
17:07:17 <Pseudonym> aH@
17:07:30 <Pseudonym> I need some help with wording.
17:07:58 <Pseudonym> Basically, what I've done is for an operation, I've plotted the disk block number vs time.
17:08:04 <Pseudonym> So there are a bunch of I/O requests.
17:08:08 <wagle> odd..  i cant get a tcsh or bash shell to see the chars on my mac, but i can do it if i then login to a linux machine (in the same terminal emulator)
17:08:21 <Pseudonym> And I've plotted where the requests are for, on the disk.
17:08:39 <Pseudonym> What I want to say is that a shallow straight line means that the disk head doesn't move very much.
17:08:52 <Pseudonym> But if it looks like a dithered rectangle, then the disk head is moving a lot, which slows things down.
17:09:29 <Pseudonym> Dunno if anyone understood that.
17:09:43 <SyntaxNinja> is it just me, or is the ghc manual missing documentation of -M?
17:10:19 <Igloo> I think I have a patch to add that I haven't committed to CVS yet
17:10:44 <wagle> Pseudonym: i did..  maybe you should graph the movement (first differential?) and the throughput?  
17:12:12 <wagle> hmm..  the head position might be important to you, though..  so things like standard deviations, etc would be important
17:14:18 <Pseudonym> The thing about plotting it this way is you get two pieces of information.
17:14:35 <Pseudonym> One is how fragmented it is, the other is how much of the disk you have to seek through.
17:14:58 <Pseudonym> I have one graph where the disk head is seeking from one end of the disk to the other.
17:15:03 <Pseudonym> Literally.
17:15:23 <Pseudonym> Throughput is actually fairly uninteresting.
17:16:20 <wagle> well, if you are reordering the accesses to track the current position of the read head, the movement might not be as much a problem
17:16:56 <Pseudonym> This is just measurement.
17:17:13 <Pseudonym> I'm trying to find out a) how fragmented a file is (both internal and external), and b) how much of a problem this causes.
17:17:37 <wagle> i'm trying to refer to (b) by the word "throughput"
17:17:37 <Pseudonym> Throughput is less interesting than the amount of time spent in iowait.
17:18:32 <wagle> what i care about is how much a problem it is, and might be interested in a graph that tells me
17:19:25 <Pseudonym> Right.
17:21:17 <Pseudonym> Basically, I'm showing a graph.
17:21:23 <Pseudonym> Now I need to explain what it means.
17:21:41 <Pseudonym> OK, here's one example.
17:21:48 <wagle> dunno term..  lousy approximations (to send through a thesaurus or something) might be "jitter", "calmness", "energy", "amplitude", "hysteresis" [sp?], ..
17:21:48 <Pseudonym> I have a B-tree file.
17:21:54 <Pseudonym> Hmmm.
17:22:10 <Pseudonym> I said: The apparent structure us a set of columns (one per segment) densely filled with random dots.
17:22:18 <wagle> the elevator algorithm literature should have a term
17:22:39 <Pseudonym> This means that accesses to the file were apparently randomly ordered during this operation, indicating an extremely high degree of fragmentation.
17:22:42 <Pseudonym> Does that read well?
17:24:41 <wagle> the use of the word "apparent" is weak..  there are statistical measures of randomness..
17:25:04 <wagle> the human eye is pretty odd when looking at random data
17:25:42 <wagle> hence the statistical measures become necessary when claiming randomness
17:25:50 <Pseudonym> Well I'm not claiming they're random.
17:25:56 <Pseudonym> I'm claiming they're all over the place.
17:26:04 <Pseudonym> But I need a technical term for that. :-)
17:26:18 <Riastradh> Varied?
17:26:39 <wagle> statistical lit has a term, but i'm too untrained to know what it is
17:27:13 <wagle> i have a book (at home) that would tell me..  8/
17:27:16 <Riastradh> Expansive?
17:27:27 <Riastradh> Broad?
17:27:34 <Pseudonym> Hmmm.
17:27:44 <Pseudonym> But it's not just the extent that's the issue.
17:27:46 * wagle is thinking
17:27:57 <Pseudonym> If you read 1GB from one end of the disk, then 1GB from the other, that's not an issue.
17:28:13 <Pseudonym> If you read one block from one end, then one block from the other and so on until you hit 2GB, _that's_ a problem.
17:28:54 <wagle> i keep thinking "high frequency" (wrt FFT), but keep rejecting that
17:29:55 <wagle> large magnitudes at high frequencies..
17:30:31 <wagle> but there must be a simpler way to say that...  FFT analysis seems a bit over the top
17:30:46 <Pseudonym> Right.
17:30:58 <Pseudonym> I want to say "it looks like a dithered rectangle".
17:32:41 <wagle> word of the moment is "oscillatory"
17:36:12 <wagle> i have a vote for "polymodal"..
17:38:11 <wagle> candidate antonym: quiescient
17:39:26 <Pseudonym> "Quiescent" is a misnomer in this case because it suggests no activity.
17:40:17 <wagle> antonym means "opposite"
17:40:24 <Riastradh> 'Quiescent' is a cool word but inapplicable here.
17:41:03 <Pseudonym> I'm aware what "antony" means.
17:41:06 <Pseudonym> antonym
17:41:27 <Pseudonym> As we can see...
17:41:31 <Pseudonym> @wn quiescent
17:41:35 <lambdabot> *** "quiescent" wn "WordNet (r) 2.0"
17:41:35 <lambdabot> quiescent
17:41:35 <lambdabot>      adj 1: not active or activated; "the quiescent level of centimeter
17:41:35 <lambdabot>             wave-length solar radiation"
17:41:36 <lambdabot>      2: marked by a state of tranquil repose; "the quiescent
17:41:38 <lambdabot>         melancholy of the town"
17:41:40 <lambdabot>      3: being quiet or still or inactive
17:41:42 <lambdabot>      4: causing no symptoms; "a quiescent tumor"
17:41:57 <Pseudonym> Like I said, no activity.
17:42:11 <wagle> so i'm looking for an antonym of quiescient.  geez
17:43:47 <wagle> http://thesaurus.reference.com/search?r=2&q=quiescent
17:44:13 <Riastradh> Not exactly.  There is activity in either case, but the search is for a word describing the scattering of activity.
17:44:27 <Pseudonym> Right.
17:44:33 <Pseudonym> ScaottereScattered.
17:44:37 <Pseudonym> Scattered
17:44:40 <Pseudonym> I( like that.
17:44:54 <Pseudonym> It doesn't sound too obscure.
17:45:05 <Riastradh> Having kybard difficulties, Pseudonym?
17:45:20 <wagle> i think scatter has a formal definition in stats
17:45:20 <Pseudonym> Yed,m O an.
17:45:33 <wagle> but i like scatter the best so far
17:46:12 <Pseudonym> Me too.
17:47:37 <Riastradh> How about 'diffuse?'
17:48:37 <wagle> Synonyms:Â Â 
17:48:39 <wagle> broadcast, catholic, circulated, diluted, dispersed, disseminated, distributed, expanded, extended, general, prevalent, propagated, radiated, scattered, separated, strewn, thin, unconcentrated, universal, widespread
17:49:02 <Pseudonym> "A highly scattered graph indicates a high level of external fragmentation."
17:49:37 <wagle> who is the audience?
17:49:46 <Pseudonym> Database administrators.
17:50:12 <wagle> serious ones?
17:50:16 <Pseudonym> Yes, serious ones.
17:50:24 <Pseudonym> Fairly clueful, but perhaps untrained in statistics.
17:50:40 <wagle> then you have to learn their vocabulary, i think..  
17:51:06 <Pseudonym> Well, statistics isn't my goal here.
17:51:13 <Riastradh> I'd say 'widely scattered' or 'broadly scattered,' not 'highly scattered.'
17:51:16 * Pseudonym nods
17:53:10 <wagle> i'm sure that they know the phenomenon, and have a word for it..  if you don't use it, then you lose "points"
17:53:13 <Riastradh> (If you wanted to use the proper terminology from statistics, you might say:  'A graph with a correlation coefficient close to +/-1 indicates a high level of external fragmentation.')
17:53:57 <wagle> well, i'm wanting to use the term that the audience knows
17:54:10 <Riastradh> (That's why I parenthesized it.)
17:55:20 <wagle> it was bad that it took me so long to realize that targeting to the actual audience (and not the one in my head (biologists)) was important
17:56:20 <wagle> (had a vote for "space filling curves" ..  8) )
18:00:14 <Pseudonym> Riastradh: That's actually not entirely true.
18:00:35 <Pseudonym> Correlation coefficient is almost unrelated to fragmentation.
18:00:46 <Pseudonym> The least fragmented possible file is a flat line.
18:00:52 <Pseudonym> Everything is in the one place on disk.
18:01:01 <Pseudonym> A steep line is unfragmented, but distributed over the disk.
18:01:05 <Pseudonym> Which means extra seeks.
18:01:13 <Riastradh> I'd respond, but my cat impedes me now.
18:01:23 <Pseudonym> Cats are more important.
18:01:39 <Riastradh> Of course.
18:02:15 <Riastradh> He is presently using my left hand as a pillow.
18:02:20 <Pseudonym> Anyway, I'll think about it over lunch.
18:02:27 <Pseudonym> Thanks for your help, people.
18:12:00 <wagle> you in asia somewhere?
18:13:48 <Igloo> What's the rationale behind   import Foo ( bar ) with the spaces around bar, anyway?
18:13:56 <dons> easierr to read?
18:14:17 <dons> that's my rationale
18:14:32 <Igloo> Really? Why don't you see     map ( chr ) xs    then?
18:15:21 <dons> i know. it's a mystery. but perhaps the inner '(' in the import list serves to help the eyes find the import list, when several imports are lined up vertically
18:16:32 <dons> like /* foo
18:16:48 * Igloo sometimes lines the (s up when I want it to be pretty
18:17:00 <Igloo> But I find ( foo ) just ugly. Maybe it's just me  :-)
18:17:30 <dons> yes. I think the analogy with /* ... \n * ... in C is what is happening, and the space after in: -- comment
18:19:24 <dons> and after: -- | haddock comment
18:20:13 <Igloo> It mainly annoys me because my fingers don't type spaces after (, so I have to keep going back and fixing them  :-)
18:20:39 <dons> hehe
18:21:04 <dons> what's annoying for me is -ddump-minimal-imports, which doesn't add ' ' :(
18:21:19 <Igloo> Aha, an ally!
18:21:20 <wagle> i like putting spaces around (, but convention/style doesnt permit that in expressions
18:22:10 <wagle> the space is _required_? 
18:22:29 <Igloo> No
18:23:07 <wagle> eg, i say do { foo ; baz }, and might add space on ( for symmetry
18:23:59 <dons> so, my theory is that '( ' serves as a comment marker in imports lists, so the space is ok. it's not in expressions, as they are completely different beasts
18:24:16 * Igloo spots "\n\n\n\n\n\n\n\n\n\n\n" in the openssl signing code in darcs and worries about its fragility
18:24:21 <dons> another issue is whether to add a space in ranges: [1..2] or [1 .. 2]
18:24:51 <wagle> i spend most of my time visually verifying my code, so am very minded to make life easy on _my_ eyes
18:25:01 <dons> or arrows in list comprehensions: [ x | x <- ys ] vs [ x | x<-ys ]
18:25:10 <Igloo> Oh, that string seems to be being signed for some reason
18:25:19 <dons> (a,b) vs (a, b0
18:25:20 <dons> )
18:25:41 <Igloo> Oh, no, I was right the first time, it's just scary
18:26:13 <Igloo> I'm happy with [1..2]. It's when you have [1, 2..3] that I start getting confused as to where I want spaces
18:26:54 <wagle> i try to stay consistent with the complex cases
18:27:27 <wagle> if you really want generality, insert line-breaks
18:27:49 <dons> maybe import lists should be:  import Foo [a, b, c], then I'd be happy about no spaces
18:28:05 <dons> import Foo: a, b, c
18:28:37 <Igloo> Huh? You're odd  :-Ã¾
18:28:46 <Riastradh> What frivolty regarding unnecessarily complicated syntax!
18:28:57 * Riastradh is nice & happy with simple S-expressions.
18:28:59 * Riastradh ducks.
18:29:11 <Igloo> Riastradh: But do you put spaces after the (s?  :-)
18:29:12 <wagle> i was about to suggest s-expressions
18:29:22 <Riastradh> Of course not!  What a silly idea.
18:29:58 <dons> there's something about the length of the names in the import list that makes me avoid tuple-no-space syntax
18:30:01 <wagle> (import Foo a b c)
18:30:27 <wagle> ( import Foo a b c )
18:30:36 <Riastradh> Hurk!  Glargh!  Bletch!
18:30:49 * wagle jumps out of the way
18:30:49 <dons> import F (a, b, c) vs import F ( unsafeLongFoo, safeFooBar )
18:31:00 <dons> import F with a b c
18:31:21 <dons> import F only a b c
18:31:40 <wagle> import a b c from F
18:31:46 <dons> nice
18:32:10 <dons> though lining up 'import M' is good
18:33:09 <wagle> i'm wondering about let xxx in yyy // yyy where xxx duality for import
18:33:17 <wagle> heh
18:34:52 <wagle> import F (a .:. b .:. c)
18:35:13 <wagle> oops
18:35:20 <wagle> import F (a .*. b .*. c)
18:36:03 <wagle> import F (a :*: b :*: c)
18:36:08 <dons> import F ( all a. a =~ unsafe* )    ;)
18:36:08 <Igloo> Ah crap. Keeping everything in darcs as Docs was going well untill I hit QP-ising in Email
18:36:22 <wagle> QP-ising?
18:36:30 <Igloo> quoted-printable
18:37:23 <wagle> need existential imports..  you imported it, but you cant use it..
18:38:58 <Pseudonym> wagle: I think Australia is technically somewhere in Asia.
18:39:04 <wagle> more seriously, important by type signature..  "i want all the list functions"
18:39:31 <wagle> isnt australia its own continent?
18:39:53 <Pseudonym> Probably, yes.
18:40:01 <wagle> more seriously, _import_ by type signature..  "i want all the list functions"
18:40:29 <wagle> i didnt think australia was 6 hours west of me
18:42:13 <wagle> mannnnn..  i hate the "Constructor overload" of defining a bunch of datatypes that use each other
18:42:42 <Riastradh> Am I correct in thinking that the continent is technically called 'Oceania,' and Australia is but one country within it?
18:42:59 <Pseudonym> No.
18:43:05 <Riastradh> Bother.
18:43:23 <Pseudonym> "Oceania" is a term used by atlas writers to make up for the fact that you've got to put all those countries somewhere.
18:43:36 <Riastradh> ...
18:44:09 <Pseudonym> Well, countries are customarily arranged by continent.
18:44:16 <Pseudonym> Which means the south pacific nations would have nowhere to go.
18:44:34 <Pseudonym> @wn oceania
18:44:36 <lambdabot> *** "Oceania" wn "WordNet (r) 2.0"
18:44:36 <lambdabot> Oceania
18:44:36 <lambdabot>      n : a large group of islands in the south Pacific including
18:44:36 <lambdabot>          Melanesia and Micronesia and Polynesia (and sometimes
18:44:37 <lambdabot>          Australasia and the Malay Archipelago) [syn: {Oceanica}]
18:44:44 <Pseudonym> @en continent
18:44:44 <lambdabot> Sorry, I don't know the command "en", try "lambdabot: @listcommands"
18:44:48 <Pseudonym> @wn continent
18:44:49 <lambdabot> *** "continent" wn "WordNet (r) 2.0"
18:44:49 <lambdabot> continent
18:44:49 <lambdabot>      adj 1: having control over urination and defecation [ant: {incontinent
18:44:49 <lambdabot> ]
18:44:51 <lambdabot>      2: abstaining from sexual intercourse; "celibate priests" [syn:
18:44:53 <lambdabot>          {celibate}]
18:44:55 <lambdabot>      n 1: one of the large landmasses of the earth; "there are seven
18:44:57 <lambdabot>           continents"; "pioneers had to cross the continent on
18:44:59 <lambdabot> [3 @more lines]
18:45:11 <Pseudonym> "one of the large landmasses of the earth" != "a large group of islands"
18:46:52 <wagle> http://www.ri.net/schools/Central_Falls/v/218/t7con.html
18:53:09 <aj> how do i use getEnv in ghci?
18:53:50 <aj> i jsut want the contents of$PATH?
18:54:11 <Igloo> p <- getEnv "PATH"
18:54:27 <wagle> Variable not in scope: `getEnv'
18:54:28 <Igloo> Or   do x <- getEnv "PATH"; print x
18:54:34 <Igloo> :m + System
18:55:50 <aj> yeah, you have to import it from system first
18:56:21 <aj> what's <- do?
18:56:40 <wagle> its part of the do syntax
18:56:58 <Igloo> do x <- getEnv "PATH"; print x    is syntactic sugar for    getEnv "PATH" >>= (\x -> print x)
18:57:13 <aj> ah!
18:57:19 <Igloo> You can think of it as like = but for monads
18:57:37 <wagle> reading (and writing!) the environment is side-effect-full, hence has to be monadic
18:58:21 <aj> "side-effect-ful" is the worst word i've heard all day :)
18:58:45 <Riastradh> Try 'has effects.'
18:58:47 <wagle> (\x . 1) "thanks!"
18:59:09 <Igloo> Except it doesn't - it is only sensitive to the effects of others  :-)
18:59:16 <Riastradh> Bah!
18:59:27 <wagle> two read can have different results
18:59:54 <Riastradh> I was merely offering a better term for 'is side-effect-full,' not correcting wagle!  Nyah!
19:00:55 <wagle> do { x <- getEnv "FOO" ; y <- getEnv "FOO" } can get different values for x and y
19:01:08 <Riastradh> wagle, that does not mean getEnv itself has effects.
19:01:09 <aj> what's \_ -> return "scp" mean? an anonymous function that always reutrns scp?
19:01:24 <wagle> i was trying to complement "side-effect-free"
19:01:25 <monochrom> No. But getEnv "FOO" can get different values for different runs.
19:01:29 <Igloo> It's the same as \x -> return "scp"
19:01:39 <Igloo> But as we don't use x we don't bother giving it a real name
19:01:42 <wagle> NO..  i was right
19:01:59 <Igloo> So yes, the anonymous function that takes an argument and returns "scp"
19:02:05 <wagle> the environment is in shared memory
19:02:33 <Igloo> (or returns (return "scp") if you want to be pedantic)
19:02:37 <wagle> i know of things that change env on the fly
19:03:03 <Riastradh> monochrom, all that that means is that getEnv is referentially opaque.  It still does not have effects.
19:03:17 <Riastradh> Functions might also have effects but still be referentially transparent.
19:03:52 <Igloo> return :: Monad m => a -> m a    (it's a monad thing, not really like return in C where it's always used to return the result of a function)
19:03:59 <monochrom> I seldom describe things as side-effects.  getEnv, getChar, putChar all work on the world; that's what IO is for.
19:04:08 <Riastradh> (I'm using a loose definition of the word 'function,' by the way.)
19:04:33 <aj> yay!
19:04:47 * Igloo explains this really badly, having not realised what was probably the true question until I got to the end  :-)
19:05:16 <Riastradh> monochrom, there is still a distinction between getChar & putChar.
19:05:30 <aj> yeah, i was wondering why the return needed to be there, forgot it was syntactic sugar
19:05:42 <Riastradh> It's not syntactic sugar.
19:06:01 * wagle tries to apply sed s/return/unit/ to the world..  he fails!
19:06:03 <Igloo> No, \_ -> "scp" is also valid, and is different
19:06:09 <Riastradh> return has an important meaning.  'return x' is very different from just 'x'.
19:06:11 <Igloo> (\_ -> "scp") :: a -> String
19:06:21 <Igloo> (\_ -> return "scp") :: Monad m => a -> m String
19:06:22 <aj> sorry, i mean syntactic sugar for "create_a_monad_of(x)"
19:06:35 <Riastradh> monochrom, the computation that getChar returns does not modify the world that is threaded through it; that of putChar does.
19:06:45 <wagle> syntactic cod-liver-oil?
19:07:14 <monochrom> I know all that, Riastradh.
19:07:24 <wagle> getChar returns something different each time
19:07:36 <Riastradh> No.
19:07:38 <wagle> something is changing
19:07:53 <Riastradh> getChar always has the same value.
19:08:12 <wagle> oh.. we are being pedantic?
19:08:21 <Igloo> getChar has a side-effect though - it alters the contents of stdin
19:08:28 <Riastradh> Er, right, sorry.
19:08:31 <Riastradh> get & put, then.
19:08:50 <monochrom> I no longer see the point of this sermon.
19:09:04 <wagle> you saw a point?
19:09:09 <monochrom> Especially since it is inaccurate to begin with.
19:09:44 <Riastradh> wagle, the computation that getChar represents will produce different values for different input worlds.
19:09:48 <monochrom> Well, I thought I saw a point; I thought the point was to be pedantic.  But now since it's grossly wrong, it can't be.
19:09:58 <Riastradh> monochrom, grossly wrong in what way?
19:10:38 <wagle> well, in some contexts, my loose language would have made sense..
19:10:48 <wagle> but nooooOOoooo
19:11:02 <wagle> 8) 8) 8)
19:11:57 <wagle> i guess i understand more of why i dislike the do notation
19:12:36 <wagle> it leads me to try to describe do { x <- getEnv ; ...} as "returning a char into x"
19:13:19 <wagle> when i'm using english in a loose fashion
19:13:46 <aj> so ghci is like the body of a "do" block, right?
19:13:51 <wagle> umm..  s/getEnv/getChar/
19:13:52 <Riastradh> Correct.
19:14:23 <Riastradh> monochrom, would you care to elaborate what I have expressed so grossly wrongly?
19:14:54 <monochrom> Igloo told you, and you agreed.  Don't act like a memoryless winning strategy for parity games.
19:15:25 <aj> hahahaha
19:15:40 <Riastradh> I agreed and corrected a trivial mistake.  You proceeded, _after_ I corrected myself, to claim that I was grossly wrong.
19:15:51 <aj> "Yo momma is a memoryless winning strategy for parity games"
19:15:52 <aj> what an awesome insult
19:16:05 <cratuki> Pseudonym: what about the hut river province? That's another country in the bounds of australia. It's a bit bigger than vatican. in WA.
19:17:10 <Riastradh> It is not customary to begin beating the spot a dead horse lay on after it was revived & walked away.
19:17:21 <monochrom> It was not a trivial mistake.  Your entire lecture on "a distinction between getChar & putChar" hinged on it.  Once it's gone, there's nothing left.
19:17:58 <Igloo> But it works for getEnv/setEnv. Dear god this is a dull argument.
19:18:11 <Riastradh> If there is anyone to label a pedant, it should be the one who brings up an already corrected trivial mistake.  Was it really necessary to accuse me of being grossly wrong?
19:19:43 <Riastradh> I've had quite enough argument today; I'm not keen on being pulled completely arbitrarily into another one, on an excruciatingly trivial matter, by someone far more pedantic than I who claims that I'm a grossly wrong sermon-giver.
19:19:47 <aj> how do i write { x = 2; y = 3; x = x + y; } in pseudo-procedural do/let/<-/whatever haskell?
19:19:51 <monochrom> It is a dull argument to begin with.  I only said "work on the world"; nothing about change.  I don't see why I need to be further educated.
19:20:29 <Riastradh> aj, there is no variable assignment in Haskell.  You can only bind variables.
19:20:29 <Igloo> I'm not sure what you really mean, aj
19:20:48 <Riastradh> (I presume that you meant to assign x to the value of x + y when you wrote 'x = x + y' there.)
19:20:54 <aj> yeah
19:21:34 <aj> isn't the do stuff haskell's clever way of allowing that sort of thing without breaking functional-ity?
19:21:45 <Igloo> "I'm a computerÂ´s student [...]" - the mind boggles (from haskell-cafe)
19:22:16 <Igloo> You could write that sort of thing in a state monad, with (Int, Int) being the state (representing x and y respectively)
19:22:33 <Riastradh> monochrom, there was a distinction in question -- effectuality versus referential transparency -- that you seemed to brush off and that I desired to clarify.
19:22:40 <Igloo> But really you just shouldn't be thinking about trying to do that unless you have a good reason
19:24:02 <Shammah> afternoon aj :)
19:24:10 <Shammah> haven't seen you around here before.
19:24:45 <monochrom> What a dull argument.
19:25:09 <Riastradh> It is only an argument because you argued in response.  I intended only to clarify the distinction.
19:25:11 <Igloo> Urgle, why is GHC using 800M compiling Email.hs?
19:25:42 <monochrom> I know the profound subtle deep fine far-fletching distinction thank you very much.
19:25:44 <aj> okay, what i'm trying to do is do two different things depending on whether an an environment variable is defined, iwas going to try using catch for it, but wasn't getting anywhere
19:27:13 <aj>  and now i have to go bbl
19:27:26 <Riastradh> monochrom, is your irritated, sarcastic tone really necessary?  You might simply pleasantly ask why I addressed you about the matter, for example, rather than complain with disgusted sarcasm about so frivolous a matter.
19:27:29 <aj> tnx
19:28:13 <Igloo> This might help you: do x <- liftM Just (getEnv "PATH") `catch` \_ -> return Nothing; print x
19:28:14 <Riastradh> (Addressed you in specific, that is.)
19:31:00 <Riastradh> (As opposed to the general channel, which includes wagle, who slightly misused the term 'effect' in the first place.)
19:38:21 <wagle> think "troll", and relax..  the sun is coming up
19:59:25 <monochrom> I am sorry. I overreated. I felt irritated because I was addressed on something I considered unimportant.  I still insist the distinction is besides my point; I admit I acted wrong.
21:25:49 <aj> Igloo: aha, yes that was what i was looking for, thanks
21:41:08 <aj> okay, next stupid question; if x is a Maybe String; and f is String -> String; what's the nicest way of saying `f x' and ending up with Maybe?
21:41:30 <aj> x >>= \y -> Just(f y)  # seems obnoxious?
21:41:33 <Riastradh> x >>= f
21:41:41 <Riastradh> Er, sorry.  fmap f x
21:41:56 <Riastradh> @info fmap
21:41:57 <lambdabot> -- fmap is a method in class Functor
21:41:57 <lambdabot> fmap :: forall f :: (* -> *). (Functor f) =>
21:41:57 <lambdabot> 	forall a b. (a -> b) -> f a -> f b
21:42:17 <Riastradh> Or rather:   liftM f x
21:42:19 <Riastradh> @info liftM
21:42:26 <Riastradh> @info Monad.liftM
21:42:27 <lambdabot> -- Control.Monad.liftM is a variable
21:42:27 <lambdabot> Control.Monad.liftM :: forall a1 r m :: (* -> *). (Monad m) =>
21:42:27 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
21:43:36 <aj> liftM sounds familiar, what's fmap, and why's it work?
21:43:45 <Helic> fmap doesnt
21:43:54 <aj> it did
21:44:08 <aj> (in the specific instance)
21:44:24 <Helic> you said f was String -> String
21:44:56 <aj> it is -- let f x = ">>" ++ x ++ "<<"
21:45:38 <Riastradh> I'm afraid I don't have time tonight to try to formulate a good explanation about fmap and its relation with liftM tonight.
21:45:50 <Riastradh> ...bah, stupid redundant redundancy.
21:46:12 <aj> Riastradh: thanks anyway :)
21:46:39 <Helic> fmap f (Just x) = Just (f x)
21:47:08 <Helic> in that sense, it should work
21:48:14 <Helic> my bad
21:49:20 <aj> ah, i begin to see
21:57:34 <Helic> I recently solved the Skyline problem question (acm) in haskell and it's ridiculously simple and elegant.
22:01:28 <Pseudonym> Damn this is hard.
22:01:32 <Pseudonym> I hate writing research reports.
22:01:44 <Helic> Ph D student ?
22:01:52 <Pseudonym> I'd far prefer to stand up in front of a whiteboard and explain it to people.
22:01:54 <Pseudonym> No, worse.
22:01:58 <Pseudonym> R&D programmer.
22:02:08 <Helic> oh. why is that worse ?
22:02:16 <np_hard> if I want string split/join a la perl functionality should I just use Data.PackedString.splitPS and joinPS ? I can't seem to find those functions for regular Strings
22:02:17 <Pseudonym> PhD students get to write assuming the audience is smart.
22:02:30 <Helic> ah
22:02:56 * Pseudonym does not get that luxury
22:04:04 <Helic> Well, I suppose in your case you should provide enough detail for the possibly dumbest reader while you could skip a lot of stuff if you could interact with them.
22:04:40 <aj> why does    x <- (liftM Just (getEnv "PATH")) `catch` \_ -> return Nothing   work in ghci; but break if I wrap it in  do { ... }  ?
22:05:15 <arauko> Pseudonym, That is because they care more to show they know well, than to make people understanding well what they know.
22:07:00 <Nioate> np_hard: what do they do in perl? anything like what they do in python?
22:08:14 <np_hard> split ":", "this:is:a:test" -> ["this","is","a","test"]
22:08:16 <Pseudonym> My problem is that I have interesting things to say.
22:08:27 <Pseudonym> And they require deep understanding.
22:08:46 <np_hard> join ":", ["this","is","a","test"] -> "this:is:a:test"
22:08:47 <np_hard> so yes
22:08:49 <np_hard> :)
22:09:43 <np_hard> words/unwords in the Prelude is similar but not the same
22:10:02 <Nioate> I'm not sure about split, but the other day I was poking around and found that concat . Data.List.intersperse is the same as join
22:10:41 <np_hard> good one :)
22:11:51 <Nioate> hm.
22:11:53 <Nioate> or not
22:12:40 <Helic> Pseudynm: Are you going to ask people to read your doc carefully and spend some time thinking about it ? Heh.
22:12:59 <Nioate> you can use the two to make a join, but not the way I just said
22:13:39 <Pseudonym> Helic: Very funny.
22:15:02 <np_hard> join x = concat . (Data.List.intersperse x)
22:15:28 <Helic> Pseudonym: Sorry. Recently I gave the same talk on the same algorithm 4 times to different people.
22:15:33 <Helic> not fun.
22:20:21 <musasabi> morning
22:33:48 <aj> is there some way in ghci to tell the type of an expression?
22:33:59 <Helic> :i ?
22:34:32 <Helic> ugh no
22:34:34 <Cale> :t blah
22:34:45 <aj> :t, thanks
22:35:13 <SyntaxNinja> aj: you can also ask lambdabot to some extent:
22:35:18 <SyntaxNinja> @type (++)
22:35:19 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
22:35:29 <SyntaxNinja> aj: learning haskell?
22:35:40 <SyntaxNinja> is this so you can hack on darcs? :)
22:35:45 <aj> SyntaxNinja: trying to, and yes :)
22:35:58 <aj> well, also because haskell's cool
22:36:09 <SyntaxNinja> aj: are you using a book, or just online tutorials?
22:36:40 <aj> #haskell is my online tutorial :) looking at http://www.nomaware.com/monads/html/maybemonad.html a bit atm
22:37:15 <SyntaxNinja> #haskell is a pretty good tutorial :) especially when shapr's around. he's very enthusiastic.
22:37:27 <Helic> heh
22:38:05 <aj> aha!
22:38:19 <aj> finally i see where the IO() is coming from!
22:38:21 <aj> kind-of
22:38:37 <Helic> where ?
22:38:48 <SyntaxNinja> aj: don't tell him... he must learn on his own ;)
22:39:47 <Helic> That tutorial is very detailed
22:40:19 <Helic> But for me, it was Wadler's original paper that made me understand it
22:41:46 <SyntaxNinja> aj: it is pretty common to think that you need to tackle monads before you can grok haskell, but that's not necessarily the case.  you don't need to completely understand monads in order to do all kinds of IO
22:41:59 <SyntaxNinja> but of course, you will need to understand monads at some point. just don't let them get in your way.
22:42:43 <aj> hrm, i still don't see how to make it go away though
22:42:51 <SyntaxNinja> if you get frustrated with monads, just do some real hacking for a while
22:42:54 <SyntaxNinja> how to make IO go away?
22:43:01 <Helic> it doesnt go away imho
22:44:43 <SyntaxNinja> aj: try this: main = l <- getLine; putStrLn (show (length l))
22:44:55 <SyntaxNinja> notice that "length" and "show" are pure functions, they're not in the IO monad.
22:44:59 <SyntaxNinja> @type show
22:45:00 <lambdabot> show :: forall a. (Show a) => a -> String
22:45:00 <SyntaxNinja> @type length
22:45:01 <lambdabot> length :: forall a. [a] -> Int
22:45:19 <np_hard> does anyone do points-free style a lot?
22:45:35 <aj> oh, i see the IO has to stay so haskell can tell when the IO occurred, kind-of
22:46:05 <SyntaxNinja> aj: you can kinda pretend that you're just "marking" functions that do IO, until you get to understand what monads are doing.
22:46:26 <SyntaxNinja> and the "<-" operator "extracts" the pure value from the monad.
22:46:41 <SyntaxNinja> I think my code up there should have had a "do"
22:46:53 <Helic> heh
22:47:18 <Helic> the container analogy in the nomaware tutorial is a good one
22:47:24 <SyntaxNinja> main = do l <- getLine; putStrLn (show (length l))
22:47:51 <Shammah> np_hard, I rather like points-free.
22:48:03 <SyntaxNinja> aj: I'm the darcs debian maintainer, btw :)
22:48:33 <np_hard> Shammah: does it still work for functions that manipulate their argument twice?
22:48:39 <np_hard> a simple example:
22:48:52 <aj> SyntaxNinja: oh, i keep assuming your nick is ij i think; was it ever?
22:48:57 <np_hard> tripleThenSquare x = 3*x * 3*x
22:49:04 <SyntaxNinja> aj: no, I'm not ij.
22:49:13 <aj> who's ij?
22:49:39 <aj> no one maybe
22:49:41 <SyntaxNinja> I don't know.  I've seen him on the debian-devel channel, and heard someone complaining about him, and thought they were talking about me, I was all like huh?
22:49:43 <aj> weird, whatever
22:49:45 <Shammah> np_hard, why wouldn't it?  
22:50:28 <np_hard> just trying to come up with how to express it ... by "work" i mean "still simplifies code reading"
22:50:36 <Helic> ugh. I dont see how f x = cos x + sin x can be written that way
22:50:55 <np_hard> there are many examples
22:51:01 <np_hard> the one I am looking at is actually
22:51:15 <SyntaxNinja> aj: I thnk you & I also corresponded a bit on the apt-secure patch
22:51:23 <aj> SyntaxNinja: yeah
22:51:41 <aj> oh, i bet walters called you ij on irc
22:51:42 <np_hard> capitalize x = consPS (firstChar x) (remaining x)
22:51:50 <Shammah> you tuple the operators, tuple the arg with itself, and use a tuple application.
22:52:07 <np_hard> with firstchar and remaining defined nicely points-free
22:52:15 <SyntaxNinja> I've been wanting to do some more APT hacking to keep my C++ skillz... I do mostly Haskell at work and at play these days, which might not be good for my career long term ;)
22:52:36 <SyntaxNinja> aj: yeah, maybe. we should call him watson.
22:53:07 <np_hard> Shammah: I think I see what you are driving at, can you do Helic's example?
22:53:13 <SyntaxNinja> there's an ij on d-d right now
22:53:30 <Shammah> It dosn't simplify the code unless you also leverage the resulting algebra.  The example I'm currently studying is Yampa (see any of the FRP papers coming out of the Yale group)
22:53:45 <np_hard> I see
22:54:01 <SyntaxNinja> Shammah: what do you think of yampa?
22:54:08 <np_hard> That makes sense, and I doubt I will be leveraging the algebra yet.
22:54:36 <Shammah> By remaining points-free they are able to easilly move to an Arrow structure for their underlying api, and gain signifigantly in safety as well as remaining readable.
22:54:43 <aj> SyntaxNinja: been there done that. (actually in reverse i think)
22:54:47 <np_hard> I am glad to learn that it wasn't particularly trivial (in the sense that it would yield shorter and simpler expressions in the general case)
22:54:55 <Shammah> SyntaxNinja, Still experimenting.  But so far it looks very cool.
22:54:58 <aj> SyntaxNinja: ij = ingo jurgwhatever, buildd wannabe
22:55:06 <SyntaxNinja> oh
22:55:15 * SyntaxNinja hopes not too many people think I'm him
22:55:27 <Helic> you are not a wannabe, Syntax
22:55:46 <SyntaxNinja> aj: what are you working on these days?
22:56:13 <SyntaxNinja> Helic: worse, a wannabe impersonator! 
22:57:07 <aj> SyntaxNinja: nothing terribly interesting. i'm trying to start something terrifyingly interesting, but it's painful and hard, so i keep letting myself get distracted by things like darcs :-/
22:58:35 <aj> how do you write something to stdout with a function call?
22:58:51 <SyntaxNinja> with a function call?
22:59:10 <aj> as opposed to saying print and having it just end up on stdout?
22:59:48 <musasabi> aj: isn't print a function?
23:00:14 <aj> print doesn't get it to stdout though does it? i could use print and have it end up in some other file entirely, couldn't i?
23:00:46 <SyntaxNinja> print, putStr, and putStrLn use stdout
23:00:47 <musasabi> well you can direct stdout on an OS level.
23:00:58 <aj> oh, so print is the stdout function!
23:01:02 <SyntaxNinja> if you want to write to handles you can look at this: http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC.IO.html
23:01:11 <musasabi> but then again you can derect everything on a sane OS.
23:01:19 <SyntaxNinja> putStr is actually a bit lower-level than print, I think since print calls show
23:01:21 <SyntaxNinja> @type print
23:01:22 <lambdabot> print :: forall a. (Show a) => a -> IO ()
23:01:25 <SyntaxNinja> @type putStr
23:01:26 <lambdabot> putStr :: String -> IO ()
23:01:48 <SyntaxNinja> so print is probably defined as: print a = putStr (show a))
23:01:59 <SyntaxNinja> @type (putStr . show)
23:02:01 <lambdabot> (putStr . show) :: forall a. (Show a) => a -> IO ()
23:03:22 <aj> so, does IO() mean you've down output, and IO(t) mean you've done input of type t?
23:03:34 <aj> (roughly)
23:03:55 <SyntaxNinja> no...
23:04:04 <SyntaxNinja> IO () means that the value performs an IO action and returns no result
23:04:19 <SyntaxNinja> IO t means that it performs an action and returns a value of type t
23:04:25 <SyntaxNinja> @type getLine
23:04:26 <lambdabot> getLine :: IO String
23:04:39 <SyntaxNinja> so getLine performs an IO action and returns a string value
23:04:43 <SyntaxNinja> @type putStr
23:04:45 <lambdabot> putStr :: String -> IO ()
23:04:51 <SyntaxNinja> while putStr performs an IO action and has no return value
23:05:02 <aj> right, but it's not doing input if you don't get a result :)
23:05:37 <SyntaxNinja> well, you could have a funcction that gets input from the user and prints it to stdout. that whole function would be IO ()
23:05:50 <SyntaxNinja> @type (getLine >>= putStr)
23:05:51 <aj> details! :)
23:05:51 <lambdabot> (getLine >>= putStr) :: IO ()
23:06:06 <musasabi> @type interact
23:06:07 <lambdabot> interact :: (String -> String) -> IO ()
23:06:55 <aj> yay! "do {x <- getLine; putStr x}" worked how I expected
23:07:13 <SyntaxNinja> cool!
23:08:05 <SyntaxNinja> aj: can you tell me what the type of this function would be:   f s = do x <- getLine; putStr (x ++ s)
23:08:57 <aj> add a suffix to a line from stdin, write it to stdout?
23:09:06 <SyntaxNinja> yep.
23:09:12 <aj> what's the definition of mplus?
23:09:18 <SyntaxNinja> the question is what is the type of 'f'
23:09:31 <aj> x >>= return y  ?
23:09:51 <SyntaxNinja> that's not a type :) f inputs a string, performs an IO action, and returns no result
23:09:56 <SyntaxNinja> so it's f :: String -> IO ()
23:10:10 <aj> huh?
23:10:17 <SyntaxNinja> oh you were talking about mplus?
23:10:25 <aj> yeah
23:11:28 <SyntaxNinja> mplus is an instance in a class, so it doesn't have a definition, strictly speaking
23:11:32 <SyntaxNinja> er
23:12:00 <SyntaxNinja> it's a function in a type class, so you can say "What's the definition of mplus in the IO monad" or something
23:12:33 * SyntaxNinja never uses MonadPlus
23:12:37 <aj> hrm
23:12:59 <aj> mplus isn't what i want anyway
23:26:23 * SyntaxNinja is off to bed
23:26:53 <SyntaxNinja> aj: I'm glad you're learning Haskell. feel free to bombard me with questions, if you have any left by the time tomorrow rolls around ;)
23:27:33 <tintin> is haskell being used for Artificial Intelligence ?
23:28:49 <SyntaxNinja> tintin: yes. I used to work for a company doiing that (http://www.aetion.com) now I work for a security company (http://www.galois.com)
23:31:21 <tintin> cool 
23:40:54 <aj> do { x <- getEnv("xPATH"); print x } `catchError` \_ -> print "Try something else"
23:41:01 <aj> ah, that makes some sense
23:43:09 <tintin> ghc is good for noobs ?
23:44:31 <Shammah> @type catchError
23:44:33 <lambdabot> bzzt
23:55:29 <aj> catchError :: forall m e a.
23:55:29 <aj>               (MonadError e m) =>
23:55:31 <aj>               m a -> (e -> m a) -> m a
23:56:11 <aj> `catch` works too
