01:16:04 <musasabi> nirbubg
01:25:10 <Itkovian> musasabi: any experience using darcs over ssh using e.g. SSH_PORT=8022
01:26:48 <Itkovian> a regular scp on that port works just fine
01:39:47 <musasabi> Itkovian: no, just regular scp with a public key
01:40:09 <musasabi> Itkovian: I would try setting things in $HOME/.ssh/
01:40:20 <Itkovian> i got a public/private keypair, empty passwd
01:40:32 <Itkovian> i can do an scp just fine
01:41:04 <Itkovian> somewhere in External.hs (copySSH :: String -> FilePath -> IO ()) it goes wrong
01:41:37 <Itkovian> it seems the exec of the scp command is not succesfull, hence a fail is raised
01:46:22 <Itkovian> I see nothing wrong with the code though
02:18:49 <Itkovian> dang ... in the tarball compiled version it works fine ... not so in the ebuild version
02:18:51 <Itkovian> grmbl
02:44:28 <Itkovian> ok ignore my previous remarks ... seems like somebody emerged the bloody old darcs version
02:44:30 <Itkovian> aaargh!
02:44:41 * Itkovian nips off to shoot himself
02:44:54 <Itkovian> (I'll be very humane)
03:26:17 <musasabi> Can one create newtypes with TH ?
03:29:26 <musasabi> hmm data would be enough if that can be created inside a function.
03:32:14 <musasabi> that is if I am using $(), can I create new toplevel bindings too (which need not be visible outside the $()) ?
03:34:17 <dons> I think so.. 
03:34:35 <dons> check the TH paper
03:34:45 <arjanb> shapr: the wiki.. :(
03:35:42 <Lunar^> up
03:35:47 <musasabi> hmm that is a very nasty spammer :-(
03:36:15 <Lunar^> dons: You happen to code in a bus ?!
03:36:43 <dons> i did today!
03:37:08 <dons> normally, no. very empty bus though, because uni is out of session, so no undergrads
03:38:49 <dons> Lunar^: is the problem with tab completion that you have to store state that is obtained from an IO action? so it can't be stored in the lexer (pure) state var
03:38:53 <musasabi> dons: I read the paper, but don't see a way at the moment.
03:39:53 <dons> musasabi: I'm fairly sure it works, but I haven't done this myself. you need to ask a TH hacker. hassle Igloo
04:09:10 <Lunar^> dons: I was very tired... I don't remember well
04:10:50 <dons> ok :
04:10:51 <dons> :)
04:15:13 <Lunar^> damn... 7 hours of sleep, 80 mails
04:21:41 <Janni> G'morning
04:23:42 <musasabi> morning
04:31:31 <musasabi> "Generishe Functionale Programmierung 2" is a quite nice text ^_^
04:32:22 <musasabi> *Generische
04:49:09 <musasabi> How do I create an empty Cxt in template haskell?
05:47:44 <Igloo> You should be able to create newtypes with TH
05:47:51 <Igloo> Isn't an exmpty Cxt just []?
05:53:02 <musasabi> yes, that I solved..
05:53:10 <musasabi> instances still escape my grasp.
05:53:55 <musasabi> you wouldn't happen an example code snippet creating newtypes and instances with the new TH syntax?
05:54:31 <musasabi> using [d| |] seems to work in trivial cases...
05:54:44 * musasabi plays around with the testsuite examples
05:57:50 <Igloo> If the class is in an imported module or also inside the [d| |] then it should certainly work - please give me an example if not
05:58:03 <Igloo> If it's in the same module before the [d| |] then I'm not sure OTTOMH
05:58:29 <Igloo> Oh, you can't splice type names in AtM - is that what's confusing you?
05:59:20 <musasabi> well I can do [d| data A = A \n instance Show A where show _ = "foobar" |] but how do I create a new A? (A seems to be hidden away)
06:00:02 <xerox> yeee-aaww!
06:02:45 <Igloo> I get "Failed binder lookup: GHCziShow.show {- v raA -}" with 6.2.2, but it works with CVS
06:03:22 <Igloo> It's better to develop with CSV at this point as things have been moved round slightly
06:04:45 <musasabi> I have CVS.
06:04:59 <musasabi> so that should not be the problem.
06:05:40 <xerox> a question, is "fib 0 = 1" "fib 1 = 1" "fib n = fib (n-1) + fib (n-2)" correct? haskell-mode highlightes the first two statements only if i put 0 and 1 in parens like (0) and (1)
06:06:36 <musasabi> yes that is correct
06:06:46 <xerox> who it doesn't highlight ?
06:07:02 <xerox> err, why
06:07:41 <musasabi> well it is not perfect...
06:07:49 <xerox> mmh.
06:08:04 <musasabi> Igloo: currently I have something like: 'foo = [d| data A = A ; instance Show A where show _ = "A from TH" |] >> [| A |]'
06:08:36 <musasabi> this does obviously not work, since A is not scope in the latter splice. But how do I create an expression splice than can refer to A?
06:08:44 <Igloo> musasabi: Erro, if you never splice the first one in it never happens
06:09:31 <Igloo> And even if you did, you'd probably get a different A - you'd need to use mkName for it, but as it's a type you run into the net being able to splice type names in issue
06:10:05 <Igloo> If possible you should splice the type declaration in in another module
06:10:58 <xerox> (can i ask why is not "perfect" ?)
06:11:17 <xerox> the lack of fib :: Int -> Int ?
06:13:41 <Igloo> Are you asking why Haskell 98 doesn't define fib?
06:14:02 <Igloo> If so, it's because it's not a commonly used program, but it's common for student to implement it, so there'd probably be ngeative gain overall
06:14:05 <musasabi> Igloo: Would using InstanceD work?
06:14:16 <xerox> Igloo no no
06:14:40 <xerox> Igloo musasabi told me my definition wasn't perfect, just trying to realize what does it mean
06:15:00 <swiert> xerox: musasabi probably meant that haskell-mode isn't perfect.
06:15:25 <Igloo> musasabi: Yes, that's what you'd have to use if you wanted it all in one module I think
06:15:47 <Igloo> (and not all within one [d| |])
06:15:53 <musasabi> xerox: yes, I was referring to haskell mode.
06:16:00 <xerox> Ah! sorry
06:16:05 <musasabi> syntax highlighting with regexes is not very good.
06:16:13 <musasabi> thus yi.
06:16:34 <xerox> mmh i still don't know Haskell, do i need Yi yet? :D
06:17:09 <musasabi> no, yi is a project to build a very nice editor with haskell. (dons and shapr are hacking on it)
06:17:29 <xerox> i know that
06:20:28 <musasabi> What I ultimately want is to create newtypes and corresponding type class instances for all values passed to a TH function. Does that sound possible?
06:22:16 <Igloo> If I understand correctly then yes
06:24:20 <chbug> hi. is this a good place for haskell newcomers ?
06:25:17 <Igloo> Certainly is  :-)
06:26:44 <chbug> cool ! I'm looking for an idiomatic way of writing a log analyser:
06:27:07 * shapr yawns
06:27:08 <chbug> it would read a file, line by line, and feed them to filters that perform statful computations
06:27:11 <shapr> good morning #haskell!
06:27:33 <xerox> yo!
06:27:38 <TheHunter> morning shapr
06:27:46 <TheHunter> seen the mess on the wiki?
06:28:36 <chbug> Sth modular, where I could plug a new filter in the middle of a chain and obtain a summary once the file is parsed
06:29:21 <chbug> I'm able to write the file parser itself, but feel a bit lost on the way to handle the filters
06:29:36 <shapr> just looking at the mess now.
06:30:54 <shapr> I'll add that hostname to LocalBadContent
06:31:43 <shapr> on the subject of spam, there's this company that keeps trying to sell me stocks over the phone
06:32:18 <shapr> I keep telling them don't call me, send me an email with the information. But they still call me and haven't sent an email yet.
06:32:20 <tromp> you have long mornings there in sweden!
06:32:47 <shapr> tromp: in the summer the sun stays in the sky for months. That's a long morning.
06:33:54 <shapr> chbug: what about using interact?
06:36:30 <shapr> dons: is too many undergrads a bus error?
06:37:18 <chbug> shapr, I'd like to have different functions handling the input file at the same time, each one returning a measure. Is this possible with interact?
06:37:49 <shapr> that's possible in many different ways.
06:38:14 <shapr> actually, a lazy file read may be more sensible.
06:38:18 <tuomov> it's as dark as it would be early in the morning so it must be morning!
06:38:28 <shapr> oh, I like that logic.
06:38:36 <musasabi> How does specifying instances work? "InstanceD Cxt Type [Dec]" does seem quite short. Where is the typeclass name? Iam trying to translate 'instance Value Foo Bar where value _ = x'
06:40:34 <chbug> shapr, as I said, I'm a newcomer :-) so far, I use a simple hGetLine to test that my file is properly parsed (it's an apache log file, I process the date / ip / query). 
06:42:05 <Igloo> The type is Value (Foo Bar) IIRC
06:42:52 <shapr> TheHunter: thanks for fixing the wiki spam :-)
06:43:27 <Igloo> Or if you meant what you said and have a MPTC, it's probably Value Foo Bar
06:43:49 <Igloo> You can check this by wrapping an instance in [d| |] and pprinting the result
06:44:07 <chbug> shapr, I think what blocks me is how to keep a state over all the lines of a file, and returns the result at the end. maybe the error comes from processing the file line by line?
06:45:04 <TheHunter> shapr, just in case something like that happens again. You can revert the wiki back to a certain date, can't you?
06:45:44 <musasabi> thanks I'll try pprint
06:46:08 <Igloo> Arg, sorry, pprint will give you back the concrete syntax
06:46:11 <Igloo> I meant show
06:46:54 <shapr> I don't think there's a global date revert, but it sure would be nice.
06:47:27 <shapr> I also wish that a certain change could be globally marked as spam so that that same change is undone everywhere.
06:47:49 <TheHunter> yeah, that'd be cool, too.
06:48:43 <shapr> or maybe a nicer feature is 'move back in time' after marking the spam hosts, and then replay the changes, rejecting changes that are spam.
06:49:21 <Philippa_> shapr: hurry up and integrate darcs and flippi? ;-)
06:49:23 <shapr> chbug: monadic parsers are good at keeping state.
06:49:27 <shapr> I'm working on it :-)
06:49:48 <shapr> today's task is to add the metadata support we discussed.
06:50:38 <musasabi> got it.
06:53:37 <Philippa_> cool
07:21:16 * CosmicRay looks in
07:21:26 <CosmicRay> shapr: what do you think of my little exception-handling rant?
07:21:49 <shapr> um
07:21:52 <shapr> haven't read it yet
07:21:55 <CosmicRay> on haskell-general
07:21:59 * shapr looks
07:22:15 <CosmicRay> I wonder how much of it we could fix with TH...
07:23:48 <shapr> ah
07:24:19 <shapr> you should read the inexact exceptions paper by SPJ and others.
07:24:55 <shapr> there's a good reason for the IO exceptions, but I forget the details.
07:25:38 <shapr> ya know, I really really hate top-quoting.
07:25:50 * CosmicRay pleads guilty to doing that sometimes
07:25:58 <shapr> Keean Schupke seems like a nice guy, but I have real trouble reading his top-quotes.
07:26:00 <CosmicRay> but yeah
07:26:01 <CosmicRay> heh
07:27:17 <CosmicRay> but I think that, in general, exceptions in haskell stink
07:27:28 <shapr> I don't know. I never use exceptions.
07:27:34 <CosmicRay> the whole bit about having to use a Dynamic for custom exception types is particularly annoying
07:27:36 <shapr> I use error "foo"
07:27:44 <CosmicRay> that's raising an exception :-)
07:27:59 <shapr> right, but I only do that once in a blue moon
07:28:04 <shapr> and that's it.
07:28:18 <shapr> only for stuff like myfunction _ = error "myfunction fell through"
07:28:19 <CosmicRay> I have use for them in several places
07:28:28 <CosmicRay> one is network communication
07:28:31 <CosmicRay> for instance, in my FTP client library
07:28:44 <CosmicRay> if the server returns an error code for a particular operation, the sensible thing to do is return an exception
07:29:06 <CosmicRay> don't make people parse out an Either from every single operation call.  that just totally stinks
07:30:07 <shapr> can you bind together a bunch of either calls?
07:30:07 <CosmicRay> also anything that involves parsing seems to be ripe for this sort of thing
07:30:34 <CosmicRay> shapr: afaik not without using case or some sort of fromMaybe-style hack
07:31:35 <shapr> http://nomaware.com/monads/html/errormonad.html
07:31:46 <shapr> the error monad uses Either
07:32:29 <shapr> I think you have a point about catching inexact exceptions, but I think that returning Either is actually a good thing.
07:33:02 <shapr> I agree, it would be nice to have some way to catch only network exceptions, or only fatal network exceptions or ...
07:33:14 * shapr yawns
07:33:28 <CosmicRay> yes, exactly, and that's one of the problems with the errormonad idea
07:33:39 <CosmicRay> which incidentally reminds me a lot of the Twisted architecture in PYthon
07:33:54 <CosmicRay> (which happens to suffer from the same problem)
07:33:59 <shapr> man, I hate voice spam.
07:34:33 <shapr> I don't have a good answer for that.
07:34:45 <shapr> but maybe SPJ will know, he wrote the exception mechanism in the first place.
07:35:10 <shapr> I think there's at least two papers on the exception mechanism, I read one of them some time back.
07:35:54 <CosmicRay> the exception system in python is, I think, the only true advantage it holds over both ocaml and haskell
07:36:19 <shapr> Guido's sheer handsomeness is another advantage.
07:36:22 * shapr snickers.
07:36:24 <CosmicRay> heh
07:36:57 <CosmicRay> but I don't think that adding features like that is really outside the basic design of either language
07:37:18 <CosmicRay> ocaml already has an object system that could be used, and haskell could permit catching based on typeclasses
07:37:40 <musasabi> hmm does not work.. maybe I will just go home for the day.
07:38:11 <shapr> gee, I was thinking of leaving the house.
07:38:33 <CosmicRay> heh
07:38:42 <shapr> I could visit musasabi :-)
07:38:49 <shapr> probably too far to take the bus though.
07:38:59 <musasabi> welcome but be wary of the snow ;)
07:39:08 * shapr grins
07:39:26 <CosmicRay> shapr: if you hurry, you could visit me before the snow hits :-)
07:39:41 <CosmicRay> (we're supposed to get an inch or two tomorrow... nothing of great consequence)
07:39:56 <shapr> I'd have to hurry lots.
07:41:11 * Lemmih goes for a unicycle trip in the dark.
07:41:32 <shapr> oh, will you update your blog then?
07:42:27 <musasabi> but, => home 
07:43:13 <Lemmih> shapr: I'm not quite sure what I should write.
07:44:04 <shapr> length of time you were unicycling, tricks that you're practicing, tricks that succeeded for the first time, tricks that are improving
07:44:13 <shapr> small children that you squished
07:44:16 <shapr> that sort of thing
07:44:19 <Lemmih> (o:
07:44:35 <shapr> I dont recommend squishing small children :-)
07:44:55 <shapr> though I've nearly done it myself a few times.
07:46:41 <Lemmih> I don't really like to train in front of people. It makes me feel like a clown.
07:47:04 <shapr> yah, I understand that.
07:47:21 <shapr> but I can't seem to escape from the gawkers sometimes.
07:47:53 <shapr> I feel much more comfortable trying new stuff when no one is watching. I tend to fail spectacularly when trying new stuff for the first few times.
07:49:50 <shapr> The most spectacular bailout I've had yet was where a 30-kilo dog tried to jump into my lap while I was unicycling.
07:50:52 <shapr> I only wish someone were recording that.
07:53:23 <CosmicRay> @index bracket
07:53:23 <lambdabot> Control.Exception,IO
07:57:00 <shapr> CosmicRay: so if you want some help writing a Haskell book ;-)
07:58:07 <shapr> Alistair Bayley is a very perceptive person.
07:58:28 <shapr> I only wish he'd write more of this thoughts on functional programming.
07:59:06 <CosmicRay> heh
08:15:28 <shapr> mmm, unicycling
08:15:59 <xerox> i did skate, but it's too cold outside :\
08:16:10 <shapr> how cold is it there?
08:16:20 <xerox> i think 3-4°C
08:16:22 * dottedmag can only ski for now :)
08:16:25 <xerox> brrr
08:16:31 <shapr> It's -20Â°C here right now.
08:16:38 <shapr> and I'm about to go unicycling...
08:16:41 <xerox> O_O
08:17:21 <dottedmag> shapr: are you from Scandinavia?
08:17:39 <shapr> my hostname is Scannedinavian.com
08:17:57 <shapr> I live in Sweden, but spent my first 28 years in the USA.
08:18:10 <dottedmag> shapr: shapr is Shae Erisson (~user@3ffe:bc0:8000:0:0:0:0:237b)
08:18:21 <dottedmag> shapr: I have to set up my resolver properly :)
08:18:37 <shapr> that's a freenet6 ip, so it won't help much.
08:18:52 <shapr> one day I'll get off my but and follow CosmicRay's 6to4 tutorial properly.
08:18:57 <shapr> then your resolver will probably work fine.
08:19:24 <shapr> CosmicRay: what's the url to your nifty tutorial again?
08:19:52 <shapr> anyway, time for unicycling...
08:20:54 <CosmicRay> shapr: oh, one sec
08:21:23 <CosmicRay> shapr: http://master-www.complete.org/~jgoerzen/changelog_old/http/node/view/61.html
08:22:16 <dottedmag> such a mnemonic url :)
08:23:14 <CosmicRay> dottedmag: it was in a blog system, that I have since moved away from :-)
08:24:31 <CosmicRay> I used pavuk to download the content out of it
08:50:07 <musasabi> home..
09:25:43 <CosmicRay> spj's paper is excellent.
09:25:50 <CosmicRay> now I know why we can't catch exceptions outside of the io monad.
09:31:44 <dottedmag> CosmicRay: link?
09:32:00 <CosmicRay> http://research.microsoft.com/%7Esimonpj/Papers/imprecise-exn.htm
09:33:14 <dottedmag> CosmicRay: thanks
09:34:46 <flodin> interesting
09:35:42 <musasabi> yes, that is quite nice.
09:40:16 <musasabi> is it possible to define identifiers in ghci?
09:40:32 <esap> let x = 10
09:41:09 <musasabi> hmm, that obvious ^_^
09:44:27 <xerox> but you can't modify it later
09:44:29 <xerox> am i correct?
09:45:25 <jadrian> xerox: you can
09:45:25 <musasabi> hmm you seem to be able to modify it
09:45:57 <xerox> mmh k
09:46:43 <jadrian> IIRC haskell interpreters work like you're inside an IO monad
09:46:57 <jadrian> a <- return 2    -- works too
09:47:14 <jadrian> or
09:47:18 <jadrian> c <- getLine
09:48:42 <jadrian> To be honest the way bindings work is one of the things I don't like about haskell...
09:49:33 <jadrian> Dynamic typing...
09:49:45 <kristnjov> you dislike haskell!?? brutus
09:50:30 <jadrian> I know I can get banned by it... :)
09:50:37 <monochrom> It is not dynamic typing.
09:50:38 <jadrian> s/by/because of
09:51:33 <jadrian> monochrom: well you can do   a <- return 1 (...) a <- return 'c'
09:51:53 <jadrian> monochrom: so you are binding "the same var" to different types
09:52:12 <jadrian> monochrom: why do you say it is not dynamic typing?
09:52:23 <mflux> you can write { int a = 42; { char* a = "foo"; } } in c, is that dynamic typing?
09:52:36 <dash> jadrian: why do you think they are the same var
09:52:48 <monochrom> They are not the same var.  They are two different vars taking the same name, the more recent one  overshadowing the earlier one.
09:53:01 <jadrian> ok I know it's not the same var, and therefore the " " :)
09:53:21 <monochrom> So your whole conception breaks down.
09:53:27 <jadrian> yes
09:53:42 <monochrom> You should re-format your brain and re-install Windows.
09:54:00 <jadrian> still it reemsembles dynamic typing
09:54:06 <jadrian> and has some of it's disadvantages
09:54:36 <monochrom> What is a disadvantage?
09:55:16 <jadrian> for instance it's easy to "override" a previously declared variable with another, without noticing it
09:55:38 <jadrian> a <- return somint
09:55:39 <jadrian> ...
09:55:45 <mflux> I don't think that's a problem of the type system though
09:55:46 <jadrian> a <- return somechar
09:55:51 <jadrian> print a 
09:56:36 <jadrian> having the type checked would at least catch some mistakes
09:57:08 <jadrian> forcing/allowing declaration could help further
09:58:07 <monochrom> Some languages disallow overshadowing.
09:59:53 <jadrian> yeap
10:02:31 <monochrom> I think I agree with you.  Overshadowing is not a much needed feature, and permitting it invites more mistakes than benefits.
10:02:33 <xerox> mmh can somebody explain me a thing
10:02:42 <xerox> data Point a = Pt a a
10:02:47 <xerox> Pt is data constructor, right?
10:03:36 <monochrom> Yes.
10:03:45 <xerox> and Pt is a -> a -> Point a
10:04:04 <monochrom> Yes.
10:04:06 <xerox> where the first 2 a are the arguments and Point a the return value ?
10:04:13 <monochrom> Yes.
10:04:16 <xerox> ok.
10:04:18 <xerox> now
10:04:38 <xerox> data Tree a = Leaf a | Branch (Tree a) (Tree a)
10:04:53 <xerox> Branch :: Tree a -> Tree a -> Tree a
10:04:53 <xerox> ?
10:05:01 <monochrom> Yes.
10:05:05 <xerox> argh
10:05:29 <xerox> mmh, no i think i got it
10:05:52 <xerox> explaining carefully on IRC let me understand :D gee
10:06:26 <monochrom> Generally, a clear exposition of the problems solves 90% of the problems.
10:06:49 <xerox> so Branch sometree someothertree
10:06:55 <xerox> returns a Tree
10:07:10 <xerox> it's clear, i'm confusing for nothing
10:07:16 <xerox> it's the syntax ;)
10:08:00 <nysin> Am I missing something in being unable to get the toplevels/REPLs of either GHCi or Hugs to let me define functions, etcetera?
10:09:09 <shapr> GHCi can do it, sort of
10:09:20 <monochrom> let f x = x + 1  -- works in ghci
10:09:22 <nysin> According to my reading of the hugs documentation, it accepts only expressions for example
10:09:31 <shapr> but GHCi can't do everything.
10:09:42 <shapr> yes, you can't define functions in hugs
10:10:29 <shapr> nysin: I like haskell-mode in emacs, C-c C-l dumps the file you're editing into GHCi
10:10:46 <shapr> that way you can easily play with functions interactively
10:11:08 <shapr> hs-plugins
10:11:21 <shapr> will probably give you the whole repl at some point
10:11:51 <nysin> Okay.
10:12:15 <shapr> any other questions?
10:12:28 <nysin> monochrom: Hm. The Haskell code I've seen generally omits 'let'. (I've not done much with the language, but am interested and prefer playing with a more interactive system.)
10:13:01 <monochrom> I know.
10:13:24 <shapr> I really need unicycle leg armor. My knee hurts.
10:14:12 <irce> is hugs bad ? should i use GHC? 
10:14:31 <shapr> musasabi: did your investigation of network mobile values get any further since our last discussion?
10:14:40 <shapr> irce: no, hugs isn't bad, it's just different.
10:14:50 <shapr> Hugs is a Haskell interpreter written in C.
10:14:58 <shapr> GHC is a Haskell compiler written in Haskell.
10:15:08 <psi> hugs has worked very well for me
10:15:21 <shapr> Hugs doesn't use much memory or disk space, and it's easy to port to any os/cpu.
10:15:51 <shapr> GHC is big and heavy, but it does almost *everything* you could ever want.
10:17:01 <shapr> There are other Haskell implementations with other good points, nhc98 produces very small executables for examples.
10:17:36 <shapr> There's an in-progress nhc98 runtime for the PalmOS. I can barely wait :-)
10:18:42 <shapr> irce: if you have >500MHz and >128MB of ram, I would suggest using GHC, but you should try both and see what you think.
10:19:12 * shapr throws a go stone at psi 
10:19:32 * psi hurls a goban at shapr
10:19:34 <psi> hah!
10:19:51 <shapr> Does that mean I can never play go again?
10:19:57 <SyntaxNinja> shapr: have I pointed out that apt-get is available for redhat and might make maintaining stuff easier?
10:20:28 <shapr> well, I'll try it.
10:20:42 <shapr> After I get back from more unicycling.
10:21:27 <psi> shapr: no :) you can play against me if you want to :)
10:22:01 <psi> i need to practise for the tournament ;)
10:22:05 <shapr> ok, sometime in the next coupla weeks I'll look you up. Is there a bar in LuleÃ¥ where we can play go?
10:22:49 <psi> dunno. i don't actually own a board
10:22:57 <psi> well, i do, but it's broken
10:23:37 <shapr> I'll ask some luleÃ¥ medborgars.
10:23:46 <psi> you could come and visit the go club
10:23:47 <ned> http://nm.nerim.net/goCube2.r.hs && http://nm.nerim.net/goCube2.r.man : my last release :) every time the "go" word is pronounced i appear :)
10:23:53 <shapr> that sounds like fun.
10:24:03 <psi> yep, we play every sunday
10:24:21 <psi> not this coming sunday though, because of the tournament (i think)
10:24:21 <shapr> this sunday I'm hacking yi
10:24:29 <shapr> ok
10:24:50 <shapr> ned: looks cool!
10:25:05 <shapr> can you add a copyright and license?
10:25:10 <ned> yep
10:25:24 <shapr> anyway, I gotta get outside before it goes under -23
10:25:27 <ned> as soon as i've finished the network support
10:25:31 <ned> i think
10:25:32 * shapr disappears
10:25:35 <xerox> psi do you play go?
10:25:37 <xerox> :D
10:25:53 <psi> xerox: it happens :)
10:26:08 <xerox> which rank are you ? ^_^
10:26:41 <psi> i'm not sure
10:26:46 <xerox> me neither.
10:26:48 <psi> i haven't played much online
10:27:08 <psi> over 15k, and under 20k. that is my guess.
10:27:34 <xerox> you mean 20k < you < 15k ?
10:28:07 <psi> 15k < me < 20k :)
10:28:17 <xerox> but 15 is higher ;)
10:28:26 <xerox> hehe
10:28:41 <xerox> i don't play much in real life as opposite
10:28:57 <xerox> i'm kgs 8k, but it doesn't mean anything i think
10:29:06 <psi> well, i guess you could see it that way :)
10:29:13 <psi> that's pretty good
10:29:36 <xerox> i didn't play in the last .. mmh ..
10:29:44 <xerox> 2 months i think :|
10:29:56 <psi> i played once in the last month or so
10:30:03 <xerox> but i introduced the game at two friends:D
10:30:11 <psi> so much else to do :<
10:30:18 <xerox> :\ yay
10:38:29 <CosmicRay> @index getException
10:38:30 <lambdabot> bzzt
10:38:34 <CosmicRay> foo.
11:02:41 <musasabi> back from sauna.
11:04:42 <musasabi> shapr: approaching the problem inside haskell seems quite problematic (typeclass requirement) but the parallel haskell code could be used. It would need work, and unfortunately I don't have time for that (and hs-fltk has taken much of that time in the recent weeks)
11:05:40 <jadrian> when using getLine, neither backspace or delete work
11:05:57 <jadrian> is there any way around it?
11:06:11 <musasabi> jadrian: readline
11:06:53 <jadrian> musasabi: update readline?
11:07:11 <musasabi> jadrian: System.Console.SimpleLineEditor
11:07:19 <jadrian> musasabi: thanks
11:09:41 <musasabi> there was a bug in there with some versions that was fixed (I stumbled it the last time, so if you have problems with the terminal after the program has quit...) 
11:10:10 <jadrian> musasabi: right, thanks
11:28:38 <marcot> Hello, where can I find doc about $ ?
11:31:43 <SyntaxNinja> marcot: that operator is mostly used to 'apply' a function without using parentheses
11:32:09 <SyntaxNinja> for instance print (toString (sqrt 10)) would be print $ toString $ sqrt 10
11:32:44 <xkb> a kind of glue operator
11:33:50 <psi> ned: i get 'bus error' when i try to run your go application, on mac os x
11:36:02 <Lunar^> psi: same here
11:36:30 <Lunar^> marcot: f $ x = f x <- it's defined like that actually
11:37:29 <mflux> it's darn useful, I've defined that in some ocaml programs too ;)
11:39:22 <marcot> Lunar^: So it's very similar to . ?
11:39:37 <jadrian> I have a .ghci file with "-i/home/jadrian/Program/Haskell/MyLibs"
11:39:40 <marcot> SyntaxNinja: Lunar^: thanks.
11:39:44 <jadrian> is there any equivalent for ghc?
11:39:55 <jadrian> I tried copying .ghci to .ghc but doesn't work
11:40:54 <jadrian> I can always make an alias ghc='ghc -i/home/jadrian/Program/Haskell/MyLibs'
11:44:42 <jadrian> musasabi: actually deleting just doesn't work when calling readLine from the interpreter, if I compile the program then it works just fine
11:45:22 <marcot> Actually, what's the difference between $ and . ?
11:45:48 <kristnjov> that's what i've been wondering as well
11:46:02 <Lunar^> marcot: no !
11:46:04 <Igloo> The type, for one thing
11:46:10 <Lunar^> @type ($)
11:46:11 <kristnjov> our lecturer told us once i remember, but i was half asleep so i can't remember :P
11:46:11 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
11:46:15 <Lunar^> @type (.)
11:46:16 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
11:46:37 <Lunar^> marcot: ($) is just application, (.) is composition
11:47:13 <marcot> Lunar^: humm... ok, now. Thank you.
11:47:17 <Lunar^> marcot: The idea is that ($) is defined with a very low priority, thus decreasing the number of required parenthesis
11:47:55 <Lunar^> marcot: But sometime people use it alone instead of giving (\f x -> f x) to a high-order function
11:48:50 <marcot> Lunar^: Ok.. I'll try to read some programs with it to get it.
12:17:36 <CosmicRay> I think it is quite amusing that googling for "what the hell are monads" produces a useful answer.
12:18:15 <internot> Hi there
12:18:19 <CosmicRay> hello
12:18:21 <internot> Hi kolmodin
12:20:14 <internot> dons: Are you there?
12:24:01 <internot> I was hoping to discuss porting hs-plugins to win, but it seems like there's not much action here..
12:26:39 <CosmicRay> internot: the action comes and goes
12:26:46 <CosmicRay> internot: though you may have just scared everyone off
12:26:51 <CosmicRay> that sounds like a difficult task
12:28:41 <internot> Not really, I've managed to compile it, but there's still some issues..
12:29:03 <internot> Well,still dificult perhaps, but interestin ;)
12:29:23 <CosmicRay> heh
12:29:40 <CosmicRay> windows dynamic linking doesn't sound interesting to me, but hey, have fun :-)
12:29:53 <CosmicRay> aix dynamic linking is bad enough :-)
12:30:04 <flodin> so, anyone thought of an irc client in haskell
12:30:14 <CosmicRay> I think that exists already
12:30:16 <CosmicRay> hsirc iirc?
12:30:18 <CosmicRay> shapr would know
12:30:30 <flodin> oh, yeah. Hm, not cute though :P
12:31:16 <internot> Well, I'm involved in a project that needs to be platform independent and hs-plugins would be great.. If it wld just work under windows..
12:31:29 <CosmicRay> internot: ah
12:31:47 <CosmicRay> flodin: you mean a haskell irc client with a user interface like xchat?  doesn't exist afaik :-)
12:32:04 <flodin> well, something like irssi would be fine for now :)
12:32:13 <flodin> but of course, user interface and back end should be separate
12:32:34 <flodin> does haskell have support for unicode?
12:33:09 <CosmicRay> I believe there is a unicode library floating about, but I'm not sure that it's part of the base libs
12:33:09 <flodin> in case i wanted to do something like the charset support in xchat
12:33:19 <flodin> hrm
12:33:34 <flodin> well an utf-8 string is just a string with funny indexing
12:36:05 <Lunar^> flodin: ever Char is Unicode
12:36:09 <Lunar^> every
12:36:22 <CosmicRay> but unicode support is a bit more than that
12:36:28 <CosmicRay> you have different representations of unicode
12:36:36 <CosmicRay> and often a need to convert between different character sets
12:36:43 <Lunar^> dons made an Iconv binding. It's in Yi
12:37:05 <Lunar^> There is code floating around in pure Haskell in haskell.org mailing-lists archives
12:37:08 <Igloo> I â™¥ unicode
12:37:39 * Igloo apologises for dragging the level of the channel down - it's been a long day  :-)
12:37:45 <CosmicRay> http://sourceforge.net/projects/haskell-i18n/
12:37:59 <flodin> CosmicRay: yeah, well, there's plenty of unicode support in external libs, or if worse comes to worse you can implement them yourself. But it might be a pain if the native string type (as in, what you get when you type "hello world") does not generate a unicode string
12:39:52 <Igloo> Are you on libraries@, CosmicRay?
12:40:19 <CosmicRay> Igloo: I don't think so
12:40:56 <Igloo> http://www.haskell.org//pipermail/libraries/2004-November/002696.html
12:41:09 <CosmicRay> heh
12:42:27 <flodin> format strings are pretty useful
12:42:51 <CosmicRay> yeah, igloo is pointing me to that becuase I wrote a printf in haskell last week :-)
12:43:07 <CosmicRay> Igloo: huh, that message just arrived.  guess I'm on libraries after all :-)
12:43:12 <flodin> but without positional arguments translation is difficult
12:43:24 <CosmicRay> ahh, that problem is solved.
12:43:26 <flodin> and even with, they're sitll difficult
12:43:32 <CosmicRay> well mostly so
12:43:54 <flodin> like how do you do "You have %1 files" so that it's correct for both singular and plural
12:44:01 <CosmicRay> oic
12:44:12 <CosmicRay> that's not a problem unique to printf though
12:44:20 <flodin> nope
12:45:24 <stepcut> "You have %1 file(s)" :p
12:45:39 <flodin> stepcut: that was okay in DOS 4.0
12:45:43 <stepcut> hehe
12:46:44 <flodin> maybe translation strings need their own miniature functional language
12:46:56 * stepcut is rather interested in good unicode/translation for haskell
12:48:54 <flodin> "you have %1 %if{%1 == 1 then 'file' else 'files'}"
12:51:25 <Igloo> Don't say things like that or you'll tempt me ot add them to the TH one  :-)
12:51:55 <flodin> aha!
12:52:01 * flodin tries to think of more to add
12:53:22 <Igloo> You want more than an embedded Turing complete language?
12:53:23 <stepcut> let fileStr = if num_files == 1 then "file" else "files" in printf "you have %1 %s" num_files fileStr :p
12:53:46 <flodin> stepcut: that's not very translatable
12:54:18 <stepcut> "The number of files you have is %d" ;)
12:54:28 <flodin> Igloo: i haven't thought much about what is needed or not
12:54:43 <flodin> i'm not even sure if it must neccessarily be turing complete
12:56:09 <Igloo> Hmm, actually, to do it nicely you'd need to be able to call the TH parser from TH code. Not sure how easy that would be OTTOMH
12:57:13 <stepcut> meta-template-haskell
12:59:33 <dash> well if you can't write macro-defining macros what's the _point_
12:59:47 <dash> you're just fooling yourself!
13:00:44 <stepcut> i wonder if there will ever be something like ocamlp4 for extending haskell ...
13:01:33 <stepcut> because then you could do all sorts of silly things :p
13:01:56 <Igloo> I think the danger of someone writing something like that is that people might actually use it
13:02:01 <stepcut> indeed!
13:02:35 <stepcut> You could write a scheme "compiler" using just haskellp4 + template haskell :p
13:03:46 <Igloo> CosmicRay: Simon M (and possibly others) might be unhappy with non-BSD for the standard libraries
13:04:03 * stepcut would be unhappy with non-BSD for the standard libraries
13:04:07 <Igloo> But I think the fptools repo is trying to shrink, not grow, anyway
13:10:37 <CosmicRay> Igloo: Oh, I thought it was lgpl
13:14:29 <shapr> shapr would know!
13:14:35 * shapr grins
13:15:03 <shapr> There are two graphical irc clients written in Haskell.
13:15:40 <Lunar^> stepcut: Would it be strict ?
13:15:42 <shapr> juhp wrote hircules, and Philippa is writing whirc
13:16:51 <SyntaxNinja> down with standard libraries! up with the cabal!!
13:17:05 <shapr> yay cabal!
13:17:24 <shapr> oh hey, I thought of neat trick to allow 'unsecured' network imports in cabal.
13:17:36 <CosmicRay> there is something to be said for having useful tools in the standard library
13:17:49 <SyntaxNinja> CosmicRay: "standard"
13:18:14 <SyntaxNinja> there's nothing much standard about it, if it were a matter of actually standardizing on anything, making promises about it, and releasing a haskell 2, that would be one thing
13:18:24 <SyntaxNinja> but just distirbuting it with the compilers is a different story :)
13:18:26 <SyntaxNinja> shapr: do tell
13:18:33 <CosmicRay> SyntaxNinja: I'm not so sure
13:18:47 <CosmicRay> SyntaxNinja: there are things one can expect any haskell system to have available
13:18:49 <shapr> if you download a package that you trust, it can give you the version and *md5sum* of the package used during development.
13:18:52 <CosmicRay> SyntaxNinja: that is a useful thing
13:18:52 <SyntaxNinja> CosmicRay: I think we should definitely have all the stuff that's in the libraries now really really easy to install.
13:19:53 <shapr> then you could be relatively certain that an 'anonymous' download of a cab file from wherever is probably not a trojan.
13:20:02 <shapr> I guess gpg sigs would be simpler though.
13:20:17 <shapr> yes, probably so.
13:21:21 <shapr> upon further thought, maybe that trick isn't particularly interesting =)
13:21:54 <shapr> musasabi: which parallel haskell code?
13:22:31 <shapr> musasabi: have you seen something specific that you think is already close to workable?
13:22:39 <stepcut> Lunar^: I imagine so
13:23:12 <shapr> Man, I really need unicycle armor, I landed hard on my left knee.
13:23:33 <dash> hmm 
13:23:47 <shapr> hey dash, how's code?
13:24:33 * shapr bounces
13:24:44 * dash thinks about gyroscopes and unicycles
13:24:44 <shapr> ow, knee hurts. bad for bouncing.
13:25:00 <shapr> dash: done by trevor blackwell already. 'Eunicycle'
13:25:21 <dash> trevor blackwell is a thoroughly disturbing individual
13:25:28 <shapr> he is amazingly cool.
13:25:32 <shapr> I would very much like to hang out with him.
13:25:41 <dash> and i knew this /before/ i saw his scooter/unicycle projects
13:25:48 <shapr> So did I.
13:25:55 <dash> how did you find out!
13:26:00 <shapr> via Paul Graham
13:26:04 <dash> oh really
13:26:12 <dash> what did paul graham say about him 
13:26:24 <shapr> I think he said that trevor blackwell is his best friend or something.
13:26:34 <dash> i found out by reading the code to xanalogtv
13:26:36 <flodin> shapr: whirc doesn't seem to be public though
13:26:54 <shapr> flodin: I'll ask philippa next time I get a chance.
13:27:04 <dash> shapr: have you seen xanalogtv? (comes with xscreensaver)
13:27:12 <shapr> Yes, I dearly love it.
13:27:31 <shapr> That and the almost 100% accurate Apple ][ 
13:27:31 <dash> shapr: i looked at the code, it doesn't cheat
13:27:36 <shapr> wow
13:27:41 <dash> it /really is/ a complete TV simulator
13:27:48 <shapr> I'm afraid to ask what that entails.
13:27:54 <SyntaxNinja> shapr: why don't you get unicycle armor
13:27:57 <Janni> Hi.
13:27:59 <SyntaxNinja> hi
13:28:01 <dash> lots of constants
13:28:04 <flodin> dash: what does that entail?
13:28:29 <shapr> SyntaxNinja: I made a deal with myself that I'd get it from my next paycheck, and the guys have been reallly slow paying.
13:28:44 <shapr> y0 Janni
13:29:00 <shapr> flodin: hircules is a fork of lambdabot 
13:29:05 <SyntaxNinja> shapr: but if you break a wrist, then you can't work.
13:29:15 <shapr> I only need leg armor.
13:29:23 <shapr> I have kevlar gloves.
13:29:59 <shapr> Even so, I would have rolled out of this fall just fine, but I had a backpack full of groceries on my back, so...
13:30:30 <shapr> dash: I tend to investigate along 'lines of friends' from people I find impressive.
13:30:42 <shapr> Paul Graham impressed me, so I had to see who impresses him.
13:30:46 <flodin> i never quite understood the desire in some people to put yourself in physical danger
13:30:53 <dash> """
13:30:53 <flodin> *themselves
13:30:54 <dash>   A maxim of technology is that failures reveal underlying mechanism.
13:30:54 <dash>   A good way to learn how something works is to push it to failure.
13:30:54 <dash>   The way it fails will usually tell you a lot about how it works. The
13:30:54 <dash>   corollary for this piece of software is that in order to emulate
13:30:54 <dash>   realistic failures of a TV set, it has to work just like a TV set.
13:30:55 <dash>   So there is lots of DSP-style emulation of analog circuitry for
13:30:56 <SyntaxNinja> flodin: you mean moving?
13:30:57 <dash>   things like color decoding, H and V sync following, and more.
13:30:59 <dash> """
13:31:09 <flodin> SyntaxNinja: among other things
13:31:17 <shapr> dash: whoa!
13:32:21 <shapr> flodin: Unicycling is usually safer than bicycling. Enhjulingar speeds are lower, accidents are less damaging, etc.
13:32:55 <dash> "Here we model the analog circuitry of an NTSC television. Basically, it splits the signal into 3 signals: Y, I and Q."
13:33:10 <jadrian> is there any difference between GHC.Exception.catch and Control.Exception.catch ?
13:33:39 <flodin> shapr: i'm not sure like paul graham's writings... too much word play and implicit or explicit assumptions that i don't get along well with. And too much lisp propaganda :)
13:33:43 <psi> shapr: how is your balance compared to regular bicycling?
13:34:04 <Janni> jadrian: I don't think so. GHC.Exception.catch is just GHC's implementation of Control.Exception.catch
13:34:06 <shapr> flodin: My reasons for unicycling are many, but one interesting reason is that I'm testing the saying "The only important numbers are zero, one, and infinity."
13:34:32 <flodin> but some of it is really great, albeit they always tend to get a little bit long
13:34:37 <shapr> I don't much like lisp myself, but I agree with most everything else Paul Graham says.
13:35:00 <shapr> I completely agree with his reasons for choosing Lisp, but those reasons lead me to choose Haskell.
13:35:03 <jadrian> Janni: thougt so too... I wonder why it is exported in both modules...
13:35:17 <flodin> shapr: what do those numbers have to do with unicycles?
13:35:39 <Janni> jadrian: I think Control.Exception just reexports GHC.Exception.
13:35:56 <Janni> Use Control.Exception to stay portable
13:36:03 <dash> flodin: obvious! a unicycle has one wheel
13:36:08 <shapr> psi: Unicycle balance has about four axes, as compared to the one axis that bicycle balance requires.
13:36:21 <dash> flodin: the only other reasonable alternatives are walking and infinite-wheeled devices
13:36:34 <Janni> shapr: Four? I'd say three...
13:36:38 <flodin> a bicycle kind of looks like the infinity sign
13:36:45 <Janni> shapr: Ah, forget it...
13:36:58 <flodin> and a unicycle kind of looks like zero
13:37:01 <Janni> Thinking in dimensions, there should be two...
13:37:13 <shapr> dash: exactly my thoughts on the matter, though my thoughts on infinite-wheeled devices involves transportation that dynamically reconfigures itself.
13:37:53 <Janni> What do you mean by that?
13:38:08 <Janni> I think the Transrapid would be an infinite-wheeled device
13:38:34 <Janni> Or ships
13:39:10 <flodin> nothing is _really_ infinite, it just converges toward infinity
13:39:11 * Janni rather goes back to programming...
13:39:19 <shapr> I think keeping from turning while moving, and doing controlled turning is complicated enough to count as two separate axes, but I could be wrong.
13:39:56 <flodin> if the vehicle was growing new wheels constantly maybe it could represent infinity
13:39:58 <shapr> IT feels like two separate skills to me. I think it is.
13:40:07 <shapr> flodin: that's what I was thinking about.
13:40:52 <shapr> I've also been thinking about spheres instead of wheels. I see some advantages there.
13:41:32 <shapr> Janni: I think that keeping from turning while moving is about foot usage, and turning on command is about leaning correctly.
13:41:51 * shapr shrugs
13:42:00 <shapr> I want to see someone else unicycle.
13:42:55 <shapr> flodin: what implicit or explicit assumptions do you see in PGs writings?
13:44:39 <shapr> CosmicRay: btw, Lennart Augustsson is one of the more impressive/scary programmers I've seen.
13:44:53 <shapr> hiya bobsulei88, how are ya?
13:45:59 <shapr> bobsulei88: learning Haskell?
13:47:03 <shapr> CosmicRay: there ya go, printf-style formatting.
13:47:36 <flodin> shapr: for instance, in "If Lisp is so great" he assumes that the kind of quality we think of when we talk about high-quality books also should determine what programming language we use
13:48:05 <flodin> it's a flawed analogy which he uses as the base of a "proof"
13:48:08 <shapr> hej ski 
13:48:13 <shapr> flodin: what's the flaw?
13:49:08 <flodin> well for one thing, books are read by a single person. If that person understand the difficult language in a jane austen novel, fine
13:49:08 <ski> hej shapr !
13:49:33 <flodin> programs are written in collaboration of several people over long periods of time
13:49:50 <flodin> people with varying degrees of "literacy"
13:50:46 <flodin> LISP is very far from being a language that would promote type safety, static checking, and other methods for ensuring bug-free code
13:51:16 <flodin> in LISP a type error will occur at function invocation, not definition, and sometimes only for specific arguments
13:51:17 <shapr> Yesterday I claimed that writing a program in Java is like writing a book in pidgin english, when I'd much rather use my entire decent-sized english vocabulary, aka Haskell.
13:51:18 <dash> ha ha
13:51:25 <dash> bug-free code
13:52:03 <shapr> type safety and static checking are just programming tools.
13:52:09 <flodin> same types of arguments go for producing code that the other people after me will understand easily
13:52:14 <dash> yes
13:52:22 <dash> there are problems that static checking can help with
13:52:39 <dash> but there are plenty of problems they don't help with
13:52:39 <flodin> readability and bug squashing go hand in hand
13:52:44 <shapr> guten abend nuckinucki1236 
13:52:50 <shapr> flodin: I agree!
13:53:02 <flodin> dash: that's beside the point imo. I'm just saying, paul graham doesn't deal with any of these questions
13:53:04 <shapr> but type safety and static checking don't necessarily have anything to do with readability.
13:53:15 <dash> flodin: eh? 
13:53:24 <dash> flodin: you're the one who brought it up, i thought ;)
13:53:33 <flodin> dash: yes?
13:54:04 <dash> flodin: i'm just saying that there are plenty of problems that don't especially benefit from static typechecking
13:54:08 <shapr> I do think type systems are great tools. Who was it who recently said that Haskell's type-system is 1st generation?
13:54:12 <dash> flodin: and that lisp is a good choice for them 
13:54:17 <flodin> shapr: i'm not saying they do, readability and type checking are two different points that are important
13:54:44 <flodin> dash: fine, you can say that if you like, i'm not gonna argue over that. :)
13:54:50 <shapr> dash: I disagree, I think that most problems can benefit from static typechecking. But I also think that types are just one tool among many.
13:55:07 <dash> shapr: i guess i'm only interested in ones that don't ;)
13:55:14 <shapr> bah, I don't believe that :-P
13:55:23 <dash> well clearly not
13:55:27 * shapr grins
13:55:28 <dash> since i am writing a program in haskell
13:55:35 <dash> but it is an exception ;)
13:56:27 <shapr> flodin: Personally, I think that companies should require Jane-Austen-quality literacy from programmers.
13:56:28 <dash> the class of problems i am thinking of could probably be characterized as "large-scale persistent simulations"
13:56:37 <Riastradh> Static type analysis is overrated and for the wrong reasons.
13:57:02 <flodin> shapr: there are more companies than people with that kind of literacy
13:57:28 <ski> Riastradh : overrated for the worng reasons ?
13:57:30 <Igloo> Aarg
13:57:48 <Igloo> nhc compiles hat with a 20M heap but not a 16 or 32M heap
13:57:55 <shapr> flodin: I'm not convinced of that.
13:57:57 <flodin> shapr: i'm writing lisp all day long out of neccessity, and despite decades of experience reading code, i still find it pretty confusing and hard to locate the "then" and "else" clauses in if statements (or whatever those are called in lisp)
13:58:21 <dash> flodin: what's the code do?
13:58:42 <flodin> it generates grammars attached to semantic rules
13:58:48 <shapr> flodin: so, write a tool to turn it into a whitespace-significant view that you can understand :-)
13:59:02 <shapr> one benefit of lisp is the extremely regular syntax.
13:59:07 <flodin> shapr: i don't think i should need a special tool to read the programming language. It should be easy to read from scratch
13:59:14 <shapr> I agree with you.
14:00:03 <ski> flodin : doesn't your editor indent for you  
14:00:06 <ski> ?
14:00:21 <flodin> it so happens that it does
14:00:38 <dash> shapr: i had an amusing bug yesterday
14:00:52 <Riastradh> flodin, what in particular makes it hard to distinguish the two branches?
14:01:19 <dash> shapr: in my code to process quoted lists, i was doing "foldM pairify nil addresses"
14:01:44 <dash> shapr: unfortunately, I forgot that it was foldl instead of foldr :)
14:01:49 <shapr> hehe
14:01:53 <shapr> that *is* funny.
14:01:56 <dash> so '(1 2 3) evaluated to (((nil . 1) . 2) . 3)
14:02:02 <flodin> Riastradh: well one thing, I think, is separating the body of the 'then' clause from the body of the 'else' clause. I have to try to see how things align vertically with my eyes, instead of simply looking for the word "else"
14:02:03 * shapr laughs
14:02:06 <shapr> dash: very cute =)
14:02:21 <Riastradh> flodin, you can always use COND if you like.
14:02:27 <dash> it was a pleasant surprise that it got that far, really :)
14:02:34 * shapr does use cond when writing lisp
14:02:38 <dash> so i wrote foldrM
14:02:51 <shapr> dash: you probably don't want that.
14:02:55 <Riastradh> If the initial characters are too far apart to distinguish their alignment, however, there is simply too much code anyway.
14:02:59 <dash> shapr: maybe not :)
14:03:17 <dash> shapr: can you suggest alternatives?
14:03:22 <flodin> Riastradh: it's better but not good. In this case though, i prefer if for efficiency
14:03:29 <Riastradh> Efficiency of what?
14:03:35 <flodin> of parsing
14:03:37 <shapr> iirc, foldM is left because otherwise all the thunks build up for a grand finale.
14:03:41 <flodin> well
14:03:48 <flodin> it's a bit complicated :)
14:03:56 <dash> shapr: foldrM f z (x:xs) = (foldrM f z xs) >>= \fzxs ->  (f x fzxs)
14:03:59 <dash> shapr: so, yes.
14:04:38 <flodin> i'm using lisp for semantic rules in the parser and the semantic rules have to be executed fairly often during parsing
14:04:40 <Riastradh> I don't understand.  You were just complaining that reading IF was harder & required more effort than something with a simple ELSE token, which would be there in COND.
14:04:56 <shapr> imho, the one real obstacle in Haskell programming is avoiding space leakis.
14:05:25 <Riastradh> Huh?  What does that have to do with IF versus COND, flodin?
14:05:44 <shapr> flodin: my theory is that four Haskell-literate programmers can often (always?) make up for fourty Java-literate programmers.
14:06:08 <shapr> Of course, I'm just talking about programmer literacy levels, so not necessarily Haskell itself :-)
14:06:12 <Lunar^> head still broken :(
14:06:15 <jadrian> is there sucha thing as Java literate programming?
14:06:22 <jadrian> oh!
14:06:24 <Lunar^> GHC HEAD, sorry :)
14:06:32 <jadrian> literate in that sense :)
14:06:42 <flodin> Riastradh: cond takes longer to evaluate. It's my own lisp interpreter, executing during parsing of code
14:06:49 <jadrian> I was thinking about literate programming
14:06:54 <shapr> haha
14:07:20 <SyntaxNinja> does simonMar come around here anymore?
14:07:23 <Riastradh> flodin, uh, you don't macro-expand first?
14:07:39 <shapr> SyntaxNinja: he told me 'not since his gaim installation broke'
14:07:40 <flodin> Riastradh: in any case, i only have about two lines of code in the 'then' clause, so i don't think it's too much code
14:07:40 <Igloo> Java has a dstandard way of doing things like giving descriptions of methods
14:07:43 <SyntaxNinja> heh
14:07:46 <Igloo> /** */ or osmething IIRC
14:07:54 <flodin> but it's two nested ifs
14:07:58 <SyntaxNinja> shapr: we shuold fix that for him
14:07:58 <shapr> Igloo: you mean javadoc?
14:07:59 <flodin> and the second else just gets lost
14:08:05 <Igloo> Maybe
14:08:10 <shapr> Just
14:08:11 <flodin> Riastradh: i don't have macros
14:08:17 <Igloo> Do I look like a Java programmer to you?  :-)
14:08:23 * shapr laughs
14:08:25 <shapr> no, not really.
14:08:55 <Riastradh> flodin, that's silly.  You have primitive special forms for all things that any Lisp programmer would consider macros, such as COND?
14:09:06 <flodin> Riastradh: it's not literally lisp, i'm just taking some of the syntax from lisp
14:09:24 <dash> flodin: oh. well put in "else" tokens then
14:09:30 <flodin> the point is really to implement something that's more powerful than lisp macros anyway
14:09:42 <dash> flodin: Hmm. More powerful in what regard?
14:09:49 <Riastradh> But you can't implement simple things like COND that way?
14:10:17 <flodin> Riastradh: i can, but i haven't. I have to start somewhere. I would implement the 'new' way of parsing cond by using the basic lisp-style language
14:10:54 <flodin> dash: in the regard that i can modify any part of the grammar
14:11:06 <flodin> dash: and the grammar also covers lexical items
14:11:09 <shapr> flodin: I think that programmers who are comfortable with metaprogramming, automation, abtraction, etc are sufficiently more productive than 'codemonkeys' that there's very little reason to hire codemonkeys. But I may be wrong. Some people say it's near impossible to find even neophyte hackers much less wizardly hackers.
14:11:26 <dash> flodin: hmm
14:11:36 <dash> flodin: like reader macros, then
14:11:44 <flodin> dash: this code defines yacc-style syntax using the basic lisp language. Then it uses the yacc syntax to define C. Then it defines a C function. http://www.cs.umu.se/~flodin/thesis/input.loom
14:12:24 <dash> ow, my eyes
14:12:53 <flodin> heh don't complain, that's how vim indents it
14:13:12 <dash> vim doesn't make you put closing parens on separate lines
14:13:31 <flodin> how else would i make sure there are enough of them
14:13:36 <dash> %
14:13:42 <Riastradh> OK, this is just ridiculous.
14:13:44 <dash> or use emacs and turn on paren-highlight
14:14:02 <dash> though vim probably has something like that now, i bet
14:14:27 <shapr> So, I think programmers should spend at least one third of their 'productive' time improving their skills. Because codemonkeys just aren't worth it.
14:14:30 <dash> i wrote a C parser in CL, once
14:14:36 <dash> want to see it? >:D
14:15:09 <SyntaxNinja> shapr: and one-third resting ;)
14:15:18 <shapr> haha
14:15:19 <flodin> well i'm not going to define %, but that particular part is far from the worst
14:15:19 <dash> http://ghostwheel.ddts.net/~washort/c-parse/c-parse.lisp
14:15:38 <dash> flodin: no, it is a key you push in vim 
14:15:45 <shapr> SyntaxNinja: have any of your coworkers newly read tPP?
14:16:06 <ski> tPP ?
14:16:16 <flodin> dash: like i said (well, paraphrased), a language shouldn't need special tools just to be able to type it in
14:16:17 <shapr> "The Pragmatic Programmer"
14:16:28 <ski> ty
14:16:36 <shapr> ski: have you read it?
14:16:37 <dash> flodin: by what standard?
14:16:57 <flodin> huh?
14:17:05 <dash> flodin: you said "should"
14:17:07 <ski> shapr : not sure (prolly not), is it just a site, or a book too ?
14:17:16 <dash> flodin: i am wondering what standard says that
14:17:30 <flodin> dash: i don't speak RFC english
14:17:39 <dash> flodin: i am not talking about RFCs
14:17:46 <dash> flodin: i am talking about how you decided that :)
14:18:01 <shapr> ski: it's a book.
14:18:11 <dash> (also if you think paren-matching is a special tool then i have to wonder what isn't a special tool)
14:18:32 <flodin> by my own experience
14:18:43 <flodin> i think many editors don't have paren matching
14:19:09 <flodin> does vi even have it? or is it some vim extension
14:19:22 <dash> vi does
14:19:36 <dash> but who cares everyone has vim 
14:19:39 <Riastradh> Almost every reasonable editor does.
14:19:50 <shapr> Yi doesn't yet have parenthese matching.
14:19:59 <dash> i think Yi is imaginary
14:19:59 <Riastradh> That's because it's still young.
14:20:03 <flodin> anyway, that's far, far strayed away from what i wanted to discuss
14:20:12 <shapr> dash: try it, it's not imaginary.
14:20:24 <shapr> yi WINS!
14:20:32 <dash> shapr: i could! but how would I know if i was imagining it working or not working
14:20:44 <shapr> write a unit test?
14:20:45 <flodin> people always seem to get touchy about the parens :)
14:21:05 <dash> flodin: yeah, what's up with that
14:21:28 <shapr> flodin: your thesis journal is neat, reminds me of when I came to many of those same realizations.
14:21:40 <flodin> hehe
14:21:59 <SyntaxNinja> shapr: no, I've been hoarding it
14:22:04 <flodin> thanks
14:22:34 <shapr> SyntaxNinja: cool! are you applying it?
14:22:57 <dash> flodin: have you seen this? http://home.pipeline.com/~hbaker1/Prag-Parse.html
14:23:06 <shapr> Programming is like executable ideas, machines built from thoughts.
14:23:19 <marcot> Hello, I'm having a problem using the network module in Linux.
14:23:31 <shapr> what's the problem?
14:23:34 <flodin> dash: no
14:23:44 <marcot> In windows it was working fine, but here I got the error *** Exception: bind: resource busy (Address already in use)
14:23:52 <flodin> dash: what about it_
14:23:53 <flodin> ?
14:24:01 <shapr> marcot: that means someone is already using that port.
14:24:05 <dash> flodin: It seems related to stuff you're doing
14:24:10 <dash> flodin: but maybe i'm misreading :)
14:24:13 <marcot> shapr: hum.. possibly me.
14:24:17 <flodin> dash: ah, ok thanks :)
14:24:31 <monochrom> Wait a few minutes. The port will be released.  (This assumes you had a program using the port and you recently killed it.)
14:24:49 <shapr> you may also want to look at psyco, which I think lets you write inline C in Python programs.
14:24:52 <flodin> dash: it doesn't sound like it's general enough for my use though. I'm parsing all context-free grammars including ambiguous and left-recursive ones
14:25:00 <marcot> The code is at http://tonhao.no-ip.org/~marcot/xadrez/Main.hs and Conexao.hs
14:25:09 <shapr> flodin: have you already read about PackRat parsing?
14:25:10 <flodin> dash: which is neccessary because the user can extend the grammar
14:25:18 <dash> flodin: yeah, the examples he gives are slightly underpowered
14:25:20 <marcot> The 2's functions were working fine in windows.
14:25:23 <flodin> shapr: yeah, packrat doesn't handle left recursion
14:25:28 <marcot> But here in Linux, just this message.
14:25:28 <shapr> oh
14:25:32 <dash> flodin: but I suspect the reader-macro technique could be extended
14:25:43 <dash> anyway
14:25:51 <shapr> marcot: if you have the program installed, "lsof -i" will show you who's using that port.
14:25:54 <marcot> Am I using the sendTo recvFrom functions correctlu?
14:25:57 <dash> it's going to be interesting to see how perl6's rule system turns out
14:26:40 <marcot> Shammah: I don't have it.. what port could I try, that noone will be probably using it?
14:26:44 <flodin> dash: i'll keep the link for reference, thanks
14:26:49 <dash> hopefully the idea of patterns that can reasonably include other patterns and call functions will make their way into other languages
14:27:12 <dash> flodin: the parser I wrote was based on this
14:27:28 <dash> flodin: i ended up having to interleave a lot of code into the patterns, it was kinda messy :)
14:27:57 <flodin> yeah well, the thing with my code there is that you can define new ways of defining syntax, too
14:28:12 <flodin> so you can to some extend abstract away the need to insert lots of low-level code everywhere
14:28:15 <flodin> *extent
14:28:50 <flodin> the C code at the end is defined using the syntax which is defined at the top of the file
14:29:54 <flodin> it's parsed properly now but i don't have a lot of semantics tied to it
14:30:05 <flodin> oh and there's some nasty problem with the greedy parsing
14:30:18 <marcot> ghc-6.2.1 17114 marcot    3u  IPv4 114230       TCP *:13033 (LISTEN)
14:30:35 <flodin> it parses "sizeof_n" as 'sizeof' and '_n' then complains that _n is not a variable
14:31:02 <marcot> How can I make it doesn't do this?
14:31:16 <shapr> hej internot 
14:31:36 <internot> Hej hej
14:31:47 <shapr> How's code in the big city?
14:32:13 <internot> well.. At the moment I'm slightly stuck..
14:32:19 <marcot> Is there a better way to do a peer to peer connection than using these two functions?
14:32:52 <shapr> internot: stuck on code?
14:33:12 <SyntaxNinja> shapr: not quite yet, a bit of the principals, but I need to get through and make a TODO list from it :)
14:33:14 <SyntaxNinja> that's my big plan.
14:33:25 <internot> nah, stuck on porting hs-plugins to win..
14:34:44 <shapr> SyntaxNinja: oh, I'm *very* interested in any high points you want to mention.
14:34:54 <shapr> internot: talked to dons already?
14:35:06 <shapr> internot: are you part of the IDE team?
14:35:08 <internot> No, haven't gotten ahold of him..
14:35:15 <internot> Yeah :)
14:35:47 <flodin> shapr: what were you doing when you 'came to many of those same realizations', btw?
14:36:05 <shapr> flodin: often arguing with dash  =)
14:36:09 * shapr pokes dash 
14:36:16 <shapr> back when dash was still washort.
14:36:20 <internot> shapr: I've managed to compile it, but something goes wrong when linking with it..
14:37:34 <shapr> internot: do you have a short description of the linking error?
14:39:27 <shapr> flodin: do you have a more specific question than that? do you mean, where did I pick up some neat ideas about programming, what books, what activities, which people? or what do you mean?
14:39:59 <internot> libHSplugins.a(Make.o)(.text+0x19a4):ghc2056.hc: undefined rference to 'SystemziProcess_waitForProcess_closure'
14:40:12 <flodin> shapr: no i was more wondering if you did anything like what i'm doing now
14:40:22 <flodin> since it's hard to find people with advice on it :)
14:40:28 <internot> shapr: about 15 errors like my previous message...
14:40:43 <shapr> flodin: how would you define "what you're doing now" ?
14:40:58 <shapr> writing a language? studying CS? writing a parser? or what?
14:41:11 <shapr> trying to understand extensible languages?
14:41:38 <shapr> internot: I know dons said that hs-plugins doesn't work on windows, and I forget exactly why. I thought it was dlopen?
14:41:46 <flodin> well, implementing an extensible language, for one thing. Another is, writing a scannerless parser
14:42:44 <marcot> Can someone please help me using sendTo and recvFrom functions?
14:43:35 <flodin> i don't know of any language that is as hysterically extensible, in the sense that you can define languages such as C or python or haskell within it, including whatever lexical conventions that entails
14:43:46 <shapr> internot: aha, I found it.
14:44:06 <shapr> <Philippa> dons: what's the state of hs-plugins and win32? <dons> well, I'm waiting for 6.4 to be released. then i'll have a portable System.Process library <dons> rather than writing my own one
14:45:47 <shapr> internot: From what dons said, and since your linking errors mention waitForProcess, I suspect that GHC's System.Process doesn't work on win32.
14:46:27 <shapr> marcot: have you tried writing isolated test functions?
14:47:11 <internot> shapr: Ok, cool! I downloaded the most recent version from the CVS and rewrote it a bit and after that it went through the compiler.. My guess is that it's because I'm using GHC 6.2.1, so I'm going to try to update.. 
14:47:50 <shapr> yah, 6.3 might have gotten to the point of running hs-plugins correctly on win32
14:48:05 <shapr> 6.3 == cvs version of GHC
14:48:38 <internot> I think so, since System.Process is part of package base in that version..
14:48:53 <internot> brb
14:49:51 <Igloo> @index unfoldr
14:49:51 <lambdabot> Data.List,List
14:51:03 <irce> does anyone know why the first code example in http://tinyurl.com/4vrbd (pdf) is so extrordinary?
14:51:18 <internot> back
14:53:41 <marcot> *Conexao> do s <- recvFrom "localhost" (PortNumber 13035); putStr s
14:53:42 <marcot> Ola*Conexao> do s <- recvFrom "localhost" (PortNumber 13035); putStr s
14:53:42 <marcot> *** Exception: bind: resource busy (EndereÃ§o jÃ¡ em uso)
14:53:53 <marcot> On the second try it doesn't work.
14:55:47 <shapr> marcot: I bet it works fine in an executable
14:56:10 <shapr> irce: which page?
14:56:47 <irce> 3
14:57:27 <shapr> figure 2?
14:58:45 <irce> jep and the rest of the page
14:58:50 <marcot> shapr: hum... does it make difference?
14:59:52 <shapr> marcot: yes. your socket isn't being garbage collected. not sure why exactly.
15:02:18 <shapr> irce: writing code in terms of the domain allows for more simple and elegant expression, and can allow use by non-programmer domain experts.
15:03:20 <shapr> Hudak's papers mention DSELs for scoring music, choreographing dance, and lots of other neat DSELs.
15:03:50 <marcot> compilation IS NOT required
15:03:56 <marcot> Why does ghc give this message?
15:04:15 <shapr> because you haven't changed the source for that .o file.
15:04:47 <marcot> Conexao.o(.text+0x1b): In function `__stginit_Conexao_':
15:04:47 <marcot> : undefined reference to `__stginit_Network_'
15:04:51 <marcot> A lot of errors like that.
15:04:59 <Lunar^> marcot: -package unix ?
15:05:05 <shapr> or -package network ?
15:05:15 <shapr> g'day Pseudonym 
15:05:31 <marcot> Sorry, first time compiling with packages.
15:05:31 <shapr> irce: what do you think? does this code look unimpressive?
15:05:46 <irce> shapr: ok. where did you find that about scoring music and choreographing dance?
15:06:09 <Pseudonym> G'day.
15:06:13 <marcot> xadrez: internal error: main thread has been GC'd
15:06:13 <marcot>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
15:06:13 <marcot>     or http://www.sourceforge.net/projects/ghc/
15:06:14 <shapr> Hudak's publications page mentions those among others.
15:06:16 <marcot> And what's this?
15:06:17 <irce> well. gotto read more haskell tutorials :)
15:06:26 <irce> ok
15:06:29 <Riastradh> The main thread was GC'd and you should report a bug, duh!
15:06:42 <marcot> I've tried to run main, but nothing happened...
15:06:47 <shapr> marcot: that most likely means you're using ghc 6.2.1 and hit ^C while the program was starting?
15:06:48 <marcot> Riastradh: thank you for your education.
15:06:58 <Riastradh> Sorry, couldn't resist.
15:07:15 <shapr> irce: what do you think of domain specific embedded lanugages?
15:07:36 <marcot> If I knew what a GC'd is I would never has asked.
15:07:47 <shapr> GC == garbage collection
15:08:11 <Riastradh> It means that the memory used to represent the main thread was reclaimed.
15:09:07 <marcot> Ok... But, what's happening is strange. In ghci, when I load Main.hs and do main, it works fine (the first main command is putStr ".."), but with ./xadrez (the binary file), nothing happens.
15:09:47 <irce> shapr: promising   
15:10:22 <SyntaxNinja> marcot: it outputs nothing at all? how are you compiling it?
15:10:35 <marcot> ghc -o xadrez -package network Constantes.hs Peca.hs Linha.hs Tabuleiro.hs Entrada.hs Conexao.hs Main.hs
15:10:38 <SyntaxNinja> and main looks like 'main = putStr ".."
15:10:45 <Lenny1729> Hi all
15:11:34 <SyntaxNinja> hi marcotsorry, i didn't scroll back
15:11:44 <SyntaxNinja> so it's crashing on garbage collection?
15:12:03 <marcot> SyntaxNinja: the code is at http://tonhao.no-ip.org/~marcot/xadrez/Main.hs
15:12:31 <SyntaxNinja> are you using the ffi?
15:12:47 <marcot> SyntaxNinja: what's ffi?
15:13:23 <Lemmih> marcot: Looks like a buffering problem.
15:13:24 <SyntaxNinja> foreign function interface
15:13:58 <marcot> Actually, without the Conexao module, it was working ok. I think that the problem may be in something related to it.
15:14:04 <SyntaxNinja> Lemmih: with the gc error he reported?
15:14:10 <SyntaxNinja> oops, bbiab...
15:14:36 <Lemmih> SyntaxNinja: Oh. That just happens when you make a keyboard interrupt.
15:15:06 <Lemmih> (C-c)
15:15:18 <marcot> That error message is just in the C-c
15:15:27 <marcot> But nothing happens when I don't press nothing.
15:16:14 <Lemmih> marcot: I think you would benefit from setting stdout to NoBuffering.
15:16:32 <marcot> Lemmih: how do I do this?
15:16:47 <Lemmih> 'putStr "hello world"' doesn't actually print anything if you're writing to a LineBuffered device.
15:17:01 <Lemmih> @type hSetBuffering
15:17:02 <lambdabot> bzzt
15:17:40 <Lemmih> @type System.IO.hSetBuffering
15:17:41 <lambdabot> System.IO.hSetBuffering :: GHC.IOBase.Handle
15:17:41 <lambdabot> 			   -> GHC.IOBase.BufferMode -> IO ()
15:18:00 <Lemmih> So it would be: hSetBuffering stdout NoBuffering.
15:18:24 <marcot> hum.. I'll try it here.
15:20:09 <marcot> Lemmih: now it worked the local part.
15:20:23 <marcot> Lemmih: but the network part is still with the same problem.
15:21:39 * Lemmih scrolls back to find out what problem marcot is refering to.
15:21:55 <marcot> sendTo and recvFrom.
15:21:57 <marcot> The thing is:
15:22:10 <marcot> I'm doing a chess game for be used by two computers only.
15:22:14 <marcot> Giving ip and stuff..
15:22:31 <marcot> I was trying to use these functions, and it worked ok in windows.
15:23:52 <marcot> But here on gnu/linux, it's just not working.
15:24:36 <Lemmih> marcot: Are you sure you wanna use connectionless networking?
15:24:44 <marcot> Lemmih: no...
15:24:51 <marcot> Lemmih: I thought it would be easier.
15:24:58 <marcot> Lemmih: so let me get back to the old way.
15:26:23 <marcot> Lemmih: when I do:
15:26:50 <marcot> do serv <- listenOn porta 
15:26:50 <marcot> 	 tupla <- accept serv
15:26:50 <marcot> 	 return (primeiro tupla)
15:27:04 <marcot> This is a small function for initializing the server.
15:28:33 <Lemmih> 'primeiro' is a pure operation which handles the connection?
15:28:52 <bringert> hmm, seem to have messed up my ipod good
15:29:01 <marcot> Lemmih: no, it gets the first element of a triple
15:29:06 <marcot> (a, b, c) -> a
15:29:24 <Lemmih> Oh ok.
15:29:25 <bringert> anybody have a 4th gen ipod around? I seem to need a copy of the firmware
15:31:51 <marcot> Lemmih: after the 'servidor' function, which initializes the server, theses a putStr that's never reached.
15:32:57 <Lemmih> marcot: How do you know it's never reached?
15:33:32 <marcot> Lemmih: at least, it doens't go to the screen.
15:34:03 <marcot> jogoServidor = do h <- servidor ; putStr ...
15:34:12 <Lemmih> Did you change the buffering for both client and server?
15:34:40 <SyntaxNinja> bringert: is that the scroll-wheel one?
15:34:58 <bringert> click-wheel
15:35:08 <bringert> i.e. no buttons
15:35:14 <SyntaxNinja> marcot: buffering, as well as laziness can influence what gets printed out and when
15:35:17 <bringert> it's the latest version
15:35:34 <Lemmih> 'accept' first returns when there's an incomming connection.
15:35:42 <marcot> Lemmih: yes.
15:35:50 <marcot> Lemmih: ah... ok.
15:35:53 <Lemmih> So did you connect to the server?
15:36:17 <SyntaxNinja> bringert: I sent you a msg. were you formatting it under linux or something?
15:36:31 <marcot> ok..
15:36:39 <bringert> I was using it under linux
15:36:48 <bringert> suddenly it wouldn't mount read-write
15:37:08 <bringert> then it would just show a folder with an exclamation mark
15:37:23 <bringert> apple support says to do a restore
15:37:30 <bringert> but I don't have a windows box handy
15:37:34 <SyntaxNinja> yeah
15:37:34 <bringert> or mac
15:37:51 <SyntaxNinja> hm. I don't know if the box i'm on right now has the ability to read from my ipod
15:38:04 <bringert> so I was thinking I could recreate the partitions manually and dd the firmware back in
15:38:14 <SyntaxNinja> yeah; I've seen instructions for how to do that.
15:38:37 <bringert> but the firmware itself is not downloadable, just some .exe
15:38:38 <SyntaxNinja> oh, actually I don't have it with me :( my laptop is broken so I left the bag at home
15:39:03 <SyntaxNinja> right. you need to get the firmware off of one and reload it.
15:39:49 <bringert> I'll try to use a mac at work tomorrow to run restore
15:40:12 <SyntaxNinja> OK email me if I can help, I have the same one you do and use it in linux.
15:40:23 <marcot> Lemmih: yes, now it's connecting.
15:40:25 <bringert> is yours HFS+-formatted?
15:40:42 <marcot> Lemmih: the problem is that after I connect, the client is not reading the server information.
15:40:55 <marcot> Lemmih: from the jogoCliente function:
15:41:06 <marcot> jogDele <- le h
15:41:16 <marcot> It's stopping there.
15:43:09 <SyntaxNinja> bringert: no, I reformatted it fat32
15:43:24 <SyntaxNinja> did that with a windows box, which I think is the only sane way to do it :)
15:43:40 <bringert> yeah, I think I'll do that too
15:44:00 <SyntaxNinja> so were you reading & writing w/ HFS+?
15:44:03 <bringert> yeah
15:44:11 <bringert> for a while :)
15:44:18 <SyntaxNinja> yeah, kinda dicey in linux
15:44:42 <bringert> hmm, no windows at chalmers
15:45:00 <bringert> will need to find a windows box with fw or usb2
15:45:19 <SyntaxNinja> it's a PIA too because I think it needed a very specific version of windows
15:45:29 <bringert> why do they only have osx and win32 programs? noone uses windows anymore :)
15:45:31 <SyntaxNinja> well, at least I tried it on several windows machines which weren't Good Enough
15:47:31 <bringert> thanks, I'll try
15:47:33 <bringert> good night
15:48:57 <marcot> Lemmih: NoBuffering on the handler is not working for the connection.
15:54:43 <marcot> bah...
15:54:48 <marcot> It was hPutStr
15:54:54 <marcot> It should be hPutStrLn
15:56:56 <marcot> uhu!!!!
16:18:53 <marcot> Lemmih: if you want to play chess... =P
16:36:23 <shapr> I wish programming journals had RSS feeds.
16:38:55 <stepcut> heh
16:47:12 <shapr> In any case, I'm nearly out of interesting papers to read. I need some new input.
16:48:00 <Pseudonym> scholar.google.com is your friend.
16:48:39 <Pseudonym> I've been reading about static single assignment form lately on a whim.
16:49:26 <dons> ssa gives me nightmares
16:49:37 <shapr> g'day dons 
16:49:43 <dons> hey shapr!
16:50:01 <shapr> hs-plugins on win32 with 6.3?
16:50:04 <Pseudonym> Well, I still have as a background task, a compiler for a certain domain-specific imperative language.
16:50:09 <Pseudonym> And SSA form looked good to me.
16:50:14 <Pseudonym> Array SSA form, to be precise.
16:50:20 <Pseudonym> G'day, BTW. :-)
16:50:41 <shapr> I thought of 'perverting' Hudak's Dance DSEL and turning it into a way to automatically generate martial styles.
16:50:44 <dons> shapr: hs-plugins on win32?
16:50:45 <shapr> g'day Pseudonym 
16:51:07 <shapr> does System.Process work with ghc cvs head?
16:51:15 <dons> yep. it's portable too
16:51:24 <dons> that's what hs-plugins win32 will be using
16:51:46 <dons> haven't got around to that yet .. mostly due to lack of a machine to test on
16:51:52 <shapr> ah, cool. Someone from the Haskell IDE team at chalmers was trying to port hs-plugins to win32 a few hours ago.
16:52:38 <dons> that sounds good. cool cool
16:53:07 <shapr> I suspect that finishing and release Fermat's Last Margin will be more conducive to my continuing entertainment than even scholar.google.com
16:53:56 <shapr> Because, reading research papers is fun, but discussing and connecting them in a group along with other smart people is far more fun.
16:55:09 <shapr> dash: have you investigated the connection between linear types and quantum computing?
16:55:33 <shapr> Does HUnit have a way to do test fixtures?
16:55:44 <stepcut> is Fermat's Last Margin something you are writting?
16:56:28 <shapr> Yup. Basically it's a distributed wiki with a notes page for each research paper page.
16:56:57 <dons> mmm. coffee
16:57:12 <stepcut> The description of my article is wrong and I am appropriately outraged. How do I have it corrected? 
16:57:21 <stepcut> haha (from the scholar.google.com faq)
16:57:44 <stepcut> shapr: sounds neat
16:58:25 <shapr> Pseudonym gave me the idea with his comonads and IO discussion that keeps popping up every few months.
16:58:32 <Pseudonym> :-)
16:58:38 <shapr> sorry, comonads and OI
16:59:31 <stepcut> sweet! a comonadic wiki!
16:59:36 * shapr snickers
16:59:47 <Pseudonym> Yay, an unsafe wiki!
16:59:58 <stepcut> unsafeEditPage
17:00:02 <dash> shapr: no
17:00:06 * Pseudonym has a suspicion that he was the first person who actually tried out that comonad library
17:00:13 <Pseudonym> Otherwise someone else would have spotted it first.
17:00:22 <Pseudonym> Why do I never get asked to review papers, that's what I want to know.
17:00:35 <stepcut> Pseudonym: I will ask you to review my next paper
17:00:46 <shapr> Thing is, there's no 'central' persistent forum to discuss research papers.
17:00:49 <Pseudonym> Ah, OK. :-)
17:01:09 <shapr> Research papers don't have comments turned on. So I'm fixing that.
17:03:43 <wagle> how do you peer review wiki?
17:03:45 <Pseudonym> Actually, wiki-based review might be handy, too.
17:03:57 <Pseudonym> Put your preprints there.
17:04:33 <wagle> i guess i was meaning "how do you quality control the wiki edits and re-edits"?
17:04:49 <Pseudonym> Same way that any wiki does.
17:05:03 <Pseudonym> That's my guess.
17:05:05 <wagle> the (recent) claim is that wiki doesnt
17:05:22 <Pseudonym> No, the recent claim is that _wikipedia_ doesn't.
17:05:29 <wagle> (i wdoner where i saw/read that)
17:05:34 <wagle> ah.. yes, that was it
17:05:40 <Pseudonym> There's a difference here, because paper annotations are by definition opinions.
17:05:53 <Pseudonym> Whereas wikipedia is supposed to be a bit above mere opinion.
17:06:52 <shapr> FLM has a very simple quality control. It'll use darcs, and it'll be pull-only.
17:07:25 <shapr> So, I can pull wiki content from Pseudonym, or from dash, or whoever I want.
17:07:30 <shapr> and they can pull from me.
17:07:41 <Pseudonym> That's a good idea.
17:08:15 <shapr> and if lambdabot's darcs repo has spam in it, I rollback his patches, and I take his repo out of my pull list.
17:09:30 <shapr> wagle: think it'll work?
17:10:21 <arjanb> how would you find repo's which have annotations the papers you are reading?
17:10:46 <Pseudonym> A web of trust might be handy here.
17:11:02 <Pseudonym> So, for example, I trust shapr's annotations a lot, but not lambdabot's so much.
17:11:10 <Pseudonym> So then if you trust me, my trust is inherited.
17:11:31 <shapr> Right, anything that Pseudonym has pulled into his repo, I get automatically.
17:11:38 <wagle> i think its worth trying
17:11:43 <Pseudonym> It'd be like Linux.
17:11:58 <Pseudonym> Some people track Linus' tree, other Alan Cox', other Red Hat's etc.
17:12:06 <wagle> i WOULD like to see feedback on papers i'm looking at
17:12:07 <Pseudonym> But Red Hat make sure they track Linus' tree too.
17:12:07 <shapr> So, if he suddenly gets subverted by the australian procedural language mafia, and his repo starts including Java advertisements...
17:12:19 * Pseudonym shudders
17:12:38 <Pseudonym> Or hacked by Brazilian script kiddies named Ramone.
17:12:51 <Pseudonym> Which is a more likely scenario.
17:12:57 <wagle> the drawback might be that it makes followup papers harder to publish
17:13:05 <shapr> why? how so?
17:13:46 <shapr> it might make followup papers easier to publish, if you suddenly get five new ideas from the comments of smart and interested people.
17:14:02 <wagle> since the discussion raises the bar of "significant contribution" without being particularly publishable in and of itself
17:14:19 <wagle> i'm just brainstorming..  
17:14:40 <shapr> you have a good point, you're not the first person to mention that exact fact :-)
17:14:53 <tuomov> I've also occasionally been thinking of a trust metric basic news system
17:14:59 <tuomov> s/basic/based/
17:15:21 <tuomov> everything that those you trust have approved will be forwarded for you to read too and so on
17:15:42 <Pseudonym> One suggestion, though.
17:16:00 <Pseudonym> If shapr and I pull annotations from the same source, will they be duplicated if you include both of ours?
17:16:04 <shapr> but then again, I'm a self-employed programmer with zero formal computer science training, and no budget for academic journals, so if I can snatch the whole process out of the claws of Springer-Verlag et al I'll be thrilled.
17:16:16 <shapr> Pseudonym: no, they're just patches.
17:16:21 * Pseudonym hmms
17:16:32 <Pseudonym> So you need a format which annotates each comment by where it came from.
17:16:40 <Pseudonym> But that's just a format problem.
17:16:41 <shapr> darcs already does this.
17:16:44 <dash> tuomov: shapr and i talked about that a long while back :)
17:16:46 <Pseudonym> Ah, OK.
17:16:56 <shapr> dash: wow, you remember PeopleFilter?
17:17:52 <shapr> Pseudonym: only downside is that darcs has some complexity issues...
17:20:01 <Pseudonym> shapr: True.
17:20:18 <Pseudonym> What you _actually_ want is for annotations to be mostly self-contained.
17:20:27 <Pseudonym> Say, one darcs file per annotation.
17:20:34 <Pseudonym> Rather than a lot of annotations in the one file.
17:21:00 <Pseudonym> It might be a little more expensive, but the semantics would be correct.
17:21:10 <shapr> I dunno, I just want it to work :-)
17:21:15 <Pseudonym> :-)
17:21:18 <tuomov> signed annotations with hashed name that can only be modified by patch signed by the same key
17:21:37 * Pseudonym would reserve that for future expansion
17:21:53 <Pseudonym> Personally, I might want to correct the spelling of annotations that I pull locally, if they offend me.
17:22:30 <Pseudonym> Or highlight the most salient points.
17:22:32 <tuomov> locally perhaps, but external changes shouldn't usually be applied without proper signature
17:22:41 <Pseudonym> Well they wouldn't be applied upstream.
17:22:48 <Pseudonym> They'd be applied to _my_ repository only.
17:23:03 <shapr> somedays I agree with tuomov, and somedays I think the complete anarchy of standard wikis is better. I really don't know.
17:23:10 <Pseudonym> And others could pull my repository, but they would know that it's not necessarily a true and correct copy of what I pulled.
17:23:24 <Pseudonym> I think that's the best of both worlds.
17:23:32 <Pseudonym> Local autonomy, global anarchy.
17:23:40 <shapr> right, I like that. Sometimes.
17:23:56 <Pseudonym> The only problem is I could make a local change which misrepresents someone upstream.
17:23:58 <shapr> On the other hand, maybe each person should have their own 'channel' and you can turn them on and off?
17:24:03 <Pseudonym> But then, that would reduce my social trust.
17:24:04 <tuomov> everyone's free to apply whatever changes they wish, but there should be a way to protect "anonymous" reputation 
17:24:11 <Pseudonym> Hmmm.
17:24:19 <shapr> darcs annotations will show you who made what change and when.
17:24:37 <Pseudonym> Anonymity is a good thing in general, but I'm not sure if it's useful here.
17:24:37 <tuomov> => signatures
17:25:03 <Pseudonym> I guess you could say that anonymous contributions must be signed to be accepted into a particular repository.
17:25:07 <tuomov> identity is just your public/private key unless you want to give out more
17:25:10 <shapr> There's also the possibility that the reader may want to read the notes made by only a few people, rather than the notes made by all people ever.
17:25:10 <Pseudonym> That could be a policy of that repository.
17:25:34 <tuomov> everyone can create multiple identities, of course
17:25:45 <Pseudonym> So in addition to my repository, there are other repositories which accept anonymous contribution.
17:25:48 <Pseudonym> Signed if necessary.
17:25:53 <Pseudonym> And I can choose what to pull from that.
17:25:55 <shapr> I think that if people actually use this software at all, I'll be thrilled :-)
17:26:15 <Pseudonym> :-)
17:28:15 <wagle> fix the slashdot rating system 8) 8/
17:28:44 <tuomov> I think it works fairly well on less popular articles
17:29:02 <tuomov> on the more popular articles funny comments dominate and lots of intresting stuff remains undiscovered
17:29:51 <tuomov> but I don't follow /. that actively
17:29:54 <dash> the pervasiveness of RSS at least makes the idea more feasible than it was a while back
17:30:07 <Pseudonym> RSS would be an interesting model, too.
17:30:19 <Pseudonym> But I think shapr has settled on darcs.
17:31:26 <shapr> darcs and flippi already exist, and they're both Haskell.
17:31:58 <Pseudonym> Rght.
17:32:26 <Pseudonym> But Haskell is a very nicely abstracted language, so I figure the darcs part can be swapped out if the need arises.
17:33:51 <tuomov> I'd like to have stuff on top of freenet/mute..
17:34:32 <Shammah> has anyone implemented a beep library for haskell?
17:34:53 <dons> beep?
17:37:16 <shapr> Someone once mentioned working on one, but I don't remember who. Maybe you?
17:37:31 <Shammah> pretty sure I haven't ever mentioned beep and haskell before.
17:37:45 <shapr> then I don't remember who.
17:37:58 <Pseudonym> Lunch.
17:38:03 <Shammah> dons: it's a internet meta-protocol.
17:38:06 <dons> so beep apparently isn't curs_beep(3)
17:38:24 <dons> 'cause i've got a library for that ;)
17:38:31 <Shammah> dons: unfortunately it's a bit more involved than that ;)
18:26:37 <dash> BEEP is a silly silly protocol
18:26:56 * shapr finds nearby unicyclists!
18:27:12 <shapr> two in GÃ¤llivare, one in haparanda, and one in UmeÃ¥.
18:27:13 <shapr> w00
18:30:09 <shapr> dash: Looks pretty likely I'll be in B'ham for july 4th.
18:30:28 <shapr> I might even bring my uni.
18:30:48 <dash> cool
18:58:22 <stepcut> I should subscribe to the haskell libraries list..
19:07:41 <cm> Yo
19:07:55 * shapr y0wns
19:08:04 <cm> shaprr
19:08:14 <shapr> guten tag cm
19:08:37 <cm> achtung! :P
19:08:47 <stepcut> cell phone standards are insane -- they can write a 100 page spec about a friggin' 5 line xml file 
19:08:56 * shapr agrees
19:09:28 <stepcut> the amount of documentation available is, like, 20 times what is necessary, which makes it really hard to find the useful stuff
19:12:09 <shapr> Yay, looks like all five of the unicyclists in the north of sweden are going to meet this summer in the one large city in these parts.
19:12:24 <stepcut> haha
19:12:49 <stepcut> it'll be madness! unicycles everywhere!
19:13:30 * stepcut shows his girl how to use halipeto
19:13:51 * shapr snickers
19:13:59 <stepcut> what?!
19:14:04 <shapr> yeah, five unicycle in the same city will be CRITICAL MASS!
19:14:19 <shapr> The unicycleverse will implode!
19:14:23 <stepcut> hehe
19:15:17 <stepcut> if a unicyclist and tricyclist collide, does it result in a massive explosion ?
19:16:46 <cm> no, in multiplication
19:17:51 <shapr> stepcut: I think you end up with two bicycles.
19:18:15 <shapr> ya know, atomic instability, wheel sharing and all that.
19:20:20 <juhp> stepcut: is the source available somewhere - www.acooke.org seems to be down...
19:21:10 <stepcut> juhp: source ?
19:21:47 <stepcut> oh, for halipeto...
19:21:56 <stepcut> i have it already
19:23:03 <stepcut> i even made a site: http://www.n-heptane.com/n-heptane
19:23:41 <shapr> I'm using halipeto for my website also.
19:47:08 <shapr> is there a basename command?
19:47:34 <shapr> If I want just the file part of a FilePath ?
19:52:42 <stepcut> shapr: not that I have seen, but you can do something like, reverse . takeWhile (/= '/') . reverse 
19:53:10 <shapr> I'll try that, thanks.
19:54:15 <stepcut> unless you have some wacky OS that allows for / in filenames 
19:54:38 <stepcut> in which case you would have to worry about escaping and stuff like that
19:54:41 <shapr> I'll need this to work on win32 sometime soon, but I'll just worry about that when the time comes.
19:56:14 <dons> shapr: basename p = reverse $ takeWhile (/= '/') $ reverse p
19:56:33 <dons> oh, that's the same as stepcut's :}
19:56:43 <stepcut> :p
19:56:45 <dons> the above is from hs-plugins
19:56:57 <dons> dirname p  =
19:56:57 <dons>     case reverse $ dropWhile (/= '/') $ reverse p of
19:56:57 <dons>         [] -> "."
19:56:57 <dons>         p' -> p'
19:58:03 <stepcut> how awesome is String = [Char]
19:58:07 <dons> hehe
19:58:09 <shapr> I love it.
19:58:09 <stepcut> I say, very awesome
19:58:20 * stepcut thumbs his nose at smerdy
19:58:23 <dons> it does make string processing easy.
19:58:47 <shapr> Lotsa people complain about the inefficiency of String = [Char], but I adore that feature.
19:58:53 <dons> and if you can get your data into  a [a], then things are easy too. [a] is great
19:58:56 <cm> it would be sufficient for it to "act as if it was [Char]" to have those advantages :-)
19:59:05 <shapr> Yes, I agree.
19:59:18 <dons> if you need it, CStringLen's are easy enough.
20:01:00 <stepcut> I should go to the store, or I will be forced to eat wasabi coconut noodles with 'mixed vegetables' (aka, celery and kale)
20:01:27 <shapr> I have horse lunchmeat.
20:01:55 <stepcut> mmm, horse lunchmeat
20:02:07 <stepcut> I had beef tongue sandwich the other day...
20:02:25 <shapr> It's very tasty. I was surprised. At first I thought of the soft cuddly horses. Then I realized they can be both cuddly and tasty.
20:02:37 <dons> hmm :/
20:02:45 <tuomov> I also like String = [Char] 
20:02:48 <shapr> dons: you're a vegetarian, right?
20:02:56 <tuomov> There should just be a more efficient internal implementation
20:03:06 <dons> shapr: yeah.
20:03:19 <stepcut> shapr: people for the eating of tastey animals ;)
20:03:25 <tuomov> e.g. lists could sometimes be compressed as ropes
20:03:41 <shapr> ShowS is probably better than ropes.
20:03:54 <shapr> It's pretty much the same idea at least.
20:04:13 <shapr> though ropes weren't designed to exploit non-strictness.
20:04:26 <stepcut> I think horse meat is illegal in the US...
20:04:35 <stepcut> (for human consumption)
20:04:37 <shapr> That's strange, I wonder why.
20:04:46 <stepcut> too cuddly?
20:04:52 <shapr> probably so.
20:05:16 <shapr> dons: why are you vegetarian? animals are too cuddly?
20:05:37 * stepcut takes it back..
20:05:38 <tuomov> you only need to implement static strings as contiguous blocks, and rebuild lists so when the user calls some special function
20:05:53 <stepcut> "USDA Promotes the Eating of Horse & Goat Meat"
20:05:59 <stepcut> http://www.igha.org/USDA.html
20:06:22 <dons> it's not sustainable to eat meat, and suffering is something we shouldn't inflict
20:06:28 <tuomov> s/rebuild/build a new copy/
20:06:49 <dons> I grew up on a cattle farm, though :}
20:06:50 <stepcut> can we eat vi users?
20:06:53 <shapr> Truly, meat eating is a far less efficient use of resources than plant eating.
20:07:17 <shapr> I'm not in favor of animal suffering either.
20:07:33 <tuomov> meat's easier to make decent food of than just veggies..
20:08:14 <tuomov> just put meat on the pan and lots of spices
20:08:14 <shapr> On the other hand, the horses I'm eating were usually racehorses. Boden is one of the big horsey towns in Sweden. Lots of betting, lots of horse farms, etc. Seems to me that when the life of a horse ends, you might as well eat it.
20:08:28 <dons> tuomov: that's just be cause you're not used to cooking meals out of grains, lentils, beans and friends
20:08:42 <Janni>  /quit gnight
20:08:46 <tuomov> you can't claim it would be less work
20:08:47 <shapr> g'night Janni 
20:08:52 * shapr dunno
20:08:57 <shapr> I know that I cannot cook at all.
20:09:00 <tuomov> of course, if there were semi-ready ingredients..
20:09:28 <dons> 'bout the same I think. certainly less messy, and safer, than bloody steak.
20:09:37 <shapr> In any case... back to my unit testing.
20:09:43 <stepcut> I saw a 'study' once that showed that per calorie, eating free range cows kills less animals than eating machine harvested grain...
20:09:43 <dons> unit testing, yeah!
20:10:05 <shapr> I'm doing Fermat's Last Margin with test-driven-development. I luvvvvv TDD.
20:10:37 <shapr> stepcut: yah, free range anything tends to be more sustainable than machine anything.
20:10:41 <shapr> greetings Diaconal, how's code?
20:10:47 <stepcut> shapr: indeed!
20:13:15 <shapr> I'm often pissed off at the whole gasoline culture. It's like an alcoholic pattern. You drink and you feel great, but you're stealing happiness from the next day, and you'll pay for it then. But it's happening now with gasoline, and our children will pay for it.
20:13:58 <shapr> How can you justify research into efficient use of gasoline when we already know gasoline isn't a sustainable resource?
20:14:54 <shapr> It's like eating your leg to keep from starving, at some point that strategy does not tend towards survival.
20:15:22 * shapr gets off soapbox, and onto a unit test...
20:16:13 <cm> maybe we will stop once it hurts? :-)
20:16:17 <tuomov> all methods of producing energy are pollution or dangerous in other ways
20:16:37 <shapr> Not all. geothermal, hydroelectric, solar power... 
20:16:42 <shapr> wind power
20:16:50 <tuomov> huge ugly farms of wind turbines or solar panels
20:17:17 <tuomov> and those will not work everywhere
20:18:28 <tuomov> nuclear power is the least polluting alternative, but also the potentially most dangerous
20:19:04 <nysin> tuomov: many of the most acute dangers have been attenuated with newer designs.
20:19:06 <shapr> nuclear reactor designs are usually sane. Leaving out blatantly stupid stuff like chernobyl, that is.
20:19:21 <tuomov> you still have to store the waste
20:19:23 <shapr> I still think breeder reactors should be used.
20:19:27 <stepcut> plus wind farms cause global warming ;p
20:19:50 <shapr> Breeder reactors have *significantly* less problems with nuclear waste.
20:20:15 <cm> stepcut: haha :D
20:20:32 <stepcut> cm: it's true (maybe)
20:21:01 <tuomov> I'd guess that huge wind farms can have a significant effect on global weather pattern
20:21:19 <cm> i read that as well.. it just struck me as funny :)
20:21:48 <cm> (especially reading it a few sentences after "chernobyl" ;)
20:21:59 <shapr> Right now, standard reactor designs use only uranium, and the dump the pellets when a certain amount of the uranium is used up. Breeder reactors can also burn all the resulting crap that comes from used up uranium.
20:22:59 <shapr> The only downside I can think of is that you end up with a lot of interesting stuff like plutonium in a breeder reactor, so maybe some nutcase could shutdown the reactor, take out the plutonium and try to make a bomb with it.
20:25:32 <tuomov> in the longer term, waste storage vaults may not be safe
20:25:41 <tuomov> that's the biggest problem I see
20:25:50 <shapr> There's a very interesting early design of nuclear reactor that requires the reaction to produce enough heat to melt the fuel. The melted metal flows around a circuit, and only in one spot does it enter a sphere of sufficient size to continue the reaction.
20:25:51 <Nioate> conservation of energy. wind generators suck energy out of the local weather, which probably has weird effects.
20:27:24 * shapr used to be a nuclear power geek
20:27:51 <tuomov> And nuclear power isn't really a replacement to gasoline; used batteries are hazardous waste too
20:28:38 <tuomov> s/hazardous/toxic/
20:29:30 <cm> shapr: where did your infos come from?
20:29:33 <cm> expose teh source! :)
20:29:42 <shapr> I hope low-temperature fuel cell research finds a good solution. That would be the best approach.
20:30:29 <shapr> I got most of my at Oak Ridge Associated Universities, next door to Oak Ridge National Labs in the USA. I was working towards a degree in Health Physics (radiation safety).
20:30:43 <cm> ah ok
20:30:44 <tuomov> In the meanwhile, and for other reasons as well, public transport is the remedy
20:31:12 <shapr> tuomov: solar/wind/hydro power could charge low-temp fuel cells. That would be great imho.
20:32:12 <shapr> I've read that existing prototype low-temp fuel cells can give 80 hours or so of notebook power.
20:32:26 <tuomov> how big are they?
20:32:31 <shapr> iirc, the downside is that the electrodes don't survive many charges
20:32:36 <shapr> they're laptop battery sized.
20:32:38 <tuomov> cool
20:32:59 <shapr> and I think they require some expensive metals at the moment.
20:33:05 <shapr> that's why they're prototypes :-/
20:33:08 <tuomov> of course, someone will think of ways to waste the energy once so much is available..
20:33:14 <shapr> hah, probably so.
20:34:12 <shapr> it would be amusing if the batteries in a laptop are worth more than the hardware itself.
20:35:19 <shapr> I vaguely recall that they were using yttrium, barium, and niobium in the prototypes.
20:35:50 * shapr wonders how much those elements cost by weight.
20:36:03 <tuomov> never heard of two of those :)
20:37:26 <shapr> I know they're used in superconductors, I don't know why they might be good for fuel-cells.
20:38:29 * shapr idly wonders if superconductors block radio waves.
20:43:17 <tuomov> maybe one day we'll have nuclear fusion
20:45:04 <shapr> would be nice.
20:58:09 <cm> nn
21:06:23 <jose21> Is there anyway to have a global variable in haskell?
21:09:52 <jose21> anyone?
21:09:58 <shapr> jose21: there are ways, but they're all considered 'non-functional' if you know what I mean.
21:10:16 <jose21> yes I do
21:10:38 <shapr> global variables go against the functional approch, and tend to weaken the strong points of functional programming.
21:10:46 <shapr> but if that's what you want...
21:10:55 <jose21> well, how else can you store things?
21:11:04 <shapr> lots of ways
21:11:20 <shapr> I've been writing Haskell programs for three years, and I haven't used a global variable yet.
21:11:47 <monochrom> I "store" things in parameters.
21:12:14 <jose21> so like, if I have a function that adds an item to a list, and I want to add two items, just recursively call it?
21:12:22 <shapr> yup
21:12:27 <tuomov> if you need the variable in many places, consider a state monad
21:12:51 <jose21> ok then, but out of curiosity, how would you do a global variable?
21:13:03 <shapr> The weirdest thing about test-driven-development is when your unit test should fail, but doesn't.
21:13:28 <shapr> you can do it with an IORef, with unsafePerformIO, and with various global variable code snippets.
21:13:39 <shapr> John Hughes wrote a paper about some global variable approaches.
21:13:50 <jose21> oh, so it's not a simple thing to do?
21:13:54 <shapr> Google should find that paper quite easily if you plug in John Hughes global haskell
21:14:26 <shapr> it's straightforward with an IORef, but it's still more trouble than doing it the functional way.
21:14:45 <jose21> keep in mind this is day 3 of Haskell for me :)
21:14:50 <shapr> Neat, my code works and I don't know why.
21:15:05 <shapr> jose21: in that case, you should probably stay far far away from variables at all.
21:15:28 <jose21> ok then
21:15:29 <shapr> One of the greatest strengths of Haskell is that its purely functional approach teaches a whole new way of thinking about programming.
21:15:40 <shapr> At least, compared to procedural programming it's very new.
21:15:55 <shapr> @wiki HaskellDemo
21:15:55 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
21:16:13 <monochrom> If humans were ideal computers, they would have no problem forgetting the whole idea of "storing things in variables".  Day 3 would pose no hinderance.
21:16:27 <shapr> jose21: http://www.haskell.org/learning.html
21:16:47 <shapr> and there's more good stuff on the wiki
21:16:47 <monochrom> It has less to do with newbie than to do with possessing a previous brainwashing.
21:16:50 <jose21> Shammah: well unfortunately, recursive stuff is often feared
21:17:03 <jose21> shapr rather
21:17:04 <shapr> I fear Java.
21:17:12 <monochrom> I fear loops.
21:17:20 <shapr> Especially after years of using Java.
21:17:30 <shapr> truly, loops are a waste of brainpower.
21:17:34 <monochrom> Every time there is a loop written, there needs a loop invariant for proving it correct.  It is nasty.
21:17:56 <jose21> proving it is correct... that's crazy
21:17:58 * shapr tries to figure out why his code works
21:18:02 <tuomov> recursion is much easier to see correct
21:18:07 <tuomov> no scare states
21:18:14 <monochrom> recursion is much easier to prove correct.
21:18:18 <jose21> in the words if shapr, "my code works and I don't know why" ;)
21:18:28 <shapr> jose21: length [] = 0 ; length (x:xs) = 1 + length xs
21:18:53 <shapr> well, doing subpages in flippi works, and I didn't expect that.
21:19:05 <shapr> I'm hacking on a wiki written in Haskell.
21:19:35 <jose21> ok, lastly, do you know any tutorials on doing IO?
21:19:37 <shapr> I just changed pages to be directories, and without me noticing, that means they also support subpages.
21:19:46 <monochrom> even the more efficient "length xs = f 0 xs where {f n [] = n; f n (x:xs) = f (n+1) xs}" is easy to prove correct.
21:19:57 <tuomov> int n=0; for(ptr=l; ptr!=NULL; ptr=ptr->next){ n++; }; return n;
21:20:01 <tuomov> that looks much scarier..
21:20:05 <shapr> truly.
21:20:45 <shapr> jose21: I'd suggest you learn the pure stuff first, and then learn monads. Then you understand IO for free.
21:21:04 <monochrom> The best way to reason about tuomov's code snippet... is to first translate it to my functional version!
21:21:08 <jose21> but how can you start a programming language without doing a hello world??
21:21:29 <shapr> write a text mandelbrot fractal grapher?
21:21:33 <tuomov> main = putstr "Hello World!"
21:21:34 <shapr> use interact?
21:21:37 <tuomov> s/str/Str/
21:21:44 <tuomov> that's much simpler than in C!
21:21:49 <monochrom> how can you start a programming language without doing binary tree operations?
21:22:20 <shapr> monochrom: neat, I hadn't thought of that from the perspect of a Haskell programmer learning C.
21:22:35 <shapr> very cute :-)
21:22:44 <tuomov> I think pattern matching is quite natural a way to do things.. if you haven't been imperatively brainwashed
21:22:58 <jose21> tuomov: do you need to load a module to use putStr?
21:23:08 <tuomov> no, it's in prelude
21:23:17 <jose21> tuomov: I've been doing imperative programming since I was 12, I'm pretty brainwashed
21:23:26 <shapr> jose21: the purely functional approach to programming is very different from procedural, but I promise, it's also very elegant and sexy!
21:23:47 <jose21> tuomov: I got "unexpected string literal" when trying that putStr
21:23:52 <tuomov> I've been programming imperatively since somewhere around that age too and only wrote my first real haskell program this autumn
21:23:57 <shapr> I've been doing imperative programming since I was 11. I had to squish my brain pretty hard to learn Haskell.
21:24:07 <shapr> But man is it great!
21:24:12 <monochrom> I summarize my experience as: imperative programming is best done by thinking of it as syntactic sugar for functional programming (e.g., implicitly passing "state" around).
21:24:43 <shapr> I wrote a mailing list web search application in three evenings of spare time hacking.
21:25:11 <shapr> This wiki written in Haskell is significantly simpler than the original wiki written in Perl.
21:25:18 <tuomov> I didn't have such a hard time... but then again, I've studied maths and fp is quite mathy a way to write programs
21:25:40 <monochrom> Another point.  Imperative programming book: chapter 1 "hello world", chapter 10 "binary search trees".  Functional programming book: chapter 1 "binary search trees", chapter 10 "interpreter project".  Which one is not a waste of time?  You be the judge.
21:25:48 <shapr> jose21: where you did type that?
21:25:55 <shapr> jose21: into a haskell source file or what?
21:25:58 <jose21> shapr: in a .hs
21:26:01 <stepcut> monochrom: haha
21:26:36 <shapr> jose21: main = putStrLn "hello world"
21:26:59 <jose21> ok
21:27:07 <shapr> Having subpages unexpectedly work really put me off my stride.
21:27:30 <shapr> oh well, only darcs integration left to do now.
21:29:23 <tuomov> another thing to say about fp is that while writing riot (my first proper haskell program), I made very few errors that were not caught at compile time... not so with C
21:29:52 <tuomov> it's very easy to forget something
21:30:20 <tuomov> even if you've basically reasoned correctly
21:30:49 <nysin> This 'it's only imperative brainwashing' sort of thing - I'm not agreeing or disagreeing with it (it seems plausible-to-likely), but is there empirical evidence?
21:31:17 <nysin> Students learning Haskell as a first language or something.
21:31:25 <stepcut> shapr: i think halipeto needs a graph viz generator for visualizing the database, what do you think ?
21:31:32 <tuomov> I don't know if there's evidence wrt. programming per se, but people just get set in their ways
21:31:32 <shapr> stepcut: ooooh nifty
21:31:35 <tuomov> in general
21:31:37 <nysin> And their performance compared to those learning some imperative language
21:32:31 <shapr> I've seen some discussion about it, but I'm not sure if there's any detailed statistics.
21:32:33 <tuomov> it's hard to think outside the box you've made for yourself
21:32:53 <shapr> The discussion I saw was talking about chalmers.se, where they teach Haskell first, and Java second.
21:33:12 <shapr> I think this was mentioned on lambda-the-ultimate.org
21:33:16 * shapr looks for the url
21:33:33 <stepcut> the first language my girlfriend learned was lisp for a music class :)
21:33:34 <monochrom> Why do you ask as though the brainwashing question is hooked up with the performance question?  They are independent.
21:33:38 <nysin> Okay, I don't recall it coming up there, but I don't always read it. It'd be interesting to see the resulting Java code.
21:33:42 <tuomov> I got turned off from cs to maths for the c++ hegemony..
21:34:13 <shapr> nysin: oh, you're on LtU? Who are you?
21:34:20 <nysin> monochrom: well... I don't know.. not performance maybe? Some vaguely quantitative measure
21:34:26 <shapr> nysin: hi, I'm shapr on LtU also. I'm Shae Erisson legally.
21:34:40 <nysin> shapr: ah, reader only, no account.
21:34:45 <monochrom> There is no empirical data comparing performance of native FP programmers with performance of native IP programmers.
21:34:54 <shapr> Josef Svenningsson mentioned it in the comparitive language discussion.
21:35:21 <shapr> nysin: http://lambda-the-ultimate.org/node/view/362
21:35:21 <jose21> if you have a tuple, how do you get one of the individual values from it?
21:35:28 <stepcut> i think the university of illinois teaches scheme in their first level comp sci classes
21:35:34 <shapr> Josef's is the first comment there.
21:35:59 <shapr> jose21: you can use tuple unpacking, \ (x,_,_) -> x
21:36:02 <tuomov> they used to teach scheme as the first language where I studied a few years before I started
21:36:11 <monochrom> If a student receives an "education" to the effect of becoming disabled from opening their minds to alternatives, that's brainwashing by definition.  This is not an empirical issue.
21:36:25 <tuomov> but now it's all c++ for the first programming courses, and only in a few later courses there's prolog or modula
21:36:25 <jose21> shapr: I guess that means I'll need to do some reading...
21:36:32 <tuomov> or used to be when I still was as tudent
21:36:49 <shapr> jose21: read that HaskellDemo, it'll help.
21:36:59 <tuomov> (prolog obviously in ai course)
21:37:20 <nysin> monochrom: I'd prefer not to believe in that effect if it's not measurable in some way.
21:37:32 <shapr> I wonder if I should just shell out to a darcs command. Probably so.
21:38:00 <nysin> I'm not denying some experience it.
21:38:01 <shapr> nysin: well, Josef teaches at chalmers, and you see what he has to say.
21:38:08 <nysin> But as a broader effect..
21:38:15 <monochrom> You can easily test it by trying to teach an alternative.  This experiment happens daily.  Everyday hundreds of native IP students go into an FP class and come out whining.
21:38:17 <nysin> shapr: yeah, reading that thread
21:38:38 <shapr> In my opinion, functional programming is simpler than procedural programming.
21:38:51 <tuomov> not teaching of alternatives to people who are not that interested in what they study has the effect of blocking their minds from alternatives
21:38:57 <shapr> Though I think FP implementations are more complicated.
21:39:49 <shapr> Maybe it's just that FP is simpler for me and the way I think. Even if that's all there is to it, I'm sure happy I learned Haskell.
21:39:57 <shapr> I can code better now!
21:40:10 <tuomov> so all these management type people take a few basic courses in cs and all the ever hear of is c++
21:40:23 <tuomov> and thus workers suffer from it
21:40:23 <nysin> shapr: There are some pretty simply imperative turing tarpits.
21:40:29 <nysin> s/simply/simple/
21:41:40 <nysin> But, yeah, that seems like a restatement of the 'FP is more abstract' idea.
21:42:08 <shapr> I mean that (in my opinion) a given Haskell program is less complex than the equivalent Java program.
21:42:35 <tuomov> certainly true in case of hello world :)
21:42:54 <shapr> Would be interesting to compare flippi with a java wiki.
21:43:14 <jose21> hmm this is a strange language
21:43:24 <nysin> shapr: Java's almost an unfair example...
21:43:33 <nysin> Even among imperative languages.
21:43:49 <shapr> Well, students are usually taught Java nowadays...
21:44:07 <tuomov> another thing to say for fp is that I think it requires to think more of a good solution than ip where you can just throw in some shit
21:44:11 <Shammah> (unfortunately.  Although a local uni has just added SICP to their undergrad course :)
21:44:54 <jose21> does haskell have a "do nothing" operation?
21:45:00 <shapr> nysin: I think that map versus writing a loop pretty much wins the contest.
21:45:00 <stepcut> id ?
21:45:15 <jose21> like if I'm going through a list using (x:xs) recursively, how do I tell it when to stop?
21:45:32 <shapr> you give two cases, a stop case and a next step case
21:45:39 <shapr> length [] = 0
21:45:47 <shapr> length (x:xs) = 1 + length xs
21:45:54 <monochrom> See my example and shapr's example.
21:45:57 <shapr> the two cases get tried in order.
21:46:00 <jose21> ok, the 0 is what I wasn't sure of
21:46:08 <nysin> shapr: while Java's solution to that's incredibly verbose, many of Perl/Python/Ruby/Lua/etc languages do better at it.
21:46:21 <nysin> I still like map, but again, Java?
21:47:00 <shapr> Python was my first love, but Haskell is just more elegant and more powerful.
21:47:06 <Shammah> nysin: I don't think java's an unfair example at all.  It's a modern IP, with a fair number of the latest advances in ip-abstraction available, as well as a huge stdlib and supporting frameworks.
21:47:23 <tuomov> Is there any safe and convenient to use _statically typed_ imperative language?
21:47:56 <tuomov> oh, well, "safe"
21:48:00 <tuomov> global state is unsafe
21:48:00 <stepcut> tuomov: ocaml?
21:48:06 <tuomov> :)
21:48:14 <shapr> nysin: I do think that Haskell will still compare favorably to Python in terms of program complexity.
21:48:22 <nysin> shapr: Amusingly, Python seems to be adopting a bunch of Haskell-patterns lately... itertools outright copies the takeWhile/takeUntil names, for example, and they have list comprehensions...
21:48:29 <stepcut> ocaml can be written very imperative style, while, for, etc 
21:48:50 <shapr> nysin: and yet, Guido thinks that map, reduce, and lambda should be removed from the language.
21:49:09 <Shammah> nysin: perl/python/ruby/lua tend to be less verbose precisely because their solutions include strong fp influences .
21:49:18 <nysin> shapr: okay. I've used Python and O'Caml, but not Haskell much (witness my earlier question about toplevels)
21:49:32 <nysin> shapr: yes, that's rather unfortunate.
21:49:35 <tuomov> ruby isn't that strong on the fp influences
21:49:43 <tuomov> they don't have higher-order/first-class functions
21:49:50 <tuomov> only an iterator kludge
21:49:55 <monochrom> Guido is a freak.  Bogged down too much by his armchair philosophy.  "Statements and expressions should be distinguished." (Read: expressions should be second class.)  What the bloody hell.
21:50:22 <nysin> tuomov: wait, what?
21:50:23 <shapr> nysin: higher order functions and partial application are way sexy.
21:50:34 <nysin> They don't have first-class functions?
21:50:48 <tuomov> f { |x| .... } is a special-case kludge, not a lambda
21:50:53 <nysin> Oh, Ruby
21:50:55 <nysin> never used it
21:51:18 <tuomov> it's more like lua's coroutines...
21:51:32 <monochrom> If not for pressure from the community for years, today Python would still not permit the C equivalent of x==0? "yes" : "no".  What a moron.
21:52:13 <shapr> I do think Python should be simpler than it is now. Its great advantage was that you could learn it in a day and immediately be productive.
21:52:13 <nysin> shapr: and the latter's not found all that commonly.
21:52:37 <shapr> nysin: partial application isn't common in languages other than Haskell you mean?
21:52:45 <tuomov> Lua's simple.. unfortunately the aren't as many libraries as for python
21:52:48 <nysin> monochrom: er? It still doesn't. One has to resort to ugly tricks such as [False,True][Bool(blah)] or whatnot
21:52:57 <Shammah> tuomov: I thought ruby had some sort of block syntax ala smalltalk?
21:53:12 <monochrom> Then Guido is still a braindead moron.
21:53:14 <tuomov> I don't know any smalltalk..
21:53:15 * Shammah hasn't used ruby either, so is operating strictly on hersay
21:53:20 <shapr> I've been using Python since 1.5 was in beta, but nowadays I have to look up the new syntax stuff when I run across it.
21:53:52 <nysin> shapr: right. First-class functions and such have spread pretty widely, but not partial application, which gives Haskell a nice advantage...
21:53:54 * shapr is operating strictly on heresy
21:53:58 * shapr grins
21:54:16 <Shammah> lol.
21:55:06 <nysin> tuomov: I regard Lua and Python as almost the same language modulo indentation, sugar & libraries...
21:55:11 <shapr> nysin: and that not all! for the low price of 29.95, you get an amazing type-system, a mind-boggling community, an exciting future, and so much more!
21:55:30 <tuomov> nysin: have you looked at the size of those? 
21:55:37 <tuomov> lua is a really compact language
21:55:48 <tuomov> the python interpreter/library is _huge_
21:55:53 <nysin> Yes, I use both, and have embedded Lua into software of mine.
21:56:11 <shapr> nysin: oh, what software have you written? I want to see!
21:56:21 <tuomov> I have also embedded Lua (Ion)
21:56:34 <nysin> A modification of someone else's filesharing client...
21:56:57 <shapr> oy, it's 7am.
21:57:08 <shapr> time for sleep
21:57:12 * shapr disappears
21:57:12 <tuomov> 8
21:57:21 <shapr> tuomov: crazy man :-P
21:57:22 <monochrom> To be fair, distinguising commands and expressions isn't wrong, and even making one of them second class isn't wrong (e.g., the former has a lower status in Haskell).  But saying that if-then-else is an imperative/command thing and therefore should not apply to expressions --- that's downright idiotic.  What is so imperative or stateful about if-then-else?  The premise is flawed.
21:57:25 * shapr &
21:57:27 <tuomov> but I intent to stay awake to normalise my sleeping pattern a little
21:57:43 <nysin> tuomov: how big's Python, sans libraries?
21:57:44 <tuomov> woke up at 16:00 again
21:58:20 <tuomov> the python binary on my system is 900k
21:58:30 <nysin> monochrom: that's not Guido's issue I think
21:58:44 <tuomov> it isn't dynamically linked to any python-related libs
21:58:54 <nysin> I've never seen him state a concern that Python's just too imperative or stateful
21:58:58 <tuomov> but I'd suspect it will load some modules dynamically for extra features
21:59:28 <tuomov> the lua libraries are less than 200k
21:59:35 <nysin> tuomov: ~100kB
21:59:45 <nysin> At least last I measured
22:00:10 <nysin> tuomov: okay; Python's rather larger than I expected.
22:00:23 <tuomov> and it doesn't even have proper GC :)
22:01:01 <nysin> Don't tell me it falls prey to the standard circular refcount thing. I'm hoping for a slightly more creative form of brokenness here
22:01:20 <tuomov> it uses refcounting and requires you to implement specific kludges for potentially cyclic data structures
22:01:28 <Shammah> nysin: python is an ip-oo hybrid.  It isn't too imperative or stateful wrt. some theoretical 'ideal' latently-typed, ip-oo hybrid.
22:01:56 <Shammah> tuomov: that hasn't been the case since ~2.1 iirc.
22:02:05 <tuomov> hmm..
22:02:07 <Shammah> python has had a real gc for sometime now.
22:02:21 <tuomov> my info is outdated then
22:02:21 <monochrom> How real?
22:02:48 <Shammah> monochrom: stock-standard mark-n-sweep iirc.
22:02:58 <nysin> It does have refcounts, though
22:02:59 <monochrom> What I heard a few days ago here, if my memory hasn't faded, is that Python GCs by refcounting + cycle detection.
22:03:12 <nysin> That I know for sure, as of the latest 2.4 RC
22:03:24 <Shammah> nysin: yeah, it still does refcounting to provide lifecycle guarentees.
22:03:38 <monochrom> Well I suppose mark-n-sweep is good enough.
22:03:54 <Shammah> (ie. if you create a resource and leave scope memory will be reclaimed while leaving scope).
22:04:11 <Shammah> monochrom, it is only a scripting language after all :)
22:04:24 <tuomov> lua 5.1 has incremental gc iirc
22:04:37 <tuomov> as it is used quite a lot in apps where that matters
22:04:45 <Shammah> monochrom, I don't however know if it's incremental or stop-the-world gc.
22:04:47 <nysin> Shammah: well, my response was more regarding Guido's presumed motivation for not including an if-else expression
22:05:21 <nysin> That Python's being stateful or not strikes me as irrelevant to that
22:05:36 <monochrom> I don't know what "only a scripting language" is a good excuse for, apart from performance penalties.
22:05:51 <Shammah> monochrom, performance and latency.
22:05:58 <tuomov> for not having a type system :)
22:06:08 <dons> yep.
22:06:10 <nysin> Aside from scope silliness, some of which 2.2 resolved, it's a pretty good language.
22:06:42 <tuomov> although, type inference pretty much pulls the floor from under that argument
22:06:55 <monochrom> In fact, "only a scripting language" is a good excuse for a correct but slow algorithm --- that I understand and sympathize with.  But for a fast and broken algorithm? That sounds counterintuitive.
22:07:07 <dons> tuomov: I agree
22:08:37 <nysin> Python certainly has a type system... Not one similar to Haskell, but...
22:10:04 <mflux> but it's checked runtime?
22:10:22 <nysin> Sure, it's dynamic typing...
22:10:23 <monochrom> Anyway, newbies to functional programming, in particular recursion, should take a look at my toy slides http://www.cs.utoronto.ca/~trebla/fp/lecture-02.pdf  in particular pages 6, 15, 16.
22:10:29 <nysin> Runtime/etc.
22:10:49 <monochrom> Recursion is very natural if you just divide-n-conquer.
22:12:19 <Shammah> monochrom, agreed.
22:17:19 <nysin> So I asked earlier about defining functions in a Haskell RPL, and had missed that GHCi could do it. What about type constructors?
22:17:45 <nysin> er, REPL
22:18:08 <nysin> I've searched some in vain.
22:19:51 <monochrom> Another shameless plug: http://www.google.ca/groups?selm=4uhe5s9xee.fsf%40vex.net&output=gplain
22:20:26 <monochrom> No, can't define type constructors in the repl of ghci.
22:21:31 <nysin> monochrom: I've never understood the aversion of some to recursion, but there's an argument to be made that unless the language guarantees tail calls explicit loops represent a reasonable optimization.
22:23:19 <monochrom> My article proposes a hypothesis for explaining that aversion.
22:24:48 <nysin> I skimmed it, and apparently missed a mention of tail calls there too. Whoops. Anyway, that people are taught an execution model rather than an art of solving problems?
22:25:08 <monochrom> YES!  We are living in a Dark Age.
22:25:15 <tuomov> I think some old programming books or tutorials found on bbs:s talking about the evils of recursion
22:25:28 <tuomov> s/think/remember/
22:25:52 <tuomov> infinite recursion, running out of stack, etc.
22:27:28 <nysin> In the right contexts, the stack argument's even real.
22:27:30 <tuomov> loops do avoid the latter, but so does a good compiler
22:27:54 <nysin> Look at the Linux people's fight to get 4kB kernel stacks working...
22:28:01 <musasabi> morning
22:28:02 <nysin> Granted they're using C.
22:28:13 <monochrom> SICP focuses on what you do to solve problems (it also describes an execution model, but that does not receive the spotlight) and so students come out not hating recursion, and in fact having a more holistic view of programming.  Or maybe it's just because they're MIT students. :D
22:28:38 <esap> Recursion is not evil. You just need to understand what it's good for. [and put hard resource limits for every use of recursion :-) ]
22:29:32 <musasabi> recursion is no more evil than iteration
22:29:35 <esap> monochrom: The structure (and interpretation) of SICP is IMO very good.
22:30:02 <Shammah> monochrom, url for the article?
22:30:04 <esap> monochrom: I think the students hate SICP because it uses scheme.
22:30:12 <nysin> Somehow I don't think there's going to be a great deal of disagreement here about the virtues of recursion...
22:30:50 <monochrom> My article?  http://www.google.ca/groups?selm=4uhe5s9xee.fsf%40vex.net&output=gplain
22:31:26 <esap> monochrom: oh sorry, you said *not hating* recursion, I read that as 'hating' recursion, which I think is true where I come from :-)
22:31:28 <Shammah> don't forget that alot of students get introduced to recursion as an 'advanced' concept, and iteration as a 'basic' concept.
22:31:40 <Shammah> monochrom, that link is currently a 502.
22:31:44 <nysin> Worked for me.
22:32:17 * esap shouldn't do anything after just having woken up.
22:33:14 <monochrom> On efficiency (e.g., of recursion vs. loop) I have the following two points to make.
22:34:19 <monochrom> In this universe, by the trick of historical accident, stock hardware are imperative with cheap goto's, so recursion and FP look slow unless you aggressively optimize.
22:35:20 <Shammah> which group was it posted to?
22:35:38 <nysin> Even LISP machines' instruction sets have frequently looked fairly iterative in nature... last I remember reading about was the CADR one...
22:35:54 <nysin> From the early '80s I think
22:36:08 <nysin> s/iterative/imperative/, bah
22:36:34 <esap> monochrom: Actually, I think FP provides better control over time usage [but about space usage, things are different...]
22:36:59 <nysin> Relying on recursion does introduce issues such as fold-left vs fold-right...
22:37:07 <nysin> One being tail-callable and one not...
22:37:29 <nysin> And in certain places that difference being critical.
22:39:28 <monochrom> In a parallel universe, Alonzo Church's paper was an overnight worldwide success, and von Neumann was never born.  Stock hardware is what we know in this universe as graph rewriters, geared towards pure FPLs.  When finally someone invented Fortran, it was ridiculously slow because every assignment "x := x + 1" was translated to a function that copies the other 999 global variables unchanged.  Later it became acceptably fast, only after someon
22:39:28 <monochrom> e invented data-flow analysis to figure out "w00t, these other 999 variables are unchanged, no need to copy them!"
22:41:04 <musasabi> Why do ghc internals use the `thenM` notation?
22:41:26 <musasabi> and should it or do be used for new code?
22:41:55 <monochrom> So in other words, in the parallel universe, we say to each other "while-loops are inefficient unless you do dataflow optimizations, but of course all respectable compilers do it --- though imperfectly."
22:42:30 <nysin> monochrom: yes, in that parallel universe...
22:43:00 <nysin> Though, there has been graph-reduction hardware in this one too.
22:43:12 <stepcut> mmm, graph reduction hardware..
22:43:22 <nysin> Just not funded for hundreds of millions of dollars a year by Intel.
22:43:22 <monochrom> graph-reduction hardware in this world is uncommon and unpopular and uncheap.
22:43:28 <stepcut> wasn't there some that worked with clean ? Or am I imagining that ?
22:44:15 <stepcut> monochrom: that just makes it a huge untapped market ;p
22:45:37 <esap> stepcut: the market is not there, because most people do not realize they need it.
22:46:04 <nysin> Most people don't need it. Turing-equivalence and all.
22:46:12 <monochrom> I just want to point out that certain conventional wisdoms are accidents rather than absolute truths, e.g., "unoptimized recursion is slower than unoptimized loops" is just the status quo.  You know, trying to refuse to be brainwashed.  I acknowledge that cheap imperative hardware is here to stay, and we should make the best out of it rather than dream or whine.
22:46:29 <esap> nysin: it's needed to make certain optimizations easy.
22:47:09 <monochrom> Also large companies know how to FUD when it sees a competitor emerging.
22:47:19 <stepcut> maybe when hOp is further along, we start the hOp machine
22:47:27 <nysin> monochrom: I'm not claiming slow vs fast. I'm claiming correct vs incorrect. If I have a loop that executes millions of times and I convert that to a recursive function, I'm going to blow the stack...
22:47:31 <monochrom> It is tough to be even slightly different, e.g., AMD suffered for many years.
22:47:32 <stepcut> and have some crazy keyboard with 18 meta keys
22:47:39 <nysin> If it's not tail-recursive of course.
22:48:19 <esap> nysin: that's exactly the space vs. time usage issue. If you want to optimize time, then you have enough space.
22:48:32 <stepcut> monochrom: true, but look at the outstanding success of linux on the desktop!
22:48:35 <stepcut> :-/
22:48:58 <nysin> I've seen claims they're overtaking Mac OS by some measure... Don't know how credible.
22:49:41 <monochrom> I view the stack overflow problem (btw a graph rewriter suffers from this problem too, to be fair) as an issue of dumb algorithm vs. smart algorithm.  You can blow the stack for silly reasons in IP, too.
22:49:44 <stepcut> the last company I worked for made a stack based microprocessor... but they never sold any
22:50:26 <monochrom> Or even better, you can in IP implement your own stack as an array you allocate, then blow it for stupid reasons.
22:51:44 <monochrom> In fact, in real-world C programming, if you forget to free(), or even better, if the program is complicated enough that there is no good point of free()ing so you just can't free(), ... tee hee hee you have the same problem!
22:52:07 <nysin> monochrom: sure. And one can implement constant-space recursion, and all. It's just less subtle in IP why it happens for those unfamiliar with a language, I'd claim (see the foldl vs foldr thing I mentioned). Or, maybe that's just my IP brainwashing.
22:52:32 <esap> monochrom: I think if there is no point where you can call free(), then the program is broken.
22:52:33 <nysin> monochrom: GC and IP vs FP are orthogonal, no?
22:53:07 <nysin> Or, I guess not entirely, in that few FPs I've seen lack GC.
22:53:15 <esap> nysin: I don't think GC is orthogonal to IP vs. FP. Consider schedulers.
22:54:07 <nysin> Elaborate?
22:54:15 <esap> nysin: GC is a way to simulate infinite space. Scheduler is a way to simulate infinite time :-)
22:55:00 <monochrom> I think in real OOP actually, if you use those design patterns heavily enough, there is no safe point of free()ing except at the main program exit point.  Think of the Observer pattern: when you de-register an observer, can you free() it right away?  Design patterns pretty much requires automatic GC.
22:55:41 <nysin> Depends whether one considers ad hoc refcounts GC...
22:55:50 <nysin> Since I've seen them used for that.
22:56:23 <monochrom> Well yes for the observer pattern you can implement your own refcounting.  That will be more error-prone than having a general GCer.
22:57:16 <esap> monochrom: Obviously, the registered pointers in observer need to be reference counted. You free if you have the last copy.
22:57:27 <esap> monochrom: s/copy/reference/
22:57:52 <musasabi> local type declarations don't seem easier in the morning :-(
22:57:54 <dash> "real OOP"? hah
22:58:03 * musasabi tries to force TH to do his bidding.
22:58:11 <nysin> There are also the numerous 'smart pointers' of C++, which don't really count as general GC, but aren't as error-prone as manual stuff.
22:58:30 * esap thinks OOP equals building platforms (even where it's not a good idea).
22:59:08 <monochrom> You are right about GC being orthogonal to F/I.  But stock hardware in our world doesn't come with GC; it is a non-trivial add-on.  Graph rewriters come implicitly with GC; it is so implicit you don't even think of it.
22:59:19 <dottedmag> esap: what do you mean by 'building platforms'?
22:59:23 <dash> monochrom: in an alternate universe, _Hewitt's_ paper was an overnight success and everyone started building multi-CPU and NUMA machines for desktop use
23:00:03 <dash> and people discovered later that you could simulate multiple tasks on the same CPU by means of an event loop
23:00:10 <esap> dottedmag: I mean, with OO design, what you normally get is an API for a collection of objects, which is somehow "easy-to-use".
23:00:46 <esap> dottedmag: the API is obviously an interface to a platform.
23:00:55 <nysin> How did people in this alternate universe deal with #tasks > #CPUs without reinventing the same techniques used for largely serial systems?
23:01:06 <dash> nysin: buy more cpus! ;D
23:01:10 * esap has to run. see you later.
23:01:15 <dash> esap: hmm. i am curious how you'd define 'platform'
23:01:23 <dash> sure sure, drive-by punditry ;D
23:01:49 <dash> nysin: anyhow it's less of a good analogy
23:01:51 <tuomov> I've found deferring destroying of objects to the mainloop work quite well in C
23:01:51 <esap> dash: Platform is the common part of code that makes building applications easier.
23:01:57 <dash> esap: ah
23:02:16 <dash> esap: well, my experience is that you're right -- but I suspect it would be the same in any language
23:02:20 <monochrom> My overall point is that FP problems have IP counterparts.  If you point out it takes work to make FP space-efficient, I can point out that it takes work to make IP space-efficient too.
23:02:22 <nysin> dash: sure, that's why I only responded to its most superficial aspects; it just doesn't work more deeply. :p
23:02:24 <tuomov> no gc or refcounting, but don't destroy the object while some code might locally refer to it
23:02:38 <dottedmag> esap: questionable
23:02:47 <dash> nysin: i'm just waiting for a reasonable language with advanced concurrency support
23:02:51 <dash> nysin: (other than erlang i mean)
23:03:19 <nysin> monochrom: similarly to my response regarding recursion, I'm not sure you're going to find much disagreement in #haskell...
23:03:22 <dash> i have spent the last 5 years working on framework code in python :)
23:03:52 <Shammah> dash: but what is wrong with erlang? :)
23:04:22 <dash> Shammah: well, mostly that it isn't python =/
23:04:31 <nysin> That the prople behind it made a cheesy promotional video comically bad.
23:04:36 <dash> Shammah: that's the only real defect
23:04:38 <nysin> s/prople/people/
23:04:41 <monochrom> nysin: You have seen that I have faced a quite bit more opposition and I have to do quite a bit more arguing.
23:05:03 <nysin> (LtU linked it at one point)
23:06:33 <nysin> dash: okay, I haven't done much with concurrency, and am relatively ignorant about it. I 'know' from hearsay that e.g. Ada was better... And there've been others too.
23:08:32 <dash> mmh. ada still emphasizes sharing too much
23:09:02 <dash> something like erlang's copy-everything approach is more reasonable, i think
23:09:11 <Shammah> dash: any python programmer smart enough to recognise its weaknesses I point at erlang.
23:09:36 <dash> Shammah: yeah, but erlang doesn't have near as much infrastructure
23:09:41 <Shammah> I've pointed a few so-far and they tend to like it the transition.
23:09:43 <dash> so it's not really a feasible alternative
23:10:19 <Shammah> dash: That depends.  There's alot of infrastructure in otp that python can only dream of.
23:10:34 <dash> such as?
23:11:02 <nysin> There's also OCCAM, which I've seen a couple of people espouse the virtues of, but not in much specificity.
23:11:08 <nysin> I know little about it.
23:11:24 <dash> yeah, occam was the transputer thing
23:11:59 <nysin> Did support for it die with transputer?
23:12:21 <monochrom> Message passing is sexy.  No sharing.  (Sharing is hard to recent about.)  Nice process algebras.  (Of course, in this world, message queues are implemented using mutex and sharing.  Here we go again.  In a Far, Far Away Neverneverland, it's the other way round... :))
23:12:30 <monochrom> s/recent/reason/
23:12:36 <dash> meh
23:12:58 <dash> in general, caring about how the bottom layers are implemented isn't necessary
23:13:06 <dash> once it's done, anyway
23:13:35 <dash> shammah: so what OTP stuff are pythonistas missing
23:13:36 <Shammah> dash: the failover, supervisor support.  mnesia and mnemosyne.  message passing/strong-concurrency.  
23:15:51 <dash> mmm 
23:16:23 <dash> well, we've got about half of mnesia (we haven't needed distributedness yet)
23:16:34 <dash> the concurrency model is of course the biggest advantage
23:16:46 <dash> don't know much about failover
23:17:00 <dash> anyway, all good stuff but they can't offset python's advantages unfortunately
23:18:05 <Shammah> Personally, erlang feels very similar to python, only cleaner.
23:18:08 <nysin> dash: that's going to be hard without one of (1) large corporate backing with marketing money driving a desire to maintain it, or (2) widespread popularity on the order of magnitude of python
23:18:37 <dash> nysin: no kidding
23:18:46 <dash> anyway erlang is a dead end, in some senses
23:19:03 <Shammah> dash: curious why you think that.
23:19:03 <dash> the future is in the multi-language VMs like mono and parrot
23:19:29 <dash> parrot in particular bodes well for concurrency
23:19:35 <dash> what with first-class interpreters and all
23:19:44 <dash> and continuations
23:19:46 <nysin> One problem with the .Net runtime is the 'everything's C# with a different syntax', no?
23:20:03 <dash> i don't find mono particularly interesting, no
23:20:11 <nysin> That while one can run one's language of choice, it has to dumb its typesystem down for example
23:20:16 <Shammah> dash: I don't agree, but I don't have time now to debate the point.
23:20:16 <dash> though ironpython may surprise me 
23:20:35 <nysin> To satisfy the CLS
23:21:01 <nysin> Or that all the built-in libraries are basically object-oriented, so one's language must be too to effectively utilize them
23:21:06 <nysin> Etc.
23:21:21 <tuomov> I think language interoperation should be done by writing a very simple low-level C interface, and then wrappers in the style of target language for each language
23:21:33 <dash> Shammah: well. certainly erlang has a place, but it's going to be much more feasible to get better concurrency into our systems via a new VM with better features, than rewriting 5 years' worth of code in a different language :)
23:21:38 <tuomov> one api does not fit all
23:21:43 <dash> tuomov: what does that mean?
23:22:12 <tuomov> no stupid oo-c shit and stuff; something much simpler and lower-level in style
23:22:22 <nysin> LLVM or C--?
23:22:33 <Shammah> dash: personally I don't think the next 'language of the future' has been written yet.
23:22:35 <dash> tuomov: i don't understand what "wrappers in the style of target languages" means?
23:22:44 <tuomov> functional, oo, etc.
23:22:44 <dash> shammah: Certainly it hasn't ;)
23:22:56 <dash> shammah: i plan to write at least one of them though ;D
23:22:59 <tuomov> no point in making the core library in a particular "high-level" style
23:23:11 <nysin> Both FORTRAN and LISP will be around for another 45 years just fine :p
23:23:16 <tuomov> just keep it simple so it will be easy to wrap
23:23:26 <Shammah> dash: I most definately look forward to seeing what you come up with (and stealing as much as I can for my own ;) ;)
23:23:29 <dash> tuomov: that sounds like too much work for not enough benefit
23:23:32 <dash> shammah: Likewise.
23:23:58 <tuomov> more work in designing a good library, but much better apis
23:24:06 <tuomov> current popular apis are awful
23:24:07 <Shammah> dash: personally I expect something that looks alot like a cross between lisp/scheme and ml.
23:24:13 <tuomov> g*, java, .net, *yuck*
23:24:14 <dash> the other exciting thing about parrot is the possibility of restricted execution
23:24:24 <dash> tuomov: well obviously those are bad
23:25:08 <dash> they're better than C or C++ though
23:25:24 <dash> and the people .net is going to suck in are the people who still write apps in those languages
23:25:30 <tuomov> g* (gtk etc.) is awful oo-c shit
23:25:31 <dash> so i think it's a win, overall
23:25:42 <dash> tuomov: awful? compared to what?
23:25:46 <nysin> I prefer C++ to Java, at least Java pre-1.5.
23:25:54 <nysin> Yes, it's overly complex.
23:25:56 <tuomov> compared to almost any proper language or a true c api
23:25:59 <dash> nysin: i'm just going to stare at you and laugh
23:26:07 <tuomov> opengl is cool
23:26:10 <dash> tuomov: why are you writing apps in C? :)
23:26:10 <tuomov> lua/c api is cool
23:26:33 <nysin> You do that while I still point and laugh at Java's claiming a static type system.
23:26:48 <tuomov> I just think certain core libraries should be written in simple C, so that it is easy to share the code from each language with wrappers designed for that language
23:26:59 <tuomov> and not be some stupid generic framework with bad api for each language
23:27:30 <nysin> C++ templates may be complex and turing-complete, but at least it acknowledges the problem.
23:27:43 <dash> tuomov: nah, generic frameworks are great
23:27:50 <nysin> They're even FP :p
23:27:51 <dash> tuomov: unless you have more than one
23:28:15 <tuomov> lowest common denominator shit.
23:29:09 <dash> that's why i'm enthusiastic about parrot, it's a generic framework more people can agree on ;)
23:29:29 <nysin> I'm waiting to relish the day the first production language for it comes out, and it's not Perl.
23:29:53 <dash> nysin: forth is already there!
23:29:53 <dash> ;)
23:30:06 <tuomov> yet another vm is not a solution, it is the problem
23:30:22 <dash> tuomov: oh? so what is the solution
23:30:46 <tuomov> I've already described it
23:30:55 <dash> tuomov: so let me get this straight. you think that the problem of libraries being tailored for the lowest common denominator.... is to move them even _lower_?
23:31:05 <dash> i don't see how that makes any sense at all
23:31:23 <tuomov> no
23:31:34 <dash> okay
23:31:39 <dash> then i don't understand what you are saying
23:31:42 <tuomov> the solution is to make it easier to write proper wrappers for the libraries in each target language's style
23:31:42 <nysin> I can make an argument for that if tuomov won't. Not that I would agree, but ;)
23:31:54 <tuomov> the api should not be the same for each language, because language are different
23:32:13 <tuomov> if you write a bloated oo api, it is hard to write wrappers for different types of languages
23:32:33 <nysin> "bloated" and "oo" don't imply each other...
23:32:36 <tuomov> although the generation of just that kind of crappy api can be automated
23:32:36 <dash> tuomov: i don't understand what "bloated oo api" means
23:32:46 <dash> or why this makes parrot a problem 
23:32:51 <tuomov> the kind of api most apis these days are
23:33:07 <dash> that doesn't tell me much
23:33:29 <nysin> It's bad because I say it is, and I say it is because it's bad!
23:34:08 <tuomov> list of functions in the api is thousands of lines for even the simplest things
23:34:17 <tuomov> that's the state of modern apis
23:34:27 <dash> ok?
23:35:21 <tuomov> a high-level virtual machine just aims at exporting such an api to all languages without effort
23:35:30 <dash> yes
23:35:35 <dash> effort is generally disliked
23:35:36 <tuomov> but that's wrong!
23:35:39 <dash> why?
23:36:03 <tuomov> it should be made easier to write different kinds of apis for different languages to same services
23:36:13 <tuomov> thus a simple low-level c api at the bottom
23:36:16 <dash> tuomov: i find your style of conversation hard to engage
23:36:21 <dash> hence, I am going to bed
23:36:25 <dash> see you goons tomorrow!
23:36:39 <nysin> tuomov: what if one wishes to avoid destructive updates?
23:37:04 <nysin> That's a poor fit for many languages' philosophies, but nice in FP...
23:37:19 <tuomov> it's easier to avoid those by having that simple c api at the bottom than automagically exporting a huge oo-api
23:37:31 <nysin> It's also nontrivial to simply write a wrapper for a C-base function accomplishing it.
23:38:31 <nysin> Since you're suggesting a fantasy world anyway, can I suggest a language other than C?
23:38:39 <tuomov> for many things, the higher-level api might be about constructing messages to pass to the low-level part to handle eventually
23:39:25 <tuomov> well, C atm is the only language that is easy to link to from other languages
23:40:37 <nysin> Two concerns: (1) debuggability. If you move important functionality to 'native code' inaccessible to a debugger...
23:41:07 <tuomov> huh?
23:41:17 <tuomov> how is vm any different?
23:41:37 <nysin> (2) bloat. The adapting classes could easily rival the size of the base-implementing code...
23:42:09 <nysin> In which case why bother with the C implementations...
23:42:28 <nysin> Depends how a VM is implemented.
23:42:35 <nysin> That term's incredibly vague/broad.
23:42:36 <tuomov> you can add debug info to native libraries
23:43:12 <tuomov> the simple C implementation is about _quality apis_ not about reduction of amount of compiled code or even code to maintain
23:43:42 <nysin> I thought you were changing the APIs anyway?
23:43:48 <nysin> In the higher-level languages.
23:44:42 <tuomov> core system features should have simple apis, so that everyone can write a decent interface to them for a particular language or just to suit their style of programming instead of forcing a huge bloated oo-api as is so common these days
23:45:17 <nysin> Why can't one use only a small subset of a core with a huge bloated oo-api?
23:45:45 <nysin> It's not going to be visible to end-users of the high-level libraries anyway and this is not, you said, about the amount of compiled code or even code to maintain.
23:45:46 <tuomov> because you can't use small enough part?
23:45:58 <nysin> You can't?
23:46:16 <tuomov> due to the crappy nature of the api, depending on all parts of itself
23:46:36 <nysin> Oh, sure, one has to keep all the code around.
23:47:10 <nysin> If I call crappy_api's_hash_table.insert(key, value), I don't have to care though.
23:47:29 <tuomov> key is of course CrappyAPIKeyThatMustBeCreatedWithSomethingHorrible
23:47:48 <tuomov> and value too
23:48:03 <tuomov> and of course everything in that api depends on CrappyAPIHashTable
23:48:15 <tuomov> instead of what might be native to the language you are using
23:48:27 <nysin> If it follows current OO orthodoxy, again, it's encapsulated so one doesn't care...
23:48:57 <tuomov> it's awful
23:51:56 <nysin> I've not yet grown this cynical, I guess, though Java's streams come close... I'm therefore limited to how long I can keep supposing the commonness of these APIs for the purpose of argument...
23:52:49 <nysin> Because to everything I say you can simply postulate an ever more evil, hypothetical OO API.
23:53:32 <tuomov> I'm disgusted by most apis. I dont' want to fill my head with them.
23:53:57 <nysin> Every class I mention must come from triply-hierarchical factories and suchlike...
23:54:36 <nysin> I'm curious, can you point to one you like?
23:54:45 <tuomov> opengl is a standard example
23:54:52 <tuomov> of course that particular style doesn't suit everything
23:55:17 <nysin> It has its equivalent of the ioctl-grab-bag to some extent in how it deals with extensions, though
23:55:18 <tuomov> it isn't particularly small, though, but I like the style
23:55:24 <tuomov> lua/c api is another nice c api
23:55:32 <tuomov> basic posix/libc stuff is ok
23:55:33 <nysin> Agree about that one.
23:55:36 <nysin> (Lua/C)
23:55:55 <nysin> Which POSIX? They've kept expanding it...
23:56:00 <tuomov> much of the haskell libs are nice, but I don't like the posix interface
23:56:10 <tuomov> the core stuff
23:56:24 <musasabi> I think tuples are clumsy in haskell.
23:57:22 <dons> that's an interesting thought
23:57:50 <dons> I'll have to ponder what better tuples would look like
23:59:49 <musasabi> well better tuples would have functions which would work with any arity tuples.
