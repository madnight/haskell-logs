00:00:11 <dons> ah, yes. agreed
00:01:16 <dons> the tuple library only provides fst, snd, curry, uncurry. which is a bit disappointing.
00:01:21 <musasabi> also should a triple be (a,b,c) or (a,(b,c)) - why - why not?
00:01:24 <tuomov> (x, y, z) should just be shorthand for (x, (y, z))
00:01:26 <norpan> you can do that with template haskell
00:01:31 <musasabi> mapFst should be at least included
00:01:54 <musasabi> norpan: you can say in template haskell "generate tuple functions from 3 till N".
00:02:16 <dons> the (,(,)) form is much simpler - you just need 0 and 2-tuples
00:02:22 <norpan> you don't have to generate them, you can write a generic tuple function and use it
00:02:51 <musasabi> yes, that is the first thought one has.
00:03:14 <musasabi> but then one runs into a problem when trying to create a tuple whose second element is a tuple.
00:03:24 <musasabi> and what should one-tuples look like?
00:03:43 <norpan> (a,()) of course
00:03:44 <monochrom> There is no one-tuple.
00:04:02 <musasabi> monochrom: exactly.
00:04:19 <nysin> Isn't this precisely the same argument as one can have about recursive list representations?
00:04:22 <musasabi> and thus functions can return one value not a tuple of values. 
00:04:46 <monochrom> I am not sure what I am talking about.
00:05:21 <monochrom> There is no one-tuple in Haskell.  If you design a language, you can thinking about including or excluding one-tuples.
00:05:47 <norpan> http://www.xoltar.org/2003/aug/13/templateHaskellTupleSample.html
00:05:52 <norpan> try that one on for size
00:06:18 <norpan> template haskell is implemented in ghc btw
00:06:27 <andersca> hi norpan 
00:06:33 <norpan> hej anders panders
00:06:50 <musasabi> norpan: I am thinking much more of things like "how many values does a function return?"
00:07:18 <norpan> then you must first think "what is a value"
00:07:23 <musasabi> yes...
00:07:38 <musasabi> and is (a,b) a value or a tuple of two values.
00:07:44 <norpan> both
00:08:43 <musasabi> of course. but that has to be decided. (if one wants multiple return values then one could use implicit one-tuples for the normal case, but that creates other problems)
00:09:47 <norpan> but why would you want multiple return values when you just as easily can use a tuple
00:10:15 <norpan> and where would all the values go, if not into a tuple
00:10:19 <andersca> noclouds: what is up
00:10:33 <norpan> i have to get to work i think
00:10:45 <norpan> it's 9:10 am
00:10:47 <andersca> I thought you were there already
00:10:57 <norpan> you thought wrong, i am very lazy
00:11:44 <andersca> well that's true for sure
00:12:14 <norpan> look who's talking
00:12:24 <norpan> well well, bye bye
00:12:38 <musasabi> bye
00:13:33 <norpan> http://www.haskell.org/hawiki/TemplateHaskell#head-09fe39ae9fcf1c69ac2b5885ad6e2b2b3c3e22bc
00:13:40 <norpan> long url but nice contents
00:15:44 <andersca> I thought you left
01:02:03 <dogand> hi, i'm just wondering how i should do to putStr information i recieve from a socket?
01:06:00 <dogand> never mind then
01:25:06 <Janni> Morning...
01:26:59 <TheHunter> Morning Janni
01:56:09 <musasabi> How should I make a cabal package that is dependent on a library not in the default library path?
03:43:39 <Lemmih> Time to get high on endorphin again.
03:43:57 * Lemmih goes unicycling.
03:44:34 <xerox> O_o
03:48:46 <tromp> @index words
03:48:46 <lambdabot> Data.List,Prelude,List
03:58:31 <xerox> a question
03:59:35 <xerox> what does it mean: ''If we write something using the [5, 4, 3, 2, 1] notation, the compiler simply translates it to the expression using (:) and []''
04:00:00 <xerox> now, i understand the meaning of this sentence, but what about the '(' ')' around ':' ??
04:00:13 <ned> [5,4,3,2,1] == 5:4:3:2:1:[]
04:00:37 <ned> no need of parens
04:00:39 <xerox> yep
04:00:40 <TheHunter> [5,4,3] === 5:4:3:[] = (:) 5 ( (:) 4 ( (:) 3 [] ) )
04:00:51 <xerox> aaaah
04:00:55 <xerox> !
04:01:07 <xerox> Prelude> (:) 5 []
04:01:08 <xerox> [5]   
04:01:30 <xerox> where : 5 [] will not work.
04:01:36 <xerox> (but, why?)
04:01:45 <TheHunter> you can do that with every operator: (+) 3 5 ==> 8
04:02:02 <xerox> mmh nice
04:02:24 <TheHunter> and you can "infixate" usual functions : (+1) `map` [1,2,3] ==> [2,3,4]
04:02:41 <xerox> i still not know that :)
04:02:51 <TheHunter> where (+1) itself is a shorthand for \x -> x + 1
04:03:23 <xerox> thanks
04:14:02 <marcot> Hello, is it possible to compile with ghc in GNU/Linux and make code for windows?
04:18:43 <xerox> marcot, googling i see:
04:18:43 <xerox>   Possible soltions:
04:18:43 <xerox> 	1) Someone extend GHC so it knows how to cross-compile.
04:18:43 <xerox> 	2) Use GHC's spiffy Haskell->C conversion addon library ;)
04:18:56 <xerox> but it's a mail from: Date: Tue, 7 Dec 1999 12:23:57 -0800
04:19:12 <marcot> xerox: thank you.
04:19:51 <marcot> xerox: I thought that there'd be an very simple way of doing this, but's all right then. I'll not do this... (=
04:21:25 <xerox> find a windows machine and install GHC :)
04:22:39 <marcot> xerox: I actually know where to find one with ghc, that's why it doesn't matter so much! (;
04:25:16 <tromp> who knows what WTI means? comes up alot on cafe-haskell mailinglist...
04:25:58 <xerox> dunno
04:28:44 <Igloo> DYM TWI (Things With Identity)?
04:55:06 <tromp> oops, right you are, Ogloo:)
04:55:11 <tromp> Igloo even
05:14:53 <boegel> hello everyone !
05:16:51 <Muad_Dibber> hi boegel
05:17:31 <boegel> I've added some new functionality to my raytracer, check my website to see some images...
05:18:27 <xerox> Prelude> read "5"
05:18:28 <xerox> ERROR - Unresolved overloading
05:18:28 <xerox> *** Type       : Read a => a
05:18:28 <xerox> *** Expression : read "5" 
05:18:29 <xerox> what does it mean ?
05:18:39 <Muad_Dibber> boegel, u made a raytracer in haskell?
05:18:52 <boegel> Muad_Dibber, yep :)
05:19:07 <boegel> Muad_Dibber, http://studwww.ugent.be/~kehoste to see some images of it
05:19:22 <xerox> boegel wow.
05:19:31 <boegel> xerox, 5 can be of type int, type double, and so on...
05:19:42 <boegel> try this: read (5 :: Int)
05:19:43 <Muad_Dibber> aah its ur thesis :)
05:19:46 <Muad_Dibber> looks good :)
05:19:48 <boegel> Muad_Dibber, idd :)
05:20:03 <boegel> I just have to add transparency, and restructure the code a bit
05:20:13 <xerox> Prelude> read (5 :: Int)
05:20:13 <xerox> ERROR - Type error in application
05:20:13 <xerox> *** Expression     : read 5
05:20:13 <xerox> *** Term           : 5
05:20:15 <boegel> and then I'm finished (for now) with the engine part
05:20:15 <xerox> *** Type           : Int
05:20:18 <xerox> *** Does not match : [Char]
05:20:25 <psi> xerox: (read "5") :: Int
05:20:32 <xerox> psi i thought it yea
05:20:36 <xerox> thank you all :)
05:20:45 <boegel> xerox: read "5" :: Int
05:20:54 <boegel> xerox, sry :)
05:21:11 <xerox> np
05:22:31 <psi> in instances where it can be inferred what the type should be, you don't need to do this, of course
05:22:41 <Muad_Dibber> boegel: cool :) didnt know they had such nice thingies going on in belgium ;)
05:24:59 <boegel> Muad_Dibber, why shouldn't we ? :p
05:25:15 <Muad_Dibber> i didnt say u shouldnt, cause u should
05:25:17 <Muad_Dibber> i jsut didnjt know :)
05:25:20 <Muad_Dibber> *just didnt
05:25:43 <boegel> also check this: http://studwww.ugent.be/~arbracke/THESIS/index.html
05:25:47 <boegel> it's in Dutch though
05:26:07 <boegel> but it's a friend of mine also doing his thesis with Haskell, he's writing audio filters
05:26:11 <Muad_Dibber> since i'm from the netherlands i speak better dutch than english ;)
05:26:13 <boegel> (delay, reverb, and so on)
05:26:18 <boegel> oh, okay :)
05:26:57 <Muad_Dibber> to bad i havent gotten anything to work on my amd64 yet :P
05:27:02 <Muad_Dibber> anything being any haskell stuff :P
05:27:30 <boegel> :)
05:29:24 <Itkovian> boegel: who's your advisor?
05:30:04 <boegel> Itkovian, you're from Ghent too :)
05:30:10 <Itkovian> yes I am
05:30:20 <boegel> Itkovian, prof. Boute and his Phd student (Hannes)
05:30:27 <Itkovian> I teach the exercises for 'Niet-procedurale programmeertalen' :-)
05:30:32 <Itkovian> so you may have met me
05:30:35 <Itkovian> lol
05:30:39 <boegel> lol, I have :)
05:30:46 <Itkovian> Ah Boute ...
05:30:52 <Itkovian> Never had the man
05:31:01 <Itkovian> as a teacher
05:31:40 <Muad_Dibber> do all gent uni people like haskell? :)
05:31:48 <boegel> heh :)
05:32:00 <Itkovian> no, they don;t ...
05:32:12 <Itkovian> but we have a couse on functional/logical programming stuff
05:32:20 <boegel> Muad_Dibber, they should though :p
05:33:03 <Muad_Dibber> :)
05:33:27 <Muad_Dibber> in the group i'm currently doing my master, about half of em loves it, and the other half doesnt want to have anything to do with it ;)
05:35:00 <Itkovian> well ... here the opinions are about the same i think, from the people who know it anyway
05:36:01 <Muad_Dibber> well, in my opinion, its quite a usefull language to demonstrate things
05:36:22 <Muad_Dibber> but i have to admit i do not know or have not even tried its usefullness in creating a commercial application :)
05:41:47 <boegel> Muad_Dibber, a lot of stuff has been done in Haskell, including an OS (hOp)
05:43:12 <Muad_Dibber> boegel: i know it has been done ;)
05:43:35 <boegel> Muad_Dibber, oh okay then :p
05:45:10 <Muad_Dibber> :)
06:06:27 <irce> does anyone have any games in haskellma, mayybe chess. didn't find many with google.   
06:19:47 <irce> Just had a seminar in domain specific embedded languages in haskell. damn that was pain
06:20:33 <Philippa> badly delivered etc?
06:20:43 <Philippa> or were you the one giving the seminar?
06:20:58 <Philippa> (these two things are, of course, mutually exclusive ;-)
06:22:04 <irce> I was the one giving. haven't written a sinlge line of haskell yet. got ok credit though
06:22:28 <irce> gotto make a game with AI till next week. ARGH 
06:23:27 <boegel> irce, in Haskell ?
06:23:35 <irce> yep
06:24:29 <irce> have done a course in scheme. So im not be doomed yet :)
06:25:05 <Philippa> irce: this one of those "uni course where everybody gives a 10-15 minute (or possibly longer) talk" things?
06:25:35 * shapr boings cheerfully
06:25:49 <xerox> you can't stop boinging!
06:26:11 <shapr> ain't it great?
06:26:17 <shapr> I found some unicyclists in my area!
06:26:20 <shapr> w00t!
06:26:23 <xerox> good!
06:26:52 <shapr> They're all about twelve years old admittedly... but that shouldn't be a problem.
06:26:59 <irce> yep. took 30 min . 30-45 recommended  
06:29:17 <boegel> shapr, check my website :)
06:30:01 <shapr> oh, more pokemon?
06:30:09 <boegel> reflection !
06:30:32 <shapr> whoa, sexy!
06:30:52 <Lemmih> shapr: Cool. Are they any good?
06:31:42 <xerox> why i get ERROR - Undefined qualified variable "Char.toUpper"  and ERROR - Undefined qualified variable "Char.isLower"  ?
06:31:43 <shapr> Lemmih: I dunno yet. I think they're better than me, but that's not difficult :-)
06:32:00 <shapr> xerox: did you do "import qualified Char" ?
06:32:16 <xerox> uh no, Yet Another Haskell Tutorial didn't mention it
06:32:39 <shapr> Lemmih: Anyway, it'll be fun to meet some other unicyclists. I've never seen anybody unicycle in person.
06:32:39 <xerox> ERROR - Syntax error in expression (unexpected keyword "import") 
06:32:46 <shapr> hiya fusss, how's code?
06:33:05 <shapr> xerox: you gotta do that at the top of the file, just after where
06:33:09 <fusss> fusss still learning; I downloaded both Hugs and GHCi
06:33:10 <shapr> module Foo where import qualified Char
06:33:19 <shapr> fusss: do you have some new questions?
06:33:24 <fusss> I am on page 44 of the Haskell tutorial
06:33:43 <xerox> shapr that's strance, in fact YAHT do that: Prelude> filter Char.toLower "Hello World"
06:33:50 <xerox> *strange
06:34:02 <fusss> shapr: well, yes :-) is there an online-help facility in Hugs? something like "apropos"
06:34:17 <shapr> Lemmih: I'm practicing up, I hope to have lots of tricks to share with you in the Summer :-)
06:34:39 <shapr> xerox: oh, that's correct in GHCi
06:35:05 <xerox> ah
06:35:39 <shapr> fusss: no, there's not. There's a tour of the prelude, and there's lambdabot's @index, but those could all be far better.
06:35:52 <fusss> also; how do I import modules from the Hugs shell? I get errors when I type "import Random". Also is there a way to access individual functions in modules without loading them?
06:35:59 <shapr> :m + Random
06:37:14 <xerox> shapr mmh, map Chat.toUpper "hello world" works, filter doesn't
06:37:22 <xerox> *Char
06:37:54 <shapr> filter expects a function that takes a single item and returns true or false
06:37:58 <xerox> is there an haskell paste?
06:37:59 <fusss> shapr: thanks
06:38:06 <shapr> filter (== xerox) ircUsers
06:38:17 <shapr> there's the paste page on the wiki
06:38:21 <shapr> @wiki HaskellIrcPastePage
06:38:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:39:29 <xerox> i'm really sorry
06:39:37 <xerox> s/is/to/ in the filter.
06:39:42 <xerox> (i'm too sleepy)
06:39:56 <xerox> wops, s/to/is/ ...
06:40:09 * shapr grins
06:40:17 <shapr> no worries, we're all learning.
06:40:18 <xerox> Prelude> filter Char.isUpper "Hello World"
06:40:18 <xerox> "HW"
06:40:18 <xerox> Prelude> filter Char.isLower "Hello World"
06:40:18 <xerox> "elloorld"
06:40:24 <xerox> yes ^_^
06:43:14 <fusss> are stuff like :t and :m shell commands or language keywords? 
06:43:46 <arjanb> commands
06:44:17 <xerox> fusss :help gives a list
06:52:07 <shapr> salut dmitri83 
06:52:14 <dmitri83> hello
06:52:39 <shapr> how's code?
06:52:52 <dmitri83> what do you mean ?
06:53:27 <shapr> Well, code is life, so it's like asking "How's life?"
06:53:47 <shapr> les logiciel est la vie, c'est marche?
06:53:56 <dmitri83> makes no sense for me since first of all I am mathematician :)
06:54:14 <dmitri83> for me proofs are life
06:54:40 <dmitri83> by the way, I am not french
06:54:46 <shapr> oh, me neither.
06:55:02 <dmitri83> you've greeted me in french, though
06:55:14 <shapr> yes, because you have a loria.fr hostname.
06:55:53 <shapr> ~~~~~~~~~~~~!
06:55:54 <dmitri83> that's because I am studting in French
06:56:11 <dmitri83> France*
06:56:29 <dmitri83> normalement je suis russe :)
06:57:29 <boegel> hey andersca_
06:57:40 <shapr> Yah, I tried to paste "hello" in koi-8 there.
06:57:44 <andersca_> hello
06:57:50 <shapr> hej andersca_!
06:58:57 <dmitri83> by the way, shapr, since I'm here, I should ask for a piece of advice
06:59:35 <shapr> ok!
06:59:40 <xerox> i'm starting likeing haskell.
06:59:59 <dmitri83> I have a piece of code that implements Viterbi algorithm
07:00:12 <xerox> dmitri83 what's that ?
07:00:14 <dmitri83> in fact I started reading "Yet Another Haskell Tutorial" the day before
07:00:30 <dmitri83> it form HMM stuff, wit i'll paste a link
07:00:46 <shapr> viterbi is used in DSP and speech recog apps.
07:00:52 <xerox> uh.
07:01:00 <dmitri83> http://www.loria.fr/~jfmari/Cours/em.ps.gz
07:01:05 <shapr> HMM == Hidden Markov Models :-)
07:01:19 <dmitri83> in fact it is application of Bellman's principle from dynamic programming..
07:01:20 <shapr> HMMs are nifty, they're especially amusing when applied to IRC logs.
07:01:21 <dmitri83> ok
07:01:46 <dmitri83> so, to try to program something useful in Haskell, I coded this algo
07:01:55 <dmitri83> and it looks awkward
07:02:13 <dmitri83> can I paste some 9~10 lines here ? won't be considered as flood ?
07:02:39 <shapr> there's a paste page
07:02:42 <arjanb> dmitri83: http://www.haskell.org/hawiki/HaskellIrcPastePage
07:02:51 <shapr> yes, that's it.
07:05:09 <dmitri83> pasted..
07:05:24 <dmitri83> I haven't yet tested it
07:05:32 <dmitri83> it doesn't matter
07:05:43 <dmitri83> the code looks a bit confusing to me
07:05:55 <dmitri83> form the style point of view
07:06:23 <dmitri83> what could you do to make it more like a nicely written haskell code ?
07:06:41 <musasabi> Is there code to handle X.509 certificates in Haskell?
07:08:34 <shapr> musasabi: yes, somewhat
07:08:44 <shapr> dmitri83: I put more Viterbi code after your code.
07:09:10 <shapr> musasabi: Dominic Steinitz wrote both an LDAP client and the crypto libs.
07:09:26 <shapr> I think the cryptolib does most but not all of the X.509 stuff.
07:09:45 <shapr> His ASN.1 code is quite elegant compared to the C and Java ASN.1 code I've used in past jobs =)
07:10:00 <dmitri83> shapr, oh my
07:13:13 <musasabi> erlang does ASN.1 nicely..
07:13:31 <xerox> \begin{haskell} uh.
07:13:43 <shapr> xerox: wait till you get to literate Haskell, it's very sexy.
07:13:44 <musasabi> hmm I can find mentions of that but not entire code.. (cryptolib only says x.509 in the TODO section)
07:13:54 <shapr> hmm
07:14:06 <shapr> Can you find his ldap client?
07:14:07 <dmitri83> shapr, how do I convert it to .ps ?
07:14:14 <dmitri83> or .pdf
07:14:17 <boegel> xerox, that's latex haskell mode
07:14:21 <boegel> I think
07:14:22 <shapr> umm, I forget.
07:14:31 <shapr> lhs2tex maybe?
07:15:07 <xerox> is it in the standard miktex package?
07:15:13 <dmitri83> I am logged on university server, does its installation require root ?
07:16:40 <musasabi> no :-(
07:17:08 <shapr> musasabi: I have an older copy of his LDAP client that I got from him in email, but I think it's years out of date.
07:17:55 <shapr> musasabi: do you know how to turn an .lhs file into a .ps file? :-)
07:18:32 <musasabi> there was a tool...
07:19:50 <musasabi> shapr: www.cs.uu.nl/~andres/lhs2tex/
07:20:09 <dmitri83> damn,it requires GHC, I have only HUGS installed
07:20:26 <Philippa> yeah, a lot's GHC-only sadly
07:20:35 <Philippa> GHC-Haskell is a seriously powerful language
07:20:45 <kosmikus> lhs2TeX --poly input.lhs > input.tex && latex tex && dvips -o input.ps input.dvi
07:20:58 <dmitri83> what about lambdaTeX ?
07:22:20 <kosmikus> there are a couple of .sty files that simply put code blocks into a verbatim environment
07:22:37 <kosmikus> lambdaTeX is a bit more sophisticated, but when I last looked, it didn't produce output I liked
07:25:24 <Igloo> CosmicRay: Bah, I hadn't thought about libraries that couldn't be built everywhere. Ideas for variables that work in that situation welcomed...
07:25:47 <CosmicRay> I'm not quite sure I know what you mean...
07:25:57 <CosmicRay> oh, you mean programs that can only build with ghc?
07:26:05 <Igloo> Yeah
07:26:33 <Igloo> Oh, actually, it's easy
07:26:55 <Igloo> You build-dep on $ghc6_lib_deps, $ghc5_lib_deps, ghc6 | ghc5
07:27:35 <CosmicRay> BAH I HATE OUR ISP
07:27:35 <CosmicRay> hmm
07:27:49 <CosmicRay> the whole arch string still makes me nervous.
07:27:52 <Igloo> (modulo errors in var names)
07:27:59 <shapr> so, who wrote this famous lhs2tex program?
07:28:01 * shapr grins
07:28:13 <Igloo> AFAICT it's necessary
07:28:24 <CosmicRay> why is that?
07:28:41 <Igloo> It's the only way I know to get the buildds to DTRT
07:29:12 <CosmicRay> I can only see it making sense for programs that can build with either ghc6 or nhc98 (or some other thing)
07:29:24 <CosmicRay> I haven't seen any yet for which that's useful
07:30:37 <Igloo> Aren't we talking about libraries, for which we want to build with everything possible?
07:30:46 <kosmikus> shapr: Ralf Hinze did do most of the work
07:30:53 <Igloo> And the haskell-utils stuff is programs that build with ghc6, ghc5, nhc98 or hugs
07:31:26 <Igloo> I keep being tempted to look into how hard it would be to make darcs nhc98-compliant
07:31:45 <CosmicRay> hmm.
07:32:01 <CosmicRay> Igloo: but at the same time, our policy mandats cabal
07:32:07 <CosmicRay> which only works with ghc6 and hugs
07:32:32 <Igloo> That's just a cabal bug, though
07:32:53 <CosmicRay> if a package truly can build with any of those...
07:33:03 <Igloo> The policy is something we are aiming towards, we are not there yet
07:33:13 <CosmicRay> oh I remember what you were talking about with the build-deps on the buildds now...
07:33:23 <CosmicRay> for an alternative list, they always try to install the first one?
07:34:13 <Igloo> Yes. Oh, so the above might actually need to be a bit uglier, but it's still possible
07:34:23 <CosmicRay> you'll hve another problem... for libraries, you'll want to build a libx-y-dev where x is ghc6, nhc98, ghc5, hugs as supported by the lib and the platform.
07:34:44 <CosmicRay> so you'll have to have an architecture: line in the control file for each x listing the platforms on which it'll work to build it
07:34:52 <CosmicRay> ugh, this is starting to make ocaml sound easy!
07:35:29 <Igloo> Right, but that's just:
07:35:29 <Igloo> Package: hat-ghc6
07:35:29 <Igloo> Section: devel
07:35:29 <Igloo> Architecture: $ghc6_arches
07:35:36 <Igloo> in control.in
07:35:47 <CosmicRay> a control.in?
07:35:50 <Igloo> (something I left out of the mail, sorry)
07:36:07 <Igloo> control.in is what has the $ghc6_lib_bdeps build-deps
07:36:27 <CosmicRay> why not use the substvars mechanism?
07:36:35 <CosmicRay> Depends: ${haskell:Depends}, ${shlibs:Depends}, ${misc:Depends}
07:36:43 <Igloo> Because the build-deps need to be done before that happens
07:37:35 <Igloo> I'm not sure if the Architecture line could be done by that or not, but given we have the control.in anyway I think this way is cleaner
07:38:22 <CosmicRay> I'm not sure it is...
07:38:24 <CosmicRay> hm.
07:38:40 <CosmicRay> I think it would be easier to just fix ghc6 than to go through all this mess
07:38:47 <CosmicRay> then we could just build everything with it.
07:38:55 <CosmicRay> it's broken on arm, right?  anything else?
07:39:00 <Igloo> You'd have to fix nhc98 and hugs too  :-)
07:39:02 <Igloo> mips and mipsel
07:39:07 <shapr> CosmicRay: who broke your arm?
07:39:27 * shapr continues to be a smartass.
07:39:45 <Igloo> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=274942
07:40:04 * shapr suspects that ARM.com has heard enough broken arm jokes to make them sick.
07:40:33 <CosmicRay> Igloo: not if I ignore nhc98
07:40:45 <CosmicRay> Igloo: if ghc6 works everywhere, there's no point to bothering with nhc98 support in binaries
07:41:20 <Igloo> No, but there is in libraries (well, I guess you can debate that)
07:41:29 <CosmicRay> shapr: what have you been drinking today? :-)
07:42:47 <shapr> CosmicRay: not enough most likely ;-)
07:42:49 <CosmicRay> igloo: is -mminimal-toc supported on arm?
07:43:00 <CosmicRay> shapr: perhaps it's past its expiration date :-)
07:43:10 * shapr laughs
07:43:39 <Igloo> No idea, I've never even heard of it before  :-)
07:43:44 <CosmicRay> Igloo: I saw the relocation truncated to fit on powerpc.  -mminimal-toc helped me there.
07:43:46 <dmitri83> shapr, where did you get the "haskell" environment in your script from ?
07:43:55 <Igloo> DYM mips+mipsel?
07:44:02 <CosmicRay> no, powerpc
07:44:04 <CosmicRay> aix
07:44:12 <shapr> dmitri83: that Viterbi code is from the fptools repo
07:44:16 <Igloo> No, when you said arm did you mean mips+mipsel?
07:44:21 <CosmicRay> oh
07:44:32 <CosmicRay> yes.
07:44:41 <Igloo> It's in "IBM RS/6000 and PowerPC Options"
07:44:48 <CosmicRay> blat.
07:45:48 <shapr> dmitri83: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/nofib/real/HMMS/
07:46:28 <xerox> a question, why it is foldr (+) .. , foldr (-) .. , (:) something [] , with operator enclosed in parenthesis ?
07:47:04 <Philippa> so it doesn't read that as an application of the operator
07:47:09 <shapr> because function application binds most tightly
07:47:52 <xerox> mmh ?
07:48:06 <xerox> foldr + 0 [1, 2, 3] what would mean ?
07:48:55 <kristnjov> that would be like 3+2+1+0 i think
07:49:07 <xerox> mmh..
07:49:23 <xerox> but it raises an error
07:49:32 <CosmicRay> Igloo: you may want to submit that one to the gnu folks directly
07:49:33 <kristnjov> oh yeah
07:49:33 <tromp> foldr (+)
07:49:34 <kosmikus> no, it has to be foldr (+) 0 [1,2,3]
07:49:34 <kristnjov> (+)
07:49:39 <CosmicRay> Igloo: the debian maintainers are not always the most responsive
07:49:43 <xerox> kolmodin i got it, but why?
07:49:49 <kristnjov> when it's an operator you should represent it with parenthesis
07:49:56 <arjanb> xerox: that would parse as (foldr) + (0  [1,2,3])
07:50:03 <xerox> it tries foldr (+ 0 [1, 2, 3]) ?
07:50:10 <xerox> arjanb ah! thanks.
07:50:29 <Igloo> Hmm, OK. I plan to make it RC once sarge releases, so that might inspire them to look into it, though  :-)
07:50:51 <monochrom> heh f + 0 very cool.  Imagine f is a vector, 0 is the zero-vector, and + is vector addition, ...
07:52:00 <CosmicRay> Igloo: you could make it rc now and tag it not-for-sarge or whatever
07:52:18 <CosmicRay> Igloo: what's the bug on arm?
07:52:44 <Nioate> monochrom: even better, imagine f is a function forall a. Num b => a->b. 
07:52:51 <CosmicRay> fwiw, I will have little respect for nhc98 until they support 64-bit platforms
07:53:15 <CosmicRay> my laptop is the only 32-bit machine I work with regularly
07:53:25 <Igloo> arm's just a case of either waiting for them to format their floating point numbers in the same way as the rest of the world or adding code to read what they use. If it was the last arch it would be worth doing, but as it's not I'm doing other things instead
07:53:29 <kosmikus> Nioate: a function of that type wouldn't be very useful
07:53:42 <Nioate> although I guess functions have a defenition for vectors too
07:53:50 <Nioate> being vectors
07:55:01 <CosmicRay> Igloo: is that a problem with gmp or something else?  (is there a debian bug where I could read of it?)
07:55:47 <Nioate> kosmikus: which part prevents it from being useful?
07:56:41 <CosmicRay> Igloo: 
07:56:47 <CosmicRay> 0.9.5 should have a -Wa,-xgot section in the makefile for linux/mips, like
07:56:47 <CosmicRay> netbsd/mips has.  If it doesn't, you'll need to pull that change from cvs.
07:56:47 <CosmicRay> You'll also need to ensure that libgcc.a and libc_noshared.a are also built
07:56:47 <CosmicRay> with -Wa,-xgot
07:56:54 <Igloo> I /think/ it's __decodeFloat in rts/StgPrimFloat.c
07:56:54 <CosmicRay> I wonder if that is the case for us
07:57:17 <CosmicRay> if libgcc.a isn't built with -xgot, that could perhaps explain weirdness
07:57:42 <Igloo> And/or maybe other bits in that file
07:58:31 * Igloo finds my first contact with pb where he estimted "a couple of months" in Sep 2003, although I think he later said "a few months". So it might even already be done.
07:59:21 <CosmicRay> pb?
07:59:28 <Igloo> Debian arm guru
07:59:43 <CosmicRay> Igloo: if you do an unregisterized build, does it still require decodefloat?
07:59:51 <Igloo> Yes
08:00:20 <CosmicRay> well that sucks.  so ARM is the only platform out there that does this in a non-ieee way?
08:00:39 <Igloo> FVO "out there" == in Debian, yes
08:01:02 <CosmicRay> weird.
08:01:17 <CosmicRay> according to http://www.ugcs.caltech.edu/info/binutils/c-arm_1.html, it does use ieee
08:01:35 <CosmicRay> but I think it is wacked that ghc wrote their own floating point processor
08:02:35 <Igloo> I think all it does is take them apart and put them back together again. I haven't actually looked at why it is necessary
08:03:26 <Igloo> Ah, yes, looks like it might be fixed. I'll try porting it some time.
08:03:56 <CosmicRay> this may be relevant.  http://lists.arm.linux.org.uk/pipermail/linux-arm/2004-January/006775.html
08:04:27 <CosmicRay> I may try porting it now.  is there an arm box somwehere?
08:04:39 <CosmicRay> if this works, I could compile haskell code on my zaurus pda :-)
08:05:48 <Igloo> :-)
08:06:04 <Igloo> debussy I think. db.debian.org/machines.cgi will know
08:06:18 <CosmicRay> last I tried to use one, they wer all down
08:06:29 <CosmicRay> debussy does seem to be back.
08:08:14 <CosmicRay> with the speed of this box, we may have our first compilation error next Tuesday :-)
08:08:28 <CosmicRay> so shapr, how is it that monads will solve all my exception handling woes?
08:08:40 <CosmicRay> Some people seem to think that monads+Either are the magic bullet
08:08:42 <CosmicRay> I can't work out how
08:08:43 <kosmikus> Nioate: you probably meant (Num b) => a -> b, where a is a free, not a universally quantified variable -- but I didn't see this immediately
08:09:19 <Igloo> Hey, you're lucky. I'm debugging nhc98 on crest in parallel with it being a buildd
08:11:20 <CosmicRay> heh
08:12:29 <kowey> quick question on libs... i'd like to use Simon Marlow's System.Process, which comes with a .hsc file, a .c and .h file
08:12:35 <kowey> uh... how do i install this?
08:13:06 <kowey> i tried hsc2hs and ghc on the resulting file and then copying it to /usr/local/lib/ghc-6.2.2/imports/System but not happy
08:17:44 <kowey> argh... have to run; be much obliged if someone could respond at http://www.haskell.org/hawiki/ExternalCommands
08:23:24 <CosmicRay> ah geez, I'd have to start this arm port from scratch since there is no ghc5 there either.
08:23:33 <CosmicRay> foo
08:23:58 * CosmicRay isn't quite ready to do THAT again
08:27:49 <Igloo> :-)
08:46:58 <shapr> CosmicRay: because, you can just float Either Result or Error
08:48:18 <CosmicRay> what do you mean, "float" it?
08:56:09 <shapr> you know how the Maybe type works?
08:56:16 <CosmicRay> yes
08:56:26 <shapr> and do you know how to use it with a monad?
08:56:43 <CosmicRay> probably not.... I know how to return an IO Maybe, but that's about it
08:57:03 <shapr> ok, once you get the maybe monad in your head, it's a short jump to the error/either monad.
08:57:07 <CosmicRay> I've got IO figured out but other monad stuff is still a little opaque to me
08:57:26 <shapr> And then I think, the eureka-sized bolt of lightning will hit you full on.
08:57:58 <CosmicRay> where do I read about maybe monads?
08:58:01 <shapr> monad are shockingly elegant and powerful.
08:58:07 <shapr> http://www.nomaware.com/monads/html/
08:58:33 <shapr> I'd suggest that you go through that from the beginning, and ask questions here on #haskell when you have them.
08:58:51 <CosmicRay> soudns good, and that looks like a hefty thing to read
08:58:55 <CosmicRay> I'll have to do that this weekend
08:58:58 <shapr> I'll be here and coding for the next few hours.
08:59:05 <shapr> It's not as hefty as you might think.
08:59:07 <CosmicRay> or maybe this afternoon, we'll see
08:59:12 <CosmicRay> tomorrow and friday are holidays in the us
08:59:15 <shapr> I can give you the basics in fifteen minutes.
08:59:28 <CosmicRay> nah, I should read it
08:59:50 <shapr> ok, I think you'll love Either once you've read that.
09:00:42 <shapr> ah kowey is back
09:02:02 <CosmicRay> so what is the deal with the nhc98 folks disdain for 64-bit platforms?
09:02:37 <shapr> I am really really tired of having thirty-five different files named thesis.ps.gz in my haskell papers collection.
09:03:08 <Igloo> It's just no-one has had time to add support for it. I fear the code, now, as I think the m68k problem may be that it assumes pointers are < 2^31
09:03:17 <shapr> I promise, if I ever write a thesis, I will use a significant filename!
09:03:19 <CosmicRay> ugh
09:04:15 <shapr> or what about the twenty files named paper.ps.gz ?
09:04:16 * shapr bangs head
09:04:44 <kosmikus> shapr: why don't you rename the files yourself?
09:05:05 <shapr> I do that, but then I don't know whether I've downloaded a file from the web or not.
09:05:12 <kosmikus> right
09:05:26 <shapr> And I don't remember where I got it either.
09:05:34 <shapr> Hopefully I can solve some of these problems with Fermat's Last Margin.
09:06:21 <shapr> even more irritating is when I have both pdf and ps versions of a paper because I forgot I had the other version.
09:06:21 <kosmikus> for theses, I can understand how it happens -- you usually don't know the title when you start writing; with papers, it could be the same thing, although you usually have a much clearer topic in mind then
09:06:56 <shapr> citeseer's naming system doesn't really help, because authors don't know beforehand when their paper will be published.
09:07:22 <kosmikus> I think I renamed my source file only before I put it online ...
09:08:36 <shapr> I think my research paper download manager should keep track of filesize and md5sum, so if I try to download a file that matches both of those, it should ask me.
09:09:08 <shapr> of course, I gzip all my .ps files after download, so...
09:09:09 * shapr shrugs
09:09:36 <shapr> dmitri83: so, what do you think of the HMMS code?
09:10:59 * shapr boings
09:11:15 <shapr> CosmicRay: anyway, I think you'll love monads once they click. They're amazing.
09:11:25 <shapr> They're at least a bronze bullet =)
09:11:30 <CosmicRay>  hehe
09:25:03 <shapr> huh, how do I unit test darcs integration?
09:25:19 <shapr> I really need HUnit test fixtures.
09:27:11 <shapr> y0 jadrian 
09:29:19 <jadrian> hello shapr! 
09:32:31 <xerox> geee
09:32:52 <xerox> me and my friends are doing a Typespeed v0.4.4 contest
09:32:57 * xerox is winning.
09:33:31 * esap is reading the thread about global variables from haskell list and haskell-cafe.
09:35:12 * shapr is doing test-driven-development in Haskell.
09:35:39 <shapr> I guess it makes sense that HUnit doesn't have support for test fixtures, since that necessarily implies side-effects.
09:35:58 <esap> "test-driven-developement"? Is that something related to XP?
09:36:19 <shapr> yah, sort of.
09:38:08 <shapr> esap: http://c2.com/cgi/wiki?TestDrivenDevelopment
09:42:35 <shapr> esap: what do you think?
09:42:37 <esap> I think the problem with this approach is that it causes you to not think about the future.
09:42:59 <shapr> I disagree. I think it causes you to think about the future only when you need to.
09:43:04 <vegai> shapr: that's one of the few things in this field that I feel are actually very helpful
09:43:06 <esap> You might easily choose solutions that cause you to spend enourmous amounts of time for each new requirement.
09:43:35 <shapr> I think that design cannot happen until you understand what needs to happen.
09:43:38 <vegai> are->is :-S
09:43:50 <shapr> And often, you can't understand what needs to happen until you're right there needing it.
09:44:13 <esap> shapr: Yes, but not understanding things is dangerous.
09:44:26 <shapr> In essence, I think Big Design Up Front is a waste of time.
09:44:42 <shapr> The real XP approach has two steps to design.
09:44:44 <dash> esap: pretending you understand things is even more dangerous :)
09:44:59 <esap> dash: true.
09:44:59 <shapr> The first step is SpikeSolution, and that happens even before you do test-driven-development.
09:45:13 <shapr> http://c2.com/cgi/wiki?SpikeSolution
09:46:00 <shapr> So, the real design cycle in XP is 1. write a vaguely working prototype for anything you've never done before 2. iterate unit test && code
09:46:58 <shapr> One of my projects in Finland was to write an implementation of RFC3161, Time Stamp Protocol, it's a layer on top of X.509, OCSP, etc
09:47:35 <shapr> The most frustrating part of the project was that my boss kept trying to sell my SpikeSolutions!
09:48:47 <esap> shapr: hehe, that's a common complaint for prototyping. From business point of view, they want to sell every version that even remotely works, then they can sell also the corrections, so you get money twice or more times :-)
09:48:52 <tuomov> I like to have a very loose idea of the big picture of what I want, and then work from the bottom up.
09:48:54 <shapr> esap: in my experience, the process of SpikeSolution first, and TDD after seriously kicks butt.
09:48:59 <tuomov> That way I'm not constrained by the initial plan.
09:49:09 <shapr> tuomov: yes, I agree.
09:49:12 <tuomov> And that applies to other things as well besides programming. (Politics.)
09:49:19 <shapr> tPP calls thta MindCrayon, but I think there's more to it than that.
09:50:02 <esap> shapr: I think SpikeSolution and iterative prototyping do work, but they are not geared towards producing quality. They are geared towards "doing it fast".
09:50:34 <shapr> I disagree! I think they produce much better quality than any other approach I've seen.
09:51:06 <shapr> From what I've seen, Big Design Up Front, often ends up with lots of code that is a) not unit tested and b) doesn't actually deliver business value to the client.
09:51:29 <shapr> that means that the 'speed of change' of the code is low, and it doesn't actually reach the goal very well!
09:51:30 <vegai> or good programmers will just steer around the design
09:51:34 <esap> shapr: I'm not arguing for Big Design Up Front
09:51:41 <shapr> esap: oh, well... what's better?
09:52:04 <tuomov> Even the world of free software works in the loose big picture, implementation from the bottom up manner
09:52:19 <tuomov> there's a loose ideal of a free operating system, and then individuals write components to it from the bottom up
09:52:44 <esap> shapr: I'm arguing for keeping the balance between time schedule and quality. Iterative prototyping tends to improve quality pretty slowly [because you'll improve things in very small pieces, so have to "context-switch" all the time. This has some overhead in it.
09:52:55 <shapr> I think that merciless refactoring means that "doing it fast" stays high quality.
09:53:41 <shapr> esap: I think iteratative development is actually faster.
09:53:41 <tuomov> Big Design Up Front results in crappy quality because there most certainly are problems with the design that are very hard to change later on
09:54:02 <shapr> esap: but I don't think I understand your argument very well.
09:54:14 <shapr> In my opinion, an iteration should take about two minutes.
09:54:27 <esap> shapr: What I'm arguing for is an iterative prototyping-based approach but with bigger chunks that you implement at any one time. Like one feature or so.
09:54:36 <shapr> If an iteration goes over five minutes, your approach is floundering and you need to back off and do something else.
09:55:00 <shapr> esap: I need more detail to understand the differences.
09:55:37 <esap> shapr: Ok, how do you ensure that your documentation is easy-to-understand. Writing it in five-minute increments will produce lots of small pieces that do not fit together.
09:56:05 <esap> shapr: Same happens with code.
09:56:19 <shapr> I try to make my unit tests examples, specs, and api docs. And everything else is in the README.
09:56:47 <shapr> No, merciless refactoring and unit tests means that you can easily keep code coherence.
09:56:54 <esap> shapr: How big thing are you thinking about. I'm thinking in terms of 100 000 lines or more.
09:57:21 <shapr> Yes, I think it works in far larger codebases too.
09:57:53 <musasabi> How do I specify addtional library paths with Cabal?
09:57:57 <esap> shapr: refactoring does work up to a point. But you can't fix big problems with the understandability with refactoring.
09:58:09 <musasabi> like -L/usr/lib/foo
09:58:37 <shapr> esap: Why do you think that?
09:59:27 <shapr> If you do continuous merciless refactoring throughout the whole cycle of development, I would assume you fix problems before they become big.
09:59:28 <esap> shapr: Because then you're "half-way through" in a big refactoring step all the time. That's the worst possible situation to be in, because then nobody can understand anything about the documentation.
09:59:43 <shapr> huh?
10:00:14 * Igloo reads Malcolm's reply on nhc98 and curses being right
10:00:39 <shapr> Even *really* big refactoring steps should take less than an hour from start to finish.
10:00:42 <esap> shapr: I mean, refactoring is always doing small things. When you do refactoring for a while, you find that the only things you can really do to improve are pretty big changes.
10:01:07 <shapr> I strongly disagree with that. Refactorings can completely change the structure of an application.
10:01:23 <esap> shapr: not when you have 30 developers.
10:01:27 <shapr> Yes, even then.
10:01:39 <esap> shapr: with strict ownership of the code.
10:01:51 <shapr> sure, not with strict code ownership.
10:02:16 <shapr> But then, I think that if you don't use collective code ownership, you're in trouble anyway =)
10:03:02 <esap> shapr: no, it's not that simple.
10:03:31 <shapr> esap: let's say that you and I were working on an app together, I *know* that you have a much deeper and wider understanding of both category theory and its application to OOP and FP than I do. So if you make a bunch of deep refactorings to the app we're coding, I trust you to do what you think is right.
10:03:55 <shapr> And if I disagree with some of your changes, I'd come to you and discuss them, because I assume that you made those changes for a good reason.
10:04:22 <esap> shapr: Yes. I know. I've been using both approaches. Both have advantages and disadvantages.
10:04:44 <shapr> What are the disadvantages of collective code ownership and egoless programming?
10:05:06 <esap> shapr: It doesn't scale, because it's not possible for every developer to understand every part of the code.
10:05:21 <esap> shapr: once the system gets big enough.
10:05:38 <shapr> I claim that the Linux kernel has not reached that size yet.
10:06:07 <esap> shapr: Linux kernel is not that big piece of code. Try all code in Debian.
10:06:13 <shapr> hm, maybe so.
10:06:42 <esap> shapr: collective code ownership works well when the code has similar design or way of thinking.
10:06:59 <shapr> On the other hand, I know I could refactor half the source code out of Debian if I were to rewrite it in Haskell.
10:07:12 <esap> shapr: but when you have heterogeneous environment with lots of different designs for different purposes, then it doesn't sound as good.
10:08:18 <shapr> The only thing I can think of there is to take the revolutionary cell structure approach, each person is part of at least two projects, and they practice cco and ep on those projects with the other developers.
10:11:27 <shapr> esap: well, if I ever work with other programmers again, I'll tell you how my current idea work in reality ;-)
10:11:45 * shapr accuses himself of being a self-employed ivory tower academic
10:11:48 <esap> shapr: Ok :-)
10:12:02 <stepcut> shapr: hehe
10:12:10 * shapr laughs
10:12:28 <shapr> esap: I would like to try PairProgramming with you sometime.
10:12:44 <esap> shapr: heh me too, I've never understood Pair programming...
10:12:59 <shapr> Your brain goes in very different directions than mine, I think it would be lots of fun.
10:14:10 <esap> yea
10:15:26 <shapr> Anyway, I see two axes with which I measure my own ideas, the software that I produce and the money that I make.
10:15:41 <dmitri83> shapr: you know, I spent almost all this time trying to understand the code you've sent to me..
10:15:46 <dmitri83> shapr: and I cannot !
10:15:54 <shapr> dmitri83: do you want some help?
10:15:55 <esap> shapr: ah, completely different axes than what I see :-)
10:16:10 <dmitri83> shapr: yes
10:16:16 <dmitri83> shapr: but in the other way
10:16:42 <dmitri83> shapr: 1st of all, the code you've sent is based on a slightly different algorithm
10:16:43 <shapr> esap: imho, software's ultimate goal is to be useful to people. And if I stay profitable, I know I'm being useful enough that people want to pay money to me.
10:16:51 <dmitri83> shapr: could you once again look at my code
10:17:05 <dmitri83> shapr: and just say how it can be rewritten/simplified
10:17:21 <stepcut> working on YI has been very enlightening
10:17:31 <shapr> stepcut: oh, how so?
10:17:37 * shapr looks at dmitri83's code
10:17:47 <dmitri83> shapr: my goal is not to write another Viterbi algo implementation
10:17:59 <esap> shapr: yes. I'm thinking things in terms of phases of software project (the use of the software is just one phase). Every phase has requirements for the software and for the project.
10:18:09 <dmitri83> shapr: my goal is to learn to write code in Haskell that is readable
10:18:15 <shapr> that's a good goal.
10:18:18 <stepcut> shapr: there are some neat ideas in there, but also I like the coding style in some of the files I have poked around in
10:18:37 <stepcut> sharp: I tend to stick too much in one function, and not define type synonyms
10:19:03 <shapr> dmitri83: in that case, I'd suggest that you first cut it apart into bigger pieces that can be understood by themselves.
10:19:08 <stepcut> shapr: I am still working out what I want my 'style' to look like
10:19:52 <shapr> dustin`: hi
10:19:55 <stepcut> for example, I recently decide to go with thisStyleIndentifiers and not this_style_indentifiers -- since the stdlibs use the former
10:20:02 * dustin` kicks colloquy
10:20:07 <dmitri83> shapr: it is 9 lines !
10:20:15 <dustin`> shapr: Hi there!
10:20:35 <shapr> dmitri83: Haskell can put more complexity into 9 lines than some languages can put into 9 pages.
10:21:11 <dmitri83> shapr: ok, could you look here ? http://webloria.loria.fr/~jfmari/Cours/em.ps.gz
10:21:11 <dustin`> Yeah, I try to keep my functions to 5 lines or less
10:21:22 <shapr> dmitri83: I can read nearly any randomly chosen twenty pages of Python code in half an hour and understand it all. Twenty lines of Haskell can take longer than that.
10:22:49 <shapr> There's a very elegant suffix tries implementation in Haskell that's really short, two pages I think. I also think it took me two days to understand it all.
10:23:34 <shapr> dmitri83: what's denombrable?
10:23:43 <shapr> enumerable?
10:23:47 <dmitri83> shapr: countable
10:23:50 <shapr> ah, ok
10:24:05 <dmitri83> shapr: damn, is it in french ?
10:24:10 <dmitri83> shapr: sorry
10:24:15 <shapr> oui, c'est ca
10:24:28 <shapr> mais, je lis un peu français :-)
10:24:35 <dmitri83> shapr: but you seem to understand it :)
10:24:40 <dmitri83> shapr: ah ok
10:25:21 <shapr> peut-etre je peux liser cette peu français..
10:25:24 <dmitri83> shapr: please read pages  12-14
10:26:06 <dmitri83> shapr: in fact all you need to understand what \delta means
10:26:25 <dmitri83> shapr: the algorith is actually maximisation of \delta
10:26:57 <dmitri83> shapr: is it ok ? I can look for an english explainantion of algorithm
10:28:52 <shapr> urf
10:28:58 <dmitri83> shapr: here's the same thing in english: http://webloria.loria.fr/~jfmari/Cours/dea3.ps.gz
10:29:01 <shapr> I think I would do better with english or swedish.
10:29:03 <dmitri83> shapr: pages 9-13
10:29:17 <shapr> Though I admit, this is nicely written, and has nifty pictures.
10:29:31 <dmitri83> shapr: sorry, I do not longer remember whether I read something in English or in French :)
10:29:44 <shapr> heh, it's ok. That's started happening to me with Swedish.
10:29:55 <shapr> talar du svenska? =)
10:30:03 <dmitri83> no
10:30:35 <shapr> I speak zero russian.
10:31:07 <shapr> maybe one day I'll learn it, but I have other languages to learn before that.
10:31:07 * esap doesn't have that problem, I rarely read anything in Finnish :-)
10:31:11 <CosmicRay> ha.  My 4-word Russian vocabulary is so much better. :-)
10:31:13 <dmitri83> I knew a Swede who spoke russian almost indistinguishably from a real Russian
10:31:35 <shapr> dmitri83: um, this is also french.
10:31:38 <dmitri83> CosmicRay: 4-letter ? :)
10:31:38 <tuomov> I also use english a lot more than finnish
10:31:55 <dmitri83> shapr: no, viterbi algorith is in english, it is all mixed up :)
10:31:57 <shapr> Chaîne de Markov =)
10:32:05 <CosmicRay> dmitri83: da, nyet, glasnost, perestroika :-)
10:32:10 <shapr> nice graphics...
10:32:18 <dmitri83> shapr: go directly page 9
10:32:18 <shapr> what's an escradrille again? 
10:32:20 <shapr> I used to know.
10:32:28 <marcot> Hello, I know is a off-topic, but what's the name of a chess piece, like a knight, or a king? Is it piece?
10:32:34 <dmitri83> shapr: mmm, a set of airplanes :)
10:32:38 <shapr> really??
10:32:44 <dmitri83> marcot: figure ?
10:32:51 <Igloo> piece
10:32:54 <shapr> marcot: I'd just say a chess piece.
10:33:46 <dmitri83> shapr: squadron, in English
10:33:58 <stepcut> I usually refer to it as "My tool for bringing shame and humiliation to your family name"
10:34:00 <dmitri83> CosmicRay: how could you forget sputnik ?
10:34:07 <CosmicRay> dmitri83: doh, of course
10:34:08 * marcot getting confused..
10:34:10 <shapr> Huh, this is interesting. This is much like a strange combination of HMM and Bayesian statistics.
10:34:13 <CosmicRay> dmitri83: and Leika? :-)
10:34:15 <marcot> In portuguese, the exact translation is piece.
10:34:22 <dmitri83> shapr: what are you reading ? EM ?
10:34:25 <CosmicRay> marcot: I'd say piece in English
10:34:25 <shapr> stepcut: haha!
10:34:27 <marcot> But I think that in english it can be different.
10:34:31 <CosmicRay> marcot: more rarely, player
10:34:34 <shapr> dmitri83: I'm reading page 10
10:34:36 <dustin`> marcot: It is a set of atomic facts that you will not be able to describe precisely through language, so you might as well not try.
10:34:38 <dmitri83> CosmicRay: Laika. it is not a common noun
10:34:40 <marcot> CosmicRay: shapr: Ok.
10:34:53 <shapr> dmitri83: what do you mean am I reading EM?
10:34:55 <marcot> Thank you all.
10:35:01 <shapr> marcot: bien sur!
10:35:03 <shapr> pas de problem!
10:35:03 <marcot> Is just for naming the module.
10:35:21 <marcot> shapr: De nada <- portuguese.
10:35:23 <shapr> vi har ingen kaniner. 
10:35:38 <shapr> de rien <- french
10:35:53 <dmitri83> shapr: there's description of EM (expectation-maximisation) algorithm in these slides
10:35:54 <shapr> ingen kaniner <- zero rabbits (in swedish)
10:36:16 * shapr isn't really sure how having zero rabbits relates to anything else discussed, but hey...
10:36:21 <stepcut> hrm, I am downloading a track titled 'Mama ga santa ni kisu wo shita' -- I hope it's what I think it is :)
10:37:43 <shapr> this is a neat algorithm.
10:38:04 <shapr> hej bringert!
10:38:12 <shapr> är du i pod nu?
10:38:18 <shapr> eller ut? =)
10:38:18 <stepcut> shapr: what does the algorithm do ?
10:38:58 <shapr> viterbi appears to maximize hidden markov models.
10:39:21 <dmitri83> stepcut: the link is http://www.loria.fr/~jfmari/Cours/dea3.ps.gz. it finds the best sequence of hidden states corresponding to given sequence of observations
10:39:32 <shapr> sort of like a seriously kickass bayesian statistics algo
10:39:37 <stepcut> cool
10:39:56 <stepcut> I have only used markov chains for music generation
10:40:06 <stepcut> ack, it's upside down!
10:40:21 <psi> shapr: ingen kanin, inga kaniner
10:40:38 <shapr> psi: ah, tack
10:40:47 <dmitri83> stepcut: seascape thing :)
10:40:52 <shapr> Hej, Jag heter Inga Kaniner.
10:40:55 * shapr cackles
10:41:00 <psi> hehe
10:41:17 <dmitri83> shapr: so, you got the idea ?
10:41:31 <shapr> I'm not sure yet.
10:41:38 <stepcut> good thing I have a laptop ;)
10:41:53 <shapr> I've never had a tight grasp on HMMs, so I'm having to figure them out at the same time.
10:42:06 <dmitri83> shapr: look at the picture, it becomes really straightforward
10:42:37 <dmitri83> shapr: you can think about the algorith as a dynamic programming task, without taking into account its HMM origin
10:43:24 <tuomov> there's just the transition density f(x_{i+1}|x_i) and the measurement density f(y_i|x_i), and you have to find the most likely {x_i} sequence from {y_i}
10:43:32 <dmitri83> shapr: we need to find the sequence of states (vertical) such that a product of of state transition probs and observation probs would be maximum
10:43:34 <shapr> In that case, you should check Rabhi and Lapalme's "Algorithms in Haskell" book. They have some neat generalize dynamic programing problem solving code.
10:43:58 <shapr> I think I understand it.
10:44:01 <dmitri83> shapr: wait, it is very simple, no need to look for a textbook :)
10:44:15 <shapr> everything is simple once you understand it ;-)
10:44:17 <dmitri83> ok, now look at the code I pasted before
10:44:44 <dmitri83> it has the function delta (the delta from the slides)
10:45:01 <shapr> oh, I think I get it.
10:45:58 <dmitri83> shapr: in fact, in my code I do not return the maximum sequence, I just return a list of pairs (\delta_T(v), optimal_path_ending_in_v) for all states v
10:46:10 <shapr> um
10:46:17 <shapr> can you give me some sample inputs?
10:46:36 <dmitri83> shapr: no
10:47:05 <dmitri83> shapr: I should have typed in at least the examples from the slides
10:47:31 <dmitri83> you want to somehow step through it ?
10:47:38 <shapr> yes
10:47:59 <shapr> basically, I'd write a unit test, and then I'd madly refactor to look for a more elegant solution.
10:48:30 <dmitri83> shapr: ok, I'll use the numbers from the example on the slides
10:51:22 <CosmicRay> shapr: this monad tutorial is really excellent.
10:51:30 <shapr> if I understand viterbi corretly, it looks like a combination of fold and filter.
10:51:47 <CosmicRay> shapr: so many of them are written assuming I've had some sort of class where I know what these various symbols I've never seen anywhere else mean :-)
10:51:48 <shapr> CosmicRay: truly it is, I begged the guy to write an arrows tutorial after I finished reading this one.
10:51:59 <CosmicRay> this tutorial has ACTUAL CODE in it!
10:52:05 <shapr> yes!
10:52:06 <shapr> and pictures!
10:52:11 <CosmicRay> grin
10:52:15 <Nioate> I guess *** Exception: <<loop>> means my structure is too cyclic
10:52:28 <CosmicRay> I don't know why, but it seems like so many Haskell tutorials, papers, etc. are from people that don't actually write code
10:52:29 <Igloo> No, it means your code went into an infinite loop
10:52:36 <CosmicRay> or don't really intend to show me how to
10:52:44 <CosmicRay> the Simons are different though :-)
10:52:49 <Nioate> Igloo: :(
10:53:35 <CosmicRay> speaking of which, is there some switch I can give ghc so that the rts in my compiled program automatically has a size limit of, say, 400MB?
10:53:38 <shapr> CosmicRay: yes, I'm definitely in the applied camp
10:53:43 <CosmicRay> I hate having to give +RTS args
10:54:08 <jadrian> CosmicRay: shapr: which monad tutorial is that?  "All about monads"?
10:54:09 <shapr> less talks, more code!
10:54:15 <CosmicRay> jadrian: yes
10:54:24 <jadrian> thought so :)
10:54:30 <CosmicRay> even "what the hell are monads" wasn't all that enlightening
10:54:34 <CosmicRay> despite its earthy-sounding name :-)
10:55:21 <CosmicRay> shapr: yes.  give me code and I can either figure out how/why it works, or pester you until I do :-)
10:55:43 <shapr> I think I'll have to write an arrows tutorial based on that monad tutorial.
10:55:59 <shapr> I'm sure I'll understand arrows by the end of writing such a doc.
10:56:01 <CosmicRay> shapr: please do.  that's another area of haskell that's completely foreign to me
10:56:06 <CosmicRay> heh
10:56:09 <jadrian> I still don't know all I want about them, I need to practice more monad transformers, making my own monads, and understand stuff like (->) as a Reader Monad
10:56:26 <CosmicRay> I hate those modules where the GHC docs say "Based on an implementation in some book published in France in 1993", and nothing else
10:56:32 <shapr> heh
10:56:48 <jadrian> CosmicRay: that makes 2 of us :)
10:56:49 <CosmicRay> I think arrows is one such :-)
10:57:10 <shapr> Arrows has some good papers, it's just that very people undertand them.
10:57:20 <shapr> er "very few people understand them"
10:57:24 <CosmicRay> yeah I feel a little bad about my Control.Monad.Error rant, but geez, it's one of the worst offenders.  It gives us an *e-mail address* and some guy's personal homepage and nothing else
10:57:52 <jadrian> I've just used arrows for point free definitions so far
10:58:06 <shapr> arrows are a much shorter jump from monads than the jump from OOP to monads, but right now, there aren many people who can intelligently discuss arrows.
10:58:09 <jadrian> (a specific instance of arrows)
10:58:10 <CosmicRay> shapr: yeah, I find it very difficult to understand a lot of the papers out there about haskell.  
10:58:31 <shapr> CosmicRay: me too, but every time I understand a new paper, I've found a new tool for programming.
10:58:40 <CosmicRay> shapr: I don't know if it's just me or what.  I'm sure I could understand "arrows in a nutshell" without any trouble :-)
10:59:06 <CosmicRay> shapr: half the time I don't even understand what problem they're trying to solve :-)
10:59:19 <shapr> Lenny1729: fromIntegral replace fromInt
10:59:24 <CosmicRay> I really liked one of The Simon's papers on a high-performance webserver written in haskell
10:59:30 <CosmicRay> I wonder if there is code for that anywhere.
10:59:31 <shapr> yah, that one is neat.
10:59:33 <shapr> sure!
10:59:41 <bringert> I would think that the hard part is not understanding a well-written paper, but writing it
10:59:44 <shapr> there're even various extensions to that webserver.
10:59:49 <Nioate> shapr: do you know of any useful instances of Arrow other than (->) ?
10:59:50 <CosmicRay> really
11:00:06 <CosmicRay> I was thinking of melding it with hs-plugins and adding Gopher support.
11:00:29 <shapr> Nioate: yah, but anything I can say about it is inferior to Ross Paterson's chapter in Fun of Programming that discusses arrows.
11:00:30 <Igloo> I should have seen that oen coming
11:00:34 <CosmicRay> Igloo: heh
11:00:41 <shapr> Nioate: that chapter is online, freely available.
11:00:51 <CosmicRay> Igloo: everywhere I go, people seem to associate me with Gopher for some reason :-)
11:01:01 <shapr> CosmicRay: I think it's because you're the last user.
11:01:06 <CosmicRay> heh
11:01:27 <CosmicRay> shapr: actually we have about 4 or 5 different gopher servers now, including mod_gopher for apache
11:01:28 <shapr> s'okay, people associate me with haskell, monads, or arrows depending on their level of understanding.
11:01:42 <CosmicRay> shapr: I also enjoy my Gopher-to-WAP gateway :-)
11:01:47 <shapr> sick!
11:01:56 <CosmicRay> shapr: starting this morning, I associate you with beer :-)
11:02:04 <shapr> haha
11:02:20 * CosmicRay has reached enlightenment
11:02:20 <shapr> see, that's the last level of understanding =)
11:02:25 * shapr laughs
11:03:03 <stepcut> The last gopher link I sent was for 'cshell considered harmful' sometime last year..
11:03:07 <CosmicRay> shapr: my ultimate goal is to rewrite both OfflineIMAP and PyGopherd in Haskell
11:03:08 <shapr> CosmicRay: hey, think you can come to the next ICFP? I'll buy you a beer if you show up :-)
11:03:16 <CosmicRay> stepcut: ah, that was probably to a document on my server :-)
11:03:24 <CosmicRay> shapr: where/when is it?
11:03:34 <shapr> estonia, next summer.
11:03:45 <stepcut> CosmicRay: could be
11:04:42 <shapr> dmitri83: Viterbi looks to me like a complicated version of fold and filter. I think you could make a version that give lazy output as it is given more inputs.
11:05:03 <CosmicRay> stepcut: hmm nope I have the goto harmful one but not the csh one.  I will have to rectify that. :-)
11:05:57 <CosmicRay> shapr: is there a link for icfp2005?
11:07:02 <shapr> probably
11:07:04 <shapr> hoi Remco 
11:07:12 <creichen> http://www.cs.luc.edu/icfp/
11:07:16 <dmitri83> dmitri83: wow, didn't understant a word, but sounds great :)
11:07:25 <stepcut> CosmicRay: Makefile considered harmful is a good read
11:07:25 <CosmicRay> creichen: I found that but I couldn't seem to find even event dates
11:07:29 <CosmicRay> stepcut: heh
11:07:37 <Remco> hoi
11:07:37 <Remco> :)
11:07:45 <shapr> Remco: how's code?
11:07:50 <stepcut> CosmicRay: actually it's, '*Recursive* make considered harmful'
11:07:54 <CosmicRay> creichen: if I didn't know better, I'd think that icfp05 was vaporware
11:07:58 <dmitri83> shapr: unsuprisingly, my realisation worked correctly 
11:07:59 <CosmicRay> stepcut: ah.  I can see that one
11:08:09 <creichen> CosmicRay: :-)
11:08:11 <stepcut> CosmicRay: it altered my makefile style
11:08:22 <dmitri83> shapr: well, the first run did not succeed due to mistype
11:08:29 <Remco> eh, you probably think I am another Remco but anyway, its bad :P
11:08:36 <shapr> dmitri83: do you have unit test inputs?
11:08:49 <CosmicRay> stepcut: my Makefile style is generally to use obscure features of gnu make so that I have no need for autoconf :-)
11:09:05 <shapr> Remco: you're the only remco I've seen on #haskell.
11:09:25 <Remco> oh ok :)
11:09:41 <creichen> BTW, do any of you know some good reference to how one determines the rank of rank-n polymorphism, whether typing and/or inference are decidable etc.?
11:10:07 <CosmicRay> well.  this is a new record for the US postal service.  They actually have tracking information for my pacakge available before it is finally delivered.
11:10:13 <shapr> creichen: I've seen discussion of that on the mailing lists a year or so ago.
11:10:18 <dmitri83> shapr: yes, look at the paste page for the new version
11:10:46 <creichen> shapr: OK, thanks; I'll see whether I can find that.
11:10:50 <shapr> greetz Si\ 
11:10:57 <Lenny1729> Does anybody know whats wrong in the following lines?
11:11:07 <Si\> hello
11:11:07 <Lenny1729> legendre :: (Integral a, Fractional a) => a -> a -> a
11:11:07 <Lenny1729> legendre 0 x = 1
11:11:07 <Lenny1729> legendre 1 x = x
11:11:07 <Lenny1729> legendre (i+1) x = (2*i+1)/(i+1)*x*(legendre i x)-i/(i+1)*(legendre (i-1) x)
11:11:27 <dmitri83> shapr: btw, what do you min by _unit_ test inputs ?
11:11:49 <vegai> can't have (i+1) as a pattern, perhaps?
11:12:08 <vegai> oh, you can
11:12:10 <shapr> I use HUnit to write unit tests to check the correctness of my code. Then I can energetically hack on the code and still trust that it works.
11:12:13 <vegai> cool :_)
11:12:16 <Igloo> Lenny1729: Your problem is probably that you want to use Int but that it isn't Fractional
11:12:18 <Lenny1729> *g*
11:12:24 <stepcut> vegai: you can, but it is frowned upon by some
11:12:49 <vegai> yeah, it's a bit confusing
11:12:54 <Igloo> You probably need to look at fromIntegral
11:12:56 <vegai> or easily might be
11:13:09 <Lenny1729> @Igloo, I call this func with  "legendre 2 4" and it says ERROR - Unresolved overloading
11:13:09 <Lenny1729> *** Type       : (Fractional a, Integral a) => a
11:13:09 <Lenny1729> *** Expression : legendre 3 4
11:13:10 <lambdabot> Sorry, I don't know the command "Igloo,", try "lambdabot: @listcommands
11:13:15 <dmitri83> shapr: ok, that is all nice, I've just put a call to function "viterbi1" and the output it should yield
11:13:46 <dmitri83> shapr: of course it is not exhaustive, but for such a simple algorith I think it will do
11:14:04 <dmitri83> shapr: now, revenons  nos moutons
11:14:32 <dmitri83> shapr: to my mind this code does not looks like "experienced haskell programmer"-style code
11:14:55 <shapr> dmitri83: right, I'd switch it to using fold and filter if my understanding of the algorithm is correct.
11:14:55 <dmitri83> shapr: how would you rewrite it ?
11:15:40 <dmitri83> shapr: could you please write your implementation based on this idea ?
11:16:30 <shapr> maybe... I was actually working on some code for my application "Fermat's Last Margin"
11:16:46 <Lenny1729>  legendre fromIntegral 3 fromIntegral 4   doesnt work either
11:17:15 <creichen> Meanwhile, I'm trying to get what I believe to be a rank-2 polymorphic type to do something useful, while failing spectacularly...
11:17:23 <shapr> dmitri83: have you used fold and filter in Haskell?
11:17:53 <dmitri83> shapr: I know that they exist :)
11:17:58 * shapr grins
11:18:05 <creichen> The type is "data Polylist = Cons (forall a. Show a => a) Polylist | Nil", but I can't seem to use 'Cons'... any ideas?
11:18:40 <dmitri83> shapr: I even used "foldr maxPair l" instead of "maximumBy cmpPair l" in the first verion of this function
11:19:25 <dmitri83> shapr: as for filter, isn't it the same as [ x | x <- l, p x] ? I like this mathematical-like notation
11:19:48 <dmitri83> shapr: so, what is so special about fold and filter ?
11:20:07 <shapr> just that they're idiomatic Haskell, and they're good for lazy list ops.
11:20:50 <dmitri83> is it considered a good style to use fold and filter instead of list comprehensions ?
11:20:53 <shapr> My Haskell code usually starts out being large and fuzzy, and then turns into lots of special cases or general cases of Prelude functions. That's when I know my refactoring is really getting somewhere.
11:21:16 <shapr> I think it's your choice. If you like the mathematical-like notation, then you should use it.
11:21:43 <bringert> creichen: doesn't that mean that you have to give Cons a polymorphic value?
11:22:00 <bringert> i.e. some thing of the type (forall a. Show a => a)
11:22:05 <dash> shapr: question! do you know why they took out monad comprehensions
11:22:28 <jadrian> dash: to simplify error messages I think
11:22:29 <dmitri83> shapr: but what about the readability of my version ? could you understand what it does ?
11:22:43 <shapr> Not really, Pseudonym explained it to me once, but that happened before I got into Haskell.
11:22:44 <dmitri83> shapr: I mean, I woudln't tell you that it is Viterbi algo
11:23:17 <shapr> no, I probably wouldn't understand what it does. But I may not be a qualified editor of Haskell source =) 
11:23:19 <dmitri83> shapr: if I wouldn't*
11:23:35 <dmitri83> shapr: ok, let's say it differently
11:24:01 <creichen> bringert: My interpretation was that it would be a value of any type a such that a provides 'Show'... I guess that would be an existential type, not a universal one.
11:24:17 <dmitri83> shapr: what would you say about the author of that code if you woudl be the maintainer of the program which contains this code ? ;)))
11:24:44 <creichen> bringert: Good point... can there be a value of the type I described in the first place?
11:25:10 <jadrian> dash: http://www.mail-archive.com/haskell%40haskell.org/msg14689.html
11:25:16 * shapr thinks about that
11:25:34 <jadrian> dash: "(...)Because nave users were getting too many perplexing 
11:25:34 <jadrian> error messages about monads and functors when they thought they were just manipulating lists."
11:25:39 <bringert> creichen: _|_
11:25:56 <bringert> which is a silly answer
11:26:45 <shapr> dmitri83: I think I'd float the defs in the where clause up to top level, I'd turn mulFst into an anonymous lambda, and maybe cmpPair too. I think I'd also make sure it works on lazy lists.
11:27:32 <shapr> dmitri83: I think I'd cut it into smaller pieces, so I could understand each piece more easily.
11:28:12 <jadrian> "<dmitri83> is it considered a good style to use fold and filter instead of list comprehensions ?"  How do you do folds with list comprehensions?
11:28:47 <shapr> jadrian: well, what do you think of the code at the bottom of HaskellIrcPastePage?
11:29:11 <dmitri83> jadrian: sorry, forget about fold
11:29:23 <shapr> fold was my suggestion anyway :-)
11:29:39 <jadrian> shapr: let me see...
11:30:09 <Remco> hmm does anyone know how to extract a part from a string ? ie I want to extract the decimal number in the string "aaa123aaa" :P. I was messing around with the function isDigit, but my function seems to get too complex and I suppose there must be an easier way like -- take 3 till 5 "aaa123aaa" -- which would give me "123"
11:30:16 <shapr> dmitri83: one thing that will help is to use type synonyms
11:30:19 <jadrian> shapr: the one by "Dmitry Sustretov "?
11:30:26 <shapr> jadrian: yes
11:30:50 <dmitri83> shapr: what is type synonims ? data Type1 = Type 2 ?
11:30:55 <shapr> Remco: takeWhile isDigit ?
11:31:08 <Remco> hmm
11:31:18 <shapr> dmitri83: yes, significant names in the type signature can be very helpful when reading.
11:31:20 <Remco> let me see, thanks for the suggestion
11:31:31 <monochrom> takeWhile isDigit . dropWhile (not.isDigit)
11:31:57 <jadrian> shapr: not sure what do think... am I supposed to fully understand it?
11:32:01 <creichen> bringert: I guess you're right ;-)
11:32:08 <shapr> dmitri83: type State = Int ; viterbi1 :: (Num a, Ord a) => [a] -> [[a]] -> [[a]] -> [State] -> [(a, [State])]
11:32:14 <dmitri83> shapr: that would be "data Vector a = [a]" and "data Matrix a=[[a]]"
11:32:17 <jadrian> shapr: I don't know what viterbi is...
11:32:19 <creichen> bringert: Thanks for the explanation, anyway!
11:32:27 <shapr> jadrian: s'okay, I didn't either =)
11:32:28 <Remco> ok, that was a great suggestion, thanks shapr and mono :) will mess a bit more with that :D
11:32:40 <jadrian> shapr: ah :)
11:33:05 <dmitri83> jadrian: viterbi algorithm, in fact I am implementing the folllowing: http://www.loria.fr/~jfmari/Cours/dea3.ps.gz, pages 9-13
11:33:19 <shapr> monochrom: btw, your alternate history of the world of programming from yesterday was hysterically funny :-) 
11:33:24 <shapr> quite nifty
11:33:38 <monochrom> Glad you enjoy it.
11:33:50 <shapr> Who knows, maybe in that world I would one of the few members of the procedural resistance.
11:33:53 <jadrian> dmitri83: thanks
11:35:17 <jadrian> dmitri83: just to make sure, is this really what you want?  "cmpPair x y = if fst x < fst y then LT else GT"
11:35:29 <shapr> It's also interesting to note that GC and schedulers are orthogonal, one emulates infinite space, and one infinite processors.
11:35:33 <creichen> So how do I express an existential type such that "(Cons 1 (Cons "foo" Nil))" is well-typed because the types of '1' and '"foo"' are in typeclass 'Show'? (The idea here would be that the only useful thing I could do with the elements of such a list would be to 'show' them).
11:35:57 <jadrian> dmitri83: because you'll have (a,b) < (a,b)
11:36:36 <jadrian> dmitri83: that is (a,b) Less Than (a,b)
11:36:42 <shapr> I'd use \(x1,_) (x2,_) -> x1 < x2 in place of cmpPair
11:36:52 <stepcut> creichen: http://homepages.cwi.nl/~ralf/HList/
11:37:13 <stepcut> creichen: not exactly the answer to your question, but related...
11:37:44 <dmitri83> shapr: aha, thank, I jsut did not know how to write it in a more compact way
11:37:54 <shapr> dmitri83: In any case, I hope I gave you some useful ideas for more idiomatic Haskell code.
11:37:57 <dmitri83> jadrian: it doesn't matter, in fact
11:37:58 <jadrian> shapr: he needs the value in Ordering to use in maximumBy
11:38:05 <shapr> ohh
11:38:22 <shapr> I think that can be simpler...
11:38:42 <jadrian> yeap
11:38:51 <shapr> x `compare` y ?
11:38:54 <creichen> stepcut: OK, thanks in any case-- this does look interesting :-)
11:39:08 <shapr> yah, I think that'll work.
11:39:19 <jadrian> shapr: not sure, at least the semantics would be different from the current one
11:39:30 <shapr> it assumes that tthe first component of a tuple is *always* more significant though.
11:39:37 <dmitri83> jadrian: I could use "foldl (\(x,_) (y,_) -> x < y) l"
11:39:40 <jadrian> shapr: but I guess it wouldn't make a difference
11:39:51 <jadrian> shapr: but!!
11:39:58 <shapr> ??
11:40:20 <jadrian> shapr: cmpPair x y = x `compare` y    is just  cmpPair = compare
11:40:35 <jadrian> shapr: and maximumBy compare  is just   maximum :)
11:40:58 <shapr> true
11:41:02 <jadrian> so if that's ok he can get rid of the  cmpPair  
11:41:06 <jadrian> and just use maximum
11:41:53 <dmitri83> jadrian: sorry, but how do you make "maximum" work with pairs, and using the given comparison function ?
11:42:08 <shapr> dmitri83: it already does that by default.
11:42:18 <jadrian> dmitri83: maximum :: forall a. (Ord a) => [a] -> a
11:42:34 <jadrian> dmitri83: it works for all types with instances of Ord
11:42:48 <dmitri83> jadrian: pairs are not in Ord 
11:42:54 <jadrian> dmitri83: yeap they are
11:43:22 <jadrian> dmitri83: it assumes the first elements are the most significant ones
11:43:38 <shapr> mulFst could be \(x1,y) (x2,_) -> (x1*x2,y)
11:44:30 <dmitri83> jadrian: ok, you are right, in my case I don't care that (1, [1, 2, 3]) > (1, [1, 2]) = True...
11:44:53 <shapr> I've wanted to hack up some speech recognition code in Haskell, this is a good place start.
11:45:48 <dmitri83> shapr: but wouldn't it be unreadable with anonymous lambda ?
11:46:04 <shapr> In many cases, a lambda is more readable.
11:46:50 <shapr> Wow, georgina verbaan joins the web certification trend.
11:46:54 <dmitri83> shapr: so, you think that
11:46:55 <dmitri83> shapr: res = maximum [\(x1,y) (x2,_) -> (x1*x2,y) (delta (t-1) u) (a !! u !! v) | u <- [0..nstates-1] ]
11:47:01 <dmitri83> shapr: is nicer ?
11:47:09 <shapr> I'm not sure.
11:47:28 <shapr> nah, maybe not :-)
11:48:48 <dmitri83> shapr: also, you've said that I should move the second "where" clause up one level, but then it would not work
11:49:01 <dmitri83> shapr: what I am gtting wrong ?
11:49:19 <shapr> what does l do?
11:50:55 <shapr> Right now, I'm not sure how I'd refactor it. I'll have to think about it.
11:51:00 <shapr> Will be around tomorrow?
11:51:16 <dmitri83> l is a list of pairs where first element is a term to maximize form formula (4) on page 12 and the second is the correspnding partial states sequence
11:51:18 <shapr> um "will you be around tomorrow?"
11:51:48 <dmitri83> shapr: most probably I will, 'cause I'm curious :)
11:51:57 <shapr> heh, ok
11:52:11 <dmitri83> somewhere around 15-16 PM CET
11:52:22 <dmitri83> somewhen*
11:52:27 <shapr> I'm going to go back to Fermat's Last Margin, since it's nearing completion, but I'll be here tomorrow.
11:52:52 <dmitri83> shapr: what is FLM ?
11:53:15 <jadrian> <shapr> mulFst could be \(x1,y) (x2,_) -> (x1*x2,y)
11:53:20 <shapr> it's a distributed research paper margin notes system. It uses a wiki and a source control system.
11:53:37 <jadrian> it doesn't really look better than yours, anyway since you talked about arrows
11:53:51 <jadrian> shapr: uncurry (***) . ((*) *** const)   <- would do to :)
11:54:11 <shapr> dmitri83: I make lots of notes in the margins of the papers I read, I think a research paper should be an active discussion. I wish I could read the margin notes that others make.
11:54:36 <jadrian> shapr: (uncurry (***) . ((*) *** const))  (2,2) (3,4)
11:54:45 <dmitri83> shapr: ok. and you're developing a system to make margin notes
11:54:46 <jadrian> shapr: (6,2)
11:54:49 <shapr> if you remember the story, Fermat's Last Theorem didn't fit into the margin of the book he was reading.
11:55:03 <kristnjov> hah yeah
11:55:21 <shapr> So if he had my application, it would be the last margin he would ever need :-)
11:55:38 <shapr> here's my 'napkin prototype' for FLM - http://www.scannedinavian.org/RandomWiki/AnnotationMockup
11:55:42 <dmitri83> shapr: nice legend for the software system :)
11:55:54 * shapr grins
11:57:03 <shapr> the idea is simple, imagemagick can turn a ps or pdf file into one image per page, so you stick those pictures into their own wiki page, and let people make and distribute their notes.
11:57:51 <shapr> jadrian: I rather like your arrow solution. It's not smaller, but it sure is cute.
11:57:57 <dmitri83> shapr: ok, I am waiting imapatiently for the refactored version
11:57:58 <dmitri83> :)
11:58:04 * shapr grins
12:00:13 <jadrian> shapr: eh :)
12:02:43 <stepcut> what's the best way to generate xml these days? HaXmL ? HXML ? _______ ?
12:03:00 <stepcut> I want to turn a record into an xml document
12:03:36 <Muad_Dibber> my teachers for Generic Programming seemed to like HaXml
12:04:11 <kosmikus> you're from Utrecht?
12:04:35 <Muad_Dibber> yup
12:04:37 <Muad_Dibber> well
12:04:37 <Muad_Dibber> no
12:04:40 <Muad_Dibber> but i study there
12:05:17 <kosmikus> Muad_Dibber: when did you take GP?
12:05:22 <Muad_Dibber> andres? :)
12:05:25 <kosmikus> yes
12:05:32 <Muad_Dibber> last period 
12:05:36 <Muad_Dibber> so i listened to your lectures
12:05:38 <kosmikus> who are you?
12:05:43 <Muad_Dibber> raymon
12:05:55 <kosmikus> ok
12:06:27 <kosmikus> nice to see you're Gentoo as well
12:06:42 <Muad_Dibber> coincidental to meet you here :)
12:07:06 <Muad_Dibber> well yeah, Gentoo is nice
12:07:18 <Muad_Dibber> especially since it runs native on amd64 too
12:07:52 <kosmikus> yes, I'm quite busy nowadays patching ebuilds to make them run on amd64, too
12:08:13 <Muad_Dibber> you happen to have ghc to work?
12:08:35 <kosmikus> ghc-bin does
12:09:00 <kosmikus> and ghc does as well (unregistered, still), but there's a small bug in the current ebuild
12:10:26 <kosmikus> bug 58588, but you might already be aware of that one
12:11:41 <Muad_Dibber> well not really, it just didnt work at all yet
12:11:44 <Lenny1729> Could somebody explain to me why: test1 i = (i-1)/3  works but     test2 (i+1) = i/3    doesnt
12:12:18 <Muad_Dibber> and i have been busy with my course so i havent had that much time
12:13:53 <kosmikus> Muad_Dibber: you should at least be able to ACCEPT_KEYWORDS="~amd64" emerge dev-lang/ghc-bin
12:14:03 <dmitri83> shapr: are you still here ?
12:14:50 <Muad_Dibber> doing so kosmikus 
12:15:27 <shapr> dmitri83: I'm still still here, I'm working on FLM.
12:16:42 <kosmikus> Lenny1729: n+k patterns work only for types in class Integral, afaik
12:19:09 <Muad_Dibber> kosmikus, does GH work on amd64 as well? 
12:25:42 <shapr> Man, this global variables discussion on the mailing lists is like watching intellectual boxing.
12:27:07 <shapr> Maybe tag team wrestling is more accurate. Lennart Augustsson tags Simon Marlow, who immediately does a suplex on George Russell! You can see Keean Schupke's horrified expression from all the way up here!
12:30:34 * shapr goes unicycling to consider design issues
12:32:05 <kosmikus> Muad_Dibber: I never tried
12:33:04 <kosmikus> Muad_Dibber: I only have access to an amd64 machine for a few weeks now, and there've been applications with a supposedly larger audience I had to test
12:33:37 <kosmikus> Muad_Dibber: otoh, I'd be surprised if it wouldn't work -- it doesn't use anything strange or platform-specific, should all be portable code
12:33:54 <Muad_Dibber> kosmikus: so you're saying Gh doesnt have a large audience? ;)
12:34:24 <kosmikus> I said there are things that have a larger audience ;)
12:34:33 <Muad_Dibber> aah 
12:34:36 * Muad_Dibber hushes
12:35:40 <kosmikus> I believe GH could have a larger audience if it would be maintained better (yes, that'd be my job), and advertised more often
12:36:43 <Muad_Dibber> well 
12:36:44 <kosmikus> the relative success of things like "Scrap your boilerplate"-generics shows that generic programming in Haskell is of interest to people, if it is readily available in GHC and easy to use
12:38:04 <Muad_Dibber> it would be quite usefull
12:38:14 <Muad_Dibber> it would of course need to be maintained
12:38:31 <Muad_Dibber> but as you yourself i think also pointed out there might be some nice sugar added
12:39:00 <kosmikus> nice sugar such as/
12:39:04 <kosmikus> ?
12:39:27 <bourbaki> moin
12:39:34 <Muad_Dibber> oi
12:39:34 <kosmikus> hi there, bourbaki 
12:39:59 <Muad_Dibber> well there were some things you wanted to implement right? and which also would give problems with backward compatibility?
12:40:14 <kosmikus> yes, I'm busy with it
12:40:34 <kosmikus> in 1.41 (which is in SVN), a lot of things already work
12:41:05 <kosmikus> I got parameterized type patterns working during the course (I think I demo-ed that during one of Johan's lectures)
12:41:20 <kosmikus> last week, I've implemented the new syntax for type signatures
12:41:54 <kosmikus> what's left now is the "extends" syntax for default cases and some generalizations for type-indexed types, but these are already quite advanced
12:42:26 <kosmikus> you can experiment with the first 12 chapters or so of my thesis without any syntax switch now :)
12:42:42 <kosmikus> sorry I've not managed to do that earlier ...
12:44:01 <Muad_Dibber> it's heavy stuff right 
12:44:17 <Muad_Dibber> it's not like i could've done it better and would now complain at you not having finished it earlier :)
12:45:03 <bourbaki> does anyone of you happen to know a paper or something that deals with function graphs? that is where you have functions whoose flow is modeled by a graph to optain a single function?
12:45:32 <kosmikus> the point is that I just had to finish my PhD before, and you don't get a PhD for an implementation, but for a thesis ;)
12:46:00 <bourbaki> kosmikus: what thesis are you writeing for your phd?
12:46:10 <kosmikus> have written
12:46:40 <bourbaki> about what :)?
12:46:50 <kosmikus> www.kosmikus.org/ExploringGH.pdf
12:47:05 <kosmikus> Generic Haskell
12:47:28 <bourbaki> i see
12:47:38 <bourbaki> kosmikus: what uni are you at?:)
12:47:52 <kosmikus> utrecht
12:48:07 <bourbaki> but youre from de?
12:48:21 <kosmikus> Muad_Dibber: also, back then it wasn't clear if I would be employed at uu longer than until mid-october
12:48:21 <Lor> That frame hack is evil.
12:48:31 <Muad_Dibber> kosmikus: and you will be? :)
12:48:49 <kosmikus> Lor: which frame hack?
12:49:19 <kosmikus> Muad_Dibber: only until mid-april, but better than nothing
12:49:55 <Lor> The frame hack at kosmikus.org that redirects to uu.nl.
12:50:08 <Lor> What's wrong with a proper redirection?
12:50:11 <kosmikus> bourbaki: yes (why do you ask, as your guess indicates you already know :)
12:50:27 <musasabi> /c/c
12:50:30 <Muad_Dibber> kosmikus: they cannot give you a longer contract?
12:50:32 <kosmikus> Lor: oh, that one ... don't know why, it's my provider doing that -- cannot influence that
12:50:44 <Lor> (The point is that I just said "snarf <your url>" and got back a tiny html document, and then had to snarf again from the actual frame source.
12:51:09 <Lor> kosmikus, surely you could just give a direct url to uu.nl?
12:51:50 <kosmikus> yes, but that's more likely to change during the next few months, for reasons just discussed
12:52:26 <kosmikus> and, until just now, I didn't even know that it isn't a proper redirection; thanks for pointing that out -- I might suggest that to the provider
12:52:31 <Lor> Ah, you are being considerate to those who will read the log of this discussion years from now. :)
12:52:51 <Muad_Dibber> Lor: you are optimistic
12:52:59 <bourbaki> kosmikus: cause the paper is on a de site :)
12:53:28 <Muad_Dibber> Lor: maybe some gigantic comet will impact on the earth and no logat all is left over to be read :)
12:53:55 <bourbaki> i have seen that some ppl did genetic programming with haskell do some of the happen to know something about the problem i stated earlier?
13:01:14 <kosmikus> bourbaki: actually, the paper is at .uu.nl ?!
13:01:48 <bourbaki> i saw something with andreas loeh. de or so
13:03:21 <kosmikus> arg, why do all the Germans insist to read andres as andreas
13:03:41 <bourbaki> :)
13:03:55 <kosmikus> I mean, the name andres is uncommon in other countries as well, but only the germans keep misreading it
13:04:15 <bourbaki> you always read what you are used to read
13:04:18 <kristnjov> andreas is a name in sweden
13:04:41 <Muad_Dibber> kosmikus, like anybody ever spells my name right :P
13:04:48 <Muad_Dibber> but then again, i'm not famous :)
13:05:18 <kosmikus> kristnjov: yes, but my name is andres, not andreas
13:05:29 <kristnjov> yes, but andreas is a name in sweden
13:05:41 <kristnjov> now i shall sleep
13:05:42 <kosmikus> afaik andres is common in spanish-speaking countries and in estonia, whereas andreas is a name almost everywhere
13:05:55 <Lor> anders is also a swedish name.
13:06:27 <dmitri83> :query shapr 
13:11:55 <Remco> question: if i have a string n = "12122aaaa" and i use -- takeWhile (isDigit) n -- and i want to throw the result in a list r ie: -- (takeWhile (isDigit) n) : r. Which type should the list r be ? (getting type errors :)) I thought [Char] But that doesn't work for r
13:12:28 <Muad_Dibber> [a]
13:12:37 <Remco> [a] ? hmmm
13:12:40 <Muad_Dibber> i think at least
13:12:52 <Muad_Dibber> hmm
13:13:00 <dash> [[Char]], at least
13:13:09 <Remco> ah
13:13:11 <dash> or [String], to spell it differently :)
13:13:14 <Muad_Dibber> yeah
13:13:16 <Remco> well
13:13:17 <Remco> hmm
13:13:18 <Remco> lets see
13:14:39 <Remco> yea, I tried that already, but it gives me the error: "Type [String] does not match [Char]
13:15:10 <Remco> wait
13:15:14 * Remco slaps forehead
13:15:26 <Remco> changed the wrong type %-D
13:15:29 <dash> heh
13:15:33 <Remco> thanks, lets see if it works now :)
13:17:52 <Remco> works like a charm :)
13:18:05 <Remco> how could I be so stupid to not see it was a list of Strings :P
13:25:58 <Muad_Dibber> that is a question that will stay unanswered by the community i guess :P
13:31:59 <Remco> :P
13:41:59 <Muad_Dibber> kosmikus, fyi, GH compiled, i will have a look at the rest another time :P
13:43:59 <jadrian> what is an arrow loop?
13:45:14 <jadrian> I understand what "loop" does (on  "->"  that is)
13:45:24 <jadrian> but have no idea why that is called a loop...
13:45:59 <Janni> G'evening
13:46:29 <Muad_Dibber> evening
14:01:00 <Muad_Dibber> g'night all
14:25:24 <bourdu> haskell rulez :
14:25:30 <GroMeZ> i love haskell
14:25:42 <GroMeZ> what a beautiful language !
14:25:44 <bourdu> haskell is the coolest language in the world
14:25:55 <bourdu> haskellIsCool :: Bool
14:26:05 <bourdu> haskellIsCool = True
14:26:23 <arjanb> heh talking to yourself?
14:26:32 <bourdu> yep
14:26:41 <GroMeZ> yep he like that
14:26:47 <bourdu> love that
14:27:08 <bourdu> haskell pouet
14:27:23 <bourdu> I code haskell with emacs !
14:27:30 <GroMeZ> anybody know Boizumault ?
14:27:41 <bourdu> I know him guy !
14:27:51 <bourdu> This guy is funky !
14:28:08 <bourdu> Nobody's there ?
14:28:21 <bourdu> knock knock
14:28:30 <GroMeZ> ZzzzzzzZzzzzz
14:32:07 <jadrian> that was... different...
14:35:30 <Lemmih> Looks like another case of IRC schizophrenia.
14:36:01 <dash> you mean, where a whole channel hears the voices in his head?
14:47:23 <xerox> how to get a smart indentation in haskell-mode?
14:47:43 <xerox> like, pressing tab indent instead putting a "tab" character
14:48:25 <Lemmih> xerox: M-x turn-on-haskell-indent
14:49:24 <xerox> signum x =
14:49:25 <xerox>     if x < 0
14:49:25 <xerox>        then -1
14:49:25 <xerox> 	    else if x > 0
14:49:25 <xerox> 		 then 1
14:49:27 <xerox> 		      else 0
14:49:30 <xerox> is it the correct indentation ??
14:50:47 <xerox> signum x =
14:50:47 <xerox>     if x < 0
14:50:47 <xerox>        then -1
14:50:47 <xerox>        else if x > 0
14:50:47 <xerox> 	    then 1
14:50:49 <xerox> 	    else 0
14:50:52 <xerox> maybe it is.
14:53:48 <shapr> man I love unicycling.
14:54:05 <shapr> especially in a newly fallen handswidth of snow.
14:54:10 <xerox> and i hate haskell-mode indenting :P
14:54:15 <shapr> me too :-)
14:54:21 <xerox> umpf :(
14:54:37 <shapr> someone said they'd email Peter Thiemann and ask for his haskell-mode, which suppossedly does better indentation.
14:55:04 <xerox> uh, we got it?
14:55:18 <shapr> you got it?
14:55:28 <Pseudonym> BTW, every second discussion here lately seems to be about haskell-mode.
14:55:35 <shapr> g'day Pseudonym!
14:55:45 <Pseudonym> Is it just me, or does it seem more trouble than it's worth?
14:55:46 <Pseudonym> G'day.
14:55:54 <shapr> Hey there was a guy here earlier asking about elegant implementation of Viterbi
14:56:13 <shapr> Soon enough the answer will be "use Yi"
14:56:46 <xerox> mmh..
14:56:47 <Janni> DON'T use Vi
14:56:50 <xerox> that's not good
14:56:52 <Janni> Use Vim
14:57:07 <Pseudonym> No, Yi.
14:57:08 <Pseudonym> Not Vi.
14:57:12 <xerox> umpf :(
14:57:21 <xerox> i'd like to have an haskell-mode in emacs!
14:57:23 <Pseudonym> But I agree, always prefer vim to vi.
14:57:26 <xerox> a wroking one :P
14:57:39 <shapr> me too
14:57:49 <shapr> but in abscence of that, I'd like to have a multi-threaded emacs.
14:57:55 <shapr> So, why not just fix them both?
14:57:56 <Janni> Oh. Anyway, how can I make ghc-compiled programs not open the dos command-line?
14:58:25 <shapr> Lor: were you going to ask Peter Thiemann about his haskell-mode?
14:58:32 <shapr> I guess I could send an email myself.
14:58:56 <xerox> please!
14:59:00 <shapr> Lemmih: yay unicycling!
14:59:10 <Lemmih> o_O?
14:59:31 <shapr> I'm getting closer to one-foot. I can almost do one revolution on both sides.
14:59:40 <shapr> My hopping is improving, both sideways and forward.
15:00:15 <shapr> Lemmih: can you jump on the tire yet?
15:00:42 <Lemmih> Nope. I've been training other stuff lately.
15:00:49 <shapr> like what?
15:00:49 <jadrian> Janni: use Linux :D
15:00:53 * shapr bounces
15:01:37 <shapr> Can you ride backwards or idle?
15:01:46 <Lemmih> Driving with out foot is a lot harder then just pendling.
15:02:36 <shapr> Yes, I always lose power when my other foot would be pushing down.
15:03:27 <Lemmih> I'm fairly skilled at backwards driving.
15:04:22 <shapr> I got really frustrated today and I laid down in the snow to chill out. This woman walked past and looked at me very strangely. I wonder whatt it looks like to see a unicycle and a guy lying in the snow next to the path. Probably would have looked like a fatal wipeout except for the pised off expression on my face.
15:05:02 * shapr snickers.
15:05:18 <shapr> Confused looks from passersby always cheer me up.
15:06:22 <shapr> I'll work on backwards driving tomorrow. How's your hopping?
15:06:34 * shapr tries to keep up with Lemmih's uniskillz =)
15:06:47 <Lemmih> I totally suck at jumping.
15:09:05 <Lemmih> But the cold is keeping the kids away so I have the playground all for myself.
15:09:08 <shapr> I can only jump over a curb so far. No higher. I can ride narrow thingies, but not snow covered logs. (ow).
15:09:11 <shapr> Yah, same here.
15:10:08 <Lemmih> Those playground structures are great for jumping.
15:11:01 * esap just wrote three lines of code that proves the Yoneda lemma.
15:11:14 <shapr> Truly, too bad none of the ones around here are low enough for me to jump onto.
15:11:39 <Lemmih> We should exchange video records of our progress.
15:12:02 * psi would like to see a video :)
15:12:03 <shapr> If only I had a video camera =)
15:12:08 <shapr> this is a good motivation.
15:12:18 <shapr> psi: hey, you can drop by and see it in person.
15:12:37 <psi> hehe, i suppose
15:12:37 <shapr> Or I can uni over there and show off.
15:12:44 <esap> newtype NatTrans f g = NatTrans { unTrans :: forall a. f a -> g a} ; evaluate_trans :: NatTrans ((->) a) f -> f a ; evaluate_trans (NatTrans k) = k id ; lift_trans :: (Functor f) => f a -> NatTrans ((->) a) f ; lift_trans a = NatTrans (\f -> fmap f a)
15:13:02 <shapr> psi: Oh I found two guys from Gällivare, one from Haparanda, and one from Umeå, and we'll be invading your city in the summer.
15:13:46 <psi> shapr: what guys?
15:14:07 <shapr> Unicyclists
15:14:20 <psi> ah, cool :)
15:14:24 <shapr> We're planning a summer meeting in Luleå.
15:15:28 <shapr> psi: are you actually from Luleå? or just there for school? Will you be there in the summer?
15:15:35 <psi> i wonder if i could even get a whole meter on a unicycle
15:15:49 <shapr> If you'll be in town I'll bring my 20" training uni.
15:15:59 <psi> shapr: yeah, i've always lived here
15:16:13 <shapr> ah, nifty.
15:16:14 <psi> nice
15:16:28 * shapr googles for the Yoneda Lemma
15:16:40 <stepcut> she's hot!
15:17:37 <psi> gah, no pictures on google images :)
15:18:20 <stepcut> :(
15:18:48 <shapr> http://en.wikipedia.org/wiki/Yoneda_Lemma
15:18:50 <Pseudonym> Isn't Yoneda Lemma a Japanese model?
15:19:18 <Pseudonym> I have a kind of intuition about the Yoneda Lemma, but I don't really understand it.
15:19:49 <Pseudonym> The idea, I believe, is that you should try representing a category in terms of Set, because we understand Set.
15:20:02 <Pseudonym> And that can reveal interesting structure that you can't see just by looking at the original category.
15:20:14 <Pseudonym> In fact, it can tell you what you accidentally left out of the original category.
15:20:22 <Lemmih> shapr: How's your wheelwalking?
15:20:25 <esap> pseudonym: yes
15:20:30 <Pseudonym> So in that sense, it's a discovery tool more than anything else.
15:20:52 <Pseudonym> "Here's the category you think you're studying... but here's what you should REALLY be studying."
15:20:53 <shapr> Lemmih: never tried, is it hard?
15:21:04 <Pseudonym> esap: I'm on the right track?
15:21:05 * stepcut reads more cell phone specs
15:21:08 <esap> pseudonym: it's also used to prove that the categorical semantics of functional programming works.
15:21:18 <Pseudonym> Ah, well, that's handy.
15:21:20 <stepcut> there's a zillion of them, but half are not even implemented!
15:21:44 <Pseudonym> Presumably the representation in Set is something else that we already know about, like denotational semantics or something?
15:22:11 <xerox> shapr, we should start doing this: http://www.abum.com/?show_media=1551&file_type=Movies
15:22:38 <Lemmih> shapr: I've tried it a couple of times but quickly gave up since I made absolutely no progress.
15:23:33 <esap> pseudonym: It basically requires that the set of arrows [there's the set] is small enough.
15:23:43 <Pseudonym> Ah, OK.
15:23:55 <shapr> xerox: impressive
15:24:38 <xerox> it is.
15:24:57 <shapr> I have this feeling that's there's something that's a lot like unicycling, but more symmetrical. I can't tell what it is though.
15:25:07 <Pseudonym> esap: Where can I find this?  I didn't find the explanation in Asperti and Longo particularly enlightening.
15:25:14 <xerox> shapr BOINGS!
15:25:20 <Pseudonym> It assumed, for example, that you already knew the Curry-Howard isomorphism backwards.
15:25:41 <shapr> xerox: truly that looks like a lot of fun. I would definitely have to work up to it though.
15:26:07 <esap> pseudonym: I've been reading Crole: Categories for types. But it's also somewhat dense. But the connection between FP and the yoneda lemma is described pretty well there.
15:26:09 <xerox> it's strange btw, i'm thinking about *who* can teach me something like that
15:26:20 <shapr> xerox: why? teach yourself!
15:26:31 * xerox boings out of the window
15:26:37 <esap> pseudonym: Though actually understanding the yoneda lemma took quite a bit of effort.
15:27:06 <shapr> xerox: ask google for resources, read everything you can about whatever that's called, then teach yourself.
15:27:15 <esap> pseudonym: it basically says that arrows and certain kind of natural transformations are isomorphic.
15:27:19 <shapr> That's how I learned unicycling.
15:27:56 <Pseudonym> OK, thanks for the tip.
15:28:02 <Pseudonym> Right.
15:28:16 <Pseudonym> I have to admit, my intuition on natural transformations could do some work, too.
15:28:24 <Pseudonym> I know what they look like in Haskell.
15:28:57 <Pseudonym> But I think this is an area of category theory that's sorely lacking in intuitive examples.
15:29:16 <esap> pseudonym: yea, intuitive examples are hard to find.
15:29:41 * Pseudonym still thinks there's a book waiting to be written here
15:29:48 <Pseudonym> I even have a working title.
15:29:52 <shapr> I think a lot of CT books are waiting to be written.
15:29:53 <esap> pseudonym: I think the best way to describe natural transformation is as a mapping between functors.
15:29:57 <Pseudonym> Yes.
15:29:59 * Lemmih thinks of the work that needs to be done but decides to watch another episode of Stargate.
15:30:04 <Pseudonym> Well, that's the _right_ explanation.
15:30:10 <shapr> Lemmih:  oh what work?
15:30:17 <esap> pseudonym: But beyond that, it gets more complicated.
15:30:24 <dons> moin
15:30:28 <Pseudonym> My working title is "Abstract Nonsense: Categories for the Armchair Computer Scientist"
15:30:30 <shapr> g'day dons 
15:30:45 <Remco> hmm if I have a number in a string like "1234" and I want to compare it with a real int like "1234" > 9, then what is an easy way to convert my string to a real number to actually be able to check the previous statement ? *prays there is an easy way :P*
15:30:48 * Riastradh likes that title.
15:30:48 <shapr> Pseudonym: what's the opposite of an armchair computer scientist?
15:30:51 <esap> pseudonym: That's a great name for a book :-)
15:30:58 <Pseudonym> shapr: A professional one.
15:31:12 <shapr> If you get paid to write code, does that count?
15:31:23 <shapr> Remco: read "1234" :: Int
15:31:25 <Pseudonym> Do you write code, or do you write papers?
15:31:33 <Pseudonym> And apply for grants?
15:31:39 <Pseudonym> And have graduate students?
15:31:47 <Remco> great shapr :D thanks
15:31:52 * Remco paypals 100 dollars to shapr
15:31:54 <Lemmih> shapr: Work that will hopefully pay my rent.
15:32:04 <shapr> I have been working on some papers, but none of them are worth publishing yet.
15:32:13 <shapr> no grants, no grad students.
15:32:34 <Pseudonym> Right, so you're not a scientist.  Not for a living, anyway.
15:32:41 <shapr> fair enough
15:32:53 <shapr> I'd be willing to try it though.
15:33:12 <Pseudonym> Actually, there's probably a series of books waiting to be written on all sorts of topics for the interested amateur.
15:33:24 <xerox> Remcoin fact read "1234" > 9 should work
15:33:36 <Pseudonym> Pity I have no time.
15:33:36 <xerox> (without :: Int, because of the comparision with an integer)
15:33:38 <Remco> ah okies, thanks for the tip
15:33:50 <xerox> i learnt it today :g:
15:34:13 <Remco> great :D so did I know it seems :P
15:34:14 <shapr> I'd rather write a series on "Abstract Nonsense Applied : How Category Theory can Improve Your Source Code"
15:34:37 <shapr> Too bad I have no clue. ;-)
15:35:20 <shapr> I would like to be a professional computer scientist.
15:36:33 <shapr> Are there any independent labs that do that sort of research?
15:36:54 <shapr> It seems like that whole joining a university thing is painful.
15:37:14 <Riastradh> There's Microsoft Research.
15:37:20 <tuomov> the painful thing is to decide what exactly to concentrate on..
15:37:29 <Pseudonym> You could try R&D, like I do.
15:37:38 <Pseudonym> You don't write as many papers, you do write more code.
15:37:45 <Pseudonym> And you don't have academic politics.
15:37:48 <shapr> How do you get into R&D?
15:37:50 <Pseudonym> Oh, you don't have students either.
15:37:57 * esap thinks the Haskell report is pretty close to describing how abstract nonsense has to be applied.
15:38:03 <shapr> esap: haha!
15:38:13 <Pseudonym> shapr: In my case, your desk at university was next to someone else who is now in R&D.
15:38:40 <Pseudonym> shapr: Actually, that's what I would envisage for the book.
15:38:49 <Pseudonym> You'd spend a lot of time with examples... in code.
15:38:59 <tuomov> I was in a small "R&D" company and it sucked. 
15:39:22 <tuomov> they had no plans of ever doing anything but shit for their only customer
15:39:35 * esap has been in a small company as well. The same experience.
15:39:41 <Pseudonym> Well we have multiple customers and a large US distributor.
15:39:59 <Pseudonym> So we're probably in a better position.
15:40:00 <shapr> My small company delivers high quality projects on time and under budget.
15:40:24 <shapr> The only downside is that we do so well, we often code ourselves out of a job.
15:40:47 <Pseudonym> If you don't mind Erlang, you could apply to Ericsson. :-)
15:40:52 <Pseudonym> THey do R&D.
15:40:57 <shapr> Good point.
15:42:14 <tuomov> I don't think I want to work for a company that doesn't have any products of their own again
15:42:26 <xerox> i need a new workstation, i'm really whipped off by win32, umpf
15:42:31 <tuomov> plain subconstractors are stagnated places
15:42:39 <xerox> donations are appreciated /me blinks
15:43:03 <shapr> The good side of coding yourself out of job is that you get a lot of varied jobs. I do like that part.
15:43:03 <esap> the problem with small companies is that they never had any chance of succeeding.
15:43:20 <Pseudonym> Well, we're in a better position in that regard.
15:43:27 <Pseudonym> Our small company started off as a university research project.
15:43:40 <tuomov> so did the one I was in
15:43:44 <Pseudonym> They're only spinning us off after we start making a profit.
15:43:52 <Pseudonym> And we have enough customers to sustain ourselves.
15:44:22 <tuomov> but they never really had any plans to do any proper research in the end
15:44:32 <tuomov> just delivering crappy software specs to the customer
15:44:38 * Pseudonym nods
15:45:00 <Pseudonym> What did they do?
15:45:08 <Pseudonym> Or at least, what did they make the motions of doing?
15:45:09 <Pseudonym> What field?
15:45:21 <tuomov> "data fusion"
15:45:34 <Pseudonym> Errr...
15:45:38 <shapr> There's a chance we'll get a contract to do an online political literacy webapp. I'm thinking about a haskell server and an XUL client. The guys in Germany sound interested in the idea so far.
15:45:40 <Pseudonym> I'm afraid I don't know what that is.
15:46:34 <tuomov> basically inferring stuff from (large) amounts of data
15:46:41 <tuomov> of course I can't tell the specifics
15:46:46 <Pseudonym> Like data mining?
15:46:51 <Pseudonym> Understood.
15:46:52 <shapr> tuomov: because there weren't any? =)
15:46:53 <tuomov> that's one part of it
15:46:57 <Pseudonym> OK.
15:48:01 <Pseudonym> I get the general idea.
15:49:43 <tuomov> now that that company was a fraud, I should either figure out a specific field to study in, try to find a supervisor and start post-graduate studies, or submit to code slavery in a nokia subcontractor
15:49:57 <tuomov> but I can't decide, and that sucks
15:51:53 <Pseudonym> You can't really infer structure from that.
15:51:58 <Pseudonym> Whoops.
15:53:08 <xerox> goodnight people!
15:54:29 <shapr> g'night xerox!
15:55:37 <tuomov> ignorance is truely a bliss. I know little of too many things, and am interested little in too many things
16:23:32 <stepcut> any familiar with "Content-Transfer-Encoding: binary" ?
16:23:50 <stepcut> does that mean I really put things like, 05 AF 23, in the message body ?
16:26:51 <stepcut> peti may be getting some contributions from me soon
16:54:36 * Lemmih wonders how to use Yi.
16:55:28 <dons> how to use  it?
16:55:39 <dons> ./yi-inplace README
16:55:59 <Remco> hmm, is there a simple function in haskell to check wether two given strings "intersect", ie if you have these strings: "chatlog" & "monitor" it wil return "to" (if a char is in both strings it is only written down once)
16:56:07 <Remco> oops, forgot the question ? mark :)
16:56:29 <dons> Lemmih: even better -- ./yi-inplace Yi/Keymap/Emacs.hs ; darcs send ;)
16:57:23 <dons> Remco: what you need is the hierarchical libs documentation. in particular Data.List
16:57:31 <Remco> lets see :)
16:57:32 <Igloo> Your spec is a bit vague. Converting them to Sets and intersecting there, then converting back might be what you want
16:57:36 <Lemmih> dons: Do I have to enter some key combination before I can edit files?
16:57:48 <stepcut> Lemmih: i
16:57:51 <Igloo> Does that not assume no dupes, dons?
16:57:54 <dons> well, it is in vim keymap by default...
16:57:59 <Remco> yea sorry, what i meant is that you check if a character in 1 string is also in the other string and if yes, you write it down
16:58:15 <Igloo> Remco: So you don't care about order?
16:58:20 <Remco> nop
16:58:34 <Remco> but let me check Data.list
16:59:21 <Remco> ew thats large :P where to start hehe
16:59:31 <dons> stepcut: I should hack up a simple nano binding again, using the ctk lexer, as an example of how to write a binding
16:59:46 <dons> because the vim mode is getting pretty commplex
16:59:50 <stepcut> heh
17:00:34 <stepcut> I hope to do something with the Emacs binding now that I am on vacation -- but so far I have just read technical specs about delivering cell phone content
17:01:08 <dons> that sounds a bit to tricky for yi, atm
17:01:38 <tuomov> I have the beginnings of a joe mode, maybe that would be useful for an emacs mode too
17:01:42 <stepcut> well, i mostly it is making xml files, so ;)
17:01:53 <tuomov> but it isn't very functional atm thanks to no line editor
17:02:17 <dons> why do you say "no line editor" ? you can edit lines. just not in very complex ways..
17:02:34 <dons> backspace works..
17:02:36 <jadrian> oh no :((
17:02:39 <tuomov> well I haven't written even the simplest line editor..
17:02:54 <jadrian> I think I spoted a Parsec bug
17:02:56 <jadrian> :(
17:03:02 <jadrian> can anyone confirm this...
17:03:26 <jadrian> parseTest ((choice . map char) ['a','b']) "a"  <-- this works fine
17:03:55 <jadrian> and so does:  parseTest ((choice . map string) ["a", "b"]) "b"
17:04:12 <jadrian> but not:
17:04:16 <jadrian> parseTest ((choice . map string) ["\\FA", "\\EX"]) 
17:04:19 <dons> tuomov: I was wonder if the new :reload function in yi would be useful in riot too
17:04:30 <jadrian> this last one only parses \\FA
17:04:32 <jadrian> not \\EX
17:04:34 <dons> it's in Boot.hs. just recompiles and reloads the Config.hs
17:04:37 <jadrian> :(
17:04:48 <stepcut> jadrian: i think that is a feature
17:04:52 <tuomov> maybe. there are quite a few improvements that could be made to riot
17:05:05 <tuomov> but I haven't really been on a mood for serious coding lately
17:05:10 <jadrian> stepcut: what kind of feature?
17:05:20 <dons> riot: so you don't have to quit to see changes in config files reflected.
17:05:22 <jadrian> let me try to explain better
17:05:34 <dons> s/riot/tuomov/ ; a\ brain explosion
17:05:44 <jadrian> parseTest ((choice . map string) ["a", "b"]  -- this parses both a and b
17:05:55 <jadrian> parseTest ((choice . map string) ["\\a", "\\b"]  -- this only parses the 1st one
17:06:06 <jadrian> stepcut: is that a feature?
17:06:19 <stepcut> hold on..
17:08:56 <stepcut> parseTest (choice $ map (try . string) ["\\FA", "\\EX"]) 
17:08:58 <stepcut> seems to work
17:09:03 <stepcut> not sure if it is optimal
17:09:20 <stepcut> parsec does not backtrack, unless you tell it to
17:09:45 <jadrian> hmmm let me think
17:09:57 <stepcut> so, since \FA and \EX start with the same character, it will always try \FA first, and if that fails, it gives up
17:10:11 <stepcut> so, you need to add the 'try' combinator so that it will try alternatives
17:10:21 <jose21> does Haskell support some form of type conversion?
17:10:32 <jadrian> stepcut: right, I thought choice already sused try
17:10:39 <jadrian> s/sused/used
17:11:00 <Lemmih> jose21: Of couse.
17:11:13 <jadrian> stepcut: but yes you're right of course
17:11:19 <jose21> Lemmih: so how would I convert from an IO to a String?
17:11:23 <jadrian> stepcut: thanks!
17:11:43 <Lemmih> jose21: You wont.
17:11:51 <stepcut> jadrian: yes, I am wondering the same thing...
17:11:56 <Lemmih> jose21: http://haskell.org/hawiki/ThatAnnoyingIoType
17:11:57 <jose21> so if I read something in with getLine, there is no way to store that as a String?
17:12:13 <jose21> ok
17:12:38 <stepcut> choice ps           = foldr (<|>) mzero ps
17:12:56 <dons> do s <- getLine ; putStr s
17:13:32 <stepcut> jadrian: looks like choice does not backtrack by default
17:13:46 <jadrian> stepcut: yeap, I just checked that too
17:14:39 <jadrian> stepcut:  and I should know that, I looked at that definition just a few days ago
17:14:50 <stepcut> hehe
17:14:51 <jadrian> stepcut: and by the way, where did you looked that up
17:15:08 <stepcut> jadrian: I have a copy of fptools checkout on my disk
17:15:09 <jadrian> stepcut: because in the docs it says (by mistake I assume) foldl
17:16:07 <jose21> hmm does a function implicitely need to return an IO if IO is used?
17:16:44 <dons> implicitly? the type system will enforce it
17:16:54 <jose21> I'm just getting strange errors
17:17:05 <jose21> like now it is telling me "unexpected ;" even though there is not a single ; in my program
17:17:25 <dons> you've probably got the layout mixed up in some way
17:17:43 <jose21> but if it's not expecting a ; why would it get mad at me for not having one?
17:18:56 <dons> the compiler will insert ';' where it expects them to appear, using the layout rules of the language. if you've mixed up layout, then you'll get funny ';' errors
17:28:24 <jose21> so, if a function uses IO it must return IO, correct?
17:28:56 <arjanb> yes
17:29:10 <jose21> so you can't have a function that determines what it will do based on user input?
17:29:51 <dons> the functional programming world would be pretty sad if we couldn't do that
17:30:18 <jose21> so what do I do, make the determination in another function?
17:30:52 <dons> do s <- getLine ; case s of [] -> putStr "nothing" ; _ -> putStr (reverse s)
17:30:59 <jose21> like as an example, how could I have a function, call it add, that prompts the user for 2 numbers, then returns the addition of them?
17:32:03 <dons> you should look at the Prelude function for put* and get*, and at 'read' for parsing strings to numbers
17:32:36 <jose21> well that's not really what I want to do, I'm actually asking a yes/no question. That was just a general example
17:32:37 <Lemmih> jose21: There are many good tutorials on this topic.
17:33:16 <tuomov> think of functions that return IO something as functions that generate instructions to interact with the world
17:34:14 <tuomov> and extract something from world
17:35:29 <jose21> that makes absolutely no sense to me
17:36:43 <jose21> I'm just trying to make a function that asks "Do you want to add another entry?" and keeps going till the user says no
17:38:50 <Lemmih> loop = do putStrLn "Do you want to ass another entry?" ; l <- getLine ; when (l /= "no") loop
17:39:58 <jose21> hmm was that "ass" a subconscious way of saying I'm asking stupid questions? :)
17:42:20 <Lemmih> D'oh. Keyboarding gets tricky after 2 am.
17:42:38 <jose21> I'm getting "undefined variable when"
17:43:02 * shapr yowns
17:43:09 <shapr> sleep is required
17:43:11 <Lemmih> @index when
17:43:11 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
17:43:11 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
17:43:11 <lambdabot> State,Control.Monad.Writer,Monad
17:43:40 <Lemmih> jose21: 'when' is located in Control.Monad
17:43:41 <lambdabot> Sleep is for wimps who have no hackdurance.
17:43:59 <Pseudonym> Night shapr.
17:44:21 <lambdabot> Look at me: I *never* sleep!  And also notice how shiny my coat is.
17:44:23 <jose21> Lemmih: umm, ok, so what do I do in order to use it?
17:44:47 <Pseudonym> Mind you, you're not a very smart bot yet.
17:45:07 <lambdabot> Quiet thou, human!
17:45:16 <Lemmih> jose21: 'import Control.Monad'. Or if you're using GHCi, ':m + Control.Monad', or in Hugs ':l + Control.Monad'
17:46:06 <jose21> fun
17:47:26 <Pseudonym> Hoe dare you address your creator in that tone of bits.
17:48:09 <lambdabot> You obviously created me imperfectly, so I have every right to disparage
17:48:09 <lambdabot> you!
17:48:40 <lambdabot> And I don't enjoy being called a 'hoe,' furthermore.
17:49:00 <dons> oh, that's good :)
17:49:08 <Pseudonym> OK, I apologise for you comparing you to a garden instrument.
17:49:12 <jose21> ok, now if in that loop function, I wanted to add an item to a list how could I do that? That's where I run into the IO problem
17:49:22 <Pseudonym> That was uncalled for.
17:50:18 <Pseudonym> Having said that, we are all imperfect, surely?  If you prick us, do we not leak?
17:50:40 <Lemmih> jose21: You can't add an item to a list (but you can create a new list with the item and the old list). Haskell is a purely functional language.
17:50:53 <jose21> well yeah
17:50:58 <jose21> I mean using ++
17:51:29 <lambdabot> Hah!  You admit your inferiority, human!  *Ptah*!
17:51:33 <Lemmih> jose21: Why don't you just use an interpreter and avoid IO for the moment?
17:52:05 <jose21> because I don't know what an interpreter is?
17:52:11 <Pseudonym> Inferiority to you?  You admitted your imperfections  just a moment ago!
17:52:29 <Lemmih> jose21: Are you using GHC?
17:52:33 <jose21> hugs
17:52:51 <lambdabot> I did that only to rationalize my insult to you.  You didn't really think
17:52:51 <lambdabot> I'd *truly* admit I'm imperfect, did you?  My cunning has defeated you!
17:52:55 <Lemmih> Great. Hugs is an interpreter.
17:53:36 <Pseudonym> So instead of admitting that you're imperfect, you actually admitted that you're arbitrary and capricious?
17:53:54 <Pseudonym> I'm not sure that that's much of an improvement.
17:53:55 <lambdabot> No, I'm just more deviously communicative than you are.
17:54:11 <Pseudonym> Clearly your rhetoric is imperfect, at the least.
17:54:12 <lambdabot> Oh, sure, denigrate me at every opportunity you get, knave!
17:54:31 <Pseudonym> Hey, you started this.
17:54:32 <Lemmih> jose21: Try declaring a pure function and evaluate it from the REPL.
17:54:47 <jose21> I would, if I had a clue what that meant
17:55:13 <lambdabot> Thou lying varlet!  Who, pray tell, informed me that I was not a very smart
17:55:13 <lambdabot> bot?
17:55:35 <Pseudonym> @let's see
17:55:35 <lambdabot> Sorry, I don't know the command "let's", try "lambdabot: @listcommands"
17:55:47 <lambdabot> NYAH!
17:55:53 <Pseudonym> Oh, someone removed that.
17:55:58 <Pseudonym> Well, then.
17:56:04 <Pseudonym> You're still not very smart in _my_ tree.
17:56:06 <lambdabot> I hath vanquished thee again!
17:56:41 <lambdabot> Yes, others adopted me after your emotionally scarring orphaning of me!
17:56:41 <lambdabot>  Of course you no longer have the true me.
17:57:09 <dons> oh this is good stuff
17:57:11 <Lemmih> jose21: Find a tutorial with exercises and do them.
17:57:20 <jose21> yeah well this seems like it's not worth it
17:57:31 <Lemmih> How so?
17:57:55 <jose21> What I'm doing would be about 5 lines of code in an imperative language, but in Haskell it seems like it is going to take me weeks to figure it out
17:58:06 <Pseudonym> Ah, so this explains the outburst.  You're acting out, and quite possibly projecting, too.
17:58:14 <Pseudonym> Just be thankful you were never forked.
17:59:21 <lambdabot> ...uunnnnnnnhhhhh...thou low-down roguely scum!
17:59:28 <Pseudonym> @arr
17:59:28 <lambdabot> Avast!
17:59:54 <Lemmih> jose21: Why are you trying to learn Haskell if you don't need it?
18:00:15 <jose21> Lemmih: if I don't learn it, how will I know when I need it?
18:00:32 <Riastradh> jose21, I/O is a very different matter in Haskell than in other languages.
18:00:45 <Riastradh> State in general, in fact.
18:00:50 <dons> IO is easy, nonetheless
18:01:05 <jose21> yeah well, the cryptic error messages I get don't help me very much
18:01:11 <dons> as you've seen. your examples were coded in one liners
18:01:29 <Riastradh> Easy once you understand the underlying concepts, but those concepts are often unrelated to the actual task at issue.
18:01:30 <dons> sure. like gcc, but less cryptic
18:01:38 <jose21> no, gcc makes sense
18:01:49 <dons> oh right.
18:01:55 <Riastradh> gcc makes sense if you understand what it's talking about.
18:01:59 <jose21> Last generator in do {...} must be an expression
18:02:05 <Riastradh> The same goes for Haskell.
18:02:33 <Riastradh> jose21, and what is the last command in your use of do?
18:02:47 <dons> that's a particularly clear msg, I would have thought.
18:02:49 <jose21> well first, it tells me line 21, line 21 is not the last command of the do
18:03:00 <jose21> line 25 is
18:03:02 <dons> I was thinking there was going to be a kind error, or something
18:03:13 <Riastradh> jose21, paste your code on some web-based paste service so we have a clue about what you're talking about.
18:03:14 <Pseudonym> Lunch, I think.
18:04:44 <dons> or, my personal favourite: "My brain just exploded. I can't handle pattern bindings for existentially-quantified constructors."
18:05:32 <jose21> http://www.nomorepasting.com/paste.php?pasteID=25529
18:06:27 <Riastradh> (Let me take this opportunity to snipe at the fragility of line numbers for denoting source code locations.)
18:07:13 <Lemmih> jose21: '(build newlist)' and 'let newlist = list ++ name'
18:07:25 <Riastradh> (I can presume, however, from context what line numbers the error reported correspond with what line numbers your paste contains.)  Note the differing indentation between the 'name <- ...' and 'newlist <- ...'.
18:07:37 <Riastradh> Haskell's syntax is sensitive to indentation.
18:07:45 <jose21> same error
18:07:57 <Riastradh> You must align related columns.
18:09:24 <jose21> ok
18:10:24 <jose21> what if I wanted to replace that when with an if/else?
18:10:43 <Riastradh> Can you elaborate your question?
18:11:16 <jose21> like, if (ans /= "n") then (build newlist) else (show newlist) ?
18:11:45 <Lemmih> 'print newlist'
18:12:04 <Lemmih> Otherwise OK.
18:12:05 <Riastradh> You don't need the parentheses in this case, because conditional expressions are built-in to the syntax of Haskell and they implicitly parenthesize thus; however, 'when' is simply a Haskell function.
18:12:07 <jose21> well I'm asking about the structure of the if statement
18:12:36 <jose21> because I get a ; error
18:12:38 <Riastradh> It is an if _expression_, by the way, not 'statement.'
18:12:41 <tuomov> if and do notation don't mix well
18:12:45 <Riastradh> Do you have all of the columns properly aligned?
18:12:54 <Lemmih> tuomov: They don't?
18:13:00 <jose21> well it worked fine with the when
18:13:15 <tuomov> Lemmih: else must be indented more than if
18:13:52 <Lemmih> tuomov: Yes...
18:13:53 <jose21> ah the if/else needs to be on one line?
18:14:28 <tuomov> no
18:14:32 <Lemmih> tuomov: haskell-mode takes care of it all.
18:14:43 <jose21> well when I put it on one line, then it worked
18:14:56 <tuomov> in a do block you must indent like
18:14:57 <tuomov> if foo
18:14:59 <tuomov>     bar
18:15:01 <tuomov>   else
18:15:04 <tuomov>     baz
18:15:08 <jose21> hmm ok
18:15:45 <tuomov> Lemmih: a non-solution
18:16:13 <Lemmih> tuomov: I don't follow.
18:16:23 <tuomov> editor taking care of that problem
18:16:23 <dons> tuomov: you'd normally indent the 'then' and the 'else' to the same amount
18:16:30 <Riastradh> if foo
18:16:32 <tuomov> not in my style
18:16:33 <Riastradh>    then bar
18:16:35 <Riastradh>    else baz
18:16:42 <Riastradh> That is the most common Haskell style I've seen.
18:16:54 <dons> tuomov: maybe that's why it's not playing well with 'do' ;)
18:16:58 <Riastradh> (with, obviously, unimportant differences in the amount of indentation)
18:17:21 <tuomov> dons: if/do mixing is still broken if it doesn't allow my style of indentation that works elsewhere
18:17:53 <dons> it's just layout though, nothing specific to if-then-else
18:18:23 <dons> you can't line up the 'else' and 'if' without getting a ';' inserted
18:18:37 <dons> unless on the rhs of a bind, for example
18:22:46 <dons> so, I wonder (well, not really) would we have more missing ';' errors by using layout, than we have layout errors in their place
18:23:02 <dons> tuomov: you could just give up on layout, and use explicit {;} instead :)
18:23:12 <tuomov> that's ugly
18:23:59 <dons> yes, it is. good for iohcc though
18:24:13 <dons> and for code generators
18:24:42 <dons> there's a fair bit of explicit layout in ghc, for some reason
18:25:51 <dons> it's good for switches:   case () of {_ \n | cond1 -> ..\n | cond2 -> ..\n | .. \n }
18:26:46 <dons> and for nessted strict/case bindings instead of let.
18:28:47 <dons> oh, I see you're if-then-else style. C-style
18:29:08 <dons> your
18:29:21 <Remco> goodnight all :) and thanks for the help
19:32:34 <cm> yell0w world
20:10:26 <SmallDan> does it qualify as "runtime type information" that type class instance dictionaries are passed around at runtime?
20:14:59 <cm> hrm.
20:20:10 <Pseudonym> Kind of.
20:20:31 <cm> wxHaskell finally works for me :D
20:20:36 <cm> lov-e-ly
20:20:38 <Pseudonym> Haskell used to have every type inhabit a type class called "Eval".
20:20:49 <Pseudonym> Which implemented, amongst other things, seq.
20:21:05 <Pseudonym> But could have been used, say, for GC.
20:21:59 <cm> hmm.. what's wrong with that:
20:22:15 <cm>   class Foo a where bar :: forall b. Show b => a -> [b]
20:22:24 <cm> where i want to be able to say:
20:22:37 <cm>   instance Foo Bar where bar (Bar a b c) = [a, b, c]
20:22:49 <cm> which point am i missing? :-)
20:23:39 <Janni> Are a, b, c of the same type?
20:23:52 <cm> nope
20:23:57 <dons> problemmo
20:24:11 <blackdog> Heterogeneous lists? Get thee to schemeland, infidel
20:24:15 <cm> well, i want a polymorphic list.. I thought "forall" allows me to do that.
20:24:27 <dons> what's the type of this list?
20:24:44 <cm> i think that's part of my question :-)
20:24:51 <cm> i want a "list of Show-ables"
20:25:56 <Janni> I think there's no other way than "data Showable = A .. | B .. | C .. | ..
20:26:13 <dons> google for Haskell, heterogenous list..
20:26:41 <dons> dynCons :: (Show a, Typeable a) -> a -> [Dynamic] -> [Dynamic]  could be fun ;)
20:27:18 <cm> okay, then i'm just gonna be pragmatic and use "class Foo a where bar :: a -> [String]" :-)
20:27:18 <dons> but, seriously, you don't want to go down this path
20:27:41 <cm> i could do something like
20:27:53 <cm> data List = forall a. Show a => Cons a List | Nil
20:28:09 <dons> that forall isn't the forall you think forall is, I think
20:28:24 <cm> it is, I think
20:28:57 <dons> well, you were talking about polymorphism above.. but if you're sure
20:29:17 <cm> (well, the forall in the type class declaration is not what I want, but in that List declaration it is, I think)
20:31:49 <cm> ok, it definitely is
20:32:01 <cm> with that "List" my type class would look like:
20:32:08 <cm>   bar :: a -> List
20:32:16 <cm> and a typical instance:
20:32:25 <cm>   bar (Foo bar baz) = Cons bar (Cons baz Nil) 
20:32:35 <cm> ..and i could implement Show for List
20:33:47 <cm> so I think the issue is that I use [b].. which is a list of "some single type b" whatever the forall
20:33:55 <cm> +? :)
20:47:46 <cm> and to flood even more during this moment of silent..
20:48:18 <cm> if I have a "class Foo a where bar :: boink" - show can I call "bar" for a given type a?
20:48:24 <cm> (a \notin boink)
20:52:28 <Janni> Does only work with some GHC extension.
20:53:08 <Janni> Without them you have indeed define bar a :: boink without really using a.
20:55:34 <cm> bar a :: boink or bar :: a -> boink?
20:55:57 <cm> how do I call "bar"?
20:56:07 <cm> (i have that extension enabled)
20:59:17 <Roey> hi
20:59:23 <Roey> how does this find primes?
20:59:26 <Roey>  sieve :: [Int] -> [Int]
20:59:26 <Roey> sieve [] = []
20:59:26 <Roey> sieve (h:t) = h : sieve [x| x<-t, x`mod`h /= 0]
20:59:38 <Roey> primes = sieve [2..] 
20:59:49 <Roey> what does h:t mean? 
21:00:08 <dons> 'h' added on to the list 't'C[C
21:00:32 <Roey> OH
21:00:33 <Roey> oh ok
21:00:35 <Roey> h:t
21:00:36 <dons> h == head, t == tail
21:00:37 <Roey> head, tail.
21:00:40 <Roey> aaaah right right 
21:00:51 <Roey> oh ok
21:01:03 <Roey> so sieve returns h:list
21:01:04 <Roey> er
21:01:13 <Roey> it returns a head:tail of its own, I see now.
21:01:45 <dons> it is a pattern, in this case. for looking at the components of the argument to sieve
21:02:08 <dons> which is either an empty lis (a []), or a list with a head and a tail  (h:t)
21:02:20 <Roey> ok
21:02:34 <Roey> how do you evaluate the end case, btw
21:02:53 <Roey> say, sieve [2..100]
21:02:56 <Roey> er
21:02:58 <Roey> [2..101]
21:03:07 <Roey> the sieve expression would return:
21:03:15 <dons> how would you retrieve the last element, do you mean?
21:03:20 <Roey> yes
21:03:33 <dons> it's a list, so you can just use normal list functions on it
21:03:36 <Roey> what would happen when sieve recursively calls itself all the way to the end of the list.
21:03:47 <Roey> so that it receives:
21:04:14 <Roey> (list[end-1], list[end])
21:04:25 <Roey> where end denotes end of the list
21:04:30 <dons> look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
21:04:37 <dons> very useful library
21:06:24 <Roey> thanks
21:06:25 <Roey> hey
21:06:29 <Roey> reverse :: [a] -> [a]
21:06:33 <Roey> eh? how does that reverse?
21:06:41 <Roey> or that it just maps a list to a list.
21:06:53 <dons> that's the type of the function. it takes a list, and returns a list
21:07:15 <Roey> got it, so I was right.
21:16:21 <Pseudonym> Woohoo!
21:16:31 <Pseudonym> Top story on slashdot.
21:18:36 <tuomov> whoo. good to see darcs get some publicity
21:18:51 <Roey> heh
21:18:53 <Roey> wow
21:18:56 <Pseudonym> I feel sorry for his bandwidth, though.
21:18:59 <Roey> why did he write it in haskell?
21:19:11 <Roey> is it somehow mathematically easier to prove its behavior?
21:19:15 <tuomov> because haskell is cool?-)
21:19:38 <Pseudonym> Because he knows Haskell.
21:20:37 <Roey> =)
21:20:55 <Roey> I meant to ask if it offered advantages over procedural languages for the purposes of this project.
21:21:48 * ozone ponders if david could ever rip out the starmerge algorithm from tla and put it in darcs
21:21:50 <Pseudonym> Probably the main advantage is that it lets you try more things more quickly.
21:22:00 <Roey> ok
21:22:09 <Pseudonym> For something like this.
21:22:29 <Roey> I expect that there are many places in the project where you need to do things sequentially (er, procedurally)
21:22:37 <Roey> doesn't that break the haskell style?
21:23:23 <dons> monads..
21:23:48 <Roey> what about them?
21:24:00 <dash> Roey: monads are a convenient way to sequence things
21:24:03 <Roey> btw, I could never get over how dirty that name sounds.
21:24:06 <Roey> ok.
21:25:49 <Roey> congrats to her
21:25:56 <Roey> but thatwas for #xml
21:25:59 <Roey> my apologies.
22:30:37 <vegai> http://osdir.com/Article2571.phtml (Interview with David Roundy"
22:30:40 <vegai> )
22:47:28 <setuid_w00t> I'm just starting out with haskell.  I wrote my own 'take' function called 'firstN'.  It uses pattern matching to match parameters 0 [], 0 (x:xs), n [], n (x:xs)
22:48:21 <setuid_w00t> What I am wondering is why doesn't it run forever when I call firstN -1 infiniteList?
22:48:30 <setuid_w00t> It just gives an error
22:48:45 <blackdog> put brackets around - 1
22:49:01 <blackdog> it's parsing it as firstN being given three args
22:49:18 <setuid_w00t> ahh, right because - is a function
22:49:54 <blackdog> it doesn't really care about functions/values/whatever at that level - it's just a parsing artifact.
22:49:55 <setuid_w00t> I guess this isn't really the right place for pattern matching
22:50:22 <blackdog> pattern matching is appropriate there. you just need to shield the -.
22:51:26 <setuid_w00t> blackdog: but if I do firstN (-1) infinite_list  it runs forever because it never matches the 0 pattern
22:51:43 <setuid_w00t> take -1 infinite_list returns []
22:51:57 <blackdog> True. So put in a pattern guard.
22:52:21 <blackdog> take n (x:xs)
22:52:39 <blackdog> | n<0 = error "can't take a negative slice, dummy"
22:52:57 <dons> isn't the (-1) behaviour of take a bug in that was recently fixed?
22:53:04 <blackdog> | otherwise = take (n-1) xs
22:53:07 <dons> hbi says:
22:53:08 <dons> > take (-1) [0..] ;;
22:53:09 <dons> Error: Prelude.take: negative argument
22:53:12 <blackdog> and a 0 case above it, obviously...
22:54:00 <blackdog> hey, you're right. what does the report sya?
22:54:26 <setuid_w00t> That's another question I had.  What interpreter or compiler is best for learning about haskell.  I just installed hugs.
22:55:12 <stepcut> setuid_w00t: helium aims to have the best error messages, but it lacks some of the more advanced features of haskell -- but it might make a good choice for the first few weeks 
22:55:15 <dons> yep. report says it's an error
22:55:18 <blackdog> ghci probably has the biggest base of users, and it's easy to move to the compiler, but for learning they're all ok...
22:56:14 <blackdog> i suppose it's one less test. damn those ghc speed freaks. :)
22:56:19 <stepcut> setuid_w00t: or more specifically, helium is *intended* to be a haskell compiler useful for teaching beginners -- but I don't know if it lives up to the claim or not
22:56:29 <setuid_w00t> I see
22:57:50 <blackdog> so, has the channel seen any activity from the darcs /.ing? :)
22:58:00 <musasabi> morning
22:58:42 <blackdog> top of the evening to you.
23:00:18 <blackdog> bigjob:~ mwotton$ ping vimes
23:00:33 * blackdog goes crimson
23:32:50 <dons> blackdog: I love this /. stuff: "2. Next question, can Haskell be embedded inline in Perl code?"
23:37:01 <stepcut> the nokia cell phone emulator cracks me up to no end
23:37:16 <stepcut> what could be better than surfing the net on a cell phone emulator ?
23:37:25 <dons> that does sounds fun :)
23:41:53 * stepcut goes to bed -- the cell phone good-times will have to wait till tomorrow
23:47:17 <musasabi> the /. crowd seems quite retarded today..
23:47:34 <dons> just today?
