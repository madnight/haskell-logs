00:49:45 <TheHunter> morning folks
00:55:50 <Lemmih> Morning.
02:02:56 <TheHunter> @eval "@hello"
02:02:56 <lambdabot> @hello
02:26:59 <kosmikus> TheHunter: he - that might work if there are two lambdabots in the channel ;)
02:29:39 <bringert> hmm, if there were two lambdabots, could you feed one a quine and get them into an infinte discussion?
02:29:41 <TheHunter> kosmikus: yeah, i thought about that and about evil things like @define flood "@eval flood".
02:39:07 <kosmikus> sure, only you still need two if there's a check not to react to own messages
02:41:03 <kosmikus> I think it's on the TODO for lambabot to use /notice to send its replies, to prevent causing any loops
02:48:42 <tromp> @index stdin
02:48:42 <lambdabot> GHC.Handle,System.IO,IO
02:48:58 <TheHunter> @eval "@hello"
02:48:58 <thbot> @hello
02:48:58 <lambdabot> @hello
02:48:58 <lambdabot> Hello world. 
02:48:58 <thbot> Hello world. 
03:39:54 <bourbaki> moin
03:41:03 <Lemmih> Hey bourbaki.
03:41:28 <bourbaki> Lemmih did you do some more ogl stuff lately?
03:42:21 <Lemmih> Sadly no /-: Been too busy with other things.
03:42:39 <bourbaki> oh for uni?
03:44:53 <Lemmih> I'm not yet studying at any university. I feel so unschooled at times /-:
03:45:10 <bourbaki> i know what you mean i feel like that all the time
03:47:57 <Lemmih> Right now I'm working on ways to pay my upcoming rent and learning about FFI tools in the spare time (-:
03:48:43 <bourbaki> :)
03:51:25 <Lemmih> You can completely avoid using the raw FFI interface when you combine GreenCard with hsc2hs.
03:52:34 <bourbaki> moin maihem
03:52:51 <bourbaki> well im not sure if i want that i want to understand how the ffi works
03:54:23 <maihem> moin
03:55:00 <bourbaki> i still need to write an interface to the webcam in windoze but i need vc++ first
03:59:53 <Lemmih> bourbaki: The FFI is not very complicated and writing the same marshalling/ummarshalling code over and over again will become boring at some point (-:
04:00:21 <bourbaki> whats marshalling?
04:02:07 <Lemmih> Converting a Haskell variable to a C-readable variable.
04:02:31 <bourbaki> ah ok
04:12:57 <bringert> Lemmih: you were having problems compiling HaskellDB from CVS before, right?
04:13:58 <Lemmih> Nope. I'm the one with the optimizer problem (-:
04:14:03 <bringert> ah, right
04:14:10 <bringert> :)
04:14:28 <bringert> so I've fixed the build system anyway :)
04:14:35 <bringert> in CVS now
04:17:06 <Lemmih> For HSQL?
04:22:34 <tromp> @index index
04:22:34 <lambdabot> Graphics.UI.GLUT,Graphics.Rendering.OpenGL,Graphics.Rendering.OpenGL.GL
04:22:34 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec,Data.Array,Data.Array.Diff,Data
04:22:34 <lambdabot> Array.IArray,Data.Array.IO,Data.Array.MArray,Data.Array.ST,Data.Array.Storable
04:22:34 <lambdabot> Data.Array.Unboxed,Data.Ix,GHC.Arr,Array,Ix
04:24:24 <bringert> Lemmih: ah, no, HaskellDB
04:24:36 <bringert> the HSQL build problem with hugs is still there
04:24:42 <Lemmih> I didn't know there was a problem with HaskellDB's build system...
04:24:43 <bringert> but it builds fine with ghc
04:25:02 <bringert> the CVS version has had a problem for a week or so
04:25:07 <Lemmih> It does? I haven't been able to compile since pre 1.2 /-:
04:25:13 <bringert> HSQL?
04:25:18 <bringert> what OS?
04:25:43 <Lemmih> Yes. On Gentoo Linux.
04:25:55 <bringert> what's the problem?
04:27:35 <Lemmih> The paths to MySQL.hsc and PostgresSQL include directory are wrong.
04:29:04 <bringert> configure gets them wrong?
04:30:55 <bringert> do "pg_config --includedir", "pg_config --includedir-server" and "mysql_config --cflags" show the right thing?
04:31:07 <bringert> that's what HSQL's configure uses anyway
04:31:42 <Lemmih> I can't remember the exact problem with the MySQL.hsc file since I haven't compiled it with MySQL support for a while.
04:32:16 <bringert> if you can get a bug report together, I'll try to fix it
04:34:43 <kosmikus> and if you get it running, submit an ebuild ;)
04:47:07 <tromp> @index notNull
04:47:07 <lambdabot> bzzt
04:47:57 <bringert> @index xor
04:47:57 <lambdabot> Data.Bits,Foreign,Bits
04:48:16 <bringert> @type Data.Bits.xor
04:48:19 <lambdabot> Data.Bits.xor :: forall a. (Data.Bits.Bits a) => a -> a -> a
04:48:53 <bringert> hmm, is there no logical xor in the standrad libs?
04:49:49 <bourbaki> moin Boegel
04:49:54 <kosmikus> bringer (/=) ?
04:50:03 <kosmikus> bringert, even
04:50:03 <bringert> heh
04:50:07 <Boegel> hello #haskell
04:50:08 <bringert> true
04:50:24 <bourbaki> Boegel is there a word like boegeleisen in be ?:)
04:50:34 <Boegel> nope
04:50:41 <bourbaki> is Boegel a word?
04:50:50 <Boegel> nope :)
04:51:04 <Boegel> years ago I was looking for a nick
04:51:07 <Lemmih> bringert: Data.Bits.complement
04:51:16 <bourbaki> buegeleisen in german is a flat iron ;)
04:51:22 <Boegel> and I asked some (weird) girl, and she shouted 'Boegel!'
04:51:26 <Boegel> so that kinda stuck :)
04:51:37 <bourbaki> heh
04:51:49 <Boegel> bourbaki, it has nothing to do with that :)
04:51:50 <bourbaki> or boereg thats something nice to eat ;)
04:51:57 <Boegel> hehe
04:52:36 <bringert> Lemmih: there doesn't seem to be an instance of Bits for Bool
05:06:14 <Boegel> hello cptchaos 
05:06:36 <cptchaos> hi Boegel
05:06:57 <cptchaos> Boegel: how's code?
05:09:37 <Boegel> kinda quiet now... I want to implement perlin noise, and optimize my current code
05:09:51 <Boegel> but I'm not sure how to map a perlin noise texture on my objects
05:10:15 <Boegel> the perlin nosie algorithm itself isn't that hard to implement, but I can't seem to find anything on how to map it to objects
05:10:44 <cptchaos> cptchaos: do you use (H)openGL?
05:10:50 <bourbaki> Boegel if its a 3d perlin noise map just apply the 3d point of the rayintersection to it
05:11:26 <Boegel> bourbaki, but mostly they suggest to build a 2D perlin noise to generate textures...
05:11:52 <bourbaki> yeah thats because they dont see what its about ;) you can have n dimensional noise
05:12:10 <Boegel> bourbaki, and I have to make sure that the perlin noise function will return the same result everyone I check it for a certain intersection, because of reflection and such... otherwise my reflection will be different from the object :)
05:12:22 <Boegel> bourbaki, I know about the n-dim noise
05:12:32 <bourbaki> so where is the prob then?
05:12:37 <Boegel> I might try it that way :)
05:12:45 <bourbaki> thats the usual way
05:12:55 <bourbaki> its a 3d texture
05:12:59 <Boegel> bourbaki, the fact that the result needs to be the same every time I go check it
05:13:21 <bourbaki> why shouldnt it be that way?
05:13:41 <bourbaki> its not a random function
05:13:57 <bourbaki> not that random is that random really ;)
05:14:18 <Boegel> bourbaki, maybe I think it will be a problem, but it won't :)
05:14:39 <Boegel> also, I'm not sure how big my 'random array' which I need for the algorithm should be...
05:14:40 <bourbaki> the function has a certain frequency and so its tileable there
05:14:55 <bourbaki> doesnt matter really
05:15:06 <bourbaki> its a cyclic space
05:15:20 <Boegel>  I can just use the % operation, right ?
05:15:24 <bourbaki> like the mdulo space
05:15:28 <Boegel> modular, or how do you call that
05:15:38 <bourbaki> well you have real values so no
05:16:03 <bourbaki> but you map it to the quotient space of the map
05:16:07 <Boegel> bourbaki, no, I mean to choose a random value from the array
05:16:09 <bourbaki> like sin
05:16:44 <Boegel> bourbaki, I don't get that
05:16:54 <bourbaki> well sin 0 = sin 360
05:17:23 <Boegel> how does that help me with choosing a random value..? 
05:17:39 <bourbaki> no i mean if the map is smaller then the space
05:17:46 <bourbaki> then it just warps back like sin
05:17:57 <bourbaki> ie your map is 10 units big
05:18:09 <bourbaki> if you plug in 20 then its the samle value like 10
05:18:19 <bourbaki> cause the map is tileable in all axises
05:18:43 <Boegel> bourbaki, won't you get 'edges' in the texture then ?
05:18:52 <bourbaki> nope cause its tileable :)
05:18:57 <bourbaki> there is no edge
05:19:05 <Boegel> ow okay
05:19:13 * Boegel doesn't know much about textures :)
05:19:15 <bourbaki> its an infinite space
05:19:42 <bourbaki> well anyway i need to go to training
05:20:09 <bourbaki> ill be back soon then ill have a look again at PN
05:22:29 <Boegel> maybe I'll have it implemented by then ;)
05:29:43 <Boegel> @index StdGen
05:29:43 <lambdabot> System.Random,Random
05:34:09 <Boegel> @type System.Random.randoms
05:34:11 <lambdabot> System.Random.randoms :: forall a g.
05:34:11 <lambdabot> 			 (System.Random.Random a, System.Random.RandomGen g) =>
05:34:11 <lambdabot> 			 g -> [a]
05:34:37 <Boegel> how do I get an instance from System.Random.RandomGen ? 'getStdGen' doesn't work...
05:37:41 <Boegel> has anybody worked with random generators in Haskell before ?
05:54:50 <musasabi> morning
05:55:07 <morbidi> yoo 
05:55:08 <morbidi> :)
05:55:28 <musasabi> Boegel: randomIO and randomRIO are the simple solutions
05:56:14 <musasabi> Boegel: use it like do { iv <- randomIO; ... } or do { iv <- randomRIO (0,500); ... } (to genarate with a range)
05:57:02 <Boegel> musasabi, what I need it a array of random values
05:57:10 <Boegel> so I want to use 'andoms'
05:57:17 <Boegel> s/andoms/randoms
05:59:09 <musasabi> I would just use replicateM 
05:59:24 <musasabi> of course if you want to work outside IO...
06:00:26 <Boegel> I do...
06:00:34 <Boegel> @wiki HaskellIrcPastePage
06:00:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:02:21 <Boegel> musasabi, check the PastePage, I've put my code there to get a random array of Float's of a certain length
06:16:25 <musasabi> Boegel: that is wrong because getStdGen is inside IO.
06:16:32 <Matt-W> Boegel: shouldn't that be of type Int -> Int -> IO [Float]
06:16:37 <musasabi> so it will produce IO [Float]
06:34:01 <maihem> hi Boegel
06:56:33 <bourbaki> moin
06:58:07 <bourbaki> my new favorite word is coeval :)
06:59:45 <maihem> @web1913 coeval
06:59:47 <lambdabot> *** "Coeval" web1913 "Webster's Revised Unabridged Dictionary (1913)"
06:59:47 <lambdabot> Coeval \Co*e"val\, a. [L. coaevus; co- + aevum lifetime, age.
06:59:47 <lambdabot>    See {Age}, n.]
06:59:47 <lambdabot>    Of the same age; existing during the same period of time,
06:59:49 <lambdabot>    especially time long and remote; -- usually followed by with.
06:59:53 <lambdabot>          Silence! coeval with eternity!           --Pope.
06:59:57 <lambdabot> [8 @more lines]
07:00:20 <bourbaki> cool eh ;)?
07:00:38 <maihem> interesting word
07:00:48 <bourbaki> yep
07:01:12 <maihem> @web1913 diseval
07:01:13 <lambdabot> No match for "diseval".
07:01:19 <bourbaki> especially if you use it in a channel like this :) maihem my coeval ;)
07:01:25 <maihem> hm, I wonder what the opposite is?
07:01:44 <maihem> @web1913 disaeval
07:01:45 <lambdabot> No match for "disaeval".
07:01:49 <maihem> hrmph
07:01:53 <bourbaki> :)
07:02:18 <bourbaki> maybe disaevus in latin?
07:02:46 <maihem> what is the morpheme that turns aevum into aevus?
07:03:06 <bourbaki> no idea :)
07:05:28 <bourbaki> maihem do you have a lot of judge shows on tv as well?
07:06:05 <maihem> what, in the UK? Like judge judy? no, we just get old judge judy editions on the crappiest cable channels
07:06:29 <bourbaki> no i mean like tv shows at court :)
07:06:40 <bourbaki> weve got nearly no talkshows anymore
07:06:43 <maihem> you mean *real* courts. No they are not permitted
07:06:50 <bourbaki> but these even more crappy faked court shows
07:07:08 <bourbaki> no they are all faked that makes it even worse :)
07:07:20 <maihem> We have the BBC, so we have some decent programming -> nobody would watch court shows
07:07:31 <bourbaki> and there always is a 'surpriseing' end ;)
07:08:02 <bourbaki> its not on the gov tv channels but on the commercial ones
07:08:17 <bourbaki> id love if they would show more reports and documentations
07:09:23 <maihem> If the BBC loses their remit, we'll have no good TV in this country except Futurama and So Graham Norton.
07:10:17 <bourbaki> simpsons are cooler then futurama :)
07:10:26 <bourbaki> and also there are still new episodes right?
07:10:32 <maihem> Not sure.
07:11:04 <bourbaki> futurama is at its end
07:11:13 <bourbaki> no more new episodes
07:11:45 <maihem> maybe they'll make "pastarama"
07:11:56 <maihem> Mmmm, pasta
07:11:57 <bourbaki> heh
07:12:11 <bourbaki> i eat pasta everyday ;) or haskellerama :)
07:12:51 <maihem> IMHO logic and programming shows would be good. I mean proper stuff. Something to get your teeth into.
07:13:27 <bourbaki> there where some pretty decent shows on german tv years ago
07:13:30 <maihem> like Tomorrows World but with a less showy bent. Phillipa Forrester could host it.
07:13:37 <bourbaki> math physics chemistry and the like
07:13:47 * maihem dreams of Phillipa Forrester
07:14:03 <maihem> yeah, the whole shebang.
07:14:05 <bourbaki> whos that?
07:14:26 <maihem> Phillipa Forrester was one of the presenters on Tomorrows World. Also did robot wars here in the UK
07:15:04 <earthy> Robot Wars UK was fun
07:15:04 <earthy> ;)
07:15:23 <earthy> the amerikkun version is zilch compared to that
07:16:06 <bourbaki> robotwars?
07:16:07 <Boegel> can someone help me with my random list function which I posted on the wiki ?
07:16:13 <bourbaki> isnt that a bit expansive?
07:17:01 <maihem> robot wars rocked. Craig Charles is da man. Awoogaaaa!
07:19:12 <bourbaki> id just plug an emp blaster on my bot
07:19:24 <bourbaki> one shot winner :)
07:19:30 <maihem> heh
07:22:08 <Boegel> @type mkStdEng
07:22:09 <lambdabot> bzzt
07:22:19 <Boegel> @type System.Random.mkStdEng
07:22:20 <lambdabot> bzzt
07:22:31 <Boegel> @type System.Random.mkStdGen
07:22:32 <bourbaki> @arr
07:22:32 <lambdabot> System.Random.mkStdGen :: Int -> System.Random.StdGen
07:22:32 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
07:22:48 <Boegel> @type System.Random.StdGen
07:22:50 <lambdabot> bzzt
07:23:01 <matteo> I'm learning haskell and I've a problem with using foldr/l. I think that I got the basic concept but I'm unable to apply it to something more complex then just foldr f []. To learn how to use it, I'm trying to convert a function that I wrote without foldr but without success. ANyone want to spend 5 minutes to try to do the function togheter?
07:24:35 <matteo> ups, it seems that I've frozen the channel :)
07:24:55 <Boegel> matteo, post it on the wiki
07:25:01 <Boegel> @wiki HaskellIrcPastePage
07:25:01 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:25:25 <matteo> thanls
07:25:27 <matteo> thanks
07:26:54 <Matt-W> Boegel: I have a version of getRandomList that actually works, would you like it?
07:27:59 <Boegel> Matt-W, I got mine working to... but please post it on the wiki, I could learn from it :)
07:28:02 <Boegel> I'll adjust mine
07:28:29 <Matt-W> Boegel: done
07:28:51 <Matt-W> I haven't figured out why you had two Int parameters to yours
07:28:56 <Matt-W> so I took it out
07:28:59 <Matt-W> one of them out
07:32:04 <Matt-W> matteo: you got your function posted yet?
07:32:49 <Boegel> Matt-W, I posted my function, yes :)
07:33:15 <Matt-W> Boegel: I was talking to matteo... I wanted to help
07:33:31 <Boegel> I use the two Int params, because I want to seperate between heigth and witdh
07:33:34 <matteo> Matt-W: it says to wait 10 minutes
07:33:47 <matteo> Matt-W: to avoid overlapping
07:33:49 <Matt-W> matteo: probably because other people were editing it
07:34:02 <matteo> Matt-W: indeed. So i preferred to wait :)
07:34:05 <Boegel> I know it's 'wrong' to give it like that to the function, it's better to do getRandomList (w*h)
07:34:15 <Boegel> matteo, I was editing it :)
07:35:19 <Matt-W> Boegel: yes, it is indeed wrong!
07:35:33 <Matt-W> if you're going to do it like that then the function should have a different name
07:36:32 <Matt-W> Boegel: aaah I see how you managed to do it outside IO
07:36:46 <Matt-W> Boegel: I suppose you can get away with that sometimes
07:37:42 <matteo> Matt-W: ok, now is there :)
07:37:42 <Boegel> Matt-W, I works with mkStdGen , but not with getStdGen
07:38:04 <Boegel> matteo, it's not ?
07:38:07 <Matt-W> Boegel: yes, that's because mkStdGen works from a seed so it doesn't need to be in IO, but getStdGen pulls one from the system
07:38:45 <Boegel> Matt-W, oh okay :) I like the one outside the IO better, but thanks for the help :)
07:39:02 <Boegel> the whole point was to get it working with result type [Float], not IO [Float]
07:39:05 <Matt-W> Boegel: the one outside IO is fine, just be aware it will produce an identical sequence of numbers each time you run it
07:39:07 <Boegel> I should have said that ;)
07:39:33 <Boegel> Matt-W, I guess that's fine
07:39:40 <Matt-W> good
07:39:49 <Boegel> but thanks for the hint :)
07:40:31 <Matt-W> one does need to understand these things
07:41:16 <matteo> Boegel: ?
07:42:35 <Boegel> matteo, I don't see your function when I refresh the page...
07:43:14 <Boegel> matteo: remdups ?
07:43:15 <matteo> Boegel: I've just reloaded again now and it's the last one, at the end of the page.
07:43:25 <matteo> Boegel: yes
07:43:26 <Boegel> oh, you should have posted it at the top :)
07:43:32 <Matt-W> with your name next to it
07:43:32 <Boegel> nevermind ;)
07:43:52 <matteo> Matt-W: Boegel: sorry, obviously I'm definitevely a beginner ;)
07:43:58 <Boegel> matteo, you want to write this function using foldr/l ?
07:44:03 <matteo> yes
07:44:13 * Matt-W hmmmms
07:44:13 <Boegel> matteo, nevermind, so am I, and everyone has to learn :)
07:44:19 <matteo> the problem that i have in thinking about it
07:44:21 * Boegel hmmms with Matt-W
07:44:27 <matteo> is to udnerstand how foldr manage the list
07:44:28 <Matt-W> I'm not sure if that's actually possible
07:44:43 <Matt-W> can foldr actually remove elements from a list?
07:44:59 <matteo> i tried to conceive the function that removes the adjacent duplicates directly with foldr
07:45:13 <bourbaki> Boegel http://www.robo-murito.net/code/perlin-noise-math-faq.html
07:45:30 <matteo> but i cannot 'see' it. So I tried to write it how I'm able to do it and then to move from this version to the foldr one
07:45:32 * Matt-W thinks
07:46:11 <Igloo> You can do it
07:47:35 <Boegel> bourbaki, thanks, I have seen it, but haven't read that one
07:47:55 <Igloo> You just need to think about what the result should be when the input is the empty list or in the inductive case
07:48:04 <bourbaki> Boegel thats the right thing though that demo code tut thing you came up with inst the real thing
07:48:31 * Igloo can try to help more if you can explain where you're stuck
07:49:12 <Igloo> Just to make sure, you want   foldr f e [1,1,1,2,3,3,4,3,3,5] == [1,2,3,4,3,5], right?
07:49:15 <Matt-W> Igloo: oh yes, I think I see
07:49:22 <matteo> Igloo: yes
07:49:33 <Boegel> bourbaki, oh, damn :s
07:49:42 <Boegel> bourbaki, first test: http://studwww.ugent.be/~kehoste/thesisPublic/website/random.png
07:49:43 <Boegel> :)
07:49:49 <Igloo> OK, so do you know what e should be?
07:49:50 <matteo> Igloo: now I cannot think another wayt to do it then to use a test between two adjacent elements of the list
07:50:09 <Igloo> There is such a test, in f
07:50:15 <matteo> Igloo: and then leave both of them in the list or just discard one
07:50:15 <bourbaki> Boegel looks quite random :)
07:50:45 <Boegel> brb
07:50:58 <Boegel> bourbaki, that's the whole idea ;)
07:51:06 <Boegel> but I have to go now... I'll be back !
07:51:14 <bourbaki> Boegel well not if you want it to tile
07:51:15 <matteo> Igloo: e would be recursevily one element of the list, either taken from the back or from the front of the list
07:51:16 <bourbaki> bye
07:51:34 <Igloo> ermmm, I think you're confused
07:51:49 <matteo> Igloo: I think so too :)
07:52:10 <Igloo> foldr f e [] = e
07:52:17 <matteo> Igloo: flodr thake e and the last element of the list and appplyes the function f
07:52:19 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)
07:52:45 <matteo> Igloo: ok
07:53:07 <Igloo> What you said isn't really how I'd think about foldr
07:53:18 <matteo> Igloo: oh, ok
07:53:32 <Igloo> OK, so what should foldr f e [] be equal to in this case?
07:53:50 <matteo> Igloo: I've read another two wayhs to think about it. The first is like a pattern and the other as a replacement of the cons operator in the list
07:54:09 <Igloo> Replacement for cons and nil in a list is a nice way
07:54:16 <matteo> Igloo: ok
07:54:23 <Igloo> But in this case I think just looking at the definition of foldr is the simplest
07:54:40 <matteo> Igloo: OK
07:55:02 <matteo> In this case, (x:xs) is the initial list
07:55:32 <matteo> e  could be the elment to check in the list 
07:55:52 <matteo> and f the function that check if e is repeated in the list
07:56:19 <Matt-W> woot, done it
07:56:29 <Matt-W> although I doubt mine is the most elegant solution available
07:56:32 <Igloo> But e isn't an argument of f - look at the definition
07:56:42 <Igloo> e is only used when the input list is the empty list
07:57:07 <Igloo> foldr f e says that if the input is [] then the result is e
07:57:09 <matteo> Igloo: right, first point clarified.
07:57:33 <matteo> f e [] = []
07:57:42 <matteo> ups
07:57:46 <matteo> f e [] = e
07:58:33 <matteo> if i think to the replacement of : with f
07:58:48 <Igloo> Hmm, I think you're on the wrong track
07:58:53 <matteo> now i know that f takes x as argument
07:59:07 <matteo> in this case, the first element of the list
07:59:36 <Igloo> Right, let's start again. You want to find an f and e such that foldr f e xs is the duplicate-removing function, right?
07:59:51 <matteo> right
07:59:59 <Igloo> Now, let's do the easiest case first
08:00:03 <Igloo> Assume xs == []
08:00:04 <dv> can that even be done? 
08:00:19 <matteo> ok
08:00:19 <Igloo> dv: Yes
08:00:29 <Matt-W> dv: It can, I just did it
08:00:39 <Igloo> OK, so the first line of the definition of foldr matches:  foldr f e [] = e
08:00:51 <matteo> ok
08:00:57 <Igloo> Now, what answer do you want from the duplicate-removing function when the input is []?
08:01:04 <matteo> []
08:01:15 <matteo> so e has to be []?
08:01:15 <Igloo> OK, so what can you deduce from that?
08:01:18 <Igloo> Right!
08:01:36 <Igloo> So you are now looking for an f such that foldr f [] xs is the duplicate-removing function
08:01:53 <matteo> so i get from the definition foldr f [] (x:xs)
08:02:11 <Igloo> OK, so let's think about 2 more cases now
08:02:21 <matteo> ok
08:02:27 <Igloo> The first is [1,1,2,3]
08:02:49 <Igloo> This matches    foldr f [] (x:xs) = f x (foldr f [] xs)    , right?
08:03:01 <matteo> yes
08:03:12 <Igloo> And what are x and xs in this case?
08:03:20 <matteo> 1 and 1,2,3
08:03:25 <Igloo> Right
08:03:38 <Igloo> So the right hand side is f 1 (foldr f [] [1,2,3])
08:03:59 <matteo> ok
08:04:30 <Igloo> Now, we know the result of (foldr f [] [1,2,3]) is going to be [1,2,3] because foldr f [] is defined to be the duplicate-removing function, right?
08:05:25 <matteo> wait, here I've problem
08:05:27 <matteo> s
08:06:06 <matteo> f [] is defined to be the duplicate-removing function
08:06:15 <Igloo> No, foldr f [] is
08:06:24 <Igloo> [15:59] < Igloo> Right, let's start again. You want to find an f and e such 
08:06:24 <Igloo>                  that foldr f e xs is the duplicate-removing function, right?
08:06:24 <Igloo> [15:59] < matteo> right
08:06:46 <matteo> ok
08:07:01 <matteo> now it's clear
08:07:26 <Igloo> OK, so we have   f 1 [1,2,3]
08:07:49 <Igloo> Now think about the case where xs is [1,2,3,4]
08:08:03 <Igloo> By the same line of reasoning you get f 1 [2,3,4], right?
08:08:14 <matteo> right
08:08:23 <Igloo> And what should the results be for these 2 cases?
08:08:58 <matteo> [1,2,3] and [1,2,3,4]
08:09:16 <matteo> the result of the whole function I mean
08:09:37 <Igloo> Right, so now you need to find an f such that f 1 [1,2,3] == [1,2,3] and f 1 [2,3,4] == [1,2,3,4]
08:09:49 <Igloo> This /is/ the result of the whole function, though
08:10:09 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)    and this is the top level call to foldr that we're considering
08:10:24 <Igloo> So its result is just the call to f that we have here
08:10:42 <matteo> ok
08:11:58 <matteo> the only function that come to my mind is one that check if 1 is already in the list or not
08:12:49 <Igloo> What should f 1 [2,1,3] be?
08:13:20 <Igloo> (remember this is the same as foldr f [] [1,2,1,3])
08:13:20 <matteo> Igloo: right. So one that checks if the next element in the list is equal to 1
08:13:27 <Igloo> Exactly!
08:14:38 <bourbaki> http://www.dangermouse.net/esoteric/chef_fib.html have a look at this and see a language with a good flavor ;)
08:14:42 <Igloo> So f is going to look something like   (\x ys -> if [x] == take 1 ys then ... else ...)    (you can't use head ys as ys may be []) - does that make sense?
08:15:30 <matteo> yes
08:16:02 <Igloo> OK, so can you fill in the results then?
08:17:31 <matteo> Igloo: how 'it' knows that ys is the list [2,1,3]?
08:18:06 <Igloo> OK, you're calling foldr f e [1,2,1,3], right?
08:18:17 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)
08:18:25 <matteo> yes
08:18:33 <Igloo> So on the right hand side   foldr f e [2,1,3] is called
08:18:43 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)
08:18:47 <Igloo> So on the right hand side   foldr f e [1,3] is called
08:18:49 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)
08:18:54 <Igloo> So on the right hand side   foldr f e [3] is called
08:18:57 <Igloo> foldr f e (x:xs) = f x (foldr f e xs)
08:19:00 <Igloo> So on the right hand side   foldr f e [] is called
08:19:13 <Igloo> This matches the base case so e is returned
08:19:36 <matteo> ok
08:19:51 <Igloo> Then the calling foldr has f 3 (foldr f e []) = f 3 e = [3] (in this case)
08:20:24 <Igloo> Then the one above that has f 1 (foldr f e [3]) = f 1 [3] = [1,3]
08:20:40 <Igloo> Then the one above that has f 2 (foldr f e [1,3]) = f 2 [1,3] = [2,1,3]
08:20:52 <matteo> so I'll have something like: f 1 (f 2 (f 1 (f 3 (f []))))
08:20:56 <Igloo> So the [2,1,3] comes from the recursive call to foldr
08:21:02 <Igloo> Right, exactly
08:21:35 <Igloo> You might find iteasier to start by considering the input being [1] rather than a longer list
08:23:37 <matteo> ok, _so after the recursion_, I have f 1 [2,1,3]
08:23:46 <Igloo> Yup
08:24:05 <Igloo> (this is actually a bit of a lie since Haskell is lazy, but you can think about it that way)
08:24:09 <matteo> second ray of light!
08:24:15 <Igloo> :-)
08:24:18 <matteo> :)
08:25:17 <matteo> ok, now back to the \ function
08:25:34 <matteo> it has to be applied during the recursion
08:26:53 <monochrom> Recursion is best understood by expanding expressions rather than keeping a stack in the head and be aware of recursion.
08:27:28 <monochrom> Actually I lie.  I mean recursion is best executed, not best understood.  (Many people equate understanding with execution though.)
08:28:08 <Igloo> In simple cases like this there's no real need to think about what the recursion is doing explicitly
08:28:13 <monochrom> So for example you just keep evaluating and simplifying f 1 (f 2 (f 1 (f 3 (f [])))) and you're set.  No rocket science.
08:28:22 <Igloo> Just assume the recursive case has given you the right answer and work ut what you need to do with it
08:28:46 <matteo> ok
08:28:47 <monochrom> Yes, the right way to understand (as opposed to execute) recursion is divide and conquer.
08:29:18 <monochrom> "To add up 10 numbers, let me add up 9 numbers and then fix it up with the 10th."
08:30:24 <monochrom> "Oh but by recursion/induction I already know how to add up 9 numbers... :)"
08:30:24 <Boegel> bourbaki, I should try the tile funciton then to get it less random ?
08:30:34 <matteo> Igloo: to have from f 1 [3] the list [1,3] f has to be the list constructor
08:31:03 <bourbaki> Boegel id use the real implementation of perlin noise not that hacked stuff on that demo coder site
08:31:28 <Boegel> bourbaki, that image is not yet perlin noise, it's just random :)
08:31:32 <matteo>  
08:31:34 <Igloo> OK, so does that let you fill in one of the holes in (\x ys -> if [x] == take 1 ys then ... else ...) ?
08:32:22 <matteo> (\x ys -> if [x] == take 1 ys then ys else x:ys)
08:32:33 <matteo> but I still have problem with take 1 ys
08:32:42 <matteo> ys = [3]
08:32:42 <Igloo> OK, what's your problem?
08:32:47 <Igloo> Right
08:33:01 <Igloo> take 1 [3] == [3]
08:33:12 <matteo> the only way that I know to catch the first element of a list is by pattern matching
08:33:15 <matteo> like x:xs
08:33:23 <Boegel> hello avatar8888 :)
08:33:29 <Igloo> OK, you could do that here but it would be uglier
08:33:41 <Igloo> (in my opinion)
08:33:49 <matteo> Igloo: ohhh, you mean the function 'take'
08:34:08 <Igloo> Yes
08:34:13 <matteo> Igloo: hem, sorry
08:34:32 <matteo> ok
08:34:35 <matteo> so 
08:34:41 <matteo> (\x ys -> if [x] == take 1 ys then ys else x:ys)
08:34:45 <matteo> this should work
08:34:59 <Igloo> You could say (\x ys -> case ys of [] -> [x]; (y:_) -> if x == y then ys else x:ys) if you wanted to use pattern matching
08:35:06 <Igloo> But it's twice as long  :-)
08:35:13 <matteo> Igloo: :>
08:37:06 <Boegel> bourbaki, when I want to implement perlin noise, I have a problem... in Java or C getting access to a certain element of a (2-dimensional or 3 dimensional) list is quite easy, but it isn't in Haskell...
08:37:30 <bourbaki> Boegel why is that?
08:38:03 <Boegel> bourbaki, well, in Java you can say noise[x][y][z] to get a certain element, in Haskell oyu have to run through the list to get the element
08:38:10 <bourbaki> [[a]] or [[[a]]] would to the job
08:38:26 <Boegel> bourbaki, to construct the list, okay
08:38:36 <matteo> Igloo: thank you very much, you are a great teacher!
08:38:38 <Boegel> but say I want the 3rd element of the second row of the 7th column
08:38:48 <bourbaki> list = [[a]] so to get element x y you just do (list !! x) !! y right?
08:39:13 <Boegel> bourbaki, isn't that really inefficient ?
08:39:16 <bourbaki> the first !! returns a list the second an element of the row
08:39:32 <bourbaki> Boegel i think you can also use arrays but i havent used them yet
08:39:43 <bourbaki> you also could just use a singe array
08:39:47 <bourbaki> er list
08:39:49 <Boegel> bourbaki, I think the noise function will be really slow like that...
08:40:09 <Boegel> bourbaki, that wouldn't make any change, it would even be more inefficient
08:40:17 <bourbaki> list = [a] to get element x y , list !! (y * width + x)
08:40:20 <Boegel> I'm not scared to use !! or so, I just think it pretty slow
08:40:55 <Boegel> because Haskell needs to run through the list to get the element I want (or does Java do that to, but we just can't see it ?)
08:41:06 <bourbaki> well in c you do almost anything thats time citical with tables
08:41:24 <bourbaki> as i said use an array then i guess thats a lot quicker
08:41:33 <Oejet__> Hello all.
08:41:35 <bourbaki> is array perfocmance orientated?
08:42:15 <Boegel> Hello Oejet_
08:43:35 <monochrom> LinkedList.get(int) runs through the list.  ArrayList.get(int) is an array.
08:44:09 <monochrom> array is slow when it comes to inserting and removing things
08:44:32 <monochrom> "is array performance oriented"  it therefore depends on what you want it to perform.
08:45:20 <Boegel> monochrom, just get elements from the array, not inserting or deleting
08:45:55 <Boegel> I need to build a list, depending on the various values of a different list (so I guess it would be better to use an array for this ?)... 
08:51:47 <Boegel> @type split
08:51:48 <lambdabot> bzzt
08:51:53 <Boegel> @index split
08:51:54 <lambdabot> Language.Haskell.THSyntax,GHC.Exts,System.Random,Random
08:52:05 <Boegel> @index splitAt
08:52:05 <lambdabot> Data.List,GHC.List,Prelude,List
08:52:11 <Boegel> @type splitAt
08:52:12 <lambdabot> splitAt :: forall a. Int -> [a] -> ([a], [a])
08:52:26 <Boegel> @eval splitAt 2 [1,2,3,4,5,6]
08:52:27 <lambdabot> unbound variable: splitAt
08:52:40 <Boegel> :s
08:53:43 <Boegel> is there a function which does the following: f 2 [1,2,3,4,5,6] = [[1,2],[3,4],[5,6]] ?
08:54:02 <Boegel> (it shouldn't be too hard to write it myself, but why re-invent the wheel right :) )
08:57:34 <mornfall> yow
08:58:28 <Boegel> hello
09:02:09 <dv> partition (x:y:xs) = [x,y] : partition xs
09:02:21 <dv> well that and partition [] = []
09:03:14 <Boegel> dv, does that does use the first parameter... I want to be able to use that for 3,4,5 and so-one too... 
09:03:19 <Oejet__> And partion [x] = [x].  If that wasn't an assumption.
09:03:30 <Boegel> I can write it myself, I just wonder whether if it exists
09:03:31 <Igloo> partition already means something else, though
09:05:56 <Oejet__> Boegel: You are just lazy the lazy way.  ;-P
09:08:45 <Boegel> Oejet__, no, I don't want to do work I don't need to... there's a big difference ;)
09:10:05 <Oejet__> That sounds like lazy style to me.  :-P
09:11:02 * Boegel -> food
09:16:10 <seidan> a beginner's solution to Boegel's question:
09:16:10 <seidan> every :: Int -> [a] -> [[a]]
09:16:10 <seidan> every n [] = []
09:16:10 <seidan> every n xs
09:16:10 <seidan>     | n > length xs = [xs]
09:16:11 <seidan>     | otherwise = (take n xs) : every n (drop n xs)
09:16:30 <seidan> how does that look? over-complicated?
09:18:32 <seidan> actually that last part can just be: every n xs = (take n xs) : every n (drop n xs)
09:20:37 <earthy> now in pointless style? :)
09:23:56 <Igloo> The original version was horribly inefficient as length is O(n), so it was quadratic overall
09:24:15 <Boegel> seidan, looks great to me :p
09:24:21 <Igloo> The ammended one looks good, though
09:24:28 <Boegel> I would have done it in a simelar way probably
09:24:36 <Boegel> but I think I won't need it after all ;)
09:24:45 <seidan> ok, I'm looking at PointFreeStyle on thw wiki...
09:25:47 <seidan> does that stuff start to make sense? i mean my (ammended) point-ful version is pretty clear.
09:26:50 <monochrom> Yes.
09:27:16 <earthy> seidan: it is quite clear ;)
09:27:37 <earthy> I didn't call it pointless for no reason :)
09:27:41 <monochrom> pointfree style is not always clearer
09:29:31 <seidan> i just don't see how it *could* be clearer :)
09:29:51 <monochrom> but not always more obscure either...  it is rather pointless to write "f xs = foldr1 whatever xs" repeating xs for no reason other than to get around some monomorphism restriction.
09:29:52 <seidan> but then i bet a lot of beginners say that...
09:30:40 <monochrom> Imperative programming is a kind of pointfree programming.
09:31:10 <monochrom> "y:=x+y; x:=x-y"
09:31:20 <seidan> ok: assignment to myself:
09:32:27 <monochrom> "y:=x+y; x:=x-y" is the composition of functions from states to states.  The state (the point) is not mentioned.
09:32:49 <seidan> it's starting to sink in...
09:33:20 <monochrom> In Haskell it would be (\(x,y) -> (x-y,y)) . (\(x,y) -> (x,x+y))
09:34:56 <monochrom> Shell script pipelines are also pointfree style.  grep whatever | sort | uniq
09:35:49 <monochrom> That's nub . sort . filter some_predicate  in Haskell
09:36:40 <monochrom> Most imperative programmers (shell script writers included) are practising point-free programming without knowing it or calling it as such.
09:36:58 <seidan> nub?
09:37:05 <monochrom> @info List.nub
09:37:06 <lambdabot> -- Data.List.nub is a variable
09:37:06 <lambdabot> Data.List.nub :: forall a. (Eq a) => [a] -> [a]
09:37:29 <KiMoS> take 20 (iterate (*2) 1)   <<< what is the role of the 1  in here?
09:37:49 <monochrom> Look at iterate (*2) 1 first
09:39:03 <KiMoS> i dont get it
09:39:46 <Boegel> is there a limit on !! ?
09:39:49 <monochrom> iterate (*2) 1 = [1, 1*2, 1*2*2, ...]
09:40:01 <KiMoS> ohhhh
09:40:08 <monochrom> If you change it to 3, iterator (*2) 3 = [3, 3*2, 3*2*2, ...]
09:40:10 <KiMoS> i get it  
09:40:17 <KiMoS> thanks :)
09:40:41 <Boegel> oh, wait, nevermind
09:42:19 <Boegel> bourbaki, are you there ?
09:42:24 <bourbaki> Boegel yep
09:42:55 <Boegel> there's something strange (to me) about the smooth noise function for perlin noise
09:43:09 <Boegel> http://freespace.virgin.net/hugo.elias/models/m_perlin.htm (2-dimensional smooth noise)
09:43:37 <bourbaki> Boegel and what is that strangeness you deal with?:)
09:43:39 <Boegel> it gives a formula for the corners, but it uses x-1 and x+1, but when you're in a corner, you either have x==0 or x==w (width)
09:43:49 <monochrom> One hurdle in transition from expert imperative programming to beginner functional programming is the bothersome task of needing to name all data you need as parameters and all results you produce as return values.  You cannot assume an implicit state (point) that you can "transform".  You are asked to put back the point.
09:44:10 <Boegel> so x=-1 or x=w+1 gives a problem... (or am I searching this too far ? :))
09:44:18 <bourbaki> Boegel i still dont understand why you dont use the real perlin noise
09:44:25 <Boegel> isn't that the real thing ?
09:44:30 <bourbaki> you always have to keep an array if you want to keep the same function
09:44:38 <Boegel> the page you gave linked to this one...
09:44:40 <bourbaki> no thats the demo freak code
09:44:46 <monochrom> In this sense, to the expert imperative programmer, pointfree is clearer than pointful.
09:44:52 <Boegel> freak ? :)
09:44:55 <bourbaki> the other code is way easier to implement and more robust
09:45:23 <bourbaki> yeah its not the real thing they just did something wrong with is similar
09:45:28 <Boegel> but the 'math' page doesn't show much code does it ? is everything in there I need to know ?
09:47:02 <bourbaki> you just take all points of your square cube hypercube ... and take the difference vector to that point from all points of that shape
09:47:27 <bourbaki> then you do the dot product with the vectors at all the edge points of that shape
09:48:00 <seidan> monochrom: it is??
09:48:01 <bourbaki> adding up these vectors then with these dotproduct is your value you searched for
09:48:29 <Boegel> bourbaki, I don't get it at all, but let me study that math page first :)
09:49:06 <Boegel> bourbaki, I really like the other page, because I show the different steps to be taken, and show lot's of nifty images.. but I believe you when you say that's not the real perlin noise :)
09:49:34 <monochrom> Point-free functional programming = Imperative programming in Arabic.
09:49:46 <bourbaki> i like math and i want to know what the idea is no code
09:49:54 <bourbaki> that so sucks
09:50:04 <bourbaki> thats more or less the original perlin noise
09:50:16 <monochrom> I.e., you read "f . g . h" as a sequence of state transformers (imperative), right-to-left (Arabic).
09:50:25 <seidan> hahaha. I think that made it clear. Your point at least...
09:53:02 <Boegel> bourbaki, I like it to, but it's more diffucult to put exactly those idea's into usefull code... but I'll give it a shot :)
09:53:08 <Boegel> it does look easier though
09:53:58 <bourbaki> its easier and according to the guy who wrote the thing its also as fast as the ugly looking code thing
09:54:17 <bourbaki> and its better for higher dimensions and you get your tileing function in the end
09:54:56 <bourbaki> though i think you can make it a cyclic map so you can omit the many lookups that he proposes
09:58:34 <Boegel> bourbaki, I've read the whole page, but am not sure how to implement it yet... it's less clear than the other page, probably because it's not code-oriented
09:59:09 <bourbaki> you understand how you get your u v s t values?
09:59:41 <Boegel> yes
09:59:46 <Boegel> I think i do
10:00:01 <bourbaki> ok
10:00:11 <bourbaki> then you have two interpolations to do
10:00:35 <bourbaki> one from the vectors corresponding to u and v and one from s and t
10:00:38 <Boegel> this? : # find the average of the first pair of numbers
10:00:38 <Boegel> # find the average of the second pair of numbers
10:00:38 <Boegel> # average those two new numbers together
10:00:54 <bourbaki> right
10:01:00 <Boegel> ok
10:01:09 <Boegel> and then I need to adjust it, to get better result
10:01:20 <Boegel> using 3p² - 2p³, right ?
10:01:42 <bourbaki> for example yes
10:01:53 <Boegel> okay
10:02:13 <Boegel> how do I make a wood texture (for example) then ? use a different adjust function ?
10:02:13 <bourbaki> or something like
10:02:21 <bourbaki> sec
10:02:24 <Boegel> kay
10:02:43 <bourbaki> http://astronomy.swin.edu.au/~pbourke/texture/perlin/
10:03:25 <Boegel> I've seen that one too...
10:03:58 <Boegel> does that use a different adjust function ?
10:04:10 <Boegel> the NOISE(x) function ?
10:04:16 <bourbaki> not sure read the c source files :)
10:04:29 <bourbaki> or use them with ffi
10:04:34 <Boegel> ffi ?
10:04:44 <bourbaki> forign function interface to haskell
10:05:32 <Boegel> what's that ?
10:05:43 <bourbaki> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:05:50 <bourbaki> then you can use c code in haskell
10:06:17 <Boegel> oh no, I want to implement it myself in Haskell
10:06:51 <Boegel> do you know how to create different textures then ? wood, marble, and such ?
10:06:57 <Boegel> what should I change then ?
10:07:32 <bourbaki> no idea its just tinkering around with interesting features
10:08:50 <Boegel> hmm, the other page gives nice examples...
10:08:57 <Boegel> I hate it that's not the real perlin noise :(
10:09:14 <Boegel> "tandard 3 dimensional perlin noise. 4 octaves, persistence 0.25 and 0.5"
10:09:23 <Boegel> I really don't see those things on the math page...
10:10:14 <bourbaki> well its a different approach
10:11:28 <KiMoS> (succ.(*3)) 7     why is the anser 22  in here?  
10:11:39 <KiMoS> ohh
10:11:41 <KiMoS> nvm
10:12:07 <Boegel> I have to go, I'll be back later
10:13:05 <bourbaki> bye
10:23:00 <Lunar^> In Data.Array.*, I can't see any subarray operation, is there any ?
10:23:10 <Lunar^> (anywhere else, maybe)
10:29:13 <musasabi> Lunar^: not really.
10:29:32 <musasabi> parallel arrays are nice for things like that, but the support is quite buggy
10:29:58 <Lunar^> musasabi: It wouldn't be a big deal for immutable array
10:32:03 <Lunar^> musasabi: sub :: Array i e -> (i, i) -> Array i e, maybe
10:49:18 <br1> I've been trying to run http://www.nomaware.com/monads/html/contmonad.html#example but the example uses 'when'.  Where is 'when'?  Thanks.
10:50:02 <kosmikus> @index when
10:50:03 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
10:50:03 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
10:50:03 <lambdabot> State,Control.Monad.Writer,Monad
10:50:45 <kosmikus> @type Control.Monad.when
10:50:46 <lambdabot> Control.Monad.when :: forall m. (Monad m) => Bool -> m () -> m ()
12:23:12 <Jan_w> how can I redefine a function that is also in Prelude ? for instance MyTest.hs contains a type Word, but there is also Prelude.Word , wasn't there something you could specify to ignore certain import fucntions ?
12:25:40 <Jan_w> override or something "The craft of fucntional programming" doens't seem to list it
12:28:37 <musasabi> Jan_w: import Prelude hiding(foo)
12:29:09 <Jan_w> ah, yes that was it
12:29:12 <Jan_w> thanks
12:29:22 <Jan_w> searching for the wrong keyword :)
12:56:58 <Boegel> bourb[jog], back yet ?
13:17:10 * Boegel scratches his head
13:56:55 * Boegel scratches his head again
13:59:04 <Boegel> does Haskell provide a function to scramble a list
13:59:39 <Boegel> i mean, something like this: scramble [1,2,3,4,5] = [2,5,1,4,3] (or something similar)
14:00:14 <wilx> Hmm, this sounds so...non-pure :))
14:00:29 <norpan> sounds so quadratic
14:00:54 <norpan> unless you make it into an array first of course
14:01:16 <norpan> but yeah, impure too
14:01:22 <monochrom> Why must it be [2,5,1,4,3] ?
14:01:50 <norpan> how about scramble [x1,x2,x3,x4,x5] = [x2,x5,x1,x4,x3]
14:02:03 <norpan> is that good enough?
14:03:06 <kosmikus> why generalize unnecessarily? Boegel has written down the definition already :)
14:03:17 <norpan> i know
14:03:37 <norpan> but he said something similar
14:04:18 <kosmikus> ok, here's another one, then: ks_scramble _ = [2,5,1,4,3]
14:04:38 <kosmikus> it even works for strings!
14:04:57 <kosmikus> but then again, yours does, too ;)
14:04:59 <norpan> wow, that's one mean function, it works for any type!
14:05:24 <kosmikus> yes, I call it the Generic Scrambler
14:05:30 <arjanb> kosmikus: maybe you should update the topic, the lambdabot entry has a little glitch in the html version
14:06:09 <kosmikus> arjanb: don't tell me about bugs yet ;) I'm sure there are plenty ...
14:06:35 <wilx> Hmm, anyway, that was rather legitimate question, at least for me.
14:06:41 <wilx> Is there any way how to do it?
14:06:46 <wilx> Efficient and nice?
14:06:48 <Boegel> monochrom, that was just an example... it should work for lists of any length...
14:06:59 <norpan> yeah, but that's not a function, at least not a pure function
14:07:16 <monochrom> First you need to add a parameter --- a random number generator --- to purify it.
14:07:20 <norpan> you'd have to pass in a list of random numbers
14:07:27 <wilx> Hmm, I can imagine giving it random number generator and the list.
14:07:32 <kosmikus> arjanb: ok, I should fix that one
14:07:36 <monochrom> Same generator ==> same outcome.  Different generator ==> different outcome.
14:07:59 <norpan> random generators, that's soooo imperative
14:08:05 <Boegel> monochrom, I don't care if it always produces the same outcom... that's not really that important... at least for me it's not ;)
14:08:12 <monochrom> Next, internally you will use an array to speed things up.
14:08:24 <norpan> Boegel: then use the function scramble a = a :)
14:08:41 <Boegel> norpan, hmmm :p
14:08:57 <monochrom> Finally, look up Knuth's TAOCP volume 2 for the algorithm for permuting an array randomly.
14:09:10 <monochrom> I have actually done all those.
14:09:38 <norpan> it's quite easy to get the distribution uneven, but it's easy to get it even if you know how to do it :)
14:10:13 <norpan> and that was ambigous...
14:10:24 <Boegel> maybe I can just build something that seems random, with using 'mod' orso...
14:10:51 <monochrom> No don't do that.  Never write your own random number generator.  Use the Random module.
14:11:18 <monochrom> http://www.cs.utoronto.ca/~trebla/Shuffle.hs
14:11:48 <monochrom> You can use permute
14:13:58 <monochrom> It is impossible to write a pure function with irreproducible outcome.  That's beyond what you care and what you don't.
14:14:00 <norpan> http://norpan.org/fluxx/Fluxx.hs <- or scramble from this one
14:14:15 <norpan> and look at Server.hs for really nice IO stuff
14:15:27 <norpan> monochrom: it's at least very improbable :)
14:16:11 <Submarine> yow
14:16:17 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]' by ksbot
14:17:14 <arjanb> hey Submarine
14:17:21 --- topic: set to '["The Nov 2004 HC&A Report is released! - http://haskell.org/communities/","Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]' by ksbot
14:17:25 <Submarine> can I do some mild advertisement?
14:17:51 <Boegel> norpan, thanks, that works pretty good
14:18:00 <Submarine> http://www.di.ens.fr/~monniaux/stages.html.en <-- internships
14:18:16 <norpan> gah, french!
14:18:28 <norpan> or does fr stand for freedom?
14:18:43 <kosmikus> arjanb: html version should be (suboptimally) fixed
14:19:08 <arjanb> :-)
14:19:12 <Submarine> norpan, This is off-topic, but afaik "Franc" originally means "Free".
14:19:33 <norpan> really, cool
14:21:02 <norpan> i thought it was a german word meaning "sincere"
14:22:07 <Boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website/randomColor.png (2mb)
14:22:11 <Boegel> nice, isn't it :p
14:22:51 <norpan> weee, white (!) noise
14:23:17 <Boegel> white ?
14:23:32 <norpan> yeah, uniformly random noise is called "white"
14:23:45 <Boegel> ow, I didn't knowthat
14:24:01 <Boegel> that's as far as I get with perlin noise... (not perlin yet :p)
14:24:48 <Submarine> norpan, possible... "franc" can mean both
14:25:56 <norpan> "free" speaking perhaps
14:48:05 * Boegel scratches his head
15:21:22 <bourb[jog]> moin
15:23:55 <Boegel> hey bourbaki 
15:24:15 <bourbaki> Boegel solved yer prob?
15:24:16 <Boegel> I'm trying to implement perlin noise for 3d, but I'm having troubles with types...
15:24:20 <Boegel> bourbaki, hell no :)
15:24:30 <Boegel> if you'll see my code, you'll laugh
15:24:47 <bourbaki> i guess yer still on that single function approach right?
15:25:18 <bourbaki> yer not interpolateing trice as in the stie i gave you
15:25:30 <Boegel> yes I am
15:25:50 <bourbaki> so whats yer prob?
15:26:03 <Boegel> I have follow this: http://www.noisemachine.com/talk1/16.html
15:26:10 <Boegel> s/follow/followed
15:26:29 <Boegel> I'll show you my code, watch pm
15:40:06 <HET2> i have a quick question
15:40:08 <HET2> facCps k 0 = k 1
15:40:08 <HET2> facCps k n = facCps (k . (n *)) (n-1)
15:40:08 <HET2> fac = facCps id
15:40:17 <HET2> can somebody give me a hint as to why i need the id there?
15:40:21 <HET2> <- new to fp
15:41:28 <Boegel> HET2, facOps uses an extra argument, fac does not
15:41:37 <Boegel> fac n = facCps id n
15:42:40 <HET2> ah
15:42:43 <HET2> suddenly all makes sense
15:42:45 <Boegel> :)
15:42:49 <HET2> thx
15:42:54 <Boegel> np
15:43:43 * HET2 just found out that "the evolution of a haskell programmer" although meant as a joke is a great way to get used to haskell idoms ;)
15:59:16 <Boegel> @index fromIntegral
15:59:16 <lambdabot> GHC.Real,Prelude
15:59:26 <Boegel> @type fromIntegral
15:59:28 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
16:00:06 <bourbaki> @arr
16:00:06 <lambdabot> This is the END for you, you gutter-crawling cur!
16:00:20 <bourbaki> woop the bot wants me to go to bed ;)
16:00:59 <Boegel> hehe :)
16:01:34 <bourbaki> damn bot!
16:01:44 <bourbaki> @seen shapr
16:01:44 <lambdabot> I saw shapr leaving #darcs 21 hours 38 seconds ago.
16:02:17 <bourbaki> @seen me
16:02:18 <lambdabot> I haven't seen me
16:02:23 <bourbaki> @seen you
16:02:24 <lambdabot> I haven't seen you
16:02:31 <bourbaki> @seen bourbaki
16:02:31 <lambdabot> bourbaki is in #haskell.
16:02:48 <bourbaki> @seen jep
16:02:48 <lambdabot> I haven't seen jep
16:08:38 <Jan_w> @seen anyone
16:08:38 <lambdabot> I haven't seen anyone
16:09:10 <Jan_w> @seen anything for quite a while now
16:09:10 <lambdabot> I haven't seen anything
16:09:17 <Jan_w> hm :)
16:09:39 <Pseudonym> @seen a-purple-cow
16:09:40 <lambdabot> I haven't seen a-purple-cow
16:10:01 <Jan_w> @seen anythingforquiteawhilenow
16:10:01 <lambdabot> I haven't seen anythingforquiteawhilenow
16:10:08 <Jan_w> hehe
16:11:15 <lambdabot> I haven't seen a purple cow
16:11:21 <lambdabot> I hope I never see one
16:11:27 <lambdabot> But I can tell you anyhow
16:11:32 <lambdabot> I'd rather see than be one
16:13:38 <bourbaki> @die
16:13:38 <lambdabot> Sorry, I don't know the command "die", try "lambdabot: @listcommands"
16:13:50 <lambdabot> You can't kill me.  Mwhahahaha!
16:14:36 <bourbaki> @comit sucidie
16:14:37 <lambdabot> Sorry, I don't know the command "comit", try "lambdabot: @listcommands"
16:14:55 <lambdabot> Hay doap! Karnt u spel?
16:15:10 <bourbaki> @get drunk
16:15:10 <lambdabot> Sorry, I don't know the command "get", try "lambdabot: @listcommands"
16:15:27 <lambdabot> OK, that I like. Get someone to implement that.
16:15:36 <bourbaki> heh
16:18:22 <Boegel> hehe
16:18:23 <Boegel> funny
16:19:04 <bourbaki> @get work
16:19:05 <lambdabot> Sorry, I don't know the command "get", try "lambdabot: @listcommands"
16:19:22 <lambdabot> @get stuffed
16:19:34 <bourbaki> auha
16:21:10 <stepcut> join #emacs
16:21:13 <stepcut> ack
16:21:19 <bourbaki> :)
16:21:20 * stepcut hands himself a /
16:24:02 <dons> hehe. now you've revealed your hand ;)
16:24:22 <bourbaki> as in poker?
16:24:37 <dons> that's the metaphor, yep.
16:24:40 <Pseudonym> Yes, you should dump emacs and use yi immediately.
16:24:40 <Spark> heh
16:24:43 <Spark> i got that
16:24:48 <Spark> and im so drunk i just had some doner meat
16:25:00 <Spark> yi?
16:25:17 <dons> http://www.cse.unsw.edu.au/~dons/yi.html
16:25:19 <dons> ;)
16:25:46 <dons> and stepcut's writing the emacs binding, so I guess he's allowed to do research
16:25:52 <Spark> i see
16:25:56 <Spark> its a 'framework' :)
16:25:57 <bourbaki> Spark drunk by what ?:) i just discovered the coolest cocktailbar and its 200m from my flat :)
16:25:58 <Pseudonym> True.
16:26:02 <Spark> rah
16:26:07 <Spark> traditional english pu
16:26:08 <Spark> pub
16:26:10 <Spark> smuggler themed
16:26:17 <bourbaki> :)
16:26:21 <bourbaki> i love cider
16:26:23 <Spark> 3 pints of greene ipa, but then im a lightweight, totally
16:26:29 <bourbaki> but they dont serve good cider here
16:26:54 <bourbaki> i had 2 50 cl cocktails and one sambuca :)
16:27:14 <Spark> heh
16:27:24 <Spark> 5 units?
16:27:26 <bourbaki> wednesday is all day happy hour :)
16:27:33 <Spark> heh cool
16:27:33 <bourbaki> .5 litres
16:27:40 <Spark> mm
16:27:51 <Spark> how much is a spirit measure in england
16:27:55 <Spark> 20 i think
16:28:07 <kosmikus> dons: sorry, I forgot to include the yi homepage in the report -- I had planned to do that
16:28:11 <bourbaki> 2 cl\
16:28:17 <bourbaki> 4cl is a doulbe
16:28:47 <dons> kosmikus: oh, that's ok. it only got created 2 days ago, anyway
16:28:49 <bourbaki> or .04l :)
16:29:11 <bourbaki> im gonna go there tommorow again
16:29:28 <bourbaki> 5 euro per .5l cocktail is unbeatable
16:29:42 <Spark> oh, 2
16:29:45 <Spark> :o
16:30:15 <bourbaki> one caipirinha and one "something with mango in it" :)
16:30:19 <kosmikus> dons: I know
16:30:22 <Spark> i tend not to drink very often, so i always end up being a lightweight
16:30:45 <bourbaki> lightweight as in drunk or literaly?
16:30:51 <Spark> drunk
16:30:57 <bourbaki> or as in throw up :)? 
16:30:59 <Spark> 4 pints is more than enough
16:31:00 <Spark> nah
16:31:01 <bourbaki> didnt know that phrase
16:31:08 <Spark> when things start to get dizzy its time to stop :)
16:31:19 <bourbaki> i drink like 2-4 times a year :)
16:31:20 <Spark> i havent thrown up from drink for maybe 2 years
16:31:21 <Boegel> Spark, then it just starts :p
16:31:24 <Spark> maybe once in the last year :)
16:31:37 <bourbaki> i drink one .3l beer and am dizzy :)
16:31:39 <Spark> i used to drink all the time, 6 pints minimum :)
16:32:18 <bourbaki> but im not that ... sissy ? when it comes to be drunk when i drink i can drink alot and am not totally wasted :)
16:32:28 <dons> kosmikus: thanks for being so thorough :)
16:32:46 <Spark> heh
16:33:18 <bourbaki> the funny thing is i just discovered the bar after jogging in the wrong direction :)
16:33:28 <bourbaki> so after jogging i got drunk :)
16:34:02 <Spark> after 200m of jogging? :)
16:34:15 <Spark> i think the only exercise i get is clubbing
16:34:23 <bourbaki> heh no after like 30 min jogging
16:34:29 <Spark> where i dance for 7 hours or osmething :)
16:34:33 <bourbaki> there are no cool clubs here :(
16:34:38 <Spark> :(
16:34:46 <bourbaki> i like lounges
16:34:46 <Boegel> Spark, I get drunk faster from beer than from other stuff (like jenever)
16:34:55 <Spark> really
16:34:57 <Spark> bizarre
16:34:58 <bourbaki> where you can sit in cofy chairs
16:35:04 <Spark> chill out room!
16:35:07 <kosmikus> dons: I'd like to be, but am most certainly not. The irc channel has the advantage that I hear some things, but I definitely miss a lot of others.
16:35:20 <Spark> after a few hours of clubbing though, you dont give a shit about comfy chairs :)
16:35:21 <bourbaki> and get a nice drink and cool chilly music where you can talk over
16:35:25 * Boegel is testing the perlin noise thingie...
16:35:59 <bourbaki> well im a comfy man :) i like it comfy when i go to bars i sit at the desk and nearly sleep :)
16:36:17 <Spark> heh desk
16:36:18 <Spark> table? :)
16:36:22 <Spark> desks are for working on
16:36:34 <bourbaki> no the thing where the bartenders are at
16:36:38 <Spark> ah, the bar
16:36:45 <bourbaki> heh :) ok the bar then
16:36:53 <Spark> sometimes they have bars too
16:36:55 <Spark> along the floor
16:37:01 * Boegel thinks it's really slow... :( but that's just my code probabl
16:37:25 <bourbaki> im not much of a dancer im a sitter the more comfy the chair the more chilly the music the longer i stay :)
16:37:53 <bourbaki> Boegel premature code optimizations are the root of all evil
16:38:04 <bourbaki> make the code propper then crank it up
16:38:10 <Boegel> bourbaki, still, it takes way too long ;)
16:38:15 <bourbaki> dont care for speed in the first place
16:38:31 <Boegel> it's taking like over 3 min's now for a 100x75 image
16:38:33 <Boegel> :)
16:38:53 <bourbaki> do you have a 3d noise on the shpere now?
16:40:34 <bourbaki> Spark what kind of clubs do you go to?
16:40:47 <Boegel> bourbaki, I'm working on it...
16:40:53 <Boegel> it should be 3D noise yes
16:41:06 <bourbaki> should i wake or should i go?
16:41:28 <bourbaki> i wonder if i can make it past 14h
16:41:30 <Spark> industrial or goth or sometimes metal
16:41:38 <Spark> things the mother would not approve of basically :0
16:41:43 <bourbaki> wargs yer a goth?
16:41:45 <Spark> sometimes electro too :)
16:42:04 <Spark> wargs?
16:42:10 <bourbaki> friend of mine is a goth but i cant really go with the music
16:42:16 <Spark> heh
16:42:23 <Spark> it changes all the time
16:42:29 <Spark> during the 90s it was all darkwave
16:42:31 <bourbaki> wargs ans in ... er if yer surprised and or shocked :)
16:42:32 <Spark> before that it was rocky
16:42:40 <Spark> oh ok :)
16:42:43 <bourbaki> but i listen to anything
16:42:49 <Spark> now its all electronic
16:42:56 <bourbaki> since im not a dancer its not a prob
16:42:57 <Spark> cybergoth :)
16:43:00 <Spark> heh
16:43:14 <Spark> i was chatting to some pretty girl last saturday, who never dances
16:43:20 <Spark> she was 16 though
16:43:23 <bourbaki> its just a question for the right intoxication ;)
16:43:36 <Spark> heh
16:43:41 <Spark> there are a selection of intoxications available
16:43:43 <Spark> i love that word
16:43:47 <Spark> its like chemical-self-harm
16:43:56 <bourbaki> i love exaclty that state ;)
16:44:20 <bourbaki> i just thought about applying to a bartenders school :)
16:44:29 <Spark> heh
16:44:36 <Spark> you have to be streetwise
16:44:38 <Pseudonym> Do bartenders use Haskell?
16:44:43 <Spark> but not as much as a drug dealer i suppose
16:44:45 <bourbaki> i bet im a good bartender
16:44:47 <bourbaki> sure
16:44:48 <bourbaki> no
16:44:53 <bourbaki> they use chef :)
16:45:07 <bourbaki> im anything :)
16:45:10 <bourbaki> im flexible
16:45:27 <Spark> you're polymorphic?
16:45:31 <bourbaki> righto
16:46:51 <bourbaki> and i can be really streewise and astute if needed
16:47:55 <Janni> Hi
16:47:59 <bourbaki> moin
16:48:19 <Spark> my old landlord used to throw out the guys who started fights
16:48:25 <Spark> and then come back in moments later covered in blood
16:48:33 <Spark> wash his hands behind the bar, then continue serving
16:48:35 <bourbaki> :)
16:48:44 <Spark> he was the dogs bollocks, he was from jersey
16:48:51 <bourbaki> Janni not asleeep yet?
16:49:13 <bourbaki> im the guy who talks everyone out of trouble usually
16:50:03 <Janni> No I'm working
16:50:13 <Janni> I'm actually earning money with Haskell
16:50:17 <bourbaki> working at these hours?
16:50:34 <bourbaki> where yer worink at?
16:50:37 <Janni> At home
16:50:47 <bourbaki> guessed so :)
16:50:52 <bourbaki> what company i ment
16:51:24 <Janni> No company. To be exact, my uncle in Korea owns a smaller company, I'm writing a program for him...
16:51:30 <Boegel> scene without perlin: http://studwww.ugent.be/~kehoste/thesisPublic/testNoPerlin.png
16:51:42 <Boegel> scene with perlin: http://studwww.ugent.be/~kehoste/thesisPublic/testPerlin.png
16:51:47 <Boegel> so something is wrong :)
16:51:57 <bourbaki> Boegel are you useing bdrf already?
16:51:57 <Janni> It's some kind of 3D CAD-Program, using wxHaskell and OpenGL
16:52:12 <Boegel> bourbaki, no, I stook to Phong
16:52:19 <bourbaki> Janni cool
16:52:27 <Boegel> Janni, raytracing ? :)
16:52:38 <Janni> Oh yes, I've waited so long for such a job
16:52:46 <bourbaki> Boegel you also need to take into account the colour of the oject
16:52:56 <Janni> Boegel: Not really.
16:53:04 <bourbaki> id like to work for alias wavefront
16:53:48 <Boegel> bourbaki, the texture IS the color, not ?
16:53:53 <Pseudonym> It's just Alias now.
16:53:55 <bourbaki> nope
16:54:00 <Janni> If anyone wants to know: His company sells machines, that make three-dimensional photographs into glass blocks. With LASERS 8-o
16:54:20 <bourbaki> cool holograms !
16:54:21 <Boegel> bourbaki, are you sure ? how do I use the colour (diffuse?) of the object then ?
16:54:24 <Pseudonym> Maya's renderer is crap, though.  So if rendering is what you're interested in...
16:54:40 <bourbaki> Boegel the colour you get is just a gray scale
16:54:56 <Janni> They're black/white of course, or white/translucent to be correct
16:54:59 <bourbaki> im interested in the cool editor features
16:55:16 <bourbaki> Janni can you buy em in germany as well?
16:55:33 <Boegel> bourbaki, I give a value for x,y,z and I get a value of for x,y and z ? so i have an rgb value ? or am I wrong here... ?
16:55:37 <bourbaki> Pseudonym are you working in a related field?
16:55:42 <Pseudonym> I used to.
16:55:50 <bourbaki> cool where ?
16:55:51 * Pseudonym still uses Maya, though
16:55:55 <bourbaki> Boegel you get a singel value
16:55:56 <Pseudonym> http://www.dotcsw.com/
16:56:04 <Janni> bourbaki: I think there is a company producing them in Germany, I think VitroCam or s.th like that...
16:56:12 <bourbaki> Pseudonym as coder or artist?
16:56:16 <Pseudonym> Coder.
16:56:21 <Pseudonym> Dot C just writes software.
16:56:28 * Pseudonym hasn't worked for them in a few years
16:56:56 <bourbaki> cpp;
16:56:59 <bourbaki> cool
16:57:15 <bourbaki> this wave renderer has been used in titanic as well right?
16:57:24 <bourbaki> Pseudonym where do you work now?
16:57:32 <Janni> And I'm earning money by writing free software, it's perfect...
16:57:32 <Pseudonym> Oh, I work in information retrieval now.
16:57:40 <Pseudonym> http://www.teratext.com.au/
16:57:58 <Pseudonym> The renderer is a general-purpose renderer.  The waves are just the output of a specific modeller.
16:58:24 <Janni> But first, I have to implement that damn thing >:-|. *back to work*
17:00:08 <bourbaki> Pseudonym quite a change :) i thought about going into that movie render suff also but you need to be a math and physics crack there
17:00:26 <Pseudonym> The problem with me is I find too many things interesting.
17:00:29 <Pseudonym> Besides, work is work.
17:00:36 <Pseudonym> And everything is work.
17:01:14 <bourbaki> right
17:01:17 <Pseudonym> I don't care what field I work in so long as the mental and technical challenge is there.
17:01:40 <bourbaki> i wont do any db stuff though :)
17:02:00 <Pseudonym> Well, that's what we do here.
17:02:05 <Pseudonym> We write database servers.
17:02:17 <Pseudonym> Not SQL, though.
17:03:18 <bourbaki> thats what i saw :)
17:03:26 <bourbaki> i think we had a talk a long time ago
17:03:46 <bourbaki> i used the pseudonym ham back these days
17:04:12 <Pseudonym> Probably, yes.
17:04:15 * Pseudonym tends to talk a lot
17:05:19 <bourbaki> so do i:)
17:05:26 <Pseudonym> Meeting.  BBL
17:05:30 <bourbaki> kk
17:05:35 <bourbaki> bed bbl ;)
17:05:52 <bourbaki> nighto #haskell
17:05:55 <bourbaki> @nighto
17:05:55 <lambdabot> Sorry, I don't know the command "nighto", try "lambdabot: @listcommands
17:07:36 * Boegel goes to bed aswell
17:07:43 <Boegel> goodnight #haskell
17:07:48 <Boegel> goodnight bourbaki 
17:25:14 <Igloo> Hmm, there's no way with the standard libraries to do sortBy compare_on_length on something without recomputation, right?
17:25:48 <Igloo> (or the map snd . sort . map (\x -> (length x, x) style)
19:13:56 <jedi`> morning all
19:14:07 <jedi`> I am going through a tutorial, and it says to try
19:14:15 <jedi`> map toUpper "test string"
19:14:25 <jedi`> i am using GHCi, and hugs, and both tell me variable isnt in scope
19:14:29 <jedi`> hehe im confused :)
19:15:31 <Lemmih> toUpper is located in the Data.Char module.
19:15:44 <jedi`> k, so must i import it?
19:15:56 <jedi`> if so, how would i do that in GHCi
19:15:57 <Lemmih> Write: :m +Data.Char
19:15:57 <jedi`> ? :)
19:17:17 <jedi`> still getting variable isnt in scope
19:17:18 <jedi`> :\
19:18:31 <Lemmih> What's the name of the variable?
19:18:31 <Igloo> Can you paste it, including the ghci prompt and the line you entered?
19:18:51 <jedi`> variable not in scope: 'toUpper'
19:18:52 <jedi`> I wrote
19:18:58 <jedi`> map toUpper "test"
19:19:00 <jedi`> so yeah
19:19:07 <Igloo> What's the ghci prompt?
19:19:42 <jedi`> Prelude?
19:20:49 <Igloo> You either haven't done ":m +Data.Char" or it hasn't worked for some reason
19:20:57 <jedi`> it seemed to work
19:21:12 <jedi`> perhaps the toUpper isnt in that module?
19:21:22 <Igloo> You'll need to copy and paste more for us to see what's happened
19:21:25 <Lemmih> It should say: 'Prelude Data.Char>'
19:21:32 <jedi`> it doesnt say that Lemmih
19:21:38 <jedi`> im using GHCi
19:21:52 <Igloo> Paste the equivalent of this:
19:21:53 <Igloo> Prelude> :m +Data.Char
19:21:53 <Igloo> Prelude Data.Char> map toUpper "test string"
19:21:53 <Igloo> "TEST STRING"
19:21:57 <Lemmih> Then write ':m + Data.Char' again and notice any errors.
19:22:05 <jedi`> you cant paste
19:22:10 <jedi`> its like a dos window hehe
19:22:25 <Igloo> There is a way - or at least there used to be
19:22:30 <jedi`> ok i had to use :module
19:22:36 <jedi`> it doesnt like :m
19:22:37 <jedi`> heh
19:22:39 <jedi`> thanks guys :)
19:22:50 <Igloo> Ah, OK. Perhaps you have an old versino or something
19:22:52 <Lemmih> What version of GHC are you using?
19:23:04 <jedi`> 6.2.1
19:23:10 <Igloo> Hmm, curious
19:23:39 <Lemmih> Does it print any error messages when you try to use :m?
19:53:42 <Lemmih> Guess not.
21:05:48 <Lemmih> What does HaskellDB use hs-plugins for?
21:15:50 <dons> I think it dynamically loads queries as plugins
21:16:06 <dons> it may do other things too
23:58:44 <earthy> good moring #haskell
23:59:13 <Lemmih> Morning.
