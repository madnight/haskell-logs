00:41:24 <shapr> good morning #haskell!
00:46:36 <shapr> Man, I'm tempted to write up an Oleg Kiselyov style reply to the "partition does not work on infinite lists"
00:53:58 <shapr> good morning!
00:54:14 <shapr> it's @416, do you know where your code is?
00:57:25 <shapr> did forkProcess change with 6.2.2?
00:57:30 <shapr> @index forkProcess
00:57:30 <lambdabot> System.Posix,System.Posix.Process
00:57:38 <shapr> @type System.Posix.forkProcess
00:57:40 <lambdabot> System.Posix.forkProcess :: IO ()
00:57:40 <lambdabot> 			    -> IO System.Posix.Types.ProcessID
01:05:33 <Si\> is there anyway of keeping a state between TH sections other than writing a file?
01:08:39 <shapr> at first thought it seems like you could do the monadic thing.
01:08:50 <shapr> that is, do something and return a value
01:09:31 <Si\> but Q is stateless
01:14:43 <Si\> I think I'll just create a file called .th and serialize my data-types to that
01:20:43 * shapr jump up and down on PLog
01:33:52 <shapr> hoi xkb 
01:33:55 <xkb> hi
01:33:57 <xkb> I have a type system related question
01:34:04 <shapr> uh oh
01:34:20 <shapr> lemme guess, you're going to ask about skolemization?
01:34:28 <xkb> In a static type system, is it true that a return value is always of one type or a supertype thereof
01:34:36 <xkb> shapr, he.. no, not yet :D
01:35:04 <xkb> also very interesting.. 
01:35:26 <shapr> I don't understand your question.
01:36:18 <shapr> hoi Boegel 
01:36:29 <xkb> hmm.. Ill try to explain
01:36:39 <Boegel> hey
01:36:42 <xkb> I'm searching for alternatives for current exception handling
01:36:51 <xkb> And I was thinking of type-systems
01:38:00 <xkb> So the return value of a function/method whatever is normally of the type defined by the signature
01:38:11 <xkb> or a supertype thereof (inheritance)
01:38:21 <xkb> And I was wondering if that's always the case
01:38:35 <shapr> Have you read the various exceptions paper by Simon PJ?
01:39:00 <shapr> It sounds like you're close to the same type system path that led to two different kinds of exceptions in Haskell.
01:39:22 <shapr> greetinz gnufan 
01:39:28 <xkb> shapr, He uses an extensionn of the "value" system
01:39:50 <xkb> shapr, hmm 2 diferent kinds?
01:39:58 <shapr> yes, exact and inexact.
01:40:07 <shapr> one of which can only be caught in the IO monad.
01:40:07 <xkb> ahh yeah
01:40:13 <xkb> the inexact one
01:40:32 <xkb> hmm is there a sep. paper on the exact design?
01:40:39 <shapr> I don't remember.
01:40:47 <shapr> but I think there is
01:40:51 <xkb> hmm.. 
01:40:56 * xkb goes back to citeseer
01:41:10 <xkb> atm I have 2 papers by SPJ
01:41:16 <shapr> I vaguely recall that there are at least two different papers on exceptions in Haskell....
01:41:27 <xkb> there's one by Reid 2
01:41:32 <shapr> and I thought the second one was about three years later, and was on inexact exceptions.
01:41:50 * shapr shrugs
01:42:11 <shapr> I never got around to reading those papers, so I don't remember the details.
01:42:32 <shapr> What I remember is just what was mentioned on the mailing lists.
01:43:24 * shapr suddenly realizes he's been trying to debug a tabs versus spaces problem.
01:44:40 <shapr> crap, I don't know what these tab widths were set to before :-(
01:46:59 <shapr> man, I *hate* tabs.
01:48:34 <shapr> hoi swiert 
01:48:41 <shapr> hoi gaat het?
01:48:55 <swiert> hi shapr
01:48:59 <swiert> het gaat goed.
01:49:01 <xkb> hoe ;)
01:49:27 <shapr> how's code?
01:49:38 <Boegel> goeiemorgen swiert :)
01:50:28 <swiert> shapr: allright. I've been getting along nicely lately. A week or two till I finish a working prototype.
01:50:41 <shapr> for your thesis?
01:50:49 <swiert> yep.
01:50:51 <shapr> neat
01:50:55 <Boegel> swiert, subject ?
01:51:13 <swiert> Boegel: embedding attribute grammars in Haskell compilers.
01:51:34 <shapr> would that allow for syntax macros?
01:52:01 <shapr> Guten morgen yeti 
01:52:34 <yeti> guten morgen shapr :)
01:52:56 <shapr> man, where's juhp when I want to berate him about using \t instead of spaces?
01:53:18 <shapr> yeti: any new questions today?
01:53:38 <yeti> yeah ;) what's "good morning" in swedish?
01:53:44 <shapr> god morgon
01:54:05 <shapr> and in english, it sounds like "good moron"
01:54:22 <yeti> :)
01:54:30 <swiert> shapr: hmm, I need to think about syntax macro's. I know Arthur Baars has been working on them and Alexey Rodiguez (also @ Utrecht) has some nice ideas on combining views and attribute grammars.
01:55:02 <shapr> syntax macros using AGs would be quite spiffy.
01:55:18 * shapr googles for those guys
01:55:48 <shapr> Oh, I have an idiomatic Haskell question/poll.....
01:56:22 <shapr> Richard Braakman stopped using length and started using "atLeast n"
01:56:51 <shapr> and dons mentioned that using 'length' was generally a bad idea in yi, it was one of the costlier calls when profiled.
01:57:25 <shapr> then yesterday there's the "partition doesn't work on infinite lists" email.
01:57:34 <yeti> um - what's yi :) ?
01:57:55 <shapr> it's the programmers editor written in Haskell.
01:59:05 <shapr> So, for efficiency and well-behaved-ness (?) reasons, it's best to have functions that can handle only as much of an infinite list as they need. 
01:59:14 <yeti> can you give me the URL, please? i can't find it with google 
01:59:31 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi
01:59:34 <shapr> do you know darcs?
01:59:54 <yeti> yeah, a CVS-like program written in haskell
02:00:31 <Boegel> has anybody had contant with Meurig Sage in the last few months or so ?
02:00:53 <shapr> Anyway, that's my recent theory, that maybe laziness has greater benefit in Haskell than most people realize, and maybe that's because Haskell library code doesn't always handle laziness well.
02:01:50 <Boegel> his website -> " Last updated January 2001." doesn't look good :s
02:02:06 <shapr> Boegel: the other pages say 2003 :-P
02:02:32 <Boegel> ow :)
02:03:05 <shapr> btw, I've seen at least two othre people asking about FranTk lately.
02:03:12 <Boegel> I would like to send him an email to ask him if it would be hard to implement a pixel coloring function in FranTk, because I'm missing that one...
02:03:12 <shapr> seems like it needs a maintainer.
02:03:26 <shapr> send it over, worst he can do is ignore you...
02:03:28 <Boegel> it does, it hasn't been updated for ages
02:03:35 <Boegel> true :)
02:10:46 <shapr> anyone have any thoughts on laziness and efficiency in Haskell?
02:12:45 <TheHunter> shapr: I think laziness and monads (at least the way things are currently done) don't go together very well.
02:13:07 <shapr> how so?
02:13:12 <maihem> I keep think about it, and I just can't work out what will be efficient and what won't. I can't help thinking, though, that most stuff can be very efficient.
02:13:54 <TheHunter> monads usually force unnecessery strictness.
02:14:45 <shapr> you think monads could be less strict? maybe arrows can do a better job?
02:14:46 <TheHunter> if you have an adt (say a tree) inside monadic code, you can't have side effects associated with the leaves, only with the whole tree.
02:14:46 <Boegel> "Thank you in advance", is that correct English ?
02:14:51 <shapr> Boegel: yes
02:15:37 <shapr> maihem: I agree, in my experience lazily evaluated code can use much less memory and less cpu than strict code.
02:15:45 <TheHunter> I think algebraic data types inside of monads should have a different form than outside.
02:15:47 <shapr> and yes, it's often hard to get it just right.
02:15:56 <maihem> Some things like a recursive definition of sort, should even be possible to rewrite automatically to iterative.
02:16:12 <shapr> can you explain how monadic ADTs could/would be different?
02:16:16 <shapr> I think I understand, but I'm not sure.
02:16:22 <TheHunter> for example, consider combinatorical problems implemented using the list monad
02:16:58 <TheHunter> say we want to find all permutations of [1..n] with a certain property
02:17:19 <shapr> maihem: that part is already done, "tail-call optimization" turns recursion into iteration (if you used tail-calls).
02:17:38 <TheHunter> the easy way is something like do {perm <- perms [1..n], guard $ check perm}
02:18:35 <TheHunter> the only problem is, it is terribly inefficient if the check can already decide that a permutation should be thrown a way after evaluating a part of the list perm
02:19:06 * Boegel pressed "Send mail"
02:19:35 <TheHunter> so this computation is done again and again for every permutation, even though it could be shared between the computations.
02:19:47 <shapr> ?
02:19:47 <maihem> hm, function specialisation could be an option? so the programmer can define new algorithms for certain combinations - sort of rewrite rules?
02:20:07 <shapr> maihem: that exists too, in both pragmas and template haskell
02:20:17 <maihem> cool
02:20:29 <shapr> TheHunter: I don't get it.
02:21:12 <maihem> How about letting the programmer define data that lasts over several checks, provided that the programmer guarantees it is equivalent
02:21:23 <shapr> maihem: like what?
02:21:35 <maihem> so certain computations are explicitly marked for keeping. with a lifetime notation
02:21:38 <maihem> or something
02:21:59 <shapr> oh, common subexpression eliminination... 
02:22:11 <shapr> it's not done by default, but it can be turned on...
02:22:12 <maihem> yeah, GCSE annotation
02:22:25 <maihem> but let the program mark things that are undecideable by the compiler
02:22:27 <TheHunter> what i'm trying to say is, a list inside a list monad shouldn't be [[]] but some more complicated structure like data MList m a = MList m (Maybe (a, MList m a))
02:22:36 <maihem> s/program/programmer
02:22:44 <shapr> there's no lifetime notation, but it's usually simpler to just express the lifetime by doing a "let =" in the correct scope.
02:23:26 <maihem> but should a let mark a lifetime. the programmer should be able to say that the result of a let is valueable in another iteration ?
02:23:27 <TheHunter> shapr: so to each element of the list, we have a monadic side effect
02:24:15 <shapr> would the special monadic list ADT allow for computation sharing?
02:24:16 <Boegel> where can I find the Haskell mailing list ?
02:24:20 <shapr> hoi arjanb 
02:24:25 <xkb> Boegel, haskell.org
02:24:37 <Boegel> are there several ?
02:24:37 <shapr> Boegel: http://www.haskell.org/mailinglist.html
02:24:37 <TheHunter> if we do some computation with the list, which fails early, this wouldn't have to be computed again and again.
02:25:09 <shapr> Boegel: there's about fifteen standard haskell lists for different subjects, and quite a few lib/app-specific lists.
02:25:13 <TheHunter> shapr: yep
02:25:57 <maihem> TheHunter, how does one decide how many common prefixes are to be "cached"?
02:25:58 <shapr> could you write up a working example I could trudge through?
02:26:14 <Boegel> shapr, which one should I consider just to informed about some important stuff on haskell ?
02:26:41 <shapr> Boegel: probably just haskell@haskell.org and haskell-cafe@haskell.org
02:26:48 <Boegel> shapr, okay thanks
02:27:18 <TheHunter> (another thing I noticed is, that this MList is indeed a monad transformer as opposed to the ListT thingy from the haskell libs)
02:28:57 <TheHunter> maihem: i think about the list monad as having a command which enables the programmer to fork the universe. With the monadic ADT, the universe is forked after having inspected only a part of the list, whereas in the usual case, it has to be forked right at the beginning of the computation.
02:29:14 <Boegel> shapr, the mails that get sent to you from the mailinglist, which 'from' adress do they have ?
02:29:26 <maihem> TheHunter, this confuses me :)
02:29:28 <Boegel> just haskell@, or haskell-owner@ or something like that ?
02:29:42 <TheHunter> shapr, maihem : I'll write something up and put it on the paste page, i just have to think about an appropriate combinatorical problem.
02:30:06 <shapr> Boegel: the from address is the author, the to address is haskell@haskell.org or haskell-cafe@haskell.org
02:30:48 <maihem> I get confused because I'm an imperative person, not functional. But I can't seem to do anything about it. I should have studied more at Uni.
02:31:10 * maihem makes a decision. He's buying a good book.
02:31:13 <Boegel> shapr, so it's ot possible to sort the mails on the 'from' adress ?
02:31:45 <Boegel> because I use procmail to sort my mails from our interal university mailing list, and I believe that uses mailman to
02:31:46 <maihem> What's the best for somebody who like imperative programming because he can write some logic, then tack stuff on without making loads of changes?
02:31:50 <Boegel> s/to/too
02:32:40 <TheHunter> maihem: you can do the same kind of thinking in an imperative language. It's just about nondeterministic computations.
02:33:03 <shapr> Boegel: no, but you can sort by the to: address
02:33:20 <shapr> Boegel: or sort by the subject, it has [Haskell] and [Haskell-cafe]
02:33:50 <maihem> yeah, that's it, that's why I have trouble with haskell. It's all the big words. The book I should buy is -> the dictionary ;)
02:35:01 <TheHunter> hmm, i have some weird code here which provides an implementation of a List monad transformer, i think i'll put that on the wiki first.
02:36:46 <shapr> maihem: nah, just big concepts. That's why I like Haskell so much.
02:36:58 <shapr> it's amazing how many nifty ideas fit into Haskell.
02:38:17 <Boegel> shapr, how much mails get sent over those mailing lists every day ?
02:38:39 <shapr> not very many
02:38:48 <Boegel> 5 a day ? something like that ?
02:38:52 <shapr> that sounds right
02:39:10 <maihem> yeah, I look forward to the data that I understand an ounce of it :o/
02:40:17 <Boegel> shapr, the gui@haskell list seems to get spammed a lot :s
02:40:18 <maihem> I can't help thinking that it would be nice to be able to encode the broad logic of a function and add detail, I always seem to end up needing to define all the detail and build up to the broad logic.
02:40:31 <Boegel> if I search the archives, not much sensible has been posted
02:42:05 <shapr> usually I end up writing detail code first, then coming back and noticing how many broad patterns I've used
02:42:22 <shapr> the more I do that, the more I can see the broad patterns ahead of time
02:44:05 <maihem> I like to go "I need to do a, then b, then c" and then work out how to do a, then b, then c. Then work out optimisations and whatnot (caching, etc) and add them on. I suppose the problem is that I don't understand how to write transformers to produce the caching functions that I want from the non-caching versions.
03:08:13 <Boegel> some weird things going on here :)
03:09:09 <TheHunter> shapr, maihem: http://www.haskell.org/hawiki/ListTDoneRight
03:09:12 <shapr> maihem: memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
03:10:41 * maihem squeals
03:11:58 <maihem> ooh, I think I get it.
03:13:47 <shapr> TheHunter: this is nifty
03:14:28 <shapr> btw, is the comment above runListT' purposefully humorous?
03:16:18 <TheHunter> i'd like to say yes, but i'd be lying.
03:16:55 <shapr> it's still humorous =)
03:17:24 <shapr> looks a lot like a lazily evaluated comment... you'll write in the rest as soon as someone asks for it ;-)
03:17:30 * shapr snickers
03:19:47 <Boegel> I think something is wrong with the syntax highlighting file for LHS i downloaded
03:20:16 <Boegel> every time I see Point3D, the 'in' part is coloured, and the rest is black :s
03:20:25 <Boegel> in stead of colouring the whole 'Point3D'
03:22:47 <Boegel> does anybody know what the problem could be ?
03:23:55 <shapr> LHS?
03:24:10 <Boegel> Literate Haskell :)
03:24:41 <Boegel> same problem with hs files :s
03:25:18 <xkb_> Boegel:  what editor?
03:25:55 <Boegel> xkb_, emacs
03:27:12 <Boegel> how do I take a screenshot in linux ?
03:27:19 <Boegel> nevermind ;)
03:29:21 <Boegel> http://studwww.ugent.be/~kehoste/screenshot.png
03:29:35 <Boegel> see the 'Nothing' keyword
03:33:50 <xkb_> lol
03:34:04 <xkb_> looks like a problem with the keyword scanner :D
03:34:28 <Boegel> and nobody ever noticed that ?
03:43:49 <Boegel> xkb_, can I solve the problem or is it out of my hands ?
03:44:18 <xkb_> Boegel: Im an avid vim user (and eclipse atm)
03:44:42 <xkb_> so I really dont know :d
03:47:15 <Boegel> okay, I'll figure it out
03:47:19 <Boegel> have to go now, bye !
04:04:19 <xkb_> ∂ß <- testing
04:09:23 <bourbaki> moin
04:09:23 <shapr> y0
04:09:23 <bourbaki> @arr
04:09:23 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
04:11:10 <shapr> swiert: what the correct input for Parrowsec's test2 ?
04:11:43 <shapr> @fortune
04:11:44 <lambdabot> Yow!  I'm having a quadrophonic sensation of two winos alone in a steel
04:11:44 <lambdabot> mill!
04:11:51 <swiert> shapr: either "cc" or "aa" should parse correctly.
04:12:01 <shapr> ah
04:12:37 <shapr> oh, I see
04:12:45 <shapr> "cc " or "aa "
04:13:52 <swiert> you can read <+> as "or"
04:16:12 <bourbaki> is there a way to make functions with chars infix without the '' ?
04:18:32 <Lemmih> Chars as in a-z?
04:19:34 <bourbaki> yep
04:19:46 <Lemmih> Then no.
04:20:07 <bourbaki> why is that ? cant i tag them somehow beginning and end?
04:20:17 <bourbaki> ok nm :) then it would be like '' :)
04:22:24 <Lemmih> You can't mix special characters with letters (a-zA-Z_).
04:24:31 <bourbaki> hm i guess ill just use the '' notation then
04:27:16 <Lemmih> Anyone feeling like helping me with some Greencard code?
04:30:19 <shapr> kosmikus: ok, you can commit directly to the lambdabot darcs repo
04:30:27 <shapr> assuming my mail server is setup correctly
04:36:47 <kosmikus> shapr: where is the lambdabot darcs repo?
04:41:36 <shapr> kosmikus: http://www.scannedinavian.org/repos/lambdabot
04:41:48 <shapr> and I haven't yet applied the patches you sent me =)
04:42:06 <shapr> http://www.scannedinavian.org/cgi-bin/darcs.cgi/lambdabot/?c=browse
04:48:18 <Lemmih> Is greencard outdated? If so, what should I use instead?
04:48:53 <peti> Lemmih: hsc2hs is pretty good. And there is a greencard version in the works that's based on template meta-programming.
04:52:29 <tromp> is there a comparison of all 6 different FFI preprocessors?
04:52:45 <peti> Not that I am aware of.
04:53:07 * peti thinks hsc2hs is best because it (a) comes with GHC and (b) is simple to use.
04:53:22 <peti> Greencard et all come with amazing features ... which I didn't need.
04:53:34 <tromp> let's ask google for a comparison:)
04:53:57 <tromp> haskell greencard: 3910 hits
04:54:27 <EviL_DORK> nothing like haskell to make me feel like I can't cut it as a programmer, argh
04:54:40 <tromp> haskell haskelldirect: 953 hits
04:55:06 <tromp> haskell c.to.haskell: 188 hits
04:55:31 <EviL_DORK> at least it's not java or c#
04:55:35 <tromp> haskell hsc2hs: 1890 hits
04:56:45 <tromp> haskell qforeign: 310 hits
04:56:45 <tromp> haskell kdirect: 29 hits
04:56:49 <tromp> i shld make a script do automate these coparisons:)
05:00:24 <tromp> this makes my head spin:
05:00:26 <tromp> In the following, “Haskell file” is the main output (usually a .hs file), “compiled Haskell file” is the Haskell file after ghc has compiled it to C (i.e. a .hc file), “C program” is the program that outputs the Haskell file, “C file” is the optionally generated C file, and “C header” is its header file.
05:01:11 <musasabi> morning
05:01:18 <tromp> which of these files does the human write in the first place?
05:01:24 <musasabi> What is new in the haskell world?
05:02:08 <peti> musasabi: Made a Postmaster release moments ago.
05:02:35 <peti> Not exactly breath-taking news, I realize. :-)
05:03:58 <Lemmih> musasabi: Giving new life to mod_haskell.
05:07:01 <musasabi> Lemmih: sounds nice, are you going to the lisp direction (a process connected with a pipe to apache) ?
05:07:01 <musasabi> peti: I have to look at it when I get some time..
05:07:07 <peti> musasabi: Cool. 
05:07:16 <marcot> Good morning.
05:07:23 <peti> Right now, nobody is using it but me, that's a little weird. :-)
05:09:09 <Lemmih> musasabi: Nope.
05:11:35 <musasabi> Lemmih: so how does it work?
05:12:29 <Lemmih> I'm creating a module in C which will then give control to Haskell.
05:13:32 <emu> how are you doing the haskell runtime
05:13:39 <emu> keeping it running?
05:13:48 <emu> or reloading it each time?
05:15:39 <emu> which implementation are you using
05:16:16 <musasabi> that should be easy, but what about sharing state?
05:16:52 <Lemmih> The haskell runtime environment will always be loaded.
05:17:14 <emu> so how is this different from what mod_lisp or java does?
05:18:23 <Lemmih> I haven't used mod_lisp nor Java so I'm not sure.
05:18:35 <emu> there's nothing particularly "lisp-specific" about mod_lisp really
05:18:46 <emu> it should be called mod_shim
05:18:49 <emu> or something
05:19:49 <emu> it just has a simple protocol for talking to some running process
05:24:19 <Philippa> Lemmih: lemme know when you've got something working properly so I can figure out what it'd take to get Flippi working well with it?
05:56:08 <kosmikus> shapr: did my patches arrive?
06:13:31 <xkb_> is catch of Control.Exception compatible with the fail function?
06:14:35 <tromp> @index fail
06:14:36 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
06:14:36 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
06:14:36 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
06:15:59 <pesco> xkb_: Yes, I take it you mean fail for the IO monad? That calls error, which raises a UserError exception. You can catch that.
06:16:14 <xkb_> pesco: yes
06:16:36 <xkb_> ok. that's nice
06:17:25 <xkb_> So can skip that part of my article :D. Older implementations did not yet throw exceptions if i'm correct
06:17:35 <xkb_> *insert I there*
06:24:13 <Lemmih> Philippa: Sure.
06:25:09 <Philippa> interesting - you took exactly an hour to respond :-)
06:25:53 <Philippa> anyway, am just writing some extra docs then hopefully I'll be able to put out Flippi 0.03 today
06:26:18 <peti> Philippa: What do I need to run Flippi? Is it a CGI?
06:28:03 * shapr plays original german beatles LPs at 33rpm
06:28:39 <dash> shapr: good morning
06:28:40 <shapr> kosmikus: not yet, lemme check the logs
06:28:46 <shapr> y0 dash, wassup?
06:29:23 <shapr> I bought my woman an LP player for her birthday... and she'll be home in two hours. Can't wait till she sees it =)
06:29:27 <dash> shapr: i think i've got a full interpreter set up
06:29:31 <dash> shapr: only one problem 
06:29:35 <shapr> ?
06:29:59 <dash> hmm, it may not be a problem. hold on i'll check :)
06:30:50 <shapr> hey peti, did I already ask you for ideas on running multiple MTAs on virtual hosts?
06:33:19 <peti> shapr: No, you didn't. :-)
06:33:48 <peti> shapr: It's no problem, but I yet haven't decided on the best way to do it.
06:34:12 <shapr> I have *.ScannedInAvian.{com,org,net} and I'd like to run postmaster on ScannedInAvian.net only, but they're all on the same ip.
06:34:33 <peti> I could have Postmaster listen on different interfaces with different configurations, or I could have postmaster listen on any_addr and have tho configuration do different things depending on the peer's IP address. Not sure what is better.
06:35:05 <peti> shapr: Make it accept e-mail for your domain as local and relay everything else. That should work nicely.
06:41:11 <pesco> Soon, the whole world will know my name!
06:41:49 <shapr> pesco: um, why?
06:41:56 <shapr> hiya pesco, wassup?
06:41:58 <pesco> I just registered pesco.de.
06:42:01 <shapr> oh, neat!
06:42:09 <pesco> And I have an IPv6 tunnel.
06:42:12 <shapr> spiffy!
06:42:33 <pesco> And I control my DNS zone.
06:42:39 <shapr> you could have registered pes.co.de
06:42:53 <pesco> .de is not devided like .uk.
06:43:02 <shapr> and then you'd get fun.co.de ,obfuscated.co.de, etc
06:43:17 <Igloo> {less.talk.,}more.co.de
06:43:20 <shapr> haha
06:43:21 <shapr> that too
06:43:32 <pesco> That's good.
06:44:06 <pesco> But co.de is invalid, currently.
06:44:10 <shapr> oh, too bad.
06:44:51 <peti> pesco: What's you IPv6 address? Or hostname?
06:45:05 * shapr smacks postfix
06:45:07 <tuomov> individuals still can't register .fi domains.. you have to set up a fake company or non-profit organisation to register a domain
06:45:18 <pesco> peti: 2001:6f8:900:3f7::2
06:45:41 <shapr> I considered fluf.fi, hi.fi, or sci.fi ... lots of good choices for .fi names.
06:45:46 <pesco> will be arctic.pesco.de as soon as the registration compledes.
06:45:48 <peti> Let's check whether you forgot to configure iptables for v6. *grin*
06:45:58 <tuomov> sci.fi used to be an isp in the modem days
06:45:58 <shapr> someone recently registered moo.se :-/
06:45:58 <pesco> shapr: Oh my god. Get sci.fi.
06:46:09 <pesco> Wah! The Moose!
06:46:16 <tuomov> then it got bought by a bigger isp that still has to domain afaik
06:46:29 <tuomov> yep
06:46:39 <shapr> and plea.se is registered now too.
06:46:45 <pesco> Chr.
06:46:54 <shapr> chrr?
06:47:00 <peti> pesco: No services on v6 but SSH yet?
06:47:13 <pesco> peti: No services on v4 but SSH yet.
06:47:21 <peti> Oh. :-)
06:47:30 <peti> Anyway, I can ping you. Whatever that's worth. :-)
06:47:42 <shapr> oh hey, someone in the UK is doing a dictionary attack on the ScannedInAvian ssh server via IPv6, any suggestions for good honeypots?
06:47:47 <peti> Now all we need is v6 support in Haskell.
06:47:48 <pesco> peti: Good to know.
06:47:54 <shapr> yes v6 in Haskell!
06:47:57 <shapr> it wouldn't be hard!
06:48:02 <pesco> peti: Er, shouldn't we have it?
06:48:10 <peti> pesco: Nope.
06:48:14 <pesco> Gah!
06:48:16 <peti> You can't make an inet6 sockaddr.
06:48:40 <pesco> Eahaa. *grumble*
06:48:41 <peti> It's not difficult to do, it just has to be done. 
06:48:44 <shapr> right
06:48:47 <shapr> like many things.
06:49:15 * peti is about to buy the Silbermond CD. That's the second they play from that album and I like them both.
06:49:21 <pesco> This should be hidden anyway. What are the POSIX functions called?
06:49:47 <peti> pesco: You don't have separate functions to use the socket, but you have different sockets.
06:49:52 <pesco> peti: Oh, my new favourite is Beborn Beton - Mantrap.
06:50:06 <peti> Wir steeeehen hier im Regen ....
06:50:19 <peti> Pop music rules. ;-)
06:50:41 <shapr> I just found some German Pop Music from the late sixties. It's interesting stuff.
06:50:45 <pesco> peti: man getaddrinfo.
06:50:50 <peti> shapr: Kraftwerk? :-)
06:50:50 <pesco> shapr: Ugh.
06:50:52 <pesco> :)
06:51:00 <shapr> It's even more interesting at 45 rpm when the LP is 33.
06:51:43 <shapr> was kraftwerk ever pop music?
06:51:58 <peti> pesco: Well, it was popular here. So I guess it was. :-)
06:52:12 <shapr> There is the occasional really good german pop music, I still love 99 balloons.
06:52:50 <peti> pesco: IMHO v6 support in Haskell should bring along a real data type for IP addresses. The current representation is pretty much unusable with out FFI functions, unfortunately.
06:53:00 <tromp> i love Propaganda
06:53:12 <tromp> too bad my CD got stolen from a gym:(
06:53:23 <pesco> Those are bad places.
06:53:33 <shapr> mp3 players are easier to steal, and then you still have your CDs
06:53:34 <peti> shapr: Nena? Cool stuff. Do you know "Irgendwo, Irgenwann" from her?
06:53:42 <shapr> no, sorry.
06:53:57 <shapr> My kind of german music is stuff like Rammstein.
06:54:08 <shapr> sick lyrics, admittedly, but nice music.
06:54:48 <pesco> Yah, Rammstein rules if you don't know German. :)
06:54:54 <shapr> truly.
06:54:55 <peti> shapr: Rammstein sounds great. 
06:55:02 <tuomov> I never listen to lyrics anyway
06:55:12 <pesco> shapr: Do you know the Schneider remix of Slick Idiot - Xcess.
06:55:13 <pesco> ?
06:55:14 <shapr> You really don't want to know the Rammstein lyrics.
06:55:40 <shapr> no I don't, similar sound?
06:55:46 <tuomov> In case of concept albums I may follow through the lyrics once or twice, but usually I don't care for them
06:56:05 <shapr> My favorite concept album is "operation mindcrime"
06:56:11 * shapr has heavy metal flashbacks
06:56:12 <pesco> Exactly. The lyrics are cool, and it sounds like slick idiot on rammstein. Awesome.
06:56:32 <tuomov> operation mindcrime is cool
06:56:57 <shapr> my cd got 'sanded' by falling out of my big book of CDs :-(
06:57:33 <shapr> I have a non-working Operation Mindcrime CD, and a promise to myself that I won't buy anything from big record companies until those companies stop being stupid. Dang.
06:58:00 <tuomov> yeah, I boycott the big ones too
06:58:11 <tuomov> unfortunately, they've been buying out smaller record labels...
06:58:26 <pesco> shapr: look for www.scannedinavian.org:/home/pesco/*.mp3
06:58:26 <shapr> yah, much suckage.
06:58:43 <shapr> !
06:59:02 <pesco> shapr: Oh, it's not completed. My upstream is slow. Wait one minute.
06:59:06 <shapr> oh
06:59:06 <peti> Bah. runInteractiveProcess does _still_ leave zomies around. :-(
06:59:34 <shapr> lambdabot has zombie problems too, one with every @info and @type call.
06:59:49 <peti> shapr: Does it fork to answer those?
06:59:51 <monochrom> Yuck
07:00:54 <peti> The problem is that you have to wait for the child to avoid a zombie, but more often than not these waits will never return! 
07:01:25 * peti is considering using fork/exec directly. :-(
07:02:36 <monochrom> you are supposed to install a SIGCHLD handler. the handler is only run when a child finishes; it calls wait() and we know it won't block.
07:03:03 <monochrom> either that, or wait in a separate thread, or select()
07:05:00 <monochrom> or you daemonize.  parent spawns child and wait for it; child spawns grandchild and dies immediately. grandchild is orphaned (now adopted child of init), parent's wait returns promptly
07:05:13 <shapr> can I have some interface where it's a string in, and the results from the child as IO String ?
07:07:31 <shapr> I'd like two interfaces, the one I just described, and another where I get a read/write handle to/from the child.
07:07:40 <monochrom> I suppose you can.
07:10:47 <peti> monochrom: If I have to install handlers and do special process creation stuff, what's the point of runInteractiveProcess then? I wait for every process I fork (through finalizers), but -- honest to god -- it simply doesn't _work_ reliably. 
07:10:49 <musasabi> SIGCHILD is not necessarily the best option.
07:11:15 <peti> About 1 in 100 waitForProcess calls never returns. 
07:11:22 <musasabi> because zombies will become to haunt you if signals are not reliable.
07:11:27 <peti> And I _have_ called terminateProcess and closed all handles before I call it.
07:12:00 <musasabi> peti: I have some code with fork+exec+wait in haskell if you want
07:13:00 <tuomov> I'd like to get events instead of signals from the kernel, and then just write a simple event-processing mainloop
07:13:19 <musasabi> backwards compatiblity is signal hell
07:13:23 <musasabi> and portablity too
07:14:02 <tuomov> of course there are a few things related to killing the problem that must be signals
07:14:08 <tuomov> s/problem/program
07:20:32 <peti> musasabi: Please, I'd be interested to see that! Could you mail it to <simons@cryp.to>?
07:25:26 <musasabi> peti: ok, I'll send it.
07:28:43 <peti> musasabi: Thanks!
07:28:51 * peti has to reboot.
07:30:25 <kosmikus> bourbaki: you obviously belong to those people on #latex who ask questions and aren't patient enough to wait for answers ;)
07:34:11 <mikael> hey, postmaster is really cool
07:34:24 <mikael> all software should be like that
07:34:30 <mikael> it's like the IKEA of software
07:41:48 <Leimy> dons: around?
07:47:18 <kosmikus> desrt: ping?
07:48:36 <EviL_DORK> how do you get functions to return two values?
07:49:52 <bourbaki> kosmikus no im one of those ppl who solve it in the mean time :)
07:50:06 <tuomov> EviL_DORK: pass them in a tuple?
07:50:24 <tuomov> (x, y)
07:54:15 <EviL_DORK> tuomov: I'm not passing them in a tuple
07:55:54 <kosmikus> bourbaki: ok, nm then
07:56:43 <kosmikus> EviL_DORK: tuomov was giving an answer, not asking a question
07:58:41 <EviL_DORK> ah ok
07:58:48 <EviL_DORK> well I'm at a loss then
08:00:12 <tromp> @indec divMod
08:00:13 <lambdabot> Sorry, I don't know the command "indec", try "lambdabot: @listcommands"
08:00:17 <tromp> @index divMod
08:00:18 <lambdabot> GHC.Real,Prelude
08:00:28 <tromp> @type divMod
08:00:29 <lambdabot> divMod :: forall a. (Integral a) => a -> a -> (a, a)
08:00:41 <tromp> that one returns two values
08:01:04 <dash> hey, i work there
08:01:31 <EviL_DORK> I would like to call a function with the first two strings in the stringlist returned by getArgs
08:02:26 <tromp> case getArgs of a:b:_ -> function a b
08:03:07 <EviL_DORK> wow
08:03:07 <EviL_DORK> thanks
08:03:15 <EviL_DORK> that wouldn't have occurred to me in a million years
08:04:27 <tromp> it would if you read some of the great tutorials available
08:07:01 <pesco> But it's not correct. EviL_DORK: do { (a:b:_) <- getArgs; ... } 
08:07:04 <EviL_DORK> I'm still working on those, just got stuck
08:08:56 <EviL_DORK> I'm partway through "a gentle introduction...."
08:09:16 <EviL_DORK> just wanted to see what happens if I were to try to run my program from the command line instead of the interpreter
08:11:24 <tromp> @type getArgs
08:11:25 <lambdabot> bzzt
08:11:36 <tromp> @index getArgs
08:11:36 <lambdabot> System.Environment,System
08:11:44 <tromp> @type System.getArgs
08:11:46 <lambdabot> System.getArgs :: IO [String]
08:12:20 <tromp> ah, right, pesco
08:31:18 <Leimy> q/quit
08:31:25 <pesco> Haha!
08:31:31 <pesco> Damn, missed him.
08:43:03 <shapr> cool, 99 clients
08:43:32 <dash> your channel is 2/3rds full!
08:43:44 <monochrom> the 100th client get a free copy of ghc!
08:43:55 <monochrom> Yay!
08:44:00 <dash> bing bing bing bing
08:55:35 <Jan_w> what's the best way to find the last element that matches in a list ? findlist a = elemIndex ',' (reverse a) ? will performance be very bad on large lists ?
08:57:01 <tromp> will be linear
08:57:17 <monochrom> reversing first is probably the fastest way
08:57:41 <monochrom> Actually not the fastest, but reasonably fast and easy to code
08:57:46 <Igloo> But without already having some sort of lookup table or other datastructure it's inherently linear anyway
08:58:23 <monochrom> It is possible to do it in just one pass. The code is less obvious.
08:58:51 <Igloo> It's not /that/ bad, but only worth doing if profiling points fingers at it
08:59:04 <monochrom> Right.
08:59:05 <Jan_w> why is it so easy to take the head by doing (a:as 
08:59:26 <pesco> That's a constructor match.
08:59:26 <Jan_w> (a:as) and so diffculy to do for the last element
08:59:38 <monochrom> Because nothing is perfect.
08:59:41 <pesco> Because the list is singly-linked.
08:59:48 <tromp> the one pass can be written as a foldl
09:00:36 <Jan_w> pesco: ok, that makes sence than
09:01:28 <Jan_w> i didn't know lists where implemented as linked-lists
09:01:36 <tromp> but the reverse one may be faster than the one-pass anyway
09:02:01 <pesco> fst . head . filter ((==',') . snd) . zip [0..]
09:02:06 <Igloo> The one-pass ought to be fastest, but not when written as a foldl due to laziness
09:02:10 <pesco> What about that?
09:02:28 <pesco> Er I meant, last. I think.
09:02:33 <pesco> That's what you wanted, right?
09:02:52 <tromp> the one-pass ends up doing a lot of extra tests
09:03:08 * Jan_w is thinking, i can't bend my mind around . like this :)
09:03:27 <tromp> in case the sought element is really at the end
09:04:17 <Igloo> You could say last . elemIndices ',' or something couldn't you, modulo error handling?
09:04:19 <Jan_w> pos = elemIndex ',' (reverse a)	
09:04:26 <Jan_w> ?
09:04:40 <pesco> Igloo: or that.
09:04:59 <pesco> Jan_w: Hm, that will give you the index counting from the back of the list. Is that what you want?
09:05:22 <Jan_w> pesco: If i understand correctly you solution will build a lists of pairs with all matches ?
09:05:46 <pesco> Jan_w: Right. The pair has the match and its index.
09:06:21 <Jan_w> hm, thats basicly even better anyway 
09:06:25 <Jan_w> hmm
09:06:26 <Jan_w> ok
09:06:27 <Jan_w> thanks
09:10:08 <Jan_w> how do i convert a Maybe Int to Int ?
09:10:21 <Jan_w> where Nothing becomes 0 ?
09:10:24 <tromp> patternmatching?
09:10:47 <pesco> fromMaybe 0
09:10:48 <pesco> I think?
09:10:55 <pesco> @type fromMaybe
09:10:57 <lambdabot> bzzt
09:11:04 <pesco> @type Data.Maybe.fromMaybe
09:11:05 <lambdabot> Data.Maybe.fromMaybe :: forall a. a -> Maybe a -> a
09:11:10 <pesco> Yes.
09:11:26 <TheHunter> @type maybe
09:11:28 <lambdabot> maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
09:12:00 <Jan_w> ah great, beautiful such is haskell
09:12:11 <pesco> Don't you love stuffing reference manuals in your head? I do.
09:12:34 <Jan_w> pesco: hehe
09:13:07 <Jan_w> pesco: i'm just learing haskell, i'd never seen Maybe before today :)
09:25:55 <tintin> hello all
09:26:22 <Lemmih> Hey tintin.
09:26:34 <Lemmih> Yay. GHC rocks!
09:27:01 <Igloo> ?  :-)
09:28:11 <tromp> are there any haskell irc clients?
09:29:00 <Lemmih> I made a C program which evaluates a Haskell function. And it was really easy.
09:29:43 <Lemmih> tromp: There's hercules and hirc. But I don't think they're maintained anymore.
09:29:53 <mikael> s/hercules/hircules/
09:29:59 <tromp> thx, lemmih
09:30:56 * Igloo wonders if I should say "Yi IRC mode" or not  :-)
09:31:06 <tromp> does the C program link to the .hc, lemmih?
09:31:36 <Philippa> Lemmih: dammit, you've just reminded me I'd been frigging about with the idea of writing one using wxHaskell
09:31:44 <musasabi> is the IRC.hs client code that floated somewhere one of them.
09:31:49 <musasabi> _
09:31:49 <musasabi> ?
09:32:07 * musasabi tries to write one sentence without typos.
09:32:16 <musasabi> Igloo: sounds nice..
09:32:25 <Philippa> think I'll leave that 'til Flippi's run the course ideas-wise though
09:32:33 <Lemmih> tromp: .hc? I compile the C file with gcc and the haskell file with ghc. Then I link them together with ghc.
09:33:53 <Lemmih> I thought messing with the Haskell runtime would be messy.
09:35:21 <musasabi> no it is easy and clean as is doing FFI
09:36:57 <Igloo> It /is/ part of the FFI
09:37:29 <tromp> running hircules now, it just hangs
09:37:41 <tromp> Exception: Maybe.fromJust: Nothing
10:09:04 <kosmikus> has anyone heard from hdaume recently?
10:21:04 <stepcut> any made a yi keymap for emacs yet ?
10:21:26 <stepcut> er
10:21:31 <stepcut> emacs keymap for yi
10:47:46 <shapr> ooh, 100 clients on #haskell
10:47:48 <shapr> neat
10:48:03 <bourbaki> :)
10:48:08 <pesco> Hah, that's that.
10:48:34 <stepcut> much better...
10:48:36 * shapr grins
10:48:44 <pesco> :-)
10:50:34 <stepcut> I wonder what the best way to define an emacs keymap for yi is... it would be nice to preserve the ability to change keybindings on the fly without having to update Keymaps.hs (ie, the new bindings will be lost when the session ends)
10:50:39 <shapr> kosmikus: coupla months ago I emailed him about NewBinary
10:51:02 <stepcut> shapr: and ??
10:51:28 <shapr> er, I think he sent me the version I already have.
10:51:44 <stepcut> does he intend to do any more work on it ?
10:51:53 <shapr> I don't remember, I'll have to check my mails.
10:52:55 <shapr> stepcut: yah, I'd like to modify keymaps on the fly too
10:53:39 <stepcut> shapr: I got NewBinary to build last night (again), by the end of this weekend, I hope to have it cabalized+debianize and imported into darcs/arch
10:53:54 <stepcut> and add a wiki page about it
10:53:58 <shapr> ah, nifty
10:54:25 <stepcut> and then, hopefully, we (the community) can start discussing what is there, and where it needs to be in order to be integrated into the official tree
10:54:36 <musasabi> NewBinary sounds nice..
10:54:50 <stepcut> I *really* need it...
10:55:01 <musasabi> stepcut: does it support lazy loading of binary files and/or mmap ?
10:55:01 <shapr> and the rest of us could really use it.
10:55:18 <shapr> I can put a darcs repo on ScannedInAvian if you want.
10:55:24 <stepcut> musasabi: i think so, but I am not sure
10:55:40 * musasabi has some code doing such things but not binary stuff precisely
10:56:24 <stepcut> musasabi: I believe it handles bitstreams (aka read the next 3 bits), which is good news for me
10:57:43 <stepcut> shapr: I have an idea for emacs bindings in yi
10:57:44 <musasabi> bitstreams are imho quite worthless, as there are two common usecases 1) need fast read => alignment (byte boundaries) is important 2) need compact size => compression 
10:58:03 <shapr> stepcut: oh tell me more
10:58:51 <shapr> I want to dump emacs and use Yi
10:58:52 <stepcut> musasabi: how do you propose reading existing file formats that are based on bitstreams ?
10:58:57 <Igloo> I used a (very inefficient) bit stream when I wanted to do Huffman decompression
10:59:07 <shapr> but I need 1) emacs bindings 2) irc client code in Yi
10:59:32 <stepcut> shapr: are you familiar with how the currently vi keymap works ?
10:59:55 <musasabi> stepcut: outside compression formats very few things are based on bitstreams, but rather on bytes or even words.
11:00:16 <shapr> er, yes, I think so.
11:00:19 <shapr> it's just a function from key to action
11:00:51 <stepcut> musasabi: .swf files 
11:01:29 <stepcut> shapr: more or less, the keymap function has the tye keymap :: Char -> IO Keymap
11:01:33 <stepcut> data Keymap = Keymap (Char -> IO Keymap)
11:02:32 <stepcut> so keymap takes a Char, and returns a (wrapped) function that takes a char and returns a (wrapped) function that takes a char and...
11:03:01 <shapr> you like? dislike?
11:03:07 <stepcut> that is fine
11:03:12 <stepcut> it's how you use it that matters
11:03:43 <stepcut> in the vi keymap he starts with a toplevel function, cmd
11:03:49 <musasabi> btw a "Chan KeyEvent" is a nice working abstraction..
11:03:57 <shapr> yah, Chans are handy.
11:04:01 <stepcut> so, keymap c = cmd c
11:04:53 <stepcut> cmd does matching on single character commands like hjkl 
11:05:26 <stepcut>     | c == 'h' || c == '\^H'  || c == keyLeft
11:05:26 <stepcut>     = leftOrSolE (fromMaybe 1 mi) >> nextCmd
11:06:05 <stepcut> if you have a multiple character command, then he invokes a new function to handle the remaining characters
11:06:14 <stepcut> for example something prefixed with ':'
11:06:24 <stepcut>     | c == ':'   = msgClrE >> msgE ":" >> nextEx 
11:07:45 <stepcut> he sees the ':', and so instead sticking a call to cmd at the end (aka nextCmd), he switches to the ex function, which is a special function for handling things that start with ':'
11:08:32 <stepcut> but, that seems difficult to extend without redefining the actual functions cmd and ex
11:09:47 <stepcut> so, I would propose for emacs bindings, to move the bindings into a data structure, and have a generic handling function that looks up the values in the data structure
11:09:54 <shapr> yes, dons mentioned switching to Chilli's lazy lexer code
11:09:58 <stepcut> an assoc list for example
11:10:05 <shapr> at least, that was the most recent discussion
11:10:07 <dash> are you going to implement the kill ring? :)
11:10:14 <dash> and the mark ring? :D
11:10:24 <shapr> and the brass ring?
11:10:40 <dash> what is that
11:10:50 <stepcut> so the data structure might be like: [("C-p", prev),("C-n",next),("C-x C-c",quit)]
11:10:58 <stepcut> and the cmd function would be like:
11:11:09 <shapr> a brass ring is on a merry-go-round, and if you grab the brass ring you get another ride.
11:11:18 <stepcut> cmd :: String -> Char -> IO Keymap
11:11:39 <stepcut> where the String is the unevaluated command sequence so far
11:11:53 <stepcut> normally it would be ""
11:12:14 <shapr> well, write it up, send in a patch
11:12:28 <shapr> I mean, "code it up"
11:12:32 <stepcut> so you would call: cmd "" '\^P' , and that would look up C-p in the hash table an run prev
11:13:11 <shapr> personally, I think it's best to argue via patches or unit tests, but I don't mind if they accompanying text :-)
11:13:44 <stepcut> but if you hit C-x it would find that C-x is not a complete entry, so it would return (cmd "\^X")
11:14:07 <stepcut> and then if you hit C-c, it would find that C-x C-c is a command...
11:14:16 <Igloo> Why's that better than returning the ^X keymap?
11:14:58 <Igloo> It makes your lookups O(number of commands) rather than O(number of characters * length of command) too
11:15:00 <stepcut> Igloo: hrm, actually, I think you are right about that
11:16:32 <stepcut> Igloo: I just need to be able to store my keybindings in a data structure, so, I could just make that datastructure a tree 
11:17:11 <stepcut> and maybe every node has an implicit C-g child
11:18:42 * stepcut ponders the best data structure
11:19:31 <stepcut> I was actually considering a hashtable instead of a list
11:19:52 <shapr> why not a lazy lexer?
11:20:00 <stepcut> but one thing I might want to know is, "if the user has hit C-x, what valid keystrokes could he hit next"
11:20:08 <shapr> right
11:20:13 <shapr> that's C-h
11:21:04 <stepcut> shapr: it would depend on how the lexer was built. The way the currently Keymap is built, I can not see how to change the bindings without modifying the functions and recompiling the module and reloading it...
11:22:00 <shapr> ok, why not switch to a finitemap then?
11:22:13 <stepcut> that might work
11:22:16 <shapr> like the Trie that Igloo suggested
11:22:40 <shapr> Keymap :: FM Key (Action | Keymap)
11:23:05 <stepcut> yeah, that might be the ticket!
11:23:53 <stepcut> I knew someone had designed the right datastructure years ago...
11:24:14 <musasabi> Data.Tree maybe even
11:24:22 * shapr looks at Data.Tree
11:24:25 <musasabi> then again that is not very optimized
11:24:54 <shapr> well, it might be fast enough anyway
11:25:16 <shapr> "Worse Is Better" says that simplicity of implementation is often superior to speed of execution
11:25:43 <Igloo> Optimisation should be primarily profiler-driven anyway
11:25:56 <shapr> with open source, simplicity of implementation is almost always superior to anything, because it's much more likely other people will send you patches
11:28:05 <stepcut> musasabi: With Data.Tree, the single character commands will all be in a linear list, which could be quite long... but maybe not long enough to matter
11:28:42 <Philippa> In case anybody here's bothered, Flippi 0.03 is now out! www.flippac.org/projects/flippi/ - you heard it here first
11:29:42 <shapr> yay flippi!
11:29:59 <Igloo> :-)
11:30:26 <shapr> speaking of which, I have some flippi extensions I wrote
11:30:31 <shapr> where do I put them?
11:30:35 <stepcut> gah! mv != rename
11:31:12 <Philippa> shapr: wherever feels good. Create a FlippiExtensions page off the FrontPage of the main copy and link to them there?
11:32:03 <goron> stepcut: What does rename do anyway?
11:32:31 <stepcut> goron: well, the problem is really with mv
11:33:02 <stepcut> goron: if I do mv file1 file2 to rename a file, but file2 is actually a directory, then I don't get an error, and I don't get what I want
11:33:28 <goron> stepcut: Ah, I see, I need regexe's.
11:36:00 <goron> I should say rename file1 file2, should rename file1 to file2. But it doesn't. It doesn't say in the docs it should, but I think it should :)
11:37:14 <goron> This is what's on the top of the manpage: Perl Programmers Reference Guide 
11:37:31 <stepcut> to make things more confusing, I didn't actually mean the rename(1) command, I was really only refering to my displeasure with mv(1)
11:40:37 <goron> What does the 1 means in rename(1)? The number of minimal arguments for a useful operation of the program?
11:41:04 <stepcut> goron: section it shows up in man
11:41:32 <stepcut> goron: sometimes the same keyword shows up in different sections of the man pages, so you have to specify which section you mean
11:41:41 <stepcut> for example:
11:41:43 <stepcut> man 1 rename
11:41:44 <stepcut> man 2 rename
11:41:49 <stepcut> return different pages
11:42:19 <stepcut> the manpages themselves us the syntax mv(1) to indicate mv in section 1
11:42:38 <goron> So command() is undefined?
11:42:39 <Philippa> so like namespaces, only undecipherable
11:44:09 <Igloo> command() is meaningless in the sense of manpage references
11:44:10 <stepcut> goron: i guess... its only intended to be human readable...
11:44:19 <stepcut> (i think)
12:20:18 <Lemmih> Greencard is confusing.
12:27:12 <stepcut> Greenland is HUGE!!
12:27:36 <goron> Anyone that can build Yi *with* CWString?
12:28:11 * stepcut builds Yi however it comes out-of-the-box
12:29:48 <goron> CWString.hsc:288:4:
12:29:48 <goron>     Ambiguous occurrence `withCWString'
12:29:48 <goron>     It could refer to either `Yi.CWString.withCWString', defined at CWString.hsc:182:0
12:29:51 <goron>                           or `Foreign.C.String.withCWString', imported from Foreign.C.String at CWString.hsc:70:0-22
12:30:00 <goron> This kind of errors I get. 
12:30:05 <goron> It's in the README.
12:31:07 <goron> But I have no idea of how I should overcome this problem (except for disambiguing).
12:31:46 <goron> I have a standard debian install of ghc-cvs + nightly CVS snapshot of hs-plugins. 
12:32:16 <stepcut> I use ghc 6.2.2, maybe they added withCWString to the standard libs in ghc-cvs ?
12:35:01 <goron> stepcut: I will try it. 
12:36:10 <stepcut> if that is the problem, you could just modify the import Foreign.C.String  to import Foreign.C.String hiding (withCWString) or something...
12:44:48 <musasabi> I had those problems and added some ifdefs to fix it.
12:46:01 <goron> I got Yi now :)
13:22:34 <Lemmih> Hey SyntaxNinja.
13:22:39 <SyntaxNinja> hihi Lemmih
13:53:13 * Igloo is a great fan of importing with explicit imports
15:17:28 <LAPA> hello
15:18:24 <arjanb> hello
15:20:57 <Lemmih> Hey
15:21:12 <arjanb> LAPA: learning Haskell?
15:21:18 <LAPA> nop
15:33:26 <mattam> how do you name the two axis in a 2D graph ?
15:35:09 <Igloo> x and y?
15:35:27 <Igloo> I think I must be misunderstanding the question - or is it a language/country thing?
15:35:30 <mattam> more abstractly
15:35:58 <Igloo> Do you mean something along the lines of domain and codomain/range?
15:36:14 <mattam> more concrete than that :)
15:36:20 <LAPA> I know in my language
15:36:30 <LAPA> abcissa ordenada
15:36:31 <mattam> we say 'abscisse' and 'ordonne' here
15:36:43 <mattam> :)
15:36:51 <mattam> italian ?
15:36:55 <LAPA> nop
15:36:56 <LAPA> portuguese
15:36:59 <mattam> pt ?
15:37:03 <LAPA> yes
15:37:04 <mattam> oh yeah
15:37:39 <Igloo> babelfish translates that as "ordered X-coordinate"
15:38:29 <Igloo> And "abcissa commanded". So I still don't really know what you're asking  :-)
15:39:09 <Igloo> abscissa and ordinate look like what you want according to dict, though
15:39:18 <mattam> ok, thanks
17:57:43 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first","Write for the HC&A Report, Nov 2004 edition - http://haskell.org/communities"]'
17:57:43 --- topic: set by ksbot on [Wed Oct 27 01:34:32 2004]
17:57:43 --- names: list (clog borism__ skuggi polli_ jadrian noclouds Spark Philippa_ det juhp LAPA np_hard viv themaximus xerox stepcut XTL Cale jesse98 mikael flaw dons blackdog rhaaw Matt-W_ Igloo tumm skylan _shawn wagle_gone ned Lunar^ emu norpan bik CLxyz mflux shrimpx kosmikus ozone aj Perite gdsx mattam chucky earthy Lor Maddas psi Taaus keverets asmodai flori musasabi edwinb sorje esap cmeme dryan maihem dash buggmuzz thebug lambdabot shapr ibid SamB)
17:57:43 --- names: list (tromp tintin Loopus arauko Jan_w EviL_DORK r3tex opet tic isomer Iter djw swiert|away desrt tuomov creichen wilx` Lemmih andersca shammah)
17:59:04 <kosmikus> yes?
17:59:23 <jadrian> I'm doing it... just a sec
18:00:04 <jadrian> it would be easier with generalized trees then with binary trees...
18:00:24 <jadrian> faster to explain I guess
18:00:43 <jadrian> foldTerm     :: (Term->[b]->b) -> Term -> b
18:00:44 <jadrian> foldTerm f t = f t (map (foldTerm f) (subTerms t)) 
18:01:06 <jadrian> this is pretty close to a Fold on Trees
18:01:24 <jadrian> the difference is that when folding a tree we'd have:
18:01:38 <jadrian> f elem (map (foldTerm f) (subTerms t))
18:02:52 <jadrian> ...
18:03:08 <jadrian> f elem (map (foldTree f) (subTrees t))  <-- is fold
18:03:08 <jadrian> f t (map (foldTree f) (subTrees t))     <-- is fold??
18:03:10 <jadrian> ...
18:03:16 <jadrian> is this understandable?
18:03:28 <jadrian> I may write the whole function if you want
18:03:41 <kosmikus> it's partially understandable
18:03:56 <jadrian> the 1st is a classic fold on Trees
18:04:12 <kosmikus> well ...
18:04:25 <jadrian> you map the subtrees, then apply f your elem and the result and 
18:04:55 <jadrian> the 2nd is similar but function f takes your whole tree and the result on the subtrees
18:05:15 <kosmikus> yes, I see that
18:05:35 <jadrian> from what I've read (admitedly not much) I'd call this 2nd a cata
18:06:08 <jadrian> but it's not the kind of pattern I would call a fold
18:06:37 <kosmikus> it's a specific instance of a fold
18:07:38 <kosmikus> in the first situation, define f as (\elem -> f' t)
18:08:12 <jadrian> you cannot
18:08:15 <kosmikus> then you are in the second situation
18:08:52 <jadrian> that is not possible..., because the function must not change during the trasversal
18:09:19 <jadrian> and that "t" is the subtree that you are in at that point of the trasversal
18:09:20 <kosmikus> ah sorry
18:09:48 <kosmikus> you get a paramorphism then
18:10:08 <jadrian> damn I haven't read that one yet :-/
18:11:04 <kosmikus> a paramorphism is like a catamorphism which you tuple with the identity function
18:11:27 <jadrian> yeap I was reading it right now
18:11:31 <jadrian> seems like that's it
18:11:38 <kosmikus> i.e., a paramorphism can be expressed as a catamorphism
18:11:45 <jadrian> right
18:12:10 <jadrian> in fact, in my case I could define the fold as a catamorphism but it would be messy
18:12:32 <jadrian> to define a cata on something like:
18:12:34 <jadrian> data A = Foo | Bar | Rec Blah [A]
18:12:49 <jadrian> wait... something like:
18:13:07 <jadrian> data A = Foo Int | Bar Char | Rec Float [A]
18:13:59 <jadrian> I'd need to pass a function for the Ints (in foo) another for the Char (in Bar) another for the Float (in Rec) and another to combine the results in the recursive step
18:14:31 <jadrian> now I think that is proper way to make a fold/cata on that structure right?
18:15:33 <kosmikus> the standard algebra of A would be "type AAlg r = (Int -> r, Char -> r, Float -> [r] -> r)", and "foldA :: AAlg r -> A -> r"
18:16:15 <kosmikus> or cataA, whatever you prefer
18:16:32 <jadrian> right eaxctly, one of my functions was not needed
18:16:48 <jadrian> problem is that as the structure gets more complicated, it gets messier
18:17:08 <kosmikus> not much ;)
18:17:44 <jadrian> well you need to pass more and more functions
18:18:14 <kosmikus> yes
18:18:23 <kosmikus> what do you actually want to do in the end?
18:18:46 <jadrian> you mean with the fold functions?
18:18:54 <kosmikus> yes
18:19:58 <jadrian> well one example would be collecting info from the terms
18:20:36 <jadrian> like getting the list of all variables in a term
18:20:44 <jadrian> (I know it's pretty inefficient this way)
18:21:19 <jadrian> the one similar to mapping can be used to apply substitutions on terms for instance
18:21:39 <kosmikus> generic programming, as I said
18:21:47 <kosmikus> three possibilities, actually:
18:22:00 <kosmikus> (1) use Scrap your boilerplate
18:22:05 <kosmikus> (2) use Generic Haskell
18:22:17 <kosmikus> (3) use the UU Attribute Grammar system
18:22:29 <jadrian> hmm never heard of the 2nd...
18:22:46 <kosmikus> that's probably (unfortunately) the least usable of the three
18:23:01 <kosmikus> because the implementation is severely outdated
18:23:08 <kosmikus> but I'm actively working on a new version
18:23:18 <kosmikus> www.generic-haskell.org 
18:23:56 <jadrian> opsss
18:24:03 <jadrian> sorry I've heard of generic haskell
18:24:07 <jadrian> I meant the 3rd
18:24:18 <kosmikus> more recent probably
18:24:22 <kosmikus> http://www.cs.uu.nl/docs/vakken/gp/
18:25:20 <kosmikus> ah, ok
18:25:23 <kosmikus> http://www.cs.uu.nl/groups/ST/Center/AttributeGrammarSystem
18:27:28 <jadrian> k thanks for all the info!
18:27:58 <jadrian> I'm off to bed now, need to sleep on it :)
18:28:02 <jadrian> kosmikus: bye!
18:39:56 <LAPA> C:\ghc\GHC-60~1.1\bin\ghc.exe: panic! (the `impossible' happened, GHC version 6.
18:39:57 <LAPA> 0.1):
18:39:57 <LAPA>         can't load package `wxcore'
18:40:03 <LAPA> the `impossible' happened
18:40:04 <LAPA> 1!!!
18:40:05 <LAPA> lol
18:40:59 <Lemmih> That happens way to often.
18:41:06 <dons> linking is a pain
18:41:17 <LAPA> any suggestion?
18:41:18 <Igloo> Should be the motto. "GHC: Making the impossible happen"
18:41:24 <Lemmih> haha
18:42:57 <LAPA> hm
18:43:04 <Igloo> In this case it might be to do with gl flags
18:43:04 <LAPA> I want to use wxhaskell
18:43:14 <Igloo> google might help
18:43:14 <LAPA> they say I need ghc version 6.2.1
18:43:22 <LAPA> but i only have 6.0.1
18:43:31 <LAPA> could be this?
18:43:32 <Lemmih> Then it would probably help to upgrade.
18:43:44 <Igloo> Oh, wait, this is ghc not ghci? I think you can scratch what I just said then
18:46:12 <LAPA> i don't know the diference between ghc and ghci
18:46:36 <LAPA> i am running this command : ghci -package wx Hello.hs
18:50:12 <peti> I bet shapr is still awake. ;-)
18:51:10 <flaw> oooh, nifty domain, cryp.to :)
18:51:53 <peti> Thanks. :-)
18:51:58 * peti was lucky to get it.
19:41:21 <Lemmih> What's Malcolm Wallace' IRC handle?
20:16:24 <dash> will some kind soul look at my program and tell me how i'm being stupid
20:16:59 <dash> http://ghostwheel.ddts.net/~washort/arnis.gs
20:17:01 <dash> errr
20:17:04 <dash> http://ghostwheel.ddts.net/~washort/arnis.hs
20:17:30 <dash> when i do 'run "(progn 1 2 3)"' the result is 1
20:17:40 <dash> when it should clearly be 3
20:17:55 <dash> sequenceMeaning is the code in question, but what is it doing wrong?
20:33:40 <heatsink> what is s2?
20:33:49 <heatsink> sequenceMeaning (expr:[]) r k s  = meaning expr r k s2
20:33:55 <dash> huh the what
20:33:58 <dash> how did that get there
20:34:03 <heatsink> :)
20:34:06 <dash> and in fact why does it not complain 
20:34:15 <heatsink> are you running interactive?
20:34:56 <dash> yeah, loading it in hugs
20:36:14 <heatsink> Does that fix the problem?
20:36:27 <dash> alas, it does not!
20:36:32 * heatsink doesn't know where dash's s2 comes from
20:36:38 <heatsink> hurmnh.
20:37:01 <dash> Main> sequenceMeaning [AAtom (AInt 1),AAtom (AInt 2)] initialEnvironment initialCont initialStore
20:37:01 <dash> 1
20:39:00 <dash> in particular, is the pattern matching i'm using for expr correct?
20:39:16 <heatsink> pattern matching is performed in lexical order
20:39:31 <heatsink> so the third sequenceMeaning will never happen
20:39:38 <heatsink> s/third/second/
20:39:41 <dash> ahhh dangit. I hit this once before.
20:39:45 <dash> YOu'd think I'd learn
20:40:26 <dash> Oddly, that didn't help either.
20:41:01 <heatsink> when expr is an AAtom (AInt i), then...
20:41:18 <heatsink> sequenceMeaning (expr:exprs) = meaning expr _ _ _
20:41:48 <heatsink> looking at the definition of meaning
20:41:54 <heatsink> this evaluates to i
20:42:26 <heatsink> exprs never get inspected
20:44:24 <dash> heatsink: hmm. did you get something to print that out or did you just figure it yourself? :)
20:44:33 <heatsink> I just figured it out
20:44:49 <dash> OK, just making sure there's not some debugging tool i'm missing ;)
20:45:01 <heatsink> I think you're evaluating the sequence backwards... you evaluate exprs, update the store, then evaluate expr
20:45:33 * dash stares at his denotations again
20:48:35 <heatsink> oh, I'm looking at the continuation, not the store.
20:49:54 <dash> yeah, that's the continuation
20:53:38 * dash tries writing it to be explicit-er
20:54:41 <dash> i am sure this code can benefit from a monadic representation of the store and possible of other bits, but i'd like to get the schemeish version working first :)
21:09:54 <dash> hmmh
21:10:12 <dash> OK i think i need to do something monad-y in my initial continuation
21:10:20 <dash> because that's where the value has to come out
21:11:08 * heatsink laughs
21:11:19 <dash> heatsink: yeah, i sucks ;D
21:11:20 <heatsink> 666!
21:11:25 <heatsink> I just got that now :)
21:11:28 <dash> s/s //
21:11:35 <dash> heatsink: hehehehe
21:11:47 <dash> heatsink: hopefully it'll never get that far ;)
21:15:26 <dash> OK so what initialCont looks like in scheme is essentially (lambda (v s.final) (print v))
21:16:00 <dash> and i don't see how to do that here, since if i print i can't return a Val
21:16:24 <heatsink> okies...
21:16:37 <heatsink> you could cheat and use a continuation or throw something
21:17:01 <dash> oh reaaally. didn't know you could do such things here
21:17:17 <dash> anyway cheating sounds great
21:17:27 <dash> because i plan to rewrite this code later anyway :)
21:18:09 * heatsink throws something and hears a transparent reference break
21:19:29 <heatsink> in ghc, there's Control.Exception and Control.Monad.Cont
21:20:21 <heatsink> ...hugs has them too
21:20:37 <dash> yeah
21:28:42 <dash> OK if i'm going to do monad-y things i might as well go whole hog and convert it all
21:29:17 <heatsink> woohoo!
21:29:42 <dash> not that i really know where to begin :)
21:31:03 <heatsink> Is this an interpreter for the linear stuff?
21:31:39 <dash> yeah
21:31:42 <dash> or will be :)
21:32:26 <dash> if i can get it to handle a lisp-2 then i figure i can extend it with linear variables as well
21:32:37 <heatsink> deck
21:32:44 <heatsink> what is lisp 2?
21:33:01 <dash> one that has separate namespaces for functions and values
21:34:13 <heatsink> ok
21:34:24 <dash> (which this isn't now, but one step at a time)
21:36:20 * dash reads _Monad Transformers and Modular Interpreters_
21:38:16 <dash> OK so 'meaning' will change its signature to ArnisExpr -> ArnisM Val
21:45:27 <dash> hmmmmmm
21:45:31 <dash> i am liking this paper
21:45:44 <dash> they seem to do things cleaner than Steele
23:26:39 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first","Write for the HC&A Report, Nov 2004 edition - http://haskell.org/communities"]'
23:26:39 --- topic: set by ksbot on [Wed Oct 27 01:34:32 2004]
23:26:39 --- names: list (clog asmodai dblhelix xkb mornfall arauko polli_ maihem ramen saynte jesse99 Spark heatsink borism__ skuggi noclouds Philippa_ det juhp themaximus xerox XTL Cale mikael dons blackdog rhaaw Matt-W_ Igloo tumm skylan _shawn wagle_gone ned Lunar^ emu norpan bik CLxyz mflux shrimpx kosmikus ozone aj Perite gdsx mattam chucky earthy Lor Maddas psi Taaus keverets flori musasabi edwinb sorje esap cmeme dryan dash buggmuzz thebug lambdabot shapr)
23:26:39 --- names: list (ibid SamB tromp Loopus Jan_w EviL_DORK r3tex tic isomer Iter djw swiert|away desrt tuomov creichen Lemmih andersca shammah)
