00:16:26 <bourbaki> moin
00:19:41 <shapr> I love this guy's music - http://www.bradsucks.net/
00:25:20 <shapr> segphault: good morning!
00:26:16 <segphault> indeed. =}
00:28:45 <Lemmih> Good morning, #haskell.
00:28:53 <bourbaki> hi Lemmih
00:30:47 <Lemmih> What a lovely day for unicycling.
00:31:40 <shapr> I agree, it's only -20Â°C
00:32:01 <segphault> its still pitch black outside here.
00:32:31 <shapr> The sun came up here in the last hour or so.
00:33:22 <Lemmih> The weather is really great here. The sky is clear and the sun is shining.
00:33:45 <earthy> gray, slightly blustery and whet
00:33:45 <segphault> sounds scary to me
00:34:21 <shapr> Last night these weird ice crystals were coming out of the sky, every light source looked light it had a fountain of light sticking up above it.
00:34:38 <segphault> trippy
00:35:06 <shapr> I thought it was northern lights at first, but whatever it was, it was very much trippy.
00:36:37 <musasabi> the world is white here...
00:36:59 <segphault> hehe plugged into the construct?
00:39:21 <shapr> whitebrain? that's from gibson, isn't it?
00:40:01 <segphault> I was alluding to the "Construct" from the Matrix
00:40:04 <segphault> the loading program
00:40:10 <segphault> empty white space
00:40:42 <segphault> no Matrix fans here I guess
00:40:54 <bourbaki> matrix is a really bad plagiarism of lem and gibson
00:41:06 <segphault> really? I thought it was really bad plagarism of Plato
00:41:11 <bourbaki> its just another bad action movie
00:42:01 <bourbaki> i dont try to find the root but the direct succesors :) otherwise id end up in a cave at a man who paints some animals on the walls
00:42:24 <Lemmih> I've posted a part of a Makefile at the HaskellIrcPastePage. Every %.gc file is dependent on %_cpp.cpp but I'm not sure how to express that dependency.
00:43:04 <segphault> the plot closely mirrors what we know of the life of Socrates, with quite evident inspiration taken generously from Plato's dialogues Euthyphro, Apology, and Crito, not to mention many thematic allusions to his famous Allegory of the Cave.
00:43:39 <shapr> Socrates met a bunch of robots?
00:43:43 <segphault> lol
00:46:29 <segphault> Chaerephon, a friend of Socrates, asked the Oracle at delphi if there was any man smarter than Socrates, the oracle replied quite clearly, no. Chaerephon made it his mission to see that the wisdom of Socrates was shared with the all the peoples of athens to liberate them from their hedonism and gluttony but Socrates did not believe that he was substantially wiser than his peers, and he felt that the only thing that differen
00:47:53 <segphault> He ardently believed that understanding of self was the only true way to learn
00:47:58 <segphault> sounding familiar?
00:48:56 <segphault> I wont go into the allegory of the cave here because its too complicated to explain in a few lines, but the entire thematic structure of The Matrix is almost entirely based on it. The Matrix is for all practical intents and purposes, the cave of Plato's allegory
00:50:00 <bourbaki> i wonder why ppl try to interpret something in that movie that is not not there
00:50:05 <bourbaki> the movie is an action movie
00:50:38 <bourbaki> nothing more it is not a philosophical movie and if it was intended by the makers then they utterly failed
00:54:08 <bourbaki> segphault did you read the gibson books? and have you read lem's the futurological congress?
00:54:15 <segphault> no
00:54:22 <bourbaki> you should :)
00:57:32 <segphault> could someone help me understand what the '@' is used for in haskell syntax?
00:57:39 <dons> for 'let'
00:58:18 <dons> it gives you a value bound to the pattern on the rhs of the '@'
00:59:06 <dons> so x@(a:bs)  =~   let x = (a:bs) in ...
00:59:30 <segphault> i've never seen 'let' used in haskell
00:59:39 <segphault> where would one want to do that?
00:59:39 <dons> you use 'where'?
00:59:44 <segphault> yeah
00:59:46 <dons> that's just post-fix form of let.
01:00:04 <segphault> in ocaml, you had to use let to do all assignments
01:00:39 <dons> yep. 'where' just gets desugared to 'let' anyway. you can use 'let' for all bindings too, if you want
01:01:08 <segphault> I dont. =} I'm particularly fond of the 'where' syntax, it seems a lot more graceful
01:01:32 <segphault> rather than writing a bunch of lines of let x = ... in
01:01:36 <bourbaki> can you use let and where at the same time?
01:01:40 <dons> sure. so are guards. but the point is that it's all just sugar that gets compiled down to the core lanugage of let and case
01:01:47 <Itkovian> i find it makes for more readable code ...
01:01:58 <dons> yes. you can mix them. it would be unhaskell not to be able to mix syntax, right?
01:02:25 <dons> I use let in do-notation for most pure values
01:02:25 <bourbaki> heh i dont know if it would but in math i have seen such definitions :)
01:03:05 <dons> do let x = 1 + 2; putStrLn $ show x ; return () , for example
01:03:22 <dons> let is apparently underrated :)
01:03:58 <Itkovian> i'm just not used to it. yet.
01:04:12 <Itkovian> which is why i find ocaml stuff sometimes hard to read ;-)
01:04:44 <dons> using where might lead you to write a definition a long way from where it is used.
01:05:09 <dons> every language has worse syntax than haskell, anyway ;)
01:05:12 <segphault> but if you give good names to your definitions, it shouldnt matter
01:05:38 <dons> but you don't always want descriptive names for short-lived values
01:05:45 <Itkovian> ah ... names ...
01:06:02 <segphault> thats true
01:06:04 * Lemmih throws a shuriken at C++ and make.
01:06:05 <Itkovian> where the students usually go bezerk
01:06:31 <Itkovian> 1D3 -> 2 points damage
01:06:55 <segphault> I try to use single letter variables in a really consistent way so I never have to guess what they are
01:07:10 <segphault> but I never put any single letter variables in global scope
01:07:14 <Itkovian> you can run out of those pretty fast tho ;-)
01:07:25 <segphault> which is why I dont put them in global scope. ;-)
01:07:31 <dons> that's what ' is for ;)
01:07:35 <segphault> indeed
01:08:01 <segphault> the ' thing is really a spiffy idea. In python I would use a single underscore at the beginning of the name, which always looked ugly
01:09:23 <dons> and underscores at the beginning of a name are used for shutting up ghc in -Wall mode, anyway
01:09:36 <dons> _x means don't complain that 'x' isn't used
01:09:51 <segphault> why would you want a variable that you never use?
01:09:55 <dons> because everyone is using -Wall, right?
01:10:10 <dons> documentation ++ maybe you use it later
01:10:20 <segphault> ah
01:11:39 <Itkovian> -What ? ;-)
01:11:44 <segphault> one time, I was working on a particularly complex ocaml code that I hadnt maintained very well. I spent over an hour trying to figure out where I was using this one variable before I realized that I wasnt using it. Since then, I have *always* commented out things that i'm not explicitly using
01:12:58 <dons> It's not so much for true dead code, but more for patterns.
01:13:00 <dons> (_x:ys)
01:13:16 <segphault> oh. that makes sense
01:13:38 <dons> {- -} is for dead code ;)
01:14:11 <segphault> I love the haskell commenting syntax. somebody actually *thought* about it
01:15:24 <segphault> in ocaml, its (* *) which makes it difficult to do: map ((*)3) [1;2;3;]
01:15:59 <segphault> you have to do it:  (( * )3) otherwise it thinks its a comment
01:16:44 <dons> and -Werror is fun to. then it won't compile until all warnings are gone. Including, e.g. non-exhaustive pattern matches
01:16:57 <dons> which just bite you in the end, anyway
01:17:26 <segphault> I was actually a little bit surprised that haskell allows non-exhaustive matching
01:17:40 <segphault> haskell is so darn picky about maintaining complete and total type safety
01:18:00 <segphault> so not caring about something so potentially dangerous seemed inconsistent with the rest of the philosophy
01:18:25 <dons> yep. but I guess it is quite common to write correct code, despite non-exhaustive patterns
01:18:41 <dons> at least they don't cause segfaults..
01:19:30 <segphault> ocaml is very picky about non-exhaustive matches. it goes as far as informing you of a few possible matches that you havent accounted for
01:19:50 <dons> doesn't ghc do that?
01:20:05 <segphault> I havent really used ghc yet. I primarily use Hugs
01:20:21 <dons> ok. you get much better warnings in ghc.
01:20:25 <segphault> thats cool
01:20:40 <segphault> I've been using hugs because it makes for faster debugging
01:20:53 <dons> that's what ghci is for!
01:21:08 <segphault> I cant get ghci to evaluate and die
01:21:16 <dons> the non-exhaustive matching errors are cool: 
01:21:19 <dons>    (GHC.Base.C# 'Z') : ((GHC.Base.C# #x) : _) with #x `notElem` ['Z']
01:21:23 <segphault> it always enters that damn interactive mode after I run a script through it
01:21:37 <dons> the missing pattern is an x /= 'Z'
01:22:07 <segphault> does haskell use the # for syntax?
01:22:15 <dons> for unboxed types
01:22:31 <segphault> hrm. I like to use # as my 'map' operator
01:22:51 <dons> well, you don't get to use fast cpp or fast unboxed types then ;
01:23:06 <dons> s/fast//
01:23:29 <segphault> I should probably stop using it anyway
01:23:46 <dons> noone else will know you mean 'map' when you write '#'
01:23:48 <segphault> a map operator isnt really all that beneficial in a pure language
01:24:04 <dons> @type map
01:24:05 <segphault> other people very rarely read my code
01:24:06 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
01:24:13 <dons> very beneficial
01:24:23 <segphault> hm?
01:24:37 <segphault> map is certainly beneficial, but having an operator for it isnt in a pure language
01:24:55 <segphault> I was using a map operator in ocaml to reduce the paren hassle, which $ does quite well
01:25:13 <dons> doesn't really have anything to do with operators, or pureness
01:25:44 <segphault> the way that stuff gets evaluated in haskell, using operators doesnt generally seem to reduce the number of necessary paren
01:25:44 <dons> yep. $ is great.
01:25:52 <dons> I started using: flip ($) today
01:25:58 <segphault> although that may be because I wasnt setting the arity right
01:26:42 <segphault> what would flip ($) do?
01:26:54 <dons> reverse the arguments to lazy application
01:26:56 <segphault> flip switches around two arguments, right?
01:27:00 <dons> yep
01:27:15 <dons> operators and functions are the same in haskell
01:27:18 <dons> they're just identifiers
01:27:23 <segphault> I'm still not exactly sure how and where I should use flip
01:27:38 <dons> if you have a really long first argument, and a short second argument
01:27:44 <segphault> but I should probably figure it out. I like nifty point-free style
01:27:55 <segphault> what do you mean by long?
01:27:59 <dons> or, if you want to partially apply an argument that isn't the first
01:28:13 <np_hard> pointless style?
01:28:15 <np_hard> :)
01:28:27 <dons> flip ($) 1 (some long expression that takes an Int)
01:28:38 <segphault> oh. cool
01:28:43 <segphault> thats really spiffy
01:28:44 <dons> but, usually flip is used for partial application
01:29:50 <segphault> there are a lot of really nifty, useful things in the prelude that make life much easier
01:29:59 <dons> something that produces a value >>= flip fun 7
01:30:35 <segphault> I know the >>= has something to do with monads, and I know more or less what a monad does, but I havent gotten around to figuring out how to use them yet
01:30:53 <dons> just to sequence things :)
01:30:55 <segphault> mastering monads is on my schedule for this weekend
01:31:41 <dons> looks like I use flip mostly for long expresions, or getting arguments into the order I find more sensible
01:31:50 <dons> flip replicate ' ' 16
01:32:27 <segphault> thats interesting, but doesnt that slow down execution speed?
01:32:57 <dons> it gets well and truly optimised away
01:33:07 <segphault> good to hear
01:33:19 <segphault> sounds like the haskell compilers do some insanely cool optimizing
01:33:52 <dons> yep. you can do more cool optimisations when side effects are contained properly
01:34:26 <segphault> and a syntax without side affects is much more graceful anyway
01:34:46 <segphault> makes me wonder why other functional languages dont go with a pure syntax
01:37:15 <dons> do you mean side-effect free semantics?
01:37:27 <segphault> yeah. isnt that what 'pure' implies?
01:37:43 <dons> the syntax is just the concrete representation of the language
01:37:56 <dons> pure, yes.
01:38:14 <dons> syntax isn't the same thing as semantics.
01:38:32 <segphault> indeed
01:38:57 <xkb> so its lazy evaluation semantics
01:38:57 <segphault> and evaluation methodology wouldnt be an aspect of syntax
01:38:59 <xkb> eh
01:39:04 <segphault> I actually knew that
01:39:10 * xkb meant to say pure
01:42:24 <musasabi> How did I make ghc dump the "core" presentation of a program?
01:42:42 <dons> -fext-core
01:42:47 <dons> it's in a .hcr file
01:42:54 <dons> also, you can use -ddump-simpl
01:43:45 <musasabi> thanks
01:43:52 <segphault> is there any way to interface with haskell from C?
01:44:09 <musasabi> yes
01:44:13 <dons> yes. the foreign function interfacce
01:44:18 <dons> it is extremely good
01:44:39 <segphault> I thought the ffi was only capable of allowing me to use C from haskell
01:44:48 <dons> nope. works both ways.
01:44:51 <segphault> very cool
01:44:59 <musasabi> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
01:45:06 <dons> you could also use hs-plugins to evaluate haskell strings from C programs
01:45:07 <musasabi> foreign export
01:45:24 <segphault> thx for the link. =}
01:46:15 <segphault> I was just thinking that it would be really cool to be able to intermingle haskell and python for a certain project
01:46:25 <segphault> if it can export to c, then I will probably be able to do it
01:46:48 <dons> that sounds doable.
01:46:51 <segphault> much coolness
01:47:20 <segphault> and if I can use hs-plugins to evaluate haskell strings from c programs... I could theoretically interface that with python as well
01:47:33 <segphault> I could write haskell code in triple-quote blocks in a python script and evaluate it.
01:47:59 <dons> that would be really fun. bit of hacking though
01:48:01 <segphault> hehehehehehehehe I think i'm going to be having a lot of fun with this
01:48:29 <dons> you can do:
01:48:31 <dons> p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
01:48:43 <dons> from C, with hs-plugins.
01:48:50 <segphault> ah
01:48:52 <dons> so probably not too hard to extend that
01:49:40 <dons> if you just want to eval the code to strings, just echo foo | ghci is probably simpler
01:49:47 <musasabi> I was able to rip out ffi from some of my programs now that I have working GUIs in haskell.
01:49:52 <segphault> haskell and python would probably be really cool together. I could use haskell for... hehehe.... "low level" python programming =D
01:57:38 <Itkovian> then you certainly could do real fp stuff in python ...
01:57:39 <segphault> you can already do quite a bit of fp with python
01:58:21 <segphault> this lib adds some neat toys for fp in python: http://www.xoltar.org/languages/python.html
01:58:37 <segphault> including nifty sugar for partial application
02:03:30 <segphault> ideally, code syntax should provide enough information for makefile generation
02:03:30 <segphault> err content in your code or w/e
02:05:04 <Lemmih> Hmake can figure out dependencies on its own but it's not very good at handling non-haskell files.
02:12:09 <Lemmih> Every %.gc file is dependent on %_cpp.o. Why can't I express that in a makefile? This is so frustrating.
02:12:57 <segphault> why dont you just make your editor do the redundant part for you?
02:13:27 <Lemmih> How?
02:14:00 <segphault> for stuff like that, I use vim's python extension
02:14:27 <segphault> I can write python code on the vim command line and do all sorts of creative things to selected text in the active buffer
02:15:14 <segphault> or you could probably put something together with vim macros and regexp substittion
02:15:36 <segphault> hell, you could probably even do something like that with awk if you got really creative
02:18:58 <Lemmih> Sounds like the cure is worse than the disease.
02:19:50 <segphault> i've gotten so used to doing creepy shell/script hacks for automation that I dont bother to think twice about it anymore, I just do it
02:20:32 <segphault> if you are wiling to invest the time it takes to really learn how to use the rather unintuitive tools available, you can be a lot more productive.
02:22:24 <segphault> vim can do a lot of really cool things that seem irrelevant, but when you start using them together the increased productivity really starts to add up
02:23:27 <Itkovian> well, i find that i am willing to learn, but lack time ...
02:23:29 <Itkovian> :-(
02:23:32 <Lemmih> Creating lots of dirty hacks isn't my idea of increased productivity.
02:23:52 <segphault> I dont know what the structure of your makefiles are, but if all your files are listed together, you could copy the whole block, then paste it, and then do a regexp substitution that changes the extensions in the copied block. would that solve your problem?
02:24:24 <Itkovian> hmm ... then i'd rather write a script to automate that ...
02:24:53 <segphault> it takes 5 or 6 key strokes to do something like that in vim, which is less time than it would take to invoke a script most of the time.
02:25:22 <segphault> if I wanted something more permanent, I would write it as a quick python function which I would toss into my vimrc file and I would assign a key binding to it
02:26:28 <Lemmih> segphault: Greencard files generates Haskell sources plus a C stub file and there's a C++ file for every Greencard file.
02:26:56 <segphault> and you just need to list all of those together in a makefile?
02:27:23 <Lemmih> I don't see why I should name them all.
02:27:51 <segphault> why dont you just redirect the output of ls into the makefile?
02:28:32 <segphault> or if you needed more particular format, you could use ruby's Dir[] thing to do a quick one-liner
02:28:59 <Lemmih> How would that help? The Haskell source and stub files are not generated yet.
02:29:06 <segphault> ah
02:29:29 <segphault> I havent worked with greencard or anything like that yet so I dont know what the issue is
02:29:56 <segphault> so you have already written greencard files, and those generate the source?
02:30:12 <Lemmih> Yes.
02:30:51 <segphault> and you cant use those filenames to generate the data you need?
02:31:14 <Lemmih> It would be easy if I only needed the Haskell source which Greencard generated but there's also the stub and the CPP file.
02:31:41 <segphault> there is one stub and one cpp for each greencard file? is the name the same except for the prefix?
02:32:57 <segphault> make a list of cpp files using the gc files: ls -1 *.gc | sed 's/.gc/.cpp/'
02:33:37 <segphault> err I meant except for the suffix before
02:33:49 <Lemmih> That would be a lot easier to do in the makefile with $(FILES:.gc=.cpp)
02:34:04 <segphault> does that work?
02:35:03 <Itkovian> segphault: you got any pointers to tutorials for that vim/python stuff?
02:35:31 <segphault> Itkovian: the help files that come with the extension are really all you need, if you already know python
02:35:54 <Itkovian> i know it a bit - trying hard to find time to improve my knowlegde and skills
02:36:05 <Itkovian> i'll have a peek
02:37:02 <segphault> Itkovian: the python docs have a really good tutorial that can be worked through quite fast
02:37:35 <segphault> Itkovian: if you have already finished the python docs tutorial, this is a good one that plays with more advanced stuff: http://diveintopython.org/
02:38:03 <segphault> Itkovian: to do the vim/py stuff, if you already know python, the only thing you really need to figure out is the vim/py API.
02:38:25 <segphault> Itkovian: vim is also extendable via perl, ruby, and tcl
02:39:02 <segphault> Itkovian: if you are on linux, and you are using a distribution package, you might need to do your own build to get python support in vim.
02:43:44 <segphault> Itkovian: I just uploaded updated version of my vimrc file, you can take a peek to see how I use python. I dont maintain it very well, so its gotten quite messy, but you will be able to get the general idea: http://mmearth.net/gaerdin/code/scripts/vimrc.html
02:45:50 <Itkovian> i am in the process of reading the diveintopython thingie
02:46:36 <Itkovian> fetched that
02:58:49 <musasabi> Would an extension of Haskell transforming typeclasses into explicit dictionaries break the language?
03:01:10 <vegai> anyone know what function 'sec' is?
03:01:19 <vegai> (in a mathematical text)
03:01:25 <musasabi> secant?
03:02:09 <vegai> right, thanks
03:17:07 * segphault is going to watch some anime and take a nap
03:21:07 <swiert> musasabi: you might be interested in http://www.cs.uu.nl/groups/ST/twiki/pub/Atze/WebHome/esop05.pdf
03:21:58 <swiert> the paper shows how to allow explicit dictionary passing in Haskell - allowing overlapping instances for instance.
03:24:03 <musasabi> thanks
03:25:23 <swiert> no problem - hope this helps
03:36:08 <musasabi> hmm that tries to define local instances..
03:36:16 <musasabi> Which is too ambitious for me.
03:36:26 <musasabi> (and that pays a higher price too)
03:37:57 <musasabi> I am thinking of an operator like "untyclass :: (Q q => q -> a) -> (QDict q -> q -> a)"
03:38:54 <musasabi> where Q is some typeclass (yes, it cannot be a function)
03:42:07 <swiert> but doesn't a function like this more or less imply local instances?
03:43:15 <swiert> although you have to be fairly explicit about them
03:53:30 <musasabi> well it implies them in a sense.
03:53:46 <musasabi> local instances can open a can of worms like:
03:54:05 <musasabi> class Foo a where foo :: a -> Int
03:58:07 <musasabi> bad = let instance Foo Int where foo = const 1; instance Foo Int where foo = const 2 in foo 5
03:58:35 <musasabi> of course that can be handled like with implicit parameters.
03:59:42 <musasabi> esop05.pdf tries to modify existing class instances and create new instances from them. This results in problems as parts of the old instance are tied to each other.
04:00:05 <musasabi> By using plain simple functions all of these problems would go away.
04:02:43 <swiert> hmm - but doesn't the explicit passing of a dictionary a la esop basically enable the same mechanism you're proposing?
04:14:23 <swiert> if you want to pass explicit dictionaries, you'll need ways to create dictionaries. The esop paper allows modification of default dictionaries, and as a result local instances. That is only a small step once you've made explicit dictionaries possible.
04:41:10 <swiert> not to be rude, but I have to go. bbl.
04:56:57 <vegai> has anyone here done UTM projections?
05:02:27 <boegel> hello #haskell
05:02:31 <boegel> @seen bourbaki
05:02:32 <lambdabot> I saw bourbaki leaving #haskell 3 hours 28 minutes 33 seconds ago.
05:02:42 <boegel> damned :s missed him again
05:15:33 <Lemmih> I think the guys behind ClanLib have made serious attempts at making it unbindable to other languages.
05:16:12 <shapr> heh
05:16:20 * shapr hops
05:16:24 <shapr> BANZAI!
05:18:22 <shapr> You say you enjoy proselytizing?
05:18:22 <shapr> What can I say? I enjoy the missionary position.
05:19:39 <Lemmih> I think 'main' has to be compiled by a C++ compiler... *confused*
05:19:52 <shapr> @seen wli
05:19:52 <lambdabot> I haven't seen wli
05:20:58 <shapr> @seen jaffacake
05:20:59 <lambdabot> I haven't seen jaffacake
05:21:26 <Lemmih> That's Simon Marlow, right?
05:21:33 <shapr> yup
05:24:09 <musasabi> binging C++ with haskell is "fun"..
05:25:00 <musasabi> not to mention one needs tricks to use cabal with that
05:26:37 <Igloo> wxWidgets apparently needs to bridge the gap with a "shared library" to make everything work together
05:27:14 <musasabi> look at hs-fltk how to do it without a shared library ;)
05:27:43 <Igloo> Is that solution portable?
05:28:19 <Igloo> If so it would be good if someone who understands the issues could explain how it works to Daan
05:29:18 <Lemmih> musasabi: Do you have a simple example of calling C++ from Haskell? I'm not quite sure I'm doing it right and I'm somewhat intimidated by wxHaskell.
05:29:41 <musasabi> Lemmih: yes. http://www.cs.helsinki.fi/u/ekarttun/hs-fltk
05:30:56 <musasabi> Igloo: well it is portable in that case, but you can certainly break it if using C++ constructs needing static initialization.
05:31:36 <Igloo> OK, no idea if wxw needs that
05:32:49 <musasabi> Lemmih: drop me a line if you have any questions about that.
05:35:23 <musasabi> => (brb 15min)
06:23:59 <Lemmih> Why isn't GHC generating a 'main' function?
06:28:17 <shapr> I've heard something about that, but I don't remember the details.
06:28:28 <shapr> something on ghc-users in the last few months maybe?
06:28:42 <shapr> bringert: y0 you have a moment?
06:29:49 <shapr> bringert: I want to ask about faster searching with curryspondence, right now it's slow on my dual 1544MHz with 512mb of ram, and I want to run it on my 600MHz colo box.
06:32:33 <shapr> I wonder if John Peterson would mind if www.haskell.org suddenly became a debian box.
06:33:35 <xerox> what is it now?
06:34:01 <shapr> redhat something, fc1 I think.
06:35:50 <xerox> i'm thinking about buying SICP (Hardcover)
06:36:55 <shapr> I have it, it's nice.
06:37:40 <bringert> hi shapr
06:37:40 <xerox> there is the full text online
06:37:47 <bringert> what about faster searching?
06:38:03 <bringert> would an index help?
06:38:07 <xerox> but i think i'd like to have the physical paper thing ^_^
06:38:16 <bringert> hmm, it's full-text search, right?
06:38:28 <shapr> yeah
06:38:54 <shapr> I can't make an index because the postgresql will only make an index on text up to a certain size
06:39:00 <shapr> something like 8k or so.
06:39:10 <bringert> I assume running the same query manually against postgre takes as much same time?
06:39:14 <xerox> ~50$
06:39:15 <shapr> yup
06:39:29 <bringert> can you think of a better query if you write the SQL by hand?
06:39:34 <shapr> Nope.
06:39:38 <bringert> hmm
06:39:43 <shapr> I guess I need to refactor the table structure or something.
06:39:53 <bringert> I think MySQL has some sort of full-text index feature
06:40:19 <bringert> or you could do some fancy google-like stuff
06:40:23 <shapr> I could put each mailing list in its own table, but that's cheesy.
06:40:30 <bringert> yuk
06:40:37 <shapr> I wish I could precalculate the indexing.
06:40:54 <bringert> isn't there somehing called principal component analysis for that?
06:41:05 <bringert> something like what google does
06:41:10 <shapr> er, I dunno.
06:41:28 <shapr> I was just thinking that I could precalc an index of the most commonly used N words that aren't stop words.
06:41:29 <bringert> seeing how there is now way the scan their whole copy of the internet for every search :)
06:42:05 <bringert> there must be tons of papers on clever full-text indexing algorithms
06:42:40 <shapr> I wonder if there's something else I can do.
06:42:52 <shapr> I'd rather just let postgresql handle it, but not so slowly :-)
06:43:03 <musasabi> shapr: there are full text indexing solutions for postgresql.
06:43:10 <bringert> mmm, excellent, a fscked up db upgrade just took down half of chalmers 
06:43:16 <shapr> musasabi: but they only work on TEXT fields below a certain size
06:43:33 <musasabi> what about qdbm then ?
06:43:43 <musasabi> that has a full text api too.
06:43:48 <shapr> if any of your TEXT values are larger than 8192 bytes or so, you can't do full-text indexing for postgresql.
06:44:13 <bringert> hmm, how many unique words are there in the db?
06:44:23 <shapr> good question
06:44:34 <shapr> you think a table of word -> uid might be an easy approach?
06:44:41 <musasabi> shapr: they don't support TOAST? :-(
06:44:46 <shapr> what's that?
06:44:54 <bringert> what if you just make a mapping from each word (except the N most frequent english words) to a list of emails?
06:45:00 <musasabi> (the way postgresql handles larger chunks of text)
06:45:16 <bringert> eh, maybe not N most frequent english, make that N most frequent in the DB
06:45:17 <musasabi> I used to know postgresql quite well a few years back in time.
06:45:56 <shapr> the frequent mapping sounds workable
06:46:01 <bringert> I guess you don't want to have "Haskell" in the list
06:46:06 <shapr> probably not
06:46:17 <bringert> nor "Simon"
06:46:20 <bringert> :-P
06:46:26 <shapr> I could do frequent mapping and fall back to the brute force search I use now.
06:46:55 <shapr> Also, I want to get rid of WASH. It's just too much trouble.
06:48:28 <bringert> shapr: http://techdocs.postgresql.org/techdocs/fulltextindexing.php
06:48:47 <bringert> don't know anything about it, just a random google hit
06:49:53 <bringert> I guess you're going to hack up a regexp match operator for HaskellDB
06:50:01 <bringert> to get that working though
06:51:22 <shapr> iirc, new operators are easy to write.
06:51:32 <shapr> Last I looked at the example.
06:51:51 <bringert> yeah
06:51:55 <bringert> if they're not unary
06:52:25 <bringert> for some reason we never add support for custom unary operators
06:52:27 <bringert> nullary and binary is easy enough
06:52:52 * boegel waves at everyone
06:53:52 <boegel> I'll try to get FranTk working again... wish me luck :p
06:54:38 <Lemmih> Is there an easy way of searching through a mailing list?
06:54:50 <CosmicRay> google?
06:55:14 <boegel> hello CosmicRay 
06:55:18 <CosmicRay> morning boegel
06:55:43 <Lemmih> I don't want results not from the list.
06:56:52 <ibid> depends on the list really
06:57:03 <boegel> I slept like 12 hours this night... that can't be healthy :s
06:57:36 <bringert> Lemmih: curryspondence, if you are talking about a haskell list
07:00:36 <bringert> fix to support custom unary operators is in cvs now
07:00:40 <bringert> in HaskellDB that is
07:00:57 <shapr> it would be nice if a curryspondence installation could be pointed to a mailman page and would then import it.
07:01:17 <bringert> does mailman expose mbox archives?
07:01:20 <shapr> yup
07:01:37 <bringert> sounds not too difficult then
07:01:37 <shapr> That's why I hacked up curryspondence in the first place, because mailman archives are such a pain in the butt to search. 
07:01:48 <bringert> just use Network.HTTP
07:02:03 <bringert> to grab the mbox-file that is
07:02:09 <shapr> Yah, I like it.
07:02:14 <boegel> does anyone have experience with hacking Tcl/tk ?
07:02:46 <shapr> I wonder if peti's Postmaster code handles MIME and attachments better than WASHMail.
07:04:23 <CosmicRay> what's the trouble with washmail?
07:04:41 <shapr> I don't remember.
07:04:44 <CosmicRay> heh
07:04:57 <CosmicRay> iirc, it looked fairly complete to me
07:05:32 <shapr> Well, now is a good moment to resurrect Curryspondence and find out.
07:11:18 * shapr kicks alsaplayer
07:11:27 <shapr> I hate it when my music player segfaults.
07:14:37 <shapr> I wonder how irc handles utf-8 nicknames...
07:15:08 * urtie thinks it doesn't
07:15:28 <shapr> irc suxx
07:15:38 <urtie> that's putting it mildly
07:15:42 <urtie> ever looked at the protocol?
07:15:49 * shapr points to SILCnet
07:17:13 <bringert> --- Ã¶Ã¶Ã¶Ã¶Ã¶ :Erroneous Nickname
07:17:20 <bringert> is what it told me
07:17:38 <bringert> @eval "Ã¶"
07:17:39 <lambdabot> Ã¶
07:19:03 <TheHunter> @eval (\Î» -> Î»+1)
07:19:04 <lambdabot> (line 1, column 3):
07:19:04 <lambdabot> unexpected "\206"
07:19:04 <lambdabot> expecting identifier
07:19:15 <TheHunter> :(
07:19:17 <Lemmih> haha
07:19:43 <CosmicRay> hey shapr, if you ever want to poke at my printf code and tell me where I suck, I'd appreciate it :-)
07:20:00 <CosmicRay> it seemed to be surprisingly controversial on cafe
07:24:35 <CosmicRay> although I guess half of that was a meta-conversation (printf sucks / printf rules etc)
07:26:25 <bringert> anyone know how hard it would be to hack haskell-mode to show a Î» instead of \?
07:32:29 <Lemmih> Is it possible to link with the RTS before other libraries?
07:34:39 <shapr> bringert: it's been done
07:34:55 <shapr> it's called pretty-lambda.el
07:36:49 <xerox> http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
07:37:36 <shapr> First written by Luke Gorrie for erlang-mode, later improved by Jorge Adriano for haskell-mode, since then it's been generalized to a variety of projects.
07:43:42 <boegel> if I want to start hugs with some extra directory's to look for module, I do this right ? : hugs -P"/extra/dirs:/foo/bar"
07:47:06 <boegel> oh my god !
07:47:46 <boegel> thery're giving away a trip on the radio to go to Mexico and see KoRn there in concert
07:47:55 <boegel> I _have_ to win that contest
07:48:53 * boegel 's heart is pouding like hell
07:49:00 <boegel> pounding that is
07:49:45 <bringert> I basically know fsck-all about emacs, but I tried putting the pretty-lambda stuff in my .emacs, and all it doess is turn of syntax highlighting.
07:50:13 <bringert> s/of/off/, s/doess/does/
07:50:33 <bringert> I really should read what I type before I make you guys do it
07:51:04 <boegel> damn, why isn't hugs loading the paths I give it :s
07:51:49 <bringert> boegel: I seem to remember that you need an extra ":" at the the of the path to get it to work as expected
07:51:58 <bringert> can't remember why though
07:53:19 <ski> "A null entry in this list will be replaced by the previous search path"
07:54:05 <CosmicRay> @index satisfy
07:54:06 <lambdabot> Text.ParserCombinators.ReadP,Text.ParserCombinators.Parsec,Text.ParserCombinator
07:54:06 <lambdabot> .Parsec.Char
07:55:12 <boegel> Hugs can't even find the "Random" module anymore :s
07:55:18 <shapr> oy - http://lwn.net/Articles/111621/
07:55:21 <boegel> not even when I just use "hugs"
07:55:23 <shapr> microsoft sucks
07:56:40 <boegel> pfff, they're getting scared I guess :)
07:56:42 <boegel> they should
07:57:37 <boegel> what's going on ???
07:57:38 <boegel> [root@localhost bin]# hugs
07:57:38 <boegel> __   __ __  __  ____   ___      _________________________________________
07:57:38 <boegel> ||   || ||  || ||  || ||__      Hugs 98: Based on the Haskell 98 standard
07:57:38 <boegel> ||___|| ||__|| ||__||  __||     Copyright (c) 1994-2003
07:57:38 <boegel> ||---||         ___||           World Wide Web: http://haskell.org/hugs
07:57:40 <boegel> ||   ||                         Report bugs to: hugs-bugs@haskell.org
07:57:42 <boegel> ||   || Version: November 2003  _________________________________________
07:57:44 <boegel> Haskell 98 mode: Restart with command line option -98 to enable extensions
07:57:44 <shapr> aiee
07:57:46 <boegel> Type :? for help
07:57:48 <boegel> Prelude> :m Random
07:57:50 <boegel> ERROR - Cannot find module "Random"
07:57:52 <boegel> Prelude>
07:57:57 <shapr> try :m + System.Random
07:58:15 <shapr> boegel: you can just pasted the two lines that count :-P
07:58:28 <shapr> anything over three lines should go on a paste page
07:58:45 <boegel> shapr, that was to show that hugs doesn't show any errors
07:58:48 <boegel> ow, sorry :|
07:59:04 <boegel> Prelude> :m + System.Random
07:59:04 <boegel> ERROR - Cannot find module "+"
07:59:04 <boegel> Prelude>
07:59:27 <boegel> without + -> ERROR - Cannot find module "System.Random"
07:59:40 <Lemmih> Hugging as root?
08:00:01 <boegel> Lemmih, that's just because I'm installing some stuff, and I don't want to switch all the time
08:00:41 <boegel> what could be the problem ?
08:01:16 <Lemmih> Try :l System.Random
08:02:07 <boegel> Lemmih, that works...
08:02:12 <boegel> isn't that very strange ?
08:02:33 <Lemmih> I think it's normal for Hugs.
08:03:46 <boegel> that :m gives an error ?
08:04:45 * ski thinks :m just switches between active module of already loaded modules, in hugs
08:06:14 <boegel> ski, thanks, that's probably it
08:31:33 <Igloo> OK, have I missed something or has Malcolm been silently releasing new versions of stuff?
08:32:41 <Igloo> But hey, "Go Malcolm!" anyway  :-)
08:35:14 <kosmikus> has he?
08:35:47 <Igloo> hmake and cpphs are at 3.09 and 0.8 respectively
08:36:01 <kosmikus> interesting
08:45:56 <shapr> wow, Johannes Waldmann's Haskell code to simulate jugglers led to advances in juggling theory.
08:46:13 <shapr> I didn't actually know juggling theory was a field of research.
08:46:20 <Igloo> What code, and what advances?
08:46:46 <shapr> the "drop" program, and http://www.sonic.net/~boyce/prime.html
08:47:50 <shapr> er "drops" is the Haskell program.
08:47:54 <shapr> It's quite nifty actually.
09:06:13 <Lemmih> D'oh. Now I have to unicycle in the dark.
09:10:13 * boegel pokes shapr with a stick
09:17:51 * CosmicRay makes progress with his ConfigParser port to Haskell
09:19:02 <Igloo> Hmm, vim's diff syntax highlighter needs to understand what the @@ lines mean
10:51:51 <Oejet_> Hello.
10:57:08 <ski> hiya Oejet_
10:57:20 <SyntaxNinja> shapr: w00t
11:59:02 <kristnjov> .
13:42:15 * Lemmih is very proud of himself.
13:42:46 <segphault> what did you do?
13:43:44 <Lemmih> I learned a new unicycle trick.
13:43:50 <segphault> hehehehe cool
13:44:29 <Riastradh> Falling over in a different spectacular way?
13:44:35 <segphault> lol
13:47:05 <segphault> when I have a case statement and I have a bunch of lines that have the same number of arguments and the same thing on the right hand side, can I compact that and not have to define the right hand side for each one?
13:47:31 <jyp> use let
13:47:34 <Lemmih> That too actually. You put the unicycle on the ground, then place one foot under the sadel and one on a pedal, and then "jump" up on the unicycle (ie. move the sadel up under you and drive).
13:48:02 <segphault> jyp: how can let help?
13:48:38 <jyp> There was a thread on the list about just that; give me a minute to find it.
13:48:44 <segphault> thx
13:49:47 <segphault> ocaml lets you do things like: match a with X z | Y z | Z z -> z
13:50:29 <jyp> http://haskell.org/pipermail/haskell/2004-October/014689.html
13:50:55 <jyp> Basically you can't do the same thing, but please read on.
13:51:08 <segphault> k. thx
13:52:59 <segphault> thats really a bummer.
13:54:09 <jyp> I haven't been annoyed by that till now...
13:54:33 <segphault> it adds unnecessary verbosity
13:54:59 <jyp> -- you should file your case to the list
13:55:12 <jyp> I'm not qualified to comment
13:55:28 <segphault> eh?
13:56:05 <jyp> I'm afraid I can't fix the language ;)
13:56:30 <segphault> ah
13:56:42 <Lemmih> I don't think it has a high priority because it's so rarely used.
13:56:49 <segphault> can I send to the list without having to be subscribed to it?
13:57:07 <Igloo> You might have to wait for it to be approved, but I believe you can
13:57:19 <Igloo> There have been a few times I would have found it really nice
14:02:14 <musasabi> segphault: you can use pattern guards.
14:02:42 <segphault> musasabi: I dont think pattern guards are applicable in this situation
14:03:35 <segphault> I'm not basing my matches on values, but on constructor names
14:03:46 <musasabi> segphault: foo (X _) = True; foo (Y _) = True; foo (Z _) = True; foo _ = False
14:04:21 <segphault> where foo is... the type of the constructors?
14:04:22 <musasabi> case x of _ | foo x -> unX x
14:05:53 <Lor> musasabi, don't reuse x
14:06:01 <Lor> Ugly and confusing.
14:29:51 <LittleDan> why does the Num typeclass have only one parameter, disallowing something like calling + with an Int and an Integer?
14:30:27 <Riastradh> Type classes may have only one parameter.
14:30:35 <jyp> Wrong ;)
14:30:48 <jyp> There are extensions
14:30:54 <LittleDan> Riastradh: what about multiparameter typeclasses?
14:31:01 <Riastradh> Yes, but not in Haskell 98, which is what defines Num.
14:31:13 <jyp> ... But basically, little dan, what you want is subtyping
14:31:21 <LittleDan> jyp: no, not at all
14:31:43 <LittleDan> jyp: something like instead of having class Num a, we could have class Num a b c | a b -> c
14:31:44 <jyp> So, whatcha want ?
14:31:55 <jyp> ok
14:32:09 <Riastradh> It has been suggested for Haskell 2.
14:32:19 <LittleDan> Haskell 2?
14:32:47 <Riastradh> The hypothetical next version of Haskell.
14:33:12 <LittleDan> is that like Python 3000 hypothetical or it's actually going to happen in this century
14:33:30 <dons> just use fromIntegral to get the right type...
14:34:09 <kosmikus> there are no concrete plans for Haskell 2, afaik
14:34:22 <dons> there's a wiki!
14:34:22 <kosmikus> it depends on someone starting an effort to get it done, but it certainly will be no easy task
14:35:03 <dons> and the language extensions are in a real state of flux, anyway
14:35:19 <LittleDan> dons: well, I'm making my own language from scratch that has typeclasses and I'm not sure which scheme to use for numbers
14:35:30 <dons> oh, that's cool
14:35:54 <dons> multiparameter type classes would be fun ;)
14:36:25 <LittleDan> would it be too cumbersome to use multiparameter typeclasses for all of this?
14:36:43 <dons> depends on how much of a type checker hacker you are, I guess
14:37:00 <Igloo> I think 3 of the most important questions are what happens to n+k patterns, what happens to the MR and how do we restore principal types, and I don't think they have all (have any?) been answered
14:37:14 <LittleDan> Igloo: what?
14:37:16 <Riastradh> 'What happens to n+k patterns?'
14:37:21 <dons> they die, they die
14:37:22 <Riastradh> Haskell 98 supprots them?
14:37:25 <Riastradh> Supports, even.
14:37:40 * Igloo likes them
14:37:42 <Lor> n+k patterns are a hack.
14:37:49 <Riastradh> n+k patterns are horrible.
14:37:53 <Lor> If there were some way to generalize them to work with arbitrary datatypes, it'd be cool.
14:37:54 <dons> do you use them, Igloo?
14:37:54 <Igloo> And I understand views may be a way for them to stay as one instance of something more general
14:37:56 <Lor> Views.
14:37:58 <Igloo> Yes
14:38:06 <LittleDan> I don't see the point in n+k patterns, but adding views to Haskell in general would be cool
14:38:12 <dons> wow. you're the first persson I've met who uses them :)
14:38:33 <Lor> n+k patterns are sortakinda neat if you do simple primitive recursion.
14:38:41 <Lor> Not worth the mess, though.
14:38:55 <LittleDan> dons: which one of us uses them?
14:39:15 <Riastradh> Igloo
14:39:43 <dons> "I use n+k patterns, and I vote"
14:39:55 <Igloo> I used them to get a more direct translation of the layout rule from the report, and I often use them when otherwise I would have to have lots of (n-1)s or bind n' = n - 1
14:40:15 <dons> oh, that's interesting
14:40:27 <Igloo> But I don't think you can just say "Views are the answer for Haskell 2" when no impl supports them as an extension yet
14:40:34 <LittleDan> I wonder why not
14:40:47 <Lor> Couldn't you do that sort of stuff more neatly with some sort of a primitive recursion combinator?
14:41:17 <Igloo> There are probably other cases where they gave a more direct translation, but I can't name them OTTOMH
14:41:33 <dons> does mingw provide, for example, ncurses.h and regex.h ?
14:42:07 <Lor> primrec z s 0 = z; primrec z s n = s (n - 1) (primrec z s (n - 1)) or something...
14:42:44 <LittleDan> how often do would you use that?
14:43:23 <Lor> Dunno, prolly not often.
14:43:38 <Lor> You'd get the same effect with [0..] and scanl
14:43:46 <Igloo> In fact, now I think about it, it's really just special sugar for   f (Succ n)  , so it's not really any more a wart than numbers in general having special syntax
14:44:37 <Lor> Do n+k patterns work with arbitrary instances of Num?
14:44:43 <Igloo> Yes
14:44:49 <LittleDan> Igloo: numbers in Haskell work by the peano axioms?
14:46:51 <jyp> Not axioms are specified
14:46:57 <jyp> s/not/no
14:47:42 <LittleDan> but he used a sucessor type thing
14:47:47 <kosmikus> I think there are many other issues. I don't think there's actually a consensus on MP type classes, functional dependencies, implicit parameters, GADTs, and consequences all those might have on Prelude or standard library redesign.
14:48:19 <jyp> LittleDan: that's non-standard
14:48:59 <Lor> How about the class hierarchy for general algebraic structures?
14:49:00 <dons> the altnerative is to code up certain extensions as appendicies, like the FFI
14:49:30 <LittleDan> kosmikus: what differing views are there on those? Do people think they're just unnecessary?
14:49:35 <dons> rather than trying to do a complete redesign
14:49:40 <kosmikus> dons: yes, I think that's the way to go.
14:50:00 <Lor> LittleDan, people just don't feel like they understand the consequences of new and nifty features well enough.
14:50:04 <Igloo> kosmikus: Yeah, but you can always leave them for Haskell 2.1/2.5/3 if you can't decide what to do about them, whereas not fixing what's already there is worse IMO
14:50:08 <kosmikus> I'd not like MP type classes and fundeps to become standard.
14:50:12 <arjanb> i wonder whether consensus is possible with the speed new nifty get created as extensions to haskell
14:50:21 <LittleDan> why not?
14:50:43 <kosmikus> ugly ;)
14:51:02 <jyp> Can anyone point me to a binary IO library (ghc, linux)
14:51:20 <kosmikus> arjanb: I'd be surprised if Haskell 2 would happen within the next 5 years, but who knows ...
14:51:47 <jyp> Basically I'd like an "interact :: [Word8] -> [Word8]" function
14:51:48 <Igloo> You currently need them to get the Control.Monad hierarchy, I think
14:52:55 <dons> jyp: if it is just a pure function, use Data.Bits and GHC.Word
14:53:11 <jyp> whoops
14:53:39 <jyp> "interact :: ([Word8] -> [Word8]) -> IO ()"
14:53:48 <dons> real bianry IO is the domain of the various binary libs out there. ghc has one in ghc/compiler/utils. nhc98 has the predecessor of that. hs-plugins uses a variety of the ghc one
14:54:15 <dons> you could probably find 3 or 4 other binary IO libs out there
14:54:50 <jyp> Any of them you've already used ?
14:55:03 <dons> I've used the latter 2 (one of which I wrote ;)
14:55:29 <dons> but, i'm a bit suspicious that you don't really need binary IO, since you only work on Word8s
14:55:56 <dons> binary IO is for arbitrary types. do you need to construct/destruct arbitrary types?
14:56:05 <jyp> Yup,
14:56:34 <jyp> All I need is the equivalent of interact but for bytes instead of Chars
14:57:10 <dons> @type interact
14:57:11 <lambdabot> interact :: (String -> String) -> IO ()
14:57:48 <jyp> or interact :: ([Char] -> [Char]) -> IO ()
14:58:19 <jyp> what is need is ([Word8] -> [Word8]) -> IO ()
14:58:33 <dons> interact f      =   do s <- getContents
14:58:33 <dons>                        putStr (f s)
14:58:48 <Janni> G'evening
14:59:47 <dons> I don't see where the binary lib comes in, if you're just filtering Word8s
15:00:31 <Lor> Is unsafeInterleaveIO a wart?
15:01:10 <dons> interactW f = do hGetBuf h ptr n ; f ptr ; hPutBuf h ptr n ; hClose h
15:01:23 <jyp> Thanks ;)
15:01:35 <dons> Lor: maybe. but it isn't too ugly. and it's very nice for constructing lazy lists
15:02:00 <dons> unsafeInterleaveIO (IO m)
15:02:00 <dons>   = IO ( \ s -> let
15:02:00 <dons>            r = case m s of (# _, res #) -> res
15:02:00 <dons>         in
15:02:00 <dons>         (# s, r #))
15:02:26 <dons> if it's just 'let' and 'case' it can't be a wart ;)
15:03:30 <Lor> Well...
15:04:45 <dons> @type GHC.IOBase.unsafeInterleaveIO
15:04:46 <lambdabot> GHC.IOBase.unsafeInterleaveIO :: forall a. IO a -> IO a
15:04:59 <dons> so I guess the type doesn't reveal all :)
15:06:53 <Lor> Well yeah, the implementation is based on special knowledge about ghc's evaluation order.
15:07:36 <dons> is it GHC, or just Haskell?
15:07:40 <Lor> This was pointed out in some paper about how ghc implements IO... forget which one.
15:07:43 <Lor> dons, GHC.
15:08:12 <dons> I guess there is some magic in how values are demanded later on
15:08:34 <Lor> Haskell semantics would allow r to be evaluated beforehand optimistically.
15:09:00 <dons> ah. true. i've spent too long in STG-machine land
15:10:28 <dons> jyp: true binary io: http://www.cs.york.ac.uk/fp/nhc98/libs/Binary.html
15:10:28 <Igloo> Does unsafeInterleaveIO guarantee not to evaluate its argument optimistically?
15:10:58 <Lor> It'd be kind of useless if it didn't.
15:11:15 <dons> "When passed a value of type @IO a@, the 'IO' will only be performed
15:11:16 <dons> when the value of the @a@ is demanded."
15:11:27 <Igloo> Well, Haskell doesn't guarantee not to evaluate [1..] optimistically in   head [1..],   but I like to think Haskell isn't useless
15:11:43 <Lor> The difference is in side effects.
15:11:47 <jyp> dons: much thanks
15:12:05 <dons> jyp: but i'm still not sure if that is really what you want ;)
15:12:14 <Igloo> I didn't think unsafeInterleaveIO guaranteed anything about when sideeffects will happen
15:12:34 * Igloo reads up - oh, fair enough
15:12:59 <jyp> dons: Your 1 liner alsmost did it except it required to allocate a buffer large enough beforehand
15:12:59 <Lor> If it didn't, then interact wouldn't work.
15:13:12 <Igloo> But given Haskell doesn't stop whatever uses the a from being optimistically evaluated I think that comes down to the same thing (unless it's entirely unused, I guess)
15:14:04 * Igloo can't actually remember if head [1..] is guaranteed to terminate given the vagueness of the report
15:14:24 <Igloo> The point is there's a difference between what will happen with real impls and what is guaranteed
15:15:36 <Pseudonym> Igloo: All programs terminate.
15:15:54 <Pseudonym> The power gets kicked, someome types ^C, the computer gets decommissioned...
15:16:09 <kosmikus> Igloo: huh, head [1..] not terminating, have I missed something?
15:16:13 * esap thinks that's not guaranteed.
15:16:19 <jyp> dons: What I need is really simple except all standard IO functions insist on returning Chars whereas I need raw bits.
15:16:24 <dons> jyp: liftM (map castChartoWord8) hGetContents >>= return . f >>= hPutStr
15:16:46 <jyp> dons: looks neat
15:16:57 <Lor> and ignores locale issues completely.
15:17:07 <dons> hehe. of course!
15:17:28 <Igloo> kosmikus: evaluation order isn't defined strongly, e.g. I think ghc's optimistic evaluation was within that it required, but I can't remember just how lax it is
15:19:34 <esap> "The order of evaluation of expressions in Haskell is constrained only by data dependencies; an implementation has a great deal of freedom in choosing this order" (section 7 intro)
15:20:29 <Lor> A default-strict mode might be interesting to experiment with.
15:20:46 <Lor> Hm, wasn't that something that Tim Sheard mentioned at HW03?
15:22:18 <segphault> is there a way to do tests on constructors? I'm writing a bunch of functions like this: isA (A _) = True; isA _ = False  and I would much rather just be able to do something like: (== (A _))  ... I know that syntax doesnt make sense, but you get the ideaq
15:22:57 <dons> jyp: getWord8 = do c <- hGetChar ; return $! (fromIntegral (ord c))
15:23:05 <dons> that's  how GHC reads .hi files in binary
15:23:18 <kosmikus> the Report is indeed more vague than I remembered
15:23:40 <Lor> segphault, sorry but no.
15:23:48 <Lor> Well, with TH you might cook up something.
15:23:53 <segphault> hm
15:24:12 <Lor> But there are no first-class constructor tags.
15:24:21 <dons> wouldn't that be fun
15:24:40 <segphault> I could do something stupid, like write a function that does 'show' on the object and extracts the constructor name... but that would probably be *really* friggin slow
15:24:52 <Lor> Which is actually a bit of a shame, because they would be useful e.g. for declaring token types for parsers.
15:25:06 <segphault> indeed
15:25:34 <Lor> That is one of the few reasons why I sometimes would prefer happy over parser combinators.
15:25:50 <jyp> dons: good; but I need to write too... So far my program fails with "Fail: Prelude.chr: bad argument"
15:26:24 <dons> chr ?~
15:26:29 <esap> Doesn't the Data.Generics provide first-class constructor tags (at least close)
15:26:41 * LittleDan wonders if first-class tags can be created with TH or an extension or something
15:26:46 <dons> ok. I'll write a test instead of theorising in irc
15:26:53 <jyp> For Word8 -> Char
15:27:04 <dons> oh. you're writing the cast?
15:27:45 <jyp> I tried too, but chr doesn't seem to accept any combination of 8 bits
15:28:09 <kosmikus> Igloo: in my offline version, which isn't the most recent, there's a Section 6.2 "Strict Evaluation" which is pretty explicit, and I think it'd even rule out optimistic evaluation
15:29:35 <Igloo> Hmm, I think that's just badly written motivation for seq
15:30:09 <kosmikus> it is, but still ...
15:30:18 <dons> jyp: f :: Char -> Word8 ; f c = fromIntegral (Char.ord c)
15:30:26 * Igloo is trying to decide whether it disallows GHC's strictness analysis too
15:30:54 <kosmikus> don't think so, but then again, I don't know how exactly that works
15:31:36 <Igloo> Well, it evaluates something it knows /will be/ required, but earlier than /when/ it's required
15:31:37 <kosmikus> well ok, it says "when required", not "if required" ;)
15:31:46 <kosmikus> yes, just saw that
15:31:55 <jyp> dons: Thanks... However I think I'm just too tired too think cleary; I'll call it a day and check again tomorrow ;)
15:32:15 <jyp> Night everyone
15:32:19 <kosmikus> I think this sentence should be considered a "bug" in the Report
15:32:53 <Igloo> Yeah, although it's a little hard to write good documentation about seq when the evaluation order is so vague to begin with  :-)
15:33:17 <kosmikus> simple: when using seq, evaluation order is no longer vague
15:33:35 <Pseudonym> Or perhaps, no longer quite as vague.
15:34:06 <Igloo> But it is. You can't even say nothing within seq is evaluated before the seq as it may be shared with something outside of the seq
15:34:18 <esap> Is it really that vague? Well maybe it's just the compilers, but to me the evaluation order seems pretty deterministic, I haven't seen any big surprises.
15:34:35 <kosmikus> furthermore, I think that the report should specify that the result of a Haskell program (modulo unsafe effects) should be the same as in normal-oder reduction
15:34:37 <Igloo> esap: In practice we know roughly what the implementations will do
15:34:50 <Igloo> We're just debating the letter of the report for no good reason  :-)
15:34:57 <Pseudonym> That's partly because in practice, we don't write programs which exercise corner cases.
15:35:20 <Pseudonym> For example, in the real world, seq _doesn't_ break monad semantics, because people don't write programs like that.
15:35:23 <kosmikus> well, the question is whether the implementations approximate Haskell better than the Report does ;)
15:35:25 <Pseudonym> We try to avoid deliberate bottoms.
15:36:09 <LittleDan> Pseudo: isn't undefined useful sometimes, like when doing type stuff?
15:36:28 <Pseudonym> Yes, but we avoid evaluating them.
15:36:38 <Pseudonym> In theory you could write an exception-driven loop.
15:36:47 <Pseudonym> But in practice, don't.  Just don't.
15:37:02 <LittleDan> what's an exception-driven loop?
15:37:27 * esap has tried to write code that would be guaranteed to evaluate the whole expression given as argument to normal form within an expression before continuing.
15:37:32 <Pseudonym> You write an infinite loop, where the loop is terminated by throwing an exception.
15:37:41 <Pseudonym> e.g. evaluating undefined
15:38:14 <esap> I've seen a situation where the correctness of unsafePerformIO was dependent on whether you could evaluate fully to normal form.
15:38:44 <esap> see http://haskell.org/hawiki/ControlOperation
15:39:13 <kosmikus> good night
15:39:32 * esap notes DeepSeq and all uses of $!, evaluate etc.
15:40:37 <dons> jyp: http://www.cse.unsw.edu.au/~dons/t.hs
15:41:10 <dons> too late.
15:42:53 * segphault wonders what would happen if he told lambdabot to evaluate [1..]
15:43:20 <Riastradh> @eval [1..]
15:43:21 <lambdabot> (line 1, column 4):
15:43:21 <lambdabot> unexpected "."
15:43:21 <lambdabot> expecting simple term
15:43:28 <LittleDan> hmm
15:43:37 <segphault> ah. it cant do ..
15:43:40 <LittleDan> @eval [1..5]
15:43:40 <lambdabot> (line 1, column 4):
15:43:40 <lambdabot> unexpected "."
15:43:40 <lambdabot> expecting simple term
15:43:42 <LittleDan> yeah
15:43:52 <Riastradh> @eval let x = 1:x in x
15:43:53 <lambdabot> (line 1, column 7):
15:43:53 <lambdabot> unexpected "="
15:43:53 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
15:43:53 <lambdabot>  "(", operator, simple term or end of input
15:44:01 <Riastradh> @eval let x where x = 1:x
15:44:02 <lambdabot> (line 1, column 15):
15:44:02 <lambdabot> unexpected "="
15:44:02 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
15:44:02 <lambdabot>  "(", operator, simple term or end of input
15:44:05 <esap> @eval enumFrom 1
15:44:26 * segphault pokes lambdabot
15:44:30 <segphault> I think you killed it. lol
15:44:37 <Riastradh> @eval 3
15:44:39 <lambdabot> out of fuel - use @resume to continue
15:44:39 <lambdabot> 3
15:44:43 <segphault> LOL
15:44:51 <LittleDan> when I do that to a Haskell repl it prints it out infinitely
15:45:57 <esap> @eval take 10 (enumFrom 1)
15:45:58 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
15:46:40 <LittleDan> @eval undefined
15:46:47 <lambdabot> out of fuel - use @resume to continue
15:46:51 <LittleDan> @resume
15:46:57 <lambdabot> out of fuel - use @resume to continue
15:47:38 <segphault> @eval enumFrom 1.0/0
15:47:38 <lambdabot> type error
15:47:44 <segphault> @eval enumFrom 1/0
15:47:44 <lambdabot> type error
15:48:22 <Riastradh> (Hint: Function application has higher precedence than any operator.)
15:48:28 <Lemmih> You want to divide a list with zero?
15:48:37 <segphault> @eval enumFrom (1.0/0)
15:48:38 <lambdabot> type error
15:49:31 <segphault> @eval 1.0 / 0
15:49:31 <lambdabot> type error
15:50:04 <Riastradh> @eval 1.0 / 0.0
15:50:04 <lambdabot> type error
15:50:13 <Riastradh> . is function composition, I believe.
15:50:14 <Riastradh> @eval 1.0
15:50:15 <lambdabot> <<EM Dynamic -> EM Dynamic>>
15:50:52 <segphault> @eval 1 / 0
15:50:52 <lambdabot> divide by zero
15:51:56 <segphault> @eval "@eval 1"
15:51:56 <lambdabot> @eval 1
15:52:11 <lambdabot> Nice try, segphault.
15:52:15 <segphault> LOL
16:06:32 <shapr> Ron Jeffries is hard to believe sometimes =) He is amazing.
16:08:44 <Lemmih> Note to self: Linking order of the RTS is not fixed.
16:09:18 <Igloo> shapr?
16:09:24 <Igloo> Lemmih?
16:09:33 * Igloo doesn't seem to be doing too well tonight  :-)
16:10:30 <shapr> Igloo: I'm writing a blog entry about it...
16:10:40 <shapr> which just found an amusing bug in PLog btw.
16:10:58 <shapr> input lines starting with -- don't turn up in the output
16:11:18 <Lemmih> I was having problems with a library which was shadowing 'main' from the RTS.
16:11:34 <Igloo> Ahh
16:11:54 * shapr is still cackling happily over this lovely bit of Ron Jeffries' wisdom
16:12:14 <dash> what did Ron Jeffries say this time 
16:14:45 <shapr> In essence he said that if you use a bugtracking system at all, you suck.
16:15:08 <shapr> No, he said if you *need* a BTS you suck.
16:15:19 <shapr> ah, just a moment while I write this up.
16:17:05 <dash> shapr: i find that difficult to reconcile with my current experience
16:18:44 <tuomov> people who don't suck don't make bugs
16:18:52 <Riastradh> QED.
16:19:58 <shapr> Actually, RJ said that people who fix bugs when they find them stay very near zero count of bugs.
16:20:00 <dash> tuomov: i find that also hard to believe!
16:20:17 <dash> shapr: yeah but sometimes the person who finds it ain't the person who needs to fix it :)
16:20:26 <shapr> This is interesting, because it fits into a simple get it done strategy I've heard elsewhere.
16:20:29 <dash> and you've gotta keep track of those somewhere
16:20:34 <shapr> collective code ownershipt gets rid of that.
16:20:39 <tuomov> I don't need bug tracking for Ion
16:21:02 <tuomov> there have never been that many bugs, and I usually fix them immediately when I hear of them, or at least within few days
16:21:22 <tuomov> unless it is something that is not serious and is related to some architechtural change
16:21:43 <dash> shapr: yeah, but the QA team shouldn't own the code
16:22:17 <tuomov> segfaults are something that are to be fixed immediately
16:22:26 <tuomov> because segfaults mean you suck (for choosing C in the first place)
16:22:31 <dash> right
16:22:33 <dash> those are easy to fix
16:23:35 * Igloo goes through removing $MACHINE from hmake and finds it seems to test for whether you're using cygwin in a different way each time
16:23:40 <dash> shapr: besides, in a small team, people naturally specialize, and what would take days of familiarization for one person would be an hour's work for another
16:23:41 <dons> tuomo says "segaults mean youu suck"
16:23:53 <tuomov> :)
16:24:43 <shapr> dash: I disagree.
16:25:28 <shapr> I think it should be the other way around, every member of a team should be ultimately responsible for the code.
16:25:54 <shapr> anyway, here's the entry - http://www.scannedinavian.com/2004-11-19.html
16:27:05 <dash> shapr: well yes ultimately responsible
16:27:19 <dash> shapr: but it makes sense for people with different areas of knowledge to work on different areas of the code
16:27:20 <tuomov> I think, ideally, programs should be so small that one person can handle it
16:27:44 <shapr> I disagree. I think each member of a team should be able to work on any part of the code.
16:27:48 <tuomov> bigger programs just use a lot of libraries
16:27:56 <dash> shapr: why? that's a lot of extra work
16:27:57 <tuomov> that could be used by other programs as well
16:28:05 <dash> shapr: take Quotient, for example
16:28:30 <shapr> For a lot of different reasons...
16:28:38 <shapr> maybe I should write more in this entry =)
16:28:38 <dash> shapr: i don't know javascript or IMAP and the guys who do don't have the SIP RFC memorized
16:29:01 <dash> shapr: so we all work on different subsystems
16:29:21 <dash> shapr: what's the rationale for making everyone learn all the nuances of every part of the system?
16:30:18 <dash> remember orwell's rules of software design!
16:30:29 <dash> "freedom is slavery", "ignorance is strength"
16:30:37 <shapr> 1.  Anybody can get vacation when they need it. 2. The projects Bus Number is high 3. Everyone improves their education 4. Having both high and low level understandings means anyone can make design improvements and better informed decisions.
16:30:46 <shapr> I can go on...
16:32:03 <dash> #2 will be true regardless, #3 is irrelevant
16:32:14 <shapr> No it's not!
16:32:36 <shapr> C'mon, we all like to eat.
16:32:51 <dash> #4 is not relevant either because the cost of design changes will be high anyway
16:32:53 <shapr> I won't take a job where my employers are not interested in my continuing education.
16:33:17 <tuomov> I think very few employers would be interested in the kind of education I am
16:33:27 <shapr> And I don't want to write code or work on a project where I'm not learning new stuff at least part of the time. How else can I assure that I will be hired in the future? How else can I remain qualified?
16:33:28 <dash> shapr: i don't think that's quite the same thing
16:33:34 <tuomov> and I don't really want to learn dozens of different APIs and stuff
16:33:38 <tuomov> I just want to learn the cool ones
16:34:02 <shapr> Well, I do want to learn dozens of different APIs, sometimes they're a lot cooler after I've started using them.
16:34:15 <bojohan> how do i stop wxHaskell from blowing up under ghci? 
16:34:18 <tuomov> but then again, I'm a theory nut
16:34:23 <dash> shapr: being _able_ to work on multiple parts of the system is one thing
16:34:25 <shapr> Unless it's J2EE, and at least I can say with confidence that I *know* it sucks =)
16:34:28 <dash> being _required to_ is another
16:34:53 <shapr> bojohan: I don't think you can... it's a threading problem, iirc
16:35:03 <shapr> but that may have changed recently, I'm not sure.
16:35:07 <dash> shapr: my point is that it is expensive for everyone to understand all the code all the time 
16:35:19 <dash> shapr: I am uncertain that the benefits outweigh those costs
16:35:21 <shapr> and my point is that it's more expensive to *not* understand all the code all the time.
16:35:32 <dash> shapr: Perhaps there are situations where this is true
16:35:39 <shapr> for design, for bug finding and fixing, and especially for education
16:35:39 <dash> but I don't think i'm in one of them :)
16:35:42 <tuomov> if the api can't be presented on one a4, it sucks :)
16:35:57 <dash> tuomov: in what encoding
16:36:18 <shapr> the XP approach uses Pair Programming to speed and smooth the flow of information from one experience person to another
16:36:19 <bojohan> and it writes a 30M core file every time :(
16:36:27 <tuomov> I don't like bloated over-engineered apis. I want to compose stuff from powerful primitives
16:36:34 <dash> shapr: pair programming is great when you can get it
16:36:45 <dash> shapr: it's very hard for our most of our company right now
16:36:48 <shapr> XP also says that every member of the team should work on all parts of the code at different times, even though they may have their specialties.
16:37:14 <tuomov> dash: "normal size" font etc.
16:37:27 <shapr> I know your company is geographically distributed but hey, you guys hack on a networking framework, what are you waiting for? ;-)
16:37:30 <dash> tuomov: i vote for gzip and conversion to a dot matrix
16:37:37 <dash> shapr: airline tickets
16:37:51 <dash> shapr: we use screen and the phone
16:37:52 <shapr> No, I mean Virtual Pair Programming in the style of Self's Kansas.
16:37:57 <dash> shapr: but it ain't the same 
16:38:04 <shapr> http://research.sun.com/ics/pics/overview.GIF
16:38:11 <dash> i know about Kansas
16:38:37 <shapr> Anyway, I'm in a one-programmer company, so I'm not doing any better than you.
16:38:41 <dash> heh heh
16:38:47 * shapr casts a stone in his own direction
16:39:19 <dash> anyway
16:39:23 <dash> if we were to implement that strategy
16:39:33 <dash> it'd be 2-3 weeks before we got anything else done
16:41:29 <shapr> Well, I don't know about your company specifically, but I am convinced that if app knowledge doesn't flow to all members of the team you'll have problems in the future.
16:42:26 <shapr> Specialization is for insects -- Robert Heinlein
16:42:35 <tuomov> it depends..
16:42:47 <tuomov> if the coder who leaves the group sucks, then you'll have problems
16:42:51 <shapr> Speaking of which, I want to get out of the webdev business, or at least get some other work :-/
16:43:03 <tuomov> because it takes time to figure out bad code
16:43:16 <dash> shapr: specialization is for civilization :)
16:43:19 <shapr> But, collective code ownership means a sucky coder won't last.
16:43:26 <tuomov> and I think well-written code is easier to read than documentaion
16:43:38 <tuomov> over-specialization is de-civilization
16:43:49 <Riastradh> Specialization is for industrialized capitalist pigs!  Down with the ruling class!  Rhaaa!
16:44:12 <shapr> I don't much believe in specialization for purposes of civilization either.
16:44:34 <tuomov> there are some things people naturally specialize in in some extent
16:44:40 <tuomov> but most people would like to do other things as well
16:44:45 <shapr> Obviously it's good to have a specialty. But I think that shouldn't exclude everything else.
16:44:57 <dash> shapr: division of labour is a result of capital structure
16:45:22 <shapr> Yah, I don't disagree with that.
16:45:33 <dash> shapr: if nobody specialized then you'd be spending all day tending your crops or your herds and not posting on your blog or writing haskell programs ;)
16:45:50 <tuomov> there's specialization and over-specialization
16:45:57 <tuomov> over-specialization is that you never do anything else but one thing
16:46:14 <tuomov> specialization is that you know about some things more than others, but are also able to and do other things
16:46:15 <shapr> Well, I did spend about a year tending to my grandfather's crops, cattle, and farm equipment.
16:46:52 <shapr> I never want to castrate another animal, but I do enjoy gas and arc welding.
16:47:37 <tuomov> and if you ask me, I think all people should do their part in tending crops and cattle
16:47:44 <dash> why's that
16:47:49 <tuomov> it wouldn't be many hours a month if everyone did that
16:48:00 <tuomov> and more people would be free to pursue other interests
16:48:02 <shapr> Plus I'm sure we'd have OpenFarm pretty quick ;-)
16:48:24 <shapr> Think of IBM's X-10 home automation framework applied to a farm, that would rock.
16:48:37 <dash> tuomov: more people would be free to pursue other interests? how so?
16:49:03 <tuomov> because they're don't have to spend all their time doing that
16:49:20 <dash> heh
16:49:30 <shapr> Things I've learned in farming are quite applicable to other fields of study.
16:49:40 <shapr> 'hybrid vigor' is a good example of that.
16:50:32 <shapr> The idea behind crop rotation fits just as well into scheduling your own learning.
16:50:43 <shapr> Anyway
16:52:32 <Pseudonym> One of the benefits of XP, IMO, is that programmers are interchangable.
16:52:47 <Pseudonym> It not only benefits management (no single point of failure), but also it benefits programmers.
16:52:49 <shapr> Right, but another benefit of that is that *companies* are interchangable.
16:52:52 <shapr> right!
16:53:00 <Pseudonym> Because they can work on what they like rather than what they have to.
16:53:06 <tuomov> when the productive capabilities of mankind were poor, it was essential that some people be allowed to concetrate on other things for the advancement of science and so on. And that in turn lead to the formation of the kinds of authoritative power structures we have these days. But with the present technology, this is no longer necessary. Everyone could do their part, and yet everyone would have time for intellectual and other interests as well.
16:53:19 <shapr> That's one reason it's so important to become as familiar as possible with all parts of the application you're writing.
16:53:25 <Pseudonym> Right.
16:53:33 <Pseudonym> Well, that doesn't scale completely.
16:53:54 <Pseudonym> You can understand all parts of an application "enough" up to about 2 million lines of code, I think.
16:54:10 <Pseudonym> Beyond that, it's infeasable to get all programmers working on the project familiar with all bits.
16:54:30 <Pseudonym> But beyond 2 million LOC, you'd better have good modularity.
16:54:54 <Pseudonym> You'd better be talking about a product family, or a suite of components.
16:55:24 <Pseudonym> Windows XP is supposedly about 30MLOC, but that includes a large number of drivers.
16:55:46 <dash> tuomov: why?
16:55:57 <Pseudonym> And Win XP is actually a product family.  It's the OS, plus a web browser, plus some admin tools, plus plus plus.
16:56:08 <tuomov> why what?
16:56:20 <dash> tuomov: why is it no longer necessary
16:56:48 <dash> we're at 124 KLOC of python code, and we already need all the modularity we can get ;)
16:57:01 <Pseudonym> Well obviously. :-)
16:57:11 <Pseudonym> Our database server is about 2MLOC.
16:57:23 <Pseudonym> Some of that is automatically generated, from ASN.1.
16:57:23 <tuomov> dash: because agriculture is more efficient these days
16:57:31 <tuomov> and other things as well
16:57:40 <tuomov> indeed, there's a large number of surplus people in modern society
16:57:49 <dash> tuomov: "surplus"?
16:57:54 <Pseudonym> But the important thing is this: Not that you are familiar with every LOC, but rather, knowing what each "module" does.
16:57:55 <tuomov> unemployed, lawyers, management, etc.
16:58:13 <dash> tuomov: there's a place for lawyers and management :)
16:58:17 <tuomov> there simple isn't enough meaningful work for everyone to do if we stick to 8h/day wage slavery
16:58:26 <Pseudonym> Management aren't entirely surplus.
16:58:42 <Pseudonym> Management was crucial even 3000 years ago.
16:58:43 <dash> tuomov: i don't believe that for a minute
16:58:59 <Pseudonym> Do you think the pyramids would have been built without good management?
16:59:16 <tuomov> pyramids wouldn't have been built without slavery
16:59:17 <dash> Aliens built the pyramids.
16:59:25 <dash> But they probably had managers too.
16:59:26 <Pseudonym> Pyramids weren't built by slaves.
16:59:40 <Pseudonym> Though slavery was important to support the society which built them, yes.
16:59:58 <tuomov> well, true. but those who built them were coerced into it nevertheless
17:00:07 <Pseudonym> Not necessarily, unless you mean indirectly.
17:00:13 <dash> heh
17:00:21 <dash> as if we really know anything about who built the pyramids and why
17:00:24 <Pseudonym> As I understand it, the modern thinking is that it was like a national service project.
17:00:34 <Pseudonym> dash: Well, we can make an educated guess.
17:00:38 <whee> (I agree with the aliens idea ;))
17:00:53 <Pseudonym> For example, we can dig up the bodies of the people who did it and decide if they were educated or not based on their diets.
17:01:04 <Pseudonym> We're not completely in the dark.
17:01:23 <tuomov> the same kind of coercion that a wage slaver is under: if you don't accept the work given to you, you lose youre livelyhood
17:01:31 <Pseudonym> True.
17:01:32 <tuomov> s/slaver/slave/
17:01:43 <Pseudonym> Note that wage slavery isn't the only kind of slavery in the modern world.
17:01:55 <Pseudonym> A lot of the US economy is dependent on illegal immigrants.
17:01:58 <dash> whee: i was joking ;)
17:02:29 <dash> tuomov: eh? where is that happening
17:02:43 <tuomov> what happening?
17:02:45 <tuomov> when?
17:02:51 <dash> tuomov: "if you don't accept the work given to you"
17:02:53 <dash> given by whom?
17:03:07 <Pseudonym> Wage slavery is actually more insidious than more traditional kinds of slavery.
17:03:16 <Pseudonym> Because there are carrots to stay in wage slavery.
17:03:21 <tuomov> employer, unemployment office
17:03:26 <dash> i don't understand
17:03:34 <tuomov> if you don't do exactly what the employer says, he kicks you out
17:03:36 <dash> if you said "tax slavery" i would understand what you mean 
17:03:41 <Pseudonym> Namely, consumer goods and packaged entertainment.
17:03:46 <dash> tuomov: ok? and how is that like slavery?
17:03:49 <tuomov> if you don't take the shit job th employment office points you at, you lose your benefits
17:04:10 <dash> tuomov: well, unemployment benefits are a scam anyway
17:04:10 <Philippa> dash: the bit where no money = starvation
17:04:27 <Philippa> in what regard?
17:04:37 <Philippa> (I ask this as somebody currently on them)
17:04:46 <tuomov> corporations are authoritarian structures, you are not free when you're at work
17:04:52 <dash> you don't see any particular problems with giving people money not to work? :)
17:04:59 <tuomov> a wage slave is free to choose his master, but is still the master's slave
17:05:12 <dash> tuomov: i don't understand the way you're using the word "slave"
17:05:15 <Philippa> dash: where I am, the money's barely enough to live on
17:05:39 <Philippa> you're not going to be eating anything overly pleasant, you certainly can't afford entertainment
17:05:54 <shapr> According to my current thinking, gov't support should be barely enough to live on...
17:05:55 <Pseudonym> The theory is that unemployment benefits are designed to get you working doing whatever you can do.
17:06:05 <shapr> Right, that's my current thinking.
17:06:20 * Philippa nods
17:06:22 <Pseudonym> When I was on benefits for about 6 weeks, that was certainly what I was told.
17:06:43 <Philippa> though with exceptions for those who're in a state where they're not able to work
17:06:44 <Pseudonym> I had to fill out this little book showing at least ten employers that I had spoken to every fortnight.
17:06:53 <tuomov> oh yeah, and if the employer fires you for non-economical reasons, or you quit yourself, they don't give benefits for three months here
17:07:08 <Pseudonym> I was probably the only person in the unemployment system who put down "head hunted by NVIDIA; rejected as the commute to Silicon Valley was too long".
17:07:10 <tuomov> I've been without a job for almost three months now and haven't seen a penny
17:07:17 <shapr> Sweden has huge benefits, there was a recent article about a woman who was 'sick' from 1993 to 2003, where she was employed for three?months. She became sick again, and sued the gov't because she didn't get the new higher unemployment benefit from her 2003 employment. She went back to her 1993 level of support.
17:07:35 <tuomov> so if you don't have any savings, you can't even quit a shitty job
17:07:42 <tuomov> I call that slavery
17:07:52 <Philippa> shapr: what value of 'sick'?
17:08:26 <Pseudonym> tuomov: That's very wrong.
17:08:34 <shapr> I don't remember. But I am convinced that the system is too supportive in Sweden.
17:08:44 <Pseudonym> IMO, it doesn't matter why you're unemployed.
17:08:54 <Pseudonym> Though flags should be raised if it looks like you can't hold down a job.
17:09:11 <Philippa> sure. Though how that's reacted to should vary based on /why/ you can't hold it down
17:09:19 <Pseudonym> Sure.
17:09:32 <Philippa> plenty of untreated depression cases and so forth in that situation
17:10:05 <shapr> I'm sort of irritated by some of my SFI classmates who are only taking Swedish class because the immigration bureau said they had to take the class or lose their gov't support. But I realize I have a strongly biased USA work-to-eat viewpoint.
17:10:41 <tuomov> people should not have to work for basic livelyhood (housing, food)
17:10:55 <tuomov> and that should be without any bureaucracy
17:11:02 <Pseudonym> tuomov: Yes and no.
17:11:04 <whee> tuomov: I'm lazy enough that I would be useless to society if that were the case
17:11:24 <tuomov> I'd do things, but they'd have to be rewarding things
17:11:28 <Pseudonym> The flip side of that is that society don't need to support millionairres.
17:11:32 <tuomov> not the kidn of shit my ex job was
17:11:35 <Pseudonym> Though, again, there are limits.
17:11:48 <Pseudonym> I wouldn't object to paying taxes to go to rich children if they're genuinely disabled, for example.
17:11:53 <Pseudonym> I say this as a parent of a disabled child.
17:12:05 * Philippa nods
17:12:38 <Pseudonym> We don't get a huge amount from the government, but it's enough to take the edge off.
17:12:44 <Philippa> yeah
17:13:18 <Pseudonym> Oh, and we get discounted pharmeceuticals, which doesn't really help for autism.
17:14:37 <tuomov> anyway, I belive most people like doing things, but they must be interesting things and they must have very free hands in doing those things to do them, and those people who rather slack off are not a burden to society and should be thus tolerated
17:15:26 <dash> i agree
17:15:45 <dash> except i don't agree that i should be required to help feed slackers
17:15:52 <shapr> same here.
17:15:55 <Pseudonym> Well, even there...
17:16:00 <Pseudonym> Suppose slackers have children.
17:16:05 <Pseudonym> Should you help feed them?
17:16:12 <Pseudonym> It's not their fault their parents are slackers.
17:16:14 <tuomov> and even slackers may be artists and so on
17:16:20 <dash> Pseudonym: no
17:16:25 <dash> tuomov: and?
17:16:48 <tuomov> they may do important things even if it isn't something that is immediately beneficial to society
17:16:58 <shapr> That's true.
17:17:02 <shapr> hiya yaarg 
17:17:05 <shapr> lovely nickname.
17:17:12 <yaarg> hello
17:17:16 <Philippa> dash: that's IMO a foul response. The kid's not chosen to have slacker parents, but they're going to get seriously shat on as a result
17:17:29 <Philippa> the end result will probably leave them worthless to society
17:17:30 <dash> tuomov: so maybe they should do something beneficial to society too :)
17:17:36 <dash> Philippa: well yeah, it sucks
17:17:49 <dash> Philippa: and i'm not saying i'm opposed to helping them 
17:17:50 <tuomov> also, if basic livelyhood was quaranteed without the kind of bureacracy and head-kicking that is involved in it now, employers would have to treat workers better
17:18:11 <tuomov> dash: maybe, and most probably would
17:18:11 <dash> Philippa: i'm very much in favor of helping them 
17:18:24 <tuomov> if they didn't have to do it 8h/day
17:18:29 <shapr> tuomov: still, most of the people I've met wouldn't do anything if they didn't have to.
17:18:32 <dash> Philippa: but i am not in favor of other people forcing me to pay for their version of helping them 
17:18:33 <tuomov> 8h/day is a lot of your life
17:18:59 <shapr> I doubt many of the #haskell denizens fit into that group of people.
17:19:06 <tuomov> I think they would, if the workplaces wouldn't be organised as they are now
17:19:10 <tuomov> people like doing things.
17:19:30 <shapr> Maybe so. I guess a lot of them could be so frustrated they just won't do anything.
17:19:35 <tuomov> but I don't think many people really want to be arbitrarily bossed around.
17:19:58 <tuomov> but that's what the current society is built upon
17:20:17 <tuomov> depriving people of basic livelyhood if they don't subject to the whims of the rulers
17:20:39 <dash> tuomov: yep
17:20:56 <dash> tuomov: and if the govt gives people basic livelihood, it gets worse instead of better
17:21:07 <tuomov> yes and no
17:21:37 <dash> a corporation may be able to make its workers' lives miserable, but it's not too hard to look for another company to work for, or even start your own
17:21:58 <dash> a government involved in feeding and clothing people can make the entire nation miserable
17:22:05 <tuomov> but when all the corporations essentially treat people the same
17:22:12 <tuomov> and very few can be succesfull in their own business
17:22:20 <shapr> Part of the problem there is that we can't change governments easily.
17:22:32 <tuomov> and even then are subject to the will of venture capitalists
17:22:56 <shapr> Humans are rarely allowed to have multiple citizenships, so it's hard to change to a govt that you like better.
17:23:19 <tuomov> I don't like any govt. much more than any corporation
17:23:34 <shapr> Otherwise goverments would have to behave or lose citizens.
17:23:59 <tuomov> corporations don't have to behave for fear of losing workers..
17:24:16 <tuomov> and unemployment is kept up to ensure that
17:24:38 <tuomov> the govt. and corporations cooperate in this
17:25:03 <tuomov> the govt. doesn't treat unemployed people very well, so for most people "any job is better than unemployment"
17:25:23 <desrt> there's a difference.  a company isn't a democracy
17:25:33 <desrt> politicians don't do what's best for the people
17:25:39 <desrt> they do what is best for themselves to get reelected
17:25:44 <desrt> and this approximates what the people want
17:25:55 <desrt> so it's not all bad
17:25:58 <tuomov> no, it approximates what the powerful corporations want
17:26:11 <desrt> only in the united states
17:26:16 <tuomov> while still trying to keep people for making a revolution
17:26:22 <desrt> which is a bit of a corner case as far as democracy goes
17:26:28 <tuomov> finland, nokia. 'nuff said.
17:26:39 <desrt> have you ever been to finland?
17:26:45 <tuomov> lol
17:26:50 <desrt> well then :)
17:27:38 <shapr> desrt: are you joking?
17:27:50 <desrt> shapr; /whois tells me that i should be :)
17:28:02 <shapr> I used to work for Nokia second-hand via Widian.
17:28:03 <desrt> other than that, no comment
17:28:31 * shapr grins
17:30:04 <dash> yeah, the difference with corporations is that they have to actually do what their customers want
17:30:26 <dash> (unless they can get the govt to change the rules for them, of course)
17:30:26 <tuomov> not if you have a near monopoly situation
17:30:36 <tuomov> and that's where all markets tend to
17:30:48 <desrt> man
17:30:49 <shapr> Yah, that does suck.
17:30:50 <dash> tuomov: all monopolies are govt-created
17:30:54 <desrt> good thing the software market isn't like that
17:31:02 * shapr snickers
17:31:11 <desrt> otherwise you'd get prominant haskell hackers working for the monopoly in question
17:31:17 <desrt> and that would just be very unfortunate
17:31:53 * desrt pulls his tongue out of his cheek
17:32:00 <tuomov> dash: to some extent yes, by protectionism etc.
17:32:07 <Philippa> dash: he didn't say monopoly, he said near-monopoly - as in, the competition isn't worth talking about
17:32:22 <tuomov> but then, the govt. works for those corporations
17:33:30 <dash> tuomov: right
17:36:08 <tuomov> and in any case, corporations don't have to listen to their workers
17:37:13 <tuomov> there are some laws to prevent some worker abuse, but you can still make their life a hell thanks to a significant unemployed population
17:37:51 <shapr> Btw, any suggestions for high-capacity ogg players that can handle flying off a unicycle at high speed and -20Â°C?
17:38:09 <tuomov> no.
17:38:23 <shapr> oh well.
17:38:32 <tuomov> I had the hd in my player break when I accidentally dropped it from 1.5m to the floor
17:38:46 <tuomov> so now I have ~15G hd instead of 20G
17:39:21 <shapr> ok then, no HD player for me.
17:39:46 <tuomov> plain old cassette player is quite robust..
17:39:51 <shapr> I can guarantee that any music player I own will receive heavy physical shocks, probably from me landing on it.
17:43:23 <shapr> ah, I like Riku Voipio's latest blog entry: http://www.livejournal.com/users/nchip/ Mirrors my thoughts on software patents.
17:45:11 <segphault> interesting posts
17:45:56 <segphault> I often argue with myself about patents
17:46:18 <shapr> I am thoroughly against software patents.
17:46:20 <segphault> software patents are obviously having a really destructive affect, but I dont know that its the general concept of patents that is at fault
17:46:33 <shapr> I have wondered about that myself.
17:46:37 <tuomov> I'm against all IP.
17:46:48 <Philippa> the amount of work it takes to know you've not infringed on anything really doesn't help with patents
17:46:56 <tuomov> (and infact all "property", but that's another story.)
17:46:56 <shapr> Yup.
17:47:09 <Philippa> I wouldn't go that far. There're significant works that just can't be created without IP
17:47:31 <tuomov> I don't think so.
17:47:45 <tuomov> Sure you'll lose hollywood blockbusters and stuff, but who needs them anyway?
17:47:53 <Philippa> personally I'd miss Square's RPGs
17:47:55 <shapr> The patent system exists to encourage people to disclose their ideas in a reproducible manner and the payment is a temporary monopoly. I think that's a good way to get idea disclosure, and I think that no patent system might mean we lose a lot of ideas.
17:48:34 <shapr> But if I write code off the top of my head that infringes on a patent, it can't have been very novel in the first place.
17:48:41 <dash> heh
17:48:49 <dash> do the ends really justify the means?
17:49:02 <Philippa> there needs to be a far better defined obviousness test in software
17:49:20 <dash> i am reminded of the kittens-to-poptarts machine in Goats
17:49:40 * Pseudonym is reminded of the ceiling babies, but only because dash mentioned Goats
17:49:41 <shapr> ?
17:49:53 <dash> Pseudonym: weren't those awesome?
17:50:06 <Pseudonym> Yes. :-)
17:50:10 <dash> shapr: well, it's a machine that makes poptarts
17:50:19 <dash> you just have to put a kitten in it every once in a while
17:50:19 <segphault> the problem in america is that the government does nothing but waste money. The patent bureau here probably doesnt know the difference between a microchip and a potato chip, so expecting them to recognize something with "prior art" is pretty much a joke
17:50:23 <dash> but mmmmm, poptarts
17:50:24 <tuomov> but, yeah, elimination of IP requires that basic livelyhood is quaranteed for people who want to work on such things
17:50:25 <segphault> HAHAHAHA
17:50:35 <segphault> dash: I want one of those
17:50:35 <dash> segphault: wrong! the government does more than waste money
17:50:44 <segphault> it also kills foreigners.
17:50:45 <tuomov> and then there could be all sorts of awards
17:50:57 <segphault> and violates the rights of taxpaying citizens
17:50:57 <dash> segphault: it also tell people how to run their lives
17:51:02 <dash> right, and kill foreigners
17:51:12 <dash> gotta look at the big picture, man
17:51:24 <dash> tuomov: "requires"?
17:51:50 <dash> and guaranteed by whom? :)
17:51:52 <tuomov> if people want to spend some time writing a book and so on without doing other work
17:52:00 <dash> tuomov: yes?
17:52:02 <tuomov> the "system"
17:52:15 <tuomov> whatever that might be
17:52:18 <dash> haha
17:52:40 <dash> i think i am going to go dancing now instead of argue with you silly silly people any more
17:52:42 <segphault> tuomov: I dont understand how your system would work. who pays to support everybody?
17:52:49 <tuomov> I envision a world without states and corporations, so I didn't say the govt.
17:53:12 <dash> tuomov: well, it has to come from somewhere :)
17:53:16 <tuomov> but in the present setting govt. through taxes
17:53:20 <segphault> tuomov: like marxist style international communism?
17:53:34 <tuomov> segphault: more like anarchism (libertarian socialism)
17:53:45 <segphault> tuomov: thats a paradox
17:53:52 <Philippa> read Banks. Let technology sort it out
17:53:57 <segphault> tuomov: in that kind of society people would form corporations anyway
17:53:59 * Pseudonym wonders where Smerdyakov is when you don't need him
17:54:03 <Pseudonym> Oh, that's right.  Banned.
17:54:06 <Philippa> hehehe
17:54:20 <Philippa> thank fuck for that, ISTR him being extremely clueless on such matters...
17:54:20 <segphault> tuomov: you would end up with something that bordered on techno-feudalism
17:54:22 <tuomov> segphault: who would subject to a corporate rule when you're not coerced into it by any rulers?
17:54:34 <tuomov> people would form coopreatives
17:54:40 <tuomov> democratic workplaces
17:54:43 <segphault> tuomov: what is a cooperative? its a corporation
17:54:55 <Philippa> there's still power within a democracy
17:55:15 <tuomov> in direct democracy (and decentralised) democracy everyone has equal voice
17:55:22 <tuomov> representative "democracy" is a fraud
17:55:30 <segphault> tuomov: people would realize they can increase their quality of life by exploiting weaker cooperatives, and then cooperatives would start banding together into commerical conglomerates to pool resources so they can be the best exploiters
17:55:47 <Philippa> In theory. In practice, not everybody'll bother to listen enough to work out the right answers
17:56:17 <Philippa> segphault: congratulations, you've just discovered that communism works best in a post-scarcity environment :-)
17:56:25 <segphault> absolutely
17:56:43 <dash> everybody needs to go read Ken MacLeod's books, btw
17:56:48 <Philippa> am reading atm
17:56:50 <dash> _Star Fraction_ especially :D
17:56:50 <Pseudonym> Scarcity is also the major practical problem with pure Randian capitalism.
17:56:55 <Philippa> read SF already
17:56:55 <dash> Philippa: Thought so
17:57:01 <tuomov> segphault: I don't think so. But I don't want this discussion again. Please go read some anarchist texts instead.
17:57:03 <dash> Pseudonym: haha "pure randian capitalism"
17:57:06 <segphault> I think we need to totally eliminate government regulation of business in order to dramatically increase progress so we can reach a point where scarcity is no longer an issue
17:57:12 <Philippa> dash: I've not said anything I wouldn't have said beforehand
17:57:20 <segphault> tuomov: could you suggest a few good ones?
17:57:20 <Pseudonym> Obviously I use the term "pure" in a broad sense. :-)
17:57:35 <dash> Pseudonym: Rand was a nutter who didn't know a lot about economics :)
17:57:37 <Philippa> segphault: nice. You do that, there's a serious risk nobody'll sell me food
17:57:39 <tuomov> hmm.. anarchistfaq.org answers all your questions, but it is _huge_
17:57:45 <Pseudonym> Rand didn't know a lot about anything.
17:57:54 <Pseudonym> Except that she was really pissed off at Communists.
17:58:04 <dash> well hey, for a novelist she was a pretty good philosopher
17:58:07 <tuomov> I'm not really sure what would be a good concise overall introduction
17:58:11 <Pseudonym> No she wasn't.
17:58:16 <dash> (and for a philosopher, she was a pretty good novelist)
17:58:20 <shapr> Ya know, SimPolitik would be a great Haskell project.
17:58:26 <shapr> Something like StarLogo
17:58:27 <Pseudonym> For a novelist, she was a pretty good self-promoter.
17:58:29 <shapr> and SimCity
17:58:29 * Philippa sniggers
17:58:43 <shapr> with a nice twist of HP Lovecraft...
17:58:57 <segphault> I dont like Rand. there are too many obvious problems with her ethical egoist approach to humanism
17:58:59 <Philippa> shapr: ever play Cults Across America?
17:59:10 <dash> segphault: well. Rothbard refuted her pretty well
17:59:14 <shapr> No, but it sounds realistic.
17:59:18 <Pseudonym> I don't think many people "like" Rand.  Even Randians.
17:59:20 <Philippa> heh
17:59:24 <shapr> ah, 3am approaches. I shall return tomorrow.
17:59:29 <Philippa> it's an operational wargame with cults taking over america
17:59:32 <Pseudonym> Like all kooks, though, she had one or two good points.
17:59:33 <Philippa> you can summon cthulhu :-)
17:59:50 <Pseudonym> Even the stupidest beliefs have a grain of truth in them.  Otherwise nobody would follow them.
17:59:55 * shapr falls over asleep.
18:00:08 <Pseudonym> Anyway, lunch time for me.
18:00:23 <Philippa> and bed time for me, I think
18:00:29 <segphault> Rand's strong disapproval of conformity/solidarity for the sake of conformity/solidarity is appealing, but thats really all that I approve of in her work
18:02:10 <dash> segphault: except that she _did_ demand conformity :)
18:02:30 <dash> http://www.lewrockwell.com/rothbard/rothbard23.html 
18:02:30 <segphault> dash: in what way?
18:03:28 <dash> segphault: well, the most amusing example was her position on smoking :)
18:04:24 <CosmicRay> would there happen to be some parsec folks here?
18:04:25 <CosmicRay> I'm trying to figure out how to hook up two parsers...
18:04:36 <CosmicRay> I have a lexer and a parser (these were ported originally from lex/yacc files)
18:04:39 <shrimpx> haha smerdyakov got banned?
18:04:42 <CosmicRay> both are now written in parsec
18:04:56 <CosmicRay> I can't figure out how to nicely pass the stream of tokens from the lexer to the parser
18:05:04 <segphault> dash: this article is interesting. the beginning of it reminds me of something H.S. Thompson wrote, where he compared Charles Manson and Mel Lyman
18:05:09 <CosmicRay> the parser is written to take a list of tokens and I have a lexer that generates that list
18:05:11 <CosmicRay> any ideas?
18:10:04 <segphault> dash: this is bizarre. it borders on surreal
18:10:11 <dash> Hee hee
18:13:45 <segphault> dash: this cant possibly be true...
18:13:52 <segphault> dash: this is way too strange
18:17:49 <tuomov> rand was a nutcase
18:18:01 <tuomov> natural law... pffft.
18:18:22 <tuomov> that just the kind of thing that is used to justify all kinds of oppression
18:18:49 <segphault> if this essay has even a shred of truth to it, she really must have been totally insane
18:19:11 <tuomov> "Freedom, in a political context, means freedom from government coercion. It does not mean freedom from the landlord, or freedom from the employer, or freedom from the laws of nature which do not provide men with automatic prosperity. It means freedom from the coercive power of the state -- and nothing else!"
18:19:11 <segphault> it makes her sound like a perverse meglomaniac
18:19:18 <tuomov> -- Rand's definition of "freedom"
18:20:09 <segphault> hrm
18:20:15 <np_hard> read some orwell for a good antidote to rand
18:20:27 <segphault> I have read orwell
18:20:34 <np_hard> homage to catalonia++
18:20:53 <segphault> orwell paints the future of a communist nation, not a capitalistic nation. 
18:21:07 <segphault> Huxley's view of the future seems much more realistic to me
18:21:19 <np_hard> s/communist/totalitarian/g
18:21:26 <np_hard> s/capitalistic/democratic/g
18:22:10 <np_hard> there are other orwell books besides 1984 you know 
18:22:11 <np_hard> :)
18:22:16 <segphault> I read animal farm
18:22:18 <segphault> and 1984
18:22:43 <tuomov> capitalism and state communism are not really that different
18:22:54 <tuomov> in state communism the state is the sole capitalist
18:22:55 <segphault> animal farm lacked subtlety. it was such obvious historical allegory, that I wished after reading it that I hadnt wasted the time
18:23:19 <np_hard> read homage to catalonia
18:23:31 <np_hard> you are reading the grade school books
18:23:31 <np_hard> :)
18:23:35 <segphault> tuomov: its very different, in that if you only have one capitalist you have a reckless monopoly
18:24:00 <segphault> np_hard: i'll add it to my list. thx
18:24:05 <tuomov> near-monopoly is where markets tend to
18:24:57 <segphault> I'd rather a productive/progressive near monopoly rather than an anachronistic and overly bureaucratic system that does nothing but produce
18:25:30 <segphault> in america, even our unscrupulous companies do more to help the common individual than the government could ever possibly do
18:26:09 <np_hard> segphault: how so?
18:26:09 <tuomov> that depends on the type of government
18:26:18 <tuomov> not that I like any
18:26:55 <tuomov> still, having some kind of government is better to pure private-state capitalism
18:27:38 <segphault> I think that the federal government in the USA should exist only to regulate inter-state commerce and faccilitate arrangements between states for the sake of national defense
18:27:45 <segphault> I dont think there should even be a national army
18:29:06 <segphault> np_hard: one of my overly liberal friends wrote a rant in her livejournal about the evils of corporate america, and I produced a refutation: http://www.livejournal.com/users/m00f/26033.html?thread=36273#t36273
18:30:42 <tuomov> corporate donations are just like "greenwashing"
18:30:48 <tuomov> they
18:31:05 <tuomov> 're just there to paint a better picture of the corporation, but really do not do much to help except very few people
18:31:25 <segphault> the numbers seem pretty clear to me, and I dont particularly care *why* they do it.
18:32:26 <tuomov> numbers don't say anything without lots of other numbers too
18:33:16 <tuomov> m$ makes lots of donations... in windows licenses
18:33:25 <tuomov> now how did that really help anyone?
18:34:07 <segphault> the companies I listed in my post make it very clear how they allocate and use the money
18:34:32 <segphault> and they would give even more if the government had better tax deduction policies
18:35:02 <tuomov> yeah, right..
18:35:59 <segphault> and companies will be able to ensure that the money is used correctly better than the government can, because companies will always have better process and organization than the government
18:36:50 <tuomov> corporations do donations just because they think they can benefit from it by advertising themselves to people etc., and even then, do you really think those donations are significant at all compared to the income of the company?
18:37:10 <segphault> no they arent, and they shouldnt be
18:37:56 <tuomov> and why not?
18:37:59 <segphault> companies *should* be able to keep a majority of their income so they can invest it in research, and find ways to produce better goods at lower costs, which in the long run does more to raise everybody's standard of living than welfare does
18:38:18 <tuomov> lol
18:38:33 <tuomov> find new ways to exploit people
18:38:52 <tuomov> to reduce workforce so that they don't have to pay so much salaries
18:39:22 <tuomov> and maybe make a fraction of that more donations
18:40:22 <segphault> if people dont like the way their employer treats them, they should be able to leave and start their own companies. Unfortunately, income tax for small businesses and government regulation of business is so incredibly costly that most people cant afford to start their own businesses. Why is that? because the government needs to appropriate all that money to feed people who are incapable of feeding themselves.
18:40:41 <tuomov> and how do you enter a near-monopoly market?
18:41:06 <segphault> make a product and sell it to a company that doesnt want you to be a competitor. ;-)
18:41:26 <segphault> in our current system they dont have to worry about new competitors because they *know* that the government stifles small businesses.
18:41:48 <tuomov> government doesn't stiffle small businesses, the monopolists do because they have much more resources
18:41:59 <Riastradh> What the government _doesn't_ do is stifle monopolies.
18:42:19 <Riastradh> The government doesn't even need to stifle the small businesses for them to be ineffectual against gargantuan monopolistic tyrants.
18:42:38 <segphault> the consumers are what make companies like microsoft into a monopoly
18:42:43 <segphault> not the government
18:42:58 <Riastradh> And who donates the most money to the campaigns of people running for offices who will try their best not to stifle monopolies?  Those monopolies!
18:43:08 <Riastradh> No, it's Microsoft that made Microsoft a monopoly.
18:43:08 <tuomov> because consumers don't have real choice
18:43:18 <Riastradh> Then it made itself bigger.
18:43:19 <tuomov> because of the bigger corporations' resources
18:43:22 <segphault> I have a choice. I choose to use linux rather than windows
18:43:29 <Riastradh> That choice is not viable for most of the market.
18:43:35 <segphault> I think it is
18:43:36 <tuomov> the can be cheaper, have more ads etc.
18:43:51 <Riastradh> Please show me a usable Linux desktop environment for non-hackers.
18:43:58 <segphault> Unbuntu
18:44:00 <Riastradh> There can be absolutely _NO_ configuration file editing.
18:44:23 <segphault> my brother is a musician. He barely understands how to use a web browser, and he is very happy with Unbuntu.
18:44:24 <tuomov> linux is not a good comparison, but take beos for example
18:44:43 <tuomov> they just couldn't compete with m$
18:44:50 <segphault> then how has QNX survived?
18:44:52 <Riastradh> Does it run Excel, segphault?
18:44:57 <tuomov> qnx has a niche
18:45:13 <segphault> Riastradh: it runs openoffice
18:45:19 <Riastradh> Or any of another thousand applications written by companies who don't have the resources to develop for platforms other than Windows?
18:45:19 <tuomov> but now m$ also has its windows ce or whatever
18:45:27 <tuomov> so how long will qnx survive?
18:45:59 <segphault> tuomov: judging by the massive problems with windows ce, and general hardware manafacturer distrust of microsoft after the tablet os fiasco, I think QNX will have a nice long life
18:46:37 <Riastradh> Furthermore, there is the problem that no alternative platform has the resources to make itself known in comparison with Windows.
18:46:47 <tuomov> if m$ can't penetrate themarket, they  could also buy the competitors away
18:47:04 <Riastradh> ...as they did with the PC hardware manufacturers.
18:47:21 <segphault> Riastradh: I saw a novell linux ad in a magazine
18:47:46 <segphault> tuomov: I dont see microsoft buying QNX
18:47:56 <segphault> tuomov: and they certainly havent bought out mozilla
18:48:03 <Riastradh> Oooooooo.  A single magazine ad.  Boy, that'll really change the world!
18:48:16 <tuomov> segphault: mozilla is free software. they did practically kill netscape.
18:48:22 <Riastradh> Did you see an Ubuntu ad along with it?
18:48:30 <tuomov> free software is indeed the only thing that has any chance against m$
18:48:44 <Riastradh> If not, then you have a problem, even assuming Ubuntu is a usable desktop environment.
18:49:16 <segphault> Riastradh: so should the government start censoring microsoft ads to be "fair" to other businesses??
18:49:41 <Riastradh> No, the lawsuits raised against Microsoft's monopoly should not be dismissed by the government with a slap on the wrist.
18:50:19 <Riastradh> They should be carried out to their proper conclusion.
18:50:26 <segphault> Riastradh: which is what?
18:50:43 <segphault> Riastradh: should companies be financially punished for making commercially successful products?
18:50:43 <tuomov> what the law that m$ has bought itself says
18:50:44 <Riastradh> Large sums of money taken from Microsoft, Microsoft split into several different companies, etc.
18:51:06 <Riastradh> Not for making commercially successful products: for tyranically ruling an entire industry by gargantuan monopoly.
18:51:35 <tuomov> that's what any profit-driven corporation would do in the same situation
18:51:41 <tuomov> the system is inherently flawed
18:52:02 <segphault> Riastradh: if you allow the government to start picking apart companies, it will destroy the free market economy. People will be afraid to invest for fear that their money will disappear when it is appropriated by the gvmt
18:52:29 <segphault> Riastradh: and whats to prevent the government from abusing monopoly laws to fill its coffers?
18:52:32 <Riastradh> What free market?  You can buy from Microsoft, or you can buy from Microsoft.
18:52:32 <tuomov> "free market" is an oxymoron
18:52:45 <tuomov> the dominant bodies in the market will always attempt to lay restrictions
18:52:47 <Riastradh> You can also waste money on a platform that won't do you much good in your job.
18:52:58 <segphault> Riastradh: and what is to prevent a judge from decimating a company that competes with one that he invests in just because it competes with one he invests in?
18:53:28 <tuomov> patents in general are inherently anti-free market
18:53:44 <Riastradh> A corrupt government & legal system is a problem.  I don't claim it's not.  But it is absolutelu _ludicrous_ to sidestep such a huge issue as a tyrannical monopoly because of the mere _potential_ for a corrupt legal system!
18:53:48 <Riastradh> Absolutely, even.
18:54:02 <segphault> our legal system is fundamentally corrupt
18:54:16 <tuomov> I know it's a cliche, but power corrupts.
18:54:33 <segphault> the government cant be trusted to regulate anything
18:54:45 <tuomov> and corporations can't be trusted for anything
18:54:49 <Riastradh> But a megalomaniacal corporation can?
18:55:07 <tuomov> (other than that they will attempt to maximize their profits)
18:55:14 <Riastradh> Corporations can be privatized.  Corporations can span across the globe.
18:55:20 <segphault> if corporate regulation exists at all, it should be performed by trade organizations that are comprised of corporations
18:56:00 <tuomov> if corporations are not regulated at all, the common people will be even worse off than now
18:56:23 <Riastradh> Why should corporations be trusted any more than...corporations?
18:57:18 <segphault> when you have a group of corporations with differing interests they can synergize in productive ways that are mutually beneficial and they will stop certain kinds of exploitation because it will be mutually beneficial
18:57:38 <tuomov> mutually beneficial to the ruling class, not to the common people
18:57:50 <Riastradh> Certain kinds of exploitation?  Yes.  They can fix prices to benefit each other while hurting everyone else.
18:57:59 <tuomov> it is not in their interests to make the life of the common people better
18:58:02 <Riastradh> They can merge, making even bigger monopolies.
18:58:29 <tuomov> until we have a megacorp of the size of the ussr :)
18:58:31 <segphault> it is in their interest to make the life of the common people better, because the common people are their customers and consumers
18:58:41 <Riastradh> It's like a bunch of mafia families meeting to gang up on the police rather than fighting between each other.  The mafia guys are still not the 'good guys.'
18:58:42 <tuomov> who have no choice!
18:58:50 <tuomov> it's one megacorp or the other
18:58:52 <Riastradh> Haha.  No, it's in their interest to take more money from the common people.
18:59:05 <Riastradh> It doesn't matter if the common people appreciate the product or not if they have no choice.
18:59:20 <segphault> if the people make money the people can invest that money. corporations know that, especially financial institutions.
19:00:08 <tuomov> but to keep people in wage slavery, they can't be paid that much
19:00:48 <segphault> I dont see wage slavery in the united states
19:00:58 <tuomov> wage slavery is everywhere in the capitalist world
19:01:04 <segphault> I see companies doing things like offering stock options to employees, and providing health care options, etc
19:01:11 <Riastradh> Your entire argument, segphault, depends on there being no means by which the corporations can exploit the common people to gain more money than by not exploiting the common people.
19:01:51 <segphault> exploitation is expected. people will always try to exploit each other.
19:01:53 <tuomov> wage slave==someone who must work against wages for a living
19:01:59 <Riastradh> You see no wage slavery?  You're blind.  Look at the meatpacking industry, for example.
19:02:18 <segphault> if people dont feel that they are being treated fairly, they can form unions.
19:02:30 <segphault> unions have always been relatively powerful in america
19:02:43 <segphault> and then the employees can exploit the employers
19:02:45 <Riastradh> Form unions?  Not if the corporations for whom the employees work forbid unions!
19:02:59 <segphault> then people can refuse to work for companies that forbid unions
19:03:00 <tuomov> strikes don't help if there are always enough poor unemployed people to replace the strikers
19:03:10 <Riastradh> Such as Wal-Mart, your first example, as I remember, in your ridiculous response to that blog post.
19:03:15 <Riastradh> Not if they have no options, segphault!
19:03:41 <segphault> there are always options
19:03:45 <segphault> malcontents fail to see them
19:03:57 <tuomov> options are one capitalist master or the other
19:04:03 <tuomov> both of which are equally bad
19:04:29 <segphault> I didnt like the work environment I was in, so I quit, developed some skills, and got a job elsewhere
19:04:30 <Riastradh> segphault, why don't you try going into feigned poverty to demonstrate that you can always get by?
19:04:55 <segphault> the only people who get screwed are the ones who cannot develop any skills or cannot work a job, and I feel no pity for them
19:05:20 <Riastradh> No pity for the people who are unable to get reasonable education?
19:05:53 <segphault> nobody in america can get a reasonable education
19:05:59 <tuomov> there isn't enough work for everyone, and the capitalist class wouldn't even want that
19:06:06 <segphault> the public school system here is a grotesque obscenity
19:06:14 <tuomov> because they can use the unemployed masses for coercion
19:06:18 <Riastradh> I'm not even necessarily talking about the public school system.
19:06:28 <segphault> if there isnt enough work for everyone then why are we trying to feed everyone?
19:06:31 <Riastradh> How do you expect to get to college without money?  How do you expect to get money at a certain age without having the necessary skills?
19:06:54 <segphault> all welfare does is inflate an already bloated population.
19:07:14 <segphault> I have developed skills myself, and those skills are what make me employable
19:07:20 <tuomov> you know what, the most bloated populations are in the poorest places
19:07:25 <Riastradh> It is therefore ineffectual.  What does welfare provide people with?  Some money to eat and a crappy place to work.
19:07:56 <segphault> welfare makes people dependant on the state
19:08:07 <segphault> and it provides a means of perpetuation for people who shouldnt exist at all
19:08:12 <tuomov> no welfare makes people completely dependant on corporations
19:08:19 <tuomov> how's that any better?
19:08:34 <segphault> I'd rather be dependent on corporations than on the state
19:08:48 <segphault> a corporation will at least give me stock options
19:09:03 <shrimpx> haha
19:09:05 <tuomov> you're obviously one of those people that think that you're always among "the best" and can rise into the ruling class and so on
19:09:15 <segphault> i'm not "the best"
19:09:21 <segphault> i'm just very determined
19:10:06 <tuomov> no matter how big the population, not everyone can be at the top of an authoritarian structure
19:10:14 <tuomov> there will always be those people that you think shouldn't exist at all
19:10:31 <segphault> until we reach a point where scarcity is no longer an issue
19:10:37 <tuomov> because they're used to coerce those people at the next level into whatever the higher levels want
19:11:00 <shrimpx> scarcity will always be an issue in a hierarchical society
19:11:07 <tuomov> scarcity is not an issue anymore wrt. essentials of livelihood
19:11:30 <tuomov> the western world is dumping food into junkyards
19:11:36 <shrimpx> er, there are still assloads of people who don't have food to eat
19:11:49 <shrimpx> unless you're talking US specifically
19:11:52 <tuomov> while at the same time part of the world produces more than it can eat
19:12:15 <tuomov> and won't just give to those parts that don't have such effective agriculture
19:12:32 <Pseudonym> Are we still on this topic?
19:12:33 <segphault> if a country doesnt have effective agriculture they can produce something else and trade
19:12:57 <emu> someone needs to establish the Monadic States of America
19:13:21 <tuomov> not if the united states of capitalism has a trade embargo, or there simply aren't resoures for other things and so on
19:13:44 <Pseudonym> Hey, good point!
19:13:47 <tuomov> it's not that simple in this world
19:13:52 <Pseudonym> Only the Monadic States of America should outlaw seq.
19:13:59 <Pseudonym> Because it breaks true monadism.
19:14:10 <shrimpx> i believe seq is hiding in some mountins somewhere
19:14:16 <shrimpx> mountains
19:14:34 <Pseudonym> Oh, and unsafePerformIO.
19:19:12 <emu> we will establish principles of separation of program and state, the freedom of higher-order functions, protection from unreasonable evaluation, and the right to bind variables
19:19:21 <segphault> LOL
19:59:22 <Symmetry_> hi all haskelites =)
19:59:55 <Symmetry_> i'm reading the haskell intro and i have just one question if i may
20:00:10 <Symmetry_> the type of the operator : is a->[a]->[a]
20:00:17 <Symmetry_> i'm fuzzy on this
20:01:16 <jesse99>     it takes any type, a list of that type, and returns another list of that type
20:01:34 <Symmetry_> yes it takes a, [a] and returns [a]
20:01:42 <Symmetry_> but why the -> between a and [a]?
20:02:00 <jesse99> because haskell functions really only take one argument
20:02:24 <Symmetry_> hmm but : takes two arguments
20:02:31 <jesse99> so you can call it with an a, and get a function of type [a] -> [a]
20:02:39 <Riastradh> It is a function that takes one argument and returns a function that takes one argument.
20:02:47 <jesse99> yeah
20:02:48 <Riastradh> The function it returns in turn returns the final value.
20:03:06 * Symmetry_ processing
20:03:17 <Riastradh> This is called 'currying,' named after Haskell Curry.
20:03:37 <Symmetry_> as an aside, doesn't operator [] have type a->[a] ?
20:03:49 <Riastradh> (Haskell Curry a guy, not a pair of programming languages or a concept relating to Haskell.)
20:05:03 <Symmetry_> oh!
20:05:11 <Symmetry_> so you feed a to operator :
20:05:22 <Symmetry_> and it returns a function that is latched on to the next function
20:05:40 <Symmetry_> nm that
20:05:50 <Symmetry_> i'll figure it out on my own
20:06:01 <dons> @type []
20:06:02 <lambdabot> [] :: forall a. [a]
20:06:09 <Riastradh> Consider this function f:
20:06:17 <Riastradh> f t h = h:t
20:06:24 <Riastradh> It could be rewritten using lambda explicitly:
20:06:28 <Riastradh> f = \t h -> h:t
20:06:32 <dons> @type (:)
20:06:33 <lambdabot> (:) :: forall a. a -> [a] -> [a]
20:06:40 <Riastradh> That, too, however, is syntactic sugar for something:
20:06:45 <Riastradh> f = \t -> \h -> h:t
20:06:54 <Symmetry_> what's \
20:06:55 <Riastradh> This function has type [a] -> a -> [a].
20:06:56 <Riastradh> Lambda.
20:07:12 <Riastradh> The function accepts an argument t and returns a function that accepts an argument h & returns h:t.
20:07:19 <Symmetry_> i havent gotten there yet. maybe i'll read the whole book and then see what questions i have
20:07:45 <jesse99> lambdas are anon functions (more or less)
20:07:50 <Symmetry_> these arguments, t and h, are really types?
20:07:58 <Riastradh> Nope.
20:08:00 <Symmetry_> like template<class T> in C++?
20:08:09 <Riastradh> No.  They're just regular old variables.
20:08:14 <Symmetry_> of any type?
20:08:20 <Riastradh> All of the definitions I showed above are equivalent.
20:08:41 <Symmetry_> ok, thanks. i'll do the digging on my own
20:08:51 <Riastradh> (Except for obscurities involving the monomorphism restriction.  But that can be glossed over.)
20:09:12 <Riastradh> t isn't of any type.  It is of type [a] for any a.
20:09:31 <Symmetry_> oh i see
20:09:44 <Symmetry_> i was going to ask how you wrote h:t when t apparently wasn't a list
20:10:07 <Riastradh> Lambda expressions (for example: \h -> h:t) evaluate to first-class function values.
20:10:16 <Riastradh> Are you familiar with the concept of first-class, anonymous functions?
20:10:29 <Symmetry_> no
20:10:41 <Riastradh> OK.  You know what a function is, of course, right?
20:10:45 <Symmetry_> yes =)
20:10:50 <Riastradh> Such as f.
20:11:04 <Symmetry_> I come from C++, please be gentle
20:11:43 <Symmetry_> i suppose first-class anonymous function is a function generated on the spot
20:11:48 <Riastradh> In Haskell, functions are just regular values, like integers.
20:11:54 <Symmetry_> yes
20:12:14 <Riastradh> Just as the expression 2 + 3 evaluates to the integer 5, the expression \x -> x evaluates to a function value that returns its argument.
20:12:33 <Symmetry_> oh
20:12:38 <Symmetry_> so \ applies to the whole thing
20:12:41 <Riastradh> You could define it at the top level, like:
20:12:42 <Riastradh> id x = x
20:12:55 <Symmetry_> i see
20:13:04 <Riastradh> When using this, the expression (id 5) evaluates to 5; you could also equivalently write ((\x -> x) 5).
20:13:23 <Symmetry_> i see
20:13:48 <Symmetry_> so a function is in a sense, an "object"?
20:13:58 <Riastradh> So when you call (f p), it returns a function that will add its argument to the list p.
20:14:01 <Riastradh> Yes.
20:14:08 <Riastradh> Just like any other first-class object.
20:14:51 <Symmetry_> so how do we get to the type of : from here?
20:15:34 <Symmetry_> wait, so (f p) 5 will add 5 to the list p?
20:15:40 <Riastradh> Right.
20:15:51 <Riastradh> : is itself a regular function.  These two expressions are actually equivalent; the former is simply syntactic sugar for the latter:
20:15:55 <Symmetry_> i see, it's like a C++ functor, so to speak
20:15:59 <Riastradh> 5 : [1,2,3]
20:16:04 <Riastradh> (:) 5 [1,2,3]
20:16:23 <Symmetry_> so there are actually two steps here?
20:16:39 <Riastradh> What two steps do you have in mind?
20:16:49 <Symmetry_> 1. (:) takes the argument 5
20:16:58 <Symmetry_> and returns --?
20:17:00 <Riastradh> (It would be more accurate to say that C++ functors are lame imitations of first-class functions.)
20:17:09 <Symmetry_> yes i gathered :)
20:17:19 <Riastradh> First you might rewrite this fully parenthesized:
20:17:22 <Riastradh> ((:) 5) [1,2,3]
20:17:29 <Pseudonym> Just like monads are lame imitations of global state.
20:17:33 <jesse99> stl would be a hell of a lot nicer with lambda expressions
20:17:48 <Symmetry_> ok... so : takes the argument 5 and returns what?
20:17:57 <Riastradh> STL would be a hell of a lot nicer if people realized how awful it was and annihilated its scarring presence.
20:18:13 <jesse99> there are a lot of good ideas in stl Riastradh
20:18:40 <Riastradh> Symmetry_, well, if calling the result of ((:) 5) with the argument [1,2,3] returns [5,1,2,3], what must the result of ((:) 5) be?
20:18:52 <Symmetry_> a sec
20:19:57 <Symmetry_> : returns a function that appends it argument to its argument
20:20:18 <Symmetry_> what type is that?...
20:20:34 <Riastradh> What is the type of the initial argument to (:)?
20:20:38 <Symmetry_> a
20:20:57 <Riastradh> So what must the final result of (:) be?
20:21:06 <Riastradh> (the type of it)
20:21:10 <Symmetry_> hold on
20:21:23 <Symmetry_> a->[a]->[a]
20:21:28 * Symmetry_ grins
20:21:35 <Riastradh> Right.
20:21:40 <Symmetry_> damn, thanks
20:21:46 <Riastradh> (As the whole type of (:), that is.)
20:21:48 <Symmetry_> send me the bill :))
20:21:53 <Symmetry_> yes the whole type
20:22:11 <Symmetry_> i just couldn't break past the C++ mold, you know
20:22:20 <Symmetry_> i forgot that functions can return functions
20:22:44 <Riastradh> This is how functions 'do' multiple arguments in Haskell, since Haskell functions really accept only one argument at a time.
20:22:52 * Symmetry_ hats off to Riastradh
20:23:01 <Symmetry_> so that's 'currying'?
20:23:07 <Riastradh> Yup.
20:23:28 <Symmetry_> and this whole thing is possible because lambda functions are possible, right?
20:23:37 <Symmetry_> i.e. building a function on the spot
20:23:40 <Riastradh> Yes, I suppose it could be phrased that way.
20:23:48 <Symmetry_> i see
20:24:11 <Symmetry_> i'm using Hugs98, is it ok for study?
20:24:21 <Riastradh> Sure.
20:24:33 <Symmetry_> ok thanks a lot Riastradh!
21:27:56 <musasabi> morning
21:28:26 <Pseudonym> "They're playing a computer game.  It's called Word.  They're stuck on a puzzle on the fifth screen."
21:28:38 <Pseudonym> Just something I overheard.
22:40:45 <emu> what puzzles me about Word is why anyone uses it
22:41:01 * emu grabs heatsink and installs it on his overheating cpu
22:45:09 * heatsink is feeling warm and toasty
22:45:24 * heatsink catnaps
22:52:06 <emu> hey,  quit nappin, start coolin
22:52:18 <emu> i come back, find my cpu1 blazing at 81c
22:52:24 <emu> yer fired!
23:01:21 <musasabi> Does an ebuild for cvs ghc exist?
23:01:38 <heatsink> not fired, just warm :)
23:01:57 <heatsink> 81 C? You really should turn that off. In fact, I'm surprised it didn't turn itself off.
23:05:55 <emu> it did
23:06:07 <emu> well no, it just kept running while doing absolutely nothing at all
23:06:18 <heatsink> sux
23:06:28 <emu> weird.  anyway it's back to normal now
23:06:32 <emu> not quite sure what happened
23:06:48 <heatsink> maybe it caught a virus from your toaster
23:07:01 <emu> yeah, that damn talking toaster
23:59:10 <Itkovian> musasabi: not in the portage tree afaik
