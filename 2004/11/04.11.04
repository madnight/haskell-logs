01:49:08 <xkb> hmm still trying to fix my wxHaskell program
02:08:48 <maihem> After wolfman8k posted his raytracer, I thought, that's a jolly good bit of practice material. So I'm having a go but I have a performance issue: http://rafb.net/paste/results/k6Z4ym75.html
02:09:10 <maihem> When run as it appears, it outputs a pgm file on stdout, but it takes 8 seconds or so
02:10:01 <maihem> when the word "lighting" on line 82 is replaced with \_ -> 0, it only takes 2-3 seconds. a major difference for a function that doesn't seem to do much.
02:10:04 <maihem> Any ideas why?
02:20:41 <maihem> hm, okay, I tried replacing the diffuse function with ambient _ = 0.5 and it takes 8 seconds there too. The difference must just be in optimisation when the value to be output is constant, and the intersection calculations don't have to be done
02:40:14 <Asta> hello
02:40:35 <Asta> is this function or some equivalent in the std libs?
02:40:37 <Asta> defaulTo            :: a -> Maybe a -> a 
02:40:37 <Asta> defaulTo x Nothing  = x
02:40:37 <Asta> defaulTo x (Just y) = y
02:41:40 <xkb> there is a function that returns x or Nothing, ie it removes the Just part. (I think)
02:41:54 <tromp> fromMaybe
02:42:05 <xkb> I have the following problem with wxhaskell:
02:42:17 * xkb set input_field [ on enterKey := (\str -> set result_field [text := str ])]
02:42:40 <xkb> the idea is to set the text of result_field after an enter is pressed in the input_field
02:42:46 <Asta> tromp: nice thanks
02:42:55 <xkb> but it doesnt work though
02:42:57 <Asta> tromp: I just noticed there is a Maybe module, I didn't know that...
02:43:51 <tromp> browsing the std libraries really pays off
02:44:18 <Asta> yeap... they are so many though
02:44:24 <Asta> I keep reinventing the wheel :-/
02:44:51 <xkb> the problem is assigning the string to the result_field
02:45:06 <xkb> so the (\str -> set ....) part is wrong
02:45:15 <Asta> brb
02:45:20 <musasabi> Asta: defaultTo x = maybe x id
02:52:36 <xkb> hmm.. another attempt:
02:52:37 * xkb set input_field [ on enterKey := set result_field [text :~ (\str -> str) ]]$
02:52:51 <xkb> compiles, however it doesnt update the field :?
03:06:18 <kosmikus> xkb: you're updating text with the identity function?
03:06:39 <xkb> hmm.. that seems a bad idea :D
03:07:08 <xkb> the idea was to apply the text from inputfield to result
03:27:52 <xkb> hmm okay, so how do I retrieve the value of another widget?
03:28:04 <xkb>      47 >       set input_field [ on enterKey := set result_field [text := "erm" ]]$
03:28:16 <xkb> this works ok, as "erm" is a constant
03:30:10 <xkb> im browsing trough the examples
03:30:32 <xkb> but I cant yet find a on event example that retrieves values from another widget
03:39:27 <kosmikus> get?
03:39:40 <xkb> hmm.. 
03:39:45 * xkb greps on get
03:40:11 <shapr> good morning #haskell!
03:40:18 <shapr> wazzup?
03:40:18 <kosmikus> on enterKey := do { x <- get input_field text; set result_field [ text := x ] }
03:40:26 <kosmikus> (untested)
03:40:37 <kosmikus> hi shapr
03:41:27 <shapr> anything exciting happening?
03:42:07 <maihem> mornin shapr
03:42:44 <shapr> RSS is really nifty.
03:43:36 <maihem> I have discovered how cool haskell really is. I have two functions that work on similar data. using the value of either adds ~5 secs to runtime, using both together only adds an extra second or so.
03:45:16 <xkb> kosmikus: after a small change it does indeed work
03:45:19 <xkb> thanks
03:46:00 <kosmikus> ok
03:46:04 <shapr> maihem: enjoying laziness?
03:46:17 <maihem> loving it.
03:47:41 <dons> laziness is great :)
03:48:12 <shapr> g'day dons, how're ya?
03:48:35 <xkb> hmm ok, another problem: I have a function retrieve: retrieve :: String -> Database -> IO String, now I need to print only the return string in that widget
03:48:43 <dons> good good. got this lazy key input stuff working.
03:48:55 <dons> now we have the whole of the key stroke input as a string
03:49:04 <xkb> now I get a matching error: String doesnt match IO String.. 
03:49:06 <dons> to transform, do things to. record etc.
03:49:15 <dons> replay.. got back in time :)
03:49:22 <dons> s/got/go
03:50:24 <shapr> sounds useful
03:51:22 <xkb> Is there a way to get only the string out of IO String?
03:51:25 <dons> return
03:51:38 <xkb> aha 
03:51:41 <dons> @type return
03:51:47 <lambdabot> return :: forall m a. (Monad m) => a -> m a
03:52:20 <dons> @type (>>=)
03:52:21 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
03:53:24 <xkb> hmm.. now the compiler cant match Char against IO String.. investigating..
03:55:01 <shapr> hej bringert 
03:59:14 * kosmikus is amazed about the sudden speed of his mail client
04:02:20 <jak> xkb: only IO function can get the result of other IO functions
04:03:33 <bringert> hej
04:08:17 <xkb>  set input_field [ on enterKey :=.$
04:08:18 <xkb>      48 >|      |       |       do {.$ 
04:08:18 <xkb>      49 >|      |       |       |       x <- get input_field text;.$
04:08:19 <xkb>      50 >|      |       |       |       set result_field [ text :=  return (retrieve x db) ]$
04:08:22 <xkb>      51 >|      |       |       }$
04:08:24 <xkb>      52 >|      |       ]$
04:08:55 <xkb> The problem is with the return
04:09:16 <xkb> retrieve returns IO String
04:09:25 <xkb> or handles an exception
04:09:27 <kosmikus> no, you have to do it like in my example above
04:09:57 <xkb> ahh
04:10:03 <kosmikus> i.e., first retrieve, then set
04:10:06 <xkb> y <- retrieve 
04:13:04 <xkb> weee.. now it works..
04:13:25 <xkb> next up my list: how to handle the exception nicely without crashing the program :P
04:14:44 <kosmikus> catch it
04:15:08 <xkb> retrieve catches exceptions
04:15:30 <xkb> however it rethrows unexpected errors
04:15:39 <xkb> so I also have to catch those again
04:17:29 <xkb> cool.. showError
04:25:41 <xkb> Is there also a way to map Either a b to a or b?
04:28:20 <dons> @type (Data.Either.either)
04:28:22 <lambdabot> (Data.Either.either) :: forall c b a.
04:28:22 <lambdabot> 			(a -> c) -> (b -> c) -> Either a b -> c
04:31:42 <dv> @index LiftM2
04:31:43 <lambdabot> bzzt
04:33:02 <maihem> is the syntaxpolice debian archive still there, or did it move/go by by
04:35:05 <shapr> it's moved to haskell-unsafe
04:35:12 <shapr> dv: it' liftM2
04:35:31 <dv> ah ok
05:10:33 <musasabi> Is there an easy way to get from ClockTime to TimeDiff ?
05:11:15 <musasabi> Or to get the "current" timediff
05:52:04 <xkb> @type either
05:52:05 <lambdabot> either :: forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
06:03:49 <xerox> @eval filter (\x -> not $ elem x [4, 7, 9, 0]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
06:03:50 <lambdabot> [1, 2, 3, 5, 6, 8]
06:06:49 <xerox> @eval [x | x <- [1,2,3,4,5,6,7,8,9,0], not $ elem x [4,7,9,0]]
06:06:49 <lambdabot> (line 1, column 4):
06:06:49 <lambdabot> unexpected "|"
06:06:49 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
06:06:49 <lambdabot>  "(", operator, simple term, "," or "]"
06:09:12 <xerox> it works on my pc .. uhmm
06:09:17 <xerox> Prelude> [x | x <- [1,2,3,4,5,6,7,8,9,0], not $ elem x [4,7,9,0]]
06:09:21 <xerox> [1,2,3,5,6,8]
06:09:29 <kosmikus> xerox: eval isn't Haskell
06:09:47 <xerox> ouch, didn't know
06:12:45 <reffie> @eval [ciao | ciao <- [1,2,3,4,5,6,7,8,9,0], not $ elem  ciao [4,7,9,0]]
06:12:46 <lambdabot> (line 1, column 7):
06:12:46 <lambdabot> unexpected "|"
06:12:46 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
06:12:46 <lambdabot>  "(", operator, simple term, "," or "]"
06:12:49 <reffie> hm?
06:13:20 <reffie> works here.
06:13:33 <xerox> kosmikus said "eval isn't haskell"
06:13:46 <reffie> then why does this work:
06:13:51 <reffie> @eval [1,2,3]
06:13:51 <lambdabot> [1, 2, 3]
06:14:20 <kosmikus> why not?
06:14:33 <reffie> oh
06:14:37 <reffie> eval isn't haskell.
06:14:39 <reffie> i get it.
06:15:07 <kosmikus> eval is just a lambda-calculus interpreter with a syntax that resembles Haskell
06:15:33 <kosmikus> some constructs like list comprehensions or operator sections or ... are not supported
06:15:41 <reffie> i see
06:15:42 <reffie> thanks
06:19:56 <xkb> y <- catchDyn (retrieve x db) (\ex -> "error, rec not found");
06:20:06 <xkb> why is that wrong?
06:20:14 <xkb> retrieve returns IO String
06:20:27 <shapr> In an email from Peter Gammie - "I'm not precious about it, I just didn't expect to have a user..."
06:20:28 * shapr laughs
06:20:46 <shapr> All sorts of unexpected things happen life, like people using the code you've written.
06:23:39 <flaw> precious about it?
06:25:17 <maihem> my preciousssss
06:25:37 * maihem strokes hims^H^Hs ring
06:28:11 <flaw> hehe
07:21:33 <bourbaki> moin
07:22:31 <Lemmih> Annoying Apache! Spawning processes instead of threads completely eliminates the speed bonus /-:
08:28:52 <Oejet> @seen shapr
08:28:52 <lambdabot> I saw shapr leaving #darcs 1 hour 46 minutes 2 seconds ago.
08:34:25 <peti> Yo.
08:34:47 <Oejet> Hello, peti.
08:55:19 <bourbaki> can someone wrap a c++ class such that i can use just one function of it within haskell? the code is written for vc++
08:58:20 <bourbaki> or is that a module for haskell which interfaces the video for windows lib?
09:01:10 <peti> bourbaki: Does the class use any special Windows stuff?
09:02:25 <bourbaki> peti yes
09:02:46 <bourbaki> Perite thats the calss
09:03:10 <bourbaki> peti 
09:04:33 <peti> bourbaki: Hmmm. I _could_ write a wrapper, but I can't compile any Windows software. 
09:05:31 <bourbaki> shit :(
09:05:40 <bourbaki> the prob is that my cam doesnt work in lx
09:05:51 <bourbaki> so i can write my app just in linux
09:05:57 <bourbaki> erm windoze
09:06:14 <peti> bourbaki: Just check out hsc2hs. It's really simple to interface to C/C++ from Haskell.
09:06:46 <bourbaki> i cant compile that either cause i dont have a compiler for windoze and i guess id need vc++
09:07:03 <peti> Hmm. That's bad luck then. :-(
09:07:04 <thebug> cygwin / mingw might work
09:07:17 <bourbaki> gcc in gywin wont work?
09:07:21 <thebug> that, or the compilers for vc++ are available 'free' from microsoft
09:07:44 <bourbaki> the compiler is free?
09:08:00 <thebug> yep
09:08:07 <thebug> I can find the url if given a minute or three
09:08:23 <bourbaki> cool that would be a big help
09:08:41 <bourbaki> i want to do some handrecognition in haskell
09:08:48 <bourbaki> i just need the image from my webcam
09:12:05 <thebug> bourbaki: http://tinyurl.com/5myff
09:12:56 <bourbaki> thx
09:13:06 <thebug> other than the registration, enjoy ;)
09:13:12 <bourbaki> i guess ill have to output an object file right?
09:14:18 <thebug> I really don't know ... when I use VC++ [extrememly rarely], I use the IDE with it
09:14:51 <bourbaki> yes
09:15:15 <bourbaki> but i mean in order to get my c++ into haskell
09:15:32 <bourbaki> in general you need to compile a .o file and link that in haskell right?
09:15:54 <thebug> iirc, it's .obj on windows, but something like that
09:16:38 <thebug> you might also have to look at the symbol table to see how vc++ mangled your function/variable names
09:19:21 <bourbaki> has anyone in here done stuff like that with vc++ and ghc in windoze?
09:20:38 <Raron> HI
09:22:38 <Raron> hi
09:22:39 <Oejet__> Raron, hello.
09:22:40 <Raron> i have a function
09:22:43 <Raron> index :: String -> String
09:22:52 <Raron> and what i want the function to do is to print an index
09:23:22 <Raron> how to do it Oejet__?
09:23:59 <Oejet__> An index of what?
09:24:28 <Raron> lit reads a text file
09:24:37 <Raron> and the file contains lines
09:24:51 <Raron> of words
09:25:18 <Raron> so the index should read every line and give the line number for every word
09:25:53 <Raron> Oejet__ >?
09:26:08 <Raron> any idea how
09:26:17 <peti> bourbaki: Compile the file, link the *.o file to the Haskell program. To access the functions from C++, you need to write a wrapper with 'extern "C"' linkage, because C++ will mangle the names for overloading.
09:26:27 <Oejet__> Well, index :: String -> String  can't read a file.  Show me a small example of it's behavior.
09:26:48 <bourbaki> peti can you point me to a link in the hawiki or elsewhere?
09:27:15 <Raron> Oejet__ can I pm you
09:27:16 <Raron> ?
09:28:04 <peti> bourbaki: Not really, sorry. That's C++ know-how, not Haskell know-how. Just look at any /usr/include/*.h file and look for 'extern "C"'. You have to write a C function that's declared like that, and which calls the C++ functions you want to use. Then import that C function with a 'foreign' statement from Haskel.
09:28:28 <peti> bourbaki: I just hope the code doesn't use any global constructors/destructors. Then you're in deep shit. :-(
09:28:41 <bourbaki> peti i was reffering to the last part :)
09:28:49 <peti> Oh. :-)
09:28:54 <peti> bourbaki: just a sec.
09:29:03 <bourbaki> ive done something like that for lisp already in lx
09:29:23 <Raron> Oejet__ module IndexTest where import Index test = do input <- readFile "input.txt" putStr (makeIndex input)
09:29:26 <Raron> thats the bit of code that reads the lines
09:29:33 <Raron> and prints it
09:29:33 <peti> The FFI spec is at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/>. 
09:29:48 <stepcut> there is a standard for mangling C++ names these days, but I am not sure how closely it is followed
09:30:05 <peti> bourbaki: You only need to read the first ten pages or so. The rest is a bit esotheric. 
09:30:10 <bourbaki> peti the object has some internal buffers but i will just make 3 c functions makecam deletecam and getpic
09:30:24 <peti> bourbaki: Exactly. 
09:30:26 <stepcut> bourbaki: for the extern C method, see http://www.reid-consulting-uk.ltd.uk/docs/ffi-Common_Problems.html#SECTION00030200000000000000
09:30:51 <Raron> Oejet__ still there?
09:30:52 <bourbaki> ah good thanks
09:31:26 <bourbaki> well ill just make a .h file and list whichever fns i need and make them extern "C" that should surfice
09:32:10 <Oejet__> Raron: I am trying to PM you.
09:32:26 <bourbaki> is there an image processing lib for haskell?
09:32:28 <Raron> yes
09:32:28 <Raron> Oejet__
09:32:30 <Raron> can we talk here?
09:32:34 <Raron> I received your msg!
09:32:40 <Raron> makeIndex :: String -> String
09:33:11 <kristnjov> is there any module for id3 reading and editing in haskell?
09:33:35 <Raron> what the hell
09:33:36 <Raron> Oejet__
09:33:42 <Raron> i pmed you
09:33:48 <Raron> and Im stll here
09:33:52 <Raron> and you'er not lagging either
09:33:54 <Raron> erm
09:34:13 <arjanb> Raron: new to irc? :)
09:34:20 <Raron> no
09:34:46 <Raron> Oejet__?
09:35:07 <peti> bourbaki: I think there is a binding it imlib on Unix.
09:35:22 <Raron> can someone help
09:35:31 <peti> bourbaki: Google revealed this: <http://www.haskell.org/pipermail/haskell/2004-August/014396.html>
09:35:45 <Raron> Oejet__ you're weird dude, i just pvt msged you, and you havent even bothered to reply
09:36:24 <bourbaki> as i said im bound to windoze plus itd be cooler to have the filters in haskell since i think you can make optimizations
09:36:25 <bourbaki> liek
09:36:50 <bourbaki> something like a map for images lets call it forallpixels
09:37:19 <Oejet__> Raron: This is not a personal message.
09:37:37 <bourbaki> then you could have something like forallpixels(fn1) o forallpixels(fn2) = forallpixels(fn1 o fn2)
09:37:41 <bourbaki> at least in some cases
09:37:47 <Raron> Oejet__
09:37:51 <Lemmih> Raron: Do you have experience with monadic IO?
09:37:54 <Raron> whether it is ot not
09:38:00 <Raron> Lemmih a little
09:38:58 <Raron> Oejet__: took you 10 mins to get backto me on that? if you didnt know you could have just said you didnt know
09:38:58 <Lemmih> What do you mean by "give the line number for every word"?
09:39:27 <peti> Oha. Food is ready. 
09:40:52 <Raron> Lemmih
09:41:11 <Lemmih> Raron: ?
09:42:38 <Raron> ok
09:42:43 <Raron> the idea is lambdabot
09:42:46 <Raron> Lemmih
09:42:52 <Raron> a function (not the one i am writing) reads a text
09:43:02 <Raron> what i need to write is:
09:43:47 <Raron> once the text has been read, i want to write my own function which makes an index of the text that has been read
09:44:01 <Raron> the text will be several lines long
09:44:13 <Raron> and so all the words in the first line, will have an index of 1. in other words, all those words appear on the first line
09:44:36 <Raron> all the words on the second line will have an index of 2, i.e they are all on the second line
09:44:37 <Raron> and so on
09:44:57 <Lemmih> as in 'createIndex :: String -> [(Int,String)]'?
09:45:08 <Raron> word1 ..................................... 1
09:45:15 <Raron> word2 ..................................... 2
09:45:20 <Raron> word 3 ........................... 1, 3
09:45:30 <Raron> (word 3 appears on lines 1 and 3
09:46:51 <Lemmih> as in 'createIndex :: String -> [(Int,String)]'?
09:47:10 <Oejet__> And then:    [(Int,String)] -> [  ( [Int], String )  ] 
09:47:24 <Raron> yes Lemmih
09:48:15 <Raron> yes Oejet__
09:48:29 <Lemmih> Raron: Then read about 'lines' and 'words'.
09:48:34 <Raron> problem is i havent got a starting point. its just starting it off which i need help with
09:49:01 <dv> indexIt s = concat $ zipWith f [1..] (lines s)
09:49:01 <dv>         where f x y = (show x) ++ ". " ++ y ++ ['\n']
09:49:27 <Raron> dv?
09:49:32 <Raron> that works?
09:49:46 <dv> that puts a line number on the beginning of the line
09:50:18 <Raron> awsome
09:51:20 <dv> meh, maybe it shouldn't have solved it completely
09:51:27 <Oejet__> Raron: What does that has to do with your problem?
09:51:47 <Raron> nothing
09:51:50 <Raron> i was just wondering
09:51:54 <Raron> Oejet__ what do I do
09:51:54 <dv> initially he said he wanted a String -> String function
09:52:38 <Raron> Oejet__ can you actually talk me me through it
09:52:42 <Raron> yes
09:52:44 <Raron> dv
09:52:46 <Raron> thats what i want
09:53:28 <Raron> makeIndex :: String -> String
09:53:42 <Raron> it takes a string and gives out a string
09:54:04 <Lemmih> Raron: You have to break the problem down into smaller pieces. String -> String is only the final result.
09:55:02 <Oejet__> Raron: I'm thinking: createIndex :: String -> [(Int,String)] (by Lemmih), collectThem :: [(Int,String)] -> [ ( [Int], String ) ] printThem :: [ ( [Int], String ) ] -> String
09:57:26 <Lemmih> Associate words with linenumbers -> Group linenumbers with equal words -> Pretty print.
09:58:06 <Lemmih> ^^ Non-haskell version of what Oejet__ said (-:
09:58:35 <Oejet__> Yeah, what Lemmih said.
10:01:07 <Oejet__> @type unlines
10:01:09 <lambdabot> unlines :: [String] -> String
10:01:25 <Oejet__> @type words
10:01:26 <lambdabot> words :: String -> [String]
10:01:32 <Raron> thanks
10:02:13 <Philippa_> unlines x= concat (filter (\n -> case n of '\n' -> False; _ -> True) x) ?
10:02:55 <Philippa_> er, not quite, need to map that filter across x (which should be ls or css or something)
10:03:54 <Raron> Oejet__
10:03:56 <Raron> Lemmih
10:03:59 <Raron> can you basically jot down
10:04:02 <Raron> what I should do here
10:04:11 <Raron> im kinda confused
10:04:17 <Oejet__> Philippa_: (\n -> case n of '\n' -> False; _ -> True) = (\n -> n /= '\n')
10:04:38 <Lemmih> Raron: Start with the first problem: associating words with line numbers.
10:04:41 <Philippa_> Oejet__: point, I tend to write things out as case analysis because I end up having to add another case all too often
10:05:06 <Raron> Lemmih then?
10:05:06 <Lemmih> Raron: That problem can be broken down into even smaller tasks.
10:05:28 <Philippa_> however, you can go one better with ((/=) '\n')
10:05:38 <Lemmih> unlines = map (++"\n"), right?
10:05:55 <Raron> Lemmih then what?
10:06:04 <Lemmih> Raron: Associate lines with line numbers.
10:06:17 <Philippa_> Lemmih: er, point. Well, concat of that
10:06:18 <Oejet__> Philippa_: Doh, of course.  :-)
10:06:40 <Lemmih> unlines = concatMap (++"\n") (-:
10:06:48 <Philippa_> Oejet__: spot who writes interpreters all too often ;-)
10:07:30 <Raron> ok
10:08:09 <Philippa_> dammit, I just figured out a really /bad/ name for an IRC client written with wxhaskell
10:08:14 <Philippa_> "whirc" (because it does, honest!)
10:08:57 <Raron> thx
10:09:11 <Oejet__> Raron:  Do you know the fuctions: lines, words, zip and [1..]?
10:09:30 <Oejet__> He.
10:09:44 <Lemmih> Too late (-:
10:09:45 <dv> didn't he want the function i pasted? 
10:10:18 <Oejet__> dv:  Did you talk personal with him?
10:10:36 <Oejet__> dv: I don't think that solved his problem.
10:10:52 <dv> the way i understood it he wanted to number ("index") the lines
10:11:02 <dv> oh well
10:11:12 <Oejet__> dv: :-)
10:11:50 <bourbaki> Philippa_ did you finish that client?
10:12:20 <marcot> Good afterrnoon.
10:12:30 <marcot> Does yi runs in Windows?
10:12:51 <dv> hey while we're on the topic of yi, i wanted to ask a really dumb question
10:13:12 <dv> darcs get doesn't work for me, something about it that it can't apply a patch
10:13:19 <dv> any ideas on what i'm doing wrong?
10:13:27 <dv> (i've never used darcs before)
10:14:17 <Lemmih> Maybe you should ask in #darcs
10:14:47 <Igloo> Have you got the latest version of darcs?
10:15:16 <dv> probably not (0.9.13)
10:15:30 <Igloo> Try upgrading
10:15:46 <Philippa_> bourbaki: nope
10:16:05 <dv> will do
10:16:10 <Philippa_> better yet, when I took a look at the code I'd left it in a non-functional and rather confusing state, so I think a rewrite's in order
10:16:25 <marcot> Have anyone tried to use yi with windows?
10:17:36 <Philippa_> not properly. I tend not to feel up to messing around with makefiles to get stuff to build
10:17:39 <dv> well, there go any hopes of building the latest darcs sources:    Module `System.IO' does not export `openBinaryFile' 
10:17:42 <Philippa_> well, that and I don't have curses
10:17:52 * Philippa_ blinks
10:17:58 <Philippa_> dv: which compiler're you using?
10:18:10 <dv> ghc, it would appear
10:18:23 <dv> 6.0.1, pretty old
10:18:43 <marcot> Can anyone give me the address from yi?
10:18:53 <Philippa_> 6.2 should build it
10:20:03 <dv> too much work, too little time. maybe they'll include the new ghc in the next freebsd release and i'll be able to just download the binary. building it myself would take forever
10:20:33 <marcot> It should be in the topic.
10:24:32 <marcot> I'm trying darcs get http://www.cse.unsw.edu.au/~dons/code/yi/ but it's not working...
10:24:44 <marcot> Bad repo directory: http://www.cse.unsw.edu.au/~dons/code/yi
10:25:24 <stepcut> http://www.cse.unsw.edu.au/~dons/yi
10:26:02 <stepcut> is what I use...
10:26:19 <stepcut> though, they seem to be aliased to the same place
10:26:39 <marcot> stepcut: strange, I found that link on google.
10:26:41 <dv> do you think it'd work if i just wget it on my openbsd machine (which has ghc 6.2) ?
10:26:56 <marcot> stepcut: it may be outdated.
10:29:03 <marcot> Bad repo directory: http://www.cse.unsw.edu.au/~dons/yi
10:29:29 <marcot> What port does darcs use?
10:29:43 <marcot> Is it 80? Maybe the network from my work is blocked.
10:30:55 <Igloo> 80, yes
10:32:05 <marcot> Igloo: do you know what is the correct command for getting yi?
10:33:45 <marcot> Can someone zip it to me?
10:33:52 <marcot> I can't get it.
10:37:18 <kristnjov> i've got a question for those interested in boolean algebra.. is x' * y' the same as (xy)'?
10:37:47 <dv> * = or?
10:37:50 <kristnjov> and
10:37:53 <kristnjov> + = or
10:38:06 <stepcut> hntaoeua
10:38:14 <dv> isn't that de morgan's rule
10:38:18 <stepcut> marcot: did you try, darcs get http://www.cse.unsw.edu.au/~dons/yi
10:38:27 <stepcut> that works for me...
10:38:32 <kristnjov> i believe de morgans theorem was (x + y)' == x'y'
10:38:34 <dv> aka (!p && !q) == !(p || q)   (in C) :)
10:38:56 <kristnjov> yeah.
10:39:21 <Igloo> kristnjov: You can easily check by looking at the truth table for both sides
10:39:28 <kristnjov> true.
10:40:22 <marcot> stepcut: so the problem should be here.
10:40:24 <marcot> =
10:40:26 <marcot> =[
10:40:41 <marcot> darcs get http://www.cse.unsw.edu.au/~dons/yi
10:40:51 <marcot> Bad repo directory: http://www.cse.unsw.edu.au/~dons/yi
10:41:06 <marcot> Can someone zip that for me?
10:42:08 <Igloo> Have you got the latest darcs?
10:43:00 <marcot> Igloo: sure.
10:43:08 <stepcut> marcot: odd, I checked just now and that works for me
10:43:29 <marcot> darcs -v
10:43:39 <marcot> 1.0.0rc4
10:43:52 <marcot> stepcut: maybe it's the network from here blocking.
10:44:15 <stepcut> I have 1.0.0.rc3
10:44:25 <stepcut> hope they didn't break something in the new rc
10:45:03 <stepcut> maybe you can just wget it ?
10:45:19 <marcot> I'm in windows.
10:45:31 <stepcut> ah
10:45:49 <Igloo> Does darcs get take --verbose?
10:46:05 <Igloo> If you can debug it then that would be useful, especially if it isn't a firewall
10:46:43 <arjanb> yes
10:47:37 <marcot> There's no --verbose
10:48:50 <marcot> I'm trying with rc3
10:49:41 <marcot> Things are going different now.
10:52:16 <marcot> darcs get http://www.cse.unsw.edu.au/~dons/yi
10:52:26 <marcot> darcs failed:  Failed to download URL http://www.cse.unsw.edu.au/~dons/yi/_darcs/inventory
10:52:30 <marcot> libcurl: couldn't connect to host
10:52:44 <marcot> Any ideas of the reason of this error?
10:53:14 <Igloo> Can you open that URL in a web browser?
10:54:25 <marcot> Igloo: yes.
10:54:49 <marcot> Any idea of how to build yi in windows?
10:56:14 <Igloo> Sounds like a bug then
10:56:17 <bourbaki> dv what you were reffering do is the demorgan law btw
10:57:47 <marcot> Igloo: but how can I debug?
10:59:05 <arjanb> marcot: do you have a firewall on your machine?
10:59:49 <marcot> arjanb: actually I don't know, but probably.
11:02:00 <dv> bourbaki: De Morgan's laws (there's two of them, !(p && q) <=> (!q || !p) and !(p || q) <=> (!q && !p)), at least, so my maths manual says
11:02:07 <arjanb> it could be blocking trafic from unknown applications
11:03:13 <marcot> But I still don't know how com build yi in windows. I've tried ghc Yi.hs and ghc Main.hs, but none of this worked.
11:04:55 <marcot> arjanb: maybe.
11:05:01 <marcot> Can someone please help me on that?
11:05:18 <marcot> C:\marcot\yi>c:\ghc\ghc-6.2.2\bin\ghc.exe Main.hs
11:05:29 <marcot> Failed to load interface for `Yi':
11:05:43 <marcot> Could not find interface file for `Yi'
11:05:46 <bourbaki> dv right :) but logcally the <=> means that you can do it in both directions
11:05:50 <marcot> (use -v to see a list of the files searched for)
11:05:59 <marcot> Main.hs:28: Module `Yi' does not export `static_main'
11:06:18 <bourbaki> dv !(p && q) => (!q || !p) and !(p || q) => (!q && !p)) => !(p && q) <=> (!q || !p)
11:07:20 <kolmodin> marcot: I don't think yi runs in windows
11:07:29 <dv> <=> is xnor isn't it? p <=> q => (p && q) || (!p && !q)
11:07:49 <kolmodin> it needs hs-plugins which does not work in windows
11:07:58 <marcot> kolmodin: hum...
11:08:06 <marcot> kolmodin: not even the static version?
11:08:16 <bourbaki> dv <=> is just that you can infer one of the other and vica versa
11:08:27 <kolmodin> marcot: I don't think so
11:08:52 <bourbaki> dv (q -> p ^ p -> q) -> (p <-> q)
11:08:57 <kolmodin> if you want to try to build it, run the makefile
11:09:35 <marcot> kolmodin: how do I do it on windows?
11:09:43 <kolmodin> you'll need cygwin
11:10:08 <kolmodin> or perhaps mingw
11:11:54 <marcot> kolmodin: too much work.
11:12:07 <kolmodin> :)
11:16:21 * marcot downloading cygwin
11:17:45 <kolmodin> has anyone used wxWidgets and scintilla?
11:18:17 <bourbaki> cant #haskell compile a cool live haskell linux environment ;)?
11:19:11 <Igloo> You mean a linux-and-Haskell-on-a-CD thing?
11:19:26 <bourbaki> yep like knoppix
11:19:27 * Igloo doesn't really see the point - who'd use it?
11:19:50 <bourbaki> i was told that there was a knoppix with a lot of linguistic tools cant remember the name
11:19:58 <Igloo> I assume it's easy to do - you take knoppix, add the packages you want to the package list and remove other crap until it fits on a CD again
11:20:15 <bourbaki> hm maybe a disk then ;)?
11:20:40 <Igloo> I don't see what problem you're trying to solve, though
11:21:18 <bourbaki> id just like a hakers delight live system
11:21:20 <bourbaki> hackers
11:21:43 <bourbaki> with lisp and haskell and forth and ... chef ;) and a lot of other funny languages
11:25:18 <Oejet__> bourbaki: Find the live CD scripts that does it for you with least sweat.
11:34:40 <marcot> All these sources need make to be built?
11:34:57 <marcot> Must I have cygwin to use them?
11:36:26 <marcot> I thought Haskell was platform independent.
11:47:07 <chucky> marcot: Haskell is platform independent, but people tend to build things using it that aren't. :) Creating windows specific installers is unfortunately a lot of boring work, so people tend to just create one solution that works reasonably on all platforms (configure/make)
11:47:34 <marcot> chucky: ok! 
11:47:54 <marcot> chucky: I'll quit compiling things in my work.
11:48:09 <marcot> chucky: so that I use windows for less things.
12:40:14 * Etaoin sads upon finding he can't define instances for functions
12:49:47 <teclo> greetings. I'd like to learn Haskell and play with it. I've learned ML when I was younger. Hm, what do you think or something ?
12:50:02 * esap found a way to implement variables without monads.
12:53:05 * esap implemented assignment :-)
12:55:15 <chucky> teclo: Try http://www.haskell.org/learning.html
12:55:22 <chucky> and ask questions. :)
12:55:31 <teclo> chucky: ok :)
12:55:54 <teclo> Well hm, do functional languages have iteration instructions ?
12:56:42 <arjanb> they have recursion
12:57:05 <teclo> Yeah I know about recursion
12:57:42 <Philippa_> functional languages tend not to have iteration instructions, but often there're higher-order functions that do something iteration-like - eg map
12:58:33 <teclo> For instance, let's say there's a list or n elements, a[1] to a[n], it will be broken to down into a[1] and a[2] to a[n], then processed recursively
12:59:00 <teclo> my questions is there instructions for, well, explicit iterations, like for(;;) in an imperative language ?
12:59:11 <Philippa_> there's no built-in iteration, no
12:59:20 <teclo> Ah thank you Philippa_ 
12:59:24 <teclo> Now I have an argument ;)
12:59:30 <Philippa_> you could, of course, write many variations on for() as a higher-order function
12:59:49 <Philippa_> and given tail-recursion they'd most likely compile to something iterative
13:01:06 <teclo> yeah but, that would be "stupid" wouldn't it ? :)
13:02:30 <teclo> Well actually, I ask this because I've read something, hm.... "controversial" in some book
13:04:12 <teclo> In "Learning Perl", 2nd Edition, by Randal L. Schwartz and Tom Christiansen, O'Reilly Associates, they say in a footnote that if there's no iterative instruction, it is not a programming language, giving the example of HTML.
13:04:28 <teclo> I kinda choked when reading that and well
13:04:45 <teclo> I figured these people never heard of functional languages...
13:06:00 <chucky> hmm doesn't Perl 6 have a functional subset or similar (I'm on really thin ice here, I'm recalling something I might have read on /.)
13:06:56 <teclo> chucky: I have read that it "seems" that Perl 6 has some features of a functional language, indeed
13:07:03 <dv> functional programming in perl is possible, but horribly ugly. more than usual perl code
13:07:21 <chucky> dv: I didn't think that was possible. :)
13:07:26 <teclo> heh..h :)
13:07:40 * chucky should really stop with the perl bashing. It can be a very nice and useful language
13:07:42 <teclo> yeah I was gonna say... :) ... There can't be anything more ugly than perl code ;)
13:08:09 <dv> perl is useful. but it sure doesn't look pretty
13:08:33 <teclo> Well right now I've learned a bit of perl, I've written perl scripts that generate graphics of %cpu per user, per process, temperature of the hard disk, it's pretty cool
13:08:37 <teclo> But it is ugly to read
13:08:52 <tuomov> perl is useful when you don't want your hands full of toothpicks writing sed expressions
13:08:53 <teclo> I used to find C difficult to read, but perl is worse :)
13:09:03 <tuomov> for everything else.. no thanks
13:09:05 <kristnjov> you could always look at it this way, YOU'RE ugly to look at! :I
13:09:12 <Philippa_> teclo: if there's no way to /express/ iteration somehow, it's probably not a programming language
13:09:34 <Philippa_> that's only a minor rephrasing of what the perl book says, and it's pretty much correct FCVO "expressing iteration"
13:09:56 <chucky> philippa_: good point
13:09:57 <Philippa_> (ones that admit tail-recursive definitions, say)
13:10:47 <teclo> Philippa_: yes but, functional languages don't have iteration, and well, if you want to iterate, it will translate to a recursion, right ?
13:11:17 <teclo> Philippa_: I just guess the folks who wrote that never paid much attention to the functional language class heh
13:12:40 <teclo> Cuz well, something more correct would be to say "If there's no recursion, it's not a programming language", because there are actually problems that can only be solved by recursion and cannot be solved by iteration (Hanoi Towers, if I recall...)
13:13:41 <tuomov> depends on what you mean by iteration
13:14:16 <teclo> well to me iteration is repeating statements
13:14:45 <tuomov> If you manage your own stack, it's recursion by iteration, isn't it?
13:14:52 <dv> i don't think there are any problems that can't be solved by recursion
13:15:02 <dv> er, iteration :)
13:15:20 <Philippa_> teclo: yeah. And probably to a rather iterative-looking pattern upon evaluation
13:15:39 <Philippa_> that'd be like complaining it's not iteration if there's no LOOP command in the machine language
13:17:10 <teclo> hm
13:17:21 <teclo> well hm, no
13:17:32 <teclo> there is indeed no LOOP command in machine language
13:17:53 <teclo> but to do loops, you decrease values and do stuff like JZ (Jump if Zero)
13:17:55 <tumm> perl, the only language that looks the same before and after RSA-encryption...
13:18:20 <maihem> teclo, iteration + a stack can do anything recursion can do, because recursion does depth first searches. I think in lazy languages like haskell recursion can also do breadth first searches - which is iteration + a queue.
13:18:22 <chucky> teclo: x86 assembly has a LOOP construct I think
13:18:30 <maihem> and vice-versa
13:18:44 <teclo> chucky: I know only MIPS assembly :)
13:18:46 <Philippa_> teclo: it depends on the machine in question
13:18:54 <Philippa_> MIPS doesn't even have a stack last I checked?
13:19:00 <maihem> chucky, jmp and decrement cx if cx is non-zero IIRC
13:19:13 <Philippa_> but yes, x86 has iteration constructs
13:19:18 <teclo> Philippa_: no stack in Philippa_, indeed
13:19:55 <chucky> maihem: Probably something like that, yes. I don't even want to know. I've compiled to it once in my life, now I don't ever want to see it again. :)
13:37:08 <teclo> hm
13:37:13 <teclo> no stack in MIPS indeed
14:46:33 <dons> moin
14:46:52 <Lemmih> Good morning, dons.
14:47:10 <Igloo> Hey ho
14:47:17 <dons> hey guys
14:47:34 <dons> Igloo: the options pragma issue bugs me too :)
14:48:08 <Igloo> I haven't looked at the code properly, but I /think/ it tries to put the pragma at the top but loses it
14:48:22 <Igloo> But I'm sure someone more familiar with it can track it down in far less time than I  :-)
14:48:37 <dons> you end up having to put all flags on one line, which seems to work
14:48:47 <dons> but it's clearly a bug, since alex doesn't have this issue
14:49:34 <Igloo> "all flags on one line"?
14:49:47 <Igloo> DYM on the command line?
14:50:12 <dons> oh. it was losing pragmas, if there was more than 1 at the top of the file
14:50:31 <dons> but if I cons them all into one pragma all the flags when through
14:50:47 <Igloo> Oh, it just loses them all for me
14:51:12 <Igloo> I wonder if I broke something
14:54:25 <marcot> Good evening all.
14:56:17 <dons> got to go now, but marcot, you may be able to get started building yi on windows with 'make way=static'
14:56:31 <dons> but you'll need GNU make still, and ncurses
14:56:48 <dons> there will then be a few posix-ish things to look at
15:03:33 <marcot> dons: ok.
15:03:42 <marcot> dons: I'll not try it anymore.. =)
15:04:07 <marcot> dons: how is the development of yi? Have you implemented any way of checking what was the last command yet?
15:04:47 <dons> hmm. haven't thought about it. but it may now become possible with the new lazy input stream
15:04:57 <dons> good point. i'll look into this.
15:05:07 <dons> got to go now
15:06:53 <marcot> dons: tell me when it's ready.
15:07:13 <marcot> dons: then it'll be so much easy to implement the nano mode correctly. Good bye.
15:39:43 <shapr> greetings!
15:39:45 <shapr> what's going on?
15:42:52 * Lor is doing minor typographical corrections to his thesis.
15:43:31 <Lor> For the "official" version that will eventually be archived in the department's library.
15:44:38 <Igloo> Cool
15:46:00 <shapr> I'm just on a break between Zope hacking bouts.
15:55:07 <Raron> anyone could query this for me plz -- select sum(sal), deptno from emp union select '-------------'||chr(10)||sum(sal),null from emp group by(deptno)
15:55:37 <Igloo> ?!
15:55:41 <stepcut> ???
15:55:44 <shapr> ?!?!?!
15:55:56 <Lor> ¿¿¿
15:55:57 <Raron> what
15:56:03 <Igloo> OK, who broke the punctuation barrel?
15:56:07 * shapr laughs
15:56:30 <stepcut> â™¯
15:56:32 <shapr> Raron: that looks suspiciously like a SQL query. It does not look like Haskell code.
15:56:58 <Raron> sorry
15:57:37 <Igloo> Woah, that's aliased as "z notation infix bag count"
15:57:57 <shapr> Igloo: I'm jealous of your fonts :-/
15:58:10 <shapr> it doesn't show up as anything for me.
15:58:31 * Igloo discovers there's a little cluster of z-notation symbols at the start of misc math symbols B
15:58:40 <shapr> are you using debian fonts?
15:58:45 <Igloo> Yes
15:58:58 <Igloo> uxterm default
15:59:01 <shapr> which unicode fonts are you using?
15:59:08 <Igloo> If you want to know more you'll have to tell me how to find it out  :-)
15:59:12 <shapr> :-)
15:59:49 <stepcut> that is quite the alias
16:00:21 <stepcut> â™©
16:04:22 <Raron> sorry
16:04:23 <Raron> wrong code
16:06:04 <shapr> g'day mrak
16:06:16 <blackdog> jeez, you're quick on the ball shapr. 
16:06:25 <shapr> it's my bottish nature.
16:06:28 <blackdog> i was hoping to find you here, actually... still playing with haskelldb?
16:06:34 <shapr> yup
16:07:00 <shapr> I'm going to fix up curryspondance in a few days.
16:07:29 <shapr> I've realized the world needs *something* to search mailman archives.
16:08:11 <blackdog> i can't seem to get it to build mysql or postgresql support in... do you know where the libraries are?
16:08:28 <shapr> Actually, I need something to search mailman archives, and since I have r00t on haskell.org, I might as well setup HDB there along with curryspondance and Hackage.
16:08:29 * Igloo currently uses wget and grep, but is isn't ideal
16:09:15 <shapr> the handy part about installing curryspondance on haskell.org is that I can easily use the local pipermail archives for updating.
16:09:16 * Lor prefers snarf when just getting a single web page.
16:09:44 <shapr> blackdog: tried explicit --enable-postgresql or --enable-mysql ?
16:10:17 <Pseudonym> Woohoo!  I found a bug in Solaris 10!
16:10:58 <shapr> yay!
16:11:15 <shapr> g'day Pseudonym, how's onymity?
16:12:41 <shapr> blackdog: install dev versions of postgresql/mysql, install HSQL from htoolkit.sf.net, install SQLite, install haskelldb, tada!
16:12:49 <blackdog> shapr: yeah. are there support libraries you're meant to have? The htoolkit.sf.net link is dead
16:13:14 <shapr> http://sourceforge.net/projects/htoolkit
16:13:35 <blackdog> damn. shoulda thought of that. cheers.
16:13:42 <shapr> usually HSQL cvs is the best way to go... and even then it's best if you have bjorn bringert around... 
16:14:06 <shapr> bringert can fix HSQL and HaskellDB with amazing speed.
16:15:15 <blackdog> ok, i'll remember that. got any cool demos? It'd be nice to see if you get much of an advantage over the standard php approach
16:15:27 <Pseudonym> Ah, it's not a bug.  Damn.
16:15:31 <Pseudonym> Oh well.
16:15:48 <blackdog> shapr: er, i mean WASH + haskellDB, obviously...
16:16:33 <shapr> well, curryspondance uses both of them.
16:16:51 <Pseudonym> Oh, g'day by the way.
16:17:06 <shapr> curryspondance is somewhat buggy, and may not build with the latest HSQL + haskelldb + wash
16:17:24 <shapr> but it's not bad for a few evenings hacking.
16:18:02 <shapr> blackdog: darcs get http://www.scannedinavian.org/repos/curryspondence
16:18:02 * blackdog goes off to poke curryspondance
16:19:40 <shapr> ah, I put my blog back up.
16:19:50 <shapr> PLog 0.0.6 does RSS feeds now. Sort of...
16:20:25 <blackdog> Yeah, I know. I was hassling pete about putting full-text in them, and he hummed and hawed...
16:21:04 <shapr> I hacked on RSS.hs some last night, the feed will be better soon.
16:21:12 <shapr> do you have PLog 0.0.6 sources?
16:21:26 <shapr> if so, I can create a darcs repo and share my changes.
16:21:34 <shapr> er, assuming Pete doesn't mind...
16:21:41 <shapr> I don't even know if PLog has a license.
16:22:09 <blackdog> No, I don't. I'm not using it so much myself - I just want to be able to read _his_ blog without clicking around. I'm selfish like that.
16:23:46 <shapr> anyway, I'm in the midst of hacking FormatIndices.formatIndices to take the lists of [date] and [entry] so that the RSS feed shows [getHeading] in the title, and some of the entry text in the description.
16:24:22 <shapr> In an email from Pete yesterday, "I'm not precious about it, I just didn't expect to have a user..."
16:24:40 * blackdog grins
16:24:53 <shapr> oh hey, you could try BLob
16:25:01 <blackdog> I can hear him saying that...
16:25:02 <Igloo> Is this the Pete who went to AFP?
16:25:13 <shapr> Igloo: yah, pix of you on his blog :-)
16:25:45 <shapr> I may switch to BLob, I was using it for awhile.
16:25:48 <Igloo> Oh, scary
16:27:14 <shapr> blackdog: BLob (PLog clone by Bjorn Bringert) is nicer than PLog in many ways, the only downside is that HaskellDB and its many deps are such a pain in the butt to install and upgrade.
16:27:24 <shapr> Of course, debs would fix that.
16:27:43 * Igloo gets 403s from http://www.cse.unsw.edu.au/~peteg/
16:27:45 <shapr> I should put more time into debbing and less into whinging
16:27:52 <blackdog> igloo: gungnir.csbnet.se
16:27:55 <shapr> http://gungnir.csbnet.se/~peteg/
16:27:57 <blackdog> he's left us, the bastard
16:28:30 <Igloo> Oh, duh, I knew that
16:29:36 <blackdog> shapr: yes, so i'm discovering. ah well, a-dependency-hunting i shall go
16:30:10 <shapr> Igloo: pix of you here - http://gungnir.csbnet.se/~peteg/blog/2004-08-16.html
16:30:46 <blackdog> you look like you're thinking terrifically hard.
16:31:09 <shapr> The upside of PLog is that its only dep is ImageMagick. The downside of PLog is that it doesn't use HaskellDB, so it's more trouble to do cool stuff.
16:31:29 <shapr> And pix of the famous BjÃ¶rn Bringert on that page too.
16:32:25 * kosmikus has about 50% of the HCAR finished (although probably the easier 50%)
16:33:06 <shapr> I want to go to the next ICFP and AFP. I met cool people, had fun, and learned a lot at ICFP03.
16:33:20 <shapr> kosmikus: yay! 50% is good!
16:33:48 <Igloo> AFP is your sort of thing, I think
16:34:04 <kosmikus> Igloo: should I have got anything from you, btw?
16:34:27 * kosmikus agrees with Igloo on shapr and AFP
16:35:27 <Igloo> kosmikus: No, sorry. The deadline you gave conflicted with me going to GPCE I think, and there hasn't been much TH activity recently anyway so I'm not sure what I'd say  :-)
16:35:39 <shapr> oh, what about minstrel?
16:36:29 * Igloo thinks it's too young to announce to the world
16:36:44 <Igloo> Maybe I'll have that and the regexp library all shiny for next time round  :-)
16:37:18 <Igloo> Oh, you have a Debian thing from Isaac, right?
16:37:18 <kosmikus> what about the TH entry then, remove it?
16:38:11 <Igloo> Guess so
16:38:16 * Igloo goes to rescue food
16:38:34 <kosmikus> ok
16:38:40 <shapr> blackdog: BLob is on its way.
16:38:45 <kosmikus> I have a Debian thing, yes
16:45:31 <shapr> well, back to work for me...
16:50:52 <blackdog> shapr: cheers
22:06:59 <musasabi> morning
22:07:21 <musasabi> dons: Have you looked at channels as an input abstraction?
22:08:30 <dons> no. what benefit would they have over [Key] ?
22:10:06 <dons> I'm not familiar with them enough to know the benefits
22:13:05 <musasabi> well you can simulate [Key] with them cGetContents.
22:13:24 <musasabi> It is possible to trivially discard keystrokes you don't need.
22:13:55 <skew> it should be easier to build at the other end
22:14:15 <skew> if there were a tryTakeChan that would be nice
22:14:17 <musasabi> also I found that coding my input driver was easier with them.
22:14:26 <musasabi> But I needed timeouts so that might explain it.
