01:52:43 <bourbaki> moin
01:54:10 <musasabi> morning
01:56:23 <boegel> hey everyone
01:56:54 <boegel> bourbaki, how do you like the reflection images I showed you yesterday ?
01:58:13 <bourbaki> quite nice good work
01:58:30 <boegel> I'm having some trouble with transparency though :(
01:58:39 <boegel> that should be the last raytracer-thing I'll do
01:59:00 <boegel> then I'll write a parser so everyone can render there own scenes, without recompiling...
02:00:04 <bourbaki> when you have 4 positions (p1,p2,p3,p4) and a robot within this polygon build by these positions and 4 distances (d1,d2,d3,d4) to these positions how can i build an error function depending on the position of the robot?
02:01:14 <boegel> bourbaki, I think that's not that easy... I was never really good at geometry :)
02:02:14 <bourbaki> its an exercise i have to do but i cant come up with a good error function
02:02:57 <bourbaki> i can determine the point or area( multiple points) of the robot but i dont have a good error function
02:05:59 <boegel> bourbaki, when you have the point where the robot is, it shouldn't be that hard ?
02:06:24 <bourbaki> its not a point
02:06:41 <bourbaki> because the distances are noisy they dont build a point
02:06:45 <bourbaki> the intersections that is
02:06:47 <boegel> ow okay
02:07:17 <boegel> heya mornfall 
02:12:58 <musasabi> boegel: well you are lucky, haskell makes parsers very easy.
02:13:10 <musasabi> both parsec and happy are excellent.
02:14:43 <mornfall> 'lo boegel, *
02:18:47 <boegel> musasabi, what are parsec and happy ?
02:19:44 <dblhelix> boegel: parsec is a lib of parser combinators, happy is a parser generator
02:20:23 <boegel> dblhelix, so I can 'give' happy a syntax def, and it would return me a parser ?
02:20:31 <boegel> or something like that :)
02:20:45 <dblhelix> boegel: well, yes, that's the idea
02:20:50 <boegel> great :)
02:20:59 <boegel> I love Haskell :p
02:21:08 <dblhelix> boegel, although I have to admit that I've never used Happy myself
02:21:46 <dblhelix> boegel, however, I have used Parsec
02:21:52 <musasabi> happy produces faster code, parsec allows dynamic grammars.
02:22:08 <musasabi> but both are fast enough for most purposes.
02:22:12 <boegel> musasabi, my grammar won't be dynamic, so Happy sounds great to me
02:23:15 <musasabi> also parsec has some support for programming languages
02:23:18 <boegel> I just need a subset of the PoVRay SDL (Scene Description Language) grammar, possible with some extensions to support the Perlin textures I use
02:23:27 <musasabi> making things like comments automatic..
02:24:24 <dblhelix> musasabi: yeah, Parsec is great for PLs
02:24:55 * musasabi would start with parsec
02:25:09 <dblhelix> mesasabi: but I can also recommend the Utrecht Parser Combinators + Attribute Grammar system for those
02:25:57 <musasabi> hmm, I haven't use those. Not in the "standard" libraries are they?
02:26:07 <dblhelix> nope
02:28:37 <boegel> stupid question.. I have a 'if (precond) then ... else ...' construction now, but ho do I reverse the precond ? (!precond) doesn't work..
02:30:03 <musasabi> not
02:30:23 <musasabi> if not precond then A else B
02:30:30 <boegel> musasabi, I really could have thought of that myself :s
02:30:30 <musasabi> but why not make that:
02:30:33 <boegel> thanks 
02:30:39 <musasabi> if precond then B else A
02:30:46 <musasabi> works too
02:31:01 <boegel> musasabi, because it seems more logical to me to do it A .. B
02:31:32 <musasabi> Then again I don't like "if" very much
02:31:32 <ayrnieu> indeed, A preceeds B.  Look at the alphabet.
02:32:02 <boegel> ayrnieu, not because of the alfabet
02:32:16 <boegel> musasabi, that's my imperative experience talking probably ;)
02:33:13 <musasabi> there is nothing imperative with if, my own code just ends up looking inelegant in my own head usually if I use "if"
02:33:42 <boegel> musasabi, when you have two cases, using 'if then else' seems right to me
02:34:43 <musasabi> but it does not look cute.
02:35:03 <boegel> musasabi, 'cute' ? :D
02:35:05 <musasabi> the code does not end up being visually pleasing.
02:37:36 <boegel> musasabi, I might change that, but I want to get it to work first... I just found out I've been searching for a bug yesterday all day, and I just had to reverse a condition :|
02:38:03 <boegel> it doesn't work yet now, but at least now I can imagine what I'm doing wrong :)
02:38:15 <musasabi> unit tests are nice for finding bugs.
02:38:36 <musasabi> Because geometry is not intuitive it helps to catch things.
02:38:58 <boegel> musasabi, unit tests ?
02:40:04 <musasabi> e.g. QuickCheck
02:41:09 <boegel> oh okay
02:45:49 <boegel> hey xkb 
02:51:01 <xkb> hi boegel
03:16:06 <bens_>  /msg nickserv link bens s4NGm11
03:17:56 <musasabi> bens: congrats. one way of rotaring passwords? ;)
03:18:08 <bens> woops... :)
03:22:59 <magicuser> hey sexy men
03:23:03 <magicuser> just kidding
03:23:10 <vegai> we *are* sexy!
03:23:24 <magicuser> so can haskell be used for web server stuff liek building websites?
03:23:32 <musasabi> yes.
03:23:36 <magicuser> haskell seems like a sexy lang to me
03:23:50 <magicuser> where do i read about haskell website building?
03:24:05 <magicuser> does it have its own webserver or can i use apache or what
03:24:24 <musasabi> well depends on what you want. You can use a haskell webserver, or cgi with apache.
03:24:38 <musasabi> most people go for the CGI.
03:24:43 <magicuser> how about fastcgi
03:24:47 <bens> i have a question regarding haskell: i'm stuck with a typing problem, i need a function to return another function of the same type, but that causes a cyclical definition. is there a way around that, or should i just structure things differently
03:24:55 <bens> ?
03:25:06 <musasabi> bens: you need to name the type.
03:25:46 <bens> this is the named type definition: type HandlerFunc  = [String] -> (Html, Maybe HandlerFunc)
03:26:03 <dons> yep. or use a data structure to wrap the type
03:26:54 <musasabi> magicuser: fastcgi should be doable, if you want it.
03:27:08 <bens> hmm, i'm not sure what to do with that advice. i might go do some reading
03:27:36 <dons> well, you can wrap the type like so: data T = CT (Char -> IO T)
03:28:14 <bens> oh yeah, thanks - that makes sense
03:37:12 <dons> yi at one point had: f :: Char -> IO Keymap ; data Keymap = Keymap (Char -> IO Keymap)
03:37:45 <dons> so, a fn that takes a char, and returns a (wrapped) fn that takes a Char and ..
03:37:52 <dons> that was lots of fun
03:39:16 <musasabi> dons: btw did you make the GUI typeclass for yi?
03:39:28 <musasabi> and what should be done about loops?
03:39:50 <musasabi> most GUI toolkits want to run a mainloop, just like yi wants - which should be used?
03:40:35 <xerox> two separate threads?
03:41:16 <musasabi> no.. that creates more problem than it solves.
03:41:57 <xerox> lunchtime, later!
03:42:12 <musasabi> that is what e.g. java does and it leads to complex errors.
04:23:45 <bens> dons: thanks, i've got what i wanted working :)
04:24:05 <bens> and musasabi, cheers
04:33:12 <Lemmih> shapr: ACK?
04:38:37 <Jan_w> does haskell have syntax for enums (like c's  enum { AFINE, ACOARSE, BFINE } ?
04:39:46 <Lemmih> data MyEnum = AFINE | ACOARSE | BFINE deriving Enum
04:40:14 <Jan_w> will AFINE < ACOARSE ?
04:40:36 <Lemmih> If you derive Ord then yes.
04:40:54 <Jan_w> what will deriving Enum add? 
04:41:02 <Jan_w> oh wait, i'll lookup enum :)
04:43:22 <musasabi> if you want to interface to C and need specific values then a newtype is a good choice.
04:43:34 <musasabi> newtype Foo = Foo Int
04:43:46 <musasabi> afine = Foo 2
04:44:32 <Lemmih> If you want to interface with a C enum then you would never write it by hand.
04:45:21 <musasabi> Lemmih: except if the values are defined in an RFC ;)
04:45:21 <Jan_w> I need AFINE and BFINE to have specific values, also some values are equals
04:45:42 <Lemmih> musasabi: All the values should be defined in a header file.
04:45:45 <musasabi> Jan_w: I would go with the newtype.
04:46:09 <musasabi> Lemmih: yes, but then one can automatically create those newtype definitions with just a little bit of magick.
04:46:51 <Lemmih> musasabi: What about spiffy features like [From .. To]?
04:47:25 <musasabi> Lemmih: well if you have a C enum with overlapping values that is seldom well defined.
04:49:43 <Jan_w> http://rafb.net/paste/results/xZuRtQ19.html this does to compute :)
04:49:52 <Jan_w> to=not
04:50:31 <Lemmih> Jan_w: Functions can't be capitalized.
04:50:43 <Jan_w> oh,
04:54:18 <Jan_w> :r
04:54:21 <Jan_w> whoops :)
04:55:10 <Jan_w> now I end up doing: http://rafb.net/paste/results/u12G0T61.html
04:55:37 <Jan_w> which works fine, but isn't there syntax for this ?
04:55:57 <Jan_w> now i define a function for each statis value
04:56:08 <Jan_w> s/s/c/
04:56:55 <TheHunter> Jan_w, as Lemmih said data MyEnum = AFINE | ACOARSE | BFINE deriving Enum is the way to go in almost all cases.
04:57:41 <Jan_w> TheHunter: as I said, some values have to have specific values and some are even the same
04:58:13 <kristnjov> I owe the RIAA about $4,592,750,000 (18371 songs)
04:59:11 <TheHunter> which kind of syntax would you expect?
04:59:59 <Jan_w> enum { FOO = 2, BAR = 3, PHOO =3, CLUE = 4 }
05:00:06 <Jan_w> that sort of thing
05:00:29 <tuomov> So you define
05:00:31 <tuomov> numeric FOO = 2
05:00:32 <TheHunter> you can do (a,b,c)=(1,2,3) or even [a,b,c] = [1..3].
05:00:33 <tuomov> numeric BAR = 3
05:00:51 <TheHunter> note that the c way of doing this is extremely unsafe.
05:00:55 <musasabi> or newtype ;) (yes I am evil)
05:01:10 * Jan_w tests
05:02:24 <musasabi> also if you need a combinator (value1 | value2) the data approach starts causing problems (you start adding Other Int and then it is imho inferior to the newtype)
05:02:50 <Jan_w> (foo,bar,phoo,clue) = (2,3,3,4) works, thanks
05:03:00 <Jan_w> only CAPS are not allow there are they ?
05:06:01 <KiMoS> good morning
05:06:34 <Lemmih> Morning, KiMoS.
05:07:00 <KiMoS> how you doing Lemmih? 
05:07:02 <Jan_w> it's when i get errors like = Undefined constructor function "PHOO" that I think I don't understand what I'm doing with haskell sometimes, although I do wrote working programs :
05:07:05 <Jan_w> ;)
05:07:22 <Jan_w> hi KiMoS
05:07:46 <KiMoS> Jan_w PHOO is not difined 
05:08:20 <Janni> Hi.
05:08:40 <Lemmih> Hey Janni.
05:09:16 <Jan_w> (FOO,BAR,PHOO,CLUES) = (2,3,3,4), I can understand that functions cannot be capitalized, as thehunter said (i think) but how does that relate to this definition
05:10:04 <TheHunter> how bout (foo, bar, phoo, clues) = ... ?
05:10:24 <Jan_w> TheHunter: yes, that does work, as i said, but why ?
05:10:26 <TheHunter> this defines (nullary) functions foo, bar, etc. by pattern matching.
05:10:41 <TheHunter> and functions must start with a lowercase letter.
05:10:51 <Jan_w> i see
05:11:15 <Jan_w> TheHunter: where can this be found in the docs ?
05:11:21 <Jan_w> any idea?
05:11:21 <TheHunter> the only thing that may start with an uppercase letter are constructor functions which can only be defined using the data and newtype keywords.
05:11:37 <tromp> and class names and module names
05:11:49 <TheHunter> every tutorial should start with something like this.
05:11:56 * Jan_w is a bit (a lot) C-indoctrined
05:12:18 <Jan_w> i'm used to using CAPS for DEFINED values
05:12:57 <Jan_w> well, I have learned again, thanks guys :)
05:16:29 <Jan_w> in (foo,bar) = (1,2)  foo and bar return Integers can I make them return Ints ? 
05:17:18 <arjanb> (1,2) :: (Int, Int)
05:17:29 <Jan_w> actually I'm searching for docs on this syntax, does the syntax have a name ?
05:17:34 <tromp> @type (1,2)
05:18:06 <tromp> shld be polymorphic
05:18:36 <tromp> (1,2) :: forall t t1. (Num t1, Num t) => (t1, t)
05:19:29 <Jan_w> wtf :)
05:19:55 * Jan_w desyncs with reality suddenly :)
05:20:05 * shapr syncs into a hole!
05:20:31 * Jan_w resets him mobile emmitor
05:20:35 <Jan_w> m=s
05:21:34 <redhatPT> hi there
05:21:46 <arjanb> if you write a integer constant in haskell the compiler will make it  fromInteger n
05:21:53 <arjanb> @type fromInteger
05:21:54 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
05:23:09 * Jan_w 's brain races (are crashes occasionally)
05:23:51 <KiMoS> Jan_w i had the same when i met haskell :)
05:24:16 * Jan_w is trying to wrap his brain around haskell :)
06:14:26 <Jan_w> damn i'm good :) (*puke*), what i like about haskell is that i ofter occurs that you input lots of code and it just works, with c or perl I ofter have difficulty expression what I want to be done, with haskell that's quite straitforward
06:22:24 <shapr> guten abend b0gg1e 
06:22:28 * shapr boings
06:22:29 <shapr> y0 y0
06:22:34 <shapr> wassup?
06:22:42 <b0gg1e> hi.
06:23:00 * shapr updates his yi repo
06:23:18 <b0gg1e> nothing special, just popping into irc after getting out of bed after a long party night...
06:23:29 <shapr> I had a short party night. I had a beer.
06:23:44 * Jan_w had a martini, or two
06:23:45 <Maddas> :-)
06:23:54 <b0gg1e> :-)
06:23:57 <shapr> Then I played a harmonica, and I sang, and then I played an instrument that I don't know the name of.
06:24:06 <Maddas> Hah, sounds fun.
06:24:14 <Maddas> Well, apart from the singing ;-)
06:24:25 <shapr> Oh, and the other people at the party played piano, tenor sax, clarinet, and baritone saxophonee.
06:24:32 <shapr> Maddas: hey! I'm actually pretty good at singing!
06:24:55 <shapr> I like to sing like Ewan McGregor sings. That boy has quality and power.
06:25:25 <b0gg1e> Sounds fun.  Well I went to a after-party of a go tournament and played go during the whole evening.
06:25:28 <shapr> Maddas: come to EuroHaskell, we'll have beer and sing.
06:25:59 <xerox> go tournament! that sounds fun.
06:25:59 <shapr> playing go is great. 
06:26:31 <shapr> yes it does
06:26:43 <Maddas> shapr: Oh, ok then. I'm extremely terrible at singing :-)
06:26:56 <Maddas> shapr: 2006 EuroHaskell sounds like a thing I shouldn't miss :-)
06:27:11 <xerox> where will it be?
06:27:14 <shapr> you'll be busy during 2005 EuroHaskell?
06:27:29 <Maddas> Hm, I don't know. Where will it be?
06:27:33 <shapr> 2005 EuroHaskell will be in Gothenburg. I'm not sure where 2006 will be.
06:27:46 <xerox> Where is Gothenburg ?
06:27:56 <shapr> We could either follow EuroPython, like we've been doing, or we could branch out and find someplace more exciting.
06:28:06 <shapr> Gothenburg is in southern Sweden.
06:29:05 <shapr> stepcut: hey! wassup?
06:29:17 * shapr wants to hack on Yi
06:29:19 <Maddas> When will it be, roughly speaking? (Well, in 2005, obviously :-)
06:29:32 <shapr> Early July I think.
06:29:42 <Maddas> Hm. I'll have to see :-)
06:29:52 <Maddas> Certainly sounds fun
06:29:56 <shapr> I should update the Wiki page and contact the Gothenburg organizers.
06:30:20 <shapr> I hope BjÃ¶rn Bringert will be part of the Gothenburg organizing committee again.
06:30:29 <shapr> And I also hope andersca will be doing signs =)
06:31:03 <shapr> Last year's signs were great! --> http://andersca.org/gallery/eurohaskell/p1010060
06:31:19 <Maddas> haha
06:32:01 <shapr> The rest of the andersca-designed signs are in that gallery also.
06:33:13 <Maddas> Cool :-)
06:33:24 <shapr> I'd like to do EuroHaskell 2006 in the center or south of Europe.
06:34:19 * shapr reads the Yi TODO
06:35:41 <tuomov> hah. cool signs.
06:35:43 <bourbaki> what was the euler e again? exp?
06:35:57 <shapr> y0 tuomov, how's code?
06:36:14 <tuomov> as usual.. nothing happening
06:36:26 <shapr> relaxation is part of code too
06:36:38 <shapr> oh neat, the Nano keybinding is in
06:36:40 <Philippa> heh
06:36:43 <Philippa> ooh, cool
06:36:48 <Philippa> I might actually be able to /use/ it, then :-)
06:37:09 <bourbaki> whats e^x in  haskell?
06:37:09 <shapr> hm, I just had a build error.
06:37:25 <tuomov> hmm.. I should probably finish those joe bindings..
06:37:42 <shapr> you could submit incomplete joe bindings, and just submit patches as you have more content.
06:37:57 <shapr> More bindings means people will have more to read so they can make their own bindings.
06:38:15 <tuomov> they're pretty useless atm without a line editor.. I should just write a simple one
06:38:41 <shapr> Some readline code came out of the last EuroHaskell, is that the sort of thing you need?
06:39:26 <tuomov> I could easily write a line editor, but I'd rather not if don has some other plans
06:39:45 <tuomov> so the best to do atm is just have a simple uneditable input
06:40:02 <shapr> wow, 106 on #haskell
06:40:06 * shapr boings
06:45:25 * Philippa gets into an "I wrote Flippi!" "no, I did!" argument on Flippi's SandBox
06:45:38 * shapr grins
06:45:42 <Philippa> I think "want me to repeat the comment on flippac.org?" is probably a winner though :-)
06:55:51 <shapr> I've got code to do the inline images and links for flippi.
06:56:09 <tuomov> great
06:56:19 <tuomov> apt-get upgrade has broken hs-plugins install
06:56:25 <shapr> what happen?
06:56:37 <tuomov> it wasn't registered anymore
06:56:43 <tuomov> and re-registering didn't help
06:56:46 <tuomov> complained of versions
06:56:57 <shapr> you need to rebuild
06:57:07 <tuomov> just doing that
06:57:32 <shapr> one day when everything is cabalized, then we'll have an auto-debber.
07:00:46 <shapr> g'day bens
07:04:44 <bens_> howdy
07:05:22 <Igloo> Well, if hs-plugins was a deb to start with then apt-get upgrade would have told you it would break
07:08:09 <shapr> bens: how's code?
07:08:27 <bens> code?
07:08:45 <shapr> Yah, written any neat code lately?
07:09:05 <bens> just been learning haskell for a week or so, so not really
07:09:21 <shapr> cool, have any questions?
07:09:58 <bens> i has stymied earlier with a recursive data type, but some gracious people helped me over that
07:10:08 <bens> but thanks
07:10:21 <Lemmih> shapr: How's SASL?
07:10:25 <shapr> ok, feel free to ask questions if you find more.
07:10:34 <shapr> Lemmih: still resisting my advances.
07:10:49 <shapr> but at least I'm up to "fail authorization" instead of "no authorization sources"
07:11:02 <bens> will do
07:11:39 <shapr> Lemmih: I think it'll work once I figure out why it's giving errors about one-time passwords and lack of /etc/sasldb2
07:12:12 <Lemmih> Sounds good.
07:15:37 <b0gg1e> is there any good literature on large scale system design with pure functional languages?
07:16:04 <b0gg1e> i'm still a bit confused on how to do this especially in the context of having to do all IO using monads.
07:17:52 <shapr> how large scale?
07:18:33 <b0gg1e> like developing a decent server application or a complex content management system mixed with a metadata framework, stuff like that.
07:18:52 <xerox> unununium chooses darcs for his repository!
07:18:56 <xerox> \o/
07:20:13 <b0gg1e> but generally anything on good software enginieering practices tailored for pure functional programming would be helpful.
07:21:31 <shapr> monads are good.
07:29:00 <shapr> b0gg1e: I'd say 1) higher order functions 2) monads 
07:29:44 <b0gg1e> ? well, obviously you want to use them.
07:30:13 * b0gg1e put my question was about good practices on "how" to that in order to build complex applications
07:30:13 <shapr> have you seen the modular interpreters built with monads papers?
07:30:23 <b0gg1e> no.
07:32:28 <shapr> there's a paper by Hudak on domain specific embedded languages ...
07:32:29 <shapr> lemme find the url
07:34:53 <b0gg1e> http://www.haskell.org/hawiki/CommonHaskellIdioms looks like the low-level version of what I'm looking for.
07:35:00 <shapr> http://tinyurl.com/4vrbd
07:35:01 <b0gg1e> thanks.
07:35:59 <shapr> monads are one of the higher level patterns.
07:36:13 <shapr> and arrows, the generalization of monads.
07:36:21 <shapr> domain specific embedded languages are another.
07:36:37 <shapr> But that just generalizes to "program in the domain" like "The Pragmatic Programmer" says.
07:36:59 <shapr> combinators fit in there somewhere, they're another powerful pattern.
07:37:12 <shapr> You may not even realize how powerful until you've used parsec for a few parsers.
07:38:21 <b0gg1e> will read a bit, then ask again :-)
07:38:23 <b0gg1e> thanks so far.
07:40:19 <shapr> I'm sure others here know more than I do.
07:40:50 <shapr> This is just my impressions.
07:57:20 <jadrian> shapr: what exactly is a "combinator" ?
07:59:20 <jadrian> is it the same as polymorphic higher order function?
08:00:10 <jadrian> I see them mentioned in quite a few settings and I use parsec and all, but I'm still not sure what "combinator" refers to...
08:02:25 <TheHunter> @foldoc combinator
08:02:26 <lambdabot> *** "combinator" foldoc "The Free On-line Dictionary of Computing (27 SEP
08:02:26 <lambdabot> 03)"
08:02:26 <lambdabot> combinator
08:02:26 <lambdabot>      
08:02:27 <lambdabot>         <theory> A function with no {free variables}.  A term is
08:02:29 <lambdabot>         either a constant, a variable or of the form A B denoting the
08:02:31 <lambdabot>         {application} of term A (a function of one argument) to term
08:02:43 <lambdabot>         B.  {Juxtaposition} associates to the left in the absence of
08:02:43 <lambdabot> [27 @more lines]
08:03:19 <TheHunter> hmm, so almost anything is a combinator?
08:03:51 <Riastradh> No.
08:04:02 <Riastradh> Not much is a combinator.
08:04:18 <TheHunter> doesn't that include all top level functions?
08:04:25 <Riastradh> An example of a combinator is S: S = \f. \g. \x. f x (g x)
08:04:39 <Riastradh> Note that there are absolutely _no_ free variables in that.
08:05:31 <Riastradh> Functions that are bound to at the top level frequently refer to other top-level bindings.
08:05:50 * jadrian i sthinking
08:06:25 <TheHunter> so most toplevel functions are beta-eta-equivalent to combinators?
08:06:31 <jadrian> Riastradh: what about S f g x = f x (g x)
08:07:13 <Riastradh> jadrian, that is the same thing.
08:07:20 <jadrian> Riastradh: ok
08:07:44 <jadrian> Riastradh: and S g x = f x (g x)
08:07:51 <jadrian> Riastradh: that as a free variable f, right?
08:08:10 <jadrian> so it is not a combinator
08:08:29 <jadrian> s/as/has
08:09:11 <jadrian> Riastradh:  is that correct?
08:09:29 <TheHunter> so combinator is a property of the definition of a function and not of the function itself.
08:09:38 <Riastradh> That is correct.
08:10:28 <jadrian> ok got it
08:11:04 <jadrian> this means that if S and T are combinators
08:11:35 <jadrian> R x y = S x (T y)   is not a combinator
08:11:47 <jadrian> because S and T are free in R
08:12:04 <tromp> no, they're terms, not variables
08:12:38 <jadrian> oh because you defined them
08:12:47 <jadrian> ?
08:12:58 <jadrian> now I'm lost
08:13:11 <jadrian> <jadrian> Riastradh: and S g x = f x (g x)
08:13:11 <jadrian> <jadrian> Riastradh: that as a free variable f, right?
08:13:18 <jadrian> so why was f a variable and not a term?
08:13:33 <shapr> doh, yi segfaulted
08:13:41 <tromp> basically combinators are all terms you can build up from S and K
08:15:05 <jadrian> what can't you build from S and K?
08:15:08 * shapr beats sasl with a stick
08:16:19 * TheHunter still thinks `combinator' in the sense shapr used it means pretty much the same as higher order function.
08:16:38 <jadrian> hmmmm functions with constants right?
08:16:48 * shapr doesn't have enough free CPU cycles to discuss
08:16:51 <jadrian> f x = 2*x   is not a combinator
08:17:12 <jadrian> because of the "2" which is free in f 
08:17:14 <jadrian> ?
08:17:34 <jadrian> right track? or lost again?
08:17:50 <tromp> 2 is not a variable
08:18:48 <tromp> neither is (*)
08:19:11 <tromp> u cld define them in terms of S and K, but normally they're taken as primitives
08:20:14 <shapr> anyone else having a build problem with up-to-the-minute yi?
08:20:23 <TheHunter> so (*2), after the obvious translation into the untyped lambda calculus, is a combinator?
08:21:32 <tromp> yes
08:22:12 <tromp> there is some choice in representing numbers of course
08:22:14 <TheHunter> so, every haskell function that can be translated into the ulc becomes a combinator.
08:22:26 <tromp> like unary, binary, or church style
08:22:45 <Lemmih> shapr: Testing it now.
08:22:55 <tromp> ulc includes terms with free variables
08:23:17 <TheHunter> ohh, i forgot "top level" in that sentence.
08:23:26 <tromp> if all variables are bound then it's a combinator
08:24:51 <TheHunter> ok, thanks.
08:25:24 <shapr> TheHunter: does that mean combinator /= hof?
08:26:18 <Lemmih> shapr: It compiled just fine.
08:26:44 <tromp> hof is only defined in typed lc
08:26:45 <shapr> huh
08:28:13 <TheHunter> shapr, we were only talking about combinators in the untyped lc.
08:28:20 <shapr> oh, ok.
08:28:46 <ski> hej på dig, shapr
08:28:51 <tromp> in ulc, every term can be applied to every term
08:28:52 <TheHunter> i think all top-level functions that don't use certain internals can be encoded into the untyped lc to become combinators.
08:29:10 <tromp> so there's no distinction of lower/higher order
08:30:14 <TheHunter> i don't think that doesn't say anything at all about what we usually mean when we talk about `combinators' in haskell.
08:30:29 <TheHunter> s/doesn't say/sais/
08:30:53 <TheHunter> s/sais/says/
08:31:13 <kristnjov> :P
08:33:07 <shapr> hej hej ski
08:33:19 * TheHunter wonders why there's so much traffic on the mailing list about Things With Identity (whatever that means), and almost nothing about Lexically scoped type variables.
08:33:36 <shapr> TWI is very unfunctional.
08:33:59 <shapr> in Python lambda x:x + 1 does not equal lambda x:x + 1
08:34:09 <shapr> because only memory addresses are compared to find equality
08:34:10 <TheHunter> am I the only one who is pissed at the current type variable scoping rules?
08:34:25 <shapr> I'm not sure what you're talking about exactly :-)
08:34:52 <TheHunter> f :: a -> a
08:34:58 <TheHunter> f x = y where
08:35:01 <TheHunter>   y :: a
08:35:05 <TheHunter>   y = x
08:35:12 <kristnjov> uhm
08:35:29 <shapr> oh, you mean the Lennart Augustsson puzzle?
08:35:33 <TheHunter> this is a type error because a in y::a isn't the same as a in f :: a -> a
08:35:58 <TheHunter> no, i mean SPJ's questions on the list.
08:36:01 <shapr> oh
08:37:26 <tromp> i'd want it to be a type error
08:37:35 <TheHunter> doing stuff like callCC' (f :: ((a -> (forall b. m b)) -> m a) ) = callCC f' where ... seriously hurts, and ghc-6.3 even breaks this.
08:38:07 <TheHunter> there are so many possible type variable names. You can always choose a different name if you mean something else.
08:38:16 <edi> haskell has continuations ?
08:38:31 <shapr> java only has discontinuations ;-)
08:38:38 <TheHunter> edi, there is a continuation monad.
08:38:46 <edi> uh! :)
08:39:04 <TheHunter> @wiki MonadCont
08:39:05 <lambdabot> http://www.haskell.org/hawiki/MonadCont
08:40:44 <TheHunter> anyone here who feels like this is a big deal?
08:41:22 <shapr> it sure looks like it would be handy to have it work right.
08:42:12 <jadrian> back, sorry, connection problems...
08:42:38 <TheHunter> it's so cool that SPJ finds this so important he's even considering to sacrifice haskell 98 compatibility.
08:42:49 <jadrian> I partially understood the def of combinator, I'm just not sure about the difference between variable and term in this setting
08:43:22 <edi> What's SPJ ?
08:43:28 <jadrian> Symon P. Jones
08:43:34 <jadrian> Simon*
08:44:19 <jadrian> edi: http://research.microsoft.com/Users/simonpj/
08:45:35 <shapr> SPJ is a large part of the reason Haskell is so cool.
08:46:34 <edi> impressive
08:47:43 <shapr> I'm an obsessive research paper downloader/reader, and I still haven't read everything I have on-disk by SPJ.
08:48:04 <wilx`> :)
08:48:14 <shapr> Well, maybe I'm not obsessive, I just get bored and academic research papers are fun :-)
08:48:16 <wilx`> Research papers are so...thick.
08:48:27 <edi> I agree
08:48:31 <wilx`> I can't wrap my mind around them most of the time.
08:48:34 <Maddas> Thick in what sense?
08:48:39 <jadrian> shapr: I think SPJ is an obsessive paper uploader/writer, so it's going to be tough competition :)
08:48:45 * shapr laughs
08:48:49 <wilx`> THough I've only tried few.
08:48:49 <Maddas> Academic research papers are fun indeed :-)
08:48:49 * shapr quotes that
08:49:06 <Maddas> (Well, the easy ones, since I don't understand any talking about non-trivial things :-)
08:49:12 <Maddas> (FSVO non-trivial)
08:51:24 <shapr> my personal value of non-trivial changes as I read more research papers.
08:51:49 <shapr> wilx`: I ask questions here on #haskell when I can't wrap my head around a paper.
08:52:00 <shapr> Lots of smart people here who are willing to help out.
08:52:27 <Maddas> shapr: Indeed, I'm sure that is the case
08:53:30 <shapr> I try to figure things out on my own, but when I'm really stuck, it's good to ask people who know more than I do.
09:00:25 <wilx`> Hm.
09:00:33 * shapr beats sasl with more sticks
09:00:45 <shapr> I shall defeat SASL!
09:01:23 <shapr> wilx`: there are lots of fun papers to read.
09:01:36 <shapr> Of course, it depends on what you enjoy.
09:01:41 <wilx`> :)
09:01:44 <wilx`> Yeah.
09:02:04 <wilx`> Well, I find reading C++ proposals interesting  :)
09:02:15 <shapr> For me, part of the fun of programming is finding more mental toys. There's lots of mental toys in research papers.
09:02:30 <shapr> Hey, that's good. If you enjoy it, keep it up.
09:32:16 <mitchkov> hai, i ve a stupid question: how can i print some results in commander prompt while executing a function, because the end result is an empty set and i don't understand what's going on :)
09:37:08 <shapr> ?
09:37:17 <shapr> if it's a fold, you could do scanr
09:37:29 <shapr> if it's an iteration, you could use a side-effecty until
09:37:44 <shapr> hoi mitchkov, hoe gaat het?
09:37:53 * shapr stabs SASL
09:38:06 <mitchkov> ah nederlands :) heel goed shapr 
09:38:22 <shapr> I'm actually from Alabama, USA.
09:38:34 <shapr> Ik spreek un beetje nederlands.
09:38:54 <mitchkov> you're not bad !
09:39:00 <shapr> just enough to buy food and find the WC.
09:39:21 <shapr> I was in Brussels last christmas, it was fun!
09:39:42 <mitchkov> shpar, can you help me out ? 
09:39:50 <shapr> Maybe, what your function?
09:40:01 <shapr> um "what's your function" ?
09:40:13 <mitchkov> alterneer2 (y:ys) (x:xs)  
09:40:16 <mitchkov> 	  |y == 1      = alterneer2 (ys++[y]) (x:xs)
09:40:16 <mitchkov> 	  |otherwise   = alterneer2 (ys++[y]) xs
09:40:47 <mitchkov> i wanna know what xs and ys are, every time i call the function again
09:41:07 <edi> mitchkov, "the rest of the list", the tail, the cdr
09:41:19 <edi> where x and y are the head, the car, of them
09:41:21 <shapr> there is a function to do that, Debug.trace
09:41:27 <shapr> it's not very functional, but it'll work.
09:41:38 <edi> i think i misunderstood the question *cough*
09:41:46 <shapr> as for your code, I might suggest pattern matching instead.
09:42:08 <mitchkov> and that is ....
09:42:13 <shapr> alterneer2 (1:ys) (x:xs) = alterneer2 (ys++[y]) (x:xs)
09:42:24 <shapr> alterneer2 (y:ys) (x:xs) = alterneer2 (ys++[y]) xs
09:42:57 <shapr> Hey, you're Boegel's friend, aren't you?
09:43:02 <mitchkov> yes I am 
09:43:17 <mitchkov> but waddaya mean by pattern matching ? 
09:43:36 <shapr> pattern matching is where it looks like the function has multiple definitions, like the version I just showed in two lines
09:44:00 <shapr> under the hood, it happens with a case statement.
09:44:03 <tic> the first line matches against the cases where y == 1, the second line matches against everything else.
09:44:15 <tic> shapr, yeah, but that's not important for the coder. :)
09:44:26 <shapr> oh, good point
09:46:15 <shapr> edi: are you related to xerox?
09:46:38 <edi> yes, i should close mirc i know
09:46:51 <edi> i had to do something in emacs so i wakened up erc
09:46:54 * shapr was just curious
09:47:00 <edi> oh, ok (:
09:47:55 <mitchkov> shapr, can you explain me than how the Debug.trace works
09:48:22 <mitchkov> cuz i really need to know what those lists look like
09:51:58 <shapr> @type Debug.trace
09:51:58 <lambdabot> bzzt
09:52:05 <shapr> @index trace
09:52:07 <lambdabot> Debug.Trace
09:52:12 <shapr> @type Debug.Trace.trace
09:52:14 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
09:52:46 <shapr> mitchkov: so, I warn you ahead of time, this is really an ugly way to do tracing, but I'll still show you how to work it :-)
09:53:19 <mitchkov> thx anyway :) 
09:53:40 <shapr> ok, lemme test this before I give you wrong information...
09:54:11 <mitchkov> ok
09:55:14 <shapr> what inputs do you usually use?
09:55:38 <shapr> lemme guess, you get the error "Non-exhaustive patterns in function alterneer2" ?
09:56:07 <mitchkov> no, i just get an empty list
09:56:12 <mitchkov> no errors
09:56:25 <shapr> oh, strange. do you have a test input I can try?
09:57:12 <mitchkov> i use a pattern list: [1,0,1,1,0] that's y and than a random input list x (eg. [1,2,3,4,5,6,7,8,9,10])
09:57:56 <shapr> ok, my code really does work
09:57:59 <jadrian> shapr: for most my purposes I've found Data.trace to be the most convinient way to do tracing...
09:58:16 <jadrian> shapr: do you have any other suggestion? besides monadifying everything?
09:58:22 <shapr> write more unit tests
09:58:27 * shapr grins
09:58:32 <jadrian> ah of course! :)
09:58:38 <shapr> alterneer2 (1:ys) (x:xs) = trace (show ys ++ show xs) alterneer2 (ys++[1]) (x:xs)
09:58:40 <shapr> alterneer2 (y:ys) (x:xs) = alterneer2 (ys++[y]) xs
09:58:40 <shapr> alterneer2 x y           = error ("alterneer2 " ++ show x ++ show y)
09:58:46 <shapr> mitchkov: that's the code I just hacked up.
09:59:05 <jadrian> I should have seen that answer coming :)
09:59:15 <shapr> if you load it into ghci (or hugs) and run it with alterneer2 [1,0,1,1,0] [1,2,3,4,5,6,7,8,9,10] you'll see Debug.Trace.trace in action
09:59:27 <shapr> I put import Debug.Trace at the top of my file.
09:59:55 <jadrian> what I can't do yet
10:00:05 <shapr> jadrian: it really does work. Everytime you have to write some tracing code, that time does not 'pay back'
10:00:09 <shapr> it's just gone forever
10:00:17 <jadrian> yeap I understand
10:00:22 <mitchkov> ok i'll try that shapr
10:00:38 <mitchkov> thx 4 the help, dinner time first !!!
10:00:46 <shapr> if instead you write tests that are an investment of time, then every debugging session is profitable, in that the time you spent and the code you wrote pays dividends later.
10:00:59 <jadrian> there is one use of tracing where Data.trace isn't really adequate and unit testing doesn't help either
10:01:06 <shapr> oh, where?
10:01:13 <jadrian> and that's when you already have a fully functional algorithm
10:01:20 <shapr> ?
10:01:24 <jadrian> and then you want to gather information about the way it works
10:01:26 <shapr> what do you mean?
10:01:43 <jadrian> well for instance, you have a genetic algorithm
10:02:26 <jadrian> and then you'd like to to see how many times some kind fo mutation is applied
10:02:42 <shapr> I'd probably class that as logging.
10:03:01 <jadrian> ok... logging then :)
10:03:18 <jadrian> I still don't have any good method for doing that
10:03:21 <shapr> in which case, I'd write unit tests for a logging monad or something.
10:03:50 <shapr> I think Ginsu has some logging code.
10:04:34 <shapr> Trace is a hack, and it works. But if you need to use, it's likely that something already needs fixing.
10:04:55 <jadrian> but that implies "monadifying" your functions and that might imply large changes to your already stable algorithm implementation
10:05:06 <shapr> admittedly, I use trace when I'm prototyping, because all I want from a prototype is a rough idea of how to do a real implementation
10:05:12 <jadrian> and sometimes it's complicated to know exactly what you'll want to log
10:05:35 <shapr> I think ginsu's logging framework is both monadic and extensible.
10:05:43 <jadrian> I got to check it out
10:05:51 <jadrian> it's the first time I hear aout it
10:06:03 <shapr> yah, sometimes a bunch of pure code is just trouble to monadize.
10:06:13 <shapr> it's just easier to stay pure, and use trace in a few places.
10:07:16 <shapr> But it's not a good long-term solution.
10:07:49 <shapr> I've been having fun with HUnit lately, but I really want test fixture support now that I'm doing tests of side-effect stuff.
10:07:58 <jadrian> addmitedly I don't know that much about theoretical foundations of functional languages
10:08:13 <shapr> I probably don't either.
10:08:24 <jadrian> but what "bothers me" is that intuitively it seems that logging should be fine even with pure laguages
10:08:41 <jadrian> in the sense that you're exporting information 
10:09:02 <jadrian> but the semantics of your function should be the same
10:09:30 <jadrian> if you were reading information and using it
10:09:50 <jadrian> then of course you have side effects involved
10:10:01 <jadrian> but just exporting info, seems ok
10:10:04 <jadrian> *if*
10:10:19 <jadrian> you're not going to use that info in your algorithm
10:10:45 <jadrian> the point is that if I have an algorithm A
10:11:04 <jadrian> id like to be able to include A in B 
10:11:19 <jadrian> and export info from A to B
10:11:38 <jadrian> B would not be pure 
10:11:43 <jadrian> but A would
10:11:48 <jadrian> does that make any sense?
10:11:52 <shapr> sure
10:12:22 <jadrian> right now, even if you just export info from A to a higer layer you have to monadify A too...
10:12:22 <shapr> in that case, a logging monad wouldn't be impure, it'd just be a way to pipeline all the pure passing of log info
10:12:36 <jadrian> yeap
10:12:41 <shapr> monads don't necessarily mean impurity or side-effects
10:12:51 <shapr> they're just a way to make auto-pipes
10:13:09 <shapr> well, that's part of what they do.
10:13:16 <jadrian> yes
10:13:39 <shapr> in fact, this does sound like a writer monad
10:13:41 <shapr> the logger
10:13:48 <shapr> so you could do it with a monad transformer
10:13:56 <jadrian> yes I know that
10:16:37 <jadrian> but my point was that I still think there should be better solution for things like writer monads, without affecting the type system
10:16:50 <jadrian> let me give you an example
10:17:29 <jadrian> lets say an: algorithm A 
10:17:37 <jadrian> with a: function foo
10:17:54 <jadrian> A is not monadic
10:19:04 <jadrian> foo = ...
10:19:38 <jadrian> now I want to export info to an higher layer
10:19:50 <jadrian> like you said, writerMonad is something like a pipe
10:19:53 <jadrian> but if I do
10:20:28 <jadrian> foo = ...  ; write something  (ignore the syntax)  
10:20:48 <jadrian> and then just run A and never use the exported stuff
10:20:58 <jadrian> the semantics should be the same
10:21:38 <jadrian> that is, it would be nice to add exporting annotations, and preserve A as it was before
10:21:58 <jadrian> if I compiled that program A with the anotations I'd expect them to simply be ignored
10:22:04 <shapr> but, for it to stay pure it has to accumulate the logged info as it goes along.
10:22:17 <shapr> so the type does change.
10:22:38 <shapr> y0 delYsid!
10:22:40 <shapr> long time no see!
10:22:45 <jadrian> kind of
10:22:48 <delYsid> true!
10:22:49 <delYsid> hi shapr!
10:22:50 <jadrian> if you don't use that info
10:23:00 <jadrian> you don't have to accumulate it anywhere
10:23:04 <shapr> hey hey delYsid, check out Yi!
10:23:22 <shapr> delYsid: http://www.cse.unsw.edu.au/~dons/yi.html
10:23:23 <delYsid> Yi?
10:23:30 <jadrian> all those anotations would be ignored
10:23:44 <jadrian> and you'd have you're previous (pure function)
10:23:50 <shapr> true, but in that case you want something like commutative monads
10:24:03 <jadrian> now when you want to use that info, in that case... well
10:24:05 <shapr> delYsid: so, what brings you to #haskell?
10:24:36 <shapr> jadrian: that's a good point, and one that SPJ himself has mentioned, that monads can often cause 'over-sequencing'
10:24:38 <jadrian> you could see it as a pure program A that is running, and a program B that is annalysing it
10:24:54 <shapr> If you read his hair-shirt retrospective he discusses that, and ask for a nice syntax for commutative monads.
10:25:20 <jadrian> got to look into commutative monads, I don't know those yet...
10:25:27 <shapr> they don't exist =)
10:25:31 <jadrian> oh 
10:25:37 <shapr> but SPJ wants 'em
10:25:43 <delYsid> shapr: nothing in particular, just visiting old friends :)
10:25:56 <tromp> shae, when was next eurohaskell again?
10:25:57 <delYsid> Since you dont come to #emacs anymore, if the prophet doesn't...
10:26:02 <jadrian> but are they an already studied actegorical entity?
10:26:02 <shapr> hah
10:26:07 <jadrian> categorical*
10:26:10 <shapr> @eurohaskell
10:26:12 <lambdabot> less talks, more code!
10:26:12 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
10:26:12 <lambdabot> EuroHaskell - Haskell Hackfest - Summer 2005 - Gothenburg, Sweden
10:26:24 <jadrian> or did he came up with the definition in his paper?
10:26:28 <shapr> delYsid: I was in #emacs a few days back looking for you... because I wanted to show you Yi
10:26:29 <tromp> cause i must be in holland on June 11/12
10:26:39 <shapr> tromp: I think it'll be earlier than that.
10:26:50 <shapr> EuroHaskell will either be just before or just after EuroPython.
10:27:45 <delYsid> hmm, looks interesting, but I dont know how Haskell and Scripting go together...
10:27:52 <shapr> jadrian: The Hair Shirt Retrospective is a PPT, but I've converted it via OpenOffice - http://www.scannedinavian.org/~shae/retro/HairShirt.html. If you have OpenOffice, the PPT looks nicer.
10:28:15 <jadrian> shapr: thanks!
10:28:23 <shapr> you remember the basic runtime dynloading that lambdabot does?
10:28:33 <delYsid> kind of
10:28:36 <shapr> dons has thoroughly extended that, it does lots more now.
10:29:05 <shapr> at this point, Yi has a static loader, and everything else is dynamic, and can be reloaded.
10:29:30 <delYsid> kind of like microkernel design I guess
10:29:47 <shapr> there's even :reboot that saves state and restarts the whole editor, putting you back where you were in about .2 seconds
10:29:49 <edi> gee, Yi-OS
10:29:54 <jadrian> brb
10:29:55 <shapr> this is cool for editing the core of the editor.
10:29:57 <delYsid> does it to terminal IO?
10:30:10 <shapr> what do you mean?
10:30:35 <shapr> ich verstehe nicht :-)
10:30:37 <delYsid> you know, the dreaded "can I use it" question
10:30:45 <shapr> it uses ncurses
10:30:51 <delYsid> gppd
10:30:57 <delYsid> er
10:30:57 <delYsid> good
10:31:01 <shapr> the ui is on the way to pluggable
10:31:24 <shapr> I've been thinking about an OpenGL ui for extra-strange tricks.
10:31:25 <delYsid> I guess I cant go apt-get install yi yet, right? :)
10:31:34 <KiMoS> can someone help me with this function i have realy no idea how to make it  
10:31:37 <KiMoS> highInt :: String -> Integer
10:31:52 <shapr> nope, you need ghc6, darcs, and the latest hs-plugins from dons' website.
10:31:56 <shapr> then you can build Yi
10:32:12 <delYsid> uuuuuffff
10:32:23 <KiMoS> highIst must return the highist number in a string like  "aaa123aaa1aa9"  return 123   block of int count as a number 123
10:32:27 <edi> i agree with delYsid :)
10:32:31 <delYsid> not that I am not used to that, but I really dont feel like installing dependency chains today :)
10:32:37 <shapr> yah, I understand.
10:33:15 <delYsid> ghc6 and darcs not being a problem
10:33:19 <shapr> I was originally thinking of scripting with Joy, and written in Haskell, but hs-plugins is so dynamic that's not needed.
10:33:26 <delYsid> but as soon as stuff leaves apt-space, I am lazy :)
10:33:36 <shapr> if/when you get the urge to install hs-plugins, I can help you out.
10:33:49 <musasabi> shapr: Does it (=yi) have a GUI typeclass yet?
10:34:00 <shapr> at the moment, debs of hs-plugins would have to be updated once every few days to run Yi
10:34:10 <shapr> musasabi: don't think so
10:34:41 <shapr> the yi 0.1 release is close, then we can go crazy on the UI and the parsers
10:35:04 <delYsid> be sure to keep the ncurses UI equivalent to others.
10:35:10 <shapr> will do
10:35:11 <delYsid> thats the really kick ass thing about emacs
10:35:27 <musasabi> shapr: When you have the gui typeclass and answer to the top-loop question I can contribute a GUI ;)
10:35:27 <shapr> well, you know I want to fix the emacs warts with Yi
10:35:38 <shapr> musasabi: sounds good :-)
10:35:44 <shapr> fltk I assume?
10:35:50 <musasabi> yes
10:36:05 <shapr> multithreading, parser-based modes, parse tree macros, etc
10:36:32 <shapr> I just want to live in an editor that I'm happy with.
10:37:10 <musasabi> Currently I am waiting for a cabal release before posting a link to the MLs about hs-fltk.
10:38:41 <shapr> delYsid: how's code?
10:43:42 <edi> what's fltk ?
10:43:50 <shapr> so, how do I let the postfix user read my /etc/sasldb2 ?
10:44:38 <shapr> can a file only be owned by a single group?
10:46:51 <musasabi> edi: A portable lightweight GUI toolkit.
10:46:55 <musasabi> edi: www.fltk.org
10:47:51 <edi> mmh, how's compared to wxwindows ?
10:48:08 <musasabi> edi: much smaller ;)
10:49:19 <vegai> "supports 3d graphics via OPENGL..."
10:49:19 <edi> heh
10:51:33 <delYsid> hmm, how do I tell hs-plugins to use ghc6 instead of ghc?
10:52:50 <musasabi> --with-ghc or something similar.
10:52:51 <delYsid> shapr: code was mostly plain C driver hacking this year...
10:53:00 <musasabi> that is --with-ghc=ghc6
10:54:24 <vegai> hmm, seems like yi doesn't compile here...
10:54:31 * vegai cleans and tries again
10:54:56 <delYsid> hmm, --with-ghc=ghc6 doesnt help.
10:55:21 <shapr> delYsid: do you have ghc5 installed?
10:55:33 <shapr> you could always tell /etc/alternatives/ghc to be ghc6
10:55:36 <delYsid> lexx:~/src/hs-plugins-20041129% ./configure --with-ghc=ghc6
10:55:36 <delYsid> checking build system type... i686-pc-linux-gnu
10:55:36 <delYsid> configure: error: ghc6 not found. You need GHC to build this project
10:55:36 <delYsid> zsh: exit 1     ./configure --with-ghc=ghc6
10:56:02 <shapr> sounds like you don't have the ghc6 deb installed.
10:56:47 <delYsid> no, its there...
10:56:51 <delYsid> now that I set the alternative
10:57:01 <delYsid> I get the error that I am missing ghc-pkg, whatever that is
10:57:37 <shapr> should be /usr/bin/ghc-pkg, but that may also be an alternatives prob
10:57:37 <Igloo> What version of ghc6 do you have?
10:58:07 <delYsid> 6..2
10:58:11 <delYsid> 2.2
10:59:59 <Igloo> Hmm, do /usr/bin/ghc-pkg and /etc/alternatives/ghc-pkg look right?
11:00:01 <delYsid> hm, directly specifying it with full path --with-ghc-pkg= helped
11:00:24 <Igloo> Oh, I bet it wanted /usr/bin/ghc6-pkg
11:00:26 <delYsid> Igloo: no, I simply appear to have no alternative for ghc-pkg
11:00:41 <delYsid> Igloo: /usr/bin/ghc-pkg6 actually
11:01:15 <Igloo> If you have a 6.2.2-anything deb you ought to have a /usr/bin/ghc-pkg
11:01:37 <Igloo> (assuming it's the selected alternative for /usr/bin/ghc)
11:01:39 <vegai> ah, yi compile worked after I darcs getted again
11:02:13 <vegai> Fail: user error (Curses[-1]:init_pair)
11:02:18 <vegai> (when running it)
11:02:39 <shapr> I can run it.
11:03:10 <delYsid> well, how do I build yi now?
11:03:12 <vegai> shapr: it fails with xterm and Terminal
11:03:18 <vegai> shapr: but works on a virtual console
11:03:32 <shapr> huh, weird
11:03:44 <shapr> works for me on gnome-terminal
11:03:46 <tuomov> weird termcap/terminfo?
11:03:52 <vegai> I can cheat it with TERM="linux" yi
11:03:54 <tuomov> saying there are no colours or such
11:04:02 <vegai> it doesn't like TERM="xterm" here, it seems
11:04:15 <tuomov> I have TERM=xterm-debian
11:04:30 <tuomov> but TERM=xterm works too
11:04:38 <vegai> tuomov: "Fail: user error (Curses[-1]:init_pair)" and it bails out
11:04:46 <tuomov> TERM=vt100 fails
11:04:55 <vegai> something wrong with my termcap / ncurses, obviously
11:05:15 <tuomov> that too, but also perhaps it shouldn't die on not being able to create that colour pair..
11:06:03 <delYsid> hmm, the Makefile of yi looks very broken
11:06:17 <delYsid> I mean, the build stage fails quite extremely
11:06:20 <vegai> tuomov: at the least it could deinit ncurses cleanly =)
11:06:45 * vegai wonders if he could help
11:07:29 <delYsid> shapr: any hints?
11:07:34 <shapr> delYsid: what errors?
11:07:56 <shapr> once you've done a darcs get, then autoreconf && ./configure && make boot all
11:07:56 <delYsid> lexx:~/src/yi% make all
11:07:56 <delYsid> Makefile:103: depend: No such file or directory
11:07:56 <delYsid> Icbits   Yi/Curses/CWString.hsc
11:07:56 <delYsid> make: Icbits: Command not found
11:07:56 <delYsid> make: [Yi/Curses/CWString.hs] Error 127 (ignored)
11:07:56 <delYsid> Icbits   Yi/Curses/Curses.hsc
11:07:58 <delYsid> make: Icbits: Command not found
11:08:00 <delYsid> make: [Yi/Curses/Curses.hs] Error 127 (ignored)
11:08:02 <delYsid> ...
11:08:11 <shapr> yes, you need autoreconf && ./configure && make boot all
11:08:49 <delYsid> yes, thats what I did
11:10:45 <shapr> it should be calling hsc2hs
11:11:00 <shapr> is that another alternatives problem?
11:11:11 <shapr> probably so
11:11:13 <delYsid> well, the Makefile isnt generated from configure, at least not afaics
11:11:39 <delYsid> I dont have hsc2hs at all
11:11:56 <shapr> your /etc/alternatives/hsc2hs should point somewhere useful
11:12:06 <delYsid> where?
11:12:21 <shapr> mine points to /usr/lib/ghc-6.2.2/bin/hsc2hs
11:12:29 <delYsid> OMG
11:12:46 <delYsid> I wonder why I dont have that
11:13:03 <delYsid> lexx:~/src/yi% sudo update-alternatives --config hsc2hs
11:13:04 <delYsid> No alternatives for hsc2hs.
11:13:34 <shapr> !
11:14:01 <Igloo> It's a slave of ghc
11:14:33 <delYsid> ah, I see.
11:14:42 <delYsid> the bug is that configure silently fails although hsc2hs was not found
11:14:52 <delYsid> er, I mean, it does not fail.
11:15:04 <shapr> yup
11:15:05 <Igloo> Try reselecting ghc6 as the ghc alternative
11:15:22 <delYsid> Igloo: I have that
11:15:53 <delYsid> looks like something is broken with my ghc package
11:16:20 <delYsid> eeek, looks like vi!
11:16:32 <delYsid> shapr: Any quick hints for de-vi-ification?
11:17:16 <shapr> well, there's an emacs keymap
11:17:20 <shapr> but I haven't tried it yet
11:17:43 <tuomov> I have written the beginnings of a joe keymap that should be quite easily modified to an emacs map
11:17:49 <shapr> as with any sane editor, behavior is just a matter of syntax
11:17:52 <tuomov> a lot of functionality is still missing
11:18:23 <tuomov> kmap=[
11:18:27 <tuomov>     "\^KU" ++> topE,
11:18:27 <tuomov>     "\^KV" ++> botE,
11:18:37 <tuomov> looks like that
11:19:06 <shapr> delYsid: and unsurprisingly, very much can be configured in your ~/.yi/Config.hs
11:19:38 <edi> dinner time, later!
11:20:29 * shapr kicks SASL
11:20:55 <dash> shapr: don't hurt your foot
11:20:59 <delYsid> hmm, ok, I see...
11:21:04 <shapr> truly, it is a tough little bugger.
11:21:11 <delYsid> You got a funny 30 years of development ahead of you guys :)))
11:21:22 * shapr shrugs
11:21:53 <dash> just write a monadic elisp interpreter
11:21:58 <dash> then you're halfway done!
11:26:08 <KiMoS> so anyone can help me with the function i was trying to make?
11:26:32 <goron> Can anyone help me with a package(Debian) problem? 
11:26:40 <shapr> which package?
11:27:03 <Lemmih> KiMoS: Sure.
11:27:21 <KiMoS> its about this   highInt :: String -> Integer
11:27:35 <goron> mrpostman-debianized, which depends on java_something_05. 
11:27:39 <KiMoS> must return the highist number in a string  
11:27:59 <KiMoS> but a block of int count as one number  
11:28:00 <goron> I installed a binary java outside of my package system. 
11:28:23 <KiMoS>  maximum (filter isDigit "a2a4a12a")   this wont work   becouse it give back 4 instead of 12
11:28:31 <goron> And now every time it claims I have a "broken" package, while in fact everything is working fine...
11:29:00 <goron> I want to change it status to being not broken, without removing the program. 
11:29:42 <KiMoS> Lemmih any idea?
11:30:17 <goron> So in genereal package A depends on B, but A's dependencies are fullfilled outside the package management system, and it keeps nagging about B being not fullfilled. 
11:32:53 <dblhelix> KiMoS: have you considered using reads to parse the first numeric part of the string and then to strip the next character and continue that way until you have processed the whole input?
11:33:08 <dblhelix> @type reads
11:33:09 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
11:33:41 <dblhelix> then you'll have a value of type [Integer], which you can easily sort
11:35:53 <KiMoS> but dblhelix  if i do that i wont get a block of int as 1 number
11:36:36 <dblhelix> yes, you will: reads give you the longest parse
11:36:41 <shapr> ya know
11:37:04 <shapr> it would be less effort to add the necessary features to Postmaster instead of slogging through all this source
11:38:05 <KiMoS> read "aa12aa122"::Int
11:38:05 <KiMoS> Program error: Prelude.read: no parse 
11:38:40 <dblhelix> no, not read, but reads
11:38:51 <KiMoS> oh reads   sorry 
11:39:01 <dblhelix> if you get no parse, you strip the head and you try again
11:39:01 <KiMoS> let me read reads first im new to haskell
11:39:07 <dblhelix> ok
11:39:55 <KiMoS> how do you strip the head ?
11:40:14 <dblhelix> @type head
11:40:15 <lambdabot> head :: forall a. [a] -> a
11:40:23 <dblhelix> @type tail
11:40:24 <lambdabot> tail :: forall a. [a] -> [a]
11:40:42 <dblhelix> by using tail (but you have to be sure that the list is non-enm
11:40:51 <dblhelix> non-empty)
11:41:20 <Lemmih> Or dropWhile (not . isDigit)
11:42:04 <kristnjov> dropWhile and takeWhile are the best functions available in haskell ;O
11:42:05 <dblhelix> that's even better
11:42:14 <Lemmih> @type List.dropWhile (not . Char.isDigit)
11:42:15 <lambdabot> List.dropWhile (not . Char.isDigit) :: [Char] -> [Char]
11:42:55 <goron> shapr: You had no idea?
11:43:14 <KiMoS> how do you use reads dblhelix  there is no example in the references
11:43:34 <shapr> goron: no idea about what?
11:43:46 <shapr> oh, your java package?
11:44:03 <goron> shapr: Yeah.
11:44:08 <Lemmih> reads "10abc20" :: Int => [(10,"abc20")]
11:44:14 <shapr> there's a fake-java package you can install
11:44:18 <shapr> I forget the name of it.
11:44:47 <Lemmih> s/Int/[(Int,String)]/
11:45:12 <goron> shapr: I tried that 1,5 months ago, or so. Then it didn't work very smoothly. I could try again...
11:45:24 <dblhelix> reads "12xyz45" will give you [(12, "xyz45")]
11:45:53 <KiMoS> i get error on that
11:45:54 <KiMoS> ERROR - Unresolved overloading
11:45:55 <KiMoS> *** Type       : Read a => [(a,[Char])]
11:45:55 <KiMoS> *** Expression : reads "12xyz45"   
11:46:32 <KiMoS> the same error when i try reads "10abc20" :: Int
11:46:48 <Lemmih> Yeah. I corrected that two lines down.
11:48:57 <Lemmih> I wonder if it's sound to use TH in a non-toy program.
11:50:07 <Igloo> If you do, and it's OS, please let me know!
11:51:39 <dblhelix> KiMoS: can I mail you a little sample?
11:51:51 <KiMoS> yes u can
12:05:35 * shapr maniacally stabs sasl
12:05:46 <shapr> I think I'll just switch to Postmaster.
12:06:32 * jadrian should learn more about some CAS
12:06:53 <jadrian> to bad not much development seems to be happening in open CAS like yacas or maxima...
12:08:43 <Muad_Dibber> CAS?
12:09:07 <shapr> computer algrebra system?
12:09:16 <jadrian> yeap
12:09:18 <Muad_Dibber> k
12:18:10 * dblhelix is away: ...
12:41:35 <goron> Thanks to the great help of #debian...namely none... I did it myself by tracing all the scripts and stuff of the original package(which was corrupting the dependencies)...so..
12:41:39 * goron is :)
12:59:41 * shapr gives up on sasl
12:59:47 <dash> what were you doing with sasl
13:00:04 <kristnjov> a sexy asl
13:02:38 <shapr> dash: trying to make it work.
13:02:45 <shapr> postfix + sasl
13:03:05 <shapr> I got saslauthd working, according to the test binaries, but postfix refuses to speak to it.
13:06:39 <shapr> dash: you know anything about postfix + sasl?
13:11:00 <goron> Is there some tool to automatically recompile everything when you upgrade to a new version of ghc? I thought I heard of something like that.
13:11:40 <shapr> would be nice
13:13:11 <ayrnieu> goron - I suppose that you could have a cron job which checks the version of ghc against the one in your programs-compiled-by-ghc database.
13:13:33 <dash> shapr: all my experiences with SASL have been bad
13:14:03 <edi> What finally is SASL?
13:14:08 <dash> seeing as i'm working for a company developing what you might call a competing product, i can't recommend it :)
13:14:19 <dash> edi: "simple" auth and security layer
13:17:32 <Muad_Dibber> dash: bill gates wont admit linux pwns windows either :P
13:18:35 <goron> There should be such a mechanism in Cabal, or all haskell compiled code should be very much more stable. 
13:22:25 <SyntaxNinja> that's the job of a cabal-layered tool.
13:22:43 <boegel> hello everyone
13:23:38 <SyntaxNinja> hi boegel
13:24:13 <stepcut> this HList stuff is sweet!
13:26:21 <boegel> stepcut, what is HList ?
13:27:01 <stepcut> Strongly Typed Heterogeneous Collections
13:27:17 <stepcut> http://homepages.cwi.nl/~ralf/HList/
13:27:34 <stepcut> It solves the option list problem nicely
13:27:38 <musasabi> How would one create a FiniteMap like HList?
13:27:53 <musasabi> And how to generalize that automatically to other structures?
13:28:03 <stepcut> musasabi: I have not got that far yet
13:28:11 <wagle> hmm..  i'll have to write a scheme interpreter using it..  ~*<8-)
13:28:39 <dash> Muad_Dibber: huh what what?
13:29:15 <stepcut> with hlist, I can define a bunch of options that a function can take (To, From, UDH, Etc), and then enforce that each option only appears once 
13:29:32 <dash> wagle: scheme lists are homogenous!
13:29:47 <dash> type SchemeList = [SchemeValue]
13:29:48 <dash> ;)
13:30:19 <stepcut> and, I can reuse the options for different functions, but have each function take a different subset of the the options, one might only take UDH and To, and another might only take UDH and From
13:31:13 <ayrnieu> dash - and all programming languages are purely functional!  You can't choose not to pass the entire state of the world through your every function!
13:33:27 <wagle> (1 "a" 'b' 2.3 (lambda (x) (+ x 1)) '()) is a scheme list
13:33:50 <wagle> oh.. 
13:34:14 <wagle> i mean writing a scheme variant using hlist instead of universal types
13:34:46 <ayrnieu> wagle - except for 'b'
13:35:57 <wagle> > '(1 "a" 'b' 2.3 (lambda (x) (+ x 1)) '())
13:35:57 <wagle> (1 "a" 'b '2.3 (lambda (x) (+ x 1)) '())
13:36:07 <wagle> duh..  hold on
13:36:37 <wagle> > (list 1 "a" 'b '2.3 (lambda (x) (+ x 1)) '())
13:36:37 <wagle> (1 "a" b 2.3 #<procedure> ())
13:37:24 <wagle> ayrnieu: ?
13:37:49 <wagle> oh..  nm
13:38:08 <wagle> i don't do enough actual scheme these days
13:38:31 <wagle> (suddenly remembered that ' is a read macro for quote
13:38:39 <wagle> )
13:41:47 <wagle> (scheme interpreters are one of my "hello world" suite of programs to write in each new language/methodology, even if i don't actually program in scheme these days)
13:42:15 <ayrnieu> ... or, presumably, get much correctness in your intepreter.
13:42:30 <musasabi> wagle: I would make: data SchemeT = SInt Int | SLambda ...
13:44:12 <wagle> ayrnieu: huh?
13:44:44 <dash> scheme is complicated to implement
13:44:51 <wagle> musasabi: i'm a platonist.  i'll have to wait to see what i get..  8)
13:44:56 <dash> especially backquote
13:45:14 <wagle> dash: not really
13:45:20 <dash> wagle: well it gave /me/ fits
13:46:18 <wagle> dash: you have to realize that reader macros are separate
13:46:30 <ayrnieu> wagle - suggesting that your admitted and exhibited ignorance of of even Scheme syntax for basic literal data types may indicate that your schemes-in-every-language may not actually implement the language at all well.
13:46:38 <ayrnieu> Scheme doesn't have reader macros, wagle.
13:46:59 <wagle> ayrnieu: you are a troll.  go away.
13:47:39 <dash> well, uh
13:47:45 <dash> scheme /doesn't/ have reader macros, really
13:47:54 <ayrnieu> wagle - indeed?  Go back and read your statement and my reply to it.  If you didn't want a verbose follow-up, you should've avoided the completely retarded "huh?" question.
13:50:02 <wagle> ayrnieu: please grow up
13:50:45 <wagle> dash: i'm calling things like "'", ",", etc reader macros
13:51:04 <wagle> if you want to call them something different, thats fine
13:51:33 <wagle> but processing them is something more that mere tokenization
13:51:56 <wagle> but processing them is something more than mere tokenization
13:53:41 <dash> it was the most gnarly part of the parser, anyway :)
13:56:52 <wagle> yeah, i can see how the wrong approach would make them a bit torturous
13:57:38 <wagle> at some point the scheme report described them in detail..  did that go away?
14:00:28 <wagle> anyone know what "the 1-ambiguity property is" (wrt parsing xml)
14:00:41 <wagle> anyone know what "the 1-ambiguity property" is? (wrt parsing xml)
14:09:18 <Muad_Dibber> wagle, why all the double statements? :P
14:10:03 <Muad_Dibber> we all understand u make typos ;)
14:12:49 <wagle> i felt repeating with the typo corrected was easier to read than the sed notation
14:13:16 <Muad_Dibber> :)
14:13:24 <Muad_Dibber> i'll stop whining ;)
14:13:43 <segphault> I've run into a little problem. I'm porting some of my ocaml code to haskell, and I cant quite figure out a way to express this particular function without side affects
14:13:55 <wagle> and didnt require you to spend the time to figure out how to apply the sed pattern t=when you didnt care..  8)
14:14:32 <resiak> I'm trying to let emacs into my black vim-tainted heart, but I can't figure out how to make the indenting in haskell-mode work. If I type    cp = foldr op e \n where op xs ys =     and hit tab, I'd expect the second line to line up appropriately, but it won't budge from the left column.
14:14:57 <Janni> G'evening
14:15:08 <resiak> Ignore me, I suck and forgot the >s in my .lhs :s
14:15:38 <wagle> resiak: sometimes hitting tab again cycles through the various possible indentings.. (sometimes it wont choose one that i'd like, though)
14:16:12 <wagle> oh..  nm then..
14:16:19 <resiak> wagle: Yeah, I just found that.
14:17:17 <resiak> wagle: Hmm. It won't indent my second definition within the where as I would like/expect. Ack well.
14:17:41 <shapr> stepcut: hey, is the latest Emacs keymap in yi?
14:17:56 <dons> moin
14:18:03 <shapr> g'day dons
14:18:15 <edi> hello dons :)
14:18:23 <dons> hey guys. doing some yi hacking?
14:18:28 <wagle> resiak: fortunately, you can override it by manually spacing
14:18:36 <wagle> yi?
14:18:38 <shapr> yi!
14:18:39 <resiak> wagle: Indeed. I think I shall migrate back to vim ;)
14:18:45 <shapr> yi!
14:19:06 <edi> stop answering yi! to people!
14:19:10 <wagle> nooooooooOOOOoooo  xemacs is everything!  </sigh>
14:19:25 <shapr> I used to love xemacs, but I've lost that loving feeling.
14:19:29 <segphault> if somebody could take a look at this and give me some suggestions, i'd be very appreciative: http://rafb.net/paste/results/qSdbsQ60.html
14:19:37 <shapr> hiya segphault, how's code?
14:19:57 <segphault> hm?
14:19:59 <shapr> dons: I spent all day hacking SASL, unsuccessfully :-/
14:20:38 <shapr> segphault: that looks like ocaml code
14:20:42 <segphault> it is
14:20:55 <segphault> i'm trying to port it to haskell, and i'm stuck because of haskell's lack of state
14:20:55 <shapr> you can use a monad
14:21:16 <shapr> in essence, the only way to have 'state' is to pass it explicitly
14:21:20 <shapr> but a monad makes that easy.
14:21:32 <wagle> what is yi?
14:21:37 <segphault> I thought I monad might work, and i've spent the last several hours reading about them, but I cant figure out how I would apply monads to this problem
14:21:53 <segphault> I tried passing state manually, but because of the recursion, it gets all messed up
14:22:01 <dons> wagle: http://www.cse.unsw.edu.au/~dons/yi.html
14:22:07 <dons> haskell editor project.
14:22:08 <shapr> Have you read the nomaware monads tutorial?
14:22:14 <shapr> Yi is spiffy.
14:22:41 <segphault> shapr: yeah. that was the first one I read
14:22:47 <dons> it's getting more usable all the time
14:23:54 <wagle> cool..  i was trying to imagine how to write an IDE in haskell...
14:24:22 <shapr> segphault: the simplest approach is a state monad.
14:24:41 <shapr> but if you're doing some sort of iteration over a tree structure, there are other solutions
14:25:41 <segphault> shapr: like what?
14:25:41 <wagle> need a refactorer that "thread function XXX to state monad form"
14:26:40 <shapr> segphault: first two I can think of are richard bird's various one-pass tree counters, and maybe defining an fmap for your tree.
14:26:49 <shapr> I think it's fmap...
14:27:02 <shapr> you can define how to map over a algebraic datatype
14:27:06 <segphault> will that be difficult?
14:27:24 <resiak> Is there any probably reason why my university uses Hugs rather than GHC(i)?
14:27:25 <shapr> depends on what you're doing, and with what datatype.
14:27:31 <resiak> s/probably/probable/
14:27:40 <wagle> if you are going to do haskell, you should be facile with monads
14:27:47 <dons> resiak: maybe they haven't upgraded since '98
14:27:49 <wagle> ... get facile ..
14:27:56 <shapr> segphault: you're doing this for actual paying work, aren't you?
14:28:06 <segphault> no
14:28:10 <shapr> oh, ok
14:28:25 <segphault> I'm trying to learn haskell, and I figured the best way to do that would be to port an ocaml program
14:29:02 <shapr> you're incrementing a counter in that code
14:29:12 <segphault> right
14:29:13 <wagle> you get to play with the state monad in a simpler setting first..
14:29:40 <wagle> s/get/need/
14:29:46 <shapr> hm
14:30:28 <wagle> convert some simple tree traversal functions first
14:30:35 <shapr> yah, that's what I'd suggest too
14:31:05 <segphault> eh?
14:31:08 <shapr> and you may want to check out the Functor typeclass also.
14:31:21 <shapr> though I admit, monads are seductive and powerful.
14:31:41 <segphault> will I ever find a simple way to do what I want to do, or am I better off just returning to ocaml?
14:32:06 <dons> tuomov: around?
14:32:07 <shapr> I think monads *are* simple, but they require a certain way of thinking about the problem.
14:32:09 <wagle> segphault: i claim that its important to understand monads
14:32:21 <shapr> it's like OOP, you gotta think about it in the right way to use it right.
14:32:35 <shapr> but, traversing a tree isn't so hard
14:32:40 <dons> tuomov: I want to know what you mean by line editor? -- like the echo buffer in vim mode?
14:32:49 <dons> or do you need fancier editing?
14:32:49 <segphault> yeah, but will using a monadic idiom vastly increase the verbosity of code?
14:33:02 <shapr> no, monads usually make stuff much simpler.
14:33:03 <wagle> it will decrease the verbosity
14:33:09 <shapr> sometimes so simple you wonder where all the code went.
14:33:14 <segphault> hm
14:33:23 <wagle> plus you can factor the code in new and interesting ways
14:33:28 <segphault> I'm still having trouble understanding how to use them.
14:33:28 <shapr> like the Gen monad in QuickCheck, it's amazing how much you can do with so little code.
14:33:43 <dons> shapr: why did yi segfault for you (in the logs)? any ideas?
14:33:50 <shapr> user error
14:33:52 <shapr> :-)
14:34:07 <dons> oh.. were you hacking the src again? I warned you about that...
14:34:09 * wagle thought haskell couldnt segfault..  >)
14:34:11 * shapr grins
14:34:15 * Nioate is having a lovely experience with parser monads right now
14:34:27 <Nioate> yay
14:34:37 <dons> shapr: when you mix it with dynamic loading, into running applications...
14:34:38 <shapr> segphault: one thing the nomaware tutorial says, "monads are like an assembly line"
14:34:49 <dons> and we don't do all the dyn type checking we could. todo
14:34:57 <shapr> should the emacs keymap work?
14:35:20 <dons> no. it has been disabled since the keymap type changed. only small change to get it  working again required
14:35:24 <shapr> ah, I see.
14:35:29 <shapr> what change is required?
14:35:52 <dons> make sure the type is correct :P
14:35:58 <shapr> fair enough :-)
14:36:00 <wagle> anyone know what "the 1-ambiguity property" is? (wrt parsing xml)
14:36:14 <dons> you've just got to hook the emacs lexer back in
14:36:34 <dons> maybe stepcut could send in whatever he has?
14:36:41 <wagle> segphault: learning monads takes a little time, but its worth it
14:36:53 <shapr> segphault: the monadic interface is very powerful and elegant, but it's a bit mind boggling at first
14:37:01 <dons> shapr: what about those build problems?
14:37:07 <dons> I've fixed the TERM=vt100 issue
14:37:08 <shapr> I think it's confusing at first because you expect powerful stuff to be more complex
14:37:10 <segphault> i've already spent more time trying to learn monads than it took me to learn the entire ocaml language
14:37:23 <shapr> it's still worth it.
14:37:29 <Riastradh> segphault, consider a sequential computation.
14:37:38 <shapr> I also think the monadic abstraction is more powerful than all of OOP.
14:37:39 <Riastradh> It starts off with a single value.
14:37:56 <Riastradh> The computation may be extended by a function that maps the current value to a new value.
14:38:40 <Riastradh> For example, take a simple non-deterministic computation.
14:39:01 <dons> musasabi: I'll need an example of what the main loop would have to be for some arbitrary ui
14:39:03 <Riastradh> I'll represent all the threads' current values in a notation similar to Haskell lists; so, for example, if there are three non-deterministic threads with the current values 1, 2, & 3, the computation would be denoted with [1,2,3].
14:39:11 <Riastradh> segphault, do I make sense so far?
14:39:22 <dons> musasabi: though it would seem fairly easy for the ui to define its own loop
14:39:25 <segphault> sort of
14:39:34 <shapr> dons: I dunno what happened with the build problems, but I ended up re-getting the whole repo and then it all worked.
14:39:43 <Riastradh> So you start off with a single value -- say, 1.  The computation looks like [1].
14:39:57 <shapr> but even make distclean && autoreconf && ./configure && make boot all wouldn't fix it.
14:40:02 <dons> shapr: good. ok. maybe it was the left-over .o's after moving some stuff around
14:40:10 <shapr> yah, maybe so.
14:40:24 <dons> the build system is a bit too friendly about picking up .os to link
14:40:29 <Riastradh> Then you might compute +/- on it, so it splits to [1,-1].
14:40:36 <Riastradh> Follow, segphault?
14:40:38 <musasabi> dons: most UIs have a mainloop which dispatches eventhandlers.
14:40:40 <dons> musasabi: e.g. the current loop is just: repeatM_ $ handle handler (sequence_ . fn =<< getChanContents ch)
14:40:47 <shapr> stepcut: hey, is your emacs keymap handy?
14:41:05 <dons> musasasabi: yah. right. so instead of getch
14:41:19 <segphault> Riastradh: yeah
14:41:23 <dons> this isn't actually the main loop for yi though. it's the input thread loop
14:41:32 <dons> getcLoop ch = repeatM_ $ threadWaitRead 0 >> getcE >>= writeChan ch
14:41:52 <boegel> @senn mitchkov
14:41:52 <lambdabot> Sorry, I don't know the command "senn", try "lambdabot: @listcommands"
14:41:57 <boegel> @seen mitchkov
14:41:58 <lambdabot> I saw mitchkov leaving #haskell 4 hours 40 minutes 9 seconds ago.
14:41:58 <dons> musasabi: so we'd want a different getcLoop
14:42:04 <boegel> ow, I missed him
14:42:04 <Riastradh> So now suppose you want to add 3 to the value.  You extend the computation with the function (\x -> x + 3), and each value is incremented by 3; you therefore get [4,2].
14:42:15 <shapr> boegel: I helped him debug some code
14:42:26 <boegel> shapr, nice :)
14:42:35 <boegel> he finally got it that he has to come here :)
14:42:40 <shapr> :-)
14:42:47 <boegel> I've learned _a lot_ from you guys is the past few weeks
14:42:57 <shapr> yay!
14:43:08 <boegel> I helped him too an hour ago
14:43:23 * shapr compares the vi and emacs keymaps
14:43:27 <dons> musasabi: but can I just do getevent? or do I really have to hand control over to the ui binding?
14:43:32 <Riastradh> segphault, am I still making sense?
14:43:37 <dons> shapr: lookk at the vim one for state of the art
14:43:40 <segphault> Riastradh: yes
14:44:15 <Riastradh> OK.
14:44:20 <shapr> dons: do you have a dead simple keymap that uses the lazy lexers etc?
14:44:24 <Riastradh> What I have been describing is a simple monad, the non-determinism monad.
14:44:26 <dons> shapr: cmd_eval is probably what you'd want.
14:44:37 <Riastradh> Monads are simply generalizations of computation.  This is one specific kind of monadic computation.
14:44:39 <dons> shapr: I think I need to rewrite the Nano keymap that way, huh?
14:44:46 <shapr> er I dunno
14:44:46 <Riastradh> How do you get [1] from 1?  return 1
14:44:57 <shapr> I just want something that's 'correct' and I can use to build an emacs keymap
14:44:58 <segphault> Riastradh: I see how you are chaining the operations together, and I see how that describes a monad, but I still dont understand how that could be applied to larger problems
14:45:04 <dons> well, nano is dead simple. seems vim is getting to obfuscated to hellp people
14:45:10 <Riastradh> How about from [1] to [1,-1]?  [1] >>= \x -> [x,-x]
14:45:12 <shapr> and the vim keymap confuses me because of the state
14:45:12 <Riastradh> OK.
14:45:21 <dons> yeah. the state. hmm.
14:45:24 <Riastradh> Monads can also hold more information than just one value.
14:45:31 <Riastradh> Take a state monad, for instance.
14:45:32 <dons> ok. I'll hack up the nano one as an example tonight
14:45:34 <shapr> maybe a notepad keymap? =)
14:45:39 <dons> oh. that's an idea
14:45:43 <dons> don't have notepad though
14:45:45 <dons> simpletext?
14:45:47 <shapr> I think notepad has like six bindings
14:45:48 <dons> ;)
14:45:51 <shapr> sure, what's that?
14:45:54 <Riastradh> It contains two values: the current state and the 'main' value.
14:45:58 <shapr> anything simple
14:45:58 <dons> oh, sorry. flashbacks.
14:46:08 <dons> isn't nano simple?
14:46:08 <shapr> oh hey simpletext is macos?
14:46:15 <shapr> um, I guess so.
14:46:24 <shapr> sure looks simple if this is a full binding
14:46:35 <dons> which?
14:46:42 <shapr> the one in the repo
14:46:57 <dons> I think if most of vi can be expressed in 500 lines, then we're on to something
14:47:08 <dons> but only vi and vim use the nice lexers, atm
14:47:14 <shapr> surfing the wave of the future!
14:47:42 <Riastradh> The current state is implicit.  You don't operate on it with the standard monad operators; they simply preserve it.
14:47:46 * shapr pokes stepcut 
14:48:10 <dons> stepcut!!
14:48:17 * shapr snickers at the "-- stupido" comment
14:48:26 <boegel> all together now: stepcut !
14:48:26 <boegel> :p
14:48:29 <stepcut> shapr: the trick to getting a good emacs mode is figuring out how to support: tab completion, describe-key, remapping, and echo what you have typed so far in the message buffer
14:48:29 <Riastradh> The two state operators, put & get, return monadic values that operate on the state.
14:48:32 <wagle> argh..  extra batteries cost $129..
14:48:41 * wagle afk's
14:48:43 <shapr> stepcut: I'll take anything at all right now.
14:49:20 <stepcut> shapr: something like xedit, should be much easier though
14:49:31 <Riastradh> segphault, consider these definitions:
14:49:36 <stepcut> shapr: not that emacs is hard, it just requires time, and I have not had any :(
14:49:45 <dons> yep. that's true
14:49:47 <Riastradh> return value = \state -> (value, state)
14:49:50 <shapr> you sent me one before, did that use the lazy lexer?
14:49:51 <stepcut> once the core primatives for an emacs mode are in place, the rest is grunt work
14:50:09 <Riastradh> computation >>= function =
14:50:11 <Riastradh>   \state ->
14:50:17 <dons> shapr, stepcut: but don't we just need examples for the ctk stuff? is that the barrier?
14:50:20 <stepcut> that said, I think the current lazy lexer will make the emacs mode easier than the previous variations
14:50:32 <Riastradh>     let (value, state') = computation state
14:50:33 <dons> good. it was certainly true of the vim mode
14:50:45 <Riastradh>     in (function value) state'
14:51:01 <dons> xedit is scary
14:51:03 <Riastradh> segphault, even if you don't yet understand the theory behind these definitions, do you follow them?
14:51:06 <shapr> stepcut: which primitives?
14:51:45 <stepcut> dons: I think a very simple mode (everything static, no prefix commands, or reflection) + a complex mode like vim would be good enough..
14:51:45 <dons> hmm. maybe I can steal the line wrapping algo
14:51:48 <segphault> Riastradh: not entirely
14:52:12 <dons> stepcut: ok. good idea. i'll do a nano mode in that style
14:52:14 <musasabi> dons: you could do getevent.
14:52:23 <Riastradh> segphault, is there any part of the Haskell code that you don't understand in specific?
14:52:24 <musasabi> dons: but that would represent you with a problem:
14:52:32 <stepcut> shapr: well, primitives is perhaps not the right word -- but perhaps the core idioms and data structures
14:52:37 <shapr> ah
14:52:49 <dons> working out the state components?
14:52:56 <musasabi> either it returns even if no events are present => you loop and burn cpu, or it would block making yi loop hang.
14:53:10 <dons> no no. it runs in a thread, musasabi
14:53:12 <shapr> well, if you have time to make up a list of some of those core idioms and data structures, I'll work on them tomorrow after school.
14:53:33 <dons> musasabi: i'd like to use getcLoop ch = repeatM_ $ threadWaitRead 0 >> getcE >>= writeChan ch
14:53:43 <dons> where getcE is defined in terms of the ui
14:53:56 <dons> it can block all its wants, waiting for events
14:54:09 <dons> this is how we currently do ncurses events, and I think it will generalise
14:54:17 <dons> though all this talk of ui main loops was worrying me
14:54:41 <stepcut> shapr: rather than bind a lot of keys for emacs using a simple method, it would be better to figure out how to do everything you can do in emacs with a small subset of the total bindings so that you don't have to scrap to much later (but that is just how I work...)
14:54:46 <dons> of course, you wouldn't use threadWaitRead, you block on an mvar, say.
14:54:48 <stepcut> shapr: hold on, I can send you a very simple emacs like mode
14:54:53 <shapr> ok
14:54:56 <segphault> Riastradh: ok. I just copied all the pieces of the code and pasted them into an editor so I could get a better look at them. I think I understand the definitions
14:55:04 <shapr> you can just commit the simple emacs-like mode
14:55:08 <shapr> well, I mean...
14:55:21 <musasabi> hmm
14:55:24 <shapr> if it uses the ctk stuff, it'll be better than the non-working existing mode.
14:55:32 <stepcut> shapr: well, it is very simple, it only supports self-insert and ^N :p
14:55:51 <shapr> that's pretty simple
14:56:25 <shapr> still, it sounds god
14:56:27 <shapr> good
14:56:35 <dons> well, there's lots of new primops, which will make things easy
14:56:44 <dons> undo/redo, paragraph jumps etc
14:57:07 <dons> word completion
14:57:22 <shapr> btw, SASL sucks.
14:57:33 <shapr> simple authentication something
14:57:39 <musasabi> I think I will try how that works.
14:58:17 <dons> musasabi: just hack in your own definition of getcE, or better, UI.getKey
14:59:36 <dons> once I get a feel for how it will work, then I can start taking out secret ncurses assumptions
14:59:50 <stepcut> shapr: ok, I emailed you everything I have :)
15:00:00 <shapr> yay! I have a keymap!
15:00:35 <stepcut> shapr: your first challenge will be to support compound key combinations :)
15:00:44 <shapr> truly
15:01:04 <dons> stepcut: how do these work?
15:01:07 <musasabi> dons: does the current code run all GUI updates from one thread or multiple concurrent ones?
15:01:46 <stepcut> dons: compound key combinations ?
15:01:47 <dons> gui updates are invoked by the refresh thread, which waits on an mvar that is set when the editor state is modified
15:01:51 <dons> a single thread.
15:02:13 <dons> musasabi: refreshLoop in Core.hs
15:02:23 <dons> stepcut: yes. how do they work?
15:02:50 <stepcut> dons: I just meant stuff like, C-c C-x, or C-u 5 C-n, the code I sent shapr only supports single character commands write now (like C-n, C-p, etc)
15:02:50 <dons> is it like 7d3j in vi?
15:03:07 <stepcut> yeah, similar to 7d3j
15:03:15 <musasabi> hmm that makes things simple.
15:03:16 <dons> ok. yep. so we already have a strategy
15:03:30 <stepcut> except there is immediate interpretation of the keystrokes
15:03:54 <dons> right. so you can't use a regex. you must match char-at-a-time, and accumulate in the state
15:04:07 <dons> that's how I do numbers in vim, which require a msgE on each keypress
15:04:18 <stepcut> right
15:05:08 <stepcut> and some commands allow tab completion, which also means immediate intepretation of keystrokes 
15:05:15 <musasabi> dons: I promise to do something concrete before weekend.
15:05:15 <dons> musasabi: try to provide defns for the functions exported by Yi/Curses/UI.hs
15:05:19 <shapr> and there's always C-h
15:05:29 <dons> musasabi: oh, great! :)
15:05:46 <dons> stepcut: tab completion. hmm..
15:05:49 <shapr> stepcut: thanks, this is spiffy :-)
15:05:50 <stepcut> like, M-x do-something <RET>, does not actually do anything until you hit <RET>, but M-x do-som<TAB>, should tab complete if possible
15:06:18 <dons> so this is a bit like :ex mode.
15:06:19 <shapr> I'll hack in more keystrokes tomorrow and stare at the 7d3j code in the Vim mode.
15:06:49 <stepcut> shapr: right, there is C-h k, C-u, C-g, and dynamic key bindings, plus showing of stuff in the mini-buffer as you type
15:07:00 <shapr> and also things like C-c C-h
15:07:18 <shapr> which should show you what keystrokes are 'under' C-c and what they are
15:07:24 <stepcut> yeah
15:07:35 <shapr> ah, this should be fun =)
15:07:37 * shapr hops
15:07:44 <shapr> but first, sleep and swedish class
15:07:50 <stepcut> so, I think it might be smart to figure out how to support all those things before writing to many of the individual key bindings :)
15:08:22 <dons> yeah. working out the individual modes is useful
15:08:25 <stepcut> indeed, I think it would be quite fun, but I don't think I will have time to work on it till May :(
15:08:35 <dons> yikes
15:08:44 <shapr> I think I'll have time before then :-)
15:09:14 <shapr> anyway, g'night, I'll be back tomorra
15:09:34 <stepcut> currently, getting haskelldb to optimize away sub-queries rates as a higher priority for me 
15:09:50 <musasabi> stepcut: use a view?
15:09:54 <stepcut> because it need that to make money :)
15:10:10 <stepcut> musasabi: well, mysql 4.0 does not support views either I think
15:10:29 <stepcut> musasabi: but I have an documented algorithm for it, so it is just a matter of implementing it I hope
15:10:30 <musasabi> well mysql... :-(
15:10:46 <stepcut> musasabi: 4.1 supports sub-queries, but they are insanely slow
15:10:49 <musasabi> postgresql has supported them for many years ;)
15:11:06 <musasabi> who forces one to use a broken db.
15:11:11 <stepcut> same query with: join = 0.6s, application logic = 6.0s, sub-query = 10s !!
15:11:18 <Pseudonym> Depends what you call "broken".
15:11:25 <stepcut> musasabi: postgresql is broken differently
15:11:31 <Pseudonym> If by that you mean "doesn't implement a feature that you never use"...
15:11:42 <musasabi> stepcut: hmm?
15:12:12 <stepcut> When we used postgresql 3 yrs ago (yes, that is not the same as using it today), we had to take it offline for an hour/night to run some damn vacuum program
15:12:30 <musasabi> stepcut: you don't need to do that anymore.
15:12:45 <musasabi> stepcut: and 3 years ago mysql didn't have any foreign key support.
15:12:50 <stepcut> musasabi: indeed, I expect it is a lot better now
15:13:18 <Pseudonym> Bleah.  SQL is just plain broken.
15:13:21 <stepcut> musasabi: yep, things are changing, but in the past postgresql had more features, but mysql could take higher loads
15:13:36 <Pseudonym> 70s technology with 50s syntax.
15:13:38 <musasabi> Pseudonym: I couldn't agree more.
15:14:01 <musasabi> There seems to be no easy way of stuffing a string to a database.
15:14:05 <Pseudonym> Mind you, I hack Z39.50 for a living.  At least SQL was actually implemented before it was standardised.
15:14:13 <stepcut> are main db server usually does around 2000 queries/second, so high volume support and reliability was more important than subqueries, views, etc
15:14:27 <stepcut> s/are/our/
15:15:03 <stepcut> I suspect postgresql could do it today, but there is not a compelling reason to switch back
15:15:18 <stepcut> (and it is not my choice to make anyway :)
15:16:16 * stepcut goes out for treats
15:17:03 <stepcut> ...on the flip side, my personal database server does < 2000 queries per year ;)
15:18:12 <Pseudonym> Z39.50 is broken in strangely odd ways.
15:18:30 <Pseudonym> Most things are under-specified, optional or both.
15:18:39 <Pseudonym> Things are named inconsistently.
15:19:07 <Pseudonym> Those things which are adequately specified often don't _quite_ do what you need to get any useful information out...
15:19:15 <musasabi> Does haskelldb btw currently handle strings correctly?
15:19:27 <musasabi> I am thinking it didn't work in the past.
15:28:22 <Heffalump> is there a standard way of checking if a Rational can be expressed exactly as an Integer?
15:28:49 <Pseudonym> numerator r `mod` denominator r == 0?
15:29:06 <Pseudonym> Actually, denominator r == 1
15:29:25 <Pseudonym> Or can it be -1 too?
15:29:27 <Heffalump> those are guaranteed to be normalised?
15:29:33 <Heffalump> I don't care about negative numbers in this case.
15:29:45 <Pseudonym> Let me check the report.
15:29:54 <Heffalump> oh, if it's in that I can check it myself
15:29:58 <Heffalump> I just failed to spot it.
15:29:59 <Pseudonym> http://haskell.org/onlinereport/ratio.html
15:30:15 <Pseudonym> The functions numerator and denominator extract the components of a ratio; these are in reduced form with a positive denominator.
15:30:22 <Pseudonym> There you go.
15:30:45 <Heffalump> thanks.
15:40:41 <boegel> how can I use a function on each element of a tuple as I would sue 'map' on a list ?
15:41:37 <Heffalump> there's no generic way
15:41:43 <Heffalump> short of using Template Haskell or similar
15:41:44 <Lemmih> boegel: Use TH.
15:42:02 <boegel> Lemmih, what is TH?
15:42:07 <Heffalump> Template Haskell.
15:42:14 <boegel> okay, but what is it ? :)
15:42:26 <Lemmih> Meta programming.
15:42:33 <Heffalump> how familiar are you with Haskell in general?
15:42:43 <boegel> pff, I just want to test something :)
15:43:03 <Heffalump> ok, you don't want the hassle then.
15:43:07 <Heffalump> Just live without it :-)
15:44:13 <boegel> ;)
15:44:31 <boegel> it's weird something like that doesn't exist...
15:44:45 <Heffalump> not really, it's a consequence of the type system design
15:44:56 <Heffalump> you could write one for fixed tuple lengths
15:45:16 <resiak> boegel: You could use lists instead of tuples, if your logic allows, but I'm not sure if doing that might be Bad and Wrong.
15:45:16 <Heffalump> oh, actually, you could write one using a type class, too.
15:45:27 <Heffalump> But you'd have to make the instances for each tuple length manually.
15:45:27 <boegel> resiak, nevermind :)
15:45:31 <boegel> it's not worth the effort
15:46:13 <boegel> I've been looking on this bug in my raytracer forever... I'll show you guys an image of what's going wrong...
15:47:37 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website/forever.jpg
15:47:47 <boegel> the inner sphere is transparent
15:48:06 <boegel> but the spheres behind it are mirrored for some reason, and I can't figure out why
15:49:10 <wolfman8k> boegel: what's up
15:49:46 <boegel> wolfman8k, have you seen the image ?
15:51:26 <wolfman8k> boegel: looks good
15:51:48 <boegel> wolfman8k, the blue and red colors shouldn't be mirrored ???
15:52:33 <wolfman8k> is that a glass ball?
15:52:36 <boegel> i've set the refraction index to 1, so there should be _no_ refraction
15:52:54 <boegel> wolfman8k, even if it is, it's not right is it ?
15:54:00 <wolfman8k> hm...
15:54:10 <wolfman8k> i'm too tired
15:54:37 <boegel> the ratio that is used in the calculation of the transmitted ray, which is provided by Shell's Law, I've set that to 1, just for testing purposes
15:55:06 <boegel> so if I'm right, there should be no refraction then, right ?
15:56:32 <boegel> wolfman8k, can you give me a website where some of those refraction indices are listed ?
15:56:55 <wolfman8k> like for different materials?
15:57:20 <boegel> wolfman8k, yes
15:57:21 <wolfman8k> i think water is 1.3 or something. or maybe 1.5
15:57:57 <wolfman8k> dunno man
15:58:00 <boegel> so I should do 1/1.3 to get the deflection index, righ ?
15:58:08 <wolfman8k> i personally would just stay away from refraction... it's so.... 1970s :)
15:58:23 <boegel> wolfman8k, it part of the strong points of a raytracer :
15:58:25 <boegel> :)
15:58:40 <boegel> and it's probably the last thing I'll implement on it
15:58:49 <boegel> besides some new object-types then
15:59:40 <boegel> wolfman8k, have you seen my progress ?
16:00:03 <wolfman8k> no, i've been on vacation
16:00:16 <wolfman8k> maybe this link will help you if you haven't already seen it: http://www.flipcode.com/articles/article_raytrace03.shtml
16:01:59 <boegel> wolfman8k, some other indices: http://studwww.ugent.be/~kehoste/thesisPublic/website/forever_refrIndex0.8.jpg and http://studwww.ugent.be/~kehoste/thesisPublic/website/forever_refrIndex0.9.jpg
16:02:10 <boegel> the refraction looks right, but it's still mirrored
16:02:53 <boegel> wolfman8k, thanks for the link, that might help me
16:03:30 <wolfman8k> hm.... it might be the drugs... but i think that refraction indices are supposed to be equal to or greater then 1
16:04:15 <boegel> wolfman8k, it depends which direction you're looking at
16:04:33 <boegel> air -> water < 1, water -> air > 1
16:04:55 <wolfman8k> oh yeah
16:04:55 <boegel> because 1/1.3 (air->water) and 1.3/1 (water->air)
16:05:33 <wolfman8k> but the individual indices are 1 or greater
16:05:58 <wolfman8k> in the naming of your images, you used 0.8 and 0.8, i thought that it might potentially mean the index you were using for the sphere material
16:07:15 <boegel> wolfman8k, no, it's the 'total' index
16:07:37 <boegel> it will be a stupid bug, I don't doubt it, but I don't see what I'm doing wrong
16:08:02 <boegel> wolfman8k, http://studwww.ugent.be/~kehoste/thesisPublic/website, to see some of my progress
16:08:41 <boegel> you made some really cool scenes with your raytracer, with all the spheres in it... can you show me how to place them and how many spheres I should use ?
16:09:35 <wolfman8k> nice
16:09:41 <wolfman8k> one sec...
16:10:54 <wolfman8k> you mean this one?
16:10:55 <wolfman8k> http://img49.exs.cx/img49/8617/haskell-raytrace-09.png
16:12:19 <boegel> yes
16:14:41 <wolfman8k> ok, here are how the spheres are positioned:
16:15:04 <boegel> how long did the render take ?
16:15:21 <Lemmih> Wow. a is still unused if it's used by an unused function.
16:15:29 <wolfman8k> boegel: about 1 minute
16:15:57 <boegel> that's fast :) what resolution ?
16:16:19 <wolfman8k> here's the geometry:
16:16:20 <wolfman8k> http://rafb.net/paste/results/wT5U4L84.html
16:16:27 <wolfman8k> 1024x768
16:17:51 <wolfman8k> actually, it's probably closer to 2 minutes
16:18:07 <boegel> okay, let me try that :)
16:20:07 <boegel> wolfman8k, I don't think I'll will get those insane colors...
16:20:24 <boegel> oh, you used colored lights... then I might ;)
16:21:35 <wolfman8k> my raytracer uses "high dynamic range colors"
16:22:09 <wolfman8k> colors aren't clamped to a maximum value. they can be as bright as you want them to be
16:22:50 <musasabi> pretty pictures ^_^
16:23:45 <boegel> wolfman8k, but what if they reach (1,1,1) ?
16:23:47 <wolfman8k> and i think my metal shader is incorrect. it might be adding extra light energy
16:24:14 <wolfman8k> boegel: i just use Double for the r,g,b elements of the color
16:24:23 <boegel> wolfman8k, so do I
16:24:43 <boegel> but I clip each channel down to 1, so my PPM file is correct
16:25:06 <wolfman8k> for final image output, i clamp the values, but the cool thing is that you can adjust the exposure before doing this :)
16:25:08 <boegel> wolfman8k, I don't have a metal shader, i just use diffuse and specular... will that make a difference ?
16:25:25 <boegel> wolfman8k, adjust the exposure ? how do you mean ?
16:25:39 <wolfman8k> my "metal shader" basicly just does diffuse + reflection
16:25:44 <wolfman8k> i didn't add specular yet
16:26:02 <boegel> wolfman8k, oh, ok
16:26:02 <wolfman8k> boegel: multiply the final image by an exposure constant
16:26:37 <wolfman8k> i'm gonna try adding depth of field soon maybe
16:30:44 <boegel> I hope I can get my refraction working soon...
16:32:19 <boegel> I've been working an that stupid bug for 2 days now :@
16:32:54 <boegel> wolfman8k, you have no limit on recursion depth, right ?
16:33:04 <wolfman8k> that's correct
16:33:09 <wolfman8k> i'm not sure how to set a limit
16:33:56 <boegel> just add an extra argument to your raytrace function, and subtract 1 on every recursion...
16:34:19 <boegel> my colors aren't as nifty as your are... :(
16:34:34 <boegel> the lights, you give the a (4,0,0) color, how does that work ?
16:35:52 <wolfman8k> i played around and that gave pretty results :)
16:36:16 <wolfman8k> only problem is that the extra argument adds a bit of nasty syntax
16:36:24 <wolfman8k> maybe i should use a monad or something
16:39:14 <musasabi> What do you want to do if you reach the recursion limit?
16:39:25 <musasabi> Abort or save current result?
16:39:30 <boegel> musasabi, return (0,0,0) as resulting color
16:40:23 <boegel> musasabi, if you reach the limit, no error has occured or something... if you set the limit high enough, you won't see any difference in the resulting image
16:40:44 <musasabi> boegel: why not just send async exceptions with a timer?
16:41:04 <musasabi> I would try that out, it could be worse too.
16:41:26 <boegel> musasabi, why would i use exceptions, when there none :)
16:41:52 <boegel> it's like a basic case... returning (0,0,0) as resulting color for that recursion step doesn't harm the image
16:42:02 <boegel> hey Cale 
16:42:12 <Cale> hello
16:42:55 <musasabi> boegel: because that would eliminate the extra bookkeeping with recursion depth.
16:45:51 <wagle> its been awhile since i took a raytracing class, but shouldnt you return no color at all (Nothing :: Maybe Color) if you run out of recursion (reflections?)
16:46:41 <wagle> otherwise, you contaminate your samples with Black = (0,0,0)?
16:50:22 <wagle> (or am i fos?)
16:55:29 <masm> What is the fastest way to implement cat command in haskell? (read from stdin and write to stdout)
16:56:36 <musasabi> getContents >>= putStr
16:56:44 <musasabi> that is the shortest/
16:56:48 <wagle> oooooo
16:57:01 <musasabi> masm: you want to look at the cryp.to binary io library.
16:57:15 <musasabi> or use a c wrapper if you want the most performance.
16:57:50 <musasabi> (I had some code doing sendfile/buffered read/write which was very fast)
16:57:56 <wagle> one quick improvement is not to read one char at a time
16:58:20 <wagle> is there a recvfile yet?
16:59:01 <wolfman8k> Cale: hi!
16:59:06 <Cale> hello
16:59:14 <wolfman8k> i'm back! you are back!
16:59:15 <jadrian> musasabi: isn't getContents for reading stdin?
16:59:17 <wolfman8k> do you remember me?
16:59:29 <Cale> yep
16:59:33 <wagle> jadrian: he asked for stdin
16:59:37 <jadrian> oh
16:59:48 <jadrian> I just read he wanted a "cat"
17:00:21 <wolfman8k> Cale: did you see my latest code with the flexible shader system?
17:00:37 <Cale> I'm afraid I haven't had too much time to work on the raytracer. I started some nicely abstract stuff, but didn't get it quite to the part where it would run before being inundated with assignments.
17:00:58 <Cale> I think so -- at least I saw something along those lines.
17:01:24 <wolfman8k> i just got back from a 3 week vacation
17:06:55 <masm> musasabi: That's block io in cryp.to, right? I can't find binary io there.
17:07:28 <musasabi> yes.
17:08:17 <wolfman8k> i have a question about haskell compiler optimization potential
17:08:24 <wolfman8k> let's say i have a function add x y = x + y
17:08:38 <wolfman8k> and then i have a function
17:09:05 <wolfman8k> double x = add x x
17:09:53 <wolfman8k> and then i have a function: f x = (double x) + (x + x)
17:10:42 <wolfman8k> can the compiler potentially "unfold" the double function call, and then do like the (x + x) evaluation only once in the f function instead of twice?
17:10:50 <wolfman8k> or am i not making any sense :|
17:10:52 <Lemmih> wolfman8k: You can compile it and look at the external code.
17:11:19 <Lemmih> s/code/core/
17:11:29 <wolfman8k> hm...
17:11:32 <Cale> wolfman8k: I see no reason why that couldn't happen.
17:11:34 <arjanb> i would be surprised if the haskell compiler did this..
17:11:52 <wagle> cse
17:12:05 <wagle> nm
17:12:06 <Lemmih> Aren't such small functions supposed to be inlined?
17:12:18 <wagle> i'm sure it inlines
17:12:33 <wagle> (with sufficient -O energy)
17:12:34 <wolfman8k> i'm thinking about functions that aren't small though
17:13:27 <wolfman8k> i have functions f and g, both evaluate the same expression, and then combine that with something else for the final result
17:13:40 <wagle> its going to have a heuristic about when to start avoiding the undecidability of equality
17:13:53 <wolfman8k> but if i make a function that combines the results from f and g, then will the expression be computed twice redundantly?
17:14:15 <wagle> and that heuristic is going to change when the compiler is patched, etc
17:14:54 <wagle> disassemble the binary to see what the compiler is doing today..
17:15:28 <wolfman8k> this may sound stupid, but can't the compiler just
17:15:50 <wolfman8k> when it compiles a single function
17:16:12 <wolfman8k> inline all of the functions inside it and inside those into one big evaluation tree
17:16:22 <wagle> i'm ignorant of whether the current compiler is tied to some specification of what its required to do..
17:16:33 <wolfman8k> i'm just sort of curious
17:16:50 <wolfman8k> then it just looks for duplicate expressions
17:17:10 <wolfman8k> seems like it should be pretty simple
17:17:11 <wagle> in one future life, i produce a compiler where you can demand that it do such things, but i hadnt even done a litsearch on the state of the art yet
17:18:07 <wagle> i know that it does some recognition of common subexpressions..  i just dont know when it gives up checking equality
17:18:14 <wolfman8k> it just seems that just because it's *possible* to do this kind of optimization then it's really sweet, since you could never do such optimizations in something like C, since the compiler must stay close to the code
17:18:45 <wagle> umm..  i think the C people do do this sort of thing
17:18:59 <wolfman8k> i doubt it
17:19:15 <np_hard> are strict folds in a library somewhere?
17:19:28 <wagle> they think in terms that would permit this
17:19:33 <Pseudonym> wolfman8k: Do you know what is meant by "strong laziness"?
17:20:05 <wolfman8k> Pseudonym: it means that evaluation will never happen unless it's absolutely required?
17:20:19 <Pseudonym> No, that's just laziness.
17:20:32 <Pseudonym> Strong laziness also imposes the guarantee that when evaluation happens, it will happen only once.
17:20:44 <wagle> do do anything, ever.  period.  8)
17:20:49 <Pseudonym> Haskell doesn't require that guarantee.
17:20:56 <Pseudonym> Though all Haskell compilers provide it.
17:21:01 <Pseudonym> (Though GHC doesn't with -O0, I believe.)
17:21:27 <np_hard> strict folds?
17:21:41 <Pseudonym> Looking at your example:
17:21:47 <Pseudonym> f x = (double x) + (x+x)
17:22:03 <Pseudonym> Uhm... is that what you meant?
17:22:14 <wolfman8k> here's a better example:
17:22:27 <wolfman8k> f x = (complex x) * 2
17:22:31 <Pseudonym> OK.
17:22:33 <wolfman8k> g x = (complex x) * 3
17:22:43 <wolfman8k> foo x = (f x) + (g x)
17:22:45 <wagle> the man question appears to be how f' x = (x + x) + (x + x) is optimized
17:22:54 <wagle> s/man/main/
17:23:01 <Pseudonym> OK, no, it won't do that transformation.
17:23:05 <Pseudonym> And there's a good reason for it.
17:23:25 <Pseudonym> Consider this:
17:23:28 <Pseudonym> powerset [] = [[]]
17:23:42 <Pseudonym> powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
17:24:17 <Pseudonym> If you shared the recursive call to (powerset xs), then this function would eat up all available memory for any decent sized input list.
17:24:30 <Pseudonym> Try it and see:
17:24:44 <Pseudonym> powerset (x:xs) = let psxs = powerset xs in psxs ++ map (x:) psxs
17:25:06 <Pseudonym> By _not_ sharing the recursive call, it doesn't eat up memory.
17:25:46 <wolfman8k> hm... in theory though, those 2 lines should produce identical results though, right?
17:25:50 <Pseudonym> Right.
17:26:03 <Pseudonym> This is the difference between semantics and pragmatics.
17:26:07 <wolfman8k> shouldn't the compiler figure out the best thing to do in both cases?
17:26:09 <wolfman8k> i see
17:26:12 <wolfman8k> hm...
17:26:17 <Pseudonym> Well, yeah.
17:26:25 <wolfman8k> i mean, shouldn't the compiler figure out that both cases are the same even?
17:26:33 <wagle> it might be able to grok the space behavior of powerset
17:26:47 <Pseudonym> In practice, the best way seems to be to analyse the type.
17:26:56 <Pseudonym> If what you're sharing is a Double, then its space is bounded.
17:27:02 <Pseudonym> If what you're sharing is a list, then it's not.
17:27:15 <wolfman8k> i thought that "let" was just "syntax sugar" :/
17:27:34 <Pseudonym> So you could automatically abstract the common subexpression if you can prove that the size of the subexpression is bounded.
17:27:38 <Pseudonym> How here's the catch.
17:27:43 <Pseudonym> For Double, the size is bounded.
17:27:46 <Pseudonym> But for Integer, it's not.
17:27:58 <jadrian> I want to lookup an element in a FiniteMap
17:28:28 <jadrian> I want to lookup an element in a FiniteMap, and if it satisfies p, then I want to "change it"
17:28:53 <jadrian> looking at the primmitives seems like I have to do 2 traversals, right?
17:29:01 <jadrian> one to fetch the element
17:29:13 <jadrian> and another one to produce the new FiniteMap
17:29:30 <jadrian> or am I wrong?
17:29:39 <wolfman8k> Pseudonym: so your saying that in all haskell compilers you know, the foo function will compute the result of "complex x" twice?
17:29:44 <Riastradh> You are wrong.  See FiniteMap.adjustFM, if I remember the name correctly.
17:29:53 <jadrian> thanks
17:30:02 <Pseudonym> wolfman8k: RIght.
17:30:07 <wolfman8k> Pseudonym: ok thanks man
17:30:15 <Pseudonym> And there are good reasons why.
17:30:21 <Pseudonym> Incidentally...
17:30:24 <Pseudonym> http://haskell.org/hawiki/LambdaLifting
17:30:31 <Pseudonym> There's some stuff in there that's relevant.
17:31:25 <jadrian> Riastradh: can't find anything similar...
17:31:49 <wolfman8k> Pseudonym: hm... that stuff is above my level :\
17:32:49 <Riastradh> Oops.  I'm thinking of the Map module from DData.
17:32:58 <jadrian> Riastradh: oh
17:33:00 <Pseudonym> Yeah, there's something similar in Edison, too.
17:33:04 <Riastradh> (where the function you really want is Map.update)
17:33:06 <Pseudonym> I'd ask for it to be added.
17:33:15 <Riastradh> Well, there _ought_ to be such a function in FiniteMap, or you could just use DData or Edison.
17:33:16 <Pseudonym> Seems useful enough.
17:33:32 <jadrian> argh... 
17:33:53 <jadrian> can't afford to spend time changing my code now... guess I'll just do it in two steps for now
17:34:02 <jadrian> thanks for the tips
17:35:13 <wagle> anyone know what "the 1-ambiguity property" is? (wrt parsing xml)
17:35:35 <Shammah> can anyone explain to me the distiction between an 'algebra' and a 'calculus'?
17:36:20 <jadrian> Riastradh: Pseudonym: DData.updateLookupWithKey  <-- this is what I wanted 
17:36:46 <jadrian> Riastradh: look up and at the same time update it
17:37:13 <jadrian> I might have mappings like:
17:37:21 <jadrian> [a->b, b->c, c->d]
17:37:36 <wolfman8k> haskell's laziness requirements seem to cause lots of problems for performance :|
17:37:44 <jadrian> and my mappings are transitive
17:37:54 <jadrian> so that is the same as 
17:37:59 <jadrian> [a->d, b->d, c->d]
17:38:28 <wagle> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=calculus&x=15&y=15
17:38:28 <jadrian> so my ideia was to make the binding sequences shorter when looking up 
17:39:03 <dons> oh, laziness isn't so bad. there are plenty of nice, fast haskell programs. it's useful to use -prof -auto-all in ghc to see what's going on, though..
17:39:17 <jadrian> since I don't wanna change my datatypes now, I guess I'll just return a list with the elements to be updated 
17:39:39 <wagle> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=algebra&x=15&y=15
17:39:40 <jadrian> and then do it in the end...
17:39:53 <Riastradh> Pseudonym, hmmm, I just read your explanation above of why such common subexpression elimination is a bad idea, but I don't quite understand why it would eat up so much memory.
17:40:00 <wagle> Shammah: those two urls
17:40:53 <Pseudonym> Well, what is length (powerset [1..n])?
17:41:03 <Riastradh> 2^n
17:41:06 <Pseudonym> Right.
17:41:18 <Pseudonym> So suppose n is, say, 32.  On a 32-bit machine.
17:41:37 <Pseudonym> powerset [1..n] calls powerset [2..n] recursively.
17:41:46 <Riastradh> That obviously wouldn't work very well.
17:41:48 <Riastradh> Yes...
17:41:53 <Pseudonym> Right.
17:42:11 <Pseudonym> Now if it doesn't have to remember what powerset [2..n] is between the first call and the second call, everything is okay.
17:42:33 <Pseudonym> You can do (powerset [1..32]) !! 100000 and it works.
17:42:36 <wagle> "l ++ _" copies l
17:43:12 <Riastradh> Oh, I see now.
17:43:21 <Pseudonym> It might take a while to do (powerset [1..32]) !! (2^32 - 2), of course.
17:43:56 <Pseudonym> But it'll only take O(n) transitive space rather than O(2^n).
17:44:13 <Pseudonym> Yes, lazy evaluation has unexpected consequences when it comes to space usage.
17:44:28 <Riastradh> And people are frequently too lazy to figure them out.
17:44:40 <wolfman8k> Pseudonym: do you think that an advanced compiler would be able to figure out that it's possible to evaluate "complex x" only once in some situations?
17:44:54 <Pseudonym> wolfman8k: Sure.
17:45:11 <Pseudonym> And to be fair, you can do better than just analysing the type.
17:45:12 <np_hard> hmm, they lazily evaluate lazy evaluation?
17:45:35 <wolfman8k> Pseudonym: do you know if anyone is working on compiler optimizations like these?
17:45:35 <Pseudonym> This isn't a huge problem in practice because people generally don't write powerset.
17:46:28 <Pseudonym> wolfman8k: No idea.
17:46:40 <Pseudonym> But asking Google about "shape analysis" might return a hit.
17:46:47 <wolfman8k> cool thanks
17:50:21 <Shammah> wagle: a start.  Any clarification on the distinction between a calculation and an operation?
17:52:36 <wagle> Shammah: i found the dictionary definition far less satisfying than i expected
17:52:53 <wagle> i think i know, but...
17:54:46 <wagle> i keep meaning to figure out what "computation" _IS_ in general, buy never get around to it..  i've been hoping that reading feynman's stuff on computation might give me more clarification...
17:56:23 <wagle> i wonder if computation (calculation) is more "directed", "goal/result oriented"
17:56:28 <Shammah> wagle: I'm currently reading around abstract algebra, but can't seem to find an analagous abstract calculus.
17:56:57 <wagle> proof theory?
17:57:49 <Shammah> wagle: that's the current theory floating around here amongst those of us trying to clarify the distinction (goal/result/simplifcation orientation)
17:57:54 <wagle> math seems to like avoiding the notion of time / evolving-systems
17:58:00 <Shammah> maybe, don't know any proof theory.
17:59:26 <wagle> most (classical?) notions of computation seem tied to some sort of proof technology
18:01:21 <wagle> i was amazed when i saw that process calculi (and chemical abstract machines) were "just" resolution provers
18:01:42 <wagle> (my vocabulary is off)
18:02:22 <wagle> (when i took a course on symbolic AI, doing a bunch of different sorts of provers, planners, etc)
18:03:24 <wagle> but recall that turing machines appears as a response to hilbert's programme to formalize "mathematics" (logic)
18:03:44 <Shammah> indeed.
18:04:43 <Shammah> although while I am familar with the existence of process algebra, I haven't come across process calculi.
18:04:48 <wagle> i think undecidability is that "not all true propositions have finite proofs"
18:06:19 * wagle googles and finds "_Algebraic_ Process _Calculi_"  8)
18:08:23 <wagle> hmm..  my common usage appears to be an algebra is pure math, worthy of direct study, whereas a calculus is something i use to achieve some sort of answer/result aboutg the target domain of the calculus
18:13:46 <wagle> calculi seem more operational in orientation...
18:15:01 <jadrian> wagle: yeap
18:16:01 <jadrian> wagle: and I won't start rambling again, but IMO that has much to do with the way algebra and calculus teaching has evolved, and someday someone will have to do something about it
18:16:40 <jadrian> wagle: calculus has been dumbed down and packaged and people can start learning it soon and using it
18:16:52 <jadrian> wagle: not algebra...
18:17:54 <jadrian> When I studied neural networks among a few motives pointed for its success over symbolic AI at that time
18:18:28 <jadrian> was that engineers were confortable with the math of it
18:18:44 <jadrian> so applications soon appeared
18:20:41 <jadrian> so there seems to be a kind of vicious cicle here... 
18:20:47 * jadrian shuts up 
18:37:35 <Cale> Calculus by its very nature is a method of calculating (hence the name). If you want the general, abstract version, it tends to get called Analysis.
18:40:04 <Cale> There are computational methods in some areas of Algebra as well, but Algebra by its very nature is not so easy to package in the way that you mentioned. It consists of a bunch of abstractions, and the interconnections between them.
18:41:42 <Cale> Packaging it up into non-abstract facts will increase its size in an unreasonable way, because the statements made are often of a very general nature.
18:44:50 <jadrian> Cale: I'm not so sure about that
18:45:11 <jadrian> Cale: because Analysis is quite general too
18:45:26 <jadrian> Cale: (yes algebra is more abstract)
18:46:20 <jadrian> Cale: but when you teach Calculus you don't explore the whole thing
18:46:44 <Cale> yeah, that's true -- it's just a small useful bit of analysis on R^n
18:47:10 <Cale> However, I'm somewhat opposed to that style of teaching.
18:47:22 <jadrian> identifying the "important" algebraic stuff and packaging it is probably possible
18:47:27 <jadrian> well me too
18:47:31 <Cale> Mathematics tends to actually become more difficult to learn as it is watered down.
18:47:39 <jadrian> yeap
18:47:57 <jadrian> actually I'm teaching calculus right now
18:47:57 <Pseudonym> Like most things, you have to do a V-cycle.
18:48:15 <jadrian> and sometimes I feel really bad because of the way we teach it...
18:48:23 <Pseudonym> You have to start off watered down, and build up until you can get to the point wher eyou can understand the unifying factors.
18:49:24 <jadrian> but yes, that's what is very well done in calculus education
18:49:34 <Cale> Well, I don't think you have to start off watered down -- I'd say instead that you should start off concrete, and move to the abstract.
18:49:42 <jadrian> it beins in high school
18:49:47 <jadrian> begins*
18:50:01 <Cale> but I think it's important in mathematics to prove the results which are claimed
18:50:06 <jadrian> with intuitive concepts in a restritive domain
18:50:14 <jadrian> well me too
18:50:42 <jadrian> and I also think that in many cases calculus teaching has gone too far
18:51:03 <Cale> Proving things enforces a particular logical flow to everything, and people learn better with that there.
18:51:04 <jadrian> at grad level I mean
18:52:00 <jadrian> and I don't think the curent state of affairs (at least in here) the that good in calculus teaching, it can be to watered down
18:52:17 <jadrian> but when teaching non-math courses
18:52:26 <jadrian> courses that want to use it as a tool
18:52:34 <jadrian> there as to be a compromise
18:52:45 <jadrian> but it's about much more than that, forget grad level
18:52:53 <jadrian> think of high-school level teaching
18:53:59 <jadrian> when a student goes to college he already has some good foundations and intutions in the domain of calculus
18:54:58 * jadrian has got to get some sleep
18:55:12 <jadrian> bye!
18:58:20 <Shammah> So can we describe what feature/property makes first-order predicate logic a calculus and not an algebra?
18:59:33 <Cale> Shammah: It's not an abstraction of something else, and it gives effective computational rules for things.
19:00:22 <Shammah> Cale: and boolean algebra is an 'abstraction of something else'?
19:01:22 <Cale> indeed -- the notion of a boolean algebra can be instantiated in a lot of ways
19:11:20 <Leimy> asmodai: ???
19:28:56 <stepcut> hrm, what is the best way to turn a Word8 into a two character ascii hex representation, aka 15 -> "0F"
19:30:45 <stepcut> some form of intToDigit and shiftR I suppose..
19:31:57 <dons> you could look at Numeric.showHex
19:32:19 <stepcut> showHex does not appear to pad with 0 i think
19:32:26 <dons> nope.
19:32:42 <dons> pretty easy to adjust, though
19:33:02 <stepcut> ah, I see
19:33:14 <stepcut> showHex = showIntAtBase 16 intToDigit
19:33:58 <stepcut> hrm, showIntAtBase is a bit wacky, I think a custom function will be easier to do 
19:34:59 <dons> case Numeric.showHex (127 :: Word8) "" of { [c] -> '0':[c] ; cs -> cs } ?
19:35:13 <dons> or do we have stricter requirements?
19:35:30 <stepcut> no, that would probably do it
19:36:12 <dons> map Char.toUpper too, probably
19:39:01 <stepcut> \w -> [ intToDigit ((w `shiftR` 4) .&. 0xf) , intToDigit (w .&. 0xf) ]
19:39:08 <stepcut> I wonder which is faster
19:40:42 <dons> hmm. I wonder ;)
19:40:58 <stepcut> I might be encoding as many as 160 characters, so speed is *very* important ;)
19:41:15 <dons> 160! oh my ;)
19:41:37 <stepcut> perhaps dozens of times per day!
19:41:54 <dons> for real speed, do something like:
19:41:55 <dons>         return (I# (word2Int#
19:41:56 <dons>              ((int2Word# i `and#` int2Word# 0xffff#) `remWord#` int2Word# 52#)))
19:42:16 <dons> that turns into & % etc. in the C backend
19:42:21 <stepcut> heh
19:42:39 <dons> whereas .&. is still mostly going to be a function call
19:42:52 <dons> but you can always -ddump-absC to see what's happening ;)
19:43:03 <dons> the above code is for making random files names in yi.
19:43:08 <stepcut> heh
19:43:12 <dons> which must happen, what?, twice a day??
19:43:20 <dons> so speed is crucial..
19:43:43 <Riastradh> Whoa.  That code looks too slow for that frequency.  You'd better bum it further.
19:43:45 <dons> int2Word# ~~> (StgWord)i;
19:44:18 <dons> i'm not sure if I can get it faster, other than writing an .asm stub file
19:44:27 <dons> it's only 3 C stmts
19:44:44 <Riastradh> In-line assembly!
19:44:45 <stepcut> heh
19:44:59 <stepcut> dons: maybe you could precalculate the answer ;)
19:45:02 <Riastradh> That would really beautify Haskell code, I'm sure!
19:45:11 <dons> inline asm:; you could do that. write a Word8 array, and use some low-level op to jump to it.
19:45:29 <dons> jump _in to_ it, I mean
19:45:49 * dons goes snooping...
19:45:58 <dons> and wonders about next year's ohcc
19:47:00 <dons> now, can we do it some way other than importing TailCalls.h
19:48:21 <stepcut> import BootyCalls
19:49:09 <dons> looks like we  don't have a goto primop :{
19:49:17 <stepcut> !
19:49:28 <dons> well, it's an ffi call then
19:49:57 <stepcut> maybe I will have to cabalize hlist
19:50:20 <dons> that'd be nice
19:50:31 <dons> people would have to use it
19:50:32 <stepcut> indeed, I am addicted to hlist at the momment :)
19:51:16 <dons> we could do inline asm if we had a GHC-backend TH.
19:51:28 <dons> so you could  have #defines that only get spliced after code generation
19:51:30 <stepcut> scary
19:51:30 <dons> hmm..
19:54:02 <dons> I think inline asm is a worthy obfuscated haskell goal.
19:54:08 * dons adds it to the todo list
19:54:51 <stepcut> just imagine haskellp4 + GHC-backend TH+inline asm
19:55:44 <dons> yeah!
19:56:12 <dons> I guess you could use normal TH to generate backend-TH
19:56:29 <dons> or maybe generate some RULES pragmas, that in turn produce backend-TH
19:57:54 <Riastradh> But don't forget to mix in some plain old obfuscated Haskell, too.
20:02:59 <stepcut> cripe, I could use some template haskell right now, except it would take me 10x as long to remember how to use it as it would to just copy and paste :)
20:28:40 <stepcut> ack! too many type class, my poor dev box only has 128 MB of ram :(
21:56:13 <cm> :]
22:08:08 <asmodai> Leimy: :P
22:25:39 <tuomov> dons: ping?
22:27:41 <dons> heya
22:28:43 <tuomov> I'm trying to do something like   'if regexp_set then searchE Nothing else querySearchRepE'
22:28:50 <tuomov> but this does not seem possible
22:29:29 <tuomov> The rest of the action stream can't depend on the results of getRegexE; only the currently constructed action
22:29:34 <tuomov> or so it would seem to me
22:29:55 <dons> if there was a previous regex, then search, otherwise ask for a new regex string? is that what the above says?
22:30:03 <tuomov> yes
22:30:12 <dons> ok. we've got code for that.
22:30:42 <Spark> we get signal
22:30:47 <dons> searchE Nothing will reuse the previous pattern
22:31:06 <tuomov> but if there is no pattern, I want the same key to query for one
22:31:12 <dons> searchE (Just pat) will compile and use a new pattern
22:31:37 <dons> the same key. ok. let me think
22:32:14 <dons> so why doesn't getRegexE work?
22:32:34 <tuomov> I can get the pattern with it.. but the rest of the stream can't depend on the result, only the currently constructed action?
22:32:54 <dons> but you can have a side effect ...
22:33:28 <dons> the rest of the stream is modifed by the value stored in the editor state
22:33:52 <tuomov> The editor state can't depend on the result of getRegexE
22:34:29 <tuomov> only the input Char stream
22:34:43 <tuomov> s/editor/keymap/
22:34:44 <dons> what about, say, yank buffers?
22:34:55 <dons> it's the same situation.
22:35:27 <dons> anyway, how about: do v <- getRegexE ; case v of Nothing -> searchE Nothing; Just _ -> searchE (Just ..)
22:35:44 <tuomov> the problem is obtaining ..
22:35:45 <dons> hmm. where the snd Just is the string represented by the regex in getRegexE. hmm.
22:36:01 <tuomov> I wrote
22:36:03 <dons> so we need to store both  the compiled, and uncompiled forms in the regex reg
22:36:06 <tuomov>     getRegexE >>= \e -> case e of
22:36:06 <tuomov>         Nothing -> querySearchRepE cont cs
22:36:06 <tuomov>         Just _ -> (searchE Nothing):(cont cs)
22:36:10 <tuomov> but it can't work
22:36:46 <dons> side-effecting actions need to get Core.hs support.
22:37:01 <dons> that's awkward.
22:37:05 <dons> but maybe not a bad thing
22:37:44 <dons> hang on .. why can't it work?
22:38:06 <dons> it will searchE using whatever the current compiled regex is. seems ok.
22:38:13 <tuomov> querySearchRepE depends on the rest of the input stream, but getRegexE can only affect the currently constructed action
22:38:36 <dons> oh. urgh. you want to ask a question in querySearchRepE ?
22:38:41 <tuomov> querySearchRepE cont cs =
22:38:41 <tuomov>     query "Search term: " [] qflags cont cs
22:38:41 <tuomov>     where
22:38:41 <tuomov>         flagprompt = "(I)gnore, (R)eplace, (B)ackward Reg.E(x)p? "
22:38:44 <tuomov> etc.
22:38:53 <dons> ok. so that's a mode switch.
22:39:02 <tuomov> essentially yes
22:39:13 <dons> this is interesting.
22:39:33 <dons> I'm not sure if you can trigger a mode switch based on the outcome of an actoin
22:39:36 <tuomov> it first queries for what to search, and the for flags
22:39:41 <tuomov> dons: that's what I noticed too
22:39:55 <dons> yeah. I get it now :) so what to do.. hmm
22:40:34 <dons> if you have a regex string stored in _the lexer state_ then you might be ok
22:40:45 <dons> hmm. but it's pure. problem.
22:41:01 <tuomov> but the lexer is buffer/window specific?
22:41:03 <dons> no no. that might be alright.
22:41:06 <dons> yep.
22:41:11 <dons> no no. sorry. it's not
22:41:24 <dons> but neither is the regex pattern atm.
22:41:29 <dons> they both will be eventually
22:42:09 <dons> what char triggers the regex lexer code?
22:42:31 <tuomov> eh?
22:42:55 <tuomov> I can just push the changes. Moment..
22:43:52 <dons> char '/' `meta` \_ st -> case st of "" -> askquestionmode ; _ -> (Just .. searchE Nothing
22:43:55 <tuomov> hmm.. there's no address in the repo?
22:44:08 <dons> oh. must have got wiped at some point
22:44:52 <dons> anyway, store your own regex in the lexer state, and use a meta action to inspect it, branching to a different lexer mode if []
22:45:08 <tuomov> I could do that, but the keymap gets awfully complex..
22:45:41 <dons> I think if you look at the C code for the equivalent, it'll be complex too ;)
22:46:07 <dons> I can't think of an obvious way for an action to cause a mode switch
22:46:37 <dons> have a look at the new Nano mode, it stores a filename,prompt triple in a certain mode
22:47:22 <dons> and the keymap shouldn't get too complex. just use a `meta` instead of an `action`
22:47:36 <dons> for the specific binding you need
22:47:54 <musasabi> morning
22:47:59 <dons> this is a good point though. I'll ponder it some more
22:48:02 <dons> hey musasabi
22:49:14 <dons> tuomov: what's the file to put the repo addr in?
22:49:41 <tuomov> _darcs/prefs/email
22:49:41 <dons> it's not 'author'?
22:49:47 <dons> oh. ok. 
22:52:48 <dons> the state just has to be a bool, anyway. not even a string
22:53:07 <dons> just start with False on execLexer
22:53:16 <dons> and set it to true after the first searchE
22:53:48 <dons> in that way you modify the rest of the input stream, yeah?
22:57:22 <dons> ah. and read/echo char at a time editing for, say, search input, was a problem?
22:57:37 <dons> that's just a meta action that accumulates the line in the state, too
22:58:20 <dons> say you wanted '/' to initiate a search:
22:58:21 <dons> cmdSwitch = char '/'
22:58:21 <dons>     `meta` \_ seen_regex ->
22:58:21 <dons>         if seen_regex
22:58:21 <dons>             then (Just (Right (searchE Nothing)), True, Just deflt_mode)
22:58:24 <dons>             else (Just (Right (msgE "Search term: ")), True, Just ask_mode)
22:58:50 <dons> where ask_mode is an accumulating char mode, a bit like echoAccum in nano mode
23:00:01 <tuomov> hmm..
23:00:13 <tuomov> maybe instead of using lists, a kind of trees could be used
23:00:41 <dons> where?
23:01:16 <tuomov> data ActStream = Action (IO ()) ActStream | Branch (IO a) (a -> ActStream)
23:01:41 <tuomov> that way keymap state could be also maintained with iorefs, I think..
23:02:48 <dons> actions can write iorefs atm, already, though.
23:03:20 <tuomov> but it doesn't help with this kind of input branching
23:03:49 <dons> sure. I think, however, that branching is exactly what meta actions are for
23:04:02 <tuomov> what's a meta action?
23:04:22 <dons> `meta` .. (sorry, action is overloaded)
23:05:09 <tuomov> I don't even use the lexer..
23:05:14 <tuomov> just a simple finitemap
23:05:23 <dons> that's ok. that's why I made the type so simple
23:05:35 <dons> but maybe it would be easier if you did ...
23:06:04 <dons> simple editors would be easy this way, but complex ones.. that was the finite map hell stepcut and I were in a few weeks ago
23:06:25 <dons> so I started looking for wrappers over fm's
23:06:43 <dons> the ctk lexer is essentially a fancy fm interface
23:07:17 <dons> char 'x' `action` Just some_action  == insert ('x, some_action) into the fm
23:08:26 <dons> char 'x' `meta` \c state -> ... gives you the key, and a threaded state, and lets you return an entirely new fm to continue with
23:09:17 <tuomov> the lexer stuff seems much more complicated than my mode..
23:09:52 <tuomov> much of which would still remain as the code has to do the fm lookup itself
23:10:03 <dons> maybe, but once you start wanting runtime mappings or state, it's the only way, I think
23:10:12 <tuomov> and I want to be able define single keys and prefix maps in the same place
23:10:56 <tuomov> so I just have a list of bindings, and then code to build a (nested) finitemap out of it
23:11:20 <dons> yeah. sure. that's how i originally did the vi mode, and how stepcut did emacs.
23:11:53 <dons> maybe you can write your own wrapper over the keymap type to thread state
23:12:05 <dons> essentially your own execLexer
23:12:26 <tuomov> of course I always could do that.. but it would be nice to have a simple generic way to do this
23:14:24 <dons> yeah. a nice way to store state in the editor would be fun. i've mostly stopped looking at that, since it's so easy to thread state using ctk. but maybe I could have a keymap-defined state-type threaded with the input.
23:15:19 <tuomov> it's just a bit pointless to have each keymap store e.g. the search thing and so on
23:15:43 <dons> no. you shouldn't do that. that's what setRegexE is for.
23:16:00 <dons> but storing a bit saying 'I've done a search' -- that is more reasonable
23:16:13 <dons> and it can be done purely.
23:16:33 <dons> every extra bit of state in the editor is more stuff to restore on :reboot too. :(
23:16:34 <tuomov> it doesn't work
23:16:47 <dons> nope
23:16:49 <tuomov> I also need the IBXR flags and act according to those
23:17:00 <tuomov> and the core doesn't support them, at least not now
23:17:10 <dons> ibxr?
23:17:19 <tuomov> ignore case, backwards, regexp, replace
23:17:35 <dons> oh. ok. no, we don't have bacwards search yet
23:17:37 <tuomov> oh, and the replace string too needs to be stored in the case of replace
23:17:38 <dons> there's replace though
23:18:10 <dons> ok. i'll look into a nice way for this general search and replace stuff. all editors need it
23:18:27 <tuomov> ^KF starts a search/replace querying for all those options, ^L does next searc/replace or queries if there's no existing one
23:19:41 <dons> nonetheless, if you're using nested fm's, that need to remember previous input, ctk would be easier. not all state-related stuff will get a primop
23:23:58 <dons> so if you want to send Core.hs patches for the search and replace stuff. that'd be cool.
23:24:06 <dons> there's so much to work on..
23:24:50 <dons> atm, I'd like either nice general regex state support, or none at all
23:32:35 <tuomov> maybe there should be a Search datatype, and it would be up to the keymap to thread it if it supports reusing it
23:33:11 <tuomov> hmm..
23:33:41 <tuomov> but how about "Replace y/n?" query?
23:33:59 <tuomov> that absolutely has to depend on the editor state, not just keymap state
23:35:18 <musasabi> Could't that be maintained the same way as configuration settings? (or are they static)
23:35:46 <tuomov> I mean, replace should work this way:
23:35:51 <tuomov> 1. search
23:36:09 <tuomov> 2. if not found, tell the user that. If found, ask the user if this instance should be replaced
23:36:36 <tuomov> oh, and if all instances should be replaced.
23:36:46 <tuomov> Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?
23:36:52 <dons> i'm not sure about a _primop_ that asks a question. that behaviour is very editor-dependent.
23:36:56 <tuomov> that's what joe asks when it finds a string with replace flag set
23:37:08 <tuomov> dons: branching..
23:37:16 <musasabi> it is a little more incolved, if onw wants vi emulation
23:37:38 <musasabi> s/// vs s///g vs s///c (vim)
23:37:55 <dons> branching is just running an alternate keymmap(/fm). we already support that well
23:38:13 <tuomov> branching based on editor state
23:38:32 <tuomov> search result depends on editor state, it can't be done in keymap state
23:40:11 <dons> i'm not sure that we can't do it already.
23:40:33 <dons> with ctk and meta
23:41:48 <dons> 1 annd 2. can already be done.
23:42:14 <tuomov> how do you extract editor state out from the currently constructed action?
23:43:37 <dons> you wouldn't be able to extract it. 
23:43:55 <dons> you'd have to make wrap the action in a larger action
23:44:00 <dons> s/make//
23:44:03 <tuomov> but that needs to be done for the replace query
23:44:53 <tuomov> if nothing was found, we just show a message. If something was found, we want to verify that the user wants to do the replace
23:45:09 <tuomov> This creates two different branches for user input processing dependent on editor state
23:45:29 <dons> yep. sure. let me see if I can write it.
23:46:01 <dons> I'm thinking that you write an action that returns a flag and an action
23:46:18 <tuomov> but actions can't return anything
23:46:25 <tuomov> they're just IO ()
23:46:36 <dons> ultimately, yes.
23:46:47 <tuomov> if I getEditorState >>= something, the result must be IO something
23:47:39 <dons> I think I'm writing a branch..
23:51:26 <dons> hmm. tricky. ok. I give in. the types defeat me.
23:51:48 <dons> this is why I've been programming this kind of stuff as primops, I guess.
23:52:24 <dons> have a look at the wordCompleteE action as an example
23:52:51 <dons> still, issuing a prompt and branching to a new keymap, or returning. have to think about it.
23:53:32 <tuomov> replacing [Action] for that ActStream should solve the problem
23:53:34 <dons> we need a way for an action to invoke a lexer
23:53:42 <dons> yeah.
23:54:45 <tuomov> Just define e.g. :> for the normal concat there and the changes required to existing keymaps should be minimal
23:56:01 <tuomov> but I'm wondering if simply working in the io monad would after all be simplest
23:56:40 <dons> having a monadic lexer?
23:57:07 <dons> or, you just want [Char] -> IO [Action]
23:57:24 <tuomov> No, keymaps would just be IO (), and a 'getch' would be provided
23:57:38 <tuomov> of course, particular keymaps could implement list processing on top of that
23:58:11 <tuomov> that might not work with buffer-specific keymaps, though
23:58:43 <tuomov> perhaps with some concurrency stuff, but...
23:59:19 <dons> it's admitting defeat, since we managed to get rid of explicit getch, and now have lovely threaded getch in the background
23:59:58 <tuomov> It's quite neat atm, but not sufficient, and I'm concerned that once all the flaws have been fixed, it ends up being rather complicated
