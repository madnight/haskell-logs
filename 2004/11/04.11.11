00:03:09 <Lemmih> Note to self: when (ghc >= 6.3) $ s/mkAppTy/mkTyConApp
00:03:27 <dons> yeah
00:06:25 <Lemmih> Hmm Development version of HaskellDB is also buggy /-:
00:17:47 <Lemmih> Anyone doing anything spiffy?
00:31:10 <Lemmih> Hey bringert
00:32:37 <Lemmih> I'm about to send off the bug description to the HaskellDB mailing list.
00:41:29 <bringert> ah, nice
00:42:48 <bringert> if you want, you can enter it into the bug tracker at http://sourceforge.net/tracker/?group_id=101095&atid=629040
00:45:48 <Lemmih> Already mailed it. Awaiting moderator approval.
00:50:37 <bringert> you're not on the list?
00:51:41 <bringert> ok, approved it
01:04:14 <bringert> Lemmih: it sure is a bug
01:13:54 <bringert> eeh, the query optimizer code is a little tricky sometimes
01:21:17 <bringert> Lemmih: I need some more time to hunt for that bug, don't think I can do it today
01:22:01 <bringert> you're welcome to try to figure out which optimization causes the problem, you could try to disable the various optimizations in Optimize.hs
01:22:33 <Si\> bringert, are you now the maintainer of Network.HTTP?
01:26:48 <bringert> it would seem that way
01:27:10 <bringert> I don't do all that much maintaining though
01:27:23 <Si\> care if I make a few changes?
01:27:34 <bringert> darcs repo is at http://cvs.haskell.org/darcs/http/
01:27:42 <bringert> what is it you want to do?
01:28:07 <Si\> well, first I've split it into three modules, Network.[Stream,TCP,HTTP]
01:28:36 <Si\> then I've added a couple of functions for doing server-side interactions by pulling out the transfer functions from the client-side function
01:29:28 <bringert> is the client-side interface pretty much the same?
01:29:39 <Si\> exactly the same, I haven't touched it
01:29:48 <bringert> sounds good
01:29:55 <Si\> all I've done is pulled the transfer functions into global scope
01:30:04 <Si\> (e.g. chunkedTransfer)
01:30:08 <bringert> are you in the darcs group @ cvs.haskell.org?
01:30:35 <Si\> no, and really should learn how to use darcs...
01:31:42 <bringert> is your code based on the one from http://cvs.haskell.org/darcs/http/ ?
01:33:18 <Si\> basically yes
01:33:39 <Si\> it is the 0.2 version, i.e. the working one after you fixed it
01:33:59 <Si\> but with a couple of changes by Graham Klyne as well
01:34:28 <bringert> are you using the new Network.URI module?
01:34:54 <Si\> -- ** Changes by Graham Klyne:
01:34:54 <Si\> --      - export httpVersion
01:34:54 <Si\> --      - use new URI module (similar to old, but uses revised URI datatype)
01:37:15 <Si\> the only thing it doesn't do yet it server-side 100-continue, because I'm unsure of how that works
01:37:45 <Si\> so it might be a few days before I'm ready to release a full patch, I just wanted to make sure I'm ok to make changes
01:38:15 <bringert> it would be great if you could get a copy of the darcs repo, make the changes there and send me a patch
01:38:50 <Si\> right ok
01:39:24 <Si\> cuz I've been able to build a reasonably decent HTTP server using it, thought it might be useful for your XmlRpc project
01:39:30 <bringert> cool
01:39:43 <bringert> yeah, that would be nice, not having to use CGI
01:50:43 <bringert> hmm, the new Network.URI module is not yet in a released version of ghc
01:51:13 <Si\> I'm using 20041004 atm
01:51:16 <bringert> anyone know when ghc 6.3 will be out?
01:51:36 <Si\> ghc 6.4 is scheduled for release sometime this month
01:52:05 <Si\> "A new STABLE branch will be forked in preparation for the 6.4 release shortly, and we plan to release 6.4 around October/Novermber."
01:52:32 <Si\> it's going to be released in Novermber
02:44:41 <xkb> Does "evaluate" of Control.Exception reduce lazyness? According to the docs it reduces to Weak Head Normal Form
02:45:03 <xkb> In what way does Weak HNF differ from HNF?
02:46:26 <xkb> and by "reduce lazyness" I mean: Say I want to wrap an exception to another type of exception, I need to catch it first. To catch it I need the IO Monad, and thus evaluate
02:47:01 <xkb> this can be in any level of a (large) application
02:56:33 * Jan_w goggles in amament at xkb
02:56:43 <Jan_w> amazement?
02:56:43 <Jan_w>  :)
03:01:43 <xkb> Jan_w: just fighting the system :P
03:01:56 <xkb> Im working on an alternative exception system..
03:02:03 <xkb> or rather: trying to work onit
03:02:07 <xkb> insert space there
03:02:26 <mornfall> anywhere? .)
03:03:31 <xkb> yeah ;)
03:03:37 <bringert> xkb, I've used evaluate to that effect
03:04:00 <bringert> only works if the exception is produced by evaluating to whnf though
03:04:45 <xkb> yeah.. and thats what evaluate does right?
03:04:50 <xkb> reducing to hnf
03:04:57 <xkb> whnf
03:05:21 <bringert> as far as I understand, yes
03:05:40 <bringert> I did something nasty like unsafePerformIO (tryJust errorCalls (evaluate x))
03:05:46 <Lemmih> bringert: The bug is located in Database.HaskellDB.Optimize.pushRestrict. *the hunt continues*
03:05:59 <bringert> to catch calls to 'error' made by HaXml
03:06:44 <xkb> ooh.. thats nasty indeed
03:07:21 <bringert> Lemmih: good work. if you fix it, just send a patch
03:08:45 <bringert> xkb: it feels like it should be safe though
03:11:20 <xkb> my main concern is to make "wrapping" of exceptions easier. E.G. converting one exception to another
03:11:29 <xkb> as they are often used in say Java
03:12:53 <bringert> so you will have a problem if the exception is thrown by something that is not evaluated by 'evaluate', right?
03:14:04 <xkb> yes.. I cant catch the exception to wrap it if it's not in the IO monad
03:14:35 <xkb> as catch needs to enforce some kind of order in the exceptions of the evaluated statement
03:14:48 <xkb> see papers by SPJ for details
03:18:31 * Lemmih hugs Debug.Trace
03:33:30 <gokr> Question: Anyone know if ghc works on RiscOS? And if so, if darcs can be compiled and used there?
05:16:06 <TheHunter> @yow
05:16:07 <lambdabot> My polyvinyl cowboy wallet was made in Hong Kong by Montgomery Clift!
05:41:33 <Dosin> Hi! I am new to haskell and i am doing some assignments for school
05:41:42 <Dosin> I was wandering if i can ask you guys a question?
05:41:53 <Dosin> I want to convert a string to an integer
05:42:08 <Dosin> is there any standard way in haskell to do something like that?
05:42:34 <TheHunter> Dosin: read should work fine:
05:42:39 <Lemmih> Yes. 'read' can be used for such a task.
05:42:51 <TheHunter> *Main> read "123" :: Int
05:42:51 <TheHunter> 123
05:43:23 <Dosin> ah, it works, thanks for the fast reply!
05:43:25 <Philippa_> Lemmih: remind me if you can catch it when read fails?
05:43:35 <bourbaki> moin
05:44:29 <TheHunter> Philippa_: reads?
05:44:47 <Lemmih> Philippa_: You can use 'reads' which won't throw an exception but it is possible to catch the exception read throws on error.
05:44:49 <TheHunter> moin bourbaki 
05:44:53 <Lemmih> Hey bourbaki.
05:46:36 <Dosin> what am i doing wrong here? map read ["123","456"] :: Int
05:46:58 <Dosin> i want to convert an array of strings with numbers in them to an array of integers...
05:47:03 <TheHunter> Dosin: map ... :: [Int] should work
05:47:09 <Lemmih> You probably want it to read an list of ints and not just an Int.
05:47:30 <TheHunter> or map (read :: String -> Int) ["123","456"]
05:47:32 <Dosin> i need some coffee..
05:47:36 <Dosin> i should have seen that..
05:47:42 <Philippa_> or better yet, don't try to specify the types at first
05:48:00 <Dosin> well, the thing is i have to select the biggest number in the array
05:48:02 <Lemmih> bringert: Around?
05:48:19 <Lemmih> Dosin: Array or list?
05:48:23 <bourbaki> [14:51] <bourbaki> a line in quotient space is a circle so it has one more dimension if you want to draw the new space
05:48:23 <bourbaki> [14:52] <bourbaki> a rectangular space as a otient space in both extends is a torus so its from 2d to 3d
05:48:23 <bourbaki> [14:52] * fatpelt has joined #Math
05:48:23 <bourbaki> [14:52] <bourbaki> what is the object called that i get when i apply the quotient space to a cube?
05:48:54 <bourbaki> hypertorus?
05:48:55 <Dosin> ["123","44334","23232"] for example, i would get the returned value 44334
05:50:06 <Lemmih> Dosin: 'read' and 'maximum' will do great.
05:50:23 <Dosin> yeah, this is my endresult:
05:50:25 <Igloo> If you're using [1,2,3] notation it's called a list in Haskell, not an array
05:50:29 <Dosin> grootsteDeci n = foldl1 max (  map read (toDecimaalList n) :: [Int])
05:50:48 <Dosin> ahh, ok, thanks igloo
05:50:56 <Dosin> i have just been doing this since yesterday
05:50:58 <Dosin> so its a bit new to me
05:51:29 <Igloo> What should the result be if n is []? Or is it guaranteed not to be?
05:51:48 <Igloo> No problem - looks like you're doing good  :-)
05:52:33 <Dosin> i will test empty lists now
05:52:42 <Dosin> haven't added those exeptions yet
05:54:25 <TheHunter> bourbaki: [0,1]^n/~ where ~ is induced by (0,x2,..,xn) ~ (1,x2,...,xn), ..., (x1,...,x(n-1),0) ~ (x1,...,x(n-1),1) if i'm not mistaken.
05:54:53 <Lemmih> bringert: I think I've located the problem but I'm not sure how to proceed.
05:55:11 <bourbaki> TheHunter i just mean what kind of object is it then? is it called a hyper torus?
05:56:10 <TheHunter> bourbaki: i'd call the thing i just defined hypertorus.
05:56:42 <TheHunter> being not exactly sure what you mean by "apply the quotient"
05:57:21 <bourbaki> i mean that the upper square is next to the lower one and the right to the left and the front to the back in the quotient space
05:57:32 <bourbaki> that is beeing the same actually
05:58:20 <bourbaki> (0,y,z) = (1,y,z), (x,0,z) = (x,1,z), (x,y,0) = (x,z,1)
05:58:37 <bourbaki> in [0,1]^3
05:58:40 <TheHunter> i have heard that thing being referred to as hypertorus, i guess.
05:59:11 <bourbaki> well the topology is the same so it kind of makes sense i guess
05:59:48 <bringert> Lemmih: back from lunch now
06:00:05 <bringert> what's the problem?
06:00:26 <TheHunter> well, (hyper)torus is usually defined as that quotient in topology.
06:00:52 <bourbaki> same as a circle :)
07:08:50 <dash> good morning! i have a puzzle for your haskell brains
07:09:01 <bourbaki> 42! :)
07:09:22 <dash> in particular! I have some code producing an infinite pattern matchign error
07:11:06 <dash> it looks like this: 
07:11:11 <dash> "Program error: pattern match failure: applicationMeaning_v2307 [ArnisExpr_AAtom (Atom_AInt (Num_fromInt instNum_v32 0))] (extend (Make.Eq (instEq_v20_v1429 instEq_v11) (Eq_v466 (Make.Eq (instEq_v20_v1429 instEq_v11) (Eq_v466 (Make.Eq (instEq_v20_v1429 instEq_v11) ....."
07:11:37 <dash> what is the usual method for debugging such a monstrosity? :)
07:12:16 <arjanb> looks more like a compiler bug to me..
07:12:31 <dash> this is Hugs.
07:12:50 <ski> look at definition of applicationMeaning
07:13:05 <dash> ski: well, yes. That much i guessed =) 
07:13:15 <dash> any suggestions of what in particular to look for?
07:13:25 <Igloo> That's what hugs gives you when you have unhandled cases
07:13:37 <Janni> Hi.
07:13:39 <Igloo> Make it ghc -Wall clean and your life will be better
07:13:46 <dash> Igloo: Hm. OK
07:14:06 <ski> applicationMeaning [ArnisExpr_AAtom (Atom_AInt (Num_fromInt instNum_v32 0))] .. seems to not be handled
07:14:26 <dash> i'd gotten other pattern matching errors in the past, but that hadn't been quite so infinite
07:14:32 <dash> s/that/they/
07:14:45 <dash> so i thought maybe this one was special. :)
07:15:12 <ski> focus on the data constructors in the arguments of the call, ignore the other rubbish
07:17:44 <shapr> bringert: y0, did you see Koen's talk today?
07:18:09 <Lemmih> Hey shapr.
07:18:21 <shapr> greetz Lemmih 
07:18:39 <shapr> How's it going?
07:19:20 <bourbaki> moin shapr
07:19:27 <Lemmih> shapr: HaskellDB get's really cool when dealing with really advanced queries.
07:19:46 <shapr> tja bourbaki 
07:19:48 <gokr> Q: Anyone knows if ghc is available on RiscOS?
07:20:02 <shapr> does RiscOS do Posix?
07:20:10 <gokr> Eh.. think so.
07:20:15 <bourbaki> shapr got time to integrate iging?
07:20:16 <gokr> It has gcc.
07:20:34 <gokr> (I don't use RiscOS personally, but I need to know)
07:21:14 <shapr> bourbaki: I don't have time to do it, but writing a plugin generally involves just calling the 'msg' function to send a reply back to the channel/person who executed the command.
07:21:34 <shapr> gokr: I don't know, but http://www.haskell.org/ghc/ or google should tell you.
07:23:32 <dash> Blah. now i've gotta go add real error handling to this code
07:23:56 <dash> good thing i was planning on converting it to a monadic interpreter anyway
07:24:14 <shapr> greetings dash!
07:24:17 * Lemmih is away: fmap Unicycle (deliver =<< getMail)
07:24:19 <dash> hello shapr!
07:24:21 <dash> how are you
07:24:30 <shapr> Lemmih: haha!
07:24:51 <shapr> I'm okay, lots of work and school and not enough sleep. But it's better than being bored.
07:24:57 <dash> Hheh
07:32:37 <bringert> shapr: dammit, I knew there was something I meant to do today
07:33:20 <shapr> I'll email Koen and ask for a preview copy, then maybe I can tell you about the cool new stuff in QC2.
07:33:25 <bringert> :)
07:33:41 <bringert> btw, I think I've fixed the haskellDB build system
07:33:46 <shapr> yay!
07:33:59 <shapr> did you add a configure option for hs-plugins?
07:34:17 <shapr> or, does it build and load into ghci with the latest hs-plugins now?
07:34:24 * shapr cvs up
07:34:56 <bringert> I didn't add one, but I think there is one
07:35:10 <bringert> --enable-ghc-plugins
07:35:21 <shapr> ok
07:35:31 <bringert> chucky did that I think
07:41:28 * shapr throws a lambda boomerang
07:43:47 <Igloo> ISAGN
07:44:59 <shapr> Maybe if ICFP is in .au one year, they can give them away as the entrance gift.
07:46:51 <Igloo> That sounds dangerous. Best to give them away as exit gifts
07:46:59 * shapr laughs!
07:47:01 <ski> or moooonad didgeridoos
07:47:10 * shapr laughs more
07:49:56 <earthy> you guys are weird ;)
07:50:35 <Igloo> With all had exposure to imperative programming. It rots your brain, donchaknow?
07:50:42 <Igloo> s/With/We've/
07:50:48 <earthy> yeah, I know
07:50:53 <Philippa_> heh
07:50:58 * earthy has even had exposure to digital circuitry and VHDL
07:51:05 <shapr> lambdas really do look a lot like boomerangs.
07:51:06 <Philippa_> I wouldn't go quite that far, you need to know some for the days you're forced to produce a stream of commands
07:51:13 <earthy> http://home.pacific.net.hk/~plastics/boomerang.htm
07:51:17 * earthy whistles
07:51:41 <shapr> Wow, they already exist.
07:51:44 * earthy has optimised machine code as well as digital circuits by hand
07:52:11 <earthy> and then tried to devise algorithms for same
07:52:15 <earthy> not pretty
07:54:27 <shapr> At some in the past we noticed that Star Trek furniture is not for sale online.
07:54:56 <shapr> So we thought we'd start an online store to sell Star Trek furniture, and the first product would be the futon torpedo.
08:04:01 <tuomov> :)
08:04:41 <shapr> Just read Graham Klyne's read . show == id comments
08:05:40 <shapr> 1. Python has two 'show' functions, str() and repr(). Such that, eval(repr(x)) == x and str() is just for 'showing' an object as text
08:05:57 <shapr> But I think this goes further than that.
08:06:31 <sond> shapr, where are you reading?
08:06:32 <shapr> I've wanted "deriving WebPublish" as I described before, and I realized that will involve "show as html/xml" 
08:06:44 <shapr> sond: haskell@haskell.org
08:06:50 <sond> okay
08:06:56 <shapr> post subject is "Conceptual overloading of show?"
08:07:20 <shapr> I've also realized that WebPublish will be a lot easier if  "readXML . showXML == id"
08:08:02 <shapr> and the same for {show,read}XHTML,{show,read}HTML, {show,read}ASN1, etc
08:08:21 <shapr> I think there's a pattern here, but I don't know how to capture it in Haskell's Read/Show classes.
08:08:51 <shapr> hoi Boegel 
08:09:30 <Boegel> hey shapr 
08:09:43 <Boegel> bourbaki, are you there ?
08:09:57 <bourbaki> yep
08:10:03 <Philippa> shapr: generalise Read/Show by parameterising on the type that's String in those cases, anything more involved?
08:10:30 <Boegel> I'm still having problems with perlin noise, but I'm very close now... let me show you an image
08:10:45 <bringert> shapr: I guess you've seen the TH code in XmlRpc for deriving XML-RPC representations of user-defined record types?
08:10:45 <bourbaki> k
08:10:58 <Philippa> also, do you want just equivalent structures or the exact same structures out?
08:11:11 <shapr> Philippa: huh?
08:11:40 <shapr> bringert: no, but I'll look at that now.. can that code be parameterized for more than XmlRpc reps? Also ASN1, XML, etc?
08:11:55 <shapr> I suspect Data.Generics and TH would fit well into this pattern.
08:12:24 <shapr> sond: haskell and haskell-cafe mailing lists is where most of the fun stuff happens. libraries mailing list is interesting too.
08:12:38 <sond> shapr, i know.. i'm a subscriber :)
08:12:43 <shapr> ok :-)
08:13:10 <Philippa> shapr: half-formed braindead idea. But suppose the ADT representation has two or more ways to say something and the show func converts them both to the same thing...
08:13:57 <shapr> if they're equivalent, it won't matter?
08:14:04 <shapr> like darcs repos
08:14:18 <Philippa> it might to somebody though - "I want *my* whitespace, dammit!" :-)
08:14:52 <shapr> well, don't derive Show in that case
08:15:17 * shapr adds the THDeriveXmlRpcType example to his email reply.
08:16:04 <shapr> so, parameterize Show on various 'transports' ?
08:16:13 <Philippa> yeah
08:16:20 <Philippa> Show signal carrier
08:16:25 <dv> is there a way to read/write to lpt in haskell?
08:16:27 <shapr> signal?
08:16:51 <Philippa> instead of the present Show signal [implicit String]
08:16:52 <shapr> dv: it's just a file, I'm sure you can write to it.
08:17:21 <shapr> you may want to derive (Show Signal) to get showSignal and readSignal methods?
08:17:30 <dottedmag> shapr: I suppose under Windows things are more interesting
08:17:45 <shapr> For some value of interesting, yes.
08:18:20 <Philippa> for "boring and frustrating" values...
08:18:25 * shapr grins
08:18:33 <dottedmag> shapr: I just don't know whether Windows still provide 'lpt:' file
08:18:36 <Philippa> shapr: AIUI the deriving syntax isn't really sorted out for multiparm classes...
08:18:37 <shapr> Why do you use windows again?
08:18:42 <Philippa> because I'm a gamer
08:18:50 <shapr> well, ok.
08:19:00 <Philippa> oh, and because I cba to find out how to clone my desktop setup under X, though that's a strictly secondary thing
08:19:09 <shapr> I can help with the desktop setup.
08:19:20 <dv> i think i'm supposed to use windows for this
08:19:25 <shapr> Only way to fix the gaming problem is to write some Haskell games I suspect.
08:19:29 <dv> but i'll ask my teacher if they have freebsd installed somewhere heh
08:19:33 <shapr> :-)
08:19:57 <Philippa> quite. I'm tempted to use linux or a BSD as the main OS if/when I get a laptop because I won't be gaming so much on it
08:20:06 <Philippa> and because I may as well get a little more familiar
08:20:20 <Philippa> but essentially it's somewhere on a backburner
08:20:31 <Philippa> I mean, this box dual-boots now, but there's a reason GRUB defaults to the win2k install
08:20:49 * earthy whistles innocently after mentioning the joys of Mac OS X
08:21:00 <Philippa> my single biggest irritation with windows atm is not being able to rearrange the icons on the taskbar
08:21:05 * Boegel scratches his head
08:21:07 <Philippa> things could be worse, y'know?
08:21:48 <bourbaki> Boegel wheres my pic?
08:22:29 <Boegel> bourbaki, I just changed something regarding ambient lighting and such, just a moment :)
08:23:36 <shapr> hoi swiert, how's writing?
08:23:59 <Boegel> bourbaki, I adjusting my perlin noise function so I get 1 value, which I use a a grey scale, as you told me yesterday
08:24:09 <swiert> shapr: all right - there's light at the end of the tunnel.
08:24:16 <bourbaki> Boegel right
08:24:19 <Boegel> but I get some weird results, I'm not sure I'm intorpolating as I should
08:24:39 <shapr> swiert: just hope it's not an approaching train =)
08:24:43 <bourbaki> ok then show it :)
08:26:43 <Boegel> bourbaki, the image without perlin noise, just to see how the brightness of the colors come out with the lights in the scene: http://studwww.ugent.be/~kehoste/thesisPublic/exNoPerlin.png
08:26:54 <Boegel> bourbaki, the same scene with perlin noise: http://studwww.ugent.be/~kehoste/thesisPublic/exPerlin.png
08:27:38 <bourbaki> seems as if you always get a very dark val
08:27:53 <bourbaki> how do you randomize the vectors on the grid?
08:28:11 <bourbaki> the longer these are the bigger ther u v s and t
08:28:26 <bourbaki> resulting in a brighter scale value
08:28:27 <Boegel> bourbaki, longer ?
08:28:40 <bourbaki> the vectors you randomize they have a length
08:28:58 <Boegel> yes, but I generate very random stuff...
08:29:00 <Boegel> some output:
08:29:06 <tic> hrm, now I should start proving Monotone Sat.
08:29:37 <tic> err, that it's NP-complete, even.
08:29:39 <Boegel> (0.3805393,0.9040574,0.9269586),(0.8852215,0.43106094,0.5695719),(0.9438803,0.94998956,0.6154798),(0.6447757,0.97746086,0.7082844),(0.49660394,0.93819946,0.8122431),(0.27060372,0.985815,0.52887416),(0.19128609,0.72367835,0.7655127),(0.33122087,9.994784e-2,0.47812968),(0.9124495,9.208992e-2,0.29902494),(0.97961664,0.5655856,3.80466e-2),(0.46299982,0.6517818,0.46652406),(0.9400543,0.8851284,0.24760306),(0.5847745,0.7793933,5.0785244e-3),(0
08:29:39 <Boegel> .8179107,0.39502883,0.640359),(0.5808511,4.101157e-3,0.62248045),(0.9741156,9.87252e-2,0.16554296),(0.770774,0.93636596,0.5609619),(0.43901142,0.24332106,0.2316978),(0.98616505,0.13367242,0.76614296),(0.7859677,0.8266995,0.43436372),(0.9719955,9.221694e-2,0.48523512),(0.47759956,0.64147496,0.789967),(0.10709676,4.255295e-3,8.743456e-2),(0.28269672,0.80749255,0.6533973),(0.37397027,0.13379139,0.6850607),(0.59167534,0.44498008,0.3896),(0.6
08:29:40 <Boegel> 2329406,0.114540905,0.22327343),(0.58976746,0.6009276,0.85591614),(0.47455177,0.66385627,0.57234776),(0.8012384,0.9993111,0.8008811),(0.5316791,0.72332186,0.70237696),(0.9220509,0.3101152,0.61403525),(0.46466795,0.59416455,0.85825604),(0.5544375,9.833866e-2,0.38806567),(1.0539144e-2,0.6725843,0.1922892)
08:30:11 <Boegel> there are some vectors there that are quite close to having length 1 I think...
08:30:11 <musasabi> argh
08:30:12 <bourbaki> all quite small
08:30:28 <shapr> hei musasabi 
08:30:44 <Boegel> do I need to add a certain minimal contraint orso ?
08:30:44 <bourbaki> your difference to the inner point is always smaller then 1
08:31:07 <bourbaki> so if you do the dot product with these vectors your scale is always smaller then 1
08:31:20 <shapr> musasabi: working on something interesting?
08:31:26 <bourbaki> since all the vals of your vectors are also smaller then 1
08:31:35 <bourbaki> so the maximal value is 3
08:31:46 <bourbaki> 0 < scale < 3
08:31:49 <Boegel> bourbaki, don't the values of my vectors need to be smaller then 1 ?
08:31:58 <bourbaki> no
08:32:02 <Boegel> they represent gradients, so colors, not ?
08:32:05 <bourbaki> they are not normals
08:32:21 <bourbaki> they arent gradients either they are just random vectors
08:32:44 <Boegel> of _any_ size ?
08:33:00 <bourbaki> multiply your vectors with rand 80
08:33:08 <bourbaki> the above vectors that is
08:33:15 <Boegel> @index rand
08:33:16 <lambdabot> Debug.QuickCheck
08:33:25 <Boegel> what is rand ?
08:33:26 <shapr> Oh man, I forgot to mention EuroHaskell in my HC&AR entries! Argh!
08:33:39 <bourbaki> (x * rand 80, y * rand 80, z * rand 80)
08:33:43 <bourbaki> random value i mean
08:34:17 <Boegel> bourbaki, I don't get your rand 80 :) do you mean a value around 80 ?
08:34:27 <bourbaki> no a random value
08:34:36 <bourbaki> 0 <= x <= 80
08:34:48 <musasabi> shapr: interfacing C++ and haskell.
08:35:02 <shapr> kosmikus: do you want editorial corrections for HC&AR?
08:35:08 <musasabi> shapr: which is mainly remainding me why I used to hate C++ so passionately.
08:35:43 * shapr laughs
08:36:02 <shapr> Is there some automated way to link a libfoo into Haskell?
08:37:21 <shapr> I vaguely recall there's some command I can use to list all the functions available in a lib, does something like greencard or friends automatically find all the names and produce Haskell source to call them?
08:38:35 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesisPublic/exPerlin80.png :s
08:39:16 <Boegel> you can see it in the other image to... it's either or black or dark red, but no in between...
08:39:36 <bourbaki> then theres something wrong with your interpolation
08:39:47 * Boegel scratches his head
08:40:00 <Boegel> I'll show you the function where I interpolate, okay ?
08:40:27 <shapr> whoa, EHC is nifty!
08:40:36 <bourbaki> yep
08:40:37 <Boegel> @wiki HaskellIrcPastePage
08:40:37 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:41:36 <shapr> man, HC&AR is going to fuel quite a few lambda-the-ultimate.org posts from me.
08:41:54 <Boegel> bourbaki, posted
08:41:59 <bourbaki> kk
08:42:02 <earthy> shae: good show!
08:42:07 <earthy> let Ehud off the hook
08:43:16 <Boegel> bourbaki, I just used *80 to adjust the values... I doesn't matter I think, because the x, y, z values are already random, am I right ?
08:43:31 <shapr> greetz Hunter
08:43:32 <bourbaki> yes but they are so small
08:43:50 <Boegel> I know
08:43:57 <shapr> TheHunter: Found any interesting avenues of exploration lately?
08:43:58 <Boegel> but that's not the only problem I think...
08:43:58 <TheHunter> good evening shapr 
08:44:31 <Boegel> hey TheHunter 
08:44:35 <TheHunter> hey Boegel 
08:44:54 <TheHunter> shapr: not really.
08:46:19 <TheHunter> I noticed something weird though: The construction of the Stone-Cech-compactification seems similar to the use of continuation passing style to construct monads (prolly only on the surface).
08:47:01 <earthy> wow. you've completely lost me in 1 sentence
08:47:06 <earthy> mad props! :)
08:47:23 <bourbaki> Boegel the interpolation between the c and d is missing
08:47:23 * TheHunter is looking forward to tomorrow - not being online all day sucks!
08:47:45 <Boegel> bourbaki, no it's not ? res is the interpolation between c and d ?
08:48:11 <Boegel> bourbaki, ow, it's not on the wiki... wait, I'll adjust it :)
08:49:07 <TheHunter> hmm, there is a bug in that sentence: s/Cech/ÄŒech/
08:49:24 <Boegel> bourbaki, adjusted
08:49:39 <bourbaki> i dont understand what you do at some places
08:49:48 <TheHunter> (don't know how to produce this weird character using the compose key though)
08:50:13 <Boegel> bourbaki, ask me :)
08:50:17 <bourbaki> you need to get the point in that cube and substract them from the edge points
08:50:22 <Boegel> I use the faster algorithm
08:50:42 <Boegel> bourbaki, that's what I do (I think)
08:50:43 <bourbaki> ah ok so you floor and ceil the val
08:50:49 <Boegel> yes I do
08:51:14 <bourbaki> and grad does what?
08:51:19 <Boegel> I determine x0 and x1 first, being floor and ceil, and I combine the different x,y,z values to get the 8 edge points of the cube
08:51:22 <earthy> hm. damn. time to run
08:51:34 <Boegel> returns the gradient at a given point
08:51:50 <Boegel> > getGradientAt :: (Int,Int,Int) -> Int -> [Int] -> [Color] -> Color
08:51:50 <Boegel> > getGradientAt (x,y,z) n pList gList = gList !! (mod ((abs x) + (pList !! (mod ((abs y) + (pList !! (abs z))) n))) n)
08:51:54 <bourbaki> i wouldnt call it gradients
08:52:03 <Boegel> perlin calls it gradients :)
08:52:04 <bourbaki> why round?
08:52:12 <bourbaki> oh ok still :)
08:52:36 <bourbaki> you should look up the things with the ceil and fool vals
08:52:40 <Boegel> because gradient want a Int value, and x0 is of type float (because of the sub, it needs to be Float)
08:52:52 <Boegel> I do
08:52:56 <bourbaki> not round if your point is > .5 you always get the same gradients
08:53:10 <bourbaki> why do you round them??
08:53:13 <bourbaki> ah ok
08:53:20 <shapr> TheHunter: good points of not being online is that you tend to get a lot of stuff done... at least, that's my experience.
08:53:27 <bourbaki> so round is an int
08:53:28 <shapr> THat may change once decent online pair programming tools are available.
08:53:29 <Boegel> maybe round isn't the right function for it, but that's the least of my worries now
08:53:32 <Boegel> yes
08:53:41 <Boegel> I needed something to parse 3.0 to 3 (float to int)
08:53:52 <Boegel> it has nothing to do with the .x
08:53:58 <dv> wah, this lpt stuff is way harder then one would think
08:54:06 <Boegel> because x will always be 0, because of the floor/ceil
08:54:19 <Boegel> @index toIntegral
08:54:19 <lambdabot> bzzt
08:54:20 <TheHunter> shapr: i usually end up watching futurama episodes for the nth time.
08:54:27 <TheHunter> i really suck at getting stuff done.
08:54:27 <Boegel> @index fromIntegral
08:54:27 <lambdabot> GHC.Real,Prelude
08:54:35 <Boegel> @index fromFloat
08:54:35 <lambdabot> bzzt
08:54:37 <Boegel> @index fromFloating
08:54:37 <lambdabot> bzzt
08:55:10 <bourbaki> Boegel cant you randomize the adjust thingy?
08:55:12 <shapr> TheHunter: me too, but I don't like TV much, so I usually end up reading sci-fi and fantasy books.
08:55:32 <bourbaki> you want random length the length is the scale
08:55:34 <Boegel> bourbaki, I could... I could do that in buildColor, where I build the list of gradients...
08:55:48 <TheHunter> @type ceiling
08:55:49 <bourbaki> do that then please and render again
08:55:50 <lambdabot> ceiling :: forall a b. (RealFrac a, Integral b) => a -> b
08:56:15 <shapr> I wish there were some people here in the north of Sweden who I could discuss #haskell-ish subjects with in person.
08:56:33 <shapr> IRC is nice, but IRL has its advantages.
08:57:30 <Philippa> move to the UK?
08:58:02 <shapr> Well, maybe France, then I could just take the Chunnel.
08:58:14 <Boegel> bourbaki, how can I get an random value out of the IO monad ?
08:58:27 <TheHunter> unsafePerformIO?
08:59:17 <maihem> moin everybody
08:59:22 <TheHunter> moin maihem 
08:59:25 <shapr> greetz maihem 
08:59:30 <Philippa> yell if you ever fancy organising a \pissup over here, anyway
08:59:38 <bourbaki> Boegel no idea but you do some random operations dont you?
09:00:13 * maihem is having a pissuo over heree.
09:00:47 <Boegel> yes, but only on lists... nevermind, I'll figure it out ;)
09:01:14 <ski> randomRIO ?
09:01:25 <bringert> Boegel: you can create a StdGen or an infinite list of random numbers on the top level, then thread it through your code
09:01:32 <bringert> or put it in a state monad
09:01:44 <TheHunter> if find myself abusing quickcheck for that purpose, sometimes
09:01:54 <bourbaki> Boegel but the vectors have to be random as well
09:03:26 <Boegel> bringert, I know, I'm working that way now... I use a random list of 256 values that I thread through my code :) thanks
09:03:34 <Boegel> bourbaki, I know
09:05:17 <TheHunter> Boegel: do you want a fixed size list?
09:05:39 <Boegel> TheHunter, yes
09:05:47 <Boegel> that makes the algorithm faster...
09:06:39 <TheHunter> if you abuse QC, you have vector.
09:07:14 <CosmicRay> hello syntaxninja
09:07:34 <Boegel> bourbaki, 80 is too high, but if I use 10 as max value I get this: http://studwww.ugent.be/~kehoste/thesisPublic/exPerlinR10.png
09:07:43 <Boegel> I think it still quite black :s
09:07:50 <CosmicRay> SyntaxNinja: have you uploaded a fix for #279988 yet?
09:07:54 <shapr> Greetings Agent Jones.
09:07:58 <CosmicRay> heh
09:08:09 <CosmicRay> shapr: You're going down, Neo.
09:08:24 <CosmicRay> shapr: You can't possibly imagine what kind of power I wield.
09:08:33 <CosmicRay> shapr: All agents run as root --- bwahahaahaha!
09:08:52 * Boegel used to think he was the one... but he's not :p
09:08:54 * shapr slpoits CosmicRay's access
09:09:00 <CosmicRay> heh
09:09:02 <shapr> protocol fuzzing! yay!
09:09:27 <TheHunter> Boegel: the cleanest way is to define a monad Gen a = Gen (StdGen -> a), randGen :: Random r => Gen r, then you can simply sequence a fixed number of Gens.
09:09:38 <bourbaki> Boegel you should recheck the interpolation construct a samle you can calc on paper
09:09:55 <shapr> Actually, I wrote an email to Koen Claessan about protocol fuzzing that quoted Igloo and his HUnit tests for his regexp lib....
09:10:23 <SyntaxNinja> hi CosmicRay
09:10:32 <Boegel> bourbaki, ok, I will try that... are you on the same lever as me, it can't be anything else then the interpolation ? or can it ?
09:10:41 <shapr> I also had SyntaxNinja's ReactiCheck attached to that email.
09:10:54 * Boegel slaps himself ... "or can it "
09:10:57 <shapr> I want to see the QC2 preview code!
09:11:00 <Igloo> eh?
09:11:22 <shapr> Igloo: remember when I said that your regex code screamed out for quickcheck?
09:11:23 <Igloo> What's protocol fuzzing and what does it have to do with regexp hunits?
09:11:24 <bourbaki> Boegel as i said construct a sample that you can test your code with
09:11:25 <musasabi> shapr: the problem with "automatic" calling is scavenging enough type information.
09:11:27 <TheHunter> shapr: yeah, me too. And I hope variant is fixed.
09:11:29 <SyntaxNinja> CosmicRay: yeah. I'll close that.
09:11:34 <SyntaxNinja> hi shapr :)
09:11:42 <Igloo> And I disagreed, but go on  :-)
09:11:54 <Boegel> I should be getting something like this.. http://www.noisemachine.com/talk1/20.html
09:11:59 <Boegel> that's really smooth
09:12:31 <shapr> musasabi: requires sources?
09:12:55 <CosmicRay> SyntaxNinja: what version fixed it?
09:14:16 <bourbaki> Boegel how big is your grid?
09:14:37 <CosmicRay> SyntaxNinja: I guess 0.2-3?
09:15:26 <shapr> oh cool, Numeric Prelude!
09:15:36 <Boegel> bourbaki, infinite... but I use a list of 256 grid points, as Perlin suggested in http://www.noisemachine.com/talk1/17.html
09:15:44 <SyntaxNinja> CosmicRay: 0.2-2 fixed it, I think, and 02.-3 fixed the problem with HUnit building.
09:16:07 <bourbaki> Boegel and how big is your sphere?
09:16:15 <CosmicRay> SyntaxNinja: excellent.
09:16:45 <Igloo> Incidentally, haskell-cabal is blocking on ghc6 IBO hat which needs nhc98 to be fixed on powerpc and m68k
09:16:47 <bourbaki> bogel please initialize all your gradients as (1,...,1)
09:16:52 <CosmicRay> SyntaxNinja: ok, it looks like a couple of the autobuilders are just slow then.
09:17:02 <CosmicRay> Igloo: "IBO hat"?
09:17:10 <Igloo> "is blocking on"
09:17:11 <bourbaki> what you get then when you do the dp is the difference
09:17:23 <musasabi> shapr: more or less.
09:17:40 <musasabi> shapr: with C++ you can get mostly everything except return types from the binary.
09:17:51 <shapr> Is there a tool to generate bindings from sources?
09:17:55 <musasabi> shapr: however inline functions are only in the source..
09:18:02 <Igloo> At least on powerpc it seems to build with gcc2, though, so it ought to be fixable that way if nothing else. I'm trying to avoid that if possible, though
09:18:08 <musasabi> shapr: I have some code which is not ready...
09:18:21 <shapr> sounds nifty, darcs repo?
09:18:24 <bourbaki> the sum of the vector itself of course
09:18:38 <musasabi> I can put up a tarball if you want.
09:18:54 <shapr> yes please!
09:19:01 <bourbaki> so what you should siee is something like small dots in black squares
09:19:31 <shapr> musasabi: I occasionally wish I could browse your Haskell sources :-)
09:19:34 <Boegel> bourbaki, how do you mean, initialize my gradients at (1,..,1) ?
09:20:07 <bourbaki> Boegel just as i said all the gradients should be 1
09:20:21 <bourbaki> then you just get the sum of the difference vectors elements
09:20:32 <shapr> the CGA api would be handy...
09:20:41 <bourbaki> Boegel or wait
09:21:00 <bourbaki> Boegel just add all the dps and divide them by 8
09:21:01 <Boegel> bourbaki, you mean I should do this : 'grad (x,y,z) = (1,1,1)'
09:21:02 <Boegel> ?
09:21:25 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/c++iface_really_not_ready.tar.gz
09:21:32 <bourbaki> Boegel yes but were gonna have a look if its the dp thats wrong or the interpolation so just sum the dps and div 8 them
09:21:36 <Boegel> bourbaki, in stead of interpolationg ?
09:21:39 <bourbaki> Boegel yes
09:22:47 <Boegel> bourbaki, I have to eat now, mommy is calling me :p
09:22:52 <shapr> musasabi: thanks!
09:22:53 <Boegel> I'll be back in a giffy !
09:23:41 <shapr> aha, Sdf2Haskell might be good for Yi synhl
09:27:07 <shapr> whoa, there's something called Administrative Normal Form
09:27:19 <shapr> I swear that sounds like a blizzard of forms that must each be filled out in triplicate.
09:28:29 <shapr> Whoa, dance is being further developed, nifty!
09:28:44 * shapr is riding the high of too much input
09:31:40 <shapr> In the "Commercial Users of Functional Programming" report, they mention the "A Bus Hits Simon Peyton Jones" problem.
09:31:43 * shapr laughs
09:32:32 <SyntaxNinja>  we should give a fancy, mathy sounding name to that problem.
09:32:57 <CosmicRay> lambdasquish
09:33:06 <shapr> tPP calls it the 'Bus Number' of any project.
09:33:11 <shapr> I do like lambdasquish =)
09:33:19 <shapr> \_ -> squish
09:33:22 <CosmicRay> :-)
09:33:39 <Igloo> shapr: And what do they conclude happens in that scenario?
09:33:53 <shapr> Igloo: zero commercial use of Haskell/FP
09:34:02 <shapr> And they have a real point too
09:34:06 <Etaoin> is \ supposed to look like a lambda?
09:34:26 <shapr> Etaoin: it's a lambda in Haskell at least...
09:34:27 <Igloo> Hmm, that's not the answer I was hoping for  :-)
09:34:30 <shapr> \x -> x + 1
09:34:57 <wilx> Link?
09:35:13 <shapr> In my opinion, SPJ has been the largest contributor to the success of FP, specifically with Haskell (98) and GHC.
09:35:33 <xerox> it would be nice to have a lambda greek letter as lambda
09:35:57 <shapr> He has several zillion published papers, he's prolific in coding, paper writing, meeting organizing, project leading, and everything else you can think of...
09:36:02 <tuomov> and all other kinds of fancy symbols for operators
09:36:52 <xerox> in DrScheme CTRL+SHIFT+ù puts a nice greek lambda ^_^
09:37:01 <xerox> (that works as 'lambda')
09:38:31 <shapr> hiya gabor 
09:38:51 <shapr> wilx: the CUFP report is linked from the HC&A report.
09:38:53 <gabor> hi shapr!
09:39:09 <shapr> how's code treating you?
09:40:10 <shapr> One thing mentioned is that there aren't many skilled functional programmers.
09:41:04 <wilx> 'k
09:41:53 <Boegel> bourbaki, http://studwww.ugent.be/~kehoste/thesisPublic/exPerlinDiv8.png
09:42:04 <Boegel> so I guess something is wrong with the dp's, right ?
09:42:21 <bourbaki> yes
09:42:29 <Igloo> There also aren't many jobs demanding skilled functional programmers
09:42:36 <Boegel> what did you suggest with the (1,1,1) gradient stuff ?
09:42:39 <bourbaki> as you see the dp is always the same in the upper and lower part of the quad
09:42:59 <bourbaki> Boegel that was to see if the gradient is wrong but i think its the dp
09:43:04 <bourbaki> so we can skip that
09:43:18 <bourbaki> its either your gradients that are not random or you dp
09:43:22 * Igloo would self-identify as a skilled functional programmer, but doubts I'll be able to get a job doing it, unfortunately  :-(
09:43:32 <Boegel> my gradients are defently random :)
09:43:37 <shapr> Yah, chicken and egg problem.
09:43:37 <tuomov> there arent' many jobs demanding skilled programmers.. any monkey will do
09:43:45 <gabor> shapr: my code is evil code (c++ at work :-(
09:43:59 <bourbaki> Boegel then your dp is wrong
09:43:59 <Boegel> although you may never say that when debugging, right :)
09:44:04 <shapr> Well, I do Python for work, and Haskell for fun.
09:44:36 <shapr> gabor: To be honest, code is like sex, no matter the relative quality, it's still a lot of fun.
09:45:13 <shapr> Compare digging ditches to writing C++, PHP, or even COBOL. I'd still rather code.
09:45:36 <tuomov> much of the more demanding code is already in libraries, and the only challenging part of programming left in businesses is combining those libraries in a good way modulo constraints from above
09:46:19 <shapr> I think there's a *lot* left in the challenging part of programming. I think we're just reaching the infancy of 'notions of computation'
09:46:46 <tuomov> yes, but that is done in universities and as a hobby
09:46:55 <tuomov> not in many companies producing software
09:47:43 <shapr> For example, Linux just barely supports asymmetric multiprocessing, and only with the same flavor of CPU. If it had good support for multi-cpu-arch AMP, you could use your NVidia card as a 'transputer' coprocessor, or stick in an Alpha for massive FPU power.
09:47:46 <tuomov> there are some, but those are in minority in my view
09:48:53 <shapr> I would love to see Linux ported to some of the Xilinx FPGAs.
09:49:04 <Oejet_> The teacher makes me write a parser in Java for a HTTP-like protokol. :'(
09:49:06 <shapr> shades of transmeta...
09:49:17 <shapr> Oejet_: wow, that sounds like fun.
09:49:19 <Boegel> bourbaki, this is 100% right, yes? : 
09:49:20 <Boegel> > dotProd :: Num a => (a,a,a) -> (a,a,a) -> a
09:49:20 <Boegel> > dotProd (x1,y1,z1) (x2,y2,z2) = x1*x2 + y1*y2 + z1*z2
09:49:33 <shapr> Ã“la Asta
09:49:34 <bourbaki> Boegel yes
09:49:37 <Boegel> well, it can't be wrong, because I use it for diffuse and such too
09:49:38 <musasabi> Oejet_: you can do monadic parsing in java, it is just quite painfull.
09:49:38 <shapr> Oejet_: ok, maybe not...
09:49:47 <Boegel> so it's in the def of the different dp's
09:49:50 <Oejet_> shapr: It's the job of a trained monkey. :-)
09:49:51 <shapr> s'true, there is a monadic parser framework for Java somewhere.
09:50:05 <shapr> Oejet_: yes, too true.
09:50:10 <shapr> CS Grad often means that.
09:50:24 * musasabi teached his gf to do small monadic ad hoc parsers for her project in a java prog course.
09:51:10 <Boegel> musasabi, you have a girlfriend ? he's a fraud ! no real coder is allowed to have a girlfriend ! kick him ! :p
09:51:11 <bourbaki> Boegel i think that its the gradients
09:51:28 <musasabi> Oejet_: write a haskell interpreter in java, and use haskell ;p
09:51:30 <Boegel> bourbaki, and I can test that with the (1,1,1) trick ?
09:51:39 <Oejet_> musasabi: I'm writing a recursive decent parser. How do you do a monadic one?
09:51:46 <Philippa> Boegel: dammit, *that's* why I'm having no luck with women? :-)
09:51:52 <bourbaki> sure just change the grad to (1,1,1) always
09:52:13 * Oejet_ thought that Philippa was a woman.
09:52:20 <musasabi> Oejet_: well that is mostly about creating suitable combinators.
09:52:47 <Boegel> bourbaki, I still don't know how old you really are :)
09:53:01 <Oejet_> musasabi: But how do you represent a combinator?
09:53:04 <bourbaki> no one knows you are as old as you feel
09:53:18 <Philippa> Oejet_: I am. I never said I'm straight
09:53:45 <Oejet_> Philippa: True, I never heard you say that. :-)
09:53:46 <Boegel> bourbaki, I feel like 13 between you guys :)
09:54:07 <bourbaki> i feel like 70 usually
09:54:15 <shapr> I feel like 12 usually.
09:54:18 <shapr> 13 on a good day.
09:54:28 <shapr> But I try to act as least 16.
09:55:21 <Boegel> bourbaki, http://studwww.ugent.be/~kehoste/thesisPublic/exPerlinGrad111.png
09:55:36 <Boegel> and with (10,10,10) as gradient: http://studwww.ugent.be/~kehoste/thesisPublic/exPerlinGrad101010.png
09:55:45 <bourbaki> ah right :) thats what i wanted to say
09:56:13 <Boegel> bourbaki, you mean (10,10,10) in stead of (1,1,1) ? 
09:56:15 <bourbaki> now im about sure its your grads
09:56:31 <bourbaki> yes i wanted to have a longer vec
09:56:44 <tuomov> I feel like I'll be 70 tomorrow
09:56:45 <Boegel> bourbaki, this image is okay with the (10,10,10) gradient ?
09:56:48 <tuomov> years pass to fast
09:57:05 <tuomov> no time to do all the interesting things
09:57:12 <shapr> huh, Andy Moran was a chalmerite too?
09:57:27 <shapr> Man, I gotta move to Gothenburg. It's the Haskell Mecca.
09:57:27 <bourbaki> well if you are in the middle you get 8 values about the same size
09:57:44 <bourbaki> Boegel are you interpolateing now or just add and div?
09:57:56 <Boegel> bourbaki, interpolating
09:58:28 <Oejet_> shapr:  This Gothenburg you are talking about, is that Göteborg?
09:58:34 <shapr> Oejet_: yup, same place.
09:58:38 <shapr> GÃ¶teborg
09:58:58 <shapr> The english name sounds pretty strange when I'm used to speaking swedish.
09:59:22 <bourbaki> Boegel thats still strange though
09:59:30 <tuomov> how are you supposed to pronounce the english variation anyway?
09:59:35 <bourbaki> you have these sharp edges all the time
09:59:59 <shapr> It's neat to observe that my notes in Swedish class are slowly moving away from "swedish words - english definition" to "swedish words - swedish explanation"
10:00:15 <Boegel> bourbaki, this is with /8 : http://studwww.ugent.be/~kehoste/thesisPublic/exPerlinGrad101010Div8.png
10:00:19 <shapr> I've never heard anyone say Gothenburg, I learned it on #haskell.se =)
10:00:26 <Oejet_> shapr: Yeah, sounded strange to me too. Ran the hurdles there a couple of times.
10:00:52 <Boegel> bourbaki, those sharp edges could be a dp problem, or not ?
10:01:05 <bourbaki> i think so yes
10:01:12 <shapr> Oejet_: so, are you a CS Student in KÃ¶penhamn?
10:01:18 <Boegel> okay, then I just need to get those fixed...
10:01:29 <Boegel> I have to go now, but I will be back later on the evening
10:01:39 <Boegel> but you'll be drinking cocktails then probably ;)
10:01:40 <bourbaki> ok bye ill go to bed now though
10:01:48 <Boegel> bed ? at 19h ? :s
10:01:53 <bourbaki> no no more cocktails for me for a while
10:02:04 <Boegel> bourbaki, stomache problems ? :)
10:02:06 <bourbaki> yes im tired and hungry but got no money atm to buy some food
10:02:06 <Oejet_> shapr: Well, almost. :-) Informatics at DTU just outside of København.
10:02:31 * Boegel gives bourbaki a cookie
10:02:33 * Oejet_ gives bourbaki a hot pizza slice.
10:02:41 <bourbaki> heh i dont eat sweets either :)
10:02:55 * Boegel hands bourbaki a cookie without sugar
10:02:59 <bourbaki> pizza is good :) the cornerstone of every nutritious breakfast
10:03:22 <Boegel> bourbaki, thanks a lot for the help, now atleast I know where to look for problems :)
10:03:33 <bourbaki> yeah its a bit strange though 
10:03:43 <bourbaki> anyway i bet youll get rid of it
10:03:49 <Boegel> bourbaki, I hope so :)
10:03:55 <Boegel> you'll see/hear it in here ;)
10:03:59 <bourbaki> :)
10:04:03 <bourbaki> nighto
10:04:03 <Boegel> bye for now !
10:04:34 <shapr> Oejet_: How do you like it? Do you learn any FP?
10:10:13 <Spark> whats the difference between inference and deduction?
10:11:52 * Spark digs out dict.org
10:12:01 <tuomov> inference includes induction
10:12:07 <tuomov> (according to dict)
10:12:11 <Spark> mm ok
10:12:23 <Spark> my poor modem connection didnt get there in time :)
10:12:30 <tuomov> apt-get install dict
10:13:04 <Spark> would inference also include proof by contradiction
10:14:09 * ski recalls there's something called "statistical inference"
10:14:52 <tuomov> wouldn't contradiction just be part of deduction/induction rules?
10:15:14 <shapr> Interesting, LinuxQuestions.org interviews the Nvidia Engineers. The net result is a Zero-Content discussion. - http://lwn.net/Articles/110528/
10:17:33 <shapr> hiya Godeke 
10:18:43 <shapr> Hm, neat description of unification from Glynn Clements. "This is essentially "unification". Haskell and ML use it for type inference and for pattern matching, (although pattern matching is always unidirectional, i.e unifying a pattern comprised of both variables and constants with a value comprised solely of constants). Prolog uses it more extensively (variables can occur on either side).
10:23:22 <Spark> cool
10:23:37 <Spark> unification is a partial function in the curry system, right?
10:24:04 <Spark> am i right in thinking its not defined for unify(t1,t2) if t1!=t2 and t1 is included within t2?
10:24:23 <ski> err
10:25:58 <ski> unification takes two terms with variable occurances in them and (maybe) gives a substitution that, when applied to both terms, causes the results to be equal
10:26:07 <Spark> right
10:26:21 <Spark> so the 'maybe' means its a partial function?
10:26:25 <ski> yeah
10:26:35 <Philippa> Spark: yes, you're right
10:26:36 <ski> Term -> Term -> Maybe Subst
10:26:49 <Spark> throws an exception otherwise :)
10:26:52 <Spark> heh ok
10:26:59 <Philippa> if t1 is included within t2, you're asking it to solve a potentially rather scary equation, hence it failing
10:27:10 <Spark> i think im seeing the point of intersection types now
10:27:27 <Spark> you just fill in that blank by saying replace both sides with t1&t2
10:27:47 <Spark> and then define & so that the system is sound?
10:28:08 * ski doesn't recognises this 'curry system' and 'is included in'
10:28:32 <Philippa> ski: 'is included in' amounts to t1 appears in the term for t2
10:28:42 <Philippa> eg trying to unify Int and [Int]
10:29:23 <ski> Philippa : is that sometimes counted as a unification of t1 and t2 ?
10:29:23 <Spark> ski: curry type assignment system for the lambda calculus?
10:29:44 <Spark> thats the first thing on this course :)
10:29:45 <Philippa> ski: where t1 = Int and t2 = [Int] = [t1]
10:30:07 <Philippa> Spark: I've not heard of it. To put this in perspective, the brick book was bedtime reading for me a while back
10:30:20 <Spark> it was for me too
10:30:29 <Spark> there seems to be not much correlation :)
10:30:39 <Spark> the bloke said he was teaching stuff in a different order though
10:30:53 <Spark> so it might be beyond page 78, in which case i wouldnt know about it :)
10:31:09 <ski> Philippa : that seems for me to be more like higher-order unification of (f t1) and t2  (giving f = \t.[t] in this case)
10:31:31 <Philippa> ski: if you're doing first-order unification, it'll fail on that
10:31:52 <Philippa> but yeah, I think ISWYM about intersection types
10:31:53 <Spark> what makes it first order / higher order?
10:32:37 <ski> being able to "match out" higher-order values (i.e. functions, here)
10:32:47 <Spark> ah so a higher order unification would recurse?
10:33:04 <ski> LambdaProlog does higher-order unification (partially :)
10:33:31 <Philippa> Spark: higher-order unification's undecidable for roughly that reason :-)
10:33:53 <Spark> does it not recurse on smaller types each time then?
10:34:03 <Philippa> not in all cases
10:34:15 <Spark> i think i need a definition of unify :)
10:34:26 <Spark> or various flavours of unify
10:34:34 <ski> also, there are not always a most general unifier
10:34:40 <Spark> i have here "robinson's unification algorithm"
10:34:41 <Philippa> "find a value that unifies these two other values"
10:35:01 <Philippa> = first-order unification
10:35:17 <Spark> values?
10:35:21 <Spark> types
10:35:56 <ski> doesn't matter much
10:36:06 <Spark> just terms i suppose
10:36:20 <Spark> so thats just unify(t1,A) t1->A  for all concrete types A?
10:36:46 <Spark> hmm no
10:37:10 <Spark> its defined here to return a substition, which when applied to both types, returns the same type
10:37:17 <Spark> i guess thats the same thing
10:37:39 <Spark> because if you can just stick the type on the end of the expression then and get what you said :)
10:43:02 * Spark loops
10:43:37 <Spark> ski what do you mean by higher-order unification of (f t1) and t2  (giving f = \t.[t])
10:43:58 <Spark> is that unification of actual code, rather than just types?
10:45:06 <tuomov> unification of actual code would seem undecidable to me
10:45:36 <Spark> isnt it just unification of abstract syntax though
10:45:54 <Spark> youre not evaluating or reducing anything i think
10:47:42 <Philippa> think halting problem
10:48:13 <Philippa> "do these functions both terminate in exactly the same circumstances?"
10:48:35 <Spark> is that what unification of code means then
10:49:17 <Philippa> no, but you'd have to know that to know you've got a sucessful unifier
10:49:27 <Spark> why?
10:49:35 <Spark> unifying what? :)
10:51:12 <ski> hm
10:53:07 <ski> unifying (\x.(x*x)+(x*x)) with (\x.(f x)+(f x)) would give the binding f = \x. x*x
10:53:21 <Spark> thost are lambda expressions right?
10:53:25 <ski> yup
10:53:32 <wilx> "\x."?
10:53:37 <Spark> so youre unifying one abstract syntax with another
10:53:46 <ski> yup
10:53:46 <Oejet_> shapr: Sorry, was away for a bit. Had a course about languages and parsing + SML. Now having again as assistant teacher. :-)
10:53:53 <Spark> ok yeah thats the same thing hten
10:53:53 <shapr> I need some sort of mouse/trackball that doesn't require a table... I can put my keyboard on my lap and lie down on my couch. Mice don't work that way.
10:54:11 <ski> (though lambdaprolog actually can use eta and beta rules for equivalence when unifying)
10:54:20 <shapr> Oejet_: Neat,is that how you got into FP?
10:54:32 <Philippa> shapr: the MS optical trackballs're nice
10:54:34 <Spark> it makes sense for any inductive definition of terms then
10:54:36 <Philippa> used to use one when IRCing in bed
10:54:40 <Spark> syntax, or types
10:54:49 <ski> Spark : rightee
10:55:07 <shapr> Ya know, I'd really like a thimble mouse.
10:55:10 <Philippa> these days, IRCing in bed might lead to Damien spanking me...
10:55:11 <Oejet_> shapr: The students suffered very much under SML in the beginning, maybe because of the introduction to Java at semester one.
10:55:12 <Philippa> *thinks*
10:55:14 <shapr> Actually, that would be *really* cool.
10:55:15 <Philippa> hmm... :-)
10:55:29 <shapr> thimble mouse with a tiny ball on the pad of the finger tip.
10:55:39 <shapr> then you could just rub your fingers together to move the mouse around.
10:55:47 <Philippa> Oejet_: the tendancy for uni Java teachers to hype it up as the one true thing really doesn't help...
10:55:56 <shapr> or you could roll your finger around on the desk to move the pointer.
10:56:00 <Spark> shapr: the mouse is for newbies :)
10:56:03 <shapr> hm, would interfere with touch-typing though.
10:56:12 <shapr> Spark: and for browsers, sadly.
10:56:17 <Spark> mm
10:56:22 <Oejet_> shapr: Well learned a bit of SML before beginning Informatics. Just general interest in programming languages.
10:56:30 <Spark> browsers are for newbies :)
10:56:41 <shapr> lambda-the-ultimate.org requires a browser, sadly.
10:56:53 <shapr> as does lwn.net and many other interesting websites.
10:56:56 <Oejet_> IRC are for newbies.  :-P
10:56:57 <Philippa> LtU is for </pred>
10:57:05 <shapr> IRC does not require a mouse.
10:57:18 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, built 2004-10-23)!
10:57:22 <Philippa> strictly speaking nor does web browsing
10:57:31 <shapr> yah, but web browsing in emacs sucks much.
10:57:37 <Spark> i think its down to the fact that functional languages are designed in a sane way, whereas imperative languages are designed by the roll of the die
10:57:38 <Philippa> I've used text mode browsers in anger before
10:57:39 <Philippa> heh
10:57:41 <shapr> and the keyboard accessibility of browsers is realy crap.
10:58:08 <Philippa> yeah, you wear out the tab key faster than a vi user does the esc key
10:58:15 <shapr> yup
10:58:22 <dv> w3m has very good keyboard accessibility
10:58:32 <shapr> though being able to type the partial name of a link in galeon really saves me a bunch of mousing
10:58:47 <Spark> with firefox you can type in the names of the links to select them, which is neat
10:58:48 <Oejet_> Spark: Java wasn't designed much I think.  "There are no pointers".  Yeah, but why do I get a null pointer exception then? ;-)
10:59:01 <Spark> there are no explicit pointers :)
10:59:06 <shapr> Java suXXors.
10:59:12 <Spark> what they really mean is you cant add things to pointers :)
10:59:17 * Oejet_ is up for some Java bashing.
11:00:04 <Spark> the jre is big and slow, java code isnt concise enough
11:00:09 <Spark> cant think of anything else
11:00:10 <Oejet_> Spark: Yeah, and that is what you do in C, C++, etc all the time?
11:00:17 <shapr> JVM doesn't support tail-calls
11:00:28 <shapr> meaning that FP on the JVM is nigh impossible.
11:00:35 <Spark> mm
11:00:45 <Spark> that should be a simple optimisation shouldnt it?
11:00:52 <shapr> should be, sure.
11:00:59 <shapr> talk to Sun
11:02:02 <Oejet_> Containers contains only Objects.  Switch only cases on integers (???!).
11:02:28 <shapr> raw types vs objects - int vs Integer 
11:02:57 <shapr> The minimum unit of Java is a class. Newbies can't just type System.out.println("Hello");
11:03:09 * Oejet_ is off topic.  He knows, and considers looking for a Java channel. ;-)
11:03:22 <shapr> reflective loading kills off the tiny bit of a typesystem Java had in the first place.
11:03:33 <Spark> heh
11:03:40 <Spark> reflection is kinda cool though
11:03:42 <shapr> inner classes must be final.
11:03:45 <Spark> plugin system
11:03:54 <shapr> final variables can be mutable!
11:03:58 <Spark> heh
11:04:08 <Oejet_> The real reason for design patterns are lack of language expressiveness.
11:04:41 <Spark> you always get a mess, no matter what you try and program
11:04:42 <shapr> J2EE contains two different incompatible database layers, each with slightly different syntax and capabilities.
11:04:56 <Spark> heh
11:05:10 <Spark> its for business use though, thats what business users require :)
11:05:31 <shapr> no way man... business use requires delivering functionality on time and under budget.
11:05:35 <tuomov> java is the new cobol
11:05:40 <shapr> heck yeah.
11:05:45 <Spark> whats the new algol then
11:06:31 <Lor> Oh yeah, regarding reflection, I've done some final finishing up of my thesis. The pdf version is especially nice.
11:06:39 <shapr> Java is Write Once, Debug Everywhere.
11:07:11 <shapr> Each jvm is about 99% like the others, and they all have that 1% of difference from each other that makes life exciting.
11:07:30 <Spark> heh
11:10:29 <shapr> Sun recently released a 'pluggable' compiler where you now have access to the parse tree from compiler.
11:10:38 <shapr> But you only get to read it, you can't put it back into the compiler.
11:10:59 <shapr> So, no macros, no syntax extensions, no inlined functions...
11:11:38 <Lor> Nothing forces you to use sun's code.
11:11:48 <Lor> There is plenty of free code for parsing java.
11:12:53 <shapr> Happily, I haven't used Java in the last few months.
11:13:03 <shapr> But I probably will use it in the future :-/
11:14:04 <Oejet_> Oh, and guess what if you later decide to deliver your program in a hierakial package?
11:15:03 <Oejet_> You have to add to every single stupid file where it is in the hieraki.  :-[
11:15:23 <shapr> From my viewpoint, Java was written for managers, it's designed to keep monkeys from shooting themselves in the foot when they use abilities they don't understand.
11:16:01 * Oejet_ feels like a trained monkey when writing a recursive decent parser in Java.
11:16:02 <shapr> I think that's particulary true of private and protected, and that sort of stuff.
11:16:13 <Lor> shapr, recently I've come to understand that that is a very valuable feature.
11:16:18 <shapr> how so?
11:16:37 <Lor> It's better than giving monkeys guns.
11:17:20 <Lor> It's relatively hard to write truly bad code in Java.
11:17:26 * Oejet_ just realised that design patterns are not a solution, but a language workaround.
11:17:31 <tuomov> but all code is bad 
11:17:41 <marcot> Hello.
11:17:50 <shapr> It's also relatively hard to write truly good code in Java.
11:17:58 <Lor> Impossible, I'd say.
11:18:09 <shapr> Ã“la marcot 
11:18:14 <Spark> im much happier having the fundemental being the function, rather than the class
11:18:16 <marcot> I'm trying to understand the list function from the parse example in Thompson's Haskell book, but I'm having some problemms.
11:18:30 <shapr> So, I'd rather give guns to the monkeys, and let them clean themselves from the programming genepool.
11:19:13 <Lor> I woudn't, when they are all around me. :)
11:19:43 <wilx> :))
11:19:47 <shapr> What's the url to your thesis in pdf?
11:19:49 <marcot> b, [a])
11:19:54 <marcot> sorry...
11:20:01 <Lor> The same as before.
11:20:02 <shapr> marcot: what's your question?
11:20:07 <shapr> ah, ok.
11:20:08 <Oejet_> Give them sniper rifles then, so they won't miss their feet. :-)
11:20:38 <marcot> I don't know why, when I type ( in my mozilla browser it makes the whole line clean.
11:20:43 <shapr> After working with a bunch of codemonkeys, I realized that Java is nowhere close to enough to keep them from shooting themselves in the foot.
11:20:54 <marcot> shapr: do you know this example from this book?
11:21:03 <Lor> It's not just the language, it's also the coding conventions.
11:21:06 <shapr> I do not, but if you have a coherent question, I will try to answer it.
11:21:13 <Lor> Few languages have such universal coding conventions as Java.
11:21:20 <marcot> shapr: I'm not understanding why the list function finishes.
11:21:40 <Oejet_> Lor, what conventions?
11:21:42 <marcot> shapr: from an first look, I'd say that it's an infinite function.
11:22:16 <tuomov> never having worked with codemonkeys, I've realised I don't want to. Not because of the codemonkeys themselves, but how they are managed.
11:22:32 <wilx> Mmm.
11:22:38 <shapr> Even so, these monkeys wrote code where... Everything was static, no use of instances, as they didn't understand OOP. The main class called the GUI form, the form called the database, the database wrapper directly updated fields in the GUI form.
11:22:47 <Spark> tuomov: YES
11:22:50 <marcot> shapr: this is the function : list p :: Parse a b -> Parse a b ; list p = (succeed []) `alt` ((p >*> list p) `build` (uncurry (:)))
11:22:56 <shapr> marcot: what code are you talking about? 
11:23:01 <Spark> its when the management are lower in the clueorder than the codemonkeys themselves
11:23:08 <Spark> that you have a fuckup waiting to happen
11:23:09 <wilx> I have only one experience with coders management as one of the "managees" and it is not good.
11:23:24 <marcot> shapr: the parser example from the 16 chapter of Thompson's book.
11:23:26 <wilx> It seems to me that managers usually don't know what they want.
11:23:26 <Spark> and then the people who have the clue are hte ones who invest personal suffering in sorting it out, ultimately
11:23:52 <marcot> shapr: where Parse a b = [a] -> (b, [a])
11:24:15 <tuomov> If programmers managed themselves, the skillfull programmers would have a far better chance of influencing the outcome of the project
11:24:18 <shapr> Seems to me that managers should be 'underneath' their employees. It is the job of the managers to get as many obstacles as possible out of the way of the workers, so that the workers can actually do stuff.
11:24:38 <tuomov> All "leaders" should be responsible to the workers, imho.
11:24:46 <marcot> shapr: so it's a function that takes a function as a parameter and returns another function.
11:24:48 <shapr> marcot: that's both too much and not enough data :-)
11:24:57 <shapr> marcot: well, that's pretty normal...
11:25:01 <shapr> look at flip for example.
11:25:05 <shapr> @type flip
11:25:06 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
11:25:11 <marcot> shapr: yes, but I don't see where's the end of the recursion.
11:25:14 <wilx> tuomov, imho programmers are lazy by nature, without management and somebody who would be prodding them constantly there would be no products.
11:25:26 <wilx> Just toy programms :)
11:25:37 <tuomov> and how do we have so much of quality free software?
11:26:01 <shapr> marcot: there's an explicit base case in the code you just pasted.
11:26:06 <ski> marcot : in the same way as "from n = n : from (n+1)" works   (e.g. when calling it as "take 10 (from 0)")
11:26:07 <wilx> May OSS developpers are imho paid people.
11:26:12 <wilx> And also manged.
11:26:16 <wilx> managed even
11:26:23 <Oejet_> tuomov: Big corporations releasing source?
11:26:31 <shapr> Hm, I disagree. I think people have the same quality standards whether they're being paid or not.
11:26:33 <marcot> ski: but in this case the function ends.
11:26:51 <marcot> shapr: what base case?
11:27:08 <shapr> Look at bringert's XmlRpc library, or Philippa's Flippi code. Their code is elegant and well-written.
11:27:13 <tuomov> when people are paid, they may not have time for quality code
11:27:26 <tuomov> although they would otherwise prefer to do so
11:27:29 <shapr> I've seen quite a bit of bringert's code, and his is always that way.
11:27:53 <shapr> marcot: (succeed [])
11:28:41 <marcot> shapr: the `alt` function concatenates.
11:29:01 <marcot> shapr: so it'll ever have an empty tuple in the beggining.
11:29:11 <marcot> shapr: but I'm understanding it now..
11:29:31 <shapr> ok
11:29:41 <marcot> shapr: in >*> it breaks the input in (x : xs)
11:30:21 <shapr> alt in a parser usually means try the first, and then the second.
11:30:54 <wilx> I didn't say that they cannot write nice code unless managed. I wanted to say that unless managed or really really interested in subject programmers tend to be too lazy to produce anything useful.
11:31:00 <marcot> shapr: that's because this list function makes a list of possibilities.
11:31:13 <marcot> shapr: so doing this in this context is concatenate.
11:31:26 <shapr> ok, I take your word for it :-)
11:31:41 <wilx> Well, based on observation of myself :)
11:31:42 <marcot> =)
11:31:46 <marcot> Thanks.
11:32:28 <shapr> wilx: yes, so the secret is just what Paul Graham says... don't do anything you're not interested in, and always do the best job you can.
11:32:33 <Lor> shapr, did you try out the pdf? In acroread?
11:33:08 <shapr> not yet...
11:33:10 <wilx> Hmm... Does everybody has the luxury of doing what they are interested in?
11:33:17 <shapr> I'm writing a vicious riposte on LWN.net
11:33:21 <Lor> Ah.
11:33:29 <wilx> It could be too hard to find yourself a job that is both interesting and well paid.
11:33:43 <shapr> someone said the Postmaster config file looks painful to administer.
11:33:55 <shapr> wilx: I agree, therefore I am happy and poor =)
11:33:57 <Lor> Well, just check out the bibliography. I think it's pretty neat (I think all pdf versions of papers should be the same way)
11:34:05 <shapr> ok, I'll look at it now.
11:34:08 <wilx> :)))
11:35:12 <Spark> coding is a hobby as well as a profession
11:35:33 <Spark> its generally worse in a business because a) youre working to a deadline and b) you dont give a shit
11:36:06 <shapr> Lor: whoa, that is smooth.
11:36:20 <Oejet_> Lor: Can I see, too?
11:36:22 <Spark> lor: url?
11:36:27 <shapr> Spark: I think that's an industry problem.
11:36:30 <shapr> hej cm_
11:36:38 <shapr> http://www.cs.helsinki.fi/u/lealanko/alanko04types.pdf
11:36:47 <cm_> hej
11:36:49 <shapr> gruÃŸgott HET2 
11:36:51 <tuomov> "nice job" is almost an oxymoron in the system of authoritarian corporations
11:37:09 <shapr> I think it really can work
11:37:16 <Spark> "professional" has a very precise meaning for me :)
11:37:39 <shapr> The whole idea behind extreme programming is that both the sales and the coder guys should be given an opportunity to do the best job they can.
11:38:25 <shapr> There are two 'Bill of Rights' lists in one of the XP books, one for programmers, one for managers.
11:38:36 <Spark> heh yeah thats in my SE lecturenotes
11:38:45 <segphault> Lor: nice looking. what did you use to generated the pdf?
11:38:55 <shapr> hiya segphault, wassup?
11:39:25 <segphault> shapr: not much today. just been reading all the amusing insights about the insidious nature of java. =}
11:39:27 <Lor> Just pdflatex and hyperref.
11:39:32 <shapr> One of my favorites is that the programmers give out the deadlines, not management or marketing.
11:39:38 <Spark> if its a phd thesis though, it will contain errors, its always the way :)
11:39:48 <Lor> No, it's an MS thesis.
11:39:59 <Spark> ah k
11:39:59 <shapr> There's nothing worse than being given both a goal and a deadline.
11:40:00 <Lor> Just a bloated one.
11:40:09 <segphault> typed reflection is a great topic
11:40:12 <Spark> ill be doing one of them in 7 months time
11:41:15 <shapr> This is funny - http://lwn.net/Articles/110640/
11:42:02 <segphault> LOL
11:42:44 <shapr> Also, nice to know that Duncan Coutts reads lwn.net.
11:43:02 <Spark> haha
11:43:30 <swiert> shapr: nice bit on LtU.
11:43:50 <shapr> swiert: yah, I'm advertising for Utrecht :-)
11:44:08 <shapr> As soon as I saw it, I had to put it up. EHC is a great idea.
11:44:10 * Igloo gets reminded of "That's no moon"  :-)
11:44:23 <shapr> Did you see the earlier post about a Scheme compiler in 90 minutes?
11:44:26 <Igloo> EHC is the thing I thought was called UHC, right?
11:44:33 <swiert> yep - free publicity is always good.
11:44:55 <shapr> good question, EHC == UHC?
11:45:24 <swiert> Igloo: well Atze started out writing a Haskell compiler (initialy called the UHC), but at some point it the code size and complexity exploded.
11:45:44 <swiert> the EHC started from scratch and leart from the mistakes.
11:46:01 <Igloo> So UHC is dead?
11:46:31 <swiert> Igloo: it's not actively developed that I know of.
11:49:05 * shapr viciously stabs more people on lwn.net
12:01:05 <Igloo> ?
12:01:31 <Spark> hes got an evil streak
12:02:23 <shapr> I see the occasional comment on lwn.net that appears clueless to me. Usually I just ignore them.
12:02:32 <shapr> Sometimes, like this evening... I challenge their assumptions.
12:04:52 <shapr> "I have not run extensive tests, mostly for the lack of any findable benchmark programs."
12:05:00 <shapr> How can I improve that sentence? Any suggestions?
12:05:10 * shapr is editing the Postmaster README
12:05:13 <aj> s/findable/available/
12:05:21 <shapr> Ah, thanks.
12:05:23 <aj> s/for the/due to the/
12:05:46 <aj> you could drop "any" too
12:05:55 <shapr> "I have not run extensive tests, due to the lack of available benchmark programs."
12:06:00 <shapr> Yes, that's clean, thanks!
12:06:05 <Lor> drop the comma.
12:06:11 <shapr> ah, excellent point.
12:06:20 <Spark> s/due/because of/ ?
12:06:37 <Spark> s/due to/because of/ ?
12:06:44 <shapr> nah, I like 'due to'
12:06:52 <Spark> mmk
12:07:01 <shapr> but you can patch the Postmaster README too if you prefer it the other way =)
12:07:07 <Spark> i think theyre semantically equivelant
12:07:09 <Lor> s/the lack/a dearth/
12:07:09 <shapr> just grab the darcs repo and send in patches
12:07:16 <shapr> hah, dearth is a good word.
12:07:36 <shapr> But, some people may not know it, so I'll skip it.
12:07:43 <Lor> Bah. I used "nigh" in my thesis. :)
12:07:57 <shapr> yah, but this is a README file!
12:08:12 <shapr> People from Korea with very little clue about English won't know dearth.
12:08:29 <shapr> Heck, people from the US with very little clue about English won't know dearth!
12:08:31 <Lor> Oh, you mean it's actually intended to be understandable? So sorry, such a novel concept. :)
12:08:44 * shapr snickers
12:09:22 <Lor> Oh, there was this great Calvin and Hobbes -strip I just read yesterday...
12:11:41 <Lor> Bah, can't find it off the net.
12:12:22 <Lor> http://www.wac.ohio-state.edu/tutorials/bestpractices/calvin-writing.htm
12:16:19 * shapr grins
12:16:26 * shapr kicks postfix in the nuts
12:21:05 <Spark> Lor: hehe
12:24:08 * Oejet_ ponders over another little handy English word.  Not e.i. or sic, but something cool sounding and not very used.
12:24:27 <Lor> e.i.?
12:24:39 <shapr> yah, i.e. is latin, so is sic
12:24:42 <shapr> vice versa
12:25:39 <Oejet_> No, no.  Argh, I can't remember.  It was so cool, and meaning something very ordinary but sounding very pristine.
12:25:41 <Lor> viz?
12:25:49 <Oejet_> Yeah, that's it, Lor!
12:25:53 <Oejet_> Thanks.
12:27:10 * Oejet_ saw sic in the teachers comment in an English paper and thought it was a misspelling of sick. :-)
12:28:07 <Spark> i feel tired
12:28:17 <Spark> maybe i should play a computer game or somethng
12:28:22 <Spark> trying to work is unproductive
12:28:23 <ibid> of course, there is ibid., loved by all in the academia :)
12:28:53 <shapr> Spark: try TDD!
12:28:58 <Spark> whats tdd?
12:29:12 <shapr> test driven development
12:29:19 <shapr> works wonders for productivity
12:30:16 <Spark> oh, like in XP
12:30:17 <Oejet_> shapr: Really? Test THEN implement, or what?
12:30:24 <shapr> yep, that's it.
12:30:32 <Spark> that would require some tests
12:31:08 <Spark> what we're developing here is my understanding of type theory :)
12:31:28 <Spark> im going to get some caffeine-rich fluid
12:31:40 <Oejet_> shapr: Guess that would work well with a strict specification.
12:31:59 <shapr> It works well without strict specs too.
12:32:30 <Oejet_> shapr: Why?
12:33:16 <shapr> The test works like a question, the code like an answer. When the test passes, you're done. More pressure is put on the API, the code already has a 'first user'
12:33:31 <Spark> is the question correct though :)
12:33:42 <shapr> Sometimes it isn't
12:33:51 <Spark> if the test is written by a different person, you end up with interesting discussions
12:33:54 <shapr> But then you usually find out quickly.
12:34:16 <shapr> step zero is to refactor your code with the next test/code cycle in mind.
12:35:10 <shapr> I usually start with a single top level test that fails. Possibly 'assert typecheck "1" == Num'
12:35:42 <shapr> Then I write the next test down, "assert eval "1" == 1" or something.
12:35:59 <Spark> you can do that implicitly though
12:36:16 <Spark> 'i need to write code that behaves like so' --> implement
12:36:23 <Spark> and then demonstrate
12:36:36 <Spark> then the test is wetware i guess :)
12:37:00 <Spark> it might be useful to have a permenant record
12:37:02 <shapr> Writing the test first gives you a small and manageable goal that you can accomplish in the next five minutes.
12:37:14 <shapr> Having the tests means you can trust that the code you wrote last year still works.
12:37:39 <shapr> Having excellent test coverage means you can refactor like mad and totally rearchitect your program without fear.
12:38:07 <Spark> when doing these little prolog assignments, ive had a spec.ps, a solution.pl and a test.txt, the test.txt being full of things that go "yes" or "no" depending on whether its correct, these being derived directly from the examples in the spec
12:38:07 <Lor> Tests are poor man's specifications.
12:38:35 <shapr> Lor: see, I think specs are a poor man's tests ;-)
12:38:42 <Spark> works great until you have to test predicate sideeffects :)
12:39:07 <tuomov> tests are proofs of the incapable
12:42:41 <Spark> this train is making an awful noise, i hate living next to a train track
12:43:02 <Spark> </whinge>
12:43:05 <Spark> (its gone now)
12:43:27 <Spark> i want to code but i have too much computer science theory work to do
12:43:43 <Boegel> @seen bourbaki
12:43:43 <lambdabot> I saw bourbaki leaving #haskell 2 hours 12 minutes 43 seconds ago.
12:44:00 <Spark> i wonder if im not good enough for this course, or if its supposed to be occupying most of my time, or if perhaps i sit on irc too long
12:44:06 <segphault> @seen elvis
12:44:06 <lambdabot> I haven't seen elvis
12:44:12 * segphault chuckles
12:44:30 <Spark> @seen the_light
12:44:30 <lambdabot> I haven't seen the_light
12:45:15 <Spark> shapr: what is a basis?
12:45:27 <Spark> or a base, is it called
12:45:43 <Spark> something to do with principal pairs, unification, etc
12:47:02 <Spark> ah, its part of the principal pair?
12:48:40 <Spark> if motivation was available in liquid form, i would have a pipeline installed to my house
12:51:24 <shapr> drink coffee!
12:51:32 <Spark> proprietory foodstuffs are worse than narcotics - at least if i wanted to, i could learn how to make cocaine on the cheap :)
12:51:42 <Spark> ah yeah i dont like coffee unfortunately
12:51:47 <Spark> i do quite like coke though
12:52:02 <segphault> aderol is the greatest thing ever invented
12:52:05 <Spark> as in the drink coke
12:52:17 <Spark> whats that?
12:52:25 * shapr grins
12:52:26 <segphault> prescription amphetamine
12:52:31 <Spark> oh heh
12:52:36 <shapr> ADDerol is not amphetamines
12:52:40 <Spark> is the comedown really crap though
12:52:52 <segphault> shapr: aderol is an amphetamine, look it up
12:52:57 <shapr> ADDerol is a blend of methylphenidate and methylphenidate salts.
12:53:17 <shapr> Dude, I have a prescription, I know what it is =)
12:53:30 <segphault> its a dextroamphetamine
12:53:36 <segphault> I have a prescription for it too. ;-D
12:53:41 <Spark> i got hold of some prescription antidepressents once, they were good fun
12:54:10 <Spark> bit drowsy though
12:55:08 <segphault> shapr: http://www.medicinenet.com/amphetamine_and_dextroamphetamine/article.htm ("DRUG CLASS AND MECHANISM:  Amphetamine and  dextroamphetamine")
12:55:29 <shapr> segphault: ah, my mistake, I was talking about Concerta. I no longer have an ADDerol prescription.
12:55:37 <segphault> ah
12:56:34 <shapr> I've written about that sort of stuff on http://c2.com/cgi/wiki?AttentionDeficitDisorder and http://c2.com/cgi/wiki?RitalinDrug
12:56:50 <Spark> ah is it a treatment for add?
12:56:54 <shapr> yup.
12:57:02 <Spark> doesnt it have the opposite effect to that required? :)
12:57:09 <shapr> Nope.
12:57:29 <shapr> Amphetamines put me to sleep.
12:57:44 <Spark> weird
12:58:17 <segphault> I have OCD. aderol works like a stimulant on me - it has never effectively diminished my symptoms, but it is so incredibly beneficial in other ways, I keep taking it anyway
12:58:29 <Spark> heh
12:58:35 <Spark> any comedown though?
12:58:44 <Spark> thats the bad thing about stimulants
12:58:46 <segphault> yeah, but thats what weed is for
12:58:52 <Spark> heh
12:58:56 <Spark> its not a drug, its a herb, right? :)
12:59:04 <segphault> what?
12:59:10 <shapr> I don't have any comedown from Concerta. I just get bouncy again.
12:59:13 <Spark> thats what people say
13:00:04 <Spark> the worst thing ive had is probably ketamine :)
13:00:12 <kristnjov> http://www.microstore.se/VisaProdukt.asp?ProduktID=260&GruppID=26
13:00:17 <Spark> for some reason i was on a mission to get slagged that weekend though
13:00:41 <segphault> i've never tried ketamine
13:00:43 <Oejet_> You talk so much about drugs, that even raver had enough and left. :-P
13:01:02 <segphault> I've experimented with a lot of obscure psychadelics tho. I'm particularly fond of absinthe
13:01:07 <shapr> I stay away from non-prescription drugs. Quitting smoking was one of the hardest things I've ever done.
13:01:28 <shapr> I still want a cigarette, three years later.
13:02:01 <kristnjov> and i, three hours later, STILL feel the craving
13:02:02 <Oejet_> kristnjov: Lol.
13:02:19 <segphault> lol
13:02:42 <shapr> I'd rather obsess about code. Programming has better long-term effects.
13:02:45 <segphault> I quit cigarette smoking a while ago. I only have cravings when I dont have enough of something else in my blood stream
13:03:14 <Spark> nicotine is a bit evil though
13:03:19 <kristnjov> i'm kind of a sugar addict, but i'm not diabetic.. my dad is though, i'd bet i'll get it when i get older
13:03:22 <Spark> its up there with cocaine and heroin :)
13:03:40 <shapr> Yah, I like sugar a bit too much myself.
13:03:40 <Spark> i suspect the long term effects of club ecstacy pills are worse than cigarettes though
13:03:52 <segphault> I imagine so.
13:04:04 <segphault> I would love to get my hands on some good, clean, lab produced mdma
13:04:04 <shapr> Don't you worry about killing your brain cells?
13:04:13 <Spark> yeah i do
13:04:19 <segphault> I dont
13:04:21 <Spark> i also worry about having a good time though
13:04:39 <Spark> you end up with seretonin deficiency, requiring prescription drugs
13:04:40 <shapr> Gee, I can have a good time just reading and writing code. I guess I'm lucky.
13:04:44 <segphault> I'd rather have 30 years of intense fun, joy and creativity rather than 60 years of tedious boredom
13:04:56 <shapr> There's a third option you know...
13:05:00 <Spark> 45 years? :)
13:05:01 <shapr> 60 years of fun, joy, and creativity.
13:05:31 <shapr> C'mon, look at arrows... There's a rush :-)
13:05:47 <ski> 60 years, all with Haskell !
13:05:51 <Spark> my first experience on mdma was so good, ive never come anywhere near it, despite ingesting nearly 10x the quantities :)
13:06:05 <Spark> its all delusion though
13:06:29 <Spark> its better to be rationally happy
13:06:39 <shapr> See, I lump that sort of stuff in with online gaming, it feels good when you're doing it, but afterwards it doesn't do anything for you.
13:06:47 <Spark> bit like love :)
13:06:51 <segphault> lol
13:07:03 <Spark> i knew it, youre all goths
13:07:08 <shapr> Code lasts a long time. New people use your code and are happy, or they send you improvements, and you are happy.
13:07:31 <shapr> Or you use your own code and it saves you time and cuts down on the boring part of working.
13:07:40 <segphault> shapr: I think that some of the experiences I have on drugs have a very positive, lasting impact on my life.
13:08:03 <shapr> Code can have a positive lasting impact on many people's lives.
13:08:19 <segphault> I truly believe that psychedelic introspection has made me a better, more complete person.
13:08:50 <shapr> Well, ok. I don't think it would be a positive thing for me though.
13:08:54 <Spark> heh
13:09:05 <Spark> i figured it all out... on drugs
13:09:19 <Spark> exploration can only be good though
13:09:29 <Spark> making a habit of it, thats a different thing
13:09:39 <segphault> most people serve the tedium of necessity and dont try to see beyond the facades they erect around themselves. My experiences have helped me to discover who and what I really am
13:09:57 <Pyoko> [amsg] Gone: Shower
13:10:02 <shapr> Serving the tedium of necessity has never been a problem for me.
13:10:25 <Spark> i dont think thats true
13:10:30 <segphault> I wouldnt say that drugs are right for everybody, some people feel that, as candide discovered, "the best of all possible worlds exists in the tedium of daily chore."
13:10:32 <Spark> you dont have bills, bank accounts, credit cards? :)
13:10:39 <Spark> you dont need to buy food and drag it home
13:10:41 <shapr> Spark: no, not really.
13:10:56 <shapr> Not that either.
13:11:18 <Spark> which utopian pacific island do you live on? :)
13:11:19 <shapr> But, daily chores don't have to be tedium.
13:11:29 <segphault> I get frustrated with the mundane. I need transcendent introspection, and without it, I probably wouldnt feel that my life was worth living.
13:11:30 <Spark> i normally do them to avoid work
13:11:49 <Spark> actually i did comment before that youre always in a good mood didnt i
13:12:02 <shapr> I get frustrated with the mundane too, so I search for mental toys.
13:12:17 <shapr> Yes, you did mention that.
13:12:19 <segphault> when I'm tripping, EVERYTHING becomes a mental toy
13:12:49 <Spark> anyway you are both arguing about the other's mutually exclusive perspective :)
13:12:52 <shapr> Everything already is a mental toy if you look at it from the right viewpoint.
13:12:56 <shapr> yah, true.
13:13:11 <shapr> segphault: I agree, you may be right. But I haven't come around to your viewpoint if you are.
13:13:17 <tuomov> I get frustrated when I have to do trivial work or when I try to think what I want to do when I'm big.
13:13:32 <shapr> Can you automate the trivial work?
13:13:47 <tuomov> not of the boss says you have to do it in a particular way?
13:13:54 <shapr> For the trivial work that I can't automate, I try to do a bunch of it all at the same time.
13:14:06 <tuomov> and I count a lot of things as trivial
13:14:31 <tuomov> like writing a once-used script to convert data from format to another
13:14:43 <tuomov> (that I used to do quite a few times in my ex job)
13:15:14 <shapr> Sounds like an opportunity to write some conversion tools.
13:15:34 <Spark> ohhhh the basis is the set of free variables in the expression, which when combined with the type of the expression becomes the principal pair
13:15:49 <shapr> I usually follow the third strike principle. The third time I was asked to convert data, I'd write tools to automate as much of it as possible.
13:16:25 <tuomov> doesn't work if the data is always in different obscure format
13:16:34 <tuomov> and in any case, it is a waste of my time
13:16:40 <shapr> Maybe you could write a minilanguage?
13:16:49 <Spark> i would like that
13:16:56 * shapr thinks
13:16:57 <Spark> its possible to do some very complex conversions with vim
13:17:11 <Spark> using the find replace feature, and the \1 \2 \3 part of regexps
13:17:19 <Spark> good for renaming mp3s, for example
13:17:22 <shapr> Something like the parameterized show idea might be good for a minilanguage.
13:17:36 <shapr> zsh has zmv that does stuff like that.
13:17:52 <shapr> I do enjoy writing that sort of thing interactively in ghci also.
13:18:04 <segphault> Spark: I used to use vim for that kind of thing, but recently, i've discovered that ruby is faster and has better syntax for it
13:18:23 <tuomov> in any case, I could frustrated when I'm ordered to do such trivial tasks
13:18:29 <tuomov> I need something to really think on
13:18:33 <shapr> yah, I understand that.
13:18:40 <tuomov> s/could/get/
13:18:48 <Spark> this is what i do to rename a bunch of mp3s:
13:18:54 <shapr> "The Pragmatic Programmer" says "THINK! about your work."
13:18:57 <segphault> thats why I always try to automate, even if it isnt exactly practical. its more entertaining
13:19:14 <Spark> shapr: interactivity is the future :)
13:19:17 <tuomov> and thus I should just start graduate studies, because I don't I'll get to do any challenging things in a company
13:19:29 <Spark> http://rafb.net/paste/results/YBKoVb42.html
13:19:33 <tuomov> if I could just decide in what exactly...
13:19:34 <Spark> this wasnt my idea though i have extended it
13:19:39 <shapr> I interpret that to mean that I should be looking for higher order patterns in anything I do, and that there might be hidden interesting problems there.
13:19:55 <Spark> the purpose of the rot13ing is to allow search/replaces that only match the target of the mv instruction
13:20:40 <segphault> Spark: you could probably reduce that to one line with ruby
13:21:01 <shapr> I don't understand the goal?
13:21:13 <Spark> shapr: you edit script with vim
13:21:21 <Spark> to change all the names to what you want, and then fire it off
13:21:31 <Spark> its less typing for a large number of similar changes, and a large number of files
13:21:39 <Spark> segphault: reduce what to one line?
13:21:43 <Spark> the script or the script generator
13:21:57 <segphault> Spark: you could do the same task with one line
13:22:07 <Spark> which task :)
13:22:09 <Spark> there are two tasks
13:22:15 <shapr> explain the tasks
13:22:28 <shapr> what do you want to do to those multiple hello world files?
13:22:33 <Spark> rename them
13:22:37 <segphault> Spark: dir rename
13:22:38 <shapr> to what?
13:22:46 <Spark> something different :)
13:22:55 <Spark> maybe you want to capitalise the words
13:23:03 <Spark> so you go through the file hitting ~ in the right places
13:23:07 <Spark> and then :wq ./script
13:23:16 <shapr> oh I see.
13:23:35 <Spark> the alternative is typing mv <source> <dest> each time at the prompt
13:23:37 <shapr> I'd probably use dired in emacs, or a shellscript.
13:23:43 <Spark> or using some gui tool
13:23:47 <shapr> ick :-)
13:23:49 <segphault> if I wanted to capitalize names:  Dir["."].each {|x| `mv #{x} #{x.upper}`}
13:24:45 <Spark> what if someone has mp3s like "album - tracknum - arist - track.mp3" and you want them like "artist [album-tracknum] - track.mp3"
13:24:49 <Spark> how would that look
13:25:25 <shapr> I'd use a shellscript
13:25:39 <shapr> or sed if I'm feeling cruel =)
13:25:42 <Spark> thats obviously harder though
13:25:49 <ski> some kind of patter-matching could be useful, here
13:25:51 <shapr> nah, cut at the spaces
13:25:58 <Spark> than just doing a single find/replace in vim
13:26:14 <tuomov> I have a similar scripts, but it launches an editor only to edit the target names
13:26:30 <Spark> ah now that would probably be better
13:26:42 <Spark> i have one that renames the output of cdparanoia based on a simple definition file
13:26:47 <segphault> Dir["."].each {|x| f = x.split(" - "); `mv #{x} "#{f[2]} [#{f[0]}-#{f[1]}] - #{f[3]}"` }
13:27:23 <shapr> segphault: can you do it better in Haskell? =)
13:27:38 <Spark> thats nice
13:27:44 <Spark> is ruby good for sting processing then?
13:27:47 <segphault> shapr: I dont know haskell well enough yet, but I know that something like that would be like 30 lines in ocaml
13:27:53 <shapr> eek
13:27:59 <segphault> Spark: yes and no
13:28:17 <segphault> Spark: ruby has an insanely cool object model, and it has really nifty sugar for iteration and string manipulation
13:28:22 <segphault> Spark: but its not terribly fast
13:28:26 <shapr> I can do that same thing in Python in about the same amount of chars, but doing it in Haskell would be niftier.
13:28:39 <segphault> Spark: its like perl, but not stupid
13:28:44 <Boegel> can someone tell me what (int)t does in c/c++ ?
13:28:45 <shapr> it has explicit END though
13:28:47 <shapr> and that makes me ill
13:28:50 <Spark> what if the splitting strings were all different
13:28:59 <Boegel> does it cast t to an integer ? and so (int)3.6 would be 3 ?
13:29:09 <Spark> how would it look if you pattern matched with a regexp
13:29:11 <Spark> like i do in vim
13:29:26 <segphault> Spark: ruby has built-in syntax for regexp, like perl, but slicker
13:29:31 <shapr> I really like significant whitespace.
13:29:55 <segphault> Spark: "this is a string"[/regexp-goes-here/]
13:30:10 <tuomov> I dislike regex sugar
13:30:15 <Spark> and that returns true/false?
13:30:20 <Spark> what about the find/replace version
13:30:24 <segphault> Spark: that would clip out a regexp
13:30:25 <Spark> [s/blah/blah] ?
13:30:32 <shapr> How would you do this same task in Haskell?
13:30:36 <Spark> ah ok
13:30:39 <tuomov> there should be a nice and simple core syntax and everything build around that using functions
13:30:44 <Spark> thats like a specialisation
13:30:53 <shapr> tuomov: yah, I agree with that.
13:31:02 <Spark> then it extends to other datatypes :)
13:31:10 <kimmell> Does anyone here have some experience with concurrent haskell and be willing to help me out with a couple of questions?
13:31:29 <segphault> Spark: I dont like using regexps, I typically use gsub to replace, but ruby probably has sugar for it
13:31:30 <shapr> kimmell: ask your questions
13:31:45 <kimmell> thanks shapr
13:31:57 <segphault> Spark: and ruby is very mutable so you could very easily overload an operator in the default string class to do replacement with regexp if you wanted ot
13:32:11 <tuomov> ruby doesn't have first-class functions afaik
13:32:12 <kimmell> i have a concurrent program that i *think* has a lot of lock contention, but I'm not sure
13:32:20 <tuomov> that "lambda" above is a special construction for iterators
13:32:23 * shapr looks at System.Directory
13:32:33 <segphault> Spark: ruby is great for cgi and scripting, but I wouldnt use it for a "real" program. if you are interested you can read the book: http://phrogz.net/programmingruby/
13:32:39 <tuomov> python and lua otoh have first-class functions
13:33:06 <Spark> whats a first class function?
13:33:07 <shapr> I think Haskell can be used for cgi and scripting too.
13:33:14 <kimmell> I'd like to find some way to find out how much time I'm spending blocked on an MVar, but the profiler isn't much help
13:33:35 <segphault> tuomov: you can do lambdas in ruby for other things besides iterators: Proc {|x| blah }
13:33:40 <Philippa> shapr: it's not wonderful for CGI atm, but that's a matter of lib support
13:33:49 <tuomov> spark: functions can be passed around just like any other objects, and they remember their scope
13:33:54 <Spark> ah ok
13:34:01 <Philippa> and yeah, Haskell would be my first choice for script-type stuff
13:34:05 <Spark> hmm
13:34:11 <kimmell> anyone have any suggestions for getting this sort of information about a concurrent program?
13:34:12 <Spark> just funciton pointers then?
13:34:17 <Philippa> largely because I trust myself to get it right, and to understand WTF the script does the next time I read it
13:34:17 <tuomov> segphault: but can you return the "lambda" from the other function?
13:34:17 <Spark> or am i missing something here
13:34:31 <Philippa> yeah
13:34:38 <segphault> tuomov: yes
13:34:47 <Philippa> the bit where any local variables from enclosing scopes are carried with the function
13:34:51 <segphault> tuomov: you can pass around functions/methods in ruby, it just looks ugly and is a pain in the ass
13:35:04 <Philippa> otherwise you couldn't write eg \x->(\y->x+y)
13:35:07 <Spark> what does it mean 'carried with'
13:35:14 <Philippa> because the x wouldn't be in the second function's scope
13:35:18 <tuomov> function a(x) return function(y) return x+y end end
13:35:20 <Philippa> pretty much literally
13:35:24 <tuomov> does that work in ruby?
13:35:29 <tuomov> from what I've read, no.
13:35:39 <segphault> tuomov: no
13:35:47 <Philippa> you get a structure containing a function pointer and an environment, or optimisations thereof
13:35:53 <segphault> tuomov: that doesnt, but you could do the same thing with different syntax
13:36:10 <tuomov> how would you do that?
13:36:23 <tuomov> some object trick?
13:36:24 <segphault> tuomov: I honestly couldnt do it off of the top of my head, but it can be done
13:36:29 <segphault> tuomov: yeah
13:36:33 <Spark> hmm
13:36:34 <tuomov> yeah. no first-class functions.
13:36:40 <segphault> tuomov: as I said, you can do it, but it aint pretty.
13:36:45 <Spark> so youre defining a funciton in the middle of the body of another function there
13:36:46 <segphault> tuomov: right
13:37:01 <Philippa> Spark: bingo
13:37:08 <tuomov> Spark: yes, and returning it from it, and it remembers its scope (x)
13:37:22 <Philippa> tuomov: I'd say its environment rather than its scope
13:37:35 <tuomov> yeah, maybe that's a better term
13:37:43 <Spark> oops just spilt coke on a power brick
13:37:50 <Spark> and had to unplug it quick :)
13:38:03 <Spark> so yeah is that all they are
13:38:27 <Spark> its a prerequisite that you can define a function anonymously then
13:38:37 <Spark> at runtime, as it were
13:38:56 <Spark> within another function
13:38:59 <Spark> it makes no sense otherwise
13:39:05 <ski> runtime constructed environment
13:39:08 <Spark> you have to be within a block of code, thats what im trying to get at
13:39:40 <Philippa> outside a block you just have a null environment, but yeah
13:40:13 <Spark> outside a block, you have C, right?
13:40:18 <Philippa> :-)
13:40:21 <Spark> they have access to global vars and thats it
13:40:42 <Philippa> yeah, in practice outside a block is just the global environment rather than a null one
13:41:15 <Spark> inside they get as an added scope, a copy of the nesting function's scope?
13:41:21 <Spark> by reference or by value?
13:42:01 <Spark> because if you define some variable on the stack, the function could use it after its been lost...
13:42:26 <Philippa> usually by value
13:42:33 <Spark> if everything is a reference to an object and you have a gc then thats ok, but otherwise isnt it a bit complicated
13:42:36 <Spark> ah ok then
13:42:50 <Philippa> of course, more usually this is in a functional language and it doesn't matter anyway
13:43:25 <Spark> its funny how the functional languages got the interesting features first
13:43:34 <Spark> this could be for any number of reasons :)
13:44:07 <Philippa> data hiding predates the hardware computer - great, innit?
13:44:18 <Spark> like they werent bogged down with pragmatic details, or their creators were more forward thinking, or maybe they are quite simple so its easier to understand
13:44:43 <Spark> data hiding?
13:44:49 <Spark> is that encapsulation
13:44:59 <Philippa> essentially, yeah
13:45:26 <Philippa> take a look at the typical definitions of fst, snd and pair in the lambda calculus, for example
13:45:49 <tuomov> imperative languages are based on the von neumann model of computers, and functional languages on lambda calculus
13:46:10 <tuomov> imperative languages became popular, and are only now taking features from functional languages
13:46:26 <kristnjov> i'm sticking to functional programming
13:46:40 <shapr> let sep = " - " in getCurrentDirectory >>= getDirectoryContents >>= \fl -> zipWithM_ renameFile fl (map (\ [a:b:c:d] -> concatMap [c," [",a,"-",b,"] -"d]) breakOnGlue sep ) fl
13:46:43 <shapr> does that look right?
13:46:44 <kristnjov> imperative programming feels very bloated and slow once i saw the sleek code examples of haskell :)
13:47:00 <Spark> theres no reason for imperative langauges to be like that
13:47:12 <shapr> it also requires this --> "import System.Directory; import Control.Monad; import ShaeTools (breakOnGlue)"
13:47:18 <Oejet_> kristnjov: I know what you mean.
13:47:55 <shapr> There must be some way to make that rename chunk nicer.
13:48:04 <kristnjov> chunk of what?
13:48:09 <shapr> that code I just pasted.
13:48:43 <segphault> shapr: interesting. MUCH more graceful than an equivalent ocaml solution, but I dont think its as nice as my ruby solution
13:49:06 <shapr> so, how can it be better?
13:49:10 <Philippa> shapr: give the do notation version?
13:49:13 <shapr> ok
13:49:20 <Philippa> just for readability
13:49:46 <segphault> shapr: that makes an awfully verbose script. function names are too long, and too much importing. haskell just isnt as scripting language
13:50:34 <Spark> too general?
13:50:36 <segphault> shapr: ultimately, its a very impressive display of just how expressive haskell can be.
13:50:53 <shapr> I am not convinced that Haskell isn't a scripting language.
13:51:16 <shapr> Since this is my first try at doing a renamey thing with it. I suspect it can be done more easily.
13:51:20 <tromp> any1 know the most common unix/linux program to compute password hashes?
13:51:24 <Philippa> segphault: dunno 'bout you, but personally I don't find the long function names an issue - my thinking:typing ratio takes care of that
13:51:26 <shapr> md5sum
13:51:31 <segphault> shapr: also, how long did that take you, vs how long it took me to produce the ruby equivelent?
13:51:46 <tromp> but it shld be crypt-based, not md5 based
13:51:54 <tromp> like standard passwords
13:52:04 <shapr> segphault: I can do it much faster and shorter in Python, but that's too easy...
13:52:06 <Oejet_> tromp: crypt
13:52:18 <tromp> crypt is a library function, right? not a unix command
13:52:32 <shapr> C'mon, we're on #haskell, what's the fun in writing a Python program?
13:52:34 <segphault> shapr: if you were going to right a script for some simple task, would you use haskell or python?
13:52:38 <tromp> i found that openssl can do it, but maybe not every1 has that
13:52:38 <shapr> I would use Haskell.
13:52:41 <shapr> Of course!
13:52:46 <segphault> shapr: why?
13:52:55 <shapr> Because it's more fun.
13:52:57 <Spark> heres an idea, if i get this fucking work done, i can have time spare to learn some new programming languages :)
13:52:58 <segphault> this isnt me being a jerk, btw, this is me being curious.
13:53:00 <Spark> (quits0
13:53:04 <tromp> so wonder about alternatives
13:53:24 <shapr> If I just wanted to do it quickly, I'd use a shellscript.
13:53:40 <segphault> shapr: wouldnt it be a lot longer with a shell script?
13:53:43 <shapr> But it's more fun, and ultimately more profitable to stretch myself to do it in other ways.
13:53:45 <shapr> heck no.
13:53:51 <segphault> shapr: hell, even the haskell solution is probably more concise than a bash solution
13:54:11 <shapr> no way man... sed will do anything.
13:54:18 <segphault> hahahaha
13:54:21 <shapr> but once again, it's not as much fun.
13:54:29 <segphault> I should learn sed better
13:54:34 <shapr> seriously though, sed is probably the simplest solution
13:54:45 <segphault> I know enough awk to know its unfortunate limitations
13:55:18 <Boegel> I think I found the bug in my Perlin Noise code
13:55:21 <shapr> David whatshisname on Kragen's hacks list wrote a full-featured term-rewriting system in sed.
13:55:47 <tromp> could he port haskell to sed:-?
13:55:55 <shapr> I'm sure he could.
13:56:58 <Oejet_> tromp: Argh don't remember the password hash fuction. Used it some time ago. Argh.
13:58:31 <shapr> Philippa: http://www.scannedinavian.org/~shae/ProtoRename.hs
13:59:54 <shapr> I'm sure that can be simpler, any ideas?
14:00:13 <Philippa> yeah, don't bother getting the current directory?
14:00:17 <shapr> heh
14:00:18 <shapr> too easy
14:00:19 <Philippa> assuming a FS where "." is the local dir
14:00:26 <shapr> I just thought of that myself
14:01:02 <Philippa> there's also the rather obvious "make the code uglier", but hey
14:01:10 <Philippa> (roll the let stuff into the last line)
14:01:19 <shapr> ?
14:01:37 <shapr> oh
14:02:01 <Philippa> 'snot a breach of OnceAndOnceOnly, so some folks might well write it that way
14:02:05 <Philippa> (*I* might)
14:02:06 <shapr> good point
14:02:34 <shapr> ok, edited that way
14:02:42 <Philippa> is there really not a breakOnGlue or near-equivalent in the standard libs?
14:02:51 * Philippa thinks a mo
14:02:58 <Philippa> prolly not, only an item-based split
14:03:01 <shapr> I think you can use unfoldr to do it.
14:03:07 <shapr> but that may be by char only.
14:03:31 <shapr> @index unfoldr
14:03:31 <lambdabot> Data.List,List
14:03:37 <shapr> and unfoldr isn't Prelude :-(
14:04:01 <Philippa> I'd imagine for scripting purposes you'd knock up a Prelude-replacement that grabbed more of the relevant stuff, too
14:04:05 <Philippa> hell, mebbe even imported Parsec
14:04:11 <shapr> yah, probably so.
14:04:20 <shapr> I should probably do that in ShaeTools.
14:04:28 <stepcut> shapr: do you have a url for that term rewriting thing ?
14:06:00 * shapr googles
14:06:18 * Boegel scratches his head
14:08:54 <shapr> stepcut: http://lists.canonical.org/pipermail/kragen-discuss/2002-November/thread.html
14:09:32 <shapr> stepcut: any ideas for easier shell scripting with Haskell?
14:10:53 <shapr> ah, could use system
14:11:49 <stepcut> heh, I just found that page
14:13:23 <shapr> importing System is too cheezy
14:13:52 <shapr> aha - http://www.volker-wysk.de/hsshellscript/
14:16:09 <segphault> shapr: thx. looks interesting
14:16:27 <segphault> shapr: reminds me of the scheme shell
14:18:34 <shapr> I still think there are several ways of making this simpler.
14:21:20 <stepcut> shapr: what are you trying to do ?
14:21:43 <shapr> the mp3 rename thing mentioned earlier - http://www.scannedinavian.org/~shae/ProtoRename.hs
14:21:56 <stepcut> ah
14:23:51 <segphault> does haskell have any kind of string interpolation?
14:25:26 <segphault> probably hard to do really clean string interpolation with a statically typed language
14:25:55 <Philippa> "string interpolation"?
14:26:03 <Philippa> string ++ int ++ float ++ etc?
14:26:32 <kristnjov> string ++ show int ++ show float ++ etc?
14:26:47 <tuomov> perhaps cleaner with concat..
14:26:54 <segphault> inside of a string
14:27:09 <segphault> in ruby you can put entire expressions inside some syntactic sugar within a string
14:27:20 <CosmicRay> shapr: have you looked at svk? svk.elixus.org
14:27:22 <segphault> "blah #{5 * 2} blah"
14:27:35 <segphault> would evaluate into "blah 10 blah"
14:27:42 <CosmicRay> see that is why I don't use ruby.
14:27:44 <CosmicRay> or perl..
14:27:46 <CosmicRay> or php.
14:27:53 <CosmicRay> python has it but it's not su commonly used.
14:27:55 <CosmicRay> that is just evil
14:28:09 <tuomov> printf is cool, though.
14:28:13 <CosmicRay> because for any instance where you might possibly need it, you have no guarantees about what will actually happen
14:28:17 <Muad_Dibber> for simple web applications its very handy CosmicRay :)
14:28:17 <segphault> with python you can do: "blah %s blah"%(5 * 2)
14:28:18 <CosmicRay> and implementable in pure haskell, I believe
14:28:21 <dons> looks like template haskell to me
14:28:23 <tuomov> but you need dpendent types for a proper implementation
14:28:34 <Philippa> segphault: the syntactic sugar is " ++ show (exp) ++ "
14:28:38 <Philippa> including the quotes
14:28:50 <segphault> lol
14:28:50 <Philippa> oh, wait, that's not sugar, but hey :-)
14:29:51 <segphault> I figured that because haskell has the 'show' thingy, (something that ocaml sadly lacks) it might have some nifty sugar for interpolation.
14:30:30 <dons> there are really nifty pretty printing libraries (see Text.PrettyPrint)
14:30:38 <dons> but the problem is the static typing
14:30:54 <br1> Hi.  I just found out I can't do "type Actor = Model -> (Choice, Actor)".  Where can I read a workaround?  TIA.
14:31:03 <dons> so to solve that you can use Template Haskell, or a runtime evval function
14:31:04 <tuomov> it would be easy to write a replace function String -> [String] -> String, but you either have to manually use show on all the parameters or perhaps make a kludge with existential types
14:31:17 <tuomov> but it isn't any more convenient than manually typing show
14:31:35 <dons> no, exactly. that's why noone uses the existing TH printf
14:31:49 <dons> or the hs-plugins runtime printf, for that matter
14:34:25 <ski> "... A truly static type system would have to check our brains to make sure that we will not write buggy programs, .. Indeed, a static system would have to check the genes of our parents to make sure that bad programmers were never even born. ..."
14:34:28 <ski> ;)
14:34:57 <Philippa> segphault: fancy string sugar doesn't really go with Haskell's design philosophy
14:35:20 <segphault> Philippa: why not? it seems like haskell has sugar for a lot of different things
14:35:29 <ski> br1 : use data or newtype
14:35:34 <dons> there is sugar. it's called Text.PrettyPrint
14:35:44 <Philippa> segphault: such as?
14:35:45 <segphault> Philippa: the sugar is really what attracted me to haskell from ocaml (and the superior type system is what keeps me here)
14:35:46 <dons> *untyped* sugar in strings is for TH
14:36:06 <segphault> Philippa: hell, operator definition blew my mind.
14:36:16 <Philippa> the way I see it, most of the power isn't sugar, it's having trimmed all the fat out of the syntax in the first place
14:36:28 <Philippa> the do notation's nice, as is function definition by pattern-matching
14:36:42 <Philippa> (it could just insist on foo = \x.\y.case (x,y) of...)
14:36:44 <segphault> Philippa: the absence of double-semi colons and the absence of let are particularly appealing
14:36:52 <tuomov> I prefer >>= notation in shorter pieces
14:37:01 <tuomov> but for arrows the sugar is absolutely essential
14:37:10 <dons> we have much nicer mechanisms for encoding small languages, then just using string literals. it's un-haskell to encode a DSL in a [Char].
14:37:11 <segphault> Philippa: as are applicative combinators, sexy partial application tricks, and list comprehensions
14:37:27 <Philippa> OK, yeah, list comprehensions're the other major piece of sugar
14:37:44 <Philippa> forgot about 'em because I just don't use them that much
14:37:49 <dons> it's all sugar -- remember that Core Haskell is just let, case, lambda, literals, types
14:38:09 <segphault> Philippa: most of it is implementable in ocaml, but it gets ugly really quickly. I've found that haskell emphasizes syntactic elegance over pure runtime efficiency when compared to ocaml.
14:38:30 <Muad_Dibber> actually dons, isnt core haskell not even not recursive?
14:38:32 <segphault> Philippa: most notable example of that is the fact that haskell makes strings list of characters
14:38:33 <tuomov> haskell emphasises purity
14:38:35 <Philippa> dons: I've written an interpreter for something very close to it. I'd forgotten about if as well, and where's nice...
14:38:38 <Muad_Dibber> or is that even before core haskell?
14:38:49 <Philippa> segphault: yeah, I know
14:39:04 <dons> Core is recursive. you have to do tail calls.
14:39:21 <Philippa> I just don't see most of the syntactic benefits as being about sugar - they're about having decent syntax in the first place IMO
14:39:33 <Philippa> some of the "where you can define stuff" stuff is nice, things like that...
14:39:40 <Philippa> and yeah, operator definition good
14:39:57 <br1> ski:  Thanks.  I tried with data before without luck.  I'm trying newtype now.
14:39:58 <tuomov> being able to have arbitrary operators is good
14:40:04 <segphault> ocaml lets you do operator definition but its ugly and unintuitive
14:40:06 <Philippa> but it's nowhere near the level of sugaring that you'd get if you let Wall loose on the language
14:40:13 <tuomov> being able to have unicode operators would be even better :)
14:40:24 <segphault> I want as much sugar as I can get
14:40:30 <tuomov> ringed + - * etc.
14:40:36 <dons> tuomov: that would be great :)
14:41:59 <segphault> my last ocaml program was a camlp4 extension that added list comprehensions to ocaml. I got tired of brewing my own sugar when I could get it for free with a language like haskell
14:42:05 <Philippa> tuomov: is that allowable as per the report?
14:42:13 <tuomov> I don't know.
14:42:26 <tuomov> I don't see any reason why it couldn't be allowed
14:45:31 <dons> varsym ::= symbol ; symbol ::= asciSym | unicodeSym (any unicode symbol)
14:45:41 <dons> so it's just the implementations that lag ;)
14:46:07 <tuomov> but aren't operar symbols defined elsewhere?
14:46:12 <tuomov> +to
14:46:18 <tuomov> so that it can decide what to infix by default
14:47:04 <dons> operators are just varsyms. you infix them with the infix[lr] decl.
14:47:05 <dons> infixl 7  *
14:47:06 <dons> infixl 6  +, -
14:47:45 <Philippa> eeew, you can infix an ordinary variable?
14:48:20 <tuomov> symbol 	 -> 	 ascSymbol | uniSymbol<special | _ | : | " | '>
14:48:20 <tuomov> ascSymbol 	-> 	! | # | $ | % | & | * | + | . | / | < | = | > | ? | @
14:48:20 <tuomov> 	| 	\ | ^ | | | - | ~
14:48:20 <tuomov> uniSymbol 	-> 	any Unicode symbol or punctuation
14:48:32 <tuomov> hmm. that didn't paste nicely
14:49:08 <dons> yeah. you can infix with l or r assoc, any varsym or varid. in yi:
14:49:08 <dons> infixl 3 +>, `lexaction`, `lexmeta`, `action`, `meta`
14:49:08 <tuomov> so yeah, it allows unicode operators.
14:49:09 <dons> infixl 2 >|<, >||<
14:50:23 <dons> hmm. I'm thinking obfuscated code contests...
14:51:07 <tuomov> infixl 2 a is allowed..
14:51:15 <tuomov> but 2 a 3 isn't. maybe that effects 2 `a` 3, though
14:51:33 <dons> normal varids have to be infixed with ``
15:04:55 <dons> but a problem might be ghc/compiler/parser/Lexer.x:
15:04:57 <dons> --   ToDo / known bugs:
15:04:57 <dons> --    - Unicode
15:05:35 <Philippa> has anybody worked out what'd be involved in getting GHC to parse unicode?
15:06:09 <dons> I think SimonM knows the situation
15:06:52 <dons> I think there might be  byteArrays in GHC and in Handles, that cause problems
15:08:03 <tuomov> what are these .x files?
15:08:42 <dons> Alex lexer source
15:09:02 <dons> fast Haskell lexer generator
15:09:13 <dons> with lex-like syntax
15:09:43 <dons> hmm. the regex part of Lexer.x for full gla-exts Haskell is only 250 lines
15:09:49 <dons> Sounds good for syn hl
15:10:38 <dons> esp. now we have colours in yi
15:10:51 <stepcut> sweet!
15:11:15 <dons> colours are fun :)
15:11:16 <stepcut> dons: I suspect I won't have an emacs keymap till monday... 
15:11:39 <dons> ok. that's fine. there's no hard deadline
15:11:51 * stepcut waits for the yi-qt
15:11:51 <dons> getting .hs syn hl in would be good before 0.1, anyway
15:12:03 <segphault> whats yi?
15:12:15 <dons> http://www.cse.unsw.edu.au/~dons/yi.html
15:12:41 <segphault> lol
15:12:51 <dons> we're very serious
15:12:59 <dons> (or at least I am)
15:13:07 <segphault> whats funny is that such things seem to border on obligatory for every functional language
15:13:18 <dons> yep. of course!
15:13:35 <dons> because noonee does indent mode for .hs correctly
15:13:35 <segphault> it looks cool tho
15:13:41 <dons> so we have to do it ourselves :)
15:13:57 <tuomov> and this time to language parsing properly
15:14:01 <tuomov> s/to/do/
15:14:06 <segphault> this is probably an apocryphal question.... does it support extension in other languages besides hsakell?
15:14:18 <dons> at least C, C++, and objective C
15:14:27 <dons> anything else we can get at through our lovely FFI
15:14:37 <dons> lua, I guess
15:14:49 <dons> (hmm... summer project, I think, for some undergrad)
15:14:49 <segphault> I would want python and ruby, specifically
15:14:56 <dons> that's crazy talk
15:14:59 <segphault> lol
15:15:06 <tuomov> it isn't much work to export all the lua api through ffi
15:15:21 <dons> no, just a C binding, right?
15:15:21 <tuomov> it's quite light
15:15:34 <tuomov> yeh, the C api
15:15:40 <dons> this would be quite an interesting intersection, don't you think, tuomov?
15:15:42 <tuomov> of course, it is very low-level stack manipulation
15:15:45 <segphault> I would love something like vim thats a lot cleaner, and a lot more programmable, and written in a language that isnt c, but it would have to be extendable in at least python before I considered  using it.
15:16:12 <dons> segphault: try yi. cleaner than vim. extensible in Haskell.
15:16:14 <tuomov> my libextl is also quite light, but doesn't provide access to all of lua
15:16:46 <tuomov> as it is mainly meant as a specialised wrapper generator and table access library
15:17:35 <dons> i think a lua binding would be an interesting thing to do, anyway. so it goes on the list.
15:18:10 * stepcut wonders if would be considered bad practice to use setjump/longjump in C++
15:18:40 <tuomov> it is always bad practice to use setjump/longjump
15:18:48 <tuomov> (the lua core actually uses those a lot)
15:18:54 <dons> hehe. of course.
15:19:05 <dons> but how else to do continuations in C?
15:19:11 <tuomov> it is surprisingly unbuggy, though
15:19:35 <tuomov> you must pass special structs with the function and parameters
15:19:40 <segphault> it is always bad practice to use c++
15:19:45 <stepcut> tuomov: :p
15:19:47 <tuomov> and lua uses the jumps to recover from errors
15:20:18 <tuomov> it doesn't have any in-function data that needs to be freed afaik
15:20:25 <stepcut> What I really need are some type of contiuations or first class functions for C++ :(
15:20:37 <stepcut> or, I have to rewrite a big chunk of code :-/
15:20:50 * stepcut dreams about haskell-kde bindings
15:21:01 <dons> stepcut: you could call into Haskell, store a continuation, and use it later ;)
15:21:07 <tuomov> in c++ I'd write a continuation class..
15:21:19 <tuomov> or many
15:21:22 <stepcut> heh
15:21:26 <Philippa> stepcut: how first class do you need?
15:21:26 <tuomov> template for each possible number of arguments
15:21:49 <Philippa> I mean, would something like boost::lambda do?
15:21:59 <tuomov> first-class functions are essential for serious programming!
15:22:21 <stepcut> I should really just restructure the code a bit...
15:22:36 <tuomov> I constantly keep wanting them and in the end write an ugly hack around it
15:22:45 <dons> tuomov: I should quote that
15:23:03 <tuomov> feel free to do so
15:23:26 <dons> to my "principle of programming languages" students. Maybe a series of "Tuomo says"
15:23:52 <tuomov> :)
15:24:34 <dons> "Tuomo says: don't use longjump"
15:25:33 * dons mkdir yi/Yi/Syntax
15:25:47 <monochrom> Modern OOP makes use of many design patterns such as Command, Strategy, Template.  They scream "first-class functions/closures".
15:27:45 * stepcut imagines people sticking cdroms into 5 1/4" floppy disks drives
15:28:17 <segphault> ah, debian. Trying to compile yi, and of course it wont compile without some ghc package that is probably in one of the two extra ghc library debian packages that wont install because of bizarre version conflicts.
15:28:46 <dons> you need hs-plugins, that's it I think
15:28:53 <dons> and ghc-6.2.1 or greater
15:29:03 <segphault> yes. hs-plugins is what it is looking for
15:29:38 <dons> you can grab it off the homepage http://www.cse.unsw.edu.au/~dons/hs-plugins
15:29:44 <segphault> thx
15:29:52 <dons> though it is probably in debian somewhere by now
15:30:18 <Philippa> monochrom: design patterns are HOFs, HTH HAND ;-)
15:30:21 <dons> use the latest cvs snapshot, or the "heatwave" release
15:30:35 <ski> "HTH HAND" ?
15:30:43 <Philippa_> Happy To Help, Have A Nice Day
15:30:44 <tuomov> hope that helps, have a nice day
15:30:54 <ski> ah, ty
15:31:00 <Philippa_> often somewhat sarky
15:32:01 <monochrom> Yeah I know.  But the general audience finds "design patterns" "real world" and "higher-order functions" "ivory tower".
15:32:22 <dons> you learn something every day. isn'tIn msg x ys = notElem__ x ys
15:32:30 <monochrom> The same way "shell script pipelines" are "real world" but function composition "ivory tower".
15:32:41 <dons> hehe
15:32:50 <segphault> what does "ivory tower" mean?
15:33:11 <tuomov> academic wanking
15:33:16 <segphault> ah
15:33:55 <segphault> I aspire to be an academic wanker
15:34:07 <Philippa_> tuomov: with the assumption that academics are all white males?
15:34:09 <stepcut> is ivory tower really a euphimism for wanking? Or does it have a different origin ?
15:34:16 <Philippa_> it's not a euphemism
15:34:29 <Philippa_> it refers to some intellectual up in a tower in a castle somewhere never seeing the real world
15:34:49 <monochrom> http://www.google.ca/groups?selm=4uhdspcbds.fsf_-_%40shell.vex.net&output=gplain
15:35:00 <stepcut> Philippa_: that was my understanding...
15:35:00 <tuomov> Philippa_: not really.. 
15:35:09 <segphault> the real world tends to be short sighted and inefficient. you can see quite a bit more from the top of a tower, than you can from the bottom of a valley.
15:35:32 <Philippa_> better ivory tower than head up your arse, then
15:36:17 <dons> oh boy. I need a good syn hl mode for alex src now
15:36:32 <monochrom> There is a Chinese proverb "the outside observer sees clearly, the insider is confused."
15:36:50 <monochrom> which is similar to segphault's sentiment.
15:37:16 <Philippa_> or alternatively "the spectator sees more of the match"
15:38:14 <monochrom> So I find no logic in the practitioner's objection "you are not one of us, you don't understand our problem".
15:38:41 <Philippa_> though "and you appear not to understand our problem" is understandable at times
15:38:44 <Philippa_> anyway, bed
15:39:54 <segphault> when I manually install a ghc package to /usr/local, how do I add it to the ghc path or w/e so ghc can find it?
15:40:51 <dons> make register
15:40:56 <dons> will do it for hs-plugins
15:41:11 <dons> it updates /usr/local/lib/ghc-XX/package.conf
15:41:14 <segphault> spiffy! thx
15:49:47 <segphault> i'm playing with yi
15:50:00 <segphault> looks pleasantly like vim.
15:50:28 <segphault> hrm. no help command. thats a little annoying
15:52:49 <dons> :help is part of the keymap, and hasn't been implemented. Feel free to send me a patch to Yi/Keymap/Vi.hs
15:53:41 <dons> should be pretty easy to use a FM to map :help foo to a doc string. then open a new window with that doc string
15:53:48 <segphault> I'm still relatively new to haskell, i'm probably not at the point where I can intelligently participate in collaborative development projcets
15:55:11 <dons> sure. I was just baiting you for complaining about the lack of :help -- esp. considering it is 28 days old
15:55:38 <tuomov> I haven't yet got around to writing help for riot
15:55:48 <tuomov> and it's already almost two months old
15:56:12 <tuomov> but I have written pretty much nothing during the last month
15:56:19 <dons> hehe. there you go. "Tuomo says: help is for the weak"
15:56:29 <segphault> hahahaha
15:56:43 <dons> but, actually, there is docs. if you 'make html', (and you have haddock installed)
15:56:49 <dons> you'll get nice docss
15:56:58 <dons> I just haven't integrated them into yi yet
15:57:08 <dons> an html renderer would be cool.
15:58:11 <segphault> there are some good libs for that
15:58:17 <segphault> but probably not native haskell
15:58:23 <tuomov> I had a big coding spree after having been fired during which I wrote riot and a lot for ion
15:58:41 <segphault> tuomov: ion as in the window manager? =D
15:58:43 <tuomov> but after that I've just had this nagging feeling that I should be trying to figure out what to do next instead of coding
15:58:45 <dons> tuomov: yeah. it's hard to maintain the energy
15:58:45 <tuomov> segphault: yes
15:58:58 <segphault> tuomov: tis my desktop environment of choice. =}
15:59:14 * segphault blinks
15:59:30 * segphault puts it all together.
15:59:36 <segphault> holy crap. you are the tuomov that WROTE ion
15:59:37 <segphault> hahahaha
16:00:53 <segphault> I've been using ion for quite some time now. its an absolute blessing.
16:05:12 <dons> hehe. "silly_escape_chars" is a GHC lexer char class
16:05:32 * ski grins
16:07:59 * Spark returns
16:08:02 <Spark> <-- addict
16:14:58 <segphault> dons: yi is a good start, but its not a viable replacement for vim quite yet. ;-)
16:15:36 <segphault> dons: code makes good reading tho. good comment/code ratio.
16:16:12 <dons> thanks. I wonder what the ratio is... hmmm
16:16:21 <dons> 3643 code/ 3646 comment
16:16:26 <dons> comments win!
16:16:42 <segphault> you use a lot of blank comment lines tho.
16:17:05 <dons> blank lines aren't in the above count though
16:17:42 <segphault> I like the use of '|' in your comments. makes it more readable
16:18:02 <dons> that's a haddock markup operator. it generates docs when you 'make html'
16:18:28 <segphault> interesting. I thought you were just using it to denote beginning of paragraphs
16:19:06 <dons> nope. install haddock and  'make html'. then you get all those comments to read in marked up form, with links
16:19:25 <dons> it's literate programming really. explains the high comment ratio
17:13:27 <Igloo> Hmm, what is it exactly that makes   \x -> x :: a   ill-typed?
17:19:53 <jedi`> hey guys :)
17:26:21 <Pseudonym> What's the operator precedence on that?
17:26:30 <Pseudonym> Is it (\x -> x) :: a or \x -> (x :: a)
17:26:31 <Pseudonym> ?
17:26:37 <HET2> is there a haskell reference which is more complete than the one at zvon?
17:26:51 <Pseudonym> And, as a matter of curiosity, would \ (x :: a) -> x work?
17:27:27 <Igloo> \x -> (x :: a)
17:27:47 <Pseudonym> What's the whole definition?
17:27:50 <Igloo> The other is clearly ill-typed  :-)
17:27:53 <Pseudonym> Can you produce a cut-down example?
17:28:16 <Igloo> That's it. :t that in hugs or ghci
17:28:46 <Igloo> \ (x :: a) -> x isn't H98
17:28:58 <Pseudonym> No, it's glasgow-exts.
17:29:19 <Pseudonym> Ah...
17:29:22 <Pseudonym> OK, I see the problem.
17:29:39 <Pseudonym> As GHCi notes, your syntax means this:
17:29:43 <Pseudonym> \ x -> (x :: forall a. a)
17:29:55 <Pseudonym> What you want it to be is something like this:
17:30:03 <Pseudonym> forall a. (\x -> (x :: a))
17:30:10 <ski> HET2 : Haskell Report ?
17:31:07 <Igloo> Hmm
17:31:24 * Igloo goes to look for the scoping in the report
17:33:29 <Pseudonym> I think the thing is that you can't let a polymorphic type variable leap out of a lambda abstraction or a let or something.
17:33:34 <HET2> ski: thx
17:33:37 <Pseudonym> leak, not leap
17:34:05 <Pseudonym> I dunno.  It's been a long time since I completely understood Haskell's type system.
17:35:03 <Igloo> I see what you're saying; thanks
17:39:54 <jedi`> http://pastepad.com/?pad=b0
17:40:03 <jedi`> Im getting indentation errors from my compiler, GHCi
17:40:13 <jedi`> is anyone able to explain why, i am stuck :S
17:40:24 <jedi`> ive read up on the indentation rule, but i cant work this one out
17:40:36 <Igloo> Indent your else more
17:40:45 <Igloo> It's being taken as another statment in the do block
17:46:57 <HET2> if i have (a -> a) -> a -> a can i pass (a->a->a) where a->a is expected?
17:47:07 <HET2> (i can't modify the function i want to pass)
17:47:17 <Igloo> No
17:47:32 <jedi`> i cant get the indentation right
17:47:33 <jedi`> :\
17:48:55 <HET2> Igloo: so iter only takes functions with one curry argument?!
17:49:47 <Igloo> iter?
17:51:45 <HET2> Igloo: i meant iterate
17:52:02 <Igloo> Well, iterate has type   (a -> a) -> a -> [a]
17:52:44 <Igloo> What do you want to write?
17:53:18 <HET2> Igloo: i want to write something like iterate which returns the f^n(a) where ^n is the n-wise application of f
17:54:08 <Igloo> That's iterate f a !! n
17:55:20 <HET2> Igloo: that's not very efficient
17:55:34 <HET2> Igloo: it first creates a list and then iterates through it to get my result
17:56:13 <Igloo> "first" is wrong given it's a lazy language
17:56:22 <Igloo> If it first made the list it would never terminate as it's an infinite list
17:57:18 <HET2> Igloo: let me rephrase for you if you're going to be pedantic
17:57:27 <HET2> Igloo: it first builds the list up to the element i want
17:57:32 <HET2> Igloo: then it iterates through it
17:58:16 <Igloo> No it doesn't - it will never work out what the third element of the list would be (although as it does the work anyway it wouldn't matter)
17:58:49 <Igloo> There is a potential issue with it building a large closure with the n nested calls, but you shouldn't worry that unless profiling highlights it as a problem
17:58:51 <HET2> Igloo: it wouldn't if the result wasn't ever used
17:59:09 <HET2> Igloo: but doesn't !! basically head through the list until it gets where you want it?
18:00:14 <Igloo> It does. There's probably a very slight overhead incurred (but I'm not sure what the optimiser will do), but it is far outweighed by the simplicity of the code
18:00:58 <HET2> i have to confess i am a fp newbie and i am totally not used to relying on the interpreter/compiler to decide for me when to evaluate my stuff
18:01:21 <HET2> but my experience so far is that it doesn't evaluate when you need it and it evaluates when you don't most of the time...
18:01:51 * HET2 has had his share of seemingly buggy code which was fixed with a $!
18:02:30 <Igloo> Do you think 2^1000 is evaluated in this?   [2^1000, 2, 3, 4] !! 3
18:03:45 <HET2> hrm
18:04:11 <HET2> good point
18:15:17 <dustin`> favorite string similarity algorithm, anyone?
18:19:07 <dons> hmm. similarity? like == ?
18:25:03 <dustin`> nah, some numerical metric
18:28:34 <Igloo> There's one that gives similarity based on how things sound which looked like a cute idea. I forget its name, though.
18:29:02 <tuomov> that depends on the language, though
18:29:17 <Igloo> Yeah; I assume it assumed English
18:29:30 <tuomov> english has many same-sounding words with totally different meanings
18:29:34 <Igloo> Or maybe it was a higher-order algorithm which you partially apply a language to  :-)
18:34:02 <dustin`> Errr....it would be difficult.  The English language *is* infinite...
18:34:40 <dustin`> ( {great-}*grandfather )
18:34:49 <tuomov> googling by 'edit distance' might help, and then there's of course the basic l^n metrics..
18:35:18 <dustin`> tuomov: I haven't tried that search term yet, thanks
18:36:27 <Igloo> dustin`: Huh? There'sa  finite mapping of lists of letters to sounds
18:37:09 <tuomov> with some hundreds of special cases :)
18:37:24 <Igloo> Sure, but still finite  :-)
18:38:09 <dustin`> hmmm, I stand corrected
23:31:46 <mornfall> morning :)
23:32:30 <xkb> morning
23:33:13 <shrimpx> attapl needs to come out already
23:36:30 <stud> Good morning! Anybody here?
23:37:15 <mornfall> stud: possibly
23:37:21 <mornfall> morning anyway
23:37:22 <musasabi> no...
23:37:45 * mornfall got 2 very easy bonus points in haskell class... =)
23:38:24 <stud> I need some help. Function protype is countFilter :: (a -> Bool) -> [a] -> ([a],Int)
23:38:40 <stud> and it is defined as countFilter p xs = (filter p xs, length xs - length (filter p xs))
23:39:20 <stud> all I need to do is define countFilter using foldr: countFilter p xs = foldr f b xs
23:39:39 <mornfall> hmm
23:39:49 <mornfall> is that some kind of assignment? =)
23:40:00 <musasabi> sounds like an assignment..
23:40:12 <stud> yes 
23:40:23 <musasabi> stud: can you implement length with foldr?
23:41:30 <stud> I can implement a filter with foldr ( myFilter f xs = foldr check [] xs where check a b | f a = a:b | otherwise b
23:41:43 <stud> but i don't know how to implement length
23:41:48 <musasabi> "length xs = foldr foo bar xs", now what are foo and bar?
23:41:59 <musasabi> what should length return on an empty list?
23:42:03 <stud> foo = (+)
23:42:07 <stud> and bar = 0
23:42:27 <stud> length [] = 0
23:42:33 <musasabi> correct.
23:43:07 <stud> ok, but now, how to put them together
23:43:46 <musasabi> btw filter is better expressed as filter p xs = foldr (\a i -> if p i then (i:a) else a) xs
23:44:35 <musasabi> the gist is to use a pair of values accumulating through foldr.
23:46:13 <mornfall> musasabi: yeah, btw, that length will (imo) add up numbers in the list, not count the length...
23:46:31 <mornfall> that is, it's sum s
23:46:34 <mornfall> not length s
23:46:39 <mornfall> or i'm missing sth :p
23:46:43 <stud> aa yeah, i need counting not summing
23:47:22 <stud> so, it should be something like \a b -> b + 1 ?
23:47:29 <mornfall> map (\x -> 1
23:47:33 <mornfall> ::Integer)
23:47:34 <mornfall> helped :)
23:47:42 <mornfall> ...stupid enter...
23:48:46 <stud> ok, thanks so far, I need to go. I'll be back after 3 hrs.
23:48:57 <mornfall> cu then
23:49:19 <musasabi> mornfall: length = foldr (\a _ = a+1) 0 
23:49:48 * musasabi remembers foldr/foldl parameter order quite loosely..
23:51:09 <mornfall> yeah, fair enough
23:51:24 <mornfall> probably more efficient, too =)
23:56:51 <blackdog_> igloo: there? i'm having problems with your printf package...
23:58:01 * mornfall wonders what's going on here in the class
23:58:15 <mornfall> the tutor disappeared somewhere in the corner
