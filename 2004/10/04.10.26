00:00:35 <Lemmih> The source is available here: http://www.scannedinavian.org/~shae/Hackage.tgz
00:04:27 <Lemmih> And there's a demo of the old version here: http://www.scannedinavian.org/cgi-bin/web/webbih
00:10:53 <musasabi> dons: I have code with scrolling using curses (in haskell) if you are interested (yi) 
00:31:10 <Lemmih> HaskellDB rocks at creating advanced SQL.
00:31:59 <xkb> Does haskell db use exceptions? Or Maybe?
00:33:41 <Lemmih> HaskellDB is only a SQL unwrapper. It generates SQL but doesn't actually execute it (it uses HSQL or wxHaskell for that).
00:33:51 <xkb> aha
00:34:07 <xkb> so it doesnt support cursors or anything like it?
00:34:13 <xkb> recordsets etc
00:34:18 <Lemmih> eh?
00:34:36 <xkb> like JDBC for example
00:35:31 <Lemmih> Isn't JDBC just an database abstraction layer?
00:35:39 <Lemmih> *a database
00:35:44 <xkb> yes
00:36:13 <Lemmih> HaskellDB is nothing like that (but HSQL is).
00:36:59 <Lemmih> HaskellDB provides a type safe and high level interface to SQL.
00:37:01 <xkb> ahh HSQL.. I was reading HSQL as in HSQLDB, a java based database
00:38:32 <Lemmih> I've written a small HaskellDB tutorial if you're interested. http://www.scannedinavian.org/AvianWiki/HaskellDbTutorial
00:38:53 <xkb> always nice to look at
00:45:21 <cm> http://www.leetspeak.org/HAL.hs /o/o/o/ oh so useless!
00:45:22 <cm> nn
00:55:00 <Lemmih> xkb: What do you think?
01:02:43 <xkb> Lemmih, looks real nice
01:03:13 <xkb> reminds me a little bit of hibernate (a ORM layer)'s HQL
01:03:17 <xkb> thats OO though
01:44:56 <dons> musasabi: yes please. my save me some time!
01:45:03 <dons> s/my/may/
01:45:33 <dons> scrolling was my job for the next 6 hours
01:46:58 <xkb> Does anyone here know some good links to the current state of types research? Esp. augmenting type systems to allow for example external effects
01:56:26 <ez4> i'm getting an ambiguous type error with the literal '1'.  shouldn't it just default to Int?
01:57:22 <xkb> ez4, can you show the code somewhere?
01:57:46 <earthy> such as on the HaskellPastePage
01:58:05 <ez4> k
01:58:45 <ez4> where is HaskellPastePage?
01:58:45 <Lukhas> hello
01:59:00 <xkb> earthy, to paste on the HaskellPastePage, do you need to learn any special syntax or have a username?
02:01:31 <xkb> ez4, http://www.haskell.org/hawiki/HaskellIrcPastePage
02:04:18 <ez4> ok, it's the top item on HaskellPastePage
02:04:24 <ez4> the last line is the problem
02:05:04 <ez4> both Int and Float implement the Emit class, so I get an 'ambiguous' error
02:16:01 <earthy> ez4: makes sense
02:16:56 <ez4> so do i have to add a type signature to each literal num or is there a better way?
02:17:00 <earthy> the system cannot figure out if you want to display "0 J" ++ s or "0.0 J" ++ s
02:17:44 <earthy> well, I'd just try "0" <+ "J" ++ s
02:20:58 <ez4> yep, it works.  thanks
02:21:17 <earthy> but, the neater option is to use defaulting
02:22:19 <earthy> i.e.: add    default (Int, Float)     to the code
02:25:06 <ez4> can i just add that anywhere in the module?
02:32:16 <earthy> yes
02:32:59 <ez4> i found the section about it in the haskell 98 report, so i'm reading up on it.
02:33:22 <ez4> my code just compiled with no errors.  thanks for your help. :)
02:46:24 <dons> yay. yi can scroll :D
02:50:30 <shapr> yay!
02:51:25 <dons> just need to clean this crazy code up a bit
02:51:51 <dons> screens, windows, buffers. oh my!
02:53:48 * shapr receives unicycle pictures in email
03:02:08 <shapr> hoi swiert 
03:02:15 <swiert> hi shapr
03:03:09 <swiert> shapr: I have a very basic parse lib based on the arrow stuff if you're interested
03:03:41 <shapr> yes!
03:04:48 <swiert> ok - let me just try and send it.
03:05:03 <shapr> sadly, my irc client doesn't do DCC
03:05:15 <shapr> because it's written in elisp, and DCC is only supported on XEmacs.
03:05:23 <shapr> er "only on Gnu Emacs"
03:05:33 <swiert> aha - I can mail it if you want.
03:05:40 * tic ponders printing a lisp book today
03:05:49 <shapr> yes please!
03:05:54 <swiert> address?
03:05:57 <shapr> I'm shae@scannedinavian.com
03:06:29 <shapr> yay - unicycle pix from that nice dutch girl who visited us - http://www.scannedinavian.org/~shae/PA090170.JPG (warning half a meg)
03:07:50 <shapr> swiert: my vicious spam filter will bounce the first time unless you tell me your domain so I can whitelist you.
03:08:07 <swiert> shapr: swierstra.net
03:08:42 <shapr> ok, you're whitelisted
03:09:03 <swiert> shapr: it's en route
03:09:25 <shapr> yay!
03:09:43 <swiert> shapr: beware though - it can only parse LL(1) grammars
03:10:01 <shapr> that's fine with me
03:12:15 <swiert> shapr: you can run basic tests with parse tst... "...." - fill in the dots yourself
03:12:24 <earthy> damn dude, that's like totally off the ground ;)
03:12:58 <shapr> earthy: I've been practicing hopping on my unicycle, I'm getting better!
03:13:15 <swiert> earthy - maybe when I go beyond pre-alpha release, testing support will be better ;-)
03:13:38 <shapr> swiert: this is great!
03:13:54 * earthy doesn't quite see how arrows help parsers...
03:13:55 <shapr> salut ianxek 
03:14:11 <swiert> earthy - they don't per se. 
03:14:14 <shapr> swiert: do you want to explain? =)
03:14:32 <shapr> ianxek: looking for Haskell info?
03:14:40 <ianxek> salut shapr
03:14:59 <earthy> it's just that now they fit in with arrowised code more neatly?
03:15:01 <ianxek> yes, I'm hesitating between Haskell and Ocaml and SML/NJ
03:15:15 <swiert> shapr - ok basically the Hughes paper explains how to do a few basic parsers from Swierstra-Duponcheel with arrows.
03:15:17 <earthy> Haskell, all the way. unless there's legacy stuff you want to use.
03:15:49 <shapr> ianxek: why choose? more languages is good :-)
03:15:59 <xkb> ianxek, asking that in #haskell is a surefire way to get the answer "haskell" back ;-)
03:16:01 <swiert> shapr - but once you have those primitives its not that hard to rewrite some of the derived combinators from uust.
03:16:39 <ianxek> xkb : sure but I've read stuff from haskell people that seemed reasonable about comparisons
03:16:51 <earthy> owh, yeah, ofcourse
03:17:43 <swiert> shapr: but as earthy pointed out, I'm not sure what the exact benefit is of moving all this  to the arrow level, besides perhaps better integration with existing arrow code.
03:17:48 <shapr> earthy: arrows let you drop input earlier, and cut off enclosing scope
03:18:10 <ianxek> xkb : for example Andre Pang talks about performance issues and readability
03:18:22 <earthy> shapr: come again?
03:18:41 <earthy> `cut off enclosing scope'?
03:18:50 <ianxek> shapr : yes, learn more languages, but then no time to code for real
03:19:03 <earthy> ianxek: if you want to code, just pick one
03:19:10 <shapr> monands are recursive descent parsers, so earlier bindings are still in scope
03:19:20 <shapr> ianxek: I really like Haskell.
03:19:36 <ianxek> earthy : yes, but you mean among those 3 I mentioned or also include cobol in the random draw ?
03:19:48 <shapr> ianxek: it's not as fast as C, but its expressive power means I can quickly write code that works well.
03:19:51 <earthy> ummm... umm... did I misunderstand the concept of parser combinators?
03:19:58 <swiert> earthy: no
03:20:20 <earthy> ianxek: that depends. did you specifically want to expose yourself to functional programming?
03:20:30 <ianxek> shapr : that's what I want. But what about this easiness compared to, say, Python ?
03:20:37 <earthy> afaik there is no real reason for parser combinators to be recursive descent, right?
03:20:47 <earthy> it's just that that is easiest to make...
03:20:49 <swiert> earthy: Doaitse's parser combinators do the same thing, only now a very basic version of the same trick has been translated to arrow-ish notation.
03:20:58 <shapr> Python does not allow as much abstraction as Haskell.
03:21:06 <shapr> I switched from Python to Haskell.
03:21:32 <shapr> Also, Haskell requires a lot more brain effort than Python, but what you get is worth all that effort to learn.
03:21:37 <earthy> Haskell is much much *much* nicer than Python in my mind
03:21:49 <ianxek> shapr : interesting. Did you have problems finding useful libraries ?
03:21:56 <earthy> Python has features (such as the scoping rules) that make for dumbwork
03:22:12 <shapr> Python has more libraries than Haskell, but we're writing more all the time.
03:22:32 <shapr> Peter Simons just wrote an MTA in Haskell.
03:22:36 <shapr> lambdabot is in Haskell
03:22:40 <ianxek> shapr : what about numerical libraries
03:22:53 <shapr> dons is writing an editor in Haskel
03:23:04 <shapr> what sort of numerical libs?
03:23:06 <earthy> there's wxHaskell for GUI's
03:23:27 <shapr> there are both MPI and PVM wrappers
03:23:44 <shapr> I think I heard about a blaspack wrapper.
03:23:46 <ianxek> Tensor manipulation, signal analysis, PDEs
03:24:12 <shapr> I don't know about those, I've never looked.
03:24:12 <ianxek> matrix stuff
03:24:26 <shapr> it's pretty easy to write your own matrix libs
03:24:42 <shapr> but I don't know if there are any "Well Tuned" existing libs.
03:24:55 <shapr> there is the DSP library project
03:25:12 <shapr> http://haskelldsp.sourceforge.net/
03:25:14 <ianxek> shapr : what about easiness of interfacing with C/fortran libs
03:25:31 <shapr> Haskell's foreign function interface is easier than Python's
03:25:31 <earthy> pretty easy, really
03:26:11 <shapr> I don't know about interfacing to fortran, never tried that.
03:26:26 <ianxek> Interesting link, thanks shapr
03:27:13 <ianxek> What about Andre Pang's comments on Haskell's performance and redability ?
03:27:16 <ianxek> http://www.algorithm.com.au/mt/haskell/haskells_performance.html#000155
03:28:02 <ozone> speak of the devil
03:28:05 <ozone> hello world
03:28:09 <shapr> g'day andre
03:28:15 <ozone> sup shae
03:28:18 <ianxek> People on Ocaml irc explained that SML/NJ was getting closer to Ocaml performance
03:28:21 <shapr> you want to respond to your comments on Haskell? ;-)
03:28:27 <ianxek> Hello andre ozone
03:28:36 <ozone> sure
03:28:42 <ozone> written all i wanted to say, though
03:28:59 <ianxek> very interesting stuff
03:29:22 <ianxek> The link to the ocaml/haskell code speaks of itself
03:30:24 <ianxek> Python's problem is that when I want performance I have to rewrite in C. So I don't want the same problem happening with Haskell, you see ?
03:30:53 <xkb> you can always use Clean then ;-
03:31:04 <shapr> or Template Haskell.
03:31:39 <ianxek> xkb : yes, I've looked at it. Are there shootout examples ?
03:31:41 <shapr> I don't do heavy duty numerical computing, so I've never had to rewrite anything in C
03:31:55 <ianxek> shapr : what's template haskell ?
03:32:04 <shapr> http://www.haskell.org/th/
03:32:10 <shapr> meta-programming
03:32:12 <xkb> ianxek, not that I know of.. I can try to fix some.. or ask someone else here to do it
03:32:22 <ozone> one good thing to come out of it (my ranty blog entry) was a talk in our programming group about solving some of the performance problems
03:32:34 <shapr> There's also the Nepal Project that does nested data parallelism.
03:32:42 <ianxek> xkb : what would you expect if that got done ?
03:32:45 <earthy> ozone: that's pretty good in fact
03:32:46 <ozone> ianxek: the shootout examples are pretty non-indicative of haskell performance as whole, though
03:32:59 <shapr> ozone: personally, I think spec_eval and good halfway points between expressiveness and speed would be fine.
03:33:10 <ianxek> ozone : yes, but Pang's point was that performance meant non-readability
03:33:21 <shapr> ozone == Andre Pang
03:33:21 <ozone> ianxek: you can stop referring to me in the third person :)
03:33:23 <xkb> ianxek, I would expect it to be faster or equal as fast as the haskell versions.. though not much faster
03:33:23 <earthy> that is not true.
03:33:38 <earthy> performance does not mean non-readabiliyt
03:33:38 <ozone> shapr: right, same
03:33:45 <ozone> speceval would be really nice if it were merged
03:33:49 <xkb> whats the link of the shootout page?
03:33:51 <ianxek> ozone ok, sorry, just wanted to cite my sources
03:34:21 <ozone> ianxek: no prob
03:34:22 <earthy> however, it is hard to get some things to perform well
03:34:49 <shapr> I've just never needed more speed than Haskell offers. In my opinion changing my abstraction or my algorithm is a better approach.
03:34:53 <earthy> i.e.: you win big on the big-O speedups
03:34:57 <ozone> earthy: right now, i think that getting good performance from haskell can be hard
03:35:12 <earthy> but you lose out in the small nitbitty details such as pointermangling
03:35:19 <ianxek> ozone : what about the probable future
03:35:43 <tromp> when i have time i'll port my fhourstones benchmark to haskell
03:35:47 <ozone> ianxek: i think it'll be well-solved in the probable future
03:35:54 <earthy> http://shootout.alioth.debian.org/ btw
03:36:11 <xkb> tu
03:36:19 <ozone> chilli was suggesting some nice strictness expressions
03:36:29 <xkb> ah
03:36:32 <xkb> clean is allready there
03:36:58 <ozone> yeah, problem with clean is that you shove strictness annotations everywhere
03:37:04 <xkb> http://shootout.alioth.debian.org/lang/clean/
03:37:06 <ozone> and uniqueness types make the code a lot harder to read than monads.  imho
03:37:12 <xkb> ozone, yeah.. very annoying to read
03:37:52 <ozone> and clean does quite well on the language shootout since it's all microbenchmarks
03:38:02 <shapr> I wish someone would resurrect spec_eval.
03:38:08 <ozone> and it makes much heavier use of strictness annotations
03:38:15 <earthy> *much* heavier use
03:38:34 <shapr> not me, of course ;-)
03:38:38 <ozone> shapr: i wouldn't like to be the maintainer, the code for that is ... fun :)
03:38:42 <earthy> Clean wins out probably more due to the strictness annotations than due to the uniqueness
03:38:57 <ozone> yeah, agreed
03:39:02 <ozone> shapr: i think the future is JITs
03:39:10 <shapr> future of Haskell?
03:39:18 <ozone> well, in general
03:39:22 <ozone> but haskell, sure
03:39:27 <shapr> how so?
03:39:33 <ozone> nobody's done JIT research on haskell yet, and stuff like speceval is just primitive JITting
03:39:49 <earthy> just look at the wc example for clean, it is almost completely in unboxed and strict datatypes
03:40:17 <ozone> especially if you have a more dynamic language like what hs-plugins can give you, you kill off a lot of static optimisations
03:40:28 <shapr> Duncan Coutts is checking out partial evaluation with TH
03:40:38 <ozone> yes, but TH is still static
03:40:51 <shapr> not if you mix in hs-plugins
03:41:21 <ozone> i don't think you'll want to be maintaining hand-rolled optimisations like that :)
03:41:23 <shapr> sounds like the epigram approach, where the next step of compilation is just another 'refinement' of the program.
03:41:34 <ozone> logical next step is to move the logic into the compiler
03:41:37 <ianxek> ozone : and what about the comment I've read that Haskell's laziness meant code performance was unpredictable
03:41:37 <shapr> Nah, but then I don't have a problem with Haskell's speed right now :-)
03:41:47 <ozone> ianxek: what about it?
03:41:57 <ozone> shapr: you're such a technologist :)
03:42:10 <ianxek> Is that a fact, or are there workarounds ?
03:42:18 <shapr> What's a technologist?
03:42:22 <ozone> ianxek: sure there are workarounds, but (right now), they're not pretty
03:42:26 <shapr> @wn technologist
03:42:33 <lambdabot> *** "technologist" wn "WordNet (r) 2.0"
03:42:33 <lambdabot> technologist
03:42:33 <lambdabot>      n : a person who uses scientific knowledge to solve practical
03:42:33 <lambdabot>          problems [syn: {engineer}, {applied scientist}]
03:42:41 <shapr> huh, sounds good to me.
03:43:06 <ozone> shapr: i was using it more in the sense of using technology for its own sake :)
03:43:25 <ozone> (not meant in an offensive sense, just commenting)
03:43:48 <shapr> In reality, I am just easily bored, thus forcing me to learn new things =)
03:44:10 <ianxek> shapr : what about dealing with large codes with multiple modules, is all that easy to handle in haskell ?
03:44:23 <ianxek> shapr : compared to Python
03:44:32 <ozone> ianxek: why not just learn the language, instead of asking theoretical questions?
03:44:35 <ozone> (seriously)
03:44:45 <ozone> you can't get a feeling for the language without using it
03:44:47 <shapr> Yes, it's just about the same as Python, easier in some ways.
03:45:43 <ianxek> ozone : it's easier to spend some time before, than regretting choice later, no ?
03:46:29 <ozone> depends what you're learning the language for, really
03:46:32 <shapr> ianxek: I usually pick up three or four languages at the same time, and write the same stuff in all of them for a few weeks, and I quickly discover what I like.
03:46:40 <ianxek> ozone : I like to hear about others and their choices
03:46:41 <ozone> if it's just a hobby and you're interested, it never does any harm to learn
03:46:54 <ianxek> shapr : that's what I'm doing right now
03:47:12 <ozone> it would be worthwhile learning haskell just so it can influence your programming style in other languages
03:48:38 <ianxek> ozone : it's not for hobby
03:49:06 <ozone> ah, right.
03:49:33 <ianxek> shapr : I'm working in parallel on D, Python and I need a third
03:50:47 <shapr> try Haskell =)
03:51:07 <ianxek> And what about distributed programming with Haskell ?
03:51:08 <shapr> Python was my first love, but Haskell is a more mature relationship ;-)
03:51:31 <ianxek> shapr : the little I've done in Haskell, I like the feeling
03:51:57 <shapr> there's some support for MPI and PVM. There's also GdH (distributed) and GpH (parallel), though I haven't tried them.
03:52:45 <shapr> python is almost totally determinstic, you can depend on stuff to get garbage collected for example
03:53:13 <shapr> that's good for predictability, but it also means you can predict it will be slow in some cases because of that.
03:53:51 <shapr> In my opinion, Haskell gives you more freedom and more power. Which means you can shoot yourself in both feet and start shooting your friends too, if you really screw up ;-)
03:55:04 <ianxek> Anyone tried GdH ?
03:55:34 <shapr> As for parallel programming, there's also Goffin and PArr.
03:55:47 <shapr> ozone: any idea if Goffin is still actively developed?
03:56:16 <ozone> nah, haskell doesn't let you shoot yourself in the feet unless you start using unsafe*
03:56:20 <ozone> that's the beauty of it
03:56:29 <ozone> compiler catches so many errors for you
03:56:44 <ozone> dunno about goffin.  i'm not really interested in parallel/distributed stuff
03:56:56 <ozone> the phrase "distributed garbage collection" makes me want to hold a gun to my head
03:57:04 <shapr> I'm thinking of Haskell's laziness vs Python's reference-counted strictness.
03:57:48 <shapr> Call-by-name plus laziness gives you some really spiffy options, including the ability to shoot everyone's foot tomorrow.
03:58:09 <shapr> once all the thunks get eval'd ;-)
03:58:25 <shapr> Guten Tag TheHunter
03:58:58 <TheHunter> Hey shapr, how's code?
03:59:08 <shapr> goed :-)
03:59:17 <shapr> I just got a prelim version of Parrowsec.hs from swiert
03:59:24 <shapr> anyway, lunch time for me...
04:14:53 <shapr> swiert|away: hey, any explicit license on that code? 
04:37:03 <swiert> shapr: no, go ahead and use it as you seem fit.
04:39:29 <TheHunter> swiert: can I have a look at it, too?
04:39:59 <swiert> TheHunter: sure, there's not that much to look at, but the basics are there.
05:11:48 <shapr> ianxek: interesting thread on haskell-cafe, about Haskell and Python - http://www.haskell.org//pipermail/haskell-cafe/2004-October/007245.html
05:13:52 <tromp> pythons are somewhat more fp aware
05:14:15 <tromp> he forgot statistics on ruby
05:14:45 <tromp> those shld also be fp aware; ruby has lambdas too, just not called such
05:16:51 <shapr> Guten Tag pesco 
05:16:53 <pesco> Woohoo!
05:17:13 <pesco> Moin shapr! I've just found the solution to my command line error handling problems.
05:17:20 <shapr> cool! what is it?
05:17:39 <pesco> I've reduced the problem to basically a map! 
05:18:14 <pesco> I'm just going to map each command line argument to a big "Arginfo" structure that already holds all the info I need, but unstructured.
05:18:35 <shapr> good idea.
05:19:11 <pesco> Currently it's a bunch of interlocked functions that find the info and build the structure immediately.
05:19:50 <shapr> that sounds like elegantly idiomatic Haskell.
05:20:02 <shapr> because then you can reuse those functions elsewhere if you ever need them
05:20:27 <pesco> They are pretty and readable, but trying to add fine-grained error reporting (passing up error data through Either) immediately destroyed that.
05:20:54 <shapr> you can't just lift it through ErrorT or something?
05:20:58 <ianxek> shapr : thanks, I'll have a look now
05:21:47 <pesco> shapr: No, although I've not tried ErrorT itself.
05:22:13 <pesco> I tried monadic Either but it just resulted in a huge mess.
05:22:32 <pesco> Basically because the return types were not always uniform.
05:24:20 <pesco> Those functions are parser-like. Most return a rest list to be parsed.
05:27:54 <pesco> Ah whatever, the big-arginfo-way is going to give me a low-level raw parser, too, that I can throw at stepcut! ;-)
05:28:21 <shapr> heh
05:28:28 <shapr> he'll like that I'm sure :-)
05:28:38 <pesco> Surely! :)
05:29:18 <pesco> "What?! Sure, just wrap a thin layer around this." *pointsatarginfolist*
05:32:47 * shapr grins
05:33:03 <shapr> I was recommending something like that to CosmicRay yesterday.
05:33:25 <pesco> BTW, I wonder why Microsoft is continuously emberassing themselves with the version naming of their products. I mean, it's not like it's hard to get right.
05:33:36 <shapr> ?
05:34:48 <shapr> what did they do?
05:35:24 <pesco> They don't count right. I go 0.1, 0.2, ..., 0.9, 1.0, 1.1.
05:35:31 <shapr> ah, that.
05:35:38 <shapr> java is going from 1.5 to 5.0
05:35:51 <pesco> Is it really? That's good.
05:35:54 <shapr> and emacs is actually version 0.21 you know?
05:36:02 <pesco> Er.
05:36:07 <shapr> seriously. 
05:36:13 <shapr> They just gave up and dropped the leading zero.
05:36:21 <pesco> Really? Cool.
05:36:32 <pesco> When was that?
05:36:37 <shapr> I forget..
05:36:50 <pesco> But it wasn't JWZ who did it, was it? ;-D
05:37:23 <shapr> heh, I don't think so.
05:38:25 <pesco> Argh. My english vocabulary is vanishing.
05:39:06 <pesco> Consider a series. \sum x_i. Ok?
05:39:20 <pesco> What do you call (x_i) ?
05:39:44 <pesco> It just took me a day to find this word two weeks ago and now I've lost it againg!
05:40:27 <pesco> sequence.
05:40:32 <pesco> Phew.
05:40:44 <Iter> pesco: aritmetic?
05:41:03 <pesco> Iter: ?
05:41:48 <Iter> ahhh, I thought you were looking for a name for the sum.
05:41:51 <shapr> pesco: you could always give me your phone number and then I can call you up and talk to you in American.
05:42:02 <Iter> addend is the word I think you're looking for.
05:42:13 <shapr> Not sure if that will help your English, but at least I can teach you a really interesting accent.
05:42:27 <pesco> shapr: Hm, what's your accent?!
05:42:40 <shapr> I'm from Alabama originally.
05:42:45 <pesco> Waha.
05:42:58 <shapr> Actually, you can't hear the Southern accent unless I do it on purpose :-)
05:43:20 <shapr> Years of living in other places has given me a very boring accent in my normal speech.
05:43:23 <tromp> Eclipse is such a wonderful IDE...
05:43:55 <shapr> too bad it's based on a closed source language.
05:43:55 <Iter> tromp: of course so is vim ;)
05:43:59 <pesco> I used to speak an almost perfect Boston accent, which I liked very much, just as I like my Hamburg accent, but now I'm surely all back to British-German-American-Missingsh.
05:44:24 <shapr> Boston accent is cool :-)
05:44:35 <pesco> Yayah.
05:44:48 <tromp> vi is just ok if all your code fits in one medium sized file:)
05:44:50 <shapr> you wan some quaffee?
05:44:57 <shapr> tromp: tried emacs?
05:45:07 <xkb> what's that? emacs?
05:45:10 <xkb> :0
05:45:27 <Iter> pesco: was addend the word you were looking for?
05:45:32 <tromp> no can do. i'm of the vi persuasion...
05:45:36 <pesco> Iter: No, sequence was the word.
05:45:38 <shapr> I occasionally have 500 or so files open at the same time when I'm tracking through the linux kernel.
05:45:41 <Iter> tromp: well if you have large sized files then you're doing something wrong.
05:45:56 <shapr> max I can remember in the last coupla months is 900 files that I was searching through.
05:46:16 <tromp> i'm developing a project with dozens of files each with dozens of variables and methods
05:46:32 <Iter> I routinely have 30-50 files open in vim when working on kowari.
05:46:35 <tromp> and eclipse gives me the overview i need
05:46:56 <xkb> Is there a haskell mode for eclipse?
05:47:01 <tromp> yes
05:47:09 <xkb> do you have a link?
05:47:15 <shapr> have you guys tried yi yet?
05:47:29 <shapr> c'mon, a vi written in Haskell... how can you resist?
05:48:32 <tromp> http://eclipsefp.sourceforge.net/
05:48:45 <tromp> what's the y stand for?
05:49:23 <shapr> Y
05:49:27 <shapr> really =)
05:49:31 <shapr> the name is Y I
05:49:36 <shapr> @eval Y I
05:49:55 <lambdabot> out of fuel - use @resume to continue
05:49:56 <shapr> it's the ultimate in recursive names, it totally beats weenie recursive names like HURD or GNU
05:50:36 <Iter> lol
05:51:48 <pesco> It really is.
05:52:07 <tromp> ah, that's like naming it SSK(S(SSK))
05:53:04 <shapr> tromp: but it's a lot easier to type yi ;-)
05:53:39 <tromp> can't argue with that
05:54:21 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi
05:54:22 <tromp> how much % of vi functionality is currently supported?
05:54:34 <pesco> Finished getting.
05:54:43 <shapr> well, it's got buffers and editing :-)
05:54:49 <shapr> that's about it at the moment.
05:55:10 <shapr> I think yi is seven or eight days old right now, so that's not too bad.
05:55:31 <tromp> and alrd it can produce any conceivable document!
05:57:25 <tromp> but one thing escapes me
05:57:38 <shapr> <dons> we just need undo, text searching, yank buffers, colours, some dynamic haskell <dons> and we have 0.1
05:57:56 <tromp> why not an emacs clone instead:-?
05:58:03 <shapr> oh it will be an emacs clone too =)
05:58:40 <tromp> an emacs clone with insertion mode??
05:58:44 <shapr> I haven't had much time to put into the emacs features, and dons is a vim user.
05:58:58 <shapr> modes are just for the vi emulation
06:00:13 <tromp> -rwxr-xr-x  2 root root 4404396 Apr 15  2004 /usr/bin/emacs
06:00:15 <tromp> -rwxr-xr-x  1 root root 475568 Apr  7  2004 /bin/vi
06:00:23 <tromp> are you gonna be smaller yet?
06:01:36 <shapr> -rwxr-xr-x  1 shae     71 Oct 24 13:27 yi-inplace
06:01:36 <shapr> -rwxr-xr-x  1 shae 960907 Oct 26 02:58 yi-static
06:01:55 <shapr> well, we have the statically linked binary, and the dynamically loaded version.
06:02:34 <shapr> actually, the dynamic version is 2.3mb
06:02:41 <shapr> but I can probably strip them
06:02:53 <shapr> and later we can do -split-objs to cut down the size even more.
06:03:04 <shapr> ok, 1mb stripped
06:03:21 <shapr> and yi-static 458k stripped
06:14:21 <tromp> that's amazingly close to vi
06:14:31 <shapr> you tried it?
06:14:41 <tromp> no, in size i mean:)
06:14:43 <shapr> oh
06:17:00 <shapr> Guten Tag cptchaos 
06:17:16 <shapr> Wie geht es?
06:17:18 <cptchaos> Guten tag shapr
06:17:23 <cptchaos> gut :-)
06:17:47 <cptchaos> my new semester has just started, ... 
06:17:53 <shapr> what classes do you have?
06:19:48 <cptchaos> im studying mathematics and Physics and, visiting lectures in "Functional Analysis", Quantum Field Theory, General Relativity and Time Series Analysis in Mathematical statistic
06:20:05 <cptchaos> don't know if that is all translated correct
06:20:25 <shapr> sounds like fun
06:20:28 <cptchaos> won't have much time for coding at the moment
06:20:32 <shapr> hej chucky 
06:20:40 <shapr> especially quantum field theory sounds like fun
06:20:50 <cptchaos> yes its very intresting
06:21:04 <chucky> hi shapr
06:21:18 <shapr> did you get HaskellDB working with hs-plugins?
06:21:20 <chucky> dons, are you here today too? :) I need some more help
06:21:22 <shapr> cptchaos: no time for coding :-(
06:21:25 <chucky> almost. :)
06:21:49 <cptchaos> :-/ yes and I allost got my project finished ...
06:22:42 <chucky> shapr: I have something that theoretically works, but in practice I get Fail: Prelude.undefined from hs-plugins. That might be my fault though...
06:33:02 * shapr drinks caffeine and sugar
06:33:02 <shapr> mmmm
06:48:39 <bourbaki> moin
06:52:33 <musasabi> hello bourbaki 
06:54:01 <bourbaki> :) hi\
07:06:05 <xerox> yo
07:07:34 <bourbaki> ho ho ho on the dead mans ship ;)
07:22:32 <shapr> ho ho ho
07:22:38 <shapr> netsplits are fun!
07:25:05 <bourbaki> :)
07:25:13 <bourbaki> @arr
07:25:13 <lambdabot> Ahoy mateys
07:25:14 <cptchaos> I have read about a new backend in ghc 6.4, does anyone know what kind of improvements they want to do?
07:25:22 <bourbaki> hahah :)
07:25:33 <musasabi> Is there a reason Complex is limited to reals ?
07:25:37 <shapr> cptchaos: C-- first of all
07:25:43 <shapr> get rid of the Evil Mangler forever!
07:25:48 <shapr> @arr
07:25:48 <lambdabot> This is the END for you, you gutter-crawling cur!
07:26:19 <shapr> @arr
07:26:19 <lambdabot> Yeh scurvy dog...
07:26:22 <shapr> @arr
07:26:22 <lambdabot> Aye Aye Cap'n
07:26:22 <bourbaki> :)
07:26:24 <shapr> @fortune
07:26:24 <lambdabot> There's nothing like the face of a kid eating a Hershey bar.
07:26:27 <shapr> @arr
07:26:27 <lambdabot> This is the END for you, you gutter-crawling cur!
07:26:30 <shapr> again?
07:26:32 <bourbaki> i feel as if id need an eyepatch :)
07:26:32 <shapr> boring!
07:26:33 <shapr> @arr
07:26:34 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
07:26:36 <shapr> @arr
07:26:36 <lambdabot> Drink up, me hearties
07:26:38 <shapr> @fortune
07:26:38 <lambdabot> There are many intelligent species in the universe, and they all own cats
07:26:41 <shapr> haha
07:27:02 <shapr> @listcommands quote
07:27:02 <lambdabot> Module quote provides the following commands: ["fortune","yow","arr"]
07:27:05 <shapr> @yow
07:27:05 <lambdabot> Should I do my BOBBIE VINTON medley?
07:27:12 <shapr> @hello World.
07:27:13 <lambdabot> Hello world. World.
07:27:28 <bourbaki> @hello @hello
07:27:28 <lambdabot> Hello world. @hello
07:27:31 <cptchaos> shapr thanks
07:27:52 <shapr> cptchaos: getting rid of the Evil Mangler could mean easier porting to new platforms
07:27:55 <shapr> I hope it means that at least
07:28:08 <shapr> new template haskell goodies in 6.2
07:28:17 <shapr> ArrowTransformer libs will be standard
07:28:30 <bourbaki> whats an arrow transformer :)?
07:28:41 <shapr> IPv6 if CosmicRay and/or I can get it done in the next week ;-)
07:28:47 <shapr> bourbaki: you know monad transformers?
07:28:52 <cptchaos> because I was Thinking of an direct translation to something like c (c++ would work), with dircet I mean with no use of an abstract machine
07:28:55 <bourbaki> no :)
07:29:30 <bourbaki> from where to where does it transform?
07:29:50 <cptchaos> ext-core would be fine
07:30:09 <shapr> does Core turn into STG?
07:30:25 <cptchaos> shapr: yes
07:31:09 <tnks> hey guys, is there a log() function in haskell that's base 2?
07:31:14 <cptchaos> got bourbaki question wrong ...
07:31:19 <tnks> Or do I have to define my own?
07:31:47 <cptchaos> tnks: don't know, but I would bet there is none
07:32:39 <tnks> oh well. . . I guess I'll be scaling by (log 2)
07:32:57 <CosmicRay> shapr: heh, it's not a top priority for me
07:33:03 <cptchaos> tnks: scaling?
07:33:18 <CosmicRay> shapr: though it is something I'd do eventually if nobody else does
07:33:31 <CosmicRay> shapr: if you add IPv6, I'll make my FTP module support it.  How's that? :-)
07:33:32 <shapr> CosmicRay: I've been saying that for more than a year =)
07:33:42 <shapr> I've been saying I'll sit down and do IPv6
07:33:46 <shapr> hasn't happened yet.
07:33:51 <shapr> life is just too exciting.
07:33:55 <shapr> or something.
07:33:57 <CosmicRay> ftp is one of those protocols that has to be modified to suport ipv6.
07:33:58 <CosmicRay> sigh.
07:34:00 <cptchaos> tnks: don't you wan't the inverse of \ x -> 2^x ?
07:34:20 <shapr> Lemmih: database format changed any?
07:35:10 <shapr> musasabi: you around?
07:36:06 <shapr> Lemmih: it's up: http://www.scannedinavian.org/cgi-bin/hackage/hackage
07:36:36 <shapr> I still like the idea of an hourly walk of the wiki to ease database insertion, edit, etc.
07:36:41 <shapr> but hey, it's your code :-)
07:36:53 <cptchaos> tnks: ... ah that you mean, had to write it down first
07:39:19 * shapr sings badger badger badger
07:40:33 <earthy> mushroom mushroom
07:41:15 <earthy> a snake! a snake! ooooh... it's a snake!
07:42:33 <bourbaki> ?
07:42:37 <bourbaki> did i miss something?
07:42:50 <bourbaki> whats that about all the bagers and snakes and mushrooms ?
07:44:53 <earthy> http://www.badgerbadgerbadger.com/
07:47:07 <shapr> for more along those lines, http://wtf.cookiethievery.com/
07:48:56 <shapr> the Lego Rave is pretty spiffy
07:49:09 <xkb> is there any tool to convert .hs files to eps or something else usable in latex?
07:49:17 <xkb> Im using listings package now
07:49:31 <xkb> but that's not really suited for larger files imo
07:50:41 <shapr> lhs2tex?
07:51:21 <xkb> Ok I can try that again
07:58:26 <peti> Hi.
08:04:57 <kosmikus> hi swiert, hi peti
08:05:11 <swiert> hi kosmikus
08:05:12 <kosmikus> finally committed bnfc ;)
08:05:29 <swiert> bnfc?
08:06:06 <peti> kosmikus: I sow it. Very nice, thanks!
08:06:20 <shapr> bnfc?
08:06:26 <shapr> the chalmers.se thingy?
08:06:27 <peti> Uh ... s/sow/saw/ of course
08:07:17 <kosmikus> shapr: yes
08:07:25 <peti> bnfc is great. The only problem is that there is hardly any grammar that's well-formed according to its definition. :-( 
08:08:25 * peti will be away for a moment ... Need food. :)
08:09:45 <shapr> kosmikus: committed bnfc to what?
08:18:51 <shapr> hoi Boegel 
08:20:32 <Boegel> hello :)
08:20:41 * Boegel hates proving math stuff
08:21:07 <cptchaos> Boegel: what's your problem?
08:22:21 <kosmikus> shapr: Gentoo
08:22:31 <shapr> oh
08:23:25 <kosmikus> shapr: peti had requested it a long time ago
08:23:32 <shapr> ah, I see
08:23:39 <ianxek> I'd like to know if there's a simple graphics library like Ocaml's Graphics ?
08:23:50 <shapr> HGL
08:24:34 <cptchaos> *g*, thought of HGL too, but I don't know how simpel Ocaml's Graphic lib is ...
08:24:42 <Boegel> cptchaos, oh, we have this class "fuzzy set theory" (lightly translated), and we have to prove stuff
08:24:58 <Boegel> and I can't get it correct, and it should be pretty easy
08:25:19 <shapr> Boegel: does the set of sets that contain themselves contain itself?
08:25:40 <shapr> hej bringert!
08:25:43 <Boegel> shapr, don't mess with my head :p
08:26:00 <shapr> Boegel: what? do you already know where I'm going with this? ;-)
08:26:13 <Boegel> recursion or something like that
08:26:24 <shapr> worse than that ;-)
08:26:35 <cptchaos> *bg*
08:26:36 <Boegel> according to the definition it should contain itself, but where do you stop :)
08:26:45 <shapr> you're right it does contain itself.
08:27:01 <Boegel> shapr, why is that so hard ?
08:27:01 <shapr> what about the set of sets that do not contain themselves?
08:27:10 <shapr> where does that set fit in?
08:27:37 <Boegel> that set is empty ? right ? every set contains itself ?
08:27:50 <shapr> the set of rocks does not contain itself.
08:27:56 <shapr> since rock != set
08:27:57 <Boegel> rocks ?
08:28:01 <shapr> the set of all rocks.
08:28:03 <bringert> hej shapr
08:28:05 <tuomov> define contain
08:28:13 <tuomov> subset or member?
08:28:15 <Boegel> tuomov, contain : is in
08:28:16 <Boegel> :)
08:28:16 <shapr> is an element of itself
08:28:21 <shapr> member
08:28:33 <shapr> so, the set of rocks is not a member of the set of rocks
08:29:01 <shapr> the set of sets that contain themselves is a member of the set of sets that contain themselves, right?
08:29:08 <xkb> but a set of rocks contains a set of rocks
08:29:08 <Boegel> shapr, by rock you mean stone, brick ? or is it something mathematical I don't know about ? :)
08:29:22 <shapr> Boegel: nah, I mean like, a brick.
08:29:28 <Boegel> ah okay
08:29:38 <Boegel> you lost me then shapr  ;p
08:29:56 <shapr> well, if you say "all the rocks in entire universe" that's the set of all rocks, right?
08:30:12 <shapr> rocks, bricks, whatever...
08:30:29 <cptchaos> iff there aren't some rocks outside the universe, whatever that means :-)
08:30:43 <shapr> right well... I assume there aren't ... at least, I don't know of any.
08:30:56 <shapr> ok now, there is the set of all sets, right?
08:31:16 <Boegel> yep
08:31:27 <shapr> obviously, it must contain itself, because, it is a set, and it holds all sets.
08:31:32 <Boegel> yep
08:31:46 <shapr> now, what about the set of all sets that contain themselves? does it contain itself?
08:32:18 <bringert> mu
08:32:31 <Boegel> yes, same as above...I'm not sure though :)
08:32:49 <shapr> ok, now the set of all sets that do *not* contain themselves. does it contain itself?
08:33:44 <Boegel> no
08:33:53 <Boegel> according to the definition
08:34:07 <shapr> wait, if it doesn't contain itself, then it's part of the set, right?
08:34:16 <shapr> the set of all sets that don't contain themselves, yes?
08:34:23 <Boegel> euh yes :)
08:35:04 <Boegel> but then, if it contains itself, then it's not ok with the definition, so it doesn't contain itself...
08:35:05 <Boegel> :)
08:35:05 <shapr> but then, if it contains itself, it can't be a member of the set of sets that don't contain themselves, right?
08:35:09 * shapr grins
08:35:18 <Boegel> i got it :)
08:35:22 <Boegel> so math = bull :p
08:35:24 <shapr> haha
08:35:29 <shapr> that's called Russel's Paradox
08:35:34 <shapr> er, Russell(?)
08:36:08 * Boegel feels the ground pounding and screams "it's a mathematician stampede ! run for your life ! "
08:36:13 * shapr laughs
08:36:17 <bourbaki> heh
08:36:36 <shapr> that's one of the discoveries that led to GÃ¶del's Incompleteness Theorem.
08:37:21 <Boegel> but anyway, I should prove transitivity of <= starting with irrflex of < and trans of <, and using the def x =< y <=> x < y OR x = y
08:37:32 <Boegel> it seems real simple, but I can't get it to work :s
08:38:43 <Boegel> I meant transitivity of =< (greather then or equal)
08:40:31 <shapr> bringert: hej, I mentioned XmlRpc on ghc-users today
08:41:36 <bringert> wait, is there a haskell mailing list I'm not on?
08:42:47 <Boegel> I'm out, watching 24, bye !
08:43:04 <shapr> bringert: glasgow-haskell-users ?
08:43:08 <shapr> something like that.
08:43:12 <shapr> there's a whole bunch of mailing lists
08:43:40 <shapr> speaking of which, I've been thinking of a 'gossip' tree
08:43:51 <danols_> what's the character for new line ? as in "test <newline test"
08:43:58 <Boegel> \n
08:44:16 <shapr> a gossip tree is where you can 'subscribe' to a tree of inputs about subjects
08:44:18 <danols_> thanks
08:44:21 <Boegel> np
08:44:26 <Boegel> *gone
08:44:59 <shapr> a gossip tree includes blog feeds, usenet discussions, website rss feeds, irc logs, repository urls, or whatever
08:45:26 <bringert> sounds like a good idea
08:45:38 <shapr> basically, RSS for anything internet
08:45:55 <shapr> and the subscriber chooses their subjects and mediums
08:46:19 <bringert> there sure are a lot of haskell mailing lists, I think I am on about 5 of them
08:46:30 <shapr> I think I'm on too many.
08:46:37 <shapr> not quite all of them, but nearly.
08:47:20 <shapr> oh, peti's postmaster is spiffy =)
08:47:36 <Si\> I've got an idea to build on Typeable and Data to further Generic programming.
08:47:51 <shapr> with that and a haskell pop3 server, I'll be able to write my own anti-spam email system!
08:47:55 <shapr> Si\: oh, talk to kosmikus 
08:47:59 <Si\> How about adding another class called Meta which stores semantic meta data about the type data
08:48:14 <shapr> kosmikus is Mr. Generic Haskell
08:48:21 <shapr> er wait, sorry...
08:48:26 <Si\> like axioms and such
08:48:29 <shapr> *Doctor* Generic Haskell
08:48:30 <Si\> not Generic Haskell
08:48:41 <Si\> SYB
08:48:55 <shapr> yah, but kosmikus is an expert on generic programming with Haskell from what I've seen. :-)
08:48:57 <shapr> SYB?
08:49:07 <shapr> shove your buddy?
08:49:13 <Si\> Scrap Your Boilerplate
08:49:16 <shapr> oh =)
08:49:18 <shapr> right
08:49:22 <Si\> Generic Haskell is something different all together
08:49:32 <shapr> yah, it is
08:49:38 <shapr> type-indexed everything
08:50:16 <Si\> point is currently you have a complete syntactic description about a type structure, but there is no way of declaring axioms over the data to aid in parsing/serializing
08:50:47 <danols_> what is the code /r for ?
08:51:42 <Si\> for example in GXS, you have to have lots of horrible tables here and there for storing namespace data and XSD typing data which is frankly not good for scalability
08:52:10 <shapr> maybe you need epigram? =)
08:52:35 <Si\> whereas if you could declare axioms over the data you could really do some cool stuff
08:54:00 <shapr> like what?
08:54:04 <shapr> peti: y0, you there?
08:54:06 <kosmikus> while SYB is certainly different from GH, they are still similar in goal
08:54:26 <shapr> peti: I sent you a patch
08:54:32 <shapr> now trying to build postmaster with 6.3
08:54:42 <shapr> eek
08:55:38 <shapr> doh, missing libs...
08:56:45 <Si\> Does GH have any system for declaring semantic declarations over types?
09:38:50 <bourbaki> fstep :: Float -> Bool; fstep x | x >= 0  = 1; | otherwise = 0
09:39:38 <bourbaki> fstep ((fstep x) + y) is there a way to get rid of the outer fstep and keep the same value?
09:42:55 <Lemmih> Keep the same value?
09:49:42 <bourbaki> the same result
09:49:54 <bourbaki> fstep ( x + y ) wont work
09:53:08 <Lemmih> You want to find out if (x+y) is non-negative?
09:54:03 <bourbaki> what i want is to get rid of one of the fsteps
09:55:10 <Lemmih> Maybe you should start by changing the type of fstep.
09:55:22 <bourbaki> to?
09:55:38 <Lemmih> :: Float -> Float
09:55:45 <bourbaki> ok and then?
09:56:11 <Lemmih> I'm not really sure I know what you're trying to do.
09:56:31 <bourbaki> well ok ill write down the complete problem
09:56:36 <Lemmih> You know that 1 and 0 are not boolean values.
09:56:48 <Lemmih> Right?
09:57:02 <bourbaki> yes its just my lazyness
09:57:37 <bourbaki> P x = fstep ( <(x,1),(w,b)> )
09:57:42 <bourbaki> thats a perceptron
09:57:48 <peti> Could you guys do me a favor and send me an e-mail (or two) to <simons@cryp.to>, please? I need to test something.
09:58:02 <Lemmih> peti: Sure.
09:58:13 <bourbaki> now i got an assignment asking me to show that P2 (P1 x) = P3 x
09:59:35 <peti> Hmpf. Still get an exception from runInteractiveProcess. :-(
09:59:46 <bourbaki> P x = fstep (( fstep ( <(x,1),(w,b)> ) * v ) + b_2) <=> fstep (( fstep <(x,1), v*(w,b)> ) + b_2)
10:00:17 <bourbaki> but i dont see a way to get rid of the b_2 and the second fstep to yield a function of the from P x
10:00:37 <arjanb> hallo illustir
10:02:30 <illustir> hallo
10:51:21 <Lunar^> Hackage is really cool ! :)
10:51:35 <Lemmih> That was fast.
10:51:42 <monochrom> That's a funny name.
10:52:04 <stepcut> Lunar^: how cool is it ?
10:55:11 <jadrian> hello
10:55:18 <Lemmih> Hey jadrian
10:55:25 <jadrian> hi Lemmih 
10:56:21 <bourbaki> bah this makes my head burn
11:00:25 <jadrian> is there any standard way to write "ands" of functions?
11:00:46 <jadrian> s/ands/ifs
11:00:53 <jadrian> by that I mean something like
11:01:08 <jadrian> iff odd then (2*) else (3*)
11:01:17 <jadrian> you get the picture...
11:01:55 <jadrian> or do I have to define my own function for that?
11:01:57 <Lemmih> What about: if odd then (2*) else (3*)?
11:02:28 <jadrian> it doesn't make sense because odd is not a Boolean ;)
11:02:44 <CosmicRay> you phrased it as a boolean
11:02:46 <CosmicRay> I'm confused
11:02:55 <jadrian> sorry I'll explain better
11:02:57 <CosmicRay> you could always do (*) (if odd then 2 else 3)
11:02:58 <CosmicRay> :-)
11:04:01 <jadrian> choice test f g x = if test x then f x else g x 
11:04:12 <jadrian> ...
11:04:36 <CosmicRay> that looks good to me
11:04:48 <jadrian> now I'm just asking if I'm reinventing the wheel ;)
11:04:56 <CosmicRay> ah.
11:04:59 <danols> does prelude have a function to search for a substring withing a string ?
11:04:59 <CosmicRay> no, I don't think so.
11:05:02 <jadrian> if there is any std "choice" function
11:05:30 <Lemmih> danols: No /-:
11:05:37 <jadrian> some time ago I duplicated quite a bit of arrows
11:05:38 <danols> Lemmih hmm
11:05:57 <jadrian> not the general case, but I could use arrows for what I was doing...
11:06:00 <Lemmih> Oh wait. I was thinking of regex.
11:06:00 <CosmicRay> danols: my MissingH lib has one
11:06:45 <CosmicRay> or you could use a regexp
11:07:26 <Lemmih> CosmicRay: Some of the functions in your MissingH library are also in the standard libraries.
11:07:41 <CosmicRay> Lemmih: yes, but they *should* all be noted :-)
11:07:43 <CosmicRay> that one isn't
11:07:53 <CosmicRay> Lemmih: if there are any you're aware of that aren't noted, please let me know
11:08:10 <CosmicRay> Lemmih: I started writing MissingH before I was completely familiar with what was in the standard libraries
11:09:01 <Lemmih> Ah. They are indeed noted (-: I missed that when I was browsing it before.
11:13:49 <Lemmih> Hello ows
11:15:35 <ows> Yellow Lemmih
11:19:16 <CosmicRay> Lemmih: actually, a couple of them I knew already existed, and are just aliases because sometimes it logically makes more sense to think of things a different way.  but there are only 4 or 5 functions in the whole thing that are aliases anyway.  most of the code is brand new (or at least stolen <g>)
11:20:19 <Lemmih> (o:
11:22:48 * esap just implemented category theory limits with Haskell.
11:23:24 <jadrian> do you know any good book about Category Theroy and Functional Languages
11:24:18 <esap> jadrian: sure, there are many, what kind you need? basics or advanced?
11:27:13 <esap> jadrian: "Categories for types" is one that has pretty good exposition of FP with category theory (though is not intended for beginners)
11:28:07 <jadrian> esap: I've studied category theory ;)
11:28:46 <jadrian> esap: it was a pure math course 
11:28:54 <esap> jadrian: ok. There is one book even available on-line, though I can't now remember its name.
11:29:28 <jadrian> esap: If I could get a really good one I wouldn't even mind buying it...
11:29:40 <jadrian> esap: I'll check that one
11:30:11 <esap> jadrian: Pitts: Categorical Logic is available on-line http://citeseer.ist.psu.edu/pitts01categorical.html
11:30:13 <vivek> hello all
11:30:22 <esap> jadrian: That's pretty good as well.
11:30:45 <jadrian> esap: thanks!
11:33:17 <bourbaki> esap how did you do that limit computation?
11:33:49 <esap> I can paste it, hold on
11:33:59 <bourbaki> esap cool thanks
11:34:20 <danols> do you guys have suggestions on how to search for a substring within a string ?
11:34:42 <esap> bourbaki: http://www.kotiposti.net/epulkkin/Limit.txt
11:35:33 <danols> and what does \r stand for ?
11:35:41 <esap> \r?
11:35:58 <esap> carriage return? :-)
11:36:10 <danols> esap just checking :)
11:36:32 <danols> esap any ideas on how to search a substring within a string ?
11:37:58 <Oejet> danols: Implement a DFA.
11:39:03 <bourbaki> esap hm i dont get that really to be honest :)
11:39:29 <esap> bourbaki: It's based on the adjoint definition of limits.
11:40:35 <esap> bourbaki: there is a functor Const : C -> [I,C]. Lim is the right adjoint of Const.
11:41:30 <esap> bourbaki: Const produces a constant functor for each object and identity arrow for each arrow
11:41:53 <bourbaki> esap so you have a limit of all identity functors?
11:42:36 <esap> bourbaki: no, I think the limit construction works for all functors [though Haskell limits it to *->* due to kinds]
11:43:43 <bourbaki> esap the adjoint is a way to construct the limit? i just think how i could make use of that for my stuff *think think think*
11:44:41 <esap> bourbaki: Yes, you can actually build limits as right adjoint [and colimits as left adjoint] of the same functor.
11:45:20 <bourbaki> esap i just wonder how you can construct it in general thats why i ask
11:45:31 <bourbaki> TheHunter hi
11:46:26 <bourbaki> esap do you have a sec to help me with another math prob?
11:46:28 <esap> bourbaki: Colim -| Const -| Lim, where Const : C -> [I,C]  Const(A) = <functor that ignores its domain and produces object A> Const(f) = id
11:47:54 <esap> bourbaki: no, actually, Const(f) has to be a natural transformation.
11:48:41 <esap> bourbaki: but it's a natural transformation such that the component Const(f)_I = f
11:48:58 <bourbaki> esap i think i need to read on that again but i didnt thought that there was a possibility to do a limit in general due to its different meanings
11:49:29 <esap> bourbaki: it is possible [I'm reading this from Crole: Categories for types.
11:49:44 <esap> bourbaki: page 93 
11:50:16 <TheHunter> hi bourbaki 
11:50:16 <bourbaki> esap thats the book you reffered to earlier ? or is that a paper i can get online?
11:50:22 * esap nods.
11:50:47 <esap> bourbaki: it's a book, I'm not aware it's available on-line
11:51:05 <bourbaki> ok i try to get it at the lib or tell my logic prof about it ;)
11:51:30 <jadrian> What do you call functions like map, fold, scan. That is, those basic polymorphic functions that you define over your datatypes, in order to build other functions?
11:51:33 <bourbaki> esap this one? http://www.amazon.com/exec/obidos/tg/detail/-/0521450926/102-8430459-6264113?v=glance
11:52:12 <jadrian> I was going to call them generic, but that might sound like "generic haskell"
11:52:37 <esap> bourbaki: yes, that's it.
11:53:23 <bourbaki> esap thanks ill have a look into that one then
11:53:41 <bourbaki> TheHunter do you have a sec for a math prob i have?
11:54:20 <TheHunter> sure
12:35:29 <Lunar^> Peter Simons did IT !
12:35:34 <Lunar^> YEAH !
12:36:24 <Maddas> Did what?
12:36:38 <Lunar^> Now I want POP3, IMAP and Webmail on top of Postmaster
12:36:48 <Lunar^> http://postmaster.cryp.to/
12:36:49 <Maddas> Ok
12:36:58 <Lunar^> For the complete integrated mail solution
12:37:20 <Maddas> Thanks
12:38:39 <Etaoin> woo
12:39:12 <Maddas> Wow, looks very cool!
12:42:19 <bourbaki> gnight #haskell
12:42:30 <Lemmih> Bye bourbaki.
12:53:43 <ralf_> I have a question:  I am a beginner, I have been working on haskell for about a month.  I would like to read a file into a list of lines. 
12:53:46 <ralf_> What tool should I use? 
12:55:32 <stepcut> readFile and lines
13:10:49 <jadrian> Lunar^: "Postmaster allows you to do anything. I really mean it." ... "What can it not do? At the moment, Postmaster has no mail queue." :)    I know it's in the TODO... 
13:10:59 <chucky> 2
13:14:44 <chucky> any hs-plugins developers here perhaps?
13:19:33 <Cale> yes, dons -- but I'm not sure if he's here
13:22:26 <chucky> no it would seem so
13:50:44 <shapr> Lemmih: hey, the HaskellDbTutorial has moved to HaWiki
13:51:23 <shapr> so, what's going on guys?
13:51:33 <shapr> whoa 97 clients =)
13:51:53 * chucky just discovered the reason hs-plugins doesn't build correctly
13:52:53 <shapr> what's the problem?
13:53:23 <chucky> using GHC 6.3, it assumed I had write access to the GHC directory
13:53:32 <chucky> which I didn't, since I wasn't root
13:53:48 <shapr> strange, I didn't need write access...
13:54:00 <shapr> I used hs-plugins in-place for a few days that way.
13:54:52 <chucky> might be my ad-hoc GHC 6.3 installation
13:56:20 <chucky> ouch! Now I know why things aren't working
13:56:32 <chucky> root still runs ghc 6.2.2! :O
13:56:48 <shapr> oh!
13:57:53 <chucky> that was confusing. :)
13:57:59 <Oejet> GHC from CVS won't compile for me :-(
13:58:24 <shapr> Oejet: what's the problem?
13:58:28 <shapr> HOpenGL?
13:58:40 <shapr> salut Lukhas, Ã§a va?
14:02:17 <Oejet> peter@eigil /Files/Compile/Sources/fptools]sudo configure
14:02:17 <Oejet> ...
14:02:17 <Oejet> checking empty struct support... yes
14:02:17 <Oejet> configure: creating ./config.status
14:02:17 <Oejet> config.status: creating mk/config.mk
14:02:18 <Oejet> config.status: creating mk/config.h
14:02:20 <Oejet> config.status: error: cannot find input file: mk/config.h.in
14:02:31 <shapr> hmm
14:02:44 <shapr> are you using lndir to build a shadow dir for building?
14:03:31 <shapr> because, if you are it's possible that new file was created in your most recent cvsup and hasn't been symlinked yet.
14:03:48 * stepcut kicks udev in the nads
14:03:54 <shapr> ooh, what's it doing?
14:04:10 <stepcut> it's not doing dynamic module loading
14:04:33 <shapr> oh
14:06:50 <stepcut> the devs think that when you add and remove hardware, that should trigger creation of nodes and loading of modules. Which is fine, except, I need to dynamically load the ppp module when someone opens /dev/ppp, there is no hardware involvode
14:07:30 <shapr> does udev use hotplug?
14:08:40 <stepcut> hotplug and sysfs
14:09:51 <shapr> can you fake a hotplug event by wrapping /dev/ppp with an event script?
14:10:29 <stepcut> dunno, how would that work ?
14:10:38 <chucky> question: If I want different code for different GHC versions, do I need to do some kind of preprocessing or is there a better way?
14:10:49 <stepcut> when someone tries to open /dev/ppp, I need that to automatically load the ppp module
14:11:25 <shapr> stepcut: inotify?
14:11:36 <shapr> chucky: cpp :-(
14:11:49 <shapr> that's all I've ever heard of.
14:12:20 <chucky> ugh
14:12:26 <chucky> I was afraid of that. :(
14:12:43 <shapr> if you want extra sanity, try to put all your cpp-needing code into a single module that clearly shows what gets switched out
14:13:09 <shapr> it sucks a lot to have to crawl all over a bunch of code to find hidden cpp statements to edit/delete
14:13:22 <chucky> yeah that's what we have now. The problem is, all that is needed now is some syntactic fixes. GHC 6.3 changes some stuff in Data.Dynamic
14:13:39 <Oejet> shapr: Hm, it doesn't work with a fresh checkout. It should just be "configure; make; make install", but configure is not even there.
14:14:13 <shapr> Oejet: "autoreconf"
14:14:27 <shapr> configure is generated from .ac (autoconf) files.
14:14:50 <chucky> oejet: if there's no reason for you to build directly from CVS, you might try one of the nightly snapshots instead.
14:15:02 * shapr considers making a darcs mirror of the ghc cvs repo
14:15:40 <Oejet> chucky: Well, trying to make a GoboLinux recipe for it. Just to see if I can.
14:15:45 * shapr got rid of his desk chair a few days ago, and put a couch in the same place
14:16:02 <shapr> PairCouching roxx
14:16:48 <stepcut> shapr: I have a recliner with a foot stool at work...
14:16:59 <earthy> then either you have a sturdy and probably expensive couch, or you don't sit in it for very long
14:17:05 <shapr> ohh, I want a recliner.
14:17:12 <shapr> earthy: no, I just kill couches quickly.
14:17:22 <earthy> I tend to find my desk chair more comfortable for long bouts of computerplay
14:17:27 <shapr> not me
14:17:39 <shapr> I find it difficult to stay in the same position for even a minute at a time
14:17:41 <CosmicRay> shapr: do you have any idea how I could return an error code from a process started via forkProcess without making the ghc rts print out a nasty "forkProcess: uncaught exception" to the screen?
14:17:55 <shapr> @index forkProcess
14:17:56 <lambdabot> System.Posix,System.Posix.Process
14:18:00 <earthy> owh, yah
14:18:05 <shapr> @type System.Posix.forkProcess
14:18:06 <lambdabot> System.Posix.forkProcess :: IO ()
14:18:06 <lambdabot> 			    -> IO System.Posix.Types.ProcessID
14:18:13 <CosmicRay> problem is in the RTS
14:18:23 <CosmicRay> ghc/rts/RtsAPI.c:       prog_belch("%s: uncaught exception",site);
14:18:24 <earthy> but the couch I own is quite uncomfortable in any position but hanging
14:18:37 <CosmicRay> that's what I'm getting if I try to use exitFailure in the child
14:18:38 <earthy> and hanging disallows armmovement ;)
14:18:41 <CosmicRay> (in that IO action
14:18:44 <shapr> earthy: I'm considering switching to a tatami futon
14:19:08 <shapr> hm, forkProcess doesn't let you return an exitcode?
14:19:11 <shapr> is there one that does?
14:19:15 <CosmicRay> not afaik
14:19:30 <CosmicRay> it would have to wait on it
14:19:33 <CosmicRay> and that defeats the purpose
14:19:39 <CosmicRay> the exit code is not available after fork()
14:19:44 <CosmicRay> it's only available after a waitpid()
14:19:53 <CosmicRay> in between the fork and the waitpid, you probably want to do stuff
14:19:57 <CosmicRay> like shove data down a pipe in my case.
14:20:12 <Oejet> shapr: Autoreconf, I have never heard about, but it seems to work.
14:20:20 <Lemmih> shapr: Yay.
14:20:28 <stepcut> shapr: http://www.ikea-usa.com/webapp/wcs/stores/servlet/ProductDisplay?catalogId=10101&storeId=12&productId=11051&langId=-1&parentCats=10114*10292
14:21:04 <stepcut> (in black)
14:21:06 <earthy> tatami is straw matting. you intend to sit on a straw mat on a thin mattress on the floor?
14:21:18 <shapr> I'm trying to decide whether it's easier to a) beat mailman into creating archives, or b) resurrect curryspondence and add a thread view
14:21:39 <earthy> I'd say b)
14:21:44 <shapr> earthy: if it's straw matting on a foldy futon, sure
14:21:50 <earthy> even though there is evidence that a) is possible
14:22:04 <stepcut> speaking of tatami, any here slept on a japanese style futon?
14:22:20 <shapr> we have an ikea-style japanese-style futon.
14:22:31 <stepcut> shapr: ??
14:22:35 <shapr> I *really* like futons for sleeping on.
14:23:14 <shapr> stepcut: as in, we're considering purchasing a real japanese futon from an import company in .de, but for the moment we bought a westernized futon because someone else was selling theirs.
14:23:24 <stepcut> ah...
14:23:27 <Lemmih> shapr: Where did you move the HaskellDB tutorial?
14:23:48 <stepcut> shapr: I have had several western style, but they always sagged in the middle and crap like that...
14:23:56 <shapr> Lemmih: http://www.haskell.org/hawiki/HaskellDbTutorial
14:24:18 <shapr> stepcut: er, in what middle?
14:24:22 <stepcut> shapr: There is only one place in the US I can find that sells japanese style, and they are on the opposite coast, so it's hard to try it out :)
14:24:24 <shapr> hoi goron! hoe gaat het?
14:24:48 <goron> shapr: I once got the darcs repository of Yi. Is there a command to say:svn up(if you svn, that is)?
14:24:50 <shapr> stepcut: yah, shipping the futon from .de is more expensive than purchasing.
14:24:50 <stepcut> shapr: the middle of the futton...
14:24:51 <goron> shapr: Hoi
14:24:59 <shapr> goron: darcs pull -a
14:25:06 <goron> :-)
14:25:23 <goron> Yeah!
14:26:09 <shapr> stepcut: the futon we have here is wood slats closely spaced with a thin 'mattress' on top. There's no space for it to sag.
14:27:21 <stepcut> shapr: ah
14:27:45 <shapr> oh hey, I have a unicycling hopping picture of me that I just got from the nice dutch girl who visited us...
14:27:54 <stepcut> the futons I have had are about 8" thick :)
14:28:03 <shapr> geez, that's huge
14:28:21 <stepcut> shapr: about the thickness of a normal mattress...
14:28:24 <shapr> with futons like that, you must 'roll' them regularly to restore fluffiness.
14:28:31 <goron> shapr: I called today to HP support (my scanner doesn't work for quite a while), but it seems my NForce2,Windows XP, HP ScanJet 5200C combo is not supported. On some Windows XP installations it does work, but not mine. What kind of a compatibility is that? That's what I have done today. Very annoying...
14:28:32 <shapr> and to keep the contents from settling
14:28:47 <shapr> goron: that sucks :-(
14:28:56 <stepcut> shapr: i tried rolling, fluffing, flipping -- it's futile
14:29:05 <shapr> goron: I've heard a lot of horror stories about the NForce2
14:29:08 <shapr> stepcut: futonile? ;-)
14:29:10 <stepcut> shapr: now I just through a bunch of blankets and pillows on the floor and sleep on that
14:29:28 <shapr> stepcut: was it regularly maintained and that still happened?
14:29:49 <earthy> the nofrce2 is not *that* bad
14:29:56 <stepcut> shapr: yes, and I have even gotten new high-tech, zero maintainance ones :)
14:30:08 <shapr> wow, how much do you weigh? ;-)
14:30:14 <stepcut> :p
14:30:24 <shapr> of course, I weigh 94.5 kilos at the moment...
14:30:32 <earthy> geez. you are big. :P
14:30:40 <shapr> down from 107 at the beginning of the summer.
14:30:54 <stepcut> i think the problem is the futons are just two thick and fluffy, so there is too much room for them to compress
14:30:58 <earthy> (to whit, you're still about 25% heavier then I am ;))
14:31:13 <tromp> that's a fine weight if you're 1.95m tall
14:31:23 <shapr> er, I'm not.
14:31:28 <stepcut> 6'3", 75kg
14:31:34 * earthy simply sleeps on fairly hard foam mattress
14:31:38 <shapr> 5' 10" 95kg
14:31:43 * earthy is 6'2" at 75kg
14:31:49 <tromp> 6'1" 80kg
14:32:09 <earthy> (187cm to be more exact)
14:32:33 <earthy> and the mattress is on a `lattenbodem'... damn... another word I don't know how to translate
14:33:00 <earthy> horizontally mounted flexible beams of wood
14:33:03 <tromp> shapr, why not come visit me on your unicycle? by the time you get to amsterdam u'll be under 80kg
14:33:24 <earthy> Ikea UK website to the rescue
14:34:04 <goron> shapr: It's a Windows (stupid idiots (can't Simon P.J. help the poor suckers)) problem (and because my parents have no idea of what a computer is, it's my problem :(  ). I seem to agree more and more on the matter of openness of software with you. 
14:34:09 <shapr> unretouched photos just received today, note they're each about 500k - http://www.scannedinavian.org/~shae/unicycle/
14:34:51 <shapr> goron: maybe your parents would like Linux? it sure gets less network worms.
14:35:09 <shapr> see, here's me hopping on my unicycle: http://www.scannedinavian.org/~shae/unicycle/PA090170.JPG
14:35:19 <tromp> wow, you're airborn
14:35:20 <earthy> right. a slatted bed base... that's a name I'd *never* have come up with by myself
14:35:26 <shapr> marianne caught a pic while I was nearly at the top of a hop.
14:35:47 <earthy> on digital?
14:36:19 <shapr> tromp: Sadly, I tend to gain weight when exercising, ~95kg is my minimum. I instead build up muscles.
14:36:32 <shapr> earthy: yes, she's the girl in the last pic
14:37:07 <earthy> that's *impressive* timing.
14:37:36 <tromp> of course, if you take 10 pics while he's hopping...
14:37:38 <shapr> her cam has some cool feature where it takes a whole bunch of pix in a row
14:37:42 <tromp> one is bound to be near the top
14:37:48 <shapr> tromp: yah that's what happened.
14:38:18 <goron> shapr: I don't think so, considering the fact that they always choose Windows in the grub menu and even startup IE6 while it's full of security leaks (and I maked them aware of what might happen). They don't like changes (as most people). Thanks. 
14:38:53 <shapr> goron: worms will make changes for them :-(
14:41:50 <goron> shapr: No, because they don't had to solve the Sasser Worm we experienced. They say:"I am not experiencing any difficulties, so it's ok". It's that I don't use Windows for important things, but I should do a reinstall from a security point of view. 
14:43:15 <goron> Probably it's didn't, instead of don't. Am I right?
14:43:16 <shapr> maybe you could give them a walkthrough of Linux? They might even like it better since it tends to look about the same, and is generally faster.
14:44:01 <shapr> like, KDE is pretty windowsy, and can look very nifty.
14:45:01 <goron> shapr: The boot time is slower, because Windows doesn't wait until there's a internet connection. (Getting an IP takes 10 seconds on Linux). And then there's the vendor-lock-in problem. 
14:45:56 <andersca> shapr: gnome!
14:45:57 <shapr> ah, I have a simple solution for your first problem. parallelize your /etc/rc3.d/ startup (or whatever runlevel you use)
14:46:02 <shapr> ok, gnome =)
14:46:32 <shapr> I don't really care as long as it's 100% keyboard usable, and I don't ever have to resize a window.
14:47:11 <shapr> speaking of which, I should file a wishlist bug against the ion3 deb. It's way older than the snapshots.
14:47:28 <goron> shapr: How? And why isn't it standard?
14:48:12 <shapr> um, I forget the details off the top of my head, and I don't know why it's not standard.
14:48:25 <goron> shapr: Well I google for it. 
14:48:33 * shapr googles too
14:50:56 <goron> http://www-106.ibm.com/developerworks/linux/library/l-boot.html?ca=dgr-lnxw04BootFaster
14:51:24 <goron> This seems useful. 
14:51:59 <shapr> and in fact, this *is* standard in LSB http://www.linuxbase.org/spec/refspecs/LSB_1.1.0/gLSB/initscrcomconv.html
14:53:51 <goron> What's Debian anyway? Is it targeted at server-apps, or developers? I thought the latter. 
14:55:16 <monochrom> It's targetted at Debian users.
14:55:19 <shapr> I don't know what target debian has... 
14:55:33 <goron> shapr: I don't read it's standard. It's not excluded.  
14:55:41 <monochrom> Actually it's targetted at paranoid people.
14:55:43 <shapr> you don't read Debian's standard?
14:55:44 <goron> monochrom: That too. 
14:56:04 <shapr> I use Debian for servers, desktops, gateways... pretty much everything.
14:56:07 <goron> shapr: I read the URL you gave me.
14:56:12 <shapr> ah
14:56:35 <goron> 	
14:56:38 <goron> This specification does not require, but is designed to allow, the development of a system which runs boot scripts in parallel. Hence, enforced-serialization of scripts is avoided unless it is explicitly necessary. 
14:57:09 <shapr> ah, I see what you mean.
14:57:18 <goron> What did you mean?
14:57:53 <shapr> well, I didn't mean anything in particular, but I now see that the LSB standard allows but does not require parallel startup.
14:58:13 <shapr> that makes sense, makes it easier to create a completely new distro.
14:58:18 <shapr> that's still LSB
14:58:33 <shapr> I wonder if Debian supports this.
14:58:34 <goron> You would be a good politician :)
14:59:28 <shapr> Probably not, I tend to put community progress ahead of my own progress.
14:59:50 <shapr> Economically speaking, that pattern is vulnerable to the 'free rider' flaw.
15:00:07 <TheHunter> goron: an easy way to get some percent increase in startup time is using a leightweight shell.
15:00:56 <goron> shapr: I don't know the 'free rider' flaw. Is it that some people benefit from other people's work, while in fact they do nothing(the free part)?
15:01:03 <shapr> exactly
15:02:14 <shapr> Also, most governmental systems prioritize survival of the system over benefit to the people.
15:03:17 <shapr> I think for the same reason that your parents don't want to use Linux, because it's easier to keep on doing the same old thing until it's so broken you can't keep doing it.
15:03:33 <goron> TheHunter: lightweight shell? You mean like IceWM or something like that? I know they won't like it. But thanks for the tip. 
15:04:58 * goron reads the IBM story. 
15:05:04 <TheHunter> goron: i meant something like using dash instead of bash, but if after thinking about it twice, i guess it'll only save you at most a few seconds.
15:05:30 <shapr> I think service parallelization is the most gain for the least effort.
15:05:43 <shapr> Especially if you have two cpus like me.
15:06:11 <shapr> I am tempted to start a linux tuning wiki.
15:06:31 <shapr> but wait, I should be writing Haskell code instead...
15:06:37 * shapr goes back to fixing Flippi
15:06:53 <goron> TheHunter: bash starts in milliseconds. At least in X. Or am I wrong?
15:08:35 <joao> Hello
15:08:40 <Lemmih> Hey joao
15:08:44 <shapr> Ã³le joao 
15:08:55 <shapr> how's code?
15:09:01 <goron> Hi joao 
15:09:09 <TheHunter> goron: during bootup, the shell is called for each startup script, so maybe 50 or 100 times. bash startup time seems to be something like 0.03 seconds, so not much gain :(
15:09:16 <joao> shapr, getting shape :)
15:09:37 <joao> I need to discuss some ideas...
15:09:42 <shapr> are you using FISh?
15:09:47 <shapr> ok! what ideas?
15:10:09 <goron> TheHunter: I now understand your point. It seems stupid to restart bash each time. (Creating a new process).
15:10:09 <joao> FISh ?
15:10:30 <shapr> it's a language that deals with the shapes of problems :-)
15:10:33 <shapr> just a silly joke
15:11:39 <joao> :)
15:12:05 <joao> shapr, my problem is...
15:12:18 <joao> I have some type, suppose [Int]
15:12:32 <Lemmih> shapr: Is is possible project everything in two tables in an easy way? (talking about HaskellDB)
15:12:49 <joao> I also have a class C, which defines a function "fc"
15:12:56 <shapr> Lemmih: eh?
15:13:17 <joao> Imagine now that there are two functions: add and del, which operate with [Int]
15:13:18 <shapr> sadly, I still think in SQL, what does that mean in SQL? just stuff together two tables?
15:13:55 <joao> I want add to verify a property (P1) before doing something
15:14:04 <joao> And I want del to verify P2
15:14:22 <joao> Is there any way of doing that using fc ?
15:14:27 <joao> For example:
15:14:38 <joao> instance C [Int] "add" where
15:14:41 <joao> fc=P1
15:14:50 <joao> instance C [Int] "del" where
15:14:51 <joao> fc=P2
15:15:10 <joao> then add = fc[add] blah
15:15:16 <joao> and del = fc[del] blah
15:15:28 <joao> Did I make myself clear? I don't think so...
15:15:47 <shapr> it sounds like you want pre and post conditions?
15:15:58 <joao> shapr, pre
15:15:58 <joao> :)
15:16:26 <Lemmih> shapr: You know you can limit the accessible fields via the project function.
15:16:58 <shapr> Lemmih: so you want two tables to show up as one?
15:17:13 <shapr> usually, linked on common values...
15:17:19 <shapr> or just show up?
15:17:21 <goron> shapr: The IBM "solution" is too much effort for a user. A programmer could make a program (that would be worth the efforts). It seems GNU/Linux does not have a good way of dealing with dependencies in rc.  
15:17:45 <shapr> goron: even so, you might be able to do it for your parents :-)
15:17:54 <shapr> if startup time is so important to them
15:17:55 <joao> Well, ideas?
15:18:09 <shapr> joao: I'm not sure what you want with the typeclass
15:18:10 <Lemmih> shapr: And just returning the table gives access to all fields. Now I'm wondering if I have to name the fields explicitly (via project) or if there's an easy way of doing it.
15:18:26 <shapr> but you can use functions like unless maybe?
15:18:28 <shapr> @index unless
15:18:28 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
15:18:28 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
15:18:28 <lambdabot> State,Control.Monad.Writer,Monad
15:19:15 <shapr> chucky: hey, what do you think?
15:19:26 <joao> shapr, well, my idea was to define a precondition just by defining and instance of the type with a certain function associated
15:19:55 <shapr> joao: you could do it with a monad...
15:20:11 <goron> shapr: The ratio time to figure out everything/boottime speedup is too high according to my standards (and every other sane person (I think)). But it's true I could do it. ;)
15:20:35 <shapr> actually, I keep meaning to parallelize my bootup.
15:20:54 <shapr> and it is especially worth the effort with SMP
15:21:02 <joao> shapr, I'm using Error monad
15:21:16 <goron> SMP>>NSMP :) 
15:22:07 <joao> shapr, I wouldn't like to define the precondition inside the function...
15:22:19 <joao> shapr, I'd like to define just the call to it
15:23:21 <shapr> joao: what about something like the instance of the maybe monad?
15:23:38 <goron> shar:  gentoo already offers this an an option.
15:23:38 <goron> Edit the /etc/conf/rc file
15:23:38 <goron> change
15:23:38 <goron> RC_PARALLEL_STARTUP="no"
15:23:38 <goron> to "yes".
15:23:45 <shapr> wow, cool
15:24:00 <shapr> I don't know if debian has it.
15:24:35 <joao> shapr, how do you suggest then? I'm not understanding
15:26:32 <shapr> Lemmih: have you tried just projecting and returning?
15:27:11 <shapr> joao: you can probably do it with a separate monad instance for each precondition, and then lift the calls through
15:27:27 * shapr thinks
15:27:52 <peti> Good evening.
15:28:02 <shapr> you might could do it with a record, but even if works right, it'll be way cheesy
15:28:03 <Lemmih> shapr: Well I have two tables (of type :: (GetRec er vr) =>  Rel er) which I would like to access.
15:28:09 <Lemmih> Hey peti.
15:28:42 <shapr> joao: hm, I'm sure there's an easier way...
15:29:29 <joao> shapr, my problem is: how can I define an instance for each precondition? The precondition depends on the function... a precondition evaluates a datatype, BUT just in a defined function scope
15:29:39 <joao> btw, i'm sorry my bad english :)
15:30:34 * peti recommends shapr for proof-reading duty. He'll eliminate any word he doesn't like -- whether it was correct or not. :-)
15:30:36 <shapr> I think higher-order functions is the easiest solution.
15:30:50 <shapr> peti: uh oh, what else did I get rid of? =)
15:31:05 <peti> shapr: Just my beloved tendentious. :-)
15:31:16 <shapr> peti: oh, I asked my fiancÃ©e (professional translator from SÃ¤Ã¤rbrucken) about tedentious
15:31:27 <peti> shapr: What did she say?
15:31:44 <shapr> she said that's the wrong word, and that there is a correct one..
15:31:47 * shapr tries to remember
15:31:49 <goron> shapr: THE solution: http://smarden.org/runit/ You may try it first lol 
15:32:22 <peti> shapr: Maybe this will help refresh your memory: <http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=tendentious&x=0&y=0> :-)
15:32:27 <shapr> Bea said the correct translation is to use 'tendency' as an adjective.
15:32:33 <shapr> tendential I think
15:32:49 <goron> GoogleFight!
15:32:50 <peti> Hmmm. Tendential sounds better, I admit.
15:32:55 <shapr> but I've never heard tendency used in an adjective form.
15:33:37 <peti> shapr: It's probably something only a German could come up with. 
15:33:49 <shapr> I'm used to that ;-) I live with one.
15:34:06 <peti> So do I. :-)
15:34:11 <shapr> Oh, Bea ran the social skills track at EuroPython 2004
15:34:33 <shapr> She gave the two of us as a case study of intercultural differences.
15:34:37 <peti> shapr: She's into computers too? That's rare! Consider yourself fortunate.
15:34:58 <shapr> For example, early in our relationship she asked me "Would you take out the trash?" and I said "Yes."
15:35:04 <shapr> Can you guess what happened next?
15:35:10 <peti> Then _do_ it. :-)
15:35:35 <shapr> Fifteen minutes later, Bea was unhappy that I had not taken out the trash.
15:35:51 <shapr> It took me some time to understand that there is an implicit "NOW" in every request.
15:36:34 <shapr> gotten any feedback about Postmaster?
15:37:26 <shapr> oh, is a pop3 and/or imap server also in your long-term plans?
15:37:35 <peti> shapr: I know that problem. In German, you put things like that to sound polite: Could I have another glass of water, would you take out the trash, etc. But if you put things like that in an foreign language, people don't get that you meant it as a _request_, rather than as a genuine question.
15:38:11 <shapr> Yes, but a request in American means "when you have time, could you do this thing"
15:38:34 <shapr> Otherwise, you would say "Could you do this thing right now, starting as soon as you've said yes?"
15:38:35 <peti> shapr: I've gotten several e-mails from people who are interested in using the MTA. Although I am not aware that anyone would actually _use_ it so far. :-) One guy is writing some big, fat web-based e-mail service!
15:38:58 <shapr> That would be Jeremy Bobbio, I suspect.
15:39:20 <shapr> Or maybe S. Alexander Jacobsson?
15:39:29 <peti> shapr: The latter, Alexander Jacobson. 
15:39:43 <peti> shapr: It appears he's already written SMTP client code. 
15:39:55 <peti> So there should be plenty of opportunity to share sources.
15:40:13 <shapr> anyway, I had another idea about Postmaster... I can finally implement my antispam idea! http://www.scannedinavian.org/~shae/antispamserver.html
15:40:46 <peti> shapr: I wouldn't mind adding POP3 etc. The architecture allows for all kinds of things to be added into the daemon. 
15:41:23 <peti> shapr: I think an integrated e-mail server with MTA, POP3, IMAP, web-based front-end, and all that would be pretty attractive.
15:41:33 <shapr> yah, very much so.
15:41:57 <shapr> especially if it works on windows too
15:42:40 <peti> shapr: Indeed! If anyone would port Postmaster to Windows, that would be really cool. And it should be possible, even! Except for syslog, there is little that's Unix specific in the code right now.
15:43:07 <shapr> how hard is a mail queue?
15:43:08 <peti> shapr: Just read your anti-spam idea. That's pretty neat! A nice variation of the challenge/response scheme people have been working with.
15:43:11 <shapr> doesn't sound very hard
15:43:49 <shapr> peti: dj bernstein had the same idea independently in 2000, but no one has ever implemented such a thing.
15:44:11 <shapr> has Jacobsson sent you his SMTP code?
15:44:20 <peti> shapr: The mail queue is no big deal. It's just not really exciting to code, so I didn't do it yet. I also wanted to know my "MailHandler" data type really works, before I build additional code around it. 
15:44:24 <shapr> hm, Hallgren's InternetLib has SMTP code too.
15:44:58 <shapr> hiya jadrian 
15:45:04 <jadrian> heya shapr!
15:46:52 <jadrian> there is no function like (!!') :: [a] -> Int -> Maybe a
15:46:58 <jadrian> in the std libs, right?
15:47:46 <shapr> peti: ah, InternetLib has only pop client code
15:47:50 <shapr> and nntp client
15:48:10 <joao> see shapr? (!!) needs a precondition :)
15:48:42 <jadrian> lol :)
15:49:06 <shapr> joao: a monad for each precondition will work, but I'm sure there's a better way...
15:49:10 <shapr> I just can't think of it right now.
15:49:24 <joao> Well
15:49:27 <joao> I can do something like
15:49:31 <marcot> Good night.
15:49:37 <shapr> good evening marcot 
15:49:43 <peti> shapr: I really have to look at this InternetLib. It's a pity it's such a mess. I wasn't even able to build it yet. :-(
15:49:46 <jadrian> not sure what you wanna do, but you can catch errors in the IO monad right?
15:49:49 <joao> data Pf a b = Pf (a->b) (a->Bool)
15:50:09 <joao> precheck (Pf f p) a | p a = Ok (f a)
15:50:16 <joao>               | otherwise = Err "blah blah"
15:50:23 <shapr> joao: but how do you change all the values of a precondition at once? only with a monad that I can think of.
15:50:53 <joao> Then, (!!') = Pf (!!) (\n l -> length l >= n)
15:51:12 <joao> precheck (!!') (3,[1,2]) would give Error
15:51:13 <joao> :D
15:51:14 <peti> I'll be back in a moment ...
15:51:15 <marcot> shapr: did you read my problem yesterday? I'm trying to implement init using foldr, as an exercise of the Thompson's book. My teacher wrote a very ugly solution, but I was looking for something more elegant.
15:51:37 <shapr> peti: if you get InternetLib to build, I want advice =)
15:51:59 <jadrian> joao: why do you want to do that, by the way?
15:52:22 <jadrian> can't you just "Maybefy" those functions?
15:52:30 <joao> jadrian, because I'm working on datatype invariants and functions preconditions
15:52:39 <jadrian> oh :)
15:52:45 <jadrian> still
15:52:50 <joao> jadrian, I want to define preconditions outside the function
15:53:14 <shapr> you can do that with a precondition monad
15:53:15 <joao> And, besides, in the final product, it should be optional to check pre, pos or datatype invariant
15:53:16 <joao> And, besides, in the final product, it should be optional to check pre, pos or datatype invariants
15:53:38 <jadrian> right
15:53:48 <shapr> but I'm not quite sure how to switch conditions per function.
15:54:04 <shapr> On the other hand, this is pretty much both Eiffel's design-by-contract and Aspect Oriented Programming.
15:55:12 <joao> shapr, I said I was here to discuss ideas... tell me more about it :)
15:56:14 <shapr> one monad per function is the best I can think of right now.
15:56:33 <shapr> and then lift through as many monads as you have
15:56:40 <joao> shapr, how do you do that?
15:56:48 <shapr> joao: do you understand the maybe monad?
15:56:55 <joao> I think so
15:57:21 <joao> I'm using the Error one, so I can get error messages
15:57:28 <joao> Ok a == Just a
15:57:31 <joao> Err String == Nothing
15:57:36 <shapr> do you know how to stack the Maybe monad on top of the Error monad?
15:57:56 <shapr> or, do you know how to stack monads in general?
15:57:59 <jadrian> why would he need that?
15:58:02 <joao> You mean, compose?
15:58:06 <joao> >>= ?
15:58:11 <jadrian> nope, Monad Transformers
15:58:32 <jadrian> shapr: right?
15:58:54 <shapr> or just lift
15:59:03 <jadrian> right
15:59:22 <jadrian> but why does he need the error monad?
15:59:30 <shapr> I don't know :-)
15:59:44 <joao> What do you suggest then?
16:00:09 <shapr> one monad per unique combination of conditions is the best I can think of right now.
16:00:17 <jadrian> not sure what you want to do...
16:00:22 <jadrian> but from what you've said
16:00:31 <shapr> (but I'm not an expert at all)
16:00:35 <jadrian> I'd just use your structure
16:00:55 <jadrian> then I'd define some "apply" functions
16:01:09 <jadrian> data Pf a b = Pf (a->b) (a->Bool)
16:01:22 <jadrian> apply :: Pf a b -> a -> Maybe b
16:01:35 <jadrian> then define composition of Pfs
16:01:39 <joao> shapr, please give me an example. type Stack = [Int] ; I'd like to define pop, which has as precondition pre s = length s > 0
16:02:02 <joao> jadrian, My error monad is the same as Maybe...
16:02:32 <jadrian> ok so use yours...
16:06:17 * shapr is thinking
16:07:01 <jadrian> by the way, isn't this wrong?
16:07:06 <jadrian> http://www.nomaware.com/monads/html/errormonad.html
16:07:15 <jadrian> --
16:07:17 <jadrian> instance MonadError (Either e) where 
16:07:17 <jadrian>     throwError = Left 
16:07:23 <jadrian>    (...)
16:07:31 <joao> shapr, you got time... i'll take a shower and brb :)
16:07:34 <shapr> heh
16:07:37 <shapr> my brain is friend :-)
16:07:39 <musasabi> Is it possible to do something like ungetc in haskell ?
16:07:46 <shapr> musasabi: what does that do?
16:07:57 <joao> lol
16:07:58 <shapr> oh hey, musasabi did you see the discussion stepcut and I had about mobile types?
16:08:00 <musasabi> shapr: unread a character read from a file.
16:08:12 <shapr> joao: um, "fried"
16:08:19 <musasabi> shapr: no sorry, was busy hacking things, and didn't look at irc/mail.
16:08:31 <shapr> good strategy, I should try that.
16:08:43 <jadrian> class (Monad m) => MonadError e m | m -> e where
16:08:47 <jadrian> instance MonadError (Either e) where 
16:08:56 <jadrian> ...
16:09:18 <shapr> jadrian: what's the problem?
16:09:21 <shapr> ohh
16:09:37 <shapr> I bet fundeps aren't worth mentioning in a monad tutorial.
16:09:45 <jadrian> instance MonadError e (Either e) where   <-- maybe they mean this?
16:10:00 * shapr doesn't know
16:10:30 <shapr> musasabi: in essence, I found this : http://www.haskell.org/pipermail/template-haskell/2003-September/000172.html
16:11:08 <shapr> and figured if I can dump a TH executable version of a type, I can then load that type on a remote RTS with hs-plugins
16:11:12 <shapr> g'day Pseudonym 
16:11:21 <Pseudonym> G'day.
16:12:01 <shapr> though stepcut wondered what useful things can be done from an RTS, to a type that didn't exist before hand.
16:12:05 * Pseudonym is learning about numeric analysis
16:12:15 <Pseudonym> Something that didn't interest me as an undergrad.
16:12:32 <shapr> specifically, how do you send functions across a wire to work on those new types?
16:12:34 * shapr doesn't know
16:13:14 <shapr> Pseudonym: what sort of numal?
16:13:16 <jadrian> I still don't completly get how to use (Either a) as a monad
16:13:23 <jadrian> I know it could be handy to me
16:13:31 <jadrian> because I'm using Maybe in my work
16:13:34 <Pseudonym> jadrian: Look at Control.Monad.Error
16:13:37 <shapr> jadrian: just like Maybe, but you pass either results or errors
16:13:41 <Pseudonym> The source code, in particular.
16:13:43 <shapr> instead of result or nothing
16:13:44 <jadrian> Pseudonym: I am :)
16:13:48 <Pseudonym> Ah. :-)
16:14:04 <musasabi> shapr: polymorphism should still remain a problem.
16:14:04 <jadrian> shapr: exactly, that's what I want to do...
16:14:15 <Pseudonym> Once you've mastered that, try to work out how to use (->) r as a monad.
16:14:35 <shapr> musasabi: how so?
16:14:51 <jadrian> and I actually find this because I thought it seemed an obvious step
16:14:55 <jadrian> I'm using Maybe
16:15:10 <jadrian> but I want to say why I failed
16:15:16 <shapr> stepcut said that you can't write code to operate on types you don't yet know exist
16:15:23 <shapr> which makes a lot of sense, I admit :-)
16:15:27 <musasabi> shapr: "If your 'x' variable is monomorphic, you can use the rType function that Sean and I came up with, detailed here:"
16:15:37 <Pseudonym> shapr: That's not _entirely_ accurate.
16:15:46 <Pseudonym> If the only way you deal with them is through a typeclass binding.
16:15:55 <Pseudonym> Something polymorphic.
16:16:01 <Pseudonym> Then you _should_ be able to deal with that.
16:16:30 <Pseudonym> If the first time you see the type is sent over a wire, though, you do have problems.
16:16:43 <Pseudonym> Getting the garbage collector to recognise it, for example.
16:17:23 <shapr> hs-plugins deals with this same situation correctly, doesn't it?
16:17:38 <Pseudonym> hs-plugins is okay because you're linking in static code.
16:17:40 <shapr> or does it require that types stay the same?
16:18:12 <shapr> well, same with a THSyntax description of a type
16:18:17 <shapr> you end up with static code
16:18:45 <shapr> I should just try to hack up a weenie mnesia-style db with this...
16:19:26 <jadrian> Pseudonym: where is that instance defined? do you know?
16:20:18 <Pseudonym> Which one?
16:20:50 <jadrian> Either as a monad
16:21:30 <shapr> musasabi: any ideas on beating the poly problem?
16:21:41 <jadrian> Pseudonym: got 
16:21:43 <jadrian> Pseudonym:  got it
16:21:51 <jadrian> Pseudonym: found it in the GHC sources
16:22:13 <Pseudonym> Ah, cool. :-)
16:22:41 <jadrian> No I didn't argh
16:23:21 <jadrian> ghc-6.2.1/libraries/base/Data/Maybe.hs <- defines Monad instance of Maybe
16:23:32 <musasabi> well that is kind of hard in Haskell, as polymorphic values can only be applied to their constraining typeclass's functions.
16:23:47 <jadrian> ghc-6.2.1/libraries/base/Data/Either.hs <- does not define Monad instance for Either :-/
16:24:16 <jadrian> ...
16:24:25 <jadrian> and why is Either marked as -- Stability   :  experimental
16:26:21 <jadrian> ...
16:26:24 <jadrian> Ok now I found it
16:26:30 <jadrian> ghc-6.2.1/libraries/base/Control/Monad/Error.hs
16:26:44 <Pseudonym> Yes.
16:26:45 <shapr> musasabi: I guess I should look into Goffin then.
16:26:49 <Pseudonym> That's where I thought you were looking.
16:29:10 <jadrian> Pseudonym: I was forgeting it needed "Error", so I was looking next to the definition of  Either and in the Monad module
16:29:18 <Pseudonym> BTW, I also implemented a monad which works like Maybe, only it works as a transformer.
16:29:24 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/mtl/Negate.hs?rev=1.2&view=auto
16:29:36 <Pseudonym> You might find that interesting.
16:31:00 <jadrian> nice
16:31:04 <jadrian> let me see
16:31:15 <shapr> hey Pseudonym, people asking what's up with Edison these days.
16:31:16 <Pseudonym> It works by CPS, though.
16:31:33 <jadrian> argh :)
16:31:48 <Pseudonym> Nobody is interested in it.
16:31:49 <jadrian> I should be more confortable with CPS than I am
16:31:57 <Pseudonym> That's the short answer.
16:32:02 <jadrian> :)
16:32:14 <shapr> hm, I heard a few people express interest.
16:32:27 <Pseudonym> The consensus seems to be that people think that something _like_ Edison is important, but not Edison itself necessarily.
16:32:42 <musasabi> shapr: perhaps, the easy solution would to have a typeOf :: a -> TypeRep ;)
16:33:03 <Pseudonym> Ah, yes, the Eval typeclass.
16:33:12 <Pseudonym> Actually, you don't need that.
16:33:19 <Pseudonym> typeOf :: (typeable a) => a -> TypeRep
16:33:24 <Pseudonym> typeOf :: (Typeable a) => a -> TypeRep
16:33:29 <Pseudonym> Sorry, capitalised wrongly.
16:33:55 <musasabi> Pseudonym: I know, but that little constraint makes some things quite hard.
16:34:13 <jadrian> I just don't understand why do I need the Error monad here
16:34:18 <Pseudonym> WHat would be handy is if, like in earlier Haskells, every type is a member of some typeclass.
16:34:26 <Pseudonym> It used to be called Eval.
16:34:37 <jadrian> and what is the purpose of the 	
16:34:38 <jadrian> noMsg  :: a
16:34:38 <jadrian> 	strMsg :: String -> a
16:35:12 <Pseudonym> Its methods were strict and seq.
16:35:56 <jadrian> So if I have 
16:36:02 <musasabi> sounds nice. afaik GHC has everything needed to implement the typeOf for all types (of course only ones with the kind *)
16:36:05 <jadrian> data = Fail1 | Fail2
16:36:11 <jadrian> data Fail = Fail1 | Fail2
16:36:16 <jadrian> and
16:36:34 <jadrian> data A = Either Fail Int
16:36:47 <jadrian> I can use Left Fail1, and Left Fail2 for failure
16:36:54 <shapr> er, what's the kind of x -> y -> z ?
16:36:55 <Pseudonym> OK.
16:36:56 * shapr forgets
16:36:57 <musasabi> jadrian: I have some examples using Error-monad in various ways (usually in a transformer) if you are interested.
16:37:08 <Pseudonym> shapr: It's *
16:37:10 <musasabi> shapr: *
16:37:17 <jadrian> musasabi: that would be nice :)
16:37:31 <shapr> so you think typeOf for (+) could be implemented?
16:37:35 <Pseudonym> jadrian: The reason why you need strMsg is to implement "fail".
16:37:51 <Pseudonym> shapr: Yes.
16:38:06 <shapr> and then I could send that value across a wire?
16:38:15 * shapr thinks about that
16:38:44 <jadrian> Pseudonym: hmm doesn't fail as some default method?
16:38:45 <shapr> that's equivalent to serializing functions, right?
16:38:50 <jadrian> s/as/has
16:39:21 <Pseudonym> In an error monad, you want "fail" to map to a catchable error.
16:39:50 <jadrian> Pseudonym: yes but my point was exactly, why do I need the erro monad at all?
16:40:06 <jadrian> Pseudonym: to use Either as a Monad that is...
16:40:47 <jadrian> 	return        = Right
16:40:47 <jadrian> 	Left  l >>= _ = Left l
16:40:47 <jadrian> 	Right r >>= k = k r
16:40:50 <jadrian> this would do it
16:41:06 <Pseudonym> Yes, that's true.
16:41:22 <Pseudonym> OTOH, you might want to replace your code that uses one monad with code that uses another.
16:41:26 <Pseudonym> Say, Error to ErrorT.
16:41:50 <musasabi> jadrian: http://www.cs.helsinki.fi/u/ekarttun/haskell/dns/ Type.hs - definition of MayIO, HiWire.hs and Main.hs for usage.
16:41:53 <jadrian> Yes true
16:41:57 <jadrian> thanks musasabi !
16:42:49 <shapr> musasabi: oh hey, did you figure out arrow drawing?
16:43:08 <shapr> or have you asked on the mailing lists?
16:44:03 <musasabi> shapr: perhaps, but whether that type is usable is an another story. (e.g. it may reason that (+) :: (* -> *))
16:44:54 <shapr> sounds even more interesting
16:44:57 <musasabi> shapr: I think the problem with that is allowing arr, but reformulating arrows without that is nontrivial.
16:45:31 <shapr> is it even possible?
16:45:45 <jadrian> Pseudonym: I just don't like it because I'll have to make my Fail type an instance of Error...
16:45:56 <shapr> or is 'nontrivial' tactful for "it would require a rewrite of Haskell" ?
16:45:58 <jadrian> Pseudonym: and that will just be a dummy instance
16:46:13 <musasabi> well it is certainly possible to have more restricted combinators which are a little bit like arrows, but their general usablity might be low.
16:46:28 <musasabi> shapr: hard to reuse in haskell more likely.
16:46:52 <shapr> what about the Yampa approach, where the difficult parts are implicit, and not to be directly handled?
16:46:55 <Pseudonym> jadrian: So make your own instance.
16:47:03 <Pseudonym> raise :: Fail -> Either Fail a
16:47:09 <shapr> or is that the same as removing arr?
16:47:13 <Pseudonym> Sorry, your own operation.
16:47:44 <shapr> is there a publishable unit below "research paper" ?
16:48:00 <jadrian> Pseudonym: yeap... I could do that.
16:48:24 <Pseudonym> shapr: "Letter" and "extended abstract"?
16:48:26 <musasabi> like Hughes noticed it makes sense to restrict arrows for many cases, however the restricted versions can are similar to arrows but incompatible.
16:48:27 <shapr> I was just thinking that arrow drawing might not be enough to write a full paper about, but would be a great essay at least.
16:48:43 <jadrian> Pseudonym: on the other hand I'd be kind of duplicating, one Type, Monad instance, and MonadPlus instance
16:48:44 <Pseudonym> Or you could mangle it into a functional pearl.
16:48:48 <joao> shapr, no example? :)
16:49:03 <shapr> joao: oh sorry, I got distracted
16:49:07 <Pseudonym> jadrian: Yes.
16:49:18 <shapr> joao: but it's just a modified Maybe monad
16:49:24 <shapr> or Error monad
16:49:26 <Pseudonym> Well, Either is already an instance of Monad if you import Control.Monad.Error.
16:49:33 <musasabi> Another choice would be to make the arity of the arrows abstracted, but that would need even more changes.
16:49:35 <Pseudonym> You don't need to use the MonadError operations.
16:49:50 <shapr> musasabi: abstract arity?
16:51:40 * shapr rereads SP*.hs
16:51:48 <jadrian> Pseudonym: yes, I know... now you lost me. I can either use Either with it's Monad/MonadPlus instance that requires Error, therefore us a dummy instance. Or define my own type and "duplicate" those definitions without Error. Either way it's trivial...
16:52:03 <musasabi> shapr: extra data is currently passed in tuples like with first. The reverse operation is done with e.g. "arr fst". 
16:53:09 <Pseudonym> Oh, duh.
16:53:23 <Pseudonym> I see.  Yes, you do need e to be an instance of Error to use Monad (Either e).
16:53:27 <Pseudonym> Hmmm.
16:53:31 <Pseudonym> OK, now here's a thought.
16:53:38 <Pseudonym> Add another constructor to your Fail type.
16:53:46 <Pseudonym> data Fail = Fail1 | Fail2 | FailStr String
16:53:47 <jadrian> yeap
16:53:51 <Pseudonym> That'd do.
16:53:52 <jadrian> oh
16:54:01 <Pseudonym> Then make an Error instance.
16:54:18 <jadrian> that is nicer then what I thought :)
16:54:30 <jadrian> I thought data Fail = Fail1 | Fail2 | DummyFail
16:54:33 <joao> see you tomorrow!
16:54:33 <Pseudonym> Right.
16:54:39 <shapr> cya joao 
16:54:40 <joao> shapr, tks
16:54:45 <joao> jadrian, tks
16:54:49 <joao> :)
16:54:50 <jadrian> bye joao 
16:55:32 <jadrian> is there any motive why we can't have different class instances depending one wether the class parameters belong to some other classes? 
16:55:38 * shapr comes up with a crazy idea for joao's problem using alpha renaming and a lazy list of conditions
16:55:50 <jadrian> as long as there is no overlaping everything should be ok...
16:56:23 <Pseudonym> I think the reason is that instance resolution is supposed to be efficient.
16:56:51 <stepcut> mysql 4.1.7 stable was released today
16:56:52 <Pseudonym> And deterministic.
16:56:52 <stepcut> :)
16:56:56 * stepcut dances around
16:57:11 <Pseudonym> stepcut: DOes it still have the GPL'd client library?
16:57:23 <stepcut> Pseudonym: no clue
16:58:06 <stepcut> Pseudonym: why do you ask ?
16:58:51 * jadrian is out!
16:58:53 <jadrian> bye all
16:58:58 <Pseudonym> Bye.
16:58:59 <jadrian> bye shapr ! 
16:59:02 <jadrian> bye Pseudonym !
16:59:18 <Pseudonym> stepcut: It means that Debian won't be including a binary distro of PHP with MySQL 4.1.7.
16:59:26 * musasabi goes to bed
16:59:26 <Pseudonym> Because PHP isn't GPL-compatible.
16:59:47 <Pseudonym> MySQL's client libraries used to be LGPL, so it didn't matter.
17:00:18 <Lemmih> shapr: http://212.242.49.100/d1.jpg
17:01:34 <Lemmih> Me showing your seat compared to my old one.
17:02:09 <Lemmih> Although you can't see much of me /-:
17:02:14 <stepcut> Optional GPL License Exception for PHP. As a special exception, MySQL AB gives permission to distribute derivative works that are formed with GPL-licensed MySQL software and with software licensed under version 3.0 of the PHP license.
17:04:12 <Pseudonym> Ah, OK.
17:04:18 <Pseudonym> Good.
17:04:19 <musasabi> or not.
17:04:44 <musasabi> it seems I cannot exit my app cleanly with GHC if one thread block in getChar.
17:04:57 <musasabi> *blocks
17:05:26 <musasabi> allways dies with "Fail: <stdin>: hGetChar: illegal operation (handle is finalized)"
17:06:39 <musasabi> any ideas how to kill it in a clean fashion?
17:06:50 <musasabi> other than manual killThread 
17:22:51 <rhw> What's a good haskell (standard?) library reference ?
17:23:28 <rhw> I was going to play a bit with Haskell (I read about 80% of Craft of functional programming) and I realised I can't do much without it :)
17:29:23 <peti> rhw: http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:29:48 <peti> That's the complete reference documentation of all libraries shipped with GHC (and the other compilers, too, I think).
17:31:38 <peti> musasabi: Use a wrapper around forkIO that takes the childs down when main terminates.
17:32:02 <rhw> Thanks, peti.
17:32:14 <peti> musasabi: What's happening is, I guess, that main has closed the handles while a fork'ed thread still tries to use them.
17:32:49 <peti> rhw: You'll find _lots_ of things on haskell.org, by the way. The complete language definition is on-line plus several tutorials and examples.
17:33:35 <peti> musasabi: I have had that exact problem, too, which caused me to write this: <http://cryp.to/child/>. 'par' is the function you probably need.
17:37:16 <rhw> peti, I was just looking for a library reference. I skipped the tutorial part and bought (and almost read) a book.
17:39:05 <peti> rhw: Fair enough. :-) 
17:39:15 * peti learned Haskell from that book, too. 
17:43:22 <rhw> How did you start to actually code *something* ? As the book emphases on the language, and not real-life usage.
17:45:22 <Lemmih> First you gotta find something you wanna write, and then you write it (-:
17:45:58 <peti> rhw: I can't say, really. :-) I read lots of papers about the language. There are a few particularly good ones when it comes to doing I/O, network stuff, concurrency, etc., and all of them contain plenty of example code. Seeing actual code  was very enlightening. 
17:46:37 <rhw> Hm, papers on network stuff ? Got a link ? :)
17:47:22 <peti> rhw: I think this one is great: <http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/>.
17:47:52 <peti> In it, Simon Peyton-Jones implements a complete web server, just like that. :-)
17:49:08 <rhw> Owies ! *opens*
17:49:18 <peti> rhw: Another really good one is "generalizing monads to arrows", which you'll find here: <http://www.haskell.org/arrows/biblio.html>.
17:49:39 <peti> rhw: That was the paper from which I /finally/ understood what a Monad really is.
17:49:57 <rhw> I was about to say "Not really clear about what a monad is yet"
17:49:59 <rhw> hehe
17:50:45 <peti> rhw: The problem is that it's _so simple_, that it's especially hard to grasp. A monad is a way to force computations into an ordering. Nothing more, nothing less. :-)
17:51:11 <peti> Uh, sequence is probably a better word than ordering for that, though.
18:04:57 <dons> moin
18:07:20 <Lemmih> Good morning, dons.
18:09:12 <dons> hey Lemmih
18:27:07 <shapr> y0 dons 
18:27:44 <shapr> Lemmih: I've never seen a seat like that before, ever
18:29:19 <danols_> i have a question
18:29:29 <heatsink> danols_: good!
18:30:04 <danols_> i used the network module to download a stream from http, everything works except it's 'corrupted', when the same stream is saved manualy using a browser all works
18:30:15 <danols_> i'm using binary mode for the file hangle
18:30:19 <danols_> any ideas ?
18:30:34 <danols_> *handle
18:31:01 <danols_> can i paste the code here ? it's only a few lines
18:31:11 <heatsink> use rafb.net/paste
18:31:19 <heatsink> use http://rafb.net/paste
18:31:28 <danols_> k
18:32:05 <danols_> heatsink can you take a look ? http://rafb.net/paste/results/QX2l4Z83.html
18:33:16 <heatsink> what is request?
18:33:28 <danols_> let me paste the whole thing than
18:34:12 <dons> shapr: get a bit scared when hs-plugins gets discussed on the TH list :}
18:34:14 <dons> that's just wrong
18:34:21 <danols_> heatsink http://rafb.net/paste/results/BIAHZm66.html
18:34:31 <danols_> request is a http get string
18:34:45 <danols_> everything works except that when I save it seems to be corrupted
18:34:48 <shapr> dons: whyfor?
18:35:29 <dons> too many levels of staged computation
18:35:33 <danols_> heatsink it could be something with the way binary modes write, prehaps it changes the output slightly
18:35:48 <heatsink> danols_: have you diffed the output files? or examined them in text editor?
18:35:49 <dons> though seafood has been joking about doing TH optimisations in GHC as plugins
18:35:51 <shapr> anyway, that's only a way to do mobile types, and some mobile values, but not really mobile computations
18:35:53 <heatsink> I mean... hex editor
18:36:14 <heatsink> danols_: I'ven't used the network module so I can't say whether usage is correct
18:36:22 <danols_> heatsink i was thinking of that, however i can't get the exact same stream twice
18:36:42 <danols_> heatsink when I point a web brower directly to the link and save the 'unknown' file it works
18:36:47 <shapr> Duncan Coutts mentioned that arrows, template haskell, and partial evaluation would work together well.
18:37:03 <heatsink> danols_: Is the stream roughly the same size as what the browser gets?
18:37:21 <heatsink> Some servers will send a redirect upon receiving an HTTP get
18:37:33 <heatsink> the browser follows the redirect to get the real file
18:37:41 <danols_> heatsink no that would not be the issue
18:37:58 <danols_> the file is 'corrupted' but readable as in there is sound and a distorted video
18:38:09 <heatsink> oh. Strange.
18:38:16 <danols_> heatsink yes indeed
18:38:18 <shapr> dons: I'm trying to find something interesting to drop into the template haskell list.
18:38:27 <shapr> Seems not many people are really using TH.
18:38:31 <dons> yeah, it's good. stir them up a bit
18:38:32 <danols_> heatsink i tried doing that with a gif file and it seemed to have worked
18:38:40 <danols_> heatsink that's why i'm puzzled
18:38:55 <dons> shapr: like the idea of stripping objects
18:39:00 <dons> will add code to mk/rules.mk now
18:39:03 <shapr> stripping objects?
18:39:07 <danols_> heatsink and i'm using a packet sniffer to help me, it seems all is good except when the file is written
18:39:25 <dons> stripped symbols
18:39:31 <shapr> reimplementing -split-objs with TH?
18:39:31 <heatsink> danols_: check the file in a hex editor
18:39:34 <shapr> that would probably work
18:39:43 <danols_> dons ? are you reffering to my problem ?
18:39:53 <dons> shapr: hmm. what do you mean by split-objs?
18:39:54 <heatsink> danols_: especially look for hex 10 13 combinations in the file output by haskell
18:40:02 <dons> you want split objs version of the Yi library?
18:40:08 <danols_> heatsink could you please explain why in plain english ?
18:40:21 <shapr> dons: nah, -split-objs version of everything :-)
18:40:24 <dons> because you get split-objs, on e.g. linux, by default
18:40:27 <shapr> oh
18:40:39 <shapr> I thought it didn't work on linux
18:40:41 <dons> that's why you have a 432k yi-static when stripped
18:40:46 <heatsink> danols_: If the file is getting written in text mode, newline (10) turns into crnl (10 13).
18:40:47 <dons> no, it's worked for yonks
18:40:53 <shapr> oh, ok
18:40:59 <heatsink> although you did open a binary file...
18:41:02 <dons> doesn't work on AIX, though
18:41:04 <dons> ;)
18:41:08 <danols_> heatsink i understand that, that's why i'm using binary mode
18:41:18 * shapr is unsurprised
18:41:28 <shapr> I am surprised the AIX works.
18:41:36 <dons> so was I
18:42:15 <dons> anyway, we can remove symbols from the yi binaries to keep users happy
18:42:23 <danols_> heatsink do you think it's prehaps how binarymode interprets some symbols ?
18:42:23 <dons> and pretend that it's just the same as vi
18:42:37 <dons> (except prettier on the insider)
18:42:40 <dons> inside
18:42:46 <heatsink> danols_: Binary mode should not translate any symbols.
18:43:11 <danols_> hmmm
18:43:15 * dons tries to finish new UI implementation
18:43:24 <heatsink> danols_: Seeing the difference between the dowload files may make it clearer what is going on
18:43:37 * shapr works on the two buffers for a bit
18:43:38 <danols_> i have an idea
18:43:41 <danols_> brb
18:45:43 <danols_> heatsink can you recommend a hex editor for windows ?
18:45:59 <heatsink> I don't know of one...
18:51:46 <shapr> dons: you're using ideas from chilli's fast lazy lexing paper?
18:52:02 <dons> not atm.
18:52:06 <dons> whyfor?
18:52:28 <shapr> just thought the keymap stuff was going to be a fast lazy lexer :-)
18:52:37 <dons> it was! using alex
18:52:40 <shapr> oh
18:52:41 <dons> but alex is too strict
18:52:41 <danols_> heatsink hmmmm
18:52:56 <danols_> heatsink hPutStr :: Handle -> String -> IO () that's a text operation prehaps that's corrupting my output ?
18:52:59 <dons> shapr: but that's a good idea.
18:53:01 <shapr> does alex incorporated chili's ideas?
18:53:05 <dons> he has some nice combinators
18:53:09 <dons> nope. 
18:53:14 <dons> alex is just lex in haskell
18:53:23 <dons> standars super-fast table driven lexer
18:53:24 <heatsink> oh
18:53:25 <shapr> dons: you realize I'm also looking for citation opportunities? ;-)
18:53:31 <heatsink> that wuold do it.... streams are one-way
18:53:48 <dons> ok. i know chilli's lazy lexer pretty well. maybe we could use that. 
18:53:49 * dons thinks
18:54:06 <shapr> I dunno, is that actually a better approach than just alex?
18:54:15 <dons> but we can't use alex for the keymap
18:54:19 <dons> because it is so strict
18:54:22 <shapr> ah
18:54:28 <dons> we need a ... lazy lexer!
18:54:32 * shapr cheers
18:54:39 * shapr laughs
18:54:43 <danols_> heatsink, hmmm so hPutStr  converts CRLF to LF ?
18:55:33 <heatsink> I think that only happens when output is a local file. But I haven't worked on windows much.
18:55:55 <danols_> hmmm heatsink ok, well that's the only thing i could think of
18:56:14 <danols_> heatsink is there a different write command ? that dosen't convert ?
18:56:19 * shapr reads the fast lazy lexing paper
18:56:42 <heatsink> danols_: does connectTo return a Handle?
18:56:56 <danols_> yes
18:57:14 <danols_> heatsink why ?
18:57:53 <danols_> heatsink connectTo :: HostName -> PortID -> IO Handle
18:58:05 <heatsink> I wouldn't normally think of a handle as encapsulating a TCP session
18:58:28 <dons> shapr: Chilli thinks this is a good idea :)
18:58:34 <danols_> heatsink i'm not sure where you are going with this
18:59:51 <heatsink> danols_: I'm trying to find the definition of connectTo... where is it defined?
19:00:20 <shapr> dons: which? use of lazy lexing, or finding more opportunities for citations?
19:00:21 <danols_> NETWORK
19:00:23 <danols_> brb
19:00:37 <shapr> @index connectTo
19:00:37 <lambdabot> Network
19:00:38 <danols_> yeah NETWORK class
19:00:46 <shapr> @type Network.connectTo
19:00:47 <lambdabot> Network.connectTo :: Network.BSD.HostName
19:00:47 <lambdabot> 		     -> Network.PortID -> IO GHC.IOBase.Handle
19:00:49 <danols_> module i mean
19:01:11 <dons> shapr: both, I'm sure
19:01:16 <danols_> heatsink the odd think i used binary mode with putStr before with no problems
19:01:33 <danols_> heatsink so i'm stumped why it's currupting now
19:02:49 <shapr> dons: heh, I'm sure I can think up more citation opportunities if that means time you spend developing yi is considered part of your education. =)
19:03:19 <dons> using chilli's work probably helps the good will towards my yi hacking, i'm sure ;)
19:03:41 <shapr> I understand :-)
19:04:35 <dons> and, the good thing is that the chilli lexers are truly lazy. just what we need
19:06:46 <danols_> heatsink hmmm
19:06:53 <danols_> anyone else have an idea ?
19:07:11 <shapr> yah, they are quite spiffy
19:07:16 <shapr> I wish I'd read this before.
19:07:20 <heatsink> danols_: are you sure that the handle that connectTo returns is for both sending and receiving?
19:07:45 <danols_> heatsink what do you mean ?
19:07:57 <danols_> heatsink i send the HTTP GET request and recieve a stream back
19:08:01 <danols_> heatsink so yes
19:08:14 <danols_> heatsink i've been using a packet sniffer to analyze the traffic
19:08:26 <heatsink> ok
19:08:36 <danols_> heatsink i've tested it with geting a simple gif file
19:08:57 <danols_> and when I load it up in a graphic program it is not corrupted
19:09:26 <danols_> heatsink do you have winamp ?
19:09:43 <heatsink> no
19:09:46 <danols_> i see
19:09:55 <danols_> i was going to send you the file
19:10:08 <danols_> hmm like i said the audio is there, the video is somewhat there, but corrupted
19:10:20 <shapr> danols_: what's the difference?
19:10:27 <shapr> exactly how is it corrupted?
19:10:34 <danols_> shapr artifacts
19:10:42 <shapr> no I mean, on a bit level
19:10:53 <danols_> shapr the funny thing is, when i use opera to download the stream it works perfect
19:11:04 <danols_> shapr i don't know
19:11:28 <danols_> i guess i should download a gif image and compare with the one saved in my browser
19:11:30 <danols_> brb
19:11:42 <shapr> danols_: can't you write a Haskell program to read the two files until there's a difference at the bit level?
19:12:01 <danols_> shapr that would be possible but would mean I would have to learn
19:12:22 <danols_> shapr brb i'm gonna run difference on a gif file downloded through my function and through a web browser
19:12:31 <shapr> how do you get data into the file on disk? what function do you use?
19:12:48 <shapr> do you use putStrLn or putStr or hPut or what?
19:12:53 <danols_> shapr http://rafb.net/paste/results/BIAHZm66.html
19:12:54 <danols_> brb
19:13:21 <shapr> danols_: turn off buffering
19:13:35 <shapr> does that change anything?
19:13:37 <danols_> shapr i've tried that before
19:13:42 <danols_> just give me a minute
19:17:06 <shapr> dons: hey, do the meta actions allow modeful keymaps?
19:17:49 <danols_> ok 
19:18:14 <danols_> here are the results after removing the http header i.e. ""HTTP/1.1 200 OK\r\nDate: Wed, 27 Oct 2004 02:18:0...."
19:18:21 <danols_> Compare: (<)D:\NSV_Grabber\test.jpg (10373 bytes) 
19:18:21 <danols_>    with: (>)D:\NSV_Grabber\thunders1.jpg (10373 bytes) 
19:18:21 <danols_>  
19:18:21 <danols_> The files are identical 
19:18:33 <danols_> suggestions ?
19:18:42 <shapr> do they both look the same in your browser?
19:18:46 <danols_> yes
19:18:55 <danols_> even witht the header left in
19:18:56 <shapr> then they're not corrupted, right?
19:19:05 <danols_> shapr that would be the conclusion
19:19:14 <heatsink> can you do the same comparison for the file that gets corrupted?
19:19:16 <shapr> but you do get corrupted mp3s, yes?
19:19:20 <danols_> shapr let me run another test this time i'll remove the header before writing the file
19:19:28 <danols_> shapr let me verify that
19:19:50 <dons> shapr: modeful keymaps should be easy. it just means checking an ioref, and taking a branch based on that
19:21:14 <shapr> dons: what about per-buffer modes?
19:22:04 <dons> ok. that means you bind keymaps not globally, but per-window (or buffer)
19:22:13 <dons> easy-peasy
19:22:30 <shapr> ok
19:22:30 <dons> the keymap field is not an Editor.state field, but a Window.state field
19:22:40 <shapr> makes sense to me
19:22:48 <Cale> shapr: seems like 60.25.122.54 needs banning
19:22:53 <shapr> Cale: ok
19:23:03 <dons> or -- you bind keymaps to chunks of text *in* the buffer
19:23:13 <dons> so .lhs would be handled nicely.
19:23:16 <dons> or math mode in .tex
19:23:28 <dons> not sure if this is feasible or confusing though
19:23:54 <dons> i.e. on interting a .tex comment in some .lhs, some keys would switch over to their .tex meaning
19:23:58 <dons> entering
19:24:04 <Pseudonym> BRB
19:25:45 <shapr> Cale: 60.25.119.199 and 60.25.127.199 is already banned, I wonder if 60.25.*.* needs to go.
19:25:51 <dons> or, not that keys would change, but the action bound to that key would change
19:25:59 <Cale> hmm...
19:26:06 <dons> so the newComment action would be different on entering .tex code
19:27:09 <shapr> Cale: seems to be hongkong
19:27:50 <shapr> all three of them are hk
19:27:56 * shapr viciously bans
19:29:01 <shapr> I really gotta get around to the global ban content stuff.
19:29:19 <shapr> I wonder when wiki spammers will figure out how easy it is to get around that :-/
19:29:39 <shapr> dons: yes, I like that approach best.
19:31:57 <shapr> I like the idea of a parse tree that's annotated with syntax highlighting, and the view attaches controller bits according to mode
19:33:13 <shapr> then you could have .lhs using two modes, xhtml files could use xhtml/javascript/css keybindings and syntax highlighting in the right place, etc
19:34:25 <dons> yeah. so we need to work out the representation for syntax trees that carry extra attributes with them
19:34:27 <shapr> dons: hey what do you think about the parse tree stuff? you think it's really workable? do you think users are willing to implement as much of a parser as they'll need for their new language-specific mode?
19:34:34 <dons> a generic syntax type
19:34:50 <dons> parse tree for what -- syntax hl?
19:35:03 <dons> or for keymaps
19:35:08 <shapr> for syntax hl
19:35:18 <dons> well, they have to currently in emacs or vim
19:35:19 <Cale> http://www.apnic.net/apnic-bin/whois.pl?searchtext=60.25.0.0
19:35:21 <shapr> I don't know how parsers could help keymaps?
19:35:29 <dons> using regexes to approximate parsing
19:35:52 <shapr> There's a *big* difference between regexes and parsing for syntax highlighting.
19:36:13 <dons> but the reason all syn hl sucks is because of the approximation
19:36:17 <shapr> for example "Marvin--" make a comment in haskell-mode in emacs :-(
19:36:20 <dons> plus, most languages come with a grammar
19:36:33 <dons> and we use happy, so it's just transcribing the standard grammar
19:36:42 <dons> much easier than transcribing the grammar into regexes
19:37:29 <dons> I think a happy parser for syn hl will be easier than a regex approx of the grammar
19:38:28 <shapr> that's good to hear.
19:38:34 <Cale> or parsec?
19:39:07 <shapr> oh speaking of which, swiert hacked up a minimal implementation of Parrowsec
19:39:31 <shapr> though that probably won't do much for yi :-)
19:39:57 <dons> well, there's no reason you *have* to use happy for syn hl
19:40:00 <dons> it's just the type
19:40:08 <dons> Window -> SynTree
19:40:12 <shapr> right
19:40:16 <dons> so you could use parsec if you really like that
19:40:26 <dons> or write it by hand for some small grammar
19:41:16 <dons> and because we're not using silly regexes, but the proper technology, the syn hl should be fast
19:41:23 <danols_> shapr: [Tuesday 22:22] <shapr> then they're not corrupted, right?
19:41:23 <danols_> [Tuesday 22:22] <danols_> shapr that would be the conclusion 
19:41:36 <danols_> the file is still corrupted
19:41:43 <danols_> but the gifs weren't
19:41:46 <danols_> i'm confused
19:41:51 <shapr> danols_: *which* file is corrupted, did you diff them?
19:42:17 <danols_> i can't diff the streams as I can't get two exact copies through my function and through the browser
19:42:22 <shapr> danols_: also, I have an excellent memory for things that happened in the last half hour or so, you don't need to paste background info ;-)
19:42:33 <danols_> but when i did the gif they were identical (after removing the http header)
19:42:42 <shapr> why can't you get two exact copies?
19:42:54 <danols_> shapr ;) about the memory good to know i suck at that 
19:43:29 <danols_> shapr well for once i wold have to save the browser and my function at the same time and end them at the same time
19:43:56 <danols_> shapr what's more important i believe is that the gif files which are not streams came up to be exactly the same through the browser and through my function
19:44:13 <shapr> have you tried downloading the same mp3 file from a server with both your browser and your code?
19:44:15 <danols_> right now i'm listening to a short mp3 file i recored through my function and the are noise artifacts
19:44:28 <shapr> I strongly suspect that those gif files weren't a sufficient test.
19:44:39 <danols_> shapr i don't see how that would make a diff. since i've done that test with a gif file
19:44:46 <danols_> shapr hmmm
19:44:48 <shapr> I also suspect that your problem is either LineBuffering, or it's that \r\n thing that win32 does.
19:45:14 <shapr> so, if your gif files didn't have any \n chars in them, they'd be fine
19:45:19 <shapr> aka \013 I think
19:45:22 <danols_> shapr  i'm guessing more that's it is the \r\n thing
19:45:34 <danols_> ok let me test with mp3 files
19:45:39 <danols_> any of the top of your head ?
19:45:40 <shapr> when one input works, and one input fails, find more test data
19:46:00 <shapr> if you can't find an mp3 file to download on the internet, the MPAA and RIAA will give you medal ;-)
19:46:26 <danols_> haha ok i'll get right on it
19:46:27 <danols_> brb
19:49:40 <shapr> dons: where's Chilli's fastlazylex code? It's not on his unsw software pages.
19:52:24 <dons> it's in the ctk library
19:52:28 <shapr> dons: actually, can I get a copy from you or Chilli?
19:52:30 <shapr> ohh
19:53:04 <dons> ctk light should be enough
19:53:13 <dons> http://www.cse.unsw.edu.au/~chak/haskell/ctk/index.html#CTKlight
19:53:43 * shapr apt-get's
19:54:06 <dons> cool thing is we should be able to insert new bindings into the keymap -- at runtime
19:54:10 <dons> can't do that in alex
19:54:57 <shapr> extraspiffy
19:55:36 <dons> even delete elements from the keymap lexer table
19:55:38 <shapr> keymaps as dynamically modifiably lazy lexers totally fulfills my technologist urges.
19:55:53 <dons> I suspected as much 
19:56:35 <shapr> I'm just a hotrodder...
19:56:51 * shapr wonders if that term is still used.
20:01:25 <shammah> shapr: I suspect that's a term that has inconsistent cross-cultural meaning :)
20:04:09 <shapr> uhoh
20:05:01 <shapr> Twenty years ago in the southeast usa, a hotrodder was someone who built fast and powerful cars for fun.
20:05:05 <danols_> shapr: i've tested mp3
20:05:09 <danols_> here are the results : Compare: (<)D:\NSV_Grabber\MarkSheeky-Oceanic.mp3 (1921024 bytes) 
20:05:09 <danols_>    with: (>)D:\NSV_Grabber\NSV_test.mp3 (1921024 bytes) 
20:05:09 <danols_>  
20:05:09 <danols_> The files are identical 
20:05:20 <danols_> now i'm puzzled
20:05:29 <danols_> the test is after removing http header
20:05:31 <shapr> did you listen to the file to check for artifacts?
20:05:45 <danols_> shapr doing it right now
20:05:49 <shapr> ok
20:05:54 <danols_> but if they are identical they should be exactly same
20:06:00 <danols_> sounds good so far
20:06:21 <danols_> so downloaded with a browser and through my function are the same
20:06:33 <danols_> shapr it just seems streams are fucking up
20:07:10 * shapr shrugs
20:07:41 <shapr> don't use windows? =)
20:08:04 <shapr> I don't know what's wrong.
20:08:56 <danols_> */*\r\nIcy-MetaData:1\r\nCuest = "GET /music/MarkSheeky-Oceanic.mp3 HTTP/1.1\r\     --hPutStr result <- hGetContents stream 
20:08:56 <danols_>      return result 
20:09:00 <danols_> crap sorry
20:09:06 <danols_> shapr http://rafb.net/paste/results/NTIkn576.html is my code at
20:09:27 <danols_> shapr you think it's a windows related thing ?
20:09:37 <shapr> I really don't know.
20:09:40 <dons> shapr: that term has the same meaning in aus, but probably not current since '80s
20:09:56 <dons> or maybe since Happy Days
20:09:57 <danols_> shapr hmmm i'm puzzled aswell
20:10:07 <shapr> dons: I'm old... ;-)
20:10:14 <dons> not that old
20:10:19 <shapr> 33
20:10:35 <shapr> I grew up in the 80s
20:10:42 <dons> so did i
20:10:44 <danols_> should i report this or something ?
20:10:48 <shapr> how old are ou?
20:10:52 <dons> 24 ;)
20:10:55 <shapr> danols_: hey! we're not doing anything illegal!
20:11:01 <danols_> lol
20:11:05 <danols_> no i mean my problem
20:11:08 <shapr> oh.
20:11:11 <shapr> I don't think it's a Haskell bug.
20:11:14 <danols_> i just don't understand what's the problem
20:12:06 <shapr> danols_: write some tests
20:12:51 <shapr> read in the saved and uncorrupted file of stream data, write out the file to a different name
20:12:56 <shapr> (with haskell)
20:13:08 <shapr> listen to the newly produced file to see if it's corrupted
20:14:09 <shapr> if you have an account on a linux box somewhere, try your code there and see if it makes a difference
20:14:11 <danols_> shapr i've listen to the file that was writen with my function it's sounds perfect, diff comparison shows no diffreances
20:14:30 <danols_> shapr hmmm the last i can not do, haven't had a linux box in over a year
20:14:41 <shapr> ok, try your code on the stream again then
20:14:47 <shapr> you've changed the buffering at least
20:14:53 <shapr> maybe it make a difference?
20:15:38 <danols_> yes to NoBuffering let me do the same with the binary file
20:15:40 <danols_> brb
20:16:13 <ned> hello all && just one idea : doesn't hPutStr interpret meta-carcter like '\' ? && sorry, time to sleep, see you
20:16:28 <shapr> salut ned
20:16:31 <shapr> bonne nuit
20:16:35 <ned> merci :)
20:16:38 <shapr> I should sleep too....
20:17:27 * shapr does so
20:21:12 <danols_> well i give up
20:21:25 <danols_> this is just to puzzling
20:21:35 <danols_> shapr NoBuffering didn't help
20:22:12 <danols_> it could be the way network module is impemented ?
20:23:24 <danols_> where could i post this problem so other ppl could prehaps give me an answer ?
20:24:19 <danols_> question does take change any of the elements as it reads them ?
20:26:19 <danols> sorry
20:28:29 <heatsink> danols: no
20:28:42 <danols> heatsink ?
20:28:47 <heatsink> take doesn't change anything
20:30:05 <danols> heatsink than i'm truly stumped
20:30:21 <danols> heatsink it seemed like a smiple problem, argh...
20:39:22 <dons> note to self. don't use undefined in a strict field
20:45:50 <heatsink> :)
20:46:42 <monochrom> Hahahahah
20:49:15 <heatsink> hmm... this is illegal:
20:49:21 <heatsink> type B = forall a. B -> a
20:50:08 <heatsink> ghc says "Cycle in type synonym declaration"
20:51:01 <dons> looks like a good error message to me
20:51:12 <heatsink> That's the type of (\x -> x x)
20:51:40 <dons> which has infinite type
20:51:43 <heatsink> yup
20:51:55 <heatsink> but it should be executable!
20:52:03 <dons> not in haskell
20:52:28 <heatsink> I guess I didn't need that function anyway...
20:53:08 <dons> use error instead ;)
20:56:10 <heatsink> type B = forall a. a -> B is also not allowed. That's the V combinator.
20:57:16 <dons> lots of stuff in untyped lambda calculus isn't allowed in typed lambda calculus
20:57:30 <heatsink> sure
20:58:29 <heatsink> I'm just testing the language. V _seems_ well-typed to me.
21:00:00 <dons> can you describe the function that has this type?
21:00:21 <heatsink> f x = f
21:00:39 <dons> @type const
21:00:40 <lambdabot> const :: forall a b. a -> b -> a
21:01:02 <heatsink> const x = x
21:01:09 <heatsink> I mean
21:01:11 <heatsink> const y x = x
21:01:26 <heatsink> argh
21:01:27 <dons> but f x = f isn't typeable
21:01:27 <heatsink> const y x = y
21:04:23 <heatsink> Okay, I think I see.
22:43:39 <musasabi> morning
22:44:13 <vivek> hello musasabi 
22:44:26 <vivek> what does ur nick mean in ur language ?
22:52:47 <Cale> giant flying squirrel?
22:57:35 <vivek> hmmz really ?
22:59:55 <musasabi> yes more or less..
23:00:14 <musasabi> What happens if there is an IOException inside unsafePerformIO ?
23:05:39 <dons> bad things ;)
23:06:30 <dons> the exception will just get thrown, but you don't know when
23:07:58 <dons> musasabi: you said you had some curses code?
23:11:15 <musasabi> yes, http://www.cs.helsinki.fi/u/ekarttun/haskell/Window.hs
23:11:33 <musasabi> although currently I am working on getting nice windowing in ANSI terminals without curses.
23:12:30 <dons> wow. this is the 4th or 5th curses binding I know of. we really should just write a standard one
23:13:37 <Pseudonym> Hmmmm.
23:13:48 <Pseudonym> OK, I'm trying to write an algorithm, but I can't think of the best way.
23:14:12 <Pseudonym> Basically, I have N sets of equivalence classes, and I need to "intersect" them.
23:14:13 <musasabi> dons: that was just a quick hack rather than a full binding, but I think I will have something really good working in a week
23:15:39 <Oejet> Pseudonym: Do you have a isMember :: a -> a Set function?
23:16:00 <Pseudonym> Not at the moment, but I can.
23:17:07 <Oejet> Ok, so what is the intersection of singleton set A and a set B?
23:17:29 <Pseudonym> If a \in A is also in B, then it's A.
23:18:01 <Pseudonym> Otherwise it's the empty set, and I need to drop the equivalence class.
23:18:12 <Oejet> Ok, what is the intersection of {x, y} and B?
23:18:45 <Pseudonym> It's { x | x \in A and x \in B }
23:18:51 <Pseudonym> Obviously.
23:19:28 <Oejet> Hm, list comprehension?
23:19:40 <Pseudonym> Set comprehension.
23:19:58 <Pseudonym> I'm using it as notation.
23:19:58 <Oejet> Well, convert to lists.
23:20:07 <Oejet> Ok.
23:20:13 <Pseudonym> Yes, in fact the data comes in as lists, basically.
23:20:20 <Pseudonym> (They're actually ASN.1 SEQUENCE OFs.)
23:20:33 <Pseudonym> (But that detail is irrelevant.)
23:21:07 <Pseudonym> For example, if I have the equivalence classes { {a, b}, {c} } and { {a}, {b, c} } then the intersection is { {a}, {b}, {c} }
23:21:38 <Oejet> Mmm, that looks wrong.
23:21:46 <Pseudonym> Why?
23:22:07 <dons> oh, this scrolling is really nice
23:22:16 * dons likes simple things
23:22:40 <Oejet> Because your intersection has the member {b}, which is in neither of the two original sets.
23:23:06 <Pseudonym> Ah, perhaps you misunderstand.
23:23:20 <Oejet> Please explain.
23:23:21 <Pseudonym> Basically, I have a set of sets, and I need to intersect that with another set of sets.
23:23:57 <Pseudonym> Let E1 be the first set of sets, and E2 be the second set of sets.
23:24:13 <Pseudonym> Then I want E = { X `intersection` Y | X <- E1, Y <- E2 }
23:24:20 <Pseudonym> And then remove the empty sets.
23:25:28 <Oejet> Ah, I see.  You want a kind of pairwise intersection.
23:26:57 <Oejet> {x, ...} `intersection` B = if x `isMember` B then x `addElem` ({...} `intersection` B) else ...
23:29:23 <Pseudonym> Something like that, yes.
23:29:41 <Pseudonym> Only I have N equivalence classes to intersect in general.
23:30:13 <Pseudonym> So if N is the number of equivalence classes, and M is the number of elements in the final class, the most obvious algorithm is O(N&M^2)
23:30:22 <Pseudonym> O(N*M^2)
23:30:26 <Pseudonym> Which is big.
23:32:18 <Oejet> Ok, so you need a specialised, efficient algorithm.
23:32:30 <Pseudonym> Well, I need something fairly clean.
23:33:25 <Oejet> I don't know if you have tried that one, and it was too slow?
23:33:26 <heatsink> How big are the contained sets?
23:33:47 <Pseudonym> heatsink: Most likely small, but some of them are going to be big.
23:34:34 <Pseudonym> The thing is... the overwhelmingly common case is going to be that the equivalence classes are the same.
23:34:58 <Pseudonym> Or the same, plus some elements which are unique to each class and hence won't appear in the final set.
23:35:28 <heatsink> You can find the elements unique to each class quickly, to start with...
23:36:00 <Pseudonym> Part of the complication is that each set comes with extra information that I need to preserve.
23:36:03 <Pseudonym> Hmmm.
23:38:27 <heatsink> If the common case is that each set will appear in both classes, then you can sort the sets in each class individually and find matches between the two classes.
23:38:42 <Pseudonym> I think I might have to do that, actually.
23:39:06 <Pseudonym> Doing a merge is going to be cheaper than doing intersection tests.
23:40:04 <Pseudonym> And simpler.
23:40:36 <Oejet> Wow, thats three things at once!
