00:13:48 <musasabi> morning
01:27:16 <bourbaki> moin
02:15:23 <pesco> Moin moin, #haskell!
02:15:38 <bourbaki> :)
02:15:55 <pesco> Hello bourbaki. What's going on?
02:15:57 <bourbaki> pesco: are you at uni?
02:16:05 <pesco> bourbaki: No, at home.
02:16:06 <bourbaki> nothing much yet :)
02:16:16 <bourbaki> no i mean in general are you studying?
02:16:24 <pesco> Oh, yes I am. :)
02:16:31 <bourbaki> where?
02:16:36 <pesco> Hamburg University.
02:16:46 <bourbaki> ah CS i suppose?
02:16:55 <pesco> CS and math.
02:17:02 <bourbaki> oh nice
02:17:32 <pesco> I'm aiming for Prof. Dr. Dr. Inf./Math. ;-P
02:17:42 <bourbaki> :)
02:18:10 <tromp> take about 2 years per letter:-?
02:18:12 <bourbaki> i wish i had the will to study math
02:18:22 <tromp> g'morning, btw:)
02:18:28 <bourbaki> :)
02:18:41 <pesco> tromp: Morning. Ah, let's say 1 year per letter.
02:18:55 <tromp> here it takes 4 years to become dr
02:19:29 <tromp> which is same as phd
02:19:36 <pesco> Ah yeah, all in all you might be right.
02:20:03 <tromp> prof in 8 years sounds about right too
02:20:24 <pesco> bourbaki: The trick is to not attend the lectures.
02:20:39 <tromp> that's hard to avoid as a prof:)
02:20:43 <bourbaki> you dont need to go to math lectures
02:20:50 <bourbaki> you need to read the script and books
02:20:58 <pesco> tromp: I mean as a student.
02:21:07 <tromp> i know; was just kidding:)
02:21:38 <pesco> tromp: Oh. It's still early. :) And I'm already programming. :-?
02:22:20 <pesco> bourbaki: Yes. And you skim the scripts to see what they contain, then just go on reading the books.
02:22:50 <pesco> Well, that's how I do it, everyone else goes to the lectures. Ah well.
02:23:59 <pesco> Good morning, xkb! Did I mention I like you again? You gave me access to all the greek letters!
02:24:02 <bourbaki> well the script i had for linear algebra was really really good
02:24:11 <pesco> bourbaki: Where are you from?
02:24:19 <bourbaki> osnabrueck
02:24:30 <pesco> Ahum.
02:24:37 * pesco scratches his head.
02:24:40 <bourbaki> ahum :)?
02:24:41 <pesco> Where is that?
02:25:06 <bourbaki> you know where bielefeld lies?
02:25:12 <pesco> Roughly.
02:25:20 <bourbaki> in its vicinity
02:25:30 <pesco> Ok.
02:25:36 * pesco digs up his map.
02:25:40 <bourbaki> :)
02:27:55 <pesco> Wow. Germany suffered through many decades of Communist influence.
02:28:04 <bourbaki> ?
02:28:10 <pesco>   -- worldatlas.com
02:28:46 <xkb> east germay
02:28:49 <xkb> eh
02:28:52 <xkb> nice spelling there :d
02:29:09 <pesco> Yeah. We suffered through many decades of East Germany. :)
02:29:15 <xkb> hehe
02:29:18 <pesco> Thank god, that's gone. ;-P
02:29:42 <bourbaki> i thought east germany was still there
02:29:43 <xkb> does it say "suffered" literaly?
02:29:51 <pesco> xkb: Yes.
02:30:03 <pesco> The quote is accurate except for the "Wow."
02:30:12 <xkb> worldatlas must be american :D
02:30:22 <pesco> Probably.
02:31:39 <pesco> bourbaki: Right. Actually, last time I looked, there was still some left, too.
02:31:46 <bourbaki> :)
02:31:55 <pesco> You could hear the Langoliers, though.
02:37:12 <pesco> Hey, can you tell me if my non-ASCII characters are coming through correctly now? äöü € αβγ (\"a\"o\"u \euro \alpha\beta\gamma)
02:37:22 <tuomov> yes
02:37:28 <pesco> Wonderful, thanks.
02:37:35 <bourbaki> not here
02:37:44 <tuomov> for the äöü; I can't display the rest
02:37:52 <pesco> bourbaki: Are you using UTF-8?
02:38:01 <bourbaki> i guess not
02:38:07 <tuomov> (the rest appears as EUR ??? as I'm using latin1 on my terminal)
02:38:59 <pesco> tuomov: You mean it can display only the latin-1 character set but interprets UTF-8.
02:39:12 <tuomov> yes
02:39:15 <pesco> OK.
02:39:43 <pesco> bourbaki: Try urxvt.
02:40:03 <bourbaki> nah im happy with my 26 chars :)
02:40:35 <pesco> Ok then.
02:40:37 <tuomov> for irssi, if you want to use utf-8 for a channel but still stick to latin1 for your terminal, you need the charconv module
02:41:17 <tuomov> http://norpan.org/cvs/charconv/
02:41:18 <pesco> And if your terminal sends UTF-8 (as urxvt does if it's set in the locale), you need to tell irssi about it in the term_charset setting.
02:41:41 <tuomov> what's keeping me from switching to mostly utf-8 is jed's lack of support for it... maybe Yi will fix the situation
02:41:51 <tuomov> (and then there are few channels with people who oppose utf-8)
02:41:52 <bourbaki> sounds all to complicated already to me :)
02:42:00 <pesco> Hm. Okay, I'm a vim and emacs user.
02:42:29 <tuomov> and also, there isn't any decent unicode fonts
02:42:35 <pesco> bourbaki: The thing is, actually it shouldn't be. urxvt does it right by just looking at the locale setting and behaving accordingly.
02:42:38 <tuomov> not much point in using unicode when you have to stick to latin1 font
02:43:04 <tuomov> of the misc-fixed family only the basic alias 'fixed' size has many characters
02:43:08 <bourbaki> pesco: can your char set render a lambda as well?
02:43:34 <tuomov> and other fonts are inferior to misc-fixed
02:43:54 <tuomov> misc-fixed and adobe-helvetica are all the fonts that are ever needed :)
02:44:08 <pesco> tuomov: That's not true. I have a pretty nice one on this terminal. It's called screen (in the sgi foundry).
02:44:21 <pesco> bourbaki: Yes.
02:44:26 <bourbaki> cool
02:44:47 <bourbaki> can you use that in emacs instead of \ ?
02:45:33 <pesco> bourbaki: I don't know if it's _possible_, but I can't do it. ;)
02:45:43 <bourbaki> heh ok :)
02:46:02 <pesco> tuomov: http://www.suse.com/us/private/products/suse_linux/prof/packages_professional/sgi-fonts.html (emerge sgi-fonts on Gentoo)
02:46:15 <tuomov> I use debian
02:46:30 <pesco> I don't know if they have a package.
02:46:48 <dons> I'd like to see real lambdas in my .hs syntax highlighting, much like the Isabelle frontend ProofGeneral does in emacs
02:47:05 <pesco> Yes, me too.
02:47:20 <pesco> In fact, I'd like to _write_ real lambdas in my Haskell code.
02:47:42 <pesco> Jumping into GHC to make it accept UTF-8 is on my wishtodo list.
02:47:49 <tuomov> dons: if Yi will be based on a theory of buffers, it should be easy :)
02:48:56 <tuomov> pesco: and that too
02:50:08 <pesco> ftp://ftp.suse.com/pub/suse/i386/9.1/suse/noarch/sgi-fonts-1.0-705.noarch.rpm
02:50:17 <pesco> That's the file the Gentoo ebuild fetches.
02:50:30 <tuomov> and how do you unpack rpms?
02:50:41 <pesco> lemme check
02:50:52 <tuomov> it was some cpio magic
02:51:01 <tuomov> but I haven't needed that for a long time
02:51:07 <tuomov> sigh. why can't it be a normal tarball
02:51:23 <pesco> unpack_rpm I think!
02:51:24 <dons> tuomov: yep!
02:52:16 <tuomov> pesco: but that is probably a script that does something else
02:52:52 <pesco> tuomov: Alright, alright, I'm taring it up and will put it on scannedinavian.
02:54:42 <tuomov> hmm.. google rpm cpio only finds references to some rpm2cpio script
02:54:48 <tuomov> did the rpm format change at some point?
02:55:03 <tuomov> the last I had anything to do with rpms was something like 7 years ago
02:55:06 <pesco> I have no idea.
02:56:21 <pesco> http://www.scannedinavian.org/~pesco/distfiles/sgi-fonts.tar.gz
02:58:20 <earthy> the fileformat did indeed change once or twice
02:58:52 <earthy> but, rpms are cpio files with a number of metafiles and another cpio file in them, IIRC
03:00:21 <tuomov> screen's ok..
03:00:29 <tuomov> but it is also latin1 only
03:01:19 <pesco> Hm, strange, then urxvt is choosing something else. But the characters look so fitting, I assumed they came from screen as well.
03:02:30 <pesco> Which registry is Unicode?
03:02:51 <tuomov> iso10646-1
03:04:08 <tuomov> xlsfonts|grep iso10646 lists a lot of fonts but few of them actually contain anything beyond latin1
03:06:34 <tuomov> it is possible to use multiple fonts as fontsets, but xlib support for unicode fontsets is broken
03:06:48 <tuomov> and nobody bothers to fix it since gtk and qt reinvent the wheel
03:07:23 <tuomov> as usual
03:13:24 <earthy> !sigh
03:13:35 <pesco> tuomov: Don't they use Xft?
03:41:25 <peti> Good morning. 
03:41:27 <peti> Sort of. ;-)
03:42:20 <peti> Does  anyone have have  a working copy of "darcs"?
03:45:35 * earthy does
03:45:41 <earthy> why?
03:47:11 <peti> earthy: Apparently same people have trouble accessing a darcs repository of mine and I have no idea why. Could you please try "darcs get --partial http://cryp.to/hsemail/" and let me know whether it works?
03:48:03 <kosmikus> peti: works for me with rc3
03:48:37 <peti> OK. Thanks!
03:51:12 <bourbaki> i want to build something like a state monad where the state is somekind of network that gets updated due to the functions in between the nodes
03:51:37 <bourbaki> but i also want to include functions that can change that network within the network
03:52:49 <peti> bourbaki: Use "StateT (MVar st) IO a". Then you have a global state which everybody can modify.
03:52:51 <bourbaki> but how can you do something like that?
03:53:02 <bourbaki> ah ok
03:53:13 <bourbaki> but how can you modify it along the functions?
03:53:39 <peti> You mean, you have functions stored in your state, right?
03:53:47 <bourbaki> yes
03:54:16 <bourbaki> and the functions in that state modify the state itself
03:55:04 <peti> bourbaki: Well, just change them. :-) If the state is "data ST = ST { foo = Int -> Int }", then you can update it with "get >>= modifyMVar_ (\st -> st { foo = newfunct })".
03:56:35 <bourbaki> hm
03:56:35 <peti> bourbaki: I have the exact same design in a software of mine. I also have a global state with a bunch of callback functions, which the monad modifies during the life-time of the program. It works _great_. 
03:57:04 <peti> bourbaki: The only problem with having functions in the state is that it is a bit harder to debug then, because functions are opaque. You can't show them.
03:57:19 <bourbaki> my program is the state :)
03:57:21 <tuomov> pesco: not if you don't allow it (I don't)
03:57:38 <tuomov> (anti-aliasing is ugly)
04:00:32 <bourbaki> peti: but you dont use the functions within your state to modify the state do you?
04:01:27 <peti> bourbaki: Yes, those functions also modify the state. 
04:02:24 <peti> bourbaki: Just bind the MVar to the function via currying, and then they'll always use the current state! If the MVar changes the contents, then the function will also have a new state. 
04:02:45 <pesco> tuomov: I find anti-aliased text quite pleasing.
04:03:01 <peti> bourbaki: So you'd have a signature like: stateTrans :: (MVar MyState) -> ...
04:03:19 <peti> bourbaki: And you'd put them into the state as (stateTrans mymvar). 
04:03:36 <bourbaki> hm
04:03:42 <peti> bourbaki: Even though it can be argued that you won't even need the StateT monad anymore, if you have the state bound via currying.
04:04:06 <bourbaki> so you propose a tuple
04:04:26 <peti> bourbaki: A tuple?
04:04:29 <bourbaki> (state, foo) -> (state', bar) ?
04:04:55 <peti> bourbaki: I'm not sure I follow. That is the signature of what exactly? 
04:05:23 <bourbaki> of all the functions i will use
04:06:14 <peti> bourbaki: If the function modifies a state which is encapsulated in an MVar, you don't need to return the new state. Just put it in the MVar and everybody has it.
04:06:47 <bourbaki> what is MVar?
04:06:54 <peti> bourbaki: Your functions would probably have a signature so that you can run them with 'modifyMVar' or 'withMVar'.
04:07:01 <bourbaki> im not familiar with all the standard monads and such
04:07:20 <peti> bourbaki: An MVar is a "global" variable which synchronizes access to it in a thread-safe manner.
04:07:33 <bourbaki> ok and how is that done
04:08:06 <peti> bourbaki: wait a second. There is a very nice article that should bring you up to speed on all that. I'll just have to find the URL ... 
04:08:12 <bourbaki> im interested in the way it is implemented not just writeing such a program
04:08:16 <bourbaki> cool thanks
04:09:33 <peti> bourbaki: Check out the "web server" paper at <http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/>.
04:10:02 <peti> bourbaki: If you want to know how it's implemented, just look at the source code of the module GHC.Conc in GHC's internals.
04:10:33 <bourbaki> i want to get the mathematical idea behind it :)
04:12:02 <peti> bourbaki: I think the paper gives formal semantics of MVars. But it's basically just a "semaphore", or a "mutex", in pthread-speak.
04:13:07 <bourbaki> peti: kk
04:13:19 <peti> Ah, it does: "The tutorial also gives an operational semantics for everything described except the foreign-language interface part."
04:24:21 <bourbaki> i think im going to do something like (network, domain) -> (network', codomain) for all functions and this will be in the same function space as the domain -> codomain functions
04:26:13 <lmbdwar> 'lut 
04:26:33 <peti> bourbaki: And your state is "network"? 
04:26:39 <bourbaki> yes
04:27:02 <peti> bourbaki: Then network' must be the same type as network, right?
04:27:16 <bourbaki> that way i can mix functions that change the network and usual functions from within in the network
04:27:24 <bourbaki> peti: yep
04:27:44 <peti> bourbaki: OK. Yes, that should work, as far as I can tell.
04:28:18 <bourbaki> the only thing that bothers me is that i need to write some kind of interpreter then
04:28:37 <peti> bourbaki: By the way, if you have the entire state in an MVar, you might want to use a ReaderT instead of a StateT.
04:29:18 <bourbaki> peti: ill try to do that with my arrow like implementation
04:29:47 <bourbaki> then i can just use +++ to build the functions from the above type
04:30:17 * peti hasn't really used Arrows yet. 
04:30:31 <peti> Although I keep running into them all the time. 
04:32:07 <peti> Just yesterday I've read the thesis an Fudgets, because I need a generic stream processor API. But frankly, I think the SP arrows are awkward for that. 
04:32:33 <bourbaki> sp?
04:32:54 <peti> bourbaki: Stream Processor 
04:32:59 <bourbaki> ah ok
05:14:26 <bourbaki> moin shapr 
05:15:13 <shapr> y0
05:16:46 * shapr reads Computer Sweden "hot new trends : test driven development, refactoring"
05:17:53 <peti> shapr: Howdy!
05:18:14 <shapr> y0 peti!
05:18:30 <peti> shapr: I'm building the web page for the MTA right now. :-) Two, three more days, then I'll make it public. 
05:18:35 * peti is rather excited about it.
05:19:00 <shapr> I think refactoring was a hot new trend in the late nineties...
05:19:03 <peti> shapr: You volunteered to beta test, right? :-)
05:19:19 <shapr> yup!
05:19:25 <peti> Very cool.
05:19:56 <shapr> hey, source for House has been release.
05:20:13 * shapr wonders what else is needed for a Pure Haskell OS.
05:20:26 <bourbaki> one thing i keep asking myself about haskell is when i have a variable in global scope like foobar :: Float; foobar = 1.0 for example is this then mutable? can you change foobar then?
05:21:04 <peti> bourbaki: No. Mutable stuff has to be in the IO monad.
05:23:23 <peti> shapr: Have you ever tried House?
05:23:34 <shapr> I've booted it on Qemu
05:23:41 <shapr> haven't tried it on real hardware yet.
05:24:09 * peti loves a idea of an OS written in Haskell.
05:24:16 <shapr> me too
05:25:00 <bourbaki> what a haskell system really would need is an editor that supports all math symbols :)
05:25:40 <peti> bourbaki: Couldn't Emacs do that? With the MULE extensions to do Unicode, it should be possible, IMHO.
05:26:06 <bourbaki> no idea its always tinkering around
05:26:17 <peti> shapr: Is there still anything going on with the haskell-libs project on SounceForge? 
05:26:21 <bourbaki> i dont want to deal with the system but with the problems i want to solve :)
05:26:30 <shapr> peti: a little bit
05:26:42 <shapr> I'm unhappy with sourceforge itself though.
05:26:48 <shapr> slow and painful
05:27:10 <peti> shapr: Yes, and it doesn't really support other VC systems than CVS.
05:27:21 <peti> shapr: I like darcs for that because it's easy to submit patches back.
05:27:42 <shapr> me too
05:27:48 <shapr> I use darcs for everything.
05:28:11 * edwinb makes another note to learn to use darcs
05:28:22 * peti uses Monotone for "real" VC, and darcs as an add-on so that people can use it to download/patch the software easily.
05:28:33 <peti> But I think Monotone is ultimately better than darcs.
05:28:38 <kosmikus> edwinb: that takes about 5 minutes
05:28:42 <shapr> edwinb: hey, I can host a darcs repo for epigram sources on scannedinavian :-)
05:28:47 * edwinb checks his watch
05:28:53 <edwinb> Aha, I have five minutes!
05:29:16 <shapr> edwinb: http://www.scannedinavian.org/DarcsWiki/GettingStarted
05:29:50 <edwinb> I'm not sure how easy it will be to get people to use something other than CVS now they're used to it though. Much as I dislike CVS.
05:30:21 <shapr> edwinb: darcs is really easy.
05:30:26 <shapr> Easy to learn, easy to use.
05:30:29 <peti> shapr: I could host a darcs-based library effort on cryp.to. I have been thinking about adding a my.cryp.to subsite, which has a bunch of Haskell modules in the My.* namespace. I'd have a dozen modules to put there, but it would only make sense if other people would submit their code too.
05:30:37 <velco> edwinb: www.gnuarch.org
05:30:48 <shapr> bah arch is too heavy
05:30:56 <edwinb> Yes, I don't doubt that. But making other people believe it is not always so simple.
05:31:02 <shapr> and darcs is written in Haskell :-)
05:31:02 <velco> shapr: arch has more features than darcs
05:31:15 <shapr> darcs has more features than arch
05:31:16 <velco> shapr: and the last comment is a pure nonsense
05:31:39 <shapr> no, this is #haskell so being written in Haskell is perfectly valid.
05:31:48 <tromp> great, a pissing contest:)
05:32:06 * peti thinks that you can't compare Darcs with Arch or with Monotone, because each of the systems has an entirely different architecture. 
05:32:10 <velco> so, just to make clear, written-in-haskell => good ?
05:32:15 <velco> (=> is implication)
05:32:17 <velco> ?
05:32:23 <phubuh> no
05:32:43 <tromp> which one has more features per Kb source:-?
05:32:46 <velco> peti: the architecture does not matter that much, important is what you can DO with them
05:32:46 <peti> velco: Written in Haskell => I can read, modify, and re-use the source code more easily than C/C++.
05:32:50 <phubuh> written-in-haskell is better than written-in-anything-else, but that fact alone doesn't make something good
05:32:54 <velco> peti: ok
05:33:16 <velco> ok, ok, haskell fanboys ... I;m not trying to convert you
05:33:17 <shapr> anyway, darcs is very easy to learn and use, it really does take about five minutes.
05:33:33 <shapr> velco: dude, you're on #haskell, of course we're Haskell fanboys.
05:33:46 <velco> shapr: well, I'm here too:)
05:34:04 <shapr> velco: greetings velco, would you like to learn Haskell? :-)
05:34:11 <peti> velco: The architecture matters very much, IMHO. Darcs tracks individual patches, for example, where as Monotone doesn't care about individual changes and just tracks the state of the repository as a whole. That is good for entirely different things than Darcs is. 
05:34:12 <velco> shapr: nope
05:34:16 <tromp> i just found http://hardgrok.org/blog/?postid=8
05:34:17 <shapr> velco: so why are you here?
05:34:30 <tromp> a blog titled darcs: revision control done right
05:34:38 <velco> shapr: indeed
05:34:47 <shapr> griitings buggmuzz, long time no see.
05:34:56 <buggmuzz> hey, indeed
05:35:20 <tuomov> monotone doesn't have a decent merge iirc
05:35:27 <buggmuzz> hows it going shapr
05:35:40 <peti> tuomov: The same as all the others. xxdiff, emacs, whatever you'd like to use.
05:35:41 <shapr> Code is good, how're you?
05:37:02 <tuomov> edwinb: svn is very straightforward to convert to from cvs... it was designed that in mind
05:37:15 <tuomov> and indeed it is slowly happening
05:37:23 <buggmuzz> um.. pretty much the same as before, nothing exciting.. just came around to see what's going on
05:37:24 <tuomov> but there really is absolutely no learning curve to darcs
05:37:25 <edwinb> People aren't straightforward to convert though ;)
05:37:39 <edwinb> These are people who get scared when I write Makefiles at them...
05:37:54 <shapr> edwinb: you have darcs installed?
05:37:58 <tuomov> they're no coders then. they should not be using version control at all :)
05:38:05 <tromp> there's only one downside to darcs
05:38:24 * buggmuzz wonders if luigi is in here
05:38:33 <shapr> Luigi who?
05:38:39 <shapr> tromp: what's that?
05:38:46 <edwinb> shapr: Not yet. I'm going to use a different five minutes. I've read the intro though so I'll give it a go tonight.
05:38:51 <shapr> ok
05:38:58 <tromp> it has a buzzword in its acronym:-(
05:38:59 <edwinb> I have a small project or two that really ought to be in some kind of VC system.
05:39:07 <buggmuzz> luigi barone
05:39:13 <tuomov> as I see it, full distributedness can be a downside too if you can't keep things organised yourself
05:39:30 <peti> What I like better in Monotone than in Darcs is that there is no boundary between any kind of branch or repository that you have. _All_ your data lives in the same namespace. In Darcs, one repository is completely separate from another one, even though it may share 99% of the files it contains.
05:39:33 <shapr> tromp: david?
05:39:41 <tromp> no, advanced
05:39:45 <shapr> oh
05:40:00 <buggmuzz> he's a big proponent for haskell at our uni
05:40:14 <tromp> i'll just think of it as DAndy Revision Control System :P
05:40:17 <tuomov> it should be quite easy to implement multiple branches within a repo in darcs, but I don't see the point
05:40:28 <shapr> edwinb: I've started keeping everything in darcs, my elisp files, my .zshrc, all my code sources.
05:40:44 <tuomov> just add multiple inventory files or something like that
05:40:52 <edwinb> shapr: Yes, I think it's a good idea to do that...
05:41:19 <peti> tuomov: Yes, you can have multiple branches within one repository. But you still have multiple repositories. In Monotone, you have no repository at all. Whatever you keep in your database can be used, imported, merged, and changed in any branch you'd like to have it.
05:42:20 <shapr> edwinb: I've structured it such that I can easily grab all of my user config with darcs onto a new box
05:43:01 * shapr hugs darcs
05:43:20 <shapr> buggmuzz: if he's here, I don't know it.
05:43:29 <shapr> buggmuzz: lots of good stuff happening in the Haskell world lately.
05:43:53 <tuomov> peti: and so if you had multiple branches in a repo, you could apply patches from other branches
05:44:21 <tuomov> I think you can apply patches from just about anywhere in darcs too, but it doesn't make sense applying stuff from a completely different project
05:44:50 <buggmuzz> yeah i know shapr, in particular buggmuzz's surprise visit to the haskell channel :P
05:44:52 <tuomov> usually
05:44:58 <buggmuzz> but seriously, what sort of things?
05:45:04 <shapr> buggmuzz: hah,
05:45:09 <peti> tuomov: The problem I'm having is this: I have a repository for my project "foo". Now I'd like to import the FastPackedString.hs module from the darcs repository. And I'd like the VC system to update the copy in my repository with the changes David makes automatically. How do I do that with Darcs? How do I pull a single file from one repo into another one?
05:45:28 <shapr> hs-plugins is cool, totally dynamic loading of applications in Haskell.
05:45:51 <tuomov> you can't really in a changeset based system
05:46:04 <tuomov> such that you retain all the logs and stuff
05:46:14 <peti> tuomov: Right. And that is why Monotone is better for that purpose, because with Monotone that's no problem at all.
05:46:16 <tuomov> but otoh monotone doesn't have a decent merge so what's the point?
05:46:24 <tuomov> it's just applying diffs
05:46:29 <tuomov> just like cvs, svn, etc.
05:46:30 <peti> tuomov: Monotone merges just fine.
05:46:32 <shapr> peti: you could ask david to pull FastPackedString out into its own repo.
05:46:33 <tuomov> and unlike darcs, arch
05:47:06 <shapr> peti: couldn't you also turn it into its own repo by pulling a darcs repo, deleting everything else, and then pulling new changes from the original darcs repo?
05:47:19 <tuomov> and in arch star-merge is a special operation..
05:47:20 <peti> shapr: And how do I get it from there into my other repo?
05:47:28 <shapr> use it as a library?
05:47:42 <peti> shapr: Yes, but how do I get it into my repository?
05:48:02 <shapr> does it need to be in your repo?
05:48:05 <peti> shapr: I'd like to track the sources I'm using. All of them.
05:48:24 <peti> shapr: How else would I be able to reproduce a specific version of my code?
05:48:36 <shapr> hm
05:49:21 <shapr> could you do the same thing where you pull darcs into your repo, and then delete all the other files?
05:49:37 * shapr wonders if that would work
05:49:44 <peti> shapr: I don't know it either. :-)
05:49:48 <tuomov> if there was a --put-in-subdir option to darcs pull..
05:49:56 <tuomov> so you could pull other projects as subdirectories
05:50:08 <tuomov> initially
05:50:22 <peti> tuomov: Yes, you'd need somehing like CVSROOT/modules, where you can specify that your project includes other projects. 
05:50:22 <shapr> Guten Abend pesco_
05:50:23 <tuomov> so it doesn't conflict with your files and such
05:50:44 <tuomov> after that, simply pulling from the other project's repo should update the files
05:51:05 <peti> tuomov: Right. And that is what Monotone does.
05:51:20 <tuomov> now, if you initially pull files from another repo and move them elsewhere, they should get properly updated
05:51:43 <tuomov> but doing this in the middle of a project could conflict with our files, thus the --put-in-subdir option
05:52:38 <shapr> buggmuzz: oh, darcs is one really good thing
05:53:00 <tuomov> but yeah, there's no version control system that fits every task
05:53:17 <dustin`> Is there a pastebuffer for this channel?
05:53:17 <peti> There are several other cases Darcs architecture isn't particularly good for, it's not just tracking other people's repositories. And there are, of course, lots of things darcs can do better than Monotone can. I ultimately ended up using both. 
05:53:24 <shapr> dustin`: yes
05:53:38 <shapr> @wiki HaskellIrcPastePage
05:53:38 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:53:46 <dustin`> Thanks!
05:53:59 <tuomov> e.g. the fact that copying a file is the basic operation in svn instead of moving it might cause problems to implementing a decent merge operation
05:54:15 <tuomov> all version control systems with a decent merge don't allow copying stuff
05:54:21 <tuomov> and tracking it
05:54:24 <tuomov> afaik
05:54:53 <tuomov> decent==merge that actually keep tracks of patches and does not just apply a diff
05:55:09 <shapr> dustin`: are you at rit.edu?
05:55:46 <dustin`> shapr: Indeed I am.
05:56:13 <peti> tuomov: I am sorry, but simply repeating that Monotone doesn't have a "decent merge" won't make it true. :-) It's just plain wrong. The merging operation of Monotone is probably even more powerful than Darcs', because it uses SHA1 to identify files. So any change to any file can be propagated to _any_ other branch that contains that file. That's impossible with any other VC I know.
05:56:50 <tuomov> but does it really keep track of patches?
05:57:03 <peti> Duh! Of course it does. 
05:57:06 * peti shakes his head.
05:57:06 <tuomov> e.g. in svn svn merge and svn diff|patch; svn commit are no different
05:57:17 <tuomov> I read differently from the monotone web page
05:57:21 <peti> Wouldn't be much of a version control system if it didn't, would it? :-)
05:58:24 <peti> tuomov: Can you quote the sentence that said that?
05:58:32 <tuomov> I'm trying to load the page..
05:58:50 <dustin`> shapr: Do you know me in some manner? =)
05:59:32 <peti> tuomov: At <http://www.venge.net/monotone/faq.html> you'll find a (very short) description of Monotone's merge operation when compared to Darcs.
06:00:10 <tuomov> "Why not use more "sophisticated" merge algorithms" in the FAQ... so it has a primitive merge, they admit it
06:00:24 <shapr> dustin`: I think I've seen your name on a mailing list somewhere, was just curious...
06:00:35 <peti> tuomov: You won't be strayed by reason, will you? :-)
06:00:35 <shapr> dustin`: I do have one question though, what the heck is aquathenics?
06:01:08 <peti> tuomov: What do you think the quotes around "sophisticated" signify? :-)
06:02:06 <tuomov> they're tired of people complaining of their primitive merge?
06:02:22 <dustin`> shapr: Aquathenics is a light way of excericizing while in water, mainly for old people.  I tried it out because my impression was that there was some kind of meditative aspect to it, but as it turned out, there was not, and thus I quit the class.
06:02:39 <peti> Anyway ... each to his own. I'll do some massively Monotone-tracked Haskell coding now!
06:02:45 <shapr> dustin`: oh, ok. It does sound meditative, I agree. Did it suck?
06:04:03 <dustin`> shapr: It was quite sour, although the ladies in the class were quite impressed with my nipple piercings.
06:04:13 <shapr> haha
06:07:00 <shapr> tuomov: what's that confucianism url again?
06:07:14 <tuomov> search in wikipedia
06:07:14 <buggmuzz> shapr: ah yes i think darcs was the most talked about thing on this channel last time i was here
06:07:38 <shapr> oh I found it, http://www.fact-index.com/c/co/confucius.html
06:07:53 <shapr> buggmuzz: today's mugg buzz is yi
06:08:00 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi
06:14:01 <shapr> tuomov: hey, I think arrows and buffer theory might be related
06:14:06 <shapr> but I'm not really sure.
06:14:35 <shapr> for one thing, I think buffer arrows could be reordered according to efficiency
06:14:35 <tuomov> you might be able to view a patch as an arrow
06:14:40 <tuomov> or transformation or whatever
06:15:19 <shapr> From what I've read, an arrow is a transformation, 'morphism' in category theory. (don't sue me if I'm confused :-)
06:15:36 <tuomov> yes
06:15:41 <shapr> I think the difference between a patch and a transformation is that all patches must be reversible
06:16:14 <shapr> and patches have explicity commutation properties, where transformations don't necessarily have either of those.
06:16:25 <bourbaki> type Network a = ([[Int]], [((Network a), a) -> ((Network a), a)], [String], [[a]], [String])
06:16:33 <tuomov> high-level transformations are not necessarily invertible, yes
06:17:07 <bourbaki> can that Network a within the type definition change itself?
06:17:57 <shapr> bourbaki: at first glance it looks like it can, but I'm not totally sure.
06:18:32 <shapr> bourbaki: I read most of the Yampa Arcade paper last night, and I'm totally sure you can build a self-modifying neural network if you read that paper and follow their directions.
06:18:34 <bourbaki> shapr: i want to build a network that way and all functions that are just normal functions have an id function for the network part
06:18:47 <shapr> hoi swiert, how's thesis? :-)
06:19:04 <bourbaki> shapr: oh what was the url?
06:19:16 <swiert> hi shapr, code has been good the last couple of days.
06:19:37 <shapr> bourbaki: http://www.haskell.org/yale/papers/haskell-workshop03/index.html
06:19:37 <swiert> I have the feeling I'm finally getting somewhere.
06:19:41 <shapr> yay!
06:19:56 * shapr likes getting somewhere too
06:27:43 <shapr> "free software friendly graphics card" http://kerneltrap.org/node/view/4033 As they said in Wayne's World  "Oh yes! She will be mine."
06:28:04 <bourbaki> :)))
06:28:25 <tuomov> hmph. peti seems to have quit..
06:28:43 <tuomov> I went and actually tried monotone and after merging, I seem to have no history of the patches in each branch, as I suspected
06:28:43 <bourbaki> shapr: but yampa doesnt save the program structurally do they?
06:29:10 <tuomov> but this seems almost as painful to use as arch.. everything requires a version
06:29:47 <tuomov> all that remains is
06:29:51 <tuomov> Value : merge of a644a633dec842512d46bf3a014b0f5f5557c21b
06:29:52 <tuomov>       :      and ed822efd1c241220e121075fbabe507cf52b877c
06:32:17 <shapr> tuomov: that sounds heavy
06:32:42 <shapr> xerox-: y0
06:32:47 <xerox-> hi shapr
06:32:57 <tuomov> hmm.. after re-checkout the changes appear in log but still not in list certs
06:32:58 <shapr> how's code?
06:34:12 <xerox> mmh school leaches life
06:36:47 <shapr> ?
06:40:44 <shapr> Man, I hope this "totally open graphics card with passeble 3D" becomes reality. I would switch instantly.
06:41:03 <shapr> nvidia drivers just don't handle the weird setups I use.
06:41:08 <shapr> and I can't fix 'em :-(
06:49:34 <shapr> xerox-: hey, you're bouncing... network problems?
06:49:57 <xerox-> yup, damn router
06:58:27 <tuomov> hmph. I should probably read more on arrows..
07:08:15 <shapr> tuomov: read the Yampa Arcade paper, tell me if my Buffer Arrow idea is stupid or not :-)
07:15:18 <bourbaki> shapr: the switches are the thing you wanted to point me to right?
07:15:26 <shapr> yes!
07:15:41 <shapr> section 5.5
07:16:00 <shapr> a switch effectively allows an arrow to change its behaviour completely.
07:16:33 <bourbaki> yes im thinking about that and how to apply that to a neural net
07:16:52 <shapr> in the Yampa Arcade, the gun, and each alien and missile are all arrows that get added to the collection when they are created, and removed when they die
07:17:59 <shapr> you want your net to be able to add and remove nodes?
07:18:16 <bourbaki> yes
07:18:32 <bourbaki> and change arrows
07:18:43 <bourbaki> that includes adding and deleting them
07:18:47 <shapr> let's say that each node is an arrow, in the collection
07:19:28 <shapr> what's the state of a node you're using right now?
07:20:28 <bourbaki> atm all nodes are Floats (and arbitrary products) cause i just deal with neural nets but in the end it could be any type
07:22:25 <shapr> well, look at 4.1 of the paper, define what state each node has, and how it updates the state. See if you can fit into the code shown in simpleGun
07:22:55 <shapr> I think it won't be too difficult.. (I hope :-)
07:23:03 <bourbaki> my other problem is that i dont understand how i should take the structure into account
07:23:22 <shapr> which structure?
07:23:35 <bourbaki> that is if i delete or add eges it would maybe require to change the way i gather the functions
07:23:37 <shapr> hej sond
07:23:44 <sond> tja
07:24:03 <shapr> bourbaki: I've never dealt with NNs that change structure, so I can't help you there.
07:24:34 <bourbaki> shapr: (erup ((((pure (weight 11)) +++ (pure (weight 12)) +++ (pure (weight 13))) >>> (pure add) >>> (pure filterfn)) &&& ((pure (weight 21)) +++ (pure (weight 22)) +++ (pure (weight 23)) >>> (pure add) >>> (pure filterfn)) &&& ((pure (weight 31)) +++ (pure (weight 32)) +++ (pure (weight 33)) >>> (pure add) >>> (pure filterfn))))
07:25:03 <bourbaki> this is the way i build a network but if i change something then the way i write this down might change the wireing so to say
07:25:42 <shapr> the switches have two pieces, a routing function and a collection changing function, so you get to easily change the way you do either.
07:26:12 <shapr> well, three pieces... the initial collection too..
07:28:12 <shapr> bourbaki: so, what's the state of a single node? just a float? how does a node get described in terms of input to a control system producing a new node?
07:28:41 <shapr> bourbaki: btw, I'm not an expert, so hopefully I'm not misleading you here :-)
07:28:45 <bourbaki> shapr: there is no control system yet
07:29:05 <shapr> do you have any details about neuron activation?
07:29:08 <bourbaki> no its fine i think we two are on the right way and thanks for helping and listening
07:30:03 <bourbaki> as you can see above i collect all functions on the output layer and +++ all the functions that come in
07:30:28 <bourbaki> then i have something like a product of Floats which i sum up with thehunters cool add function
07:30:36 <bourbaki> which yields a single float
07:31:07 <bourbaki> and this single float is filtered with a function which is the activation
07:33:42 * shapr looks for a simple NN demo online
07:33:56 <bourbaki> shapr: general or implemented in haskell?
07:34:15 <shapr> well, either...
07:34:31 <bourbaki> sec ill give you a good intro site 
07:34:41 <shapr> I haven't any NN code in a few years, so I'm trying to find some code demos that fit with what I remember.
07:35:06 <dons> profiling rules. reduced memory consumption of yi by 42%, and inc speed by ~30
07:35:13 <dons> just by fixing 3 inner loops
07:35:13 <bourbaki> http://neuralnetworks.ai-depot.com/Tutorials.html
07:35:41 <shapr> dons: yay!
07:36:37 <dons> the delete command does 0 allocs now
07:36:59 <Oejet_> dons: I agree, profiling rules. Actually with GHC was the first til ever that I used profiling, because it is so easy.
07:37:17 <Oejet_> s/til/time/
07:37:28 <dons> yeah. they do make it easy -- and that really helps
07:43:32 <dons> ok. 16 hours of yi hacking is enough.
07:43:35 * dons falls asleep
07:43:48 <shapr> g'night dons!
07:44:06 * shapr cheerfully pulls new Yi changes!
07:44:07 <shapr> w00!
07:51:17 <Lemmih> Is profiling still easy to use when you're using several libraries?
07:54:38 <Oejet_> Lemmih, do you mean like: module Main where import Int, import Bits, import Control.Monad, import List, import IO?
07:57:58 <Lemmih> No. I'm thinking about HaskellDB and HSQL in particular.
07:59:09 <Oejet_> Lemmih: I don't know.
08:05:52 <Jan_w> hi all
08:05:57 <tromp> hi jan
08:06:29 <Jan_w> why can i not do this:
08:06:29 <Jan_w> type Disc = [Int] 
08:06:29 <Jan_w> instance Eq Disc where
08:06:29 <Jan_w>  (==) a b  = (a `eq` b) 
08:06:45 <Jan_w> i want my own == for disc
08:06:56 <desrt> Variable not in scope: `eq'
08:07:13 <desrt> :)
08:07:23 <Jan_w> i can do newtype Disc = Disc [Int], but then i have to put "Disc a" everywhere
08:07:40 <desrt> that sounds about right
08:07:45 <Jan_w> desrt: eq is my own compare fucntion
08:07:56 <desrt> Jan_w; equality is already defined on lists
08:08:05 <Jan_w> desrt: but i don't want to write Disc a every where
08:08:12 <desrt> so how does ghci know if it's a list or a Disc?
08:08:19 <Jan_w> desrt: yes, but not the way i want it
08:08:51 <Jan_w> because i tell it, when i say Disc i mean a list with a different compare function
08:08:55 <Jan_w> :0
08:09:06 <desrt> when you say it in the type signature?
08:09:20 <desrt> or..
08:09:41 <Jan_w> well i quess i'm not saying to, but i would like to :)
08:09:53 <Jan_w> well i quess i'm not saying it right, but i would like to :)
08:10:26 <desrt> i don't think you can cause == to be overloaded inside a given function by changing the type declaration
08:10:38 <desrt> to me, that wouldn't seem very good
08:10:47 <Jan_w> hm
08:11:38 <Jan_w> then i'm stuck with either ugle syntax or not using the == operator :)
08:11:54 <desrt> correct :)
08:11:55 <phubuh> the problem is that Disc isn't a new type, it's a mere alias for [Int]
08:12:21 <Jan_w> well, then i'll try to work around the == operator :)
08:12:22 <Jan_w> unique :: Eq a => [a] -> [a]
08:12:22 <Jan_w> unique [] = []
08:12:22 <Jan_w> unique (a:as) 
08:12:22 <Jan_w>  | elem a as    = unique as
08:12:22 <Jan_w>  | otherwise    = [a] ++ (unique as)
08:12:51 <Jan_w> how could i make this work on Discs without changing ==
08:13:04 <Jan_w> i guess i cant
08:13:12 <phubuh> not in an elegant way
08:13:13 <Jan_w> because elem requires Eq
08:13:32 <phubuh> the proper solution is to create a new Disc type :)
08:13:45 <Jan_w> phubuh: grr
08:14:05 <Jan_w> phubuh: i'll have to put up with the darn ugly syntax then
08:14:09 <tromp> 'why are you so eager to use == ?
08:14:20 <Jan_w> tromp: i'm not
08:14:29 <Jan_w> tromp: but elem is
08:15:04 <Jan_w> i guess i could write a new elem for discs
08:15:20 <tromp> so use a generalized elem?!
08:15:33 <Jan_w> is there one ?
08:16:01 <tromp> find
08:16:19 <tromp> elem is prolly defined like find . (==) anyway
08:16:35 <tromp> oops, wait
08:16:48 <tromp> different return value:(
08:16:55 <tromp> hmm
08:17:30 <tromp> ok, use any . (myeql)
08:17:48 <tromp> elem is defined as any . (==)
08:17:49 <Jan_w> is there a reference where i can find this ?
08:18:02 <Jan_w> i only have my book, and it's now complete
08:18:12 <Jan_w> w=t
08:18:13 <tromp> APIs are at http://www.haskell.org/ghc/docs/latest/html/libraries/
08:18:27 <tromp> the base source is in Prelude
08:18:59 <tromp> which on my linux system is in /usr/share/hugs/lib/Prelude.hs
08:19:19 <tromp> i'm not sure whether source for all of libraries is:(
08:19:25 <tromp> whether->where
08:20:01 <Jan_w> thanks!
08:25:26 <tromp> in a sense, any is elemBy
08:25:45 <tromp> see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html#22
08:25:51 <tromp> about Generalized functions
08:27:52 <Jan_w> unique :: (Eq a, Num a) => [a] -> [a]
08:27:52 <Jan_w> unique [] = []
08:27:52 <Jan_w> unique (a:as) 
08:27:52 <Jan_w>  | (any . eq) a as    = unique as
08:27:52 <Jan_w>  | otherwise    = [a] ++ (unique as)
08:28:01 <Jan_w> inferred type is not general enough ?
08:28:34 <Jan_w> should a be an Int ?
08:29:10 <Jan_w> :r
08:29:21 <Jan_w> whoops
08:29:22 <Jan_w>  :)
08:29:59 <tromp> are u defining nubBy?
08:31:13 <Jan_w> tromp: eeeh
08:31:19 <Jan_w> tromp: i think so :()
08:31:25 <tromp> :-P
08:32:00 <Jan_w> going offline thanks tromp :)
08:48:37 <tuomov> buffer transformations could otherwise be quite neatly modelled as arrows, but pure/arr can not define a commutable arrow, and so is quite meaningless
08:48:43 <tuomov> shapr: ^
08:50:00 <tuomov> or a two-directional arrow if you prefer an event-passing view
08:53:47 <tuomov> and &&& could be a problem too
08:56:08 <tuomov> it could be used to model multiple connections to a buffer, but supporting it at every step could complicate the code a lot
09:07:01 <Si\> how do I build haddock library docs from GHC CVS?
09:17:20 <Igloo> Si\: make doc and/or make install-doc I think. If you can't work it out you could peer at debian/rules in the source deb
09:19:05 <Si\> /bin/sh: line 1: t: command not found
09:19:24 <Si\> The question is, what should that t in reality be
09:19:39 <Si\> t "Haskell Hierarchical Libraries (base package)" --no-implicit-prelude    -h -o html Control/Arrow.raw-hs Control/Concurrent.raw-hs ...
09:19:48 <Si\> haddock surely
09:27:59 <CosmicRay> @index assertError
09:28:00 <lambdabot> GHC.Base,GHC.Err
09:56:01 <shapr> EVIL STRIKES!
09:56:01 <shapr> whoops, wrong window...
09:56:01 * shapr looks around suspiciously
09:56:02 <shapr> phubuh: aha! it's YOU!
09:56:06 <shapr> tuomov: what do you mean it can't define a commutable arrow?
09:56:10 <shapr> assuming a commutable arrow really can't be defined, maybe arrow transformers would work instead?
10:00:16 <tuomov> arr: (b -> c) -> a b c
10:00:44 <shapr> now that, was some serious lag.
10:01:04 <tuomov> now, if we have something like (arr f) >>> g, how do we form g' >>> f'?
10:01:49 <tuomov> or if passing a message p to (arr f), how do we pass it through (arr f) when the domain and codomain are not the same?
10:02:34 <shapr> does darcs use a typeclass or what?
10:02:36 * shapr digs into darcs sources
10:05:18 <tuomov> I think it uses a fixed data
10:06:09 <shapr> is every type of patch explicity invertible?
10:06:25 <tuomov> yes I think so
10:06:34 <phubuh> shapr: :O :O
10:06:37 <shapr> yes, line 618 of Patch.lhs
10:07:22 <shapr> this looks too manual
10:09:06 <tuomov> We'd need a more restricted arrow class
10:09:08 * shapr thinks Invertible a => instance Patch a where
10:09:17 <tuomov> where arr' would only work on invertible functions
10:09:25 <shapr> huh?
10:09:37 <tuomov> arr' :: (b -> c) -> (c -> b) a' b c
10:10:11 <tuomov> and then still require that all types occuring as inputs or outputs to Arrow':s were Diffable
10:10:12 * shapr doesn't really get that... but will think about it.
10:10:21 <tuomov> gets a bit complicated
10:10:51 <tuomov> uhm. well. all types occuring in arr'
10:10:58 <shapr> for me, I think the first question is, can a darcs Patch be made into an arrow?
10:11:07 <musasabi> Constraints + arrows seem to be a very hard pair.
10:11:11 <tuomov> arr' :: (Diffable b, Diffable c) => (b -> c) -> (c -> b) a' b c
10:11:33 <tuomov> patches can be thought of as arrows
10:11:43 <tuomov> the problem is defining arr and perhaps &&& too
10:12:06 <tuomov> at the very least supporting &&& everywhere complicates the code a lot
10:12:43 <tuomov> of course we can define arr in such a way that nothing can commute with it/events pass through it
10:12:51 <tuomov> but that isn't very useful
10:13:12 <musasabi> arrows needing to satisfy some constraints could maybe be implemented with fundeps
10:13:13 <shapr> musasabi: have you read the Yampa Arcade paper?
10:13:45 * shapr is still wondering about a good BufferArrow type
10:14:04 <musasabi> shapr: only Functional Reactive Programming, Continued
10:14:14 <musasabi> from the yampa papers.
10:14:21 <shapr> hiya velco 
10:14:33 <tuomov> if you want to model things with arrows, you need to scrap the theory of buffers
10:14:46 <shapr> Yampa Arcade is the step-by-step how to make your own Yampa application paper.
10:14:54 <tuomov> and only pass stuff from the bottom to up
10:15:18 <tuomov> arrows aren't suited for birectional stuff
10:15:20 <shapr> tuomov: I'm not yet convinced of that
10:15:47 <tuomov> an (arr f) can pass stuff only in one direction
10:15:54 <tuomov> in a meaningful way
10:16:31 <tuomov> now, you could have different paths from file to view and view to file
10:16:53 <shapr> which would make sense
10:17:00 <musasabi> class Arrow' a i o aic aoc | a -> (aic,aoc) where arr :: (Sat aic i, Sat aoc o) => (i -> o) -> a i o
10:17:00 <tuomov> but I'm not sure if it would be very clean.
10:17:39 <shapr> what's Sat?
10:18:17 <tuomov> a way to model that i satisfies condition aic etc.
10:18:46 <tuomov> instance Sat (Aic i) where etc.
10:19:00 <musasabi> shapr: a class containing the necessary constraints.
10:20:34 <shapr> if you apply a patch, it could return the new buffer and the patch inverse
10:20:59 <shapr> you're not really working on the file, you're working on the model
10:21:10 <shapr> so as long as the model can be stuffed back into the file whenever
10:21:17 <tuomov> no. you're working on the view. sort of.
10:21:19 * shapr isn't sure if this is all correct
10:22:04 <tuomov> The final transformation in the chain of transformations is one that transforms abstract structures into a form that the editor core can understand
10:22:11 <tuomov> a form that is viewable by it
10:22:13 <shapr> right
10:22:33 * shapr thinks about that
10:22:36 <tuomov> essentially it transforms stuff into colour-coded buffer
10:22:50 <tuomov> but at the bottom we also have a buffer; the contents of the file
10:23:09 <shapr> yes, the buffer is the real content, the view is what is displayed
10:23:17 <shapr> the model fits in there somewhere =)
10:23:30 <tuomov> the model is somewhere there between
10:23:53 <shapr> the model must be the path back to the buffer?
10:24:19 <shapr> I've done MVC stuff before, but mixing it in with arrows is a bit brain twisting.
10:24:28 <phubuh> isn't the model the color-annotated parse tree along with buffer metadata such as name and file path?
10:24:44 <tuomov> colours don't yet belong in the parse tree
10:24:48 <tuomov> colours are strictly view-related stuff
10:25:13 <tuomov> the model is the most abstract step in the chain of transformations where no information has yet been discarded
10:25:16 <shapr> you could do syntax highlighting by annotating the parse tree, but it shouldn't affect the actual content
10:25:21 <shapr> http://c2.com/cgi/wiki?ModelViewController
10:25:34 <phubuh> er, yes, of course.  the parse tree's being parsed already has all the information needed to colorize :)
10:25:36 <tuomov> (now that is a vague definition)
10:26:33 <tuomov> in the chain of transformations for a programming language source code file no information is really discarded unless we fold stuff
10:26:53 <tuomov> but the most abstract step is the parse tree, after that we start highlighting it etc.
10:26:59 <tuomov> bringing the stuff back into a more concrete form
10:27:08 <tuomov> but consider e.g. a html2wiki transformation
10:27:09 <shapr> ok, the model is the parse tree, the view is the pretty picture, and the controller lets you change the model
10:27:17 <tuomov> there the html parse is the model
10:27:24 <tuomov> and the wiki transformation actually discards some information
10:28:18 <tuomov> well, depending a the type of transformation
10:28:32 <tuomov> s/a/on/
10:28:46 <tuomov> the controller lets you change the model through the view
10:28:56 <tuomov> sort of.
10:29:21 <tuomov> I think we should separate 'full view' and 'user view' here
10:29:45 <tuomov> the final transformation gives the full view, but the editor still only displays part of that to the user
10:30:10 <tuomov> (although I'm not sure what 'view' actually stands for in mvc)
10:30:35 <shapr> #  A model, therefore is an object representing data or even activity, e.g. a database table or even some plant-floor production-machine process.
10:30:35 <shapr> # A view is some form of visualization of the state of the model.
10:30:35 <shapr> # A controller offers facilities to change the state of the model.
10:30:38 <shapr> from the wiki
10:30:41 <tuomov> hmm.. and the obove mvc link isn't working
10:31:36 <tuomov> I think view there would be the 'user view'
10:32:43 <tuomov> strange. now the wiki loaded. before it ws giving 'Forbidden'
10:42:59 <kristnjov> what does a code snippet look like which uses a lambda expression with two "lambda variables"?
10:43:53 <shapr> kristnjov: \x y -> x + y ?
10:44:23 <kristnjov> but what if i wanted to use it in map for example.. map (\x y -> x + y) (two lists)
10:45:10 <kristnjov> where x is from one list and y is from the other list?
10:45:20 <Igloo> @type zipWith
10:45:21 <lambdabot> zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
10:45:58 <kristnjov> would that be the same as map, but with two lists?
10:46:02 <kristnjov> @type map
10:46:04 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
10:46:06 <shapr> kristnjov: your life will be much easier if you read through the Prelude and Data.List and try to use each of the functions to see what they do, and when you would use them.
10:46:20 <kristnjov> shapr, but i do know what zipWith does, just didn't think about it
10:46:35 <shapr> ah, ok
10:46:45 <kristnjov> 7 weeks ago was the first time i wrote a haskell code, come on :P
10:47:00 <shapr> bah, get moving ;-)
10:47:02 * shapr is joking of course
10:47:03 <kristnjov> hehe
10:51:11 <kristnjov> i didn't get the zipWith thing to work.. :/
10:51:40 <kristnjov> i'll try using nested map functions (if that is possible)
10:51:45 <shapr> what result do you want?
10:52:45 <kristnjov> it's hard to explain, this is a lab for school
10:52:52 <kristnjov> i'm simulating digital circuits
10:52:57 <kristnjov> and we're not allowed to use the Arrows module
10:54:15 <shapr> Lava?
10:54:26 <kristnjov> lava? :S
10:54:31 <shapr> guess not...
10:54:35 <kristnjov> hehe
10:56:27 <shapr> hiya Kelt
10:56:36 <shapr> kristnjov: if you can't explain it, we can't help :-(
10:56:40 <kristnjov> yeah i know
10:57:58 <shapr> arrows really do kick ass.
10:58:31 <shapr> they're marvelously powerful critters
10:58:44 <kristnjov> indeed
11:01:46 <shapr> too bad they're not used more in commercial programming.
11:02:01 <kristnjov> i wouldn't know
11:02:05 <shapr> ya know, the last time I tried to introduce monadic parsers on #java I nearly got lynched.
11:02:24 <tuomov> objects! objects!
11:02:40 <phubuh> sorry dude, parsers have been made deprecated by XML XML XML
11:03:08 <shapr> so after I explained monads and then how they could be made into parers, only one person really got it, and he was a math major anyway.
11:03:09 <kristnjov> parsing is a harsh
11:03:48 <shapr> I tried to show the similarities between OOP and monadic programming, but it didn't really go over well.
11:04:14 <tuomov> I think you need a certain degree of mathematical sophistication to really get fp
11:04:44 <shapr> I dunno... I've never had any real math classes. But fp is all about finding the most basic traversals and making them easy to use.
11:05:16 <tuomov> You can be mathematically sophisticated without classes
11:05:38 <tuomov> I remember in secondary school people who weren't that good at math having problems even with the concept of a function
11:05:47 <tuomov> in an imperative language
11:05:48 <shapr> and monads are from one view, just right-hand recursion, thereby forcing sequencing
11:06:06 <tuomov> and people having problems with understand what a function is in mathematics
11:09:13 <musasabi> well it is not something very easy on an abstract level.
11:09:30 <dustin`> And in most languages you *still* can't apply an array as a function!
11:10:15 <shapr> dustin`: can you do that in Haskell?
11:10:42 <tuomov> f = (!) a
11:10:43 <shapr> I remember seeing a discussion about it lambda-the-ultimate.org
11:10:51 <dustin`> shapr, I just tried ([1 ..] 1) in HUGS and it doesn't work
11:10:53 <tuomov> or which !^n was array indexing
11:10:54 <shapr> but I don't remember the result
11:11:10 <dustin`> shapr, after doing set theory it seems like a natural thing to me.
11:11:22 <shapr> dustin`: ok, what do you mean by 'apply an array as a function' ?
11:11:29 <shapr> what should it do?
11:11:40 <shapr> oh, I see
11:11:41 <shapr> I think
11:11:45 <dustin`> shapr: An array is a mapping of indices to values, and therefore a function over the natural numbers
11:11:51 <shapr> right, I get it.
11:12:11 <dustin`> shapr: It satisfies criterion since each index has at most one value
11:12:13 <shapr> why not ([1..] !! 1)  ?
11:12:34 <dustin`> shapr: Because that doesn't look like a simple function application to me =)
11:12:38 <shapr> admittedly, that's just the list index operator, not a full array.
11:12:55 <Lor> How about (([1..] !!) 1) then?
11:12:59 <musasabi> I think most of the problems are related to first class functions being more important in CS than in elementary math.
11:13:04 <pesco_> Lor: I was just about to say.
11:13:13 * Lor uses that idiom for memoizing functions at times.
11:13:33 <dustin`> Lor: I recently used that in my algorithms project for memoization.  Its nice...
11:13:33 <shapr> Guten Tag pesco =)
11:13:45 <Lor> memoize f range = ((map f range) !!)
11:13:46 <pesco> Guten Tag shapr :)
11:14:02 <dustin`> Lor: But my position with respect to applying arrays as functions is more of a syntactical nitpick that is a bit superfluous
11:14:03 <shapr> Lor: that is really cute.
11:14:03 <Lor> Well, actually with arrays.
11:14:27 * shapr saves that into ShaeTools.hs
11:14:42 <dustin`> I have a nice one... one moment...
11:14:58 * shapr makes sure to use Lor's middle name in the attribution ;-)
11:15:00 * shapr ducks!
11:15:04 <Lor> Eeekk!
11:15:35 <shapr> ok ok, I should learn from my mistakes =)
11:15:38 * shapr removes the middle name
11:15:39 <pesco> What's everyone's problem with their middle names?
11:15:52 <Lor> Middle initial is okay. :)
11:16:13 <Lor> The reason I used my middle name in the title page of the thesis is that there is another Lauri Alanko at the university.
11:16:19 <Lor> A sleep researcher.
11:16:28 <Lor> And also the son of a professor at the cs department. :)
11:16:47 <Lor> He's called Timo Alanko, and I also have an uncle named Timo Alanko, but he's a statistician.
11:16:50 <shapr> pesco: at least in my culture, if someone uses your first and second name, it's either your mother about to kick your ass verbally, or the cops about to kick your ass literally.
11:18:59 <pesco> shapr: I see, that sucks. I think of my middle name as part of my first.
11:19:09 <shapr> greetz gintas 
11:19:23 <shapr> pesco: I wonder if it makes a difference if your first name is a single syllable.
11:19:35 <pesco> shapr: Quite possibly.
11:20:12 <shapr> My first two used to be 'Robert Benjamin'.
11:20:35 <Lor> memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
11:20:49 <Lor> Didn't try it out, but that ought to be reasonably sensible.
11:20:55 <dustin`> Memoized least-common-substructure: http://www.cs.rit.edu/~dem5302/lcs.hs ... Any comments?
11:21:04 <shapr> Lor: oh even cuter
11:21:23 <shapr> gintas: how're you doing with all that literature?
11:21:28 <dustin`> This is perhaps my second Haskell program, and thus I would appreciate advice...
11:21:37 <pesco> I got a rubber ducky today!
11:21:57 <shapr> cool! is it yellow?
11:22:01 <gintas> shapr: ack, don't have time to start reading it ;(
11:22:19 <pesco> shapr: Yes!
11:22:25 <gintas> and I'm kind of planning to finish SICP before I start any of those...
11:22:30 <shapr> gintas: good idea
11:23:00 <shapr> pesco: I've seen some that include one of those multi-color thermometers, did you get a high-tech model like that?
11:23:04 <gintas> but their time will come soon enough ;0
11:23:22 <pesco> shapr: I'd still like a cardboard wookie to get a second opinion occasionally.
11:23:24 <shapr> gintas: good to hear, feel free to drop by #haskell and ask questions about any of it.
11:23:37 * shapr laughs hysterically
11:23:58 <shapr> pesco: truly that is a classic XP joke
11:24:04 * shapr adds that to his QuotesPage
11:24:05 <pesco> shapr: ;)
11:24:10 <pesco> Wooh!
11:24:12 <shapr> dustin`: what's it sposed to do?
11:24:13 <Lor> dustin`, your code is too wide
11:24:45 <Lor> dustin`, have a look at List.tails
11:24:59 <dustin`> Lor: Sorry!  it's difficult to format plaintext, since its presentation depends on tab width
11:24:59 * shapr asks wikipedia
11:25:08 <shapr> don't use tab chars =)
11:25:16 <shapr> spaces only
11:25:30 <pesco> shapr: And no, ducky is only equipped with the classic ducky speak module.
11:25:40 <Lor> A tab is eight columns.
11:25:51 <shapr> one level of indentantion is four columns.
11:25:54 <shapr> (imho)
11:26:02 <dustin`> shapr: Given two strings, find the longest common subsequence of the two.
11:26:09 <shapr> or two column if you're typing on a 'palm connected organizer'
11:26:22 <dustin`> Lor: I will, thanks
11:26:48 <shapr> pesco: did you read that on the wiki?
11:27:54 <Lor> dustin`, also check out List.lookup
11:28:19 <pesco> shapr: Read what?
11:28:31 <shapr> the cardboard wookie and rubber ducking stuff?
11:28:50 <dustin`> Lor, where do I find references to these?
11:29:21 <pesco> I'd known about cardboard wookies' fabulous qualities for long, but only discovered rubber ducky use the other day. Maybe on the wiki, I'm not sure.
11:29:40 <Lor> http://www.haskell.org/onlinelibrary/list.html
11:29:55 <dustin`> Thanks!
11:30:32 <dustin`> Lor: I see!  Is that standard in all Haskell implementations?
11:31:13 * shapr thinks so
11:31:27 <dustin`> Lor: Nevermind, its part of the haskell 98 report, so therefore it must be... one would think.
11:31:58 <Lor> Also check out the max function.
11:32:03 <pesco> In unrelated news, I just bought the Foundation trilogy! This is going to be good.
11:32:22 <pesco> Life is SO peachy.
11:33:35 <shapr> oh, I gotta bug Singh again about an OSS Lava
11:33:47 <shapr> I'd love to hack Xilinx FPGAs from Haskell.
11:33:59 <pesco> Woo...
11:34:08 * pesco thinks about hacking FPGAs.
11:34:28 * shapr is reading his own blog
11:35:17 * pesco introduces Either3.
11:35:30 <shapr> what's that do?
11:35:45 <Lemmih> Either3 = Right Middle Left?
11:36:15 <pesco> data Either3 α β γ = Left α | Middle β | Right γ
11:36:16 <pesco> right.
11:36:18 <shapr> what about foo :: Either (Either a) ?
11:36:53 <shapr> can you paste that again?
11:36:59 * shapr just switched to utf-8
11:37:04 * stepcut too
11:37:09 <pesco> shapr: Too verbose in code without helper functions. And then you might as well define the data type.
11:37:16 <shapr> ok
11:37:17 <pesco> data Either3 α β γ = Left α | Middle β | Right γ
11:37:26 <shapr> hm, now I only see ~
11:37:33 <stepcut> works for me...
11:37:37 <shapr> you're using utf-8?
11:37:40 <stepcut> alpha beta gamma
11:37:42 <pesco> Yes.
11:37:51 <Lor> Gaa.
11:37:53 <shapr> maybe I need to change fonts...
11:38:04 <stepcut> shapr: I am using utf-8 in erc
11:38:11 <shapr> stepcut: which font?
11:38:16 * Lemmih has completed his highly optimized template library.
11:38:25 <shapr> Lemmih: yay!
11:38:57 <pesco> I fixed irssi's settings. Yesterday it was taking the UTF-8 from urxvt, thought it was Latin-1 and converted each of the "characters" into their UTF-8-encoded equivalent and sent that to the channel.
11:39:01 <stepcut> shapr: something like this: -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1
11:39:14 <shapr> oh, (set-face-font 'default "-*-lucidatypewriter-medium-r-normal-*-*-140-75-75-m-*-iso8859-1")
11:39:14 <shapr> duh
11:39:42 <stepcut> shapr: heh, I think you need an iso10646-1 or iso8859-16
11:39:48 <shapr> right, exactly
11:39:57 <stepcut> not sure which is better
11:40:06 <pesco> Which is kind of comic, in effect reproducing the classic "utf-8 on latin-1 terminal" effect for everyone. Retro!
11:40:36 <shapr> ha
11:42:41 <shapr> gah, fixed doesn't look as nice as lucidatypewriter
11:42:48 <stepcut> shapr: no it doesn't
11:43:04 <stepcut> and λ is really stupid looking
11:43:12 <stepcut> (that's a lambda in case you can't tell)
11:43:31 * shapr looks for other iso10646-1 fonts
11:43:50 <stepcut> fixed is the most complete
11:43:54 <stepcut> but ugly :(
11:44:11 <stepcut> ☂
11:44:20 <shapr> !
11:44:44 <shapr> which debs have unicode fonts?
11:44:45 <pesco> What the hell is that?! The "dark cloud of anger" as seen in comic books?
11:45:06 * shapr didn't see that char at all
11:45:48 <pesco> urxvt seems to do a pretty good job at looking through fonts to find glyphs.
11:46:26 <Igloo> It's an umbrella, but my font doesn't do a very good job of it
11:46:31 <stepcut> pesco: in fixed, it is an umbrella
11:46:44 <stepcut> the cloud is: ☁
11:46:50 * shapr must have the wrong font set
11:46:52 <pesco> stepcut: Ah, I see.
11:47:37 <pesco> I'm not sure which font urxvt is choosing here, but at 8px size it's hard to read.
11:53:56 <shapr> pesco: oh, maybe you read about RubberDucking on my blog?
11:57:22 <tuomov> of misc-fixed, only the one aliased as 'fixed' is at all complete
11:57:32 <tuomov> other sizes of misc-fixed are only latin1 and perhaps some more
12:01:28 <stepcut> tuomov: are there any other descent fixed-width bitmap fonts besides misc-fixed ?
12:01:49 <stepcut> The greek letters in misc-fixed (especially lambda) are a bit ugly
12:01:55 <tuomov> stepcut: no?
12:02:52 <stepcut> http://www.cl.cam.ac.uk/~mgk25/ucs-fonts.html 
12:03:04 <stepcut> (more info on misc fixed)
12:06:39 <stepcut> shapr: 10x20 seems nice..
12:09:00 <pesco> shapr: Oh yes, that might be.
12:12:58 <shapr> stepcut: what font spec are you using?
12:14:11 <stepcut> shapr: I just went, M-x set-default-font RET 10x20 RET
12:16:21 <shapr> bah, gnu emacs
12:16:39 <stepcut> ah, you use xemacs :)
12:17:31 <stepcut> well, the font alias is 10x20 either way
12:19:07 <stepcut> \rightarr
12:19:10 <stepcut> eek
12:21:02 <shapr> (arr andersca) :: Arrow Geek Pirate
12:21:56 <andersca> @arr
12:21:56 <lambdabot> I'd like to drop me anchor in her lagoon
12:22:21 <shapr> oh, hey, I need to create msn or yahoo! accounts for business (yes really) can I do that with bitlbee?
12:24:42 <stepcut> heh
12:27:08 <tic_> arr, ye be pirates
12:40:07 * shapr finds a very old quote from pesco
12:40:55 <shapr> <pesco> "Book sales on advanced functional programming titles skyrocketed this week, after word had spread through an underground mailing list about two particular volumes which one coder described as 'good', a commonly-used code for sources of new powerful knowledge pertaining to the long-term achievement of world domination."
12:40:56 <CosmicRay> @help
12:40:57 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
12:40:58 * shapr snickers
12:41:10 <CosmicRay> lambdabot: @listcommands
12:41:12 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
12:41:12 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
12:41:12 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
12:41:12 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
12:41:12 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
12:41:12 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
12:41:14 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
12:41:16 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
12:41:17 <shapr> y0 CosmicRay, wazzup?
12:41:18 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
12:41:36 <CosmicRay> implementing an FTP module
12:41:54 <pesco> shapr: Wow, what was I refering to?
12:41:59 <shapr> I've got a coupla FTP modules lying around.
12:42:15 <shapr> dunno how well they work, but I can send 'em to ya
12:42:22 <shapr> pesco: no clue, but it sure sounds impressive.
12:42:43 <pesco> Heh. :) Where did you find it? Is that on the QuotesPage?
12:42:53 <CosmicRay> shapr: that would be nice
12:43:04 <CosmicRay> shapr: google couldn't find me any.
12:43:23 <shapr> pesco: nah, it's a really old file from my last linux installation
12:43:32 <pesco> Wow!
12:43:32 <shapr> pesco: how long have I known you? :-)
12:43:53 <pesco> I think I first came in here in the summer of 2001.
12:43:53 <shapr> it's surrounded by notes from #twisted and #python so it must from quite some time ago.
12:45:35 <shapr> CosmicRay: I got InternetLib here - http://www.cse.ogi.edu/~hallgren/untested/
12:45:47 <shapr> haven't persuaded Fudgets to build yet, so I haven't tried it.
12:46:02 <shapr> I'll mail you harc
12:46:56 <shapr> sent
12:47:08 * shapr tries to read the notes he kept in lojban ...
12:48:14 <CosmicRay> ooo, haskell w7r3z
12:48:33 <Lor> 7?
12:48:41 <CosmicRay> warez
12:48:45 * CosmicRay is just kidding
12:48:53 * pesco improves his code.
12:48:54 <CosmicRay> shapr sent me an e-mail with the subject "ftp codez"
12:49:02 <Lor> No, it's just a strange dialect.
12:49:03 <pesco> Or rather, my code improves itself.
12:49:19 <CosmicRay> ugh,this internetlib code is a mess
12:49:22 * Lor would write it with a 4.
12:49:33 * CosmicRay will look at the other package :-)
12:49:40 <pesco> Is there an ISO standard for leetspeak?
12:49:47 * shapr grins
12:49:47 <shapr> CosmicRay: I got bunches...
12:49:50 <CosmicRay> shapr: FWIW, Wash does most of what's in there as far as mime stuff goes
12:50:16 <CosmicRay> whoa
12:50:21 <CosmicRay> richard braakman is a haskell coder?
12:50:31 <pesco> Why does it do that? Haskell code keeps getting prettier when you extend it.
12:50:48 <shapr> CosmicRay: you didn't know that? dark is a seriously kickass Haskeller, when he feels like it.
12:50:55 <shapr> I have a whole bunch of Haskell code he wrote.
12:51:05 <shapr> including a highly impressive SDL binding
12:51:16 <CosmicRay> huh, no I had no idea
12:51:24 <CosmicRay> he goes way back with debian
12:51:29 <shapr> yah, I know.
12:51:41 <shapr> sadly, I introduced him to "A Tale in the Desert"
12:51:51 <shapr> and he hasn't resurfaced that I'm aware of...
12:51:58 <CosmicRay> his FTP.hs is nice
12:52:07 <CosmicRay> it doesn't quite do everything I need it to, but it should be useful for ideas
12:52:10 <pesco> What's "A Tale in the Desert"?!
12:52:10 <CosmicRay> esp. url parsing
12:53:58 <CosmicRay> heh, his Util.List has several of the same functions I have in my MissingH.List
12:54:09 <CosmicRay> shapr: you should have sent this to me a week ago :-)
12:54:24 <CosmicRay> and it's all well-written, documented code, too.
12:54:27 <CosmicRay> just the kind I like.
12:54:40 <CosmicRay> there's some really nasty haskell code otu there
12:54:52 <CosmicRay> haskell can look a lot like Perl in the wrong hands :-)
12:56:37 <pesco> I've had it with this game! I'm going for a scuttle...
12:56:52 <pesco> Good bye everyone, see you soon!
13:00:50 <shapr> CosmicRay: you want my whole collection?
13:01:15 <shapr> ~200mb in my haskell dir, but that includes papers and multiple versions of some stuff.
13:01:22 <CosmicRay> that would be kick-ass.
13:01:28 <CosmicRay> can you post a tar.bz2 somewhere?
13:01:54 <shapr> maybe
13:03:03 <shapr> much of it doesn't have any sort of license at all.
13:03:42 <CosmicRay> well maybe it can be useful for ideas at least
13:03:49 * CosmicRay is always careful about licenses and attributions and such
13:04:04 <CosmicRay> but I'm also very much a learn-by-example kind of guy
13:06:05 <shapr> oy, this is wayy too much crap to look through...
13:06:19 <stepcut> heh
13:06:22 <xerox> yo
13:07:01 <CosmicRay> just tar up the whole thing :-)
13:09:20 <CosmicRay> disk cheap
13:09:22 <CosmicRay> bandwidth cheap
13:09:23 <CosmicRay> tar good.
13:10:37 <shapr> CosmicRay: yah but, I think I really do have some Haskell semi-warez in here.
13:10:42 <CosmicRay> oh
13:10:49 <CosmicRay> heh
13:10:50 <shapr> code that I really shouldn't give out at all.
13:10:59 <stepcut> heh
13:11:06 * CosmicRay promises not to post it where the Microsoft guys read :-)
13:11:19 <CosmicRay> btw, what is microsoft's involvement in haskell?
13:11:23 <CosmicRay> there's some guy on the lists a lot
13:11:25 <CosmicRay> marlow maybe?
13:11:26 <CosmicRay> from ms
13:11:45 <shapr> well, Simon Peyton-Jones is pretty much the big guy in Haskell, imho.
13:11:59 <shapr> and Simon Marlow is the guy who does the most work on GHC
13:12:07 <shapr> and Microsoft has hired both of them.
13:12:18 <CosmicRay> huh
13:12:20 <CosmicRay> I wonder why
13:12:33 <Igloo> SP-J is a prolific researcher at MS Research Cambridge
13:12:36 <CosmicRay> they don't seem to be into haskell-like stuff maybe
13:12:39 <CosmicRay> ah
13:12:55 <shapr> yah, SPJ is shockingly productiev.
13:12:59 <Igloo> He'd written GHC while at Glasgow Uni, and when they employed him Simon Marlow was his research assistant
13:13:00 <shapr> I wonder when he sleeps.
13:13:12 <xerox> is there some win32 haskell compiler/interpreter as nice as DrScheme is for Scheme ?
13:13:24 <shapr> SPJ is also *really* nice.
13:13:37 <shapr> He's great fun to talk to, hang out with, etc.
13:14:35 <shapr> and SPJ has a reputation for taking off at least his shoes while giving talks.
13:15:14 <CosmicRay> Is there a way to, say, convert from a Word32 to a Word8 when I know the data in question will fit in a Word8?
13:15:16 <shapr> CosmicRay: in answer to your question, it sure looks like ms.com puts in money, and we get out development.
13:15:22 * shapr shrugs
13:15:29 <CosmicRay> shapr: well that's cool then
13:15:58 <shapr> yah, I used to be worried about it, but so far it looks like ms.com is just helping out Haskell.
13:16:02 <drlion> CosmicRay: just open the file and Word will ask you to convert it
13:16:13 <shapr> drlion: oh that's evil
13:16:20 <CosmicRay> ouch
13:16:22 <kolmodin> haha :)
13:16:25 <CosmicRay> :-)
13:16:40 <drlion> ;-)
13:16:42 * shapr puts that on the QuotesPage right away
13:17:40 <CosmicRay> I guess I could go through show and read
13:17:43 <CosmicRay> but that just seems wrong
13:18:10 <drlion> where is the QuotesPage?
13:18:40 <Igloo> fromIntegral
13:18:47 <shapr> http://www.haskell.org/hawiki/QuotesPage
13:19:28 <CosmicRay> thanks igloo
13:23:07 <Philippa_> xerox: under win32, GHC(i) is as good as it gets. Pretty damn usable IMO
13:23:49 <xerox> Philippa_ uhm, okie, thanks
13:41:11 <maihem> shapr what does a credit card company (ms.com) have to do with haskell development?
13:41:52 <shapr> sorry, ms.com is a shortcut for microsoft.com
13:42:34 <maihem> heh, I knew, just thought I'd be pendantic for the sake of a cheap laugh :)
13:42:38 <shapr> :-P
13:42:42 * shapr wants a dbus binding for Haskell
13:42:53 <stepcut> he
13:42:57 <desrt> shapr; i'll get on that
13:42:58 <stepcut> heh
13:42:59 <desrt> :)
13:43:19 <shapr> desrt: really?
13:43:31 * shapr cheers
13:43:40 <desrt> no.  i doubt it :)
13:43:48 * desrt thinks about it a bit
13:44:17 <desrt> it would be interesting if you could declare a method call to be pure
13:44:27 <Igloo> Gah, I hate stack overflows
13:45:18 * shapr too
13:45:26 <shapr> lambdabot's only problem is stack overflows.
13:51:18 <stepcut> shapr: It also dies if you run @yow without the right version of emacs installed
13:54:40 <shapr> yah, that too..
13:55:06 <shapr> I hacked it to look for yow.lines in . but it really shouldn't die like that at all.
14:04:09 <shapr> best thing that could happen to lambdabot right now would be hs-plugins support.
14:06:08 <CosmicRay> wghat does @ mean in span _ xs@[]            =  (xs, xs) ?
14:06:34 <shapr> means, "bind [] to the name xs"
14:07:08 <shapr> foo a@(Constructor x y) = if x == 0 then (Constructor 1 y) else a
14:07:22 <CosmicRay> ah.
14:07:22 <CosmicRay> thanks
14:07:24 <CosmicRay> that is useful.
14:07:46 <shapr> can be confusing to read
14:31:55 <shapr> it's oh so quiet....
14:37:29 <shapr> it's oh so still...
14:37:45 <shapr> it's midnight friday night in sweden, and I'm working...
14:37:45 <shapr> dang
14:37:48 <CosmicRay> huh.  lines lines "foo\nbar\n\nbaz\n55" returns the same thing as lines lines "foo\nbar\n\nbaz\n55\n"
14:37:51 <CosmicRay> that seems broken to me.
14:38:48 * shapr agrees
14:42:30 <Igloo> I don't like it either, but that's what we're stuck with
14:44:35 <shapr> time for Haskell 2 !
14:44:41 <shapr> Haskell 04
14:45:38 <stepcut> :p
14:50:13 <shapr> I wish Gadgets were under at least a GPL license.
14:51:35 * shapr sighs
14:52:42 <Igloo> What licence are they under?
14:53:41 <shapr> freeware for academic use only
14:53:51 <Igloo> :-/
14:54:07 <shapr> I nearly sent a snippy reply to the libraries list about licenses...
14:54:41 <shapr> basically saying "As a self-employed programmer, I'm not interested in libraries I can't use to do paying work."
14:55:00 <shapr> but decided at the last moment that it was far too snippy
14:56:23 <Igloo> Well, you can't dictate what licences other people should be allowed to use, but allowing things with no licence is just silly
14:57:02 <shapr> yes, true.
14:58:20 <CosmicRay> shapr: that's not too snippy
14:58:27 <CosmicRay> wtf is the point of releasing a license for academic use only?
14:58:35 <CosmicRay> make it gpl
14:58:41 <CosmicRay> then at least if they profit off you, you can profit off them
14:58:50 <shapr> I don't know
14:59:00 <Igloo> It could be university regs or something
14:59:34 <shapr> I was even less snippy about the license with Yampa, just saying that I'd like to use it in a game and that I couldn't with the existing license, and the authors were very snippy in return.
14:59:57 <tromp> http://www.amdboard.com/pic.html
15:00:06 <tromp> that is one cute pc:)
15:00:47 <CosmicRay> shapr: I license all my code as GPL, but I include a note saying that I'm willing to negotiate if it doesn't work for someone
15:00:50 <shapr> For me, I don't even want to invest my time spent learning something, if I can't use it in my daily life. And my daily life is being self-employed.
15:01:04 <CosmicRay> yeah, that's similar to me
15:01:09 <CosmicRay> my daily life involves using stuff in Debian
15:01:17 <CosmicRay> hence my desire to shove haskell stuff into it :-)
15:01:26 <tromp> do you work contracts, shapr?
15:01:33 <shapr> CosmicRay: I am happy about that :-)
15:01:34 <shapr> tromp: yes, I do.
15:01:51 <shapr> tromp: want to hire me? ;-)
15:01:55 <tromp> how do you advertize your services?
15:02:22 <shapr> word-of-mouth has been most efficient so far.
15:02:33 <shapr> Most of our clients are in EU projects.
15:02:35 <tromp> once u reach critical mass yes
15:03:09 <tromp> what's the most boring job you worked on:-?
15:03:18 <tromp> project i mean
15:04:13 <shapr> I'd say that tracking through Zope to fix I18N issues has been the most boring thing I've done so far.
15:04:36 <tromp> so you're a python wiz too:)
15:04:53 <shapr> Mostly because there is no standard I18N support, and all the bugs I found and fixed were never going to be useful to anyone else.
15:05:19 <shapr> Most of my income comes from Zope/Plone work.
15:05:26 <tromp> i can see that's boring, but proabably not the most agonizing project
15:06:03 <shapr> I've also been paid to do XSLT+XML stuff, MS Access database stuff, javascript, SQL, sysadmin, lots of random things.
15:06:36 <shapr> Before I moved to Europe I did Java and Visual Basic.
15:06:59 <tromp> wow, a master of many trades
15:07:07 <shapr> I don't really have a good answer, programming doesn't ever really get agonizing.
15:07:33 <shapr> Whenever something starts to really pain me, I think about the jobs I've had making sandwiches at fast food shops for extremely small amounts of money.
15:07:58 <tromp> i know some1 who loved that job
15:08:12 <shapr> I didn't hate it, but it sure didn't stretch my brain.
15:08:29 <tromp> but maybe i read one hitchiker's guide novel too many:)
15:08:44 <shapr> Some people say programming is art, some say it's science... I say it's magic =)
15:09:25 <shapr> The most agonizing jobs I've had were all about managers who wouldn't listen, who insisted on doing something obviously (to me) suicidal for the project/company/my job.
15:10:43 <shapr> Even working on the massively bloated and under-refactored J2EE wasn't nearly as bad as knowing before starting, that the project would fail miserably.
15:11:13 <tromp> you must find lots of recognition in dilbert:)
15:11:21 <shapr> dilbert is reality.
15:11:49 <shapr> I have a very very long list of dilbert stories that have happened to me.
15:12:30 <tromp> maybe you even learned the location of Elbonia:-?
15:12:52 <shapr> My co-sysadmin did rm -rf /lib accidentally on our only Solaris box, and my boss had sold the license and media for Solaris long ago.
15:12:53 <tuomov> office space is reality as well :)
15:13:04 <shapr> And the client wanted the box ready in less than an hour.
15:13:40 <Etaoin> tromp: regarding "magic" have you heard the Arthur C Clarke quote?
15:13:55 <tromp> yeah, i saw office space recently
15:14:03 <tromp> hilarious
15:14:17 <tromp> i think so eatoin
15:14:24 <shapr> The Java code given to me by other people in one of my projects was 100% static since no one knew how to use intances. The first dialog box called directly to the database backend, and the database backend directly set field values in that dialog.
15:14:43 <shapr> all if statements had "else {}" because they didn't know it was optional.
15:14:52 <tromp> oh my god:(
15:15:22 <tromp> and i get upset alrd if i see   if (flag == true) ...
15:15:32 <shapr> they refused to use CVS until someone deleted the wrong .bak.bak.bak folder and we lost six weeks of work on the project.
15:15:41 <tromp> well, let's sat   if (isempty == true)
15:16:04 <tromp> you've really been in the trenches!
15:16:40 <tuomov> I wonder if at my ex-job they revert back to copying file manually around now that they kicked my out
15:16:50 <tuomov> before I introduced them to cvs, they were doing that
15:16:55 <shapr> sad... very sad.
15:17:57 <shapr> tuomov: btw, pair programming with finnish programmers is either utter euphoria or a burning hole in the ground.
15:18:35 <kristnjov> linus thorvalds :O
15:18:41 <tromp> where'd you live before sweden?
15:18:45 <shapr> Finland =)
15:18:53 <tromp> :-P
15:19:20 <shapr> and before that, I had programmer and sysadmin jobs in Seattle and Birmingham
15:19:47 <goron> hej shapr
15:20:00 <shapr> Both my best and worst pair programming experiences have been with finnish programmers.
15:20:16 <shapr> hoi goron, hoe gaat het met jou?
15:20:22 <goron> Did you read the metacat paper?
15:20:29 <goron> Goed, en met jou?
15:20:34 <shapr> nah, I got distracted into hacking on yi
15:21:06 <tuomov> never done any pair programming... or any sort of team programming at all
15:21:26 <tuomov> All the code I've ever written for a living have been quick&dirty scripts
15:21:49 <goron> I hacked up a version of an election algorithm with a fellow student today (in Java). 
15:21:52 <shapr> if you can hook up with the right people, pair programming multiplies those involved
15:22:23 <goron> I agree.
15:23:10 <stepcut> shapr: watch this:
15:23:13 <stepcut> @eval Y I
15:23:17 <kristnjov> gorgons spawned through witchcraft
15:23:21 <shapr> As you can probably guess, I can come up with new ideas quickly and continuously, but I easily get distracted into investigating all those ideas. When I'm pair programming with someone who has a different but compatible outlook, they help me stick to the plan, can usually pick which of my ideas are worth following, or which are pipe dreams.
15:23:37 <lambdabot> out of fuel - use @resume to continue
15:23:39 <stepcut> :p
15:23:43 <shapr> that makes sense.
15:23:48 <shapr> @get-definition Y
15:23:49 <lambdabot> Y = \f.U(\g.f(U g))
15:23:51 <shapr> @get-definition I
15:23:51 <lambdabot> I = \x.x
15:23:53 <stepcut> of course, I just find it entertaining
15:24:09 <shapr> It's the ultimate in recursive names. Beats HURD or GNU or whatever.
15:24:17 <stepcut> exactly
15:24:46 <tromp> @get-definition U
15:24:47 <lambdabot> U = \f. f f
15:25:15 <shapr> anyway, one of my goals for yi is virtual pair programming.
15:25:35 <stepcut> shapr: you mean, supporting virtual pair programming in the editor ?
15:25:44 <shapr> yop
15:25:48 <kolmodin> shapr: cool, two users in the same buffer?
15:25:56 <shapr> yop
15:26:09 <stepcut> shapr: I have done that with emacs before, though it is not quite perfect
15:26:13 <goron> Is U = \f.f f f valid Haskell :?
15:26:13 <stepcut> it's neat
15:26:14 <shapr> there's already ways to do it with a variety of different editors, and plugins
15:26:42 <shapr> one thing I've realized is that you require an out-of-band communications channel, you can't mix text editing with text chat
15:26:56 <stepcut> in emacs, you just do make-frame-on-display i think
15:26:59 <shapr> otherwise you have to break flow and check the chat buffer
15:27:11 <shapr> voice chat and text editing seems to work fine
15:27:21 <stepcut> shapr: sipphone stuff maybe?
15:27:35 <shapr> some sort of VoIP
15:27:56 <shapr> g'day dons_
15:28:07 <shapr> the downside of make-frame-on-display is that it uses a lot of bandwidth
15:28:13 <shapr> screen gives you one way to do it
15:28:34 <shapr> another downside of most VPP solutions is that they require that all parties use the same tool for editing
15:29:10 <shapr> so I wouldn't be able to use my emacs keybindings to edit along with dons_ and his vim setup.
15:29:18 <stepcut> shapr: true (regarding make-frame-on-display)
15:29:37 <kolmodin> good night everybody
15:29:42 <shapr> g'night kolmodin 
15:33:32 <goron> What should \f.f f f stand for? \f->f.f f f?
15:33:58 <kristnjov> function composition?
15:34:04 <Igloo> . and -> mean the same thing in different notations
15:34:24 <Igloo> i.e. \f.f f f is the same as \f -> f f f
15:35:12 <Igloo> And isn't typeable in Haskell
15:35:35 <goron> It has an infinite type, yes.
15:36:42 <goron> I meant \f.something is no valid syntax in Haskell. 
15:37:25 <kristnjov> wouldn't that depend on the compiler?
15:37:35 <kristnjov> or perhaps not
15:37:38 <kristnjov> ignore me
15:37:46 <goron> Will do ;)
15:37:48 <kristnjov> :\
15:38:35 <goron> But probably it's something every Software Technology FP dude writes. 
15:40:49 <shapr> goron: it's lambda calculus syntax
15:41:58 <goron> shapr: That's what I said. :)
15:42:24 <shapr> oh, ok
15:44:28 <goron> shapr: But it's never a bad thing to inform the clueless. :-)
15:45:01 <stepcut> shapr: I am thinking, your desire to to virtual pair programming, and my desire to have the editor backend seperate from the UI portion, might have a common solution...
15:50:16 <shapr> stepcut: types that are mobile across running RTSs and E-style capability security?
15:50:59 <stepcut> shapr: something like that
15:51:26 <stepcut> mmm, mobile types
15:52:04 <shapr> we should ask musasabi when he's next awake
15:52:14 <shapr> I also want parr to get fixed :-(
15:54:01 <stepcut> @arr ?
15:54:01 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
15:55:18 * shapr hacks on yi
16:02:58 <shapr> greetings np_hard 
16:09:24 <shapr> hiya heatsink 
16:10:13 <shapr> what's the ascii value of ESC?
16:10:24 <kristnjov> it's ansi, is it not?
16:10:59 <Lemmih> 27
16:11:14 <Lemmih> @eval Data.Char.ord '\ESC'
16:11:15 <lambdabot> <<EM Dynamic -> EM Dynamic>>
16:11:47 <Lemmih> eh?
16:11:55 <shapr> eval is just lambda calculus
16:11:58 <shapr> not really haskell
16:12:04 <shapr> \ESC is just fine
16:12:11 <shapr> I'm hacking on the keymap for yi
16:12:48 <drlion> @eval (X X X) (X (X X)) (X (X X)) ((X (X X) (X X X))
16:12:48 <lambdabot> (line 1, column 47):
16:12:48 <lambdabot> unexpected end of input
16:12:48 <lambdabot> expecting operator, simple term or ")"
16:12:57 <Lemmih> What's yi?
16:13:01 <drlion> @eval (X X X) (X (X X)) (X (X X)) ((X (X X) (X X X)))
16:13:01 <lambdabot> <<EM Dynamic -> EM Dynamic>>
16:13:50 <tuomov> U+7fa9
16:13:57 <shapr> Lemmih: formerly know as hemacs - darcs get http://www.cse.unsw.edu.au/~dons/yi 
16:14:29 <drlion> wow, that's a cool name
16:15:08 <shapr> eval Y I
16:16:57 <dons> moin
16:17:14 <tromp> what kind of reduction are you using, shapr?
16:17:25 <shapr> g'day dons 
16:17:31 <stepcut> tuomov: is that utf-16 or something ?
16:17:34 <tromp> environment based?
16:17:49 <tromp> or substituation based?
16:18:21 <shapr> dons: hey, I want to do "insertKeyMap (Key x) = flip insertE x" but I don't think that works.
16:18:40 <shapr> basically, I'm very tired of the single key input mode, and ready to fix it :-)
16:18:57 <dons> oh! so am i. the key lexer was my job for today
16:19:06 <Igloo> If anyone is particularly bored, I'd welcome bug reports or anything on darcs http://urchin.earth.li/darcs/ian/regexp
16:19:27 <dons> and it would be nice to add regex searching in yi..
16:19:50 <shapr> I was just hacking up a new keymap, then I was going to see how hard to change keymaps on the fly.
16:20:10 <dons> pretty hard atm. you have to edit ~/.yi/Config.hs and restart
16:20:23 <dons> we don't have hs-plugins at runtime atm
16:20:26 <Igloo> Hmm, shouldn't be hard to adapt that code for that. Currently it's just Text.Regex in Haskell
16:20:27 <shapr> even if multiple keymaps are defined?
16:20:27 <stepcut> shapr: do you know about mustux/jmb ?
16:20:37 <shapr> stepcut: don't think I've heard of it.
16:20:52 <Igloo> Which means it should work on nhc98, and also means you can match infinite strings against "^a", for example
16:20:54 <shapr> tromp: reduction in eval? it has its own definitions file
16:21:02 <dons> shapr: I was thinking about that. shouldn't be too hard to switch between multiple pre-loaded keymaps right now
16:21:05 <dons> sure
16:21:20 <shapr> cool, that's what I was hacking on
16:21:30 <dons> but the current keymap stuff is about to go..
16:21:43 <shapr> awright, I'll skip it and work on scrolling
16:21:50 <dons> yay!
16:22:02 <stepcut> shapr: its a sub project of protux. JMB=jog mouse board. The idea is you use the mouse in one hand and the keyboard in the other. You never click with the mouse, but instead use the keyboard. *AND* (here is the part you might like) many of the keyboard shortcuts require multiple keys to be pressed at once
16:22:17 <tromp> i don't understand, shapr. how does your eval work?
16:22:20 <dons> I was going to come up with a data type for the input to the UI. rather than intermixing buffer reading and ui writing as we do atm
16:22:20 <shapr> stepcut: ooh aah
16:22:24 <stepcut> (or sometimes, you have to do things like 'double-click' with the keyboard)
16:22:31 <stepcut> http://www.nongnu.org/protux/index.html
16:22:41 <shapr> tromp: not my eval, written by Derek Elkins. you mean @eval in lambdabot, right?
16:22:49 <tromp> right
16:23:04 <shapr> grab the source, look at EvalModule. It's quite nice.
16:23:28 <shapr> Uses research by Labra & Gayo (I think) and monads tranformers and lots of neat stuff
16:23:54 <shapr> dons: that would be cool.
16:24:28 <shapr> stepcut: oh this looks goood
16:24:41 <shapr> only downside is that you still can't touchtype with it.
16:25:05 <shapr> recent research has suggested that a nose mouse might work well
16:25:07 <stepcut> shapr: right, but it has some good ideas
16:25:13 <stepcut> heh
16:25:25 <stepcut> might be hard to read the screen with your nose on the table...
16:25:59 <shapr> I think the idea is that your nose points the mouse on-screen :-)
16:26:16 <shapr> and I thought my neck got stiff just from my chair...
16:26:32 <shapr> stepcut: this really is a orthogonal approach, move the button off the mouse.
16:26:35 <shapr> very sensible.
16:28:30 <stepcut> shapr: right, but it does have code to deal with multi-key presses and stuff
16:28:52 <stepcut> shapr: there is the problem that people can not simultaneously press two or three buttons at the exact same time
16:29:06 <stepcut> so you have to distinguisd between 'at' and a followed by t
16:29:20 <stepcut> or maybe I misunderstand what you wanted..
16:30:47 <shapr> ah, right
16:32:01 <shapr> yay, FINALLY! https://sourceforge.net/tracker/?func=detail&atid=350001&aid=713424&group_id=1
16:33:00 <shapr> stepcut: good point, I'll check the code at some point
16:33:43 <stepcut> shapr: cool! go haskell!
16:35:16 <stepcut> wtf -> http://www.thedenverchannel.com/news/3841819/detail.html
16:40:17 <Igloo> Hmm, 2 orders of magnitude slower than grep -Eq at matching '^a*$'  :-/
16:42:24 <tromp> shapr, i can't seem to find any papers of the research you mentioned
16:43:25 <tromp> his homepage is petra.euitio.uniovi.es/~labra/
16:43:41 <tromp> which is excruciatingly slow:(
16:44:31 <tromp> http://di002.edv.uniovi.es/~labra/ is better
16:46:59 * Igloo fiddles a bit with negligible effect. Oh well, I guess grep doesn't have the overhead of having to potentially identify with parentheses match
16:50:11 <dons> this is very exciting. modeful editors are easy to simulate using monadic lexers
16:50:21 <dons> haskell rules again
16:51:41 <Igloo> Does vim's 5ifoo<ESC> work nicely?
16:52:58 <tromp> or do you mean the liang/hudak/jones paper, shapr?
16:53:11 <dons> Igloo: not yet. shouldn't be too hard
16:53:38 <dons> I'm writing a vi mode, then working up to vim mode
16:53:42 <Igloo> *nod*, I only meant does the design make it easy - I'm not expecting anything to work yet  :-)
16:54:06 <dons> yes. it makes it easy
16:54:20 <dons> you just have to come up with the grammar, and the action it invokes
16:55:18 * Igloo beds
16:55:19 <dons> $int 'i' $c+    { \cs i -> mapM_ (insertE cs) [0..i] }
16:59:17 <shapr> greetings jay_23, looking for Haskell info?
16:59:39 <shapr> tromp: nah, paper by labra & gayo iirc.
16:59:44 <shapr> ok then, no info for jay_23
16:59:48 <phubuh> :O yi is already cool enough to support a vi mode?
17:00:17 <peti> Good morning. 
17:00:30 <peti> Anyone awake? :-)
17:00:32 <tromp> that's one person:) his name is Jose Emilio Labra Gayo
17:00:52 <shapr> Gute Morgen peti
17:00:59 <shapr> peti: no one sleeps on #haskell, it's just not done.
17:01:10 <shapr> tromp: oh ok then.
17:01:10 * peti is proud to report that since 10 minutes ago there is a complete sendmail written entirely in Haskell.
17:01:12 <peti> Yay. :-)
17:01:14 <shapr> yay!
17:01:25 <peti> shapr: http://postmaster.cryp.to/
17:01:28 <phubuh> yay!
17:01:39 <stepcut> peti: are you the peti who wrote the RFC2822 parser ?
17:01:46 <peti> stepcut: yep.
17:01:50 <peti> Guess why. :-)
17:02:16 <tromp> can you tell me which paper of http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/g/Gayo:Jos=eacute=_Emilio_Labra.html i want?
17:02:18 <peti> The MTA is far from complete, naturally, but once it is, it is gonna _rock_.
17:02:38 <tromp> maybe "Modular Development of Interpreters from Semantic Building Blocks" ?!
17:03:01 <stepcut> peti: i pulled a copy rfc2822 out of cvs attic somewhere, is there a better version anywhere ?
17:03:25 <shapr> tromp: no, I can't remember. But I think there's more info in EvalModule.hs
17:03:28 <peti> stepcut: http://cryp.to/hsemail/
17:03:46 <peti> stepcut: Even though the 2822 module is not very good, really.
17:04:07 <shapr> better than my 822 module ever got
17:04:16 <shapr> peti: want sources!
17:04:50 <peti> shapr: You can browse them at the web site, so far. I could set up darcs?
17:05:15 <stepcut> peti: I have been using it to parse debian files, so far I there is only one bug I ran into (something to do with fws i think)
17:05:47 <peti> stepcut: Depending on what you want to parse, you might be better off using the 2821 module. That one is much better maintained.
17:06:01 <shapr> peti: sure, setting up darcs for anon get is pretty easy =)
17:06:09 <stepcut> peti: ok, I will look into that
17:06:17 <peti> I'll polish the 2822 module ASAP, because I'll need it for the MTA, too. 
17:06:49 <stepcut> hehe
17:07:45 <stepcut> I just need to parse files like -> Field: Value
17:07:49 <stepcut> with folding whitespace
17:08:23 <peti> stepcut: I see. Then you'll need 2822. The other module just defines e-mail addresses and SMTP commands, that won't help you.
17:09:02 <peti> stepcut: If you found any bugs, have any problems, please let me know, okay? I'll try to fix everything ASAP.
17:09:42 <stepcut> ok, hold on
17:13:34 <shapr> hi LrdMtrod 
17:15:13 <LrdMtrod> hi
17:15:22 <shapr> LrdMtrod: how's code?
17:15:27 <shapr> dons: hey, you got a moment?
17:15:42 <LrdMtrod> code... not ggood at the moment!
17:16:37 <tromp> sorry shapr, no pointers in any evalmodule.hs google can find:(
17:16:57 <tromp> pls drop me a note if you ever find the reference:)
17:17:32 <shapr> dons: the simplest thing that could work would be to offset the buffer by dropping earlier lines until the cursor is visible. cheesy, but would work. Any better ideas?
17:18:09 <shapr> tromp: latest lambdabot sources - http://www.scannedinavian.org/~shae/lbot2.1.tgz
17:18:37 <tromp> thx, shapr
17:18:58 <shapr> look in LangPack.hs
17:19:42 <tromp> no such file?!
17:19:43 <dons> shapr: that's how I thought to start with too
17:20:21 <tromp> although it's on the web
17:20:28 <dons> let depth = filter (== '\n') ss
17:20:33 <tromp> ah, "Language Prototyping using Modular Monadic Semantics"
17:21:14 <dons> where ss = take (pointB b) (elemsB b)
17:21:29 <dons> take depths (lines ss)
17:21:31 <dons> or something
17:21:44 <shapr> right, but will Curses be okay with that?
17:22:02 <shapr> is curses actually getting the whole buffer to be drawn? or just enough to fill the visible area?
17:22:06 <dons> just generate an appropriate [String], and mapM_ drawLine over it
17:22:11 <shapr> ah, ok then
17:22:18 <dons> just enough to fill the visible area, please ;)
17:22:22 * shapr grins
17:22:35 <dons> and then curses can optimise the movement, however it does that
17:22:44 <dons> optimise the redraw
17:22:59 <shapr> sounds good to me
17:23:16 <shapr> pretty bizarre.. our own text framebuffer.
17:23:46 <dons> yeah. oh well, this leads us to our own ion wm for the editor, methinks
17:23:57 <shapr> ?
17:24:09 <shapr> oh, I see
17:24:13 <shapr> right, I agree.
17:24:37 <dons> the most expensive functions in the editor are now in Curses.hsc and UI.hs
17:24:48 <dons> wAddStr is the worst
17:24:49 <tromp> i have a stack of 12 haskell papers sitting on my desk, maybe need some time off work:)
17:25:25 <shapr> only 12 ? ;-)
17:25:53 <tromp> oh, plus 2 more in the paper tray:)
17:26:15 <tromp> how many years have you used haskell, shapr?
17:26:32 <shapr> um.. as long as this channel has been around.
17:26:43 <shapr> slighly over three years.
17:27:08 <wagle_> i have the original haskell design draft from 1988
17:27:25 <phubuh> i was born in 1988 :/
17:27:28 <shapr> before that, I was a 100% Pythonista
17:27:44 <dons> shapr: isn't laziness great for the (s ++ repeat ' ') code in the ui!
17:27:50 <dons> no stupid calculations
17:27:51 <shapr> yah, that's pretty sexy
17:27:53 <tromp> http://www.lib.uchicago.edu/keith/crisis/crisis.html is an interesting read
17:28:07 <tromp> "My Programming Language Crisis"
17:28:10 <wagle> kjhsd
17:28:21 <shapr> aeiahnts!
17:28:25 <shapr> aoeuhtns no less
17:28:34 <stepcut> dons: I thought it might be nice if you could run a yi GUI on one machine, and have to controlling multiple yi processes running on remote network machines... 
17:29:47 <shapr> tromp: I'm still in my crisis ;-) I want epigram's type system, erlang's distributed-ness with E's capability security, transparent parallelization, or at least nested data parallelization, and so much more.
17:29:58 <shapr> and arrows
17:30:04 <stepcut> and spears
17:30:07 <dons> stepcut: ok. so I really need a type for the input into the ui
17:30:07 <tromp> no bows:-?
17:30:09 <shapr> and spears ;-)
17:30:33 <shapr> dons: does chilli still hack on parr at all?
17:31:01 <stepcut> dons: right, the ui and the non-ui would have to be completely seperated, but that could be really nice
17:31:07 <dons> there's still people here working on the low level of that stuff (C level), but I think he's off in functional dependencies for a  while
17:31:28 <dons> stepcut: well, they're fairly separate. but I'm going to enforce that
17:31:46 <stepcut> dons: I could use my laptop to control the process on my dev box. Then even if I turn of my laptop and take it home for the weekend, I could reconnect to my dev box on Monday and pick up where I left off
17:31:53 <dons> I was going to write a line editor (ie. sed) gui, just to make sure the abstractions were sound
17:32:03 <dons> stepcut: that is really cool
17:32:07 <dons> ok. I like this idea
17:32:41 <stepcut> dons: or, I could being editing a file locally using the graphical mode, and then go somewhere else, ssh in, and connect to the running session via the command-line...
17:33:31 <dons> switch to the console and get ncurses, then switch to X and get the opengl ui :)
17:33:38 <dons> without closing any files
17:34:17 <shapr> yes, this is a good idea.
17:34:22 <stepcut> dons: The thing I do most is use my laptop as my graphical display, and then connect to multiple remote machines for doing the dev work, and so every morning I have to spend time restarting all the remote sessions. Plus it is annoying to have 3 or 4 emacs windows, instead of just one that has everything
17:34:45 <stepcut> dons: and tramp is not really sufficient, because I want to do M-x eshell, and run compiles on the different machines
17:35:10 <peti> Good night, everybody. I'm off to bed.
17:35:11 <dons> ok. so we come up with a ui class, and a good type for sending buffer data to the ui instance
17:35:24 <stepcut> right
17:35:25 <dons> this seems doable
17:35:42 <shapr> tramp copies everything locally, and only saves remotely
17:36:01 <shapr> how do to M-x hshell ?
17:36:27 <shapr> Haskell doesn't have a Serializable class.
17:36:29 <shapr> We need one.
17:36:41 <shapr> stepcut: NewBinary == Serializable?
17:36:59 <stepcut> shapr: I have some work done on (a) serializable data (b) pipes
17:37:08 <phubuh> (Read a, Show a) => a? :-)
17:37:18 <shapr> phubuh: that doesn't always work
17:37:44 <stepcut> phupuh: Currently, yes, with Typeable, but I think I might use Storable instead of Read a/Show a
17:37:44 <shapr> and it's slow :-(
17:37:48 <phubuh> oh, yeah, putting serialize and deserialize in the same class implies that their composition is the identity
17:38:52 <tromp> still got to submit a lambda calculus quine ...
17:38:58 <shapr> stepcut: my number one research interest along these lines is: can I add to the type-table at runtime?
17:39:10 <phubuh> hm... i guess you can't serialize a = 1 : a in pure haskell
17:39:19 <shapr> or, is there a way for me to send a type-description along with the value to a remote RTS?
17:39:32 <dons> hehe. maybe we can come up with a way.
17:39:49 <bojohan> <stepcut> dons: and tramp is not really sufficient, because I want to do M-x eshell, and run compiles on the different machines
17:39:52 <dons> more moves to pull ghc in to its rts
17:39:53 <bojohan> what do you mean?
17:40:06 <shapr> dons: can it be done?
17:40:07 <stepcut> shapr: yes, it stores the type description and the data
17:40:36 <shapr> I thought a TypeRep was just a pointer into the type table, not an actual 'description' ?
17:40:40 <shapr> what are you using?
17:40:57 <stepcut> shapr: hold on
17:41:01 <tuomov> mm.. so what's the latest on yi, would someone care to summarise?
17:41:07 <shapr> bojohan: eshell across tramp
17:41:07 <dons> ok!
17:41:17 <bojohan> like
17:41:17 <bojohan> Welcome to the Emacs shell
17:41:17 <bojohan> ~ $ cd /bojohan@helm.dd.chalmers.se:~
17:41:17 <bojohan> /ssh:bojohan@helm.dd.chalmers.se:/users/dd/bojohan $ pwd
17:41:17 <bojohan> /ssh:bojohan@helm.dd.chalmers.se:/users/dd/bojohan
17:41:20 <stepcut> first, here is a sample command-line thing from my new library:  ls ["/tmp","aoeu"] @> "/tmp/ls_error" -|- cat ["-n"] |> "/tmp/output"
17:41:42 <shapr> bojohan: tried it with multi?
17:41:42 <dons> yi: basic editing, somewhat like vi. no undo/redo. save. multiple buffers, and rotate between them.
17:41:52 <dons> no scrolling yet.
17:41:54 <bojohan> hmm, no...
17:41:55 <LrdMtrod> I'm thinking of coding a chemical cad program, and as it needs some highly complexed simulations involving quantum mehcanics and stuff as well as large tables of data, would haskell be a good choise?
17:42:10 <shapr> bojohan: last I checked, it doesn't work with multi, but I also fixed some multi bugs in my local tramp sources.
17:42:13 <tuomov> the buffer design?
17:42:36 <bojohan> i don't really use tramp or eshell
17:43:01 <dons> please comment on this: http://www.cse.unsw.edu.au/~dons/yi/Yi/Buffer.hs
17:43:02 <shapr> LrdMtrod: it would be a good design if you abstract it well, and you'll probably want to wrap a tiny bit of C code for the inner loops on the quantum mechanics.
17:43:21 <dons> tuomov: essentially your buffer class, extended to multiple lines
17:43:33 <dons> with a few extra things i found useful for cursor movement
17:43:45 <stepcut> shapr: I don't have my serialization code here, but I will dig it up this weekend
17:43:54 <shapr> stepcut: spiffy, I look forward to it.
17:43:54 <tuomov> that old pre-theory design?
17:44:03 <dons> yes
17:44:20 <dons> undo/redo should be the introduction of buffer theory, most likely
17:44:21 <tuomov> it could work as a front-end to theory..
17:44:24 <dons> yep
17:44:37 <shapr> LrdMtrod: the downside to using Haskell is that if you do it wrong, it's *really* slow and painful.
17:44:42 <stepcut> shapr: Its nothing too fancy, and it has some limitations, but it works for what I need
17:44:47 <bojohan> "a tiny bit of C code for the inner loops on the quantum mechanics." that's funny. taken out of context.
17:44:51 <dons> the current buffer is extremely fast, so I'd like to build on top of that, if possible
17:44:59 <LrdMtrod> bojohan: japp
17:45:27 <shapr> LrdMtrod: if you use something like Yampa for the simulation you could take advantage of a lot of powerful stuff.
17:45:38 <dons> pressing projects: better ui code. customisable key bindings. undo/redo
17:45:54 <shapr> yah, the UI code needs help.
17:45:55 <dons> the first two are being worked on. the second is getting a few cycles in my head
17:46:03 <dons> s/second/third/
17:46:03 <shapr> I should probably go with Screen.hs from ginsu.
17:46:12 <LrdMtrod> what's yampa?
17:46:18 <shapr> http://www.haskell.org/yampa/
17:46:23 <tuomov> undo/redo depends on the eventual buffer theory implementation
17:46:24 <dons> shapr: or steal some ion algos ;)
17:46:38 <dons> tuomov: yes. that's why I'm putting it off for now.
17:46:43 <tuomov> there's no point doing anything special if simply snapshotting is enough
17:47:24 <tuomov> and as we usually should want to keep amount of modified data small, it should be enough
17:47:34 <shapr> Once we've got an editor that does work, and can edit itself, I want to have a powwow about the possibility of Yampa and arrows.
17:47:48 <shapr> but not before...
17:47:57 <tuomov> otoh, as suggested in the theory posting, it might allow for other as convenient implementations 
17:48:55 <tuomov> I should get ion3 out of the way before starting to really work on anything big..
17:49:02 <dons> shapr: well, i've already used yi to edit the TODO list :)
17:49:21 <dons> tuomov: sure. and once yi settles down a bit
17:49:33 <shapr> dons: awesome!
17:49:39 <shapr> dons gets first edit =)
17:49:58 <dons> insert atm is painful :)
17:50:02 * shapr agrees
17:50:07 <dons> hence the key binding issue being tackled today!
17:50:17 <dons> but kill is fun :)
17:50:24 <shapr> :-)
17:50:56 <shapr> dons: you want to write up yi for HCnAR, or shall I?
17:51:22 <tromp> hmm, why does ghci barf on   x+x where x = 3
17:51:22 <dons> ooh. you can. I've already got 2 things to write.
17:51:27 <shapr> ok
17:51:43 * shapr has many things to write for HC&AR
17:51:46 <dons> hehe
17:52:10 <dons> tromp: ghci is a do-loop
17:52:22 <dons> so you can only write things you can write inside a do 
17:52:24 <tuomov> what's hc&ar?
17:52:39 <dons> tromp: let y = x + x where x = 3
17:52:41 <tromp> ah, thx dons
17:52:53 <dons> haskell communities and activities report
17:53:26 <dons> http://www.haskell.org/communities/
17:54:47 <dons> tuomov: riot could go in..
17:56:40 <tuomov> hmm..
18:00:33 <dons> someone might see the entry, and write riot-mutt for us :)
18:02:32 * shapr finally understands drawPoint
18:03:30 <dons> hehe :}
18:04:12 <dons> i even put comments in!
18:04:32 <shapr> yes, I think I now understand pretty much all of the UI code at once.
18:04:56 <dons> "length $ filter (== '\n') prev"  --> that's just counting how many lines in to the file we are
18:05:02 <shapr> right, I got it :-)
18:05:55 <shapr> where do I stick the line offset?
18:06:09 <shapr> buffer state?
18:06:23 <shapr> no, that's icky :-(
18:06:24 <dons> there isn't any line offset in the buffer state. just the point
18:06:31 <shapr> right
18:07:07 <dons> I'm thinking that we should put this, amongst other things, in a 2D-UI-local state.
18:07:30 <dons> some things don't generalise to all buffers, but shouldn't be recalculated each refresh
18:07:32 <shapr> yes, I agree
18:07:52 <shapr> I was just thinking that everything after "(h,w)   <- screenSize" in redraw is *not* Editor state
18:07:54 <shapr> it's UI state.
18:08:08 <dons> yep
18:08:13 <dons> exactly
18:08:21 <dons> the ui should remember the current sizes etc
18:08:33 <shapr> in fact, point isn't really Buffer state either.
18:08:34 <dons> so mouse events, for example, could resize windows, but not touch buffers
18:09:15 <dons> but point applies even in an ed ui
18:09:50 <shapr> it's still the UI. Think of multiple people network editing a Buffer
18:09:58 <shapr> they each have their own insertion spots
18:10:19 <dons> hmm.
18:10:33 <tuomov> hmmm. multiple people editing indeed breaks any point optimisations
18:10:42 <shapr> admittedly, it's a handy optimization to think of point as part of buffer state, but it's not very general
18:10:57 <shapr> a buffer should be good at taking changes to the text
18:11:02 <dons> unless we have multiple points
18:11:18 <shapr> and probably should optimize itself according to the last one or more insertions
18:11:31 <shapr> like a zipper rotates around to make changes in the tree easy.
18:12:13 <dons> I do think for now pointB can stay in the buffer class, but we can keep multiple access in mind
18:12:18 <shapr> yes, I agree
18:12:41 <dons> a useful scenario: a single yi instance, with two windows to the same buffer, each window has a local point, into the shared buffer
18:12:50 <dons> can't do that in vim
18:12:59 <shapr> emacs does it, don't know how.
18:13:10 <bojohan> each *window has a point
18:13:12 <dons> or, maybe you can. hmm.
18:13:30 <shapr> bojohan: ah, so a view has an insertion point
18:13:30 <dons> yep. each window has its own point.
18:13:34 <dons> yeah
18:13:37 <bojohan> (info "(elisp)Window Point")
18:13:46 <shapr> read the docs? ewww ;-)
18:13:57 <dons> but we alternate access to the buffer
18:14:03 <dons> resetting pointB afresh
18:14:17 <dons> moveTo b windowP
18:14:27 <dons> more UI state!
18:15:00 * shapr adds that to the steadily growing TODO list
18:15:10 <dons> so we can keep a single point in the buffer, but we also need a window point
18:15:21 <bojohan> does point have to remain in window at all times? (like in emacs)
18:15:27 * shapr dunno
18:15:34 <shapr> that does make life easier..
18:15:35 <dons> when you shift focus to a new window, you reset the buffer point from the UI.window point
18:15:59 <shapr> what about two users editing at the same time?
18:16:09 <stepcut> dons: maybe. What if you wanted to have two windows open on two different X displays with two users editing the same buffer
18:16:13 <dons> isn't that like having to windows open to the same buffer
18:16:37 <dons> you still have MVars on the buffer, and you can alternate access between them, surely
18:16:44 <dons> just like the local windows case
18:17:11 <stepcut> dons: maybe, I haven't thought about what the desired usage would be
18:17:13 <shapr> what's the advantage of having a buffer point if you have window points?
18:17:21 <dons> so two X displays have two window points. when a user edits the buffer, the point is set to that user's window point
18:17:47 <dons> the point exists while the user has access to the buffer, to make editing simpler
18:18:01 <tuomov> for scripting, point should be movable outside view, but the view should not be moved to contain the point until a refresh is forced or we get back from a script
18:18:01 <stepcut> dons: with two people editing the same buffer in different windows, if user A kills a line, should that show up in user B's paste buffer? Or do they get seperate copy and paste buffers (for example)
18:18:04 <bojohan> shapr: a buffer can exist without windows...
18:18:06 <dons> I think points stay, but they don't persist between access to the buffer
18:18:11 <shapr> how does it make editing simpler?
18:18:32 <dons> once you've got access to a buffer, you set the point, and away you go.
18:18:51 <dons> so the buffer code doesn't keep asking the ui code for the current insertion point
18:18:55 <dons> for example.
18:19:05 <stepcut> dons: hrm, that sounds reasonable
18:19:23 <dons> think of a point like a program counter for the current thread
18:19:36 <shapr> alternatively, a buffer could be a bunch of ropes that are changes waiting to be folded into the buffer proper when it's more efficient
18:19:37 <bojohan> "scripts" should move the buffer point, not the window point
18:19:56 <tuomov> I'd say keep the point in the current buffer class.
18:20:10 <dons> yep. but of course, once you get a window, you just moveTo windowP
18:20:10 <tuomov> If and when buffer theory is implemented, point might be part of the final viewing transformation
18:20:31 <tuomov> which is separate for each window
18:21:00 <tuomov> infact, all the high-level transformations would be separate for each window
18:21:12 <tuomov> because different users may have different settings
18:21:12 <dons> yep. so ui windows have a point
18:21:13 <stepcut> dons: so, looking at the two users version, when my window gets ask to the buffer, my window will set the buffer point, and when your window gets ahold of it, your window will set your buffer point ?
18:21:17 <shapr> well, I still think point shouldn't be part of the buffer in the long-term, but I'll argue about it if we actually reach long term =)
18:21:26 <dons> stepcut: exactly
18:21:46 <bojohan> how emacs does it:
18:21:46 <bojohan> "Each window has its own value of point, independent of the value of point in other windows displaying the same buffer."
18:21:46 <bojohan> "Selecting a window sets the value of point in its buffer from the window's value of point. Conversely, deselecting a window sets the window's value of point from that of the buffer."
18:21:46 <tuomov> shapr: what really is the buffer?
18:21:51 <stepcut> dons: I wonder if there aren't a bunch of other things, besides the point
18:21:57 <dons> and this applies equally to multiple users, or single users with multiple windows onto a buffer
18:22:20 <tuomov> is the buffer the data storage at the bottom or the output of all the transformations?
18:22:25 <shapr> I think the buffer is is something that represent the current state of the text, if it were to be saved to disk right now. It doesn't have to be a single string
18:22:28 <dons> bojohan: looks like that's reasonable
18:22:45 <dons> tuomov: I thought the buffer was the very bottom unit of storage
18:23:11 <dons> the output of all the transformations would be the type sent to the ui?
18:23:15 <tuomov> then, the current Buffer class should perhaps be renamed
18:23:24 <dons> ?
18:23:26 <shapr> ?
18:23:50 <tuomov> it more a ViewToBuffer
18:23:54 <dons> Buffer -> SyntaxifiedBuffer ->  FontifiedBuffer -> DrawableBuffer -> UI
18:24:41 <dons> data DrawableBuffer = Something the ui can render quickly
18:25:44 <shapr> I'm thinking of a Buffer implementation that may appear to be a single string, but could be implemented as the original text, and just the changes on top of it. What's the advantage of having a buffer point there?
18:26:22 <dons> hmm. how do you generate a change?
18:27:04 <shapr> if it's a straight-up replace, you give only the offset,  the new text
18:27:20 <dons> offset == point, surely?
18:27:33 <shapr> you can have a bunch of different replaces.
18:27:52 <dons> so the changes are patches?
18:27:58 <shapr> yah, sort of
18:28:07 <shapr> and can be folded in when it's most efficient
18:28:13 <dons> and patches are at offsets. which was the point where that patch occured
18:28:19 <shapr> like a binary tree that rebalances itself when it's handy
18:29:24 * shapr shrugs
18:29:32 <tuomov> mark should also perhaps be where point is
18:29:39 <shapr> I'm not convinced, but I'm not very picky either.
18:29:51 <shapr> if it works, I'll be happy.
18:30:25 <tuomov> hmmm....
18:30:36 * shapr goes back to UI hacking
18:30:54 <tuomov> but how would one go about joe-style copy-paste
18:31:11 <dons> how does it work?
18:31:12 <shapr> oh wait, now I remember why this all started.. I wanted to know where to put the offset...
18:31:15 <tuomov> mark beginning, mark end -> move/copy/delete
18:31:26 <tuomov> s/copy/cut/
18:31:49 <tuomov> no.. 
18:31:57 <tuomov> move/copy/delete are the joe terms
18:32:09 <tuomov> but copy copies the marked area to current point
18:32:15 <tuomov> move moves marked area to point
18:32:44 <dons> shapr: data Window = Window { buffer=Unique, origin=(Int,Int), wpoint=Int, cursor=(Int,Int) }
18:32:45 <tuomov> there's no cutbuffers, killrings or anything of the like
18:33:13 <shapr> dons: awright
18:33:20 <tuomov> In jed I use normal copy-paste, but with bindings that resemble those of joe
18:33:21 <dons> hmm. so we need a Buffer a => MarkableBuffer a
18:33:39 <tuomov> and it is not a problem if joe-like marking isn't feasible
18:33:45 <tuomov> but it might be interesting to be able to support that too
18:33:48 <tuomov> but where would this go..
18:33:49 <stepcut> kill-rings rule
18:34:28 <dons> I don't seee why a variety of cut/copy/paste designs couldn't be simulataneously implemented using buffer primitives, and editor-binding specific code
18:34:46 <dons> as long as the editor primitives are general enough
18:35:38 <dons> shapr: I'm going to stick some state into the UI, to remember buffer sizes etc between refreshes.
18:35:50 <stepcut> so, is there a unicode symbol associated with yi ?
18:36:01 <tuomov> U+7fa9
18:36:22 <stepcut> tuomov: is that in utf-8 ?
18:36:24 <shapr> dons: cool
18:37:10 <dons> stepcut: so this is an incentive to get unicode rendering in yi -- so we can write our own name
18:37:18 * shapr grins
18:37:26 <tuomov> stepcut: sure
18:37:46 <tuomov> can't paste it because irssi expects latin1 input..
18:37:52 <stepcut> M-x ucs-insert RET 7fa9 RET gives me the error 'ucs-insert: Character can't be decoded to UCS'
18:37:56 <tuomov> and converts it to utf8 for the channel
18:38:36 <tuomov> the latin1 characters I see for the string are c, 3/4 (c)
18:39:08 <tuomov> ç¾© if it gets through
18:40:46 * shapr sees the same latin chars
18:40:57 <stepcut> yeah, me too
18:44:09 <shapr> argh, must sleep :-(
18:44:18 <shapr> lots of work tomorrow
18:44:18 <tuomov> metoo
18:44:24 <tuomov> no work though
18:44:30 <tuomov> as usual
18:45:35 <bojohan> A-tilde, section-sign, A-tilde, 3/4, A-tilde, (c) :|
18:50:04 <rhw> shapr ?
18:50:37 <rhw> ah, he went to sleep
18:51:06 <stepcut> �
18:57:27 <drlion> tuomov: what do you do for a living?
18:58:31 <drlion> those last two A's aren't decorated with tildes but circumflexes :-/
18:59:32 <bojohan> ah, true
22:04:56 <dons> lazy lexing is fun
