00:01:24 <shapr> interesting turbulence on the left that actually lifts some of the cold fluid
00:02:19 <Pseudonym> Right.
00:02:34 <Pseudonym> To quote The Simpsons... "It's like a lava lamp!"
00:06:37 <Pseudonym> Watching this stuff in action is kinda mesmerising,
00:07:29 <shapr> if it were realtime I'd suggest an xscreensaver plugin
00:07:56 <Pseudonym> Eek.  I can just imagine this at full screen res.
00:08:49 <shapr> I was thinking about a picture of my desktop with the colors translated into fluid densities or temperatures
00:09:41 <Pseudonym> Actually, advecting images is something I have planned.
00:14:55 <shapr> hiya mayhem 
00:17:24 <shapr> Pseudonym: have you read Cheadle's "Non-stop Haskell" incremental garbage collector paper?
00:17:37 <Pseudonym> Nope.
00:17:40 <Pseudonym> Sounds interesting, though.
00:19:47 <shapr> sort of like moving house... you leave a forwarding address
00:20:16 <Pseudonym> Indirections.
00:20:40 <Pseudonym> I think that's what they were called in "The Implementation of Functional Programming Languages".
00:22:32 <mayhem> yop
00:42:55 <Pseudonym> Must away.  Home time.  Nytol!
00:45:20 <shapr> esap: this has an interesting section (7.3) about its appliction to OO systems http://research.microsoft.com/~simonpj/Papers/inc-gc.htm
02:22:03 <shapr> yow!
02:23:11 <bourbaki> hi
02:23:21 <shapr> y0
02:33:44 <shapr> F00
02:35:17 <TheHunter> B4R
02:36:47 * shapr grins
02:38:39 <shapr> sure is quiet today.
02:38:54 <shapr> but maybe arjanb will talk ...
02:40:50 <shapr> hoi arjanb
02:41:33 <arjanb> morning shapr
02:42:12 <TheHunter> hey shapr, what do you think a cool functional editor would look like?
02:45:13 <bbls> what do you mean by functional?
02:45:19 <bbls> an editor for a functional programming language?
02:45:27 <TheHunter> yep
02:45:27 <bbls> or an editor written in a functional langauge?
02:45:36 <mayhem> emacs + tuareg = rox 
02:46:24 <shapr> TheHunter: I have a post-emacs mailing list...
02:46:34 <TheHunter> an editor for a functional language with incremental typechecking, nifty refactoring possibilities etc.
02:46:44 <shapr> yes, all that
02:47:01 <shapr> and more
02:47:14 <TheHunter> much more
02:47:18 <shapr> but I'm doing last minute homework before class, so I can't jump on my soapbox as usual :-)
02:48:49 <shapr> post-emacs archives haven't been created yet, since the list hasn't been online a month yet
02:48:50 <shapr> but soon
02:49:13 <TheHunter> cool
02:49:44 <TheHunter> where can I subscribe?
02:50:01 <shapr> http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
02:50:25 <shapr> the reply-to address on the subscription email is broken for the moment
02:50:34 <shapr> until I beat mailman into submission
02:50:48 <TheHunter> ok, thanks
02:50:55 <shapr> if you reply to lists.scannedinavian.org instead of just scannedinavian.org, it should work
02:54:13 <TheHunter> hmm, the reply adress is already @lists.scannedinavian.org
02:58:02 <musasabi> Is there a eay to run a hook upon exit ? I would need to delete a file if the app is sent a signal causing it to terminate.
02:59:15 <tuomov> System.Posix.installHandler?
02:59:30 <tuomov> hm.. +.Signals
02:59:48 <tuomov> but there are quite a few signals you'll need to trap
03:00:23 <musasabi> yes, that is not a very good way. something like atexit would be much nicer.
03:00:41 <tuomov> I don't think C atexit gets called on a signal
03:00:54 <tuomov> and of course there's no way to trap SIGKILL
05:47:33 <shapr> @yow !!
05:47:34 <lambdabot> I'm meditating on the FORMALDEHYDE and the ASBESTOS leaking into my
05:47:34 <lambdabot>  PERSONAL SPACE!!
05:48:07 <shapr> musasabi: I think I've seen an atExit implementation in the mailing lists somewhere.
05:48:58 <cptchaos> mussabi: if you find one could you tell the url, would be something for me too
05:51:16 <shapr> oh
05:51:22 <shapr> couldn't you use the monadic error thingy?
05:51:26 <shapr> um
05:51:28 <shapr> what's it called
05:51:39 <shapr> like try: except: finally: in Python
05:51:54 <shapr> where finally always gets called, no matter what
05:52:11 <tuomov> but anything of the kind only applies to errors internal to the program
05:52:21 <tuomov> such things don't catch the user pressing ^c
05:52:24 <tuomov> and so on
05:53:07 <tuomov> the only way to catch such an event is with a signal handler
05:54:30 <cptchaos> shapr: maybe, wrapping main, ant catching the exitException, is what I can do
05:57:55 <tromp> you mean bracket, shapr?
05:58:05 <tromp> @index bracket
05:58:05 <lambdabot> Control.Exception,IO
06:22:21 <shapr> gutentag magr 
06:22:31 <magr> re
06:23:07 <magr> I'm playing with WASH/CGI right now, so I thought I'd drop by if I got some questions...
06:23:17 <shapr> I've used WASH some.
06:24:34 <magr> It's nice, but seems not to work with JavaScript disabled...  unless I missed something
06:24:44 <shapr> that's true
06:24:55 <shapr> I think WASH needs refactoring.
06:25:09 <shapr> I wish the BigWig caching stuff were in a library somehow.
06:25:21 <shapr> WASH doesn't seem to give the informative typeerrors it used to give.
06:25:43 <magr> BigWig?
06:26:01 <shapr> for examples, there is tr and tr_T
06:26:11 <goron> hej shapr
06:26:16 <shapr> hoi goron 
06:26:48 <shapr> BigWig takes advantage of web caching by breaking pages into independent sections that are then sewn back together with javascript
06:27:05 <musasabi> shapr: I'll ne sure to tell if I find something.
06:27:15 <shapr> that means that much of the 'framework' part of page, maybe navigation or so, is always the same single url
06:27:59 <shapr> in essence, it lets you cache the parts of a page/website that don't change
06:28:14 <shapr> WASH added that functionality in 2003
06:29:03 <shapr> musasabi: I did a google search, but couldn't find the atExit ... I vaguely recall that Simon Marlow wrote it on ghc-users...
06:29:05 * shapr googles a bit more
06:29:42 <goron> I just got my first Linux lock-up. I installed the Nforce drivers. First my internet connection was killed by the buggy and not functional nvidia nvnet module. Then I tried the sound (nvsound). Well, that worked pretty good (hardware mixing), until it locked my complete machine. I am not impressed by these Linux n00bs. 
06:30:23 <shapr> goron: Linux is not the problem... closed source binary-only kernel modules is the problem.
06:31:05 <goron> shapr: I know. 
06:31:08 <shapr> if NVidia would open all their specs, there wouldn't be a problem. They think they wouldn't make any money if their specs that way.
06:31:16 <shapr> they're wrong...
06:31:47 <shapr> They should be focussing on morphing their GPUs into general purpose parallel coprocessors that are only coincidentally kickass OpenGL coprocessors.
06:32:00 <goron> shapr: I don't know whether NVidia has anything that is worth protecting. It seems they think so.
06:32:17 <tuomov> companies always think so of everything
06:32:32 <tuomov> even 20-year-old games that are not sold anywhere
06:32:45 <shapr> yah, I wish I could get the source for Pizza Tycoon :-/
06:32:53 <shapr> bunch of bugs I'd like to fix so I could play past them.
06:33:41 <shapr> Anyway, I hope that the IBM/Sony Cell (now 'Grid') CPU design will finally get rid of graphics cards entirely.
06:33:49 <phubuh> pizza tycoon ruled!
06:34:01 <goron> shapr: When will they launch it?
06:34:21 <phubuh> i remember the most profitable strategy being build towers of hundreds of lobsters
06:34:21 <shapr> not sure, sometime in the next few months I think
06:34:34 <goron> shapr: I heard it was 1000 times faster than a normal CPU.
06:34:54 <phubuh> openttd is impressive, by the way - some guy disassembled transport tycoon deluxe, grokked it, and translated it to C
06:35:20 <goron> You need some files for openttd. 
06:35:20 <phubuh> and it works a lot better than the original :)
06:35:32 <goron> It's not *open*.
06:35:33 <phubuh> yeah, you need the copyrighted data files
06:35:36 <shapr> actually, the Cell/Grid CPU is just a multicore RISC design
06:36:10 <phubuh> the engine is open.  you could make your own artwork :)
06:36:38 <goron> phubuh: Hmm, ok, didn't knew that. 
06:36:55 <goron> /s/knew/know.
06:36:59 <shapr> the idea being that for less complexity and with the same die size, you can stick a bunch of RISC CPUs that allow higher clock speeds
06:38:08 <shapr> the first Cell/Grid die calls for four CPUs, and they have a timeline that scales up to 64 cores on the same die.
06:38:09 <goron> shapr: Won't that hurt Intel/AMD share *bad*?
06:38:28 <shapr> I think it won't hurt as much as it could...
06:38:47 <shapr> because I don't think most people will be able to take advantage of even 8 cores
06:39:01 <shapr> Windows certainly won't handle that well
06:39:17 <goron> If that factor 1000 (2002 figure) is true, well, I don't think there's place for Intel.  
06:39:49 <shapr> very few programming languages can produce parallelized code.
06:40:27 <shapr> Anyway, AMD has just showcased a dual-core Opteron
06:40:41 <shapr> and Intel is making noise about their upcoming dual-core designs.
06:41:01 <shapr> hoi Jan_w 
06:41:27 <Jan_w> goddag shapr
06:42:03 <shapr> goron: I think the scientific Beowulf-using community will flock to this new design because most of their code is designed for it in the first place.
06:43:36 <shapr> goron: I'm still assuming the new design won't be a huge belly-flop :-)
06:43:40 <shapr> look at the Itanic
06:43:58 <Jan_w> shapr: is it ? does beowulf software gain much from just a dual core ?
06:44:38 <goron> :)
06:45:22 <Jan_w> I thought it was specicly for use on whole clusters ...
06:45:25 <shapr> the way they've described the Cell/Grid design, it's almost exactly like the MPI interface in hardware, so I think there would be a worthwhile improvement
06:45:40 <Jan_w> hm
06:45:41 <shapr> sure, but beowulf usually means either MPI or PVM
06:45:45 <tromp> shapr, where did you find cell specs?
06:46:00 <Jan_w> tromp read me mind
06:46:15 <shapr> tromp: no specs, just somewhat vague details. Most of what I found was on linux insider and the register
06:47:15 * shapr looks for the urls
06:47:24 <tromp> jan_w, ben je nou een jan of een john:-?
06:47:55 <Jan_w> jan
06:48:18 <tromp> irc zegt dat je john wanters heet
06:49:17 <Jan_w> well, jan is mostly reserved for females in english, tromp, so to avoid confusion :)
06:50:10 <tromp> ok, dus je gebruikt john als vertaling voor jan:)
06:50:20 <Jan_w> ja
06:50:29 <Jan_w> tromp: I noticed people become overly friendly when you just use Jan :)
06:50:38 <tromp> heh:P
06:50:39 <Maddas> phubuh: Heh, yeah, OpenTTD is nifty. Pizza Tycoon really did rule :-)
06:51:33 <tromp> funny that ibm has two processors aimed at massive parrallellism
06:51:47 <shapr> http://www.linuxinsider.com/story/34548.html http://www.linuxinsider.com/story/34707.html http://www.linuxinsider.com/story/34885.html 
06:51:49 <tromp> cell and the bluegene powerpc
06:51:55 <shapr> http://www.theregister.co.uk/2004/09/15/cell_tapeout/
06:52:28 <shapr> I found some other stuff too, but I forget where...
06:54:25 <Maddas> Looks very interesting
06:54:32 <shapr> volume production of Cell expected in the first half of 2005
06:54:46 <shapr> the advertising has me interested, I hope the product is everything they say it will be.
06:54:55 <tromp> i'm not holding my breath:)
06:55:07 <shapr> I think it's the right approach
06:55:52 <shapr> well, one good approach
06:57:25 <tromp> hmm, they talk of Cell as being Powerpc derived
06:58:03 <tromp> so much for thinking it was gonna be radically new architecture
06:58:39 <tromp> or is the powerpc a controller for cell cores?
06:59:11 * Jan_w has more or less found a bug (I think) in the ghc compiler, check out http://rafb.net/paste/results/2mZlhb81.html for an example
07:00:21 <tromp> they also mention security and bandwidth limitations of the x86 architecture?!
07:00:47 <shapr> Jan_w: I can't tell, you could post to ghc-users and ask them.
07:01:17 <Jan_w> shapr: where do I find more ghc users ? not here?
07:01:31 <goron> Jan_w: Not found
07:01:37 <TheHunter> Jan_w: be sure to compile this with an -O (better O2) switch, so that tail recursion gets optimized
07:02:10 <Jan_w> ok
07:02:10 <TheHunter> you might also need to add strictness annotations
07:02:14 <goron> Jan_w: Could you post the right link?
07:02:38 <goron> Never mind
07:02:40 <Jan_w> goron: it is the right link ?
07:02:41 <Jan_w> :)
07:02:42 * shapr wonders if #haskell.nl is needed for dutch-only discussions :-)
07:03:20 <goron> shapr: Don't think so. There are like 5 people in #haskell @ max that are Dutch.
07:03:20 * Jan_w doesn't really think so?
07:04:11 <tromp> i rather chat in english anyway:)
07:04:32 <tromp> jan, did you try making encr1/decr1 functions strict?
07:04:52 <Jan_w> tromp: how do you mean ?
07:04:54 <tromp> maybe 140000 causes memory problems
07:05:11 <Jan_w> That's what i think ...
07:05:17 <tromp> because of the d-k-k-k-k...
07:05:36 <Jan_w> tromp: yea, could be
07:06:00 <Jan_w> How would making the functions strict (how do i do that) solve anything ?
07:06:20 <tromp> d-k would be evaluated right away
07:06:30 <TheHunter> Jan_w: strictness analysis appears to do the job, just compile it with -O2
07:06:45 <tromp> avoids a  d-k-k-k-k... expression of length 140000
07:06:58 <Jan_w> hm testen
07:07:01 <Jan_w> testing :)
07:07:47 <tromp> maybe haskell should just evaluate arithmetic expressions by default?
07:08:20 <tromp> at least for Ints
07:13:15 <thebug> then it's not lazy evaluation ... ?
07:15:15 <shapr> Lunar^: does hOp need anything more than a filesystem for self-hosting?
07:15:55 <bourbaki> TheHunter: can you tell me why [0,1] is compact? i mean which open set of it contains 0 and 1?
07:16:21 <Lunar^> shapr: Assembler
07:16:24 <Lunar^> shapr: Linker
07:16:38 <shapr> hm
07:16:55 <shapr> I've never written either of those.
07:16:55 <Lunar^> shapr: For the assembler, I stumbled around this recently : www.tortall.net/projects/yasm/
07:17:18 <Lunar^> shapr: which has a C libyasm, which we could link with
07:17:57 <shapr> ok, how hard to write a linker?
07:17:58 <TheHunter> bourbaki: [0,1] is (of course) open in itself
07:18:07 <shapr> a linker doesn't sound complicated...
07:18:17 <shapr> greetings CosmicRay 
07:18:29 <shapr> CosmicRay: is Ray your middle name?
07:19:04 <Lunar^> shapr: Maybe we don't really need it, or walk around
07:19:13 <Lunar^> shapr: Look at Linker.c in the rts
07:19:22 <bourbaki> TheHunter: ? why is that i mean can you build an openball around 0 and 1?
07:20:18 <tromp> lazy is only useful in delaying nontrivial amount of work
07:20:31 <tromp> delaying or avoiding
07:20:36 <CosmicRay> shapr: nope.  I just like the electromagnetic spectrim.  x rays seemed boring, gamma rays odd, so I chose cosmic rays.
07:20:40 <CosmicRay> but the nick was too long
07:20:42 <CosmicRay> so the s was dropped
07:20:52 <shapr> freenode allows longer nicks
07:21:06 <CosmicRay> yeah but freenode did not exist in 1995 :-)
07:21:08 <kosmikus> bourbaki: every set is open and closed relative to itself
07:21:25 * CosmicRay changes servers...
07:21:31 <bourbaki> kosmikus: ok with this definition every topology is compact
07:21:59 <TheHunter> bourbaki: a set U is open in [0,1] (that is we consider [0,1] as our topological space) iff there is an open subset V of R such that V \union [0,1] = U
07:23:13 <kosmikus> bourbaki: what?
07:26:41 <CosmicRay> much better.
07:26:52 <CosmicRay> maybe.
07:27:26 <bourbaki> TheHunter: so [0,0.5] is open in [0,1] ?
07:27:45 <TheHunter> bourbaki: no
07:27:56 <TheHunter> [0, 0.5) is
07:29:23 <shapr> who's this schreur guy at nijmegen? I like his style.
07:29:41 <CosmicRay> bah
07:29:47 <CosmicRay> hate lag
07:30:03 <shapr> ping6 CosmicRay :-P
07:30:08 <CosmicRay> :-)
07:30:14 <CosmicRay> yeah, ipv4 sux0rs :-)
07:30:28 <shapr> oh hey, schreur is unicyclist also.
07:30:33 <CosmicRay> am I correct that hugs does not support cpp?
07:30:45 <shapr> along with Henry Baker and François Pinard
07:31:00 * goron just build wxHaskell. 
07:31:03 <shapr> What's the connection between unicyclists and programmers? 
07:31:12 <shapr> goron: oh, are you using the wxHaskell debs?
07:31:20 <goron> shapr: No
07:31:29 <goron> shapr: They didn't work. 
07:31:34 <shapr> oh really?
07:31:40 <goron> Good source >> binary. 
07:31:40 <shapr> do you have demo code that didn't work?
07:31:57 <goron> No
07:32:24 <goron> It was some time ago. SyntaxNinja's packages. 
07:33:00 <goron> Compiling it isn't that bad on my machine :-)
07:33:18 <shapr> sure, but updating it everytime the ghc6 debs gets updated will be...
07:33:22 <shapr> that was my experience, at least
07:33:52 <CosmicRay> shapr: don't you mean everytime ghc6 gets updted?
07:34:05 <CosmicRay> shapr: a new debian build of the same version of ghc6 shouldn't cause any trouble
07:34:05 <bourbaki> TheHunter: so every set that contains a boundary and is not closed on "the other side" is open in all topologies?
07:34:10 <CosmicRay> shapr: I hope
07:34:20 <shapr> won't it eat the custom package.conf entries?
07:34:42 <shapr> hiya mornfall 
07:35:00 <kosmikus> bourbaki: are you talking about intervals now, or about sets? "other side" doesn't make sense for sets
07:35:03 <TheHunter> bourbaki: if you consider the subspace induced by a (closed) interval, then yes
07:35:43 <bourbaki> kosmikus: thats what the "" are for ;)
07:35:56 <mornfall> hey shapr 
07:36:41 <goron> shapr: Do you know why every lib has to be rebuild when you undate ghc? I know it as a fact, but the exact reason behind it is unclear. 
07:36:45 <kosmikus> bourbaki: I still don't really understand you sentence, but if TheHunter does, then fine ...
07:37:18 <shapr> goron: no, I do not. I've never investigated.
07:37:22 <bourbaki> im still not sure why i can take open sets of 
07:37:25 <Lunar^> shapr: still no answer from Thomas, btw
07:37:32 <bourbaki> |R to build [0,1]
07:37:55 <shapr> Lunar^: well, I put my request on the end of a Fudgets bug report, so I was extrasneaky.
07:38:08 <Lunar^> shapr: About, what ?
07:38:13 <kosmikus> bourbaki: no, you are taking open sets which are open in [0,1]
07:38:23 <shapr> Fudgets, Thomas Hallgren's thesis at chalmers
07:38:35 <kosmikus> bourbaki: "open" is a relative property, something can be open in the whole space, or w.r.t. some subspace
07:38:35 <goron> The contrib opengl example is broken :( 
07:38:41 <bourbaki> kosmikus: but [0,.5) is not really open in [0,1]
07:38:46 <shapr> Fudgets are vaguely like Gui Yampa bits or something.
07:38:49 <kosmikus> bourbaki: yes, it is
07:39:03 <bourbaki> kosmikus: but there is no open ball for 0 in [0,1]
07:39:19 <kosmikus> bourbaki: there does not have to be one
07:39:28 <shapr> Lunar^: anyway, he told me he's waiting for Rob Noble's permission for Gadgets
07:39:35 <bourbaki> kosmikus: ? but thats what all books and links i know say
07:39:57 <bourbaki> a set is open if for every element in that set there is an open ball within that set
07:40:23 <kosmikus> ah sorry
07:40:26 <TheHunter> bourbaki: they only talk aobut the topology of |R^n then
07:40:32 <shapr> goron: oh, debian-haskell mailing list discussion said that wxHaskell should really be two libraries, and the OpenGL part should be separate.
07:40:36 <shapr> I forget the details though.
07:40:46 <bourbaki> TheHunter: they talk about metric spaces
07:40:54 <goron> shapr: I compiled it myself *with* opengl. 
07:41:25 <bourbaki> TheHunter: but i still dont see how that goes together with what you said
07:41:37 <shapr> goron: as long as the .hi file numbers don't change, a package should not need to be rebuilt, so 6.2 to 6.2.1 change .hi file numbers from 6200 to 6210, but ghc6-4 to ghc6-5 should not require a rebuild
07:41:40 <Lunar^> shapr: ok, cool
07:41:46 <bourbaki> TheHunter: cause then 0 and 1 dont have open balls
07:41:55 <Lunar^> shapr: That must be why his delaying his answer
07:42:06 <shapr> probably so
07:42:09 <tuomov> an open ball around a point x within a set S is those points in S that are less than some r distant from x
07:42:19 <shapr> Thomas wrote an InternetLib for Fudgets that does much cool stuff
07:42:22 <TheHunter> bourbaki: then an open ball around 0 is something like [0,0.1)
07:42:30 <tuomov> so B(0, 0.5) in [0, 1] is [0, 0.5)
07:42:49 <goron> shapr: And where can I find this "file number"?
07:43:14 <bourbaki> TheHunter: but thats not really a ball is it?
07:43:26 <kosmikus> yes, tuomov explained it well, I think
07:43:30 <bourbaki> TheHunter: thatd be a hemisphere
07:43:34 <TheHunter> bourbaki: by definition, it's a ball
07:43:45 <tuomov> forget about geometrical balls when you're talking about topology
07:44:10 <tuomov> you can have metric balls around a function as well and so on
07:44:20 <shapr> goron: you can always do "less foo.hi"
07:44:29 <shapr> there's probably a simpler way though...
07:44:47 <bourbaki> i always thought that a ball has an extention in all possible "directions"
07:44:53 <shapr> my foo.hi has 6021 in it
07:45:01 <goron> I get all kinds of errors like this:ByeDemo.o(.text+0x3c): first defined here
07:45:02 <goron> Paint.o(.text+0x144c): In function `Main_gui_srt':
07:45:18 <kosmikus> bourbaki: well, in this case, there is only one possible direction, then ...
07:45:21 <shapr> Igloo: what's the second digit for?
07:45:32 * shapr tries to remember the number for 5.04.2
07:45:51 * goron thinks that enables NSA mode.
07:45:52 <shapr> the ByeDemo actually works for me
07:45:56 <shapr> :-)
07:46:04 <TheHunter> bourbaki: a ball can even be one single point (for example 0 in {0,1} \subset |R)
07:46:19 <Igloo> In case we get to 6.10 presumably. Or maybe just for consistency
07:46:30 * Igloo isn't sure 5.x actually had a number in the hi file
07:46:43 <bourbaki> TheHunter: a ball has to have a radius so a point cant be a ball
07:46:43 <shapr> but, wouldn't consistency mean that 6021 is version 60.21?
07:46:56 <shapr> or that this version is really 6.0.2.1 ?
07:47:09 <kosmikus> bourbaki: you're mixing your view of the real world with mathematical definitions
07:47:18 <bourbaki> and a radius forces an extention in all "directions"
07:47:19 <TheHunter> bourbaki: take a look at the definition of "ball" in one of your topology books
07:47:30 <bourbaki> http://planetmath.org/encyclopedia/Ball.html
07:47:39 <tuomov> bourbaki: take all the points in {0, 1} at at most radius .5 from 0
07:47:44 <tuomov> what do you get?
07:47:48 <goron> shapr: Now it works (the byedemo). 
07:48:07 <bourbaki> tuomov: not an open ball at least
07:48:14 <shapr> goron: yay! what happen?
07:48:17 <tuomov> it is open in that discrete topology
07:48:41 <tromp> @index \\
07:48:43 <lambdabot> Data.List,List
07:48:43 <tuomov> forget the topology and geometry of R^n when you're dealing with general metric spaces
07:48:44 <goron> shapr: First I used globbing. 
07:48:45 <bourbaki> tuomov: but 0, 1 is continious isnt it?
07:48:53 <goron> shapr: Now I didn't.
07:48:56 <tuomov> {0, 1} = the two points 0 and 1
07:49:03 <bourbaki> ah ok sry
07:49:07 <tromp> @commands
07:49:08 <lambdabot> Sorry, I don't know the command "commands", try "lambdabot: @listcommands
07:49:13 <tromp> @listcommands
07:49:13 <goron> shapr: Not that it should make any difference. 
07:49:14 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
07:49:14 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
07:49:14 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
07:49:14 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
07:49:14 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
07:49:14 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
07:49:16 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
07:49:19 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
07:49:20 <TheHunter> bourbaki: the definition doesn't imply that a ball has a well-defined radius
07:49:20 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
07:49:32 <bourbaki> TheHunter: but it says r > 0
07:49:37 <tromp> @get-definition List.\\
07:49:38 <lambdabot> List.\\ not defined
07:49:43 <tromp> @get-definition List.(\\)
07:49:44 <lambdabot> List.(\\) not defined
07:49:51 <kosmikus> bourbaki: r was 0.5 in the example
07:50:03 <shapr> used globbing where?
07:50:04 <tromp> @get-definition Data.List.\\
07:50:05 <lambdabot> Data.List.\\ not defined
07:50:10 <TheHunter> bourbaki: but a radius of 0.25 amouts to the same ball
07:50:10 <tromp> @get-definition Data.List.(\\)
07:50:11 <lambdabot> Data.List.(\\) not defined
07:50:14 <Igloo> shapr: Huh? 6021 -> 6.(0)2.1
07:50:21 <bourbaki> kosmikus: yes i see what you try to say but as i see it it has to contain all the points in order to be a proper ball
07:50:23 <shapr> Igloo: oh
07:50:44 <shapr> tromp: get-definition is part of the Eval lambda calculus interpreter
07:50:53 <shapr> @get-definition fst
07:50:54 <lambdabot> fst = \p.p const
07:50:55 <bourbaki> TheHunter: yes but with that definition a point cant be a ball since a point is a ball with r = 0
07:51:14 <goron> shapr:  ghc -package wx -o *.hs
07:51:31 <shapr> tromp: @type, @index, and @info work with 'real' Haskell... and there was a new command I was thinking about, but I've forgotten what it was...
07:51:42 <tuomov> a point is not an open set in the standard topology of R^n
07:51:50 <kosmikus> bourbaki: not if you take X to be {0,1}, as TheHunter did
07:51:51 <tuomov> but a point is an open set in a discrete topology
07:51:52 <shapr> oh, I think was just that, @get-definition that worked on the Hugs sources
07:52:04 <shapr> with a better name...
07:52:21 <tuomov> and with finite sets, all you can have is discrete topology
07:53:15 <bourbaki> tuomov: discrete topology ? afaik you always have to trick in continouity to get topology of discreet stuff like a graph ie
07:53:44 <tuomov> d(x, y) = 1 if x=y, 0 otherwise
07:53:48 <tuomov> sigh
07:53:57 <tuomov> d(x, y) = 0 if x=y, 1 otherwise
07:54:06 <bourbaki> :)
07:54:09 <bourbaki> yes
07:54:10 <tuomov> that's your discrete metric for an arbitrary set
07:54:10 <goron> Don't I need to give another package to ghc when I want to compile the opengl sample?
07:54:23 <tuomov> now take B(x, r)={y|d(x,y)<r}
07:54:34 <shapr> goron: possibly, there are two wxHaskell packages
07:54:38 <shapr> wx and wxcore I think
07:54:39 <tuomov> that's the definition of an open ball in a metric space
07:54:54 <tuomov> (r>0)
07:55:46 <bourbaki> ok so what you tell me is that if its not a point its always an open set?
07:56:12 <tuomov> no
07:56:19 <bourbaki> that is every element on boundary that is connected to something has a ball
07:56:22 <tuomov> the complement of an open set is always closed
07:56:26 <Jan_w> well -O2 solved the problem in my simplyfied example indeed..., but in the actually algorithm (a DES implementation from the Haskell Cryptographic Library 1.2.2) the problem remains..
07:57:00 <tuomov> the open sets in a metric space are the open balls and arbirary unions and finite intersections of them
07:57:11 <tuomov> and what the open balls are depends on the metric
07:57:11 <tromp> @info \\
07:57:20 <tromp> @index (\\)
07:57:20 <tuomov> different metrics give different topologies and thus different open sets
07:57:21 <shapr> needs parens
07:57:21 <lambdabot> bzzt
07:57:28 <shapr> er..
07:57:30 <Jan_w> TheHunter: Now, i'v gone from thinking a had something to well, not understanding it anymore :)
07:57:39 <bourbaki> tuomov: yes but they dont habe to contain all elements of the ball to be a ball a hemisphere is also an open ball?
07:57:50 <Jan_w> http://rafb.net/paste/results/lvbmdS87.html is the actual program (
07:58:01 <shapr> tromp: oh, the interface is inconsistent.... I need to fix that..
07:58:08 <tromp> ok:)
07:58:08 <shapr> @index //
07:58:09 <lambdabot> Data.Array.Base,Data.Array.Diff,Data.Array.IArray,Data.Array.Unboxed,Data
07:58:09 <lambdabot> Array,GHC.Arr,Array
07:58:11 <tuomov> bourbaki: forget your geometrical R^n notions of a ball, and just use the B(x, r) definition
07:58:18 <shapr> @type Data.Array.(//)
07:58:20 <lambdabot> bzzt
07:58:21 <bourbaki> tuomov: [0,.5) is an open ball in [0,1] right?
07:58:22 <tromp> @index \\\\
07:58:23 <lambdabot> bzzt
07:58:34 <shapr> the index command is just a string lookup in a FiniteMap
07:58:43 <tuomov> bourbaki: yes. 
07:58:46 <shapr> but type and info call into GHCi, and it wants parens
07:59:03 <tuomov> but you should not think in terms of hemispheres and such
07:59:06 <bourbaki> tuomov: that is what i am useing and to my understanding all points had to be included
07:59:14 <goron> shapr: I got it working :)
07:59:21 <tuomov> just take the abstract definition and be happy with it
07:59:28 <shapr> griits SiintacksNiinjah!
07:59:32 <SyntaxNinja> y0 shapr
07:59:32 <shapr> goron: yay!
07:59:51 <bourbaki> tuomov: if you have a metric a ball is always something has a perfect extent in all directions with the same radius i didnt know that it can be capped though
07:59:53 <tuomov> once you start dealing with balls in function spaces, you're completely lost if you must find your geometrical balls and hemispheres somehwere
08:00:10 <goron> shapr: The result is only a bit disappointing. A white screen.
08:00:25 <bourbaki> tuomov: i think in terms of neighbouring not r^n
08:00:38 <shapr> goron: what are you compiling? a standard example?
08:00:49 <shapr> if so, which one?
08:01:06 <goron> shapr: Yes, GLCanvas.hs
08:01:11 <shapr> I'll try it
08:01:24 <goron> ghc -package wx -package wxcore -package OpenGL -package HGL  -o gl GLCanvas.hs
08:01:28 <bourbaki> tuomov: that is what i thought is something like if you have a space of something and want a ball you have to go in each possible direction for exactly the same amount of emelemnts in order to get a ball
08:01:43 <bourbaki> tuomov: but that helps a lot if that isnt the case
08:02:11 <tuomov> in a sense it is
08:02:45 <tuomov> but there doesn't have to be any points anywhere
08:02:48 <bourbaki> tuomov: cause your B definition as i always saw it forces you to use all x that suffice the equation
08:03:08 <shapr> goron: 'ghc --make -package wx GLCanvas.hs' works for me, with the wxHaskell 0.8 debs, and also produces a lovely white window.
08:03:26 <tuomov> and there isn't necessarily any sense of direction that would make any sense
08:03:45 <bourbaki> tuomov: yes what i mean with direction is elements in neighbourhoods
08:04:04 <tuomov> say you have the discrete set {Red, Green, Blue}, and take the discrete metric to form a topology on them
08:04:08 <goron> shapr: It gives the same result at my place.
08:04:21 <shapr> well then, time to try some other demos
08:05:29 <bourbaki> tuomov: one last maybe dumb question
08:05:37 <TheHunter> Jan_w: getting something like JanW_stub.c:9: error: parse error before "jaxDecrypt" ?
08:05:51 * shapr builds Camels.hs
08:06:06 <tuomov> or you take the distance between two infinite strings to be the maximum of the distances of their elements
08:06:16 <bourbaki> tuomov: if you have B(c) = {x /in X | d(c,x) < r}
08:06:17 <tuomov> metrics aren't just limited to R^n
08:06:26 <goron> shapr: Camels works.
08:06:36 <Boegel> hello everyone
08:06:46 <bourbaki> tuomov: would you speak of a ball still if you miss one x where d(c,x) < r?
08:06:54 <bourbaki> tuomov: i know
08:07:06 <tuomov> it's a ball relative to the space under consideration
08:07:56 <shapr> goron: Camels works too
08:07:57 <tuomov> and every set in a metric space forms a new space that may have different open sets than the containing space
08:08:19 <bourbaki> tuomov: the only thing i have a problem with is that i cant understand why something that doesnt contain all these x's where d(c,x)<r is still a ball
08:08:21 <tuomov> depending on the type of the set we're considering
08:08:35 <kosmikus> bourbaki: of course, you have to take all x which are in X, and must not miss a single one; but X is a space which can look very different from R^n ...
08:08:38 <goron> shapr: And PaintDirect? I am using ghc-6.3 and it gives a name clash.
08:08:53 <tuomov> going back to your [0, 1], [0, 0.5) example
08:09:01 <bourbaki> yes
08:09:02 <tuomov> [0, 0.5) is _not_ an open set relative to R
08:09:05 <kosmikus> I'm leaving ... tuomov, TheHunter, bourbaki, have fun ;)
08:09:07 <tuomov> but it is an open set relative to [0, 1]
08:09:31 <bourbaki> tuomov: but its not a ball relative to [0,1] right?
08:09:40 <tuomov> yes it is
08:09:53 <bourbaki> well kosmikus just said something different
08:09:55 <shapr> goron: where's PaintDirect? I only have Paint
08:10:10 <tuomov> no he didn't
08:10:11 <kosmikus> bourbaki: no, I didn't ...
08:10:18 <shapr> oh, duh
08:10:31 <bourbaki> kosmikus said it has to contain all x's
08:10:42 <tuomov> in the space X under consideration
08:10:49 <goron> shapr: In contrib
08:10:50 <tuomov> X=[0, 1] in this case
08:10:54 <bourbaki> ah ok
08:11:11 <shapr> goron: I found it, I was being clueless
08:11:16 <shapr> goron: I get the same clash
08:12:00 <bourbaki> this then also makes it quite easy to prove the heine-borel theoreme
08:12:00 <CosmicRay> can anyone here help me with state monads?
08:12:08 <bourbaki> anyway sry for the hassle :)
08:12:26 <shapr> CosmicRay: there's like, Virginia, and you wrap it up in a function... and then A STATE MONAD!
08:12:29 <shapr> er wait.. PROFIT!
08:12:34 <shapr> yah, that's it
08:12:42 <CosmicRay> heh
08:12:42 <shapr> CosmicRay: but seriously...
08:12:54 <CosmicRay> all I need to do is essentially simulate a global variable
08:13:02 <CosmicRay> (I am implementing a syslog module)
08:13:07 <shapr> I'll give you the intro... a monad is a design pattern
08:13:17 <shapr> this design pattern consists of one type and two functions
08:13:19 <TheHunter> bourbaki: topologically, the heine-borel theorem _is_ the definition of compact
08:13:26 <shapr> this type is partially filled in
08:13:45 <bourbaki> TheHunter: it says that every bound topology is compact
08:13:58 <shapr> one of those two functions fills in the partially filled in type with a 'normal' type/value
08:14:08 <shapr> and the other function sticks together two of those filled in types.
08:14:15 <CosmicRay> hmm.
08:14:26 <CosmicRay> I'm not understanding this partially filled in thing
08:14:34 <shapr> I'm glad you asked :-)
08:15:01 <shapr> actually, you didn't .. 
08:15:02 <bourbaki> TheHunter: which is quite clear once you have a proper understanding of a ball ;)
08:15:03 <Igloo> Cos: Can you describe which bit you are stuck with?
08:15:03 <shapr> but I'll tell you anyway
08:15:17 <tuomov> no, the h-b theorem says that in a metric space compactness is equivalent to being closed and bounded
08:15:28 <CosmicRay> Igloo: this may seem unbelievable, but no.  I seem to be stuck with the whole thing :-)
08:15:30 <tuomov> but the real definition of compactness is in terms of open covers
08:15:43 <CosmicRay> I just want to be able to stick a value in, change it periodically, and read it periodically
08:16:03 <tuomov> there are other topological spaces besides metric ones
08:16:15 <TheHunter> bourbaki, tuomov: sorry, i thought heine borel was that pointless theorem you prove in analysis I
08:16:35 <Igloo> OK, your functions will all have type arg1 -> ... -> argn -> State Int a    for some type a (assuming your state is an Int)
08:17:22 <Igloo> You write code with the do notation like   do x <- get; put (x+1); return 5
08:17:40 <CosmicRay> that looks way too easy.
08:17:41 <Igloo> That would increment the state and return 5 (so a here might be Integer, the type of 5)
08:18:05 <tuomov> hmm. actually. closed&bounded is R^n only. for generic metric spaces the requirement is complete&totally bounded
08:18:10 <CosmicRay> all the tutorials on state monads show all sorts of mapping function crap and stuff
08:18:19 <shapr> CosmicRay: it's really easy actually...
08:18:20 <Igloo> At the outer level you'll want either runState, evalState or execState depending on what you want to get out at the end
08:18:28 <CosmicRay> shapr: where are get and put defined?  are they in the prelude?
08:18:36 <Igloo> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.State.html
08:18:39 <bourbaki> tuomov: totally bounded?
08:18:40 <CosmicRay> ah.
08:18:43 <CosmicRay> ok I have been looking there.
08:18:56 <CosmicRay> Igloo: ok, I don't get the runState, evalState, etc. thing
08:19:10 <bourbaki> tuomov: complete does mean what in general?
08:19:14 <Igloo> OK, suppose foo is the function I wrote above
08:19:21 <tuomov> bourbaki: rtfMathBook
08:19:21 <CosmicRay> right
08:19:30 <Igloo> evalState foo 1 == 5
08:19:34 <tuomov> too much to explain over irc
08:19:35 <Igloo> execState foo 1 == 2
08:19:38 <vegai> is the next version of ion going to written in Haskell? :)
08:19:47 * shapr can only hope
08:19:48 <Igloo> runState foo 1 == (5, 2)
08:20:20 <shapr> vegai: I've heard that the "Persuade tuomov to write a Haskell Window Manager" Fund is open for business.
08:20:23 <bourbaki> tuomov: heh
08:20:41 <CosmicRay> so execState is discarding the return value and just giving me the internal stored state value?
08:20:50 <CosmicRay> while evalstate is showing the return value?
08:20:53 <Igloo> Yup
08:21:25 <SyntaxNinja> good morning, CosmicRay
08:21:38 <CosmicRay> ok, now is there a single monad used for that one function, or what happens if I have multiple State Int functions?
08:21:42 <CosmicRay> morning syntaxninja
08:21:47 <Igloo> If the tutorials are talking about liftM and suchlike then these are combinators that you will find make it easier to write clean code as you get used to them
08:22:05 <Igloo> StateT is a state transformer monad
08:22:05 * SyntaxNinja shamelessly points out that he wrote the documentation for Control.Monad.State
08:22:08 <SyntaxNinja> there are examples in the bottom
08:22:13 <shapr> vegai: we could send money to tuomov to fund his hedonistic lifestyle, that might work...
08:22:18 <Igloo> It takes a monad and gives you another one with some state
08:22:31 <CosmicRay> SyntaxNinja: I found them but I didn't understand it
08:22:53 <Igloo> So you might have   StateT Int (State Char) a
08:22:58 <shapr> CosmicRay: you gotta dig monads before you can really 'get it'
08:23:03 <shapr> but you don't gotta dig monads to use it.
08:23:15 <Igloo> Here get and put x work on the Int, lift get and lift $ put x work on the Char
08:23:19 <CosmicRay> SyntaxNinja: what would halp me would be three examples: "Here's how you initialize it", "Here's how you modify it", and "Here's how you read it"
08:23:27 <vegai> shapr: would that be the first Haskell WM, btw?
08:23:33 <shapr> I think so
08:24:00 <shapr> there's Alistair Reid's HSX11 bindings, but no idea if anyone has done a WM with them.
08:24:00 <SyntaxNinja> CosmicRay: evalState and runState are how you initialize it :)
08:24:08 <SyntaxNinja> CosmicRay: patches always welcome
08:24:12 <shapr> I know andersca was considering it at one point.
08:24:21 <CosmicRay> SyntaxNinja: ok :-)
08:40:07 <goron> Lunar^: hOp does not build. utils/Panic.lhs:127:21:  
08:40:09 <goron>     Couldn't match `TypeRep' against `TyCon
08:43:48 <goron> http://www.toolshed.com/blog Sweet revenche on tele.. :-)
08:50:44 <shapr> CosmicRay: when you have time and interest, I can point you to all the good monad tutorials and answer any questions
08:51:47 <shapr> gutenabend pesco 
08:51:56 <pesco> Hello shapr!
08:52:38 <shapr> pesco: how's code?
08:52:39 <pesco> Wow, I just noticed my UTF-8 codec is used by darcs. :)
08:52:46 <shapr> ohcool!
08:53:06 <shapr> greetz stepcut 
08:53:21 <goron> shapr: Do you know House? 
08:53:45 <shapr> somewhat, why?
08:53:54 <pesco> Apart from that, I'm going to put out a minor revision of Pesco.Cmdline tonight. After some insightful input from Alastair Reid.
08:53:59 <CosmicRay> shapr: monad tutorials would be excellent
08:54:06 <goron> shapr: Well, you were talking about hOp. 
08:54:23 <goron> shapr: And House has a PS2 driver.
08:54:30 <shapr> and a linear framebuffer
08:54:40 <shapr> and a separate process space
08:55:57 <stepcut> pesco: does your command-line argument library handle reusing flags in different contexts, for example, cvs -d :ext:jeremy@src.lindows.com co -d project os/deeply/nested/project  ??
08:56:18 <goron> shapr: Yes, I know, but I was too lazy to type it all.
08:56:46 <stepcut> greetz shapr
08:57:15 <pesco> stepcut: No.
08:57:57 <stepcut> :(
08:58:41 <shapr> goron: where'd you learn about House?
08:59:57 <shapr> were you at HW2004?
09:00:28 <goron> shapr: No, just visited the website.
09:00:33 <shapr> ah, ok
09:00:52 <shapr> have you tried the house floppy image?
09:01:00 <bbls> hello
09:01:03 <bbls> hi shammah
09:01:10 * shapr looks at shammah 
09:01:11 <bbls> sorry :) shapr :)
09:01:12 <goron> shapr: I don't possess the ability to be invisible, yet. :)
09:01:17 <goron> shapr: No
09:01:32 <bbls> shapr i have a question
09:01:39 <shapr> goron: http://www.cse.ogi.edu/~hallgren/House/
09:01:44 <bbls> shapr how are applications implemented?
09:01:44 <shapr> sexy screenshots too
09:01:56 <shapr> bbls: there's a very large answer to that question.
09:02:02 <shapr> I suggest you limit your problem space.
09:02:26 <bbls> well, how house applications respond to used events (mouse move, key press, etc)
09:02:28 <shapr> do you mean, how are Haskell apps implemented? or what?
09:02:35 <shapr> oh for House
09:02:39 <bbls> or they use a different model?
09:02:43 <bbls> (i/o model)
09:03:02 <shapr> it uses the GHC RTS scheduler, and some sexy interrupt code that Lunar^ wrote
09:03:32 <shapr> I don't know how House is different from hOp, because House source is not yet available.
09:03:38 <bbls> ah
09:03:50 <bbls> i was going to ask you about house source :)
09:03:53 <bbls> what is hOp?
09:04:24 <shapr> http://lambda-the-ultimate.org/node/view/299
09:04:36 <goron> I also wanted to see the source of a *working* Haskell Operating System (I don't care how it's called).
09:04:40 <shapr> I should probably have given more info...
09:04:48 <shapr> hOp does work
09:04:52 <shapr> I've built it several times.
09:05:03 <pesco> (Cool, GADTs in GHC.)
09:05:25 <goron> shapr: I think the RTS code has changed. 
09:05:59 <shapr> the hOp build script used to pull a specific version of the GHC source package, 6.0 I think
09:06:01 <shapr> or 6.0.1
09:06:20 <goron> shapr: Now it's 6.2
09:06:28 <shapr> House is 6.2 ?
09:06:38 <goron> shapr: No hOp.
09:06:53 <shapr> are you sure?
09:07:04 <goron> Yes
09:07:07 <shapr> huh
09:07:16 <shapr> I'll have to look into that.
09:07:19 <goron> I am gone.
09:07:28 <shapr> gone home?
09:07:52 <shapr> bbls: anyway, download the House floppy image and try the apps, it's fun.
09:08:05 <shapr> I succeeded in locking up QEmu with explode :-)
09:14:06 <CosmicRay> can something defined with "type" -- as opposed to something defined with "data" -- qualify for an instance of a type class?
09:14:44 <Igloo> No
09:14:54 <shapr> can't it now with ghc 6.2 ?
09:14:58 <Igloo> newtype is probably what you want
09:15:01 <shapr> or is that deriving I'm thinking of?
09:15:12 <shapr> I thought that changed somehow in the most recent version
09:15:39 <Igloo> You can probably put the symonym in the instance head with extensions, but that's no use if there is already an instance for the type
09:18:16 <pesco> shapr: Maybe you're thinking of the GHC extension of "liberal type synonyms" which basically treats type synonyms like macros?
09:18:27 <shapr> maybe so...
09:18:41 <CosmicRay> ok.
09:19:02 <CosmicRay> just some extra keyboarding for the "data" thing then :-)
09:19:33 <Igloo> You probably want newtype - it has less overhead
09:19:49 <pesco> less=none?
09:19:57 <shapr> CosmicRay: my favorite monads tutorials: http://www.nomaware.com/monads/html/index.html, http://www.haskell.org/hawiki/MonadsAsContainers, and http://www.cs.fit.edu/~satkin/monads.html
09:20:13 <Igloo> Well, yes  :-)
09:21:00 <pesco> :) Ok. Newtypes never leave the typechecker, right?
09:21:27 <Igloo> Right
09:21:37 <CosmicRay> thanks shapr
09:22:25 <shapr> CosmicRay: plus I can give you the country-fried explanation of monads, which compares them to OOP and a bunch of other unexpected things.
09:22:51 <pesco> Oh, which reminds me. Does GHC use a "dictionary passing implementation" for type classes?
09:23:10 <Igloo> Yes
09:23:18 <musasabi> related to that how would one combine Either and IO in a nice way?
09:23:40 <pesco> Igloo: Can you explain in quick and general terms how that works?
09:23:42 <stepcut> pesco: there are some whitepapers about that. I think sometimes it does, but other times it can optimize the out ??!?
09:24:07 <Igloo> Not now, sorry. There might be something in the GHC commentary or something?
09:24:13 <pesco> Oh, ok.
09:24:22 <pesco> I'll look for one of the papers then.
09:24:26 <musasabi> currently the code is full of val <- comp; case val of Left x -> ...
09:24:50 <shapr> can you liftM fromLeft ?
09:25:31 <musasabi> pesco: I think it works with passing the function an array/struct of function pointers (in C terminology)
09:26:34 <pesco> Hm. Yes.
09:27:32 <pesco> Then that will be as efficient as virtual function calls in C++, right?
09:27:37 <goron> shapr: Checked it?
09:27:56 <musasabi> pesco: that is different from C++ virtual functions.
09:28:10 <musasabi> shapr: fromLeft?
09:29:19 <pesco> musasabi: But such an array of function pointers would be like a C++ vtable, wouldn't it? Just that it's passed from function to function, following the class context, instead of being attached to an "object".
09:30:12 <musasabi> pesco: yes, but the performance characteriscs are obviously different.
09:30:45 <pesco> Hm, I don't see that, please explain.
09:31:57 <shapr> goron: if you mean checking hOp to see if it's 6.2 and whether it builds with 6.0; no, not yet.
09:32:19 <shapr> musasabi: er, fromLeft is in the GenUtil.hs file of ginsu, John Meacham's chat client
09:32:37 <shapr> that whole file should go into PreludeExts/MissingH
09:32:43 <Lunar^> goron: The EuroHaskell release build, at least on my Debian Sarge
09:33:24 <Lunar^> goron: I've got to go now, but maybe we could check what's wrong later
09:34:25 <musasabi> pesco: stack pressure and the number of indirections.
09:36:01 <pesco> Ok, I think I should read one of the papers some time.
09:39:45 <musasabi> pesco: well most of the time it is not so significant that you would need to care about it.
09:40:03 <musasabi> (>>>=) :: IO (Either l r) -> (r -> IO (Either l r2)) -> IO (Either l r2) seems to work
09:43:52 <bbls> hi ski
09:44:08 <ski> hello bbls
09:44:12 <bbls> how are you? :)
09:44:18 <ski> fine,ty
09:46:35 <CosmicRay> ok I'm looking at classes in haskell and wonder if it has a notion of inheritance
09:46:44 <CosmicRay> I have this:
09:46:47 <CosmicRay> instance LogHandler StreamHandler where
09:46:48 <CosmicRay>     setLevel (StreamHandler (h, pri)) newpri = StreamHandler (h, newpri)
09:46:48 <CosmicRay>     getLevel (StreamHandler (h, pri)) = pri
09:46:48 <CosmicRay>     emit (StreamHandler(h, pri)) (pri2, msg) = hPutStrLn h msg
09:46:48 <CosmicRay>     close _ = return ()
09:47:07 <CosmicRay> now what I'm wondering is if I can define something else identical to this in every way except that close does something different
09:47:58 <ski> (that would be overriding)
09:48:29 <ski> what do you mean by "define something else identical ..." ?
09:49:20 <shapr> typeclasses in Haskell work like interfaces in Java
09:49:51 <shapr> usually you're defining a single operation that will have different implementations on different types
09:49:51 <shapr> or at least a set of operations
09:50:09 <shapr> == is defined different for Int than for Char
09:50:34 <shapr> CosmicRay: typeclasses example here - http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:51:22 <ski> do you want another type class ?
09:51:33 <ski> same type class, but for different type ?
09:51:51 <ski> same type class, same type ?  (with different "close" as you said)
10:01:31 * shapr sings the spam song
10:01:56 <shapr> Lunar^: Non-stop Haskell might be really handy for hOp
10:04:10 <CosmicRay> in the OO world I would inherit from StreamHandler and simply redefine the method
10:04:11 <CosmicRay> but it seems that in haskell I would have to define a new type and duplicate all this code
10:04:11 <CosmicRay> is that correct?
10:04:32 <Philippa> or have the new type wrap the old type and delegate, but yeah
10:07:45 <shapr> CosmicRay: why don't you make a logging monad instead?
10:12:15 <pesco> Wow, a logging monad. Mo monads!
10:12:56 <pesco> shapr: Why don't we make a mo monads contest?
10:14:11 <shapr> sounds cool tome
10:14:12 <shapr> to me
10:14:24 <shapr> but I ain't got off my ass to put up IOHCC results yet
10:14:55 <musasabi> I am combining IO and Error into "ErrorT String IO a", now how should I handle functions like "withFoo :: Foo -> (Ptr a -> IO b) -> IO b ". That is how will I lift them?
10:16:35 <shapr> CosmicRay: one view of monads is like subclassing function calls, so a monadic logger might make more sense in Haskell.
10:17:01 <esap> "subclassing function calls"?
10:17:18 <shapr> esap: you don't think so?
10:17:26 <esap> I don't know what that means.
10:17:35 <shapr> take the Maybe monad
10:17:42 <shapr> well, any monad
10:17:48 <shapr> you end up subclassing >>=
10:18:04 <shapr> with monad transformers you get 'multiple inheritance' too
10:18:51 <esap> Well >>= is not a function call, >>= is like composition.
10:18:55 <ski> cbv
10:19:10 <shapr> cbp
10:19:19 <shapr> call by phone ;-)
10:19:46 <esap> cbv and cbn are duals. Function application is dual to composition.
10:19:55 * esap thinks.
10:20:34 * esap doesn't know what is dual to cbp :-)
10:20:39 * shapr laughs
10:21:15 <shapr> probably call by gossip
10:21:51 <shapr> if you look at gossip as the dual of phones, as in, one is talking directly to the persond, and the other is an attempt to talk to everyone *except* the person.
10:24:01 <ski> call-by-handwaving ?
10:24:18 <stepcut`> :p
10:24:23 <pesco> call-by-smack-upside-the-head
10:25:06 <esap> one approach would be to think of a phone as a point-to-point link. A dual to that is a time-to-time link, hmm.. a recorder?
10:25:35 <shapr> or a diary/journal
10:27:01 <stepcut`> ok, I need to call a single c function from haskell, but it returns a struct, so I need some sort of ffi preprocessor to access the members(?) of the struct. Which tool should I use ? (for ghc)
10:31:33 <TheHunter> esap: i'm with shapr: >>= is like reverse application, not like composition. if you're making the filinski transformation, application essentially becomes the same as =<<
10:33:31 <Jan_w> TheHunter: i'm back, you tried it compile it ?
10:34:01 <shapr> with absoluetly no theory behind it, I think >>= feels like a subclassable function call.
10:34:17 <shapr> I can tell it do any tricks I want
10:34:43 <shapr> usually it's used to build plumbing, hot and cold running values
10:35:10 <Philippa> shapr: not subclassable, just an interface for which you can supply an implementation
10:35:11 <Philippa> but yeah
10:35:26 <esap> TheHunter: Think of x >>= \a -> y a >>= \b -> z b
10:35:26 <TheHunter> Jan_w: yep, didn't work for some strange reason, maybe compiler bug
10:35:55 <esap> TheHunter: that looks like z . y . x
10:36:38 <TheHunter> esap: what about x # \a -> y a # \b -> z b where (#) = flip ($)
10:36:43 <ski> (f >@> g) ma = ma >>= \a -> f a >>= \b -> g b
10:36:49 <Jan_w> TheHunter: what do you mean? you got the same problem ? or just couldn't compile it ?
10:37:26 <TheHunter> Jan_w: I couldn't compile it (well a similar the non-dll-version because i'm running linux)
10:37:38 <shapr> but back to the point... how would you write a logging lib in Haskell?
10:38:00 <TheHunter> (f >@> g) = (=<<) g . f
10:38:16 <Jan_w> TheHunter: if i compile it in an executable, the problem does not occur
10:38:34 <TheHunter> Jan_w: what's your problem? space leak?
10:39:00 <Jan_w> TheHunter: how can i tell ? it just crashes
10:39:35 <Jan_w> it does not consume how memory, it crashes allmost instantly
10:39:51 <esap> TheHunter: I think what's confusing here is the fact that (.) and ($) are really close to each other in function.
10:40:05 <Jan_w> how=much
10:41:07 <TheHunter> esap: i agree, the difference between them is not very big
10:42:07 <TheHunter> Jan_w: compile it into a file and see if it uses too much memory. Perhaps profile it.
10:42:56 <Jan_w> TheHunter: can I use profiling on a dll ?
10:43:28 <esap> TheHunter: But consider ($!) and (.)
10:43:29 <TheHunter> Jan_w: dunno, but if it eats much memory in the dll, it does so in the executable, too
10:44:23 <bourbaki> Jan_w: which profiler do you use?
10:44:28 <Jan_w> TheHunter: the problem is, there's no problem when I create it as an executable, but i'm see how much mem it uses anyway
10:44:32 <Jan_w> bourbaki: i
10:44:47 <Jan_w> bourbaki: i've never used a profiler for haskell
10:45:07 <Jan_w> bourbaki: can you recommend one ?
10:45:09 <bourbaki> Jan_w: i thought you were useing one for windoze since you mentioned dlls
10:45:17 <shapr> whoa, flashback - http://www.oberon.ethz.ch/native/snaps/deskpict.jpg
10:45:17 <shapr> I remember booting Oberon for a few months long long ago when I just couldn't stand Windows anymore...
10:45:17 <shapr> maybe GHC is specializing the code differently when it's built into an exe?
10:45:31 <bourbaki> Jan_w: vtune is quite good and that amd profiler also cant recall the name
10:45:38 <shapr> if you know which bit of the code is causing problems, maybe you can use -ddump-simpl and look at the Core for clues?
10:46:10 <Jan_w> bourbaki: i'm using windoze, because i'm trying to create a .dll to load in a vc++ program :)
10:46:27 <Jan_w> bourbaki: i'll check out vtune
10:46:58 <bourbaki> Jan_w: with both you should be able to profile the dll when you compiled it with debug infromation when i recall correctly but it has been ages since i profiled anything
10:47:40 <bourbaki> Jan_w: the amd profiler is also quite good if yhou want a good profile id check them out both
10:47:51 <Jan_w> ack
10:48:02 <bourbaki> Jan_w: but vtune will do
10:48:13 <bourbaki> Jan_w: for mem leaks check out boundschecker
10:48:38 <bourbaki> Jan_w: and you might want to write your own mem manager if you are serious about mem leacks
10:48:57 * TheHunter just though of ghc -prof
10:49:26 <Jan_w> TheHunter: thats what i thought you ment, but how does that work ?
10:50:37 <Jan_w> bourbaki: for memleaks i use valgrind
10:51:13 <Jan_w> at least on linux, for windoze, i don't really have a good program for this
10:52:03 <TheHunter> i think it only works for executables. you compile with ghc -prof and then run the program with argument +RTS -p ...
10:52:30 <TheHunter> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:52:43 <pesco> I'm off, see you!
10:52:54 <Jan_w> TheHunter: that something worth checking out, even if it's not helpfull right now
10:53:51 <TheHunter> Jan_w: i'm pretty sure the code contains some space leak, i'd check (though i'm not very good at finding space leaks) but i just can't compile it for some weird reason
10:54:17 <Jan_w> TheHunter: what's the problem?
10:54:52 <Jan_w> TheHunter: i could remove the dll code if you like, so you can compile it as an exe ?
10:54:54 <TheHunter> the gcc produces a parse error
10:55:27 <TheHunter> Jan_w: i already did that. There's nothing in this code the compiler could be offended from
10:55:56 <Jan_w> could you echo your code back to me ?
10:58:02 <musasabi> Is there any monad transformer tutorial (besides the section nomaware and "Monad Transformers and Modular Interpreters") ?
10:58:43 <TheHunter> Jan_w: i didn't change anything. I Just removed the two foreign lines and added main = print $ jaxEncrypt 34923 34235
10:59:45 <Jan_w> TheHunter: and change the module name to main ?
10:59:53 <Jan_w> or is that not required?
11:00:46 <TheHunter> that's not required
11:04:11 <Jan_w> TheHunter: when I don't change the module name to Main, I get : /ghc/ghc-6.2.1/libHSrts.a(Main.o)(.text+0x87):Main.c: undefined reference to `__stginit_ZCMain'
11:04:43 <Jan_w> and something about a JaxCrypt_stub.c missing references
11:04:53 <TheHunter> hey, it compiles.
11:05:04 <Jan_w> TheHunter: *blush* :)
11:06:45 <Jan_w> hey, Stack space overflow: current size 1048576 bytes.
11:06:54 <Jan_w> I never had that before!
11:07:01 <Jan_w> cool
11:07:13 <Jan_w> at least there's an error :)
11:07:25 <TheHunter> did you compile with -O2?
11:07:33 <Jan_w> no
11:07:42 <Jan_w> yea, with the the dll
11:07:47 <Jan_w> but not just yet
11:08:10 <TheHunter> i don't see a space leak here.
11:08:23 <TheHunter> so it must be a windows-dll-problem :(
11:08:30 <Jan_w> hmm
11:08:43 <Jan_w> I was afraid you'd say that :)
11:09:51 <shapr> are you using --make ?
11:09:51 <shapr> try using ModuleName.o as the target
11:09:52 <shapr> or .dll or whatever
11:10:44 <Jan_w> shapr: how do you mean ?, i use: ghc -c -fglasgow-exts JaxCrypt.hs ;  ghc -c Cryptlib.c ; ghc --mk-dll -o Cryptlib.dll Cryptlib.o JaxCrypt_stub.o JaxCrypt.o 
11:13:23 <musasabi> Anyone willing to help with transformer troubles? or to point somewhere?
11:13:58 <Jan_w> shapr: i'll read the man about --make, see how that works
11:17:38 <Jan_w> shapr: hm, --make Source.hs is the syntax, how do you propose to use that to make the dll ?
11:20:27 <shapr> musasabi: the nomaware tutorial talks about monad transformers
11:20:29 <shapr> Jan_w: "undefined reference to `__stginit_ZCMain'" means GHC wants a Main.main function, and it shouldn't be wanting that with your args
11:20:32 <shapr> I dunno why it's saying that.
11:20:34 <shapr> maybe you need to put something in next to --mk-dll like -c ? maybe it assumes --make in the abscence of other args? not sure.
11:21:21 <musasabi> shapr: yes, I have read it. 
11:21:40 <Jan_w> well the "undefined reference to `__stginit_ZCMain" is not my problem.. that way TheHunters problem, but he solved it :)
11:22:09 <musasabi> Jan_w: do you have a module called main ? (or a file without a module declaration) ?
11:22:15 <Jan_w> no
11:22:27 <shapr> just that I think --make requires a Main.main, and -c probably doesn't
11:22:27 * shapr wanders around confusedly
11:22:58 <Jan_w> ok, thats fine 
11:23:32 <musasabi> --make works fine without a main.
11:23:50 <musasabi> try ghc --make SomeModule.hs 
11:24:53 <musasabi> shapr: my problem a functions like "withFoo :: Foo -> (Ptr a -> IO b) -> IO b"
11:25:42 <Jan_w> musasabi: well it does not know how to handle things like "foreign export stdcall jaxDecrypt :: Word64 -> Word64 -> Word64" when i use --make, and with -c it does
11:25:46 <musasabi> I would need to lift them to "withFoo' :: Foo -> (Ptr -> m (IO b)) -> m (IO b)" or something similar.
11:26:28 <TheHunter> musasabi: i guess that's impossible without redefining withFoo
11:29:56 <DenizzzZ> anyone from chalmers here ? :)
11:30:00 <CosmicRay> shapr: a logging monad?
11:31:11 <musasabi> redefining allocaArray seems nasty.
11:35:14 <ski> DenizzzZ : some of us, yeah
11:39:00 <Luke> shapr: howdy. have there been any posts on that mailing list? noticed that the archive exists not
11:40:05 <TheHunter> musasabi: i have no idea of this low-level stuff but if you can implement allocaArray in terms of mallocArray, then you can define the function allocaArrayM aka withFoo
11:41:17 <musasabi> GHC uses an optimizes representation (of course one could just do "bracket malloc free"
11:42:46 <shapr> Luke: y0 y0
11:43:01 <shapr> Luke: yes, two posts so far
11:43:18 <shapr> you should have gotten forcer's post at least
11:43:42 <Luke> nope
11:45:50 * shapr suspects lag
11:45:50 <shapr> Luke: I'll send a quick test post
11:45:51 <shapr> ok, I just sent a test post
11:46:29 <shapr> and received it too
11:48:41 <TheHunter> musasabi: i guess that's your only chance, then. (plus, i don't think you lose too much performance if you make the malloc and free explicit)
11:48:57 <Luke> hm, I didn't
11:49:05 <Luke> maybe hook up Gmane?
11:49:17 <Luke> (but - how come the archive doesn't work?)
11:50:20 <shapr> the archive won't be generated until the end of the first 'period'
11:50:27 <shapr> and I've set the period to be monthly
11:51:30 <shapr> btw, you and darius had the same reply problem, but other people didn't have that problem...
11:51:30 <shapr> very confusing
11:51:30 <shapr> this ipv6 lag is irritating...
11:52:42 <shapr> ah, that's better
11:53:02 <shapr> zero ping as compared to four minutes
11:53:09 <shapr> Luke: do you see the incoming mail at all?
11:56:13 <musasabi> TheHunter: thanks in any case.
12:02:44 <shapr> hm
12:04:09 <shapr> wonder what happened to Luke
12:04:42 <bourbaki> maybe he met vader
12:04:56 <shapr> oy
12:06:40 <bourbaki> i wonder if you can send a laser impulse through a fiber glass calbe or and a light saber 
12:58:43 <Lemmih> Infinity == 2^1024?
13:17:21 <mattam> i'd really like to know what the default >= code is in Ord
13:24:04 <TheHunter> if you're using hugs, you can find the source under /usr/lib/hugs/libraries/hugs/Prelude.hs, if you're using ghc under debian and have ghc-libsrc installed, then the source is somewhere below /usr/share/doc/ghc6-libsrc/
13:26:18 <mattam> ghc, i could unpack the source (gentoo) but maybe someone knows ?
13:26:49 <TheHunter> mattam: look at the hugs Prelude (should be pretty much the same)
13:32:20 <mattam> i got stack overflows with the ghc one, on very small Integer's :)
13:33:01 <mattam> there's something bizarre happening
13:33:13 <mattam> the default is:     x >= y = case compare x y of { LT -> False; _other -> True }
13:33:53 <mattam> my original declaration was: newtype Natural = MakeNatural Integer deriving (Eq)
13:33:57 <mattam> (Eq,Ord)
13:34:23 <mattam> and i just defined instance Ord Natural where
13:34:23 <mattam>   (MakeNatural x) < (MakeNatural y) = x < y
13:35:18 <mattam> using, this, when i compared two Naturals i got overflows, but adding   (MakeNatural x) >= (MakeNatural y) = x >= y made the overflows disappear
13:36:09 <mattam> could someone try to reproduce it ?
13:48:57 <TheHunter> mattam: the comment in the prelude says:     -- Minimal complete definition: (<=) or compare
13:49:20 <TheHunter> so you have to implement either <= or compare, the rest will be done automatically
13:50:00 <mattam> thats what i did... not!
13:51:39 <mattam> ghc could have warned me i hadn't defined <= but < no ?
13:52:31 <TheHunter> ghc normally warns but in this case a definition of (<=) in terms of compare AND a definition of compare in terms of (<=) are provided, so both call themselves again and again
13:55:21 <Igloo> Did you have -Wall on? It ought to warn you
13:55:47 <mattam> i'll try with -Wall
13:55:50 <Igloo> Oh, hmm, actually I guess not given there is a mutually recursive definition
13:57:05 <mattam> indeed
14:36:46 <shapr> SyntaxNinja: what's Cabal compatability importance order?
14:39:37 <SyntaxNinja> as far as compilers?
14:40:03 <SyntaxNinja> ooh, aj is here
14:40:30 <shapr> Cabal mostly works with ghc6, what do you want next? ghc5? nhc? hugs?
14:41:06 <SyntaxNinja> shapr: well, the way I see it, basically, is that, if I do it, it'll be Hugs.  Hopefully, if someone else thinks hugs and / or nhc is important, then they will do it. I don't use all platforms, so I'm relying on contributions.
14:41:20 <SyntaxNinja> but I will focus on what I use, which is ghc and debian
14:42:44 <Igloo> I would say ghc6, hugs, nhc98, ghc5 is the order of importance, but ghc5 would probably be the easiest to do
14:43:00 <SyntaxNinja> yeah
14:44:30 <SyntaxNinja> but for me, preprocessors take priority over other compilers... I'm keen to get an end-to-end solution out the door
14:44:48 <shapr> preprocessor stuff isn't finished?
14:45:00 <SyntaxNinja> not quite, no, and it definitely needs more eyes on it.
14:45:30 <SyntaxNinja> btw, I think we might change the way compilation works; right now, it moves the sources and preprocessed files into a temp location, then runs the build on them
14:45:34 <SyntaxNinja> this is to make cleaning up easier
14:45:51 <SyntaxNinja> but of course that will give the user bad error messages, since the files will be in the wrong place.
14:45:56 <SyntaxNinja> that's pretty ugly, so it needs to change.
14:46:00 <shapr> right, CosmicRay found that with ghc5
14:46:24 <SyntaxNinja> simonMar said something about it, and he might have a patch, idono
14:47:00 <shapr> did he mention on the libraries list?
14:47:26 <SyntaxNinja> no, in private email to me
14:48:11 <Igloo> The errors will be right if you just chdir "build/" or whatever first
14:48:42 <shapr> ok, I'll check into it.
14:48:44 <Igloo> Hmm, although the user would have to change to that directory to investigate
14:49:13 <shapr> Igloo: eh?
14:49:27 <SyntaxNinja> Igloo: right
14:49:39 <SyntaxNinja> I'd be afraid of systems where you click on the error and it opens the source file, then you fix the error
14:49:57 <shapr> ah
14:49:58 <Igloo> Well, they're symlinks on decent OSes presumably, so that would work
14:50:01 <SyntaxNinja> could have some very confusing and annoying consequences.
14:50:26 <SyntaxNinja> they're not symlinks
14:50:36 <Igloo> How come? In case the build process changes them?
14:52:25 <SyntaxNinja> why are they not symlinks? idono, it never occurred to me to make them symlinks
14:52:38 <SyntaxNinja> for one thing, we still have to move them for "setup sdist"
14:52:53 <Igloo> Anyway, in that case you don't want the files in build/ changed, you want the ones in . changed and then to be copied across again
14:53:09 <SyntaxNinja> right
14:54:08 <SyntaxNinja> so it sorta makes me wonder, why bother copying them in the first place?
14:54:55 <CosmicRay> not all OSs have symlinks
14:54:56 <Igloo> Because blowing away build/ is easy
14:54:58 <CosmicRay> anyway
14:55:01 * CosmicRay has to run
14:55:38 <shapr> Igloo: so is unpacking the archive?
14:55:41 <SyntaxNinja> Igloo: so I propose that we put the .hi, .o, and the output from the preprocessors in build
14:55:49 <Igloo> Do you have an archive at this point?
14:55:55 <shapr> I dunno
14:56:34 <SyntaxNinja> but leave the .hs files where they are
14:56:36 <Igloo> With -odir etc you mean? Is that supported by everything?
14:57:00 <SyntaxNinja> you mean by the various compilers?
14:57:09 <Igloo> Yeah. ghc5 looks OK.
14:57:32 <SyntaxNinja> idono if nhc supports it, I would suppose so
14:57:46 <SyntaxNinja> if not, then maybe we should just move them into build afterward
14:57:48 <Igloo> I don't see anything in the nhc manpage about it. hugs obviously doesn't matter (except for FFI stubs?)
14:58:47 <SyntaxNinja> we need an official #haskell nhc representative on staff.
14:58:59 <shapr> truly
15:00:12 <SyntaxNinja> Igloo: do you have another idea of how to solve this? you think we should make symlinks instead of copying? what platforms lack symlinks?
15:01:11 <Igloo> Does whatever windows env things work in have them? It's easy enough to have a fallback of copying stuff over to build/ more aggresively when you don't have them, anyway
15:02:20 <SyntaxNinja> but if we have to implement copying stuff to build, then why bother w/ implementing symlinks?
15:02:28 <Igloo> I think I like the idea of things getting built in a copy of the tree as it makes a lot of things easier. If it were me I think I'd do that with symlinks. The user docs would have to make it clear what was going on, though
15:02:41 <Igloo> (and cabal should have a -v to show what it's executing where)
15:03:13 <Igloo> symlinks are just an optimisation, you can add them later
15:03:34 <Igloo> When copying you should only copy files that have changed timestamp to minimise unnecessary rebuilds
15:05:55 <SyntaxNinja> but when is copying ever the right thing to do?
15:06:06 <SyntaxNinja> I mean copying the source files to the build/ directory?
15:06:22 <Igloo> When you can't symlink them. I think I've misunderstood the question
15:06:26 <shapr> alternatively, we could record the decision along the reservations
15:06:42 <Igloo> Oh, I think I see
15:07:03 <Igloo> Currently "setup something --ghc" copies then "setup build" builds, right?
15:07:15 <Igloo> Instead, build should do the copying
15:07:28 <Igloo> So you setup once and then if the first build breaks you fix something and build again
15:07:44 <Igloo> Oh, make the copied files RO if you haven't got symlinks
15:08:08 <SyntaxNinja> what's "something"? build does do the copying, I think.
15:08:32 <SyntaxNinja> but it shouldn't use copies fo the files for building, because that will confuse the end user (unless there are symlinks)
15:08:35 <Igloo> I thought you had something before build, but I might misremember
15:08:47 <Igloo> Why will it confuse the user?
15:09:35 <Igloo> something == configure
15:10:15 <SyntaxNinja> no, I don't think configure copies; I could be wrong...
15:10:44 <SyntaxNinja> because they'll get error messages that refer to the wrong files; if they click on them, fix them, then recompile, then they will have fixed them in the wrong file.
15:10:58 <Igloo> I don't see why
15:11:05 <Igloo> You have a file ./Foo.hs
15:11:08 <Igloo> It gets copied to build
15:11:22 <Igloo> "setup build" does "cd build && ghc -c Foo.hs"
15:11:26 <Igloo> Error talks about Foo.hs
15:11:34 <Igloo> To the user that's the one in ., which is the one they should fix
15:11:56 <shapr> so, assuming the user re-execute 'setup build' then the new file will be in the right place
15:11:59 <shapr> right?
15:12:12 <Igloo> "new file"?
15:12:27 <Igloo> They modify ./Foo.hs which gets copied again by "setup build" as its timestamp has changed
15:12:33 <shapr> right
15:12:57 <SyntaxNinja> hm
15:12:58 <shapr> to start with, setup build could just copy all the source files mentioned in the package description
15:13:04 <shapr> cheesy, but easy
15:13:13 <shapr> oh wait
15:13:19 <shapr> ghc will then recompile everything, won't it?
15:13:32 <Igloo> And if you "setup build -v" then it should tell you what commands it runs in which directory, a la make, so you know what to do to reproduce the error yourself
15:13:49 <shapr> still, it's a good way to start out.
15:13:58 <Igloo> Yeah, the timestamp thing is just an optimisation too
15:14:03 <SyntaxNinja> OK I'll think about that, simonMar had some problem w/ VS
15:14:14 <shapr> what sort of probs?
15:14:21 <SyntaxNinja> just what I described
15:14:48 <shapr> oh
15:15:02 <Igloo> Ah, if VS itself is doing the compilation itself then it might point you at build/Foo.hs
15:15:32 <shapr> was he re-running 'setup build' each time?
15:15:45 <Igloo> But if that was the case I don't think it would be using the cabal code at all, so I don't get that
15:16:29 <SyntaxNinja> I guess then we're counting on VS, etc to use relative paths for errors instead of absolute paths
15:16:57 <Igloo> But VS is presumably just parsing ghc errors?
15:17:08 <Igloo> Oh, but it talks to GHC's internals now doesn't it?
15:17:15 <Igloo> So maybe it gets a fully qualified path out
15:17:22 <SyntaxNinja> idono
15:18:16 <Igloo> Pah, silly OSes without things like symlinks  :-)
15:18:45 <SyntaxNinja> I'll ask simon what's up
15:22:20 <shapr> are all of the public beta release items finished?
15:23:38 <SyntaxNinja> shapr: I have a list of things I want done before 1.0, if that answers your questions
15:23:45 <shapr> is it in the TODO?
15:24:12 <shapr> should I just grab the first item on top of the TODO list and go for it?
15:27:37 <SyntaxNinja> shapr: one thing you could do, which takes almost no background, is to clean up warnings
15:29:12 <SyntaxNinja> adding an install target for hugs and nhc would be cool.
15:29:23 <SyntaxNinja> make runhugs actually work
15:29:41 <SyntaxNinja> (for the setup scripts)
15:30:32 <shapr> ok
15:30:46 <SyntaxNinja> there are some notes on the parsing that I don't know for sure whether marvin did them or not
15:31:13 <shapr> I'll see what I can clean up.
15:50:29 <carp> evening Edwin
16:18:44 <shapr> @yow !
16:18:44 <lambdabot> Do you need any MOUTH-TO-MOUTH resuscitation?
16:24:33 <shapr> carp: would you like the quick tour of #haskell?
16:25:04 <carp> shapr: wha?
16:25:25 <shapr> just an offer to point out the local tourist attractions here on #haskell...
16:25:43 <carp> err, ok
16:25:59 <shapr> since you already know Haskell, I'll skip the learning page...
16:26:13 <shapr> lambdabot is an irc bot written in Haskell, he has some useful plugins
16:26:27 <carp> cool
16:26:37 <shapr> the Haskell Wiki has lots of good info http://www.haskell.org/hawiki/RecentChanges
16:27:00 <shapr> the url for the channel logs is mentioned in the topic
16:27:20 <shapr> wasn't that quick?
16:27:33 <carp> thanks!
16:27:50 <shapr> Haskell-related lambdabot plugins include @index @type and @info
16:27:54 <shapr> @index anyChar
16:27:54 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
16:28:00 <shapr> @type foldr
16:28:01 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
16:28:10 <shapr> @info Eq
16:28:11 <lambdabot> -- Eq is a class
16:28:11 <lambdabot> class Eq a where {
16:28:11 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
16:28:11 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
16:28:11 <lambdabot>     }
16:28:20 <carp> that's pretty cool
16:28:38 <shapr> yah, the next step is to write a plugin that searches by type.
16:28:42 <shapr> that should be interesting
16:29:08 <shapr> lambdabot does a lot of other stuff too, but that's about the extent of the on-topic functionality.
16:30:45 <shapr> maybe a nice epigram plugin next :)
16:31:54 <carp> epigram have any libraries at present so it might require a bit of thought!
16:35:19 <carp> s/have/doesn't have/
16:50:54 <shapr> has anyone tried to build HS-HGL 3.00?
17:30:20 <musasabi> Is there a large difference in performance between ST and State ?
17:44:35 <tuomov> is there any way to have lists with (almost) arbitrary elements, and still be able to define map for them?
17:45:28 <tuomov> I'm currently trying
17:45:31 <tuomov> data Arbitrary = forall a. Show a => A a
17:45:33 <tuomov> data AList = ANil | ACons Arbitrary AList
17:45:55 <tuomov> and I can 'show' the list and map a constant function, but anything else fails
18:08:32 <dons> tuomov: you're looking for a heterogenous list
18:08:43 <dons> there's a few ways. one is to use a [Dynamic]
18:10:24 <dons> here's a comprehensive reference: http://homepages.cwi.nl/~ralf/HList/
18:10:59 <dons> though perhaps the introductory examples are more easy to understand than the body of the paper..
18:13:35 <tuomov> Dynamic seems like an ugly kludge..
18:14:37 <tuomov> and I don't think you can have dynamic functions?
18:15:22 <dons> you can. you have to use Data.Dynamic.dynApp
18:15:25 <tuomov> ah, you can, I just had missed it earlier
18:15:28 <conleymt> can someone help a poor student learning haskell
18:16:01 <conleymt> no answer means yes
18:16:09 <conleymt> ?
18:16:19 <tuomov> is there some performance penalty in dynamic?
18:16:55 <dons> it is about 4% slower to unwrap a value and use it, maybe less. no real penalty
18:17:00 <musasabi> tuomov: what about existentials?
18:17:22 <tuomov> ?
18:17:28 <dons> all the ways I know of to do heterogenous lists are in the above paper, anyway.
18:17:29 <musasabi> data S = forall a. Show a => S a
18:18:09 <tuomov> GADTs might solve the problem quite elegant if all you want to do is manipulate that list
18:18:09 <dons> they describe the standard ways: [Dynamic], and some others, and propose a statically checked way using brain-hurting types
18:18:20 <conleymt> you  bastards
18:18:22 <tuomov> but if the list must be part of another data structure, it gets complex again
18:18:27 <dons> maybe... that is interesting!
18:18:33 <dons> conleymt: just ask your question
18:18:37 <conleymt> hehe
18:19:02 <conleymt> Unresolved top-level overloading
18:19:09 <tuomov> musasabi: I have it that way now, but I can't map a non-constant function over the list
18:19:11 <conleymt> what is this
18:19:23 <tuomov> because I can't match on the Arbitrary values
18:19:42 <tuomov> data AList a where
18:19:42 <tuomov>     ANil :: AList ()
18:19:42 <tuomov>     ACons :: c -> AList d -> AList (c, d)
18:19:59 <tuomov> no, I haven't tried it
18:20:29 <dons> tuomov: re dynamics, here's a dynamic application operator. applies a dynamically typed function to a heterogenous list:
18:20:33 <dons> infixr 0 $>
18:20:35 <dons> ($>) :: Dynamic -> [Dynamic] -> IO ()
18:20:37 <dons> f $> as = putStr (fromDynamic $! f `dynAppHList` as)
18:21:10 <dons> ignore the putStr
18:22:04 <dons> dynAppHlist is: dynAppHList fn (x:xs) = (fn `dynApp` x) `dynAppHList` xs
18:22:18 <dons> so it isn't too hard to do dynamically typed hlists.
18:23:02 <dons> the statically typed ones are the hard ones, I think
18:24:23 <tuomov> but can one cast from Dynamic to an arbitrary member of a type class?
18:27:58 <dons> arbitrary member?
18:28:01 <dons> fromJust $ fromDynamic (toDyn (1 :: Int)) :: Int
18:28:34 <dons> so we get back a member of all the classes Int is defined over
18:29:30 <tuomov> but if I just want a Show a?
18:29:50 <dons> what is 'a' though?
18:29:55 <tuomov> unspecified
18:30:11 <dons> fromDynamic (toDyn v) :: Show a => a ?
18:30:24 <dons> can't do that. you'd need to specify the type of a in the outer constraint
18:30:47 <tuomov> show $ fromDynamic v
18:30:53 <tuomov> is that possible?
18:31:00 <musasabi> tuomov: instance Show S where show (S s) = show s
18:32:09 <tuomov> apparently not
18:32:26 <dons> dynamics in haskell are monomorphic only. so you need to kill off the polymorphism
18:32:41 <musasabi> tuomov: show [S True, S "foo"] (you need -fglasgow-exts)
18:32:46 <tuomov> so they're not applicable
18:34:02 <tuomov> musasabi: I'm essentially doing that now, but I can't map over that list
18:34:27 <tuomov> t :: Arbitrary -> Arbitrary
18:34:27 <tuomov> t (A (Just x)) = A Nothing
18:34:27 <tuomov> t x = x
18:34:44 <tuomov> can't map that function over such a list
18:35:05 <tuomov>     Inferred type is less polymorphic than expected
18:35:05 <tuomov>         Quantified type variable `a' is unified with `Maybe a1'
18:39:15 <dons> ah, the hlist paper solves how to show dynamics
18:39:37 <dons> you attempt fromDynamic for all types you are interested in, until it works
18:39:40 <tuomov> and there's a class based alternative to the gadt above
18:40:48 <tuomov> but if I don't know the types?
18:41:10 <tuomov> if I know them, I could just use data EverythingImInterestedIn
18:41:27 <conleymt> i.... hate....you guys
18:41:48 <tuomov> or is it something smarter? which page?
18:42:16 <dons> nothing smarter than that
18:42:30 <dons> unless you use the statically typed hlist library they defined in the rest of the paper
18:42:41 <dons> it maybe be complex to use though
18:42:47 <tuomov> I should read that..
18:43:47 <dons> they emphasise a ready-to-use library for HLists, which sounds promising
18:45:06 <tuomov> I just started wondering how one would actually go about implementing something like a WM in haskell
18:45:14 <tuomov> (not that I actually intend to do so)
18:45:21 <tuomov> and there are quite a few problems with the OO framework
18:45:36 <dons> WM == ?
18:45:41 <tuomov> window manager
18:45:50 <dons> oh. but we all just use ion here ;)
18:46:07 <tuomov> and everyone wants me to rewrite it in haskell :)
18:46:33 <dons> yep. i've got a student project to add Haskell as an extension language to ion..
18:46:44 <dons> just need a student to begin work on it
18:47:13 <dons> http://www.cse.unsw.edu.au/~pls/thesis-topics/windowmanager.html
18:47:43 <tuomov> :)
18:47:55 <dons> (load Haskell plugins as `scripts' into foreign applications, using hs-plugins)
18:51:59 <dons> there's a bit of a Haskell window manager in the House haskell OS
18:56:41 <tuomov> I guess most wm:s wouldn't be that big a problem to implement
18:57:04 <dons> nope
18:57:07 <tuomov> but Ion's architechture is quite flexible, as any object (region) can manage any other kind of region
18:57:32 <tuomov> so one needs list of the sort [\forall a. WRegion a => a]
18:58:36 <tuomov> or perhaps lists of references to such objects
18:59:10 <dons> yeah. so a bit of an tricky type.
19:12:29 <dons> tuomov: re riot. you could use hs-plugins to load the config data dynamically, more like a .muttrc, rather than compiling it in statically
19:12:53 <dons> (just struck me when playing around with riot)
19:13:56 <dons> use make() and load() to load Config.hs when riot starts up, and you can reload if the src changes
19:44:44 <shammah> afternoon all.
19:45:33 <dons> hehe. shammah lives somewhere sensible :)
19:46:12 <ozone> dons: screw you hippie
19:46:47 <dons> hahaha.
19:47:10 <ozone> don't mind me, i just had some tequila
19:47:26 <dons> what is it, like, midnight?
19:47:57 <dons> see wolfgang put the first pic patch in last night
19:48:51 <ozone> yeah, i know
19:48:57 <ozone> crazy crazy germans/austrians
19:49:01 <dons> didn't even break anything!
19:49:03 <ozone> err, crazy german-speaking countries
19:49:15 <ozone> works on mac os x too
19:49:23 <ozone> should get sean to try it with exactly the example i did
19:49:37 <ozone> only problem is that it's not integrated with the build system properly, because wolfgang doesn't like build systems
19:49:58 <dons> no. strange, that.
19:50:11 <dons> oops. maybe it did break something..
19:50:19 <dons> nativeGen/PositionIndependentCode.hs:94:
19:50:19 <dons>     Variable not in scope: `howToAccessLabel'
19:50:26 <dons> grr.. wolfgang!
19:51:30 <ozone> mein laben!
19:55:55 <dons> argh. he plays some tricksy games with #ifdef
19:55:59 <dons> blargh
20:02:50 <dryan> hi can anyone tell me how to write a function which preserves all letters of a string
20:04:20 <dons> dryan: what is the type of the function?
20:04:36 <dons> and what does 'preserve' mean in this case
20:04:41 <dryan> String -> String
20:04:44 <dryan> for example
20:04:52 <dryan> "July 4th" would become "Julyth"
20:05:38 <dons> so you are really interested in what chars to remove..
20:05:58 <dryan> i suppose
20:06:00 <dons> look in Data.Char for character class selection functions
20:07:14 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Char.html
20:07:31 <dryan> ok thanks
20:09:42 <tuomov> hs-plugins can't determine what's already loaded?
20:10:31 <dons> the application should know what is already loaded (?)
20:10:57 <tuomov> I mean, the application imports Curses, CWString, etc.
20:11:07 <tuomov> but Config.hs also imports them
20:11:19 <tuomov> and I need to tell load where to find .hi files for those
20:11:31 <shrimpx> so the only diff between State and StateT is that StateT allows lifting of some other monad?
20:11:38 <dons> tuomov: yep
20:11:44 <tuomov> and finally it dies in
20:11:44 <tuomov> ./ginsu/CWString.o: unknown symbol `hs_get_mb_cur_max'
20:12:01 <tuomov> that's in inline defined in CWString_hsc.h
20:12:07 <dons> can you load ginus/CWString in ghci?
20:12:24 <dons> maybe there is a missing package argument to load?
20:12:40 <dons> load requires the same package and path flags as ghci would
20:14:51 <dons> hmm. a foreign binding to an inline function in a .h file. that's a bit icky
20:15:13 <dryan> woo hoo it works thanks dons
20:16:30 <tuomov> I can't get ghci to even attempt to load anything
20:17:27 <dons> unknown symbols occur if the loader can't find all the .o files it needs, so it is just a matter of getting the nec. object loaded
20:17:33 <dons> nothing to serious
20:17:41 <tuomov> but the symbols are in the binary..
20:18:33 <tuomov> not necessarily exported though, and ghc doesn't seem to have an -export-dynamic flag
20:18:54 <dons> the static versions. dynamically loaded stuff needs another (dynamic) version loaded.
20:19:04 <dons> so we don't have to mess with -export-dynamic
20:19:19 <dons> it doesn't know that something is already statically linked. just like ghci
20:20:17 <tuomov> I wonder why make is deleting .hs files generated from .hsc
20:20:26 <tuomov> I haven't asked it to do so
20:20:36 <tuomov> and ghci won't attempt to load .hsc:s
20:20:39 <dons> hmm. anyway, I get ghci to do:
20:20:40 <dons> Loading package haskell98 ... linking ... done.
20:20:40 <dons> Loading object (static) CWString.o ... done
20:20:40 <dons> final link ... CWString.o: unknown symbol `hs_get_mb_cur_max'
20:20:50 <dons> ghci-6.2.1 CWString.o -package haskell98
20:21:33 <dons> got it. you add CWString_hsc.o to the load command line
20:21:40 <dons> ghci-6.2.1 CWString.o -package haskell98 CWString_hsc.o
20:22:07 <dons> so you could do this in load() by explicitly loading _hsc.o prior to CWString itself.
20:22:22 <dons> not sure why ghci nor hs-plugins couldn't find it automagically
20:22:54 <dons> it should be in a cbits archive, really.
20:23:21 <tuomov> gets a bit too complicated, having to have all the files around
20:23:40 <tuomov> there should be some way to include the necessary information in the binary
20:24:00 <dons> it's nasty because CWString_hsc.o doesn't appear in CWString's .hi file
20:24:19 <dons> this is an unconventional structure. hence it doesn't work in ghci simply either
20:25:03 <dons> normally you'd package up ginsu as a libHSginus style library, and load() would just pull it in as a normal package
20:25:34 <dons> currently, you're Config.hs is linked against a bunch of riot internals, so it is not a clean separation
20:26:32 <dons> I'd normally write a single API.hs, that is distributed as a .o, and that defines what Config.hs requires
20:27:38 <tuomov> but API.hs can't depend on anything?
20:28:32 <dons> no, it could depend on anything
20:28:52 <dons> load() chases down dependencies. it is just about making the deps simple and well-defined
20:31:49 <dons> but, yes, interal modules of riot that are used in Config.hs, or the API, will have to be around at runtime as libraries or .o files
20:34:31 <dons> load "~/.riot/Config.hs" ["/usr/local/lib/riot/"] [] "resource"
20:34:40 <dons> where your .o files live in the lib dir. 
20:34:56 <dons> or if it is a package, installed into ghc's package system, no args are needed at all
20:40:52 <tuomov> is it possible to load CWString_hsc.o at all with hs-plugins?
20:41:03 <tuomov> it requires a symbol to load, but that has to be a haskell symbol?
20:44:54 <tuomov> actually, the symbol isn't even in CWString_hsc.o
20:47:36 <tuomov> or not in a section scanned by 'strings' by default
20:47:45 <dons> $ nm CWString_hsc.o
20:47:46 <dons>          U __ctype_get_mb_cur_max
20:47:46 <dons> 00000000 T hs_get_mb_cur_max
20:48:35 <dons> anyway, it won't get loaded automatically, so you have to load it explictly.
20:48:41 <dons> Plugins.Load.loadObject 
20:49:17 <dons> or you could fix ginsu to be a well-behaved Haskell program ;)
20:50:30 <dons> load() itself won't work, I think, because CWString_hsc.o doesn't have a .hi file
20:51:17 <dons> but once CWString_hsc.o is in memory, load() should be able to pull in everything else
20:51:40 <tuomov> I had to load Curses_hsc.o and nomacro.o as well
20:51:52 <tuomov> and no I get segfaults
20:51:54 <tuomov> +w
20:52:28 <tuomov> maybe something to do with the same stuff being in memory twice..
20:52:37 <dons> yep. so all the ginsu stuff should be a -package. then it would be in a .hi file, and get loaded automatically.
20:52:56 <dons> c objects need to be explicitly loaded, otherwise
20:53:16 <tuomov> gets a bit complicated for such a quick&dirty program..
20:53:21 <dons> yep!
20:53:50 <dons> I agree. but it is the existing structure that is making things hard
20:54:58 <dons> so I claim it isn't my fault :)
20:55:38 <tuomov> how does whatever search for symbols?
20:56:17 <tuomov> For Ion I have to tell gcc -export-dynamic for modules to be able to use symbols from the main binary
20:56:35 <tuomov> and ghc binaries probably don't set such an option by default?
20:56:41 <tuomov> and ghc doesn't seem to have one
20:56:52 <dons> in the ghc rts, we have our own linker that does some magic to dynamically loaded modules
20:56:52 <tuomov> or does (whatever) even try looking up symbols this way?
20:57:04 <dons> it doesn't look in the static code
20:57:17 <tuomov> does it even use libdl?
20:57:35 <dons> underneath, yes
20:58:30 <tuomov> so Maybe some -export-dynamic flag would help?
20:58:42 <tuomov> But it would still need the .hi files, though?
20:58:44 <dons> we've tried this, it messes with ghc's garbage colletor
20:59:18 <dons> we still in the .hi files of stuff we're loading, so we hs-plugins can find the dependencies
20:59:24 <dons> s/in/need/
21:00:27 <dons> but you just distribute Config.hs as src, and have the app compile it at startup
21:01:20 <dons> wolfgang thaller's PIC commit to ghc last night is hopefully going to make dynamic linking a lot easier
21:01:31 <dons> s/easier/more standard/
21:10:43 <dryan> how do i get rid of empty items in a list
21:11:12 <dons> pattern matching
21:12:28 <dryan> i have a function which tokenizes a string then normalizes it
21:12:47 <dryan> the problem is it returns the empty tokens which have been stripped of commas and full stops
21:13:22 <dons> what are they -- []?
21:13:34 <dryan> ""
21:14:57 <dons> "" == [] in Haskell, "" is just shorthand
21:15:11 <dryan> i see
21:15:18 <dons> have a look at filtering functions in Data.List
21:15:29 <dons> or write a recursive function to do this.
21:15:45 <dryan> ah that rings a bell thanks
22:44:50 <dons> tuomov: just sent you a patch to build ginsu/ as a proper Haskell package
23:05:53 <Helicopter> question
23:06:01 <Helicopter> in a do block, if I perform
23:06:15 <Helicopter> contents <- hGetContents somehandle
23:06:30 <Helicopter> x <- somefunc (lines contents)
23:06:41 <Helicopter> y <- somefunc2 (lines contents)
23:07:01 <Helicopter> does "lines" run on "contents" twice ?
23:35:35 <musasabi> morning
23:47:25 <musasabi> Does anyone have working UDP + Handle example? Whenever I use Network.Socket api it works, but after converting to a Handle I am unable to receive anything, with various buffering modes.
