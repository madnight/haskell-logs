00:06:02 <musasabi> How do I build the GHC rts with gprof support?
00:07:08 <xman23> could someone please hack http://www.frisky-business.net/members/index.htm please i need a pass for this site thanks?
00:07:26 <bbls> haha :)
01:49:59 <musasabi> hmm got GHCi to segfault again.
01:51:19 <musasabi> http://youzen.b2.fi/~musasabi/crash.hs
01:52:17 <musasabi> I understand why it crashed, just don't like it.
01:54:18 <dons> well, you play with unsafePerformIO...
01:54:43 <dons> ;)
02:39:34 * shapr yawns
03:25:30 <musasabi> Is there any eleganter way to do: unsafeSuffix a b = drop (length a) b
03:27:51 <tromp> unsafeSuffix = drop . length  ?!
03:28:47 <tromp> what's inelegant about yours anyway?
03:38:13 <bourbaki> hi
03:39:35 <tromp> hi dennis
03:39:50 <bourbaki> dennis?
03:40:24 <tromp> isn't that your Realname?
03:40:54 <bourbaki> why do you think so?
03:41:28 <tromp> my irc client shows it when i rightclick on your name
03:41:48 <bourbaki> :)
03:41:57 <jfpf> Hello
03:42:35 <tromp> hi, joao:)
03:43:00 <jfpf> I need some help
03:43:11 <jfpf> :)
03:43:33 <tromp> help with what?
03:43:37 <jfpf> Have you ever worked with Data.Set library?
03:43:51 <tromp> not yet
03:44:19 <jfpf> Hmm. Well, I'll try to explain the problem.
03:45:09 <jfpf> Data.Set is built using Data.FiniteMap. Data.FiniteMap is implemented as balanced trees (eg. Tree a b) where (Ord a) is assumed
03:45:31 <jfpf> So, a FiniteMap a b assumes (Ord a)
03:45:40 <jfpf> Just because of the implementation
03:45:57 <jfpf> Set a is the same as FiniteMap a ()
03:46:04 <jfpf> So, Set a assumes (Ord a)
03:46:15 <jfpf> My problem is that I'd like to define an instance of Functor for Sets
03:46:30 <jfpf> But I can't, because of that constraint (Ord a)
03:46:42 <jfpf> Is there any way to solve this problem? :)
03:46:59 <TheHunter> jfpf: it's sad but i think it's impossible. You also can't make Data.Set an instance of Monad
03:47:21 <bourbaki> moin TheHunter 
03:47:27 <TheHunter> moin bourbaki 
03:47:37 <jfpf> That's a real problem, hmmm
03:47:53 <TheHunter> jfpf: depending on your situation, you can kinda solve this with fundeps:
03:48:07 <TheHunter> class Functor' x fx | fx -> x where
03:48:32 <TheHunter> no, that doesn't work...
03:48:51 <TheHunter> class Functor' x y fxy | fxy -> x, fxy -> y where
03:49:48 <TheHunter>   fmap' :: (x -> y) -> (fxy x -> fxy y)
03:50:06 <TheHunter> that's still not optimal...
03:50:35 <tromp> why not use a HashTable to implement mySet?
03:51:16 <jfpf> tromp, Data.Set already uses Data.FiniteMap
03:51:37 <jfpf> TheHunter, hmm, i have to study fundeps better, to see if they can help me
03:51:40 <jfpf> TheHunter, thank you
03:51:44 <tromp> i see HashTable returns IO types:(
03:52:17 <TheHunter> jfpf: well it's a workaround and it sure gets quite ugly
03:52:46 <TheHunter> jfpf: but for functors you at least won't lose something like the do-notation
03:53:52 <jfpf> TheHunter, I need to study this thing.. thanks for the help :)) btw, have you ever worked with data types invariants in haskell?
03:53:53 <tromp> what do you want to make an instance of what?
03:53:53 <TheHunter> is there any reason Data.Hashtable uses IO instead of ST?
03:54:22 <tromp> maybe laziness:(
03:54:40 <tromp> the real life variant that is:(
03:55:32 <musasabi> How do I get the current time ?
03:55:52 <TheHunter> jfpf: sorry, no
03:56:59 <tromp> use System.Time
03:57:46 <tromp> @type getClockTime
03:57:48 <lambdabot> bzzt
03:58:01 <tromp> @type System.Time.getClockTime
03:58:03 <lambdabot> System.Time.getClockTime :: IO System.Time.ClockTime
03:58:23 <tromp> @index getClockTime
03:58:24 <lambdabot> System.Time,Time
03:59:39 <musasabi> thanks
04:05:46 <jfpf> How can we import data type constructor that are not exported? For instance, import Data.Set(Set(MkSet)) works well with Hugs but not with ghci...
04:06:38 <TheHunter> jfpf: the code above still doesn't do what it's supposed to do, the best I can think of is class FunctorMap x fx y fy | fx -> x, fy -> y where {fmap':: (x->y) -> (fx -> fy)}, but i think tromp's hashmaps are a better alternative anyway.
04:08:37 <jfpf> You mean Data.Hashtable ?
04:09:14 <TheHunter> yes (of course, it depends on what you want to do)
04:09:42 <TheHunter> jfpf: import Data.Set(Set, MkSet)
04:09:49 <jfpf> What are the big differences between Data.Hashtable and Data.FiniteMap (besides implementation)
04:09:52 <TheHunter> err, import Data.Set(Set, mkSet)
04:10:13 <jfpf> mkSet is not the constructor... is just a function
04:11:07 <TheHunter> Hashtable works for any type, but the result is always in the IO monad (which should be relaxed to ST, IMHO)
04:11:44 <TheHunter> jfpf: the ghc libraries don't export the constructor MkSet
04:12:32 <jfpf> TheHunter, Hugs libraries don't export it either.. but I can load it, if I want. In my case is useful so that I can define the Show instances
04:13:04 <shapr> yow!
04:14:03 <TheHunter> jfpf: i would consider this a hugs bug. You can still define Show instances if you don't have the constructor.
04:14:24 <TheHunter> @yow
04:14:25 <lambdabot> --``I love KATRINKA because she drives a PONTIAC.  We're going away now
04:14:25 <lambdabot>  I fed the cat. - Zippy''
04:14:44 <shapr> that's a nice running away to get married note
04:15:08 <jfpf> TheHunter, I don't know how... I've always used the type constructors
04:15:43 <TheHunter> jfpf: you mean pattern matching?
04:16:52 <TheHunter> ah, the type constructor is Set.
04:17:12 <jfpf> TheHunter, it's MkSet
04:17:19 <jfpf> TheHunter, yes, pattern matching
04:17:23 <tromp> where is MkSet documented?
04:17:50 <TheHunter> jfpf: You are not supposed to do that Set is an Abstract data type, so the implementation might change
04:18:11 <TheHunter> s/Set/Set./
04:18:24 <TheHunter> s/that/that./
04:19:00 <jfpf> I understand that, of course, but I'd like to define Show instance
04:19:42 <TheHunter> instance Show a => Show (Set a) where...
04:20:21 <TheHunter> oh my god, there is no fold operation for Data.Set...
04:20:31 * shapr gasps
04:20:44 * shapr eagerly awaits the next act of the play.
04:21:03 <jfpf> I think you can use foldFM
04:21:18 <jfpf> But it should be defined in Data.Set module
04:21:38 <TheHunter> no, you can't because you don't know Sets are implemented using FiniteMaps
04:21:59 <TheHunter> you can use setToList, however
04:23:00 <jfpf> Well, I'm kinda stupid today, because I've defined the Show instance without the type constructor O:)
04:23:24 <jfpf> Sorry :(
04:24:24 <TheHunter> jfpf: Your functor problem is very common, and a satisfying solution has yet to be found.
04:25:29 <TheHunter> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005988.html
05:18:52 <shapr> the hills are alive!
05:21:49 <Lemmih> They are?
05:25:19 <bourbaki_> hills?
05:25:20 <goron> I want to use threads in Haskell, but it seems they are limited. Suppose I have two threads one printing "a" and one printing "b", I want the output to be "aaababb", or something like that. And not "aaaaaaaaaaaaaaaaaaaaaaaaa.." "bbbbbbbbbbbb.."  or the other way around as is in the docs of ghc.  
05:25:50 <Lemmih> @index yield
05:25:50 <lambdabot> Control.Concurrent,GHC.Conc
05:26:24 <goron> Does that work?
05:27:00 <Lemmih> I don't think it's broken if that's what you mean...
05:27:09 <Igloo> If you want a specific ordering you'll have to use MVars or something to synchronise. If not, the scheduler can do what it likes while there are multiple runable threads
05:28:44 <goron> Igloo: The way I read it was: either the scheduler says:aaaaaaa.. and then bbbbbb..., but it doesn't ever do for example "ababa.."
05:28:55 <goron> But I will look for yield
05:30:33 <musasabi> goron: well "aabbaabb" is probably not what you really really want.
05:31:19 <musasabi> goron: you can have different threads printing concurrently to e.g. stdout. Just single io actions should be atomic hopefully.
05:31:57 <goron> musasabi: Well the docs say it's good enough to create " simple gui's". I than begin wondering, why the word "simple" is being used.  
05:32:15 <shapr> maybe because it didn't have thread-local state before?
05:32:53 <goron> shapr: And now it does?
05:32:59 <shapr> yup
05:33:11 <shapr> with forkIO I think
05:33:37 <goron> So, it's correct to say that Haskell threads are at least as powerfull as java threads (Threads class)?
05:34:03 <shapr> more flexible
05:34:21 <shapr> standard/default haskell threads are coroutines, aka green threads
05:34:52 <shapr> with -threaded you have a pool of real OS threads that can get handed any coroutine that needs to do stuff
05:35:07 <goron> So everything you can do in Java, you can do in Haskell (using Control.Concurrent)?
05:35:14 <shapr> those two options are fast and efficiently use resources
05:35:31 <shapr> but things like OpenGL *require* that the same OS thread is used to do stuff
05:35:35 <shapr> so forkIO appeared.
05:35:39 * Igloo grins at SM's build system post on g-h-u
05:36:22 <shapr> goron: I don't know for sure.
05:36:43 <shapr> because I haven't read about Java threads in a year or two
05:37:09 <goron> shapr: You can assume they are the same. Java implements threads only by monitors.
05:38:05 <shapr> I've read about that... but off the top of my head, I don't remember how it works.
05:38:07 <goron> I mean that's the interface to Joe, the java programmer. 
05:38:11 * shapr asks google
05:39:58 <musasabi> goron: I haven't found many problems with haskell threads.
05:40:12 <musasabi> goron: most of the time they appear to be just very fast.
05:40:27 * musasabi dreams of parametized modules
05:42:34 <goron> musasabi: It seems the programmer has to make sure of fairness of the scheduler through yield. I think that's bad. 
05:42:44 <musasabi> goron: no.
05:42:48 <shapr> it's good for speed
05:43:10 <shapr> two flavors of concurrency, cooperative and preemptive
05:43:22 <xerox> hi!
05:43:23 <musasabi> goron: the threads are pre-emptive. you have to use yield in the same places as you would in java.
05:43:32 * shapr copies xerox 
05:43:35 <xerox> :(
05:43:39 <goron> musasabi: You say it's not bad? Or do you say I am wrong?
05:43:49 <shapr> hiya xerox!
05:43:53 <tromp> cooperative multitasking is something of a kludge:(
05:44:01 <shapr> tromp: I like coroutines
05:45:05 <Oejet> Igloo: What is g-h-u?
05:45:20 <shapr> probably ghc-users
05:45:27 <shapr> glasgow-haskell-users ?
05:45:29 <goron> musasabi: There is no need for yield in Java (at least it's not necessary) (I don't know whether it exists in Java).
05:45:56 <musasabi> goron: I have used yield in both Java and Haskell ;)
05:46:15 <musasabi> goron: actually threas cause less headache in Haskell than in Java.
05:46:51 <shapr> java does stuff a lot like Haskell in that you sometimes have fast, cooperative green-threads, and sometimes slower preemptive OS threads
05:46:56 <shapr> but I don't remember all the details.
05:47:23 <shapr> green-threads aka coroutines
05:47:59 <musasabi> shapr: green-threads is usually used to mean soft (userlevel) threads, not coroutines.
05:48:07 <goron> So if I don't use yield in Java, and don't use yield in Haskell and made a program with the same logic, they behave the same?
05:48:07 <musasabi> afaik that is.
05:48:30 <musasabi> goron: yes, they should.
05:48:52 <shapr> what's the difference between soft userlevel threads and coroutines?
05:49:37 <goron> That's nice.  
05:52:47 <musasabi> shapr: theads are pre-emptive in common speak unless otherwise specified, while coroutines are usually co-operative.
05:53:38 * shapr is already planning his EuroHaskell 2005 talk "How to keep your monads safe on a unicycle."
05:53:53 <xerox> where do it will take place?
05:54:08 <shapr> Gothenburg, Sweden
05:54:10 <shapr> end of July
05:54:15 <xerox> gee.
05:54:25 <shapr> xerox: you want to come?
05:54:31 <xerox> too far :(
05:54:38 <shapr> oh, too bad
05:54:55 <shapr> I think 2006 might be in .ch
05:55:31 <xerox> acceptable for an italian
05:55:34 <xerox> nice.
06:02:11 <tromp> how many days does it last?
06:02:30 <shapr> I think it will be three days
06:02:40 <Maddas> oooh
06:02:43 <Maddas> :-)
06:02:55 <shapr> Maddas: you're hosting 2006, right? ;-)
06:03:01 <tromp> how many eurohaskells have there been?
06:03:24 <Maddas> shawn: Heh
06:03:32 <Maddas> er, shapr. I must get used to not use nick-completion :-)
06:03:34 <shapr> tromp: one so far
06:03:58 <tromp> any dutch ppl there?
06:04:10 <shapr> no, not last time
06:04:20 <shapr> but we tried to get earthy to show up
06:04:40 <shapr> last time we had swiss, german, US, swedish, uk, and finnish.
06:04:45 <shapr> I think that's all.
06:04:55 * raboof pinging earthy 
06:05:09 <raboof> tromp: i'm dutch, why?
06:05:33 <shapr> raboof: it's the orange outfits.
06:06:28 <shapr> hm, who's the guy who wrote and posted the totally in-memory database to the list?
06:06:52 <shapr> Igloo: you mean this? -> "We *want* the RTS to be able to be called by threads it doesn't expect. Otherwise how do you implement a thread-safe library API in Haskell?"
06:09:04 <shapr> hej ralejs 
06:09:06 <tromp> maybe i cld bike there. wld be quite an adventure
06:09:35 <ski> shapr : wasn't there a japanese, too ?
06:09:46 <shapr> tromp: make sure you take the ferry between germany and denmark, unless you have added a propeller to your nifty recumbent bike.
06:10:00 <shapr> ski: oh yes! there was!
06:10:49 <tromp> can one bike across the bridges connecting kopenhagen island?
06:10:54 * ski 'll switch computer
06:10:58 <shapr> I don't know.
06:11:21 <shapr> Lemmih: you know anything about biking around köpenhamn?
06:12:54 <Lemmih> shapr: Yeah.
06:13:09 <shapr> what about unicycling? ;-)
06:14:07 <Lemmih> I usually don't train in the streets of Copenhagen.
06:14:26 <shapr> that makes sense. I don't even train in the streets of Boden.
06:14:48 <shapr> mostly because the n00bs around here hang their mouth open and wander off the street while staring...
06:15:41 <Lemmih> So where do you unicycle?
06:17:01 <earthy> tromp: yes, you can
06:17:05 <shapr> we have some low-rent apartments nearby where most of the immigrants live.
06:17:11 <earthy> Kopenhagen is *very* bicycle-friendly
06:17:24 <bourbaki_> hehe
06:17:58 <tromp> wanna bike there too, earthy?
06:18:00 <shapr> So I practice there. The people there see stranger things in their breakfast cereal I'm sure. They think unicycles are fun but not surprisingly weird.
06:18:54 <shapr> I ate breakfast made by a brahmin woman once. It was a very strange breakfast cereal.
06:18:54 <earthy> tromp: err.. ;) I cycled around Kopenhagen during CTCS'04
06:19:10 <earthy> but cycling all the way there seems somewhat... incompatible with my schedule :)
06:19:44 <shapr> Sort of like hot'n'spicy mueslix combined with corn porridge.
06:20:30 <shapr> anybody know what that's actually called?
06:20:52 <Jan_w> http://rafb.net/paste/results/GVfgwq94.html, I'm trying to create a DLL (cygwin/win32 in my case, but the idea is the same as a normal library) I've pasted some code at this like, can someone shed any light on it ? my main questions are: what are the stub files ? 
06:21:26 <Jan_w> excuse the bad english, i'll try to mind it :)
06:21:53 <shapr> other than "at like this" I think your english was just fine.
06:22:04 <Jan_w> at this link :)
06:22:08 <shapr> oh
06:22:39 <Jan_w> and the questions "are" should be question is :)
06:22:44 <Jan_w> but anyway
06:23:28 <Jan_w> I'm trying to interface with haskell from c++
06:23:46 <shapr> Cale wrote some neat examples of calling C++ from Haskell.
06:24:14 * Jan_w i'm calling haskell from c++
06:24:33 <shapr> I know it works, and I've seen people discuss it...
06:24:44 <bourbaki_> can you write something like the class system of c++ in haskell?
06:24:54 <Philippa> depends if you want something that messed up :-)
06:25:03 <Jan_w> bourbaki_: a module ?, more or less
06:25:05 <shapr> y0 Philippa
06:25:08 <Philippa> 'lo
06:25:15 <Philippa> 'fraid I'm not on for long, need to go get breakfast...
06:25:27 <Philippa> dunno if you saw my post on libraries@haskell.org?
06:25:30 <shapr> hm, I'm thinking about dinner
06:25:31 <bourbaki_> well my problem is that i dont know if you can have an object that modifies itself
06:25:34 <shapr> nah, I'll look at it now.
06:25:48 <Philippa> oh, some mild complaint about "why isn't this exposed in Network.CGI?"
06:26:00 <Philippa> only I got a private mail from somebody about haskell wiki clones :-)
06:26:07 <shapr> oh really?
06:26:12 <shapr> who from?
06:26:19 <shapr> sebastian carlier?
06:26:38 * shapr can think of three or four people who have worked on a wiki clone in Haskell.
06:26:43 <shapr> Marko Schuetz?
06:27:10 <Philippa> Alistair Bayley
06:27:35 <shapr> oh
06:27:38 <shapr> he's cool  :-)
06:27:46 <Philippa> he seems to be aiming for something more heavyweight before an initial release than I'm going for with Flippi
06:28:00 <Philippa> which reminds me - I think I've got edit conflict resolution in now, just need to test it...
06:28:04 <musasabi> it seems everyone has their own haskell wiki clones.
06:28:07 <shapr> I'm a huge fan of release early, release often
06:28:26 <shapr> if your code inspires, you're likely to end up like darcs, zillions of people throwing patches your way
06:28:45 <musasabi> One problem is that there is currently no real way of handling large posts.
06:29:05 <musasabi> Rewriting multipart parsing with BlockIO could help..
06:29:06 <shapr> Jan_w: short lunch ;-)
06:29:19 <Jan_w> shapr: i'm a fast eater
06:29:23 * shapr grins
06:29:23 <Jan_w> hehe
06:29:28 <Jan_w> wrong button :)
06:30:24 <Philippa> shapr: 'mnot sure I'm ready for that, I've not acted as the maintainer for anything before
06:30:39 <shapr> first time for everything
06:30:43 <Philippa> I agree with you more generally, but I'm actually kinda worried about what happens if it takes off
06:30:57 <shapr> in my experience, my first six or seven attempts at starting something failed miserably
06:31:21 <shapr> or just don't keep interest or something
06:31:38 <shapr> python refactoring browser for example...
06:31:45 <musasabi> Philippa: would you be interested in sharing library code for different things?
06:32:07 <Philippa> such as?
06:32:19 <Philippa> (probably, though I've not got much of interest)
06:37:05 <Philippa> er, with GHC, can I rely on derived Read and Show working together properly?
06:37:10 <musasabi> mostly I would be interested in parsing code if you have anything nice.
06:37:20 <musasabi> Philippa: you can rely on them being too slow ;)
06:37:33 <shapr> hej xerox
06:37:36 <Philippa> not exactly - all I'm handling is a hacked paragraph (<br /><br />), a couple of link syntaxes and an escape
06:37:45 <Philippa> sure, I need a timestamp for edit conflict resolution
06:37:53 <Philippa> speed isn't too big an issue
06:38:31 <Maddas> What are light-weight ways to parse input? Just fairly trivial things.. e.g. a few numbers on a line. :-)
06:38:54 <musasabi> Maddas: parsec is quite nice.
06:39:00 <Philippa> parsec's great
06:39:01 <musasabi> Philippa: do you have working file uploads?
06:39:04 <Philippa> nope
06:39:14 <Philippa> I have the most trivial little thing imaginable
06:39:15 <Maddas> Ok
06:39:30 <Philippa> no metadata at all, for example
06:39:37 <musasabi> ah.
06:39:57 * musasabi has metadata, versioning, different filetypes, optimized output, ... but it still sucks.
06:41:23 <Philippa> any particular source of suckage?
06:42:01 <musasabi> io and encodings 
06:42:12 * Philippa nods
06:42:28 <Philippa> I came to the conclusion that for now it's a case of "welcome to i18n hell"...
06:42:51 <musasabi> I want to be able to upload 50mb files.. and that seems very hard to do.
06:43:04 <musasabi> Serving them is not a problem via the fastpath.
06:43:18 <Philippa> I don't know enough about how that kind of thing works tbh - I've not exactly done a lot of web development
06:43:42 <musasabi> well it is not exactly web related.
06:43:56 <musasabi> more haskell string related.
06:44:30 <Philippa> ah, yeah. Certainly Network.CGI'd break on that badly
06:44:52 <Philippa> sometimes you just wanna be handed stdin and told to get on with it
06:48:13 <dblhelix> lhs2tex question: I want to emit _formatted_ index entries (I use makeindex) from within a code block ... any best practices?
06:50:19 <earthy> umm.... well... kosmikus is somewhat afk, and I wouldn't know
06:50:28 <earthy> I don't think that has gotten much attention really
06:53:43 <dblhelix> I was hoping for a easy hack for I cannot really come up with a satisfying one myself :(
06:58:54 <musasabi> Does prelude have the function "list x = [x]" (of course one could use return but that is quite distracting)
06:59:12 <shapr> have you read through PreludeExts?
07:02:24 * ski chuckles
07:05:03 * dblhelix_ often uses (: []), which is quite compact anyway
07:05:38 * TheHunter doesn't feel bad about using return
07:05:45 <Cale> return is okay :) In fact, I often use >>= for concatMap
07:06:09 <tromp> return is dandy
07:06:11 <ski> for infixness ?
07:06:17 <tromp> l
07:06:21 <shapr> Cale: have you written an example of C++ calling Haskell?
07:06:38 <Cale> shapr: no, but I suspect it's not so bad
07:07:49 <dblhelix_> another lhs2tex struggle: when I end a section with a block of code there is a lot of space between it and the start of the next section ... any remedies?
07:08:00 <Igloo> shapr: No. "is it possible to use a simpler build system for GHC? :)" "We *are* using a simpler build system for GHC.  You should have seen the last one :-)"
07:08:10 <Igloo> Oejet: g-h-u = glasgow-haskell-users@haskell.org
07:08:50 <shapr> hah
07:09:46 <earthy> dblhelix: add a negative vertical space
07:09:56 <earthy> (ugly, I know :))
07:10:22 <shapr> Igloo: hey, have you read about maak?
07:10:49 <Cale> The syntax is "foreign export c e v :: t" where c is a calling convention (you want ccall), v is a value, field name, or class method to be exported, e is a string which names it externally, and t is an instance of the type of v.
07:11:07 <Igloo> The build system? Yes, but it can't have been very interesting to me because scons and cook wree the best of those I looked at
07:11:10 <Igloo> (IIRC)
07:11:24 <Cale> foreign export ccall "addInt" (+) :: Int -> Int -> Int
07:12:19 <shapr> maak seems to have a semi-solution to the debian problem of n * m binary packages for various option combinations, and it's written in Haskell, and it seems to think like graph reduction (which I like).
07:12:32 <shapr> so I was wondering if parts of it could be borrowed for Cabal
07:13:08 <shapr> Cale: truly, that's not too scary.
07:13:22 <Igloo> Hmm, I don't remember it being written in Haskell. Has it got an accent on one of the 'a's?
07:13:28 <shapr> don't think so
07:13:41 <shapr> I grabbed a tgz yesterday
07:14:09 <shapr> heer's the page http://www.cs.uu.nl/~eelco/maak/ (unintentional dutch pun)
07:14:42 * earthy doesn't get it
07:15:52 <shapr> huh, the tbz url seems to have vanished
07:16:12 <shapr> earthy: sorry, maak graag all those doubled vowels, so 'heer' seemed very dutch to me.
07:16:51 <earthy> https://svn.cs.uu.nl:12443/repoman/info/maak
07:17:00 <earthy> shapr: `heer' is dutch
07:17:09 <earthy> but, there's no obvious pun there... ;)
07:17:20 <earthy> as `heer' means as much as `gentleman'
07:17:24 <shapr> it's a typo of 'here'
07:17:28 <shapr> oh, never mind then
07:17:36 * shapr quickly retracts that pun
07:18:02 <shapr> mijn heer van Leeuwen
07:18:26 <earthy> that's normally spelled as one word `mijnheer'
07:18:31 <shapr> so many languages, so little time...
07:18:36 <earthy> or, shorter, `meneer'
07:18:52 <earthy> yeah... I have 0 time to learn arabic... which would be *so* useful next week
07:19:02 <shapr> 403 - https://svn.cs.uu.nl:12443/dist/maak/ :-(
07:19:06 <shapr> wasn't 403 yesterday
07:19:27 <shapr> maybe it was a one-time special offer
07:19:35 <earthy> hm. time to kick eelco d
07:20:03 <earthy> as the repository is svn-able... or should be according to the info
07:20:11 <shapr> svn wouldn't get it for me either
07:20:20 <earthy> weird
07:20:33 <shapr> but I have an archive handy...
07:21:10 <shapr> http://www.scannedinavian.org/~shae/maak-trunk.tar.bz2
07:22:48 <shapr> hej kristnjov 
07:23:02 <kristnjov> tja
07:24:56 <shapr> Igloo: anyway, there's the source. I've only read the doc, haven't tried the code yet. I'll get back to you when I have.
07:27:38 <shapr> y0 y0 lypanov 
07:27:54 <lypanov> yoyo shapr :)
07:28:18 <shapr> you have some Haskell questions?
07:28:25 <lypanov> nope
07:28:34 <lypanov> just wanted to pop in see how it looked in here :P
07:29:19 <sorje> How do you like the new curtains? I especially like the big blackboard..
07:29:36 <shapr> I keep trying to get that pinball plugin working in lambdabot ;-)
07:29:47 <shapr> @pinball
07:29:47 <lambdabot> Sorry, I don't know the command "pinball", try "lambdabot: @listcommands
07:29:59 <lypanov> sorje: i do like the curtains quite a bit :>
07:33:39 <earthy> dammit why does category theory crop up so often
07:33:46 <shapr> because it's everywhere!
07:34:47 <earthy> yah
07:35:15 <earthy> and I just happen to have extremely weak category theory skillz
07:35:29 <shapr> some good books out there
07:36:53 <shapr> earthy: http://www.xp123.com/wwake/dissertation/model.shtml
07:37:07 <shapr> I really like that intro
07:37:11 <ski> fun fun fun !
07:47:28 <andersca> hey DenizzzZ 
07:47:35 <andersca> DenizzzZ: we have a swedish haskell channel at #haskell.se
08:05:36 <shapr> hello vivien @ work.
08:06:16 <vivien> heya shapr-whos-always-here~!
08:06:16 <vivien> =)
08:07:13 <ralejs> Sorry, I think I crashed lambdabot :-(
08:08:57 <shapr> what did you do?
08:10:04 <lypanov> "hello viveon @ work."
08:10:30 <lypanov> oh ignore me :P
08:11:00 <ralejs> I said "@eval map"
08:11:09 <lypanov> hehe
08:11:59 <shapr> I don't know why lambdabot crapped out.
08:12:09 <Jan_w> http://www.haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html, says: "Since this Haskell DLL depends on a couple of the DLLs that come with GHC, make sure that they are in scope/visible.
08:12:18 <Jan_w> does anyone know which DLLS ?
08:12:34 <ralejs> shapr: exactly, it seems strange.
08:12:52 <ralejs> Should I try and crash lambdabot again? :-)
08:13:01 <shapr> sure
08:14:07 <ralejs> Hmmm.. This time it didn't crash on "@eval map". Maybe it was something else...
08:14:35 <kristnjov> @eval foldr (+) 0 [1,2,3,4,5,6]
08:14:36 <lambdabot> (line 1, column 8):
08:14:36 <lambdabot> unexpected "+"
08:14:36 <lambdabot> expecting simple term
08:15:22 <ski> @eval foldr (\x y -> x + y) 0 [1,2,3,4,5,6]
08:15:22 <lambdabot> 21
08:15:31 <kristnjov> hehe
08:15:45 <kristnjov> why didn't my thing work=
08:15:46 <kristnjov> ?
08:15:56 <ski> lambdabot doesn't understand haskell
08:16:12 <ski> (it only pretends to ..)
08:16:46 <ski> (though, @index and @type and such are genuine haskell)
08:20:00 <shapr> g'day SyntaxLaptop 
08:20:14 <SyntaxLaptop> y0y0 shapr!
09:12:15 <musasabi> hmm hacked a simple template replace system (still buggy).. 
09:12:24 <musasabi> seems amazingly simple
09:17:46 <musasabi> http://youzen.b2.fi/~musasabi/Template.hs 
09:17:49 <musasabi> -> sauna
10:07:49 <musasabi> back
10:08:08 <shapr> musasabi: have you looked at Halipeto?
10:10:27 <vegai> what a name :P
10:10:34 <vegai> hugglebeast
10:10:40 <musasabi> shapr: yes, a few times.
10:11:08 <shapr> it has a Haskell clone of ZPT in there, that looks a bit like what you've got
10:11:12 <shapr> not nearly as simple, obviously
11:04:52 <shapr> it's oh so quiet....
11:04:55 <shapr> it's oh so still...
11:05:18 <bourbaki_> ;)
11:05:19 <bbls> shapr /me listening to Amazing Grace
11:05:26 <bbls> :)
11:05:29 <shapr> I like that track.
11:05:39 <bourbaki_> im listening to the new prodigy :)
11:05:48 <shapr> I'm listening to The Crystal Method
11:05:48 * esap is downloading updates to debian.
11:06:05 <bourbaki_> ah crystal method isnt bad either
11:07:33 * esap is listening mozart.
11:08:00 <bbls> esap /me scrolls down to vivaldi :)
11:09:12 <bbls> oh
11:09:13 <Jan_w> hm, when I ./configure ghc, it check for ghc and if it is not present, it fails ?! 
11:09:14 <bbls> what's that?
11:09:19 <bbls> Star Spangled Banner :)
11:09:31 <shapr> Jan_w: you need ghc to build ghc
11:09:45 <Jan_w> ghc has a circular dependancy on itself ?
11:09:56 <shapr> sure, ghc is written in Haskell.
11:10:08 <shapr> just like gcc is written in C
11:10:23 <Jan_w> makes you wonder how the first ghc v1 was written
11:10:29 <thebug> very carefully
11:10:43 <shapr> 'bootstrapping' is a sexy thing
11:10:48 <Jan_w> so i can never install ghc on a system that does not yet have ghc ?
11:10:48 <esap> "very carefully" is a good answer to almost any question.
11:11:01 <thebug> :)
11:11:27 <musasabi> Jan_w: you can use ghc sources which have been compiled to C to compile a version of ghc and then compile ghc with that.
11:11:34 <bbls> Jan_w http://www.bordergatewayprotocol.net/jon/humor/web_animations/Recursive.swf :))
11:12:04 <Jan_w> bbls: yea, seen it :)
11:12:07 <bbls> :)
11:12:58 <Jan_w> any haskell on win32 users here?
11:13:27 <Jan_w> i have what appears to be a win32-dll specific problem
11:17:28 <shapr> zamer: do you know Fractal?
11:17:39 <zamer> no
11:17:45 <shapr> oh, too bad.
11:17:51 <shapr> would you like to learn Haskell?
11:18:21 <zamer> why not :)
11:18:26 <shapr> excellente!
11:18:34 <zamer> i'm reading the links on topic
11:18:43 <shapr> do you have any prior functional programming experience? scheme, elisp, common lisp?
11:18:53 <zamer> c programming :)
11:19:01 <shapr> ah
11:19:33 <shapr> shall I give you the short tour of #haskell?
11:19:45 <zamer> yeah :)
11:19:48 <shapr> awright
11:19:56 <shapr> here on the channel we have the 'bot lambdabot 
11:19:57 <shapr> @yow
11:19:59 <lambdabot> I'm CONTROLLED by the CIA!!  EVERYONE is controlled by the CIA!!
11:20:03 <shapr> he's written in Haskell, and make a great code-toy
11:20:16 <zamer> huuh
11:20:18 <zamer> :)
11:20:20 <shapr> In the channel topic you'll see the url to the learning page and the irc logs
11:20:39 <shapr> the Haskell wiki has lots of great info
11:20:45 <shapr> um, I always forget something...
11:20:51 <shapr> hmm
11:21:18 <shapr> oh! I remember!
11:21:21 <zamer> :)
11:21:33 <shapr> here on the learning page: http://www.haskell.org/learning.html
11:21:36 <shapr> lots of links to good stuff
11:21:57 <shapr> if you want to start out without purchasing a book on Haskell
11:22:08 <shapr> Has Daume's tutorial "Yet Another Haskell Tutorial" is really good for that.
11:22:41 <shapr> lambdabot has useful commands to find named functions in the libraries
11:22:41 <zamer> ok
11:22:43 <shapr> @index foldr
11:22:45 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
11:23:06 <shapr> I would recommend that you use the Glasgow Haskell Compiler, aka GHC
11:23:14 <shapr> it has a nice interactive mode called GHCi
11:23:31 <shapr> are you using windows? or a particular linux distro?
11:23:36 <zamer> slackware
11:23:52 <shapr> I don't know if there are GHC packages for slackware.
11:25:52 <shapr> zamer: have you found any GHC packges for slackware?
11:26:07 <shapr> my short google search only leads me to believe I know nothing about slackware...
11:27:15 <zamer> lol
11:27:33 <zamer> i haven't found that
11:28:31 <zamer> yet
11:28:33 <shapr> well, if you find a ghc6 package for slackware, that's the easy way to go
11:29:15 <jfpf> shapr, you don't need the slackware package.. get the binary distribution and install it (/usr/local/ghc for instance;)
11:29:23 <shapr> ah, ok
11:29:25 <zamer> yeah
11:29:36 <shapr> zamer: http://www.haskell.org/ghc/download_ghc_621.html
11:29:47 <jfpf> shapr, I use slackware and I've done that
11:30:06 <shapr> ok, I'll remember that for the next time a slackware user asks me.
11:30:35 <vegai> shapr is the cyborg of the channel :-P
11:30:41 <jfpf> shapr, that was for zamer, sorry :P
11:30:50 <shapr> zamer: anyway, once you've got ghc installed, the Haskell demo for the impatient is http://www.scannedinavian.org/AvianWiki/HaskellDemo
11:31:00 <Marvin--> wow, John Goerzen sure isn't wasting any time, is he
11:31:12 <shapr> vegai: resistance is futile, capacitance is the only acceptable way!
11:31:18 <shapr> Marvin--: no kidding, I like this guy.
11:31:32 <shapr> now I just have to get off my butt and build these c2hs debs...
11:32:03 <zamer> ok i'll see that
11:32:06 <zamer> thanks shapr ;)
11:32:10 <zamer> bye, good night
11:32:13 <shapr> g'night!
11:32:24 <zamer> :)
11:32:38 <shapr> hm
11:32:47 <shapr> I was willing to walk him through all the beginning stuff :-)
11:33:17 <raboof> http://www.cyborgname.com/cybimages/S/governor2k3-SHAPR.jpg
11:35:51 <Maddas> shapr: haha (resistance)
11:39:57 <mattam> isn't (<:>) :: some_type the correct syntax for defining operators ?
11:40:25 <bbls> haha :)
11:40:30 <bbls> http://www.cyborgname.com/cyborger.cgi?acronym=BBLS&robotchoice=governor2k3
11:40:31 <bbls> :)
11:43:18 <mattam> @type (:)
11:43:19 <lambdabot> (:) :: forall a. a -> [a] -> [a]
11:43:34 <shapr> raboof: haha
11:44:04 <Marvin--> mattam: yes, that ought to work, if some_type is on the form T1 -> T2 -> T3
11:45:27 <Marvin--> Igloo: ping
11:46:05 <Igloo> I'm hereish
11:46:35 <Marvin--> Igloo: would you mind approving my silly d-haskell posting that I sent from my gmail account that I forgot wasn't subscribed to the list? :)
11:46:55 <Marvin--> (I subscribed now, but it's such a bother to re-send the mail...)
11:48:24 <Igloo> Done
11:49:12 <Marvin--> thanks :)
11:50:54 <Marvin--> mattam: what kind of errors are you getting?
11:56:01 <mattam> i used the wrong chars
11:57:03 <Marvin--> oh :)
11:58:54 <Muad_Dib> hi all
11:59:46 <Marvin--> eeek, the jyhad is near
11:59:49 <raboof> little mouse
12:00:32 <Muad_Dib> hehe :)
12:00:49 <Muad_Dib> maybe you can tell the little mouse exactly what this means:
12:00:57 <Muad_Dib> data Blaat = Blaat{ test :: Test }
12:01:12 <Muad_Dib> or more generally, how to use the { } in a data type :P
12:02:25 <Marvin--> it basically is the same as  data Blaat = Blaat Test + some more syntactic sugar
12:02:32 <vegai> compiling darcs is hurting my poor little box :/
12:02:52 <Muad_Dib> ah okay
12:03:11 <Muad_Dib> so can i also do data Blaat = Blaat{ test::Test test2::Test2 } ?
12:03:14 <Marvin--> Muad_Dib: for example, you'll get a function  test :: Blaat -> Test, and you can use the record syntax in pattern matching and record updates
12:03:38 <Marvin--> Muad_Dib: yes, but with commas between the selectors
12:03:45 <Muad_Dib> aah okay :)
12:04:24 <Marvin--> Muad_Dib: you can even do nifty things like  data Foo = F1 { f :: Int, g :: Float } | F2 { f :: Int, h :: Char }
12:05:13 <Marvin--> which means f will work for both F1 and F2, but g and h will only work for F1 and F2 respectively
12:06:54 <Muad_Dib> cool :)
12:20:02 <vegai> hmm
12:20:19 <vegai> is it probably normal that compiling Patch.lhs from darcs takes a very long time on a low-end machine?
12:25:06 <Marvin--> took about two minutes on my Athlon 1600+ and lots of memory, so... yeah
12:29:30 <vegai> that's where the magic happens then, eh?
12:30:02 <Marvin--> pretty much :)
12:32:42 <shapr> hey pesco, I want instances of pescosity
12:33:09 <shapr> the beautiful future
12:35:44 <shapr> I like John Goerzen
12:36:20 <shapr> where's the source for MissingH?
12:36:50 <Marvin--> didn't he include a url? that's standard for ITPs
12:37:20 <shapr> er, where's the ITP? :-/
12:37:31 <Marvin--> on debian-devel or in wnpp on www.d.o
12:37:33 <shapr> the mention on debian-haskell is the first I've seen.
12:37:53 <Marvin--> WTF
12:38:00 <Marvin--> a *gopher* address?!
12:38:09 <shapr> yah, he seems to like gopher
12:38:31 <shapr> any idea of the bug number?
12:39:09 <Marvin--> go to www.d.o/devel/wnpp
12:39:21 <shapr> ok
12:39:51 <raboof> gopher? wow. 
12:39:54 <raboof> i've heard of that ;)
12:40:52 <shapr> where in there do I find the missingh itp?
12:40:57 * shapr feels clueless
12:41:57 <Jan_w> gopher? cool, so '70 
12:42:23 <Marvin--> shapr: ah, the page is probably not regenerated all the time
12:42:31 <kristnjov> i've only briefly read about gopher in an html handbook
12:42:47 <Marvin--> shapr: then look at #275070, but I just talked to him and the missingh page isn't up yet
12:42:51 <shapr> aha
12:43:24 <shapr> I used gopher before that upstart NCSA Mosiac browser was released.
12:43:29 <shapr> it sucked ass
12:43:35 <shapr> I had to manually type in urls all the time
12:43:41 <Jan_w> What was Gopher?
12:43:41 <shapr> after seeing them on the page
12:43:41 <Jan_w> Gopher service was a hierarchically designed menu system for browsing file and text archives. It is a tool that was developed by students at the University of Minnesota that creates menus that allow you to access network resources by moving an on-screen cursor.
12:45:09 * shapr looks up Goerzen's MissingLib for OCaml
12:46:02 <shapr> Marvin--: so, is he going to visit #haskell?
12:46:46 <shapr> MissingLib seems simple enough.
12:46:55 <shapr> PreludeExts has a lot more stuff.
12:48:28 <shapr> psi: speaking of which, "rmap fs x = map ($ x) fs"
12:49:17 <shapr> psi: that applies a list of functions to a value
12:50:28 <shapr> geez, PreludeExts is huge.
12:51:42 <Marvin--> yeah, it ought to be trimmed a bit, and as Igloo said on the list, probably merged with MissingH, and probably put in a nice hierarchical lib
12:52:34 <Marvin--> CosmicRay said he's come by here after the SPI meeting
12:52:51 <shapr> er, is cosmicray john goerzen?
12:53:23 <Marvin--> yes
12:53:28 <shapr> oh
12:53:29 <shapr> neat
12:56:11 <shapr> Marvin--: one for your quotes
12:56:14 <shapr> <hannes> "Aj säääd it is blååååvinG tvenn-ty tooo miters pär seckånd!"
12:56:28 <shapr> and for my quotes
12:57:53 * CosmicRay looks around for Debian haskellers
12:58:47 * polli points at shapr 
12:58:57 <polli> doh
12:59:19 <Marvin--> CosmicRay: hey :)
12:59:27 * Marvin-- points out Igloo too
13:00:24 <CosmicRay> shapr eh
13:00:30 <CosmicRay> I've seen him somewhere else before
13:01:12 <CosmicRay> well anyway, I'm looking for any reason not to dupload some haskell stuff to sid
13:01:19 <CosmicRay> the stuff I ITP'd
13:01:40 * shapr grumbles
13:01:48 <shapr> greetings CosmicRay 
13:01:51 <CosmicRay> hello shapr
13:01:56 <CosmicRay> <CosmicRay> well anyway, I'm looking for any reason not to dupload some haskell stuff to sid
13:02:21 <shapr> personally, I'd be thrilled with HSQL and HaskellDB debs
13:02:29 <Marvin--> well, I agree with Igloo, if we're happy with the package naming we've worked out, the other stuff isn't too hard to fix later
13:02:29 <shapr> btw, I'm Shae Erisson
13:02:45 <shapr> CosmicRay: and you're John Goerzen
13:02:49 <CosmicRay> yes.
13:02:51 <Marvin--> too bad Syntax isn't here
13:02:56 <Marvin--> @seen SyntaxNinja
13:02:57 <lambdabot> I haven't seen SyntaxNinja
13:02:59 <CosmicRay> who is Syntax?
13:03:03 <shapr> @seen SyntaxLaptop
13:03:04 <Marvin--> Isaac Jones
13:03:04 <lambdabot> I saw SyntaxLaptop leaving #haskell 4 hours 1 minute 45 seconds ago.
13:03:06 <CosmicRay> ah.
13:03:23 <shapr> hm, what else...
13:03:26 <CosmicRay> anyway I'm perfectly happy to turn haskell-cabal over to him if he wants to maintain it
13:03:35 <CosmicRay> but his debian/ is not ready for sid
13:03:47 <Marvin--> right
13:04:14 <shapr> oh, debs for FGL, halipeto, greencard, fudgets, GF, yampa...
13:04:27 <Marvin--> but I agree, upload it and let's see what happens
13:04:28 <shapr> lambdabot debs, yes =)
13:04:32 * shapr cackles greedily
13:04:33 <Marvin--> I guess I should get around to making that gtk2hs upload too
13:04:34 <CosmicRay> Marvin--: cool.
13:04:59 <CosmicRay> I shall upload that and then get cracking on my other ITPs then.
13:05:04 <CosmicRay> expect to see at least missingh today
13:05:08 <shapr> oh hey
13:05:15 <shapr> I'm the primary instigator of PreludeExts
13:05:19 <CosmicRay> shapr: ahh
13:05:49 <shapr> The people who wrote PreludeExts code into the wiki did not give explicit licenses.
13:05:52 <CosmicRay> shapr: it would be really cool (TM) if: 1) the legal status of all that were more clear, and 2) it were organized in real .hs files
13:05:56 <shapr> right
13:05:57 <CosmicRay> 2) I can do
13:06:02 <CosmicRay> 1) I'm not so sure about
13:06:07 <CosmicRay> and without it we can't put it into debian
13:06:14 <shapr> I can contact the people.
13:06:19 <CosmicRay> that would be excellent
13:06:20 <shapr> and ask for explicit licenses.
13:06:25 <Marvin--> I'm thinking MissingH should probably go somewhere under the Unstable hierarchy
13:06:58 <Marvin--> if the intention is to get much of it into the standard distributions
13:07:00 <Igloo> Isn't there a user hierarchy?
13:07:08 <CosmicRay> Marvin--: hmm.  that would be excellent.
13:07:09 <Marvin--> hm
13:07:11 <Igloo> Oh, well, it depends on the intention, too
13:07:13 <CosmicRay> Marvin--: I'm not ready for that yet though
13:07:15 <shapr> most people put stuff under Unstable.Name
13:07:18 <shapr> from what I've seen
13:07:30 <CosmicRay> Marvin--: theck out http://quux.org/devel/missinglib/ for the basic idea
13:07:35 <CosmicRay> that's my similar OCaml library
13:07:41 <Marvin--> CosmicRay: yeah, I found it
13:07:46 <shapr> I looked at MissingLib, it's pretty straightforward.
13:07:56 <shapr> PreludeExts has some more unusual stuff.
13:08:03 <shapr> adjunction for example
13:08:10 <shapr> and I still don't really know what that is.
13:08:13 <shapr> esap: hey
13:08:24 * esap thinks adjunction is not unusual :-)
13:08:24 <CosmicRay> here, I'm dccing you the docs for what I have so far with missingh
13:08:25 <Igloo> Yikes, surely ocaml has a function composition operator?
13:08:26 <shapr> esap: can you explicitly license your PreludeExts code :-)
13:08:30 <CosmicRay> Igloo: no
13:08:50 <esap> shapr: sure, I wasn't aware that was needed, but sure.
13:09:06 <shapr> esap: it's needed if it's going into a deb
13:09:14 <Igloo> shapr: My minute contribution can be treated as PD
13:09:22 <Igloo> In fact it's probably not copyrightable anyway
13:09:23 <shapr> esap: could you cut out the code you wrote and license it?
13:09:32 <CosmicRay> I've got some cool stuff in IOutil
13:09:45 <shapr> Igloo: you wrote box, and what else?
13:09:55 <shapr> Cale: can you license your code in PreludeExts?
13:09:58 <Igloo> I think that's it  :-)
13:09:59 <CosmicRay> versions of interact over arbitrary file handles, automatically working with lines, or binary blocks, etc.
13:10:12 <Igloo> Can someone translate (\x -> x+1) to ocaml please?
13:10:19 <CosmicRay> Igloo: fun x -> x + 1
13:10:26 <esap> shapr: can I do it into the preludeExts page, or what do you have in mind?
13:10:30 <Igloo> Ta
13:10:33 <CosmicRay> Igloo: for ints.
13:10:54 <shapr> er, good question
13:11:00 <Cale> shapr: whatever license you think would be suitable -- I was thinking public domain
13:11:24 <shapr> the 'safest' legally speaking is to have a separate file with the license
13:11:34 <shapr> why don't I just create LicensedPreludeExts ?
13:11:40 <shapr> and put the lGPL at the top? sounds okay?
13:11:45 <CosmicRay> shapr: 3-clause BSD seems common for haskell stuff
13:11:55 <CosmicRay> shapr: it's fairly liberal and would work well for that
13:12:03 <CosmicRay> shapr: /usr/share/common-licenses/BSD
13:12:04 <shapr> having been screwed out of code by various companies, I'm fond of lGPL
13:12:08 <Marvin--> meh, Simon's hierlibs docs don't even talk about Unstable, but that seems to be what people are using
13:12:12 <CosmicRay> I use GPL for everything myself
13:12:19 <shapr> well, lGPL is nice for libs
13:12:26 <Igloo> I'd prefer PD for this, I think. It might want to end up in the report, or an extension to it, for example
13:12:33 <CosmicRay> Marvin--: is there anyreason that I should use Unstable.MissingH.Foo instead of MissingH.Foo?
13:12:35 <Igloo> Although BSD might do for that too
13:12:41 <CosmicRay> Igloo: I think BSD would do fine for that
13:12:58 <shapr> Igloo: bits of PreludeExts end up in the report?
13:13:06 <CosmicRay> shapr: yeah, if anybody asks me to license things under BSD or LGPL, I usually will agree to do it
13:13:14 <shapr> hm, ok. BSD sounds good.
13:13:29 <Igloo> Wasn't the original motivation to collect things to go into the prelude and standard libraries in Haskell 2?
13:13:31 <Marvin--> CosmicRay: well, hopefully the hierarchical libs may some day be standardized and become an addendum to H98, and Unstable.stuff is what a lot of others use
13:13:34 <shapr> Igloo: yes!
13:14:04 <shapr> CosmicRay: is it acceptable to create a new wiki page that explicitly says that all code herein is BSD licensed?
13:14:20 <shapr> then I can move over the code I'm sure about, and email the others
13:14:25 <CosmicRay> shapr: as long as it's clear that the copyright owners have agreed to it
13:14:37 <shapr> how do I make that clear?
13:14:42 <CosmicRay> shapr: in that case yes, as long as you still attribute it
13:14:56 <shapr> "by adding code to this page, you agree to license it under the BSD license" ?
13:15:10 <CosmicRay> shapr: "All code on this page is copyrighted.  The authors have agreed to make it available to you under the license at [wherever].  Copyright is held by the individual authors listed below."
13:15:34 <CosmicRay> shapr: oh, good point.  "If you add code to this page, you agree to license it under these same terms."
13:15:53 <shapr> awright
13:16:40 <shapr> http://www.haskell.org/hawiki/LicensedPreludeExts
13:17:02 <Igloo> CosmicRay: Re package names, policy is right for nhc and ghc, but for hugs the -dev suffix should be dropped
13:17:19 <shapr> @seen riastradh
13:17:19 <lambdabot> I haven't seen riastradh
13:17:25 <CosmicRay> Igloo: I couldn't find any support for hugs in cabal -- but for that, I just cp it in place somewhere, right/
13:17:52 <CosmicRay> well would -dev apply for ghc6, due to ghci?
13:18:14 <Marvin--> I'm sure Syntax would love some help with hugs support in cabal .)
13:18:15 * Igloo looks at Marvin
13:18:44 <Marvin--> Igloo: ?
13:19:05 <shapr> esap: you want to copy your code over into the new page, or shall I copy it over and you check it to make sure Igot it right?
13:19:08 <Igloo> You answered the line above. Don't mind me.
13:19:23 * esap just put it in.
13:19:34 <Marvin--> I haven't had time to do any Cabal work for some time
13:20:01 <shapr> esap: thanks :-)
13:20:09 <Igloo> -dev for ghc6 is an approximation. It's not ideal, but in practice people are unlikely to make debs that use ghci to run a program in the way hugs does, and use of ghci itself fits into the -dev category IMO
13:20:10 <shapr> Igloo: may I copy over your code?
13:20:44 <Igloo> If cabal made it easy to have the ghc and ghci files separately installed then we'd do that, but as it stands it's not worth the effort
13:20:52 <Igloo> shapr: The PE stuff? Yes.
13:20:58 <shapr> ok
13:22:16 * shapr wonders who Scott Turner is...
13:22:53 <Marvin--> seeing as both the packages for ghc and the packages for ghci would need the .hi files but they're otherwise independent it'd be a PITA to put them in separate packages
13:23:35 <Igloo> Oh, good point. I was just thinking of it being a pain to get ghc-pkg to do the right thing.
13:23:52 <Marvin--> yeah, that too
13:24:07 <Marvin--> thus we conclude there are several good reasons to just have a -dev package :)
13:25:01 <Marvin--> it kinda sucks that different ghc6 versions are incompatible
13:25:15 <Marvin--> but having libghc6.2.1-foo-dev sucks even worse :)
13:25:44 <Marvin--> especially if it means having ghc6.2.1, ghc6.2.2, ghc6.4 etc. packages
13:25:59 <Igloo> Especially given the NEW time delay
13:26:06 <shapr> ?
13:26:09 <shapr> what time delay?
13:26:29 <Igloo> It takes a week or two for the ftp-masters to let a package with a new name into unstable
13:26:36 <CosmicRay> btw, why do we still support ghc5?
13:26:56 <Marvin--> python has it easy, since you're guaranteed to have compatability in all X.Y versions
13:26:58 <shapr> yuck
13:27:11 <CosmicRay> we should not be supporting multiple ghc6 versions
13:27:25 <CosmicRay> the only reason to do that is if there are source-level incompatibilities that are non-trivially fixed
13:27:33 <CosmicRay> binary incompatibilities should be fixed by recompilation
13:27:36 <CosmicRay> (as the policy states)
13:27:52 <Igloo> Once sarge releases I'll file for ghc5's removal if its presence becomes a problem
13:27:54 <Marvin--> CosmicRay: because ghc5 is in stable and we want an upgrade path somehow?
13:28:09 <CosmicRay> Marvin--: why don't we have a package ghc that depends on ghc6?
13:28:17 <CosmicRay> Marvin--: and have it provide and replace ghc5
13:28:21 <Marvin--> CosmicRay: ask the ghc maintainer ;)
13:28:31 <CosmicRay> Marvin--: in the futurue when ghc7 comes out, we can just adjust that
13:28:49 <CosmicRay> but since ghc is not used to run anything -- only to build it -- it's not such a great problem imho
13:28:58 <CosmicRay> so basically we have ghc5 because we're too lazy to get rid of it? :-)
13:29:05 <shapr> ghc6 may be used to run things in the future.
13:29:10 <Marvin--> hey, laziness is good, remember ;)
13:29:13 <shapr> haha
13:29:16 <shapr> greetings viv 
13:29:16 <CosmicRay> lol
13:29:20 <Marvin--> (besides, we're still using ghc5 at work)
13:29:22 <Igloo> Some people still use it, and have source that they haven't bothered to change yet. I didn't see any pressing need to remove it.
13:29:37 <CosmicRay> oh, so there are source-level incompatibilities?
13:29:40 <Igloo> Also, lots of people try to support it, so having it around is useful
13:29:48 <Igloo> Yup
13:31:04 <Marvin--> eek, 148 patches since I updated cabal last time
13:31:15 <Marvin--> darcs pull --all it is
13:32:54 <TheHunter> speaking of categorical stuff, i think you might consider Dave Menendez's stuff, especially Control.Recursion (http://www.eyrie.org/~zednenem/2004/hsce/, appears to be PD)
13:34:55 <shapr> well, he wrote it
13:35:03 <shapr> and says he claims no ownership, hmm
13:35:07 <shapr> TheHunter: any other suggestions?
13:35:18 <shapr> anyone have more suggestions for stuff to add to PreludeExts?
13:35:26 <shapr> licensed or not, I'd like to hear about it.
13:35:53 <Marvin--> am I the only one who thinks that category theoretical crud don't belong in a *Prelude*?
13:36:04 <shapr> err, well
13:36:09 <shapr> map is CT crud too :-)
13:36:12 <esap> I've recently done some things to represent monos and epis, but I'm not sure it's good enough for inclusion.
13:36:18 <TheHunter> is this supposed to be "a prelude" or hierarchily organized?
13:36:30 <shapr> I dunno
13:36:37 <shapr> the Prelude part is most interesting to begin with
13:36:58 <shapr> it all started with the fiftieth person showing up and asking for 'permute'
13:38:06 * shapr shrugs
13:38:16 <shapr> send me suggestions, I'll try to organize them.
13:38:18 <esap> Another thing that might be of interest is a support for OO. But maybe it should be just for an ordinary library.
13:43:55 <CosmicRay> indeed.
13:44:37 <CosmicRay> according to my read of the hierarchical libraries standard, I could use Org.Quux.MissingH.foo or jsut MissingH.foo
13:44:49 <CosmicRay> though theoretically the latter could be a problem if someone else wants to use MissingH.foo
13:44:51 <CosmicRay> which I doubt
13:46:18 * CosmicRay uploads libghc6-haskell-dev to sid.
13:46:24 <CosmicRay> err
13:46:26 <CosmicRay> make that -cabal-dev
13:46:27 <CosmicRay> heh
13:52:18 <Marvin--> libghc6-cabal-dev?
13:52:30 <CosmicRay> that's the ./setup magic to make thigns go into /usr/lib/haskell-libraries/ghc6/foo?
13:52:33 <CosmicRay> yup, the cabal package.
13:52:41 <CosmicRay> s/that/what/
13:53:17 <Marvin--> I'm not sure cabal and the debian-haskell-policy match up 100% :)
13:53:35 <CosmicRay> yeah I was, erm, noticing that
13:57:19 * Marvin-- yawns
13:57:37 <Marvin--> man I'm tired, I'm going to go sleep
14:18:44 <jfpf> What is the format of $HUGSLIB variable? Isn't HUGSLIB=.:dir1:dir2:...:dirn ?
14:57:52 <shapr> yay, more LicensedPreludeExts
15:04:28 <Philippa> shapr: PM
15:08:18 <bourbaki_> why is there no haskell song?
15:08:22 <bourbaki_> http://www.cs.unm.edu/~williams/cs257/the_eternal_flame_god_wro.mp3
15:08:26 <bourbaki_> like that for lisp
15:08:41 <shapr> I can write a Haskell song for you.
15:08:48 <shapr> I can even sing it for you =)
15:08:51 <bourbaki_> :)
15:09:06 <Philippa> "open parenthesis sing open parenthesis about..."
15:09:08 <bourbaki_> do you know that song?
15:09:19 * shapr sings about the soft curried lambdas grazing in the fields
15:09:43 <shapr> the bulging foreheads that inspired weak head normal form
15:10:03 <bourbaki_> that sounds like a rap ;)
15:10:22 <Philippa> what, all the monosyllabic words?
15:10:28 <shapr> the real story of the thick glasses lost in a market place that brought us the famous bananas, lenses, barbed wire, and envelopes paper.
15:12:20 <bourbaki_> when will be the next tv meeting of bush and kerry?
15:19:40 * shapr dunno
15:21:25 <bourbaki_> can you have something like a global variable in haskell?
15:21:32 <shapr> yes
15:21:33 <Igloo> First you'll need to write your lyric combinators, though
15:21:40 <shapr> Igloo: ohoooh
15:21:44 <shapr> that sounds cool
15:21:51 <Igloo> Yeah, I thought that might get you going  :-)
15:22:13 * shapr thinks
15:22:28 <bourbaki_> so i can write selfmodifing objects as well
15:22:31 <Igloo> You might want something to deal with homonyms and puns, too...
15:22:47 <bourbaki_> puns?
15:22:51 <Igloo> bourbaki_: You /probably/ want a State monad, or StateT transofrmed monad
15:23:01 <Igloo> The puns line was to shapr
15:23:09 <bourbaki_> yeah i know :)
15:23:25 <shapr> Song (Rhyme Aabba) (Tempo FourFour)
15:23:30 <Igloo> Oh, well, just that a lot of lyrics tend to deal with words with double meanings, and perhaps more generally puns
15:23:43 <bourbaki_> what i want is a function in one of my networks thats able to modify the network it self
15:23:54 <bourbaki_> what was fun is a haskell haiku genarator
15:24:06 <shapr> bourbaki_: look at the Yampa combinators
15:24:15 <shapr> they can modify themselves
15:24:34 <bourbaki_> fromwithin themself?
15:24:37 <shapr> yup
15:25:04 <bourbaki_> hm do you happen to know how they do that?
15:25:13 <shapr> sure, they use arrows.
15:25:24 <shapr> http://www.haskell.org/yampa/
15:25:30 <shapr> read the Yampa papers, they're way cool
15:26:00 <bourbaki_> my problem is that if i would build a network like i told you the last time
15:26:07 <bourbaki_> that models a class like in c++
15:26:25 <bourbaki_> where you have one edge that gets and one edge that sets a val
15:26:34 <bourbaki_> then the getting thing wont be a big deal
15:26:47 <bourbaki_> but the function that sets a value would have to modify itself
15:27:01 <bourbaki_> that is modify the get function actually
15:27:15 <bourbaki_> and thats not really side effect free is it?
15:28:38 <Philippa> well no, that's why arrows look a good match
15:29:09 <Philippa> in fact, arrows make a /very/ good match for an OO(ish) framework - consider the combinators and the stuff you build from them as objects and you're building wiring between them...
15:29:17 <Philippa> (the syntax obscures that a bit, mind)
15:30:09 <bourbaki_> so these arrows arent side effect free themselfs?
15:30:31 <Philippa> the eventual RunThisThroughSomeArrows func is, the stuff inside isn't
15:30:34 <bourbaki_> my prob is that this would make things a little ugly acutally imho
15:30:37 <Philippa> bit like monads
15:30:48 <Philippa> well, a lot like monads as arrows subsume them :-)
15:31:18 <bourbaki_> can you give me a quit intro to arrows?
15:31:52 <Philippa> er, maybe if I wasn't braindead tired. www.haskell.org/arrows/ has some useful info though
15:33:00 <bourbaki_> can you so something like the categorical sum and prudct with them?
15:34:42 <bourbaki_> what i often need for my stuff is to split things in more then one process so to say
15:34:48 <bourbaki_> or join them again
15:35:17 <Philippa> yeah, something a bit like a categorical product (but with ordering/side-effects) is in the basic signiature and there's a matching sum in an ArrowChoice class
15:39:34 <Philippa> there's an equivalent of return, so you can do arbitrary routing
15:39:58 <Philippa> black boxes and \wiring :-)
15:41:32 <bourbaki_> hm
15:42:40 <bourbaki_> but i cant have one input to an arrow and have two outputs right?
15:42:50 <Philippa> sure you can
15:42:53 <Philippa> the arrow outputs a product
15:42:59 <Philippa> tuples being the product type
15:45:07 <bourbaki_> can you also combine more then one function to one inpput?
15:45:39 <Philippa> combine in what way?
15:46:06 <Philippa> if you want to do a tupled input there's a combinator. Currying depends on whether the arrow supports it (if it does it's equivalent to a monad)
15:46:15 <bourbaki_> imagine you had a channel like this and there would arive somedata and there are more then one function to process that data
15:46:37 <TheHunter> if the input is a sum type, you can.
15:46:54 <bourbaki_> why a sum?
15:47:04 <bourbaki_> and i could do even if it was just a normal type
15:47:18 <bourbaki_> i can process it with different strategies
15:47:20 <Philippa> you'd use a sum if it's going to only one of those functions - demux
15:47:37 <bourbaki_> demux?
15:47:45 <Philippa> de-multiplexing
15:48:08 <bourbaki_> aha and what are the attributes of a sum type?
15:48:33 <Philippa> it looks like Either :-)
15:48:42 <Philippa> in fact, IIRC Either /is/ the sum type
15:48:53 <Philippa> (in the Haskell implementation)
15:49:01 <bourbaki_> either was like this either a b = a | b ?
15:49:10 <TheHunter> a sum type is Either, that is if your Input can either be an a or a b, and you have to arrows from a to c and b to c, you can build an arrow from a + b to c
15:49:28 <Philippa> if you just want to pair something and send it to two functions and get two outputs, you do something >>> a &&& b
15:49:30 <bourbaki_> so you either pick the one or the other function ok thats quite reasonable
15:50:10 <bourbaki_> has anyone written a neural net with arrows yet?
15:50:16 <Philippa> I'm not aware of it
15:50:29 <Philippa> then again, I've not been looking out for it either
15:50:30 <bourbaki_> well i think ill have a closer look at arrows then
15:50:54 <bourbaki_> it seems as if it will spare me some work on the implementation of my stuff
15:50:56 <TheHunter> i think john hughes' first paper is a good place to start
15:51:30 <bourbaki_> i just need to convert a network to something that uses arrows in the end
15:51:36 <shapr> I found paterson's FoP chapter more palatable.
15:51:39 <bourbaki_> and that sounds as if it was managable
15:52:34 <bourbaki_> is there an editor for arrows yet?
15:52:39 <shapr> ?
15:53:14 <TheHunter> there is a special syntax for arrows, somewhat similar to the do-notation and reflecting their first order character
15:53:16 <bourbaki_> well to me it sounds as if it was possible to write a visual editor for that
15:54:06 <TheHunter> we first need an editor for usual haskell code!
15:54:11 <bourbaki_> and yampa does what with arrows?
15:55:36 <shapr> yampa is a reactive framework
15:56:08 <shapr> Hudak and some others have been studying functional embedded system for years.
15:56:32 <bourbaki_> and yampa can be self modifying?
15:56:33 <shapr> They've looked at industrial robotics, choreographing dance, all sorts of neat stuff
15:57:05 <shapr> One of their problems was that space leaks seemed to always happen
15:57:16 <bourbaki_> another prob i have is how i can add edges to my network from within the network itself
15:57:20 <shapr> they tried a variety of approaches, and ended up with Yampa, which seems to work
15:57:31 <bourbaki_> space leaks meaning what? i have read that
15:58:12 <shapr> a space leak is where something doesn't get evaluated or garbage collected when you really wish it would
15:58:17 <TheHunter> time leak =~= endless loop, space leak =~= memory overflow
15:59:08 <shapr> space leaks started the whole process that turned out arrows
15:59:11 <bourbaki_> ok but how can something that isnt useing side effects produce a mem overflow?
15:59:34 <TheHunter> it's ridiculously easy
15:59:34 <shapr> with monadic parsers, the 'next piece' of a parser is a function
15:59:35 <bourbaki_> and how can you make sure that something that has cycles is terminateing?
15:59:55 <shapr> a function is opaque, all you get to do is call it with input
15:59:58 <TheHunter> i think space leaks are the biggest problem of lazily evaluated langs
16:00:09 <shapr> so, all you can do with a monadic parser is call the next piece
16:00:16 <shapr> TheHunter: yes, I agree
16:00:21 <bourbaki_> hm
16:00:37 <bourbaki_> ok i will start to think about that when it happens i guess :)
16:00:47 <shapr> so, sometimes you would have two alternatives in a parser
16:00:56 <bourbaki_> but how do you want to omit something like time leaks?
16:01:02 <shapr> let's say you're parsing -foo or -bar for a command line options library
16:01:02 <bourbaki_> yes
16:01:10 <bourbaki_> thats perfectly fine with me
16:01:26 <shapr> the programmer knows that once the 'f' character is accepted
16:01:39 <shapr> then it's highly unlikely any of the other options will start with -f also
16:01:53 <shapr> so at that point, we could throw away the original input string that we're keeping in the memory
16:02:06 <bourbaki_> well if its mutaly exclusive you have that either thing right?
16:02:17 <shapr> but it's not mutually exclusive
16:02:18 <bourbaki_> but if it isnt you have to process the stuff
16:02:30 <shapr> what if the param you have is actually -flub ?
16:02:38 <shapr> then you have to fail out of parsing the -foo option
16:02:42 <shapr> and go to the next option
16:02:49 <TheHunter> hi roconnor 
16:03:04 <bourbaki_> ok and how does arrow help me there?
16:03:17 <bourbaki_> hidiho roconnor 
16:03:21 <shapr> so, the problem with monadic parsing was that you often had to hang onto really big input strings when you knew you weren't going to need them.
16:03:21 <roconnor> hi everybody
16:03:34 <shapr> that's a 'space leak'
16:03:52 * TheHunter gets another beer
16:04:17 <shapr> well, Doatsie Swierstra and Duponcheel found some parser combinators that didn't have this problem!
16:04:38 <shapr> these other combinators were both a function, and a static description of what they could parse
16:05:06 <shapr> these combinators never ended up making useless functions calls, because they could check it out beforehand
16:05:09 <shapr> tada, no space leak
16:05:19 <shapr> but one problem, these combinators did *not* fit into the monadic model
16:05:31 <bourbaki_> ok that sounds like i wanted to do with my function handler
16:06:01 <bourbaki_> hm
16:06:10 <shapr> some time later (two years?) John Hughes came out with a paper where he wrote about his discovery of something more general than monads
16:06:12 <bourbaki_> sounds reasonable in some way
16:06:32 * roconnor wonders what monadic parsing is
16:06:35 <shapr> and he showed how Swierstra and Duponcheel's combinators are instances of this more general system
16:06:36 <bourbaki_> cause monads dont allow you to split something
16:06:48 <shapr> these more general things are called 'arrows'
16:07:08 <roconnor> that's pretty round-about
16:07:26 <bourbaki_> hm i think ill try to use arrows for my stuff
16:07:58 <TheHunter> i think the stream transformer arrows hughes describes in his paper are worth a look
16:08:09 <bourbaki_> id just need a function that converts a graph of arrows to something that is a computation
16:08:23 <shapr> monads are like first class actions, and arrows are like first class transformations
16:10:37 <bourbaki_> ok so imagine a graph where the edges are arrows
16:10:54 <bourbaki_> and the source nodes are inputs
16:11:16 <bourbaki_> and the sink nodes are output which is kind of the canonial way to look at it when you use arrows i think
16:11:25 <shapr> yup
16:11:38 <bourbaki_> how could you introduce an arrow in this graph that modifies the graph itself?
16:12:00 <bourbaki_> like adding an edge or modify another arrow
16:12:03 <shapr> the Yampa paper talks about that.
16:12:12 * shapr digs into his arrow papers collection
16:12:15 <bourbaki_> roconnor: didnt we talk about that the other day?
16:12:48 <roconnor> I don't think so.
16:12:50 <Philippa> bourbaki_: you could pass the entire graph into another graph
16:13:02 <Philippa> you just turn things inside out then realise it's the same anyway (IO monad, anybody?)
16:13:08 <bourbaki_> of course you can
16:13:33 <Philippa> in particular, you can pull continuations or similar
16:13:39 <bourbaki_> i think what you want to do is that you want to have that arrow as an external second graph right?
16:14:02 <Philippa> doesn't have to be external, can be recursive, but yeha
16:14:04 <Philippa> *yeah
16:14:23 <Philippa> god, if I carry on like that I'll be spelling my language's name "typo" next...
16:14:30 <bourbaki_> :)
16:14:53 * esap has been looking for a good name for a language anyway :-)
16:14:55 <bourbaki_> the problem is that i think that i need to be able to call that arrow from with in the network
16:15:27 <shapr> you can
16:15:39 <shapr> the combinator is called rp something
16:16:12 <bourbaki_> ok but i cant imagine how that is possible
16:16:42 <shapr> it's discussed in the two Yampa papers.
16:16:43 <bourbaki_> you would need somekind of reference in the function and it wouldnt realy be sideeffect free would it?
16:17:04 <bourbaki_> im glad though that they discussed that :) and probably have a good solution :)
16:17:04 <shapr> for example, in the second paper they write code for a UAV traffic drone
16:17:28 <shapr> the drone flies along above traffic and checks for cars that get too close to other cars
16:17:34 <bourbaki_> so i could also write a stack with arrows?
16:17:35 <shapr> each car is represented by an arrow
16:17:51 <shapr> when new cars come into the view of the drone, new arrows are added
16:17:52 <bourbaki_> ah ok and you can add arrows that is cars right?
16:18:02 <bourbaki_> cool ok i just bought it ;)
16:18:17 <bourbaki_> ill read all that stuff then and use it for my stuff
16:18:32 <shapr> personally, I want to use this for a WarCraft clone
16:18:42 <bourbaki_> thats quite cool cause i can concentrate on the other stuff i want to do 
16:18:57 <CosmicRay> hey, where can I get a list of preprocessor symbols a given ghc defines?
16:19:02 <shapr> the 'self-optimizing' and independent nature of arrows would lend itself to a speedy real-time strategy game, I think.
16:19:05 <bourbaki_> if you want to write a game id like to discuss somethings with you
16:19:08 <CosmicRay> cabal doesn't compile with ghc5
16:19:11 <CosmicRay> grr
16:19:18 <bourbaki_> maybe we could make it a sandbox for ais then
16:19:20 <shapr> CosmicRay: what's the error?
16:19:23 <CosmicRay> and I think I just need to import different files
16:19:28 <shapr> oh, I should probably just install ghc5 and see
16:20:11 <shapr> bourbaki_: read up on Yampa first, tell me what you think.
16:20:56 <bourbaki_> sure i would like to use my stuff then though cause i want to have something that makes it possible to combine these yampa modules then and such
16:21:24 <shapr> yampa is all about signal transformers
16:21:26 <bourbaki_> though i think that it will be alot easier in the end then i thought if i am right
16:21:46 <bourbaki_> is yampa capable of concurrency?
16:21:47 <CosmicRay> Compat/RawSystem.hs:9:
16:21:48 <CosmicRay>     Module `System.Cmd' does not export `rawSystem'
16:21:55 <CosmicRay> shapr: that's the problem
16:22:03 <CosmicRay> rawSystem is not in System.Cmd in ghc5
16:22:27 <shapr> hm
16:22:31 <CosmicRay> now that I have libghc6-cabal-dev uploaded, I'm working on libghc5-cabal-dev, libnhc-cabal-dev, and libhugs-cabal-dev
16:22:48 <Philippa> bourbaki_: for what value of concurrency? It'll happily do simulations with entities interacting concurrently, that's kinda the point
16:23:20 <bourbaki_> so i could process data at two points in this graph i spoke about?
16:23:48 <Philippa> yep
16:23:54 <bourbaki_> the thing is that i want to use it for virtual agents and there you can have continous data input from different nodes all the time
16:24:06 <Philippa> it's ideal for virtual agents
16:24:06 <shapr> I think that would work fine.
16:24:14 <Philippa> read The Yampa Arcade
16:24:27 <shapr> oh yeah
16:24:37 <shapr> I got partway into building the Yampa Arcade recently and got distracted
16:24:41 <CosmicRay> shapr: any ideas on the ghc5 thing?
16:24:43 <shapr> it's space invaders :-)
16:24:50 <shapr> CosmicRay: installing ghc5 and friends right now
16:24:58 <CosmicRay> ah danke :-)
16:26:04 <shapr> it's true, rawSystem doesn't exist in ghc5
16:26:13 <shapr> but, it might be quick and easy to backport
16:29:28 <bourbaki_> shapr: do you have a link collection of your yampa and arrow papers? or al
16:29:36 <bourbaki_> are they all accessable from the site?
16:29:40 <shapr> yes, they are
16:29:46 <CosmicRay> shapr: it doesn't have to be backported
16:29:56 <CosmicRay> shapr: compat/rawSystem.hs *is* the backport
16:30:00 <shapr> oh
16:30:01 <CosmicRay> the #ifdef is just wrong
16:30:07 <CosmicRay> and I don't know the right way to fix it
16:30:39 <bourbaki_> are arrows decomposable also?
16:30:50 <shapr> bourbaki_: ?
16:30:51 <Igloo> What does it say now?
16:31:01 <shapr> #ifndef __GLASGOW_HASKELL__
16:31:10 <CosmicRay> exactly
16:31:17 <Igloo> #if __GLASGOW_HASKELL__ < 600
16:31:22 <Igloo> Or some other number as appropriate
16:31:23 <bourbaki_> well you have something like that >>> that combines two arrows right?
16:31:33 <CosmicRay> and that test needs to be rewritten so it is true only for ghc6
16:31:35 <CosmicRay> ah.
16:31:39 <shapr> greetz Heffalum1 
16:31:44 <Heffalum1> EEEK!
16:31:51 <shapr> Heffalump: eh?
16:31:51 <Igloo> Oh, err, #if defined(__GLASGOW_HASKELL__) && (__GLASGOW_HASKELL__ < 600)
16:31:59 <bourbaki_> and i want to have somethig like <<< that yields a tuple of two arrows
16:32:00 <Heffalump> I had a 1.
16:32:03 <Heffalump> 1s are evil.
16:32:05 <Heffalump> clearly.
16:32:09 <bourbaki_> like a coalgebraic operator
16:32:10 <Igloo> Oh smeg, or if it's not defined, YKWIM
16:32:18 <bourbaki_> Heffalump: do you play nwn ?
16:32:24 <Heffalump> whatwhichwhen?
16:32:37 <shapr> bourbaki_: yes, you can get a two tuple
16:32:51 <bourbaki_> so you can decompose a composed arrow ?
16:32:52 <shapr> >>> as the same as flip (.)
16:33:10 <shapr> if you mean splitting a two-tuple, then yes
16:33:21 <shapr> first and second are basic parts of the arrow interface
16:33:35 <bourbaki_> no what i mean is when you compose two arrows to a sequence of computations
16:33:56 <Heffalump> no.
16:34:04 <Heffalump> you can't decompose one in general.
16:34:06 <bourbaki_> then you get a new computation and i want to decompose that thing to two computations atain
16:34:12 <bourbaki_> i thought so
16:34:13 <CosmicRay> shapr: it has to be written inverted...
16:34:15 <CosmicRay> #if !(defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ > 600)
16:34:15 <bourbaki_> thought it would be cool
16:34:18 <CosmicRay> I think that'll do it
16:34:25 <Heffalump> however, I think it should be possible to make an arrow transformer that would make a decomposable arrow out of any existing arrow.
16:34:37 <bourbaki_> then i think ill just crunsh the stuff down to computations when its needed
16:34:41 <Heffalump> since all you'd have to do would be to explicitly keep the structure of anything you built.
16:34:45 <Philippa> yep
16:34:54 <Heffalump> Though it might violate the arrow laws.
16:34:58 <shapr> Heffalump: what bring you here? free time? ;-)
16:34:58 <bourbaki_> which is kind of what i do with that graph
16:35:01 <Philippa> you'd do the list bits etc with products
16:35:17 <Heffalump> shapr: no, foolishness.
16:35:26 <shapr> what are you being foolish about?
16:35:29 <bourbaki_> isnt there a lib yet that combines arrows and graph?
16:35:37 <Heffalump> well, I don't have free time, so spending it here is foolish.
16:35:42 <shapr> oh, ok
16:35:50 <CosmicRay> shapr: I'm trying it again now.
16:35:59 <shapr> me too
16:37:08 <shapr> CosmicRay: changing both checks?
16:37:14 <CosmicRay> yeah
16:37:25 <shapr> works for me
16:37:31 <shapr> with both ghc6 and ghc5
16:37:45 <shapr> you may want to make sure that syntax is handled by cpphs though
16:37:55 <CosmicRay> bah
16:37:59 <CosmicRay>     Module `System.IO' does not export `openBinaryFile'
16:38:02 <shapr> Igloo: can I persuade ghc -cpp to use cpphs?
16:38:07 <CosmicRay> Distribution/Simple/Utils.hs:74:
16:38:07 <CosmicRay>     Module `System.IO' does not export `openBinaryFile'
16:38:10 <Igloo> It ought to be a cpphs bug if it's not
16:38:13 <CosmicRay> How does that work on your system but not mine?
16:38:17 <Igloo> -pgmP cpphs I think
16:38:46 <shapr> CosmicRay: because I'm using a  single ProtoRawSystem.hs file to check the cpp syntax
16:38:57 <CosmicRay> ah
16:39:12 <CosmicRay> and it also pisses me if that ./setup.py build doesn't return an exit code when one of these errors occurs
16:39:37 <shapr> ?
16:39:42 <CosmicRay> err
16:39:44 <CosmicRay> s/.py//
16:39:54 <Igloo> Phew, I was gonna say  :-)
16:39:56 <shapr> you got the distutils part right, but wrong langage ;-)
16:40:00 <CosmicRay> hmm
16:40:01 <Heffalump> hah. Python. *spit* :-)
16:40:03 <CosmicRay> haha
16:40:16 <CosmicRay> err nm, the bug is with my for loop
16:43:00 <Heffalump> hiya
16:43:08 <shapr> Igloo: I think I found a bug
16:43:16 <shapr> g'day Pseudonym 
16:43:28 <Pseudonym> G'day.
16:43:37 <Pseudonym> http://andrew.bromage.org/fluid.mpeg
16:43:41 <shapr> zsh/5 5074 [1] % ghc5 -c -cpp -pgmP cpphs RawSystem.hs
16:43:42 <shapr> Fail: .: openFile: inappropriate type (is a directory)
16:43:46 <Pseudonym> My fluid simulator is coming along nicely.
16:44:05 <Igloo> shapr: Can you add -v and see what command actually failed there?
16:44:10 <shapr> yup
16:45:31 <shapr> cpphs -v -I . -I /usr/lib/ghc-5.04.3/include -D__HASKELL1__=5 -D__GLASGOW_HASKELL__=504 -D__HASKELL98__ -D__CONCURRENT_HASKELL__ -DDONT_WANT_WIN32_DLL_SUPPORT -x c RawSystem.hs -o /tmp/ghc26735.hscpp
16:45:52 <shapr> manual use of cpphs on RawSystem.hs seems to work fine.
16:46:11 <andersca> Pseudonym: that's cool stuff
16:46:24 <Igloo> Hmm, it doesn't know about -x c I don't think
16:46:42 <Igloo> Does that exact command fail in the same way? And does it work if you remove -x c?
16:47:42 <shapr> yes, yes
16:47:45 <shapr> still fails
16:47:51 <Pseudonym> andersca: Thanks.
16:48:03 <shapr> Pseudonym: very spiffy, is that computationally expensive?
16:48:18 <Igloo> Try removing the -v, and if it still fails the spaces after the -Is?
16:48:21 <Pseudonym> It's 128x128, and it takes probably 20 sec per frame.
16:48:25 <Pseudonym> Maybe a little less.
16:48:46 <Pseudonym> But there are a couple of things I can do re optimisation.
16:48:49 <shapr> Igloo: removing spaces seems to have fixed it
16:48:58 <Pseudonym> My sparse linear solver isn't preconditioned, for example/.
16:49:03 <Igloo> Ah, I didn't think cpp supported them either
16:49:22 <Igloo> Thanks
16:49:26 <shapr> :-)
16:49:37 <shapr> Pseudonym: hey did you get my various emails?
16:49:45 <Pseudonym> shapr: Yes, but I just got in.
16:49:48 <shapr> ok
16:49:49 <Pseudonym> Reading the first now.
16:50:54 <shapr> CosmicRay: hey, you gotta package HaskellDB too
16:51:00 <shapr> if you're going to do HSQL
16:51:01 <CosmicRay> why?
16:51:15 <shapr> because HaskellDB is the primary reason to use HSQL in the first place ;-)
16:51:18 <shapr> at least, in my opinion
16:51:28 <CosmicRay> oh
16:51:30 <shapr> HaskellDB is awesome
16:51:47 <CosmicRay> to me haskelldb looks like some crappy java thing that makes me type 15 lines to produce a 60-character query
16:52:06 <shapr> you can do typechecking of queries, higher-order queries, and other stuff that you just can't do anywhere else.
16:52:32 <shapr> HaskellDB is something I've been wishing for since I learned SQL.
16:52:47 <shapr> CosmicRay: nah, it's opposite
16:52:54 <shapr> everything else is a database wrapper
16:52:58 <shapr> HaskellDB is a database UNwrapper
16:53:18 <shapr> you get closer to the real theory behind databases in the first place
16:54:08 <shapr> this is my opinion, at least.
16:54:17 * shapr waves the lambda pom-poms
16:54:50 * Pseudonym thinks logic programming was always even closer
16:54:52 <Pseudonym> Personal opinion.
16:55:12 <Pseudonym> In fact, it's one of the very few things which logic programming does more elegantly than functional programming.
16:55:21 <Pseudonym> (VERY few.)
16:55:26 <Heffalump> yeah, logic programming is clearly closer
16:55:40 <Heffalump> though the whole Prolog DFS/cut thing doesn't help
16:56:02 <Pseudonym> Yes, I was careful to say "logic programming" rather than "Prolog". :-)
16:56:10 <Pseudonym> Although DFS actually ain't so bad.
16:56:23 <Heffalump> true. I guess databases are finite beasts.
16:56:24 <Pseudonym> If you have strong mode information, anyway.
16:56:57 <Pseudonym> DFS is actually pretty close to the SQL "lazy stream of tuples" model under the hood.
16:57:02 <Heffalump> isn't mode inference bound to be incomplete?
16:57:26 <Pseudonym> Uhm... no.
16:58:56 <Pseudonym> http://citeseer.ist.psu.edu/overton02constraintbased.html
16:59:40 <shapr> CosmicRay: so, why switching to Haskell from OCaml? or is Haskell just 'in addition to' ?
17:03:25 <Pseudonym> Clearly it's the superior language shootout times.
17:03:49 <shapr> :-)
17:03:58 <shapr> that's been a fun discussion.
17:04:07 <Pseudonym> Ueah.
17:04:10 <Pseudonym> Yeah, too.
17:04:56 <Heffalump> hah, the answer's in the topic
17:05:09 <Pseudonym> True!
17:07:15 <shapr> I like being a discriminating hacker.
17:07:47 <CosmicRay> shapr: for now, in addition to.
17:07:59 <CosmicRay> shapr: I'm doing Haskell because I don't know Haskell yet.
17:08:01 <Heffalump> shapr: the causation doesn't go that way.
17:08:08 <CosmicRay> shapr: we'll see how I like it.
17:08:17 <CosmicRay> I'm almost completely switched away from Python now
17:08:20 <Heffalump> Haskell is used by discriminating hackers. That doesn't mean that all Haskell users are discriminating hackers.
17:08:30 <CosmicRay> which is quite something, since I have a huge Python codebase
17:08:42 <shapr> I had a large Python/Jython codebase.
17:08:57 <shapr> probably all bitrotted now
17:09:01 <CosmicRay> Pseudonym: yeah, I love languages that are twice as slow as Java! :-)
17:09:36 * shapr finds existing licenses for large chunks of PreludeExts
17:09:50 <Pseudonym> Them's fighting words!
17:10:44 <CosmicRay> oh.
17:10:47 <CosmicRay> I guess they fixed sumcol.
17:11:05 <shapr> man, whole bunch of goodies in ginsu's GenUtil.hs
17:11:15 <CosmicRay> it used to run at 350sec
17:11:22 <CosmicRay> kaffe did it in 33sec
17:11:34 <tuomov> I probably still have quite a lot of x86 asm lying around somewhere...
17:11:55 <shapr> last time I wrote asm, I used debug.com
17:12:35 <Pseudonym> Moved my stuff over.  Note that the references to Tomasz Zielonka and Tom Pledger are a little spurious.
17:12:41 <Pseudonym> They had the idea on the mailing list, but I wrote the code.
17:12:48 <Pseudonym> (Trivial amount of code.)
17:12:48 <shapr> cool
17:12:55 <CosmicRay> whoa
17:12:56 <CosmicRay> debug.com
17:13:28 <shapr> on an XT ... with 512k of RAM
17:13:50 <shapr> uphill, both ways IN THE SNOW!
17:13:57 <CosmicRay> got ya beat
17:13:58 <CosmicRay> mine had 640k
17:14:05 <shapr> well, I upgraded later...
17:14:10 <Pseudonym> I had a COMX-35.  Can't get more obscure than that.
17:14:11 <shapr> mostly because I fried my CPU
17:15:00 <shapr> I spent my college tuition buying that XT :-)
17:15:19 <shapr> now I have RSI and no degree...
17:15:23 * shapr snickers
17:16:27 <shapr> all of John Meacham's code comes from GenUtil.hs in ginsu
17:18:29 <Pseudonym> Got another fluid.
17:18:38 <Pseudonym> http://andrew.bromage.org/fluid.mpeg
17:19:04 <Pseudonym> Bandwidth!  Mwhahaha!
17:19:36 <shapr> man, I only get ~50k to .au
17:19:43 <CosmicRay> ok
17:19:46 <shapr> I can get >1000k to the local debian mirror.
17:19:49 <CosmicRay> so where is openBinaryFile in ghc5?
17:20:04 <shapr> it doesn't exist in ghc5
17:20:10 <shapr> needs another Compat/ file
17:20:15 <CosmicRay> ah plat
17:20:20 <shapr> darcs had that same problem recently
17:20:26 <bourbaki_> Pseudonym: whats that about?
17:21:24 <shapr> Pseudonym: nice and squidgy... I keep expecting a squishy soundtrack
17:21:35 <Pseudonym> bourbaki_: This is my fluid simulator.
17:21:40 <Pseudonym> Well, it's some of the output of it.
17:21:43 <shapr> the colors merged more this time
17:21:46 <Pseudonym> Right.
17:21:56 <Pseudonym> The three scalar fields have different dissipation rates.
17:21:58 <bourbaki_> Pseudonym: in haskell?
17:22:00 <shapr> ah
17:22:01 <Pseudonym> The blue field dissipates the most.
17:22:08 <Pseudonym> The green field the least.
17:22:13 <Pseudonym> bourbaki_: No, sadly.
17:22:22 <Pseudonym> There wouldn't be much benefit to writing this in Haskell.
17:22:24 <bourbaki_> Pseudonym: do you use vector fields for that?
17:22:25 <Pseudonym> It's all numeric code.
17:22:36 <Pseudonym> I use a vector field for the velocity.
17:22:53 <bourbaki_> Pseudonym: and what do you use for that stuff?>
17:22:58 <CosmicRay> DAMN YOU GHC5
17:23:04 <CosmicRay> Distribution/Simple/Utils.hs:332: Variable not in scope: `try'
17:23:11 <Pseudonym> I'm using C++ with Boost's version of BLAS.
17:23:22 <shapr> oh, that's because exceptions change in ghc6
17:23:25 <Igloo> try is in H98 isn't it? In IO probably.
17:23:27 <bourbaki_> Pseudonym: no i mean mathwise what do you do to make it happen
17:23:28 <Pseudonym> There is a Haskell version of BLAS level 0 somewhere.
17:23:44 <Pseudonym> Oh, it's the incompressible Navier-Stokes equations on an Eulerian grid.
17:23:52 <Pseudonym> Semi-Lagrangian solver.
17:24:07 <bourbaki_> so you simulate the particles or what?
17:24:13 <Pseudonym> No, not particles.
17:24:18 <Pseudonym> I treat it as a continuum.
17:24:26 <bourbaki_> that means?
17:24:37 * Pseudonym tries to work out a way to explain this
17:24:42 <bourbaki_> :)
17:24:45 <Pseudonym> OK.  Consider a particle.
17:24:50 <Pseudonym> We'll do it in 2D.
17:24:53 <bourbaki_> ok
17:24:56 <Pseudonym> It has position (x,y).
17:25:05 <shapr> CosmicRay: how are you building Cabal?
17:25:26 <CosmicRay> shapr: what do you mean?
17:25:48 <shapr> like, did you just switch ghc to ghc5 in the makefile?
17:26:11 <CosmicRay> oh, I have a make variable that replaces certain components with a command
17:26:23 <CosmicRay> then I use $(foreach) and $(call) to call it for each flavor
17:26:29 <shapr> oh
17:26:36 <Pseudonym> No, I've decided I don't want to try to derive it in IRC.
17:26:48 <shapr> did you already fix the System.Posix.Files problem?
17:26:54 <Pseudonym> Basically, when you're treating it as a continuum, you don't care about the individual particles.
17:26:58 <CosmicRay> haven't seen that one
17:27:04 <CosmicRay> there were several in System.Io
17:27:07 <CosmicRay> I think I got them all now
17:27:11 <shapr> I just tried replacing ghc with ghc5 and running make
17:27:19 <bourbaki_> so you have the whole thing as a state?
17:27:21 <Pseudonym> Because a fluid fills the space that it occupies.
17:27:32 <CosmicRay> shapr: I am doing it this way so I can generate multiple debs form the same source
17:27:34 <shapr> if you're using the darcs repo, you can easily submit patches
17:27:38 <shapr> yah, makes sense
17:27:39 <Pseudonym> So there are particles effectively everywhere, so giving the particles identities doesn't really help.
17:27:56 <shapr> if you're not using the darcs repo, then send me diffs and I'll submit patches
17:27:58 <Pseudonym> Yes, so I basically have a 2D array of velocities.
17:28:08 <Pseudonym> And then evolve that using the Navier-Stokes equations.
17:28:34 <bourbaki_> so you have an equation system for the vector fields basically?
17:28:58 <Pseudonym> Yeah, pretty much.
17:29:02 <CosmicRay> shapr: will do
17:29:09 <CosmicRay> shapr: I'm using cabal-code.tgz from the website
17:29:19 <bourbaki_> friend of mine is working for a company that does root finding for vector fields and the like
17:29:25 <Pseudonym> Ah, interesting.
17:29:37 <shapr> CosmicRay: have you tried darcs? it's my favorite source code control system, and written in Haskell.
17:29:41 <Pseudonym> To do the main convection, though, I use a semi-Lagrangian method.
17:29:44 <bourbaki_> yeah it is and he also searches for planes and such in the fields quite interesting
17:30:00 <bourbaki_> to solve the system that is i guess right?
17:30:04 <Pseudonym> Basically what you do is you start at some point on the grid, then you step backwards in time, following the vector field backwards.
17:30:12 <Pseudonym> And then you see what was there, and copy it over.
17:30:36 <Pseudonym> If you think about the red/green/blue scalar fields moving through the fluid, that's pretty much what you do.
17:30:42 <CosmicRay> shapr: I've been using tla
17:30:50 <Pseudonym> You step backwards, see if there was any red fluid there, and if there was, copy it over.
17:30:52 <CosmicRay> shapr: I've heard about it but haven't seen enough to convince me to move
17:30:57 <Pseudonym> Kind of thing.
17:31:17 <shapr> CosmicRay: whenever you want the quick darcs demo/intro, ask me
17:31:17 <bourbaki_> ah ok sounds kind of good :) though i guess its a bit more difficult ;)
17:31:18 <Pseudonym> Oh, interesting.  What does the company do this for?
17:31:36 <bourbaki_> is some spin off company form uni
17:31:52 <bourbaki_> they do it as an analysis package for things like ...
17:32:07 <bourbaki_> er where you test cars and its air resistance stuff and such
17:32:38 <bourbaki_> ill ask him for the webpage tomorrow if you want then i can give you the link there are some examples and pictures
17:32:50 <CosmicRay> shapr: ./setup build is failing with ghc5 for me:
17:32:54 <CosmicRay> ompiling Distribution.Simple ( Distribution/Simple.hs, dist/build/./Simple.o )
17:32:55 <CosmicRay> /usr/bin/ar: creating dist/build/libHSCabal-0.1.a
17:32:55 <CosmicRay> /usr/bin/ar: dist/build/./Distribution/Package.o: No such file or directory
17:32:57 <CosmicRay> I can't figure it out
17:33:04 <CosmicRay> there are no .o files in dist/build/Distribution
17:33:07 <CosmicRay> but there are in dist/build
17:33:14 <CosmicRay> but according to the messages, there should be .o files there
17:33:39 <CosmicRay> ahh.
17:33:42 <shapr> ?
17:33:45 <CosmicRay> compare this from ghc6:
17:33:50 <CosmicRay> Compiling Distribution.Package ( ./Distribution/Package.hs, dist/build/./Distribution/Package.o )
17:34:05 <CosmicRay> to this from ghc5:
17:34:10 <CosmicRay> Compiling Distribution.Package ( Distribution/Package.hs, dist/build/./Package.o )
17:34:15 <shapr> ohh
17:34:15 <CosmicRay> freaky
17:34:21 <CosmicRay> why is that different?
17:34:36 <shapr> ghc5 support for hierarchical libs was an aftermarket addon.
17:34:44 <shapr> ghc6 has better hierarchical libs support.
17:34:51 <CosmicRay> so essentially cabal is broken with ghc5?
17:35:12 <shapr> might be more tactful to say "has many bugs with ghc5" ;-)
17:35:22 <CosmicRay> hah
17:35:35 <CosmicRay> I'd call "./setup build" failing to be broken :-)
17:35:41 <shapr> well, ok
17:35:41 <Igloo> It's probably using a flag like -odir that ghc5 isn't understanding, I'd guess
17:36:21 <shapr> I don't know of anyone doin new development with ghc5, only ghc6, and almost always ghc6.2 or later.
17:36:45 <shapr> well, except for Marvin-- :-)
17:36:51 <shapr> safelogic.se is still using ghc5
17:37:47 <CosmicRay> oooo kaaay...
17:37:51 <CosmicRay> cabal is also broken with nhc98.
17:38:04 <bourbaki_> Pseudonym: so what you do is start your simulation at the end actally?
17:38:18 <CosmicRay> ./setup build
17:38:18 <CosmicRay> Warning: -package haskell-src interfaces not found.
17:38:18 <CosmicRay> Warning: -package haskell-src library  not found.
17:38:18 <CosmicRay> gcc: Cabal: No such file or directory
17:38:18 <CosmicRay> gcc: Distribution.Package: No such file or directory
17:38:19 <CosmicRay> gcc: Distribution.Version: No such file or directory
17:38:23 <CosmicRay> gcc: Distribution.Misc: No such file or directory
17:38:25 <CosmicRay> gcc: Distribution.Setup: No such file or directory
17:38:27 <CosmicRay> gcc: Distribution.InstalledPackageInfo: No such file or directory
17:38:36 * CosmicRay is a little nonplussed that the uber-make build-everywhere tool only actually works with ghc6 :-)
17:38:54 <shapr> the tool isn't completely finished yet :-)
17:39:00 <CosmicRay> or at least only actually builds itself with ghc6
17:39:08 <CosmicRay> I wonder if it can build MissingH for other things
17:39:22 <shapr> but your calling-it-names evalution should help ;-)
17:39:30 <CosmicRay> shapr: :-)
17:39:48 <CosmicRay> <-- always quick to complain about code including his own
17:39:56 <shapr> yah, me too
17:40:24 <Igloo> Well, you're seeing why stuff isn't in sid yet anyway  :-)
17:40:37 <shapr> I lik the idea calling-it-names evalution, as opposed to call-by-name evaluation.
17:40:54 <CosmicRay> shapr: lazy names? :-)
17:41:12 <CosmicRay> Igloo: yeah well, sometimes you have to jam the square peg into the round hole in order to accomplish things :-)
17:41:21 <Igloo> :-)
17:41:23 <shapr> DeepSeq
17:41:25 <shapr> whee
17:44:00 <CosmicRay> foo.
17:44:08 <CosmicRay> no, it does not build with nhc for me.
17:44:36 <CosmicRay> ok well I guess everything will be ghc6-only for the moment
17:44:49 <shapr> but tomorrow, it might be better!
17:44:53 <CosmicRay> grin
17:45:08 <Igloo> Oh, try to avoid making mips binaries in Debian with ghc6 BTW
17:45:17 <CosmicRay> why?
17:45:32 <Igloo> I think I'm probably going to have to ask for its removal
17:45:59 <CosmicRay> why?
17:46:08 <Igloo> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=274942
17:46:12 * CosmicRay hates special-casing archs
17:46:39 <Igloo> You have to special-case things anyway or the buildds get upset
17:46:51 <Igloo> Where special case = list arches in the build-deps
17:47:46 <CosmicRay> Igloo: usually the relocation error just means lack of -fPIC
17:47:47 <Igloo> It's not the end of the world if a binary gets built, it'll just be one more for the ftp-masters to remove  :-)
17:48:28 <CosmicRay> Igloo: what, is ghc6 not arch: any now?
17:48:36 <Igloo> -fPIC is irrelevant if all the object files just get linked together isn't it?
17:48:46 <Igloo> ghc6 is arch: any but doesn't exist on mipsel or arm
17:48:57 <Igloo> nhc98 is arch: any but doesn't exist on anything 64-bit
17:48:58 <CosmicRay> ah dammit
17:49:05 <CosmicRay> yeah I know about the nhc98 thing
17:49:13 <CosmicRay> why is ghc6 not on mipsel or arm?
17:49:20 <CosmicRay> that meas that ghc6 isn't in sarge, doesn't it?
17:49:58 <Igloo> It's not on mipsel because of the above bug. It's not on arm because of non-standard floating point representations due to be fixed within a few months last I checked
17:50:14 <Igloo> No, to get into sarge you just need to not be outdated on any arches. Not being on an arch at all is fine.
17:50:23 <CosmicRay> oh
17:50:26 <CosmicRay> freaky.
17:50:29 <CosmicRay> ok.
17:51:03 <CosmicRay> I may look into that
17:51:08 <CosmicRay> I just ported ghc to aix
17:51:11 <Igloo> Which?
17:51:14 <CosmicRay> I feel like I can conquer anything now :-)
17:51:17 <Igloo> :-)
17:51:20 <CosmicRay> the relocation thingy
17:51:36 <CosmicRay> Lame guess: -mieee will fix arm
17:51:52 <CosmicRay> it does on alpha anyway
17:52:13 <juhp> Igloo: I think you need -fPIC anyway even if the objs get linked together
17:53:16 <Igloo> I don't get that. Anyway, after speaking with mips god Thiemo Seufer I'm fairly convinced the solution is as in that bug report, but anyone is of course welcome to prove me wrong  :-)
17:55:31 <Igloo> Hmm, we do add -mieee for alpha. I'm surprised pb didn't mention it if that would fix it
17:55:38 * Igloo tries to find it in the acursed info pages
17:56:31 <Igloo> Ah, I'm just going blind. It's in the Alpha options but not the ARM options
18:15:22 <Pseudonym> Sorry, back.
18:15:58 <Pseudonym> Hbourbaki_: If you're still here, thanks.  That'd be interesting.
18:38:35 <bourbaki_> Pseudonym: :) kk
18:39:05 <bourbaki_> is there an operator to build the product of two arrows?
18:39:28 * bourbaki_ ate too much cookies and cant sleep
18:40:21 * cptchaos can't sleep too
18:41:14 <bourbaki_> too much cookies as well?
18:44:33 * shapr is trying not to sleep
18:45:22 * bourbaki_ gives shapr and cptchaos a cookie
18:59:47 <shapr> yay House! http://lambda-the-ultimate.org/node/view/299
19:01:18 <bourbaki_> heh
19:04:28 <bourbaki_> shapr: do you want to make a whole new game or do you want to use something like freecraft?
19:04:38 * shapr shrugs
19:05:03 <shapr> I'd like to experiment with yampa as a way to accomplish concurrency
19:05:22 <bourbaki_> hm
19:05:29 <shapr> and see how it compares with Stackless Python's ability to run 10,000 coroutines with no strain
19:05:38 <shapr> can I run 10,000 arrows at once with Yampa?
19:05:42 <shapr> more? less?
19:05:48 <bourbaki_> heh i dont know :)
19:05:52 <shapr> would it make a good server for an MMORPG?
19:06:28 <bourbaki_> if you have something like a network what would happen if to data elements hit the same arrow at the same time?
19:06:52 <bourbaki_> can arrow or yampa do something like waiting for data? like in petri nets
19:08:03 <shapr> er
19:08:09 <shapr> I don't know what you mean
19:08:13 <bourbaki_> well
19:08:21 <bourbaki_> i want to build a neural network with it
19:08:39 <bourbaki_> and to do the backpropagation i need the outcome of the computation
19:08:41 <shapr> oh, that should work fine
19:09:04 <bourbaki_> and i have to wait for that until i use the backprop arrows
19:09:23 <bourbaki_> cause if that works i think im off superfine
19:19:15 * bourbaki_ -> (me, bed)
19:19:24 <bourbaki_> nighto
19:47:35 <CosmicRay> shapr: why are we standardizing on cabal instead of hmake?
19:47:47 <shapr> because hmake doesn't do what Cabal does
19:48:04 <shapr> look at the Cabal proposal
19:48:06 <shapr> there's more detail there
19:48:13 <CosmicRay> ok
19:48:29 <CosmicRay> or rather, hmake won't do what Cabal will?
19:48:38 <shapr> right :-)
19:48:39 <CosmicRay> because at the moment it seems to do slightly more :-)
19:49:04 <shapr> anyway, SyntaxNinja/SyntaxPolice/ Isaac Jones is the instigator of Cabal, and he's the expert.
19:49:20 <shapr> he's often SyntaxLaptop here on #haskell
19:49:26 <CosmicRay> but even on that score, at least we have Cabal.
19:49:31 <shapr> right
19:49:34 <CosmicRay> the situation with ocaml so totally sucks
19:49:46 <CosmicRay> we don't even have the variations of compilers
19:49:50 <CosmicRay> there is ocamlopt and ocamlbyte
19:49:55 <CosmicRay> err ocamlc.
19:50:04 <shapr> Haskell was getting scary with three different build systems
19:50:11 <shapr> I'm glad Cabal got started.
19:50:19 <shapr> many credits to Isaac
19:50:27 <CosmicRay> but damn, there are about six different build systems for OCaml, and EVERY SINGLE ONE SUCKS
19:50:30 <CosmicRay> </rant>
19:50:31 * shapr tiredly waves a lambda pom-pom
19:50:48 <shapr> geez, it's 5am, I gotta go to the bookkeeper tomorrow
19:50:56 <CosmicRay> heh
19:51:06 <CosmicRay> the Setup.description that I wrote for MissingH is *awesome*
19:51:14 <shapr> self-employment has serious downsides... like.. accounting.
19:51:24 * shapr falls over asleep
19:51:32 <CosmicRay> cya shapr
19:52:13 <CosmicRay> shapr: what's your e-mail?
19:52:15 <CosmicRay> I'll send you a diff
23:32:52 <musasabi> morning
23:33:00 <bbls> hi musasabi
23:49:51 <crackhead> what's up everyone :)
23:51:29 <Lemmih_> Going to school in a couple of minutes.
23:58:06 <Matt-W> Argh, work in fifteen minutes! Argh!
