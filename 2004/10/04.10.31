02:38:20 <wilx`> Yo!
02:38:23 <wilx`> Question.
02:38:46 <wilx`> Is there any other pure lazy strictly typed language than Haskell?
02:40:21 <mflux> concurrent clean
02:40:45 <mflux> some functiona languages newsgroup faq covered this
02:41:00 <wilx`> comp.lang.functional?
02:41:07 <mflux> maybe
02:41:14 <wilx`> 'k
02:41:36 <wilx`> I am just curious.
02:42:08 <wilx`> I really like Haskell but I'd like to see if there is also some different approach to the same thing.
02:45:05 <bourbaki> min
02:45:18 <bourbaki> moin
02:51:48 <shapr> gwahr!
02:52:27 <shapr> good morning #haskell!
02:56:39 <bourbaki> shapr maybe you can help me
02:56:55 <bourbaki> this paper page 10 http://www.haskell.org/yampa/AFPLectureNotes.pdf
02:57:28 <bourbaki> the first function
03:00:58 <shapr> what about it?
03:01:47 <bourbaki> vrSF &&& vlSF returns something like (Signal Speed, Signal Speed)
03:02:11 <bourbaki> and + adds to Nums but Signal Speed is no number but a function
03:03:57 <shapr> nah, they return Speed
03:04:12 <shapr> vrSF :: SF SimbotInput Speed
03:04:36 <bourbaki> but SF is of type SF a b = (Signal a) -> (Signal b)
03:05:06 <esap> but that's inside that arrow type. 
03:05:08 <shapr> so vr <- vrSF -< inp takes a SimbotInput, and transforms it into Speed
03:05:11 <shapr> hei esap 
03:05:17 <esap> hei shapr
03:05:39 <bourbaki> ok im confused
03:07:06 <esap> arr2 (+) :: (Num a) => SF (a,a) a
03:07:11 <bourbaki> why does + get something of type Speed as input?
03:07:36 <Spherical> Are haskell and lisp/scheme similar languages?
03:07:48 <bourbaki> yes i know that but the return of the two functions is (Signal Speed, Signal Speed)
03:08:51 <esap> bourbaki: You're seeing inside the SF type.
03:09:25 <esap> Or do you mean it's not Signal (a,a) ?
03:10:29 <shapr> Spherical: for some definition of similar, yes.
03:10:35 <bourbaki> (vrSF &&& vlSF) :: (Signal RoboInput) -> (Signal Speed, Signal Speed)
03:11:04 <shapr> Spherical: you want to see the short intro?
03:11:17 <bourbaki> er
03:11:33 <bourbaki> SF (Signal RoboInput) -> Signal (Speed, Speed)
03:11:49 <bourbaki> ...
03:11:59 <bourbaki> SF RoboInput (Speed, Speed)
03:12:15 <esap> right.
03:12:23 <bourbaki> but why does that + just take the output of the Signal?
03:12:38 <bourbaki> the elements of SF are functions not Nums
03:13:00 <esap> arr2 does that.
03:13:22 <bourbaki> ?
03:13:38 <esap> arr2 :: (a -> b -> c) -> SF (a,b) c
03:13:41 <bourbaki> arr2 just takes the input given to it and adds it
03:13:59 <bourbaki> ah ok
03:14:30 <bourbaki> ok sry :) when i looked at it it had been something like 4h here but it seems reasonable now thanks
03:16:45 <bourbaki> no wait
03:22:32 <shapr> ?
03:45:33 <bojohan> "that is old school programming. modern languages require you to specify the type of a new variable."
03:46:52 <arjanb> heh
03:49:34 <bojohan> in a response to a response to a response to Philippa_'s post in the "C++ sucks for games" thread in comp.games.development.programming.misc/comp.lang.lisp
03:50:22 <nTfirewall> can someone please tell me the type of this ... rpt 0 f x     = x          
03:50:24 <nTfirewall> rpt (n+1) f x = f (rpt n f x)
03:50:58 <nTfirewall> i tried this > rpt :: Int ->(Int->b)->b->Int ... but it doesnt work
03:51:06 <bojohan> ask the compiler
03:51:25 <wilx`> Sounds like troll to me.
03:51:34 <nTfirewall> how do i ask a compiler
03:51:41 <shapr> nTfirewall: use the :t command in ghci
03:51:53 <nTfirewall> i am using hugs
03:52:02 <bojohan> Prelude> :t rpt where rpt 0 f x = x;  rpt (n+1) f x = f (rpt n f x)
03:52:02 <bojohan> let {...} in rpt :: Integral a => a -> (b -> b) -> b -> b
03:52:29 <bojohan> nTfirewall: it's ":t" here too
03:52:45 <nTfirewall> thanks :)
03:57:47 * shapr hop
04:13:52 <shapr> yow!
04:14:04 <shapr> ok, time for unicycling
04:43:23 <shapr> it's 2pm, and it's 0Â°C... now is a great time to unicycle!
04:43:52 <yeti> hehe, have fun :)
04:44:48 <shapr> Lemmih: come unicycling with me! it's one-tenth of a degree above freezing!
04:45:43 <Lemmih> (o:
04:46:10 <shapr> what's the temperature in kopenhamn?
04:46:43 <shapr> I don't know what I'm going to do about unicycling in weather colder than -10Â°C or so.
04:46:58 <shapr> I have enough trouble unicycling with anything more than bike shorts.
04:47:54 <shapr> amazingly, I am still losing weight... down to 93.5 kilos.
04:50:24 <Lemmih> Good morning to you too, shapr.
04:51:14 * shapr bounces around
04:51:21 <shapr> hej sond
04:51:32 <davve> tja
04:52:34 <Oejet> davve: How is that pronounced? An 'a' like in flaw or like in back?
04:53:18 <davve> neither of them
04:53:29 <davve> swedish mute a
04:54:02 <Oejet> Meaning?
04:54:12 <shapr> davve: record it! upload it!
04:54:15 <shapr> then we'll know =)
04:54:16 <davve> tho davve is just a nickname, my real name is David
04:54:45 <Lemmih> That's a great name.
04:54:51 <davve> shapr, i'm too lazy to find my mic :)
04:55:51 <Boegel> good afternoon #haskell
04:56:05 <shapr> hoi Boegel!
04:56:15 <Lemmih> Hey Boegel.
04:56:22 <shapr> davve: that's okay, we can almost hear you from under the desk.
04:57:00 <shapr> that's an old joke from SunOS... where mics were world-readable, and you could usually login under some guest user and listen to the guys on the console ;-)
05:07:47 <davve> haha :)
05:12:53 <bojohan> davve: hmm, which area is brg.sgsnet?
05:57:52 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first","Write for the HC&A Report, Nov 2004 edition - http://haskell.org/communities"]'
05:57:52 --- topic: set by ksbot on [Wed Oct 27 01:34:32 2004]
06:23:47 <esap> Hmm.. GADTs don't let me build two values with one constructor :-)
06:27:52 <shapr> man I love unicycling
06:28:02 <shapr> too bad my bike shorts blew out today :-(
06:29:36 <shapr> d00d
06:29:38 <shapr> wazzup?
06:29:55 * esap is experimenting with GADTs.
06:46:22 <Igloo> Does anyone know what I should do to me test suite to make it cabal-friendly?
06:53:54 <shapr> hoi Jan_w 
06:55:56 <Jan_w> hi shar
06:56:01 <Jan_w> shapr
06:56:15 <shapr> hoe gaat het?
06:56:46 <Jan_w> goed :)
06:57:10 <bourbaki> het gaat goed ;)
06:57:21 <shapr> Jan_w: look, it's me! - http://mw75.student.utwente.nl/~marianne/MarianneinLulea/photos/photo22.html
06:57:47 <Jan_w> cool
06:58:12 <shapr> This nice dutch girl came to visit us - http://mw75.student.utwente.nl/~marianne/MarianneinLulea/photos/photo42.html
06:58:46 <Jan_w> shapr: i lived almost nextdoor to mw75 for 4 years :)
06:58:56 <shapr> what's mw75?
06:59:07 <shapr> ik veit het niet.
06:59:28 <Jan_w> shapr: you'r not used to using w's :) 
06:59:33 <Jan_w> shapr: it's an student flat
06:59:45 <Jan_w> on the university campus
06:59:51 <shapr> oh, ok.
07:00:48 <Jan_w> shapr: http://mw75.student.utwente.nl/~marianne/zusjes/html/P7211213.htm, that's it...(mw75)
07:01:05 <Jan_w> in the back
07:01:52 <shapr> oh cool!
07:16:04 <shapr> I was surprised to meet a nice dutch girl who could unicycle and had learned to program with Miranda.
07:20:16 <Jan_w> those are rare indeed
07:20:17 <Jan_w> :)
07:21:37 <Jan_w> i never met a girl how could program anything
07:22:09 <Oejet> Jan_w: Never?!
07:22:19 <shapr> I've met quite a few, but rarely an 'average' girl who could program.
07:22:52 <chucky> wow, never? I've met many, and they're usually quite good too. :)
07:22:53 <shapr> Usually either beautiful and brilliant, or complete nerds.
07:24:05 <shapr> Happily, that's changing. Programming is becoming 'normal' now.
07:25:36 <chucky> damnit why is my heat always off on Sundays?
07:25:55 <shapr> sunday is for chillin
07:26:02 <chucky> obviously
07:26:07 * shapr snickers
07:26:47 <chucky> it's not like I can call my landlord right now or anything. It'll have to wait until tomorrow, when I will have forgotten it, and then I'll sit here next sunday and freeze my ass off. Again.
07:27:13 <bojohan> completely off?
07:27:20 <chucky> yes
07:27:29 <bojohan> here it's not
07:28:20 <chucky> well it is here. :)
07:29:15 <shapr> hey TheHunter, what were those headphones you suggested?
07:30:44 <sorje> 16:20 <@schula> oh Sie sind alkoholgefährdet!...
07:30:47 <sorje> oh, sorry.
07:32:11 <shapr> ich bin gekipt auf alkohol!
07:32:22 * shapr pretends to have a clue about german.
07:33:11 <sorje> I'm not sure how to break this to you, but you failed. ;-)
07:33:19 * shapr laughs
07:33:54 * shapr sucks down energy drinks
07:34:00 <shapr> mmm, Battery and Jolt
07:36:20 <TheHunter> hiya shapr
07:36:45 <shapr> Guten abend TheHunter.
07:37:10 <bojohan> hahaha, those eurohaskell pics are hilarious
07:37:33 <TheHunter> i suggested sennheiser hd 590, (my roommate has them and i therefore had to buy the hd 600, but i don't think they sound better...)
07:37:37 <shapr> What got you to the EuroHaskell gallery?
07:37:43 <shapr> TheHunter: haha!
07:37:58 <bojohan> http://andersca.org/gallery/eurohaskell/p1010060
07:38:17 <shapr> Truly, andersca is a creative genius.
07:38:43 <shapr> You'll be at the next one, right Bojohan?
07:39:06 <bojohan> i guess i should :/
07:39:09 <shapr> Planning to have more and better unicycles next time.
07:39:19 <shapr> You might even enjoy it.
07:39:49 <bojohan> the question is if i'll understand anything
07:39:56 <shapr> I'm sure you will.
07:40:17 <shapr> You know the EuroHaskell committee, right?
07:40:18 <bojohan> can't we have a EuroEmacs? :)
07:40:40 <bojohan> shapr: ehm, no.
07:40:48 <shapr> Do you know BjÃ¶rn Bringert?
07:41:10 <bojohan> no
07:41:17 <bojohan> only by name
07:41:21 <shapr> he's a really cool guy at chalmers.
07:41:53 <shapr> Anyway, EuroHaskell happened because bjÃ¶rn and andersca and I were chatting on #haskell.se, and we said "hey, we should get together in gothenburg and have a hackfest sometime"
07:42:16 <shapr> A few weeks later, I said "oh I'll be in gothenburg for EuroPython, let's get together then"
07:42:30 <shapr> and just to be smartass (as usual) I started calling it EuroHaskell.
07:42:42 <shapr> Greetings of fish of economy.
07:42:50 <shapr> ahem "Oh Fish of Economy"
07:42:54 <Naughty_Minnow> greetings
07:43:07 <Lemmih> Hey Naughty_Minnow.
07:43:20 <Naughty_Minnow> het there
07:43:23 <Naughty_Minnow> *hey
07:43:34 <shapr> bojohan: so, EuroHaskell'l intent was to get some guys together and hack, then drink beer. Did you see the official EuroHaskell t-shirt?
07:43:35 <Lemmih> Looking for Haskell info?
07:43:48 <Naughty_Minnow> Lemmih: a little :P
07:44:06 <bojohan> shapr: i /might/ have. or not.
07:44:45 <Naughty_Minnow> Lemmih: i am looking for a function to turn a String (of numbers) into an Int, I can't find one however
07:44:51 <shapr> bojohan: somehow, things got out of hand and we actually had a haskell and monads tutorial and two talks, one on arrows by John Hughes, and one on hOp by Jeremy Bobbio
07:44:51 <Lemmih> Naughty_Minnow: Feel free to ask any question you might have.
07:45:19 <bojohan> shapr: how is your first name pronounced, btw? :)
07:45:25 <chucky> shapr: So what do we do this year? Bigger and better? :)
07:45:30 <Lemmih> Naughty_Minnow: That'll be 'read'.
07:45:37 <shapr> bojohan: anyway, I did the email advertising and general cheerleading, and BjÃ¶rn and Anders and Chucky did all the hard work.
07:46:06 <Naughty_Minnow> "read" you say
07:46:08 <Naughty_Minnow> hmm ok
07:46:09 <shapr> They organized rooms, equipment, logins and everything.
07:46:29 <Lemmih> @type read
07:46:30 <shapr> chucky: sure, more unicycles =)
07:46:31 <lambdabot> read :: forall a. (Read a) => String -> a
07:46:45 <shapr> bojohan: it's a lot like tjej, I think.
07:47:00 <Naughty_Minnow> ok thanks!
07:47:04 <shapr> "shay" in phonetic american english
07:47:26 <bojohan> it's not very common, is it?
07:47:43 <shapr> No, not very common at all. Mostly because it's short for shapr ;-)
07:49:07 <bojohan> hmm, i didn't understand that last sentence
07:49:15 <shapr> chucky: One thing I learned, this year tutorials happen in a different room. I think the tutorials distracted the people who were being productive.. I should have noticed that earlier.
07:49:44 <chucky> I agree
07:49:57 <shapr> bojohan: I was born Robert Benjamin Gilliam, but that name sucked. So I changed it to Shae Matijs Erisson.
07:50:00 <chucky> I think that was sort of the plan initially
07:50:09 <shapr> we had a plan?
07:50:16 <shapr> man, no one told me =)
07:50:36 <chucky> no, I didn't say we had a plan, we had a sort of plan
07:50:42 <shapr> ah, good point!
07:50:49 <chucky> something like "it would be great if..."
07:50:50 * shapr laughs
07:51:08 <shapr> EuroHaskell was a *lot* of fun.
07:51:16 <chucky> it sure was
07:52:24 <shapr> I would like to embrace and extend EuroPython into 'EuroProgram' where any open source programming is welcome. Even so, I doubt that'll happen for several years, if ever.
07:52:57 <chucky> not until you organize it at least. :)
07:53:23 <shapr> We could integrate EuroEmacs this year or next.
07:53:36 <chucky> I *would* like to extend EuroHaskell into an event that was almost as big as EuroPython, only organized a lot better
07:53:54 <shapr> I've been part of the organizing team for two EuroPythons, and it's a nightmare =)
07:54:23 <shapr> still lots of fun though.
07:54:41 <chucky> yeah
07:55:19 <shapr> My main problem with most programming language conferences is that they don't really encourage on-the-premises emergent hackfests.
07:56:23 <chucky> yes. You really should have a "hacking room" or two where you could just go and someone would tell you what you should hack on. :)
07:56:50 <shapr> right
07:57:06 <shapr> show up, join a sprint, or start your own
07:58:02 <shapr> it was cool that last year all the productive EuroHaskellers were also on #haskell at the same time, so others could participate.
07:59:18 <shapr> I wonder if we can get more mid or southern european participats this year.
07:59:51 <chucky> yeah. Although this year having more concrete project ideas would be great (as well as the loosely defined we had last year). Some people (like me) need to be able to just jump in there (otherwise I just end up getting distracted)
08:00:08 <shapr> right, makes sense.
08:00:48 <shapr> I want to bring a laptop this time, setting up on the chalmers account took up a lot of my time.
08:01:00 <shapr> (mostly because I use so many strange customizations)
08:01:25 <chucky> it's always nice to have your own custom environment.
08:01:31 <chucky> and a GHC that works. :P
08:01:36 <shapr> heh, that too
08:01:43 <shapr> did you get readline working?
08:01:47 * chucky is still bummed that he can't get GHC 6.3 to compile
08:01:55 <chucky> not me, but a guy named rydis fixed it
08:02:16 <Igloo> chucky: What's the problem?
08:02:57 <chucky> it can't find readline (which is the same problem we had before with 6.2). The problem's on this end though, so to speak
08:03:06 <Igloo> Ah, OK
08:03:14 <Igloo> It ought to compile without it, though
08:03:24 <chucky> not on this system. :)
08:03:33 <Igloo> Fair enough
08:03:35 <shapr> EuroPython 2005 is in Gothenburg, Monday the 27th of June to Friday, the 1st of July. Should we do EuroHaskell before or after?
08:03:54 <bojohan> the chalmers lab accounts suck
08:04:17 <chucky> let me check stuff like exam dates (they should be over by then, but you never know)
08:04:23 <shapr> ok
08:05:11 <shapr> bojohan: hey, if EuroEmacs seems like a good idea, organize it!
08:05:27 <bojohan> hmmm
08:05:42 <shapr> maybe we can factor out some of the common difficulties in hackfest organizing.
08:06:06 <Igloo> EuroYi!
08:06:15 <shapr> Igloo: yes, that too =)
08:06:15 * Igloo ducks to avoid potentially bouncing shaprs
08:06:19 * shapr bounces!
08:06:30 * shapr bounces over Igloo
08:06:40 <shapr> Igloo: will you have time to show up this year?
08:07:20 <Igloo> I can't say. It's likely I'll be feeling too poor and trying to pull a thesis together around that time
08:07:48 <shapr> maybe you could get your thesis done before, and then show up for stress-free fun hacking?
08:07:50 <chucky> exams end May 31, so for us people at Chalmers, both before and after EuroPython is fine
08:08:19 <Naughty_Minnow> arrgh damn read function
08:08:33 <Lemmih> Naughty_Minnow: Problems?
08:08:35 <shapr> chucky: sounds good
08:09:00 <Lemmih> Hey marcot
08:09:18 <marcot> Lemmih: hello!
08:09:31 <Naughty_Minnow> Lemmih: you could say that, i have this: read ((words h)!!4)
08:09:33 <marcot> Lemmih: Wie geht's?
08:09:47 <shapr> Ã³la marcot 
08:10:01 <marcot> shapr: Hello.. =)
08:10:31 <Lemmih> Naughty_Minnow: And it isn't working?
08:10:38 <Naughty_Minnow> no :(
08:10:50 <marcot> How do I know what char code is C-b for example?
08:10:57 <marcot> So that I can configure yi like emacs?
08:11:19 <shapr> marcot: you can use \^C for control-c I think
08:11:43 <marcot> shapr: what about M-x for example?
08:11:44 <mflux> marcot, simple: ctrl-a, b, c -> ascii 1 2 3 ;)
08:12:19 <marcot> mflux: thank you.
08:12:41 <mflux> M-x is usually two characters, escape (27) and then the character x
08:13:09 <mflux> alternatively it could be x with the highest bit on, but I think that's really rare
08:13:18 <marcot> Ok.
08:13:29 <Lemmih> marcot: I'm fine, thank you.
08:21:56 <Igloo> Ick, M-x is normally done with a timeout. How's that going to work with the lexer plan?
08:22:12 <shapr> a timeout?
08:22:23 <Igloo> I guess the stream could be mangled before it hits the lexer, but it's still not going to be pretty
08:22:39 <Igloo> You wait a second and if nothing comes after the escape you treat it as a single character
08:22:53 <shapr> I don't know.
08:24:46 * shapr boings
08:25:48 <mflux> igloo, I think you could just wait indefinitely until another character comes
08:26:43 <Igloo> Yeah, but that's not what the rest of the world does; you also couldn't write a vi mode then
08:27:59 <mflux> xemacs doesn't seem to have a timeout or it's long
08:28:23 <mflux> it does however display the 'ESC -' in the minibuffer after a sub-second timeout
08:28:40 <mflux> and xemacs also has a well-defined abort-key so maybe it's not a good example
08:28:41 <shapr> xemacs can interpret ESC in at least two different ways, ESC x is Meta-x, and ESC ESC ESC is the 'bail out of anything' command.
08:29:00 <mflux> oh, I thought only C-g did that
08:29:15 <mflux> esc esc esc isn't quit though?
08:29:24 <mattam> bah, there's no #logic channel here :(
08:29:31 <shapr> M-ESC ESC runs `keyboard-escape-quit'
08:29:32 <mflux> oh, it's some keyboard-escape-quit
08:29:40 <shapr> C-g runs `keyboard-quit'
08:37:02 <marcot> I've changed yi's Yi/Keymap.hs, from 'h' to '\2', and I've compiled it, but it's working in the same way.
08:37:46 <marcot> It's still using 'h' to leftE
08:37:46 <bojohan> meta *is* ESC in emacs
08:39:14 <marcot> Does anyone knows how to change it?
08:39:24 <Naughty_Minnow> is there any way to access tuple elements higher than snd?
08:40:06 <abstrato_general> hello, everyone.
08:40:12 <Lemmih> Hello abstrato_general.
08:40:15 <shapr> hello abstrato_general 
08:40:32 <abstrato_general> no questions today, just hanging out. 
08:40:33 <Lemmih> Naughty_Minnow: I don't there there are standard functions for that.
08:40:35 <shapr> Naughty_Minnow: fst3 = (\x _ _) -> x
08:40:35 <abstrato_general> not yet, anyway ;-)
08:41:03 <Naughty_Minnow> fst3, eh
08:41:17 <marcot> I thought that yi loaded this file at compilation.
08:41:26 <marcot> Must I pass a parameter?
08:41:27 <shapr> marcot: rebuild it!
08:41:33 <marcot> shapr: I have.
08:41:43 <marcot> shapr: I have done make && make install again.
08:43:23 <shapr> did it work?
08:46:30 <abstrato_general> are there yi binaries for windows? I'm curious.
08:46:53 <shapr> I think yi-static will work on win32
08:47:12 <abstrato_general> console-mode?
08:47:18 <shapr> yes
08:47:58 <marcot> shapr: no...
08:48:02 <abstrato_general> I switched back after a year and a half with Linux to WinXP because of work and because Linux performance was so annoying.
08:48:19 <abstrato_general> But I'm still addicted to all the little tools, and use Gvim whenever I can, etc.
08:48:22 <marcot> shapr: I've downloaded it, change only Yi/Keymap.hs and make && make install, but it's not working.
08:48:36 <shapr> well, why not? =)
08:48:47 <shapr> abstrato_general: what linux performance problems did you have?
08:49:10 <marcot> shapr: =) I've change 'h' to '\2', but it's still using 'h'.
08:49:20 <marcot> shapr: Can you try doing it?
08:49:29 <abstrato_general> I do have to use spreadsheets in a regular basis. What really triggered switching back was poor rendering of .xls files.
08:49:48 <abstrato_general> Anyway, boot up times suck, app startup times are painful, screen redraws in X are painful, etc. etc.
08:50:00 <abstrato_general> maybe I'll move back to Linux when I have a decent computer.
08:50:10 <shapr> boot up times suck??
08:50:24 <shapr> what hardware are you using??
08:50:40 <abstrato_general> a K6-II 500. 384 megs RAM.
08:50:44 <shapr> Windows wouldn't handle my hardware nearly as well as Linux does.
08:50:57 <shapr> what graphics card?
08:51:12 <abstrato_general> WinXP will boot and load up Firefox with three tabs open faster than Gentoo will boot, start x and load ion3.
08:51:18 <marcot> shapr: any idea?
08:51:18 <abstrato_general> And, gosh, ion3 is as minimal as it gets.
08:51:27 <abstrato_general> it's a cheap Trident.
08:51:49 <abstrato_general> it's not an ATI. Everytime I mention WinXP outperforms a minimal linux install, people come up with the ATI theory.
08:51:58 <shapr> what's the ATI theory?
08:52:00 <abstrato_general> It's all very exciting and powerful, but also quite half-baked.
08:52:09 <abstrato_general> that ATI binary drivers are bad, etc. etc.
08:52:11 <shapr> huh, I think Windows is half-baked.
08:52:41 <abstrato_general> It's not. After 18 months on linux only, Windows brings me pleasant surprise after pleasant surprise.
08:52:41 <shapr> boot times aren't really a problem for me, I never turn off my computer.
08:52:58 <Philippa_> abstrato_general: lucky you, I tend to get unpleasant surprises
08:53:05 <shapr> abstrato_general: I strongly disagree, have you tried to use windows for paying work?
08:53:07 <Philippa_> 'mstill running 2KPro though, I play too many games not to
08:53:07 <abstrato_general> yes, there are a lot of things that are better engineered in a typical linux isntall.
08:53:17 <marcot> dons: are you there?
08:53:19 <abstrato_general> I had to switch to Windows because of paying work.
08:53:33 <abstrato_general> the thing that bothers me the most is how slow file operations are.
08:53:42 <shapr> slow file ops in windows?
08:53:56 <abstrato_general> Even the most boring linux filesystems are lightning-fast compared to FAT32.
08:54:34 <abstrato_general> Linux is very very exciting, but I eventually became an adult, and.
08:54:39 <abstrato_general> Maybe when I get a new computer.
08:54:54 <shapr> I became an adult too, and stopped using windows =)
08:55:13 <chucky> abstrato_general: Why FAT32? Isn't NTFS faster/better?
08:55:26 <abstrato_general> I was thinking of NTFS. Sorry.
08:55:41 <shapr> In my opinion, any programmer using windows is like a mechanic who buys a car with the hood welded shut.
08:55:57 <abstrato_general> the thing is, I am not a programmer. I'm an economist.
08:56:06 <shapr> well, ok then.
08:56:33 <abstrato_general> I work with computer simulations, neural nets et al. But I also have to deal with spreadsheets, and Word documents containing equations (I use Latex for the stuff I write, yes), etc.
08:56:41 <abstrato_general> In the real world, you need to work with other people.
08:56:41 <shapr> but anyone who uses ion3 and haskell sounds more like a programmer than an end-user to me.
08:56:55 <shapr> 1000 lemmings can be wrong.
08:56:57 <abstrato_general> I'm a geek. I enjoy computers.
08:57:05 <chucky> shapr: I think many mechanics might do just that. Sort of like one of the sysadmins at Chalmers I talked to. He runs Red Hat, because it just works, and he doesn't want to administrate stuff at home
08:57:09 <abstrato_general> Linux makes a computer enjoyable to use.
08:57:31 <shapr> When people send me ms.doc files, I send them .dvi files.
08:57:35 <chucky> ha ha
08:57:35 <abstrato_general> But I have to live in the real world.
08:57:44 <abstrato_general> if you send them .dvi files, they download Yap and keep on living.
08:57:46 <shapr> abstrato_general: so do I, I'm self-employed =)
08:58:01 <abstrato_general> I'm in an academic research project with a govt. grant.
08:58:04 <shapr> I have very much put my money where my mouth is.
08:58:43 <shapr> Most of my paying work lately comes from EU Projects.
08:59:04 <shapr> I think it's even more important for gov't funded work to use open source formats.
08:59:28 <abstrato_general> I can use open source formats.
08:59:33 <abstrato_general> I write most of my stuff in latex.
08:59:45 <abstrato_general> I make sure my Matlab code runs in Octave, etc.
08:59:55 <shapr> But you switched back to windows because of xls compatability?
08:59:57 <abstrato_general> the thing is, I can work with the open source world from Windows.
09:00:10 <abstrato_general> but I can't work with the Windows world from Linux.
09:00:40 <shapr> I don't believe you. But I'm open to proof.
09:00:43 <chucky> I recognize that problem all too well
09:01:19 <shapr> In what way can you not work with the windows world from Linux?
09:01:21 <abstrato_general> Working with the Windows world was one of the causes. Poor desktop-oriented performance on older computers was another one.
09:02:30 <abstrato_general> finally, it took me just too bloody much time to get things working. And while I enjoy to hack things into working, I need to get my actual work done too.
09:03:04 <shapr> Do you have any specific instances?
09:03:33 <abstrato_general> 1) I can't open .xls files past simple tables. 2) I can't open word documents with embedded equations. 3) I can't use my banking site.
09:03:52 <abstrato_general> Those would be the biggies, the one I got stuck in the most times.
09:04:31 <abstrato_general> There is a _load_ of minor annoyances that are workaround-able. Those three are big problems.
09:04:32 <shapr> 1) works fine for me with OpenOffice.org, I've never tried 2) and I switched banks because of 3) so now it's not a problem.
09:05:09 <tuomov> 3) the problem is ie, not linux?
09:05:11 <shapr> Do you have a handy word doc with embedded equations?
09:05:26 <abstrato_general> hmm. I'll look up a web link.
09:05:39 <abstrato_general> I'm behind a proxy. No DCC's here.
09:05:43 <marcot> shapr: I was changing the examples/Keymap.hs
09:06:12 <marcot> shapr: When I change it and replace Yi/Keymap.hs with it it doens't compile.
09:06:27 <shapr> Well, if you happen to know of an online ms.doc file with embedded equations, I'd like to try it.
09:06:40 <abstrato_general> bah, damn IIS :-P the university network is down.
09:07:02 <shapr> tuomov: we had two different banks, one for personal, one for business. The business account was only accessible with MSIE.
09:07:04 <abstrato_general> I don't disagree that a typical linux install is better engineered than Windows in many aspects.
09:07:49 <shapr> So we moved our webwitches.com banking to the bank where online banking worked fine with Mozilla.
09:07:57 <abstrato_general> but there are so many minor annoyances and a few show-stoppers, so.
09:08:16 <abstrato_general> Mozilla and Firefox were so slow it was unusable on Linux for me.
09:08:21 * abstrato_general hollas to tuomov.
09:08:25 <shapr> We asked beforehand, of course. "Do you plan on supporting non-MSIE banking?." "No." "Okay then, can you send our money to this other bank?"
09:08:38 <abstrato_general> You should write something like ion3 for Windows, tuomov.
09:08:45 <abstrato_general> I sure miss them tabs :)
09:09:00 <shapr> abstrato_general: that's shocking... I've used mozilla on a 600MHz box with 512mb of ram, with no problems.
09:09:12 <abstrato_general> this is a 300Mhz box with 384 megs of RAM.
09:09:21 <shapr> oh, I thought you said it was 500MHz
09:09:33 <abstrato_general> the other box is a 500 Mhz.
09:09:44 <shapr> hoi goron 
09:09:58 <shapr> marcot: if it didn't compile, I guess you need to fix the compile errors :-)
09:10:33 <abstrato_general> on the 300 Mhz box running windows XP, I have 5 gvim windows, 2 mozilla windows full of tabs, Gaim, Soulseek, Shareaza, KCeasy, Hugs98, Matlab, Maple, five excel spreadsheets and two mIRC instances. And it's SMOOTH. 
09:10:34 <goron> hej shapr (Is there another word than hej that means (hej or hello) in Swedish)?
09:10:37 <abstrato_general> It's all very smooth.
09:10:52 <shapr> goron: there's tjenare which is like "hey" and tja which is like "yo"
09:10:58 <abstrato_general> Linux would slow to a crawl if I ever attempted to have, say, three OO documents and Gaim on.
09:11:08 <marcot> =)
09:11:14 <abstrato_general> Many of these apps are the very same apps, mind you. Gaim, Mozilla and so on. 
09:11:44 <goron> shapr: I thought hej meant hi in English. What's the diff. with hey?
09:11:57 <goron> abstrato_general: You could use CrossOver Office. 
09:12:08 <abstrato_general> goron It'd prolly be Even Slower (tm). 
09:12:16 <shapr> abstrato_general: I'd have to see it to believe it.... it sounds like a broken (ie terribly inefficient) configuration to me.
09:12:29 <abstrato_general> I did use Wine with a few little games like Chips' Challenge, and it was all okay.
09:12:33 <goron> abstrato_general: How many RAM?
09:12:36 <shapr> hej d99mary 
09:12:42 <d99mary> hallå
09:12:56 <d99mary> jag tror jag blir galen!!
09:12:57 <abstrato_general> shapr Heh. I did try several distros, WM's, I did two gentoo installs, I tried different combinations of prelinking, etc.
09:13:01 <bojohan> hej!
09:13:08 * abstrato_general has 384 megs of RAM.
09:13:15 <d99mary> varför hittar inte mina filer fromInt, fromDouble?
09:13:19 <shapr> abstrato_general: well, I look forward to hearing how linux and windows compare for you with newer hardware.
09:13:27 <goron> abstrato_general: Should be enough. 
09:13:32 <TheHunter> hmm, does ghc-cvs have an additional parameter (apart from -fglasgow-exts) for higher rank types?
09:13:38 <abstrato_general> I look forward to having new hardware. Except I won't, for a while.
09:13:47 <shapr> d99mary: because that's oldsk00l.. it's fromIntegral now
09:14:02 <shapr> at least, fromInt is fromIntegral
09:14:07 <shapr> @index fromInt
09:14:08 <lambdabot> bzzt
09:14:11 <shapr> @index fromIntegral
09:14:12 <lambdabot> GHC.Real,Prelude
09:14:15 <shapr> @index fromDouble
09:14:16 <lambdabot> bzzt
09:14:26 <abstrato_general> And the QA of x86 components is so bad lately - I keep on seing mobos with leaky capacitors after a year or so - that I'm actually considering shelling out the extra cash for a mac.
09:14:41 <shapr> depends on which mobos you get.
09:14:42 <Igloo> fromRational.toRational, I think
09:14:51 <shapr> my Tyan dualie is doing fine.
09:15:04 <abstrato_general> I am a geek and enjoy computers, but I don't have the time to keep current on which mobos are working and which aren't. 
09:15:19 <abstrato_general> I'd rather spend my free time learning stuff like Haskell.
09:15:38 <shapr> well, I can give you the easy solution, don't buy VIA motherboards ever
09:15:43 <shapr> don't buy Promise hardware, ever
09:16:13 <shapr> Tyan and Intel make good solid motherboards and chipsets. Via will break horribly in ways you've never imagined.
09:16:39 <Lunar^> abstrato_general: :)
09:17:00 <shapr> d99mary: Fran/TK ?
09:17:12 <abstrato_general> Windows is very OK since they began using NT-based kernels for the consumer products.
09:17:36 <shapr> In general, name-brand hardware is worth the extra cost when buying hardware.
09:18:06 <abstrato_general> It has a few pitfalls, but those are fixable. And since I'm forced to be behind a proxy that doesn't let me run any services to the outside, I don't even care about the pesky service exploits that plague some Windows shops.
09:18:21 <abstrato_general> shapr Then again, "Apple" is name-brand hardware.
09:18:28 <goron> abstrato_general: It's only a pity that the title of your DVD is sent to a MS server, when you play one...
09:18:37 <shapr> yes, Apple is good linux hardware =)
09:18:48 <abstrato_general> I don't play DVD's on my computer. 
09:18:58 <abstrato_general> I downloa divx files and play them with a bootable linux cd called Movix.
09:19:03 <Lunar^> shapr: :))
09:19:27 <shapr> salut Lunar^ 
09:19:33 <goron> np_hard: Do you do anything with NP-Hard?
09:19:52 <shapr> j'oublie mes questions au hOp :-/
09:20:10 <Lunar^> shapr: sur hOp ?
09:20:14 <shapr> yah, that too
09:20:16 * shapr grins
09:20:19 <np_hard> not much
09:20:29 <Lunar^> shapr: Thomas Halgren made an update for next HC&R
09:20:32 <shapr> cool!
09:20:46 <shapr> I wish Gadgets had an libre license :-(
09:20:54 <shapr> d99mary: have you tried wxFruit?
09:20:59 <abstrato_general> I wish tuomov would write something like ion3 for win32.
09:21:02 <Lunar^> shapr: My studies and other tech-political stuff takes a lot of my time currently
09:21:13 <shapr> that's understandable.
09:21:21 <Lunar^> shapr: But, I am going to follow a course about drivers next semester :))
09:21:21 <goron> Lunar^: Are you also involved in House?
09:21:31 <shapr> cool!
09:21:48 <shapr> do you think you'll be able to come to EuroHaskell again? Or will you be a poor student?
09:21:57 <tuomov> abstrato_general: I will never touch any m$ apis if I can avoid it. *yuck*
09:22:07 <abstrato_general> Write in cygwin.
09:22:31 <tuomov> and I don't think one could even get something like Ion to work in win32
09:22:35 <Lunar^> shapr: And during next semester, we have to make a projet. We've asked with a friend about hacking GHC to add C compilation to it
09:22:37 <abstrato_general> you can.
09:22:38 <tuomov> apps have too much control over their windows
09:22:45 <abstrato_general> there are many alternative shells for windows.
09:22:48 <abstrato_general> LiteStep, for one.
09:22:49 <shapr> d99mary: http://www.haskel.org/yampa http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
09:22:50 <tuomov> an app hangs and its windows hang too
09:22:55 <tuomov> yes, they are library hacks afaik
09:23:01 <Lunar^> shapr: I don't if we are going to do it, but the teacher accepted it
09:23:11 <shapr> Lunar^: which friend? anyone I know?
09:23:27 <Lunar^> shapr: nope, I just met him at the university
09:23:38 <shapr> ok
09:23:45 <tuomov> and what would cygwin help? You can already compile ion under cygwin and use it as a an x window manager in windows
09:24:08 <abstrato_general> hmm. can you?
09:24:30 <Lunar^> shapr: For EuroHaskell, I don't think that it will be possible
09:24:35 <tuomov> of course it will only manage x apps
09:24:35 <shapr> quelle dommage
09:24:46 <shapr> maybe EuroHaskell 2006
09:24:57 <Lunar^> shapr: I'd rather spend my time working on hOp than working to get money for EuroHaskell
09:24:58 <shapr> we could do EH06 in france =)
09:25:35 <Lunar^> shapr: But there's always Libre Software Meeting in Dijon in July if you're interestd
09:25:58 <Lunar^> shapr: I think there will be a quite big Zope track
09:26:23 <Lunar^> We should do EH06 in Glasgow :)
09:26:36 <shapr> oh, that would be cool!
09:26:56 <Lunar^> praise Simons lord, etc.
09:27:01 * shapr laughs
09:27:27 <Lunar^> erf... I did not reply to goron
09:27:53 <Spark> bleh
09:27:57 <Spark> this is the wrong time of day to get up
09:28:18 <shapr> depends on your timezone.
09:28:25 <shapr> But I know you're CET, so I agree.
09:28:56 <Spark> mm is bst equivelant to cet?
09:29:04 <Spark> its 17:34
09:29:10 <shapr> oh, 18:34 here
09:29:18 <shapr> unless I forgot to fix my clocks
09:29:19 <Lunar^> GMT + 1 now
09:29:21 <Spark> we got an extra hour of clubbing last night because the clocks went back
09:29:36 <Spark> it was like RRAAAR WHITE NOISE
09:29:48 <shapr> oops
09:29:52 <shapr> I had more to say to d99mary
09:29:55 <shapr> oh well.
09:30:13 <Spark> i need to submit my prolog assignment
09:30:25 <shapr> I need to submit to the LAW!
09:30:30 <Spark> dont we all
09:30:44 <Spark> ive decided industrial music is linked to bdsm
09:31:02 <Spark> because its just at the edge of whats comfortable and you can let it lift you up and beat you about a bit
09:31:19 <Spark> or you can have it be your power source as you munt around
09:32:03 <abstrato_general> that's Glenn Branca, not industrial music.
09:32:46 <shapr> what counts as industrial?
09:32:58 <shapr> Spark: have you seen my writings on speaker worship? 
09:33:14 <Spark> noise and ebm and stuff
09:33:16 <Spark> nope url? :)
09:33:20 <Lunar^> shapr: Do you still have a blog somewhere ?
09:33:20 <shapr> umm... not sure...
09:33:35 <shapr> Lunar^: yes, I've moved it. http://www.scannedinavian.org/~shae/blog/
09:33:43 <shapr> I'll probably put it on blog.scannedinavian.org soon.
09:34:00 <shapr> anyway PLog 0.0.6 is going to come out soon, and it has RSS.
09:34:06 <shapr> I have a warez copy, of course =)
09:34:19 * shapr is the master of Haskell Warez
09:34:21 <Lunar^> June 16...
09:34:37 <shapr> I haven't written anything lately....
09:34:44 <Lunar^> that's not what I call having a blog :)
09:34:45 <shapr> but I have been thinking a lot, so I have a lot to write.
09:34:47 <shapr> ok ok
09:34:51 <shapr> I'll write something tonight!
09:34:54 <Lunar^> :))
09:35:02 <Lunar^> Do not worry about it, really :)
09:35:09 <shapr> my first blog post is about length being harmful for Haskell
09:35:13 <shapr> and how atLeast is bett.r
09:35:15 <shapr> better
09:36:18 <shapr> I think I should write about arrows too, since most people don't seem to see why they're better than, or different from monads
09:36:27 <shapr> but I need more funny pix :-/
09:36:44 <shapr> greetz stepcut 
09:36:57 * Lor is not convinced that arrows are a better way of doing static computations than macros.
09:37:11 <stepcut> greetz shapr
09:37:33 <stepcut> my girlfriend is making band t-shirts for non-existant bands...
09:37:43 <shapr> I'm pretty sure that arrows are better for static computations, but I don't know enough details about macro usage to really argue.
09:37:50 <shapr> cool, what bands?
09:38:00 <shapr> I have some good bands names if you need some.
09:38:19 <shapr> I like "Hedge Wizards" for example
09:38:32 <stepcut> jack and the o'lanterns currenty...
09:38:54 <shapr> Jack Black and the O'Lanterns?
09:38:58 * shapr grins
09:38:59 <stepcut> http://www.n-heptane.com/jack/
09:39:15 <chucky> hmm isn't ghc supposed to swallow -R options happily?
09:39:37 <shapr> whoa,t that's a *great* bio
09:40:10 <stepcut> the single is awesome
09:42:11 <shapr> I have a big pile of random song lyrics... no decent tunes though.
09:42:19 <stepcut> heh
09:42:34 <shapr> I can come up with tunes, but I can't write them down, so I forget them :-(
09:42:46 <stepcut> yeah, that takes practice 
09:42:53 <stepcut> i suck at it
09:43:07 <Igloo> Record yourself humming them?
09:43:08 <chucky> yaaay my heat is back on!
09:43:16 <shapr> Igloo: hm, that's a good idea
09:43:29 <shapr> stepcut: you can write down musical notes that you hear in your head?
09:43:40 <stepcut> but my girlfriend can remember songs she heard once in 4th grade and write them down :-/
09:43:49 <shapr> I just wish I could write music at all.
09:43:58 <shapr> haven't wished it hard enough to learn though...
09:44:08 <Igloo> I find the hard bit is going from melody to decent music
09:44:20 <stepcut> I can sometimes do it, but only with the help of a piano 
09:44:23 <shapr> how do you know if it's decent?
09:44:53 <Igloo> If I don't think "Good that sucks" it's decent
09:44:59 <Igloo> s/oo/o/
09:46:26 <shapr> I bought a shure 55SH II mic for Bea for her birthday.
09:46:26 <shapr> http://www.shuredistribution.co.uk/products_shure/product-Shr-472-56-34.htm
09:46:27 <shapr> Bea can really sing :-)
09:46:36 <stepcut> I have been annoying my neighbors by learning to sing 
09:46:58 <shapr> heh, cool
09:47:10 <shapr> how'd she do the music on that? played it herself?
09:47:28 <stepcut> shapr: the jack and the o'lanterns stuff ?
09:48:13 <shapr> ah
09:48:14 <shapr> yah
09:48:34 <stepcut> I played the guitar, she sang, and the rest was sequenced in with reason
09:49:03 <shapr> nifty
09:49:18 <stepcut> it's a cover of a song her sister wrote when she was 7 or something. The hard part was getting the terrible singing down right :)
09:52:23 <cm> g'morning
09:53:49 <Spark> heh
09:54:22 <stepcut> shapr: i think the next band t-shirt is for the disinfecticons (and may the antisepticons)
09:58:13 <shapr> antisepticons is nice.
09:58:42 <stepcut> the logo is great
10:00:22 <stepcut> american apparel just openned a store down the street, so now we can get good, keep t-shirts for silk screening really easy
10:04:35 <shapr> I think t-shirts showing famous computer scientists as rock stars would be cool.
10:04:51 <stepcut> haha
10:04:58 <shapr> Alan Turing & The Machines
10:05:10 <shapr> Philip Wadler and the 'Nads
10:05:13 <stepcut> nice!
10:05:23 * Oejet is imagening Knuth with an electric guitar.
10:05:26 <stepcut> I think we might have to do the Alan Turing one soon
10:06:16 <stepcut> Simon and the Glorious Haskells
10:06:21 <shapr> Donald Knuth - World tour 2005 :  Down, Dirty, and wrapped in Latex
10:06:37 <stepcut> haha
10:07:00 * Igloo bangs his head on cabal and stubs his toe on hunit
10:07:10 <shapr> Simon and Simon and the Kombinators
10:07:14 <stepcut> haha
10:07:43 <shapr> or Simon PJ, the Spineless, Tagless, G-spot Machine
10:07:52 <stepcut> hahah
10:08:02 <stepcut> this is great!
10:08:09 <shapr> you want more? =)
10:08:12 <stepcut> hell yaeh
10:08:22 <shapr> hmm
10:08:47 <stepcut> I have been planning to switch my wardrobe to jeans and t-shirts
10:08:50 <stepcut> but I need more t-shirts
10:09:08 <shapr> Alonzo and the Preachers - Separation of Church and State.
10:09:26 <shapr> that one could be better....
10:09:35 <stepcut> hehe
10:10:03 <stepcut> maybe we need some yi t-shirts
10:10:22 <shapr> Ada Lovelace would make a good geek t-shirt all by herself.
10:10:28 <shapr> She was one crazy brilliant chick.
10:10:49 <shapr> You might have to tone down reality to get people to print it.
10:11:24 <stepcut> I can print them myself in small quantity
10:11:50 <shapr> they'd be easy to design too
10:12:29 <stepcut> I wonder what should go on the yi t-shirt
10:12:36 <shapr> put the Yi character on the sleeves
10:12:49 <shapr> or on the breast logo spot if sleeve printing is expensive
10:13:19 <stepcut> for DIY it makes no difference
10:14:17 <shapr> let's see... the easiest approach would be the anime/otaku ripoff where you use a big red blocky version of the Yi character on a black t-shirt
10:14:52 <stepcut> i still have not figured out how to get emacs to produce the Yi character :(
10:16:02 <shapr> On the back, quotes like "It's just a simple functional language -- Simon Peyton-Jones" and "Shirts off to Wadler -- Simon Peyton-Jones"
10:17:16 <shapr> I'm sure I could come up with a bunch of ideas, and then you can sort out which ones don't suck.
10:18:01 <shapr> tetragram for change would fit in there nicely
10:18:26 <shapr> and I'd love to have the hand of eris somewhere in there
10:18:37 <Igloo> "<Yi character>. Enough said."?
10:19:07 <stepcut> heh
10:19:17 <stepcut> cool, well I am going out for tea, be back later
10:21:26 <Igloo> @seen SyntaxNinja
10:21:26 <lambdabot> I haven't seen SyntaxNinja
10:21:45 * Igloo gives LambdaBot a pair of glasses
10:26:11 <abstrato_general> I used to be Syntax_Recorded.
10:40:52 <Lemmih> Hey Boegel
10:41:14 <Boegel> hello
10:41:20 <Boegel> just checking things out...
10:41:37 <Boegel> I've almost implemented specular lighting, but there still are some problems with it
10:42:09 <Boegel> when I change an object's anchor (place in the scene) with 1, I get a whole different image 
10:42:21 <Boegel> so I think there's something not quite right in my implementation
10:48:29 <LittleDa1> is there any runtime dispatch with type classes?
10:49:11 <Lor> Usually.
10:49:27 <LittleDa1> really? I thought it was all at compiletime
10:49:50 <Lor> Compile-time specialization is possible, but it is an optimization and not done all the time.
10:49:56 <Lor> (Since it increases code size.)
10:50:08 <LittleDa1> so there's runtime type information?
10:50:14 <Lor> And some things such as existentials and polymorphic recursion practically require run-time dispatching.
10:50:27 <LittleDa1> what are those?
10:50:45 <Lor> For each class instance there is a "dictionary" object that contains the implementations of the class functions for that instance.
10:50:52 <Lor> These dictionaries are then passed around implicitly.
10:51:30 <LittleDa1> doesn't that take a lot of memory?
10:52:05 <Lor> Memory? No, why?
10:52:19 <Lor> There are only a limited number of instances and dictionaries.
10:53:27 <LittleDa1> what are existentials and polymorphic recursion?
10:54:20 <Lor> It's a bit complicated. GIYF.
10:54:20 <LittleDa1> are there any papers on how typeclasses are implemented?
10:54:59 <Lor> Yes.
10:56:20 <mattam> GIYF ?
10:56:31 <LittleDa1> Google Is Your Friend
10:56:38 <LittleDa1> had to look it up myself
10:56:42 <mattam> haha
10:57:18 <Lor> That's the politically correct way of saying "STFW".
10:57:44 <mattam> i see
10:59:18 <mattam> hmm, so the compile-time specialization is done 'parcimoniously' ? is there a way to tweak ghc to do it completely ?
11:00:16 <Lor> There might be a flag for it. But why would you want that?
11:00:26 <LittleDa1> to make it faster
11:00:32 <LittleDa1> wouldit be faster?
11:00:46 <Lor> ghc probably knows better than you what would be faster.
11:00:48 <XTL> Oh. Snow.
11:01:04 <Lor> In Oulu? Cool.
11:01:26 <LittleDa1> oh, I didn't know existential types existed. they sound cool
11:01:29 <abstrato_general> cool. it's damn hot in here.
11:01:43 <mattam> well, it's certain it will be faster without runtime dispatch isn't it ?
11:01:57 <Lor> Is it?
11:02:30 <mattam> i can't see why there would be more cache misses or things like that
11:02:34 <Lor> When everything is specialized, there might be much more code, which then wouldn't fit in the cache, and the cache misses would slow down the program.
11:04:26 <mattam> i assume there are lots of misses already due to runtime dispatch, anyway i'd like to see numbers
11:05:31 <Lor> Due to runtime dispatch?
11:05:55 * abstrato_general is in Rio de Janeiro.
11:06:09 <Lor> Anyway, I have no idea about these things, but I do expect that if specializing everything would really make things faster, ghc would do it when optimizing.
11:06:32 <mattam> dereferencing and jumping to an adress out of the cache 
11:06:52 <mattam> well, some people don't like big executables...
11:06:54 <Lor> Why do you expect that the address would be out of cache?
11:07:16 <Lor> Individual dictionaries take much less size than all the specialized functions.
11:07:31 <Lor> space.
11:07:57 <mattam> i don't know, maybe
11:09:36 <abstrato_general> So what does a Haskell compiled program _do_? 
11:09:42 <abstrato_general> I mean, I've been using hugs
11:09:47 <abstrato_general> I declare a lot of functions, and use them later.
11:10:03 <Cale> abstrato_general: it executes main
11:10:04 <abstrato_general> But what would hte compiled bunch of function do ? 
11:10:04 <LittleDa1> abstrato: what do you mean? It can be executed like any other compiled program
11:10:05 <abstrato_general> ahh.
11:10:05 <jadrian> abstrato_general: you declare a  main :: IO(...) function
11:10:09 <jadrian> and it is executed
11:13:34 <LittleDa1> Lor: I couldn't find anything on polymorphic recursion on Google
11:14:41 <jadrian> h f = last  . unfoldr f    <- is this a bad idea, efficiency-wise?
11:15:07 <Lor> Um. I get 'Results 1 - 10 of about 2,530 for "polymorphic recursion".'
11:15:20 <jadrian> can I expect the compiler to get rid of the intermediate structure?
11:16:21 <Lor> Try it and see.
11:16:30 <Lor> I would expect so.
11:16:36 <Lor> ghc has heaps of deforestation optimizations.
11:16:58 <jadrian> k I'll try then
11:19:01 <Lor> @type until
11:19:02 <lambdabot> until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
11:19:07 <Lor> That might also be useful.
11:19:39 <XTL> Funny (not really) five-minute network jam
11:19:46 <jadrian> Lor: not really... 
11:19:54 <jadrian> Lor: it's very close 
11:19:58 <jadrian> Lor: but not usable
11:20:37 <jadrian> Lor: last  . unfoldr f <- returns the last element that doesn't give you a Nothing
11:20:59 <jadrian> Lor: now if you try to use "until" you'll end up get the nothing itself
11:21:04 <Lor> Right.
11:21:42 <jadrian> Lor: I've also wondered if I was reinventing the wheel with that function
11:21:50 <jadrian> Lor: but I cannot find it in the std libs
11:22:24 <jadrian> in fact
11:22:46 <jadrian> we have
11:22:58 <Lor> If it can be expressed as a combination of two standard functions, it probably doesn't need to be included separately.
11:23:15 <jadrian> iterate ---- until 
11:23:24 <jadrian> unfold ---- (my function)
11:23:36 <jadrian> ...
11:23:53 <jadrian> and you have "iterate" and "until" in libs
11:24:07 <jadrian> the relationship between them is exactly the same
11:26:37 <mattam> @index unfold
11:26:37 <lambdabot> bzzt
11:27:05 <jadrian> mattam: unfoldr
11:27:12 <mattam> @index unfoldr
11:27:13 <lambdabot> Data.List,List
11:27:14 <jadrian> @index unfoldr
11:27:15 <lambdabot> Data.List,List
11:27:24 <mattam> @type List.unfoldr
11:27:26 <lambdabot> List.unfoldr :: forall a b. (b -> Maybe (a, b)) -> b -> [a]
11:34:47 <Igloo> Who maintains HUnit?
11:36:34 <jadrian> Igloo: acording to SF, Dean Herington does...
11:36:46 <jadrian> Igloo: http://sourceforge.net/project/memberlist.php?group_id=46796
11:37:07 * Igloo is trying to work out why fptools has a hierarchial library version, but SF doesn't
11:37:39 <jadrian> SF?
11:37:54 <Igloo> You used it yourself 2 lines preiously...
11:37:56 <tromp> @type foldl
11:37:57 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
11:38:10 <jadrian> Igloo: meaning SourceForge...
11:38:18 <Igloo> Right, I meant the same thing
11:38:39 <jadrian> Igloo: oh, I thought you meant some other tool...
12:54:18 <tromp> @type (>>=)
12:54:20 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
13:01:09 <yeti> good evening #haskell
13:01:47 <Lemmih> Hello yeti
13:22:46 * shapr waits for his code to build...
13:22:52 <Etaoin> yay
13:24:17 <yeti> i admire the guys who made ghc - i imagine that writing a compiler for a functional language must be terribly difficult
13:25:54 <tromp> but terribly rewarding too
13:26:07 <tromp> it's by far the most used haskell application:)
13:33:09 <Etaoin> anyone have any comments on using a global IORef a with unsafePerformIO verses using a StateT a IO?
13:34:33 <abstrato_general> isn't "[Int] -> Int" a special case of "[a] -> a"? 
13:35:28 <wilx> It seems so. from my newbie perspective.
13:35:44 <abstrato_general> mean :: [Int] -> Int
13:35:44 <abstrato_general> mean list = (sum list)/(length list)
13:35:46 <Etaoin> ditto
13:35:47 <abstrato_general> oops.
13:35:49 <shapr> Etaoin: well, IORefs and unsafePerformIO can be way fast, but if they blow up, it's your own fault =)
13:35:55 <abstrato_general> it previously was mean :: [a] -> a
13:36:02 <abstrato_general> and I got the following error:
13:36:07 <abstrato_general> (in hugs98, haskell mode)
13:36:18 <abstrato_general> ERROR "c:\stata.hs":2 - Inferred type is not general enough
13:36:18 <abstrato_general> *** Expression    : mean
13:36:18 <abstrato_general> *** Expected type : [a] -> a
13:36:18 <abstrato_general> *** Inferred type : [Int] -> Int                    
13:36:23 <Etaoin> shapr: how could they blow up?
13:36:24 <shapr> Etaoin: imho, unsafePerformIO is usually a sign of premature optimization, unless carefully used after profiling.
13:36:32 <shapr> cuz it's unsafe
13:37:11 <shapr> when lambdabot had the GHCi plugin, Derek Elkins crashed the whole RTS it in several interesting ways with unsafe* calls.
13:38:52 <yeti> hmm, i think i'm stuck with "yet another haskell tutorial" - i'll buy a book. is "haskell - the craft of functional programming" by simon thompson a good book for beginners?
13:39:25 <shapr> yah, it's pretty good.
13:39:38 <shapr> you may prefer Hudak's book if you have a decent math background...
13:39:45 <shapr> that is, basic geometry
13:39:58 <Etaoin> What I want is a global mutable variable and using using unsafePerformIO is a really obvious way to do it. using the state monad and somehow wrapping in an IO monad seems less obvious
13:41:19 <Philippa> IORef
13:41:23 <abstrato_general> What the hell does "Inferred type is not general enough" mean?
13:41:35 <abstrato_general> I explicitly declared types. Don't try to infer them!
13:41:53 <Philippa> it probably means that the inferred type isn't general enough to match your explicit type
13:42:07 <yeti> shapr: some of the user's feedbacks on amazon.com say that hudak's book isn't really for beginners - so i think i'll try to get thompsons' :) thanks
13:42:12 <abstrato_general> It's inferring it wrong.
13:42:24 <abstrato_general> I want it not to infer and just do what I'm telling it to.
13:42:35 <shapr> it depends on what you're telling it.
13:42:36 <Philippa> there's no / operator on Int
13:42:43 <abstrato_general> I know. 
13:42:48 <chucky> try taking away your type declaration to see what it wants
13:43:03 <abstrato_general> That's why I tried to make it [Float] -> Float first, then [a] -> a
13:43:09 <shapr> yeti: hudak has some worthwhile benefits, for example, you get to use and play with monads and IO without being scared of them.
13:43:15 <Philippa> it's none of those
13:43:20 <Philippa> there's a typeclass involved
13:43:26 <abstrato_general> if I take away the type declaration, it says ERROR "c:\stata.hs":2 - Instance of Fractional Int required for definition
13:43:34 <shapr> plus you get to make pictures and music with Hudak, and Thompson is just about factorial and sort, and boring stuff like that.
13:43:44 <abstrato_general> Floats should satisfy the "Fractional" typeclass, right?
13:43:49 <shapr> yeti: admittedly, I learned from Thompson too, but I wish I'd used Hudak instead.
13:43:50 <Philippa> that's because *there is no / on int*
13:43:55 <abstrato_general> I know.
13:43:58 <Philippa> therefore that function cannot work on a list of ints
13:44:10 <abstrato_general> It seems to be inferring the function is on a list of ints.
13:44:29 <Philippa> what list're you passing it?
13:44:36 <abstrato_general> and if I try to explicitly say it's not, it says its inferring something different from what I say.
13:44:46 <abstrato_general> I tried "[Float] -> Float" first, then "[a] -> a"
13:44:58 <Philippa> yes. It's inferring that it's on Fractional a => [a] -> a
13:45:02 <abstrato_general> "Inferred type is not general enough", it complains.
13:45:11 <abstrato_general> it's inferring [Int] -> Int.
13:45:15 <abstrato_general> That's what annoys me.
13:45:15 <Philippa> that is, it's between a list of some type in Fractional and a value of the same type
13:45:36 <Philippa> no, it's not inferring [Int] -> Int
13:45:38 <abstrato_general> it says "Inferred type: [Int] -> Int"
13:45:50 <tromp> what's a good book for some who understands the basic and wants to do "advanced" haskell programming?
13:45:50 <Philippa> Fractional a => [a] -> a is less general than [a] -> a
13:46:00 <Philippa> ah. It'll be inferring that based on info from the call site then
13:46:05 <Philippa> it thinks you're passing it ints
13:46:17 <shapr> tromp: I don't think there is one, though it really depends on your idea of "advanced".
13:46:19 <Philippa> it's typing the function itself fine, it's where you call it that's the problem
13:46:28 <dash> it's like the Tallest said
13:46:30 <abstrato_general> and then complains the explicit types are too general for the ones it infers.
13:46:30 <Philippa> Fun of Programming?
13:46:38 <dash> "It's not stupid! It's advaaaanced!"
13:46:38 <Philippa> yes. You know why?
13:46:39 <abstrato_general> it's a two-line program.
13:46:44 <shapr> tromp: first of all, advanced Haskell covers a *huge* area.
13:46:49 <tromp> guess nothing beats attending an advanced haskell programming workshop
13:46:52 <shapr> dash: who?
13:46:53 <Philippa> Because Fractional a => [a] -> a is less general than [a] -> a
13:47:03 <dash> shapr: from _Invader Zim_. :)
13:47:09 <abstrato_general> so what? It should suffice :-|
13:47:20 <Philippa> your mean function *does not have type [a] -> a*. It cannot have that type. Fractional a => [a] -> a is as general as it gets
13:47:22 <Philippa> no, it shouldn't
13:47:37 <shapr> tromp: http://www.haskell.org/hawiki/FundamentalConcepts
13:47:40 <Philippa> to give a function an overly-generic type would allow somebody to try to take the mean of a string, for example
13:47:41 <abstrato_general> it's inferring [Int]->Int
13:47:47 <Philippa> and it's inferring that from the call site
13:47:51 <Philippa> where's the call site?
13:48:10 <abstrato_general> it's a two-line file I'm trying to load into Prelude.
13:48:13 <shapr> I think the best way to learn advanced Haskell is to hack on some Haskell code. You'll quickly see what you're missing.
13:48:18 <Philippa> *WHAT IS THE BLOODY CALL SITE*?
13:48:20 <abstrato_general> mean list = (sum list) / (length list)
13:48:29 <Philippa> sure. Now, the second line?
13:48:40 <Philippa> or else, the example code you're testing it with?
13:48:48 <Philippa> oh, wait. length returns an int
13:48:49 <abstrato_general> that is the one actual line of code. The first line was the type declaration.
13:48:52 <Philippa> fair enough. You be screwed
13:48:57 <abstrato_general> ohh.
13:49:02 <tromp> @type (/)
13:49:03 <shapr> abstrato_general: you could paste your code into a paste page somewhere.
13:49:04 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
13:49:12 <abstrato_general> Int, and not Integer, so no fromInteger
13:49:21 <Philippa> it's fromIntegral these days
13:49:23 <abstrato_general> shapr I usually do that.
13:49:29 <abstrato_general> hmm.
13:49:31 <Philippa> which'll apply to any integer type
13:49:36 <Philippa> sorry for the shouting
13:49:51 <tromp> @eval 2%5
13:49:52 <abstrato_general> sorry for the general confusion :-)
13:49:52 <lambdabot> (line 1, column 2):
13:49:52 <lambdabot> unexpected "%"
13:49:52 <lambdabot> expecting digit, operator, simple term or end of input
13:52:19 <shapr> hiya Lemmih
13:52:23 <shapr> um Leimy 
13:52:47 <dash> shapr: I am looking at http://haskell.cs.yale.edu/arrows/
13:52:53 <shapr> and what do you see there?
13:52:59 <dash> shapr: is it my imagination or are arrows easier to understand than monads
13:53:25 <tromp> @index (%)
13:53:26 <lambdabot> bzzt
13:53:40 <shapr> I think arrows are easier to understand than monads.
13:53:48 <dash> ok!
13:53:54 <Philippa> I think arrows're easier to understand than the FP presentation of monads
13:54:10 <Leimy> I think I'm still struggling with monads :)
13:54:26 <Philippa> join is getting on for app
13:54:39 <Leimy> shapr: hello :)
13:54:45 <shapr>  f
13:54:47 <shapr>  But, I think you don't really see just how cool monads and arrows are unless you're looking from the monad perspective.
13:54:53 * shapr smacks his irc client
13:54:59 <Leimy> heh
13:55:13 <Leimy> well I'm trying to design a test harness program
13:55:23 <Leimy> which may include an imperative language
13:55:29 <Leimy> and I want to use haskell
13:55:49 <Leimy> I shouldn't call it a program
13:55:53 <Leimy> it will hopefully be a system
13:55:53 <tromp> happy haskelloween!
13:56:01 <Leimy> indeed :)
13:56:02 <tromp> for you yankees anyway
13:56:14 <Leimy> Halloween is my favorite holiday
13:56:19 <Leimy> in my favorite season
13:56:33 * Leimy <--- into cheesy horror movies
13:56:53 <shapr> Leimy: QuickCheck!
13:57:01 <Leimy> shapr: QuickCheck?
13:57:07 <shapr> yes, it kicks butt.
13:57:08 * dash is torn between the desire to cook and the desire to write more haskell code
13:57:19 <Leimy> shapr: are you telling me this thing exists :)
13:57:27 <dash> http://www.cs.chalmers.se/~rjmh/QuickCheck/ this?
13:57:30 <shapr> that's it
13:57:35 <Leimy> dash: cooking is my second favorite passtime :)
13:57:36 <yeti> dash: write a haskell roboter that cooks for you :)
13:57:56 <Leimy> oooh John Hughes
13:57:58 <Leimy> good stuff
13:58:15 <dash> Leimy: i like cooking but i like eating more!
13:58:19 <dash> and i have no prepared food
13:58:33 <Leimy> hehe
13:58:37 <Leimy> well that's part of the fun
13:58:47 <Leimy> finding out what you like to cook...
13:58:50 <Leimy> and eat :)
13:59:27 <dash> today i think it is chicken stirfry
13:59:55 <yeti> by the way, is ocaml very similar to haskell?
14:00:16 <dash> it is not as rad
14:00:26 <dash> but if pycaml were better i think i would use it a lot.
14:00:28 <Leimy> yeti: it's pretty cool... but the operator syntax is scary :)
14:00:33 <tromp> it's syntax is not as clean
14:00:37 <tromp> i mean its
14:00:58 * Leimy has Hugs on Plan 9 now ... very happy :)
14:00:59 <abstrato_general> grrr. I hate how MSN shows pictures in message windows.
14:01:07 <Leimy> all my obscure tastes on one platform :)
14:01:07 <abstrato_general> People always put up their worst pictures :-(
14:01:11 <tromp> and it's not as minimal in its design as haskell
14:01:30 <abstrato_general> Hugs has a Haskell mode.
14:01:39 <Leimy> ???
14:01:44 <Leimy> Hugs is Haskell :)
14:01:46 <shapr> abstrato_general: want to see my worst pictures?
14:01:51 <Leimy> you mean Emacs?
14:03:57 <abstrato_general> There's this girl I'm interested in from the uni.
14:04:06 <abstrato_general> I actually got MSN so I could chat with her.
14:04:13 <abstrato_general> And she put up a picture where she looks horrible.
14:04:50 <shapr> You could look at me, I'm much scarier. --> http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
14:05:43 <shapr> Ya know... now that I think of it. Putting ugly pictures on MSN probably cuts down on the number of internet stalkers tremendously.
14:05:47 <shapr> I like this girl already.
14:05:48 <monochrom> You don't need haircut.  You need hair conditioner.
14:05:53 <Taaus> shapr: Oh my GOD! That's horrible! You have a Shanghai Noon poster... Nice hair, though.
14:06:01 * shapr laughs
14:06:06 <Leimy> shapr: nice pic
14:06:37 <wagle> cousin it!
14:07:23 <shapr> Of course the 581K hopping unicycle pic is far niftier --> http://www.scannedinavian.org/~shae/unicycle/PA090170.JPG
14:07:27 <yeti> http://dfy.dyndns.org/yeti.jpg <= heh - that's got to be one of my worst pictures then ;)
14:07:55 <Leimy> shapr: hopping unicycle?
14:08:00 <shapr> yeti: if that's worst, you're not doing too bad.
14:08:02 <Leimy> that can't be good :)
14:08:14 <Leimy> for nutz I mean
14:08:17 * stepcut wonders how many #haskell peopl have long hair...
14:08:23 <Leimy> not I
14:08:27 <stepcut> bunch of dirty hippies I tell ya!
14:08:34 <monochrom> I have short hair.
14:08:37 <Boegel> not me either
14:08:41 <chucky> short hair here too
14:08:45 <stepcut> hrm
14:08:47 <Leimy> I bet most of us have cats though
14:08:49 * Boegel would like too see a picture of the regular ones here :)
14:08:55 <yeti> eeww - short hair
14:08:56 * stepcut has long hair and 3 cats
14:08:58 <yeti> you guys are sick
14:09:00 <yeti> :)
14:09:01 <Leimy> 3 cats
14:09:05 <Boegel> 1 cat
14:09:07 <shapr> Actually hopping requires you to stand up on the pedals, so testicles generally stay safe, unless one of your feet slips off the pedal.
14:09:09 <Boegel> and a pussy :p
14:09:15 <Leimy> shapr: sure
14:09:26 <Leimy> Boegel hehe
14:09:33 <Boegel> shapr, and you probably don't want that to happen :p
14:09:42 <stepcut> Boegel: do you have new images (since last weekend)
14:09:55 <Boegel> sure, check my website
14:09:57 * Leimy checks out QuickCheck
14:09:59 <shapr> I have lovely Snafu brand aluminum alloy concave spiked mountain biking pedals, so my feet have never slipped off.
14:10:04 * stepcut finishes his email to Thiemann
14:10:11 <shapr> stepcut: oh, what about?
14:10:12 <Boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website
14:10:16 <shapr> asking for a refactor of WASH?
14:10:33 <shapr> Boegel: yay! POKEMON!
14:10:36 <Boegel> I'm implementing specular reflection now, but I'm having some slight problems with it
14:10:36 <stepcut> shapr: a minor bug in constructQuery, which is called by makeForm
14:11:01 <Boegel> I'll probably have to re-check my normal directions and such to get it solved, shouldn't be too hard to fix
14:11:11 <Boegel> shapr: :o)
14:11:21 <stepcut> shapr: it only affects people who pass multiple command line parameters to cgi apps, which is something wash won't do unless you monkey inside the CGI monad yourself :p
14:11:39 <stepcut> shapr: but I am complaining about hyperlink support (and presenting my solution)
14:11:59 * Boegel is reading "The Haskell School of Expression" to see what he doesn't know about Haskell yet
14:12:08 <Leimy> shapr: is QuickCheck for testing Haskell programs?
14:12:16 <Leimy> I want to test other programs in general
14:12:20 <stepcut> shapr: do you want me to bcc you ?
14:13:42 <desrt> is it bad to feel inclined to use unsafePerformIO in places that you really don't need it at all?
14:14:09 <desrt> doing IO in ghci is just so annoying without it :P
14:14:15 <stepcut> desrt: heh
14:14:48 <Boegel> stepcut, do you like the new images ? :)
14:15:17 <stepcut> Boegel: nice!
14:15:26 <Leimy> so arrows are more general than  monads
14:15:30 <Leimy> hmmmmm
14:15:55 <stepcut> Boegel: how far do you plan to go with this ?
14:16:04 <tromp> no, arrows are different from monads, even if similar
14:16:18 <tromp> some things you can do with monads but not with arrows
14:16:36 <dash> tromp: huh! i missed that
14:17:26 <Boegel> stepcut, as far as it takes :p
14:17:38 <stepcut> but spears can do everything monads and arrows can
14:17:48 <stepcut> however, they have not been invented yet
14:18:13 <Boegel> no, I'll think I'll implement specular reflection, inter object reflection (recursive ray tracing), transparent objects, and some material stuff (perlin noise)
14:18:18 <Boegel> and that will be it I think
14:18:26 <Boegel> because that's not the only thing I have to do
14:18:32 <stepcut> Boegel: tweening and animation ?
14:18:38 <Boegel> stepcut, nah :)
14:18:53 <Boegel> I have to build a simple GUI for it too, probably using FranTk
14:19:14 <Boegel> and maybe a small parser too for the SDL of PovRay
14:19:21 <stepcut> Boegel: blender3d file compatibility
14:19:23 <Boegel> and then write a thesis about my work :)
14:19:30 <Boegel> stepcut, why blender ?
14:19:45 <Boegel> I'm not sure if I'll implement polygons as object....
14:19:57 <stepcut> Boegel: well, others too 
14:20:00 <Boegel> so compatibility with blender has no use then...
14:20:20 <Boegel> because 3D modellers use polygons as basis
14:20:37 <stepcut> ok
14:20:40 <Boegel> I'll see, but I have to have a decent raytracer, which supports some things
14:20:44 <Boegel> so i can move on
14:20:53 <Boegel> I can always implement extra stuff later on
14:21:04 <kosmikus> tromp: every monad is an arrow, so the "more general" statement by Leimy is correct in a sense
14:21:19 <Boegel> or other people can, using my code (and thesis) as a starting point
14:22:23 <tromp> yes, but in another sense, you can do things with a monad that you can't do with the monad-transformed-into-an-arrow
14:23:43 <stepcut> Boegel: do you plan to/have you already released the code ?
14:24:03 <tromp> btw, a Monad m is not itself an Arrow, but (Kleisli m) is
14:24:58 <Boegel> stepcut, I guess I should wait with that until I finished my thesis
14:25:23 <Boegel> but when it has been graded, i see no reason why I shouldn't 'release' my code
14:26:00 <Boegel> it will be described in my thesis, and I'll put a 'release cd' with it, so people can see the program (and FranTk GUI) in action, without having to install stuff
14:26:45 <Boegel> it's perfectly possible to let the program run from a cd, except when you want to save the file (and even then, you can just copy the stuff on the cd onto your hd)
14:27:05 <Boegel> stepcut: so yes, I'm planning to release the code :)
14:27:20 <Boegel> it's not like I'll make money of of it ;)
14:29:06 <stepcut> Boegel: or maybe make a liveCD hOp cd that runs your program ;)
14:29:39 <stepcut> s/liveCD/live/
14:29:43 <abstrato_general> jesus christ on a pogo stick. Turkish pop is so bad.
14:30:07 <stepcut> s/pogo stick/hopping unicycle/
14:30:29 <Boegel> stepcut: live hOp cd ? I don't know that concept (or whatever it is)
14:31:20 <stepcut> Boegel: are you familiar with the concept of LiveCDs ?
14:31:30 <stepcut> like knoppix ?
14:32:42 <Boegel> I know Knoppix, it has rescued me before yes :)
14:32:55 <Boegel> well, that's the whole idea really
14:33:03 <stepcut> have you heard of hOp ?
14:33:11 <Leimy> how is hOp coming?
14:33:12 <Boegel> no, I haven't heard of hOp
14:33:23 <stepcut> ah, hOp is an operating system written in haskell
14:33:25 <abstrato_general> it's da Hall oph Phame.
14:33:40 * abstrato_general coughs.
14:33:46 <stepcut> someone took the GHC RTS out of the compiler turned it into a bootable OS
14:33:56 <stepcut> all the drivers are written in haskell
14:33:57 <abstrato_general> uh wow.
14:34:05 <Leimy> the claim is it's a microkernel
14:34:12 <abstrato_general> wow.
14:34:16 <abstrato_general> wow.
14:34:19 <Leimy> not sure if it's true
14:34:20 <Leimy> :)
14:34:37 <abstrato_general> screw Inferno, that's a 31337 OS to run! :-D
14:35:01 <stepcut> There is also a derivative of hOp named House that has a GUI and some apps
14:35:28 <abstrato_general> ooh. URLs?
14:35:31 <stepcut> hold on
14:36:03 <Leimy> http://www.cse.ogi.edu/~hallgren/House/
14:36:18 <stepcut> yeah, what Leimy said...
14:36:18 <Boegel> stepcut, sounds nice
14:36:48 <Boegel> but that hasn't got anything to do with my thesis, and not everyone who's going to read it knows Haskell
14:36:51 <stepcut> so, for extra nerdiness, you can make a bootable hOp cd that runs your app :p
14:37:18 <Boegel> besides, for my FranTk GUI, I need Tcl/Tk, and I'm guessing that won't run an hOp :)
14:37:23 <Boegel> s/an/on
14:37:35 <shapr> stepcut: I would like to get a copy of your WASH hyperlink suggestion
14:37:45 <stepcut> yeah... House has a nice haskell GUI, but they GUI code has not been released yet :(
14:37:59 <stepcut> shapr: already added you to the bcc :p
14:38:00 <shapr> Leimy: look at QuickCheckM for testing anything from Haskell.
14:38:02 <shapr> stepcut: thanks,
14:38:12 <abstrato_general> wowow.
14:38:24 <Boegel> stepcut, the reason I needto use FranTk is because I will probably (try to) prove some GUI related stuff too
14:38:30 <Boegel> but thanks for the hint :)
14:38:47 <Boegel> I'm going to bed now
14:38:53 * Leimy is now running House in QEMU
14:38:55 <Leimy> on Mac OS X
14:38:57 <shapr> I want hOppix
14:38:57 <Leimy> not too shabby :)
14:39:09 <Boegel> tomorrow is a holiday in Belgium, so I need to do some family visits and such
14:39:18 <tromp> i want hopenstep:)
14:39:21 <shapr> tomorrow is a holidy in sweden
14:39:28 <shapr> I need to do some work =)
14:39:33 <Boegel> :)
14:39:37 <Boegel> bye everyone !
14:39:40 <tromp> g'night
14:39:41 <shapr> bye Boegel!
14:39:51 <abstrato_general> Leimy QEMU is like Bochs?
14:41:03 <Leimy> QEMU is faster than bochs
14:41:09 <Leimy> and emulates PPC, X86 and SPARC :)
14:41:17 <shapr> mips?
14:41:19 <Leimy> though I think x86 is the best one
14:41:21 <Leimy> might do mips
14:41:23 <Leimy> I forget
14:41:31 <shapr> hm, I could play my playstation games on qemu then.
14:41:42 <Leimy> http://fabrice.bellard.free.fr/qemu/
14:41:48 <shapr> there's a bad spot on my GTA3 dvd such that I can't do ambulance missions :-(
14:41:55 <Leimy> it does ARM
14:42:16 <shapr> I wonder how I'd get my save games off the thingy.
14:42:24 <Leimy> heh
14:48:22 <dash> hugs just keeps giving me awesome error messages
14:48:30 <dash> *** Type           : ([a] -> [b]) -> c -> ([b] -> b) -> [b]
14:48:30 <dash> *** Does not match : ([a] -> [b]) -> c -> (([a] -> [b]) -> [a] -> [b]) -> [b]
14:48:30 <dash> *** Because        : unification would give infinite type
14:48:57 <dash> what's wrong with infinite types, i ask! infinity is fun
14:49:07 <abstrato_general> Infinite dreams, I can't deny them
14:49:11 <abstrato_general> Infinity is hard to comprehend
14:49:21 * abstrato_general has a metalhead backlash.
14:49:33 <dash> "space is big / space is dark / it's hard to find / a place to park"
14:49:46 <tromp> haskell things that infinite data should be enough for everyone
14:49:51 <tromp> things->thinks
14:50:58 <abstrato_general> oh please.
14:51:20 <abstrato_general> haskell arrows where haskell arrows belong, you should use :s/wrong/right
14:51:48 <stepcut> dash: there are some bugs that they compiler can not detect if you allow infinite types. You can turn infinite types into finite types by using an additional constructor...
14:51:55 <Leimy> actually
14:51:58 <Leimy> s/wrong/right/
14:53:17 <abstrato_general> hmm. and why omit the ":"?
14:53:19 <dash> stepcut: More likely i have made a good in this code.
14:54:28 <shapr> Ã³la ows 
14:54:46 <Leimy> damn my UTF-7ness
14:54:50 <Leimy> I'm using ERC Version 4.0 $Revision: 1.600 $ with GNU Emacs 21.3.50.1 (powerpc-apple-darwin7.5.0)!
14:54:57 <dash> hmm
14:55:01 <ows> hi shapr!
14:55:10 <dash> putting the args in the wrong order in a lambda will break things, i bet.
14:55:14 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-10-23)!
14:55:47 <Leimy> I built mine from CVS
14:55:50 <Leimy> + Carbon
14:55:53 <Leimy> on Mac OS X :)
14:56:10 <shapr> I'm building my own in Haskell...
14:56:13 <shapr> :-P
14:56:17 <Leimy> you own editor?
14:56:23 <Leimy> s/you/your/
14:56:31 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi
14:56:42 <shapr> actually, dons is the one doing all the code so far...
14:57:17 * Leimy grabxars it
14:57:24 <Igloo> Is there a way of telling cabal to use -O -Wall without using per-compiler options?
14:58:04 <Leimy> ghc-6.2.1: unknown package name: plugins
14:58:07 <Leimy> D'oh!
14:58:19 <shapr> you'll need the latest nightly version of hs-plugins.
14:58:50 <Leimy> no idea what/where that is :)
14:59:10 <Leimy> also darcs?
14:59:31 <jadrian> hello
14:59:34 <jadrian> hi shapr  
14:59:38 <shapr> greetings jadrian 
14:59:56 <shapr> Leimy: http://www.cse.unsw.edu.au/~dons/hs-plugins/index.html
15:00:32 <shapr> darcs has fink, darwinports, and other binaries.
15:01:04 <Leimy> darcs has darwinports binaries?
15:01:08 <Leimy> that's weird
15:01:21 <shapr> er, sorry "package"
15:01:30 <shapr> can be installed with darwinports :-P
15:01:35 <Leimy> heh
15:01:36 <Leimy> I get you
15:01:41 <Leimy> darwinports has darcs
15:01:44 <Leimy> as does fink
15:01:56 <shapr> and there are other MacOS X options too.
15:02:07 <Leimy> yep
15:02:13 <Leimy> I've got darcs already
15:02:16 <Leimy> I use it here in fact
15:02:22 <Leimy> from darwinports
15:03:04 <shapr> anyone know how to use imagemagick to autocrop blank borders from page images?
15:04:43 <stepcut> shapr: check your electronic mail
15:04:59 <stepcut> shapr: no
15:06:13 <abstrato_general> marcot is from brazil too.
15:06:14 <jadrian> shapr: *maybe*, convert -crop 0x0 image
15:06:14 <abstrato_general> wow.
15:07:25 <jadrian> shapr: or mogrify -crop 0x0
15:08:19 <marcot> abstrato_general: vocÃª Ã© daqui tambÃ©m?
15:08:39 <abstrato_general> seus acentos estão todos estranhos, cara.
15:09:25 <marcot> abstrato_general: deve ser o UTF-8, que vocÃª provavelmente nÃ£o estÃ¡ usando.
15:09:42 <abstrato_general> ah, sim.
15:10:04 <shapr> stepcut: man, this is heavy...
15:10:43 * shapr takes a tight curve dealing with 64-bit Uniques
15:11:21 <stepcut> i hope i don't run out of unique 64 bit ids :p
15:11:38 <shapr> why not just use the GHC Unique type and complain if it dies?
15:12:08 <stepcut> what does Unique generate ?
15:12:11 * shapr dunno
15:12:15 <shapr> @index Unique
15:12:16 <lambdabot> Data.Unique
15:12:22 <shapr> @type Data.Unique.Unique
15:12:23 <lambdabot> bzzt
15:12:31 <shapr> ?
15:13:03 <stepcut> shapr: well, the unique numbers are generated by mysql...
15:13:10 <Leimy> shapr: can't build yi on Mac OS X
15:13:17 <Leimy> not on HFS+ anyway
15:13:24 <Leimy> it's case insensitive
15:13:42 <Leimy> and it claims it can't create an output file caled yi because it's a directory
15:13:52 <shapr> oh
15:13:58 <shapr> that sucks
15:14:03 <Leimy> also... I had to make the plugins thingy run ranlib
15:14:10 <Leimy> because ar doesn't automagically make a TOC
15:14:15 <Leimy> on mac os x anyway
15:14:32 <shapr> stepcut: this is a cool proposal.
15:14:45 <Leimy> shapr: yep sure does
15:14:46 <Leimy> :)
15:15:00 <shapr> well, send bug reports to dons 
15:15:02 * jadrian didn't know about unique
15:15:06 <Leimy> HFSX would support it I think
15:15:07 <stepcut> shapr: yeah, I am working on the bugs, but I am interested to see what Thiemann thinks...
15:15:10 <jadrian> I should probably be doing this...
15:15:13 <Leimy> since that will have case sensitivity
15:15:18 <jadrian> s/doing/using
15:15:34 <jadrian> damn...
15:15:57 <stepcut> shapr: I think any additional changes I make will be mostly cosmetic
15:16:27 <stepcut> shapr: crap, I forgot to mentian that URLs have a length limit :(
15:19:08 * Leimy wonders if any Haskell GUI stuff works in hugs98
15:19:13 <shapr> stepcut: btw, (5) is what Zope does, and it plays (sometimes permanent) havoc when two extensions conflict
15:19:25 <Philippa> Leimy: most likely, hugs98 has working FFI doesn't it?
15:19:39 <Leimy> Philippa: it might...
15:19:47 <dons> Leimy: hs-plugins gets pretty good macosx testing. can you send patches?
15:19:49 <shapr> hej tic
15:19:58 <Leimy> dons: sure... it's just a static lib issue
15:20:01 <shapr> g'day dons 
15:20:03 <Leimy> it made "ar" libs
15:20:09 <Leimy> but didn't ranlib them
15:20:11 <Leimy> so I did it manually
15:20:14 <dons> I wonder why this hasn't been spotted before
15:20:15 <Leimy> and it's fine now
15:20:34 <Leimy> all I did was ./configure && make clean all && sudo make install && sudo make register
15:20:49 <dons> hmm. which hsplugins version?
15:20:52 <Leimy> then when I went to use it in yi it cried about tables of contents
15:20:53 <dons> because it does this:
15:20:55 <dons> $(LIBRARY): banner $(COBJ) $(XOBJ) $(YOBJ) objs
15:20:55 <dons>     $(RM) -f $@
15:20:55 <dons>     $(AR) cq $@ $(OBJS)
15:20:55 <dons>     $(RANLIB) $@
15:21:00 <Leimy> dons: right...
15:21:03 <Leimy> but if you copy it elsewhere
15:21:10 <Leimy> the toc must be updated
15:21:12 <stepcut> shapr: in my stuff I am not sure you can have a conflict, because you would have to have two modules with the same name, which haskell does not allow 
15:21:15 <Leimy> so ranlib should be part of installation
15:21:15 <dons> oh, ok!
15:21:17 <Leimy> :)
15:21:25 <Leimy> two-level namespaces for symbols on OS X :)
15:21:29 <Leimy> part is the path to the lib :)
15:21:44 <dons> excellent point. thanks :)
15:21:50 <dons> now, what was wrong with yi?
15:21:50 <Leimy> no problem
15:21:55 <Leimy> case sensitivity
15:21:59 <dons> I haven't tested it on the mac yet
15:21:59 <Leimy> it wants to make a file called yi
15:22:02 <Leimy> but it can't
15:22:07 <Leimy> because there is a dir called yi
15:22:18 <Leimy> and the only difference is probably the case
15:22:20 <dons> it wants to make aa file called yi?
15:22:25 <dons> hmm. doesn't sound right
15:22:29 <Leimy> yeah 
15:22:32 <Leimy> hold on :)
15:22:32 <shapr> stepcut: problem with zope is that there is no protected address space. All plugins have system-level privs, so they can easily step on each other.
15:22:32 <dons> it tries to make the ~/.yi directory
15:22:34 * Leimy retries
15:22:44 <Leimy> dons: during a compile?
15:23:02 <Leimy> ghc -o yi  -lncurses -package plugins Boot.o
15:23:07 <dons> oh, ok. I get it
15:23:11 <dons> Yi conflicts with yi
15:23:12 <Leimy> and there is Yi
15:23:13 <Leimy> right
15:23:14 <Leimy> :)
15:23:16 <Leimy> that's the problem
15:23:19 <dons> Yi/ and yi the executable
15:23:20 <dons> hmm
15:23:25 <dons> that sucks
15:23:28 <Leimy> HFSX can do case sensitivity but it's not really supported on Panther
15:23:30 <Leimy> maybe in Tiger :)
15:23:36 <Leimy> it works on OS X server
15:23:40 <shapr> stepcut: this is cool, I'll reread it a few times and think about how Zope/J2EE/your code does things... I'm sure there's a great lesson about modularity in there somewhere.
15:23:43 <Igloo> Is Yi the root of its hierarchial libs or something?
15:23:47 <dons> yep
15:23:56 <Igloo> You could stick it in src/Yi then
15:24:02 <dons> so 'yi' the executable can be named something else, and installed as yi
15:24:09 <dons> because you use yi-inplace in-tree anyway
15:24:18 <dons> that should fix it
15:24:26 <Leimy> I was going to try "_yi"
15:24:37 <stepcut> shapr: cool! Hopefully something  official will come out of this one way or another
15:24:56 <dons> you can test by hand. rename yi to something. edit yi-inplace
15:25:02 <dons> the test ./yi-inplace
15:25:03 <desrt> so...
15:25:15 <desrt> i have some nice recursive functions
15:25:23 <stepcut> shapr: maybe someday I will also look at a replace for wash/html, because the syntax drives me up the wall
15:25:26 <desrt> and every now and then i want to generate a unique label inside
15:25:35 <stepcut> but the cgi and html parts are largely independant
15:25:37 <shapr> stepcut: me too.. and the lack of type-checking nowadays.
15:25:51 <desrt> i don't care what order the labels are in... as long as they are unique
15:25:52 <Leimy> CWString.hsc:257: Variable not in scope: `peekCWString'
15:25:57 <Leimy> dons: got a little further
15:26:03 <shapr> it used to be a lot pickier about type-checking anything generated, but somethings get through now.
15:26:13 <desrt> i can't do this because it would break purity rules, or something :(
15:26:16 <shapr> you need ncursesw
15:26:30 <dons> or comment out that in mk/config.mk
15:26:30 <Leimy> shapr: dangit
15:26:42 <dons> no no. you don't *need* it. don't have it on openbsd either.
15:26:45 <Igloo> desrt: You can put the functions in a name supply monad
15:27:05 <desrt> Igloo; but then i can't do my fun recursion stuff so easily :(
15:27:15 <dons> comment out DCF_CHARSET_SUPPORT
15:27:20 <dons> and DCF_WCHAR_SUPPORT
15:27:24 <desrt> i like saying arf x y z = arf x ++ arf y ++ arf z
15:27:33 <Leimy> I'm sure I have ncurses
15:27:37 <Leimy> hmmmm
15:27:39 <dons> make sure CURSES=ncurses
15:27:44 <Leimy> it is
15:27:54 <Leimy> and DEFINES += -DHAVE_NCURSES_H=1
15:28:05 <dons> and comment out the CHARSET stuff next paragraph down?
15:28:28 <dons> i reckon the mac is much like bsd in this respect. and it works nicely on openbsd
15:28:32 <Leimy> I've got that CHARSET STUFF out
15:28:45 * Leimy retries
15:29:57 <shapr> hiya The_Tick, ltns
15:30:02 <Leimy> oh this isn't so good
15:30:05 <Leimy> /usr/include/regex.h:68: parse error before "regoff_t"
15:30:10 <Leimy> hey The_Tick  :)
15:30:13 <dons> doh
15:30:17 <The_Tick> hey shapr 
15:30:22 <The_Tick> and Leimy 
15:30:24 <Leimy> that doesn't bode well :)
15:30:25 <mattam> I can't find a simple latex symbol and it's driving me mad. It's a \smile below a \frown, the contrary of \asymp
15:30:30 <dons> ok. the regex code is in cbits/YiUtils.c and YiUtils.h
15:30:37 <dons> very simple. should be a able to fix
15:30:51 <abstrato_general> latex has \smile and \frown?
15:30:58 <mattam> yep
15:31:01 <shapr> \heybaby
15:31:05 <mattam> and \radiation
15:31:10 <abstrato_general> uhh
15:31:23 <Leimy> \god_please_kill_me
15:31:27 <mattam> and anything you want in fact, it's turing-complete
15:31:37 <dash> huh
15:31:42 <shapr> Alan Turing & The Machines... WORLD TOUR 2005!
15:31:43 <mattam> well, that's not exactly related... :)
15:31:44 <dash> i have a function:
15:31:46 <desrt> \segfault
15:31:51 <abstrato_general> hahahaha
15:32:00 <dash> extend fn pt im x | pt == x = im
15:32:00 <dash>                   | otherwise = fn x
15:32:27 <dash> Oh, i see my mistake now
15:32:31 <dash> i was trying to type it like this:
15:32:42 <dash> extend :: (a -> b) -> a -> b -> a -> b
15:32:51 <dons> Leimy: also in Yi/Regex.hsc. I'm just rewiting Text.Regex.Posix to work on buffers, so look at library/base/Text/Regex/Posix.hsc to see if there's something in the original library that went missing
15:32:55 <dash> when really i had to type it like this. 
15:32:55 <dash> extend :: Eq a => (a -> b) -> a -> b -> a -> b
15:33:11 <abstrato_general> yikes. I'm never using the "square" cqd again.
15:33:15 <dons> ghc's libraries/base/.. I mean
15:33:22 <Leimy> hmmm need to include <sys/types.h> before regex.h
15:33:24 <Leimy> and all is good
15:33:27 <dons> cool
15:33:28 <abstrato_general> It's gonna be all smiles and frowns.
15:33:33 <dons> please send patch..
15:33:34 <Leimy> it uses off_t i regex.h
15:33:41 * desrt lessens his woes by making a monadic ++
15:33:59 <Leimy> dons: with all my changes?
15:34:20 <dons> well, the ones you feel are publicable.. but all of them are good, if you want
15:34:24 <Leimy> dons: should I try to see if it works? :)
15:34:31 <dons> please do that first ;)
15:34:40 <Leimy> ok
15:34:42 <Leimy> what do I run? :)
15:34:44 <dons> try both ./yi-static and ./yi-inplace
15:34:58 <Leimy> /yi-inplace: line 2: /Users/dave/work/yi/yi: is a directory
15:35:00 <Leimy> that's bad
15:35:15 <Leimy> _yi-static works
15:35:19 <dons> edit ./yi-inplace and fix whatever got broken by the last edit
15:35:24 <Leimy> that's due to the case sensistivity again
15:35:32 <Leimy> it looks a lot like vi :)
15:35:54 <dons> that's cause you're using the vi binding
15:36:05 <dons> there's half a nano binding that looks more like nano
15:36:05 <Igloo> :-)
15:36:11 <Leimy> dons: groovy
15:36:22 <Leimy> all my keys are borked
15:36:24 <Leimy> like backspace
15:36:25 <Leimy> tab
15:36:26 <Leimy> etc etc
15:36:34 <dons> you can read Yi/Keymap.hs to see the keybindings
15:36:42 <dons> please send patches to make, esp backspace, work
15:36:56 <Leimy> ah neat
15:37:01 <Leimy> keybindings in Haskell :)
15:37:12 <dons> of course -- it's just syntax (tm)
15:37:17 <Leimy> right
15:37:22 <Leimy> this is very neat though
15:37:26 <dons> "yi - it's just syntax"
15:38:02 <dons> try the window splitting code. :sp and :q
15:38:10 <dons> and :e should pull in new files
15:38:43 <Leimy> the e command is unknown
15:38:46 <Leimy> it claims
15:39:17 <dons> hmm. I wonder if \13 and \12 are well behaved on the mac
15:39:43 <Leimy> what's \13 and \12/
15:39:45 <Leimy> ?
15:39:48 <dons> the keybinding probably assumes that hitting enter produces \n or \r
15:39:55 <dons> to terminate an ex command
15:40:15 <Leimy> all I did was :e
15:40:18 <Leimy> no args
15:40:30 <dons> oh. sorry. :e with no args doesn't mean anything :)
15:40:38 <dons> :e README
15:40:42 <dons> should load that file
15:40:57 <dons> line 354 of Keymap.hs
15:41:43 <Leimy> ah I see it
15:42:04 <Leimy> need to find backspace
15:42:04 <dons> they're the ex commands down there
15:42:43 * dons reads the logs ... and wants a yi t-shirt!
15:42:48 <shapr> me too!
15:42:50 <shapr> I like the motto
15:42:57 <shapr> "yi - it's just syntax"
15:43:40 <dons> yeah! sounds good :)
15:43:54 <shrimpx> is there an isaac jones in here?
15:44:16 <skuggi> what's yi?
15:44:18 <Leimy> hmmm if c == '\BS' || c == keyBackspace 
15:44:19 <Leimy> ah hold on
15:44:19 <Leimy> it might be terminal settings
15:44:37 <Leimy> dons:  it was the terminal setting
15:44:46 <Leimy> delete key sends backspace had to be enabled
15:44:57 <Leimy> otherwise I guess it's sending delete.
15:44:57 <shapr> skuggi: darcs get http://www.cse.unsw.edu.au/~dons/yi
15:45:07 <dons> ok. or we could add the delete keycode to the matches
15:45:13 <dons> hmm. which is?
15:45:18 <Leimy> dons: Good question :)
15:45:44 <Leimy> I don't have a good event viewer atm
15:45:48 <dons> \^?
15:45:53 <Leimy> probably
15:45:57 <dons> \127
15:46:07 <shapr> You think a YiWiki is needed?
15:46:17 <Leimy> shapr: wouldn't hurt :)
15:46:28 <dons> maybe.
15:47:05 <Leimy> c == '\127'
15:47:10 <Leimy> doesn't do it in the ||
15:47:10 <dons> there's a little ref on www.cse.unsw.edu.au/~dons/code.html
15:47:17 <dons> hmm
15:47:34 <dons> I actually got a multi-char sequence unless I hold down shift-delete
15:47:40 <dons> then I get \127
15:48:32 <TheHunter> wb, channel!
15:48:57 <shapr> hiya TheHunter!
15:49:23 <TheHunter> did I miss anything?
15:50:45 <TheHunter> have the us elections been already discussed here?
15:51:15 <dons> hmm. shift-delete is \127 for me
15:51:30 <dons> oh well.
15:52:34 <shapr> is there a pic of the Yi symbol anywhere?
15:52:44 <Leimy> tab is apparently "9"
15:53:01 <Leimy> according to getc :)
15:53:27 <dons> man ascii?
15:53:39 <Leimy> I should totally use ncurses :)
15:53:40 <dons> 9 == ht. which sounds right
15:53:44 <Leimy> or stty
15:53:44 <Leimy> :)
15:53:50 <dons> hehe
15:53:56 <tuomov> shapr: go to the wikipedia confusius page (and zoom), or try some pdf for the range from unicode.org
15:55:00 * desrt creates his first monad
15:55:00 <Leimy> dons where is tab in Keymap.hs
15:55:57 <dons> maybe not in there
15:56:04 <dons> what does it mean in vi?
15:56:18 <Leimy> insert a tab character :)
15:56:27 <Leimy> though it has settings for how to display it
15:56:43 * Pseudonym thinks we need the 90 minute Haskell compiler
15:56:54 <dons> oh. no support yet from me. I wonder what it does?
15:57:00 <stepcut> Pseudonym: heh
15:57:05 <Leimy> dons: prints an @
15:57:07 <dons> enters a '@'
15:57:09 <dons> yeah
15:57:14 <Leimy> which is what "delete" does
15:57:21 <Leimy> when I have the wrong mapping
15:57:46 <shapr> g'day Pseudonym, I agree.
15:57:54 <shapr> Pseudonym: bet it takes less than 90 minutes.
15:58:08 <Pseudonym> Bet it takes three hours just to write the parser.
15:58:18 <shapr> well... maybe so.
15:58:24 <shapr> But once you've got Core, everything is smooth sailing.
15:58:36 <Pseudonym> A Haskell implementation in Haskell is actually fairly straightforward.
15:58:49 <Pseudonym> But you get to use the host GC for that.
15:59:09 <Pseudonym> I did a G Machine implementation once.
15:59:25 <Leimy> dons: you said delete came up "\127" ?
15:59:33 <Pseudonym> Though going via SK combinators would be even easier.
15:59:45 <Leimy> for del
16:00:12 <dons> shift-delete generates del, which is \127
16:00:15 <dons> for me.
16:00:50 <Leimy> do I want to insert that in loop w@(c:cs) ???
16:01:36 <dons> I'm doing it now. or do you have some tricksy ideas?
16:01:46 <Leimy> no trickyness
16:01:53 <Leimy> just trying to figure out where to stick it :)
16:02:31 <shapr> an SKI compiler would be easy enough.
16:02:34 <shapr> I think...
16:02:55 <dons> Leimy: you could also try out /regex and :s/a/b
16:03:04 <dons> since you're regex.h was a little different
16:03:24 <Leimy> dons: I don't think it's different beyond the fact that you have to include sys/types.h
16:03:48 <Pseudonym> The only tricky bit of implementing a lazy language in Haskell itself is update.
16:03:54 <Pseudonym> You basically need to use Refs.
16:04:36 <Pseudonym> Although... hmmm.
16:04:46 <Pseudonym> If you did an STG-based backend, you might be able to avoid updates.
16:05:02 <desrt> is the state monad opaque?
16:06:19 <Leimy> dons: the regexp syntax for replacement should be :s/orig/new/
16:06:33 <Leimy> for hysterical raisins
16:06:39 <Leimy> but it's not working for me anyway :)
16:07:09 <Leimy> anywy...
16:07:10 <dons> hmm. vi syntax is: s[ubstitute] [/pattern/replace] [options] [count] [flags]
16:07:22 <Leimy> s/pattern/replace/g
16:07:27 <dons> it should respect or ignore the '/' at the end anyway
16:07:31 <dons> yi currently does that
16:07:43 <Leimy> well I'm talking about ed/ex/sed which is where vi came from :)
16:07:46 <Leimy> maybe you have vim :)
16:07:52 <dons> yep. but this is vi emulation
16:07:57 <Leimy> I've never seen it work without trailing / :)
16:08:17 <dons> no. it works fine. 
16:08:24 <dons> just using plain old 1992 BSD vi
16:08:31 <dons> the one on your machine too -- probably
16:08:42 <Leimy> weird
16:08:50 <Leimy> I used nvi and it succeeded
16:09:04 <dons> ok. nvi == vi on openbsd
16:09:05 <Leimy> which is likely the closest to the original vi you'll get anymore
16:09:23 <dons> yep. it's pretty close. but there are some bugs not respected
16:09:32 <dons> now, you say it doesn't work in yi
16:09:57 <Leimy> well I used addressing
16:09:59 <Leimy> like %
16:10:03 <dons> oh, come on!
16:10:03 <Leimy> but I realize that's not done
16:10:05 <Leimy> :)
16:10:14 <dons> that code was written 8 hours ago
16:10:15 <Leimy> dons: sorry it was muscle memory :)
16:10:25 <Leimy> I just realized what I was doing :)
16:10:31 <dons> there is current line addressing only :P
16:10:39 <Leimy> it's cool
16:10:43 <dons> global search though using /
16:10:45 <dons> and 'n'
16:10:58 <Leimy> hmmm
16:11:20 <Leimy> search forward works
16:11:24 <dons> yes.
16:11:25 <Leimy> doesn't wrap yet.
16:11:25 <dons> don't ask
16:11:29 <Leimy> that's cool though
16:11:43 <shapr> patches welcome...
16:11:51 * shapr looks at himself
16:11:51 <dons> these are the newest bits of code you're looking at
16:12:00 <Leimy> awesome
16:12:01 <Leimy> ok
16:12:07 <Leimy> s/orig/new/g works :)
16:12:12 <Leimy> very cool
16:12:25 <dons> where orig can be a pattern..
16:12:31 <Leimy> oh wait
16:12:34 <Leimy> I spoke too soon
16:12:38 <Leimy> it missed the first match
16:12:43 <Leimy> but got the last?
16:12:45 <dons> yep. bug. fixed already
16:12:50 <Leimy> oh sweet
16:12:57 <Leimy> well let me get my patches together here
16:13:31 <stepcut> yi-inplace fails on my system because it can not find /usr/lib/ghc-6.2.1/package.conf â I have 6.2.2 installed currently
16:14:42 <dons> hmm. why is 6.2.1 appearing here then, I wonder?
16:14:49 <dons> was hs-plugins build with 6.2.1?
16:14:59 <dons> is ghc == ghc-6.2.1
16:15:13 <Leimy> dons email to?
16:15:23 <dons> use darcs send
16:15:26 <dons> that should send mail to me
16:15:32 <dons> I hope
16:15:34 <Leimy> ah :)
16:15:42 <Leimy> darcs send will send my patches
16:15:43 <Leimy> ?
16:15:46 <dons> yep
16:15:47 * Leimy reads darcs docs :)
16:16:07 <dons> or you could darcs send -o /tmp/f ; and then mail /tmp/f
16:16:28 <Leimy> I don't think my darcs has a send 
16:16:50 <Leimy> darcs help | grep send yielded nothing
16:17:03 <Leimy> 0.9.15
16:17:20 <Leimy> whoah
16:17:22 <Leimy> I'm behind
16:17:25 <dons> oh. that's  really old. I'm surprised it checked out properly
16:17:26 <Leimy> 1.0.0rc3 is out
16:17:31 <Leimy> dons hehe 
16:17:34 <Leimy> hold on I'll update
16:17:55 <stepcut> dons: ghc is a symlnk to ghc-6.2.2
16:18:50 * stepcut goes out for tea
16:18:53 <Igloo> You haven't managed to have an old ghc-pkg left behind?
16:19:28 <dons> stepcut: in which package.conf is hs-plugins registered?
16:19:29 <Leimy> well I'll have to update the darks darwinport
16:19:33 <Leimy> er darcs
16:24:13 <Leimy> building new darcs....
16:26:19 <Leimy> dons... nice stuff btw :)
16:26:22 <Leimy> I like it..
16:26:47 * Leimy looks for how to put it in nano mode
16:28:13 <dons> ok. you can either just swap in keymaps/Nano.hs for Keymap.hs and rebuild
16:28:45 <dons> or cp examples/Config.hs and keymaps/Nano.hs into ~/.yi
16:28:54 <dons> edit ~/.yi/Config.hs to import Nano.hs
16:29:04 <dons> and then start up ./yi-inplace
16:29:14 <dons> that shoudl dyn load the new keybinding
16:29:21 <dons> but this doesn't work with yi-static
16:29:29 <Leimy> yi-inplace doesn't work here
16:29:49 <Leimy> /Users/dave/.yi/Config.hs:
16:29:49 <Leimy>     Can't find module `Keymap'
16:29:49 <Leimy>     (use -v to see a list of the files searched for)
16:30:11 <dons> it's asking for the module keymap, which is known as Nano.hs
16:30:21 <dons> so edit Config.hs to include Nano.hs instead of Keymap.hs
16:30:33 <Leimy> yi = settings {
16:30:33 <Leimy>     keymap = Keymap.keymap
16:30:33 <Leimy> }
16:30:36 <Leimy> that's what it has now
16:30:42 <dons> should be: keymap = Nano.keymap
16:30:48 <dons> since that's what you're wanting to use
16:31:01 <Leimy> ok I did that
16:31:07 <dons> and you'll need to import qualified Nano
16:31:08 <Leimy> /Users/dave/.yi/Config.hs:
16:31:08 <Leimy>     Can't find module `Keymap'
16:31:08 <Leimy>     (use -v to see a list of the files searched for)
16:31:12 <desrt> when i'm making a module can i declare some symbols private?
16:31:23 <dons> you don't include them in the export list
16:31:41 <dons> Leimy: Config.hs is still importing module Keymap..
16:31:47 <Leimy> hmmm... in HSyi.o it found duplicate __module_registered
16:31:58 <Leimy> which is GHCi runtime linker fatal error
16:32:03 <dons> hmm.
16:32:16 <desrt> ah.  i see
16:32:23 <Leimy> dons: that also might be why I didn't get backspace working :)
16:32:29 <Leimy> since I kept using static :)
16:32:40 <dons> yep. sure.
16:32:55 <Leimy> chalk that one up to "DOH!"
16:33:26 <dons> i've tested the dynamic loading version on linux and openbsd only. looks like the mac is ill-behaved (surprised) so I'll do some debugging on a mac soon.
16:33:38 <Leimy> not surprising
16:33:44 <dons> until then just use yi-static, and statically compile in Nano.hs
16:33:55 <Leimy> Mach-O has a strong policy about duplicate symbols vs ELF
16:34:12 <Leimy> I'll do that
16:34:31 <dons> also, if you feel like finishing off the nano binding, that would be cool :)
16:34:42 <Leimy> heh I've got other stuff I was gonna do
16:34:43 * dons used nano for the first time when writing the binding
16:34:45 <Leimy> this is a side-track :)
16:34:56 <Leimy> I like emacs more than these two btw :)
16:35:01 <dons> oh, sure.
16:35:08 <Leimy> but it's still awesome to have an extensible editor :)
16:35:12 <Leimy> using Haskell
16:35:24 <dons> it's nice when you look at the source and see it's just haskell, hey?
16:35:31 <Leimy> indeed
16:35:31 <dons> you think: "oh, I can fix this bug now"
16:35:38 <dons> whereas if it was C..  time to go home
16:36:06 <dons> it's much more fun though using the dynloaded version
16:36:14 <dons> you just edit the keymap and restart
16:36:19 <marcot> dons: is it working like nano already?
16:36:29 <dons> 60% of a nano binding is there
16:36:32 <dons> most of the options
16:36:38 <dons> maybe more than 60%
16:37:14 <marcot> dons: cool... let me check.
16:37:22 <dons> the nano binding is only ~70 lines anyway
16:37:52 <dons> marcot: if you're a nano fan, please write more binding code ;)
16:38:30 * desrt weeps
16:38:48 <Leimy> dons: do you want me to record the Makefile patch?
16:38:53 <marcot> dons: I'll try that.
16:39:05 <Leimy> it makes yi-static _yi-static
16:39:14 <dons> Leimy: oh, please. send it in
16:39:25 <dons> but yi-static shouldn't get renamed..?
16:39:25 <Leimy> just making sure that's what you want
16:39:35 <Leimy> dons: I had to to get the _yi rule to work
16:39:35 <dons> it was "yi" that needed renaming
16:39:42 <dons> hmm
16:39:46 <Leimy> some string expansion required it
16:39:52 <Leimy> or I couldn't build
16:39:55 <dons> send the patch, yes, please
16:40:03 <Leimy> i figured you could fix it :)
16:40:23 <marcot> dons: but how can I change from nano mode to vi mode?
16:40:35 <TheHunter> are there any haskell compilers that acutally accept this code: http://www.haskell.org//pipermail/haskell-cafe/2004-October/007338.html ?
16:41:31 <dons> marcot: what OS are you on?
16:41:49 <Leimy> dons: I have to key in the target email for darcs send... probably because I checked it out with an old darcs
16:41:52 <marcot> dons: GNU/Linux.
16:41:54 <Leimy> can you msg me the email ?
16:42:55 <dons> just look in _darcs/patches and zcat one of the patches
16:43:00 <dons> you'll see the author address
16:43:24 <dons> marcot: ok. so you've got the latest _cvs_ hs-plugin installed?
16:43:34 <marcot> dons: no.
16:43:50 <dons> please install this then, if you're going to hack on yi :)
16:44:34 <Leimy> off it goes
16:44:35 <dons> get the "Nightly cvs src snapshot"
16:44:44 <dons> Leimy: cheers!
16:45:11 <marcot> dons: =) ???
16:45:16 <marcot> dons: what must I do?
16:45:27 <dons> marcot: get the nightly cvs snapshot from the hs-plugins page
16:45:29 <marcot> dons: how can I know which patch is?
16:45:44 <marcot> dons: this is easy.. I was talking about the package.
16:45:50 <marcot> patch
16:46:08 <dons> sorry, I'm confused. What is the problem?
16:46:21 <marcot> dons: =)
16:46:36 <marcot> dons: How can I use the nano mode?
16:46:47 <dons> oh. ok. cp examples/Config.hs into ~/.yi
16:46:53 <dons> cp keymaps/Nano.hs into ~/.yi
16:47:04 <dons> edit ~/.yi/Config.hs to import qualified Nano
16:47:20 <dons> and replace the line that says "Keymap.keymap" with "Nano.keymap"
16:47:33 <dons> you can then start ./yi-inplace and it should use the new keymap
16:48:04 <marcot> dons: what's the command for getting the cvs from hs-plugins?
16:48:13 <dons> oh. just download it from the webpage
16:48:30 <dons> ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots/
16:48:36 <marcot> dons: does it have a tarball?
16:48:50 <dons> yep.
16:49:53 <marcot> dons: ok!
16:50:50 <marcot> /bin/sh: line 1: src/altdata/altdata.conf.inplace.in: Arquivo ou diretÃ³rio nÃ£o encontrado
16:50:51 <marcot> make[2]: ** [inplace-pkg-conf] Erro 1
16:50:57 <marcot> File not found.
16:51:23 <marcot> Sorry..
16:51:26 <dons> my portugese isn't too good 
16:51:27 <marcot> I forgot the ./configure
16:51:42 <marcot> Now it worked.
16:54:20 <marcot> dons: some warnings.
16:54:31 <dons> building yi?
16:54:42 <marcot> CWString.hsc and Curses.hs
16:54:44 <marcot> Yes.
16:54:48 <dons> don't worry
16:54:58 <dons> it's because we have -Wall on, and don't have full type sigs in those files
16:55:11 <dons> it's more to remind us to fix the warnings :)
16:55:12 <marcot> Isn't it bad?
16:55:15 <Lemmih> @index makeStablePtr
16:55:15 <dons> no.
16:55:16 <lambdabot> bzzt
16:55:28 <marcot> dons: but it should be fixed, right?
16:56:03 <dons> eventually
16:56:14 <dons> or, soon, but it isn't pressing
16:56:25 <dons> s/pressing/very important
16:56:43 <dons> you can remove -Wall from mk/config.mk and they go away ;)
16:57:07 <marcot> Ok.
16:57:27 <marcot> So I should add import Nano in the ~/.yi/Keymaps.hs file?
16:57:49 <dons> no. you should cp Nano.hs to ~/.yi/Nano.hs
16:58:03 <marcot> And then..
16:58:03 <dons> and cp examples/Config.hs to ~/.yi/Config.hs
16:58:16 <dons> then edit Config.hs to import Nano.hs instead of Keymap.hs
16:58:35 <dons> and replace the Keymap.keymap line with Nano.keymap
16:58:41 <marcot> ok.
16:58:46 <dons> Config.hs is the top level config file
16:58:57 <dons> and we're asking it to use the keymap found in Nano.hs by default
17:00:46 <marcot> dons: there's a lot of things missing in nano mode..
17:00:52 <marcot> dons: let me check the Nano.hs file.
17:01:11 <dons> what do you mean by "missing"?
17:01:14 <dons> not implemented?
17:01:53 <dons> did it load nicely, though? that is the important thing :)
17:02:08 <marcot> dons: yes.
17:02:12 <dons> yay:)
17:02:23 <marcot> dons: I'll try to add somethings here.
17:02:45 <dons> ok. so please add all the things you want to Nano.hs :)
17:02:57 <dons> I just added what I saw from the nano help screen
17:03:42 <dons> look at the Yi/Keymap.hs for the full range of actions
17:03:47 <dons> you can probably adapt many of them
17:04:03 <dons> the things you can use are in Yi/Core.hs
17:04:24 <marcot> Ok!
17:05:00 * SyntaxNinja has moved to Portland Oregon :)
17:05:09 <dons> hehe
17:05:18 <marcot> Adding C-n C-p C-b C-f it's very better.
17:05:33 <dons> i don't know what they do, so I'll just believe you
17:06:17 <Lemmih> I hate porting old code /-:
17:06:17 <marcot> =)
17:06:45 <desrt> >> has to be the sexiest operator ever
17:07:09 <Leimy> it can mean so many things in so many languages :)
17:07:13 <marcot> The quit from nano is different.
17:07:22 <marcot> It asks if you want to save changes.
17:07:23 <desrt> haskell's >> is best
17:07:27 <Leimy> heh
17:07:38 <dons> marcot: can't detect save changes yet. it's on the todo list though
17:07:41 * Pseudonym resists the urge to compose a sexier operator in ASCII art, since that would be too obvious a joke
17:07:55 <Leimy> >> append .  >> shift right, stream extraction.
17:08:01 <Leimy> all good things
17:08:11 <desrt>  \ \  \ \
17:08:11 <desrt>   \ \  \ \
17:08:11 <desrt>   / /  / /
17:08:11 <desrt>  /_/  /_/
17:08:12 <marcot> dons: ok.
17:08:37 <desrt> oh!  shifts!
17:08:46 * desrt is writing an abstract syntax tree for C
17:09:15 <desrt> or rather, a datatype for one
17:09:25 <jadrian> I think it's also used in math for "much bigger than"
17:09:25 <desrt> it's so hard to remember all the different operators
17:09:44 <Leimy> we've got an archive format with an XML table of contents... I need to update the DTD so I can get Haskell to parse those archives :)
17:09:51 <Leimy> er the toc and then use the archive
17:10:41 <dons> desrt: this has been done a few times. maybe you'd like to check http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
17:11:09 <dons> also, the hare has a full C parser for gcc-extended C
17:11:28 <desrt> dons; mmm.
17:11:34 <dons> Leimy: no mail arrived yet, I wonder what's up.
17:12:42 <desrt> dons; i might want to avoid something that will trivialise the work entirely.  this is for school....
17:12:49 <marcot> dons: why haven't you added '\^k'?
17:13:27 <dons> marcot: nano isn't my favourite hobby ;)
17:13:36 <marcot> dons: hehehe..
17:13:42 <marcot> dons: but how can I add it?
17:13:43 <desrt> i'm working with someone else... and how it goes is i write a backend and expose a datatype for the abstract syntax tree... and my parter writes the parser
17:13:55 <marcot> dons: It does something like d d from vi.
17:14:18 <dons> marcot: oh, cool then. look at the 'dd' code in Keymap.hs and adapt it to '\^K'
17:14:20 <desrt> *partner
17:14:20 <marcot> dons: but then when you do C-u it pastes all the lines you have cutted with C-k.
17:14:43 <dons> ok. we have cut and paste. look at 'y' and 'p' in the vi code
17:15:04 <Leimy> how cool is that? :)
17:15:19 <Leimy> could do an emacs kill ring with that probably
17:15:27 <marcot> dons: what does killE and deleteE do?
17:15:37 <dons> read their comments in Core.hs
17:15:50 <dons> *or* 'make html' and read the documentation!
17:15:56 <dons> you'll need haddock
17:16:28 <shapr> heya SyntaxNinja!
17:16:50 <shapr> SyntaxNinja: how's Oregon?
17:17:19 <marcot> dons: the problem is that I don't know what the operator >> do
17:17:28 <marcot> and >>=
17:17:42 <shapr> then there's the spears operators >>=->
17:17:56 <dons> it's just short hand for do-notation. '>>' means 'and then do'
17:18:16 <dash> shapr: so what does @---`---,-- do
17:18:28 <marcot> dons: and >>=?
17:18:40 <shapr> dash: that's Richard Bird's single pass algorithmic operator.
17:18:45 <shapr> obviously, for rose trees.
17:18:52 <Philippa> (@---`---,--) returns a pseudorandom goth poem
17:19:04 <Leimy> dons: sequencing operator
17:19:05 <Leimy> ?
17:19:11 <Leimy> useful for actions
17:19:12 <dash> shapr: in ETC, it probably writes a web server or something
17:19:13 <dons> marcot: do v <- something; use v;  ==  something >>= \v -> use v
17:19:36 <shapr> dash: probably so
17:19:44 <marcot> dons: ok.
17:19:47 <shapr> man, I'm tired.
17:20:43 <jadrian> shapr: just to make sure, there is no spear operator right?
17:20:57 <shapr> no, it's long-standing joke.
17:21:01 <jadrian> ok :)
17:21:51 <shapr> there are several running gags, "spears are more general than arrows" is one, and "bOing is Hugs booting on the raw hardware" is another.
17:21:56 <dons> Philippa: I dont' understand it, but I like it
17:23:26 <jadrian> Philippa: you cannot use ` nor , ;)
17:23:46 <dons> yeah, Haskell is so lexically restricted..
17:23:55 <Philippa> dons: the operator looks a little bit like a rose
17:23:57 <Pseudonym> "shapr isn't a lambdabot plugin" is another one that comes up often.
17:24:06 <jadrian> Lol!
17:24:10 <dons> I thought he was a lambdabot plugin?
17:24:15 <dash> i knew shapr before he was written in haskell
17:24:28 <shapr> :-P
17:24:31 * shapr snickers
17:24:33 <dons> before he was *ported* ot Haskell
17:24:47 <Philippa> he was written in Python before that
17:24:54 <dons> not miranda or lml?
17:24:55 <Philippa> problem was he had to say "ni!" after every line
17:25:03 <dons> it explains so much
17:25:16 <marcot> dons: I'm having problem in paste.
17:25:35 * shapr chortles
17:25:40 <marcot> dons: The nextCmd doen't work.
17:26:01 <marcot> dons: and it's not working without it.
17:26:35 <dons> there's no nextCmd in nano mode
17:26:45 <dons> it is modeless, so it always uses the same keymap
17:26:57 <dons> hence: keymap c = nano c >> return (Keymap keymap)
17:27:15 <shapr> this bot needs sleep
17:27:25 <dons> bots don't sleep..
17:27:34 <shapr> ok, scheduled maintenance
17:27:39 <dons> maybe they overflow they're stacks
17:28:22 <dash> crud! this scheme code i am porting from uses set!. time to figure out how to use he state monad :)
17:29:17 <shapr> lambdabot surely stack overflows on a regular basis.
17:29:34 * shapr goes for scheduled maintenance
17:29:35 <dons> marcot: should be something like: do s <- getRegE; eolE >> insertE '\n' >> mapM_ insertE s >> solE
17:29:36 <dash> (it's using set! in the 'allocate' function that models the store for a lisp interpreter, which sorta makes sense)
17:31:34 <marcot> dons: It's saying: The last argument of do must be an expression.
17:31:50 <dons> that's not my fault ;)
17:32:12 <marcot> dons: correct.
17:33:58 <stepcut> dons: I wiped out my old /usr/lib/ghc-6.2.1 directory, plugins is currently registered in /usr/lib/ghc-6.2.2/package.conf
17:34:03 <marcot> dons: is it possible to use yi in windows?
17:34:39 <dons> marcot: it is possible, but untested. the new regex code will certainly break.
17:35:02 <dons> you could start with: make way=static, and progress from there
17:35:10 <dons> not too hard as far as porting jobs go
17:35:20 <marcot> dons: hum..
17:35:28 <stepcut> actually, I think I didn't rerun configure when installing hs-plugins in 6.2.2., so that is probably what is broken
17:35:29 <marcot> dons: I'll try it some day.
17:35:51 <marcot> It's all ok now.
17:35:57 <marcot> Only one problem.
17:36:31 <dons> yes?
17:36:49 <marcot> =)
17:36:52 <dons> send me the new Nano.hs if you'd like it included in yi.
17:37:07 <marcot> When I cut two lines with '\^K'
17:37:17 <marcot> And do '\^U'
17:37:18 <dons> oh, you probably lose the first?
17:37:22 <marcot> It should paste both.
17:37:52 <marcot> If I cut one, then move with the cursor, then cut another, it'll paste both.
17:38:08 <dons> yeah. can't easily append to the cut buffer atm. you could getRegE, append, setRegE
17:38:09 <marcot> But if I cut one, edit the text, and cut other, it'll only paste the last one.
17:38:53 <marcot> where are these getRegE and setRegE defined?
17:38:57 <dons> Core.hs
17:39:11 <dons> everything ending in 'E' is an editor action you can call
17:40:35 <marcot> dons: is it hard to define a an appendRegE function?
17:40:54 <marcot> appendRegE s = modifyEditor_ $ \e -> return e { yreg = yreg ++ s }
17:40:59 <marcot> Or something like this?
17:41:26 <dons> almost. modifyEditor_ $ \e -> return e { yreg = (yreg e) ++ s }
17:41:52 * jadrian is off to bed
17:41:54 <marcot> =)
17:42:04 <jadrian> bye!
17:42:08 <dons> marcot: try it out. send me the patch
17:43:03 <marcot> dons: ok!
17:46:08 <stepcut> does creating your own ~/.yi/Keymaps.hs actually work ? Because it does not seem to be working for me..
17:47:13 <dons> it does work. you need a ~/.yi/Config.hs that correctly imports your new keymap
17:47:31 <dons> you need the cvs version of hs-plugins
17:48:13 <dons> there was a bug that meant it wouldn't recompile the local deps of a module if they changed but the top level module hadn't
17:48:15 <Leimy> uh oh
17:48:27 <Leimy> I just updated and have trouble building Keymap.hs
17:48:29 <stepcut> ah
17:49:24 <dons> stepcut: but usually that's not the problem more often people seem to get Config.hs wrong
17:49:37 <dons> like not importing their keymap
17:49:54 * dons should document the configuration system at some point
17:50:02 <stepcut> cool, it works
17:50:14 * stepcut had no Config.hs
17:50:20 <dons> problemo
17:50:51 <dons> Config.hs is dyn loaded by Boot.hs when yi starts up. it then pulls in any dependencies
17:51:03 <dons> there's thus no reason to have separate files for the keymap. it could just be in Config.hs
17:51:32 <Leimy> so it's basically like a #include?
17:51:49 <dons> I guess a bit like that
17:52:02 <dons> but we're in Haskell module system-land here
17:52:39 <dons> how you link together your config files is up to you, as long as the "yi" var is set in "Config.hs"
17:52:46 <dons> that's all the yi cares about
17:53:14 <marcot> dons: How do I concatenate an IO String with '\n' for example?
17:53:58 <dons> what IO String?
17:54:24 <marcot> dons: the return of ReadLnE
17:54:49 <dons> do s <- readLnE ; let s' = s ++ '\n'
17:54:51 <dons> that would be one way
17:55:30 <marcot> dons: ok.
17:55:52 <marcot> Why doesn't readLnE returns a simple String?
17:56:03 <dons> it does some IO, so that is part of its type
17:56:08 <dons> that's just Haskell
17:56:35 <Leimy> it's an IO action returning a String
17:56:38 <Leimy> so that's it's type
17:57:12 <Leimy> if it's an IO action returning nothing... it's IO ()
17:57:19 <Leimy> like a putStrLn
17:58:28 <marcot> hum...
17:58:33 <dons> Leimy: still didn't get that mail. Maybe you should resend
17:59:03 <Leimy> dons: does my sendmail need to be running or does darcs actually have it's own SMTP?
17:59:05 <marcot> But Why can't I concatenate this string whit '\n' just using for example '\n' : readLnE ?
17:59:19 <dons> no smtp in darcs, I hope
17:59:34 <marcot> Do I have to use do?
17:59:35 <dons> sorry. bug in my code: let s' = s ++ "\n"
17:59:36 <Leimy> and I am NOT configuring postfix/sendmail to use a source repo :)
17:59:42 <Leimy> so I guess I'll manually email it
17:59:54 <dons> Leimy: easy. darcs send -o f ; then send 'f'
18:00:01 <Leimy> yep
18:00:09 <marcot> Does I have to use do because it's an IO operation?
18:00:17 <dons> yep
18:00:25 <dons> or else >>= and >>
18:00:34 <marcot> ok.
18:00:57 <dons> there's lots of IO in yi: it has to access the ncurses library, and a mutable buffer underneath wrapped in mvar sync locks
18:01:15 <dons> and eventually there's threads swapping in and out.
18:01:24 <dons> so it all needs to be ordered properly
18:02:46 <Leimy> dons: off it goes again
18:02:52 <Leimy> hopefully for real :)
18:03:21 <marcot> dons: =)
18:03:23 <marcot> dons: working now.
18:03:34 <marcot> dons: but other problem showed up.
18:03:36 <Leimy> I think the next version of OS X will have yet another MTA
18:03:57 <marcot> dons: I must clean the yank buffer when I copy something eles.
18:03:58 <Leimy> not Sendmail or Postfix but probably that thing debian defaults to :)
18:04:11 <dons> marcot: easy. set it to []
18:04:21 <marcot> dons: that's not the problem.
18:04:23 <dons> or just use set to the new string. not append
18:04:27 <marcot> dons: Let me explain it better.
18:04:45 <marcot> dons: I must set all the time.
18:05:02 <marcot> dons: except when the last action that changed the text was an set.
18:05:11 <marcot> dons: in this case I must use append.
18:05:48 <marcot> dons: how can I check what was the last action?
18:06:02 <marcot> dons: I mean, the last action that changed the text.
18:06:27 <dons> there's no editor support for this at the moment. but you can store state in the keymap yourself
18:06:53 <dons> slightly more advanced haskell programming now
18:07:54 <marcot> dons: then...
18:08:05 <marcot> dons: let me know when something of this sort is implemented.
18:08:26 <dons> in Keymap.hs down the bottom you'll see some unsafePerformIO code 
18:08:44 <dons> that stores the last regex string inside an IORef.
18:09:01 <dons> you could duplicate that code to store the last command you executed
18:09:25 <dons> you can use readIORef to get at the value, and writeIORef to store a new value
18:09:39 <marcot> hum..
18:09:45 <dons> soon i'll think up some way to store arbitrary state in the editor, but IORefs are the way to go for now
18:10:35 <dons> -lastRe :: IORef String
18:10:35 <dons> -lastRe = unsafePerformIO $ newIORef []
18:10:44 <dons> that stores a ref to a string.
18:11:10 <dons> writeIORef lastRe s    inserts 's'
18:11:17 <dons> do s <- readIORef lastRe
18:11:22 <dons> reads it back
18:11:53 <marcot> hum..
18:11:56 <dons> so you could store a Bool in the ioref.
18:11:58 <marcot> cool.
18:12:22 <dons> if it is True, then the last action you used set the cut buffer
18:12:42 <marcot> The bad part is that every command will setit to false.
18:12:46 <marcot> I have an better idea.
18:12:58 <marcot> '^K' always append.
18:13:03 <marcot> and other commands clean.
18:13:40 <dons> I think that if the keymap can't be encoded cleanly in Haskell, the that editor is broken :)
18:13:59 <dons> which makes emacs a prime candidate for brokeness :}
18:14:45 <marcot> This is not unclean.
18:14:50 <marcot> Will see.
18:15:00 <dons> no, I know nano is pretty easy
18:15:03 <dons> it's quite clean
18:15:52 <dash> dons: ahaha, lisp 0wnz j00! ;D
18:17:00 <marcot> When you ask for reading a file, '\^C' should cancel.
18:17:17 <Leimy> there is a comment about ^C not working
18:17:18 <Leimy> IIRC
18:17:58 * Leimy is trying to write mapF :: (a -> b) -> IO a -> IO b
18:18:37 <Leimy> I'm not sure I understand what it's supposed to do though :)
18:19:01 <Lemmih> Leimy: mapF = liftM
18:19:03 <Leimy> "the effect of which is to transform an interaction by applying th function to its result.  You should define it using the do construct"
18:19:15 <Leimy> Lemmih: it's an excercise for educational purposes :)
18:19:20 <Leimy> but thanks !
18:19:21 <heatsink> why is it called mapF?
18:19:28 <Leimy> heatsink: ask the author
18:19:36 <Leimy> Simon Thompson
18:19:37 <marcot> How is backspace?
18:20:01 <Leimy> marcot: who are you asking?
18:20:08 <heatsink> marcot: backspace is like thi
18:20:12 <marcot> Leimy: anyone how nows.
18:20:14 <marcot> knows.
18:20:23 <marcot> The ascci code.
18:20:36 <marcot> ascii
18:20:48 <Leimy> more importantly "stty" :)
18:21:35 <dons> marcot: grab the latest patches for yi. there's some backspace detection code
18:21:41 <dons> isDel :: Char -> Bool
18:22:07 <marcot> dons: ah...
18:22:08 <dons> living in Yi/Keymap.hs
18:22:30 <Leimy> dons: got that update :)
18:22:35 <Leimy> darcs is generally pretty cool
18:22:43 <Leimy> I need to setup a minimalistic SMTP somewhere
18:22:49 <Leimy> or figure out Postfix 
18:22:50 <Leimy> :)
18:23:07 <dons> heh
18:23:21 <marcot> dons: to update my code is darcs get again?
18:23:35 <dons> darcs pull
18:23:53 <dons> get is like cvs co; pull is like cvs update
18:23:56 <Leimy> ghc -cpp -fglasgow-exts -Wall -O -fvia-C -funbox-strict-fields -#include YiUtils.h -DLIBDIR=\"/usr/local/lib/yi\" -DHAVE_NCURSES_H=1 -Icbits  -package-name yi -c Yi/Keymap.hs -o Yi/Keymap.o -ohi Yi/Keymap.hi
18:23:56 <Leimy> Yi/Keymap.hs:36: parse error (possibly incorrect indentation)
18:23:58 <Leimy> doh!!!
18:24:09 <dons> hmm
18:24:17 <Leimy> module Vi ( keymap ) where
18:24:22 <Leimy> uhm... I think it's on crack
18:24:32 <dons> did you have a conflict?
18:24:45 <dons> Vi /= Keymap
18:24:48 <marcot> cool
18:24:49 <Leimy> dans nothing there
18:24:53 <Leimy> as far as conflicts go
18:25:00 <Leimy> oh
18:25:01 <Leimy> maybe not
18:25:14 <Leimy> there is some madness in there
18:25:22 <dons> you moved keymap/Vi.hs to Yi/Keymap.hs ?
18:25:46 <dons> builds nicely for me
18:25:50 <Leimy> I'll retry it 
18:26:12 <dons> bit of a problem atm is that the examples/ and keymaps/ go out of date so fast
18:26:21 <dons> well, I guess that is what 0.1 is for
18:26:29 <Leimy> Yi/Yi.hs: can't locate import `Yi.Keymap'
18:26:31 <Leimy> yikes
18:26:37 * Leimy better clobber and reget
18:26:49 <Leimy> I think I hosed a previous conflict and am now in eternal torment or something
18:27:07 <dons> Leimy: the module Yi/Keymap.hs appears to be missing, or has been renamed
18:27:27 <Leimy> Ah
18:27:32 <marcot> dons: you added appendRegE.. 
18:27:34 <Leimy> somehow I renamed it to Keymaps.hs
18:27:39 <dons> marcot: nope
18:27:41 * Leimy is a doofus
18:27:51 <dons> marcot: send me the patch
18:27:52 <marcot> dons: no?
18:28:00 <marcot> dons: oh.. it's because of the diff.
18:28:14 <dons> Leimy: still dont' have your patch either.. hmm. you send it to dons@cse..
18:28:16 <dons> ?
18:28:34 <Leimy> dons: wonderful
18:28:41 <Leimy> nothing freaking works :)
18:28:43 <marcot> dons: just a sec.
18:28:51 <marcot> dons: what's yourmail?
18:28:55 <dons> Leimy has mangled his repo :)
18:29:01 <Leimy> probably
18:29:10 <Leimy> Yi/Keymap.hs:160:
18:29:10 <Leimy>     Couldn't match
18:29:10 <Leimy>         `(FilePath, Int, Int, Int, Int, String)' against `(t, t1, t2, t3)'
18:29:10 <Leimy>         Expected type: (FilePath, Int, Int, Int, Int, String)
18:29:10 <Leimy>         Inferred type: (t, t1, t2, t3)
18:29:11 <Leimy>     When checking the pattern: (f, _, ln, pct)
18:29:13 <Leimy>     In a 'do' expression: (f, _, ln, pct) <- bufInfoE
18:29:15 <Leimy> yeah... see :)
18:29:23 <dons> dons at cse ' unsw ' edu ' au
18:29:47 <dons> reminds me to turn bufInfoE into a data type instead of a big tuple
18:29:52 <marcot> dons: au? What country is it?
18:29:53 <dons> or at least name some fields
18:30:04 <dons> .au-stralia
18:30:16 <Leimy> dons: sent again
18:30:22 <Leimy> from leimy2k@mac.com this time
18:30:28 <Leimy> leimy@opendarwin.org is crapping out or something
18:30:31 <marcot> dons: =)
18:31:58 <marcot> dons: where's this isDel stuff?
18:32:11 <dons> bottom of Keymap.hs
18:33:18 <marcot> dons: what's \127?
18:33:18 <Leimy> dons: it's highly likely mixing versions of darcs is a bad thing :)
18:33:32 <Leimy> marcot: backspace we think :)
18:33:39 <Leimy> or "delete"
18:34:09 <dons> 127 del
18:34:19 <dons> that's what i get from man ascii :)
18:34:32 <Leimy> likely correct
18:36:37 <marcot> dons: what must I do to use it in my Nano.hs?
18:36:48 <Leimy> dons: Backspace works
18:36:51 <Leimy> congrats :)
18:36:57 <dons> marcot: copy and paste :)
18:37:09 <Leimy> and I have a much better patch nbow
18:37:10 <Leimy> er now
18:37:12 <Leimy> than that last one
18:37:13 <Leimy> :)
18:37:14 <dons> hmm. should write a KeymapUtils.hs 
18:37:38 <dons> Leimy: I still haven't got a patch. I wonder if mail is broken at my end
18:37:49 <Leimy> DOH!
18:37:53 <Leimy> that would super-suck
18:38:09 <marcot> I don't know why, but here Delete goes foward.
18:38:36 <dons> try shift-delete
18:39:23 <Leimy> wow darcs makes large emails for patches
18:40:03 <marcot> backspace is ok.
18:40:07 <dons> hm. I think something funny is happening at my end.
18:40:08 <marcot> But now the problem is with delete.
18:40:40 <dons> not all delete keys work in all settings. I know that delete doesn't something weird on linux
18:40:44 <dons> debian anyway
18:40:50 <dons> s/doesn't/does/
18:41:02 <dons> debug if you wish :)
18:41:09 <bik> hrmm.. anyone ever messed around with "Curry"? It's Haskell w/ logic variables
18:41:38 <marcot> dons: no thanks.
18:41:46 <marcot> dons: I'll send it for you.
18:41:59 <Leimy> dons: have some code for tab yet in Keymap.hs
18:42:00 <Leimy> ?
18:42:30 <dons> nope. no tab code yet
18:42:37 <Leimy> ok
18:42:47 <dons> you could intercept that tab and insert 4 or 8 spaces. that would be easy
18:42:53 <dons> look at the '>' code
18:43:01 <Leimy> and nicer depending on whom you ask :)
18:43:04 <Igloo> It's probably better to use curses's getch and special key names
18:43:17 <dons> yep.
18:43:30 <dons> there are special names already. Look in Curses.hsc for these
18:43:37 <dons> keyBackspace is one.
18:43:45 <Igloo> Oh, you are using them and delete etc are still giving you issues?
18:43:57 <Leimy> O and o should do different things too
18:43:57 <dons> yeah. keyBackspace is ^H I think
18:44:07 <Leimy> O opens a line under neath the current cursor
18:44:12 <Leimy> o opens it and goes to it
18:44:15 <Leimy> IIRC
18:44:27 <marcot> It's almost ok.
18:44:36 <Leimy> so if I am on a line "line" O will open a line and push "line" under
18:44:42 <Leimy> and o is the opposite
18:45:25 <Leimy> I think it's reversed
18:45:25 <dons> Leimy: I'm following strict vi emulation..
18:45:33 <Leimy> hmmm
18:45:36 <dons> O         Open a new line above the line the cursor is on
18:45:38 <Leimy> I don't use vi that much anymore :)
18:45:41 <dons> o         Open a new line below the line the cursor is on
18:45:46 <dons> does it do that?
18:45:56 <Leimy> ah I see the prob
18:46:09 <dons> looks like O doesn't go up one line.
18:46:13 <dons> but 'o' works
18:46:20 <Leimy> the cursor should stay in the blank space
18:46:25 <Leimy> at the beginning yeah :)
18:46:27 <dons> yeah
18:46:32 <Leimy> but o is fine
18:46:38 <dons> must have changed when I messed with the curLn code
18:46:40 <dons> sigh
18:47:46 <Leimy> hmmm does >> in vi use spaces or tabs?
18:48:35 <marcot> dons: I'll need to use that variable thing.
18:48:44 <Leimy> anyway... this is really cool stuff :)
18:48:45 <Igloo> It can't always insert a tab as it works on shiftwidths, not tabstops
18:49:16 <Igloo> But all sane people have tabs autoconverted to spaces anyway, so it's not an issue  :-)
18:49:29 <dons> yep. and all Haskell people should..
18:49:57 <marcot> dons: how are that functions?
18:50:41 <dons> Leimy: 'O' fiixed
18:50:55 <dons> marcot: what variable thing?
18:51:19 <marcot> dons: that one that tells if the last command was an '\^C'
18:51:24 <marcot> dons: actually.
18:51:33 <marcot> dons: I'll take a look at vi's code.
18:52:01 <marcot> dons: what does nextCmd do?
18:52:30 <dons> in the vi emulation code, it returns the command-mode keymap 
18:52:37 <dons> it is just for modeful editors
18:52:53 <dons> so I wouldn't get yelled at for using IORefs in the keymap
18:53:03 <dons> bah
18:53:24 <dons> keymaps return the next keymap to use to the main loop
18:53:34 <dons> for modeless editors, this means always just the same keymap
18:53:45 <dons> for modeful editors like vi, this means sometimes you switch to different keymaps
18:53:59 <dons> so the vi mode sometimes returns the 'ins' or 'ex' keymaps
18:54:06 <dons> but mostly sits in 'cmd' mode
18:54:34 <ozone_> unless you use vimacs. ;)
18:54:44 <marcot> dons: ok.
18:54:59 <marcot>     | c == 'd' = do c' <- getcE
18:55:00 <marcot>                     when (c' == 'd') $ solE >> killE >> deleteE
18:55:00 <marcot>                     nextCmd
18:55:09 <dons> ozone_ :p
18:55:10 <marcot> Can I do something like this in '\^K'?
18:55:22 <marcot> dons: so that if it's the second time, it'll append?
18:55:39 <dons> so you want to modes. 1 for not appending to the cut buf, and one for appending
18:55:52 <dons> you could use keymaps to store state maybe, yes.
18:55:59 <dons> IORefs are simpler..
18:56:07 <marcot> dons: yes, append only if it's the second time consecutive in '\^k'
18:56:27 <marcot> dons: I want to do it the in the simple way.
18:57:02 <marcot> dons: I was wondering something about: cut, check next char, if it's cut, append, eles do nano c
18:57:41 <dons> I think you should use IORefs. Because there will soon be a system for doing state-based things like this, which will be easy to switch to if you use iorefs.
18:57:59 <dons> marcot: ooh. that's a good idea
18:58:10 <dons> yeah. do that. see if that works
18:58:17 <marcot> dons: so how can I implement it easily?
18:58:23 <marcot> dons: I mean.
18:58:24 <dons> kind of like 'dd' in the vi code
18:58:31 <marcot> dons: do something and then do anoter.
18:58:45 <marcot> dons: in the dd it does nothing before... i'll try here.
19:00:28 <dons> hmm. should have a #yi channel
19:01:32 <dons> ozone_: can I have a lend of your g5 sometime?
19:01:40 <dons> need to test yi out
19:03:14 <Leimy> dons: I'm testing on a g5
19:03:17 <Leimy> but on OS X
19:03:34 <ozone_> dons: you can't log in at the moment?
19:03:49 <dons> cool. I've used ozone's machine a few times though, it's close by
19:03:57 <marcot> dons: the problem is I must wait for the next command to the cut be done.
19:04:18 <dons> marcot: so just call getcE. that will block till the next command
19:04:36 <dons> ozone_: i'll try
19:04:49 <dash> hmm
19:04:52 <marcot> dons: that's what's happening.
19:05:01 <marcot> dons: but that's not what I want to do.
19:05:14 <dons> ;) well you'll have to try something else
19:05:28 <marcot> nano '\^K'  = do s <- readLnE
19:05:29 <marcot> 		 setRegE (s ++ "\n") >> solE >> killE >> deleteE
19:05:29 <marcot> 	      >> do c' <- getcE
19:05:39 <marcot>                     when (c' == '\^K') $ 
19:05:40 <marcot> 			 do s <- readLnE 
19:05:40 <marcot> 			    appendRegE (s ++ "\n") >> solE >> killE >> deleteE
19:05:40 <marcot>                     nano c'
19:06:03 * Leimy got the O fix
19:06:08 <marcot> the indentation is completly wrong here.
19:06:17 <marcot> but you can get the idea.
19:06:42 <Leimy> dons: >> prints not implemented but it clearly is :)
19:07:18 <dons> marcot: do c' <- getcE; if c == '\^K' then ... else nano c'
19:07:32 <Leimy> oh weird
19:07:35 <Leimy> I must be mistaken
19:08:56 <marcot> dons: it still wait for the next comand.
19:09:03 <dons> Leimy: btw. not_impl is a sign for you to write some code! ;)
19:09:08 <dons> marcot: yes, it will
19:09:20 <dons> maybe you'll have to try the ioref model
19:09:31 <marcot> dons: Isn't it possible to he do that and the wait?
19:09:37 <Leimy> dans: I'd like to learn more Haskell first :)
19:10:06 <Leimy> I don't feel like I have enough of a clue to write anything significant in the language yet
19:10:27 <marcot> s/the/then
19:11:55 <marcot> dons: how can I do this using the ioref model?
19:12:12 <marcot> dons: can you explain me?
19:12:21 <dons> follow the readIORef writeIORef stuff from Keymap.hs 
19:12:49 <marcot> dons: ok.
19:13:37 <marcot> dons: there's nothing of it here.
19:14:55 <dons> oh, it's gone in the last couple of patches.
19:15:05 <dons> hmm. you'll have to unrecord a few times to find it
19:15:46 <marcot> dons: I'm very tired.
19:15:54 <marcot> dons: I'll send you the way it's now.
19:15:59 <marcot> dons: It's almost ok.
19:16:08 <marcot> dons: the only problem is pasting lots of lines.
19:16:21 <dons> use darcs send -o /tmp/f to save the patch
19:16:23 <dons> then send that
19:16:35 <dons> don't use paste please. it will get confused
19:17:11 <marcot> dons: my changes are only in Nano.hs
19:17:22 <dons> ok. just send that whole file
19:17:26 <dons> that will be easy.
19:17:32 <marcot> dons: e-mail?
19:17:34 <dons> what about Core.hs? didn't you implement append?
19:17:41 <marcot> dons: by email?
19:17:45 <dons> yep
19:17:55 <marcot> dons: I'm not using it anymore..
19:18:26 <dons> ok
19:19:02 <Leimy> what does yi standfor?
19:19:05 <Leimy> your interface?
19:19:26 <desrt> is there a sane way to handle the state monad?
19:19:33 <desrt> i keep adding more state and it keeps getting more and more insane
19:19:36 <Leimy> with a large hammer
19:20:05 <desrt> ie: if i only want to update a single part of the state i have to have some weird function like
19:20:16 <desrt> newthing newa = (\(a,b,c,d) -> (newa,b,c,d))
19:20:22 <dons> Leimy: it's the Y combinator applied to the I combinator
19:20:24 <desrt> and it keeps getting bigger every time i add something new :)
19:20:29 <dons> @eval Y I
19:20:35 <marcot> I'll sleep.
19:20:37 <Leimy> dons: I with I knew what that was :)
19:20:39 <marcot> Good night for all.
19:20:47 <desrt> marcot; cheers
19:20:52 <lambdabot> out of fuel - use @resume to continue
19:20:54 <dons> night marcot. thanks for the code :)
19:21:05 <marcot> dons: ok! =)
19:21:05 <dons> hehe. too recursive for lambdabot ;)
19:21:41 <dons> hmm. i got marcot's email. i wonder why i haven't got Leimy's
19:21:54 <desrt> anybody have a suggestion?
19:21:55 <dons> and i didn't get my own. hmm
19:22:08 <dons> desrt: break the state up into pieces?
19:22:14 <dash> desrt: i'm struggling with the same question myself :)
19:22:21 <dons> use IORefs.. hehe
19:22:23 <desrt> dons; how do i do this?
19:22:26 <desrt> erm
19:22:36 <dons> oh, come on, I'm not going to write your code :}
19:23:02 * desrt writes NotSuckMonad
19:23:52 * Leimy tried to write a monad once
19:23:57 <Leimy> and was partially successful
19:24:15 <desrt> i have a cool AsmMonad
19:24:25 <Leimy> which does wha?
19:24:49 <desrt> it's designed for writing assembly out of abstract syntax trees
19:25:05 <Leimy> sounds neato
19:25:11 <desrt> ya.  it's supergroovy
19:25:32 <desrt> on the very lowest level you have asmString which takes a string and adds it to the assembly
19:25:48 <desrt> so all of the operators are full of >>s
19:26:10 <desrt> my favourite is the one to make a function call :)
19:26:23 <desrt> value (Call f args) = mapM value (reverse args) >> mapM pop (take (length args) [3..]) >> asmString ("bl " ++ f)
19:27:03 <stepcut> does the AsmMonad support forward and backward jumps ?
19:27:10 <desrt> yes
19:27:19 <desrt> it has a getLabel that returns a unique label
19:27:28 <desrt> which you can then insert into your code in interesting ways
19:27:36 <desrt> the getLabel problem was the problem that forced me to make it monadic
19:27:43 <desrt> the >> thing was just a really really cool sideeffect
19:28:39 <desrt> example:
19:28:43 <desrt> expr (Do a b) = do label <- getLabel
19:28:43 <desrt>                    asmLabel label
19:28:43 <desrt>                    expr b
19:28:43 <desrt>                    condLabel a label
19:29:13 <desrt> with condLabel being a function that jumps to label if 'a' is true
19:29:42 <stepcut> desrt: I am writing a scheme -> swf (flash) compiler, and I need to write the part where I calculate the byte offset from the jump instruction to the label
19:29:55 <dash> stepcut: in haskell?
19:29:57 <stepcut> yeah
19:29:59 <stepcut> in haskell
19:30:00 <desrt> stepcut; this doesn't do that.  it relies on the assembler
19:30:04 <dash> stepcut: i would like to see it
19:30:13 <stepcut> desrt: ah, well then it won't help me :)
19:30:45 <dons> ok. ciao for now
19:31:03 <stepcut> dash: I hope to release it sometime next year
19:31:41 <stepcut> first I need to write a better library for writing binary files because the .swf format uses all sorts of bitfields
19:32:25 <dash> stepcut: i'm interested in seeing lisp-handling code that is not as crazy as hscheme :)
19:32:44 <stepcut> dash: heh, I have not actually looked at hscheme
19:33:03 <dash> stepcut: how'd you write the parser?
19:33:09 <stepcut> dash: with parsec
19:33:13 <dash> awesome 
19:33:16 <dash> does it handle backquote?
19:33:36 <dash> quasiquote, i should say 
19:33:42 <stepcut> dash: i think so... let me check
19:34:01 <dash> stepcut: i just wrote a lisp parser with parsec
19:34:14 <dash> stepcut: i would like to see how mine differs from one written by someone who knows haskell better :)
19:35:51 <stepcut> no, I take it back, I do not handle quasiquotes yet
19:36:17 <dash> OK! well, i wrote some code to do it based on the r5rs grammar
19:36:21 <stepcut> dash: do you use gnu arch at all ?
19:36:24 <dash> no
19:38:25 <stepcut> sent!
19:39:06 <stepcut> I don't remember how compliant it is, but I did write it by looking at r5rs so it should be pretty close
19:40:33 <stepcut> i sent two emails
19:42:21 <stepcut> I have code that compiles core scheme to swf assembly, I am working on the assembler now.
19:42:51 <stepcut> once that works, then I can add the standard library functions
19:43:00 <stepcut> and quasiquotes
19:43:06 <stepcut> and eventually macros
19:43:13 <stepcut> maybe
19:43:13 <dash> stepcut: awesome 
19:43:52 <dash> i am working on a very-explicit lisp interpreter (based on the denotational semantics in LiSP) so that i can expirement with some new language features
19:43:57 <stepcut> I definately want to write the assembler, not sure how far I will go with the scheme portion
19:44:13 <dash> and maybe use QuickCheck to tell me if i've done it right
19:44:15 <stepcut> I am tempted to do a haskell->swf compiler instead :p
19:44:57 <stepcut> I figure once I have a good asm->swf library, I can do all sorts of silly things :)
19:45:20 <dash> Hm
19:45:29 <dash> your types look like less of a mess than mine :)
19:45:50 <stepcut> heh
19:46:04 <stepcut> I just copied the spec into haskell ;)
19:46:29 <stepcut> not sure what will happen when I add quasi-quotes
19:47:26 <dash> stepcut: http://ghostwheel.ddts.net/~washort/arnisparser.hs
19:49:19 <dash> it gets exciting around Quotable :)
19:50:03 <stepcut> heh
19:50:52 <stepcut> cool, I bookmarked it for later reference
19:51:01 * heatsink didn't know that lisp had block comments
19:51:22 <dash> i'm aiming more for a CL-ish thing than a scheme-ish thing
19:51:30 <dash> and CL does have block comments.
19:51:40 <heatsink> ah.
19:52:47 <stepcut> I may have to mark my parser more complicated later, because I think I depend on rewriting things into simpler forms, which makes error reporting a little funky
19:53:24 <stepcut> But when I wrote it, I wasn't even sure that it was possible to compile scheme to the flash VM, so I didn't worry about that too much :)
19:56:30 <Leimy> scheme on the flash vm?
19:57:28 <stepcut> Leimy: yes sir
19:57:41 <Leimy> like flash the web bastardization tool?
19:58:07 <stepcut> yes, macromedia flash
19:59:41 <dash> i just can't live with a lisp implementation that doesn't handle (let ((let '`(let ((let ',let)) ,let))) `(let ((let ',let)) ,let) correctly!
19:59:42 <dash> ;)
20:01:39 <stepcut> me neither
20:01:56 <Leimy> I like swiss cheese
20:04:13 <ikegami--> stepcut: interesting
20:04:37 <ikegami--> (I have read the flash specification)
20:06:36 <stepcut> ikegami--: cool
20:08:18 <Leimy> dons: do I have to "install" yi to get the yi-inplace to work?
20:08:28 <Leimy> or should it just work from the build directory
20:08:53 <stepcut> Leimy: should just work i think
20:09:00 <Leimy> me too
20:09:02 <Leimy> but it's not :)
20:09:07 <stepcut> what happens ?
20:09:07 <ranto> Hi. I need to place a two line let expression in hugs. Is there any way to do multiple lines?
20:09:14 <Leimy> ooh food came
20:09:29 <stepcut> ranto: what is the expression ?
20:09:55 <ranto> let IO a = getClockTime
20:10:01 <ranto> TOD b c = a in c
20:10:13 <ranto> I am so newbie
20:10:33 <ranto> I've just read the prelude
20:10:59 * stepcut blinks
20:11:49 <stepcut> I can't even begin to figure out what that code is supposed to be doing...
20:12:59 <stepcut> what where you hoping that code would do ?
20:13:20 <ranto> take the microseconds of the time (data Time = TOD Integer Integer)
20:14:12 <stepcut> hold on, my gf is calling
20:14:22 <ranto> I want to deconstruct what getClockTime returns. (yes, laugh for a while, I deserve it)
20:14:49 <heatsink> the way to deconstruct is with pattern matching
20:15:28 <hilbert> toUTCTime
20:15:44 <hilbert> also toCalendarTime
20:16:55 <heatsink> The TOD will deconstruct correctly, I think
20:17:18 <heatsink> but you're not trying to deconstruct getClockTime, right?
20:17:45 <ranto> heatsink: no, Clocktime, what getClockTime returns
20:18:23 <heatsink> ranto: getClockTime is not a function, it is a monad. So you can't get its return value that way.
20:19:14 <ranto> heatsink: That's what I was suspecting.... monads are somewhat misterious to me right now
20:20:42 <heatsink> I only know how to use IO monads in compiled programs. someone else should be able to help.
20:21:09 <ranto> heatsink: never mind, thanks anyway
20:21:26 <stepcut> ranto, you need something more like this -> getClockTime >>= \(TOD a b) -> print (a,b)
20:21:43 <stepcut> unfortunately, I have to clean now, so I can't help anymore :(
20:22:16 <ranto> stepcut: ok thanks... that will do
20:23:05 <ranto> thanks a lot to all
20:45:40 <dons> Leimy: did you get yi-inplace to work?
20:45:53 <dons> weren't you on a mac..?
20:52:30 <Leimy> dons: no workie
20:52:34 <Leimy> yes on mac
20:53:40 <dons> what error?
20:53:53 <Leimy> Starting up dynamic Haskell ... Errors in config file, using defaults
20:53:53 <Leimy> /Users/dave/.yi/Config.hs:
20:53:53 <Leimy>     Can't find module `Keymap'
20:53:53 <Leimy>     (use -v to see a list of the files searched for)
20:53:59 <Leimy> and some linker error
20:54:06 <Leimy> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
20:54:06 <Leimy>    __module_registered
20:54:06 <Leimy> whilst processing object file
20:54:06 <Leimy>    /Users/dave/work/yi/HSyi.o
20:54:11 <dons> Config.hs is trying to pull in ~/.yi/Keymap.hs which doesn't exist.
20:54:29 <Leimy> no it isn't
20:54:30 <dons> if you just want the vi bindings, remove ~/.yi/*
20:54:36 <Leimy> hmmm
20:54:45 <Leimy> I changed the settings
20:54:52 <Leimy>    keymap = Vi.keymap
20:55:07 <dons> ok. so Config.hs is importing qualified ~/.yi/Vi.hs ?
20:55:17 <dons> the error msg is ghc trying to compile Config.hs
20:55:25 <Leimy> yeah... that's probabbly it
20:55:29 <dons> so if you can get Config.hs to compile by hand, then yi should be fine with it too
20:55:31 <Leimy> I didn't copy Vi.hs over to yi
20:55:54 <dons> the other dup sym error I don't know.
20:56:09 <dons> try make distclean ; make 
20:56:19 <dons> otherwise I'll have to get on a mac and do some thinking
20:56:55 <dons> now, why does everyone get the configuration system wrong the first time?
20:57:10 <dons> needs to be more intuitive somehow
20:57:32 <dons> examples should probably just be single files, rather than split across Config.hs and FooMap.hs
21:01:52 <Leimy> dons: if you load two different objects that are exporting the same symbol... that would do it
21:02:01 <Leimy> in this case the symbol is __module_registered
21:02:18 <dons> sure. but why is that symbol appearing twice
21:02:27 <Leimy> or it's possible the same object is specified 2x
21:03:46 <dons> oh.. which ghc are you using?
21:03:56 <Leimy> 6.2.1
21:04:06 <dons> because 6.2.2 has a fix to stop it complaining about trying to load the same module twice
21:04:12 <Leimy> figures
21:04:14 <dons> I'm just surprised it has come up.
21:04:29 <dons> it's not supposed to be triggered in this case
21:04:40 * dons is suspicious of the mac
21:04:40 <Leimy> the runtime linker in general on mac os x is very picky
21:05:01 <Leimy> you have to do things like -multiply_defined_suppress to get some binarie to load
21:05:18 <Leimy> and it will stop bitching about certain ELF-legal situations that are suposed to be only warnings on Mach-O
21:05:25 <dons> hm. ok. if you'd like to fiddle with the linking system in mk/rules.mk feel free
21:05:33 <Leimy> I'll look
21:05:34 <dons> otherwise it will have to wait till i get on a mac sometime this week
21:07:23 <dons> still haven't got your patch. or a couple of mails I sent to myself. though some is getting through. will have to bug the admins i think
21:07:38 <Leimy> well HSyi.o has __module_registered defined like 20x
21:07:41 <Leimy> so there isn't much I can do
21:08:19 <Leimy> sorry it's only 15 times
21:24:48 <Leimy> is it wrong to drink a pint of merlot?
21:43:48 <emu> yes, you should drink 2
21:45:06 <Leimy> not if I don't want a headache tomorrow :)
21:48:01 <stepcut> Leimy: are you drinking it in a pint glass 
21:48:02 <stepcut> ?
21:48:50 <Leimy> it's meant for beer
21:48:59 <Leimy> so I think it's a pint
21:49:05 <stepcut> heh
21:49:21 <Leimy> it's pretty good stuff too :)
21:50:01 * Leimy puts Ringu in
22:27:51 <dons> Leimy: but it's just a normal haskell library. why doesn't ghci barf?
22:27:57 <dons> this is what i don't know
22:28:22 <dons> each module in the lib has a __module_registered flag in the generated code.
22:28:47 <Leimy> dons: pehaps because it's not confusing the dynamic linker
22:28:53 <Leimy> and I don't know why it wouldn't be
22:29:19 <dons> yeah, i guess i play a couple of tricks. anyway, as long as ghci works, then i should be able to get yi to work
22:29:45 <Leimy> well I should update to 6.2.2 first probably
22:29:49 * Leimy checks the darwinport status
22:29:55 <dons> yeah. do that.
22:30:00 <dons> Leimy: patches came through
22:30:08 <dons> along with about 1000 missing emails :{
22:30:17 <Leimy> dons: good and bad :)
22:30:21 <Leimy> dons: did you get 3 or 2?
22:30:25 <Leimy> from me
22:30:33 <dons> 2
22:30:35 <dons> from you
22:30:35 <Leimy> ok
22:30:44 <Leimy> then I don't have darwinports configured
22:30:48 <Leimy> er postfix
22:30:50 <Leimy> :P
22:33:26 <Leimy> dons: I probably have to remake the plugin thingy too eh?
22:33:53 <dons> hm. if you uprade ghc versions, yep
22:34:13 <dons> please use the latest nightly snapshot if you're getting into linker hacks ;)
22:39:20 <Leimy> ghc isn't normally so "dynamic" is it?
22:39:34 <Leimy> I mean ... the plugin thingy is a bit of a hack on the ghci runtime isn't it?
22:40:57 <dons> hack, no. it's part of the final part of the Haskell Execution Platform proposed a few years ago.
22:41:05 <dons> it's the same stuff underlying ghci
22:41:42 <dons> i guess it really depends on your defn of "hack"
22:42:07 <dons> if you mean by "not in Haskell98 report", well, yeah..
22:42:12 <dons> :}
22:42:22 <Leimy> I mean... is ghci designed to work that way?
22:42:29 <dons> yep
22:42:36 <Leimy> oh well then nevermind :)
22:42:59 <Leimy> all the fun stuff appears tobe in ghc
22:45:09 <dons> yeah :)
22:46:01 * Leimy wonders how hard it would be to port ghc to Plan 9 :)
23:00:44 <dons> hmm. probably not too hard..
23:01:50 <dons> compared to writing it from scratch
23:03:24 <Leimy> heh yeah
23:04:01 <Leimy> the lack of POSIX is bad though
