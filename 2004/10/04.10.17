00:11:47 <heatsink> oops
00:11:52 <heatsink> I meant (a + b) ** 4
00:12:13 <heatsink> It expands (a * b) ** 4 also :)
00:21:08 <drlion> cool, does it expand (a + b) ** 5?
00:24:37 <heatsink> yes
00:27:38 <heatsink> But I get a stack overflow for (a + b + 2) ** 12
00:38:15 <drlion> :-)
01:01:17 <musasabi> Wasn't 6.2.2 supposed to fix the hashtable performance problems?
01:20:42 <bourbaki> moin
02:54:01 <Lemmih> Good morning, #haskell.
03:47:07 <Boegel> hello everyone :)
03:47:13 <Boegel> bourbaki, I have something for u :p
03:47:14 <bourbaki> hi
03:47:17 <Boegel> s/u/you
03:47:18 <bourbaki> :)
03:47:47 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesis/Haskell/test.png
03:47:56 <Boegel> bourbaki: if you want a bigger version, just let me know
03:48:35 <bourbaki> nah its ok
03:48:55 <bourbaki> looks nice you need lighting :)
03:49:17 <Boegel> is there any way I can measure the time in GHCI ? I mean, how it takes for a function to complete his task
03:49:26 <Boegel> bourbaki: I'm planning this in the next few days
03:49:35 <Boegel> but first I have to improve my code a bit
03:49:46 <Boegel> seperating the math from the raytracing
03:49:46 <bourbaki> make it all parameterizable
03:49:53 <Boegel> and using O-O
03:50:03 <Boegel> bourbaki: what do you mean ?
03:50:15 <bourbaki> then you can just add functions for lighting and surface
03:51:14 <shapr> yow
03:51:18 <Boegel> I'm not sure what you mean by parameterizable
03:51:21 <Boegel> hello shapr
03:51:25 <shapr> hoi Boegel 
03:51:32 <bourbaki> so when you have the point you get the normal and the color of the surface and texture at that point
03:51:42 * Boegel greets shapr again
03:51:59 <Boegel> that's what I'm doing now, isn't it ?
03:52:02 <bourbaki> moin shapr 
03:55:03 <dons> shapr: moin. simple buffer working read-only
03:55:06 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesis/rayCasting.hs (check the intersectSphere function)
03:55:10 <dons> fancier stuff coming in soon
03:55:28 <dons> try: ./hemacs-inplace README
03:55:35 <Boegel> Intersection has the Material, normal and intersection point
03:56:13 <bourbaki> Boegel: ah thats good ok
03:56:22 <bourbaki> my idea was that you have a textrureing function
03:56:40 <bourbaki> so you could ie make textures based on perlin noise and such
03:57:03 <Boegel> ow, man, that's far away now :)
03:57:24 <bourbaki> no it isnt
03:57:32 <Boegel> first things I'm going to implement is intersecting a plane, and using a shading model (specular or Phong, don't know yet)
03:57:42 <bourbaki> perlin noise is quite an easy function you could actually do it right now
03:57:57 <Boegel> what does it do bourbaki ?
03:58:36 <bourbaki> its a function that is tileable in all axes
03:58:48 <bourbaki> you can make clouds with it
03:58:50 <bourbaki> or wood
03:58:58 <bourbaki> marble lava and the like
03:59:40 <bourbaki> so if you have a point in space relative to the object you could trow it into that function and retrieve a grayscale value
03:59:47 <tuomov> shapr, dons: there's the beginnings of an abstract buffer class at http://modeemi.fi/~tuomov/LineEditor.hs
03:59:50 <Boegel> hmmz, but then I have to change my Material type
03:59:55 <tuomov> (plus the beginnings of a line editor)
04:00:02 <tuomov> I wonder if all the functions should be in some monad..
04:00:05 <bourbaki> and colour it with the base colour of your object and then you could make nice marble balls and such
04:00:09 <Boegel> and replace the color with a texturing function specific for that material
04:00:13 <Boegel> or something like that
04:00:32 <bourbaki> Boegel: to me texture and surface is like a function depending on the point on the object
04:00:35 <dons> tuomov: i'm exactly at the point wher I need a decent buffer type
04:01:04 <Boegel> my Material type now has a color, reflection factor and diffuse factor
04:01:06 <bourbaki> so your ray cast gives you a point then you can get the normal and texture and what ever else you need and so
04:01:35 <Boegel> like I do now, by close...
04:01:57 <Boegel> bourbaki: then I should change my Material type to texture (a function), refl and diff ?
04:02:13 <dons> tuomov: looks good. i might drop that straight into HEmacs/Core.hs
04:02:24 <Boegel> and then produce a few function like opaque (just 1 color), perlinNoise, and so on... ?
04:03:05 <bourbaki> Boegel: i dont say you should do that :) i also have never implemented a ray tracer but its the way i would start it
04:03:20 <bourbaki> my idea is that you get a point lets say an element x
04:03:36 <bourbaki> and you have several functions that do the shadeing and texture stuff
04:03:49 <Boegel> sounds nice bourbaki :)
04:03:49 <cptchaos> good morning #haskell
04:04:03 <bourbaki> (tex . light) x
04:04:13 <bourbaki> moin cptchaos 
04:04:14 <Boegel> but if I would do that now (the perlin noise texture), I would probably get strange effects
04:04:22 <Boegel> hello cptchaos
04:04:32 <Boegel> because I don't have any lights yet
04:04:58 <Boegel> but the first thing I have to do now, is improve my current code
04:05:09 <Boegel> math <-> raytracing, and object orientation
04:05:14 <Boegel> and a bit more abstraction
04:05:25 <Boegel> 'cause if I don't do it now, I won't do it :p
04:05:27 <bourbaki> yes a lot more abstract
04:05:46 <bourbaki> but you get my idea do you?
04:05:59 <cptchaos> does anybody know what gereralized data types are (GADTs) ?
04:06:21 <Lemmih> cptchaos: Sure.
04:06:51 <cptchaos> because ghc 6.4 will support it
04:07:02 <dons> ghc-6.3 supports it now!
04:07:07 <Boegel> bourbaki: yeah, I get it
04:07:32 <Boegel> I like the idea very mutch, because I haven't looked at that aspect yet
04:07:34 <cptchaos> hm is there a link that describes GADTs in haskell ?
04:07:44 <Boegel> I was very happy my ray casting bit worked :)
04:07:48 <bourbaki> Boegel: maybe you also want to have a look into volume rendering for fog and that kind of stuff
04:07:52 <kristnjov> is it possible to combine two functions into one.. like this: twoFuncsToOne (a -> b) (c -> d) = (a -> d)
04:07:58 <bourbaki> Boegel: :)
04:07:59 <Boegel> bourbaki: that's really later on
04:08:17 <Boegel> bourbaki: I have to do more than just implement it in Haskell
04:08:25 <bourbaki> Boegel: what else?
04:08:42 <bourbaki> kristnjov: (a -> b) (b -> d) ?
04:08:43 <Lemmih> cptchaos: http://research.microsoft.com/Users/simonpj/papers/gadt/
04:08:53 <cptchaos> Lemmih: thanks
04:09:13 <kristnjov> bourbaki, but can you pattern match like i did?
04:09:19 <Boegel> bourbaki: theoretically support the whole implementation in FunMath, and proving properties of my ray tracer in FunMath
04:09:26 <Boegel> and write a simple GUI
04:09:47 <Boegel> bourbaki: [13:08] <bourbaki> my idea is that you get a point lets say an element x
04:09:47 <Boegel> [13:08] <bourbaki> and you have several functions that do the shadeing and texture stuff
04:09:51 <Boegel> woops :s
04:09:58 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesis/rayCasting.pdf
04:10:04 <Boegel> (it's in Dutch though)
04:10:09 <bourbaki> heh :)
04:11:22 <kristnjov> bourbaki, i'm not quite sure what you meant by that
04:11:26 <kristnjov> (bourbaki) kristnjov: (a -> b) (b -> d) ?
04:12:02 <kristnjov> i have two functions Env -> Env which I want to combine so to speak
04:12:06 <bourbaki> kristnjov: i was not sure if you meant to concaternate two functions that dont have the matching domain and codmain
04:12:25 <kristnjov> well that's pretty much what i want to do
04:12:31 <kristnjov> but how do i write it in code?
04:12:43 <kristnjov> pattern matching wasn't really the trick
04:13:28 <Boegel> I'm gone, going to see my girlfriend (and continuing on #haskell there :p)
04:13:57 <Boegel> bye everyone (see you in a bit)
04:14:07 <bourbaki> girlfriend?
04:14:16 <bourbaki> what real coder has a gf? ;)
04:14:31 <kristnjov> ... so you don't know or are you simply ignoring me?
04:14:34 <bourbaki> kristnjov: are you talking about that gadt thing?
04:14:34 <Boegel> bourbaki: who said I was a real coder :p
04:14:38 <tuomov> he's a fake!
04:14:39 <kristnjov> gadt?
04:14:48 <bourbaki> kristnjov: sry i had to run to the toilet
04:14:54 <bourbaki> tuomov: right
04:15:10 <Boegel> bourbaki: I you need to run, you should eat less onions :p
04:15:17 <bourbaki> kristnjov: ah ok sry i was a bit confused sec
04:15:32 <bourbaki> kristnjov: i dont know how you want to combine two functions like that ie
04:15:37 <bourbaki> heh
04:15:38 <Boegel> I'm out
04:15:50 <bourbaki> atm i eat too much milk based products i think
04:15:57 <bourbaki> and my stomach doesnt like that
04:16:12 <kristnjov> well i'm doing a program simulating digital circuits (andgates and inverters and such)
04:16:30 <kristnjov> and to create a nandgate i could combine the andgate with the inverter, see?
04:16:34 <bourbaki> kristnjov: did you have a look at arrows?
04:16:37 <kristnjov> arrows, no
04:16:46 <bourbaki> i guess thats what you want to do
04:16:56 <kristnjov> okay
04:16:59 <bourbaki> there also are examples for static circuits
04:17:24 <bourbaki> http://www.haskell.org/arrows/
04:17:28 <kristnjov> so i can't simply patternmatch it?
04:17:46 <bourbaki> well the functions need to be of the same type at the junction points
04:17:54 <shapr> dons: yay!
04:17:55 <kristnjov> they are
04:18:13 <bourbaki> kristnjov: didnt you say something like (a -> b) (c -> d) ?
04:18:17 <kristnjov> yes i did
04:18:20 <kristnjov> = (a -> d)
04:18:36 <bourbaki> kristnjov: yes but what you want to have is (a -> b) (b -> c)
04:18:46 <kristnjov> ah yes
04:18:46 <kristnjov> true
04:18:49 <bourbaki> :)
04:18:54 <kristnjov> but hugs gives me errors about unexpected ->
04:18:56 <bourbaki> thats all i meant
04:19:11 <shapr> tuomov: neat!
04:19:17 <bourbaki> kristnjov: you really should read that arrow stuff youll be super happy :)
04:20:01 <bourbaki> are there something like the 10 commandments of haskell programming around?
04:20:26 <kristnjov> i'm not sure i understand that arrow stuff
04:20:48 <kristnjov> i started reading this haskell course i'm in like 7 weeks ago
04:21:44 <bourbaki> hm ... well im not sure if i can help you there but its not that much about haskell its rather about a bit of math
04:21:49 <dons> get your latest hemacs commits while they're hot
04:21:49 <bourbaki> sec there is a paper
04:21:52 <bourbaki> http://www.lysator.liu.se/c/ten-commandments.html
04:21:55 <bourbaki> like that
04:22:39 <bourbaki> shapr: where are these paper on arrow again you pointed me to?
04:24:02 <kristnjov> but are you sure i even need arrows to do what i'm doing?
04:24:30 <dons> shapr, tuomov: now I think we're in a position to really think about buffer types, and editor core api's :)
04:24:40 <bourbaki> you can do circuits in arrows easyly
04:26:01 <kristnjov> but there must be some easier way than trying to learn a whole new part of haskell programming
04:26:14 <bourbaki> its more like a lib
04:26:15 <kristnjov> hughes hasn't even mentioned arrows in the lectures
04:26:28 <bourbaki> you have operators to concaternate functions and such
04:26:39 <bourbaki> whos huges?
04:26:43 <kristnjov> john hughes
04:27:03 <bourbaki> i think i have heared that name but dont know who he is
04:27:14 <kristnjov> he wrote quickcheck and arrows i believe
04:27:23 <bourbaki> do you own a copy of structure and interpretation of computer programs?
04:27:36 <kristnjov> now
04:27:36 <Lemmih> bourbaki: He's also the author of Hugs, right?
04:27:38 <kristnjov> no*
04:27:48 <bourbaki> Lemmih: no idea :)
04:27:54 <bourbaki> i dont believe in names
04:27:56 <Lemmih> eh, I meant to ask kristnjov /-:
04:27:58 <dons> hugs is mark jones
04:28:04 <kristnjov> Lemmih, not sure, wouldn't surprise me
04:28:24 <kristnjov> someone told me john hughes and some other guy were the ones who made functional programming big
04:28:55 <dons> it's big?
04:28:56 <bourbaki> *shrugs* i like choclatebars as well
04:29:07 <bourbaki> but do i worship its inventor ...?
04:29:16 <kristnjov> dons, i don't know, that's what i was told
04:29:39 <dons> jokes folks :)
04:29:45 <bourbaki> as we here in germany say names are smoke and sound (whats the english phrase for it?)
04:30:15 <kristnjov> it's raining cats and dogs? :P
04:30:28 <bourbaki> no
04:30:49 <kristnjov> omg bourbaki
04:30:51 <kristnjov> thanks a LOT
04:30:57 <kristnjov> that was so easy it hurt :D
04:31:02 <kristnjov> the (>>>) operator
04:31:39 <bourbaki> eh
04:31:41 <bourbaki> heh
04:31:47 <kristnjov> what? :P
04:32:00 <bourbaki> no im just glad that you think the same way now :)
04:32:18 <bourbaki> and there are also operators that paralelize two functions
04:32:55 <kristnjov> this made my day :))
04:33:04 <bourbaki> hail to me ;)
04:33:08 <kristnjov> hail \o,
04:33:23 <bourbaki> heh
04:33:39 <bourbaki> itd be cool if you would make a graphical editor for it
04:35:58 <phubuh> john hughes is the director & writer of the breakfast club and ferris bueller's day off!
04:36:32 <bourbaki> !!! :)
04:36:46 <kristnjov> phubuh haha yes i know
04:36:53 <kristnjov> but it's not the same john hughes is it?
04:36:54 <bourbaki> ok if there is one name one should remember ever then its ferris bueler :)
04:37:16 <bourbaki> and speaking of breakfast i need to order a pizza :)
04:37:24 <phubuh> kristnjov: i like to pretend that it is
04:37:26 <kristnjov> i wish i could afford a pizza
04:37:40 <kristnjov> phubuh, life gets much more fun that way, don't you think?
04:37:44 <phubuh> indeed
04:38:12 <bourbaki> kristnjov: ?
04:38:26 <kristnjov> bourbaki, i'm a poor student
04:38:45 <bourbaki> so am i but i dont spend money on anything but internet and food :)
04:39:11 <bourbaki> i dont buy any magazines i never leave my flat so i can afford a pizza once in a while :)
04:40:19 <kristnjov> food rocks
04:41:58 <bourbaki> its kind of the bread and butter of life ;)
04:43:25 <kristnjov> indeed
04:46:49 <shapr> bourbaki: http://www.haskell.org/arrows/
04:47:02 <shapr> dons: yes, we're getting closer
04:48:17 <tic> Arrows are magic. :)
04:48:28 <tic> (but then, I too think they're magic.)
05:00:03 <dons> shapr: yep. what we need is a nice interface defined in UI.hs, that would abstract over, say, ncurses and wxHaskell
05:00:40 <dons> also, buffer ops (see tuomov's classes), and a buffer type
05:01:35 <dons> and then I can start thinking about runtime Haskell evaluation
05:03:18 * dons falls asleep
05:04:40 <Boegel> back :)
05:05:23 <Lemmih> Welcome back Boegel.
05:06:52 <Boegel> okay, let's do some work :p
05:08:35 <shapr> dons: and OpenGL...
05:09:12 * shapr rolls off for one-wheeled meditation.
05:41:21 <musasabi> morning
05:41:37 <musasabi> anyone willing to discuss hemacs ?
05:43:53 <musasabi> shapr: the subscription to post-emacs does not seem to be working.
06:10:19 <Philippa> musasabi: I'd actually be happy to discuss anything but, my brain doesn't like one easy-but-big and two non-trivial projects on the run at once :-)
06:13:44 <peti> Does anyone else have trouble with the current CVS-HEAD ghc? The compiler instals fine, but it doesn't seem to work reliably. It suddenly fails translating an hsc2hs module I've written long ago, and ghci seems to have trouble loading external libraries at random times. 
06:13:53 <peti> Am I the only one having that?
06:16:52 <Igloo> If you have something reproducable I can try
06:17:19 <peti> http://cryp.to/hsdns/ADNS.hsc
06:18:25 <peti> It begins with that ghc doesn't find the _stub.(c|h) files hsc2hs generates, and ends with a compiler error about some undefined function in the object.
06:19:19 <Igloo> And what commands are you running?
06:20:03 <peti> Hmm, I built it as part of a larger project. But "hsc2hs ADNS.hsc && ghc -c ADNS.hs" should already fail.
06:20:46 <Igloo> Where do I get adns.h?
06:21:13 <peti> http://www.gnu.org/software/adns/
06:21:50 <peti> Igloo: I can put a small tar.gz together which demonstrates the problem, if that helps. 
06:22:15 <Igloo> Ah, no, I just thought it was something you'd written. Whichi would be silly, really  :-)
06:22:52 <Igloo> The above commands work fine for me
06:23:00 <peti> Great.
06:23:08 <Igloo> Should be up to date to within a couple of days
06:23:31 <peti> Hmm. I had that problem for several weeks already. So it's probably something in my setup.
06:23:37 <musasabi> Philippa: I am thinking that to do things properly one would need to work on structured data (as opposed to text) and separate front and backends, but then it might get too complex..
06:24:00 <tuomov> I've been thinking about that too
06:24:17 <tuomov> but I'm not sure if it would be very practical
06:24:47 <tuomov> all the parsing code among the rest of it.. it could become an awful  mess
06:25:08 <peti> Igloo: Thanks for trying to help. I guess, I'll compile that problem.tar.gz after all. 
06:25:55 <tuomov> hmm.. maybe language modes should be new buffer types..
06:26:54 <tuomov> then we could start with a simple buffer for plain text and once we get to language modes, just write a special buffer
06:27:09 <musasabi> most complex things operate on structured data.
06:27:28 <musasabi> simple things like text are trivial to represent as structured data.
06:27:52 <musasabi> But representing structured data as text creates complex modes like those in emacs.
06:36:02 <musasabi> Going the structured route would also give the choice for invidual modes - they can treat the whole buffer as a single flat text node or something more complex.
06:36:18 <tuomov> yes, I think that is the way we should go
06:36:46 <tuomov> just specify a buffer api like that planned in http://modeemi.fi/~tuomov/LineEditorState.hs to the editor core
06:37:03 <tuomov> start with a simple plaintext buffer and then write structured buffers for different languages if applicable
06:46:37 * Philippa realises she has a case for HaRe or similar on her hands...
06:48:08 <bourbaki> hare? bucky o hare?
06:48:26 <Philippa> I have a piece of refactoring to do and I really don't want to have to do it by hand :-)
06:48:52 * Philippa looks at haskell-cafe
06:48:56 <Philippa> ah, the start of a new academic year...
06:49:05 <bourbaki> heh
06:55:38 <redhatPT> hi there
06:55:39 <musasabi> tuomov: that fails in that the editor will most probably want to provide generic structured editing commands.
06:56:22 <tuomov> you could have a StructuredBuffer class...
06:56:50 <tuomov> I don't yet know how to really use all these classes though, because haskell doesn't handle type classes and dynamic objects..
06:58:48 <musasabi> tuomov: existentials maybe?
06:59:42 <musasabi> data StructBuf = forall a. StructuredBuffer a => StructBuf a
06:59:59 <musasabi> mypluginBuf :: StructBuf
07:00:07 <tuomov> yes, but if the buffer isn't necessarily structured
07:00:44 <tuomov> there doesn't seem to be a simple way to realise that a data is actually more than we thought it to be..
07:01:48 <musasabi> well flat text is simply just one large text node.
07:03:05 <musasabi> tuomov: think about folding, literateprogramming (two modes in one buffer), ...
07:03:38 <Lemmih> shapr: Around?
07:05:14 <redhatPT> can anyone help me? I've got to create a function that gets a Int and a String like redhat 3 and returns rrreeedddhhhaaattt
07:05:25 <redhatPT> anyone?
07:07:23 * shapr yawns
07:07:48 <shapr> Lemmih: wheee
07:08:17 <shapr> musasabi: what's the problem? lemme guess post-emacs@scannedinavian.org is bouncing?
07:10:22 <shapr> redhatPT: what have you tried so far?
07:10:31 <tuomov> both folding and lp should be possible to do by buffer nesting..
07:10:58 <tuomov> folding hides part of the contained buffer, and lp possibly contains multiple buffers of different types
07:11:01 <redhatPT> I've tried to pass the String to a char list and then add the chars
07:11:12 <Lemmih> shapr: http://212.242.49.100/cgi-bin/web/Main?action=search
07:11:32 <shapr> redhatPT: did it work?
07:11:49 <redhatPT> I cant even pass the string to the char list
07:11:50 <redhatPT> :(
07:12:22 <musasabi> shapr: no, subscribing didn't work, however it seemed to work later quite fine.
07:12:24 <shapr> redhatPT: have you written any haskell functions before?
07:12:31 <shapr> musasabi: that's bizarre...
07:12:44 <shapr> musasabi: you know anything about postfix? I'm having some weird problems....
07:12:50 <redhatPT> shapr its the 1st time
07:12:51 <shapr> have you tried sending mail to the list?
07:12:55 <musasabi> shapr: sorry never used postfix.
07:13:14 <redhatPT> its for a college work
07:13:21 <redhatPT> sorry my bad english
07:13:33 <shapr> redhatPT: I think you should grab a tutorial and work through it... I think you'll be able to write this function after less than an hour of reading and trying the examples.
07:13:35 <musasabi> tuomov: but to implement folding the structure needs to be known to the fold-functionality - not private to the mode.
07:14:12 <shapr> musasabi, tuomov: I'd really like to see this discussion on the mailing-list as well... since I don't quite understand what you're talking about, but very much want to =)
07:14:21 <redhatPT> shapr I have a book that was written by my professor but I cant find anything there
07:14:36 <redhatPT> I've seen the haskell wiki and I found this irc channel
07:14:39 <shapr> redhatPT: does the book include a 'getting started' section?
07:14:46 <tuomov> a StructuredBuffer be defined to export some view of the structure
07:14:48 <redhatPT> sure
07:14:54 <shapr> have you read that section?
07:14:57 <kristnjov> redhatPT, recreate n s = map (\x -> replicate x n) s
07:14:58 <kristnjov> try that
07:15:04 <redhatPT> I got some other functions made by myself
07:15:12 <shapr> redhatPT: do those other functions work?
07:15:18 <musasabi> I'll try to write up something on that to the ML.
07:15:20 <redhatPT> yes sure
07:15:21 <redhatPT> all
07:15:35 <tuomov> or how else do you propose to do folding?
07:15:38 <shapr> do you have a function that can repeat a single letter?
07:15:55 <tuomov> I think it is now at least in jed a special feature of the editor
07:16:17 <tuomov> there's a fold mode, but it just parses the files for {{{ }}}
07:16:18 <kristnjov> replicate 'a' 5 == "aaaaa"
07:16:28 <shapr> tuomov: I'd like to have the whole editor based on parse trees
07:17:10 <shapr> then folding would be a lot easier.
07:17:25 <peti> /me's ghc doesn't like him.
07:17:31 <shapr> hiya peti! ltns!
07:17:37 <redhatPT> kristnjov doesnt work :(
07:17:40 <tuomov> but how do you still combine different modes?
07:17:51 <peti> Just doesn't compile. :-(
07:17:51 <peti> shapr: Hi. :-)
07:18:14 <peti> shapr: It's nice too "see" a familiar face here. :-)
07:18:28 <shapr> tuomov: you mean like an html-mode that uses javascript-mode for the head section?
07:18:58 <tuomov> e.g. jed-style fold-mode with folded parts enclosed in /* comment {{{ */ ... /* }}} */ and any language mode
07:19:12 <tuomov> you could do
07:19:17 <musasabi> tuomov: I'll try to describe how to actually do that.
07:19:27 <tuomov> instance StructuredBuffer a => Structuredbuffer (FoldedBuffer a) where ...
07:19:39 <shapr> peti: want to hack on a post-emacs editor written in Haskell?
07:19:41 <tuomov> and
07:19:52 <tuomov> separate instance for plaintext buffer
07:20:09 <tuomov> or no, not that instance
07:20:14 <peti> shapr: You're kidding? Such a thing exists?
07:20:24 <shapr> I think a buffer should have its structe given by its parser
07:20:28 <tuomov> but for structured buffer the fold mode just hides part of the structure, but still exports it as far as it is needed outside the mode
07:20:31 <musasabi> tuomov: a fold is more like a foldSomething :: Part -> PartRef where PartRef is a snort snippet possibly opening to the full part.
07:20:45 <musasabi> *short
07:20:47 <shapr> peti: the editor formerly known as hemacs, now known as "U+1D321 TETRAGRAM FOR CHANGE"
07:21:07 * peti thought quite a few times before how nice it would be if Emacs understood Haskell! I can't speak a line of elisp to save my life, unfortunately ...
07:21:27 <peti> shapr: Where can I get it?
07:21:28 <shapr> a buffer should have its structure, and the view of that structure can be rendered differently
07:21:43 <musasabi> Now if the structure is generic (and can thus be navigated by generic functions) then it is quite simple to implement the folds as generic code.
07:21:55 <shapr> I think it's 'darcs get http://www.cse.unsw.edu.au/~dons/hemacs/ '
07:22:24 <peti> shapr: Thanks. I'm pulling it now. 
07:22:30 <shapr> peti: it's stone soup right now...
07:23:01 <dv> ls
07:23:04 <dv> oops
07:23:16 <musasabi> shapr: so we have basically three different kinds of operations. 1) Load/save graph from file, 2) transform graph, 3) display a view of a graph
07:23:16 <shapr> but tuomov and dons brought quite a few veggies to the stone soup =)
07:24:54 <peti> Rewriting Emacs? Wow ... that's quite an undertaking.
07:24:55 <shapr> musasabi: I think a graph is a view of a file, and folding and syntax highlighting are views of the graph?
07:25:18 <shapr> peti: not necessarily rewriting it, but at least distilling parts of the emacs QWAN and at a minimum adding multithreading
07:25:24 <shapr> and Haskell
07:25:52 <tuomov> graph? more like tree?
07:25:56 <shapr> ok, tree
07:26:06 <musasabi> shapr: both folding and syntax highlighting can be seen as transforming (or decoriating) the graph.
07:26:07 <tuomov> and, yes, a fold would be a view transformation
07:26:13 <peti> shapr: What about all those lisp modules? Gnus, for instance, and all those other modes? Would it be possible to use these in hemacs? 
07:26:53 <tuomov> and for language modes you want the fold transformation to interpret the comments in the language
07:26:56 <shapr> peti: actually, you probably could with HScheme and the right elisp emulation, but gnus also assumes single-threaded-ness
07:26:57 <Lor> There was a PLDI (I think) paper some years ago about converting elisp to scheme.
07:27:02 <tuomov> while for plaintext you want it to scan all lines of the text
07:27:17 <shapr> peti: but the most important goal for right now is a 'self-hosting' editor.
07:27:34 <peti> shapr: Yes, one step at a time. Let's edit text before we read news with it. :-)
07:27:46 <shapr> as in, I want to switch to using hemacs instead of xemacs, because then I will definitely hack up a whole lot of good stuff.
07:28:17 <shapr> Lor: yes, written by Michael (Mr. Preprocessor) Sperber, friend of Peter Thiemann.
07:28:17 <peti> shapr: I have another contribution to reaching the goal of Haskell world domination, by the way: An MTA written entirely in Haskell. It has delivered its first e-mail two days ago. :-)
07:28:18 <tuomov> I want to switch from jed to hemacs if anything ever comes out of it, because jed development is quite slow, and there would still be lots to do
07:28:23 <shapr> peti: wow cool!
07:28:26 <tuomov> and I'm sure hemacs code will be cleaner..
07:28:41 <peti> shapr: And it's configurable. You bet. :-)
07:28:57 <shapr> peti: that's awesome, when's the first release?
07:29:02 <shapr> I want to use that on my desktop box!
07:29:23 <peti> shapr: Its running on my machine right now. I think, a week or two and then I'll release it.
07:29:37 <shapr> excellent, I look froward to it.
07:29:50 <peti> shapr: The only problem so far is that it has zero configuration files. You write a Config.hs rather than a sendmail.cf now. :-)
07:30:02 <shapr> ah, you need the magic of hs-plugins!
07:30:25 <tuomov> hmm.. next we'll formulate a "theory of buffers"...
07:30:38 <shapr> tuomov: yup :-)
07:31:07 <peti> shapr: I figured, I'll let people who do know Haskell run it first, and then we'll see what kind of combinators come out of it, which might inspire a module system, or config file language.
07:31:50 <shapr> peti: have you named it yet?
07:31:56 <peti> shapr: Postmaster.
07:32:12 <shapr> haha
07:32:17 <shapr> good name.
07:32:23 <peti> Glad you like it. :-)
07:32:37 <shapr> Postmaster will be great for House/hOp
07:32:57 <peti> shapr: House/hOp? What is that?
07:33:12 <shapr> http://www.cse.ogi.edu/~hallgren/House/
07:33:44 <tuomov> just extend riot a little and we have a mua too :)
07:34:03 <shapr> anyway, shopping, and then I'll back for more coding on U+1D321
07:34:23 <peti> Hehe, these guys rock! Device drivers written in Haskell. Cool. :-)
07:35:24 <peti> tuomov: Do you have an URL for "riot", too? I don't know it yet.
07:35:34 <tuomov> http://iki.fi/tuomov/riot/
07:35:36 * peti is interested in all things e-mail. :-)
07:35:40 <peti> thanks
07:35:58 <tuomov> it's just an outliner, but it uses mbox format files
07:36:47 <peti> Ah! I've seen that before. Yes, I recall that project, I've wanted to look at that for ages. Are you the author?
07:36:56 <tuomov> yes
07:37:18 <peti> Good to know. :-) 
07:41:26 <peti> tuomov: I can't compile it. <ncursesw/ncurses.h> is missing, and changing the define in system.mk to use ncurses doesn't seem to help.
07:42:02 <tuomov> you may have to make clean
07:42:09 <Lor> Hm. It suddenly just occurred to me that although hs-plugins is by no means perfect, it might actually provide enough functionality for me to switch from scheme to haskell in a toy project of mine.
07:42:38 <peti> tuomov: doesn't seem to change anything: my_curses.h:21:30: ncursesw/ncurses.h: No such file or directory
07:43:08 <tuomov> which version?
07:43:11 <peti> tuomov: I remember having that problem before. I had patched the sources to compile, but then it just core dumped. 
07:43:22 <peti> tuomov: Just got via darcs. So it should be the latest.
07:43:38 <tuomov> aha. there's a stray include there..
07:43:47 <tuomov> don't know where that's got there from
07:44:16 <tuomov> Fixed
07:45:20 <peti> tuomov: CWString.hsc:267:22:  Ambiguous occurrence `withCWString'
07:45:32 <peti> Lots of them. 
07:45:49 * peti will try it with ghc 6.2 ...
07:46:27 <tuomov> I haven't tried to compile it without all the wchar stuff after don did his hs-plugins changes
07:46:30 <tuomov> maybe I should..
07:46:45 <peti> tuomov: 6.2 fails, too: CWString.hsc:38: Module `Foreign.C.String' does not export `charIsRepresentable'
07:46:55 <tuomov> though he's on openbsd, so..
07:47:39 <tuomov> hmm.. works for me without the wchar stuff too
07:49:07 <tuomov> that charIsRepresentable error is probably due to a kludge there (not my code!)
07:51:15 <Lor> Hm, hs-plugin supports bsd's special random number interface, but not /dev/urandom for linux...
07:51:15 <peti> I think I got it fixed. Compiler is running ...
07:51:26 <tuomov> there are far too many #ifdefs in that file..
07:51:50 <peti> Ugh, don't remind me. I haven't even begun worrying about portability yet.
07:52:45 <peti> Hmm, I've set "USE_HS_PLUGINS=0", but it still tries to link the package.
08:00:45 <tuomov> you most comment the line out
08:00:54 <tuomov> it doesn't matter which value it is set to, if it is set
08:03:22 <tuomov> I think I fixed the ifdef mess..
08:03:42 * peti re-compiles ...
08:04:07 <peti> Works!
08:04:14 <musasabi> When playing with the buffer thing I started thinking whether using boilerplate style traversals could be better than typeclases.
08:04:21 <joao> Hello!
08:04:39 <joao> Is it possible to create an infix operator that begins with ':' ? :)
08:04:47 * peti has yet still to find a useful application for gmap and friends.
08:05:33 <musasabi> peti: well the problem is that type classes + dynamic loading don't mix very well.
08:05:33 <Lemmih> joao: No.
08:05:40 <peti> I keep thinking: "For this problem it would be nice", but I end up solving it without the generics as well. It's weird.
08:06:05 <joao> Lemmih, ok, thanks :)
08:06:15 <Lemmih> joao: ':' counts as uppercase.
08:06:27 <peti> musasabi: Possibly. Haven't used dynamic loading yet either. :-)
08:06:38 <joao> Lemmih, hmmm. Why?
08:07:05 <musasabi> folding a tree node is easy (just wrap it with a node that renders only to a shorthand)
08:07:15 <Lemmih> Which means that you can make data constructors but not functions with it.
08:07:26 <peti> It's hard to keep track of all those features that are added to this language every day. I've stopped even writing all those URLs down. :-|
08:07:56 <Lor> Hm, if I want to name modules in my own code properly, do I really always have to start each module with "module User.Fi.Iki.La.SomePackage.SomeModule where ..." ?
08:08:03 <Lemmih> joao: data Test = String := String
08:08:06 <musasabi> but unfolding gets complex - having it defined in the typeclass would be unhandy.
08:08:36 <Lor> And my email address is still as short as they get...
08:09:47 <tuomov> that java naming convention is brain-dead
08:10:15 <joao> Lemmih, Oh... Thank you :)
08:10:18 <tuomov> maybe TuomovAtIkiFi.SomePackage.SomeModule, but not that
08:10:29 * peti likes the idea that one day someone will design a namespace system _without_ an absolute root.
08:10:58 <peti> It sucks that names are unique only "by convention".
08:11:38 <peti> You wouldn't have that problem if a module's path were relative to the path of the module it is imported from. Then you wouldn't need all those mad prefixes.
08:11:41 <Lor> tuomov, why? I think the java approach to package naming is quite sensible.
08:11:57 <tuomov> as bloated as the rest of the language
08:12:19 <Lor> You have a better idea of how to prevent namespace collisions?
08:12:31 <tuomov> that above?
08:12:38 <peti> Yes. Use relative paths only.
08:12:47 <tuomov> relative's good too
08:13:06 <Lor> Uh, huh?
08:13:31 <Lor> So your point is that instead of dots, use capitalization to separate the components of the domain name?
08:13:42 <tuomov> write the components in a sensible order
08:14:03 <tuomov> and the dots are superfluous since you need to capitalise in any case
08:14:04 <Lor> That's a cosmetic issue.
08:14:24 <tuomov> cosmetics are important
08:14:42 <Lor> It would be nice if there were some shorter guaranteed-unique identifier for every person, but email addresses have to do.
08:15:05 <tuomov> email address may also not always be something you want to be identified with
08:15:21 <peti> Lor: Why does one even _need_ something inane as a "world-wide unique qualifier"? We all know such a thing cannot exist.
08:15:57 <Lor> Of course it can. There are lots and lots of global naming schemes.
08:16:03 <tuomov> and if you have multiple authors for a package, email address become meaningless
08:16:11 <tuomov> maybe a hash of the contents of the first release would be a good identifier?
08:16:21 <peti> Lor: And they are all based on following some convention. 
08:16:29 <Lor> Of course.
08:16:38 <Lor> That's the question here: what's a good convention.
08:17:16 <peti> Lor: relative namespaces don't need any convention. You can call your modules whatever you like.
08:18:30 <Lor> And how do I specify what external modules my code uses?
08:18:43 <peti> Lor: Through an URL?
08:18:53 <Lor> Ah, so that's just another namespace.
08:19:05 <peti> Lor: No, it's an _external_ source.
08:19:07 <tuomov> at compile time, the user must provide a path to the module
08:19:15 <Lor> So no dynamic loading?
08:19:16 <tuomov> peti: it's no different from an email address
08:19:23 <Lor> Every package is statically linked?
08:19:26 <peti> Lor: What does dynamic loading have to do with that?
08:19:33 <Lor> (BTW, Alice uses urls as module identifiers)
08:19:35 <tuomov> dynamically a path to the module is also provided
08:19:53 <Lor> Besides, URLs are _locations_, not identifiers.
08:19:55 <Lor> Even worse.
08:20:03 <peti> tuomov: The URL where I download the package from has nothing to do with the name under which you address the package in your build. That is determined by where I download it to.
08:20:12 <peti> Lor: You misunderstand my point. 
08:20:29 <tuomov> then the url has nothing to do with this issue
08:20:41 <peti> No, it hasn't.
08:21:02 <Lor> peti: If Tuomo writes a package, and I write another package that uses it, and then I ship my code (and mine alone) to you, then how are you (and your compiler) supposed to know which package my code needs to be linked with?
08:21:22 <tuomov> -module Foo.Bar=/usr/local/lib/haskell/FooBar
08:21:49 <Lor> And who is supposed to write that line?
08:22:05 <tuomov> the user by editing a Makefile, or autoconf?
08:22:35 <Lor> So every user of every package is supposed to give manual mappings to all dependencies?
08:22:49 <tuomov> all "non-standard" dependencies yes
08:22:51 <peti> Lor: When I have two libraries and _both_ are named Foo, then I put them into the directories A and B and reference them as A.Foo and B.Foo. By choosing the layout of the build, I can determine the namespace of the whole system. 
08:22:53 <Lor> Besides, how is the user of my package supposed to _know_ which other package to link my code with?
08:23:03 <tuomov> that's what you have to do in any case
08:23:07 <tuomov> check if the package is there and so on
08:23:46 <tuomov> and I've always wanted this sort of more explicit library paths for C... the current path lookup is a mess
08:24:09 <Lor> This sounds like a worse is better philosophy. "We cannot do perfect namespace management, so let's not do it at all, and leave it as the users' problem."
08:24:28 <tuomov> *sigh*
08:24:31 <tuomov> autovirus!
08:24:32 <peti> Lor: That's what you hear. I hear: "I have full control."
08:24:49 <Lor> Compiling java code would be a nightmare.
08:24:57 <Lor> Or any other code with a nontrivial number of dependencies.
08:25:09 <peti> Lor: How do you arrive at that conclusion?
08:25:31 <Lor> Because the amount of manual work needed is then linearly proportional to the number of dependencies in a package.
08:26:01 <Lor> You have to check every package's import conventions manually to make sure that they get mapped properly.
08:26:03 <peti> Lor: Why do you assume there would be more manual work involved in such a system than in an absolute-root system?
08:26:45 <Lor> Because in an absolute-root system you don't need to provide name mappings. A package has just a single name everywhere.
08:27:41 <Lor> And you still haven't answered my question: if I cannot just say "import User.Fi.Iki.Tuomov.FooPackage" then _how_ do I specify which package my code depends on?
08:27:43 <peti> Lor: You realize that the only case in which you have to edit things in when you want to _change_ a name? If the names don't collide, you don't have any more or less work than in any other system. But if two names collide, you _can_ fix it. In Haskell (or Java), you are uh .... fucked, if that happens.
08:28:29 <tuomov> -module Tuomos.FooPackage=/usr/local/lib/haskell/EmailBased.TuomovAtIkiFi.FooPackage
08:28:33 <tuomov> and then
08:28:37 <tuomov> impor Tuomos.FooPackage
08:28:58 <Lor> And how is the user supposed to know that Tuomos.FooPackage should be mapped to that particular package?
08:29:01 <peti> Lor: External dependencies are the domain of the package manager (like the library infrastructure), not of the programming language. There are a million ways how fetching external packages can be automated and none depend on how you call the includes in your program.
08:29:25 <tuomov> you tell the user where to find that package and where it will probably install itself and so on
08:29:29 <tuomov> and maybe autoconf can find it
08:29:36 <Lemmih> Have anyone fixed Network.CGI so it can handle multipart/form-data?
08:29:38 <Lor> Tell it? By using an URL perhaps?
08:29:54 <tuomov> or the package name to apt-get install
08:29:59 <Lor> When we want to identify a single object, even in informal natural speech, it has to have an unambiguous name.
08:30:09 <peti> Lemmih: I have a different module here which does that. It's IMHO much better than the standard module.
08:30:11 <Lor> tuomov, yet another globally-managed namespace.
08:30:33 <tuomov> package names and urls can change
08:30:43 <Philippa> Lemmih: 'fraid I just used Network.CGI
08:30:51 <Philippa> but yeah, it's in much need of fixing...
08:30:57 <tuomov> and what if you need a particular version of a module?
08:30:58 <peti> tuomov: And they can be changed without changing the source code! That's the main advantage, IMHO.
08:30:59 <tuomov> what then?
08:31:00 <Lor> URLs in particular can change.
08:31:06 <Lor> Names don't need to.
08:31:13 <tuomov> and if the author hasn't thought of versioning?
08:31:18 <Lor> Versioning is a different problem.
08:31:20 <peti> Lor: Names  have to changed when they collide.
08:31:21 <tuomov> currently it is quite impossible to select version
08:31:26 <tuomov> relative paths allow for that
08:31:56 <Lor> peti, ...which doesn't happen when there is a properly managed global namespace.
08:32:03 <peti> Lor: hehehe 
08:32:05 <Lemmih> peti: Where's it located?
08:32:28 <peti> Lemmih: I can e-mail you the source. It's not publicly available as far as I know, just got it from another user myself.
08:32:36 <tuomov> e.g. Ion depends on liblua, but I have no way to tell gcc to use liblua.so.5.0 in /usr when liblua.so.4.0 is in /usr
08:32:37 <peti> lor: It happens all the time.
08:32:45 <tuomov> +/local
08:33:01 <tuomov> this is a similar problem
08:33:22 <tuomov> they both have the global name -llua as far as gcc can see
08:33:42 <Lor> Granted, really reliable namespaces are rare. OIDs ought to be pretty good.
08:34:41 <tuomov> Also, often a distribution maintainer may select a naming scheme for packages in the distribution
08:34:49 <tuomov> and sensible defaults can then often be provided
08:34:57 <tuomov> but if you need something else, you can remap with -module
08:36:53 <tuomov> Debian has, for example, renamed liblua 5.0 to liblua50, and this remapping needs to be made when compiling Ion for debian
08:41:15 <Lor> I am all for customizing the namespace on a per-package basis as needed. But still I don't see why a reasonably system shouldn't be used to prevent collisions as far as possible.
08:43:09 <tuomov> in a way I agree. But for more popular packages e.g. an email-based prefixing is quite superfluous, and much of the rest may be just quickly hacked together, not even thinking about any namespaces
08:43:20 <peti> Lor: I am very much in favor of a name convention. Not in the lest, because it makes things easier to find. 
08:46:04 <tuomov> and those less popular package you probably include among the sources to your project, also modifying them
08:47:50 <peti> tuomov: Uh ... is there any documentation in the darcs repository for riot? 
08:48:03 <tuomov> ConfigAPI.hs?
08:48:13 <tuomov> there you should be able to read the keys
08:48:32 <tuomov> I've been planning to write a help screen eventually
08:48:46 <peti> OK, thanks.
08:51:05 <peti> tuomov: This looks pretty cool, actually. I had a similar program back on the Apple Lisa, ages ago. It's rather useful for brainstorming.
08:56:27 <heatsink> I need some help with the type system
08:56:55 <heatsink> I think I'm doing something that is type-correct, but not in a way that the type inference system can prove
08:56:56 <Lemmih> heatsink: What's the problem?
08:57:17 <heatsink> Give me a sec to provide a link to the code
08:58:05 * monochrom resists the temptation of asking the obvious question.
09:00:18 <Philippa> monochrom: you mean "is it /really/ type-correct?"?
09:00:48 <heatsink> http://www.rafb.net/paste/results/SkKTVT10.html
09:01:38 <heatsink> I have an ordering on the types: Int, Ratio, Float
09:01:44 <Lor> Is there a way to use haddock in literate haskell style? Do I have to convert the .lhs into .hs first?
09:01:57 <monochrom> No, I mean "why didn't you prepare the link to the code before speaking up?" :)
09:02:19 <heatsink> and when I do arithmetic operations, I want to demote types as little as possible in order to do the operation
09:03:05 <heatsink> so (IntL a) * (RatioL b) produces (RatioL c), not (FloatL c)
09:03:26 <Heffalump> so what's the type checking problem?
09:03:35 <peti> Lor: You have to "unlit" the sources first. 
09:04:03 <heatsink> on the first implementation of leastPrecision
09:04:32 <heatsink> I get the error: Cannot unify the type-signature variable `a' with the type `Int';  Expected type: Int; Inferred type: a; In the application `op a b'
09:04:41 <Heffalump> where is coerceToFloat definde?
09:04:46 <Lor> Bah, haddock forces function type declarations to be indented Wrong.
09:05:06 <heatsink> I forgot to include that.... coerceToFloat :: Literal -> Float
09:05:07 * peti will do some coding ...
09:05:10 <peti> Take care, guys.
09:06:22 <Heffalump> can you give me the definition?
09:06:56 <heatsink> ok
09:07:03 * monochrom resists the temptation of asking the extremely obvious question. :)
09:07:42 <monochrom> Perhaps it's Sunday so everyone is unusually unorganized. :)
09:09:17 <heatsink> coerceToFloat (IntL i)   = fromIntegral i
09:09:17 <heatsink> coerceToFloat (FloatL f) = f
09:09:36 <Heffalump> what's the clause for RatioL ? I worked out those two for myself :-)
09:09:43 <Heffalump> though I guess it doesn't matter
09:10:02 <heatsink> I forgot about RatioL, am working on that
09:11:04 <Heffalump> ok, so one subtle problem is that it doesn't like the way you are using "op" polymorphically
09:11:19 <monochrom> very disorganized :)
09:11:19 <Heffalump> A rather more significant problem is that yuor instance Num Literal can't work
09:12:00 <Philippa> it's recursive
09:12:12 <Heffalump> philippa: (+) doesn't have type a->a->a
09:12:14 <heatsink> hmm, because it requires that (+) have more than one type?
09:12:20 <Heffalump> heatsink: yeah
09:12:24 <heatsink> oh!
09:12:26 <Heffalump> What you'll need to do is use -fglasgow-exts
09:12:34 <Philippa> Heffalump: yeah, that too. Existential types ahoy
09:12:38 <Heffalump> leastPrecision :: (forall a . a -> a -> a) -> Literal -> Literal -> Literal
09:12:48 <Heffalump> (assuming you are using ghci)
09:12:50 <shapr> Heffalump Attack! hide the hunny!
09:13:03 <Heffalump> but you actually need to put a Num a => in there too, to make your instance Num literal work
09:13:09 <Philippa> shapr: PM
09:13:20 <Heffalump> what which when who where?
09:13:26 <shapr> hiiii Heffalump!
09:13:51 * Heffalump only has two more weeks in academia :-(
09:13:54 <heatsink> okay, I'll try that
09:14:00 <Heffalump> (anyone going to OOPSLA, OOI?)
09:14:06 <shapr> Heffalump: speaking of the real world, have you see the editor formerly known as hemacs?
09:14:36 <Heffalump> pardon?
09:14:51 <shapr> an editor written in Haskell.. 
09:14:54 <shapr> it's a stone soup editor
09:15:03 <Heffalump> a what?
09:15:08 <shapr> well,
09:15:24 <shapr> the editor formerly known as hemacs, now known as "U+1D321 TETRAGRAM FOR CHANGE"
09:15:36 <Philippa> "everybody brings a bit to add to it 'til you get a working editor from a stone"
09:15:42 <shapr> yah, totally
09:15:48 <shapr> you know the stone soup parable?
09:15:54 <Heffalump> you've all gone crazy since I last left.
09:15:54 <shapr> fable?
09:16:00 <Heffalump> s/last left/was last here/
09:16:03 <shapr> Heffalump: excuse, have you ever known me to be sane?
09:16:06 <Heffalump> although maybe you were crazy even then
09:16:10 <shapr> you're not used to me anymore :-P
09:16:11 <Philippa> heh
09:16:39 <shapr> right, sources...
09:16:50 <shapr> Heffalump: darcs get http://www.cse.unsw.edu.au/~dons/hemacs/
09:18:27 <heatsink> argh, I turned on glasgow-exts and now it thinks my $ operators are template haskell
09:18:30 * heatsink inserts spaces
09:18:58 <shapr> outer spaces!
09:19:26 <heatsink> yay it worked thx
09:21:32 <shapr> Heffalump: dons got hs-plugins to load a whole app on top of a tiny static core... it's way sexy.
09:24:20 <Heffalump> hmm.
09:24:28 <Heffalump> I think I'll stick with xemacs for now..
09:24:30 <shapr> remember the MoreModule problem?
09:24:40 <Heffalump> he told me at ICFP that he fixed that
09:24:42 <shapr> well yeah... hemacs isn't quite usable yet
09:24:54 <shapr> but it will be soon =)
09:25:05 <shapr> not bad for starting on wednesday...
09:25:09 <shapr> want to join the mailing list?
09:25:11 <Heffalump> no.
09:25:42 <shapr> ok
09:25:53 <Igloo> :-)
09:25:56 <shapr> so, you're going to ARM, right?
09:26:04 <Heffalump> yes.
09:26:09 <shapr> sounds nifty =)
09:26:25 <shapr> do they write their compilers with a functional lang?
09:26:49 <Heffalump> they do some research stuff with Haskell, but I'm not going to be in the research division
09:27:05 <shapr> will you be an expert on ARM9 assembly so I can ask you questions? :-)
09:27:11 <Heffalump> I expect so.
09:27:18 <shapr> cool!
09:27:22 <Heffalump> well, the first half of your clause, anyway.
09:27:26 <shapr> haha
09:28:35 <Heffalump> :-p
09:29:10 <shapr> hey, did you see the IOHCC winners?
09:29:25 <Heffalump> yes.
09:29:35 <drlion> shapr: is the mailing list in gmane?
09:29:39 <shapr> Ulf Norell's documentation starts off with "All Haskell programs are alpha-equivalent (in some sense)"
09:29:50 <shapr> drlion: yes it is, gmane.org.editors.post-emacs
09:29:55 <Heffalump> yeah, I never did quite understand that claim
09:30:11 <drlion> oh, sounds cool :-)
09:30:32 <shapr> I called it 'metasteganography' because he encodes the other program in the variable names of the carrier program.
09:30:54 <Heffalump> ah, right.
09:31:21 <shapr> of course, I only called it that after I asked Igloo to explain to me just what was going on in that code.
09:31:40 <Philippa> shapr: did you just not have a category theory abuse entry?
09:31:52 <shapr> nope, sadly not
09:31:58 <shapr> Philippa: you'll submit one next year, right? ;-)
09:32:09 <Philippa> heh
09:32:10 <Philippa> possibly
09:35:25 <shapr> One especially cool feature of Ulf Norell's submission was his use of Template Haskell to separate the 'deriving' mechanism from the definition of the datatype.
09:35:50 <shapr> He used that to derive Data and Typeable on a bunch of standard library types that don't already have that.
09:36:21 <shapr> His submission only does that for non-parameterized datatypes, but he's update it to work with parameterized datatypes also: http://www.cs.chalmers.se/~ulfn/th/DeriveData.hs
09:38:23 <musasabi> That sounds quite usefull.
09:47:07 <musasabi> shapr: post-emacs@lists.scannedinavian.org is bouncing my mails.
09:47:49 <heatsink> It refused my confirm-join-list message as well...
09:47:56 <musasabi> <post-emacs@scannedinavian.org>: unknown user: "post-emacs" (the sent mail had *lists*.s.o)
09:48:28 <shapr> it's a postfix problem... and I haven't figured out how to fix it. The suggestions on #postfix haven't worked :-/
09:48:29 <Igloo> Did I manage to subscribe? I don't tend to read bounces these days
09:49:02 <shapr> some mailers send to the canonical MX rather than the hostname, and then postfix bounces it...
09:49:52 * shapr tries something else...
09:49:55 <musasabi> shapr: at least the server here does it (I had the issue with some other domains and the local admin just refered me to the RFC)
09:50:16 <musasabi> (that the canonical MX is correct)
09:50:58 <shapr> mailman suggests usage of virtual domains, but the mailman config doesn't keep it from being rejected...
09:52:41 <musasabi> shapr: the problem is that lists. is a CNAME, which means that the post will get sent to @s.o instead of @l.s.o, and postfix deduces that there is no such recipient on s.o (which is probably correct)
09:52:50 <shapr> right
09:54:19 <musasabi> could you locally redirect posts from post-emacs@s.o to post-emacs@l.s.o (caveat - that might create a loop)
09:54:37 <shapr> I don't think it will create a loop, I'll try that.
09:58:36 <shapr> musasabi: ok, can you try it?
10:01:45 <musasabi> yes
10:02:43 <musasabi> worked ^_^
10:03:19 <shapr> w00!
10:03:27 <shapr> heatsink: ok, it should no longer bounce
10:22:54 <shapr> SyntaxNinja: YOW!
10:23:11 <shapr> wazzup?
10:23:38 <kristnjov> if i want to take -1 on a and +1 on b in (a,b) how do i do that?
10:23:49 <kristnjov> if (a,b) is a function
10:24:08 <shapr> isn't (a,b) a tuple?
10:24:22 <kristnjov> yes, but i don't know how to explain this..
10:24:48 <musasabi> kristnjov: could you provide some simple examples?
10:25:01 <kristnjov> i have a function which takes two arguments and returns a tuple..
10:25:06 <kristnjov> and i'm writing a property for it now
10:25:12 <shapr> tupF f g (a,b) = (f a,g b) 
10:25:13 <shapr> ?
10:25:47 <kristnjov> is that a prelude function?
10:25:52 <shapr> no, I just made it up
10:26:03 <kristnjov> can you use (-1) and (+1) as f and g=?
10:26:57 <shapr> try it
10:27:20 <kristnjov> well isn't there any simpler way? :P
10:27:43 <shapr> probably
10:27:54 <shapr> figure it out ;-)
10:28:00 <kristnjov> ye :P
10:28:41 <kristnjov> unzip maybe?
10:28:53 <kristnjov> unzipWith
10:29:28 <kristnjov> ok that wasn't a function :)
10:33:07 <SyntaxNinja> shapr: w00t
10:39:58 <Igloo> (-1) is a number, not a function (ignoring nasty tricks)
11:02:19 <desrt> attempting to grok .hc leads to insanity
11:03:11 <tuomov> as the name says, it's hard-core stuff
11:03:20 <desrt> heh
11:04:40 <desrt> the fact that (-1) and (+1) have different types is annoying
11:05:06 <desrt> the fact that (- 1) and (+ 1) also have different types is more annoying
11:05:39 <desrt> see also (-(1))
11:06:17 <desrt> is there a better way to write (\a->a-1)?
11:06:58 <Lemmih> pred
11:07:05 <Lemmih> @type pred
11:07:06 <lambdabot> pred :: forall a. (Enum a) => a -> a
11:07:27 <Lemmih> @eval pred 10
11:07:27 <lambdabot> unbound variable: pred
11:07:34 <desrt> ah
11:07:36 <desrt> opposite of succ
11:07:42 <Lemmih> Indeed.
11:07:52 <desrt> ok.  how about (\a->a-2) :)
11:07:58 <desrt> without pred.pred
11:09:48 <desrt> hm
11:09:51 <desrt> (flip (-) 2)
11:09:56 <desrt> heh
11:10:03 <tuomov> I've thought it would be nice to have a math-style currying syntax
11:10:25 <tuomov> so you could do f(., y) for \x -> f(x, y)
11:10:43 <desrt> hm
11:11:03 <desrt> it would also be useful if you could specify the nth argument to fill in
11:11:12 <desrt> that would be an easy combinator
11:11:50 <SyntaxNinja> shapr: you msg me, and then you disappear. shameshame
11:12:00 * shapr immediately reappears
11:12:03 <shapr> *poof*
11:13:35 <tuomov> however, this syntax won't work without parentheses around the function arguments
11:14:15 <shapr> desrt: if you can't read .hc files, you're not hard core.
11:14:26 <shapr> hardCore, excuse me...
11:15:01 <desrt> shapr; i'm working at it :)
11:15:16 <desrt> gcc does some annoying stuff that the splitting doesn't handle properly
11:15:32 <desrt> trying to figure out the best way to handle it
11:20:52 <musasabi> having whitespace specifying indentation would be nice.
11:21:01 <musasabi> no.
11:21:16 * musasabi looks at the right word
11:21:16 <shapr> ?
11:21:24 <musasabi> operator precedence.
11:21:40 <musasabi> so that one could write a+b * c 
11:21:45 * desrt gets the feeling that monomorphism is biting his ass again
11:21:48 <shapr> unicycling on ice and snow is an usual experienc.
11:21:54 <shapr> musasabi: that's a really nifty idea.
11:22:13 <shapr> ahem "unusual experience"
11:22:23 <shapr> I slipped on the ice a few times.
11:22:40 <monochrom> mathematician's notations are mostly sloppy.
11:22:41 <tuomov> head still in one piece, though?
11:22:58 <shapr> yah, I always wear a helmet when unicycling, since I make a living with my brain.
11:23:04 <tuomov> sloppy, but convenient
11:23:28 <Philippa> you can't afford sloppiness in a programming language though
11:23:37 <Philippa> far too easy to eg fuck up a refactoring
11:23:51 <tuomov> but this can be given clear meaning
11:23:59 <tuomov> _if_ you have those parentheses
11:24:04 <musasabi> parenthesis are easy to get wrong too.
11:24:05 <tuomov> without parentheses it becomes ambiguous
11:24:07 <monochrom> For example "1 1/2" for 1+1/2, "sin x" for sin$x, and "x y" for x*y.  "Would be nice to adopt this to programming languages".  No, would be a nightmare, unless you're Larry Wall.
11:24:39 * Philippa nods
11:24:40 <tuomov> f _ y x =? (\z -> f z y) x or (\z -> (f z y) x)
11:24:48 <musasabi> (in C) if(foo = bar() < 1) 
11:24:48 <shapr> I wonder what advantages graphs would have over n-ary trees for representing source code.
11:24:58 <Philippa> though I would like to spend more time talking about programming languages to a friend of mine studying (natural) languages
11:25:11 <desrt> shapr; common subexpressions
11:25:27 <monochrom> n-ary tree = graph with no sharing
11:25:45 <shapr> yah but, how would that be useful in an emacs-mode?
11:26:05 <monochrom> probably not much
11:26:26 <Philippa> and it'd get in the way a lot, I suspect
11:26:31 <shapr> automatic refactoring?
11:26:39 <shapr> if you can find the duplicate parts of the source code?
11:26:46 <shapr> hmm
11:26:58 <Philippa> never automatic, only on demand IMO. In which case it doesn't matter because you can generate the graph from the tree
11:27:02 <tuomov> going beyond parse trees may be a bit too ambitious..
11:27:10 <musasabi> It could be nice in e.g. Gnus with different aliases for one group (or a todo manager). But that all can be solved by replacing the cycles with link-nodes.
11:27:37 <shapr> I've just never thought of the possibilities of a higher level representation of source than a parse tree....
11:27:53 <shapr> so I wonder if there are any cool tricks that could do
11:28:13 <tuomov> and if the buffer interface design is good, it will be possible to experient with other kinds of structures later on
11:28:18 <shapr> yah, true
11:28:28 <Philippa> and if not, you refactor 'til it is ;-)
11:28:33 <shapr> heh
11:28:52 <shapr> Ivan Moore wrote an automatic refactoring plugin for the Self Language
11:29:05 <cm> Intentional Programming is still in a certain way appealing to me, although i haven't been able to isolate what i think are the good ideas from it
11:29:43 <shapr> I'm not convinced IP can really work across languages like Haskell and C
11:30:16 <shapr> maybe for languages with more similarity.
11:30:19 <Philippa> it could probably work across Haskell and Haskell embeddings of C's semantics though...
11:30:25 <shapr> yah, good point
11:32:55 <shapr> I've been thinking of something like text -> parse tree -> actual display, I wonder if graphs might be useful in the display part
11:33:08 <shapr> maybe with syntax highlighting, or active properties? or folding?
11:33:36 <monochrom> No, it won't speed things up.
11:34:07 <musasabi> shapr: After thinking I think trees are enough.
11:34:32 <tuomov> folding as I understand it would be just another transformation between parse tree and display
11:34:47 <musasabi> shapr: no-one is saying that the the data may not form cycles - just that there should be a tree representation for it.
11:34:48 <shapr> yah, I agree about folding.
11:35:08 <tuomov> interestingly, you could make a folding between text and parse tree to, to hide part of the source..
11:35:12 <shapr> musasabi: yah, I'm just trying to do a random walk of ideas that might be better with a cyclic representation...
11:35:13 <musasabi> shapr: and when doing things with graphs you have to break the cycles in some way.
11:35:17 <tuomov> from the parser
11:35:20 <shapr> right, good point
11:35:29 <tuomov> folding and parsing don't commute..
11:35:43 <tuomov> we're getting to the theory of buffers here.. :)
11:35:48 <shapr> heh, cool =)
11:36:01 <shapr> we should invite David Roundy to come chat with us about this :-)
11:36:04 <musasabi> parsing is a String -> Tree operation while fold is a Tree -> Tree operation.
11:36:32 <tuomov> Fold is either Tree -> Tree or Text -> Tree, as we want to fold plaintext too
11:36:55 <tuomov> the kind of folding I'm thinking off is based on special markers within the plaintext or comments
11:37:08 <tuomov> but of course you could support folding functions and so on too in the Tree -> Tree fold
11:37:10 <shapr> right
11:38:08 <shapr> and it would probably be easiest to have Text -> Tree first step, and only do views on the resulting Tree
11:38:35 * shapr bounces cheerfully
11:39:30 <shapr> this is fun 
11:40:40 <Maddas> It sure sounds like fun :-)
11:41:01 <cm> bounce bounce
11:41:08 <tuomov> hmm.. I wonder if the lenses paper I once saw on the darcs ml would be relevant..
11:41:29 <shapr> export EDITOR=hemacs
11:42:00 <tuomov> http://www.cis.upenn.edu/~bcpierce/papers/lenses.pdf
11:42:42 <shapr> oh hey, we can rip out lots of the MetaEnvironment
11:42:59 <shapr> in fact, that's probably a good direction to aim
11:43:06 <tuomov> what's that?
11:43:18 <shapr> it's a tool for designing languages, sort of,
11:43:45 <shapr> it uses emacs for the editing component, stratego for tree transforms, SDF+ASF(?) for BNF and parser building
11:43:56 <shapr> and ATerm is the 'standardized' parse tree format it uses
11:43:57 * Oeje1 ducks to avoid all the bouncing.
11:44:17 <shapr> ATerm is designed to interface well with a variety of languages
11:44:38 <shapr> it has Haskell libs for higher-order hacking, and C libs for speed
11:45:10 <desrt> ok.  i've come to the conclusion that my function is impossible
11:45:23 <shapr> desrt: You are dysfunctional.
11:45:33 <monochrom> Your function is to procreate.
11:45:39 <monochrom> If your function is impossible, ...
11:45:41 * shapr grins
11:45:44 <desrt> because the type of the function changes depending on one of the arguments
11:46:07 <desrt> i keep getting "can't construct infinite type" errors from ghc :P
11:46:14 <desrt> and if i think about it, i can't type this function either
11:46:30 <shapr> tuomov: http://www.cwi.nl/projects/MetaEnv/
11:46:38 <desrt> damn shame
11:46:51 * shapr has problems typing sometimes too
11:47:01 <desrt> basically, apply n f a
11:47:05 <desrt> applies a as the nth argument to f
11:47:17 <desrt> so if f x y z = x*y+z
11:47:28 <desrt> and you apply 3 f 6
11:47:36 <desrt> you get (\x y -> x*y+6)
11:48:01 <desrt> sort of a super-flip
11:48:07 <monochrom> Hrm, probably not typable in our familiar type system.
11:48:13 <desrt> ya.  you can't type it
11:48:19 <desrt> :(
11:48:21 <Igloo> You could do it with TH
11:48:28 <desrt> th?
11:48:32 <shapr> TH!
11:48:33 <Igloo> Template Haskell
11:48:33 <monochrom> template haskell
11:48:35 <desrt> ah
11:48:51 <monochrom> yeah I recommend that as the first workaround attempt.
11:48:58 <tuomov> f(.,.,6)
11:49:04 <desrt> tuomov; ya.  exactly :P
11:49:10 <musasabi> Is there any list which parts of GHC work in windows environments?
11:49:21 <desrt> tuomov; you got me started on this
11:49:48 <tuomov> hmmm.. maybe some type-level programming
11:49:55 <desrt> haskell's lack of support for infinite types is annoying
11:50:22 <shapr> desrt: you could try it in C
11:50:39 <desrt> you'd need some assembly magic to make it work
11:51:07 <desrt> assuming you mean to do it with the C function calling convention
11:51:42 <shapr> can C generate infinite types?
11:51:49 <desrt> C doesn't have types :)
11:52:02 <Lor> What's an infinite type?
11:52:02 <Philippa> musasabi: I'm not aware of one. Thankfully most seem to now
11:52:12 <Philippa> though not the Posix bits
11:52:26 <cm> and GLU didn't work for me either
11:52:35 <shapr> Lor: I have one handy, but it won't fit into this margin...
11:52:39 * shapr grins evilly
11:52:43 <musasabi> so anything outside System.Posix (and various display things) is fair game for portable apps ?
11:52:51 <cm> GLUT*
11:53:26 <desrt> i love how if you try to type lambda calculus using haskell's type system you don't even get past the first ( :)
11:53:37 <desrt> ((((((((((((((...
11:53:40 <Philippa> musasabi: can't guarantee it, but it seems to be getting on for that way
11:53:50 <Lor> desrt, ah, you meen equi-recursive types?
11:54:00 <Philippa> you can always hand me the code and ask me to scream at you if it doesn't work - windows is my home platform
11:54:05 <desrt> Lor; i mean types that reference themselves
11:54:25 <desrt> in lambda calc, everything has type a
11:54:28 <desrt> where a = a -> a
11:54:47 <Lor> Haskell has recursive types, there just needs to be a named type constructor somewhere in between the recursion.
11:54:57 <Lor> But you can do newtype F = F (F -> F)
11:55:13 <Lor> And then add some wrappers to add and remove F properly, and you can do LC.
11:55:31 <desrt> you can do lc a lot easier if you cheat a little :)
11:56:40 <Lor> If you really really want equi-recursive types for some reason, try ocaml -rectypes.
11:56:52 <musasabi> Philippa: thanks, I'll ask when I have something critical to test (of which I am unsure of)
12:00:41 <shapr> hej tuomov
12:00:43 <shapr> ahem
12:00:47 <shapr> hej tumm 
12:00:52 * shapr smacks his nick completion
12:01:11 <Philippa> musasabi: lemme know if there're any libs you want to know about generally, I might've tried them already
12:02:04 <tumm> hi
12:02:37 <shapr> how does Data.Generics compare to Strafunski?
12:02:41 <desrt> wow
12:02:46 <musasabi> Philippa: Network.Socket comes to my mind.
12:03:07 <desrt> ladd :: forall t4 t3 t1 t2 t. ((((t -> t1) -> t2 -> t) -> (t -> t1) -> t2 -> t1) -> t3 -> t4) -> t3 -> t4
12:03:21 <Philippa> musasabi: I'm just trying to remember, but I could swear I've had something working using that
12:03:44 <Philippa> but yeah, pretty likely - withSocketsDo was added so winsock inits/deinits could be called
12:03:59 <desrt> lprod :: forall t5 t1 t t3 t4 t2 t6. ((t -> t1) -> ((t6 -> t6) -> t6 -> t6) -> t5) -> ((((t2 -> t3) -> t4 -> t2) -> (t2 -> t3) -> t4 -> t3) -> t -> t1) -> t5
12:04:02 <desrt> this is scary shit
12:04:54 <musasabi> thanks.
12:06:49 <desrt> are unicode function names kosher in haskell?
12:07:09 <shapr> they're standard =)
12:07:16 <desrt> cool
12:07:20 <shapr> too bad no one implements that part of the standard
12:07:41 <desrt> lc.hs:1: lexical error
12:07:52 <desrt>  0 = (\f x -> x)
12:07:53 <desrt> lame :P
12:08:07 <shapr> like I said man, nobody implements that part of the standard.
12:08:20 <shapr> which has led to some irritated discussions on the various haskell mailing lists
12:08:40 <shapr> everyone wants it, no one wants to actually sit down and make the various implementations do it right.
12:08:52 <shapr> greetings squire 
12:08:58 <squire> hi shapr
12:09:04 <shapr> how's code?
12:09:39 <Philippa> shapr: what're the issues?
12:10:07 <shapr> detailed and confusing last I remember...
12:11:17 <desrt> well, you have to decide what a variable name character is
12:11:34 <desrt> and you need to handle capitals properly
12:11:35 <squire> what is haskell's equivalent of a symbol type?
12:12:01 <Lor> Sadly, there is none.
12:12:04 <desrt> if you start a token with a greek capital letter then it's a type/data constructor?
12:12:15 <Lor> It's relatively easy to implement symbols, though.
12:12:15 <desrt> or is it a variable with a greek symbol?
12:14:15 <musasabi> shapr: the problem is that cases don't work in many writing systems.
12:14:47 <tuomov> if we just had at least greeks and extra operator characters..
12:14:48 <shapr> squire: what do you mean?
12:16:00 <desrt> having () = (&&) for example would be nice
12:16:13 <squire> shapr: Well, I'm so used to thinking in Lisp that I'm looking for a symbol type
12:16:30 <squire> shapr: for instance, how do i represent variables in an interpreter?
12:16:45 <tuomov> circled + and * would be nice and so on
12:16:45 <shapr> in ghci you can say "let x = 5"
12:16:54 <tuomov> maybe \cup and \cap and so on
12:17:03 <shapr> yah, all the hylo- cata- ana- +morphism symbols
12:17:15 <shapr> bananas, lenses, etc
12:17:32 <tuomov> hmm.. hemacs should support writing these symbols with their latex names
12:17:53 <shapr> btw, ATerm looks like an excellent Tree type
12:18:04 <shapr> squire: do you have ghci handy?
12:18:09 <desrt> tuomov; no.  something higher should
12:18:33 <desrt> gtk supports character composing already, for example
12:18:40 <tuomov> maybe, but there exactly isn't such a good framework
12:18:44 <desrt> you could add a gtk input method to support tex
12:18:59 <tuomov> there are actually X input methods..
12:19:11 <tuomov> but of course nobody uses them as everyone has to reinvent the wheel
12:19:15 <squire> shapr: yes
12:19:22 <desrt> x input methods sort of suck
12:19:35 <tuomov> and in any case, I do not want to use gtk apps
12:19:36 <desrt> well.. they're not suited for this, i should say
12:19:40 <tuomov> I want my editor to run in the tty
12:19:51 <desrt> tuomov; then the tty ought to support this
12:20:09 <desrt> linux console already supports utf8
12:20:15 <Lor> Hm, which has the best-looking future? Data.FiniteMap, DData or Edison?
12:20:22 <tuomov> maybe, but it is easier to write a few lines in the editor..
12:20:27 <desrt> and you can do fancy things with the keymap.. but not as fancy as you get with gtk, unfortunately
12:20:29 <tuomov> an extra script
12:20:36 <desrt> tuomov; right.
12:20:49 <desrt> workarounds are often easier than fixing the real problem :)
12:20:53 <shapr> squire: ghci is an 'incremental compiler' so you can do a lot of stuff interactively, but not everything that fits into a .hs file will go into an interpreter
12:21:10 <tuomov> the real problem being that internationalisation support sucks everywhere
12:21:16 <desrt> i agree
12:21:20 <desrt> well.. most places, anyway
12:21:36 <desrt> your statment of "everywhere" makes it quite clear that you're not a gtk user :)
12:21:41 <squire> shapr: i've noticed. you can't define functions at the repl
12:21:45 <tuomov> gtk sucks, so...
12:21:57 <shapr> squire: there's a better solution in the near future with hs-plugins, but it isn't easily available right now
12:22:00 <desrt> tuomov; that's an interesting opinion
12:22:11 <shapr> squire: you can, actually "let f x = x + 1"
12:22:32 <desrt> don't try to let f = succ, though =)
12:22:39 <tuomov> I've never liked the _awful_ API, GObject and everything at all, and, hey, I wrote Ion. 
12:23:06 <shapr> desrt: you succ
12:23:14 <desrt> shapr; i try to succ and fail :(
12:23:18 * shapr laughs
12:24:03 <tuomov> well, to speak the truth, I've yet to see a single tolerable WIMP toolkit
12:24:10 <tuomov> WIMP is inherently awful
12:24:55 <tuomov> it is crappy as an UI, the code for such UIs is complex
12:25:05 <squire> i'm being tripped up by the type system
12:25:13 <squire> i have a type Term, and 3 ways to construct it
12:25:34 <squire> and a list (Char, Term)
12:26:07 <squire> now I try 'find ('f', ****) assocList'
12:26:34 <squire> the problem is what do I substitute for '****'?
12:26:38 <Lor> tuomov, what would be a better api for a widget system, when you're constrained to using C?
12:26:58 <tuomov> I'd rather not interface with such a widget system. at least not directly
12:27:47 <Lor> That's not an answer.
12:27:56 <tuomov> ObVis: http://modeemi.fi/~tuomov/vis/
12:28:07 <Lor> If you think the api is bad, surely you have a better alternative in mind?
12:28:36 <desrt> tuomov; this sounds boring
12:28:56 <desrt> how the hell am i supposed to waste time staring off into space if i don't have pretty icons to stare at?
12:29:03 <shapr> squire: can you show me the code for your type?
12:30:15 <squire> shapr: paste it right here?
12:30:21 <shapr> if it's only one line, sure
12:32:22 <squire> data Term = VarTerm Char | ConstTerm String | AppTerm [Term]
12:32:27 <squire> then I try this:
12:32:45 <shapr> ghci won't let you define that datatype interactively
12:32:57 <shapr> you can put it into a file and load the file into ghci
12:33:03 <squire> ofcourse, it's in a file
12:33:04 <shapr> then you can construct values of that type
12:33:06 <shapr> ah, ok
12:33:14 <shapr> VarTerm 'a'
12:33:18 <shapr> or ConstTerm "foo"
12:33:26 <squire> deleteBy (\(x,y) (p,q) -> x == p) (i, ConstTerm "foo") s				s
12:33:39 <squire> oops, two s's
12:33:49 <squire> s :: [(Char, Term)]
12:34:01 <squire> I'm bothered about the ugly ConstTerm "foo"
12:34:12 <shapr> ?
12:34:34 <squire> I want to delete any tuple whose fst is i
12:34:48 <squire> from s
12:36:09 <shapr> oh, I haven't used deleteBy in awhile
12:36:41 <squire> or am I trying to do a (key,value) mapping type the totally wrong way?
12:37:06 <shapr> I'd use a FiniteMap normally, but if you're just starting to learn Haskell, a list of pairs is fine
12:37:31 <shapr> that's a commonly used structure.
12:37:50 <shapr> and can easily be turned into a variety of other lookup types
12:38:15 <shapr> if you want to delete any tuple whose fst is i, why not use filter?
12:38:37 <squire> hm, that's a good idea
12:38:54 <shapr> a list comprehension would be even shorter.
12:39:41 <shapr> filter (\x -> (fst x) /= i)
12:39:56 * Lor wants some standard data structure infrastructure to emerge.
12:40:16 <Lor> Edison seems to be kind of dead, and ddata isn't very abstract.
12:41:08 <squire> yes, that's great
12:42:08 <shapr> Lor: I think we should volunteer Pseudonym to head such an effort.
12:42:19 <shapr> squire: any other questions?
12:43:56 <squire> shapr: hm, none for now I guess :) thanks
12:44:09 <shapr> ok, ask me if you think of any more
12:44:56 <squire> well, what's a good place to learn to think in a language with a type system?
12:45:10 <shapr> hmm
12:45:36 <shapr> I'd suggest you write a bunch of Haskell code, starting with small but interesting bits
12:45:41 <shapr> and leave off the type signatures as much as possible
12:45:44 <Lor> Some functional pearls give you lots of insight, but they're not quite beginner stuff.
12:46:04 <shapr> first off, Haskell can figure out type sigs 99% of the time
12:46:17 <Philippa> Bugs that screw you over badly: Evaluating a closure in the wrong environment
12:46:18 <Lor> Uh, how does leaving off type signatures help think about them?
12:46:18 <Philippa> d'oh
12:46:31 * Lor would suggest writing down the types _first_ and then writing the functions.
12:46:41 <shapr> second, you'll still have some problems with the system, and that'll show you what's happening behind the scenes
12:47:05 <squire> indeed, I never write type signatures (though I should probably for documentation reasons)
12:47:09 <shapr> Lor: well, my thoughts are a) learn the language without focussing on the type system b) learn the type system
12:47:42 <shapr> one thing that will help (imho) is to come back later and add type signatures to your working code to check your understanding of the working code
12:47:44 <Lor> I don't think that is possible with Haskell.
12:47:49 <Lor> Types are so ingrained into everything.
12:47:53 <squire> the problem is simply that I'm used into thinking in a dynamically typed language, so I have to discover anew how to do a lot of common things
12:47:53 <shapr> hm, it worked for me
12:47:57 <shapr> I came from Python to Haskell.
12:48:37 <Lor> That's why I don't think Haskell is a good first language, btw. Too much to learn before you can concentrate on programming.
12:49:21 <squire> true. Hearing 'monad' alone will scare away a beginning programmer
12:49:30 <shapr> heh, monads are a design pattern
12:49:46 <shapr> monads are just a way to structure your code
12:50:23 <squire> "design pattern": that's a new way to look at it
12:50:34 <shapr> it's true, that's all they are
12:50:34 <Boegel> good evening #haskell
12:50:47 <shapr> monads work in scheme, perl, and ml as well.
12:50:56 <shapr> they may not be quite as pretty in those languages, but they work :-)
12:50:59 <shapr> hoi Boegel 
12:51:14 * Boegel notices he missed an explenation on monads...
12:51:35 <Oeje1> Hello Boegel, wasn't it you who was working on a ray tracer?
12:51:37 <shapr> nah, it just started ;-)
12:51:58 <shapr> Boegel: you want to hear my 'monads are simpler than OOP' talk *again* ??
12:52:24 <Boegel> shapr: sure :)
12:52:29 <Boegel> Oeje1: yes I am
12:52:59 <Boegel> Oeje1: wanna see a render ?
12:53:05 <shapr> I wonder if the regulars here on #haskell are getting tired of my monads explanation...
12:53:18 <monochrom> Not at all.
12:53:24 <Boegel> I haven't heard it, and I'm quite regular, no ?
12:53:33 <shapr> ok then :-)
12:53:37 <monochrom> you're context-sensitive
12:53:40 <shapr> haha
12:53:45 <Oeje1> Boegel: I am just beginning one myself.  I want to visualize it when my connect four brain is playing.
12:54:03 <Oeje1> Boegel: Yes, I'd like to see a render.
12:54:06 <Boegel> Oeje1: what are you planning to implement ?
12:54:09 <monochrom> the moment you prove to be unable to do matching parentheses, you're regular.
12:54:12 <Boegel> Oeje1: http://studwww.ugent.be/~kehoste/thesis/Haskell/test.png
12:54:25 <Boegel> monochrom: UNable ? :s
12:54:34 <monochrom> Yes, unable.
12:54:47 <Boegel> monochrom: I don't get it
12:54:52 <monochrom> regular expressions can't express lisp for example.  Too many parentheses.
12:55:19 <Boegel> oh
12:55:24 <monochrom> Anyway, let's listen to shapr.
12:55:27 <Boegel> Oeje1: how do you like the render ? :)
12:55:31 * Boegel is listening
12:55:45 <shapr> er, I dunno
12:55:45 <Oeje1> Boegel: I want to implement the recursive tracing algorithm with reflection, refraction, textures and shadows.
12:55:56 <shapr> I'm not sure if squire is quite ready to learn about monads...
12:56:03 <shapr> (and I have some homework I should be doing)
12:56:18 <Oeje1> Boegel: It's nice. Just needs the mentioned things ;-)
12:57:06 <Boegel> shapr: nevermind, we'll listen later on then :)
12:59:12 <squire> I think I'm quite ready. I always learn stuff in a random order ;)
12:59:14 <Oeje1> Boegel: Allthough I'm still working to get where you are.
13:01:58 <Boegel> Oeje1: you'll get there, don't worry ;)
13:03:44 <squire> ok see you guys :) thanks for everything
13:07:17 <Oeje1> Boegel:  I'm considering defining each scene object as an instance of a class, Object, with functions: 
13:07:19 <Oeje1> class Object a where
13:07:19 <Oeje1> 	intersections :: Line -> a -> [Double]
13:07:19 <Oeje1> 	normal :: Vector -> a -> Vector
13:07:19 <Oeje1> 	texture :: Vector -> a -> Colour
13:12:28 <Boegel> Oeje1: you'll probably want this:
13:12:57 <Boegel> class Object a where
13:12:57 <Boegel> intersections :: Line -> a -> [Intersection]
13:13:19 <Boegel> where Intersection is a type which contains normal, texture and intersection point
13:14:32 <Oeje1> Boegel:But that would be very inefficient, since I only want one of the intersections, the nearest.
13:17:29 <tromp> g'evening
13:17:35 <Boegel> you only wan't one normal too :)
13:17:51 <Boegel> why do you need the other intersections then ?
13:17:54 <Boegel> you could do
13:18:00 <tromp> is ghc6.2.2 available as .deb yet?
13:18:05 <Boegel> intersection :: Line -> a -> Intersection
13:18:49 <Boegel> and if you want to support other objects besides spheres, your model of only 1 intersection isn't right
13:19:03 <Boegel> a torus can have up to 4 intersection (I think)
13:20:35 <Boegel> s/intersection/intersections
13:20:53 <Oeje1> Boegel: He, the [Double] is a list of distances to where the intersections are.  What I meant was, that you only need one tuple (inters, normal, texture) and not the whole list.
13:21:08 <Boegel> I know :)
13:21:24 <Oeje1> Ah, ok :-)
13:21:50 <dv> gmake[2]: *** [Graphics/UI/ObjectIO/OS/ClCrossCall_12.o] Error 1
13:21:50 <dv> gmake[1]: *** [all] Error 1
13:21:51 <Boegel> but what I mean is that you can return only the closest intersection, with all it's information
13:21:55 <dv> ah god.. after 10 hours...
13:22:14 <Boegel> dv: nice :p
13:23:06 <Oeje1> Boegel: Mmm, I want to return the nearest intersection and from that calculate the normal and so one.
13:25:58 <Boegel> I include the normal and texture into the Intersection type
13:26:01 <Boegel> but that might change
13:27:16 <Oeje1> I want to make a general vector data type: data Vector a = Vector (a, a, a).  And make it an instance of the Num class.
13:27:48 <Boegel> I made something like that
13:28:00 <Boegel> Oeje1: want to see my code ? it needs a cleanup though
13:28:20 <Oeje1> Sure.
13:28:31 <Boegel> Oeje1: maybe you can give me some pointers what parts you don't like... :)
13:28:41 <Oeje1> Sure.
13:28:42 <Boegel> http://studwww.ugent.be/~kehoste/thesis/rayCasting.hs
13:29:02 <Boegel> is that right actually 'final year thesis' ?
13:29:10 <Boegel> how do you say that in correct English ?
13:29:27 <Oeje1> Master thesis?
13:29:47 <Boegel> we'll, technically, I won't be a Master
13:29:59 <Boegel> because they just started with that this year
13:30:14 <Boegel> my title will be 'licentiaat informatica' (in Dutch)
13:30:32 <Boegel> I'm not sure how you translate that into English
13:30:43 <Boegel> ow wait, I have a thesis article lying around here somewhere...
13:31:06 <Oeje1> Mmm, ah like a diploma/bachelor?
13:31:17 <Boegel> Oeje1: yes
13:31:17 <Lor> Hereabouts a licentiate is a postgrad degree between master and doctor.
13:31:29 <Boegel> but Bachelor is only 3 years
13:31:40 <Boegel> mine is 4 (like Master)
13:32:02 <Oeje1> Is a master only four years?
13:32:29 * Boegel is starting to install Fedora Core 3 Test 2 on his desktop... wish me luck :p
13:32:34 <Oeje1> How about: Afgangsprojekt?
13:32:50 <Boegel> that's German I believe :p
13:32:58 <monochrom> Afghan's project? :)
13:33:15 <Oeje1> Sure, you're both right.
13:33:20 <Boegel> ;)
13:41:19 <Oeje1> Boegel: I have some suggestions.
13:44:35 <Oeje1> insersections :: Line -> Sphere -> [Double]
13:44:36 <Oeje1> nearest :: [Double] -> Double
13:44:36 <Oeje1> nearest ts = minimum $ filter (>0) ts
13:46:40 <Oeje1> It seems that the functions are too entangled with each other.  Each function should be as simple as possible and they should combine cleanly.
13:47:19 <Oeje1> I think.
13:50:01 <Boegel> Oeje1: that's very true
13:50:10 <Boegel> that's what I meant with 'cleaning' up
13:50:26 <Boegel> I want to seperate the math and the actual ray tracing as mutch as possible
13:55:10 <Oeje1> Also, maybe use infix notation with vector operations: v `dotProd` w.
13:57:33 <Oeje1> Maybe the objects could be in a tree instead of a list.
13:58:39 <Oeje1> Then a node will be an object spacially containing all children.  Then the leafs will be the real objects.  This will be an optimisation.
14:04:28 <Boegel> Oeje1: optimisation is not the issue now
14:04:31 <Boegel> getting it to work is
14:04:38 <Boegel> the speed isn't the most important thing for me
14:06:23 * Oeje1 is thinking of a Hoare/Knuth quote:  Premature optimisation is the root of all evil
14:08:21 * Oeje1 remembers the benchmark:  Most time spent in createPPM,
14:09:34 <Oeje1> http://c2.com/cgi/wiki?PrematureOptimization
14:15:38 <stepcut> has any installed halipeto, I am a bit confused as to what I do after tar -xvzf ...
14:16:34 <shapr> stepcut: I'm using it for my website.
14:17:00 <shapr> try ghc --make Demo I think
14:18:00 <stepcut> Do I build a new executable for each site? Or is there a useable binary that I use to process different templates for different sites ?
14:18:38 <shapr> new executable
14:18:40 <shapr> at least, for the moment
14:18:43 <stepcut> ok
14:19:09 <shapr> andrew wants to make site organization easier, something where it can be automatically figured out from a directory structure or something
14:19:35 <stepcut> shapr: do you think you will continue to use halipeto for static content ?
14:19:41 <shapr> also, Demo has a bunch of hackish and crufty bits, while halipeto itself is way sexy
14:19:43 * desrt conquers the object splitter
14:20:03 <shapr> I'll continue to use it for template-style webcontent.
14:20:26 <stepcut> ok, I am going to start using it today
14:20:32 <shapr> oh, I think someone has recently mixed halipeto and HaskellDB...
14:20:43 * shapr looks at Lemmih 
14:20:57 <jao> hi. i was trying hemacs on freebsd (5.3b7), butit doesn't seem to work: when i run hemacs-inplace i just get a blank screen (aterm) or a screen with a modeline that doesn't react to any keystroke (xterm)...
14:21:44 <shapr> sounds like you should ask dons when he's awake, or send email to dons
14:22:01 <shapr> he's developing hs-plugins on openbsd
14:22:10 <shapr> sounds like we might need some unit tests too
14:22:11 * Lemmih stares back at shapr.
14:22:17 <jao> shapr, ok, thanks.
14:22:28 * shapr quickly dodges the piercing stare of Lemmih 
14:23:36 * Oeje1 gets hit bye the stare.  Ughpf.  Rolls backwards and lands in the corner.
14:23:48 <shapr> man, that's a powerful stare!
14:24:18 * shapr wonders if this is related to those late-night commercials like the StareMaster.
14:25:03 <Lemmih> Oh no. I have school tomorrow /-:
14:25:14 <shapr> oh no! time to sleep!
14:25:17 <monochrom> who dosn't
14:25:19 <shapr> I have school tomorrow too :-(
14:25:24 <shapr> no late night hacking for me...
14:25:24 <Oeje1> Me too.
14:25:25 <desrt> how do i turn on PIC code generation for ghc?
14:25:31 <monochrom> tomorrow never dies
14:25:32 <shapr> -fPIC maybe?
14:25:35 <desrt> no
14:25:44 <monochrom> die another day
14:25:45 <shapr> -fThaller ?
14:25:51 <monochrom> you only live twice
14:25:53 <desrt> ghc-6.2.2: unrecognised flags: -fThaller
14:25:54 <desrt> :(
14:25:56 <monochrom> diamond is forever!
14:25:58 * shapr snickers
14:26:22 * Oeje1 has parallel systems and languages and parsing tomorrow :-)
14:26:35 <shapr> I have SWEDISH!
14:26:42 <desrt> i just ported a regexp that he wrote :P
14:26:47 <monochrom> hrm that's an ambiguous parse
14:26:49 <desrt> it's clever
14:27:17 <shapr> Buncha strange people in my swedish class... no one as strange as me, thankfully.
14:27:20 <Oeje1> shapr: Uh, den var vrre.  Jeg havde ogs lidt svensk i skolen.
14:27:30 <desrt> actually... i know there is a way to pass arguments to the cc1 and -fPIC to cc1 with -fvia-C would give me PIC
14:27:34 <shapr> men det r inte svenska! det r dansk!
14:27:35 <monochrom> yeah tell them about monads in swedish
14:27:46 <shapr> oh, cool idea
14:28:00 <shapr> Om du anvnder monader i din kod...
14:28:05 <shapr> um "du ville"
14:28:35 <Lemmih> stepcut: I've modified Halipeto to generate dynamic webpages but many of the modifications are kinda hackerish.
14:28:43 <shapr> I tried to explain the economics of open source programming and how cost-free error-free reproduction meant that research was the only cost..
14:28:54 <shapr> But everyone in class ended up being lost except for me.
14:29:11 <stepcut> Lemmih: well, I just want static right now anyway...
14:29:11 <Oeje1> shapr: Vi hatte lita svenska, fordi det r nordiska kultur sprk.
14:29:27 <shapr> Maybe 1) my swedish sucks 2) their swedish sucks 3) their understanding of economics sucks 4) something else entirely.
14:30:00 <shapr> svenska  nordiska kultur sprk??
14:30:05 <desrt> shapr; don't you speak the CHEF dialect of swedish?
14:30:19 <shapr> export LANG=sv_CHEF
14:30:23 <desrt> perhaps this was the problem
14:30:45 <Oeje1> Huh? What dialect is that?
14:30:53 <desrt> Oeje1; bork bork bork!
14:31:55 <Oeje1> He, you mean like boss/management language?
14:33:08 <desrt> http://www.google.com/intl/xx-bork/
14:34:31 <Oeje1> :-)
14:39:32 <shapr> I use xx-hacker
14:39:36 <shapr> my favorite
14:39:43 * Boegel cheers, because he doesn't have _any_ classes tomorrow
14:40:24 <shapr> 4DV4NC3D 534RC|-|      PR3F3R3N(3Z
14:42:29 <Cale> http://www.alltooflat.com/geeky/elgoog/
14:42:52 <shapr> whoa, nifty
14:45:05 <bojohan> ahahah
14:45:10 <Boegel> eheheh
14:45:44 <shapr> hej bojohan 
14:45:48 <shapr> vad hnder?
14:47:44 <bojohan> shouldn't be here, really. exams on thursday.
14:48:58 <shapr> well...
14:49:10 <shapr> I am unwilling to assist you.
14:49:17 * shapr refuses to /kb bojohan 
14:49:31 * desrt went from bork to hax0r to latin
14:49:48 <desrt> it's almost time for a change...
14:49:57 * Boegel doesn't know what wrong with bojohan so shapr won't talk to him...
14:50:00 <shapr> bojohan: hey, if you here doing nothing.. I have a few questions...
14:50:12 <bojohan> right
14:50:26 <bojohan> we call it "tentaflykta"
14:50:28 <shapr> like... what the difference among talstreck, bindestreck, and tankstreck?
14:50:38 <shapr> I'm not really clear on usage and difference with those.
14:51:00 <bojohan> bindestreck is the short one (hyphen)
14:51:04 <shapr> ok
14:51:27 <Boegel> is that swedish ?
14:51:33 <shapr> yup
14:51:37 <Boegel> nice :)
14:51:41 <Oeje1> shapr: Tankstreck is long one, --- in LaTeX.
14:51:44 <Boegel> seems a hard language...
14:51:49 <shapr> I'm learning punctuation in swedish.
14:51:58 <shapr> Nah, swedish is pretty close to dutch and german.
14:52:01 <Boegel> streck = space ?
14:52:10 <Oeje1> shapr: Do you know LaTeX?
14:52:11 <shapr> streck = 'strike'
14:52:13 <Boegel> I speak dutch \o/
14:52:16 <shapr> Oeje1: nope, never met him ;-)
14:52:24 <Oeje1> :-P
14:52:33 <shapr> never got around to learning LaTeX
14:52:34 * Boegel meets him every day
14:52:36 <shapr> maybe one day
14:52:50 <Boegel> shapr: it's chaos if you ask me
14:53:42 <Oeje1> Tal: 2--3, tank: Hello --- what's ..., binde: abe-kat.
14:53:42 <shapr> bojohan: how do I use talstreck and tankstreck? I don't really get it.
14:53:44 * Boegel is almost done installing Fedora Core 3 Test 2, and is excited to try Linux once more
14:54:11 <cm> \newcommand\shapr[0]{\tt shapr}
14:54:39 <desrt> \tex{evil}
14:54:48 <tuomov> I think you don't usually use --- in europe, it's an american convention
14:55:03 <tuomov> but I'm not sure
14:55:05 <shapr> It's rarely used in the US.
14:55:10 <kosmikus> I think tuomov is right
14:55:18 <Oeje1> tuomov: We use it in Danish.
14:55:44 <desrt> is --- supposed to be like emdash?
14:55:49 <tuomov> yes
14:55:55 <kosmikus> and \newcommand\shapr{\texttt{shapr}} is better ;)
14:56:00 <desrt> --- is reasonably common in english
14:56:07 <shapr> I get the impression that tankstreck is halfway between commas and parens, and that it's some way to 'escape' an aside or bit of info that's not directly related
14:56:18 <tuomov> and --- is usually written without spaces around it, while -- is surrounded by spaces
14:56:27 <desrt> hmm
14:56:33 <shapr> I saw kosmikus -- Andres -- out the window.
14:56:35 <tuomov> shouldn't that be tnkstreck or something?
14:56:44 <tuomov> then it would correspond to finnish "ajatusviiva"
14:56:49 <tuomov> (thinking strike)
14:56:51 <desrt> emdash is a lot like parens except that you put emphasis on the contents instead of sort of marking them 'optional'
14:56:55 <shapr> in my book it's tankstreck with no dots
14:57:14 <juhp> "empty buffer" :)
14:57:23 <desrt> like, emdash is a common - and important - entity in the english language
14:57:36 <desrt> er.  that was sort of a bad example
14:57:43 <shapr> I'd use commas there.
14:57:46 <shapr> or parens.
14:57:53 <shapr> but never those weird dashes :-)
14:57:55 <desrt> i'd probably use commas there too
14:58:03 <desrt> lemme find something i've recently written
14:58:27 <desrt> Knuth's most noteworthy books  and indeed, the books that he, himself considers to be his most important life accomplishment  are the volumes of The Art of Computer Programming. 
14:58:42 <shapr> I've seen - used at the beginning of a sentence where each - started the other person talking
14:58:54 <desrt> An example of such an algorithm is the Knuth-Morris-Pratt string matching algorithm which  in the worst case  runs in O(n) time
14:58:55 <Oeje1> I think "---" is used a lot like a comma, only with a longer pause.
14:58:56 <kosmikus> desrt: I still think emdash originates from american english ... nowadays, many people are writing books without having knowledge of typography, so you can't really tell anymore ...
14:58:57 <bojohan> that's talstreck
14:58:58 <desrt> Knuth also possesses many personality quirks that  in addition to his many accomplishments  make him a truly interesting person.
14:59:02 <shapr> -Oh really? -That's what he said -Are you sure?
14:59:02 <desrt> stuff like this :P
14:59:22 <desrt> kosmikus; you may be right
14:59:32 <bojohan> talstreck 'speech strike'
14:59:50 <tuomov> in europe " -- " is afaik preferred over "---"
15:00:02 <tuomov> (note the spaces)
15:00:13 <kosmikus> I agree with tuomov
15:00:14 <bojohan> --Foo, she said.
15:00:14 <bojohan> --Bar, he replied.
15:00:18 <desrt> sort of ironic that i end up quoting a paper on knuth talking about the use of emdashes in tex documents...
15:00:29 <shapr> Ok, so tankstreck is the comma/parens weird thing, talstreck is for conversations, and bindestreck is just hyphen.
15:00:33 <kosmikus> at least, don't use " --- "
15:00:52 <monochrom> --- is like parentheses
15:01:05 <shapr> oh one more question, if / is snedstreck, what's \ ?
15:01:15 <tuomov> so's " -- ". Between " -- " and "---" is a matter of style.
15:01:16 <bojohan> backslash
15:01:18 <bojohan> :)
15:01:22 <shapr> are you serious?
15:01:24 <tuomov> the meaning is the same
15:01:36 <shapr> None of my several swedish teachers knew the name of a 'back snedstreck'
15:01:38 <Oeje1> shapr: What does the Swedish retstavningsboka say?
15:01:44 <bojohan> "bakstreck"
15:01:50 <shapr> Oeje1: good question, I should grab one.
15:01:50 <tuomov> baktlutande snedstreck
15:01:58 <tuomov> that's what my dictionary says..
15:02:02 <shapr> hm, nifty
15:02:15 * shapr looks up utande
15:02:15 <tuomov> oh. there's also bakstreck elsewhere
15:02:24 <bojohan> http://www.nada.kth.se/dataterm/rek.html#a12
15:03:15 <bojohan> lutande = "leaning, sloping"
15:03:32 <shapr> ah, thanks
15:03:56 <bojohan> luta + ande
15:04:19 <shapr> leaning spirit?
15:04:34 <shapr> that's pretty cool.
15:04:38 <bojohan> no
15:04:56 <bojohan> sw. -ande/-ende = en. -ing
15:04:59 <shapr> oh, lean + ing
15:05:01 <shapr> doh
15:05:18 <shapr> lutaande would be leaning spirit?
15:05:35 <Boegel> shapr: didn't you have a class tomorrow ? :p
15:05:42 <shapr> Boegel: yes?
15:05:43 <bojohan> wth is that?!
15:05:54 <Boegel> what's the time where you are now ?
15:06:01 <Boegel> it's 00:10 here
15:06:03 <bojohan> `_' = understreck
15:06:10 <shapr> But my teachers often get confused when I ask bizarre questions, so it's nice to get them answered here.
15:06:18 <bojohan> o_O
15:06:23 <Boegel> shapr: :o)
15:06:29 <shapr> bojohan: I don't know what a leaning spirit is, but I'd like to know how it would be spelled.
15:06:50 <bojohan> "lutande ande"
15:06:52 * Boegel is rebooting his Fedora system now !
15:06:57 <shapr> On thursday I asked if gngga is a group 1 verb and my teacher handled it pretty well.
15:07:42 <shapr> I love those whacked looking verbs with two consonants at the front like gngga, fnissa, etc.
15:07:43 * Oeje1 gngger p danska.
15:08:13 * Boegel sees only a black screen, and doesn't like that :(
15:08:27 <shapr> Boegel: how can you see IRC on that black screen??
15:08:37 <Boegel> I'm on IRC on my laptop :)
15:08:40 <shapr> anyway, thanks for your swedish help guys :-)
15:08:46 <Boegel> Fedora is on my desktop
15:09:16 * Boegel isn't liking linux quite at the moment :@
15:09:20 <bojohan> what's weird with two consonants?
15:09:30 <monochrom> there is also the blue screen.
15:09:46 <shapr> bojohan: it's weird in english, things like "gnu" are very strange words in english.
15:10:06 <Boegel> it says initialising hardware, and then the screen goes black, and just stops
15:10:07 <bojohan> so you're referring specifically to consonant+n
15:10:16 <shapr> hm, maybe
15:10:27 * Boegel curses his graphics card
15:11:15 <Boegel> Fedora probably doesn't support my graphics card
15:11:16 <shapr> Boegel: should be able to boot text-mode maybe?
15:11:24 <Boegel> I don't know how :)
15:11:26 <shapr> you have a pretty strange graphics card, iirc
15:11:36 * shapr googles for a list of swedish verbs
15:11:44 <Oeje1> Good night good folks of #haskell.  Sova jtta bra.
15:11:46 <Boegel> Hercules 3D Prophet 4000XT
15:11:54 <Boegel> good night Oeje1 !
15:12:29 * Boegel takes out Mandrake 9.0 which he has lying around
15:12:31 <shapr> g'night Oeje1 
15:12:33 <shapr> whoops
15:12:50 <Boegel> hehe
15:14:13 * shapr apt-gets iswedish wswedish and dict-freedict-{swe,eng}-{swe,eng}
15:15:46 <Boegel> shapr: which distro should you advise me (besides Debian, because that's driver hell)
15:16:13 <Boegel> s/should/would
15:17:25 <shapr> From what I remember from the last time I searched around for the Hercules drivers, it's not very well supported by Linux the kernel.
15:17:56 <shapr> I think the easiest solution is to buy a really cheap nvidia card and use the binary drivers.
15:18:13 <shapr> I suspect you'll be able to use just about any distro then.
15:18:56 <shapr> Boegel: sadly, there aren't any good open source graphics drivers at all.
15:19:48 <shapr> that's mostly because the companies believe that if they give out the hardware specs, they lose their investement, because then anyone can clone it.
15:19:54 <Boegel> shapr: I'm planning to buy a new system next year
15:20:16 <Boegel> I'll pay attention on driver support when I buy a new one, so any distro is fine for me now :)
15:20:36 <phubuh> typographically, the em dash & quotation dash are separate :-)
15:20:38 <bojohan> [#emacs]: <caphuso> if you're polymorphed in a monster, you don't die, you return to your normal form :-)
15:21:18 <shapr> I can only hope that nvidia and/or ati will understand that they should aim for an efficient parallel coprocessor based on their current GPU designs.
15:21:31 <mento> (whoever got haskell exam tomorrow can tell the prof. he can screw himself)
15:21:33 <shapr> otherwise, nvidia and ati will die when multi-core CPUs become available.
15:21:39 <shapr> mento: eh?
15:21:44 <kosmikus> bojohan: that's true
15:22:18 <mento> (I still cant comprehend all the things cons can do :( )
15:22:34 <mento> I find it very disscuraging
15:22:36 <phubuh> i use an em dash where using a comma would make the sentence sound run-on-ish
15:22:44 <shapr> mento: cons? the guy that builds a list?
15:22:49 <mento> yea that mf
15:23:08 <shapr> what can he do other than build a list?
15:23:09 <phubuh> only where a period isn't appropriate, of course
15:23:10 <mento> nm I go back to the book
15:23:16 * shapr is confused
15:23:25 * Boegel is confused with shapr
15:24:12 <phubuh> i also use it for emphasized parentheses, but that was mentioned already :-)
15:24:17 * isomer hands shapr an ephemeron, to further confuse things
15:24:29 * phubuh wields an interrobang
15:25:12 <shapr> actually an ephemeron seems to be something to do with floating point code
15:26:14 <isomer> garbage collection...
15:26:17 <shapr> oh
15:26:24 <shapr> you're squeaking lately?
15:27:58 <isomer> nope...visualworks. but i suppose it's a minor distinction. how about you? what have you been up to?
15:29:19 <shapr> hemacs
15:29:37 <shapr> the stone soup editor...
15:30:23 <isomer> sounds tasty
15:32:06 <shapr> it's a lot of fun
15:32:55 <shapr> isomer: ever tried to write your own editor?
15:33:35 <bojohan> as an emacs user, i write my own editor every day
15:33:47 <shapr> emacs isn't multithreaded
15:34:05 <kosmikus> what's the goal of hemacs? and why did you choose a name that's taken?
15:34:17 <shapr> kosmikus: actually, igloo came up with a better name...
15:34:23 <shapr> "U+1D321 TETRAGRAM FOR CHANGE"
15:34:46 <bojohan> hemacs -- master of the gnuniverse
15:34:57 <stepcut> bojohan: haha
15:35:01 <shapr> it was suggested that hemacs is a) taken and b) not very descriptive (since it'll also be hvim and hjoe/hjed)
15:35:15 <shapr> so I suggested that we name it after a single rarely used unicode character
15:35:43 <shapr> I really like naming an editor after a symbol of change, I think that's very fitting.
15:36:29 <kosmikus> hmm, it's not something that's easy to remember though
15:36:35 <shapr> kosmikus: as for goals? I set up the post-emacs list because emacs is my favorite editor and I still can't stand to use it on a regular basis.
15:36:57 <bojohan> you set up a list?
15:37:01 <shapr> sure
15:37:03 <isomer> shapr: nope. it sounds like a fun thing to do though
15:37:08 <kosmikus> how ambitious are you? you obviously have started coding already, so you agree on a design?
15:37:30 <shapr> kosmikus: I'm hoping for the IETF model - "rough consensus, running code"
15:37:54 <isomer> smart
15:38:12 <isomer> "bug reports welcome...patches even more so"
15:38:28 <shapr> right, flames sent to /dev/null
15:39:26 <shapr> kosmikus: I am not ambitious, I'm just impatient to get it working enough that I can switch from xemacs to the editor formerly known as hemacs.
15:40:14 <shapr> I've written a surprising amount of elisp, and I don't really like the elisp language. I really *do* like Haskell.
15:41:00 <kosmikus> ok
15:41:16 <shapr> kosmikus: so, if you have time, grab the code, see what you think
15:41:34 <kosmikus> actually, I did grab the code, but didn't look at it yet
15:41:50 <shapr> bojohan: you want the post-emacs list address? it's also gmane.org.editors.post-emacs if that helpse.
15:43:00 <bojohan> oki
15:43:05 <kosmikus> shapr: will there be a HCAR article on U+1D321?
15:43:21 <bojohan> i *do* like elisp
15:43:48 <kosmikus> bojohan: even if you could write your extensions in Haskell instead?
15:43:49 * Igloo was really suggesting it for amusement value - I don't htink it's a very practical name. Logo maybe.
15:43:53 <shapr> bojohan: do you like multi-threading?
15:44:48 * kosmikus was suggesting Dunkosmiloolump for amusement value as well ... sometimes these suggestions survive longer than you think
15:44:51 <shapr> My major problem with Haskell as a scripting language before this week was that it's just not as interactive as elisp.
15:45:05 <shapr> kosmikus: actually, that's a great team name :-)
15:45:24 <shapr> dons latest version of hs-plugins is interactive enough now.
15:45:32 <bojohan> is it dynamic enough?
15:45:41 <phubuh> bojohan: do you like lexical scoping? :-P
15:45:48 <shapr> yes, it's dynamic enough.
15:45:59 <bojohan> phubuh: that's being worked on
15:46:18 <bojohan> i'm thinking about the type system
15:46:57 <bojohan> like you have a function that can take a buffer or a buffer-name (a string)
15:47:31 <shapr> ?
15:48:03 <bojohan> many functions in emacs take arguments of several different types
15:48:33 <bojohan> have you implemented defadvice yet?
15:48:35 <shapr> whackBuffer :: (Buffer a) => a -> IO a
15:48:38 <kosmikus> you can have overloading in Haskell, of course
15:49:03 <Igloo> kosmikus: That was a short-term thing that you don't have to be able to enter quickly in an xterm, though  :-)
15:49:04 <kosmikus> otoh, I'd say that some of these functions in emacs are probably bad design and should be separate functions
15:49:22 * Boegel is installing Mandrake 9.1 now, and hopes it works with his graphics card
15:49:29 <kosmikus> Igloo: true
15:49:39 <shapr> bojohan: no, we started on wednesday. We're still working on a decent buffer =)
15:49:50 <kosmikus> then again, who's using xterms? just have an icon and click on it ;)
15:49:54 <Igloo> And also, one that /can/ be entered by most people when they need to...
15:49:58 <Igloo> :-)
15:50:12 <bojohan> redefining functions during runtime is useful
15:50:19 <shapr> that's what hs-plugins does
15:50:39 <shapr> hs-plugins dynamically loads the whole app on top of a tiny static core.
15:51:01 <shapr> look at Boot.hs in U+1D321
15:52:56 <Boegel> there's a new Mandrake version, but I can't find a link to download it... isn't it at mandrake.org ?
15:53:22 * shapr assumes so
15:54:18 <desrt> so.. it has come to my attention that HEAD can die
15:54:30 <kosmikus> shapr: who's actively developing U+1D321? dons, tuomov, shapr, Igloo, ...?
15:54:46 * stepcut is beta testing
15:54:48 * Igloo hasn't even looked at the code yet
15:54:55 <desrt> 
15:55:15 <shapr> kosmikus: at least dons, tuomov, shapr. Not sure about anyone else.
15:55:36 <shapr> Anyone who wants to join in :-)
15:55:42 <Igloo> But I might look in the future, especially if someone packages any dependencies it has for Debian  :-)
15:56:29 <desrt> it seems like my irc client is incapable of encoding upper-block unicode :(
15:56:50 <stepcut> :p
15:57:18 <kosmikus> what dependencies are there besides hs-plugins? ncurses, I assume, but anything else?
15:57:29 <shapr> not that I can think of...
15:58:02 <tuomov> libiconv on obsd
15:58:22 <tuomov> although I don't know if U+1D321 depends on it anymore
15:58:32 <stepcut> shapr: have you improved that RSS stuff I sent you at all ? (Because I am about to do some more work on it and I don't wish to duplicate efforts)
15:59:09 <shapr> no, I haven't... but I do think bringert and Pete Gammie have worked on some RSS code.
15:59:16 <stepcut> will U+1D321 actually have good unicode support from the start ?
15:59:32 <stepcut> ok
15:59:35 <tuomov> it shouldn't be too difficult to include it
15:59:54 <shapr> ah, the RSS.hs in blob says "Jeremy Shaw"
16:00:02 <stepcut> heh
16:00:21 * stepcut goes to make soup first
16:00:53 <tuomov> (not too difficult in linux, that is. openlsd is a totally different issue.)
16:01:20 <kosmikus> SyntaxNinja: ping
16:02:20 <Igloo> Anyone know where I can get a GADT program?
16:02:33 <kosmikus> write one?
16:02:38 <Boegel> does anybody know if the current linux kernel supports a Intel 82852/82855 GM/GME Graphics Controller (the one in my laptop)
16:02:40 <desrt> ghc 6.4?
16:03:19 <desrt> Igloo; it supports GADT.  not sure really what that is or if that's what you really want
16:07:52 <Igloo> OK, ghc-cvs in haskell-unsafe probably supports GADTs
16:12:04 <shrimpx> so the way haskell does gadts is with explicit type annotations?
16:12:04 <kosmikus> Igloo: were you looking for an example program or for a compilter that supports GADTs?
16:12:14 <shrimpx> s/haskell/ghc/
16:12:35 <Igloo> example program
16:12:51 <kosmikus> I think there are tests in the CVS
16:13:02 <Igloo> Oh, good point
16:13:07 <shrimpx> spj's announcement email has a good one
16:13:38 <shrimpx> http://research.microsoft.com/~simonpj/tmp/gadt.html
16:13:41 <kosmikus> shrimpx: I guess if you can explain to spj how he can do GADTs without explicit type annotations, he'd do it ;)
16:13:54 <shapr> g'day Pseudonym 
16:13:57 <Pseudonym> G'day.
16:14:02 <Igloo> Well, the tests mostly passed, so I assume it really does support them  :-)
16:14:03 <Pseudonym> I guess one way of doing it is like this:
16:14:19 <Pseudonym> data State a = Store a :: State ()
16:14:29 <kosmikus> Igloo: yes, I ran a few tests on my own :) seems to work
16:14:31 <Pseudonym>             | Fetch
16:14:33 <Pseudonym> Say.
16:14:43 <Pseudonym> You put a :: return-type on the end.
16:14:55 <Pseudonym> On only those constructors where it's needed.
16:15:06 <Igloo> Oh, I'm sure it can be made to work, I just wasn't sure if I'd not done some necessary thing  :-)
16:15:13 <shrimpx> kosmikus: i think tim sheard's omega uses some different syntax in data declarations... spj's just does it with explicit type annotations on constructors, afaict
16:15:27 <Pseudonym> Like most Haskell language extensions, syntax is the biggest problem.
16:18:39 <shrimpx> k now i wanna play with this
16:19:33 <SyntaxNinja> kosmikus: y0
16:20:50 <kosmikus> SyntaxNinja: I've only recently started playing a bit with cabal
16:21:12 <kosmikus> SyntaxNinja: ... and I have a remark, but you might be well aware of it by now
16:22:18 <kosmikus> register/unregister is suboptimal, because it essentially requires you to keep the *entire* source distribution around if you want to re-register or unregister a package
16:22:42 <kosmikus> that is because you don't know which other files Setup depends on, and in which directories they must be etc.
16:23:24 <Igloo> Maybe install should also copy whatever is necessary somewhere sensible?
16:23:29 <SyntaxNinja> what do you mean 'which files setup depends on'?
16:23:56 <kosmikus> Igloo: that's what I was thinking about
16:24:01 <SyntaxNinja> oh, I think I see what you mean... 
16:24:14 <kosmikus> have something like /usr/share/cabal/package-name where Setup plus dependencies gets copied to
16:24:22 <SyntaxNinja> well, for unregister, hopefully, HC-PKG will be the way most people unregister
16:24:44 <Igloo> They will call setup rather than HC-PKG directly though, right?
16:24:48 <kosmikus> SyntaxNinja: which still forces you to remember which packages a package has installed
16:25:03 <kosmikus> it's better to call setup, because that's guaranteed to remove *all* packages
16:25:09 <Pseudonym> BTW, GADTs + higher ranked types == lots of fun.
16:25:12 * SyntaxNinja nods
16:26:00 <SyntaxNinja> for Simple tools, all the system needs is Setup.lhs and the package description file
16:26:13 <SyntaxNinja> and probably the local configuration info. Setup won't have any dependencies
16:26:25 <SyntaxNinja> so install could copy those three files into a logical place.
16:26:32 <kosmikus> yes
16:27:04 <SyntaxNinja> and we'd need to add a rule that says you must make it easy to unregister a file if you roll your own Setup install
16:27:46 <shrimpx> are there instructions on building ghc cvs somewhere?
16:28:37 <SyntaxNinja> A better idea actually might be to have hc-pkg remember all the haskell-packages it has installed, and be able to unregister them all in one go
16:29:07 <kosmikus> SyntaxNinja: yes, functionality could probably be moved over there
16:29:13 <kosmikus> but unregistering is not the only problem
16:29:37 * SyntaxNinja waits in eager anticipation
16:30:40 <kosmikus> in Gentoo, I cannot touch the live filesystem during package installation, only during post-installation
16:31:06 <kosmikus> I guess Debian might have similar issues, because the live filesystem isn't even available during build time there
16:31:37 <Igloo> That's why install and register are separat
16:31:49 <kosmikus> that means, I have to call register during post-installation, but by then the source distribution is no longer available, only the installed files
16:32:05 <kosmikus> right, being separate is already good
16:32:22 <Igloo> Right, so you need to install whatever is necessary to (un)register
16:32:45 <kosmikus> yes, I need to install Setup.lhs plus the two other files manually atm
16:32:58 <kosmikus> to call register during post-installation and unregister during pre-removal
16:33:03 <SyntaxNinja> right now, it just uses ghc-pkg directly to register
16:33:08 <SyntaxNinja> well, all the packages I know of anyway
16:33:23 <Igloo> kosmikus: Isn't that the problem we just solved?
16:33:35 <SyntaxNinja> during build, it dumps the package file for GHC to use, and then postinst registers it and postrm (?) unregisters it
16:33:53 <kosmikus> yes, I just point out that its not only important for *un*registering packages, but already for registering them
16:34:00 <Igloo> Ah, right, OK
16:34:02 <SyntaxNinja> right
16:34:20 <SyntaxNinja> fwiw, I will happily accept patches to fix that, and I've put it in the TODO
16:34:31 <SyntaxNinja> it shouldn't be too hard, though the details will be somewhat platform specific
16:34:43 <SyntaxNinja> probably want a new configure flag for where to dump those files to
16:35:15 <kosmikus> I think cabal itself should specify a place where cabal-specific metadata goes
16:35:27 <SyntaxNinja> a default place, sure, but that should be over-ridable, no?
16:35:34 <kosmikus> this might be configurable once during the setup of cabal on a system, but not per package
16:35:34 <Igloo> Wouldn't it make sense to put them in the same place as the .hi files etc?
16:35:36 <SyntaxNinja> cabal itself will never look for those files again
16:36:06 <SyntaxNinja> something riding above cabal might care where they are, but why should cabal care?
16:36:18 <kosmikus> you may be right
16:41:01 <SyntaxNinja> so all we need is 1) a new flag for configure (perhaps over-ridable by install, just like --prefix) 2) install moves the necessary files into place
16:41:16 <SyntaxNinja> 3) policy in the proposal to explain what needs to go there (enough to {un}register but nothing more?)
16:41:38 <SyntaxNinja> and by 2) I mean code in Distribution.Simple.Install
16:43:45 <SyntaxNinja> and it might be good to think about what kind of role HC-PKG could play here
16:44:32 <kosmikus> sounds good
16:45:59 <Igloo> I think normal people shouldn't have to know HC-PKG exists
16:46:16 <Igloo> Well, except to ask it questions like "what packages are installed?"
16:46:30 <SyntaxNinja> hmm. really, maybe it would be best to do exactly what we're doing now w/ ghc-pkg
16:46:39 <Pseudonym> I'm not so sure of that.  Normal Perl users are usually aware of CPAN, for example.
16:46:59 <SyntaxNinja> well, it's a bit more natural to dump a package file and use HC-PKG to register/unregister than to copy Setup.lhs, Setup.description, etc
16:48:02 <Igloo> But the point of setup is to provide an abstraction that works on any package
16:48:17 <kosmikus> as long as all packages provide a uniform interface, I don't see any problem if the register/unregister step happens via hc-pkg instead of Setup
16:49:08 <kosmikus> ./Setup register can still call "hc-pkg register <pkg-name>" as long as it is available, and if it is guaranteed that it never does anything else
16:50:35 <Igloo> But what if you /do/ need to do something else? That's why setup is preferable to hc-pkg
16:50:39 <r3tex> is haskell hard to learn if i know erlang?
16:50:51 <Boegel> does anyone know how I can easily change the language in Mandrake 9.1 using GNOME ?
16:51:07 <Pseudonym> r3tex: The type system might throw you a little, but I think you'll get the idea.
16:51:43 <Boegel> nevermind: localedrake
16:52:33 <SyntaxNinja> Igloo: hm yeah...
16:52:40 <bojohan> r3tex: hello, neighbor! :)
16:52:44 <shapr> r3tex: jump in, the water's fine!
16:53:03 <SyntaxNinja> it's funny how this channel becomes general open-source helpline; I think it has to do with how friendly it is :)
16:53:26 <Pseudonym> SyntaxNinja: You suck.
16:53:29 <shapr> I was asking for Swedish homework assistance earlier, and I got a bunch of that too :-)
16:53:31 <Boegel> SyntaxNinja: on other channels you would get kicked :p
16:53:37 <Igloo> And we haven't even gratuitously advocated Debian yet tonight  :-)
16:53:50 <Pseudonym> Windows r00lz!!!!1!!
16:53:50 <bojohan> #emacs is very, very friendly
16:54:11 <shapr> bojohan: as long as jordanb is asleep...
16:54:14 <Igloo> bojohan: Oh, you want the-editor-forma...  :-)
16:54:14 <SyntaxNinja> bojohan: that's probably because it's another channel where shapr is known to hang out
16:54:17 <shapr> or in one of his serial bans
16:54:30 <r3tex> Pseudonym: ok =)
16:54:34 <SyntaxNinja> Pseudonym: meh
16:54:47 <bojohan> he's not unfriendly, just annoying
16:55:18 <r3tex> i was just wondering cause i've been studying erlang and now i have a course in haskell but i dont have time for the lectures too and was wondering if it's too hard to learn it by my self
16:55:47 <bojohan> exam next week?
16:55:58 <kosmikus> Igloo: I see the point, lhs2TeX, if ever cabal-ized, would probably want to run mktexlsr in the "register" phase
16:56:12 <r3tex> bojohan: exam this week =P
16:56:19 <Pseudonym> r3tex: Do you know what will be covered when in the lectures?
16:56:26 <r3tex> Pseudonym: yeah
16:56:33 <Pseudonym> It might be worth picking and choosing which lectures you go to, if you can.
16:56:38 <r3tex> Pseudonym: they have it on the course websites
16:56:41 <Pseudonym> Right.
16:56:50 <bojohan> right, it's past midnight :)
16:56:53 <shapr> Is John Hughes teaching you Haskell?
16:56:57 <shapr> g'night bojohan 
16:57:03 <r3tex> shapr: yeah =P
16:57:04 <shapr> I gotta sleep too, school in the morning.
16:57:10 <shapr> r3tex: and you're skipping out??
16:57:15 <r3tex> what =)
16:57:18 <bojohan> you *should* go to the lectures
16:57:18 <r3tex> is he extra cool
16:57:24 <r3tex> he
16:57:25 <bojohan> so they say
16:57:28 <shapr> yes John Hughes is very much extra-cool.
16:57:30 <r3tex> erhmm..
16:57:40 <r3tex> what is the advantage of haskell over erlang?
16:57:50 <r3tex> erlang is backed up by ericsson =P
16:57:56 <Pseudonym> Haskell is pure.
16:58:04 <r3tex> oh, well then...
16:58:08 <r3tex> ;P
16:58:09 <shapr> Haskell has nifty static typing.
16:58:10 <kosmikus> john hughes is a good teacher, from what I can tell; plus, he is someone who definitely knows a lot about Haskell
16:58:19 <desrt> is there a way to completely rebuild stage2 in ghc?
16:58:27 <Pseudonym> A lot of Erlang programmers have been asking for some kind of type system, actually.
16:58:28 <shapr> John Hughes gave a talk on arrows at EuroHaskell.
16:58:33 <r3tex> oh
16:58:34 <desrt> i just did make clean; make in libraries/
16:58:34 <Pseudonym> static type system
16:58:35 <bojohan> shapr: hey, you on #chalmers?!
16:58:39 <shapr> bojohan: what??
16:58:51 <shapr> bojohan: are you looking over my shoulder?
16:58:59 <r3tex> bojohan: me noo =)
16:59:31 <bojohan> guess i should be...
16:59:51 <shapr> EuroHaskell 2005 dates are pretty close to set.
17:00:10 <r3tex> sa many languages so little time
17:00:13 <SyntaxNinja> Pseudonym: good example
17:00:24 <SyntaxNinja> (re hs2latex)
17:00:26 <r3tex> Java, lisp and Perl are on my list .....
17:00:27 <r3tex> crap
17:00:28 <Igloo> desrt: stage 2 only applies to ghc/compiler
17:00:36 <shapr> r3tex: John Hughes is good...
17:00:38 <Pseudonym> SyntaxNinja: Did I mention hs2latex?
17:00:45 <bojohan> lisp!
17:00:46 <desrt> Igloo; right.  so will make clean in ghc/compiler/stage2 work?
17:00:50 * Pseudonym didn't even know abot it
17:00:52 <shapr> epigram!
17:00:53 <shapr> Joy!
17:00:55 <SyntaxNinja> sorry, kosmikus
17:00:58 <shapr> arrows!
17:00:58 <SyntaxNinja> kosmikus: Igloo: I see the point, lhs2TeX, if ever cabal-ized, would probably want to run mktexlsr in the "register" phase
17:00:58 <thebug> Clean?
17:01:07 <bojohan> scratch java, though :/
17:01:13 <Igloo> Not sure. You might just be able to blow it away - it's automatically created IIRC
17:01:15 <SyntaxNinja> whatever, lhs2Tex, kosmkus, bah
17:01:49 <kosmikus> SyntaxNinja: ?
17:02:11 <r3tex> bojohan: oh yeah how about .net right ;) jk
17:02:16 * SyntaxNinja was being inaccurate by messing up the name of the package, and the person who came up with the example
17:02:25 * bojohan barfs
17:03:20 <kosmikus> ah, ok
17:03:36 <r3tex> heh
17:04:29 <shapr> iaf... jag mste sova...
17:04:34 <shapr> svenska skolan i morgon
17:05:47 <desrt> Igloo; hm
17:05:57 * desrt backs up the build directory first =)
17:06:16 <r3tex> japp cs
17:06:19 <jadrian> hello
17:06:46 * shapr falls over asleep
17:06:56 * desrt gets shae a pillow
17:07:05 <desrt> or would you rather some meth?
17:07:08 * jadrian shakes shapr  
17:07:08 <r3tex> im am Greato Teacher Onizuka!!!
17:07:41 <jadrian> are there strict tuples available?
17:07:41 <r3tex> desrt: meth is baaad bizoniz
17:07:51 <jadrian> I know I can do my own...
17:08:45 <jadrian> but they'll look ugly, and I'd rather use 'std' ones if available...
17:08:54 <Boegel> shapr: why don't you go to sleep :p
17:10:23 * jadrian assumes there are no strict tuples available :(
18:01:31 <dons> moin!
18:16:48 <jadrian> hi
18:20:08 <SyntaxNinja> hi
18:21:34 <jadrian> hi SyntaxNinja 
18:22:23 <jadrian> Is there some standard (or ghc) datatype that is like a cross between Maybe and Either
18:22:27 <jadrian> in the sense that
18:22:47 <jadrian> it as two parameterized fields like either
18:23:00 <jadrian> s/as/has
18:23:14 <jadrian> but it is an instance of Monad
18:23:24 <jadrian> and MonadPlus
18:23:37 <jadrian> with the 2nd field denoting failure possibilities...
18:23:55 <jadrian> ...
18:24:03 <monochrom> I think you can easily turn Either a b into Monad a, say.
18:25:50 <monochrom> return x = Left x
18:26:10 <jadrian> hmmm
18:26:44 <dons> maybe you want the Error type
18:27:11 <monochrom> @info Error
18:27:32 <dons> @info Control.Monad.Error
18:28:07 <jadrian> monochrom: how would you type the instance declaration header?
18:28:24 <jadrian> monochrom: instance Monad Either where ?
18:28:47 <monochrom> Ah, I don't know. :)
18:30:50 <jadrian> eh never mind
18:31:19 <jadrian> it's easy to do with Either yes...
18:31:34 <jadrian> the question is, does it exist?
18:31:46 <jadrian> dons: hmm I don't think that's what I want
18:32:05 <jadrian> but let me check again
18:32:57 <Igloo> It would be  instance Monad (Either a) where  and return would have to be Right
18:33:11 <jadrian> Igloo: yeap I just got that :)
18:33:38 <jadrian> Igloo: I was just wondering if it already existed
18:33:43 <jadrian> I keep reinventing the wheel
18:33:59 <jadrian> the latest were the mapAccum functions
18:35:50 <jadrian> brb
18:41:39 <dons> where's that coffee gone?
18:42:34 <dons> ah ha!
18:52:11 <Igloo> Right, haskell-unsafe now has debs of ghc 6.2.2, plus copies of all the compilers with a file of variables, plus a haskell-utils with a program to manipulate them, plus hat that uses it all
18:55:47 <SyntaxNinja> sweet
18:55:54 <SyntaxNinja> you rule, Igloo
18:56:43 * Igloo will have completed today's todo list in a minute, when I send one final mail  :-)
18:58:54 <cm> i should start making myself daily todo lists
18:59:38 <Igloo> I didn't actually make a physical list. Hell, if I'd done that I'd never have had time to do everything on it too  :-)
19:00:02 <Igloo> SyntaxNinja: You don't seem to have CCed John Peterson
19:00:24 <cm> :)
19:00:29 <Igloo> (on your Haskell Libraries Wishlist mail)
19:04:27 <SyntaxNinja> hm. how strange... the sent-mail looks like I CC'd him, but the list doesn't
19:54:15 <desrt> who is root on glass?
20:12:33 <SyntaxNinja> I saw a guy at a conference a few weeks ago whose name was "Grant Root"
20:12:43 <SyntaxNinja> at least that's what his nametag said
20:13:51 <dons> root:*:0:0:Charlie &,,,:/root:/bin/sh
20:14:54 <dons> oh, but glass is a linux machine... so it isn't Charlie Root
20:48:43 <desrt> heh
20:48:55 <desrt> Login: root                             Name: root
20:49:47 <desrt> i'm getting mail from "desrt@haskell.org" because i have no fullname
20:49:56 <desrt> and i can't chfn because i have no password :)
20:52:22 <desrt> (and i tried sending mail to desrt@haskell.org and i didn't receive it and it didn't send a bounce back... which is interesting) :)
20:52:48 <dons> hmm. mine bounces these days
20:53:12 <dons> hemacs can display multiple buffers :)
20:55:08 <desrt> i get the impression that i am going to be trying hemacs very soon
20:55:34 <dons> give me a couple more days to get *editing* working :)
20:55:38 <desrt> hahah
20:56:06 <dons> it's just a pager atm -- with no scrolling ;)
20:58:02 <dons> darcs whatsnew -s is my new favourite command
20:58:29 <Pseudonym> rm -rf ~ is mine.
20:59:09 <juhp> lol
20:59:26 <dons> :P
21:00:02 <Pseudonym> http://andrew.bromage.org/fluid.mpeg
21:00:11 <Pseudonym> Latest fluid simulation.
21:10:37 <desrt> Pseudonym; can you help me with something?
21:10:49 <desrt> http://www.desrt.ca/lc.hs
21:10:55 <Pseudonym> desrt: Yes, for certain values of "something".
21:11:03 <desrt> can you explain to me what is *really* going on here?
21:11:22 <desrt> lambda calculus is supposedly infinitely typed, and yet i can write this little program to play with it
21:11:41 <desrt> even though haskell isn't infinitely typed
21:11:56 <Pseudonym> www.informatik.uni-bonn.de/~ralf/publications/Church.pdf
21:11:57 <Pseudonym> Read that?
21:12:00 <desrt> now if i type ":t lprod" then i start to get scared...
21:12:17 <Pseudonym> As it happens, you don't need infinite types for this.
21:14:01 <desrt> i think this paper is too smart for me
21:14:13 <Pseudonym> Yeah, the type of lprod is pretty impressive.
21:14:45 <Pseudonym> @wiki DerivingFromSpecifications
21:14:45 <lambdabot> http://www.haskell.org/hawiki/DerivingFromSpecifications
21:14:48 <Pseudonym> Might help to read that first.
21:15:17 <desrt> the type of lexpdumb is pretty impressive too
21:15:45 <Pseudonym> The thing you have to realise is that this is the most general type.
21:15:55 <Pseudonym> It's actually _not_ the type that's effectively used.
21:15:56 <desrt> my other question is that if lexpdumb and lexp are functionally equivilent and have no type constraints then why don't they have the same type signature?
21:16:10 <Pseudonym> And I shall answer that question too.
21:16:16 <Pseudonym> Consider this:
21:16:22 <Pseudonym> type Record = (Int,Int)
21:16:36 <Pseudonym> setSecond (a,_) x = (a,x)
21:16:50 <Pseudonym> setSecond :: Record -> Int -> Record
21:16:57 <Pseudonym> That's what the intended type is.
21:17:02 <Pseudonym> But the inferred, most general, type is this:
21:17:19 <desrt> (a,b) -> c -> (a,c)
21:17:21 <Pseudonym> setSecond :: forall a b c. (a,c) -> b -> (a,b)
21:17:23 <Pseudonym> Right.
21:17:45 <Pseudonym> In general, the most general inferred type might be a lot scarier than the intended type.
21:18:02 <desrt> hm
21:18:13 <Pseudonym> lexp and lexpdump have different types for this reason.
21:18:21 <Pseudonym> Their intended types are the same.
21:18:27 <Pseudonym> Their most general inferred types are not.
21:18:36 <desrt> so there is probably some non-lambdaish thing that i could pass to one but not the other
21:18:44 <Pseudonym> This is explained in the Church Numerals paper.
21:18:47 <Pseudonym> Right.
21:18:54 <desrt> right
21:18:57 <Pseudonym> Or a non-Church-numeral that you could pass to one but not the other.
21:19:09 <desrt> ya.  that's what i meant by non-lambdaish :)
21:19:13 <Pseudonym> Because they're only supposed to work on Church numerals and nothing else.
21:19:13 <desrt> heh
21:19:28 <desrt> and i can't properly specify the intended type...
21:19:33 <desrt> at least not in haskell
21:20:32 <Pseudonym> Actually, you can, I believe.
21:20:35 <desrt> although i suppose they all have the type a->a for some scary definition of a :)
21:20:43 <Pseudonym> type Church = forall n. (n -> n) -> n -> n
21:20:58 <Pseudonym> Not sure if you can express that in GHC.
21:21:27 <Pseudonym> Now, lexp :: Church -> Church -> Church
21:21:28 <Pseudonym> I think/
21:21:42 <desrt> i think you can't really say that
21:21:51 * Pseudonym wouldn't be surprised.
21:21:57 <desrt> no.. i don't mean just in ghc
21:22:01 <desrt> (or haskell)
21:22:11 <Pseudonym> It's worth working through the paper, BTW, if you're curious.
21:22:23 <desrt> a church is just a function that takes a function and returns a function
21:22:23 <Pseudonym> I found it pretty readable.  Ralf Hinze is a remarkably clear writer.
21:22:37 <desrt> you also have an iq of 2500 :P
21:22:51 <Pseudonym> Uhm... doubtful.
21:23:02 <desrt> right.  ok.  250 :P
21:23:04 <Pseudonym> That would give me a mental age of 775.
21:23:13 <Pseudonym> Which seems unlikely.
21:23:23 <desrt> lambdabot: 775/250
21:23:24 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
21:23:37 <Pseudonym> @eval 775/2500 * 100
21:23:37 <lambdabot> 0
21:23:40 <Pseudonym> Hmmm.
21:23:47 <Pseudonym> @eval 775 * 100 / 2500
21:23:47 <lambdabot> 31
21:23:58 <desrt> oh.  right.
21:24:22 * Pseudonym has no idea what his IQ is
21:24:23 <desrt> by my calculation, you have an age of 3.1 and the average iq is 10 :)
21:24:43 <Pseudonym> I did a silly on-line test once, but that's not very scientific.
21:24:51 <desrt> what did it say?
21:24:56 <Pseudonym> 160
21:25:09 <desrt> that's what they usually say for me
21:25:21 <Pseudonym> There you go.  So you CAN understand the paper. :-)
21:25:35 <dons> that's what they say for all haskell programmers :)
21:25:41 <desrt> i'm less educated than you are, and online tests are still not scientific :)
21:25:46 <blackdog> necessary but not sufficient condition, perhaps. :)
21:26:07 <desrt> right.  you need iq160 *and* education :)
21:26:16 <desrt> give me another 10 years and i'll be caught up
21:26:26 <Pseudonym> You maybe also have to have read another Hinze paper or two.
21:26:42 <desrt> first: i must eat
21:27:03 <desrt> i tried to go to bed an hour ago but couldn't sleep, so the obvious thing to do is eat instead
21:28:35 <Pseudonym> The other obvious thing to do is hack code.
21:29:24 <desrt> mm
21:29:29 <desrt> i'm waiting for ghc HEAD to build right now
21:33:28 <Pseudonym> Yes, the first question on those online IQ tests is a Haskell question.
21:33:35 <desrt> ?
21:33:44 <Pseudonym> If you answer that correctly, all other questions are ignored and you automatically get at least 160./
21:33:55 <desrt> heh
21:34:03 <Pseudonym> You must be at least THIS smart to use Haskell.
21:49:37 <Lemmih> @seen shapr
21:49:37 <lambdabot> I saw shapr leaving #haskell.se 3 hours 53 minutes 26 seconds ago.
23:18:19 <Lemmih> Good morning, #haskell.
23:35:55 <dblhelix> @yow
23:35:55 <lambdabot> YOW!!  I'm in a very clever and adorable INSANE ASYLUM!!
23:36:48 * Lemmih is going to school.
