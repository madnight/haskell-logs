00:00:03 <skew> what sort of information do you want, and what do you mean by "partially specified"?
00:00:28 <dash> i mean i'd like to feed some text to this code and see what kind of AST comes out
00:00:49 <dash> i'm already feeling uneasy, having written so much code and never tested it :)
00:01:09 <skew> why haven't you tested any of it?
00:01:46 <skew> that's a bit of a different story than thinking out structure
00:01:58 <dash> well, how would i? the type is incomplete, it won't compile
00:02:01 <skew> more like the art of writing your code in little bits that you can play around with in the interpreter
00:02:23 <dash> OK
00:02:39 <dash> i guess that is the biggest problem i've had with static languages
00:02:49 <skew> like, just mock up the expression parser as string "<expr>" or something so you can fiddle around with the quotation parser
00:03:16 <dash> i can't just load a module that's half working and test the working half
00:03:53 <skew> well, you need to stub in the bits of code that the written part actually calls, but you need that in any language
00:04:21 <dash> mmmm 
00:04:30 <dash> from waht i can see you need more in haskell
00:05:00 <dash> if this was python code, for example, i could already be parsing things without quotations in them 
00:05:09 <dash> anyhow
00:05:14 <dash> it ain't, and i will stop whining
00:05:19 <skew> you do lose a bit of flexibility if you want types to directly refer to each other
00:05:32 <skew> rather than insulating them with polymorphism or Dynamic or something
00:06:03 <skew> it's not quite as easy, but for now you could just comment out the bits about quotations
00:06:51 <skew> haskell isn't very friendly about leaving ill-typed code live 
00:07:11 <dash> sigh! haskell sucks!
00:07:26 <dash> just as much as all the other languages i thought i liked
00:07:31 <Pseudonym> Haskell won't let me keep my bugs.  The bastard!
00:07:32 <skew> yeah, I always switch to Python when I want to write bogus code :)
00:07:48 <dash> skew: *nod* which is why i'm glad we use it at work...
00:08:30 <Pseudonym> I'm much more proficient at writing bugs in C++.
00:09:37 <dash> well, yes
00:09:40 <dons> C++ is great for writing bugs!
00:09:42 <dash> that's what C++ is for
00:09:57 <dons> In fact, I think it may have been specifically designed as a bug DSL
00:12:39 <skew> I don't think incremental coding is any harder in Haskell, it's just that the compiler has a lower threshold for nonsense it will accept without choking
00:13:05 * dash blinks
00:13:31 <dash> i can't reconcile those two statements, sadly :)
00:14:03 <skew> adding a few lines of line noise will stop anything but a perl interpreter cold, unless you go and comment it out
00:14:28 <skew> mismatched parens will throw off Python
00:14:33 <dash> sure
00:14:36 <skew> trying to increment a list will baffle Haskell
00:14:49 <dash> yes
00:15:08 <dash> hm 
00:15:35 <skew> I mean once you have the stuff that drives the interpreter batty hidden away in comments, it's just the same old dance of coding some functions, stubbing in stuff for the moment, testing things out in the interpreter, changing code around, ec.
00:15:56 <dash> what's the general aesthetic judgement of the haskell community on depth of nesting type tags
00:16:25 <dash> (or whatever you call those names you gives to stuff in "data FooBaz = Foo x | Baz y")
00:16:44 <skew> types shouldn't go too deep, if you mean something like Tree (ListThingy (Either Int Bool))
00:16:48 <dash> right
00:16:52 <dash> so what's too deep
00:17:04 <skew> that's getting up there
00:17:14 <dash> even two is making me suspicious :)
00:17:50 <dash> remind me how fmap works again?
00:18:37 <Perite> @type fmap
00:18:38 <lambdabot> fmap :: forall f b a. (Functor f) => (a -> b) -> f a -> f b
00:18:53 <skew> fmap f m is like m >>= return . f
00:19:20 <dash> skew: OK
00:20:25 <dash> so... hm 
00:20:51 <dash> m >>= return . f . g would become fmap (f . g) m ?
00:21:27 <skew> one or two layers of type constructors is about the limit for thing you mention once per type signature, less for things that are repeated
00:23:11 <skew> The definition of a type synonym can be more complicated because you only need to read it once, types that show up many times in a function's type signature should be simple, just a name or maybe one constructor deep
00:23:17 <skew> dash: yes
00:28:27 <dons> lovely. yi can split screens now :)
00:28:36 <dons> haskell is just so great
00:28:53 <dons> once you convince the type checker everything is fine, it all just works
00:34:29 <dash> heh
00:34:33 <dash> i wish i could believe that
00:34:51 <dash> anyway i seem to have turned a type error into a syntax error
00:36:25 <dash> ERROR "arnis.hs":73 - Syntax error in expression (unexpected `;', possibly due to bad layout)
00:36:48 <dash> the code in question looks like:
00:36:58 <dash> quotedObject = q <|> backq <|> unq
00:36:58 <dash>     where
00:37:00 <dash>     q     = do ...
00:37:20 <dash> bleh
00:37:31 <dash> sorry, i have been awake too long. I am missing a paren.
00:38:10 <dash> oh yeah, this was the other thing
00:38:30 <dash> i have to think about my data structures beforehand, and change a lot of code when they change
00:38:38 <dash> despite inference
00:52:57 <danols_> i have a question
00:53:16 <danols_> anyone alive first ?
00:53:22 <dons> ask away
00:53:37 <danols_> ok it's rather a simple one, but i need to know that i understand this correctly 
00:54:17 <danols_> i need to locate characters after the first initial 8192 bits, since haskell stores the 'stream' as a string, that means 8192/8 = 1024 element ?
00:55:36 <dons> are you talking about reading from files?
00:55:52 <dons> using hGetContents, or similar?
00:55:56 <danols_> correct
00:56:03 <shapr> hey skew, ltns
00:56:04 <danols_> but i'm reading from an mp3 stream
00:56:22 <danols_> i need to read the meta encoded in the msg
00:56:25 <danols_> (http://ample.sourceforge.net/developers.shtml)
00:56:41 <dons> since it is a String, you don't need to worry about how long it is, it is as long as its input
00:56:53 <danols_> dons that's true
00:56:59 <dons> to index a string, use !!
00:57:02 <danols_> dons each element in the string represents one byte ?
00:57:09 <danols_> !! ?
00:57:14 <danols_> i forgat about that one
00:57:16 <danols_> it's been a year
00:58:20 <danols_> dons my confusion is if the meta msg starts at 8192th byte that means 8192 element in the hGetContents ?
00:59:10 <dons> I think so. But you should check carefully
00:59:29 <danols_> dons i am acctually trying to check it as we speak but the meta data seems to elude me
00:59:31 <danols_> hmmm
01:05:35 <dash> my work here is done
01:09:15 <musasabi> What would be a good way at trying to find out what causes a pure haskell program to segfault?
01:10:59 <musasabi> bt in gdb only tells me "stg_NO_FINALIZER_closure" which is not very helpfull..
01:11:22 <dons> musasabi: compile your program with -debug flag to ghc
01:11:34 <dons> then you get the debugging rts, which has better symbols
01:11:45 <dons> otherwise, that's about the best you can do.
01:11:51 <dons> you can run ghc in gdb
01:12:01 <dons> sorry, step through the haskell program in gdb
01:12:13 <dons> but you'll need -optc-ggdb too
01:13:00 <dons> but truly pure programs that do nothing strange should never crash. so it could be a bug, and if so please report!
01:13:18 <skew> shapr: yeah, my computer was broken. Turned out a bad network card was keeping it down
01:15:39 <skew> I think I'll be around some now
01:16:03 <musasabi> that yields 1# stg_NO_FINALIZER_closure, 9# TextziParserCombinatorsziReadPrec_minPrec_closure, #12 lookupStableName
01:17:26 <dons> so now go and look at the library code for minPrec and see if it does something unexpected
01:17:41 <dons> maybe it doesn't work on your platform?
01:17:57 <dons> though that seems unlikely
01:20:45 <musasabi> well this is i386 linux...
01:21:04 <musasabi> I am trying to isolate it.
01:24:36 <musasabi> found it, just my own carelesness
01:25:10 <musasabi> a global variable in ioref + forgetting it was in a wrapped type => nice crash
01:25:11 <dons> how so?
01:25:16 <dons> hehe
01:25:48 <dons> s/pure haskell/impure dirty haskell/ ;)
01:26:51 <musasabi> well the modules I was looking at were pure..
01:28:10 <musasabi> just the impure module never actually specified what type the data behind the ioref is believing in inference.. And then changing a function using the data in the pure module => instant crash
01:46:38 <shapr> dons: yay! new patches to yi!
01:47:00 * shapr sends ebeer(or beverage of choice) to dons 
01:48:43 <shapr> hey, if anyone has recommendations for 1U profile colo server hardware, I'm looking for info.
01:48:58 <dons> shapr: just about to commit window splitting code
01:49:00 <dons> lots of fun
01:49:11 <dons> beer is fine
01:49:36 <shapr> remind me at icfp05 :-)
02:02:31 <wilx> So...
02:02:48 <wilx> I have a file opened.
02:02:57 <wilx> Now I would like to read integers from it.
02:03:20 <wilx> But I don't see anything useful in System.IO docs...
02:05:06 <dons> shapr: try out that commit. it's fun.
02:05:31 <musasabi> wilx: read
02:05:34 <musasabi> @type read
02:05:36 <lambdabot> read :: forall a. (Read a) => String -> a
02:05:37 <Lemmih> Integers? As in Word32 or a list of Ints?
02:06:04 <wilx> Hmm... So I have to first read the whole file using hGetContents and then use read on it?
02:06:47 <Lemmih> hGetContents is lazy. It'll only read as much as you're using.
02:08:30 <Lemmih> @type readFile
02:08:31 <lambdabot> readFile :: FilePath -> IO String
02:09:07 <musasabi> readMap s = case reads s of [(a,r)] -> a : readMap r; _ -> []
02:09:48 <musasabi> readThings :: Read r => Handle -> IO [r]
02:10:00 <musasabi> readThings h = hGetContents h >>= return . readMap
02:12:05 <musasabi> is that what you want?
02:12:32 <wilx> Hmm, probably :)
02:13:44 <musasabi> -> shopping
02:24:32 <seafood_> Is there any easy way to override a Show instance?
02:28:24 <Si\> you can't override class instances except by not importing where they are declared
02:29:07 <Si\> so you'd have to not import Prelude
02:33:06 <seafood_> But then I'd lose all the Prelude functions.
02:33:17 <seafood_> That's no good. THere's no easy way to do this is there.
02:34:32 <Si\> no, you can get all the Prelude stuff back though by manually importing the appropriate modules
02:34:49 <wilx> Hmm... Isn't there something like "hidden" attribute for import?
02:34:58 <seafood_> Only works for functions.
02:35:11 <seafood_> And data types.
02:36:43 <Si\> If you want to do something like this, either create your own class or wrap your data-type with a newtype declaration
02:37:02 <seafood_> Nah that sux even more.
02:47:42 <tromp> why do you want to override show?
02:48:07 <tromp> why not make a show' ?
02:48:59 <seafood_> tromp: Because you can derive Show.
02:49:08 <seafood_> I'm happy with all the derivations.
02:49:15 <seafood_> I'm not happy with the way Show Double works though.
02:49:23 <seafood_> Just one instance killing everything!
02:49:30 <seafood_> If only Generic Haskell were usable.
02:49:49 <seafood_> I'd just write a generic show.
02:50:08 <Si\> Why not use SYB Generics?
02:50:10 <seafood_> Oh... that wouldn't work.
02:51:03 <Si\> myShow :: (Data a, Show a) => a -> String
02:51:26 <Si\> Use default show if you like it, or create a special case instance
02:51:46 <Si\> or don't use Show a, just use SYB's gshow
03:03:01 <tromp> so you want to use the derived Show on data that includes Doubles, and just do those differently?
03:03:13 <seafood_> yup.
03:04:09 <tromp> then u have to chose between 2 evils
03:05:06 <tromp> either don't derive Show, or use newtype MyDouble
03:06:36 <tromp> actually, u'd only have to rewrite show for the data that directly includes Double
03:06:48 <seafood_> Si had the solution.
03:06:49 <seafood_> But it's tedious.
03:06:57 <tromp> that's what the newtype achieves too
03:07:26 <tromp> so, whatever data is wrapped right around the Double needs its own show
03:07:38 <seafood_> I don't want to have to change all my data types now.
03:08:34 <tromp> how many data declarations have Doubles on the right side?
03:08:40 <seafood_> Heaps.
03:08:44 <seafood_> Plus it was for an assignment.
03:08:49 <seafood_> One I wrote for students.
03:08:53 <seafood_> I can't change the interface now.
03:09:08 <tromp> there's one other kludge solution
03:09:20 <seafood_> doesn't matter now.
03:09:26 <seafood_> I tedious wrote out new show instances.
03:09:30 <seafood_> For a class called Show2
03:09:38 <seafood_> very annoying. But it's done now.
03:09:57 <tromp> use myshow = reformatdoubles . show
03:10:21 <seafood_> This still doesn't work.
03:10:28 <seafood_> I want to be able to use derived Show instances.
03:10:57 <seafood_> so if I type show <complex data structure containing doubles> i want it to use an overridden show on all the Doubles.
03:11:06 <seafood_> On the Doubles that are inside that data structure.
03:11:20 <tromp> that's what happens with myshow
03:11:43 <tromp> it takes the (derived) show output, and lexes it for doubles
03:11:51 <seafood_> Oh. I see.
03:11:52 <tromp> which it then reformats
03:11:52 <seafood_> Of course.
03:11:59 <seafood_> Annoying as all hell.
03:12:03 <seafood_> Thanks though :)
03:36:32 <TheHunter> in your face, ListT!
03:36:39 <seafood_> Woah.
03:36:41 <seafood_> What's all that about?
03:38:22 * TheHunter thinks the ListT should really be like data MList' m a = MNil | a `MCons` MList m a; type MList m a  = m (MList' m a); newtype ListT' m a = ListT' { runListT' :: MList m a }
04:23:37 <Boegel> hello everyone
04:24:36 <tromp> hi Boegel
04:24:57 <Boegel> I'm bored :(
04:25:07 <tromp> lucky you
04:25:33 <Boegel> lucky ? no, not lucky... I have a lot of work to do, but I can't do it here
04:26:03 <Boegel> hello kristnjov
04:26:08 <tromp> i have work to do which stops me from reading haskell papers
04:26:26 <kristnjov> hi
04:26:30 <Boegel> tromp, but you do have time to be on #haskell ? :)
04:26:44 <tromp> barely:)
04:27:17 <Boegel> I see you here all the time... or am I mistaking?
04:32:47 <musasabi> home
04:33:02 <tromp> i just leave this window sitting around
04:40:49 <Boegel> hey musasabi
04:41:04 <musasabi> hello Boegel 
04:41:40 <wilx> w000t!!
04:41:50 <wilx> I was finally able to read the graph.
04:41:52 <wilx> Wheee.
04:42:00 <wilx> Haskell IO is hard...
04:42:57 <seafood_> Yeah, but it's safer than other languages.
04:46:17 <wilx> Hm...
04:46:32 <wilx> Is there a pastebin somewhere?
04:48:11 <musasabi> in the wiki
04:48:48 <musasabi> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:55:19 <wilx> Mmm.
04:55:26 <wilx> On the top of the pastebin.
04:55:37 <wilx> Why doesn't it compile?
04:57:47 <tromp> remove the .o and .hi files and recompile to see errors?
04:59:16 <musasabi> wilx: s/module TDG where/module Main where/
04:59:28 <wilx> Ah.
04:59:56 <musasabi> despammed the wiki a little bit
05:24:59 <kristnjov> darn, i thought i had just managed to complete a fulladder in haskell :/
05:39:47 <kristnjov> and now i have :)
05:40:01 <Lemmih> Fulladder?
05:40:07 <kristnjov> yeah
05:40:15 <kristnjov> a school lab
05:40:43 <kristnjov> the code snippet became rather long... i wonder if there is any faster way of doing it
05:42:23 * shapr hops
05:42:44 * kosmikus has written his first lambdabot plugin
05:42:47 <musasabi> hello shapr 
05:42:57 <kristnjov> now the only thing left for me to do are a couple of quickcheck properties and i'm done
05:44:08 <shapr> kosmikus: yay!
05:44:11 <shapr> kosmikus: what did you write?
05:44:31 <kosmikus> shapr: go to a certain other channel and test it: @tex-idx
05:51:12 <marcot> Good morning.
05:51:23 <shapr> Ã³la marcot 
05:51:42 <marcot> shapr: OlÃ¡, shapr.
05:51:59 <shapr> oh, did I have the accent in the wrong place? oops.
05:52:14 <dons> squashed a bug. yeah
05:52:16 <shapr> marcot: how do you like Haskell so far?
05:52:45 <marcot> shapr: sorry?
05:54:17 <shapr> you're learning haskell? do you have any questions or problems I can help you with?
05:54:18 <marcot> shapr: I didn't understand the question...
05:54:24 <marcot> shapr: My english isn't very good.
05:54:38 <shapr> my portuguese isn't very good.
05:54:51 <shapr> so we're even :-)
05:55:13 <mornfall> hey hey, shapr 
05:55:20 <shapr> greetz mornfall 
05:55:39 * mornfall notes his haskell is slightly hindered by learning prolog :p
05:56:16 <marcot> shapr: hehehe.. I'm learning Haskell in my work, no problems for now.
05:56:47 <mornfall> like, i'm generally used to imperative programming, but haskell is all nice and grokkable... prolog is arcane tho
05:58:12 <tromp> take a prolog unlearning course...
05:58:38 <mornfall> can't, i have exam next week :p
05:58:55 <mornfall> and then another one at the end of the year
05:59:02 <mornfall> s/year/semester/
06:01:48 <kristnjov> what's the function to get the first parameter from a tuple in the form of (a,b,c)?
06:01:55 <kristnjov> i want to get "a" from that
06:02:07 <tromp> (\(a,b,c) -> a)
06:02:09 <kristnjov> tried fst, head and !!
06:02:49 <tic> 3rd (_,_,a) = a
06:02:50 <tic> :)
06:02:54 <dons> fst3 ?
06:02:56 <kristnjov> yeah well ;P
06:07:18 <shapr> hoi swiert 
06:07:26 <shapr> y0 dons, wassup?
06:07:28 <swiert> hi shapr
06:07:47 <shapr> I still haven't checked out Parrowsec, but it's nearing the top of my list :-)
06:08:08 <swiert> shapr: no problem - don't feel obliged to look at it.
06:08:13 <shapr> right now I'm looking for 1U profile colo hardware.
06:08:38 <shapr> speaking of neat arrow tricks: http://lambda-the-ultimate.org/node/view/345
06:10:23 <shapr> I like Einar Karttunen's "arrows that draw themselves" demo.
06:10:57 <marcot> Does anyone knows the haskell-mode for emacs author?
06:11:06 <shapr> I know the maintainer.
06:11:14 <shapr> Simon Marlow last I checked.
06:11:24 <shapr> do you have some patches?
06:11:28 <shapr> if so, I want them =)
06:11:36 <swiert> shapr: graphviz is pretty amazing
06:11:38 <kosmikus> which reminds me ...
06:11:47 <kosmikus> I wanted to ask Peter Thiemann to send me his haskell emacs mode
06:11:53 <shapr> he has a separate one?
06:11:56 <kosmikus> yes
06:11:59 <marcot> shapr: It's not a patch, cause I don't know nothing of lisp.
06:12:03 <kosmikus> seems to be better than the original
06:12:06 <marcot> kosmikus: is it better?
06:12:08 <shapr> wow, cool
06:12:10 <kosmikus> well
06:12:24 <marcot> kosmikus: isn't it free?
06:12:41 <marcot> In Simon's mode, there's a small problem with lambda notation.
06:12:44 <shapr> iirc, Peter Thiemann is good friends with Michael Sperber.
06:12:46 <kosmikus> he says (and from what I've seen, I agree): "my version at least offers the correct indentation position, among many others"
06:12:57 <shapr> ok, I want it!
06:13:10 * kosmikus writes the mail
06:13:14 <marcot> when yo do something like (\(a, b) -> a), it connects the ) after b with the ( before the \
06:13:26 <shapr> I think that's a standard problem with regex based syntax highlighting.
06:13:34 <shapr> the first paren appears to be escaped
06:13:39 <shapr> you can use (\ ( instead
06:13:53 <marcot> yes... but I prefer to use \(
06:13:56 <shapr> me too
06:14:03 <shapr> but I prefer to not use regex based highlighting also.
06:14:06 <marcot> And in fundamental mode we don't have this problem.
06:14:21 <shapr> well, patch it :-)
06:14:38 <marcot> shapr: if I knew a little of lisp..
06:14:52 <shapr> there's also the problem of " foo -- " showing up incorrectly.
06:15:21 <shapr> I've written a decent amount of elisp, but I'd rather spend my time working on an emacs replacement.
06:15:47 <shapr> marcot: which version of haskell-mode are you using?
06:15:52 <musasabi> Where is the template haskell 2 notes, it was posted somewhere...
06:16:07 <kosmikus> mattam: you had a question about me doing Generic Haskell?
06:16:11 <shapr> musasabi: url mentioned in the last two weeks on the TH mailing list.
06:16:13 <u1sf> has anyone ever considered how a higher-order type-class would work?
06:16:16 <marcot> 1.45
06:16:40 <kosmikus> Si\: what's a ho type class?
06:16:54 <swiert> kosmikus: could I get a copy of that as well?
06:17:20 <kosmikus> swiert: of what? the other emacs mode?
06:17:24 <Si\> I've no idea kosmikus
06:17:27 <shapr> marcot: ok, gimme a coupla minutes, I'll see if I can fix it for you.
06:17:43 <kosmikus> Si\: how would I have an idea how it works if I have no idea what it is
06:17:47 <marcot> shapr: what do you don't like in emacs?
06:17:57 <shapr> hiya FunkyFis, looking for Haskell info?
06:17:57 <Si\> Just something I was thinking about, perhaps some logical grouping for type-classes based on a common property or something like that
06:18:03 <marcot> shapr: what should the haskell mode show in "foo --" ?
06:18:05 <Si\> type-class-classes
06:18:13 <swiert> kosmikus: yes the emacs module
06:18:51 <kosmikus> I will ask Peter if I'm allowed to redistribute it
06:18:55 --- mode: ChanServ set +o shapr
06:19:31 <shapr> FunkyFis: you look a whole lot like a clonebot, respond or be whacked
06:20:10 --- kick: FunkyFis was kicked by shapr (Kicked by shapr)
06:20:32 <shapr> anybody who has alphabetically joined the max number of channels looks suspicious to me.
06:20:52 --- mode: shapr set -o shapr
06:20:56 <shapr> anyway...
06:21:39 <Si\> or could one some how reify polymorphic type constraints satisfied by a particular type and used this data to allow type-class based processing
06:21:44 <shapr> marcot: emacs does not have multithreading, does not have a good standard incremental parser, only has elisp, is too tightly bound to the C underpinnings.
06:22:23 <marcot> shapr: hum...
06:22:27 <shapr> marcot: the GUI code is not abstract enough to easily support gtk2/gnome/OpenGL/antialiased TTF...
06:22:36 <swiert> kosmikus: "bij voorbaat dank"
06:23:16 <musasabi> I have been prototyping a library for text-mode userinterfaces in haskell...
06:23:21 <marcot> shapr: with this C part I totally agree. The oder comments, I don't know a lot about emacs to understand.
06:23:30 <shapr> marcot: also, the community is splitting into two warring factions, and I seriously doubt it will ever get better.
06:23:50 <marcot> shapr: but do you know any better editor?
06:23:53 <shapr> all those problems are fixable, but not while RMS is running gnu emacs.
06:24:25 <marcot> shapr: is it hard to deal with him?
06:24:26 <shapr> marcot: darcs get http://www.cse.unsw.edu.au/~dons/yi
06:24:32 <Si\> What do you think kosmikus; is the Haskell type-system such that you could reify polymorphic constaints satisfied by a type?
06:25:03 <shapr> marcot: RMS removed the .so support from gnu emacs because he was afraid it would allow people to use emacs along with closed source code.
06:25:23 <marcot> shapr: what's .so?
06:25:32 <shapr> dynamic library linking
06:25:40 <shapr> the dlopen() call
06:26:14 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-28)!
06:26:30 <shapr> marcot: of course, I love emacs enough that I use it for my irc client even =) but it still needs to be replaced.
06:26:34 <marcot> shapr: hum.. what's this yi thing?
06:26:47 <shapr> I hope that yi will be an editor that's better than emacs
06:26:48 <marcot> shapr: but you're using xemacs.
06:26:55 <kristnjov> prop_inout :: [String] -> Property
06:26:56 <kristnjov> prop_inout a = length a < 2 ==> (length . concat . inout) a == (8*(length a))
06:27:08 <kristnjov> does anyone have any idea about why that fails sometimes?
06:27:17 <kristnjov> like every 30th time it fails and i have no idea why!
06:27:35 <shapr> kristnjov: doesn't it show you the failing input?
06:27:39 <shapr> if not, use verboseCheck
06:27:47 <kristnjov> it does show me
06:27:58 <kristnjov> and the failing input doesn't seem very strange to me
06:28:11 <kristnjov> apart from that it's nonsense
06:28:22 <shapr> does the failing input fail when you try it manually?
06:28:31 <shapr> marcot: gnu emacs and xemacs are both still emacs.
06:28:36 <kristnjov> i'll see
06:28:44 <marcot> shapr: yes, but why do you prefer xemacs?
06:29:14 <shapr> xemacs is more user-friendly in several ways, and has more support for some things.
06:29:31 <shapr> on the downside, xemacs doesn't have as much elisp being written for it as gnu emacs does
06:29:31 <kosmikus> Si\: sorry, I'm not sure I understand what exactly it is you want
06:29:40 <shapr> and both xemacs and gnu emacs are becoming less compatible with each other.
06:29:58 <kristnjov> think i know the problem now.. odd problem though
06:30:21 <kristnjov> heh, now it fails even more often!
06:30:22 <shapr> in my opinion, RMS should kiss and make up with the xemacs guys and they should merge codebases, otherwise emacs will not survive.
06:30:41 <marcot> shapr: and why they don't do it?
06:31:28 <musasabi> shapr: that is a legal problem.
06:31:42 <shapr> originally because RMS didn't want to go through the mounds of code that jamie w. zawinski had written for Lucid Emacs, and wanted to commit into emacs 18 (19?)
06:32:20 <musasabi> shapr: FSF requires contributors of significant changes to grant the copyright to FSF so that they hold the copyright and thus the ablity to sue GPL violators.
06:32:37 <shapr> that's a problem now, but I don't think it was originally.
06:33:31 <shapr> So, I don't think gnu emacs will ever merge with xemacs because of the copyright assignment problem, and I think that means the community will continue to splinter.
06:34:06 <shapr> I still say they should merge and refactor mercilessly if they want emacs to survive.
06:34:13 <musasabi> well the problem is that code can flow from GNU emacs to xemacs but not backwards.
06:34:34 <marcot> musasabi: this is the worse thing.
06:34:34 <musasabi> Which does not create a very healthy atmosphere ;)
06:34:36 <shapr> and I think that's the terminal disease of emacs.
06:35:13 <shapr> so, even though I have loved emacs for years, I want out.
06:35:46 <shapr> I don't trust the vender ;-)
06:36:06 <marcot> shapr: You don't trust who?
06:36:13 <marcot> shapr: RMS or the xemacs guys?
06:42:04 <tintin> xemacs 
06:47:21 <marcot> shapr: how do I download all these files from the yi repository?
07:12:08 <shapr> marcot: both
07:12:16 <shapr> marcot: use darcs get
07:18:43 <Lemmih> Time to unicycle!
07:19:21 <Maddas> heh :-
07:19:21 <Maddas> :-)
07:20:07 <Lemmih> Btw, did you see the picture of my old seat, shapr?
07:20:32 <marcot> shapr: what's darcs?
07:20:41 <CosmicRay> heh
07:23:43 <Lemmih> *Puff* (and the Lemmih is gone)
07:25:55 <bringert> marcot: http://abridgegame.org/darcs/
07:27:25 <marcot> bringert: thanks.
07:40:27 <marcot> Why isn't the .deb version of darcs in the official debian repository?
07:40:50 <marcot> actually it is.
07:40:53 <marcot> sorry... =)
07:41:26 <CosmicRay> the official debian repository?
07:41:32 <CosmicRay> is there a debian darcs repo somewhere?
07:42:30 <marcot> CosmicRay: yes, look in the bringert's link.
07:42:39 <marcot> And it's in unstable.
07:43:28 <skuggi> http://rafb.net/paste/results/XJp8DS67.html <- can someone tell me what's wrong?
07:43:31 <CosmicRay> marcot: bringert's link?  That's just the darcs home page
07:46:25 <musasabi> skuggi: the type of form is too general.
07:46:44 <skuggi> musasabi: right.. how do i fix this?
07:47:23 <musasabi> "x^2n)/(facul" typo
07:47:35 <musasabi> "x^(2*n))/(facul" perhaps
07:47:55 <skuggi> ah, right..
07:48:08 <skuggi> fixed that in another version of the code :)
07:48:28 <skuggi> er..
07:48:32 <skuggi> not entirely..
07:48:41 <skuggi> now it works... thanks..
07:49:01 <skuggi> hmm.. what does 2n mean then?
07:51:11 <musasabi> it means 2n => 2 n => (fromInteger 2) n
07:51:12 <skuggi> hmm. Integral and Fractional are type classes?
07:51:21 <skuggi> oh..
07:51:34 <musasabi> that is in Num
07:51:42 <skuggi> k
07:52:02 <skuggi> now i'm getting: ERROR - Unresolved overloading
07:52:02 <skuggi> *** Type       : (Integral a, Fractional a) => a
07:52:03 <skuggi> *** Expression : cosinus 1 6   
07:54:01 <musasabi> well that is because the result type is polymorphic making the application undefined
07:54:33 <wilx> Hmm, is Data.Array access using (!) O(1)?
07:55:24 <skuggi> musasabi: huh?
07:55:43 <musasabi> skuggi: the code is valid but no existing number type satisfies the constraints.
07:55:50 <musasabi> @type (^)
07:55:52 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
07:55:58 <musasabi> @type (/)
07:56:00 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
07:56:18 <Cale> wilx: I would think you could expect it to be O(1).
07:57:29 <skuggi> musasabi: hmm. how can i solve this?
07:58:04 <musasabi> to cut the story short "/" is for floats and "^" wants the second argument to be an integer and you are asking for a type that is an integer and a float.
08:00:01 <musasabi> skuggi: what do you want to do if n is e.g. 2.8  ?
08:00:12 <musasabi> or do you want it to be an integer?
08:00:17 <skuggi> n should be integer
08:00:25 <musasabi> if so you should probably use div instead of /
08:00:32 <skuggi> ok
08:00:47 <skuggi> div can give float result?
08:01:21 <musasabi> no that produces ints (and leads to div by zero)
08:02:48 <skuggi> it needs to be able to give float results. how can i do that?
08:04:29 <musasabi> form x m n | n == m = 0
08:04:29 <musasabi>            | True   = (((-1)^n * x^(2*n)) / fromIntegral (facul (2*n)) ) + (form x m (n+1))
08:04:58 <musasabi> but that does not produce anything sensible.
08:05:13 <skuggi> why not?
08:05:55 <musasabi> Infinity..
08:05:59 <musasabi> but have to go.
08:06:29 <skuggi> oh.. there's an error..
08:06:33 <skuggi> k..
08:14:06 * Lemmih is back again.
08:19:52 <skuggi> http://rafb.net/paste/results/k908N227.html <- how would i do to do a putStrLn in the else clause on line 13?
08:20:18 <earthy> not.
08:20:26 <skuggi> ?
08:20:44 <earthy> or do it both in the then and in the else clause
08:21:06 <earthy> you can only do putStrLn in the IO monad
08:21:16 <earthy> and you cannot have more than one return type for a function
08:21:44 <earthy> so, the return type of `form' needs to be something with the IO monad as well, if you want to doe a putStrLn
08:21:52 <skuggi> so i can't output text in that function, or what?
08:21:58 <earthy> exactly
08:22:04 <earthy> well, not completely
08:22:05 <skuggi> wtf. :/
08:22:15 <earthy> `there are ways'
08:22:20 <earthy> but it's best to not think of those ;)
08:22:22 <skuggi> haskell is weird :P
08:22:26 <skuggi> ok :)
08:22:37 <earthy> why do you want to do output there?
08:22:57 <skuggi> i want to know how many times it's been called.
08:23:39 <skuggi> how many times that else clause has happened i mean.
08:48:30 <bourbaki> moin
08:56:40 <earthy> skuggi: sorry, was afk for a moment
08:56:49 <earthy> why not keep a counter?
08:57:24 <earthy> (extra input argument, extra output argument)
08:57:28 <earthy> so,
08:58:45 <earthy> form x m n c = if (n == m) then (0,c) else ( (((-1)^n * x^(2*n)) / fromIntegral (facul (2*n)) ) + (fst (form x m (n+1) c+1)), snd (form x m (n+1) c+1) )
08:59:07 <earthy> ofcourse, you could put the recursive call to form in a where clause
09:12:20 <Lemmih> Pryvit, dottedmag.
09:13:16 <dottedmag> Lemmih: hi
09:13:43 <Oejet> Priviet, dottedmag.
09:14:07 <dottedmag> Lemmih: unfortunately, don't know Dutch :)
09:14:15 <Oejet> dottedmag: Kak dela?
09:14:29 <dottedmag> Oejet: thanks, ok
09:14:48 <Oejet> dottedmag: Horoscho :-)
09:16:56 <Lemmih> I guess my russian sucks /-:
09:17:36 <shapr> dottedmag: looking for Haskell info?
09:17:44 <CosmicRay> anyone here heard of Mercury?
09:17:48 <shapr> sure yeah
09:17:55 <CosmicRay> how does it compare to Haskell?
09:18:04 <dottedmag> shapr: no, just wanna join community
09:18:28 <shapr> CosmicRay: it's a pretty different thing, it's logic/constraint based.
09:18:35 <CosmicRay> like prolog?
09:18:44 <shapr> yup, but more multiparadigm like Haskell.
09:18:56 <shapr> I'm going to hit Mercury/OZ after Haskell.
09:19:03 <shapr> get my dose of logic programming.
09:19:13 <CosmicRay> OK, I'll just wait for you so I can l33ch knowledge from your brain again :-)
09:19:40 <shapr> it might be six or eight months till I get there btw.
09:19:59 <CosmicRay> I'll have forgotten about it until then anyway
09:20:05 <shapr> heh, ok
09:20:08 <CosmicRay> I just noticed it yesterday since it appears to be the largest package in Debian
09:20:16 <CosmicRay> the mercury package installs over 100MB of files
09:20:22 <shapr> yow
09:20:34 <musasabi> Oz has horrible syntax
09:20:41 <shapr> yah, I totally agree with that.
09:20:48 <shapr> I've tried to start learning Oz ... four times already.
09:21:01 <musasabi> and imho it is a too large language.
09:21:19 <shapr> musasabi: other than Mercury/Oz and Haskell, what do recommend for niftyness?
09:21:24 <dottedmag> CosmicRay: 30M of binaries, 1M of docs. Or they docs are very concise, or Mercury compiler generates very unoptimized code :)
09:21:34 <CosmicRay> heh
09:21:55 <CosmicRay> shapr: it occurs to me that Mercury is very similar to Haskell.
09:21:59 <musasabi> shapr: scheme is nice for some purposes, but lacks a standard way of expressing polymorphism.
09:22:02 <shapr> Lately I've spent some time in the postfix concatenative world, that's fun.
09:22:06 <CosmicRay> shapr: actually, Haskell seems more similar to Prolog that I realized at first.
09:22:06 <shapr> I've done scheme.
09:22:07 <musasabi> shapr: how about adding logic values to haskell with a suitable abstraction?
09:22:32 <shapr> I've seen several implementations of prolog in Haskell
09:22:43 <CosmicRay> IIRC, the only difference is that you can extend a Prolog function anywhere, whereas you can only do that in the same module in Haskell
09:22:44 <shapr> one which didn't even use functions, only types =)
09:22:48 <CosmicRay> heh
09:22:53 <CosmicRay> and I use "function" loosely
09:22:58 <musasabi> Inductive Logic Programming can be nice ;)
09:22:59 <CosmicRay> because I don't even know what it's called in Prolog anymore
09:23:28 <Philippa> CosmicRay: when describing things to folks who'd done an intro to haskell course at uni, I ended up dubbing prolog "Haskell backwards"
09:23:34 <shapr> maybe that's where I should jump to inhale my logic paradigm... Prolog or other logic programming in Haskell.
09:23:36 <CosmicRay> heh
09:23:37 <Philippa> predicate
09:24:18 <shapr> Concatenative languages are great fun.
09:24:40 <CosmicRay> shapr: just as long as I don't have to write a MissingP now, I'll be happy. :-)
09:24:57 <shapr> I want to understand the benefits of every major approach to programming, so I keep looking for new approaches.
09:25:12 <shapr> Functional is my favorite so far.
09:25:15 <CosmicRay> I had half a semester of prolog at college.  I don't think we ever once learned how to do I/O in it.  My impression was that it either couldn't or was really bad at it.
09:25:18 <CosmicRay> yeah.
09:26:47 <shapr> thing about scheme is that it's so transparent it feels like lambda calculus to me.
09:27:49 <shapr> That is a nice approach for many things, but it just doesn't do it for me. Maybe if python and scheme has some mutated offspring, I might use that.
09:27:52 <CosmicRay> has someone written a scheme interpreter for haskell yet?
09:27:59 <shapr> yah, HScheme
09:28:03 <CosmicRay> ah.
09:28:08 <shapr> but it's by Ashley Yakeley...
09:28:18 <CosmicRay> that name doesn't sound familiar
09:28:19 <shapr> ever played Call of Cthulhu?
09:28:23 <CosmicRay> nope
09:28:31 <shapr> familiar with the concept of SAN points?
09:28:43 <CosmicRay> nope
09:29:01 * CosmicRay feels like he's depressing shapr
09:29:02 <CosmicRay> :-)
09:29:13 <shapr> Call of Cthulhu is a role-playing game based on H.P. Lovecraft's novels.
09:29:41 <shapr> Each exposure to the terrifying things that your characters expunge from the world removes SAN points.
09:29:49 <shapr> if you reach zero, you go insane.
09:30:39 <shapr> Things like reading texts about Cthulhu, Shub-Niggurath, R'lyeh, etc may be good for your characters to get rid of something, but it slowly makes them crazy.
09:31:01 <shapr> Anyway, reading Ashley's code feels like it removes SAN points from me sometimes.
09:31:09 <CosmicRay> heh
09:31:18 <shapr> things like J2EE removes SAN points
09:31:25 <shapr> Python gives back SAN
09:31:26 <CosmicRay> ah. useful analogy.
09:31:29 <shapr> Haskell even more so.
09:31:30 <CosmicRay> and haskell?
09:31:35 <CosmicRay> thought so :-)
09:32:08 * CosmicRay afks
09:36:16 * Cale hits shapr with a compose (MkStaticFunctor fqr) (MkStaticFunctor fpq) = MkStaticFunctor (fapply (fmap (\pq qr p -> qr (pq p)) fpq) fqr)
09:36:48 <skuggi> earthy: ok.. thanks..
09:37:04 * shapr is charged with static funk!
09:37:12 <shapr> hej skuggi 
09:37:16 <musasabi> what getting SAN back ?
09:37:18 <shapr> vet du om #haskell.se oxa?
09:37:21 <musasabi> That should be illegal.
09:37:33 <shapr> musasabi: in the game it's really hard to get SAN back
09:37:33 <musasabi> SAN is a oneway trip to madness.
09:37:46 <shapr> you have to spend time in a sanitorium
09:38:00 <shapr> or take long vacations, or do psychotherapy
09:38:23 <shapr> so if your character nears zero SAN, you generally have to make a new character while the former character is recovering.
09:38:30 <shapr> dash: SMALL CHILD STAPLES!
09:38:34 <dash> mmmm, zero SAN
09:38:40 * shapr has #python flashbacks
09:38:46 <dash> exactly what I was thinking as i typed '/join #haskell'
09:38:54 <shapr> haha
09:39:01 <shapr> see, I think Haskell gives SAN.
09:39:05 <shapr> even more so than Python.
09:39:16 <dash> python sucks
09:39:22 <dash> but at least I understand its typesystem 
09:39:24 <dash> anyway I have a lisp parser in haskell now 
09:39:27 <shapr> cool!
09:39:35 <dash> now i am trying to do something with it
09:39:35 <tic> heh, are everyone on all channels? :)
09:39:52 <bourbaki> dash is it online somewhere?
09:39:58 <dash> bourbaki: hmm
09:40:09 <skuggi> shapr: hej :)
09:40:17 <skuggi> shapr: nej, den kände jag inte till
09:40:29 <dash> http://ghostwheel.ddts.net/~washort/arnis.hs
09:40:50 <dash> everything but 'meaning' there works :)
09:40:58 <dash> so anyway
09:41:29 <dash> what d'you do when you want to call one function for one type and another for all the others
09:41:44 <shapr> like what?
09:42:05 <skuggi> shapr: hmm känner du till några bra haskell-tutorials? (särskilt som förklarar typer och sånt bra)
09:42:07 <dash> well. here is what it looks like in Queinnec's example code :)
09:42:09 <dash>       (if (symbol? e) (meaning-reference e)
09:42:09 <dash>                       (meaning-quotation e) )
09:42:59 <dash> this corresponds to the 'Atom' type i've got near the top
09:44:07 <shapr> skuggi: I know some tutorials in english. Not any swedish though.
09:44:19 <skuggi> shapr: ok... english is fine.
09:44:43 <shapr> Hal Daume's "Yet Another Haskell Tutorial"
09:44:52 <dash> aw man
09:44:54 <skuggi> ok. that's the one i'm reading now
09:44:57 <shapr> are you at chalmers?
09:45:03 * shapr reads dash's code.
09:45:05 <skuggi> nope. you?
09:45:08 <dash> why didn't he name it "Yet Another Concise Haskell Tutorial" or something
09:45:10 <shapr> no, I'm in Boden.
09:45:16 <dash> so you could call it "YACHT"
09:45:18 <skuggi> ok
09:45:28 <shapr> Boden, the mecca for technology!
09:45:33 <skuggi> i live in gbg tho :)
09:45:35 <skuggi> hehe :)
09:45:42 <tic> everyone lives in gbg :)
09:45:52 <skuggi> :)
09:45:53 <shapr> well, ok, Boden isn't really the tech-mecca  (tecca?)
09:46:01 <shapr> Ya know, I really wanna move to gbg :-/
09:46:21 <skuggi> tic: are you at chalmers?
09:46:38 <tic> skuggi, yah
09:46:44 <skuggi> k
09:47:06 <shapr> dash: this code looks pretty good, did you write it yourself?
09:47:10 <dash> yeah
09:47:16 <shapr> nice
09:47:22 <dash> got some help last night from skew on the QAtom/QList bit
09:47:26 <dash> but that was basically all
09:47:44 <dash> well and the parsec tutorial
09:47:59 <shapr> you already know Haskell?
09:48:09 <dash> i've known haskell since like '99
09:48:15 <shapr> ah, way before me :-)
09:48:56 <shapr> looks like you understand monads.
09:49:07 <dash> not really
09:49:09 <dash> but i can fake it
09:49:16 <tic> hah :)
09:49:23 <shapr> monads are easy, you want the quick fix?
09:49:28 <dash> eh
09:49:38 <dash> i just think of it as CPS upside down and on fire
09:49:49 <shapr> hm, that pretty much works.
09:50:02 <dash> btw
09:50:08 <shapr> there's some benefit from the category theoretical view too
09:50:13 <shapr> tried arrows?
09:50:20 <dash> perl people have names for their operators sometimes 
09:50:30 <dash> like, <=> is the 'spaceship operator'
09:50:44 <dash> do hskell people call >>= the 'deathray operator'?
09:50:49 <dash> 'cause if not, you probably should
09:50:54 <bourbaki> :)
09:50:59 <shapr> actually, >>= is the S&M operator.
09:51:02 <dash> heh
09:51:04 <shapr> it's "bind"
09:51:09 <dash> i know ;)
09:51:47 <dash> so anyway i don't see how to put an else clause into a case, or how to unwrap a type without a case
09:51:49 <shapr> arrows syntax look silly at first, feels like some made-up tinkertoy thing
09:52:29 <shapr> expr = proc () -> do
09:52:29 <shapr> 		x <- term -< ()
09:52:29 <shapr> 		expr' -< x
09:53:03 <shapr> I think the combination of <- x -< looks ... unserious or something.
09:53:15 <musasabi> expr' <<< term -< ()
09:53:16 <shapr> like a syntax I would make up while terribly bored.
09:53:35 <musasabi> the whole "-< ()" should be implicit
09:53:59 <shapr> yah, it's just there for clarity.
09:55:18 <dash> so anyway in the code i have now, i get:
09:55:18 <dash> ERROR "arnis.hs":178 - Constructor "AAtom" must have exactly 1 argument in pattern
09:55:41 <dash> i am guessing this means that i have multiple patterns that match AAtom"
09:56:15 <dash> and i am guessing that case doesn't have a way to say "anything but the patterns specified above"
09:56:28 <shapr> @index anyChar
09:56:28 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
09:57:27 <shapr> ah, they're renamed, that's why it confused me.
09:57:49 <dash> yeah, this is code from 2002 :)
09:58:18 <shapr> btw, tried darcs?
09:58:22 <dash> no
09:58:30 <dash> svn does everything i need
09:58:43 <shapr> darcs is worth trying/investigating.
09:59:19 <dash> why so?
09:59:44 <shapr> in short, because it does so much cool stuff for so little effort on your part.
09:59:53 <dash> heh
10:00:36 <shapr> very easy to learn and to use, it seems to treat only the essential difficulties of source control, none of the accidental difficulties.
10:00:58 <dash> so i think my brain is still stuck in dynamic typing land
10:00:59 <shapr> but that's just my opinion, I realize darcs anarchic distributed viewpoint doesn't fit everyone.
10:01:15 <shapr> I'm getting a precedence error
10:01:17 <shapr> with arnis
10:01:21 <dash> huh
10:01:46 <shapr> oh, I think I see.
10:01:48 <dash> if you take out the bits below the line it should work...
10:01:59 <shapr> on line 61, is that (-1) ?
10:02:07 <shapr> this --> (i* -1)
10:02:12 <shapr> i* (-1) ?
10:02:27 <dash> yeah
10:03:32 <musasabi> darcs is very nice.
10:03:42 <musasabi> Easy to learn and keeps the fuss to the minumum
10:03:50 <dash> i ran this with "hugs -98", it seems to work
10:04:06 <shapr> you'll need (-1) with the latest GHC
10:04:14 <dash> strange :) ok
10:04:41 <shapr> you're talking about the "Couldn't match `Symbol' against `Atom'" error?
10:05:01 <dash> huh... no
10:05:12 <shapr> on line 180?
10:05:14 <dash> er rather. that is not what hugs tells me :)
10:05:21 <dash> Yeah.
10:06:23 <shapr> what are you trying to do with that code?
10:07:10 <shapr> meaning evaluates to one of (id sim) or (id e)
10:07:16 <Oejet> What place is gbg?  I would guess Göteborg?
10:08:40 <shapr> greetz Si\
10:09:07 <Si\> hello
10:09:26 <dash> shapr: i just put in 'id' because i wanted to have a definition for the functions :)
10:10:10 <shapr> so, you want a typeclass?
10:10:48 <dash> shapr: you tell me! i have forgotten when typeclasses are called for
10:15:13 <shapr> I don't really know what your code is doing...
10:15:19 <dash> Me neither
10:15:31 <dash> anyway here is the part I am leaving out I guess
10:15:39 <dash> meaning :: ArnisExpr -> Env * Cont * Store -> Val
10:15:51 <shapr> oh
10:15:58 <dash> but i'm a long way from there
10:16:12 <shapr> still useful docs to put at the bottom.
10:16:19 <dash> yea probably
10:16:35 <dash> Hmm
10:17:36 <dash> i'm going off this scheme code as a rough guide: http://ghostwheel.ddts.net/~washort/chap5a.scm 
10:18:16 <dash> i probably just need to get my brain readjusted :)
10:25:30 <shapr> if you want the same function for different types, you want typeclasses.
10:26:09 <dash> hm
10:26:11 <dash> OK
10:27:11 <dash> i think i probably don't want that, then
10:27:28 <shapr> why not?
10:27:41 <shapr> typeclasses are marvelous things.
10:28:25 <dash> looks like more work
10:29:49 <shapr> they're actually really easy.
10:30:03 <shapr> checkit - http://www.haskell.org/hawiki/HaskellDemo
10:30:24 <shapr> btw, I wrote 90% of that, so please mention it if something isn't clear.
10:31:20 <shapr> dash: hey, anything exciting happening in bhm lately?
10:31:29 <dash> not really
10:31:30 <shapr> btw, I'm planning on dropping by next summer.
10:31:45 <dash> cool
10:31:48 <dash> we'll have to get together
10:31:53 <shapr> if you have time and interest we can go get a beer.
10:32:24 <dash> yeah, let me know
10:32:26 <shapr> current plans imply that I'll be taking my unicycle to the US... 
10:32:42 <shapr> because of scheduling weirdness.
10:33:16 <shapr> Anyway, we'll be there for a few weeks centered on july 4.
10:34:00 <shapr> dash: you see the typeclass demo?
10:34:44 <dash> yeah
10:34:50 <dash> OK i am actually havign a different problem 
10:34:59 <shapr> that being?
10:35:10 <dash> mostly that i don't know how to write pattern matching, i guess
10:35:52 <dash> you can write multiple function definitions with different patterns, yes?
10:36:10 <dash> how do you do pattern matching for types created with "data"
10:36:46 <shapr> pattern matching is rewritten as case x of ...
10:36:53 <dash> right
10:37:08 <shapr> so, what do you want to match on?
10:37:18 <shapr> SpecialForm?
10:37:19 <dash> "meaning AAtom e = e" doesn't work, but i have a feeling that something like it should :)
10:37:44 <shapr> "meaning (AAtom e) = e" is correct syntax at least.
10:37:58 <dash> aaah
10:38:01 <dash> OK.
10:38:26 <dash> OK that was the first problem... :)
10:38:30 <dash> let's see if there's others
10:38:31 <shapr> that does constructor matching an unpacking.
10:39:50 <dash> OK so
10:40:14 <shapr> Programming is the Magic Executable Poetry -- shapr
10:40:41 <dash> if i have "data Foo = One x | Two y | Three z" or similar
10:40:52 <shapr> I recently had this crazy idea that I should make lambda calculus fridge magnets and a whiteboard that can execute them.
10:41:10 <peti> Good evening.
10:41:12 <shapr> Guten abend peti 
10:41:18 <shapr> Wie geht es?
10:41:35 <shapr> haben sie gut code? ;-)
10:41:39 <dash> then i should be able to do "case b of One a -> doStuff a; _ -> doOtherStuff b"
10:41:41 <dash> right?
10:41:42 <peti> shapr: Sehr gut, danke der Nachfrage. :-)
10:42:25 <dash> modulo syntax mistakes :)
10:43:06 <shapr> dash: yes, that should work fine
10:43:22 <dash> OK!
10:43:27 <dash> maybe i do actually understand this stuff.
10:46:56 <shapr> I've often wondered if compiler pragmas in logic programming are called pravdas
10:46:56 <CosmicRay> huh, where'd you pick up German? :-)
10:47:20 <shapr> CosmicRay: ich habe keine ahnung ;-)
10:47:46 <CosmicRay> heh
10:47:54 * CosmicRay understands a *little* german
10:48:04 <shapr> Believe it or not, all of my german comes from listening to other people speak german.
10:48:05 <CosmicRay> (had to look up ahnung)
10:48:14 <CosmicRay> feh, I should be great at it then 
10:48:31 <shapr> But after a few hours of listening to Germans in Munich, it got a lot easier.
10:48:33 <CosmicRay> my grandparents always used german when they didn't want us grandkids to understand what they were saying
10:48:40 <CosmicRay> which was frequent. :-)
10:48:44 <shapr> that would *not* work around me :-)
10:48:47 <CosmicRay> heh
10:49:27 <shapr> I picked up a bit of lithuanian at EuroPython 2004
10:49:54 <shapr> that's a strange language, reminds me a little bit of Basque. I wonder if they're related.
10:50:29 * CosmicRay has trouble learning human languages
10:50:43 <CosmicRay> though that may be because it almost impossible to be immersed in anything but English in Kansas
10:50:44 <shapr> google says no.
10:50:48 <CosmicRay> heh
10:50:52 <Igloo> I was always good at the grammar and poor at the vocab
10:51:01 <shapr> "Basque is a language with no known linguistic relatives spoken by about 660,000 people in Spain and France"
10:51:15 <CosmicRay> Igloo: me too
10:51:39 <CosmicRay> Igloo: actually when I took a semester of German, I was OK at the vocab, but the genders were difficult for me to remember correctly
10:52:17 <Igloo> I wonder if I don't have that problem with computer languages because they are smaller or I use them more. Probably both, I guess.
10:52:26 <shapr> Vocabulary is easier if you go at it from an etymological perspective.
10:52:40 <CosmicRay> Igloo: for me, I think it's because I use them.
10:53:10 <CosmicRay> Igloo: I forget them when I haven't used them for a long time.  For instance, with Java, I haven't used it since 2000.  I remember the principles but would have to rely heavily on the API docs to do most anything.
10:53:19 <CosmicRay> or maybe that's the typical java programmer... :-)
10:53:43 <Igloo> Actually, computer languages also probably have more consistency in naming
10:54:02 <shapr> For me, I think it's because my conceptual memory web works very well. That seems to come with the tradeoff that I have no time sense, meaning I rarely know which month it is, what day of the week it is, and nearly always miss appointments.
10:54:31 <shapr> I was 24 years old for two years because I got confused about how old I was :-/
10:54:32 <CosmicRay> hmm, that's interesting.
10:54:54 <CosmicRay> I can figure those things out but it takes some time.  I wear a watch with the date on it.  that helps.
10:54:59 <Igloo> I find it odd how people suddenly, at around the same age, stop just knowing their age but have to think about it
10:55:17 <shapr> it's easier to think of my age in binary for some reason.
10:55:21 <CosmicRay> heh
10:55:23 <shapr> hm, that sounds *way* geeky.
10:55:27 <CosmicRay> yes.
10:55:29 <CosmicRay> yes it does.
10:55:35 <dash> binary?!
10:55:36 <dash> Come on.
10:55:43 <dash> At _least_ use hex.
10:55:54 <shapr> but it's really just that the tighter relationship I can make in head between things, the more likely I'll remember them.
10:56:00 <shapr> base 10 is overused.
10:56:17 <CosmicRay> I think base 3 would be interesting.
10:56:19 <Igloo> Is the best way to learn how to actually cabalise something to look in examples in the cabal source?
10:56:28 <dash> "happy 0x1A birthday" etc
10:56:30 <shapr> Igloo: that's the rumor.
10:56:32 <CosmicRay> Igloo: the hunit example is pretty good
10:56:38 <Igloo> OK, ta
10:56:45 <dash> shapr: Tell me about the haskell cabal.
10:56:46 <CosmicRay> Igloo: I've got about a 20-line Setup.description for MissingH
10:56:55 <shapr> Cale: oh hey, I have a group theory question, do you have a moment?
10:57:10 <Igloo> The simplest base to give your age in is your age, of course
10:57:17 <Cale> shapr: sure
10:57:18 <CosmicRay> Igloo: in fact, I used that hunit example to package hunit
10:57:23 <CosmicRay> Igloo: so you're always 10? :-)
10:57:29 <shapr> dash: "The Common Architecture for Building Applications and Libraries" aka, distutils for haskell. 
10:57:30 <Igloo> Exactly  :-)
10:57:40 <CosmicRay> wb dash
10:58:08 <shapr> Cale: is there any group theory for n-dimensional quasi-tiles? like, 3 dimensional penrose tiles?
10:58:30 <shapr> also, we discussed that equation that can find tiling shapes in any dimension. Does that exist for quasi-tiles as well?
10:58:37 <CosmicRay> dash: syntaxninja is the main guy behind cabal
10:58:51 <Cale> shapr: well, anything which exhibits symmetry, you can describe that symmetry with a group
10:58:55 <CosmicRay> dash: the eventual goal is to make it an uber-builder of sorts.  can build binaries or libraries using ghc, hugs, or nhc98
10:59:02 <CosmicRay> dash: right now it works with ghc and hugs
10:59:06 <CosmicRay> ghc6 anyway.
10:59:16 <CosmicRay> dash: we are also standardizing on it at debian
10:59:23 <Cale> I don't really know much about tilings, per se.
10:59:25 <CosmicRay> dash: www.haskell.org/cabal
10:59:40 <CosmicRay> Cale: me neither.  we don't even have tilings in our bathroom.  :-)
10:59:56 * CosmicRay goes for the bad pun award
11:00:52 <shapr> Cale: I was just thinking that quasi-tiles might be a good avenue for parallel architectures. You know how the butterfly/hypercube is the spiffy way to do parallel organizations?
11:01:03 <Cale> yeah
11:02:02 <shapr> I wonder if the whole deal with 2-D quasi-tiles being important in superconductors is related to the reasons braided silver wire is a better conductor than solid silver wire.
11:02:08 <CosmicRay> so dash, what has kept you still looking at Haskell? :-)
11:02:13 * shapr suspects that theory ranks with ufo sightings
11:02:41 <dash> CosmicRay: it's much harder to dismiss offhand as other non-python/lisp/smalltalk languages
11:02:48 <dash> s/as/than/
11:02:56 <CosmicRay> dash: because it has real practical applications?
11:03:16 <dash> CosmicRay: I'm convinced it's good for _something_, i'm just not completely sure what
11:03:31 <dash> there are lots of langauges with real practical applications that are easy to dismiss offhand
11:03:37 <CosmicRay> oh right, Java.
11:03:40 <dash> C++, PHP, etc.
11:03:41 <CosmicRay> :-)
11:03:52 <dash> nah, Java isn't too bad, overall
11:03:56 <CosmicRay> dash: you may also be interested in OCaml
11:03:57 <dash> no
11:03:58 <shapr> dash: is too
11:04:01 <dash> i am not interested in ocaml
11:04:08 <dash> shapr: there's worse
11:04:08 <CosmicRay> ok then.
11:04:16 <dash> anyway
11:04:23 <shapr> sure, manual memory allocation sucks.
11:04:28 <CosmicRay> dash: yeah, there's worse, but of popular languages, I can only think of worse ones coming from Redmond
11:04:35 <dash> CosmicRay: PHP, C++
11:04:38 <CosmicRay> ok.
11:04:40 <CosmicRay> point.
11:04:44 <dash> CosmicRay: perl
11:04:50 <shapr> but Java the language is rough. Java the standard libs is schizophrenic, and Java the VM is constricting.
11:04:54 <dash> hehe
11:05:06 <dash> well, there's always C#
11:05:07 <CosmicRay> dash: I think Java is worse than perl.
11:05:10 <dash> Anyhow
11:05:21 <dash> CosmicRay: java at least has exceptions and strong typing
11:05:30 <dash> (and jython for when you want to cheat)
11:05:35 <shapr> I want firm typing :-/
11:05:46 <CosmicRay> exceptions good.  java's typing isn't just strong.  It's suffocating.
11:05:57 <shapr> Java typing isn't that strong.
11:06:02 <dash> well the static checker is dumb 
11:06:03 <shapr> at least, not in popular useage.
11:06:05 <Lor> java's type system provides the worst of both worlds: they provide no real static guarantees but they still constrain the programmer all the time.
11:06:12 <shapr> Lor: yes, exactly!
11:06:16 <CosmicRay> shapr: because everybody casts to Object to get around it?
11:06:24 <CosmicRay> lor: yup
11:06:25 * dash blinks
11:06:32 <Lor> With 1.5 it's a little better.
11:06:37 <dash> we are talking about the same thing, right?
11:06:38 <shapr> everybody casts to Object to make heterogenous collections.
11:06:45 <dash> i mean, python/lisp/smalltalk have strong typing too
11:07:01 <CosmicRay> dash: haskell too.
11:07:02 <Lor> Depends on your definition of typing.
11:07:14 <dash> ANYHOW so what i'm writing at the moment is a lisp interpreter based on chapter 5 of Queinnec's book "Lisp in Small Pieces" which does everything via denotational semantics and stuff
11:07:18 <Lor> One school of thought equates "typing" with "static typing"
11:07:28 <dash> he's got a scheme impl but i figured i'd do it up proper
11:07:32 <CosmicRay> heh
11:07:40 <dash> well
11:07:47 <dash> here is the comment at the top of the scheme file
11:08:04 <dash> ;   Meaning  : Form -> Env * Cont * Store -> Val
11:08:04 <dash> ; r   Env    : Var -> Loc
11:08:04 <dash> ; s   Store  : Loc -> Val
11:08:04 <dash> ; k   Cont   : Val * Store -> Val
11:08:04 <dash> ; v   Val    : Fun | Int | Pair
11:08:04 <dash> ; f   Fun    : (Val...) * Cont * Store -> Val
11:08:07 <dash> ;     Cons   : Loc * Loc
11:08:09 <dash> ; e   Form
11:08:18 <dash> that suggested certain ideas to me 
11:09:27 <dash> the goal is to extend it with some experimental features and see if i can get haskell to tell me when i'm doing them wrong
11:09:34 <Lor> http://www.appsolutions.com/SchemeDS/
11:10:04 <dash> i'm not doing scheme, though
11:10:35 <dash> and anyway i've got the book for this stuff
11:14:14 <dash> hmm
11:14:22 <dash> now, how far does this currying thing go
11:15:20 <dash> if i have data Foo = One X | Two X | .... 
11:15:20 <Lor> "far"?
11:16:30 <dash> then if I have "case a of someFoo { One x -> doStuff x; Two x -> doOtherStuff x; ...}
11:16:59 <dash> "does that collapse to "case a of someFoo { One -> doStuff; Two -> doOtherSTuff; ..}"? 
11:17:00 <dash> :)
11:17:40 <Lor> what's "someFoo" here?
11:18:02 <dash> something of type Foo
11:18:07 <Lor> What's "a" then?
11:18:47 <Lor> Anyway, the answer is no.
11:18:56 <peti> dash: I think you mean: case a of { One x -> doStuff x; Two x -> doOtherSTuff x; }
11:19:04 <Lor> There are languages where pattern matching is done the latter way, but it is very inconvenient.
11:19:39 <Lor> (Older versions of coq come to mind, also several intensionally polymorphic calculi)
11:20:34 <dash> oh well :D
11:35:17 <marcot> shapr: Good Afternoon. Earlier you sad that haskell-mode for emacs don't work well with "foo --", what do you mean by that?
11:39:44 <shapr> marcot: try it with ["foo--","bar"]
11:41:37 <marcot> shapr: you mean that it consider the rest of the line as a comment?
11:41:44 <shapr> yup
11:41:52 <marcot> shapr: not hear.
11:41:54 <stepcut> annoying 
11:41:56 <marcot> here
11:41:59 <marcot> sorry... =)
11:42:22 <marcot> shapr: Are you using 1.45?
11:42:54 <shapr> no, 1.44
11:44:19 <marcot> shapr: this seems to be correct in 1.45. I'll check it with my debian at home, there I use 1.44.
11:44:34 <marcot> shapr: have you taked a look at that bug I've commented about?
11:45:04 <shapr> I got distracted, but I'm looking at it now
11:45:28 <marcot> shapr: Ok, thanks.
11:52:11 <shapr> hoi Jan_w 
11:52:17 <Jan_w> hi shapr
11:53:19 <Jan_w> any winhugs users ? I've set the heapsize for winhugs too high,  (200000000 bytes or so) now winhugs won't start anymore, reinstall picks up my config again :(, can
11:53:29 <Jan_w> find the .ini file so simular
11:57:54 <Jan_w> oh sound it, registy entry 
12:00:10 <shapr> marcot: I'm pretty sure it's the regex on line 177 of haskell-font-lock.el
12:00:32 <marcot> shapr: have you already tried without it?
12:01:28 <shapr> in fact, this misfeature is documented there.
12:02:21 <marcot> shapr: what does it sais about that?
12:02:56 <marcot> shapr: here in 1.45 it's probably in another line.
12:03:15 <marcot> shapr: actually I think is this line.
12:05:34 <marcot> shapr: I've commented this line here, and the highlighting stoped working, but the problem persist.
12:20:07 <shapr> it's the sexp definition that's the problem.
12:21:00 <earthy> that sounds like a predicate determining if you wanna have sex or not
12:21:15 <shapr> s-expression :-P
12:21:23 <earthy> yeah, I know ;P
12:21:42 <marcot> shapr: Any idea of how to fix it?
12:21:45 <earthy> but watching `Revenge of the Nerds' kinda rots the brain ;)
12:22:10 <CosmicRay> heh
12:24:08 <shapr> marcot: yes, find the s-expression definition in haskell-mode and fundamental-mode, understand the differences enough to make haskell-mode not treat \( like an escaped paren.
12:25:32 <marcot> shapr: how can I search for the s-expression? How do I recognize one?
12:25:39 <shapr> I don't know :-)
12:25:49 <shapr> it should be building a syntax table somewhere
12:25:56 <shapr> but I don't really see where it's doing that.
12:26:08 <shapr> but then, this is why I want an editor written in Haskell ;-)
12:27:03 <stepcut> shapr: I had another idea for yi. In addition to syntax highlighting, it could also do typo-correction 
12:27:48 <stepcut> so If I define data DBError = DBError String, but then try: throwDyn (BDError "whee"), it could note that BDError is not a valid constructor 
12:27:49 <sorje> Oh, and tab completion! 
12:28:05 <stepcut> yeah!
12:28:49 <marcot> shapr: anyway, I sent an e-mail to simonvar.
12:29:15 <shapr> ok
12:31:25 <shapr> It's sad that I can drink a Red Bull and still want to fall over asleep.
12:31:49 <shapr> I'll take the shocking option...
12:31:50 * shapr goes to sleep
12:33:09 * Oejet is poking to shapr with a crooked stick.
12:33:52 <Oejet> shapr: Wake up, wake up.
12:35:28 <musasabi> hmm have to go away from irc for the weekend for the most part.
12:35:42 <musasabi> seing some friends and having a meet @ Tampere.
12:36:20 <sorje> Oh, shapr sleeps, you're going to stay away from IRC. The world must have come to an end..
12:37:32 * Oejet have seen this day coming for ages, because he is good at seeing things.
12:37:56 <dash> do i have time for a sandwich
12:38:42 <sorje> Yeah, there's always some lunch at the end of things.
12:39:37 <marcot> instance Visible Int where
12:39:48 <marcot>     toString = converte
12:39:48 <Oejet> Apocalypse is coming, run people, run.  Forget you ever learned Haskell, and never look back; that is the only way to survive the Great Catastrofe.
12:39:53 <marcot>     size _ = 1
12:40:06 <marcot> converte :: Int -> String
12:40:17 <marcot> class Visible a where
12:40:24 <marcot>     toString :: a -> String
12:40:33 <marcot>     size :: a -> Int
12:40:46 <marcot> When I load it with hugs, it works fine
12:40:49 <sorje> And take a seat at the restaurant at the end of the world and enjoy the show!
12:41:13 <marcot> But when I do toString 0, it gives me the error:
12:41:20 <marcot> ERROR - Unresolved overloading
12:41:26 <marcot> *** Type       : (Num a, Visible a) => [Char]
12:41:32 <marcot> *** Expression : toString 0
12:42:00 <marcot> Can someone help me?
12:42:23 <Oejet> marcot: Try: toString (0::Int)
12:42:49 <marcot> Oejet: thank you!
12:43:06 <marcot> Oejet: Why doesn't hugs consider my 0 an integer?
12:43:23 <Oejet> I don't know, I just guessed :-P
12:43:49 <sorje> You must know, he is good at seeing things. ;-)
12:43:57 <tic> maybe it's Succ Zero? :)
12:44:49 <marcot> It gives the same error with every integer I've tried.
12:45:16 <Oejet> But I think 0 is of type "Num" and also of type "a".  Thus it could be both instances.
12:45:53 <Oejet> With no way to choose "Num" over "a" wisely.  But again, I just "saw" is ;-)
12:46:08 <sorje> Heh ;-)
12:46:37 <marcot> Oejet: are you talking seriously?
12:46:58 <arjanb> all Integer constants in haskell are  fromInteger theNumber
12:47:10 <arjanb> @type fromInteger
12:47:11 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
12:48:42 <marcot> arjanb: thank you.
12:50:08 <Oejet> marcot: Yes, though I had similar some similar problems with Bits.bit :: forall a. (Data.Bits.Bits a) => Int -> a, where I wanted a to be Int64.
12:51:14 <Oejet> (Ok, not exactly that, but with some bit functions)
12:51:36 <marcot> Oejet: that's too advanced haskell for me.
12:54:39 <Oejet> @eval Bits.bit 4
12:54:39 <lambdabot> <<EM Dynamic -> EM Dynamic>>
12:54:55 <Oejet> marcot: Try that.
12:56:37 <Jan_w> filterWord :: String -> String
12:56:37 <Jan_w> filterWord (a:as)
12:56:37 <Jan_w>  | elem a wordSet 	= a:(filterWord as)
12:56:37 <Jan_w>  | otherwise 		= filterWord as
12:56:59 <Jan_w> pattern match failure: filterWord [] ?
12:57:34 <Jan_w> what does that mean "pattern match failure"
12:57:45 <arjanb> (a:as) cannot match []
12:57:45 <Jan_w> its occurs runtime
12:57:52 <Jan_w> OH
12:57:56 <Jan_w> i see!
12:58:20 <Jan_w> :r
12:58:23 <Jan_w> whoops :)
13:01:41 <Jan_w> ok
13:01:46 <Jan_w> filterWord :: String -> String
13:01:46 <Jan_w> filterWord a
13:01:46 <Jan_w>  | a == []	= "" 
13:01:46 <Jan_w>  | elem (head a) wordSet  = [head a] ++ filterWord (drop 1 a)
13:01:46 <Jan_w>  | otherwise 		  = filterWord (drop 1 a)
13:01:48 <Jan_w> wroks
13:02:17 <Jan_w> but I'd rather use (a:as) to take the first element
13:02:25 <Jan_w> how can i do that ?
13:03:31 <tromp> filterword [] = ""; filterword (a:as) = ...
13:03:41 <stepcut> yeah, what tromp said...
13:05:54 <Oejet> yeah, what stepcut said...
13:06:30 <Jan_w> ofcourse, stupid me
13:10:30 <tromp> yeah, what Jan_w said...
13:10:37 <tromp> :-P
13:12:34 <tromp> or better yet, filterword = filter (`elem` wordSet)
13:12:39 <stepcut> heh
13:12:59 <tromp> people are always re-implementing library functions:)
13:14:53 <tromp> @index elem
13:14:54 <lambdabot> Data.List,GHC.List,Prelude,List
13:15:21 <Oejet> tromp: In Java people, I think, are not alway implementing library functions. I don't know what that means, though.
13:16:31 <tromp> java's standard containers are rather clumsy in use
13:17:01 <tromp> many ppl define their own just to avoid casting back/forth to Object
13:17:53 <Lor> 1.5 ought to fix that, at least.
13:18:04 <Lor> Well, pizza and gj fixed it ages ago already.
13:19:05 <Oejet> Lor: Yes, but people use pure Java for a reason.
13:19:38 <Lor> Yes, because they aren't aware of any alternatives.
13:20:13 <tromp> so does Java have a filter function defined for ArrayList?
13:20:22 <arjanb> they are aware but dismiss them as scary
13:20:54 * Oejet surfs to the EVIL site.
13:21:37 <arjanb> tromp: no Java doesn't have higher order functions :(
13:22:31 <tromp> sure they do, but it usually requires extra code, like defining a FilterPredicate interface
13:23:07 <tromp> ok, that's cheating, i admit.
13:23:35 <Oejet> tromp: It doesn't seem that they have a filter on ArrayList.
13:23:36 <tromp> instead of function arguments, they take interface arguments through which u call a function
13:23:59 <tromp> requiring you to name the function
13:24:26 <tromp> that's what makes java programming so painful
13:24:39 <Oejet> public boolean removeAll(Collection c)
13:24:39 <Oejet>     Removes from this collection all of its elements that are contained in the specified collection (optional operation).
13:25:00 <Maddas> tromp: You mean to create a class?
13:25:11 <Lor> Anonymous classes ease the pain a little.
13:25:19 <Lor> Syntactic tricks (a la pizza) help some more.
13:25:49 <tromp> i mean for every use of the higher order function, u must implement the Interface, perhaps in an anonymous class
13:26:48 <tromp> so Oejet, that means to filter, you need to transform the predicate into a collection for its negation
13:27:23 <tromp> so it take 3 lines of code or more what haskell does in 3 words:(
13:27:40 <Lor> new Fun(){ public Object call(Object o){...})
13:27:46 <Lor> It's a pain, but not quite unbearable pain.
13:28:27 <tromp> is Fun the Interface?
13:28:36 <emu> ahhh! stop pasting java code
13:28:40 <emu> my eyes are burning
13:28:57 <emu> the pain it took to write, the waste of effort
13:29:13 <Lor> Hey, that's nothing compared to C++.
13:29:18 * emu drops dead
13:29:30 <Oejet> emu: Atsiprasau (appologize in Lithuanian).
13:29:37 <tromp> i once had to develop someone else's C++ code.
13:29:44 <tromp> the horror..... the horror..................
13:30:10 <tromp> moving to Java seemed such a relief:)
13:30:12 <Oejet> tromp: And the movie at least ended when he said that ;-)
13:38:43 <stepcut>  are there any key combinations I can press other than ^C, ^Z, or ^Y that will raise a signal ?
13:39:16 <tromp> control-backslash
13:39:22 <stepcut> what is that one ?
13:39:31 <tromp> no idea:(
13:40:15 <tromp> maybe google knows
13:40:55 <stepcut> SIGQUIT i think
13:41:00 <stepcut> http://osr5doc.ca.caldera.com:457/cgi-bin/man/man?keyboard+HW
13:41:37 <tromp> if you send it to sleep 10 it returns "Quit"
14:36:21 <Lemmih> Yay. Another step in the right direction.
14:38:59 <goron> Does anyone knows what's the inverse of the irssi command /channel ADD -auto ?
14:41:17 <Lemmih> /channel DEL -noauto?
14:41:30 <Lemmih> (o:
14:44:01 <goron> I tried /channel DEL -auto :-)
14:44:06 <goron> Thanks. 
14:44:11 <goron> Where did you find that?
14:44:54 <Lemmih> I was actually just joking.
14:47:09 <goron> Lemmih: I also considered that option, but I thought the probability of you telling something useful was quite high. Thanks for the joke, though. :)
14:48:05 <goron> At least I have autojoining for #haskell. And my layout is ok. :)
14:48:31 <Lemmih> Yay and hello peti.
14:55:05 <peti> Lemmih: Hi! 
14:55:19 <Lemmih> What's up?
14:55:41 <peti> Taking a break. I've been writing documentation. Bah. :-)
14:56:23 <peti> What is always a bit frightening is when you want to document a function you've written a week ago, and then you realize you don't really know what it does yourself anymore. 
14:56:33 <Lemmih> Heh.
14:56:37 <Oejet> Should the Network library has a ceartain flag, when compiling with GHC?
14:56:48 <Oejet> s/has/have
14:57:06 <peti> I've written a version of C's strstr for lists. And I just spent ten minutes looking at it and wondering whether it returns the position _after_ the string it found or before the string.
14:57:08 <peti> Weird.
14:57:24 <Lemmih> Oejet: No. What kind of error is it throwing?
14:57:39 <peti> Oejet: If you have ghc 6.x, then you don't need any additional parameters to compile it.
14:58:06 <Lemmih> And if you have ghc < 6.x then it's time to upgrade (-:
14:58:48 * peti is compiling CVS HEAD in another window as we chat. :-)
15:00:21 <Oejet> : undefined reference to `NetworkziSocket_withSocketsDo_closure'
15:00:21 <Oejet> collect2: ld returned 1 exit status
15:00:45 <Oejet> And ten lines preceding the same way.
15:01:32 <Lemmih> GHC version?
15:01:42 <Oejet> B.t.w it works in GHCi.
15:01:57 <Oejet> ghc-6.2.1
15:02:17 <Lemmih> Weird indeed.
15:02:39 <peti> Oejet: Does "ghc-pkg -l" show the network package?
15:02:58 <Oejet> network
15:04:20 <peti> Oejet: Hmm. You could try compiling with "-v". Then you get loads of debug output. 
15:04:40 <peti> Oejet: If in doubt, try adding "-package network" on the command line, too. You never know ...
15:06:22 <Oejet> "-package network" worked.  Thanks, peti.
15:07:14 <Lemmih> Why is that not required when using ghci?
15:07:49 <Oejet> Good question, Lemmih.
15:08:14 <peti> Oejet: Does a file .ghci exist in the current directory, by any chance?
15:09:29 <Oejet> peti: No.
15:10:44 <peti> Weird. Either your package description file has a problem, or there is some environment variable / shell script magic going on we don't know about. Specifying the -package flag should not be necessary.
15:11:50 <peti> Oejet: Did you compile GHC yourself or are you using a binary version that comes with a Linux/whatever distribution? And which one, in case of the latter?
15:12:09 * Oejet trying to translate some Java network exersices he had today into Haskell.  It goes pretty well.
15:12:22 <Oejet> peti: Compiled myself.
15:12:59 <peti> Oejet: Then I don't know what causes that either. Sorry.
15:13:18 <Oejet> peti: That is from source with a GoboLinux recipe (I made myself :-) ).
15:13:45 <peti> Never heard of GoboLinux. :-)
15:14:39 <Oejet> peti: It will become the distro of choice for Haskell hackers ;-) A bit like Debian is today with Lisp.
15:16:25 <peti> Oejet: I see. Well, I'll be hard to convince to give up my Gentoo. :-)
15:18:45 * Philippa is still waiting for somebody to show her how to get a desktop (plus program interaction with it) that she finds more usable than windows
15:19:03 <Philippa> let me put this in perspective: as far as I'm concerned, windows is one steaming pile of mediocrity
15:19:26 <Lemmih> 'apt-get install gnome' should do the trick.
15:19:43 <Oejet> peti: Funny, then there is a good chance, you'll like GoboLinux.
15:19:53 <Philippa> anything of note I'll find improved over the other stuff I've tried?
15:20:15 <peti> Oejet: What is the advantage over Gentoo?
15:20:38 <flaw> its not gentoo?
15:20:41 <flaw> (;
15:21:00 <peti> flaw: That's it the eye of the beholder.
15:21:12 <peti> Philippa: Bye a Mac.
15:21:27 <Philippa> peti: I've not seen enough Mac-based stuff I like either
15:21:28 <Oejet> peti: Simplicity. Both in package management and file hieracky.
15:21:45 <flaw> peti: have you seen gentoo's IRC bug?
15:22:00 <peti> flaw: No, what is it about?
15:22:01 <flaw> feature request, rather (;
15:22:05 <monochrom> My next laptop will be a Mac, a Power Book.
15:22:14 <Philippa> yeah, they seem nice machines
15:22:34 <flaw> http://bugs.gentoo.org/show_bug.cgi?id=35890
15:22:38 <Philippa> I've just yet to be shown things like a text editor I'll like, or IRC and IM clients that fit the way I like to work
15:22:43 <peti> Oejet: I don't know ... _All_ distributions started out simple. And they all ended up being complicated. I think that's for a reason.
15:23:10 <Philippa> "Real OSes are complicated"?
15:23:16 * flaw hugs freebsd
15:24:16 <peti> flaw: There doesn't appear to be much substance to that "bug report".
15:24:31 <Oejet> peti: You have a point. :-)
15:25:00 <flaw> peti: that's good geek comedy there
15:26:28 * peti thinks people should user whatever allows them to get their work done best.
15:26:55 <peti> s/user/use/, obviously
15:27:13 <Philippa> yep. Now if only I can have windows with the UI tweaks /I/ want to make and without all the security holes and the shitty APIs and... er :-)
15:28:22 <Oejet> peti: Many recipes need only be two lines long.
15:29:14 <peti> Oejet: How to you control the build flags then? CFLAGS, CXXFLAGS, stuff like that. And can you control which ./configure options are set or not set?
15:29:15 <Philippa> Lemmih: will try gnome next time I boot Debian, may be a while though
15:31:09 <Oejet> peti: Mmm, don't now much about that. It's possible to some degree.
15:32:43 <peti> Oejet: That's what causing most of the trouble in Gentoo. The recipes start out with two, maybe five lines, and then someone needs to set --enable-xxx, the next guy has a different gcc that needs a patch applied to the sources, etc. And before you know it, the recipes were better written in literate programming style. :-)
15:33:41 <Oejet> peti: Yeah, and then you are better of compiling yourself from scratch, if you have the routine.
15:34:34 <peti> Oejet: Happens more often than not, unfortunately. 
15:34:46 <Oejet> I guess the only reason people don't want to (configure; make; install) is to have the package files fit better in the system.
15:35:18 <Oejet> And administering those files of course.
15:35:19 * peti likes Gentoo because they are _very_ quick at getting security patches out.
15:35:41 <peti> That's where using a package system pays off. 
15:36:05 <peti> If I had to track and recompile all that myself, then I most likely wouldn't be doing it.
15:36:26 <Oejet> GoboLinux does not really have a package system.
15:36:42 <peti> Oejet: Do you have an URL for the project?
15:36:54 <Oejet> www.gobolinux.org :-)
15:37:15 <peti> Wouldn't have guessed it. :-)
15:37:43 <Oejet> But be careful, you might not like some of the ideas.
15:37:52 <peti> I'll take a look at it. Thanks.
15:38:12 <peti> And now ... I'll write more documentation. Bah.
15:38:15 <peti> Take care!
15:47:58 <dons> ÿmoin
15:48:19 <peti> Oejet: Hey, I like GoboLinux. :-)
15:48:22 <stepcut> moin
15:48:43 <tuomov> I like application directories but I don't like /MarketdroidNaming
15:48:58 <tuomov> stick short and simple lower-case names, please
15:49:02 <peti> tuomov: That's what I thought.
15:49:22 <stepcut> what about spaces in directories names ?
15:49:32 <tuomov> spaces are also evil
15:49:37 <tuomov> especially spaces
15:49:38 <peti> I have been installing software like this for ages, only I call it /usr/local/ghc, not /programs/maybe/maybenot/link/linksomewhereelse ...
15:49:54 <tuomov> does funny things with scripts that are not carefully written
15:50:04 <stepcut> tuomov: yeah, because unix is broken piece of crap :p
15:50:23 <tuomov> it's just how sh expands stuff
15:50:32 <tuomov> i="foo bar"
15:50:39 <tuomov> ls $i -> ls foo bar
15:50:43 <tuomov> ls "$i" -> ls "foo bar"
15:51:35 <tuomov> and even if everyone understood to write their scripts properly, spaces are still annoying on the command line because you need to escape them
15:51:46 <stepcut> haven't spaces been valid in unix for like 30+ years, you think people would learn 
15:51:48 <Oejet> peti: Did you look at the recipe collection. I think, I make most of the Haskell related recipes.
15:52:07 <tuomov> Same with LongMarketdroidNames; even if the shell could tab-complete them from lower-case, they make the command line long and harder to read
15:52:13 <stepcut> tuomov: not in cmd.exe :p
15:52:22 <tuomov> cmd.exe is a joke
15:52:30 <tuomov> of a shell
15:52:41 <stepcut> yeah, but atleast you don't have to escape spaces :p
15:52:50 <tuomov> stepcut: spaces are valid, but not often used
15:53:11 <peti> Oejet: I didn't look at in detail, no. I read the FAQ and some other documents, and I agree with most of what the guy wrote. I just don't agree with organizing a system like that. I thought the purpose of building software _custom_ for your system is that you don't _need_ symlinks. I certainly won't start scripts that create them in the dozen. ;-)
15:53:41 <tuomov> other than that naming aspect, I'm all for an app-directory based system
15:53:52 <tuomov> the current all-in-one-basket is a nightmare esp. with gcc search paths
15:54:30 <tuomov> there's no easy way to select a particular version of a library if the library base names and header names are not versioned and so on
15:55:21 <tuomov> infact, I'd go as far as allow multiple distribution on the same system
15:55:27 <peti> What baffles me is that people don't understand that you simply don't need to have a single /usr/bin or whatever it's called. That's what $PATH is for. Same with includes and libraries. That's what C_INCLUDE_PATH, etc. is for! People should stop symlinking around like maniacs. The very idea that you need _scripts_ to manage all your symlinks is bizarre.
15:55:36 <tuomov> e.g. /debian-unstable for stuff from unstable debian and so on
15:55:59 <tuomov> peti: it may be more efficient to have the binaries in one place for search.. but you can just symlink them
15:56:14 <Oejet> /Programs/GHC/6.2.1/lib/ghc-6.2.1/libHSQuickCheck.a
15:56:34 <tuomov> /pkg/ghc-6.2.1/ rather
15:57:00 <tuomov> then you could install tarballs as well simply by extracting them in /local
15:57:08 <tuomov> +binary
15:57:26 <peti> tuomov: I doubt the performance is any difference. Where I have to search the PATH other people have to dereference symlinks. It's probably all the same.
15:57:39 <peti> And probably irrelevant with today's machines, too.
15:57:53 <tuomov> ~$ ls /usr/bin/*| wc -l
15:57:53 <tuomov> 2711
15:58:04 <tuomov> that's quite a lot of diretories to scan..
15:58:20 <Oejet> peter@eigil ~]ls /usr/bin/*| wc -l
15:58:20 <Oejet> 2018
15:58:26 <peti> tuomov: Yeah, but each of them contains just one file.
15:58:43 <tuomov> the directories may be scattered all around the disk
15:58:54 <peti> tuomov: So may be the entries of your single, big one.
15:59:12 <tuomov> possibly, but there's still less entries to read
15:59:23 <tuomov> you don't have to scan down a directory tree
15:59:23 <peti> The total number of entries to read is identical.
15:59:50 <stepcut> umsdos chokes if you have two many files in a directory, so it would probably behave better :)
15:59:55 <tuomov> symlinks don't really help in that case, though
15:59:59 <tuomov> maybe hard links..
16:00:06 <peti> tuomov: You don't have to scan at all, because those whopping 20kb of data are in momery after the first search.
16:00:42 <tuomov> for a while
16:01:03 <tuomov> I just tab-completed and my disk started making noises
16:01:03 <peti> tuomov: My installed packages don't change on a per-minute basis.
16:01:10 <tuomov> took a few seconds
16:01:25 <Oejet> Oh, no I feel like a troll again!
16:02:05 <tuomov> but it's not a big problem
16:02:11 <tuomov> the mess of the current hierarchy is
16:02:25 * peti thinks it doesn't make a difference. If you start an application like Mozilla, finding the executable will not be the significant part of that effort.
16:02:46 <Oejet> P.S.  A good place to discuss such things might be #gobolinux  ;-)
16:02:59 <peti> Hehe.
16:03:07 <tuomov> but they're doing it wrong and the faq indicates that they don't want to do it right
16:03:23 <peti> We don't discuss with people who don't know Haskell. :-)
16:03:24 <tuomov> (wrt. naming)
16:03:48 <Oejet> :-)  I see.
16:04:03 <tuomov> there are problems with unix, but they way to fix is not to make it MoreLikeWindows
16:04:06 <peti> When Cabal is ready, all other forms of distributing software are _dead_. Mark my words. :-)
16:04:19 <tuomov> as the current trend seems to be
16:04:25 <tuomov> that just breaks it further
16:05:30 <peti> Although ... thinking about Cabal ... I'd love to see someone maintain that "complete list of all compiler extensions" enum for GCC instead of GHC. :-)
16:05:37 <tuomov> (and yes, I do not like thisKindOfFunctionNames either.)
16:05:50 <tuomov> (I prefer this_kind_of_functions.. mixed-case is for types)
16:06:31 <peti> tuomov: Underscores mean that I have to do one key-press more. :-)
16:06:38 <Oejet> tuomov: Me too. Reminds of J... 
16:06:40 <tuomov> but it is easier to read
16:07:22 <dash> it is time for more code of dubious usefulness!
16:07:35 <peti> I tend to use mixed case when there is a common prefix. E.g. adnsInit, adnsClose, etc. I think that makes it easier to read than adns_init, adns_close.
16:08:17 <tuomov> maybe that should be adns.init etc.?
16:08:18 <peti> But how I name what is usally an ad-hoc decision. 
16:08:36 <tuomov> given a language with some sort of namespaces
16:08:49 * Oejet wishes that scheme naming could be used.
16:09:00 <tuomov> this-kind-of-functions are prettier indeed than underscored
16:09:02 <peti> tuomov: I should be, yes. But it's a problem what you have adnsInit, fooInit, barInit all in the same module and don't want to break it up.
16:09:08 <tuomov> but it doesn't fit infix notation
16:10:07 <peti> The module system is the only part of the Haskell language that I am really not happy with.
16:10:23 <tuomov> I'd prefer lower-case module names..
16:11:04 <peti> Oh well ... that doesn't bother me. I'd much rather not have an artificial "root" in the namespaces.
16:11:41 <peti> I'd like to have the quivalent of ".." for referencing modules as "Up.Foo.Bar", relative to where I am in the namespace.
16:12:15 <peti> Oh, and modules should be first-order citizens, naturally. :-)
16:15:20 <wolfman8k> hello
16:15:53 <Lemmih> Hey wolfman8k
16:15:55 <wolfman8k> i tried typing these haskell lines into hugs
16:15:56 <wolfman8k> http://www.frank-buss.de/challenge/solutions/dirk.haskell.txt
16:15:59 <wolfman8k> but it doesn't work :(
16:16:43 <Lemmih> How so?
16:17:45 <wolfman8k> gives errors
16:18:07 <Lemmih> Did you save it as a literate haskell script and load it or did you just copy&paste into Hugs?
16:18:17 <Lemmih> Which errors?
16:18:17 <Oejet> Why does the imports have to be in the beginning, when all other declarations can be mixed?
16:18:33 <Oejet> (Besides the compiler saying so)
16:23:06 <wolfman8k> Prelude> import List
16:23:06 <wolfman8k> ERROR - Syntax error in expression (unexpected keyword "import")
16:23:31 <dash> mmh. i keep thinking "surely someone smarter than I must have written code to do this already"
16:23:53 <dash> (i'm trying to write a parser for a lisp interpreter. currently i am stuck on backquote :)
16:23:59 <monochrom> That does not imply the code is released.
16:25:02 <marcot> Good night..
16:25:05 <Lemmih> wolfman8k: You have to save the code in a file and then load it.
16:25:11 <wolfman8k> why?
16:25:23 <dash> 'cause haskell sucks
16:25:41 <wolfman8k> :O
16:26:08 <Lemmih> I assume that was a joke.
16:26:10 <dash> everything does, somehow. that's just where it came out for haskell ;)
16:27:11 <wolfman8k> even python allows me to interactively run all code!
16:27:42 <Lemmih> Saying Haskell sucks because an implementation doesn't do what it wasn't designed for is hardly logical.
16:27:45 <bourbaki> if youd write an interpreter for haskell you could do that with haskell also :)
16:27:57 <dash> wolfman8k: yeah, but python sucks in other ways
16:28:00 * dash shrugs
16:28:04 <bourbaki> just use :reload
16:28:05 <Lemmih> wolfman8k: So does Hugs. You just have to save the code in a file.
16:28:20 <wolfman8k> isn't hugs supposed to be an interpreter though?
16:28:37 <Lemmih> wolfman8k: Hugs in an interpreter. Why do you think it isn't?
16:28:49 <wolfman8k> it doesn't seem to be able to run some basic code
16:29:07 <Lemmih> wolfman8k: You just have to save the code in a file first.
16:29:53 <dash> Lemmih: why's the interactive loop crippled?
16:29:59 <bourbaki> there is not much difference if you write the code in the file and reload it or if you dynamically add the fn in the interpreter
16:30:33 <bourbaki> i came from lisp as well and had a bit of a problem with that at first but its not that dramatical really
16:30:37 <dash> exactly, so why doesn't it let you do everything at the prompt?
16:30:59 <bourbaki> you can write that in haskell
16:31:08 <Lemmih> dash: It's not crippled. It's a read-eval-print loop.
16:31:31 <dash> Lemmih: that doesn't answer my question, though :) why are there things you can't type at the prompt?
16:31:51 <dash> it's not because hugs cannot do them, obviously
16:31:58 <bourbaki> dash you rever to the lisp thing that you can interpret strings as code right?
16:32:20 <dash> bourbaki: Hmm?
16:32:21 <Lemmih> dash: It's because it's a read-eval-print loop.
16:32:29 <dash> Lemmih: i don't understand
16:32:44 <monochrom> interpreter != interactive
16:32:46 <Lemmih> dash: It takes an expression, then evaluates it and prints it.
16:32:50 <bourbaki> dash what cant you do in the prompt in haskell that you want to do?
16:32:55 <dash> Lemmih: so..... why are there statements it won't process?
16:33:01 <dash> bourbaki: what wolfman8k said
16:33:14 <Lemmih> dash: 'import Blah' is _not_ an expression.
16:33:30 <Lemmih> Neither is a function declaration.
16:33:32 <dash> Lemmih: ok...? so why can't you run it from the prompt?
16:33:43 <monochrom> hugs has its limitations
16:33:50 <Lemmih> Because it is a read-eval-print loop.
16:34:03 <dash> Lemmih: that's not an answer, though
16:34:11 <bourbaki> heh :)
16:34:14 <Lemmih> But it is.
16:34:16 <dash> monochrom: i know. i'm curious why, though
16:34:22 <monochrom> You may as well ask "why is windows not secure".  They haven't spent the time to make it secure, duh.
16:34:34 <dash> Lemmih: "Why doesn't it do X?" "because it doesn't do X"
16:34:39 <dash> Lemmih: that's hardly useful
16:34:50 * bourbaki sits back and eats popcorn
16:35:14 <dash> Lemmih: i mean, if there's no good reason, or if it's Just Because, ot you don't know, then say so :)
16:35:27 <monochrom> In fact I think complaining to Microsoft about their insecure products is more beneficial to society than wondering why hugs is not full-featured.
16:35:40 <bourbaki> monochrom haha
16:35:56 <dash> monochrom: if i was feeling beneficial to society, i wouldn't be in #haskell :)
16:36:13 <bourbaki> havent i heared that there is a module that lets you do dynamic haskell code?
16:36:37 <dash> bourbaki: anyway what were you saying about lisp and strings or something
16:37:01 <Lemmih> monochrom: Hugs is limited in this way on purpose.
16:37:02 <bourbaki> dash you can interpret stings in lisp and add new functions at runtime
16:37:05 <monochrom> Hugs is free/volunteer-based so its missing all sorts of useful things is understandable.  Microsoft has big bucks and top-notch programmers and they still get it wrong --- now that is an itchy question you should pursue relentlessly.
16:37:34 <bourbaki> though m$ also seems to be involved in haskell stuff
16:37:36 <dash> Lemmih: oh really? why's that
16:38:24 <monochrom> So I completely don't understand the logic behind making all sorts of tough demands over free software *while*at*the*same*time* taking everything from Microsoft for granted.
16:38:37 <dash> heh. who's doing that?
16:38:48 <dash> Oh, crumbs. This parser doesn't handle dot syntax
16:38:49 <Lemmih> dash: Because it's designed to be a repl.
16:38:50 * dash attacks
16:39:01 <dash> Lemmih: you just said that
16:39:03 <Lemmih> dash: It's like asking why a car can't fly.
16:39:10 <monochrom> For example you should ask "why doesn't Microsoft ship with a full-featured haskell environment"
16:39:20 <monochrom> err why doesn't windows
16:39:27 <dash> Lemmih: well, when everybody else's car flies, it's a notable exception :)
16:39:53 <bourbaki> what was this cool new feature of the new ghc again that things with types
16:40:20 <Lemmih> dash: Other repls are pretty much similar to the Hugs toplevel.
16:41:20 <dash> Lemmih: Mmm? python, lisp, ruby, etc REPLs generally don't have that sort of exclusion
16:41:28 <dash> what are you referring to?
16:41:31 <marcot> Is there not a debian package for yi?
16:42:58 <Lemmih> dash: That's because they don't just evaluates expressions.
16:43:28 <dash> Lemmih: Precisely. So why is hugs different?
16:46:01 <Lemmih> Because only expression can be evaluated and printed.
16:46:17 <dash> that doesn't stop anyone else, it seems 
16:47:57 <Lemmih> So? Just because others add extensions to their REPLs doesn't mean that Hugs should.
16:48:21 * Oejet signals bourbaki to pass him the popcorn.
16:49:12 <dash> Lemmih: o.O
16:49:27 * bourbaki passes popcorn to Oejet
16:49:36 <dash> i didn't say Hugs should. I was asking if there was a reason it didn't.
16:49:40 <dash> anyhow
16:49:46 <bourbaki> can someone tell me what these oh so cool Generalized Data Types are?
16:49:47 <dash> any of you guys familiar with Parsec?
16:49:50 <Lemmih> That's because it's REPL.
16:50:17 <dash> Lemmih: To clarify: I was askign why it is a strict REPL and not a full interpreter.
16:50:19 <bourbaki> theres a typo on the ghc page
16:50:21 <bourbaki> The main new features in 6.4 will be a largely rewritten back-end, some new libraries, and Generalised Data Types (GADTs).
16:50:26 <Lemmih> The toplevel was designed to read, evaluate and print expressions in Haskell and it does that just fine.
16:50:47 <dash> Lemmih: Quite. I am asking why the design stopped there.
16:51:13 <wolfman8k> anyway
16:51:14 <dash> hmmh
16:51:29 <wolfman8k> i'm gonna try to use haskell to do some genetic algorithms and neural network programming
16:51:35 <Lemmih> Why should it go any further?
16:51:38 <wolfman8k> i hear that functional programming languages are good for AI
16:51:43 <bourbaki> wolfman8k oh interested in ai?
16:51:53 <wolfman8k> yeah
16:51:58 <dash> lemmih: As wolfman8k pointed out, it is useful.
16:51:58 <bourbaki> wolfman8k join #ai here on the server then
16:52:01 <monochrom> I hear that AI is good for nothing.
16:52:06 <dash> well
16:52:11 <bourbaki> id like to see your ANN implementation in haskell
16:52:12 <monochrom> I have nothing to do.
16:52:20 <dash> "AI" just means "stuff we don't know how to do yet" :)
16:52:21 <monochrom> So is AI good for me? :)
16:52:24 <bourbaki> i prefer the term AD
16:52:33 <wolfman8k> i actually don't really know anything about ai
16:52:35 <bourbaki> artificial dumbness :)
16:52:36 <dash> artificial dumbness?
16:52:38 <dash> yeah
16:52:38 <wolfman8k> i just read some cool articles 
16:52:50 <bourbaki> wolfman8k which ones?
16:52:59 <wolfman8k> on aijunkie.com i think
16:53:03 <bourbaki> i dont like the word intelligence
16:53:07 <bourbaki> ah
16:53:08 <dash> so anyhow i need to parse lisp constructs like "(foo a b . stuff)" 
16:53:20 <wolfman8k> i wanna do ai coding in haskell to learn haskell basicly
16:53:29 <wolfman8k> i tried learning haskell but i never could figure it out
16:53:39 <tuomov> what's intelligence anyway?
16:53:44 <bourbaki> wolfman8k a noble task since haskell will give you insight in things that you wont get in other langs
16:53:44 <dash> probably into a DottedList with 'list' and 'rest' fields
16:53:48 <Lemmih> dash: It would also a lot harder to code. And when you have a lot of Haskell code then it's good idea to save it in a file.
16:53:54 <tuomov> I hate the word "smart" in so many names these days
16:54:01 <tuomov> and all the "smart" features are just crap
16:54:04 <dash> Lemmih: sure, when you have a /lot/
16:54:04 <bourbaki> heh
16:54:09 <bourbaki> buzz words
16:54:10 <dash> Lemmih: but exploratory programming is useful
16:54:26 <dash> Lemmih: why would it be a lot harder to code?
16:54:31 <monochrom> intelligence: ... the ability to perform computer functions.  (See Merriam Webster online, definition 5)
16:54:38 <bourbaki> wolfman8k are you studying?
16:54:48 <bourbaki> monochrom hahahahaha :)
16:55:00 <wolfman8k> bourbaki: yeah, they say that haskell is magical and stuff. i really want to learn it. all i know is object oriented programming :/
16:55:01 <dash> just use Javam then you'll get Artificial Inelegance
16:55:01 * Oejet passes the popcorn back to bourbaki and thanks him for the kindness and goes to bed.
16:55:02 <wolfman8k> borism: studying?
16:55:10 <dash> s/m/,/
16:55:13 <bourbaki> im a student of cognitive science and one of the first things they told us is that intelligence is a very fuzzy thing :)
16:55:21 <dash> bourbaki: It probably isn't real.
16:55:41 <monochrom> not as fuzzy as consciousness, mind you
16:55:48 <bourbaki> wolfman8k yeah at uni and such can you search the article again?
16:55:52 <bourbaki> heh :)
16:55:56 <bourbaki> or cogsci ;)
16:56:00 <wolfman8k> i'm not studying at uni
16:56:13 <bourbaki> wolfman8k ah so you still go to school?
16:56:25 <wolfman8k> no
16:56:35 <wolfman8k> http://www.ai-junkie.com/ann/evolved/nnt1.html
16:56:40 <marcot> Can someone help me compiling yi?
16:56:43 <Lemmih> dash: Because it should distinguish between expressions and declarations.
16:56:53 <marcot> ghc-6.2.1: unknown package name: plugins
16:56:57 <wolfman8k> i've done buttloads of programming in C++
16:57:01 <wolfman8k> i see objects everywhere
16:57:06 <wolfman8k> i can't figure out haskell :/
16:57:14 <wolfman8k> i've also tried lisp and ocaml
16:57:16 <wolfman8k> no luck either :(
16:57:18 <bourbaki> wolfman8k ah i thoght it was an article on ai and fp
16:57:22 <marcot> I've downloaded hs-plugins from the website and installed with ./configure; make; make install
16:57:24 <dash> Lemmih: Aah.
16:57:30 <dash> Lemmih: OK, why's that?
16:57:42 <monochrom> "functional programming" = "value oriented programming"  I see values everywhere.  Everything is a value of some type.
16:57:43 <bourbaki> wolfman8k im doing an implementation of ANN in haskell as well
16:57:53 <dash> wolfman8k: no luck with lisp? lisp is basically the original object oriented language ;D
16:58:13 <Lemmih> dash: '[1..10]' should be handled different from 'f x = x+1'.
16:58:28 <wolfman8k> well, i didn't really try to hard with lisp. they told me that i should learn haskell before lisp since haskell is "pure?"
16:58:38 <dons> marcot: I can help
16:58:42 <dash> wolfman8k: so's lisp
16:58:49 <bourbaki> eeek
16:58:54 <dons> marcot: you forgot to 'make register'
16:58:59 <bourbaki> i see a war comeing up :)
16:58:59 <dash> wolfman8k: lisp is pure something, but haskell is pure something else :)
16:59:00 <GreyLensman> pure what??
16:59:04 <wolfman8k> yeah, but haskell is better then lisp for other reasons. exceptions i think
16:59:05 <marcot> dons: hum... thanks.
16:59:08 <monochrom> http://pauillac.inria.fr/~xleroy/talks/icfp99.ps.gz  may orient wolfman8k better
16:59:11 <dash> (and then there is PHP, which is pure crap)
16:59:25 <wolfman8k> hehe, php chugges donkey penis
16:59:27 <dons> marcot: which hs-plugins did you get?
16:59:28 <dash> wolfman8k: Depends on the lisp
16:59:52 <marcot> dons: the latest stable version. Does yi works with it?
17:00:08 <Lemmih> dash: And 'data Test = Test' should be handled different if it's followed by ' | NewTest'
17:00:24 <wolfman8k> woohoo! it's raining!
17:00:26 <dash> Lemmih: OK? 
17:00:27 <dons> there are improvements in hs-plugins that yi depends on. you need either the 'heatwave' snapshot, or the cvs snapshot
17:00:33 <dash> 'tis raining here too
17:00:34 <dash> well
17:00:36 <bourbaki> wolfman8k ?
17:00:37 <dash> it's dripping
17:00:38 <wolfman8k> first rain of the season!
17:00:38 <dons> it's in the README ;)
17:00:42 <dash> it wants to rain
17:00:45 <wolfman8k> Nein! it stopped :'(
17:00:45 <marcot> dons: how can I uninstall hs-plugins?
17:00:55 <wolfman8k> i can't believe it :( it rained for only 4 seconds :'(
17:00:56 <bourbaki> wolfman8k are you in sahara ?:)
17:00:58 <marcot> dons: it doesn't have a make uninstall target.
17:01:01 <dash> wolfman8k: game over!
17:01:02 <dons> just install the new version over the top
17:01:07 <wolfman8k> bourbaki: no
17:01:26 <bourbaki> wolfman8k so where does it rain  just once i wann move there :)
17:01:36 <dons> but do 'make unregister'
17:01:37 <wolfman8k> bourbaki: tel aviv
17:01:42 <Lemmih> dash: Then, of course, it could save it all in a file and evaluate that later on but then why should the user paste the source in the top level instead of a file?
17:01:51 <bourbaki> wolfman8k www.ai-deopt.com might also be of your interest
17:01:59 <wolfman8k> bourbaki: yeah, i've seen that site
17:02:04 <dash> Lemmih: why would it have to save it in a file?
17:02:05 <wolfman8k> i'm actually more interested in haskell resources
17:02:21 <bourbaki> wolfman8k i havent seen anything on ai and haskell specifically yet
17:02:25 <dash> http://www.cs.umaine.edu/%7echaitin/unknowable/ch2.html <-- lisp is pure something, but i'm not sure what :)
17:02:47 <wolfman8k> i think i understand the ai concepts that i need for now
17:02:56 <wolfman8k> i just need to know how to implement them in haskell :)
17:03:06 <wolfman8k> dash: are you saying that i should use lisp then?
17:03:10 <bourbaki> wolfman8k i think if you are aquainted with haskell youre able to implement all the stuff in haskell
17:03:15 <Lemmih> dash: Because, for example, 'data Test = Test' is different from 'data Test = Test\n | Test2'.
17:03:16 <dash> wolfman8k: no
17:03:41 <dash> Lemmih: OK? this is a solved problem, just require a blank line after a statement
17:03:48 <marcot> dons: there's not this target.
17:04:14 <dash> wolfman8k: i'm just saying that saying haskell is "more pure"  has some implied context :)
17:04:35 <wolfman8k> dash: i think it has to do something with what they call "monads"
17:04:39 <dons> marcot. then don't worry. just install the latest cvs snapshot
17:04:46 <marcot> dons: when I install the new version without uninstalling the old one will I have a lot of crap here?
17:04:56 <marcot> Like useless files?
17:04:57 <Lemmih> dash: But then people like wolfman8k wouldn't be able to just paste code in the toplevel.
17:05:06 <dons> no. the versions are identical in their files
17:05:11 <dash> Lemmih: so? you can _type_ it :)
17:05:27 <dons> if it really worries you, cd into the lib dir that hs-plugins was installed in, and rm -rf it 
17:05:49 <Lemmih> dash: And why is that better than saving it in a file and the load it in Hugs?
17:05:52 <dash> Lemmih: if you've got it in a file already, sure, go ahead and load it
17:06:04 <marcot> dons: ok, if the files are identical, no problem.
17:06:12 <dash> Lemmih: but being able to try out certain things before putting them in a file is useful
17:06:12 <dons> marcot: sorry about the missing targets. they're all in newer versions of hs-plugins, I keep forgetting
17:06:23 <boubaki> wolfman8k imho haskell has the advantage of learning something about math and the problem your dealing with
17:06:39 <wolfman8k> boubaki: math is good
17:07:15 <boubaki> wolfman8k but haveing a look at lisp wont hurt as well the more languages you know the better
17:07:23 <marcot> dons: Oh, don't worry.. =)
17:07:25 <Lemmih> dash: It's not really a problem since it can be solved by having an editor and hugs open at the same time.
17:07:26 <dash> Indeed.
17:07:32 <dash> Lemmih: Heh.
17:07:37 <boubaki> though for me its most interesting to implement ai things in haskell
17:08:04 <dash> Lemmih: I tried hugs in '99; one of the reasons i didn't make it very far is because I couldn't do this
17:08:11 <wolfman8k> boubaki: i've done a tiny amount of programming in ocaml
17:08:29 <marcot> dons: are you the author of yi?
17:08:33 <dash> Lemmih: i'm just wondering if it's hostile to that style of programming on purpose or not
17:08:40 <dash> apparently it is
17:09:02 <boubaki> wolfman8k i guess then you shouldnt have big probs with haskell as well though im not aquainted with ocaml to be honest
17:09:36 <wolfman8k> boubaki: problem is i don't know a lot of math :(
17:09:45 <wolfman8k> boubaki: only what i learned in high school
17:10:06 <boubaki> wolfman8k that totally surfices for most things in ai
17:10:27 <dons> marcot: yep. see the README ;)
17:10:27 <Lemmih> dash: I don't think anyone's gonna change it since it would be very redundant.
17:10:33 <boubaki> wolfman8k i think you should start out with decision trees or GAs thats easier then ANNs i think
17:10:37 <wolfman8k> boubaki: well... i've read some articles, and i think i understand enough to do some basic stuff. i feel like i could do this stuff in c++
17:10:47 <dash> Lemmih: Oh well.
17:10:51 <wolfman8k> boubaki: yeah, i'm gonna start with GA
17:11:11 <boubaki> wolfman8k if youre really interested in ai you should buy "ai a modern approach" is one of the ai bibles
17:11:23 <boubaki> wolfman8k youll find most of the standard techniques in there
17:11:56 <wolfman8k> boubaki: like i said, i mostly want to fool around with ai in haskell to learn haskell :)
17:12:22 <boubaki> :)
17:12:25 <marcot> dons: Now it's compiling! 
17:13:03 <dons> yay :)
17:13:09 <dons> you on linux?
17:13:25 <marcot> dons: yes.
17:13:33 <dons> ok, should be very easy then
17:13:37 <marcot> dons: debian... You should make a package for it.
17:13:52 <dons> I don't use linux -- but I do test on debian
17:14:14 <marcot> dons: what do you use?
17:14:25 <marcot> haddock: command not found.
17:14:28 <dons> also, there's been no official release yet (i.e. it is 9 days old) so a package might be a bit early :}
17:14:47 <marcot> hehehe
17:14:59 <dons> marcot: hmm. you need haddock to build the documentation. but you shouldn't require it
17:15:06 <dons> just to build yi itself
17:15:23 <marcot> dons: it asked for that in make install.
17:15:34 <marcot> dons: anyway: aptitude install haddock.
17:15:35 <dons> oh, yeah. cause it tries to build the documentation
17:16:50 <marcot> dons: it's just like vi.
17:17:02 <marcot> dons: I want my C-f back...
17:17:10 <dons> well, not quite like vi ...
17:17:29 <dons> if you want emacs, you should write a keybindings in ~/.yi/Config.hs
17:17:45 <dons> or look at Yi/Keymap.hs and write your own keymap
17:17:50 <marcot> dons: ok.
17:18:20 <marcot> dons: I thought it was like emacs... cause shapr sad about it when we're talking about emacs.
17:18:29 <dons> the idea is that the editor core is entirely scriptable
17:18:44 <dons> and I've scripted it into vi at the moment, because that is easy
17:18:49 <wolfman8k> emacs?
17:19:03 <dons> *but* all you have to do is adjust the config files, and you get emacs
17:19:10 <dons> that's the idea, and why it is like emacs
17:19:14 <marcot> dons: hum.. nice. It has a problem with unicode characters.
17:19:29 <dons> oh. look in mk/config.mk and set the appropriate wchar variables
17:19:40 <dons> I don't use unicode, but there should be some support in there
17:20:01 <marcot> dons: Ã§ makes the ~ colum go to the right.
17:20:03 <dons> if you'd like to debug the unicode stuff, and send me patches, that would be really helpful :)
17:20:25 <marcot> =)
17:20:32 <marcot> How do you debug haskell code?
17:20:44 <dons> write it, test it, change it...
17:20:55 <marcot> ok.
17:22:46 <marcot> dons: I don't have a ~/.yi/Config.hs
17:24:37 <dons> no. you'd have to write it! look in examples/
17:25:07 <dons> marcot: this code is 9 days old...
17:25:54 <dons> it isn't an emacs replacement yet. it's getting towards vi.
17:26:48 <marcot> dons: ok.
17:26:57 <marcot> dons: I'll look it.
17:28:06 <wolfman8k> anyone know about alice language btw?
17:29:18 <Philippa_> dons: lemme know when a win32 build's possible...
17:30:05 <dons> Philippa_: I've decided not to attack win32 until GHC 6.4 is out. Then hs-plugins gets ported. However, you probably can build yi, without plugins, right now
17:30:15 <dons> just won't be dynamically configuratble
17:30:43 <dons> yi will be called yi-static, and it wouldn't be installable.
17:30:47 <dons> hmm.. maybe I should fix that
17:31:50 <dons> ok. yes. I'll definitely clean things up so win32 users can use the static version
17:32:05 <dons> thanks for the hint/push ;)
17:32:24 <GreyLensman> wolfman8k, Alice has cool features, but slow. 
17:32:25 <marcot> dons: How can I change 'h' for C-b?
17:33:15 <dons> marcot: easiest way is to go into the source tree where you built yi
17:33:29 <dons> edit Yi/Keymap.hs and change the binding for 'h' to the action you want
17:33:38 <marcot> dons: I'm doing this.
17:33:46 <Philippa_> dons: np, I might actually get involved if there's some chance I can run it ;-)
17:33:50 <dons> I don't know what C-b does, so you'll have to read Core.hs to find the editor action you need
17:33:52 <marcot> dons: I mean, how can I write the C-b character?
17:34:01 <dons> what is C-b?
17:34:12 <marcot> dons: ctrl + b
17:34:15 <dons> Philippa_: ok! I'll do it today :)
17:34:28 <dons> you want to insert the ctrl+b character?
17:34:38 <Philippa_> oh, and feel free to nag me to finish the next Flippi release in return, fair's fair'n'all that :-)
17:34:43 <dons> hehe
17:34:48 <Philippa_> (but right now bed happens)
17:35:16 <marcot> dons: like emacs
17:35:19 <marcot> =)
17:35:24 <marcot> dons: don't you use it?
17:35:29 <dons> marcot: if you look at the documentation in html/ for Core.hs you'll see all the actions you can bind to
17:35:37 <dons> marcot: I use yi!
17:35:45 <dons> :P
17:36:11 <marcot> dons: =)
17:36:31 <marcot> html/ is empty.
17:36:46 <dons> because you didn't install haddock?
17:36:54 <dons> you can fill it with docs: make html
17:37:25 <dons> marcot: it's in the README
17:37:27 <marcot> dons: this is not the problem.
17:37:34 <marcot> dons: I installed haddock.
17:37:41 <marcot> dons: but I didn't make html.
17:37:53 <marcot> dons: the problem is how do I change the line:
17:38:03 <marcot> key F 'h' = leftE
17:38:13 <marcot> so that instead of 'h' I have C-b
17:38:59 <dons> so, when you press 'h', you want to instead insert '^B' ?
17:39:15 <marcot> dons: that's my question.
17:39:18 <marcot> dons: thanks.
17:39:21 <marcot> '^B'
17:39:41 <dons> do you really want to _insert_ the ^B character -- why?
17:39:49 <dons> or do you want to do the emacs action ^B is bound to?
17:40:31 <marcot> dons: I want to go to the left.
17:40:41 <marcot> dons: that's why I'm using it in leftE
17:40:43 <dons> oh, you want to use ^B to go left.
17:40:46 <dons> not 'h'
17:40:47 <dons> easy
17:41:18 <dons> just replace 'h' with the '\2'
17:41:26 <marcot> dons: Why \2?
17:41:34 <dons> that's the ascii value for ^B
17:43:18 <wolfman8k> monochrom
17:43:50 <marcot> dons: ok..
17:43:54 <marcot> dons: how do you know?
17:44:17 <marcot> Curses.hsc:592:
17:44:18 <marcot>     Warning: This binding for `bit' shadows an existing binding
17:44:27 <marcot> And a lot of other warnings.
17:44:38 <dons> doesn't matter
17:44:42 <marcot> When I replaced the Keymap.hs from Yi/ with the one from examples/
17:45:14 <dons> warnings in Curses.hsc don't matter
17:45:23 <dons> it's possible examples/ is out of date
17:45:39 <dons> if you just edit Yi/Keymap.hs, the original one, and recompile, things will work nicely
17:46:05 <dons> otherwise, you're living on the total bleeding edge, so expect things to be weird
17:46:28 <marcot> dons: I have to go..
17:46:38 <marcot> dons: I'll do the emacs mode for yi later... hehehe
17:46:42 <marcot> good bye.
17:49:16 <wolfman8k> monochrom: hello?
18:44:56 <dons> damn laziness
19:52:45 <danols__> hey guys do you have tips for minimizing plumbing ?
19:52:50 <danols__> in haskell programing
19:58:26 <danols__> anyone alive ?
20:00:43 <danols__> i have a question 
20:00:49 <danols__> if i have a hGetContent
20:01:15 <danols__> and take 1000 from it and write it to a file, wold the next take 1000 take the same first 1000 elements or the next 1000 ?
20:03:49 <danols__> knock knock ?
20:12:28 <cm> heya
23:07:31 <mornfall> moin moin
