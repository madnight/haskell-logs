00:12:20 <tuomov> theory of patches posted on the ml.. :)
00:12:25 <tuomov> s/patches/buffers/
00:13:13 <dons> I will be scrutinising this :)
00:18:22 <kolmodin> are there any hemacs mail list archives? 404 when following from: http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
00:20:53 <tuomov> not yet, as the list is not one month old (iirc). But try gmane
00:21:13 <tuomov> gmane.editors.post-emacs
00:23:33 <kolmodin> tuomov: found it, thanks
00:23:48 <Mike121> is there a commerical compiler for haskell ?
00:54:07 <bourbaki> hi
00:56:20 <ned> hi all
00:57:28 <ned> bourbaki: why this nickname ? are you a fan of these mathematicians ?
00:58:02 <ned> that remembers me the dark side of my mathematical studies ... :)
00:58:18 <bourbaki> ned: kind of yes :) i think its a rather funny storry
00:58:21 <ned> i dislike their mathematical apporach .. nothing against you yet :)
00:58:25 <bourbaki> ned: why dark side :)?
00:58:45 <ned> oh yeah it's a funny story, you're write
00:58:49 <bourbaki> to be honest i havent read any of the stuff they published
00:59:05 <ned> for me it's a really dogmatic point of view
00:59:21 <ned> s/write/right (my so bad english !!)
00:59:39 <bourbaki> ned: np
00:59:44 <ned> it's a deductiv-only, and intuition-less appoach
01:00:07 <ned> *from my point of view* :)
01:00:07 <bourbaki> and whats bad with that?
01:00:27 <ned> it's meaningless, it' just technical
01:00:37 <bourbaki> ah :)
01:00:48 <ned> you don't know what you are talking about, you just learn some rules
01:01:01 <ned> to build a perfect model
01:01:25 <bourbaki> :)
01:01:35 <bourbaki> thats what abstraction is about ;)
01:01:53 <ned> they want to summarize all mathematics in a perfect pyramid
01:02:06 <ned> for me mathematics are building models
01:02:12 <ned> from reality
01:02:29 <bourbaki> sounds reasonable
01:02:44 <ned> progress are oftien made in contradiction with what was untill now thought as the true
01:03:01 <ned> dunno if i'm clear ..
01:03:18 <Mike121> hmmz is there a problem borism should i bash up ned or ned do u want me to bashup borism ?
01:03:22 <ned> but it doesn't really matter :) i was just surprised :)
01:03:45 <ned> hu ?
01:03:48 <Mike121>  /s / borism / bourbaki 
01:04:01 <bourbaki> ned: falseification
01:04:25 * Mike121 bashes up both bourbaki and ned  ....
01:04:31 <ned> arf ..
01:04:33 <bourbaki> heh
01:04:39 <bourbaki> ned: where are you from?
01:04:47 <ned> france
01:05:00 <bourbaki> ah nice
01:05:06 <ned> and you ?
01:05:06 <bourbaki> what uni are you at?
01:05:16 <bourbaki> germany uni osnabrueck cog sci
01:05:25 <ned> i'm not at uni  anymore
01:05:29 <ned> i was in dijon
01:05:39 <bourbaki> :)
01:05:46 <ned> you learn mathematics ?
01:05:50 <bourbaki> and your working now as a mathematicain
01:05:56 <bourbaki> yes but not enough
01:06:37 <ned> hum .. no .. as a computer-stuff teacher .. but at really low-level .. :(
01:06:41 <bourbaki> math philosophy psychology lingusistics neurobio neurocomputation
01:06:49 <ned> whaou !
01:06:58 <bourbaki> compsci and ... *think*
01:07:07 <ned> not low-level as asm, low-level as newbies :)
01:07:20 <bourbaki> and something i cant remember :)
01:07:26 <ned> :)
01:07:33 <bourbaki> its 8 fields
01:07:53 <bourbaki> but i think we dont do enough math cause math is the lingua franca of all these things
01:08:07 <ned> have you ever read russians papers in mathematics ?
01:08:13 <bourbaki> nope
01:08:19 <ned> i don't say it's perfect or whatever
01:08:30 <ned> but it's quite different from bourbaki's approach
01:08:37 <kehoste> hello everyone
01:08:42 <ned> much more inductiv
01:08:45 <Mike121> hello kehoste 
01:08:49 <ned> hello
01:09:01 <bourbaki> i think im far from able to see the difference in a lot of these things
01:09:11 <Mike121> intutive ? or inductive ?
01:09:18 <Boegel> Mike121, it's Boegel :p
01:09:24 <ned> hum .. good question
01:09:26 <ned> :)
01:09:31 <bourbaki> i read a bit of topology and eventually will read up some geometrical algebra stuff
01:09:34 <bourbaki> hi Boegel 
01:09:43 <Boegel> hey bourbaki
01:09:50 <Boegel> started your ray tracer yet ?
01:09:52 <bourbaki> Boegel: ~ bagel = bourbaki hungry
01:09:54 <ned> trying to find regularities, not compute them
01:10:06 <Mike121> hello Boegel 
01:10:42 <bourbaki> ned: ah that sounds like a plan though i cant say if its something good or bad id have to read it should i ever start a new study its math though :)
01:11:23 <ned> :)
01:12:11 <ned> well .. it's not a question about Good or Bad .. let's say that i prefer inductiv approach 
01:12:17 <bourbaki> two of my best friends study math in berlin
01:12:36 <bourbaki> one of them comp sci at the same time :)
01:13:05 <ned> and dislike the bourbakists's will to build The Truth (tm)
01:13:19 <bourbaki> :)
01:13:34 <bourbaki> sounds a bit like the hilbert program
01:13:58 <bourbaki> ned: are you working ? if so what kind of job do you do as a math man?
01:14:39 <ned> 10:11 < bourbaki> and your working now as a mathematicain
01:14:39 <ned> 10:11 < bourbaki> yes but not enough
01:14:43 <ned> 10:12 < ned> hum .. no .. as a computer-stuff teacher .. but for newbies
01:15:18 <Boegel> ned: so you get the a lot of questions like " where is the any key ?" :)
01:15:35 <ned> things like that, yes ... 
01:15:50 <bourbaki> ah
01:15:52 <bourbaki> sry
01:15:52 <ned> but it's just a less-than-half-time job,
01:16:02 <ned> so i've some times to do others things
01:16:09 <Boegel> I always told myself I was never gonna do that, but with work coming closer and closer, I'm not so sure anymore...
01:16:33 <ned> d'ailleurs
01:16:57 * ned finally found some times to see these hs-plugins and arrows.hs stuff
01:19:33 <ned> i will soon do an initiation to Debian GNU/Linux, that's much more greater
01:19:55 <bourbaki> :)
01:19:57 <ned> it's not always about keys :)
01:19:58 <Boegel> ned: why Debian ?
01:20:06 <ned> cause it's the best :))
01:20:09 <ned> sorry
01:20:17 <Boegel> it's driver hell isn't it ?
01:20:26 <ned> not anymore
01:20:40 <ned> you just have to not be afraid by command-line
01:20:45 <Boegel> I installed Fedora yesterday on my laptop...
01:20:53 <Boegel> how do you like fedora ?
01:21:01 <ned> don't really know
01:21:13 <Boegel> then how can you say Debian is the best :)
01:21:41 <musasabi> debian is very nice.
01:21:41 <ned> i choose debian cause it's really great technically,
01:21:47 <ned> and especially cause it's
01:21:59 <ned> no profit, 
01:22:04 <Boegel> how ? what makes it better than other distro's ?
01:22:16 <ned> ethically the most closer to the FSF philosophy
01:22:29 <kristnjov> gentoo über alles
01:22:36 <ned> free as freedom, not as free beer :)
01:22:43 <Boegel> :)
01:22:57 <Boegel> I'm kinda new to linux, so I'll stick to Fedora
01:23:16 <Boegel> I tried to mount my iPod Mini yesterday, but I didn't work that well :s
01:25:42 <ned> diversity is great, i'm not a debian fanatic
01:26:54 <ned> but the debian project is for me a really great exemple of how benevolent cooperativ project can do so much
01:27:50 <ned> .. much more than the capitalist model
01:32:23 <Boegel> I'm out, I have a class in a bit
01:32:26 <Boegel> bye !
01:32:32 <ned> bye
01:32:36 <Boegel> exit
01:32:40 <Boegel> woops ")
01:39:56 <xkb> hi all
01:40:01 <xkb> I have a question:
01:40:12 <xkb> Say you are developping a large haskell application
01:40:30 <asyd> howdy
01:40:33 <xkb> using several layers
01:40:58 <xkb> like a data abstraction layer
01:40:58 <xkb> a gui layer
01:40:58 <xkb> and what not
01:40:59 <xkb> In java it's common to separate error of the layers in the form of exceptions
01:41:12 <xkb> and wrap those exceptions to more abstract exceptions
01:41:15 <xkb> for example:
01:41:27 <xkb> a network connection fails on database level
01:41:41 <xkb> the user does not want to see "Error reading port 9999"
01:41:52 <xkb> he wants to see "Error retreiving Student"
01:41:57 <xkb> or something like it
01:42:04 <kristnjov> catch EExceptionError
01:42:06 <xkb> Is this also possible in Haskell?
01:42:07 <kristnjov> something like that
01:42:20 <xkb> as catch is in the IO monad
01:42:30 <kristnjov> xkb, if you're asking if there is GUI in haskell, there is
01:42:45 <xkb> kristnjov, no. I meant the wrapping and passing on of exceptions
01:45:16 <kolmodin> xkb: you might want to take a look at: http://www.nomaware.com/monads/html/errormonad.html
01:46:30 <xkb> kolmodin, thanks
01:46:43 <musasabi> xkb: Control.Exception too.
01:52:03 <kolmodin> how can I raise and catch errors in Haskell as I can in O'caml?
01:52:34 <kolmodin> I mean: in O'caml i can just create a new exception and throw it wherever I am
01:53:04 <kolmodin> and catch it with    try e of Not_found -> handler;
01:53:27 <xkb> musasabi, Control.Exception is what im looking at now
01:53:37 <xkb> the problem with it is catch being in IO()
01:54:03 <musasabi> xkb: in pure code you can use Control.Monad.Error
01:54:08 <kolmodin> should I raise exceptions with DynException Dynamic and have a separate catch for each type?
01:54:27 <xkb> catch catches all as far as I know
01:54:42 <xkb> however I dont know for sure with the Dynamics version
01:54:58 <kolmodin> like:   doIt `catchSpecific` (\e -> handleShit e)
01:55:16 <xkb> kolmodin, thats catchJust I think
01:56:24 <kolmodin> hmm
01:56:27 <xkb> musasabi, using both Control.Monad.Error and Control.Exception wont let me wrap exceptions without using the IO monad right?
01:57:25 <xkb> I can either use Control.Monad.Error in pure code
01:57:39 <xkb> or Control.Exception's catch in non-pure, IO() code
02:00:08 <musasabi> yes.
02:00:23 <kolmodin> so I catch it with catchJust dynExceptions, fromDynamic into my errorType, if it's (Just e) I handle it, otherwise I reraise it. right.. :)
02:00:27 <musasabi> xkb: but you can throw exception which can be catched only with IO in pure code.
02:02:27 <xkb> musasabi, ok.. my point however is that wrapping exceptions to another exception is hard with the current implementation
02:06:18 <musasabi> how ? foo `catch` MyWrapper
02:06:55 <xkb> like that indeed
02:06:58 <musasabi> where MyWrapper :: Dynamic exc => exc -> MyWrapperExc
02:07:15 <xkb> 'catch' here is in the IO monad right?
02:07:24 <musasabi> yes
02:07:35 <xkb> so say you have for layers in your app
02:07:52 <xkb> and in the first most basic layer you want to wrap the exception to something else
02:08:03 <xkb> you need to use the IO monad
02:08:13 <xkb> wont that slow things down/make it more complicated?
02:11:13 <musasabi> not really
02:12:04 <xkb> musasabi, hmm Im gonna write some sample code to try this stuff..
02:30:29 <shapr> hej dryan
02:30:33 <shapr> um DrX 
02:31:17 <Lemmih> Hey shapr.
02:34:23 * shapr yawns
02:35:53 <Lemmih> I got off early from school.
02:35:57 <DrX> hej shapr
02:35:58 <shapr> neat
02:36:22 <Lemmih> And I've fixed the "Got NULL value from non-NULL field" bug.
02:36:26 <shapr> cool
02:36:39 <shapr> I'll put up the new code after I'm awake
02:36:45 * shapr wanders off to imbibe stimulants
02:37:36 <tromp> g'morning
02:37:51 <Lemmih> Morning, tromp.
02:38:00 <tromp> @index maybe
02:38:01 <lambdabot> Data.Maybe,Prelude,Maybe
03:00:07 <musasabi> integrating IO into stream processors was suprisingly easy and the code is tidy.
03:00:18 <musasabi> Now to get things done with real arrows..
03:02:14 <DrX> are there a paste site for Haskell code ?
03:03:38 <musasabi> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:15:10 <DrX> I pasted a bit of code on that page, Im having some troubles with it. Im trying to compile it with ghc but i get this "Ambiguous type variable `a' in the top-level constraint: `PropClass a' arising from use of `propParser' at Main.hs:176" I don't understand why, i use a "case" to take care of both cases
03:18:21 <shapr> musasabi: you have stream proc code I can see?
03:18:28 * shapr wants more arrow examples to understand
03:25:48 <Lemmih> Oh no. It looks like halipeto is gonna need some optimizing. /-:
03:27:59 <musasabi> shapr: yes, http://www.cs.helsinki.fi/u/ekarttun/haskell/SP.hs
03:28:25 <musasabi> that's not really arrows though.
03:28:49 <musasabi> I am unsure how I can express the serializable constraint with arrows.
03:29:36 <musasabi> DrX: how *should* that code work in your view?
03:30:25 <musasabi> DrX: do you want to return a value of some type which happens to satisfy PropClass, but you don't know the type of it)
03:31:28 <DrX> it should take the first element in the argument list, parse it with propParser, if propParser was unable to parse it the program should give an error if it did parse it it should print some extra info (Left == error, Right == success)
03:32:52 <musasabi> DrX: what type is success?
03:34:39 <DrX> Prop "data Prop = Truee |..." its an instance of PropClass, should i upload the whole file ?
03:35:48 <musasabi> DrX: so instead of "propParser :: PropClass a => String -> Either String a" you want "propParser :: String -> Either String Prop" ?
03:36:54 <DrX> hmm... no, im not allowed to change the propParser
03:38:29 <musasabi> of course but then you would change Prop, no?
03:39:34 <DrX> this is how my data types looks like, http://www.rafb.net/paste/results/sIv7HS82.html  this is the PropParser i got http://www.cs.chalmers.se/Cs/Grundutb/Kurser/e4fun/2004/pa/4/PropParser.hs
03:40:33 <DrX> i don't understand why my propParserTest function works but my main function does not
03:41:13 <DrX> the only thing i changed is the code after "->"
03:41:13 <musasabi> DrX: you have to return values of concrete types.
03:42:41 <DrX> what type is putStrLn() ? isn't that IO () ?
03:43:10 <musasabi> yes.
03:43:10 <DrX> my main function works if i remove the "case" statement, and only have putStrLn "test"
03:43:17 <musasabi> that is a concrete type.
03:44:14 <DrX> in my "case" statement i only return putStrLn "" Im not using any other type, why is it so mad at me then ?
03:44:27 <musasabi> DrX: you cannot have a function like 'foo :: Show a => a \n foo = "aaa"'
03:45:52 <musasabi> DrX: your example (the case) @ http://www.rafb.net/paste/results/sIv7HS82.html has some problems.
03:46:02 <Lemmih> DrX: (propParser x) evaluates to type 'Either String a' and Haskell can't calculate the correct type of 'a' since you don't use it.
03:47:44 <shapr> hiya rhw 
03:47:49 * shapr yawns
03:48:02 <asyd> \_o<
03:48:14 <shapr> salut asyd!
03:48:21 <asyd> heya shapr !
03:48:22 <shapr> comment Ã§a va?
03:48:23 <asyd> how goes
03:48:26 <asyd> bien :)
03:48:42 <shapr> apprends tu Haskell?
03:48:46 <asyd> I'm studying the linux tcp/ip stack for two weekds
03:48:51 <asyd> i want
03:48:54 <shapr> c'est chouette
03:49:09 <asyd> I met Lunar^ this week end but talked about a futur tcp/ip stack for hop ;p
03:49:23 <shapr> les langue fonctionelles est tres chouette =)
03:49:42 <asyd> :) (langage)
03:49:46 <shapr> whoops
03:50:00 <shapr> you met Lunar^ in person?
03:50:07 <asyd> don't worry your french is probably better than my english
03:50:08 <asyd> yes !
03:50:12 <shapr> wow, nifty!
03:50:32 <shapr> I met Lunar^ last year, he's a cool guy.
03:51:05 <shapr> yes, I'm interested in hOp/house
03:51:11 <shapr> have you seen House also?
03:51:13 <DrX> Lemmih, hmm... i just tried using 'a' and now it works... strange, can't haskell just throw away the variables i don't use and be happy about it ?
03:51:58 <shapr> je veux IPv6 en Haskell!
03:52:17 <Lemmih> DrX: No. The behaviour of propParser is dependent on the type of 'a'.
03:52:24 <DrX> i thought Haskell was lazy ? if i don't use a variable == less work the haskell == happy haskell ? :)
03:52:36 <DrX> *the = for
03:52:39 <Lemmih> DrX: Know about the function read?
03:52:46 * shapr is lazy too
03:53:19 <asyd> shapr: yes :) no i don't have seen his house
03:53:25 <DrX> Lemmih, no :/
03:53:30 <Lemmih> DrX: 'read :: String -> String' is different from 'read :: String -> Int'
03:54:02 <DrX> yes that i can see
03:54:37 <ned> asyd: no : http://www.cse.ogi.edu/~hallgren/House/
03:54:49 <shapr> salut ned!
03:54:51 <DrX> but propParser returns a type Either, aren't 'Left' and 'Right' of the same type ?
03:54:53 <asyd> ned: no what ? ;p
03:54:55 <Lemmih> DrX: When using typeclasses you want to have one function which different behavior on different types. That's why the type matters.
03:55:03 <ned> hello shapr
03:55:11 <shapr> cava?
03:55:13 <ned> asyd: not his house, House :)
03:55:23 <asyd> arf
03:55:25 <shapr> does Lunar^ have a house now?
03:55:28 <Lemmih> DrX: It returns 'PropClass => Ether String a'
03:55:29 <asyd> shame on me
03:55:41 <ned> shapr: he has 3 house for what i know :)
03:55:49 <ned> shapr: in 3 towns :)
03:55:59 <shapr> I thought Lunar^ didn't need a house, rain stays away by sheer force of wil.
03:56:11 <shapr> um "sheer force of will"
03:56:37 <JerubBaal> ;)
03:56:44 <shapr> g'day JerubBaal 
03:56:46 <Lemmih> Speaking of rain... I gonna go unicycle while the sun is shining.
03:56:46 <DrX> Lemmih, hmm.. but doesn't Haskell now that in "Left s" s is a String when i have defined a function like PropClass =
03:57:07 <DrX> oh its the 'a' that fucks it up
03:57:18 <Lemmih> Indeed. (-:
03:59:14 <DrX> hmm.. I should have studied more on Haskell, i think i will fail my exam tomorrow...
04:05:38 <shapr> DrX: Haskell is cool, it's worth learning even without an exam.
04:06:02 <shapr> asyd: Is this title a joke about "journey to the center of the earth" ?
04:06:10 <asyd> yes
04:06:15 <shapr> it's very funny :-)
04:06:24 <asyd> thanks i tried to look the englis translation for this book title
04:06:38 <shapr> Jules Verne
04:06:39 <shapr> he's cool
04:06:42 <asyd> sure
04:06:58 <shapr> Voyage au centre de la pile TCP/IP de Linux
04:06:59 * shapr laughs
04:07:03 <asyd> :)
04:07:05 <DrX> shapr: I think its weird, i never liked recursive functions (i find them very hard to debug) and haskell is all about recursion (almost)
04:07:33 <shapr> DrX: I think recursive functions are easier to debug.
04:07:39 <shapr> myLength [] = 0
04:07:48 <shapr> myLength (x:xs) = 1 + myLength xs
04:08:23 <shapr> with recursive functions you can say "1. here's the last step and 2. here's how to get one step closer to the last step"
04:09:12 <shapr> DrX: the code is actually less complex than a loop in Java/C/etc
04:09:34 <DrX> in Haskell they are very usefull, but i find them hard to debug in other language like c++ or java thats why i never used them and i used loops instead so i find it hard to even com up with a recursion function its a whole other way to think
04:10:19 <DrX> shapr: yes its less complex but if there are a small bug in it, and you run your debugger you ususaly get a load of crap as output
04:10:30 <shapr> I started using recursive functions in Visual Basic, Python, and Java; but those languages often explode when they have too many recursive function calls.
04:10:42 <DrX> and its hard to determine how deep into the function you are
04:10:47 <shapr> "stack depth exceeded"
04:11:04 <DrX> yeah thats another problem in other languages
04:11:07 <Lemmih> How deep into the function you are?
04:11:20 <shapr> asyd: I think chapitre 1 needs regeneration
04:11:21 <DrX> how many times it has recursed
04:11:31 <shapr> Chapitre 1. Initialisation de la pile TCP/IP [exit 1. Too many jobs.] 
04:11:59 <shapr> asyd: does this mean you have too many jobs so you don't have time to write this chapter yet? ;-)
04:12:36 <Lemmih> DrX: A simple (loops+1) could probably solve that even tho it's rarely needed.
04:14:20 <DrX> it has been very educational for me to take a haskell course... i have learned a few new concepts but unfortinaly i haven't learned haskell :/
04:15:39 <shapr> well, come by #haskell and ask if you want to learn more!
04:15:49 <shapr> I am often here and willing to help.
04:15:59 <shapr> And many other people on #haskell are willing to help.
04:16:02 <musasabi> shapr: I created the equivalent of SP.hs with arrows and it works ^_^
04:16:32 <shapr> oh I want to see!
04:16:36 <DrX> I found this channel to late, i have the exam tomorrow :/
04:16:57 <asyd> shapr: yes :) will be available in one week i hope
04:16:58 <shapr> DrX: you can still learn Haskell... it's worth more than just an exam =)
04:17:32 <rhw> hey shapr :)
04:17:32 <shapr> DrX: recursion is just the first thing you learn in Haskell, there are lots more powerful and simple patterns.
04:18:02 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/SPArr.hs
04:18:44 <shapr> musasabi: yow, this looks like double-espresso quality code.
04:19:02 <DrX> shapr, i did buy a very expensive (expensive when you don't have any money) book so i will read it when i get time :)
04:19:43 <shapr> DrX: all of the simple and powerful patterns that Haskell can teach you will be useful in languages like C++ and Java, so it's really worth it.
04:19:57 <shapr> musasabi: the arrows code looks simpler...
04:21:08 <shapr> but I'm more used to reading enumerated code..
04:21:12 <shapr> oh I see how it works
04:21:25 <musasabi> yes, it is simpler but I don't like the proc syntax very much.
04:21:30 * Lemmih remembers the good weather and goes unicycling.
04:21:59 <shapr> Lemmih: hey can you send me the latest webbih code when you get back?
04:22:29 * Mike121 pulls Lemmih back in and points to the flat tyre ....
04:22:37 <Lemmih> I can send it now. But it's just small changes.
04:22:55 <shapr> or you can send it when you get back, I won't have time to put it up right away
04:23:12 <Mike121> Lemmih  u can unicycle ?
04:23:21 <Mike121> isnt that dangerous ?
04:23:22 <Lemmih> shapr: I've added some dummy packages at http://212.242.49.100/cgi-bin/web/Main
04:23:36 <dv> how do i access the third element in a n-tuple?
04:23:50 <shapr> dv: \(_,_,x) -> x
04:24:00 <dv> ah right. thanks
04:24:06 <Lemmih> Mike121: It's actually very safe. You can always just remove your feets from the pedals and land on the ground.
04:24:10 <shapr> Lemmih: nice, do you have the input .description files online for people to look at?
04:24:27 <shapr> Mike121: I have two unicycles, and I ride almost every day.
04:25:00 <rhw> shapr, You glue 'em together and ride a bicycle ? =)
04:25:02 <shapr> j'aime les monocycles!
04:25:24 <shapr> rhw: no, but there is a neat clown circus 'bicycle' that does that
04:25:39 <Lemmih> shapr: I do now; http://212.242.49.100/Descriptions/
04:26:03 <Mike121> so there is no chance of breaking ones teeth ?
04:26:15 <shapr> Lemmih: excellent, I'd like to link to those demos next time I mention Webbih on libraries@haskell.org
04:26:22 <musasabi> Is there any good prioritu queue library around?
04:26:24 <Mike121> Forbidden
04:26:24 <Mike121> You don't have permission to access /Descriptions/ on this server.
04:26:41 <shapr> Mike121: not if you wear a helmet, and don't try to do things that are too dangerous for your skill level.
04:26:43 <Lemmih> Mike121: Ops.
04:27:06 <DrX> woohooo now it works, thanks for the help
04:27:18 <Mike121> hmmz but na handle bar is a bit scarry?
04:27:21 <shapr> DrX: yay!
04:27:21 <tuomov> an ice hockey goalie helmet?
04:27:36 <shapr> tuomov: heh! I just wear a bike helmet :-)
04:28:23 <Mike121> hmmz and does ur chin stay protected ?
04:28:25 <shapr> usually you just gotta pick up your feet and the unicycle leaves, then you put your feet back down and you're standing a meter from the unicycle landing position.
04:28:53 <shapr> Mike121: sometimes I fall on my hands instead of my feet, but very rarely.
04:29:03 <tuomov> I assume those things don't have breaks?
04:29:09 <tuomov> s/break/brake/
04:29:22 <shapr> tuomov: most of them don't, but mine does have brakemounts.
04:29:28 <shapr> since mine is a mountain unicycle.
04:29:40 <Mike121> so breakmounts and no breaks ?
04:29:49 <shapr> http://www.unicycle.com/Shopping/shopexd.asp?id=466
04:30:02 <Mike121> cas u make one on ur own ?
04:30:07 <shapr> I haven't needed any brakes yet, I haven't tried any mountains :-)
04:30:19 <shapr> konichiwa juhp-san
04:30:44 <shapr> juhp: I'm never sure whether to greet you in japanese or dansk
04:30:47 * juhp bows konban-wa :)
04:30:51 <juhp> lol
04:31:10 <juhp> shapr: you get to choose :)
04:31:14 <shapr> heh, ok
04:31:14 <tuomov> shapr: is there any language you don't know?-)
04:31:22 <waltz> Goo' mownin'.
04:31:31 <shapr> tuomov: minÃ¤ en puhu suomea ;-)
04:31:35 <waltz> shapr, do you talk 24/7?
04:31:50 <shapr> waltz: sorry, I'm not a very smart bot yet
04:31:54 <Mike121> shapr how many languages do u speak ?
04:32:01 <Oejet> juhp: I'm Danish too :-)
04:32:02 <Mike121> 5 
04:32:06 <Mike121> ?
04:32:12 <waltz> shapr can you speak Ukrainian like myself :)
04:32:23 <shapr> Mike121: about half a language? I grew up in Alabama!
04:32:23 <Mike121> russian ?
04:32:41 <waltz> Ukrainian is not Russian. Similar, but not quite.
04:32:42 <Mike121> english french japanese 
04:32:46 <Mike121> cantonese 
04:32:55 <Lemmih> shapr: http://212.242.49.100/Descriptions/ is now available.
04:33:13 <Mike121> ah tnx Lemmih 
04:33:21 <shapr> nah, I speak English, and some Swedish and some French. I have minimal understanding of Finnish, and a few words of dutch, german, japanese, and some other languages.
04:33:43 <xkb> Heel goed :)
04:33:56 <shapr> hoi xkb, hoe gaat het met jou? :-)
04:34:01 <xkb> :D
04:34:02 <xkb> nice
04:34:10 <shapr> ik begrijp het niet!
04:34:15 <Mike121> hmmz where did ya pick all that up ?
04:34:17 <xkb> volgens mij wel
04:34:40 <xkb> shapr, to bad I can't hear you pronounce it
04:34:50 <shapr> I'm just a sponge... I read stuff or hear stuff and then I often remember it.
04:35:02 <earthy> useful, that
04:35:13 <Mike121> hmmz great 
04:35:24 <shapr> xkb: I had a girlfriend from Nijmegen for about six months, so I try to really grind my Gs like a heavy smoker with a heavy Nijmegen accent :-)
04:35:33 <shapr> gggraaaggg gggedann!
04:35:34 <xkb> LOL
04:35:52 <waltz> heh
04:35:56 <xkb> I'm originally from Apeldoorn, just north of Nijmegen
04:36:04 <earthy> nijmegen actually has pretty soft g's
04:36:41 <shapr> My fiancee speaks six languages, one of the being dutch that she learned in Leuven.
04:36:58 <shapr> She always tries to get me to do that soft flemish :-)
04:37:28 <earthy> probably sound cute, coming from you :P
04:37:31 <earthy> +s
04:37:43 <shapr> it sounds nice, but it's not nearly as much fun as gravelly Gs.
04:38:10 <earthy> but damn... 6 languages
04:38:14 * earthy has some catching up to do :)
04:38:18 <earthy> I only speak 3 ;)
04:38:18 <shapr> earthy: come to EuroHaskell next time, I'll speak my minimal dutch with you :-)
04:38:45 <shapr> I think I have about two really, 1 English, and 0.5 Swedish + 0.5 French
04:39:28 <earthy> oh well... I have a list of languages to learn... should really get started on it sometime
04:39:28 <tuomov> I speak one, I read&write one more, I have minimal understanding of two more
04:39:35 <shapr> waltz: I haven't tried to really learn any slavic languages, though I do have some russian friends who have taught me a few words of russian.
04:40:12 <Oejet> shapr: Kak dela?
04:40:16 <earthy> (Portuguese, French, Spanish, Chinese, Russian, Hindi, Arabic. The first three I plan to learn in that order. ;))
04:40:26 <shapr> earthy: whoa, nice list... 
04:40:46 <tuomov> learning is no fun unless you get to use it
04:40:49 <shapr> tuomov: finnish, english, and ? - ?
04:40:54 <tuomov> swedish, french
04:40:58 <shapr> ah, neat
04:41:07 <shapr> Oejet: what's that?
04:41:11 <earthy> tuomov: portuguese is gonna be used next year... plan to travel through brasil for a month
04:41:22 <shapr> earthy: is _swiert_ going with you? :-)
04:41:28 * earthy laughs
04:41:37 <earthy> no, my gf is. ;P
04:41:45 <shapr> ah, ok
04:41:47 <Oejet> shapr: Russian for "how are you".
04:42:33 <shapr> Oejet: oh neat, I only learned "hi" and some things I shouldn't say in public.
04:43:08 <Oejet> shapr: Ok. :-)
04:43:43 <shapr> does M. C. Widerkrantz hang out on #haskell?
04:46:30 <Mike121> do any authors of haskell books hang out at #haskell ?
04:46:53 <shapr> sometimes, yes
04:47:16 <shapr> but most of the really productive Haskellers don't have time to chat much :-)
04:47:30 <Mike121> haha 
04:47:34 <Mike121> obviously
04:47:58 <Mike121> are there enough opensource haskell projects to glean into ?
04:48:08 <shapr> yes, there are lots.
04:48:46 <Mike121> can u point me to one of them which is not so complex yet not so trivial and undercooked ?
04:51:04 <shapr> well, what sort of info do you want? :-)
04:51:29 <shapr> if you want fun and not very serious, there's lambdabot 
04:51:58 <shapr> but one goal of lambdabot is that it is somewhat undercooked, in obvious ways, so that new Haskellers can fix it, and get their name in the AUTHORS file =)
04:56:30 <shapr> Mike121: oh what about a wiki in Haskell?
04:57:03 <shapr> Mike121: http://www.flippac.org/projects/flippi/
04:58:04 <Mike121> ah tnx purposfully undercooked is fine ...
04:59:06 <shapr> Mike121: if you want to find a useful project that's not much work, lambdabot needs a @help command, hopefully something where you can add help from plugins.
05:00:14 <Mike121> i will give it a shot tnx shapr :)
05:07:09 * shapr reads a theory of buffers
05:23:14 * Lemmih is back.
05:23:22 * shapr is forward
05:30:16 <Lemmih> I would appreciate some feedback on Hackage.
05:30:21 <musasabi> home.
05:35:20 <DrX> Oh there is OpenGL for haskell, cool :)
05:43:15 <shapr> Lemmih: I'd like to be able to see all the fields when I click on a package
05:45:43 <shapr> oh maybe it already does that =)
05:45:58 * shapr dohs
05:47:36 <Lemmih> I've omitted 'Version' but that's mostly a design thing.
05:48:10 <shapr> Lemmih: how to delete a package? Do re-uploaded packages update the old info?
05:48:11 * shapr tries
05:48:52 <shapr> Is there a set list of values for Category?
05:49:57 <Lemmih> A set list?
05:50:16 <tromp> @index lex
05:50:17 <lambdabot> GHC.Read,Prelude,Text.Read,Text.Read.Lex
05:50:25 <Lemmih> You currently can't edit nor delete packages.
05:50:25 <shapr> Just wondering if I upload Category tracing/Debugging if that will show up as a separate category
05:50:50 <shapr> as in, whether tracing/Debugging and Tracing/Debugging are different
05:50:57 <Lemmih> They are.
05:51:01 <shapr> ok
05:53:06 <Lemmih> I thinking of a hiding feature instead of actual deleting. Then people would be able to unhide as well.
06:04:10 <Lemmih> Hey Boegel
06:04:26 <Boegel> brb
06:04:45 <Boegel> nice, hey Lemmih
06:04:55 <dblhelix> LtU just pointed me to this: http://compsoc.dur.ac.uk/whitespace/index.php
06:05:22 <dblhelix> perhaps some of you have already seen this ... I think it's fantastic!
06:05:23 <dblhelix> :)
06:05:45 <Boegel> dblhelix, it's sounds crazy :)
06:06:02 <dblhelix> Boegel: it is
06:06:38 <shapr> and the author is even nearby ;-)
06:06:50 * shapr looks at edwin2 
06:08:02 * dblhelix says hi :)
06:09:46 <Boegel> woops :s
06:10:00 * shapr watches Boegel bounce
06:10:09 <Boegel> ctrl+alt+shift+backspace switches to non graphic in linux ? :s
06:10:13 <edwin2> oh, hello ;)
06:10:24 <earthy> um.... ctrl-alt-backspace kills the X server...
06:10:30 * shapr goes into interviewer mode
06:10:37 <Boegel> earthy, ow :)
06:10:40 <shapr> edwin2: so, what prompted you to create the Whitespace language?
06:10:44 <Boegel> I was configuring my shortcuts :$
06:10:55 <edwinb> sorry, can't talk now, busy playing Go ;).
06:10:58 <edwinb> I'll be back in a bit...
06:11:01 <shapr> Boegel: you can turn that off with DontZap in the config file
06:11:02 <shapr> edwinb: ok
06:11:12 <Boegel> shapr, it's ok
06:11:17 <Boegel> I was just trying something :)
06:12:50 <tromp> where do you play, edwin?
06:13:29 <shapr> greetings djw 
06:13:31 <djw> hello
06:13:39 <shapr> looking for Haskell info?
06:13:52 <djw> this is such a friendly channel :)
06:13:55 <tromp> i mean, edwinb:)
06:14:03 <djw> shapr: no just stroking edwinb ;)
06:15:19 <shapr> djw: so, you already know Haskell? :-)
06:15:28 <edwinb> tromp: I'm on kgs.
06:15:44 <tromp> ah, so am i from time to time
06:15:48 * Boegel sees shapr going for another tour
06:15:51 <shapr> can I introduce you to the beauty of point-free programming?
06:16:08 * shapr grins evilly
06:16:44 <asyd> :)
06:17:15 <musasabi> What is happening to Edison?
06:17:18 <tromp> you must be using a different handle there though
06:17:36 <musasabi> The cvs says it was deprecated two weeks ago..
06:18:11 <shapr> musasabi: last I heard, only Pseudonym was maintaining it, as HFL.
06:18:11 * Igloo is very proud of http://urchin.earth.li/~ian/pf.txt from the ICFP contest  :-)
06:18:41 <shapr> Greetings Agent Goerzen.
06:18:47 <shapr> Welcome to The Matrix.
06:18:59 * shapr throws chinese looking characters at CosmicRay 
06:19:17 <dv> i finally got the game of life code working :|
06:19:25 <shapr> dv: yay!
06:19:26 <CosmicRay> yeow!
06:19:31 <CosmicRay> green characters!
06:19:38 <dv> http://transfixion.org/files/life2.hs
06:19:40 <shapr> dv: so, is now a good time to point you to the Automata workbench written in Haskell?
06:20:06 <dv> oh?
06:20:07 <shapr> CosmicRay: Right, we've got Jackie Chan, Charlie Chan, and that oriental detectve whose name I've forgotten.
06:20:14 <CosmicRay> heh
06:20:26 <CosmicRay> all I have is Sherlock Holmes
06:20:29 <kosmikus> Igloo: unimportant comment: you shoud specify vertical spaces in terms of "ex", not "em" ...
06:20:40 <CosmicRay> ahh, but that will do.  He did defeat Dr. Moriarty, after all.
06:20:48 <shapr> true
06:21:01 * CosmicRay spots the telltale signs of another sherlock holmes fan
06:21:02 <Igloo> Good point
06:21:03 <shapr> djw: wake up! smell the lambdas!
06:21:12 * shapr looks through djw's cupboard
06:21:36 <Igloo> Although for slides I'm just doing it by eye anyway  :-)
06:21:48 * djw wakes up
06:21:58 <earthy> good afternoon Wouter
06:21:59 <kosmikus> I said it's unimportant ... ;)
06:22:21 <djw> shapr: well actually I don't really know haskell. Although once I get some time I'll be learning it
06:22:29 <shapr> djw: how does programming count as a natural science?
06:22:43 <djw> interesting question
06:22:57 <earthy> does maths?
06:23:07 <shapr> djw: maybe I could interest you in a free copy of lambdabot 2.1 ?
06:23:09 <djw> maths isn't a science
06:23:24 <earthy> then what is it? :)
06:23:28 <swiert> hi earthy
06:23:41 <djw> shapr: what does lambdabot do?
06:23:59 <kosmikus> maths isn't a natural science, programming isn't a science
06:24:21 <shapr> djw: well, he speaks the irc protocol....
06:24:23 <shapr> @listmodules
06:24:23 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
06:24:23 <lambdabot> ,"dynamic","eval","hello","karma","more","quote","seen","state","system
06:24:23 <lambdabot> ,"topic","type"]
06:24:41 <shapr> @eval map (\x -> x + 1) [1,2,3]
06:24:42 <lambdabot> [2, 3, 4]
06:24:45 <djw> shapr: I figured that, written in Haskell I geuess
06:24:54 <shapr> djw: yup, fun for the whole family.
06:24:57 <djw> yay!
06:25:06 <shapr> @yow
06:25:07 <lambdabot> Yow!  Now we can become alcoholics!
06:25:14 * djw giggles
06:25:20 <shapr> nice plugin interface, easy to write your own.
06:25:27 <Boegel> shapr, my sound isn't working on my laptop in linux (Fedora)
06:25:29 <Boegel> :(
06:25:50 <Boegel> any idea how I can solve this problem ?
06:26:06 <earthy> boegel: 1. ask on the right forum? :P
06:26:11 <djw> shapr: great stuff, I've written many perl irc bots.... doing it in haskell could but the fun back into it
06:26:21 <earthy> 2. check what kind of sound chip is in the laptop
06:26:31 <shapr> Boegel: lspci !
06:26:43 <earthy> then try to see if there's a checkbox somewhere that has the same name of the sound chip and something like `driver'
06:27:01 <shapr> djw: http://www.scannedinavian.org/~shae/lbot2.1.tgz
06:29:06 <shapr> Boegel: I don't have DCC in this client.
06:29:20 <Boegel> shapr, sorry, I'm not used to working in XChat :)
06:29:23 <Boegel> see pm
06:29:26 <shapr> y0, got it
06:29:36 * shapr considers some 'divine wind' unicycling.
06:30:55 <shapr> djw: so, you write any functional languages?
06:31:00 <djw> nope
06:31:09 <Mike121> Boegel try sondconfig 
06:31:13 <Mike121> as root
06:31:17 <djw> shapr: I just know once I get my head around it I'll probably like it
06:31:20 <Mike121> sndconfig
06:31:42 <shapr> Haskell is pretty sexy.
06:32:00 <shapr> djw: you want the short intro for the easily bored?
06:32:30 <djw> shapr: anyway, I should stop procrastinating and do some maths problems
06:32:39 <shapr> no intro for you then?
06:32:45 <djw> shapr: maybe later :)
06:32:50 <shapr> fair enough :-)
06:32:56 * djw smiles
06:34:37 <Boegel> Mike121, I don't have sndconfig
06:34:51 <Mike121> get it installed
06:34:56 <Mike121> via the rpm manager 
06:35:38 <Mike121> shapr give out the intro i am all ears ....
06:36:03 <Mike121> i wont mind listening to u for hours on end ....
06:36:20 <shapr> what? intro to Linux?
06:36:28 <shapr> oh, Intro to Haskell..
06:36:39 <asyd> :)
06:36:41 <Mike121> Boegel do an lsmod and see if u have the audio drivers as kernal module 
06:36:59 <shapr> asyd: how long have you been using Haskell?
06:37:08 * shapr is actually in the mood to unicycle...
06:37:09 <Mike121> u just need to load the module 
06:37:11 <asyd> I never use it atm
06:37:17 <Mike121> shapr haskell 
06:37:18 <shapr> oh no!
06:37:31 <asyd> :/
06:37:53 <shapr> asyd: lots of fun Haskell projects to join.
06:37:54 <Mike121> i am a linux geek marooned in M$ teritory for unavoidable reasons ...
06:38:02 <shapr> hacking around on hOp is always fun.
06:38:06 <asyd> shapr: my main goal is hop i think
06:38:29 <Mike121> h0p will be better than linux one day .... 
06:38:43 <Mike121> ohh lala 
06:38:54 <Boegel> Mike121, see pm
06:39:07 <shapr> yay hOp!
06:39:17 <shapr> asyd: House sources probably have some good stuff for hOp
06:40:17 <asyd> ok
06:40:44 <shapr> but there's no released sources yet :-/
06:41:50 <Mike121> shapr i am really excited about h0p
06:42:06 <Mike121> it could be the next big os ...
06:42:30 <Mike121> if they borrow the right stuff and make it eyecandy hehe
06:43:35 <edwinb> hello again
06:43:52 <shapr> Mike121: yes, hOp could be really awesome.
06:44:27 <shapr> Mike121: hOp is heavy duty stuff though, you probably want to start with smaller programs first... maybe.
06:44:54 <shapr> I've looked through the hOp sources, it's not as scary as I expected.
06:45:24 <shapr> the scheduler needs improvement for a real production OS, and stuff like network card drivers are needed.
06:45:36 <tuomov> I've long thought that the OS should at least enforce garbage collection
06:45:39 <shapr> asyd: hey, any plans on a network card driver? ne2000? or something simpler?
06:45:51 <tuomov> there are too many apps that leak memory
06:46:04 <tuomov> the mozilla family being the most significant of them :)
06:46:14 <shapr> I've been thinking of hardware garbage collection in non-cache-coherent NUMA systems =)
06:46:37 <tuomov> lisp machine!
06:46:47 <shapr> HaskellM!
06:47:42 <shapr> The idea being that the commonly used 'push' cache-coherency of today's NUMA systems costs about 10% of the performance on 2cpu boxes, and more with more CPUs
06:47:57 <shapr> so I was thinking... why not use the Haskell approach?
06:48:47 <shapr> if you never write to already used memory, you don't need to check/sync the caches with any write
06:49:29 <shapr> you can simulate infinite memory by calling the GC whenever a process needs more memory than is actually available
06:50:27 <shapr> sounds simple enough?
06:50:58 <Boegel> shapr, now it does, Mike121 got my sound working :)
06:51:04 <Boegel> :p
06:51:05 <shapr> yay!
06:51:51 <shapr> of course, 'hardware GC' isn't really needed, only non-ccNUMA hardware with sufficient software.
06:53:29 <Mike121> maybe a browser in haskell will solve all the memory leaks ....
06:53:56 <shapr> Haskell has something a bit like a memory leak that's called a 'space leak'
06:54:02 * Boegel tries to talk his prof again
06:54:17 <Mike121> why does that happen shapr 
06:54:27 <shapr> Mike121: but we can discuss that in greater detail when you've written some code, it'll be easier to understand then.
06:55:00 <Mike121> ok cool i will get down to reading the rest of the tutorial 
06:55:02 <shapr> a space leak is 'unwanted laziness' usually, but sometimes it's 'holding onto data too long'
06:55:12 <shapr> anyway, time for some kamikaze unicycling...
06:55:13 * shapr disappears
06:55:24 <Mike121> i wonder if anyone else has learnt haskell with only tutorials ...
06:55:27 <Boegel> shapr, don't break anything :p
06:55:32 <Mike121> ride safe shammah 
06:55:57 <Mike121>  /s / shammah / shapr  
07:00:02 <musasabi> Mike121: tutorials + coding + rereading parts + coding => some understanding
07:00:08 <musasabi> at least I hope so
07:00:53 <Mike121> well i dont mind the code reading and coding part but cant shell out $s for a book ...
07:01:34 <tuomov> there's no need for a dead tree book
07:01:44 <Lemmih> Is it possible to profile code that uses a library which isn't compiled for profiling?
07:02:40 <Mike121> ah tnx for the boost tuomov if we er meet in real life remind me to get u a free lunch 
07:05:02 <Lemmih> I'm having problems profiling some code which uses HaskellDB.
07:05:06 <musasabi> Mike121: I learned haskell without any books/courses.
07:05:30 <Mike121> u can have a free lunch too musasabi :)
07:05:44 <phubuh> i did too!
07:05:49 <phubuh> lunch please!
07:06:05 <earthy> hmmmm. food....
07:06:30 * Oejet is hungry.
07:09:20 <tromp> how's your connect4 program coming along, oejet?
07:09:26 <Mike121> no more free lunches today ...
07:09:37 <phubuh> unfair :(
07:10:02 <Mike121> there is a connect 4 in haskell ?
07:10:04 <Mike121> lovely 
07:10:12 <Oejet> tromp: It's going forward. I have a problem with printing to stdout.
07:10:20 <Mike121> Oejet wanna play connect four with me ?
07:10:40 <tromp> are you storing the board as 2 bitmaps?
07:11:14 <Oejet> Mike121: Hmm, just let me finish my c4 brain ;-)
07:11:31 <Oejet> tromp: Yes.
07:12:02 <tromp> and how do you test for a win?
07:12:04 <Mike121> sure i always love a fair game of connect four 
07:12:31 <Mike121> odd no and even nos ?
07:12:32 * Oejet wonders if Mike121 has something up his sleeve.
07:13:30 * desrt pokes viv
07:14:15 <Mike121> hello viv 
07:14:41 * viv says to desrt-- work on the compiler and the german paper!!
07:15:02 <desrt> mm.  i have to talk to scott about the german thing
07:15:05 <Oejet> tromp: I test if one of masks4 matches one of the bitmasks: test bb = \mask->bb .&. mask == mask.
07:15:05 <desrt> perhaps today in 3x
07:15:15 <vivek> connect four is a first player winner game ...
07:15:32 <tromp> for how many masks?
07:15:59 <Oejet> vivek: I know. :-)
07:16:05 <viv> desrt: yay..but not the class during the midterm~!!=)
07:16:19 <Oejet> tromp: There are 69 masks for four in a row.
07:16:23 <desrt> i think scott is probably going to handle the front-end (parsing the source code into some kind of a tree) and i'm going to work on the code generation
07:16:48 <tromp> your test can be much faster, without any masks
07:16:48 <viv> Dr.Kahl just assigned scott to write the documentation......
07:16:48 <desrt> i'm so sick of tests
07:16:54 <desrt> go ahead and FLUNK MY ASS
07:16:56 <viv> much to his surpirse.....hah
07:17:04 <tromp> just using a few bitshifts
07:17:35 <desrt> dr. kahl has a copy of the code i wrote over the summer.  he knows what my 'documentation' looks like :P
07:18:36 <Oejet> tromp: That's neat, but I can't see how to do that. I'm strugling with this IO thing.
07:18:57 <tromp> my win-tester looks like this in java:
07:19:02 <tromp>   // return whether newboard includes a win
07:19:02 <tromp>   final boolean haswon(long newboard)
07:19:02 <tromp>   {
07:19:02 <tromp>     long y = newboard & (newboard>>HEIGHT);
07:19:02 <tromp>     if ((y & (y >> 2*HEIGHT)) != 0) // check diagonal \
07:19:03 <tromp>       return true;
07:19:05 <tromp>     y = newboard & (newboard>>H1);
07:19:07 <tromp>     if ((y & (y >> 2*H1)) != 0) // check horizontal -
07:19:09 <tromp>       return true;
07:19:13 <tromp>     y = newboard & (newboard>>H2); // check diagonal /
07:19:15 <tromp>     if ((y & (y >> 2*H2)) != 0)
07:19:17 <tromp>       return true;
07:19:19 <tromp>     y = newboard & (newboard>>1); // check vertical |
07:19:21 <tromp>     return (y & (y >> 2)) != 0;
07:19:23 <tromp>   }
07:19:54 <tromp> (sorry for the spam:()
07:20:24 <tromp> of course this only works if you layout the bits just right
07:22:06 <Oejet> tromp: That is pretty clever. I think, I got the idea.
07:22:56 <tromp> yes, it's very neat:) see if you can figure out the layout for yourself
07:23:16 <tromp> you have to take care that there's no phantom wins due to wrap around effects
07:24:06 <tromp> for that reason it won't fit in 7*6=42 bits
07:24:31 <tromp> you need an empty border which makes it 7*7=49 bits
07:25:04 <Oejet> I have 64 bits, so that should be enough.
07:26:02 <tromp> you'll also save all the code for computing the old masks:)
07:26:58 <tromp> you cld even enlarge the board the 8x7
07:27:06 <tromp> and use all your 64 bits...
07:27:11 <tromp> the->to
07:27:54 <tromp> which also has the advantage that perfect play is still unknown (7x6 is totally solved)
07:28:14 <Oejet> I have this frustrating problem: My program writes to stdout lines of the form "3".  When running in the terminal: ]a.out ... 3\n2\n2 ... it works, but when redirection to a file: ]a.out >file.  It doesn't write anything to the file.
07:31:20 <bourbaki> moin
07:33:44 <tromp> that sounds weird, oejet. is the program online somewhere?
07:35:53 <Igloo> Oejet: It's probably a buffering issue
07:35:59 <Oejet> http://eigil.dyndns.dk/OlinkaII.hs
07:36:06 <Igloo> Does it not write anything even when the program terminates?
07:36:35 <Oejet> Igloo: Nope.
07:36:38 <Igloo> Oh
07:37:34 <SyntaxNinja> Igloo: I uploaded wxhaskell
07:37:39 <SyntaxNinja> to haskell-unsafe
07:38:03 <SyntaxNinja> I haven't heard any complaints about it; except one from shapr that I didn't grock; maybe it is indeed time to upload it to debian
07:38:19 <Igloo> Cool
07:38:33 <tromp> running a.out now
07:38:41 <Igloo> If you upload to Debian now it'll have to be with the old ghc, of course
07:39:08 <Igloo> I'm at a conference next week so I'm not sure if I should hold off uploading new versions of almost everything I maintain until I get back
07:39:19 <SyntaxNinja> right
07:39:39 <tromp> what input does it expect,  oejet?
07:39:57 <SyntaxNinja> up to you; there's nothing hugely obviouslyi wrong with 6.2.2 and it won't drop into testing before you get back, right/
07:40:04 <tromp> or what's a good test input?
07:40:15 <Igloo> True
07:40:35 <Oejet> tromp: Ah, from stdin lines of the form "3\n4". Try the empty file: ]a.out 
07:40:59 <kosmikus> dblhelix: ping
07:41:22 <Oejet> tromp: ]cat emptyfile | a.out
07:41:48 <tromp> ok, getting some 4's and 6's
07:42:27 <tromp> and now it's thinking hard
07:42:31 <Oejet> tromp: That is correct. That is the potential best moves. The get better and better.
07:43:55 <tromp> you don't see output in file because the program doesn't finish
07:44:01 <tromp> and if you
07:44:17 <tromp> stop it with control-C it get no chance to write the buffer to file
07:45:16 <Oejet> tromp: Ok, how do I get it to empty the buffer after each line?
07:45:33 <bourbaki> hi TheHunter 
07:45:37 <tromp> if you change [0..] to [0..3] you'll see the output in the file
07:45:38 <TheHunter> hi bourbaki 
07:45:59 <tromp> you'd have to do the haskell equivalent of flush()
07:46:18 <bourbaki> TheHunter: wanna see what i did so far with that neural net and arrow thing?
07:46:40 <tromp> set no buffering on stdout
07:46:49 <TheHunter> bourbaki: yep
07:47:46 <bourbaki> TheHunter: http://paste.phpfi.com/33737
07:48:43 <desrt> viv; heh.  i just got an email
07:48:44 <tromp> hSetBuffering stdout LineBuffering
07:48:58 <desrt> Hi,
07:48:59 <desrt>   after talking with Scott, I just had an idea:
07:49:00 <desrt> you could call your language C*, and make it simple and powerful ;-) :
07:49:06 <bourbaki> TheHunter: ive just one thing there that is not to my likes and that is the useage of (pure plus) i need a way to make that recursive over the nested pairs
07:49:15 <Oejet> tromp: Ah thanks, was just looking for that command.
07:50:06 <TheHunter> bourbaki: wow, the last line is long
07:50:19 <bourbaki> TheHunter: its a 2 layer neural network
07:50:43 <bourbaki> TheHunter: just some testlines i noted down
07:53:26 <bourbaki> TheHunter: do you have an idea for the nested pair recursion thing?
07:53:51 <Oejet> tromp: Thanks it works now, you are my hero.
07:54:12 <TheHunter> bourbaki: what's exactly the problem?
07:54:31 <bourbaki> TheHunter: you have a slight idea of how a neural net works?
07:54:51 <TheHunter> depends on the definition of slight, but i guess not.
07:56:12 <tromp> you're welcome. now you can go back to the bit layout challenge:)
07:56:22 <bourbaki> TheHunter: http://www.uab.edu/cogdev/lect3d.jpg
07:56:34 <bourbaki> TheHunter: look at figure 1.3
07:56:38 <DrX> Can someone help me to interpretate question 13 the part with checkPp on this assignment http://www.cs.chalmers.se/Cs/Grundutb/Kurser/e4fun/2004/pa/4/pa4.html   Im not asking you to do it for me i just need help understanding what they want me to do, I wrote it like this http://www.rafb.net/paste/results/VrRM9210.html  but i got this back from the teacher "checkPp should be a relation between propParserTest and pp only." I don't understand what they
07:56:38 <DrX>  want
07:57:01 <bourbaki> there is a sum function that sums up all values of the inputs
07:57:18 <bourbaki> what i do is i take
07:58:01 <bourbaki> (pure (weight xy)) +++ (pure (weight vw)) >>> (pure plus) and that all the time because the arity of all the operators in arrow is 2
07:59:05 <earthy> DrX: they want you to state the function checkPp in terms of propParserTest and pp only
07:59:32 <TheHunter> bourbaki: what about defining plus3 :: ((Float, Float), Float) -> Float ?
07:59:38 <bourbaki> which leads me to my nested pair problem when you want to build a product of more then one function you have to apply the +++ operator on and on which leads to a nested pair list (structurally like a binary tree) and over this structure i need some way of recursion but tagging the last element mwith first wont work
07:59:41 <earthy> so, you are not allowed to use other functions to cut the string or deal with the propositions between calls to propParserTets and pp
08:00:03 <bourbaki> TheHunter: i can do (first (pure plus))
08:00:36 <bourbaki> TheHunter: but thats not recursive so it wont work on arbitrary many usues of +++
08:01:08 <TheHunter> bourbaki: you want a plus that works for arbitary expressions that are build up from (,) - products ?
08:01:31 <bourbaki> TheHunter: basically yes but instead of plus take any 2 ary operation
08:01:37 <bourbaki> TheHunter: what i want is something like reduce in lisp
08:02:07 <bourbaki> TheHunter: take (1,(2,3)) and @ as 2-ary operator
08:02:34 <TheHunter> ok, try this (first for the plus only): class Addable a  where add :: a -> Float
08:02:49 <bourbaki> TheHunter: then reduce (1,(2,3)) @ -> (@ 1 (@ 2 3))
08:02:50 <TheHunter> instance Addable Float
08:03:33 <TheHunter> instance (Addable a, Addable b) -> Addable (a, b) where add (x,y) = add x + add y
08:03:59 <bourbaki> TheHunter: but how does that help me to build a recurstion on a nested pair list?>
08:05:16 <TheHunter> it does exactly what you want to do for the (+) operation
08:05:55 <TheHunter> *Main> add ((3::Float,4::Float),(4::Float,(3::Float,2::Float)))
08:05:55 <TheHunter> 16.0
08:06:12 <bourbaki> TheHunter: hm i dont understand that really to be honest
08:06:22 <musasabi> Why is there no timed wait for mvar ?
08:06:29 <DrX> earthy, hmm... I thought about writing it like this: checkPp x = pp x == pp (propParserTest (pp x)) ; but that compares two strings and they say in the Q13 notes that checkPp can't determine if the parentheses is correct, so that solution won't work, The only relation ship betwen propParserTest and pp i can see is that "propParserTest x" (where x is a string) should give the same result as "propParserTest (pp y)" (where y is a Prop)
08:07:36 <TheHunter> bourbaki: if a is instance of the class Addable, that means that a is a nested pair whose sum can be evaluated by the functino `add'
08:08:09 <TheHunter> you get this as follows: You say a float can be added together to a float, by the identity function
08:08:23 <TheHunter> and if a and b can be added together, so can (a,b)
08:09:26 <shapr> man I love unicycling.
08:09:41 <bourbaki> hm
08:10:14 <bourbaki> i still dont understand it why that does the recursion properly
08:10:20 <bourbaki> but it seems as if it would do
08:13:05 <TheHunter> do you know what the syntax instance ... => ... means?
08:13:51 <bourbaki> no i havent read on classes and the like yet
08:14:28 * arjanb wonders how haskell compiles such nifty things
08:15:12 <TheHunter> it means, if the conditions on the left side of => are met, then haskell can build the instance (on the right side)
08:15:26 <bourbaki> ok
08:15:37 <TheHunter> together with fundeps, you get a kind of "type-level-prolog"
08:15:54 <bourbaki> TheHunter: can you paste the code you wrote i tried to copy it from irc but it wont work somehot
08:15:56 <Philippa> oh god, somebody's reinvented C++ templates again? :-)
08:15:58 <bourbaki> *how
08:18:04 <bourbaki> TheHunter: but i kind of see the trick Addable can be a single value or a pair right?
08:18:52 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:19:01 <TheHunter> bourbaki: right
08:19:16 <dblhelix> kosmikus: pong (a little late perhaps)
08:20:07 <kosmikus> no problem
08:20:13 <kosmikus> which ghc version do you run/
08:21:19 <dblhelix> IIRC 6.2.1
08:21:29 <kosmikus> good
08:22:13 <dblhelix> is it?
08:22:52 <kosmikus> you might want to test www.cs.uu.nl/~andres/gh-1.41-win32.exe then
08:23:27 <bourbaki> TheHunter: i think i need to understand the class system first :)
08:23:35 <dblhelix> downloading ... cool new features?
08:23:53 <kosmikus> local redefinition and definition on patterns both work
08:24:04 <kosmikus> still kind-indexed types as typesigs though
08:25:02 * shapr wants kosmikus to give an irc presentation on kind-indexed and type-indexed thingies someday
08:25:07 <dblhelix> okay, I'll try
08:25:18 <kosmikus> shapr: no problem, suggest a time
08:25:49 <shapr> well, um
08:26:02 <bourbaki> TheHunter: thank you very much though :) you saved my day
08:26:04 <shapr> depends on who else wants to hear about it, I guess.
08:26:12 <bourbaki> shapr: have you seen TheHunter solution :)?
08:26:21 * musasabi wants
08:26:23 * dblhelix signs up to attend the presentation
08:26:33 <shapr> bourbaki: no, I just read a bit of it in the scrollback
08:26:45 <shapr> combination of typeclasses and fundeps
08:26:54 <shapr> sounds like something worth putting on the wiki :-)
08:27:20 <shapr> kosmikus: well, you've got two people signed up for your presentation :-)
08:27:32 <kosmikus> one of which won't learn anything ...
08:28:04 <Philippa> pick a good time and I'm happy to listen/read
08:28:25 <Igloo> shapr might not be the brightest spark, but give him a chance!
08:28:28 * Igloo ducks
08:28:35 * shapr laughs
08:28:54 <kosmikus> I'll try ;)
08:28:57 <bourbaki> whats fundeps?
08:29:09 <shapr> functional dependencies
08:29:22 <shapr> @wiki FunDeps I think
08:29:22 <lambdabot> http://www.haskell.org/hawiki/FunDeps I think
08:36:25 <Igloo> Hmm, according to the wiki Redhat has a newer version of ghc4 than there is source
08:36:41 <bourbaki> TheHunter: i bow to you thanks again look at this now :)
08:36:52 <bourbaki> (erup ((((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3))) >>> (pure add)) &&& ((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3)) >>> (pure add)) &&& ((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3)) >>> (pure add))))
08:37:37 <bourbaki> one (pure add) per line is a lot better then one (pure plus) per every two functions :)
08:38:21 <TheHunter> looks a bit less scary :)
08:38:30 <bourbaki> now its so cool!
08:39:23 <bourbaki> the last thing i now will need is to find a way how to include a function in there that modifies the functions in it self :)
08:41:21 <jemfinch> shapr: you in?
08:49:39 <shapr> jemfinch: am I ever out?
08:50:17 <TheHunter> hi Boegel 
08:50:22 <Boegel> hello
08:50:25 <jemfinch> shapr: hehe
08:50:28 <shapr> jemfinch: I'm sorry, I'm not a very smart bot yet, try shapr: @listcommands
08:50:32 <Boegel> I have a problem when installing hugs on Fedora
08:50:43 <Boegel> i get this error while running 'make'
08:50:46 <jemfinch> shapr: I have a naming issue I can't think of the name for.
08:51:01 <shapr> wow, I've never had a recursive naming issue before.
08:51:04 <Boegel> runhugs: Error occurred
08:51:04 <Boegel> ERROR "../hugsdir/libraries/Data/List.hs":197 - Syntax error in fixity decl (unexpected backslash (lambda))
08:51:06 <jemfinch> hehe
08:51:47 <shapr> bringert: y0, you got a moment?
08:51:56 <jemfinch> basically, I have a series of processors (consider them functions, if you want) that can be considered to return options (Just/Nothing) and I want to run each in turn until one returns Just something.
08:52:14 <shapr> bringert: I'm in the market for some 0-day Haskell warez...
08:52:19 <TheHunter> jemfinch: do you know msum?
08:52:31 <asyd>  /s 3
08:52:32 <asyd> oups
08:52:39 <shapr> asyd: /s 42 !
08:52:46 <asyd> :)
08:52:56 <jemfinch> TheHunter: msum is what it's called in Haskell?
08:53:06 <shapr> Man, unicycling is one of the great highs in life.
08:53:13 * shapr sighs cheerfully and begins to code...
08:53:26 <TheHunter> msum [Nothing, Just 3, Just 4] ==> Just 3
08:53:39 <jemfinch> ok.
08:53:47 <jemfinch> that seems not to be a very intuitive name.
08:53:47 <TheHunter> in case of maybe, it returns the first just value
08:53:55 <kosmikus> dblhelix: does it work?
08:53:58 <Boegel> shapr: can you explain the error I get while installing hugs ?
08:54:22 <TheHunter> in case of lists of lists, it joins all the lists
08:54:43 <jemfinch> TheHunter: I'm concerned mostly with naming right now.  I'm not even writing in Haskell.
08:54:55 * jemfinch just made the comparison because it was an appropriate metaphor to make.
08:54:59 <TheHunter> the m in msum stands for monad, if that doesn't scare you.
08:54:59 <dblhelix> I've only just run the installation: that's okay ... will expermiment with the compiler itself after dinner ...
08:55:07 <jemfinch> yeah, that makes sense.
08:56:05 <kosmikus> dblhelix: can you go to tests/80misc/LR-Size/ref and run gh on LR-Size.ghs?
08:57:13 <dblhelix> kosmikus: okay, give me a sec ...
08:58:29 <shapr> TheHunter: is msum named that way because +++ is the 'one or the other' monadic thingy?
08:58:41 * shapr should probably remember ...
09:00:00 <Philippa> shapr: folds mplus across the list?
09:00:38 <shapr> right, but why is mplus named that?
09:00:43 <TheHunter> shapr: it's probably something to do with the monad being called MonadPlus, and it's similar to <+> if that's what you mean. Actually, I have no idea.
09:01:26 <TheHunter> i usually end up calling stuff f,g,h and x,y,z because i can't think of good names for stuff...
09:01:28 <shapr> I wonder why it's called Plus rather than MonadOr or MonadChoice or something.
09:01:56 <dblhelix> kosmikus: malformed type argument in generic declaration (15, 1)
09:02:00 <TheHunter> shapr: well, in case of lists monads it's really something like plus.
09:02:16 <shapr> oh, that's where it started.
09:02:22 <TheHunter> maybe there's a ct explanation?
09:02:27 <shapr> maybe so.
09:02:30 <kosmikus> dblhelix: very strange ... are you executing the new gh, or an old one?
09:03:10 <Philippa> TheHunter: very likely it's a categorical sum
09:04:06 <dblhelix> mmm ... I guess it could be that the env vars are not setup correctly ... have to go for dinner now ... but I'll have a look at it after that, ok?
09:04:14 <kosmikus> yes, sure
09:04:20 <kosmikus> the installer doesn't touch envvars
09:05:09 <shapr> oy, Henrik Nilsson brought up a rather thorny issue on libraries@h.o just now.
09:05:25 <dblhelix> kosmikus: definitely running an old version ... my mistake ... the executable is renamed ... it's called gh-bin now, right?
09:05:38 <kosmikus> you should execute gh.bat
09:05:39 <shapr> GHC is the only one that supports arrow syntax, so how do you tell other implementations to use a preprocessor? 
09:05:46 <shapr> he suggested Foo.hs.arr
09:05:48 * shapr gicks
09:06:18 <dblhelix> kosmikus: that one does not like paths that do not adhere to the 8+3 convention
09:06:40 <kosmikus> hmmm
09:06:54 <kosmikus> what's the error?
09:06:55 <Philippa> where do I sub to libraries, anyway?
09:07:05 * shapr hates topquoting with a passion
09:07:09 <Philippa> heh
09:07:29 * shapr stabs topquoters with the wrong end of the knife until they're a bloody pulp
09:07:45 <shapr> Philippa: http://haskell.org/mailman/listinfo
09:08:14 <shapr> JerubBaal: no one talks on #erlang :-(
09:08:51 <dblhelix> not sure ... really have to go now ... I'll get back at you on that
09:08:56 <Boegel> I'm updating my system in Fedora, using up2date, but when I'm installing everything, it asks with every package if I want to continue because the GPG signature isn't right... how can I fix this, so I don't have to click 'Yes' every time ?
09:10:12 <kosmikus> dblhelix: ok, later
09:11:30 <bourbaki> is there an example of building a stack with arrows with just the basic operators?
09:17:29 <Boegel> anyone? :s
09:19:22 <shapr> oboy, lots of work lined for the rest of the week and the weekend.
09:22:44 <TheHunter> @hawiki HaskellIrcPastePage <-- bourbaki, check this out.
09:22:45 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
09:22:50 <TheHunter> @wiki HaskellIrcPastePage <-- bourbaki, check this out.
09:22:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage <-- bourbaki, check this
09:22:50 <lambdabot> out.
09:23:00 <bourbaki> TheHunter: k thanks
09:23:52 <TheHunter> it converts nested products to other nested products (needs a s/Int/Float/eg for you application)
09:24:58 <bourbaki> TheHunter: ah cool thank you very much that is a good thing since i can use it to show that a binary tree or nested pairs is the same like a simple vector :)
09:25:26 <Igloo> Anyone know what's going on when ltrace shows munmap taking 5 arguments?
09:25:58 <bourbaki> TheHunter: i neet to run to the shop now to get food for the eve :)
09:26:18 <bourbaki> TheHunter: maybe you can even help me with my last big problem then
09:29:14 <shapr> speaking of useful lambdabot commands, I'd like to have @@command as an 'inline' command
09:34:53 <tromp> @eval pi
09:34:53 <lambdabot> unbound variable: pi
09:35:04 <tromp> @index pi
09:35:05 <lambdabot> GHC.Float,Prelude
09:35:19 <tromp> @eval GHC.Float,Prelude.pi
09:35:19 <lambdabot> (line 1, column 10):
09:35:19 <lambdabot> unexpected ","
09:35:19 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character
09:35:19 <lambdabot>  "[", string, "(", ".", "`", operator, simple term or end of input
09:36:04 <TheHunter> @eval 22/7
09:36:05 <lambdabot> 3
09:54:24 <Oejet> tromp: I have reached a milestone in my Connect Four brain called Olinka II. Now it actually beats Olinka (has a list of list of integers board representation, written in Common Lisp) :-)
09:55:14 <shapr> Greetings Agent Jones.
09:56:20 <Lemmih> shapr: Ever used profiling and HaskellDB together?
09:56:26 <shapr> er, no?
09:56:36 <shapr> but if you want to ask bringert, you better ask now :-)
09:56:38 <Lemmih> Know if it's possible?
09:56:54 <bringert> Lemmih: can't see we that shouldn't work
09:57:01 <bringert> s/we/why/
09:57:39 <bourbaki> bk
09:57:52 <Lemmih> I get "Failed to load interface for `Database.HaskellDB.DBLayout':" when I compile with -prof -auto-all.
09:58:03 <Oejet> tromp: For a feel of the action, see an ongoing match at http://eigil.dyndns.dk/Spildommer/spil.html. Olinka is red, Olinka II is blue and the time to think is 20 s per move.
09:58:06 <shapr> you'll need to build HDB with -prof as well
09:59:10 <SyntaxNinja> hi shapr
09:59:16 <Lemmih> shapr: Is there an easy way of doing that?
09:59:30 <shapr> probably just stash -prof into the Makefile and rebuild
09:59:34 <shapr> whoa, he's back so soon!
10:01:11 <bringert> not for long
10:01:40 <tromp> let me know when you want to challenge my perfect playing program:)
10:02:05 <Oejet> tromp: How fast is it?
10:02:10 <tromp> near instant
10:02:39 <tromp> fraction of a second
10:02:50 <Oejet> tromp: Hm, I think, I'll think a little more before challenging you then.
10:03:18 <tromp> have you figured out the bitlayout yet?
10:03:54 <tromp> blue won
10:04:27 <Oejet> tromp: No, because the alpha beta pruning algorithm was so difficult for me to get correct. Now it's ok.
10:05:24 <tromp> alpha-beta is not that useful in connect4 unless you search all the way to the end
10:06:31 <Lemmih> Bzzt. That makes profiling very close to impossible /-:
10:06:33 <bourbaki> you can alpha - beta prune also if you dont search till the end
10:07:22 <tromp> you can, but you cannot make the evalutation function in connect4 that precise
10:07:27 <bourbaki> you just wont find the optimal state then maybe
10:07:49 <tromp> so even a 16 ply search will misunderstand many positions
10:07:54 <bourbaki> thats true
10:08:12 <bourbaki> but i guess the search space isnt that big anyway in c4 right?
10:08:39 <tromp> u can solve the game in an hour
10:12:10 <shapr> Lemmih: eh?
10:12:19 <shapr> Lemmih: HDB is way too slow with -prof ?
10:12:39 * shapr waits for GF to build
10:12:40 <Lemmih> shapr: Can't even compile it with -prof.
10:12:48 <shapr> what errors?
10:12:56 <bourbaki> shapr: you build your gf in haskell ;)?
10:13:11 <shapr> :-P Grammatical Framework
10:13:11 <bourbaki> if you would release that source i guess youd get the noble price ;)
10:18:03 * shapr is covered up with strange ideas
10:18:21 <tromp> i'd like to do a custom build :)
10:18:28 * shapr grins
10:20:25 <Oejet> Lemmih: Profilling the alpha beta algorithm?
10:22:01 <Lemmih> huh?
10:22:03 <Oejet> tromp: Does your brain has a hashtable of perfect moves or something similar?
10:22:20 <Oejet> Lemmih: Huh, yourself.
10:22:58 <Oejet> Lemmih: Were you talking about profiling Olinka II?
10:23:01 <Lemmih> Oejet: What alpha beta algorithm?
10:23:16 <DrX> hmm.. is there a function that converts a string to a Int ? (in my Standard functions list there is a function "ord" that goes from Char -> Int but that doesn't work in hugs)
10:23:20 <Oejet> Lemmih: Guess not. :-)
10:23:23 <Lemmih> No. I wanna profile halipeto.
10:23:41 <psi> DrX, read
10:23:43 <Lemmih> DrX: read.
10:23:46 <shapr> read!
10:23:48 <psi> !
10:24:03 <shapr> oh, I was saying that out of sheer peer pressure.
10:24:25 <joao> Hello
10:24:27 <shapr> hiya
10:24:36 <DrX> thanks :)
10:25:06 * SyntaxNinja is very pleased with the discussion on preprocessors on libraries@haskell.org :)
10:25:36 <Igloo> Well, we're pleased you're pleased too
10:25:44 <SyntaxNinja> I would actually like to use .hscpp or something for unpreprocessed files
10:25:56 <SyntaxNinja> it's a bit odd to use .hs for these, really.
10:26:24 <SyntaxNinja> though I'd hate to lose automatic syntax highlighting for such files :)
10:26:44 <shapr> -- -*- haskell -*-
10:26:45 <Igloo> It's what happens today. And they are Haskell source files in the sense that if you throw them at the compiler it will happily eat them
10:27:05 <SyntaxNinja> Igloo: if you throw them at some compilers
10:27:28 <SyntaxNinja> but that's more of a oddity of the compiler, really :)
10:28:21 <shapr> Re: The Libraries List, I think some people want to have interactive and editable input where they can make mistakes a bunch of times and no one cares.
10:28:42 <shapr> wikis are good for quick feedback, instant gratification, etc
10:29:20 <SyntaxNinja> shapr: that's a good point, though email is like that :)
10:29:29 <SyntaxNinja> well, not the 2nd part of what you said
10:29:41 <shapr> unless someone is on vacation, or takes awhile to respond or...
10:29:52 <shapr> plus this seems like something that's easy to automate.
10:30:20 * shapr resurrects his GF Swedish teaching code.
10:30:38 <tromp> oejet: no, i cannot play perfectly myself. but i'm a pretty mean c4 player:)(
10:30:57 <SyntaxNinja> shapr: like I (just) said on the list; like many things around here, it's a cultural issue
10:31:09 <SyntaxNinja> and I think we often have the instinct to throw theory or technology at cultural issues
10:31:20 <shapr> could be
10:31:21 <SyntaxNinja> and indeed, technology can shape culture of course, which is what I hope cabal will accomplish
10:31:25 <tromp> but then, so are most people who have read all of http://homepages.cwi.nl/~tromp/c4.html
10:31:53 <Lemmih> Darn! I can't remember how to fix HSQL /-:
10:31:55 <shapr> SyntaxNinja: for me, I'm loath to send in a real 'listing' for something like curryspondence.
10:32:00 <shapr> Lemmih: what's it doing?
10:32:08 <SyntaxNinja> porque?
10:32:22 <shapr> curryspondence was a fun and cheesy hack, I never got around to cleaning up the code for a real 'release'
10:32:25 <Oejet> tromp: Nice. I feel humble suddenly.
10:33:10 <shapr> so, curryspondence doesn't feel to me like something worth listing.
10:33:49 <psi> tromp, do you play go? :)
10:33:50 <Lemmih> Complaining about a missing 'postgres.h' (configure finds it just fine) and then spew lots of errors messages out about undeclared variables.
10:34:07 <tromp> yes, psi
10:34:39 <psi> ok. i just noticed a lot of go terms there
10:34:42 <tromp> as you can tell from my homepage:)
10:35:55 <shapr> SyntaxNinja: on the other hand, when skew had his entire ~/src/haskell/ directory listed on the web, I learned a lot in a very short time.
10:35:57 <tromp> some day i'll write a go program in haskell
10:36:00 <psi> i also play, but i'm not good at all :)
10:36:23 <shapr> I learned as much from his failed attempts as I did from his neat toys.
10:36:41 <Oejet> tromp: Maybe I'll challenge you in GO someday then.
10:36:54 <psi> maybe a tsumego solver
10:37:26 <shapr> Maybe I should do the same thing.
10:37:56 <tromp> http://www.qmw.ac.uk/~ugah006/gotools/ does that alrd
10:38:05 <Lemmih> shapr: Yay. Remembered how to dirty hack it.
10:38:36 <shapr> I'd very much like to see the random haskell bits some people have collected, William Lee Irwin III writes some amazing stuff, I'd love to browse esap's Haskell sources. Lots of other people's sources here I'd enjoy perusing.
10:38:36 <DrX> hmm... how can i make haskell evaluate a parameter to a function before it sends it away ? Ex: "ex :: String -> [Int] -> [Int]   \n  ex (x:s) i = ex ((read "x")::Int):i" (i left out the end case)
10:39:33 * shapr decides to try it.
10:39:44 <Igloo> You mean read x, not read "x", I think
10:40:16 <psi> tromp, cool
10:41:23 * shapr has 531 files in ~/src/haskell/
10:43:52 <Lemmih> I can't use ghci with a package that I've compiled with -prof?
10:44:20 <Igloo> Not even if you give ghci -prof on the command line?
10:44:42 <Lemmih> 'ghc-6.2.1: --interactive can't be used with -prof, -ticky, -unreg or -smp.'
10:44:48 <kosmikus> dblhelix: I've updated the installer and fixed a few bugs; the current version not only installs on our NT machine, even the test program works ...
10:45:58 <tromp> afk...
10:47:10 * Lemmih gives up.
10:50:02 <Igloo> Guess not, then
10:51:16 <shapr> Is there a generic viewer program for debian/linux? Something where I can just say "view filename" and it automatically picks a viewer for the file type?
10:52:35 <shapr> it sucks that I have to remember which papers are in pdf/ps
10:52:40 <tuomov> yes
10:52:54 <tuomov> run-mailcap, but there's some view link to it..
10:53:11 <tuomov> see
10:53:20 <shapr> ah, handy
10:53:37 <tuomov> that's what Ion's F5/F6 bindings use by default
10:54:35 <shapr> thanks
10:58:24 <DrX> are there a way to force evaluation of an expression ?
10:58:34 <shapr> seq or $! or DeepSeq
10:58:54 <DrX> thanks
10:59:12 <shapr> Igloo: do you know if Duncan's TH Partial Evaluator sources are online?
11:00:22 * shapr is thinking of applications in hemacs
11:01:29 <musasabi> Is there a way to wait on a MVar for a specified amount of time?
11:03:32 <shapr> I suspect that hs-plugins would mix in interesting ways with a partial evaluator that uses Template Haskell.
11:03:51 <Igloo> They aren't as far as I know
11:03:51 <shapr> musasabi: I think there was a thread about that on ghc-users just now
11:03:59 <shapr> Igloo: ok, I'll email him, thanks.
11:04:26 <Igloo> Anyone seen any problems with ghc 6.2.2 before I start building the final package?
11:04:59 <shapr> it's worked for me on snowblind.ScannedInAvian.org
11:06:15 <kosmikus> Igloo: works fine here
11:08:13 <Igloo> Ta
11:08:44 <SyntaxNinja> seemed to work to build wxhaskell
11:08:54 <SyntaxNinja> oh hm
11:09:09 <SyntaxNinja> I guess it's OK to build darcs w/ ghc 6.2.2 even though it's not in unstalbe, right?
11:09:56 <SyntaxNinja> and if you wait a few minutes, I can tell you if it looks OK for building darcs, fwiw.
11:10:12 <Igloo> I've started it now, but do let me know if there are any problems
11:10:34 <CosmicRay> SyntaxNinja: ok, but you can't build-dep on it if it's going into sid, and ti will build with 6.2.1 on all other platforms.  so I'd say ok but unwise. :-
11:10:41 <musasabi> shapr: thanks, I'll look that up.
11:10:56 <SyntaxNinja> CosmicRay: why?
11:11:11 <Igloo> A versioned build-dep is unnecessary
11:11:14 <SyntaxNinja> right
11:11:28 <Igloo> It'll probably go into sid tonight, so unless you're in a rush I'd wait
11:11:41 <SyntaxNinja> ok cool.
11:11:52 <CosmicRay> SyntaxNinja: because if you build it with 6.2.2 on your system, and it builds with 6.2.1 everywhere else, it may break due to some change between 6.2.1 and 6.2.2
11:12:09 <Igloo> CosmicRay: But that could happen anyway
11:12:21 <CosmicRay> true, but the resulting trouble will be harder to diagnose
11:12:23 <Igloo> But it does feel wrong to compile with something that hasn't hit unstable yet
11:12:49 <CosmicRay> there may be Debian policy on this
11:12:59 <CosmicRay> something like "everything in main can only build-dep on things in main"
11:13:01 <CosmicRay> I don't know for sure
11:13:07 <SyntaxNinja> it's not build-deping on it
11:13:11 <CosmicRay> actually there's a thread on this very topic right now
11:13:14 <CosmicRay> on -legal
11:13:20 <CosmicRay> the one about a guy wanting to use icc for something
11:13:26 <shapr> eek
11:13:28 <Igloo> Yeah, but that's a slightly different case again
11:13:31 <Igloo> It's all very grey  :-)
11:13:43 <Igloo> It's touched -devel a bit too
11:14:38 <SyntaxNinja> I think the best thing to do would be to debate it in heated tones until 6.2.2 makes it into sid or someone accuses someone else of taking away their rights, whichever happens first
11:14:40 <SyntaxNinja> it's the debian way
11:14:47 <CosmicRay> heh
11:14:53 <CosmicRay> I'm in favor of just putting it into sid :-)
11:14:59 <CosmicRay> but then you could probably have guessed that :-)
11:15:18 * SyntaxNinja is not sure what you mean
11:15:31 <CosmicRay> well, it seems like it doesn't break anything
11:15:37 <CosmicRay> so I figure, might as well just put it into sid
11:15:42 <CosmicRay> the whole problem goes away then.
11:16:57 <musasabi> shapr: don't see it in the october g-h-u archives, can you give a pointer to the subject?
11:17:15 <shapr> sure, lemme check my archives
11:17:43 * SyntaxNinja nods sagely while secretly not being able to reconcile CosmicRay's various comments
11:17:51 <CosmicRay> heh
11:17:54 <SyntaxNinja> I'll just wait 'till tomorrow to upload it
11:18:11 <DrX> Im getting tierd of this... This evaluate function doesn't work www.itstud.chalmers.se/~krysellh/upg3-04.hs  first i thought it was my function so i ripped the lecturers solution (thats the one in the file) but i still get the same error "Program error: pattern match failure: evalaute ["2","3","*","+"] [read instRead_v41 "1"]" I thought it was that (read x) didn't got evaluated before sending it to the function but with "seq" i got the same error
11:19:25 <musasabi> DrX: you have a simple typo there.
11:19:44 <musasabi> DrX: evaluate and evalaute
11:20:33 <shapr> musasabi: oh, not sure if this related or not: http://www.haskell.org//pipermail/glasgow-haskell-users/2004-October/007218.html
11:20:58 <shapr> In any case, it implies that you can block a thread on a timeout.
11:21:32 * DrX is banging his head against the keyboard
11:21:47 <shapr> is that how you got the typo? :-)
11:22:06 <DrX> musasabi, i didn't get any errors when running the file in hugs... it usualy complains like shit
11:22:18 <shapr> try using -Wall
11:22:26 <DrX> shapr, yes when i have been stuck with it for almost 1h
11:22:43 <DrX> shapr, when running hugs ?
11:23:36 <musasabi> hmm that is the timeout n = myThreadId >>= \tid -> forkIO (threadDelay n >> killThread tid)
11:23:48 <musasabi> which is what I am trying to avoid
11:24:55 <musasabi> DrX: it didn't complain because you define both a function evaluate (the first forms) which call the function evalaute (the last form). Now the evalaute only works for the empty list case thus causing the error.
11:26:01 <CosmicRay> is there any version of select() or poll() in the ghc libs?
11:26:03 <CosmicRay> I can't find one
11:26:41 <DrX> musasabi, omg! now thats a nasty typo imo.
11:26:52 <DrX> a sneaky one
11:27:20 <musasabi> yes, particulary as it is hard to see ones own typos.
11:30:54 <Igloo> CosmicRay: There's a select in the old hslibs, but you're meant to use threads nowadays
11:31:16 <CosmicRay> ugh, threading is not a replacement for select
11:31:42 <CosmicRay> there are times when it is entirely impractical to use anything but select/poll
11:33:18 <Igloo> I couldn't think of one Simon Marlow didn't have an answer to when I talked to hime about it a while ago
11:33:53 <Igloo> (these are Haskell threads, not pthreads or anything incidentally. I think there'll be a select in the RTS doing the actual work)
11:34:47 <musasabi> There is a select in Select.c
11:35:17 <Igloo> .c? If you're going to call c you might as well call select  :-)
11:35:37 <musasabi> Igloo: well that is used for the whole rts..
11:35:51 <musasabi> Igloo: select is not very portable (windows).
11:35:52 <Igloo> Oh, I see, you're talking about how it's implemented
11:36:42 <musasabi> yes..
11:41:27 <musasabi> the implementation of threadDelay seems particularly nasty.
11:42:14 <musasabi> (ghc/rts/PrimOps.hc delayzh_fast)
11:49:33 <CosmicRay> huh, Igloo, so you're saying that Haskell threads are like the icky Java green threads?
11:49:53 <CosmicRay> IE, internal multiplexing using select(), but providing no actual speed benefits for SMP systems?
11:50:41 <Igloo> Yes. You can forkIO if you want another OS thread
11:51:09 <Igloo> I don't know if there's any pthreads support OTTOMH
11:51:39 <Igloo> Err, ITIM forkOS
11:52:03 <musasabi> CosmicRay: most of the time you don't need SMP for haskell..
11:52:12 <CosmicRay> where can I find forkIO or forkOS?
11:52:23 <Lemmih> @index forkIO
11:52:23 <lambdabot> Control.Concurrent
11:52:27 <musasabi> CosmicRay: and soft threads switch faster and consume less system resources than hard kernel based threads.
11:52:37 <CosmicRay> @index forkOS
11:52:37 <lambdabot> Control.Concurrent
11:53:12 <CosmicRay> musasabi: yes, which is one benefit of select()/poll().  OTOH, if you are doing compute-intensive stuff, you probably want real threads, especially if you have smp
11:54:18 <CosmicRay> well OK, that's slick.  so if I'm understanding correctly, Haskell'
11:54:27 <CosmicRay> s internal implementation of forkIO will use select or poll
11:54:39 <CosmicRay> but to the programmer, the regular socket or handle functions are used unmodified
11:54:40 <CosmicRay> yes?
11:54:47 <musasabi> CosmicRay: but then you can use forkOS ;)
11:55:09 <CosmicRay> and if I prefer instead to use real threads, I could just s/forkIO/forkOS/
11:55:22 <CosmicRay> that's a very nice architecture if I'm understanding it correctly. :-)
11:56:53 * Jan__w is freaking out (almost), please let me why 192 & 64 where the numbers are Ints does but work ? .&. from Bits does not work either
11:57:37 <CosmicRay> Jan__w: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Bits.html
11:57:45 <CosmicRay> wrong operator :-)
11:58:04 <CosmicRay> oh.
11:58:09 <CosmicRay> didn't read your second thing
11:58:13 <CosmicRay> what do you mean by "does not work"?
11:58:28 <Lemmih> (.&.) works fine for me.
11:58:39 <Igloo> You probably want Int32 if you are using Data.Bits. Dunno if that's your problem or not
12:00:05 <Lemmih> Igloo: But Int is an instance of Bits as well...
12:01:15 <Jan__w> do i need to import Bits first ? 
12:01:49 <Lemmih> Yes.
12:02:10 <Igloo> OK, I wasn't sure. But people using it without thinking worries me...
12:02:42 * shapr is also an instance of Bits
12:03:50 <phubuh> shapr: jimmy eat world is awesome :-)
12:03:58 <shapr> yeh :-)
12:04:02 <shapr> phubuh: you got anymore Reds?
12:04:30 <phubuh> i think vacuum might qualify
12:04:32 <phubuh> for me at least :-)
12:04:34 <shapr> phubuh: have you tried Mr Scruff - Get a Move On, and St. Germaine - Rouge Rose?
12:04:59 <shapr> what's vacuum?
12:05:14 <phubuh> a swedish electro-pop band, sort of
12:05:31 <phubuh> i can give you mp3s if you don't respect copyright :-)
12:05:39 <shapr> hm :-/
12:05:52 <shapr> do they have a website where I can download legal samples?
12:06:06 <shapr> Have you tried The Crystal Method yet?
12:06:14 <Jan__w> testme :: Int -> Int -> Int
12:06:16 <Jan__w> testme a b = (a .&. b)
12:07:07 <Jan__w> Type error in application  ... *** Expression     : g (.&.) 1 *** Term           : g *** Type           : Int *** Does not match : a -> b -> c  
12:07:17 <phubuh> oh!  apparently you can download all their albums ... in wma
12:07:20 <phubuh> http://audio.vacuum-music.com/albums/
12:07:30 <shapr> yay!
12:07:45 <phubuh> i've only listened to the plutonium cathedral so far
12:07:54 <shapr> right, I'll try it.
12:08:01 <phubuh> cool :-)
12:08:05 <Igloo> Jan__w: The error doesn't match the code
12:08:41 <phubuh> i wonder if the song title of 'atlas shrugged' is coincidental
12:08:54 <Jan__w> Igloo: the line number refers to the testme a b = (a (.&.) b) line
12:08:54 <shapr> coincidental to what?
12:08:56 <shapr> Ayn Rand?
12:09:03 <phubuh> yeah
12:09:06 <drlion> shapr: by Reds, do you mean Doktor Kosmos?
12:09:12 <phubuh> haha
12:09:23 <drlion> (I seriously don't get it)
12:09:39 <phubuh> think the opposite of 'the blues'
12:09:42 <shapr> right
12:09:55 <CosmicRay> Jan__w: that compiles fine for me
12:10:10 <drlion> and what is the blues?
12:10:12 <Jan__w> CosmicRay: hm, I don't get it then
12:10:14 <shapr> drlion: I wrote about The Reds on my website: http://www.scannedinavian.org/
12:10:17 <CosmicRay> Jan__w: now in the example you posted, you said (a .&. b)
12:10:25 <CosmicRay> Jan__w: now you are saying (a (.&.) b)
12:10:31 <CosmicRay> which did you use?
12:10:46 <Jan__w> both
12:10:50 <Jan__w> same rezult
12:10:54 <CosmicRay> well, the first is correct
12:11:05 <drlion> is The Reds something fun, a programming language or something to do with unicycling?
12:11:05 <CosmicRay> maybe the error is elsewhere
12:11:10 <CosmicRay> you did import Data.Bits, right/
12:11:11 <phubuh> http://www.scannedinavian.org/output/en/reds.html
12:11:24 <phubuh> it's random :-)
12:11:48 <Lemmih> Jan__w: You could post the entire source code on the haskell wiki.
12:11:57 <shapr> What's random?
12:12:07 <drlion> oic
12:12:27 <phubuh> the page about the reds is in the random category
12:12:32 <shapr> oh
12:12:34 <shapr> right
12:13:59 <shapr> gutenabend pesco 
12:14:08 <shapr> phubuh: dang, the downloads don't work :-(
12:14:19 <Jan__w> CosmicRay: I imported just Bits
12:14:20 <Igloo> :q
12:14:23 <Igloo> Bah
12:14:24 <phubuh> shapr: :-/
12:14:25 <Jan__w> maybe thats it
12:14:30 <Jan__w> oho
12:14:34 <Jan__w> system going down
12:14:39 <Jan__w> damn
12:14:51 <Jan__w> houston.. wee have a problem
12:14:53 <pesco> Hey everyone.
12:15:03 <Lemmih> Hello pesco
12:15:03 <shapr> that sounded interesting
12:16:08 <Lemmih> Wow. Almost a hundred people in #haskell (-:
12:16:19 <pesco> Woo. I'm giving a Haskell intro at this year's Chaos Communication Congress!
12:16:20 <shapr> neat
12:16:25 <shapr> pesco: spiffy!
12:16:47 <shapr> asyd is researching a tcp/ip stack for hOp, that could be interesting for the CCC guys.
12:16:58 <pesco> Yeah!
12:18:26 <shapr> I just had a thought today that the pSwitch combinator in Yampa maybe could be used to allow an arrow-style TCP/IP stack to look like (dll >>> ip >>> tcp)
12:18:55 <pesco> pSwitch pSwitch... What's that do exactly, again?
12:19:03 <shapr> and (dll <<< ip <<< tcp) for the other direction.
12:19:47 <shapr> pSwitch sticks together a collection of signal functions into a single signal function, and takes a trigger and a 'modifier'
12:20:16 <shapr> when the trigger flips, it passes the resulting event to the modifier, and the modifier changes the contents of the collection
12:20:39 <pesco> Ah, the p is for "parallel"?
12:20:53 <shapr> my original thought on building a TCP/IP stack with arrows was to use the Automaton arrow instance
12:21:32 <shapr> but in that case, the new resulting Auto arrow with different stack state doesn't replace the old one.
12:22:28 <shapr> I think with pSwitch, the resulting Auto could replace the contents of the collection and then you effectively have an arrow that modifies itself.
12:22:44 <shapr> Does that sound reasonable?
12:25:03 <shapr> greetz Cale 
12:25:13 <Cale> greetz
12:25:58 <shapr> pesco: yes, I think it's for parallel
12:27:01 <shapr> pesco: anyway, see any flaws in the logic there?
12:27:11 <pesco> shapr: I'm not able to follow right now.
12:27:24 <dblhelix> kosmikus: same url to the new version?
12:27:41 <shapr> pesco: no worries
12:27:49 <shapr> pesco: writing fun code?
12:28:08 <pesco> shapr: Not really, I'm a little numb from a day of installing software.
12:28:32 <CosmicRay> pesco: on hat OS?
12:28:40 <pesco> But I've finally had a look at the update of the Cmdline module I was planning since last week.
12:28:43 <shapr> hat?
12:28:51 <CosmicRay> pesco: oh?  what does this module do?
12:28:52 <pesco> CosmicRay: Linux
12:28:56 <CosmicRay> pesco: pfft, you got it easy
12:29:05 <CosmicRay> pesco: It took me 2 or 3 days just to get ghc built for AIX
12:29:13 <CosmicRay> pesco: that that was about average for AIX :-)
12:29:37 <shapr> well, pesco did port GHC too
12:29:43 <shapr> hiya arauko
12:29:43 <pesco> CosmicRay: It's a command line parser. AIX, heh.... ;-)
12:29:48 <CosmicRay> shuddup :-)
12:29:52 <pesco> shapr: pssst.
12:29:59 <CosmicRay> was not my choice :-)
12:30:24 * pesco mumbles something about the porting guide.
12:30:37 * CosmicRay mumbles something about it not helping much with AIX :-)
12:30:50 <CosmicRay> well, it did tell me the steps I needed to perform
12:30:52 <pesco> CosmicRay: I suspect, GHCi doesn't work for you?
12:30:56 <CosmicRay> correct
12:31:00 <CosmicRay> I have an unregisterized port
12:31:08 <arauko> shapr, hello 
12:31:08 <CosmicRay> I don't know enough to write the linker code for aix
12:31:15 <shapr> arauko: nice signoff msg
12:31:23 <pesco> Then your situation is similar to mine.
12:31:27 <CosmicRay> oh, and matters are made worse, apparently, since we're on ppc64
12:31:30 <shapr> greetings godzilla, welcome to our humble coastal IRC channel.
12:31:35 <CosmicRay> there were a lot of autoconf tests that were wrong
12:31:37 <CosmicRay> some gmp confusion
12:31:37 <CosmicRay> etc.
12:31:49 <CosmicRay> some things compiled code to POWER, others to PowerPC, and others to PPC64
12:31:53 <CosmicRay> a muddled mess
12:32:02 <pesco> Heh, wow.
12:32:27 <pesco> I see, you're running AIX on PowerPC's?
12:32:35 <CosmicRay> that's what IBM sells it on these days
12:32:50 <shapr> Did they do AIX on something other than PPC?
12:32:52 <arauko> shapr, :-)
12:32:52 <pesco> Interesting. Is that the 970, as in Apple's G5?
12:32:59 <CosmicRay> shapr: RS6000
12:33:11 <CosmicRay> shapr: and POWER (the precursor to the PowerPC)
12:33:32 <arauko> shapr, actually you are the first person who see the beauty behind that message, i am always insulted by most of the people when i come beck to the channels. :-)
12:33:44 <shapr> huh, the box we had in Seattle said RS6000 on the front, and was a 604e 
12:33:48 <CosmicRay> pesco: I don't know exactly what model it is
12:33:56 <shapr> arauko: that message is exactly why I use Haskell.
12:34:00 <CosmicRay> pesco: and uname just says "unknown unknown', feh
12:34:05 <arauko> shapr, :-)
12:34:09 <pesco> CosmicRay: :)
12:34:24 <pesco> CosmicRay: Anyway, should you get the linker to work, drop me a line!
12:34:40 <shapr> On the good side, that 233MHz 604e AIX box was the fastest floating point cruncher I've seen in a long time.
12:34:42 <CosmicRay> pesco: I'm not planning to add COFF support to it :-)
12:34:50 <pesco> COFF.
12:35:02 <pesco> I see.
12:35:05 <CosmicRay> pesco: ghc works via C.  That's all I need.  I'm happy.
12:35:07 <CosmicRay> yes
12:35:14 <CosmicRay> you didn't think AIX would use something modern like ELF, did you?
12:35:19 <CosmicRay> shared libraries barely work here
12:35:26 <pesco> I've never touched AIX.
12:35:26 <CosmicRay> they're "new".
12:35:28 <CosmicRay> heh
12:35:38 <CosmicRay> you don't pronounce it "aches" for nothing :-)
12:35:44 <pesco> Haha.
12:36:20 <shapr> kosmikus2: you have a twin?
12:36:25 <kosmikus2> :)
12:36:37 <kosmikus2> locked myself out of my office computer
12:37:15 <pesco> CosmicRay: I tried to port the linker to linux-ppc32 but it kept failing for reasons beyond my comprehension.
12:37:30 <CosmicRay> hm.
12:37:35 <CosmicRay> what sort of errors did you get?
12:37:40 <pesco> I'm not sure.
12:37:51 <shapr> kosmikus2: at least you know it's secure.
12:38:00 <CosmicRay> perhaps the problem with the comprehension part is failing to read the error messages :-)
12:38:16 <kosmikus2> shapr: :)
12:38:31 <pesco> CosmicRay: Well, I think it was something along the lines of "the impossible happened"...
12:38:37 <CosmicRay> oh.
12:38:39 <CosmicRay> that sucks.
12:38:44 * CosmicRay has seen that a couple of times
12:38:52 <kosmikus2> hmm
12:38:54 <CosmicRay> pesco: I wrote a gcc wrapper script
12:38:57 <CosmicRay> named it gcc
12:39:00 <CosmicRay> put it at the head of my path
12:39:02 <shapr> it's amazing how often the impossible happens.
12:39:06 <CosmicRay> #!/opt/freeware/bin/bash
12:39:06 <CosmicRay> exec /usr/local/bin/gcc -mpowerpc -maix32 -mminimal-toc "$@"
12:39:16 <CosmicRay> the -mpowerpc and -mminimal-toc may be of use for you
12:39:27 <pesco> Why?
12:39:44 <dblhelix> kosmikus2: same url to the new version?
12:39:49 <CosmicRay> powerpc has some sort of toc thing.  I don't know what it is, but unless I build ghc with -mminimal-toc, ld crashes with weird toc overflow errors, occasionally leading to a segfault or impossible thing happening to ld
12:40:36 <CosmicRay> "the impossible happened" is almost as bad as those bad Perl programs that generate errors that say "Error opening file: Success"
12:40:38 <CosmicRay> I hat those
12:40:47 <pesco> lol
12:41:37 <pesco> I think I was basically getting segfaults because the relocation went wrong.
12:41:46 <CosmicRay> the toc thing is related somehow
12:41:52 <CosmicRay> it's all rather beyond me
12:42:11 <pesco> I have no problems with ld though.
12:42:20 <pesco> GHC runs fine on linux-ppc.
12:42:26 <CosmicRay> oh, so the impossible is happening in your own code?
12:42:43 * CosmicRay is confused
12:42:44 <pesco> Just the GHCi dynamic linker doesn't know how to perform the relocation on powerpc.
12:42:48 <shapr> where do I get pslatex.sty ?
12:42:49 <CosmicRay> oh.
12:42:55 * shapr looks at kosmikus2
12:43:21 <pesco> So I fetched the relevant documentation, implemented the relocations as described, and it segfaulted.
12:43:41 <pesco> Then I stopped. ;-)
12:43:44 <kosmikus2> shapr: why would you want to?
12:43:54 <shapr> GF wants it when building docs
12:43:58 <pesco> I might revisit this issue the next time I seriously want GHCi, though. :)
12:44:12 <kosmikus2> shapr: GF?
12:44:18 <shapr> Grammatical Framework
12:44:28 <kosmikus2> shapr: anyway, it's included in any reasonable TeX distribution
12:44:31 <shapr> oh
12:45:17 <shapr> do I need tetex-src for that?
12:45:29 <kosmikus2> no
12:46:28 <kosmikus2> maybe tetex-extra, though
12:46:38 <kosmikus2> or however debian arbitrarily splits things
12:46:45 <Lor> I met Aarne Ranta once when he was guest lecturing in Helsinki. I sent him some patches to PESCA's user interface, but he never adopted them...
12:47:06 <shapr> surprising
12:47:27 <kosmikus2> surprising?
12:47:32 <shapr> He seems happy to get input from me so far.
12:47:37 <kosmikus2> ah, nm
12:47:45 * shapr installs tetex-extra
12:47:53 <shapr> Lor: did you get a response back from him at all?
12:47:59 <Lor> Tell him to incorporate my proof-rendering patch. :)
12:48:23 <shapr> GF is fun to hack on.
12:48:39 <shapr> And I can claim I'm doing Swedish homework while hacking on Haskell.
12:48:55 <Lor> He said my patch was very cool, but ended the note with:
12:48:58 <Lor> En ehdi nyt paneutua Pesca-sivujen päivittämiseen, kun siellä on se
12:48:58 <Lor> suht bugiton vanha koodi jota monet käyttävät - mutta pysytään
12:48:58 <Lor> yhteydessä.
12:50:11 <shapr> no new development? bugfixes only?
12:51:28 <Lor> He just said he didn't have the time, and sort of implied that the "bugless" current pesca distribution is good enough.
12:51:36 <shapr> ah
12:52:06 <shapr> hello again Russell\ 
12:52:19 <Lor> http://www.cs.helsinki.fi/u/lealanko/stuff/pesca-la.tar.gz
12:52:52 * shapr grabs
12:53:01 <shapr> 403
12:53:17 <Lor> now.
12:53:31 <shapr> ok
12:53:45 <Russell\> hi shammah 
12:53:47 <Russell\> ops -.-
12:53:51 <shapr> I haven't even looked at PESCA yet.
12:53:55 <Russell\> hi shapr  :D
12:53:56 <shapr> Russell\: how's code?
12:54:25 <Russell\> what are u talkin' about? :|
12:54:47 <shapr> Russell\: are you writing any code?
12:55:40 <Russell\> not now
12:56:11 <shapr> the way I see it, code is life... so if I ask how's code, then it's the same as "How's life?"
12:56:29 <Russell\> ok... i'll try to remember it
12:56:31 <shapr> Have you written some Haskell before?
12:56:49 <Russell\> i come from tcl... i'm just a newbie
12:57:00 <shapr> cool! welcome!
12:57:14 <shapr> Have you already found a tutorial and other resources?
12:57:21 <shapr> Do you have any questions?
12:57:37 <Russell\> i found tutorials etc. etc. i haven't got any question :D
12:57:52 * CosmicRay is working on a new Haskell tutorial
12:57:58 <Russell\> *'ve
12:58:21 <shapr> CosmicRay: is it wiki-editable?
12:58:27 <CosmicRay> no, I'm using docbook
12:58:34 <shapr> Russell\: ok, if you have any questions, or want some intros, ask me!
12:59:02 <Russell\> thanks shapr you're very k?nd
13:00:58 <shapr> :-)
13:07:12 <shapr> how do I turn a dvi file into ps?
13:07:32 <kosmikus2> dvips
13:07:43 <shapr> doh, too easy
13:07:47 <kosmikus2> however, that's sometimes preconfigured to send to the printer
13:07:57 <shapr> I've never owned a printer.
13:07:59 <kosmikus2> dvips -o outfile.ps infile.dvi
13:08:04 <kosmikus2> and you're on the safe side
13:08:09 <shapr> ok
13:28:07 <shapr> nifty nickname
13:28:18 <shapr> greetings Naughty_Minnow
13:28:30 <shapr> are you looking for Haskell info?
13:28:30 <Naughty_Minnow> hello!
13:28:38 <Naughty_Minnow> yes i am as it happens
13:28:52 <shapr> What a lucky coincidence, we happen to have Haskell info!
13:29:02 <Naughty_Minnow> haha excellent!
13:29:04 <shapr> So, are you learning? looking for some specific answer?
13:29:08 <Naughty_Minnow> i like this place already
13:29:14 <pesco> :)
13:29:23 <Naughty_Minnow> well,
13:29:35 <pesco> Hello, stepcut!
13:29:39 <stepcut> hello
13:29:42 <stepcut> pesco
13:29:52 <bourbaki> heh
13:30:19 <pesco> Do you remember asking me the other day about handling "cvs -d foo co -d blah" with Pesco.Cmdline? Of course that works. I seem to be unfamiliar with my own library.
13:30:32 <stepcut> heh
13:30:57 <stepcut> hold on
13:30:58 <Naughty_Minnow> shapr, i am writing a method that takes two bags (which i have defined as a list of tuples of (a, Int)) and it must return a new bag which is the union of the 2 bags
13:31:00 <shapr> Naughty_Minnow: still there?
13:31:06 <Naughty_Minnow> sorry long reply!
13:31:07 <shapr> ah, ok.
13:31:58 <stepcut> pesco: what is the url, I can't find the copy I got before...
13:32:07 <Naughty_Minnow> the bags are [("cheese",3),("elephants",5)] for example to represent the contents of a small and unusual zoo o_0
13:32:47 <shapr> Naughty_Minnow: so, do you already know how to add lists together?
13:32:55 <Naughty_Minnow> yeah
13:33:05 <Naughty_Minnow> i was thinking converting the 2 bags to lists
13:33:06 <pesco> stepcut: It works as long as you can split the command line without looking at the options.
13:33:08 <Naughty_Minnow> then adding them
13:33:18 <Naughty_Minnow> but that's kind of beating about the bush really
13:33:19 <pesco> stepcut: The url: http://www.scannedinavian.org/~pesco/
13:33:37 <shapr> how do you define union?
13:33:40 <shapr> what should the result look like?
13:34:35 <Naughty_Minnow> bagAddition [("alpha",1),("beta",2)] [("alpha",3),("beta",4)]
13:34:37 <Naughty_Minnow> will return
13:34:53 <Naughty_Minnow> [("alpha",4),("beta",6)]
13:34:59 <shapr> ok, that makes sense.
13:35:22 <shapr> do you know how to get only the first or the second part of a tuple?
13:35:28 <pesco> stepcut: So it's not really an "officially supported feature", but can be achieved in certain cases with little extra help.
13:35:59 <stepcut> pesco: oh ?
13:36:02 <Naughty_Minnow> fst
13:36:04 <Naughty_Minnow> snd
13:36:20 <Naughty_Minnow> i tried:
13:36:22 <shapr> right, it sounds like you already understand all the tools you'll need for this.
13:36:38 <shapr> assuming you can add two numbers, and check for equality.
13:36:45 <pesco> stepcut: Hm. Wait.
13:37:01 <pesco> stepcut: I forgot about option arguments!
13:37:03 <Naughty_Minnow> i tried this for a bagToList function:       bagToList (h1:t1) = replicate snd h1 fst h1: bagToList t1
13:37:22 <Naughty_Minnow> but Hugs disagreed
13:37:49 <Naughty_Minnow> takes a bag, returns a list that is
13:38:08 <pesco> stepcut: Are you implementing something where you need this functionality, out of interest?
13:39:47 <stepcut> pesco: I am implementing a command-line parsing argument library (or modifying an existing one). Currrently I am trying to document everything I might want to be able to do...
13:40:01 <pesco> Heh.
13:40:20 <pesco> I see.
13:40:22 <shapr> Naughty_Minnow: I don't think you'll need to turn the bag into a list
13:40:34 <Naughty_Minnow> no i thought that was a very longwinded way
13:40:35 <stepcut> Like, automatically generate bash completion code from the options spec :)
13:40:50 <pesco> stepcut: Good idea!
13:40:57 <stepcut> yeah
13:41:04 <tuomov> sort & foldl
13:42:24 <pesco> stepcut: I specifically chose not to try and implement every possible feature a command line parser could have.
13:42:28 <Matt-W> Anybody know a good primer on category theory?
13:42:33 <Naughty_Minnow> i'm not very experienced in lists is part of the problem (having said that my haskell experience anywhere isn't monstrous)
13:42:43 <stepcut> pesco: right, I am taking the opposite approach =)
13:43:06 <pesco> stepcut: I'm interested to see what happens. ;)
13:43:11 <shapr> Matt-W: this is a conceptual approach: http://www.xp123.com/wwake/dissertation/model.shtml
13:43:42 <stepcut> pesco: I wanted to see if by find all the most obscure command-line parsing requirements, I could come up with a system that is both more powerful and easier to use than the current systems
13:43:51 <shapr> Naughty_Minnow: can you write a function that checks to see if two bags have the same content?
13:43:52 <stepcut> pesco: the anwser may be no :)
13:43:58 <Naughty_Minnow> hmm
13:44:17 <Matt-W> shapr: thanks
13:44:57 <shapr> Matt-W: I have Lawvere&Schanual "Category Theory something" part of the conceptual mathematics series
13:45:07 <shapr> but it doesn't hold my interest very well
13:45:25 <shapr> I think I've made it about twenty pages in
13:45:33 <shapr> after six or seven tries :-/
13:45:34 <stepcut> pesco: cvs has a pretty complex command-line, as does find
13:45:42 <tuomov> esap pasted a link to a rather decent-looking primer some days ago..
13:45:59 <pesco> stepcut: True.
13:46:13 <stepcut> pesco: find is interesting because the ordering of the options is important, and options can be repeated
13:46:28 <stepcut> pesco: like -o, -a, -not, etc
13:46:38 <pesco> stepcut: I'd not consider find's "options" options, I think.
13:46:49 <tuomov> http://citeseer.ist.psu.edu/487012.html
13:46:52 <pesco> Did I already mention that in the past? Dejavu.
13:47:09 <tuomov> it is short on proofs, but seems to be rather understandable account to get an overall idea from
13:47:23 <stepcut> pesco: what would they be then ?
13:47:45 <Naughty_Minnow> shapr: i already have a function that checks bag equality, but it looks like this bagEqual [] [] = True
13:47:46 <Naughty_Minnow> 	bagEqual bag1 bag2 = bag1==bag2
13:47:46 <pesco> stepcut: Well, -a -o etc. clearly build boolean expressions.
13:48:02 <stepcut> pesco: right...
13:48:06 <shapr> Naughty_Minnow: yes, but, can you check for bag contents equality?
13:48:06 <Naughty_Minnow> and doesn't really delve into the tuples
13:48:19 <Matt-W> shapr: maybe I'll avoid that one then
13:48:44 <pesco> stepcut: The rest are predicates and actions. I'd say, drop the '-'s in front and make a real parser with Parsec...
13:48:51 <shapr> Matt-W: I dunno, I just have trouble getting into stuff that I can't see how to really use.
13:49:13 <shapr> some people seem to have enjoyed it.
13:49:32 <pesco> stepcut: I'm not sure what to make of cvs-style subcommand things.
13:49:40 <stepcut> pesco: right, that is where I think I am heading -- a parsec like system for command-lines
13:49:58 <pesco> stepcut: The first prototype of my lib is actually implemented with Parsec.
13:50:04 <stepcut> pesco: heh
13:50:34 <Naughty_Minnow> i don't know how i would go about that.. i could look at the head of the bag1, and then if i could find a tuple in bag2 with the same fst i could sum the snd's of each, but i don't know how i would find such an element from a list (bag)
13:50:35 <CosmicRay> really
13:50:44 <CosmicRay> isn't parsec overkill when you already have the args split out?
13:51:11 <pesco> CosmicRay: Heh, the pre-splitting of args is actually the worst thing about command line parsing.
13:51:23 <pesco> Thank you, C.
13:51:37 <CosmicRay> pesco: oh, you'd rather have to do globbing and parsing of ", ', etc. yourself? :-)
13:51:48 <shapr> Naughty_Minnow: if you had two bags of the same 'type' in a list [("bag",1),("bag",3)] could you write a function to check those for equal type?
13:51:54 <CosmicRay> actually, not having pre-splitting would be insecure, too
13:51:59 <CosmicRay> think of filenames with spaces in them, etc.
13:52:04 <pesco> Yes, parsec is overkill. But it was a good exercise in structure.
13:52:09 <shapr> command lines are just totally insecure.
13:52:11 <CosmicRay> ok, cool.
13:52:15 <bourbaki> where can i read on that => in classes?
13:52:25 * CosmicRay accepts "I learned something" as a valid reason for lots of things :-)
13:52:44 <CosmicRay> http://www.isi.edu/~hdaume/htut/
13:53:00 <tuomov> @index nubBy
13:53:00 <lambdabot> Data.List,List
13:53:04 <shapr> pesco: found any arrow-style parsec?
13:53:12 <CosmicRay> bourbaki: page 40, 85, or 108
13:53:17 <pesco> shapr: No?
13:53:23 <shapr> oh, too bad.
13:53:33 <Naughty_Minnow> shapr: by type do you mean the first element in the tuple, i.e. "bag"?
13:53:39 <bourbaki> CosmicRay: page of which book? i dont have a book at hand atm otherwise i wont ask :)
13:53:40 <shapr> Naughty_Minnow: that's correct
13:53:50 <CosmicRay> bourbaki: of that URL I gave you
13:54:00 <CosmicRay> bourbaki: http://www.isi.edu/~hdaume/htut/
13:54:07 <bourbaki> CosmicRay: ah that was for me thanks and sry
13:54:10 <CosmicRay> no prob
13:54:15 <pesco> CosmicRay: Of course quotation should not be parsed by the application. Nor should globbing be done by it. But you have to admit that the simplistic way the system works in C is deficient.
13:54:29 <pesco> s/works in C/works under Unix/
13:54:50 <CosmicRay> pesco: I dunno, I think it works reasonably well.  We have getopt for when it doesn't. :-)
13:54:52 * Naughty_Minnow has a go
13:54:58 <CosmicRay> I think that's the right way to do it, too.
13:55:07 <CosmicRay> let you do a simple low-level thing if you want
13:55:10 <CosmicRay> and layer more powerful stuff atop it
13:55:14 <CosmicRay> it's the Unix Way
13:55:57 <pesco> I mean the command line parsing is done half-way by the shell and the app is left to perform the other half.
13:56:31 <pesco> Consider a LISP-like interface.
13:57:47 <shapr> Naughty_Minnow: do you know how to pick the first item off a list and work with it? or even the first two?
13:58:19 <pesco> I'm not a very deep LISP programmer, but I'm pretty sure you could come up with a really decent way of supporting everything the Unix command line traditionally offers but in a more structured (and more secure) manner.
13:59:46 <tuomov> passing (key, value) pairs along with a list of extra data might work
14:00:00 <tuomov> would make parameters more consistent too between programs
14:00:53 <pesco> tuomov: (key, value) is basically what's done in LISP with (foo :key value)
14:00:55 <tuomov> but then they might not be consistent with help
14:01:30 <tuomov> the current way works well enough. worse is better.
14:01:42 <Naughty_Minnow> shapr: head is the first item and tail the rest, and !! i think is a specific entry, but to iterate through and check the fst of each tuple in the list?
14:02:01 <pesco> tuomov: I'm a perfectionist.
14:02:03 <tuomov> Naughty_Minnow: nubBy
14:03:17 <Naughty_Minnow> hold on...
14:03:46 <shapr> Naughty_Minnow: do you understand how the colon in a function's arguments works? like this "myFunction (x:xs) ="
14:03:58 <Naughty_Minnow> x is the head and xs is the tail
14:04:27 <shapr> have you defined any recursive functions?
14:04:29 <tuomov> pesco: I don't think such core features should dictate policy.. policy is annoying if you want to make things in a new way, and also such approaches are often bloated
14:04:45 <Naughty_Minnow> i have            listToBag (h:t) = (h,length [y|y<-(h:t), y==h]): listToBag [x|x<-(h:t), x/=h]
14:05:20 <Naughty_Minnow> i find i understand list comprehensions quite well
14:05:22 <tuomov> Ion wouldn't be possible if X and the ICCCM didn't specify as little policy as is necessary to get anything working at all
14:05:43 <pesco> tuomov: I wasn't trying to impose policy, was I?
14:05:49 <shapr> ok, the best way to iterate in Haskell is to either use recursion, or one of the standard iteration functions.
14:05:54 <Naughty_Minnow> ok
14:05:58 <pesco> tuomov: (Not meant rethorical even)
14:06:10 <tuomov> it is more "political" than a simple list of parameters
14:06:13 <shapr> Have you ever seen (x:y:zs) used in function arguments?
14:06:19 <Naughty_Minnow> no?
14:06:38 <tuomov> not excessively so, though
14:06:40 <shapr> x and y are the first two times, and zs is the rest
14:06:44 <bourbaki> hm ok i cant come up with a proper definition of this in the tuts i have seen or im too dumb
14:06:45 <Naughty_Minnow> i could guess x is the head, y is the second, zs the rest though
14:06:48 <bourbaki> instance (Addable a, Addable b) => Addable (a,b) where
14:06:54 <shapr> Naughty_Minnow: try typing 1:[] into hugs
14:07:03 <bourbaki> of what class is this an instance ?
14:07:04 <pesco> tuomov: Actually, no. It's just a list of parameters in LISP, too. The parsing of ":key value" and stuff is just conventional (and built-in).
14:07:09 <shapr> and then try 1:2:[]
14:07:25 <Naughty_Minnow> wow
14:07:38 <shapr> the : puts items into a list
14:07:44 <kosmikus2> bourbaki: Addable?
14:08:03 <shapr> and it means the same thing in the function, "give me the items from the list"
14:08:12 <bourbaki> kosmikus2: ok and what is that => good for?
14:08:17 <Naughty_Minnow> i new of concatenation, i used it in listToBag, i guess in this instance it it concatenating 1 with an empty list
14:08:21 <Naughty_Minnow> *knew
14:08:36 <tuomov> pesco: are we talking of the same thing? I was thinking of the shell/kernel already passing parameters in such format
14:08:47 <kosmikus2> bourbaki: it's like a rule in a logical program
14:09:02 <shapr> Naughty_Minnow: concatenation is adding two lists together, but : puts something into a list.
14:09:11 <kosmikus2> bourbaki: if you have an instance of Addable for a, and one for b, you can make one for (a,b), and here (after the "where") is how ...
14:09:21 <bourbaki> kosmikus2: ok so it says if i have a tuple of Addables ... then its an instance of Addable itself?
14:09:40 <Naughty_Minnow> oh ok then
14:09:41 <pesco> tuomov: I was thinking simply of replacing the Unix shell and C calling convention with something more like LISP function calls.
14:09:45 <bourbaki> kosmikus2: ah ok
14:09:47 <pesco> Think of LISP machines.
14:09:49 <kosmikus2> no, the (,) syntax on the left of the => just groups constraints
14:10:08 <kosmikus2> it does not mean "tuple" there
14:10:11 <tuomov> I don't know any lisp.
14:10:33 <shapr> Naughty_Minnow: do you have any ideas on how to start this?
14:10:49 <bourbaki> kosmikus2: ah!! so i could do something like (preq1, preq2, ..., preqn) => blubb ?
14:10:55 <kosmikus2> bourbaki: yes
14:11:06 <bourbaki> kosmikus2: ah !!! thanks 
14:11:17 <pesco> tuomov: Have a look at it some time, it's a wonderous example of powerful complexity all layered on top of the next simple layer, down to cons cells.
14:11:32 <bourbaki> cool :)
14:12:07 <tuomov> I can't stand the parentheses :)
14:12:25 <pesco> tuomov: Hah. They disappear.
14:12:40 <pesco> LISP code is read by indentation.
14:12:40 <bourbaki> tuomov: if you cant stand them they are too strong ;)
14:13:43 <shapr> Naughty_Minnow: still there?
14:15:46 <pesco> tuomov: I have a question about ion3, btw. Is there a way to run a program so that it's "main window" will appear in the frame I gave the command from?
14:15:51 <Naughty_MinnowDC> got DC
14:15:56 <shapr> what's DC?
14:16:01 <Naughty_MinnowDC> disconnected
14:16:09 <Naughty_MinnowDC> d/c rather
14:16:13 <shapr> ah, ok
14:16:59 <shapr> Naughty_MinnowDC: so, do you have any ideas how to approach this problem?
14:17:05 <Naughty_MinnowDC> i was thinking i could check in the second bag for a tuple that is equivalent to the head of the first bag
14:17:33 <shapr> you'd have to have a function that can compare bag 'types'
14:18:39 <Naughty_MinnowDC> do you mean type as in String Float Int etc
14:18:59 <shapr> nah, I mean you need to compare elephant or cheese.
14:19:00 <Naughty_MinnowDC> or "alpha" 5.6 4 etc
14:19:05 <Naughty_MinnowDC> ah
14:19:12 <drlion> tuomov: this is how Lisp code looks on my screen: http://wigwam.deepwood.net/~drlion/parens.png :-)
14:19:42 <pesco> Heh. That's pretty.
14:20:06 <drlion> why thank you :-)
14:20:23 <pesco> drlion: Did you make that color theme yourself? I might be interested in a copy.
14:20:24 <shapr> drlion: have you tried the Misty-Day color theme?
14:20:25 <Naughty_MinnowDC> i could compare the first element in each bag to see if their type was equal
14:20:29 * shapr grins innocently
14:20:41 <shapr> Naughty_MinnowDC: cool, you'll need that function. It's an easy first step.
14:20:42 <drlion> pesco: more or less: http://www.deepwood.net/software/zenburn/
14:20:47 <Naughty_MinnowDC> ok one sec
14:21:24 <drlion> shapr: hmm, no, I don't think I have.  I haven't tried that many though
14:21:31 <pesco> drlion: Thanks!
14:21:33 <drlion> shapr: is it that weird green-on-pink one?
14:21:37 <Lemmih> Hey Boegel
14:21:38 <Boegel> hello everyone :)
14:22:11 <drlion> pesco: you're welcome. :-)  Let me know how it works for you
14:22:25 <pesco> drlion: Yes.
14:22:33 <shapr> drlion: WEIRD? it's not WEIRD!
14:22:44 <drlion> hahaha
14:23:01 <drlion> I'm sorry, I didn't mean weird...  I just meant... different, I guess :-)
14:23:55 <shapr> drlion: heck I think it's flat out useful - http://www.scannedinavian.org/~shae/secret-joy.png
14:24:02 <Naughty_MinnowDC> shapr: thanks for helping so far, i have this      bagHeadCheck :: Eq a => Bag a->Bag a -> Bool
14:24:02 <Naughty_MinnowDC> 	bagHeadCheck [] [] = False --arbitrarily
14:24:02 <Naughty_MinnowDC> 	bagHeadCheck (h1:t1) (h2:t2) = fst h1 == fst h2
14:24:06 <drlion> pesco: do you use Emacs from CVS?
14:24:29 <pesco> drlion: No, do I need that? (*fear*)
14:24:44 <shapr> Naughty_MinnowDC: you probably want to make that more generic, so that it only takes two bags as its arguments.
14:24:53 <drlion> pesco: no, but if you do, you'll want a more recent version of zenburn.el to cover all the new things
14:25:15 <pesco> drlion: Ah ok. I use emacs mostly at work.
14:25:32 <shapr> nobody likes my color-theme... always screaming about acid burning their eyes and shit like that.
14:25:36 <Naughty_MinnowDC> shapr: sorry i don't understand what you mean
14:25:49 <drlion> shapr: oh my god, you made it even *more* disgu--- I mean.. different?
14:25:55 <shapr> :-P
14:25:57 * shapr laughs
14:26:15 <shapr> Naughty_MinnowDC: that function requires two lists as input, it'll be easier to use if it only requires two bags
14:26:24 <Naughty_MinnowDC> ah
14:27:06 <bourbaki> whats the name of power in haskell?
14:27:14 * shapr can barely wait for the color-theme package for hemacs
14:27:15 <bourbaki> the power fn that is
14:27:16 <shapr> HEMACS! YAY!
14:27:34 <shapr> bourbaki: well, I has the real power of the three combinators.
14:27:45 <shapr> ya know, S K I
14:27:49 <drlion> what is the power function?
14:27:57 <bourbaki> x^y
14:28:09 <Naughty_MinnowDC> shapr: i have this, bagHeadCheck :: Eq a => Bag a->Bag a -> Bool
14:28:09 <Naughty_MinnowDC> 	bagHeadCheck bag1 bag2 = fst head bag1 == fst head bag2
14:28:11 <pesco> Oh, I think it's called (^). :)
14:28:20 <bourbaki> ... heh ok
14:28:22 <Naughty_MinnowDC> but that generates an error
14:28:43 <shapr> Naughty_MinnowDC: do you see the error?
14:28:51 <Naughty_MinnowDC> no...
14:29:01 <shapr> ok, what does fst do?
14:29:30 <Naughty_MinnowDC> returns the first element of a tuple. is it because it may not be expecting a list of tuples?
14:29:33 <drlion> fst (a,b) = a?
14:30:28 <shapr> Naughty_MinnowDC: if you want a function that just checks two bags for equal 'type' of contents, you're effectively check the fst of two different tuples for equality, right?
14:30:43 <Naughty_MinnowDC> yes
14:30:51 <shapr> ok, what does head do?
14:31:02 <Naughty_MinnowDC> returns the first element of a list
14:31:13 <Naughty_MinnowDC> in this case a tuple
14:31:15 <Oejet> tromp: Implementet your great line testing idea. Now Olinka II is evily good (relatively, i know). :-)
14:31:21 <shapr> Naughty_MinnowDC: a tuple is not a list
14:31:28 <Naughty_MinnowDC> ..?
14:31:35 <shapr> for example try "head (1,2)" in hugs
14:31:41 <shapr> what happens?
14:31:54 <Naughty_MinnowDC> the tuple is not a list
14:31:59 <Naughty_MinnowDC> so it doesnt work
14:32:01 <shapr> correct
14:32:04 <Naughty_MinnowDC> but
14:32:12 <shapr> so we want a function that just checks two tuples for type equality
14:32:50 <Naughty_MinnowDC> yes. in my saying fst head bag1, does this not mean "the first element of the tuple, which is the head of the bag"?
14:32:52 <drlion> shapr: oh, haha, sorry, I thought you forgot what fst did :-)
14:33:05 <shapr> drlion: no, I do know what fst does :-)
14:33:40 <shapr> Naughty_MinnowDC: right, good point... terminology error on my part
14:33:49 <Naughty_MinnowDC> no probs
14:34:06 <Naughty_MinnowDC> why does hugs not like it when i say that then?
14:34:16 <Naughty_MinnowDC> bagHeadCheck bag1 bag2 = fst head bag1 == fst head bag2
14:34:25 <shapr> ok, how could you check two different tuples to see if they have the same content type?
14:34:43 <Naughty_MinnowDC> fst tuple1 == fst tuple2
14:35:16 * shapr tries to remember where he was going with this...
14:35:16 <Boegel> Naughty_MinnowDC: try bagHeudCheck bag1 bag2 = (fst head bag1) == (fst head bag2)
14:35:34 <Igloo> fst head bag2 == (fst head) bag2
14:36:02 <Naughty_MinnowDC> boegel: same error
14:36:10 <shapr> Naughty_MinnowDC: I see two possible approaches here, either you can add together items of a common type in the bag, until there are no duplicates
14:36:16 <bourbaki> oh man this conversion things again :( how do i convert a Float to an Integral ?
14:37:10 <shapr> Naughty_MinnowDC: or you can pick the top item from one bag, and loop over the other bag until you've checked for all the matching types
14:37:12 <Naughty_MinnowDC> bourbaki: ceiling, floor or round
14:37:20 <Naughty_MinnowDC> shapr: ok
14:37:25 <shapr> I think the first approach is easier, but that's just my opinion.
14:37:35 <Naughty_MinnowDC> i was envisioning the latter haha
14:37:44 <shapr> you could try both :-)
14:37:48 <shapr> extra points from the prof?
14:38:01 <Naughty_MinnowDC> hehehe
14:38:08 <Naughty_MinnowDC> i wish
14:38:15 <bourbaki> Naughty_MinnowDC: filterfn :: Float -> Float; filterfn x = (2.71^x + 2.71^x) / (2.71^x - 2.71^x)
14:38:42 <shapr> @type (^)
14:38:44 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
14:38:50 <shapr> @type (**)
14:38:52 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
14:39:05 <Naughty_MinnowDC> wow what a nice bot friend
14:39:11 <shapr> yes, lambdabot is friendly.
14:39:14 <Naughty_MinnowDC> :)
14:39:17 <shapr> he can also find functions for you by name.
14:39:21 <shapr> @index foldr
14:39:21 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
14:39:25 <Naughty_MinnowDC> wow!
14:39:59 <bourbaki> ? so how to i do something like e^x ?
14:40:06 <shapr> bourbaki: e**x ?
14:40:20 <bourbaki> oh man sry i should go to bed soon :( thanks
14:40:32 <Igloo> exp x   if you mean e
14:40:58 <Naughty_MinnowDC> shapr: the problem i saw with taking the first tuple in bag1 and finding the corresponding tuple in bag2 was that there may be elements unique to bag2
14:41:02 <bourbaki> aha :)
14:41:19 <Naughty_MinnowDC> hmm
14:41:29 <Naughty_MinnowDC> this is going to require some thought
14:41:32 <shapr> Naughty_MinnowDC: yes, you'll need to deal with that
14:41:36 <Naughty_MinnowDC> but later!
14:41:54 <shapr> that's why I think the first solution is easier.
14:41:57 <Naughty_MinnowDC> ok
14:42:18 <Naughty_MinnowDC> so why does my practice function, bagHeadCheck not compile?
14:42:26 <Naughty_MinnowDC> i fail to see the error
14:42:38 <shapr> I think because, the terminology error on my part confused you
14:42:48 <shapr> you had it right the first time
14:42:58 <shapr> but I was talking about the elements inside the bag, and calling them bags :-(
14:42:58 <tromp> nice, oejet
14:43:15 <Naughty_MinnowDC> ahhhhhh
14:44:14 <Naughty_MinnowDC> but out of curiosity and wanting to understand this, what was my typing error?
14:44:32 <Naughty_MinnowDC> bagHeadCheck :: Eq a => Bag a->Bag a -> Bool
14:44:32 <Naughty_MinnowDC> 	bagHeadCheck [] [] = False --arbitrarily
14:44:32 <Naughty_MinnowDC> 	bagHeadCheck bag1 bag2 = fst head bag1 == fst head bag2
14:44:57 <Naughty_MinnowDC> where a bag is defined as:
14:45:05 <Naughty_MinnowDC> type Bag a = [(a,Int)]
14:45:07 <Igloo> Because  fst head bag2 == (fst head) bag2
14:45:08 <shapr> Naughty_MinnowDC: you need parentheses
14:45:35 <Naughty_MinnowDC> oh ok i will try (fst head) bag2
14:45:55 <shapr> you need the parentheses the other way around
14:46:04 <Naughty_MinnowDC> fst (head bag2) ???
14:46:10 <shapr> function application is right associative
14:46:17 <Naughty_MinnowDC> yeah i thought so
14:46:23 <Naughty_MinnowDC> fst of head of bag2
14:46:27 <shapr> right!
14:46:45 <Igloo> No, function application is left associative
14:46:59 <shapr> oh
14:47:02 <shapr> whoops :-)
14:47:47 <Naughty_MinnowDC> left, right, whatever :P, but fst (head bag1) == fst (head bag2) is working excellently
14:47:58 <Oejet> tromp: See http://eigil.dyndns.dk/Spildommer/spil.html, red is the old test mask system and blue is the new.
14:48:05 <Naughty_MinnowDC> kinda makes sense.........
14:48:39 <Naughty_MinnowDC> ok, so i can check for equality in the heads of 2 bags
14:49:22 <Naughty_MinnowDC> bagHeadCheck [("alpha",2)] [("alpha",3)]    returns True
14:49:53 <tromp> red move in col 7 was losing
14:50:24 <shapr> Naughty_Minnow: can you check for equality in the first two items of one bag?
14:50:37 <tromp> but only if blue responded in col 6 :)
14:51:04 * Naughty_Minnow attempts this next task
14:51:15 <Oejet> tromp: I know, it's not evil enough, I have profiled it and see clearly where the problem is:
14:51:28 <bourbaki> nighto
14:52:02 * shapr fights with FM
14:53:48 <shapr> hum, Functional Morphology doesn't seem to take a-dots in either iso-8859-1 or utf-8, what other encodings can I try?
14:54:19 <Oejet> COST CENTRE                    MODULE               %time %alloc
14:54:19 <Oejet> count4                         Main                  47.5   42.4
14:54:19 <Oejet> explode                        Main                  35.4   49.1
14:54:27 <tromp> if you download Fhourstones, you can find a connect-4 solver in there
14:54:44 <Naughty_Minnow> how do you say "or"?
14:54:55 <tromp> a < 2 || a > 5
14:54:56 <shapr> @type or
14:54:58 <lambdabot> or :: [Bool] -> Bool
14:55:03 <Naughty_Minnow> cheers
14:55:10 <shapr> @type (||)
14:55:11 <lambdabot> (||) :: Bool -> Bool -> Bool
14:55:32 <Igloo> What's a-dots?
14:55:47 <Oejet> tromp: count4 bb = length $ filter (/=0) $ concat $ map explode [vert4 bb, hori4 bb, diul4 bb, diur4 bb]
14:55:56 <Igloo> If it's not in unicode it's unlikely to be anywhere vaguely standard
14:56:21 <shapr> just &auml;
14:56:21 <Igloo> What's Functional Morphology for that matter?
14:56:26 <shapr> http://www.cs.chalmers.se/~markus/FM/
14:56:36 <Igloo> That's in unicode
14:56:44 <shapr> more language stuff in Haskell
14:57:10 <Naughty_Minnow> shapr: i tried this but not only is it wrong it also "feels" very wrong o_0      bagHeadCheck bag1 bag2 = fst (head bag1) == fst (head bag2) || fst (bag2!!2)
14:57:46 <Igloo> U+00E4 LATIN SMALL LETTER A WITH DIAERESIS: Ã¤
14:57:56 <Igloo> UTF-8: 0xC3 0xA4
14:58:10 <shapr> Naughty_Minnow: take only a single bag as input, and check the first two items for equal content type?
14:58:24 <shapr> Igloo: this must be user error...
14:58:46 <shapr> or maybe it has something to do with my use of a 0-day warez version of FM
15:01:20 <tromp> why wld u want to count them, oejet?
15:02:14 <Naughty_Minnow> shapr: bagDupeCheck :: Eq a => Bag a -> Bool
15:02:14 <Naughty_Minnow> 	bagDupeCheck [] = False
15:02:14 <Naughty_Minnow> 	bagDupeCheck (b:bs) = fst b == fst (head bs)
15:02:21 <Naughty_Minnow> this works!
15:02:35 <shapr> Naughty_Minnow: cool!
15:02:37 <Oejet> tromp: Ah, I'm using the count in my static :: Game -> Int evaluation function.
15:02:39 <Naughty_Minnow> hahaha
15:03:26 <shapr> Naughty_Minnow: you could also use the (x:y:zs) trick there, then you could reuse your bagTypeEq function
15:03:51 <Boegel> I'm out, going to sleep
15:03:53 <Boegel> bye everyone
15:03:57 <shapr> g'night Boegel 
15:04:23 <Naughty_Minnow> shapr: but what if the bag only contained 2 tuples, would x:y:zs fail? in my code i posted that does work, it fails when the bag contains just one tuple..
15:04:27 <Naughty_Minnow> bye Boegel
15:04:35 <shapr> Naughty_Minnow: excellent point :-)
15:04:41 <dons> moin!
15:04:46 <tromp> how do i start a private chat?
15:04:48 <shapr> g'day dons!
15:04:52 <shapr> tromp: use /query name
15:04:59 <shapr> or just /msg name for a single message
15:05:03 <tromp> thx
15:05:06 <Boegel> tromp: or click on the name in the list you see in your client
15:05:38 <Boegel> gone now ;)
15:05:40 <shapr> Naughty_Minnow: have you reached pattern matching in your class?
15:05:48 * dons gets back to hacking hemacs
15:05:49 <Naughty_Minnow> never heard of it...
15:06:02 <stepcut> dons: can you hack any faster?
15:06:10 <shapr> the (x:xs) is one instance of pattern matching
15:06:27 <shapr> you can also check for specific values with pattern matching
15:06:36 <shapr> for example, with (x:[])
15:07:14 <shapr> Naughty_Minnow: when you see what looks like a function written multiple times, one for the empty list maybe, that's also pattern matching
15:07:23 <Naughty_Minnow> ok...
15:07:33 <shapr> Naughty_Minnow: I have to ask, who's your teacher? do they not teach this? or do you sleep in class? ;-)
15:07:42 <Naughty_Minnow> haha
15:07:54 <kristnjov> pattern matching rocks
15:08:04 <dons> stepcut: :p
15:08:06 <Naughty_Minnow> i've never heard him speak of pattern matching
15:08:39 <kristnjov> pattern matching is what makes life worth living
15:08:49 <Naughty_Minnow> this is our first assignment, quite complex for a first attempt is the general opinion of the student body
15:08:55 <kristnjov> that and of course higher order functions :)
15:08:55 <Naughty_Minnow> i think
15:08:57 <dons> btw, new buffer is fast and working nicely. should be ready soon
15:09:04 <shapr> dons: yay!
15:10:00 <dons> we really need to work out a UI class. I'm thinking drawAll, drawBuffer, drawLine, drawChar
15:10:01 <shapr> Naughty_Minnow: you could add a new line to your bagDupeCheck between the first and second
15:10:15 <dons> drawPoint etc
15:10:31 <dons> the ui programming is too ad hoc atm
15:10:35 <shapr> dons: I very much wish we could get together in person and have a sprint :-)
15:10:53 * shapr decides to visit tuomov  ;-)
15:11:02 <dons> well -- if hemacs/yi gets big enough -- we can have conferences!
15:11:06 <shapr> yes!
15:11:12 <shapr> btw, I really like the name yi
15:11:27 <shapr> very functional :-)
15:11:29 <shapr> easy to type
15:11:38 <dons> yep. i'm starting to slip it into the source
15:11:50 <shapr> Naughty_Minnow: try adding a case for bagDupeCheck (x:[]) = ...
15:11:52 * kosmikus2 like yi, too
15:11:52 <dons> new unnamed files are tmp.abcdefg
15:11:56 <dons> sorry, yi.abcdefg
15:12:01 * Igloo wonders how to handle "Does this look like it should be syntax-highlighted as TeX" for .lhs files. I guess it wants to be special functionality of the lhs syntax-highlighting module
15:12:09 <dons> s/abcdefg/randomness/
15:12:34 * Naughty_Minnow wonders "yi" pronounced yee or why-aye, as in geordie-speak?
15:13:13 <shapr> I'd probably say yiiii
15:13:35 <dons> or 'ee' even
15:13:38 <Igloo> I'd rhyme it with "why"
15:13:41 <Cale> yi.org is already taken
15:13:42 <dons> ee for editor
15:14:23 <dons> funyi.org
15:14:33 <shapr> funeee?
15:14:36 <dons> :)
15:14:37 <kolmodin> :)
15:15:42 <shapr> Naughty_Minnow: once you have a separate case that checks for (x:[]), you can write a function that just adds the top two items in a bag.
15:16:11 <Naughty_Minnow> i have a trivial 	bagDupeCheck (x:[]) = False
15:16:48 <shapr> Naughty_Minnow: ok once you have a function that can add the top two items in a bag... can you guess the next step?
15:16:49 <pesco> I'm off to bed.
15:16:54 <shapr> g'night pesco 
15:16:58 <pesco> Good night.
15:17:02 <Naughty_Minnow> bye
15:17:09 <Naughty_Minnow> hmm
15:17:16 <pesco> shapr: I just read in your blog, I need enough sleep. I think you're right. :-)
15:17:24 <shapr> yes it's true :-)
15:17:28 <shapr> I need to update my blog too
15:17:28 <dons> sleep, bah!
15:17:36 <shapr> sleep makes for good code
15:17:47 * dons decides he needs more sleep too
15:17:49 <pesco> True. So there.
15:18:14 <dons> i have been dreaming about yi/hemacs. scary
15:18:16 <shapr> dons: hey, you wouldn't happen to have any 0-day PLog warez would you?
15:18:20 <shapr> dons: me too =)
15:18:21 <dons> new buffer models etc
15:18:28 <shapr> yes, same here
15:18:41 <Naughty_Minnow> shapr: the next step could be adding together two tuples in a bag only if they have the same fst value
15:18:44 <shapr> I think that shows how much I want out of emacs.
15:18:45 <dons> no plog warez
15:18:54 <shapr> ok, I'll email pete
15:19:43 <shapr> Naughty_Minnow: first question, how do you get all the items of the same type 'next to' each other in a list?
15:19:54 <shapr> greetings hydden 
15:20:05 <hydden> =)
15:20:06 <Naughty_Minnow> sorting? i don't know
15:20:14 <shapr> Naughty_Minnow: good answer, that's what I would do.
15:20:30 <Naughty_Minnow> =D
15:20:41 <Naughty_Minnow> how does one sort a list, pray tell?
15:20:42 <shapr> hydden: looking for haskell knowledge?
15:20:50 <shapr> I tend to use the 'sort' function.
15:20:53 <Naughty_Minnow> hahahahahaha
15:21:02 * Naughty_Minnow slaps himself
15:21:07 * shapr grins
15:21:37 <hydden> shapr no
15:21:41 <dons> giving buffers a Unique to carry around makes things easier (should have thought of that before)
15:21:54 <shapr> Naughty_Minnow: ok, you have all the basic pieces, now there's only the central structure function to go...
15:22:02 <hydden> shapr i dont know what is this...its my first time hier
15:22:03 <shapr> hydden: oh, you already know Haskell?
15:22:16 <hydden>  im brasilian
15:22:21 <shapr> hydden: welcome to #haskell! Haskell is a purely functional programming language.
15:22:32 <shapr> Do you know how to program?
15:22:40 <shapr> Would you like to learn Haskell?
15:22:51 <hydden> maybe
15:22:58 <shapr> For only five small payments of hanging around #haskell and chatting, you too can learn Haskell!
15:23:06 <Naughty_Minnow> =D
15:23:08 <monochrom> "The best way to write an imperative program is by functional programming." - me
15:23:18 <hydden> haha
15:23:21 <hydden> thks
15:23:37 <rhw> This book is killing me. It takes too long until they explain tuples and lists properly.
15:23:37 <rhw> =)
15:23:58 <rhw> But overall, I like it so far.
15:24:03 <shapr> hydden: if you'd like to see a small taste-test of Haskell, try http://www.haskell.org/hawiki/HaskellDemo
15:24:20 <shapr> rhw: which book?
15:24:21 <kosmikus2> rhw: which book?
15:24:25 <Naughty_Minnow> haha
15:24:28 <rhw> shapr, craft 2e
15:24:38 <shapr> nice book
15:24:43 <hydden> shapr thks bro
15:25:00 <shapr> Naughty_Minnow: ok, now comes the exciting part... how to stick this all together so it works on the whole bag?
15:25:09 <rhw> Can't wait to finish it so I can start following what people here talk :p
15:25:22 <shapr> hydden: good places to start learning are http://www.haskell.org/learning.html
15:25:22 <kolmodin> 00:29 < dons> giving buffers a Unique to carry around makes things easier (should have thought of that before)
15:25:33 <kolmodin> what gets easier?
15:25:54 <dons> for example, working out which buffer has focus.
15:26:10 <Naughty_Minnow> shapr: it sounds exciting but daunting. and how do i get sort to work? i tried it but Hugs said undefined variable "sort"
15:26:28 <shapr> @index sort
15:26:29 <lambdabot> Data.List,List
15:26:38 <shapr> Naughty_Minnow: I think you need to import Data.List
15:26:38 <kolmodin> aha.. so you just keep the Unique of the active buffer, whichever it might be
15:26:44 <dons> yep
15:27:11 <shapr> if you want to use sort interactively in Hugs, try ":m + Data.List" at the prompt
15:27:19 <dons> the UI has to draw it slightly differently: it gets a cursor, and a fancy modeline
15:28:22 <Naughty_Minnow> to import Data.List, is that in Hugs or in the module?
15:28:40 <shapr> in the module, put "import Data.List"
15:28:51 * Naughty_Minnow slaps myself again
15:28:51 <shapr> in hugs you can use the functions from Data.List with ":m + Data.List"
15:29:02 <kolmodin> it has to draw the active buffer differently? for splitscreening? otherwise there will be only one active buffer... ah...
15:29:41 <dons> yep. multiple buffers might be on the screen. anyway -- it is good to know which buffer is active :)
15:30:13 <kolmodin> haha, yeah, that might be useful to know
15:31:24 <Naughty_Minnow> shapr: where do i import the Data.List in the module? if i put it above the module title line hugs says unexpected keyword "module"
15:31:47 <shapr> Naughty_Minnow: after the module line
15:31:51 <shapr> module Fooo
15:31:51 <shapr> where
15:31:55 <shapr> import Data.List
15:32:03 <JerubBaal> shapr: its unfortunate.
15:32:13 <Naughty_Minnow> ok cheers
15:33:29 <shapr> in my opinion, the easy way to make the whole thing go is to write a recursive function that does one of two things, depending on whether the two items are of the same type. 1) they're the same type, add them together, and call yourself with the result of the add, stuck on the front of rest of the list
15:33:48 <shapr>  or 2) they're not the same type send the top item out as a result, and call yourself with the rest of the list
15:34:15 <shapr> Naughty_Minnow: makes sense?
15:34:22 <Naughty_Minnow> yes..
15:34:33 <Oejet> Good night, everybody.
15:34:39 <shapr> g'night Oejet 
15:34:41 <Naughty_Minnow> but this will have to run for each element in the first bag, and the second bag
15:34:46 <Naughty_Minnow> cya
15:35:06 <shapr> Naughty_Minnow: what if you just put the two bags together?
15:35:29 <kolmodin> shapr: gonatt
15:35:36 <kolmodin> :)
15:35:36 <Naughty_Minnow> ahh
15:35:37 <shapr> natti :-)
15:35:52 <Naughty_Minnow> that makes an alarming amount of sense shapr
15:35:59 <shapr> shocking, isn't it?
15:36:12 <shapr> sort (bag1 ++ bag2)
15:36:30 <Naughty_Minnow> thats so simple
15:36:35 <Naughty_Minnow> i can't believe it
15:36:46 <shapr> functional programming is like that....
15:36:50 <Naughty_Minnow> i've all this time been worrying about checking each element in each bag
15:37:06 <Naughty_Minnow> haha i've noticed that about functional, if it looks easy it probably is
15:37:12 <shapr> heh, yes
15:37:22 <shapr> you just have to think about it the right way.
15:37:27 <Naughty_Minnow> yeah!
15:37:56 <shapr> and usually, the right way is to find just two steps, how to stop when you've reached the end, and how to get one step closer to the end.
15:38:28 <JerubBaal> shapr: you left #erlang
15:38:33 <JerubBaal> shapr: and I just talked to you.
15:38:38 <shapr> whoops
15:38:56 <JerubBaal> shapr: pretend I just said "shapr: have you written much in erlang?"
15:38:57 <kosmikus2> bye
15:39:03 <shapr> heh
15:39:56 <Naughty_Minnow> shapr: i'm going to attempt this now, i see the light...
15:40:02 <shapr> yay!
15:45:23 <dons> I wish you could put in instance-local type sigs, just as documentation
15:45:33 <dons> oh well, have to just put them as comments
15:45:43 <shapr> can't you do that with 6.3?
15:45:55 <shapr> class-local stuff as per chak+simon?
15:45:56 <dons> "Misplaced type signature: newBuffer :: FilePath -> IO FBuffer
15:46:07 <dons> maybe there is some trick
15:47:10 <Naughty_Minnow> shapr! bagSum bag1 bag2 = bagDupeCheck (sort bag1++bag2)      is giving me problems
15:47:27 <shapr> Naughty_Minnow: you need to do more than that...
15:47:32 <Naughty_Minnow> oh i know...
15:47:37 <Naughty_Minnow> but this is the first step
15:47:43 <Naughty_Minnow> and it doesnt compile yet
15:47:54 <shapr> first add parens
15:48:15 <shapr> otherwise only the first bag is sorted
15:48:25 <Naughty_Minnow> oh balls
15:49:15 <Naughty_Minnow> ok thats out of the way but it still says "cannot justify constraints in explicitly typed binding"
15:51:19 <shapr> try commenting out the type sig for right now
15:52:29 <Naughty_Minnow> ??
15:52:45 <shapr> or, you can try it interactively in Hugs
15:52:56 <shapr> comment out your definition of bagDupeCheck
15:53:02 <shapr> er sorry
15:53:05 <shapr> comment out bagSum
15:53:08 <shapr> not bagDupeCheck
15:53:25 <Naughty_Minnow> ok...
15:53:26 <shapr> then load the file in hugs and try bagDupeCheck (...
15:53:42 <Naughty_Minnow> oh bagDupeCheck is fine
15:53:54 <shapr> if you've also defined some test bags in the file
15:53:57 <Naughty_Minnow> i can remove it for the purposes of fixing this typing error
15:54:01 <shapr> then you can try lots of stuff interactively
15:55:39 <shapr> g'day Pseudonym
15:56:30 <Pseudonym> G'day.
15:58:34 <rhw> Yay. The tuples and lists chapter.
16:00:00 <shapr> rhw: yay!
16:00:45 <shapr> Naughty_Minnow: from here, I think you can do it yourself :-)
16:06:47 <Naughty_Minnow> yeah i think so
16:06:54 <Naughty_Minnow> thanks very much!
16:07:45 <Naughty_Minnow> it's much better to explain things step by step than say "here's the code, goodbye", now I'm getting my head into a functional programming mode
16:08:06 <Igloo> Aargh! How dare nhc98 not have Text.Regex?
16:09:07 <Igloo> Even hugs has it! *sigh*
16:13:44 <np_hard> one of the pitfalls of not being a single-implementation language
16:14:19 <Igloo> The real problem is that nhc98 isn't supported as well as we'd like
16:14:52 <dons> hehe. you can't load plugins compiled with a different version of ghc to the one hemacs was compiled with :}
16:15:39 <dons> Igloo: yes. nothing much we can do except send patches when we can, I guess
16:15:45 <Pseudonym> Part of the problem is that Haskell is a relatively new language, but the standard is 6 years old.
16:16:02 <Pseudonym> There's a lot of active research, but the standard hasn't caught up with any of it.
16:16:09 <Igloo> Pseudonym: I don't think a newer standard would make a significant difference to nhc98
16:16:21 <np_hard> hemacs?
16:16:23 <Pseudonym> No, but it might to nhc05.
16:16:26 <np_hard> is that what it sounds like?
16:16:30 <Igloo> No, I don't think it would
16:16:37 <Pseudonym> True, probably not.
16:16:41 <Igloo> I think it was even Malcolm Wallace who said that the HLs are virtually a standard
16:18:27 <dons> np_hard: yep. though it's called 'yi' now. I keep forgetting
16:18:40 <Igloo> Now, do I drop nhc support so it falls back to hugs, try to hack it into nhc or just copy the regex files to the package?
16:18:47 * Igloo decides on the last one for now
16:20:39 <np_hard> emacs with haskell as an extension language
16:20:43 <np_hard> now I've seen everything
16:21:12 * dons really wants people to stop being surprised by haskell as an extension language
16:21:42 <np_hard> or is it hebrew emacs?
16:21:53 <dons> nope :)
16:22:02 <dons> that's why we call it 'yi'
16:22:02 <Pseudonym> Most languages develop an implicit theory about what it's "for".
16:22:14 <dons> looks like
16:22:17 * Igloo thinks hemacs is a particularly bad thing to call it, as if it was just emacs rewritten in Haskell I wouldn't be interested
16:22:29 * Pseudonym likes 'yi'
16:22:34 <np_hard> what is yi's relationship to emacs?
16:22:39 <dons> no relationship
16:22:41 <Pseudonym> Since it's bottom in combinatorial logic.
16:22:42 <np_hard> ok
16:22:57 <dons> or maybe "trying to kill it with arrows"
16:22:59 <dons> hehe
16:23:01 <np_hard> i dunno
16:23:19 <np_hard> the killer feature for any new programmer's editor would be backwards compatibility with elisp
16:23:22 <np_hard> for me anyway :)
16:23:25 <dons> bah!
16:23:42 <Pseudonym> Haskell, being non-dynamic (i.e. not having "eval") would appear to be less suited for scripting applications than others.
16:23:49 <dons> how about -- forwards compatibility with Haskell!
16:23:58 <Pseudonym> On first impressions, anyway.
16:23:59 <np_hard> nope nope
16:24:11 <dons> (but we do have eval -- that's how ghci works, and Plugins.Eval.eval)
16:24:14 <Pseudonym> I think that's why people are surprised by it as an extension language.
16:24:20 <Pseudonym> We have eval in GHC.
16:24:25 <Pseudonym> No other implementation.
16:24:33 <dons> true, true.
16:25:09 <np_hard> the dissociation from emacs helps me
16:25:24 <np_hard> the "hemacs" name implies something like emacs
16:25:27 <dons> ok. that is useful to know. I will definitely move over to calling it "yi"
16:25:37 <dons> just work out how to pronounce it now
16:25:37 <np_hard> which an editor with haskell as an extension language would not be
16:26:30 <dons> hmm.. I only get the correct behaviour with -O. not good :(
16:26:41 * dons goes snooping
16:27:17 <dons> np_hard: darcs get http://www.cse.unsw.edu.au/~dons/yi
16:27:23 <dons> ;)
16:36:32 <Igloo> darcs failed:  Failed to download URL http://www.cse.unsw.edu.au/~dons/yi/_darcs/inventorylibcurl: HTTP error (404?)
16:37:27 <dons> oops
16:37:29 <dons> fixed
16:37:35 <dons> (wrong path)
16:38:17 <dons> it's still just hemacs, but with a different repo name :)
16:45:03 * Igloo ponders the merits of a Haskell Text.Regex
16:45:43 <Igloo> Anyone happen to have a good reference to a decent, simple algorithm?
16:45:57 <JerubBaal> what? fib ?
16:46:25 <Igloo> For converting regexps to FA
16:46:37 * Igloo can't even remember if DFAs or NFAs work out better in practice
16:48:13 <arauko> Anyone knows what means the name #-2 in the USER field of the command ps aux?
16:48:44 <Igloo> It probably means user 65534 which hasn't got a name in /etc/passwd
16:53:58 <Igloo> Urgle - it seems POSIX Basic Regular Expressions have backreferences but Extended Regular Expressions don't
16:54:42 <Pseudonym> DFAs are good.
16:54:52 <Pseudonym> Backreferences don't work with DFAs, though.
16:55:01 <Pseudonym> Do you need backreferences, substitution etc?
16:55:10 <Pseudonym> Or do you just want to recognise things?
16:56:08 <Igloo> I only want EREs for now, which is good because they seem to be easier than BREs  :-)
16:56:08 <JerubBaal> DFAs are the easiest to implement.
16:56:21 <Igloo> So no backreferences, and matching only
16:56:35 <JerubBaal> http://thorne.id.au/users/stephen/dfa.png (I was explaining a dfa a while back)
16:56:36 <Igloo> But I'd like to be able to say what things parens matched
16:57:19 <Igloo> That URL most helpfully says "No."
16:58:18 <Igloo> Why are DFAs easiest? Don't you make an NFA first and then transform that to a DFA?
16:58:20 <Pseudonym> http://cvs.sf.net/viewcvs.py/haskell-libs/libs/text/
16:58:37 <Pseudonym> No, my version (there) converts from regexes directly to DFAs.
16:58:44 <Pseudonym> And it's easier (IMO) than going via NFAs.
16:58:51 <Igloo> Ah, OK
16:58:52 <Pseudonym> Want a precis of how it works?
16:58:57 <Pseudonym> It's pretty simple.
16:59:07 <Igloo> What does LGPL mean when you have cross-module inlining?
16:59:26 <Pseudonym> No idea.  Would you like it licensed under another licence?
16:59:42 <Igloo> This is GPLed anyway so it doesn't matter. Just curious
16:59:49 <JerubBaal> Igloo: DFAs are really simple to transform into a state machine.
17:00:01 <JerubBaal> Igloo: I think there are some complications with NFAs.
17:00:07 <JerubBaal> don't remember exactly.
17:00:23 <Pseudonym> With NFAs you either need backtracking or multiple states.
17:00:32 <Pseudonym> OTOH, NFAs can be much smaller.
17:01:03 * Igloo will read through the code quickly and then ask you questions if I'm confused. Thanks
17:01:10 <Pseudonym> OK.
17:01:38 <Pseudonym> The theory behind it is kinda neat.
17:02:22 <Pseudonym> My interpretation of the LGPL and cross-module inlining is that you're fine.
17:02:35 <Pseudonym> If the library is unmodified, anyway.
17:03:30 <Igloo> Is parseDfaFromString doing to give me a parse tree or a FA?
17:04:00 <Pseudonym> It gives you a parse tree which you can feed to Dfa.lhs.
17:04:54 <Igloo> Err, should I be looking at matchRe or matchRe2?  :-)
17:04:59 <Pseudonym> Probably matchRe.
17:05:13 <Pseudonym> matchRe is going to be a bit faster, but matchRe2 will be more compact.
17:05:15 <Pseudonym> More or less.
17:05:23 <Pseudonym> Maybe not, actually,
17:05:27 <Pseudonym> Who knows. :-)
17:05:48 <JerubBaal> I had to write a regexp engine using prolog in an exam.
17:05:56 <JerubBaal> I had nearly blocked that out. :p
17:06:05 <Pseudonym> Eek.
17:06:21 <Pseudonym> Did it infinitely loop if you tried to parse a**?
17:07:47 <Igloo> Hmm, I'm starting to think this is more clever than it simple
17:08:40 <JerubBaal> Pseudonym: hmm
17:08:47 <JerubBaal> Pseudonym: I'm not sure. I don't think so.
17:09:15 * Igloo thinks for a minute and remembers how NFA construction works
17:09:26 <JerubBaal> parsing a** is simple.. matching it might have loops
17:09:30 <JerubBaal> star(star(a))
17:09:30 <Pseudonym> Right.
17:09:59 <Pseudonym> Igloo: Actually, it's pretty simple at heart.
17:10:04 <JerubBaal> but I don't think it would have infinitely looped either, not the way I'd done it in prolog
17:10:11 <Pseudonym> Though if you wanted NFAs, that would be even simpler.
17:10:46 <Pseudonym> remCodeGen is too clever for its own good, tht's true.
17:11:01 <shapr> dons: ok, yi is the uh, 'official' repo now?
17:11:26 <Igloo> I'm trying to decide if I want to convert it to a DFA, and if I care about getting matched stuff out
17:11:43 <Pseudonym> The basic idea is to transform the top level of the regular expression into a form tha's easier to turn directly into a DFA or NFA state.
17:12:51 <Pseudonym> The tricky part is that you need to hash cons regular expressions to make the states recursive.
17:13:22 <Igloo> I think I can see in my head both how to easily create the NFA and get the matched stuff out
17:13:43 * Igloo wonder if it'd be possible to make a recursive daatstructure directly without the hash consing
17:13:58 <dons> shapr: ln -s
17:14:17 <shapr> ah, ok
17:14:18 <dons> once I replace all the hemacs tokens, I'll make 'yi' the official repo
17:14:51 <shapr> ok
17:14:52 <Pseudonym> Igloo: It might be.
17:14:53 <Igloo> But I can't remember how the NFA to DFA works, now am I sure it'll remain simple to match stuff, so maybe I should just stick to the NFA
17:15:12 <Pseudonym> If you do this transformation, for example: A* -> 1 + A A*
17:15:18 <Pseudonym> Then you can just make the recursion direct.
17:15:37 <Pseudonym> "+" is or, "1" is the empty string.
17:19:51 <Igloo> Does anyone else find themselves compelled to use Integer for things like regexp bounds when Int will obviously be big enough?
17:20:08 <Pseudonym> No.
17:20:20 <Igloo> I didn't think so
17:21:22 <dons> nope, either
17:23:19 <Igloo> Does not allowing a|b make anything easier?
17:24:05 <Pseudonym> Yes.  It means you can construct DFAs with no gathering pass.
17:24:26 <Igloo> Ah, OK
17:24:42 <Pseudonym> It's as easy to construct DFAs as it is to construct NFAs if there are no ors.
17:25:04 <Igloo> Ah!
17:25:20 <Pseudonym> Maybe.
17:25:30 <Pseudonym> Oh, hang on.  No, not quite.
17:25:40 <Igloo> Right, I'll go back to not bothering then  :-)
17:25:42 <Pseudonym> a*a would result in an NFA.
17:25:59 <Pseudonym> a*a -> a | a (a* a)
17:26:04 <Pseudonym> Right, that's an NFA state.
17:26:19 <Pseudonym> -> a (1 | a (a* a))
17:26:24 <Pseudonym> Because it introduces an or.
17:35:39 <Igloo> Oh, there are ors, just not where I expected them to be
17:44:17 <Igloo> Hmm, if the nice way works then laziness is going to mean it keeps the whole string in memory
17:45:24 <Igloo> Oh, actually, seqing the functions would fix that I think
17:55:03 <Igloo> Are NFAs actually better than just dumb backtracking except for not keeping the whole input in memory?
18:04:24 <shapr> dons: hey, should I start changing tokens to yi as well?
18:04:52 <Pseudonym> Igloo: Yes.
18:05:11 <Pseudonym> NFAs will, in general, do less backtracking.
18:05:28 <Pseudonym> Actually, naive backtracking is actually interpreting a kind of NFA.
18:06:43 <dons> shapr: of course. please send patches
18:06:47 <shapr> right
18:08:25 <Igloo> Pseudonym: Does your last line mean your first one was wrong?
18:09:20 <Igloo> And if not, have you got a simple example where an NFA does better?
18:13:33 <stepcut> why is the reasoning for the name yi?
18:13:52 <shapr> Y I
18:14:01 <stepcut> combinators ?
18:14:09 <shapr> yup, it's the ultimate recursive name
18:14:30 <stepcut> what does the I combinator do again ?
18:15:16 <drlion> identity, right?
18:15:19 * drlion has no idea
18:16:42 * stepcut goes home
18:31:11 <dons> hmm. bug gone once I made the type monomorphic. mysteriouso
18:31:14 <shapr> does darcs mv complain if the file isn't in the repo?
18:31:30 <shapr> yes it does...
18:31:35 <dons> sounds reasonable
18:37:14 <shapr> doh
18:37:32 <shapr> I just said Y to patch 25/100 can I go back and say no?
18:37:40 <shapr> aha
18:38:14 <shapr> dangit, s/Yi/yi
18:50:20 <shapr> dons: sent
18:57:18 <shapr> dons: got it?
19:00:07 <dons> you missed 9 occurences ;)
19:00:12 <shapr> doh
19:00:14 <dons> looks good :)
19:00:23 <shapr> I just found the Yi/Config.hi-boot I missed
19:01:02 <dons> yup. I think i've got them all now
19:01:35 <dons> starts up ok :)
19:01:39 <shapr> spiffy
19:02:07 <dons> yi!
19:02:11 <shapr> yi!
19:02:32 <dons> import Yi.Yi! :)
19:03:19 <shapr> can you record the occurences I missed?
19:03:36 <dons> yep. putting them in now
19:03:51 <shapr> I probably should have used darcs replace ....
19:04:16 <shapr> next time
19:06:30 <shapr> spiffy
19:06:58 <dons> hemacs is dead.. long live yi
19:07:04 <shapr> w00!
19:09:19 <shapr> what's needed to get a modifiable buffer?
19:09:59 <dons> I'm about to commit this. In the next few hours
19:10:05 <shapr> yay
19:10:08 <shapr> I'll check it when I wake up
19:10:11 <shapr> g'night
19:10:16 <dons> ciao
19:11:39 <flaw> yi?
19:11:46 <dons> Y I
19:11:57 <dons> pronounced either "why" or "ee", not sure yet
19:12:05 <dons> (though I keep saying 'why' in my head)
19:12:29 <Pseudonym> I would have thought "yee".
19:12:35 <flaw> me too
19:12:49 <dons> 'yid" maybe
19:12:58 <dons> or even "id"
19:13:07 <Pseudonym> "mu"
19:13:33 <dons> "yee" sounds good
19:14:49 <dons> hope this doesn't turn into a li-nux/lie-nux thing
19:47:36 <shrimpx> i'm wondering about the cases when liftIO is required for lifting an IO action (as opposed to using lift)
19:48:47 <shrimpx> i've found that when nesting state, if the one of the inner states is declared to lift IO, any of the outer ones can liftIO (but not lift)
20:39:39 <vivek> hullo all
20:45:16 <vivek> hello heatsink
20:45:58 <heatsink> hi vivek
21:50:22 <vivek> .
22:09:36 <musasabi> morning
22:11:56 <heatsink> g'morning musa
22:21:43 <vivek> hello musasabi 
23:14:35 <asyd> howdy
23:27:31 <ned> hello 'syd
23:27:40 <asyd> hello ned
23:27:41 <asyd> comment va
23:27:51 <ned> "how's code ?" ;)
23:27:57 <ned> aVa
23:28:21 <ned> et toi ? toujours dans ton "voyage au centre ?"
23:28:46 <asyd> oue
23:28:49 <asyd> enfin hier pas trop
23:29:01 <asyd> j'ai eu un peu la flemme d'autant que je suis sur une partie tres delicate
23:29:27 <ned> tu seras content quand t'auras dépassé
23:33:07 <asyd> oue
