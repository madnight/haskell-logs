00:04:54 <dons> tuomov: try that
00:08:26 <tuomov> applied ok at least. I'll just have to install newer hs-plugins to see if it works
00:09:07 <dons> yep
00:09:17 <dons> it's worked for me on linux and openbsd
00:10:11 <dons> kind of fun. Config.hs feels like a .muttrc
00:11:39 <tuomov> k_map and tag_map should not perhaps go into the settings
00:11:48 <tuomov> as the user can have any submaps
00:11:56 <tuomov> he wants
00:13:08 <dons> it would be nice to individual elems of the style list have top level names, too
00:13:22 <dons> so I could define only attr_infoline, say, in Config.hs
00:13:57 <dons> (also, if you use Plugins.merge, you can call Config.hs whatever you want. e.g. .riotrc)
00:14:23 <tuomov> seems to work
00:14:50 <dons> cool
00:15:04 <tuomov> some work is still required for it to work out of the source directory, or?
00:15:25 <dons> yes.
00:15:45 <dons> you'd have to register libHSginsu, or install it somewhere known with its package.conf
00:15:58 <dons> and the internals of riot would have to be packaged as a library too
00:16:05 <dons> -package riot -package ginsu
00:16:44 <tuomov> how does hs-plugins handle loading of such packages that are already part of the binary?
00:16:54 <tuomov> are they reloaded or does it know that the binary contains them?
00:17:08 <dons> in GHC's rts, there is a strict separation between dynamic and statically linked code
00:17:20 <dons> so they are reloaded
00:17:28 <tuomov> that's rather ugly :(
00:17:30 <dons> usually, adding -export-dynamic brekas the rts
00:17:35 <dons> yes!
00:18:09 <dons> but the rts does magic to dynamically loaded code, which i don't fully understand
00:19:19 <tuomov> One could create a very small stub loader that loads the config and necessary packages
00:19:36 <tuomov> or maybe just the packages
00:21:05 <dons> possibly, I'm not sure what this would involve
00:21:50 <dons> if you can reduce dependencies in Config.hs, less things will be loaded dynamically, obviously
00:23:32 <tuomov> that would mean changing the config system considerably
00:23:41 <tuomov> you could no longer bind functions directly and so on
00:25:35 <dons> given the existing dynamic loader, I don't see a problem with installing libHSriot and libHSginsu when installing riot itself
00:47:05 <crackhead> hello everyone :)
02:16:59 <Lemmih_> Hello crackhead 
03:01:05 <shapr> yow!
03:01:43 <tromp> g'afternoon
03:01:48 <shapr> hoi tromp 
03:04:35 <shapr> how's code?
03:09:20 <tromp> what code?
03:09:34 <dblhelix> :)
03:10:23 <shapr> whatever code you're working on?
03:11:11 <tromp> i was trying to find a bug in java code:)
03:11:22 <tromp> the code is complex:(
03:15:44 <shapr> you could write unit tests?
03:37:14 <tromp> i cld have. but it wldn't have caught this bug. which was a bug in the design rather than implementation:(
04:01:06 <shapr> oh
04:53:07 <ows> Hi!
04:55:32 <ows> Haskell community is not like pseudo-code, here we don't have specifically algorithms but mostly functions declarations (not methods declarations what they should do), right?
04:56:08 <ows> (I'm talking about haskell I forgot to write)
04:59:35 <Lemmih> Are you asking about something?
05:08:13 <blackdog> g'day all.
05:10:09 <blackdog> does anyone know how to bomb out of a haskell program with a reference to the current line?
05:11:03 <bourbaki> hi
05:12:58 <Lemmih> Hey
05:13:45 <Lemmih> blackdog: Perhaps you can do it with hscpp.
05:14:18 <blackdog> it's ok, i just found it - Control.Exception.assert does the trick.
05:14:27 <blackdog> i knew there was a simple way.
05:19:19 <yohanm> heya
05:19:48 <yohanm> ive got this: deleteBy (\x y -> x /= y) 5 [5,3,2,4] 
05:19:53 <yohanm> this should return only five right?
05:19:55 <yohanm> why doesnt it..
05:20:10 <yohanm> anyone got a clue?
05:23:01 <Lor> It should return a function that takes a list and returns only the fives in that list.
05:23:34 <Lor> No, sorry, it removes the _first_ non-five in the list.
05:23:43 <ows> Haskell community I asked if haskell syntax is not like pseudo-code (don't has code on how functions do something), haskell don't has specifically algorithms but mostly functions declarations (not methods declarations and what/how they should do), right?
05:24:08 <yohanm> Lor what do you mean by first?
05:24:09 <tuomov> yohanm: what you want is filter
05:24:13 <yohanm> aha
05:24:52 <Lor> ows, you may want to rephrase that.
05:25:06 <yohanm> thanks
05:26:37 <ows> well, with haskell we are at a high level of abstraction when compared with c, java, c++, right? we only have functions and variables declarations, right?
05:27:49 <Lor> Yes.
05:28:06 <Lemmih> What about data constructures and type classes?
05:28:19 <Lemmih> Or am I missing the whole point here?
05:29:25 <ows> yeah, type classes too..
05:29:46 <ows> but is it posssible to call something like system calls with haskell?
05:30:18 <Lemmih> Yes.
05:30:20 <tuomov> if you couldn't make system calls, you couldn't do anything but simple computations, so...
05:30:54 <Lemmih> ows: Everything you can do in C, you can do in Haskell.
05:31:11 <Lor> Except for segfaults... :)
05:31:19 <blackdog> except impress girls...
05:32:40 <sorje> and there's the FFI too (which may even impress girls).
05:32:46 <ows> humm.. and about lisp macros (and extensibility)?
05:33:26 <Lemmih> I'm not familiar with macros in Lisp.
05:33:41 <blackdog> Template Haskell for all! :) and don's hs-plugins stuff lets you do some pretty funky runtime extensibility tricks.
05:35:42 <ows> is it possible to include some assembly instructions inside haskell code (like in c lang)?
05:36:40 <blackdog> you can do it indirectly through the C FFI - don't know if you can include it directly.
05:36:44 <tuomov> now why would you want that?
05:37:49 <ows> well, to deal directly with linux kernel and drivers
05:37:58 <ows> like in c (and assembly)
05:38:02 <tuomov> and since when have you needed assembly to do so?
05:38:29 <ows> well, it's not essential. but I prefer assembly to do so
05:38:39 <tuomov> some kind people have written libc so we don't have to start writing unportable assembly to interface with the kernel
05:39:26 <blackdog> On occasion, you might want to write unportable code. Everyone's got a kink, and that's no worse than most. :)
05:40:16 <tuomov> in some critical inner loops perhaps, but not in many other places
05:40:30 <tuomov> certainly there's no reason to duplicate syscall code
05:41:10 <ows> how haskell lang specification was created, so that we don't need to specify inside functions what and how I should do?
05:42:14 <Lemmih> Your english is seriously confusing me.
05:46:34 <Lemmih> You might wanna take a look at these websites: www.haskell.org/aboutHaskell.html and www.haskell.org/complex/
05:50:04 <yohanm> where can i find a doc on how 'where' works in haskell? id like to use 2 where but it seems only to work with 1
05:50:25 <Lemmih> You only need one.
05:50:38 <yohanm> oh ok
05:50:41 <yohanm> i have: where (xz,xa) = arrival x
05:50:41 <yohanm> 				where (xp,xd) = departure x 
05:50:53 <yohanm> would i use , or something instead of where?
05:51:00 <Lemmih> where x = 10
05:51:01 <tuomov> just indent properly
05:51:05 <Lemmih>       y = x*2
05:51:10 <tuomov> and leave out the latter where
05:51:12 <yohanm> aha.
05:54:32 <tromp> @index splitAt
05:54:33 <lambdabot> Data.List,GHC.List,Prelude,List
06:00:12 <tromp> @index bit
06:00:13 <lambdabot> Data.Bits,Foreign,Bits
06:03:55 <yohanm> @index observe
06:03:55 <lambdabot> bzzt
06:13:44 <blackdog> any emacs hackers in here? I'm trying to get compile-mode to jump to the first error in the other window, but aren't having much luck...
06:20:10 <shapr> ows: I do not understand your question
06:20:30 <shapr> blackdog: C-x `
06:21:01 <Boegel> hello everyone
06:21:10 <Boegel> @seen mitchkov
06:21:11 <lambdabot> I haven't seen mitchkov
06:21:39 <shapr> seen on Lambda-the-ultimate.org "(subject) Paul Graham's invited talk at ILC 2003 (created) 3 days 15 hours ago (poste) by Michael Walter	13 hours 42 min ago (last reply) by Paul Graham"
06:22:08 <shapr> hoi Boegel 
06:22:12 <shapr> who's mitchkov?
06:22:51 <blackdog> Oh, g'day shapr.
06:22:56 <shapr> g'day mrak
06:22:58 <shapr> how's code?
06:23:11 <shapr> speaking of emacs-hackers, have you heard about the post-emacs mailing list I've created?
06:23:16 <blackdog> pretty good at the moment, actually...
06:23:19 <blackdog> no, i hadn't.
06:23:22 <shapr> awesome :-)
06:23:44 <shapr> haven't seen you on irc lately, does that contribute to your quality and quantity of code? :-)
06:24:00 <Boegel> mitchkov is a friend of me from school
06:24:14 <Boegel> I told him about this channel, but apparently he hasnt visited it
06:24:25 <blackdog> it can help. :)
06:24:29 <shapr> well, I'll give him the usual hazing if he shows up.
06:24:29 <Boegel> how's the Magazine going shapr ? anything new ?
06:24:38 <Boegel> okay shapr
06:24:40 <blackdog> i've got a hard deadline now, so it's all systems go.
06:24:56 <Boegel> he hasn't been here yet because he's still catching up on his thesis subject i guess
06:24:57 <shapr> Boegel: no, nothing... like I said, I won't do it unless there are at least four people committed to regular articles.
06:25:04 <Boegel> so he not programming yet
06:25:12 <Boegel> I get it shapr
06:25:16 <shapr> blackdog: deadlines do help
06:25:20 <Boegel> I think it will be hard to get those people
06:25:48 <shapr> well, I'm willing to do two columns and editorness. but I don't want to do it by myself.
06:26:31 <Boegel> shapr: that wouldn't be human, would it :)
06:26:50 <shapr> I don't have the time and focus to do a monthly haskell magazine by myself.
06:26:57 <Boegel> neither do I :p
06:27:02 <blackdog> shapr: C-x ` is almost what i want: i just need to change it to display in the other window.
06:27:11 <blackdog> what's the magazine about?
06:27:16 <tuomov> hmm..
06:27:16 <Boegel> I don't even have the time to write an article ;)
06:27:18 <shapr> haskell
06:27:20 <blackdog> oh. sorry. lagging. :)
06:27:29 <blackdog> yeah, i just realised. *beetroot*
06:27:53 <shapr> honestly, it's more fun to write code, but articles can be cool too.
06:28:13 <shapr> oh blackdog, I'm working up a whole 'protocol' for Haskell development.
06:28:15 <tuomov> I kinda like writing articles too
06:28:28 <tuomov> but I'm just a haskell n00b
06:28:35 <blackdog> we need a protocol?
06:30:11 <shapr> nah, not a protocol, but ways to integrate a bunch of useful stuff together.
06:30:19 <shapr> I want to do a high-quality mix of XP and Haskell.
06:30:40 <Lemmih> XP?
06:30:42 <blackdog> yeah, that'd be nice. 
06:30:47 <shapr> like the stuff I wrote about one-button testing with HaskellMode, but editor and OS agnostic.
06:31:01 <shapr> zero-button testing, run the unit tests when the file is saved
06:31:21 <shapr> easy to do with save-hooks in emacs, but inotify sounds better for Linux.
06:31:26 <shapr> tuomov: you want to write an article or a column?
06:31:36 <shapr> Lemmih: eXtreme Programming
06:31:48 <tuomov> at this point, I don't think I have much to say
06:31:55 <shapr> blackdog: I sent my Test-Driven-Development QuickCheck version to Koen, he said he'll look at it.
06:32:11 <shapr> tuomov: you could talk about learning Haskell, have you seen Graham Klyne's notes?
06:32:23 <tuomov> no
06:32:34 <blackdog> it's the one-button testing stuff I'm looking at now - trying to get it so that it goes to the first error in the window that isn't the compile buffer.. did a bit of munging in the makefile and now compile-mode looks at assertion failures. :)
06:33:15 <Boegel> neither have I shapr
06:33:19 <tuomov> (no as in have not seen)
06:33:29 <Boegel> and I'm also still learning Haskell :)
06:34:09 <tuomov> but yeah, perhaps I could at least occasionally write something if such a mag came to be
06:34:26 <tuomov> but monthly, I don't know. 
06:34:38 <tuomov> I guess it depends on what I decide to do with my so-called life
06:35:23 <tuomov> at the moment I have all the time and still I don't have time for anything
06:35:34 <tuomov> trying to figure that out
06:36:03 <Boegel> grr, I can't get syntax highlighting working for Haskell in Emacs :(
06:37:38 <shapr> blackdog: nifty
06:37:54 <blackdog> shapr: what's C-x ` actually bound to? How do i find out?
06:38:04 <shapr> blackdog: C-h k C-x `
06:38:24 <blackdog> bewdiful.
06:38:25 <shapr> once you hit C-h k, you can press any keycombo to get help on that command
06:38:33 <shapr> C-h w lets you type in a function name
06:39:06 <shapr> tuomov: I'd be interested in your thoughts upon learning Haskell.
06:39:10 <Boegel> shapr, can you help me with the syntax highlighting thingie in emacs ?
06:39:36 <shapr> for example, check out Graham Klyne's notes - http://www.ninebynine.org/Software/Learning-Haskell-Notes.html
06:39:41 <shapr> Boegel: gnu emacs or xemacs?
06:40:03 <Boegel> emacs for win32
06:40:12 <Boegel> no xemacs, but emacs
06:40:24 <shapr> ok, M-x global-font-lock-mode
06:40:32 <shapr> or (global-font-lock-mode 1) in your .emacs
06:40:41 <Boegel> wait
06:40:57 <Boegel> I'll show you my .emacs file, and where I put the haskell font lock files
06:40:59 <Boegel> okay ?
06:41:19 <shapr> all you have to do is put "(global-font-lock-mode 1)" into your .emacs
06:41:27 <shapr> then you get color on emacs startup
06:41:35 <shapr> if you want to turn it on right now without restarting emacs
06:41:46 <shapr> you can press meta-x and type global-font-lock-mode <enter>
06:42:06 <blackdog> shapr: is there a general way to change which window a command operates on?
06:42:21 <shapr> not that I can think of, but I'm not an emacs expert
06:42:25 <blackdog> sorry, this is turning into emacs 101. :)
06:42:46 <blackdog> jeez, if you're not an expert, who is?
06:43:17 <shapr> Alex Schroeder, aranan(sp?), Mario Lang, Luke Gorrie, etc :-)
06:43:26 <shapr> of course, some of those people are emacs maintainers....
06:43:50 <shapr> I just never got into elisp and emacs internals, it never really did it for me.
06:43:53 <Boegel> shapr, I put the line in .emacs, but no change at startup, or after opening a hs file
06:44:01 <shapr> I can hack some elisp, but nothing really nifty.
06:44:30 <shapr> Boegel: when you open an .hs file, does it say Haskell in the mode-line?
06:44:58 <Boegel> http://wina.ugent.be/oldskool/cursussite/temp/.emacs
06:45:15 <shapr> Boegel: http://www.scannedinavian.org/~shae/ghcisshot.png
06:45:17 <Boegel> shapr: is that the black line on the bottom ? if so, no
06:45:26 <Boegel> it says (Emacs-Lisp)
06:45:43 <shapr> Boegel: are you really using emasc 20.7 ??
06:46:06 <Boegel> 20.7.1
06:46:09 <shapr> if so, there's your first problem :-)
06:46:13 <Boegel> java syntax highlighting works
06:46:18 <shapr> upgrade to gnu emacs 21
06:46:30 <shapr> iirc, global-font-lock-mode doesn't work in 20.7
06:47:09 <Boegel> oh okay
06:47:18 <Boegel> let's do that then :)
06:47:24 <shapr> blackdog: tried checking M-x customize-group compile ?
06:47:33 <Boegel> and then the syntax highlighting bit should work without installing extra files?
06:47:42 <shapr> sort of...
06:48:00 <shapr> if you have the latest haskell-mode and the latest gnu emacs, then (global-font-lock-mode 1) in your .emacs should give you pretty colors.
06:48:24 <shapr> blackdog: hey, if you were rewriting emacs, how would you do it?
06:48:28 <shapr> tuomov: you use emacs?
06:49:06 <shapr> Boegel: don't you love my emacs color-theme ;-)
06:49:16 <shapr> most people complain that it burns their eyes out of their skull...
06:49:31 <tuomov> shapr: jed
06:49:37 <shapr> oh
06:50:29 <tuomov> with joe-style bindings and not the emacsy defaults
06:50:31 <blackdog> shapr: well, a typed scripting language would be nice.
06:50:33 <shapr> blackdog: you found any useful practices I might not know about?
06:50:38 <blackdog> </predictable>
06:50:45 <tuomov> I've never liked emacs bindings 
06:51:01 <shapr> I've been thinking about a concurrent Joy scripting language implemented in Haskell.
06:51:02 <tuomov> escape meta alt control shift
06:51:16 <Boegel> shapr: actually, no, I don't like it :)
06:51:21 <Boegel> it looks like hell
06:51:25 <shapr> I can hit C-M-Sh-H-S-BS with one finger.
06:51:36 <Boegel> I sure as hell couldn't work like that
06:51:47 <blackdog> doubt it... i'm just trying to make my working environment as smooth as possible. I'm so easily distracted, I can't give myself any easy outs. :)
06:51:49 <shapr> lots of the color-themes are quite relaxing
06:51:56 <shapr> blackdog: I know that feeling.
06:53:02 <shapr> man, I want to play with the new version of QuickCheck....
06:53:03 <blackdog> on the gripping hand, it's very easy to spend hours customising stuff and never actually do any real work... i think i'm coming perilously close to that now. (just have to dedicate a week or two to getting past the emacs-newbie stage)
06:53:18 <blackdog> what's new?
06:53:34 <shapr> shrink will be in the new version
06:53:41 <shapr> and maybe my test-first code if I'm lucky
06:53:55 <shapr> shrink will rock :-)
06:54:34 <shapr> I also hope they'll give real examples of QuickCheckM usage, I could never get that working for me.
06:54:40 <shapr> have you ever tried it?
06:55:03 <blackdog> No. I'm still integrating hunit into my workflow.
06:55:05 <shapr> has anyone here used QuickCheckM for monadic testing? I screwed around with it for six or seven hours and finally gave up and wrote assertEqualM for HUnit.
06:55:32 <shapr> QuickCheck is way better, from one viewpoint.
06:55:47 <shapr> but standard QC doesn't let you retest with the same input
06:56:04 <Boegel> shapr, I downloaded emacs 21.3, but still no syntax highlighting for Haskell
06:56:06 <shapr> so I hacked it to save the RNG seed if the generated test case fails.
06:56:24 <Boegel> and I put "(global-font-lock-mode 1)" in .emacs
06:56:32 <shapr> Boegel: ok, do you have an .hs file open?
06:56:34 <blackdog> btw, shae, should http://www.webwitches.com/~shae work?
06:56:39 <shapr> er, I dunno
06:56:49 <shapr> oh, no, It shouldn't...
06:56:56 <Boegel> yes I do
06:56:58 <shapr> http://www.ScannedInAvian.com/ shoudl
06:57:07 <Boegel> but my java syntax highlighting is gone now to
06:57:11 <shapr> Boegel: does it say Haskell in the mode-line?
06:57:20 <Boegel> no
06:57:40 <shapr> blackdog: I pried webwitches off of our ISP's win32 server and it's running on ScannedInAvian
06:57:56 <shapr> Boegel: ok, check your load-path value with C-h v load-path
06:58:25 <blackdog> ah, gotcha. I was just looking to grab your elisp files. Got it now, so it's not important.
06:58:48 <shapr> I haven't updated my online elisp for awhile
06:58:57 <shapr> but the old stuff should be here: http://www.scannedinavian.org/~shae/src/elisp/
06:59:19 <Boegel> shapr, C-h v means 'hold ctrl in, push h then v', right ?
06:59:27 <Boegel> 'cause that doesn't work with me :)
06:59:30 <Boegel> :s
06:59:35 <shapr> Boegel: C-h v means hold ctrl and push h, then let off control and push v
06:59:41 <Boegel> oh sry :s
06:59:47 <shapr> C-h C-v would be holding control while pressing both
07:00:01 <Boegel> okay, it worked :s
07:00:06 <Boegel> now what ?
07:00:24 <shapr> load-path tells you which directories emacs looks in to find elisp files
07:00:25 <Boegel> it gives a whole load of directory's
07:00:38 <Boegel> uhu
07:00:52 <Boegel> oh, I should put the haskell lock files into one of those then ?
07:01:13 <shapr> so, decide where you want to put elisp addons, then put something like (add-to-list 'load-path "/home/shae/.xemacs") into your .emacs
07:01:31 <Boegel> okay
07:01:45 <shapr> thing is, I don't know how win32 load-path entries should look.. "C:\home\boegel\elisp" ? no clue
07:01:45 <Boegel> and should I restart emacs then ?
07:01:53 <Boegel> or can I do it another way
07:02:00 <Boegel> no
07:02:02 <shapr> you can do it another way
07:02:03 <Boegel> more like
07:02:18 <Boegel> "C:\Program Files\emacs21.3\lisp"
07:02:31 <shapr> emacs lets you instantly execute any visible elisp by putting your cursor just after the last parentheses and pressing C-x C-e
07:02:35 <Boegel> shapr: how can I do it ? I want to learn more on emacs
07:03:03 <Boegel> okay, let's try that :)
07:03:03 <shapr> the add-to-list function makes sure there aren't duplicate entries.
07:03:36 <shapr> so, let's say you've got haskell-mode files in "C:\Program Files\emacs21.3\lisp\haskell" (just guessing)
07:03:54 <Boegel> remove the 'haskell' bit, and you're right
07:03:55 <Boegel> hmmz
07:03:59 <shapr> then you open your .emacs file and put in (add-to-list 'load-path "C:\Program Files\emacs21.3\lisp\haskell")
07:04:00 <Boegel> maybeI should put em there :p
07:04:19 <shapr> then you move your cursor just after the last parentheses there, and press C-x C-e
07:04:39 <Boegel> oh like that
07:04:44 <Boegel> okay, let's do that :)
07:05:39 <Boegel> now, my window is 'split in half'
07:05:40 <shapr> emacs isn't really an 'editor' it's really the elisp language written in C with some windowy bindings, and then everything else is written in elisp.
07:05:42 <Boegel> how can I fix that ?
07:05:46 <shapr> C-x 1
07:05:56 <Boegel> nice :)
07:06:12 <Boegel> C-x 2 would have given the window at the bottom ?
07:06:23 <Boegel> oh no
07:06:29 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-28)!
07:06:31 <Boegel> it would have split the window further, right ?
07:06:45 <shapr> C-x 0 means "get rid of this window"
07:06:54 <shapr> C-x 1 means "make this the only window"
07:06:59 <Boegel> and, how can I 'jump' between opened documents?
07:07:11 <Boegel> because I always use my mouse for that
07:07:20 <Boegel> but I'm guessing I can do it faster :)
07:07:26 <shapr> well, you can use the C-x b and then type the name of the document, but that sucks
07:07:26 <blackdog> C-x b
07:07:33 <shapr> better way is to use iswitchb
07:07:41 <shapr> which replaces the standard buffer switching
07:07:44 <blackdog> oh, i forgot you set that up for me. :)
07:07:47 <shapr> whoops
07:08:02 <shapr> blackdog: do you have to type the entire buffer name? or just a unique substring?
07:08:13 <shapr> Boegel: but (iswitchb-default-keybindings) into your .emacs
07:08:21 <shapr> s/but/put/
07:08:28 <blackdog> just a unique substring
07:08:37 <shapr> ok, then I probably did set that up for you.
07:08:46 <shapr> blackdog: is your .emacs online?
07:09:07 <blackdog> nope. it's my dirty little secret.
07:09:16 <shapr> I've rebound Shift_R to iswitchb-buffer, which is what's called from C-x b
07:09:18 <blackdog> why, you wanna see it?
07:09:41 <shapr> sure, I wonder if I've learned more stuff since I set that up for you, maybe I can improve it.
07:10:20 <shapr> Boegel: ok, once you've put (iswitchb-default-keybindings) into your .emacs (and also executed it for immediate use) then C-x b is more fun.
07:10:25 <shapr> the standard C-x b sucks much.
07:10:55 <shapr> oh I remember, I have switched my keybinding around a lot since ICFP03. I found a bunch of useful stuff when I was one-handed keyboarding.
07:11:15 <blackdog> *snigger*
07:11:30 <shapr> RSI :-P
07:11:37 <shapr> geez, that sounds even worse
07:11:41 * shapr gives up
07:12:26 <blackdog> jeez, that's a bit extreme
07:12:28 <shapr> anymore emacs questions?
07:13:27 <blackdog> www.cse.unsw.edu.au/~mwotton/init.el
07:13:56 <blackdog> i'm trying to customise it for dual display
07:14:01 <blackdog> without much luck. :/
07:14:03 <shapr> pizza-mode ??
07:14:38 <shapr> ah neat, you're using diary
07:14:40 <blackdog> FP version of java. pretty nice, and if you're delivering .class files, th customer never needs to know.
07:14:50 <shapr> you should check out Sacha Chua's planner-mode
07:14:51 <blackdog> actually, I'm not. I started and lapsed.
07:14:58 <shapr> she's turned emacs into outlook++
07:15:02 <Boegel> shapr, the syntax highlighting bit doesn't work yet :s
07:15:07 <Boegel> (global-font-lock-mode 1)
07:15:07 <Boegel> (add-to-list 'load-path "C:/Program Files/emacs-21.3/lisp/haskell")
07:15:07 <Boegel> (iswitchb-default-keybindings)
07:15:13 <Boegel> this is my .emacs now
07:15:15 <shapr> ok
07:15:24 <shapr> next, let's see if your emacs can find the haskell-mode files
07:15:34 <shapr> put (require 'haskell-mode) into your .emacs
07:15:54 <Boegel> and execute?
07:15:56 <shapr> yup
07:16:07 <Boegel> okdone
07:16:33 <shapr> (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock) (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci) (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode) (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan) (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
07:16:47 <shapr> for extra-spiffy haskell abilitiez
07:17:18 <shapr> one of the great strengths of elisp/emacs is 'hooks'
07:17:40 <shapr> you can get your own code to be executed before, after, or instead of something else
07:18:17 <shapr> funny thing is that's becoming really popular in the OOP world nowadays, those hooks and some formal theory are called "aspect oriented programming"
07:18:20 <Boegel> shapr, I still have no highlighting :s
07:18:25 <shapr> right, we're getting there :-)
07:18:37 <Boegel> I've heard about that
07:18:40 <shapr> you'll have a nice shiny mercedes by the time we're done.
07:18:49 <Boegel> that should be the new step in programming
07:19:01 <blackdog> my friends all drive notepad, i must make amends
07:19:02 <shapr> it's been around forever, emacs users have known about it for decades.
07:19:20 <Boegel> oh
07:19:32 <shapr> Boegel: anyway, open an .hs file now
07:19:37 <Boegel> we'll, at my university they're looking at it as the next big step
07:19:46 <tic> shapr, decorators?
07:19:47 <tuomov> isn't aop just type classes?
07:19:56 <Boegel> it says '(Fundamental)' at the bottom :s
07:20:30 <shapr> look here --> http://www.cse.unsw.edu.au/~mwotton/init.el grab the part that starts with auto-mode-alist
07:20:43 <blackdog> yay, i'm useful!
07:20:45 <shapr> (setq auto-mode-alist ...
07:20:54 <shapr> tic: yah, pretty much
07:21:09 <shapr> tuomov: aop is more about monads
07:21:28 <tic> shapr, k.
07:22:37 <Boegel> done shapr
07:22:39 <Boegel> executed
07:22:43 <Boegel> no highlighting
07:22:43 <Boegel> :p
07:23:01 <Boegel> and still (Fundamental) at the bottom
07:23:15 <shapr> Boegel: ok, hit M-x haskell-mode
07:23:45 <shapr> hm, doesn't Garrin Kimmel hang out here?
07:23:57 <Boegel> yep
07:23:58 <Boegel> works
07:23:58 <Boegel> :)
07:24:13 <shapr> now, close the file and reopen it
07:24:15 <blackdog> Boegel: were you editing a file with a .hs extension?
07:24:53 <Boegel> yes I was
07:25:02 <Boegel> how do I close a file ? :>
07:25:07 <shapr> thing is, you opened the file before your haskell-mode was configured.
07:25:08 <Boegel> C-x ... ?
07:25:12 <shapr> C-x k
07:25:15 <shapr> then enter
07:25:16 <TheHunter> shapr: i don't think aop is about monads, the monad laws are getting in the way of that.
07:25:45 <shapr> TheHunter: how so?
07:25:51 <TheHunter> (but i have to admit I don't have a very clear idea of what aop is)
07:25:54 <Boegel> reopening: syntax highlighting
07:25:56 <Boegel> nice
07:25:57 <Boegel> thx
07:26:20 <Boegel> http://wina.ugent.be/oldskool/cursussite/temp/emacs.jpg
07:26:29 <Boegel> colors are a bit simple though :p
07:26:50 <Boegel> I've learned a whole lot shapr, thx
07:26:58 <TheHunter> shapr: if you want to have a hook on every `execution point' of your program, you can implement a "monad" that maybe prints out something every time a bind is executed.
07:27:02 <Boegel> I'll write it down so I won't forget it, and keep using it
07:27:49 <shapr> Boegel: better colors here: http://www.emacswiki.org/cgi-bin/wiki/ColorTheme
07:27:53 <TheHunter> shapr: but you can't really do this because then a >> return () >> c and a >> c have different side effects
07:28:33 <TheHunter> maybe i'm getting aop wrong, though
07:28:46 <shapr> or maybe I am
07:28:54 <shapr> worth looking at more.
07:28:55 <Boegel> shapr, how do I put comment in the .emacs file?
07:28:56 <Boegel> %% ?
07:29:06 <Boegel> comment = documentation :)
07:29:09 <shapr> semicolon
07:29:15 <Boegel> ; ?
07:29:18 <shapr> yup
07:29:34 <shapr> or two semicolons for system docs, or pre defun docs
07:29:49 <Boegel> okay, thx
07:30:41 <Boegel> shapr: can I install a color scheme for Haskell only
07:31:35 <shapr> err, probably
07:33:01 <shapr> TheHunter: "Monads as a theoretical foundation for AOP" Wolfgang De Meuter - haven't read it yet...
07:33:35 <TheHunter> oh...
07:33:58 <shapr> Boegel: two possibilities, either you can use a color-theme for a single frame, or maybe haskell-mode defines its own faces, in which case you can customize only those colors.
07:34:47 <Boegel> okay
07:34:55 <TheHunter> shapr: i also wanted to throw in the argument that aop seems to be an inherently first-order thingie that doesn't go well together with the higher-order-character of monadic fp, but forget about that...
07:35:00 <shapr> TheHunter: of course, that paper might be about disproving monads as a basis for AOP, I don't know :-)
07:35:16 <bourbaki> pure :: (a -> b) -> f a b, pure f = ..., whats the type of f a b like then?
07:35:29 <tuomov> I guess you could model "extracting an aspect" as a monad..
07:35:29 <shapr> bourbaki: f is an arrow from a to b
07:35:33 <Boegel> shapr, still one problem: when I close and reopen emacs, the syntax highlighting for hs files is gone
07:35:35 <TheHunter> shapr: i'll have a look at it
07:35:42 <Boegel> only when I use M-x haskell-mode, it works
07:36:01 <shapr> Boegel: that's odd
07:36:12 <bourbaki> shapr: can you give me an example for a type for that?
07:36:33 <shapr> @type Control.Arrow.pure
07:36:34 <lambdabot> Control.Arrow.pure :: forall a c b.
07:36:34 <lambdabot> 		      (Control.Arrow.Arrow a) =>
07:36:34 <lambdabot> 		      (b -> c) -> a b c
07:36:51 <tuomov> but what little I read about it, it seemed to be about designing oo in such  way that type classes/interfaces are used more instead of inheritance
07:36:59 <shapr> @type Control.Arrow.pure (+)
07:37:00 <lambdabot> Control.Arrow.pure (+) :: forall a b.
07:37:00 <lambdabot> 			  (Control.Arrow.Arrow a, Num b) =>
07:37:00 <lambdabot> 			  a b (b -> b)
07:37:22 <shapr> Boegel: can you put your .emacs online so I can look at it?
07:37:29 <bourbaki> shapr: and what would an implementation of it look like?
07:37:39 <Lemmih> Yes!
07:37:46 * Lemmih does the happy dance.
07:37:53 <shapr> bourbaki: implementation of what?
07:38:13 <Boegel> shapr: yeah, sure
07:38:30 <bourbaki> shapr: sec let me not-post it
07:39:35 <shapr> bourbaki: what about "pure (+ 1)" ?
07:39:39 <bourbaki> shapr: http://paste.phpfi.com/32780
07:40:15 <shapr> Boegel: try moving the global-font-lock-mode line to the bottom maybe?
07:40:23 <Boegel> okay
07:40:27 <shapr> er, no that's not the problem
07:40:54 <Boegel> shapr: no, it's not :)
07:41:03 <shapr> the auto-mode-alist thingy isn't working.
07:41:10 <Boegel> ow wait
07:41:17 <shapr> it should notice that the filename .ends with .hs and then turn on haskell-mode
07:41:28 <Boegel> if I do M-x haskell-mode now, it says 'no match'
07:41:28 <Boegel> :s
07:41:32 <shapr> ohh
07:41:39 <shapr> then the haskell-mode files aren't in your load-path
07:41:49 <TheHunter> Section 3, after a short paragraph introducing bind and unit and saying nothing about any monad laws: "Now that we know what a monad is..."
07:42:01 <shapr> TheHunter: oh, you think they got it wong?
07:42:08 <shapr> "wrong"
07:42:37 <shapr> bourbaki: are you reading Paterson's chapter? or Hughes' paper?
07:43:03 <bourbaki> shapr: petersons
07:43:29 <shapr> Boegel: look at the load-path value again, (try using M-x pp-variable load-path)
07:44:21 <Boegel> when I did C-h v load-path, it wasn't there indeed
07:44:36 <Boegel> but when I executed the command in .emacs, it was adjusted...
07:44:51 <Boegel> emacs isn't looking at the .emacs file ? :s
07:45:12 <shapr> bourbaki: I could give the exact definition and sound really cool, but really I just looked at the top of page 6 =)
07:45:20 <bourbaki> shapr: i dont understand what f a b is exactly
07:45:45 <bourbaki> shapr: is that ND this not of type f a b?
07:45:48 <TheHunter> shapr: the paper is doesn't really contain any information
07:46:17 <TheHunter> shapr: just a few examples of monads implemented in scheme and the conclusion that monads and aop have much in common
07:47:08 <shapr> bourbaki: you've seen "data Maybe a = Just a | Nothing" right?
07:47:41 <shapr> bourbaki: did you look at the Arrow instance for ND on top of page 6?
07:47:54 <shapr> TheHunter: that's cheesy... not much proof in the paper.
07:48:05 <Boegel> shapr, if I executed the commands in the .emacs file, it works
07:48:37 <shapr> Boegel: oh I bet I know, it's probably checking %HOME% for a file named .emacs, have you set a value for %HOME% ?
07:48:53 <bourbaki> shapr: yes
07:48:55 <shapr> hej andersca
07:48:55 <Boegel> shapr: how can I do that ?
07:49:04 <andersca> hej
07:49:17 <shapr> Boegel: control panel... um... something in there lets you set environment variables
07:49:29 <Boegel> shapr: I put the .emacs file in the emacs-21.3 directory, I guessed it would check there for the file...
07:49:45 <Boegel> oh, I should do it in windows?
07:50:00 <Boegel> it's probably because I reinstalled 21.3 instead of 20.7 :)
07:50:06 <Boegel> that will be the problem
07:50:08 <Boegel> *stupid*
07:50:36 <shapr> I think you just need to give windows the %HOME% env var, and then emacs will look there for your .emacs
07:50:47 <shapr> at least, that's what happened to me last time I used emacs on windows
07:51:31 <TheHunter> shapr: the problem is i don't really know what aop is. If it means you can invoke stuff before and after message calls, then monads don't give you much unless you make the hooks explicit in your code. If, on the other hand, you think of aop as the buzzword to describe everything oop can't really manage, then of course monads are a nice way of achieving this.
07:52:35 <Boegel> shapr: how can I determine which env var emacs is looking for ?
07:53:04 <shapr> Boegel: check the docs, or ask on #emacs, but I'm pretty sure it's looking for %HOME% so it can execute %HOME%\.emacs
07:53:24 <shapr> bourbaki: f a b is a first-class representation of a transformation from a to b
07:53:25 <Boegel> it's probably another variable in windows :)
07:53:39 <tuomov> the foldoc definition of aop doesn't say anything..
07:54:36 <Boegel> shapr: nevermind, it works
07:54:39 <shapr> bourbaki: I don't think I understand your question, you want to see how pure can be implemented for NonDet? or what?
07:54:41 <Boegel> you were right
07:54:52 <bourbaki> shapr: yes
07:55:16 <shapr> Boegel: what did you do?
07:55:18 <Boegel> now I can finally start to code the ray casting algorithm I finished in FunMath in Haskell
07:55:23 <shapr> yay! code!
07:55:45 * Boegel bounces with shapr
07:55:54 * shapr bounces with Boegel 
07:56:27 <ows> Hi, with imperative languages we specify what and how to do something in a function.. but with haskell we don't need that, but how haskell compiler is organized to knows what and how to do something inside a function at a runtime?
07:56:47 <shapr> the first informal description of AOP that I heard was that AOP is used to separate cross-cutting concern into their own  separate piece, and then weave them back together later.
07:57:24 <tuomov> sounds like a marketing speech
07:57:37 <shapr> the example I got was that a client-server application might have most of its code on the server, but that AOP could be used to move the code around so that as little bandwidth as possible is used
07:57:43 <tuomov> doesn't say anything but sounds complicated
07:58:04 <shapr> I thought it was bullshit at first, but then the creator of Jython switched jobs to work on AspectJ
07:58:20 * Boegel is off, trying to finish that algorithm
07:58:21 <Boegel> bye !
07:58:22 <shapr> ows: call-by-name
07:58:25 <shapr> Boegel: cya!
07:59:03 <shapr> ows: the three major approaches to programming (as far as I know) are procedural, functional, and logic/constraint
07:59:37 <shapr> procedural is step-by-step, functional is like a math equation, everything gets simplified down, and logic/constraint is a set of relationships
07:59:54 <shapr> (NB. I haven't learned logic/constraint yet, my info could easily be wrong there)
08:01:14 <shapr> tuomov: Jim Hugunin seems really smart to me, and he moved to work on AspectJ (moved to Xerox PARC, I think)
08:01:32 <shapr> so I figure, there must be something more than marketing there.
08:01:37 <xerox> nobody moved here
08:01:42 <xerox> *g*
08:01:45 <shapr> :-)
08:03:26 <shapr> bourbaki: the given info is "type NonDet i o = i -> [o]" and  pure f = ND (\b -> [f b])
08:03:42 <shapr> so I assume that's really type NonDet i o = ND (i -> [o])
08:04:05 <shapr> and in that case, it's a lot like a Functor instance, isn't it?
08:04:14 <bourbaki> shapr: http://paste.phpfi.com/32792
08:04:31 <shapr> right
08:04:43 <bourbaki> shapr: but that gives me an error
08:06:35 <TheHunter> bourbaki: pure :: (a -> b) -> NonDet a b
08:06:56 <bourbaki> TheHunter: ahh *feels dumb* sec
08:06:56 <shapr> hej Denizen
08:07:52 <shapr> ows: did you understand my answer?
08:07:59 <bourbaki> TheHunter: thx
08:09:55 <shapr> AspectJ Programming Guide claims to introduce AOP and the AspectJ language: http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/progguide/index.html
08:09:59 * shapr reads
08:10:36 <tuomov> http://www-106.ibm.com/developerworks/java/library/j-aspectj/
08:10:39 <tuomov> there's another
08:10:55 <tuomov> by that it seems to be an awful 'exec some other code at these points' kludge
08:10:58 <bourbaki> isnt aop something that you can do nicely with arrows?
08:11:45 <shapr> bourbaki: I think so
08:12:20 <bourbaki> shapr: i wanted to use some aop like things with that graph system i want to do with arrows to optimize it
08:12:35 <TheHunter> shapr, tuomov: from what I read, I think aop is very much about modularity. You have some code written by this idiot who didn't care much about extensionality, and since you don't have his code, you add some functionality using codepoints.
08:13:02 <tuomov> yes, very ugly
08:13:18 <shapr> like I said, it's elisp's before, after, and replace hooks.
08:13:25 <shapr> aka, pre-hook, post-hook, and advice
08:14:13 <shapr> there were some excited AOP people at ICFP03, and I got the impression they'd put together some heavy-duty theory that increased the abstraction or something.
08:14:15 <bourbaki> shapr: do you know the meta object [
08:14:20 <bourbaki> shapr: do you know the meta object protocol?
08:14:41 <tuomov> it might be more cleanly done with generic programming, but that java is awful
08:14:42 <shapr> Common Lisp's MOP? I've only heard of it.
08:15:05 <bourbaki> shapr: i think that is also a good base for AOP
08:15:28 <shapr> or, you could just use Python or Ruby, where you can replace all of your methods at runtime
08:15:51 <shapr> then instrumentation, logging, or whatever is pretty easy.
08:17:01 <blackdog> god, if i never see logging as justification for AOP again it'll be too soon. It's like seeing fibonacci in haskell, or that dinky quicksort-alike
08:18:03 <tuomov> yes, are there any real examples?
08:18:45 <shapr> it sure looks like just 'subclass function calls' like a monad.
08:19:25 <tuomov> sideffects++
08:19:28 <tuomov> +e
08:19:36 <shapr> hej Harteex 
08:19:44 <tuomov> absolutely no way to reason about the code
08:20:21 <shapr> Harteex: are you new to haskell? or a long-time user?
08:20:52 <Harteex> new
08:21:08 <shapr> have any questions? want the short tour of the #haskell channel?
08:21:42 <Harteex> no questions right now :)
08:22:27 <ows> shapr: so, algol based lang (like c++ and java OO) are procedural lang.. you said that you know some sites with haskell AI source, is it possible to gimme the addresses?
08:26:00 <shapr> ows: here's a good starting point: http://www.mail-archive.com/haskell-cafe@haskell.org/msg04529.html
08:28:11 <shapr> google turns up a bunch of stuff with "haskell neural" like http://lift.mdworld.nl/bellboy_src.zip
08:29:44 <ows> k, tkx
08:38:37 <shapr> tuomov: have you found any real examples?
08:39:03 <tuomov> there's the property change notification example that might be of some value
08:39:22 <tuomov> 3. Example -> Production Aspects
08:40:02 <shapr> still sounds like function call subclass
08:41:34 <shapr> it does seem to be advantageous for Java, 'timing' is good to be separate from the other telecom code in that example.
08:42:29 <shapr> is there anything that AOP can do for Java, that cannot be done with higher-order functions?
08:45:31 <shapr> From what I've read so far, arrows do the same thing, but better.
08:45:36 <tuomov> I don't think so, although in some cases despite being ugly, the aop way could be faster to write
08:46:01 <tuomov> (that reply being to "is there..")
08:48:07 <Philippa_> shapr: hell, monads don't make too bad an attempt at AOP on their own, arrows just add the extra flexibility
08:48:15 <shapr> yah, I agree.
08:48:50 <Philippa> saw somebody mentioning that on flipcode's forums a year or so back - when something like that's being discussed in a game coder's forum, chances are you've something worth building on...
08:49:07 <shapr> mentioning what? monads do AOP?
08:49:18 <shapr> is flipcode worth reading?
08:51:51 <TheHunter> I still don't think anything like AOP is possible using monads/arrows without making the hooks explicit. Chances are, however, that you can automate this using TH.
08:52:23 <shapr> what do you mean 'without making the hooks explicit' ?
08:52:58 <shapr> gutenabend Blackwell
08:53:09 <TheHunter> like myFunc = do { beforeHook "myFunc"; x <- origFunc; afterHook "myFunc"; return x}
08:53:28 * shapr thinks about that
08:53:30 <Blackwell> shapr: hi. are you the local "open ports" scanner? ;)
08:53:37 <shapr> er.. I guess so.
08:53:38 <Philippa> flipcode can be mixed, sometimes the forums are really good sometimes they're just forums
08:53:49 <TheHunter> well, probably x <- lift origFunc.
08:53:51 <shapr> Blackwell: I'm the unofficial greeting and introduction person.
08:53:52 <Philippa> #flipcode's going a bit downhill atm, it comes and goes
08:54:03 <Blackwell> shapr: had that when i hit #java first, was greeted with some comments regarding kazaa running in the background ;)
08:54:16 <Blackwell> shapr: ah, ok. you are doing an important job. :)
08:54:25 <shapr> no, I don't scan people like that...
08:54:28 <Philippa> TheHunter: right, lift/pure/return are important points
08:54:58 <Blackwell> anyway...<wave>
08:55:03 <shapr> I merely attempt to direct new people to the resources they want...
08:55:05 <shapr> um, bye!
08:55:07 <Philippa> though I figure you were thinking about withFoo constructs
08:55:07 * shapr wonders
08:56:26 <TheHunter> Philippa: ok, that's true, withFoo could help.
08:56:48 <tuomov> the problem is identifying functions
08:57:10 <Philippa> see previous comment about "why can't we have pure functions expressed as an arrow type by default?"
08:57:20 <shapr> hiya webby 
08:57:21 <Philippa> (long time previous, mind - I say that once in a while)
08:57:26 <webby> shapr hi ya mate
08:57:29 <shapr> webby: looking for Haskell info?
08:57:59 <shapr> I think named join points would be easy enough to do with arrows.
08:58:06 <shapr> and you could just transform standard functions, right?
08:58:10 <webby> shapr well sort of, i am quite suprised by the number of people in this room i though haskell was quite un common lol
08:58:21 <tuomov> one count individually lift each function along with a name
08:58:26 <shapr> webby: actually, we're the Haskell Secret Underground...
08:58:32 <shapr> we don't advertise, you have to find us by yourself.
08:58:33 <tuomov> aopFunc = liftAop origFunc "origFunc"
08:58:41 <tuomov> but that's quite inconvenient
08:59:10 <Philippa> yeah, you do something a little bit different where you still fill in the aspect details "in-place" but they're not woven already
08:59:22 <Philippa> the aspect stuff's all parameters
09:01:04 <shapr> webby: are you learning Haskell? long-time user?
09:01:58 <shapr> I think elisp keeps a list of pre- post- and advice functions
09:02:13 <shapr> that might be inconvenient in Haskell
09:03:07 <shapr> but arrows that just stick on a pre-, post-, or replacement should be easy enough
09:03:08 * shapr thinsk
09:03:33 <shapr> would suck though, you'd lose predictability
09:03:56 <shapr> arrows can hold state, you could do it the yampa way.
09:04:57 <shapr> will that work?
09:05:28 <tuomov> you could pass events around, but there's still the issue of giving names to them
09:05:58 <shapr> arrows are sort of pass-by-reference function objects
09:06:02 <tuomov> or you could just modify the state and have everything re-inspect it
09:06:14 <shapr> or are you thinking about how this would work at run time?
09:06:55 <shapr> if you stick with compile-time AOP, it's easy enough.
09:07:19 <shapr> you're right that run-time AOP would require named events
09:07:24 <tuomov> I'm thinking how some handler can know which function is called
09:08:10 <shapr> can you wrap the function in an AOP arrow, and have pre, post, advice AOP arrow transformers?
09:08:14 <shapr> I think that would work
09:08:35 <shapr> I'd have to try it to be sure.
09:08:37 * TheHunter thinks that aop becomes almost meaningless if you want to keep lazy evaluation
09:09:03 <shapr> you think AOP doesn't preserve semantics in lazy eval?
09:09:17 <tuomov> and do modification notificiations have any meaning either in a functional language?
09:10:31 <shapr> if your AOP Arrow is a pre list, a post list, and a function and the pre-hook arrow transformer adds the function the pre-list, and etc and the advice arrow just empties the list and replaces the function...
09:10:35 <TheHunter> you never know when a particular piece of code gets evaluated. In particular you can hardly reason about what gets evaluated before what, which seems to be a problem, as aop seems a very stateful beast.
09:10:39 <shapr> does that sound like a sane implementation?
09:11:04 <ows> is declarative programming (logic and functional programming) slower, at the runtime, than imperative programming?
09:12:14 <monochrom> No.
09:12:16 <shapr> ows: sometimes, but (in my opinion) mostly because many billions of dollars have been invested into things like efficient C compilers, and not so much into FP and logic.
09:12:22 <tuomov> well, c compilers make faster code than most people would write assembly these days
09:12:23 <shapr> OCaml is FP, and can be faster than C
09:12:30 <shapr> Sisal and FISh can be faster than C
09:12:50 <tuomov> but surely a great guru could make things as fast as possible by writing pure asm
09:13:06 <shapr> problem with writing asm is that you lose abstraction
09:13:19 <tuomov> same with imperative vs. functional
09:13:32 <tuomov> in theory the compiler could make very efficient code
09:13:42 <tuomov> of course, there are some things that don't make sense in fp
09:13:53 <shapr> identity
09:14:13 <shapr> webby: have you been programming long?
09:14:43 <webby> that book is good
09:14:47 <tuomov> shapr: but where do you get those lists?
09:14:59 <webby> its called haskell by simon thompson is anyone doesnt know
09:15:04 <tuomov> those who attach to the arrow must have some way of identifying it
09:15:16 <shapr> tuomov: I'm thinking "pure f" wraps the function in an AOP arrow
09:15:30 <shapr> might be way off, won't know unless I try it.
09:15:47 <tuomov> Eq is not defined for functions, afaik
09:15:48 <shapr> but, I think a slightly modified ParserArrow would do it
09:15:56 <shapr> er, huh?
09:16:09 <ows> well, with assembly (and even c) we have the control to optimize the code, with FP lang we lose that control cause of abstraction level where we are programming..
09:17:00 <Philippa> certainly Haskell doesn't strike me as being at a more abstract level than Java in that (specific) respect
09:17:03 <shapr> ows: you gain speed of programming, speed of change, because you assume the FP lang will do a good job.
09:17:21 <shapr> bye webby....
09:17:21 <ows> we, that's right
09:17:38 <TheHunter> Sorry to be destructive, but what's the point in using arrows for this kind of task? You lose a lot of nice things that make functional programming so great, especially higher-order-functions.
09:17:52 * shapr shrugs
09:18:00 <Philippa> TheHunter: you don't necessarily lose HOFs, you just don't necessarily keep them
09:18:03 <shapr> I was just wondering if arrows could do all the same stuff as AOP.
09:18:17 <ows> we can program quickly... but programs become obselete (when compared with other developed programs with c/asm lang)
09:18:19 <Philippa> granted, if you don't lose them then you really have a monad
09:18:27 <Philippa> ows: they do?
09:18:38 <Philippa> they might be slower, but we're far more able to implement new features (and correctly)
09:18:47 <shapr> tuomov: have you seen the ParserArrow that exports static parse info? I think you can have static info that is a list of pre and post functions
09:19:13 <Philippa> we're also more able to implement features that speed things up (see industrial applications of lazy evaluation)
09:19:17 <shapr> ows: plus, computer time is very much cheaper than programmer time.
09:19:18 * Lor once did an xml parser arrow that exported a dtd.
09:19:25 <shapr> Lor: whoa cool! I wannna see!
09:19:41 <Lor> This was ages ago, when I first learned about arrows.
09:19:58 <tuomov> shapr: what do you mean?
09:20:35 <shapr> ows: let's say programming at 50 euro per hour, and that I can write Haskell programs in half the time of a C program, that run half as fast as the C program...
09:20:40 <tuomov> preprocessing the code?
09:20:46 <ows> well, suppose you want to write a reliable robot to do some tasks in another planet.. are you going to use haskell? or maybe c with some assembly code cause you have more control on robot programming?
09:20:52 <shapr> at what amount of time, does the tradeoff become profitable for a company?
09:21:25 * TheHunter wonders what arrows would be like if you kept higher order functions, but allowed to use different implementation of sums and products within the arrow.
09:21:33 <tuomov> economics.. pfftt.. it's fun1
09:21:41 <Philippa> ows: me? I'd be very, very tempted by Haskell. A second CPU is dirt cheap by comparison.
09:21:43 <tuomov> s/1/!/
09:21:58 <Philippa> hell, NASA've put a LISP-based system into space before
09:22:24 <Philippa> any details you want explicit control over, we can bolt into the IO monad
09:22:53 <Philippa> *that*, for me, is what makes Haskell really powerful - we can have whatever semantics we like underlying it, we can do higher-order reasoning about really messy systems
09:22:54 <shapr> let's say a boring computer is 2500 euro, and a twice as fast computer is 5000 euro. Then if I can save fifty hours of programmer time, I break even, no profit no loss.
09:23:26 <shapr> hello again webby 
09:24:16 <Lor> Hm, I found some old source files, but they're not in a very presentable state.
09:24:27 <ows> well, so what FP need is to have some enterprises to do a lot of work on their compilers, to optimize code...
09:24:48 <shapr> ows: I think we just need some managers to check their financial calculations.
09:24:50 <webby> hi
09:25:06 <shapr> Lor: I'd love to see that xml arrow, it sounds way cool.
09:26:22 <ows> I heard something about a lisp-based kernel.. and about haskell-based kernel?
09:26:25 <shapr> ows: I think it's about the cost of adding hardware, or the cost of adding programmer time.
09:26:32 <shapr> ows: http://www.cse.ogi.edu/~hallgren/House/
09:26:54 <tuomov> the cost of making mistakes
09:26:57 <shapr> right
09:27:01 <shapr> and we all make mistakes
09:27:13 <shapr> so I want to be able to fix my mistakes with the least amount of effort
09:27:15 <Philippa> ows: entire machines've been based on running lisp. The virtual memory and GC systems interacted a lot better than in eg Java
09:27:31 <tuomov> and a language that makes it difficult to make mistakes that are not detected at compile time
09:27:44 <shapr> so for me, the most valuable thing a programming language can have is expressiveness, abstraction, or whatever increases my speed of change.
09:28:02 <Lor> shapr, I put some old files up here: http://www.cs.helsinki.fi/~lealanko/xmlarr/
09:28:53 <Lor> You won't be able to compile or run them very easily, though.
09:28:55 <shapr> Lor: thanks! I just grabbed 'em, I'll check 'em out after I visit the tvttstuga
09:29:45 <tuomov> for me the most valuable thing is being fun :)
09:30:16 <tuomov> low-level and very high-level are fun, anything between is not
09:31:43 <ows> yeah, abstraction, expressiveness, speed of change all are excellent things to us... but you are programming at a very high level, you don't know what some command are doing in hardware, i.e. if you want to manage some hardware(memory, cpu, ...) or kernel information you can deal with that directly with c and assembly, so I question how you know what is going on when you are programming at high abstraction levels?
09:32:16 <Philippa> by having explicit links right the way down to that level
09:32:32 <Philippa> I might be programming at a high level, but I still know what my evaluation model is
09:32:38 <Philippa> just like the C coder knows all about the stack and the heap
09:32:49 <Philippa> as I said, all I need is hooks to the relevant details in the IO monad
09:34:45 <ows> so, if you want to program a driver (to a specif hardware) you use haskell to do that?
09:35:07 <Philippa> if I'm working under House I would
09:35:23 <Philippa> for linux I'd have to look at writing a set of FFI bindings to the relevant calls first
09:35:28 <ows> so, I question why unix community persists to do that with c and asm (historical reasons? I don't think so)
09:35:35 <Philippa> you don't?
09:35:39 <Philippa> gee, where've you been?
09:35:47 <Philippa> if it weren't for historical reasons they'd at least be using C++ by now
09:36:07 <tuomov> C++ is not fun, C is
09:36:32 <Lor> C++ is occasionally fun, too. When it's _your_ c++ and not someone else's, that is. :)
09:36:38 <ows> yeah C++ is trying to link C and java
09:36:46 <kristnjov> java is cool, but slow.
09:37:06 <Lor> ows, that's a novel way of putting it.
09:37:10 <Philippa> C++ is in no way trying to link C and Java - it has no intention of being as hamstringed as Java when it comes to abstractions, for example
09:37:47 <Philippa> C++ is perhaps halfway between C and Haskell though
09:38:13 <Philippa> it lets itself be dominated by the C-style imperative core but grabs as many abstraction features from elsewhere as it can shoehorn within that framework
09:38:18 <Philippa> Haskell's kinda the other way round
09:38:42 <tuomov> and that's exactly why languages there between are not fun
09:38:53 <tuomov> they're very complex
09:38:54 <Philippa> well, not just kinda - it's *the* most fiercely dedicatedly pure language I've worked in
09:39:03 * Philippa nods
09:39:16 <Philippa> I used to like C++, but only until I found I could do enough in Haskell that I didn't need it 99% of the time
09:39:46 * Lor would be content with a C with struct subtyping.
09:40:23 <Philippa> hrmm... I could live with that, but the syntax'd keep making me want to vomit
09:40:25 <ows> And about Polymorphism, Encapsulation and Inheritance of OO prog lang.. is there some efficient manner to deal with that using haskell?
09:40:37 <Lor> Philippa, huh? What's better about C++ syntax?
09:40:39 <Philippa> not in quite the same way generally, but yeah
09:40:55 <Philippa> Lor: constructors in place of explicit field initialisation comes to mind. So do constructors as expressions
09:40:56 <tuomov> c++ makes one vomit, especially the operator abuse
09:41:07 <Philippa> though yeah, the operator overloading mechanism sucks
09:41:24 <Philippa> ows: take a look at type classes, and ruminate hard on them
09:41:32 <Lor> It's not a big deal to write your own functions that return new objects.
09:41:37 <Philippa> inheritance itself is fairly hard to implement, but interface subtyping's a piece of piss
09:41:42 <Philippa> it's still a PITA
09:42:10 <Philippa> admittedly I have an almost pathologically low tolerance of boilerplate code...
09:42:19 <Lor> I'd like C++ a lot more if it didn't force the implementation of a class to be declared in a public header.
09:42:36 <ows> Philippa: just curiosity, but you like AI topics (r you a researcher?)
09:42:43 <Lor> Even in C you can create abstract data types by just giving a forward declaration in the header.
09:43:38 <tuomov> but yeah, subtyping would help C a lot
09:43:52 <tuomov> would remove quite a few unsafe casts from Ion source..
09:44:46 <Lor> Enum subtyping might occasionally be useful, too.
09:45:02 <tuomov> I seldom use enums
09:45:08 <Lor> Huh?
09:45:09 <Philippa> ows: I've done a little bit of undergrad level stuff, but AI's not something I'm big on per se (the NASA example I mentioned was given in an intelligent agents course I showed up to). I'm doing an amount of personal research into other stuff though, and I at least think about AI once in a while from a gamedev POV
09:45:25 <Lor> How can one use C without using enums?
09:45:26 <tuomov> for some reson I often just #define 
09:45:30 <Lor> Eeekk.
09:45:34 <Lor> That's ugly. 
09:46:00 <Lor> Enums allow you to use types more expressively, and they are also more debugger-friendly.
09:46:03 <bourbaki> http://paste.phpfi.com/32807
09:46:24 <bourbaki> i want to build a neural network with these operations but i have a small problemn
09:47:04 <bourbaki> i need something like the cartesian product of the codomain of all the (**) glued functions any idea?
09:47:54 <bourbaki> ie you have one input node and 3 outputs would look like
09:48:10 <bourbaki> w1 ** w2 ** w3 , where w are weightening functions
09:48:31 <bourbaki> and if i have a second input node it would look like
09:48:50 <Philippa> is the difficulty in the transform or in the type?
09:48:57 <bourbaki> (w11 ** w12 ** w13) x (w21 ** w22 ** w23)
09:49:08 <Philippa> (I'm being a bit braindead and I'm not having a good day, might take me a while to grasp the problem fully...)
09:49:10 <bourbaki> in the transform and type
09:49:30 <Philippa> x is mul in that line?
09:49:51 <bourbaki> x is cartesian product
09:50:00 <Philippa> 'k (see, said I'm braindead!)
09:50:18 <bourbaki> (w11 ** w12 ** w13) x (w21 ** w22 ** w23) = (w11 x w21, w12 x w22, w13 x w23)
09:50:42 <Philippa> so you return a trio of pairs, in effect
09:50:47 <bourbaki> if i can get something like that i can build single layered networks
09:51:23 <bourbaki> yes but i want it to have it work for arbitrary many elements
09:51:27 * Philippa is sometimes tempted to describe arrows as "revenge of the cons"
09:51:43 <Philippa> effectively list-of-lists then
09:51:49 <bourbaki> that is if i add another output node there were 4 elements
09:51:51 <bourbaki> yes
09:51:55 * shapr boings
09:51:56 <Lor> It would be nice to get a sensible generalization of tuples.
09:52:04 <Philippa> Lor: cons! :-)
09:52:06 <ows> What lang is better in your point of view: Lisp or Haskell (to FP)?
09:52:08 <bourbaki> i think i need something like that then
09:52:22 <shapr> ows: why don't you download House and run it on QEmu, or you could just write it to a floppy and boot it on nearby x86 hardware.
09:52:23 <bourbaki> so i need to crank on the type of the functions
09:52:35 <Philippa> I've not written any real amount of lisp, it simply doesn't appeal to me (I'm big on static typing)
09:52:59 <tuomov> lots of incomprehensible silly parentheses
09:53:08 <tuomov> that's my opinion of it :)
09:53:08 <bourbaki> hehe
09:53:15 <bourbaki> i like the parenthes :)
09:53:36 <Philippa> weirdo :-)
09:53:43 <shapr> Lisp is a bit procedural, a bit functional. You might like it. I plan on trying Common Lisp once I've recovered from the fanaticism of its users.
09:53:44 <bourbaki> :)
09:54:13 <Philippa> shapr: makes sense. What I've seen suggests I'd find it a bit too... bulky? for my tastes, hopefully YMWV
09:54:29 <bourbaki> lisp can be fun cause you have that funky eval
09:54:34 <shapr> I like the totally regular syntax, and unhygienec macros look like fun.
09:54:43 <shapr> Common Lisp sounds monstrous from what I've heard.
09:54:49 <bourbaki> ive written a downloader where you download code from the internet that gets interpreted :)
09:55:22 <Philippa> yeah, I'm looking forward to playing with hs-plugins for related reasons
09:55:33 <shapr> hs-plugins is cool
09:55:36 <tuomov> yes, in a way the syntax is cool.. but it's just not usable
09:55:36 <Philippa> though one thing I like about hs-plugins is the potential to very, very tightly control what the code you're handed can do
09:55:55 <Philippa> you want a restricted set of IO operations? Build a subset-of-IO monad, problem solved
09:56:08 <bourbaki> you all should watch these funny 80'ies sicp lessons from ableson and sussman
09:56:08 <Philippa> tuomov: bingo :-)
09:56:57 <shapr> I got into Haskell because I started writing Python code with no side-effects, and a single return point.
09:57:07 <shapr> and I realized that could go a lot further, but I didn't know where.
09:57:29 <shapr> now I know!
09:57:33 <shapr> and it's coool!
09:57:50 <ows> and if you want to exchange data in the web? what are you going to use? xml, rdf?
09:58:02 <shapr> sure, Haskell has HaXML for example
09:58:19 <Lor> s-expressions! :)
09:58:24 <shapr> it can turn a DTD into Haskell datatypes
09:58:48 <shapr> with HaXML, you can ensure that tags that shouldn't be nested, aren't nested
09:59:11 <shapr> sometimes that's too restrictive for me, so I use HXmlToolbox as well
09:59:36 <shapr> I've used the Haskell XmlRpc lib to unit test Zope stuff I've written.
09:59:55 <shapr> there's a haskell web server that has an apache-style plugin interface.
10:00:00 <shapr> lambdabot is written in Haskell
10:00:01 <shapr> @yow !
10:00:01 <lambdabot> This is my WILLIAM BENDIX memorial CORNER where I worship William
10:00:01 <lambdabot>  Bendix like a GOD!!
10:00:24 <shapr> ows: I think the greatest barrier to Haskell use is that codemonkeys will have trouble using it.
10:00:48 <bourbaki> hm when i traverse the net from the output to the input i can do what i want
10:01:36 <shapr> tuomov: did you get what I was saying about the AOP arrow with pre and post lists of functions?
10:01:38 <programmer> apoligies if this is off topic, but does anyone know a site where you are able to hire Haskell programmers
10:01:46 <tuomov> it needs a new way of thinking, and regular code monkeys are only taught c++ these days on engineer assembly lines
10:01:56 <shapr> programmer: hiya webby, back again?
10:02:13 <tuomov> shapr: no
10:02:18 <shapr> programmer: what sort of job is it?
10:02:37 <musasabi> evening
10:02:48 <shapr> hei musasabi, hyv ihltaa
10:03:19 <shapr> whoops iltaa
10:03:37 <programmer> shapr it is a small task I havent got the full details yet but it is going to be fairly basic something like arranging words etc, its needs to be done so it can be placed on an intranet site
10:04:12 <programmer> i meant to say the program created will appear on the intranet showing what haskell can do 
10:04:13 <musasabi> programmer: http://haskell.org/jobs.html and I sometimes it is ok (if it is haskell related) to post on the ML, but I would ask the admins first.
10:04:20 <shapr> arranging words? that sounds like homework.
10:04:24 <tuomov> yeah
10:04:58 <programmer> ha ha never knew haskell was even taught at school, no it isnt homework 
10:05:40 <shapr> It would be unethical for us to do homework for you. But I could direct you to some Haskell tutorials.
10:06:02 <musasabi> god kvll shapr
10:06:15 <bourbaki> is there  a graphviz <-> graph tool for haskell?
10:06:17 <programmer> its ok
10:06:30 <programmer> it isnt homework 
10:06:44 <shapr> ok, what sort of task is it?
10:07:11 <programmer> i am just a java programmer that doesnt know the full capabilities of haskell and therefore want to demostrate it 
10:07:31 <shapr> in that case, I'd recommend something like http://www.haskell.org/complex/why_does_haskell_matter.html
10:07:31 <musasabi> bourbaki: Why not use graphviz ? Isn't that quite straightforward?
10:07:34 <programmer> shapr it is still under development i have not got the full details 
10:07:42 <tuomov> shouldn't you learn it so you can better demonstrate it?
10:08:04 <programmer> no, ask i will not be programming it 
10:08:12 <bourbaki> musasabi: i want to edit graphs in graphviz and export the graphs to my haskell app to interpret them
10:08:26 <programmer> they will outsource hence me looking for a site to hire out programmers
10:09:24 <musasabi> bourbaki: isn't graphviz more or like "draw graph from a text file describing it" ?
10:09:54 <bourbaki> musasabi: yes but there is also an editor for it
10:10:02 <shapr> programmer: In that case, there are several people here who will write code for money, and you can post on the haskell mailing list as well.
10:10:18 <bourbaki> musasabi: id like to have my own editor but i suck at app codeing :)
10:10:19 <musasabi> bourbaki: if it exports the dot format then that should be quite easy to parse.
10:10:50 <programmer> shapr mailing list is it possible if you could tell me the mailing list - is this mailing this which you have set up 
10:10:50 <musasabi> also there is libgraph (part of graphviz), but I don't know how clean the interface is.
10:11:36 <sorje> programmer, http://haskell.org/mailinglist.html
10:12:18 <programmer> thanks sorje 
10:12:31 <programmer> are most of you members of the haskell mailing list 
10:13:49 <musasabi> yes, but there are many more people on the lists.
10:16:10 <shapr> programmer: could you tell us more about this job?
10:26:53 <shapr> whew
10:26:56 <shapr> he's gone.
10:27:22 <shapr> so, how many of you got private messages from him, where he was trying to pay you to do his homework for him?
10:29:16 <Lor> I got one, but he never got so far as to say what he wanted.
10:30:23 <Philippa> I got one, once I told him "no" he asked if I'd explain why... I said "no" again
10:30:39 <ibid> i got some
10:30:47 <shapr> I've seen irc channels that have *.aol.com banned... 
10:30:56 <Philippa> he got lucky, today is not a good day to mess me around
10:30:58 <Philippa> heh
10:31:00 <Philippa> yeah, seen that
10:31:07 <Lor> It's still september...
10:31:13 <tuomov> I got some. I told him I'm not interested until I know more about it, and then he started asking if I'll be around towards the end of the week etc.
10:31:18 <sorje> shapr, oh, I got one, too.
10:31:23 <shapr> tuomov: he asked me that too
10:31:50 <ibid> hmm
10:32:00 <ibid> i'm not sure that it's the same guy though
10:32:06 * ibid checks his logs
10:32:37 <shapr> programmer and webby were both webb@*.ipt.aol.com
10:32:59 <shapr> ACBE59DE and ACB95402
10:33:19 <shapr> it's more fun to talk about AOP...
10:33:53 <ibid> ok. different guy then
10:33:59 <ibid> but similar behaviour
10:34:10 <ibid> different nick too
10:34:17 <shapr> I think programmer and webby were the same guy.
10:34:24 <ibid> no, this one was not either
10:34:42 <shapr> oh, you get more than I do
10:35:06 <ibid> this was around 15th last month
10:35:40 <tuomov> both had 'guggggfgf' as ircname, I think
10:35:44 <shapr> yup
10:36:04 <shapr> tuomov: what do you use hs-plugins for in riot?
10:36:14 <ibid> anybody remember Michael`? :)
10:36:22 <shapr> oh yeah
10:36:26 <ibid> that's the one
10:36:29 <shapr> you remember joey_ ?
10:36:33 <ibid> no
10:36:59 <tuomov> there's nothing fully working yet, but eventually it might be possible to load Config.hs with it
10:37:07 <shapr> oh cool
10:37:41 <tuomov> there's just some ugliness with things being loaded twice..
10:37:45 <shapr> ?
10:37:51 <shapr> static and dynamic?
10:37:56 <tuomov> yes
10:38:13 <shapr> yah, I wondered about an 'hs-plugins core'
10:38:31 <shapr> where the entire app is loaded via hs-plugins, and none of it is static.
10:38:54 <tuomov> yeah, I'll probably have to write such a stub loader if I go ahead with this
10:38:55 <CLxyz> Hrm, anyone code on a laptop?
10:40:22 <shapr> I'd like to try that hs-plugins core for a haskell editor with elisp-quality dynloading
10:41:56 <shapr> CLxyz: whyfor?
10:43:02 <shapr> ows: so, anymore questions?
10:46:10 <CLxyz> shapr: i'm looking to buy 1?
10:46:25 <shapr> oh, good reason.
10:46:33 <shapr> I'd like to hear about that too
10:47:04 <shapr> for me, I want a big comfy keyboard, screen and CPU are not so important
10:47:20 <CLxyz> bat llife
10:47:24 <shapr> oh good point
10:47:38 <shapr> keyboard and battery life are important.
10:47:50 <shapr> anything else?
10:47:53 <tuomov> heat production
10:48:07 <tuomov> you don't want it burning through your pants
10:48:11 <shapr> heh, right
10:48:38 <CLxyz> the heats implicit in bat life no?
10:48:41 <tuomov> at least I'd primarily use a laptop for coding sitting on a sofa
10:49:05 <tuomov> my ancient 486 laptop has zero bat life :)
10:49:08 <CLxyz> 3 hours on bus/train/daily
10:49:10 <shapr> I'd use my laptop to code outside, away from civilization.
10:49:49 <shapr> cool, 184 IOHCC results views
10:56:59 <shapr> I wish for collaborative editing, pair programming on IRC
11:04:01 <musasabi> shapr: url ?
11:06:22 <shapr> http://www.scannedinavian.org/iohcc/succzeroth-2004/
11:06:28 <shapr> musasabi: you mean IOHCC results, right?
11:07:58 <shapr> hej Marvin-- 
11:10:00 <Marvin--> evenin'
11:13:22 <shapr> how's code?
11:16:07 <musasabi> yes
11:16:14 <musasabi> thanks.
11:16:48 <Marvin--> not much code to report
11:17:50 <musasabi> btw anyone know a key-value cache wich supports different keep-alive policies in haskell?
11:19:40 <shapr> that sounds handy, I've seen discussion of that in some memoizing threads on the mailing lists, dunno if there was ever any code though.
11:21:57 <ows> http://hopl.murdoch.edu.au/keyset.html -> I think that could be great to analyse this site :)
11:23:17 <ows> What do you think about that?
11:24:16 <musasabi> Data.HashTable seems extremely unsuitable :-(
11:24:56 <musasabi> as there is not even an easy way to fold over it :-(
11:27:50 <shapr> ows: that's cool
11:29:54 <ows> We was talking about functional and algorithmic languages... and about reflexive languages?
11:30:03 <shapr> never heard of 'em
11:30:12 <shapr> what does it mean?
11:30:22 <ows> But there are a lot.. you can see that
11:31:55 <ows> The picture it's a little complex.. What you catch from that?
11:32:03 <Lor> I'd say reflection is a feature, not a paradigm.
11:32:29 <shapr> oh, reflection
11:33:32 <ows> people in this channel is mainly nordic? :)
11:33:59 <shapr> I'm from the southeast of the USA.
11:34:53 <ows> don't you are swedish?
11:35:15 <shapr> nope, I'm a US Citizen. But I live in Sweden.
11:35:29 <Philippa> Lor: I'd say it's a bug not a feature, but to each their own ;-)
11:36:04 <ows> so, why there are a lot of researching in reflexive lang topic?
11:36:36 <Philippa> like I said, to each their own. Certainly introspective features are a good thing, I'd rather static introspection and good abstractions to build reflection-like systems if need be though
11:45:42 <Lor> Reflection just has to be designed so that it doesn't break abstractions, or only does so in a controlled way.
11:46:34 <Philippa> Yeah, fair enough. I'm being a bit bitchy today, 'sall
11:46:35 <shapr> oy, common lisp user on #java
11:46:47 <Philippa> comedy alert? :-)
11:47:12 <shapr> I mentioned Haskell, and he said "<slava> shapr, haskell is dusty academic junk"
11:47:57 <Philippa> ah, just a fuckwit then :-)
11:49:47 <esap> uhuh, one of the winning IOHCC entries uses compiler-specific kludges, uhuh.
11:54:44 <Lor> The entire submission is one big compiler-specific kludge. :)
11:54:56 <shapr> yah, it's sexy
11:54:59 <Lor> (There's no 6.3 in debian yet, so I can't test it)
11:55:04 <shapr> Lor: there is! ghc-cvs
11:55:27 <Lor> Ah.
11:57:57 <esap> that doesn't yet contain the generalized ADT extension though?
11:58:18 * esap is waiting for 6.4 in debian :-)
11:58:18 <shapr> nope, not yet
11:59:03 <esap> because that extension seems genuinely useful.
12:00:11 * esap expects it to simplify my compiler.
12:01:47 <Lor> generalized adt:s are the coq-like dependent inductive datatypes?
12:02:11 <esap> they let you declare a return type for constructors.
12:02:27 <Lor> I take that to be a yes.
12:02:53 * esap hasn't actually used coq-like dependent inductive datatypes a lot, so I don't know about that.
12:02:54 <Lor> Earlier it has been possible to simulate those by using an equality representation.
12:03:20 <Lor> Like in Baars and Swierstra's dynamics paper.
12:04:21 <Marvin--> gadts will rock
12:10:16 <esap> The syntax is very uniform as well, it's obvious after the extension that type classes and data declarations are dual.
12:10:46 * Marvin-- groans
12:10:54 * esap laughs
12:10:57 <Marvin--> he said the "d" word
12:11:26 * esap wonders whether functional dependencies will have some corresponding feature as well....
12:16:00 <shapr> hiya toomasr 
12:16:07 <toomasr> hi shammah 
12:16:10 <shapr> looking for Haskell info?
12:16:10 <toomasr> *shapr
12:16:14 <toomasr> nope, some help
12:16:21 <shapr> what can we do for you?
12:17:03 <toomasr> trying to write a function, filterNext, its like [x | x <- list, test x], but the test has to run on the element following the x, but i can't figure out how to doit
12:18:27 <Lemmih> @type tail
12:18:28 <lambdabot> tail :: forall a. [a] -> [a]
12:21:14 <toomasr> running forall through google produced interesting results
12:22:20 <Marvin--> toomasr: I think the main problem is what your intention is for the corner cases
12:24:19 <toomasr> well, if should skip comparing n and n+1
12:25:03 <toomasr> i've been reading all kinds of materials on haskell, and it seems to be the hardest language i've ever come by
12:26:17 <Lemmih> Never used a functional language before?
12:26:53 <toomasr> had a lisp course, thats it
12:27:33 <Lor> Haskell is easy. It's just hard to realize how easy it is.
12:27:56 <toomasr> today i was thinking that i'll just debug by printing some values out, but i couldn't define a functions who's return value is (void)
12:28:31 <Lemmih> Heh. Debug.Trace.trace migth help a little.
12:28:35 <kosmikus> shapr: you there?
12:28:37 <toomasr> but the constructs are so out-of-this-world
12:28:39 <Lemmih> @type Debug.Trace.trace
12:28:41 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
12:29:29 <toomasr> oh, now i understand, the forall wasn't what i needed, but i was suggested to use tail
12:29:59 <toomasr> oh, i can just take (head.tail)
12:30:42 <Lor> Or just (list !! 1)
12:31:48 <toomasr> as my tests show, you're correct :)
12:33:04 <toomasr> but i was really amazed in one of the lectures, when i was told about list comprehension, it was really cool
12:33:34 <toomasr> but looking at certain *sample* programs it gets on my nerves that everything is written just in couple of lines :)
12:34:02 <esap> Look at standard prelude. Almost everything is just a couple of lines.
12:35:24 <esap> And that's real code, not examples.
12:39:12 <toomasr> yeah, i did that last week this why i left my assignment to the last minute :)
12:40:10 <toomasr> what was the command i prelude, so that it would show the number of reductions/actions of a expression?
12:41:10 <toomasr> probably expression is not the right word, maybe evaluation...
12:42:06 <esap> :set +s  I suppose you mean in ghci?
12:42:53 <esap> or hmm.. I haven't actually used that, it only prints time in seconds :-)
12:45:20 <toomasr> (head.tail) [1,2,3,4] shows 25reductions, 64 cells and ([1,2,3,4] !! 1) is 50reductions and 64 cells
12:45:35 <toomasr> sry, head.tail one is 33 cells
12:45:51 <toomasr> so the !! n, seems to double the reductions and cells
12:47:00 <esap> ah, you're using hugs, in ghci :set +s shows time in seconds.
12:48:49 <kosmikus> toomasr: it's more like a constant overhead, comparing the two approaches on larger lists should give a less dramatic difference
12:49:14 <toomasr> kosmikus: ok
12:51:11 <kosmikus> toomasr: no, ignore me, the operation should not really depend on the length of the list anyway ...
12:53:45 <shapr> kosmikus: you screamt?
12:54:14 <shapr> kosmikus: what can I do for you?
12:54:35 * shapr suspects HC&AR related matters.
12:55:01 <kosmikus> shapr: that, too
12:55:08 <kosmikus> how do you log this channel?
12:55:09 <shapr> oh wait, maybe it's that epigram mailing list post...
12:55:16 <shapr> I don't, clog does
12:55:24 <kosmikus> how does it work?
12:55:35 <shapr> nef showed up one day and asked if he could log the channel
12:55:46 <shapr> he's part of the tunes.org project
12:56:31 <shapr> which channel do you want logged?
12:56:35 <shapr> #epigram?
12:58:29 <kosmikus> no, #latex
12:58:49 <shapr> oh
12:59:09 <shapr> not sure nef would go for that, since tunes.org is prog-lang specific
12:59:35 <kosmikus> well, anyone wants to argue LaTeX is not a programming language?
12:59:49 * shapr grins
13:00:18 <kosmikus> I certainly would be much less interested in it if it weren't
13:00:28 <shapr> ok, check out meme:  http://meme.b9.com/
13:00:46 <kosmikus> just found the page as well
13:00:53 <kosmikus> haven't found a contact address yet, though
13:01:01 <shapr> I don't see one either.
13:10:47 <toomasr> missions accomplished, filterNext is ready and tested :)
13:10:50 <toomasr> *mission
13:10:52 <shapr> yay
13:11:00 <Lemmih> hurrah
13:11:31 <toomasr> yeah :)
13:11:50 <dblhelix> kosmikus: before I forget: did johanj mentioned that we're supposed to meet earlier than normal, tomorrow?
13:11:59 <dblhelix> /s/mentioned/mention
13:12:10 <kristnjov> isn't it s/mentioned/mention/?
13:12:48 <shapr> yes, but I decided I won't complain about someone second language until my second language is better than theirs.
13:12:58 <shapr> och jag har ingen aning om hollandska!
13:13:00 <toomasr> i tried the hugs' observe thingy, but it was a bit complicated, can i somehow use the the trace utility after i load my file in hugs and start to invoke my functions? like trace myfunc 1 2, and it'll show the recursion tree...
13:14:34 <kosmikus> dblhelix: I don't remember, sorry
13:14:50 <kosmikus> I can ask him tomorrow morning, if I recall it then, and tell you online
13:14:54 <Lemmih> toomasr: That's not how Debug.Trace.trace works.
13:16:02 <toomasr> oh, okay, i'll then just look into it, i thought maybe there is a simple way
13:16:24 <dblhelix> kosmikus: I'm pretty sure it was in the afternoon, so I guess that's okay ... thanks
13:18:09 <dblhelix> shapr: complaining about my English is appreciated, so please do ... if you want to, I will comment on your Dutch ;)
13:18:14 <shapr> haha
13:19:16 <shapr> you don't have enough time to give full appreciation of my lack of dutch =)
13:20:08 <dblhelix> :)
13:26:31 <toomasr> okay, next one done
13:26:34 <toomasr> and here haskell already pwned
13:26:57 <toomasr> i'll just copy 2 lines
13:26:59 <toomasr> flatZip (l1:l1s) (l2:l2s) = l1:l2:flatZip l1s l2s
13:26:59 <toomasr> flatZip [] (x:xs) = x:flatZip [] xs
13:27:30 <toomasr> so it means, that the if the recursion in the flatZip finds a case of flatZip [] list, it'll use the other declaration!
13:27:38 <toomasr> damn, this is cool
13:28:27 <Marvin--> well, it's not much to be excited about ;) even though it's two lines, it's part of the same function definition
13:28:46 <Lemmih> Wouldn't 'flatZip [1] []' fail?
13:29:01 <sorje> It may only be syntax, but it rocks. ;-)
13:32:47 <toomasr> Lemmih: i didn't want to copy 3 lines, somebody would have told me to use the pastebin :)
13:33:37 <toomasr> it's like a new type of a if construct, it automatically tests the length of the input lists
13:33:41 <toomasr> i'm excited
13:35:28 <shapr> me too!
13:38:38 <toomasr> but is there a "rotate" like function, like rotate 2 [1,2,3] => [3,1,2]?
13:39:07 <Lor> No, but you can write one.
13:39:16 <toomasr> aye
13:39:30 <Lemmih> rotate n = drop n . cycle
13:40:05 <Lemmih> Eh d'oh
13:40:06 <Lor> Or you could just be boring and use take and drop.
13:40:48 <toomasr> i'll just check take and drop and cycle
13:51:04 <Boegel> hellow everyone :)
13:56:10 <Lemmih> Hello Boegel
13:57:58 <Boegel> I'm finally putting my ray casting algorithm in Haskell
13:58:06 <Boegel> and I'm noticing my Haskell is a bit rusty :s
13:58:30 <Lemmih> Got it online somewhere?
14:02:24 <Boegel> what ? the ray casting algorithm ?
14:04:24 <Boegel> Lemmih, the ray casting algorithm ?
14:08:13 <Boegel> shapr,you there ?
14:12:27 <Lemmih> Boegel: Yes.
14:12:54 <toomasr> now, rotations is done, meaning everything done
14:13:02 <toomasr> i had to use genericDrop/Take though
14:13:21 <toomasr> all who helped me thanks a lot :), cya before the exam :p
14:14:15 <Lemmih> genericDrop?
14:14:16 <Boegel> Lemmih: http://studwww.ugent.be/~kehoste/FunMath/rayCasting.pdf
14:14:32 <Boegel> Lemmih: do you speak Dutch ? because the explanation of the functions is in Dutch
14:14:43 <Boegel> although the function name should explain a lot
14:14:53 <Boegel> it's not 100% ok yet, but the big lines should be
14:15:35 <Boegel> Lemmih, tell me what you think, okay ?
14:16:09 <Lemmih> I don't understand dutch.
14:17:27 <Boegel> okay, but the functions should explain a lot :p
14:17:43 <Boegel> it's just a small explenation what the function (should) do(es)
14:24:09 <Boegel> I would like to make a type constructor for a color type
14:24:24 <Boegel> it should consist out of a tuple with 3 Int values
14:24:35 <Boegel> but they should be >=0 and <256
14:24:45 <Boegel> can I restrict this in the type constructor ?
14:26:17 <stepcut> Boegel: no
14:26:36 <stepcut> Boegel: well, you could use Word8 though..
14:27:10 <stepcut> since Word8 happens to have that limited range
14:27:53 <Boegel> stepcut, there's no way to restrict it ?
14:27:57 <Boegel> and is Word8 ?
14:28:03 <Boegel> <insert> what
14:29:56 <Boegel> Lemmih, how do you like it ?
14:31:38 <Lemmih> I gave up. I don't have the energy to understand foreign code without comments.
14:32:40 <stepcut> Word8 is just an 8-bit unsigned number
14:32:45 <stepcut> Data.Word
14:32:55 <Boegel> heh
14:33:10 <Boegel> Lemmih: but what do you think about the FunMath system it's written in
14:33:22 <Boegel> stepcut, I'll rather use Int
14:33:30 <Boegel> i'll figure it out how to limit the range
14:33:49 <stepcut> Boegel: you can not limit the range at compile time with Int, you could do it at runtime though
14:33:51 <kosmikus> you can't limit the range of a datatype in Haskell
14:35:33 <Boegel> not even with a where or something like that ?
14:36:11 <kosmikus> no
14:37:27 <kosmikus> such a feature would very likely make typechecking undecidable, if not implemented with extreme care
14:37:38 <Boegel> that's a shame...
14:40:02 <stepcut> Boegel: you might be able to do that in epigram... but epigram is still quite experimental
14:42:17 <Boegel> no, I have to use Haskell
14:42:42 <Boegel> maybe I can make a function that checks the values for me, when I want a color...
14:42:56 <Boegel> and returns Nothing when the check fails...
14:44:41 <dons> tuomov: ping!
14:45:19 <dons> or is it a bit late in .fi?
14:46:45 <ibid> bit late, yes
14:46:52 <ibid> approaching 1 am
14:46:55 <ibid> i should be in bed too
14:48:30 <vegai> holy cr...!
14:48:30 <kosmikus> stepcut: theoretically, yes, but epigram does not even have something like builtin integers yet
14:49:11 <shapr> Boegel: y0
14:49:26 * vegai_ boggles.
14:49:39 <vegai_> Freenode doesn't like my epic
14:50:58 <Boegel> shapr, I thought my friend was coming here for a quick tour, but apparently he's not :s
14:51:14 <shapr> Boegel: no worries, we stay open at all hours.
14:51:14 <dons> is there such a thing as remote ssh access to a windows machine?
14:51:23 <shapr> dons: sure, install linux
14:51:39 <shapr> dons: but seriously, what about vnc?
14:51:44 <Igloo> Terminal services might be similar
14:51:49 <dons> of course, I know that. but some people apparently need to run hs-plugins on windows..
14:51:53 <Igloo> But I've never used it
14:52:01 <dons> and it is so slow hacking for an os I've never used
14:52:11 <shapr> you've never used windows??
14:52:18 <shapr> dons: YOU'RE SO LUCKY!
14:52:24 * shapr is jealous
14:52:55 <dons> MacOS 7.1 -> Debian 2.0 -> FreeBSD -> OpenBSD :)
14:53:08 <ibid> vegai: why "holy cr..."?:)
14:53:25 <shapr> I used MacOS 1... when it was new.
14:53:48 <Boegel> I'm having problems with enumerated sets in Haskell (Hugs)
14:53:48 <dons> MacOS 1 (<1984?)
14:53:54 <Boegel> damn, my Haskell really is rusty :s
14:54:16 <dons> wolfgang thaller was scaring me with an idea to port ghc to System 7 :)
14:54:23 <shapr> haha
14:54:27 <shapr> *why* ??
14:54:40 <dons> why not! there's an AIX port
14:54:41 <Boegel> what's the url to the wiki again where I can put things so you guys can tell me what I'm doing wrong ?
14:54:44 <shapr> did you know that the filing system in MacOS 1 had no support for directories?
14:54:53 <dons> hmm...
14:54:59 <shapr> directories were in fact regular files, it was faked.
14:55:08 <dons> ah! tricksy
14:55:24 <shapr> you couldn't have more than 512 files total on a disk (floppy being the only support disks)
14:55:32 <Boegel> shapr: what's the url to the wiki ?
14:55:40 <shapr> @wiki
14:55:45 <lambdabot> http://www.haskell.org/hawiki/
14:55:48 <Boegel> ow :$
14:55:52 <dons> so there is some consensus that there may be a way to get a shell up on a windows box?
14:55:52 <shapr> man, lambdabot is slow today.
14:55:56 <Boegel> damn :s
14:55:59 <Boegel> what's wrong with me :)
14:56:15 <Boegel> yeah, a virus engine :)
14:56:20 <Boegel> good work Bill :|
14:56:28 <TheHunter> @wiki HaskellIrcPastePage
14:56:28 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:56:32 <dons> i just have to convince some hapless windows person to install ghc, then
14:57:19 <dons> hmm. maybe there is some vnc system at uni
14:57:43 <Boegel> that's what I needed TheHunter ! thanks
14:58:50 <Boegel> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
14:58:52 <dons> I am *so* going to hack riot into haskell-mutt...
14:59:05 * dons thinks world domination is close
14:59:20 <Boegel> that code gives "ERROR "F:/THESIS/Haskell/rayCasting.hs":78 - Repeated definition for constructor
14:59:20 <Boegel>  function "Sphere1"
14:59:21 * shapr grins
14:59:23 <Boegel> woops :s
15:00:00 <Boegel> I don't repeat the Sphere1 constructor, do I ?
15:00:15 <shapr> sounds like it
15:00:26 <Marvin--> Boegel: uh, yes you do
15:00:36 <Marvin--> both Object and Sphere1 have Sphere1 constructors
15:00:45 <Marvin--> and boh Object and Sphere2 have Sphere2 constructors
15:00:53 <Boegel> ow, like that
15:01:03 <Boegel> but you get what i want to do, right ?
15:01:20 <Boegel> (using Sphere1 and Sphere2 is just an example)
15:01:21 <Marvin--> you probably want to do  data Object = Sphere1 { ... } | Sphere2 { ... }
15:01:59 <Boegel> ow, okay :)
15:02:11 <Boegel> it nicer my way, but it doesn't work :p
15:03:54 <Boegel> thank you Marvin-- !
15:10:38 <Marvin--> my work here is done! (I'm off to bed)
15:14:45 <Boegel> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
15:14:50 <Boegel> another (stranger) problem
15:15:11 <Boegel> error: Repeated definition for selector "direction"
15:15:40 <Boegel> why doens't 'radius', or even 'place' cause a problem
15:15:47 <Boegel> and 'direction' does ?
15:15:47 <Boegel> :s
15:16:15 <Lemmih> 'place' will cause an error if you fix 'direction'.
15:16:24 <Boegel> oh, it's backwards...
15:16:42 <Lemmih> 'radius' is different since it's in the same data type.
15:16:48 <Boegel> damned :s
15:17:02 <Boegel> so I should call it diffrently for every data type ? :s
15:17:16 <Lemmih> Yes.
15:17:50 <Boegel> oh, I see why
15:17:56 <Lemmih> You can use type classes to get a common interface.
15:18:00 <Boegel> because 'direction' is seen as a function...
15:18:18 <Boegel> type classes... let's look that up :)
15:20:12 <Lemmih> Named fields in data constructures just allows Haskell to generate functions which isolates the correct data.
15:20:36 <Boegel> my book (Haskell school of expression) has a piece on type classes, but I don't see the link
15:22:28 <Boegel> you mean something like this ?
15:22:45 <Lemmih> class WithRadius a where getRadius :: a -> Vector
15:23:39 <Boegel> and how do I specify which data types are in that class ?
15:23:51 <shapr> bonjour Lunar^ 
15:23:53 <Boegel> WithRadius = Sphere | Light
15:23:57 <Boegel> something like that ?
15:24:10 <Lemmih> No. You can make data types instances of the class.
15:24:57 <Boegel> instance WithRadius Sphere where getRadius s = ?
15:25:20 <Lemmih> instance WithRadius Light where getRadius = lightRadius
15:25:42 <Boegel> and then
15:26:08 <Boegel> getRadius light1 = 'the radius for light1'
15:26:09 <Boegel> right ?
15:26:41 <Lemmih> Yeah. I just used a point-free style of code.
15:27:11 <Boegel> but still I need to give the various attributes different names...
15:27:17 <Boegel> that doesn't solve anything, does it :p
15:27:48 <Lemmih> It allows you to write [getRadius myLight, getRadius mySphere].
15:28:16 <Boegel> true
15:28:32 <Lemmih> Isn't that why you wanna give all of them the same name?
15:28:35 <Boegel> but i could do that with [sphereRadius, lightRadius], or not ?
15:29:38 <Boegel> yeah, probably :)
15:29:38 <Boegel> you're right I guess :)
15:29:38 <Boegel> but I feel that's kinda like a workaround...
15:29:38 <Boegel> not being able to set restrictions to a type, now this...
15:29:48 <Boegel> I know, it's me who uses the features wrong I guess
15:33:27 <Lemmih> You can't generate two functions with the same name and different types.
15:33:29 <Lemmih> You have to give the functions different names or use type classes.
15:35:03 <Lemmih> Wow. I just got a ping reply on 79 seconds from myself.
15:35:17 <shapr> neat!
15:40:27 <Boegel> does emacs support 'hiding' bits of code ?
15:40:33 <shapr> yes it does!
15:40:38 * shapr gets out an eraser
15:40:49 <Boegel> like you can hide the content of a directory by clicking the +
15:40:56 <shapr> oh ,sure
15:41:01 <shapr> you can narrow-to-region
15:41:06 <shapr> or you can use um...
15:41:54 <Boegel> how to I use narrow-to-region ?
15:42:16 <Boegel> 'cause scrolling in my code is beginning to irritate me
15:42:21 <Boegel> and I've just started :p
15:42:38 <shapr> there's another one I'm trying to remember
15:43:02 <shapr> well, select a region
15:43:13 <shapr> and hit C-x n n
15:44:48 <Boegel> nice shapr :)
15:46:39 <Boegel> how do I define a function where the definition of the function depends on the type of one of the arguments ?
15:46:51 <Boegel> intersect :: Ray -> Object -> Intersection
15:47:05 <Boegel> the definition of intersect depends on the type of Object
15:47:17 <Boegel> something with @ ?
15:48:31 <Lemmih> intersect ray (Sphere blah blah) = ...
15:49:15 <Boegel> hmmz
15:49:22 <Boegel> that's not quite what I mean...
15:49:33 <Boegel> Ihave to be able to pass the sphere to another function...
15:49:44 <Boegel> http://studwww.ugent.be/~kehoste/FunMath/rayCasting.pdf
15:50:03 <Boegel> check the definition of 'intersect' on page 2
15:50:11 <Boegel> the U mean a function union
15:50:21 <Boegel> intersect is a union of different functions
15:50:27 <Lemmih> intersect ray (sphere@Sphere blah blah) = ...
15:50:32 <Boegel> okay
15:50:42 <Boegel> I thought I'd need @ :p
15:51:18 <Lemmih> eh. 'intersect ray sphere@(Sphere blah blah) = ...'
15:52:54 <Boegel> does the (Sphere rad cen mat) work with the way I defined a Sphere ?
15:53:02 <Boegel> data Object = Sphere1 { radius :: Double, center :: Point3D, material :: Material} 
15:53:02 <Boegel> 	    | Sphere2 { radius :: Double, center :: Point3D, material :: Material}
15:53:06 <Boegel> probably not...
15:53:26 <Boegel> Hugs only knows Object as type, right ?
15:53:28 <Lemmih> Yes that would work.
15:54:01 <Lemmih> Oh wait.
15:54:32 <Lemmih> That wouldn't work since you haven't defined Sphere.
15:55:25 <Boegel> yeah I know
15:55:28 <Boegel> Sphere1 :>
15:55:32 <Boegel> but tha's what I meant
15:55:40 <Boegel> intersect :: Ray -> Object -> [(Double,Intersection)]
15:55:40 <Boegel> intersect ray sphere@(Sphere1 radius center mat) = intersectSphere ray sphere
15:55:40 <Boegel> intersect ray sphere@(Sphere2 radius center mat) = intersectSphere ray sphere
15:55:42 <Boegel> works fine
16:01:58 <bourbaki> hi
16:02:02 <shapr> bourbaki: y0, how's arrows?
16:02:03 <Lemmih> Hey bourbaki
16:02:26 <bourbaki> shapr: very good :) i think ill soon be able to apply it all to my graph stuff
16:02:32 <shapr> yay!
16:02:47 <bourbaki> im currently thinking about methods to traverse the tree and build the functions
16:03:03 <bourbaki> which is why im here atm cause i wanted to check my idea
16:03:20 <bourbaki> my idea is that you have a directed graph where the edges are arrows
16:04:18 <bourbaki> atm i have one type of arrow "splitting", paaralelization and "join"
16:04:39 <bourbaki> the splitting is when one node feeds two functions
16:05:03 <bourbaki> the paaralelization is just the cartesian product of the two functions
16:05:32 <bourbaki> and the join is the cartesian product of two codaomains
16:06:23 <bourbaki> and if you have a network of arrows now the question arises how to yield the functions you want
16:06:43 <bourbaki> so you define a set of nodes and i check for source and sink nodes
16:07:23 <bourbaki> then i take the dual of the graph and take the flow form the sinks to the source nodes
16:07:45 <bourbaki> that way i get n sequential functions where n is the number of sink nodes
16:08:22 <bourbaki> and what i try to do now is to patch these function paths together to a single function
16:08:34 <bourbaki> does that sound reasonable in anyway?
16:12:52 <Boegel> I don't know anything about arrows, so i wouldn't know :)
16:13:22 <bourbaki> :)
16:28:43 <Boegel> can I reference a argument by name and by 'parts' ?
16:28:45 <Boegel> for example
16:28:56 <Boegel> intersectSphere (Ray (rsX,rsY,rsZ) (rdX,rdY,rdZ)) (Sphere1 radius (cenX,cenY,cenZ) mat)
16:29:13 <Boegel> I would like to be able to reference (rsX,rsY,rsZ) as a whole
16:29:25 <Boegel> without having to type (rsX,rsY,rsZ) again
16:29:31 <Boegel> is that possible ?
16:29:59 <Lemmih_> You can use the '@' operator.
16:30:17 <Boegel> so
16:30:32 <Boegel> intersectSphere (Ray start@(rsX,rsY,rsZ) dir@(rdX,rdY,rdZ)) (Sphere1 radius center@(cenX,cenY,cenZ) mat)
16:30:34 <Boegel> like this ?
16:31:09 <Lemmih_> Indeed.
16:31:35 <Boegel> ok,thx
16:31:40 <bourbaki> oh funky :)
16:32:24 <Boegel> another problem
16:32:31 <Boegel> in a where clause, I have the following
16:32:31 <Boegel> 	getInt t = (Intersection (intX t,intY t,intZ t) ((((intX t)-cenX)/radius),(((intY t)-cenY)/radius),
16:32:32 <Boegel> 			    	 (((intZ t)-cenZ)/radius)) mat)
16:32:32 <Boegel> 	intX t = rsX + rdX*t
16:32:32 <Boegel> 	intY t = rsY + rdY*t
16:32:32 <Boegel> 	intZ t = rsZ + rdZ*t
16:32:54 <Boegel> (intX t) for example is calculated twice
16:33:03 <Boegel> how can I avoid this ?
16:33:22 <Boegel> would this work:
16:33:53 <Boegel> 	getInt t = (Intersection (intX t,intY t,intZ t)@intPoints ((((intX t)-cenX)/radius),(((intY t)-cenY)/radius),
16:33:53 <Boegel> 			    	 (((intZ t)-cenZ)/radius)) mat)
16:33:53 <Boegel> 	intPoints = (...,...,...)
16:33:56 <Boegel> ?
16:34:05 <Lemmih_> I don't follow.
16:34:42 <Boegel> I put (intX t, intY t, intZ t) as a second argument for the result of getInt t
16:34:44 <Lemmih_> Why should intX be calculated twice?
16:35:07 <Boegel> but I need the value of (intX t) again for calculating the third argument
16:35:39 <Boegel> because Haskell is lazy, and it will replace (intX t) with (rsX + rdX*t) twice
16:35:41 <Boegel> right ?
16:36:03 <Lemmih_> The result will be cached and only computed once.
16:36:31 <Boegel> and would it work with the (x,y,z)@intPoints ?
16:36:55 <Boegel> where intPoint = ('calc x', 'calc y', 'calc z')
16:36:57 <Boegel> ?
16:37:34 <Lemmih_> I don't follow.
16:38:10 <Boegel> wait, I'll show it to you on the wiki
16:39:15 <Boegel> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
16:39:16 <Lemmih_> You shouldn't worry to much about performance since GHC is pretty good at optimizing.
16:39:42 <Boegel> it's also to avoid the intX t, intY t and intZ t expressions...
16:39:54 <Boegel> it shortens the where clause
16:39:59 <Boegel> and looks niftier
16:40:29 <Boegel> I'm guessing it won't work, because Hugs gives an error with the @
16:41:11 <Boegel> but maybe there's an other way to do it like this
16:41:19 <Boegel> check the wiki, I posted it there
16:43:52 <Lemmih_> (intX,intY,intZ) = (..,..,..)
16:54:43 <Boegel> yeah, that could work to
16:54:46 <Boegel> *stupid* :)
16:55:23 <Boegel> no it won't
16:55:30 <Boegel> because intX is a function, it needs t
16:56:07 <Lemmih> Functions are values too.
16:59:58 <Boegel> Lemmih, so (intX t, intY t, intZ t) = (..,..,..) would work to ?
17:00:50 <Lemmih_> intX = \t -> ...
17:01:31 <Boegel> that's the same as intX t = ...
17:01:34 <Boegel> :)
17:01:38 <Boegel> anyway, I'm going to bed
17:01:43 <Boegel> tomorrow more Haskell
17:01:50 <Boegel> Lemmih, thank you for the help
17:02:00 <Lemmih_> No problem.
17:02:05 <Boegel> bye
17:07:38 <bourbaki> qwe63qAs
17:10:16 <Lemmih> Indeed.
17:14:32 <bourbaki> heh
17:14:53 <bourbaki> i cleaned my keyboard
17:15:40 <bourbaki> s anyone of you a glad wner of a happy hacking keyboard?
17:15:48 <dons> yes :)
17:15:58 <dons> aren't they great!
17:16:20 <bourbaki> id like to buy one my ond keys tha ti just connected arent a lot bigger then the hhk
17:16:39 <bourbaki> but they are so expansive and i dont know  astore where i can try it
17:16:58 <dons> sure
17:17:05 <bourbaki> wehre?
17:17:58 <dons> I got mine at everythinglinux.com.au, don't know if they still sell them
17:18:14 <dons> coming to sydney might be a bit of a luxury to try a keyboard, though ;)
17:18:24 <bourbaki> :)
17:18:49 <bourbaki> i was aleady about to build my own keyboard cause that would be a lot cheeper
17:59:37 <crackhead> sup everyone :)
18:21:33 <CosmicRay> very little, apparently :-)
18:22:23 <crackhead> true
18:24:16 <crackhead> http://rafb.net/paste/results/WHvigG86.html
18:25:13 <crackhead> could someone tell me why hugs is giving me an error for line 4?
18:25:45 <crackhead> Last generator in do {...} must be an expression
18:25:47 <crackhead> Last generator in do {...} must be an expression
18:26:00 <crackhead> oops...didn't mean to paste twice
18:26:10 <crackhead> ...but that is the error HUGS is giving me
18:27:18 <Cale> you might try making sure that the n <- getInt and so on are spaced in the same as the putStr
18:27:42 <crackhead> hmmmmm
18:27:46 <crackhead> ok...trying
18:33:16 <crackhead> http://rafb.net/paste/results/sf6Ixj30.html
18:33:23 <crackhead> hmmmm....now it's line 16
18:33:28 <crackhead> ...same error
18:33:42 <Cale> same problem
18:33:51 <Cale> space those in a little more
18:34:26 <crackhead> hmmm
18:34:56 <crackhead> oh crap...I'm using tabs
18:35:11 <crackhead> I though my editor was converting tabs to spaces
18:35:16 <Cale> yeah
18:37:53 <crackhead> aaaaah.....so much better :)
18:37:58 <crackhead> thanks!
18:38:22 <Cale> np
19:11:08 <crackhead> Cale :are you there?
19:11:17 <Cale> yeah
19:11:30 <crackhead> I have a question about IO
19:11:38 <Cale> sure
19:11:53 <crackhead> the program I posted earlier was an example from my prof
19:12:19 <crackhead> I was wondering about the signature of the function
19:12:43 <crackhead> for example, the getInt :: IO Int versus nSum :: IO ()
19:12:48 <Cale> yeah
19:12:56 <crackhead> what exactly does each one mean?
19:13:00 <Cale> getInt is an Int producing IO computation
19:13:20 <Cale> nSum is a () producing IO computation
19:13:25 <crackhead> so then...it kinda returns an Int?
19:13:30 <Cale> yeah
19:13:41 <crackhead> versus returning a function?
19:13:43 <Cale> it returns a computation which would return an Int if it were run.
19:14:25 <crackhead> hmmmm....cool
19:14:34 <crackhead> that helps a lot
19:15:23 <Cale> the only thing which is ever run in that sense is main, or anything you type into ghci/hugs
19:16:02 <crackhead> huh?
19:16:09 <crackhead> that confused me
19:16:39 <Cale> main runs, and it might be built up of a bunch of other computations
19:16:41 <crackhead> what do you mean by "... in that sense is main"?
19:17:13 <Cale> but it's the one that actually gets run when you compile and execute your program
19:18:32 <crackhead> are you talking about nSum :: IO ()?
19:18:40 <crackhead> where () is like main?
19:18:47 <Cale> nSum is sort of your main
19:18:52 <crackhead> aaah
19:19:02 <Cale> for some reason you don't have an IO value called main
19:19:32 <Cale> If you wanted to compile an executable with ghc, I suppose you could put main = nSum
19:19:41 <crackhead> so are you saying I should have main :: IO ()
19:19:51 <Cale> usually, yeah
19:19:59 <crackhead> oh ok...I think I understand
19:20:13 <Cale> it's not necessary if all you're going to do is fire up an interpreter, but if you're going to compile something
19:20:32 <crackhead> yea...I'm using hugs
19:21:51 <crackhead> I tried to put in main = nSum and it didn't do anything for hugs
19:22:09 <crackhead> I still had to call main for it to start running
19:22:16 <Cale> well, hugs will always just give you the read-eval-print-loop
19:22:27 <crackhead> so does ghc actually compile to machine code?
19:22:33 <Cale> yeah
19:22:50 <crackhead> hmmm...I'm going to try and install it
19:23:02 <crackhead> what OS are you using?
19:23:22 <Cale> Debian GNU Linux
19:23:36 <Cale> (unstable)
19:23:46 <crackhead> hehe...that's what I run
19:24:23 <crackhead> ...but I just switched to OSX about 2 weeks ago
19:24:44 <Cale> apt-get install ghc6 ghc6-doc ghc6-hopengl :)
19:24:46 <crackhead> ...but I still have dselect and apt-get :-)
19:25:24 <crackhead> whoa....do you have any experience with haskell and opengl?
19:25:43 <Cale> A little, haven't tried anything serious.
19:25:57 <crackhead> I want to experiment with it after this class is over
19:26:16 <crackhead> how is hte performance?
19:26:35 <Cale> hopengl is a pretty unnatural binding, if you ask me, but the performance seemed okay
19:27:25 <Cale> someone implemented a quake-type game in Haskell at one point.
19:27:26 <crackhead> ok...almost done installing ghc
19:27:43 <crackhead> could you tell me how to compile with it?
19:27:52 <crackhead> hehe...nice
19:28:02 <Cale> ghc -o myExecutable mySource.hs
19:28:17 <crackhead> ok....cool
19:30:25 <crackhead> 36: Variable not in scope: `isDigit'
19:30:34 <Cale> import Char
19:30:50 <Cale> (this is a hugs oddity)
19:31:03 <crackhead> hmmm....do imports need to be done as the first lines of the file?
19:31:26 <Cale> possibly -- I've never tried to put them elsewhere
19:31:52 <crackhead> ld: can't locate file for: -lHShaskell98
19:32:20 <Cale> hmm
19:32:23 <Cale> odd
19:32:42 <Cale> does ghci work?
19:33:07 <dons> -package hsakell98
19:33:31 <crackhead> use ghci instead of ghc?
19:33:47 <Cale> no -- ghci is the interpreter that comes with ghc
19:33:56 <Cale> just wondering if it's working
19:34:32 <Cale> try dons' suggestion, add "-package haskell98" to the commandline arguments
19:34:51 <Cale> but it seems odd that you'd get a linker error
19:34:53 <crackhead> Loading package base ... ghc-6.2: can't load .so/.DLL for: HSbase (dlcompat: file "libHSbase.dylib" not found)
19:35:14 <Cale> perhaps your library path isn't set up quite right?
19:35:22 <crackhead> hmmm
19:35:28 <crackhead> damn OSX
19:36:27 <Cale> fink can be annoying sometimes
19:37:09 <crackhead> hmmmm....I still get the same error with the -package option
19:37:24 <crackhead> oh well...I'll play with it later
19:37:37 <Cale> . /sw/bin/init.sh
19:37:39 <Cale> try that
19:37:49 <Cale> and see if it helps
19:38:02 <Cale> (assuming you have fink installed at /sw)
19:39:11 <crackhead> mmasters@Michael-Masters-Computer:~/haskell/compile$ ghc -o test HW4.hs 
19:39:11 <crackhead> compilation IS NOT required
19:39:11 <crackhead> ld: can't locate file for: -lHShaskell98
19:39:45 <Cale> yeah, it's not finding the libs
19:40:13 <crackhead> hmmmm
19:40:41 <Cale> in case you were wondering, the "compilation IS NOT required" is because it's already compiled the program to object code, but gets stuck linking it
19:40:43 <crackhead> I know with opengl I have to tell gcc/g++ where the opengl libs are
19:41:12 <Cale> right, but you shouldn't have to mention libHShaskell98
19:41:50 <Cale> but if you can find it -- -L as usual to specify the path
19:51:05 <crackhead> ok....I'm updating hte locate db right now to see if I can find it
20:00:30 <crackhead> read             :: (Read a) => String -> a
20:00:39 <crackhead> what is the => mean?
20:01:02 <crackhead> is that  greater than or equal?
20:04:00 <Cale> it's an arrow -- you might read it as implies.
20:04:40 <Cale> That type is essentially "If a is in the class Read, then read is of type String -> a"
20:05:20 <crackhead> hmmmm
20:05:24 <crackhead> cool
20:05:40 <crackhead> for some strange reason I can't find that library
20:06:05 <Cale> maybe don't install ghc from fink
20:06:18 <crackhead> yea
20:06:35 <Cale> http://haskell.org/ghc/dist/6.2.1/MacOSX/GHC.6.2.1.dmg
20:06:41 <Cale> (10.3)
20:06:49 <crackhead> aaah
20:06:54 <crackhead> cool
20:12:52 <crackhead> wow...this is miserable. downloading at 7.3 KB/sec :(
20:13:31 <crackhead> I'm just going to have to mess with it later
20:13:54 <crackhead> ...when I'm somewhere with more bandwith
20:14:29 <crackhead> this coffee shop limits the bandwith
23:14:33 <crackhead> getInt :: IO Int
23:14:33 <crackhead> getInt = do s <- getLine
23:14:33 <crackhead>             if isInt s
23:14:33 <crackhead>                 then return (read s)
23:14:34 <crackhead>                 else do putStrLn " invalid integer"
23:14:36 <crackhead>                         getInt
23:15:07 <crackhead> why do you return (read s) if s is and Int?
23:16:58 <heatsink> @type read
23:17:00 <lambdabot> read :: forall a. (Read a) => String -> a
23:17:20 <Cale> crackhead: I suspect that isInt checks if the string s is a valid integer.
23:17:32 <crackhead> right
23:17:33 <Cale> read actually reads that string to get the integer value
23:18:45 <crackhead> Cale :what did you say about the => ?
23:20:45 <Cale> forall a. (Read a) => String -> a says "For every type a which is in the class Read, the type String -> a"
23:21:20 <Cale> basically, read reads readable things (which are in the class Read).
23:23:03 <crackhead> hmmm
23:23:23 <crackhead> do you have a different example?
23:23:41 <Cale> (+) :: (Num a) => a -> a -> a
23:25:11 <Cale> bounds :: (Ix a) => Array a b -> (a,a)
23:25:23 <Cale> that one might be confusing if you don't know how Arrays work
23:25:45 <Cale> (Array a b) is the type of arrays indexed by a's and which contain b's.
23:25:55 <Cale> (Ix a) says that a is an index type
23:26:38 <Cale> that is, it's ordered, and has some extra operations, like being able to return a list of all values in a given range
23:27:24 <crackhead> hmmmm....yea. I can't say I know how Array's  work
23:27:30 <crackhead> I just found a tutorial
23:27:43 <crackhead> I'm going to read through it real quick
