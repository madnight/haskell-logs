00:12:44 * musasabi starts to hate threadDelay slowly
00:13:47 <musasabi> It has a little bonus feature making it impossible to wait for longer than 35minutes
00:27:59 <dblhelix> kosmikus: ping
00:46:38 <dons> yay! you can actually edit characters in yi now
01:07:42 <musasabi> hmm why does GHC seem use ThreadIds against the documentation?
01:07:56 <musasabi> that is they are recycled very fast.
01:08:03 <musasabi> which creates "interesting" effects
01:22:26 <musasabi> hmm seems it is ghci rather than my program
02:03:24 <vivek> hello pesco 
02:03:59 <pesco> Hi vivek, how's code?
02:07:29 <vivek> code is just pretty messy as of now :)
02:07:43 <pesco> What is it?
02:10:28 <vivek> pesco: i am just starting with haskell so there are plenty of problems nothing in particular that a little bit of RTFMing wont fik  
02:10:38 <pesco> I see.
02:12:10 <TheHunter> Is it possible to call cpphs from ghc? (-pgmP "cpphs --layout") doesn't seem to work.
02:12:53 <TheHunter> ...or to convince stupid cpp to insert newlines.
02:15:25 <pesco> TheHunter: Maybe it doesn't like the --layout argument?
02:15:52 <TheHunter> pesco: nah, it doesn't like -I directory, -x c and -o filename.
02:16:19 <pesco> As in, it doesn't call a shell but execve with "cpphs --layout" as the program argument?
02:16:34 <pesco> What do you mean, it doesn't like -I, -x, -o?
02:18:01 <TheHunter> the command ghc calls cpphs with is `cpphs --layout -v -I /usr/lib/ghc-6.2.2/include -x c test.hs -o /tmp/ghc1313.hscpp'
02:18:28 <TheHunter> Fail: /usr/lib/ghc-6.2.2/include: openFile: inappropriate type (is a directory)
02:19:14 <pesco> Oh. Then cpphs doesn't accept the same command line arguments as cpp? Maybe that should be changed?
02:19:35 <TheHunter> ok, i could write a wrapper that simply removes arguments that cpphs doesn't like, but there should be a simpler way.
02:19:56 <TheHunter> Yes, that should be changed at least for the arguments ghc uses to call cpphs with
02:20:39 <pesco> Then either write a wrapper that translates the arguments in some suitable manner or hack cpphs to accept the "correct" ones.
02:22:46 <TheHunter> Ok, i'll just preprocess the files manually then...
02:22:58 <pesco> Or that. :/
02:24:17 <TheHunter> pesco: thanks anyway.
02:52:10 <shapr> dons: yay!
02:53:35 <pesco> Moin shapr!
02:53:43 <shapr> gutentag pesco 
02:54:46 <pesco> shapr: Say "Guten Tag", two words. Just as in "good day".
02:54:54 <shapr> ok
02:55:04 <shapr> Guten Tag pesco :-)
02:55:13 <pesco> shapr: Combining works only on nouns to built a new noun.
02:55:18 <pesco> Tach auch. ;-)
02:56:38 <xkb> strange I read a german magazine every 2 weeks and I still can't write nice conversation in German
02:56:56 <pesco> shapr: (The "ch" is incorrect spelling expressing the north-german (esp. Hamburgish) pronounciation.)
02:57:22 <pesco> xkb: Wow, I just noticed you're named like the X Keyboard Extension. I hate you. ;-)
02:57:24 <asyd> heya shapr 
02:57:36 <xkb> pesco, your welcome :D
02:57:41 <xkb> eh
02:57:44 <xkb> you are
02:58:30 <pesco> Actually, I'm fine with xkb again. Just yesterday I spent half a day trying to get it to do what I want.
02:58:51 <pesco> Now it's done and I understand it (mostly) and it's good.
02:58:59 <xkb> pesco, so you spent half a day with me, and you liked it ;-)
02:59:09 <earthy> no, he likes it now
02:59:14 <earthy> he didn't like the half day. :)
02:59:18 <xkb> darn
02:59:19 <xkb> :d
03:00:06 <pesco> Right. Yesterday I was pissed at your utter lack of documentation. ;)
03:00:14 <xkb> lol
03:00:22 <pesco> Well, that's not entirely fair.
03:00:39 <pesco> The XKB protocol is documented.
03:01:35 <pesco> What's lacking is a short manual explaining such simple things as remapping some keys.
03:01:47 <pesco> Oh well, next topic.
03:03:38 * xkb looks back at throwDyn for his exception example
03:08:28 <kosmikus> dblhelix: pong
03:09:22 <dons> moin shapr
03:11:11 <bourbaki> moin moin
03:11:19 <TheHunter> moin bourbaki 
03:11:32 <bourbaki> TheHunter: you are my hero :)
03:11:47 <pesco> If I throw an exception of custom type with throwDyn and that type is in Show, and the exception is not caught, is there a way to have the exception printed upon program terminationV
03:11:58 <bourbaki> TheHunter: my last problem would you be able to listen to it?
03:11:58 <pesco> s/terminationV/termination?/
03:12:13 <TheHunter> bourbaki: sure
03:12:15 <pesco> bourbaki: What is it?
03:12:25 <xkb> pesco, isnt that default behaviour?
03:12:39 <pesco> xkb: I just tried it and it printed "unknown exception".
03:12:39 <bourbaki> TheHunter: imagine you have a function like i showed you there
03:12:41 <xkb> runtime env. prints exceptions if they are not caught I thought
03:12:49 <xkb> pesco, darn.. I need that to :D
03:12:57 <xkb> you can always do a catchAll
03:13:21 <pesco> Yes, but that stinks, because nobody ever wants any program to print "unknown exception".
03:13:22 <dblhelix> kosmikus: is the new version hidden behing the same url?
03:13:27 <bourbaki> TheHunter: no lets start in a different way how would you build a stack or something that adds arrows to an arrow collection?
03:13:34 <dblhelix> /s/behing/behind
03:14:05 <xkb> pesco, true.. but thats the catch of using dynamics
03:14:10 <TheHunter> bourbaki: wdym by `arrow collection'?
03:14:18 <bourbaki> TheHunter: what i so to say need is an arrow in my network that changes other arrows
03:14:34 <bourbaki> or add some
03:14:41 <TheHunter> bourbaki: change in what way?
03:15:00 <pesco> xkb: Still, I feel it should be possible somehow.
03:15:12 <bourbaki> TheHunter: in a neural network you need to adjust the weights in my terminology i have to change the (pure (weight x)) arrows
03:15:38 <TheHunter> ok
03:16:09 <TheHunter> you first need a way to reference your weights
03:17:55 <bourbaki> yes
03:18:12 <TheHunter> any ideas how that could work?
03:18:26 <bourbaki> well that is not really side effect free is it?
03:18:38 <bourbaki> i had that idea also something like a global table of things
03:19:12 <bourbaki> my idea was to preconstruct functions that are like this
03:19:24 <TheHunter> in any case, i think the ST monad is your friend.
03:19:37 <bourbaki> \x -> \y -> ... where x is the other arrow as a refference
03:20:49 <bourbaki> the problem is if you see the network as something like a category then adding an arrow is like a functor or changeing and the like as well
03:21:13 <bourbaki> and then i mix stuff together that isnt really meant to be in the same place
03:23:04 <TheHunter> is the set of changable arrows fixed or does it depend on the evaluation of your program?
03:23:46 <bourbaki> its fixed cause its all of the weight arrows
03:23:59 <kosmikus> dblhelix: yes, it should be
03:24:19 <dblhelix> ok, tnx
03:24:29 <TheHunter> and if you `change' the arrow, everything has to get re-evaluated?
03:24:44 <bourbaki> TheHunter: yes
03:25:18 <TheHunter> and you want to be able to change arrows from within the network?
03:25:37 <bourbaki> yes this is what i would like and also add or delete arrows
03:26:03 <bourbaki> imagine a stack with arrows where you push and pop arrows
03:26:30 <bourbaki> and a peek on the stack gives you the evaluation of the uppermost arrow
03:27:10 <TheHunter> ok, what happens if the stack is empty?
03:27:34 <bourbaki> the last element could be an arrow which does something like
03:27:45 <bourbaki> \x -> empty so to say
03:28:13 <bourbaki> that retrieves the buttom element of the stack that is
03:28:48 <TheHunter> so deleting the last element of the stack will give you an arrow?
03:28:56 <TheHunter> s/arrow/error/
03:29:28 <bourbaki> when id pop from the empty stack just nothing would change
03:30:38 <TheHunter> but the output of your arrow is connected to an input isn't it?
03:31:02 <bourbaki> in the neural net application or in the stack thing?
03:31:13 <TheHunter> in the neural net application
03:31:20 <bourbaki> yes
03:31:39 <TheHunter> so if you delete the arrow, something is missing.
03:31:57 <bourbaki> yes in the case of they neural net deleting is not an option really
03:32:50 <bourbaki> but i guess its impossible to do something that is self referential
03:33:05 <TheHunter> ok, the two workarounds i saw would have been (i) returning a default value (ii) making every input a Maybe-type
03:33:14 <bourbaki> which always makes me wonder about the oo way c++ is
03:34:33 <bourbaki> i think ill have to make adding, subtracing and changeing arrows/edges/transitions a functor and nothing that is within the network :( which is not very nice
03:34:51 <TheHunter> so to sum up, you want to have an Arrow type that has two kinds of arrows: primitive arrows and arrows that can be changed. The set of changeble arrows is fixed, so you can't dynamically add these things.
03:35:37 <bourbaki> right
03:37:01 <TheHunter> i'll have to think about that, but i think it is possible.
03:37:45 <bourbaki> but you see the problem of selfreference there as well your first proposal was what i had in mind also
03:38:00 <bourbaki> with a global refference table thing
03:39:16 <bourbaki> i also will make a slight rewrite of the stuff i had so far that allows you to have a reverse operation of >>>
03:40:15 <bourbaki> all operatiors will construct paths in these networks which store all its elements and the overall crunched function
03:40:34 <bourbaki> youll need that for changeing and replaceing things
03:45:35 <TheHunter> once again, changing an arrow will result in an instant re-evaluation of everything or just that another arrow is used the next time this arrow is invoked?
03:46:06 <bourbaki> the latter
03:46:33 <TheHunter> puh, that's definitly the easier alternative.
03:46:57 <bourbaki> another analogy would be
03:47:09 <bourbaki> think of a network that has two arrows
03:47:26 <TheHunter> and the nn gets executed stepwise, each step being a complete computation of all output nodes?
03:47:40 <bourbaki> yes
03:48:07 <bourbaki> (get|set, value)
03:48:39 <TheHunter> so the top level should be something like runNN :: NNArrow Input Output -> [Input] -> [Output]
03:48:42 <bourbaki> if you put in (set,valxy) the arrow that retrieves valxy is changesd to a function that retirevs this arrow
03:48:45 <bourbaki> er value
03:49:47 <bourbaki> NNArrow Input Output is considered a triple?
03:50:10 <TheHunter> no, it should be an arrow from Input to Output
03:50:19 <bourbaki> ah ok sry of course
03:51:51 <TheHunter> <bourbaki> if you put in (set,valxy) the arrow... could you explain that again?
03:52:03 <bourbaki> yes
03:52:16 <bourbaki> the idea is that you have one input node in this network
03:52:27 <bourbaki> and the input is of the type
03:52:36 <bourbaki> (get|set, value)
03:53:06 <bourbaki> (get, valuexy) would select the arrow corresponding to the valuexy
03:53:22 <bourbaki> like in c++ objects or very alike
03:53:41 <bourbaki> objectfoo.getbar
03:54:13 <TheHunter> so valuexy is just a reference to an arrow.
03:54:18 <bourbaki> and if you want so set a new value in the object (that is the network) youd have to change the function of the arrow
03:54:21 <bourbaki> yes
03:54:33 <TheHunter> ok
03:55:09 <TheHunter> bourbaki: i have a class now, but i'll think about it then.
03:55:11 <bourbaki> and (set,valuexy) would change an arrow ... ok maybe it has to be a triple ;) but you get the idea i guess
03:55:26 <TheHunter> yep
03:55:50 <bourbaki> cool if you are getting interested in it we can tinker something together and when i pub my thesis im mentioning you
03:56:28 <bourbaki> and if im not getting a degree because im fed up with studying ill send that stuff to some conv or so ;)
03:57:12 <bourbaki> im meeting the gui guy tomorrow if you have ideas for that visual ide thing tell me
03:57:46 <TheHunter> ok, i gotta go. See you.
04:03:05 <vivek> bourbaki: wxhaskell guy ?
04:03:10 <bourbaki> nope
04:03:21 <bourbaki> java or flash or i dont know what
04:03:32 <vivek> another gui for haskell ?
04:03:36 <bourbaki> i want to have a visual editor for my stuff
04:04:15 <bourbaki> i dont mind really what language or stuff he uses as long the editor does what i need :)
04:04:36 <vivek> use emacs bourbaki :)
04:04:49 <bourbaki> emacs cant edit graphs visually
04:05:11 <bourbaki> and also it doesnt implement the functionality that i want to have
04:05:16 <vivek> oh graphs sorry 
04:05:20 <bourbaki> :)
04:05:26 <kristnjov> when i'm going to press (in emacs) C-x C-s to save i usually accidentally press C-x C-c which closes the program :/
04:05:31 <pesco> bourbaki: What kinds of graphs do you need to edit?
04:05:41 <pesco> kristnjov: Haha!
04:05:44 <pesco> :)
04:05:55 <bourbaki> pesco: nodes are domains and the edges are haskell arrows roughly
04:06:07 <vivek> kristnjov: it sill asks u if u wanna save the buffers 
04:06:16 <vivek> so no harm done :)
04:06:17 <asyd> kristnjov: well, C-x C-c don't close emacs if you have no save buffer
04:06:26 <kristnjov> yes, but i want to cancel the closing process vivek
04:06:32 <bourbaki> my idea then is you can choose from a pallete that matches the domain and codomain
04:06:34 <pesco> bourbaki: So, directed graphs with labeled nodes and edges?
04:06:41 <bourbaki> yes
04:06:51 <kristnjov> asyd, still a hassle to restart emacs
04:07:26 <vivek> remap the save key kristnjov ?
04:07:31 <bourbaki> and if there is no matching function then you can double click the edge and it writes a typesignature to a file and you can begin to write the function
04:07:57 <kristnjov> vivek, i feel like i shouldn't really have to
04:08:33 <pesco> bourbaki: So you'd place the nodes and edges yourself and then assign suitable arrows to the edges?
04:08:46 <bourbaki> pesco: right thats the idea
04:09:13 <vivek> kristnjov: switch to dvorak and u will never worry about this problem s and x are far away :)
04:09:33 <kristnjov> alright
04:10:05 <pesco> bourbaki: Ok. I'll be interested in the graph layout algorithm you end up using.
04:10:27 <musasabi> Is it possible to have arr (Control.Arrow) do different things on different values to arrowize?
04:10:30 <pesco> bourbaki: I have to draw incrementally-built directed graphs for work.
04:10:46 <bourbaki> pesco: my idea is that you can change them but you can zoom in and out by useing topological things
04:11:05 <bourbaki> pesco: you know that you can read the code of graphviz?
04:11:16 <pesco> What do you mean by "topological things"?
04:11:29 <bourbaki> my idea is that these graphs are topologies
04:11:45 <bourbaki> and then i can build quotient spaces that collapse graphs
04:12:17 <bourbaki> functionally the collapseing can be done in with the arrow stuff
04:12:32 <pesco> bourbaki: There appear to be algorithms superior to those graphviz uses.
04:13:09 <bourbaki> yeah but these programs are awfully expansive
04:13:30 <tromp> how do the expand then?
04:13:33 <tromp> they->they
04:13:50 <bourbaki> tromp: ?
04:13:54 <pesco> bourbaki: I don't know any programs, I was refering to published algorithms.
04:13:58 <tromp> oh, you mean expEnsive :-?!
04:14:28 <pesco> Those are free. :)
04:14:51 <bourbaki> pesco: i havent implemented anything like that yet and i dont think that the guy who implements it will do something really intelligent ;)
04:15:11 <bourbaki> if he implements it himself that is
04:15:34 <pesco> bourbaki: "The guy who implements it"? Oh, you're talking about someone making such a program?
04:15:34 <bourbaki> i alread also thought about 3 dimensional representations
04:15:41 <bourbaki> yes
04:15:54 <bourbaki> i need it for my stuff and ill tell him what exactly i need
04:16:09 <pesco> bourbaki: 3D seems a bit like evading the problem, since we only have 2D screens.
04:16:58 <bourbaki> yes but if you have a functor of networks or you want to combine networks topologically then i think it would come handy
04:17:15 <bourbaki> to think of changes as layers in the 3rd dimension
04:17:26 <pesco> Ok, that could be useful.
04:17:31 <bourbaki> yep
04:17:46 <bourbaki> i write that thesis for bsc in ai
04:18:03 <pesco> I see.
04:18:21 <bourbaki> and i want to show that these graph things are usefull to represent a lot of different standard algorithms
04:18:39 <bourbaki> and i want to have a running implementation of it in haskell
04:19:07 <bourbaki> that includes that you can build simple state automata
04:19:34 <bourbaki> neural networks and a number sequence function generator
04:20:10 <bourbaki> maybe a decision tree as well if its easy i can build the things very quickly (which is of course the idea ;)
04:27:06 <shapr> g'day dons 
04:27:41 <shapr> happy: do you have a brother named alex?
04:27:51 <bourbaki> hi shapr 
04:28:04 <shapr> Guten Tag bourbaki 
04:28:06 <vivek> shapr: is me in erc 
04:28:09 <shapr> salut asyd
04:28:32 <asyd> bonjour shapr :)
04:28:34 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, built 2004-08-28)!
04:28:59 <vivek> shapr: i am learning the ropes on erc and am gonna say goodbye to the other irc clients
04:29:07 <shapr> ERC is nice.
04:29:11 <xkb> erc?
04:29:14 <xkb> emacs irc?
04:29:20 <happy> yes the emacs irc client
04:29:21 <shapr> but sometime very soon, there will be Yirc
04:29:32 <shapr> and Yirc will be better than ERC.
04:29:54 <happy> are u writitg yirc ?
04:30:05 <shapr> yes, sort of...
04:30:24 <shapr> Yi is an editor in-progress.
04:30:33 <happy> now i am a step closer to living in emacs ... 
04:30:39 <xkb> Emacs the Os ;)
04:30:49 <shapr> I was minorly involved with ERC 2.0 development.
04:30:53 <musasabi> hmm got arrows creating a graphical presentation of themselves..
04:31:01 <shapr> musasabi: oh oh! I want to see!
04:31:11 <shapr> musasabi: outputting graphviz? or what?
04:31:53 <musasabi> yes with graphviz
04:32:03 <shapr> nifty!
04:32:26 <shapr> happy: I've been living in emacs for years, but I got really tired of it :-/
04:32:44 <shapr> emacs doesn't have multithreading, so if gnus or erc blocks on a read, you can't edit at the same time.
04:33:02 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/SPDraw.hs http://www.cs.helsinki.fi/u/ekarttun/haskell/SPDraw.png
04:33:28 <happy> shapr: can i be in two channels in erc /
04:33:34 <shapr> happy: yes, many
04:33:41 <shapr> also multiple servers.
04:33:52 <happy> how do i switch between windows ?
04:33:59 <happy> i mean channels 
04:34:08 <happy> i am in #emacs too 
04:35:04 <bourbaki> whats ERC?
04:35:17 <happy> emacs irc client
04:35:21 <bourbaki> ah :)
04:35:31 <bourbaki> why dont you use irssi?
04:35:49 <happy> i am on irssi i wanna switch to erc 
04:36:05 <bourbaki> in what respect is it better?
04:36:56 <vivek> well i use emacs for programming so i guess i should stay in the same program and handle my chatting too ...
04:37:19 <happy> vivek = irssi version of happy 
04:38:45 <bourbaki> hm maybe i should change from emaces to vi ;)
04:39:04 <bour[meeting]> hi Boegel 
04:39:07 <happy> hello Boegel
04:39:22 <Boegel> brb
04:39:23 <musasabi> now why does it seem like only one putString is related to the getString ?
04:39:45 <Boegel> heya
04:41:17 <Boegel> bour[meeting]: have you worked on your raytracer yet ?
04:42:57 <musasabi> hmm it is first handling probably.
04:45:22 <shapr> hoi goron 
04:45:32 <shapr> happy: switch to the #emacs buffer
04:45:48 <shapr> vivek: each channel has its own buffer just like a file
04:46:17 <shapr> hej bringert 
04:46:21 <bringert> hej
04:46:26 <goron> hej
04:46:40 <vivek> shapr: tnx shapr
04:46:41 <shapr> oh I'm in the midst of writing an email about these warez
04:46:54 <bringert> email to whom?
04:46:57 <vivek> what warez ?
04:46:58 <shapr> to you
04:47:01 <vivek> to whom ?
04:47:03 <goron> shapr: Can you also unload code with hs-plugins?
04:47:07 <bringert> to me?
04:47:09 <shapr> goron: I think so
04:47:12 <dons> goron: yes
04:47:14 <shapr> bringert: yes you... 
04:47:43 * bringert is playing with Slideshow
04:47:43 <goron> shapr: Are you thinking of making the GUI a plugin too?
04:48:03 <goron> shapr: HEmacs
04:48:05 <shapr> goron: you mean in yi, formerly known as hemacs?
04:48:16 <shapr> yes, the GUI will be a plugin also.
04:48:23 <goron> shapr: A name change, this soon. :)
04:48:30 <shapr> hemacs was already taken
04:48:45 <goron> shapr: As a sourceforge projectname, you mean?
04:48:45 <shapr> plus it wasn't really haskell emacs, it was also hvim and hjoe/hjed
04:48:54 <shapr> nah, hemacs is "hebrew emacs"
04:49:00 <goron> lol
04:49:12 <goron> what's yi?
04:49:19 <vivek> its hemacs 
04:49:24 <vivek> renamed 
04:49:28 <goron> That I do understand.
04:49:34 <shapr> bringert: one problem I couldn't get around was that FM wouldn't accept anything outside of boring ascii, no ä or å
04:49:37 * dons tentatively adds :w support to yi
04:49:46 <shapr> Y I
04:50:01 <bringert> hmm, that sounds odd
04:50:05 <rhw> shapr, Do you ever sleep ? :)
04:50:17 <shapr> rhw: I tried it once, it was a waste of time.
04:50:17 <xkb> hemacs sounds like heman's emacs
04:50:25 <dons> yeah!
04:50:37 <shapr> by the power of Haskell!
04:50:40 <shapr> anyway...
04:50:49 <shapr> bringert: I suspect it's user error, but I can't figure it out.
04:51:00 <goron> shapr: I should pronounce it in English?
04:51:07 <bringert> for non-latin scripts some ad-hoc coding is often used, but I can't see we swedish would need that
04:51:19 <bringert> s/we/why/
04:51:20 <shapr> bringert: I used comint-run in xemacs to start morpho_sw
04:51:52 <vivek> shapr: is multithreading planned in emacs ?
04:52:11 <shapr> vivek: I don't think so, it would be a catastrophic upheaval in the emacs world
04:52:45 <shapr> none of the existing elisp code is threadsafe, and the existing elisp code is what makes emacs so cool.
04:52:49 <tuomov> Yi can best be translated a righteousness (http://www.fact-index.com/c/co/confucius.html)
04:53:12 <tuomov> and we have a symbol for it too!
04:53:18 <shapr> dons: what was the consensus on pronunciation? yee?
04:53:33 <tuomov> english y or finnish/whatever y?
04:54:16 <goron> shapr: Is there some website for Yi?
04:54:31 <shapr> goron: not yet, but there is a mailing list and a darcs repo
04:54:34 <dons> yee. pronounce the y
04:54:46 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/yi
04:54:46 <dons> tumov: don't know?!
04:55:10 <shapr> tuomov: I think 'jii' in finnish
04:55:51 <dons> Confucius rocks!
04:55:55 <shapr> goron: http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
04:56:07 <shapr> and the repo url I just pasted
04:56:22 <shapr> yay, insert, delete and kill
04:56:40 <dons> some buffer oddities atm, but soon to be fixed..
04:56:44 <goron> dons: I am not sure about that ;)
04:57:08 <tuomov> shapr: yes, that's how yee would be written
04:57:31 <tuomov> and how yi would be pronounced with finnish rules there's no way to write in english..
04:57:44 <dons> yi flows out of ren (?). Ren can best be translated as human
04:57:50 <dons> interconnectedness.yi flows out of ren (?). Ren can best be translated as human
04:58:04 <tuomov> since there's no y in english
04:58:09 <tuomov> afaik
04:58:17 <shapr> not a finnish y
04:58:30 <bringert> shapr: I can use åäö in morpho_sw
04:58:36 <bringert> started it from the terminal
04:58:44 <bringert> maybe a utf-8/latin-1 problem?
04:58:44 <shapr> bringert: most likely user error
04:58:56 <shapr> I dunno, I swapped encoding from emacs, didn't seem to change it...
04:59:07 <shapr> I wonder what I'm doing wrong
04:59:18 <bringert> so, I just start morpho_sw and enter "åka"
04:59:26 <bringert> 1. åka (16850) Verb - Inf Act -
05:02:15 <shapr> greetings squire 
05:02:33 <shapr> bringert: oh, it looks like my attempts at changing the encoding did not succeed... 
05:03:31 * Lemmih returns from the world of the drones.
05:06:04 <musasabi> Is there a way to create datastructures which have identity outside monads?
05:06:24 <shapr> you could use records with Unique
05:06:55 <goron> Wouldn't it be better to call it CEmacs? Considering the fact of all the INLINE pragma's and mutable byte arrays? :-)
05:07:13 <shapr> well, while we're just starting...
05:07:15 <squire> hello shapr
05:08:09 <dons> goron: bah!
05:08:18 <squire> do monads have any relation to something in category theory(?) called *monoids*?
05:08:41 <tuomov> monads are a category theoretical concept
05:08:54 <tuomov> the haskell operators just differ from the usual definition
05:09:57 <goron> squire: Yes, a monad is more abstract. 
05:10:04 <dons> yi just wrote created its first file :)
05:10:05 <tuomov> (but return, join, liftM+the data type itself on types form such a monad)
05:10:16 <shapr> goron: the goal is to get a usable editor as soon as possible, then we can refactor at will
05:10:29 <tuomov> s/data type/type class/
05:11:17 <tuomov> any thoughts on the theory of buffers?-)
05:11:28 <shapr> tuomov: it's sexy
05:11:40 <shapr> I keep getting stuck in a loop when I try to reply to your email
05:11:56 <shapr> too much different stuff to try to stick into one reply
05:12:21 <goron> shapr: I don't think having some speed is bad, but I would first write something slow and than optimize it. But I never created a big project with Haskell, and have little experience with FFI. I am very glad someone is creating some Haskell editor. 
05:12:23 <shapr> would allow out of order undo
05:12:34 <shapr> goron: you can jump in and help :-)
05:12:41 <shapr> then you will have experience ;-)
05:14:36 <goron> shapr: If there's an opensource project I would like to participate in, this will be it. 
05:14:39 <dons> goron: we had a slow buffer 2 days ago, and a faster one now :)
05:14:44 <squire> ok, it seems "monoid" and "monad" are somewhat different
05:15:13 <goron> squire: A monoid is a thing which obeys to more rules. 
05:15:25 <goron> squire: Therefor, a monad is more abstract. 
05:15:37 <squire> oh, ok
05:15:42 <shapr> I'm really abstract, I never obey any rules.
05:16:00 <goron> shapr: You do obey rules.
05:16:07 <shapr> hah! I do not!
05:16:16 <shapr> I'm a Rebel without a Clue!
05:16:17 <goron> shapr: Yes you do.
05:16:33 <shapr> nuhuh
05:16:39 <shapr> er, how do you write that anyway?
05:16:41 <goron> shapr: That's only an outer layer of you.
05:16:42 <shapr> nuh uh!
05:17:09 * shapr feels psychoanalyzed!
05:17:25 <vivek> shapr: he just called u a liar in an abstract manner ...
05:17:32 * shapr laughs
05:17:37 <shapr> that was punny.
05:17:38 <vivek> hah 
05:17:55 <shapr> "I'm abstract!" "Liar!"
05:18:03 * shapr chortles
05:18:26 <shapr> goron: In reality, my outer layer obeys more rules than my inner layer.
05:18:45 <goron> " Closure: x   y is in S, if x and y are both in S. " Associativity: x   (y   z) = (x   y)   z for all x, y, and z in S. " Identity: There is an element e in S such that e*x= x*e = x , for all x in S .
05:18:55 <goron> This is a monoid.
05:19:06 * shapr had monoid once, was a terrible disease
05:19:39 <goron> You are truly living up to your title :)
05:19:43 <tromp> a monoid is a group without inverses
05:19:52 <shapr> er, what's my title?
05:19:59 <shapr> Shapr, Boy of Destiny?
05:20:02 <goron> I'm a Rebel without a Clue!
05:20:05 <shapr> oh, that :-)
05:20:31 <goron> shapr: Ever read about metacat?
05:20:50 <shapr> Mono is the commonly used name of the disease 'mononucleosis' in the US
05:21:14 <shapr> sounds vaguely familiar... what's Metacat?
05:21:39 <goron> shapr: It's a program that makes analogies in a microworld of letters.
05:21:53 <goron> shapr: It's AI like, but nowhere near GOFAI.
05:22:15 <shapr> this one? --> http://www.cs.pomona.edu/~marshall/metacat/
05:22:44 <shapr> Based on work by Hofstadter, that's a nice recommendation :-)
05:22:45 <goron> yes
05:23:06 <shapr> this is a nifty idea
05:23:12 <goron> They are working on a successor. 
05:23:18 <goron> Yes
05:23:43 <goron> It explains "creativity" in a good way, imo.
05:24:14 <shapr> it explains metapatterns at least.
05:24:26 <shapr> I haven't seen any mention of creativity yet.
05:24:51 <goron> The paper begins to get boring after a few chapters. That's the only bad thing.
05:25:16 <Cale> A monoid obeys more rules?
05:25:43 <Cale> Monoids seem simpler than monads to me.
05:26:00 <goron> Cale: If you say it like this, then I will check my self-written paper again...
05:26:53 <Cale> A monoid is just a set with an operation which is associative and has an identity element.
05:28:28 <goron> Cale, That's what I said above.
05:28:36 <Cale> yeah...
05:28:38 <shapr> goron: this is a beautiful approach to creativity in AI
05:28:55 <shapr> I think a lot of good stuff will come out of this approach.
05:29:08 <musasabi> Why is it that there seems to be no connection between both putStrings and the getString in "proc p -> do { s <- getString -< p; putString -< s; putString -< s }"
05:29:12 <goron> Cale: A monad is more abstract than a monoid, imho.
05:30:20 <shapr> konichiwa LrdMtrod 
05:30:28 <goron> Cale: A monoid is more abstract :)
05:30:37 <musasabi> That seems to form a tree with putString and getString as children and one putString in the root, which is clearly wrong (from the dataflow perspective)
05:31:06 <Lemmih> GHC 6.3 is spiffy.
05:31:21 <Cale> Monads, at least at first glance, have more structure than monoids. They're functors in addition to having two operations which satisfy a collection of laws.
05:31:33 <goron>   T from C to C. A monad, also referred to as triple, triad or standard construction in the literature, on a category C is a monoid object in the category [C ! C] of endofunctors on C, and natural transformations between them.
05:32:15 <goron> Cale: Do you agree with this definition?
05:32:31 <Cale> sure.
05:32:52 <Cale> So monads can be seen as a particular kind of monoid.
05:32:56 <goron> Yes
05:33:36 <Cale> So monoids are structurally simpler.
05:33:44 <goron> Yes
05:33:48 <Cale> good :)
05:33:52 <goron> Great :)
05:34:03 <goron> Amazing :)
05:34:09 <goron> Superb :)
05:34:15 <Cale> and more abstract
05:34:19 <goron> Yes
05:35:10 <Cale> heh, a finite monoid is a puzzle that you can break
05:36:18 <goron> The weird thing with category theory is that the idea is complely simple, but when the human race puts labels on all kinds of combinations of dots and arrows, it becomes ridiculously hard. 
05:36:32 <goron> complelt->completely
05:37:23 <tuomov> much of math is obfuscated with labels
05:37:31 <Cale> Well, you sort of need to start labelling things in order to prove anything interesting about categories unfortunately. There's not enough structure there at first for many general theorems.
05:37:38 <tuomov> and probably many other fields too
05:38:14 <tuomov> keeps you in job when no-one else can understand it without years' work
05:38:19 <Cale> I don't think that the goal is to obfuscate things. The goal is just to pick interesting things out enough so that we can say something.
05:39:05 <tuomov> obfuscation is not necessarily intentional
05:39:25 <tuomov> people just start using weird names when it might be better to just keep to simple terms
05:39:53 <tuomov> same with strange loan words that nobody knows..
05:40:18 <tuomov> makes you seem wise when you can speak with words that no-one else knows what they mean
05:40:32 <Cale> For example, in ring theory, the concept of a ring is formed so as to generalise the notion of addition and multiplication on the integers. But while the initial definition is nicely abstract, it's almost impossible to prove much without restricting it in any way. There aren't many properties that all rings satisfy.
05:42:56 <shapr> goron: this is deeply fascinating
05:44:46 <shapr> goron: any idea if this has been applied to real-world problems?
05:44:50 <goron> shapr: I knew you would like it. 
05:44:56 <Cale> Also, if mathematics stuck to ordinary language for trying to describe anything, I can't see how we'd ever get any work done.
05:45:14 <goron> shapr: I don't think so. But they have a project called Letter Spirit. 
05:45:37 <Cale> A large part of the idea is to make things precise and that requires making definitions.
05:45:50 <shapr> I'd apply this to cancer cell diagnosis, I think it would work very well there.
05:46:23 <goron> shapr: Input, for example: A grid of bytes, that should stand for the letter a and b. So a part of a font, and then it creates the rest of the letters in "the same way".
05:46:56 <shapr> most impressive is the metapattern ability. In essence, it's able to apply solutions across domains.
05:47:23 <goron> shapr: I think it's possible to create a "logic" in this way that can represent any logic. This would be some metalogic. 
05:47:36 <shapr> That's how I approach solutions. A solution pattern in programming is equally applicable to washing dishes, imho.
05:47:44 <Russell> hi there :D
05:47:53 <shapr> y0 Russell!
05:48:13 <goron> Wazaa! (no seriously hi)
05:49:34 <shapr> goron: example of this from yesterday, I decided to apply garbage collection to my room, my new pattern is "Once a week take everything off of your desk and put it into 'midterm' storage. During the week take stuff out of midterm storage and put it back on your desk. Last step of the week is to take all the remaining things in midterm storage and move them to long term storage (like the cellar). repeat"
05:50:45 <shapr> I sort all the dishes when putting them into the dishwasher because it's a lot faster to put them back in the cabinets when they're clean.
05:51:13 <shapr> Does everyone do that sort cross-domain solution application?
05:51:18 <goron> shapr: It's quite efficient to organize your life in such a way, but I only built up some value of unhappiness about my room, and then do everything at once. (That's my algorithm :) )
05:51:26 <shapr> haha
05:51:47 <tuomov> I collect garbage when I'm out of free space :)
05:51:52 <shapr> stop-and-grumble garbage collection?
05:51:56 * shapr laughs
05:52:29 <goron> tuomov: That's my strategy for my harddisc. (And buying a larger harddisc too :) )
05:52:32 <shapr> My basic idea behind desk garbage collection is that the most used things should be easiest to access.
05:53:08 <goron> shapr: It's even possible to prove that property :)
05:53:38 <goron> shapr: If you assume that all garbage collecting algorithms take up an equal amount of time.
05:53:47 <shapr> they don't
05:54:02 <shapr> I've realized that speculative evaluation is usually the cheapest.
05:54:15 <shapr> at least, in everyday life.
05:54:33 <shapr> in short, "do something as soon as you know it needs to be done"
05:54:42 * dons is sleepy. changing a comment doesn't change the implementation, usually
05:54:48 <shapr> ha
05:55:10 <bringert> hmm, that would be nice though
05:55:54 * bringert starts thinking about natural language stuff for commenting code, or checking code against comments
05:56:21 <shapr> I'd like to put QuickCheck or HUnit tests into comments, or just into the file.
05:56:28 <shapr> and have the outputs show up in Haddocks
05:57:15 <shapr> dons: is the :w code recorded?
05:58:56 <dons> not yet.
06:01:35 <shapr> goron: Upon first reading, I think Metacat self-perception of patterns needs to be parallel rather than after the fact. Right now it can perceive its own patterns, but it needs to be able to perceive its formation of patterns too.
06:03:26 <goron> shapr: Ofcourse, the more patterns it has access too and the sooner, the better it could work. I am glad someone on this world was so smart to come up with something non-traditional.
06:03:33 <goron> too->to
06:04:32 <shapr> the hard part would be writing something that can create its own new patterns by observing inputs.
06:05:51 <shapr> For example, Max Planck's pattern leap of claiming that heat/light came in discrete packets, when science had been claiming continuousness forever.
06:06:54 <shapr> Greetings Agent Ray
06:06:59 <CosmicRay> does anyone associated with the crypto library hang out here?
06:07:08 <CosmicRay> you are so dead, Morpheus.
06:07:11 <LrdMtrod> shapr: konichi wa
06:07:23 <shapr> It's only Dominic Steinitz, isn't it?
06:07:33 <goron> shapr: Well, I think that what science claimes is irrelevant w.r.p. to some intelligent agent(human or non-human).
06:07:33 <CosmicRay> I think so, but it's hard to tell
06:07:45 <goron> .p->t.
06:07:59 <shapr> the ACKs in cryptolib are bits of code he collected from elsewhere.
06:08:00 <goron> p.->t.
06:08:13 <shapr> .t->p
06:08:17 * shapr wonders if this is a math proof game
06:08:32 <shapr> q.p->t.q ?
06:09:05 <goron> Wonders on what platform shapr is running...
06:09:25 <shapr> ShaprOS! A new shape everyday!
06:10:05 <shapr> CosmicRay: why? you want to package cryptolib?
06:10:39 <goron> Pretty dump question: shapr stands for shaper?
06:11:10 <shapr> yup
06:11:25 <shapr> and Shae stands for shapr
06:11:27 <pesco> It's just so his nick is the same length as ours'. :)
06:11:33 <earthy> hm. I love having nice backgroundable pictures taken on walks in the woods, on holidays etc.
06:12:13 <pesco> "backgroundable". Great.
06:12:39 <earthy> yeah... there's about 4 of them out of the 457 we took last week :)
06:12:41 <goron> My nickname is also the same length, although on #debian, they found it to look too much on moron :)
06:12:59 <pesco> Morons.
06:13:02 <earthy> :)
06:14:26 <kristnjov> gargoyle
06:14:27 <kristnjov> gorgon
06:15:17 <musasabi> Is there any info how to really really draw things from arrows?
06:16:35 <earthy> owh gawd... `Archer, emmissary of the Gorgonites' out of `Small Soldiers'
06:16:40 <musasabi> Currently I can get to the resolution of http://www.cs.helsinki.fi/u/ekarttun/haskell/SPDraw.png, but something would be needed to handle the plumbing in correct fashion, mainly bypassing.
06:16:48 <earthy> I thought I had succesfully wiped that from my brain...
06:17:06 <CosmicRay> shapr: yes
06:17:16 <CosmicRay> shapr: actually I want to either package it or include it in MissingH
06:18:45 <shapr> musasabi: Ross put pictures on the arrows page
06:18:54 <CosmicRay> shapr: either way, there is some ambiguity about the licenses for parts of it
06:18:58 <CosmicRay> shapr: I just want to get that resolved
06:19:00 <shapr> which parts?
06:19:16 <CosmicRay> *Aux.hs have no license/copyright stated at all
06:19:33 <CosmicRay> the stuff Dominic wrote refers to a "BSD-like" file named LICENSE that is not included in the distribution
06:20:04 <CosmicRay> I think he means the libraries/base/LICENSE from ghc6, but I'm not certain, and it contains several BSD-style licenses
06:20:08 <musasabi> shapr: but those are probably hand-drawn.
06:20:17 <pesco> I have a dumb question. What does i.e. stand for?
06:20:23 <ibid> id est
06:20:31 <musasabi> What I want is to create a dataflow diagram from an arrow based program.
06:20:35 <CosmicRay> pesco: it means "that is"
06:20:39 <pesco> Good. Then I've been using it correctly. :)
06:20:41 <ibid> yeah
06:21:20 <pesco> I suddenly wasn't sure anymore whether I'd actually known that or just guessed... ;-)
06:22:01 <shapr> CosmicRay: does he say where Aux.hs comes from?
06:22:20 <Oejet_> Oh, no! Brandon J. Van Every is back in c.l.functional.
06:22:32 <ibid> though i've been told that id est is unidiomatic latin in such contexts as where i.e. is used in english ;)
06:22:57 <shapr> Oejet_: oh no, is he that complete nutcase who is trying to drive his world view into everyone around him?
06:22:59 <pesco> Hm, ok, I don't know about that, really. My latin is flaky at best.
06:23:07 <CosmicRay> shapr: no, though the *Aux.hs files are things like MD5Aux.hs, and there are copyright statements for MD5.hs
06:23:12 <Oejet_> shapr: Yep.
06:23:15 <earthy> shapr: that nutcase, yes
06:23:17 <CosmicRay> shapr: however I can't just extrapolate that these are the same
06:23:27 <earthy> the indiegames.com guy
06:23:52 <shapr> He's the one that pissed off the entire Python community, resulting in Guido asking him to leave, right?
06:24:10 <Oejet_> shapr: Yep.
06:24:25 <shapr> hoi swiert 
06:24:27 <Igloo> Cryptolib is built from libraries from 3 or 4 people - I think they're listed at the bottom of the webpage
06:24:32 <swiert> hi shapr
06:24:41 <shapr> how's your portuguese?
06:25:01 <shapr> Everyone should just killfile Brandon J. Van Every.
06:25:03 <swiert> not that great - I used to speak a few words when I was < 2
06:25:22 <earthy> Acho que swiert nao comprendo isso. :)
06:25:43 <earthy> s/comprendo/comprendera/ (IIRC)
06:25:52 <shapr> It's like, if you piss off an entire language community and they kick you out... You're doing something wrong.
06:25:59 <swiert> I speak spanish - so I can make out a few words.
06:26:19 <shapr> At least BJvE has decided to aim for OCaml this time, and not Haskell.
06:26:31 * shapr selfishly protects his own language community.
06:27:38 <shapr> There's a very small number of people who fit into that category.
06:28:13 <musasabi> BJvE said something about "not being as interested in OCaml as he once was" a short time ago.
06:28:21 <musasabi> So you may not be safe.
06:28:25 <shapr> Thaddeus L. Olczyk, and Aryeh M. Friedman are possibles.
06:28:29 <vivek> shapr: english ?
06:29:02 <vivek> Ocaml is a functional language isnt it ?
06:29:05 <shapr> Of course, I wasn't the easiest person to get along with in my younger years, so I like to think that people get better.
06:29:32 <earthy> this BJvE guy gives me the distinct feeling that he doesn't learn
06:29:37 <shapr> Hopefully BJvE will direct his boundless enthusiasm towards more productive pursuits.
06:29:51 <vivek> Lua Ocaml haskell ... i dont know any others which might be functional ...
06:29:52 <shapr> "hermetically sealed" is the expression I use.
06:30:01 <Oejet_> > What happend to your OCaml projects?
06:30:02 <Oejet_> You asked, so...
06:30:02 <Oejet_> It has taken me 1 year to realize that I'm a fundamentally low-level ASM
06:30:02 <Oejet_> kind of guy, always have been, and will yet be for some time.
06:30:14 <vivek> shapr: u rememebre ur science lessons obviously 
06:30:26 <shapr> My science lessons?
06:31:08 <vivek> hermatically sealed is usually used in science ... 
06:31:21 <CosmicRay> BJvE?
06:31:24 <vivek>  /s /hermatically /hermetically 
06:31:26 <CosmicRay> oh.
06:31:32 <CosmicRay> he is damn annoying
06:31:36 <CosmicRay> where had you seen him before, shapr?
06:31:41 <CosmicRay> haha
06:32:06 <pesco> Wow, BJvE is a "real" Windows developer!
06:32:21 <arjanb> it's busy here :-)
06:32:37 <CosmicRay> shapr: BJvE pissed off the entire FreeCiv community too
06:32:41 <shapr> wow
06:32:44 <CosmicRay> shapr: and we, uhm, asked him to leave.
06:32:45 <shapr> what did he do to FreeCiv?
06:33:11 <CosmicRay> basically the same thing he does everywhere else: complain about its Windows support and features it doesn't have that nobody else cares about, say it's bad for business, and refuse to do anything about it
06:33:21 <shapr> seen that before
06:33:36 <CosmicRay> freeciv was the first place I saw him (I run the mailing lists for freeciv.org)
06:33:58 <shapr> does gmane.org have a c.l.f mirror?
06:34:09 <CosmicRay> clf = comp.lang.?
06:34:11 <shapr> my ISP doesn't have a usenet server :-(
06:34:14 <shapr> functional
06:34:24 <CosmicRay> no, but give me a sec and I'll give you some that do
06:34:34 <shapr> spiffy
06:34:35 <arjanb> shapr: google has
06:35:11 <CosmicRay> shapr: http://news.individual.net/
06:35:27 <CosmicRay> shapr: they have free access to the big eight, except for binaries
06:35:33 <vivek> shapr: cant u use google groups ?
06:35:38 <CosmicRay> shapr: you just have to register a free account, then yuo get full nntp 
06:35:47 <CosmicRay> shapr: they don't archive it like gogle does; it's a regular news server
06:36:45 <shapr> neato
06:37:37 <Oejet_> Hm, I feel a bit like a troll for posting that news about BJVE. :-(
06:37:58 <CosmicRay> Oejet_: you're not a troll.  I don't see anyone flaming you. :-)
06:38:01 <vivek> Oejet_: its ok :)
06:38:08 <vivek> u informed us ... 
06:38:19 <CosmicRay> I think our reaction is more of, "Ah.  We expected that would happen." 
06:38:27 <vivek> information is never bad 
06:38:37 <CosmicRay> vivek: it is if your name is "Bush"
06:39:03 <vivek> haha i dont know is bush bad ?
06:39:20 <vivek> it dosnt affect my universe ... not too much ...
06:39:35 <CosmicRay> vivek: this is a literal quote from a recent debate: "I hear there's rumors on the Internets."
06:40:13 <vivek> but its gonna be fun ... to watch the polls 
06:40:13 <CosmicRay> vivek: that's just one example -- see bushisms.com :-)
06:40:35 <vivek> haha seacch google for stupid ...
06:40:55 <vivek> or was it idiot ...
06:42:18 <vivek> its the second link for idiot ...
06:42:48 <musasabi> hmm found the problem.. Seems arrows are not enough :-(
06:42:54 <shapr> musasabi: eh?
06:43:39 <musasabi> shapr: things like first are arrow operators but things like "arr fst" which is the negation are not, so getting the wiring right seems impossible.
06:43:41 <Boegel> vivek: Idiot son of an *assh*ole !
06:43:44 <Oejet_> its the third link for stupid.
06:44:27 * vivek goes to a corner and sulks ...
06:44:29 <shapr> musasabi: this sounds interesting enough to mention to Ross or John :-)
06:45:07 <musasabi> or maybe I need to define different arrows for printing and running (defined in modules with identical signatures)
06:51:21 <musasabi> e.g. with "putString <<< arr snd <<< first putString <<< arr (\x -> (x,x)) <<< getString" which is what "proc p -> { do s <- getString; putString -< s; putString -< s }" might be simplified into, there is no real way of saying that the dataflow just based on the arrows
06:52:31 <musasabi> This is because "arr :: (i -> o) -> a i o" takes a function which has no identify so we cannot do different stuff depending what it is
06:52:45 <shapr> no identify?
06:53:14 * desrt yawns, evily
06:53:23 <musasabi> shapr: meaning that arr cannot know anything about the argument it is given
06:53:59 <shapr> could you specify arrow constraints?
06:54:29 <musasabi> I don't think they are comparable with the typeclass.
06:54:33 <musasabi> *compatible
06:54:49 <shapr> what constraints would be required?
06:55:49 <musasabi> or maybe those branches could be deduced from statical knowledge..
06:56:27 <Oejet_> Hm, CosmicRay and vivek, I think you are right, because a real troll would present a statement that at least someone doesn't agree with. :-)
06:56:55 <musasabi> we know we have a pair @ first and for our primitive operations we know their input "arity"
06:57:58 <goron> http://news.bbc.co.uk/2/hi/asia-pacific/3755154.stm
06:58:52 <shapr> dons: defaultKeyMap :: FiniteMap Key Action ?
06:59:31 <shapr> musasabi: I'm still slightly lost, but trying to keep up :-)
07:00:09 <CosmicRay> Oejet_: yup :-)
07:01:30 <musasabi> shapr: I would want to see that no data is passed from the first putString to the second putString (not counting hidden state)
07:03:31 <Igloo> shapr: You probably want a trie
07:03:47 <dv> gmake install of ghc-6.2.2 is failing because it can't find "../../glafp-utils/mkdirhier/mkdirhier" ... am i missing something?
07:03:49 <Igloo> So you can tell if you have a set of characters which aren't a prefix of a command
07:03:51 <Igloo> s/set/list/
07:04:28 <CosmicRay> dv: hmm, gmake all should have built that
07:05:52 <shapr> Igloo: data defaultKeyMap :: FiniteMap Key (defaultKeyMap | Action) ?
07:06:15 <dv> CosmicRay: i'll try to build it again
07:06:30 <Igloo> Ermm, something like
07:07:09 <Igloo> data Trie = Trie (FiniteMap Key (Either Action Trie))
07:07:10 <shapr> is a Trie easier to update?
07:07:27 <shapr> ok
07:07:37 <shapr> dons: hey, you recorded the :w code?
07:07:53 * shapr wonders if dons has fallen asleep and is dreaming editor dreams
07:08:04 <shapr> pesco_: your evil twin is here!
07:09:06 <CosmicRay> dv: you can also try running gmake in the mkdirhier or glafp-utils directory
07:10:23 <shapr> what time is it in .au?
07:10:46 <Boegel> does anyone have any experience with installing tcl/tk ?
07:10:46 <CosmicRay> where in .au?
07:10:52 <shapr> um, unsw
07:10:58 <shapr> so, NSW
07:11:10 <CosmicRay> $ TZ="Australia/Melbourne" date
07:11:11 <CosmicRay> Thu Oct 21 00:17:25 EST 2004
07:11:19 <CosmicRay> I don't know if that's in NSW, but it should be within an hour of them
07:11:19 <shapr> ok
07:11:29 * shapr suddenly wants a timezone plugin for lambdabot
07:11:39 <pesco_> 1What the hell.
07:11:56 <CosmicRay> oh here we go
07:12:09 <CosmicRay> $ TZ="Australia/NSW" date
07:12:09 <CosmicRay> Thu Oct 21 00:18:29 EST 2004
07:12:44 <shapr> does dat have a lookup table for the country/state part?
07:13:12 <CosmicRay> well it is calling into libc for the tz stuff, iirc
07:13:17 <CosmicRay> it's in /usr/share/zoneinfo on my system
07:13:22 <shapr> eek
07:13:25 <CosmicRay> the TZ is just setting the environment variable TZ for this command
07:13:25 <shapr> yi segfaulted
07:13:45 <shapr> ah, spiffy
07:14:50 <shapr> what does this mean? "./yi-inplace: line 2: 17606 Segmentation fault      /home/shae/build/darcs/yi/yi -B/home/shae/build/darcs/yi $*"
07:15:30 <pesco> What is yi, shapr?!
07:15:38 <tuomov> hemacs renamed
07:15:42 <shapr> it's the new name for hemacs
07:15:43 <tuomov> again
07:15:44 <shapr> Y I
07:15:50 <shapr> I think this one will stick.
07:16:01 <shapr> I just gotta find my credit card and register funyi.org
07:16:03 <pesco> It's good.
07:16:17 * shapr is dangerous when he can remember where he left his credit card.
07:17:54 * Lemmih is thinking of a Cabal package module for lambdabot.
07:18:27 <shapr> hiya ralf 
07:18:36 <shapr> Lemmih: oh good idea
07:19:00 <Lemmih> '@hackage get author of HOpenGL' would be cool.
07:19:01 <shapr> lambdabot would be a lot easier to deal with if I would get around to switching to hs-plugins
07:19:48 * shapr finds bugs with yi
07:20:09 <shapr> Fail: user error (Curses[-1]:wmove)
07:20:30 <shapr> Lemmih: feel free to hack on lambdabot all you want
07:20:59 <tuomov> yeah, it dumps core
07:21:14 <ralf> hi shapr
07:21:34 <shapr> ralf: learning Haskell?
07:23:23 <shapr> talk of carefully structuring a wiki feel strange to me.
07:23:44 <shapr> wiki is totally IETF-style, imho.
07:23:45 * Lemmih is away: Unicycling.
07:23:51 <Lemmih> IETF?
07:24:00 <shapr> 'rough consensus, running code'
07:24:01 <Lemmih> @jargon IEFT
07:24:01 <lambdabot> Sorry, I don't know the command "jargon", try "lambdabot: @listcommands
07:24:04 <ralf> shapr:  Yes.  haskell is my life, at least for the next couple of days. 
07:24:16 <ralf> shapr, remind me of your meat-space identity?
07:24:16 <shapr> just do it, if it sucks, someone will fix it.
07:24:27 <shapr> ralf: I am the shaper! I have no meat-space identity.
07:24:39 <shapr> ok seriously, I'm Shae Erisson.
07:24:46 <shapr> Ever heard of me?
07:24:49 * shapr doubts it
07:25:00 * shapr is the secret haskeller!
07:25:12 * shapr shuts up and goes back to fixing yi
07:25:13 <ralf> Cool.  I am a friend of syntax who frequents here. 
07:25:18 <ralf> You may know syntax. 
07:25:31 <Lemmih> The ninja?
07:25:32 <ralf> I am trying to take his job in columbus ohio while he moves out west. 
07:25:37 <shapr> from such famous band as "The Debian Maintainer Who Joined the Circus"
07:25:44 <shapr> ralf: ah cool
07:26:03 <ralf> Yeah, so I have to study mad haskell from now until the second interview.  
07:26:04 <shapr> ralf: any idea if aetion is likely to contract out some gruntwork to overseas teleworkers?
07:26:10 <ralf> I'm looking foward to the challenge. 
07:26:20 <shapr> ralf: how long do you have?
07:26:32 <ralf> shapr, no comment on outsourcing. 
07:26:38 <shapr> heh, ok
07:26:48 <ralf> shapr, a week
07:26:51 * shapr hadn't realized he was an outsourcer.
07:27:11 <shapr> Cool, I'm an OutSource, hopefully not related to an OutHouse.
07:27:12 <xkb> a week to learn haskell completely?
07:27:26 <xkb> from scratch?
07:27:37 <shapr> ralf: how much prior Haskell experience do you have?
07:27:45 <ralf> xkb, not completely and not from scratch. 
07:27:53 <xkb> ralf, ah ok :D
07:28:07 <ralf> I spent about a week (a solid week though) working throguh hudak's book
07:28:25 <ralf> Also, I read SICP by Sussman and Abelson, so I am familiar with the concepts. 
07:28:39 <ralf> I just need to learn it well enough so they hire me, however well that is. 
07:28:43 <ralf> So I'll learn it as well as I can. 
07:28:51 <ralf> My goal is to master the first half of this book. 
07:29:01 <xkb> ralf, who are "they"?
07:29:13 <ralf> The company is called Aetion. 
07:29:30 <vivek> they use functional programming ?
07:29:33 <vivek> cool 
07:29:38 <xkb> yeah.. cool!
07:29:39 <shapr> ralf: well, I'm going to send my resumé to aetion, I'll tell you if they actually respond. I seriously doubt they'll send any work overseas since most of their work requires US Citizens who actually live in the US. 
07:29:54 <shapr> I'm from Alabama, but I live in Sweden, doubt that counts.
07:30:40 <vivek> which is the best book on haskell so far ?
07:30:54 <shapr> probably Hudak if you want dead tree.
07:30:58 <ralf> shapr, Can you write a short haskell program for me? 
07:31:05 <shapr> ralf: I can do much more than that.
07:31:11 <xkb> shapr, and without dead tree?
07:31:12 <shapr> ralf: you just have to ask me for the tour =)
07:31:19 <ralf> Oh yeah? 
07:31:26 <ralf> shapr, tour, huh? 
07:31:28 <xkb> the tour rocks ;-)
07:31:29 <shapr> xkb: Hal Daume's YAHT is the best live lectron edition.
07:31:35 <vivek> shapr: i asked for one yday u never obliged 
07:31:41 <xkb> shapr, I will look it up
07:31:42 <shapr> vivek: oh, I'm sorry...
07:31:50 <shapr> you guys want the tour?
07:31:52 <ralf> shapr, GIMME THE TOUR!!!
07:31:57 <shapr> w00!
07:32:02 <shapr> ok!!
07:32:25 <vivek> yeah 
07:32:30 <shapr> the first stop on this tour, and probably the most important... is the learning page at http://www.haskell.org/learning.html
07:32:32 <vivek> its about time 
07:32:57 <shapr> That's a collection of the best resources for picking up Haskell.
07:33:05 <shapr> Next on the tour we have The Haskell Wiki!
07:33:26 <shapr> Everyone's favorite collaborative tool houses gobs of useful information for both beginners and long-time experienced users.
07:33:51 <shapr> Some useful pages include the list of concepts, the question and answer pages, and ... well lemme grab some urls.
07:34:27 <xkb> darn he did not yet start his advanced techniques part
07:34:35 <shapr> who didn't?
07:34:42 <xkb> Hal Daume
07:34:51 <xkb> or I have an older version
07:35:18 <shapr> Dang, what's the name of the basic concepts page on the wiki?
07:35:27 <shapr> I'm the wiki maintainer, I should really know this...
07:35:40 <vivek> yet another haskell tutorial 
07:35:40 <vivek> hehe 
07:36:05 <shapr> aha http://www.haskell.org/hawiki/FundamentalConcepts
07:36:27 <shapr> That page is handy as a list of things to understand, and some of them have explanations on the wiki itself.
07:37:03 <shapr> There more goodies on the wiki, http://www.haskell.org/hawiki/HaskellNewbie and http://www.haskell.org/hawiki/LearningHaskell for example
07:37:31 <vivek> hmmz can we skip ahead of the wiki ? 
07:37:54 <shapr> The last two stops on our tour focus on the #haskell channel itself, first we have the logs of channel conversation http://tunes.org/~nef/logs/haskell/ or the pretty version at http://tunes.org/~coreyr/
07:37:56 <vivek> http://www.haskell.org/hawiki/
07:38:12 <shapr> Last we have lambdabot, the ever friendly and useful tool!
07:38:27 <vivek> already met him 
07:38:32 <vivek> @moo 
07:38:33 <lambdabot> Sorry, I don't know the command "moo", try "lambdabot: @listcommands"
07:38:34 <shapr> lambdabot has three useful features, @type, @index, and @info
07:39:13 <shapr> all three of which probably won't work until I rebuild lambdabot with ghc 6.2.2 =)
07:39:14 <vivek> ah tnx that was informative :)
07:39:17 <tromp> @index index
07:39:17 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
07:39:24 <shapr> just a moment...
07:39:25 <shapr> lambdabot: @quit
07:39:45 <vivek> maybe the haskell tour deserves to be it the wiki ...
07:39:51 <shapr> right, like I thought ... "mismatched interface file versions: expected 6022, found 6021"
07:41:24 * shapr rebuilds lambdabot
07:41:42 <shapr> I just upgraded ghc6 on snowblind, so...
07:42:08 <vivek> hmmz i wonder what snowblind is ...
07:43:34 <shapr> snowblind.ScannedInAvian.org is the host machine for lambdabot, AvianWiki, a bunch of darcs repos, the running Flippi, and a bunch of other stuff.
07:44:28 <shapr> and my website, my blog, ec
07:45:16 <shapr> sadly, snowblind is a 600MHz machine doing a lot of other stuff, so it takes awhile to build lambdabot
07:46:32 <ralf> shapr, what is your website? 
07:47:39 <shapr> http://www.ScannedInAvian.org/
07:48:10 <vivek> scannedinbird.org ....
07:48:19 <vivek> thats easy to remember ...
07:49:32 <shapr> vivek: do you know what the countries sweden, norway, finland, and denmark are called together?
07:50:11 <vivek> scandinavia 
07:50:52 <vivek> well that dosnt help me with the scanned in part so its just a pneumonic for my avian brain to grap ...
07:51:15 <shapr> The name comes from an IRC joke where I said I'm a penguin (linux user) living 99% on the internet, and 1% in Sweden, so I'm a Scanned In Avian.
07:51:19 <vivek> and i never use bookmarks they tend to rot in hell 
07:51:40 <vivek> haha 
07:52:01 <vivek> maybe u should have got a .com :)
07:52:09 <shapr> I got that too
07:52:29 <tuomov> actually, finland is not part of scandinavia
07:52:34 <tuomov> as far as I know
07:52:42 <shapr> huh, neat
07:52:43 <tuomov> but scandinavia+finland+iceland = the nordic countries
07:53:22 <Oejet_> (+ Faero Islands?) (ABC?)
07:53:35 <tuomov> aren't they part of denmark?
07:53:39 <vivek> maybe scandinavia will invade finland and icelad in the next world war and annex them both .. haha
07:53:56 <ibid> tuomov is correct
07:54:20 <bringert> they have home rule though (IIRC)
07:54:33 * vivek realises no war is fun ...
07:54:35 * shapr also stays at home as a rule.
07:54:43 <Oejet_> tuomov: Well, yes, and so is Greenland, but they are much autonomous (except for the funding from DK).
07:54:48 <ibid> scandinavia is the peninsula where sweden and norway are
07:55:10 <abstrato_general> I just installed Hugs and am trying to follow the tutorial at haskell.org
07:55:13 <shapr> Greetings Abstrato.
07:55:25 <vivek> hello abstrato_general 
07:55:30 <Oejet_> ibid: And Danes aren't vikings ;-)
07:55:31 <abstrato_general> but I seem to get at a Prelude prompt, and I don't know what to do from there.
07:55:37 <abstrato_general> hello, shapr and vivek :)
07:56:01 <shapr> can you run hugs?
07:56:02 <abstrato_general> anyway, back to kvetching, the Prelude prompt seems to expect something from me not mentioned in haskell tutorials.
07:56:29 <shapr> what's the problem? what do you type, and what do you expect?
07:56:36 <abstrato_general> yep, I can run hugs. it gets me to a Prelude> prompt.
07:56:59 * abstrato_general is getting confused now, and feeling kinda stupid :-O
07:57:14 <shapr> what do you type at the Prelude> prompt?
07:58:01 <vivek> what do u expect the prelude to do abstrato_general ?
07:58:02 <abstrato_general> the tutorial at http://www.haskell.org/tutorial/goodies.html seems to imply "inc n = n+1" is a valid function declaration.
07:58:22 <shapr> It is a valid function declaration, but you need to put it into a file and load the file.
07:58:39 <abstrato_general> uh, I'm totally confused now. What does the hugs "interpreter" do, as opposed to (uh, so sue me) a Basic interpreter or a Python interpreter?
07:58:40 <abstrato_general> oh.
07:59:12 <abstrato_general> I might be getting everything wrong. 
07:59:39 <ralf_> shapr, Thanks for the great tour. 
07:59:57 <shapr> ralf_: do you have any questions?
08:00:04 <Oejet_> abstrato_general: "let inc n = n+1"
08:00:14 <shapr> Oejet_: does that work in hugs?
08:00:41 * Oejet_ ducks and pretends he is not here :-)
08:00:56 <Oejet_> Sorry.
08:01:04 <vivek> shapr: works in ghci 
08:01:11 <shapr> I think it only works in ghci
08:01:17 <abstrato_general> oh. It works.
08:01:24 <Oejet_> Huh?
08:01:27 <abstrato_general> not "let", but saving it in a file and loading.
08:01:46 <Oejet_> Ah, so I'm still dumb.
08:02:17 <abstrato_general> you're not alone.
08:02:38 <Oejet_> I am here with you
08:03:13 <vivek> shapr: how long have u been messing with haskell ?
08:03:46 <Lemmih> About two years.
08:04:11 <vivek> thats plenty of time ... 
08:04:40 <shapr> vivek: three years?
08:05:00 <shapr> about three years, twenty-five weeks.
08:05:42 <Lemmih> Oh well. I came pretty close to the right answer (-:
08:05:46 <shapr> :-)
08:06:01 <vivek> em i was stupid not to have tried haskell a long time ago i never knew about haskell i was happy in language blurb ...
08:06:19 <shapr> It's good to explore new languages.
08:06:34 <Oejet_> ...and old ones.
08:06:42 <shapr> yes
08:06:42 <ralf_> shapr, Well, should I read the logs, or just dig when I need something? 
08:06:48 <vivek> and i looks insane to have not done this earlier .. 
08:06:49 <abstrato_general> I like to "explore" new languages once in a while.
08:07:04 <abstrato_general> I'm fond of Ruby.
08:07:09 <shapr> My two other languages of interest right now are Epigram and Joy.
08:07:20 <abstrato_general> but, uh, Ruby just looks like a radicalization of things seen elsewhere.  Haskell seems so foreign.
08:07:22 <vivek> ralf_: they are pretty useful if u ignore the useless stuff 
08:07:56 <vivek> shapr: what do they have which makes u interested it them ?
08:08:04 <shapr> ralf_: depends on what you need, the logs are huge. Digging on google might be easier, and then asking here if you can't find something.
08:08:23 <ralf_> shapr, I could really use a short haskell program that reads a textfile, say input.txt in dot, into a list of lines, and then outputs them, say to output.txt in dot. 
08:08:31 <shapr> vivek: Epigram has a dependent typesystem, and Joy is a postfix concatenative stack-based purely function language.
08:08:34 <ralf_> shapr, that way I can parse stuff with haskell
08:09:07 <vivek> shapr: can u list all the functional languages around ?
08:09:31 <shapr> ralf_: lemme throw something together.
08:10:11 <shapr> ralf_: interact is probably your best bet
08:10:24 <shapr> @type interact
08:10:32 <shapr> oh right, I haven't fixed lambdabot yet.
08:11:00 <shapr> vivek: there are quite a few... might be better to check out one of the directories like dmoz
08:11:10 <abstrato_general> so, um, how do I write a Haskell function that returns the sum of the squares of the elements of a list?
08:12:30 <dv> sum $ map (\x -> x^2) list
08:12:51 <abstrato_general> um, apparently I need to read some more tutorial to get it.
08:13:03 <abstrato_general> anyway, I was jumping at it too soon. Sorry :-)
08:13:12 <ralf_> abstrato_general, Well, there are more transparent ways to solve the problem. 
08:13:17 <shapr> CosmicRay: what was it you did to get interact to do line-by-line ?
08:13:21 <ralf_> abstrato_general, do you know anything about functional programming. 
08:13:23 <ralf_> ? 
08:13:55 <abstrato_general> I've used spreadsheets, and read the tutorial at http://www.haskell.org/tutorial/goodies.html once, six months ago.
08:14:27 <abstrato_general> I once learned a bit or two about Lisp.
08:14:29 <shapr> I can't remember why this happens - "DummyModule.o: unknown symbol `__stginit_Prelude_' \n symbol resolution failed"
08:15:09 <abstrato_general> I was just toying around with lists, and it struck me I should write a standard deviation function.
08:16:40 <abstrato_general> as you might know, stddev(x) = sum((x-avg(x)^2)
08:16:41 <ralf_> abstrato_general, well, summing squares seems like a really natural thing to do with lists. 
08:16:54 <ralf_> abstrato_general, First, you have to understand map. 
08:16:59 <abstrato_general> anyway, I'll be doing some more reading.
08:17:19 <ralf_> abstrato_general, map has type (a->b)->[a]->[b].  Does that make any sense? 
08:17:33 <ralf_> abstrato_general, maybe not.  But map is pretty simple. 
08:17:37 <abstrato_general> yep. I did skim through the turial, as I said.
08:18:08 <ralf_> abstrato_general, good.  Then you can understand map.  Map is what you use when you want to apply a function to each element of a list. 
08:18:18 <ralf_> abstrato_general, The first thing that you want to do is to square each element of your list. 
08:18:24 <abstrato_general> like dot operators in Matlab? 
08:19:00 <ralf_> So you write a function square which has type Float->Float.  Then you map it over the list. 
08:19:16 <ralf_> abstrato_general, can't help you.  I don't know matlab. 
08:19:29 <abstrato_general> well, it pretty much seems like it.
08:19:56 <abstrato_general> My programming background is writing neural networks and genetic algorithms in Matlab.
08:20:22 <Oejet_> @eval map (\x -> x*X) [2,4,7,3,4]
08:20:22 <lambdabot> type error
08:20:37 <Oejet_> @eval map (\x -> x*x) [2,4,7,3,4]
08:20:37 <lambdabot> [4, 16, 49, 9, 16]
08:20:44 <ralf_> square :: Float->Float
08:20:44 <ralf_> square x = x*x
08:20:44 <ralf_> y = map square [1..10]
08:21:12 <abstrato_general> heh. lambdabot is a haskell interpreter? :-D
08:21:19 <tromp> @index index
08:21:20 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
08:21:25 <Oejet_> @eval let square x = x*x
08:21:25 <lambdabot> (line 1, column 14):
08:21:25 <lambdabot> unexpected "="
08:21:25 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
08:21:25 <lambdabot>  "(", operator, simple term or end of input
08:21:29 * abstrato_general is a known bot abuser. Watch out for him.
08:22:50 <Oejet_> Hm, is lambdabot stateful; can one define new functions: let f x = x*x?
08:23:06 <ralf_> abstrato_general, If you are able to load a file into hugs, you can copy the example I gave you into a file and interpret it. 
08:23:07 <shapr> @get-definition square
08:23:07 <lambdabot> square = \x.x*x
08:23:28 <shapr> @get-definition cube
08:23:28 <lambdabot> cube not defined
08:23:38 <shapr> @define cube = \x.x*x*x
08:23:38 <lambdabot> (line 1, column 2):
08:23:38 <lambdabot> unexpected "="
08:23:38 <lambdabot> expecting space or simple term
08:23:41 <shapr> whoops
08:24:27 <shapr> @define cube \x.x*x*x
08:24:27 <lambdabot> cube defined
08:24:40 <Oejet_> shapr: Ah, thanks!
08:24:52 <shapr> I didn't write @eval, Derek Elkins wrote it.
08:25:03 <shapr> it's just a tiny lambda calculus interpreter.
08:25:17 <shapr> What's most impressive is how few definitions were needed to get it resembling Haskell.
08:26:25 <abstrato_general> it shouldn't be really hard to link an irc bot to a command-line interpreter like Octave.
08:26:30 <abstrato_general> now, that would be useful.
08:26:52 <abstrato_general> Octave is a matlab interpreter. Sorry.
08:26:57 <shapr> how would you handle something like \x . x x \x . x x ?
08:34:14 * shapr snores quietly
08:34:42 <shapr> musasabi: arrows and partial evaluation?
08:44:04 <Boegel> can I ask questions here on TclHaskell ?
08:44:15 <shapr> you can ask...
08:44:50 <Boegel> we'll, I'm trying to load a hello world application for FranTk, the GUI package for Haskell which is built on tcl/tk
08:44:56 <Boegel> and I get this error (in linux)
08:45:14 <Boegel> ERROR "/home/boegel/FranTkHannes/src/TclHaskellSrc/TclPrim.hs" - Error while importing DLL "/home/boegel/FranTkHannes/src/TclHaskellSrc/TclPrim.so":
08:45:14 <Boegel> /home/boegel/FranTkHannes/src/TclHaskellSrc/TclPrim.so: cannot open shared object file: No such file or directory
08:45:54 <shapr> does that file exist?
08:45:56 <Boegel> when I go check, there indeed is no TclPrim.so file
08:46:08 <shapr> maybe the build process didn't create it?
08:46:09 <Boegel> but why does FranTk go check for it then... :s
08:46:26 <Boegel> I didn't build FranTk
08:46:34 <Boegel> you only need the source as far as I know...
08:46:51 <shapr> try "cd /home/boegel/FranTkHannes/src/ && make TclHaskellSrc/TclPrim.so"
08:47:33 <Boegel> [root@localhost src]# make TclHaskellSrc/TclPrim.so
08:47:33 <Boegel> make: *** No rule to make target `TclHaskellSrc/TclPrim.so'.  Stop.
08:48:13 <Boegel> I did use tcl8.5, while the docs of FranTk say that it's builty for 8.0
08:48:14 <shapr> ok, cd TclHaskellSrc && make TclPrim.so
08:48:25 <Boegel> but that shouldn't be an issue, right ?
08:48:29 * shapr dunno
09:03:10 <abstrato_general> I never really got the hang of tcl. what is it good for?
09:03:47 <Oejet_> Love, what is it good for?
09:04:01 <abstrato_general> love is a very good patchset for the linux kernel.
09:04:16 <Oejet_> abstrato_general: Scripting.
09:04:22 <abstrato_general> it's somewhat unstable, but improves desktop responsiveness very significantly.
09:04:38 <abstrato_general> more information on www.love-sources.org
09:20:31 <danols_> anyone here is familiar with  context-free grammar ?
09:21:19 <monochrom> No. We only know context-sensitive grammars.
09:22:14 <danols_> monochrom i'm not sure if you are joking
09:22:49 <danols_> i need help with representing (a^n b^m c^n | n,m >0) 
09:24:20 <danols_> would this work ?
09:24:28 <danols_> S -> aB | Bc
09:24:33 <danols_> B -> B | b
09:24:59 <monochrom> Can your grammar generate abbc ?
09:26:09 <danols_> what is the difference between context-sensetive and context-free now i'm curious
09:26:15 <danols_> i've found some examples on the www
09:27:40 <monochrom> context-free is a special case of context-sensitive.
09:28:19 <danols_> This is different from a context-free grammar where the context of a nonterminal is not taken into consideration. 
09:28:27 <danols_> which means ?
09:30:17 <monochrom> In a context-free grammar your rule looks like <one single nonterminal> -> stuff.  Note the LHS is required to be one single nonterminal.  Can't have aSb -> stuff, SB -> stuff, etc.  This restriction is removed in context-sensitive grammars.
09:31:01 <danols_> i see
09:31:15 <danols_> so context free is a subset of context-sensitive ?
09:31:33 <monochrom> Yes.
09:31:36 <kosmikus> that's what monochrom said 3 minutes ago
09:31:53 <danols_> kosmikus forgive me but this is rather new stuff to me
09:32:03 <danols_> we are studing this in class acctually
09:32:08 <kosmikus> no problem
09:32:30 <danols_> can one just type this stuff into GHC ?
09:32:36 * ralf_ is signing off
09:32:37 <danols_> and see the result
09:36:03 <danols_> hopefuly you can bear with me guys, here it comes
09:36:28 <danols_> i understand how {a^n b^n | n > 0 } is S = aSb
09:36:58 <danols_> but i'm having a hard time trying to do the same thing with {a^n b^m c^n | n,m > 0}
09:37:22 <monochrom> I think it's the other way round.  You should bear with me.  I asked if your first attempt could deal with abbc.  Maybe you should answer that first.  Please bear with me.
09:38:03 <danols_> ok let me think for a second
09:38:22 <danols_> what i meant bear with me is that I am new to this
09:39:49 <danols_> monochrom it should be able to deal with it
09:39:58 <danols_> any string that's abbb....c ?
09:40:13 <monochrom> Show me the derivation from S to abbc.
09:40:18 <monochrom> Bear with me.
09:40:21 <danols_> ok
09:40:35 <danols_> what do you mean derivation (my english is second language)
09:40:51 <monochrom> (Sheesh every time someone says "bear with me" it suddenly puts him on the moral highground.  I may as well exploit that.)
09:41:06 <danols_> monochrom i thought i was being polite ?
09:41:17 <monochrom> I thought I was being polite too.
09:41:21 <monochrom> Bear with me.
09:41:22 <danols_> ok :)
09:41:23 <danols_> ok
09:41:26 <danols_> i'm all ears
09:41:31 * shapr wasn't being polite at all!
09:41:54 <Igloo> I was polite once, but I didn't like it.
09:42:03 <shapr> yah, I totally understand that.
09:42:13 <danols_> Igloo i can imagine, must a lot of repetative questions here
09:43:10 <monochrom> You have no word similar to "derivation", "derive", ... ?  Some sequence of using the grammar that goes like S -> ... -> abbc
09:43:27 * Oejet_ is in an evil mood
09:43:28 <danols_> i understand what the word means but i'm not sure what you are asking of me
09:43:58 <danols_> monochrom can you give me an example
09:44:05 <danols_> let's say S -> aSb
09:44:15 <monochrom> let's say I want aabb.
09:44:29 <danols_> ok
09:44:33 <monochrom> S -> aSb -> aaSbb   now I'm stuck, I need another rule.
09:44:39 <danols_> S -> aSb | empty string
09:45:01 <monochrom> ok cool.  S -> aSb -> aaSbb -> aa<empty string>bb  done.
09:45:08 <danols_> yes 
09:45:25 <danols_> but that also means the it can generate just <empty strign> right ?
09:45:30 <monochrom> Yes.
09:45:38 <danols_> cool
09:46:02 <danols_> because when {a^n b^n | n = 0 } = empty string (i'm just thinking out loud)
09:46:05 <monochrom> Now you had a grammar that you thought would generate abbc.  Show me.
09:46:33 <danols_> S -> aBc | <empty>
09:46:42 <danols_> B -> b | B | <empty>
09:46:43 <danols_> ?
09:47:35 <monochrom> Show how you can get abbc.
09:48:15 <danols_> S -> aBc -> abBc -> abbBc -> abb<empty>c -> abb<empty>c <empty> ?
09:49:10 <monochrom> You don't have a rule B -> bB.  The second step can't be right.
09:49:15 <danols_> does the S need the <empty> since B will terminate anywho ?
09:49:46 <shapr> tuomov: I got to that article "The Command Line - The Best Newbie Interface?" from your page, it's really interesting.
09:51:02 <danols_> monochrom are you still there ?
09:51:25 <shapr> ows: hi!
09:51:39 * shapr bounces around randomly
09:51:40 <monochrom> I have already said what I needed to say.
09:51:57 <danols_> monochrom hmmm
09:52:06 * shapr sings o/~ the hills are alive! o/~
09:52:10 <danols_> monochrom dose it look like i understand it ?
09:52:28 <monochrom> Sigh. I'll repeat.
09:52:30 <monochrom> You don't have a rule B -> bB.  The second step can't be right.
09:53:04 <danols_> monochrom why ?
09:53:29 <monochrom> Look at your grammar. Does it have B->bB?
09:53:49 <danols_> no but it has B -> b ahhhh which would terminate
09:53:59 * shapr reads the "Job Posting" thread on LtU
09:54:06 <danols_> crap i though i understood it 
09:54:39 <danols_> so B should be B -> bB | <empty> ?
09:54:45 <monochrom> Yes.
09:54:53 <shapr> man, rrevelts really took it hard
09:55:13 <danols_> and B -> b | B | <empty> is not valid ?
09:55:20 <monochrom> It won't work.
09:55:26 <danols_> ok
09:55:43 <monochrom> Now can you also get aabcc?
09:55:55 <danols_> now that's what I need to work on
09:55:57 <danols_> no i can't get it
09:56:35 <monochrom> Work on it more.  When you see the root of the problem you'll laugh.
09:56:56 <danols_> monochrom i believe you i am working on it now
09:57:08 <danols_> i'll say something when I think that I got it
09:57:46 <danols_> monochrom thanks for the help already :)
09:58:27 <shapr> hey, I have a quick straw poll question. When someone mentions "cutting edge researching working with Java" in a job posting, do you feel positive or negative about that?
10:00:52 <stepcut> heh
10:00:57 <ows> Hi shapr!
10:01:11 <shapr> stepcut: what do you think about that stepcut?
10:01:21 <shapr> ows: what about you?
10:01:43 <stepcut> shapr: slightly negative
10:01:49 <monochrom> I feel paradoxical about it.
10:01:55 <Oejet_> shapr: I feel hungry.
10:02:21 <shapr> Oejet_: is that positive or negative towards a job posting that says "cutting edge research" and "java" ?
10:02:34 <monochrom> what cutting edge anything could you do with Java?  Java itself has a hard time catching up with generics etc. already.
10:02:37 <shapr> monochrom: that's how I feel about it too.
10:02:43 <tuomov> "cutting edge research" and "job postting" don't match
10:02:48 <stepcut> shapr: I feel slightly negative about both parts
10:03:20 <shapr> what's negative about "cutting edge research" ? The buzzword bingo?
10:03:26 <shapr> tuomov: heh
10:03:44 <Oejet_> shapr: He, mmm, I think, I think: "This doesn't surprise me".
10:03:54 <phubuh> i feel negatively about it, because the only cutting edge research areas i'm interested in require good abstraction facilities
10:04:06 <monochrom> Alright if the writing is more specific like "cutting edge research in Java code optimization" I'd believe it.  I know some open problems there.
10:04:09 <shapr> phubuh: yah, that's my thoughts on the matter too.
10:04:35 <ows> shapr: I'm fine and about you
10:04:47 <tuomov> monochrom: still doesn't sound like something you would find in a job posting, unless it is a lie
10:04:51 <shapr> ows: life is GOOD!
10:05:06 <phubuh> indeed it is
10:05:10 <ows> wow, why you said that?
10:05:14 <tuomov> more like "developing cutting edge research done elsewhere into a product"
10:05:28 * phubuh just experienced a rush of impulse shopping at the book store
10:05:30 <shapr> ows: because, there's a really cool new Haskell project to make an editor, so I can escape emacs.
10:05:48 <ows> wow, is there some beta version
10:05:54 <phubuh> the physical book store, i.e., the place that sells terrible books, but cool pads & pencils
10:06:02 <Oejet_> shapr: I think it depends a lot on who did the posting.
10:06:08 <shapr> tuomov: that's an excellent point, real 'researchers' rarely show up from job postings.
10:06:18 <monochrom> The IBM Toronto Lab does both original research and implementation on Java code optimization.
10:06:42 <tuomov> and you can get there through job postings? I don't think so..
10:06:56 <shapr> ows: there's an alpha version: darcs get http://www.cse.unsw.edu.au/~dons/yi
10:06:59 <tuomov> you get there by knowing someone
10:07:26 <tuomov> (and having a phd)
10:07:34 <Oejet_> tuomov: Or sleeping with someone.
10:07:37 <shapr> heh
10:08:33 <Oejet_> How do I convert :: Integer -> Int, convert x = x.
10:08:54 <monochrom> Yeah, just shoot down all counterexamples. That proves your point.
10:09:08 <bringert> @type fromIntegral
10:09:09 <lambdabot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
10:09:11 <phubuh> convert = fromIntegral ?
10:09:39 <tuomov> monochrom: show me a single job posting for a real research job?
10:09:40 <danols_> monochrom is this correct ? S -> aSc | aBc   B -> bB | b
10:10:07 <stepcut> shapr: It's like reading the personals in the newspaper and running across: Single-Bi-Female - I am extremely good looking and like OS X. Let's chat!
10:10:10 <tuomov> (that hasn't been made just because it is said somewhere that all jobs must be posted)
10:10:20 <tuomov> (although the person for the job has already been selected)
10:10:34 <monochrom> Open any issue of The Communication of the ACM.  Lots of research job posting there.
10:10:48 <tuomov> but then again, maybe there's still some real jobs left in the big world
10:10:54 <Oejet_> phubuh, bringert: No, its not fromIntegral  :: forall b a. (Num b, Integral a) => a -> b
10:11:04 <tuomov> in finland, all job postings are symbian, java, etc., etc.
10:11:07 <bringert> Oejet_: why not?
10:11:25 <monochrom> danols_: that will miss ac, aacc, etc.
10:11:35 <phubuh> Oejet_: sure it is: Integer has instance of Integral and Int has an instance of Num
10:11:47 <monochrom> danols_: ah nevermind, at least one b the question requires.
10:11:52 <tuomov> don't have access to any sort of acm publ
10:11:57 <bringert> Oejet_: the magic of type classes
10:11:58 <danols_> monochrom so i'm on the right track ?
10:12:08 <phubuh> Oejet_: the explicit signature will un-generalize it
10:12:14 <monochrom> Yes. I think it is correct now.
10:12:23 <danols_> cool
10:12:26 <danols_> but
10:12:33 <Oejet_> phubuh, bringert: Sorry, I stand corrected! Thanks!!!
10:12:36 <danols_> let me rewrite it and ask a question
10:13:06 <shapr> thanks for your input guys 
10:13:09 <monochrom> I have seen Communications of The ACM sold in a news booth in downtown Toronto.  Some IEEE stuff too.
10:13:58 <tuomov> I live in the middle of nowhere
10:14:11 <shapr> tornio? ;-)
10:14:17 <tuomov> tampere
10:14:25 <danols_> monochrom S -> aSc | aBc | ac     B -> bB | b  ==> {a^n b^m c^n | n,m > 0}  ?
10:14:47 <monochrom> Well this time you have ac but the question doesn't want it.
10:14:50 <shapr> I lived in Tornio for three years. I think I would have preferred Tampere.
10:15:00 <danols_> monochrom ohhh yeah 
10:15:14 <shapr> I had lots of time for coding, admittedly.
10:15:16 <tuomov> it's a nice town to live in otherwise, but both the unis are quite dead
10:15:29 <danols_> monochrom man i learned more in the past 1 hour than this last week in class
10:15:43 <danols_> monochrom thanks for making it make sense to me
10:15:53 <monochrom> Don't just thank me.  Thank yourself too.
10:16:01 <shapr> we had to pay 300euro initially, and 100euro a month (which went down to 50e a month lateron) for the first DSL line in Tornio.
10:16:05 <monochrom> All I did was make you work out two examples.
10:16:10 <danols_> monochrom that's how i learn, by doing and having someone direct me :)
10:16:48 <shapr> It had good ping times though... Felt like I was the only guy on the whole lappish branch of their DSL =)
10:17:16 <danols_> does any of know what produce-match npda means ?
10:17:45 * shapr wonders if produce-match has to do with melon equality.
10:17:54 <danols_> shapr i wish lol
10:19:41 <shapr> Are the HOpenGL libs equally functional on Win32?
10:29:34 <shapr> dang, I can't find the emails I swapped with seafood about PaTHeon.
10:30:40 <shapr> Igloo: if you have a moment, do you remember what the problem was with using TH like hs-plugins? I think it was that turning source code into an equal tree of TH types had to be done by-hand... Does that sound right?
10:30:49 * shapr is trying to start some activity on the TH list.
10:31:15 * Igloo doesn't remember
10:31:36 * Igloo doesn't really have a moment right now, either
10:31:39 <shapr> ok
10:33:41 <CosmicRay> shapr: let me pick your brain about TH a bit, if that's ok
10:33:46 <CosmicRay> shapr: have you heard of camlp4?
10:33:47 <shapr> sure
10:33:51 <shapr> heard of it.
10:34:05 <CosmicRay> shapr: do you know enough about it to help me understand how TH is similar/dissimilar to it?
10:34:13 <shapr> nope, what does camlp4 do?
10:35:13 <CosmicRay> it provides a way to extend or replace the ocaml syntax.  You can insert your own logic into the parser tables that are used to parse OCaml source, and thus redefine syntax, add new keywords/operators, etc.  You can also completely replace the parser with your own -- for instance, there's a camlp4 module for Scheme.
10:35:18 <CosmicRay> then, on the output side..
10:36:05 <CosmicRay> there are pluggable modules.  One can output a raw binary ocaml AST.  Another can output pretty-printed output.
10:36:35 <CosmicRay> on the input side, modules are layerable
10:36:47 <CosmicRay> so you can combine well-written camlp4 parsers.
10:37:21 <shapr> Template Haskell is in a different direction than that.
10:37:25 <CosmicRay> it acts as a preprocessor, so it can be used as part of the compilation process, or you can output straight ocaml code using the pretty-printer so everyone can compile it.
10:37:32 <Igloo> It's more like MetaML/MetaOCaml if you know either of them
10:37:41 <CosmicRay> unfortunately, I don't
10:37:41 <shapr> In essence, TH lets you write Haskell code to generate your program.
10:38:06 <CosmicRay> well that sounds like Camlp4 -- or Language.Haskell.
10:39:33 <shapr> TH works at compile time, and a has loop of execution, type checking, compilation
10:39:45 <shapr> well, that's the rough (and possibly inaccurate) overview
10:39:58 <stepcut> CosmicRay: camlp4 allows for syntax extensions, whereas TH does not
10:39:58 <shapr> I have the TH paper printed out around here somewhere...
10:40:20 <shapr> stepcut: does camlp4 do everything TH does?
10:40:37 <stepcut> shapr: I don't believe so, but its been a while since I used either of them
10:46:20 <bourbaki> bk
10:47:28 <shapr> YOW!
10:54:25 <Lemmih> @arr
10:54:25 <lambdabot> Sorry, I don't know the command "arr", try "lambdabot: @listcommands"
11:02:14 <abstrato_general> it's me again.
11:02:31 <abstrato_general> I'm an ultra-newb. What is wrong with this snippet? http://rafb.net/paste/results/SESgqX62.html
11:04:04 <joao> Hello
11:04:13 <Lemmih> Maybe you should tell us about the error you got.
11:04:17 <Lemmih> Hey joao
11:04:29 <abstrato_general> um, of course. 
11:04:30 <abstrato_general> Sorry.
11:04:39 <abstrato_general> I load it into hugs
11:04:45 <abstrato_general> and try to say "dress Male".
11:04:51 <abstrato_general> ERROR - Cannot find "show" function for:
11:04:52 <abstrato_general> *** Expression : dress Male
11:04:52 <abstrato_general> *** Of type    : Clothes            
11:05:08 <Lemmih> @type show
11:05:09 <lambdabot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
11:05:27 <Lemmih> You'll need to make Clothes an instance of Show.
11:05:53 <abstrato_general> why isn't that needed with a function like "inc n = n + 1" ?
11:05:55 <Lemmih> The easy way to do it is like this: 'data Clothes = Trousers | Skirts deriving Show'
11:06:06 <abstrato_general> ok. 
11:06:10 <abstrato_general> thanks! :)
11:06:30 <shapr> @dynamic-load quote
11:06:31 <lambdabot> symbol resolution failed
11:06:36 * shapr kicks lambdabot 
11:06:36 <Lemmih> abstrato_general: All instances of Num must be instances of Show as well.
11:06:43 <abstrato_general> oh ok
11:06:51 <Lemmih> shapr: Problems with lambdabot?
11:06:53 <abstrato_general> thanks again.
11:07:06 <shapr> yah, haddock/HaddockHH.o: unknown symbol `__stginit_HaddockUtil_'
11:07:09 <Lemmih> No problem.
11:07:19 <shapr> I should remember what this means... but I don't
11:07:24 <shapr> lambdabot: @quit
11:10:00 * Lemmih is working on a template library designed for dynamic pages from scratch.
11:14:05 * Russell is away: echo -e \\160\\157\\162\\143\\157 \\144\\151\\157
11:14:22 <stepcut> it's raining on my desk :-(
11:14:40 <shapr> ?
11:17:28 <shapr> yow, Paul Graham makes some vicious comparisons in his latest writing.
11:17:41 <bourbaki> which one?
11:17:51 <shapr> http://www.paulgraham.com/gba.html
11:18:30 <dv> i don't really like him. too much talk, too little code
11:19:04 <shapr> well, somebody gotta talk to the rest of the world about those who code.
11:19:30 <shapr> managers/owners in my last job had no clue how to make a company of programmers work out.
11:19:43 <shapr> And didn't want to listen to what I had to say either.
11:20:39 <shapr> Paul does try to explain the hacker mindset to mundanes.
11:20:52 <shapr> *muggles ;-)
11:21:05 <arauko> he does it very well.
11:21:37 <arauko> Comparing hackers with painters is a pretty good comparison.
11:22:29 <shapr> Interesting quote from this most recent one --> "There is such a thing as American-ness. There's nothing like living abroad to teach you that."
11:22:37 <stepcut> shapr: its raining outside, and the roof is leaking
11:22:48 <shapr> stepcut: that sucks.
11:23:00 <stepcut> building maintainence is looking into it
11:24:24 <shapr> I want to use GF/FM to build some open source teaching software for the local schools. I'd like to do "software as a service" After checking around for funding locally, I found out that there is funding for that sort of thing, but that it would take 2.5 to 3 years to get the funding.
11:26:37 <shapr> @type show
11:26:38 <lambdabot> show :: forall a. (Show a) => a -> String
11:26:40 <shapr> yay!
11:31:05 * shapr is a fan of disruptive technologies.
11:39:45 <vivek>  /me confers the crown of champion Haskell instructor to shapr 
12:17:24 <abstrato_general> shapr: Paul Graham's latest essay is disappointing, yes.
12:17:38 <abstrato_general> shapr: I mean, "What the bubble got right" was brilliant.
12:19:28 <musasabi> home.
12:30:37 <tromp> hi oejet
12:31:58 <Oejet_> Hello, tromp.
12:32:23 <Oejet_> Are we alone (with the rest of 96 people sleeping)?
12:32:47 <tromp> not sleeping, just lost for words...
12:33:19 <tromp> well, half of em sleeping prolly
12:33:39 <Oejet_> I don't think I can optimize Olinka II more, unless I change the algorithm with tables an such.
12:34:29 <Oejet_> http://eigil.dyndns.dk/a.out.prof
12:34:56 <Oejet_> I mean, I can't squeze more out of the bit count function.
12:35:12 <tromp> you can speed it up
12:36:28 <Oejet_> Speed count' up?
12:37:02 <tromp> use shifts, masks, and + to countbits
12:38:03 <Oejet_> count' :: Int -> BitBoard -> Int
12:38:03 <Oejet_> count' acc (0) = acc
12:38:03 <Oejet_> count' acc n = let s = n .&. (-n) in
12:38:03 <Oejet_> 	count' (acc+1) (n `xor` s) 
12:38:31 <tromp> that's the slow way
12:38:34 <Oejet_> Finding lowest bit, erasing it, and repeating.
12:38:42 <tromp> think parallel, not serial
12:39:12 <Oejet_> Mmm, I saw an algorithm in...
12:39:28 <Oejet_> http://www.jjj.de/fxt/fxtpage.html#fxtbook
12:39:51 <Oejet_> But it took 18 bit operations each time.
12:40:15 <Oejet_> Mine is linear to the number of bits set.
12:40:39 <tromp> i prefer logarithmic in wordsize
12:41:19 <tromp> also avoids a test&branch
12:41:39 <Oejet_> Well, I profiled the different count functions.
12:41:55 <Oejet_> Maybe I have overlooked one clever one?
12:43:54 <tromp> imagine that an int64 consists of, say, 16 bitfields of 4 bits each
12:44:12 <tromp> that's 16 small counters
12:44:46 <tromp> how would you add up the counters in pairs?
12:45:09 <tromp> to get 8 counters
12:45:42 <shapr> abstrato_general: what did you like or dislike about the bubble essay?
12:46:43 <Oejet_> tromp: b >> 2
12:49:12 <Oejet_> tromp : No, b & (b >> 2)
12:49:28 <tromp> not even close:(
12:50:02 <Oejet_> Mmm, thought of it the wrong way ...
12:53:38 <abstrato_general> shapr for one, it was a good overview of how the technological explosion did actually change the world.
12:54:03 <abstrato_general> shapr there is a prevailing view among suits that the bubble was a nice dream, but it collapsed.
12:54:35 <abstrato_general> there is a 1973 feel floating around.
12:54:38 <Oejet_> tromp, the beginning: b + (b & mask), where mask=00010001...0001
12:54:53 <shapr> abstrato_general: how old are you? :-)
12:55:02 * abstrato_general is 22 :-P
12:55:05 <shapr> I just barely remember 1973...
12:55:33 <abstrato_general> I'm an economist, interested in the relations between economic outlook and culture.
12:55:39 <shapr> heh, me too
12:55:44 <shapr> but not an economist per se
12:55:53 <shapr> more of a geek trying to figure out how it all works
12:56:03 <tromp> if you have 8 bitfields of 8 bit each, and the total count is < 255, then bb mod 255 gives the total
12:56:12 <abstrato_general> In ultrasimplified terms, both the 60's and the 90's were times of extreme optimism, and that's reflected on hippie/raver culture.
12:56:18 <tromp> but on most cpu's a mod is pretty slow:(
12:56:26 <shapr> I've tried to explain the economics of open source to various bosses/managers/company owners, never seems to work.
12:56:38 <abstrato_general> I'm not sure I understand the economics of open source either.
12:56:48 <shapr> it's pretty simple, in my opinion.
12:56:56 <shapr> software is a service
12:56:59 <tromp> oejet, the mask should be 0F0F0F0F0F0F0F0F
12:57:24 <abstrato_general> I was planning to write my undergrad thesis on that, but it's too complex for me yet. Instead, I'm working on neural network analysis of the term-structure of interest rates instead
12:57:34 <abstrato_general> I think that should give you an estimate of just how complex it is :-P
12:57:40 <shapr> sounds interesting
12:57:50 <shapr> I still think open source economics are simple.
12:58:21 <abstrato_general> I've heard pretty much all of the open source economics "theories" floating around.
12:58:33 <abstrato_general> Calling software a "service" is interesting, but flawed.
12:58:48 <shapr> The difference for me is that I'm a self-employed open source programmer. I've put my money where my mouth is ;-)
12:59:01 <shapr> How is that flawed?
12:59:07 <abstrato_general> Corporate use is just a part of what software is.
12:59:40 <shapr> That's an incomplete answer.
13:00:02 <abstrato_general> For many many uses it's still a buy-once thing. See, suppose I graduate and open a financial consulting firm specialized in neural nets and genetic algorithms for "intelligent" analysis of market signals.
13:00:15 <shapr> ok
13:00:23 <abstrato_general> That's more than just predicting indexes. I'm interested in predicting the political situation from market signals, for instance.
13:00:32 <Oejet_> tromp: Is it like http://www.jjj.de/fxt/fxtpage.html#fxtbook, top of page 15.
13:00:48 <shapr> What does that have to do with buy-once or not?
13:00:51 <abstrato_general> anyway. I'm gonna buy me, say, an Opteron, put Gentoo on it and port my Matlab code to Octave.
13:01:08 <abstrato_general> My firm will be probably me and a couple of colleagues. 
13:01:31 <tromp> don't they have the code in html?
13:01:50 <abstrato_general> they'll prolly need a desktop each, but I'll be managing the service. The thing is, I see technology leading us to smaller and smaller firms.
13:02:02 <shapr> I think that's true.
13:02:08 <shapr> Four-person Jazz bands will win out.
13:02:10 <abstrato_general> The minimum scale to survive has collapsed dramatically.
13:02:15 <Oejet_> tromp: No, I haven't seen any, sadly.
13:02:28 <shapr> but, how does that point out a flaw in the idea of software as a service?
13:02:48 <abstrato_general> shapr most software-as-service arguments are centered around corporate-use-with-support.
13:02:55 <shapr> Oh, mine isn't :-)
13:03:15 <abstrato_general> They're thinking of huge cubicle farms with hundreds or thousand mindless drones typing away on Microsoft Excel.
13:03:29 <abstrato_general> Hint, my neural nets replace a LOT of those mindless drones.
13:03:45 <tromp> i only see header files
13:03:45 <abstrato_general> And I'm not talking about cutting-edge science, these things are sorta settled since the late 70's.
13:03:46 <shapr> I assume that the corporation will do support themselves, since that's cheapest, and that when they need new development they'll pay an outside firm to extend their existing code to do more.
13:04:16 <abstrato_general> shapr if there's a corporation. What will the four-person jazz band do?
13:04:32 <shapr> I see open source software like dry-cleaning. You put in your software at the beginning of the month, and at the end of the month you have a new feature.
13:04:33 <tromp> for bitcount
13:04:38 <shapr> the four-person jazz band is corp.
13:04:46 <Oejet_> The steadily growing "Algorithms for programmers" text
13:05:12 <abstrato_general> see. from a business standpoint, why would I share my neural network code? 
13:05:21 <shapr> Because you're not perfect.
13:05:21 <tromp> ah yes, that's it
13:05:37 <abstrato_general> It's got some added parmeggiani on it over the standard toolboxes. And it works.
13:05:39 <shapr> Because I've done neural network code for twelve years
13:05:58 <abstrato_general> well, why would you share your parmeggiani with me, instead of opening a consulting firm and selling results?
13:05:59 <shapr> Because if I share my code with sixteen other jazz bands, ours will be better.
13:06:24 <shapr> and the way to make the code best is to give it away.
13:06:33 <abstrato_general> unless they decide not to share it. Remember, if you change GPL code and keep it in-house, churning out the results, you don't need to GPL the changes.
13:06:35 <shapr> because, code is not the product.
13:06:51 <abstrato_general> software is a machine.
13:07:12 <shapr> your code is not the product that you sell
13:07:17 <abstrato_general> The fact that the washing machine support business exists doesn't make washing machines a service. 
13:07:32 <shapr> your code may be a crystallized form of your understanding, but it is only your understanding that makes that code worthwhile.
13:07:35 <abstrato_general> Of course, the washing machine place is a service. That's what my consulting firm would be, a washing machine place.
13:07:40 <tuomov> cell phones are a service in some parts of the world
13:07:55 <shapr> you can't compare software to washing machines, the economics is obviously different
13:07:56 <abstrato_general> cell phones are ultra cheap.
13:08:12 <shapr> 100% of the cost of software is in the production of the first copy.
13:08:14 <abstrato_general> yes. Software has zero marginal cost. And that's what makes it so complex.
13:08:28 <shapr> it's actually easier, give it away and it gets better :-)
13:08:52 <abstrato_general> Actually, software confirms the harshest predictions of theoretical microeconomics.
13:09:06 <abstrato_general> Under perfect competition, firms are only able to get away with selling their product at the marginal cost.
13:09:21 <abstrato_general> Even outside the open source world, free-beer software just sprouts, because it's hard to sell.
13:09:21 <shapr> software isn't a product!
13:09:31 <tuomov> perfect competition is a pipe-dream
13:09:31 <abstrato_general> shapr "product-or-service". 
13:09:35 <tuomov> all markets monopolise
13:09:47 <abstrato_general> markets tend to monopolise under increasing returns to scale.
13:10:28 <abstrato_general> increasing returns to scale are somewhat common in heavy industries like steel, but those are less and less important.
13:10:46 <abstrato_general> In fact, I think increasing returns of scale were only important from a short period of time between the 1860's and the 1950's.
13:11:11 <tromp> they replace the mod 255 with * 0x0101010101010101; that's clever:)
13:11:34 <shapr> The secret to code is that it's intelligence augmentation, IA rather than AI. If you give your code away, you do not give away that which makes you profitable.
13:12:15 <abstrato_general> shapr there is that argument. Then again, what makes a washing machine place profitable is not just their machines.
13:12:18 <tromp> but still assumes that mul is faster than 2 shifts and 3 adds
13:12:35 <abstrato_general> Still, the physical investment in the machines is an important part of it, and so is the development investment in code.
13:12:56 <shapr> which is why there should be companies that specialize in developing code, and then giving it away.
13:13:02 <shapr> and you should pay them for that.
13:13:56 <abstrato_general> if you remove sociological factors, it doesn't make any sense at all. at least under the profit motive of scarcity economics.
13:13:57 <shapr> I make more profit using my window manager, because it gets out of my way, and I can use it entirely with the keyboard.
13:14:13 <abstrato_general> ion or ratpoison?
13:14:16 <abstrato_general> I prefer ion.
13:14:29 <Oejet_> tromp: I ended up with the sparse counting.
13:14:53 <shapr> If I want some new feature that makes that window manager better, I would call up whoever could most quickly and cheaply make changes to that window manager, and hand them some cash in return for that feature.
13:15:03 <shapr> Ion3
13:15:08 <tuomov> free software is based more on cooperation than competition, and that is quite strange a concept to capitalist econimics
13:15:23 <abstrato_general> tuomov is the author of ion! 
13:15:27 <abstrato_general> now I remember :-)
13:15:27 <shapr> yup
13:15:35 <abstrato_general> hey. good job, man.
13:16:03 <shapr> so I'd say hey tuomov, can I send you X euro for feature Y?
13:16:29 <abstrato_general> the thing is, would the marginal return to the feature or improvement you need outweigh the marginal cost of tuomov to sit down and write it?
13:16:30 <shapr> assuming the price was right, he'd probably even do it...
13:16:40 <shapr> Yes!
13:16:53 <abstrato_general> an improvement in a wm doesn't seem worth much.
13:16:56 <shapr> because I am not alone in this world, and the marginal return to half a million people is really big return
13:16:58 <tuomov> it's not that simple
13:17:13 <tuomov> I write interesting features for free, eventually
13:17:28 <tuomov> ideas totally contrary to my goals I won't write
13:17:32 <abstrato_general> I love ion3, but I'm using WinXP right now because I needed specific software that wouldn't run on wine or win4lin. So, uh, software preferences only reach this far.
13:17:33 <shapr> well, right :-)
13:17:37 <tuomov> the other, perhaps, if I have the time and the price is right
13:17:41 <tuomov> but not everything is for sale
13:17:44 <tuomov> +s
13:18:09 <abstrato_general> a GPL fork of ion3 is possible, and you could always pay someone else to hack it.
13:18:15 <abstrato_general> that's besides the point.
13:18:25 <tuomov> but really, I'd much rather not have to be paid to do anything..
13:18:27 <shapr> in this idealized world in my head, you'd have at least thirty or forty possible contracts to pick
13:18:47 <abstrato_general> yes, but you'd be the one to have to pay for it, then everyone else would have it.
13:18:54 <abstrato_general> Why would you, instead of waiting for other people to do it?
13:18:59 <tuomov> not in an other kind of world
13:19:00 <abstrato_general> it's called the free rider problem.
13:19:04 <shapr> because I want it, because it's worth it to me.
13:19:28 <shapr> IBM paid for NUMA support for Linux, and it benefited other NUMA-using companies too.
13:19:45 <abstrato_general> IBM is big.
13:19:57 <shapr> So am I for some definition of big.
13:19:58 <abstrato_general> They can afford the risk and all.
13:20:10 <shapr> I can afford the risk too, if it's only a few hundred euro.
13:20:12 <abstrato_general> well, there is a scale of operation. Tuomov does have to eat everyday.
13:20:38 <abstrato_general> um, are you really willing to pay a few hundred euros for a couple of new keybindings?
13:20:51 <shapr> depends on the feature
13:21:12 <abstrato_general> what kind of feature would make you a few hundreds of euros more productive?
13:21:48 <shapr> Anything that saved me five minutes a day over a period of several months would be a net gain for me.
13:21:56 <abstrato_general> the best argument in open source economics is still that software elliminates scarcity.
13:22:23 <abstrato_general> and therefore the economics of scarcity wouldn't make sense, leaving us with raw game theory to build up models of cooperation.
13:22:35 <abstrato_general> Still, game-theoretical cooperation is very unstable.
13:22:42 <tuomov> supposing all other things being the same, that the concept of free software did not exist. Does someone think I could earn I living with such a marginal program as Ion? 
13:22:51 <tuomov> I do not think so. Infact, it'd probably even be less popular than now.
13:22:58 * shapr agrees with tuomov
13:23:09 <abstrato_general> tuomov nope. But you'd be working at something probably more useful, useful enough that people would pay for it.
13:23:17 <shapr> ion IS useful!
13:23:18 <abstrato_general> I mean, open source is just part of the problem.
13:23:28 <tuomov> I think Ion is much more useful than much of the software written in companies
13:23:33 <shapr> hell yes
13:23:37 <abstrato_general> shapr he just said it's not useful enough to be able to sell it to recap its cost.
13:23:41 <tuomov> it's much just rewriting the wheel
13:24:00 <tuomov> abstrato_general: I didn't say that. 
13:24:01 <shapr> in a purely microsoft-style capitalist society, Ion will not make a profit.
13:24:04 <tuomov> abstrato_general: consider BeOS
13:24:17 <abstrato_general> BeOS succumbed under network externalities.
13:24:30 <shapr> but those economics are fading, open source works better.
13:24:37 <tuomov> you just can't compete with MS
13:24:47 <abstrato_general> There is an argument that technical protocols must be regulated because of network externalities.
13:24:54 <tuomov> only free software can compete with it
13:25:06 <tuomov> and perhaps some other major given the time
13:25:17 <tuomov> +company
13:25:17 <abstrato_general> OTOH, the industry organizes itself in industry standards through cooperation models. The current standardisation of the non-MS world on unix is a sign of that.
13:25:18 <shapr> hej yohan 
13:25:32 <yohan> tja shapr, what up?
13:25:33 <shapr> aka 'conventions'
13:25:33 <abstrato_general> Some regulation of technical protocols is needed.
13:25:44 <shapr> bah, I'm in favor of 100% laissez-faire
13:25:53 <shapr> laissez les bon temps roulez =)
13:26:01 <abstrato_general> I'm mostly a laissez-faire advocate.
13:26:08 <tuomov> and I'm more of an anarchist
13:26:24 <abstrato_general> Precisely because it can be demonstrated that in very general conditions, market equillibria are pareto-efficient.
13:26:32 <abstrato_general> but market failures exist.
13:26:44 <shapr> The last pareto I ate was very efficient.
13:26:49 <abstrato_general> Network externalities probably being the less thought of, and the most destructive nowadays.
13:26:55 <shapr> tasted like chickin
13:26:57 <shapr> bawk!
13:27:21 <abstrato_general> Microsoft is Microsoft because of network externalities.
13:27:36 <shapr> you have a very strange view of economics.
13:27:45 <abstrato_general> how so?
13:27:49 <bourbaki> microsoft is microsoft because of the sign in the front
13:28:09 <bourbaki> otherwise it would be what it would be because of what the label sais
13:28:10 <abstrato_general> I'm mostly a laissez-fair advocate in principle, but recognize that market failures exist and must be addressed for.
13:28:14 <bourbaki> *says
13:28:28 <abstrato_general> I'm not a laissez-faire advocate because of moral reasons, I'm a laissez-faire advocate because the market works.
13:28:32 <bourbaki> market in itself is a failure :)
13:28:35 <shapr> bah, I donno
13:28:39 <tuomov> markets don't work.
13:28:47 <shapr> I have an idea of what I think open source economics is
13:28:52 <bourbaki> they want to grow forever
13:28:55 <shapr> and I apply that to running my own company
13:29:00 <shapr> and it works so far
13:29:04 <shapr> that's the best I can say
13:29:11 <abstrato_general> but then again, the markets are a very elegant solution to the problem of scarcity.
13:29:21 <tuomov> free software economics is anarchist economics.
13:29:24 <abstrato_general> and, again, the most powerful argument for open source economics is that in software, scarcity is artificial.
13:29:26 <bourbaki> and the market came up with the stocks :)
13:29:49 <abstrato_general> therefore the "magic cauldron" Eric Raymond speaks of.
13:29:58 <shapr> tuomov: I think it's a strange mixture of pure communism in the original sense, and capitalism in its purest sense.
13:30:22 <abstrato_general> but is it an accident that the crowd at Slashdot recommends to aspiring CS students to become tradesmen instead?
13:30:36 <abstrato_general> Apparently, you can get better pay installing kitchen sinks than developing software in the US nowadays.
13:30:36 <bourbaki> *cough* what?
13:30:47 <shapr> Anything that happens on slashdot is an accident.
13:30:57 <shapr> ;-)
13:31:01 <stepcut> heh
13:31:03 <bourbaki> and we know the better buzzwords ;)
13:31:08 <tuomov> in a very old sense of the word communism, when anarchist still used the term of themselves too, yes. But for long communism has stand for authoritarian socialism, and free software is everything but that
13:31:33 <shapr> right, but in its original sense, communism meant 'sharing everything'
13:31:41 <abstrato_general> That's partly an effect of the Microsoft monopoly, but also partly that there is no long-term perspective for software as a dynamic business center. 
13:31:44 <shapr> you put everything you got into a pot, and whatever you need, you take out.
13:31:55 <shapr> doesn't work... but that was the idea.
13:32:10 <bourbaki> isnt the idea of ms to share windoze with everyone ;)?
13:32:16 <shapr> yes
13:32:23 <bourbaki> but for just a little fee?
13:32:23 <abstrato_general> shapr it doesn't work because of the free rider problem. Go look it up on wikipedia.
13:32:25 <abstrato_general> I gotta go.
13:32:28 <bourbaki> bye bye
13:32:33 <shapr> there is no free rider problem with software.
13:32:38 <tuomov> it's never been implemented.
13:32:43 <shapr> g'bye abstrato_general 
13:32:51 <tuomov> so-called communist states have been just state capitalisms.
13:32:54 <shapr> right
13:33:10 <shapr> I went to a communist youth rally in Athens, Greece with a Linux T-shirt on...
13:33:15 <bourbaki> there is no real communist country
13:33:21 <shapr> I was not happy :-(
13:33:33 <bourbaki> cause its a utopy and the point of those is that you cant implement them
13:33:34 <tuomov> in the modern sense of the word there is.. but communism is just state capitalism
13:33:52 <shapr> and the state is not flexble enough to be any good at capitalism
13:33:56 <tuomov> yes
13:34:04 <tuomov> it's just a huge megacorp
13:34:04 <shapr> independent agents deciding for themselves are significantly better at it.
13:34:13 <shapr> and that's the future I see
13:34:21 <monochrom> part of communism is supposedly the elimination of "state" isn't it?
13:34:25 <bourbaki> i doubt that the market system can remain as it is now
13:34:36 <shapr> two to eight people corporations with four people being the most efficient average size
13:34:37 <bourbaki> no why monochrom ?
13:34:38 <tuomov> monochrom: yes and no
13:34:47 <bourbaki> someone has to manage all the stuff
13:35:07 <Oejet_> A free market economy is also an utopy.
13:35:07 <tuomov> some marx's texts say that the elimination of state is the eventual goal, but a transitory workers' state is needed
13:35:22 <tuomov> and I think some texts say that this workers' state is the goal
13:35:26 <shapr> tuomov: that sets off every bullshit detector I have :-)
13:35:36 <bourbaki> :)
13:35:46 <tuomov> and this is where anarchists disagreed with the communists; anarchist think the state must be eliminated "overnight"
13:36:00 <shapr> oh just a transitory workers' state, really... we'll get rid of it asap.
13:36:04 <tuomov> because all hierarchical authority leads to oppression
13:36:29 <bourbaki> once all the money is in the hand of the top 5% the ppl will see that there is no use of the system as it is now
13:36:54 * monochrom contemplates stateless demand-driven value-oriented programming.  "No global state!"  "Not evaluated until needed!"  "Everything is a value!"
13:37:02 <shapr> Personally, I want the minimum system possible.
13:37:16 <monochrom> Yeah, minimum system.
13:37:17 <bourbaki> isnt that anarchy?
13:37:18 <tuomov> that's anarchy
13:37:30 <shapr> I don't think zero system is possible :-(
13:37:30 <tuomov> an-archy = no-leader
13:37:31 <bourbaki> and to be honest i dont want that
13:37:43 <shapr> but I sure think we have too much system right now.
13:37:45 <monochrom> I don't mind a government as long as it doesn't get into the way.
13:37:51 <shapr> monochrom: yah, exactly
13:37:54 <bourbaki> there cant be no zero system
13:38:02 <bourbaki> cause there is always physics
13:38:15 <shapr> anyway....
13:38:21 <bourbaki> and the best gov cant aruge that away ;) so there is still hope ;)
13:38:27 <tuomov> but in a semi-capitalist system, you want the government when you're unemployed etc.
13:38:32 <monochrom> The government should do nothing during peaceful times.  When there is a big problem requiring large-scale coordination it can kick in.  Otherwise it should let people figure out things themselves.
13:38:32 <tuomov> in a pure capitalism you're out of luck then
13:38:46 <shapr> tuomov: so you take the jobs when you need them
13:39:02 <bourbaki> i think that the industry needs to be heavyly prued
13:39:05 <shapr> and make sure you have at least two skills you can sell =)
13:39:05 <bourbaki> pruned
13:39:10 <tuomov> but you're completely at the mercy of the wealthy
13:39:26 <bourbaki> the big tiers like m$ have to be shattered
13:39:36 <shapr> that assumes there is a tiny minority with all the cash
13:39:47 <shapr> a massive middle class would mean that you would find a job
13:39:50 <tuomov> there will always be in a capitalist system
13:39:52 <bourbaki> shapr: isnt it the way it is now?
13:39:58 <shapr> hm, no
13:40:17 <bourbaki> i guess that the top 5% of the world own more money then the rest
13:40:20 <shapr> in the feudal system, the lords and the king had everything.
13:40:29 <tuomov> top 5% own 90% or something like that
13:40:46 <bourbaki> and those who have the money are the ones that are heared most by those who rule
13:40:51 <shapr> thing is, the middle class can mostly keep itself employed by working for each other
13:40:52 <bourbaki> if they are not even the same
13:40:59 <tuomov> bourbaki: those who have the money really rule
13:41:10 <bourbaki> tuomov: yes kind of
13:41:19 <tuomov> because elected representatives must listen to them, or they will take their money elsewhere
13:41:39 <tuomov> and that's driving down the so-called welfare states now
13:41:53 * Oejet_ 's eyeballs are beginning to fall out, trying to keep up with the fast scrolling text, which is the sign of #haskell.  So he goes to bed.
13:41:54 <bourbaki> yes
13:41:56 <tuomov> finland does what nokia says or they move out of the country
13:42:04 <bourbaki> and because the rich dont pay taxes
13:42:14 <shapr> Oejet_: are we really that bouncy usually?
13:42:16 <shapr> huh
13:42:29 <bourbaki> :)
13:42:29 <shapr> tuomov: yah, but that's an exception, imho
13:42:36 <tuomov> that's the rule
13:42:42 <Oejet_> shapr, Usually not, luckily.
13:42:47 <bourbaki> the problem is that money is a money magnet
13:42:48 <shapr> that's because finland's gotten so much cash income from nokia
13:42:55 <tuomov> bourbaki: exactly
13:42:57 <shapr> I disagree
13:43:02 <bourbaki> and the ones who need the wellfare dont have no money
13:43:13 <bourbaki> the ones who have money dont want to give money
13:43:19 <shapr> hm
13:43:33 <bourbaki> hence the ones with money will get more and more of it until no one but the rich have money
13:43:37 <shapr> I think money is just a symbol of a system of exchange
13:43:54 <bourbaki> yes but money is attracted
13:43:54 <shapr> so getting a bunch of people together 'creates' money from some viewpoint
13:43:58 <bourbaki> and gathers itself
13:43:58 <shapr> because we're exchanging stuff
13:44:01 <tuomov> in a way, yes. The concept of property is the core problem.
13:44:10 <bourbaki> its like a blackhole :)
13:44:30 <tuomov> so-called individualist anarchists advocated a sort of money-based system
13:44:31 <shapr> I disagree, I don't think this is a tyranny of the rich.
13:44:31 * Oejet_ offers tuomov two cows and a goat for a special feature in Ion.
13:44:37 <shapr> hah
13:44:45 <bourbaki> of course it is
13:44:54 <tuomov> but there would be no usury etc.
13:45:06 <tuomov> socialist anarchists think such a system would, however, eventually lead to capitalism
13:45:18 <bourbaki> i bet that the top 5% have so much money that they could pay the depts of all the countries in the worls
13:45:21 <bourbaki> *world
13:45:45 <bourbaki> and if they would they still would live a life of wealth until their end of days
13:46:26 <Etaoin> and then they'd own the world
13:46:30 <Oejet_> bourbaki: Well, some countries still borrow alot of money. ;-)
13:46:35 <shapr> there's only so much money you can actually use
13:46:44 <bourbaki> and things like the war in iraq are just a shift of money
13:46:53 <shapr> if you buy two lamborghinis, you still can't drive them both at the same time.
13:47:03 <bourbaki> shapr: thats what inflation is good for
13:47:10 <bourbaki> but all economies require to grow
13:47:14 <shapr> getting rid of money?
13:47:18 <bourbaki> but what can grow forever?
13:47:19 <Etaoin> good?
13:47:25 <bourbaki> and what about the stocks?
13:47:30 <shapr> huh?
13:47:31 <mattam> the universe
13:47:46 <shapr> you get more people, you get more value, the system keeps growing
13:47:48 <Oejet_> and everything in between.
13:47:55 <tuomov> but the planet suffers
13:48:07 <bourbaki> the planet is limited
13:48:08 <mattam> all economies can't grow infinitely in a finite world like ours
13:48:09 <tuomov> it can't hold an ever-growing population
13:48:18 <bourbaki> so economy cant grow forever
13:48:24 <mattam> Qed
13:48:32 <bourbaki> :)
13:48:35 <shapr> anywayyy
13:48:42 <shapr> what about that Yi editor?
13:48:46 <bourbaki> thus its faulty in itself
13:49:01 <shapr> tuomov: any idea how to approach scrolling in the buffer?
13:49:10 <mattam> the premisse that every economy has to grow is faulty
13:49:21 <bourbaki> shapr: why dont you make scrolling with a monad?
13:49:28 <shapr> oh no, not the monads!
13:49:52 <stepcut> Aren't the monads some punk band?
13:49:53 <bourbaki> something that shifts texts in a vector :)
13:50:03 <tuomov> in the theory of buffers, each top-level drawable buffer should perhaps export a getline function as I suggested before
13:50:11 <tuomov> s/buffer/transformation/
13:50:20 <shapr> oh hey
13:50:23 <tuomov> the rest of the scrolling is done in the ui module
13:50:28 <stepcut> shapr: have you guys thought about server/client issues at all ?
13:50:28 <shapr> I've been hacking away at writing the reply to your theory of buffers
13:50:43 <shapr> stepcut: like what?
13:50:48 <mattam> what code are you talking about ?
13:50:55 <shapr> the Yi editor
13:50:59 <shapr> formerly known as hemacs
13:51:11 <stepcut> shapr: well, *I* would like to run an editor backend on several different machines, but have them all talk to the same UI componant
13:51:23 <shapr> hm!
13:51:31 <shapr> I was just thinking of something like tramp
13:51:32 <mattam> oh, where is the code ?
13:51:45 <shapr> where you can edit files via ssh/scp/etc
13:52:14 <shapr> mattam: darcs get http://www.cse.unsw.edu.au/~dons/yi
13:52:18 <mattam> thx
13:52:19 <stepcut> the UI part might run on my laptop, which I take home from the office each day. So I would like to reconnect to the servers when I get back in the morning, and not have to reopen all the files I was editting on the remote systems...
13:52:41 <shapr> well, something like emacs desktop that tracks open files?
13:52:50 <stepcut> shapr: the problem with tramp, is it only deals with file editing, but M-x shell will still run on the local system (for example)
13:53:09 <shapr> you should try it with M-x eshell-toggle-cd
13:53:15 <shapr> that really *can* cd into the remote dirs
13:53:20 <shapr> flipped me out the first time that happened.
13:53:32 <stepcut> shapr: but if I run a process, it will be running it on my local system still, yes ?
13:53:47 <shapr> hm
13:53:51 <shapr> I think so
13:54:03 <shapr> but hey, why not peer-to-peer editing processes?
13:54:10 <shapr> stepcut: we'll assign that part to you =)
13:54:15 <stepcut> see, what happens now, Is I ssh into 3 or 4 remote systems, and then I have 5 emacs windows open, and its a horrible mess
13:54:36 <stepcut> I would rather just have one 'emacs' window, but be connected to multiple machines
13:54:38 <monochrom> I think the human version of "peer-to-peer editing" is called "pair programming". :)
13:54:38 <shapr> you can't use tramp to edit files on all those systems?
13:55:00 <stepcut> shapr: use, but then I need to run the compiler
13:55:11 <shapr> hm
13:55:11 <stepcut> s/use/yes/
13:55:27 <shapr> so you really need some way for it to all happen over the same connection.
13:55:35 <Submarine> dear all
13:55:35 <shapr> greetings Submarine 
13:55:39 <shapr> dear all?
13:55:46 <monochrom> Hrm 4 ssh sessions, 5 emacs windows.  Sounds like some pigeon hole question.
13:55:50 <shapr> I don't think all is on this channel.
13:56:06 <stepcut> shapr: right. a bit like emacsclient over ssh or something...
13:56:10 <Submarine> shapr: this is a polite greeting before asking for some advice
13:56:16 <shapr> Submarine: oh, I see.
13:56:23 <shapr> Submarine: right, go ahead
13:56:48 <Submarine> I've been asked to evaluate some programming technique that, broadly speaking, collects information on a recursive data structure.
13:57:10 <Submarine> In a functional way, this would normally imply threading a kind of collector (set, list, or other) through the data structure.
13:57:24 <Submarine> They propose doing it with a monad.
13:57:38 <Submarine> I'm not a Haskell programmer, but this sounds like a very obvious implementation technique for Haskell.
13:57:59 <Submarine> i.e. where one is tempted to use some kind of imperative accumulator, just thread a monad
13:58:01 <stepcut> shapr: if the UI and the 'backend' are seperated, then (greatly simplifying) you just need a way to route the commands over network connection...
13:58:02 <Submarine> am I right?
13:58:05 <monochrom> That reminds me of the "traverse monad" (traversal monad) paper.
13:58:13 <stepcut> shapr: a 'concurrent' haskell type problem..
13:58:29 <shapr> stepcut: yes, but you'll still have the same problem in some ways.
13:58:44 <shapr> Submarine: what do you mean? monads are obvious?
13:59:23 <Submarine> shapr: I mean that a knowledgeable Haskell programmer would conceivably think that instead of threading an accumulator, he could use a monad.
13:59:36 <shapr> er, yes?
13:59:41 <tuomov> you just make patches Storable and send them over the network..
13:59:46 <Submarine> Is that correct, shapr?
13:59:56 <tuomov> (in the theory of buffers)
13:59:56 <shapr> I think so
14:00:50 <shapr> Submarine: why are you asking this? I'm not sure I understand all the parts of your question.
14:01:04 <shapr> Are you asking whether a monad is better than an accumulator in some cases?
14:01:32 <Submarine> shapr: No, I'm asking if using a monad instead of threading some variable everywhere is a common software engineering method in the Haskell community.
14:01:34 <shapr> Are you asking whether monads are more common than accumulators in Haskell?
14:01:42 <shapr> oh. Yes, definitely.
14:01:49 <shapr> because, they're the same thing.
14:02:36 <shapr> A monad can thread a variable everywhere, and you only have to type the monad code in one place.
14:03:10 <shapr> Submarine: français?
14:03:47 <shapr> tuomov: I think a theory of buffers make sense for undo, for changes to the buffer contents
14:04:00 <Submarine> shapr: correct
14:04:02 <shapr> but I think the purely presentational stuff doesn't really fit in there
14:04:30 <Submarine> shapr: That's what I suspected.
14:04:42 <shapr> tuomov: but I think you sort of said that yourself with primitive transformations vs higher-level transformations.
14:04:48 <tuomov> yes
14:04:53 <shapr> Submarine: will you be doing monads in OCaml?
14:04:59 <Submarine> shapr: No.
14:05:14 <Submarine> shapr: Well, I'm not in the Cristal group, if that's the question.
14:05:36 <Submarine> shapr: I was asked to referee a paper where, essentially, they took a problem that's essentially a list traversal, and rewrote it using monads.
14:05:38 <shapr> :-)
14:05:50 <shapr> ah, I see.
14:06:04 <Submarine> not a list, a more complex structure
14:06:31 <Submarine> my opinion was that this was merely a software engineering issue, and, besides, that the idea was not terribly original
14:07:13 <shapr> Both of those may be true, but in my experience, more usage and knowledge of such techniques would be nice.
14:08:08 <Submarine> Am I wrong in saying that monads would be somewhat useless in OCaml because of the imperative features?
14:08:23 <shapr> monads work fine in OCaml.
14:08:35 <shapr> I've also seen Scheme and Perl implementations of monads.
14:08:52 <Submarine> i.e. a monad is just about threading a variable everywhere and adding some "make the state change" commands?
14:08:53 <shapr> A monad is just a design pattern.
14:09:05 <shapr> No, a monad is a way of structuring a program.
14:09:14 <shapr> Threading a variable is one instance of that.
14:09:16 <tromp> a strategy for combining computations
14:09:20 <Submarine> mmmh
14:09:43 <shapr> This is the best monads tutorial, in my opinion. http://www.nomaware.com/monads/html/index.html
14:09:55 <Submarine> From what I remember in my lambda calculus courses, a monad is much like being able to overload lambda and application in order to do some additional nifty stuff like passing a state around.
14:09:56 <shapr> Would you like to hear my not very formal introduction to monads?
14:10:20 <Submarine> or printing stuff, or counting events, whatever
14:10:22 <shapr> Yes, but the state monad is just the most common.
14:10:50 <shapr> As tromp succintly put it, "<tromp> a strategy for combining computations"
14:11:19 <Submarine> so in a category-style fashion, I would say that a monad is a kind of morphism
14:11:36 <Submarine> it gives the new composition operator on the destination arrows
14:12:08 <shapr> Well, my understanding of category theory and monads has recently been polluted by my study of arrows and category theory.
14:12:38 <tuomov> a monad is a functor together with two natural transformations
14:12:39 <shapr> There is a generalization of monads called arrows, and they're definitely morphisms.
14:12:55 <tuomov> in haskell, the typeclass together with liftM form the functor
14:13:27 <tuomov> with the typeclass working on objects (types), and liftM on morphisms
14:13:58 <tuomov> (and the nat.trans are return and join)
14:14:31 <shapr> Submarine: My thoughts are that, by itself, using monads is not novel. But, there are novel uses of monads.
14:14:40 <shapr> And that probably doesn't help at all :-)
14:15:12 <Submarine> shapr: but, surely, doing state := state U { new element } is not new
14:15:26 <Submarine> I mean, what does the IO monad do, when you print, on a theoretical point? it just lets you append stuff to a list
14:15:38 <shapr> Truly, that does not sound new.
14:16:24 <tuomov> models are just a new (or were when haskell was young) way of thinking of old things
14:16:29 <tuomov> s/models/monads/
14:16:50 <tuomov> started again writing something completely different what the sentence ended up to be
14:18:25 <Submarine> I've read across the tutorial and it's what I thought: it's a kind of way to overload lambda and application by overloading the composition...
14:18:47 <Submarine> it's indeed a kind of functor
14:19:00 <shapr> Arrows are much more nifty :-)
14:19:00 <desrt> shapr; this is me bugging you :)
14:19:10 <shapr> desrt: oh right... I'll check it out.
14:19:19 <Submarine> shapr,  I agree that you can code in ML with monads, but the lack of syntactic support will make it tedious.
14:19:20 * desrt goes over to a friends house and ircs (Sad...)
14:19:43 <Matt-W> shapr: oh yes, like arrows :-)
14:19:58 <Submarine> shapr,  I mean, instead of just coding your functions as if nothing was threaded, you'll have to use your (m a -> (a -> m b) -> m b) function everywhere.
14:20:08 <shapr> Submarine: Even so, sometimes it's still easier to use a monad. I can't think of any example in ML, but I have seen cases in Scheme where a monad was the best choice.
14:20:09 <Submarine> You'd have to use CamlP4 for this.
14:20:23 <desrt> is there a good tutorial somewhere about what y'all mean when you say arrow?
14:20:33 <shapr> desrt: sort of..
14:20:38 <Submarine> desrt,  I personally mean arrow in the sense of category theory.
14:20:43 <shapr> arrows -> http://www.haskell.org/arrows/
14:20:48 <desrt> rawk.
14:20:53 <shapr> desrt: read Ross Paterson's Fun of Programming chapter.
14:21:01 <shapr> That's the best intro, imho.
14:21:08 * CosmicRay adds a MIME type guesser module to MissingH
14:21:16 <shapr> oh hi CosmicRay =)
14:21:24 <CosmicRay> I see camlp4 mentioned
14:21:49 <shapr> Submarine: I don't know much about category theory, though I have been reading about it recently.
14:22:05 <shapr> Category theory looks like a lot of fun.
14:22:10 <CosmicRay> I'll have half the Python standard library ported before long :-)
14:22:17 <shapr> Great!
14:22:29 <Submarine> shapr: I tend to forget about it every so and then until I have to work with people saying things like "natural transformations".
14:22:33 <CosmicRay> does anybody know where I can download internetlib?  http://www.cs.chalmers.se/~hallgren/InternetLib/ doesn't seem to have a download link
14:22:44 <Submarine> CosmicRay,  yes, I mention camlp4.
14:22:46 <phubuh> i keep thinking of category theory in chemistry class
14:22:59 <shapr> CosmicRay: you can get it from his 'hacker' versions.
14:23:08 <Submarine> CosmicRay,  My understanding is that one can emulate the syntactic aspects of Haskell monads by using camlp4.
14:23:09 <CosmicRay> versions of Fudgets?
14:23:11 <shapr> CosmicRay: I'm still trying to get it all built and see if it can be separated from Fudgets.
14:23:20 <phubuh> it seems to me that chemical reactions are morphisms in a category whose objects are chemical compounds
14:23:22 <Submarine> CosmicRay,  at least to some extent
14:23:26 <shapr> You'll need Fudgets to make it work, I *think*.
14:23:35 <CosmicRay> shapr: ahh, that would be cool.  I am really only interested in the htmlFetchF stuff
14:23:38 <Submarine> phubuh,  you want linear logic then
14:23:41 <shapr> phubuh: and you didn't tell your teacher that?
14:23:53 <shapr> CosmicRay: it does a lot more than that.
14:23:57 <Submarine> phubuh,  obviously, chemistry is multiplicative linear logic
14:24:16 <shapr> Greetz Ninja Jones.
14:24:20 <phubuh> Submarine: oh, really?  i'll look into that, thanks
14:24:22 <SyntaxNinja> hihi
14:24:26 <phubuh> shapr: i highly doubt he'd be interested :)
14:24:30 <SyntaxNinja> Igloo: did your ghc hit sarge?
14:24:34 <shapr> Whoa, 97 clients on #haskell :-)
14:24:49 <Submarine> phubuh,  multiplicative linear logic is just something like having sockets of a certain shape, and plugs of another
14:25:07 <Submarine> you have to plug all sockets and plugs together
14:25:26 <Submarine> if you have exponentials, you have the permission to replicate some objets (which may have any number of plugs and sockets)
14:25:42 <shapr> This sounds nifty.
14:25:55 <phubuh> very nifty
14:26:31 <CosmicRay> shapr: yeah but that's the only part I need
14:26:39 <phubuh> in category theory, what do you call the relation that exists between A and B if there exist morphisms f : A -> B and G : B -> A?
14:26:46 <CosmicRay> Submarine: what is the point of a monad in OCaml?
14:26:50 <CosmicRay> Submarine: it already has refs
14:26:53 <phubuh> isomorphism?
14:27:11 <Submarine> CosmicRay,  you can do more than passing a state around
14:27:26 <Submarine> phubuh,  naaaaah
14:27:35 <CosmicRay> actually, I'd love to see a camlp4 backend that emits Haskell.... :-)
14:27:43 <phubuh> CosmicRay: refs make the state monads unnecessary, but not, say, the list monad :)
14:27:45 <CosmicRay> pretty-printed, of course.
14:27:47 <stepcut> CosmicRay: heh
14:27:55 <phubuh> Submarine: wild guess :-)
14:28:06 <shapr> desrt: you here?
14:28:23 <desrt> hi
14:28:31 <shapr> desrt: where do you want it to go?
14:28:32 <desrt> reading about arrows, becoming confused, etc :)
14:28:42 <phubuh> well, the relation isn't an isomorphism, but f and g are isomorphisms, right?
14:28:42 <Submarine> phubuh,  proof: in the category of sets, there exist morphisms from { 0 } to {0, 1} but they are not isomorphic
14:28:49 <Submarine> and the reverse
14:28:55 <Submarine> NOOOOOH
14:29:11 <shapr> ?
14:29:23 <Submarine> you'd need some condition like f o g = Id_B and g o f = Id_A if I'm not mistaken :-)
14:29:28 <phubuh> wikipedia says a morphism f : A -> B is called an isomorphism if there exists a morphism g : B -> A, f o g = id_B, and g o f = id_A
14:29:29 <phubuh> yeah
14:29:32 <monochrom> If you have f:A->B, g:B->A, and no other information, there is not much you can say about A and B.
14:29:40 <desrt> shapr; desrt@desrt.ca
14:30:00 <phubuh> if you built chemistry on category theory or linear logic or something, you could describe things a lot more concisely :)
14:30:04 <shapr> awright, I'm going to email John Petersen first and ask him if it's okay to do that...
14:30:13 <desrt> cool.  thanks.
14:30:21 <Submarine> phubuh,  well, chemistry is about electron orbitals, not about writing formulas :-)
14:30:22 <monochrom> chemistry on linear logic?
14:30:30 <shapr> He said it's okay for me to do random admin on the box, but I've been a bit worried about killing www.haskell.org  =)
14:30:38 <phubuh> Submarine: sorry, i'm talking naive high school chemistry here :-)
14:30:42 <CosmicRay> shapr: I am making sure that each network client module I write can download data from a URL
14:30:48 <Submarine> monochrom,  sure
14:30:58 <desrt> shapr; just give me root.  i'll do it for you
14:30:58 <CosmicRay> shapr: I can then provide a generic URL library to download stuff from any known protocol
14:30:59 <desrt> :)
14:31:00 <monochrom> I think I see how.
14:31:13 <Submarine> monochrom,  balancing a chemical equation is just multiplicative linear logic
14:31:16 <CosmicRay> shapr: I *don't* want to write code to download HTTP, especially if someone else has already done it!
14:31:26 <CosmicRay> HTTP is way too complex.
14:31:42 <shapr> Can't you use HTTP.hs from XmlRpc?
14:31:46 <CosmicRay> hmm
14:31:51 <shapr> or darcs binding to curl?
14:31:58 <shapr> HTTP.hs even has a Browser monad.
14:32:04 * CosmicRay googles
14:32:48 <shapr> I can get the url for you...
14:33:15 <shapr> CosmicRay: what other libs you want? I tend to remember haskell libs I've run across.
14:33:36 <shapr> Well, I hope he had fun.
14:41:05 <CosmicRay> shapr: none other come to mind at the moment
14:41:10 <CosmicRay> shapr: I've saved off your reply to me
14:41:19 <CosmicRay> on the list
14:41:20 <CosmicRay> thanks, btw
14:41:27 <shapr> sure :-)
14:41:42 <shapr> oh hey, question about your docs merger idea
14:41:47 <CosmicRay> sure
14:41:51 <shapr> how would you handle a really huge amount of docs?
14:42:03 <CosmicRay> what do you mean?
14:42:10 <CosmicRay> orders of magnitude larger than ghc
14:42:11 <CosmicRay> ?
14:42:16 <shapr> well, I dunno..
14:42:21 <shapr> there's a lot of Haskell code out there
14:42:28 <shapr> and I have a whole lot downloaded
14:42:29 <CosmicRay> I don't think it would be a problem
14:42:40 <shapr> I'd like to be able to search through all the source I have
14:42:52 <shapr> seems like you'd need some way to navigate more easily.
14:42:53 <CosmicRay> I am individually calling haddock on each package
14:43:00 <CosmicRay> then dumping the interface files
14:43:00 <CosmicRay> ah.
14:43:22 <CosmicRay> I bet haddock could be enhanced to do a javadoc-style output
14:43:28 <CosmicRay> with the three frames
14:47:58 <shapr> would be nice
15:00:39 * phubuh digs the ``twin peaks: fire walk with me'' sound track
15:01:20 <bourbaki> nighto
15:01:36 <vivek> bonne nuit bourbaki 
15:01:45 <bourbaki> :)
15:24:45 <abstrato_general> I have a Hugs question.
15:25:04 <abstrato_general> Can't I declare a variable in Hugs like one does in, say, a Python interpreter?
15:25:07 <Boegel> abstrato_general: shoot
15:25:21 <kristnjov> try typing: n = 5; putStr (show n)
15:25:36 <kristnjov> ok that didn't work :)
15:25:43 <Boegel> :)
15:25:58 <abstrato_general> initializing with n :: Float doesn't work either.
15:26:04 <kristnjov> i think i'm so smart sometimes
15:26:09 <abstrato_general> I'm starting to wonder what a Haskell interpreter is good for.
15:26:17 <ayrnieu> abstrato - GHC evaluates differently, as if you were in a definition, and thus will let you do that.  eh, 'initializing?'  that won't work.
15:26:37 <kosmikus> abstrato_general: you cannot in hugs, you can in ghci
15:26:47 <shrimpx> abstrato_general: use ghci pls :)
15:26:52 * abstrato_general is getting paradigm shock.
15:26:53 <ayrnieu> abstrato - um, I think that you mean to ask about the usefulness of Hug's repl.
15:26:53 <shrimpx> hugs is so July 2004
15:27:01 <shrimpx> or November 2003 whatever it is
15:27:11 <Boegel> I'm out
15:27:13 <ayrnieu> yes, ghci.  Anyway, as krist said: let n = 5 in putStr (show n)
15:27:15 <Boegel> bye
15:27:48 <abstrato_general> ohh. 
15:27:50 <shrimpx> in ghci you can say 'let x = 5' followed by Enter
15:27:52 <shrimpx> etc
15:28:07 <abstrato_general> Main> let jean = Male in crossdress jean
15:28:07 <abstrato_general> Skirts   
15:28:11 <abstrato_general> good.
15:28:16 <abstrato_general> thanks :)
15:28:17 <shrimpx> hahaha
15:28:54 <abstrato_general> I wish I could just declare variables and keep'em in the environment. But, alors, it's prolly because of some paradigm.
15:29:04 <kristnjov> like a GLOBAL variable?? don't curse!
15:29:17 <ayrnieu> abstrato - we've already suggested that you use GHCi, as it offers that.
15:29:21 <abstrato_general> just in the interpreter, not in programs :)
15:29:28 <abstrato_general> ayrnieu okay, okay, thanks :)
15:30:03 <abstrato_general> crossdress n = dress (trans n)  
15:30:13 <abstrato_general> this is pretty. In a few more days I'll be talking like that.
15:31:32 <ayrnieu> abstrato - oh, a crossdress-con?  Where?
15:31:40 <kristnjov> transpose "male" == "female", coincidence?
15:35:10 <SyntaxNinja> Oo
15:35:53 <abstract_general> OOo is awful.
15:36:04 <abstract_general> I wish open source pundits would stop touting it.
15:37:59 <JerubBaal> abstract_general: yes.
15:38:00 <JerubBaal> I agree.
15:38:13 <JerubBaal> Its the best all round competitor to word, but it sucks.
15:38:45 <abstract_general> I wonder how hard it would be for Microsoft to just port the windowing environment and the win32 API to a Linux.
15:38:47 <abstract_general> they don
15:38:49 <ayrnieu> LyX++ , anyway.
15:38:51 <abstract_general> they don't need to GPL it. 
15:38:52 <kosmikus> I've never understood why anyone would want to compete with word when there's TeX
15:39:06 <abstract_general> kosmikus because pasting pictures is easier.
15:39:18 <ayrnieu> kosmikus - because people want to compete with word =)  People are silly.
15:39:19 <JerubBaal> kosmikus: its approching the problem from a different angle.
15:39:22 * abstract_general is a TeXie, himself, but he needs Excel professionally.
15:39:34 <JerubBaal> kosmikus: one angle wants to be able to produce professional documents, the other wants to be windows.
15:39:43 <abstract_general> LyX is awful. TeXMacs is a bit better.
15:39:56 * kosmikus wasn't quite serious; I know that the programs have different goals
15:40:06 <JerubBaal> I still use LyX as a crutch when I write tex.
15:40:13 <kosmikus> I just never felt the need to use the Word-like angle for anything ...
15:40:16 <abstract_general> LyX made me lost time.
15:40:27 <JerubBaal> "I can't figure this out" (open LyX, do it, save as .tex, read the tex), "aah! thats how..."
15:40:37 <kosmikus> using (La)TeX directly is easier in the long run than fighting LyX
15:40:40 <abstract_general> I prefer having to look at documentation than using LyX
15:40:58 <abstract_general> TeXMacs is good.
15:41:00 <kosmikus> TeXmacs might be better than LyX in its interface, but it's not TeX
15:41:26 <abstract_general> the excessively structured approach of latex is annoying.
15:41:46 <kosmikus> excessively structured?
15:41:48 <abstract_general> But I sure miss the pretty typesetting when working in word.
15:41:49 <kosmikus> not really
15:42:00 <abstract_general> yes! not every document is structured like a doctoral thesis :-|
15:42:21 <kosmikus> no one forces you to either
15:42:27 <kosmikus> most documents have at least sections, though
15:42:50 <ayrnieu> bah, I still fondly remember the first time that I needed to write up a document, and decided to do it in LyX.  I got complimented on the physical appearance of the paper.
15:43:20 <ayrnieu> kosmikus - oh, TeXmacs doesn't emit TeX?  Bizarre.
15:43:24 <kosmikus> abstract_general: look at ConTeXt then; it doesn't try to impose that much on the user, but it also requires you to work harder to get a nice result
15:44:07 <kosmikus> ayrnieu: no, it's not named very well ... you can export to TeX, I think, but that's not the default, and you can't go the other way in general, i.e., you cannot import arbitrary LaTeX styles
15:44:25 <mattam> kosmikus: i made an ebuild for hs-plugins, can i add it in dev-haskell/ ?
15:45:23 <kosmikus> mattam: wanted to do that, too. thanks, also for asking. go ahead.
15:45:45 <abstract_general> my head is so mixed up.
15:46:01 <stepcut> ayrnieu: I am pretty sure my college papers got higher grades than they deserved simply because they where typeset with latex
15:46:16 <mattam> is there an haskell herd ?
15:46:45 <abstract_general> can I create a data type Couple that is a (Gender, Gender) vector/list?
15:47:21 <kosmikus> mattam: yes
15:47:37 <tromp> newtype Couple = [(Gender, Gender)] you mean?
15:47:49 <kosmikus> mattam: want to add yourself to the herd? you're welcome
15:47:50 <tromp> oops, i mean type
15:47:56 <tromp> not newtype
15:48:01 <mattam> i'll do
15:49:22 <ayrnieu> abstract - data Couple = Couple (Gender, Gender) | ProbablyIllegal [Gender]
15:50:01 <abstract_general> ayrnieu that's what I was thinking.
15:50:23 <abstract_general> say, what if I needed a function that returned "1" if the two genders are the same and "0" if they're not?
15:50:50 <kosmikus> abstract_general: you'd write it?
15:51:03 <abstract_general> :-P
15:51:15 <kosmikus> mattam: tell me when you're done committing ... I'll test
15:54:03 <abstract_general> is there any work in Haskell for parallell computing?
15:54:11 <abstract_general> it sounds like a good langiag
15:54:15 <abstract_general> it sounds like a good language for that.
15:54:33 <mattam> kosmikus: done
15:57:22 <kosmikus> mattam: thx -- looks quite simplistic ;)
15:57:30 <abstract_general> wait, wait. If I have a data type Couple, how do I compare its two elements?
15:57:38 <abstract_general> I mean, how do I access each element?
15:58:59 <tromp> usually by pattern matching
15:59:24 <tromp> first (Couple (A,B)) = A
16:00:55 <tromp> it would be more natural not to use the (,) in date declaration though
16:00:58 <ayrnieu> isDefinitelyIllegal (Couple a b) | inSameFamily(a,b) = True
16:02:03 <abstract_general> um, yes, I remember "first" from Lisp I think.
16:02:10 <tromp> which you'd probably write with inSameFamily a b
16:02:25 <ayrnieu> yes, as tromp said.
16:10:40 <abstract_general> what is wrong with this? 
16:10:41 <abstract_general> mean :: [a]->Float
16:10:41 <abstract_general> mean this = (sum this)/(length this)
16:10:58 <Pseudonym> What does your implementation tell you is wrong?
16:11:14 <abstract_general> ERROR "c:\inc.h":20 - Type error in explicitly typed binding       
16:11:22 <abstract_general> *** Term           : mean
16:11:22 <abstract_general> *** Type           : [Int] -> Int
16:11:22 <abstract_general> *** Does not match : [Int] -> Float                                             
16:11:52 <Pseudonym> Do you know how to interpret that error?
16:12:08 <Pseudonym> (Hugs error messages aren't as helpful as they could be, BTW.)
16:12:08 <abstract_general> Apparently not. 
16:12:27 <Pseudonym> WHat it means is that the system has decided that the type of mean should be [Int] -> Int
16:12:36 <Pseudonym> Which doesn't match your type signature.
16:12:37 <abstract_general> why dividing an integer by another would not render a float?
16:12:47 <Pseudonym> @type (/)
16:12:48 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
16:12:49 <abstract_general> so, how do I force that?
16:12:55 <abstract_general> oh, ok.
16:13:04 <abstract_general> no, not ok. 
16:13:14 <Pseudonym> @type fromInt
16:13:15 <lambdabot> bzzt
16:13:17 <Pseudonym> Hmmm.
16:13:21 <Pseudonym> @type fromIntegral
16:13:22 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
16:13:25 <Pseudonym> That's it.
16:13:34 <Pseudonym> DOes that help?
16:13:46 <abstract_general> I'm trying to parse.
16:13:52 <Grind> hello
16:13:59 <Pseudonym> G'day Grind.
16:14:03 <Grind> hi Pseudonym 
16:14:11 <abstract_general> nope, I'm still confused.
16:14:22 <Pseudonym> OK.  This might be more useful.
16:14:32 <Pseudonym> fromIntegral :: (Integral a, Num b) => a -> b
16:14:44 <Grind> is there any functional programming language with good support for GUI stuff?
16:14:47 <Pseudonym> Just rearranged it a bit and removed the explicit quantification.
16:14:56 <JerubBaal> Grind: most of them have GUI bindings.
16:15:17 <Pseudonym> Concurrent Clean's is probably the best integrated.
16:15:20 <abstract_general> yes, but how does the type declaration of fromIntegral explain how to get mean to return a float?
16:15:25 <Pseudonym> But I don't think it works under non-Windows.
16:15:46 <Grind> by good support I don't mean just bidings
16:15:57 <Pseudonym> abstract_general: Why do you think the system thinks that mean should return an Int?
16:16:10 <Pseudonym> One thing might help.
16:16:21 <Grind> but also possibility to use an IDE to "draw" them and all that stuff
16:16:24 <Pseudonym> Unlike in C, Haskell does not automatically coerce types.
16:16:36 <abstract_general> oh
16:16:48 <Grind> in the beginning I hated that about haskell :)
16:16:55 <Grind> now I actually like it
16:17:08 <abstract_general> ohh.
16:17:09 <Grind> because you really control the casts
16:17:16 <Pseudonym> Yeah.  It's the price you pay for not having to declare the types of all of your variables explicitly, too.
16:17:25 <tromp> off to bed...
16:17:35 <Pseudonym> And fact is, unless it's a true type promotion, you end up casting explicitly in C and C++ anyway to shut up the compiler warnings.
16:17:48 * esap doesn't think of non-use of casts as a cost.
16:18:05 <Pseudonym> Me neither, though fromIntegral is a long word.
16:18:19 <Grind> yeah
16:18:22 <Pseudonym> There's something very elegant about (Float)i
16:18:28 <Grind> I just wish there was some elegant sytax
16:18:40 <Pseudonym> Though it's better than C++.
16:18:48 <Pseudonym> static_cast<double>(i)
16:18:54 <Grind> I use things like   +>>
16:18:58 <esap> There is also something very bad about (Float)i, because it's not at all obvious that it can fail.
16:18:59 <Grind> <<+
16:19:00 <abstract_general> I forgot how to comment out lines?
16:19:02 <Grind> <<+>>
16:19:15 <Pseudonym> abstract_general: -- single line comment
16:19:18 <Pseudonym> {- inline comment -}
16:20:06 <Grind> I think my definition is
16:20:07 <abstract_general> ERROR "c:\inc.h":19 - Instance of Fractional Int required for definition of mean
16:20:12 <abstract_general> what IS Fractional Int?
16:20:25 <Grind> a >>+ b = fromIntegral a + b
16:20:45 <Grind> Fractional is for things that are not integer
16:20:49 <Grind> like Rationals
16:20:55 <Grind> and Floats
16:21:08 <abstract_general> I just wanted to write a "mean" function :-|
16:21:14 <Grind> and it says Int is not Fractional
16:21:20 <Grind> ah mean!
16:21:22 <Grind> wait
16:21:23 <abstract_general> mean this = fromIntegral (sum (this))/(length (this))
16:21:28 <Grind> I did a general one once :)
16:21:32 <abstract_general> er, forget "fromintegral", I was just toying around.
16:21:49 <abstract_general> mean this = (sum (this))/(length (this))
16:21:54 <Grind> ...
16:21:56 <Grind> average :: (Real a, Fractional b) => [a] -> b
16:21:56 <Grind> average xs = realToFrac (sum xs) / fromIntegral(length xs)
16:21:59 <Grind> ...
16:22:12 <Grind> that is pretty ineficient but quite general
16:22:33 <abstract_general> bah, back to the documentation. There's a lot I don't understand yet.
16:22:37 <abstract_general> Thanks for all the fish anyway,
16:22:43 <Pseudonym> No problem.
16:23:06 <Grind> by the way, one thing I don't get
16:23:12 <Grind> there are unboxed pairs
16:23:16 <Pseudonym> Yes.
16:23:20 <Grind> but I cannot find strict pairs anywhere...
16:23:26 <Grind> are these not available?
16:23:26 <esap> grind: your version is actually two general, it's hard to use.
16:23:36 <Grind> esap: yes, I agree :)
16:23:42 <esap> grind: s/two/too/
16:23:43 * abstract_general was trying to write a standard deviation function.
16:24:01 <Pseudonym> Grind: I don't believe there are strict pairs, no.
16:24:31 <Grind> I miss them a lot, even more than I would miss unboxed, because you can always use a flag to unbox strict types
16:24:32 <Pseudonym> What do you need them for?
16:24:42 <shapr> g'day Pseudonym 
16:24:44 <Pseudonym> Ah, no, not in GHC.
16:24:51 <Pseudonym> In GHC< you don't use a flag for boxing.
16:24:59 <Pseudonym> It's to do with the way it's implemented under the covers.
16:25:01 <Pseudonym> G'day shapr.
16:25:10 <shapr> had a chatce to check out Yi sources?
16:25:10 <Grind> ?
16:25:13 <shapr> er "chance"
16:25:14 <Pseudonym> The STG machine doesn't use flags and tags.
16:25:20 <Pseudonym> No, not yet.
16:25:22 <Grind> hi shapr 
16:25:22 <shapr> ok
16:25:26 <shapr> greetz Grind 
16:25:26 <Pseudonym> I'm glad my suggested name stuck, though.
16:25:34 <Pseudonym> But I kind of liked "lambaste" too.
16:25:40 <Grind> Pseudonym: isn't there a flag for ghc to unbox strict types?
16:25:43 <kosmikus> yi is a great name
16:25:47 <Pseudonym> Oh, duh.
16:25:48 <Pseudonym> Yes.
16:25:50 <shapr> yes, yi is best.
16:25:50 <Pseudonym> Sorry.
16:25:54 <esap> What does it do?
16:25:57 <Grind> Pseudonym: ok that's what I meant ;)
16:26:06 <Pseudonym> I thought you meant a bit in the structure under the covers.
16:26:08 <Grind> Pseudonym: as for what I wanted strict pairs...
16:26:17 <shapr> Y I, pun on vi, and really short to type
16:26:22 <shapr> hei esap 
16:26:23 <Pseudonym> No, a value can only be strict in context.
16:26:35 <shapr> esap: what does yi do?
16:26:38 <Pseudonym> Not strict everywhere.
16:26:39 <Grind> I keep using things like foldl' <--
16:26:42 <esap> shapr: yes.
16:26:47 <Grind> strict fold
16:26:53 <shapr> esap: darcs get http://www.cse.unsw.edu.au/~dons/yi
16:26:54 <Pseudonym> Good.  foldl' is good for you
16:26:58 <Grind> yeap
16:27:01 <shapr> esap: it is cool. jump in and make it cooler.
16:27:08 <Grind> now try to generalize something like
16:27:12 <Grind> foldl' (+) 0
16:27:19 <kosmikus> functions are strict in an argument, I don't know what a strict value is
16:27:22 <Grind> to work with pairs of Ints instead of Ints
16:27:35 <Pseudonym> In particular, you can make constructor functions strict in an argument.
16:27:43 <shapr> esap: http://news.gmane.org/gmane.editors.post-emacs/
16:27:49 <Grind> it won't work because pairs will only be reduced to head normal form
16:27:50 <Pseudonym> But yes, values are only strict in context.
16:28:17 <Pseudonym> Well, Grind, you could easily handle that by defining your own pair type.
16:28:26 <Grind> Pseudonym: yes 
16:28:26 <Pseudonym> data StrictPair a b = StrictPair !a !b
16:28:30 <Grind> Pseudonym: I have 2 solutions
16:28:39 <Grind> Pseudonym: that one, and using a deepFold
16:29:03 <Pseudonym> Right.
16:29:06 <Grind> Pseudonym: now I prefer the 1st 
16:29:17 <tuomov> shapr: and there's still is the unicode character U+7fa9 :)
16:29:35 * shapr googles
16:29:41 <Grind> Pseudonym: but sometimes its tedious to define your own pairs to use just in one or two functions
16:29:42 <Pseudonym> Sometimes you can avoid pairs altogether and use CPS.
16:29:53 <Pseudonym> But that's only useful if you really need strict control over evaluation order.
16:30:22 <Grind> I think that's overkill in many situations
16:30:31 <Pseudonym> In most situations.
16:30:33 <Pseudonym> :-)
16:30:36 <Grind> yeap :)
16:30:43 <shapr> tuomov: lemme guess, Yi from Confucius?
16:31:08 <Pseudonym> Actually, do we know anyone who does Chinese calligraphy?
16:31:13 <Pseudonym> That'd make a nice logo.
16:31:15 <tuomov> shapr: yes
16:31:17 <Grind> In some cases I just want to define some polymorphic function similar to foldl' or where I use foldl'
16:31:20 <shapr> spiffy :-)
16:31:26 <Grind> and I want to call it with some pairs of numbers
16:31:32 * Pseudonym nods
16:31:49 <kosmikus> Pseudonym: have anything to write for the HCAR?
16:31:49 <Grind> Pseudonym: by the way in the   foldl' (+) 0   example
16:32:04 <Pseudonym> kosmikus: Nah.  Been busy with non-Haskell a lot lately.
16:32:04 <shapr> anyone else has interesting changes for Yi that I can pull?
16:32:20 <kosmikus> shapr: who's going to report on yi for HCAR? you, dons, tuomov? choose one, start writing ;)
16:32:25 <Grind> Pseudonym: when generalizing it to pairs I don't even want to declare a new function, I'll just use Lambda or Freepoint Style with Arrows
16:32:25 <kosmikus> Pseudonym: ok
16:32:43 <Grind> Pseudonym: So I obviously want to avoid declaring  a new type ;)
16:32:47 <shapr> kosmikus: righto
16:32:59 * esap gets compilation failure from yi "unknown package name: plugins".
16:33:10 <shapr> esap: oh, you need the latest nightly hs-plugins 
16:33:13 <kosmikus> yi depends on hs-plugins
16:33:48 * esap apt-gets.
16:33:52 <shapr> esap: ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots/
16:33:59 * Grind is thinking about trying DARCS
16:34:07 <shapr> esap: actually just ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots/hs-plugins-20041021.tar.gz
16:34:22 <shapr> Grind: darcs is great
16:35:09 <dons> moin
16:35:34 <abstract_general> what _is_ darcs?
16:35:35 <Grind> shapr: what is keeping me from dumping CVS, is KDE cervisia... I really like using Kompare to see the diffs between versions
16:35:47 <Pseudonym> http://www.omniglot.com/writing/yi.htm
16:35:50 <Pseudonym> I did not know that.
16:35:59 <abstract_general> ah, like cvs.
16:36:37 <tuomov> but much better
16:36:45 <abstract_general> how so?
16:36:55 <abstract_general> version control is pretty simple. 
16:37:04 <Grind> tuomov: much better then CVS isn't saying much though :)
16:37:15 <Pseudonym> darcs is a bit more like arch, as I understand it.
16:37:22 <Grind> even though I use it I really hate it... :-/
16:37:24 <tuomov> but not so fascist
16:37:25 <Pseudonym> But not quite.
16:37:28 <esap> version control is not simple when you have lots of code to control.
16:37:44 <abstract_general> well, doesn't it ... control versions?
16:37:47 <abstract_general> I mean.
16:38:06 * Grind misses file renaming/moving so much...
16:38:13 <Grind> that is the main reason why I want to dump cvs
16:38:55 <Pseudonym> My $DEITY, the Yi alphabet has 1,164 characters.
16:39:03 <tuomov> abstract_general: cvs has lots of problems. compared to other modern version control systems (subversion, arch), the main advantages of darcs are perhaps it being completely decentralised -- each working copy is a full repository -- (arch isn't quite as decentralised and svn not at all) and it being very easy to start to use (unlike e.g. arch)
16:39:14 <kosmikus> abstract_general: I guess if you only know cvs, you don't even notice the problems it has
16:39:39 <dons> Pseudonym: yi will have 1,164 primops then!
16:39:40 <Pseudonym> 819 if you only use the standardised ones.
16:39:48 <kosmikus> Pseudonym: there are more kanji
16:39:51 <tuomov> abstract_general: you don't need a special server for darcs repositories; any http capable server will do, and you can receive patches by email
16:40:04 <Grind> kosmikus: well like I said, I only use cvs... but I miss at least renaming and moving... :-/
16:40:08 <abstract_general> hmm
16:40:47 <kosmikus> Grind: I use svn a lot at the moment, it's quite okay compared to cvs, and it's relatively easy to convince other people that it's an improvement
16:41:10 <tuomov> I also use svn for Ion atm, but if I was converting from cvs now, I'd go for darcs
16:41:25 * abstract_general thought ion was a one-man show
16:41:28 <Pseudonym> Ah, I see.
16:41:31 <kosmikus> I still feel darcs cannot be used as long as it doesn't have proper conflict management
16:41:39 <Grind> kosmikus: yeap that is the one I'll probably end up moving to. Because it's similar to CVS, and because kde will probably move to it, and therefore cervisia will support it
16:41:41 <Pseudonym> It has the largest set of standardised syllables of any language.
16:41:47 <tuomov> abstract_general: it mostly is, but you still want version control with that big projects
16:42:05 <tuomov> helps keeping track of your changes, and other people staying on the bleeding edge
16:42:05 * abstract_general begins to ponder the nightmare KDE must be.
16:42:13 <kosmikus> tuomov: ok, for one-person projects, darcs is actually quite good (which is ironic, as it claims that it's strength is being distributed)
16:42:16 <Grind> abstract_general: ?
16:42:33 <Pseudonym> abstract_general: It's not KDE's fault.  It's a hard problem.
16:42:34 <abstract_general> I mean, managing the distributed development.
16:42:40 <tuomov> actually, distributedness is quite essential for one person projects
16:42:41 <abstract_general> I know it's not KDE's fault.
16:42:53 <kosmikus> tuomov: true
16:42:53 <Grind> tuomov: why?
16:43:03 <tuomov> should be easier to get other people involved when you don't have to give them accounts
16:43:22 <kosmikus> what I like so much about darcs is that you can record patches locally
16:43:24 <tuomov> and it is easier for you when you don't have to try to apply random patches manually
16:43:30 <kosmikus> I would really like to have that in svn
16:43:36 <tuomov> that's very convenient too
16:43:39 <ayrnieu> Mother of God, I must learn this 'Yi' language.
16:43:50 <Grind> lol 
16:43:50 <Pseudonym> Arch can do it.  Assuming you can handle the politics.
16:44:08 <kosmikus> Arch can do what?
16:44:08 <tuomov> arch is nuts&bolts. It's impossible to use.
16:44:36 <Pseudonym> Arch can do the local patching and upstream merging.
16:44:40 <Grind> btw, ghc is using cvs, right?
16:44:48 <Pseudonym> Oh, I'm not defending arch. :-)
16:45:13 <tuomov> a lot of projects are still using cvs
16:45:34 <tuomov> I do not want to go back to using it.
16:45:41 <tuomov> cvs is crap.
16:45:59 <dons> I've been really *enjoying* using darcs for yi so far
16:46:15 * Pseudonym backs away from dons slowly
16:46:22 <dons> but then, no ones ('cept shae) is sending patches ;)
16:46:33 <ayrnieu> dons - yi?  Something other than Yi language?
16:46:37 <Pseudonym> Oh, fair enough.  I always enjoy his patches too.
16:46:38 * esap got "Fail: user error" from Yi. Hmm...
16:46:46 <kosmikus> dons: wait a while ... it might happen
16:47:01 <tuomov> svn is ok, but it is painful to set up a server for it. darcs is truly wonderful
16:47:19 <dons> also, I'm using darcs over 3 machines for development. 2 openbsd, and 1 linux box
16:47:26 <dons> so there is lots of pushing patches around
16:47:34 <dons> and darcs is nice for that.
16:47:53 <dons> so I push to my linux machine, test yi, then push to the world-visible repo
16:48:03 <tuomov> and svn still can't do proper merging of changes in one branch to another
16:48:32 <kosmikus> tuomov: we have a svn server here at the institute which is really easy to use; someone else has been doing the hard work and setting up a web interface. Lucky for me
16:49:13 <kosmikus> tuomov: is darcs really so much better when it actually comes to *merging* changes?
16:49:26 <Igloo> SyntaxNinja: It's in for x86 only ATM. If you're going to build-dep on >= 6.2.2 then it would be polite to wait a day or two until most arches have built it (I can let you know when is a good time)
16:49:38 <tuomov> kosmikus: svn doesn't really have a merge. It just makes a diff and applies it
16:49:59 <tuomov> darcs has patch bundles, so you get the messages and everything along it
16:50:24 <kosmikus> right, but if you get conflicts, things get confusing
16:50:37 <Igloo> dons: My plan is to work on the syntax highlighting side (unless someone else is), so you probably won't see anything from me for a while (especially as I probably won't achieve anything useful at GPCE)
16:50:50 <tuomov> no more so than in any other version control system
16:51:00 <tuomov> you get files with special markers, which you must fix
16:51:53 <dons> Igloo: great! I'm want to concentrate on the keybinding lexers, and dynamic haskell eval. so if other people work on "theory of buffers" stuff, and *the UI*, that is really good :)
16:52:15 <tuomov> a merger of the patch and whatever is in the repository gets applied there though, but if it is a working copy repository, it's not a problem
16:52:16 * dons doesn't like hacking ui code, (blargh)
16:52:28 * Igloo hasn't read the theory of buffers post, but the couple of lines I scanned didn't really make sense to me
16:52:30 * ayrnieu tentatively determines that 'Yi' means 'some kind of haskell-extensible editor'.
16:52:34 <Grind> dons: UI, syntax highlight... which project are you talking about?
16:52:38 <Pseudonym> Text UI code is kind of unnecessarily painful.
16:52:53 * tuomov doesn't like writing ui code :)
16:53:12 <Igloo> I'd have thought the interesting bit was commutation of undo/redos, not commmutation of edits and syntax highlighting
16:53:13 <tuomov> but there are things you have to do to further your goals
16:53:20 <Grind> oh yi
16:53:25 <Igloo> But maybe I'm missing the point as I haven't read it  :-)
16:53:28 <Grind> what is the homepage for yi?
16:53:36 * kosmikus wonders why he didn't get any post-emacs posts after the initial two after he subscribed ...
16:53:48 <kosmikus> especially nothing about a theory of buffers ...
16:54:01 <Igloo> It was a while ago, possibly before you subscribed
16:54:07 <Igloo> It's been quiet of late
16:54:11 <kosmikus> so, no post-emacs mails today?
16:54:22 <kosmikus> I mean, the last 24 hourse or so?
16:54:29 <musasabi> Has anyone created dataflow graphs from arrows?
16:54:35 <Igloo> Date: Tue, 19 Oct 2004
16:54:44 <Grind> never mind found it on the logs
16:54:44 <tuomov> Igloo: well, everything you do to the original file to get to the final display is a sort of patch or transformation to the file
16:54:45 <Igloo> Want me to forward you a copy?
16:55:01 <kosmikus> Igloo: yes, please
16:55:17 <Igloo> tuomov: But I would think about it as "the syntax highlighter reacts to the buffer changing" and then ignore it
16:55:20 <Pseudonym> musasabi: Yes, the Fudgets people have.
16:55:49 <Igloo> Send
16:55:51 <Igloo> Sent even
16:56:06 <tuomov> the syntax highlighter is a transformation that makes a structure back into a viewable almost plaintext format
16:56:21 <tuomov> and the editor only sees this, and applies patches to it as the user modifies this view
16:56:23 <SyntaxNinja> Igloo: ok
16:56:41 <tuomov> we want to propagate those changes down close to the file at the bottom of the transformation chain
16:57:02 * Igloo heads home
16:57:04 <tuomov> so we calculate a commutation with each transformation and the patch
16:57:05 <kosmikus> Igloo: thx
16:57:09 <kosmikus> ... and bye
16:57:52 <tuomov> a commutation of the syntax highlighter and patch calculates a structural patch from a plaintext patch and maybe changes something in the highlighter as well
16:58:50 <tuomov> anyway, it's just a way of looking at the transformation chain
16:59:08 <tuomov> one could look at it as passing an event around as well
16:59:11 <dons> yep
16:59:22 <dons> but also the structure of the layers from buffer to ui
16:59:31 <dons> (it is also a way of looking at)
17:00:38 <tuomov> but I think this commutation of patches (operators) is a more "functional" view at it than an event-passing one
17:01:26 <dons> yes. and we should be aiming for nice functional abstractions -- as a design principle
17:01:27 <musasabi> Pseudonym: any more precise info, the fudgets bibliography does not seem to reference such things..
17:05:56 * dons looks in awe/fear at the lack of comments in BSD vi src
17:09:12 <dons> Igloo: on the syntax highlighting, I'd love to rip out ghc's lexer and parser
17:09:28 <dons> and the ppr, so we get a working indent mode
17:09:50 <Pseudonym> dons: I think that won't scale.
17:10:00 <Pseudonym> Any decent editor is going to need to handle any language.
17:10:18 <Pseudonym> Can you imagine an incremental parser for fortran?
17:10:21 <dons> of course! the haskell syntax and ppr are just plugins :)
17:10:37 <Pseudonym> musasabi: Have you read the Fudgets thesis?
17:11:04 <Pseudonym> http://www.cs.chalmers.se/~hallgren/Thesis/top.html
17:11:41 <dons> (of course the editor will handle any language, not of course an inc. parsre for fortran :{
17:11:49 <Pseudonym> :-)
17:12:13 <Pseudonym> The thing is, it's going to be difficult to port to a new language if you need a full lexer and parser.
17:12:25 <Pseudonym> But of course, I suppose you will have the ability just to use simple regexes.
17:12:37 <dons> yes. exactly
17:12:55 <dons> but it will be possible to use a real lexer, for example
17:13:07 <dons> because the syntax highlighting code must be written in haskell
17:13:13 <dons> (and not, say, vim script)
17:13:15 <musasabi> Pseudonym: yes, but that does not (at least according to the toc) contain usefull things.
17:13:54 <dons> I think this is why it has been so difficult to get good hightlighting and indent modes in traditional editors
17:14:19 <dons> they're trying to write compiler frontends (at least the lexer, and the parser for the indent mode) using regex, basically
17:14:22 <Pseudonym> musasabi: Read the section on stream processors.
17:14:37 <dons> no wonder then that emacs indent mode still doesn't work
17:14:40 <dons> (for haskell)
17:14:44 <Pseudonym> BTW, if you want your dataflow graph to be _dynamic_, the consensus seems to be that arrows can't do it.
17:14:47 <Pseudonym> Which is a shame.
17:14:58 <dons> so, by the power of Haskell parsing combinators!
17:14:58 <Pseudonym> I've been looking for an elegant way to do dynamic dataflow graphs for a while.
17:17:07 <musasabi> Pseudonym: I know how to do dataflow, but what I want is to create a graph detailing how data flows through an arrow.
17:19:53 * dons dives into the yi
17:20:05 * Pseudonym nods
17:20:15 <Pseudonym> Basically, haskell ports is the best solution so far.
17:20:18 <Pseudonym> Or Concurrent.Chan.
17:23:15 <musasabi> The problem is that deleting extra dependencies is hard, With arr "arr snd" there is no way to know that the result does not depend on the first value in the tupple. (As code like that is generated when simplyfying the do-notation for arrows)
17:23:31 <Pseudonym> Right.
17:23:40 <Pseudonym> This, BTW, is a problem that I had to deal with, too.
17:23:44 * Pseudonym ended up coding it in C++
17:24:07 <Pseudonym> Each dependency node had to supply a bit matrix which specified dependencies.
17:24:20 <Pseudonym> It ain't pretty.
17:25:41 <musasabi> I am thinking of doing away with arr..
17:26:46 <musasabi> and have a more restricted lifting operator.
17:27:11 <musasabi> Then I could add dependency info to the lifting phase, which could make things work.
17:28:07 <musasabi> Does this sound sensible and what would the resulting structure be called?
17:34:47 <Igloo> dons: Hmm, using ghc's code directly sound scary
17:35:20 <Igloo> I think writing something that takes modified BNFish from the report would be easiest
17:39:37 <shapr> oh I have thoughts on 'easy' writing of parsers for new langs with yi
17:40:29 <Igloo> What's the purpose of the parsers? Refactoring?
17:40:44 <shapr> among other things, yes
17:40:58 <shapr> parsers give 'real' syntax highlighting
17:41:07 <shapr> 'intellisense' tab completion of function/module/etc names.
17:41:15 <shapr> parse tree macros =)
17:41:48 <Igloo> Hmm, you have to make it both incremental and with good error recovery to be practical, though
17:41:57 <shapr> yah, true.
17:42:00 <dons> Igloo: I just a real Haskell indent mode
17:42:01 <Igloo> Which both tend to conflict with easy  :-)
17:42:13 <Igloo> dons: "want a"?
17:42:14 <dons> I just want a..
17:42:32 <Igloo> Hmm
17:42:42 <dons> just syntax highlighting should be fairly easy with a stripped down lexer
17:43:10 <dons> and the lexer and parser are isolated in that they come as .x and .y -- so easier to hack to bits
17:43:24 <Igloo> Yeah, but they have Haskell code in...
17:43:34 <dons> we just change all the rules to construct syntaxified buffers, rather than abs syntax
17:43:36 <Igloo> And have evil tricks
17:43:40 <dons> yeah yeah :)
17:44:08 <shapr> dons: is :w close to recording?
17:44:11 * Igloo goes to look at them
17:44:29 <shapr> I think I'll look at scrolling the buffer along with the cursor
17:44:31 <dons> shapr: :w works. i'm killing buffer bugs atm. found 2
17:44:39 <shapr> yay, workingness!
17:44:39 <dons> shapr: that would be great.
17:45:13 <shapr> I'm actually quite interested in the UI part...
17:45:29 <shapr> you were talking about strange editor dreams, I was dreaming about an OpenGL UI
17:45:34 <dons> so, given the current point, and the contents of the buffer, render the section of the buffer around the point, such that it looks like it scrolls
17:45:46 <dons> that would be really nice :)
17:46:02 <Igloo> I'd also like it to be able to call the tex syntax highlighter on a "^\\end{code}[ \t]*$" lexeme with a parameter telling it to add a similar lexeme to the tex syntax highlighter to go the other way
17:46:08 <dons> shapr: if you really want to dive into the UI, maybe you could come up with a UI class
17:46:20 <shapr> I'll start with scrolling
17:46:32 <Igloo> . o O (higher-order syntax highlighters?)
17:46:52 <dons> hmm... some way to combine syntax highlighters is needed, isn't it?
17:47:07 <shapr> yes, definitely
17:47:28 <shapr> oh, I "idly" mentioned Yi to Duncan Coutts, one of the developers for hIDE/haIDE
17:47:32 <Igloo> I'm fairly sure the "switch syntax highlighting" command will always start at the beginning of a lexeme, so it hopefully won't be too bad
17:47:48 <dons> what did Duncan say?
17:48:16 <shapr> he said "Perhaps we could collaborate. Who's doing this project?"
17:48:25 <dons> did he say: "Yes! I'll write Foo?"
17:48:31 <Igloo> To get the layout stuff from GHC's lexer/parser would mean special code for Haskell I think
17:48:35 * shapr viciously subverts all Haskell editor authors into hacking on Yi
17:48:40 <dons> hhehehe
17:48:51 <shapr> Igloo: that special code could be later smashed into generic code.
17:49:05 <Igloo> Do you really need to do it properly to get a decent indentation mode?
17:49:09 <shapr> the first task is still to get Yi working on itself well.
17:49:39 <dons> yep. I'll get back on it.
17:49:45 * dons fires up ghci -package yi
17:49:51 * shapr gets on scrolling
17:50:46 * Igloo wishes I could get paid to hack on this
17:51:03 * shapr wishes that too
17:51:11 * dons is getting paid!
17:51:32 * Igloo assumes hs-plugins is part of your research?
17:51:44 <dons> yep. it is. 
17:51:58 <dons> just has to convince Manuel that yi is also part of the runtime Haskell work too
17:52:02 <dons> then I'm set :)
17:52:10 <Igloo> :-)
18:09:53 <musasabi> How can I say 'data Foo k "such that k is in Show" = Foo k'
18:10:18 <Igloo> data Foo k = Foo k deriving Show
18:10:24 <Igloo> Oh, sorry
18:10:56 <musasabi> basically I want to limit the possible object types.
18:11:00 <Igloo> Put "Show k =>" after data I think, but I have a feeling it doesn't work as you'd expect
18:11:12 * Igloo can't remember the details
18:11:59 <shapr> can't you do that with GADTs as well?
18:12:59 <Igloo> That seems like an unnecessarily big hammer
18:13:35 <shapr> well, it would make it very flat =)
18:13:39 <Igloo> Oh, I think the issues with it are that class instances and type declarations don't know about the constraint, so you have to repeat it there as necessary
18:13:47 <Igloo> :-)
18:14:38 <shapr> musasabi: you might run across the same problem that John Hughes had with the CGIArrow... that there's no way to add a Read/Show constraint to the arrow typeclass
18:15:28 <musasabi> shapr: true..
18:15:40 <shapr> dons: What's a pad? "TODO define this in terms of the ncurses WINDOW abstraction, or even pads."
18:15:48 * musasabi looks whether GADTs support stuff which could be helpfull.
18:17:32 <dons> man ncurses:
18:17:33 <dons>        Special  windows  called  pads  may  also  be manipulated.
18:17:33 <dons>        These are windows which are not constrained to the size of
18:17:33 <dons>        the  screen and whose contents need not be completely dis-
18:17:33 <dons>        played.  See curs_pad(3) for more information.
18:18:08 <shapr> aha
18:18:23 <dons> the current plan of managing our own buffers inside a single stdscr isn't too fun
18:18:44 <dons> so having each buffer get a window or pad seems better, for the ncurses ui
18:18:51 <shapr> makes sense.
18:19:15 <dons> it means more ncurses binding code to be written, though (pretty easy :)
18:19:20 <shapr> ginsu has some code for managing your own buffers inside a single screen, but I'm not sure if I want to use it...
18:19:32 <heatsink> my experience is that curses pads and windows are not very reliable
18:19:50 <dons> ok. if we could do it purely in haskell, maybe that would be better
18:19:59 <dons> we could probably write something fairly reliable
18:20:03 <heatsink> In particular, I couldn't resize the screen and then get windows to resize correctly
18:20:04 <Igloo> If I understand correctly I don't see how pads help as you often don't want to update parts of a buffer you can't see eagerly
18:20:07 <dons> (just has to emulate ion :)
18:20:11 <heatsink> *resize the terminal
18:21:45 <dons> shapr: you could rewrite the window managing code in Haskell, with ref to ginsu, perhaps?
18:23:32 <shapr> dons: yes, good idea
18:24:47 * heatsink wrote a curses windowing system in python a while ago...
18:25:44 <heatsink> I never did get a feel for how to code something so heavily side-effect oriented as a window system non-imperatively
18:25:52 <musasabi> GADTs don't seem to implement classes at least currently :-(
18:28:56 <shapr> musasabi: will they?
18:29:02 * shapr hasn't read much about GADTs yet.
18:33:29 <musasabi> I don't think so, at least by the stuff I have seen.
18:35:30 * musasabi goes to sleep and think
18:35:31 <musasabi> ->
18:35:47 <CosmicRay> what happens to a Handle that gets garbage collected?
18:35:51 <CosmicRay> does it automatically get closed?
18:37:47 <Igloo> Yes
18:40:26 <CosmicRay> excellent.
18:40:53 <Igloo> It's not so good if you haven't actually read the data because of laziness
18:47:17 <dons> insert and delete work much better now I've killed off 3 off-by-one errors ;)
18:47:43 <shapr> recorded?
18:47:59 <Igloo> You've been wasting your time, you need only have fixed one  :-)
18:48:11 * shapr grins
18:48:13 * Igloo sleeps
18:48:56 <dons> shapr: soon, soon.
18:53:01 <dons> I wish you could :reload library packages in ghci
19:02:11 <shapr> I wish I could do without sleep.
19:02:50 <blackdog> shapr: read 0wnz0red?
19:05:00 <dons> blackdog: switched to yi yet? ;)
19:06:07 <blackdog> i thought it was called hemacs...
19:06:44 <dons> already taken, apparently. so we came up with a good recursive name: Y I
19:06:54 <dons> kind of like vi, too
19:07:18 <shapr> blackdog: nah, what's 0wnz0red?
19:07:23 * heatsink wonders if y is a combinator
19:07:41 <dons> yes. the Y combinator :)
19:09:34 <blackdog> shapr: short story by cory doctorow. all about hacking your body. geek-porn, basically. :)
19:10:41 <blackdog> dons: cool. How far along is it? Can it do windows on different X displays yet? :)
19:10:55 <blackdog> gotta stop smileying, i'm really not _that_ gleeful
19:12:22 <dons> bah!
19:12:32 <dons> getting towards vi status, with split buffers
19:12:50 <dons> hey. yi is 5 days old today :)
19:12:56 <dons> or is it 6?
19:13:14 <dons> blackdog: what do you think about writing keybindings in Alex?
19:13:58 <dons> so you can have all sorts of weird grammars for char-at-a-time user input
19:14:23 <dons> hopefully this means we can abstract over the oddities of emacs and vi commands in the editor primops
19:14:59 <blackdog> dons: it's a pretty cool idea.
19:15:20 <JerubBaal> dons: once you can emulate vim, you've me as a lifelong user.
19:16:06 <blackdog> how would it cope with things like tab-expansion of long emacs-style commands?
19:19:16 <shapr> put the commands in a tree, tab checks to see which trees are still reachable?
19:19:20 <shapr> er Trie
19:19:23 <dons> the emacs lexer would be in 'tab expand command' mode, and would, say, lookup a data structure for the appropriate completion
19:19:40 <dons> printing it out, and then wait for more tabs or ^M
19:19:49 <dons> just monadic lexer actions
19:20:34 <dons> seems pretty easy. editor interface syntax/grammar is much simpler than those we normally handle with happy and alex, so reproducing them isn't too hard
19:20:46 <dons> that, I hope, is the story at least
19:21:32 <dons> JerubBaal: then I'll have me as a life long user too :)
19:22:19 <blackdog> well, surely the point is to make it _more_ usable than vim.
19:22:26 <shapr> and more usable than emacs
19:22:46 <dons> yep.
19:22:52 <JerubBaal> blackdog: ... improving vim isn't possible without starting with vim.
19:23:07 <JerubBaal> but vim is hard to start from, becuase its monolithic, so I need a good vim emulation
19:23:11 <JerubBaal> *then* I can improve on it.
19:23:56 <dons> one thought about easy key binding writing is that we'll have the ion syndrome where nobody can use anyone else's ion instance -- cause all the keys are rebound ;)
19:24:17 <dons> (well, noone can use my ion instance, anyway, because all the keys are rebound)
19:25:17 <JerubBaal> dons: no one can use mine either.
19:25:18 <JerubBaal> hold on.
19:25:24 <JerubBaal> Hands Up Ion Users?
19:25:26 * JerubBaal raises hand.
19:25:46 <dons> lots of people use ion here
19:25:56 <dons> it's purely functional!
19:28:14 * blackdog raises hand
19:28:27 <blackdog> i've started using a mac laptop, and the first thing i installed was ion... :)
19:28:29 * shapr raises hand
19:29:09 <blackdog> but that's exactly right, anyway: no-one else should be using your account anyway. It's like borrowing underpants.
19:29:17 <shapr> yah really
19:29:24 <shapr> but it makes pair programming hard
19:29:43 <shapr> I've thought about a 'settings ring' that you wear...
19:29:46 * ayrnieu waves the 'treewm' flag -- but he doesn't use it on his mac.
19:29:58 <shapr> and when your hand is on the keyboard, your settings are in effect.
19:31:12 <ayrnieu> shapr - you could use 'setting glasses' so that you only ever see the display in the manner you prefer.
19:31:49 <shapr> pair programming is about input though
19:36:32 * shapr goes to sleep
19:36:36 <JerubBaal> shapr: I'd bind a key to that. ;)
19:56:40 <CosmicRay> hmm
19:56:45 <CosmicRay> flipAL :: Eq key, Eq val => [(key, val)] -> [(val, [key])]
19:57:15 <heatsink> yes?
20:19:19 <CosmicRay> sorry
20:19:21 <CosmicRay> got a phone call
20:19:35 <CosmicRay> haskell doesn't like my comma and I can't figure out how to do it
20:20:47 <heatsink> Try (Eq key, Eq val) => [(key, val)] -> [(val, [key])]
20:23:19 <CosmicRay> ah.
20:23:44 <CosmicRay> hmm.
20:24:10 <CosmicRay>     Inferred type is less polymorphic than expected
20:24:10 <CosmicRay>         Quantified type variable `val' is unified with another quantified type variable `key'
20:24:46 <CosmicRay> I hate that error message.  I can never figure out what it means.
20:26:24 <heatsink> I don't know what it means either
20:26:34 <heatsink> Are you doing anything that would require val and key to have the same type?
20:26:43 <CosmicRay> nope
20:59:55 <dash> hello! talking to heatsink reminded me that i was working on a haskell project a while back. anybody know of a lisp implemented in haskell? =)
21:00:45 <dash> or a scheme, really
