00:13:47 <kristnjov> could someone help me with a generator of lists of integers?
00:19:35 <musasabi> kristnjov: can you describe what kind of list you want to generate?
00:19:46 <kristnjov> a list of random length and random integers
00:21:17 <Jan_w> kristnjov: the definition is randomList :: [Integer] 
00:21:46 <kristnjov> but that isn't a generator
00:22:07 <musasabi> do { len <- randomIO; replicateM len (randomIO :: IO Int) }
00:22:23 <musasabi> that is IO [Int]
00:22:41 <kristnjov> i was thinking somehting like "do a <- arbitrary"
00:22:51 <musasabi> hmm that is not what you want.
00:23:34 <kristnjov> why not?
00:23:43 <kristnjov> isn't there already some definition of arbitrary lists?
00:24:13 <Cale> what ought the distribution of list lengths be?
00:24:34 <kristnjov> distribution?
00:24:44 <Cale> well, you want it to be random
00:24:52 <kristnjov> yes
00:24:56 <Cale> so it must be distributed in some fashion
00:25:02 <musasabi> do { len <- randomRIO (1,10); replicateM len (randomIO :: IO Int) }
00:25:09 <musasabi> that is more like it.
00:25:19 <musasabi> as you don't want a negative list length etc
00:26:27 <kristnjov> undefined variable randomRIO
00:26:35 <kristnjov> randomR i suppose
00:26:43 <kristnjov> hm no not that either
00:27:10 <kristnjov> import Random :P
00:27:20 <kristnjov> undefined variable replicateM
00:30:36 <kristnjov> well`?
00:30:46 <kristnjov> musasabi, i get undefined variable replicateM
00:30:47 <musasabi> kristnjov: import Random and Control.Monad
00:31:04 <musasabi> @index replicateM
00:31:05 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
00:31:05 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
00:31:05 <lambdabot> State,Control.Monad.Writer
00:31:33 <kristnjov> but this still isn't a generator
00:31:37 <kristnjov> this is an IO [Int]
00:31:47 <kristnjov> i have to use a "Gen a" for what i'm doing
00:32:48 <kristnjov> you're telling me there's nowhere i can read about generating lists with arbitrary?
00:33:30 <dons> tuomov: ok, I've replicated the error
00:47:36 <tuomov> .
00:53:14 <dons> tuomov: still can't load?
00:53:45 <tuomov> no
00:53:56 <tuomov> just send another mail
00:54:10 <tuomov> there's no 'riot' in the dependencies
00:54:23 <dons> ok. those module dependencies are wrong. it's use the .o files in the current dir, instead of -package riot
00:54:57 <dons> the -i flag (with no arg) is supposed to prevent this
01:37:28 <dons> tuomov: ah ha! -i is a 6.2.2-ism. I get the wrong depends with -i when I use 6.2.1
01:41:03 <tuomov> I have 6.2.1
01:41:19 <dons> yes. of course.
02:16:01 <TheHunter> good morning, folks
02:39:20 <tuomov> dons: seems to work now. thanks.
02:40:28 <dons> :) now .. i hope you use it!
02:41:00 <dons> this is how we could do haskell-emacs, too, I think.
02:41:05 <tuomov> I will
02:41:41 <yohan> i cant use guards when doing this? (\x y -> | isDigit (head x) = x:y | otherwise = x ++ y)
02:42:19 <yohan> how would i do it? i get a syntax error
02:46:58 <dons> \x y -> if isDigit (head x) then x:y else x ++ y)
04:10:23 <musasabi> how is the memory model with threads - should I recycle threads when they are no longer needed or reuse them and let GC keep them clean?
04:12:06 <musasabi> "let x = foo >> x in forkIO x" or "let x = foo >> forkIO x in forkIO x"
04:18:10 <tromp> @index forkIO
04:18:11 <lambdabot> Control.Concurrent
04:19:56 <tromp> the former
04:20:20 <tromp> the latter shld give typing error
04:22:05 <tromp> @index replicateM
04:22:06 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
04:22:06 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
04:22:06 <lambdabot> State,Control.Monad.Writer
04:23:43 <musasabi> well the latter is "let x = return () >> forkIO x >> return () in forkIO x" properly expressed.
04:24:00 <musasabi> sorry "let x = foo >> forkIO x >> return () in forkIO x"
04:24:36 <musasabi> The point withstanding - is it better to spawn new threads or do GC?
04:25:14 <tromp>  return () >>  does nothing
04:25:47 <Lemmih> I don't see why it should be better to spawn a new thread.
04:25:51 <tromp> so the latter creates more and more threads
04:28:14 <Lemmih> Is haskell.org served by apache or hsw-wp?
04:28:29 <musasabi> Lemmih: because all the memory of the old one could be freed, and the new one would start with a clean heap.
04:28:42 <musasabi> that is if there are thread local heaps 
04:29:39 <Lemmih> musasabi: Why wouldn't unused memory be collected if you use the same thread?
04:30:19 <musasabi> Server: Apache/2.0.46 (Red Hat)
04:31:25 <musasabi> Lemmih: it would be collected, but that is not free.
04:32:15 <Lemmih> I don't follow.
04:33:17 <musasabi> Lemmih: given an implementation with process local heaps, it can be cheaper to create a new process than to garbage collect the old one.
04:35:17 <Lemmih> So you wanna delay the garbage collection of the old threads?
04:43:07 <musasabi> Lemmih: if they have separate heaps and they are discarded they don't need to be garbage collected.
04:49:09 <Lemmih> musasabi: I don't think it works that way with non-OS threads.
05:08:16 <Jan_w> I see monad mentioned here quite often, has is it ?
05:08:36 <Jan_w> has=wa\hat
05:08:41 <Jan_w> pff
05:08:43 <Jan_w> sorry
05:08:48 <Jan_w> I see monad mentioned here quite often, what is it ?
05:10:02 <musasabi> Monads are a way of combining computations.
05:10:05 <arjanb> http://www.nomaware.com/monads/html/
05:10:57 <musasabi> http://www.nomaware.com/monads/html/
05:11:00 <musasabi> ^_^
05:12:06 <Jan_w> hm, makes good reading, getting some tea to go with it
05:52:11 <musasabi> Is the order in which monadic actions are done specified with liftM2 ?
05:52:42 <Cale> liftM2 f         =  \a b -> do { a' <- a; b' <- b; return (f a' b') }
05:55:01 <musasabi> so the order is promised?
05:55:08 <Cale> yep
05:55:33 <Cale> though using liftM2 isn't the clearest way to do things if the order there matters
06:30:16 <musasabi> Is there a way to create an array given a Ptr and a length ?
06:34:29 <musasabi> that is other than the "newArray (0,len) (peekArray len)"
06:37:24 <Cale> create in what sense? That has a type error. There's copyArray. You could also use mallocArray or reallocArray directly
06:46:01 <velco> what are the most significant differences between haskell and sml ?
06:48:17 <Cale> In no particular order, I'd say lazy evaluation, the use of monadic IO, and typeclasses
06:49:15 <TheHunter> velco: if you consider ghc's extension, you might also find haskell's type system much more powerful.
06:51:51 <Oejet> velco: SML has a very pretty module language and I guess Haskell's is less so.
06:57:53 <arauko> All the x86 and pentium processors can only addres 4GB?
06:59:33 <velco> yes
06:59:56 <velco> from pentiumprot and up can address 64G
07:01:14 <velco> Cale: what;s the significance of the lazy evaluation ? Is haskell required to to do, whereas SML /may/ do so ?
07:01:39 <Cale> Lazy evaluation is default in Haskell
07:01:47 <Cale> you can make things strict if necessary
07:01:59 <Cale> the reverse is true of SML
07:02:14 <Cale> So different things become natural.
07:02:38 <velco> what do you mean by strict ?
07:03:26 <Cale> A function is strict if it forces the evaluation of its arguments.
07:04:38 <velco> ic
07:05:38 <Cale> In haskell, things like infinite lists, infinite data structures in general, are the norm.
07:06:15 <Cale> gotta run
07:06:37 <velco> ok, thanks
07:12:25 <tromp> hoi twentse ligger:)
07:13:17 <Jan_w> wie ik ?
07:13:56 <Jan_w> of komt xkb uit twente ? :)
07:15:00 <tromp> ik gok dat xkb ligfietst:)
07:15:38 <Jan_w> ah
07:16:11 <Oejet> @translateDutch
07:16:12 <lambdabot> Sorry, I don't know the command "translateDutch", try "lambdabot: @listcommands
07:20:34 <Jan_w> what's wrong with: map putStr [(x ++ "\n") | x <- (map show [[1,2,3],[4,5,6]])]        
07:21:02 <Jan_w> the result i expected was "[1,2,3]\n[4,5,6]\n" printed out
07:22:23 <Jan_w> but it's result is a [IO ()]
07:22:30 <TheHunter> Jan_w: map -> mapM_
07:22:59 <Jan_w> TheHunter: it works, but why ?
07:23:13 <Jan_w> wait, i'll first lookup mapM_ :
07:23:14 <Jan_w> :)
07:23:55 <TheHunter> mapM maps a list via a monadic function to a list of actions and then executes the actions in the order of the list.
07:24:20 <TheHunter> mapM_ does the same but throws away the resulting IO [a]
07:25:24 <Jan_w> hm, pretty cool stuff :_)
07:26:02 <TheHunter> Jan_w: you'll like mapM, sequence, foldM and friends!
07:27:18 <Jan_w> I take it  a \\ b is pretty slow if a is big ? is there any intellegence in this fucntion ?
07:27:46 <TheHunter> Jan_w: a \\ b must be slow because it only knows an equality function on the elements of a and b.
07:28:11 <Jan_w> is there and Ord alternative ?
07:28:22 <Jan_w> -d
07:28:39 <TheHunter> in Data.Set there is minusSet :: Ord a => Set a -> Set a -> Set a
07:29:16 <Jan_w> is that anything like a hashset ?
07:29:26 <TheHunter> so a \\\ b = setToList $ mkSet a `minusSet` mkSet b will be faster.
07:30:04 <TheHunter> not really hashes, but balanced trees, so O(n * log n) operations.
07:30:30 <Jan_w> oh, that's exactly what i need
07:33:11 <Jan_w> what does a \\\ b do ?
07:33:31 <Jan_w> \\ but for sets ?
07:34:27 <TheHunter> no, i just gave a definition for a function (\\\) which does basically the same as (\\)
07:34:42 <TheHunter> (\\) for sets is minusSet
07:35:40 <Jan_w> oh i see, i read it wrong, i thought there were two operations, and $ was "use last result"
07:36:16 <Jan_w> I didn't know you could define infix operators like that
07:36:44 <TheHunter> infixing functions is pretty handy, it allowed me to lose all () in this example
07:36:57 <Jan_w> yea, very nice
07:38:01 <TheHunter> usually functions which take two arguments of one type and return something of this type are natural candidates to be infixed.
07:48:46 <Jan_w> Hm, i'm doing something very wrong, because the set-methode is now actually much slower, i'm missing something
07:49:30 <Jan_w> i see
07:49:36 <Jan_w> hm, would this matter:
07:49:53 <Jan_w> i need a \\\ b where b is huge
07:50:39 <Jan_w> a \\\ b would indeed give me all elements of a without the elements that are also in b ?
07:50:42 <TheHunter> if a is small (~ log (length b), i guess), then yes.
07:50:59 <Jan_w> a is very small 
07:51:08 <Jan_w> 8 elements max
07:51:35 <Jan_w> but b can contain many elements
07:51:49 <TheHunter> ok, then you're probably better of with (\\), since it costs at most 8 * length b
07:52:41 <Jan_w> it appears so, but me mind won't believe it yet :)
07:52:55 <Jan_w> i'll just let it set in some more
07:54:14 <TheHunter> the cost of \\ is O(length a * length b) and the cost of \\\ O(a * log a + b * log b)
07:55:37 <Jan_w> doesn't that mean that if a is very small, and b large, \\\ most still be better?
07:55:46 <Jan_w> most=would
07:56:17 <Jan_w> no i wouldn't ofcourse
07:56:29 <Jan_w> because of the b * log b
07:56:31 <Jan_w> i see
07:57:54 <Jan_w> Running test nr 1: (33051 reductions, 48325 cells) 
07:58:05 <TheHunter> what about a \\\\ b = filter (\x -> not $ x `elementOf` b') a where b' = mkSet b
07:58:24 <Jan_w> same test, second time (38 reductions, 44 cells)     
07:58:40 <Jan_w> what is cached here ?:)
07:59:20 <TheHunter> a is still a list but b gets converted to a set for (faster, but prolly not for 8) lookup
08:00:25 <TheHunter> Jan_w: but, the imported point is: if it's fast enough, you don't need further optimizations.
08:02:02 <TheHunter> hmm, this was of course stupid (a \\\\ b is good for small b)...
08:02:52 <bourbaki> hi
08:02:55 <bourbaki> esap: you there?
08:03:01 <Jan_w> TheHunter: still, even then it appears to be faster then 2 sets
08:03:05 <Jan_w> i get it
08:03:19 <Jan_w> wrong assumption i made!
08:03:26 <bourbaki> moin TheHunter :)
08:03:40 <TheHunter> moin bourbaki 
08:04:04 * bourbaki is happy :)
08:04:19 <Jan_w> a is max 8 elements, but b is max 128 elements or so, I assumed MANY elements, but although it contains somewhat more then a, it might not be worth the overhead of the set
08:05:16 <Jan_w> In fact, although the \\ is used recursively b grows liniarly, often not bigger the 64
08:05:18 <Jan_w> +n
08:06:09 <Jan_w> I'm beginnen to understand why my attemps to optimize this failed, I made wrong assumptions about the actual size b
08:07:00 <TheHunter> is this to be executed in a tight loop? if not, just use \\, in might even be one of the fastest possible implementations.
08:15:11 <TheHunter> bourbaki: what are you happy about?
08:15:26 <bourbaki> TheHunter: about the stuff that esap pointed out yesterday
08:15:34 <TheHunter> making progress?
08:15:39 <bourbaki> TheHunter: i made all my program stuff topos
08:15:50 <bourbaki> wich means that i always have the limit of anything in that thing
08:16:08 <bourbaki> wich means that i always have a single computation for a subgraph
08:16:33 <bourbaki> the problem is now just to proof that its a topos and that its cartesian closed
08:16:46 <bourbaki> though the latter might not be that hard with arrows
08:17:20 <TheHunter> bourbaki: well, arrows aren't cartesian closed in general, iirc
08:18:02 <TheHunter> but almost, i guess :)
08:18:11 <bourbaki> TheHunter: why is that?
08:18:17 <bourbaki> TheHunter: doens that depend on >>> ?
08:18:52 <bourbaki> erm rather something like ***
08:20:08 <TheHunter> f *** g >>> arr fst === f can be false, i think.
08:20:55 <TheHunter> err &&&
08:20:57 <bourbaki> arr does what?
08:21:31 <TheHunter> arr lifts a pure computation to an arrowized computation, Ross Paterson calls it pure
08:22:06 <bourbaki> ah ok :)
08:22:11 <TheHunter> and arr fst is prolly the only sensible definition of a projection in the context of arrows
08:22:25 <bourbaki> yes 
08:23:05 <bourbaki> hm when should that able to be false?
08:23:23 <TheHunter> for example for kleisli-arrows of noncommutative monads
08:23:42 <TheHunter> like State arrows
08:23:52 <bourbaki> hm
08:24:21 <bourbaki> inst CC equivalent to lambda calculus?
08:24:30 <TheHunter> but that's no problem, you can just prove that your category indeed has products.
08:24:30 <bourbaki> or second order ...
08:24:37 <TheHunter> CC?
08:24:42 <bourbaki> cartesian closed
08:26:13 <TheHunter> cc has exponetials, so i guess it's higher order
08:27:51 <TheHunter> but i'm not sure of `equivalent`
08:27:53 <bourbaki> i thought i could make use of that to say that you can do the same with graphs as you can do with lambda functions
08:28:18 <TheHunter> if you cat is cc then this is no problem
08:28:51 <bourbaki> hm well i think i need to emphasis this then ...
08:29:05 <bourbaki> and i also yet need to proof that topos thingy with the limits
08:30:29 <bourbaki> but that would be a big gain if i can do that
08:31:31 <TheHunter> well, you'll have to find limits for all finite index cats anyway.
08:32:22 <bourbaki> isnt that like impossible?
08:32:58 <TheHunter> you mean constructively?
08:33:06 <bourbaki> i think i should state that and try that for a class of elements i need for my examples first and let others to that stuff if they want to use it
08:33:28 <bourbaki> the idea is that you can use that as a framework for stuff so i dont know what kind of arrows the ppl will use
09:43:10 <shapr> greetings!
09:43:12 <shapr> wazzup?
09:43:20 <shapr> musasabi: y0, did you get my email?
09:43:23 <bbls1> hi shapr
09:43:43 <shapr> hiya bbls1
09:44:25 <shapr> how's code treating everyone today?
09:44:35 <shapr> Anyone here written an interpreter using arrows?
09:44:37 <bourbaki> hidiho
09:44:46 <shapr> I'm trying to hack arrowex4.hs into a full Joy interpreter.
09:45:03 <shapr> bourbaki: y0, how're the pointy combinators treating you?
09:45:52 <bourbaki> i still need to invest some more work in that but esap pointed out something really usefull yesterday :)
09:46:26 <bourbaki> i think im going to my prof and ask him if he wont let other ppl join my project
09:46:33 <bourbaki> in order to get an editor :)
09:46:35 <shapr> I suspect that swapping lambdabot to arrows might fix those evil stack overflows.
09:46:43 <shapr> to get an editor?
09:46:48 <shapr> oh, a graph editor?
09:47:31 <bourbaki> yes
09:47:41 <bourbaki> its quite essential
09:47:47 <shapr> have you tried to hack up a wxHaskell prototype?
09:47:54 <bourbaki> i have a lot of ideas for an editor
09:48:00 <shapr> do you have a napkin prototype for your editor?
09:48:03 <bourbaki> im really shitty at app codeing
09:48:18 <bourbaki> i have a small design not written it down yet though
09:48:26 <bourbaki> i might do that though once i asked my prof
09:48:42 <bourbaki> id like a haskell implementation though ... ;)
09:50:18 <shapr> binary42: Are you the Drexel Brian Mitchell?
09:51:41 <binary42> shapr, no.
09:52:11 <shapr> anyway, greetings and welcome to #haskell!
09:52:21 <shapr> I think I've seen you here before, long time ago...
09:52:39 <shapr> Are you learning Haskell?
09:52:53 <binary42> yeah.. I like to listen in.. yes.
09:53:36 <shapr> Have you already found all the good link to learning webpages?
09:53:57 <shapr> bourbaki: write down your prototype ideas, draw up a mockup image. That should help.
09:54:15 <binary42> shapr, sure thing... time is my only block ;)
09:54:24 <bourbaki> shapr: yep i should do that i just didnt do so yet cause noone was interested anyway
09:54:55 <shapr> binary42: ok, if you have any questions or need some intros, ask me.
09:55:18 * binary42 thanks shapr for his offer.
09:55:30 <shapr> bourbaki: I've found it hard to communicate my ideas without visual and textual backup to further explain what I"m attempting.
09:56:43 <bourbaki> shapr: thats true :)
09:56:47 <Philippa_> yeah, it helps having something that's a permanent overview you can go back to
09:56:55 <Philippa_> lets you build up clear pictures of a system a bit at a time
09:57:17 <shapr> greetz Philippa 
09:58:06 <shapr> hey Philippa, you know anything about EnvMonad equivalents in Ross Paterson's ArrT libs?
09:58:08 <bourbaki> the idea is that when you build the graph and you click on an edge you get a text editor that lets you write the haskell implementation of that arrow (or lets you choose from a set of existing arrows that have matching domains and codomains) the good thing is that you have the type sig of that arrow then already
09:58:13 <bourbaki> moin Philippa 
09:58:45 <shapr> in that case, why not make a graph arrow that can be transparently applied to existing arrows as a 'viewer' ?
09:59:12 <shapr> Then you can show how cool it would look, and you can explain it would be even more cool if you could just click on the view.
09:59:54 <bourbaki> i bet the whole editor i need is like 1h working for an experienced app coder with a graph lib
09:59:57 <Philippa> shapr: I've not been looking stuff over much recently
10:00:13 <shapr> I'm loath to admit, but I've never written a full interpreter in Haskell...
10:00:18 <Philippa> EnvMonad = Environment ~= FiniteMap-inna-StateT?
10:00:25 <shapr> Yah, I guess so.
10:00:40 <Philippa> = trivial to implement with just a state ArrT? :-)
10:00:49 <shapr> Sounds reasonable...
10:00:57 <shapr> I was wondering that myself, but..
10:01:11 <shapr> have never written a 'real' intepreter, so I'm not really sure.
10:01:52 <shapr> Philippa: This is what I've been perusing : http://www.haskell.org/arrows/arrows/index.html
10:02:30 <shapr> What's a CoState transformer?
10:03:34 <shapr> hoi xkb 
10:03:47 <shapr> xkb: I was going to ask you something... I wonder what.
10:04:03 <TheHunter> shapr: it's a context/costate Comonad
10:04:42 <shapr> Does that mean just an implicit environment?
10:05:18 <TheHunter> dunno exactly what it means, something like allows you to apply the past computation in another context.
10:05:36 <Philippa> shapr: my type inference code just has a state-on-crack monad. Well, I eventually refactored it to an ST+transformers job, but only because I was running 3 different kinds of environment by then
10:05:38 <shapr> That sounds like continuations.
10:06:07 <shapr> What's the difference between ST and State?
10:06:30 <Philippa> ST has STRefs
10:06:50 <Philippa> which can be polymorphic, otherwise it'd be ~= State (FiniteMap Ref foo)
10:07:01 <shapr> How is an STRef different from an IORef?
10:07:42 <shapr> You have type inference code for FlippaCat?
10:08:26 * shapr has no answers today, only questions.
10:09:04 <TheHunter> shapr: runST :: (forall s. ST s a) -> a
10:10:44 <TheHunter> shapr: CoState allows you to do stuff that is impossible in Cont (where you always have to put a `reference' somewhere to be able to jump back to it)
10:11:14 <shapr> I'll add that to my ToRead list.
10:11:49 <TheHunter> but i don't know how useful this is, i haven't seen a useful application yet.
10:12:45 <shapr> Could be like arrows, no one has understood them enough to really use them yet.
10:13:15 <mattam> there's a parser library base on arrows isn't it ?
10:13:35 <shapr> Speaking of which, I haven't yet made the jump to turning this arrow interpreter example into postfix.
10:13:41 <shapr> mattam: Is there?
10:14:31 <mattam> i thought so, iirc i read an article about arrows and the example was "arrowic" parsers
10:14:40 * shapr asks google.
10:15:27 <shapr> Google doesn't have anything on arrowic, and arrowdic only turns up #haskell logs.
10:15:50 <mattam> i just made up that word :)
10:17:15 <shapr> I made up arrowdic. That's what turns up in google.
10:19:16 <shapr> Interesting: http://caml.inria.fr/archives/200008/msg00118.html
10:20:21 <mattam> it's in John Hughes article 'from Monads to Arrows' where he develops an some arrowic (i prefer mine:) parsers
10:20:36 <Philippa> shapr: an STRef only really differs from an IORef insofar as it's for a different monad (and is parameterised on which instance it sits in)
10:20:43 <Philippa> (or rather, its type is)
10:20:51 <Philippa> nothing new on FlippaCat yet
10:21:03 <Philippa> Flippi's had all my coding time for a while, and the last week's really sucked
10:21:25 * TheHunter suggests reading the polish parsers paper on http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/index.html, besides the cool parser the polish thing might be an interesting functional design pattern, too.
10:24:36 <musasabi> how inaccurate is the -prof profiling of GHC ? It seems to claim an innocent looking function would be taking very much time, or may it bad luck with ticks?
10:27:37 <musasabi> seems it was too inaccurate.. 
10:28:33 <shapr> Is there a where clause that could be lifted to the top level?
10:29:14 <musasabi> no, there were just too few ticks.
10:33:48 <musasabi> Is there a way to move blocks of data between a Ptr and an IOUArray ?
11:14:56 <shapr> it's very quiet here today
11:15:06 <stepcut> shh!
11:15:07 <kristnjov> sorry about that mate, i was out
11:15:23 <kristnjov> (as everyone knows, i'm the one keeping this place together)
11:15:27 <shapr> hey stepcut, have you written an interpreter with Arrows?
11:15:33 <shapr> kristnjov: we bow to your superior wisdom.
11:15:42 <kristnjov> well, you'd better.
11:16:33 <stepcut> shapr: no sir, I have yet to do anything useful with arrows ;(
11:16:53 <shapr> I've been hacking on arrowex4.hs, trying to make a Joy interpreter...
11:17:03 <shapr> Not sure how to jump to postfix though.
11:17:25 <shapr> also, there must be a less verbose way to implement each ESym
11:17:54 <stepcut> hrm...
11:17:59 <shapr> http://www.scannedinavian.org/~shae/ProtoJoy.hs
11:18:23 <shapr> hej kolmodin 
11:18:31 <shapr> looking for Haskell info?
11:18:44 <stepcut> The next thing I am doing is haskell is generating binary data structures
11:18:53 <shapr> oh cool, you have code that does that?
11:18:58 <stepcut> no
11:19:05 <stepcut> but I will
11:19:05 <shapr> Are you planning on modifying NewBinary?
11:19:18 <stepcut> I am probably going to start with NewBinary and see what happens
11:19:49 <stepcut> Also, maybe that code that guy wrote that analyzed structs in .h files and generated a parser ?? (or am I just imagining that is what it did...)
11:20:16 <shapr> That sounds like Wolfgang Thaller's Template Haskell Objective-C binding.
11:20:27 <kolmodin> shapr: not really, just trying the haskell channel for the first time :)
11:20:39 <shapr> kolmodin: long time user of Haskell maybe?
11:21:18 <kolmodin> i have used it for about two years
11:21:21 <shapr> Ah, google has the answers.
11:21:39 <musasabi> for existing protocols it is usually enough to define small input/output operators and implement things in terms of them.
11:21:54 <stepcut> shapr: I was thinking of the deser stuff..
11:22:40 <shapr> oh
11:22:52 <shapr> kolmodin: nice website.
11:22:59 <shapr> You need more content :-)
11:23:14 <kolmodin> you mean my chalmers webpage?
11:23:20 <shapr> yup
11:23:47 <kolmodin> noooo, that page is just embarrasing ;)
11:24:19 <kolmodin> i have thought of improve it many times but.... you know... 
11:24:20 <shapr> so, you have any online Haskell code that you've written?
11:24:37 <shapr> stepcut: oh, that would be spiffier.
11:24:41 <kolmodin> no, not yet
11:25:35 <kolmodin> but I intend to within a few month or so
11:26:08 <shapr> cool
11:26:53 <kolmodin> i'm a member of "Project Lambda" :DD   http://d3proj.dyndns.org:8080/
11:27:16 <shapr> mattam: I think UU_Parsing is arrow parsing. That makes sense since Doaits Swierstra is one of the two who came up with the problem to begin with.
11:27:34 <shapr> whoa, nifty
11:28:35 <shapr> kolmodin: you might want to try darcs instead of svn, but there's no win32 GUI for darcs.
11:28:48 <mattam> shapr, indeed it is
11:29:10 <mattam> and Hughes talks about Swiestra problems in his paper
11:29:47 <shapr> Yup, but I can't seem to get the UUST sources.
11:29:59 <shapr> kolmodin: what sort of IDE plan do you have?
11:30:32 <kolmodin> David's advanced revision control system... who is David? :)
11:30:40 <shapr> That's David Roundy.
11:31:49 <kolmodin> so why is darcs better for us? give me some sales talk
11:32:56 <shapr> It's easier to learn, simpler to use, and is also written in Haskell, so you may want to hack it into your editor.
11:33:17 <kolmodin> shapr: we have written a few documents about the IDE but they are all in swedish
11:33:33 <stepcut> shapr: can I revert to what was in my tree two weeks ago ?
11:33:33 <shapr> kolmodin: jag kan läser lite svenska, även om jag är amerikansk.
11:33:36 <tic> lame. :) We write everything in English! :)
11:33:38 <kolmodin> shapr: that sounds nice, i'll have to look in to it
11:33:42 <tic> (hey k, btw. :)
11:33:56 <shapr> er "kan läsa"
11:34:00 <shapr> man my grammar sucks :-(
11:34:18 <kolmodin> shapr: imponerande! :) jag kan lite engelska fastän jag är svensk :)
11:34:25 <shapr> heh!
11:34:31 <shapr> kolmodin: you may also want to try #haskell.se
11:34:38 <kolmodin> ah, cool
11:34:59 <shapr> I live in Boden, so knowing Swedish is useful.
11:35:11 <kolmodin> haha :)
11:37:13 <shapr> hiya CosmicRay 
11:37:18 <CosmicRay> good afternoon shapr
11:37:40 <CosmicRay> if you want to see something I think is cool, check out: http://www.complete.org/fs/hclr/
11:37:46 <CosmicRay> note that there is more there than the normal ghc fare
11:37:49 <shapr> Yah, I just saw the mail.
11:37:53 <CosmicRay> :-)
11:38:01 <shapr> Was just wondering if it's similar to lambdabot's @index command.
11:38:10 <CosmicRay> I don't know
11:38:13 <CosmicRay> how does that work?
11:38:28 <shapr> index loads all the *.haddock files from the libs into a FiniteMap
11:38:30 <shapr> @index anyChar
11:38:30 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
11:38:33 <CosmicRay> ah.
11:38:45 <CosmicRay> well this takes those files but it adds in other packages as well
11:39:27 <CosmicRay> it basically mimics the ghc process for building its docs
11:39:30 <CosmicRay> plus adds in these others
11:39:49 <shapr> Which ghc process?
11:40:34 <shapr> Truly a centralized set of documents is useful, especially the index.
11:40:48 <CosmicRay> shapr: cd libraries; make html
11:40:55 <shapr> ah
11:40:57 <CosmicRay> actually I take the output of that and add to it
11:41:12 <CosmicRay> ghc uses some under-documented haddock features
11:41:14 <shapr> CosmicRay: This is really cool :-)
11:41:21 <CosmicRay> shapr: glad you like it
11:41:30 <CosmicRay> shapr: I'm going to try to add every library I use to it
11:41:45 <CosmicRay> plus anything anybody else requests
11:41:48 <shapr> I think we're going to need folding or something.
11:41:53 <CosmicRay> folding?
11:42:22 <shapr> I envision hosting this on haskell.org and including the haddocks for every Haskell code I can find.
11:42:28 <CosmicRay> yes.
11:42:32 <shapr> You'll end up with something the size of the JavaDoc APIs
11:42:33 <CosmicRay> that would be excellent.
11:42:35 <CosmicRay> yes
11:42:37 <CosmicRay> scary.
11:42:43 <shapr> So you'll need folding, framer, or something.
11:42:46 <shapr> um "frames"
11:42:48 <CosmicRay> ah.
11:42:50 <CosmicRay> gotcha.
11:43:04 <shapr> I've wanted Haddock folding anyway.
11:43:09 <CosmicRay> what I need is a "make update" command that would also update the versions of all the stuff it has :-)
11:43:32 <shapr> Another good thing would be to add overall unit tests into the Haddocks (imho)
11:44:14 <shapr> For example, a little green square that has the implementation and version used to run the unit tests and make the haddocks for tis library.
11:44:22 <CosmicRay> ah.
11:45:07 <shapr> For extra spiffiness, haddock could check for older/other Haskell implementations and put in a red square for the failures.
11:45:46 <shapr> Then you could immediately see if a lib is GHC-only, nhc-only, GHC-5.04-only, etc.
11:45:58 <CosmicRay> you are as much a dreamer as I am :-)
11:46:25 <shapr> Well, that sort of thing already exists in much spiffier form from Ward Cunningham: http://fit.c2.com/
11:48:09 <shapr> mattam: ah, I got uust.
11:48:20 <shapr> Haven't tried it yet. I wonder if it's better than Parsec.
11:55:08 <shapr> hiya shammah
12:00:15 <Lemmih> What requirements would there be for the new haskell.org/libraries?
12:00:31 <mattam> seems so, there are comparisons on the uust site
12:00:38 <shapr> Lemmih: Which libraries?
12:02:56 <Lemmih> shapr: SPJ talked about a dynamic webpage for the libraries.
12:03:05 <CosmicRay> Lemmih: perhaps the Caml Humps would be a reasonable system to use/emulate?
12:03:20 <CosmicRay> http://caml.inria.fr/humps/
12:03:24 <shapr> Lemmih: Yes, and he volunteered me for that webpage.
12:03:29 <bourbaki> hi Lemmih 
12:03:37 <Lemmih> Hello bourbaki
12:04:19 <CosmicRay> I could use some help cabalizing hsshellscript
12:04:28 <CosmicRay> it has a heavy c component and uses autoconf IIRC
12:06:00 <Lemmih> shapr: And are you gonna do it?
12:06:04 <shapr> I dunno yet.
12:06:25 <shapr> My focus and consistency have been low in the last few weeks, not sure if I can do a good job.
12:07:06 <Lemmih> How would you proceed if you had the time?
12:08:12 <shapr> I'm make a 'webscraper' database that read in Haskell Wiki pages and had good searching and indexing features.
12:08:50 <Lemmih> I'm currently thinking in the direction of Halipeto + HDB.
12:09:10 <shapr> That way, I wouldn't have to worry about manual input and editing of entries. I'd only have to worry about making the 'reader' side worth using.
12:09:28 <shapr> Yah, Halipeto and HDB would be best I think.
12:10:14 <Lemmih> But does the wiki contain sufficient information?
12:10:35 <shapr> Maybe not now.
12:11:25 <shapr> But if you send an email to libraries@haskell.org that says "wiki pages under CategoryLibrary or CategoryApplication are automagically sucked into the database according to this template" then people will put the info into the wiki.
12:14:41 <Lemmih> Wiki pages are saved in plain text on the servers hard disk, right?
12:19:07 <shapr> hej ludde 
12:19:10 <ludde> hejhej
12:19:11 <shapr> Lemmih: that's correct.
12:20:51 <Lemmih> Wasn't there a guy who wrote a wiki in Haskell?
12:21:06 <shapr> Yes, sebastian Carlier wrote one.
12:21:12 <shapr> Philippa wrote one last week.
12:21:20 <shapr> Want to see?
12:21:40 <Lemmih> Yes.
12:21:53 <shapr> http://www.scannedinavian.org/cgi-bin/flippi/flippi
12:22:03 <shapr> That's the 0.01 version, I think.
12:22:04 <Lemmih> The parser code would save me some time.
12:22:55 <Lemmih> "Internal Server Error" /-:
12:22:57 <tuomov> wikis should be more integrated with a version control system, the wiki mainly being an interface to the version control system
12:23:07 <Lemmih> I tried to create a new page.
12:23:12 <tuomov> that way it would be easier to edit nodes with proper editors, add extra files, and so on
12:23:14 <shapr> tuomov: I agree!
12:25:41 <Philippa> tuomov: ever seen Ted Nelson giving a speech? He comes at it the other way but reaches the same conclusion
12:26:01 <tuomov> no, I haven't seen
12:26:06 <Lemmih> shapr: Got an url for the one Carlier wrote?
12:26:12 <shapr> um...
12:26:21 <shapr> I think it's in hlibs
12:27:00 <Lemmih> Found it.
12:29:48 <CosmicRay> hlibs?
12:30:16 <shapr> http://haskell-libs.sourceforge.net/
12:30:28 <shapr> It's a sourceforge project I created long ago as a cvs-wiki.
12:30:43 <CosmicRay> shapr: there's nothing on that page
12:30:49 <shapr> yes, that's true.
12:30:54 <shapr> but there's goodies in the cvs repo
12:30:55 <CosmicRay> great project :-)
12:30:59 <shapr> heh
12:31:00 <CosmicRay> ah.
12:31:09 <shapr> anyway, I moved all the goodies to a darcs repo
12:31:19 <shapr> and I keep meaning to get around to splitting them out into their own repos
12:31:22 <CosmicRay> heh
12:31:46 <CosmicRay> hmm!
12:31:56 <CosmicRay> some of this definately needs to be imported into MissingH :-)
12:32:42 <CosmicRay> what's the copyright/license on all this stuff?
12:33:04 <shapr> Should be all F/OSS compatible.
12:33:33 <CosmicRay> I'm having trouble finding copyright/license statements on the things I've checked
12:34:13 <shapr> well, for everyone that's checked in code, I've told them that it must be F/OSS licensed, lGPL, GPL, BSD, or PD
12:34:29 <CosmicRay> huh.
12:34:33 <CosmicRay> haskellLibTracker.
12:34:36 <CosmicRay> that may be relevent.
12:34:37 <shapr> yup...
12:34:51 <CosmicRay> problem is, most of the files don't even have a copyright statement
12:34:53 <CosmicRay> much less a license
12:35:02 <CosmicRay> I've found a couple that do have a license
12:35:18 <CosmicRay> if you could get all that cleaned up, we could at least put this in debian
12:35:31 <CosmicRay> as it stands, the legal status is probably not clear enough to do that
12:35:40 <shapr> hm
12:40:03 <shrimpx> anyone familiar with linear logic?
12:53:06 <shapr> hej Marvin-- 
12:53:46 <Marvin--> hej hej
13:05:36 <shapr> hiya borism 
13:05:39 <shapr> greetz monochrom 
13:06:15 <monochrom> greetz
13:06:45 <borism> hi shapr 
13:13:42 <shapr> hoi Boegel
13:15:59 <Boegel> hello shapr
13:16:12 <Boegel> I finished my ray casting algorithm in Haskell :)
13:16:45 <shapr> cool!
13:17:04 <Boegel> :)
13:17:18 <shapr> hej Deniz 
13:17:21 <Boegel> I put the documentation in English so you guys could check it ouot
13:17:22 <shapr> Denizen
13:17:29 <Boegel> s/ouot/out
13:17:30 <shapr> Boegel: spiffy! Where is it?
13:17:41 <Boegel> one moment, I'll throw it online
13:17:45 <Boegel> any comment is welcome :)
13:18:40 <kristnjov> stop saying that, my name is deniz as well :P
13:22:20 <Boegel> for everyone who wants to comment on it, or just look at it: http://studwww.ugent.be/~kehoste/thesis/rayCasting.hs
13:22:41 <Boegel> @seen mitchkov
13:22:42 <lambdabot> I haven't seen mitchkov
13:22:59 <shapr> @seen scooby doo
13:22:59 <lambdabot> I haven't seen scooby
13:23:25 <shapr> @seen Casablanca
13:23:25 <lambdabot> I haven't seen Casablanca
13:23:34 * stepcut reads the paper just referenced on haskell-cafe (http://homepages.cwi.nl/~ralf/OOHaskell/)
13:23:40 <shapr> lambdabot: You just don't watch movies at all, do you?
13:23:41 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:25:18 <Boegel> shapr: how do you like it ? is my coding style ok ?
13:25:40 <stepcut> odd, when I go to the rayCasting.hs link, konqueror adds a second bookmarks menu with two entries, 'set bookmark' and 'clear all bookmarks'
13:27:16 <Boegel> stepcut: it's no virus, I swear :p
13:27:21 <shapr> Boegel: I think you might like literate haskell.
13:27:31 <Boegel> shapr, what do you mean ?
13:28:01 <shapr> with an .lhs file, the whole file is comments except for the lines that start with the two characters "> "
13:28:36 <shapr> They're punnily known as 'birdtracks' because Richard Bird had something to do with them.
13:29:16 <Boegel> that might be a good idea yes :)
13:29:23 <Boegel> I'll take a note of it :)
13:29:41 <Boegel> tomorrow, I have to go to my promotor with it, I'll see what he says about it
13:30:23 <Boegel> ow, I forgot
13:30:38 <Boegel> when you try to run the code, you should change the directory where the file is placed
13:30:45 <Boegel> else that could cause troubles I guess
13:31:01 <Boegel> if the folder doesn't exist..
13:32:17 <Boegel> I think I could also improve the speed of it a bit
13:32:35 <Boegel> if you guys have any hints on that part... also memory 'managment'
13:32:58 <Boegel> damn, something is wrong with the parameters :)
13:33:05 <Boegel> the image is f*cked up...
13:37:28 <Boegel> damn, what did i change... :s
13:40:06 <Boegel> fixed it
13:40:20 <Boegel> are you guys all concentrating on my code or what ? shapr ? stepcut ?
13:40:42 * shapr wakes up
13:40:46 <shapr> what? who? where?
13:40:55 <shapr> is it time for school already?
13:41:21 <Boegel> :)
13:41:25 <Boegel> how do you like my code ?
13:41:29 <Boegel> have you tested it ?
13:42:08 <shapr> Haven't tried it yet, but it is very easy to read.
13:43:15 <shapr> Looks like there would be some opportunities for memoization in here somewhere.
13:43:21 <shapr> But speed may not be your goal.
13:44:11 <Boegel> yeah okay I know
13:44:18 <Boegel> Haskell isn't very fast
13:44:33 <Boegel> but, maybe with some code tuning I can improve the speed a little bit
13:44:44 <shapr> I think it can be much faster.
13:44:47 <Boegel> because this is just the beginning
13:45:02 <shapr> but this implementation is very readable.
13:45:03 <Boegel> how ? can you give me some hints ?
13:45:26 <Boegel> I think using 'map' would be a great improvement...
13:45:43 <Boegel> because I work on lists all the time (colours, objects, intersections)
13:46:21 <Jan_w> the best speed improvements are due to better program logic (almost unlimited speed improvements possible), not better language or CPU speed (only liniair speed improvements)
13:46:39 <shapr> I think you should aim for tail-calls, and pull a lot of where clause stuff up to the top level.
13:47:05 <Boegel> what are tail-calls ?
13:47:25 <shapr> like length (x:xs) = 1 + (length xs)
13:47:37 <shapr> then GHC (and Hugs I think) can turn that into a loop
13:47:38 <Boegel> and raising the where clause stuff, do you mean using let ... in ?
13:47:55 <Boegel> I think I did that most of the time
13:48:18 <kolmodin> shapr: you dont need an accumulator?
13:48:25 <Boegel> with the rayTrace and rayTraceLine I payed attention to that...
13:48:39 <shapr> I think you can cut out some duplication by refactoring things like intX, intY, intZ into more generic single top level definitions.
13:49:31 <kolmodin> like length xs = length' 0 xs where length' v (x:xs) = length' (v+1) xs        ?
13:50:45 <shapr> kolmodin: I think that'll be even faster than a tail-call alone, but it goes over my 'feels natural to write' limit.
13:50:56 <kolmodin> shapr: true
13:51:18 <kolmodin> Boegel: have you done some profiling?
13:51:49 <Boegel> profiling ? :)
13:51:55 <kolmodin> otherwise you may guess the function who cost the most (time and memory)
13:51:56 * shapr grins
13:52:08 <Boegel> I just finished the code this afternoon, and I don't know what it is
13:52:19 <Boegel> memory will be the rayTrace function
13:52:21 <Etaoin> why does moving things out of where clauses help speed?
13:52:26 <Boegel> time will be the intersect function :)
13:52:47 <kolmodin> wrong and wrong. sorry :)   
13:52:52 <Boegel> Etaoin: because then Hugs or GHC doesn't have to replace them with the expression when needed
13:53:05 <kolmodin> createPPM                      Main                  time 36.8%,   memory 30.3%
13:53:10 <Boegel> kolmodin: ow ? how do I do some decent profiling then ?
13:53:38 <Boegel> that bitch costs my most of the time ? :)
13:53:38 <kolmodin> Boegel: compile with ghc -O2 --make rayCasting.hs -o ray -prof -auto-all
13:53:45 <kolmodin> lol :)
13:54:00 <Boegel> that just so I could see the result decently :p
13:54:03 <kolmodin> then run your program with ./ray +RTS -P
13:55:52 <Boegel> kolmodin: let's give that a try :)
13:56:35 <kolmodin> yes, and save the results so that you can compare after you modified your code
13:56:56 <kolmodin> then you know what was worth doing
13:57:11 <Boegel> kolmodin, can I do that with GHCI to ?
13:57:18 <Boegel> because I'm using this in windows :s
13:59:00 <kolmodin> profiling on interpreted code?
13:59:16 <Boegel> yes
14:00:20 <kolmodin> trough ghci? i dont think that is possible... or, I mean: .. have been done before :)
14:00:21 <TheHunter> Profiling nonoptimized code doesn't make much sense since ghc doesn't eliminate tail calls by default.
14:00:44 <shapr> I think there's a ghci + hat thingy somewhere.
14:01:12 <kolmodin> shapr: for profiling?
14:01:42 <shapr> more for debugging I think
14:01:45 <Boegel> ow wait :)
14:02:03 <kolmodin> mm
14:02:35 <Boegel> it's working, I had to put the ghc folder in my 'Path' system variable
14:02:49 <Boegel> I always compile by opening the file (it starts GHCI that way)
14:03:06 <shapr> I tend to use -fvia-C -O2
14:04:27 <kolmodin> I thought that it would compile through C as soon as I use -O2?
14:04:44 <shapr> I don't know.
14:05:12 <Boegel> it works kolmodin, thanks :)
14:05:18 <Boegel> now I can show off tomorrow :p
14:05:32 <kolmodin> Boegel: you are welcome :) glad I could help
14:05:43 <Boegel> I love #haskell :)
14:06:13 <shapr> me too!
14:06:52 <Matt-W> oooh yes
14:06:58 <Matt-W> even though I rarely say anything
14:07:04 <Matt-W> or even pay attention to what anybody else is saying
14:07:09 <Matt-W> when I do say things, you're all very nice
14:07:16 <kolmodin> me too! but I have to be online on two servers now
14:07:33 <shapr> gimpnet?
14:07:40 <kolmodin> quakenet
14:07:44 <shapr> oh
14:07:58 <Boegel> shapr, can you tell me on which functions I should pay attention to improve speed + memory usage ?
14:08:02 <kolmodin> my non-haskell-friends are there :)
14:08:10 <shapr> kolmodin: man, I need some of those...
14:08:12 <Boegel> the createPPM couldn't be much different I think
14:08:12 * shapr grins
14:08:20 <kolmodin> shapr: lol :)
14:08:41 <Boegel> it's just because it does IO that that function is so slow...
14:09:06 * Etaoin remembers discovering that his createPPM function is slow in his own projects
14:09:25 <Matt-W> kolmodin: you're on the slippery slope now, I think I'm on six or seven servers these days
14:10:04 <kolmodin> Boegel: you are using a lot of ++
14:10:15 <shapr> yah, you could use ShowS instead.
14:10:59 <kolmodin> Matt-W: recomend me a good irc client for linux
14:11:27 <Matt-W> kolmodin: irssi
14:11:43 <kolmodin> right. good. i'm using irssi now
14:12:03 <Boegel> kolmodin: funny :)
14:12:13 <kolmodin> how do I join several servers with irssi :)
14:12:14 <Boegel> @type ShowS
14:12:17 <lambdabot> bzzt
14:12:24 <Boegel> @info ShowS
14:12:26 <lambdabot> -- ShowS is a type constructor
14:12:26 <lambdabot> type ShowS = String -> String
14:12:46 <Boegel> what does ShowS do ?
14:13:11 <kolmodin> @index shows
14:13:12 <lambdabot> GHC.Show,Prelude,Text.Show
14:13:37 <kolmodin> Boegel: http://www.haskell.org/tutorial/stdclasses.html
14:13:51 <Matt-W> kolmodin: to join another server use /server +servername
14:14:02 <Matt-W> kolmodin: the + is important, if you leave it out it replaces your current server with the new one
14:14:05 <kolmodin> Matt-W: ah, thanks!
14:14:55 <kolmodin> thats what I did earlier... except the +   :)
14:15:22 <Boegel> kolmodin: thanks, I'm printing that for on the train tomorrow :)
14:16:04 <kolmodin> Boegel: you'll only need "8.3  The Read and Show Classes"
14:16:18 <Boegel> kolmodin :I know, thanks :)
14:19:00 <kolmodin> Boegel: short example: (showString "foo" . showString "bar") "!"
14:19:52 <kolmodin> or as a friend of mine would say: (showString "eat " . showString "my ") "shorts"
14:20:09 <CosmicRay> Any idea what could cause:
14:20:14 <CosmicRay> /usr/lib/haskell-packages/ghc6/lib/hsshellscript-2.0.1/libHShsshellscript-2.0.1.a(ProcErr.o)(.text+0x65): In function `__stginit_HsShellScriptziProcErr_':
14:20:14 <CosmicRay> : undefined reference to `__stginit_Maybe_'
14:20:38 <kolmodin> CosmicRay: compiling with --make  ?
14:20:40 <shapr> it can't find Maybe when it wants to link.
14:20:51 <CosmicRay> kolmodin: no, this is using Cabal
14:21:06 <CosmicRay> I'm trying to Cabalize hsshellscript
14:21:10 <CosmicRay> that is not the only one it complains about
14:21:15 <shapr> HsShellScript.ProcErr want Maybe
14:21:22 <CosmicRay> it also gets __stginit_System_, IO, Directory, etc, etc.
14:21:30 <shapr> could you tell it to import Data.Maybe instead?
14:21:53 <CosmicRay> btw it compiles fine when I don't use cabal
14:21:58 <shapr> if Data.Maybe fixes the problem, then it's older code that's expecting you to use -package data and friends instead of hierarchical libraries.
14:22:15 <CosmicRay> ah, yes, I am having to use a bunch of -package stuff to make it compile.
14:22:26 <CosmicRay> actually I listed it as build-depends in Setup.description
14:30:26 <shapr> hierarchical libs are a lot nicer.
14:43:07 <shapr> hiya SamB 
14:46:55 <shapr> Any clueful arrow users here? Does (| |) do something special with -farrows ?
14:47:55 <stepcut> shapr: is there supposed to be something between the |s ?
14:48:02 <shapr> there is
14:48:06 <shapr> (|(symbol Plus)|)
14:48:40 <shapr> I'm still trying to figure out parts of the arrow-based interpreter example here: http://www.scannedinavian.org/~shae/ProtoJoy.hs
14:49:50 <stepcut> I have never seen that syntax before...
14:49:58 <shapr> neither have I
14:50:15 <shapr> but Ross Paterson wrote both these examples and the -farrows translation rules.. so who knows.
14:53:42 <kolmodin> I dont "get" arrows
14:53:45 <shapr> I suspect the handling of ESym constructors in term' could be simpler.
14:54:00 <shapr> kolmodin: you missed a long explanation of them on #darcs just an hour ago...
14:54:19 <kolmodin> :(
14:54:23 <shapr> I ended up saying, "if you noun a verb, you can do static checks on it"
14:54:34 <shapr> a function is a 'verb' and arrow is a noun from that verb.
14:54:42 <shapr> (assuming you're lifting a pure function into an arrow)
14:55:14 <kolmodin> no logs of #darcs like the ones of this channel?
14:55:19 <shapr> nope, sorry
14:56:02 <shapr> In a nutshell, monads are recursive tail calls, and arrows are an iterative form of the same thing.
14:57:15 <Matt-W> what is the best thing to read for an introduction to arrows?
14:57:19 <kolmodin> ok. I have a paper of Ross Paterson, guess I have to read it again
14:57:36 <shapr> Yah, Paterson's FoP chapter is the best intro, in my opinion.
14:57:59 <shapr> All the info is in Hughes' paper and some later papers put together, but Paterson brings it all into one place.
14:59:25 <TheHunter> hmm, so how does (<*>) :: Parser a -> Parser (a->b) -> Parser b define an arrow?
14:59:57 <TheHunter> (together with succeed :: a -> Parser a)
15:00:27 <kolmodin> shapr: the paper is a part of the book "the fun of programming"
15:00:41 <kolmodin> it's called "Arrows and computation"
15:01:50 <shapr> Yup, that one.
15:02:12 <shapr> I keep meaning to purchase that book.
15:02:14 <kolmodin> ah, FoP == Fun of Programming. now i get it :)
15:02:32 <Boegel> I'm going to bed
15:02:43 <Boegel> thanks for the help everyone, and I'll see y'all soon :)
15:02:43 <Deniz> http://www.terminal-insanity.com/z1g/steadyhand.swf
15:02:45 <shapr> g'night Boegel 
15:02:47 <kolmodin> good night :)
15:02:49 <Deniz> very nive online game :D
15:02:53 <Deniz> try it.. heheh
15:03:22 <stepcut> but apparently it is something to do with arrows
15:03:39 <Matt-W> I keep thinking FoP = Foundations of Programming
15:03:45 <shapr> Deniz: that's a mean trick.
15:04:01 <Boegel> Deniz: omg ! how can i go to sleep now :s
15:04:28 <TheHunter> ok, i'm beginning to think the author got it wrong
15:04:46 <shapr> TheHunter: that type sig is from UU_ST, I think.
15:05:13 <shapr> Doaitse Swiestra and co were using their non-monad combinators, and that's how Arrows got started.
15:06:04 <TheHunter> that type sig is from the caml list post you gave a couple of hours ago, but uu_st uses the same one.
15:06:33 <shapr> Hughes and Paterson use different type sigs.
15:07:00 <TheHunter> anyway <*> and succeed don't define an arrow
15:07:09 <shapr> I take your word for it :-)
15:08:00 <TheHunter> the UU combinators can indeed been used monadically.
15:08:48 <TheHunter> and the source doesn't mention arrows
15:09:42 <TheHunter> and in his paper, he says that the moadic interface should only be used if there is a good reason for doing so.
15:10:03 <shapr> @index (-<<)
15:10:03 <lambdabot> bzzt
15:10:20 <TheHunter> Thus, using the Kleisli arrow for Parser would prolly have a very bad behaviour.
15:12:11 <shapr> dang, I missed andersca
15:12:20 <shapr> ring ring ring banana bracket!
15:13:32 <shapr> ring ring ring banana bracket!
15:14:09 <stepcut> @arr
15:14:09 <lambdabot> Avast!
15:14:13 * shapr grins
15:14:14 <stepcut> @arr
15:14:14 <lambdabot> Ahoy mateys
15:14:20 <shapr> @arr (+ 1)
15:14:21 <lambdabot> I want me grog!
15:14:23 <shapr> @type arr
15:14:24 <lambdabot> bzzt
15:14:36 <stepcut> @arr (+ 1)
15:14:36 <lambdabot> Aye
15:15:11 <stepcut> *lambdabot* not enough privileges
15:15:13 <stepcut> sniff :(
15:15:23 <shapr> have you written a lambdabot plugin?
15:15:33 <stepcut> I hear andersca is a pirate
15:15:39 * shapr grins
15:15:51 <shapr> At least, he talks like one.
15:16:08 <stepcut> what happened to andersca anyway?
15:16:12 <shapr> andersca: hi!
15:16:18 <shapr> he's right here.
15:16:21 <stepcut> oh
15:16:27 <shapr> He came back.
15:16:52 <TheHunter> shapr: about the funny brackets: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html#AEN9675
15:17:05 <shapr> yah, banana brackets :-)
15:17:25 <shapr> ring ring ring banana bracket!
15:17:40 <shapr> That explains why I couldn't find the form keyword.
15:22:05 <shapr> hah
15:25:25 <andersca> I'm here
15:25:28 <andersca> I pressed ctrl-alt-bs
15:25:34 <shapr> oh yeah
15:25:40 <shapr> I use DontZap
15:29:51 <kolmodin> quick question: on the first page of Patersons paper, the type sig of add is incorrect. yes?
15:30:15 <kolmodin> drop the two last brackets?
15:30:37 <shapr> umm
15:30:50 <shapr> I think so
15:30:53 <TheHunter> a -> b -> c means a -> (b -> c)
15:30:57 <TheHunter> it's correct
15:31:27 <kolmodin> but it's ok to drop the brackets too?
15:31:42 <TheHunter> sure, -> is right associative
15:32:28 <kolmodin> ah, cool. I have never seen code like that elsewheere
15:33:15 <TheHunter> it's sometimes (as in this case) clearer that way. You can view it as `currying' on the type sig level
15:34:10 <kolmodin> he does the same thing on page 2, addST and andND.
15:34:50 <kolmodin> so you can take any nuber of extra arguments as long as the return type is correct. neat
15:35:40 <kolmodin> this simplifyes the understanding of the paper a bit :)
15:37:42 <kolmodin> right. goodnight
15:37:46 <shapr> g'night
15:56:26 <TheHunter> Wow, google has only two hits for the german spellings "anamorphismus" and "catamorphismus" that are related to FP, respectively
15:57:22 * stepcut kicks google
15:59:43 <monochrom> the english spelling gives you better results
16:00:28 <TheHunter> are those words so uncommon? i feel like i'm reading them every day...
16:00:39 * shapr laughs
16:00:56 <shapr> TheHunter: My fiancee is *so* tired of hearing about monads and arrows.
16:01:21 <TheHunter> :-)
16:01:30 <shapr> The last time I told a group of programmers that I like Haskell, everyone tried to leave.
16:01:33 <Philippa> shapr: I bet. Damien's asked me to teach him Haskell at some point so he can follow what I'm up to
16:01:34 <Philippa> hehehe
16:01:48 <stepcut> shapr: well, once you get married I am sure you won't be allowed to talk about monads and arrows anymore, so you better get it out of your system
16:01:51 <Philippa> I have that problem around here, but that's because UoN teach it on their compsci course...
16:02:13 <shapr> Luleå university in the next town teaches Haskell, but all their alumni seem terrified of FP.
16:02:45 <Philippa> right. UoN don't really teach enough to write useful programs with
16:02:57 <Philippa> I mean, enough to pick up the tutorials and learn how to, sure
16:03:00 <shapr> That seems to be true of Luleå also.
16:05:35 <dons> heya shapr. remember your idea to load an entire application dynamically, to save silly static linking when messing with plugins?
16:05:42 <shapr> yah yah
16:05:44 <dons> check http://iki.fi/tuomov/repos/riot-hsplugins Boot.hs and Main.hs
16:05:53 <shapr> oh you got one?
16:05:57 <dons> yep
16:06:04 * shapr darcs gets
16:06:25 <dons> to actually use this you need hs-plugins from the nightly snapshot, btw
16:06:30 <shapr> speaking of ideas, any more thought on your idea to dump .hc files for a Haskell app?
16:06:59 <dons> simon marlow didn't like it. i.e. C apps require gcc -- so why should we require ghc?
16:07:13 <dons> but, it is still out there, and I may still do it sometime
16:07:26 <dons> since we already do it for ghc bootstraps and nhc bootstraps
16:07:31 <shapr> I don't understand Simon's response.
16:07:42 <shapr> you mean why *shouldn't* we require ghc?
16:07:48 <dons> oopps. yes
16:08:07 <dons> they don't distribute their C code in asm format
16:08:14 <shapr> interesting point.
16:08:19 <dons> but maybe he has a conflict of interest
16:08:25 <shapr> though you could say that the binary Linux distros do.
16:09:01 <dons> yep. i still think this is a good way to go for certain critical apps == darcs
16:09:05 <shapr> yup
16:09:13 <dons> just a matter of writing a shell script.
16:09:19 <shapr> really that easy?
16:09:26 <dons> ok. so maybe I should do that.
16:09:43 <dons> yes. you need -keep-hc-files on the relevant libraries, and on the app itself
16:09:45 <shapr> heh, I was just surprised :-)
16:09:49 <dons> tar it up, and away you go
16:09:55 <shapr> wow, that does sound easy.
16:10:35 <dons> getting the right flags would be the tricky bit (i.e. reproducing ghc's lib C and link flags)
16:11:04 <dons> re riot-hsplugins. Boot.hs loads riot-static, and jumps to Main.dynamic_main
16:11:29 <shapr> I see
16:11:30 <shapr> way sexy
16:11:55 <dons> little bit of magic for sharing the type of the value between static and dynamic land, to avoid static land having explicit imports on dynamic land code
16:12:38 <dons> don't say "unsafeCoerce#" .... but it is just a simulated dynamic value container
16:13:02 <dons> anyway .. the point: I think this is how to do these dynamic Haskell apps
16:13:06 <shapr> I want to use this for a HEmacs =)
16:13:24 <dons> yep... if there is a Haskell editor out there *now* I'll port it!
16:13:41 <dons> otherwise, time to get hacking
16:14:10 <shapr> does this allow full elisp-style dynamic code reloading with Haskell?
16:14:30 <dons> the dynamic code itself has to use Plugins.Load.reload
16:14:42 <shapr> Also, have you mentioned this cool and sexy feature to the Haskell world at large?
16:15:09 <dons> not yet. only got committed last night :}
16:16:02 <dons> so, I think we need a killer app that wants lots of extensibility to start hacking on
16:16:33 <shapr> like... HEmacs?
16:16:36 <dons> does anyone know of an already-existing editor written in Haskell?
16:16:47 <shapr> there's haIDE and hIDE that use emacs
16:16:53 <shapr> epigram uses emacs
16:16:53 <shapr> oh hey
16:16:58 <shapr> epigram might be something...
16:17:05 <shapr> since functions and types are pretty much the same there..
16:17:27 <Philippa> I still need to play with epigram properly at some point
16:17:37 <Philippa> is there a decent set of tutorials with interesting examples somewhere?
16:17:46 <shapr> dons: House/hOp
16:17:56 <shapr> but that requires some other missing pieces as well.
16:18:04 <Philippa> disk driver?
16:18:12 <dons> yep. but at least it would run on my thinkpad
16:18:20 <dons> House/hOp that is
16:18:26 <Philippa> give it that, a filesystem of some sort and then this and you're sorted
16:18:48 <shapr> and, maybe you could fake the missing parts of hOp/House by calling out to a 'real' ghc on the QEmu host 
16:19:21 <dons> yeah. but maybe too big a project. getting an editor working might be a bit easier
16:19:28 <shapr> yah, I agree
16:19:44 <shapr> what requires lots of interactivity...
16:20:10 <dons> ok. I'll have a peek at the ide's, and see what can be done
16:20:15 <Philippa> a game engine! :-)
16:20:31 <dons> oh, that would rock
16:20:51 <dons> a window manager would be ideal too .. but I want tuomov to write that
16:21:17 <shapr> heh
16:21:38 <dons> and the cool thing is, once the framework is in place, the community can write all the missing modules
16:21:47 <shapr> ok, I like this :-)
16:23:41 <dons> now, i haven't used epigram. are you saying there is a basic ui?
16:24:36 <shapr> I still think I'm missing a bunch of applications for this ideas
16:25:09 <dons> well. the hs-plugins paper listed a couple of apps: web browser, photoshop
16:25:22 <dons> anything that has ever had lisp embedded in it
16:26:11 <Philippa> a text editor, an OS, both in the same app... :-)
16:26:38 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-28)!
16:26:39 <dons> oh,  that is beautiful :)
16:27:01 <Philippa> nice timing shapr :-)
16:27:06 * shapr grins evilly
16:27:16 <shapr> dons: I want out of emacs...
16:27:41 <dons> cool. I want to kill vim-script
16:27:46 <dons> hooray!
16:27:46 <shapr> :-)
16:27:49 * shapr cheers
16:28:24 <shapr> so, I have an existing mailing list named post-emacs
16:28:27 <Philippa> I want a decent programmable editor I can actually use...
16:28:31 <Philippa> yeah. Join post-emacs
16:28:34 <stepcut> shapr: haha
16:28:43 <Philippa> wait for my intro post where I explain that I don't actually use emacs ;-)
16:29:00 <shapr> ah, you've already escaped?
16:29:33 <shapr> I have a bunch of crazy ideas for a post-emacs editor, I think they would be best done with Haskell.
16:30:07 <Philippa> I never escaped, I just never used properly
16:30:13 <Philippa> *used it
16:30:32 <Philippa> there were too many things I'm used to that it'd take too long for me to figure out how to do in it
16:31:18 <shapr> hm, where to start with a HEmacs?
16:31:22 <shapr> curses binding?
16:31:35 <dons> well, I could adapt the curses ui in riot (which came from ginsu)
16:31:48 <Philippa> shapr: er, if I can build it under win32 that'd help...
16:32:00 <shapr> no curses on win32?
16:32:05 <shapr> wxHaskell? scintilla?
16:32:23 <Philippa> wxHaskell works for me (at least for now)
16:32:37 <shapr> Proxima? the PFE part of Programatica?
16:32:41 <Philippa> realistically though, build whatever you like and abstract out half the UI at a later date
16:32:46 <shapr> yah, agreed.
16:32:50 <dons> yep. sounds good
16:33:03 <shapr> but I want something I can start using soon.
16:33:10 <Philippa> I'd prefer wxHaskell because I can build it, but that's about it
16:33:27 <Philippa> of course, hs-plugins doesn't run under win32 yet anyway
16:33:34 <Philippa> at least, unless there's been a release while I wasn't looking
16:33:37 <shapr> wxHaskell doesn't yet have a binding to the scintilla component, though wxWidgets does support scintilla.
16:33:52 <dons> :p not quite working on win32 yet. but only \style paths to go
16:34:08 <Philippa> looking forward to a release :-)
16:34:15 <Philippa> that reminds me, need to actually /announce/ Flippi's release
16:34:21 <shapr> yah, good idea
16:34:23 <Philippa> any suggestions for places I should do so?
16:34:40 <dons> i'll get started on the ui now, and stick it in darcs by tonight
16:34:43 <shapr> well, haskell@haskell.org is the usual announce spot.
16:34:48 <Philippa> (the Haskell list, sure... I don't use other Wikis much, feel free to pimp it where it wouldn't be spam)
16:34:49 <shapr> dons: awesome
16:35:00 <shapr> which darcs repo should I cron?
16:35:21 <dons> it isn't set up yet. i'll let you know
16:35:27 <shapr> awright
16:35:42 <dons> http://www.cse.unsw.edu.au/~dons/code/hemacs probably
16:35:49 <shapr> sounds good
16:36:28 * dons is off hacking hemacs
16:36:49 <shapr> I gotta sleep, Swedish class in far too few hours.. and I haven't yet done my homework.
16:37:08 * shapr falls over asleep
17:08:47 <TheHunter> good night, everybody!
18:01:16 <michael`> hey all :)
18:02:19 <michael`> anyone here ever created an interpreter in haskell before?
18:02:59 <dons> non-trivial
18:04:26 <michael`> you think its easy?
18:04:40 <dons> I think it is non-trivial
18:05:02 <dons> interpreters for small subsets are easy
18:05:27 <michael`> yeah well its not that large :p
18:06:07 <michael`> can you give me some clues as to where i start
18:06:10 <michael`> im a bit boggled :p
18:06:25 <michael`> Ive got a language specification, all the operators, commands, syntax etc
18:06:28 <michael`> :S
18:07:20 <dons> find a small toy interpreter for a similar lanugage, and have a look at how it works
18:07:54 <michael`> ah ok :)
18:11:04 <dons> a small language interpreter was ass1 in this course: http://www.cse.unsw.edu.au/~cs3161/
18:11:23 <dons> you could have a look at that. the compiler is similar in some ways to a Haskell compiler
18:12:13 <michael`> i have to write an interpreter for a made up language, in haskell hehe
18:13:31 <dons> Simon PJ wrote a textbook on writing a compiler for Core Haskell
18:13:46 <dons> " Implementing functional languages: a tutorial", http://research.microsoft.com/users/simonpj/Papers/pj%2Dlester%2Dbook/
18:13:47 <michael`> i have to write an interpreter hehe
18:14:10 <dons> yep. but an interpreter is chapter 1, I think
18:14:29 <dons> so if you have no idea where to being, then this would be one start
18:15:06 <michael`> :)
18:16:23 <dons> also, you should read Bob Harper's book on language design: http://www-2.cs.cmu.edu/~rwh/plbook/
18:16:33 <dons> many interpreters are developed in that book
18:24:09 <LittleDan> where could I find information for beginners on arrows (or could someone explain them to me)?
18:26:25 <heatsink> dons: a number of chapters are missing from the book
18:26:37 <dons> bob harper's?
18:26:41 <heatsink> yea
18:27:00 <dons> I think there are some unwritten ones towards the end, after chapr 28 or so
18:27:06 <heatsink> right
18:27:25 <dons> just not written yet, is all
18:27:28 <heatsink> oh
18:36:32 <dons> excellent beginners book on language design, imo
18:37:44 <heatsink> When do you learn sequent notation?
18:38:25 <dons> G |- v : t ? right at the start
18:38:39 <heatsink> I've never learned it in class, but neither have I seen a computer science thing that doesn't assume the reader knows it.
18:40:30 <dons> quite true
18:44:36 <Philippa> I've just sent a post to the [Haskell] list, so I figure I may as well duplicate half the contents here...
18:44:41 <Philippa> www.flippac.org/projects/flippi/
18:44:49 <Philippa> a simple wiki clone in Haskell
18:44:51 <Philippa> go grab :-)
18:46:15 <heatsink> Hmm... PhD is not a link?
18:46:55 <heatsink> I see.
18:48:19 <Philippa> heatsink: I think one of Wadler's papers give an intro to it
18:48:40 <heatsink> to sequent notation?
18:48:42 <Philippa> so does the brick book (Types And Programming Languages)
18:48:45 <Philippa> yeah
18:48:52 <heatsink> ok
18:51:02 <dons> Pierce is the brick book?
18:51:31 <Philippa> yeah
18:51:44 * dons hates hacking build systems. grr
18:51:49 <dons> but it must be done
19:36:47 <michael`> is anyone available for some help ? :)
19:37:26 <heatsink> sure, I could use some help
19:42:46 <dons> hemacs is born : darcs get http://www.cse.unsw.edu.au/~dons/code/hemacs
19:43:16 <heatsink> does it indent haskell better than haskell-indent.el?
19:43:31 <CosmicRay> this is not an elisp mode
19:43:32 <CosmicRay> what is this?
19:44:55 <CosmicRay> are you rewriting emacs in haskell?
19:45:17 <dons> hemacs does nothing yet but start up a ui and dynamically load some Haskell code
19:45:43 <dons> see the discussion with shapr and Philippa earlier today about the post-emacs movement ;)
19:47:03 <dons> That could be a slogan : "HEmacs : This is not an elisp mode!"
19:47:11 <CosmicRay> heh
19:51:35 <Cale> dons: nice - people have been talking about that sort of project for a long time :)
19:51:56 <dons> I think we can do it now .. hopefully
19:52:07 <dons> or at least get headaches trying
19:52:26 <Cale> Is it going to use HS-Plugins, or some other mechanism for dynamically loading code?
19:52:53 <dons> hs-plugins, of course. that's the only way atm
19:58:34 <dons> now, hopefully people start playing with it in a few days and sending in patches
19:58:42 <dons> then we'll get somewhere with it
19:58:55 <dons> of course, at the moment it is a bit hard to see what to hack on
20:03:46 <Cale> You should perhaps post something to the Haskell mailing list if you haven't already :)
20:04:26 <dons> I will in a few days, once it actually does something slightly editor-ish -- like displaying a bufffer :)
20:07:42 * juhp decides its time to make an rpm of hs-plugins :-)
20:07:54 <dons> yay!
20:08:19 <dons> there's already an openbsd port script, and a mac osx script
20:08:22 <dons> so you could look at that
20:08:43 <juhp> dons: ah, thx
20:09:18 <dons> there may (?) be a debian port too
20:09:39 <dons> the openbsd port script is distributed with hs-plugins in script/
20:10:37 * juhp takes a look
20:15:14 <dons> p.s. hemacs requires the cvs version of hs-plugins, which is available as a nightly snapshot
20:15:20 <dons> hmm.. so maybe I should tag and release
20:16:23 <juhp> dons: ah - then yes please =-)
20:17:12 <dons> ok .. i'll make a snapshot release.
20:17:32 <juhp> great
20:21:18 <michael`> how do i set the command line arguments into a string?
20:21:26 <michael`> from when you run the haskell program
20:21:43 <dons> getArgs
20:21:57 <dons> juhp: check the download page. "heatwave" snapshot released
20:22:09 <michael`> which lib is getArgs in
20:22:10 <michael`> ?
20:22:29 <Igloo> System
20:22:34 <dons> michael`: check http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:23:00 * juhp wonders what the temperature is in Syndey :)
20:23:54 <dons> 39 C yesterday, 37 today. hottest Oct day in 150 years :}
20:24:06 <juhp> ouch
20:26:00 <juhp> dons: thanks for the snapshot :)
20:27:29 <juhp> dons: in future it might be better to use a more regular version numbering scheme for snapshots - to be more upgrade friendly :)
20:28:04 <juhp> well of course it can be epoch'ed, but better to avoid epochs :)
20:29:07 <dons> well, it is the date. and there shouldn't be too many snapshots.
20:29:23 <dons> there's already a standard release numbering system -- but this is a special circumstance
20:30:50 <juhp> dons: okay - no worries - when do you think 0.9.7 will be released? :)
20:31:09 <michael`> how do you compile haskell on GHCi again?
20:31:46 <dons> juhp: soon ... but I want to get Windows working
20:32:05 <Cale> michael`: not sure I understand your question
20:32:42 <juhp> dons: :)  maybe I'll label the rpm something like 0.9.6-1.20041014 to avoid the epoch
20:32:51 <dons> that' is fine :)
20:48:58 <michael`> hey dons
20:49:14 <michael`> im having trouble trying to use getArgs
20:49:21 <michael`> I just wanna run my program like
20:49:32 <michael`> ./program Hello
20:49:43 <michael`> and when it runs, it prints hello to the screen
20:49:46 <michael`> how may i do that?
20:49:47 <heatsink> how do you use getArgs?
20:50:03 <heatsink> how do you use getArgs, currently?
20:51:21 <michael`> i have nfi how to do it
20:51:44 <heatsink> Have you read about monads yet?
20:51:49 <michael`> yeah
20:51:58 <michael`> I have this things called interact im meant to use i think
20:52:01 <michael`> maybe thats easier :S
20:52:06 <dons> I'm so converted to ghc -M makefiles, instead -f --make
20:52:12 <michael`> i wish i knew how to just get the input?
20:52:43 <heatsink> First, can you print the constant string "hello"?
20:53:01 <michael`> yeah
20:53:06 <michael`> print "Hello" hehe
20:54:22 <heatsink> good
20:54:44 <michael`> hehe
20:54:55 <michael`> how do i get it so then when i compile and type
20:54:58 <michael`> ./program Hello
20:55:03 <michael`> It prints "Hello"
20:55:04 <michael`> :p
20:55:33 <heatsink> you have to sequence getArgs and print with "do" notation
20:55:45 <michael`> ie?
20:56:10 <heatsink> do getArgs
20:56:14 <heatsink>    print "hello"
20:56:22 <heatsink> Of course, that won't do what you want yet
20:56:43 <michael`> :S
20:57:25 <heatsink> You have to bind a variable to the result of getArgs
20:57:31 <michael`> Have u guys heard of interact?
20:57:34 <michael`> its easier isnt it?
20:57:35 <heatsink> no
20:57:40 <heatsink> I haven't heard of it
20:59:42 <heatsink> So when you learned about monads, did you learn how to store the result of a monadic operation in a variable?
21:00:20 <michael`> nup
21:01:20 <michael`> main = do x <- getArgs
21:01:24 <heatsink> right
21:01:25 <michael`> can you explain what <- means to me
21:01:58 <heatsink> basically x gets the result of getArgs
21:02:19 <michael`> what does the <- and -> mean in haskell
21:02:43 <heatsink> They mean unrelated things
21:02:53 <michael`> can you explain?
21:03:36 <heatsink> I should describe all three of these, because they all have to do with name binding: <- = and ->
21:04:15 <heatsink> a = b means that the value of a is b
21:04:42 <michael`> yep
21:04:52 <heatsink> -> is used in pattern matching
21:04:59 <michael`> ah ok
21:05:00 <michael`> yep
21:05:04 <heatsink> case x of 1 -> abcdefg
21:05:17 <heatsink> case y of [x] -> foo x
21:05:41 <heatsink> <- is used in monads
21:06:17 <heatsink> Monad instances are special cases of functions
21:07:10 <heatsink> Hmm, I gotta look this up actually
21:08:50 <michael`> ok
21:08:59 <michael`> what does this error mean
21:09:12 <michael`> parse error on input 'system'
21:09:18 <michael`> this is what i tried to compile
21:09:23 <michael`> import System
21:09:23 <michael`> main = do x <- getArgs
21:09:23 <michael`>           print x
21:09:47 <Cale> x <- xs where xs is a monadic value effectively "pulls" x out from xs -- in the case of the IO monad, this may have side effects
21:09:49 <heatsink> are you sure system is uppercase
21:10:58 <michael`> yep it is now hehe thanks :)
21:11:41 * desrt used to think <- in IO and <- in list comprehension were two different things
21:12:05 <Cale> yeah, they're effectively the same :)
21:18:34 <desrt> hm
21:18:56 * desrt plays with using 'do' in the list monad
21:20:05 <desrt> wow... do is list comprehension :)
21:20:28 <desrt> test xs = do
21:20:28 <desrt>         x <- xs
21:20:28 <desrt>         return x
21:20:33 <desrt> this does what you would expect =)
21:21:26 <desrt> ie: same as:  test xs = [ x | x <- xs ]
21:21:34 * desrt goes to bed happy
21:23:38 <michael`> if i have a file called File.hs in the same dir
21:23:43 <michael`> does import File 
21:23:45 <michael`> work?
21:23:50 <heatsink> yes
21:23:55 <michael`> it doesnt seem to be :\
21:24:27 <heatsink> are you also putting the filename on the command line when you invoke ghc?
21:24:43 <michael`> i typed
21:24:51 <michael`> ghc myfile.hs -o myfile
21:25:02 <heatsink> oh
21:25:07 <heatsink> you have to compile File.hs first
21:25:21 <michael`> aha
21:25:22 <heatsink> ghc looks for File.hi, which is produced when File.hs is compiled
21:25:22 <michael`> :)
21:25:27 <michael`> wicked :)
21:25:46 <michael`> what do i type to compile File.hs
21:25:55 <heatsink> ghc -c File.hs
21:26:58 <michael`> if i send you these files
21:27:05 <michael`> can u tell me if u have trouble importing them
21:28:18 <heatsink> what problem do you have?
21:29:16 <michael`> i get this error
21:29:28 <michael`> Symbol referencing erros
21:30:01 <heatsink> you can use http://rafb.net/paste
22:31:56 <juhp> sudo ghc-pkg -u -i /usr/lib/ghc-6.2.1/hs-plugins/altdata.conf.in
22:32:07 <juhp> Reading package info from "/usr/lib/ghc-6.2.1/hs-plugins/altdata.conf.in"done.
22:32:07 <juhp> Expanding embedded variables... done.
22:32:07 <juhp> warning: can't find GHCi lib `HSaltdata.o'
22:32:25 <juhp> how to get rid of that warning? :)
22:33:33 <dons> does "make register" work?
22:33:44 <dons> sudo make register
22:34:12 <dons> it doesn't matter as long as HSaltdata.o gets put in lib/ghc-6.2.1
22:34:40 <juhp> dons: hm, the .o files are in /usr/lib/ghc-6.2.1/hs-plugins/ too
22:34:45 <dons> (also, you don't really care about HSfoo.o, as they're only used in dyn loaded code, and you ghc-6.2.2 to dyn load hs-plugins components)
22:34:51 <juhp> with my current packaging...
22:34:59 <dons> sorry, they should be in hs-plugins/ yes.
22:35:12 <juhp> dons: ok, so maybe just remove *.o ?
22:35:24 <dons> well, you'll need them once ghc-6.2.2 comes out
22:35:32 <juhp> ah, 6.2.2
22:35:34 <juhp> ok, thanks
22:35:42 <dons> i'm checking the warning now
22:36:22 <dons> and thanks for the package.conf patch too
22:36:22 * juhp is trying hemacs....
22:36:29 <juhp> dons: :)
22:37:13 <juhp> dons: actually in my pkg I replaced ${LIBDIR} by $libdir btw in the .conf.in files
22:37:53 <dons> at the moment, just feedback on whether hemacs built properly and boots when you run ./hemacs-inplace would be helpful
22:38:05 <dons> (the editor stuff isn't written yet :)
22:38:17 * juhp wants to look at the hemacs source, but I'll have to wait for that :)
22:38:29 <juhp> dons: yep, it runs for me :)
22:38:33 <dons> fantastic!
22:38:41 <dons> and hemacs-static too?
22:38:51 <juhp> yep :)
22:38:57 <dons> great. we're in business then
22:39:03 <juhp> yay!!
22:39:18 <dons> :D
22:40:10 <dons> try copying plugins/Date.hs into ~/.hemacs/Config.hs, and ./hemacs-inplace
22:40:24 <dons> it should dynamically compile and load that module, and display the date in the title bar
22:43:09 <juhp> (I'll upload the rpm pkg to the haskell fedora repo in a moment :)
22:43:32 <juhp> dons: where can I find plugins/Date.hs ?
22:43:44 <dons> it should be in the darcs repo
22:43:55 <juhp> ok
22:43:57 <dons> maybe pull again
22:45:15 <juhp> got it
22:47:43 <juhp> dons: yep, hemacs-inplace shows the date
22:48:05 <juhp> dons: though I'm running in ja_JP.UTF-8 normally ;)
22:48:21 <dons> yikes.
22:48:29 <juhp> doesn't seem to handle ja at least :)
22:48:35 <juhp> but no big shock
22:48:46 <dons> well, try looking at stuff in system.mk to see if anything there helps
22:49:12 * dons doesn't know charset stuff too well
23:05:43 <tuomov> charset stuff is hell
23:09:04 <tuomov> hmm.. where's this post-emacs list?
23:09:35 <dons> I think we might have to wait for shapr to wake up to find out..
23:09:42 <tuomov> I need to move out of jed, because the development is practically non-existent and there's still lots to do
23:09:55 <tuomov> and I do not want to write thousands of lines of lisp to write joeish bindings etc.
23:11:04 <tuomov> so I want to make sure hemacs or whatever can be easily customised so :)
23:11:54 <dons> yes. that should probably be the main goal
23:12:28 <dons> have a minimal editor core (HShemacs.o) and everthing else is dyn loaded and scriptable
23:47:29 <musasabi> How does one generate haddock documentation from sources needing cpp?
23:48:00 <juhp> musasabi: I believe you have to preprocess them first by hand
23:59:40 <tuomov> dons: any idea why riot build complains as follows when building with ncursesw?
23:59:45 <tuomov> /tmp/ghc29605.hc:18581: warning: implicit declaration of function `waddnwstr'
