00:00:03 <heatsink> I thought gcc could support tail calls in some odd cases
00:00:16 <heatsink> It's not something I'd rely on, though
00:00:23 <SamB_XP> now, yes
00:00:43 <SamB_XP> presumably this was added at some point
00:00:51 <musasabi> Partial tail call support was new in gcc 3.x
00:01:01 <SamB_XP> musasabi: are you sure about that?
00:01:13 <dblhelix> heatsink: kosmikus came up with an alternative version of zip that's non-strict in its second argument: it allows you to write x = zip [1 .. 3] (map (succ . fst) x)
00:01:16 <musasabi> SamB_XP: I remember reading the changelog.
00:01:23 <SamB_XP> fair enough
00:01:31 <musasabi> But it is still quite dependent on luck..
00:01:50 <musasabi> So I wouldn't bet for ghc to optimize things in any given case.
00:01:56 <SamB_XP> well, what about that mangler? is that really what it is there for?
00:02:04 <heatsink> oh, cool
00:02:26 <dblhelix> heatsink: why don't you use Array to implement graphs? it's kind of standard practice
00:02:52 <SamB_XP> do not scare me with your mentioning of Array
00:03:23 <heatsink> dblhelix: It's not a mutable graph, so I shouldn't need indirection
00:04:04 <dblhelix> heatsink: anyway, if you look at it a while, it's quite easy to see why the strict behavior of zip causes the loop in x = zip [1 .. 3] (map (succ . fst) x)
00:05:03 <heatsink> Yes, it's because it checks whether the second argument is [] or not
00:05:04 <dblhelix> heatsink: zip needs to know the size of it's second argument (to check if it's zero): to know the size of it's second argument it has to know the size of x
00:05:16 <dblhelix> heatsink: indeed
00:05:44 <heatsink> Did you tell me about this before? Maybe it was someone else...
00:06:08 <musasabi> a function like zipSomething f lst = map (
00:06:23 <musasabi> sorry (accidental enter)
00:06:34 <dblhelix> heatsink: I did tell you, but my explanation was a little more involved: using the invisble least-fixed-point operator and stuff
00:06:40 <musasabi> a function like zipSomething f = map (\val -> (val, f val))
00:07:03 <heatsink> right
00:07:44 <heatsink> fixST is something like a first-class "let", which is what I was trying to achieve
00:08:26 <dblhelix> musasabi: x = map (id `split` succ) [1 .. 3]
00:08:45 <dblhelix> @index fixST
00:08:46 <lambdabot> Control.Monad.ST.Lazy,Control.Monad.ST,Control.Monad.ST.Strict,GHC.ST
00:09:03 <dblhelix> @type Control.Monad.ST.fixST
00:09:04 <lambdabot> Control.Monad.ST.fixST :: forall a s.
00:09:04 <lambdabot> 			  (a -> GHC.ST.ST s a) -> GHC.ST.ST s a
00:09:29 * dblhelix is processing ...
00:09:41 <dblhelix> ah, I see ...
00:09:48 <dblhelix> cool
00:10:07 <heatsink> @index split
00:10:07 <lambdabot> Language.Haskell.THSyntax,GHC.Exts,System.Random,Random
00:10:19 <heatsink> @type split
00:10:20 <lambdabot> bzzt
00:10:28 <dblhelix> split f g x = (f x, g x)
00:10:47 <dblhelix> split :: (a -> b) -> (a -> c) -> a -> (b, c)
00:11:15 <heatsink> ok
00:11:17 <dblhelix> split is often written as a triangle
00:11:41 <heatsink> like del?
00:11:48 <dblhelix> del?
00:11:53 <heatsink> upside down delta
00:12:08 <dblhelix> no, like a normal delta
00:12:46 <dblhelix> I'd really wish cross and split were just Prelude functions; they're quite useful
00:13:35 <dblhelix> IIRC, the papers on Arrows are full with splits :)
00:16:50 <rhw> I'm trying to read the gentle introduction to haskell tutorial, and I can't seem to be able to define the inc function there ( inc n = n + 1 ). Why's that ?
00:18:31 <heatsink> are you putting it on a line by itself in a file?
00:18:52 <rhw> Why would I ? I'm playing with Hugs in what I understand is intearactive mode.
00:19:06 <heatsink> Hugs doesn't let you do assignment
00:19:13 <rhw> Argh.
00:19:20 <heatsink> or maybe you can, but I odn't konw how
00:19:28 <heatsink> you can do the following in hugs:
00:19:43 <rhw> What's the haskell interpreter people normally use ? At least until I figure out my arse from my elbow in Haskell.
00:19:48 <heatsink> let inc n = n + 1  in inc 27
00:20:06 <heatsink> I learned haskell using ghc, actually
00:20:20 <rhw> Ah, good thing I got that too.
00:20:20 <dblhelix> rhw: Hugs if fine as most tutorials that are around assume you are running it
00:20:20 <heatsink> the compiler
00:20:39 <rhw> Alright, what's with "in inc 27" ? What's with the magic number there ?
00:20:54 <heatsink> you can use any other number
00:21:47 <rhw> Would you recommend another tutorial than "Gentle introduction to Haskell" for an advanced C++ programmer ?
00:22:14 <rhw> God dammit, Python took me a couple of hours :p
00:22:19 <heatsink> Unfortunately, there aren't a lot of easy online tutorials for haskell
00:22:29 <heatsink> it's slow going until you get used to it
00:22:36 <dblhelix> rhw: no, I think it's quite good; however I would recommend to forget all you know about C++ for a while
00:24:01 <heatsink> What's with this weird minus sign syntax?
00:24:11 <heatsink> (+1) 4 === 5
00:24:20 <heatsink> (-1) 4 =/= 3
00:24:45 <dblhelix> heatsink: (-1) is not a section; it's reserved for negation
00:24:46 <rhw> Hm, GHC seems to let me declare inc n = n+1 as long as I add a "let" when declaring it.
00:25:00 <dblhelix> heatsink: it's a special case mentioned in the report
00:25:08 <heatsink> okay
00:25:25 <heatsink> ghc?
00:25:32 <heatsink> ghc should let you declare it without the let
00:25:52 <dblhelix> heatsink, rhw: rhw means ghci
00:26:05 <heatsink> oh
00:26:11 <rhw> Yeah.
00:26:20 <heatsink> that's good then
00:26:24 <heatsink> I didn't know that
00:27:14 <dblhelix> heatsink, rhw: actually the declared variable is now available as 'it'; try ":t it"
00:27:38 <dblhelix> heatsink, rhw: it should give "(Num a) => a -> a" or something ;)
00:28:03 <rhw> Prelude> :t it
00:28:03 <rhw> it :: Integer
00:28:19 <heatsink> :t them
00:28:24 <heatsink> Variable not in scope: `them'
00:28:27 <heatsink> oh well...
00:28:58 <dblhelix> rhw: it is the last expression you evaluated; so I guess you 'tested' your inc function somehow ;)
00:29:05 <rhw> ah :)
00:29:07 <rhw> Yeah =)
00:29:29 <dblhelix> no crystal ball there :)
00:29:47 <heatsink> interesting -- it won't be bound if the expression isn't a Show
00:30:40 <dblhelix> and---yes!---I won the lottery ... again ... actually, for the third time this week ... don't you love spam?
00:31:57 <rhw> lol :)
00:32:58 <rhw> rofl, me too. I just received it
00:44:55 <heatsink> Is there a way to get the type of something :: Dynamic?
00:46:43 <dons> typeOf 
00:47:06 <heatsink> typeOf (a :: Dynamic) === Dynamic
00:47:18 <heatsink> I was hoping to figure out the type contained in a
00:49:41 <dons> write a typecase function that switches on the TypeRep of the dynamic
00:50:14 <dons> because that is the only type you have to work with, the TypeRep
00:50:48 <heatsink> how do I get the TypeRep?
00:51:21 <dons> case (Dynamic rep val) of ...
00:51:35 <dons> you'll have to hack Data.Dynamic though :(
00:51:51 <heatsink> hmm
00:52:05 <heatsink> Maybe I'll think about other ways to do what I want
00:52:09 <dons> (there's a simple typecase in hs-plugins AltData.Dynamic module)
00:52:59 <heatsink> I seem to not have that
00:53:27 <dons> nono. you'd have to grab it off the net. but it is just a hack.
00:54:15 <dons> once you wrap it up in a Dynamic, you lose easy access to the type (otherwise it would be easy for users to break the dynamics)
00:54:26 <heatsink> okay
00:55:30 <heatsink> I'll give it some thought; I probably should do it another way.
00:56:11 <heatsink> I'm writing an interpreter for a dynamically typed language, which means I need to emulate the dynamicness somehow...
00:57:12 <bbls> heatsink i have a different approach
00:57:19 <bbls> heatsink i consider types as sets
00:57:44 <bbls> heatsink so all i have to do is manipulate those sets
00:57:58 <bbls> heatsink (in order to infer types, etc)
00:58:27 <bbls> so all dynamic stuff turns into static stuff
00:58:30 <heatsink> sets of what?
00:58:40 <bbls> theoretical sets
00:58:43 <bbls> sets of values
00:59:09 <bbls> functions are sets too
00:59:14 <bbls> (sets of tuples)
01:00:14 <bbls> so a function call turns into a set operation
01:00:52 <bbls> the basis of the language is a query returning a set with elements matching given conditions
01:01:01 <bbls> such: all x in Real with x<>0;
01:01:04 <rhw> I wonder why this tutorial uses polymorphism where template would be more appropiate.
01:01:22 <heatsink> I can't very well create a set for a function... such as (+)
01:02:06 <bbls> well, you have to support both finite and infinite sets for doing that
01:02:37 <bbls> also + operation (on CPU integer values) is different from theoretical (algebraic) + operating on symbolic numbers
01:04:08 <heatsink> So how do I create generic code to convert from a set to a haskell datatype?
01:05:13 <bbls> you don't :)
01:05:25 <bbls> it can't be converted into haskell code
01:05:31 <heatsink> Okay
01:05:37 <heatsink> My interpreter needs to do that, though
01:06:15 <bbls> i tought you work on a different language
01:06:33 <rhw> data Point a = Pt a a -- why doesn't this work on ghci ?
01:06:41 <bbls> or you want to use haskell for back-end
01:06:48 <bbls> ?
01:07:09 <heatsink> I'm interpreting data files
01:07:24 <heatsink> the data goes through some evaluation
01:07:42 <heatsink> then I have the data structure that my haskell backend will operate on
01:08:12 <bbls> well then forget everything i said :)
01:08:37 <bbls> it's much more complicated since it can't be easly converted into haskell
01:08:50 <heatsink> okay...
01:08:58 <bbls> synce it requires an symbolic algebra engine
01:09:05 <heatsink> sounds tricky
01:09:09 <bbls> plus theoretical sets engine
01:09:27 <bbls> yes, it sounds tricky but in the end the advantages will be huge
01:09:36 <heatsink> the infinity that can be finitely expressed is not the true infinity
01:09:47 <bbls> yes
01:09:56 <bbls> also is not turing-complete :)
01:10:03 <heatsink> true
01:10:16 <bbls> but i do work on it
01:10:24 <bbls> due to the potential for
01:10:28 <heatsink> Are you a mathematician?
01:10:39 <bbls> formal verification
01:10:43 <bbls> no i am not
01:10:56 <heatsink> If you work on formal verification, I'd consider you a mathematician :)
01:11:02 <bbls> i just want to create a language
01:11:09 <bbls> that will facilitate formal verification
01:11:49 <bbls> in the end i want a safe language (and it seems that formal verification is the onl solution)
01:12:03 <bbls> so i have to do it :)
01:12:25 <bbls> (even if it will result into a non-turing-complete language)
01:14:34 <heatsink> How do you specify the properties of the program to prove?
01:14:46 <bbls> i don't
01:14:55 <bbls> (but they can be added as assertions)
01:14:59 <bbls> what i mean
01:15:05 <heatsink> the prover guesses what the program should do??
01:15:20 <bbls> the compiler has to prove that for a certain
01:15:26 <bbls> I/O model of the main function
01:15:42 <bbls> the program won't result into exceptions
01:15:46 <bbls> or loop indefinitivelly
01:15:59 <heatsink> you know that's impossible
01:16:18 <bbls> yes, on the general case
01:16:38 <bbls> but not on a sufficiently large number of particular cases :)
01:16:57 <bbls> if the compiler has a large enough databases of particular cases
01:17:07 <heatsink> then we won't need programmers!!
01:17:07 <bbls> then it will be able to verify complex enough cases
01:17:11 <heatsink> @yow
01:17:11 <lambdabot> I HAVE a towel.
01:17:13 <bbls> to write useful programs
01:17:17 <heatsink> :)
01:17:27 <bbls> heatsink we still need them to write the applications :)
01:19:11 <bbls> heatsink what this would do is to ensure that no bogus programs will be compiled
01:19:11 <bbls> but programs still have to be written
01:19:40 <heatsink> yea
01:20:05 <heatsink> I like the assertion model; it seems more useful to me
01:20:22 <bbls> well depends whenever you want to check the assertions
01:20:27 <bbls> at run-time or compile time
01:20:36 <heatsink> I thought compile-time
01:20:40 <bbls> i have to prove all of them at compile time
01:21:00 <bbls> well
01:21:08 <bbls> i mean something like an assertion:
01:21:48 <bbls> let's suppose we code something for a car's computer
01:21:48 <bbls> then we have
01:21:57 <bbls> function car_adjust_speed(parameter1, parameter2)
01:22:04 <bbls> then we would have an assertion
01:22:27 <bbls> assert result-of-car_adjust_speed < 120miles/h
01:22:37 <bbls> to protect us against code that would make the car run wild
01:22:56 <bbls> do you get the ideea of what i mean by assertion?
01:23:04 <heatsink> yes
01:23:29 <bbls> but this problem is equivalent with the formal verification of the code
01:23:49 <bbls> (since all exception and termination related problems could be converted into assertions)
01:23:56 <rhw> data Point a = Pt a a -- why doesn't this work on ghci ?
01:24:09 <heatsink> rhw: It looks okay to me
01:24:18 <heatsink> rhw: try compiling with ghc
01:24:36 <bbls> heatsink so proving a general assertion at compile-time is equivalent with complete formal verification of the source code
01:25:21 <dblhelix> rhw: you can't declare new data types in ghci
01:25:32 <rhw> ah
01:25:44 <dblhelix> rhw: i.e., not directly
01:25:47 <heatsink> You can get an answer for each assertion
01:25:59 <rhw> This is weird. I'd like to be able to test things interactively, rather than compile.
01:26:00 <heatsink> That's better than getting an answer for the whole program
01:26:07 <rhw> While I'm learning.
01:26:11 <dblhelix> rhw: why don't your put your code in a source file
01:26:11 <bbls> heatsink they are equivalent
01:26:35 <dblhelix> rhw: you don't need to compile
01:27:07 <dblhelix> just make a file Foo.hs that contains "module Foo where" and put your code below it
01:27:18 <dblhelix> then: use :m + Foo from ghci
01:27:40 <rhw> In the same folder as ghci ?
01:28:05 <dblhelix> or in the same one as from which you start ghci
01:28:16 <dblhelix> which is off course cleaner ;)
01:30:39 <dblhelix> /s/off/of
01:34:01 <rhw> Prelude> :m + Foo
01:34:01 <rhw> Failed to load interface for `Foo':
01:34:01 <rhw> Bad interface file: ./Foo.hi
01:34:01 <rhw> ./Foo.hi: openBinaryFile: does not exist (No such file or directory)
01:34:24 <rhw> .hi ? Wasn't it supposed to be .hs ?
01:34:45 <dblhelix> I'm sorry: try :l Foo
01:35:04 <rhw> alright =)
01:35:45 <dblhelix> when you make changes to Foo.hs you can easily reload the file by issueing: ":r"
01:46:52 <shapr> good morning #haskell!
01:47:49 <dblhelix> morning shapr
01:48:46 <shapr> y0 dblhelix 
01:49:46 <cptchaos> good morning
01:49:56 <shapr> y0 cptchaos 
02:00:33 <musasabi> hmm MVars seem to have very weird behaviour..
02:01:28 <shapr> how so?
02:01:31 <musasabi> http://youzen.b2.fi/~musasabi/mvar.hs 
02:01:46 <musasabi> try running that and time with various values 
02:02:16 <musasabi> time ./a.out 33 => 0.0 seconds, time ./a.out 34 0.7 seconds
02:02:50 <musasabi> performance seem to go down in a very jumpy manner...
02:03:29 <musasabi> ghc 6.2.1 from debian with -O2
02:04:14 <shapr> that is strange
02:04:29 <musasabi> can you reproduce it?
02:04:50 <shapr> yup
02:04:53 <shapr> exactly
02:04:54 <rhw> Wow, I figured out how quicksort works.
02:04:55 <rhw> *g*
02:05:04 <shapr> spiffy
02:05:41 <shapr> musasabi: the threshhold numbers for me are the same, though the times are different, so I suspect it has to do with GC or something
02:07:19 <andersca> @arr
02:07:19 <lambdabot> Shiver me timbers!
02:07:22 <andersca> how does quicksort work?
02:07:39 <musasabi> With the cvs snapshot it is between 38 and 39. (debian one)
02:12:29 <musasabi> Profiling says it spends 100% of time and 99% of alloc in the loop. (that is loop v = readMVar v >> loop v)
02:12:39 <musasabi> Now why is that?
02:12:58 <musasabi> Shouldn't it be blocked on the MVar?
02:13:21 <musasabi> Or is the issue that the main thread uses up it's timeslice and all the other threads get to run?
02:13:45 <musasabi> But that shouldn't take that long even if that was the case.
02:37:26 <musasabi> The problem was trivial, I was using readMVar not takeMVar..
02:54:34 <shapr> ah
02:58:39 <shapr> anyone using the wxHaskell debs from haskell-unsafe?
03:00:33 <shapr> I'm getting "ldconfig: Can't link /usr/lib//usr/lib/libwxc-gtk2.4.2-0.8.so to libwxc-gtk2.4.2-0.8.so"
03:01:00 <shapr> gutentag flori 
03:01:50 <shapr> where are the ldconfig entries managed in Debian?
03:01:55 * shapr used to know this
03:02:10 <jao> /etc/ld.so.conf
03:02:26 <jao>  /etc/ld.so.conf
03:02:32 <shapr> ah, thanks
03:02:46 <jao> np :)
03:03:00 <shapr> hm, that doesn't list anything about libwxc
03:03:20 <jao> it only contains dirs
03:03:37 <shapr> I wonder where the /usr/lib stuff is double
03:03:52 <jao> double?
03:04:10 <shapr> - /usr/lib//usr/lib/libwxc-gtk2.4.2-0.8.so
03:04:58 <jao> is that output from ldconfig?
03:05:13 <shapr> yup
03:06:18 <jao> here, ldconfig output looks like
03:06:23 <jao> /usr/lib/i486: (hwcap: 0x2000000000000)
03:06:23 <jao>         libssl.so.0.9.7 -> libssl.so.0.9.7
03:06:26 <jao> etc.
03:07:03 <shapr> when I run ldconfig by itself it gives that error
03:07:28 <jao> ah, i see now
03:07:45 <jao> (hadn't read yuor previous comment)
03:08:52 <shapr> aha
03:08:53 <shapr> I found it
03:09:20 <jao> oh?
03:09:32 <shapr> the shlibs file had an extra /usr/lib in it
03:09:44 <shapr> not sure where the shlibs is being installed though...
03:09:44 <jao> aha
03:10:36 <shapr> as in, editing libghc6-wxhaskell0.8.shlibs and removing the extra /usr/lib didn't change ldconfig
03:11:08 <jao> mine are all in /var/lib/dpkg/info
03:12:15 <shapr> if I use --reinstall it unpacks the deb again
03:15:01 * shapr tries a manual update
03:18:28 * shapr hopes this works
03:18:36 <shapr> :-(
03:19:12 <shapr> oh, hm
03:19:39 <shapr> is there a test script that comes with the wxHaskell debs?
03:33:40 <shapr> yay, wxHaskell happiness!
03:33:42 * shapr bounces cheerfully
03:33:54 <shapr> still no source package in haskell-unsafe though
03:36:56 <shapr> anyone know of more projects like gnomoradio and irate?
03:50:17 <keverets> shapr: http://konspire.sourceforge.net/
03:50:59 <shapr> ah, thanks
04:06:16 <bbls> keverets ?
04:06:18 <bbls> still here?
04:15:03 * shapr stabs Java with a hammer
04:15:40 <andersca> I like java
04:15:41 <Maddas> Isn't a hammer a rather blunt thing to stab with? :-)
04:16:06 <shapr> Maddas: that's the idea.
04:16:27 <shapr> stabbing Java with something like a knife would be far too kind.
04:17:24 <shapr> andersca: in reality, bad programmers can write ugly code in any language, and that's what I'm really complaining about.
04:17:42 <shapr> this code isn't really that bad as Java goes
04:18:00 <shapr> but trying to find where all the side effect stuff does stuff is not fun
04:18:35 <andersca> shapr: jag gillar http://thedailywtf.com/archive/2004/09/23/2012.aspx
04:21:27 <wkornew> hi, anyone here who knows the GHC source? I have to emulate SA_RESETHAND and want to make sure that it is done right
04:22:35 <shapr> with a host like 'thedailywtf.com', I think I'm going to like this
04:23:00 <wkornew> hi shapr
04:23:03 <shapr> y0 wkornew 
04:23:10 <shapr> what does SA_RESETHAND do?
04:23:55 <wkornew> I think it preserves the sigmask from changing
04:24:14 <wkornew> I saw some source on the net to emulate it, but am not too sure about whether I can just use it
04:27:18 <shapr> andersca: this reminds me of the Java code at my last job, *everything* was static because no one understood what instances do, and the GUI class called the utility class, which called the database class, and the database directly set the GUI field values
04:27:55 <andersca> haha
04:28:47 * shapr googles for SA_RESETHAND
04:29:57 <shapr> wkornew: man sigprocmask says "SA_ONESHOT or SA_RESETHAND - Restore the signal action to the default state once the signal handler has been called."
04:30:13 <shapr> does that help?
04:30:34 <wkornew> shapr, yes thank you, I was on #posix and someone gave me a detailed explanation
04:30:44 <wkornew> (I also found some example code)
04:31:30 <shapr> spiffy
04:54:27 <shapr> g'day saz, ltns
04:54:33 <saz> hi
04:54:36 <mento> hi
04:54:48 <shapr> hej mento 
04:55:54 <mento> I'm new to FP and I'm wondering how I can store a an Int value in a recursive function so that is the same troughout the recursion. 
04:56:09 <saz> you don't store it
04:56:12 <saz> you pass it through
04:56:17 <kristnjov> yeah..
04:56:23 <kristnjov> simply as an Int argument
04:56:27 <mento> so I'll have to pass it trough every time
04:56:32 <kristnjov> yes
04:56:35 <Igloo> You can say
04:56:41 <Igloo> foo x y = bar x
04:56:47 <kristnjov> or you could do a function which simply returns the integer :P
04:56:53 <mento> eya
04:56:55 <kristnjov> myInteger = 5
04:56:56 <Igloo>   where bar z = bar (z+y)
04:56:59 <mento> that's a good idea
04:57:08 <mento> thx guys, cya :)
04:57:48 <keverets> bbls: yes?
04:57:55 <mento> sure
04:58:54 <shapr> mento: learning FP at chalmers?
05:00:06 <mento> yes
05:00:26 <mento> u too ?
05:00:40 <shapr> no, though maybe one day.
05:01:04 <shapr> lots of chalmerites on #haskell and #haskell.se
05:01:04 <mento> How did you learn yours FP?
05:01:21 <shapr> I got some books and read them, wrote some code, talked to people.
05:01:42 <shapr> lots of helpful people here
05:02:20 <mento> yea, I noticed. you're learning with eager, that's good :) Nice that there are some ppl from school here too.
05:02:57 <shapr> next I want to get paid to write Haskell, that would be cool.
05:03:31 <mento> then you gotta love it. cool.
05:04:47 <shapr> Haskell is definitely my favorite programming language.
05:05:12 <mento> I find it very interesting too
05:05:38 <andersca> mento: feel free to join #haskell.se
05:05:44 <mento> allright
05:08:13 <shapr> if I specifically want \r\n that's what usually looks like ^M in emacs, right?
05:08:53 <Igloo> ^M<newline>, yes
05:09:04 <shapr> ok
05:16:28 <Lunar^> shapr: http://www.cse.ogi.edu/~hallgren/House/ !
05:16:40 <shapr> why would telnet work when connecting to a port, but netcat won't?
05:17:00 <shapr> Lunar^: awesome!
05:17:18 <shapr> Lunar^: you're famous!
05:17:31 <shapr> that is so sexy =)
05:17:45 <Lunar^> :)
05:17:57 <shapr> "There is no disk driver. There is no file system. There is no support for dynamically loading applications."
05:17:58 * shapr grins
05:18:12 <Lunar^> They added video !!!
05:18:17 <shapr> yay!
05:18:21 <Maddas> Cool
05:18:28 <Lunar^> And separate executable
05:18:59 <shapr> linear frame buffer support
05:19:00 * Lunar^ emits little high-pitched squeeked sounds
05:19:03 * shapr laughs
05:19:17 <shapr> oh, binaries have their own address space now
05:19:34 * kristnjov chuckles
05:19:57 <shapr> hOppix is so much closer now
05:20:23 <Maddas> Heh!
05:20:41 <musasabi> seems nice ^_^
05:21:07 <shapr> hm, where's the source?
05:21:11 <shapr> I want to hack on this!
05:21:56 <shapr> I've heard of Gadgets, but haven't read about it.
05:22:13 <Philippa> shapr: check your PMs
05:22:47 <shapr> oh, HaskellM ?
05:25:47 <shapr> Lunar^: you know where House source is?
05:28:50 <Lunar^> shapr: No :(
05:29:20 <Lunar^> shapr: But they've asked if we were interested in sharing our works
05:30:14 <shapr> I hope you said yes =)
05:30:31 <Lunar^> sebc just sond me a mail with this
05:30:34 <Lunar^> send
05:31:13 <shapr> spiffy
05:31:36 <shapr> any idea if they're planning on upgrading the scheduler as per your suggestions?
05:32:24 <shapr> whoa
05:32:32 <shapr> http://www.cse.ogi.edu/~hallgren/untested/InternetLib-030805-src.tar.gz
05:32:41 <XTL> That's something...
05:40:27 <shapr> InternetLib: ftp, nntp, pop, mime, http, html, gif, pnm, rtf
05:40:49 <shapr> I can't tell if it requires fudgets or not
05:42:23 <Maddas> Well, in the InternetLib.doc, the first line of the sample program is "import Fudgets".. :-
05:42:23 <Maddas> )
05:42:33 <Maddas> Oh, hm
05:42:58 <shapr> the files that end in F seem to require Fudgets
05:46:13 * shapr tries to install fudgets
05:46:52 <shapr> anyone installed Fudgets?
05:52:17 <shapr> erg, what happened to openBinaryFile?
05:52:28 * shapr should remember this
05:59:31 <musasabi> System.IO ?
06:00:10 <shapr> was a totally different problem ... :-/
06:07:26 <shapr> seems the Fudgets Makefile doesn't want to create a package.conf for GHC
06:20:08 * shapr fixes
06:30:49 <kristnjov> "Write a function that, given a string, returns the string with all lower-case characters replaced by the corresponding upper-case characters."
06:31:00 <kristnjov> Hint: Use map :: (a -> b) -> [a] -> [b] and toLower :: Char -> Char.
06:31:09 <kristnjov> i wrote "map toUpper"
06:31:22 <kristnjov> and it was falsifiable when the string was "H"
06:32:28 <kristnjov> any ideas?
06:33:37 <Igloo> toLower /= toUpper
06:34:12 <shapr> offtopic geek humor: http://wildspark.com/eurionize/
06:34:20 <hram> I think the question is phrased by a tired nad, he means the opposite, map toLower.
06:34:46 <shapr> what's a nad?
06:35:22 <hram> nad is a person.
06:35:24 <shapr> oh
06:36:26 <kristnjov> hram, yeah that's what i thought
06:36:59 <Igloo> shapr: Why is that humour?
06:37:59 <shapr> Igloo: for x in locate .ps; do eurionize < $i > $i; done
06:40:37 <shapr> weird, profiling Fudgets seems to build a different set of files
06:44:31 <kristnjov> $calc(1+4+9)
06:44:33 <kristnjov> oops
06:44:46 <shapr> @eval 1 + 4 + 9
06:44:46 <lambdabot> 14
06:45:14 <kristnjov> thanks a lot man, rough times here.
06:49:41 <Lemmih_> o_O
06:50:47 <kristnjov> YES
06:50:48 <kristnjov> i rule
06:51:28 <shapr> parsing rule?
06:51:38 <kristnjov> function composition.
06:51:49 <kristnjov> and lambda expressions
06:52:49 * Lemmih_ is missing an in-memory relational database.
06:53:42 * mikael too
06:54:45 <Lemmih_> mikael: You're phubuh, right?
06:54:50 <mikael> oh, whoops
06:55:12 <kristnjov> FuBu! :I~
06:55:18 <kristnjov> tardwear for us by us
06:56:48 <Lemmih_> phubuh: You might be interested in my Direct Connect library.
06:56:51 <phubuh> ooh!
06:58:21 <wkornew> hi, I am porting GHC and the mangler cannot produce Apply.s. it spits some assembler out and returns an error, can you help me please?
07:00:11 <shapr> what's the error?
07:00:20 * shapr cheers GHC porters
07:00:33 <wkornew> the last line ends with:
07:00:35 <wkornew>         addl $_GLOBAL_OFFSET_TABLE_+[.-.L175],%ebx
07:00:46 <shapr> but what the error?
07:00:46 <wkornew> oh, and now it says: /APP
07:00:51 <Igloo> Are you trying to do a registerised or unregisterised port?
07:00:55 <wkornew> registered
07:01:05 <wkornew> it's an intel machine, at least
07:01:06 <shapr> you probably want start with unreg
07:01:16 <shapr> slower, but easier
07:01:30 <shapr> not that I know from personal experience, just what I've read
07:01:30 <wkornew> will it work then?
07:01:41 <shapr> I think an unreg build will run darcs
07:01:48 <wkornew> but very slowly
07:01:51 <wkornew> that is not usable
07:02:05 <shapr> ok
07:02:19 <Igloo> It's only about a factor of 2
07:02:31 <shapr> in that case, you may want to do an unreg build first, and a registered next
07:02:38 <Igloo> The first step is to do an unreg port regardless, then fix the mangler etc afterwards
07:02:40 <shapr> then you get to separate your problems
07:02:58 <wkornew> why can I not make a registered build now? the mangler seems to not like the codfe
07:03:05 <shapr> Igloo: would/will this be easier when C-- is ready for primetime?
07:03:25 <Igloo> Not as far as I know
07:03:26 <wkornew> how can I fix the mangler?
07:03:41 <wkornew> what are the issues when porting to another OS but having the same processor
07:04:15 <wkornew> did you port GHC to a different OS? I would like to know what I have to do
07:04:57 <shapr> I think pesco got GHC running on PPC/Linux, and dons worked on x86_64 and some others
07:05:19 <shapr> I don't think John Goerzen is here, he's just gotten an AIX port working.
07:05:30 <wkornew> these are even totally different architectures...
07:05:47 <shapr> I haven't done anything like that myself.
07:05:48 <wkornew> what about people who ported it from linux to freebsd or the other way around?
07:06:01 <shapr> I think dons has done *bsd porting of some flavor.
07:06:18 <wkornew> dons, are you here? I need you :))
07:06:58 <saz> openbsd, no?
07:07:34 <wkornew> openbsd <= dons?
07:08:35 <saz> yes
07:09:27 <wkornew> when is he normally here?
07:09:33 <wkornew> (which time?)
07:09:52 <saz> hm, not sure, i haven't been on this channel in a while
07:10:06 <saz> (he's in .au)
07:10:23 <wkornew> oh, that is my timezone
07:10:29 <saz> where are you?
07:10:35 <wkornew> Germany
07:10:58 <saz> um, how is that in your timezone then?
07:11:09 <saz> (sure he keeps odd hours, but.. :P )
07:11:10 <Igloo> I think you are confusing it with .at
07:11:38 <wkornew> oh, :) what is au then?
07:11:42 <saz> australia
07:11:47 <Igloo> Australia, as opposed to Austria
07:11:48 <wkornew> argh! :)))
07:11:53 <saz> hehe
07:12:05 <wkornew> that's on the other side of the planet ;)
07:12:11 <saz> no it's not!
07:12:12 <wkornew> well, I think I found the error
07:12:23 <wkornew> nearly ;)
07:14:11 <saz> heh
07:41:41 <mento> Do you know of any debugger for Windows with stepping trough ?
07:42:54 <mento> found somthn @ http://www.haskell.org/libraries/#tracing thx
09:10:02 <wkornew> pesco, could you please help me with a port of GHC?
09:14:50 <desrt> wkornew; where are you porting?
09:15:16 <wkornew> to BeOS, intel
09:15:19 <wkornew> hi
09:15:33 <desrt> what executable format is that?
09:15:37 <wkornew> elf
09:16:08 <wkornew> I get the following screen:
09:16:16 <wkornew> ===fptools== Recursively making `all' for ways:   ... 
09:16:19 <wkornew> ...
09:16:30 <wkornew>  /bin/sh: -c: line 1: syntax error near unexpected token `;'
09:16:40 <wkornew>  /bin/sh: -c: line 1: `case '--no-print-directory -r' in *-[ik]*) x_on_err=0;; *-r*[ik]*) x_on_err=0;; *) x_on_err=1;; esac;  for i in   ; do  echo "------------------------------------------------------------------------";  echo "==fptools== /bin/make way=$i all;";  echo "PWD = /Data/Development/Stuff/ghc-6.2.1/ghc/rts";  echo "------------------------------------------------------------------------";  /bin/make way=$i
09:16:41 <wkornew>  --no-print-directory --no-print-directory -r all ;  if [ $? -eq 0 ] ; then true; else exit $x_on_err; fi;  done'
09:17:17 <wkornew> as you can see it reads: for i in     ;  (for in what?), for example
09:17:17 <desrt> looks like the build is using syntax that the beos sh can't grok?
09:17:39 <wkornew> I do not like the build system
09:17:49 <wkornew> it has bugged me all the way
09:17:49 <Igloo> No, I think it's failed to find something
09:17:59 <wkornew> can I not do it manually?
09:18:42 <Igloo> Of course you can. I think you'll find it even less fun, though
09:19:03 <desrt> is there a ghc on beos at all yet?
09:19:10 <wkornew> no, that is the problem :)
09:19:20 <desrt> are you trying to bootstrap with .hc?
09:19:32 <wkornew> yes
09:19:39 <wkornew> I took hc files from Linux
09:19:48 <wkornew> they are no problem, they compile fine
09:20:06 <wkornew> but now it wants to compile "Ways" and the script fails
09:20:40 <wkornew> where is "ways"? do I need it?
09:21:04 <desrt> for i in   ; do 
09:21:13 <desrt> you should look in the makefile for 'for i in $'
09:21:25 <desrt> and $ will be the start of some variable substitution that is empty for soem reason
09:21:57 <wkornew> for i in $(WAYS) 
09:22:04 <desrt> so find WAYS =
09:22:45 <Igloo> Oh, actually, my shell likes "for i in ; do echo $i; done", so if that is the problem it probably is an incompatible shell issue
09:23:15 <wkornew> package.mk:WAYS = $(GhcLibWays)
09:23:20 <wkornew> (next round ;)
09:23:20 <Igloo> WAYS can reasonably be empty, I think, although I thought it had p in it by default
09:23:58 <wkornew> Igloo, my shell does not like it :(
09:24:23 <wkornew> can I just remove it? :)
09:24:34 <Igloo> Try "GhcLibWays=p" in mk/build.mk, but if you're still booting from hc files it'll probably fail trying to do way p
09:24:45 <desrt> just remove the loop :)
09:24:47 <Igloo> Oh, yeah, removing it ought to work too
09:25:30 <wkornew> what part may I remove safely? just the whole ways compilation?
09:29:23 <wkornew> huh, $(WAYS) is " " (space), how can that be?
09:34:22 <lmbdwar> hey
09:35:00 <lmbdwar> is there something better than graph derivation for modeling nested control structures correctly ?
09:35:49 <monochrom> You can try recursion.
09:36:01 <monochrom> mutual recursion, even.
09:36:51 <monochrom> http://www.cs.toronto.edu/~hehner/aPToP/ section 5.2
09:43:23 <lmbdwar> monochrom, 5.2 you are sure ? isnt it 5.7 or something else ?
09:55:47 <mento> Anyone have an idea how to extract an element from this list containing only this one element? [Char] -> Char
09:58:09 <Lemmih_> f [c] = c?
09:58:14 <mento> yea
09:58:41 <mento> list containing only one character. I need it for elemIndicates function
09:58:59 <mento> elemIndices
10:00:20 <mento> damn it
10:00:22 <mento> it's head
10:00:31 <mento> head [a]
10:12:47 <desrt> well... head a
10:16:26 <desrt> random rant: zipWith has an ugly name
10:16:54 <Maddas> Why?
10:17:01 <mento> are there static variables in haskell ?
10:19:07 <shapr> there aren't any variables in Haskell.
10:19:19 <shapr> single-assignment constants with shadowing.
10:20:13 <shapr> desrt: actually, With and By are two standard suffixes, groupBy, maxBy, zipWith
10:20:37 * shapr wonders if with and by could be combinators
10:20:46 <shapr> group `by` 
10:21:00 <kristnjov> `group `By``
10:21:08 <shapr> sk````
10:21:28 * shapr considers an unlambda lambdabot plugin
10:21:48 <shapr> http://www.eleves.ens.fr:8080/home/madore/programs/unlambda/
10:22:22 <shapr> fib in Unlambda --> ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
10:22:35 <desrt> shapr; i want a new sortBy-ish thing
10:22:44 <shapr> like what?
10:22:54 <Philippa> shapr: PMs re Flippi
10:22:58 <desrt> niceSort :: Ord b => (a->b) -> [a] -> [a]
10:23:41 <shapr> @type sort
10:23:42 <lambdabot> bzzt
10:23:46 <shapr> @index sort
10:23:46 <lambdabot> Data.List,List
10:23:51 <shapr> @type Data.List.sort
10:23:52 <lambdabot> Data.List.sort :: forall a. (Ord a) => [a] -> [a]
10:23:58 <shapr> @type Data.List.sortBy
10:23:59 <lambdabot> Data.List.sortBy :: forall a. (a -> a -> Ordering) -> [a] -> [a]
10:24:15 <shapr> desrt: I don't understand
10:24:24 <desrt> for example
10:24:37 <desrt> niceSort fst [(1,2),(3,4),(5,6)]
10:24:52 <TheHunter> sortNice p = sortBy (\x y -> compare (p x) (p y))
10:25:02 <desrt> yes.
10:25:18 <TheHunter> it's a shame that this isn't in the libs
10:25:20 <desrt> except i think that that implimentation is probably slower than it needs to be
10:25:51 <TheHunter> i wouldn't care about that too much if i'm using lists anyway
10:26:40 <desrt> intuatively, i thought that this is what sortBy would do
10:26:54 <desrt> (and sortWith would be the proper name for what is currently called sortBy)
10:27:24 <TheHunter> btw the galois presentation from ICFP (link on LtU) is really cool.
10:32:15 <shapr> Lunar^: y0, can I link to House on lambda-the-ultimate.org ?
10:54:48 <wkornew> is any GHC guy here? could you please commit my (incomplete) BeOS port? you can find the source of the changed files here:
10:54:54 <wkornew> http://zeus.mpg.goe.net/~tuvok/ghc-6.2.1-beos-src.zip
10:55:13 <wkornew> (should I post this to the ML when I am in Windows again or is it okay as it is?)
10:55:28 <shapr> does it work?
10:56:02 <shapr> you should definitely post to the mailing list
10:56:42 <wkornew> those files just were not ported to BeOS, yet, but the rest is not working, and the configure scripts must be adapted, too
10:57:20 <wkornew> but even when trying to build a unregistered port, it does not work! the same errors (could not build Arrow.o, needed by libHSbase.a)
10:58:01 <wkornew> I think darcs should use a more "portable" language ;)
10:58:18 <shapr> Haskell is portable :-)
10:58:23 <wkornew> or GHC should change its build system completely
10:58:24 <shapr> just like gcc is portable
10:58:41 <shapr> but it's no small task to port either of them.
10:58:53 <shapr> if I had a BeOS box, I'd try it
10:58:57 <shapr> but...
10:59:06 <wkornew> you can easily install BeOS on your box
10:59:07 <wkornew> ;)
10:59:25 <shapr> is BeOS open source?
10:59:37 <wkornew> my main difficulties are not the source, but the makefiles and configure scripts
10:59:43 <wkornew> there is a freeware edition
10:59:45 <wkornew> which OS do you use?
10:59:48 <shapr> I use Linux
10:59:52 <shapr> I'm an open source fanatic.
10:59:54 <bbls> shapr you can get a free version
11:00:04 <shapr> is it open source?
11:00:06 <wkornew> there is a Linux version, too, but you need a FAT partition
11:00:07 <phubuh> nope
11:00:07 <shapr> or just free?
11:00:12 <wkornew> just free
11:00:16 <bbls> shapr also there exists a project that rewrites BeOS (it's called Haiku)
11:00:24 <bbls> haiku is open source
11:00:30 <wkornew> yes, I'm one of those guys ;)
11:00:46 <shapr> As a programmer, I'd rather not use any closed source programs.
11:01:03 <wkornew> porting would be much easier if Haiku were finished, so I could add needed functions directly
11:01:40 <wkornew> even Perl does not want to compile, that's frustrating!
11:01:47 <shapr> sounds like Irix
11:01:57 <shapr> I was Irix 5.3 admin for a few months.
11:02:04 <wkornew> (well, there is a 5.8 Perl, but not 5.8.5)
11:03:15 <shapr> I think programmers using closed source programs is like mechanics not being allowed to work on their own cars.
11:03:40 <shapr> obviously, that doesn't stretch to everything ...
11:03:45 <wkornew> I need help from the ghc devs, or better: someone should finish what I began
11:04:03 <shapr> well, if you continue to ask questions on ghc-users, you will continue to get answers.
11:04:06 <wkornew> shapr, yes, that's one reason for my frustration
11:04:17 <wkornew> I do not know which questions to ask :)
11:04:23 <wkornew> it just does not work
11:04:40 <shapr> take a clean source tree of .hc files or whatever
11:04:51 <shapr> document what clean source tree you're using
11:05:02 <shapr> document the diffs and changes you've made
11:05:10 <shapr> record a log of the entire build process
11:05:12 <wkornew> shapr, I think it would be easier to rewrite darcs in a different language
11:05:20 <shapr> well, our choice
11:05:24 <shapr> or "your choice"
11:06:39 <shapr> then, post links to your build logs and your sources on ghc-users
11:07:12 <shapr> if you have a build log handy, I can look at it.
11:07:24 <shapr> but no promises there, I'm not a GHC wizard.
11:07:55 <wkornew> I will upload it now
11:08:36 <wkornew> thank you
11:09:21 <wkornew> http://zeus.mpg.goe.net/~tuvok/logs
11:10:44 <shapr> huh, what's up with alloc.h?
11:10:56 <wkornew> it's the one from g++
11:10:59 <shapr> did you read what dons said about allocating 1MB blocks?
11:11:21 <wkornew> MBlocks?
11:11:25 <wkornew> what did he say, again?
11:11:36 <shapr> he replied on ghc-users, lemme get the url
11:12:04 <wkornew> oh, yes, I ported all .c files
11:12:37 <shapr> http://www.haskell.org//pipermail/glasgow-haskell-users/2004-October/007191.html
11:12:44 <shapr> ah, that was Wolfgang
11:15:07 <shapr> that is odd
11:15:26 <shapr> do you have Control/Arrow.hs ?
11:15:50 <wkornew> yes
11:15:59 <wkornew> but I got the same errors on Linux!
11:16:06 <shapr> hmm
11:16:13 <shapr> that's suspicious.
11:16:51 <shapr> it sounds like a makefile issue in that case
11:18:10 <shapr> which sources are you using?
11:18:19 <wkornew> 6.2.1
11:18:27 <shapr> from what url?
11:18:34 <wkornew> (sorry if it might take longer to reply, I'm writing the mail)
11:18:38 <shapr> ok
11:18:49 <wkornew> from haskell.org/ghc
11:19:02 <shapr> specifically this url? --> http://www.haskell.org/ghc/dist/6.2.1/ghc-6.2.1-src.tar.bz2
11:19:08 <wkornew> yes
11:19:25 <shapr> I'll try building it on Debian and see if I get the error.
11:19:35 <wkornew> you need some ghc files
11:19:42 <wkornew> don't you? or will you generate them?
11:20:02 <wkornew> mine are on http://zeus.mpg.goe.net/~tuvok/ghc-bundle.tgz
11:20:16 <wkornew> they unpack to the folder ghc-6.2.1
11:20:25 <shapr> did you try to build ghc itself from the ghc sources?
11:20:36 <wkornew> aren't that the sources?
11:20:47 <shapr> well, yes
11:21:03 <shapr> but, I don't understand exactly where you got the "can't build arrow.o" error
11:21:13 <wkornew> I tried building ghc with an existing ghc on Linux, that was okay
11:21:17 <shapr> did you first build from those sources on your Linux box, and then produce .hc files?
11:21:33 <wkornew> it seems like it wants to build a haskell file before having a haskell compiler
11:21:40 <wkornew> yes
11:21:52 <shapr> did you try to build the .hc files on Linux?
11:22:59 <shapr> is that where you got the same Arrow.o error?
11:23:38 <wkornew> that was the second compile when I tried building without ghc
11:23:54 <wkornew> the first one built fine
11:25:13 <wkornew> they must have broken the build system
11:25:38 <shapr> I'm still not clear on the order, which linux distro are you using? does it already have GHC installed? did you used your already installed GHC to build the downloaded sources, and then generate .hc files?
11:26:15 <shapr> maybe my brain is just slow today...
11:26:51 <wkornew> np
11:26:58 <shapr> you have both BeOS and Linux installed on the same box, right?
11:27:03 <wkornew> I have CRUX Linux
11:27:09 <shapr> never heard of it, but ok...
11:27:16 <wkornew> I downloaded the binary of GHC
11:27:19 <wkornew> installed it
11:27:24 <wkornew> downloaded the source
11:27:40 <wkornew> built the whole source using the binary I downloaded
11:27:47 <wkornew> this went fine
11:28:16 <SamB_XP> wkornew: what distro, if any, is CRUX derived from?
11:28:39 <shapr> http://www.osnews.com/story.php?news_id=4720
11:28:40 <wkornew> then I unpacked the source into another folder and built using gc-build (i.e.: pretending there is no ghc binary)
11:29:06 <wkornew> CRUX is a very small and rather clean linux
11:29:23 <shapr> how did you generate .hc files?
11:29:28 <wkornew> I wanted it because it is just about 200M and not as blown as the other distros (and scripts are much cleaner)
11:29:46 <wkornew> on the with-ghc build I ran:
11:29:53 <wkornew> make gc-file-bundle
11:30:07 <wkornew> this produced the files which I unpacked into the without-ghc folder
11:30:26 <Igloo> It doesn't sound like you followed the instructions on porting in the building guide
11:30:46 <wkornew> uhm, okay, what should I do?
11:31:23 <Igloo> follow the instructions on porting in the building guide
11:37:03 <wkornew> okay: Bootstrapping GHC on a system without GHC already installed is achieved by taking the intermediate C files (known as HC files) from a GHC compilation on a supported system to the target machine, and compiling them using gcc to get a working GHC.
11:37:15 <wkornew> I compiled the ghc files on linux and took the to beos
11:38:23 <wkornew> then, I just have to run distrib/hc-build --prefix=[dir]
11:38:39 <wkornew> isn't that what the porting instructions state?
11:39:23 * shapr has been reading the porting guide, and still doesn't know what to do
11:39:40 <wkornew> yes, that was the same what I thought :)
11:39:51 <shapr> I guess I'd start with 10.2.1
11:40:32 <wkornew> the upcoming GHC release? :)
11:40:44 <shapr> no, I mean section 10.2.1 on http://www.haskell.org/ghc/docs/latest/html/building/sec-porting-ghc.html
11:41:01 <wkornew> but I am not porting to a new architecture, right?
11:41:12 <shapr> no, you're not
11:41:21 <shapr> but 10.2.1 should work even for a new arch
11:41:40 <Igloo> Read "new architecture" as "new OS/architecture"
11:41:54 <shapr> I might start trying to do a fully registered build, but if that didn't work the first time, I'd swap back to the beginning.
11:42:45 <shapr> you're on BeOS/x86, and generating .hc files from Linux/x86, so 10.1 is also where I would start.
11:42:56 <wkornew> yes
11:43:17 <shapr> but if that didn't work, and ghc-users didn't have a quick fix, I'd try to make an unreg build just to see if that part works
11:43:43 <wkornew> I just tried an unreg build and it had the same error :)
11:43:47 <shapr> oh
11:44:05 * shapr thinks
11:44:37 <shapr> on Linux you had a 6.2.1 source tree and a 6.2.1 binary, and you built the 6.2.1 source tree with no errors
11:45:19 <shapr> then you generated .hc files from that build, and you put the .hc files in a new unpack of the source tree, to see if the .hc files would work on Linux
11:45:30 <shapr> and that's where you first got the "Can't build Arrow.o" right?
11:45:44 <wkornew> yes
11:46:35 <wkornew> I think I will use a different build system and finally show 'em how to make it simple :))
11:46:36 <shapr> that sounds like a bug to me.
11:46:38 <shapr> heh
11:46:48 <shapr> if you can make the GHC build system simple, I'll be impressed ;-)
11:47:08 <wkornew> ever used "jam" (different "make")? it's much nicer and looks cleaner (at least to me)
11:47:21 <wkornew> all those scripts should be replaced
11:47:22 <shapr> I've heard of it.
11:47:29 <wkornew> Haiku uses jam
11:47:42 <shapr> I've also heard of scons and a bunch of other make replacements
11:48:15 <shapr> I think I'd be happiest with a DAG-based make replacement.
11:48:36 <wkornew> what's that?
11:48:44 <shapr> directed acyclic graphs
11:49:05 <wkornew> would you work with me on integrating a clean version of ghc into darcs?
11:49:24 <shapr> clean version meaning 'uses jam to build' ?
11:49:42 <wkornew> for example
11:49:47 <wkornew> we can use make if you want
11:49:57 <reffie> hi
11:49:59 <wkornew> but reduce the number of scripts
11:50:03 <shapr> at least for the moment, I don't think I have the time and focus to work on such a project
11:50:10 <wkornew> this perl stuff is horrible
11:50:22 <shapr> if you ask the Simons and they like your idea, they'll probably work with you on that project
11:50:28 <reffie> is there anything equivalent to this in the standard libraries?
11:50:28 <Igloo> The problem is a good make system computes deps from files, and has intermediate files aren't available at the beginning you can't make the whole dag at the start
11:50:29 <reffie> seq_ :: [IO ()] -> IO ()
11:50:29 <reffie> seq_ = foldr (>>) (return ())
11:50:44 <shapr> I think it's called sequence_
11:50:51 <shapr> @type sequence_
11:50:52 <lambdabot> sequence_ :: forall m a. (Monad m) => [m a] -> m ()
11:50:58 * Igloo started writing something but got sidetracked into writing an ANSI escape parser
11:51:03 <reffie> oh great thanks :P
11:51:38 <wkornew> can we meet tomorrow again? I have to go now. are you here regularly?
11:51:50 <shapr> I'm here more than the channel bots.
11:51:54 <Igloo> I'm sure a nice replacement for the perl scripts would be welcomed, but I suspect it's not an easy task
11:51:55 <shapr> I have no life.
11:52:01 * reffie hugs shapr 
11:52:04 * shapr snickers
11:52:19 <wkornew> lol
11:52:20 <shapr> reffie: glad I can help
11:52:37 <reffie> i find haskell kinda hard to read :(
11:52:44 <reffie> and certainly hard to debug :((
11:53:06 <shapr> what are you reading right now?
11:53:11 <reffie> my own code :P
11:53:17 * shapr laughs
11:53:30 <wkornew> shapr why is darcs not in C? Haskell is probably its biggest drawback
11:53:45 <shapr> Haskell is also its greatest strength
11:53:53 <wkornew> what about O'Caml?
11:54:00 <wkornew> that's already available
11:54:09 <shapr> it's also impure
11:54:18 <shapr> doesn't have typeclasses
11:54:24 <wkornew> okay, I have to really go now. thank you for everything. bye all
11:54:28 <shapr> syntax is not as sexy (in my opinion)
11:54:35 <shapr> I think Haskell is much more expressive than OCaml
11:54:44 <shapr> anyway, have a nice evening.
11:54:52 <wkornew> thanks, ciao
11:55:05 <reffie> oh and if i have a data structure like this, and i want to change only one 'field' of some variable of that type, how would i do it?
11:55:08 <reffie> data IRCMessage = IRCMessage { 
11:55:11 <reffie> 			      msgPrefix :: String,
11:55:13 <reffie> 			      msgCommand :: String, 
11:55:15 <reffie> 			      msgParams :: [String] 
11:55:18 <reffie> 			     }
11:55:22 <shapr> that looks vaguely familiar...
11:55:27 <shapr> are you working on lambdabot?
11:55:29 <reffie> yeah stolen from lambdabot
11:55:33 <shapr> cool :-)
11:55:46 <Igloo> im { msgPrefix = "Foo" }
11:56:15 <reffie> im being the original variable?
11:56:30 <shapr> nothing = IRCMessage { msgPrefix = "", msgCommand = "", msgParams = []}
11:56:41 <shapr> nothing { msgPrefix = "some prefix or something" }
11:56:44 <shapr> er wait
11:56:45 <reffie> !
11:56:50 <shapr> is that right?
11:56:51 * shapr tries
11:57:49 <Igloo> reffie: Yup
11:57:54 <reffie> thanks!
11:58:23 <reffie> what i did was IRCMessage { msgPrefix = msgPrefix msg, etc }
11:58:36 <shapr> overkill
11:58:51 <reffie> so if i ever want to add another field, i have to add it to all the times i do that too :/
11:59:03 <shapr> you can also just do 'msgPrefix msg' to pull out that field
11:59:36 <shapr> reffie: huh?
12:00:08 <reffie> http://www.nectarine.it/~refugee/hbot.hs
12:00:15 <reffie> look at addHandler
12:01:18 <shapr> it can be simpler
12:01:33 <reffie> the way you said is simpler :P
12:01:39 <shapr> yup
12:02:42 * shapr wonders whether Igloo or shapr looks more like Cousin It
12:04:26 * shapr is jealous of Igloo hair superiority
12:04:49 <reffie> i'm having trouble keeping the lines shorter than 80 chars :/
12:17:11 * stepcut learns about 'exciting' things like UDH, and wap push...
12:22:14 <shapr> ooh
12:22:17 <shapr> what's UDH?
12:22:24 <shapr> undocument developer hole?
12:26:41 <Jan_w> data Mobiel = Leaf Int | 			
12:26:42 <Jan_w>                   Node Int (Mobiel) Int (Mobiel)
12:26:46 <Jan_w> gewicht :: Mobiel -> Int                                        
12:26:47 <Jan_w> gewicht x                                                       
12:26:47 <Jan_w>  | (Leaf a)              = a                                    
12:26:47 <Jan_w>  | (Node k l Node m n)   = (k * (gewicht l)) + (m * (gewicht n))
12:27:13 <Jan_w> why is a an undefined var here ?
12:28:12 <TheHunter> the correct syntax is gewicht (Leaf a) = ...; gewicht (Node k...) = ...
12:28:30 <TheHunter> (where the ; is a newline)
12:28:50 <Jan_w> so without the | ?
12:28:55 <TheHunter> yep
12:29:06 <TheHunter> and you'll have to duplicate gewicht
12:29:09 <Lemmih_> Pattern guards are also valid.
12:30:28 <Jan_w> without the guard it says (unexpected `=')  at the Node k line
12:30:30 <TheHunter> Lemmih_: Hugs doesn't know them
12:30:55 <TheHunter> gewicht (Leaf a) = a
12:31:05 <Lemmih_> Who uses Hugs anyway d-:
12:31:12 <TheHunter> gewicht  (Node k l Node m n)  = (k * (gewicht l)) + (m * (gewicht n))
12:31:44 <Lemmih_> But I'm not sure how you wan't 'Node' to match an Int.
12:31:59 <Lemmih_> *want
12:32:48 <Jan_w> I guess I not sure either :)
12:33:40 <Jan_w> gewicht :: Mobiel -> Int
12:33:40 <Jan_w> gewicht (Leaf a)             = a
12:33:40 <Jan_w> gewicht (Node k l Node m n)  = (k * (gewicht l)) + (m * (gewicht n))
12:34:09 <TheHunter> oh, the second Node on the left of the last gewicht definiton shouldn't be there
12:34:24 <Jan_w> oh
12:34:25 <Jan_w> gewicht (Node k l m n)  = (k * (gewicht l)) + (m * (gewicht n))
12:34:28 <Jan_w> indeed!
12:34:32 <Jan_w> THANKS!
12:34:45 <Jan_w> now i understand why that was bugging 
12:34:46 <Jan_w> :)
12:38:23 <stepcut> shapr: user data header
12:38:43 <stepcut> shapr: used when sending binary sms to mobile phones (for ringtones, etc)
12:48:36 <shapr> oh that
12:48:50 <shapr> you can do some really cool and evil tricks with that.
12:48:57 <stepcut> that too
12:49:13 <shapr> Nokia's Messaging Center accepts routing commands submitted via standard SMS
12:49:18 <stepcut> :p
12:49:48 <stepcut> you can reconfigure people's phones by send OTA (over the air) configuration data too
12:49:50 <shapr> this was recently discovered by um, a friend of mine.
12:49:57 <shapr> yes, absolutely.
12:50:20 <shapr> nokia mobile phones are significantly less secure than screen doors on bank vaults.
12:51:21 <shapr> not that I have any personal experience, mind you
12:51:25 <stepcut> :p
12:51:27 * shapr looks suspiciously at clog
12:51:56 <stepcut> well, i just care about delivering ringtones, which is harder to find out than it should be
12:52:15 <shapr> um, I can probably get you the info if you want.
12:52:22 <stepcut> oh?
12:52:27 <shapr> might take a coupla days
12:52:41 <stepcut> well, if it is not too much work, I would appreciate it
12:53:04 <stepcut> I think I am starting to understand how it all fits together, but more information would be useful 
12:53:11 <shapr> I'll see what I can do
12:53:14 <stepcut> thanks
12:54:47 <stepcut> and in unrelated news, I am also trying to figure out how to assemble a series of jpegs into a movie under linux
12:55:32 <stepcut> shapr: have you used pesco's arguement parsing library at all ?
12:56:45 <shapr> Netscape has supported jpeg movies for a long time
12:56:53 <shapr> probably still does
12:57:11 <shapr> I think you just send MIME mixed/multipart
12:57:16 <shapr> though I forget the details
12:57:27 <shapr> I have not used pesco's lib
12:57:55 <shapr> I've read about it, it looks simple enough.
13:00:29 <stepcut> shapr: i think it might be too simple, namely, it is not powerful enough to handle cvs's command line with allows you to use -d with two different meanings: cvs -d :ext:stepcut@server.com co -d project some/deeply/nested/project
13:01:25 <shapr> could be
13:01:41 <shapr> you could ask him about that, he might fix it.
13:02:25 <stepcut> i will mention it next time i see him online...
13:30:16 * shapr grumbles at DTDs stored on Wikis
13:31:18 <stepcut> hehe
13:33:25 <shapr> hiya viv 
13:33:44 <viv> bonjour~
13:34:05 <shapr> comment ça va?
13:34:11 <shapr> parlez vous français?
13:37:02 <viv> Wie geht es dies?
13:37:27 <shapr> ich habe keine ahnung
13:37:38 <shapr> spraakt u nederlands?
13:37:41 <shapr> talar du svenska?
13:37:50 <shapr> xu do tavla mi bau la lojban
13:38:02 <viv> wow wow..slow down..
13:38:10 <viv> me aint expert yet..
13:38:12 <viv> =)
13:38:54 <shapr> so are you in the part of canada where french is common?
13:38:55 <shapr> hej Marvin-- 
13:38:57 <shapr> how's code?
13:39:01 <Marvin--> evening
13:39:11 * shapr fights HaXML
13:39:32 <Marvin--> work code is buggy, I'm afraid... off time code hasn't happened for a while
13:40:19 <shapr> why doesn't HaXML like this? <!ENTITY string CDATA>
13:40:56 <shapr> can I not use CDATA in an element? only (#PCDATA) ?
13:43:06 * Oejet_ grumbles over a function which his program spends 70 percent of it's time in.
13:45:53 <tromp> spraakt should be spreekt, shapr:)
13:45:58 <shapr> whoops, thanks
13:46:12 <shapr> ik begrijp het niet!
13:46:20 * shapr shows just how little dutch he actually speaks
13:46:46 <tromp> if u want to catch a dutch persons attn, you can try
13:46:57 <tromp> heeft u een braakgesprek?
13:47:27 <shapr> I'm afraid to ask what a braakgesprek is.
13:47:31 <shapr> but I will anyway...
13:47:35 <shapr> what's a braakgesprek?
13:47:37 <tromp> it's a little joke:)
13:47:49 <shapr> gesprek I assume is like 'spoken'
13:48:01 <tromp> gesprek is a conversation
13:48:03 <shapr> ah
13:48:25 <tromp> braak is puke / barf
13:48:47 <tromp> it's a spoonerism
13:48:58 <shapr> heh
13:49:15 <tromp> spraakgebrek == speech deficiency
13:49:19 * shapr laughs
13:49:30 <Marvin--> what the hell
13:49:36 <Marvin--> http://eff.org/news/archives/2004_09.php#001962
13:49:40 <Marvin--> broken, broken I say
13:49:59 <Oejet_> applyMasks bb lst = map (\mask->bb .&. mask == mask) lst
13:50:48 <shapr> Marvin--: couldn't this apply to Microsoft's Unix tools too?
13:51:18 <shapr> if BnetD is going to be shutdown, can the OSS community use it to shut MS out of Linux?
13:51:24 <Oejet_> How can this possibly be optimized?
13:51:43 <Marvin--> the scary part is that this ruling seems to make EULAs enforceable
13:52:08 <shapr> in summary, don't buy software, and don't agree to EULAs on software.
13:52:14 <shapr> software should be a service anyway.
13:52:24 <shapr> like scientific research
13:52:44 <Marvin--> well, the stupid thing is that you are never ever shown a EULA until after buying the software
13:52:57 <Maddas> Hence "don't buy software" :-)
13:52:58 <shapr> hm, hadn't thought of that
13:53:17 <Marvin--> how can you enforce a contract that the buyer is not shown until he's forked over money and gotten a receipt?
13:53:23 <Marvin--> but apparently you can
13:53:30 <Marvin--> as long as it's not "one-sided"
13:53:43 <Marvin--> and apparently Blizzard's EULA isn't considered "one-sided"
13:53:47 <shapr> Oejet_: what is that doing?
13:53:54 <Philippa> Marvin--: because by default in at least some countries you don't even have the right to copy the data on the CD into memory
13:54:34 <Marvin--> the ruling also totally demolishes the right of first sale
13:54:41 <Marvin--> sheesh
13:55:08 <shapr> Oejet_: what's the order of operations there?
13:55:26 <Oejet_> shapr: It is testing wether a word has a certain bitpattern inside.
13:56:11 <Oejet_> shapr: More precisely: It's testing a list of bit patterns against a Word64.
13:56:46 <Oejet_> shapr: applyMasks bb lst = map (\mask->(bb .&. mask) == mask) lst, I think.
13:57:12 <shapr> if you want to do premature optimization, you could make a tree of the bit patterns, since if some of the earlier patterns fail, it means some of the later patterns will also fail
13:57:25 <shapr> I'm pretty sure there's a nice fold hiding in there somewhere
13:57:40 <shapr> do you want all masks that match, or just the first?
13:58:39 * shapr thinks of a nice fmap instance for bitmask tree testing
13:58:41 <Oejet_> Actually the list is of stripe patterns in the game of connect four with a board of Word64.
13:59:01 <shapr> oh
13:59:15 <SamB_XP> so is there only one list?
13:59:15 <Oejet_> shapr, that is actually a very good idea!
13:59:37 <shapr> hm, the match test isn't a tree then
13:59:50 <SamB_XP> if there is only one value of the list, you might be able to use TH for something
14:00:02 <Oejet_> SamB_XP: No, one for stripes of length 4, 3, and 2.
14:00:18 <SamB_XP> well, that isn't very many lists, anyway
14:00:37 <Oejet_> I want to count how many match.
14:00:43 <shapr> there is an elegant shape to connect-four pattern checking, but I can't think of it at the moment.
14:01:14 <shapr> I think maybe it's a lattice that you can unfold
14:02:03 <Oejet_> shapr: He, I don't know very much about lattices.
14:03:48 <shapr> well, I don't either.
14:03:51 <shapr> hiya Brrrrr 
14:03:55 <Brrrrr> hi shapr 
14:04:01 <shapr> are you near the arctic circle just like me?
14:04:11 <Brrrrr> the concept of pos is quite simple
14:04:17 <Brrrrr> nah not really :D
14:04:20 <shapr> what's pos?
14:04:24 <Brrrrr> I just like the nick
14:04:40 <Brrrrr> pos = partialy ordered set
14:04:44 <shapr> oh
14:04:53 <Brrrrr> of course what I meant wwas lattice
14:04:53 <Brrrrr> :D
14:04:55 <Brrrrr> opss
14:05:04 <Brrrrr> the concept of lattice is quite simple
14:05:10 <shapr> yes, I agree.
14:05:45 <shapr> Brrrrr: you wanna learn Haskell?
14:05:55 <Brrrrr> I know some already ;)
14:05:56 <shapr> or did you just clairvoyantly arrive to discuss lattices?
14:06:16 <shapr> I know some Haskell too
14:06:17 <Brrrrr> nah in fact I was wondering about another off topic issue
14:06:18 <shapr> but not enough!
14:06:22 <shapr> oh oh what is it?
14:06:24 <Brrrrr> and looking for places to ask lol
14:06:27 <SamB_XP> Brrrrr: hehehe
14:06:43 <SamB_XP> off-topic stuff is fun
14:06:48 <Brrrrr> what nice imperative/procedural languages do you know 
14:06:55 <shapr> Python
14:07:00 <Brrrrr> ah wait
14:07:01 <shapr> Self
14:07:03 <SamB_XP> yah, Python
14:07:14 <Brrrrr> I'm looking for stuff with staty and strong typing
14:07:27 <Brrrrr> python dynamic typing scares me :-/
14:07:34 <shapr> it's actually really nice
14:07:35 <SamB_XP> that doesn't sound like nice imperative to me
14:07:48 <shapr> static typing is just one tool, like OOP or threads, or etc
14:08:12 <Brrrrr> I just think it's to easy to do dumb mistakes like 
14:08:23 <Brrrrr> thiz = thiz + 1
14:08:23 <SamB_XP> so?
14:08:31 <Brrrrr> opss
14:08:36 <Brrrrr> thiz = this + 1
14:08:47 <SamB_XP> so?
14:08:56 <shapr> you can use pychecker to look for single-use and closely named vars
14:09:04 <shapr> but unit testing is a better way to go
14:09:10 <shapr> in fact, I prefer test-first
14:09:18 <Brrrrr> I also like the documentation it provides :-/
14:09:25 <Brrrrr> the types
14:09:40 <shapr> I think unit tests usually give better docs than types.
14:09:48 <Brrrrr> but you can have both
14:10:09 <shapr> I think unit tests usually subsume the docs you get from types.
14:10:21 <shapr> there are exceptions like epigram's dependent type system
14:10:29 <shapr> but epigram isn't procedural
14:10:38 <SamB_XP> is epigram even usable yet?
14:10:48 <shapr> yah, it's usable, but it's a bit flaky.
14:10:59 <shapr> it does some surprisingly nifty stuff though
14:11:09 <SamB_XP> you know what I mean... what is the feature that I always ask about when you mention epigram?
14:11:24 <shapr> even in Haskell's HM type system, it's difficult to specify behaviour in a type
14:11:33 <shapr> but epigram gets much further
14:11:41 <Brrrrr> I was also looking for something faster than python
14:11:48 <Brrrrr> something I can use instead of C
14:12:00 <SamB_XP> Brrrrr: python is faster than python!
14:12:11 <Brrrrr> for things like, say,  Operation Research algorithms
14:12:13 <shapr> in my experience, programmer time is more costly than CPU time
14:12:29 <shapr> so I usually write totally inefficient algorithms that work correctly
14:12:37 <shapr> and then tune them if I really need to
14:12:40 <Brrrrr> shapr: yes, I know, I was haskell ;)
14:12:54 <shapr> why can't you use Haskell?
14:12:55 <Brrrrr> shapr: but for some things I really need C or something like it
14:13:09 <SamB_XP> than, use C! it goes nicely with Python.
14:13:15 <shapr> when Haskell is too slow, you can write a tiny bit of C code and call it from Haskell.
14:13:17 <shapr> same for Python
14:13:41 <Brrrrr> shapr: yes I know, but sometimes it just isn't worth it, easier to do everything in C
14:13:49 <shapr> I would disagree strongly with that =)
14:13:52 <Brrrrr> shapr: for instance imagine shortest path algorithms
14:13:54 <shapr> I'm not very fond of C
14:14:11 <Brrrrr> shapr: or minimal spanning tree algorithms
14:14:16 <SamB_XP> what is that Python-like extension-language called again? oh yeah, Pyrex! 
14:14:50 <Oejet_> shapr: Some more testing reveals that the program is spending 50 % of its time in the function: \mask->bb .&. mask == mask
14:15:12 <Brrrrr> shapr: these implementations may require you to use cyclic data structures for instance
14:15:19 <shapr> Oejet_: would a fold be faster?
14:15:30 <shapr> can you order the masks in such a way that it's faster?
14:15:35 <Brrrrr> shapr: and most of the algorithm is just buildings and accessing these data in memory
14:15:54 <shapr> ok?
14:16:00 <Oejet_> shapr: I will try; ghc -prof is great!
14:16:18 <Brrrrr> of course you can do that algorithm in C and then use it in haskell programs
14:16:20 <shapr> most of every algorithm is building and accessing data in memory?
14:16:33 <Brrrrr> shapr: in cyclic data structures
14:17:07 <shapr> is C better at cyclic datastructures than Haskell?
14:17:14 <Brrrrr> shapr: isn't it?
14:17:20 <shapr> not in my experience.
14:17:26 <monochrom> what is "better"?
14:17:32 <SamB_XP> shapr: it would at first appear so, anyway.
14:17:40 <Brrrrr> ok maybe I'm about to learn then :)
14:17:41 <shapr> for me, better means my code works the first time I write it
14:17:42 <SamB_XP> what with pointer equality and all
14:17:57 <shapr> and then months later I can come back to my code and understand what I wrote
14:18:04 <ski> shapr : hi !
14:18:08 <monochrom> fewer keystrokes to make a cycle, yes.
14:18:09 <shapr> hej ski!
14:18:16 <Brrrrr> shapr: wait this is interesting because I don't know how to do this at all in haskell, so I might be about to learn haskell after all :D
14:18:40 <shapr> http://www.haskell.org/hawiki/TyingTheKnot
14:18:43 <monochrom> more obvious whether it's correct or not? that's questionable.
14:19:03 <shapr> monochrom: I find it much easier to check correctness of Haskell code versus C code.
14:19:16 <shapr> but then, the classes of errors in the two languages are different.
14:19:35 <Brrrrr> shapr: thank you! I'm going to read it
14:19:40 <monochrom> Here is part of my meaning of "better".  If you keep making pointer related mistakes, it is not "better".
14:19:41 <shapr> :-)
14:19:47 * shapr agrees with monochrom 
14:20:20 <shapr> I think it's best to know some assembly, some C, and some higher level languages
14:20:30 <shapr> then if your high level code is too slow, you can drop down a level.
14:20:33 <ski> it can be good, at least
14:20:37 <Brrrrr> shapr: yeap
14:21:12 <shapr> Brrrrr: français?
14:21:24 <Brrrrr> shapr: still I would like to drop down to the C level sometimes and avoid some things I hate about C. The only one that comes close is Pascal :-/
14:21:28 <Brrrrr> shapr: nope PT
14:21:31 <shapr> oh
14:21:32 <Brrrrr> shapr: nope portuguese
14:21:39 <shapr> I thought #happycoders was .fr
14:21:45 <Brrrrr> I don't know
14:21:54 <Brrrrr> 1st time there
14:22:00 <shapr> interesting people there
14:22:01 <Brrrrr> and no one talked yet :D
14:23:18 * Brrrrr reads
14:24:21 <shapr> hmm, HaXML likes <!ENTITY state "( broken | erased )" > but it doesn't like <!ENTITY string CDATA > or <!ENTITY float (#PCDATA) >
14:24:25 <shapr> what's up with that?
14:24:37 <shapr>     missing entity defn in G ENTITY decl  \n  Found (
14:38:46 <shapr> yay, finally HaXML takes the irate.dtd
15:19:05 <shapr> hiya Helicopter 
15:19:10 <shapr> how's it spinning?
15:19:16 <Helicopter> hi shapr
15:19:27 <Helicopter> all right I guess
15:19:32 <Helicopter> been unicycling ?
15:20:08 <shapr> yup
15:20:18 <shapr> I love my mountain unicycle I got for my birthday.
15:20:23 <Helicopter> lol
15:20:32 <shapr> I lost twelve kilos too.
15:20:37 <Helicopter> awesome
15:21:17 <Helicopter> It appears I will have to reinstall mandrake
15:21:21 <Helicopter> :(
15:21:33 <shapr> well, mandrake is easier to install than windows.
15:21:58 <shapr> Brrrrr: how's your knot tying merit badge going?
15:22:01 <SamB_XP> huh, there is a unicycle club that a guy in my hall started.
15:22:06 <shapr> really?
15:22:08 <shapr> neat!
15:22:12 <shapr> who's the guy?
15:22:17 <shapr> what's his name?
15:22:20 <SamB_XP> I probably ought to go to a meeting sometime
15:22:27 * shapr cranks up Rammstein
15:22:59 <SamB_XP> Nick Kruse. but why do you need to know that?
15:23:31 <shapr> because a bunch of the unicycle club starters hang out on rec.sport.unicycling
15:23:37 <shapr> and a bunch of the unicyclist
15:23:37 <shapr> s
15:24:39 <shapr> he's only listed on the VT roster of unicyclists.
15:24:48 <ski> shapr : music ?
15:24:59 <shapr> rammstein is music, yes.
15:25:08 <shapr> that guy can roll his Rs in a really evil way.
15:25:18 <shapr> RrRrRammstein!
15:25:43 <shapr> Helicopter: go for it, you'll probably end up with a faster system
15:25:47 <aj> err, how do you check if an element's in a list?
15:25:59 <aj> (or what's the idiomatic way of doing that?)
15:26:00 <shapr> Helicopter: debian is about the only linux distro I know of that can be nearly infinitely upgraded
15:26:06 <Igloo> 5 `elem` [1,2,3,4,5,6]
15:26:07 <shapr> lookup?
15:26:09 <shapr> oh, elem
15:26:12 <aj> tnx
15:26:17 <shapr> right, lookup is for a list of 2-tuples
15:26:44 <Helicopter> did anybody try an eclipse plugin for haskell ?
15:28:34 <shapr> I've heard it's nice
15:28:39 <shapr> I don't use eclipse myself.
15:29:22 <shapr> is there a gzip lib for Haskell?
15:30:01 <andersca> gzip :: String -> String
15:30:48 <shapr> @index gzip
15:30:48 <lambdabot> Data.Generics,Data.Generics.Twins
15:30:51 * shapr blinks
15:30:55 <Helicopter> lol
15:31:06 <shapr> er, I was thinking foo.tar.gz
15:31:13 <shapr> that sort of gzip
15:31:19 <Helicopter> yeah I know
15:31:30 <Helicopter> I'd rather bzip2 or lzma myself
15:31:59 <shapr> yup, bzip2 is nice
15:32:08 <shapr> I'm actually cloning another app
15:32:19 <Helicopter> officers, arrest that man.
15:32:23 <shapr> it sends a gzip'd file to the server
15:32:30 <shapr> Helicopter: true enough :-/
15:32:44 <Helicopter> which app is it
15:33:26 <aj> err, and how do you make a number a string, 15 -> "15"?
15:33:32 <Helicopter> show
15:33:58 <aj> ohhhh
15:34:06 <shapr> it's irate.sf.net
15:34:26 <shapr> in honor of andersca, I've named my (zero amount of code written) irate clone badgirate
15:34:38 <Helicopter> I bitch a lot about this issue, but "show" is not a very good name for what it is doing. 
15:34:45 <shapr> yah, true
15:35:00 <andersca> @arr
15:35:00 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
15:35:05 <shapr> recent discussion on the lists talks about multiple versions of show, for String/HTML/etc
15:35:42 <Helicopter> nice app
15:35:59 <shapr> actually, it sucks
15:36:15 <shapr> the idea is great, the server is nice, the client is crap
15:36:23 <ski> @arr
15:36:24 <lambdabot> Drink up, me hearties
15:36:27 <Helicopter> lol, I went to sf.net recently. and the top 10 downloaded projects were, with the exception of TightVNC, eMule, shareaza, cdex, emule, etc. 
15:36:49 <shapr> for app in $(PR0N);
15:37:15 <Helicopter> well, it's shaping computing 
15:37:28 <Helicopter> distributed file sharing networks is apparently what mankind needs at the moment
15:37:39 <shapr> wants
15:38:04 <Helicopter> I think it's a need
15:38:14 <Helicopter> information wants to be free
15:38:18 <shapr> yup
15:38:28 <shapr> DMCA/RIAA/MPAA pressure is building
15:38:34 <shapr> we're in the Prohibition
15:38:46 <Helicopter> new world anarchists
15:38:57 <SamB_XP> is *that* why they call it speakeasy?
15:39:08 <Helicopter> heh
15:39:14 <SamB_XP> that one ISP
15:39:17 <shapr> yes
15:39:22 <shapr> speakeasy started in Seattle
15:39:38 <shapr> they set up terminals in the back of coffee shops
15:48:54 <Helicopter> I'm running irate on winxp. not bad up to now.
15:50:25 <Lunar^> shapr: About LTU, I think you should ask Thomas Hallgren
15:52:30 <shapr> ok
15:52:58 <shapr> Lunar^: ok
15:53:26 <shapr> Helicopter: it crapped out bad on Debian
15:53:54 <Helicopter> ah
15:54:46 <shapr> I have about 300MB of mp3s and some large number of tracks in my trackdb, and it takes about fifteen seconds to repsond to mouse clicks
15:54:57 <Helicopter> ow
15:55:07 <shapr> that's on my dual Athlon MP 1544MHz with 512mb of ram
15:55:19 <shapr> it's not a 486  :-)
15:55:45 <Helicopter> submit a bug !
15:55:50 <shapr> I did!
15:55:54 <shapr> in february!
15:55:58 <Helicopter> oh my
15:56:17 <SamB_XP> I would complain if it did that with a 450 MHz PII
15:56:18 <Helicopter> is your java stuff up to date ?
15:56:33 <shapr> I have some knowledge of Java, yes.
15:56:42 <shapr> but I've decided it's more fun to rewrite it in Haskel
15:56:49 <shapr> badgirate!
15:56:53 <Helicopter> oh, I meant if your java runtime is up to date
15:56:58 <SamB_XP> oh, Java, slowness.
15:56:58 <shapr> oh, sure
15:57:17 <shapr> I think I was using jre 1.4
15:57:23 <shapr> but the SWT version was not any faster
15:57:43 <Helicopter> SamB_XP: I ve been hearing that java got really fast recently and it doesnt deserve that bashing, but I don't know first hand.
15:58:03 <shapr> java is really slow to write, it costs a lot in programmer time.
15:58:18 <SamB_XP> Helicopter: well, I bet swing still takes too much RAM
15:58:20 <shapr> Java is the COBOL of the future.
15:58:34 <andersca> java isn't that bad
15:58:56 <Helicopter> last line of java code I wrote was three years ago and it used swing. I havent touched it since. (not by choice. They made me write in C!)
15:58:58 <shapr> it feels to me that Java is written for managers rather than programmers.
15:59:11 <SamB_XP> and it doesn't integrate all that well with the rest of the system...
15:59:20 <shapr> andersca: it's true, Java is much better than C or C++
15:59:39 <Etaoin> suppose I wanted to write a dynamic web page engine in haskell. are there any frameworks?
15:59:48 <shapr> getting rid of malloc already saves us all from a huge class of errors
15:59:50 <shapr> Etaoin: yes
16:00:17 <shapr> Etaoin: halipeto for templates, or WASH for generating any old sort of HTML
16:00:26 <shapr> there's not yet a whole appserver
16:00:37 <shapr> but hws-wp could be hacked into one without a huge amount of work
16:00:48 <Helicopter> What I would like to know is, do they prefer writing web server side stuff in Java because the language suits it, or is it because of the existing API's.
16:01:07 <SamB_XP> the language doesn't suit all that much
16:01:13 <shapr> yah, I agree
16:01:27 <shapr> J2EE has some cool features
16:01:28 <Etaoin> I have found myself wanting to do some static stuff in twisted.
16:01:52 <Helicopter> So it's all about the libraries. When they ask me if I know java, I feel weird about saying yes because I know nothing about beans , etc.
16:02:02 <shapr> beans are pretty easy
16:02:11 <shapr> the basic JavaBeans that is
16:02:32 <shapr> EnterpriseWebBeans ;-) are a little more complicated 
16:03:12 <Helicopter> yeah. but why should that concern my answer ? so the question really is, do you know enterprise yadda yadda, not do you know java.
16:03:29 <shapr> andersca: I'm just not very patient, I don't want to wait for the entire programmer culture to finally give in to GC and switch to Java before noticing there's much more past that.
16:03:46 <shapr> with Java, it's more about knowing the APIs
16:03:55 <SamB_XP> beans work nice with Jython, don't they?
16:03:58 <shapr> yes they do
16:04:07 <shapr> they look a little strange, but it works
16:04:08 <Lunar^> shapr: I made House hw2004 start on a real Pentium 233 today
16:04:12 <Helicopter> so, I am going to write hordes of haskell libraries and claim that none of you know haskell! hah.
16:04:13 <shapr> w00!
16:04:18 <shapr> Lunar^: did you get a screenshot? ;-)
16:04:38 <Etaoin> Helicopter: go for it!
16:04:44 <Lunar^> shapr: It was quite nice, but unfortuately rebooted each time I tried to use 'run'
16:04:45 <SamB_XP> Helicopter: how do you seek to justify such a claim?
16:04:50 <shapr> oops
16:04:53 <shapr> Lunar^: we want sources!
16:05:02 <Lunar^> shapr: My readline clone isn't in it, also
16:05:06 <shapr> awww
16:05:07 <Helicopter> I was kidding. Please stop calling my bluff. heh.
16:05:26 <Lunar^> shapr: Yes, I'm definitely going to ask for them
16:05:28 <shapr> Lunar^: did they upgrade to 6.2 or maybe even 6.3 ?
16:05:44 <Lunar^> shapr: Maybe it's time to set up a repository
16:05:49 <shapr> yes!
16:05:51 <shapr> darcs repo!
16:05:54 <Lunar^> shapr: I don't think so...
16:05:58 <shapr> no darcs?
16:06:03 <shapr> oh, no upgrade
16:06:06 <Lunar^> shapr: no upgrade
16:06:17 <Lunar^> shapr: I'm waiting for official 6.4
16:06:28 <shapr> cool
16:06:33 <Lunar^> shapr: I wan't the new backend, and rewriting all hOp C code in C--
16:06:39 <Lunar^> -'
16:06:41 <shapr> yah!
16:07:05 <shapr> is there a C-- compiler written in Haskell?
16:07:12 <shapr> that would be amusingly recursive
16:07:32 <Helicopter> what is c-- ?
16:07:47 <shapr> http://www.cminusminus.org/
16:07:53 <Helicopter> C with all typechecking removed ?
16:07:55 <shapr> it's a portable assembly language
16:08:09 <SamB_XP> it would also not require ocaml to build or run
16:12:00 <Lunar^> shapr: Sure there is !
16:12:15 <Lunar^> shapr: That's what backend-hacking-branch is all about
16:13:46 <shapr> oh neat, C-- debs
16:13:59 <Lunar^> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/rts/PrimOps.cmm?rev=1.1.2.3;only_with_tag=backend-hacking-branch
16:14:22 <Lunar^> that's PrimOps.cmm
16:14:29 <shapr> neat
16:15:00 <shapr> so, how do we get this to work with House/hOp ?
16:15:11 <Lunar^>   s = R1; <- 1st integer register
16:15:20 <Lunar^>   jump %ENTRY_CODE(Sp(0));
16:15:29 <Lunar^> No more damn CPP macros
16:15:39 <Lunar^> by some work :)
16:15:52 <shapr> heh, ok
16:16:12 <Igloo> shapr: Where are the debs?
16:20:02 <shapr> http://www.cminusminus.org/rsync/dist/?M=A
16:20:15 <shapr> http://www.cminusminus.org/rsync/dist/mk_20040305-1_i386.deb http://www.cminusminus.org/rsync/dist/mk_20040305-2_i386.deb
16:20:34 <Igloo> Ah, nifty
16:20:35 <shapr> and qcmm 
16:20:58 <shapr> I don't see a qc-- deb
16:23:32 * shapr grumbles at HaXml
16:29:33 <shapr> grrr, readXml . showXml fails in HaXml
16:29:57 * shapr suspects user error
16:36:40 <stepcut> :p
16:40:37 <shapr> it was user error, of course.
16:41:26 * desrt . o O ( hax'ML )
16:41:36 * desrt . o O ( h4x0r'ML )
16:41:50 <shapr> http://www.haskell.org/HaXml/
16:42:10 <desrt> yes.  but reading xml is boring
16:42:18 <desrt> i'd rather have an ML flavour for hax0rs
16:43:30 <shapr> HaXml is less boring than most xml libs
16:43:45 <shapr> it generates Haskell algebraic types from a DTD
16:43:52 <desrt> hm.  interesting.
16:44:09 <shapr> want to see one I just did?
16:45:00 <shapr> http://www.scannedinavian.org/~shae/{irate.dtd,TrackDatabase.hs}
16:48:09 <shapr> hej psi
16:48:13 <shapr> wazzzzzup?
16:48:17 <psi> tjena
16:48:25 <psi> not much.. getting sleepy :)
16:48:38 <shapr> I got sleepy once! Then it stopped!
16:48:40 <shapr> @yow !
16:48:41 <lambdabot> Zippy's brain cells are straining to bridge synapses...
16:49:20 <shapr> psi: man, I'm gonna drop by and look you up sometime when you're not expecting it.
16:49:24 <shapr> do you feel stalked?
16:50:15 * shapr grins
16:50:30 <psi> hehe
16:50:33 <psi> well, i never have, but maybe i should :)
16:50:33 * shapr wonders if a unicycle would be conspicuous on the luth.se campus.
16:50:44 * shapr snickers
16:51:43 <psi> opeth will probably keep me awake for at least another hour.
16:51:57 <shapr> what's opeth?
16:52:02 <psi> a band
16:52:08 <shapr> oh
16:52:22 <psi> they play metal
16:52:38 <psi> mostly death metal, but also softer music
16:53:30 <shapr> I'm in a deftones/rammstein/ministry sort of mood.
16:53:56 <Helicopter> opeth are awesome
16:54:03 * Igloo needs to get around to ogging more of my music before xmas happens again and I get even more
16:54:11 <psi> Helicopter: yes :)
16:54:17 * psi is listening to orchid right now
16:54:36 <Helicopter> I dont have their latest album tho. I heard that it was pretty soft.
16:54:55 <shapr> I flac'd about 40GB of my audio CDs month before last.
16:55:10 <psi> yes. it has only soft songs. i like it.
16:55:17 <psi> damnation.
16:55:34 <shapr> I stopped when I had less than 5GB free :-/
16:55:41 <psi> my favourite album is probably still life
16:56:10 <Helicopter> still life is very very good
16:56:13 <psi> i haven't listened much to the older albums though, such as orchid and morningrise
16:56:54 <psi> shapr: how much space does a flac'd album consume?
16:57:06 <desrt> so.. what's this haskell .NET business?
16:57:14 <shapr> um, lemme look at led zeppelin IV for example...
16:57:16 <Helicopter> psi: it typically has about 50% reduction
16:57:34 <shapr> psi: 260 mb for LZ IV
16:57:38 <shapr> er 269
16:57:55 <desrt> 58M     /mnt/media/music/albums/led zeppelin/led zeppelin iv
16:57:57 <desrt> suckas.
16:58:09 <Helicopter> heh
16:58:11 <shapr> desrt: yah, but you got lossy
16:58:18 <desrt> shapr; i bet you can't tell the difference :)
16:58:21 <shapr> I bet I can.
16:58:27 <psi> hm. is it worth it? compared to ogg, for instance. i would probably not be able to tell the differnce.
16:58:32 <shapr> (warning it's a sucker bet ;-)
16:58:42 <Helicopter> shapr: I recommend doing the ABX tests you can find at hydrogenaudio.org
16:58:44 <desrt> shapr; this is quality 6 vorbis
16:59:12 <shapr> I have a ritalin prescription, I plead hardware differences.
16:59:19 <Helicopter> lol
16:59:23 <desrt> heh.
16:59:33 <Helicopter> after doing the abx test myself, I was very disappointed by my ears.
16:59:41 <shapr> I'll try it
16:59:47 <desrt> abx test?
16:59:58 <shapr> but I was most unhappy with mp3 and ogg
17:00:04 <shapr> lots of the song was missing
17:00:22 <Helicopter> yeah. a=original b=mp3 x=you dont know. You try to tell if x is mp3 or wav. I sucked at it. and that was 128kbps athaa-sensitivity 5
17:00:23 * Igloo doesn't have space to burn currently
17:00:29 <desrt> ogg gets bad at low bitrates
17:00:31 <Igloo> (or for the next 2 years or so in all probability)
17:01:52 <Helicopter> since then I switched to using their flags for ripping.
17:05:23 <shapr> is there a listening test for Linux?
17:05:33 <Helicopter> it's in java I think
17:08:30 <shapr> foo
17:08:47 <shapr> I have no route to host with this --> http://users.smuts.uct.ac.za/~mbrooker/abox-0.1.1.tar.bz2
17:09:11 <Helicopter> there is a torrent for it
17:09:33 <shapr> can you get to that link?
17:09:38 <shapr> that's a Linux GTK version
17:10:20 <shapr> Hm, not from texas or sweden. I guess the server is totally down.
17:10:31 * shapr shrugs
17:12:49 <Helicopter> http://www.rjamorim.com/test/multiformat128/presentation.html
17:13:50 <Helicopter> damn, the links are down
17:14:12 <shapr> yup
17:14:35 * XTL stretches
17:15:02 * shapr squinches
17:15:36 <shapr> for something like "<!ELEMENT album (title, artist, recording?, coverart, catalogno*, " does that mean the subelements are *required* to be in that order?
17:15:58 <shapr> can I have an <artist/> before a <title/> ?
17:19:06 <flaw> no, title must come before artist
17:19:34 <shapr> ah
17:20:10 <shapr> I love these glasses --> http://www.staffanpreutz.com/USA/Preutzproducts.htm
17:20:55 <XTL> shapr: Does that mean you have them or?
17:20:58 <shapr> yup
17:21:49 <shapr> Their only downside is that they don't handle extremely sweaty situations like unicycling. Not that normal glasses handle that much better.
17:21:50 <desrt> do they go around your ears?
17:21:53 <shapr> nope
17:21:56 <desrt> cool
17:22:03 <XTL> Looks interesting.
17:22:06 <shapr> they just lightly press onto the side of your head
17:22:45 <XTL> I don't have an excuse or cash to get glasses (I'm +0.5). People claim any glasses I try on seem to fit me.
17:23:00 <shapr> they make sunglasses too...
17:23:10 * XTL adds a drop of water to his glass
17:23:34 <shapr> I'm -4 and -4.25
17:23:42 <shapr> I can't see my elbow...
17:23:49 <XTL> Ouch
17:25:55 <shapr> flaw: how do you make those happen in any order?
17:26:20 <shapr> oh, I bet I can do (title | artist, recording?, coverart)*
17:34:06 <shapr> seems to work that way
17:34:10 <flaw> =\
17:34:27 <shapr> er with all |
17:36:10 <flaw> you know that allows something like: title title title recording recording coverart coverart, right?
17:37:35 <flaw> any order, any number is what (element1|element2)* effectively does
17:37:36 <shapr> yup
17:37:58 <shapr> I'd like to limit one of those to a single occurence, but in any order
17:38:57 <shapr> with only two options, I could do ( title*, artist, title* )
17:39:01 <shapr> but that's cheesy
17:39:47 <jao> shapr, what's a good intro to python for seasoned programmers?
17:40:00 <flaw> albums can have multiple titles?
17:40:00 <shapr> probably the standard tutorial
17:40:07 <shapr> but you may want to try diveintopython.org
17:40:32 <shapr> jao: if you've used C, and you like Haskell, Python won't be much of a challenge. It is fun though.
17:40:39 <jao> shapr, i just wanted to avoid the if-then-else explanations :)
17:41:17 <jao> shapr, i do. i was just curious.
17:41:34 <shapr> there's also Bruce Eckel's Thinking in Python
17:42:10 <jao> is it also 1000 pages?
17:42:23 <shapr> I don't know
17:42:28 <shapr> I haven't read either of them.
17:42:41 <shapr> http://www.mindview.net/Books/TIPython
17:43:03 <jao> ok, thanks.
17:43:42 <shapr> flaw: actually, I'm just trying to get HaXml to parse the irate.sf.net TrackDatabase, they have a thoroughly broken DTD on their wiki, and I'm just trying to fix it up and make it work.
17:44:28 <shapr> the reality of the xml file is often different from their DTD, so I don't really know if there's only one <PlayList/> or what
17:49:12 <flaw> haha
17:49:17 <flaw> http://www.kallisti.net.nz/IrateDev/TrackDatabaseXML
17:50:54 <shapr> that's the one
17:52:06 <flaw> yeah, that looks pretty borked.
17:52:34 <shapr> now that I'm parsing existing trackdbs, time to see if I'm creating server-accepted xml.
17:52:45 <flaw> I suppose it is preliminary tho
17:53:05 <shapr> you'd be surprised...
17:55:03 <flaw> btw, xmllint from libxml2 is a nice tool to play with this stuff.. dunno if haxml provides convenient command line tools, does it?..
17:56:24 <shapr> it does
17:56:44 * flaw will have to look at it some more
17:56:48 <shapr> DtdToHaskell, Xtract, etc
17:56:52 <shapr> http://www.haskell.org/HaXml/
17:57:21 <shapr> Haskell2Xml lets you read and write Haskell values as XML
17:57:23 <flaw> aye, I got it installed.. just never noticed
17:58:54 <shapr> it's neat
17:59:20 <shapr> it's like a syntax-directed editor in that the generated algebraic types only allow you plug in the matching algebraic types
17:59:45 <shapr> Sometimes that's too restrictive. In those cases I use HXmlToolbox (toolkit?)
18:00:05 <flaw> box
18:00:26 <shapr> HXT uses a generic tree structue, and validation is a separate step
18:00:38 <shapr> so you could have as many partial transforms as you want
18:00:43 <flaw> the version of hxmltoolbox I have doesn't seem to have an easy installer so it just sitting in my home dir..
18:01:29 <flaw> HXT probably does it right, then, IMO..
18:02:57 <shapr> benefits to both approaches
18:03:17 <flaw> so XML "dialects" without DTDs floating around, using special "validation" depending on mime type or file extension.. rdf, being a significant one, I guess..
18:03:35 <flaw> so ^many^ XML..
18:03:40 <shapr> yah
18:04:46 <flaw> mmm, would you try this real quick: run DtdToHaskell without args and hit ^C
18:05:32 <flaw> does it cause an internal error for you?
18:05:54 <shapr> no?
18:06:00 <shapr> oh yes
18:06:09 <flaw> k, gonna submit it
18:06:10 <shapr> main thread has been GC'd
18:06:14 <shapr> I think it's known
18:06:18 <flaw> oh, ok
18:06:20 <shapr> but I forget the discussion around it.
18:07:07 <flaw> hrmf, no man pages
18:11:05 <flaw> does it not support remote URIs?
18:13:22 <flaw> xtract is pretty cool
18:13:56 <flaw> very cool :)
18:14:15 <flaw> I've been wanting something like this for a while
18:15:59 <reffie> does haskell have anything like lisp macros?
18:26:53 <jesse> lazy evaluation makes haskell functions pretty macro-like by themselves
18:32:48 <flaw> hrm, shouldn't Xtract '/' xml give the whole document?
18:32:57 <XTL> Wasn't there a cafe thread about that?
18:33:16 <flaw> dunno
18:35:23 <XTL> There was that vise grips talk...
18:36:39 <flaw> also doesn't seem to support text()?
18:36:51 <flaw> oh well, it's fun, nonetheless
18:36:55 <XTL> I think I'm remembering http://www.haskell.org/pipermail/haskell-cafe/2001-May/001849.html
18:37:35 <dons> flaw: the GC ^C message is a well-known issue that arose from the new threaded rts in 6.2.1
18:37:59 <dons> must have been bug report #1 this year :)
18:38:02 <XTL> Really, really should sleep...
18:38:03 <flaw> hehe
19:19:56 * Brrrr just read the example of cyclic lists
19:20:07 <Brrrr> shapr: the example is nice
19:20:39 <Brrrr> but like it is mentioned later
19:20:43 <Brrrr> it is not mutable
19:21:21 <Brrrr> Oleg deals with that later, and I haven't read it yet
19:21:23 <Brrrr> still
19:21:51 <Brrrr> it is an example by "Oleg", so I expect it to be pretty complicated :D
21:21:07 <desrt> how do i get a list of everything in an enum type?
21:22:22 <clausen> good question
21:22:32 <clausen> I've been wondering why programming languages don't treat types as sets
21:22:36 <clausen> (that you can pass around)
21:24:06 <clausen> and allow you to find the image of functions on sets
21:24:14 <clausen> maybe I should write such a language... would be fun :)
21:24:57 <desrt> wtf.  enumerated types don't automatically have == defined?!
21:25:27 <clausen> well, you might want two binary trees to be equal
21:25:30 <clausen> if they have the same keys, for example
21:25:38 <clausen> (and not care about the structure)
21:26:09 <desrt> so if i just have a straight-up enum...
21:27:03 <desrt> oh.  deriving
21:27:05 <desrt> i almost forgot
22:17:58 --- mode: irc.freenode.net set +n
23:10:59 <Leimy> Lehigh as in the Lehigh Valley PA?
23:11:06 <Leimy> or Lehigh University?
23:53:28 <dblhelix> @yow
23:53:30 <lambdabot> Everybody is going somewhere!!  It's probably a garage sale
23:53:30 <lambdabot>  or a disaster Movie!!
