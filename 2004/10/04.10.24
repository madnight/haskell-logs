01:44:19 <musasabi> morning
02:12:25 <Boegel> hello everyone !
02:13:49 <Boegel> netsplit :s
02:14:33 <TheHunter> morning Boegel 
02:15:27 <Boegel> TheHunter, have you seen my progress with my ray tracer ?
02:15:37 <TheHunter> yah, looks really cool.
02:16:20 <Boegel> it looks even cooler now... it already supports multiple lighting, and I'm working on shadows right now...
02:18:41 <Boegel> I'll make some images of the multiple lighting stuff hopefully within the next few minutes, because I don't have much time..
02:21:18 <musasabi> morning Boegel 
02:24:47 <Boegel> hello musasabi 
02:24:57 <Boegel> musasabi, have you seen my progress ? :p
02:25:11 * Boegel is quite proud of his ray tracer
02:36:21 <musasabi> Boegel: yes, looked at the screenshots yesterday, looks really nice.
03:34:52 * shapr yawns
03:37:22 <Lemmih> Good morning, shapr.
03:45:17 <xerox-> hi!
03:45:40 <lyp|log> hows ghc on macosx?
03:46:55 <dons> pretty solid, I believe
03:47:02 <lyp|log> yay:)
03:47:22 <dons> it gets tested nightly on that platform, and has a fair few developers using it
03:48:04 <lyp|log> neat :)
03:48:15 <lyp|log> gonna switch from linux to macosx soon i  think
03:48:20 <lyp|log> want a 12" ibook
03:48:22 <lyp|log> :P
03:48:28 <mornfall> lyp|log: lypanov?
03:48:34 <lyp|log> yoyo mornfall :)
03:48:38 <mornfall> hey hey =)
03:48:45 <mornfall> wondering where will i meet you next ;)
03:48:48 <lyp|log> mornfall: u know my wonderful lappie?
03:48:54 <mornfall> lyp|log: which one?
03:48:58 <lyp|log> the magical dell
03:49:00 <lyp|log> well
03:49:05 <lyp|log> its battery is totally ****ed
03:49:08 <lyp|log> 30 minutes :(
03:49:20 <lyp|log> so i'm pondering just buying a ickle ibook
03:49:24 <mornfall> yeah, i've heard
03:50:07 <lyp|log> hehe
03:50:11 <lyp|log> bobviously ;P
03:50:20 <lyp|log> so what on earth r u doing in haskell? :P
03:50:20 <mornfall> =)
03:50:35 <mornfall> well, i have an introductory haskell course in uni
03:50:40 <mornfall> that, and i like the language
03:51:20 <mornfall> lazy functional goodness ;)
03:51:33 <lyp|log> shame about the evil syntax
03:51:49 <mornfall> hmm, the syntax is quite nice, if you get used to it
03:57:49 <dons> evil syntax -- what aspect?
03:58:55 <shapr> good morning #haskell!
03:59:13 * shapr discovers the problem with scannedinavian
04:00:28 <shapr> whoa, lots of nice yi patches
04:01:47 <dons> shapr: more to come.
04:01:51 <dons> :)
04:01:59 <tic> *sob* I want a stable server! :( My keeps freezing.
04:02:02 <tic> s/my/mine
04:03:10 <shapr> tic: I had zero bytes free on root :-/
04:03:24 <xerox> yi website?
04:03:36 <shapr> xerox: how about a yi wiki in about an hour?
04:03:52 <xerox> it can be good
04:04:45 <dons> wiki is good
04:04:47 <shapr> I wonder if I can move /home to another partition while I'm logged in.. or if something will flip out.
04:05:57 <dons> oh. memcpy doesn't work if memory overlaps on linux
04:06:04 <dons> that explains that, then
04:06:22 <tic> shapr, ick.
04:13:50 <bourbaki> moin
04:13:54 <shapr> y0
04:14:16 <bourbaki> shapr: did you read one of the ANN tuts i gave you?
04:14:26 <shapr> um, no?
04:14:32 <shapr> but I did read the wikipedia stuff.
04:14:40 <bourbaki> ah ok
04:14:56 <shapr> As usual, I got distracted again, but I remembered enough to have some questions left over.
04:15:00 <lyp|log> dons: memmove...
04:15:33 <shapr> Last I played with neural networks, each neuron had N inputs and a weight for each
04:15:53 <shapr> so each input is multiplied by its weight, and then something, either sum or average is put through the sigmoid function
04:15:55 <bourbaki> shapr: yes thats the usual neural net
04:15:56 <shapr> but which is it?
04:16:03 <dons> lyp|log: yep.
04:16:09 <bourbaki> normal feed forward network
04:16:43 <lyp|log> shapr: remind me not to try and tackle persistant undo/redo again btw
04:16:51 <lyp|log> shapr: its held back my editor development for months
04:16:53 <bourbaki> and i can do the forward feed already with the stuff ive done just the backpropagation forces me to modify the weight functions
04:16:54 <shapr> heh, ok
04:17:04 <lyp|log> shapr: i've finally decided to disable and just release :(
04:17:55 <dons> release often, release early.
04:18:03 <lyp|log> i try :)
04:18:06 <shapr> release every day
04:18:10 <shapr> just keep the source repo open
04:18:40 <lyp|log> i do dont worry :P
04:18:46 <lyp|log> however it used to be arch repo
04:18:50 <dons> shapr: ok we can edit /usr/share/dict/words now with now probs
04:18:53 <lyp|log> and noone could get the damn thing to work
04:18:54 <lyp|log> oh
04:19:03 <lyp|log> shapr: i do darcs tag --checkpoint
04:19:07 <lyp|log> shapr: and --partial works?
04:19:16 <lyp|log> shapr: so i should prob stick this in my release script right?
04:19:29 <shapr> dons: awesome
04:19:38 <shapr> lyp|log: partial works for what?
04:20:47 <lyp|log> shapr: get. to reduce download time
04:21:48 <mattam> i get stack overflow if i try yi /usr../words
04:21:58 <Lemmih> Bzzt. Shouldn't Control.Exception.catch catch all exceptions?
04:22:05 <dons> please grab the latest 3 or 4 commits
04:22:27 <dons> catch does. yes. hence catchJust
04:24:13 <mattam> dons: still the same, i have a default stack size of 1048576 bytes
04:24:26 <Lemmih> Then why does this throw an exception: catch (return $ [1,2]!!2) (\e -> return 0)?
04:24:44 <dons> mattam: did you pull the memmove patch?
04:24:52 <mattam> yes
04:25:01 <dons> ghc version?
04:25:02 <mattam> should i make clean ?
04:25:13 <dons> yep. make distclean even.
04:25:20 <shapr> mattam: the memmove patch from 16 minutes ago? :-)
04:25:26 <mattam> yes
04:25:28 <shapr> ok
04:25:33 <mattam> 6.2.
04:25:45 * shapr keeps forgetting to do darcs pull every half hour
04:25:50 <dons> 6.2.x where x == ?
04:25:55 <mattam> hmm, something's wrong
04:26:13 <mattam> 6.2
04:26:23 <mattam> do i need 6.2.2 ?
04:26:45 <dons> no, don't think so. if you're on linux
04:26:55 <mattam> i am
04:27:11 <mattam> my words is 2.5 megabytes
04:27:12 <dons> as this stack issue is what the last patch was for, could you get the repo again and try afresh?
04:27:20 <shapr> whoa, retro green-on-black now
04:27:30 <dons> yep. should have no probs with at least 5M
04:27:30 <mattam> first i'll try distclean
04:27:32 * shapr considers hacking up a yi-theme package
04:27:33 <dons> shapr: ?
04:27:40 <dons> it should just be using the defaults
04:27:53 <shapr> that's my default.
04:27:57 <dons> until I figure out a color edsl
04:28:06 <dons> also, more of a vi feel :)
04:28:32 <shapr> yah, one bug I notice is that inserting into an empty file means that the first two letters are swapped in order
04:28:51 <dons> yeah. we don't insert \n into [] by default, as vi does
04:28:55 <dons> should fix that
04:29:24 <dons> vi is a bit magic in that respect
04:30:17 <dons> shapr: if you insert a \n first, then all is as expected?
04:30:24 * shapr tries
04:30:32 <shapr> yup
04:30:35 <shapr> that's sorta weird
04:31:04 <dons> no. eol issues. can't progress past the first char, so has to insert before it
04:31:17 <dons> either insert \n by default (like vi) or write some more code
04:32:29 * dons is going to walk through vi emulation bit by bit
04:32:30 <shapr> does hs-plugins works on amd64?
04:32:41 <dons> no, we don't have ghci ported yet
04:32:45 <dons> i.e Linker.c ported yet
04:32:46 <shapr> oh..
04:32:56 <dons> but if you run it in 32 bit mode ...
04:33:00 <shapr> ok
04:33:06 <shapr> yi-static will still work though?
04:33:12 <dons> should work everywhere
04:33:15 <shapr> spiffy
04:33:40 <dons> why, you thinking of switching ;) ?
04:33:48 <dons> once scrolling works..
04:34:05 <mattam> bah, it's just yi that was failing, yi-static works
04:34:24 <mattam> they don't differ only in linking style ?
04:34:40 <dons> umm.. yes. but that's a whole lot
04:35:00 <mattam> ok
04:35:02 <dons> it means we can dynamically eval haskell
04:35:14 <dons> but we can't in yi-static -- so you can't change any settings from their defaults
04:36:06 <dons> so you're getting a stack overflow with 6.2, in yi, but not yi-static?
04:36:33 <mattam> yep
04:37:09 <dons> does it boot into the gui? (i.e. prints ".. done")
04:39:05 <mattam> i can't see if it prints .. done so i suppose it does (the screen is cleaned)
04:39:52 <dons> does it start on files other that dict?
04:40:17 <mattam> yes
04:40:58 <dons> ok. that's good then. some space issue related to dynamic loading
04:41:08 <dons> that's something i can deal with.
04:41:12 <mattam> :)
04:41:20 * mattam goes to take a shower
04:41:42 <dons> yi isn't that messy ;)
04:55:28 <mattam> :)
05:03:35 <Lemmih> Lazy evaluation can be tricky when dealing with exceptions.
05:06:05 <musasabi> Is it possible to implement a counter arrow with the (->) instance of arrows? (that is it would produce the values 1,2,3,... and discard it's input)
05:10:17 <dons> Lemmih: yep. Control.Exception.evaluate can help
05:12:02 <Lemmih> dons: Changing '$' to '$!' fixed it.
05:14:58 <Lemmih> Weird. GHC can't find HSQL if it's compiled with -prof /-:
05:15:44 <shapr> ok, I think I found the problem with Scannedinavian... something is flooding my attack detector logfiles at an insane rate. At least one of the hosts on my colo network has an MS-SQL worm, not sure if that's the problem.
05:16:45 <dons> Lemmih: not putting the right suffix on the libraries?
05:17:06 <Lemmih> eh?
05:17:27 <dons> ghc won't find it if the libraries don't have _p.a suffixes
05:17:39 <Lemmih> oh.
05:17:41 <dons> and normal objects need .p_o and .p_hi
05:18:01 <dons> this is a bit of a pain. you could look at the way == p code in yi's Makefiles
05:20:26 <Lemmih> I'm not sure how to fix it.
05:20:57 <dons> shapr: abstracting the editor behaviour into the keymap is cool. you can encode things like the vi-"\n on empty file"  behaviour into the Keymap.hs
05:21:27 <Lemmih> Can I just rename HSsql.o?
05:21:28 <dons> or, using a real language as the config language is very powerful
05:21:50 <dons> should be able to. if you rename the library .a and .o, and .hi correctly, that might work
05:27:18 <Lemmih> Yay. It worked.
05:30:01 <dons> it's fun watching vi take 9 seconds to load a 25M file, and yi takes 1.5s
05:30:05 <dons> laziness rules
05:30:41 <lyp|log> dons: is it mmaped?
05:30:53 <lyp|log> dons: what about going to end of file. or specific line number?
05:31:02 <dons> hmm. vim takes 4seconds
05:31:33 <dons> lyp|log: memcpy from a handle in yi's case.
05:31:37 <lyp|log> dons: is i5 synhlíng?
05:31:44 <lyp|log> s/i5/it/
05:32:11 <dons> synching?
05:32:22 <lyp|log> syntax highlighting
05:32:23 <lyp|log> sorry
05:32:32 <dons> nope, not yet. 9 days old :)
05:32:39 <lyp|log> :P
05:32:56 <lyp|log> dons: the first thing i implement was synhl :P
05:33:04 <lyp|log> dons: before it was even possible to edit :P
05:33:28 <dons> we've got some plans, but the design isn't sorted yet
05:33:35 * lyp|log doesn' even want to know how long his would take to load 25mb file
05:33:46 <lyp|log> lets say, an hour, and then it'd crash :P
05:33:51 <lyp|log> (no laziness whatsoever)
05:33:55 <dons> lyp|log: what's it written in again?
05:33:59 <lyp|log> ruby
05:34:10 <dons> but still, can't you do mmap underneath?
05:34:14 <lyp|log> of course
05:34:21 <lyp|log> but its just for editing ruby code
05:34:27 <lyp|log> and if you have a ruby file of 25mb
05:34:32 <lyp|log> you should get lost anyway :P
05:34:42 <dons> yeah, sure. i just love optimising boundary conditions :)
05:34:48 <lyp|log> hehe
05:34:49 <lyp|log> me 2
05:34:52 <lyp|log> in the same of ruby
05:34:53 <lyp|log> its a must
05:34:59 <lyp|log> you *have* to have good algms
05:35:02 <lyp|log> or your screwed
05:35:10 <lyp|log> *in the case of ruby*
05:35:18 * lyp|log cant type anymore
05:35:33 <dons> ok. no giant ghc compiler to turn all the crud into gold ?
05:35:46 <lyp|log> dons: im working on that also
05:35:53 <lyp|log> dons: but editor takes prio at the moment
05:36:03 <lyp|log> dons: vim got farrrr too frustrating
05:36:04 <dons> :)
05:36:34 <lyp|log> i can execute a pretty simple subset of ruby already
05:36:54 <lyp|log> the interpreter is 2kloc' of pure ruby
05:37:53 <Jan_w> List> [1,2,2,3,4] \\ [1,2]
05:37:53 <Jan_w> [2,3,4]   
05:38:27 <Jan_w> is there a operator to remove all instances in stead of 1 ?
05:40:34 <dons> oh, this is nice. 64M takes 3s in yi, vim 9s, vi 23s. 8 emacs
05:40:57 <dons> 0.5s in less
05:41:07 <dons> ;)
05:41:54 <dons> Jan_w: check out Data.List for this kind of stuff
05:42:04 <Jan_w> I am :)
05:44:06 <Lemmih> hmake is too smart.
05:44:23 <Lemmih> Or at least it think it is.
05:44:26 <dons> hehe
05:45:23 <Lemmih> It wont allow me to compile stuff that needs the .p_hi /-:
05:48:22 <dons> hmm. maybe hmake doesn't understand profiling very well
05:48:22 * Lemmih is back on --make
05:48:31 <dons> or you could write some make rules
05:48:45 <Lemmih> Maybe it doesn't understand profiling at all.
05:48:58 <dons> HC_OPTS     += -hisuf $(way_)hi -hcsuf $(way_)hc -osuf $(way_)o
05:49:05 <Jan_w> hm, strangly I can't find such a thing (remove all occurrences from a list), i'll write something then :)
05:49:21 <dons> filter?
05:49:42 <Lemmih> Jan_w: 'nub lst \\ otherlst'
05:50:08 <Jan_w> Lemmih: oh, i could use that, indeed
05:50:20 <Jan_w> didn't think of that
05:51:29 <Jad> what is the most efficient way to implement length ?
05:52:29 <dons> cache the length with the list
05:52:36 <dons> O(1) length then
05:52:47 * dons doesn't use length in yi
05:54:18 <Lemmih> Yay. I can now profile my HaskellDB apps (-:
05:55:45 <Lemmih> Time: 50% used in 'tok', 50% used in 'spaces'.
05:56:27 <dons> cool. profiling rules
05:58:15 <Lemmih> Wow. I made hmake fail with 'Prelude.tail: empty list' (-:
06:00:30 <Lemmih> dons: It doesn't understand '-hisuf p_hi'.
06:01:26 <dons> ghc?
06:01:48 <dons> or does hmake interpret that flag?
06:02:21 <Lemmih> I think it's ignoring it because it's trying to compile 'p_hi'.
06:02:57 <dons> silly hmake
06:08:14 <Lemmih> Profiling + O2 + 10K haskell code = time for food.
06:08:22 <dons> hehe
06:08:31 <dons> for sure.
06:15:39 <Lemmih> Is there a fast way of parsing escaped strings?
06:18:08 <dons> read?
06:18:17 <dons> depends on what you want to parse them to
06:18:25 <dons> read is slow
06:18:35 <dons> you could write an alex lexer
06:18:47 <dons> or a nice little loop, depending on how complex the parsing
06:27:03 * Lemmih dreams of a Haskell apache module.
06:27:22 * shapr dreams of dreaming
06:32:12 <Lemmih> Is Cabal going to making it easier to compile libraries with profiling enabled?
06:36:43 * Lemmih looks around for SyntaxNinja and Marvin--
07:18:14 <Lemmih> shapr: When will the postgreSQL server be running on scannedinavian.org?
07:18:23 <shapr> it's back
07:18:28 <shapr> but it needs some help
07:18:46 <Lemmih> How so?
07:18:48 <shapr> I'm cleaning out the 1.5 gigabytes of worm attack logs
07:19:55 <vivek> shapr: run D 
07:20:29 <vivek> or is it called tutorial D ...
07:21:50 <Lemmih> Hello goron
07:22:08 <goron> hi Lemmih
07:22:20 <vivek> hiya goron 
07:22:38 * goron greets all :)
07:22:48 <shapr> vivek: HaskellDB is much better than tutorial D, imho
07:23:04 <shapr> and pretty much the same idea as well.
07:23:36 <Lemmih> What's tutorial D?
07:23:38 <vivek> shapr: run haskelldb on ur server 
07:23:43 <shapr> vivek: I do!
07:23:55 <vivek> its a new generation database Lemmih 
07:24:13 <shapr> tutorial D is another database UNwrapper
07:24:19 <shapr> but HaskellDB got there first :-P
07:24:35 <vivek> shapr: do u have all the published deadtree books on haskell ?
07:24:42 <shapr> no
07:24:46 <shapr> I only have three.
07:25:07 <vivek> which are the three /
07:25:09 <vivek> ?
07:25:14 <Lemmih> What's tutorial D written in?
07:25:23 <vivek> c Lemmih 
07:25:36 <vivek> there are different implementaions 
07:25:42 <shapr> tutorial D is meant to replace SQL.
07:25:44 <vivek> its opensource 
07:26:07 <vivek> will it ? thats a different question ...
07:26:36 <Lemmih> So it's a query language like SQL?
07:26:44 <shapr> I don't care, as long as people realize that SQL is not database, but instead set theory is databases.
07:27:27 <kristnjov> "structured query language" was it not?
07:27:45 <goron> Not completely, I think. What about two tuples that are the same?
07:30:07 <shapr> goron: you mean that databases function via identity rather than value equality?
07:30:50 <goron> shapr: I think that's how you say it formally, yes.
07:31:28 <goron> shapr: Although "function" is more, than this,
07:31:36 <tromp> g'afternoon
07:31:47 <shapr> hoi tromp 
07:31:49 <shapr> goron: how so?
07:32:52 <goron> shapr: Well, I only wanted to say that a set of tuples!=database in practice. Although a database is theory == set of tuples.
07:33:06 <goron> is->in
07:33:28 <shapr> yes, I agree.
07:33:32 <lyp|log> is tutorial d actually any good?
07:33:42 <kristnjov> if it's to replace SQL it'd better be good
07:33:44 <lyp|log> tromp: ummm where abouts r u? :)
07:33:54 <tromp> amsterdam
07:33:59 <lyp|log> tromp: kruislaan? :P
07:34:08 <tromp> kruislaan 413
07:34:10 <lyp|log> hehe
07:34:11 <shapr> kristnjov: just expose set theory directly in the language, imho that's a better approach.
07:34:18 <shapr> HaskellDB does that.
07:34:31 <kristnjov> shapr, i'm not very into any database language at all, so i can't really argue with you there
07:34:33 <lyp|log> tromp: i used to work in the twinning building
07:34:39 <lyp|log> tromp: yay for startups :P
07:34:50 <tromp> for which company?
07:34:54 <lyp|log> eidetica
07:35:07 <shapr> kristnjov: honestly, SQL isn't all that good. It was great when it was invented, but nowadays it's not very impressive.
07:35:11 <tromp> ah, i know some ppl there
07:35:15 <lyp|log> hehe
07:35:20 <kristnjov> shapr, it's fast, that's for sure :O
07:35:21 <tromp> i think they also left:)
07:35:24 <lyp|log> yup
07:35:29 <lyp|log> u knew mr groenink?
07:35:37 <tromp> sure, he used to be here at cwi
07:35:40 <lyp|log> yup :P
07:35:48 <tromp> and jan vd steen
07:35:58 <lyp|log> he left at same time as i arrived unfortunately
07:36:03 <lyp|log> so i never had the pleasure :(
07:36:06 <Lemmih> shapr: So when will scannedinavian be back up?
07:36:27 <lyp|log> tromp: was plenty of fun while i was there tho :)
07:36:57 <tromp> they don't use haskell though, do they?
07:37:09 <lyp|log> nop
07:37:14 <lyp|log> c principally
07:37:18 <lyp|log> suckers
07:37:34 <lyp|log> shame :(
07:37:41 <shapr> Lemmih: I'll bring postgresql back up now, but it'll still be crawlingly slow until my ISPs network fixes whatever is wrong.
07:38:20 <lyp|log> tromp: really good coders admittedly but too pragmatic with little future insight...
07:39:12 <shapr> OlÃ¡ jadrian 
07:39:17 <jadrian> hi shammah 
07:39:20 <jadrian> hi shapr 
07:39:22 <jadrian> :-/
07:39:51 <tromp> i'd expect them to use some scripting languages at least
07:40:07 <shapr> Lemmih: it's back up, but I don't have time to install the latest version of Hackage right now, probably won't for several hours.
07:41:08 <tromp> stijn van dongen worked there too
07:41:18 <tromp> very nice guy
07:42:25 <lyp|log> tromp: php for webpages
07:42:36 <lyp|log> tromp: i used ruby for some of the later stuff for prototyping
07:42:48 <lyp|log> tromp: python for some random stuff
07:44:11 <tromp> ruby is nicest scripting lang
07:47:02 <lyp|log> tromp: :)
07:47:11 <lyp|log> tromp: im writing vim clone in ruby atm
07:47:17 <shapr> try yi!
07:47:21 <lyp|log> tromp: and soon i'll get back into a project i started a while back
07:47:22 <shapr> yi yi!
07:47:27 <lyp|log> ruvi ruvi! :P
07:47:37 <lyp|log> tromp: rewriting ruby :P
07:47:41 <lyp|log> tromp: (in ruby of course)
07:47:53 <Lemmih> Why is it called yi?
07:48:02 <lyp|log> tromp: that reminds me. cwi should be funding me to do this so i can stop doing it in my minimal amount of spare time :/
07:53:24 <tromp> cwi is not too interested in having the ruby interpreter rewritten:(
07:53:40 <lyp|log> tromp: :(
07:54:00 <lyp|log> tromp: wish i could find someone interested :(
07:54:20 <tromp> well, where does matz work?
07:54:29 <lyp|log> netlab.jp
07:54:32 <lyp|log> iirc
07:54:43 <tromp> maybe they'll fund you?
07:54:43 <lyp|log> .nl is a bit nearer :P
07:55:11 <tromp> don't u want to rewrite the ruby interpreter in haskell?
07:55:21 <lyp|log> tromp: maybe i should write a paper on my approach and send it around everywhere :)
07:55:43 <lyp|log> tromp: thats kind of like asking for a haskell interpreter to be written in ruby :P
07:55:53 <lyp|log> ghc is written in haskell right?
07:55:56 <lyp|log> i hope to hell it is
07:56:20 <musasabi> yes it is.
07:56:20 <lyp|log> gotta be as iirc it needs a bootstrap
07:56:24 <lyp|log> phew :)
07:56:36 <lyp|log> no serious language would ever consider being written in anything but itself
07:56:43 <tic> heh, Python. :)
07:56:46 <lyp|log> c++ being a good example of a non serious language...
07:56:50 <lyp|log> tic: pypy :)
07:56:58 <tic> yeah, was just wondering how far they've come
07:57:04 <lyp|log> or rather gcc/c++ being a good example
07:57:43 <jadrian> hmm why...
07:57:49 <lyp|log> its a joke
07:58:00 <jadrian> ok :)
07:58:08 <lyp|log> i mean gcc/c++ is a joke
07:58:15 <lyp|log> rather than what i said being a joke :P
07:58:19 <tuomov> not much point in writing a byte-code interpreter for a language that isn't compiled in itself..
07:58:43 * lyp|log isn't writing a bytecoded interpreter luckily :>
07:58:47 <lyp|log> bytecode is silly
07:59:34 <lyp|log> tuomov: the idea that your implementation can't help your implementation just makes me want to cry
07:59:45 <lyp|log> if you get me :)
08:01:23 <lyp|log> tromp: is cwi really that into haskell? pretty impressive :)
08:01:43 <lyp|log> tromp: can i ask what u work on if you don't mind/
08:01:49 <lyp|log> s/\//?/
08:03:15 <tromp> u can see some stuff on my homepage
08:03:51 <tromp> cwi has ralf lammel who is seriously into haskell
08:04:43 * lyp|log kicks his dns server
08:05:01 * lyp|log adds some urls to his todo list
08:05:11 <lyp|log> tromp: i'll take a look later... dns dead :/
08:12:51 <goron> I just found out Konsole>>xterm.
08:13:50 <lyp|log> konsole rocks
08:14:03 <lyp|log> only sane terminal prog imo
08:14:20 <lyp|log> (yer i need tabs)
08:16:05 <goron> You can look it like xterm (with letters that are readable on a 17" CRT @ 1600x1200).
08:16:30 <goron> can let it look like
08:17:07 <lyp|log> i use mono sans at 14 pixel
08:17:30 <lyp|log> and occasionally when my glasses are clean and im not in headachey time of year
08:17:36 <lyp|log> i use profontwindows 9 point
08:18:50 <TheHunter> pah, nothing beats urxvt + screen.
08:19:03 <lyp|log> TheHunter: i have screen's in my tabs
08:22:42 <Jad> any one aware of a haskell to html app ?
08:23:43 <earthy> WASH?
08:24:19 <earthy> or did you mean a literate program formatter?\
08:27:32 <Jad> something like c2html
08:27:36 <Lemmih> Jad: Like pretty printing or dynamic website generation?
08:28:08 <Lemmih> Oh.
08:35:53 <jadrian> back
08:36:03 <musasabi> isn't there a tuple constructor in the standard library?
08:36:11 <musasabi> tuple a b = (a,b) ?
08:36:47 <Etaoin> it's called (,) I think
08:37:26 <musasabi> thanks
09:05:47 <Jad> Lemmih, yes
09:11:02 <kristnjov> does anyone have the code for an instance of arbitrary string?
09:23:34 <Lemmih> kristnjov: Eh?
09:23:43 <kristnjov> never mind
09:26:22 <xkb> hi
09:26:33 <xkb> anyone of you guys here using throwDyn/catchDyn?
09:59:58 <Lemmih> Yay. You can now update entries in Hackage.
10:03:24 <Lemmih> @seen shapr
10:03:28 <lambdabot> shapr is in #webwitches and #haskell.se.
10:27:45 <bourbaki> moin
10:27:50 <Lemmih> Hey bourbaki
10:28:18 <bourbaki> hows it going Lemmih?
10:30:02 <Lemmih> It's going great. Just finished coding another feature in Hackage.
10:30:18 <bourbaki> hackage?
10:31:07 <Lemmih> Package listing webpage.
10:31:19 <Lemmih> Preview: http://localhost/cgi-bin/web/Main
10:31:22 <bourbaki> ah ok
10:31:30 <bourbaki> :)
10:31:36 <bourbaki> localhost?
10:31:38 <kolmodin> :)
10:31:41 <Lemmih> D'oh
10:31:45 <bourbaki> did you hack my box ?
10:31:47 <Lemmih> Preview: http://212.242.49.100/cgi-bin/web/Main
10:39:13 <Lemmih> Feedback would be greatly appreciated.
12:04:55 <ez4> is there an infix operator to join two strings with a space between?
12:05:18 <stepcut> ++" "++
12:05:20 <stepcut> :p
12:05:24 <lypanov> yoyo stepcut 
12:05:36 <ez4> ouch.  i guess i'll define one
12:05:45 <lypanov> stepcut: how's the stuff with arch going? :P
12:05:49 <Lor> ez4, if you're doing string generation, you might want to use a pretty printing library.
12:05:54 <lypanov> stepcut: i gave up and switched to darcs in the end :)
12:05:56 <stepcut> lypanov: which stuff with arch ? 
12:06:09 <ez4> is there one for haskell?
12:06:32 <lypanov> stepcut: umm major confusion. nm :) thought u were at lindows..
12:06:37 <Lor> Text.PrettyPrint
12:06:42 <ez4> thx
12:06:48 * lypanov looks baffled
12:07:08 <stepcut> lypanov: I am at linspire (aka lindows), and I do do stuff with arch all the time.. I thought you where refering to something specific...
12:07:28 <lypanov> stepcut: ages ago we chatting about kde arch repo
12:07:51 <stepcut> lypanov: we have an internal one, we are not quite ready to open to the outside world yet
12:08:01 <lypanov> stepcut: oh. good to hear though :)
12:08:08 <stepcut> lypanov: also, we may want to coordinate with ubuntu now...
12:08:20 <lypanov> stepcut: yeah i noticed you were in ubuntu just now
12:08:29 <lypanov> stepcut: i'm using it btw :P pretty impressed
12:08:45 <stepcut> lypanov: I haven't gotten around to installing it yet :-/
12:08:52 <lypanov> stepcut: have fun :P
12:11:21 <lypanov> gotta run
12:11:26 <stepcut> cya
12:11:27 <lypanov> stepcut: nice to know that ur using internally :)
12:11:32 <lypanov> stepcut: cya :)
12:15:54 <Jad> any one know an app like c2html for haskell
12:16:17 <Jad> ie : an app from haskell an html page with coloured syntax ?
12:21:41 <stepcut> Jad: I then there is a moin wiki plugin that does that. Maybe it has some stand-alone code that you can use ?
12:29:07 <Jad> stepcut, will check out..
12:30:27 <Jad> I think it is simpler if i Write one..
12:30:27 <xkb> Jad,  or use lhs2tex and tex2html
12:30:42 <Jad> xkb, tnx.
12:30:46 <xkb> I admit, the route is a bit longer :d
12:31:23 <Jad> xkb, I don`t write literate haskell code..
12:31:39 <xkb> you should start it :)
12:32:05 <Jad> !
12:32:34 <Jad> libipq should be ported to haskell
12:33:39 <xkb> ipq?
12:35:04 <goron> Is there a wiki already for Yi? I saw some logs about that.
12:48:59 <musasabi> Is there a way to refer to errno via the ffi ?
12:50:23 <Boegel> hello everyone !
12:50:34 <stepcut> hello
12:50:59 <Boegel> I got shadows working in my ray tracer, too see it: http://studwww.ugent.be/~kehoste/thesisPublic/website
12:51:21 <stepcut> musasabi: good question, I think so. At worst, you could write a function that returns errno, and call that...
12:51:35 <Lor> It's better that way.
12:51:47 <Lor> errno is not necessarily an external variable.
12:51:50 <sorje> Boegel, cool! And you're progressing very fast!
12:52:05 <Boegel> sorje, this step was quite simpel
12:52:08 <stepcut> musasabi: there are also issues about errno being changed... with lazy eval, that seems like a pain
12:52:27 <Boegel> sorje, my model I set it up is quite good, so the new features aren't muc work
12:52:37 <Boegel> s/muc/much
12:53:10 <sorje> Boegel, when did you start writing on it?
12:53:10 <Boegel> next up is specular reflection
12:53:31 <stepcut> musasabi: if you call a function via the ffi, that can set errno, I think you also need to get the errno value during that ffi call or it will be useless
12:53:33 <Boegel> sorje, I don't know really
12:53:43 <Boegel> let's see my history log :)
12:54:25 <Boegel> sorje, round 1 October
12:54:32 <Boegel> sorje, round 1st of October :)
12:55:17 <sorje> Nice, just about 24 days
12:55:57 <Boegel> sorje, something like that
12:56:05 <Boegel> but I don't work on it every day...
12:56:29 <Boegel> since 1st of October I worked on it 15 days orso
12:56:37 <Boegel> 2-4 hours a day
12:56:57 * Boegel wil be back in 15m
12:57:04 <Boegel> s/wil/will
12:58:06 <xkb> hmm simple question: data DBexception = DBError String followed by throwDyn (DBError "db connection failed") should work right?
12:58:27 <xkb> where DBexception is deriving Typeable and Show
13:01:08 <stepcut> xkb: i believe so..
13:01:46 <xkb> ah.. never mind.. typo
13:01:48 <xkb> sigh
13:02:07 <stepcut> heh
13:02:26 <xkb> BDError instead of DBError :d
13:02:30 <stepcut> hehe
13:02:43 <stepcut> maybe yi should have an autocorrect mode
13:02:45 <xkb> I think I need to quit coding for today :d
13:02:55 <xkb> stepcut, good idea 
13:03:00 <xkb> did you find the wiki yet?
13:03:15 <stepcut> I was not looking for one, so no...
13:04:35 <xkb> oh.. that was 
13:04:36 <xkb> goron>	Is there a wiki already for Yi? I saw some logs about that.
13:04:43 <xkb> my bad
13:04:59 <stepcut> xkb is 0 for 2 so far
13:05:12 <xkb> bad score today
13:05:32 <xkb> I'm gonna watch the telly.. 
13:05:37 <xkb> time to relax
13:05:39 <stepcut> hehe
13:11:30 <musasabi> stepcut: well lazyness is not a problem.
13:11:47 <musasabi> stepcut: but how to refer to a global C variable.
13:12:28 <Lor> It is _not_ a global C variable.
13:13:14 <Lor> it "expands to a modifiable lvalue that has type int"
13:13:29 <Lor> The spec defines it as a _macro_.
13:13:45 <Lor> And e.g. newer glibc's do bloody well make use of this.
13:13:57 <Lor> (each thread has its own errno)
13:15:52 <stepcut> musasabi: I am not sure how you can say laziness is not a problem, but if you really did have a global c variable you might do it this way:
13:16:08 <stepcut> (1) write a function that returns a Ptr a to the global variable
13:16:43 <stepcut> use Foreign.Storable.peek to look at the value pointed to by the pointer
13:17:32 <stepcut> ^(2)
13:18:34 <stepcut> laziness aside, if you do one ffi call, which fails, and then do a second one, that gets errno, I have a hard time believe errno will still be set correctly
13:19:17 <Lor> Anyway, the right way is just to have a wrapper that calls the errno macro, with type IO Int
13:19:34 <Lor> Well, all right, it's a lvalue, so you could theoretically want to set it, too.
13:19:53 <Lor> setErrno :: Int -> IO (), but I don't see any point.
13:21:14 <Lor> Hm, apparently the spec recommends sometimes resetting it manually to zero and then checking it after a library call.
13:21:31 <Lor> But all standard library calls indicate that an error occured in their return value.
13:29:39 <Boegel> CosmicRay, new progress: http://studwww.ugent.be/~kehoste/thesisPublic/website
13:30:04 <CosmicRay> cool
13:30:30 <Boegel> :)
13:42:27 <Boegel> system crash :s
13:43:15 <stepcut> suck
13:43:30 <stepcut> hrm, I wonder if mirc on win2k does unicode 
13:43:38 <mattam> what's the syntax for multiple patterns ? (like this : case a of Foo _ | Bar _ -> smth; Baz -> smth else)
13:44:42 <Lor> There is none.
13:44:42 <Lemmih> You can't do that.
13:44:48 <mattam> oh
13:45:16 <mattam> is there something similar ?
13:45:38 <CosmicRay> you could define a shortcut function
13:45:48 <mattam> that's what i'm going to do
13:45:59 <mattam> if there's nothing else
13:46:04 <Lemmih> isFoo a || isBar a = smth
13:48:02 <Lor> That doesn't work if you want to do actual pattern matching and bind variables.
13:48:03 <tromp> in your example you can match on Baz and _
13:48:31 <mattam> i prefer a separate function, it makes more sense here, but multiple patterns would be a nice addition.
13:48:51 <mattam> tromp ?
13:49:05 <tromp> as long as there's only one group of multipatterns, you can lump them together in a final _ match
13:49:54 <mattam> oh yeah, but i have two :)
13:50:00 <Lor> http://www.oefai.at/~markus/ocaml_sources/pure-fun-1.0.4/chp3.ml
13:50:05 <tromp> 2 groups?
13:50:13 <Lor> This is the classic example, look at "balance" in RedBlackSet.
13:50:37 <tromp> well, then i suggest you lump the biggest group under a final _
13:50:55 <tromp> and spell out the other group
13:52:05 <tromp> @type (<)
13:52:06 <lambdabot> (<) :: forall a. (Ord a) => a -> a -> Bool
13:52:19 <Lor> In haskell, the best you can do is replace each branch with "f a x b y c z d" and then add a "where f a x b y c z d = T (R, T (B, a, x, b), y, T (B, c, z, d))"
13:54:08 <mattam> this is from Okasaki i guess :)
13:54:14 <Lor> Yep.
13:55:14 <Lor> Sorry, T R (T B a x b) y (T B c z d) in Haskell.
14:06:06 <xerox> are the mailing lists @haskell.org active?
14:07:58 <CosmicRay> whoa ghc on this alpha is way damn slow
14:18:13 <Oejet_> Boegel: Nice pictures!
15:39:15 <Jan_w> can i get the current time in hugs?
15:40:18 <monochrom> @info Time.getClockTime
15:40:20 <lambdabot> -- System.Time.getClockTime is a variable
15:40:20 <lambdabot> System.Time.getClockTime :: IO System.Time.ClockTime
15:40:38 <Jan_w> thanks
15:41:07 <monochrom> Also look for Time.toCalendarTime
15:43:36 <Jan_w> hm
15:43:56 <Jan_w> is gives IO result, but prints nothing
15:44:06 <monochrom> It prints nothing.
15:44:51 <monochrom> But you can apply toCalendarTime to the result to get a record of year month day hour minute second etc.
15:45:17 <monochrom> Anyway the Time module should contain all the utilities you need.
16:15:37 <Jan_w> hm, 
16:16:13 <Jan_w> I have a recursive list, like [[[Int]]] but i'm not sure how deep it is
16:16:43 <Jan_w> can i somehow keep recursive until i nolonger encounter a list ?
16:16:50 <Jan_w> recursing
16:17:38 <Jan_w> basicly i need something like showList :: [a] -> String and  showList :: a -> String 
16:18:41 <Jan_w> is that allowed in haskell, the same function name with different parameters ?
16:19:53 <Lemmih> Overloading is possible via type classes.
16:20:00 <Jan_w> or can i somehow findout the type of a variable ?
16:20:07 <Jan_w> instanceof kind of thing
16:21:06 <Jan_w> Lemmih: type class, hm, i have done that somewhere before, checking
16:24:18 <Lemmih> I'm not sure what you're trying to do.
16:26:48 <Lemmih> [[[Int]]] is an already instance of show.
16:26:59 <Lemmih> *already an
16:29:16 <Jan_w> Lemmih: i want to group the lists so the lowest level is:
16:29:23 <Jan_w> [1,2,3]
16:29:23 <Jan_w> [1,2,3]
16:29:26 <Jan_w> etc.
16:29:38 <Jan_w> for level 2
16:29:40 <Jan_w> [1,2,3]
16:29:41 <Jan_w> [1,2,3]
16:29:44 <Jan_w> \n
16:29:45 <Jan_w> [1,2,3]
16:29:46 <Jan_w> [1,2,3]
16:30:06 <Jan_w> etc..
16:30:07 <Lemmih> eh?
16:30:37 <Jan_w> i'll no-paste an example , one moment
16:33:24 <Lemmih> @wiki HaskellIrcPastePage
16:33:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:34:04 <Jan_w> oh
16:34:05 <Jan_w> http://rafb.net/paste/results/E3M8dl37.html
16:34:17 <Jan_w> noticed your link a little late :)
16:37:58 <Lemmih> I don't understand. Could you post a simpler example?
16:41:12 <Jan_w> I'll make one
16:43:35 <Lemmih> Sorry. Gotta go now.
16:45:11 <Jan_w> Lemmih: k
16:45:28 <Jan_w> thanks anyway, http://rafb.net/paste/results/k8PlXJ39.html here it is, if you're still here
16:46:34 <arjanb> so you want make another show function that only puts the inner most list on a single line?
16:47:23 <Jan_w> arjanb: yes
16:47:47 <Jan_w> problem being that i don't know how deep it will be
16:48:57 <arjanb> look one page down haskell paste page, there is a similar problem with tuples
16:55:14 <Jan_w> hm, ok
16:55:39 <Jan_w> you mean the NestedOp  class ?
16:56:13 <arjanb> yes
17:41:26 <jadrian> hello
17:41:40 <jadrian> In ghc foldl is defined as,
17:41:58 <monochrom> That crashes his computer.
17:42:06 <jadrian> foldl f z xs = lgo z xs
17:42:06 <jadrian> 	     where lgo z []     =  z
17:42:06 <jadrian> 	   	   lgo z (x:xs) = lgo (f z x) xs
17:42:20 <jadrian> ...
17:42:23 <Pseudonym> Hmmm.
17:42:25 <jadrian> is this common practice?
17:42:29 <Pseudonym> Yes.
17:42:39 <jadrian> how worth it is it?
17:42:42 <Pseudonym> In STG-based implementations, anyway.
17:42:52 <jadrian> STG?
17:42:59 <Pseudonym> Spineless Tagless G-Machine.
17:43:20 <Pseudonym> Back in the days of G-machine implementations, it was more common to see this:
17:43:25 <Pseudonym> foldl f z [] = z
17:43:40 <Pseudonym> foldl f z (x:xs) = foldl f (f z x) xs
17:44:04 <Pseudonym> The reason why the former is better is that you can pass f by environment instead of by lambda argument.
17:44:30 <jadrian> I don't know much about implementation of functional languages...
17:45:02 <Pseudonym> @wiki AvoidingParameterPassing
17:45:04 <jadrian> I can intuitivly understand why the former could be better 
17:45:27 <jadrian> I just wouldn't expect it to make much difference...
17:45:40 <jadrian> or to be optimized most of the times
17:45:53 <Pseudonym> No, you're right, it probably doesn't make much difference.
17:46:34 <Pseudonym> But suppose, for a moment, that f is complex, not just a function name.
17:46:53 <Pseudonym> Then this effectively lifts f out of the loop.
17:47:07 <monochrom> "loop invariant code motion" yippee
17:47:23 <Pseudonym> Haskell implementations will basically do this transformation internally to preserve full laziness.
17:47:34 <Pseudonym> (Assuming you have the right optimisation level etc.)
17:47:58 <jadrian> right
17:48:20 <Pseudonym> But if you don't have the right optimisation level turned on, then basically you're doing the transformation manually.
17:48:30 <Pseudonym> Or something.
17:48:39 <Pseudonym> In this case, it still probably doesn't make a difference.
17:48:58 <Pseudonym> And at -O2 or whatever it is, GHC does do the worker/wrapper transformation for you.
17:49:06 <jadrian> nice
17:49:16 <Pseudonym> Anyway.,
17:49:26 <Pseudonym> Personally, I do this so I have fewer variables to deal with.
17:49:45 <jadrian> guess I'll do it for the most critical functions
17:49:50 * Pseudonym nods
17:49:51 <jadrian> and ignore it in others
17:49:57 <jadrian> another thing I'm not sure I should care about
17:50:03 <Pseudonym> I used the idiom a bit in lambdabot.
17:50:10 <Pseudonym> Let me dig out the sources...
17:50:44 <Pseudonym> http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/IRC.hs?rev=1.21&view=auto
17:50:48 <Pseudonym> Go down to readerLoop.
17:50:53 <jadrian> k thanks
17:51:24 <Pseudonym> Part of the reason why I did it there is that the reader/writer loops need to be tight because of protocol constraints.
17:51:34 <Pseudonym> The IRC protocol says you need to respond to a PING as fast as you can.
17:52:16 <Pseudonym> So the loop actually has _no_ arguments.
17:52:22 <Pseudonym> Everything is passed by environment.
17:52:38 <Pseudonym> Not sure if it's worth it or not, but I did it anyway.
17:52:44 <jadrian> yeap gotcha
17:53:15 <jadrian> I was also not sure how to implement some data types
17:53:40 <jadrian> I'm really use define the core functions of an ADT
17:53:47 <Pseudonym> OK.
17:53:55 <jadrian> and then use them as much as possible, instead of the constructors
17:54:34 <jadrian> Since I've read one post on the haskell mailing list I stoped doing that in some cases because of error messages
17:55:36 <jadrian> eg. instead of making a call to head, use pattern matching to check if it's empty, and if it's not, use my own error message
17:56:27 <jadrian> but now I was also thiniking about efficiency issues
17:56:30 <jadrian> for instance
17:57:06 <jadrian> f [x] =  foo x 
17:57:08 <jadrian> and
17:57:45 <jadrian> f xs = if singleton xs then foo (head xs)
17:58:07 <Pseudonym> Did you inspect the generated code?
17:58:29 <Pseudonym> Personally, I think the former is a) more clear, and b) no worse than the latter.
17:58:40 <jadrian> didn't think about that...
17:58:49 <jadrian> Pseudonym: yeap, bad example :)
17:58:58 <jadrian> Pseudonym: but I have good examples in my code ;)
17:59:04 <Pseudonym> :-)
18:00:28 <jadrian> you mean the C code? or the intermediate code?
18:00:50 <jadrian> intermediate right?
18:02:57 <Pseudonym> Intermediate, yes.
18:03:02 <Pseudonym> Core, as it's known.
18:03:16 <jadrian> I was trying to remember the name :)
18:09:20 <jadrian> Pseudonym: how do generate core only?  --help only shows flags for de-litted, C, assembler and .o
18:14:24 <jadrian> brb
19:50:54 <sjanssen> is anyone involved with Haskell on Gentoo about?
19:51:34 <sjanssen> I read the notice in Gentoo Weekly Newsletter, I'm curious what kind of help is needed . . .
20:00:56 <arauko> Is there any way to develop GUI applications with haskell?
20:02:11 <rhaaw> I read somewhere (on haskell.org IIRC) that someone was looking for help implementing Visual Haskell for VS. Anyone knows where ? I've lost the contact email.
20:03:23 <rhaaw> Ah, found it. It's in the report.
20:03:24 <heatsink> join #python
20:03:26 <heatsink> oops
20:03:54 <heatsink> nm
20:10:00 <vivek> arauko: yes use wxhaskell 
20:31:38 <dons> moin
20:36:54 <Leimy> hello
20:37:32 <vivek> hello dons Leimy 
21:04:53 <dons> hmm. haddock can't deal with mutually recursive modules.
21:04:57 <dons> what to do..
21:05:32 <jemfinch> what's haddock?
21:05:37 <heatsink> mutually recursive modules?
21:05:41 <jemfinch> dons: why do you need mutually recursive modules?
21:06:14 <jemfinch> abstract out the dependency into a third module and have both those modules depend on it.
21:07:05 <dons> yes. I think that is the way to go.
21:07:26 <dons> I currently need them for the way user-customisable actions are defined in yi
21:07:47 <dons> they need to see the core defns, and the core defns then import the user defined actions
21:07:52 <dons> but, oh well, I can break that loop
21:08:06 <jemfinch> what is Haddock, btw?
21:08:16 <dons> automatic documentation generation tool for Haskell
21:08:25 <dons> www.haskell.org/haddock
21:08:38 <dons> standard tool for generating docs from src code in .hs
21:09:08 <dons> in particular, the hierarchical libs docs are generated using haddock
21:10:29 <dons> btw, i don't know why people are so against mutual recursion. sometimes it is the semantically accurate way to structure code
21:10:47 <jemfinch> why?
21:10:49 <dons> that's why we have letrec too, and no one complains about that :)
21:11:09 <jemfinch> oops.
21:11:11 <jemfinch> sorry bout that.
21:17:13 <dons> To finish with a quote from the H98 report: Because they are allowed to be mutually recursive, modules allow a program to be partitioned freely without regard to dependencies.
21:17:17 <dons> this is a good thing.
21:18:42 <jemfinch> how?
21:20:29 <heatsink> they are mutually recursive?
21:21:01 <dons> how is it a good thing that we can partition code freely?
21:21:09 <heatsink> As I recall, ghc won't compile a module if all the .hi files it depends on are not present... and you get the .hi files after it compiles the module...
21:21:19 <heatsink> Unless i've been doing something wrong...
21:21:19 <jemfinch> dons: how do mutually recursive modules allow you to partition code freely?
21:22:03 <dons> you don't have to worry about the dependency order
21:22:32 <dons> just like you don't have to worry about the order of bindings inside a let
21:23:44 <dons> mutual recursion is a standard language feature at several levels in haskell
21:24:16 <dons> anyway, here's the ref: http://www.haskell.org/onlinereport/modules.html
21:25:06 <dons> and ghc certainly lets you compile mutually recursive modules, you just have to write a '.hi-boot' file specifying some decl to break the circle
21:25:18 <heatsink> ok
21:25:28 <dons> ghc itself uses this all over the place. it is very convenient
21:25:35 <dons> no unnatural refactoring
21:25:45 <dons> so, I say, cheers for mutual recursion!
21:25:52 <Pseudonym> The .hi-boots are annoying, though.
21:25:59 <dons> yep
21:26:00 <Pseudonym> It'd be nice if you could do it completely within Haskell.
21:26:52 <dons> and hugs doesn't implement this part of the standard either?
21:27:09 <Pseudonym> I think hugs might implement mutually recursive modules, not sure.
21:27:18 <Pseudonym> But hugs loads multiple modules at once.
21:27:25 <dons> makes things easier
21:27:28 <Pseudonym> Right.
21:27:33 <Pseudonym> THough not more efficient.
21:27:34 <dons> stoopid separate compilation
21:27:37 <heatsink> is .hi-boot standard?
21:27:42 <Pseudonym> No.
21:27:47 <Pseudonym> It's not even portable between GHC versions.
21:27:57 <heatsink> hm.
21:28:00 <Pseudonym> It's an ugly hack.
21:28:05 <dons> between what versions to .hi-boots break?
21:28:08 <dons> oh, 5 and 6.
21:28:27 <Pseudonym> 4 and 5 also, I believe.
21:28:46 <dons> but not between minor num releases
21:28:57 <musasabi> morning
21:29:31 <musasabi> How is the performance between Control.Exception, IOError and Control.Monad.Error ?
21:29:45 <dons> probably all much the same.
21:30:02 <dons> they're implemented on top of GHC.Exception, with very little extra ocde
21:30:57 <Pseudonym> I don't think Control.Monad.Error is.
21:31:08 <Pseudonym> But I think you're right about the other two.
21:31:34 <dons> oh, that's right. Monad.Error is an Either monad
21:32:02 <Pseudonym> Yeah.
21:36:36 <musasabi> So what kind of overhead does GHC.Exception cause? (How is it implemented) 
21:49:06 <dons> musasabi: there's a paper. "Tackling the Awkward Squad"
21:49:20 <dons> all about exceptions and more
21:49:27 <dons> as implemented in ghc
21:51:53 <musasabi> thanks
22:17:30 <musasabi> read the paper, but it didn't really tell much new - but still a good introduction.
22:18:14 <maXlo> hello, we have a stupid question: how can we convert a string of digits to an integer in hugs98?
22:19:31 <Cale> read
22:19:35 <Pseudonym> read
22:19:44 <Pseudonym> Like Cale said.
23:27:53 <musasabi> Is it possible to have nice error messages when catching dynamic exceptions?
23:28:35 <jemfinch> what kinds of things are exceptions used for Haskell?
23:29:40 <musasabi> jemfinch: Control.Exception (static + dynamic), IOErrors (a subset of the first) and Control.Monad.Exception
23:30:48 <jemfinch> musasabi: I didn't ask how they're used :)
23:30:48 <jemfinch> I'm curious what kinds of conditions they signal.
23:31:10 <musasabi> exceptional conditions ;)
23:31:30 <musasabi> I am using them for invalid data during parsing responses and timeouts from network
23:31:51 <jemfinch> why not use Maybes?
23:33:19 <musasabi> jemfinch: because that would become tedious when traversing through layers of code.
23:33:45 <musasabi> jemfinch: I used to have type MayIO = ErrorT String IO
23:45:25 <dons> musasabi: yes. nice error messages are possible. you write a nice Show instance
23:47:24 <jemfinch> musasabi: but isn't that why monads exist?
