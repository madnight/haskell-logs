00:10:07 <musasabi> morning
00:12:49 <kolmodin> morning
00:27:21 <tic> morning.
00:56:41 <Matt-W> good morning haskellers
01:18:11 <bourbaki> moin
01:26:55 <lypanov> umm
01:27:06 <lypanov> does haskell use CamelCase or something else in general?
01:27:19 * lypanov has written a vim clone in ruby
01:27:31 <lypanov> its got one interesting feature that maybe someone here will like :)
01:27:41 <dv> ruvi?
01:27:45 <lypanov> yup
01:27:52 <dv> is it any faster yet? :)
01:27:56 <lypanov> hehe. yup
01:28:01 <lypanov> what was the speed prob?
01:28:18 <lypanov> oh did you try like version 0.4.5 or so? :P
01:28:26 <dv> yes
01:28:29 <lypanov> ah hehe
01:28:34 <lypanov> there was a setting in it
01:28:35 <dv> it wasn't very usable on my 333mhz
01:28:57 <lypanov> basically the setting was set to "my latency is super high, don't render too much i can't cope"
01:29:12 <lypanov> but now the default is "i'm using local machine, render immediately"
01:29:44 <lypanov> with a high latency, if you page down a document when using remotely via ssh, you flood the remote terminal, so u'll get > 5s lag
01:29:52 <lypanov> vim is awful at this, first aim for my editor was to fix this
01:30:01 <dv> i see
01:30:03 <lypanov> unfortunately i totally forgot that other people don't have 250ms latencys :P
01:30:09 <dv> yeah it's way faster now
01:30:15 <lypanov> hehe
01:30:19 <lypanov> that was a one liner :P
01:30:26 <lypanov> i should have documented it :/
01:30:27 <arauko> Do we have fun here?
01:30:39 <shrimpx> lypanov: your site is down..
01:30:48 <shrimpx> or something
01:31:24 <lypanov> retry :)
01:32:04 <lypanov> (you got first load, it does xml processing of my entire site, please don't shout at me cus its slow :P)
01:32:27 <shrimpx> haha
01:32:47 <lypanov> umm something has to be b0rked
01:32:53 <shrimpx> word
01:32:56 <shrimpx> xml rules
01:33:21 <lypanov> wtf is it so slow? :P
01:33:29 * lypanov kills off ruby
01:35:04 <lypanov> okay this is seriously not a good sign :P
01:35:11 * lypanov wonders wtf happened to his site
01:35:15 <lypanov> (someone rebooted my machine)
01:35:19 <shrimpx> h4x0rd
01:35:32 <lypanov> ah. its back
01:35:48 <lypanov> ummm it must me finding extra xml files or something
01:36:09 <lypanov> k so yeah back to the original reason i joined :)
01:36:25 <lypanov> i added a feature a couple of months back but didn't add a keybinding for it
01:36:31 <lypanov> i added the binding the morning
01:36:32 <dv> ruvi crashes everytime i exit: http://transfixion.org/files/hardcopy.0
01:36:41 <lypanov> dv: which version?
01:37:02 <lypanov> oh. the gem
01:37:07 <dv> 0.4.11
01:37:16 <lypanov> wait a sec i'll make a prerelease
01:39:00 <lypanov> dv: http://www.lypanov.net/ruvi-prerelease-0.4.12.gem
01:40:24 <lypanov> (note, you need a new release of gem's as they changed the file format)
01:40:57 <lypanov> else if you've got rpa: rpa install http://www.lypanov.net/ruvi-prerelease_0.4.12-4.rps
01:42:14 * lypanov forgot to explain the feature again
01:42:15 <lypanov> anyways
01:42:26 <lypanov> zl and zh are stupid barely used keybindings in vim
01:42:36 <lypanov> (and if you use 'em, then please suggest an alternative ;P)
01:42:50 <lypanov> so, i've modified them to work as w/b but for sub identifiers
01:43:05 <lypanov> therefore, CamelCase and i_love_underscores
01:43:30 <lypanov> e.g your on the first C of CamelCase and you type czlBlah
01:43:34 <lypanov> it becomes BlahCase
01:43:41 <lypanov> useful huh? :P
01:45:33 <musasabi> What runtime characteristics do HLists have?
02:12:47 <Lemmih> Good morning, #haskell.
02:37:57 * Matt-W wonders why his Haddock tree has mysteriously stopped compiling
02:47:34 <Lemmih> Hello shapr.
02:47:52 <xkb> hmm the os x port of ghc supports exceptions right?
02:48:38 <musasabi> Is there a way to express octal numbers in haskell?
02:52:03 <Matt-W> convert them to decimal?
02:52:05 * Matt-W hides
02:52:30 <Matt-W> Honestly I don't know, but if there isn't there should be
02:59:01 <Lemmih> @index oct
02:59:02 <lambdabot> bzzt
02:59:55 <tromp> @eval print 0o10
02:59:55 <lambdabot> unbound variable: print
02:59:57 <Matt-W> there is
03:00:06 <Matt-W> prefix octal literals with 0o or 0O
03:00:12 <Matt-W> according to the Haskell report
03:00:21 <tromp> @eval 0o10
03:00:22 <lambdabot> 8
03:00:23 <Matt-W> hex is done with 0x or 0X
03:00:25 <tromp> bingo
03:00:43 <Matt-W> you may be able to tell that although I'm at work I'm a little bored
03:02:07 <Lemmih> Hello squire
03:07:47 <squire> hi
03:11:15 <squire> what's a simplistic definition of a monad? Like "Monad is an object" or "Monad is a 3-tuple" ...
03:11:35 <ibid> Monad is a type class
03:11:44 <ibid> a monad is an abstract data type
03:12:41 <shrimpx> a monad is something that will give you headaches for a long time
03:12:59 <squire> shrimpx: I like that :)
03:13:49 <squire> ibid: thanks
03:14:30 <dblhelix> but probably more useful is a monad is a type T :: * -> * for which the following functions are defined, (...), and for which these laws hold, (...) ;)
03:14:58 <shrimpx> like i said...
03:15:02 <shrimpx> :)
03:15:42 <ibid> that's just a more detailed version of "a monad is an abstract data type" :)
03:15:55 <Matt-W> It's a thing
03:15:59 <Matt-W> that's about as far as I've got
03:16:11 <dblhelix> well, it's the details that matter, isn't it? ;)
03:16:14 <Matt-W> except that you can do certain opperations on it
03:16:23 <squire> the standard explanation about values and structuring computations doesn't help one bit
03:17:11 <shrimpx> it's really a set of functions that obey some static and dynamic laws
03:19:22 <bourbaki> moin
03:19:30 <bourbaki> esap: are you reading?
03:21:10 <Lemmih> Hello bourbaki
03:21:48 <bourbaki> Lemmih: hidiho
03:22:16 <bourbaki> Lemmih: did you do some more work on your ogl stuff?
03:24:10 <Lemmih> Nope. Got a little disapointed with the blending features so now I'm working on making Halipeto generate dynamic webpages.
03:24:26 <bourbaki> i see
03:25:10 <kehoste> hello everyone :)
03:25:18 <kehoste> @hello
03:25:19 <lambdabot> Hello world. 
03:25:19 <bourbaki> hell-0 single one
03:26:24 <Boegel> bourbaki, have you seen my ray tracing code ?
03:26:42 <bourbaki> Boegel: nope is it anything you can look at that is visual output
03:27:10 <Oejet> How do one write binary words?  0b10011 does not seem to work.
03:27:10 <Boegel> euh
03:27:36 <Boegel> I can give you a PPM file it generated
03:27:40 <bourbaki> i had the idea of writeing some intersetction tests for a functional physics system
03:27:57 <Boegel> what do you mean by physics ?
03:28:07 <bourbaki> physics simulation
03:28:30 <Boegel> which objects would you like to intersect?
03:28:59 <Boegel> bourbqki, do you want to see the PPM file ?
03:29:04 <bourbaki> box, sphere, elispe, cone, pill, cylinder and so on
03:29:09 <bourbaki> ppm?
03:29:13 <Boegel> s/bourbqki/bourbaki
03:29:24 <Boegel> it's something like bmp
03:29:25 <shapr> whoof
03:29:32 <Boegel> put then easier to make
03:29:32 <bourbaki> ah sure
03:29:34 <bourbaki> moin shapr 
03:29:39 <shapr> greetings
03:29:42 <Boegel> one moment, I'll throw one online
03:30:25 <TheHunter> Boegel: have you tried to compile your rayTracing code with -Wall ?
03:30:47 <Boegel> no, because I don't know what that does :p
03:31:08 <bourbaki> konnichiwa tea :)
03:31:15 <TheHunter> it gives you all kinds of warnigs - useful ones and ones that are less useful
03:31:30 <Boegel> http://studwww.ugent.be/~kehoste/thesis/Haskell/test.ppm
03:31:36 <tea> bourbaki: konbanwa~ at this time =)
03:31:41 <TheHunter> anyhow, there are warnings that stuff is defaulted to Integer
03:32:09 <bourbaki> tea: dang ok :) konbanwa ;)
03:32:14 <TheHunter> which should definitely changed to Int if the numbers are less then 2^28 and performance is a concern
03:32:37 <bourbaki> Boegel: can you convert it so jpg or png or so?
03:34:46 <TheHunter> Boegel: i just see the integers are just used to print a rounded value, so it might be not that big a deal.
03:38:48 <musasabi> Matt-W: thanks.
03:38:53 <Boegel> bourbaki, I'll try to convert the image, but I'll have to look what I can do 
03:39:11 <Boegel> because I'm at school now, and using irc on a text-based client :)
03:39:12 <bour[training]> Boegel: ok cause my browser wont show me that format
03:39:17 <Boegel> that's already pretty new to me
03:39:27 <bour[training]> i need to go training now but id like to see it
03:39:32 <bour[training]> i use mozilla
03:39:43 <Boegel> TheHunter, you mean the Int's should be changed to Integer's ?
03:39:58 <bour[training]> anyway laters :)
03:40:10 <Boegel> maybe someone else can convert it for you
03:40:17 <Boegel> because I don't have the tools here...
03:40:30 <TheHunter> Boegel: nah, line 245
03:41:00 <TheHunter> as i said, it's not that big a deal: round x returns an Integral, which is defaulted to Integer
03:41:24 <TheHunter> This gives a warning.
03:41:58 <Boegel> o, but I changed that already
03:42:05 <Boegel> round isn't necassary, I dropped it
03:42:21 <Boegel> s/necasarry/necessary
03:42:25 <TheHunter> ah, ok
03:42:34 <Boegel> that was because I got inspiration from another function
03:42:46 <Boegel> and that one used Double values to represent the colors...
03:42:56 <TheHunter> intersectSphere seems to be defined only for Sphere1
03:43:05 <Boegel> TheHunter, could you convert the ppm file for me ? to jpg ?
03:43:10 <Boegel> just to show bourbaki
03:43:12 <TheHunter> Boegel: no problemo
03:43:17 <Boegel> okay thanks
03:43:22 <Boegel> mail it to me, okay ?
03:43:31 <Boegel> kehoste at Ugent dot be
03:43:39 * shapr sings ring ring ring banana bracket
03:45:03 * Boegel wonders what hit shapr this time
03:45:50 <shapr> a bus!
03:45:53 <musasabi> Why does System.Cmd block all threads ?
03:46:16 <musasabi> is it a bug or a feature or my failure to test properly.
03:46:25 <TheHunter> Boegel: done
03:46:26 <shapr> it's a feature, but I forget why.
03:46:34 <shapr> musasabi: hei, have you seen hemacs?
03:46:49 <shapr> next step is to design a buffer.
03:47:06 <Boegel> TheHunter: thanks
03:47:31 <Boegel> does anyone know a url for downloading Tcl/Tk 8.0 ?
03:47:38 <Boegel> the 8.0 part is important
03:47:58 <Boegel> TheHunter: have you mailed it too ?
03:48:12 <Boegel> ow damn, wrong mail adres :)
03:48:23 <Boegel> TheHuner: kehoste at eduserv dot Ugent dot be
03:48:42 <juhp> Boegel: 8.0 is *old*, but I guess that is why you're asking....
03:48:55 <musasabi> shapr: no, I'll probably look at it in the weekend.
03:49:07 <shapr> ok
03:49:20 <Boegel> juhp: I need 8.0 because only that works with FranTk, the GUI library I use
03:49:25 <shapr> hm, design a buffer with the zipper?
03:49:30 <shapr> is there a better way?
03:49:33 <juhp> ah
03:50:39 <Boegel> juhp: any idea where I can find it ?
03:50:50 <Boegel> google doesn't help me much on finding the home page
03:51:06 <juhp> Boegel: how about http://www.tcl.tk/software/tcltk/downloadnow80.tml
03:51:47 <Boegel> juhp: why didn't google find that for me :s
03:51:50 <Boegel> thanks !
03:52:01 <juhp> np
03:53:24 <Boegel> damn, I can't install the damn thing :(
03:53:36 <Boegel> I hate shared computers :@
03:53:52 <Boegel> oh well, I'll have to find something else to keep me busy then
03:54:46 <Boegel> TheHuner: have you remaild the image ?
03:54:52 <Boegel> s/remaild/remailed
03:55:20 <Boegel> s/TheHuner/TheHunter (text based irc'ing sucks)
03:55:48 <shapr> you don't have tab completion in your text based editor?
03:55:58 <Boegel> no
03:56:06 <Boegel> I'm using ircii
03:56:31 <Boegel> it's the only irc client available on the server I'm working on (university student server)
03:56:36 * shapr is still asleep, asking about editors...
03:56:49 <Boegel> ow
03:56:52 <Boegel> talk about editors
03:56:57 <shapr> I'm thinking about editors :-)
03:57:05 <Boegel> you were interested in writing one, right ?
03:57:09 <Boegel> in Haskell ?
03:57:11 <shapr> am hacking on one now.
03:57:38 <Boegel> my promotor wrote a DTD dependent editor for editing XML files according to that specific DTD
03:57:47 <Boegel> only correct changes are allowed
03:57:50 <shapr> I'm trying to figure out if The Zipper is the best way to build a buffer.
03:58:22 <shapr> only correct changes feels too restrictive to me, I like the way epigram mixes free editing and syntax directed editing.
03:59:36 <Boegel> the editor isn't character based, but XML 'atom' based
03:59:49 <shapr> right, I understand
04:00:05 <shapr> but if you use the epigram way, you can incrementally parse the text into 'atoms'
04:00:08 <Boegel> he made that thing for his thesis
04:01:09 <juhp> shapr: what's Zipper?
04:01:16 <shapr> I've used something like that before, they're cool for quickly learning a complex DTD (like Open Office)
04:01:34 <shapr> http://www.haskell.org/hawiki/TheZipper
04:01:56 <Boegel> damn, this machine I'm working on doesn't even have Emacs installed :s
04:02:25 <shapr> Boegel: wow, can you survive? =)
04:02:47 <Boegel> I'm trying to :p
04:03:05 <Boegel> it does have FireFox, so I can manage ;)
04:03:30 * Boegel starts looking through a hs file in WordPad *the horror*
04:04:04 <Boegel> the do have these _huge_ 19 inch LCD panels here
04:04:08 * Matt-W sneakily replaces Boegel's machine with a nice shiny G5 iMac
04:04:18 <Boegel> these computers are meant to be for architecture students
04:04:28 <Boegel> s/the/they
04:04:51 <shapr> architecture is about using wordpad on 19" LCD?
04:05:06 <Boegel> no, but neither using Emacs :p
04:05:21 <Boegel> so I have to use Notepad, WordPad or Word
04:05:24 <Boegel> ;)
04:05:52 <Boegel> shapr: it's about using 3D programs on high resolution -> works more efficiently
04:08:53 <Matt-W> what pains me most is that I had to install VMWare on my Linux workstation in the office
04:09:46 <Boegel> Matt-W : why ?
04:13:53 <Boegel> TheHunter: are you there ?
04:14:14 <Boegel> hmm, I guess not
04:14:23 <TheHunter> Boegel: here I am
04:15:03 <TheHunter> didn't you get the mail?
04:15:18 <Boegel> no, but the first mail adres was wrong
04:15:32 <Boegel> it's supposed to be kehoste at eduserv dot ugent dot be
04:15:37 <TheHunter> i know, i got a bounce for that
04:15:43 * shapr bounces
04:15:52 * Boegel bounces to
04:16:00 <Boegel> I didn't get any mail...
04:16:01 <Boegel> :s
04:16:07 <TheHunter> oh, sorry
04:16:21 <TheHunter> how did this happen? <Boegelkehoste@eduserv.ugent.be>
04:16:30 <Boegel> ay
04:16:34 <Boegel> watch spam ! :s
04:16:43 * shapr watches the spam flow!
04:16:55 * Boegel cries :(
04:17:59 <TheHunter> got it?
04:19:27 <Boegel> TheHunter: yep, thx !
04:20:18 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesis/Haskell/test.png
04:20:22 <Boegel> :o)
04:20:46 <Boegel> damn, I can't remember how to use 'find' on a unix system...
04:20:53 <Boegel> find . foo *
04:21:09 <Boegel> I want to look for the string foo in every file in the current directory...
04:21:32 <shapr> fgrep foo *
04:21:33 <squire> boegel: it's easier to just do: 'find|grep foo'
04:21:51 <shapr> greetz squire 
04:21:59 <squire> hello shapr
04:22:05 <shapr> how's code?
04:22:36 <Boegel> I thought I could do that using find only ? or is that just for filenames ?
04:22:44 <shapr> find does lots of stuff
04:23:05 <TheHunter> Boegel: you can do that with find, but find | grep is much easier to remember
04:23:23 <Boegel> just grep foo was ok :)
04:23:30 <squire> boegel: you want to find the string 'foo' in the *filename* or in the *contents* of the file?
04:24:12 <Boegel> contents
04:24:21 <Boegel> but it's ok, just doing 'grep foo' did it for me
04:24:22 <squire> then just 'grep -r foo *'
04:24:52 <TheHunter> once you want zgrep -r foo, you're doomed
04:26:05 <shapr> what's bad about zgrep -r foo?
04:26:23 <TheHunter> zgrep doesn't know -r
04:26:28 <shapr> oh
04:26:44 <Boegel> what's the difference between grep and zgrep ?
04:26:50 <shapr> in that case I use zgrep **/*.gz foo
04:26:56 <TheHunter> you can kinda do it with find -print0 (or similar) and some weird xargs stuff
04:27:13 <shapr> but I think only zsh deals with **/*
04:27:59 <shapr> @wiki TheZipper
04:27:59 <lambdabot> http://www.haskell.org/hawiki/TheZipper
04:28:21 <TheHunter> i've always been wanting to change to zsh, but there were some weird issues.
04:28:28 <shapr> zsh r0xx0rs
04:28:48 <TheHunter> what's CTRL+R in zsh?
04:29:18 <shapr> I don't think it does anything
04:29:38 <shapr> oh wait, search backwards
04:29:39 <TheHunter> i mean the zsh equivalent to bash's Ctrl+R
04:29:41 <shapr> like in emacs, right?
04:29:46 <Boegel> @i fmap
04:29:46 <lambdabot> Sorry, I don't know the command "i", try "lambdabot: @listcommands"
04:29:57 <Boegel> @index fmap
04:29:57 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
04:29:57 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
04:29:57 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
04:30:08 <TheHunter> it allows you to search in the history
04:30:13 <shapr> Boegel: oh hey, unambiguous command subnames would be cool
04:30:22 <shapr> TheHunter: right, that's the emacs binding for search backwards
04:30:45 <TheHunter> so how do i get the history search - thingie?
04:31:04 <TheHunter> it really pisses me off that fmap is exported by so many modules
04:31:05 <shapr> with C-r
04:31:18 <Boegel> shapr: what do you mean ?
04:31:19 <shapr> well, lambdabot shows modules that don't export it
04:31:21 <shapr> that's a bug, imho
04:31:48 <shapr> Boegel: for example, if @info is the only command that starts with i, then @i @in @inf or @info would still call it
04:31:55 <TheHunter> i do think most of these modules export it
04:32:15 <TheHunter> if you want to change the prec of `fmap` you're doomed
04:32:48 <TheHunter> shapr: doesn't work,  but maybe that's because zsh doesn't save the history
04:33:59 <Boegel> shapr: those would be cool indeed
04:34:15 <Boegel> shapr: but I hope you won't be counting on me for that :p
04:34:40 <shapr> TheHunter: http://www.scannedinavian.org/~shae/zshrc.shae
04:35:00 <TheHunter> shapr: Forbidden
04:35:04 <shapr> whoops
04:35:29 <shapr> ok
04:35:30 <TheHunter> shapr: hey, thanks
04:36:08 <shapr> that's what I use, and it does all sorts of nifty stuff.
04:36:19 <Boegel> what is the easiest way to check definitions of Prelude functions ?
04:36:24 <shapr> fin and die are my most recent additions
04:37:28 <TheHunter> when do you play these sounds?
04:37:44 <Boegel> hello viv
04:37:58 <shapr> TheHunter: long-running process && fin || die
04:38:06 <shapr> like a GHC compile
04:38:26 <TheHunter> ah, neat idea
04:38:47 <shapr> then I can go off and work while listening to headphones, and I know if/when failure/success
04:38:58 <shapr> I have another idea along those lines that uses procmail to do email ringtones
04:39:05 * TheHunter types chsh
04:39:23 <shapr> the idea being that I can ignore my incoming email during work hours unless it's business related
04:39:41 <shapr> time for lunch, bbl
04:39:51 <TheHunter> cool
04:48:23 <Boegel> type CLine = CItem T.CLin
04:48:49 <Boegel> is this is a defined type, where would I be able to find the CLin type def ? In the module 'T' right ?
04:49:27 <TheHunter> yep
04:56:56 <Boegel> does anyone have experience with working with TclHaskell ?
05:06:20 <Boegel> I'm put
05:06:25 <Boegel> I have a class in 20 min's
05:06:29 <Boegel> bye everyone
05:06:35 <Boegel> s/put/out
05:26:43 <Lemmih> I wonder if halipeto is too slow for dynamic webpages.
05:42:38 <musasabi> what should one write to 3 clause BSD licence when lacking a proper organisation.
05:43:45 <musasabi> hmm just removed that, hopefull that won't cause any problems.
05:49:56 <shapr> musasabi: I usually claim I'm part of the Paratheoanametamystikhood of Eris Esoteric.
05:50:03 <shapr> TheHunter: any zsh excitement?
05:50:57 <tromp> how do you load Language.Haskell.THSyntax into ghci?
05:51:21 <shapr> :m + Language.Haskell.THSyntax ?
05:51:22 <Igloo> :m + Language.Haskell.THSyntax
05:51:48 <tromp> thx
05:52:04 <shapr> Igloo: anything better than the Zipper for a buffer?
05:52:22 <Igloo> eh?
05:52:43 <shapr> The Zipper, a functional pearl for text buffers
05:52:49 <shapr> have you heard of anything better?
05:53:17 <tuomov> the zipper is unnecessarily complicated for simple text
05:54:39 <shapr> well, for color etc, you think there's something better than the zipper?
05:54:41 <tuomov> but if there's going to be any structure e.g. for syntax highlighting, then such a structure might be quite nice
05:54:57 <tuomov> but first one needs to think how syntax highlighting is done
05:55:01 <bourbaki> bk
05:55:07 <shapr> darcs
05:55:36 <musasabi> Created an utility to make it easier to filter haskell sources through cpp before haddock etc. http://www.cs.helsinki.fi/u/ekarttun/util/AFilter/afilter-0.2.tar.gz
05:55:39 <shapr> tuomov: suggestions?
05:56:05 <TheHunter> shapr: i'm playing around with it a little bit, but it's odd that -- doesn't give you a comment and that the config can't be reloaded with :r
05:57:06 <tuomov> well, the simple naive way to do highlighting would be to perhaps store context for each line from previous, and then for each line do the parsing while drawing it
05:57:49 <Philippa> that's how QT supports it
05:57:54 <tuomov> the more elegant way would be to store the parse information ina a tree
05:57:59 <Philippa> right
05:57:59 <tuomov> -> zipper
05:58:07 <Philippa> oh yeah, hi :-)
05:58:08 <tuomov> but that could cause propagation of the information
05:58:52 <tuomov> start a block comment and you end up modifying the rest of the tree
05:59:09 <tuomov> unless you do special tricks for such cases
05:59:31 <tuomov> in that sense the naive way may be better
05:59:57 <Philippa> I dunno, the full-tree way makes it very, very clear if you've left half-a-comment in place
06:00:20 <Philippa> and would make it easy to produce a list of parser errors ala VS.net
06:01:03 <Philippa> (something I'd occasionally find useful with Haskell code - once in a while I manage to do something braindead with the combination of layout and do notation)
06:01:10 <tuomov> maybe lazyness could be used to an advantage here..
06:01:30 <Lemmih> shapr: I've successfully mixed halipeto and a modified Network.CGI. Now I'm hacking the needed HDB code and after that I can start writting the template code.
06:02:03 <Philippa> Lemmih: how's your Network.CGI modded? I've been realising there's 101 tweaks it needs...
06:02:32 <tuomov> in any case, I think the buffer structure should be "local" to "point"
06:02:55 <tuomov> as most operations in a text editor are very local
06:03:20 <Philippa> would be nice if you can avoid a complete reparse if all you've done is edit one expression (and left it well-formed), certainly
06:03:40 <Lemmih> Philippa: I only use the CGI components from it (query, mime and cookie handling) and I've added a tmplWrapper.
06:04:04 <Philippa> yeah, that sorta makes sense. I was kinda POed that it doesn't actually expose that stuff
06:04:49 <Philippa> Am kinda tempted to distribute a Not.Really.Network.CGI with future versions of Flippi...
06:05:39 * Lemmih is away: Unicycling while it's still dry outside.
06:06:01 <Matt-W> Philippa: I'm going to have to take a look at Flippi, looks interesting
06:06:14 * bourbaki relies on his feet no uni nor bi-cycle
06:07:44 <Philippa> Matt-W: it's not as interesting as it could be right now, in that it's practically featureless, but yeah. Am currently working on adding RecentChanges, as it kinda badly needs it...
06:08:04 <Matt-W> Philippa: still, I'm interested in using Haskell for CGI-type stuff, so it'll be interesting from that standpoint at least
06:08:57 <Philippa> yeah. For very plain CGI it works, you'll notice Flippi's a bit hacky about query strings atm though
06:09:21 <Philippa> It's just using Network.CGI to do the work, so all it really gets offered is a pretty restrictive wrapper
06:09:30 <Philippa> on the bright side, parsec and Text.Html work well together
06:09:59 <Philippa> all the CGI stuff's in Flippi.hs btw
06:10:35 <Philippa> some other bits get passed the CGI environment so eg the code that turns wiki text to HTML knows where Flippi's actually running from and can generate links
06:10:49 <Philippa> but that's just queries on the environment
06:10:56 <Matt-W> yup
06:10:59 <Matt-W> fairly important though
06:11:15 <Matt-W> there are some tight corners you can end up in if you use relative URIs a lot in CGI programs
06:11:22 <Matt-W> unless you're very, very careful
06:11:53 <Philippa> all I'm doing is linking back to the same script, thankfully
06:13:05 <Matt-W> my recent PHP development has shown a tendency to make everything go through the same script
06:13:16 <Matt-W> ultimately that one dispatches to other scripts to do the work
06:13:27 <Matt-W> but it's handy to have only one entry point from the HTTP request, I find
06:13:29 <Philippa> yeah, Flippi'll be doing a similar thing via the module system
06:13:40 <Matt-W> especially if you're doing session handling, logins, cookies and so on
06:13:51 <Philippa> I've implemented a general interface for calling script-like things, which is where RecentlyChanged'll be implemented
06:14:02 <Matt-W> I should take a look at Network.CGI as well
06:14:09 <Philippa> Flippi?script=ScriptName, with all the parms going via POST data atm...
06:14:28 <Philippa> (I'll add a syntax for pre-filled script links as well)
06:15:09 <Philippa> the ScriptName gets put through a FiniteMap, there's no chance of a user screwing your box up unless you explicitly offer them a script to do it
06:16:10 <Matt-W> did John Hughes ever release the arrow-based CGI library he wrote about in his paper on arrows?
06:16:24 <Matt-W> oh, yes, that's good
06:16:39 <Matt-W> can't trust anything coming in over the wire
06:16:44 <Matt-W> that way lies pain
06:17:54 <Philippa> right. I've not done CGI work before, but I'm not daft :-)
06:18:33 <Matt-W> good
06:18:40 <Matt-W> I had thought before that you weren't daft :-)
06:19:38 * Philippa blinks and does a whois
06:19:45 <Philippa> hey, should've expected to find you on here :-)
06:20:09 <Matt-W> yes, you should
06:20:17 <Matt-W> especially as I'm shortly going to apply to do a PhD in this stuff
06:20:23 <Philippa> heh, cool
06:20:24 <Philippa> and good luck
06:20:26 <Matt-W> although you may not have heard that
06:20:28 <Matt-W> thanks
06:20:41 <Philippa> I hadn't, no - I'm not really following #nott these days
06:20:52 <Matt-W> I don't think I've said anything in #nott for a week or so
06:21:05 <Matt-W> tend to hang out elsewhere
06:21:09 * Philippa nods
06:21:13 <Matt-W> the wonky channels, for instance
06:21:21 <tic> mm, monkey...
06:21:23 <Philippa> as you may or may not've gathered, I'm still plodding through my BSc...
06:21:35 <Matt-W> I was just wondering if you'd managed to finish it yet
06:21:55 <Philippa> I managed a semester last year, I resume again in january assuming I'm in a half-decent state to do so (which right now I'm not really)
06:22:43 <Philippa> right now the priority's helping Damien study again though. He's resuming part time this year, and just about in a state to handle that
06:24:07 <Philippa> he also wants me to teach him Haskell so he knows what the hell I'm talking about :-)
06:31:40 <CosmicRay> shapr: I solved the hsshellscript problem after I noticed a similar problem in MissingH.
06:31:54 <CosmicRay> shapr: MissingH would link stiff fine if I also used -package HUnit
06:32:01 <CosmicRay> shapr: but sometimes had a similar problem to hsshellscript.
06:32:17 <CosmicRay> shapr: turns out that adding a Build-Depends of haskell-src fixes it both places.
06:34:27 <tromp> anyknow familiar with template haskell?
06:37:46 <rhaaw> How does one set another editor in Hugs ? :set estr.. ? something ?
06:43:25 <mikael> hej bringert :)
06:43:48 <bringert> hej phubuh
06:43:59 * bringert is looking for a ninja
06:44:08 <bringert> still a bit early for that I guess
06:44:17 <phubuh> they only come out at night
06:48:41 <desrt> rhaaw; try export EDITOR=youreditor
06:48:43 <desrt> before you run hugs
06:49:17 <desrt> EDITOR environment variable is fairly universally obeyed
06:50:03 <tuomov> VISUAL is often the first choice, so if it set, EDITOR is not used
06:50:31 <desrt> tuomov; mr. know-it-all
06:50:31 <desrt> :P
06:51:22 <tuomov> (EDITOR=/path/to/ed, VISUAL=/path/to/vi)
06:52:01 <desrt> export EDITOR=`which vim` # to hell with nano
06:52:03 <desrt> =)
06:53:17 <Philippa> nano's about the only text-mode editor I can really use under *nix atm - you can guess my mail client...
06:53:40 <tuomov> try joe.
06:53:53 <tuomov> that's the only I could make heads and tails of ten years ago
06:53:57 <desrt> try mutt while you're at it :)
06:54:11 <tuomov> and mutt for a mua, yes
06:54:22 <Philippa> I've not had any cause to get annoyed at pine in a long time - any particular reasons mutt's better?
06:54:41 <desrt> i actually wouldn't know - i use pine
06:54:49 * Philippa nods
06:55:00 <Philippa> back before it had proper threading support and so forth, it would've been a fair comment
06:55:06 * phubuh likes gnus
06:55:07 <desrt> but a lot of people seem to think that mutt is nice
06:55:17 <Philippa> once or twice I /do/ wish it wasn't single-threaded, but hey
06:57:34 <desrt> anyway.. from what i understand, you can use vi to compose with mutt
06:57:48 <Philippa> yeah, that'd be a feature for a lot of folks
06:57:48 <tuomov> mutt doesn't have an internal editor
06:58:15 <tuomov> you must use your favourite editor to compose messages
06:58:55 <Oejet> Mutt is free :-)
06:59:00 <Philippa> one reason I really wouldn't get on with mutt under windows. It'd completely screw up my workflow
06:59:03 <Philippa> Oejet: watch me care :-)
06:59:32 * Oejet watches Philippa care.
07:01:07 * dblhelix sticks with pine
07:10:48 <shapr> Lemmih: awesome!
07:12:35 <shapr> Luke: y0!
07:12:41 <tromp> mutt has a clean interface
07:13:14 <shapr> Lemmih: I'd like to see how you mixed Halipeto and Network.CGI, and I bet andrew cooke will be interested also.
07:13:23 <shapr> Luke: are you getting post-emacs traffic?
07:13:33 <tromp> i used mutt for years before switching to thunderbird (to keep spam under control)
07:14:28 <tuomov> I just use bogofilter
07:14:38 <shapr> bringert: I think the Ninja is traveling.
07:25:12 <Lemmih> Yay. GHC 6.2.2
07:27:42 <shapr> oh, already?
07:34:13 <Igloo> "already"? It's late, isn't it?  :-)
07:34:20 * shapr grins
07:36:11 <Igloo> CosmicRay: You around?
07:44:21 <bourbaki> http://en.wikipedia.org/wiki/John_Dee
07:44:28 <bourbaki> He wrote "Monas Hieroglyphica" (The Heiroglyphic Monad) in 1564
07:44:50 <bourbaki> the heiroglyphic monad is there somethting like that in haskell aslo ?:)
07:44:56 <shapr> !
07:45:07 <bourbaki> or is that just considered bad code ;)?
07:45:20 * shapr thinks about a hieroglyphic monad.
07:45:23 <bourbaki> (about Kabbala alchemy) and the preface to the first English translation of Euclid's works.
07:45:33 <bourbaki> heh shapr
07:45:53 <bourbaki> just look at one of my implementations they are really heiroglyphic ;)
07:46:23 * Igloo reads the wikipedia Monad page and wonders if Haskore could have a monad monad
07:47:57 <bourbaki> quick questin is an arrow arrow a functior? and thus an arrow arrow arrow a nat. trans.?
07:48:20 * shapr 's brain explodes thinking about that.
07:48:47 <shapr> ask TheHunter or esap, they're the category theory buffs around here.
07:48:59 <bourbaki> :)
07:49:29 <bourbaki> that reminds me to listen to monster magnet - head explode ;)
07:49:48 <shapr> Oh, have you listened to the stuff on Magnatune.com ?
07:49:57 <bourbaki> no whats that?
07:50:40 <shapr> TheHunter_: aha!
07:50:41 <bourbaki> hi TheHunter_ :)
07:50:44 <bourbaki> quick questin is an arrow arrow a functior? and thus an arrow arrow arrow a nat. trans.?
07:50:47 <TheHunter_> hi
07:51:04 <TheHunter_> an arrow is not a functor
07:51:06 <bourbaki> shapr: http://216.12.219.222:8900/ thats the stream im listening to most of the times
07:51:18 <bourbaki> TheHunter_: but an arrow of arrows is quite the same
07:51:28 <shapr> hm, Jimi roxx
07:51:30 <bourbaki> just that youd need to map the nodes as well
07:52:04 <TheHunter_> what's an arrow of arrows?
07:52:19 <bourbaki> shapr: stoner rock radio :)
07:52:26 <bourbaki> TheHunter_: it maps arrows to arrows right?
07:52:26 <shapr> hi rhw 
07:52:35 <shapr> rhw: may I induct you into the world of lambdas?
07:52:52 <bourbaki> TheHunter_: so what you need to map as well is the nodes so its only half of a functor :)
07:53:07 <shapr> rhw: I can give you the intro into FP for imperative programmers.
07:53:41 <rhw> shapr, I'd like to finish my book first.
07:53:48 <shapr> rhw: aww, ok.
07:53:53 <shapr> isomer: hi anth!
07:54:00 <shapr> isomer: seen the new croquet?
07:54:12 <TheHunter_> bourbaki, are you talking about CT arrows or about Haskell arrows?
07:54:24 <bourbaki> TheHunter_: CT
07:54:43 <rhw> shapr, But you can give me the link. I'll bookmark it.
07:55:26 <isomer> shapr! 
07:55:37 <isomer> no - i figured i'd wait for the movie. is it good?
07:55:54 <shapr> rhw: I wrote http://www.haskell.org/hawiki/HaskellDemo as the intro for the impatient
07:55:54 <bourbaki> shapr: still listening to the stream?
07:56:06 <shapr> bourbaki: no, I got distracted and never started.
07:56:38 <TheHunter> there is a construction which produces another category from two categories, let's say B and C. Its objects are the functors from B to C, and its arrows are the natural transformations between these functors
07:57:06 <rhw> shapr, Thanks.
07:57:07 <TheHunter> so fuctors are object-like and nat. transf. are arrow-like
07:57:57 <shapr> rhw: Hal Daume's 'Yet Another Haskell Tutorial' is also excellent, but in my experience the best thing is to hang around here and ask questions when you don't understand something.
07:58:15 <bourbaki> TheHunter: i see
08:04:34 <rhw> shapr, I tried reading that tutorial, but I belive it takes more time to figure out stuff yourself from tha tutorial rather than buying the Craft of Functional Programming.
08:04:39 <shapr> rhw: if you have time to inhale some FP info when I'm around, I promise I can bridge the gap beween imperative and FP. I came from Python to Haskell.
08:06:46 <tromp> i came from ruby and lambda calculus and combinatory logic
08:07:00 <shapr> rhw: I started with the 'Gentle Introduction' and it felt like a brickbat.
08:07:17 <shapr> I complained bitterly on the mailing lists, and that's why YAHT was started.
08:07:26 <rhw> shapr, I'm coming from C++.
08:07:30 <tromp> it's a delight compared with the Java Language Definition:)
08:08:18 <shapr> I also got "Haskell: The Craft of Functional Programming" and "The Haskell School of Expression"
08:10:34 <shapr> rhw: Might be just my learning style, but I got the most out of reading simple code, then trying to write my own, and asking questions here on #haskell whenever I was stuck.
08:11:55 <Philippa> shapr: the gentle introduction worked for me having been taught some of the language a couple of years previously. Says it all, really
08:12:20 <shapr> haha
08:17:33 <shapr> hej Markus 
08:17:47 <shapr> aka Deniz
08:17:49 <shapr> aka etc
08:18:56 <Markus> ?
08:18:59 <Markus> :)
08:19:33 <kosmikus> I'd still like to get my hands on the YAHT sources to make the whole thing readable
08:19:39 <shapr> kosmikus: ask Hal
08:19:52 <shapr> I just deleted my cvs checkout of an older version of YAHT yesterday.
08:19:54 <Igloo> How's it unreadable OOI?
08:20:04 <kosmikus> haven't seen him for a long time
08:20:15 <shapr> Send him an email, he reponds quickly.
08:20:16 <Deniz> you got good memory shapr
08:20:32 <kosmikus> Igloo: well, if it hasn't changed during the last six months, the document comprises an excellent example of how a LaTeX document should *not* look like
08:20:38 <shapr> Deniz: bien sûr! je n'oublie pas rien!
08:20:52 <kosmikus> meaning, he obviously invested considerable amounts of time in making things look worse than they would by default
08:21:07 <Igloo> :-)
08:21:13 <Deniz> ooh.. tu parle francais? :D
08:21:27 <Luke> shapr: howdy. yeah I'm getting the mail - I wasn't seeing it due to Gnus misconfiguration. but what are the prereqs to build hemacs? I get "ghc-6.2.1: unknown package name: plugins"
08:21:28 <Deniz> olala
08:21:29 <shapr> un peu de français, parlez vous?
08:21:43 <shapr> Luke: you need the latest nightly of hs-plugins from dons' site.
08:22:01 <Luke> from mail it looked like hs-plugins had been rolled into "riot", or are they separate?
08:22:28 <shapr> they're separate
08:22:51 <Deniz> shapr : je ne parle francais...
08:22:55 <Deniz> :)
08:23:01 <shapr> :-P
08:23:09 <Deniz> shapr : je ne parle pas francais...
08:23:10 <shapr> hollandska? tyka? finska?
08:23:11 <Deniz> ?
08:23:19 <Deniz> hmm.. no..
08:23:22 <shapr> alabamsk?
08:23:28 <Deniz> what ?
08:23:37 <thebug> hehe
08:23:40 <shapr> y'all come back now, ya hear?
08:23:51 <Deniz> hehe
08:28:25 <shapr> Luke: tuomov wrote riot, wanted to dynload Config.hs, didn't like the dichotomy between static and dynamic loading
08:32:37 <Luke> I still get 'ghc-6.2.1: unknown package name: plugins', possibly because debian's ghc is in /usr and hs-plugins is in /usr/local? if so, how do I tell ghc where to look?
08:32:56 <shapr> Luke: did you do 'make register' ?
08:33:30 <Luke> ahem. :)
08:33:50 <shapr> hej Deniz
08:33:50 <shapr> er depaulis 
08:34:06 <Luke> Expanding embedded variables... Unable to expand variable "LIBDIR"
08:34:10 <Luke> which LIBDIR does it want?
08:34:12 <shapr> yah, that happened to me
08:34:26 <shapr> I just did it manually...
08:34:31 * shapr gets the command line he used
08:34:46 <Igloo> Did you tell dons?
08:34:59 <shapr> 'env LIBDIR=/usr/local/lib/ ghc-pkg -u < src/printf/printf.conf.in'
08:35:11 <shapr> Igloo: yes, I told him and he's fixed it, but it may not yet be in the latest nightly
08:35:22 <Igloo> OK, cool
08:36:11 <Luke> dependency `eval' doesn't exist
08:36:28 <shapr> huh?
08:37:00 <shapr> Luke: I did that env part for each of the foo.conf.in entries in the Makefile
08:37:59 <Luke> ok, that fixed it, thanks
08:39:26 <Luke> $ ./hemacs
08:39:26 <Luke> Starting up dynamic Haskell ... 
08:39:26 <Luke> Fail: /usr/local/lib/hemacs/hemacs.conf: openFile: does not exist (No such file or directory)
08:39:34 <shapr> oh right
08:39:37 <shapr> make hemacs.conf
08:39:47 <shapr> actually, try 'make boot all'
08:39:49 <Luke> oh, I had to 'make install'
08:40:00 <shapr> there's an install target now?
08:40:01 <shapr> oh yeah
08:41:16 <mayhem> hi
08:41:22 <mayhem> anyone experienced in Chu spaces ?
08:41:28 <shapr> bonjour mayhem, comment ça va?
08:41:51 <mayhem> salut shapr .. ;) encore et toujours sur IRC ? ;)
08:42:17 <shapr> bien sûr!
08:42:21 <shapr> quelle surprise?
08:44:22 <shapr> bye luke!
08:46:01 <shapr> hiya ows 
08:46:06 <shapr> ows: more questions today?
08:46:15 <ows> yo shapr
08:46:19 <shapr> y0 y0
08:48:02 <bourbaki> heh
08:48:26 <bourbaki> shapr: did you learn haskell in the bronx ;)?
08:48:49 <shapr> actually, in the bronx it's more like italian. Heeey Tooony, howzit goin?
08:49:02 <bourbaki> hahaha
08:49:04 <shapr> it's hard to type that 'howzit gowin'
08:49:15 <bourbaki> ill write you a code you cant reject ;)
08:49:57 <shapr> In alabama, it's more like "Yo Homey, How's it hangin? You be chillin widgo niggaz in yo crib?"
08:50:40 <shapr> alternatively, there's "hi y'all, we just come back from Pidgin Forge, it's so lovely up their this time uh year"
08:55:23 <CosmicRay> Igloo: yes
08:55:34 <CosmicRay> shapr: did you see my solution for hsshellscripts?
08:57:08 <Igloo> CosmicRay: When you said ghci worked for you on amd64, was that pure64?
08:57:33 <CosmicRay> I didn't say it works there, just that it builds there
08:57:36 <CosmicRay> but yes, pure64
08:57:56 <Igloo> Ahh, OK, ta
08:58:24 <shapr> CosmicRay: yes, but I'm not quite sure *why* that fixed it.
08:58:25 <CosmicRay> I do have an amd64 box but it's running i386 debian just now
08:59:00 <CosmicRay> shapr: I have no idea either
08:59:10 <CosmicRay> according to what I know, haskell-src is the haskell parsing stuff
08:59:15 <CosmicRay> but it works
08:59:17 <bourbaki> heh shapr 
08:59:28 <CosmicRay> I noticed that HUnit depd on haskell-src
08:59:35 <CosmicRay> so syntaxninja may know about this
08:59:41 <shapr> yah, probably so
08:59:43 <CosmicRay> since I used his HUnit cabal files
09:00:45 <shapr> hoi swiert 
09:00:50 <swiert> hi shapr
09:00:58 <shapr> swiert: this is your new nickname?
09:01:05 <swiert> yes
09:01:08 <shapr> neat
09:01:19 <shapr> oh, I saw your pic on your website, very stylish glasses.
09:01:31 <swiert> when I was in high school we had two wouters in our class
09:01:54 <swiert> I became swiert and the nick still haunts me.
09:02:13 <swiert> the pic on my website is a bit dated - I now have even more stylish glasses.
09:02:35 <swiert> you can actually see that they are going crooked in the pic.
09:03:04 <shapr> cool, are you going to update your website?
09:03:27 <swiert> once I have an equally  charming picture of me with new glasses.
09:04:13 <shapr> oh, I want a copy of your thesis.
09:04:18 <depaulis> Hi, I am learning Haskell, and at the moment I am trying to get a grip of how high-order functions work. in an exercise I will define length using map and sum. The code I have been written does not work as I thought it would (http://www.dtek.chalmers.se/~depaulis/) And I cant get anything out of my book why it does not. Any help or tips would be really apreciated.
09:04:54 <swiert> no problem - once I have something worth reading, I'll be sure to send you a copy.
09:05:20 <swiert> at the moment I'm actually spending more time implementing than writing though.
09:05:28 <shapr> Are you working with epigram?
09:06:40 <swiert> I've messed about with epigram in the past and have some thoughts about how to do attribute grammar stuff in epigram (or any dependently typed language)
09:07:02 <shapr> oh speaking of attribute grammars, do you know how well they lend themselves to incremental parsing?
09:07:08 <swiert> but I still have a lot to work out. I might spend some more time thinking about it once I wrap up my thesis.
09:07:18 <CosmicRay> depaulis: using map and sum.  what sort of algorithm are you trying to do there?
09:07:35 <shapr> @type sum
09:07:36 <lambdabot> sum :: forall a. (Num a) => [a] -> a
09:08:05 <depaulis> CosmicRay : What I am trying to do is to define a function working just as the length function do, but using map and sum. 
09:08:15 <swiert> shapr: I'm not I understand what you want to do.
09:08:33 <shapr> depaulis: you could say the list represents its own length, if each item is just the value 1. In that case, you could use map to turn all the items to 1, and sum to get the length.
09:08:37 <Philippa> depaulis: so you're going to use map to turn every element of the list into something then sum to add those elements together?
09:08:52 <Philippa> shapr: aw, you could've let him figure out to map everything to 1 himself :-)
09:08:56 <CosmicRay> heh
09:08:58 <depaulis> CosmicRay : From what I read about the Prelude.hs 
09:09:01 <depaulis> slt
09:09:06 <shapr> hey, at least I didn't tell him how to do it :-)
09:09:19 <depaulis> sorry.. wrong button ;) hold on. reading what you say.. 
09:09:20 <CosmicRay> depaulis: does what shapr said make sense?
09:09:37 <shapr> swiert: I've been thinking about arrow-style incremental parsing for syntax-highlighting in an editor
09:10:11 <shapr> ski mentioned that it sounded like Doaitse's attribute grammar stuff to him, so I was wondering.
09:10:27 <Philippa> that reminds me, I emailed gmh asking how much it'd cost me to show up to just the epigram bit at BCTCS, given that I've got my own accomodation and food in the area...
09:10:29 <shapr> I've never tried to use UU_ST, so I don't know how it behaves.
09:10:34 <Philippa> (or to put it another way, because I live up the damn road)
09:10:38 <shapr> heh
09:11:17 <shapr> I could just ask John Hughes and Ross Paterson how they would approach incremental parsing with arrows... that might save me a lot of time.
09:11:38 <swiert> ok - if you don't want to use the current implementation of the UU attribute grammar system to do this sort of thing.
09:11:57 <swiert> s/if/
09:12:00 <depaulis> shapr : You mean I should turn every elements in the list to 1, and then take the sum of the list? 
09:12:16 <shapr> Is the UUAG system good for incremental parsing?
09:12:32 <shapr> depaulis: you think that would work?
09:13:19 <shapr> Is the attribute grammar system the latest version of the swierstra and duponcheel combinators that inspired arrows?
09:13:42 <swiert> shapr: the current implementation is fairly straightforward. I may be wrong, but I don't think it works fairly well if you want to evaluate the attributes incrementally.
09:13:47 <depaulis> shapr : That would work, yes. But I dont understand what I wrote would not work.. I get an error that I dont understand really (if I try my code in hugs) So maybe your way would be better  ;) 
09:14:07 <swiert> shapr: I do know that arrows were originally inspired by that paper you mentioned.
09:14:46 <swiert> shapr: but if your only interested in incremental parsing - I know arrows were inspired by the paper you mentioned.
09:15:23 <swiert> shapr: the attribute grammar system is actually a separate language that maps to pure haskell.
09:15:30 <shapr> hm, interesting.
09:16:01 <swiert> shapr: its fairly easy to use together with doaitse's parser combinators - the attribute grammar generates the parsers semantic functions.
09:16:08 <depaulis> shapr : But actually "map sum [1,1,1,1]" gives me the same error I get with the code on page. " ERROR - Cannot infer instance" 
09:16:27 <shapr> depaulis: you're not combining the steps correctly
09:16:42 <shapr> depaulis: the last step is to run sum on the list of [1,1,1]
09:16:57 <shapr> the first step is to use map to make a list of whatever into a list of [1,1,1]
09:17:03 <swiert> shapr: it should be pretty easy to build/install the uust library and mess around if you're interested.
09:17:23 <depaulis> shapr : AHA! Thanks I think I got it now! Thanks :O) 
09:17:31 <shapr> think of a string, "foo" which is really ['f','o','o'] - how do you turn that list into a 1 for each character?
09:18:25 <depaulis> shapr : [ 1 | n <- xs ] would give me the list of 1:s
09:18:29 <musasabi> back.
09:18:43 <shapr> depaulis: is that map?
09:18:49 <shapr> looks like a list comprehension to me
09:19:15 <shapr> depaulis: what function can you write that turns any single input into just the number one?
09:19:28 <depaulis> shapr : yeah ;) Forgot to use map for it ;) 
09:19:40 <swiert> shapr: I've got to leave now, be happy to tell you more later.
09:19:47 <shapr> swiert: ok, thanks for the info
09:20:24 <shapr> hoi xkb 
09:21:32 <depaulis> shapr : There is a function for that? 
09:22:22 <depaulis> shapr : you do mean that there is a Prelude function already done for that, otherwise I could as I thought above write a list comprehension for it... 
09:29:11 <shapr> depaulis: the list comp will work, but your teacher may not think that's really map
09:29:53 <shapr> there is a prelude function for turning things of any value into a single given value
09:29:54 <shapr> it's called const
09:33:04 <depaulis> shapr : I got it working. I wrote it like "length :: [a] -> Int" "length3 xs = sum (map tuggen xs)" "where tuggen x = 1" Could not find the function that turn an element to 1, but this must work as good as using that function? 
09:33:22 <dv> map (\x -> 1) xs
09:33:36 <shapr> @type const
09:33:36 <musasabi> const 1 :: a -> Int
09:33:37 <lambdabot> const :: forall a b. a -> b -> a
09:33:55 <musasabi> map (const 1) xs
09:34:16 <Igloo> This is now incorrect, right?:
09:34:17 <Igloo> HOpenGL was built as a part of the GHC compiler.  Note that this is
09:34:17 <Igloo> -not- the 'official' (aka. standalone) version of HOpenGL.  Due to the
09:34:17 <Igloo> hierarchical library transition, not everything is working yet.  See
09:34:17 <Igloo> <URL:http://bugs.debian.org/156339:> for the full story.
09:34:19 <depaulis> sum (map (const 1) xs)    I guss
09:34:43 <shapr> Igloo: I can never tell
09:34:57 <Igloo> I'll mail Sven to check
09:34:59 <shapr> Igloo: I wish Sven would delete *all* the old versions of HOpenGL
09:39:21 <musasabi> depaulis: why not fold over the list?
09:39:45 <musasabi> (you will probably have "fun" with stricteness then)
09:42:30 <depaulis> musasabi : "fold over the list" Well I dont really understand how you mean. but I got it working as I typed it. And I think it should be something like this. I also got alot of other things to learn before monday.. So I really have to move on. "fun" ? ;)
09:42:52 <shapr> depaulis: fold will help you understand other stuff you'll learn.
09:44:03 <shapr> a function that changes one value can be changed to a function that changes a whole list of values by map
09:44:04 <depaulis> Hmmm.. ahh.. wait.. Just looked down in my book here and guess what I saw ;O) "foldr" ;) I guess I will come to that soon then. 
09:44:28 <shapr> a function that changes two values into one value, can change a whole list of values into one value, by using fold
09:46:21 <depaulis> shapr : Still got some exercises on map, but I will get to fold later.. I deal with fold then
09:46:26 <shapr> ok
09:46:44 <shapr> depaulis: I tell you, this is really sexy stuff... it's *so much simpler* than C, C++, Java, Python, etc
09:48:00 <shapr> map is like a loop over a container, but you never have to worry whether the container starts at zero or one, you never have to worry about a type in your for (x=0;x >container.length;x++) { ... } loop...
09:48:01 <depaulis> that was not what I would like to hear :( for never doing any programming before I think this is kind of hard :(  ... But damn fun when its work :) 
09:54:28 <shapr> depaulis: do you know about turing machines, or lambda calculus?
09:58:18 <shapr> Java and Haskell are two different approaches to computing.
09:59:04 <CosmicRay> stupid question: what's the operator to diving one Int by another Int?
09:59:06 <tic> I think Haskell is easier to learn than the C-family of languages if you've never written a program before.
09:59:16 <tic> CosmicRay, / no?
09:59:19 <CosmicRay> no
09:59:22 <tic> hm. 
09:59:26 <tic> what's / then? :)
09:59:33 <shapr> @type (/)
09:59:33 <arjanb> div
09:59:34 <TheHunter> `div`
09:59:36 <CosmicRay> Prelude> :t (5::Int) / (2::Int)
09:59:36 <CosmicRay> No instance for (Fractional Int)
09:59:36 <CosmicRay>   arising from use of `/' at <No locn>
09:59:39 <shapr> eek
09:59:44 <shapr> I killed lambdabot!
09:59:47 <shapr> you bastard!
09:59:48 <CosmicRay> ah ha.
09:59:49 <CosmicRay> div.
09:59:50 <CosmicRay> thanks.
10:05:17 <Lemmih> Grrr. Stupid configure.
10:05:47 <shapr> lambdabot needs arrows...
10:05:50 <shapr> always gets lost.
10:11:28 <kristnjov> can anyone come up with good quickcheck properties for a black jack game?
10:11:43 <shapr> you could do card counting
10:11:58 <kristnjov> what do you mean?
10:12:21 <shapr> have you read the QuickCheckM paper as well as the original QuickCheck paper?
10:12:45 <shapr> basically, a blackjack game is simple enough that you can define how things should be after any transform
10:12:45 <kristnjov> no, but john hughes is our tutor and i know the basic uses of it
10:12:57 <shapr> the whole state of the game is simple enough that you can check everything
10:13:12 <kristnjov> well i'm all out of ideas
10:13:33 <shapr> look at the Queue checking that John does in the QuickCheckM paper.
10:15:11 <shapr> kristnjov: also, for a simpler check, read up on card counting
10:15:51 <kristnjov> i already have a couple of quickcheck properties which make use of my size function
10:15:59 <shapr> card counting is essentially where you remember all of what you've seen so far of the contents of the deck in front of you, and as you get closer to the bottom of the deck, you get a very good idea of what will come out next.
10:16:02 <kristnjov> size returns the amount of cards in one hand
10:21:08 <shapr> kristnjov: what's the theoretical max number of cards you could have in one hand?
10:22:02 <shapr> length [1,1,1,1,2,2,2,2,3,3,3] right?
10:22:41 <kristnjov> i guess
10:23:10 <kristnjov> although i may not keep the cards in a list, we have to use (Add (Card Rank Suit) Hand)
10:23:27 <shapr> well, datastructure doesn't really matter that much
10:23:34 <kristnjov> yeah i guess not
10:23:52 <kristnjov> shapr, but are you sure that that's the theoretical maximum number of cards?
10:23:58 <shapr> question is, what conditions should be valid for a blackjack game always, and what conditions should be valid only after certain conditions?
10:24:20 <shapr> kristnjov: for a valid, non-ended game, I don't see how it could be different
10:24:36 <shapr> @eval fold (+) [1,1,1,1,2,2,2,2,3,3,3]
10:24:50 <shapr> ahem
10:24:51 <shapr> @eval fold (+) [1,1,1,1,2,2,2,2,3,3,3]
10:24:51 <lambdabot> (line 1, column 7):
10:24:51 <lambdabot> unexpected "+"
10:24:51 <lambdabot> expecting simple term
10:24:54 <shapr> doh
10:25:02 <shapr> @eval foldr (+) 0 [1,1,1,1,2,2,2,2,3,3,3]
10:25:02 <lambdabot> (line 1, column 8):
10:25:02 <lambdabot> unexpected "+"
10:25:02 <lambdabot> expecting simple term
10:25:06 <kristnjov> well considering there are no cards with rank 1 except for some Aces (when hand value exceeds 21)
10:25:25 <shapr> not all aces?
10:26:02 <shapr> @eval foldr (\x y . x + y) 0 [1,1,1,1,2,2,2,2,3,3,3]
10:26:02 <lambdabot> 21
10:26:32 <kristnjov> aces are worth 11 until the hand exceeds 21, then they all become worth 1
10:26:46 <TheHunter> @eval sum [1,1,1,1,2,2,2,2,3,3,3]
10:26:47 <lambdabot> 21
10:26:53 <shapr> TheHunter: too easy ;-)
10:26:56 <kristnjov> perhaps you're right, i'm just questioning.
10:27:29 <shapr> so, four aces, four twos, and three threes is twenty-one.
10:28:42 <shapr> Assuming the four aces can all be worth 1, there should be no valid non-ended game where you have more than eleven cards.
10:29:25 <shapr> also, you should never have more than four cards of the same rank in your hand
10:29:26 <tromp> @index print
10:29:28 <lambdabot> Prelude,System.IO,IO
10:30:03 <shapr> kristnjov: this is just assuming you can check only the 'visible' portion of the blackjack game... think about applying these same ideas to network testing ;-)
10:33:26 <shapr> unsurprisingly, the discovery of decade(s)-old vulnerabilities in xdrlib and ASN.1 was found with QuickCheck-like tool written in Java
10:33:39 <shapr> nowadays, the trick is called protocol fuzzing
10:34:05 <kristnjov> ...so got any good ideas for quickcheck properties? :P
10:34:31 <shapr> basically, you make an FSM that describes legal states and legal paths from one state to another
10:34:49 <shapr> then you try to use the wrong path from various states
10:34:50 <kristnjov> oh.. basically.. :P
10:35:00 <shapr> you know finite state machines?
10:35:04 <kristnjov> nope.
10:35:15 <kristnjov> listen, i'm in an introduction course for functional programming :P
10:35:21 <kristnjov> barely done any programming at all before
10:35:32 <shapr> I never had any CS classes even, what's your excuse? ;-P
10:35:40 <d3n17_> how could I write bulls (x:xs) (y:ys) 
10:35:40 <d3n17_>     | x == y = 1 +  (bulls xs ys)
10:35:40 <d3n17_>     | otherwise = bulls xs ys
10:35:45 * shapr is teasing
10:35:50 <kristnjov> :P
10:35:51 <d3n17_> using list comprehension ?
10:36:06 <CosmicRay> for those of you just starting with functional programming
10:36:13 <CosmicRay> unfortunately there are not a lot of good haskell tutorials
10:36:16 <CosmicRay> but check out this one for ocaml:
10:36:33 <shapr> what about Yet Another Haskell Tutorial? or all the goodies on the Wiki?
10:36:56 <CosmicRay> http://www.merjis.com/richj/computers/ocaml/tutorial/
10:36:59 <CosmicRay> not as good
10:37:01 <Lemmih> CosmicRay: There are many good Haskell tutorials, IMHO.
10:37:06 <CosmicRay> YAHT is a pretty good one
10:37:13 <CosmicRay> Lemmih: I disagree
10:37:28 <CosmicRay> Lemmih: far too many of them are way too abstract
10:37:48 <CosmicRay> Lemmih: many of the remaining ones give so little space to I/O that if you want to do any, you have to look elsewhere
10:37:52 <shapr> kristnjov: anyway, a finite state machine is where you describe legal states, maybe awake and asleep, and legel paths that go from state to state. Like "GoToBed : awake -> asleep"
10:38:09 <shapr> and "StigaUpp : sova -> yrvakat"
10:38:16 * CosmicRay notes that the concepts you learn in OCaml will translate well to Haskell, and the syntax is even similar in a lot of cases.
10:38:23 <CosmicRay> Haskell adds a couple of new concepts :-)
10:38:41 <shapr> speaking of yrvakat, maybe we can add that as a state?
10:38:50 <Etaoin> d3n17_: bulls xs ys = sum [1 | (x,y) <- zip xs ys, x==y]  ? There might be a better way than that.
10:39:00 <Lemmih> CosmicRay: One just have to realize that it's possible to actually do stuff in a pure environment.
10:39:13 <shapr> now we have awake, asleep, and standing-up-but-not-really-here
10:39:14 <TheHunter> for all of you starting with functional programming: Don't try to learn Haskell by reading in OCaml tutorial, the concepts are different enough to cause confusion.
10:39:17 <desrt> CosmicRay; are you a mary timony fan?
10:39:30 <CosmicRay> Lemmih: yes.  trouble is, a lot of the tutorials make it seem far more difficult than it is, or skip it
10:39:34 <CosmicRay> desrt: never heard of mary timony
10:39:38 <desrt> helium?
10:39:59 <CosmicRay> TheHunter: that's bad advice.  It never hurts to learn another language.
10:40:00 <desrt> you're named after a song.  that's all :)
10:40:01 <shapr> kristnjov: once you've got a bunch of states like that, some paths become invalid
10:40:27 <CosmicRay> TheHunter: I'm not a worse Haskell programmer because I learned Python, Java, Python, OCaml, and probably some other languages since I learned C
10:40:35 <TheHunter> CosmicRay: I strongly disagree
10:40:36 <Etaoin> TheHunter: coming from non-functional languages, I found ocaml a necessary stepping stone to haskell...
10:40:37 <shapr> kristnjov: anyway, a finite state machine is one subsection of general 'automaton' theory.
10:40:40 <CosmicRay> TheHunter: I believe I'm a *better* Haskell programmer because of it
10:40:48 <TheHunter> beginners should first stick to one language
10:40:54 <Lemmih> CosmicRay: IO in Haskell is not very different from other langauges (when looking at the syntax). The library documentation should be good enough.
10:40:56 <shapr> I went from Python to Haskell.
10:41:07 <desrt> shapr; a good transition, all things considered
10:41:15 <CosmicRay> Lemmih: the library documentation is obviously not good enough for someone new to Haskell.
10:41:22 <CosmicRay> Lemmih: if you assume otherwise you are deluding yourself completely
10:41:24 <shapr> Personally, I agree with TheHunter, I think you should stick with one language till you get a good handle on how itworks.
10:41:34 <CosmicRay> Lemmih: how would a beginner deduce from that the indentation rulse for do
10:41:35 <shapr> CosmicRay: it often is good enough for people new to Haskell.
10:41:49 <Lemmih> CosmicRay: Why would a beginner be bothered with IO?
10:41:58 <shapr> I've seen a bunch of people show up here, read the Gentle Tutorial, and write Haskell code with no problem.
10:41:59 <TheHunter> CosmicRay: IO is a non-issue for haskell beginners
10:42:11 <CosmicRay> what program is useful without doing any IO?
10:42:19 <shapr> I couldn't do it, but a lot of people have.
10:42:39 <CosmicRay> I suggest that a program that does no IO at all is useless.
10:42:42 <desrt> wow.  this is pathetic.  it's been so long that i checked work into the gnome cvs that i've forgotten the CVSROOT
10:42:45 <CosmicRay> unless you're load-testing your machine.
10:42:46 <TheHunter> you can check out what stuff evaluates to with ghci
10:42:48 <Lemmih> CosmicRay: The non-IO tutorials will teach you about the syntax then the haddock documentation will be sufficient.
10:42:53 <CosmicRay> that's not a program, thehunter
10:43:13 <shapr> I don't think that a useful program is required to learn stuff.
10:43:14 <CosmicRay> Lemmih: some of them don't mention IO **AT ALL**
10:43:30 <CosmicRay> shapr: no, but it helps a lot.
10:43:30 <Lemmih> CosmicRay: So?
10:43:34 <TheHunter> just tell them to type main = print $ myExpression
10:43:50 <shapr> I think there's a good reason to not mention IO when first learning Haskell
10:43:56 <CosmicRay> and when they want to read?  loop over stuff?  detect EOF?
10:44:02 <CosmicRay> I disagree shapr
10:44:03 <Lemmih> CosmicRay: Almost all the major tutorials have at least a couple of sections about IO.
10:44:10 <CosmicRay> do get a well-rounded understanding of a language, IO is vital
10:44:20 <tuomov> you need _some_ IO
10:44:26 <CosmicRay> Lemmih: I remember seeing one that explicitly said IO was out of scope for it.
10:44:31 <shapr> yes, I agree, but learning Haskell is usually harder when monads are in there at the beginning.
10:44:33 <TheHunter> but it doesn't make much sense to start with monadic IO until you have a good feel about the evaluation order and stuff like that
10:44:38 <tuomov> a final putStr, if nothing else
10:44:49 <CosmicRay> shapr: It doesn't have to be.  You can tell people to use <- to read and how to write, and leave it at that for a little while,.
10:44:56 <Lemmih> CosmicRay: Yes. Monadic operations can be very confusing for beginners.
10:44:57 <desrt> you don't need IO if you learn haskell inside of ghci or hugs
10:45:05 <desrt> which is really how you ought to
10:45:10 <shapr> CosmicRay: that's how Hudak's book works, and that's what I teach people.
10:45:23 <TheHunter> CosmicRay: and when they get their first monadic type error without even knowing what a monad is, they totally freak out
10:45:23 <Lemmih> CosmicRay: And it's almost never needed when you're learning.
10:45:42 <CosmicRay> Lemmih: I needed it right away, because I wanted to write programs and experiment as I was learning.
10:45:53 <CosmicRay> just typing in expressions to hugs does something, but little.
10:45:56 <desrt> dr. kahl *just* introduced IO and we're more than a month into haskell
10:46:00 <Lemmih> CosmicRay: That's what the interpreters are for...
10:46:06 <shapr> I wrote a text mandelbrot fractal thingy, and ran it inside GHCi 
10:46:15 <desrt> shapr; what toolkit?
10:46:31 <shapr> desrt: it just made little asterisks
10:46:33 <Lemmih> CosmicRay: You can load files with Hugs and GHC.
10:46:36 <desrt> heh.
10:46:37 <tuomov> heh. I also wrote text mandelbrot as one of my first haskell programs..
10:46:43 <CosmicRay> Lemmih: I am aware of that.
10:46:48 <CosmicRay> Look, here's my point.
10:46:54 <Lemmih> CosmicRay: Then why isn't it enough?
10:46:57 <shapr> thing is, text fractals don't really need IO, you can just show the string
10:46:57 <desrt> one of my first programs was a cool triangle fractal in gtk
10:46:59 <CosmicRay> If IO is so darn scary, then it is done wrong.
10:47:05 <CosmicRay> I don't believe it is that scary
10:47:24 <shapr> it's not scary, it's just confusing
10:47:26 <CosmicRay> and I think that trying to hide seriously important details like how to do basic IO is a wrong approach
10:47:31 <shapr> look at the poor suckers who learn programming with Java
10:47:34 <CosmicRay> not if presented right
10:47:41 <shapr> you *must* make an object with every Java program
10:47:43 <CosmicRay> shapr: yeah, I/O in Java is confusing
10:47:48 <TheHunter> CosmicRay: sure IO is scary, in fact haskell is one of the languages where it is the least scary
10:47:52 <shapr> and you won't know what that means until you understand OOP
10:47:55 <Igloo> I agree with Cos - it's only scary because everyone tells everyone else it is, and that puts people off learning it
10:48:27 <shapr> CosmicRay: write a better tutorial =)
10:48:38 <shapr> CosmicRay: your second book? want some helpful contributors? ;-)
10:48:44 <CosmicRay> It is damn simple to write a Hello World with a few lines of "do", and with explaining the caveat that you must use <- and store input in a variable, you give epople enough to read and write from the terminal in a few lines
10:48:49 <CosmicRay> shapr: :-)
10:48:54 <shapr> 'Haskell in a Nutshell' by John Goerzen
10:49:06 <CosmicRay> shapr: I've considered doing something like the Merjis OCaml thing with Haskell
10:49:11 <CosmicRay> I don't know Haskell well enough yet though
10:49:16 <tuomov> CosmicRay: you can tell that.. but it doesn't really tell what's happening
10:49:23 <tuomov> and some people want to know what's really going on
10:49:28 <CosmicRay> tuomov: that's OK, you can leave that for Chapter 7
10:49:33 <CosmicRay> like all the tutorials do anyway :-)
10:49:43 <Lemmih> Igloo: IO in itself isn't hard nor scary but the concept of a Monad can be very confusing.
10:49:46 <shapr> Hudak's book uses IO early on, and explains it laet.
10:49:47 <shapr> late
10:50:16 <Igloo> Lemmih: But you can just teach beginners how to use them, not the generality or cat. theory background
10:50:18 <shapr> I think monads are simpler than OOP.
10:50:33 <shapr> not sure about arrows yet.
10:50:40 <CosmicRay> shapr: I may have to buy that one then
10:50:41 <tuomov> I hate to figure out how the CT Monad relates to haskell monad operators before I could use IO :)
10:50:53 <CosmicRay> shapr: I don't have any haskell books, have only read online material so far
10:50:57 <Lemmih> Igloo: Isn't the haddock documentation doing that?
10:51:03 <CosmicRay> shapr: I prefer practical stuff to abstract
10:51:28 <tuomov> arrows are simpler than monads
10:51:38 <tuomov> >>= is weird
10:51:42 <shapr> heh
10:51:56 <shapr> some astronomy guy named kleene...
10:52:09 <shapr> arrows really are simpler than monads.
10:52:21 <TheHunter> that depends on the monad, list monads are easier that nondet arrows and state arrows are easier that state monads
10:52:47 <shapr> list monads are really easy if you look at them from the monad as container perspective
10:53:15 <CosmicRay> I made this comment on /. yesterday, comparing I/O in Python, Haskell, and Java: http://books.slashdot.org/comments.pl?sid=125530&cid=10530681
10:53:30 <CosmicRay> Java takes about 10 lines to display two lines and read one
10:53:45 <CosmicRay> Haskell takes three and you don't even have to know squat about monads to do it.
10:53:48 <CosmicRay> thanks to interact
10:54:27 <CosmicRay> interact is one of my favorite functions :-)
10:54:31 <shapr> yah, interact is spiffy
10:55:02 * TheHunter wrote a 150-line java program yesterday that is equivalent to a one-line haskell program.
10:55:04 <CosmicRay> I think it's stupid that there is nothing in the standard library that lets you apply interact to arbitrary handles, though
10:55:06 <Igloo> You can do it in 3 lines with do syntax too, and that way you wouldn't be relying on buffering to get the right effect
10:55:11 <CosmicRay> heh
10:56:55 <Igloo> I don't think that's a great example to show people how easy Haskell is to understand, either  :-)
10:57:20 <CosmicRay> that's quite true :-)
10:57:32 <desrt> TheHunter; that's not too impressive
10:58:02 <desrt> it's all about what's available to you in the standard library 
10:58:07 <TheHunter> foldM (\x y -> [y:x,x] ) []
10:58:17 <CosmicRay> java does have us beat in that department
10:58:21 <shapr> desrt: I disagree, I think the standard abstractions are often overlooked.
10:58:24 <CosmicRay> the java standard library has all sorts of goodies
10:58:33 <TheHunter> it's basically about laziness and having to emulate it with iterators
10:59:08 <desrt> foldM on lists is cool.
10:59:47 <TheHunter> why the hell is there no foldrM in the standard library?
10:59:57 <Igloo> Anyone know of a nice way to get a graph of memory usage over time of an arbitrary binary program under Linux?
10:59:57 <stepcut> this seems clearer, even though it uses monads... main = putStrLn "Who are you?" >> getLine >>= \name -> putStrLn ("I'm glad to meet you " ++ name)
11:00:06 <stepcut> cuz the >> and >>= imply a direction of action
11:00:17 <shapr> Haskell has a few small parts that interact in amazing ways, and Java has a very large number of parts that don't really do that much.
11:00:36 <desrt> stepcut; that's all that do does, though
11:00:37 <Igloo> stepcut: It's still more obvious how it all works if you use do notation, though
11:00:50 <desrt> you get <- implying direction with the do
11:00:53 <desrt> name <- getLine
11:01:00 <stepcut> desrt: hrm, that is true...
11:01:03 <shapr> Of course, that means you can just drop into Java and use it, but Haskell requires lots more understanding.
11:01:19 <tuomov> err. that interact example doesn't work
11:01:22 <musasabi> monadic IO is very nice, but the haskell standard library is not perfect.
11:01:28 <tuomov> it prints I'm glad etc. before user input
11:01:43 <shapr> musasabi: we can fix it! #haskell world domination!
11:02:04 <desrt> tuomov; it does?
11:02:26 <shapr> I do wish spec_eval would come back.
11:02:38 <desrt> with >>= i thought it was impossible for putStrLn to run before getLine finishes...
11:03:47 <desrt> since putStrLn requires the updated IO monad that's only computed by getLine finishing...
11:04:07 <stepcut> desrt: I don't disagree, what brings this up ?
11:04:20 <desrt> 14:05 <tuomov> it prints I'm glad etc. before user input
11:04:28 <shapr> desrt: have you tried it?
11:04:33 <desrt> shapr; no.
11:04:36 <stepcut> desrt: err. that ---> interact  <---- example doesn't work
11:04:39 <shapr> I tried it...
11:04:39 <Igloo> tuomov: It'll depend on the default buffering. I thought it was always line buffering nowadays, but it might not be for interactive envs
11:04:44 <desrt> stepcut; ah.  gotcha :)
11:04:51 <stepcut> :p
11:05:08 <tuomov> ok, it seems to work compiled
11:05:11 <tuomov> but not in ghci or hugs
11:05:15 <shapr> in GHCi, it works as tuomov described, compiled it's fine.
11:05:50 <shapr> hiya Strx 
11:07:08 * shapr throws lambdas
11:07:30 * shapr runs around in circles
11:08:34 <d3n17_> is there any standard list function that calculates how many times an element appears in the list ?
11:10:13 <musasabi> d3n17_: length + filter ?
11:10:50 <d3n17_> thx
11:11:59 <musasabi> world domination sounds good...
11:17:57 <TheHunter> CosmicRay: just to make sure, i only disagreed with your first remark, i don't think that knowing other languages makes you a worse haskell programmer
11:24:14 <musasabi> Knowing other languages will make one a better programmer.
11:25:02 <stepcut> I wonder if know vi will make me a better emacs user...
11:25:27 <Philippa> musasabi: with the possible exception of any version of basic
11:26:37 <musasabi> stepcut: It will give you insights of different ways of doing things.
11:26:40 <tuomov> using emacs should not in itself be problem-solving
11:26:51 <kristnjov> hehe
11:26:53 <kristnjov> i hate emacs :/
11:26:57 <tuomov> metoo :)
11:26:59 * musasabi uses emacs with vi emulation regularly
11:27:17 <Philippa> musasabi: exactly - basic gives insights into how not to do it ;-)
11:27:18 <kolmodin> how far is hs-plugins from working on windows?
11:27:25 <tuomov> but in problem-solving, knowing different approaches should usually help you
11:27:34 <tuomov> something it might, however, be best to know no previous approaches
11:27:43 <tuomov> to come up with a really novel approach
11:27:48 * Philippa nods
11:27:55 <Philippa> 'soften my advantage when I come at a hard problem...
11:28:14 <stepcut> tuomov: I often use emacs to solve problems, like add a trailing \ to the end of a file list in a Makefile...
11:28:20 <tuomov> s/something/sometimes/
11:33:38 <Lemmih> Any got HSQL 1.4 install?
11:33:45 <Lemmih> *installed
11:34:42 <kolmodin> no, for me it fails with this: MySQL.hsc:144: error: `MYSQL_FIELD' undeclared (first use in this function)
11:35:39 <kolmodin> hmm
11:36:00 <kolmodin> actually, first message is this: MySQL.hsc:33:21: HsMySQL.h: No such file or directory
11:40:40 <Lemmih> I get 20 erros when I compile it with postgres support.
11:42:52 <kolmodin> I'm only trying to compile with mysql
11:43:31 <Lemmih> I actually successfully compiled it with mysql support some time ago.
11:43:43 <kolmodin> ohh! how? :)
11:44:08 <kolmodin> it whines about HsMySQL.h: No such file or directory
11:44:25 * stepcut has some version of HSQL installed
11:45:10 <stepcut> actually, it appears i don't
11:46:25 <Lemmih> kolmodin: I think you need to move it to /tmp or something.
11:46:48 <kolmodin> Lemmih: good thinking
11:47:49 <kolmodin> it needed <HsMySQL.h> so i gave it "HsMySQL.h" instead. that was ok until it wanted to compile from /tmp/ghc$$$$.hc
11:49:37 <Lemmih> Isn't HSQL maintained anymore?
12:03:46 <kolmodin> Lemmih: thanks! I finally got it to compile and install
12:04:29 <Lemmih> kolmodin: HaskellDB doesn't play nice with MySQL /-:
12:04:39 <kolmodin> :(
12:05:28 <kolmodin> it works better with postgres?
12:06:03 <kolmodin> or sqlite perhaps
12:06:25 <Lemmih> Yes. MySQL doesn't support nested queries which HaskellDB is using a lot.
12:08:32 <kolmodin> from HaskellDB's homepage: MySQL, version 4.1 or greater, since earlier versions do not support nested queries.
12:08:50 <kolmodin> I'm using 4.1.4 so it should be ok. or?
12:09:40 <Lemmih> Sure. But there's no ebuild for 4.1 yet and I don't feel like booting my debian machine.
12:09:54 <kolmodin> in gentoo?
12:10:01 <Lemmih> Yes.
12:10:36 <kolmodin> i found an ebuild in the bugzilla Bugs part of gentoo homepage
12:10:49 <kolmodin> and it works pretty well
12:11:15 <kolmodin> but it breaks DBD-mysql or something like that, mysqlsupport in perl
12:14:26 <Lemmih> Anyhow, I'm hacking on some software which isn't gonna run my machine so depending on a new version of MySQL isn't exactly good.
12:14:32 <kolmodin> http://bugs.gentoo.org/show_bug.cgi?id=62582
12:15:03 <kolmodin> ok
12:57:29 <Lemmih> YAY! I got it working!
13:04:11 <kolmodin> :)
14:18:28 <stepcut> mysql 4.1.6gamma is out (good news for haskelldb)
14:30:15 <stepcut> everytime I see GADT, I think of that j-pop band gackt
14:32:56 <stepcut> http://www.mahamari.com/story/pics/hishou/hs_front.jpg
14:40:33 <Jan_w> thinkgeek got some cool tshirts :)
14:40:38 <Jan_w> how about "How many people can read hex if only you and dead people can read hex?"
14:41:21 <Jan_w> or "There are 10 types of people in the world: Those who understand binary, and those who don't... "
14:43:13 <Lemmih> I don't get the first one...
14:44:47 <stepcut> 0xdeae ?
14:45:05 <Lemmih> ah (-:
14:45:15 <stepcut> took me a while :)
14:55:59 <lmbdwar> hi peoples 
14:57:01 <Lemmih> Hello
15:15:51 <depaulis> In an exercise on foldr I am going to sum the squares of the natural numbers 1 to n using foldr. "function x = sum (foldr double 0 [1 .. x])     where double x = x*x 
15:16:43 <depaulis> This did not work, double dont seems to fit the definition of foldr f function, in some way.
15:17:59 <Oejet> depaulis: foldr takes a binary function.  Double is unary.
15:18:15 <kristnjov> how do i get the last part of (a,b,c)
15:18:17 <kristnjov> ?
15:18:23 <Cale> sum (map double xs)
15:18:42 <Oejet> @index foldr
15:18:42 <lambdabot> Data.List,GHC.Base,GHC.List,Prelude,List
15:18:51 <Oejet> @type foldr
15:18:52 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
15:18:55 <depaulis> Oejet : Okay.. I can se that now when you say that.. It would work with map, but to get it with foldr I have to make the function binary ..
15:18:57 <Cale> kristnjov: (_,_,x) <- (a,b,c) in a pattern binding, or (\(a,b,c) -> c)
15:22:28 <Oejet> depaulis:  Yes, f.ex. \x y -> (double x)+y
15:24:18 <depaulis> Oejet : I still have some pages in the book before I have to deal with the lambda thing ;) anyway how can I make a function binary when the only thing it has to do is to take the element x and do x*x ? 
15:26:21 <depaulis> my function that will take the square of an element must be "a -> a -> a"  But.... ? Maybe I am doing this the wrong way.
15:27:03 <arjanb> depaulis: i think you shouldn't use to 'sum' function
15:27:58 <Oejet> dep: Actually arjanb is right, if you use foldr and the suggested function, that is all you need.
15:28:18 <depaulis> arjanb : hmm... let me think
15:28:24 <Cale> depaulis: you could define squarePlus x y = x*x + y, like the lambda expression above
15:29:06 <arjanb> depaulis: first try to write you own sum using foldr
15:29:07 <depaulis> Cale : I am not so familuar with the lambda expression. 
15:30:01 <Oejet> foldr takes a kind of accumulating function f(x,y) where y is the accumulator and x is the list element.
15:30:55 <Oejet> depaulis: f x y z = ...  <=> (\x y z -> ...)
15:30:57 <depaulis> accumulater, have to look in a dictonary. hold on ;) 
15:33:13 <Oejet> More accurately: f x y z = ...    <=> f = (\x y z -> ...)
15:33:55 <depaulis> hold on.. I am trying to read what you have typed... and understand that ;) 
15:36:56 <Oejet> foldr op 0 [1,2,3,4] = (1 `op` (2 `op` (3 `op` (4 `op` 0))))
15:37:39 <Oejet> op x acc = x*x + acc
15:38:09 <depaulis> Oejet : Hmm... 
15:38:44 <Oejet> So we square the left hand of `op` and add it to the sum of squares so far.
15:39:05 <depaulis> op here would be an function or an operater that would square the element right? Or am I missing your point with that acc here? 
15:39:37 <depaulis> okay, op could be (+) that would sum it.
15:39:58 <Oejet> depaulis:  Exactement!
15:40:26 <Oejet> depaulis:  Lige præcist.
15:40:39 <depaulis> Oejet : ;O) Okay... but I have to square it.. but where do I do that? 
15:41:14 <Cale> depaulis: change plus to something that squares one thing and adds it to the other.
15:42:10 <depaulis> Cale : Ohh? Is there an op for that? Or is it some kind of combo op? ;)
15:42:34 <Cale> depaulis: write one :)
15:42:47 <Oejet> See my definition of `op` just before.
15:43:34 <depaulis> aha... 
15:43:41 <Oejet> x `op` acc = x*x + acc
15:43:55 <Oejet> (another way to write the same thing)
15:43:55 <depaulis> yeah... Nice :)
15:44:46 <depaulis> Hehe... wonderfull.. Now I have try it out :) And see if it works in practice :O) Thanks alot all of you! I might get back soon ;) 
15:45:04 <Oejet>  x `op` acc = x*x + acc = new right hand side of the `op` expression
15:52:47 <depaulis> I feel kind of dumb, but it seems like I know what I want but I dont know how to define this new op. the acc... how will I define this? 
15:54:17 <depaulis> If I call the new op &&&, Then I will start of by "(&&&) :: Int -> ? -> Int" but what is the acc really? 
15:56:39 <Oejet> It is just a parameter.  Nothing special.
15:57:30 <Oejet> It is just an Int.
15:58:35 <depaulis> Oejet : okay.. lets see then..
16:01:54 <depaulis> "(&&&) :: Int -> Int -> Int" "x &&& acc = x*x + acc" And then my "squaresum x = foldr (&&&) 0 [1 .. x]" 
16:03:39 <Oejet> depaulis: Taadaa.
16:04:33 <depaulis> Oejet : Well.. Hugs complain "*** Expression     : 0 &&& enumFromTo 1 x
16:05:30 <depaulis> "*** Term           : enumFromTo 1 x" "*** Type           : [Int]" "*** Does not match : Int"
16:06:21 <depaulis> "enumFromTo 1 x" ?? 
16:06:52 <Oejet> How do you type it in Hugs?
16:07:20 <depaulis> Oejet : give me a minute and I get you a link to the code. and the error message.. 
16:07:48 <Oejet> I don't get any errors in GHCi.
16:08:25 <Oejet> OK.
16:09:01 <depaulis> I dont use GHCi I use hugs 98.. the link is soon done.
16:09:17 <Oejet> OK.
16:11:56 <shapr> any ion3 users around?
16:13:59 <depaulis> Oejet : http://www.dtek.chalmers.se/~depaulis/
16:16:12 <Oejet> Aha!
16:16:21 <arjanb> you need to remove the outer parentheses
16:16:23 <ows> shapr: Heya, do you know good pages with AI things (like Recurrent Neural Nets, Bayesian Nets...) implemented with haskell?
16:16:59 <shapr> ows: I found some neural nets with google. I wrote some bayesian statistics code myself.
16:17:05 <depaulis> arjanb : ops.. I see what you mean.. I guess that was the "Aha!" Oejet? 
16:17:23 <Oejet> It was, depaulis.
16:18:06 <depaulis> And it worked :O)
16:18:29 <ows> hum, only curiosity but how much time do you need to do that with haskell (bayesian statistics), and how much time do you expect to do that with java, c or even c?
16:19:11 <shapr> It took me three or four evenings to learn bayesian statistics and write a spam filter with Haskell.
16:19:13 <depaulis> Thanks again! I missed the little sidenot on a page "how to define your own operators" ;)
16:19:47 <shapr> It would take me longer to write it in Java or C.
16:20:16 <Oejet> It doesn't have to be a symbolic operator like &&&, it could be named `f`.
16:21:02 <shapr> ows: the code isn't very pretty, and it doesn't work very well, since it only caught 85% of my incoming spam. But it's not bad for 200 lines and a few evenings after work.
16:22:41 <shapr> A bayesian spam filter looks really nice in functional style.
16:23:12 <depaulis> Oejet : the book talked about infix operators, we talk symboloc operators? Is there any differens among them? 
16:23:36 <ows> hum, you said that probably take longer to write with java and c, cause you have more experience in haskell, or FP languages should be better for coding chunks of code
16:23:41 <shapr> is there some way to create a new dir to put files into with scp while copying?
16:24:33 <shapr> ows: I've been using Java since it was in Beta, I have lots more experience with Java. I won't say that FP languages are better for all code, but Haskell is very nice for bayesian statistics.
16:25:15 <shapr> I'll upload the code, you can look at it.
16:25:49 <Oejet> depaulis: Hm, I meant that symbolic operators (&&&,+,$) are born infix, while all functions of two arguments (g,double,f) can be used as infix operators by putting `` around (`g`, `double`, `f`).
16:26:12 <shapr> ows: http://www.scannedinavian.org/~shae/src/haskell/paskalle/
16:26:59 <ows> do you consider all FP languages as AI prog lang?
16:27:01 <shapr> I got bored in the middle of writing a lazy key promoter.
16:27:39 <shapr> No, I think the best AI language depends on what kind of AI you want.
16:28:46 <depaulis> Oejet : okay, time for some late night food now. Thanks again for the help
16:29:14 <shapr> For neural networks and bayesian statistics, Haskell is nice. Mostly because those are easy to express in Haskell.
16:29:30 <shapr> For some sorts of AI, I'd probably use a logic language.
16:29:41 <shapr> but once again, it depends on the app.
16:31:44 <Oejet> shapr:  In Paskelle.hs one of the only big non-monad functions are "msgToKeywords".  Why are not more functions monadless?
16:32:08 <Oejet> depaulis: Velbekommen og sov godt.
16:32:19 <shapr> Oejet: sheer lack of refactoring
16:32:34 <shapr> that's just a few evenings hacking, then I got bored.
16:32:45 <dons> hmm. should we start haddock'izing hemacs internals
16:32:50 <shapr> yes!
16:32:53 <shapr> greetz dons 
16:33:00 <dons> if people are going to start scripting this thing...
16:33:19 * dons is writing in comments like mad, to understand the code
16:33:22 <shapr> Oejet: if you actually want to use Paskalle, I can clean it up some.
16:33:38 <shapr> Oejet: but you have to ask a finnish person what the name means ;-)
16:33:53 <dons> time to add a haddock doc target
16:35:31 <Oejet> shapr:  Oikein sille paskalle.
16:35:48 <shapr> ows: I've never written any neural net code in Haskell, so I may be underestimating the difficulty of things like backpropagation, but I don't think it would be very hard.
16:36:02 <shapr> Oejet: puhutko suomea?
16:36:16 <dons> all the neural net code I have written was in C. that was painful
16:36:25 <Oejet> shapr: Ja.
16:36:26 <shapr> dons: think it'd be easier in Haskell?
16:36:29 <dons> turned me off neural nets for a long time
16:36:36 <dons> yes. a lot easier
16:36:50 <dons> the language is closer to the domain in question
16:37:05 <dons> better semantic embedding
16:37:05 <shapr> I think I wrote my last neural net code in ... C++ ... early 90s?
16:37:20 <Oejet> shapr: No, actually just pasted it from a random page from Google to impress you.
16:37:26 <shapr> Oejet: :-)
16:39:08 <shapr> As I understand it, paska is 'shit' and 'lle' is the "to take out of" suffix. Colloquially, it also means "to take a dump".
16:39:43 <Oejet> Game trees are nice in Haskell.  See f.ex. Why functional programming matters, Hughes.  Have written a connect four brain.
16:40:33 * Oejet is wondering what he wrote in Finnish then.  (taken from city.fi)
16:41:07 * shapr has only a vague idea
16:41:56 <Oejet>  Pyri kirjoittamaan tunnustuksesi lyhyesti ja shapr paskalle.
16:42:52 <shapr> um
16:43:27 * shapr pretends to be a clueless uncultured American.
16:44:17 * TheHunter discards a change he wanted to make to the wiki:
16:44:28 <Oejet> shapr: Sorry.  Don't know any Finnish; its just getting late in Copenhagen.
16:44:29 <TheHunter> Although this transformation often respects type isomorphisms, this is not always the case. For example a function of type {{{a -> b}}} is transformed to a function of type {{{a -> m b}}}, while the isomorphic type {{{(() -> a) -> b}}} is mapped to {{{(() -> m a) -> m b}}} which is in general not isomorphic to {{{a -> m b}}}. The reason for this is that () is not a terminal object in the Kleisi category of m.
16:45:25 <shapr> TheHunter: nifty
16:46:17 <TheHunter> it'd not even on-topic...
16:46:29 <shapr> it looks on-topic
16:46:36 <shapr> but I don't know what transform you speak of...
16:46:44 <shapr> aha, Zipper.hs
16:46:56 <shapr> already being used for a structure editor in the Grammatical Framework
16:53:17 <dons> this is nice. hemacs is working happilly from with ghci. makes everything easier
16:53:27 <phubuh> hemacs?
16:53:58 <dons> a semi-mythical project to write a scriptable editor in Haskell
16:54:03 * shapr really gotta re-add factoids to lambdabot 
16:54:26 <stepcut> dons: i bet it does (regarding ghci)
16:54:46 <shapr> stepcut: hey, your email went to scannedinavian.org, not lists.
16:54:50 <shapr> that's why it bounced
16:55:12 <stepcut> To: post-emacs@lists.scannedinavian.org
16:55:17 <shapr> stepcut: did you actually send to lists. ?
16:55:22 <shapr> well
16:55:35 <shapr> that explains the errors Luke and Darius got...
16:55:54 <shapr> can you send me the bounce?
16:55:55 <dons> stepcut: yeah. i spent a bit of time on ghci support yesterday, after thinking about the issues darcs is in now re. ghci
16:56:03 <dons> good to get it working right from the start.
16:56:11 <dons> just like making it portable from the start
16:56:20 <shapr> darcs is breaking trail for hemacs
16:56:26 <dons> it is
16:56:31 <shapr> phubuh: grab the hemacs darcs repos, hack with us :-)
16:56:38 <phubuh> whee!
16:56:43 <phubuh> what's the url? :-)
16:56:52 <stepcut> shapr: that is copy and pasted directory from the email
16:57:20 <shapr> that must be a rewriting problem somewhere?
16:57:23 * shapr thinks
16:57:29 <dons> hemacs can also be accessed from: darcs get http://www.cse.unsw.edu.au/~dons/hemacs
16:57:43 <phubuh> thanks
16:57:49 <dons> (note the 'code' dir is not necessary, i kept forgetting it anyway)
16:58:30 <dons> another thing I learn from darcs is to use -Wall by default
16:58:44 <Igloo> Huzzah!
16:59:40 <dons> and to use a ghc -M style build system. hmm, darcs has been quite influential
16:59:46 <shapr> Igloo: use of -Wall ?
16:59:50 <Igloo> Yup
17:00:04 <dons> Igloo: ?
17:00:17 <dons> fan of warnings? :)
17:00:17 <Igloo> I'm just cheering from the sidelines, don't mind me
17:00:28 <Igloo> A fan of their absence  :-)
17:00:43 <dons> yeah. me too. -Wall should be default for everyone
17:00:48 <shapr> Igloo: hey, any comments on Zipper or other datastructure?
17:01:00 * Igloo hasn't read about Zipper
17:02:13 <dons> shapr: also, SPJ wrote a paper on an editor buffer structure back in '93 I think
17:02:19 * dons googles
17:02:22 <shapr> oh really... must check that out.
17:02:43 <shapr> And then send him an email and ask for further thoughts in the last eleven years.
17:02:50 <Igloo> I think to do syntax highlighting properly you want an incremental algorithm where you evaluate the tail after any change lazily. Doing it properly does mean you either need linear memory or recomputation, though.
17:04:22 <dons> well, how does SimonM do this in vis.studio. that would be a good thing to look at?
17:04:44 <shapr> I think you can get away with only evaluating the parser whose text has changed.
17:05:04 <Igloo> That'll be Haskell specific, so rather easier
17:05:34 <shapr> Wouldn't VStudio have its own buffer?
17:05:35 <Igloo> shapr: If you insert -} in a Haskell file you may need to recolour everything after that point
17:06:37 <shapr> Igloo: true, best I could think of was that you might get away with it if you reparse only the changed text, and the result fits perfectly with the following formerly parsed tree
17:07:04 <Igloo> It's probably as simple as an automaton, a state associated with each character (or just something keeping track of where the state changes) and then only updating states after the current page when you scroll down
17:07:41 <Igloo> Then if you type {-- it doesn't actually change the entire data structure once after "{-" and then back again after the final "-"
17:07:49 <shapr> Hm, the zipper is a tree http://www.haskell.org/hawiki/TheZipper
17:08:10 <shapr> with focus...
17:08:42 <shapr> Yah, I wondered about that sort of update.
17:08:48 <TheHunter> Igloo: if you need type information, you'd need to parse the rest of the text anyway.
17:09:10 <shapr> that's one cool thing a Haskell editor would do, give good type info
17:09:13 <Igloo> I was only talking about syntax highlighting
17:09:27 <Igloo> Is this a Haskell editor or an editor written in Haskell?
17:09:42 <shapr> b)
17:09:59 <dons> ah. not SPJ -- SBJ.
17:09:59 <dons> Simon P. Booth, and Simon B. Jones "A screen editor written in the Miranda
17:10:00 <dons> functional programming language" ,Technical report TR-116
17:10:05 <Igloo> I think type info would need to be a separate Haskell-specific plugin that gets told about all buffer changes then
17:10:08 <dons> ftp://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR116.ps.Z
17:10:25 <dons> that seems reasonable
17:10:43 <shapr> url is 404
17:10:46 <Igloo> I assume there is some stuff on incremental typing out there, although probably not with all the extensions around
17:11:00 <shapr> type-error slicing has to be incremental already
17:11:04 <shapr> epigram is incremental
17:11:12 <Igloo> Hmm, type info in Haskell would be a bit odd, though
17:11:25 <dons> ftp://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR116.ps.Z
17:11:30 <Igloo> As you start writing a pair of mutually recursive functions, the type info it tells you can be wrong
17:11:31 <dons> oop.s wrong one.
17:11:52 <shapr> yes, but you can type much of the buffer.
17:11:58 <shapr> typecheck
17:12:05 <Igloo> Although you'll be giving all your top-level functions type sigs anyway to keep -Wall happy and give better errors, of course  :-)
17:12:33 <Igloo> shapr: I'm not saying it'll be absent, I'm saying it'll tell you the wrong answers making you potentially write incorrect code
17:12:40 <dons> http://www.cs.stir.ac.uk/research/publications/techreps/pdf/TR116.pdf
17:13:07 <shapr> Igloo: interesting point
17:17:21 <shapr> I wonder how the type error slicers do it.
17:18:36 <dons> i wonder why i have such a compulsion to fix "This binding for `tt' shadows an existing binding" errors :)
17:22:05 * shapr wishes .ps files could be easily reformatted to fit more text on-screen
17:26:36 <stepcut> heh
17:30:03 <jao> hm. any freebsd/ghc user around?
17:31:09 <Igloo> If you're problem is ghc on FBSD 5 I think Simon Marlow might have committed something to fix it to CVS recently
17:31:23 <Igloo> (which might be in 6.2.2)
17:31:59 <jao> Igloo, thank you. Yes, I was wondering what was the status of that port.
17:32:25 <jao> As of today, it is still marked as 'broken', though.
17:35:20 <NKwish> Hey guys. I dont mean to spam, but my website is up and running. My forums are up. Anyone interested in posting there views on the truth that is covered up by our goverment, please register and post. Im trying to build a community of truth seekers. www.behindthetruth.com is the website.
17:36:08 --- mode: ChanServ set +o shapr
17:36:12 <Igloo> You clearly do mean to spam. Please go away.
17:36:14 <Lemmih> And why do you think that's related to #haskell?
17:36:20 --- kick: NKwish was kicked by shapr (Kicked by shapr)
17:37:23 <shapr> anyway...
17:37:25 <shapr> back to HEmacs
17:37:31 --- mode: shapr set -o shapr
17:40:30 <jao> shapr, is HEmacs the joy-extensible emacs-replacement you were talking about the other day? did you find four hackers?
17:41:19 <shapr> HEmacs is a Haskell-extensible emacs-replacement.
17:41:45 <jao> oh, cool.
17:42:14 <shapr> Part of the reason I wanted to use Joy is that Haskell isn't really dynamic enough... but I think it is now.
17:42:36 <jao> what changed? (besides your mind)
17:44:28 <shapr> hs-plugins is cooler.
17:44:34 <shapr> hi vratnik 
17:44:40 <shapr> looking for Haskell info?
17:45:08 <shapr> jao: hs-plugins can now load an entire app dynamically on a tiny static core.
17:45:22 <vratnik> i have problem in linux
17:45:34 <shapr> you have a Haskell problem in Linux?
17:45:45 <vratnik> haskell doesnt work in kdevelop
17:46:21 <shapr> Did it work before?
17:46:51 <vratnik> no, never. im new to linux
17:47:18 <shapr> I haven't used kdevelop before, does it usually have Haskell support?
17:47:52 <vratnik> it was slack 10 (full install, 2CD). but many other things didnt work in slack, too. then i wanted to netinstall debian, but it returned error about not being able 2 download bla bla bla
17:48:23 <shapr> I know that emacs, vim, eclipse, and some other editors have Haskell support.
17:48:58 <jao> shapr, sounds interesting. i hope i'll be soon able to check hemacs (i guess it needs ghc to build)
17:49:28 <shapr> It does need ghc. I've heard GHC works on freebsd5 with the compat4 packages installed.
17:49:49 <shapr> I think dons develops hs-plugins in BSD, not sure which flavor.
17:50:15 <Igloo> Open, I assume
17:50:19 <vratnik> i didnt try. also 3d graphics didnt work in slack, hibernation, system sounds, mouse wheel and many other basic things. so i reformatted the partition and decided for debian
17:50:54 <jao> shapr, it seems that the ghc port is broken right now... ah, do you mean using the linux emulation?
17:51:00 <vratnik> i also wanted to try gentoo, but i couldnt even manage to start the install
17:51:14 <jao> shapr, no, you don't, sorry
17:51:43 <shapr> vratnik: I've had good experiences with Debian.
17:51:51 <dons> shapr: hs-plugins gets developed on openbsd, of course. but tested on debian and macosx
17:52:26 <dons> in fact, tested nightly on debian (that's where the snapshots are done)
17:52:28 <shapr> vratnik: but I have heard that Mandrake is easiest to install for new Linux users.
17:52:47 <vratnik> i want linux with working acpi, k3b, xboard (doesnt work in fully installed slackware even when been selected during the install), 
17:53:05 <vratnik> mandrake doesnt have linuxconf
17:53:28 <vratnik> and i heard that mandrake is unstable
17:53:44 <shapr> My fiancee uses Mandrake for all of her work.
17:53:55 <shapr> She has it on her home and work boxes.
17:54:18 <vratnik> i bet that it doesnt support hibernation 
17:54:30 <shapr> The only trouble she's had is with the Via on-board APIC
17:54:43 <shapr> Are you installing onto a laptop?
17:54:49 <vratnik> yes
17:55:03 <shapr> Does linux support all those features in your laptop?
17:55:40 <vratnik> u mean does my laptop support these things? yes
17:55:56 <shapr> Actually, I mean, does Linux support your laptop.
17:56:33 <shapr> When a company builds a new laptop, they write their own Windows drivers, but Linux drivers are usually written by a user.
17:56:58 <vratnik> yes i got toshiba and i found in something called "kernel configuration" that there were things like toshiba laptop support
17:57:10 <shapr> So, it's best to see if Linux supports all of those features in your particular combination of manufacturer, chipset, model, etc.
17:57:45 <vratnik> well system sounds didnt play but xmms worked
17:57:53 <shapr> I have a toshiba laptop.... mine is forty megahertz.
17:58:32 <vratnik> or i had 61hz refresh and i didnt know how to change it. xvidtune didnt work.
17:58:41 <shapr> actually, mine may be even slower than forty... 
17:59:09 <shapr> oh, mine is twelve megahertz: http://www.silicium.org/ibm/toshiba/t1600.htm
17:59:35 <vratnik> well cool. its 386 or what?
17:59:43 <shapr> no, it's a 286
18:00:14 <shapr> Anyway, there have been several models of toshiba laptops, so you may want to see if your particular model is fully supported by Linux.
18:01:27 <shapr> If you have an LCD screen, (do laptops have anything else?) you don't want to change the refresh rate...
18:01:45 <shapr> You may want to change the resolution, but not the refresh rate.
18:07:17 <shapr> hiya pesco 
18:07:24 <pesco> Hey, shapr.
18:07:36 <shapr> what's up?
18:07:55 <pesco> Having fun reading flame-wars.
18:08:16 <pesco> Actually, I'm on my way to bed, just wanted to see if stepcut was here.
18:09:08 <pesco> Grmbl.
18:09:21 <pesco> ;)
18:09:49 <shapr> haha
18:09:55 <shapr> have you seen HEmacs?
18:10:06 <pesco> No!
18:10:13 <pesco> Where is it?
18:10:33 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/hemacs
18:11:10 <shapr> stone soup :-)
18:11:19 <pesco> Stone soup?!
18:11:50 <shapr> um, it's a fable/parable called stone soup.
18:12:17 <dons> anyone got any suggestions on what format the hemacs docs should be in?
18:12:26 <shapr> http://spanky.triumf.ca/www/fractint/stone_soup.html
18:12:41 <dons> i've tentatively started with .tex, but can be persuaded otherwise
18:13:09 <dons> hmm. maybe there should be something like the vim :help docs
18:13:26 <dons> (or should this go to post-emacs, I wonder?)
18:14:13 <shapr> pesco: mailing list is http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
18:14:21 <shapr> also available on gmane.org
18:14:32 <pesco> Coo.
18:14:51 <shapr> I've been googling around looking for a good way to do a buffer. Zipper looks most featureful at the moment. Do you know of anything else?
18:16:15 <Igloo> I don't suppose anyone knows why "valgrind --tool=massif /bin/ls" works but "valgrind --tool=massif /usr/bin/ghc" doesn't? (I only get half the valgrind output and it doesn't make the graph)
18:16:55 <shapr> maybe ghc and valgrind interact in strange ways?
18:17:06 <shapr> valgrind was inspired by Julian Seward's work on GHC.
18:17:23 <jao> shapr, i guess you already know that post-emacs archives are not available... or at least, i cannot access them...
18:17:37 <shapr> jao: yes, they will be available at the end of the first month :-)
18:17:51 <shapr> actually, I'll try it now...
18:17:53 <jao>  :)
18:18:36 <pesco> I guess I'm off for some sleep. See you all soon.
18:19:00 <Igloo> I'd have thought valgrind should be completely transparent to the app it runs
18:19:21 * shapr is just guessing
18:19:43 <Cale> There ought to be unionSet :: Set (Set a) -> Set a in Data.Set
18:19:50 <dons> how can I do: darcs record --all, except mk/config.mk. any ideas?
18:20:19 <dons> without having to give an explicit command line list of records
18:20:37 <Igloo> You could record mk/config.mk first, then --all, then unrecord the first one
18:21:06 <dons> that is quite nice. thanks
18:21:26 * dons doesn't want linux user's to get grumpy about openbsd config.mk :P
18:22:32 <Igloo> Get Sven to use it and you might find a configure script appears  :-)
18:23:01 <dons> maybe I should write a configure script. /me puts it on the todo list
18:23:20 <dons> though sven would be even better :)
18:23:53 <dons> another thing is the design of the testsuite
18:24:17 <dons> maybe I could use ghci to get test internal functions, without the ui in the way
18:24:29 <dons> s/get/get at and/
18:24:53 <jao> shapr, i'm not able to subscribe to post-emacs. the mail server complains with 'Recipient address rejected: User unknown in local recipient table'
18:25:04 <dons> maybe darcs has the answer re. testing
18:25:12 <jao> (to my confirm message)
18:25:39 <shapr> jao: I think I know what's causing that problem, but I'm not sure how to fix it...
18:26:18 <shapr> postfix rewrites any user at lists.scannedinavian.org to mailman, but scannedinavian.org is the MX for *.scannedinavian.org
18:26:49 <jao> hm
18:26:57 <shapr> it seems that a few mail servers rewrite the virtual host to the canonical host
18:27:46 * shapr asks on #mailman
18:30:51 <shapr> oh, I bet I can fix this in postfix...
18:41:07 <shapr> hiya ez4 
18:41:31 <ez4> hi
18:41:46 <shapr> how's code?
18:43:16 <ez4> pretty good
19:19:38 <ows> by
19:33:58 <Igloo> GHC 6.2.2 should be in haskell-unsafe now
19:34:52 <shapr> will be removed: wxhaskell hat-ghc6 hsshellscript
19:35:12 <shapr> does 6.2.2 have HSX11 and HGL ?
19:35:38 <Igloo> Ah, yes, everything else will have to be rebuilt too
19:35:46 <shapr> Igloo: thanks for the quick package :-)
19:36:16 <Igloo> No HSX11 or HGL
19:36:29 <shapr> I wasn't able to find a list of changes from 6.2.1 to 6.2.2, is it in the GHC docs and I'm just missing it?
19:36:35 <shapr> or have the ghc online docs not been updated yet?
19:37:02 <dons> hmm. do we have such a list?
19:37:19 * dons goes src-trawling
19:37:28 <Igloo> It's mainly bug fixes
19:37:36 <shapr> there's this -- http://www.haskell.org/ghc/docs/latest/html/users_guide/release-6-2.html#AEN430
19:37:40 <Igloo> http://www.haskell.org/ghc/docs/6.2.2/html/users_guide/release-6-2.html only has 1 line about 6.2.1
19:37:40 <shapr> shows what 6.2.1 adds
19:38:08 <shapr> I'd still like to know what's changed.
19:38:29 <shapr> maybe it's in cvs...
19:38:32 <dons> doesn't look like 6.2.2 added anything to user_guide, from what I can see in cvs
19:38:35 * shapr cvs up
19:38:52 <dons> hmm. better openbsd support is one thing!
19:38:55 <Igloo> diff -ur will show you what's changed  :-)
19:39:09 <shapr> scary thought
19:39:12 <shapr> dons: cool!
19:39:15 <dons> and you can dynamically load external-to-the-compiler dynamic loaders
19:39:28 <dons> i.e. hs-plugins can by dynamically loaded
19:39:32 <dons> (in ghci, for example)
19:39:40 <shapr> I probably don't want to know how you did that.
19:39:58 <shapr> I read up on ClassLoaders in Java once, it was complicated.
19:40:34 <dons> practical application: hemacs is all dynamically loaded. so if it wants to reload() at runtime, then it needs hs-plugins, which must therefore be also dyn loaded
19:40:56 <dons> not just statically linked/loaded in Boot.hs
19:41:39 * shapr gives dons the curried chicken and egg award for the week
19:42:26 * dons is a vegan. but will happily accept the curried curry
19:42:30 <shapr> it sounds like you only want GHC for its runtime.
19:42:41 <dons> no no. what about make()?
19:42:51 <dons> i want the compiler too, but at runtime
19:43:01 <shapr> dons: hey, are there any pix of you online?
19:43:09 <shapr> I just saw blackdog's new haircut....
19:43:20 <dons> short is it?
19:43:31 <dons> ozone has some pics from icfp on his blog
19:43:33 <shapr> bit shorter than before
19:49:40 <Igloo> Anyone got any idea where the 5 argument munmap ltrace sees comes from?
19:49:59 <heatsink> dons: use lisp
19:50:13 <heatsink> <dons> i want the compiler too, but at runtime
19:50:22 <shapr> bah, lisp is for weenies.
19:50:35 <shapr> I like the strong static type.
19:50:41 <heatsink> I do too
19:50:50 <heatsink> but haskell doesn't give you the compiler at runtime
19:50:56 <shapr> Yes it does =)
19:50:59 <dons> yes it does!
19:51:10 <heatsink> hmm?
19:51:13 <shapr> dons gave Haskell the compiler at runtime.
19:51:31 <dons> Plugins.Make.make
19:51:44 <shapr> Before he did it right with hs-plugins, the only way was to run your application in the compile cycle of Template Haskell.
19:51:59 <shapr> I don't think anyone actually tried that
19:52:16 <shapr> but I think Ulf Norell's IOHCC submission might make that possible.
19:52:41 <dons> shapr: found it. http://www.algorithm.com.au/gallery/snowbird2004/IMG_2529
19:53:00 <dons> i'm not arthur or andre
19:53:16 <dons> oops. wrong one. i'm the one at the back in the beanie
19:53:23 <shapr> nice hat
19:53:41 <shapr> Tom who?
19:53:47 <Igloo> It was living up to its name by the looks of it, then  :-)
19:53:47 <dons> it was 20degrees F, at 11,000 feet
19:54:03 <shapr> Arthur van Leeuwen?
19:54:13 <dons> Baars
19:54:38 <shapr> ah
19:54:47 <shapr> Tom Pledger?
19:55:09 <dons> Tom Moerton (is that how you spell it?)
19:55:35 <shapr> Moertel?
19:55:51 <shapr> Cool, he showed up :-)
19:56:31 <heatsink> So you get first-class modules, that makes sense
19:56:40 <dons> yep Moertel, that sounds right
19:58:17 * Igloo goes to bed while I can still pretend it's yesterday
19:58:26 <shapr> I wish I'd been able to go to the business Haskell bit :-(
19:58:31 <shapr> Is there a summary up?
19:58:39 <shapr> me self-employed, want Haskell...
19:59:11 <dons> don't know. it was the day before icfp started
20:03:53 <shapr> dons: you have the look of a very intense person.
20:04:01 <shapr> or maybe just a very cold person ;-)
20:04:24 <dons> it was cold that day :}
20:05:13 <shapr> Not so much snow in your part of .au?
20:05:53 <dons> heatwaves, yes. snow, no.
20:06:12 <dons> it was fun
20:06:54 <dons> but the altitude was a bit of a problem. snowbird, let alone the mountains, were higher than anywhere in .au
20:07:51 <shapr> in case of global warming, I now know where to migrate.
20:15:58 <shapr> hm, Sulzmann's chameleon does some type-error slicing.
20:28:01 * shapr reads about ropes
20:29:27 <shapr> speaking of self-balancing datastructures, maybe ShowS-style arrows could automatically decide whether it's cheaper to keep darcs-style changes to the string, or 'commit' all the changes and go back to a 'static' string.
20:40:59 <blackdog>  http://www.algorithm.com.au/gallery/snowbird2004/IMG_2529
20:41:13 <blackdog> argh. sorry. using windows, none of the keys work right.
20:41:23 <shapr> g'day blackdog 
20:41:36 <shapr> Oy, it's nearly 6am, no wonder all the aussies are awake.
20:41:42 <blackdog> hej shae. 
20:42:07 <blackdog> it _is_ approaching 2pm here... we're not that lazy.
20:43:06 <shapr> I still don't have a good idea of the tradeoffs between zipper and ropes.
20:43:32 <shapr> My vague impression is that zipper is good for syntax editors, and ropes are good for efficient strings.
20:49:13 <dons> ooh. there's nothing better than finding a hidden packet of oreos :)
20:49:23 * shapr suddenly understands The Zipper
20:50:05 <blackdog> can you help me? It's still lookin about as impenetrable as a nun's knickers to me...
20:51:13 <shapr> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/komp/2002/lectures/zipper.html
20:52:07 <blackdog> cheers
20:52:10 <shapr> it's like a rubik's cube sort of tree, you can rotate the same tree into different shapes so that one node is exposed
20:52:20 <shapr> and then that node is really easy to manipulate
20:52:32 <shapr> that's pretty much it
20:53:18 <shapr> don't know the complexity of zipper modifications though
20:54:45 <blackdog> it looks interesting... would you represent a buffer as a zipper of chars, or try for a higher-level rep?
20:56:24 <shapr> I think I'd represent the buffer text with ropes, and the buffer parse with a zipper
20:57:02 <shapr> oh, I found the ropes paper, you want the url?
20:57:41 <blackdog> no, it's ok - i'm about to log off and do some thesis work.
20:57:43 <shapr> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
20:57:44 <shapr> ah, ok
20:59:10 <heatsink> How would you represent a syntactically incorrect expression with a zipper?
20:59:33 <shapr> I'd do it the good old fashioned Haskell way...
20:59:47 <shapr> lazily evaluate a correct expression.
21:00:05 <shapr> pass the buck... put it off :-)
21:00:57 <heatsink> Hmm... I thought you were talking about a text editor
21:01:02 <shapr> I am
21:01:44 <shapr> I'd leave the syntactically correct parts
21:01:57 <shapr> invalidate the syntactically unparseable parts
21:02:08 <shapr> and just hang around and wait for those parts to become legal again
21:02:20 <shapr> for syntax highlighting for example
21:03:05 <shapr> text is changed, ropes are updated, zipper nodes disappear
21:03:07 <heatsink> How do you decide which parts are syntactically unparseable?
21:04:14 <shapr> assuming there has been a legal parse, invalidate the smallest number of nodes that account for the changed text?
21:04:28 <shapr> try to incrementally reparse?
21:05:40 <heatsink> Those might work.
21:06:14 <heatsink> I'm thinking about how, in Emacs, I can change the parse of an entire file by typing {-
21:06:57 <shapr> and with semantic bovinator, it invalidates only that 'chunk'
21:08:08 <shapr> if "bar [foo baz] quux" is legal, and you put {- into the list, I'd say only invalidate the text inside the list, and wait for ten seconds or so
21:11:14 <heatsink> Okay, so it's incremental reparsing.
21:12:32 <heatsink> And strictly left to right.
21:12:58 <shapr> why strictly left to right?
21:13:18 <heatsink> What if instead of {-, I inserted ( in the list?
21:13:48 <shapr> you can still try to reparse the contents of the list as valid 'list contents' every once in awhile.
21:14:05 <shapr> ?
21:14:15 <heatsink> Sure
21:14:36 <heatsink> But will the rest of the program be inside that misplaced parenthesis?
21:15:07 <shapr> huh?
21:15:46 <heatsink> it looks something like [bar ( foo] qux
21:15:54 <shapr> yah?
21:16:21 <shapr> I don't understand your question.
21:16:22 <heatsink> so when the parser gets to ] it decides: bad syntax, ignore this node
21:16:34 <heatsink> and so on down the rest of the file
21:16:40 <shapr> the parser never gets to ]
21:16:57 <shapr> it's only trying to reparse the invalid text
21:17:15 <shapr> at least, until you reach the 'reparse from the top' timeout
21:17:32 <heatsink> which text is invalid, though?
21:17:40 <shapr> only the text inside the list
21:18:02 <heatsink> okay
21:18:12 <heatsink> now i add a closing parenthesis after qux
21:18:24 <heatsink> then I delete the opening brace before bar
21:18:34 <shapr> in which case, the list token is inside the invalid text
21:18:37 <shapr> so the list goes too
21:18:57 <shapr> then you jump up to the next node that fully contains the invalid text
21:20:08 <shapr> does that sound workable?
21:20:17 <heatsink> So, when does the ( become valid?
21:20:58 <shapr> well, never if it's "[bar ( foo] qux )"
21:21:56 <heatsink> what are the conditions for an invalid token to become valid?
21:23:04 <shapr> if the incremental parser can pick up more legal parse nodes, it does so
21:24:04 <shapr> if you legally parse all of the changed text, and it fits into the parse tree correctly, everybody is happy
21:24:19 <heatsink> yup
21:24:41 <shapr> if all the text doesn't fit into the parse tree, put in a big red X, or an MS paperclip symbol denoting broken-ness.
21:26:09 <heatsink> Is typed text invalid by default, until the incremental parser validates it?
21:26:19 <shapr> yes
21:26:30 <ikegami--> haj
21:26:39 <shapr> konichiwa ikegami--san
21:27:03 <ikegami--> today is the last day of this visit, shapr :)
21:27:05 <heatsink> This sounds plausible... I'm not convinced.
21:27:26 <shapr> ikegami--: have you enjoyed Sweden?
21:27:49 <ikegami--> shapr: exactly yes ;)
21:27:54 <shapr> heatsink: well, get on the mailing list and argue!
21:28:10 <shapr> or code up a counter-example
21:28:50 <shapr> I've only been seriously thinking about incremental parsing for a week or two, I could easily be way way off.
21:29:14 <shapr> ikegami--: Have you seen snow there in the south?
21:30:08 <ikegami--> i'm sorry, never
21:30:16 <heatsink> It's interesting that I can delete a character and retype it, and in so doing, get a different parse tree
21:30:47 <shapr> you should end up with the same parse tree
21:31:08 <heatsink> What if I have [bar (foo] qux)
21:31:13 <heatsink> and I delete the [
21:31:26 <heatsink> I will have bar (foo[ qux)
21:31:34 <shapr> and the bar will be legal
21:31:34 <heatsink> I will have bar (foo] qux)
21:31:54 <heatsink> okay
21:32:15 <heatsink> and if I instead change it to [bar (foo qux)
21:32:16 <heatsink> ?
21:32:28 <shapr> change it back?
21:32:37 <heatsink> I deleted the ]
21:32:57 <heatsink> will the (foo qux) be parsed as matched parentheses?
21:33:01 <shapr> from this? "[bar (foo] qux)" ?
21:33:05 <heatsink> right
21:33:20 <shapr> to this? "[bar (foo qux)"
21:33:24 <heatsink> yes
21:34:03 <shapr> I don't see how you could 'subparse' into the free text
21:34:21 <shapr> I think you can only incrementally extend the parse tree by growing it onto the text
21:34:45 <heatsink> What do you mean by subparse?
21:35:00 <shapr> if the "[bar" doesn't parse, you don't know where you are
21:35:12 <shapr> so you can't just skip the invalid text and start parsing the parens
21:35:34 <heatsink> why wouldn't '[bar' parse?
21:35:46 <shapr> because there's not another ] at the end
21:36:28 <shapr> make sense?
21:36:31 <heatsink> How would the parser know that when it's at '[bar'?
21:37:01 <shapr> because, the containing node is legal
21:37:12 <shapr> so you start at the beginning of the invalid, unparsed text
21:37:51 <heatsink> We have been talking about the example "[bar (foo] qux)" -> "[bar (foo qux)"
21:38:19 <heatsink> Would the parser be operating differently if we had instead "[bar (foo] qux)]" -> "[bar (foo qux)]"?
21:38:32 <heatsink> Assuming the first [ and the first ] were the valid characters
21:38:53 <shapr> what's the last completely valid parse?
21:39:15 <heatsink> The last completely valid parse is [bar foo] in both cases
21:39:21 <heatsink> or...
21:39:25 <heatsink> [bar foo] qux
21:39:50 <shapr> then what happens? you put a paren inside the list?
21:40:37 <heatsink> If it makes a difference what order the three invalid tokens are added, I don't see how.
21:42:01 <heatsink> Let's say they're typed in left to right order.
21:42:03 <shapr> [bar foo] qux -> (List (Id "bar") (Id "foo")) (Id "qux")
21:42:13 <shapr> you put a paren into the list
21:42:13 <heatsink> okay
21:42:30 <shapr> (List _|_) (Id "foo")
21:43:02 <heatsink> how did foo get out there?
21:43:23 <shapr> or maybe (List (Id "bar") (Invalid "(") (Id "foo")) (Id "qux")
21:43:45 <shapr> but that wouldn't work
21:43:53 <heatsink> why not?
21:44:18 <shapr> because you need to invalidate the textual contents of the token that entirely contains the changed text
21:45:56 <heatsink> everything in the list would be invalidated?
21:46:06 <shapr> all the text inside the [ ] would be invalid
21:46:22 <shapr> you could reparse the first id
21:46:51 <shapr> heatsink: you should write QuickCheck tests 
21:47:43 <heatsink> why?
21:48:16 <shapr> because then we'll quickly find out whether it works or not
21:49:21 <heatsink> Well, I believe it works, in the sense that if there is a valid parsing of the program, your incremental parser will find it.
21:49:33 <heatsink> s/program/text/
21:49:55 <shapr> I hope it works
21:50:05 <shapr> otherwise I have to think up something else entirely
21:50:13 <shapr> or like... actually read some papers on incremental parsing
21:50:18 <heatsink> The issue is whether it behaves reasonably when there is no valid parse. Of course, "reasonably" is hard to define.
21:50:24 <heatsink> Is this a part of hemacs?
21:50:33 <shapr> not yet
21:50:49 <shapr> I've been hammering away at the idea to see if it works or not.
21:50:55 <shapr> this discussion has helped :-)
21:51:15 <heatsink> well, thank you :)
21:51:53 <shapr> thank you
21:52:02 <heatsink> here's my concern with what you last described:
21:53:42 <heatsink> I have a list with some complicated expressions in it... [try do {char '$'; a <- macro; return $ Just a}) <|> return Nothing, something else complicated, ....]
21:53:57 <heatsink> I decide I want to add a new list item
21:54:07 <heatsink> I type a comma after Nothing
21:54:21 <heatsink> The incremental parser notices that I have two commas in a row, which is invalid
21:54:30 <heatsink> It invalidates everything inside the list
21:54:38 <heatsink> All my syntax highlighting disappears
21:55:00 <heatsink> I look like the person in the last panel of this: http://www.alessonislearned.com/lesson003.html
21:56:21 <shapr> hm
21:56:52 <shapr> in that case, highlighting should stay on text, even when it's invalid, until it gets reparsed?
21:57:04 <heatsink> That would be good
21:57:24 <heatsink> And also, something to avoid trying to reparse after every character typed
21:57:48 <shapr> right, reparse should take a second or two
21:57:56 <shapr> that is, an incremental reparse attempt
21:58:09 <heatsink> you mean, it will wait a second or two?
21:58:46 <shapr> yes, what if you're still typing a bunch of text?
21:59:00 <heatsink> that's a good idea
22:03:13 <heatsink> How do you show the user what causes the parser to give up?
22:03:53 <shapr> scriggly red lines is the MS Office way
22:04:12 <heatsink> okay
22:04:35 <heatsink> I would still like something to tell me when my code is not being reparsed because of something far away in the file
22:04:51 <heatsink> For example, I mistakenly typed a " on line 34
22:04:53 <shapr> here, subscribe to the list, share your ideas - http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
22:05:07 <shapr> semantic bovinator has that feature
22:05:13 <shapr> 'bad parse buckets' or something like that
22:05:25 <heatsink> The archives link doesn't work...
22:05:38 <shapr> yes it won't until either the first month is over
22:05:42 <heatsink> okay
22:05:44 <shapr> or until I figure out how to force it
22:05:59 <shapr> you can check gmane.org.comp.editors.post-emacs
22:06:37 <heatsink> um... newsgroup?
22:06:53 <shapr> gmane.org is sort of a newsgroup server
22:07:04 * heatsink never did figure out how to use newsgroups
22:07:49 <shapr> http://news.gmane.org/gmane.editors.post-emacs/cutoff=11
22:08:26 <heatsink> thx
22:08:59 <shapr> anyway, sleep time for me
22:09:10 <shapr> actually, it's time to wake up... but...
22:09:17 <ikegami--> shapr: good night 
22:09:18 <ikegami--> hehe
22:09:31 <shapr> good night ikegami-- 
22:09:34 <heatsink> okay. Was fun, I wanna see your incremental parser results :)
22:09:37 <heatsink> someday
22:09:44 <heatsink> goodnight
22:09:45 <shapr> show up and help write the code :-)
22:09:50 * shapr falls over asleep
