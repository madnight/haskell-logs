00:48:24 <musasabi> morning
01:13:52 <bourbaki> moin
01:35:33 <tromp>  'gmorning
02:23:33 <bourbaki> tic: are you learning haskell now ?:)
02:23:54 <bourbaki> anyone in here familiar with decision trees and arrows?
02:24:36 <tic> bourbaki, hehe. :) 
02:25:03 <bourbaki> tic: or have you been in here all the time?
02:25:08 <tic> bourbaki, all the time.
02:25:14 <bourbaki> heh
02:25:16 <tic> bourbaki, since the last two years or so.
02:25:34 <bourbaki> did you write any ai stuff in haskell?
02:30:55 <tic> bourbaki, nope
02:30:58 <tic> bourbaki, just Python. :)
02:31:14 <tic> slow, but I've got access to a 2.8 GHz Xeon, so.... :)
02:31:23 <bourbaki> hehehe
02:56:39 <bourbaki> esap: are you reading?
03:00:21 <bourbaki> moin kristnjov 
03:04:58 <Oejet> Good day to you all, sleepy persons.
03:05:11 <bourbaki> heh hell-0 single one ;)
03:40:10 <Oejet> I'm trying to understand the data type strictness flag (f.ex.  data Game = Game !Int64 !Int64 Player).
03:40:28 <Oejet> When added my code gets slower than without.
03:41:06 <Oejet> The documentation on the behavoir is hard to find.  Any suggestions of where to look?
03:42:01 <tromp> it gets slower because it evaluates unneccessary arguments
03:44:10 <Oejet> Hm.  I have a Tree Game type, in which every node is evaluated.  Is it because they are evaluated more than once for some nodes?
03:44:29 <tromp> no, that won't happen
03:44:57 <tromp> but apparently you create some Game values for which you don't need to evaluate both fields
03:45:29 <tromp> actually it's a bit suspicious
03:45:50 <tromp> since Int64 operations are near instantaneous
03:46:12 <tromp> doing them even if not necessary shldn't slow u down
03:46:21 <Oejet> Hm.  I have a function static: Game -> Int which is mapped over the tree. It uses both Int64 in every Game value.
03:46:48 <Oejet> I was thinking that Int64 are boxed and !Int64 are not.
03:47:09 <Lor> That is a possible optimization that strictness allows, yes.
03:47:20 <tromp> did you compile with -O ?
03:47:27 <Oejet> -O2
03:47:46 <Oejet> Uh, and -prof --auto-all
03:48:27 <tromp> maybe you can post your code somewhere and let the experts check it out
03:49:02 <Oejet> That would be nice.   Maybe one with and one without "!" ?
03:49:28 <tromp> ppl can easily edit it themselves:)
03:49:35 <Oejet> OK
03:49:48 <tromp> so just the version with
03:51:17 <tromp> best to cut it down to the minimal code that exhibits the slowdown
03:51:51 <Oejet> Yes, just thoght about that.
03:52:54 <tromp> is the slowdown a factor of 2 or more?
03:53:16 <Oejet> Don't remember. Give me 5 min.
04:00:51 <Oejet> With "!": total time  =        1,74 secs   (87 ticks @ 20 ms)
04:00:51 <Oejet> Without: total time  =        1,86 secs   (93 ticks @ 20 ms)
04:01:00 * Oejet is blushing.
04:01:19 <Oejet> But, but, the last time it...
04:03:28 <Oejet> http://eigil.dyndns.dk/ai2.hs
04:04:24 <Oejet> I could still need some explanation of what "!" really does.
04:05:55 <tromp> it means that whenever a Game constructor is applied, its (!) argument is first evaluated
04:06:25 <Oejet> By the way the game is this Knoughts and Crosses.
04:06:30 <tromp> whereas in the non-strict case, it will remain as an unevaluated "thunk"
04:07:32 <tromp> is the Int64 a bitmap representation of the board?
04:07:35 <Oejet> Will that mean that the whole tree is evaluated a once because every node has a strict field?
04:07:52 <Oejet> tromp: Yes, actually half the board.
04:08:47 <tromp> i'll need some time to grok your code:)
04:09:52 <tromp> ah, you call the 2 players True and False, rather than Black and White:)
04:10:00 <Oejet> Yep.
04:10:22 <tromp> that saves you from having to remember whether True is white or black:)
04:10:50 <Oejet> Got that from the OCaml book.
04:11:36 <Oejet> The tree code is from "Why Functional Programming Matters", Hughes.
04:11:59 <tromp> hmm, i think i read that once
04:12:14 <Lor> Uh, what's wrong with "data Player = Black | White"?
04:12:49 <tromp> it's just extra code, no extra functionality
04:13:11 <Lor> Um.
04:13:19 <Oejet> Lor: Nothing.  Maybe X | O, or Red | Blue.
04:13:24 <tromp> there is already a Bool = False | True
04:13:27 <Lor> Perhaps you also find enums quite useless in C, since you could as well use plain integers?
04:13:32 <tromp> that suits the purpose perfectly
04:13:53 <phubuh> what is False or True about a game player?  it's nonsensical
04:14:19 <tromp> no, i think calling Players True and False is just as conceptually clear as calling them Black and White:)
04:14:26 <Oejet> It will end up being a library, so I think it will end up as data Player = Min | Max.
04:15:04 <tromp> the downside is that it's not extensible:(
04:16:15 <Oejet> tromp: In what way?
04:17:02 <tromp> you might want to map a board location to its occupying player
04:17:21 <tromp> now you'd have to use somthing like Maybe Bool
04:17:37 <tromp> but otherwise you cld extend Player = White | Black | Empty
04:17:45 <Oejet> tromp: Huh?
04:18:07 <Oejet> Ah, I see.
04:18:21 <Lor> tromp, a player is a different thing from the state of a board location.
04:18:25 <Lor> Nothing wrong with that.
04:20:10 <tromp> i agree that Black|White is better for games where that distinction is traditional, like chess
04:20:31 <tromp> but for instance Connect4 players are not called black and white
04:21:06 <Lor> Well duh. You have to call them _something_.
04:21:46 <tromp> i also have to admit that using Bool might cause you to miss a bug that wld otherwise be caught by type checker
04:22:54 <tromp> let's say i just thought it was a neat idea for trying to write a very concise program:)
04:24:33 <Lor> Nah. You follow that idea through, and you'll never define new datatypes, but just construct all types out of (), Void, (,), Either and Mu.
04:24:56 <Lor> Like, why have a separate Bool type when Either () () will do just as well?
04:25:09 <Lor> (Yes, except for the extra bottoms)
04:25:50 <tromp> Bool is more descriptive
04:25:59 <Lor> Bingo!
04:29:13 <tromp> where is gameTree used, oejet?
04:29:54 <Oejet> eval g =( minmax (player g) . mapTree static . gameTree) g
04:30:05 <tromp> ah yes
04:30:54 <Boegel> hello everyone
04:31:29 <Boegel> bourbaki, did you see the image TheHunter converted for you ?
04:31:44 <bourbaki> Boegel: no where is it?
04:31:45 <Oejet> I said to a friend that I could write a good connect four brain in less than 100 lines.  A bit optimistic maybe.
04:32:14 <tromp> i wrote a good one, but it's way over 100
04:32:15 <Lor> What's connect four?
04:32:38 <tromp> google knows:)
04:32:46 <tromp> a simple alignment game
04:32:48 <Boegel> bourbaki: http://studwww.ugent.be/~kehoste/thesis/Haskell/test.png
04:33:10 <Boegel> but I see the image is quite small... I'll generate a bigger one for you, wait :)
04:33:24 <bourbaki> Boegel: np :)
04:33:34 <Oejet> tromp: What was your representation of the game state?
04:33:39 <bourbaki> Boegel: you havent inclueded normals of your objects yet right?
04:33:40 <Boegel> btw, I'm getting my pc ready for installing Fedora Core 3 Test 2
04:33:44 <tromp> bitboard
04:33:50 <Lor> Ah, that one. Right.
04:33:52 <tromp> but a very particular one
04:33:52 <bourbaki> for lighting that is
04:34:00 <Boegel> bourbaki: internally, I have, but I'm not using lights yet
04:34:26 <Boegel> bourbaki: it's just the basic algorithm, ray casting (just giving the objects a color and checking for intersection)
04:34:35 <tromp> that allows quick testing of 4 in a row
04:34:36 <bourbaki> Boegel: do you have support for parameterized surfaces?
04:34:47 <bourbaki> Boegel: ah ok i see
04:34:56 <Boegel> bourbaki: not yet, but who knows what I will support :p
04:35:17 <Boegel> bourbaki: the ray tracer is the subject of my thesis I have to write
04:35:35 <tromp> oejet, i think the operations you do on Int64 can be quite complex
04:36:18 <tromp> you .|. a bitmap with a move that results from a nontrivial computation
04:36:42 <bourbaki> Boegel: where to you write your thesis at ? and whats the central point?
04:36:59 <tromp> in function play
04:37:03 <Boegel> bourbaki: my thesis is at the University of Ghent
04:37:14 <Boegel> bourbaki: what do you mean by 'central point' ?
04:37:16 <tromp> so maybe sometimes the result of this .|. is not needed?!
04:37:44 <Boegel> bourbaki: I have to write a ray tracer in Haskell, and develop the functions in FunMath first, concentrating on the functional aspect
04:37:46 <bourbaki> Boegel: is it yet another raytracer or is there something special
04:38:08 <Boegel> bourbaki: and then I have to prove some stuff about it
04:38:10 <Oejet> tromp: I don't follow.  But I think you have something particular in mind. ;-)
04:38:22 <Boegel> bourbaki: I don't know what yet though
04:38:43 <Boegel> bourbaki: I have to go, sorry
04:38:44 <bourbaki> Boegel: itd be cool if you would include the standard lighting methods and sufrace shadeing as functions
04:38:48 <Boegel> I'll talk to you later !
04:38:49 <bourbaki> ok bye bye
04:38:52 <Boegel> sorry !
04:38:52 <bourbaki> sure
04:38:52 <Boegel> bye
04:38:55 <bourbaki> np
04:40:31 <tromp> oejet, when haskell computes your play function, it evaluates the move
04:41:25 <Oejet> tromp: Yes?
04:41:47 <tromp> maybe that's sometimes not needed
04:43:00 <tromp> although it's hard to see how that cld happen
04:43:18 <Oejet> Mmm, are you thinking about alpha beta pruning?
04:43:31 <tromp> not yet:)
04:44:09 <Oejet> Ok, I did implement that in my c4 program.
04:44:53 <tromp> intuitively, whenever you make a move, you expect to be testing for a win shortly after
04:45:26 <tromp> so that suggests the result of .|. m  is always needed
04:45:54 <Oejet> tromp:  I could test for a win before moving.
04:46:53 <tromp> but we want to understand why you get a slowdown
04:47:29 * Oejet is thinking so his brain (the real one) is almost exploding.
04:47:39 <tromp> what happens if you take out the ! but define play to be strict?
04:48:50 <tromp> maybe you shld just qualify the few % difference in speed as random noise
04:49:38 <Oejet> Are you talking about the execution time with and without strictness flags?
04:50:48 <tromp> yes
04:51:19 <tromp> it's not that significant, is it?
04:51:29 <Oejet> tromp: Oh, I was thinking more in the lines of some algorithmic optimisation.
04:52:25 <Oejet> tromp: It's irrellevant.
04:53:01 * shapr blinks sleepily
04:53:12 <shapr> good morning #haskell !
04:53:20 <Jan_w> shapr: g'mornin
04:53:32 <shapr> Jan_w: did you hear from Ross?
04:53:40 <Jan_w> nothing yet
04:54:11 <Jan_w> I've spend to money wisely though, thinkGeek goodies:)
04:54:22 <tromp> so in this case ! doesn't help you because changes to bitboard are inspected almost immediately
04:54:32 <shapr> :-)
04:57:05 <Oejet> tromp: So strictness flag should help when all of the structure is used but not at the same time, while lazy eval. is good when only part of the structure is used in a certain run.
04:58:16 <bourbaki> moin shapr 
04:58:34 * shapr beats postfix with a stick
04:58:44 <tromp> right, strictness flag is used when lazily you wld get an expression like 1+1+1+1+1+... millions ,long
04:59:09 <tromp> whose evaluation is only forced much later
04:59:37 <bourbaki> shapr: do you happen to know how to do something like a nested conditional?
04:59:49 <bourbaki> shapr: with arrows that is
05:00:03 <shapr> isn't there something like 'ifA' ?
05:00:57 <bourbaki> hm ..
05:01:53 <Oejet> tromp: I'm curious about your clever board representation.
05:02:49 <shapr> bourbaki: ross paterson's papers talk about conditionals with arrows
05:04:00 <tromp> i can mail you some java source that uses it
05:04:55 <bourbaki> shapr: yes i understand that perfectly but how do you nest them?
05:05:25 <shapr> like what?
05:07:02 <bourbaki> shapr: do you know what a decision tree is?
05:07:51 <tromp> off to lunch now
05:09:20 <shapr> bourbaki: like an expert system?
05:09:39 <bourbaki> shapr: lets say you had a collection of some arrtibutes
05:09:52 <bourbaki> and depending on that you want to find out what kind of object that is
05:10:04 <bourbaki> ie (red,round) would be a red ball
05:10:26 <bourbaki> but (red, cubic) would be a toy box or something
05:10:54 <bourbaki> what i now need is several layers of functions that decide what object i have
05:11:36 <shapr> that sounds easy (since I haven't tried it with arrows ;-)
05:12:00 <bourbaki> now lets say there also was a sice test
05:12:09 <bourbaki> and all the tests dont overlap
05:12:19 <shapr> sice?
05:12:26 <bourbaki> size :)
05:12:34 <shapr> ok
05:12:43 <bourbaki> f1 would say its smaller then 10 f2 would say its between 10 and 20
05:12:51 <bourbaki> and f3 would say its bigger then 20
05:13:05 <shapr> this is the game twenty questions?
05:13:16 <bourbaki> and depending on that i need to select functions then that refine that stuff further
05:13:36 <bourbaki> the game 20 q's is a perfect application of a decision tree
05:13:54 <bourbaki> http://images.google.com/imgres?imgurl=http://www.isip.msstate.edu/images/technical/sp/decision_tree.gif&imgrefurl=http://www.isip.msstate.edu/projects/speech/software/legacy/decision_tree/&h=341&w=291&sz=5&tbnid=x3hGbO9io7YJ:&tbnh=114&tbnw=98&start=40&prev=/images%3Fq%3Ddecision%2Btree%26start%3D20%26hl%3Den%26lr%3D%26sa%3DN
05:14:02 <shapr> so, you want to use static properties of arrows to choose which functions to select next?
05:14:15 <bourbaki> kind of yes
05:14:38 <shapr> can you have the same structure as the parsers that export what they can accept?
05:14:39 <bourbaki> my problem is that if i take the direct sum of one layer then i would need to constuct special functions on the next layer
05:14:57 <shapr> what does that mean? :-)
05:15:20 <bourbaki> well either a b is a direct sum
05:16:01 <bourbaki> and if you split from one node with several functions then you would yield something like a direct sum of elements afterwards like that cond in the paper you pointed out
05:16:12 <shapr> decision trees as arrows looks really cool.
05:16:27 <bourbaki> yeah thats what i intend to do with my graph thesis thing
05:16:47 <bourbaki> i want to get DT, beysian learning, neural nets and so on in one framework
05:17:07 <shapr> direct sum of elements is the elements that are still possible after the most recent question/answer round?
05:17:18 <bourbaki> i just need to understand how to construct all these techniques and then have to teach the graph how to combine the functions to get what i want
05:17:33 <bourbaki> shapr: no its the same as either
05:17:46 <bourbaki> the stuff that comes out of the single layer
05:18:03 <bourbaki> is either the return of the first or second or ... or nth function
05:18:29 <bourbaki> one layer would be like a cond thats not that hard to do with arrows i think
05:18:41 <bourbaki> but what i now need is to have a cond in the cond
05:22:04 <bourbaki> hm i think ill have to make conditionals from every node and then stick them together
05:22:07 <shapr> isn't ArrowChoice like Either?
05:22:20 <shapr> other than that, I'd have to sit down and look at the papers.
05:22:21 <bourbaki> the problem is what operations do you have to use
05:22:34 <bourbaki> np dont bother i think i figured it out
05:22:43 <shapr> I have to clean the apartment, but I'd like to look at this later.
05:22:58 <bourbaki> the problem is that i will need a lot of different methods to generate the function in the end from the network
05:23:13 <bourbaki> shapr: sure i can tell you what i had in mind then
05:23:18 <shapr> ok :-)
06:07:54 <yohan> if i have a definition of (Num a) => etc...what is the difference if i have (Num a, Ord a) => etc...doesnt Ord include everything Num has instances for?
06:09:46 <Igloo> Not necessarily
06:10:05 <yohan> But what is the difference? why would you use the latter one?
06:10:20 <arjanb> @info Num
06:10:21 <lambdabot> -- Num is a class
06:10:21 <lambdabot> class (Eq a, Show a) => Num a where {
06:10:21 <lambdabot>     (-) :: a -> a -> a {- has default method -};
06:10:21 <lambdabot>     (*) :: a -> a -> a;
06:10:21 <lambdabot>     (+) :: a -> a -> a;
06:10:21 <lambdabot>     negate :: a -> a {- has default method -};
06:10:23 <lambdabot>     signum :: a -> a;
06:10:25 <lambdabot>     abs :: a -> a;
06:10:27 <lambdabot>     fromInteger :: Integer -> a;
06:10:37 <Igloo> If you needed something that was both an instance of Num and of Ord
06:11:40 <phubuh> @type \xs -> List.sort (map (+ 1) xs)
06:11:41 <lambdabot> \xs -> List.sort (map (+ 1) xs) :: forall a.
06:11:41 <lambdabot> 				   (Ord a, Num a) =>
06:11:41 <lambdabot> 				   [a] -> [a]
06:11:44 <yohan> but if i write (Num a, Ord a)...doest it have to be an instance in both? its confusing...doesnt it mean the same thing as simply Ord a would
06:12:01 <yohan> aha
06:14:50 <yohan> i dont quite understand it but it seems that when you are dealing with lists you should use (Ord a, Num a)
06:15:52 <yohan> why doesnt sqrt . sqrt 5 work? :)
06:16:02 <Igloo> You need Num a because you are doing +1
06:16:03 <yohan> when using . it has to be a higher order function?
06:16:17 <yohan> ah, Num says that?
06:16:40 <phubuh> Ord a means you can determine if one a is greater than the other, so you need it to sort; Num a means you can treat an a like a number, so you need it to add 1
06:16:46 <Igloo> @type (+)
06:16:50 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
06:16:59 <phubuh> sqrt . sqrt 5 parses to sqrt . (sqrt 5) -- you probably mean (sqrt . sqrt) 5
06:17:26 <yohan> ah k, thank you
06:25:50 <bourbaki> can someone help me to implement a function for this type signature?
06:25:54 <bourbaki> left :: Fun a b -> Fun (Either a d) (Either b d)
06:26:16 <bourbaki> Fun a b = (a -> b)
06:28:33 <Lor> Just a standard function arrow?
06:28:44 <bourbaki> i guess yes
06:28:55 <TheHunter> left (Fun f) = Fun $ \x -> case x of { Left y -> Right (f y); Right y -> Right y }
06:29:13 <TheHunter> s/Right/Left/
06:29:33 <bourbaki> what $ doing?
06:30:17 <TheHunter> basically function application: (+1) $ 3 + 4 ==> (+1) 7 ==> 8
06:30:41 <TheHunter> but with different prec.
06:31:04 <TheHunter> left (Fun f) = Fun (\x -> case x of { Left y -> Left (f y); Right y -> Right y })
06:31:35 <bourbaki> woop Fun a b = F (a -> b)
06:32:09 <TheHunter> then the second Fun must be F
06:32:14 <bourbaki> yep
06:32:16 <bourbaki> sry
06:32:30 <TheHunter> does that typecheck?
06:32:47 <bourbaki> :) i just got it from that paper to be honest
06:33:03 <bourbaki> but i guess it might come handy some day
06:33:15 <bourbaki> to mix more then one fn type in there
06:33:28 <TheHunter> i think it's a good exercise to write Arrow instances for simple types
06:33:39 <bourbaki> i want to do it for a neural net
06:33:46 <bourbaki> so its all Float -> Float
06:34:07 <Lor> The function arrow is kinda useless in itself.
06:34:19 <Lor> Well, except that arrow combinators are useful even as function combinators.
06:35:03 <bourbaki> Lor: pardon?
06:35:03 <TheHunter> Lor: they're extremely useful, it's a shame that (with the exception of either) none of them is defined in the prelude.
06:35:28 <Lor> Yeah.
06:36:43 <Lor> And (.)
06:36:47 <TheHunter> bourbaki: you can't have (with the haskell arrow interface) arrows that are just defined for Float -> Float
06:37:29 <bourbaki> TheHunter: i know its just the application i want to use it for
06:38:14 <TheHunter> and something like g <<< f for monads instead of (=<<) g . f would be cool, too
06:48:39 <bourbaki> TheHunter: do you have an idea how to do a nested cond with arrows?
06:51:11 <TheHunter> how's a nested cond different from a usual one?
06:51:35 <bourbaki> TheHunter: do you know what a decision tree is?
06:52:16 <TheHunter> i think i have an idea what it is
06:52:47 <bourbaki> so depending on the outcome of one function youd need to pick a collection of other functions
06:54:35 <TheHunter> you could implement a function nestedCond :: ArrowChoice a => DecisionTree (a b Bool) (a d c) -> a d b -> a d c
06:55:05 <TheHunter> where DecisionTree x y stores x's at the nodes and y' at the leaves
06:55:42 <bourbaki> *think think think*
06:56:42 <TheHunter> DecisionTree is meant to be binary, but you could generalize that to arbitrary arity, i guess
07:00:44 <TheHunter> oops, the type is wrong: nestedCond :: ArrowChoice a => DecisionTree (a b Bool) (a c d) -> a b c -> a b d
07:15:51 <dv> is there any way to get arbitrary precision on floats?
07:18:24 <Lor> Yes, by implementing them.
07:18:44 <TheHunter> dammit, ghc -Wall should really warn about (-1)!
07:18:55 <raboof> Lor: (drumm roll)
07:19:23 <Igloo> Euch, no thanks - I don't want it warning about all my perfectly good code!
07:19:31 <shapr> does the exact real stuff give floats?
07:19:33 <dv> i meant like you can do in bc "scale=1000; sqrt(2);" and you get sqrt(2) to a 1000 digits
07:19:52 <Lor> I think the exact real stuff is better than floats.
07:20:32 <raboof> heh, try doing sqrt(2) for exact reals :)
07:20:48 <Lor> Yes?
07:21:06 <TheHunter> bourbaki: http://www.haskell.org/hawiki/HaskellIrcPastePage
07:21:17 <bourbaki> TheHunter: thx whats that for?
07:21:32 <bourbaki> TheHunter: ah thx :)
07:21:32 <raboof> Lor: you're talking about leaving that 'sqrt(2)' symbolically?
07:21:45 <tuomov> hmm.. with haskell's lazy evaluation, it might be possible to implement a Num type for such exact arithmetic..
07:22:03 <tuomov> you just truncate it when you print it out
07:22:07 <raboof> yeah, i guess so, as long as you just print a finite number of decimals :)
07:22:07 <TheHunter> i just tried to implement that decision tree thing. I'm not really good at arrow syntax, so this might be more complicated than it has to be.
07:22:16 <Lor> I mean you can lazily compute it to an arbitrary precision as needed.
07:22:36 <raboof> yay, we agree.
07:22:56 <bourbaki> TheHunter: neither am i :) actually i cant read it atm since i still try to understand the math of it all first
07:25:43 <TheHunter> ok, simplified :)
07:28:28 <bourbaki> hm
07:30:21 <bourbaki> the problem is that this will need some special crafted stuff
07:37:55 <TheHunter> what representation of DecisionTree (...) (...) did you think of?
07:38:24 <shapr> tuomov: there's ExactReal code in hlibs
07:38:32 <bourbaki> i want an abritrary network that gets collapsed to a DT
07:38:42 <shapr> written by Pseudonym of course, modified from the original author's code
07:39:46 <TheHunter> bourbaki: you mean, your BourbakiArrow b c should already repesent a DT from b to c?
07:40:01 <bourbaki> TheHunter: i need a collection of base operations that are able to build these things
07:40:32 <TheHunter> so BourbakiArrow baseOps b c...
07:40:45 <bourbaki> TheHunter: no the idea is to model the DT as a graph where the edges are functions and then these get tinkered together to what i had in mind
07:41:38 <TheHunter> BourbakiArrow could be represented internally as a graph
07:42:06 <bourbaki> TheHunter: the thing is that i also want to be able to make a subgraph to a single arrow
07:42:32 <bourbaki> so you mark some nodes and he calcs the function in between
07:42:44 <bourbaki> as esap pointed out thats the limit of the subgraph
07:46:48 <bourbaki> TheHunter: thats cause its ment to be more of a general framework
07:47:52 <bourbaki> the idea is that you can "write" your programs as graphs so i can just use a hand full of basic operations like the one the arrow class gives you
07:48:11 <TheHunter> i think the first thing you should think of is an interface for your graph thing. After that, you can see if it'll fit into the Haskell arrow model.
07:49:38 <bourbaki> TheHunter: i think its managable its just that its mindboggleing to find out how to glue the functions together to achieve what i want to have
07:50:06 <shapr> think of how much you're learning :-)
07:50:19 <bourbaki> sure :)
07:50:45 <bourbaki> thats what my thesis is about the idea is that you can do things with the underlying structure of these programs
07:50:55 <bourbaki> like glueing some of them together
07:51:01 * shapr wonders if Ulf Norell's code can arbitrarily derive Typeable and Data
07:51:04 <bourbaki> or build the union of two of them and such
07:58:12 <shapr> can I ask ghci whether a type is an instance of something?
07:59:35 <andersca_> can't you use :I for that?
07:59:37 <andersca_> :i
07:59:52 <shapr> how?
08:00:00 <shapr> @info Int
08:00:01 <lambdabot> -- Int is a type constructor
08:00:01 <lambdabot> data Int = GHC.Base.I# GHC.Prim.Int#
08:00:36 <shapr> info on the class or the type doesn't seem to tell me about instances.
08:00:36 <andersca_> hmm, perhaps not
08:00:53 <andersca_> ah, it's hugs that does that
08:03:16 <shapr> Igloo: did Ulf Norell get his TH deriving code from one of your papers?
08:03:37 <Igloo> No idea
08:03:55 <shapr> did you write TH code for deriving Data and Typeable in your papers?
08:03:57 <Igloo> If it's in the style of GH then no
08:04:02 <Igloo> no
08:04:06 <shapr> GH?
08:04:10 <shapr> oh, generic haskell
08:04:12 <Igloo> Yup
08:04:37 <shapr> I just saw Keean asking for separation of deriving from definition (I'd like that too)
08:04:44 <TheHunter> bourbaki: i think it's a good idea if you write an abstract interface what operations your library should be able to perform. Just high-level descriptions like subGraphArrow :: Graph -> SubGraph -> Something. You will then have a much clearer picture how this can be achieved. Questions like "How do I model decision trees with arrows?" will also become a clearer meaning.
08:04:55 <shapr> and Ulf's code can already do that for non-parameterized datatypes.
08:05:11 <shapr> I can't get it to work with something like Tree a, but that could be user error, since I don't really know what I'm doing.
08:05:38 <bourbaki> TheHunter: yep the question is just what kind of operations you would need but i think i can tinker something together ;)
08:05:58 <TheHunter> bourbaki: details don't matter, just the big picture.
08:07:53 <tromp> rehi
08:07:58 <bourbaki> TheHunter: yeah i guess so
08:08:23 <tromp> any1 here looked at ulf's obfuscated code?
08:08:30 <shapr> yes, me.
08:08:51 <shapr> Not sure I understood much of it... but I had to put up the IOHCC results :-)
08:09:00 <tromp> have you tried reconstructing his original source?
08:09:10 <shapr> No, but I have been curious about that.
08:09:26 <tromp> ok, here's a nice little exercise
08:10:01 <tromp> modify LamMain.hs (just the last line + one new import) to print rather than slice the quoted cocde
08:10:29 <shapr> oh
08:10:52 <shapr> hm
08:11:07 <tromp> i managed that, and recovered what shld be the original, except it's full of syntax errors:(
08:11:18 <shapr> that is interesting.
08:11:31 <shapr> Have you asked the Template Haskell master?
08:11:40 <tromp> i sent mail to ulf himself
08:11:46 <shapr> what did he say?
08:11:58 <tromp> i suspect he doesnt read email on weekends:(
08:12:14 <shapr> Igloo might have some ideas.
08:12:29 <tromp> i suspect bugs in the prettyprinter
08:12:44 <shapr> what did you use to print it out?
08:12:56 <tromp> well, zz is the quoted code
08:13:18 <tromp> and $(zz) splices it back to compiler
08:13:24 <shapr> right...
08:13:32 <tromp> instead you apply unQ
08:13:37 <tromp> @index unQ
08:13:37 <lambdabot> Language.Haskell.THSyntax
08:13:45 <shapr> that's all?
08:13:47 <tromp> to get an IO [Dec]
08:13:59 <shapr> putStrLn $ show $ unQ $(zz) ?
08:14:22 <tromp> main = unQ zz >>= sequence_ . map (print . pprDec)
08:14:43 <tromp> Dec is not an instance of SHow
08:14:52 <shapr> @index pprDec
08:14:52 <lambdabot> Language.Haskell.THSyntax
08:15:21 <shapr> huh, I get !! index too large
08:15:28 <tromp> knew you would:)
08:15:30 <shapr> in ghci
08:15:52 <tromp> run lambda with the list of haskell files that it compiles with
08:16:09 <shapr> ?
08:16:27 <tromp> try make lambda
08:16:32 <shapr> oh
08:16:58 <shapr> this takes a surprising amount of time to compile
08:17:04 <tromp> it expects its own source to be 4th .hs file in getArgs
08:17:24 <tromp> well, cause the compiler runs parts of the code:)
08:18:03 <shapr> yah, I still gotta try faking hs-plugins by running the whole TH program during --make
08:19:00 <shapr> oh, neat
08:19:05 <shapr> crazy and confusing and neat
08:19:09 <tromp> :-P
08:19:17 <tromp> and syntactically incorrect:(
08:19:45 <shapr> You should post this challenge on lambda-the-ultimate.org in response to my IOHCC article :-)
08:20:22 <shapr> you get an error on "data I b l = A b -> I b l | D | E l I b l" ?
08:20:51 <shapr> that "A b ->" is totally wrong
08:21:01 <tromp> yep
08:21:32 <tromp> but pprDec seems only way to get stuff printed...
08:22:10 <tromp> cant find ur article on ltu
08:22:27 <shapr> it's in the discussions
08:22:32 <shapr> laundry, brb
08:33:43 <bourbaki> can i check for equality of functions ?
08:36:00 <tuomov> (of course) not
08:36:14 <bourbaki> ?
08:36:27 <bourbaki> why of course?
08:36:35 <tuomov> halting problem etc.
08:36:55 <tuomov> you could define pointer equality, but it wouldn't make much sense
08:37:08 <bourbaki> ok but it might be able to rewrite functions in order of equality
08:37:59 <tuomov> with pointer equality e.g. (map foo) == (map foo) would be false
08:38:20 <tuomov> well, depending on how the compiler optimises that..
08:38:44 <shapr> tromp: that's really interesting... I'm pretty sure that's a bug, and it also means that pprDec isn't being used internally, right?
08:38:48 <shapr> otherwise the code wouldn't work...
08:39:37 <tromp> right
08:39:56 <tuomov> hmm.. actually, pointer equality doesn't make any sense at all in a referentially transparent language
08:40:00 <shapr> I wonder if TH works directly on Core... (I should remember)
08:40:01 <tromp> it means that almost no-one has used pprDec before
08:40:12 <tromp> or they'd have reported the bug:(
08:40:13 <tuomov> or at least so it would seem to me
08:40:29 <shapr> tuomov: identity doesn't make sense in a reftrans lang.
08:40:34 <shapr> only value equality
08:40:44 <tromp> do you have the source of pprDec?
08:40:44 <tuomov> and that you can't do with functions
08:40:50 <Igloo> TH is before core
08:40:53 <tromp> @info pprDec
08:41:03 <bourbaki> tuomov: i see the piont
08:41:13 <shapr> so, a supercombinator based FP implementation could in fact give extensional equality
08:41:19 <shapr> I've wondered about that myself.
08:41:22 <Igloo> What's the pprDec problem?
08:41:35 <shapr> but intensional equality might be harder
08:42:04 <tromp> pprDec fails on ulf's obfuscated code
08:42:06 <shapr> Igloo: ulf norell's entry generates "data I b l = A b -> I b l | D | E l I b l"
08:42:31 <Igloo> Ah, a missing case?
08:42:39 <shapr> it generates http://www.scannedinavian.org/~shae/LamOut.hs
08:43:00 <Igloo> I think it's all different in CVS, but that bug probably isn't fixed
08:43:24 <Igloo> Oh, no, I see, you mean it generates the wrong output?
08:43:35 <shapr> yup
08:43:54 <Igloo> Do you know what the right output is?
08:43:57 <shapr> nope
08:44:09 <shapr> but the program works by itself
08:44:12 <shapr> just not through pprDec
08:44:14 <tromp> that's what i was after:)
08:44:29 * shapr gives tromp the gold bug award for the day.
08:44:54 <tromp> can't believe i'm the only one to try deconstruct his entry:(
08:45:14 <shapr> maybe you're the only one who reported the bug?
08:45:55 <tromp> i'll leave the bug reporting to ulf; only he knows the details
08:46:08 <shapr> you should definitely report the bug.
08:46:15 <shapr> pprDec has some sort of problem.
08:47:24 <tromp> i want to report the details, which i don't know yet
08:47:41 * Igloo can't see the bug - what's the reult of showing the data declaration?
08:48:19 <tromp> we don't know the original declaration:(
08:48:49 <Igloo> You can just print wherever you're using pprDec
08:49:07 <shapr> sauna, bbl
08:49:49 <musasabi> home and sauna too..
08:49:53 <musasabi> shapr: have fun.
08:50:52 <tromp> print what?
08:51:08 <tromp> Dec's are not printable
08:51:57 <Igloo> Show is derived in 6.2.2 at least
08:52:29 <Igloo> And 6.2.1 too
08:53:47 <tromp> but how do i get Showable instances of Dec ?
08:54:13 <Igloo> What makes you think you haven't got one?
08:55:14 <tromp> good point:)
08:58:29 <tromp> ok, so the declaration is "DataD [] \"I\" [\"b\",\"l\"] [NormalC \"A\" [(NotStrict,AppT (AppT ArrowT (VarT \"b\")) (AppT (AppT (ConT \"I\") (VarT \"b\")) (VarT \"l\")))],NormalC \"D\" [],NormalC \"E\" [(NotStrict,VarT \"l\"),(NotStrict,AppT (AppT (ConT \"I\") (VarT \"b\")) (VarT \"l\"))]] []"
08:59:08 <tromp> which pprDec turns into data I b l = A b -> I b l | D | E l I b l
09:00:03 <tromp> so maybe it shld be A (b -> I b l) | ...
09:03:14 <tromp> pprDec leaves out many parentheses
09:04:14 <Igloo> Ah, it's fixed in 6.2.2
09:04:53 <Igloo> That explains why I couldn't see the bug  :-)
09:05:02 <tromp> hmm, too bad i can't install 6.2.2 myself
09:05:29 <tromp> can u send me the correct output?
09:06:55 <Igloo> Not right now, sorry
09:13:23 <joao> Hello haskellers! :)
09:13:30 <CosmicRay> good morning
09:13:40 <joao> 17pm here :)
09:14:11 <CosmicRay> hmm
09:14:15 <CosmicRay> central europe?
09:14:31 <CosmicRay> ah, portugal.
09:14:38 * CosmicRay didn't pay attention when you joined
09:14:40 <CosmicRay> what's up?
09:18:27 <joao> No problem :)
09:18:32 <joao> Up? The sky O:)
09:29:53 <goron> I assume everybody knows ghc 6.2.2 was released yesterday? We now have some unicode support :)
09:32:11 <CosmicRay> oo, new ghc
09:32:50 <Igloo> There are (almost entirely untested) debs in haskell-unsafe
09:33:08 * heatsink is trying to debianize hs-plugins now
09:33:19 <CosmicRay> heatsink: are you a debian developer?
09:33:31 <heatsink> no, just a user
09:33:32 <cedricshock> Is it safe to say that O(A + B) = O(A) + O(B)?
09:33:52 <CosmicRay> well if you do get .debs working, I'd be willing to maintain them in sid
09:33:54 <heatsink> cedricshock: yes
09:34:07 <CosmicRay> that is a ways down on my list of things to debianize, so I was already considering it ahway
09:34:13 <CosmicRay> heatsink: if you use cabal for it, anyway
09:34:18 <heatsink> what is cabal?
09:34:43 <CosmicRay> http://www.haskell.org/cabal/
09:34:48 <CosmicRay> there is also a debian haskell policy
09:34:54 <heatsink> oh!
09:34:55 <CosmicRay> http://urchin.earth.li/~ian/haskell-policy/haskell-policy.html/index.html#contents
09:35:06 <CosmicRay> and finally, I have written dh_haskell
09:35:19 <CosmicRay> it is waiting in incoming just now
09:35:30 <CosmicRay> http://gopher.quux.org:70/devel/haskell-devscripts_0.5.1_all.deb
09:35:55 <CosmicRay> have you ever built debs out of anything else before, heatsink?
09:36:05 <heatsink> no
09:36:18 * heatsink has the new maintainer's guide open
09:36:33 <CosmicRay> so you are thinking of becoming a debian developer down the road?
09:36:55 <CosmicRay> http://www.nl.debian.org/doc/developers-reference/ will also be useful for you, likely
09:37:16 <CosmicRay> I might suggest starting with something other than a Haskell program, even if it's just as an experiment
09:37:19 <Igloo> Generally I find it easiest to copy debian/rules from /usr/share/doc/debhelper/examples/rules and the various other debian/* files from another package, but dh_haskell might do some of that for you already
09:37:36 <CosmicRay> Haskell stuff can be fairly complex as far as Debian packages go
09:37:51 <CosmicRay> in fact, libraries in general are, since you typically generate multiple .debs out of a single source package
09:38:06 <Igloo> hs-plugins shouldn't be too bad as it's ghc6-only
09:38:27 * Igloo assumes it's only one binary deb too
09:38:29 <CosmicRay> Igloo: is there an upstream changelog for 6.2.2 anywhere?
09:38:51 <CosmicRay> heatsink: if you want an example, check out http://quux.org/devel/missingh
09:38:51 <Igloo> I don't think so - it's predominantly little bug fixes
09:39:13 <CosmicRay> blat.
09:39:16 <Igloo> People were looking earlier and couldn't find one. Interface changes are heavily frowned upon for point releases
09:41:35 <Igloo> CosmicRay: Can you think of anything necessary missing from this?
09:41:35 <Igloo> ghc6_arches="alpha amd64 hppa i386 ia64 m68k powerpc s390 sparc"
09:41:35 <Igloo> ghc6_lib_bdeps="ghc6 (>= 6.2.2) [$ghc6_arches], ghc6 (<< 6.2.2+) [$ghc6_arches]"
09:41:39 <Igloo> ghc6_app_bdeps="ghc6 [$ghc6_arches]"
09:42:01 <CosmicRay> hmm, ghc6 does not work on all Debian platforms?
09:42:21 <CosmicRay> I thought it was arch: any
09:42:30 <Igloo> No - we had that conversation a couple of days ago  :-)
09:42:43 <CosmicRay> I thought that was only ghci
09:42:44 <heatsink> this is gonna be a lot of reading...
09:44:04 <CosmicRay> yeah
09:44:19 <CosmicRay> Igloo: I would suggest that the correct thing to do is to split off ghci into its own deb
09:44:25 <CosmicRay> Igloo: and build that on only the archs where it works
09:44:31 <bourbaki> TheHunter: still awake?
09:44:40 <CosmicRay> Igloo: otherwise we add a great deal of complexity for every haskell package
09:44:45 <Igloo> http://tunes.org/~nef/logs/haskell/04.10.05 (search for mipsel)
09:44:46 <CosmicRay> Igloo: having to select a ghc based on arch, etc.
09:45:21 <CosmicRay> oh *that* conversation :-)
09:45:25 <Igloo> I don't see how splitting ghci off help unless something wants to (build-)depend on ghci
09:45:36 <Igloo> :-)
09:45:41 <CosmicRay> I still think that arch: any is the right thing for ghc
09:45:51 <Igloo> ghc /is/ arch: any
09:46:03 <CosmicRay> right, but you're proposing changing that?
09:46:07 <Igloo> You need to list arches in builddeps or the autobuilders screw up
09:46:11 <Igloo> No
09:46:23 <CosmicRay> hmm
09:46:39 <CosmicRay> so you have a package that could be built with ghc6 and some other compiler
09:46:51 <CosmicRay> and you want to explicitly list the ghc6 archs for the autobuilders?
09:47:02 <Igloo> Libraries need to build-dep on (ignoring versions  ghc6 [$ghc6_arches], nhc98 [$nhc98_arches]
09:47:22 <Igloo> Applications need to build-dep on   ghc6 [$ghc6_arches] | nhc98 [$nhc98_arches] | ghc6 | nhc98
09:47:37 <CosmicRay> I don't think that arch stuff is necessary
09:47:41 <bourbaki> what would be an implementation of app :: Fun ((Fun a b), a) b
09:47:42 <bourbaki> ?
09:47:52 <CosmicRay> the autobuilders should see that the ghc6 is not available and put the package into dep-wait state
09:47:53 <Igloo> If you say ghc6 | nhc98 then the autobuilders /always/ try to install ghc6
09:47:55 <bourbaki> where Fun a b = F (a -> b)
09:48:03 <CosmicRay> Igloo: yeah but then they fail
09:48:08 <Igloo> But it doesn't need to dep-wait
09:48:16 <CosmicRay> oh I see.
09:48:19 <Igloo> The only way thing would get compiled is by-hand
09:48:59 <CosmicRay> gar.
09:49:14 <CosmicRay> I guess I hadn't come across that yet because cabal doesn't work with nhc98 yet
09:49:30 <heatsink> bourbaki: app has a recursive type... can you do that?
09:50:04 <heatsink> a :: ((Fun a b), a)
09:50:16 <bourbaki> heatsink: thats what the paper says its just something like a dual pairing
09:50:51 <bourbaki> app (f,c) = f c is what the paper says
09:51:07 <CosmicRay> Igloo: actually don't we have a way to specify "not on this arch"?
09:51:16 <CosmicRay> ghc6 [!arm mipsel] or something?
09:51:24 <CosmicRay> If so, I'd suggest that would be the better route
09:51:25 <heatsink> that's app :: (Fun, Fun) -> something
09:51:28 * CosmicRay can't remember
09:51:30 <Igloo> ghc6 [!arm !mipsel], but why is that better?
09:51:49 <CosmicRay> because that way, it's 1) a much smaller list, and 2) doesn't have to be modified every time we add a new arch
09:52:04 <bourbaki> heatsink: app :: a (a b c, b) c
09:52:19 <Igloo> It doesn't have to be modified either way
09:52:30 <Igloo> And this way it also works when Debian gets a new arch
09:52:48 <CosmicRay> you'd have to update your lists of ghc6_arches otherwise
09:53:26 <CosmicRay> oh well, either way works
09:53:27 <Igloo> But ghc6_arches is provided by the ghc6 package, which knows when it gets ported to a new arch
09:53:33 <CosmicRay> ah.
09:53:41 <CosmicRay> ok that was a bit of information I didn't have :-)
09:53:44 <CosmicRay> in that case, excellent.
09:53:59 <CosmicRay> you're working on that file contemplated by the haskell policy then?
09:54:07 <TheHunter> bourbaki: app = Fun $ \ ((Fun f), x) -> f x
09:54:14 <Igloo> Yes - the above is what is in the h-u ghc6 package
09:54:20 <CosmicRay> excellent
09:54:23 <TheHunter> err, F $ \ ((F f), x) -> f x
09:54:26 <Igloo> I'm currently working on the script that does something with it
09:54:28 <CosmicRay> once that hits sid, I'll update dh_haskell to use it
09:55:18 <bourbaki> TheHunter: can you point me to somewhere where i can read on that $ thing?
09:55:47 <Igloo> f $ g x == f (g x)
09:56:04 <bourbaki> aha and whats the difference to . then?
09:56:19 <Igloo> (f . g) x = f (g x)
09:56:39 <TheHunter> @wiki PipeliningFunctions
09:56:39 <lambdabot> http://www.haskell.org/hawiki/PipeliningFunctions
09:56:49 <Igloo> Which looks nicer depends on what exactly you are writing, and on your taste
09:56:52 <heatsink> f $ g x y == f (g x y)
09:57:03 <heatsink> (f . g) x y == (f (g x)) y
09:58:34 <bourbaki> thx
09:59:23 <bourbaki> is F $ / .... considered better then F ( / ... ) ?
09:59:48 <Igloo> It avoids the ))))))))))) that LISP is so famous for
09:59:51 <bourbaki> i guess the first emphasis more that its some kind of constructor does it?
09:59:55 <Igloo> And generally makes it easier to match things up
09:59:58 <bourbaki> hey i like parenthes :)
10:00:15 <bourbaki> ok thx
10:00:48 <TheHunter> i usually don't like more than one $ on one line: f $ g $ h $ x -> f . g . h $ x
10:01:07 <Igloo> foo $ bar $ baz $ map (foo . bar) $ quux xs   is much cleare than    foo (bar (baz (map (foo . bar) (quux xs))))   IMHO
10:02:38 * heatsink finds foo (bar baz) qux clearer than any combination of . and $
10:02:53 <shapr> y0 Lunar^
10:02:55 <shapr> er Luke
10:03:08 <Igloo> Yeah, I wouldn't use them in that case
10:03:24 <shapr> Luke: hey luke, I found the posting problem, but I haven't yet found how to fix it :-/
10:03:27 <shapr> Luke: you know anything about postfix?
10:04:18 <shapr> Luke: you could also register your nickname if you want
10:04:35 * heatsink finds it trippy that ghc will parse undefined :: forall a b. a (a b, a b)
10:04:40 <Luke> howdy shap
10:04:55 <shapr> Luke: hey, did I already tell you about my new mountain unicycle?
10:04:56 <Luke> I'm not aware of any problems
10:05:05 <Luke> no? I've seen them on TV, look cool :)
10:05:13 * heatsink ...because without the forall, you couldn't define the type without defining a type synonym first
10:06:12 <shapr> yah, I've got the KH24 (standard, non-pro), here's pro, with brakes etc: http://www.unicycle.com/Shopping/shopexd.asp?id=466
10:06:40 <heatsink> whoah that's expensive
10:06:43 <shapr> the standard non-pro is about $1300 less, so...
10:06:44 <depaulis> what is actually the differens between define a type with "type name...." and "data name..." ? 
10:07:45 <shapr> Luke: had any time to play with hemacs? what do you think about zipper versus ropes?
10:07:58 <depaulis> Maybe just "type name..." cant give different constructors for the type I am defineing? 
10:08:11 <shapr> I think type is an alias
10:08:16 <heatsink> right
10:08:23 <shapr> I don't know the difference between newtype and data
10:08:34 <bourbaki> TheHunter: im a bit mind blanked right now how can i use app now to return a value?
10:08:36 <heatsink> The difference there is in implementation
10:08:50 <bourbaki> TheHunter: app ((pure somefn), someval) ?
10:09:08 <TheHunter> bourbaki: you can't use app to get a value, just a value "inside your arrow"
10:09:13 <heatsink> newtype is typechecked like "data", but it is implemented like "type"
10:09:28 <shapr> huh?
10:09:46 <depaulis> heatsink : So if I want I can use type instead of data .... If I am writing no complex stuff? 
10:10:09 <bourbaki> TheHunter: and how are you supposed to retrieve the value?
10:10:20 <heatsink> depaulis: Type only makes type synonyms
10:10:39 <TheHunter> bourbaki: The point of an arrow is that you never get any values within the arrow interface.
10:10:48 <Luke> shapr: I think any data structure is okay so long as it has a decent interface. I used ropes in ermacs
10:10:52 <depaulis> heatsink : Okay, now I got it.. thanks.
10:10:53 <goron> What is arm short for?  
10:10:57 <shapr> point of an arrow, hah
10:11:12 <TheHunter> bourbaki: just like you can't get a if you have m a for an arbitrary Monad m
10:11:14 <bourbaki> TheHunter: so the same as in monads "once you lifted you never come back"
10:11:18 <shapr> goron: as in ARM.com? or what?
10:11:24 <shapr> hoi goron, hoe gaat het met jou?
10:11:44 <TheHunter> bourbaki: however, you can have primitives that know the implementation of your thing which give you the value
10:11:47 <shapr> Luke: oh cool, I can look at your rope implementation then.
10:11:51 <heatsink> shapr: data Foo = Foo String
10:11:57 <heatsink> a = Foo "a"
10:12:11 <Luke> I'd recommend using demoncrat's 'doe' editor (the older version) as a template. it has some ultra-simple algorithms that make a good start - just stick with them until they break down (if ever)
10:12:15 <heatsink> creates an object Foo in memory, which references a string...
10:12:15 <TheHunter> bourbaki: like unF :: F a b -> a -> b
10:12:17 <goron> hej shapr, I see you are improving your Dutch *1337* skills.
10:12:20 <shapr> goron: I think it's Advanced Risc Machines if you mean ARM.com
10:12:21 <bourbaki> TheHunter: that would usually be the interpretation of an app?
10:12:44 <shapr> goron: yah, this dutch chick hung out with us last weekend. surprisingly,  she does both miranda and unicycles.
10:12:48 <heatsink> newtype Foo = Foo String; a = Foo "a" creates a string in memory
10:12:50 <goron> shapr: I meant in the context of Debian.
10:12:51 <TheHunter> bourbaki: no, app :: Arrow a => a (a b c, b) c
10:12:53 <shapr> Anyway, she may be back tomorrow for more unicycling.
10:12:59 <bourbaki> TheHunter: can you copy my thought that arrows are much like dual spaces?
10:13:07 <Luke> efficiency of the text structure isn't that important since in practice things like searching become painfully slow long before modifications :)
10:13:16 <shapr> goron: ARM.com makes their own CPUs, known as ARM cpus.
10:13:40 <shapr> Advanced Risc Machines :-)
10:14:00 <shapr> ARM runs in Psion, and Nokia Symbian phones last I checked
10:14:09 <goron> shapr: Ok, so they are the only company creating those kind of CPUs?
10:14:12 <TheHunter> bourbaki: i'm not too familiar with dual spaces, but i think that's a different thing.
10:14:23 <shapr> goron: there may be some clones, not sure.
10:14:35 <goron> shapr: Thanks
10:14:41 <mflux> hm, I think arm might very well be licensed as VRML-code?
10:14:55 <shapr> mflux: huh?
10:15:09 <mflux> cell phone manufacturers etc
10:15:11 <shapr> Luke: I'll check out DOE... have you tried posting to the list yet?
10:15:25 <TheHunter> bourbaki: my view of arrow is "some kind of first-order domain specific language"
10:15:29 <shapr> Virtual Reality Modeling Language? on cell phones? I'm confused.
10:15:35 <bourbaki> TheHunter: http://planetmath.org/encyclopedia/DualSpace.html
10:15:38 <mflux> uh, VHDL :-)
10:15:45 <shapr> oh
10:15:56 <shapr> hardware description language....
10:15:58 <shapr> I don't know.
10:16:35 <shapr> Luke: ever thought about or dealt with incremental parsing?
10:17:13 <TheHunter> duality always has something to do with contravariance and the b of a b c is used contravariantly, so there might be a connection.
10:17:30 <Luke> read a bit about it in a reference that demoncrat put me onto. I did an incremental lexer (easy once you see how) but never used it
10:17:46 <shapr> doe-0.1.3 is the older version?
10:18:03 <Luke> dunno. I think he has two on his website, and that he said the older one was simpler
10:18:16 <shapr> ah, no... 0.1.1
10:18:25 <Luke> is someone hacking hemacs now?
10:18:36 <shapr> at this instant? don't think so.
10:18:40 <shapr> code changes today? yes.
10:18:42 <bourbaki> TheHunter: i search in my script sec
10:18:54 <TheHunter> bourbaki: ie. the dual of a function f : V -> W is a function g: W* -> V*. OTOH arr :: (b -> c) -> a b c
10:19:00 <shapr> I'm in search of a good buffer design.
10:19:09 <shapr> that's why I've been reading up on zipper/ropes/etc
10:19:23 <shapr> I *really* want to have an incremental parser at the core of hemacs.
10:19:32 <Luke> I recommend taking whatever is easiest to implement and using it until it becomes too bad in practice
10:19:45 <cedricshock> Is a function of polynomial time of the infinite degree in P?
10:20:02 <Luke> does GHC already have a balanced tree data structure somewhere?
10:20:17 <Lor> What is a polynomial of an infinite degree?
10:20:37 <cedricshock> I mean an alorithm with time polynomial to the infinite degree.
10:20:44 <Lor> You can't just say f(x)=x^inf, it's meaningless.
10:20:54 <cedricshock> Lim d->oo of n^d
10:21:00 <Lor> There's no such number as infinite.
10:21:42 <Lor> (As long as we are talking about ordinary real or natural numbers)
10:21:45 <bourbaki> TheHunter: thats the dual mapping imho
10:21:45 <TheHunter> shapr: although the paper ski mentioned the other day talked about adaptive programming in a monadic style, i think "incremental" computations are a perfect match for arrows.
10:21:57 <cedricshock> Lor: You are right. But there is a "first" transfinite number, although there are other smaller ones.
10:22:11 <TheHunter> bourbaki: the point is, the order of the arguments changes
10:22:19 <bourbaki> TheHunter: ie V^* = Hom(V,K)
10:22:34 <bourbaki> TheHunter: and arrows are nothing but homorphisms right?
10:22:48 <Luke> in this day and age I wonder if parsers even need to be incremental. it's probably plenty cheap enough to reparse on demand
10:22:55 <cedricshock> I thought arrow were just *morphisms.
10:22:56 <goron> I just installed Mono, and downloaded the .exe file from this place: http://www.seasideresearch.com/downloads.html when I do mono programname it gives an error message. Anyone experience with .NET/Mono?
10:23:10 <Luke> I suspect the hard part is handling errors in the text
10:23:20 <TheHunter> bourbaki: CT arrows and haskell arrows are not really the same thing
10:23:27 <Lor> Are you seriously claiming to have an ordinarily computable algorithm whose time complexity is O(n^omega)?
10:23:41 <bourbaki> TheHunter: but mathematically thats right ?
10:24:03 <Lor> Anyway, then it takes infinite time and is hence not even computable, much less in P.
10:24:08 <TheHunter> they don't have to be homomorphisms, anything which obeys the law will do
10:24:14 <cedricshock> Lor: No. It's a question.
10:24:33 <TheHunter> bourbaki: in particular arrows _don't_ have to be functions.
10:24:48 <bourbaki> hm ok
10:24:51 <cedricshock> We can prove for d>=4 that there exists a problem in P with running time O(n^d).
10:25:08 <Lor> For any _natural_ number d, I take it. Or a real.
10:25:17 <monochrom> you mean Theta(n^d)? :)
10:25:29 <Lor> Yeah, O is pretty trivial. :)
10:25:32 <cedricshock> For integers.
10:25:44 <Lor> Well then, omega is not an integer.
10:25:57 <cedricshock> that's an O not a 0. "Big O"
10:26:14 <Lor> Yes. Do you know the difference between O and Theta?
10:26:20 <cedricshock> No.
10:26:43 <Lor> O gives you just an upper limit, not necessarily the _minimal_ upper limit.
10:27:00 <Lor> So anything that is O(1) is also O(n), O(n^2), O(e^n) and so on.
10:27:09 <Luke> shapr: the strategy is to start with Riot and incrementally turn it into an Emacs, right?
10:27:09 <cedricshock> Ok. Nice convention.
10:27:24 <Lor> The O-notation is pretty screwed, IMHO.
10:27:33 <cedricshock> So I mean, in your convention: ... Theta(n^d).
10:27:37 <Lor> y = O(n) looks like an equation but it isn't.
10:27:40 <Igloo> Gee, and there was me thinking it might turn into a decent editor  :-)
10:27:47 <goron> Lor: Wasn't that Omega? (lower bound for a general algorithm for a particular problem).
10:28:34 <shapr`> grr
10:28:52 <cedricshock> I just take O(...) to mean on the order of and have always specified what it meant elsewhere.
10:29:02 <tuomov> hmm.. I always forget.. what was the difference between O and o?
10:29:10 <Luke> shapr: the strategy is to start with Riot and incrementally turn it into an Emacs, right?
10:29:11 <heatsink> O is tight
10:29:15 <shapr> Luke: yes
10:29:21 <Lor> goron, how do you distinguish between O and Omega (typographically)? :)
10:29:23 <Igloo> Bah, what's the use of me insulting emacs if shapr is going to break himself when I do so?
10:29:27 <tuomov> in what sense thight?
10:29:29 <shapr> haha
10:29:31 <Lor> Properly, the big-O is really an Omega, I think.
10:29:45 <heatsink> O is <= and o is <
10:29:54 <tuomov> oh, that
10:30:08 <shapr> Igloo: well, dons is a vim person, tuomov is a jed/joe person, and I'm an emacs person... so I think hemacs will have some flexibility.
10:31:07 <shapr> as long as we get the project usable fast enough to keep everyone interested and coding...
10:31:08 <tuomov> s/jed/jed-with-joe-like-bindings/
10:31:16 * Lor is an emacs/jed person.
10:31:26 <Lor> Emacs for serious work, jed for when you just need to quickly edit some file.
10:31:28 <shapr> Lor: come to the darcside!
10:32:23 <Lor> Someone should rewrite emacs in scheme, though.
10:32:32 <shapr> I'm totally hyped that hs-plugins loads itself dynamically so an entire app can be based on a tiny static core.
10:32:35 <Lor> Or some typed language, if they only supported run-time evaluation properly..
10:33:04 <tuomov> loading the dynamic code is a bit slow atm, though
10:33:18 <tuomov> maybe something could be done to make that faster, or maybe not
10:33:34 <Luke> is the idea with dynamic code loading to define some fixed interfaces and reload on one side, a la java?
10:33:37 <tromp> f=O(g) means that as n->inf, f(n)/g(n) is bounded by some constant
10:33:59 <Lor> personally, I'd prefer to say f \in O(g)
10:34:11 <tromp> f=Omega(g) means that as n->inf, f(n)/g(n) is lower bounded by a positive constant
10:34:19 <musasabi> Having a lightweight interpreter which can interface with native code would solve the performance problems.
10:34:23 <Lor> Or even more properly f \in (O(\x.g(x))
10:34:24 <shapr> tuomov: probably can be faster, but imho a workable editor is the most important next step... 
10:34:32 <shapr> I want to switch to hemacs, since that will motivate me to hack ever faster.
10:34:40 <shapr> I just never got into hacking elisp.
10:34:46 <Lor> Good for you.
10:34:49 <Lor> You retain your sanity.
10:35:00 <tuomov> shapr: yes, of course
10:35:21 <tromp> who think Kramnik can win todays game against Leko:-?
10:35:27 * Lor has recently seen too much scheme code that looks too much like elisp...
10:35:32 <shapr> anyway, if we can get SimonM to use hemacs, dynloading will get *really* fast.
10:35:58 <Luke> I promise to contribute a few commands once you guys get the basic edit-display loop up  )
10:36:05 <shapr> :-)
10:37:04 <shapr> I'm not sure if it's limited to fixed interfaces or not...
10:37:20 <shapr> I think that since hs-plugins loads itself, then hs-plugins is the only fixed interface
10:37:29 <shapr> and after that, you get everything anyway
10:37:47 <cedricshock> tromp: those are nice definitions
10:37:47 <Luke> hm, so even today you could hack e.g. HEmacs.hs and reload it while running?
10:37:52 <shapr> I think so
10:37:56 <shapr> but I haven't tried it ye.
10:38:11 <Luke> that sounds very nice
10:38:21 <tromp> those are more or less the standard definitions
10:38:37 <shapr> yes, that's why I skipped out on the idea of a joy scripting language... haskell reached sufficient elisp-ness
10:39:41 <shapr> from HEmacs.hs "-- This is the real main module of HEmacs, and is shared between Main.hs (the static binary), and dynamically loaded by Boot.hs."
10:39:58 <Luke> I should read the paper
10:40:05 <shapr> that looks like a yes
10:40:46 <Luke> if dynamic-load implies dynamic-reload
10:40:50 <tromp> some1 rewrote emacs in haskell?
10:41:06 <shapr> tromp: project started as of three(?) days ago... want to join in?
10:41:25 <tromp> a bit too ambitious for my taste:(
10:41:31 <shapr> Luke: actually, hs-plugins has make() which is sort of like calling ghc --make every time
10:41:42 <tromp> i'm a small time haskell programmer:(
10:41:47 <shapr> tromp: me too...
10:42:12 <tromp> emacs in haskell is a 50manyear project
10:42:23 <shapr> maybe that's only if you do it in C and elisp.
10:42:47 <tuomov> you don't need all the emacs features
10:42:52 <tuomov> the features in jed are a good start
10:43:01 <shapr> the features in notepad are a good start ;-)
10:43:37 * shapr rebuilds his local copy of hemacs
10:43:55 <tromp> if i had that kind of spare time, i think i'd rather work on a Go program:)
10:44:19 <shapr> I've had it with some emacs warts...
10:44:30 <tromp> ah that explains
10:44:32 <shapr> The biggest wart that really pisses me off is RMS.
10:44:38 <tromp> i never got annoyed by emacs
10:45:23 <shapr> I use emacs for email, usenet, irc, shell, music player, and lots more
10:45:38 <shapr> I used to use it for a browser too, but the single-threaded-ness became too painful.
10:46:18 <Luke> don't say too many bad things about Emacs. you may need to come crawling back to it ;-)
10:46:26 <shapr> could be
10:46:35 <shapr> but I tend to say these same things on #emacs and #xemacs
10:46:54 <Luke> Emacs may be unkind to you in the afterlife :)
10:46:56 <shapr> the whole gnu emacs vs xemacs split is another irritant.
10:47:11 <shapr> RMS should really kiss and make up with the xemacs guys.
10:47:20 <shapr> the community is splintering
10:47:39 <shapr> people are leaving for eclipse
10:47:42 <Luke> but anyone, I'm off - let me know when the most basic editing is there!
10:48:25 <shapr> right, enough soapboxing, time to put my code where my mouth is...
10:48:25 <phubuh> eclipse is decent for anything but java editing now? :)
10:48:54 <shapr> phubuh: This evil anti-Java comment has been censored by JDEE.
10:50:11 <G|u][> hi all, I wanted to ask if there is a nice IDE that does syntax coloring under windows for haskell [I tried .edit and jedit is there anything else that you guys use]?
10:50:22 <shapr> there's emacs
10:50:25 * shapr strangles self
10:50:47 <shapr> emacs, vim, not sure what else...
10:50:53 <bourbaki> aha finally :) now i just need to adapt all the vectors to lists :)
10:52:05 <bourbaki> or is the first element of an arbitrary vector?
10:52:05 <tuomov> jed, but it can't handle both meanings of '
10:52:49 <phubuh> what's the other meaning?  i know of infixization
10:53:04 <phubuh> er, no, that's ` :-)
10:53:06 <tuomov> characters and part of a name
10:53:46 <tuomov> or, well, DFA syntax highlighting might be able to handle that, but it is broken in some other ways
10:54:02 <tuomov> but the older simple rules that work otherwise can't handle it
10:54:24 <tuomov> I'm not sure, but I think it could've been that dfa couldn't handle multi-line stuff
11:02:51 <Philippa> d'oh, was going to mention textpad to him
11:09:41 <shapr> does ncurses work on win32?
11:10:21 <tuomov> in cygwin at least..
11:11:58 <tuomov> http://pdcurses.sourceforge.net/
11:12:14 <bourbaki> can you test if something is a tuple?
11:12:34 <tuomov> haskell is statically typed so no?
11:12:38 <tuomov> or what do y ou mean?
11:12:46 <bourbaki>  (erup ( (pure (weight 1)) &&& (pure (weight 2)) &&& (pure (weight 3)) )) 2
11:12:48 <bourbaki> ((2.0,4.0),6.0)
11:13:34 <bourbaki> when i want to build the sum of the output with arbitrary many &&& applied functions i need some kind of recursions
11:14:45 <bourbaki> if i could check if the first element is a tuple or a single value i just could use first and second constantly otherwise ill have to rewrite it all to something list like
11:14:51 <Cale> You want  data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:15:04 <bourbaki> ok so rewrite
11:15:13 <bourbaki> data    Product  a   = Nil | CP a (Product a)
11:15:20 <bourbaki> is what i will use and then some conversion from that to list
11:15:32 <Cale> that is a list
11:15:47 <bourbaki> yes i want a list for elements
11:16:04 <bourbaki> ((2.0,4.0),6.0) =~ (CP (CP 2 4) 6)
11:16:13 * goron thinks Mono is even less userfriendly than Unix is.
11:16:20 <bourbaki> ((2.0,4.0),6.0) =~ (CP (CP (CP 2 4) 6) Nil)
11:16:28 <monochrom> me not user friendly?
11:16:32 <bourbaki> :)
11:17:07 <stepcut> I had mono once, it sucked
11:19:05 <monochrom> regarding bloatware that I don't use: someone should *pay me* for installing it on my disk.
11:19:16 <tuomov> unix is user-friendly. it's just selective about its users.
11:19:30 <CosmicRay> heh
11:20:10 <monochrom> if I find a piece of software useful, I don't mind.
11:20:17 <goron> tuomov: I had the exact quote in my mind, when I wrote it.
11:20:22 <monochrom> it all comes down to my utility function.
11:20:46 <goron> monochrom: What's your utility function? :)
11:21:06 <monochrom> I don't know it completely.  But I know part of it.
11:21:09 <goron> tuomov: It's "picky", btw.
11:21:24 <goron> monochrom: Share it with us :)
11:22:05 <monochrom> Well, I have described one aspect of it, regarding software that I don't happen to use.
11:22:56 <monochrom> Another aspect, regarding doing other people's homework and even taking other people's exam.  If you pay me US$10^some large number, I don't mind doing it.
11:23:25 <goron> monochrom: And you think you *can* do my homework?
11:23:49 <monochrom> Basically I charge an arm and a leg because it is insurance against ruining my reputation as an honest academic. :)
11:24:54 <goron> monochrom: That's probably the most wise you could say, except for that you don't lower yourself to such activities :)
11:25:11 <monochrom> With US$10^N I'm even willing to take your course and learn your stuff.
11:25:39 <tromp> for N>2
11:26:44 <goron> Is this E-Bay?
11:27:08 <monochrom> Once a group of friends asked me to take a course with them so I could explain it to them.  (No they did not want to cheat; they simply liked the way I explained things.)
11:27:17 <monochrom> The course was not useful to me.
11:27:46 <goron> monochrom: What was the course about?
11:27:53 <stepcut> goron: ethics
11:27:59 <shapr> my friends ask me to take courses so they can watch me annoy the teachers.
11:28:04 <shapr> hi LittleDa1 
11:28:12 <kristnjov> and my friends don't ask me to take courses with them, cause i'm an ass
11:28:12 <LittleDa1> hi shapr
11:28:19 <monochrom> Some funny 3rd year statistics course.  I couldn't care less about statistics beyond mean and stddev.
11:28:20 <shapr> kristnjov: but you can get better!
11:28:52 <shapr> being nice is a skill, and a handy survival tactic.
11:29:11 * shapr goes back to learning curses
11:30:04 <heatsink> there's haskell curses module?
11:30:18 <monochrom> So I quoted the price: 2*course_fee.  one course_fee because I should be reimbursed for a course I didn't need.  another course_fee because I would be sacrificing my time.  It's a fair price, no?
11:30:52 <shapr> heatsink: several... I'm just learning the one HEmacs is using.
11:30:54 <monochrom> I even offered: "look, you're a group, you can split the cost."
11:31:04 <goron> Is Curl ported to Haskell?
11:31:08 <monochrom> But they still refused.  I think they're cheap.
11:31:17 <stepcut> monochrom: heh
11:31:27 <shapr> goron: no, but darcs has a nice binding to libcurl
11:31:47 <goron> shapr: Via FFI?
11:32:07 <shapr> I assume so.
11:32:23 <goron> shapr: :)
11:34:54 <goron> shapr: How does darcs scale up? Is there some maximum of patches? Because otherwise, it would need O(number of patches) and that's quite a bit for systems that evolve over the years.
11:36:03 <shapr> tuomov: e_* in UI.hs means editor function? what do you think about the widgets in Ginsu's Screen.hs ?
11:36:14 <kristnjov> :r
11:36:18 <kristnjov> uhh wrong window :P
11:36:25 * shapr quickly reloads kristnjov's brain
11:36:28 <kristnjov> :/
11:36:32 <kristnjov> reload my alt+tabbing
11:36:50 <tuomov> shapr: I haven't looked into ginsu in that detail
11:37:05 <tuomov> Riot's UI just a quick&dirty hack that does what it needs to do
11:37:42 <shapr> goron: right now the only scale problem in darcs is that importing the entire linux kernel source at the same time takes many hours, but importing it in just two pieces takes significantly less than half of the many hours...
11:37:49 <tuomov> but yeah, curses's windows should perhaps be used
11:37:56 <tuomov> in a more extensible ui
11:37:57 <shapr> goron: but I think that won't be too hard to fix
11:38:20 <monochrom> Interesting.
11:39:08 <shapr> goron: anyway, david has ideas on how to fix it (and I have other strange ideas for fixing it) but david doesn't want to start tuning the code before 1.0 is released.
11:39:35 <goron> shapr: "In just two pieces"? (This feature is not existing yet?)
11:39:51 <shapr> I think David has rightly decided that an inefficiency that only shows up when you import 300MB of source at once, and can be solved by importing in smaller pieces is not worth fixing before the rest of darcs is stable.
11:40:04 <shapr> goron: source importing is not of linear complexity
11:40:22 <shapr> begrijp?
11:40:51 <tromp> that's dutch
11:40:52 * shapr learned 'begriper' in swedish recently and has a hard not saying 'begrijp' instead
11:41:07 <goron> shapr: Time-complexity or space?
11:41:15 <shapr> time complexity
11:41:39 <goron> shapr: What's the complexity?
11:42:00 <shapr> so it may take eight hours to import 300 mb of source at once, but only three hours to import that same source in two 150 mb chunks.
11:42:50 <shapr> Anyway, I think swapping the patch commuting code to using arrows might fix that, but I think David has some other ideas.
11:43:13 <shapr> Since I have been unable to write even one megabyte of source before importing into darcs, this has not been a problem for me.
11:43:38 <shapr> goron: don't know the exact complexity
11:43:46 <shapr> check the darcs mailing list, various discussions there
11:44:09 <shapr> btw, darcs gets more list traffic than all the other haskell lists combined, I think it's nearing killer-app status.
11:44:18 <goron> shapr: I just got it from Darcs, and applied the patches, so it's pretty fast for Darcs itself.
11:44:36 <shapr> and darcs has a *lot* of patches :-)
11:44:49 <monochrom> I agree with David's decision.  No major change at the last minute.
11:45:04 <LittleDa1> are there any free sf-like sites that use darcs?
11:45:24 <shapr> There was gforge.scannedinavian.org... but it died a horrible death.
11:45:32 <LittleDa1> why?
11:45:58 <shapr> the CPU fan seized up, I have nearly black heatsink with burnt-on bits of cpu
11:46:36 <LittleDa1> wow, that's pretty horrible
11:47:14 <shapr> gforge.scannedinavian.org  may return one day if there's interest.
11:47:58 <shapr> though my bandwidth bill is pretty high these days...
11:48:13 <LittleDa1> oh, that website is yours
11:49:05 <shapr> yup, *.scannedinavian.{org,com,net} is a weenie 600MHz P4 with 768mb of ram and ... three? leftover harddrives.
11:50:10 <shapr> feel free to send hardware donations... ;-)
11:51:08 <Oejet> shapr: Begriber is begriper in Danish.
11:51:14 <shapr> neat
11:51:26 <bourbaki> nighto
11:51:30 <shapr> g'night bourbaki 
11:51:42 <tuomov> you don't need a special site for darcs
11:51:49 <tuomov> any webspace will do
11:51:55 <tuomov> and that's one of the greatest features of it
11:51:56 <LittleDa1> tumov: but I don't have any webspace
11:52:11 <shapr> LittleDa1: do you have a public IP and dyndns?
11:52:16 <shapr> that'll work too
11:52:23 <tuomov> does sf allow installing software?
11:52:44 <tuomov> and even if it doesn't, you could still always rsync a local repo instead of darcs push
11:52:50 <shapr> right
11:52:52 <musasabi> There is a service here offering 1gb of space (for static content) with 100gb traffic limit with 5e/month.
11:53:09 <LittleDa1> shapr: no, I have a firewall that I dont' know how to get around
11:53:31 <shapr> LittleDa1: firewall on your PC? what's your IP?
11:53:42 <tuomov> I'm also firewalled
11:53:46 <LittleDa1> shapr: I don't know. It's a hardware firewall
11:54:07 <tuomov> (no, this machine isn't, but my home machine is)
11:54:08 <shapr> can you /msg me a traceroute to some public IP?
11:54:21 <LittleDa1> umm... how do I do that?
11:54:28 <shapr> are you using linux?
11:54:42 <shapr> windows?
11:54:42 <LittleDa1> yeah
11:54:44 <LittleDa1> linux
11:55:05 <shapr> ok, with linux, open a terminal, and do 'traceroute www.haskell.org' (just a random choice on my part)
11:55:18 <shapr> the first three or four lines are the interesting part.
11:55:36 <Oejet> LittleDa1: Or try myip.dk
11:55:54 <LittleDa1> bash: traceroute: command not found
11:56:03 <shapr> LittleDa1: try /sbin/traceroute
11:56:10 <tuomov> or /usr/sbin/traceroute
11:57:10 <shapr> Oejet: I don't think myip.dk will notice 10.*.*.* or 192.168.*.* 
11:57:15 <LittleDa1> nope, neither of those work. I'll get it off of apt
11:59:43 <goron> What does #include <curl/curl.h> *exactly* mean? Is it just:"look in the subdir called curl of the current folder(or somewhere in a special compiler path) for a file called curl.h and include(copy) it? 
12:00:33 <tuomov> include first <path entry>/curl/curl.h
12:01:58 <LittleDa1> I think my IP address is 10.108.160.1
12:02:16 <LittleDa1> how do I use that to set up a website?
12:02:29 <tuomov> you don't, it's grey
12:02:34 <shapr> install apache, install a dynamic dns client
12:02:37 <Philippa> goron: look for a file curl/curl.h under wherever the hell your compiler keeps its library headers. #include "curl/curl.h" is different
12:02:42 <goron> First like in: suppose you have /firstdir/curl/curl.h and /snddir/curl/curl.h, it's the first, or "include it, before you do anything else?
12:02:44 <shapr> that assumes your port 80 is not blocked by your ISP
12:03:04 <Philippa> goron: in that case it's ambiguous and probably down to the compiler
12:03:11 <shapr> Anyone have thoughs on the similarities between ropes and ShowS?
12:03:52 <goron> Philippa: So you say "somelib.h" and <somelib> are not equivalent?
12:04:21 <Philippa> goron: bingo
12:04:26 <goron> Philippa: <somelib> are compiler directories?
12:04:31 <Philippa> sort-of
12:04:58 <Philippa> the <> mechanism's used for all the standard libraries etc where the user's not supposed to have to know where exactly the implementation keeps it
12:05:05 <Philippa> there might not even be a corresponding file
12:05:29 <goron> Philippa: But CURL is not that standard, imo.
12:05:41 <goron> Philippa: stdio, ok.
12:06:05 <Philippa> right. Most compilers will have a set of dirs they look up lib headers in, but all of that's implementation-specific AFAIK
12:06:26 <Philippa> = no standard about what to do if there's more than one valid match
12:06:42 <Philippa> (I'd imagine most'll just use the first they find, but I'd hate to rely on it)
12:07:28 <tuomov> you have to rely on it to do anything
12:07:58 <Philippa> well yeah
12:08:01 <Philippa> shit happens :-)
12:08:08 <tuomov> but yeah, the c build system is totally broken
12:08:14 <goron> Philippa: So if I create some library, there's some interface at the compiler side, so that I can install the  libs header in some "compiler dir"?
12:08:21 <tuomov> there's no easy way to choose exactly the version of a library you want
12:08:33 <Philippa> best I can really offer is "don't do that then" - don't have two valid curl\curl.h files where the compiler'll find 'em
12:09:11 <Philippa> goron: er, more commonly you'd tell the compiler your stuff's in whatever directory you dumped it in AFAICT. Certainly that's how stuff tends to work in windows
12:09:50 <shapr> speaking of interesting build systems... kosmikus pointed me to maak recently.
12:10:10 <stepcut> tehehe, my pipes library is shaping up nicely
12:10:13 <goron> Philippa: I meant why curl is referred to as <curl/curl.h) ("compiler dir") and some are referred to as "some/somelib.h"
12:11:12 <shapr> stepcut: have you seen System.Process that'll be in 6.4 ?
12:11:13 <stepcut> now I can do stuff like => runProcess $ ls ["-l"] -|- ioProcess (interact reverse) -|- cat ["-n"] |> "/tmp/test"
12:11:35 <stepcut> shapr: no, I have been meaning to get/build ghc-cvs so I can play with GADT's though...
12:12:00 <stepcut> is there a webcvs frontend to ghc-cvs ?
12:12:01 <shapr> simonM linked to a 6.2.2 compatible System.Process
12:12:06 * shapr dunno
12:12:27 <shapr> I usually play with whatever Igloo is kind enough to package in the ghc-cvs deb.
12:12:44 <stepcut> shapr: this one -> http://www.haskell.org/~simonmar/process/System.Process.html 
12:12:44 <stepcut>  ?
12:12:59 <shapr> that's the docs for it.
12:13:09 <stepcut> Does Igloo have a ghc-cvs deb with the GADT stuff ?
12:13:13 <shapr> don't think so
12:13:24 <goron> Philippa: Another way to put it is: suppose I can refer to something with "somelib.h", how can I transform it so I can use it in <somelib> syntax?
12:14:31 <stepcut> I am going to try to publish something about my pipes stuff in the next month or so
12:15:31 <shapr> cool, I'd like to see that
12:15:59 <stepcut> its pretty neat, especially when it comes to error handling 
12:16:32 <shapr> ginsu needs refactoring >:-(
12:16:40 <shapr> too much crap in Main.main
12:17:21 <stepcut> heh
12:17:24 * shapr wants to play with Screen.hs in ghci
12:19:06 <Philippa> goron: that's platform-specific
12:19:19 <Philippa> (oh, and I almost certainly don't know for your platform)
12:19:54 <musasabi> I have simple code doing fork + exec + waitpid with the current api. It is quite simple, but won't probably work on windows.
12:20:17 <musasabi> (and the stdin/out redirection too)
12:23:27 <goron> Philippa: Ok, thanks. 
12:24:01 <bourbaki> bk
12:25:33 * musasabi waits anxiously for the 6.4 release
12:28:17 <Philippa> goron: sorry, that's kinda the point I'd been trying to make. You see why tuomov and I think this is broken?
12:29:32 <goron> Philippa: Yeah. I am glad Cabal is proposed and supported. 
12:33:42 <stepcut> anyone know a good resource for making your website 'blogger' friendly. Stuff like how to add 'Live Bookmarks' and 'permalinks' and stuff ?
12:39:15 <kristnjov> stepcut, isn't there such a thing in firefox?
12:40:01 <stepcut> kristnjov: right, but how do I make sure my site content is doing what it should so that firefox can find the 'live bookmarks'?
12:40:09 <kristnjov> dunno :P
12:40:19 <stepcut> I can look up the things I have heard about, but I wonder what other things I should be doing that I don't even know about 
12:41:16 <shapr> there's some RSS button in firefox
12:41:20 <kristnjov> yes
12:41:24 <shapr> someone asked me to add it to the DarcsWiki
12:41:31 <shapr> my firefox doesn't seem to have it though...
12:41:45 <stepcut> shapr: what firefox version do you have ?
12:41:51 <CLxyz> it wasn't in the default setting iirc
12:41:56 <CLxyz> s/setting/installation
12:42:15 <shapr> 0.9.3
12:42:22 <kristnjov> 1.0 is out
12:42:22 <shapr> how do I turn it on?
12:42:30 <kristnjov> or 1.0PR
12:42:36 <stepcut> shapr: trying going to slashdot.org and see if there is an orange RSS icon in the bottom right of the browser
12:42:55 <shapr> nope
12:43:29 <stepcut> hrm, perhaps you just need to upgrade to 1.0
12:43:45 <stepcut> I don't think I did anything special 
12:43:46 <bourbaki> whats the name for the flatten fn in haskell for lists?
12:43:55 <raboof> running a functional program is basically just doing graph reduction. Now when the program waits for input, e.g. user input or a modal dialog, does the graph reduction continue in the background?
12:43:57 <kristnjov> i didn't change any settings either
12:44:03 <raboof> (if i understand correctly, that is ;))
12:44:49 <shapr> bourbaki: concat?
12:44:58 <bourbaki> shapr: sec
12:45:13 <Philippa> raboof: depends very much on the language in question - in Haskell, "get some input" is typically a node reduction in itself, so if it blocks nothing more can carry on in that thread 'til some input's available
12:45:35 <bourbaki> shapr: no
12:45:47 <musasabi> bourbaki: that is impossible.
12:45:54 <bourbaki> shapr: what i search for is x [1,[2,3]] |-> [1,2,3]
12:46:00 <musasabi> bourbaki: what is the type of that?
12:46:01 <shapr> oh
12:46:12 <TheHunter> bourbaki: [1,[2,3]] doesn't typecheck
12:46:21 <bourbaki> and that just on first level not totaly recursive to the end of all branches
12:46:36 <musasabi> bourbaki: you cannot have the flatten you want in haskell as you cannot have those lists you want.
12:46:40 <bourbaki> TheHunter: ? whats wrong with that?
12:46:53 <TheHunter> @type [1,[2,3]]
12:46:54 <lambdabot> [1,[2,3]] :: forall t. (Num [t], Num t) => [[t]]
12:46:57 <raboof> Philippa: but in theory there wouldn't be anything against continuing (some) graph reductions of the rest of the program while this node is 'blocked'? 
12:47:00 <musasabi> bourbaki: of course most things like trees have their own flatten functions.
12:47:03 <bourbaki> ouch ok
12:47:30 <bourbaki> dang
12:47:41 <TheHunter> @type ['a',['b','c']]
12:47:42 <lambdabot> bzzt
12:48:14 <TheHunter> bourbaki: are you trying to make heterogenous lists?
12:48:18 <Philippa> raboof: in theory, sure. Might be non-trivial to express a decent set of rules about when to reduce though
12:48:23 <bourbaki> TheHunter: http://paste.phpfi.com/33445
12:48:40 <bourbaki> TheHunter: i think i will need that cause have a look at the last line in that code
12:48:48 <Philippa> essentially because you're trying to do strictness analysis
12:48:55 <bourbaki> TheHunter: and do something like that "fn (1,1)"
12:49:03 <Philippa> (and if your functional language is strict, you've evaluated everything else before trying to get input, right?)
12:49:15 <tuomov> hmm.. if the processor supported massive threading without performance penalties
12:49:18 <bourbaki> i get a nested vector back and i need to convert that to lists
12:49:26 <tuomov> and this could take advantage of multicore processors..
12:49:45 <tuomov> you could just always have each reduction done in a separate thread
12:49:48 <bourbaki> if i convert that to lists i cant use the operators like &&& the same way anymore since the reslt was a list with multiple types
12:49:50 <Philippa> yep
12:50:02 <shapr> tuomov: seen parr and nested data parallelism?
12:50:13 <tuomov> no.. I'm an n00b
12:50:19 <Philippa> I'm not gonna give it much more thought myself though, better brains than I've burnt out on it and it's not something I'm overly interested in for practical purposes just yet
12:50:26 <shapr> riot != n00b
12:50:47 <shapr> how about journeyman?
12:50:50 <shapr> that's where I count myself...
12:50:50 <TheHunter> bourbaki: you can get a function that maps (1,(2,3)) to [1,2,3] if you use faked dependently-typed style programming, if that's really what you have to do.
12:51:04 <tuomov> maybe that then
12:51:13 <bourbaki> TheHunter: but what if the elements in the vector are not of the same type?
12:51:22 <shapr> or you can try the belt color rating on @wiki HaskellIrcChannel
12:51:28 <musasabi> bourbaki: you could have things like data HCons a b = hcons a b... (see the HList paper)
12:51:29 <bourbaki> TheHunter: and it has to work for arbitrary length vectors
12:51:44 <bourbaki> oh good idea :)
12:51:51 <TheHunter> so basically, you're searching for heterogenous lists.
12:52:10 <shapr> musasabi: hei, did you get parr built and working with 6.2.1?
12:52:19 <bourbaki> TheHunter: yes and i need to embed them into my implementation of that arrow stuff
12:52:40 <kristnjov> what's faster?: boolToStr False = "False" or boolToStr False = show False?
12:52:42 <Philippa> shapr: I'm too unsure about what counts as "proficient" to go for the belt ratings
12:52:48 <TheHunter> data List a b = Cons a (List b)
12:52:53 <shapr> they're just for fun anyway...
12:52:56 <musasabi> shapr: isn't parr part of the tree? It appears to be currently quite buggy though.
12:53:08 <bourbaki> if i get that working in can build my neural networks with my arrows in a snap
12:53:13 <shapr> huh
12:53:14 <TheHunter> bourbaki: another possiblity would be to use existential types.
12:53:18 <bourbaki> and also the decision tree stuff
12:53:42 <bourbaki> TheHunter: hm what would be the tradeoff? or gain over the list?
12:54:02 <TheHunter> bourbaki: i think existentials fit better.
12:54:12 <bourbaki> TheHunter: ok
12:54:20 <TheHunter> this dependently typed stuff gets awkward very quickly
12:54:28 <bourbaki> TheHunter: isnt there a fault ? 21:57 < TheHunter> data List a b = Cons a (List b)
12:54:45 <TheHunter> bourbaki: yes, that's wrong
12:55:04 <bourbaki> data List a b = Cons a (List b _) ?
12:55:08 <TheHunter> data List a b = Cons a b
12:55:25 <bourbaki> but thats not recursive
12:55:25 <musasabi> bourbaki: the idea is to have the list via a typeclass.
12:55:36 <TheHunter> meant to be used like List Float (List Int (List (Int -> Int))))
12:55:53 <TheHunter> List Float (List Int (List (Int -> Int))) Empty)
12:55:53 <bourbaki> ah ok
12:56:05 <TheHunter> data Empty
12:56:33 <bourbaki> *think think think*
12:56:40 <Boegel> hello everyone
12:56:44 <TheHunter> http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
12:56:47 <musasabi> bourbaki: the HList paper explains quite intuitively (and they have the library).
12:56:51 * shapr smells smoke
12:56:51 <shapr> bourbaki: you're thinking too hard!
12:56:54 <musasabi> But existentials *are* easier.
12:56:55 <Boegel> sorry for my quick leave this afternoon
12:57:03 <musasabi> hello Boegel 
12:57:21 <bourbaki> heh
12:57:29 <TheHunter> @hawiki ExistentialTypes
12:57:29 <lambdabot> Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands
12:57:34 <TheHunter> @wiki ExistentialTypes
12:57:34 <lambdabot> http://www.haskell.org/hawiki/ExistentialTypes
12:57:36 <bourbaki> musasabi: was it in the paper that TheHunter gave me?
12:57:39 <bourbaki> ah ok
12:58:05 <musasabi> bourbaki: http://homepages.cwi.nl/~ralf/HList/ (but try the existentials first)
12:58:44 <bourbaki> do you think that was a good addition to arrows in the sense what i want to do?
12:59:47 <musasabi> I don't consider myself understanding arrows very well yet..
12:59:51 <TheHunter> what you want to do definitly needs existentials.
13:00:02 <bourbaki> TheHunter: ok ill read upon that
13:00:07 <TheHunter> probably rank-two polymorphism, too
13:00:30 <bourbaki> im really happy cause if i have solved that i can do the first test with that stuff for my usage
13:01:50 <bourbaki> TheHunter: for that collapsing stuff of sub networks ill need a handfull of extra "folds" ie a neural net fold and a decision tree fold and so on i guss but im not sure about that yet that is if there is a single semantic in that network
13:03:12 <TheHunter> actually, existentials won't help with the last line
13:03:41 <bourbaki> dang i need something really flexible ... ill read that stuff and then decide
13:04:58 <Boegel> I'm have to go again :)
13:05:01 <Boegel> sorry guys :p
13:05:04 <bourbaki> bye bye
13:05:05 <Boegel> bye ;)
13:08:59 <bourbaki> TheHunter: ok that way i would be able to somehow build a flexible cartesian product which has capacilities of a list but how can i build a flexible direct sum?
13:09:12 <stepcut> If my data type has only a single constructor, should I just use newtype instead ?
13:10:46 <Lemmih> Should the new haskell library page look like the OCaml hump ( caml.inria.fr/humps/caml_latest.html ) or like the current library page ( www.haskell.org/libraries/ )?
13:11:46 <bourbaki> is 
13:12:41 <bourbaki> Either a Either b c = Trither a b c ? where Trither a b c = A a | B b | C c ?
13:14:09 <TheHunter> you can define such types, but that works only for arities you explicitely specify
13:14:39 <bourbaki> what i mean is if thats the same then i wont need to thing about a way to make a more flexible thing for that
13:14:59 <TheHunter> no, it's not the same.
13:15:01 <bourbaki> cause imagine i had an automation with 3 possible different halting states and output
13:15:19 <bourbaki> then i need to build the sum of these 3 nodes as an output
13:16:06 <bourbaki> hm ok then id need to do that also with a new kind of thing :(
13:16:50 <TheHunter> You should probably fix some associativity and use it like Either (Either a b) c, ...
13:17:17 <TheHunter> and (a,(b,(c,()))
13:17:34 <bourbaki> if Either (Either a b) c = Either a (Either b c) ...
13:17:43 <TheHunter> no
13:17:57 <bourbaki> but if the sum was direct it would make no difference
13:18:29 <bourbaki> but i see the problem ...
13:18:45 <bourbaki> in the one case its a left branching and in the other a right brancheing ...
13:19:19 <bourbaki> maybe ill use the editor to just let it generate the right types
13:20:28 <bourbaki> that way it was not entirely simple haskell anymore but a bit of a haskel code gen system ... but i dont really want that kind of thing
13:21:35 <TheHunter> maybe typeclass tricks work. If you've got a fixed set of "base types" and of course -fundecidable-instances and friends.
13:22:43 <bourbaki> ... hm *sniff sniff* its like with the donkey and the carrot
13:23:00 <bourbaki> always when i think im near the carrot it moves a bit further
13:23:15 <bourbaki> in the end ill have my own compiler ;)
13:24:01 <shapr> maybe you'll find a big pot of carrots over the rainbow....
13:24:07 <bourbaki> :)
13:24:12 <bourbaki> at the end yes ;)
13:24:25 <TheHunter> if there's some way your interface doesn't mention sums and products explicitely, you'll get around all that.
13:24:35 <bourbaki> well i need that
13:24:42 <bourbaki> cause i want all my stuff to be a topos
13:24:49 <bourbaki> and then i need the limit and colimit of anything
13:25:16 <TheHunter> bourbaki: topos will be quite hard
13:25:41 <bourbaki> TheHunter: why?
13:25:45 <TheHunter> it means your stuff should almost behave like a set.
13:26:10 <bourbaki> it means that its cartesian closed and that there always has to be a limit
13:26:14 <TheHunter> for example, even the Kleisli category for the Maybe monad doesn't have products anymore, not even weak ones.
13:27:07 <bourbaki> what is that cat?
13:27:32 <bourbaki> oh and i need an exponent for each object right?
13:27:33 <TheHunter> Objects like usual haskell, morphisms from a to b: a -> Maybe b
13:28:09 <TheHunter> composition (f <<< g) x = case g x of {Nothing -> Nothing; Maybe y -> f y}
13:28:41 <shapr> ah poo
13:28:57 <shapr> curses flips out with emacs' ghci
13:29:46 <Philippa> heh
13:30:17 * shapr wants a flipping buffer!
13:30:26 <TheHunter> sure, you can do all this stuff, but you'll probably have to accept the fact that the things you get aren't real exponent, only quite close to the CT thing.
13:30:48 <bourbaki> yeah i think it will surfice for what i have in mind
13:32:18 <TheHunter> otoh, starting from some primitives and only adding the absolutely necessary stuff to ensure the categorical properties will indeed give you something which is cc, i'm not an expert.
13:33:11 <bourbaki> the problem is i need that stuff i stated above already for the implementation for a neural net
13:35:21 <bourbaki> heh nice quit message ;)
13:35:48 <shapr> @index sleep
13:35:48 <lambdabot> System.Posix,System.Posix.Unistd
13:36:00 <bourbaki> haha
13:37:32 <bourbaki> @index bourbaki 
13:37:33 <lambdabot> bzzt
13:37:37 <bourbaki> pardon?
13:38:39 <TheHunter> @seen anything
13:38:39 <lambdabot> I haven't seen anything
13:39:03 <bourbaki> :)
13:39:23 <bourbaki> shapr: maybe you could implement something in that bot like i did in my lisp bot
13:40:15 <shapr> ?
13:40:27 <shapr> lambdabot welcomes new plugins and new code...
13:40:35 <shapr> @index installHandler
13:40:35 <lambdabot> System.Posix.Signals,System.Posix
13:40:40 <bourbaki> sec ill search the paper
13:41:39 <bourbaki> http://codemages.sourceforge.net/
13:41:48 <bourbaki> if you havent seen my super funny site yet ;)
13:42:07 <bourbaki> http://ai-depot.com/Articles/49/Semantics.html
13:42:32 <bourbaki> and thats my nl thingy there is also a lisp implementation shouldnt be hard in haskell either maybe even with monads
13:44:04 <shapr> Lemmih: if it works at all, I'll be thrilled, look'n'feel is for version 2 :-)
13:44:14 <bourbaki> i think ill add a bar to that llama sign to make it look like a lambda
13:44:25 <shapr> you could write a plugin for lambdabot 
13:44:49 <bourbaki> first i need to write my other thing that has a priority of 1
13:45:38 <stepcut> shapr: but what pluggins is lambdabot in need of ?
13:46:10 <shapr> well, I need to fix the factoid plugin
13:46:18 <shapr> probably a help command
13:46:23 <shapr> switch to hs-plugins
13:46:29 <shapr> hm
13:46:35 <shapr> that's all I can think of at the moment.
13:46:39 <stepcut> yeah...
13:47:02 <shapr> fix HaddockModule to only return modules where the command is really exported
13:47:05 <stepcut> I am thinking off modifying the quotes module so that you can get quotes by index
13:47:08 <stepcut> @arr 5
13:47:08 <lambdabot> I'll keel haul ya fer that!
13:47:09 <shapr> clean out all the tabs and use spaces instead
13:47:13 <stepcut> or something like that
13:47:14 <shapr> ah, good idea
13:47:56 <shapr> write a type-sig search
13:47:59 <shapr> that would be fun
13:48:09 <shapr> an epigram plugin could be nifty
13:48:14 <stepcut> or maybe lambabot needs a sidekick, so he can tell knock-knock jokes :p
13:48:17 <shapr> haha
13:48:28 <shapr> multi-server support
13:48:32 <shapr> hircules could use that.
13:48:45 <shapr> could try to merge hircules and lambdabot if you're feeling energetic
13:48:47 <stepcut> Someday, I want to make a hatchet plugin for lambdabot, but that is a big project
13:49:09 <stepcut> what is hircules?
13:49:11 <shapr> that's part of THIH, right?
13:49:27 <shapr> http://www.haskell.org/hircules/
13:49:34 <stepcut> hatchet is a more practical version of THIH
13:49:41 <shapr> ah, neat
13:50:09 <shapr> multi-user epigram would be crazy
13:50:36 <shapr> for example, mix ERC and the current epigram user interface for irc-based epigram teaching.
13:50:42 <stepcut> heh
13:50:48 <stepcut> someone was doing a project like that on 
13:50:53 <stepcut> #hprog a while ago
13:51:17 <stepcut> irc + scheme, but it was just a java app (and did not actually use irc)
13:51:23 <stepcut> it was neat though
13:51:52 <shapr> sounds cool
13:51:55 <stepcut> until he blocked me from calling java's gui functions  from scheme :
13:51:56 <stepcut> :(
13:52:01 <shapr> awww
13:52:44 <shapr> man, I want a curses buffer.... but I can't figure out how to get a minimal curses main loop yet..
13:53:15 <shapr> ginsu's Main.hs really needs someone to show up with a brushhook
13:53:21 <stepcut> I am quite excited about this paper "Functional Pearl: Implicit Configurations"
13:53:49 <shapr> where was it mentioned?
13:53:57 <shapr> sounds like a Hughes and Claessan paper.
13:54:17 <stepcut> oleg and Chung-chieh Shan
13:54:20 <shapr> oh, neat
13:54:28 <stepcut> http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
13:54:33 <tuomov> shaprs: see end of riot's UI.hs for a minimal mainloop
13:54:35 <Igloo> shapr: Isn't minstrel an example of what you want?
13:54:36 <tuomov> -s
13:54:40 <shapr> if someone shows up here with just the irc nick "oleg" I'll be terrified :-)
13:54:44 <stepcut> TheHunter meantioned it a few minutes ago
13:54:52 <stepcut> shapr:hah
13:54:56 <shapr> ah, I've been in hack-mode trying to figure this out, not looking at the channel
13:55:22 <stepcut> the paper has a bunch of stuff that is very useful for stuff I have been doing with WASH
13:55:35 <shapr> WASH is too heavy... speaking of the need for brushhooks
13:55:45 <shapr> I'll check minstrel and riot, thanks.
13:55:57 <stepcut> I need a WML generator for WASH too :-/
14:01:03 <opet> anyone do much SQL? any generic SQL book recommendations?
14:01:38 * shapr learned SQL from the postgresql manual and the SQL 92 spec
14:02:01 <shapr> SQL is pretty easy
14:02:28 <shapr> I predict it'll take you less than a day to learn SQL, and less than a year to learn the quirks of your database backend ;-)
14:02:38 <opet> I already do quite a bit of it every day
14:02:48 <opet> but never learned it properly
14:03:20 <shapr> In that case, maybe read the SQL 92 spec, and then the extensions docs for your backend?
14:03:31 <shapr> No one actually implements SQL 92 of course...
14:04:21 <shapr> even so, LIKE is case-sensitive in PostgreSQL, and case-insensitive in MySQL... do you know what the SQL 92 spec says about that?
14:05:10 <opet> no idea :-) this is for SQL Server at work and I have no idea how it does with standards
14:05:14 <opet> badly, I'd guess
14:05:23 <opet> I kind of fell into this database lark
14:05:51 <shapr> opet: alternatively, you could use and hack on HaskellDB for a few weeks, using several different backends at the same time. That'll teach you a lot.
14:06:21 <shapr> HaskellDB rewrites relation calculus ops into SQL, and supports a bunch of backends
14:06:43 <opet> purdy
14:06:55 <shapr> yah, static checking of SQL queries, and higher-order queries...
14:06:57 <shapr> purdy badass...
14:13:42 <cm> hey everyone :)
14:14:46 <shapr> hi cm
14:14:56 <cm> hey shapr :)
14:15:11 <cm> nice posts on LTU
14:16:36 <shapr> thanks
14:17:19 <shapr> nice blog :-)
14:17:45 <Jan_w> what is blog ?
14:18:02 <cm> weblog
14:18:09 <cm> www.lambda-the-ultimate.org in this case
14:18:29 <shapr> cm: actually, I was talking about yours.. I read it awhile back, was wondering if you've actually done anything with FRP
14:18:31 <Jan_w> what does the b in blog stand for ?
14:18:41 <shapr> it's short for 'weblog'
14:18:58 <Jan_w> oh "we"blog :)
14:19:45 <cm> shapr: oh, so the shameless plug of the link to the XML hack was successful ;)
14:19:46 <shapr> cm: btw, I think QuickCheck beats DbC
14:20:24 <cm> QuickCheck is very cool
14:20:34 <shapr> yes, I hacked up a test-first version of quickcheck
14:20:55 <cm> re FRP - haven't done anything with it in own stuff.. just been reading a bit about it
14:21:17 <shapr> I got Yampa Space Invaders to build with 6.2.1 recently, if you want working AFRP sources.
14:21:45 <cm> on an unrelated note, i enjoyed some stuff on your domain (skannedinavian.org or something?)... such as the comic strips :)
14:21:54 <shapr> comic strips??
14:22:02 <cm> hehe
14:22:12 <shapr> *.scannedinavian.{org,com,net}
14:22:23 <shapr> comic strips? oh you mean my blog?
14:22:33 * shapr isn't sure
14:22:52 <shapr> this? http://www.scannedinavian.org/~shae/blog/
14:22:52 <cm> http://www.scannedinavian.org/~shae/americasarmy.jpg ;)
14:22:56 <shapr> oh that
14:22:58 <cm> this ;)
14:23:03 <shapr> it's from Penny Arcade
14:23:22 <shapr> yes, I play  America's Army sometimes.
14:23:32 <shapr> I'm a decent SF sniper.
14:23:59 <shapr> but then I get bored and go back to coding.
14:24:07 <cm> hehe
14:24:07 <shapr> game worlds are too small, their rules are too limited.
14:24:34 <cm> i still enjoy q3a 1-on-1.. haven't played it since i'm in montreal, tho
14:24:59 <shapr> I think virtual pair programming would be more fun as an online game.
14:25:09 <shapr> but hemacs doesn't have VPP features just yet.
14:25:17 <shapr> maybe once it has a buffer...
14:25:25 * shapr grumbles at Screen.hs
14:25:35 <cm> ..at least i've internet at home now
14:25:44 * cm googles for hemacs
14:25:54 <cm> last time i heard about it it was still in consideration, i think..
14:26:11 <cm> if it's hemacs for "haskell emacs"
14:26:19 <shapr> well, there's some code now.
14:26:46 <shapr> I think it's 'darcs get http://www.cse.unsw.edu.au/~dons/hemacs/ '
14:27:09 <bourbaki> why isnt there an editor written in haskell?
14:27:29 <shapr> and the mailing list is http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
14:27:34 <bourbaki> i think it would be cool to have in haskell something like you have in c++ where you can fold lines in the editor
14:27:40 <shapr> bourbaki: HEmacs needs you!
14:27:53 <bourbaki> so you could fold a function to its type or so
14:27:59 <cm> okay, so i need darcs first :)
14:28:14 <shapr> and the post-emacs html archives don't work yet..
14:28:18 <shapr> darcs is really cool
14:29:03 <cm> have it on my linux box back in germany :)
14:29:59 <opet> hemacs? dear god!
14:31:05 <bourbaki> does hemacs look like emacs?
14:31:13 <shapr> right now, hemacs looks like riot
14:31:31 <shapr> but I'm trying to hack up a buffer...
14:32:01 <shapr> the reason hemacs is suddenly worthwhile is that dons got hs-plugins to dynamically load a whole app onto a tiny static core.
14:32:15 <shapr> so now, haskell has elisp-quality interactivity.
14:35:06 <dons> moin
14:35:27 <bourbaki> is there some code for an implementation of a simple s expression lisp in haskell?
14:36:14 <shapr> There's Ashley Yakeley's HScheme, which claims to do all of scheme and a lot more.
14:36:17 <shapr> g'day dons 
14:36:53 <dons> might just get a buffer going by today. i understand most of the ui / curses code now
14:36:59 <dons> lots of new haddock comments
14:37:12 <shapr> I don't understand the curses code :-/
14:37:19 <stepcut> gah! installing a new USB card on interrupt 11 has busted my sound card on interrupt 5 :(
14:37:31 <shapr> Did you see Screen.hs in ginsu? it has some basic curses widget code.
14:37:46 <dons> hmm.. maybe that's what we need. 
14:38:01 <dons> also, how to do this nicely so we can abstract enough to have an easy wxHaskell ui too
14:38:21 <dons> and ... I'd like a command line mode for testing, that doesn't invoke the ui
14:38:25 <shapr> right
14:38:44 <dons> but just does Buffer -> Buffer manipulations
14:38:53 * dons thinks \-sed might live on
14:39:09 <shapr> oboy
14:39:16 <shapr> I've heard about that
14:39:28 <Igloo> ?
14:40:07 <dons> \-sed is a purely functional sed with lambdas I was working on a couple of years back
14:40:18 <Igloo> Ahh
14:40:21 <dons> kind of like a richer unlambda
14:40:31 <dons> or a sane sed
14:40:42 <Igloo> :-)
14:40:49 <dons> but with the appropriate keybindings, hemacs could do this
14:41:15 <cm> wonder whether i'll get darcs to compile on win32
14:41:41 <dons> hmm.. keybindings get "compiled" to hemacs-core functions, which should provide a nice edsl for the editor "machine"
14:41:55 <dons> so multiple keybindings are just multiple parser frontends
14:42:33 <dons> or in scripting mode, you just call the haskell hemacs edsl functions, and libraries, bypassing the key binding shortcuts
14:43:11 <dons> spineless-tagless editor machine..
14:43:54 <stepcut> crap, now win2k is just crashes and reboots the machine on startup
14:45:34 <shapr> dons: each key is a command in emacs, and bound to a function, usually insert-self. you can execute a named function with M-x function-name
14:46:43 <dons> so I'd like all keys to map to underlying functions -- so that writing an emacs, vi or sed binding just means finding the writing mapping from a key to the editor core functions
14:46:50 <shapr> stepcut: ok, I think I finally fixed postfix...
14:47:07 <shapr> right, emacs does it that way.
14:47:27 <shapr> stepcut: I hope :-/
14:47:58 <shapr> I can't figure out how to get my mail server to do the same thing yours does, so it's hard to test it.
14:48:19 <stepcut> shapr: cool, I will try again in a bit
14:49:14 <dons> hemacs_eval $ let parse_vi (Cmd ":wq") = WriteFile <> Quit
14:49:21 <stepcut> damnit, now win2k does not even boot in safe mode
14:50:00 <dons> or: let parse_vi (Cmd ":wq") = do writeFile ; quit
14:50:17 <shapr> dons: or maybe "cmd (':':xs) = vimCommands xs"
14:50:32 <dons> yah, sure.
14:50:48 <shapr> or is it order-dependent in vim? what does :qw do?
14:50:57 <dons> not a command
14:51:19 <shapr> huh
14:51:38 <shapr> I thought it was : to start commands, and each command was a single letter...
14:51:39 <shapr> wow, neat.
14:53:14 <dons> i wonder if we could typecheck editor scripts
14:53:49 <dons> well, certainly can if WriteFile and Quit are actually real Haskell functions
14:54:31 <dons> shapr: while reading the code, can you insert haddock comments for what things do?
14:54:37 <shapr> sure
14:54:42 <dons> that's what I've been doing. hopefully we can get it documented
14:54:54 <shapr> right
14:54:59 <dons> make html should gen the haddocks now
14:55:01 <shapr> have you committed your most recent haddocks?
14:55:14 <dons> not yet
14:55:27 <dons> i've walked through Boot.hs, HEmacs.hs, Curses.hsc and UI.hs mostly
14:55:32 <tuomov> the way bindings are done in riot, the bound scripts would get type-checked
14:55:49 <tuomov> M-x is a more complicated issue then..
14:55:50 <dons> yep, as real Haskell
14:56:11 <shapr> M-x could use eval
14:57:30 <tuomov> I thought I might write a basic line editor for riot (to handle files that have been changed on disk and exporting data) one of these days
14:57:44 <dons> btw, i've got a design for, using eval, in vi-speak: :map toUpper buffer
14:57:46 <tuomov> any ideas on how that should be done if it would be used in hemacs as well?
14:58:12 <dons> what is M-x?
14:58:22 <shapr> it's how you call a function by name in emacs
14:58:45 <shapr> if the function can be interactive, and needs some arguments, it asks for them
15:00:05 <shapr> tuomov: line editor like readline?
15:00:24 <tuomov> yes, but in curses
15:00:45 <shapr> dons: commit your haddocks?
15:00:55 <dons> very soon..
15:00:58 <shapr> ok
15:01:11 <dons> just woke up. 8am here
15:01:15 <dons> coffee on the table
15:01:17 <shapr> heh
15:01:25 <shapr> midnight here, coffee on the table...
15:01:48 <shapr> I hope to have a buffer by 6am
15:02:30 <tuomov> so what's the buffer design now?
15:02:46 <dons> shapr: just something basic, or is it ropes (?)
15:02:55 <shapr> basic at first
15:03:30 <dons> cool. shouldn't be too hard once you get a feel for how UI.hs binds to Curses.hsc, I think
15:04:00 <shapr> tuomov: a string is fine with me, right now :-)
15:04:16 <shapr> then on to more complicated structures once it works at all.
15:08:59 <tuomov> http://modeemi.fi/~tuomov/LineEditor.hs
15:09:06 <tuomov> I thought of that sort of abstraction for the line editor
15:09:18 <tuomov> full buffers could also then be instances of those classes
15:09:38 <tuomov> and one could define bindings for both in a single map
15:10:16 <tuomov> (I may have to turn those routines into IO, depending on how updating is done)
15:11:46 <tuomov> of course, one may want the line editor to also be a proper buffer..
15:12:42 <shapr> it looks good
15:14:23 <tuomov> although, the type of a buffer as seen by scripts could as well be just a typeclass
15:15:05 <tuomov> with the more lower-level operations on the contents there
15:15:48 <shapr> I'd like that
15:15:50 <dons> yep
15:16:26 <shapr> many emacs functions take optional arguments
15:16:34 <shapr> g'day SyntaxNinja, bringert was looking for you.
15:17:19 <SyntaxNinja> hi shapr
15:17:49 <shapr> ginsu's Screen.hs looks like it would be good for a buffer, but it's somewhat entangled with the rest of ginsu
15:18:52 <dons> tuomov: I had to remove some funny chars from some of the files, the sequence appeared as a '| ' on my screen, and corresponds to M-' ', and looks like: ^[[01;34m\a0^[[00m
15:19:06 <dons> haddock didn't like them
15:19:21 <dons> some funny tab?
15:19:37 <tuomov> hmm..
15:19:57 <dons> ascii 160, I think
15:20:17 <bourbaki> ok im off to bed again sleeping trial the 3rd
15:21:12 <Igloo> ascii doesn't have a 160, but that's non-breaking space in iso 8859-1
15:21:41 <tuomov> altgr-space
15:21:49 <dons> yep, not ascii :}
15:21:54 <tuomov> I wonder why ghc doesn't complain
15:21:55 <stepcut> Igloo: do you have debs for ghc with GADT ?
15:22:03 <tuomov> my kb is half broken and altgr sometimes stays down
15:22:19 <Igloo> stepcut: Not yet, but I hope to within a day or two
15:22:30 <stepcut> Igloo: cool, I will check back later then :)
15:22:40 <Igloo> My CVS snapshow from about a day ago builds, which is a good first step  :-)
15:23:23 <stepcut> heh
15:28:16 <dons> tuomov: riot state (Status) is currently threaded explicitly through the program?
15:28:25 <tuomov> yes
15:28:49 <dons> hmm. we can probably do something nice to get rid of the explict threading
15:29:22 <dons> an ioref (I didn't say that..), or a nice monad
15:30:20 <tuomov> I did't know of explicit existential/universal data types when I wrote it, but maybe the a parameter could also be dropped from Status?
15:30:36 <mayhem> 'lo
15:31:23 <dons> maybe, yes.
15:41:42 <dons> shapr: committed
15:46:23 <shapr> yay
15:47:41 <shapr> dons: I think much of UI can be replaced with Screen
15:49:15 <dons> yep
15:49:27 * dons reading the scrollback
15:49:37 <dons> tuomov: we can improve the performance of dyn loading
15:49:47 <dons> one way is to make --export-dynamic work
15:50:00 <dons> so we can statically link in HSbase.o and friends
15:50:12 <dons> that cuts about 1 second off startup time
15:50:38 <stepcut> hoo-ray! I finally upgraded from a usb 1.0+card reader to usb 2.0+card reader --- MUCH faster
15:51:23 <dons> another thing is the new PIC ghc backend Wolfgang Thaller's been working on. that lets use use the C dynamic loader directly, I think
15:51:37 <dons> so there is definitely room to move here
15:59:01 <shapr> is -#include a normal ghc param?
16:01:03 <dons> yep
16:08:22 <shrimpx> how would one suppress ghci's output (info header and prompt) to make it behave like a script interpreter?
16:08:56 <dons> -v0
16:09:16 <shrimpx> sweet
16:09:55 <dons> you can also use runghci for this kind of thing
16:10:13 <dons> runghc, sorry
16:11:11 <dons> #! /usr/bin/runghc
16:11:18 <dons> > main = putStrLn "hello!"
16:11:47 <shrimpx> i don't have a runghc...
16:12:41 <dons> it comes with  6.2.2, at least
16:12:51 <dons> though I think it has been around for about 1 year
16:12:57 <shrimpx> haha lame
16:13:05 <shrimpx> i compiled 6.2.1 like last night
16:14:47 <Igloo> Are you sure about that, dons?
16:15:05 <dons> about?
16:15:11 <Igloo> That it comes with 6.2.2
16:15:28 <dons> $ runghc --version
16:15:29 <dons> The Glorious Glasgow Haskell Compilation System, version 6.2.2
16:15:37 <dons> but maybe it only lives in cvs?
16:15:46 <desrt> oh.  l33t
16:15:48 <desrt> 6.2.2 is out
16:16:14 <dons> I remember simon committed it in perhaps july 2003.
16:17:01 <Igloo> ghc6-6.2.2/ghc/utils/runghc doesn't seem to exist
16:17:16 <dons> yep. it's not in the binary bundle on haskell.org either
16:17:55 <Igloo> Nothing jumps out at me as the problem from the Makefiles
16:18:11 <dons> ah.. utils/Makefile: "We're doing a binary-dist, descend into a subset of the dirs."
16:18:32 <Igloo> Ah, I'd only looked at . and ./ghc
16:19:05 <dons> why wouldn't we distribute runghc in the binary dist?
16:19:26 <Igloo> Although I don't see how hasktags gets into the dist
16:19:34 <dons> or ghc-pkg
16:19:37 <Igloo> I assume it was just overlooked
16:24:09 <dons> ghc/mk/config.mk says something. but I still can't see how hasktags gets in
16:24:18 <desrt> where is cvsroot on glass?
16:24:55 <dons> /home/cvs/root
16:25:02 <desrt> ah.  excellent.
16:25:25 <desrt> i'm gonna cook up a powerpc/linux binary for 622 and i want it to be elite like the x86 one (with ./configure and everything)
16:25:30 <desrt> is this stuff in cvs somewhere?
16:26:05 <dons> you want to distribute a nice binary package?
16:26:12 <desrt> yes.
16:26:16 <dons> if so, you set BIN_DIST=1 in mk/build.mk
16:26:24 <desrt> oh.  that's quite nice.
16:26:35 <dons> and at the end, make binary-dist project=Ghc
16:26:36 <desrt> then enable maintainer mode and make dist?
16:26:53 <dons> 'maintainer mode'!
16:27:05 <desrt> hm?
16:27:27 <dons> :)
16:27:29 <shapr> stepcut: tried sending to post-emacs?
16:27:44 <desrt> should i build from cvs or from the source tarball?
16:28:13 <desrt> actually, that's a rather dumb question
16:30:25 <desrt> any magic i should give to ./configure?
16:30:37 <shapr> CosmicRay may be interested in ginsu's ErrorLog.hs
16:30:50 <dons> nope. but make sure BIN_DIST=1 is set.
16:31:04 <desrt> k.  thanks for the info.
16:42:59 * shapr figures out Screen.hs
16:44:32 * stepcut high fives shapr and goes to lunch
16:51:32 <shapr> hm, what's up with widgetScroll?
17:03:39 * shapr figures out widgetScroll
17:06:21 <shapr> are the windowing extensions for Curses commonly available?
17:07:54 <dons> you referring to WINDOW type?
17:08:16 <Igloo> Do the BSDs use ncurses these days?
17:08:20 <dons> yep
17:08:31 <shapr> I don't know, tuomov mentioned that windowing extensions might be a good idea
17:08:42 <dons> if it's on openbsd, it's probably everywhere else -- give me something to look for
17:08:47 <Igloo> It's probably reasonable to assume ncurses and pass the buck onto odd people, then
17:08:56 <dons> yep. 
17:09:14 <Igloo> ncurses certainly has a number of extensions to POSIX curses
17:09:39 <Igloo> SIGWINCH magic is one important one that springs to mind
17:10:05 <dons> yep. got that
17:10:40 * dons moves editor actions out of UI.hs
17:11:21 <desrt> you guys ought to do hvim
17:11:30 <dons> hemacs will be hvim
17:11:36 <shapr> Screen.hs has some signalChanged code, but it looks commented out.
17:11:38 <Igloo> hurrah!
17:11:47 <dons> key bindings are just syntax
17:11:49 <shapr> hemacs will also be hjoe/hjed
17:11:58 <desrt> you should definitely call it vihm
17:12:02 <desrt> :)
17:12:14 <dons> it is the editor api/core language that matters. not the keybindings
17:12:19 <shapr> right
17:12:28 <desrt> they have different featuresets
17:12:42 <dons> yep. it's important to get the editor abstractions correct
17:12:45 <Igloo> Is it actually going to be called hemacs?
17:13:03 * dons noticed that there is already a Hebrew Emacs
17:13:03 <Philippa> By the power of Haskell!
17:13:11 <Philippa> (sorry, couldn't resist)
17:13:14 <shapr> right, hemacs is a good working title...
17:13:17 <Igloo> Apart from anything else I think that would be confusing, as I hope the setting names etc aren't going to be emacs compatible
17:13:51 <Igloo> (Not that emacs and xemacs are, but hey  :-)  )
17:14:31 <shapr> we could always just call it by a single UTF8 char that's rarely used and laugh at the poor suckers who can't spell it on IRC.
17:14:39 <dons> haha!
17:14:55 <Igloo> Err, before you do that, does ghc support them yet?  :-)
17:15:06 <shapr> Igloo: no, we would also be laughing at ourselves.
17:15:18 * Igloo wonders if there's a unicode character for something like "Greek symbol of change"
17:15:29 <shapr> don't they call that eris?
17:15:42 <Igloo> "Gee, we've written a cool editor. If only we could compile it..."
17:15:47 <shapr> hah
17:16:00 * Igloo interrogates gucharmap
17:16:08 <shapr> Haskeleton?
17:17:00 <Igloo> There's a "U+1D321 TETRAGRAM FOR CHANGE", but I don't have a glyph for it
17:17:04 <shapr> ohhh
17:18:16 <shapr> want want!
17:20:58 <shapr> it even looks nice too
17:21:10 <Igloo> Oh, what does it look like?
17:21:21 <dons> ascii art please..
17:21:40 <shapr> - -
17:21:41 <shapr> ---
17:21:42 <shapr> ---
17:21:44 <shapr> - -
17:22:27 <shapr> a line can be solid, or divided into three or four pieces
17:22:33 <shapr> er, two or three
17:22:44 <Igloo> Ah, it's in my fixed-size font. Although looks nothing like that
17:23:03 <shapr> 1D322?
17:23:25 <Igloo> 1D321
17:24:44 <shapr> in that case, it's top line two pieces, and three solid lines
17:25:12 <Igloo> I see http://urchin.earth.li/~ian/foo.png
17:25:47 <shapr> right - http://www.fileformat.info/info/unicode/char/1D321/sample.png
17:26:19 <dons> ooh. nice. how do we pronounce it?
17:26:23 <dons> is this korean?
17:26:28 <Igloo> Working out how to run it could be interesting, too
17:26:34 <shapr> but, afaik, tetragrams are just four lines, I'm going guess that's the actual way to write the name for it
17:26:39 <shapr> rather than its tetragram
17:26:52 <Igloo> lines, not shapes?
17:26:53 <shapr> You see trigrams in the I Ching, or on the korean flag.
17:27:11 <Igloo> @wn tetragram
17:27:15 <lambdabot> *** "tetragram" wn "WordNet (r) 2.0"
17:27:15 <lambdabot> tetragram
17:27:15 <lambdabot>      n : a word that is written with four letters in an alphabetic
17:27:15 <lambdabot>          writing system
17:27:27 <shapr> @wn trigram
17:27:29 <lambdabot> *** "trigram" wn "WordNet (r) 2.0"
17:27:29 <lambdabot> trigram
17:27:29 <lambdabot>      n : a word that is written with three letters in an alphabetic
17:27:29 <lambdabot>          writing system
17:27:32 <shapr> too easy...
17:27:36 <Igloo> :-)
17:28:33 <Igloo> It's a Tai Xuan Jing symbol apparently
17:28:38 <shapr> What's that?
17:29:01 <Igloo> I've exhausted my knowledge on the subject
17:29:06 <shapr> :-)
17:29:47 <shapr> http://www.geocities.com/dao_house/yijing.html
17:30:57 <shapr> It seems that the Tai Xuan Jing is a Daoist reinterpretation of the Yijing.
17:31:53 <shapr> So it is about the I Ching
17:32:29 <shapr> In that case, it should be four lines, with the top one split into two pieces.
17:33:06 <shapr> Igloo: symbol of change is perfect for an editor.
17:34:01 <shapr> which fixed size font in debian has that character?
17:34:55 <Igloo> Most of the ones my uxterms use
17:35:07 <Igloo> Including Large, but not Huge
17:36:11 * shapr wonders if CacheIO is really necessary for Screen.hs usage.
17:43:56 <shapr> is this normal? *** Exception: ghci/ByteCodeGen.lhs:1082: Non-exhaustive patterns in case
17:45:07 <Igloo> Does it say what case it was?
17:45:23 <shapr> nope
17:45:40 <shapr> still 6.2.1, so it may be an old bug
17:49:48 <shapr> ah, the new build process is very friendly.
17:50:08 <dons> :)
17:50:18 <dons> hemacs build process, you mean?
17:50:22 <shapr> yes
17:51:26 <shapr> in pursuit of instant gratification, I threw the Screen.hs support files directly into the dir, change their module names to Hemacs.$NAME , and then 'make HEmacs/Screen.o' just worked.
17:51:37 <shapr> much happiness.
17:51:43 <dons> yep!
17:52:03 <dons> there's make code in mk/paths.mk to find new files and add them to $(HS_SRCS)
17:52:14 <shapr> that makes me happy.
17:59:13 <Lemmih> Hmm Generating valid XHTML is difficult with Halipeto /-:
18:00:09 <shapr> andrew said something about that...
18:00:31 * shapr checks
18:02:03 <shapr> hej bojohan 
18:02:11 <bojohan> that was quick!
18:02:31 <shapr> klockan r tre, du borde sova ;-)
18:02:38 <bojohan> :p
18:02:49 <shapr> har du nn frgor ...
18:02:51 <Lemmih> shapr: Did he say something about how to fix it?
18:02:58 <shapr> Lemmih: I just found it...
18:03:07 <bojohan> egentligen inte...
18:03:16 <shapr> he said "however, haxml doesn't guarantee corrcctly formed xhtml (which is what you want, i think, when you talk about a dtd).  if you want to restrict that you need to look at the other xml package for haskell."
18:04:55 <shapr> Lemmih: I've thought of a template-haskell-like way to get halipeto to only generate legal markup, but I haven't tried to hack it together.
18:05:44 <shapr> anyway, the page is looking nice from here
18:07:38 <shapr> bojohan: so, should I tell you about the editor formerly known as hemacs?
18:08:09 <bojohan> and which is currently known as?
18:08:19 <desrt> hvim
18:08:23 <desrt> or so i've heard =)
18:08:35 <shapr> it's currently known as a single unicode character...
18:08:43 <desrt> oo!  i know this one!
18:08:52 <shapr> "U+1D321 TETRAGRAM FOR CHANGE"
18:09:13 <shapr> this is sort of like 'the artist formerly known as prince'
18:09:26 * desrt would have guessed  (U+03BB GREEK SMALL LETTER LAMDA = lambda)
18:09:31 <Lemmih> shapr: Wouldn't that be _really_ difficult?
18:09:54 <shapr> Lemmih: what? the template-haskell-style totally legal generation of correct code? no, I don't think so.
18:10:28 <desrt> shapr; how many bytes to represent that codepoint in utf8?
18:10:59 <shapr> halipeto is based on zope page templates, and they have this same problem with legal generation, but I think it can be gotten around by passing the current legal subset of the DTD into the subcall.
18:11:11 <shapr> desrt: I dunno, ask google?
18:11:34 <Lemmih> shapr: So you wanna generate TH code from a DTD?
18:11:44 <shapr> desrt: how do you use google to search for a character that you can't type?
18:11:56 <desrt> you use gtk's character composition
18:12:00 <shapr> Lemmih: no, I want to generate a sub-DTD from TH.
18:12:02 <desrt> ctrl+shift+numbers
18:12:35 <desrt> hmm
18:12:40 <desrt> my web browser turned it into 4 bytes
18:12:49 <desrt> q=%F0%9D%8C%A1
18:12:51 <shapr> For example, with XHTML, inside a <table> tag, only a limited subset of the DTD is legal.
18:13:16 <shapr> Lemmih: otoh, might be a crappy idea, won't know till I try it.
18:13:18 <shapr> hej drlion
18:13:26 <drlion> hej hej shapr :-)
18:13:45 <shapr> Lemmih: in the meantime, illegal xhtml that mozilla can render is a workable option.
18:13:47 <bojohan> hej hej
18:14:11 <shapr> man, #haskell.se is so empty today....
18:14:28 * desrt starts #haskell.en_CA
18:14:29 <bojohan> but this place is crowded
18:14:42 * shapr starts #haskell.se_CHEF
18:14:47 <desrt> bork!
18:15:02 <shapr> yah, #haskell is bouncing... 
18:15:06 <bojohan> /ncm
18:15:06 <bojohan> *** 75
18:15:41 <shapr> we get past 100 sometimes
18:15:48 <shapr> and as low as 60 in the summers.
18:15:51 * desrt joins up a bunch of clonebots
18:16:12 <drlion> bojohan mentioned in #emacs the swing function that someone discovered while we were at EuroHaskell, so I had another go at trying to understand it, but failed miserably
18:16:29 <shapr> I thought Cale wrote swing?
18:16:58 <desrt> no.. cale was the Ph.D. advisor to the guy who wrote swing as his thesis
18:17:12 <shapr> desrt: fnord!
18:18:15 <drlion> oh god, someone wrote swing as his thesis?
18:18:18 <shapr> drlion: what parts of swing do you understand?
18:18:36 <stepcut> swing f = flip (f . flip ($)) ???
18:18:54 <drlion> shapr: I guess the parantheses, and the equals sign :-)
18:19:05 <drlion> what does flip do again?
18:19:10 <shapr> swaps args
18:19:12 <shapr> @type flip
18:19:13 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
18:19:16 <phubuh> flip f g x = f x g
18:19:18 <drlion> ah, right
18:19:27 <shapr> you know what (.) does?
18:19:30 <shapr> hiya heatsink 
18:19:33 <desrt> phubuh; you picked the most confusing letters possible :)
18:19:35 <drlion> okay, then I understand all the parts, but none of how they work together :-)
18:19:53 <phubuh> desrt: haha, that's true
18:19:57 <phubuh> flip f a b = f b a :)
18:19:58 <drlion> shapr: yeah, composition
18:20:40 <shapr> you know what $ does?
18:21:07 <drlion> yeah, it's just function application, right?
18:21:12 <desrt> oh.  i rememeber this
18:21:19 <desrt> i also remember it
18:21:34 <shapr> yes
18:21:45 <desrt> it takes something like map and changes how the arguments work
18:21:54 <desrt> Prelude> :t swing map
18:21:54 <desrt> swing map :: forall a b. [a -> b] -> a -> [b]
18:22:44 <desrt> Prelude> swing map [(+1),(+4),(*2),(/3)] 24
18:22:44 <desrt> [25.0,28.0,48.0,8.0]
18:22:47 <shapr> so, swing swaps the arguments to a function, applies everything, and swaps the result
18:23:01 <shapr> make sense?
18:23:55 <desrt> i thought y'all were talking about java swing
18:23:58 <shapr> map wants a function and a chunk of data, if you swap that, it wants data and a function, right?
18:24:01 <desrt> ie: i thought you were joking when you said cale wrote it :P
18:24:03 <bojohan> make: Fatal error: Don't know how to make target `sense'
18:24:20 * shapr slr bojohan med en forell
18:24:25 <drlion> hahaha
18:24:42 * bojohan dansar
18:24:43 <shapr> bojohan: if mIRC is ever localized to swedish :-)
18:25:15 <drlion> shapr: okay, thanks, now I've got the basis for understand it, I guess, but I'll have to meditate on it :-)
18:25:19 <shapr> I don't know how to say "slaps someone around" but I can say "smacks" or "hits"
18:25:33 <Cale> "<desrt> no.. cale was the Ph.D. advisor to the guy who wrote swing as his thesis" -- what?
18:25:42 <shapr> Cale: you're famous.
18:25:43 <Cale> haha
18:25:47 <bojohan> :O
18:25:51 <desrt> Cale; i thought he was talking about java swing :P
18:26:02 <Cale> I was a PhD advisor?
18:26:09 <shapr> Cale does come up with really cool uses of flip and (.)
18:26:11 <desrt> i thought he was kidding
18:26:14 <Cale> oh
18:26:28 <desrt> 21:20 <shapr> I thought Cale wrote swing?
18:26:34 <desrt> you can see how this would be funny
18:26:49 <drlion> is Cale the tall and handsome guy who apparently wrote lambdabot?
18:26:57 <desrt> (mostly because you use cgoban a lot, really...)
18:27:04 <bojohan> swing was written by an ugly space alien
18:27:04 <shapr> Cale: you did the two and three arg versions of (.) right?
18:27:21 <Cale> shapr: yeah, though I don't remember them :)
18:27:28 <shapr> drlion: Andrew J. Bromage wrote lambdabot ... not sure if he's tall...
18:27:30 <bojohan> (.).(.)
18:27:43 <desrt> that's a pretty boring function :)
18:27:55 <shapr> desrt: actually, it's really neat...
18:28:02 <shapr> it's pair compose
18:28:09 <shapr> desrt: now find the three-arg version
18:28:27 <shapr> I think it took Cale about five minutes.
18:28:34 <bojohan> Prelude> ((+1) # (*)) 3 5 where (#) = (.).(.)
18:28:34 <bojohan> 16
18:28:37 <desrt> i'm not even sure what you're talking about :)
18:28:48 <shapr> @type ((.).(.))
18:28:49 <lambdabot> ((.).(.)) :: forall a b c a1.
18:28:49 <lambdabot> 	     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:29:44 <desrt> right...
18:29:47 * shapr goes back to hacking on the buffer for the editor formerly known as hemacs
18:29:54 <desrt> so the 3 arg one takes 3 ops or 3 operands?
18:30:09 <shapr> three operands
18:30:18 <bojohan> like?
18:30:19 <bojohan> Prelude> ((+1) # (\a b c-> a*b*c)) 3 5 7 where (#) = (.).(.).(.)
18:30:19 <bojohan> 106
18:31:03 <desrt> it would be more interesting if it was (+)#(*)
18:31:09 <desrt> and 3 5 7 gave 3*5 + 7
18:31:29 <phubuh> f . flip ($) = \a -> f (\g -> g a)
18:31:54 <desrt> i definitely hate haskell :)
18:32:10 <heatsink> oh... hi shapr
18:32:21 <bojohan> it is
18:32:34 <bojohan> Prelude> ((+)#(*)) 3 5 7 where (#) = (.).(.)
18:32:34 <bojohan> 22
18:32:43 <drlion> can you use arbitrary Unicode characters in Haskell names?
18:33:06 <desrt> bojohan; fancy
18:33:15 <bojohan> currying
18:33:17 <phubuh> map . flip ($) = \a -> map (\g -> g a)
18:33:28 <phubuh> (map . flip ($)) 10 = map (\g -> g 10)
18:33:37 <bojohan> schoenfinkeling
18:33:55 <phubuh> (map . flip ($)) 10 [(+ 1), (* 2)] = map (\g -> g 10) [(+ 1), (* 2)] = [11, 20]
18:37:05 <drlion> phubuh: I'm trying to grasp that...  Expressed in words, what does swing map do?
18:38:02 <Cale> I might as well explain it :)
18:38:08 <drlion> does it take an array of functions and something to apply them to, and give an array of the functions applied to the thing?
18:38:22 <phubuh> yes
18:38:28 <Cale> drlion: right, if you replace "array" by "list" :)
18:38:47 <drlion> okay, cool.  Right, it's the [] that does that :-)
18:38:53 <drlion> make me say array, I mean
18:39:29 <Cale> I've found "swing any" to be quite useful
18:39:59 <Cale> (it takes a list of predicates, and a value to apply them to, and sees if any of them hold)
18:40:30 <drlion> let me guess what that does...  It takes a list of predicates and a test subject, and returns a list of which ones satisfy the predicate?
18:40:38 <drlion> oh...
18:40:54 <drlion> wait, what I said doesn't make any sense
18:41:30 <shapr> Cale: I think that's illegal in several states.
18:41:35 <drlion> yeah, that sounds incredibly useful
18:41:48 <drlion> haha
18:42:09 <shapr> Cale: did you name swing?
18:42:13 <Cale> yeah
18:42:18 <shapr> I am entertained =)
18:42:53 <Cale> heh, the basic idea being that it seemed to swing the type constructors around, and I didn't have a better idea of what to call it
18:43:39 <shapr> gee, I thought it was a direct punny reference to 'gender benders' that switch your serial/parallel/etc ports from male to female.
18:43:52 <Cale> heh
18:44:04 <Cale> didn't put that much thought into it
18:44:55 <Cale> swing filter is neat
18:45:25 <Cale> it takes a list of predicates and a value, and returns only those predicates which succeed on that value
18:45:48 <shapr> sounds like something bourbake was asking for with his decision trees
18:45:59 <Cale> swing filter :: forall a. [a -> Bool] -> a -> [a -> Bool]
18:46:23 <drlion> dare I ask what swing swing does, if anything?
18:47:35 <bojohan> swing swing :: a -> (b -> a -> c) -> b -> c
18:48:08 <Cale> (swing swing) map :: forall a c a1 b. (a -> ((a1 -> b) -> [a1] -> [b]) -> c) -> a -> c
18:48:15 <bojohan> swing swing swing swing :: (((a -> b) -> b) -> ((((c -> d) -> d) -> e -> f) -> e -> c -> f) -> g) -> a -> g
18:48:22 <drlion> oh god
18:48:28 <bojohan> hahaha
18:49:44 <phubuh> swing swing a f b = f a b
18:50:12 <drlion> what is b doing there?
18:50:46 <phubuh> swing swing = \a f b -> f a b
18:51:06 <phubuh> it takes three arguments and applies the middle to the first & last, like an infix evaluator :)
18:51:47 <drlion> but why not swing swing a f = f a?
18:52:30 <drlion> am I really confused or is that the same thing?
18:53:13 <shapr> if f is a two arg function, it can be
18:53:27 <drlion> (fallaciously excluding any middle)
18:53:41 <phubuh> the former requires f :: a -> b -> c, as does swing swing
18:53:52 <drlion> oh...
18:54:33 <shapr> isn't it like.. 4am in sweden?
18:54:58 <phubuh> aren't you in sweden? :=
18:55:13 <shapr> yes... just wondering why there's suddenly all this swedish activity at 4am
18:55:17 <phubuh> sorry about the mouth
18:55:30 <shapr> really big teeth?
18:58:30 <phubuh> swing swing = flip (\a -> (\f -> flip (\b -> f (\h -> h b))) (\g -> g a))
18:58:31 <phubuh> :P
18:58:49 <drlion> is that obfuscated on purpose?
18:59:18 <phubuh> no, i just expanded the f . flip ($) expressions
18:59:26 <drlion> please say yes, because I was starting to believe swing swing = flip ($), more or less
18:59:44 <drlion> oic
18:59:57 <phubuh> that's what it amounts to, except with a useless type restriction
19:00:08 <drlion> okay, cool
19:01:37 <drlion> I want someone to discover the merryGoRound function
19:01:49 <drlion> or boogieWoogie
19:02:03 <heatsink> tango
19:02:21 <drlion> yeah, that's actually a good name
19:02:30 <drlion> as good as swing, anyway :-)
19:11:32 <heatsink> Interesting... emacs thinks that \( is not an opening parenthesis.
19:13:25 <bojohan> yes...
19:14:04 <bojohan> depending on the mode
19:14:18 <stepcut> heatsink: people often do this --> (\ (a,b) -> (b,a))
19:14:45 <heatsink> oh thx, I'll do that
19:15:03 <stepcut> heatsink: It's a bit silly to do that just to make emacs happy, but it is easier than fixing the emacs mode :-/
19:16:01 <heatsink> yeh, I'm rooting for hemacs
19:16:28 <bojohan> do you want to make baby emacs cry?
19:17:38 <phubuh> drlion: swing' f b = f (\g -> g b) is the same except it makes functions with flipped parameters
19:18:38 <phubuh> drlion: so swing' map 10 = map (\g -> g 10), and so on
19:20:49 <phubuh> ok i'm going to bed
19:24:32 <shapr> bojohan: I want baby emacs to grow up =)
19:25:59 * desrt estimates 10 minutes
19:26:27 <Lemmih> phubuh: Sleep well.
19:27:23 <shapr> Lemmih: that's looking pretty spiffy
19:29:10 <Jan_w> shapr: man, still here ?
19:29:15 <Jan_w> shapr: go to sleep
19:29:15 <shapr> yes?
19:29:32 <shapr> no way... I want to have this buffer working by 6am
19:29:36 <Lemmih> shapr: ?
19:29:38 <Jan_w> shapr: hehe, just got back from a night the town :)
19:29:51 <shapr> I've had a night on the keyboard
19:29:59 <Jan_w> shapr: so i see
19:30:22 * Jan_w is soooo drunk, martini is bad for ya
19:30:26 <shapr> Lemmih: the libraries dealie
19:30:59 <Jan_w> although the best hacks are made drunk, i'm not going to try now :), gotta get some sleep
19:31:04 <Jan_w> nighty night
19:31:20 <Lemmih> Oh. (-: I'm hacking on the search template now.
19:31:29 <shapr> g'night Jan_w 
19:33:02 <shapr> 500 line mainLoop functions are really hard to read
19:33:06 * shapr kicks ginsu
19:33:16 <dons> heh!
19:33:39 <shapr> hiya CosmicRay 
19:34:00 <CosmicRay> good evening shapr
19:34:32 <shapr> oh, there's an ErrorLog.hs in ginus
19:34:34 <shapr> ginsu
19:34:38 <shapr> it looks really nice.
19:35:23 <CosmicRay> oh?
19:35:25 <CosmicRay> what does it do?
19:35:47 <shapr> log levels, handlers, tryMany, all sorts of stuff
19:36:15 <CosmicRay> huh
19:36:18 <CosmicRay> URL?
19:36:29 <CosmicRay> I hope my own work on a logging system hasn't been wheel reinventing.
19:36:45 <shapr> http://repetae.net/computer/ginsu
19:38:18 <CosmicRay> looks like it's mostly focused on logging to files
19:38:24 <CosmicRay> though there are some nice wrappers I'd do well to emulate
19:38:39 <CosmicRay> My stuff is here: http://gopher.quux.org:70/devel/missingh/html/MissingH.Logging.Logger.html
19:39:17 <CosmicRay> currently there are only file, handler, and syslog handlers, but it is possible to extend it significantly
19:39:26 <shapr> I don't know how it compares to your logging code, but I figured you'd be interested.
19:39:55 <CosmicRay> yup, thanks
19:40:08 <CosmicRay> I should have something to catch exceptions
19:40:22 <CosmicRay> mine is a lot more versatile, though it lacks some of those utilities
19:40:34 <shapr> also, Meacham's GenUtil.hs is just really handy to have.
19:41:01 <CosmicRay> for instance, with what I'm doing, you can tune -- on a global level -- how much gets logged by particular modules, and set up specific handlers for specific things.  that sort of thing
19:41:20 <shapr> I think some of that can be done with ErrorLog also, but I'm not sure.
19:41:22 <CosmicRay> once I put a little more time into it, it will also have customizable filters (beyond the log level that it has now) and  formatters
19:41:37 <shapr> I've only glanced at ErrorLog, I'm more interested in stealing the Curses windowing code.
19:42:32 <CosmicRay> there are good things in there indeed
19:57:42 <dons> yay. separated e_* out of the ui functions -- and it still works
19:58:01 <dons> so the editor actions aren't entwined with the UI anymore
19:58:24 <dons> now, to fill that buffer up
19:59:19 * shapr bangs head on ginsu
20:00:51 <dons> mm.. pizza time
20:01:34 <dons> I think this whole editor thing's going to be pretty easy. Haskell Rules!
20:02:45 <shapr> :-)
20:03:27 <dons> i've simplified the editor state and stuck it in a global var, so no more threading of state around
20:04:44 <shapr> I'm trying to figure out what part of mainLoop is really necessary to use Screen
20:06:49 <shapr> screen is neat, curses widgets can have their own key and event handlers, otherwise the key or event bubbles up the nesting hierarchy
20:57:44 <heatsink> hmm... why is catchException an IO monad?
20:59:17 * shapr grumbles as 6am passes...
20:59:59 <heatsink> oh, there's a MonadCont, I don't need throw and catch.
21:01:02 <dons> shapr: Emacs wasn't built in a day :P
21:01:43 <dons> and if emacs was started in 1974, and we look at its current state, it will take us at least a week to get something as nice as that ;)
21:02:15 * shapr laughs
21:02:29 * shapr laughs more
21:03:10 <shapr> I seem to have a working mainLoop, but I dunno how to update the text in a widget....
21:03:49 <bojohan> shapr: lggdags!
21:04:16 <shapr> truly
21:04:35 <shapr> I want a buffer!!
21:04:39 <bojohan> emacs contains ~ 1.5 million loc
21:04:50 <shapr> about half of which could be refactored out ;-)
21:05:05 <bojohan> most of which is lisp
21:06:28 <bojohan> gnus alone is 125000 lines of code
21:07:30 <shapr> gnus is pretty cool
21:07:48 <shapr> emacs needs more integration at a minimum
21:08:22 <shapr> bbdb can pop up and show me details from gnus, but I can't jump from bbdb to a list of gnus mails from that person.
21:12:43 <shapr> aha, I think I see how ginsu gets chars
21:16:50 <heatsink> Can Exprs be deconstructed in template haskell?
21:20:50 <shapr> @index Expr
21:20:50 <lambdabot> bzzt
21:22:54 <heatsink> @index Exp
21:22:54 <lambdabot> Graphics.UI.GLUT,Language.Haskell.THSyntax,Graphics.Rendering.OpenGL,Graphics
21:22:54 <lambdabot> Rendering.OpenGL.GL,Graphics.Rendering.OpenGL.GL.Fog
21:23:03 <heatsink> hmm
21:23:12 <heatsink> the paper said Expr was a synonym for Q Exp
21:24:20 <shapr> @type Language.Haskell.THSyntax.Expr
21:24:21 <lambdabot> bzzt
21:24:30 <shapr> @type Language.Haskell.THSyntax.Q
21:24:31 <lambdabot> Language.Haskell.THSyntax.Q :: forall a.
21:24:31 <lambdabot> 			       IO a -> Language.Haskell.THSyntax.Q a
21:25:08 <shapr> heatsink: you want to get source from a TH structure?
21:25:18 <shapr> @index pprDec
21:25:18 <lambdabot> Language.Haskell.THSyntax
21:25:25 <shapr> @type Language.Haskell.THSyntax.pprDec
21:25:27 <lambdabot> Language.Haskell.THSyntax.pprDec :: Language.Haskell.THSyntax.Dec
21:25:27 <lambdabot> 				    -> Text.PrettyPrint.HughesPJ.Doc
21:27:51 <heatsink> ppr is pretty-print?
21:28:35 <shapr> yup
21:30:34 <shapr> dons: I'll work on the buffer more tomorrow. I think I'm close to having a Screen widget buffer.
21:31:09 <shapr> of course.. it is tomorrow already.
21:31:42 <stepcut> shapr: sweet
21:31:45 * shapr falls over asleep
21:31:52 <stepcut> @shapr
21:31:52 <lambdabot> needs sleep
21:31:58 <dons> cool. i'm close to getting the buffer working
21:32:18 * heatsink laughs
21:41:19 <bojohan> sleep! now!
23:09:18 <dons> yay. hemacs has a buffer!
23:10:20 <dons> ncurses rocks
23:15:48 <drlion> are you guys writing an editor from scratch?
23:16:34 <dons> not quite from scratch. but close. but it is in dynamically loaded Haskell :)
23:17:00 <drlion> so what is it based on?
23:17:27 <dons> riot, and hs-plugins.
23:17:34 * dons is busy hacking
23:18:05 <drlion> oh, sorry, I'd hate to disturb anyone working on something so cool :-)
23:37:03 * heatsink 's program now simplifies (a * b) ** 4 completely
23:38:38 <heatsink> not as cool as hemacs, but I'm happy about it
23:52:12 <drlion> heatsink: simplify == expand, in this context? :-)
23:56:12 <heatsink> um... yea >_>
23:56:18 <musasabi> morning
23:56:43 <kolmodin> morning
23:57:50 <drlion> heatsink: can it expand binomials raised to arbitrary powers?
23:59:22 <drlion> heatsink: oh, that's not a binomial.  (a * b) ** 4 == a ** 4 * b ** 4 :-)
