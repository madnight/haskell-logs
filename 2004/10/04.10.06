01:01:54 <musasabi> Is there a reason that (==) is not optimized to include pointer-eq ?
01:09:23 <Heffalump> there's no guarantee that every Eq instance will obey a==a
01:12:46 <musasabi> Heffalump: yes it should.
01:13:12 <musasabi> Heffalump: equivalence is 1) *reflexive* 2) symmetric 3) transitive
02:29:24 <musasabi> How can I read to be less hungry?
02:30:19 <kristnjov> not associate?
02:30:20 <musasabi> I have "val <- hGetContents socket >>= readIO", but that will block even when the whole value is available on the other side.
02:30:22 <kristnjov> not associative?
02:30:59 <musasabi> the other side does hPutStr[Ln] sock (show foo) >> hFlush sock
02:32:02 <musasabi> if I hit ^C and thus the socket is closed, it will happily print the result before exiting with a broken pipe
02:34:18 <musasabi> e.g. val <- hGetContents socket; print val; print (read val :: Foo) will block in the third statement
02:55:11 * shapr wibbles
02:56:44 <musasabi> hmm it works with hGetLine, I think it has something to do with unsafeInterleaveIO
02:57:12 <shapr> read to be less hungry... eat the book?
02:57:52 <musasabi> ^_^
02:59:48 <shapr> when I cranked up my metabolism via unicycling, I got only slightly more hungry than before, and I didn't eat significantly more than before. I did eat smaller meals more often, and I've lost 12 kilos and five belt notches that way.
02:59:54 <shapr> dunno if that's the same question you were asking.
03:01:51 <shapr> hej ralejs 
03:01:56 <shapr> god morgon
03:01:57 <ralejs> hej shapr
03:02:27 <shapr> how was .jp?
03:02:44 <ralejs> Oh, that was magnificent.
03:03:05 <ralejs> Hard work and great fun!
03:03:27 <shapr> that does sound good
03:04:07 <ralejs> As you probably know I gave a one week intensive course on Haskell. It was intensive indeed.
03:04:25 <shapr> I heard about it.
03:04:32 <shapr> just a bit
03:04:49 <shapr> I'd like to find more intensive group coding sessions.
03:05:16 <ralejs> I guess that's what eurohaskell is for :)
03:05:46 <shapr> yes, I think so.
03:06:53 <ralejs> Well, if you want code sprints I think it is important to have a specific goal.
03:07:49 <shapr> I could go for a nice Cabal sprint via IRC right now.
03:08:23 <ralejs> That's a good idea, I guess.
03:08:53 <shapr> Cabal would make installing stuff like HaskellDB much easier.
03:09:47 <ralejs> Hmmm, I'm ashamed to say that I'm not quite into the details of cabal. I should be.
03:10:07 <shapr> do you know about distutils for Python?
03:10:12 <shapr> that's the idea for Cabal
03:10:52 <shapr> http://www.haskell.org/cabal/
03:10:54 <ralejs> Well, I know the general idea of cabal. But not much more than that.
03:11:14 <shapr> you've probably used ghc-pkg and hmake
03:11:18 <shapr> or hbcmake
03:12:05 <shapr> but those don't work with all haskell implementations
03:12:27 <shapr> When finished, Cabal should support ghc, hugs, nhc, etc 
03:12:40 <ralejs> Right.
03:13:02 <shapr> right now it's pretty much ghc6 only, but as more people work on it, it'll get better.
03:13:54 <musasabi> having a cabal->deb script would also be very nice..
03:14:12 <ralejs> What's the reason for it being ghc6?
03:14:41 <shapr> I think because the primary developers mostly use ghc6.
03:14:53 <ralejs> Ok.
03:15:46 <shapr> iirc, it handles source packages just fine, but doesn't deal with more complicated stuff like .hsc building.
03:16:15 <ralejs> Btw, I heard rumours about hemacs. What's the status?
03:18:53 <musasabi> btw haskell.org/haskelldb seems quite stale, it would be nice if it was redirected to the sf.net page.
03:24:43 <shapr> ralejs: there's a post-emacs mailing list I just created
03:25:33 <shapr> ralejs: my vague ideas include scripting with a parallel Joy, syntax highlighting, parse tree macros, incremental parsing, etc
03:26:36 <shapr> do you know of any editor stuff written in Haskell?
03:26:45 <shapr> I've seen the editor combinators at least
03:27:23 <ralejs> So hemacs is still in the early planning stadium, I take it.
03:28:21 <ralejs> Well, as for editing there is the zipper data type. But I don't think it is ment for the kind of text editing we associate emacs with.
03:50:07 <musasabi> How would one go about implementing sized types in Haskell?
03:52:15 <bourbaki> hi
03:52:34 <bourbaki> shapr: whats the name of that one yampa paper you spoke about id like to print that one
03:57:28 <shapr> bourbaki: haskell-workshop-02
03:57:47 <shapr> bourbaki: http://www.haskell.org/yale/papers/haskellworkshop02/index.html
03:57:50 <shapr> that's the second paper
03:57:52 <bourbaki> shapr: cool thanks
03:58:21 <shapr> you probably want to read the first yampa paper before that: http://www.haskell.org/yale/papers/zwthesis/index.html
03:58:34 <shapr> er, that's the thesis, it might be too much
03:58:49 <shapr> musasabi: Bj√∂rn did it in HaskellDB, for varchar(60) etc
03:58:59 <shapr> he had a bunch of different ideas, made for interesting reading.
03:59:27 <shapr> ralejs: wouldn't the zipper type be good for an incremental parser based editor that stores the buffer as a parse tree?
04:02:50 <bourbaki> hi TheHunter 
04:04:46 <bourbaki> shapr: was that er too much ment for me?
04:06:19 <TheHunter> hi bourbaki 
04:07:09 <musasabi> shapr: the haskelldb way is more or less a hack.
04:07:41 <musasabi> It defines the instances by hand.
04:16:21 <musasabi> utf8 + sql + japanese makes for evil amounts of inefficiency.
04:31:52 <musasabi> Any idea why debian c2hs depends on ghc5?
05:07:23 <ralejs> shapr: re zipper. It could probably work. I'm not sure it is worth the effort though. But that might just be me not having a clear picture of how it would be done.
05:38:09 <dblhelix> kosmikus: I've asked this yesterday, but you seemed to be afk ... any lhs2tex trick to emit a _formatted_ index entry from within a block of code? (makeindex)
05:39:19 <kosmikus> what do you mean, from "within a block of code"?
05:39:55 <kosmikus> %format whatever = "\indexwhatever"
05:40:08 <kosmikus> \newcommand{\indexwhatever}{\index{|whatever|}}
05:40:10 <kosmikus> should work ...
05:40:14 <dblhelix> \begin{code} ... % emit from here  % ... \end{code}
05:40:27 <dblhelix> kosmikus: I'll try ... thanks
05:40:40 <kosmikus> also {-"\index{|whatever|}"-} directly in the code block should work
05:41:16 <kosmikus> I'm not sure about %format whatever = "\index{|whatever|}", though it might work as well
05:41:16 <dblhelix> should it? wouldn't that emit the |'s litteraly?
05:41:39 <dblhelix> (referring to the {-" "-} thing)
05:41:50 * kosmikus checks the code
05:41:58 <dblhelix> b
05:45:20 <kosmikus> dblhelix: no, doesn't seem to work
05:45:32 <kosmikus> but {-"\indexwhatever"-} will work as well
05:46:00 <dblhelix> okay, then I'll use that ... thanks
05:49:00 <vegai> bugger
05:53:03 <vegai> /usr/pkg/lib/ghc-6.2.1/libHSnetwork.a(BSD.o)(.text+0x5a4b): In function `NetworkziBSD_getHostEntry_entry':
05:53:07 <vegai> : undefined reference to `gethostent'
05:53:10 <vegai> (building darcs)
05:54:04 <ibid> vegai: there is also a #darcs :)
05:54:13 <vegai> is there? wow.
05:54:32 <vegai> to my defence, I didn't actually break many conversations there...
05:54:57 <Igloo> That's a GHC issue, anyway
05:55:04 <Igloo> What Os is it?
05:56:08 <vegai> -O
05:56:21 <Igloo> I meant to say what OS
05:56:28 <vegai> ah :)
05:56:35 <vegai> NetBSD-current
05:56:37 <Igloo> Sorry  :-)
05:56:48 <vegai> ghc is 6.2.1 from pkgsrc
05:57:17 <vegai> ghc was probably built without some needed flag?
05:57:26 <Igloo> You could fix it by adding to the #if above gethostent in libraries/network/Network/BSD.hsc but you might also be able to fix it with -lfoo, FSVO foo
05:57:49 <vegai> ok, I'll try all values of foo :-P
05:58:01 <Igloo> Googling for netbsd gethostent might tell you what foo is
05:58:01 <vegai> or perhaps that other idea first
05:58:19 <Igloo> Well, the other idea isn't great either as it involves recompiling GHC  :-)
05:58:45 <Igloo> Oh, try -lnsl and -lsocket first
05:58:50 <Igloo> (solaris needs them)
05:59:24 <Igloo> And if you work out what foo is, fire off a patch for libraries/network/package.conf.in to add it automatically
06:04:07 <vegai> let's see...
06:08:27 <vegai> takes a while to teste these things on a ~133MHz CPU with 64MB memory :)
06:32:58 <musasabi> Is there a good way of handling enums when interfacing with C?
06:34:30 <kosmikus> I'd like to know that, too.
06:35:33 <shapr> @yow !
06:35:34 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
06:35:37 <shapr> excitement!
06:37:00 <shapr> musasabi: debian c2hs depends on ghc5 because I haven't fixed it yet =)
06:52:42 <juhp> musasabi: I think hsc2hs is better at handling enums
06:57:14 <musasabi> thanks, I'll look at it.
06:58:11 <SyntaxLaptop>  any complains about the darcs rc3 debs?
07:39:06 <wkornew> hi, does anyone know if Resource.hsc is needed (the resource.h API)? it does not work when compiling an unregisterised build
07:39:48 <Igloo> How does it not work?
07:39:48 <wkornew> uhm, I mean for building GHC :)
07:40:34 <wkornew> it says that CRLim is not defined or something like that...
07:40:39 <wkornew> doing a recompile now
07:40:40 <Igloo> You can probably disable that library without the build breaking
07:41:08 <Igloo> It works fine in unregisterised builds, though. It must be an incompatibility with your OS.
07:41:29 <wkornew> my OS does not have resource.h, I think
07:41:49 <wkornew> but I am currently generating the HC files in Linux, so this should not happen
07:43:04 <Igloo> I have
07:43:07 <Igloo> libc6-dev: /usr/include/sys/resource.h
07:43:07 <Igloo> libc6-dev: /usr/include/bits/resource.h
07:43:11 <wkornew> me, too
07:43:16 <Igloo> linux-kernel-headers: /usr/include/asm/resource.h
07:43:16 <Igloo> linux-kernel-headers: /usr/include/linux/resource.h
07:43:17 <wkornew> but not in BeOS
07:43:32 <wkornew> IMHO, it should compile fine
07:45:03 <wkornew> okay, I'll try to remove that file and report again
07:47:08 <musasabi> Did a primitive qdbm binding if someone is interested.
07:50:38 <Boegel> hello everyone
07:53:12 <musasabi> hello Boegel 
07:53:46 <Boegel> where are my gifts ? :p
07:57:17 <musasabi> Is ghc cpp special in some way? It does not seem to handle # very well.
07:57:38 <musasabi> Running the file first through cpp and then ghc works fine, but ghc with -cpp does not like it.
07:58:23 <musasabi> http://youzen.b2.fi/~musasabi/cpp.hs demonstrates it with 3 lines of code.
07:59:41 <Igloo> ghc uses flags like -traditional -x c by default IIRC
08:00:03 <Igloo> Adding -v to the commandline should show you what it is running
08:01:42 <musasabi> yes -traditional does it.
08:08:21 <musasabi> Found it #define S(x) "x"
08:11:03 <shapr> ugh, bookkeeping
08:13:08 <shapr> Lunar^: I want hOppix!
08:13:26 <shapr> Lunar^: think of what we could fit onto an ISO!
08:13:44 <Lunar^> yeah !
08:13:57 <shapr> SyntaxNinja: y0, CosmicRay aka John Goerzen was here yesterday evening.
08:14:09 <shapr> Lunar^: what does that need? CDROM and filesystem drivers?
08:15:00 <shapr> Lunar^: you want a hOp darcs repo on ScannedInAvian?
08:16:07 <Lunar^> shapr: I've sent a reply to Thomas Hallgreen
08:16:12 <shapr> I posted about hOp and House to lambda-the-ultimate: http://lambda-the-ultimate.org/node/view/299
08:16:32 <Lunar^> shapr: cool
08:16:34 <shapr> Thomas Hallgren said it was okay for me to post the link on LtU
08:16:36 <SyntaxNinja> shapr: I was just wanting to talk to him
08:17:21 <Igloo> He's a bit idle but on IRC
08:17:31 <Lunar^> shapr: Did you run the HW demo ?
08:17:36 <SyntaxNinja> i'll msg him...
08:17:51 <shapr> hmm, I could use cvsync to make a darcs mirror of the GHC cvs tree, and see how much of the 6.2 diffs apply to hOp
08:17:55 <shapr> Lunar^: not yet
08:18:12 <Lunar^> shapr: You just need to apt-get install qemu, and use $ qemu -std-vga -fda hOp-hw2004.flp
08:18:58 <Lunar^> shapr: I've asked for House sources, if they don't intend to release something
08:19:11 <shapr> I hope they will.
08:19:24 <shapr> oh, Thomas said sources are dependent on Rob Noble licensing Gadgets
08:19:32 <shapr> I think they're trying to find him now.
08:21:01 <shapr> the Gadgets PhD thesis was about eight years ago, and I couldn't find Rob with a google search.
08:22:10 <shapr> CosmicRay: we were just talking about you...
08:22:31 <shapr> Lunar^: House is surprisingly fast, did they do some sort of optimizations?
08:22:51 <CosmicRay> shapr: I guess I should /nick CosmicPsychic
08:23:06 <shapr> :-)
08:23:19 <shapr> arghh, qwerty keyboard...gick
08:23:32 <SyntaxNinja> oh, he's not a psychic, I just msged him ;)
08:23:32 <shapr> I *really* want House sources now.
08:24:35 <Lunar^> shapr: I don't think so
08:24:48 <Lunar^> shapr: but I don't know really
08:24:56 <Lunar^> shapr: The most amazing is run
08:25:14 <shapr> how does it work?
08:25:18 <Lunar^> shapr: As Thomas wrote, Andrew did implement separate address space
08:25:31 <Lunar^> shapr: "ls" ; "run /hello"
08:25:42 <shapr> I think "User time exhausted" is quite impressive
08:25:45 <Lunar^> shapr: Which means we now have process
08:26:51 <shapr> w00
08:27:25 <shapr> with the scheduler improvements, this could be a 'real' OS
08:27:36 <Lunar^> shapr: sure :)
08:28:00 <Lunar^> shapr: I'm waiting Thomas reply... :)
08:32:02 <shapr> greetings viv at home
08:32:51 <shapr> Lunar^: how's your education? do you think hOp/House will be part of it?
08:33:26 <Lunar^> shapr: I could manage that, especially next year we have a 6 month resarch work to do
08:33:37 <Lunar^> shapr: Why not in Oregon? ;)
08:33:55 <shapr> heh, good idea
08:34:19 <shapr> talk to ogi and your educational director and see if that could work.
08:34:21 <Lunar^> House is a damnly cool name
08:34:26 <shapr> I like hOp
08:34:47 <shapr> such marvelous capitalization
08:34:53 <Lunar^> shapr: I think I will wait next year for that, but, anyway, I'm letting the idea flotting around, yeah
08:52:03 <CosmicRay> shapr: i prefer all caps.  java makes my finger hurt.
08:52:08 <CosmicRay> shapr: or all lowercase.
08:52:16 <CosmicRay> it literally hurts my hand to program in java.
08:52:29 <shapr> it hurts my head.
08:52:37 <CosmicRay> yeah java just sucks all around
08:52:42 <CosmicRay> more than perl even
08:52:56 <bourbaki_> you should go to court and ask sun for money ;)
08:53:06 <CosmicRay> heh
08:53:14 <shapr> everyone else has ;-)
08:53:15 <CosmicRay> get a little slice of that ms settlement fund? :-)
08:53:35 <bourbaki_> here at uni they do java for teaching algorithms!!!
08:53:46 <bourbaki_> whenever i see that i freak out
08:53:53 <shapr> bourbaki_: this means we will keep our jobs for a long, long time.
08:54:03 <bourbaki_> i dont have a job :)
08:54:06 <shapr> oh
08:54:11 <bourbaki_> im a student again
08:54:38 <bourbaki_> am a former pro game/engine progger and did a lot of c++ back then
08:54:43 <shapr> ah, neat
08:54:56 <musasabi> Is there a way to refer to this module in a nice short way?
08:55:20 <shapr> in what context?
08:55:36 <shapr> like "import This as T; T.ConstantName" ?
08:55:49 <musasabi> The module is named Foo.Bar.Baz and defines functions overriding prelude, but I don't want to import prelude qualified, so I have to qualify references to things inside the module.
08:56:29 <musasabi> module Foo.Bar.Baz; lookup = ...; foo = Foo.Bar.Baz.lookup
09:00:29 <shapr> I can't think of a good solution other than creating a convention to do that
09:00:44 <shapr> something like assigning your own This near the top
09:01:04 <shapr> I wonder if you can do "import Foo.Bar.Baz as This"
09:01:05 * shapr tries
09:01:41 <shapr> Module imports form a cycle for modules:
09:01:42 <shapr> hmm
09:02:30 <musasabi> well I can of course use cpp..
09:02:36 <shapr> sucks that you can't refer to the Module, so "this = Foo.Bar.Baz" won't work
09:03:55 <shapr> just reading pragprog list, a guy asks about a convention where methods return a reference to their instance
09:04:08 <shapr> so that dog.bark(); dog.run(); dog.fetch(); becomes dog.bark().run().fetch()
09:04:16 <shapr> was thinking of how that would work in Haskell...
09:04:31 <shapr> my first thought was to separate the ops from the datatype
09:04:47 <shapr> (bark . run . fetch) dog
09:05:05 <shapr> but that doesn't make much sense because none of the three operations there actually evaluate to anything
09:05:10 <shapr> they're all side-effects
09:06:04 <esap> bark << run << fetch dog
09:06:21 <shapr> what's << ?
09:06:27 <shapr> just >> flipped?
09:06:30 <esap> flip (>>)
09:06:50 <esap> I mean, actually, bark dog << run dog << fetch dog
09:07:23 <shapr> can you factor out the dog there?
09:07:32 <shapr> (bark << run << fetch) dog ?
09:07:50 <esap> yes. (\d -> bark d << run d << fetch d) dog
09:08:33 <esap> That's parallel composition. You might also do bark =<< run =<< fetch dog
09:09:54 <esap> Which does it sequentially, but then of course those operations have to return their argument.
09:10:57 <esap> The sequential version has the benefit that 'fetch' operation might return a different dog than what was given to argument. So the fetch operation may delegate the responsibility to do the rest to some other dog.
09:11:19 <esap> With the parallel composition version, that is not possible.
09:13:03 * esap means 'parallel composition' only in the sense of how the context is passed on.
09:13:07 <shapr> I think I shall paste that into my reply :-)
09:14:09 <stepcut> making fonts is hard...
09:14:14 <stepcut> but fun
09:14:32 <esap> metafont stuff?
09:14:33 <bourbaki_> fonts for what?
09:14:58 <stepcut> esap, bourbaki_: metafont for the linspire logo
09:15:13 <bourbaki_> linspire?
09:15:19 <stepcut> it's not exactly the most efficient use of time, but fun none-the-less
09:15:37 <stepcut> bourbaki_: formally known as lindows... ?
09:16:01 <bourbaki_> i think i have heared of that thing once
09:16:33 <shapr> y0 Tom
09:16:34 <shapr> ltns
09:16:39 <tmoertel> hi, shapr!
09:16:43 <shapr> how's code?
09:16:58 <tmoertel> entertaining, as always.  and bizzzzeeee
09:17:11 <tmoertel> what have you been up to?
09:17:30 <shapr> er, lots and nothing, at the same time.
09:18:35 <shapr> esap: that's really cool, mind if I paraphrase this discussion in my reply (with credits to you) ?
09:18:43 <shapr> tmoertel: seen House?
09:18:57 <tmoertel> shapr: no
09:19:02 * shapr tries to think of neat new Haskell projects
09:19:04 <esap> shapr: sure, go ahead.
09:19:04 <shapr> http://www.cse.ogi.edu/~hallgren/House/
09:19:10 <shapr> esap: thanks :-)
09:19:25 <shapr> tmoertel: oh, I have a licensing question to ask you...
09:19:51 <tmoertel> shapr: ask away :)
09:19:57 <shapr> the code you put in lambdabot's Util module has been quite popular with me and some other people, is it okay to put it under the BSD license?
09:20:25 <tmoertel> shapr: I hereby license it under a dual BSD/GPL license.
09:20:27 <shapr> specifically, I'm trying to license all of http://www.haskell.org/hawiki/PreludeExts
09:20:31 <shapr> tmoertel: spiffy, thanks
09:20:37 <stepcut> tmoertel: heh
09:20:39 <esap> hmm.. the acronym doesn't match the explanation :-)
09:21:04 <stepcut> huose
09:21:19 <stepcut> :-/
09:22:58 * esap would suggest 'Haskell operating useful system and environment' :-)
09:23:40 <tmoertel> perhaps: "Haskell omnipotent user system and environment"
09:27:07 * CosmicRay afks
09:39:35 <tuomov> You could have 'huone' (Finnish for 'room') - Haskell User's OS Nucleus and Environment
10:08:10 * tmoertel heads to lunch
10:09:04 <shapr> @yow !
10:09:05 <lambdabot> You should all JUMP UP AND DOWN for TWO HOURS while I decide
10:09:05 <lambdabot>  on a NEW CAREER!!
10:11:46 <shapr> any clueful mailman virtual host users around?
10:11:54 <shapr> #mailman is quiet
10:14:37 <musasabi> shapr: I used some dirty exim magick with it, but it is ages ago.
10:15:16 <musasabi> What influence does a LGPL library have in Haskell? 
10:15:26 <musasabi> That is from a legal standpoint.
10:15:41 <shapr> er, huh?
10:16:18 <shapr> where in Haskell?
10:16:23 <shapr> in an app, in the standard, or what?
10:17:17 <musasabi> shapr: I am thinking what consequences it has if when I am wrapping an LGPL library.
10:17:37 <musasabi> I would like to keep my code BSD, but does static linking make it illegal?
10:17:43 <shapr> good point
10:19:05 <bbls> musasabi what's the main difference between BSD and GPL
10:20:13 <tuomov> gpl is "viral"
10:20:33 <bbls> what does that mean?
10:20:44 <tuomov> you can't use gpl:d code in non-gpl:d project
10:21:11 <bbls> and what about BSD?
10:21:18 <tuomov> bsd license doesn't care as long as you indicate that you use the code
10:21:24 <bbls> ah
10:21:29 <bbls> then BSD is better :)
10:21:30 <tuomov> lgpl is something between
10:21:34 <bbls> (at least in my opinion)
10:21:41 * CosmicRay returns
10:21:47 <bbls> what oter alternatives do we have?
10:21:50 <bbls> *other
10:21:51 <tuomov> you can link to lgpl code as a whole
10:22:01 <CosmicRay> are we talking about the code in the wiki?
10:22:12 <shapr> nah, musasabi's code
10:22:39 <tuomov> although, the actual wording in the lgpl text is a bit vague, and might prohibit static linking
10:22:41 <shapr> musasabi: wouldn't the wrapper be considered dynamic linking?
10:23:35 <musasabi> shapr: I don't know, I doubt it.
10:24:20 <tuomov> however, I'm not so sure about the legal validity of prohibiting linking to any kind of dynamic library
10:24:30 <tuomov> but law has never been sane
10:25:22 <tuomov> or else we wouldn't even have ip laws
10:40:47 <shapr> not sure what to do about it though
10:44:32 <musasabi> How do I specify c_includes with Cabal?
10:44:39 <xerox> yo
10:44:43 <musasabi> I need to have -#include there..
11:00:52 <shapr> this is somewhat bizarre: http://article.gmane.org/gmane.comp.lang.lightweight/3196
11:02:04 <shapr> Huh, citeseer has Nickieben Bourbaki as an author.
11:03:56 * musasabi does not understand that very well
11:06:37 <musasabi> Now it seems that the last bit is telling Cabal somehow to link against libfoo.a
11:07:34 <netd> hello
11:07:39 <shapr> hej netd 
11:08:01 <shapr> netd: have you been here before?
11:08:09 <netd> yes
11:08:14 <shapr> ok
11:08:46 <netd> why do you ask?
11:09:11 <shapr> because if you haven't been here before, I'll give you the quick #haskell tour and short Haskell language intro.
11:09:25 <shapr> but this time, you've been saved from that whirlwind ride...
11:10:07 <netd> uhm, ok :)
11:10:30 <thebug> ha!
11:10:33 * shapr grins
11:10:44 <thebug> mr. shapr's wild haskell ride
11:10:53 * shapr boings
11:11:11 <thebug> replete with spinning cars, trains, and crashing through lambdas ;)
11:11:25 <shapr> wheee
11:12:05 * Oejet_ gets squashed by shapr as usual, while he boings.
11:12:12 * shapr unboings
11:20:12 * shapr hOps around Oejet_ 
11:21:17 <shapr> esap: seems that Smalltalk ensures that cascaded methods are always called with the original object
11:21:39 <shapr> surprising how similar that is to the Haskell version
11:23:45 <esap> shapr: hmm.. interesting.
11:24:18 <esap> shapr: I haven't actually ever used Smalltalk, though sometimes I wish I had.
11:24:41 <shapr> I've used Squeak a bit.
11:24:56 <phubuh> cascaded methods?
11:25:35 <shapr> "just reading pragprog list, a guy asks about a convention where methods return a reference to their instance so that dog.bark(); dog.run(); dog.fetch(); becomes dog.bark().run().fetch()"
11:25:52 <shapr> so I asked esap how that would work in Haskell
11:25:58 <phubuh> aha
11:26:13 <phubuh> smalltalk returns self if nothing else is explicitly returned
11:26:20 <shapr> right
11:26:31 <shapr> and that ends up looking monadic
11:26:36 <shapr> that's what I was remarking about
11:26:48 <phubuh> :)
11:27:01 <shapr> it also feels very functional
11:27:20 <shapr> python returns None by default
11:27:27 <shapr> what does Java do?
11:27:28 <phubuh> chained message sends in smalltalk look so neat, too
11:27:31 <shapr> or other languages?
11:27:41 <phubuh> "dog bark run fetch"
11:27:56 <phubuh> i think java doesn't return anything implicitly
11:28:02 <phubuh> you can only omit return in void methods
11:29:16 <phubuh> hm, now i feel like playing around with squeak :)
11:30:04 <shapr> seems that ObjC does the same thing
11:30:18 <phubuh> returns self?
11:30:33 <shapr> I think so
11:30:49 <shapr> pragprog mailing list stays interesting at least
11:30:58 <phubuh> neat
11:34:05 * CosmicRay itp's haskell-devscripts
11:36:29 <shapr> CosmicRay: hey, can I offer you one free dose of darcs? ;-)
11:36:49 <dblhelix> shapr: why does it look _monadic_ to you? "function composition" is what comes up in mind for me
11:36:51 <shapr> the first one comes free man... just try it...
11:37:08 <shapr> dblhelix: good point
11:37:14 <shapr> oh I know why
11:37:32 <shapr> because monads are function composition too if the state is explicitly passed
11:37:44 <dblhelix> (fetch . run . bark) mydog
11:37:50 <shapr> with the dog.bark() etc commands, they did not return a result, they only perform side-effects
11:38:05 <shapr> but bark doesn't eval to a barked dog
11:38:34 <dblhelix> okay, I see what you are getting at ...
11:38:54 <CosmicRay> shapr: no thanks, I have enough arch for now :-)
11:39:03 * shapr tokes on his darcs
11:39:11 <shapr> it's totally cosmic!
11:39:32 <shapr> arch is just a stepping stone scm...
11:39:38 <shapr> try the hard stuff
11:39:48 * shapr snickers
11:39:59 <shapr> man, I'm glad I'm not a teacher or prof
11:40:04 <musasabi> darcs is nice and simple.
11:40:04 <shapr> I'd get busted for saying stuff like that.
11:40:07 <shapr> hoi goron 
11:40:34 <goron> I was searching for a userbase of Concurrent Clean, but I can't seem to find one... :p
11:40:38 <goron> hej
11:40:46 * CosmicRay is a little stunned how much Perl he remembers, after not using it for four years
11:40:49 <CosmicRay> also a little scared.
11:40:52 * dblhelix goes catching up his reading: simonpj & co's piece on type inference for GADT's ...
11:41:24 <shrimpx> wagle: you around?
11:42:06 <goron> Does anyone here know of a mailinglist a la haskell-cafe?
11:42:18 <wagle> shrimpx: yes, but working on a paper with a 1pm deadline
11:42:18 <shapr> for Concurrent Clean? or for what?
11:42:27 <goron> shapr: yes
11:42:39 <shapr> not me, but you might ask xkb when he's around
11:43:01 <goron> I am not planning to leave Haskell, yet ;)
11:43:31 <shapr> goron: well, we all use what we like, so if Clean is good for you...
11:43:48 <shapr> I'm sure Haskell won't be my favorite language in twenty years.
11:43:52 <shapr> At least, I hope not.
11:44:03 <shapr> I hope SPJ and friends will have written something better.
11:45:08 <shapr> yay, magnatune has 25 new albums
11:49:08 <goron> shapr: What kind of language do you expect? I don't think the language is that bad, although the implementation could be better.
11:51:32 <shapr> goron: a language based on arrows as the native abstraction with a simpler monadic layer on top of that, support for nested data parallelism at least, if not completely transparent parallelism. 
11:51:42 <shapr> I expect a built-in incremental mode where I can pass program fragments and get back type info and more
11:51:58 <shapr> goron: this could be a very long list, are you sure you want to hear it all? :-)
11:54:40 <goron> shapr: yes, my computer has lots of space left.
11:54:47 * shapr grins
12:00:37 <shapr> I'm not sure how to mix reflection with something like Haskell, but I'd sure like to see some attempts
12:00:56 <shapr> better metaprogramming, Template Haskell is cool but not the end of the road.
12:01:13 <shapr> flawless I18N support
12:02:10 <musasabi> better records.
12:02:19 <musasabi> better support for serialization.
12:03:10 <shapr> of course, these are small goals for the next twenty years.
12:07:37 <goron> I was reading about space leaks, after the discussions on haskell-cafe, and got irritated about not knowing what it exactly is. And I think I begin to understand what it is. Is it ok to say that space leaks are caused by the size of a lot of environments of closures that are needed for complete evaluation. So for example this is a function that causes a space leak: f aa ab ac .. zz = z (zz) ..(a (aa)) (I hope the syntax is clear.)
12:16:54 <CosmicRay> w00t.
12:16:56 <CosmicRay> dh_haskell works.
12:19:24 <goron> Did anyone got my 6 line message? Or was it blocked?
12:19:30 <CosmicRay> I saw it
12:19:34 <goron> ok
12:19:44 <CosmicRay> I have no idea what the answer is, but I saw it :-)
12:25:13 * phubuh would like to see a lazy purely functional language with s-expression syntax :)
12:27:25 <musasabi> goron: I understand with space leaks programs which should not leak memory seemingly leaking memory.
12:27:48 <musasabi> goron: unevaluated closures are often a reason.
12:31:11 <goron> musasabi: So *very* deep recursion is an example of that? 
12:34:37 <CosmicRay> re
12:36:45 <SyntaxNinja> y0 CosmicRay
12:41:41 <musasabi> goron: yes, if it shouldn't leak space.
12:42:07 <musasabi> goron: e.g. a recursion that by all means should be O(1) becoming O(n) (in space terms)
12:42:16 <musasabi> that is if I understand things correctly.
12:42:40 <musasabi> "final link ... ./qdbm.o: unhandled ELF relocation(Rel) type 10"
12:43:05 * shapr sings about the final linkdown
12:43:24 <musasabi> ghci must love me.. This was with an object file produced with "ld -r --whole-archive" like the docs tell..
13:32:02 <bourbaki> hi
13:32:49 <Lemmih_> Yo
13:33:02 <bourbaki> yo?
13:34:15 <Lemmih_> It's a greeting...
13:34:19 <lmbdwr> salut
13:34:53 <bourbaki> i thoungt that it was just used in the ghetto ;)
13:36:23 <CosmicRay> what did you think IRC is?
13:36:34 <xerox> a protocol'
13:45:47 <bourbaki> heh
14:05:15 <CosmicRay> can someone tell me how hugs-package is supposed to be used?
14:07:02 <SyntaxNinja> hugs-package doesn't do what ghc-pkg does, fwiw.
14:07:07 <CosmicRay> ah.
14:07:09 <SyntaxNinja> I'd have to think to remember what it does exactly
14:07:26 <SyntaxNinja> I think maybe it "prepares the source" by preprocessing and maybe doing a couple ot her things
14:07:33 <SyntaxNinja> maybe swallowing it into its belly or something
14:08:13 <SyntaxNinja> the cabal proposal calls for {ghc,nhc,hugs}-pkg (called HC-PKG in the proposal) and ross patterson has agreed to write one
14:08:34 <SyntaxNinja> I wrote a prototype some time back that might be a good starting point; the three packages could likely use much of the same code.
14:09:26 <CosmicRay> ok.
14:09:37 <CosmicRay> I'm noticing that for hugs, setup build will copy sources into dist
14:09:40 <CosmicRay> but then dies with error 1
14:10:20 <CosmicRay> only registering with GHC is implemented
14:10:48 <SyntaxNinja> right
14:10:58 <SyntaxNinja> hugs, if I recall, has no sense of a package yet
14:11:16 <SyntaxNinja> so there's no meaningful registration step, only moving the source into a particular location.
14:11:30 <CosmicRay> yup
14:11:37 <CosmicRay> that's exactly how I'm going to support it in dh_haskell.
14:12:14 <SyntaxNinja> are you doing so via cabal? if the return code is a problem, I can change that.
14:12:36 <CosmicRay> no, I'm ignoring that, and then doing "cp -rv dist/build/* $tmp/usr/lib/hugs/libraries/
14:12:52 <CosmicRay> (for hugs)
14:13:00 <CosmicRay> I use ./setup install for ghc[56]
14:13:14 <CosmicRay> no nhc98 yet for obvious reasons
14:13:24 <SyntaxNinja> why not use ./setup install for hugs?
14:13:39 <CosmicRay> hmm.
14:14:07 <CosmicRay> because it doesn't put things at the right place for hugs.
14:14:25 <CosmicRay> it insists in lib/Package-Version/*.hs
14:14:33 <CosmicRay> hugs wants it in /usr/lib/hugs/libraries
14:15:00 <CosmicRay> btw it would be nice to be able to tell it to use just prefix/Package instead of prefix/lib/Package-Version
14:16:32 <SyntaxNinja> one win for getting it into sid is that you can file bug reports against it :)
14:16:39 <CosmicRay> bwahahaha
14:16:55 <CosmicRay> BWAHAHAHAHAHA
14:17:04 * CosmicRay shuts up
14:17:37 <SyntaxNinja> I wish that I could tell hugs to look at something like /etc/hugs/includes in order to construct its search path, that way we could stick the files wherever we want 
14:17:46 <SyntaxNinja> I wrote a little shell script to do that
14:18:01 <SyntaxNinja> btw, hugs-package does have a man page :)
14:18:36 <CosmicRay> yes but it doesn't say what it *does*
14:18:39 <CosmicRay> it "converts".
14:18:41 <CosmicRay> pfft.
14:18:46 * SyntaxNinja nods
14:18:57 <SyntaxNinja> I think it basically preprocesses... can't remember for sure
14:25:56 <CosmicRay> kick ass.  dh_haskell has built ghc5, ghc6, and hugs packages for hunit.
14:39:55 * CosmicRay releases hunit.
17:13:18 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'
17:13:18 --- topic: set by shapr on [Tue Sep 21 09:26:31 2004]
17:21:35 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'
17:21:35 --- topic: set by shapr on [Tue Sep 21 09:26:31 2004]
17:28:17 <marcot> Hello, I'm a very begginer at haskell and have a silly doubt. I'm reading the haskell tutorial, and it sais me to use the ord function, but I'm getting undefined variable when I use it.
17:28:48 <CosmicRay> hmm.  must be in a library somewhere
17:29:00 <CosmicRay> try "import Char"
17:29:02 <CosmicRay> and then use it
17:30:34 <marcot> CosmicRay: it worked. Thank you! =)
17:30:41 <CosmicRay> no problem
17:30:53 <CosmicRay> marcot: there is a library reference at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
17:31:37 <marcot> Thanks.
17:36:22 <CosmicRay> SyntaxNinja: speaking of testing...
17:36:30 <CosmicRay> are you aware of any literate testing tools?
17:36:44 <CosmicRay> where test cases and expected results are coded as comments
17:37:08 <SyntaxNinja> CosmicRay: no; have you looked at quickCheck at all?
17:37:14 <Igloo> Why not code them as...code?
17:37:28 <CosmicRay> Igloo: because they can be both examples and tests
17:37:39 <CosmicRay> for instance, in Python docs, you'd often see something like this>
17:37:46 <CosmicRay> "For example:
17:37:52 <CosmicRay> foofunc(5) -> "five"
17:37:58 <CosmicRay> foofunc(6) -> "six"
17:37:58 <CosmicRay> "
17:38:06 <CosmicRay> it's documentation and it's test.
17:38:28 <CosmicRay> SyntaxNinja: I have looked at quickcheck
17:39:15 <CosmicRay> SyntaxNinja: to be honest I couldn't figure out how it would be more accurate than unit testing -- since I'd be writing every algorithm twice, I may make the same mistake twice
17:39:26 <CosmicRay> I'd rather test with known cases and tough corner cases
17:40:08 <SyntaxNinja> CosmicRay: I use both.
17:40:22 <SyntaxNinja> sometimes, generating input is annoying
17:40:46 <Igloo> It's useful if you can easily write a very inefficient version, or if you have a spec maybe written in another language (e.g. this should do the ame as C's printf)
17:40:56 <CosmicRay> ah.
17:41:22 <CosmicRay> in most cases these are novel algorithms already written for clarity, not speed
17:41:27 <Igloo> Priority queues are the canonical examples of where you can easily write an inefficient, simple one using lists
17:41:31 <CosmicRay> so I supose I wouldn't gain much
17:41:46 <CosmicRay> but now I see why some would
17:43:14 <Igloo> Also, you can check decimal_to_roman . roman_to_decimal == id and vice-versa
17:44:02 <CosmicRay> yes, though you may have bugs in both conversions
17:44:20 <CosmicRay> for instance if you typod an O for an I in both functions
17:44:24 <Igloo> Yeah, it's obviously never going to be perfect
17:44:40 <Igloo> You can also write incorrect unit tests
17:45:03 <Igloo> foo [] = 0 instead of 1 in both the test and the code, say
17:45:05 <CosmicRay> true
18:02:20 <CosmicRay> SyntaxNinja: how do I tell cabal how to run my test suite?
18:08:01 <marcot> What's the difference from foldr and foldl?
18:09:31 <Cale> one of them is left associative, and the other right associative
18:10:34 <Cale> you'll see the difference if you fold using something like -, where the way in which you group the terms matters
18:10:41 <marcot> Cale: ok. So it's only different in functions that treat these parameters differently..
18:10:56 <marcot> Cale: thanks.
18:11:10 <Cale> It's also different in that foldr can be used with infinite lists, while foldl cannot.
18:11:31 <Cale> But foldl often gets somewhat better performance.
18:12:33 <marcot> Cale: ok.... I'll try to understand that better latter, when I know a little bit more about haskell.
18:14:11 <marcot> good night for all.
18:17:54 <SyntaxNinja> CosmicRay: there's no built-in support yet
18:29:10 <CosmicRay> oh, I thought I read in the docs about a ./setup test command
18:32:07 <SyntaxNinja> yep. it's not implemented yet
18:33:10 <CosmicRay> ah
18:33:11 <CosmicRay> gotcha.
18:34:12 <SyntaxNinja> maybe we could add a 'defaultMainWithTest :: IO () -> ..."
18:34:22 <SyntaxNinja> that just ran the IO action when they run ./setup test
18:35:18 <SyntaxNinja> there's the obvious n * m problem of having too many "defaultMainFoo" functions, though, but there are plenty of ways around that.
18:52:23 <SyntaxNinja> is the macro HAVE_UNIX_PACKAGE actually defined, or is it pure fantasy?
18:52:40 <SyntaxNinja> (presumably for systems with Posix)
19:46:29 <robs> i want to do something like that: >inverse (h:x) = (1 / h) : inverse(x) the input list is type [Int] and i want a output type [Double]..how can i do that?
19:47:19 <Pseudonym> @type fromInt
19:47:21 <lambdabot> bzzt
19:47:24 <Pseudonym> Hmm,
19:47:30 <Pseudonym> @type fromInteger
19:47:32 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
19:47:36 <Pseudonym> There we are.
20:01:25 <robs> hmm what's the difference between Int and Integer? i changed everythin to Integer because fromInteger is expecting that...now i get an error "Instance of Fractional Integer required for definition.."
20:03:18 <Igloo> You wanted fromIntegral
20:03:30 <Igloo> You're probably applying it too late
20:03:39 <Igloo> You have to convert it before you do the division
20:03:51 <juhp> robs: Int is finite
20:03:54 <robs> oh.. :)
20:07:55 <robs> hmm i don't get it... >inverse (h:x) = (1/fromIntegral(h)) : inverse(x) <-- what's wrong with that?
20:08:57 <Igloo> What makes you think something is wrong with it?
20:09:17 <robs> because hugs tell me so :)
20:09:27 <Igloo> You don't need parentheses around the h or x on the right hand side, BTW
20:09:36 <robs> kk
20:12:21 <robs> ah rofl
20:12:26 <robs> i'm too dumb
20:13:09 <robs> it's working now :) thx!
20:28:47 <yome> Hi, anyone knows of a way for Hugs to evaluate a file and have it returns an 'exit code' to the Shell?
20:29:05 <yome> In particular, I'd like to be able to distinguish if there has been an error during the evaluation of a file.
20:29:32 <yome> I also want to return some Int value.
20:30:24 <yome> I'd like to "batch" the execution of haskell programs on different inputs.
20:30:27 <yome> Any pointers?
20:31:38 <SyntaxNinja> yome: have you seen the exitWith function?
20:31:52 <yome> SyntaxNinja, no I didn't know about it.
20:31:55 <SyntaxNinja> I'm not sure I'm understanding what you want to do. 
20:32:24 <yome> Ok. I have to do a small "automatic" correction script for ~150 programs written by students.
20:32:43 <yome> I want to feed some arguments to their function and make sure they get the right answer.
20:32:59 <yome> So I'm trying to 'script' hugs to do that.
20:33:17 <SyntaxNinja> btw: http://www.haskell.org/ghc/docs/latest/html/libraries/
20:33:24 <SyntaxNinja> hm
20:34:15 <SyntaxNinja> so you want to basically write a little test harness, and bash will have hugs compile it, and you want to exit with a failure if the output doesn't match the expected output?
20:34:32 <yome> SyntaxNinja, yeah, that's about it.
20:34:50 <yome> Do you have any suggestions?
20:34:51 <SyntaxNinja> you might find HUnit interesting, btw.
20:35:23 <yome> Reading HUnit's doc...
20:35:47 <SyntaxNinja> yeah, I'd just write your test harness with something like "main = if theirFunction myInput /= myOutput then exitWith ExitFailure else exitWith exitSuccess"
20:36:06 <SyntaxNinja> not sure that HUnit gets you much further if you're just testing one function.
20:37:13 <yome> Yeah, I'm only testing one function per file.
20:37:29 <yome> By the way, thanks for the great suggestions.
20:42:11 <SyntaxNinja> yome: no problem.
21:40:37 <musasabi> morning
22:56:16 <Pseudonym> Ah, where's clausen when you need him.
23:02:00 <musasabi> How can I express a constraint like: data (Dump k, Dump v) => Depot k v = Depot (ForeignPtr DEPOT)
23:02:32 <musasabi> that is the k and v should be allways in Dump.
23:03:31 <musasabi> so I could write code like "exists :: Depot k v -> k -> IO Bool" which deduces that k is an instance of Dump.
23:36:56 <musasabi> Is this a bug in GHC(i) ":t maybe (return Nothing) (readIO)" infers "Read (Maybe a)" instead of "Read a" 
23:41:47 <musasabi> missing Just causes that, weird error in any case.
23:54:28 <shapr> yow!
23:54:35 <musasabi> hello shapr 
23:54:52 <shapr> hei musasabi 
23:55:50 <shapr> good hyperactive morning to you.
23:56:03 <Pseudonym> Greetings.
23:56:11 <shapr> y0 Pseudonym
23:56:21 <shapr> how's the flow?
23:56:38 <Pseudonym> Pretty good.
23:56:44 <shapr> new mpeg?
23:56:57 <Pseudonym> Hang on a sec, I'll upload it.
23:57:42 <Pseudonym> http://andrew.bromage.org/fluid.mpeg
23:57:49 <Pseudonym> Unfortunately, it doesn't run for long enough.
23:58:04 <Pseudonym> But the test shows a block of cold fluid inside an area of warm fluid.
23:58:13 <Pseudonym> So you get to watch the cold fluid sink.
23:59:11 <shapr> neat
