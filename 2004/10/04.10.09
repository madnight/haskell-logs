00:00:37 <Helicopter> what does the "object instantiation" test mean for haskell ?
00:01:41 <shrimpx> dunno
00:02:13 <shrimpx> also it's funny that java sucks at exceptions, seeming how they're barely used in average java code
00:02:49 <Helicopter> I thought they were meant to be used all over
00:04:08 <Helicopter> what's the rationale behind allowing an exception entry for gcc ?
00:04:10 <shrimpx> ya, sarcasm
00:04:51 <Helicopter> try { doLotsaStuff(); } catch (Exception e) { /* never happens */ }
00:07:16 <musasabi> Helicopter: I implemented it resembling the way other languages do it.
00:07:47 <Helicopter> musasabi: you entered the gcc exception entry ?
00:07:56 <musasabi> Helicopter: no the haskell objinst.
00:08:07 <Helicopter> oh
00:08:43 <musasabi> Helicopter: one would not probably write such code for a real haskell program, but it is imho quite near what the OO languages do.
00:08:54 <Helicopter> hi Einar Karttunen ?
00:09:08 <musasabi> yep.
00:09:47 <musasabi> btw how do module boundaries affect inlining in ghc ?
00:10:55 <Helicopter> I think the test is flawed. "hello world" is an objective for a progam. Object Instantiation is a step in a method in a particular group of languages. If you force alll languages to implement it, even if they don't really use it, I expect java to use Monads.
00:11:40 <Helicopter> and I'll weight it 5 points too
00:12:39 <musasabi> Sure but that would lead to all languages implementing only the tests that are best to them.
00:12:52 <Helicopter> no, most of the tests are real little projects
00:13:06 <Helicopter> wc, reverse a file, random number generator, fibonacci, etc.
00:13:30 <musasabi> Helicopter: e.g. all the test involving input are much more a problem from haskell perspective.
00:13:59 <musasabi> Helicopter: as in practise one writes/uses an efficient abstraction for that, but that doesn't exist in the language proper.
00:14:02 <Helicopter> you can allow data to be put in the source
00:14:32 <musasabi> Helicopter: that won't save haskell.
00:14:44 <Helicopter> it's not really meant to save it
00:14:51 <musasabi> String is not suitable for serious purposes ;)
00:15:28 <Helicopter> that's ok, and it's ok if haskell sucks at it. It is still better than forcing haskell to mimic object instantiation as if it means anything
00:16:30 <Helicopter> in benchmarking of CPU's, even the so-called 'synthetic tests' borrow code from real life programs. They don't just write a dumb loop and measure.
00:16:34 <musasabi> Well haskell sucking in that is only because in real life one would just use something like FastPackedString or BlockIO.
00:17:21 <musasabi> Helicopter: many of the CPU tests are unnnecessary ugly in haskell to force evaluating things the correct amount of times.. 
00:17:56 <musasabi> Helicopter: and it is very good to see how languages fare with different things.
00:18:12 <Helicopter> yeah it's educational
00:18:47 <Helicopter> anyways. nite #haskell
00:19:43 <shrimpx> the thing with ghc is, it's "fast enough" for most naturally encoded programs, and gives you many ways to squeeze out performance, should you really need it
02:57:47 <Lor> Morning, folks.
02:58:03 <bbls> hi
03:00:32 <Lemmih> Yo
03:10:44 <tromp> g'morning
03:10:59 * esap just woke up as well.
03:51:02 <Boegel> hello everyone
03:51:19 <Boegel> can someone tell me where I can find the syntax highlight file for Haskell in emacs ?
03:54:05 <Lemmih> There's a Haskell-mode somewhere.
03:54:20 <Boegel> yeah, but where :)
03:54:25 <Lemmih> http://www.haskell.org/haskell-mode/
03:54:35 <Boegel> http://www.haskell.org/haskell-mode/
03:54:37 <Boegel> damn
03:54:39 <Boegel> too late :p
03:54:48 <Lor> apt-get install haskell-mode :)
03:55:27 <Boegel> Lor: eh ?
03:59:53 <Lor> That's just the standard debian brag. Never mind. :)
04:18:34 <shapr> y0
04:19:56 <Lemmih> Any opengl gurus around?
04:20:56 <bbls> try opengl channel
04:20:58 <bbls> :)
04:23:44 <Lemmih> I'm using HOpenGL and I'm not sure 'textureFunction $= Blend' is the same thing as 'glEnable(GL_BLEND)'.
04:24:24 <bourbaki> hi
04:24:25 <bbls> hmm
04:24:26 <Lemmih> Hey
04:24:55 <Lemmih> Isn't there a one-to-one mapping somewhere?
04:25:06 <bbls> GL_BLEND
04:25:13 <bbls> just enables/disables blending i think
04:25:40 <bourbaki> hi Lemmih :)
04:25:42 <bbls> (if GL_BLEND is disabled then the alpha doesn't count, all poly's are opaque)
04:25:52 <bbls> (alpha = 1.0)
04:29:00 <bourbaki> arent they all solid then?
04:29:32 <Lemmih> bbls: That's not it.
04:30:10 <bbls> bourbaki yes
04:30:17 <bbls> Lemmih what do you mean?
04:31:18 <Lemmih> Is GL_BLEND enabled by default?
04:31:27 <bourbaki> isnt opaque the opposite of solid?
04:31:51 <bbls> not to my knowledge
04:31:58 <bbls> (at least in romanian)
04:32:04 <bbls> transparent is the opposite of solid
04:32:26 <bourbaki> i thought opaque was similar to transparent i need to consult my dict
04:32:34 <bbls> Lemmih hmm, have no ideea, i always enable/disable it on my needs. but i think that's disable
04:32:49 <Lemmih> bbls: How do you change it's state?
04:32:59 <Lemmih> *its
04:33:18 <bbls> glEnable(GL_BLEND) :)
04:33:31 <Lemmih> Well in HOpenGL of course.
04:33:43 <bbls> ah, i don't know about that :)
04:34:05 <bourbaki> Lemmih: which version of hopengl do you use?
04:34:32 <bourbaki> i think i had similar probs with that old verison that is delivered with ghc on windoze
04:35:08 <Lemmih> bourbaki: I installed GHC from cvs.
04:35:19 <bourbaki> damn i cant remember where all these samples have been i had to search quite a bit for them but i wasnt able to compile them with that old version
04:37:47 <bourbaki> Lemmih: arent there like a lot of samples shipped with the source?
04:39:38 <Lemmih> Yes.
04:41:37 <bourbaki> Lemmih: and there is no blend stuff?
04:42:03 <bourbaki> i can see a blendeq.hs though thats not exactly what you want
04:42:36 <Lemmih> In the Redbook examples?
04:43:13 <bourbaki> yes
04:43:26 <bourbaki> -rw-r--r--    1 ham      ham          3268 Dec 27  2002 BlendEqn.hs
04:43:50 <bourbaki> i just downloaded Hopengl 1.05
04:43:58 <bourbaki> http://www.haskell.org/HOpenGL/releases/HOpenGL-1.05.tar.gz
04:46:06 <Lemmih> AFAIK GL_BLEND is only used for texture blending.
04:47:06 <bourbaki> hm i cant remember from top of my head if there is an example in the redbook
04:48:19 <Lemmih> There isn't.
04:49:36 <bourbaki> hm ok then the examples wont help
04:50:12 <bourbaki> Lemmih: you could write the guy a mail
04:50:47 <dtb> hey all - i have a list (1,2,3,4,5) - how can i generate all possible combinations of that list? ie (1,2,3,4,5),(1,2,3,5,4),(1,2,5,4,3),etc..
04:51:28 <Lemmih> dtb: Check the PreludeExts on the wiki.
04:52:26 <dtb> O__o  lolz - im extremely new to haskell .. PreludeExts ? wiki ? :/
04:54:06 <arjanb> @wiki PreludeExts
04:54:42 <Lemmih> Lambdabot is gone?
04:54:50 <arjanb> http://haskell.org/hawiki/PreludeExts
04:55:07 <dtb> thx
04:56:14 <bourbaki> has anyone fetched ghc and hopengl via debian?
04:57:18 <Lemmih> I have.
04:57:38 <bourbaki> i just got the latest ghc6 package and ghc6-hopengl
04:57:58 <Lemmih> You should get ghc-cvs-hopengl
04:58:03 <bourbaki> and i cant compile the sample files since he again cant find the GL stuff
04:58:04 <bourbaki> ok
04:59:56 <bourbaki> 126mb o.O?
05:01:37 <Lemmih> Isn't it 12mb?
05:01:55 <bourbaki> its 18mbNeed to get 18.5MB of archives. After unpacking 126MB will be used.
05:02:38 <bourbaki> my poor hd :) i have just 7 gigs
05:03:10 <kristnjov> 337 gigs here
05:03:31 <bourbaki> wow what do you install there?
05:04:25 <bourbaki> Lemmih: i still get the same errors
05:04:27 <bourbaki> Tess.hs:23:
05:04:27 <bourbaki>     Failed to load interface for `GL':
05:04:27 <bourbaki>         Could not find interface file for `GL'
05:04:56 <Nighthawk> hi
05:05:00 <bourbaki> hi
05:05:09 <Lemmih> bourbaki: What example are you compiling?
05:05:19 <bourbaki> Lemmih: Tess.hs
05:05:21 <kristnjov> bourbaki, i don't install, i store
05:05:35 <bourbaki> i got that from the gz file of the net
05:05:44 <Lemmih> bourbaki: It's too old.
05:05:58 <bourbaki> Lemmih: ? too old i just fetched it
05:06:18 <Lemmih> The Redbook examples you got are too old.
05:06:55 <bourbaki> well its included in the latest hopengl file
05:07:36 <Lemmih> The new HOpenGL is included with GHC. You've downloaded the old one.
05:08:16 <bourbaki> ok im a bit confused now i just apt-get installed ghc6 and ghc6-cvs-hopengl
05:09:05 <Lemmih> Good. Then get some examples that utilized the new API.
05:09:21 <bourbaki> hm and where?
05:10:03 <bourbaki> im always confused by hopengl i expect 1.05 the latest version but you cant compile it out of the box with the deb packages
05:10:13 <Lemmih> GHC CVS.
05:12:26 <bourbaki> but the problem is that he cant find the imports isnt it?
05:12:54 <Lemmih> To whom are you refering?
05:13:02 <bourbaki> to you :)
05:13:26 <Lemmih> I can't find the imports? You've really lost me now.
05:13:58 <bourbaki>     Failed to load interface for `GL':
05:14:48 <bourbaki> thats what i get when i try to use ghc Tess.hs isnt that due to the fact that he cant find the GL file
05:15:23 <Lemmih> That are now in Graphics.UI.GLUT. That's why you should get some examples that apply to the new HOpenGL API.
05:15:34 <Lemmih> s/That/They/
05:15:41 <bourbaki> Failed to load interface for `Graphics.UI.GLUT':
05:16:20 <bourbaki> and thats the newest api these are the latest example files from the website
05:16:24 <Lemmih> Are you using the new GHC you just installed or the old <= 6.2.1?
05:16:46 <bourbaki> hm good question sec
05:17:05 <Lemmih> You should run ghc-cvs and not just ghc.
05:17:45 <Igloo> ghc6 also comes with hopengl
05:17:46 <Lemmih> Uf My english is bad /-:
05:17:59 <Lemmih> Igloo: But that's the old one right?
05:17:59 <bourbaki> Lemmih: where are you from?
05:18:06 <Lemmih> I'm from Denmark.
05:18:07 <Igloo> "old one"?
05:18:20 <bourbaki> hm well i used ghc621
05:18:28 <Igloo> It's not /different/ from the CVS one AFAIK, just a bi less complete
05:18:34 <Lemmih> Igloo: <= 1.05
05:18:57 <Igloo> No idea
05:19:17 <bourbaki> hm im really confused now
05:19:34 <bourbaki> he just wont find the imports ...
05:20:26 <Lemmih> bourbaki: Try running ghci-cvs
05:21:08 <bourbaki> Lemmih: hm ok now he just cant find the GLU thingy so i guess you are right with the examples
05:21:36 <bourbaki> but thats so confuseing cause i expect the latest files on the net to be able to compile there ...
05:21:37 <Lemmih> Igloo: As I've understod it, 1.05 is really incomplete but the one in CVS has full OpenGL 1.5 support just without nurbs.
05:22:03 <Lemmih> bourbaki: You should _not_ download anything from www.haskell.org/HOpenGL/
05:22:42 <bourbaki> Lemmih: can i browse the example files on the internet too? the cvs ones
05:22:56 <Lemmih> Yes.
05:23:14 <bourbaki> and where can i browse them?
05:23:30 <Lemmih> One moment...
05:23:37 <bourbaki> thanks
05:24:02 <Lemmih> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/GLUT/examples/RedBook/
05:24:26 <bourbaki> thats what really bothered me on lx and hopengl ... i wasnt able to figure out what matches what
05:24:59 <Lemmih> lx?
05:25:09 <bourbaki> linux
05:27:02 <kristnjov> http://www.nomorepasting.com/paste.php?pasteID=22304 <- any help appreciated!
05:27:18 <Lemmih> That shouldn't be a problem anymore since hopengl is a part of the hierarchical libraries.
05:31:04 <bourbaki> Lemmih: thanks
05:31:14 <Lemmih> So it's working?
05:31:40 <bourbaki> it seems so yes :)
05:33:33 <Lemmih> Yay!
05:33:37 <bourbaki> :)
05:40:05 <shapr> cool, this dutch girl unicycles too
05:40:12 <kristnjov> lol
05:40:16 <kristnjov> you and your unicycling
05:40:43 <shapr> kristnjov: you realize I'm going to teach you next summer, right?
05:40:50 <kristnjov> what, you are?
05:40:54 <shapr> sure
05:41:00 <kristnjov> what are you going to teach me?
05:41:02 <shapr> see, you thought you were safe...
05:41:09 <shapr> I'm going to teach you to unicycle.
05:41:10 <bourbaki> :)
05:41:12 <kristnjov> :P
05:41:19 <Philippa> or rather, how to fall over in 100 different interesting ways
05:41:20 <bourbaki> i have 2 tires :)
05:41:22 <kristnjov> thought you meant some programming languages
05:41:27 <shapr> kristnjov: sure, that too
05:41:34 <shapr> but first, the easy part
05:41:54 <shapr> programming is hard, but unicycling is easy.
05:42:05 <kristnjov> how come you like haskell and unicycling so much?
05:42:18 <shapr> well, because they're fun?
05:42:22 <kristnjov> lol :)
05:42:26 <shapr> plus, they're not the only things I like.
05:42:29 <kristnjov> haskell is fun indeed, but unicycling...
05:42:35 <bourbaki> shapr: are you gonna write a song?
05:42:39 <shapr> I like to sing, write poetry, stories, songs..
05:42:44 <bourbaki> "i want to ride my unicycle"
05:42:50 <kristnjov> bourbaki hehe
05:42:52 <shapr> I read a lot, I listen to music.
05:42:57 <kristnjov> what kind of music?
05:42:58 <shapr> I learn swedish :-)
05:43:19 <shapr> jag kan tala mycket svenska för bara två år
05:44:20 <shapr> kristnjov: rage against the machine, bob marley, tori amos, nine inch nails, crystal method, jimmy eat world, drevo ( the ukrainian accapello christian songs from the 12th century)
05:44:26 <shapr> lots of stuff
05:44:42 <shapr> Wicked Boy is my favorite swedish artist.
05:45:07 <shapr> kristnjov: bah, you missed it :-P
05:45:20 <kristnjov> what, your swedish?
05:45:38 <shapr> and my list of musical artists... but it's in the channel logs
05:45:47 <bourbaki> heh
05:46:00 <bourbaki> i just got myself the new prodigy
05:46:13 <bourbaki> and all my neighbours listen to it too all day ;)
05:46:17 <shapr> hah
05:46:41 <bourbaki> its quite strange that they havent complained yet
05:47:00 <shapr> maybe you just couldn't hear them complaining
05:47:19 <Philippa> is the new prod any good? Fat of the Land was just a bit disappointing
05:47:34 <bourbaki> hehe yeah well if someone uses the doorbell i wont hear it
05:47:50 <bourbaki> well i like it but i also liked the fat of the land
05:47:55 <bourbaki> not anything but most of it
05:48:07 <kristnjov> the new prodigy is their best album to this day
05:48:11 <bourbaki> there is just a little hand full of cds that i like completely
05:48:27 <bourbaki> i think its a bit monotonous
05:48:30 <shapr> I like all Nine Inch Nails, all Jimi Hendrix, all Led Zeppelin
05:48:37 <bourbaki> there is little difference in all the songs imho
05:48:50 <bourbaki> i like all mr bungle cds
05:48:53 <kristnjov> shapr, you like manson?
05:48:53 * Philippa probably listens to Experience more than any of the other stuff atm, though Jilted Generation gets a fair lookin once in a while
05:49:04 <shapr> kristnjov: not so much
05:49:08 <Philippa> then again, I've got Timo Maas on atm
05:49:09 <kristnjov> hehe okay
05:49:14 <shapr> though manson has some good tracks
05:49:16 <kristnjov> was just wondering since trent discovered manson
05:49:20 <kristnjov> i have like 40 manson records
05:49:22 <bourbaki> Philippa: whats that?
05:49:32 <bourbaki> 40 manson records??
05:49:35 <kristnjov> three-five different versions of a few singles and so on :P
05:49:44 <kristnjov> a couple of imports and stuff
05:49:48 <bourbaki> ah ok
05:50:11 <kristnjov> i bought a japanese fight song single (rare tracks it says on the cover) for like $40
05:50:13 <shapr> I have 45GB of music on my drive.
05:50:19 <kristnjov> i have 72 gig
05:50:20 <shapr> but it's mostly FLACs of CDs I own.
05:50:26 <kristnjov> i despise flac
05:50:30 <shapr> why?
05:50:30 <bourbaki> heh
05:50:33 <shapr> flac is lossless.
05:50:34 <bourbaki> 72 gig
05:50:38 <kristnjov> flac is bloated
05:50:38 <Philippa> bourbaki: Loud (the album I'm playing) is towards the poppy end of dance with breaks everywhere
05:50:50 <shapr> is there a better lossless encoding than flac?
05:50:52 <Philippa> odds are you've heard half the tracks on it used in ads by now...
05:51:03 <bourbaki> :)
05:51:04 <kristnjov> shapr, i wouldn't know, but i'm sticking to mp3 192kbps or vbr (lame encoder)
05:51:07 <bourbaki> ive never heared of them
05:51:09 <shapr> mp3 is lossy
05:51:15 <Philippa> him, not them
05:51:16 <shapr> lossy is not for me
05:51:25 <kristnjov> i know, but i don't care, in vbr it sounds perfect to my ears
05:51:25 <bourbaki> but then im listening to stuff that noone else knows
05:51:27 <Philippa> I do mp3@320, but then I'm nuts
05:51:38 <shapr> I do flac, but I have hardware issues.
05:51:50 <shapr> that whole ritalin prescription thing
05:52:11 <Philippa> bourbaki: a remix of his track "Ubik" was all over the (commercialised) hard house scene a few years back
05:52:52 <bourbaki> shapr: what has ritalin to do with music?:)
05:53:17 <shapr> mp3 lossy encoding is a psychological attention thing
05:53:32 <shapr> people really don't listen to the quieter parts of a song
05:53:36 <shapr> so mp3 gets rid of them
05:53:41 <Philippa> hah
05:53:42 <bourbaki> ah i see
05:53:55 <bourbaki> well i claim to be able to hear a difference also
05:54:03 <bourbaki> especially in the stuff i listen to
05:54:07 <Philippa> (what can I say, I've written enough dance stuff myself to know the quieter parts of a beat are kinda vital...)
05:54:15 <bourbaki> it depends on what kind of music it is
05:54:50 <Philippa> most stuff has either something akin to phantom beats or else a fair amount of subtlety in eg the cymbals
05:55:25 <tuomov> most people don't have a place where to listen to the quieter parts
05:55:37 <shapr> "The first generation of compression was mostly mathematical. Only later did developers discover the psychological framework within which compression can become more efficient. MP3 is a commonly known compression codec which is also based on the psychology of hearing."
05:55:42 <shapr> from http://www.debalie.nl/dossierartikel.jsp?dossierid=7165&articleid=9025
05:55:46 <bourbaki> also it depends on what kind of speakers you have
05:56:00 <Philippa> er, they often come in subconsciously anyway - "this is funky" without knowing why
05:56:06 <shapr> google searches will turn up lots of the info about that.
05:56:13 <kristnjov> shapr, still it's a fact that i wouldn't be able to hear any difference anyways, so i'm saving my disk space this way
05:56:30 <TheHunter> i doubt there aren't many people who can tell the difference between the original and lame --preset standard
05:56:31 <shapr> kristnjov: if it works for you, that's good :-)
05:56:43 <kristnjov> yes :)
05:56:44 <TheHunter> s/aren't/are/
05:56:44 <bourbaki> kristnjov: if you listen to a cd and the mp3 and switch you would be able to tell the difference
05:56:59 <kristnjov> bourbaki, why would i bother to do that anyways?
05:57:07 <bourbaki> a lot of ppl i know said that until they bought a decent headphone
05:57:13 * shapr shrugs
05:57:20 <shapr> I have 80 euro headphones
05:57:26 <bourbaki> kristnjov: i dont say you should i just say that there is a difference in quality
05:57:32 <kristnjov> of course it is
05:57:36 <shapr> I've heard the audophiles on #javapro say they're cheap and low-end
05:57:46 * TheHunter has 200 Euro headphones
05:57:53 <kristnjov> audiophiles are basically computer nerd smartasses
05:57:58 <TheHunter> but i think they destroyed my ears
05:58:01 <bourbaki> an old collegue from work had really good speakers for 11k euro per speaker
05:58:04 <kristnjov> i have 10 euro headphones.. honest
05:58:06 * Lor bought 40 euro headphones recently, just because they were the biggest one could get at a reasonable price.
05:58:10 <shapr> I'd like some recommendations for better headphones that cost less that 300 euro
05:58:15 <Philippa> I don't have any headphones, just the earphones that came with my Zen atm...
05:58:19 <kristnjov> shapr, aren't koss porta-pro good ones?
05:58:26 <shapr> heck I dunno
05:58:28 <bourbaki> and thats a whole different thing if you listen to music on that kind of speakers
05:58:30 <shapr> I'm not an audophile
05:58:37 * Lor has big ears and wants phones that won't make the ears hurt even after hours of usage.
05:58:51 <shapr> I've been using these strange sony things
05:58:53 <kristnjov> Lor, same here
05:58:54 <Philippa> Lor: no kidding, BTDT. Pressure to the side of the head is bad, too
05:58:59 <shapr> they have a spring loaded ear clip
05:59:37 <Lor> Yeah. The padding should be _around_ the ear, not _on_ it.
05:59:38 <bourbaki> shapr: you can get a lot of good headphones wuite cheap if you buy the ones that arent produced anymore
06:00:11 <bourbaki> friend of mine bought some bayerdynamics studio headphones for 150 euro if i recall correctly they are very good
06:00:12 <TheHunter> shapr: sennheiser hd 590
06:00:14 <tuomov> grado sr80 are quite good and not even that expensive
06:00:29 <tuomov> but they're not very ergonomic depending on your head
06:00:56 <bourbaki> id just go to a good hifi shop in your vicinity and try out headphones
06:01:01 <tuomov> I think you could get a pair for 150e or so
06:01:10 <tuomov> yes, you should do that
06:01:10 <bourbaki> they often have good prices
06:01:13 <shapr> bourbaki: I live in the middle of nowhere. 800km north of stockholm.
06:01:13 <tuomov> and then order online
06:01:31 <bourbaki> i bet you will get out eventually :)
06:01:41 <bourbaki> i like to buy stuff for real
06:01:44 * shapr schedules a visit to bourbaki's couch
06:01:51 <bourbaki> try things out and so and haggle for prices
06:01:52 <tuomov> if it wasn't much more expensive..
06:02:10 <Lor> tuomov, how long have you been a #haskell denizen? I don't recall seeing you here earlier.
06:02:11 <tuomov> I live in the middle of nowhere in the second biggest city in finland :)
06:02:21 <Lor> Oh yeah, ion is coooool. (Obligatory fawn)
06:02:24 <bourbaki> tuomov: a lot of shops lower their prices to the lowest price you present them
06:02:27 <tuomov> a little over a week or so..
06:02:27 <kristnjov> Lor, denizen?
06:02:36 <shapr> tuomov: ion has made you famous.
06:02:37 <kristnjov> Lor, i've been here for like a month or so, probably less
06:03:18 <Lor> The thing is, I had been explicitly searching for something like ion, until I found it.
06:03:18 <kristnjov> lol, Lor... my real name is deniz :)
06:03:30 <shapr> kristnjov: that's very punny
06:03:37 <kristnjov> yeah
06:03:47 <tic> shapr, right, I didn't see __pos__(self).  In that case, it's dead-on easy to implement ++x, just increment a private value that when reaches 2 increases the object itself. 
06:03:49 <shapr> er, since en is the article, then denizen means "the deniz" riht?
06:03:50 <kristnjov> but no pun intended i guess, he didn't know my real name
06:03:59 <kristnjov> yes in swedish
06:04:02 <shapr> tic: you found it!! yay!
06:04:11 <tuomov> if my "fame" would just get me a decent job and not regular code slavery..
06:04:15 <shapr> tuomov: hah!
06:04:29 <monochrom> what is a decent job?
06:04:36 <shapr> monochrom: never seen one
06:04:39 <tic> shapr, yeah. By accident, not like I've been searching since then. =) that there's a unary operator that makes stuff positive, so I decided to look for unary ops. :)
06:04:51 * Lor gets paid for coding scheme. That's decent enough.
06:04:51 <tuomov> someone paying you to do what you want to do?
06:04:57 <bourbaki> but if you would go all the way of that argument you would have to buy a platter anyway
06:05:00 <monochrom> you could be a proof slave instead, you know...
06:05:11 <tuomov> proof slave would be ok
06:05:12 <shapr> whoa, can I get paid to chat on irc and while listening to music?
06:05:27 <Lor> Doesn't that describe every it job? :)
06:05:29 <bourbaki> a decent job is a job that is fun for you
06:05:34 <monochrom> I know you can get paid for playing new games.
06:05:42 <bourbaki> ive been a pro game progger for 2 1/1 years
06:05:48 <bourbaki> didnt pay good but was fun
06:05:58 <bourbaki> monochrom: QA yep :)
06:06:02 <shapr> I prefer jobs where I can look back and see what I've accomplished.
06:06:07 <bourbaki> but thats usually not payed good
06:06:10 <shapr> that's something I like about coding jobs
06:06:28 <Philippa> I used to want to do that, I can't deal with the whole "oh look, crunch time!" aspect in the game industry though
06:06:44 <Lor> Crunch time?
06:06:48 <bourbaki> Philippa: pardon ?:)
06:06:48 <shapr> death march
06:07:06 <shapr> where you have to work 16 hours a day for weeks in a row
06:07:09 <shapr> that part really sucks
06:07:17 <bourbaki> the first year i have been in the industry i worked 14-16h a day 7 days a week
06:07:24 <Lor> Ah. Well, if you get paid properly for it, then maybe...
06:07:28 <bourbaki> and i had 3 spare days in a whole year :)
06:07:33 <shapr> you rarely get paid well for that.
06:07:45 <bourbaki> but thats cool
06:07:50 <shapr> because any boss/manager that ends up with a death march usually has other problems as well
06:07:54 <bourbaki> cause you can eat pizza and talk to the ppl
06:08:02 <shapr> I got paid 40 hours a week to do 80+ hours a week.
06:08:13 <bourbaki> thats true
06:08:16 <Lor> Unpaid overtime sucks.
06:08:25 <Lor> Any legislation that _allows_ unpaid overtime sucks.
06:08:31 <bourbaki> but good teams like lionhead work 8h a day
06:08:36 <Philippa> mostly
06:08:47 <shapr> TheHunter: ok, I'm persuaded.. these HD 590s look great
06:08:51 <Philippa> I've seen a LHer working longer than that on occasion, but he doesn't seem to get hit for much
06:08:56 <bourbaki> they know that its vital that you have to work in same shifts
06:09:05 <monochrom> I am a proud capitalist.  I don't believe in measuring salary by hours.
06:09:11 <shapr> monochrom: I agree
06:09:15 <bourbaki> ive stayed at LH for 2 weeks once
06:09:22 <shapr> I'd rather measure my payment by accomplishment
06:09:28 <Philippa> you ever meet Neil Wakefield?
06:09:36 <bourbaki> nope
06:09:36 <Lor> Accomplishment is much harder to measure than time.
06:09:45 <tuomov> Measuring salary by hours sucks.
06:09:46 <shapr> not always
06:09:59 <shapr> accomplishment is much easier to measure in programming, I think
06:10:01 <shapr> for example
06:10:02 <tuomov> It sucks being at work 8 hours a day when you have 1 hour worth of work to do
06:10:08 <shapr> write a bunch of QuickCheck tests
06:10:14 <monochrom> There is no need to measure accomplishment.  Just let the supply-demand mechanism adjust the price tag attached to the job.
06:10:26 <bourbaki> the biggest reward i ever got was that peter molyneux said that he wants to have his game look like the demo we did for nvidia :)
06:10:30 <Philippa> supply-demand is at best a first-order approximation
06:10:31 <tuomov> but I'd rather do away with the whole concept of wage slavery
06:10:43 <Philippa> it just doesn't produce what society wants
06:10:50 <shapr> I think it could
06:10:57 <bourbaki> society wants what the ads tell them
06:10:59 <shapr> oh you mean contract work?
06:11:13 <Philippa> bourbaki: not all of society does
06:11:20 <shapr> wage slavery doesn't work in programming, programming is not a mass-production job
06:11:22 <bourbaki> Philippa: no but 99%
06:11:29 <shapr> programming is half art and half science
06:11:32 <shapr> and all magic
06:11:35 <Philippa> right. See "first-order approximation"
06:11:55 <bourbaki> im one of those lucky guys who are ppl that arent in any of the targets of any ads
06:12:20 <shapr> the only way to get good programming is to hire motivated people, and keep them motivated
06:12:31 <bourbaki> thats trye
06:12:34 <bourbaki> true
06:12:48 <Philippa> likewise. Plus I have a whole pile of needs that society at large doesn't give much of a fuck about, regardless of whether fulfilling them would help society
06:12:54 <bourbaki> but also i dont care to work like 80h a week or more
06:13:05 <bourbaki> when the stuff i do is accnowledged
06:13:05 <tuomov> that applies to anything, but the authoritarian structure of many workplaces kills all enthsiasm
06:13:09 <shapr> I could enjoy working 80+ h if it'ssomething really cool
06:13:22 <Philippa> personally I'm not doing more than 40/week, even if it's the most fun job possible
06:13:23 <shapr> tuomov: truly
06:13:36 <Philippa> I just can't live a sufficiently balanced life otherwise
06:13:48 <bourbaki> same here i need to do something thats fun for me
06:13:48 <shapr> I doubt I've ever had a sufficiently balanced life =)
06:13:59 <bourbaki> and thats why ill go back to game dev industry
06:14:14 <bourbaki> but this time not as a 3d progger
06:14:18 <Philippa> heh
06:14:23 <tuomov> I also need to do something fun... but I haven't figured out yet what that would be
06:14:25 <bourbaki> im fed up with that
06:14:27 <tuomov> maybe going back to study
06:14:31 <Philippa> yeah, probably a good move - if I do go into the industry I'll prolly be doing tools coding
06:14:49 <bourbaki> Philippa: whys that?
06:14:52 <shapr> I already have my something fun planned...
06:14:59 <monochrom> This is my thesis.  Society needs or wants clever people.  (I don't know which.)  Clever people finishes in a minute what other people takes hours.  Pay-by-hour clearly discourages clever people and clever ideas.  This socialist, union concept is against progress.
06:15:14 <bourbaki> ive done so much at work like a physics system file system and 3d stuff anything that they needed
06:15:17 <shapr> monochrom: I agree
06:15:20 <bourbaki> thats the joy of that job
06:15:21 <Lor> Clever people can demand to get paid more for their hours.
06:15:30 <shapr> clever people are rare
06:15:38 <Philippa> Lor: we do. Beats stacking shelves in a supermarket, anyway
06:15:38 <shapr> and usually piss of all their coworkers
06:15:50 <tuomov> employers don't want clever people when they can deskill the work and employ stupid people for cheaper
06:15:53 <bourbaki> clever ppl live a dangerous life :)
06:15:54 <Philippa> bourbaki: closest fit for my interests these days
06:15:59 <Lor> "deskill"?
06:16:01 <tuomov> and that's to a large degree happened to coding as well
06:16:10 <shapr> problem is, clever people cannot be replaced with stupid people
06:16:15 <Philippa> Lor: reduce the level of skill needed so they can hire infinite monkeys
06:16:32 <monochrom> Yes bosses may *want* clever people.  But see, that is probably not what they *need*.
06:16:54 <shapr> monochrom: isn't that the other way around?
06:16:56 <Philippa> they probably need a few clever people and a number of sufficient-understanding people
06:16:58 <shapr> they need them but don't want them?
06:17:03 * Lor thinks that Google both wants _and_ needs clever people.
06:17:10 <shapr> also, clever people often do not do what they are told
06:17:18 <bourbaki> :)
06:17:29 <shapr> usually because clever people can be given goals and process
06:17:32 <monochrom> I don't know.  But my thesis is fallible (therefore scientific! :) because you can argue that clever people should be got rid of.
06:17:34 <bourbaki> the problem is if you are more clever then your buss ;)
06:17:37 <bourbaki> er boss
06:17:39 <shapr> and they realize the process is pretty damn stupid for those goals
06:18:10 <bourbaki> back at work i argued hours and hours with my boss over design issues and that was not a good move really
06:18:27 <Philippa> monochrom: there're reasons to believe that getting rid of clever people entirely is a very bad move...
06:18:35 <Philippa> OTOH, clever people don't like doing monkeywork
06:18:36 <bourbaki> and now at his new job he ueses a lot of stuff that i talked about with him :)
06:18:47 <tuomov> I complained of a brain-damaged documentation framework that required writing the sme thing three times over and got fired :)
06:18:47 <Philippa> (they may well be good at finding ways to do monkeywork quickly, however)
06:18:54 <Philippa> *ow*
06:19:05 <tuomov> or that was at least the last straw for them
06:19:09 <Philippa> heh
06:19:22 <Philippa> more likely unless they were completely nuts - sounds like an entirely fair complaint
06:20:39 <tuomov> it appeared that one of the owners of the company had started documenting things so when he was still doing that stuff at the uni, and nobody had changed it in years..
06:21:07 <bourbaki> documents are the most hassleing work imho
06:21:57 <shapr> tuomov: of course, tPP says "don't repeat yourself"
06:22:02 <tuomov> documenting is wasteful beying some summary plan and function reference within the code (in doxygen format, for example)
06:22:09 <shapr> and in my experience, finnish companies tend to fire people for complaining
06:22:16 <shapr> which is not the most useful way to handle that
06:22:30 <bourbaki> hehe
06:22:46 <tuomov> I don't think the company was doing very well, with a perhaps slightly saner project that I should've started working on delayed at least three times
06:22:49 <bourbaki> i guess then i wont get a job anywhere if it was like that everywhere
06:23:01 <tuomov> and it was easier to kick someone out who didn't fit in than start the process of downsizing
06:23:18 <tuomov> s/beying/beyond/ far above
06:23:21 <bourbaki> unhappy and complaining ppl learn quicker
06:23:36 <shapr> no way
06:23:39 <bourbaki> yep
06:23:45 <shapr> I don't believe it
06:23:55 <bourbaki> i have no source on the net but i have heared that in a report
06:23:59 <shapr> I learn to get a different job maybe.
06:24:04 <Philippa> unhappy and complaining = has more incentive to figure out how to do things
06:24:18 <tuomov> or avoid work
06:24:21 <bourbaki> not unhappy as in depressive
06:24:22 <Philippa> true :-)
06:24:39 <tuomov> if nothing starts happening
06:24:51 <monochrom> Complaining people make me uncomfortable.  But I consciously listen to them because for the most part they are actually right.
06:24:55 <shapr> a few times I've had something a bit like a jazz band, where I started to meld with some of my coworkers
06:24:55 <Philippa> yeah, depression makes you semi-braindead
06:24:58 <shapr> that was really great
06:25:06 <shapr> we got lots of good stuff done really fast
06:25:21 * Philippa nods
06:25:30 <shapr> I want that again.
06:26:11 <shapr> GroupFlow is more powerful than single flow
06:26:22 <bourbaki> i think id like to do something like consulting and firefight for teams
06:26:26 <monochrom> bose-einstein condensate :)
06:26:32 <shapr> monochrom: yah, totally
06:26:33 <bourbaki> :)
06:26:45 <shapr> that is a great feeling
06:26:56 <bourbaki> i cant work alone at all
06:27:08 <bourbaki> im just efficent in a team
06:27:10 <shapr> I can, but I work best in a group of four.
06:27:16 <tuomov> I hate working alone in a cubicle
06:27:22 <bourbaki> i need ppl that kick my ass
06:27:25 <shapr> yah, cubicles are the worst of all worlds
06:27:32 <shapr> no privacy, and no team communication
06:27:35 <Philippa> 3-4 is about the number it's efficient to work in AFAICT
06:27:43 <tuomov> it's a really depressing place, everyone staring at their monitors, not saying a word to each other
06:28:03 <shapr> it's more fun to throw footballs and paper wads with messages on them
06:28:04 <Philippa> at least working from home you're allowed to curse loudly
06:28:11 <shapr> right, I get to sing at home.
06:28:25 <shapr> though I sing loud enough to irritate the neighbors sometimes :-)
06:28:29 <bourbaki> the cool thing at the place where i worked was that they werent strict
06:28:38 <bourbaki> if you want to curse you can do that
06:28:48 <bourbaki> or listen to music and stuff
06:28:53 <phubuh> http://c2.com/cgi/wiki?LordOfTheFlies
06:28:57 <bourbaki> or go for a walk
06:29:31 <shapr> http://c2.com/cgi/wiki?CargoCult
06:29:43 <bourbaki> and i need to talk and discuss problems a lot otherwise i get insane :)
06:30:21 <bourbaki> Philippa: so you are a tool smith?
06:31:12 <shapr> http://c2.com/cgi/wiki?CargoCultProgramming
06:31:24 <shapr> I've seen too much cargo cult programming.
06:32:08 <shapr> at my job in widian, many people always included an empty else {} clause in there java if statements because they didn't know it was optional.
06:32:09 <monochrom> hee hee hee
06:32:22 <shapr> ack, "their"
06:32:54 <bourbaki> lmao
06:33:02 <monochrom> return (0) in C/C++/Java too
06:33:06 <tuomov> and soon someone decides that it is company policy to do so
06:33:09 <monochrom> (The parentheses)
06:33:16 <bourbaki> my prob at work always was that i change my style of programming a lot
06:33:39 <monochrom> char *p = (char *) malloc(...);  in C.  (The cast.)
06:33:44 <bourbaki> depending on mood and time i can invest
06:34:02 <Philippa> bourbaki: I'm most interested in finding ways to get things done more easily, so yeah - tools seem to be a natural field. Problem is I'm too used to writing stuff aimed at coders, I need to put in some serious time doing GUI code sometime...
06:34:05 <monochrom> sin(x) in Haskell.  (ObHaskell :)
06:34:07 <Lor> And it really ought to be "char* p", but let's not get into that...
06:34:28 <shapr> I haven't seen much cargo cult programming in Haskell (well, only in my own code sometimes ;-)
06:34:42 <phubuh> Lor: but the pointer qualifier belongs to the variable, not the type :)
06:34:46 <bourbaki> Philippa: would you be able to write something like a graph editor?
06:34:47 <tuomov> I don't ever want to have to write GUI code
06:34:56 <tuomov> yuck
06:35:00 <shapr> GUI code isn't that bad actually
06:35:00 * esap has seen some Cargo cult programming in C++, though it's usually simple to fix.
06:35:02 <tuomov> Ion doesn't count :)
06:35:03 <bourbaki> cause i really suck at app codeing
06:35:06 <Philippa> bourbaki: I'd prolly bang my head on the API for a while, but yeah, I could do it
06:35:09 <shapr> tuomov: right, look at ion!
06:35:11 * shapr laughs
06:35:29 <Philippa> I just don't have much in the way of patterns for writing GUIfied tools (yeah yeah, MVC...)
06:35:37 <Philippa> whereas I have plenty for text-based ones
06:35:39 <shapr> so, tuomov if I send you money to support your decadent lifestyle, will you write a Haskell WM?
06:35:48 <tuomov> I'd most rather code some algorithm/math stuff, but nobody does does such things anymore
06:35:51 <tuomov> it's all been written
06:36:17 <bourbaki> Philippa: hm do you have spare time to help me on something like a graph text editor? for my project
06:36:19 <Philippa> gamedev sees a fair amount of that, but it's all splitting up into specialities again
06:36:21 <Lor> ion demonstrates pretty well, why strict adherence to standards (icccm) is important even when it seems like it does no practical difference.
06:36:26 <Philippa> bourbaki: sadly no :-(
06:36:32 <tuomov> Philippa: everyone just buys id's engine :)
06:36:39 <bourbaki> Philippa: dang thanks anyway
06:36:45 <bourbaki> ids engine sucks
06:36:51 <Philippa> not true - Epic're outselling id for engine licensing, if nothing else :-)
06:37:17 <esap> If someone's buying things, it doesn't mean it's good.
06:37:19 <bourbaki> unreal is a lot better imho
06:37:35 <Philippa> am tempted to try writing a game entity layer in Haskell once Q3A is GPLed though
06:37:35 <monochrom> what is a graph text editor?
06:37:40 <bourbaki> right most often its just a question of money
06:37:50 <Lor> 3d graphics are so good nowadays that it seems pointless to spend too much effort on engines if a reasonable one already exists.
06:37:53 <Philippa> thing is, Tim Sweeney'll beat me to it - the next UnrealScript is looking to be highly functional
06:38:00 <tuomov> shapr: it would be a fun experiment, but I don't think I'll do that..
06:38:04 <shapr> ok
06:38:21 <Philippa> Lor: agreed there. Most of the work isn't on graphics these days, it's on content and a toolchain for producing it
06:38:31 <tuomov> A simple window manager would be quite fast written, but rewriting e.g. Ion..
06:38:40 <bourbaki> well the thing is that ids engine isnt good at outdoor rendering
06:38:42 <Lor> Ion _used_ to be simple, eh? :)
06:39:03 <tuomov> Ion is probably the most complex wm around at the internals
06:39:05 <Philippa> bourbaki: that's hardly the only problem, unless D3's engine is vastly differently engineered to previous ones
06:39:06 <bourbaki> Philippa: youre writeing stuff for the unreal script?
06:39:09 * phubuh is considering writing a wm with HSX11
06:39:24 <Philippa> bourbaki: nope, I just hear things
06:39:26 <bourbaki> Philippa: afaik the engine still uses bsp
06:39:42 <tuomov> and it's still quite small :)
06:39:50 <Philippa> that's not really what I meant - you ever played with any of the source releases?
06:39:54 <bourbaki> and bsp is really bad for big outdoor spaces
06:39:57 <phubuh> tim sweeney posted to c.l.f about some lazy purely functional language of his design, iirc
06:40:01 <Philippa> they're overspecialised, hell to modify
06:40:29 <Philippa> phubuh: right. And I know a guy working at Epic who's spoken about the next UScript being seriously different
06:40:31 <bourbaki> yeah i thought so though i never bothered to code with the source
06:41:40 <tuomov> What makes Ion so complex is that there's no fixed way how screen objects must be attached to each other
06:41:47 <tuomov> but you can nest frames, workspaces, anything, at will
06:41:53 <Philippa> the network protocols're always hardcoded down to the last bit so the poor bastard writing QC/VM code/whatever can't add on new features...
06:42:14 <Philippa> "hey, can I have another bit for the new button I want to add to the control scheme?"
06:42:28 <bourbaki> hehehe
06:42:52 <bourbaki> the worst are console programmers :) anyway
06:43:23 <Philippa> I'm told japanese console coders can be really bad - things vary though. PS2 programmers sorta have a big problem to deal with off the bat
06:43:46 <bourbaki> console programming is an art imho
06:44:08 <Philippa> certainly if you get dumped with something as evil as the Jaguar :-)
06:44:20 <Philippa> these days the teams're big enough there can be real problems just organising stuff
06:44:21 <bourbaki> ive met some guys that wanted to port our engine to gamecube and ps2 i think ...
06:44:36 <Philippa> I still wonder how most outfits handle who gets to do what with the system bus bandwidth on the PS2
06:45:07 <bourbaki> i have no clue :)
06:46:38 <Philippa> would be interesting to try using Haskell as a metalanguage to produce a DSL that'd make PS2 programming sane though
06:47:18 <bourbaki> dsl?
06:47:54 <tuomov> domain-specific language?
06:48:45 <bourbaki> there are a lot of api tools for the ps2 if i reacall right
06:48:45 <Philippa> yep
06:48:56 <Philippa> yeah, they're all C-oriented though
06:49:02 <bourbaki> thats right
06:49:24 <Philippa> there's not a lot in the way of abstraction available
06:50:00 <bourbaki> what i really would like to see is a function orientated approach of an engine in general
06:50:30 <bourbaki> a monadic renderpipeline and such
06:50:39 <bourbaki> a monadic animation system
06:51:16 <Philippa> right
06:51:42 <bourbaki> i think when i have done that graph thing with the arrows im gonna test it with a shader graph
06:51:46 <Philippa> the PS2 DSL would be a similar design only with a monadic VU1 system, a monadic VU0 system...
06:51:50 <bourbaki> thats what i did initially at work
06:52:10 <Philippa> you'd describe the other stuff in terms of tasks to run on each and run a scheduler on the IOP or something like that...
06:52:55 <bourbaki> but i guess that things like that are doomed
06:53:02 <Philippa> heh - your highest-level code'd look like a shell script
06:53:04 <bourbaki> if you would have an engine like that noone would use it
06:53:44 <bourbaki> i had a lot of ideas to build an engine where the design is like the linux file system
06:53:53 <Philippa> 'mnot sure - it seems there's starting to be some awareness of FP in the game industry and I get the impression a number of the more sweng-oriented coders're crying out for something like this
06:54:05 <bourbaki> and anything has a place and an url
06:54:45 <bourbaki> well i think there are some good things and some bad things about that
06:54:59 <bourbaki> have you ever heared of that post mortem of jak and dexter?
06:56:03 <bourbaki> i think a modern engine will force something like higher order things cause you want to have more dynamicness in the engine
06:57:14 <bourbaki> but im not sure if the memory issues that a game comes up with can be dealt with propperly with an approach like that if im not mistaken that was one of the problems in jak and dexter
06:58:55 <shapr> I thought crash bandicoot used a lisp vm written for the PS2?
06:59:07 <bourbaki> thats the same company
06:59:32 <bourbaki> and afaik they have one of the best lisp hackers at work there
06:59:43 <bourbaki> at least i was told once in #lisp
07:00:05 <shapr> anyway, things like that aren't doomed if you can outdo doom in half the coding time.
07:00:17 <bourbaki> true
07:00:34 <bourbaki> the question is just if things like that mem issues can be dealt with
07:00:44 <shapr> you may have to grow your own FP programmers rather than hiring them, but if you can do more game for less money, you'll do fine.
07:01:05 <bourbaki> id like to do good games again in the same time
07:02:04 <bourbaki> i think a hybrid approach to things it the right thing to do
07:02:17 <bourbaki> a multi paradigmatic engine
07:06:17 <Philippa> my idea of FP is scarily imperative at times, put it that way...
07:06:39 <Philippa> but yeah. I'm wondering if there's a reasonable way to do pooling using the ST monad
07:09:58 <bourbaki> i think that something like mercury or other multi paradigm languages would be the best approach
07:10:55 <Philippa> perhaps - I wanna play more with all the categorical stuff, see how multiparadigm things can get that way
07:11:44 <bourbaki> yep thats interesting
07:11:54 <bourbaki> what are you studying anyway?
07:13:41 <Philippa> at uni just plain bsc compsci atm, though I'm playing around with a lot of other stuff in my spare time
07:14:29 <bourbaki> like ? what uni are you at that you do CT stuff there in bsc?
07:14:55 <Philippa> we don't :-)
07:15:14 <bourbaki> we have one course here at uni for CT but you need all 4 basic math courses to attend to it
07:15:35 <Philippa> I'm at the University of Nottingham, I grabbed some notes my dissertation supervisor (Graham Hutton) wrote for the Midland Graduate School course this year
07:15:55 <bourbaki> ah cool
07:16:30 <bourbaki> my math prof warned me of too much abstract algebra :)
07:17:08 <Philippa> heh
07:17:36 <Philippa> really I'm more interested in it as a framework for checking my intuitions at the moment
07:18:37 <bourbaki> i try to build some framework based on CT, topology, graphs and automatons to run a lot of ai techniques in one space
07:20:10 <bourbaki> and how come that you know so much ppl in the game industry?
07:23:08 <Philippa> 'cos I've been hanging around the outskirts of it online since I was a teenager
07:23:29 <bourbaki> ah i see :)
08:19:50 <shapr> @yow !
08:29:38 <dv> ghc doesn't have ord and chr?
08:30:01 <shapr> @index ord
08:30:07 <shapr> um
08:30:29 <dv> color.hs:7: Variable not in scope: `chr'
08:30:49 <shapr> @index ord
08:30:50 <lambdabot> Data.Char,GHC.Base,Char
08:31:29 <dv> ah, Data.Char, ok. thanks
08:59:56 <shapr> it's snowing
09:00:53 <bourbaki> ?
09:01:06 <bourbaki> change the tv channel ;)
09:01:12 <shapr> big white fluffy frozen bits of water
09:01:17 <shapr> coming down really fast
09:03:40 <monochrom> Alright! It's just October!
09:03:49 <monochrom> s/Alright/Already/
09:04:23 <shapr> so, tomorrow I get to try out my unicycle in snow. I've been looking forward to this :-)
09:08:29 <thebug> does it have anti-lock brakes and 4-wheel drive? ;)
09:08:54 <ibid> even two-wheel would be good :)
09:10:50 <shapr> it has one-wheel drive, but I haven't purchased the optional hydraulic brakes yet.
09:11:02 <shapr> I'm saving up for leg armor first.
09:12:05 <ows> Hi haskell community... Where programmers should use haskell instead of c, c++, lisp, java, smalltalk and others?
09:12:18 <shapr> hi ows 
09:12:21 <ows> (When)
09:12:43 <ibid> ows: when they benefit from it, of course :)
09:12:47 <shapr> I think Haskell gives more abstraction and expressiveness in many cases.
09:13:05 <shapr> http://www.haskell.org/complex/why_does_haskell_matter.html
09:13:24 <ows> well, I heard about haskell recently..
09:13:40 <shapr> I would always recommend Haskell over C++ or Java.
09:13:41 <ows> is it appropriate to make AI programs like lisp?
09:13:58 <shapr> I think so.
09:14:19 <ows> normally lisp community is related to AI community
09:14:21 <shapr> would you like a quick demo of the syntax, and some interesting examples?
09:14:24 <ows> c to system programming
09:14:31 <ows> java to web programming
09:14:34 <ows> ...
09:14:38 <ows> and about haskell?
09:14:47 <shapr> java is crap for web programming.
09:15:37 <ows> well, to provide portability...
09:15:49 <shapr> Haskell is a real type system with type inferencing, higher order functions, community use of monads, lots of research, and a tight connection with mathematical theory.
09:15:50 <ows> and haskell is related to what?
09:16:29 <monochrom> I have the forward constraint satisfaction algorithm in Haskell.  It looks ok.
09:16:52 <shapr> ows: plus, there's a lot of really big brains in the Haskell community, and they're cool.
09:17:00 <monochrom> http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs
09:17:23 <monochrom> It can be short and nice because haskell has lazy evaluation.
09:17:28 <shapr> monochrom: nice
09:17:50 <ows> humm... how do you compare haskell and lisp?
09:17:54 <monochrom> I write "generate the list of all possibilities; now try them one after one"
09:18:09 <shapr> Haskell is purely functional and lazily evaluated.
09:18:10 <ows> are there some relations?
09:18:19 <shapr> Haskell uses the HM typesystem.
09:18:22 <monochrom> the computer takes it "generate the first possibility; try; generate the second possibility; try; oh it works! stop."
09:18:51 <ows> and about macros, haskell has these?
09:19:04 <shapr> somewhat
09:19:14 <shapr> the Template Haskell extension gives some macro capabilities.
09:19:23 <shapr> it also allows static type-checking of macro generated code.
09:19:33 <monochrom> How would I compare haskell and lisp?  I wouldn't write the algorithm in lisp.  Been there, done that, seen Norvig did it, turned off.  Mine is shorter and easier to explain.
09:19:53 <monochrom> You see my comments are longer than my code.
09:20:00 <ows> yes if possible I want some demo of the syntax and interesting examples, like you said that could gimme
09:20:08 <shapr> template haskell - http://www.haskell.org/th/
09:20:16 <shapr> syntax demo - http://www.scannedinavian.org/AvianWiki/HaskellDemo
09:20:29 <shapr> recently, my favorite example is QuickCheck
09:20:34 <shapr> greetz roconnor 
09:20:39 <roconnor> yo
09:20:52 <shapr> wazzup?
09:20:54 <shapr> how's code?
09:21:05 <roconnor> I've been playing games too much.
09:21:05 <Matt-W> monochrom: that's nice
09:21:09 <shapr> roconnor: which games?
09:21:14 <roconnor> Final Fantasy XI
09:21:17 <shapr> oh
09:21:22 <shapr> does that run on linux?
09:21:32 <roconnor> No, only Windows and PS2
09:21:35 <shapr> suck
09:21:40 <ows> has it some declarative aspects like prolog or objects like java (or c++), or it is purely functional 
09:21:49 <Matt-W> purely functional
09:21:53 <roconnor> I play at work, because I can't afford a suitable graphics card.
09:22:35 <monochrom> In my code I also take advantage of the blurred line between "list" and "monad" :)
09:22:42 <roconnor> Okay, so what is good about the monomorphism restriction?
09:22:57 <ows> just for curiosity, is someone here interested in AI topics?
09:22:57 <ows> the majority?
09:23:34 <roconnor> ows, I gave up on AI. *l*
09:23:45 <shapr> roconnor: I heard it keeps the type system from blowing up.
09:24:01 <shapr> there are some AI people around.
09:24:03 <roconnor> type inference I assume.
09:24:15 <roconnor> ... I assume you mean
09:24:48 <shapr> ows: what sort of code would you like to see?
09:25:03 <monochrom> ows it's purely functional, but the lazy list aspect emulates quite some of declarativeness
09:25:35 <roconnor> I'm not sure that declarative is the right word for what you are talking about.
09:25:42 <phubuh> i thought ``purely functional'' and ``declarative'' were two words for the same thing
09:25:54 <ows> shapr: well, if possible related to AI
09:25:57 <roconnor> java and C++ are imperitive.
09:26:09 <shapr> imperious maybe...
09:27:13 <roconnor> Haskell is declarative.  You say, ``I declare `somenumber' to be `1'.''
09:27:44 <phubuh> er, rather that ``purely functional'' implies ``declarative'' :)
09:28:34 <shapr> ows: what sort of AI? expert systems, neural networks, or what?
09:28:48 <shapr> abductive inference maybe?
09:29:40 <ows> hum... wow, are there a lot of AI libs in haskell too?
09:29:48 <ows> well, so neural nets is ok
09:30:22 <roconnor> http://www.scannedinavian.org/AvianWiki/HaskellDemo --  what's with the adkermann function being messed up?
09:30:34 <shapr> roconnor: blame me
09:30:38 <shapr> everyone else does ;-)
09:30:47 <roconnor> But the wiki source is fine.
09:30:49 <shapr> actually, it's because enscript has a problem
09:31:01 <shapr> or maybe the wiki plugin
09:31:05 <shapr> but I haven't gotten around to fixing it
09:31:09 <roconnor> weird
09:31:38 <roconnor> The demo is mostly good.  It should be on the Haskell wiki
09:31:45 <shapr> I think it's because of the GNU convention that -- ends input args
09:31:57 <roconnor> oh
09:32:08 <shapr> roconnor: AvianWiki is almost an extension of Haskell wiki... since I'm maintainer of both.
09:32:13 <shapr> but you're right, I'll move it over.
09:32:32 <shapr> I should move the HaskellDBTutorial over too
09:33:18 <roconnor> I think the parameterised data declarations need more explaination, ... I'll think about what to write.
09:34:20 <shapr> hm, good point.
09:34:59 <roconnor> And the People example (and it's depencancies) should be moved up before the tree example.
09:35:41 <roconnor> err
09:35:46 <roconnor> its dependancies
09:35:58 * roconnor throws away his keyboard.
09:36:02 <shapr> ok, moved to HaWiki
09:36:24 <shapr> further edits should happen there
09:36:29 <roconnor> ok
09:37:13 * shapr adds a BSD license
09:38:23 * roconnor hates copyright
09:38:30 * roconnor hates implicit copyright.
09:39:47 <Matt-W> Research-type people: is there anything left to do a PhD in related to Haskell?
09:39:58 <roconnor> yes
09:40:05 <Matt-W> good
09:40:32 <tuomov> there's always something to do if you pound your head long enough at the wall so it turns into an electron microscope
09:40:50 <Matt-W> you know, that doesn't sound so attractive...
09:40:53 <roconnor> You will have fame and fortune if you find a good data type for communative monads.
09:41:11 <Matt-W> what's special about a communative monad?
09:41:21 <roconnor> They are useful.
09:41:23 <tuomov> Actually, I've also been considering this road..
09:41:31 <Matt-W> I gathered that
09:41:48 <tuomov> My MSc is in maths, but pure maths surely is pounding your head against the wall
09:42:00 <tuomov> and that doesn't sound so attractive
09:42:06 <Matt-W> hmm, probably
09:42:22 <Matt-W> I've got a BSc in Computer Science, I almost applied to do a PhD straight away
09:42:40 <tuomov> I was two years in the industry (and hated it) until I got fired a month ago
09:42:43 <roconnor> I want to have good random number generators in haskell
09:42:44 <Matt-W> after a year working doing C++ and Perl I definitely want to get back into the academic vein - and functional programming's the only way to go
09:42:48 <tuomov> and now I've been considering where to study and what..
09:42:56 <shapr> tuomov: chalmers! haskell!
09:43:07 * shapr projects his own desires on someone more capable ;-)
09:43:12 <tuomov> yes, I've been thinking about that..
09:43:19 <shapr> whoa, it worked?
09:43:19 <Matt-W> roconnor: isn't that more of a matter of having a good random number generator full stop? Nothing particularly special about it in haskell?
09:43:36 * Matt-W needs to talk to the nice people at Nottingham
09:43:39 <roconnor> ... err I want to have a good interface into a random number generator in haskell.
09:43:45 <shapr> Matt-W: there's a gazillion choices for PhDs in Haskell.
09:43:53 <shapr> ows: still there?
09:44:10 <roconnor> Requests for random numbers have to be sequence, like a monad, but the order of evalutation doesn't matter.
09:44:34 <Matt-W> now I begin to see where the problem lies
09:44:48 <shapr> arrows, spec_eval, commutative monads comes to mind
09:44:52 <Matt-W> shapr: pleased to hear it. There might be some left I'm actually intellectually capable of
09:45:04 <Matt-W> arrows are something I need to look in to
09:45:11 <shapr> nested data parallelism, extending Manuel Chakravarty's work
09:45:16 <Matt-W> I glanced over them when they appeared in GHC
09:45:23 <shapr> arrows rock
09:45:27 <Matt-W> but I haven't really put in the effort to figure out what they're really for
09:45:52 <shapr> I could give you the short arrows intro, but I'm sure there are several #haskell people who are getting bored of it.
09:46:12 <Matt-W> lol
09:46:23 <Matt-W> write it up and put it on the wiki
09:46:50 <shapr> it's just a summary and partial paraphrase of John Hughes' paper, with bits of Ross Paterson's FoP chapter.
09:46:57 <roconnor> Gee, it took forever to get a good introduction to Monads.
09:47:02 <shapr> truly
09:47:03 <Matt-W> monads are tough
09:47:07 <Matt-W> initially
09:47:09 <shapr> they're not tough!
09:47:17 <shapr> they're usually just badly explained.
09:47:20 <roconnor> they are a bit tough.
09:47:21 <Matt-W> they are when you can't find anything that explains them in a straightforward manner
09:47:22 <tuomov> arrows are easier
09:47:24 <TheHunter> roconnor: have you looked at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#LINEAR-IMPLICIT-PARAMETERS ?
09:47:27 <shapr> yah, arrows are easier.
09:47:29 <roconnor> and they are usually badly explained
09:47:46 <shapr> I think I can do a good job of explaining monads now.
09:47:46 <Matt-W> I'm not sure I understand monads entirely
09:47:52 <shapr> oh oh, pick me!
09:47:54 * shapr bounces
09:48:06 <Matt-W> but I was able to muck about with some monad-like things for my final-year project
09:48:17 <shapr> I want to go to school and get a CS degree someday.
09:48:18 <Matt-W> although really they were just carrying state around, which is pretty simple
09:48:32 <shapr> I bet I'd have fun torturing the teachers.
09:48:38 <Matt-W> lol
09:48:43 <roconnor> TheHunter: scary.
09:48:54 <shapr> random comments on the relation of a particular bit of code to category theory.
09:49:03 <Matt-W> actually the main use I seem to put monads to is the syntactic sugar
09:49:09 <shapr> that's all they are
09:49:15 <Matt-W> oh? good!
09:49:25 <Matt-W> in that case I'll stop worrying that I'm incompetant
09:49:46 <shapr> but they're a very general interface to syntactic sugar of a particular flavor.
09:49:51 * shapr licks flavored sugar.
09:49:51 <Matt-W> they just seem to be things with operations which satisfy certain rules
09:49:56 <shapr> yup
09:50:01 <Matt-W> and the 'thing' can be anything you like
09:50:06 <shapr> oh, can I give you my micro-explanation?
09:50:15 <Matt-W> and since the operations let you spit out a new thing, you get instant goodness
09:50:22 <Matt-W> yeah
09:50:25 <shapr> yay
09:50:32 <shapr> monads are a design pattern
09:50:48 <shapr> the ingredients are three things, a partially filled in type, and two functions.
09:51:07 <shapr> one function fills things into the type, and another function sticks together two filled in things.
09:51:14 <shapr> er, two filled-in types
09:51:40 <shapr> that's pretty much it.
09:51:57 <shapr> of course, it doesn't get interesting until you really do stuff with them.
09:52:06 <Matt-W> the two functions being (>>) and (>>=) I hope
09:52:11 <shapr> nah, return and >>=
09:52:16 <Matt-W> oh yes
09:52:20 <Matt-W> silly me
09:52:25 <tuomov> the category theoretical definition of a monad excellently obscured :)
09:52:29 <Matt-W> since >> is almost exactly the same as >>=
09:52:40 <shapr> tuomov: thank you, that's a great compliment :-)
09:52:53 <Matt-W> is it useful to learn category theory for Haskell?
09:53:02 <shapr> well, CT is just totally cool.
09:53:05 <Matt-W> or more than the basic lambda calculus I've already been taught
09:53:14 <shapr> and CT is pretty simple too: http://www.xp123.com/wwake/dissertation/model.shtml
09:53:54 <shapr> I love the Fable of the Land Before Printers.
09:55:56 <Matt-W> it suffers a bit from lack of  MathML
09:55:58 <shapr> CT is another of those things that's formalized common sense.
09:56:23 <ibid> or rather, made common sense confusing :)
09:57:15 <TheHunter> so what's the common sense behind an adjunction? :)
09:57:29 <tic> shapr, looked at Groovy? Think it's pretty lame, myself. :)
09:57:39 <shapr> TheHunter: um, uh, well... it's your turn to explain!
09:57:43 * shapr dodges quickly
09:58:05 <shapr> tic: I looked at it for about fifteen minutes, and all I remember is thinking "lame"
09:58:36 <shapr> I should look at it again so I can support that thought.
09:58:41 <tic> shapr, exactly.  it's still java. they tro to be Python, but fail :P
09:58:43 <TheHunter> i don't know, i've never got an intuition for adjunctions. But I could tell you the definition
09:58:45 <shapr> or maybe have some other thought.
09:58:50 <shapr> TheHunter: go for it
09:58:52 <tic> s/they tro/they try
09:59:08 <shapr> I never understood adjunctions well enough to remember what they do.
09:59:30 <shapr> if I can't fit something into my mental concept map, I can't remember how it works.
09:59:51 * esap got panic from ghc-6.2.1 and it went into an infinite loop. (ouch)
09:59:56 <shapr> yow
10:00:18 <esap> shapr: Adjunctions are a kind of inverse for functors.
10:00:18 <shapr> whenever I hear "adjunction" I immediately think "Esa Pulkkinen"
10:00:25 <Lor> Me too.
10:01:08 <shapr> of course, I think that same thing in connection with heavy duty OOP theory also.
10:01:30 <esap> shapr: F -| G  (F is left adjoint of G) iff there is an isomorphism  (F A -> B) =~= A -> G B
10:01:41 * shapr explodes
10:01:57 <Lor> Now look what you did.
10:02:00 * shapr grins
10:02:05 * esap feels guilty.
10:02:33 <shapr> ok, I'll start from the bottom
10:02:51 <shapr> first I'll look up the exact definition of a functor to make sure it means what I think it means
10:03:08 <shapr> http://en.wikipedia.org/wiki/Functor
10:03:09 <Matt-W> shapr: interesting thing on category theory. It seems quite remarkably like realising what monads are - 'what's the fuss then?'
10:03:33 <Matt-W> but now I have to go and urge people to cook me nice things for dinner
10:03:37 <Matt-W> I will return
10:03:40 * Matt-W -> food chasing
10:04:09 <esap> shapr: Functor means the same as the Functor class in Haskell. [well category theory normally phrases that a bit differently]
10:04:24 <shapr> @info Functor
10:04:25 <lambdabot> -- Functor is a class
10:04:25 <lambdabot> class Functor f :: (* -> *) where {
10:04:25 <lambdabot>     fmap :: forall a b. (a -> b) -> f a -> f b; }
10:05:47 <shapr> can you give me an example of something that isn't a functor?
10:05:52 <TheHunter> esap: Well, technically, haskell functors are endofunctors.
10:05:54 <shapr> and something that is?
10:05:58 <phubuh> a boat
10:06:01 <phubuh> and a monad :)
10:06:02 <shapr> phubuh: :-P
10:06:15 * shapr slår phubuh med en forell
10:06:50 <esap> Category theory also normally requires that functors satisfy some properties, e.g. F(id) = id and F(g o f) = Fg o Ff
10:08:44 <esap> TheHunter: Doesn't that change if you think of more than one module?
10:09:10 <shapr> are there Functor instances for all of the monad instances?
10:09:22 <cybermanco> hell
10:09:25 <cybermanco> hello
10:09:28 <TheHunter> shapr: just set fmap = liftM
10:09:29 <shapr> cybermanco: heaven
10:09:39 <cybermanco> once again
10:09:41 <cybermanco> here I am
10:09:46 <cybermanco> one year later
10:09:48 <shapr> greetings cybermanco, long time no see.
10:09:54 <cybermanco> because
10:10:03 <cybermanco> i dont know shit about haskell
10:10:04 <shapr> because Haskell is so cool!
10:10:05 <cybermanco> lol
10:10:07 <shapr> oh
10:10:34 <TheHunter> esap: i don't know.
10:10:44 <shapr> instance Functor Maybe where
10:10:44 <shapr>   map f (Maybe a) = Maybe (f a)
10:10:44 <shapr>   map f Nothing   = Nothing
10:10:46 <shapr> right?
10:10:52 <esap> theHunter: I've been thinking that every module gives rise to a category.
10:11:12 <shapr> my intuition about Functor is just "how to implement the map function for this type" is that correct?
10:11:33 <TheHunter> shapr: yep
10:11:36 <shapr> cybermanco: does that mean you have some questions?
10:11:45 <shapr> ok, so Functor does mean what I think it means.
10:11:48 <cybermanco> yes
10:12:00 * TheHunter is thinking about esap's interpretation of modules.
10:12:01 <shapr> cybermanco: go for it
10:12:16 <cybermanco> I have to do a parser this time...
10:12:25 <shapr> so, an adjunction is the opposite of a functor.
10:12:31 <shapr> how do you have an opposite for map?
10:12:44 <shapr> cybermanco: oh you're lucky, that's one thing Haskell does very well.
10:12:48 <cybermanco> hm
10:12:56 <cybermanco> (sorry my bad english)
10:13:02 <shapr> (sorry my bad finnish!)
10:13:36 <cybermanco> i have to do an aritmetic expression parser...
10:13:48 <TheHunter> shapr: (,) a and (->) a are adjoint which basically means that you can do currying.
10:13:49 <shapr> oh, read the Parsec tutorial, and tada you're done.
10:13:55 <esap> shapr: I wouldn't say adjunction is an opposite of a functor, more like a relation between two functors.
10:14:13 <cybermanco> where's the parsec tut?
10:14:27 <shapr> cybermanco: on google ;-)
10:14:31 <tuomov> or, adjoint is an "approximate" inverse
10:15:22 <esap> shapr: But think of F -| G, there, F is a kind of inverse of G when F is left adjoint of G.
10:15:54 <shapr> what's F and G?
10:16:01 <esap> shapr: F and G are the two functors.
10:16:15 <shapr> oh
10:16:28 <shapr> oh, this is getting much clearer.
10:17:29 <shapr> can you make an Adjunction instance for (,) and (->) ?
10:17:38 <shapr> oh, there already is one
10:17:41 <esap> shapr: Yes.
10:18:08 <esap> shapr: Actually ((,) a)  and ((->) a) are adjoint, that is:  ((,) a) -| ((->) a)
10:18:10 <shapr> that's a strange Functor instance for ((,) a)
10:18:33 <shapr> why isn't it "fmap f (x,y) = (f x, f y)"
10:18:37 <shapr> why only apply to y ?
10:18:48 <esap> shapr: because the first element of the pair has a fixed type 'a'.
10:19:00 <esap> shapr: so mapping over the pair only maps over the second element.
10:19:12 <shapr> ohh
10:19:17 <shapr> I think I get that
10:21:51 <shapr> so what can I actually do with that adjunction instance?
10:22:02 <shapr> currying...
10:23:09 <esap> shapr: leftAdjunct is currying, rightAdjunct is function application and unit and counit are directly from the definition.
10:25:36 <ows> shapr: yeah, now I'm here :)
10:28:09 <cybermanco> I have this:
10:28:09 <cybermanco> data OP = SOMA | SUB | PROD | DIV | POTSOMA
10:28:09 <cybermanco> data Expressao = Folha Int | Nodo (OP, [Expressao])
10:28:15 <cybermanco> and i have to do this:
10:28:18 <esap> shapr: unit generally means a collection of paths in a space [e.g. all paths of a given space] and counit means a mechanism for following a path in a space (and getting an element).
10:28:22 <cybermanco> instance Read Expressao
10:28:22 <cybermanco> where ...
10:28:36 <cybermanco> but i have no idea how to..
10:28:52 <shapr> cybermanco: read the wiki about typeclasses
10:29:11 <esap> shapr: usually unit and counit are the easiest to implement when you implement instances of the Adjunction class.
10:29:27 <ows> shapr: What you wanted from me 1h ago?
10:29:34 <shapr> I can't think of other adjunctions
10:29:45 <shapr> ows: just wondering if you had other questions, wanted more code samples, etc
10:30:31 <ows> well, I need to see more about haskell.. but tkx a lot for your help :)
10:30:56 <shapr> well, I'll answer anything I can...
10:31:09 <shapr> I found some Neural Network code in Haskell, but it's old
10:31:10 <esap> shapr: given "data Sequence b = Sequence b (Sequence b)" and "data Nat a = Zero a | Succ (Nat a)" [a weird version of natural numbers], those are adjoint, e.g. Nat -| Sequence   
10:31:20 <shapr> Peano numbers, yah?
10:31:40 <esap> shapr: almost, but there is an element at zero.
10:32:47 <esap> shapr: And infinite streams is the other thing.
10:34:56 <esap> shapr: another interesting is  exists(_) -| Subst(_) -| forall(_), a functor way of defining universal and existential quantification.
10:35:19 <esap> shapr: from substitution.
10:35:44 * shapr explodes again
10:36:05 <shapr> what's Subst(_) ?
10:36:22 <shapr> I vaguely understand exists(_) -| forall(_)
10:36:58 <esap> shapr: if you have f : A --> B, Subst(f) : P(B) --> P(A)  [so subst is contravariant functor]
10:39:30 <esap> shapr: where Subst(f)(g) = g . f if I recall correctly. [might be in opposite way as well :-)]. Subst is basically defined by composition.
10:40:35 <esap> shapr: substitution and composition is very close to same thing because e[x <- f] is like e . f
10:41:06 <shapr> I see
10:41:33 <esap> shapr: so from that, you'll also get universal and existential quantification by adjunction.
10:41:47 <shapr> I don't quite jump that far... but I'll think about it.
10:43:07 <esap> shapr: Basically the whole lambda calculus can be defined using just adjunction, a copying functor and an operation that can bind a functor argument.
10:44:24 <esap> shapr: that is because there is another adjunction: _ \/ _ -| Copy(_) -| _ /\ _  (where Copy(X) = X,X  Copy(f) = f,f and Copy : C -> C x C).
10:44:56 <esap> shapr: I should say, pair of adjunctions :-)
10:45:31 <esap> shapr: That combined with the ((,) a) -| ((->) a)  does define simply-typed lambda calculus.
10:51:11 <TheHunter> esap: where can I read about that kind of stuff?
10:51:23 <esap> thehunter: which part?
10:51:37 <esap> thehunter: adjunctions in general, or about how to represent lambda calculi with adjunctions?
10:51:45 <TheHunter> http://www.cs.ru.nl/B.Jacobs/CLT/bookinfo.html ?
10:52:11 <TheHunter> esap: the lambda calculus part.
10:52:48 <TheHunter> and CT vs. functional programming in general
10:53:57 <esap> TheHunter: I read about the lambda calculi stuff from http://citeseer.ist.psu.edu/pitts01categorical.html though it might be a bit heavy to read.
10:55:17 <TheHunter> thanks, i'll have a look at that.
10:55:20 <esap> TheHunter: But it does have all the information and description of where it comes from.
10:59:17 <TheHunter> esap: seems nice. I think I'm going to read that.
11:02:05 <esap> thehunter: it is nice, it has everything to model even dependently-typed lambda calculus with category theory.
11:02:56 <esap> thehunter: But It's pretty compact (for a 100-page thing), so at places you need to understand category theory pretty well already.
11:06:48 <shapr> well, I understand at least part of what you described, and I'll reread that a few dozen times until I completely understand it.
11:18:43 <shapr> should this work? "import qualified Graphics.HGL.Internals.Types (Point) as HGL(Point)"
11:19:16 <shapr> oh, duh
11:19:19 <shapr> nm
11:24:23 <cybermanco> hi
11:24:34 <cybermanco> Hi have a Parse a and and want a
11:24:37 <cybermanco> how can I do?
11:25:47 <cybermanco> *Parser
11:27:23 <shapr> yay, the yampa arcade builds with ghc-cvs !
11:27:23 <Si\> are there any SYB experts online atm?
11:27:24 <shapr> w00
11:27:28 <shapr> what's SYB?
11:28:05 <Si\> Scrap You Boilerplate
11:28:10 <Si\> *Your
11:28:12 <shapr> oh
11:28:29 <shapr> I have a vague understand of that, not an expert.
11:28:32 <shapr> what's your question?
11:28:34 <Si\> I've got a problem with ext1Q
11:28:54 <Si\> if no-one knows, I'll email ralf
11:29:03 <shapr> I say email
11:29:05 <esap> what kind of problem?
11:29:08 <shapr> oh, maybe not
11:29:21 <Si\> Right, assume a very simple combination;
11:30:05 <Si\> testFunc = (\x -> "Nothing") `ext1Q` (\(Just x) -> "A Maybe")
11:30:32 <Si\> That will return "Nothing" if you give it anything other than a Maybe
11:30:50 <esap> right.
11:31:14 <Si\> however, now I create my own data-type "data SOAPMessage a = SOAPMessage a deriving Data"
11:31:31 <Si\> soapMessageTc = mkTyCon "SOAPMessage"
11:31:31 <Si\> instance Typeable1 SOAPMessage where
11:31:31 <Si\>     typeOf1 _ = mkTyConApp soapMessageTc []
11:31:51 <Si\> So I've got an instance of Typeable1 for SOAPMessage
11:32:20 <Si\> if I try the exact same function above with SOAPMessage instead of Just, I never get anything but "Nothing"
11:33:19 <esap> I'm wondering whether you need to put something to the second argument of mkTyConApp to make it work. Hmm... let me think a sec.
11:33:23 * shapr suddenly realizes that yampa is a *lot* like OOP
11:35:04 <esap> Maybe that's not the problem.
11:35:33 <Si\> #define INSTANCE_TYPEABLE1(tycon,tcname,str) \
11:35:33 <Si\> tcname = mkTyCon str; \
11:35:33 <Si\> instance Typeable1 tycon where { typeOf1 _ = mkTyConApp tcname [] }
11:35:53 <Si\> that's GHC's macro for creating Typeable1 instances
11:38:46 <esap> I don't see anything wrong with it.
11:39:00 <Si\> neither do I
11:39:58 <Si\> essentially, ext1Q should see whether the typeOf1 the input parameter is the the typeOf1 the function
11:40:42 * esap is wondering whether you need mkQ somewhere.
11:41:18 <Si\> hmmm
11:41:22 <Si\> interestng
11:41:37 <Si\> if I do typeOf1 (Just undefined) I get Maybe
11:43:02 <esap> is it possible to derive Typeable1? [I haven't ever used Typeable1, so I wouldn't know]
11:43:19 <Si\> forget that, I was getting an error because I'd added (Data a) to the context of SOAPMessage, it doesn't work either way
11:43:46 <Si\> no you can't derive Typeable1
11:43:59 <Si\> although I think you can derive Typeable2
11:48:07 <Si\> Typeable1 instance for Maybe in creating in Typeable.hs; INSTANCE_TYPEABLE1(Maybe,maybeTc,"Maybe")
11:48:27 <Si\> \s\in\is
11:52:28 <Si\> hmm, it seems ext1 uses dataCast1 to see whether something will cast
11:53:42 * esap is also reading that part...
11:55:01 <esap> dataCast1 _ = Nothing
11:55:50 <esap> dataCast1 always returns Nothing. Hmm...
11:58:20 <Si\> How does one invoke dataCast1 and gcast1?
12:01:34 <esap> (gcast1 (Just (Just "foo")) ) :: Maybe (Maybe [String])  => Nothing
12:02:05 <esap> (gcast1 (Just (Just "foo")) ) :: Maybe (Maybe (Maybe String)) ==> Just (Just (Just "foo"))
12:03:49 <Si\> ((gcast1 (Just (SOAPMessage "foo")) ) :: Maybe (Maybe (SOAPMessage String)) ==> (Just (Just (SOAPMessage "foo")))
12:04:38 <esap> try write a new ext1Q using gcast1 instead of dataCast1.
12:05:55 <esap> it'll change the type though, which might be a problem.
12:07:32 <esap> hmm.. maybe not. pretty odd to use dataCast1 in definition of ext1, I don't understand why it's like that.
12:10:01 <Si\> what did you do? I can't make that work
12:10:23 <esap> no, I didn't actually do anything. Just reading the code.
12:10:49 <Si\> ext1' :: (Data a, Typeable1 t)
12:10:50 <Si\>      => c a
12:10:50 <Si\>      -> (forall a . (Data a) => c (t a))
12:10:50 <Si\>      -> c a
12:10:50 <Si\> ext1' def ext = maybe def id (gcast1 ext)
12:10:56 <Si\> won't compile
12:14:48 <esap> maybe it's unfinished code, I'm actually not sure what kind of support would be needed to make that work.
12:15:06 <esap> ext1 seems pretty strange anyhow.
12:15:47 <Si\> I'm emailing Ralf, I think it may be a bug.
12:16:58 <esap> probably would need some mechanism for actually implement dataCast1.
12:18:34 <Si\> Where's the deriving macro?
12:18:39 <esap> it would need to check whether the type constructor of the element matches the type constructor of the constructor, and then return the container's element.
12:19:01 <esap> deriving macro? which one?
12:19:10 <Si\> Data
12:19:11 <esap> ah, you mean definition of the macro?
12:19:23 <Si\> yes
12:20:04 <Si\> Cuz in it's current state all that extn architecture is basically useless for anything other than Maybe.
12:20:22 <Si\> Unless you want to scrambler around creating your own instances, which isn't fun.
12:21:38 <esap> yea, I agree, ext1 doesn't work. I'm not sure there's enough framework to actually implement it, but it might also be just a bug.
12:22:07 <esap> There is somewhere a header file called "Typeable.h" which I suppose contains the #defines.
12:22:12 <Si\> If dataCast1 is _always_ just being implemented as Nothing, some code nedds to be writeen as you said
12:22:47 <Si\> shame that GHC bugs are as valuable as TeX bugs :)
12:22:56 <Si\> \s\are\aren't
12:22:57 <esap>  /usr/lib/ghc-6.2.1/include/Typeable.h in my system.
12:24:23 <esap> http://www.cs.vu.nl/boilerplate/library/Typeable.h also has it.
12:27:01 <Si\> what about the Data macro?
12:27:37 <esap> Data macro?
12:27:56 <Si\> for deriving Data
12:28:27 <esap> I don't know.
12:29:02 <esap> I thought those were built-in to the compiler.
12:30:17 <Si\> so how did you know it was returning dataCast1 _ = Nothing?
12:31:29 <esap> I read from http://www.cs.vu.nl/boilerplate/library/Basics.hs
12:32:49 <esap> But now I realize there is another dataCast1, which is part of the class. I wonder which one is used :-)
12:33:27 <Si\> it's a pretty weird function anyway
12:36:21 <esap> ah right, it's the default instance, somewhat too many comments in that code, I thought it was top-level function.
12:37:07 <esap> ok, maybe there isn't that problem, I misunderstood that code.
12:38:00 <Si\> you could be right though, if the deriving code is missing the machinary to check whether the Data-type is unary
12:38:08 <Si\> it will just pick the default instance
12:38:32 <Si\> I've no other way of explaining it as such
12:38:39 <Si\> cuz gcast1 works
12:40:03 <esap> is it somehow possible to dump the deriving stuff via one of ghc's dump options. It might be possible to see what is generated.
12:40:47 <Si\> I don't think it's worth the effort, I've sent an email to Ralf, hopefully he'll be able to help
12:41:51 <Si\> because without extn working, like half of SMB is dead
12:45:57 <shapr> do you need to add deriving to some existing datatypes?
12:48:57 <Si\> I might try copying Maybe's Data definition
12:49:17 <esap> yea, you can get it working with that.
12:49:20 <esap> probably.
12:54:48 <Si\> Yup that works
12:55:03 <Si\> which really does imply to me that you're initial supposition was correct
12:55:13 <Si\> dataCast1 can't be being defined correctly
13:02:07 <Si\> and on top of that my serializer now works correctly with it :D
13:07:15 <ikegami--> morning
13:07:31 <shapr> konichiwa ikegami--san
13:07:36 <shapr> greetings ez4 
13:07:40 <ikegami--> hi, shapr
13:07:50 <ikegami--> i will leave Japan today
13:07:56 <shapr> where are you going?
13:07:57 <ikegami--> (and visit Sweden)
13:08:06 <shapr> IOHCC results are finally up --> http://www.scannedinavian.org/iohcc/succzeroth-2004/
13:08:13 <shapr> häftigt
13:08:18 <tromp> morning&evening,  ikegami&shapr :)
13:08:26 <shapr> hoi tromp 
13:08:42 <ikegami--> hejsan tromp
13:08:56 <ez4> hi
13:09:10 <shapr> ez4: learning haskell? longtime user?
13:09:21 <ez4> longtime user
13:09:35 <shapr> spiffy, do you have any code online?
13:10:15 <ez4> no, i don't use it that much
13:14:38 <shapr> bored? looking for Haskell excitement? check out Ulf Norell's IOHCC submission!
13:14:44 <shapr> http://www.scannedinavian.org/iohcc/succzeroth-2004/ulfn.tar.gz
13:15:01 <shapr> guaranteed to bring a look of amazement to the face of the most stoic Haskeller...
13:15:38 <shapr> metasteganographic obfuscation is a seriously cool thing.
13:18:05 <shapr> check out dons submission which exploits interesting properties of GHC for scary heap walking
13:18:20 <shapr> and Jeremy Gibbons wrote a really cool spigot algorithm.
13:18:33 <shapr> Very applicable to GHC with its GC strategy.
13:26:21 <shapr> did I kill the conversation?
13:26:58 <tromp> yes, by making us look at ulf norell's stuff:)
13:27:19 <shapr> oh, ok :-)
13:27:20 <tromp> it reminds me of my own interpreters:)
13:27:23 <shapr> heh
13:33:23 <tromp> hmm, don't see runP defined
13:34:04 <tromp> oops, now i do:)
13:35:24 <tromp> boy, that is some tight code
13:35:56 <shapr> still looking at Ulf's code?
13:36:09 <tromp> of course; i only just started:)
13:36:12 <shapr> have you read the accompanying documentation?
13:36:19 <tromp> nope
13:36:31 <shapr> his writeup is almost as much fun as the code itself.
13:36:55 <tromp> it's fun trying to make sense of his source
13:36:57 <shapr> of course, anything that mixes template haskell and data.generics is going to be scary.
13:38:38 <shapr> the DeriveData.hs module is very useful.
13:43:38 <shapr> let's see, there must be more interesting geeky stuff I can post to lambda-the-ultimate.org
14:02:54 <shapr> g'day SyntaxNinja 
14:04:18 <SyntaxNinja> hihi shapr
14:04:24 <SyntaxNinja> I think amazon goes a little overboard with their packing sometimes.
14:04:45 <shapr> what happen?
14:06:01 <SyntaxNinja> I got a book, shrinkwrapped, strapped to a cardboard slate, which were shrinkwrapped together, inside a box with plastic balloon padding things
14:06:12 <SyntaxNinja> and the box was really big
14:06:33 <shapr> wow
14:17:06 <shapr> greetz CLxyz
14:17:31 <CLxyz> g'afternoon shammah
14:17:32 <CLxyz> er
14:17:34 <CLxyz> shapr
14:19:46 <shapr> how's code?
14:21:15 <CLxyz> badly?
14:21:33 <shapr> well, at least you're coding...
14:21:47 <CLxyz> programing with FPs is harder and easier at the same time
14:21:55 <shapr> have any questions?
14:22:02 <shapr> I can help you with Haskell at least.
14:23:28 * shapr smacks logrotate
14:23:41 <shapr> logrotate refuses to touch my apache2 logs... no idea why.
14:23:46 <CLxyz> noting right at this minute
14:23:58 <CLxyz> just doing some basic things with haskelle
14:24:01 <CLxyz> er
14:24:05 <CLxyz> haskell even
14:24:09 <shapr> ok, feel free to ask me if you think of some questions.
14:25:41 <shapr> bourbaki: hey, I got yampa space invaders built
14:33:50 <bourbaki> cool
14:39:29 <shapr> it builds fine with ghc-cvs-6.3 debs
14:42:52 <tromp> there's no way to make  \x -> a x . b x   point-free is there?
14:46:06 <shapr> hm, maybe
14:49:37 <shapr> tromp: ((1 +) &&& (2 +)) 5
14:49:45 <shapr> er wait
14:49:47 <shapr> doh
14:51:00 <shapr> I think you can mix curry in there.
14:53:34 <tromp> &&& is for arrows isn't it?
14:53:40 <ikegami--> hm
14:53:42 <shapr> yes, but they still work
14:53:59 <shapr> >>> is effectively flip (.)
14:54:03 <tromp> (1 +) is an arror already?
14:54:08 <tromp> uhm, arrow
14:54:19 <shapr> I think of &&& as 'fork apply' and *** as 'pair apply'
14:54:41 <shapr> but, I can't think of an 'unfork apply'
15:04:03 <shapr> uncurry (.) is an 'unfork apply'
16:14:39 <shapr> hiya wolfman8k 
16:14:55 <wolfman8k> hello?
16:15:04 <shapr> how's code?
16:15:15 <wolfman8k> who are you?
16:15:28 <shapr> I'm the unofficial #haskell greeting person.
16:15:31 <shapr> I'm not a bot, I promise.
16:15:37 <wolfman8k> what code?
16:15:42 <shapr> I've talked with you on #icculus.org several times.
16:15:52 <wolfman8k> hm...
16:16:02 <wolfman8k> your nick seemed familiar
16:16:03 <shapr> well, code is life, so I ask people how code is going.
16:16:09 <shapr> like, "how's life?" but for programmers.
16:16:19 <shapr> g'day clausen 
16:16:48 <shapr> wolfman8k: want to learn Haskell? or get a short overview?
16:17:02 <wolfman8k> i've already tried learning haskell a few times
16:17:07 <wolfman8k> also lisp and ocaml
16:17:07 <shapr> ah, what did you think?
16:17:14 <wolfman8k> i think i didn't get it
16:17:24 <shapr> do you have any questions?
16:17:28 <shapr> maybe I can help you out?
16:17:38 <clausen> gday shapr
16:17:38 <wolfman8k> farthest i've got is a 100 line program in ocaml
16:17:44 <shapr> that's pretty good.
16:17:53 <shapr> clausen: how's code?
16:17:55 <wolfman8k> with haskell i've only payed around about in the interactive thingy
16:18:04 <clausen> no code... busy :/
16:18:15 <wolfman8k> lisp i've only read about and glanced at some emacs elisp code i guess
16:18:17 <shapr> haskell is even more functional than ocaml
16:18:22 <wolfman8k> yeah
16:19:09 <wolfman8k> problem i had with ocaml is that i couldn't stop thinking in object oriented way. i kept wanting to think about data structures
16:19:24 <shapr> ocaml and haskell are also about data structures.
16:19:31 <Lor> Thinking about data structures is not object oriented.
16:19:43 <wolfman8k> yeah, but the thing that bugged me about ocaml
16:19:45 <Lor> Trying to make some behavior an inherent part of them is.
16:19:51 <shapr> but in Haskell, the 'methods' are not bound to the data type.
16:20:25 <shapr> wolfman8k: what thing?
16:20:28 <wolfman8k> if you just have some data that has a few named fields, person[name:string, age:int]
16:20:38 <wolfman8k> then i remember that this is weird to do in ocaml
16:20:51 <wolfman8k> it was a while ago
16:20:58 <Lor> No it's not. You just define a record.
16:21:09 <wolfman8k> yeah... the thing about records though
16:21:19 <wolfman8k> is that to define a record value
16:21:26 <wolfman8k> like for a person i could just type
16:21:37 <wolfman8k> ("lor", 86)
16:21:44 <wolfman8k> and it would figure out that it's a person
16:21:50 <wolfman8k> based on type inference or something
16:21:56 <wolfman8k> that just seemed weird to me
16:22:14 <wolfman8k> because what if you have another data structure that has a string and int field?
16:22:28 <Lor> No, { name="Lor"; age=26}
16:22:48 <shapr> Person { name="shapr"; age=33 }
16:22:50 <Lor> In O'Caml, the design choice has been to forbid duplicate field names in the same scope.
16:23:06 <Lor> in SML, they are allowed, but then of course you can't infer the type just from the field names.
16:23:28 <Lor> And shapr just showed the Haskell way, which is essentially the same approach as in O'Caml, except perhaps a bit kludgier.
16:23:54 <Lor> (Since you need to give the record constructor, but you still can't overload field names)
16:23:56 <wolfman8k> hm... anyway, i figure that i'll try to learn haskell before any other functional programming language since they say that it's the cleanest
16:24:03 <Lor> It is.
16:24:14 <Lor> It's also the hardest.
16:24:26 <shapr> but once you get it, you really got it.
16:24:27 <Lor> Others might not agree with me here, though. :)
16:24:45 <shapr> I really like the extreme functional approach of Haskell. It's my favorite by far.
16:24:46 <Lor> Yeah, Haskell forces you to grok functional programming.
16:25:00 <wolfman8k> yeah, that's what they say
16:25:12 <shapr> of course, it's not that extreme from my viewpoint, just from the viewpoint of C programmers.
16:25:17 <wolfman8k> thing is, some parts of functional programming i sort of like, like high-order functions and function currying
16:25:20 <Lor> In other languages, you can bluff your way and resort to ugly imperative kludges when you don't figure out how to do it otherwise, but in Haskell you either do it functionally or then not at all.
16:26:16 <shapr> what are the parts you don't like?
16:27:14 <wolfman8k> more like don't understand.... the whole monad system of haskell or whatever it is. it just seems like for some types of programs you'd need to mostly use monads and then you loose the whole "pure" benefit thingy of haskell
16:27:31 <shapr> monads are pure
16:27:37 <shapr> and they let you do side-effects too
16:27:54 <shapr> I can explain it to you, but it takes some brain-twisting to really fully understand it.
16:27:58 <shapr> you want to hear?
16:28:17 <wolfman8k> well, i was just about to read this chapter 9 Monads of this tutorial thing
16:28:49 <CLxyz> why exactly are monads pure?
16:29:31 <shapr> because they explicitly pass the state around.
16:29:36 <Lor> I say forget for now about monads as a general concept. Just think of the do notation and the IO type as special imperative kludges.
16:29:45 <shapr> yah, I agree.
16:29:51 <Lor> No, monads _implicitly_ pass the state around. That's their point. :)
16:30:00 <shapr> well, yeah..
16:30:03 <shapr> right, good point
16:30:45 <shapr> if you can't read the type signature, and you don't understand typeclasses and parameterized datatypes, it's a lot harder to understand how monads work in Haskell.
16:31:19 <shapr> CLxyz: so, purely functional means that for each unique input, the function gives the same output
16:31:51 <wolfman8k> the thing about pureness is that it seems that object oriented programming can also be done in a pure way
16:31:59 <shapr> think about a pocket calculator, they usually have a button that saves the visible value to the memory
16:31:59 <Lor> It can.
16:32:40 <shapr> you can make that pocket calculator in Haskell by passing the memory value into the calculator function.
16:33:01 <shapr> something like 'calculate "1 + 1" 5'
16:33:07 <shapr> and 5 is the memory value
16:33:16 <Lor> Then again, one classic characterization of objects is "identity, behavior, state". A functional object would have neither identity nor state.
16:33:22 <shapr> and 1 + 1 is what the user gave as input.
16:33:47 <shapr> CLxyz: so, the memory is still saved, you still have 'statefulness' and yet, everything is pure and explicit.
16:34:08 <wolfman8k> Lor: wouldn't the state be something that you pass around to several functions?
16:35:21 <CLxyz> hrm...
16:35:29 <Lor> "State" in this context typically means something that can change in time.
16:35:41 * CLxyz goes code some more in hopes he'll eventuallly grok it
16:36:57 <wolfman8k> hm... so is haskell good for web programming? like cgi scripts?
16:40:55 <Lor> For web programming the absolutely best language is scheme.
16:41:18 <Lor> (Sorry, folks, that's the truth.)
16:41:39 <Lor> Haskell is still far, far better than, say, Java.
16:42:08 <CLxyz> Haha
16:42:28 <wolfman8k> what about ruby?
16:42:44 <Lor> Don't know about ruby.
16:42:52 <wolfman8k> python?
16:43:16 <CLxyz> python+
16:43:17 <CLxyz> ++
16:43:45 <Lor> Python doesn't have proper s-expressions, or macros, or (I think) even first-class continuations. All of these are what makes web programming scheme's forte.
16:43:59 <CLxyz> Heh, true
16:44:04 <CLxyz> but python is nice in general
16:44:18 <Lor> Many languages are nice in general.
16:44:43 <wolfman8k> ok, i have a very important question about haskell...
16:44:52 <CLxyz> hahaha
16:44:55 <wolfman8k> read is just a normal function right?
16:44:56 <CLxyz> okay, true
16:45:21 <Lor> Yes, read just turns a string into data of some other type.
16:45:51 <wolfman8k> so i can use read in my own (pure) functions?
16:45:57 <Lor> Yes.
16:46:05 <wolfman8k> what happens if there is a parse error in read?
16:46:43 <Lor> It's a bit hard to explain.
16:46:59 <wolfman8k> or what if there is a divide by zero? how are runtime errors handled?
16:47:06 <Lor> Then the value returned by read is not a proper value, and trying to use it will propagate the error further.
16:47:19 <wolfman8k> so it's like exceptions throwing?
16:47:37 <Lor> In practice, yes, and GHC does have a whole exception system for those.
16:47:54 <Lor> But in the haskell standard it is described in somewhat simpler terms.
16:48:47 <Lor> Exceptions in a lazy language are a very different beast from exceptions in a strict language.
16:49:10 <wolfman8k> this i think is what confuses me most about functional programming
16:49:19 <wolfman8k> error handling or whatever it is
16:52:43 <wolfman8k> like, there is a function
16:53:08 <wolfman8k> roots a b c
16:53:35 <wolfman8k> that returns the solution to a second order equation
16:54:51 <Lor> This describes how it works: http://citeseer.ist.psu.edu/196569.html
16:54:51 <wolfman8k> it returns a tuple of the two roots
16:55:03 * wolfman8k reads
16:56:07 <wolfman8k> hm... that seems like a lot of compliated shit
16:56:13 <Lor> You can skip the actual semantic formalisms, but the introduction and problem presentation are quite readable, imho.
16:58:29 <wolfman8k> that was published in october 1998. does the haskell 98 that everyone uses use that exception system?
16:59:25 <Lor> No.
17:00:11 <wolfman8k> hm... so there is no general accepted philosophy in functional programming for dealing with errors like sqrt -1?
17:01:18 <Lor> What's "generally accepted"? Haskell 98 has a simple error handling system, GHC has a more featureful system.
17:01:30 <wolfman8k> what about lisp?
17:02:46 <Lor> lisp is not functional programming
17:02:56 <wolfman8k> :O
17:03:32 <Lor> Well, unless you interpret it broadly so that it includes scheme.
17:03:54 <Lor> But common lisp does not encourage functional programming.
17:11:17 <dons> morning #haskell
17:11:23 <TheHunter> evening dons
17:12:22 <shapr> greetz dons 
17:13:23 <dons> hey shapr
17:13:34 <wolfman8k> what about ML?
17:14:08 <shapr> dons: whoops, sorry about that misspelling
17:14:17 <shapr> I hope I linked to the right homepage at least
17:14:31 <dons> yep
17:14:35 <dons> ;)
17:14:51 <shapr> ok, spelling corrected
17:15:21 <dons> hehe :)
17:15:23 <Lor> ML is perhaps slightly more functional than scheme, since scheme has mutable variables.
17:15:43 <TheHunter> ML hasn't?
17:16:01 <Lor> No. Only mutable data structures (references in particular).
17:16:23 <shrimpx> since the property "functional" is extremely debatable, i think arguments wrt degrees of functionalness are completely futile
17:16:53 <Lor> Probably, but one can still illustrate some points along the way.
17:17:03 <shapr> well, has higher order functions, allows mutability, what else?
17:20:09 <wolfman8k> night everyone thanks for help
17:20:19 <shapr> g'night 
17:31:51 <musasabi> morning
17:32:32 <Lor> musa, do you mean to imply that you woke up already?
17:33:15 <musasabi> no, I just didn't have time to eat breakfast earlier -> it is morning now.
17:33:30 <shapr> :-)
17:33:31 * Lor LOL. :D
17:33:36 <tuomov> heh. morning :)
17:33:54 <tuomov> and I really woke up just a few minutes ago
17:34:25 <shapr> I really like waking up at three or four in the morning.
17:34:55 <shapr> programming is for night-time, but I miss the sun. 3am wake time solves both of those problems.
17:35:17 <dons> :}
17:35:30 <tuomov> I can't do anything in a sunny environment
17:36:04 <shapr> I can't do anything if I'm wondering whether someone will come into my room at any moment.
17:37:14 <shapr> ok, so ... I got yampa Space Invaders to build
17:37:27 <shapr> now I'm looking for SyntaxNinja's patch that lets the aliens shoot back
17:37:51 <dons> tuomov: can you make the riot+hs-plugins tree available to play with?
17:38:19 <dons> or just tar it up and send it to me..?
17:39:02 <tuomov> just a moment
17:39:10 <shapr> Philippa: only now am I having the same 'Yampa Arcade is OO done badly' realization.
17:39:42 <shapr> man, haskell + yampa is like emacs + gnus
17:40:07 <shapr> whole 'nother world of stuff to learn, hidden cleverly inside the first
17:41:16 <tuomov> darcs get http://iki.fi/tuomov/repos/riot-hsplugins
17:41:39 <dons> cheers
17:41:47 * shapr slurps
17:42:56 <dons> shapr: it isn't working yet, afaik. doing some debugging...
17:43:00 <shapr> ah
17:43:20 <shapr> those lined up lambdas in IConv are visually entertaining.
17:44:20 <tuomov> peeking and poking is also so retro..
17:44:22 <shapr> dons: you know of any arrow-based interpreters other than those in ross paterson, john hughes, or ghc tests?
17:44:53 <shapr> LOAD "*",8,1
17:44:54 <dons> nope. haven't played with arrows very much
17:45:50 * dons sighs happily
17:45:57 <shapr> any idea who I can ask about arrows?
17:46:01 <dons> chasing bugs is so relaxing on a sunny sunday morning
17:46:09 <shapr> I sent email to Ross Paterson, he didn't know of anything else.
17:46:57 <dons> hmm. you could ask on glasgow-haskell-users, or cafe
17:47:28 <shapr> good point
18:06:30 <shapr> monochrom: Paul is thinking about hour != output also - http://paulgraham.com/bubble.html
18:24:11 <shrimpx> he used a lot more profanity in the actual speech :)
18:28:30 <tuomov> It was cold outside.
18:29:11 <tuomov> 1.8C
18:31:06 <shapr> the snow is still on the ground here
18:32:45 <shapr> @index >>^
18:32:45 <lambdabot> bzzt
18:36:40 <shapr> is it my imagination, or is the world of programming language geeks quite small?
18:40:46 <mattam> the world's already quite small
18:45:22 <dons> ok. got riot built on openbsd :)
19:48:48 <dons> tuomov: Loading package base ginsu haskell98 unix ... linking ... done
19:48:49 <dons> Loading object Config ... done
19:48:54 <dons> :D
19:49:59 <tuomov> what did you do?
19:51:52 <dons> ginsu/ was missing the -package-name ginsu flag, so it was detected as a pkg dependency
19:52:15 <dons> couple of other less important things. i'll send you the patch once I straighten it out
19:52:33 <dons> s/it was detected/it wasn't detected/
23:14:38 <dons> yay. riot + hs-plugins!
23:21:40 <tuomov> could you send the patch the proper darcs way so all I have to do is apply it?
23:22:40 <tuomov> darcs add new files; darcs record -a; darcs send
23:24:33 <dons> ok. i'll have a go
23:42:55 <musasabi> What is the difference between ST and State monads ?
23:45:09 <musasabi> The paper which the documentation references speaks about variables inside ST, but the documentation speaks only of arrays.
23:47:38 <dons> tuomov: there you go. hope it worked
23:49:18 <tuomov> hmm.. the ginsu files should actually have been 'darcs mv'd
23:49:50 <dons> oh. ok. can do.
