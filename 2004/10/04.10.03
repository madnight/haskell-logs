05:04:21 <Jad> @moo
05:04:22 <lambdabot>          (__)
05:04:22 <lambdabot>          (oo)
05:04:22 <lambdabot>    /------\/
05:04:22 <lambdabot>   / |    ||
05:04:22 <lambdabot>  *  /\---/\
05:04:23 <lambdabot>     ~~   ~~
05:04:25 <lambdabot> ...."Have you mooed today?"...
05:22:03 <bbls> @moo
05:22:04 <lambdabot>          (__)
05:22:04 <lambdabot>          (oo)
05:22:04 <lambdabot>    /------\/
05:22:04 <lambdabot>   / |    ||
05:22:04 <lambdabot>  *  /\---/\
05:22:05 <lambdabot>     ~~   ~~
05:22:07 <lambdabot> ...."Have you mooed today?"...
05:22:11 <bbls> @boo
05:22:11 <lambdabot> Sorry, I don't know the command "boo", try "lambdabot: @listcommands"
05:22:16 <bbls> @listcommands
05:22:16 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
05:22:16 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
05:22:16 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
05:22:17 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
05:22:19 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
05:22:21 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
05:22:23 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
05:22:25 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
05:22:27 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
05:22:32 <bbls> @dynamic-load
05:22:32 <lambdabot> not enough privileges
05:22:38 <bbls> @more
05:22:38 <lambdabot> wrong type (<<[] Char>>) in ModuleState
05:22:47 <bbls> @hello
05:22:47 <lambdabot> Hello world. 
05:22:56 <bbls> @devils
05:23:07 <bbls> @web1913
05:23:19 <tromp> @eurohaskell
05:23:19 <lambdabot> less talks, more code!
05:23:19 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
05:23:19 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
05:23:33 <tromp> what, next year?
05:24:26 <polli> tromp: was this year and I assume that it will be next year aswell
05:35:14 <shapr> tromp: http://andersca.org/gallery/eurohaskell
05:35:44 <shapr> hej Xen 
05:36:28 <tromp> thx, polli&shapr
05:36:50 <shapr> tromp: you want to come to EuroHaskell next year?
05:37:27 <tromp> hey, i see a unicycler!
05:37:40 <shapr> tromp: that would be me
05:37:48 <tromp> i suspected as much:P
05:38:13 <shapr> and the guy with the nice longsleeved shirt and the beard is John Hughes
05:38:17 <tromp> although i thought you were beyond the helmet stage:)
05:38:26 <shapr> author of "generalizing monads to arrows"
05:38:37 <shapr> I make a living by using my brain, I always wear a helmet.
05:39:30 <Xen> hi :)
05:40:10 <tromp> did john master the unicycle?
05:40:15 <shapr> here you can see the EuroHaskell version of hOp - http://andersca.org/gallery/eurohaskell/p1010034
05:40:46 <shapr> It took me about ten hours of training to ride a unicycle. I think it would take John less time.
05:43:28 <tromp> i'll keep it in mind for next year
05:56:23 <shapr> tromp: last time, admission was one beverage of your choice, to be consumed by the attendee during the social part of the program
06:10:46 <Philippa> shapr: subject to money I'll try to make it to EuroHaskell this year
06:22:17 <eek> is there any way to make the build for ghc *not* wipe everything on re-build, but instead follow the standard procedure of using existing object files?
06:22:51 <eek> it is not immediately obvious where the "find + rm" it runs comes from
06:24:21 * eek is >< far from discarding Haskell over the build procedure of ghc
06:25:47 <Lemmih_> Why are you building GHC from source?
06:27:52 <eek> Lemmih: because I want it into my system using the standard way of packaging stuff, and that includes building from source.  (and my system is far enough off standard that I don't think the newer packages would work, anyway)
06:31:01 <opet> hey eek
06:31:20 <eek> hi, opet :-)
06:34:11 <Igloo> ghc doesn't wipe everything if you type make in a built tree
06:34:28 <Igloo> It will relink a few things, and maybe recompile a couple, though
06:35:02 <eek> Igloo: I'm seeing a "find <stuff> | xargs rm"
06:35:14 <eek> Igloo: for directories named <something>_split
06:36:05 <eek> besides which the linking is the main problem; it's running ar in a fashion which makes my box more or less unusable for other tasks, due to the insane memory usage :-(
06:36:32 <Igloo> I don't think I see that, but that's just chopping object files into chunks anyway, should be quick
06:37:03 <Igloo> If I do see it it must be very quick
06:38:14 <eek> Igloo: may be a memory issue.  I'm seeing memory overflow (256MB box running X etc in addition to the build), swapping, and nasty timeuse
06:39:17 <eek> but example compile line:
06:39:21 <eek> rm -f Text/ParserCombinators/Parsec/Combinator.p_o; if [ ! -d Text/ParserCombinators/Parsec/Combinator_split ]; then mkdir Text/ParserCombinators/Parsec/Combinator_split; else /usr/bin/find Text/ParserCombinators/Parsec/Combinator_split -name '*.p_o' -print | xargs rm -f __rm_food; fi;   
06:39:25 <Igloo> I meant the _split stuff. The linking can be slow, especially if you don't have enough RAM.
06:39:42 <kristnjov> wtf... is this haskell?
06:39:44 <eek> Igloo: then it starts rebuilding the stuff it built the last iteration
06:40:36 <eek> kristnjov: it comes when I start building the ghc port on FreeBSD
06:41:49 <opet> eek: obraun@ has been really helpful whenever I've had haskell-on-freebsd questions
06:43:24 <eek> opet: doesn't look at all like a Haskell-on-FreeBSD issue; it looks like a "ghc-on-Unix" issue (specifically, a "person doing build tasks do not know the conventions for Unix builds" issue)
06:45:13 <eek> opet: and it's not that I can't solve it - it is just that I get highly annoyed when somebody is specifically screwing over me and everybody else that has environmental issues in the build and know what they are doing.
06:51:29 <Jan_w> suppose i define a class
06:51:29 <Jan_w> class Afdrukbaar a where 
06:51:30 <Jan_w>   toString :: a -> String
06:51:30 <Jan_w>   size     :: a -> Int
06:51:30 <Jan_w>   height   :: a -> Int
06:51:34 <Jan_w> and some instances of it
06:51:51 <Jan_w> how do I call the functions of it ?
06:54:33 <wouter> Jan_w: just use "toString" or whatever function you have in mind.
06:54:54 <Jan_w> ok
06:55:00 <Jan_w> testf :: Afdrukbaar x => x -> Int
06:55:00 <Jan_w> testf x = size x
06:55:16 <wouter> that should work fine.
06:55:22 <Jan_w> when i do testf 4, i get testf :: Afdrukbaar x => x -> Int
06:55:22 <Jan_w> testf x = size x
06:55:27 <Jan_w> whoops
06:55:30 <kristnjov> just use "show x"
06:55:36 <Jan_w>  Unresolved overloading  
06:55:54 <kristnjov> or x::String
06:56:07 <kristnjov> read x::String
06:56:41 <Jan_w> testf 3 gives me ERROR - Unresolved overloading *** Type       : (Num a, Afdrukbaar a) => Int *** Expression : testf 3    
06:57:06 <wouter> aha - try "testf (3 :: Int)"
06:57:38 <Jan_w> that does work
06:58:04 <Jan_w> i tried defining "instance Afdrukbaar Num " but that wasn't possible ?
06:58:16 <wouter> the problem is that "digits" are overloaded - 3 could be an Int, but also an Integer.
06:58:39 <wouter> you could write class Num a => Afdrukbaar a
07:00:17 <Jan_w> that would make Afdrukbaar inhirit from Num ?
07:00:36 <Jan_w> but class Num a => Afdrukbaar a
07:01:03 <Jan_w> would make the Afdrukbaar unusable from Bool s wouldn't  it ?
07:01:20 <Jan_w> would "instance Afdrukbaar Bool" still be possible?
07:01:24 <wouter> the idea is to make every type in Num an instance of Afdrukbaar
07:01:24 <kristnjov> damn that's an annoying name for a class, Afdrukbaar
07:01:41 <wouter> there is no problem with adding additional instances for things not in Num
07:01:44 <wouter> such as Bool.
07:02:09 <Jan_w> kristnjov: Printable better ?
07:02:22 <kristnjov> Jan_w, yes.
07:02:32 <kristnjov> not that it was any of my business though
07:02:38 <Jan_w> hehe
07:02:55 <wouter> Afdrukbaar is Dutch for printable.
07:03:07 <kristnjov> yeah i could tell it was dutch
07:03:12 <kristnjov> you guys have a weird language indeed :P
07:03:19 <kristnjov> it's not german and not quite anything else
07:03:23 <Jan_w> jag prater svenska , but i don;t know printable
07:03:32 <kristnjov> hahaha
07:03:43 <kristnjov> printable in sweden is utskrivningsbar or something
07:03:45 <Jan_w> well svenska is not much better  :)
07:03:50 <Jan_w> HAHA
07:04:14 <Jan_w> class Utskrivningbar
07:04:24 <Jan_w> fine that's what i'll call it :)
07:04:35 <Jan_w> with an s
07:05:19 <eek> my experience has always been that programming in anything but english only lead to trouble
07:06:29 <Jan_w> eek: well that problem is that the statements and programming language fundamentals are in english 
07:06:53 <Jan_w> if programming in any other language would read bad, because of the mix
07:07:02 <Jan_w> in my experience
07:07:06 <eek> Jan_w: and that most CS concepts are fairly clear in english, while translations to other languages are more fuzzy
07:07:48 <wouter> eek: but then again I tend to use the english word for technical terms.
07:08:06 <eek> wouter: I do, too.
07:08:30 <wouter> that gives me an edge of native speakers - in english once you talk about a "type"
07:08:49 <wouter> you could mean the technical term or the more informal variant.
07:10:36 <eek> wouter: if only "type" had had a precsie meaning even as a technical term ;)   (it does in certain contexts, of course)
07:18:48 <Jan_w> 18380 reductions, 29865 cells
07:19:10 <Jan_w> what does that meam ? are more reductions good ? 
07:19:29 <Igloo> reductions are work
07:19:39 <Jan_w> ok
07:19:58 <Igloo> So no, they're bad
07:21:41 <Jan_w> i don't get it
07:21:42 <Jan_w> filterFirst :: (a -> Bool) -> [a] -> [a]
07:21:42 <Jan_w> filterFirst f (x:xs)
07:21:42 <Jan_w>  | (f x) == False    = xs
07:21:42 <Jan_w>  | otherwise         = x:(filterFirst f xs)
07:22:05 <Jan_w> filters the first element that does not match f
07:22:25 <Jan_w> now when I want to filter the last that does not match
07:22:25 <Jan_w> filterLastLame :: (a -> Bool) -> [a] -> [a]
07:22:25 <Jan_w> filterLastLame f a = reverse (filterFirst f (reverse a))
07:22:37 <Jan_w> (3858 reductions, 5939 cells)
07:22:52 <Jan_w> but that requires two reverses
07:23:31 <Jan_w> but when i try to iterate the list in reverse order (with init and last) i get much worse performance
07:23:38 <Jan_w> (18380 reductions, 29865 cells)
07:24:19 <Igloo> Iteratively using init and last will do n inits, giving quadratic performance
07:24:36 <Igloo> The two reverses take linear time
07:24:54 <Igloo> n inits and n lasts, I should say
07:25:15 <Jan_w> hm, so init and lasts take much more time then x:xs ?
07:25:27 <Igloo> Yes
07:25:29 <Jan_w> thats weird
07:25:39 <Igloo> You have to walk down the whole list to do them
07:25:40 <Jan_w> i need xs:x :))
07:26:18 <Jan_w> Igloo: that depends on the implementation
07:26:20 <Igloo> You might want to look at edison, or perhaps okasaki's datastructures, if you want that
07:27:44 <Jan_w> hm, okasaki has done much (google is swarming with it), any specific links for that ?
07:28:08 <Igloo> No, sorry
07:28:30 <Igloo> edison is what I think is more likely to help, anyway
07:29:31 <Jan_w> Edison is a library of data-structures by Chris Okasaki
07:30:06 <Igloo> Oh, I'd forgotten he was the original author
07:45:20 <Jan_w> hm, instance (Ord a, Ord b) => Ord (a,b) gives me Overlapping instances for class "Ord", can I override it myself ?
07:46:34 <TheHunter> Jan_w: That is already defined in the prelude.
07:46:54 <TheHunter> Prelude> (1,4) < (4, 1)
07:46:55 <TheHunter> True
07:47:07 <Jan_w> hm, can i override that ?
07:47:23 <Igloo> If you want to override it then newtype MyTuple a b = MyTuple (a, b) and give an instance for MyTuple
07:47:23 <TheHunter> i don't think so
07:50:06 <Jan_w> Igloo: should i create a class MyTuple that inhirits from Ord ?
07:50:59 <TheHunter> instance (Ord a, Ord b) => Ord (MyTuple a b) where...
07:51:09 * Jan_w is confused because classes look like types to me in haskell ":)
07:52:18 <TheHunter> forget everything about classes in other languages when you think about haskell's type classes. (You might compare them to Java interfaces, though i don't know if this is helpful)
07:52:28 <desrt> Jan_w; does the term "interface" make sense to you?
07:52:54 <Jan_w> yes, i know java
07:53:01 <desrt> that's all typeclasses are
07:53:40 <Jan_w> and instances are "like" classes that implement the interface ?
07:54:01 <Jan_w> (although i think this analogy is indeed needlessly messy :)
07:54:20 <desrt> yes.  it's a lot like that
07:54:51 <desrt> so something can be called Enum if it impliments all that is required for enum types
07:54:58 <desrt> (like succ, for example)
07:55:32 <Jan_w> ok
07:55:32 <desrt> take a look at :i Enum
07:56:03 <Jan_w> hmm
07:56:05 <Jan_w> nice
07:56:37 <desrt> mm.  tea's on.  bbiab =)
07:58:08 <Jan_w> in instance (Ord a, Ord b) => Ord (MyTuple a b)   you first restrict a and b to Ord  and then after the => what does that mean?
08:03:28 <Jan_w> :i Ord gives me the class Ord , can I also view the implementation of an instance ?
08:06:34 <TheHunter> it means: if a and b are instances of Ord then make MyTuple a b an instance of Ord, too
08:07:32 <TheHunter> you can't see the implementation in hugs/ghci but the library files are distributed with hugs for example
08:08:33 <Jan_w> ok, so all I need to do is implement the 7 functions of the Ord class for (MyTuple a b )
08:09:45 <Jan_w> for instance, the first fucntion compare (MyTuple a b) (MyTuple c d)   = (a == c)
08:10:03 <TheHunter> the comment in the source of the Prelude says:
08:10:14 <TheHunter> -- Minimal complete definition: (<=) or compare
08:10:38 <TheHunter> so you only need to implement either (<=) or compare, the rest will be infered automatically
08:12:35 <Jan_w> hm..
08:13:07 <Jan_w> instance (Ord a, Ord b) => Ord (MyTuple a b) where 	 - Cannot build superclass instance, required superclass Eq
08:13:07 <Jan_w>   (<=) (MyTuple (a,b)) (MyTuple (c,d))       = (a <= c)
08:13:38 <Jan_w> by saying instance (Ord a, Ord b) you already imply Eq I thought ?
08:13:44 <TheHunter> it's class Eq a => Ord a, so if you want a type instance of Ord, you must ensure that it already is an instance of Eq
08:14:29 <TheHunter> yep, you know that (Eq a) and (Eq b)
08:15:57 <Jan_w> ok, that makes sence, but wants wrong then ? why cannot build superclass ?
08:17:06 <TheHunter> the compiler complains that it doesn't know how to make (MyTuple a b) an instance of Eq
08:18:10 <TheHunter> ...so you'll have to tell it how.
08:18:14 <Jan_w> it wont help to add   (==) (MyTuple (a,b)) (MyTuple (c,d))       = (a == c)
08:18:23 <Jan_w> because thats not part of Ord
08:18:30 <Boegel> hello everyone
08:19:06 <TheHunter> Jan_w: this is exactly what you need to do, but you have to write instance (Eq a, Eq b) => Eq (MyTuple a b) before
08:19:07 <Jan_w> perhaps if I define  instance (Eq a, Eq b) => Eq (MyTuple a b) where 
08:19:11 <TheHunter> exactly
08:19:13 <TheHunter> hi, Boegel 
08:19:46 <Jan_w> TheHunter: cool!
08:20:18 <TheHunter> And now that you know how to make types an instance of Eq, I'll tell you how the compiler can do it for you.
08:20:21 <Jan_w> hm, going to do some testing
08:20:36 <Jan_w> TheHunter: haha
08:20:45 <Jan_w> TheHunter: can it ?
08:20:47 <Boegel> my ray tracing algorithm is almost done in FunMath
08:20:59 <TheHunter> just define newtype MyTuple a b = MyTuple (a,b) deriving (Eq)
08:21:08 <Boegel> but I think I could write better, more elagant functions for it
08:21:18 <Boegel> I want to get it working first though
08:21:57 <Jan_w> TheHunter: how will that work? are MyTuple (a,b) and MyTuple (c,d) considered equals if a=c and b=d ?
08:22:24 <TheHunter> actually, if (a,b)==(c,d) but that amounts to the same thing
08:22:50 <pesco> Good day, #haskell!
08:23:01 <TheHunter> in a similar way, you can generate Show, Ord, Enum, Read, ... instances
08:23:02 <Boegel> hello, pesco
08:23:51 <pesco> Hey, are there any Czechs here, by any chance?
08:26:14 <Jan_w> TheHunter: what would happen if said newtype MyTuple a b = MyTuple (a,b) deriving (Ord) ? in MyTuple (a,b) vs MyTuple (c,d) when would (a,b) > (c,d) ?  if a>c and b>d,  just one of the two or, it's this definition just not possible ?
08:27:23 <Igloo> Lexicographical ordering. Exactly the same ordering as if you just used (a, b) instead of MyTuple
08:28:24 <Jan_w> that means, that b and d have no effect on ordening ?
08:28:44 <Jan_w> no
08:28:45 <Jan_w> sorry
08:30:01 <Jan_w> it means that only if a == c  b and d are compared ?
08:30:03 <TheHunter> (a,b) < (c,d) = if a == c then b < d else a < c
08:30:13 <Jan_w> hehe
08:31:19 <Jan_w> hm, i'm really beginnen to wrap my head around functional programming
08:31:20 <monochrom> "dictionary order".  Use the first letter to compare; if tie, only then use second letter.
08:31:55 <Jan_w> ok
08:39:42 <Jan_w> do i have to include (or install) anything to use the Edison Sequences ?
08:39:47 <Jan_w> (using hugs)
08:40:36 <TheHunter> yes
08:40:47 <Igloo> Doesn't hugs come with edison?
08:40:51 <TheHunter> (not using ghc, though)
08:40:57 <Jan_w> i read something about it hslibs?
08:41:10 <Jan_w> is that a library that contains edison ?
08:41:43 <Jan_w> well i have ghc also, checking
08:42:09 <Jan_w> hm, EdisonPrelude.hi
08:42:29 <Jan_w> can i copy that to the hugs lib dir ?
08:42:42 <TheHunter> no, you'll need the source
08:42:47 <Jan_w> oh
08:44:50 <Jan_w> the haskell site says Edison (part of hslibs/data), but Hierarchical Libraries list does not show  hslibs
08:45:19 * Igloo has a /usr/lib/hugs/oldlib/EdisonPrelude.hs
08:46:34 <TheHunter> $ ls -l /usr/lib/hugs/oldlib/EdisonPrelude.hs 
08:46:34 <TheHunter> -rw-r--r--  1 root root 875 2003-12-03 02:50 /usr/lib/hugs/oldlib/EdisonPrelude.hs
08:47:22 <TheHunter> Jan_w: do you use debian?
08:47:49 <Jan_w> no, ghc under cygwin :)
08:48:22 <Jan_w> do I have redhat and mandrake also
08:48:30 <Jan_w> on my servers
08:49:03 <TheHunter> Jan_w: sorry, i don't know where to get the edison files from.
08:49:57 <TheHunter> but if you have ghc, you might as well use ghci
08:50:39 <Jan_w> hm, ok
08:50:52 <Jan_w> that will be fine to it seems
08:51:16 <Jan_w> i need to compile with ghc eventually anyway to wrap it into a dll
08:51:40 <TheHunter> it also has the advantage that you can define functions in your current session (let f x = x+x)
08:52:03 <Jan_w> ok
08:52:10 <Jan_w> thats nice
08:54:52 <Jan_w> creating a dll was remarkably simple, using hdirect to link the code directly into a program did not work so far
08:54:57 <dx> http://transfixion.org/files/prime.hs <-- what do i need to do to fix this error?
08:56:08 <TheHunter> round -> floor
08:56:36 <dx> same
08:57:15 <TheHunter> yeah, you're right round is better
08:58:44 <TheHunter> you need some fromIntegrals somewhere
08:59:23 <TheHunter>                 high = (round . sqrt . fromIntegral) n
09:00:15 <dx> hm ok. thanks
09:13:55 <Jan_w> hm, data Mobiel = Leaf Int | Node Int (Mobiel) Int (Mobiel) deriving (Show)                   
09:14:28 * shapr boings
09:14:44 <shapr> the hills are alive with the sound of music!
09:14:52 <Jan_w> i've derived Show, but i want to make Mobiel (a mobile) a member of Eq and Ord, which i implement myself ... how can i do that ?
09:15:14 <Jan_w> shapr (sound of music or moulin rouge :)
09:15:42 <TheHunter> it's basically the same as for the Printable thingie
09:15:54 <shapr> Jan_w: moulin rouge, as loud as possible.
09:16:05 <Jan_w> but now i have data thingy, not a type thingy ::)
09:16:06 <TheHunter> instance Eq Mobile where
09:16:24 <shapr> I think my neighbors like my voice, but wish I would sing something else.
09:16:26 <TheHunter> oh, newtype and data are basically the same
09:16:54 <Jan_w> shapr: roxanne RULEZ!
09:17:03 <shapr> Jan_w: it sure does!
09:17:22 * shapr does the gravelly rRRrRooowksanne!
09:17:48 <Jan_w> i like the violins!,
09:17:49 * Marvin-- eyes shapr warily
09:17:49 <Jan_w> grrrr
09:17:51 <shapr> I wish they'd put 'the hills are alive' on the soundtrack.
09:18:02 <shapr> that's the only music part they left out.
09:18:06 <shapr> Marvin--: moulin rouge
09:18:21 <Marvin--> oh
09:18:44 <Jan_w> shapr: i only have the "sound of music version", but it sucks
09:19:18 <Jan_w> shapr: i could record it from the dvd :_)
09:19:30 <shapr> Jan_w: I think elton john or someone did "my gift is my song" first, and I just wasn't impressed. When Ewan McGregor did it, I was addicted.
09:19:37 <shapr> that guy can sing!
09:20:21 <Jan_w> he wasn't really known for his singing before moulin rouge was he ?
09:20:57 <shapr> the soundtrack is primarily a real soundtrack, with only the occasional media-whoring cross-advertising song from PiNK, and some other singy chix.
09:21:46 <shapr> Yes, he was. He did a great bit in "Down With Love" for example, but I've never heard him in a real musical. Obviously I've been missing out.
09:23:42 <shapr> I'm looking forward to future productions from Baz Luhrmann.
09:24:41 <shapr> anyway, we now return you to your regularly scheduled programming discussion =)
09:25:49 <Jan_w> hehe
09:26:42 <Jan_w> hm, i don't understand: instance Eq Mobiel where
09:26:42 <Jan_w>   (==) (Leaf a) (Leaf b)       = (a == b)
09:26:56 <Jan_w> this is accepted
09:27:05 <Cale> Jan_w: Two leaves are equal if they carry equal values.
09:27:23 <Jan_w> BUT, Mobiel can also be Nodes 
09:27:25 <Marvin--> you could also write    Leaf a == Leaf b  =  a == b
09:27:41 <Cale> Jan_w: so there ought to be another line for (==)
09:28:09 <Jan_w> why is this acceptable without the other line (or will that problem show itself runtime)
09:28:38 <Marvin--> it will cause a runtime error, yes
09:28:38 <Cale> You'll get an error at runtime, and you should also get a warning at compile time.
09:29:17 <Marvin--> I think you need -Wall to get warnings about that
09:29:29 <Marvin--> or maybe that's just for ghci
09:29:35 <Jan_w> so i should implement (==) Mobiel Leaf Leaf, Mobiel Leaf Node and Mobiel Node Leaf ?
09:29:51 <Jan_w> i get no warning in hugs anyway
09:30:32 <Marvin--> ghc(i) -Wall will warn about missing cases
09:30:37 <TheHunter> Jan_w: exactly
09:30:54 <Marvin--> Jan_w: and probably Node Node too :)
09:30:55 <Cale> Jan_w: I recommend just using a recursive definition (Mobiel a b) == (Mobiel c d) = (a == c) && (b == d)
09:31:32 <Marvin--> Jan_w: or is Mobiel a constructor? I thought Mobiel was the type and that it had constructors Node and Leaf
09:32:05 <Cale> yeah -- it's not clear what the data type declaration looks like :)
09:32:24 <Jan_w> Cale: data Mobiel = Leaf Int | Node Int (Mobiel) Int (Mobiel) deriving (Show)               
09:33:07 <Marvin--> then you should probably have cases for   Leaf x == Leaf y  and  Node .... == Node ....
09:33:10 <Jan_w> Cale: i don't see how the recursive definition would work on that
09:33:21 <Jan_w> Marvin--: ok
09:33:32 <Cale> (Node n a m b) == (Node n' a' m' b') = (n == n') && (m == m') && (a == a') && (b == b')
09:34:03 <Cale> (which is basically what you'll get with deriving Eq)
09:34:10 <Marvin--> and a catch-all case   x == y = False  (this will catch the cases of Node .... == Leaf . and Leaf . == Node ....)
09:34:47 <Cale> unless it is the case that you want structurally different trees to be equal somehow
09:35:01 <Jan_w> Cale: i do
09:35:02 <Jan_w> :)
09:35:33 <Marvin--> then you're on your own! Mwhahaha!
09:35:37 <Jan_w> hehe
09:35:48 <Jan_w> if Node n*a == m*b this should be considered equals
09:35:51 <Marvin--> (as in, we can't help you unless you give us more info to work with ;)
09:36:22 <Jan_w> i'll try implementing the seporate cases first :)
09:37:43 <Marvin--> http://yro.slashdot.org/article.pl?sid=04/10/03/1352252&tid=123&tid=108&tid=155&tid=102&tid=98     WTF!?
09:38:18 <Igloo> Oh dear
09:39:02 <Marvin--> this is...absurd
09:39:19 <Jan_w> hahhaa
09:39:23 <Jan_w> nice
09:40:05 <Marvin--> I mean, forget Java, what about *Smalltalk*?
09:40:24 <Igloo> The article doesn't sound like they've actually won it, though
09:40:39 <Igloo> Oh, it's won something but damages haven't been decided?
09:41:02 <Marvin--> right
09:41:07 <tromp> another victory for the lawyers!
09:41:24 <shapr> http://www.groklaw.net/article.php?story=20041003041632172
09:41:51 <Marvin--> "The jury decided in Rochester on Friday that Sun infringed on technology belonging to Kodak when it developed and introduced Java more than a decade ago."
09:41:59 <tromp> u can't really blame kodak or the lawyers though. they're all just taking advantage of a totally broken patent system
09:42:24 <eek> tromp: yes, we can.
09:42:33 <shapr> I don't sue people.
09:42:48 <eek> tromp: having a broken system is NOT an excuse for exploiting the broken system
09:42:58 <TheHunter> well, at least you can blame the judge for having lost the last piece of common sense
09:43:22 <tromp> it's an open invitation
09:43:23 <shapr> the sucky part is that some companies seem to enjoy and profit from having the system the way it is.
09:43:34 <Marvin--> I blame *both* the system and Kodak
09:43:38 <tromp> i'd blame the legislators
09:44:29 <shapr> That groklaw article is neat.
09:44:31 <Marvin--> I'm not opposed to the general idea of patents, but the whole idea that software should be patentable and that you can buy and sell patents and not lose the right to patents if you don't implement them is...absurd
09:44:37 <eek> Marvin--: I agree
09:45:01 <eek> Marvin--: on both blaiming system+Kodak and on software patents
09:45:20 <eek> Marvin--: I'm not sure if patents is the right tool *at all* today, but I'm sure it is wrong for software
09:45:22 <shapr> f
09:45:22 <tromp> i can see some breakthrough algorithms as being worthy of a patent, but 99.9% of existing software patens is total bullshit
09:45:38 <musasabi> tromp: I don't think so.
09:46:04 <musasabi> Think about what would have happened if e.g. hash tables and balanced trees were patented ;)
09:46:20 <eek> Marvin--: as for other industries: there are a large number of problems that are tied to the medical industry getting patents.  specifically, they end up with researching less useful medicines because these are patentable
09:46:20 <shapr> I do know that in the current system, it is dangerous for me personally to be a programmer.
09:47:02 <eek> Marvin--: it seems better to have a monopoly traded for specific research, reviewed on a case by case basis.
09:47:23 <tromp> if some1 discovers new crypto that is both practicle and provably secure (NP hard) then I'd want them to be able to profit from it
09:47:41 <tromp> so i can see patents being useful there
09:47:46 <Jan_w> whatever the system dictates, this is purely the way the judge interpreted the arcade laws that didn't apply to software in the first place
09:48:05 <shapr> with the speed of development in the software industry, patents there should last about six months.
09:48:08 <eek> tromp: the cryptologists say there is no money to be had there.
09:49:11 <tromp> how long do software patents last currently?
09:49:19 <shapr> I think the standard seventeen years.
09:49:47 <tromp> i think between 2 and 5 years is appropriate for software
09:49:51 <eek> shapr: yes
09:50:22 <eek> tromp: there are way too many software patents; and it is unclear if there could be fewer if software patents were allowed at all
09:50:24 <shapr> the *only* good side of all this patent crap is that my kids will be able to write any sort of code
09:50:55 <Igloo> But they would even if there weren't patents
09:51:13 <eek> tromp: and I've not seen ANY cases of there being software that was clearly patentable
09:51:14 <Igloo> And you also assume everything will be invented in time, which history teaches us is a bad thing to assume
09:51:26 <eek> tromp: ie, that clearly gives a benefit to the world by being patentable
09:51:41 <musasabi> tromp: If such a short patent is actively enforced very few will use it and the product will have less success (interoperatiblity), and if it is a submarine patent it is either used in bad faith or is worthless.
09:51:48 <tromp> i agree eek there are way too many. only 1 or 2 should be accepted per year if they only rewarded breakthrough innovations
09:52:10 <shapr> Igloo: good point
09:52:22 <tromp> i'd also be happy to just see them totally abolished
09:52:27 <musasabi> tromp: Could you tell what things should have been granted a patent in the past?
09:52:33 <eek> tromp: that might be useful; I find it very hard to draw the lines for what's breakthrough, though :-(
09:52:41 <shapr> yah, blow away the software patent system, it sucks way too much.
09:52:50 <eek> tromp: I was also going to ask musasabi's question :-)
09:52:55 <shapr> what if John Hughes had patented Arrows?
09:53:08 <shapr> or what if Wadler had patented monads in programming languages?
09:53:31 <tromp> musasabi, i was gonna suggest RSA, but i understand there were some issues there
09:54:02 <musasabi> tromp: ~Nobody would have used it if it was patented.
09:54:11 <eek> tromp: RSA and Diffie-Hellman was independently discovered in at least the british 
09:54:17 <eek> musasabi: RSA *was* patented.
09:54:24 <eek> tromp: british intelligence
09:54:31 <musasabi> eek: yes but an enforced patent with royalties.
09:54:45 <tromp> the british wld've kept it secret
09:54:47 <musasabi> tromp: With cryptos it is as much about popularity as strength.
09:55:13 <musasabi> I don't see the idea of patents wich are not used.
09:55:20 <eek> musasabi: it was an enforced patent with royalties.  this blocked to a large degree use of PK for a long while; but it was also impractical (due to CPU constraints) most of the time the patent was active
09:55:50 <eek> tromp: my point was that it was something that was fairly clear would be discovered when one started looking at that problem space
09:55:50 <musasabi> eek: so you are repeating my point.
09:56:13 <tromp> without patents, rsa would have been succesful anyway, they wld simply have to put up with a few less reputable competitors
09:56:18 <musasabi> eek: "a crypto won't become very popular with royalties".
09:56:26 <eek> musasabi: I definately agree with that point.
09:56:42 <eek> musasabi: I was just making the facts correct :-)
09:56:43 <shapr> the goal of the patent system is to encourage inventors to properly document their ideas for later public benefit.
09:56:54 <eek> this does not work
09:57:03 <eek> who here looks at patents when they want to implement something?
09:57:10 <shapr> not me
09:57:11 <eek> to find out how to do the thing, I mean
09:57:32 <Maddas> Aren't engineers in larger companies usually asked *not* to look at patents?
09:57:35 <shapr> yes
09:57:39 <eek> Maddas: yup
09:57:52 <shapr> because if you have looked at a patent and then violated it, you pay triple damages
09:58:00 <Maddas> Yeah
09:58:12 <shapr> so, the patent system does not fulfill its goals
09:58:18 <shapr> it actively blocks its goals
09:58:26 <shapr> what a stupid system!
09:59:07 <shapr> I can't even submit an idea to the patent office and find out if it's already patented.
09:59:26 <Maddas> Why, too much overhead for the patent office?
09:59:29 <eek> shapr: yes, you can - that's known as a "patent application"
09:59:29 <shapr> I actually do have some ideas that might be worth patenting, and I have an aunt who is a patent lawyer.
10:00:03 <shapr> So I asked her, she said that it would probably take a year and $100,000 to do it right.
10:00:17 <tromp> it shld only take $20k
10:00:20 <Maddas> Ouch
10:00:35 <Maddas> Sounds like a hefty bill for a seemingly fairly simple question
10:00:35 <shapr> $20,000 is still too much.
10:00:39 <eek> shapr: that was expensive.  what kind of patent?  ran about $35k last time I was involved...
10:00:47 <Maddas> Especially a question that one expect to be asked often
10:00:51 <Maddas> one would expect, even.
10:01:06 <shapr> eek: high tech stuff
10:01:14 <eek> it's horribly expensive.
10:01:20 <tromp> an implementation of haskell that's faster than C :-?
10:01:47 <tromp> 'you'd have to agree that wld be worthy of a patent:P
10:01:49 <eek> shapr: I was involved in a company that had patented a design for hands-frees
10:02:14 <shapr> so, I can afford to pay maybe a thousand bucks for a patent, but even that seems too expensive.
10:02:33 <shapr> I'm not documenting my various ideas because I can't afford to...
10:02:42 <eek> shapr: do you need the patent protection or just enforcing that prior art exists so you can't get sued?
10:03:09 <Maddas> shapr: :-(
10:03:13 <eek> shapr: the latter can be done with a preliminary patent that you let expire; it's $75 or $100 now, I think (used to be $50)
10:03:37 <musasabi> shapr: publishing results in written media can help too.
10:03:39 <shapr> eek: it's in optical computing, which has a very vicious set of patents already. I suspect my idea is unique and worth developing, but how can I be sure?
10:03:45 <musasabi> but it cannot avoid getting sued.
10:05:02 <tromp> do enough research until you're *sure* it's worth developing, then develop it...
10:05:14 <eek> shapr: write a business plan, talk to a VC
10:05:49 <eek> shapr: it's interesting: lawyers say that you need patents.  VCs think it is generally a waste of time.  from what I've understood.
10:06:13 <Igloo> AIUI having patents helps you get VC, which implies that isn't so
10:06:32 <tromp> lawyers say that you shld provide business for them? how surprising:-?!
10:06:36 <eek> AIUI?
10:06:42 <maihem> as I understand it
10:06:46 <eek> ah
10:06:56 <eek> Igloo: it implies up front work
10:07:04 <eek> Igloo: rather than a vague idea
10:07:18 <eek> Igloo: VCs like ANY upfront work, anything that means that the process is further along
10:07:51 <maihem> They want to see that you have you heart set on making it a success, and not just taking them for a ride
10:08:41 <eek> and that you're able to deliver SOMETHING
10:10:47 <shapr> From a productivity point of view, nations should have a clear and simple patent process, in order to get even the geekiest to use it.
10:12:06 <maihem> Australia has one, somebody used it to patent the spoked wheel.
10:12:32 <maihem> that is one having five or more spokes.
10:12:44 * Maddas blinks
10:12:58 <shapr> A woman in the UK tried to patent heself a few years back.
10:13:04 <maihem> haha
10:13:15 <Maddas> haha
10:13:44 <maihem> A kid in america patented a method of swinging side to side on a swing whereby you pull alternately on the chains
10:13:46 <Maddas> Haven't parts of animal DNA (can't remember anymore of what) been patented?
10:13:47 <shapr> She figured that if people could patent genetic sequences as part of cloning projects, she could patent her own entire genetic sequence.
10:13:50 <Maddas> haha
10:14:04 <Maddas> maihem: That's almost as silly as... (looking it up)
10:14:10 <Maddas> shapr: Makes sense :)
10:14:36 <Igloo> There was a recent (successful) patent of a dressed-up perpetual motion machine
10:14:44 <Marvin--> shapr: very good point!
10:14:48 <Marvin--> why did it fail?
10:14:56 <Maddas> maihem: http://www.delphion.com/details?pn=US05443036__
10:14:59 <paintcan> there have been patents on infinite compression algorithms
10:15:30 <Maddas> haha
10:16:07 <maihem> If I had a penny for every argument along the lines of "No, you *can't* keep pkzipping until you're down to one byte for each file on your disk."
10:16:12 <Maddas> Igloo: Hasn't that already been done before? :-)
10:17:24 <Igloo> Yes, the amusing bit is that they still haven't learnt...
10:18:23 <jesse99> i'm sure a lossy compressy could infinitely compress data :-)
10:18:32 <CLxyz> LOL
10:19:36 <Marvin--> oh yes
10:19:38 <Marvin--> touch foo
10:19:39 <Marvin--> done
10:25:46 <tromp> half of all possible files can't even be compressed by 2 bits
10:26:30 <desrt> oh god
10:26:33 <desrt> not this again
10:28:18 <tromp> someone patented a circular transportation facilitation device
10:28:29 <tromp> aka wheel :)
10:29:04 <tromp> oops, that was mentioned alrd:(
10:29:52 <desrt> the i-can-compress-any-file falacy is interesting.  it shows you a lot about human nature
10:30:19 <paintcan> it's my favourite flamewar
10:30:26 <desrt> once someone gets an idea in their head and they become convinced that they are right, they will ignore the entire world (and their own common sense) telling them that what they are doing is impossible
10:30:33 <Marvin--> I think it's humorous that it can even turn into a flamewar
10:30:53 <desrt> i had it with someone trying to tell me that pkzip can compress any file
10:31:00 <desrt> i sent him a 1meg chunk of /dev/urandom
10:31:04 <desrt> that shut him up pretty quick
10:31:27 <paintcan> jules on comp.compression is always a source of enjoyable discussion
11:18:13 <dblhelix> anyone played around with GADTs yet?
11:22:46 <Marvin--> no :/
11:23:14 <Marvin--> I'm lazy, so I'm waiting for Igloo to build a new ghc-cvs package :)
11:25:03 <dblhelix> I'll be limited to work on Win32 for the next couple of weeks ... and yes, I'm lazy too, so I don't want to go through too much trouble to get the bits working
11:30:32 <Sam_> desrt: but the pigeonhole rule? and how do you explain the patents?
11:32:15 <maihem> speaking of patents, rochesterdandc.com reports that Kodac has won a patent dispute against Sun over Java bytecode "asking for help" (?) from the Java VM.
11:33:19 <maihem> In other news, multics has been discovered to have kernel from which help can be requested by user applications, Kodak is considering their options.
11:34:10 <paintcan> what
11:34:29 <Marvin--> http://www.groklaw.net/article.php?story=20041003041632172
11:34:52 <paintcan> i hate america
11:35:20 <paintcan> oh god that article must be lies
11:35:52 <Sam_> umm, when are they going to find out that just about *every single system* has some kind of system call interface?
11:36:18 <Marvin--> I think the patents actually cover ORBs more specifically
11:36:31 <paintcan> still pretty dumb
11:36:34 <Marvin--> oh yes
11:36:42 <Marvin--> this is software patents we're talking about, of course it's dumb
11:36:51 <Sam_> okay, so when do they go after GNOME?
11:37:03 <Marvin--> why go after GNOME when they can go after micros~1?
11:37:13 <maihem> Marvin--: like a microkernel?
11:37:29 <Marvin--> maihem: I didn't read the patents
11:37:58 <andersca> Marvin--: problem is that they can't go after microsoft
11:38:20 <Marvin--> why not?
11:38:38 <andersca> because then microsoft says
11:38:50 <andersca> "ok, we have x thousands of patents, surely you (kodak) must be violating a bunch of them"
11:38:59 <andersca> and then kodak says
11:39:02 <andersca> "hmm, ok..."
11:39:16 <Marvin--> actually, I'm kinda surprised SUN couldn't pull that trick
11:40:06 <Marvin--> I think a comment on /. compared the situation with companies with large patent portfolios to the cold war
11:40:15 <Marvin--> which is a pretty good analogy
11:40:16 <Maddas> heh
11:46:53 <mattam> or more recently the ABM treaties that aren't any more respected
11:47:49 <mattam> well, Bush just retired the US from it actually
11:48:14 <Sam_> maybe Sun forgot to try that one?
11:48:46 <mattam> like 'We don't like this patent system, it doesn't fit us so let's just ignore it'
11:49:42 <Marvin--> heh, that's a good one
11:49:44 <SamB_XP> I would say the same thing if I thought it would work.
11:51:30 <mattam> :)
11:56:48 <stepcut> it occured to me yesterday that I have most of the technology needed to shoot super high-res (~3x hdtv) claymation movies...
11:56:59 <mattam> haha, asperti from asperti & longo is in a W3C committee, that's the last thing i would have wondered he could do. http://www.cs.unibo.it/~asperti/
12:11:46 <Maddas> What does ~[foo] syntax do? :-)
12:12:33 <Maddas> (as seen in do { ~[num] <- getArgs ; ... })
12:12:46 <Marvin--> it turns a refutable pattern into an irrefutable pattern
12:12:58 <Maddas> Hm, thanks
12:13:07 <Marvin--> well, it's just the ~ that does that
12:13:14 <Marvin--> [num] is a refutable pattern
12:13:20 <Maddas> Right
12:13:37 <Marvin--> but if you use ~[num] <- getArgs ; ... you won't get the pattern match error until you actually use num
12:14:09 <Maddas> I see
12:14:12 <TheHunter> does that make any difference in that case?
12:15:04 <Marvin--> well, you can use it like   xs@(~[num]) <- getArgs ; when (length xs == 1) $ ...   or something
12:21:13 <Maddas> I understand, thanks :-)
13:03:15 <cm> feels like home
13:03:19 <cm> :o
13:03:53 <Lemmih> #haskell feels like home?
13:05:38 <cm> yeh.. been away from IRC for 3 weeks or stuff :P
13:06:49 <Lemmih> Welcome home then (-:
13:07:14 <cm> :)
13:33:58 <Boegel> hellow everyone
13:37:01 <Jad> @kamra
13:37:01 <lambdabot> Sorry, I don't know the command "kamra", try "lambdabot: @listcommands"
13:38:15 <TheHunter> @karma- lambdabot 
13:38:15 <lambdabot> lambdabot's karma has been decremented.
13:38:18 <TheHunter> @karma lambdabot 
13:38:18 <lambdabot> lambdabot has a karma of -1
13:38:35 <TheHunter> hiya Boegel 
13:38:41 <desrt> @karma- TheHunter
13:38:41 <lambdabot> TheHunter's karma has been decremented.
13:39:36 <TheHunter> @karma desrt 
13:39:37 <lambdabot> desrt has a karma of -18
13:39:38 * TheHunter is being destructive
13:41:07 <Jad> @karma Jad
13:41:08 <lambdabot> You have a karma of 0
13:41:54 <Cale> @karma desrt
13:41:54 <lambdabot> desrt has a karma of 18
13:42:04 <desrt> thanks cale :)
13:42:24 <desrt> btw
13:42:26 <desrt> i think chris is insane
13:42:32 <TheDestroyer> @karma TheHunter
13:42:32 <lambdabot> TheHunter has a karma of -1
13:42:33 <Cale> heh
13:42:35 <Jad> @shapr
13:42:36 <lambdabot> needs sleep
13:42:36 <Cale> how so?
13:42:49 <desrt> ok.  i should say coconut is insane :)
13:42:50 <Jad> @karma lambdabot 
13:42:51 <lambdabot> lambdabot has a karma of -1
13:43:03 <Boegel> @karma Boegel
13:43:05 <lambdabot> You have a karma of 0
13:43:22 <Boegel> what the f*ck is going on with this karma thing ? :)
13:43:23 <viv> ooh.....i heard that desrt........
13:43:29 <Jad> @chess
13:43:30 <lambdabot> Sorry, I don't know the command "chess", try "lambdabot: @listcommands"
13:43:57 <desrt> i've been thinking about what i believe is chris's mental model of the way the cluster will operate
13:44:00 <desrt> and i don't think it's good
13:44:38 <desrt> he sees each machine operating as a filter, and we form a pipeline of operations by chaining the filters together, right?
13:45:09 <TheHunter> @karma TheHunter 
13:45:10 <lambdabot> You have a karma of 38
13:45:13 <desrt> and the reason we have to do this is in order to handle the data that we need to handle in realtime we need to split up the jobs
13:45:52 * TheHunter wonders how old he is...
13:45:55 <desrt> i don't think i need to prove that it would be faster to let each machine do all the tasks on a single piece of data
13:46:06 <desrt> and overlap start times
13:46:43 <desrt> so say the entire thing will run in 0.25 realtime given a single machine
13:46:51 <desrt> get 4 machines
13:46:57 <desrt> send packet 1 to machine 1, 2 to 2, etc
13:47:05 <desrt> and by the time packet 5 comes along, machine 1 will be free again
13:47:18 <desrt> and by the time 6 comes along, 2 will be free again, etc
13:47:48 <desrt> instead of machine 1 processing the 1/4 of the task for each packet, then passing it on to 2, etc
13:48:25 <desrt> the amount of network bandwidth drops.  the amount of latency introduced by shipping data all over the network drops a lot.  the entire thing runs faster.
13:49:07 <Cale> Talk to Chris about it -- perhaps there are some constraints we don't know about
13:49:17 <desrt> yes.  that's what i'm thinking
13:49:42 <desrt> but assuming that what we're doing looks anything at all like 'map' then this will work
13:53:20 <desrt> viv; did you go to installfest?
14:00:54 <viv> dessrt: was it today?
14:01:00 <viv> :-/
14:01:04 <viv> oopz.....
14:01:10 <viv> i totally forgot.......
14:01:20 <viv> i knew there was something going on.....arg.......
14:28:41 <Boegel> does anyone here know a good webpage for looking up formulae ?
14:33:17 <Cale> Boegel: Mathworld, Planetmath, and Wikipedia are all pretty good
14:35:04 <tuomov> now, if there was an actual formula search angine..
14:35:14 <Cale> what are you looking for?
14:35:22 <tuomov> me, nothing
14:35:34 <Cale> Most formulas have names.
14:35:43 <Cale> The important ones anyway
14:35:44 <tuomov> but occasionally it would be nice to be able to enter a formula and find text with similar formulas
14:35:45 <kristnjov> i'm having chestpain
14:35:57 <kristnjov> i'm like 18 and feel like i'm having a heart attack or something
14:36:02 <tuomov> google is quite useless in such a task
14:36:11 <Cale> kristnjov: that's not so good
14:36:17 <kristnjov> Cale, indeed
14:37:31 <cm> (test?)
14:50:57 <thelsdj> how do i define a custom unary - for my type? is there some special way?
14:51:14 <Cale> define negate
14:51:15 <Igloo> Define negate for it
14:51:28 <kristnjov> thelsdj: define negate
14:51:35 <Cale> hehe
14:51:37 <kristnjov> sorry guys, peer pressure again :/
14:51:50 <thelsdj> hrm guess i'm doing something else wrong as i tried that
14:52:18 <Cale> put your code somewhere and we'll have a look
14:54:38 <thelsdj> this is just the beginning of a Set implementation to learn haskell (and learn some set theory) http://www.nomorepasting.com/paste.php?pasteID=21902
14:55:12 <thelsdj> basically all i'm trying to do in my negate is flip the bool 
14:55:30 <Cale> negate is a member of the class Num
14:55:38 <Cale> er, method*
14:55:50 <thelsdj> ok so how would i have a unary - for something that isn't a number?
14:55:57 <Cale> So you'll need to make Set an instance of Num
14:57:30 <Cale> fromInteger will be a problem there
14:57:43 <Cale> as will abs and signum
14:58:19 <Cale> * and + have natural definitions as intersection and symmetric difference though.
14:59:20 <Cale> I suppose that 0 and 1 are definable as the empty set and its complement though
14:59:26 <Cale> so fromInteger isn't so bad
14:59:59 <Cale> (reduce mod 2 and take one of those)
15:00:14 <blue17> Ive got a problem.. im trying to compile this code: http://www.mdstud.chalmers.se/~md9slj/code/Retracts.hs  and I get an error
15:00:23 <Boegel> I'm looking for the formula for "field of view" (fov)
15:01:53 <Cale> 2 arctan ((image size) / 2(focal length)) = (angle of view)
15:02:39 <Cale> where the focal length is in the denominator :)
15:04:17 <Boegel> howdo you know that Cale ?
15:04:26 <Cale> http://en.wikipedia.org/wiki/Angle_of_view
15:04:58 <blue17> Any ideas on my problem?
15:05:06 <Cale> blue17: what error?
15:05:56 <blue17> 8 - Syntax error in e
15:05:56 <blue17> xpression (unexpected `::') 
15:05:56 <Cale> there are a few obvious things in that code which would prevent it from compiling.
15:06:36 <blue17> Its not my code.. I actually dont know Haskell.  Is there a place where I can get some working Haskell code?
15:06:37 <Cale> retracttype equivclass
15:06:42 <Cale> that's not Haskell
15:06:51 <blue17> That wpuld be one problem
15:06:55 <Cale> That's someone's personal extension of Haskell
15:07:00 <blue17> Great
15:07:17 <blue17> Alright, thanks
15:07:19 <Cale> plus the code includes things like  "where  blablabla" so I don't think it's intended to be compiled
15:07:40 <Cale> but that looks like a modified version of part of the standard library
15:07:52 <Cale> In particular, Ratio
15:07:59 <Boegel> hmmz, anyone any idea what they mean with "film dimension" ?
15:08:13 <Cale> Boegel: they mean the size of the film
15:08:18 <Boegel> I interpret that as 640x480 (for example)
15:08:29 <Boegel> but you can't put that in a formula like that, can you :
15:08:30 <Boegel> :)
15:08:35 <Cale> you could
15:08:45 <Cale> you'd be measuring distances in pixels then :)
15:09:22 <Boegel> yeah, but still
15:09:35 <Boegel> you'll have an x part, and an y part
15:09:40 <Boegel> or heigth and width...
15:11:30 <Cale> blue17: you're looking for *any* working Haskell code?
15:11:30 <TheHunter> blue17: this stuff has been discussed before (don't know if this helps): http://tunes.org/~nef/logs/haskell/04.01.22
15:12:52 <Cale> Boegel: that assumes that you're doing the measurement along one dimension
15:14:04 <Boegel> oh, ok :)
15:14:14 <Boegel> then, you can actually have 2 fov's ? :)
15:14:38 <Cale> I suppose you might, with strange lenses
15:16:17 <Boegel> it's for my ray casting prog...
15:16:27 <Boegel> they prolly use the same fov then for x and y...
15:16:55 <Cale> should be easy enough to experiment :)
15:17:04 <Boegel> prolly :)
15:17:12 <Boegel> thanks for the help
15:17:17 <Boegel> wikipedia is bookmarked :)
15:32:57 <TheHunter> good night, #haskell
15:36:18 <Boegel> good night from me too, #haskell
17:22:45 <SyntaxLaptop> darcs 1.0.0rc3 is at haskell-unsafe
17:54:53 <netd> hello
17:55:53 <netd> does anyone know if there is any way to evaluate a non-io function in a io-function and disregard the results?
17:59:56 <dons> () <- Control.Exception.evaluate f
18:00:15 <dons> actually, just: Control.Exception.evaluate f
18:02:05 <netd> ooh
18:02:09 <netd> thank you very very much
18:05:13 <dons> sometimes 'return' might be enough
18:05:46 <netd> ok
18:06:06 <netd> evaluate is fine though, because what i'm trying to do is meassure the cpu time it takes to evaluate a function
18:06:14 <dons> cool
18:06:34 <dons> you could possibly use GHC's inbuilt profiling for this?
18:07:16 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
18:10:21 <netd> thank you very much :)
18:10:50 <dons> :)
18:59:57 <desrt> is there something that i can wrap undefined in so it doesn't kill me?
19:00:24 <desrt> like maybe catchUndef :: a -> Maybe a
19:00:32 <desrt> catchUndef undefined = Nothing
19:00:37 <desrt> catchUndef a = Just a
19:01:12 <Pseudonym> You can catch it like a normal exception in the IO monad, I believe.
19:01:55 <desrt> no way to catch it inside a chunk of code?
19:02:25 <Pseudonym> IO is code.
19:02:32 <desrt> heh
19:02:44 <desrt> s/code/code that is not IO monad/
19:02:52 <Pseudonym> No.  That would be unsound.
19:03:03 <Pseudonym> Or violate referential transparency.
19:03:04 <Pseudonym> Or something.
19:03:32 <desrt> it would just require (a) undefined not throw a trap, but rather be a value
19:03:42 <desrt> (b) any function that takes undefined strictly propogates it as a result
19:04:05 <Cale> Which would add another value to every type.
19:04:10 <Pseudonym> No, the problem is that thanks to lazy evaluation, the ancestor may have disappeared by the time undefined is evaluated.
19:04:24 <Pseudonym> It's the same reason why Haskell doesn't have first-class continuations.
19:05:02 <desrt> Pseudonym; right.  but if the code is being executed then you know that the ancestor must have been strict in the argument that was passed as undefined
19:05:16 <desrt> ie: the ancestor's proper return value is now 'undefined'
19:05:24 <Pseudonym> Nope.
19:05:26 <desrt> (under this new crazy scheme) :)
19:05:52 <Pseudonym> To see why, let's actually try to implement this.
19:05:56 <Pseudonym> Abstractly.
19:06:01 <Pseudonym> catchUndefined :: a -> Maybe a
19:06:02 <Pseudonym> OK?
19:06:10 <desrt> yup.  i'm good with that
19:06:43 <Pseudonym> Hang on a sec, getting this straight in my head.
19:06:46 <Pseudonym> OK, got it.
19:06:50 <Pseudonym> Suppose we do this:
19:06:50 <dons> undefined is just error "Prelude.undefined"
19:07:13 <Pseudonym> catchUndefined (error "foo", error "bar")
19:07:30 <Pseudonym> catchUndefined is indeed strict in its argument.  The tuple will be constructed.
19:07:43 <Pseudonym> Sorry: catchUndefined (undefined, undefined)
19:07:59 <Pseudonym> However, if either element gets evaluated, the catchUndefined ancestor will be gone.
19:08:02 <Pseudonym> Got it?
19:08:19 <desrt> not really, but continue
19:08:31 <desrt> (You mean the (,) will be gone?)
19:08:34 <Pseudonym> No.
19:08:38 <Pseudonym> What should this return?
19:08:45 <desrt> Nothing
19:09:00 <Pseudonym> fst (catchUndefined (undefined, 2))
19:09:04 <Pseudonym> What should that return?
19:09:18 <desrt> you can't apply fst to a Maybe
19:09:27 <Pseudonym> Ah, true.
19:09:28 <Pseudonym> Hmmm.
19:09:36 <Pseudonym> OK, let's define it like this instead:
19:09:42 <Pseudonym> catchUndefined :: a -> a -> a
19:09:58 <Pseudonym> where catchUndefined x y returns x, or y if you hit an undefined.
19:10:14 <desrt> acceptable.
19:10:18 <Pseudonym> fst (catchUndefined (undefined,1) (2,1))
19:10:22 <Pseudonym> What should that return?
19:10:38 <desrt> 2
19:10:52 <Pseudonym> So you're saying that catchUndefined should actually do a deepSeq on its first argument?
19:11:16 <Pseudonym> What if it's infinite?
19:11:20 <desrt> is deepSeq a way to force eager eval?
19:11:47 <desrt> no.  that's definitely not what i am saying
19:11:49 <Pseudonym> Yes, though I don't think GHC defines is on all types currently.
19:12:01 <desrt> but i'm starting to see where you are going
19:12:07 <Pseudonym> Right.
19:12:17 <desrt> a better question would be:
19:12:25 <desrt> snd (catchUndefined (undefined,2) (3,4))
19:12:33 <Pseudonym> Indeed.
19:12:46 <desrt> i'd say 2
19:12:51 <desrt> but... that might not be right
19:12:59 <desrt> ya.  you'd totally violate referential transparancy
19:13:03 <Pseudonym> Right.
19:13:09 <Pseudonym> So catch it in IO.
19:13:11 <desrt> because the return value of the function would depend on if you called it from fst or snd
19:13:29 <desrt> interesting :)
19:13:46 <desrt> thanks for the example
19:13:53 <Pseudonym> Now you could probably write a safe catchUndefined which worked if its argument was undefined.
19:13:58 <Pseudonym> Rather than its children being undefined.
19:14:23 <Pseudonym> But I think that would be of limited use.
19:14:27 <desrt> and boring
19:14:29 <Pseudonym> And you might as well just use Maybe in that case.
19:14:35 <desrt> if you're going to say checkUndef 0/0
19:14:43 <desrt> you may as well just check to make sure you're not dividing by 0 first
19:14:46 <Pseudonym> Right.
19:14:59 <Pseudonym> You'll get better diagnostics, too.
19:19:36 <Pseudonym> Lazy evaluation interacts badly with a lot of things, unfortunately.
19:25:31 <Pseudonym> The more I work with it, the more I'm convinced that turning lazy evaluation on all the time might not have been a good idea.
19:25:45 <dons> well, there's always ML..
19:25:58 <dons> ;)
19:27:38 <dons> Bob Harper: "the appearence of freedom [in lazy languages] is really a bondage" hehe
19:28:27 <Pseudonym> Lazy evaluation is great when it's what you want.
19:28:39 <Pseudonym> The problem with ML is its archaic syntax.
19:28:48 <Pseudonym> And, of course, it's still impure.
19:28:51 <dons> yep.
19:28:57 <Pseudonym> Clean is probably something more like what I want.
19:29:10 <dons> or Strict LML
19:29:16 <dons> just to be peverse
19:30:51 <Pseudonym> Clean is pure, which helps a lot.
19:31:39 <dons> good hygiene
19:37:17 <stepcut> Pseudonym: if anything, clean seems lazier than haskell to me
19:37:58 <Pseudonym> Clean has some benefits.  The unique types, for example, let you control the amount of allocation done if you're clever.
19:38:03 <Pseudonym> Hmmm.
19:38:14 <Pseudonym> I guess I want a language where you can say "I want laziness _here_".
19:38:22 <Pseudonym> It'd probably have to be part of the type system.
19:44:57 <stepcut> I wonder if (1) epigram is lazy (2) if so, do you see less issues 'do to laziness'
19:45:20 <stepcut> Everytime I use clean, my programs have heap or stack overflows
19:49:36 <tuomov> I don't see the problem with the catchUndefined example above..
19:49:44 <tuomov> (undefined, 2) is of course also undefined
19:50:33 <Pseudonym> tuomov: fst (catchUndefined (undefined,2) (3,4))
19:50:36 <Pseudonym> What should that return?
19:50:43 <tuomov> 3
19:50:56 <tuomov> the parameter to catchUndefined is always undefined
19:50:59 <Pseudonym> All right then.  What should this return?
19:51:17 <Pseudonym> tuomov: fst (catchUndefined (1,undefined) (3,4))
19:51:22 <tuomov> 3
19:51:29 <tuomov> (1, undefined) = undefined
19:51:31 <Pseudonym> Why?
19:51:53 <stepcut> Prelude> fst (1,undefined)
19:51:53 <stepcut> 1
19:51:53 <stepcut> Prelude> 
19:52:13 <tuomov> well, then the semantics of that are b0rken
19:52:25 <stepcut> Prelude> fst (1,undefined)
19:52:25 <stepcut> 1
19:52:25 <stepcut> Prelude> 
19:52:27 <stepcut> oops
19:52:27 <Pseudonym> No, the semantics of catchUndefined are b0rken.
19:52:45 <Cale> (,) is not strict in its arguments
19:52:45 <Pseudonym> Haskell is doing precisely what it advertises that it does.
19:52:50 <stepcut> Prelude> let u = (undefined, 2) in let (_,n) = u in (n + 1)
19:52:50 <stepcut> 3
19:54:46 <tuomov> but isn't there a way to force strict evaluation?
19:55:25 <tuomov> $! doesn't seem to work in this case
19:55:48 <stepcut> haha, i tried f (1,[1..]), but it didn't give me back a command prompt, so I thought it was trying to evalute the infinite list [1..]... but then I realized I was in the *scratch* buffer in emacs where I had copied some stuff from *ghci*
19:56:53 <stepcut> I bet you could write some with generics that forced strict evaluation...
19:57:09 <stepcut> what should happen in this case:
19:57:15 <stepcut> fst (1,[1..])
19:58:01 <tuomov> 1, of course
19:58:46 <tuomov> but such a catch function should force evaluation, as it needs the parameter in full
19:59:26 <stepcut> but [1..] is an infinate list, you will never finish evaluating it...
20:00:05 <tuomov> yes, but how does catchUndefined trying to evaluate such break anything?
20:02:48 <tuomov> you still always get the same answer, if you get it
20:02:51 <stepcut> well, 'fst (catchUndefined (1,[1..]) (3,4))', will return 1, which is a correct answer, but if it tried to evaluate [1..], it would never finish, which is the wrong answer
20:03:07 <tuomov> no, it wouldn't return it
20:03:33 <stepcut> exactly
20:03:40 <tuomov> catchUndefined would check that the whole argument is meaningful
20:03:57 <tuomov> you couldn't pass infinite data structures through it
20:04:32 <stepcut> even if the infinite data structure is meaningful? That seems like a bug...
20:04:34 <tuomov> well, at least not unless if it could somehow be proven that the whole structure can be calculated..
20:04:43 <tuomov> no, a feature
20:05:19 <stepcut> perhaps
20:05:41 <tuomov> anyhow, the point is, you can have catchUndefined with such semantics that the whole parameter must evaluate to a proper value
20:06:18 <tuomov> and it is no different from lifting everything to Maybes..
20:06:41 <stepcut> (except that it might not ever finish)
20:06:47 <tuomov> (except that)
20:07:55 <stepcut> of course, getting rid of undefined would also fix the problem :)
20:08:47 <tuomov> and besides, you could unsafePerformIO ...
20:09:06 <tuomov> now, I can't tell if it is safe to do so..
20:09:12 <tuomov> too n00b
20:09:44 <tuomov> and it is ugly in any case
20:15:05 <tuomov> this causes an exception: data Foo a b = Foo !a !b; from_foo (Foo a b) = a; from_foo (Foo a b) = a; main = do putStr $ show $ from_foo $ Foo 1 undefined
20:15:27 <tuomov> tuples are somehow special
20:17:23 <tuomov> can't make the whole tuple fail no matter what I try, unless it is passed through another data type
20:29:50 <tuomov> oh, well, apparently there's no way to force the evaluation of a lazy data structure, while you can make new strict ones
20:30:57 <stepcut> tuomov: maybe using generics ?
20:31:34 <tuomov> But they're like that Foo hack?
20:32:06 <tuomov> (but even there, if 'a' is not primitive, it may contain undefined components)
20:32:27 <tuomov> (or 'b', or whatever)
20:32:47 * stepcut goes to sleep
20:32:53 <tuomov> I should too
21:04:55 <desrt> @shapr
21:04:56 <lambdabot> needs sleep
21:12:25 <musasabi> morning
21:54:20 <musasabi> GADTs look yummy
21:54:48 <dons> mmm :P tasty
22:22:11 <musasabi> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/testsuite/tests/ghc-regress/gadt/tc.hs?rev=1.1 looks very promising.
22:25:18 <dons> huh. that's very nice
23:04:11 <Maddas> phubuh: ping
23:37:31 * shapr awakens
23:37:35 <shapr> @shapr
23:37:35 <lambdabot> needs sleep
23:38:37 <Lemmih_> Hey shapr 
23:38:50 <Pseudonym> G'day.
23:38:52 * Lemmih_ is playing around with GADTs.
23:38:59 <Pseudonym> @arr
23:39:00 <lambdabot> Prelude.(!!): index too large
23:39:03 <Pseudonym> Oooh.
23:39:27 <Lemmih_> Is that a bug or some weird joke?
23:39:40 <Pseudonym> It's the lesser known pirate saying.
23:39:45 <Pseudonym> index be too large, matey.
23:39:54 <Lemmih_> heh (-:
23:40:06 <Pseudonym> @arr
23:40:07 <lambdabot> Arrr!
23:40:12 <Pseudonym> There she be again!
23:40:28 * Lemmih_ is off for school.
23:49:39 <vegai> I'm considering using darcs for a project with windows developers
23:49:48 <vegai> is there a usable GUI frontend to it?
23:50:29 <shapr> hiya Lemmih 
23:50:34 <shapr> g'day Pseudonym 
23:50:40 <vegai> howdy shapr
23:50:53 <shapr> hyvää huomenta vegai 
23:51:06 <vegai> unicode attack!
23:51:11 <shapr> heh
23:51:18 <shapr> there's not a darcs GUI yet
23:51:44 <shapr> but if you start one, I want to contribute :)
23:54:42 <vegai> GUIs and Haskell is not a combination I'm very familiar with
23:55:06 <vegai> it'll probably be much easier to persuade the people to use CLI =)
23:55:07 <shapr> I've been looking at wxHaskell lately, it looks nice.
23:55:14 <shapr> there are wxHaskell debs as well
23:55:25 <shapr> in haskell-unsafe
23:55:39 <vegai> I've been programming GUIs with RAD tools lately, so it might be quite hard to settle for something more basic
23:55:54 <vegai> though a RAD tool using wxHaskell might be interesting to write
23:56:21 <vegai> perhaps one should do it with something more native, though
23:56:23 <shapr> I've heard there's a minimal wxHaskell gui for darcs, but I've never tried it.
23:56:43 <shapr> I seriously doubt it's up to the quality of the various cvs guis
23:57:04 <vegai> aye
23:57:48 <vegai> I've found that the most sophisticated programmers seem to shun RAD tools. Any idea why that is?
23:57:52 <shapr> David says he would work on the wxHaskell darcs gui as soon as there are wxHaskell debs
23:58:06 <shapr> sure, because RAD tools take away a bunch of control.
23:58:25 <bbls> shapr that's not entirely true
23:58:34 <shapr> it's been true in all the cases I've tried.
23:58:38 <bbls> there is no inherent disadvantage of RAD tools
23:58:39 <vegai> well, using Haskell instead of C takes away a bunch of control too ;)
23:58:44 <bbls> RAD is just the interface builder
23:59:21 <shapr> yup, I'm talking about the Visual Basic and various Java tools I've used for that purpose.
23:59:59 <bbls> shapr there is an inherent limitation of VB not RAD :)
