02:31:04 <boegel> hello everyone :)
02:31:16 <boegel> I need a hint for a _good_ irc client on linux
02:31:21 <Mike122> hello boegel 
02:31:26 <Mike122> try xchat 
02:31:28 <boegel> I'm using XChat now, but I don't really like it
02:31:38 <boegel> heh :o)
02:31:44 <Mike122> ok use bitchx
02:31:54 <Mike122> or erc in emacs 
02:32:03 <musasabi> irssi is quite nice.
02:32:21 <Mike122> or the most popular irssi ... 
02:32:22 <boegel> I don't like XCHat because it's so dark (default)
02:32:39 <Mike122> most linux users use irssi
02:32:56 <Mike122> even irssi is black 
02:32:59 <Mike122> command line 
02:33:31 <boegel> hmmz, I want some colors and stuff
02:33:42 <polli> boegel: find a good theme then? :)
02:33:43 <boegel> but I can probably change XChat, right ?
02:34:16 <polli> boegel: yes
02:34:33 <polli> most clients supports themes
02:35:04 <boegel> I can hand-change the colors in XChat...
02:36:54 <Mike122> boegel make xchat transparent 
02:37:09 <Mike122> so ur desktop is ur background
02:37:15 <boegel> ow nice ;)
02:37:30 <boegel> now I should really change my background :o)
02:37:39 <Mike122> haha
02:44:03 <boegel> I don't like the transparent feature, because my background is too flashy :)
02:44:14 <boegel> anyway, I'm going for a snack now
02:44:15 <boegel> bye !
02:46:03 <tuomov> irssi has even too many colours by default
02:46:21 <tuomov> I had to do a lot of work to get rid of the colours while still retaining bolding
02:55:24 <earthy> export TERM=vt100; irssi
02:55:29 <earthy> colors? *what* colors? :)
02:58:06 <tuomov> it is easy to get rid of all attributes, but not just of colours while retaining enough bold usage
03:00:45 <tuomov> I still don't get my nick bolded on this computer, within screen
03:01:23 <tuomov> elsewhere, I had to hack some stylefile to use different attributes for the nick for that to work
03:01:43 <tuomov> although it is bolded with colours in the default style
03:09:34 <dons> tuomov: simple 2d buffer for navigating text based on your plan: http://www/~dons/hemacs/HEmacs/Buffer.hs
03:09:41 <dons> www.cse.unsw.edu.au
03:11:05 <dons> and i do like the idea of generating the char decorations on the way to rendering
03:13:04 <tromp_> @info tails
03:13:20 <tromp_> @index tails
03:13:21 <lambdabot> Data.List,List
03:20:19 <dons> -prof is really useful
04:01:53 <tromp_> @info foldl
04:01:55 <lambdabot> -- foldl is a variable
04:01:55 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
04:16:54 <shapr> @yow !
04:16:55 <lambdabot> How's it going in those MODULAR LOVE UNITS??
04:17:42 <shapr> whoa cool, I got a memo.
04:18:34 <musasabi> morning
04:18:34 <shapr> salut ned
04:18:37 <shapr> hei musasabi 
04:18:45 <boegel> hello shapr
04:18:57 <shapr> hoi boegel, what happened to your capital B?
04:19:09 <boegel> I'm using a different client
04:19:12 <shapr> andyfaeglasgow_: are you really irc'ing as root?
04:19:15 <boegel> you're right, I should change it...
04:19:24 <andyfaeglasgow_> right ok
04:19:48 <shapr> just curious...
04:20:14 <Boegel> shapr: better ?
04:20:16 <Boegel> :p
04:20:19 <shapr> Boegel: yay!
04:20:37 <musasabi> Boegel: you could just do /nick Boegel
04:21:16 <Boegel> I know, but then I wouldn't know for sure I changed it correctly in the IRC client
04:21:20 <Boegel> I'm using linux btw :p
04:21:24 <Boegel> Mandrake 9.1
04:21:26 <shapr> w00!
04:21:30 * shapr cheers for Boegel 
04:21:52 <Boegel> but the highlight thingie doesn't seem to work
04:22:02 <shapr> Boegel: this is a highlight test
04:22:07 <Boegel> I set it to highlight text in red when my nick appears in it
04:22:11 <shapr> hm
04:22:12 <Boegel> it doesn't work :)
04:22:18 <shapr> that sucks
04:22:20 <Boegel> (I'm using XChat)
04:22:22 <Boegel> idd
04:24:00 <Boegel> shapr: throw in a tes again pls :)
04:24:12 <shapr> Boegel: hello dere bubby... WAZZUP?
04:24:48 <Boegel> doesn't work :(
04:25:31 <Boegel> what am I doing wrong :s
04:27:07 <Boegel> shapr: how do I make a window 'sticky' ?
04:27:17 <Boegel> I always found that pretty nice to work with
04:30:03 <Boegel> hello raver
04:32:00 <shapr> you can probably right-click on the titlebar, and choose 'sticky'
04:32:07 <shapr> but it depends on your window manager
04:32:44 <Boegel> I'm using gnome
04:32:59 <Boegel> no sticky in the right click menu...
04:33:12 <Boegel> okay, next step in the process: installing hugs and ghc !
04:33:13 <Boegel> :)
04:33:45 <Boegel> hello swiert
04:33:56 <swiert> hi
04:34:06 <Boegel> (is he new ? =p)
04:34:20 <swiert> no - but I changed my nick.
04:34:28 <swiert> it used to be just "wouter"
04:35:39 <shapr> nah, that's Mijneer Wouter Swierstra :-)
04:35:55 * shapr checks to see if he has the pic with the new glasses up...
04:36:07 <Boegel> shapr: it's Mijnheer
04:36:08 <Boegel> :p
04:36:19 <shapr> dang
04:36:24 <swiert> no, it's just wouter
04:36:26 <earthy> or Meneer'
04:36:33 <swiert> you can leave out the meneer
04:36:38 <shapr> heh ok
04:36:42 <Boegel> this is funny :)
04:36:49 <earthy> can we? rilly?
04:37:02 <Boegel> *yaay*
04:37:04 <shapr> Doesn't it mean the same as 'mister' in american/british?
04:37:19 <earthy> that'd be `Meneer'
04:37:24 <Boegel> shapr: yes
04:37:39 <Boegel> earthy: Mijnheer is the same, maybe a bit more polite
04:37:41 <earthy> Mijnheer is more formal
04:37:46 <shapr> swiert: Hey, what's your MSc thesis on? Can I get a copy of your Bachelor's thesis?
04:37:56 <earthy> does he have a bachelor's thesis?
04:38:28 <swiert> my BSc thesis is about checking proofs by only using a type checker for dependent types
04:38:33 <shapr> I think so --> http://swierstra.tk/
04:39:07 <swiert> my MSc thesis is on embedding an attribute grammar system in a Haskell compiler.
04:39:12 <earthy> ah... new-style student then. ;)
04:39:14 <shapr> oh, neat
04:39:25 * earthy sees a combination of the 2 coming up
04:39:46 <shapr> hiya andyfaeglasgow!
04:39:52 <andyfaeglasgow> hi
04:39:56 <earthy> owh, that's weird.
04:40:01 <earthy> you're formally brasilian as well. :)
04:40:03 <shapr> andyfaeglasgow: are you looking for Haskell info? or maybe a long time user?
04:40:03 <swiert> earthy: as in attribute grammars and haskell compilers.
04:40:22 <andyfaeglasgow> just hanging around
04:40:25 <earthy> swiert: as in proof checkers, attribute grammars and haskell compilers :)
04:40:29 <Boegel> andyfaeglasgow: shapr would be happy to give you a your ! :o)
04:40:49 <shapr> or even a tour
04:40:50 <swiert> earthy: well, I could have chosen for a Brazilian passport when I was 18 - but would have to run the risk of having to serve in the Brazilian army.
04:41:06 <earthy> not really
04:41:14 <andyfaeglasgow> when i came in how did you guys immediately know I was logged in as root?
04:41:28 <shapr> andyfaeglasgow: it shows up in your user@hostname info
04:41:33 <shapr> *** andyfaeglasgow_ is sirc user (~root@cpc2-broo2-3-0-cust184.renf.cable.ntl.com)
04:41:36 * Boegel curses his keyboard
04:41:40 <shapr> but now you have *** andyfaeglasgow is sirc user (~andy@cpc2-broo2-3-0-cust184.renf.cable.ntl.com)
04:41:41 <earthy> 1. you can still apply for a brazilian passport as far as I know, but doing it now would mean losing your dutch nationality
04:42:04 <shapr> irc'ing as root is dangerous, since most irc clients have scripting capabilities.
04:42:11 <earthy> 2. the `serving in the brazilian army' consists of getting a stamp every year from your 18th until your 45th while you're not in brasil
04:42:23 <andyfaeglasgow> i c
04:42:52 <swiert> but running the risk of being drafted when I'm in Brazil (right?)
04:43:14 <Boegel> does anybody here know VMWare ?
04:43:46 <earthy> nope.
04:44:15 <swiert> hmm, I'm happy with my Dutch passport.
04:44:24 <swiert> it makes travelling in the EU a lot easier.
04:44:26 <earthy> there's no incentive for them to draft you
04:44:58 <earthy> and even if they do, you can argue that they should shunt you into their space program or some such for a while ;)
04:45:15 <shapr> imperialist dutch! trying to colonize outer space too!
04:45:33 <shapr> of course, I'd pay to get in on that...
04:45:42 <earthy> it's a darn pity we didn't manage to get my `get out of the draft free-card' back in 1993 though
04:46:07 <shapr> andyfaeglasgow: so, are you learning Haskell?
04:46:16 <andyfaeglasgow> no
04:46:26 <shapr> andyfaeglasgow: oh, you already know Haskell?
04:46:28 <earthy> (there are rules that state that if you are more valuable to brazil if they don't draft you, you get to stay out of the army for the rest of your life)
04:46:45 <andyfaeglasgow> no don't know it already
04:46:54 <andyfaeglasgow> but may learn in future
04:47:10 <shapr> I think Haskell is worth learning, but that's probably obvious.
04:47:34 <andyfaeglasgow> I knew someone at uni last year who raved about it
04:47:39 <Boegel> shapr: I have a problem: I can't register my nickname anymore with Nickserv
04:47:39 <shapr> Are you in a CS program in school? or just learning programming languages for fun?
04:47:43 <shapr> Boegel: why not?
04:47:49 <Boegel> shapr: I forgot my password :s
04:47:58 <andyfaeglasgow> just finished one
04:48:02 <Boegel> shapr: is there anyway to solve that?
04:48:10 <shapr> Boegel: you can ask the admins on #freenode
04:48:19 <shapr> other than that, I don't know.
04:48:54 <shapr> andyfaeglasgow: I can give you the short tour of the #haskell irc channel, and the handy Haskell learning resources if you want.
04:48:57 <earthy> which reminds me that I should get some more stamps... :)
04:49:05 <andyfaeglasgow> that would be cool
04:49:10 <shapr> ok!
04:49:59 <shapr> First off there's the logs of all the channel conversations, in raw format here: http://tunes.org/~nef/logs/haskell/ and pretty colors at http://tunes.org/~coreyr/
04:49:59 <Boegel> shapr: what does this mean: the channel demigos have stolen your voice
04:50:00 <Boegel> :s
04:50:22 <shapr> Boegel: it means they're used to people showing up and whining, so by default people can't speak on that channel
04:50:34 <shapr> once you've been there for awhile, you'll get voice
04:50:49 <Boegel> so I just have to wait ?
04:50:55 <shapr> but usually it's best to do a /whois to find the admins, and check each one to see who's not idle, then /msg that one with your question
04:51:15 <shapr> andyfaeglasgow: next we have the Haskell Wiki, at http://www.haskell.org/hawiki/ it has lots of great content.
04:51:32 <shapr> and last there's lambdabot, the useful irc bot written in Haskell.
04:51:48 <shapr> lambdabot has some useful functions like @type, @index, and @info
04:51:56 <andyfaeglasgow> take it that's what you're using?
04:52:01 <shapr> @type (1 + 1)
04:52:02 <lambdabot> (1 + 1) :: forall a. (Num a) => a
04:52:08 <shapr> @index anyChar
04:52:08 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
04:52:12 <shapr> @info Eq
04:52:13 <lambdabot> -- Eq is a class
04:52:13 <lambdabot> class Eq a where {
04:52:13 <lambdabot>     (/=) :: a -> a -> Bool {- has default method -};
04:52:13 <lambdabot>     (==) :: a -> a -> Bool {- has default method -};
04:52:13 <lambdabot>     }
04:52:20 <Boegel> shapr: how do I know a user is an admin by using /whois ?
04:52:34 <shapr> Boegel: do you see the topic of #freenode?
04:52:44 <shapr> it shows you how you can give a wildcard mask with /whois to find admins.
04:52:54 <shapr> andyfaeglasgow: using for what?
04:53:05 <shapr> I use the wiki, lambdabot, and the logs.
04:53:12 <andyfaeglasgow> as an irc client
04:53:23 <shapr> Oh, I use emacs as my irc client.
04:54:01 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid (i386-debian-linux, GTK+ Version whatever, built 2004-08-28)!
04:54:38 <shapr> there is an irc client based on lambdabot, but I haven't used it.
04:54:55 <andyfaeglasgow> can't talk to you you anymore cos i use vi ;-)
04:54:59 <shapr> haha
04:55:32 <shapr> I want to get out of emacs anyway... I want something better.
04:55:46 <shapr> Happily, there is a project to write an editor in Haskell.
04:55:49 <earthy> something better than emacs
04:56:10 <earthy> owh, that should be interesting... an emacs style editing system but with haskell instead of lisp...
04:56:30 <shapr> darcs get http://www.cse.unsw.edu.au/~dons/hemacs
04:56:38 <andyfaeglasgow> i thought haskell was for crunching through maths type problems
04:56:57 <shapr> It depends on the problem really.
04:57:11 <shapr> In my opinion, Haskell is really good at abstracting away the boring bits.
04:57:26 <Boegel> shapr: if I want to install hugs on linux, which package should I download ? the generic linux one ?
04:57:27 <shapr> I can quickly write a program in Haskell that works.
04:57:41 <shapr> Boegel: there's probably a mandrake package.
04:57:50 <shapr> maybe?
04:58:07 <Boegel> I only see a Red Hat and Debian package...
04:58:54 <shapr> andyfaeglasgow: lambdabot is written in Haskell, irc client based on lambdabot in Haskell, wxHaskell is bindings to wxWidgets, formerly wxWindows, HaskellDB is a sexy database binding (works with postgresql, mysql, sqlite, odbc, and some other stuff)
04:59:08 <Boegel> *yaay*, I'm registred
04:59:28 <Boegel> nice people on #freenode
04:59:33 <shapr> Haskell really does have a bunch of deep and fun theory behind it, but you don't have to use that just for crunching math.
04:59:40 <shapr> yah, the freenode admins are really nice
05:00:41 <shapr> andyfaeglasgow: would you like to see the really short Haskell demo for the impatient and easily distracted?
05:01:22 <andyfaeglasgow> yes
05:01:22 * shapr occasionally sends money to freenode
05:01:30 <Boegel> now, what can I do when I'm registred ? :p
05:01:41 <shapr> andyfaeglasgow: see what you think: http://www.haskell.org/hawiki/HaskellDemo
05:01:53 <shapr> Boegel: /msg nickserv help for the basics
05:03:04 <shapr> andyfaeglasgow: have you used a somewhat functional language before? maybe scheme, lisp, ML, OCaml?
05:03:21 <andyfaeglasgow> no
05:03:37 <andyfaeglasgow> typical languages that they teach in uni these days
05:03:41 <andyfaeglasgow> java
05:04:10 <Boegel> I wonder why they don't teach more C/C++ in university's
05:04:11 <andyfaeglasgow> also php and i've done some scripting since i got my linux box
05:04:16 * desrt eyes shapr
05:04:17 <Boegel> I got a lot of java too
05:04:22 * shapr tongues desrt 
05:04:26 <desrt> heh.
05:04:30 <desrt> why do you send money to freenode?
05:05:13 <shapr> desrt: I've been using freenode for years without cost, and they spend time admin'ing the network and keeping spammers, clonebots, ircwarriors, etc off the network
05:05:34 <desrt> d00d
05:05:41 <desrt> i'm an ircwarrior and they haven't kept me off
05:05:58 <andyfaeglasgow> hehe
05:06:02 <shapr> I hope you're not an ircwarrior.
05:06:12 <shapr> you seemed so nice before this...
05:06:12 <desrt> shit.  i used to be l33t
05:06:29 <shapr> yah, but l33t / ircwarrior is destructive.
05:06:33 <desrt> shapr; i'm a defensive ircwarrior
05:06:40 <shapr> I used to be destructive too.. but it sucks.
05:06:48 <desrt> don't try to steal my channel if you value your ISP account
05:06:50 <desrt> etc
05:07:17 <shapr> I assume that most of the smart people on #haskell know how to do that sort of stuff, but choose not to.
05:07:33 <Boegel> shapr: I'm trying to install hugs, but I says I need another package 'libreadline.so.4', and that doesn't seem to come with Mandrake... how can I solve this ?
05:07:57 <desrt> Boegel; you probably already have it...
05:08:00 <shapr> Boegel: there's a package manager for mandrake, and you can search the package name
05:08:04 <desrt> bash depends on it and you probably already have that :)
05:08:05 <shapr> look for 'readline'
05:08:33 <tuomov> ls /usr/lib/libreadline.*
05:08:34 <shapr> Boegel: alternatively, if you upgrade to mandrake 10, I can look at my fiancee's mandrake boxen when checking out problems you're having.
05:08:43 <desrt> tuomov; or /lib/ even
05:08:52 <shapr> whoops, bye andy...
05:09:27 <shapr> well, I hope he comes back for the rest of the intro.
05:09:43 * shapr sl√•r polli med en forell!
05:09:53 <desrt> 0205279746b4dcc501050d66f6f87f9b  ghc-6.2.2-powerpc-unknown-linux.tar.bz2
05:09:58 <Boegel> shapr: you have a fiancee ? you have a girlfriend ! you're not a real coder ! :o
05:10:16 <shapr> Boegel: my girlfriend is sick of hearing about monads and arrows, I really am a coder.
05:10:38 <Boegel> shapr: hehe
05:10:49 <shapr> She's my boss too.
05:10:58 <shapr> I get to sleep with the boss! w00!
05:11:09 <Boegel> shapr: every girlfriend is the boss of her boyfriend
05:11:15 <raboof> lol
05:11:24 <shapr> We have a company together, webwitches.com
05:11:31 <tuomov> the "government" they say here
05:11:51 <shapr> I'm the CTO, she's the CEO.
05:12:20 <shapr> I keep trying to claim our five cats as employees for tax deductible purposes, but no one believes me.
05:13:05 <desrt> uhh
05:13:14 <desrt> you have to pay them wages (food)
05:13:19 <desrt> and probably health benifits and such too
05:13:25 <shapr> right, good point!
05:13:45 <shapr> problem is, they don't actually do anything. They're purely decorative.
05:13:56 <shapr> Admittedly, many exployees are like that too...
05:14:45 <desrt> and some are even anti-decorative
05:15:22 <shapr> true
05:15:47 <Boegel> ls: /usr/lib/readline: No such file or directory
05:16:05 <shapr> did you add the star at the end?
05:16:13 <desrt> Boegel; and the lib between the / and readline
05:16:20 <shapr> or maybe ls /usr/lib/*readline* 
05:16:28 <Boegel> [root@localhost lib]# ls /usr/lib/*readline*
05:16:28 <Boegel> /usr/lib/libguilereadline.a      /usr/lib/libguilereadline.so.0.0.1*
05:16:28 <Boegel> /usr/lib/libguilereadline.la*    /usr/lib/libguilereadline-v-12.so.12@
05:16:28 <Boegel> /usr/lib/libguilereadline.so@    /usr/lib/libguilereadline-v-12.so.12.3.0*
05:16:28 <Boegel> /usr/lib/libguilereadline.so.0@
05:16:37 <Boegel> so I have it
05:16:38 <desrt> readline is in /lib/ on my system
05:16:48 <Boegel> but why doesn't the installer find it then ?
05:16:57 <shapr> nah, guile is a gnu scripting language based on scheme
05:17:07 <Boegel> desrt: you're right
05:17:08 <Boegel> [root@localhost lib]# ls /lib/*readline*
05:17:08 <Boegel> /lib/libreadline.so.4@    /lib/libreadline.so.4.2@
05:17:08 <Boegel> /lib/libreadline.so.4.1@  /lib/libreadline.so.4.3
05:17:19 <shapr> ok, you do have it.
05:17:21 <Boegel> so I'm sure i have it
05:17:24 <tuomov> ok, the package expects a different version
05:17:30 <desrt> it expects 4
05:17:46 <Boegel> no it doesn't, it expects 4
05:17:50 <Boegel> and I have 4
05:17:56 <Boegel> so what's the freakin' problem :p
05:18:04 <tuomov> oh, I remembered 4.0..
05:18:22 <shapr> Boegel: you can ask a binary what libraries it wants with the ldd command.
05:18:42 <shapr> try the command 'which hugs' to find out exactly where in the filesystem the hugs command is
05:18:45 <desrt> shapr; not if he can't install it :)
05:19:02 <shapr> oh, does rpm barf upon install if deps aren't found?
05:19:08 <desrt> that's the impression i got
05:19:19 <bourbaki> moin
05:19:26 <shapr> darcs!
05:19:32 <Boegel> shapr: it does
05:19:34 <bourbaki> heh
05:19:34 <desrt> anything-but-arch!
05:19:39 <Boegel> hello bourbaki
05:19:54 <bourbaki> to me that darcs thing still sounds like tourette ;
05:19:56 <bourbaki> )
05:20:16 <Boegel> brb
05:20:26 <desrt> i swear... i'm the only person on earth who actually likes cvs
05:22:22 <Igloo> There's always one...
05:29:06 <Boegel> back !
05:29:20 <Boegel> shapr: do another highlight test pls :)
05:30:19 <shapr> Boegel: y0 y0!
05:34:15 <Boegel> still no highlighting :(
05:34:21 <Boegel> does anyone use XChat here ?
05:36:10 <shapr> dang, I need to talk to a bunch of serious mountain bike geeks.
05:36:13 <tromp_> i use X-chat
05:36:46 <tromp_> i wonder where that _ came from...
05:37:43 <shapr> tromp_: hey, you know anything about ice biking? I'm using an alex 32mm wide rim and a Duro wildlife 24x3 tire, and I'm searching for wider 24" rims and a bigger tire. Any suggestions?
05:37:54 <Boegel> tromp_: do you use highlighting ?
05:38:24 <shapr> Sadly, the Surly Bikes Large Marge 65mm rim comes only in 26"
05:38:27 <tromp_> sorry, shapr, my mtb doesn't get much use since i got the recumbent. never biked on ice
05:38:41 <tromp_> how do i check, boegel?
05:40:21 <Boegel> tromp_: is this in another color ? because your nickname is in it ?
05:40:47 <tromp_> Boegel is in yellow because of that
05:40:47 <shapr> didn't Okasaki do something about postfix operators in Haskel?
05:41:27 <Boegel> tromp_: please check you settings
05:41:47 <tromp_> which category?
05:41:52 <Boegel> settings -> preferences -> chattig -> general
05:41:58 <Boegel> s/chattig/chatting
05:42:20 <tromp_> no extra words to highlight on
05:42:36 <tromp_> only show away once is set
05:42:37 <Boegel> :s
05:43:15 <tromp_> how does tromp get changed to tromp_ ?
05:43:46 <Boegel> are you online somewhere else tromp_ ?
05:43:56 <tromp_> nope
05:43:56 <Boegel> it seems your client is using your alternative nick
05:44:05 <tromp> no you're not :)
05:44:10 <tromp_> i'll try quit and relogin
05:44:15 <shapr> hiya Cyber_Syrnyk 
05:44:24 <Cyber_Syrnyk> yo
05:44:34 <shapr> Cyber_Syrnyk: have you been here before?
05:44:45 <Cyber_Syrnyk> no
05:44:51 <Boegel> Cyber_Syrnyk: you want a tour from shapr ? he LOVES it :o)
05:44:52 <Cyber_Syrnyk> im new to haskell :)
05:45:00 <tromp> ah, i'm back to my old self:)
05:45:12 <Cyber_Syrnyk> u mean if i wanna to let him teach me ?
05:45:27 <tromp> just 10 minutes to game start:)
05:45:34 <Boegel> no, just give you a tour of of #haskell
05:45:35 <Cyber_Syrnyk> oh . sorry not right now .
05:45:46 <Cyber_Syrnyk> maybe later
05:45:47 <Boegel> it only takes 5 min's :)
05:45:48 <shapr> Cyber_Syrnyk: are you learning haskell?
05:45:55 <Boegel> and it's really interesting
05:46:03 <shapr> Boegel: what is this? shapr tours as a spectator sport? ;-)
05:46:06 <Boegel> shapr: how do I handle a bz2 file ?
05:46:14 <earthy> boegel: use bunzip2
05:46:19 <Boegel> shapr: just promoting you :p
05:46:29 * shapr is now a sergeant!
05:46:33 <Boegel> earthy: thanks !
05:46:42 <shapr> Cyber_Syrnyk: are you learning Haskell for school? or for fun?
05:47:17 <Cyber_Syrnyk> huh
05:47:38 <Cyber_Syrnyk> for fun not for school 
05:47:58 <Boegel> someone throw in another highlight test pls :)
05:48:09 <shapr> Ok, have you used any somewhat functional languages before like scheme, lisp, ML, OCaml, or so?
05:48:31 <Boegel> Cyber_Syrnyk: nice :) have you got any project in mind you would like to try in Haskell ?
05:48:50 <shapr> Cyber_Syrnyk: anyway, if you don't have time for the tour, you can find learning resources at http://www.haskell.org/learning.html
05:48:57 <musasabi> Boegel: ping
05:49:06 <shapr> Feel free to ask me if you have any questions about Haskell.
05:49:07 <Boegel> musasabi:  pong
05:49:19 <shapr> Boegel: prettycolors?
05:49:42 <Boegel> strange, it only colors the nick, not the whole message, and it uses a different color (yellow in stead of red)
05:50:06 <Boegel> it's a Syrnyk invasion !
05:50:47 <shapr> cool, he's twins.
05:52:55 <Boegel> is there any way I can bind the 'ctrl-tab' key combo to switching workspaces in stead of windows ?
05:53:08 <shapr> I'm sure you can...
05:53:17 <shapr> but I don't know how :-)
05:53:35 <shapr> g'day ozone_
05:54:02 <Syrnyk_> i will learn more after getting better in c# and asm
05:54:08 <shapr> ok
05:54:16 <dv> ugh c#
05:56:00 <tromp> @index joinLines
05:56:01 <lambdabot> bzzt
05:56:05 <musasabi> asm is quite worthless these days
05:56:08 <musasabi> tromp: unlines
05:56:32 <tromp> oh wait, it's defined later in the source:)
05:58:41 <Boegel> how do I add something to my 'path' variable ? in a way it stays there?
05:58:43 <Boegel> set path = ?
05:58:50 <earthy> musasabi: knowledge of asm is not worthless
05:59:11 <dv> you add it to your shell config file
05:59:13 <tuomov> Boegel: stays across sessions?
05:59:42 <musasabi> earthy: it is not worthless, but it is not very often that it is needed.
05:59:50 <musasabi> and then again mostly reading and not writing.
06:00:01 <bourbaki> moin TheHunter 
06:00:05 <Boegel> tuomov: yes
06:00:08 <TheHunter> moin bourbaki 
06:00:16 <Boegel> hey TheHunter
06:00:20 <tuomov> what's your $SHELL?
06:00:27 <TheHunter> hiya Boegel 
06:00:34 <tuomov> bash?
06:00:35 <Boegel> /bin/bash
06:00:38 <Boegel> yep
06:00:55 <tuomov> then put PATH=$PATH:your_additions (or the other way around) in either .bashrc or .bash_profile
06:01:16 <tuomov> .bash_profile only gets reloaded by a login shell (but some distros have configured to xterm to appear as a login shell)
06:01:22 <tuomov> .bashrc is loaded by all interactive shells
06:01:34 <Boegel> thanks tuomov !
06:01:54 <shapr> I think Syrnyk wasn't ready for Haskell.
06:02:07 <tuomov> depending on your settings, if you put the entry on .bashrc, starting a shell within shell will grow the path...
06:03:29 <tuomov> it is good to be able to program at least a little asm so that you know what the computer is doing when programming in higher-level languages
06:03:35 <Boegel> hi skylan, arjanb
06:04:16 <musasabi> tuomov: for that it is better to understand computer architecture than to know any given assembler language.
06:04:32 <earthy> musasabi: ummm... not entirely
06:04:48 <tuomov> all assembly languages are rather similar. Once you know one, you know all them.
06:04:59 <earthy> tuomov: not quite true either :P
06:05:20 <tuomov> there are differences in architechtures, but the way you write the code is almost the same.
06:05:45 <tuomov> (not considering vliw and such.)
06:05:48 <earthy> really? you've never seen IA64 code or DSP code, have you?
06:05:53 <earthy> bingo :)
06:06:28 <tuomov> but most c
06:06:44 <tuomov> but most general-purpose processors that have had any success are similar
06:07:36 <shapr> earthy: EPIC isn't so different imho...
06:08:03 <earthy> shapr: it is in that it gives you way more control over the pipelining
06:08:17 <musasabi> and the *old* stack based assembler languages are quite different too.
06:08:26 <tuomov> and while I haven't programming in vliw or a dsp, I would expect many general principles to still hold. What you do may just be a little more limited, or you may have to do more hand-optimisation
06:08:38 <Lemmih> Good evening, shapr.
06:08:47 <shapr> earthy: yah, but the asm itself isn't so different. just the stuff that says "this part can be parallel"
06:08:50 <shapr> greetz Lemmih 
06:08:56 <earthy> shapr: oh, yeah
06:09:03 <tuomov> x87 is stack-based..
06:09:08 <Boegel> hello Lemmih
06:09:08 <earthy> if you want completely different, go transport triggered architecture.
06:09:20 <musasabi> tuomov: most of the time I would prefer someone understanding how caches work etc to someone who can write assembler (but does not understand things at a larger perspective)
06:09:36 <Boegel> does anybody know how I can make my windows stikcy ? as in thye 'snap' to other windows when you're moving them around ? (in Gnome)
06:09:59 <earthy> the thing to understand with asm is that there *is* a level below the high level programming languages you use
06:10:09 <shapr> earthy: are DSPs different? never looked at that.
06:10:19 <earthy> shapr: some of them are
06:10:25 <earthy> (no jump instructions, e.g.)
06:11:30 <earthy> and that the level below the level you normally see does influence the exact details of the abstractions you're working with
06:11:36 <earthy> such as the speed effects of cache sizes
06:11:55 <earthy> or the magic of pointer twiddling with garbage collection
06:16:08 <Boegel> I have another question guys, if it's ok ?
06:16:17 <shapr> one day, I must sit down and read all of Henry Baker's writings.
06:16:29 <shapr> Especially since he posts to rec.sport.unicycling
06:16:33 <shapr> Boegel: yes!
06:16:48 <Boegel> I have a partition (FAT32), which is mounted in linux
06:17:02 <tuomov> Boegel: in the *nix world, "stickyness" means that a window appears on each workspace. What you describe is edge snap
06:17:10 <Boegel> and now I want to make a shortcut to it like I have shortcuts for my cd-rom drives
06:17:14 <desrt> no no no
06:17:25 <desrt> stickyness means that you need to be the owner of a file in order to delete it
06:17:56 <desrt> these neo-sticky userpers have stolen the term
06:18:01 <shapr> I thought it meant your younger siblings had spilled sugary drinks on your keyboard.
06:18:15 <tromp> is mapM same as sequence . map  ?
06:18:29 <shapr> @type mapM
06:18:30 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
06:18:35 <shapr> @type sequence . map
06:18:36 <lambdabot> bzzt
06:18:39 <shapr> @type (sequence . map)
06:18:40 <lambdabot> bzzt
06:18:43 <desrt> hahah
06:18:44 * shapr smacks lambdabot 
06:18:53 <Lemmih> @type (.) sequence map
06:18:55 <lambdabot> bzzt
06:19:07 <TheHunter> @type (Control.Monad.sequence . map)
06:19:09 <lambdabot> bzzt
06:19:16 * shapr blinks
06:19:18 <desrt> Prelude> :t (sequence . map)
06:19:18 <desrt> Couldn't match `[m a]' against `[a1] -> [b]'
06:19:18 <desrt>     Expected type: (a1 -> b) -> [m a]
06:19:18 <desrt>     Inferred type: (a1 -> b) -> [a1] -> [b]
06:19:18 <desrt> In the second argument of `(.)', namely `map'
06:19:38 * desrt gives lambdabot a cookie
06:20:00 * Lemmih would like to talk about the Haskell library page.
06:20:06 <shapr> Lemmih: talk!
06:20:13 <TheHunter> @type (sequence .). map
06:20:14 <lambdabot> (sequence .). map :: forall m a a1.
06:20:14 <lambdabot> 		     (Monad m) =>
06:20:14 <lambdabot> 		     (a1 -> m a) -> [a1] -> m [a]
06:20:51 <TheHunter> tromp: i believe it's the same
06:21:02 <Lemmih> How often should the database be rebuild if we use URLs to Cabal descriptions on the wiki?
06:21:10 <shapr> once a day?
06:21:29 <Lemmih> And should a package be deleted from the database if it's deleted from the wiki?
06:21:32 <shapr> I've got r00t on haskell.org, I can set up a cron job and all the other bits.
06:21:33 <tromp> thx
06:21:43 <desrt> shapr; !
06:21:51 <desrt> shapr; can you please set my fullname? :P
06:21:56 <shapr> desrt: what you didn't know I have r00t?
06:22:08 <shapr> desrt: yes, but are you sure you want me to set it?
06:22:10 * shapr cackles evilly
06:22:14 <desrt> hahah
06:22:26 <desrt> can you set it to something appropriate? :)
06:22:31 <shapr> bah, ok...
06:22:32 <desrt> like, for example, my full name?
06:22:36 <shapr> boring legal names :-/
06:22:53 <Lemmih> Any suggestions to my last question?
06:23:14 <shapr> Lemmih: I'd say it should be deleted once a week
06:23:24 <shapr> in case of wiki spam
06:23:43 <desrt> i'm suprised that wikispam isn't more of a problem
06:23:45 <Lemmih> I'm somewhat against the Wiki idea /-:
06:24:00 <shapr> well, argue, tell what's better, and why.
06:24:24 <shapr> desrt: hey, I think you're talking about cvs.haskell.org, I don't got root there.
06:24:33 <shapr> not even a user account on cvs.haskell.org
06:24:33 <desrt> shapr; oh. :(
06:24:43 <shapr> only on www.haskell.org
06:24:58 <Lemmih> I don't like that spammers could take down the library page by deleting the wiki page. Or overloading the crawler by spamming it.
06:24:58 <desrt> well, can you add my binaries for 6.2.2 to the webpage, then? :)
06:25:13 <shapr> maybe
06:25:19 <Lemmih> Even if it's only for a limited amount of time.
06:25:42 <shapr> Lemmih: I don't think spammers are such a big problem because there are people who restore the information
06:25:54 <desrt> shapr; i decided that i should ship them with a built-in rootkit to assist me in troubleshooting people's problems they might have during install
06:26:19 <shapr> I think that it would be very hard to overload the crawler, especially since the spam wouldn't affect it unless the page contained a valid Cabal description file
06:26:20 <desrt> shapr; hope this is not a problem
06:26:23 <shapr> I suspect spammers won't go that far.
06:26:38 <shapr> desrt: no problem... I've already trojaned your rootkit.
06:26:53 <shapr> g'day SyntaxNinja 
06:26:59 <SyntaxNinja> y0 shapr
06:27:12 <desrt> shapr; oh good.  now all we need to do is get them to install it on cvs. and you *will* have root afterall :)
06:27:20 * shapr cackles evilly
06:27:33 <SyntaxNinja> I had to bite my tongue to keep from responding to Manuel
06:27:39 <shapr> er why?
06:28:05 <SyntaxNinja> the sorta 'rtfm' comment; I felt like pointing out that I was the one who started the librariesAndTools page on the wiki
06:28:12 <SyntaxNinja> but that would be childish, so I'll just do it on IRC ;)
06:28:25 <shapr> haha
06:28:54 * desrt goes to school or something
06:29:26 <shapr> Lemmih: it is true that spammers can change the wiki, but also, users can create a wiki account and change the permissions on the wiki page such that only admins or that user can modify the page
06:29:38 <dons> everyone's awake :)
06:29:46 <Lemmih> shapr: I still don't like it /-:
06:29:47 <SyntaxNinja> also for violently agreeing with me as if I had disagreed
06:30:20 <shapr> Lemmih: the problem with building a user input form and etc is that then someone has to maintain it all
06:30:28 <shapr> the advantage of a wiki is that it's community-transparent
06:30:42 <tromp> @index break
06:30:43 <lambdabot> Data.List,GHC.List,Prelude,List
06:30:45 <shapr> if I see an error in someone's Cabal package, I'll just fix it.
06:30:58 <Lemmih> shapr: The users would just upload their description file to the webpage... No forms needed.
06:31:25 <shapr> but then other users can't see and modify the uploaded files
06:31:42 <shapr> at least, with the standard way to do uploading of content into databases
06:32:33 <shapr> For example, I wrote the HaskellDbTutorial just to teach myself. Usually I write that kind of thing into a file on my local drive.
06:32:54 <shapr> And no one ever sees it, because I don't think about how it might be useful to others.
06:33:27 <shapr> With a wiki, those who know less learn stuff, and those who know more add stuff.
06:33:34 <Lemmih> It wouldn't be hard to allow the user to change the fields.
06:33:54 <shapr> but then, you have to change the code everytime the fields change
06:34:06 <Lemmih> Nope. It's completely dynamic.
06:34:31 <Lemmih> Check the search page. It changes available categories dynamically.
06:35:07 <shapr> Well, if you write the code, you can do what you think is right. I think the wiki idea is the best approach, but I'm not perfect, and I'm not coding it :-)
06:36:21 <shapr> I think the wiki input has the advantage of simplicity and flexibility.
06:36:48 <shapr> searching the wiki text files for CategoryLibrary is easy from the local drive
06:36:55 <Lemmih> Wouldn't a wiki crawler be a lot hard to code?
06:37:12 <shapr> probably one line of shell script.
06:37:41 <Lemmih> To find the URLs, download the files, parse them and then add them to the DB? wow
06:38:04 <shapr> cd /usr/share/moin/hawiki/data/text/ && fgrep CategoryLibrary *
06:38:21 <shapr> that finds all the libs
06:39:12 * shapr hacks
06:39:43 <shapr> how do you add them to the db right now?
06:40:08 <Lemmih> But if you load the description file to the webpage then my program will have it as text without having to do anything else.
06:40:46 <dv> how do i er.. print out a variable of type [[Int]]?
06:40:59 <shapr> putStrLn $ show  maybe?
06:41:17 <dv> ERROR "matter.hs":138 - Ambiguous type signature in inferred type
06:41:17 <dv> *** ambiguous type : (Show (Int -> a), Num a) => Life -> IO ()
06:41:30 <Lemmih> I have no automated way of adding packages now. That's what I started to hack on yesterday afternoon.
06:42:38 <shapr> do you have a function that takes a PackageIdentifier?
06:42:53 <Lemmih> PackageIdentifier?
06:43:12 <shapr> do you use the Cabal code to read the .description ? or what?
06:43:22 <Lemmih> Yes.
06:43:53 <Lemmih> And my code would not break if Cabal changed the fields in the package description.
06:44:09 <shapr> ok
06:44:24 <dv> http://transfixion.org/files/life.hs :|
06:44:42 <shapr> you import a PackageDescription?
06:45:31 <shapr> Lemmih: how about allowing both type of input and seeing which one is better?
06:45:42 <shapr> I'd be happy to write all the code necessary for the wiki input method.
06:45:51 <Igloo> desrt: To get ghc 6.2.2 binaries listed you should mail Simon Marlow
06:46:24 <shapr> dv: put deriving Show at the end of your first line
06:46:39 <Lemmih> shapr: Great. The two options aren't mutual exclusives.
06:46:42 <Mike121> hello 
06:46:47 <Lemmih> Hello Mike121
06:46:48 <shapr> hi Mike121 
06:47:06 <Mike121> hi there Lemmih and shapr 
06:47:17 <Lemmih> Mike121: Looking for Haskell info?
06:47:40 <Mike121> i am looking at learning Haskell  any tips before i start out ?
06:47:44 <shapr> Lemmih: so, you want to post the url to your prototype on the libraries list?
06:47:55 <desrt> Igloo; i've sent an email to cvs-ghc
06:48:01 <Mike121> i have done no functional programming so far ...
06:48:04 <Igloo> That'll do
06:48:13 <Lemmih> shapr: Not really. It's on my local desktop so it's not very reliable.
06:48:29 <shapr> want me to run it on www.scannedinavian.org?
06:48:40 <Lemmih> That'd be great (-:
06:48:46 <shapr> cool, send me the sources
06:48:59 <shapr> actually
06:49:03 <shapr> do you have a darcs repo?
06:49:15 <shapr> then I can submit any changes
06:49:41 <Lemmih> How do I create a darcs repo?
06:49:52 <shapr> 'darcs init' in a dir
06:50:10 <shapr> then darcs add for the files (darcs add -l maybe does the right thing?)
06:50:19 <shapr> and darcs record to commit those changes
06:51:05 <shapr> then I can checkout the repo with darcs get http://lemmih.dk/repos/reponame
06:52:33 <dv> shapr: not really working..
06:52:43 <arjanb> dv: the last line seems not correct
06:53:05 <Lemmih> shapr: It's _very_ messy.
06:53:12 <shapr> it works?
06:53:33 <shapr> it appears to work, though I haven't tried to upload a cabal.description yet.
06:53:44 <shapr> works > not works
06:54:13 <arjanb> dv: you are passing a binary function to the inner map
06:54:25 <dv> yeah i just noticed
06:58:31 <arjanb> dv: don't use only single character variables / functions and not putting everything in a single where clause may make your code more understandable
06:59:23 <dv> i didn't really think i'd be showing it to anyone
06:59:38 <dv> but this is definitely broken and needs a rewrite
07:01:33 <Boegel> hey TheHunter :)
07:02:17 <TheHunter_> hey, hey
07:04:50 <Boegel> bye TheHunter
07:04:53 <Boegel> :s
07:05:33 <Boegel> hey TheHunter
07:05:34 <Boegel> :p
07:06:48 <Mike121> what compiler should i use to start out with haskel ? 
07:07:34 <Mike121>  /s /haskel /haskell
07:08:22 <TheHunter> i suggest ghci
07:08:46 <TheHunter> you can type expressions which will be evaluated and printed
07:09:41 <Boegel> hugs is easier to me...
07:09:48 <Boegel> but ghci is nice (and faster)
07:09:59 <Mike121> hmmz its not available for windows is it ?
07:10:07 <Boegel> yes it is
07:10:20 <Boegel> both ghc and hugs are availiable for windows
07:10:24 <SyntaxNinja> hugs is more lightweight, so it has a slight advantage there for new users
07:10:27 <TheHunter> Boegel: ghc error messages are usually better
07:10:29 <Mike121> due to some constraints i am on windows for a while 
07:10:38 <Boegel> that may be true
07:10:45 <Boegel> but that's just a personal thing I believe
07:10:53 <Mike121> ah i like better error messages
07:11:00 <Mike121> i make plenty of errors
07:11:17 <Boegel> :)
07:11:24 <Boegel> then you should install ghci
07:12:00 <Mike121> ty all i will give ghci a shot 
07:12:11 <TheHunter> http://www.haskell.org/ghc/download_ghc_621.html#windows
07:16:58 <TheHunter> Boegel: compare the errors msgs for test = x where x = 4 :: Char
07:17:14 <TheHunter> (just a random example)
07:17:56 <Mike121> ty TheHunter i was looking at http://www.haskell.org/ghc/download_ghc_622.html and wondering where the windows build was 
07:18:17 <Mike121> netsplit ...
07:18:29 <TheHunter> 6.2.2 is quite new, so i guess nobody has packaged it yet for windows.
07:18:41 <tromp> or for Debian...
07:19:03 <TheHunter> tromp: haskell-unsafe has it
07:19:42 <Boegel> TheHunter: you have a good point with that exampe :)
07:20:38 <Boegel> s/exampe/example
07:20:49 <tromp> why is it on haskell-unsafe but not on ghc webpage?
07:21:26 <tromp> the 6.2.1 .deb was on ghc webpage next to .rmp
07:21:31 <tromp> uhm, .rpm
07:23:24 <SyntaxNinja> tromp: because the 6.2.2 version is experimental in Debian
07:23:47 <Mike121> haskel compilers are much more resource intensive and difficult to make compared to a imperitive language like c and c++ ?
07:24:20 <dons> don't think they are more difficult to make
07:24:43 <dons> for some defn of difficult
07:25:06 <bourbaki> i wonder if there could be some hardware that would support haskell
07:25:11 <musasabi> g++ seems to be even more resource intensive than ghc for many tasks.
07:25:15 <bourbaki> like the old prolog machines and lisp machines
07:25:52 <Mike121> i suppose we could write an os in haskell and call it a haskell machine ?
07:26:12 <tromp> weird that the .deb package is less stable than the .rpm :(
07:26:30 <dons> already have a haskell os, and it runs C programs too
07:26:45 <Igloo> It's not on the GHC webpage because it'll probably move to Debian in a day or two and I don't want to have to hassle Simon twice
07:26:52 <SyntaxNinja> tromp: it's not less stable, it's experimental and unofficial. if you want to use it, go ahead.
07:27:17 <Mike121> oh cool dons  whats it called ?
07:27:23 <Mike121> haskell os ?
07:27:27 <tromp> i'll just wait a few days; thx
07:27:30 <dons> house/hOp
07:27:40 <bourbaki> id call it hoss :) like that guy in bonanza ;)
07:28:14 <stepcut>  /quit frsd
07:29:26 <TheHunter> yah! gadts!
07:30:59 <Boegel> I'm out, watching 24
07:31:13 <TheHunter> 24?
07:31:43 <shapr> gah, I hate it when paying work gets in the way of programming.
07:32:13 <Boegel> TheHunter: http://www.skyone.co.uk/24/
07:32:19 <Boegel> a must see, great series
07:32:48 * Boegel is away: watching 24 and eating some soup :)
07:33:05 <bourbaki> you eat soup?
07:33:08 <bourbaki> is it frozen?
07:33:29 <Boegel> no, it's in a can
07:33:43 <Boegel> but I will get it out before I eat it :p
07:33:48 <bourbaki> i see but dont you drink soup usually :)?
07:34:06 <bourbaki> hahaha dont you like the crunchyness for the can ;)?
07:34:14 <shapr> Depends on what you call soup. I like soup that you can eat with a fork.
07:34:21 <Boegel> eat/drink, it depends how much pieces are in it :)
07:34:37 * Boegel agrees with shapr
07:34:42 <shapr> In the old west, they used to say the coffee wasn't strong enough if you couldn't float a horseshoe on it.
07:34:43 <bourbaki> shapr: o.O what kind of soup is that?
07:34:55 <bourbaki> you mean beans and such?
07:35:06 <shapr> sure, chili is soup too, right?
07:35:08 <Boegel> vegetable soup, with spaghetti and meat balls :)
07:35:22 <shapr> I had a soup in france, and it was like... 99% liquid.
07:35:31 <bourbaki> hm chili is not soup to me but it clarifies :)
07:35:38 <TheHunter> :r
07:35:39 <bourbaki> yeah thats soup
07:35:46 <TheHunter> oops
07:35:46 <shapr> TheHunter: :arrr!
07:35:50 <shapr> @arr
07:35:50 <lambdabot> Prelude.(!!): index too large
07:35:52 <shapr> doh
07:36:02 <TheHunter> what happens to the channel if it gets reloaded?
07:36:14 * shapr tries to reload #haskell
07:36:19 <bourbaki> heh
07:36:36 <bourbaki> reboot the internets ;)
07:36:46 <shapr> reboot universe (y/n) ?
07:37:07 <bourbaki> reminds me somehow of one of the prattchet books
07:37:46 <shapr> yes :-)
07:49:18 <Mike121> http://www.haskell.org/complex/why_does_haskell_matter.html i like the part where he says "So when you start thinking things like "This is too weird, I'm going back to C++", force yourself to continue learning Haskell - you'll be glad you did." thats exactly how it looks like right now 
07:49:33 <Mike121> or rather how i feel right now 
07:50:18 <SyntaxNinja> hehe
07:50:35 <SyntaxNinja> Mike121: it's really not too bad :)
07:54:37 <bourbaki> hm any good idea how i can apply a fn to just the nth element of a list?
07:55:35 <SyntaxNinja> f ( l !! n)
07:56:25 <bourbaki> yeah but that wont retrieve the whole list again isnt there a function that splits a list at a specific element?
07:57:20 <SyntaxNinja> @type splitAt
07:57:22 <lambdabot> splitAt :: forall a. Int -> [a] -> ([a], [a])
07:57:40 <bourbaki> ah cool thanks
08:05:05 <TheHunter> Bye, i'm gonna go home. No internet there :(
08:19:41 <kosmikus> does ghc-pkg behave differently on Windows than it does on Linux?
08:19:52 <kosmikus> I get a strange "dependency 'base' does not exist" error message ...
08:22:58 <musasabi> A nifty thing for hemacs would be the ablity to render alpha etc as their real greek letter counterparts in haskell source.
08:23:07 <musasabi> But doing that is quite nontrivial :-(
08:23:59 <Mike121> isnt there a latin font ?
08:24:02 <Mike121> in emacs 
08:24:25 <Mike121> and emacs handles greek too i suppos 
08:24:51 <Igloo> musasabi: you have issues with widths changing then. Also, in principle, the unicode alpha character is valid in sources...
08:27:19 <Mike121> is haskell object oriented ? 
08:28:05 <Igloo> No
08:28:13 <Mike121> it could be absolute nonsense but excuse the same ... i have no idea about haskell 
08:33:22 <tromp_> weird
08:41:36 <Boegel> Mike121: Haskell is a functional language
08:41:47 <Boegel> everything (almost everything) acts as a function
08:46:48 <musasabi> Mike121: it has been shown that you can do OO in haskell, but we don't want to.
08:47:26 <musasabi> Igloo: yes widths are the most problematic part, maybe for typesignatures though..
08:47:38 <tromp> oo programmers do it with objects
08:47:47 <tromp> haskell programmers do it with monads
08:47:57 <musasabi> Or can I have unicode alpha inside haskell sources?
08:48:06 <Igloo> You can
08:48:15 <raboof> note that many programming strategies, like nice modularisation of code, are often associated with OO specifically but apply just as well to imperative and functional programming
08:50:34 <tromp> poor kramnik has 2min/move left to try and win a drawish position
08:58:56 <Mike121> ah tnx maybe it will all get clearer 1 week down the line 
08:59:02 <bourbaki> tromp: ?
09:02:24 <tromp> yes?
09:02:41 <bourbaki> tromp: 2min/move in what game?
09:02:59 <tromp> final game of chess world chmp.ship
09:03:10 <bourbaki> ah
09:07:19 <bourbaki> http://paste.phpfi.com/33637
09:07:28 <bourbaki> hm ive got a problem here
09:08:19 <bourbaki> when you look at the new implementation of +++ then you will see that it wont work if you want to use it twice in sucsession
09:08:43 <bourbaki> is there any possibility to fix that with lists?
09:13:31 <tromp> how do u want to use it twice in succession?
09:13:49 <bourbaki> for example like this
09:14:42 <bourbaki> erup ((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3))) [1,1,1]
09:14:57 <bourbaki> er
09:15:04 <bourbaki> (erup ((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3)))) [1,1,1]
09:15:10 <bourbaki> thats the indended usage
09:16:21 <tromp> btw, ur code wld look lots cleaner with lambda patterns:)
09:16:33 <bourbaki> the first usage of +++ is perfectly fine but the second usage wont work cause if im not totally mistaken haskell wont match [a] on a
09:17:01 <bourbaki> lambda patterns?
09:17:07 <tromp> second (F f) = F (\(a:b:l) -> a:(f b):l)
09:17:22 <bourbaki> ah ok
09:18:04 <tromp> somehow, first and second don't seem the right primitives for lists
09:18:16 <tromp> they were designed for pairs
09:18:29 <bourbaki> yes right cause the codomain of the first +++ is [a]
09:18:58 <bourbaki> right but i need to rewrite it with lists somehow
09:19:17 <tromp> well, use nested pairs
09:19:23 <bourbaki> or anything that behaves like a list that is that allows me to enumber the elements in that "vector"
09:19:24 <tromp> instead of lists
09:19:39 <bourbaki> nested pairs as i did in the old code?
09:20:09 <tromp> yes
09:20:21 <bourbaki> that wont do the job for what i want to do
09:20:40 <tromp> what do you want to do?
09:21:07 <bourbaki> well i cant have recursion on nested pairs can i?
09:21:35 <tromp> sure u can, nested pairs are almost isomorphic to lists
09:22:01 <tromp> oh wait
09:22:07 <tromp> there's type issues:(
09:22:35 <bourbaki> if you look at the last line this is what i want to use it for
09:22:44 <bourbaki> thats one layer of a neural network
09:23:34 <bourbaki> if i had now several layers and i wanted to "crunsh" the layer like in that line then i wont be able to >>> the single layers to the complete network
09:24:11 <bourbaki> cause the next layers domain is not nested
09:25:38 <tromp> it's hard to make out the structure of +++ and &&& 's
09:28:07 <tromp> so how do existing arrow-type neural nets deal with that?
09:29:18 <bourbaki> no idea
09:31:31 <bourbaki> hm ok nm the last comment
09:31:56 <bourbaki> but i would need a way to enumerate the elements of these pairs
09:32:03 <bourbaki> to ie build the sum
09:36:07 <Boegel> @arr
09:36:07 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
09:36:38 <Boegel> @seen shapr
09:36:38 <lambdabot> I saw shapr leaving #haskell 1 hour 48 minutes 24 seconds ago.
09:36:42 <Boegel> ow
09:36:51 * Boegel is in shock
09:37:05 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]' by Boegel
09:37:09 <Boegel> woops: s
09:37:34 <Boegel> why can I change the topic ? :s
09:41:17 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'' by Boegel
09:41:22 <Boegel> fixed
09:41:38 <Boegel> why am I able to change the topic ?
09:41:48 <Mike121> cos we are on freenode 
09:41:58 <Mike121> where u have freedom of speech 
09:42:08 <SyntaxNinja> we could lock it down, but why bother?
09:42:38 <Boegel> because there are numwits like me who change it by accident :p
09:42:45 <Boegel> I'm out, taking a shower and such
09:42:46 <Boegel> bye !
09:43:23 <SyntaxNinja> l8r
09:49:14 <bourbaki> tromp: so any idea? you said that you can have recursion on these nested pairs how do you do that?
09:50:57 <bourbaki> i guess ill have to say goodbye to +++ and &&& for what i have in mind
09:56:44 <Mike121> which is the best noob tutorial on haskel ?
09:56:56 <Mike121>  /s /haskel /haskell 
09:57:01 <kristnjov> some say there are none, but i'd doubt that
09:57:23 <Mike121> so far the some seem to be winning ...
09:58:21 <tromp> bourbaki, you cld define !! as (a,b)!!0 = a   (a,b)!!n = b!!(n-1)
09:58:46 <tromp> but i'm not sure if that suffices for your needs
09:59:38 <bourbaki> hm and how do i know that some element in the last element in a nested pairing?
10:01:31 <Mike121> so far haskell seems like my worst nightmare come true ... the switch to dvorak from qwerty was a lot easier ...
10:01:57 <tromp> you'd have to pair the last element with (), like lists do:(
10:02:14 <musasabi> Mike121: I liked haskell.org/tutorial
10:02:44 <musasabi> Mike121: when you have read that and want to understand monads, look at the nomaware tutorial
10:03:35 <bourbaki> tromp: hm but how would i build that into first and second?
10:04:50 <tromp> dunno, you have to read more papers on arrow applications to see how they do networks
10:05:32 <tromp> i dont know much about it
10:05:33 <bourbaki> my problem with a lot of applications of arrow is that they hide functionality in functions
10:05:49 <bourbaki> i just want to rely on a handfull of functions
10:06:39 <tromp> what i understood was that they just expose the nesting structure of pairs
10:22:57 <Maddas> shapr!!!
10:23:01 * Maddas summons shapr
10:26:45 <Lemmih> Yay. It's working.
10:31:19 <shapr> did someone call me?
10:31:42 * shapr gets out the pom-poms
10:31:50 <shapr> rah rah rah! sis boom bah! yay Haskell!
10:32:00 <Mike121> (x:xs) where x is 1 and xs is 1 2 3 4 will be equal to 11234 ?
10:32:13 <Mike121> hello shapr 
10:32:25 <shapr> hiya Mike121 
10:32:43 <shapr> that colon is something that makes a list
10:32:49 <shapr> Mike121: do you have Hugs or GHCi ?
10:33:11 <Mike121> right now hugs ghic is not yet downloaded
10:33:51 <shapr> can you type 1:[] into Hugs?
10:33:53 <shapr> what happens?
10:34:21 <polli> [1]
10:34:27 <dv> i'm having trouble making a list of lists of pairs... help |:
10:34:34 <Mike121> i get a [1]
10:34:59 <dv> (the pairs should correspond to the the their own coordinate in the list)
10:35:01 <shapr> Mike121: right, if you have a list of things, and you put one of those things and then a colon, it means "put this thing at the front of that list of things"
10:35:26 <shapr> when you use that in the arguments to a function, it means the opposite...
10:35:32 <shapr> myLength [] = 0
10:35:42 <shapr> myLength (x:xs) = 1 + myLength xs
10:35:53 <Mike121> take the first one it the list ?
10:36:00 <shapr> yes, exactly
10:36:07 <Mike121> ah tnx 
10:36:29 <shapr> you can also do (x:y:zs) if you want the first two items
10:36:36 <shapr> and you can match on exact values also
10:36:50 <Lemmih> shapr: My library page is now capable of uploading new packages.
10:37:16 <shapr> like myThingy ('f':letters) = "there's an f at the front, and " ++ letters ++ " at the back"
10:37:23 <shapr> Lemmih: cool!
10:38:51 <Mike121> shapr i guess i will store the last example and chew on it like a cow later 
10:39:02 <shapr> ok
10:39:19 <shapr> I can explain it great detail later, but right now I feel like coding...
10:40:19 <shapr> Lemmih: got some code handy I can hack on?
10:40:25 <Mike121> fine bi me i was bengining to feel a bit dizzy with the last example ...
10:41:04 <Mike121>  /s /bi /by /s /bengining /beginning 
10:41:50 <shapr> hej polli, wazzup?
10:41:57 <Maddas> shapr!
10:43:26 <shapr> Maddas!
10:43:47 <polli> shapr: not much, studying..
10:44:18 <shapr> polli: studying for programming exams?
10:44:44 <polli> crypto exam, so something between programming and math :)
10:44:52 <shapr> whoa, nifty
10:44:56 <kosmikus> mattam: could you try to emerge ghc-6.2.2 and move it to ~ppc if it works for you?
10:45:00 <shapr> now there's a class I'd like to take.
10:45:20 <polli> shapr: yes, it's really interesting
10:45:32 <shapr> have you read Schneier's Applied Cryptography?
10:45:44 <shapr> greetings Joe, how may we assist you?
10:46:28 <shapr> I only read part of Schneier's book at my last job, but it's really cool.
10:46:47 <shapr> reading about Merkle's Puzzles was a mind-expanding experience.
10:47:22 <shapr> There's some very minor progress on spoken crypto lately, but nothing near what I'd like to hear.
10:48:20 <polli> shapr: nope, I havn't read that book
10:48:23 <shapr> Lemmih: y0, code? Or should I bug you after you have some more bits working?
10:48:39 <shapr> polli: did you get to learn about Merkle's Puzzles?
10:49:05 <polli> shapr: no, doesn't ring a bell
10:49:11 <shapr> http://en.wikipedia.org/wiki/Merkle's_Puzzles
10:49:25 <Lemmih> shapr: I can give you a .tgz
10:50:04 <polli> didn't exist, I'll google for it
10:50:24 <shapr> this ? http://en.wikipedia.org/wiki/Merkle's_Puzzles
10:50:43 <shapr> huh, works for me
10:52:17 <polli> missed the last s :)
10:52:53 <polli> shapr: cool :)
10:53:19 <shapr> the interview in the related links at the bottom is great.
10:55:40 <shapr> the interview has parts like the ACM editor saying "I am bothered that your submission does not list any references."
10:56:55 <Mike121> http://www.haskell.org/complex/why_does_haskell_matter.html
10:56:58 <Mike121> it this page 
10:57:11 <shapr> Mike121: eh?
10:57:30 <Mike121> the quick sort example i have some trouble with the function 
10:58:00 <Mike121> less = filter (<x)  xs
10:58:15 <shapr> do you know the filter function?
10:58:40 <Mike121> yes and maybe no but let me give u an example 
10:58:40 <Igloo> That doesn't sound like a very cheap way to exchange keys
10:58:45 <Mike121> suppose 
10:58:47 <shapr> filter (\x -> x < 3) [1,2,3,4,5]
10:58:50 <Mike121> the seies is 
10:59:21 <shapr> Mike121: try typing what I just wrote into your handy Hugs
10:59:26 <Mike121>  6 3 4 9 3 3 3
11:01:31 <Mike121> and 6 is the first no in the list 3 < 6 and it goes to less so is 4 and it goes to 6 how does 3 get stored below 4 in the sort ?
11:02:01 <Mike121>  /s / goes to 6 / goes to less 
11:03:16 <shapr> Mike121: did you type the text I showed you into hugs?
11:03:19 <Mike121> in c there would be a loop i fail to make the same connection here 
11:03:29 <Mike121> [1,2]
11:03:47 <shapr> ok, change the 3 to 4 or to 2 and try it again
11:04:32 <Mike121>  filter (\x -> x < 3) [1,2,4,2,5]
11:04:33 <Mike121> [1,2,2]                 
11:04:43 <shapr> do you see what's happening?
11:05:03 <Mike121> it filters everything less than . 
11:05:09 <Mike121> 3 sorry
11:05:31 <shapr> another way to write (\x -> x < 3) is (<3)
11:05:57 <Mike121>  filter (\x -> x < 3) [1,2,4,2,5]
11:05:58 <Mike121> [1,2,2]                 
11:06:10 <Mike121> sorry about that
11:06:38 <shapr> filter takes two arguments, a function and a sequence.
11:06:59 <Mike121> so it will be arranged magicalli in ascending order by filter ?
11:07:03 <shapr> it applies that function to each item in the sequence, and it keeps the items where the function returns True, and it drops the items where the function returns false
11:07:48 <Mike121> filter (\x -> x < 3) [1,2,1,2,5]
11:07:49 <Mike121> [1,2,1,2]    
11:08:02 <Mike121> in which case this should be 1122 ?
11:08:11 <arjanb> no that is done by the recursive call on less
11:08:46 <Mike121> where is the recursive call in that syntax arjanb ?
11:09:02 <Mike121> i mean the quick sort code 
11:09:12 <tic> Mike121, filter calls its first argument on each item in the list, which is the first argument.
11:09:31 <tic> Mike121, so it calls (\x -> x < 3) 1, (\x -> x < 3) 1, (\x -> x < 3) 2, etc.
11:09:42 <arjanb> qsort less ++ [x] ++ qsort more
11:09:45 <tic> Mike121, and if it returns True, then that item is kept, ohtherwise it's not.
11:11:52 <Mike121> tic i get that part what i dont get is how will the quick sort do a recursive call on quicksort ... 
11:12:21 <tic> ah.
11:13:41 <Mike121> ++ means recursion ? 
11:13:48 <arjanb> qsort [3, 2, 1, 4, 5] == qsort [2, 1] ++ [3] ++ qsort [4, 5] == ...
11:14:23 <arjanb> ++ adds lists together
11:14:23 <shapr> recursion means it calls itself
11:14:38 <shapr> myLength (x:xs) = 1 + myLength xs
11:14:41 <Mike121> concatenation operator cant be the recursion part 
11:14:48 <Mike121> where is recursion ?
11:14:56 <tuomov> recursion is simply that qsort calls itself
11:15:12 <Mike121> where does it call itself ?
11:15:22 <Mike121> in c u would call it by name 
11:15:22 <musasabi> Is there any good example of a real program using arrows with the current GHC syntax?
11:15:35 <tuomov> there, in the definition
11:15:44 <shapr> musasabi: there are the arrowex{1,2,3,4}.hs in the testsuite.
11:15:56 <Mike121> recursion() (recursiol()}
11:16:16 <shapr> musasabi: and there's the -farrows docs in the GHC user guide, which show you useful stuff like form being replaced with banana brackets.
11:16:20 <Lemmih> Mike121: It's the same in Haskell.
11:16:51 <Mike121> how very stupid of me
11:17:01 <Mike121> tnx Lemmih and eveyone else 
11:17:21 <Mike121> whatever is on the RHS is part of the expressien
11:18:00 <Mike121> tnx again and sorry for the trouble
11:18:18 <shapr> Mike121: we're happy to help people who want to learn.
11:18:31 <shapr> It took me awhile to get my head around Haskell also.
11:18:36 <shapr> But I am very happy I did it.
11:19:30 <shapr> Mike121: the cool trick you learn in Haskell can also be applied to imperative languages.
11:19:35 <shapr> er "cool tricks"
11:20:02 <Mike121> i am not giving up on this one even it it takes the rest of my natural life 
11:20:06 <shapr> heh
11:20:12 <shapr> good attitude =)
11:20:16 <tuomov> lua was a nice gateway drug to fp for me.. :)
11:20:23 <shapr> hehe
11:20:27 <shapr> the first lambda is free man....
11:20:30 * shapr tokes on a lambda
11:20:50 <tuomov> a language without higher order functions etc. feels so crippled now
11:21:05 <shapr> musasabi: also, you may want to grab Paterson's arrow transformers lib, it's pretty useful.
11:21:25 <shapr> I think the lib will be standard in 6.4
11:21:28 <musasabi> shapr: thanks, I'll look those up.
11:22:07 <shapr> musasabi: and, I've been trying to hack up a 'real' interpreter from arrowex4.hs so I can help you if you have trouble reading that one.
11:23:09 <shapr> btw, I asked Ross Paterson for examples of 'real' arrow usage in a recent email and he only mentioned those same examples.
11:23:48 <bourbaki> shapr: which examples?
11:23:52 <shapr> Yampa uses arrows, maybe it has some nice idioms? I haven't looked at the source of Yampa much, but I did get Yampa Space Invaders to compile with ghc-cvs in Debian.
11:24:11 <shapr> bourbaki: arrowex{1..4}.hs you want me to put them online?
11:24:20 <bourbaki> sure
11:24:20 <shapr> they're part of the GHC tests
11:25:07 <bourbaki> i encountered some bad problems with my rewrite :( with lists i think it wont work at all that way
11:25:37 <shapr> random zsh question, I'd like to do cd `dirname `locate arrowex2.hs`` but I can't nest backticks, how do I do that?
11:26:06 * desrt pokes shapr with a chopstick
11:26:09 <mflux> use $() instead of ``
11:26:25 <shapr> ah, thanks
11:27:29 <Igloo> You can nest them with \
11:27:43 <musasabi> mainly I am thinking of using arrows to model communication protocolls
11:28:00 <shapr> musasabi: I think that's a good idea also.
11:28:29 <shapr> I thought about dll >>> ip >>> tcp but I couldn't quite figure it out.
11:29:07 <shapr> bourbaki: http://www.scannedinavian.org/~shae/ has arrowex{1..4}.hs
11:29:22 <bourbaki> thx
11:29:57 <shapr> mflux: gotten started with Haskell?
11:30:47 <mflux> not really
11:30:50 <shapr> Lemmih: are you using HSQL-1.4 ?
11:31:08 <shapr> mflux: ok, just wondering if you had any questions or insights
11:31:09 <mflux> I have read some material though
11:31:20 <shapr> hej DrX
11:31:25 <Lemmih> shapr: Yes.
11:31:37 <DrX> hi
11:31:42 <Lemmih> Hey DrX
11:31:46 <bourbaki> shapr: is there any way in arrows to deal with that nested pairs and functions? ie if i want to map + on the pairs?
11:31:46 <shapr> the swedes are waking up
11:31:57 <DrX> :)
11:32:07 <shapr> bourbaki: eh?
11:32:21 <bourbaki> shapr: sec ill post the code
11:32:28 <shapr> ok
11:32:52 <bourbaki> shapr: http://paste.phpfi.com/33665
11:33:20 <shapr> Lemmih: and 0.9 of HDB?
11:33:47 <bourbaki> shapr: the last line is the output of a single layered neural net but the output need to be summed up somehow at best in a recursive way so i dont have to write a fn each time
11:33:51 <Lemmih> shapr: 0.8 actually.
11:34:48 <bourbaki> shapr: and nested pairs just would need a binary operator in front of them to sum them up i just need a way to determine the last element and i wonder how it was thought to be done in arrows
11:35:23 <shapr> Lemmih: I'll try 0.9
11:36:30 <shapr> I think there is a nested pairs op..
11:39:19 <bourbaki> what i am looking for is something like reduce in lisp for nested pairs
11:39:32 <shapr> bourbaki: what about app in ArrowApply?
11:39:55 <musasabi> Why are the various packages distributed with GHC not a part of the documentation?
11:40:28 <shapr> musasabi: which packages? the -package stuff? CosmicRay has the same question, and a solution.
11:40:51 <shapr> musasabi: http://www.complete.org/fs/hclr/
11:41:18 <bourbaki> shapr: how would that allow me to implement a sum of elements of a nested pair?
11:41:44 <shapr> bourbaki: I'm not sure yet, I may be wrong. Still trying to work out the code.
11:42:18 <bourbaki> shapr: the output looks like this ((((11.0,21.0),31.0),((21.0,22.0),23.0)),((31.0,32.0),33.0))
11:42:55 <bourbaki> shapr: what i now want to do like in a usual neural network is to sum up the first 3 values and the next and so on
11:45:11 <musasabi> shapr: that lacks at least -package data and the arrow stuff.
11:46:36 <musasabi> and data contains lots of usefull stuff.
11:51:07 <shapr> bourbaki: I'm not really sure...
11:51:19 <bourbaki> shapr: but you see my prob?
11:51:40 <bourbaki> shapr: thats why i wanted to rewrite it with lists but that wont work i think
11:53:40 <shapr> maybe "uncurry . uncurry . \x y z -> x + y + z" ?
11:54:08 <bourbaki> shapr: yes but it needs to work for arbitrary many nests
11:54:33 * shapr thinks
11:57:07 <bourbaki> shapr: i cant tag the least element with first or second either cause i cant check if its a single element or a tuple ...
12:00:20 <Lemmih> shapr: I'm using HDB 0.9 now.
12:00:24 <shapr> ok
12:03:34 <shapr> isn't there an iterateUntil or something?
12:03:56 <bourbaki> shapr: in arrow?
12:04:06 <Lemmih> Nope.
12:05:03 <Lemmih> (Assuming you asked me about halipeto)
12:05:21 <Lor> Ah, the hug-beast.
12:07:19 <shapr> bourbaki: I know there's some really simple solution to this, but it's not coming to me right now.
12:09:49 <bourbaki> shapr: if you come up with it will you tell me?
12:09:55 <shapr> yes!
12:10:05 <bourbaki> id be really glad cause my brain throws knots atm :)
12:10:08 <bourbaki> thanks :)
12:14:36 <shapr> how does reduce stop?
12:14:52 <bourbaki> well in lisp you can test if something is an atom
12:15:08 <bourbaki> but lists are something entirely different in lisp
12:15:14 <Mike121> whats atom ?
12:15:23 <Mike121> u mean the physical atom ?
12:15:32 <bourbaki> in lisp an atom is something that is not a list
12:15:45 <bourbaki> atom means translated non splitable
12:16:01 <bourbaki> its considered the basice "block" of anything
12:16:34 <Mike121> whats the basic block in haskell its higher order functions ?
12:17:02 <bourbaki> Mike121: dont mind what i say :) cause it didnt have to do anything with haskell but with lisp
12:18:09 <Lor> "the Lord could not count grains of sand with a 32-bit word"...
12:18:20 <kristnjov> hehe
12:19:02 <Lor> I was just reminded of this when thinking of the term "atom" in lisp... as if you constructed a universe out of them.
12:19:19 <bourbaki> you kind of do
12:19:21 <kristnjov> lisp is a weird language
12:19:46 <Lor> "the Lord made sure, when each sparrow falls, that its flesh will be reclaimed"
12:19:48 <bourbaki> kristnjov: why?
12:19:49 <Lor> Great song.
12:19:57 <kristnjov> bourbaki, because it just is.
12:20:15 <bourbaki> Lor: do you know the song "god wrote the world in lisp" ;)?
12:20:25 <Lor> What do you think I was quoting?
12:20:33 <bourbaki> Lor: ah heh ok :)
12:20:44 <bourbaki> kristnjov: i like the haskell syntax
12:20:48 <bourbaki> er
12:20:49 <bourbaki> lisp
12:20:51 <kristnjov> heh
12:20:57 <bourbaki> haskell also though :)
12:21:01 <kristnjov> haskell is pretty
12:21:06 <kristnjov> lisp is more like hitler-ish
12:21:16 <bourbaki> o.O and why is that?
12:21:28 <kristnjov> because if you look at it for a while and relax your eyes you can see swastikas
12:21:39 <kristnjov> ..or perhaps that's just my fucked up mind :P
12:21:57 <bourbaki> ... *cough cough*
12:22:06 <kristnjov> :)
12:22:11 <bourbaki> heh
12:22:34 <shapr> kristnjov: you're scary sometimes.
12:22:40 <kristnjov> boogieman
12:29:11 <yohan> haha
12:29:24 <yohan> but kristnjov you're from somalia, i dont understand
12:29:36 <kristnjov> pardon?
12:29:46 <yohan> yeah, your the afro guy at chalmers right?
12:29:52 <yohan> the guy who likes manga
12:30:04 <yohan> dont be ashamed of your skin man
12:30:09 <kristnjov> well, no... no, not really.
12:30:21 <kristnjov> and why would i feel ashamed for being who i am?
12:30:24 <yohan> i know you are, you're in my friends lab-group dude
12:30:34 <yohan> i dunno, you seem very nazi
12:30:59 <yohan> you know its so ironic, that midget guy took a pic of ur afro and thought it was funny
12:31:20 <kristnjov> dude, who are you?
12:31:20 <yohan> sÂ stˆrd, assÂ vÂga va med och ta kort pÂ han n‰sta gÂng
12:31:22 <yohan> haha fan va ‰gd
12:31:31 <kristnjov> ah, you study at chalmers?
12:31:33 <yohan> sÂ ser han det typ
12:31:35 <yohan> yes i do guy
12:31:47 <yohan> quit playing around niqqa
12:31:48 <yohan> :x
12:31:56 <kristnjov> i'd doubt we're in the same lab group though, you seem to think i'm of dark skin
12:57:10 <shapr> y0 SyntaxNinja 
12:58:41 <SyntaxNinja> hiya
12:58:52 <shapr> back on the ranch...
12:58:59 <shapr> the natives were getting restless.
12:59:05 * shapr beats the drums
12:59:05 <kosmikus> who's yohan to offend people on this channel?
12:59:27 <shapr> well, yohan and kristnjov are both chalmers students it seems.
12:59:50 <kosmikus> was it only a joke?
12:59:54 * shapr hopes so
13:00:00 <kristnjov> that doesn't give him any right to talk bad about people because of the tone of their skin
13:00:09 <yohan> yeah we are
13:00:23 <kristnjov> yohan, whatever you think, i don't know who you are, alright?
13:00:26 <yohan> what? your the nazi one!
13:00:28 <shapr> I think talk of nazis and skin color is bound to make you unpopular around here.
13:00:30 <kristnjov> don't know any johan at chalmers
13:00:35 <yohan> haha
13:00:38 <shapr> guys, drop it.
13:00:43 <yohan> sure.
13:01:26 <shapr> anyway... back at the ranch...
13:01:50 <yohan> whats up shapr?
13:01:59 <shapr> yohan: libraries!
13:01:59 <ron_> hey i heard someone wanted me something
13:02:01 <shapr> nearly...
13:02:04 <ron_> yohan?
13:02:09 <shapr> ron_: you want to learn Haskell?
13:02:11 <ron_> you're talking bad about me?
13:02:18 <shapr> ahem, guys
13:02:24 <shapr> ron_: dude, leave it alone
13:02:32 <shapr> or at least, take it away from #haskell
13:02:34 <ron_> alright... he seems harmless anyways.
13:02:35 <bourbaki> sometimes this channel is like a soap opera
13:02:48 <kristnjov> heh
13:02:50 <kristnjov> what was that?
13:03:02 <shapr> kristnjov: that was the end of the discussions of nazis and skin color.
13:03:05 <Lemmih> Those chalmers are indeed combatant.
13:03:09 <yohan> what?
13:03:10 <kristnjov> i see.
13:03:15 <shapr> Godwin's Law applies here
13:03:18 <yohan> what the hell, who was that
13:03:34 <bourbaki> shapr: godwin?
13:03:54 <shapr> http://en.wikipedia.org/wiki/Godwin's_law
13:04:02 <SyntaxNinja> hehe
13:04:52 <bourbaki> heh
13:07:41 <bourbaki> Reductio ad Hitlerum hahaha oh man the internet is always a vault of freaky thinks wikipedia doubly so
13:21:33 <shapr> so, anyone here have an opinion on using ATerm + more of MetaEnvironment for hemacs?
13:21:59 <bourbaki> shapr: i think i found a solution to my problem
13:22:04 <shapr> cool, what was it?
13:22:08 <kosmikus> what do you want ATerms for?
13:22:17 <bourbaki> shapr: but that would at least need me to keep track of the arity
13:22:31 <bourbaki> shapr: (erup ( ((pure (weight 1)) +++ (pure (weight 2)) +++ (pure (weight 3)) +++ (pure (weight 4))) >>> (first (first (pure plus))) >>> (first (pure plus)) >>> (pure plus))) (((1,1),1),1)
13:22:53 <bourbaki> plus :: (Float,Float) -> Float
13:23:09 * emu can't wait til the ++++++ operator
13:23:10 <bourbaki> its not really nice though :( and its still not recursive
13:23:16 <shapr> I'd like to have an incremental parser (or just a really fast parser?) as a central tool in hemacs
13:23:34 <bourbaki> emu: do you want one ;)?
13:23:39 <shapr> I don't want to use regexes for syntax highlighting, etc
13:23:50 <emu> super-mega-add
13:24:04 <bourbaki> emu: thats not my notation though :)
13:24:32 <kosmikus> incremental parser would be nice
13:24:58 <kosmikus> question is, do you want to hardwire that, or will it all be a matter of writing the right plugins?
13:25:01 <shapr> I wonder if much of MetaEnv could be ripped for a headstart.
13:25:11 <emu> error-recovering incremental parser
13:25:13 <Igloo> I like the idea of generating it from BNF
13:25:23 <shapr> I was wondering about SDF
13:25:52 <shapr> MetaEnvironment - http://www.cwi.nl/projects/MetaEnv/
13:26:12 <shapr> SDF - Syntax Definition Formalism
13:26:49 <shapr> iirc, you can generate parsers from SDF
13:27:10 <shapr> http://www.cwi.nl/themes/sen1/sdf2-demo/index.html
13:27:15 <kosmikus> yes, you can
13:27:52 <shapr> I doubt it generates incremental parsers...
13:28:20 <kosmikus> I have to admit that I never really looked into incremental parsing
13:28:32 <kosmikus> all I have is a certain amount of intuition of how it should work
13:28:46 <kosmikus> is there anything usable on this subject that exists?
13:28:56 <shapr> one advantage of using ATerm for parse trees is that ATerm haskell libraries already exist.
13:29:34 <kosmikus> ATerms are mainly a data exchange format
13:29:51 <kosmikus> do you want/need to serialize parse trees in hemacs?
13:30:02 * shapr has no idea
13:30:45 <kosmikus> let me ask more fundamental, annoying questions as someone who has still not looked at the code ... ;)
13:30:49 <kosmikus> how does hemacs work?
13:31:04 <shapr> not at all at the moment :-)
13:31:18 <shapr> the buffer part is still in-progress
13:31:22 <kosmikus> I mean, what's between the byte in the file on disk and the character on screen?
13:31:38 <shapr> strings get displayed...
13:32:33 <kosmikus> how do different plugins interact?
13:32:46 <tuomov> via dependencies?
13:34:10 * shapr looks at tuomov
13:36:57 <shapr> hiya Philippa 
13:37:05 <shapr> kosmikus: via hs-plugins?
13:37:16 <shapr> or do you mean what sort of data do they operate on, or what?
13:37:22 <kosmikus> yes, the latter
13:37:25 <Russell-> join #gnu
13:37:30 <shapr> Russell-: no!
13:37:36 <Russell-> join #gnuops
13:37:46 <shapr> Russell-: are you missing a slash there?
13:38:31 * shapr wonders if there's enough interaction among plugins to give an answer
13:38:41 <Russell-> yes :D
13:39:46 <kosmikus> well, isn't the philosophy of hemacs that nearly everything is a plugin
13:39:47 <kosmikus> ?
13:40:00 <shapr> sure, yeah
13:40:13 <kosmikus> then there will be a lot of interaction between plugins, I guess
13:40:23 <tuomov> but the plugins could just as well be statically linked
13:40:33 <kosmikus> and I guess my question is: what is the core functionality that remains?
13:40:56 <kosmikus> what's the "model"? ;)
13:41:01 <tuomov> some basic startup routines and generic buffer stuff?
13:41:07 <tuomov> I guess curses UI should also be a module?
13:41:16 <tuomov> s/module/plugin/
13:41:46 <shapr> yah
13:41:50 <tuomov> although, in a sense, the whole program itself is a plugin
13:41:58 <shapr> right, there is no core. not really.
13:42:05 <shapr> that's why hs-plugins is so appealing.
13:42:31 <shapr> but there must be a core of some type, or you can't edit.
13:42:33 <kosmikus> well, regardless of what your system allows you to do
13:42:40 <kosmikus> you have to specify a certain core
13:42:53 <shapr> right,what's the editor core that is 'supported' by the developers
13:43:03 <kosmikus> otherwise the sheer amount of flexibility will distract you, to put it mildly
13:43:17 <tuomov> the editor core is the module that exports the buffer api
13:44:03 <kosmikus> that's all?
13:44:17 <tuomov> on the other side of that api we have ui plugins (curses initially, I suppose), and on the other side file format plugins
13:44:46 <shapr> I'd say the parser generator should be part of the core?
13:44:48 <tuomov> or that's how I would suppose things to work out
13:44:51 <shapr> syntax highlighting is a buffer plugin
13:44:55 <kosmikus> interesting is indeed the stuff that's in the middle, like file format/syntax highlighting stuff
13:44:57 * shapr pokes dons 
13:44:59 <shapr> dons: wake up!
13:45:19 <kosmikus> how do you make sure that if I write a cool parser/syntax highlighter, it will work with all UI plugins?
13:45:44 <tuomov> it should be part of the buffer api
13:45:52 <shapr> make them all Tree -> Tree transforsm?
13:46:27 <shapr> and I'd say a UI plugin should work only on views
13:46:29 <shapr> whatever that means :-)
13:47:12 <tuomov> e.g. as here http://article.gmane.org/gmane.editors.post-emacs/22
13:47:43 <tuomov> (although I'm not at all sure typeclasses will work)
13:47:43 <kosmikus> the "Tree -> Tree" thing is in the direction of what I wanted to hear, although that won't be enough
13:48:12 <shapr> I think a buffer is just a text string at the very bottom
13:48:26 <shapr> but plugins should only work on the bottom-most Tree, never on the text itself
13:48:49 <tuomov> at the bottom you have a simple plaintext Buffer
13:48:53 <kosmikus> hmm
13:49:00 <shapr> I think the core should have the freedom to reimplement the underlying buffer with ropes, zipper, or whatever.
13:49:00 <tuomov> then you apply a buffer transformation to it
13:49:20 <monochrom> Haha buffer transformation
13:49:30 <kosmikus> I basically see that you're aware of the problem, but haven't solved it
13:49:43 <Cale> there should definitely be some sort of class abstraction of the buffer
13:50:03 <shapr> kosmikus: which problem?
13:50:08 <tuomov> definitely, but I'm not sure if it will work out because of limitations of haskell's type system
13:50:25 <kosmikus> you might need to consider dynamic types
13:50:28 <tuomov> but I'm n00b, maybe someone else has a solution
13:50:38 <tuomov> dynamics don't work with typeclasses
13:50:44 * shapr is nearly a n00b t00
13:51:14 <kosmikus> not sure I consider that a disadvantage ;)
13:51:45 <bourbaki> afaik beeing a noob and not so strict about things is often an advantage
13:51:57 <Mike122> yeah ... 
13:52:11 <bourbaki> at least according to simon sighs fermats last theorem
13:52:13 <Mike122> its horrible being a c programmer ...
13:52:53 <Mike122> and trying to piece togather haskell
13:52:56 <bourbaki> whats wrong with c?
13:53:09 <bourbaki> i dont think there is anything wrong with any language
13:53:16 <bourbaki> beside java of course ;)
13:53:24 <tuomov> hmm.. not languages really.. but many standards libs are horrible
13:53:29 <kosmikus> just to make this clear ... I don't want to sound un-constructive, I have been thinking about doing an editor before, and I wasn't able to come up with a good representation of editor plugins in Haskell's typesystem -- therefore, I am interested how you do it ...
13:53:41 <tuomov> c++, java, c#, etc. awful bloat and abuse of language features esp. in case of c++
13:53:53 <Mike122> well noting wrong but learning haskell is hampered by the previous knowledge ...
13:53:55 <tuomov> (and python too..)
13:54:12 <tuomov> (I don't like + being used for concat and the special % printf syntax)
13:54:31 <shapr> kosmikus: what do you think about Tree -> Tree transforms? too limiting?
13:54:41 <bourbaki> what i dont really like in languages like c/c++ is that you have to type a lot of stuff not realated to the problem directly
13:55:06 <bourbaki> tuomov: and if you dont like the printf syntax have a look at lisps format :)
13:56:21 <kosmikus> shapr: depends on what Tree is, but I cannot imagine a fixed datatype to be adequate there, except if you want to make everything essentially untyped again
13:56:33 <kosmikus> furthermore, you probably need at least Tree -> IO Tree
13:56:35 <tuomov> no, not fixed
13:57:30 <shapr> what sort of Trees have you thought about?
13:57:59 <tuomov> at the base you have a PlainTextBuffer
13:58:09 <tuomov> to this you have apply e.g. HaskellLangBuffer
13:58:17 <tuomov> all instances of Buffer
13:58:24 <tuomov> to this you could still apply FoldedBuffer
13:58:46 <tuomov> but I'm afraid that at some point one will run into problems with the limitations of the typeclass system
13:59:01 <tuomov> s/have/can/
13:59:38 <kosmikus> I can understand what you mean
14:00:15 <kosmikus> what's a FoldedBuffer?
14:00:20 <shapr> is there a better way? something other than typeclasses?
14:00:32 <tuomov> support for hiding parts of the buffer
14:00:37 <shapr> should I ask this on haskell-cafe@haskell.org ?
14:00:59 <tuomov> either by special markers ({{{ between these in jed }}}) or by hiding whole functions in structural buffers
14:01:04 <shapr> kosmikus: why won't  a fixed datatype be adequate? can you give me some examples?
14:01:11 <kosmikus> I'm not sure there will be a problem with typeclasses if you do it right
14:01:45 <kosmikus> I have to think for a few minutes ...
14:01:45 <tuomov> I haven't thought about the potential typeclass problem any further really
14:02:06 <tuomov> perhaps alternatively one could have a data of buffer functions and so on
14:02:23 <tuomov> or maybe simply isolating each buffer in a thread might solve the problem
14:02:33 <shapr> ?
14:02:55 <tuomov> We can't have a list of all buffers with different features
14:03:11 <tuomov> at least not easily
14:03:19 <shapr> I don't understand.
14:03:21 <tuomov> existentials might or might not solve the problem
14:03:58 <kosmikus> too fast for me
14:04:05 <tuomov> Can't have a list [plaintextbuffer, haskellbuffer]
14:04:14 <shapr> ah
14:04:24 <shapr> HList could do that
14:04:30 <tuomov> doesn't work with typeclasses
14:04:32 <kosmikus> oh no, don't start using that
14:04:39 <shapr> no HList? :-)
14:04:54 <shapr> anyway....
14:05:13 <kosmikus> why would you want a list of different buffers, anyway?
14:05:27 <tuomov> how else do you keep track of them?
14:05:33 <shapr> I was thinking about starting with basic Tree -> Tree combinators like 'hide a node' 
14:05:37 <tuomov> thread for each?
14:05:47 <tuomov> (although I haven't looked in more detail if that will work out either)
14:05:51 <kosmikus> well, in the end you want all of them to be UI-buffers of a specific sort, or not?
14:06:11 <tuomov> but you can't hide what's under it
14:06:31 <kosmikus> why not?
14:06:49 <tuomov> not to my knowledge. but then again, I'm n00b.
14:07:15 <tuomov> with existentials, perhaps, but I'm that brings some other limitations to accessing them
14:07:21 <tuomov> +sure
14:07:49 <Mike122> if i want a geometir progression in lists is there a shortcut ?
14:08:15 <kosmikus> [plainToUI plaintextbuffer, haskellToUI (formatHaskell anotherplaintextbuffer)]
14:08:16 <Mike122>  /s /geometir /geometric 
14:08:19 <monochrom> @info iterate
14:08:21 <lambdabot> -- iterate is a variable
14:08:21 <lambdabot> iterate :: forall a. (a -> a) -> a -> [a]
14:08:42 <monochrom> Mike122: something like iterate (* 5) 1 ?
14:08:59 <monochrom> that would give you [1, 1*5, 1*5*5, 1*5*5*5, ...]
14:09:35 <tuomov> kosmikus: that's some existential trick, or?
14:09:42 <Mike122> 1 3 6 is an arithmatic progression 
14:09:42 <Mike122> 1 3 9 is a gp 
14:09:53 <kosmikus> tuomov: could be done with existentials, but could be done with explicit types as well
14:10:19 <tuomov> how else can you hide that the output type depends on input type?
14:10:45 <kosmikus> the output type of what depends on the input type?
14:11:13 <tuomov> how do you create some UIBuffer that refers to FooBarBuffer without it being a parameter of UIBuffer?
14:11:16 <monochrom> iterate (* 3) 1  ---> [1, 3, 9, 27, ...]
14:11:35 <Mike122> tnx monochrom i think that would solve the problem 
14:11:59 <kosmikus> tuomov: by having a function to turn a FooBarBuffer into an UIBuffer
14:12:26 <shapr> so you have a list of UIBuffer
14:12:36 <kosmikus> yes
14:12:46 <tuomov> how can you turn it so?
14:12:52 <Mike122> [1,3,9..100] would have been easier though :) if it exists 
14:13:12 <shapr> Mike122: I think that only works with static offsets
14:13:23 <kosmikus> tuomov: I don't understand
14:13:56 <shapr> tuomov: have a list of View buffers, not a list of the underlying buffer
14:13:57 <tuomov> data UIBuffer = UIBuffer{ base_buffer :: Buffer a???? }
14:14:26 <kosmikus> no, the UIBuffer does not have a reference to the base_buffer
14:14:39 <tuomov> how can it do anything at all then?
14:14:50 <Philippa> 'course, now you just have to deal with the list of FooBuffers and BarBuffers
14:14:50 <kosmikus> UIBuffer has an *interface* that is sufficient to handle the input events and display stuff on screen
14:15:06 <kosmikus> how you implement the interface, you describe by functions ...
14:15:27 <tuomov> the type of the buffer is in the signatures of those functions..
14:15:45 <kosmikus> for example, it's probably quite easy to display a simple text buffer without any fancy stuff
14:15:58 <kosmikus> so you'd have function  textToUI :: TextBuffer -> UIBuffer
14:16:20 <Mike122> ok tnx shapr 
14:16:27 <Philippa> so where does textToUI get called?
14:16:47 <kosmikus> the user calls it, explicitly or implicitly
14:17:18 <tuomov> hmm.. you could store all the necessary functions in the UIBuffer..
14:17:28 <tuomov> but it gets a bit kludgy and bloated
14:17:57 <kosmikus> well, in the end you might use type classes again; but the idea isn't really much different
14:18:09 <kosmikus> type classes provide a way of infering some of the conversions automatically
14:18:10 <Philippa> in the end you're going to have to use type classes again
14:18:18 <kosmikus> they don't change much about the underlying model
14:18:18 <Philippa> somewhere you're going to need a list of all the (non-UI) buffers
14:18:56 <kosmikus> I still think that dynamic types might be a viable alternative
14:19:14 <tuomov> also, it would probably be better to store the list of transformations to the base buffer instead of having them store reference to each other..
14:19:52 <kosmikus> my idea is not to store references
14:20:07 <Boegel> hello everyone :)
14:20:22 <Boegel> I managed to install Fedora on my laptop
14:20:26 <Boegel> and I'm just loving it :)
14:21:38 <shapr> hoi Boegel!
14:21:46 <SyntaxNinja> boegel: new Linux user or just new fedora user? I found FC1 to be a huge PITA when it came to networking; I'll stick to Debian :)
14:21:48 <shapr> tuomov: yes, buffer arrows!
14:22:31 <shapr> at least that sounds sane to me
14:22:31 <kosmikus> the nice thing, as I see it, is that you really can execute typed Haskell functions at runtime in hemacs
14:22:44 <tuomov> but one needs to carefully think how to implement these transformations to minimise reparsing of structure
14:23:00 <shapr> arrows are good at being efficient
14:23:02 <kosmikus> tuomov: I agree
14:23:34 <Boegel> SyntaxNinja, not really new, I've tried Mandrake and Red Hat before (2 years ago or so)
14:23:40 <tuomov> But I think some sort of transformations are the way to go
14:23:41 <Boegel> but I never really stuck to it
14:23:48 <kosmikus> shapr: is that a slogan, or do you have real evidence?
14:23:50 <tuomov> All sorts of charset decodings can also be implemented so
14:23:55 <shapr> kosmikus: real evidence
14:24:10 <kosmikus> shapr: ok, what?
14:24:31 <shapr> have you read the arrows paper?
14:24:31 <Boegel> so now i have Mandrake 9.1 (yes i know, old version) on my desktop and Fedora Core 3 Test 2 on my laptop
14:24:31 <kosmikus> tuomov: yes, I was thinking about decodings; that should be relatively trivial
14:24:44 <Boegel> and I have to say, linux has improved A LOT since my last try
14:24:45 <SyntaxNinja> Boegel: cool. I've been using nothing but Linux for a while now.
14:24:49 <Boegel> especially Fedora
14:24:50 <kosmikus> shapr: which one? but I think I can safely answer yes
14:24:51 <SyntaxNinja> yeah
14:25:07 <shapr> well, hughes Generalizing and paterson's FoP
14:25:16 <Boegel> SyntaxNinja, I hope I can get my digital camera, iPod and such stuff working on linux
14:25:16 <kosmikus> yes
14:25:27 <Boegel> then I see no reason to go back to windows...
14:25:28 <shapr> I think Yampa has proven that arrows can do stuff that monads can't, and be efficient about it.
14:25:46 <kosmikus> I'm not convinced
14:26:05 <shapr> what reactions or criticism or thoughts against?
14:26:07 <tuomov> plaintext >>> decode "utf-8" >>> parse_haskell >>> hide_details
14:26:14 <Boegel> I should go to sleep actually, but i'm too exctied :p
14:26:26 <kosmikus> tuomov: something like that, yes
14:26:43 <kosmikus> shapr: well, if the editor is a nice application of arrows, I'm all for it
14:27:03 <kosmikus> but I wouldn't try to force it into arrows just because of a vague feeling that it might be more efficient
14:27:08 <shapr> good point
14:27:19 <kosmikus> if ordinary functions, or monadic functions can do, why not just those?
14:27:24 <shapr> yes, I agree.
14:28:28 <shapr> tuomov: btw, I upgraded to ion3 yesterday... it feels faster than ion2
14:28:55 <Lor> What's new in ion3?
14:28:56 <SyntaxNinja> Boegel: I have both working :)
14:28:59 <Lor> Again a new configuration language?
14:29:08 <Boegel> iPod too ?
14:29:11 <SyntaxNinja> Boegel: actually, configuring them is almost identical, at least for me, since they're both mass-storage USB devices.
14:29:12 <tuomov> now, but the use lua has been simplified a little
14:29:13 <SyntaxNinja> Boegel: yeah
14:29:15 <tuomov> -w
14:29:26 <Boegel> do you have iTunes too for it ?
14:29:41 <SyntaxNinja> Boegel: but the funny thing is that they have different mount points depending on which one I load first :(
14:29:57 <shapr> kosmikus: do you have points against the arguments given in the various arrows paper?
14:30:09 <SyntaxNinja> Boegel: gtkpod is the software I use for installing mp3s onto it; I don't install any shackled music that apples sells on iTunes, if htat's hwat you mean :)
14:30:24 <SyntaxNinja> Boegel: btw, you have to format the ipod for windows before Linux can usefully access it
14:30:30 <Boegel> no, but I like iTunes
14:30:33 <tuomov> in addition to that, it supports an embedded adaptive dock/statusbar, has a "scratchpad" module, session management module, one additional workspace module (not sure if it will be very useful yet)
14:30:42 <Boegel> format it ? :(
14:30:43 <shapr> It seems to me that a monadic parser is obviously less efficient in both space and time than an arrow-style parser, if only because the arrow-style parser can release input earlier, and skip a lot of function calls.
14:30:51 <tuomov> scratchpad is like a console in fps games..
14:30:54 <SyntaxNinja> Boegel: have you been using it on a mac? or on a windows machine?
14:30:59 <Boegel> windows
14:31:02 <SyntaxNinja> then you're fine
14:31:06 <shapr> ohh, time to read ion3 docs...
14:31:08 <Boegel> ow okay then :)
14:31:12 <tuomov> and some other minor improvements
14:31:28 <Boegel> is there an iTunes client for linux ? because I like how it works
14:31:40 <Boegel> but I don't use the iTunes store or radio channels
14:31:56 <SyntaxNinja> they come standard with HFS+ as a filesystem, but Linux isn't very good with that one, but it can use Fat32, which is what windows uses.
14:32:08 * SyntaxNinja takes this offilne...
14:32:26 * Igloo starts to think about syntax highlighting and hmms
14:32:33 <Boegel> SyntaxNinja,  HFS+ ?
14:32:49 <Boegel> ow shapr , sorry for changing the topic :s
14:33:03 * shapr doesn't mind
14:33:10 <shapr> I'm reading the Yampa paper for inspiration.
14:33:37 <tuomov> some sort of event passing system from the bottom up might work..
14:33:59 <tuomov> there would be another encoding filter between ui and the base plaintext buffer
14:34:14 <tuomov> it would then send a message upwards that a new character has been entered in this position
14:35:09 <tuomov> or maybe you could have the sort of arrows where it would work from top to bottom as well?
14:35:24 <shapr> I hope so
14:35:53 <kosmikus> Igloo: hmms?
14:36:26 <shapr> a file becomes a buffer in-memory, a buffer is tranformed into a view, and the user interacts with the model behind the view?
14:37:50 <shapr> well, yeah, MVC - http://c2.com/cgi/wiki?ModelViewController
14:37:54 <Igloo> It's fiddlier than I first thought. But I think if you give it a stream and tell it where to stop rather than doing it Charwise it'll all work out
14:39:21 <kosmikus> ok, I'm convinced
14:39:30 <kosmikus> where can I subscribe to the mailing list?
14:39:32 <shapr> kosmikus: eh?
14:39:33 <shapr> oh
14:39:43 <shapr> http://lists.scannedinavian.org/cgi-bin/mailman/listinfo/post-emacs
14:40:32 <kosmikus> ok
14:43:45 * shapr searches through the yampa papers
14:46:57 <Lor> shapr, where are the archives?
14:47:49 <shapr> they'll be up once the list is a month old... in the meantime, there's http://article.gmane.org/gmane.editors.post-emacs/
14:48:23 * shapr notices that url shows nothing
14:48:43 <shapr> http://news.gmane.org/gmane.editors.post-emacs/cutoff=26
14:49:12 <shapr> hej andersca
14:49:40 <andersca> hej
14:54:14 <shapr> kosmikus: check out the pSwitch combinator on p.55 of http://www.haskell.org/yale/papers/haskellworkshop02/workshop-02.ps.gz
14:55:04 <shapr> (it's actually the fifth page of that paper, must be numbered according to how it was in the journal)
14:55:57 <kosmikus> shapr: ?
15:00:30 <shapr> buffer as collection of signal functions?
15:00:43 <dons> moin
15:00:50 <shapr> y0 y0 dons!
15:02:07 * dons got some efficient buffer inspiration from reading GHC.IOBase ;)
15:02:33 <shapr> man, I want to get Ross Paterson and John Hughes to show up here and talk about arrows some time :-/
15:05:17 <kosmikus> just turn EuroHaskell into a regular and growing event, and sooner or later people will show up or accept invitations
15:05:33 <shapr> sounds good to me.
15:05:46 <shapr> I hope Luke and Ulf both show up with unicycles.
15:06:51 <kolmodin> I saw that Hughes tried the unicycle :)
15:07:12 <shapr> yah, I was mightily impressed.
15:07:24 <shapr> he actually did extremely well for never having tried it before.
15:08:00 <kosmikus> I should really try to make it next year
15:08:03 <kosmikus> when was it again
15:08:06 <shapr> um
15:08:10 <shapr> @eurohaskell
15:08:10 <lambdabot> less talks, more code!
15:08:10 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
15:08:10 <lambdabot> EuroHaskell - Haskell Hackfest - June 10-12 - Gothenburg, Sweden
15:08:29 <shapr> hey, the libraries page prototype is up
15:08:34 <kosmikus> is this the old or the new announcement? ;)
15:08:44 <shapr> http://www.scannedinavian.org/cgi-bin/web/webbih
15:08:52 <shapr> that's the old announcement
15:09:08 <shapr> just putting in the logo and the correct .css file right now.
15:10:30 <shapr> it won't take just any old cabal description, "The fields: ["Homepage","Name","Category","Description"] are required."
15:13:14 <Boegel> sleep tight everyone !
15:13:27 <shapr> g'night Boegel 
15:14:27 <Lemmih> Bye Boegel
15:14:38 <shapr> SyntaxNinja: hey, didja see the libraries page prototype?
15:14:49 <shapr> this prototype brought to you by Lemmih 
15:15:01 <SyntaxNinja> yeah
15:15:48 <kosmikus> kolmodin: hi ... you're a student at chalmers?
15:16:52 <Lemmih> I'm going to sleep now, bye.
15:17:01 <shapr> g'night Lemmih 
15:17:34 <kolmodin> kosmikus: yes
15:18:11 <kosmikus> kolmodin: nice; just taking a Haskell course, or more advanced already?
15:18:38 <kolmodin> little more advanced :)
15:19:10 <kolmodin> I will take the AFP course next period. didn't finish it last year
15:19:21 <kolmodin> due to lack of time
15:19:51 <Boegel> bye Lemmih :)
15:20:21 <kolmodin> this time I only have three courses including AFP so it should not be too hard
15:21:31 <kolmodin> kosmikus: acctually I will study four courses if you include my d3project: http://d3proj.dyndns.org:8080/
15:22:33 <shapr> greetz andyfaeglasgow
15:22:44 <andyfaeglasgow> hi shapr
15:23:08 <shapr> How's Haskell treating you?
15:23:08 <andyfaeglasgow> wot u up to?
15:23:22 <shapr> about 5 foot 10 inches
15:23:26 <shapr> what are you up to? :-)
15:23:30 <andyfaeglasgow> hehe
15:23:36 <andyfaeglasgow> just come back from work
15:24:01 <andyfaeglasgow> am idling on a few channels to get familiar wi what goes on
15:24:09 <kosmikus> kolmodin: good to see another gentoo user on #haskell, anyway
15:24:48 <andyfaeglasgow> here's another kosmikus :-)
15:24:53 <SyntaxNinja> meh gentoo
15:25:00 <SyntaxNinja> it's for rice boys!
15:25:17 <shapr> What's a rice boy?
15:25:37 <kolmodin> kosmikus: right.. you fixed ghc 6.2.2, nice work 
15:25:40 <kosmikus> anyone interested in becoming a Haskell Gentoo developer?
15:26:00 <SyntaxNinja> shapr: http://www.funroll-loops.org/
15:26:16 <kolmodin> kosmikus: I'm compiling it right now. so far so good
15:26:36 <kosmikus> kolmodin: good luck ;)
15:26:40 <SyntaxNinja> btw, I'm just kidding about gentoo users
15:28:42 <kolmodin> kosmikus: you saw that I requested an ebuild of darcs aswell?
15:28:43 <SyntaxNinja> "I don't think that Debian can really compete with Gentoo. Sure it might be           okay, but when it comes to dependencies, you probably are still going to have           to get them all on your own. Or is there something like portage in the Debian           world as well?"
15:29:07 <kolmodin> kosmikus: somehow it's assigned to Gentoo Games...(?)
15:29:30 <kolmodin> hmm
15:30:17 <kosmikus> didn't you just assign it to me?
15:30:44 <kosmikus> SyntaxNinja: who said that?
15:30:46 <kolmodin> I CC'ed it to you. I can reassign it to you
15:30:56 <kosmikus> ah, ok, let me have a look ...
15:31:44 <kolmodin> kosmikus: It's all yours now :)
15:32:08 <kosmikus> thanks
15:32:23 <kosmikus> our bug-wranglers need to be educated a bit, it seems ;)
15:32:37 <kolmodin> I would like the latest darcs since I stepped over a bug and cant pull hemacs correctly
15:32:40 <kolmodin> :)
15:33:21 <SyntaxNinja> kosmikus: no clue
15:33:45 <shapr> pSwitch :: Functor col => (forall sf . (a -> col sf -> col (b, sf))) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
15:33:48 <shapr> mmm, crunchy
15:33:57 * shapr is still chewing on this one...
15:34:40 <dons> can't pull hemacs? :(
15:34:52 <kosmikus> kolmodin: copying the ebuild probably works
15:35:02 <kolmodin> Fail: bug in darcs! Rollback:  Unable to apply inverse patch!
15:35:24 <dons> ok. so that probably isn't my fault :)
15:35:33 <kolmodin> dons: no :)
15:35:37 <dons> darcs version ?
15:35:52 <kolmodin> darcs version 1.0.0rc1
15:36:18 <dons> I've tried 1.0.0r3, 0.9.23 and 0.9.20
15:37:00 <shapr> Igloo: hey, I think I just figured out that the ip >>> tcp >>> nntp arrows I had probably will work
15:37:08 <dons> btw, I think hemacs is progressing quite well. Just have to come up with the new name...
15:37:13 <kolmodin> I applied "more ui work. clean up core api", and did a rollback, then it apply it again
15:37:15 <shapr> yes :-)
15:37:30 <shapr> right, what's the new name of hemacs?
15:37:45 <kolmodin> 4DV4NC3D....? :)
15:38:11 <shapr> spoon?
15:38:20 <shapr> hi waltz 
15:38:24 <waltz> heh, hiya
15:38:32 <waltz> What is going on?
15:38:36 <tuomov> someone needs to draw an ascii U+1d321
15:38:37 <shapr> your names sounds vaguely familiar, do you know Haskell already?
15:38:48 <SyntaxNinja> I know an unrevert bug is fixed in upstream
15:39:01 <dons> $ ./hemacs-inplace README
15:39:14 <dons> in there is: U+1D321: "tetragram for change"
15:39:34 <dons> can't wait till hemacs can start editing itself
15:39:35 <kolmodin> how about: "hemacs, or: how I stopped worrying and love haskell"? :)
15:39:51 <shapr> waltz: if not, would you like the short intro?
15:40:00 <waltz> Oh, sorry, no, I don't..
15:40:12 <waltz> shapr, I'm reading about it online.
15:40:29 <shapr> waltz: do you have any questions? do you already know all the good watering holes for learning?
15:40:46 <waltz> heh, what are they?
15:41:09 <shapr> well, there's here on the #haskell channel, the various mailing lists, the haskell wiki, and especially http://www.haskell.org/learning.html
15:42:19 <waltz> :)
15:42:34 <shapr> Do you have any questions about Haskell?
15:42:36 <waltz> Do whitespaces matter in Haskell?
15:42:43 <shapr> Yes, layout is significant.
15:42:50 <dons> throwing stuff around: type RawBuffer = MutableByteArray# RealWorld
15:42:52 <waltz> i.e. if ( ) vs. if( )?
15:43:05 <shapr> waltz: here's a quick demo - http://www.haskell.org/hawiki/HaskellDemo
15:43:15 <waltz> if (1) vs. if(1) vs. if( 1 )??
15:43:32 <shapr> whitespace rarely matters in Haskell in that way.
15:43:45 <waltz> Good :)
15:44:43 <waltz> So I take it that Haskell is still fully supported?
15:44:54 <shapr> Here's some random sources to look at if you want to get a feel for the language - http://www.haskell.org/hawiki/HaskellIrcPastePage
15:45:06 <shapr> er supported? was unsupported at some point?
15:45:25 <waltz> Just wondering.
15:45:26 <shapr> Seems pretty active to me.
15:45:42 <waltz> shapr, don't take offence, I'm just browsing around.
15:45:45 <shapr> heh, ok
15:45:50 <dons> I hope it is supported -- and my commits aren't just getting sent to /dev/null..
15:46:11 <dons> maybe Haskell HQ in Cambridge doesn't really exist..
15:46:14 <shapr> if you look at our channel logs, you'll see we average quite a bit of traffic here on #haskell - http://tunes.org/~coreyr/
15:46:32 <shapr> The darcs mailing lists have a staggering amount of traffic, I can't keep up :-(
15:47:25 <bourbaki> shapr: if you come up with a solution for my nested pair prob plz tell me
15:47:36 <bourbaki> im off to bed *waves*
15:47:39 <shapr> bourbaki: will do, I'll let it bubble around in my brain
15:47:44 * shapr blorps
15:47:56 <bourbaki> :)
15:47:58 <waltz> hmm
15:48:05 <bourbaki> sounds good thanks nighto
15:48:14 <shapr> hej viblo, ltns
15:48:50 <waltz> Is Haskell case-sensitive?
15:48:58 <shapr> Yes, it is.
15:49:17 <viblo> hi shapr
15:49:32 <shapr> viblo: how's life in the big city?
15:49:38 <viblo> =)
15:49:40 <viblo> its good
15:50:11 <viblo> I'm playing around some with Erlang now.. 
15:50:26 <shapr> ah, cool, Peti just released an OpenSSL binding
15:50:34 <shapr> Erlang is nifty
15:50:41 <viblo> hehe
15:51:18 <viblo> I found some strange thing: Ive made (copied ;) a funktion Double = fun(X) -> 2 * X end.
15:51:31 <viblo> and then tried lists:map(Double, [19,18,17]).
15:51:52 <viblo> when all 3 numbers are in the order X, X-1, X-2.. 
15:52:00 <viblo> the output become ascii chars
15:52:05 <shapr> weird
15:52:08 <viblo> yes 
15:52:35 <viblo> for example: 
15:52:35 <viblo> 32> lists:map(Double, [38,37,1]).
15:52:35 <viblo> [76,74,2]
15:52:35 <viblo> 33> lists:map(Double, [38,37,36]).
15:52:35 <viblo> "LJH"
15:53:10 * shapr has no idea
15:53:22 <shapr> I've not used Erlang enough to know what's going on there.
15:54:14 <kolmodin> viblo: http://www.erlang.se/doc/doc-5.4/lib/stdlib-1.13/doc/html/io.html  look at io:format
15:54:41 <kosmikus> viblo: it might have something to do with all values being >31 and <(=)255
15:55:12 <viblo> good point
15:55:31 <kolmodin> erlang actually guesses if the list of ints is a string or not. if the values are printable it thinks it's a string
15:55:56 <viblo> oh
15:56:47 <Igloo> dons: Does hs-plugins (or something else) give us extensible datatypes/records?
15:56:57 <viblo> now I see, it was just pure luck that it converted 19,18,17 but not 1,2,3 then :)
15:57:10 * Igloo can't quite see how this is all going to fit nicely together yet
15:57:42 <dons> You could generate a new datatype at runtime that contains the extra field
15:57:59 * dons can't quite see how this is all going to fit together .. but I'm getting there
15:58:02 <kolmodin> use ~w and it will guess, ~s for strings
15:58:04 <shapr> g'day Pseudonym
15:58:11 <viblo> thx kolmodin
15:58:24 <kolmodin> np
15:58:30 <Pseudonym> G'day.
15:58:48 <dons> I really want to implement: :eval map toUpper -- that I know how to do straight off
15:59:03 <Igloo> Suppose we have the editor and the syn highlighter with an array of (Char, SynHighStuff). Can we load the Indenter (which adds something to the tuple/record/whatever) without recompiling the syn highlighter and editor?
15:59:29 <dons> yes, as long as we structure everything correctly
15:59:30 <Igloo> Oh, random thought I had - if emacs is editor macros, efun would be another potential name
15:59:40 <dons> oooh..
15:59:44 <dons> elam
16:00:01 <dons> efn even
16:00:11 <shapr> earrow? ;-)
16:00:15 <Igloo> efn? What are you, an MLer?  :-P
16:00:23 <dons> not me!
16:00:37 <dons> too much time reading Bob Harper's stuff
16:00:56 <dons> and complaining about the syntax the whole time
16:00:56 <waltz> So Haskell is not OOP?
16:00:59 <kolmodin> argh! can still not pull hemacs even with the latest darcs
16:01:05 <Igloo> re separate thread, that sounds great. The editor can just ask to be told about visible changes
16:01:10 <shapr> hiya JerubBaal 
16:01:25 <dons> yep. throw interrupt to gui thread or something like that
16:01:34 <Igloo> People thinking about the buffer representation (is there a summary I can read anywhere?) should also consider files that don't fit in memory, incidentally
16:01:39 <waltz> So Haskell is not OOP?
16:01:48 <shapr> waltz: not usually
16:02:00 <JerubBaal> waltz: Expand that acryonym and say it again. The question doesn't actually make sense. ;)
16:02:02 <shapr> waltz: you can do all the OOP stuff in Haskell if you really want to, but there are better ways to do it.
16:02:18 <shapr> JerubBaal: did you see the recent OOHaskell paper?
16:02:24 <dons> Igloo: that we'll have to deal with eventually - yes.
16:02:37 <JerubBaal> shapr: no!
16:02:46 <shapr> http://homepages.cwi.nl/~ralf/OOHaskell/
16:03:36 <dons> kolmodin: I checked just then. repo seems fine
16:03:41 <Igloo> Well I think it's something that should be in mind while designing the buffer, even if it isn't actually implemented immediately
16:03:54 <dons> yep. I wonder how they do it with Handles?
16:04:13 <shapr> lazy reading of of a file requires unsafeIO, sadly.
16:04:31 <kolmodin> dons: I'm sure the repo is fine, but darcs exits with Fail: bug in darcs! Rollback:  Unable to apply inverse patch!
16:04:33 * Igloo also isn't entirely sure how you automatically get from something BNF-like to a lexer
16:04:47 <shapr> Igloo: could use SDF, it already does that.
16:05:08 <kolmodin> I'll just post a bug report tomorrow
16:05:09 <kosmikus> kolmodin: have you tried with rc3 now?
16:05:12 <shapr> I'm not sure if that's a good idea, but it's an idea.
16:05:14 <Igloo> shapr: To a lexer like the one I sent to the list?
16:05:18 <kolmodin> kosmikus: yes
16:05:20 * shapr looks
16:07:23 <waltz> >)
16:07:41 <dons> oh, we could go with "lambda editor" -- lame
16:07:53 <dons> :P
16:07:59 <shapr> waltz: anymore questions?
16:08:04 * dons needs more coffee
16:08:06 <Pseudonym> "line is not emacs"
16:08:25 <tuomov> http://iki.fi/tuomov/tc.txt :)
16:08:40 <shapr> tuomov: oh, ah!
16:08:48 <dons> yeah!
16:08:59 <dons> that's it
16:09:01 <Pseudonym> I have a program which I'm working on part of the time which I've titled "Kinara".
16:09:14 <Pseudonym> And what it means is... "Kinara" is not a recursive acronym.
16:09:15 <shapr> I really like the whole idea of using a symbol of change.
16:09:35 <dons> Pseudonym: I like it :)
16:09:38 <Pseudonym> Thus making it the first self-contradictory recursive acronym.
16:09:54 <Pseudonym> And no, you can't have the name.
16:09:57 <shapr> :-P
16:10:11 <dons> maybe the name should be mutually recursive, or have bottom as an element
16:10:19 <Pseudonym> Oooh, now there's an idea.
16:10:42 <Pseudonym> Maybe we'll call it "Y", which is short for "Y".
16:10:48 <dons> hehe
16:10:53 <Pseudonym> Or "Y I".
16:10:59 <Pseudonym> Which actually is bottom.
16:11:11 <Pseudonym> "Y I" is short for "I (Y I)".
16:11:15 <dons> since the editor never terminates anyway ...
16:11:20 <shapr> the G-spot-machine?
16:11:22 <dons> (well, it need never terminate)
16:11:27 <dons> shapr: :}
16:11:30 <dons> :{
16:11:33 <blackdog> the immortal editor...
16:11:38 <shapr> g'day blackdog 
16:11:43 <dons> hey blackdog
16:11:46 <blackdog> g'day shapr, dons
16:11:53 <Pseudonym> Actually, if you can call an editor "vi", then you can call it "yi".
16:12:00 <dons> I like that
16:12:09 <Pseudonym> I do too.
16:12:12 <shapr> zataocm ? Zen And the Art of Code Maintenance?
16:12:32 <Pseudonym> Unfortunately, yi.org is taken.
16:12:38 <dons> blargh
16:13:15 <shapr> The Tureen Machine?
16:13:25 <Pseudonym> The Shroud of Turing.
16:14:03 <shapr> self-edident?
16:14:19 <Pseudonym> No, we're not writing it in Self.
16:14:50 <shapr> funk?
16:15:24 * shapr gives up, codes
16:15:40 <Pseudonym> "haste"
16:15:55 <Pseudonym> Dunno what it stands for, but it has "has" in it as well as an "e".
16:16:23 <shapr> greetings bik
16:16:23 <Pseudonym> Oh, I know.  Lambaste.
16:16:29 <shapr> looking for info on Haskell?
16:16:32 <Pseudonym> Short for Lambda Structure Editor.
16:16:41 <shapr> Lambaste is pretty cute.
16:17:46 <bik> shapr- i'm doing haskell (curry actually) as part of a cs program, and coming from a procedural background, It has been more than a little frustrating :)
16:18:01 <bik> so I figured I ought to sit in here and hopefully absorb something
16:18:08 <Pseudonym> shapr, get the brainwash machine.  We need to teach this person a lesson...
16:18:10 <shapr> well, you've found the place for sponging about.
16:18:28 <shapr> bik: How far have you gotten? able to write recursive functions with a single thought?
16:18:37 <bik> yeah
16:18:40 <shapr> scaling infinite lists with a tiny function?
16:18:54 <shapr> higher order functions? monads?
16:18:56 <bik> yes again, they just introduced monads to us
16:18:57 <Pseudonym> Look!  Up in the sky!  Is it a bird?  Is it a Wadler?
16:19:05 <kolmodin> lambalot as in lots of lambdas...
16:19:06 <kosmikus> haha
16:19:25 <shapr> bik: having trouble with monads?
16:19:36 <kolmodin> it's bicyclerepairman!
16:19:44 <Pseudonym> kolmodin: It's only a model.
16:20:02 <bik> shapr- yeah, some. 
16:20:14 <kolmodin> Pseudonym: :)
16:20:59 <kolmodin> got to catch some sleep, have got to study all day tomorrow
16:21:03 <kolmodin> good night
16:21:16 <bik> I'm used to doing all of these recursive functions, and wrapping that around a monad just feels wrong :)
16:21:22 <Pseudonym> Night.
16:21:26 <shapr> bik: my advice is 1) read the nomaware tutorial 2) read the MonadsAsContainers page on the Haskell Wiki 3) read Steve Atkin's haskell files where he rewrites some code from explicit passing to using monads
16:21:51 <bik> thanks, I will do that
16:22:00 <shapr> and in the process, ask lots of questions here on #haskell
16:22:34 <viv> bik,shapr>Cale wrote 2), btw =)
16:22:44 <viv> just a friendly promotion..=)
16:22:50 <shapr> yes, Cale is cool.
16:22:54 <kolmodin> Pseudonym: I actually booked a room tomorrow with... with... ah, look for yourself :)  https://www.ee.chalmers.se/cgi-bin/uncgi/boff?obj=dtek%2Dgrupprum%2D13&cmd=details&date=20041019
16:23:13 <bik> cool, I haven't even been to the haskell wiki yet, that should be a good resource
16:24:02 <Pseudonym> kolmodin: :-)
16:24:19 * shapr blinks
16:24:26 <bik> I'm curious, what sort of work is being done with haskell outside of academic settings?
16:24:35 <shapr> lots
16:24:43 <shapr> well, from my viewpoint it's lots.
16:24:55 <juhp> woah, the cursor works now :)  (hemacs)
16:25:04 <shapr> like um, there's an editor...
16:25:19 <kolmodin> lots? I hade never heard of any functional language until I came to Chalmers..
16:25:22 <shapr> that doesn't yet do so much, but definitely isn't part of academia
16:25:30 <Pseudonym> kolmodin: YOu hadn't heard of Lisp?
16:25:48 <kolmodin> Pseudonym: ok, lisp, but that must be the only one :)
16:26:12 <shapr> scheme? guile? erlang?
16:26:39 <Pseudonym> Erlang wasn't around when I was an undergrad.
16:26:44 <Pseudonym> Guile definitely not.
16:26:48 <kolmodin> might have heard of them but I didn't know that they where functional
16:26:48 <shapr> Pseudonym: you're old.
16:26:57 <Pseudonym> shapr: YOu're older.
16:27:02 * shapr grins
16:27:13 <shapr> Only what.. five years?
16:27:26 <Pseudonym> Less than that.
16:27:31 <Pseudonym> You're, what, 34?
16:27:35 <shapr> er, 33
16:27:38 <Pseudonym> Right.
16:27:40 * Pseudonym is 31
16:27:48 <shapr> ok, two years.
16:27:52 <Pseudonym> You must have a birthday coming up soon.
16:27:55 <shapr> just passed.
16:27:59 <shapr> september 18th
16:28:05 <shapr> I got a mountain unicycle for my birthday =)
16:28:06 <Pseudonym> Oh, happy belated birthday.
16:28:35 * Pseudonym shares a birthday with Wil Wheaton
16:28:37 <kosmikus> kolmodin: I hadn't heard of any functional pls before coming to the university as well -- but then, I discovered that I hadn't yet heard about *many* pls ...
16:28:58 <kolmodin> :)
16:29:00 <shapr> Actually, I got the unicycle several weeks before my birthday. A summer full of obsessive unicycling got rid of twelve kilos.
16:30:06 <kosmikus> I remember how I complained about having to learn Eiffel during the first semester
16:30:30 * kolmodin is going to bed
16:30:36 <shapr> g'natt kolmodin 
16:30:38 <shapr> sov gott :-)
16:30:39 <kosmikus> bye
16:30:46 <kolmodin> natti natti
16:30:50 <JerubBaal> mountain unicycle?
16:30:51 * shapr wants to edit this buffer!
16:30:55 <tuomov> the uni I went to was 100% c++... I ended up majoring in math :)
16:30:58 <JerubBaal> does that mean its got gears and can go up hills?
16:31:02 <shapr> JerubBaal: yup, I got a KH24.
16:31:19 <shapr> JerubBaal: no gears, but it does have brakemounts. And it can go up hills extremely well.
16:31:26 <shapr> Faster than a bike in fact.
16:32:36 <shapr> dons: hey, you should probably add your name to the Copyright at the top...
16:33:08 <shapr> bik: anyway, I've gotten paid to do some Haskell, I'm a self-employed programmer.
16:33:14 <kosmikus> tuomov: oh yes, I studied math anyway
16:33:57 <bik> shapr- nice, that gives me a little rosier outlook on the time I will be spending on it this year :)
16:34:27 <bik> I figure that just learning a functional paradigm will make me a better programmer all around
16:34:32 <dons> shapr: of what?
16:34:47 <shapr> bik: quite a few companies use Haskell for circuit design & verification, Intel, ARM, Xilinx, safelogic, bluespec
16:34:47 <dons> I've been adding my name once I rewrite most of the text in that file
16:34:52 <shapr> ok
16:35:23 <bik> shapr- ahh, I guess that makes a lot of sense
16:35:36 <shapr> bik: at least two companies in the US that are mostly Haskell, aetion.com and galois.com
16:35:54 <shapr> Aetion does fast prototyping and Galois does high assurance.
16:37:00 <shapr> Galois did the Cryptol domain specific language for a part of the US gov't.
16:37:12 <shapr> http://www.cryptol.net/
16:37:51 <shapr> bik: anyway, if you want a really long list, ask me tomorrow.
16:37:56 <bik> hehe, no that's fine
16:38:23 <bik> we were talking about its uses in class, and some kid said "they use it a lot in europe
16:38:37 <Pseudonym> That should give shapr time to write some killer apps.
16:38:37 <bik> that was the best answer I got until a moment ago
16:39:04 <shapr> I've written a mailing list search, a bayesian spam filter, and some small parts of lambdabot.
16:39:08 <shapr> Pseudonym wrote lambdabot.
16:39:12 <shapr> @yow
16:39:13 <lambdabot> I feel partially hydrogenated!
16:39:28 <Pseudonym> lambdabot: You're dumb.
16:39:28 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
16:39:39 <bik> hehe cool
16:39:48 <Pseudonym> @moo
16:39:51 <lambdabot>          (__)
16:39:52 <lambdabot>          (oo)
16:39:54 <lambdabot>    /------\/
16:39:56 <lambdabot>   / |    ||
16:39:58 <lambdabot>  *  /\---/\
16:40:00 <lambdabot>     ~~   ~~
16:40:02 <shapr> bik: lambdabot has a simple and easy plugin architecture, is designed to be a code-toy for aspiring Haskellers.
16:40:02 <lambdabot> ...."Have you mooed today?"...
16:40:07 <shapr> @listmodules
16:40:07 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
16:40:07 <lambdabot> ,"dynamic","eval","hello","karma","more","quote","seen","state","system
16:40:08 <lambdabot> ,"topic","type"]
16:40:15 <shapr> @seen bik
16:40:16 <lambdabot> bik is in #haskell.
16:40:35 <Pseudonym> What's cmafihe?
16:40:44 <shapr> @cmafihe xu do tavla mi bau la lojban
16:40:44 <lambdabot> xu <UI6> [yes/no?] do <KOhA3> [you] tavla <BRIVLA> [talk] mi <KOhA3> [I
16:40:44 <lambdabot>  me] bau <BAI> [in language] la <LA> [ ] lojban <CMENE> [] 
16:40:58 <Pseudonym> Oh, dear. :-)
16:41:06 <shapr> phubuh wrote Cmafihe, it's a lojban parse plugin.
16:42:12 <bik> wow
16:42:26 <Pseudonym> How big is the dictionary?
16:42:27 <bik> I wrote a ROT13 algorithm :D
16:42:32 <shapr> heh
16:42:40 <Pseudonym> blk: Good, write it as a lambdabot plugin.
16:43:18 <bik> I may have to do that
16:43:20 <shapr> I think cmafihe calls out to jbofi'e so it's as good as the datafiles.
16:44:01 <Pseudonym> @leksicono Cxu vi parolas Esperanton?
16:44:01 <lambdabot> Sorry, I don't know the command "leksicono", try "lambdabot: @listcommands
16:44:04 <Pseudonym> Damn.
16:45:15 <shapr> a'acu'i .i roda djuno noda
16:46:35 <shapr> dons: already defining simple/inefficient editing operations in Buffer.hs?
16:51:51 <dons> shapr: reimplementing the buffer type to use MutableByteArray#
16:51:56 <shapr> ah
16:52:01 <dons> so that I can then do some editing without being sick
16:52:07 <shapr> :-)
16:52:19 <dons> i.e. doing 'insert' was going to be nauseating
16:52:20 <Igloo> Do you plan to have the extra info stored separately then?
16:52:24 <Igloo> Or is this temporary?
16:52:47 <shapr> you mean like a buffer parse tree?
16:52:50 <dons> a basic buffer is:
16:52:51 <dons> data FBuffer =
16:52:51 <dons>     FBuffer
16:52:51 <dons>         FilePath{-immutable-}
16:52:52 <dons>         !(MVar FBuffer_)
16:53:01 <dons> data FBuffer_ = FBuffer_ {
16:53:02 <dons>         bufBuf   :: RawBuffer,
16:53:02 <dons>         bufPnt   :: !Int,
16:53:02 <dons>         bufSize  :: !Int,
16:53:02 <dons>      }
16:53:10 <dons> type RawBuffer = MutableByteArray# RealWorld
16:53:20 <dons> extra info will be on top of this
16:53:58 <Igloo> So there would be a complete separate array for syn highlighting code, another for indentation (if necessary) and so on?
16:54:25 <dons> I think so. That was Tuomo's suggestion, and I agree. Though, of course, everything is flexible
16:54:37 <dons> Just want to get efficient editing happening atm.
16:55:29 <Igloo> It seems like it should be the wrong answer to me, as then you have to fiddle n buffers when a character is inserted, although they might all be able to be put on top of an abstraction without too much cost
16:56:10 <Igloo> And if there is a tree of somethings down the road you have to navigate down n trees
16:56:31 <Pseudonym> How are you planning to support undo?
16:57:01 <dons> It may be that we extend the Buffer class operations, rather than build on top.
16:57:02 <Igloo> Is there a better way then a list of reversible operations?
16:57:14 <Pseudonym> Igloo: Yes.
16:57:16 <shapr> why not the darcs way?
16:57:19 <Pseudonym> In this case, anyway. :-)
16:57:28 <Igloo> What is it?  :-)
16:57:31 <Pseudonym> Explicitly undoing operations isn't the FP way.
16:57:36 <dons> Maybe we can some up with a nice semantics for the editor actions, such that we can always reverse them cheaply
16:57:39 <Pseudonym> The FP way is to go back to a previous version.
16:57:48 <dons> we should be able to go forwards and backwards in time
16:58:03 <dons> Pseudonym: yes
16:58:04 <Igloo> Even when you have MutableByteArray#s?
16:58:16 <Pseudonym> Well, don't make your arrays mutable.
16:58:23 <Pseudonym> Or at least don't mutate them.
16:58:34 <Igloo> I suspect efficiency will require we do
16:58:39 <Pseudonym> Nope.
16:59:09 <juhp> no?
16:59:24 <Pseudonym> As mentioned on the mailing lists, ropes/cords do the job nicely.
16:59:32 <Pseudonym> Ermacs calls them "cords", I believe.
16:59:47 <dons> Yep. I'll turn to this next, once some basic editing is happening.
16:59:55 * Igloo hasn't been paying attention to all the proposals. I'm hoping someone will write a nice summary some time  :-)
17:00:10 <Pseudonym> Too long to explain at the moment, but the idea is to use a (balanced) binary tree, where leaves are byte arrays.
17:00:18 <Pseudonym> Or representations of parts of files.
17:00:19 <dons> I've been joting some stuff down in hemacs/TODO, but really should add more
17:00:19 <Pseudonym> Or whatever.
17:00:31 <Pseudonym> It can be a DAG.
17:00:44 <Pseudonym> And you also allow a "restrict" node, which represents a substring of the node under it.
17:01:31 <Pseudonym> So to insert some characters, you restrict the tree to the area before the insertion point, restrict it to the point after the insertion point, make a new byte array for the inserted area, and then paste the three trees together.
17:01:38 <tuomov> err.. I have yet to suggest any practical storage for buffers. Just ways to do different modes and other transformations
17:01:55 <Pseudonym> Needn't be a byte array specifically, of course.
17:02:31 <tuomov> (CPreprocessor should be another such transformation, btw.)
17:02:42 <Igloo> Sounds like it would be hard to free memory that is too old
17:03:00 <Pseudonym> Igloo: If you're supporting unlimited undo, you can't.
17:03:16 <Pseudonym> OTOH, if you're supporting only limited undo, then you can restructure the tree.
17:03:19 <Igloo> I mean if you are allowing n-level undo
17:03:38 <Pseudonym> You can basically propagate restrict nodes into their children, turning large arrays into smaller ones.
17:03:56 <tuomov> I'd suggest not using anything mutable, but instead localised data structures
17:04:02 <tuomov> because cheap undo is nice
17:04:12 <Igloo> Hmm, yeah, OK
17:04:35 * shapr just wants it to work so it can be used and then improved
17:04:46 * dons did some profiling yesterday of the naive [Char] buffer copying and decided we needed to do something about space. ByteArray is just a quick attempt
17:05:00 * Pseudonym nods
17:05:22 <Pseudonym> That's why I think ropes/cords are a good compromise.  The only problem is that they're optimised for large changes rather than small ones.
17:05:27 <shapr> where is MutableByteArray# defined?
17:05:37 * Igloo ponders the BNF for literate Haskell with nested TeX syn highlighting
17:05:37 <tuomov> ropes sounds like a good solution to that
17:05:42 <dons> primops.txt.tt
17:05:53 <Pseudonym> So a vi-like editor, where you can easily tell where an insertion operation begins and ends, might be better suited for ropes.
17:06:05 <tuomov> with the occasional collection of single characters to bytearrays
17:06:12 <Igloo> I think this might get a bit scary
17:06:31 <Pseudonym> What is the granularity of emacs undo?
17:06:31 <shapr> personally, I'd rather aim for simplicity of implemenatation, Worse Is Better
17:06:33 <tuomov> but it needs to be figured out how all this relates to parse trees..
17:06:39 <Pseudonym> If you type a word, then hit "undo", what happens?
17:06:43 <shapr> emacs can undo out-of-order
17:06:48 <tuomov> where the actual storage is going to be in the end
17:06:53 <shapr> emacs can undo the word or the letters
17:07:11 * Pseudonym nods
17:07:36 <Igloo> commutative undoing would be cool, and would really mean the list was the way to go (or, again, "list")
17:08:15 <Pseudonym> The problem with that is you'd need to know what operations commute and what don't.
17:08:36 <shapr> there's patch theory...
17:08:42 <Igloo> Yeah, but doing it conservatively is really easy
17:08:44 <shapr> Igloo: I looked at your email
17:08:47 <Igloo> "Nothing commutes with anything"
17:09:38 <shapr> I think syntax highlighting is best as a decorated parse tree
17:10:01 * shapr is getting tired
17:10:19 <shapr> Igloo: but I can't tell if that differs from your post
17:10:36 <tuomov> but do we store all the text in the parse tree itself or what?
17:10:40 <Igloo> BNF and a suitably got code generator make the two essentially the same
17:11:27 <shapr> tuomov: possibly....
17:11:30 <Igloo> But lexers can recover from errors much more quickly and easily
17:12:00 <shapr> refactoring browsers operate only on parse trees
17:12:10 <shapr> not the underlying text
17:12:13 <shapr> that makes sense, they have to
17:12:37 <shapr> they can turn an AST back into text
17:12:43 <Igloo> Hare operates on both...
17:12:56 <shapr> ?
17:13:06 <shapr> how can it operate on text?
17:13:09 <Igloo> Do you know what hare is?
17:13:19 <shapr> yes, I know about HaRe
17:13:28 <Igloo> It works out what transformation should be done on the AST, then tries to work out what that means for the text
17:13:37 <Igloo> Thus doesn't screw up your spacing, comments etc
17:13:39 <shapr> I argued with Claus that he should use MetaEnvironment as a beginning springboard
17:15:06 <shapr> that's pretty cool
17:15:23 <shapr> does HaRe use ATerm? or a custom AST?
17:15:41 <Igloo> It uses programmatica's representation doesn't it?
17:16:05 <shapr> that would make sense
17:16:41 <Igloo> A language for specifying syntax highlighting that could explain how to parse Haskell would be pretty scary too
17:17:26 <dons> hmm.. yep
17:17:28 <Igloo> In particular "If the next lexem would cause a syntax error and the current scope is implicit, close it and try again"
17:20:22 <bik> ls
17:20:24 <bik> woops
17:23:37 <shapr> Igloo: does that fit into non-circular context-free grammar?
17:24:04 <Igloo> Ug
17:24:20 <Igloo> Not one you'd want to write certainly
17:25:17 <Igloo> I /think/ you could enumerate all possibilities, but when I thought about it a few years ago I decided it wasn't going to be trivial
17:26:10 <Igloo> Why do you ask/ And what do you mean by non-circular?
17:26:38 <Igloo> Isn't   exp -> exop op exp   circular?
17:27:20 <shapr> just wondering, that's what SDF says it can handle.
17:27:43 <Igloo> That's what I thought, so circular must surely mean something else. left-recursive perhaps?
17:44:39 <Jan__w> newtype Schijf = Schijf (Int,[Int]) deriving (Show)
17:44:39 <Jan__w> instance Eq Schijf where 
17:44:39 <Jan__w> (==) (Schijf (a,b)) (Schijf (c,d))  = (a == c) && (or [ (Schijf (a,b)) == x | x <- mogelijk (Schijf(c,d)) ] ) 
17:45:09 <Jan__w> Ambiguous variable occurrence "==",*** Could refer to: Main.== Hugs.Prelude.==  
17:45:17 <Igloo> You need a space before (==)
17:45:52 <Jan__w> Igloo: arggh. many thanks
17:46:06 <Igloo> You can also write   "(==) (Schijf (a,b)) (Schijf (c,d))"   as   "Schijf (a,b) == Schijf (c,d)"   if you want
17:47:14 * shapr falls over asleep
17:49:00 <Jan__w> hm, it compiles, but executing Schijf (6,[1,0,0,0,0,0])  == Schijf (6,[1,1,0,0,0,0])
17:49:00 <Jan__w> Main> Schijf (6,[1,0,0,0,0,0]) == Schijf (6,[1,0,0,0,0,0])
17:49:00 <Jan__w> ERROR - C stack overflow
17:49:09 <Jan__w> C stack overflow ??
17:49:17 <Igloo> You are problem recursing infinitely
17:49:50 * Igloo contemplates correctly highlighting http://urchin.earth.li/~ian/q.lhs
17:50:11 <shapr> bah, easy ;-)
17:50:27 <shapr> actually, I think it would be simple enough
17:50:45 <Igloo> If it's easy can you make a patch for lhaskell.vim please?  :-)
17:51:09 <shapr> err, with a latex and haskell parser, it would be no problem
17:51:27 <shapr> even just enough of a latex parser to strip out the latex and leave the haskell
17:51:54 <shapr> regular expressions are a bit harder to do correctly with that.
17:51:56 <Igloo> Actually, if strings themselves get tokenised then "\end{code}" will still be the beginning of a lexeme, so it might be OK
17:52:22 <shapr> must.. sleep..
17:52:54 <Igloo> And string want to be tokenised anyway so \n etc can be coloured differently
17:54:25 <Igloo> Bah, too many fun things to do, and I bet I don't have time for any of it while I'm off conferencing
17:54:32 <Jan__w> http://rafb.net/paste/results/XCD5X124.html, is is what I do.. i translated the labels for readability
17:57:13 <Jan__w> any idea why Disk (6,[1,0,0,0,0,0]) == Disk (6,[1,1,0,0,0,0]) whould cause a stack overflow ?
17:58:37 <Jan__w> ahh
17:58:44 <Jan__w> nevermind I get it..
17:59:02 <Jan__w> i used == between Disks inside the == of Disk
17:59:47 <Jan__w> How can I use the default == explicitly ?
18:00:11 <Igloo> There is not default ==
18:00:45 <Igloo> You can derive one, but then you can't call whatever you're defining ==  (well, technically you can, but you really don't want to)
18:03:54 <Jan__w> ok, got it now.. thanks again
18:04:34 <Jan__w> pff, was working on that for 3 hours now, main issue was the layout :(
18:21:25 <waltz> Is Haskell compatible with network communications, such as the TCP/IP protocol?
18:26:05 <Jan__w> can i convert an Int to it's binary representation in a String ?
18:26:19 <Igloo> show
18:26:31 <Igloo> waltz: Yes
18:26:54 <Igloo> (or at least GHC is. Can't remember what the state of Haskell 98 is)
18:27:01 <Jan__w> show 31 whould give me "31" and not "00011111"
18:27:13 <Igloo> Oh, sorry, misread you
18:27:44 <Igloo> I think there is a showBase or somesuch in the prelude, but you'd have to put the zeroes on yourself. If this is a homework problem you're probably meant to do it yourself though
18:28:35 <Jan__w> it's homework allright, the problem is much more complex then converting numbers :)
18:28:44 <waltz> They teach Haskell in school facilities?
18:28:55 <Jan__w> waltz: yep
18:29:06 <waltz> :\
18:29:16 <Igloo> What is the problem OOI?
18:29:19 <Igloo> (just an overview)
18:29:33 <Jan__w> hehe
18:29:38 <Jan__w> well
18:29:53 <Jan__w> I have disks, the disks have holes in them
18:30:06 <waltz> I take care of my hardware :|
18:30:18 <Jan__w> N holes, in a n-cornered shape positioned around the center of the disk
18:30:55 <Jan__w> the amount of disks is the amount of possible disks with different holes
18:31:00 <Jan__w> of in the case n=6
18:31:05 <Jan__w> there are 12 discs
18:32:02 <Jan__w> one with 1 hole, with 3 with 2 holes, 3 with 3 holes, 3 with 4 holes, 1 with 5 holes, and 1 with 6 holes
18:32:06 <Jan__w> ok
18:32:20 <Igloo> OK
18:32:22 <Jan__w> now we have 39 holes
18:32:43 <Jan__w> and we have N sticks, all with the same length
18:33:13 <Jan__w> in the case of 39 sticks of length 1 (1=heigh of a disc)
18:33:20 <Jan__w> we could fill all hole exacly
18:33:29 <Jan__w> and you'd have a cylinder
18:33:35 <Jan__w> that is solid again
18:33:37 <Igloo> Right
18:33:59 <Jan__w> I need to solve all possible lengths of equal sticks
18:34:16 <Jan__w> so: is 2 possible ? no: because 39/2 is not whole
18:34:29 <Jan__w> 3 might be possiblem, but how exacly
18:34:43 <Jan__w> the discs can be rotated in several ways :)
18:34:46 <Igloo> Are you expected to do it by brute force or by clever mathematics?
18:34:57 <Igloo> And shuffled, right?
18:34:59 <Jan__w> first brute force
18:35:02 <Jan__w> Igloo: right
18:35:14 <Jan__w> I working on brute force now
18:35:26 <Jan__w> to generated the possible discs
18:35:34 <Igloo> So you have 39!*38^6 ways of arranging and rotating them?
18:36:14 <Jan__w> I'm not sure, but I don't think so
18:36:36 <Igloo> Oh, I mean 6^38
18:37:01 * Igloo makes that 2^252. So I hope either it prunes well or I'm wrong  :-)
18:37:07 <Jan__w> anyway, thats of later concern :)
18:37:41 <Jan__w> i thought i'd convert the numbers 0..63 to binary to create all disks where 0 and 1 indicate a hole or not
18:37:50 <Jan__w> and filter the equals disks
18:38:13 <Jan__w> since the == is wokring now :)
18:38:30 <Igloo> :-)
18:38:44 <Jan__w> Igloo
18:38:57 <Jan__w> how do you figure 6^39 ?
18:39:09 <Jan__w> 39 holes, but just 12 discs ?
18:39:19 <Igloo> Ah, good point
18:39:41 <Igloo> A mere 2^182 then
18:39:49 <Jan__w> so 12! diskpositions
18:40:02 <Igloo> Oh, good point, the 39! was wrong too
18:40:31 <Jan__w> and max. 6*12 rotations 
18:40:33 <Igloo> 2^57. That might even be possible
18:40:45 <Jan__w> but will be less
18:41:06 <Jan__w> because when n=6 rotation a disc with 6 holes is useless
18:42:57 <Igloo> No, for a pair of discs, for each rotation of the first there are 6 rotations of the one above it. So 6^2 for 2. And 6^3 for 3 and so on
18:48:07 <Jan__w> going to get some sleep... 
18:48:29 <Jan__w> all post the solution for interested people tomorrow :)
18:48:31 <Jan__w> bye
21:03:23 <flaw> @moo
21:03:24 <lambdabot>          (__)
21:03:24 <lambdabot>          (oo)
21:03:24 <lambdabot>    /------\/
21:03:24 <lambdabot>   / |    ||
21:03:24 <lambdabot>  *  /\---/\
21:03:25 <lambdabot>     ~~   ~~
21:03:27 <lambdabot> ...."Have you mooed today?"...
21:03:38 <JerubBaal> baa
21:09:24 <flaw> moo?
21:19:02 <Mike121> cool
21:19:08 <Mike121> @lambada
21:19:09 <lambdabot> Sorry, I don't know the command "lambada", try "lambdabot: @listcommands
21:19:19 <Mike121> @listcammands
21:19:19 <lambdabot> Sorry, I don't know the command "listcammands", try "lambdabot: @listcommands
21:19:23 <Mike121> @listcommands
21:19:24 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
21:19:24 <lambdabot> ,"definitions","del-definition","det","devils","dict","dict-help","dummy
21:19:24 <lambdabot> ,"dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo
21:19:24 <lambdabot> ,"elements","eurohaskell","eval","foldoc","fortune","gazetteer","get-definition
21:19:24 <lambdabot> ,"goodbye","hello","hitchcock","index","info","jargon","join","karma","karma
21:19:25 <lambdabot> ","karma-","learn","leave","listchans","listcommands","listmodules","lojban
21:19:27 <lambdabot> ,"moo","more","msg","musasabi","part","prelude","quit","reconnect","resume
21:19:29 <lambdabot> ,"seen","set-fuel","shapr","state","stepcut","topic-cons","topic-init",
21:19:31 <lambdabot> topic-snoc","topic-tail","topic-tell","type","vera","web1913","wiki","wn
21:21:03 <Mike121> @karma
21:21:03 <lambdabot> I can't find the karma of nobody.
21:21:27 <Mike121> er back to haskell 
21:22:02 <thebug> please play with lambdabot in /msg :)
21:26:05 <Mike121> thebug ok i was thinking the same .... sorry about the mess on the channel 
21:29:23 <thebug> s'ok :)
21:43:39 <Mike121> how many keywords does haskell 98 have ?
22:11:23 <Lemmih> Heh. The word "Hackage" is nice (-:
22:18:19 <Mike121> Lemmih how many keywords does haskell have ?
22:20:19 <Lemmih> Mike121: I don't know.
22:23:14 <Lemmih> Mike121: You should check the Haskell language definition or Language.Haskell.Parser.
22:23:37 <Mike121> tnx Lemmih  i will check that out 
22:29:32 <Lemmih> I wonder if Language.Haskell.Syntax would benefit from GADTs.
22:36:48 <Mike121> does haskell support unicode ?
22:36:58 <Mike121> whats GADTs ?
22:38:54 <Lemmih> Yes. Char is actually a 32bit word.
22:39:27 <Mike121> ah tnx Lemmih 
22:39:42 <Lemmih> "Generalised algebraic data types" http://research.microsoft.com/Users/simonpj/papers/gadt/
22:39:42 <Mike121> GADTs what does that signify ?
22:40:13 <Lemmih> I'm off for school. See ya later.
22:42:48 <musasabi> morning
22:43:03 <Mike121> hello musasabi 
22:43:29 <musasabi> Mike121: GADTs are a nifty new feature that will be in (probably) 6.4
22:44:40 <musasabi> Mike121: http://www.haskell.org/pipermail/haskell/2004-October/014554.html is a good example.
22:44:50 <Mike121> in the compiler or the language ?
22:48:09 <musasabi> in GADTs
22:57:23 <tuomov> oh, great. a bunch of painters shows up, "we'll be running in and out of the apartment all day long, painting corners and stuff"
23:04:35 <musasabi> tuomov: why does hemacs need those buffers?
23:04:45 <tuomov> what buffers?
23:04:55 <musasabi> tuomov: why is it not enough to just specify a way to draw parse trees.
23:05:35 <tuomov> isn't that what the buffer abstraction does?
23:06:03 <tuomov> anyway, I think a "theory of patches" kind of approach to buffers might be what is needed...
23:06:37 <tuomov> exactly in the form of transformer commutating..
23:07:11 <tuomov> I should write up on it..
23:41:28 <musasabi> Any link to an arrow example mixing in IO ?
