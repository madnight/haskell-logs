00:05:31 <desrt> hum.
00:05:56 <desrt> ghc-6.2.2 fails to build stage1 using HEAD
00:18:58 <musasabi> Is it possible to use alex if the input needs to use getChar (or a equivalent) ?
00:21:58 <musasabi> that is alexGetChar would need to do IO (and unsafeInterleaveIO is not an option)
00:25:18 <dons> I couldn't get this to work with yi just a couple of days ago
00:25:49 <dons> though, if you don't use any wrappers, you can write whatever you want, I think
00:27:23 <desrt> Î»
00:28:00 <dons> musasabi: are you thinking of an interactive lexer?
00:28:14 <dons> or, there's some reason you can' read all input before you start lexing?
00:28:17 <dons> can't
01:20:11 <ksbot> topic doesn't parse
01:31:34 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first","Write for the HC&A Report, Nov 2004 edition - http://haskell.org/communities"]' by ksbot
02:55:04 <musasabi> dons: I was interpreting escape characters and times between two consecutive characters were important.
02:55:13 <ez4> does haskell have a physical equality predicate?
02:56:06 <musasabi> nothing generally usable/portable
02:57:05 <ez4> thanks.  i think i can get by without it.
02:57:56 <musasabi> but look at System.Mem.StableName ;)
03:02:07 <ez4> identity hashing is tough on the gc.  i'd rather just have === for a simple pointer comparison.
03:06:10 <musasabi> well that would have to be in IO
03:11:35 <ez4> oh, in IOExts.  i didn't realize that it would be unsafe because of lazyness.
03:22:00 <musasabi> Anyone know why buddha dies with files referencing IORefs ?
03:22:27 <musasabi> buddha 1.2 :ERROR: attempt to open file failed because: "/home/e/proj/WebCont/hirc/UI/Buddha/Data.IORef.i" does not exist "/usr/local/share/buddha/ifaces/Data.IORef.i" does not exist
03:28:11 <Lemmih> Maybe Data.IORef.i is missing.
03:28:13 <musasabi> hmm seems like it doesn't support hierarchical modules.
04:21:31 <musasabi> Would it be possible to create hat-ghc6 which would work with the debian ghc 6.2.2 ?
04:28:40 <xkb> Im having a really odd problem with wxHaskell
04:30:13 <Lemmih> xkb: How so?
04:33:56 <xkb> When I start an application
04:34:03 <xkb> it shows a window
04:34:09 <xkb> but I cant focus it
04:34:12 <xkb> on mac osx 
04:34:21 <Lemmih> Weird.
04:37:17 <xkb> It does show in expose
04:37:35 <xkb> im using the binary package
04:40:04 <TheHunter> good morning everybody.
04:40:43 <xkb> hi
04:41:44 <xkb> ah fixed it
04:42:38 <TheHunter> @hello
04:42:38 <lambdabot> Hello world. 
04:42:38 <ksbot> Hello world. 
04:48:24 <earthy> @ksbot
04:48:24 <lambdabot> Sorry, I don't know the command "ksbot", try "lambdabot: @listcommands"
04:48:24 <ksbot> Sorry, I don't know the command "ksbot", try "ksbot: @listcommands"
04:48:32 <earthy> owh, goody
04:48:47 <earthy> ;)
04:48:58 <kosmikus> ;)
04:49:32 <kosmikus> shapr: if you're there -- I think I've fixed TopicModule ...
05:11:44 <shapr> kosmikus: cool!
05:11:53 <shapr> kosmikus: send me an updated module?
05:15:28 <kosmikus> shapr: soon
05:15:32 <shapr> ok
05:15:43 <shapr> greetings Si\ 
05:15:46 <Si\> hello
05:16:23 <shapr> how's generics treating you?
05:16:34 <Si\> very well, but I still think that we need semantics
05:17:23 <Si\> I managed to get through to Ralf, but he doesn't understand what I meant
05:18:04 <Si\> does anyone understand what I mean?
05:18:06 <shapr> maybe you could code up an example?
05:18:21 <shapr> I don't understand what you're saying, but that may be because I'm short on sleep.
05:19:17 <dons> shapr: you're short on sleep? no .. really?
05:20:04 <shapr> it's that whole work code in the morning, fun code at night thing.
05:21:07 <Si\> Look at it this was, currently SYB works by looking at the type syntax alone
05:21:45 <Si\> I want to be able to link semantic (and other) data to a type, so that the processor can reason what it is
05:21:49 <Si\> and how to handle it
05:22:06 <shapr> like what?
05:22:20 <shapr> can you give me a simple example of semantic data to link to a type?
05:22:51 <Si\> Right, we define a piece of semantic data as a triple; (Type, PropertyName, Value)
05:23:10 <Si\> where Value is dynamically typed
05:23:47 <Si\> So lets say I have a data-type called MyType, which when serialized to another data system should have the type x
05:24:15 <Si\> so we define (MyType, "other-system-type", toDyn x)
05:29:20 <shapr> what do you do with it?
05:29:35 <shapr> what other data system is it serialized to?
05:32:53 <shapr> Si\: I want to understand, but I'm pretty lost at the moment :-)
05:33:24 <Si\> have you ever used prolog?
05:33:54 <Si\> or RDF? Or any language which involves axiomatic declarations?
05:36:44 <xkb> does anyone here know the pubs db?
05:36:57 <xkb> its mentioned in the wxhaskell examples
05:41:51 <shapr> Si\: I have not used prolog, and I don't know if I've used axiomatic declarations.
05:43:44 <Si\> an axiom is just a fact about something
05:43:53 <shapr> ok
05:44:28 <shapr> xkb: isn't that the standard demonstration MS Access database?
05:45:04 <xkb> ah.. I thougt it was somekind of haskell library
05:45:47 <Si\> so I could store the fact about a type "wage-field" => "employeeWage", which would assert that the field of a particular type which stores the wage is "employeeWage"
05:46:08 <Si\> the query engine would then know for that data-type where the wage should be retrieved from
05:46:31 <Si\> which is harder to do if you're just using the Data class functions to query field names
05:48:49 <shapr> that example sounds like accessor functions 
05:49:23 <shapr> class WageSlave where getWage :: a -> Wage
05:50:08 <shapr> instance WageSlave Employee where getWage (Employee _ wage@x _) = wage
05:52:04 <Si\> exactly, but softer and more expandable
05:53:23 <shapr> so, how does that triple fit into the accessor idea?
05:53:28 <Si\> because you can't mixed type classes and generics
05:53:57 <shapr> (WageSlave, Wage, Integer) ?
05:54:35 <Si\> sort of
05:55:13 <Si\> idea is you have a class;
05:55:37 <Si\> class MetaData a where
05:55:37 <Si\>     properties :: a -> [(String, Dynamic)]
05:55:48 <Si\> (except an FM instead of a list)
05:56:06 <Si\> and various functions for query data in a types meta-database
06:00:41 <shapr> can you already do this?
06:00:57 <Si\> what do you mean?
06:01:24 <Si\> It's not complicated to implement if that's what you mean.
06:01:33 <Si\> Have you read SYB1?
06:02:52 <Si\> think of the wage example;
06:02:54 <Si\> -- Increase salary by percentage
06:02:54 <Si\> increase :: Float -> Company -> Company
06:02:54 <Si\> increase k = everywhere (mkT (incS k))
06:03:16 <Boegel> hello everyone
06:03:27 <shapr> I read it, but I can't remember much about it right now.
06:03:28 <shapr> hoi Boegel 
06:03:37 <Si\> Suppose you can't find where the wage is for an employee just by looking at the type-signature alone
06:03:48 <Si\> so you use semantic data to figure it out
06:03:55 <Boegel> matteo, are you a girl ?
06:04:26 <matteo> hem, i'm afraid not
06:04:56 <matteo> matteo == mat in english
06:05:04 <Boegel> oh, because your whois says joke@host... and my girlfriends's name is joke :)
06:05:20 <matteo> so you are from Nederlands
06:05:22 <matteo> :)
06:05:25 <Boegel> yeah, I know, but still ;)
06:05:31 <Boegel> what does that 'joke' mean then ?
06:06:04 <tromp> he doesn't get the joke:)
06:06:05 <matteo> it's my nick name, and it means that i'm more like a joke that an human being. But today is just a nick name
06:06:18 <matteo> tromp: : ;)
06:06:58 <shapr> Si\: how can you use semantic data to figure out where wage is?
06:07:14 <Si\> <Si\> so I could store the fact about a type "wage-field" => "employeeWage", which would assert that the field of a particular type which stores the wage is "employeeWage
06:07:31 <Boegel> matteo: oh, like that :)
06:07:51 <Boegel> I know my girlfriend's name sounds funny in English, but it's normlal around here
06:08:01 <xkb> what a joke
06:08:15 <xkb> so the joke's on you?
06:08:19 <xkb> ahum
06:08:25 <xkb> enough allready :)
06:08:59 <Boegel> xkb: ok, that was it, stop it now :p
06:09:10 <Si\> instance MetaData StdEmployee where
06:09:10 <Si\> 	properties _ = listToFM [("wage-field", (toDyn "employeeWage"))]
06:09:46 <shapr> Boegel: of course my name "shae" is said the same way as "tjej" in swedish. Tjej means "girl"
06:10:21 <Lemmih> Isn't girl 'flicka'?
06:11:07 <Boegel> shapr: funny :)
06:11:09 <shapr> I sometimes wonder how the swedes feel about someone with wide shoulders and decent muscles meeting them and saying, "Hi, my name is Girl"
06:11:17 <Boegel> but then again, who knows swedish :p
06:11:28 * Boegel laughs
06:11:44 <shapr> Lemmih: ok, good point. Flicka is young female, and tjej is just 'female' I think.
06:12:43 <kosmikus> how can I reverse a list in bash?
06:16:33 <Boegel> so shapr: your name is Female :)
06:52:28 <Boegel> tintin, are you the one who tried out my raytracer, but I wouldn't work ?
06:57:08 <matteo> do you know a text/book/article where it is compared the way to think about list in haskell and in a procedural programing language? I'm struggling with the use of lists in Haskell (my previous background is only procedural). For example I consider a normal thing to store the result of a loop in a list. This seems to be not canonical in a recursive function in Haskell
06:57:48 <matteo> (a partial result I mean, not the end result)
06:58:02 <kosmikus> there are many recursive functions that return lists in Haskell
07:00:27 <matteo> kosmikus: I'm trying to produce a list with the intermediate result of a function (for example the always-for-beginners factorialization) in a list. I would use normally a variable in a loop and i would store the intermediate values of this variable in a list
07:01:25 <Boegel> matteo, you should add a element to the list _at the front_ of the list, instead of the back of the list...
07:01:35 <Boegel> that makes it a lot easier
07:02:02 <Boegel> factorize (x:y:rest) = factorize ((x*y) : x : y : rest)
07:02:05 <Boegel> (something like that)
07:03:37 <matteo> Boegl: ok, let me try to see if i can think in this way. Thanks for the hint
07:04:29 <Boegel> np
07:04:43 <Boegel> the syntax won't be a 100%, but it will look like that
07:06:35 <Boegel> matteo: don't forget the function won't stop... so I'm not sure how you will be able to test it :)
07:11:56 <matteo> Boegel: I'm going to use a pattern matching to stop it, something like factorize (x:xs) = if x == 1 then 1
07:13:54 <tromp> try scanl (*) 1 [1..]
07:14:13 <tromp> gives a list of factorials
07:14:19 <Boegel> @eval take 5 (scanl (*) 1 [1..])
07:14:19 <lambdabot> (line 1, column 16):
07:14:19 <lambdabot> unexpected "*"
07:14:19 <lambdabot> expecting simple term
07:14:25 <Boegel> damn :p
07:14:33 <Boegel> too hard for lambdabot
07:14:40 <tromp> too hard for lambdabot; use higs or ghci
07:14:50 <Boegel> tromp: I was just trying ;)
07:16:27 <matteo> tromp: I've read documentation about it but I prefer to learn on simple exercises like those one. So, no use of syslibs ;)
07:16:44 <matteo> ups, that one
07:17:03 <kosmikus> @eval scanl (\x y -> x * y) 1 [1,2,3,4,5]
07:17:33 <lambdabot> [1, 1, 2, 6, 24, 120]
07:17:35 * shapr wonders how many people are using lambdabot in private messages =)
07:17:37 <Boegel> kosmikus: lambdabot is doing some heavy math :)
07:17:40 <shapr> @eval take 5 (scanl (\x y -> x * y) 1 (enumFrom 1))
07:17:54 <shapr> something about enumFrom 1 seems to really slow down lambdabot
07:18:07 <Boegel> wierr
07:18:13 <Boegel> s/weirr/weird
07:18:18 <lambdabot> out of fuel - use @resume to continue
07:18:24 <kosmikus> shapr: that's what I tried, but it didn't work
07:18:24 <xkb> @resume
07:18:28 <Boegel> :)
07:18:29 <shapr> @eval take 5 (scanl (\x y -> x * y) 1 (enumFromTo 1 9))
07:18:30 <desrt> how. kosmikus is here
07:18:36 <Boegel> out of fuel :>
07:18:36 <desrt> *woh
07:18:37 <kosmikus> hi desrt 
07:18:45 <desrt> hey :)
07:18:48 <kosmikus> I'm always here ;)
07:18:52 <desrt> the ebuild was successful
07:18:53 <shapr> desrt: y0, I saw your name on a research paper yesterday.
07:19:05 <lambdabot> out of fuel - use @resume to continue
07:19:05 <desrt> shapr; cool :)
07:19:05 <shapr> @hello
07:19:05 <lambdabot> [1, 1, 2, 6, 24]
07:19:05 <lambdabot> Hello world. 
07:19:08 <shapr> wtf
07:19:21 <desrt> shapr; where did you see it?
07:19:21 <kosmikus> desrt: which ebuild?
07:19:27 <shapr> @eval take 5 (scanl (\x y -> x * y) 1 (enumFromTo 1 6))
07:19:27 <lambdabot> [1, 1, 2, 6, 24]
07:19:31 <desrt> kosmikus; ghc with my patches
07:19:34 <shapr> man, something seriously weird going on.
07:19:53 <kosmikus> desrt: ok, great
07:19:55 <desrt> ie: please apply :)
07:19:58 <kosmikus> shapr: got my patch?
07:20:02 <shapr> er, no?
07:20:05 * shapr checks email
07:20:56 <kosmikus> desrt: post the appropriate info to bugzilla; I prefer to leave changes that affect ppc and other arches to other people
07:21:13 <desrt> kosmikus; nod.  it's there in chris white's bug
07:21:24 <shapr> kosmikus: where'd you send it?
07:21:34 <kosmikus> desrt: just saw it
07:21:37 <desrt> i'm feeling quite singular.  as it turns out, i'm the only person on earth who actually wants to run ghc on powerpc linux :)
07:21:38 <kosmikus> shapr: five minutes ago?
07:21:42 <shapr> to where?
07:21:58 <kosmikus> shae at scannedinavian dot org
07:22:15 <shapr> ah, ok
07:22:20 <Boegel> who was it again who mentioned my mail adres here ?
07:22:24 <shapr> weird, it should be here by now.
07:22:28 <Boegel> I've been getting tons of spam ever since
07:22:41 <desrt> boegel@hotmail.com !!!
07:23:16 <desrt> (it wasn't me, it would seem)
07:23:24 <shapr> Boegel: the current email system is totally broken!
07:23:29 <Boegel> that's my old adres, I never use that ;)
07:23:30 <shapr> but I have a plan!
07:23:38 <Boegel> shapr: idd, spam everywhere :(
07:23:49 <desrt> shapr; be like knuth
07:23:55 <Boegel> I think it was TheHunter, but I'm not sure
07:23:56 <shapr> desrt: write tex?
07:24:08 <Boegel> shapr: what's your plan ?
07:24:17 <desrt> shapr; stop using email in 1990 and never use it since
07:24:29 <shapr> http://www.scannedinavian.org/~shae/antispamserver.html
07:24:34 <kosmikus> shapr: ah no, sent it to "dot org" ... does that work as well?
07:24:37 <shapr> desrt: bah, that's a copout.
07:24:42 <shapr> kosmikus: probably
07:24:44 <kosmikus> shapr: arg, com, I mean
07:25:02 <shapr> .net probably doesn't work
07:25:21 <desrt> interesting proposal, shapr
07:25:26 <kosmikus> shapr: knuth does use email, he just doesn't have his own account
07:25:44 <kosmikus> desrt ^^
07:25:46 <desrt> kosmikus; the best you can do is email his secretary
07:25:47 <kosmikus> I should learn using irc
07:26:08 <shapr> desrt: I wasn't the first one to think up the general idea, dj bernstein came up with im2000. But no one has tried to actually implement it.
07:26:13 <kosmikus> yes, but that usually works if you have something important to say
07:26:39 <desrt> he only sees the mail if you've found a bug in tex or an error in one of his books
07:26:54 <desrt> otherwise the secretary tosses it
07:30:21 <Boegel> shapr: the idea is fine, but that doesn't change the fact I have to pay al lot of attention when checking my mail
07:30:29 <Boegel> because I don't won't to remove non-spam messages
07:30:52 <desrt> just thinking... you say it works because the remote server needs to hold the spam
07:31:06 <desrt> can't the remote server just hold the spam once and return it to everyone who asks?
07:31:32 <tromp> i've written mail to knuth and gotten a reply
07:31:46 <tromp> good old snailmail...
07:31:56 * desrt smiles
07:32:07 <shapr> desrt: sure it can, but public blacklists will quickly catch that.
07:32:20 <desrt> shapr; mm.  right
07:32:27 <shapr> with more accountability built into the system, community blacklisting works
07:32:41 <shapr> another argument is, how do you get rid of spammed notifications?
07:33:02 <Boegel> white lists are good
07:33:09 <desrt> i'm in favour of cutting off the hands of the spammers
07:33:15 <Boegel> white lists, and all other mail using notifications
07:33:25 <Boegel> desrt, just the fingers will do ;)
07:33:25 <shapr> when you pick up your notifies, just get your client to put off any notifies with temp errors, and drop anything with perm errors
07:33:27 <shapr> or retry later
07:33:28 <tromp> i can't wait till all mail costs a cent
07:33:44 <tromp> and see the look on the face of the zombie owners
07:33:54 <shapr> tromp: I think that approach won't work
07:33:57 <tromp> who'll finally get a clue and clean up their systems
07:34:03 <desrt> tromp; serves them right for running windows, eh?
07:34:04 <Boegel> tromp: 0.5 cent will do :)
07:34:28 <shapr> unless you charge per-bit costs that are directly passed on down the line.
07:34:32 <desrt> shae is right though.  paying for email really won't work
07:34:38 <tromp> it wont work now cause there's no ubiquitous electonic payment system
07:34:47 <tromp> maybe in 10 years
07:34:59 <desrt> i hope the spam problem has been solved in 10 years :P
07:35:00 <tuomov> I'll stop using email when I have to pay for it
07:35:09 <shapr> same heer
07:35:17 <desrt> think about things like bugzilla
07:35:20 <shapr> I pay for my 'net connection already, why should I pay more?
07:35:23 <tromp> i'll happily pay a cent per mail to stop spam
07:35:25 <Boegel> who knows what will happen in 10 years... look at what happened the last 10 years
07:35:25 <desrt> it sends a *lot* of mail that people want to receive
07:35:32 <desrt> who pays for that?
07:35:50 <shapr> tromp: what about that antispam idea I just pasted? see any holes in that?
07:36:02 <tuomov> spammers have an armada of rooted windows boxes.. they can just crash those owners' payment system as well
07:36:08 <tuomov> s/crash/crack/
07:36:15 <shapr> one of the interesting responses to that idea was that it's a lot like RSS for email
07:36:33 <tromp> tuomov, did you just totally miss what i said?
07:36:54 <tromp> don't you think a zombie owner will notice the charges for a million spam?
07:37:12 <Boegel> shapr: the notifications are not that different from normal spam, but it would reduce the spam though
07:37:12 <tuomov> yes, but the harm is done
07:37:16 <shapr> you mean if my mother gets cracked she'll pay for the spam she sends?
07:37:19 <shapr> hmm, I dunno about that.
07:37:30 <tromp> no, the harm is minimal
07:37:42 <Boegel> shapr: you shouldn't allow your mother to get cracked
07:37:48 <tromp> awareness will rise tremendously
07:37:50 * Boegel says: "Drugs are bad, mmmmkay"
07:38:05 <shapr> Boegel: notifies are different from normal spam, first off they're smaller
07:38:18 <desrt> it's like the porn dialers
07:38:29 <shapr> second, you can easily check to see if a notify is 'valid' for multiple levels of valid.
07:38:29 <desrt> the ones that reprogram your modem to dial 1-900 numbers
07:38:29 <tromp> ppl will actually bother to properly secure their machine when every1 realizes it saves money
07:38:54 <desrt> a couple of people i know have switched to linux because their windows box got 0wned by a porndialer and they got the bill
07:39:12 <shapr> with spam, you pay for delivery, and (without special additios) you must assume that anything in the system is already valid.
07:39:42 <Boegel> desrt: use DSL, you can't get any porn dialers then ;)
07:39:48 <desrt> i have cable
07:39:52 <desrt> some of my friends still use dialup
07:40:04 <Boegel> desrt: that's really old skool ;)
07:40:17 <desrt> that's what i say
07:40:25 <desrt> these people are also running gentoo
07:40:28 <desrt> i totally fear
07:40:33 <tromp> as long as bulk email is practically free, spamming will continue
07:40:51 <desrt> tromp; not if you find and kill the spammers
07:41:02 <Boegel> desrt: kill them ? :o
07:41:03 <Boegel> :p
07:41:06 <shapr> so, put the cost of email on the sender!
07:41:08 <desrt> woh.  all of the sudden i feel like george bush
07:41:11 <tuomov> I prefer sending back puzzles that only humans should be able to solve
07:41:12 <shapr> not on the system and the receiver
07:41:36 <tromp> of course the sender shld pay
07:41:38 <Boegel> tuomov: that's not that easy :)
07:41:45 <desrt> tuomov; only useful if you mix it with whitelists
07:41:48 <shapr> tromp: did you read the url I pasted?
07:41:50 <tromp> just like snailmail
07:41:51 <tuomov> desrt: of course
07:41:58 <shapr> man, I should make a wiki page about this
07:42:02 <Boegel> and especially not when you want the system to work in the next X years
07:42:14 <desrt> tuomov; you could use those fuzzy letter pictures that you see when you sign up for stuff on the web
07:42:18 <tromp> i'll read it now, shapr
07:42:20 <shapr> I think the general principle is "push systems make spam easy"
07:42:42 <tuomov> desrt: those and other kind of puzzles as well. variety makes it more difficult for computers to make the correct answer
07:43:01 <shapr> simple text logic questions would work
07:43:24 <tuomov> but there would have to be lots of them
07:43:27 <shapr> bob and joe are friends. bob was born first. what's the name of the oldest?
07:43:36 <desrt> bob!
07:43:40 <Boegel> Im' out, taking a break
07:43:48 <desrt> problem with that
07:43:50 <shapr> or just randomize the grammar that produces these questions.
07:44:02 <shapr> desrt: what?
07:44:06 <tromp> shapr, i will still get dozens of Cheap \/lagra!! http:///blahblah    emails
07:44:10 <desrt> this would probably be done with software that the spammers also have available
07:44:19 <tromp> that are just limited to 80 chars
07:44:25 <desrt> so they'd be aware of all of the possible questions and know the expected answer
07:44:39 <shapr> tromp: if your client only shows you emails that got picked up, you'll never see 'em
07:44:59 <Boegel> shapr: he means in the notification...
07:45:06 <Boegel> *off*
07:45:10 <shapr> yes, and I mean that the notify is not the email
07:45:12 <desrt> Boegel; you don't see the notification
07:45:28 <desrt> Boegel; it's just a message to your email client to go pick up an email
07:45:29 <shapr> if your client only shows you notifies that could be picked up, that's not a problem.
07:45:33 <tuomov> if everyone had their own puzzle, that might work as well
07:45:33 <desrt> that your email client is free to ignore
07:45:38 <TheHunter> Boegel: no, i didn't, i only metioned the address i accidently sent it to, which (of course) didn't work.
07:45:43 <tromp> blacklisting is not that easy
07:45:44 <desrt> tuomov; interesting idea
07:45:55 <shapr> tromp: what do you mean?
07:46:00 <tromp> u'd have to blacklist tons of zombies
07:46:01 <desrt> so when you setup an email account you write your own puzzle
07:46:01 <tuomov> It could be as simple as "go to my home page and pick a few words here and there"
07:46:08 <tromp> and what if those zombie's get cleaned?
07:46:23 <shapr> tromp: no, you just blacklist the zombies you find, and I blacklist the zombies I find, and we share zombie lists
07:46:24 <tuomov> just like finding user/passwd to warez ftp:s :)
07:46:35 <tuomov> back in the old days
07:46:49 <shapr> tromp: time expire zombie lists?
07:46:51 <desrt> the problem is validating answers
07:47:03 <desrt> the "bob" example is particularly bad
07:47:11 <shapr> desrt: how so?
07:47:12 <tuomov> the answers should be simple
07:47:15 <desrt> since you could just send the original email back and the right answer is already contained
07:47:15 <peti> Howdy!
07:47:25 <Lemmih> Hey peti
07:47:32 <desrt> ie: if your validator did a check to see if the user said "bob" in their message
07:47:35 <shapr> desrt: not if the response requires only a single word in the subject or so
07:47:37 <peti> Writing tutorials sucks. :-)
07:47:47 <desrt> shapr; you put the bar too high
07:47:51 <TheHunter> Boegel: here's the reason: join: kehoste (~********@*******.ugent.be) joined #haskell
07:48:02 <desrt> most people want to hit 'reply' and write the answer into the body
07:48:05 <shapr> or just a "answer [  ]"
07:48:32 <desrt> shapr; most people will probably understand that the answer is "bob"
07:48:35 <Boegel> TheHunter: you're probably right :s
07:48:48 <desrt> explaining to people that they must say "answer [ sdf ]" is going to be difficult
07:48:49 <Boegel> TheHunter: sorry about that... :$
07:48:55 <shapr> desrt: good point
07:49:04 <shapr> so you'd have to pick an answer that's not already in the email.
07:49:09 <tuomov> btw, there is such an image reading based spam blocking service
07:49:16 <tuomov> once got mail from someone using such
07:49:22 <desrt> right.  something like "bob is 20.  joe is 6 years older.  how old is joe?"
07:49:42 <desrt> but then you give spammers the ability to respond to your message with a list of numbers
07:49:42 <shapr> tuomov: I swap email with at least two blind developers.
07:49:47 <peti> Discussing anti-spam measures again?
07:50:07 <shapr> yah, I'm trying to convince people that my antispam idea will actually work :-)
07:50:09 <tuomov> shapr: for that the puzzles should be text-based
07:50:16 * peti has recently found out that there is an incredibly simple solution to getting rid of spam.
07:50:19 <shapr> I think an IETF approach is best here... just write it and use it.
07:50:20 <tuomov> but it still might be difficult to them depending on the puzzle
07:50:38 <peti> Use an SMTP parser that has zero tolerance to syntax errors.
07:50:58 <tuomov> maybe they should just have to stick to good old telephone to get on your whitelist?
07:51:00 <desrt> something like "what major appliance in your kitchen is responsible for keeping food cold?"
07:51:05 <shapr> peti: problem there is that I receive email from clients with very little clue. They want to give me money, but they use stupid software.
07:51:15 <desrt> and accept and replies that contain "fridge" or "freezer" anywhere
07:51:26 <peti> shapr: No, I don't mean errors in the e-mail, I mean errors in the SMTP dialogue!
07:51:38 <peti> The spammer's bulkmail software doesn't give correct SMTP commands!
07:51:46 <shapr> that's easily fixed though
07:51:50 <tromp> it's a neat idea, shapr, but i think there's too many technological hurdles
07:51:58 <shapr> tromp: like what?
07:52:01 <tuomov> http://www.spamarrest.com/
07:52:07 <tuomov> that used image based verification iirc
07:52:16 <peti> It is flabberghasting, but it is true! Ever since Postmaster took over e-mail here, I haven't received more than 10 spam mails or so ... and that used to be dozens per day.
07:52:24 <tuomov> but you had to do it through a web interface, which is not nice
07:52:30 <peti> They usually have whitespace at the wrong places. :-) 
07:52:37 <tromp> it just breaks with the current architecture in many ways
07:52:48 <shapr> tromp: and the current architecture... work? ;-)
07:52:52 <desrt> aol's mailservers are like this
07:52:55 <shapr> I think not.
07:53:04 <desrt> i've trying having an SMTP dialog with them.  they're quite anti-social
07:53:19 <shapr> I tried to talk to postmaster, but it didn't like me.
07:53:37 <shapr> tromp: recent estimate put spam at 80% of all email sent.
07:53:45 <desrt> peti; there is another problem with this approach
07:53:49 <peti> shapr: You used the wrong syntax. :-)
07:54:07 <desrt> peti; you're supposed to be strict with what you send but permissive with what you receive
07:54:08 <tromp> no doubt it will reach 90%
07:54:13 <desrt> in terms of protocols
07:54:42 <tuomov> since I switched to reading mailing lists through gmane, 99% of my email is spam
07:54:43 <shapr> I predict spam reaches more than 99% of all sent emails in the next few years.
07:54:45 <peti> I realize it's just a matter of a few months until the spammers use better software, that doesn't have these bugs. But until then it's an amazingly effective filter because your host never even accepts the e-mail itself, the transmission is denied even before the DATA command is issued.
07:55:08 <peti> desert: What does "supposed" mean?
07:55:22 <desrt> peti; best practice?
07:55:39 <tromp> i like the camram.org solution
07:55:48 <desrt> rawr.  all this talk of spam is making me hungry
07:56:03 <peti> desrt: best practice is to accept sessions with syntax errors in the transmission dialogue?
07:56:35 <desrt> peti; it's to be permissive of things like capitalisation and whitespace
07:56:36 <shapr> tromp: that will only work if you put a cost on the bits themselves, otherwise you can work around it with a distributed spam-injection network of zombies
07:56:44 <peti> tromp: That's based on crm114, right?
07:56:49 <desrt> or choice of linefeed character
07:57:04 * peti whole-heatedly recommends crm114 for spam filtering.
07:57:04 <shapr> I don't think that postage-based solutions will succeed.
07:57:11 <tromp> what's really needed is for all the technology drivers to sit around the table and just agree on a solution to be rolled out worldwide
07:57:23 <tuomov> hmm.. maybe requiring gpg encryption and signing would be enough of a solution..
07:57:27 <shapr> or we could roll out a bunch of solutions ourselves, and see which ones suck less
07:57:38 <tuomov> just classify anything that is not signed and encrypted as spam
07:57:38 <tromp> it will probably need to co-exist with old system for 1 or 2 years
07:57:46 <peti> desrt: Why should I be permissive of it if _not_ being permissive helps me not to receive junk mail?
07:57:53 <shapr> Is this the same problem that microsoft is having with 'monocultural epidemics' ?
07:58:17 <shapr> tuomov: my clients won't send me encrypted mail, they don't know how.
07:58:33 <tromp> zombies can be slowed down a LOT with computing hashes
07:58:38 <tuomov> yeah, it's not a short-term solution unlike sending puzzles back that only requires changes at the mail server
07:58:48 <tromp> peit, it's not filtering based
07:59:00 <tromp> peti, i mean
07:59:10 <tromp> it's payment based
07:59:15 <tromp> but you pay with cpu cycles
07:59:31 <peti> tromp: Yeah, I know hashcash. But underneath it all is a crm114 backend, I think. I installed the software once and I don't they've changed that.
07:59:40 <tuomov> better support for encryption should be included in muas... of course when microsoft does that, it won't be pgp
07:59:52 <tuomov> (no, I have no idea if outlook support encryption already easily)
08:00:11 <shapr> speaking of changing entrenched protocols... I want a distributed decentralized peer to peer DNS system that allows duplicate names
08:00:13 <desrt> peti; i dont' know, and when i think about it, it's actually a pretty dumb practice
08:00:25 <tuomov> yeah, dns needs to be replaced
08:00:26 <peti> tuomov: The Windows version of PGP comes with plugins for Outlook that work pretty good.
08:00:29 <shapr> DNS names cost too much for what they do
08:00:38 <desrt> if everyone is strict about what they receive then you find out very rapidly that your implimentation is broken
08:00:42 <desrt> and fix it...
08:00:50 <desrt> which actually increases interoperability
08:00:54 <peti> desrt: That's the way I see it.
08:01:12 <peti> desrt: The only thing that worries me is that it turns out some major software has the same bug. :-( 
08:01:27 <peti> So far all legit e-mail seems to work. But who knows ...
08:01:48 <desrt> you don't want to receive mail from microsoft users, anyway :)
08:02:09 <peti> desrt: Curioiusly enough Microsoft's stuff seems to work. Just got e-mail from Simon PJ. :-)
08:02:12 * shapr tries to think of other decentralization ideas
08:02:17 <tuomov> well, not m$ home users, but there's such evil thing as corporate standards.
08:02:26 <desrt> heh.  the simons are funny people
08:02:37 <shapr> I wonder how to decentralize the assignement of IP addresses
08:02:43 <peti> I think it's cool that they work for _Microsoft_ of all things.
08:02:53 <desrt> peti; afaik they don't really work for them
08:02:53 <tuomov> you don't need ip:s
08:02:55 <peti> That really made me wonder about the company.
08:03:09 <tuomov> just make a random key for the computer
08:03:12 <shapr> or whether there's some way to build a network structure that is dynamically configurable enough to not need a finite number of addresses.
08:03:31 <desrt> peti; it's not like they're on some product team.  i think they're paid researchers
08:04:00 <shapr> anyway, I should do some work.
08:04:03 <peti> desrt: But why does Microsoft _pay_ them?
08:04:13 <desrt> peti; they have dirt on bill gates
08:04:18 <peti> hehe
08:04:23 <peti> I like that idea. ;-)
08:05:16 <peti> shapr: Good idea ...
08:05:41 <tuomov> 7quit I do it because everyone else does!
08:06:06 <desrt> mm
08:06:10 <desrt> i have an office hour in an hour
08:06:13 <desrt> so i'd better go too
08:06:15 <desrt> cheers
08:07:35 <CosmicRay> @index exitImmediately
08:07:48 <lambdabot> System.Posix,System.Posix.Process
08:50:51 * monochrom snickers
08:51:04 <monochrom> http://www.frank-buss.de/challenge/index.html  look for the Haskell entry :)
08:55:20 <musasabi> hmm home..
09:32:10 <bourbaki> moin
09:32:15 <TheHunter> moin
10:03:21 <danols> guys the haskell network module takes care of the low level error correction ?
10:03:33 <danols> assembling packets and etc ?
10:08:39 <Si\> what's the best first-order logic theorem prover for Haskell?
10:11:12 <jadrian> Si\: I'd try coq or isabelle
10:11:28 <musasabi> danols: what do you mean? (isn't that usually something network procols do)
10:12:47 <jadrian> Si\: I've tried isabelle and it's quite nice
10:13:02 <jadrian> Si\: coq, I just mentioned because people have recommended it to me before
10:13:53 <jadrian> Si\: Isabell syntax is quite close to haskell. I whish there was an adapted version to actually work with haskell :-/
10:15:10 <Si\> is coq in Haskell?
10:15:15 <jadrian> nope
10:15:24 <jadrian> O'Calm
10:15:28 <mattam> coq is not first order, and it can output haskell and caml which is the language it is written in
10:16:03 <jadrian> not 1st order? I thought it was... 
10:16:14 <jadrian> like I said I only tried Isabelle personally
10:18:09 <mattam> i mean it's high-order, with inductive types, recursive functions... What are Isabelle's foundations ?
10:20:17 <mattam> hmmm, apparently it's generic, and you can use Isabell/HOL or other logics
10:27:06 <jadrian> mattam: ah, higher-order, ok!
10:27:41 <danols> what kind of type is CInt ?
10:27:42 <jadrian> mattam: yes you can define your own logics in Isabelle and there is the HOL module
10:37:52 <danols> @type Word32
10:37:53 <lambdabot> bzzt
10:38:31 <Oejet_> @type (4::Word32)
10:38:33 <lambdabot> bzzt
10:38:39 <ski> @index Word32
10:38:39 <lambdabot> Data.Word,Foreign,GHC.Word,Word
10:39:14 <danols> ski can you give me an example ?
10:40:16 <ski> of what ?
10:40:46 <danols> acctually what is the www for pasting code ?
10:40:58 <sorje> nomorepasting.com or the haskell wiki I suppose
10:41:29 <ski> @wiki HaskellIrcPastePage
10:41:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:41:56 <sorje> @wiki foo
10:41:56 <lambdabot> http://www.haskell.org/hawiki/foo
10:43:22 <danols> ski could you take a look at http://rafb.net/paste/results/haCMwj28.html
10:43:33 <danols> the problem i have is that when I save a stream it seems to be corrupted
10:43:46 <danols> (it works for files stored on the server)
10:44:49 <danols> the only diff. I can see is that when analyzed with a packet monitor my function packets are 'http continuations' while winamps it starts fresh with http GEt...
10:45:15 <ski> (hm, btw, i haven't used Network lib very much ..)
10:45:34 <danols> ski i see
10:45:43 <ski> (why do you use \r\n, is that necessary ? wouldn't \n suffice/be better ?)
10:45:44 <danols> i was trying to figure out the problem here last night shapr was helping me
10:46:02 <danols> it's exact copy of the packet send when winamp requests a file
10:46:14 <ski> hmm
10:46:22 <danols> i downloaded a mp3 file stored on the server removed the http header and it was identical
10:46:42 <danols> but streaming seems to be corrupted (as in visual and auditory artifacts)
10:48:03 <danols> like I said the only diff. is in Ethereal in the INFO section it says GET /stream/.... for winamp (when it sends the request), while for my function it says HTTP continuation
10:48:27 <danols> suggestions would be welcomed
10:49:42 <ski> hm, sorry, i don't think i know too sufficiently here to be helpful ..
10:50:52 <danols> ski i'll try your suggestion with \r\n
10:53:31 <ski> (also not quite sure why you do "print stream" ..)
10:53:43 <danols> ski that's just for testing
10:54:04 <danols> the only thing I can think of is that Network is to high level, and i need to use Network.Sockets
10:54:37 <ski> mayhaps
10:54:53 <danols> is there anyone here that has experiance with Network module ?
10:56:12 * musasabi has done quite a lot of UDP with Network.Socket but haven't really used anything besides readily available HTTP libraries in haskell
10:57:31 <danols> musasabi you mean the build in netwrok module or the http library you can download ?
10:58:15 <danols> nm i understand
10:58:38 <danols> ok musasabi prehaps you can help me with the syntax, i'm going to try to re-write with Network.Socket
10:59:40 <danols> socket :: Family -> SocketType -> ProtocolNumber -> IO Socket what do I put for ProtocolNumber ?
11:05:34 <musasabi> danols: I can post an example.
11:05:44 <danols> sure
11:05:58 <danols> musasabi it says HostName is a Word32 type 
11:06:16 <danols> Word32 is an unsigned int how the hell one stores "www.yahoo.com" in that ?
11:08:13 <thebug> resolve it first ... ?
11:08:21 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/Util/UDP.hs
11:08:31 <danols> thebug could you give me an example of a Word32 ?
11:08:44 <thebug> nope
11:08:46 <CosmicRay> see Network.Socket.BSD
11:09:02 <thebug> lack of knowlede on that, not lack of motivation :)
11:09:04 <CosmicRay> err Network.BSD
11:09:09 <CosmicRay> see getHostByName
11:09:13 <danols> CosmicRay ok
11:09:17 <danols> good idea
11:09:20 <CosmicRay> also
11:09:24 <CosmicRay> find a basic networking text
11:09:29 <CosmicRay> or tutorial
11:09:33 <CosmicRay> covering the C interface
11:09:45 <musasabi> do { sock <- socket AF_INET Datagram 0; addr <- getHostByName host; connect sock $ SockAddrInet (toEnum port) $ hostAddress addr; return sock }
11:09:46 <CosmicRay> you will not learn enough from the haskell reference to develop effective network apps
11:10:37 <danols> brb 
11:10:40 <danols> gotta do number 1
11:10:42 <danols> thanks musasabi
11:11:16 <musasabi> but really all the haskell network documents kind of assume that you can do network programming..
11:12:47 <danols> musasabi gotta learn somehow
11:18:50 <kristnjov> zipWith (\a b -> a ++ "   " ++ b) (tfIn circ) (tfOut circ)
11:19:12 <kristnjov> makes it like "   "++(tfIn circ)++(tfOut circ), why?
11:20:12 <kristnjov> oh nvm think i got it
11:36:12 <pflanze> Hello
11:36:51 <Lemmih> Hey pflanze
11:37:08 <pflanze> I'm a haskell newbie.
11:37:47 <pflanze> atm I'm wondering about "generic programming" and "classes" and how that really relates to OO in haskell.
11:38:25 <pflanze> From what I understand, www.generic-haskell.org is talking about what is called generic functions in CLOS.
11:38:33 <pflanze> Right?
11:39:05 <kosmikus|away> I have no idea what generic functions in CLOS are
11:39:22 <Lemmih> Neither do I.
11:39:37 <pflanze> These are the "methods" in common lisp's object programming system.
11:40:31 <pflanze> They are kind of bundles of functions with the same name, that are choosen depending on the arguments given to this bundle.
11:41:17 <pflanze> Example (in a typical Scheme OO system since I don't remember common lisp that well anymore):
11:41:55 <Lemmih> Overloading in Haskell is done via type classes which is nothing like classes in most OO languages.
11:42:08 <kosmikus|away> sounds like an ad-hoc overloaded function in Haskell
11:42:17 <pflanze> (define-generic (foo a b c) (; default body here )) 
11:42:23 <kosmikus|away> that's what type classes do, as Lemmih says ... no generic programming needed for that
11:42:56 <pflanze> then: (define-method (foo a::class1 b:othertype c)  ...)   and  (define-method (foo a::class2 b:yetanoter c)...)
11:43:11 <ski> pflanze : do generic functions decide at runtime which method to run ?
11:43:29 <pflanze> (then when you call (foo bleh blah bam)  it depends on the type of bleh and blah which method is called)
11:43:52 <pflanze> ski: depends on the system, basically yes, but some can optimize.
11:44:17 <ski> and it supports use of multi-methods ?
11:44:20 <pflanze> yes
11:44:35 <pflanze> (you mean dispatching on multiple arguments, right?)
11:44:41 <ski> yeah
11:45:04 <pflanze> CLOS does it; many object systems for scheme as well, some don't.
11:45:07 * ski doesn't know very much about multi-methods or CLOS-like systems ..
11:45:14 <Oejet_> danols: A Word32 is simply a number, e.g. x = 43, x = 2^32-1, x =3. Here x is of type Int, but you have to restrict the type by writing a type decleration x :: Word32, if it cannot infer by itself.
11:46:13 <ski> pflanze : but i'm not sure that generic stuff as in generic haskell is much related to such CLOS-like things ..
11:46:19 <pflanze> So - are classes in haskell like classes without methods (only members) in, say, C++?
11:46:24 <pflanze> (only data members)
11:46:40 <Lemmih> No.
11:46:52 <kosmikus|away> ski: as I said, the things I've heard so far have nothing to do with Generic Haskell
11:46:53 <pflanze> Or is a type class a name for a set of types?
11:47:06 <ski> they are a bit similar to abstract base classes aka interfaces
11:47:45 <Lemmih> pflanze: You can read about type classes here http://www.haskell.org/tutorial/classes.html
11:47:47 <ski> (but there are differences. e.g. multi-arg type classes, defaults ..)
11:51:20 <pflanze> In any case, it seems to me like www.generic-haskell.org is talking about kind of an object system, just calling it generics, which is unfortunate considering that this term is also used for "same code works on many data types" (C++/java generics).
11:53:20 <Lemmih> Why are you looking at generic-haskell?
11:54:15 <ski> iiuc generic in generic haskell refers to making algos that work on many types, behaving differently for different kinds of structure of the type (e.g. product,sum, etc ..)
11:54:29 <kosmikus|away> pflanze: there is an unfortunate clash of terminology between generics in languages like java and generic programming in functional programming languages, yes, but generic-haskell did not invent this terminology, and it is not talking about an object system
11:54:40 <pflanze> I didn't understand when I saw it mentioned somewhere since I "knew" that haskell is generic (in the sense of "code runs on any types for which the functions alled on them exist") out of the box.
11:54:55 <ski> (e.g. algos such as unification, generic marshalling / linearizing ..)
11:56:02 <ski> pflanze : sounds like you're thinking of type-class-style ad-hoc overloading ..
11:56:40 <pflanze> ski: no!
11:56:49 <pflanze> in the case of when I'm talking of "generic"
11:56:58 <kosmikus|away> pflanze: read the introduction of my thesis (www.cs.uu.nl/~andres/ExploringGH.pdf) if you want to know what Generic Haskell is about ;)
12:00:34 <ski> pflanze : no ? (me commented on your "(in the sense of ...)")
12:01:33 <ski> pflanze : that did sound like you thought of multiple implementations, one for "any types for which the functions alled on them exist" ..
12:01:56 <mattam> kosmikus|away: you're diubg a g'haskell ? staged computations ?
12:02:06 <mattam> s/diubg/doing/
12:02:56 <pflanze> ski: my usual terminology is this:  multiple implementations with the same name, but choosen according to types = methods. same implementation acting on a (potentially wide) range of types = generics ("template" in C++).
12:03:12 <kosmikus|away> mattam: I'm doing GH, yes, which is somewhat related to staged computations, but not to the same extent as TH or MetaML
12:03:37 <pflanze> ski: and "overloading" is similar to 'methods' but doesn't care about a type *hierarchy*, just to flat types.
12:03:50 <kosmikus|away> pflanze: that's "overloading" and "polymorphism", respectively, in Haskell
12:04:06 * kosmikus|away would love to discuss this further, but has to leave for today ...
12:04:38 <pflanze> afaik, polymorphism is used in the C++ world for runtime typing (virtual methods).
12:05:00 <pflanze> (the *term* "polymorphism")
12:05:44 <kosmikus|away> last comment: I was not precise: parametric polymorphism. Overloading is also called "ad-hoc polymorphism", genericity as in GH is also called "structural polymorphism".
12:06:07 <ski> pflanze : though there is some overlap between these two .. (e.g. mapM)
12:06:16 <pflanze> ok, thanks for your answers.
12:06:37 <ski> @type mapM
12:06:38 <lambdabot> mapM :: forall b m a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:06:42 * pflanze is keeping those comments for further study
12:07:40 <ski> pflanze : this has one implementation, but will call different monad operator depending on in which monad it is used
12:07:48 <ski> pflanze : see what i mean ?
12:09:14 <marcot> Hello, I'm having the error *** Expected type : (a -> a -> Bool) -> [a] -> [a] \n *** Inferred type : ((Int,Linha) -> (Int,Linha) -> Bool) -> [(Int,Linha)] -> [(Int,Linha)]
12:09:17 <pflanze> well, that's what I call generics.
12:09:22 <marcot> Where type Linha = String.
12:09:41 <marcot> I can't understand why isn't hugs accepting this code.
12:09:50 <pflanze> ski: it is one implementation of 'mapM' - but 'dispatches' into different implementations depending on type.
12:10:22 <pflanze> (it dispatches in the function calls it is doing itself.)
12:11:15 <Lemmih> marcot: You can post the code here http://haskell.org/hawiki/HaskellIrcPastePage
12:11:37 <kristnjov> what function should i use if i want to change [["hi","ho"],["1","2"]] to ["hi ho","1 2"]?
12:11:52 <kristnjov> been thinking about this for an hour now
12:12:18 <marcot> Lemmih: is a simple function, of quickSort, I'll post there.
12:13:13 <Lemmih> kristnjov: map concat?
12:13:20 <kristnjov> Lemmih, thanks
12:13:43 <Lemmih> Ops. map unwords
12:13:47 <kristnjov> hm
12:13:54 <kristnjov> ah yes, unwords, i knew that ;)
12:14:47 <kristnjov> ah it's good to see one
12:14:51 <kristnjov> 's program turning out well
12:18:06 <marcot> Lemmih: I've pasted it there, but it's not correctly idented. But I think that it's easy to get the indentation from the context.
12:20:35 <Boegel> ellow
12:20:41 <Lemmih> Hey Boegel
12:20:44 <marcot> I've solved my problem, but thanks anyway.
12:20:50 <Lemmih> Great.
12:22:07 <Boegel> hey Philippa
12:22:11 <Boegel> bye Philippa
12:22:12 <Boegel> :s
12:23:09 <Lemmih> What's up, Boegel?
12:23:44 <Boegel> Lemmih: eh, dunno really :p
12:24:02 <Boegel> Lemmih: I haven't worked on my ray tracer today, because I have other work
12:24:27 <Boegel> and I should go to my promotor again tomorrow, but I haven't realle something constructive to say to him, so that sucks really
12:25:01 <Boegel> brb (probably)
12:27:17 <musasabi> What would be a good way to work with locations in heterogenous trees? (like zipper)
12:30:07 <Boegel> back
12:32:52 <Boegel> pff, I'm feeling tired, while I slept over 7 hours last night
12:32:55 <Boegel> I don't get it :(
12:33:37 <ski> pflanze : no
12:56:30 <mento> hi
12:59:16 <Boegel> hi
12:59:18 <Boegel> new ?
12:59:32 <mento> quite. Just greeting :)
12:59:42 <Boegel> interested in Haskell
12:59:55 * Boegel calls shapr: we have a new one ! :p
13:00:09 <mento> he knows me
13:00:15 <Boegel> ow, no shapr at the time
13:00:23 <Boegel> oh, so you're not that new :)
13:00:25 <mento> Yea, I'm interessted until I pass the course :(
13:00:44 <joao> Hello
13:00:56 <Boegel> hello
13:01:02 <Boegel> mento, is it that bad ?
13:02:06 <mento> no no. Haskell is interessting. One Q tho. Do you know if Symbols can be part of a Datastructure like Data Expr = (&&&) Bool
13:02:30 <Boegel> no idea
13:02:31 <Lor> You can have infix constructors.
13:02:38 <Lor> Their name must begin with :
13:02:43 <mento> ok
13:02:44 <mento> thx
13:03:18 <Lor> so e.g. "data Foo = Bar :& Baz" where Bar and Baz are pre-existing types.
13:03:29 <Lor> and :& is a constructor of type Bar -> Baz -> Foo
13:03:44 <mento> thx
13:05:48 <dustin`> Is there a way to make runhugs print out cell usage and reductions upon successful termination?  I pass the +s flag to the runhugs binary, but it only shows this information if there is an interpreter error.
13:09:21 <mattam> hmmm, no 'choose' operator in Data.Set ?
13:09:54 <Lor> What would it do?
13:10:00 <Boegel> @index choose
13:10:00 <lambdabot> Debug.QuickCheck,GHC.Read
13:10:05 <jadrian> maihem: nope, I defined my own
13:10:26 <jadrian> choice :: (Ord a) => Set a -> a
13:10:27 <jadrian> choice = head . setToList
13:10:34 <jadrian> ...
13:11:01 <mattam> hmm okay, i'd better stay with lists anyway
13:11:58 <jadrian> I also wondered why that wasn't included. Sets in haskell obviously take the axiom of choice into account... so it makes sense to have it.
13:12:11 <Lor> Errr...
13:12:26 <jadrian> well it requires  an Ord instance
13:12:28 <joao> Sets in Haskell have a big problem (I don't know any solution, unfortunately)
13:12:38 <Lor> You want a function that returns an arbitrary member of a non-empty set?
13:13:21 <jadrian> Lor: I think that's what he want... at least that's what I implemented for myself.
13:13:29 <jadrian> Lor: not really "arbitrary" though ;)
13:14:00 <joao> It's impossible to make Set instance of Functor, isn't it?
13:14:01 <dustin`> Lor: They could just make every set have a well ordering =)
13:14:11 <jadrian> dustin`: they do
13:14:22 <dustin`> jadrian: Then the axiom of choice is implied
13:14:32 <jadrian> dustin`: that's what I said! :)
13:14:43 <dustin`> jadrian: Oh, its been a long day.
13:15:06 <jadrian> dustin`: actually we need a little more then the Axiom of Choice, because we need that function to be computable
13:15:10 <jadrian> dustin`: and it is
13:15:42 <jadrian> dustin`: we even have setToList so you just need to take the head
13:16:06 <dustin`> jadrian: Now all that is left is to express R in haskell, and then print out the well ordering =)
13:16:19 <mattam> Lor: that's what i wanted indeed
13:16:26 <Lor> Why?
13:16:40 <jadrian> dustin`: print out it's probably not a good idea :D
13:17:40 <mattam> because my algo can work like this : 'repeat choose an object in S, use it, remove it from S until S is empty'
13:18:08 <jadrian> mattam: just use setToList
13:18:20 <jadrian> mattam: that creates the list of all elements of the set
13:18:27 <mattam> i have lists actually, so using standard recursion will do
13:18:28 <jadrian> mattam: and then work over that list
13:18:56 <jadrian> mattam: you don't even need to "remove" anything
13:19:13 <Lor> mattam, you need a fold.
13:19:20 <jadrian> mattam: depending on what you mean by use it, it can be a fold or something like that
13:19:20 <mattam> that's what i use :)
13:19:23 <Lor> For some reason Data.Set does not seem to provide a fold directly.
13:19:37 <Lor> In Edison every data structure has a gazillion different folds.
13:19:49 <jadrian> Lor: fold for sets doesn't make much sense...
13:20:09 <Lor> The ordering is arbitrary, granted.
13:20:31 <Lor> But that's what mattam is trying to do: get the elements of the set in some arbitrary order.
13:20:36 <jadrian> Lor: not really order, but structure
13:20:39 <mattam> caml uses ascending/descending orders for Set.fold
13:20:58 <jadrian> Lor: folds work over some structure
13:21:11 <Lor> Well yeah.
13:21:12 <joao> <jadrian> Lor: fold for sets doesn't make much sense...  <-- why not?
13:21:50 <jadrian> joao: because when working with sets you should not assume a particular structure
13:21:58 <jadrian> joao: and you need structure for folds
13:22:11 <Oejet_> joao: How would your order the elements before applying the operator?
13:22:27 <mattam> sets are 'ensembles' with an order here
13:22:42 <mento> Lor: How do I call the infix construcor later if I have data Foo = Bar :& Baz ?
13:22:43 <joao> Oejet_, why do you need to order the elements?
13:22:43 <mattam> aren't they ?
13:23:03 <Lor> somefoo = somebar :& somebaz
13:23:25 <mento> is there a way of avoiding : in main ?
13:23:27 <ski> mento : like   "someBar :& someBaz"  or  "(:&) someBar someBaz"
13:23:44 <ski> mento : huh ?
13:23:50 <mento> I'd like to write False & True
13:24:03 <mento> instead of False :& True
13:24:09 <joao> fold (+) 0 {1,2,3} doesn't make sense?
13:24:30 <Lor> It does, but only because + is associative.
13:24:39 <Lor> commutative, I mean.
13:24:45 <ski> mento : (&) = (:&)
13:25:08 <Lor> The only real benefit of infix constructors is that you can use them in pattern matching.
13:25:17 <jadrian> joao: that is to easy
13:25:26 <Lor> Since it is trivial to give an infix alias to a non-infix constructor for _building_ values.
13:25:35 <jadrian> joao: what about, fold (-) 0 {1,2,3}
13:25:49 <jadrian> joao: what is the result of that?
13:26:11 <jadrian> joao: but it's even worst than that, you are just thinking about Lists
13:26:30 <mattam> (1-2)-3 ? Why not assume the folds _use_ the order ?
13:26:44 <jadrian> joao: Lists have a linear structure
13:26:54 <joao> Well, Sets also assume Ord a, when they only need to assume Eq a
13:26:54 <mattam> i made an error, but nm :)
13:27:00 <jadrian> joao: but a fold over trees is quite different for instance
13:27:07 <joao> That's an implementation limitation
13:27:21 <jadrian> joao: kind of 
13:27:29 <mattam> joao: oh really ? and is Eq a necessary for lists ?
13:28:01 <joao> mattam, what do you mean?
13:28:09 <jadrian> joao: the Ord requirement is obviously because of efficiency issues
13:28:17 <joao> jadrian, Set's are implemented as balanced trees
13:28:22 <mattam> nm
13:28:44 <ski> ideally, a fold for Sets should take a folding operation such that the particular order/structure of the Set and fold implementation doesn't matter
13:28:49 <jadrian> joao: still one can always argue that since you want to be able to retrieve those elements, then the axiom of choice is valid
13:29:23 <mattam> the problem is that i'm used to O'Caml sets, which also have min_element and max_element
13:29:32 <jadrian> joao: and if the axiom of choice is valid then you can have them well ordered
13:29:46 <jadrian> joao: so there is no harm in requiring ord :)
13:30:02 <ski> (so i think the operation should be associative and commutative, and the base element should be a unit for the operation. maybe the operation should be idempotent also ?)
13:30:18 <joao> jadrian, but if they didn't require it, we should be able to write Sets as instance of Functor
13:32:12 <ski> the Ord requirement is just an artefact of the implementation
13:32:24 * mattam just finished debugging his first-order inference engine :) now to Damas-Milner-Tofte!
13:32:52 <ski> first-order as in not polymorphic ?
13:33:01 <mattam> yep
13:33:38 <ski> with explicit typings of introduced variables ?
13:33:47 <mattam> nope
13:33:49 <ski> (like in lambdas ..)
13:33:58 <mattam> that would be too easy
13:34:04 <mattam> Church was a cheater
13:34:11 <ski> why ?
13:35:03 <mattam> that was a joke :)
13:35:25 <mattam> he introduced explicit typing of introduced variables
13:35:25 <jadrian> actually you can declare Set as instance of Functor... you just cannot define it properly
13:35:32 <jadrian> :)
13:36:27 <joao> jadrian, how?
13:36:40 <jadrian> instance Functor Set where fmap = undefined
13:36:56 <jadrian> but that is because the definition of the type Set doesn't require the argument to belong to Ord
13:37:02 <jadrian> which I personally don't like...
14:01:06 <Lemmih> So what's going on in Haskell world?
14:02:16 <Boegel> not much aparantly :)
14:02:31 <Boegel> +p
14:03:06 <Lemmih> That's too bad /-:
14:03:27 <Jan_w> hehe
14:03:41 * Jan_w is happyly coding away :
14:04:04 <Jan_w> solving all kinds of funny puzzles in haskell :)
14:04:48 <danols> are there helper functions to conver char to it's int and back ?
14:05:01 <Lemmih> @type Char.ord
14:05:03 <lambdabot> Char.ord :: Char -> Int
14:05:12 <Lemmih> @type Char.chr
14:05:13 <lambdabot> Char.chr :: Int -> Char
14:05:29 <danols> i need to import prelude ?
14:05:46 <Lemmih> Importing Char is a good idea.
14:06:01 <Lemmih> I'm not sure if the Prelude is exporting those functions.
14:06:28 * Lemmih should be busy hacking database code.
14:10:35 * Boegel goes to sleep and greets the crowd
14:12:51 <nTfirewall> whats the website for pasting haskel queries
14:16:28 <nTfirewall> http://www.nomorepasting.com/paste.php?pasteID=23629 < could someone please tell me what am i doing wrong in this inssort function
14:20:15 <tromp> otherwise case loses x
14:20:54 <tromp> you reduce ur list to increasing subsequence
14:21:45 <nTfirewall> are you talking abt insert function 
14:22:18 <tromp> yep
14:22:47 <tromp> u want x:(insert a xs)
14:22:52 <nTfirewall> are you saying it should be insert a x:xs ?
14:23:03 <nTfirewall> in otherwise case
14:23:05 <tromp> no, that'd be an infinite loop
14:23:44 <nTfirewall>  ohh i see what you mean
14:23:46 <nTfirewall> thanks :)
14:25:09 <tromp> yw
14:27:37 <Jan_w> would using regex's be an efficient way to split a sentence into words ? (seporate all elements surrounded by spaces? ) In perl, i could just change the seporator-matching does haskell have anything like it ?
14:28:10 <tromp> try using the function words
14:28:38 <tromp> @index words
14:28:39 <lambdabot> Data.List,Prelude,List
14:28:50 <Jan_w> in list, checking
14:29:12 <tromp> @eval words "in list, checking"
14:29:12 <lambdabot> unbound variable: words
14:29:25 <Jan_w> tsss
14:29:28 <shapr> musasabi: got a moment?
14:29:34 <Jan_w> haskell is cool :)
14:29:36 <tromp> @eval Data.List.words "in list, checking"
14:29:37 <lambdabot> <<EM Dynamic -> EM Dynamic>>
14:29:40 <Jan_w> (again)
14:29:41 <shapr> truly, Haskell is cool.
14:30:02 <tromp> haskell, always one step ahead of you:-)
14:30:03 <CosmicRay> hmm.
14:30:09 <shapr> CosmicRay: y0
14:30:09 <CosmicRay> lambdabot will evaluate random things?
14:30:15 <shapr> CosmicRay: not exactly
14:30:26 <Jan_w> tromp: it's making my live easier every day :)
14:30:30 <CosmicRay> rats, I was going to hve fun with lambdabot :-)
14:30:49 <CosmicRay> give myself a shell or something :-)
14:30:57 <musasabi> shapr: yes, but I have to go quite soon.
14:31:00 <CosmicRay> @eval 3 + 5
14:31:00 <lambdabot> 8
14:31:16 <CosmicRay> @eval map (+ 5) [1, 2, 3]
14:31:16 <lambdabot> (line 1, column 6):
14:31:16 <lambdabot> unexpected "+"
14:31:16 <lambdabot> expecting simple term
14:31:19 <shapr> musasabi: Ehud Lamm posted about the eDSL vs UML controversy on LtU
14:31:44 <CosmicRay> @eval ((3 * 2) + 5)
14:31:44 <lambdabot> 11
14:31:50 <tromp> lambdabot shld learn (+), (*), ... next
14:31:51 <shapr> musasabi: I had the idea that I could mention your self-drawing arrows as both at once. Do you think that's an accurate description?
14:32:02 <CosmicRay> @eval ((+) (3 * 2) 5)
14:32:03 <lambdabot> (line 1, column 3):
14:32:03 <lambdabot> unexpected "+"
14:32:03 <lambdabot> expecting simple term
14:32:10 <CosmicRay> lispers would take offense at that :-)
14:32:21 <CosmicRay> hmm.
14:32:23 <CosmicRay> @eval +
14:32:23 <lambdabot> (line 1, column 1):
14:32:23 <lambdabot> unexpected "+"
14:32:23 <lambdabot> expecting white space or simple term
14:32:34 <CosmicRay> @eval read "5"
14:32:34 <lambdabot> unbound variable: read
14:32:39 <shapr> CosmicRay: it's not really haskell, it's a lambda calculus interpreter.
14:32:53 <CosmicRay> and yet it has access to the library?
14:33:07 <shapr> no, it doesn't
14:33:23 <shapr> just that implementing a simple Haskell-like language on top of lambda cal is pretty easy :-)
14:33:29 <CosmicRay> heh
14:33:47 <shapr> @get-definition fold
14:33:47 <lambdabot> fold not defined
14:33:48 <musasabi> shapr: well they are more like a DSL gone wrong ;)
14:33:49 <Jan_w> is there an unwrap function ?
14:33:49 <shapr> @get-definition foldr
14:33:49 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
14:34:05 <CosmicRay> shapr: bummer, I was going to explore System.Posix next :-)
14:34:22 <shapr> musasabi: hm, I was thinking they're something of both a DSL and a modeling language. Is there anything obviously wrong with that statement?
14:34:30 <tromp> is it typed or untyped interpreter?
14:34:52 <shapr> musasabi: was your original idea that arrows could 'draw themselves'
14:35:18 <musasabi> a modelling language is a DSL.
14:35:43 <musasabi> now normally one models a problem with a modelling language and then implements it in a host language.
14:35:45 <shapr> sure, but it seems like your idea was going in the direction of arrows that could spit out their own graphviz model
14:36:06 <musasabi> with self drawing arrows we have a DSL which serves the double purpose of modelling itself.
14:36:10 <shapr> heh
14:36:15 <shapr> right, exaccly
14:36:19 <shapr> that's what I want to post about.
14:36:52 <shapr> that doesn't cover the UML "programmer" crowd, but it does cover the UML "blueprint" crowd
14:37:30 <musasabi> true.
14:37:38 <shapr> I'll write up a short post about that then, even though I still don't understand the problem you had with it.
14:38:06 <shapr> I suspect I'll understand the first <-> arr fst problem once I have some serious sleep and a few hours to play with it.
14:38:30 <musasabi> well the problem is just that even if we know what happens between arrows we don't know what happens inside arbitary functions.
14:39:01 <shapr> oh, Benjamin Lerner wrote a neat paper on proving the arrow laws for Yampa, and found some interesting optimizations in the process. The conclusions section of his paper seems to possibly connect with some of what you've said about SPArr
14:39:18 <shapr> even if you lift the arbitary functions into arrows?
14:39:21 <musasabi> mainly "arr snd" and "arr fst" - both drop one dataflow but that is impossible to see from the arrow level (maybe with some type based trickery?)
14:40:10 <musasabi> btw the yampa arrows become nicer with GADTs
14:40:21 <shapr> yah, Henrik just mentioned that on the Yampa list.
14:40:50 <shapr> have you written any code that shows the difference with GADT signal functions?
14:41:10 <musasabi> well I have some GADT arrow examples around
14:41:26 <shapr> could I see them?
14:41:28 <Igloo> Does anyone know if GADTs are the feature Omega is designed to explore?
14:42:59 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/Al.hs (very basic)
14:43:40 <shapr> neato
14:44:42 <shapr> that is a weird and nifty arrow example
14:45:57 <shapr> musasabi: thanks, I'll write up SPDraw on LtU, and hopefully won't say anything completely wrong.
14:47:20 <musasabi> ok, I think I'll try sleeping for a while.
14:47:22 <musasabi> ->
14:47:22 <shapr> :-)
14:47:30 <shapr> good idea
14:56:35 * shapr boings
14:57:27 * Oejet_ gets squashed by shapr.
14:57:39 <Lemmih> What does 'boing' mean?
14:58:45 <Lemmih> Is it just a random expression of excitement?
14:59:10 <shrimpx> Igloo: two things, I believe. GADT and staged computation
15:00:41 <shapr> Lemmih: er, it's the noise a cartoon character makes when jumping, I think. *boing* *boing* *boing*
15:00:47 <Igloo> Cool, ta
15:01:23 <Lemmih> Oh,
15:03:19 <shapr> I think it's also the name of the noise a spring makes when one side is thoroughly attached to something like a wall, and you pull it to one side and let go. *boooooing*
15:03:56 <shapr> Lemmih: any news on Hackage?
15:04:53 * shapr wonders if Simon Marlow would accept darcs patches for Haddock
15:05:03 <Lemmih> Not really. I just realized that it doesn't contain any comments at all so that's what I'm working now (-:
15:05:14 <shapr> that's understandable.
15:07:09 <Lemmih> But my mail didn't get as much attention as I had hoped for.
15:08:37 <Lemmih> Hello np_hard.
15:09:08 <shapr> Lemmih: alternatively, I could install hackage on haskell.org
15:09:17 <shapr> not sure when I'll have time though.
15:09:31 * shapr wonders if he'll become admin of haskell.org at some point
15:10:45 <Lemmih> I don't think hackage is ready for that.
15:10:47 <shapr> I asked John Petersen about installing hsql and haskelldb on haskell.org, and he said "sure"
15:11:46 <shapr> well, what does it need for use on haskell.org?
15:12:26 <Lemmih> Prettier templates (-:
15:16:31 <shapr> why not just stick it up there, and let people submit patches for stuff they don't like?
15:16:36 <Lemmih> But then again. Installing it would probably cause some attention.
15:17:20 <shapr> if you switch to using darcs, I can even automate the patch and build process so that I never have to look at it again.
15:17:40 <shapr> except for darcs upgrades of course
15:17:47 <shapr> and adding new gpg keys
15:17:58 <Lemmih> Great.
15:18:32 <shapr> actually, I might be able to set it up such that some people can add to the key ring. Hmm.
15:19:27 <shapr> Igloo: what's the advantage of your regexp lib over others?
15:19:45 * shapr wonders why haskell.org isn't using debian
15:20:06 <mattam> what is it using ?
15:20:10 <shapr> redhat I think
15:20:47 <mattam> isn't it some 'far away' server ?
15:20:52 <shapr> it's at yale.
15:20:57 <Igloo> shapr: Which others?
15:20:58 <Lemmih> Can I use darcs when I can't send mail directly from my computer?
15:21:14 <shapr> Lemmih: yes, via ssh, or just locally.
15:21:24 <Igloo> Can anyone tell me if they get undefined references with this please? echo 'main = putStrLn "Foo"' > q.hs; nhc98 -t q.hs
15:21:30 <shapr> Igloo: like the standard regex lib, or chilli's CTK regex stuff?
15:21:50 <Igloo> Preferably both someone on Debian and someone not
15:22:01 * shapr wants an hs-plugins deb
15:22:15 <shapr> dons: hey, is there an hs-plugins darcs repo?
15:22:19 <Igloo> shapr: Test.Regex? It doesn't exist on nhc and isn't lazy. Oh, and can't be extended to REs on [Foo]
15:22:24 <Igloo> Haven't seen Chilli's
15:22:40 <shapr> REs on [Foo] ?
15:22:48 * shapr grabs Igloo's lib and looks
15:23:24 <shapr> does this repo stay current? --> http://urchin.earth.li/darcs/ian/regexp
15:23:51 <Igloo> You could ask if [True, False, False] matches "^{True}{False}*$"
15:23:56 <Igloo> Yes
15:24:51 <shapr> chilli's fast lazy lexer paper does some regex stuff, and the code is in CTK (and the ctklight debian package)
15:25:36 <shapr> it's pretty sexy, as it lazily builds the whole regex
15:26:13 <shapr> want url to the paper?
15:27:34 <shapr> HTests.hs is screaming out for QuickCheck =)
15:27:44 <Igloo> I don't think the CTK one is going to allow capturing parens, and it looks like it's prretty well woven in to the lexer
15:28:01 <Igloo> QCing it is difficult
15:28:18 <shapr> capturing parens?
15:28:31 <Igloo> It's not /so/ bad for when you want to check things match,but useful checks of things that dont match is hard
15:28:57 <Igloo> match "a(.*)b" "axyzb" == Just ["xyz"]
15:28:58 <shapr> I've been thinking about that with QC
15:29:08 <shapr> I think shrink can be used for that.
15:29:36 <Igloo> And if you've got them then you can also add backrefs easily, I think. So I'll probably add that and then add another frontend for BREs
15:29:42 <shapr> I think shrink can be used to do anti-tests or 'protocol fuzzing' or whatever you call it.
15:30:05 <Igloo> shrink just tries to find smaller test cases, right? That's not the issue
15:30:29 <shapr> but shrink can find the *edge* where something does and doesn't fail.
15:31:03 <Igloo> The problem is that there are odd cases you want to check like (a|) matches a and doesn't match b, but if that appears in the middle of a regexp that startx "^x" and the input starts "y" then you get a failure that hasn't really tested anything
15:31:25 <Igloo> Failure to match, that is, not test failure
15:31:29 <shapr> the important part is finding the edge cases, right?
15:31:33 <shapr> right, I understand.
15:31:43 <Igloo> The important part is finding tests that fail
15:31:56 <shapr> sane failure assurance is rarely tested for, thus the zillions of buffer overflows nowadays.
15:33:46 * Igloo wonders if the silence answering my earlier request means no-one has nhc98 installed. Maybe that shouldn't surprise me.
15:35:25 <shapr> I've got it installed!
15:35:54 <shapr> I got a big nasty traceback.
15:37:55 <shapr> Ã³le marcot 
15:38:05 <shapr> er "Ã³la"
15:38:06 <Lemmih> Got a question marcot?
15:38:10 <marcot> shapr: hello!
15:38:23 <marcot> Lemmih: not now. That time I was at work.
15:38:52 <marcot> Lemmih: now I'm in home, and I stay connected here just reading..
15:41:27 <marcot> shapr: Yes... how do you know I speak portuguese?
15:41:44 <shapr> marcot: your hostname ends in .br ?
15:42:59 <marcot> shapr: ok! =)
15:44:32 <shapr> how did you know I speak english? :-)
15:45:15 <marcot> shapr: cause you first talked to me in english.
15:45:19 <shapr> bah, too easy.
15:45:37 * shapr grins
15:45:49 <shapr> Lemmih: did you see Linus' advice about writing open source projects?
15:46:06 <Lemmih> No. Got an url?
15:46:52 * shapr looks
15:47:29 <Lemmih> Did he say something about lots of comments and readable code?
15:48:56 <marcot> Have you ever tried to do funcional-like code in imperative languages, like pascal?
15:49:01 <shapr> no, but he did say you shouldn't expect other people to join your project...
15:49:08 <shapr> marcot: works okay in Python
15:49:55 <shapr> ah, here it is: http://www.linuxtimes.net/modules.php?name=News&file=article&sid=145
15:50:00 <marcot> shapr: that's different... python implements some functional stuff.
15:50:45 <shapr> "So start small, and think about the details. Don't think about some big picture and fancy design. If it doesn't solve some fairly immediate need, it's almost certainly over-designed. And don't expect people to jump in and help you. That's not how these things work. You need to get something half-way _useful_ first, and then others will say "hey, that _almost_ works for me", and they'll get involved in the project."
15:51:31 <shapr> that seems true for my projects too.
15:52:16 <marcot> Don't you mind that the most used haskell compilers aren't gpl?
15:52:19 <shapr> that is, most of the time they're alive as long as I'm hacking on them, and they start gathering dust when I get bored.
15:52:26 <shapr> marcot: they're BSD
15:52:45 <shapr> that's even better, if you want to use Haskell for your own commercial products
15:52:45 <jadrian> it's true for mine too, but I 1st begin by doing the mistake, that I admit it was a bad choice, and start all over again, but simple :-/
15:53:16 <tuomov> refactoring rules
15:53:23 * shapr agrees with tuomov
15:53:54 <jadrian> I haven't tried the refactoring tools available for haskell
15:53:54 <tuomov> current ion3 has very little in common with the hack that was called pwm..
15:54:26 <shapr> tuomov: btw, I don't like IORef much either, but I wonder if IORef is the simplest thing to start with, and we can refactor it later.
15:54:32 <Lemmih> There are tools for refactoring?
15:54:41 <shapr> there's HaRe
15:54:48 <shapr> Haskell Refactorer
15:55:57 <shapr> anyway, I have some more Python code to fix...
15:55:58 * shapr sighs
15:56:27 <tic> shapr, speaking of Python, here's some for ya: http://dundermusen.mine.nu/dump/misc/ann/no4/no4-report.html
15:58:52 <bik> hmm.. pretty cool
15:59:27 <tic> moo?
16:00:12 <marcot> shapr: but they're not even copyleft. I prefer to keep things free even in my comercial products.
16:00:23 <shapr> marcot: huh?
16:00:40 <shapr> well, what's bad about BSD?
16:01:09 <tuomov> someone can take and extend the code without contributing back to the community
16:01:18 <tuomov> if you consider that bad
16:01:57 <shapr> Well, not enough people hacking on GHC as it is. Look at the spec_eval branch.
16:02:19 <shapr> tic: oh hey, I realized earlier today that ArrowLoop instances could be used for training neurons.
16:02:46 <tic> shapr, nifty. :)
16:02:51 <tic> but, I need to sleep now. :)
16:03:18 <shapr> nice pix
16:03:27 <shapr> have you written any nns in Haskell?
16:03:29 <shapr> anyway, g'night
16:03:30 <tic> nope..
16:03:32 <tic> python only
16:03:35 <tic> yeah, nite. :)
16:03:36 <marcot> shapr: the bad thing is that it allows people to make non-free software from free software.
16:04:02 <tuomov> not that anyone respect the gpl either
16:04:05 <tuomov> +s
16:04:10 <shapr> marcot: I understand the problem, but I'm not so worried about it with GHC.
16:04:44 <shapr> GHC evolves so quickly that there's no profit to be made in going closed source with a fork.
16:04:46 <marcot> tuomov: ??
16:04:56 <mento> Plz help. I'm going nuts. How would you change every occurance of String1 in SomeLongString with String2 ?
16:04:58 <marcot> tuomov: what do you mean about anyone respect the gpl?
16:05:23 <tuomov> marcot: every once in a while some product is discovered to include modified gpl:d code
16:05:30 <shapr> mento: break the string into pieces where that occurs, then sew it back together with the new string.
16:05:40 <shapr> tuomov: more often than that from the rumors I hear
16:05:55 <marcot> tuomov: this is a problem, but it's not a reason to stop using gpl.
16:05:58 <shapr> I hear that the FSF regularly finds its code in closed source products.
16:06:28 <marcot> tuomov: at least they're doing their best to stop it.
16:06:41 <tuomov> anyway, ghc started as a university project afaik and they may have some licensing policies
16:07:09 <marcot> tuomov: I understand.
16:07:29 <marcot> I'm not saying that BSD is that bad, but I would like it more if it were gpl.
16:07:38 <tuomov> and indeed at least publicly funded unis possibly _should_ release everything under a bsd-style license
16:07:57 <shapr> yes, I agree.
16:08:05 <shapr> if the public pays the taxes, we should get the results.
16:08:32 <shapr> it pisses me off that I pay taxes for European Projects that consider closed source results a success.
16:08:58 <tuomov> closed source and even classified
16:08:58 <shapr> paskaa
16:09:01 <marcot> tuomov: sorry, I didn't understand the reason.
16:09:32 <tuomov> the unis are funded by taxes paid by both individuals and corporations
16:09:51 <tuomov> so everyone should be able to use the results
16:09:55 <shapr> right, I totally agree.
16:10:04 <tuomov> (=> publications should also be freely available)
16:10:14 <marcot> tuomov: and what's the problem of gpl in this case?
16:10:15 <shapr> yes! very much so!
16:10:46 <tuomov> marcot: no major problem
16:11:10 <tuomov> but I think bsd is better suited here
16:11:12 <shapr> I cannot describe my anger and frustration that I pay taxes to fund research, and then the Journal of Functional Programming wants me to pay several hundred euro a year to read those results.
16:11:45 <marcot> shapr: where are you from?
16:11:54 <tuomov> and authors and editors don't get paid either!
16:11:57 <shapr> I was born in the USA, but I live in Sweden.
16:12:07 <shapr> so who gets paid?
16:12:19 <tuomov> owners of the publishing corporation?
16:12:20 <marcot> tuomov: with gpl you would have the garantee that the unis work would be used only in free projects.
16:12:45 <tuomov> but corporations have also funded the uni through taxes
16:13:00 <tuomov> lgpl might be more suitable
16:13:13 <shapr> g'day Pseudonym 
16:13:22 <shapr> Pseudonym: oh, I had something really cool to tell you...
16:13:28 * shapr thinks
16:13:35 <Pseudonym> G'day.
16:13:41 <shapr> oh yes!
16:13:43 <Pseudonym> Would it be in the logs?
16:13:45 <Pseudonym> Ah, ok.
16:13:46 <shapr> Yampa
16:13:51 <Pseudonym> Yes?
16:14:01 <shapr> space invaders is in the base afrp-0.4 package
16:14:04 <shapr> it's under a BSD license
16:14:13 <Pseudonym> Ah, cool.
16:14:27 <shapr> I asked about arrow collection speed on the mailing list, and Henrik it's not as fast as coroutines
16:14:35 <marcot> tuomov: but why can't corporations develop free software?
16:14:49 <Pseudonym> Oooh, software licensing flamewar?!
16:15:04 <marcot> Pseudonym: just a small helthfull discussion.
16:15:17 <tuomov> because they don't want to and it doesn't really fit into the capitalist system as such?
16:15:41 <Pseudonym> tuomov: Define "capitalist".
16:15:43 <marcot> Now it's becoming into a flame war.
16:16:07 * Pseudonym checks that Smerdyakov isn't here
16:16:08 <monochrom> Red Hat open-sources the programs it has written.
16:16:16 <shapr> Pseudonym: not since I banned him =)
16:16:19 <Pseudonym> :-)
16:16:24 <tuomov> red-hat is a linux company
16:16:31 <marcot> tuomov: I don't agree with you, but you sad that like if it was so obvious that I don't think I'll convince you either.
16:16:43 <shapr> marcot: no wait, just a moment...
16:16:48 <mattam> shapr: again... ?
16:16:49 <tuomov> but you go tell a random manager, even in a consumer electronic company that let's just start open sourcing everything?
16:16:52 <tuomov> Are you going to succeed?
16:16:58 <shapr> there are *two* definitions of freedom in the free software world right now.
16:17:10 <Pseudonym> shapr: Technically three.
16:17:13 <shapr> There's the Free Software Foundation, and the Debian Free Software Guidelines.
16:17:19 <Pseudonym> Ah, sorry, yes.
16:17:25 <monochrom> Linksys open-sources its router software, even its router hardware spec.
16:17:33 <monochrom> err, router firmware.
16:17:48 <shapr> According to the FSF, freedom means, you are forced to make your stuff free for others if you use their free stuff.
16:17:51 <Pseudonym> tuomov: You need to put a business case to a random manager.
16:18:01 <monochrom> Linksys does this because its firmware starts from open source firewall software to begin with :)
16:18:01 <Pseudonym> And if the manager is truly random, you need to use small words.
16:18:02 <marcot> shapr: but BSD don't makes you shure that your code will be always free in any of these definitions.
16:18:03 <shapr> According to Debian, freedom means you get the choice to do what you want with the stuff that you get.
16:18:16 <tuomov> and if they can't make extra money from freeing the software, who would they do it?
16:18:36 <tuomov> consider e.g. abandonware
16:18:38 <shapr> marcot: BSD fits into the Debian definition of freedom, where we each get to choose.
16:18:55 <tuomov> there's lots of old games around that are still not in public domain although nobody makes any money from them
16:19:03 <tuomov> or otherwise freely licensed
16:19:13 <shapr> like necrodome, which I would like to patch and play
16:19:16 <Pseudonym> It does cost to run an open source project.
16:19:17 <tuomov> id is quite exceptional in this
16:19:18 <shapr> and pizza tycoon
16:19:21 <Pseudonym> Not a lot, but some.
16:20:04 <shapr> marcot: the GPL is a more restrictive license than the BSD license, because the GPL places more restrictions on the user.
16:20:14 <Pseudonym> Not really.
16:20:14 <shapr> That's even more true of the Gnu Free Documentation License.
16:20:24 <Pseudonym> The GPL only places restrictions on redistributors.
16:20:29 <tuomov> gpl is about freedom of the software, bsd is about freedom of the user
16:20:30 <marcot> shapr: I understand Debian's reason to say this, but I still prefer GPL than BSD. Actually, everybody involved with the Debian Project I know prefers also GPL.
16:20:41 <monochrom> Linksys routers sell fine.  It is now well-known that other routers (SMC, D-Link) hang all the time but Linksys ones are reliable (due to the open source firmware they use and contribute to).  Just last Saturday several friends successfully convinced yet another friend to use Linksys.
16:20:52 <marcot> shapr: i know it does, but for me is a good restriction in this case.
16:21:07 <shapr> marcot: but not everyone choose that way.
16:21:11 <marcot> tuomov: gpl is about freedom of the information in general.
16:21:13 <Pseudonym> GPL benefits the "cottage industry" developer more than BSD does.
16:21:20 <shapr> especially big companies want to use BSD software rather than GPL.
16:21:22 <monochrom> Basically four guys sat down and one guy said "I want a router, which brand is good?" and the other three of us all said "we're all happy Linksys users!"
16:21:26 <marcot> tuomov: what's more important for me than freedom of a specific user.
16:21:41 <shapr> I don't make that same choice, but I respect their freedom of choice.
16:21:44 <marcot> Pseudonym: cottage industry?
16:21:51 <mattam> shapr: and GPL has more guarantees for users of derived works too
16:21:59 <tuomov> gpl is "using their own weapons against themselves"
16:22:06 <shapr> yes, but I still value freedom of choice.
16:22:10 <marcot> tuomov: why?
16:22:27 <shapr> I release my code under the GPL, but I do understand the reasons that many people use BSD.
16:22:31 <tuomov> using copyright law to advocate lack of copyright
16:22:39 <mattam> me too
16:22:41 <shapr> yes, the GPL is a law virus.
16:22:48 <shapr> it's a brilliant idea.
16:23:33 <tuomov> I used artistic license originally in ion, because ion has another goal besides simply producing free software
16:23:41 <Pseudonym> By "cottage industry", I mean people working on their own.
16:23:42 <tuomov> but once more work started going into it, switched to lgpl
16:24:10 <marcot> shapr: I don't understand why someone that is not a company releases his code in BSD. The only reason I see is because he want to help the proprietary software... can you see something else?
16:24:11 <monochrom> So I just want to say that open source makes good business sense.  It is counterintuitive (but when was the last time intuition got it right anyway).  The closed source companies are plagued by bugs in their mission-critical code (if any), that's well-known.
16:24:18 <shapr> I don't actually know if anyone is using my code on a regular basis though.
16:24:43 <shapr> marcot: yes, he feels that everyone gets to make their own choice.
16:24:50 <marcot> shapr: ok..
16:24:55 <tuomov> in a way it makes sense, but it is bound to make redundant companies disappear
16:25:08 <tuomov> contributing the disappearance of jobs
16:25:18 <shapr> redundant jobs at least
16:25:22 <marcot> tuomov: I believe that software companies can make money in more fair ways.
16:25:43 <marcot> tuomov: than hiding information and stoping the science evolution.
16:25:48 <shapr> I also believe that open source makes more business sense. Software is a service.
16:26:04 <shapr> Pseudonym: tried yi yet?
16:26:05 <marcot> shapr: totally agree.
16:26:08 <Pseudonym> Unlike RMS, I also believe in the "loss leader" approach.
16:26:20 <Pseudonym> That selling proprietary value-addons is fair game.
16:26:46 <tuomov> Maintenance services could be sold, but most software companies per se are bound to die
16:26:50 <marcot> Pseudonym: what is the loss leader approach?
16:26:51 <Pseudonym> Get them in with a free core, then sell them add-ons.
16:26:59 <tuomov> and of course they don't want this
16:27:10 <Pseudonym> A "loss leader" business model is very common.  It's like convenience stores.
16:27:21 <tuomov> so until it is too late, many may not want to embrace free software
16:27:22 <shapr> tuomov: I disagree.. I think the structure I outline to that guy with the crazy nickname (what was his name?)
16:27:22 <Pseudonym> The petrol is often sold at a discount to get people to come in and buy their overpriced drinks.
16:27:37 <mattam> as long as its not forced 'linked selling' (how do you say that in english) ?
16:27:40 <marcot> Pseudonym: I dislike this as much as pure proprietary software.
16:27:52 <shapr> I think the structure of many four-person companies would allow for faster evolution of products, and would mean that very much more custom development would happen.
16:28:08 <Pseudonym> marcot: Understandable, but I think reasonable people can disagree about this.
16:28:23 <shapr> tuomov: oh, I see your point.
16:28:43 <Pseudonym> Indeed, I often buy overpriced drinks at my favourite petrol station to encourage them to keep their fuel prices low.
16:28:46 <shapr> yes, many of today's companies will disappear when open source hits the good old boys.
16:29:18 <marcot> Pseudonym: Yes, each one has his etic.
16:29:31 <shapr> on the good side, if an employee sucks in a four person company, you can quickly figure it out and get rid of him/her.
16:29:50 <monochrom> Petrolium is a very overpriced drink indeed.
16:30:15 <mattam> but it's getting rare
16:30:26 <monochrom> But you don't have to drink petrolium.
16:30:49 <mattam> good point
16:31:34 <shapr> Ã³la ows 
16:32:31 <tuomov> Low fuel price? That's some kind of oxymoron
16:32:49 <tuomov> Not that I care. I very much prefer public transport.
16:32:58 <ows> Ciao shapr
16:33:22 <marcot> tuomov: where do you live?
16:33:26 <tuomov> finland
16:33:56 <marcot> tuomov: I prefer public transport too.
16:34:17 <marcot> tuomov: but in Brazil the transport is really bad, and it's very dangerous to use it at night.
16:34:26 <tuomov> that's sad
16:34:56 <tuomov> the only gripe I have is that trains have become quite expensive over the last 6 years
16:35:07 <marcot> tuomov: I still use it, but sometimes I have to stay for more than a hour in the bus stop in dangerous places.
16:35:10 <tuomov> but local buses are quite cheap (~1euro anywhere in the area)
16:35:34 <marcot> tuomov: this is very expensive in here.
16:36:09 <tuomov> I litre of petrol is over 1euro
16:36:13 <marcot> tuomov: the poor workers here have about $80 in a month.
16:36:13 <tuomov> s/I/A/
16:36:14 <mattam> in france we're told that the 1.20 euros subway tiket covers only 20% of the real cost. So we say, why not make it completely free ?
16:36:56 <monochrom> Haha
16:37:02 <marcot> tuomov: the bus costs about $0.50, but it's still expensive for our situation.
16:37:07 <mattam> aren't there countries with free public transportations in Europe ? I thought belgium maybe 
16:37:32 <marcot> mattam: this is a very good idea.
16:37:59 <tuomov> just increase petroleum tax a little more..
16:38:15 <Etaoin> a nonzero cost keeps it from being overused, doesn't it?
16:38:26 <mattam> there are two cities where they did it in france. They recorded a doubling in afluence
16:38:40 <marcot> Etaoin: and what is the problem of it being overused? Isn't it public?
16:38:49 <tuomov> I don't see anyone not using local buses because of the price
16:39:03 <tuomov> between cities it might be a problem
16:39:14 <mattam> tuomov: well, that's why they don't do it, frenchies like cars very much
16:39:17 <tuomov> (and currently ~170km is ~20e)
16:39:28 <shapr> Americans like cars very much, but I don't own one :-)
16:39:32 <shapr> I do own a unicycle though.
16:39:58 <shapr> I'm planning on buying a touring tricycle instead of a car.
16:39:59 <mattam> i don't have a car, not a licence, i have foots
16:40:00 <tuomov> Car's are trouble. Public transport is carefree.
16:40:22 <tuomov> Cars are an endless money sink.
16:40:38 <shapr> but that's partially because they're a really stupid design.
16:40:38 <marcot> tuomov: here in Brazil lots of people walk because they don't have money for public transport.
16:40:50 <tuomov> Yeah, it's a bit different there
16:41:04 <shapr> first of all, cars would never have made it without mass production, but then they stopped using mass production for cars!
16:41:12 <tuomov> And yet, coming from here, everything must seem so cheap there..
16:41:25 <mattam> shapr: what ? they stopped ?
16:41:43 <mattam> has the world changed overnight ?
16:41:50 <marcot> tuomov: not when you have $80 per month.
16:41:53 <shapr> mattam: yes, spare parts for Henry Ford's Model T are not very expensive because the same design was used for ... I think fifteen years.
16:42:17 <tuomov> marcot: not then, of course.
16:42:22 <mattam> and ?
16:42:26 <shapr> mattam: if there were as many different incompatible computers as there are incompatible cars, you and I would not have a job.
16:42:57 <mattam> i know, that's what is called concurrency without standards
16:43:07 <shapr> If there were three types of cars, the expertise and the parts would be very much more common and very much cheaper.
16:43:28 <shapr> Cars have already reached the endpoint that Microsoft strives for...
16:43:30 <mattam> you know porshes and volkswagen's bettles share parts ?
16:43:51 <shapr> well, the flat engine porsches did
16:43:54 <shapr> 921 I think?
16:44:23 <mattam> not only that, but all instruments, wheels, seats etc...
16:45:09 <shapr> A better approach would be to design a car as an API, something where you have one section with two wheels, and that section can hold passenger, motor, or cargo 'fittings'
16:45:32 <mattam> anyway the industrys are coming back to mass production i think, through fusions. Eq: fiat and renault cars share parts now
16:45:48 <shapr> if the engine fittings were an API such that you could switch to compressed air, batteries, fuel cells, wood burning, solar cells, or whatever, then life would be a lot easier.
16:46:11 <shapr> If you need to ship a bunch of stuff, hook a lot of them together to make a 'cargo train'
16:46:17 <mattam> prolly, but then the official garages would have no use
16:46:28 <shapr> official garages?
16:46:48 <shapr> you car repair companies
16:46:55 <mattam> yep
16:47:04 <shapr> well, if you suck, you die.
16:47:10 <mattam> :)
16:47:37 <mattam> no that i would have a problem with it
16:47:38 <shapr> there's a new car design that's really great, it's either spanish or portuguese, I forget which...
16:48:12 <shapr> it runs on compressed air, and uses a single simple power harness and wi-fi instead of a control harness.
16:48:57 <shapr> getting rid of the control harness saves a lot of complexity and maintenance.
16:48:57 <mattam> hmmm, would be forbidden in France, you must have mechanical control over steering and brakes
16:49:13 <shapr> I think you do have mechanical control of steering, not sure about brakes.
16:49:43 <tuomov> I wouldn't trust all electronic control
16:49:47 <shapr> the compressed air tank has a nifty design, very safe, even in case of failure, crash, etc
16:50:03 <mattam> i hope so
16:50:15 <shapr> tuomov: this design looks like one of those "simple enough that it can't be wrong" rather than "so complex no one can argue"
16:50:26 <monochrom> Heh.
16:50:49 <shapr> of course, I wouldn't know for sure unless I got my hands into one...
16:51:04 * shapr has worked on cars a lot.
16:51:08 <dons> moin
16:51:13 <shapr> g'day dons!
16:51:21 <mattam> you seem pretty informed indeed
16:51:48 <shapr> I don't enjoy working on cars, but I did learn a lot.
16:52:25 <shapr> Mostly I learned that simple designs are easy to get right, and easy to maintain and repair.
16:52:55 <ned> shapr: i guess you can't *feel* the road throught this kind of steer, you don't have any return from 
16:53:06 <tuomov> force feedback!
16:53:08 <ned> shapr: and you use this principle in coding :)
16:53:10 <shapr> ha!
16:53:21 <ned> 'lo
16:53:28 <shapr> yes, I think that principle works in all areas of design.
16:53:33 <shapr> salut ned
16:53:35 <ned> i'm not often here but i spy the logs :)
16:53:40 <shapr> :-)
16:53:48 <tuomov> keep it simple stupid.
16:54:02 <mattam> good night 
16:54:15 <shapr> Force feedback is a good point.. I have often wanted force feedback on the gas pedal also.
16:54:39 <shapr> if your driveshaft isn't quite lubcricated enough, you get sound feedback from too much torque =)
16:54:59 <ned> :)
16:55:34 <monochrom> Hahahah
16:55:37 <shapr> From an efficiency and system analysis standpoint, internal combustion engines were not designed for variable speeds.
16:56:08 <shapr> things like advancing the spark were 'hacks' to get around that so you could accelerate.
16:57:04 <shapr> in my opinion, a more efficient use of internal combustion engines would be to mount a small one in the trunk so it can run at its most efficient rpms and torque, and charge a battery/capacitor to run electric motors on each wheel.
16:58:02 <shapr> that gets rid of the complexity of transmission, differential, and other stuff.
16:58:32 <Pseudonym> That's how Diesel locomotives work.
16:58:37 <tuomov> how do hybrids work?
16:58:47 <tuomov> are both engines attached to driveshaft?
16:58:51 <Pseudonym> It apparently has problems for vehicles which need to take corners at speed.
16:58:54 <Pseudonym> As many bad drivers do.
16:58:55 <tuomov> s/engines/motors/
16:59:13 <Pseudonym> Something to do with angular momentum or something.
16:59:14 <shapr> the hybrid-fuel engines?
16:59:35 <tuomov> cars with both fuel and electric motors
16:59:54 <shapr> the only ones I've read about use that same setup I just described.
17:00:14 <shapr> I think some of the US Army heavy trucks use that structure.
17:01:02 <shapr> the main problem with purely electric cars right now is that we don't have a decent energy density in batteries.
17:01:25 <shapr> most of the current battery designs aren't that far removed from the original voltaic cell.
17:01:39 <shapr> (though I have hopes cold fusion will fix thaht)
17:02:06 <tuomov> I was just going to say put a nuclear reactor in the boot
17:02:21 <Pseudonym> You need a Mr Fusion.
17:02:33 <shapr> so for really usable systems, the battery can only half an hour of charge, and you run the gas engine to dump more charge into it as you go along.
17:02:44 <shapr> actually, I've thought about micro-fusion =)
17:03:11 <shapr> I don't think it's that hard to do, but I really have no idea how to shield it :-(
17:03:45 <shapr> I know how to handle everything up to gammas, but fast neutrons are just too much.
17:04:41 <tuomov> put cars on tracks and get electricity from power lines just like trams
17:04:53 <shapr> yes, I think that's the best approach.
17:05:17 <shapr> Also, current nuclear power plant designs are really painfully wasteful.
17:05:52 <shapr> btw, you can extend the externally powered approach to spaceflight too
17:06:40 <shapr> I had this idea that you could magnetically launch the equivalent of a glider that could hold cargo and/or humans.
17:06:51 <shapr> stick a big rail on a hill somewhere on the equator....
17:07:02 <shapr> use the atmosphere for fine tuning your course
17:07:05 <Pseudonym> shapr: Your name isn't Leonardo, is it?
17:07:09 <shapr> er, no?
17:07:28 <Pseudonym> It sounds like a da Vinci-style crackpot invention, that's all.
17:07:29 <tuomov> I had this idea of making the rocket of a very durable material, pulling it deep into the ocean and letting it free
17:07:37 <tuomov> might get some initial speed for it, but I'm not sure...
17:07:41 <tuomov> works for pencils :)
17:07:53 <Pseudonym> I had this idea of living beneath the waves in a yellow submarine.
17:08:02 <tuomov> except that they turn on their sides once out of water
17:08:03 <shapr> anyway, once you get the ship moving, you can give both aceleration and supplies to a mars mission by mounting something like a catcher's mitt on the butt of your unpowered spacecraft, and throwing supplies at it.
17:08:46 <Pseudonym> You have to throw the supplies faster than the craft.
17:08:52 <shapr> right, but that's no problem
17:09:16 <Pseudonym> And they'd need to be heavy supplies to give the craft enough impulse.
17:09:32 <Pseudonym> Presumably the craft discards the waste.
17:09:40 <shapr> not if the passenger capsule has a low enough mass.
17:10:15 <shapr> the whole problem with current designs is that they ship enough propellant for the whole trip, and that's insane.
17:10:59 <shapr> Pseudonym: this is my eXtreme Programming approach to Spaceflight =)
17:11:35 <tuomov> extreme spaceflight...I don't think I want to endure that :)
17:11:51 <dons> hehe
17:12:01 <shapr> tuomov: interesting idea, I'll think about that.
17:12:34 <Pseudonym> :-)
17:12:40 <Pseudonym> Pair Piloting
17:12:45 <shapr> oh hey, did you guys see the new low-speed high-carry aircraft design?
17:13:15 <Pseudonym> I suspect that "do the smallest thing that could possibly work" applied to space flight might be less than optimal.
17:13:53 <shapr> it's brilliantly elegant, this guy mounted eggbeater blowers on the front of the wing, such that they're larger than the cross-section itself.
17:14:11 <Pseudonym> Got a link?
17:14:14 <shapr> err
17:14:15 * shapr looks
17:16:23 <shapr> hm, I can't find it.
17:16:39 <shapr> I could draw it though =)
17:16:56 <shapr> dang :-/
17:41:55 <shapr> oh neat: http://www.cs.nott.ac.uk/~gmh/book.html
17:42:15 <shapr> first seven chapters of Graham Hutton's new intro book, "Programming in Haskell"
17:47:00 <shrimpx> do we really need more books on the language?
17:49:02 <shapr> I don't know.
17:49:13 <shapr> I wouldn't mind.
17:49:33 <shapr> shrimpx: we could cowrite the book "Type Tricks in a Nutshell"
17:49:36 <dons> well, we have to catch up to C# and Java ;)
17:50:02 <shrimpx> yeah!
17:50:10 <dons> apparently there's never enough books on those languages
17:50:11 <Pseudonym> Teach Yourself Guide to the Black Art of Guru's Haskell Tricks For Dummies in 21 Days For Idiots.
17:50:19 <dons> yeah!
17:50:24 <shapr> awright!
17:51:09 <dons> I think we should definitely have "Idiot" and "Dummy", and maybe "Stupid" in the title
17:51:55 <shrimpx> i wanna see books on advanced server programmign in haskell and stuff. most java books are on _applying_ java, not on the language definition
17:52:04 <dons> so, we *all* have to write 5 books each if we're going to catch up
17:52:35 <shapr> there's already a paper on advanced server programming in Haskell.
17:52:44 <shapr> Simon Marlow's haskell web server paper.
17:52:45 <dons> so you just have to pad that out ...
17:52:54 <shapr> add pictures, and you're done.
17:52:58 <dons> done and done
17:53:01 <shrimpx> sweet
17:53:09 <dons> $80US
17:53:14 <Pseudonym> Who wants to write the one on game programming?
17:53:35 <shrimpx> how to use web haskelets to replace your legacy CGIs
17:53:38 <shapr> dark already ported about half of "Programming Linux Games" to Haskell.
17:53:43 <shapr> We could just finish that project.
17:53:45 <Pseudonym> Sweet.
17:53:57 <shrimpx> shapr: really?
17:53:59 <shrimpx> word
17:54:05 <Pseudonym> Dude.
17:54:17 <shapr> it's pretty nifty, I was controlling bouncing penguins with my joystick.
18:12:00 <Etaoin> hm
20:17:18 <desrt> is there any way to form a 1-tuple?
20:17:36 <desrt> or is this just considered useless?
20:18:43 <heatsink> desrt: there is no 1-tuple
20:19:00 <desrt> it's just a value itself
20:19:04 <heatsink> yes
20:19:07 <dons> (1)
20:19:14 <desrt> Prelude> (return 1) >>= (print)
20:19:14 <desrt> 1
20:19:17 <desrt> this is just awesome!
20:19:26 <desrt> i have no idea if it's the list monad or the maybe monad or anything else
20:19:27 <desrt> it just works
20:19:36 <heatsink> IO monad
20:19:43 <desrt> oh.  right
20:19:46 <desrt> that's actually pretty boring
20:20:18 <desrt> more interesting
20:20:20 <desrt> Prelude> print ((return 1) >>= (show))
20:20:20 <desrt> "1"
20:21:24 <desrt> what monad do y'all think that >>= is operating on? :)
20:22:10 <dons> @type print
20:22:12 <lambdabot> print :: forall a. (Show a) => a -> IO ()
20:22:34 <desrt> it has nothing to do with print anymore
20:23:26 <desrt> it's list monad
20:23:27 <heatsink> @type show
20:23:28 <lambdabot> show :: forall a. (Show a) => a -> String
20:23:34 <desrt> @type return 1
20:23:35 <lambdabot> return 1 :: forall m a. (Monad m, Num a) => m a
20:23:41 <dons> there you go :)
20:23:41 <desrt> hum
20:23:52 <desrt> interesting!
20:23:58 <dons> @type (return 1 >>= show)
20:23:59 <lambdabot> (return 1 >>= show) :: [Char]
20:24:04 <dons> @type (return 1 >>=)
20:24:06 <lambdabot> (return 1 >>=) :: forall m a b.
20:24:06 <lambdabot> 		  (Monad m, Num a) =>
20:24:06 <lambdabot> 		  (a -> m b) -> m b
20:24:26 <dons> @type (return 1)
20:24:27 <desrt> if i put in a file: a = return 1
20:24:28 <desrt> then ghci the file
20:24:29 <lambdabot> (return 1) :: forall m a. (Monad m, Num a) => m a
20:24:33 <desrt> then :t a, then i get [Integer]
20:24:51 <dons> hmm
20:25:05 <dons> @type (let a = return 1 in a)
20:25:06 <lambdabot> (let a = return 1 in a) :: forall m a. (Num a, Monad m) => m a
20:25:09 <desrt> but...
20:25:19 <desrt> there are other declarations in the file that might be affecting the typing of a
20:25:33 <desrt> i think because show returns a string
20:25:36 <desrt> which is a list....
20:25:40 <desrt> i end up in the list monad
20:25:55 <desrt> ya. because show doesn't really have a monadic type
20:26:07 <desrt> but because it returns a string.... show is seen as a function in the list monad
20:26:12 <desrt> which forces >>= to be for lists
20:28:34 <heatsink> @eval return 1234 >= show >= (:" ")
20:28:35 <lambdabot> (line 1, column 21):
20:28:35 <lambdabot> unexpected ">"
20:28:35 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
20:28:35 <lambdabot>  "(", operator, simple term or end of input
20:28:35 <lambdabot> ambiguous use of a non associative operator
20:28:36 * desrt has some more fun
20:28:48 <heatsink> @eval return 1234 >>= show >>= (:" ")
20:28:48 <lambdabot> (line 1, column 14):
20:28:48 <lambdabot> unexpected ">"
20:28:48 <lambdabot> expecting simple term
20:28:57 <heatsink> lambdabot doesn't do IO
20:28:58 <desrt> HAH!
20:29:22 <heatsink> return 1234 >>= show >>= (:" ") --> "1 2 3 4 "
20:29:44 <desrt> http://www.desrt.ca/monad.hs
20:29:46 <desrt> check this out :)
20:30:52 <heatsink> cool
20:32:05 * desrt gets so excited about haskell :)
20:32:12 <dons> :)
20:34:46 <desrt> if i replace b=show with something that's more ambiguous (for example 'b x=return 1') then type unification fails
20:35:11 * desrt tries with -fno-monomorphism-restriction
20:35:35 <desrt> works :)
20:35:47 <desrt> c becomes a function that is happy to exist inside any monad :)
20:38:09 <desrt> there's no generic "make new monad" function, is there?
20:38:32 <desrt> i mean, you have to explicitly use Just or [] or unsafePerformIO or something like that to get the ball rolling...
20:39:13 <heatsink> mzero
20:39:27 <desrt> is mzero like return and >>=?
20:39:54 <heatsink> wait... Just, [], and unsafePerformIO don't do the same thing
20:39:55 <desrt> oh.  it's a monadplusism
20:40:27 <desrt> heatsink; but they're all ways of getting start values in their own respective monads
20:40:49 <desrt> by Just i mean 'Just a' and by [] i mean '[a]'
20:40:57 <heatsink> oh
20:41:00 <heatsink> Those two are return
20:41:16 <heatsink> unsafePerformIO is more like fromJust
20:41:42 <desrt> does fromJust throw an exception if it gets Nothing?
20:41:47 <heatsink> yes
20:42:31 <desrt> ya.  i think i agree with you
20:42:55 <desrt> and the list monad equivilent would be head
20:43:22 <desrt> or (map id) if you want to be less destructive :)
20:43:23 <heatsink> That makes sense
20:46:30 <desrt> where does unsafePerformIO live?
20:46:39 <heatsink> in the Dark Universe
20:46:48 <heatsink> I think it's part of the FFI
20:46:53 <desrt> seriously?
20:47:20 <dons> unsafePerformIO lives in GHC/IOBase.lhs
20:47:46 <dons> unsafePerformIO :: IO a -> a
20:47:47 <dons> unsafePerformIO (IO m) = case m realWorld# of (# _, r #)   -> r
20:47:57 <desrt> this is so cool
20:48:02 <dons> just strip off the IO constructor
20:49:59 <heatsink> Ooh, realWorld. That looks nifty. I want a function that makes those.
20:50:02 <dons> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:50:28 <heatsink> What are the #s?
20:50:45 <dons> unboxed tuple (?)
20:51:08 <dons> hmm. another evil function:
20:51:09 <dons> unIO :: IO a -> (State# RealWorld -> (# State# RealWorld, a #))
20:51:09 <dons> unIO (IO a) = a
20:52:35 <heatsink> But you can't actually use it until you can get an instance of State# RealWorld from somewhere
20:57:23 <dons> maybe that's why I've never seen it used ;)
20:58:06 <dons> oh, it's used in defining the IO monad
20:58:11 <dons> bindIO :: IO a -> (a -> IO b) -> IO b
20:58:12 <dons> bindIO (IO m) k = IO ( \ s ->
20:58:12 <dons>   case m s of
20:58:12 <dons>     (# new_s, a #) -> unIO (k a) new_s
20:58:12 <dons>   )
20:58:21 <dons>     m >>= k     = bindIO m k
20:58:47 <dons> it's quite beautiful how simple IO is
21:01:18 <heatsink> oh, I see
21:08:11 <dustin`> I'm doing some profiling with ghc, and I'm rather new to this language.  What kinds of operations result in heap allocation?
21:18:04 <heatsink> dustin`: I think the construction of closures results in heap allocation.
21:19:46 <heatsink> dustin`: I don't understand well how the internals work, but it is explained in this rather long document: http://research.microsoft.com/research/pubs/view.aspx?pubid=179
21:20:28 <dustin`> holy crap
21:20:38 <dustin`> Thanks!
22:49:31 <skew> hello
22:49:50 <dash> hi.
22:50:45 <dash> finally i get to be on a channel where _I_ ask the stupid questions and _other_ people roll their eyes and point my mistakes. 
22:51:04 <skew> isn't learning fun?
22:51:12 <dash> anyway
22:51:15 <dash> yes it is ;)
22:51:32 <dash> i'm writing a parser with Parsec and i don't understand something basic, apparently
22:51:48 <skew> I could ask you questions about Twisted anyway :)
22:51:58 <dash> possibly just how to interpret hugs' error messages 
22:52:03 <skew> I think I understand Parsec...
22:52:27 <dash> http://ghostwheel.ddts.net/~washort/arnis.hs
22:52:42 <dash> here is what i get:
22:52:43 <dash> ERROR "arnis.hs":67 - Type error in application
22:52:43 <dash> *** Expression     : atom <|> parens (many quotable)
22:52:43 <dash> *** Term           : atom
22:52:43 <dash> *** Type           : GenParser Char a ArnisExpr
22:52:43 <dash> *** Does not match : GenParser Char a [ArnisExpr]
22:52:56 <dash> this is essentially a lisp parser
22:53:27 <skew> without reading the code, it looks like "atom" should parse a single expression
22:53:28 <dash> i want quotable to match (bla (foo () etc)) and so forth
22:53:43 <dash> hmmh
22:53:46 <skew> and quotable should match a single expression as well
22:54:17 <skew> many takes a parser for a single term and turns it into a parser that will parse a list of things and return a list of values
22:54:43 <dash> right
22:54:43 <skew> so a GenParser Char a ArnisExpr turns into a GenParser Char a [ArnisExpr]
22:54:59 <dash> hmmmmm
22:55:03 * dash pokes at stuff.
22:55:10 <skew> okay, just getting the basics out of the way
22:55:53 <skew> the atom on the left side parses a single thing, the parens (many quotable) tries to parse a bunch, so the types don't match up
22:56:18 <skew> you probably need to write something like ManyExprs <$> parens (many quotable)
22:57:02 <skew> that is, explain how you want a bunch of expressions combined into a single expression
22:57:13 <dash> OK
22:57:21 <dash> i'm trying to get hugs to tell me the type of 'many' :)
22:57:28 <skew> that's a good idea
22:57:37 <skew> should be GenParser a b -> GenParser a [b]
22:58:20 <skew> er, GenParser a b c -> GenParser a b [c]
22:59:56 <skew> I don't know much about hugs, but you should be able to get the type out of it. There's also the online docs.
22:59:58 <dash> mmm yeah
23:00:03 <dash> the one i care about is parens, then.
23:00:25 <skew> parens doesn't change the type at all, just the text to parse
23:01:38 <dash> hum. OK yes, that is what I did not understand.
23:02:19 <skew> where did you find out about parens and stuff?
23:02:50 <dash> i forget
23:02:59 <dash> I wrote this code about a year ago
23:03:16 <dash> probably the parsec manual
23:03:16 <skew> I only know about Daan's introduction, and that mentions the types as it goes
23:03:23 <skew> oh, old code
23:03:26 <dash> OK yes.
23:04:52 <dash> hm, where is <$> defined
23:05:12 <skew> Prim?
23:05:48 <skew> nope
23:06:55 <musasabi> morning
23:07:28 <skew> hello
23:10:36 <dash> i see <$$> and <$?>
23:10:53 <skew> yeah, I can't find it either
23:11:22 <dash> grep does not reveal it
23:11:37 <skew> that's much odder
23:11:44 <skew> did you escape the $?
23:13:19 <dash> yes
23:13:34 <dash> it found plenty of other $ but not a <$>
23:13:50 <dash> huh. i'm making a circular definition here anyway, i doubt this is good
23:13:59 <skew> where?
23:14:50 * dash thinks
23:15:01 <dash> through 'atom' and 'quotable'
23:15:06 <dash> this may be OK, of course
23:15:12 <dash> i think it is just recursive
23:15:13 <dash> nm 
23:16:13 <skew> you might prefer fmap f m to m >>= return . f
23:16:59 <skew> you're fine as long as your definition isn't left recursive
23:17:18 <skew> even circular definitions are usually okay
23:17:20 <dash> yeah, i don;t think it is
23:17:23 * dash nods
23:17:24 <dash> anyway
23:19:15 <dash> i'm trying to include lisp's quoting
23:19:36 <dash> hmmmmmmm
23:19:55 <dash> OK i guess I need to explicitly represent 'list' in the expression types
23:20:06 <dash> or distinguish between 'quoted atom' and 'quoted list'
23:20:34 <dash> Or...
23:20:35 <dash> hm
23:20:55 <skew> probably just have quoted expressions
23:21:08 <skew> but yes, you need to decide how to handle lists of elements
23:22:50 <skew> the easiest thing and probably the right thing is just to add a constructor for expression that's just a list of expressions
23:23:03 <skew> Isn't that what Application is for?
23:23:20 <dash> mmh
23:23:29 <dash> (a b c) is distinct from '(a b c)
23:23:31 <skew> except Application only allows a Symbol in the first position. Why is that?
23:23:49 <dash> 'cause applications only allow symbols in the first position
23:24:08 <skew> ASF $ Quote (AApp $ Application a [b,c])
23:24:36 <dash> yeah, but an application is different from a quoted list
23:24:55 <skew> you can't write ((lambda (x) (x x)) (labmda (x) (x x)))? No fun!
23:25:02 <dash> nope, that is dumb!
23:25:10 <dash> only stupid CS geeks would think of that
23:25:21 <dash> anyway I guess that means i really-truly have to represent lists in the AST
23:25:22 <skew> that's me
23:25:34 <skew> does lisp make the distinction?
23:25:40 <dash> between what?
23:25:51 <skew> applications and lists
23:26:01 <skew> rather, quoted applications and quoted lists
23:26:20 <dash> well. there's no such thing as "quoted applications"
23:27:26 <skew> More usefully, you can have expressions like ((some-random-higher-order-function) args) more-args)
23:27:54 <dash> Hmm? nope, not in this language
23:28:19 <dash> scheme, yes. this one, no
23:28:57 <skew> okay, if it's an issue of language design
23:29:05 <dash> yes
23:29:11 <dash> i get to be a fascist on this one
23:29:12 <dash> ;)
23:31:58 <skew> did you ever find <$>? I be thinking of another parser combinator library
23:33:19 <dash> probably you are :)
23:34:22 <skew> oh, <$> was in the UU combinators. It's like fmap, except their parsers are not monads
23:34:51 <skew> do you have eval?
23:35:18 <skew> actually, that was a stupid question.
23:35:27 <dash> in the reader? not yet
23:35:36 <dash> dunno if i'll add it either
23:35:43 <skew> one thing to do might be to write a function for turning an expression into a list of values
23:36:09 <dash> hmm, why's that
23:36:13 <skew> I was thinking keeping the parse tree for a quoted list might make that easier, but not if they start fidding with the list
23:36:25 <dash> "they"?
23:36:36 <skew> people writing code in this language
23:36:47 <dash> oh
23:37:23 <dash> the AST for a quoted list and the data structure it evaluates to will be distinct
23:37:43 <skew> About the lists, I mean you use Quote ArnieExpression as the type in the tree, then in the evaluator you just use some kind of flatten-to-list function on the quoted expression rather then the normal evaluator for unquoted expressions
23:37:56 <dash> mmh
23:38:25 <dash> nah, that wouldn't work for what i have in mind
23:38:35 <skew> what are you trying to do?
23:38:51 <dash> build a ruthlessly abstract lisp evaluator
23:38:59 <dash> all denotational semantics and stuff
23:39:21 <dash> reifying the store, environments, continuations, etc
23:39:49 <skew> are you treating macros?
23:39:55 <dash> not yet
23:40:14 <dash> doubt i will, either
23:40:32 <dash> this is mostly to experiment with some new ideas for semantics
23:40:42 <dash> since macros aren't related, i'll leave 'em out
23:42:29 <dash> but this is always what breaks my brain when writing haskell programs
23:42:36 <dash> i get lost trying to structure data
23:42:59 <skew> do you know what you want to do with the data?
23:43:24 <dash> yeah, i want to print it out and see if it looks like a reasonable parse tree
23:44:49 <skew> If you just want that for now then you can take the structure from the parser
23:45:45 <dash> what does "take the structure from the aprse" mean?
23:46:38 <dash> parser, even
23:46:41 <skew> When you were writing the parser you came up with a grammar for lisp
23:46:49 <dash> yeah, but it's broken :)
23:47:14 <skew> so an expression can be a number or a quoted expression or some special form or parentheses around an application, etc
23:47:47 <skew> so you can just make a data type in that shape, data Expr = Atom Int | Symbol String | Quote Expr | ...
23:48:08 <dash> riiight.... i've got that already
23:48:35 <skew> okay, I thought you were stuck trying to figure out how to structure the data
23:48:42 <dash> i am 
23:49:00 <dash> i've got that, and it's broken :)
23:49:07 <skew> the type is broken?
23:49:10 <skew> how's that?
23:49:11 <dash> yes
23:49:22 <dash> i don't have a way to represent quoted lists in it
23:49:31 <skew> do you have a way to parse them?
23:49:56 <dash> guess not, if the type is wrong :)
23:49:57 <skew> yeah, you wanted to be able to write atom <|> parens (many atom) and have it make sense, right
23:50:25 <skew> what parser was that in, expr?
23:50:31 <dash> quotable
23:51:18 <skew> okay, so just say something like data Quotable = QAtom Atom | QList [Quotable]
23:51:45 <skew> then quotable = fmap QAtom atom <|> fmap QList (parens (many quotable))
23:52:39 <skew> The structure of the parser I'm talking about is the pattern of choice, sequencing, and recursion between the nonterminals of the grammar
23:52:48 <dash> Mmmm.... Yes. I was getting there.
23:52:50 <dash> thanks. :)
23:53:08 <skew> think fuzzy thoughs about inital algebras and category theory :)
23:53:22 <dash> no
23:53:24 <dash> i refuse
23:53:58 <Pseudonym> Eeek.
23:53:58 <dash> hmm
23:54:04 <dash> i don't have Atom, either
23:54:07 <skew> you were saying you have trouble figuring out how to structure data in haskell?
23:54:10 <Pseudonym> I just implemented an O(N^4) algorithm.
23:54:24 <Pseudonym> I think.
23:54:31 <Pseudonym> Maybe it's O(N^3).
23:54:35 <skew> That's not too bad
23:54:36 <dash> skew: yeah
23:55:11 <skew> dash: where does the extra trouble come from, beyond just figuring out how to write code that works?
23:55:34 <dash> skew: heh. that _is_ the trouble of figuring out how to write code that works
23:56:05 <skew> I mean compared to writing code that works in another language
23:56:24 <dash> the trouble comes from not being able to run a program that is partially specified
23:56:54 <skew> what useful information do you get from that?
23:57:14 <dash> whether the code i've written does what i expect or not
23:57:40 <skew> I see trying to compile a partial program and looking at the type errors as "running" it at a level of abstraction and seeing if it makes sense
23:58:07 <dash> yeah, that gives you limited information
23:58:08 <skew> like if the variable I expect to be a list of ints actually is, and that sort of stuff
23:58:20 <dash> better than nothing, but not the same 
23:59:28 <skew> hmm, I always think it's frustrating trying to infer my type errors from runtime errors I get in other languages
23:59:37 <dash> *shrug*
23:59:44 <dash> type errors aren't special
