00:01:03 <mornfall> yow
00:01:17 <mornfall> may i bother with newb questions? =)
00:02:03 <musasabi> yes...
00:02:09 <pesco> morn
00:03:26 <mornfall> any way to apply binary arith functions to n arguments?
00:03:34 <mornfall> (hugs 98 here)
00:03:48 <phubuh> what do you mean?
00:03:48 <mornfall> (like, n > 2)
00:03:59 <ibid> use fold
00:04:04 <ibid> (s)
00:04:45 <pesco> mornfall: In the case of (+) and (*) there are sum and product, resp.
00:05:13 <mornfall> hmm, right
00:05:33 <mornfall> sum and product worky
00:05:43 <mornfall> fold undefined variable :/
00:05:57 <mornfall> thx; i'll bother more soonish i guess ;)
00:06:07 <ibid> mornfall: foldl and foldr
00:06:48 <musasabi> e.g. sum = foldl (+) 0 
00:07:49 <mornfall> hmm, me clueless
00:08:01 <mornfall> never mind, i'll find out later
00:08:40 <pesco> mornfall: foldl folds an operator into a list from the left.
00:09:03 <pesco> Starting with a given initial value.
00:09:06 <pesco> E.g.:
00:09:30 <mornfall> ok, workying
00:09:32 <mornfall> working even
00:09:43 <mornfall> Prelude> foldl (+) 0 [1..5]
00:09:54 <pesco> foldl (+) 0 [1,2,3,4] = ((((0+1)+2)+3)+4)
00:10:20 <pesco> Thus, sum = foldl (+) 0
00:10:33 <mornfall> yay, nice =)
00:11:34 <pesco> foldr works the same, but starts from the right, so the above would become (0+(1+(2+(3+(4)))))
00:12:00 <mornfall> ic
00:12:17 <pesco> folds are fun to work with.
00:12:41 <mornfall> yep, good generalization tool it seems to be
00:12:46 <pesco> Right.
00:14:10 <pesco> Any primitive recursion can be expressed as a fold. (Right?)
00:15:11 <pesco> You can define folds for other data structures than lists, like trees, or natural numbers. There's a cool chapter on that in "The Fun of Programming".
00:16:03 <wkornew> GHC-quesition: hi, is there a way to only generate the HC files which I need with hc-build? I do not want to compile the whole language
00:16:44 <pesco> I'm pretty sure there is, but I don't remember how. :) Is it not in the Porting Guide?
00:16:58 * pesco goes to take a shower.
00:16:59 <wkornew> and after a compile I only got one folder of HC files, should there not be more (the doc mentions hslibs and libraries)
00:17:03 <pesco> bbl
00:17:11 <wkornew> no
00:17:14 <wkornew> bye
00:17:18 <wkornew> [reboot]
00:30:14 <wkornew> yes, there is a command! make hc-file-bundle! :)) someone should write this on the porting page!
00:30:23 <wkornew> (GHC porting)
00:45:16 <musasabi> Why is a replicateM_ loop eating up stackspace?
00:47:48 <mornfall> gtg, bbl
00:49:50 <musasabi> Is there a way to loop an IO computation N times without eating up stack?
00:50:15 <musasabi> ntimes :: Int -> IO a -> IO ()
00:54:51 <adept> musasabi: IO computation is not eating any stack per se ...
00:55:20 <adept> something got tied up and not freed by GC inside your computation, I believe.
01:01:59 <pesco> Wow, there is replicateM_? I didn't even know! I always used sequence_ . replicate n :)
01:04:22 <musasabi> Can I use ! (strict fields) in a newtype?
01:04:34 <pesco> I don't know. Try it.
01:04:41 <kosmikus|away> no, I don't think so
01:05:06 <pesco> (Spoke his voice from far away...) ;)
01:05:55 <kosmikus> it doesn't make sense
01:06:14 <pesco> What is it?
01:06:25 <kosmikus> the "!" ?
01:06:39 <pesco> Ah. You're right.
01:09:39 <musasabi> yse seems it is impossible.
01:10:06 <pesco> Hm. Then it probably does make sense...
01:10:10 <musasabi> But why would the loop inside replicateM_ eat stack. Heap I could understand..
01:10:25 <pesco> Is that in Hugs or GHC?
01:10:39 <musasabi> GHC (with -O2)
01:10:43 <pesco> Ok.
01:11:34 <musasabi> basically I have: replicateM_ n (foo t >> bar t) (with "foo :: T -> IO ()" and "bar :: T -> IO Bool")
01:12:07 <pesco> t being constant in that context, I presume?
01:12:22 <musasabi> t is an ioref.
01:12:47 <musasabi> (and yes it is constant as far as the loop is considered)
01:12:52 <pesco> Yes.
01:13:42 <pesco> Try sequence_ (replicate n (foo t >> bar t)).
01:13:46 <pesco> Just for the hell of it.
01:14:27 <pesco> I can't see where this should eat stack, either.
01:15:45 <pesco> Anyway, I have to go. Good luck.
01:17:31 <musasabi> that does not help.. :-(
01:19:13 <kristnjov_> hey i've got a question... why do farts make noise?
01:21:21 <adept> kristnjov_: are you serious? Read up on Bernoully principle and hydrodynamics :)
01:21:36 <kristnjov_> oh, i was hoping for a straight answer :/
01:21:59 <adept> musasabi: show more of the code 
01:22:16 <adept> kristnjov_: straigh answer is "Bernoully principle"
01:22:22 <kristnjov_> no it's not :/
01:22:48 <kristnjov_> i was thinking something like "because the anal opening is of such size that blabla"
01:24:13 <adept> kristnjov_: can you explain why sky is blue? :) (and please give a straight answer)
01:24:53 <kristnjov_> i don't know why it is.
01:25:00 <kristnjov_> but if i knew, i would give a straight answer!
01:27:37 <adept> kristnjov_: poinjt is, that straight and short answer would yield several dozen "why's" 
01:28:03 <kristnjov_> depends on who's asking :)
01:30:45 <adept> kristnjov_: have you read a classic sci-fi about computer who was supposed to give a definite answer about sense of life, universe and everything? It worked for a long time, and answer was: "48".
01:30:59 <kristnjov_> you mean hitchhiker's guide to the galaxy?
01:31:16 <kristnjov_> i haven't read it.
01:31:19 <adept> kristnjov_: yes, indeed it is
01:31:29 <sorje> adept, the answer is 42!
01:31:38 <kristnjov_> yeah, i thought 48 was kind of wrong.
01:31:56 <kristnjov_> perhaps it's different in the ukraine :)
01:31:59 <adept> sorje: yep. silly me. 48 definitely will not do :)
01:32:04 <sorje> ;-)
01:32:51 <adept> kristnjov_: which reminds me ... You said yesterday that you have some picture ... :)
01:33:02 <kristnjov_> ah yes, i'll see if the server is up
01:33:29 <kristnjov_> it is not :|
01:33:42 <dblhelix> kristnjov_ : how's your lab exercise?
01:34:04 <kristnjov_> dblhelix, i don't remember, i'm doing three labs at the same time now
01:34:15 <kristnjov_> trying to come up with properties for another lab atm
01:35:28 <dblhelix> ah, okay
01:40:40 <musasabi> adept: http://youzen.b2.fi/~musasabi/aa.hs
01:41:05 <musasabi> adept: The last line "value toggle >>= print" seems to trigger the stack overflow..
01:46:15 <kristnjov_> Program error: {buildHistogram [Bounded_maxBound instBounded_v29] []}
01:46:18 <kristnjov_> what does that mean?
01:47:07 <kristnjov_> never mind, thanks :)
01:56:01 <adept> musasabi: of course. you are building a closure of not(not(not(not(not(not(not( ......, and when it gets evaluated at "print", you have a stack space overflow.
01:58:55 <musasabi> so a simple "not" -> "\v -> not `seq` v" ^_^
02:06:21 <adept> musasabi: it helps?
02:06:37 <musasabi> yes, only it produces the wrong results.
02:06:57 <adept> :)))
02:07:24 <adept> musasabi: i'd say "\v -> v `seq` not v"
02:10:21 <musasabi> (\v -> v `seq` not v) does not help (it still overflows)
02:38:58 <adept> musasabi: i never been able to grasp pecularities of `seq` :)
03:07:17 <TheHunter> good morning, everybody
03:07:30 <Lemmih> G'day TheHunter.
04:52:42 <shapr> yow!
04:53:33 <xkb> @yow
04:53:34 <lambdabot> Uh-oh --  WHY am I suddenly thinking of a VENERABLE religious leader
04:53:34 <lambdabot>  frolicking on a FORT LAUDERDALE weekend?
04:58:03 <yohan> hey i know this is totally wrong, but what would i use if i want to check what env' would return and if something i want to do something...:
04:58:06 <yohan> putStrLn "Thank you for playing!" ++ str
04:58:08 <yohan> ups
04:58:15 <yohan>            Just a    -> do let (str,env') = gameLoop env a
04:58:15 <yohan> 			| env' == Win = putStrLn (manyEndLines ++ str ++ "\nThank you for playing!" ++ manyLines)
04:58:15 <yohan>                         | otherwise = do putStr (manyEndLines ++ str ++ manyLines)
04:58:15 <yohan>                                          loop env'
04:58:54 <yohan> i mean i have this: Just a    -> do let (str,env') = gameLoop env a and i would like to do a if statements on env'...how would i do this? 
05:00:45 <shapr> greetz yohan
05:01:03 <yohan> heya shapr, how's it goin for you today?
05:01:23 <shapr> winter approaches in Boden, it's cold and there's not much sun.
05:01:32 <shapr> good coding weather :-)
05:02:16 <shapr> I don't quite get that code you pasted
05:03:06 <shapr> what about using untilM or something?
05:03:09 <shapr> @index when
05:03:09 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
05:03:09 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
05:03:09 <lambdabot> State,Control.Monad.Writer,Monad
05:03:19 <shapr> @type Control.Monad.when
05:03:20 <lambdabot> Control.Monad.when :: forall m. (Monad m) => Bool -> m () -> m ()
05:05:32 <yohan> where would i use that?
05:05:43 <yohan> not sure what monad is
05:05:49 <yohan> yeah gettin more and more cold here too
05:06:40 <shapr> you could use until
05:06:54 <musasabi> shapr: do you have any thoughts on the stack overflow problem?
05:07:36 <shapr> check your folds?
05:08:18 <shapr> I'm not really sure.
05:09:18 <shapr> I don't thoroughly understand the differences among blowing the stack, blowing the heap, or running out of ram.
05:09:40 <shapr> I'd like to make simple examples of each to show how they happen and how they get fixed
05:09:49 <musasabi> http://youzen.b2.fi/~musasabi/aa.hs 
05:10:01 <musasabi> the problem is lazyness and how to apply seq correctly.
05:10:21 <shapr> ah
05:12:25 <shapr> it seems to me that if you understand the laziness (lazyness?) of all the functions you're using, you can usually figure out why something is leaking.
05:12:35 * shapr plays with aa.hs
05:12:53 <musasabi> yes I know what the problem is.
05:13:12 <shapr> what is it?
05:13:13 <musasabi> "not" is building up closeres (if I understand it correctly)
05:13:20 <shapr> oh
05:13:42 <musasabi> but having (\v -> v `seq` not v) does not solve it.
05:14:26 <shapr> yohan: System.exit
05:14:49 <yohan> thanks
05:14:56 <shapr> :-)
05:14:59 <cptchaos> what should aa.hs do?
05:15:28 <musasabi> cptchaos: basically it is a simplified example.
05:16:07 <ski> hej shapr
05:16:48 <musasabi> the last line "value toggle >>= print" is the problematic one, forcing evalution and thus the stack overflow
05:17:20 <cptchaos> how big has the arguement number to be to get the overflow?
05:18:07 <cptchaos> [cptchaos@motion cptchaos]$ ./a.out 100000000000000000000000000000000000000
05:18:08 <cptchaos> True
05:22:38 <musasabi> I get overflow with 1000000..
05:23:12 <cptchaos> hm, seems you found a ghc bug
05:23:29 <cptchaos> what version are you using?
05:23:56 <cptchaos> for me:
05:23:56 <cptchaos> [cptchaos@motion cptchaos]$ ghc --version
05:23:56 <cptchaos> The Glorious Glasgow Haskell Compilation System, version 6.2.1
05:24:26 <cptchaos> ah, ok
05:24:37 <cptchaos> I get the overflow with 1000000 
05:24:57 <cptchaos> its Int, i.e. modulo 0xfffffffff
05:25:04 <cptchaos> hm
05:25:07 <shapr> I get it with 100000
05:25:44 <cptchaos> you could increase the stack size
05:26:53 <shapr> in fact, I get it with 86682, but not 86681
05:27:10 <musasabi> cptchaos: yes, but that is not a solution.
05:27:40 <cptchaos> hm, a different algorithm?
05:27:56 <cptchaos> (or a differnt runtimesystem :-) )
05:29:32 <yohan> what's wrong with this line? :/
05:29:33 <yohan> putStr (str ++ "Thank you for playing!"
05:29:52 <yohan> ups
05:29:55 <yohan> crap wrong paste...nvm,
05:37:43 <cptchaos> mussabi: got a fix at last for shaprs 86681 border
05:38:20 <wkornew> hi, I just cannot get GHC to compile. it always says: "No rule to make target `Control/Arrow.o', needed by `libHSbase.a'.  Stop."
05:38:24 <wkornew> what am I doing wrong?
05:38:36 <cptchaos>     value (ToggleC t)    = do t <- readIORef t
05:38:36 <cptchaos>                               evaluate t
05:38:56 <wkornew> is there another way to compile it? maybe by using a different Haskell compiler?
05:39:39 <musasabi> hms, I'll test that in the evening.
05:39:46 <musasabi> have to go in 10min..
05:40:09 <yohan> could someone take a look at http://www.nomorepasting.com/paste.php?pasteID=21682
05:40:10 <yohan> ?
05:40:33 <shapr> yohan: wow, that's a fine looking chick... oops, wrong url.. ;-)
05:40:35 <cptchaos> wkornew: seem that your build of the libraries is corrupt 
05:41:35 <wkornew> cptchaos how can that happen? I am trying to port it
05:42:27 <cptchaos> i don't know, but I had similar broblems when trying to build ghc with threaded runtime system.
05:42:38 <cptchaos> but I don't know how to fix that
05:42:51 <wkornew> damn...
05:43:13 <wkornew> I want to use darcs! why is it written in Haskell?
05:43:16 <wkornew> !!!
05:43:17 <wkornew> :)
05:43:40 <ski> yohan : you can't have guards after you have already started a do-expr (in the "Just a ->" case-branch)
05:43:58 <cptchaos> because writing apps in haskell saves the coder a lot trouble 
05:44:18 <ski> yohan : you could use a another (nested) case as final stmt in that do-expr
05:44:23 <cptchaos> if the compiler and libraries are working ... ;-)
05:45:44 <ski> yohan : ok ?
05:45:47 <wkornew> which compiler could I try to port to port GHC? :)
05:46:23 <cptchaos> hm, I think ghc is the only way (maybe useing --via-c all the time
05:47:37 <wkornew> ./configure showed something about nhc98
05:48:17 <wkornew> why should it check if nhc98 is present if it cannot use it?
05:49:08 <cptchaos> ghc? don't know for historic reasons? maybe it works really don't know, but darcs could be usable with nhc98 or hugs
05:49:12 <cptchaos> I don't know
05:49:41 <wkornew> I will test it
05:49:45 <earthy> wkornew: historic reasons
05:49:58 <earthy> ghc 6 doesn't even compile with ghc 4 anymore
05:50:24 <wkornew> earthy, so how can I port GHC? is it impossible?
05:50:57 <shapr> it is possible
05:51:37 <cptchaos> to what architecture do you want to port GHC?
05:51:39 <wkornew> shapr, how? :))
05:51:44 <wkornew> BeOS
05:52:02 <shapr> but it might be a lot of work :-)
05:52:03 <wkornew> it has many POSIX functions, but no fully compliant
05:52:08 <wkornew> yeah ;)
05:52:33 <wkornew> though, there are some comments in the source already stating something about BeOS
05:52:40 <wkornew> maybe someone already tried?
05:52:48 <shapr> if you really want it, I'd suggest you read the porting guide, try to hack your way through it once or twice
05:52:56 <shapr> and then report problems to the ghc-users list
05:53:17 <shapr> it'll probably take 24 hours to get a reply, but I'm sure you'll get very knowledgable replies from the GHC authors.
05:53:39 <wkornew> do you think it would be harder to free dracs from GHC? :)
05:53:47 <shapr> yes
05:53:54 <wkornew> okay...
05:54:30 <wkornew> then, do I really have to use the method for a new architecture? argh!
05:54:49 <shapr> sad to say, I don't know of any BeOS users who also use GHC
05:55:13 <wkornew> tic does
05:55:23 <tic> Nope, I don't.
05:55:26 <shapr> but, if you log the whole build and put the logs online along with your description of the problems, I'm sure the Simons and others will help you get it working.
05:55:27 * tic used hugs.
05:55:39 <wkornew> ooops, I thought Haskell :)
05:55:54 <shapr> Hugs is a Haskell interpreter written in C
05:56:04 <shapr> GHC is a Haskell compiler written in Haskell
05:56:08 <wkornew> yes, I just replaced GHC with Haskell in my mind ;)
05:56:10 <yohan> ah thanks ski
06:09:59 <Lemmih_> Is there an easy way to return a string and the strings length from a function in C?
06:10:40 <cptchaos> by a pointer to a struct
06:11:03 <Lemmih_> I need to access the string in Haskell.
06:13:12 <tromp> anyone familiar with hal daume's haskell tutorial?
06:13:15 <cptchaos> Lemmith_ wirte a normal c function: void foobar( int lengt, char * str, argType arg)
06:14:29 <cptchaos> then the ffi type is Cint -> Ptr Int8 -> argType -> IO ()
06:14:46 <cptchaos> pseudo code, but for me it worded that way
06:15:18 <cptchaos> hm sorry the first arguement should be a pointer to
06:15:25 <Lemmih_> I was hoping to avoid the pointer to the length.
06:15:50 <cptchaos> than simple return it with the c funtion
06:16:22 <cptchaos> and write a wrapper to beautyfiy the pointer stuff, for the string
06:16:41 <CLxyz> would writing a haskell compiler in haskell be a good first project?
06:16:55 <shapr> CLxyz: I think it would be a heavy duty project
06:17:27 <cptchaos> CLxyz: sure, if you have a lot of time ... 
06:17:28 <shapr> CLxyz: if compilers interest you, you may want to start with a simple lambda cal interpreter
06:17:51 <CLxyz> thanks for that second tip shapr
06:18:22 <shapr> I wrote a simple text mandelbrot thingy first
06:18:33 <shapr> * for color, and space for nothing
06:19:16 <shapr> if you start with something really small like that, you get more focus on the FP part.
06:19:36 <cptchaos> CLxyz: compilers writing is a very intresting thing, and haskell is a very well suited language for that. But a  haskelcompieler is really a _huge_ project
06:19:58 <Lunar^> CLxyz: ever looked at SPJ tutorial ?
06:20:16 <shapr> "implementation of functional languages"
06:20:25 <shapr> you could write a TIM or G-machine
06:20:31 <Lunar^> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
06:20:44 <Lunar^> Damn good book
06:21:16 <CLxyz> ya, I like Huge projects :)
06:21:22 <shapr> also gets you realizing just how cool SPJ really is
06:21:29 <Lunar^> CLxyz: ever eard about hOp ;))) 
06:21:31 <Lunar^> ?
06:21:33 <shapr> hehe!
06:22:01 <shapr> hOp roxx
06:22:23 <CLxyz> hOp?
06:22:35 <shapr> haskell Operating system
06:22:42 <shapr> GHC running on the bare metal
06:22:42 * Lunar^ hides
06:22:56 <shapr> GHC as operating system
06:23:00 <shapr> it's way sexy
06:23:34 <CLxyz> Ah
06:23:44 <bbls> shapr any link?
06:23:45 <CLxyz> wouldnt that be hOs then?
06:23:53 <CLxyz> and GHC?
06:24:14 <CLxyz> damn, i really need to start hanging out here more often
06:24:30 <ski> mayhaps http://www.macs.hw.ac.uk/~sebc/hOp/ ?
06:24:31 <shapr> CLxyz: yes, we're cool ;-)
06:25:13 <CLxyz> hOp looks really cool
06:25:16 <shapr> it is!
06:25:16 <CLxyz> Hahaha
06:25:30 <CLxyz> it's an interesting change from the C stuff
06:25:40 <shapr> Lunar^ gets credit for a lot of the hOp code
06:26:56 <Lunar^> And a lot more for making that project staling
06:26:58 <Lunar^> But anyway
06:28:28 <ski> (also SML have been used for system programming)
06:30:11 <Lunar^> ski: Yes, John Hughes showed my the FoxNet project, which is really intersting
06:30:42 <ski> (Lunar^ : there's also http://web.access.net.au/felixadv/files/output/book/)
06:31:47 <Lunar^> ski: thanks
06:35:27 <ski> (hmm, can't find a live FoxNet page, atm ..)
06:47:02 <shapr> hiya lupettino
06:55:45 <Lemmih_> Anyone got time to identify the problem with the code I've posted on the haskell wiki?
07:20:38 <tromp> (++)=foldr ((.)(.)(:)) id
07:21:23 <Lemmih_> heh
07:23:22 <ski> point-less programming, eh ?
07:23:38 <tromp> yep:)
07:23:45 <ski> :)
07:23:51 <tic> mm, pancakes..
07:25:46 * Lemmih_ swears at Haskells FFI.
07:26:42 <rhw> Which of the textbooks/tutorials on the link in the topic would you recommend for an advanced C++ programmer who has no experience with functional PL ?
07:27:12 <kristnjov> "the craft of functional programming" by simon thompson i believe
07:27:13 <kristnjov> 2nd edition
07:27:30 <rhw> Thank you.
07:28:31 <ski> you can of course read the other online tutorials, too
07:29:23 <ski> (e.g. Yet Another Haskell Tutorial by Hal Daume III et al.)
07:29:44 <earthy> yaht is good, yes
07:39:36 <earthy> btw, who's the weirdo doing the BeOS port?
07:40:29 <earthy> he might actually get me to turn on my BeBox again :P
07:40:38 <earthy> to try for a wxHaskell port as well :)
07:42:10 <shapr> wkornew
07:42:30 <earthy> I noticed
07:42:53 <earthy> and only to get darcs to work as well...
07:43:00 <shapr> darcs is worth it
07:43:10 <earthy> I really should check if the ol' BeBox still works. ;)
07:43:26 <earthy> haven't switched it on in over a year ;)
07:52:39 <sorje> How would I do something like while (1) { sleep(1); foo; } in haskell?
07:53:58 <shapr> um, I dunno about sleep
07:54:05 <shapr> but fix foo maybe
07:54:10 <sorje> I can do the sleep part with threadDelay, but the infinite loop strikes me
07:54:29 <shapr> @index fix
07:54:29 <lambdabot> Control.Monad.Error,Control.Monad.Fix,Control.Monad.Identity,Control.Monad
07:54:29 <lambdabot> RWS,Control.Monad.Reader,Control.Monad.State,Control.Monad.Writer
07:54:31 <Igloo> mfix (\_ -> threadDelay 1000 >>= foo)
07:54:31 <phubuh> loop (sleep 1 >> foo)
07:54:34 <earthy> sorje: you simply generate an infinite list of sleep actions and execute those? :)
07:54:35 <phubuh>   where loop = fix (>>)
07:54:36 <phubuh> :)
07:54:48 <Maddas> heh
07:54:59 <Igloo> Ooops, >> not >>=
07:54:59 <earthy> that's even simpler ;)
07:55:27 <sorje> Okay, thanks a lot!
07:56:54 <ski> sorje : you can also do an explicit recursion
07:57:14 <sorje> Yes, I did it like that but it looked rather unhaskellish
07:57:20 <ski> theLoop = do threadDelay 1000
07:57:27 <ski>              foo
07:57:30 <ski>              theLoop
07:58:58 <sorje> Looks half as bad actually
08:31:17 <sorje> mhh, you have to go through quite some hassle to get some strftime.
08:35:33 <sorje> (and pleac_haskell is wonderfully useful! ;-)
09:15:33 * shapr cackles evilly
09:15:41 * kristnjov chuckles
09:15:46 <shapr> sorje: strftime is just getCalendarTime and that other function
09:15:50 <shapr> I've got it around here somewhere...
09:16:06 <shapr> sorje: you can probably figure it out yourself from System.Time docs
09:16:15 <shapr> but feel free to ask me if you have probs
09:18:56 <ski> "In particular, the world is never loaded into a register, stored in a data structure, or passed to C procedure calls." ;)
09:19:22 <ski> (From Imperative functional programming by SL Peyton Jones & P Wadler)
09:21:57 <Lemmih_> Yes! I just figured it out!
09:22:01 <shapr> yay!
09:22:52 <musasabi> evening
09:23:01 <shapr> y0
09:23:41 <Lemmih_> Algorithms is C can be very cryptic sometimes.
09:25:22 <earthy> s/is C//
09:25:52 <Lemmih_> Argh. *in
09:26:00 <earthy> that too. :)
09:26:50 <Lemmih_> Especially when the documentation is wrong.
09:27:49 <earthy> oh yes
09:29:39 <sorje> shapr, no, I think I have it but thank you anyway. ;-)
09:36:31 <Oejet> Greetings.  I have a function taking up half of the programs running time.  Thus it is a good candidate for optimization.
09:37:09 * Philippa spots the GADTs in GHC announce - very, very nice
09:37:14 <phubuh> GADTs?
09:37:16 <kristnjov> i hate that MAN style s/// thingie
09:37:30 <Philippa> Generalised ADTs
09:37:44 <Philippa> see SP-J's latest post on the Haskell list
09:38:08 <Oejet> What it does is take a Word64, and return a list of the bit positions that are set.
09:38:33 <Philippa> it's fairly simple - you can annotate the types of constructors, and you can make them "more specific" than the type they're constructors for
09:38:51 <ski> yay !
09:39:01 <Philippa> http://research.microsoft.com/~simonpj/tmp/gadt.html
09:39:37 <ski> does it restrict the types locally in case branches ?
09:40:33 <phubuh> oh, that's awesome
09:40:51 <Philippa> ski: not sure, grab the current snapshot and find out?
09:41:24 <tromp> what's the difference between algebraic and abstract data types?
09:41:54 <Philippa> an abstract data type you can't see, you can only see the operations exposed on it
09:42:14 <Philippa> Haskell only supports abstract data types via the module system (you write a module that doesn't expose the datatype's constructors)
09:42:27 <ski> algebraic data type ~= type constructed out of products (tuples/records) and sums (variants/disjoint unions)
09:43:22 <ski> abstract data type : type where concrete implementation is hidden, and only visible to a few interface operations, that are thus the only way to manipulate values of the ADT
09:43:46 <ski> an abstract data type can be implemented with an algebraic data type, e.g.
09:44:52 <Philippa> wow, that's a powerful example
09:46:48 <tromp> thx for the explanations
09:47:19 <ski> this is very cool ! :)
09:47:45 * Philippa wonders if she can add this to her dissertation project
09:47:55 <Philippa> I think I've finally decided on a name for the language, too
09:48:06 <Philippa> "tyop" (there's a prize for the first person to guess the origin)
09:48:15 <CraZyLeGs> :O
09:48:21 * phubuh guesses it has something to do with typos
09:48:28 <Philippa> phubuh: bingo
09:48:35 <ski> Philippa : your lang ?
09:48:56 <Philippa> yeah. 'snothing impressive, just a rig for testing H-M-like type systems
09:49:01 <Philippa> just a 3rd year undergrad project
09:49:32 <ski> so it's not a lang which attempts to correct tyops, then ? :)
09:49:39 <Philippa> sadly not :-)
09:49:44 <dblhelix> Philippa: do you actually have an interpreter or compiler for it, or is it just the type checker?
09:49:50 <Philippa> just parser'n'type checker atm
09:49:56 <ski> (or, maybe, which somehow makes tyops itself. i.e. in the machine code generated ;)
09:50:06 <Philippa> though aside from the type system it's meant to be v.haskell-like anyway - I'll prolly be hacking up an interpreter soonish
09:50:21 <ski> v.haskell ?
09:50:27 <Philippa> "very haskell-like"
09:50:33 <ski> ah, ty
09:50:52 * ski is hacking an a little type-sys himself
09:51:03 <ski> s/an/on/
09:51:22 <Philippa> so far mine's just H-M with subtyping - subtyping's closed, supertyping's open.
09:51:33 <Philippa> I'm considering System O-style overloading
09:51:41 <ski> in what sense ?
09:51:51 <ski> (i.e. open vs. closed)
09:52:08 <Philippa> you can't add an extra subtype to somebody else's type, you can give it a new supertype
09:52:22 <ski> hmm, example ?
09:52:29 <Philippa> to put it another way, pattern-matching's safe :-)
09:52:36 <Philippa> data Nothing a = Nothing
09:52:42 <Philippa> data Just a = Just a
09:52:55 <Philippa> data Maybe a = #Nothing | #Just (where # is "include this type")
09:53:08 <ski> s/#Just/#Just a/ ?
09:53:25 <Philippa> no, though that's arguably lame syntax. The kinds have to match
09:53:42 <ski> Maybe a ::: *
09:54:24 * Philippa shrugs - the syntax needs some work, anyway
09:54:28 <ski> so, anyway, you have sub-/super-typing for variants then ? no records in the system ?
09:55:03 <Philippa> there's no explicit support for records as opposed to tuples or constructors with multiple parms, but you could hack it up the usual way. No record subtyping though
09:55:15 <ski> ok
09:55:16 <Philippa> that's part of the aim of adding System O
09:55:19 <ski> any coinheritance ? ;-}
09:55:58 <Philippa> there's no inheritance at all, just the subtyping atm. Pretty trivial so far - I did say it's an undergrad project :-)
09:56:51 <Philippa> would like to figure out a good delegation mechanism though
09:56:54 <ski> hmm, do the supertyping mingle with pattern-matching nicely ?
09:56:58 <Philippa> yes
09:57:11 <ski> (btw, i said *co*inheritance, not inheritance)
09:57:20 <Philippa> ah, coinheritance is?
09:57:28 <Philippa> (say "the dual of inheritance" and die ;-)
09:57:32 <ski> hehe
09:57:55 <ski> similar to inheritance for records, but for variants instead
09:58:00 <ski> waitasec
09:58:59 <Philippa> but yeah. It works out the most specific (by subtyping) type for the discriminant. So far if you want it to restrict the type on the discriminant in the individual cases you'll have to rebind it with an as-pattern though
09:59:17 <Philippa> no reason it can't figure that out automagically, mind
10:01:14 <ski> http://www.cs.kun.nl/~erikpoll/publications/durham97.html and http://www.cs.kun.nl/~erikpoll/publications/kyoto97.html
10:01:35 <ski> Philippa : there you are
10:01:52 <ski> ok
10:05:03 <ski> Philippa : so, e.g. when caseing on an Either type, it knows the thing is in the respective subtype after that, right ?
10:05:08 <ski> like
10:05:19 <ski> Right a >>= amb = amb a
10:05:41 <ski> m@(Left _) >>= _ = m
10:05:49 <Philippa> you'd have to do the latter
10:05:59 <Philippa> rather than just using the original
10:06:00 <Philippa> but yeah
10:06:04 <ski> latter ?
10:06:09 <Philippa> m@...
10:06:12 <ski> using an at/as ?
10:06:13 <ski> ok
10:06:15 <Philippa> rather than case foo ... foo
10:06:19 <ski> yeah
10:06:26 <Philippa> can frig it to insert that automatically for you, of course
10:06:54 <ski> it would be a special case (i.e. if caseing on a variable)
10:07:18 <ski> would prolly be harder to make it (more) general
10:07:54 <ski> Philippa : those links i gave you talk some on coinheritance, anyway
10:09:17 <Philippa> yeah, will be reading them in a bit
10:09:28 <Philippa> got a friend heading round soon and need to get ready...
10:09:53 <ski> mm
10:11:16 <Philippa> not for that ;-)
10:19:35 <dblhelix> rumor travels fast: LtU reports on generalized algebraic data types
10:20:54 <ski> Philippa : eh, huh ? :)
10:25:56 <shapr> dblhelix: er hey! can't this beat the CGI Arrow problem?
10:26:26 <ski> dunno
10:27:29 <dblhelix> not sure ... to be honest: I haven't give it too much tought yet ... it was only Wednesday when I had a first serious look at GADTs
10:27:49 <dblhelix> and now I'm too darn busy hacking up an org chart in LaTeX :(
10:29:04 <dblhelix> anyway ... what could be the implications of GADTs for the type-class system? anyone?
10:30:55 <shapr> I think this does beat the CGI Arrow prob
10:30:59 <shapr> but I'm not yet positive
10:32:16 <dblhelix> well, it's weekend: so that gives you two days to find out ;)
10:32:34 <shapr> well, I was planning on hacking something else completely
10:32:39 <shapr> standard practice for me
10:33:06 <dblhelix> wanna tell us what magnificent code you are planning to write?
10:33:43 <Oejet> Hello.  Is there a function, Word64 -> Int, for converting the value?
10:33:44 <shapr> er, boring stuff actually :-)
10:33:56 <shapr> I'm trying to fully mix extreme programming and Haskell
10:33:57 <Igloo> fromIntegral
10:34:50 <shapr> so, darcs and quickcheck hacking
10:35:03 <phubuh> shapr: I tried to hack up a little ruby script to monitor file alteration with FAM & use tests, but it turns out FAM is utterly crippled
10:35:16 <shapr> to get stuff like better test-driven-development, zero-button testing
10:35:19 <shapr> phubuh: what about inotify?
10:35:32 <shapr> who's our local kernel expert since wli left?
10:35:32 <phubuh> yes, inotify seems a *lot* better :)
10:36:01 <shapr> I realized I want to run my tests a lot more often than I run darcs record
10:36:25 <phubuh> i seem to remember robert love saying something about haskell
10:36:30 <shapr> so I need something more than running darcs test during darcs record
10:36:41 <Oejet> Igloo: Thanks!
10:36:49 <phubuh> but google informs me that I'm probably misremembering
10:37:44 <phubuh> oh right, it was havoc pennington
11:04:26 <ski> hello jesse98
11:07:19 <Philippa> OK, so... I have the code for a program I want to release. Assuming there's nothing bar actual code, what's the minimum I should reasonably attach?
11:07:31 <Philippa> I assume copyright/license statements in comments at the top of each file and a "how to build"?
11:07:46 <shapr> yah, usually how to build is in the README
11:08:06 <kristnjov> make INSTALL
11:08:08 <kristnjov> ./program
11:08:10 <kristnjov> most often
11:08:23 <Philippa> you're assuming my code's that *nix-centric...
11:08:35 <kristnjov> i am indeed.
11:09:07 <shapr> also, you can just say -- see LICENCE.prog
11:12:17 <jesse98> hi ski
11:13:23 <ski> jesse98 : looking for haskell info ?
11:13:33 <jesse98> not really
11:14:30 <ski> (just lurking then, i presume :)
11:38:36 <shapr> can I give class constraints in the GADTs declaration?
11:47:16 <dblhelix> does anyone know how to change the appearance of float captions in LaTeX?
11:51:37 <shapr> y0 stepcut 
11:51:45 <shapr> I think I asked you this before, but do GADTs solve the CGI Arrow prob?
11:52:08 <stepcut> haha, "Saddama Bin Laden totally attacked us and we totally got him. Mission accomplished!"
11:52:19 <stepcut> shapr: as far as I can tell, no
11:52:40 <stepcut> but I am not a GADT master..
11:52:58 <shapr> as far as I can tell, it just lets you put type sigs on datatype constructors
11:54:50 <stepcut> hrm
11:56:18 <stepcut> the problem with CGI arrows is the pure (aka arr?) function needs the class constraint (Read a, Show a), but you can't add class constraints on a pure instance basis, the constraint needs to exist in the original class declaration
11:56:45 <shapr> oh, too bad.
12:01:40 <stepcut> yeah
12:04:39 <stepcut> if you could do something like: 
12:04:43 <stepcut> class (c a) => MyClass a where myfunc :: c a => a -> a
12:04:50 <stepcut> then we would be in business :p
12:30:30 <stepcut> I once found this great lint varient for c, where you would add special lint comments to your source code, and then it would detect all sorts of memory usage errors
12:31:05 <stepcut> like forgetting to free memory, using already freed memory, etc, but I don't remember what it was called, and I can't find it anymore :-(
12:31:44 <ski> not "purify", i guess ..
12:32:54 <stepcut> no, I think it had lint in the name
12:34:56 <stepcut> http://www.leenoar.ukos.com/lclint/
12:34:59 <stepcut> finally found it :)
12:36:52 <SyntaxLaptop> oh, stepcut; I was going to answer you!
12:36:56 <SyntaxLaptop> it's LC Lint!
12:37:19 <stepcut> lclint was my gateway drug into haskell :)
12:37:28 <SyntaxLaptop> haha
12:38:34 <stepcut> oddly, lclint does not seem to be in debian unstable, though it used to be in debian stable ...
12:39:02 <stepcut> in 1998 :)
12:54:38 <shapr> stepcut: does valgrind do everything lclint does?
12:55:26 <stepcut> shapr: never used valgrind, doesn't that require actually running the program ?
12:55:47 <shapr> yup
12:55:57 <Marvin--> yes, valgrind keeps track of memory reads and writes and stuff
12:56:07 <stepcut> lclint is a static checker, it just looks at the source
12:56:15 <shapr> valgrind was written by Julian Seward, and partially inspired by his work on GHC
12:56:29 <Marvin--> oh?
12:56:34 <Marvin--> I didn't know that
12:57:10 <shapr> http://builder.com.com/5100-6375-5136747.html?tag=tt --> "One of the major parts of GHC I worked on was the back-end x86 and SPARC code generators, and the register allocator. From this I learnt a lot about the x86 instruction set and code generation techniques, and the idea of making a memory-checking tool for Linux came back into view."
12:57:18 <stepcut> with lclint you add additional notation to your c-code like:
12:57:21 <stepcut> /*@only@*/ int **x;
12:57:39 <stepcut> and then a static checker looks for bugs
12:57:55 <shapr> hm, sensible
12:57:59 <shapr> a really smart compiler
12:58:16 <stepcut> int f (int *p, int *q) /*@modifies *p@*/;
12:58:56 <stepcut> declares a function f that may modify the value pointed to by its first argument but may not modify the value of its second argument or any global state.
12:59:36 <bbls> i'm working too on a language+compiler with static checker
12:59:44 <shapr> http://www.cs.utah.edu/flux/alchemy/software.html#knit
13:00:06 <stepcut> I used to use lclist back when I wrote c code -- it was a little bit of extra work to annotate the code, but it found tons-o-bugs
13:00:25 <shapr> I bet you could use Knit nowadays to do even more.
13:00:34 <bbls> stepcut does it requires the use of a standard C environment
13:00:48 <bbls> stepcut or could it be used for OS kernels as well?
13:01:09 <stepcut> but after using lclist for a while, I started looking for a language that did that sort of thing by default, and found clean, and then haskell
13:01:28 <Marvin--> hmmm, wonder if we can get Igloo to do a new ghc-cvs upload so we can play with GADTs
13:02:12 <stepcut> bbls: it should work, atleast in part, on any C code. Even if you do no mark-up it can still find other types of bugs
13:03:03 <stepcut> http://lclint.cs.virginia.edu/guide/
13:03:51 <bbls> what is splint?
13:03:55 <bbls> it's thes ame projecT?
13:08:45 <Igloo> Marvin--: Not until CVS HEAD compiles. And not to Debian until sparc gets off it arse and compiles the current one.
13:09:37 <shapr> who's sitting on sparc's arse?
13:11:00 <Igloo> The buildd admins. Not a Haskell person.
13:11:38 <shapr> oh
13:12:00 <shapr> should I send one of the #haskell enforcers over to their house with a spray can of whipped cream?
13:12:12 <Igloo> :-)
13:12:22 * ski grins
13:12:23 <Philippa> 'fraid I won't be volunteering for that task :-)
13:12:26 * shapr snickers
13:12:45 * kristnjov chuckles
13:12:45 <Philippa> nor for whipping the cream out of them :-)
13:16:57 <Marvin--> Igloo: dang :)
13:17:20 * Marvin-- decides to have another beer
13:17:26 * shapr has more RC Cola
13:18:05 <Igloo> Marvin--: Any comments on my recent debian-haskell mail BTW?
13:22:37 <Marvin--> which one?
13:23:04 <Marvin--> the policy stuff?
13:23:07 <Igloo> yup
13:24:17 <Maddas> stepcut: How is Clean like, do you like it?
13:27:39 <bbls> stepcut i'm running lclint on my programs.. upss. so many bugs :)
13:27:54 <Marvin--> Igloo: I dunno, it's complicated
13:28:34 <Igloo> Have you got a simpler suggestion?
13:28:47 <xkb> Maddas, Clean is nice... try it if you can :D
13:29:04 <xkb> http://www.cs.kun.nl/~clean/
13:29:11 <Marvin--> Igloo: I've been struggling with soundness bugs in latch loop optimizations all day so my brain's a bit fried right now, sorry  :)
13:29:23 <Igloo> OK, no worries  :-)
13:29:34 <Igloo> (latch?)
13:29:51 <Maddas> xkb: I certainly plan to try it, learning Haskell first though :-)
13:30:16 <xkb> Maddas, nice.. there is alot of "cross pollunation" between the 2 languages
13:30:18 <xkb> hmm
13:30:21 <xkb> how do you spell that
13:30:28 <shapr> pollination
13:30:31 <xkb> ah
13:30:33 <xkb> thanks
13:30:38 <ski> pollution ?
13:30:42 <ski> ;)
13:30:45 <shapr> pollunation is like the moons national police force ;-)
13:30:49 <thebug> the way you spelled it sort of makes me think of cross pollination/pollution ;)
13:31:07 <xkb> it might be considered pollution sometimes :D
13:31:11 <thebug> so the phrase works for both advacates and detractors :)
13:31:23 <thebug> s/va/vo/
13:38:58 <Marvin--> Igloo: memory element in circuit designs
13:39:15 <Igloo> Ah, that sort of latch  :-)
13:40:16 <Marvin--> yeah, it's what we do, static analysis of circuit designs
13:40:34 <Marvin--> or rather, we write tools for it
13:59:17 <shapr> hoi goron 
13:59:19 <shapr> wassup?
14:02:41 <goron> hej, nothing. 
14:05:07 <goron> I just got a mail from Simon P. Jones... 
14:05:39 <goron> He's trying to bind forces :)
14:07:56 <goron> shapr: How are your projects working out?
14:21:02 <shapr> goron: what's the email about?
14:21:33 <shapr> my projects are about as random and unfocussed as ever
14:22:15 <stepcut> shapr: haha
14:28:04 <goron> shapr: About the recent discussion on binary I/O.
14:28:59 <goron> shapr: He thinks the "community"(he didn't use that word) should come up with something and release it via Cabal. 
14:32:15 <Philippa> goron: that's probably the way to go for binary stuff. Is there an established means of turning ADTs into binary?
14:36:35 <shapr> hm, I think there is
14:36:49 <goron> Philippa: Not that I know of, but I am not the person to ask. I see it that the idea's of various people can *all* be implemented as modules of one giant library. The module that's the most useful in practice will then be used and the other will die a silent death after a while (because nobody maintains it). 
14:39:40 <stepcut> ls -v rocks
14:40:08 <Maddas> foldr1 rocks
14:40:11 <Maddas> :-)
14:40:16 <stepcut> that too
14:44:17 <wagle> foldr1 mount_saint_helens
14:49:52 <stepcut> mmm, binary
14:50:14 * cptchaos isn't able to think in c anymore ...
14:53:04 <wagle> lucky!
14:53:50 <stepcut> cptchaos: welcome to the club
14:56:37 <wagle> hoho..  i'm thinking about c compilers right now
14:57:14 <wagle> the cognitive dissonance stems from thinking about "security" at the same time
15:04:12 <wagle> (mount saint helens is a volcano 55 miles away that is becoming active)
20:35:45 <heatsink> Is -1 negative one?
22:41:20 <anduril1> is there a standard module that defines Show for a->a ?
22:42:40 <anduril1> nevermind, Text.Show.Functions
22:47:02 <heatsink> oh cool
22:47:10 <heatsink> I didn't know you could do that
22:47:41 <heatsink> oh, it just prints \<function>\
23:48:49 <heatsink> cool... I wrote a parser and interpreter for a mini language in ... six hours
23:54:33 <dblhelix> @yow
23:54:34 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474,
23:54:34 <lambdabot>  San Francisco, CA 94140, USA
23:56:35 <dblhelix> shapr: what are the latest insights regaring GADTs and the Arrow CGI problem? (or, more general, GADTs and type classes?)
23:59:10 <heatsink> dblhelix: I found fixST... that is what I wanted
23:59:38 <SamB_XP> is it true that the evil mangler was originally to compensate for gcc's lack of tail call support?
