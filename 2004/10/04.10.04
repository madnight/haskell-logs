00:00:24 <shapr> I was using TogetherJ(?) most recently, and it has a lot of internal conventions that I didn't agree with.
00:00:53 <shapr> So I could either use its conventions to continue to edit my GUIs later, or I could use it once to construct a GUI and then 'fix' the code it generated.
00:01:34 <shapr> I haven't used any RAD tools in the last year or two, maybe they've gotten better?
00:02:14 <vegai> I've only used Delphi seriously. It's ok.
00:02:16 <bbls> well, i often use Delphi/Kylix and i am very satified with it
00:02:32 <vegai> I guess I would like it more had I tried the others
00:02:58 <vegai> GNUStep shows a lot of promise with its interface builders, too
00:03:19 <shapr> I've used boa constructor a bit too
00:03:42 <vegai> the little I touched boa, it seemed much more awkward than Delphi
00:03:59 <bbls> well, i think that in order to have a good RAD you also need good support from the language (basicly good modularisation/OOP support)
00:04:06 <shapr> at least with Java, I can make a GUI by hand faster than with a RAD tool, and I get more control that way too.
00:04:15 <bbls> this is why BC Builder sucks while Delphi rules
00:04:42 <bbls> they are produced by the same company, use same concepts and GUI, and yet Delphi is far much more usable than BCBuilder
00:04:55 <vegai> oops, gotta run
00:05:02 <shapr> I gotta finish my homework...
00:05:05 <bbls> bye vegai
00:05:11 <shapr> hei hei vegai 
00:05:27 <shapr> mmmm -> http://web.media.mit.edu/~hayes/topobo/
00:05:50 <bbls> shapr what's that?
00:06:49 <shapr> er, kinetic memory lego
00:12:57 <Maddas> heh, cool
00:16:09 <musasabi> Is there a darcs emacs binding?
00:24:00 <shapr> there are several, but I haven't tried all of them.
00:24:10 <shapr> http://www.scannedinavian.org/DarcsWiki/CategoryEmacs
01:15:59 <Pseudonym> Must away.  Nytol!
01:49:09 <phubuh> Maddas: pong
01:50:08 <Maddas> phubuh: been working on anything fun lately? :)
01:50:22 <phubuh> nope :(
01:50:28 <Maddas> :-(
01:50:37 <phubuh> you?
01:50:54 <Maddas> Not working on anything at all ;-)
02:16:46 <Maddas> Heh, Literate Haskell is a cool idea.
02:17:25 <cptchaos> Maddas: yes it is :-)
03:02:39 * Maddas boggles
03:02:59 <Maddas> The code on http://pleac.sourceforge.net/pleac_haskell/strings.html (e.g. "Accessing Substrings") isn't supposed to work, right?
03:05:48 <kosmikus> define "work"
03:06:00 <kosmikus> I would guess it does, but you need their library, of course
03:06:16 <Maddas> Hm, maybe they just re-defined standard things then :-)
03:06:29 <kosmikus> yes
03:06:46 <Maddas> ah, ok
03:10:40 <phubuh> wtf
03:10:49 <phubuh> that whole page seems to use some crazy noun.verb thing
03:11:28 <phubuh> (.) = flip ($) i guess
03:12:13 <cptchaos> @index flip
03:12:13 <lambdabot> GHC.Base,Prelude
03:12:34 <Maddas> phubuh: Yeah, that's part of what I don't understand :)
03:13:19 <phubuh> @type flip
03:13:21 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
03:13:27 <phubuh> @type flip ($)
03:13:28 <lambdabot> flip ($) :: forall b b1. b1 -> (b1 -> b) -> b
03:13:37 <dblhelix> flip f a b = f b a
03:13:49 <dblhelix> flip ($) a f = f a
03:14:17 <arjanb> @type (.)
03:14:18 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
03:14:36 * Lemmih is back from school.
03:17:34 <phubuh> oh.
03:17:34 <phubuh> (.) o f = f o -- object notation for object fan, use it if function have more than one parameter or
03:17:34 <phubuh> 	      -- if you want make an "oo-line" (ex o.words.reverse.unwords)
03:19:50 <TheHunter> this is definitely the weirdest piece of "haskell" code i've ever seen
03:22:10 <TheHunter> well, at least the collection stuff seems to make sense
03:26:38 <Maddas> whoa
03:26:47 <Maddas> phubuh: That looks really silly to me :-(
03:27:43 <phubuh> likewise :)
03:28:54 <Maddas> Especially in something designed to be a reference of how to solve common problems :)
03:30:47 <Maddas> Ah, no wonder I didn't understand it. He re-defined ., !!, $, and many other things :)
03:31:06 <Maddas> (!) :: ca -> i -> a -- lookup, to be more esthetic do s!(0) rather than s!0
04:02:04 <Oejet> Maddas, what text are you talking about, if I may ask?
04:02:29 <bbls1> http://www.bordergatewayprotocol.net/jon/humor/web_animations/NAKED.swf
04:02:34 <Maddas> Oejet: The code on http://pleac.sourceforge.net/pleac_haskell/, especially "String Matching"
04:08:44 <Oejet> Maddas, ok, I can't seem to find the right place. Are you talking about the "1. Strings" section?
04:09:19 <Maddas> yes, the code there..
04:09:20 <Maddas> .
04:09:59 <Maddas> That's only using the things, the actual re-defining is in "Helpers", not "Strings"
04:29:17 <bourbaki> hi
04:32:04 <TheHunter> hi bourbaki 
04:32:14 <TheHunter> how's your thesis going?
04:37:56 <bourbaki> TheHunter: i havent been doing too much on it lately to be honest :)
04:44:39 * shapr hops
04:44:47 <shapr> GOOD MORNING VIETHASKELL!
04:45:03 * shapr peers around curiously
04:45:06 <bbls1> :)
04:45:23 * Maddas cleverly removes an "r" from shapr's action
04:45:28 <Maddas> s/an/a/
04:45:45 <shapr> Maddas: does that mean I'm telling everyone to piss off?
04:45:51 <Maddas> haha
04:46:11 <Maddas> Good morning, by the way :-)
04:46:25 <shapr> y0 y0
04:47:09 <musasabi> morning
04:47:30 <shapr> heippa
04:47:46 <shapr> hm, what to do today.
04:47:52 <shapr> oh, I know.. CODE!
04:48:10 <bourbaki> greetings shapr 
04:48:15 <shapr> gutentag bourbaki 
04:48:22 <bourbaki> *bows*
04:48:31 <shapr> *ribbons*
04:48:41 <bourbaki> heh
04:49:26 <bourbaki> why is there no haskell ribbon?
04:50:01 <shapr> um, what would a Haskell ribbon do?
04:50:30 <bourbaki> it would be like an aids ribbon just formed like an h :)
04:50:44 <bourbaki> and i guess it would be blue
04:51:35 <shapr> I'd like a weak head normal form ribbon.
04:51:52 <bourbaki> whats a weak head ribbon?
04:52:04 <shapr> @jargon "weak head normal form"
04:52:05 <lambdabot> No match for ""weak head normal form"".
04:52:07 <shapr> hmm
04:52:15 <shapr> @all-dicts "weak head normal form"
04:52:16 <lambdabot> *** "weak head normal form" foldoc "The Free On-line Dictionary of Computing
04:52:16 <lambdabot> (27 SEP 03)"
04:52:16 <lambdabot> Weak Head Normal Form
04:52:16 <lambdabot>      
04:52:17 <lambdabot>         <reduction, lambda calculus> (WHNF) A {lambda expression} is
04:52:19 <lambdabot>         in weak head normal form (WHNF) if it is a {head normal form}
04:52:21 <lambdabot>         (HNF) or any {lambda abstraction}.  I.e. the top level is not
04:52:24 <lambdabot>         a {redex}.
04:52:25 <lambdabot> [33 @more lines]
04:53:00 <bourbaki> hehe to me hnf is hessian normal form :)
04:53:37 <shapr> I'm not familiar with that.
04:53:46 <shapr> is that like BNF but hessian?
04:53:57 <bourbaki> thats a form of a plane equation
04:54:12 <bourbaki> n * p - d = 0
04:54:16 <shapr> better than schwabisch normal form, right?
04:54:31 <shapr> or leipzisch normal form maybe...
04:54:44 <bourbaki> :) schwabisch normal form ? is there really something like that?
04:54:51 <shapr> no :-)
04:56:01 <shapr> I forget which part of .de speaks schwabisch
04:56:27 <bourbaki> hm to be honest i dont know either where they are :)
04:56:33 <shapr> http://www.german.webtourist.net/destinationen/hotels-in-schwabisch-deutschland.html
04:56:40 <bourbaki> but im geographically challenged ;)
04:56:45 <shapr> so am I
04:56:54 <shapr> if it's not an IP address or a hostname, I'm lost.
04:57:30 <bourbaki> :)
04:57:35 <shapr> written any code lately?
04:58:40 <bourbaki> no i just needed a break
04:59:06 <shapr> writing code is often a break for me. If it's non-work code at least.
04:59:29 <bourbaki> i have to think 99% and code 1% :)
04:59:44 <bourbaki> but sometimes i think so much that i need a break
05:00:06 <shapr> I want to write code that does my thinking for me.
05:00:12 <bourbaki> to review what i did ie with my thesis sometimes when i take a break i wonder what i did there
05:00:16 <bourbaki> :)
05:00:29 <bourbaki> reminds me of adams dirk gently
05:00:33 <bourbaki> the electrical monk
05:00:39 <bourbaki> that believes for you :)
05:02:22 <bourbaki> i think i need ppl in my vicinity that help me to review my own stuff and try things out
05:14:28 <shapr> is IRC in your vicinity?
05:16:19 <bourbaki> yes and no
05:16:43 <bourbaki> it helps to talk here but i like to talk irl a lot more
05:16:53 <CLxyz> FP is nice
05:17:08 <CLxyz> its a lot easier for IRL ppl to actually help
05:17:13 <bourbaki> you can draw pictures and such
05:18:11 <bourbaki> i wish that my idea for the thesis was so interesting that more ppl then just i could think about it to write it
05:18:57 <CLxyz> haha
05:19:03 <CLxyz> whats ur thesis bourbaki
05:19:15 <bourbaki> the problem with that suff is exactly what my math prof told me once that you loose track of things
05:19:43 <bourbaki> :) my thesis tries to combine topology, fp, automatos, graphs
05:20:32 <bourbaki> for ai purposes
05:22:32 <bourbaki> *automatons
05:22:41 <earthy> automata
05:22:44 <earthy> ;)
05:22:44 <CLxyz> sounds interesting
05:22:45 <bourbaki> right :)
05:23:15 <earthy> but it all sounds way beyond me
05:23:17 <bourbaki> its a bit like petri nets but you try to look at it from different angles
05:23:20 <earthy> too abstract
05:23:22 <shapr> automatos == robotic veggies
05:23:23 <earthy> ;)
05:23:25 <bourbaki> :)
05:23:38 <bourbaki> the problem is that i sometimes loose track of things myself
05:23:46 <bourbaki> i wonder sometimes what i do :)
05:23:52 <shapr> can you write unit tests for your thesis?
05:24:02 <earthy> yes, that is a sure sign you're doing the wrong thing. :)
05:24:10 <CLxyz> hahahaha
05:24:16 <bourbaki> i started once to write a graph and tooplogy class
05:24:35 <bourbaki> well i think that this sometimes happen when you to abstract math
05:24:55 <bourbaki> i have some pictures and diagrams
05:25:08 <bourbaki> oh and i also use category theory at least i still try
05:25:34 <shapr> how do you want to combine topo, fp, autos, and graphs?
05:25:41 <shapr> what should it do?
05:26:05 <bourbaki> ok this all started back when i did some research programming for shader graphs
05:26:27 <bourbaki> i wanted to write programs with graphs that also can be done by designers
05:27:06 <bourbaki> the idea is that you split the design process of a program in different steps and the first step is to design a graph that models the "flow" of the program
05:27:18 <bourbaki> like a petri net of a data flow diagram
05:27:45 <bourbaki> but its not implemented at that time just that the nodes have domains and the edges have function names
05:28:36 <bourbaki> atm i use some stuff from ct like the cartesian product to build processes that are like threads that is that n datas are processed at once
05:28:40 <shapr> couldn't the flow be the implementation?
05:28:57 <shapr> I think you could make an executable flow with AFRP
05:29:09 <shapr> this sounds a bit like arrows
05:29:19 <bourbaki> i would need to write the graph and topo stuff and a small conversion thing that then runs the program on this structure
05:29:31 <bourbaki> yes its a bit related
05:29:46 <bourbaki> the idea is that you can change the view of that structure
05:29:53 <bourbaki> you can look at it as a graph or topology
05:30:01 <bourbaki> or as a category to proof things
05:30:07 <bourbaki> a small example
05:30:18 <shapr> I'd like to see topo and category views of a graph.
05:30:23 <bourbaki> you know these number sequences
05:30:24 <shapr> I don't know how they compare.
05:30:27 <shapr> no?
05:30:42 <bourbaki> well a graph has always a topology
05:31:04 <bourbaki> and the graph with the functions and such can be seen as a topo
05:31:10 <shapr> oh
05:31:15 <bourbaki> the graph is cartesian closed
05:31:27 <bourbaki> that is you can always build the product of two nodes
05:31:31 <bourbaki> or channels as i call them
05:31:40 <bourbaki> to run new functions
05:31:52 <shapr> somewhat like this? http://wouter.fov120.com/proglang/pix/g1.gif
05:31:57 <bourbaki> sec
05:32:24 <bourbaki> kind of yes
05:32:31 <shapr> or maybe this? http://wouter.fov120.com/aardappel/index.html
05:32:39 <shapr> though that's more tree transforms
05:32:58 <bourbaki> well treetransformations come naturally
05:33:14 <bourbaki> in the end the idea is that there is no difference between data and a program
05:33:26 <bourbaki> that is the graphs can be used as data as well
05:33:38 <bourbaki> just a small example with the number sequence thing
05:33:45 <bourbaki> you have a node that is the input node
05:33:53 <bourbaki> where the first number comes in
05:34:32 <shapr> this sounds straightforward so far
05:34:58 <bourbaki> then you have some edges that represent the basic operation + - * /  and mod
05:35:12 <bourbaki> and then the next edges are the numbers
05:35:33 <bourbaki> i would use some special numbers like 0 1 2 5 9 or so
05:36:02 <bourbaki> cause you can get alot of numbers with a few operations and reduce the comlexity of the graph
05:36:25 <bourbaki> and the 3rd and the 1st node are basicaly the same
05:36:41 <bourbaki> so you can cirle as long as you want until you get the next number
05:37:07 <shapr> graph reduction is one way to implement functional languages.
05:37:07 <bourbaki> this is quite like an automaton but what i want to do now is look at it as a graph
05:37:40 <bourbaki> and do a search to yield the function that uses the fewest number of steps
05:37:56 <bourbaki> and then i apply this to the next number to see if it surfices the sequence
05:38:03 <bourbaki> if not i search for the next function
05:38:05 <shapr> I think it might help you to read "implementation of functional languages" by lester and peyton-jones
05:38:07 <shapr> maybe
05:38:20 <bourbaki> so you have the automaton that is a graph that represents a functional topoly
05:38:27 <shapr> and you might want to read Wouter's proglang page for inspiration - http://wouter.fov120.com/proglang/index.html
05:38:47 <bourbaki> cool thanks
05:39:17 <bourbaki> the problem is that the whole thing uses a lot of things from diffecent fields and i cant take care of it all
05:39:25 <shapr> I think you can.
05:39:36 <bourbaki> i want to have something like graph reweireting and so as well
05:39:58 <bourbaki> what i want to concentrate on most atm is that i have a good foundation of the equality of the 4 things
05:40:06 <shapr> I'd suggest you write prototypes of each feature that you want
05:40:07 <bourbaki> and to point out that its usefull
05:40:18 <shapr> maybe start with viewing a graph as a topo and a cat
05:40:45 <bourbaki> i ordered a book on process algebra at my prof
05:40:55 <bourbaki> i think that it will help also
05:41:03 <shapr> once you have working prototypes of each feature, you'll know a lot more about the problems involved.
05:41:10 <bourbaki> sec phone
05:41:13 <shapr> then you can really start to develop
05:43:50 <bourbaki> a friend of mine is writeing a graph editor for uni
05:44:26 <bourbaki> small scale ill develop it a bit further with him so i can use that maybe well do that in haskell atm its in java but i hate java and he starts to like haskell :)
05:44:57 <bourbaki> i have an implementation that runs in lisp
05:45:00 <shapr> neat
05:45:05 <bourbaki> with irc channels
05:45:20 <bourbaki> once i have the algebraic stuff in haskell i can run the program in list
05:45:23 <bourbaki> er lisp
05:45:56 <bourbaki> the cool thing is then that you just need an irc bot that executes whatever gets in the channel
05:46:18 <bourbaki> so you can spread programs over the net and implement one program with different languages
05:46:52 <shapr> well, implement the prototypes first
05:46:56 <shapr> then you're likely to get more interest
05:46:59 <shapr> greetings xerox 
05:47:19 <xerox> hello
05:47:29 <bourbaki> yep true i have to remind myself to send me my thesis next time when im at the other machine
05:47:59 <shapr> xerox: looking for Haskell info?
05:48:22 * shapr refuses to make any of the copy machine jokes that come to mind
05:48:32 <xerox> shapr uhm, maybe.. a friend of mine told me to try to understand this language
05:48:35 <xerox> ouch.
05:49:13 <shapr> xerox: http://www.scannedinavian.org/AvianWiki/HaskellDemo
05:49:31 <shapr> does that friend of yours also show up here on #haskell?
05:50:15 <xerox> let's see
05:50:21 <xerox> yup, reffie
05:51:55 <shapr> ah
05:53:56 <xerox> thanks for the demo, but i'll go searching for basics :D
05:54:24 <shapr> what sort of programming language experience do you have?
05:54:31 <shapr> have you worked with lisp or scheme?
05:54:38 <shapr> or Python, Java, or C?
05:55:14 <xerox> mainly C and asm, but i learned some lis/scheme things 
05:55:18 <xerox> *lisp
05:55:20 <shapr> this is a good place to start --> http://www.haskell.org/learning.html
05:55:30 <xerox> you know, MIT's videolessons about scheme
05:55:33 <shapr> if you know som lisp/scheme, then you have some functional programming experience.
05:55:37 <shapr> oh yeah, those are cool.
05:55:38 <xerox> yep
05:56:34 <shapr> do you have GHC or Hugs installed?
05:57:07 <shapr> Hal Daume's 'Yet Another Haskell Tutorial' is a good place to start.
05:57:20 <shapr> I like the stuff on the Haskell Wiki - http://www.haskell.org/hawiki/CommonHaskellIdioms
05:58:25 <xerox> GHC or Hugs
05:58:34 <xerox> uhm, i don't even know what they are
05:58:49 <xerox> btw i'm stuck on win32 as now, so i must choose something.exe
05:58:54 <shapr> GHC is a Haskell compiler written in Haskell, Hugs is a Haskell interpreter written in C.
05:59:16 <shapr> http://www.haskell.org/ghc/dist/6.2.1/ghc-6-2-1_1.msi
05:59:46 <xerox> gee, so fast.
05:59:55 <xerox> you do like haskell so much? :D
06:00:06 <shapr> yes, I do.
06:00:27 <shapr> I've written bits of lambdabot, some stuff on the Haskell Wiki, a few apps of my own.
06:00:36 <shapr> @hello
06:00:36 <lambdabot> Hello world. 
06:00:45 <shapr> lambdabot is written in Haskell, of course.
06:00:56 <xerox> reffie wrote a bot i haskell
06:00:57 <shapr> he has two plugin APIs, one easy, one harder.
06:00:58 <xerox> too
06:01:17 <xerox> http://www.nectarine.it/~refugee/hbot.hs
06:01:18 <shapr> I heard that reffie has borrowed some bits of lambdabot.
06:01:29 <xerox> haha ! that's a news..
06:03:33 <xerox> let's bookmark the site you told me (thanks much)
06:05:20 <shapr> hbot is nice, very simple.
06:05:33 <xerox> dunno really.
06:05:34 <xerox> :D
06:09:39 <det> I heard Haskell was slow
06:09:41 <det> Is this true?
06:09:57 <shapr> det: it's true. but so is C.
06:10:28 <shapr> in fact, C is significantly slower than Haskell for the set of problems that concern me.
06:10:59 <det> shapr: what set of problems is that? Mental masturbation?
06:11:06 <det> :p
06:11:24 <shapr> no, writing code that actually works correctly.
06:12:32 <ibid> asking if haskell is slow is like asking if drawing paper can withstand a collision with a plane without falling down
06:13:12 <shapr> det: Haskell is the language of choice for discriminating hackers.
06:13:23 <det> shapr: this is true
06:14:07 <det> shapr: C++ was the most commonly entered language :)
06:14:17 <det> shapr: and Haskell cleaned house
06:14:44 <shapr> anyway, I wrote a spambayes program in between three and four evenings and it took about 200 lines of code. It only found 85% of the spam, but that's pretty good since I knew nothing about bayesian statistics before that.
06:14:47 <ibid> (they are both meaningless questions but if you substitute something that you can design with it, it becomes meaningful)
06:14:53 <ibid> (programs vs buildings:)
06:15:47 <xerox> !
06:15:56 <shapr> I wrote a mailing list search program in less time than that, but then I actually had experience with the database and email libs.
06:17:05 <det> ibid: So I cant say Python has poor execution efficiency either? :)
06:17:47 <shapr> I'd say that Haskell is faster than Python in general.
06:17:49 <ibid> det: since python has essentially only one implementation, the situation is different
06:18:13 <ibid> det: but in general, yeah, i don't think *languages* are fast or slow :)
06:23:32 <xerox> thanks again
06:23:37 <xerox> gotta study some math, see you later
06:23:41 <shapr> ok, cya
06:25:42 <shapr> y0 anth
06:27:33 * shapr cackles evilly
06:35:29 <vegai> ibid: python has cpython (the "standard" one), jpython (java), ironpython (.net)
06:38:26 <reffie> shapr the only part i stole from lambdabot was the IRCMessage type :P
06:38:44 <shapr> ok
06:38:50 <shapr> glad it was useful :-)
06:39:18 <shapr> Pseudonym wrote lambdabot, he gets credit for IRCMessage and all the other core code.
06:39:24 <reffie> oh, and the dict module
06:39:39 <shapr> that was Tom Moertel
06:40:16 <reffie> my thing is only for my personal consumption, anyway
06:40:24 <reffie> that said, i'm off to class :(
06:52:32 <ibid> vegai: i know
07:04:39 * shapr cheers for Haskell!
07:07:08 <shapr> greetz mornfall 
07:07:11 <shapr> how's code?
07:07:26 <mornfall> yow
07:07:31 <shapr> @yow !
07:07:31 <lambdabot> FUN is never having to say you're SUSHI!!
07:08:03 <mornfall> shapr: heh, sarahbot in #haskell version? ;)
07:08:13 <shapr> or maybe sarahbot is the clone?
07:08:22 <mornfall> shapr: naaah :p
07:08:57 <mornfall> anyway, is there an online haskell book somewhere?
07:09:02 <shapr> yes there is!
07:09:09 <mornfall> good =)
07:09:11 <shapr> lots of goodies on http://www.haskell.org/learning.html
07:09:18 <shapr> I like the "Yet Another Haskell Tutorial"
07:09:37 <mornfall> shapr: well, i'm sitting on a C++ lecture, but heck it :p
07:09:42 <shapr> heh
07:09:46 <mornfall> shapr: it's boring, boring, boring
07:10:00 <shapr> you could read up on the functional aspects of STL
07:10:17 <mornfall> shapr: hmm, it's cumbersome
07:10:28 <mornfall> shapr: but yes, better than nothing
07:11:08 <mornfall> shapr: the lecturer is speaking for 10 minutes now about primitive C++ types
07:11:48 * mornfall grabs the yaht pdf
07:12:22 <mornfall> hmm, what shall i put into the affiliation field? ;)
07:12:30 <shapr> whatever you want
07:12:45 <shapr> I usually put in "Organized Discordians of Europe"
07:13:05 <mornfall> shapr: heh =)
07:20:02 <earthy> fnord :)
07:20:08 <shapr> Hail Eris!
07:21:46 <earthy> All hail Bob!
07:22:00 <bourbaki> bob who?
07:22:06 <shapr> Bob Dobbs? Church of the Subgenius?
07:23:33 <earthy> blort
07:25:30 <shapr> y0 gintas 
07:25:41 <gintas> hi shapr
07:30:44 * shapr chortles merrily
07:38:37 <musasabi> http://cryp.to/blockio/ seems nice.
07:43:05 <shapr> I haven't installed it yet, though I just sucked down the darcs repo
07:50:52 <stepcut> it looks like sqlite 3.0.7 might work better with haskelldb
07:51:10 <stepcut> http://www.linuxjournal.com/article.php?sid=7803
07:51:51 <stepcut> its still typeless but has some mode where it pretends not to be ?!
08:11:26 <reffie> hey you, big star, you blaze!
08:12:05 <shapr> ?
08:27:40 * shapr boings
08:33:58 <shapr> y0 SyntaxLaptop 
08:34:23 <shapr> wassup?
08:34:27 <SyntaxLaptop> hi shapr
08:34:40 <SyntaxLaptop> I put darcs 1.0.0rc3 at haskell-unsafe yesterday for your testing pleasure
08:34:45 <shapr> yay
08:34:58 <shapr> my many 'darcs pull -a' from today have worked well.
08:35:35 <SyntaxLaptop> that's with rc3?
08:35:51 <shapr> yup
08:36:02 <SyntaxLaptop> sweeeet
08:36:15 <shapr> oh, I fixed a bug in wxHaskell debs
08:36:16 <shapr> sort of
08:36:28 <shapr> shlibs needs to have a /usr/lib taken out
08:36:48 <shapr> otherwise the symlink in /usr/lib isn't created
08:37:04 <SyntaxLaptop> can you send me a patch?
08:37:34 <shapr> you just need to remove those six chars from the shlibs file part of the deb
08:37:51 <shapr> er eight chars
08:39:57 <shapr> do you keep the control files for those debs in a darcs repo?
08:40:03 <shapr> I could send a patch for that
08:48:23 * shapr boofs
08:58:44 * shapr boings
08:58:57 <sorje> Is there some standard library to parse commandline arguments?
08:59:04 <shapr> yes
08:59:08 <shapr> and there's a non-standard lib too
08:59:26 * shapr gets url
08:59:44 <shapr> standard --> http://www.haskell.org/ghc/docs/6.2.1/html/libraries/base/System.Console.GetOpt.html
09:00:08 <shapr> non-standard --> http://www.scannedinavian.org/~pesco/ Pesco.Cmdline
09:00:35 <sorje> Cool, thank you very much
09:00:41 <shapr> anything else?
09:00:45 <shapr> would you like fries with that? ;-)
09:01:04 <sorje> With ketchup please
09:01:34 * shapr quickly combinates some Lambda Fries
09:01:40 <Maddas> :-)
09:01:51 <shapr> whoops, that one was partially applied.
09:01:58 <sorje> ;-)
09:02:02 <shapr> man, I hate finding redexes in the fridge.
09:02:39 <shapr> that usually only happens after a late-night coding party.
09:03:01 <shapr> oh man, I forgot to tell stepcut about House.
09:05:00 <shapr> shammah: hey, you think we'll get part 4 of Bananas, Lenses, Envelopes and Barbed Wire soon?
09:09:09 <shapr> hej hram 
09:09:11 <shapr> how's code?
09:10:34 <hram> shapr: everything's nice... currently correcting students' assignments.
09:11:15 <hram> (do you say "correcting"?)
09:11:18 <shapr> yup
09:11:31 <shapr> == kontrollera ?
09:11:48 <hram> rätta...
09:13:04 <shapr> ah
09:14:10 <shapr> correcting is sometimes used to mean only checking for errors, but it should mean to put in the correct answers next to wrong answers.
09:14:55 <hram> doing a bit of both really :)
09:21:57 <shapr> det: y0
09:25:20 <dblhelix> kosmikus: ping?
09:28:19 <kosmikus> dblhelix: pong
09:29:04 <dblhelix> :) I contacted Jur today ... well, actually I mailed him last Thursday and he answered today ...
09:30:00 <dblhelix> we'll meet next Thursday ... but, well, he didn't sound too enthousiastic :(
09:30:54 <kosmikus> what did he say?
09:31:30 * kosmikus has to leave in 6 minutes ...
09:32:08 <dblhelix> that I wasn't likely to be the only candidate (well, I had figured that) and that he'll send me the call for application when it was out ... and that we could meet next Thursday ...
09:32:22 * dblhelix is off for dinner in a few minutes ;)
09:33:56 <kosmikus> dblhelix: well, there's a certain other one being interested as well, yes
09:34:23 <dblhelix> I figured ...
09:34:31 <shapr> any Yampa users around?
09:49:32 <bbls> hi xerox
09:49:35 <bbls> strange nick :)
09:49:52 <sorje> GetOpt's interface is strange... ;-)
09:50:06 <bbls> :)
09:50:38 <shapr> did you try Pesco.Cmdline?
09:51:29 <sorje> I will do so after I feel familiar with the standard. Or so was the plan.
09:54:37 <sorje> But what the hell is the second argument of OptArg ?
09:55:10 <xerox> hi bbls
09:55:14 <xerox> strange? :D
09:55:18 <xerox> what about yours :P
09:58:54 <sorje> Oh shoot that. I've had enough for today. Bye. 
09:59:00 <shapr> have fun!
10:02:57 <shapr> Igloo: I got UserDir working on haskell.org, with chmod 711 on my home dir.
10:03:31 <bourbaki> shapr: did you get the sicp lecture videos?
10:03:59 <shapr> er, I think so
10:11:13 <shapr> hiya raboof 
10:11:21 <raboof> evening!
10:11:24 <shapr> looking for Haskell info?
10:11:52 <raboof> yeah, i'm just starting out
10:12:14 <raboof> i got myself ghc, is that a good one to start with?
10:12:17 <shapr> what's your goal? learning for class? specific app in mind?
10:12:18 <bourbaki> shapr: why dont you rename yourself to cindy ;)?
10:12:20 <shapr> yes, I like GHC.
10:12:24 <shapr> bourbaki: who's cindy?
10:12:33 <bourbaki> cindy portier ;)
10:12:52 <bourbaki> i know my jokes are bad heh
10:12:55 <shapr> raboof: should I point you to the wxHaskell bindings so you can jumpstart from something you already know?
10:13:01 <bourbaki> just cause you welcome everyone
10:13:11 <raboof> shapr: well, i've learned Clean (a more low-profile functional language) for university a few years ago
10:13:23 <shapr> ah, then you won't have much trouble with Haskell.
10:13:41 <shapr> bourbaki: who is cindy portier?
10:13:46 <raboof> basically my goal is to fool around with functional programming more
10:13:52 <shapr> that's a good goal
10:13:59 <raboof> possibly find a subject for my Masters' thesis :)
10:14:09 <shapr> cool, what sort of thesis are you aiming for?
10:14:18 <shapr> compilers, GUIs, or what?
10:14:23 <bourbaki> hehe cindy is acually sidney :)
10:14:51 <raboof> don't know yet, just exploring. but something with concurrency and user interaction in functional languages might be interesting
10:15:37 <bourbaki> http://www.imdb.com/name/nm0001627/
10:15:47 <bourbaki> it was just a bad word play of mine
10:15:47 <raboof> in regular programming, concurrency is cumbersome and unpractical. in functional programming, a lot of efficiency can probably be gained quite transparent to the programmer
10:15:49 <shapr> that covers a lot of ground
10:16:00 <SyntaxLaptop> raboof: oh, clean looks cool.
10:16:05 <raboof> that's the general intuition, but maybe it's not suitable at all :)
10:16:25 <jesse98> yeah, bot only limited concurrency raboof: no non-determinism for example
10:16:53 <shapr> I wonder if Yampa counts in there with concurrency.
10:17:00 <shapr> bourbaki: does he greet people a lot?
10:17:13 <raboof> SyntaxLaptop: from what i've seen so far it looks quite similar to haskell :)
10:17:28 <thebug> yo SyntaxLaptop
10:17:32 <raboof> is networking in haskell hard?
10:17:41 <tuomov> I prefer select() ... for signals too, but unfortunately System.Posix doesn't easily allow for that
10:17:44 <thebug> HE/stable is giving me a 404
10:17:49 <SyntaxLaptop> hi thebug
10:17:50 <bourbaki> shapr: a portier is that guy at the hotel entrance :)
10:17:54 <shapr> ohh!
10:17:56 <bourbaki> he greets everyone
10:18:04 <shapr> raboof: nah, it's pretty easy
10:18:06 <bourbaki> and the sidney thing was just a wordplay
10:18:12 <shapr> import Network
10:18:26 <shapr> you have recvFrom and sendTo for one way one-shot messages
10:18:29 <raboof> Could not find interface file for `Network' - i guess i'm missing some package :)
10:18:49 <shapr> and you have connectTo to get a r/w handle
10:18:59 <shapr> try adding -package network
10:19:02 <shapr> to your command line
10:19:10 <tuomov> what sucks is that the network stuff is separate from posix stuff
10:19:19 <thebug> SyntaxLaptop: did the repo get moved/disbanded/whatever and I missed the memo, or is something broken?
10:19:20 <raboof> 'ghc-5.02.2: unknown package name: network'
10:19:32 <tuomov> I'd rather have full posix support..
10:19:39 <shapr> thebug: it's become Haskell-Unsafe, and is now on alioth
10:19:45 <tuomov> and just as the posix syscalls work on the c-side
10:19:54 <shapr> raboof: I'd recommend you upgrade to GHC 6.2.1
10:19:59 <thebug> ah, I'll check that out then, thank you
10:20:04 <shapr> I haven't used 5.02 in sometime
10:20:05 <SyntaxLaptop> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
10:20:20 <SyntaxLaptop> thebug: sorry, I mentioned it a few times, but no real announcement has beenmade.  I should do that.
10:20:27 <tuomov> non-posix systems are a non-issue
10:20:28 <shapr> raboof: using win32? or a particular linux distro?
10:20:32 <thebug> no worries, I just missed the memo :)
10:20:38 <raboof> shapr: Debian
10:20:39 <raboof> stable
10:20:48 <shapr> er, hm
10:20:55 <shapr> do you have a ghc6 package?
10:20:57 <SyntaxLaptop> Igloo: around?
10:21:00 <shapr> I'm using unstable
10:21:17 <raboof> nope, only ghc5. 
10:21:25 <tuomov> wasn't a new stable supposed to be released 15.9? is that delayed?
10:21:28 <raboof> would it be worth recompiling form source?
10:21:36 <SyntaxLaptop> tuomov: Real Soon Now ;)
10:21:43 <tuomov> as usual
10:21:53 <thebug> better is WIR -- When It's Ready
10:22:19 <shapr> hm, well
10:22:27 <shapr> does H-U have ghc6 debs?
10:22:48 <shapr> or will that explode?
10:22:56 <SyntaxLaptop> hm. darn. I don't see ghc6-stable debs on H-U
10:23:04 <shapr> right, the dir is empty
10:23:30 <raboof> hmm
10:23:30 <raboof> 'Haskell Experimental Debian Archive (stable)'
10:23:34 <raboof> that looks useful :)
10:23:36 <shapr> raboof: well, debian/unstable has the best support for Haskell packages of any distro I know..
10:23:50 <raboof> hm, youknowwhat
10:23:51 <SyntaxLaptop> well, for a Very Short Time, you'll be able to get ghc6-stable debs from here: http://216.226.142.131/haskell-experimental/stable/
10:23:57 * raboof fires up his laptop running unstable :)
10:26:01 <raboof> SyntaxLaptop: it's unfortunate Clean's support for linux has mostly vanished i believe
10:26:18 <SyntaxLaptop> oh, that stinks.  It was on my short list
10:26:29 <shapr> what else is on your short list?
10:26:33 <shapr> epigram? Scala?
10:26:57 <SyntaxLaptop> Lua, a little more Python, maybe O'Caml, but I want to learn some more non-functional stuff
10:27:16 <tuomov> Lua's nice, for imperative scripting :)
10:27:17 <Maddas> heh
10:27:22 <shapr> if you use Ion, you'll end up using some Lua
10:27:26 <Maddas> SyntaxLaptop: That's a desire I rarely hear voiced :-)
10:27:36 <Maddas> shapr: What kind of stuff did you customize?
10:27:40 <Maddas> (Apart from bindings)
10:27:47 <tromp> my 2nd favorite lang is Ruby
10:27:51 <raboof> SyntaxLaptop: the clean 'core' works for linux i believe, but not the object i/o library
10:27:55 <shapr> my bindings are 100% non-standard
10:27:57 <SyntaxLaptop> Maddas: to learn non-functional stuff?  
10:28:00 <raboof> don't pin me down on this though :)
10:28:00 <tuomov> ruby doesn't have first-class functions :(
10:28:18 * SyntaxLaptop finally manages to boot linux on a lame-ass computer that wouldn't let me enter the bios setting or boot from CD
10:28:25 <tromp> ruby is about as functional as python
10:28:26 <shapr> I don't actually remember what else I changed.
10:28:35 <Maddas> SyntaxLaptop: Yes.
10:28:38 <shapr> how can you be functional with fof?
10:28:39 <tromp> which is not too much
10:28:41 <SyntaxLaptop> maybe I should learn one of those webby programming languages, but then I'd be afraid that someone might make me do web programming
10:28:59 <shapr> python has first-class functions
10:29:05 <tuomov> and so does Lua
10:29:18 <shapr> I sure do like Ruby's OO model, it's better andmore dynamic than Python's.
10:29:25 <shapr> I can't *stand* the explicit END stuff
10:29:41 <tuomov> in ruby you have special iterator constructs, but no first-class functions
10:29:50 <shapr> worse than brackets, I have to type three capital letters :-/
10:30:00 <shapr> at least I'm used to { } and ( )
10:30:05 <tromp> lower case works fine
10:30:08 <shapr> ah, ok
10:30:10 <tuomov> I actually prefer 'end' these days
10:30:16 <tromp> it grows on you
10:30:16 <SyntaxLaptop> so do you guys have any suggestions for cool languages to learn?
10:30:27 <shapr> SyntaxLaptop: epigram, Joy, scala
10:30:33 <Maddas> Do they have to be 'non-functional'?
10:30:38 <SyntaxLaptop> oh, I forgot to mention "nice"
10:30:44 <Maddas> :-)
10:30:47 <tuomov> brainfuck
10:30:56 <SyntaxLaptop> Maddas: no, they don't have to be
10:31:00 <shapr> Joy is somewhere between Forth and Haskell.
10:31:03 <tromp> binary lambda calculus
10:31:13 <shapr> there's nothing else like epigram.
10:31:23 <shapr> I'm slowly gaining interest in Scala is http://scala.epfl.ch/
10:31:31 <shapr> some people I very much respect have said good things about Scala.
10:31:39 <tromp> you can have programs like 010001101000010000010110000000000101101111000010110111110011111111011110000010011010
10:31:45 <shapr> tromp: whoa, cool
10:32:01 <shapr> raboof: got ghc6 installed?
10:32:04 <tromp> which, incidentally, is a program that duplicates every byte in the input
10:32:24 <shapr> let's see, the nearest binary lambda cal expert I know is ... tromp 
10:33:19 <shapr> hoi Jan_w 
10:33:27 <Jan_w> hi
10:33:37 <tromp> what other language has half-byte programs:-?
10:34:10 <raboof> hm, syntax changed between 5 and 6?
10:34:20 <shapr> tiny bit
10:34:23 <shapr> what are you having problems with?
10:34:50 <raboof> 3-line program paste:      module Main where
10:34:50 <raboof>      fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
10:34:50 <raboof>      main = print $ take 20 fibs
10:35:02 <Jan_w> shapr: goddag
10:35:14 <shapr> :-)
10:35:27 <Jan_w> or god afton actually
10:36:30 <shapr> raboof: looks like that should work to me
10:37:11 <raboof> deuh. the file extension was wrong ;)
10:38:47 <shapr> tromp: did I already ask you about concurrent stack-based programming?
10:39:02 <tromp> not that i remember
10:39:18 <shapr> I've been trying to find some research on parallel evaluation of stack-based languages
10:40:12 <tromp> stacks are like a serialized form of functional programs
10:40:26 <shapr> hm, interesting point
10:40:48 <shapr> hej an9n
10:40:49 <tromp> when i read that paper about minimal bases for concatenative combinators
10:40:55 <an9n> hej shapr
10:41:07 <shapr> how's code?
10:41:12 <tromp> i just got this impression that the stack was used to hold the top level applications
10:41:22 <an9n> shapr, how are you
10:41:31 <shapr> doing well, about as focussed as usual.
10:41:43 <shapr> tromp: well, everything happens 'right there' sort of
10:41:52 <an9n> shapr, ok. hacked any haskell lately?
10:41:53 <tromp> it seemed an inefficient simulation of the pure functional approach
10:42:04 <shapr> huh
10:42:14 <shapr> an9n: a bit
10:42:24 <an9n> shapr, OK. cool.
10:42:33 <shapr> an9n: you have some Haskell questions?
10:42:34 <tromp> darn' it just starts raining
10:42:52 <shapr> so maybe Joy could be more efficient if transformed into a pure FP program?
10:42:59 <tromp> and the grocery store closes at 8 :(
10:43:11 <shapr> time to put the faring on your bike
10:43:17 <an9n> yeah, actully I pondered something lately.
10:43:28 <tromp> yes, i think you cld translate each Joy primitive back to a functional combinator
10:44:23 <shapr> hm, interesting
10:44:30 <shapr> an9n: what did you ponder?
10:45:05 <an9n> shapr, in implementing something by dynamic programming, you usually memoize the results in your computations in an array or such. I wonder if haskell caches values well enough to make such structures redundant
10:45:49 <tromp> ok, going shopping. bye for now
10:46:15 <tuomov> scala looks rather nice for an oo language
10:46:29 <tuomov> (I'm not a big fan of oo)
10:46:47 <shapr> an9n: it can, with common subexpression elimination
10:46:53 <shapr> but in general, it doesn't
10:47:14 <an9n> shapr, ah, ok.
10:47:27 <shapr> specifically because there are calculations that are cheaper to recompute than to store
10:47:48 <shapr> I think there's a GHC flag that forces CSE
10:47:51 * shapr checks
10:49:06 <an9n> shapr, how do you tell a cheap computation ;)
10:49:50 <raboof> is 'ghc/misc/examples' somewhere in a debian package?
10:49:54 <shapr> probably with -ddump-cse
10:50:15 <shapr> an9n: in general, I write code, and then profile it when it feels slow.
10:50:26 <shapr> raboof: maybe in libsrc?
10:51:28 <an9n> shapr, yeah, but like, memoizing can bring your algorithm from O(2^n) to O(n) in some cases.
10:51:56 <shapr> hm, now I'm confused as to just how much CSE GHC does.
10:53:08 <shapr> there are some Haskell memoizing libs
10:53:17 <an9n> shapr, ah, cool.
10:54:32 <raboof> memoizing is neat. what would be even neater is persistent memoising imho
10:54:48 <raboof> i.e. not throwing away the 'cache' when the program terminates
10:54:55 <an9n> I'll have to check them out. 
10:55:03 <raboof> and re-use it next time you run the program
10:55:15 <shapr> sounds like TransMeta
10:55:23 <raboof> TransMeta?
10:55:45 <shapr> they make CPUs that pretend to be x96
10:55:47 <shapr> x86
10:56:12 <shapr> they have a software layer on top of a RISC chip that pretends
10:56:26 <shapr> among other things, it optimizes dynamically
10:56:34 <raboof> that's cool.
10:56:51 <tuomov> JIT compilers also optimise dynamically
10:56:58 <shapr> oh, it's VLIW rather than RISC
10:57:18 <shapr> they call their spiffy layer the "Code Morphing" software
10:57:36 <shapr> Self is still the king of JIT.
10:58:02 <bourbaki> jit?
10:58:07 <tuomov> just-in-time
10:58:09 <shapr> just in time compilation
10:58:16 <bbls> what about Java?
10:58:22 <bourbaki> and whats so cool about that?
10:58:50 <tuomov> you can make decisions such as which alternative of an if statement is unlikely and so on
10:59:07 <bbls> bourbaki code optimised at run-time, based on profiling data
10:59:11 <bourbaki> isnt that simple branch prediction?
10:59:26 <bourbaki> any modern cpu does that doent it?
10:59:27 <shapr> bourbaki: the Self VM did bytecode and JIT poly-inline caching
10:59:55 <bourbaki> i see i see :)
10:59:56 <shapr> for each combination of argument types you'd get a specialized compiled version of the method
11:00:03 <tuomov> CPU:s do that too, and so some of the optimisations a compiler does may be in vain
11:00:10 <tuomov> but I'm sure they do much more
11:00:14 <tuomov> I don't know exactly what
11:00:43 <bourbaki> id use reinforcement learning like stuff for that or that do they use?
11:00:47 <shapr> The Java HotSpot VM uses the ideas developed in the Self VM.
11:01:02 <tuomov> but even the linux kernel uses an 'unlikely' macro to instruct the compiler
11:01:17 <shapr> neat
11:01:38 <bourbaki> hehehe :) isnt that called exceptions ;)?
11:02:24 <tuomov> #define unlikely(x)       __builtin_expect(!!(x), 0)
11:09:15 <shapr> oh, looks like EuroPython 2005 dates have been given
11:10:36 <shapr> what about having EuroHaskell 2005 July 22-24?
11:11:28 <kristnjov> what goes on on those eurohaskell meets?
11:12:04 <shapr> coding, pizza, unicycling
11:12:24 <shapr> probably some sort of talks as well
11:12:38 <bourbaki> heh
11:12:56 <bourbaki> isnt it usual 
11:13:03 <bourbaki> to drink alot there as well?:)
11:13:04 <kristnjov> anyone going to dreamhack this year?
11:13:20 <shapr> hm, neat
11:13:35 <bourbaki> at least i think i kind of remember that of the convs where i have been
11:14:27 <shapr> there was some beer at the last EuroHaskell
11:14:53 <bourbaki> i remember my first conv :) they even had their own conv drink :)
11:15:31 <bourbaki> gforce juice
11:15:44 <kristnjov> conv? conversation?
11:15:57 <bourbaki> converence
11:16:07 <kristnjov> is it not conference?
11:16:10 <bourbaki> or do you write that with f ?:)
11:16:13 * raboof remembers the 'pan-galactic gargle-blaster' at HAL2001
11:16:15 <bourbaki> heh ok
11:16:18 <bourbaki> conf :)
11:16:22 <kristnjov> i wasn't being a smartass, i was just wondering :/
11:16:45 <bourbaki> np it was my bad typing
11:16:49 <kristnjov> :)
11:17:08 <bourbaki> maybe too much gforce juice back then ;)
11:18:55 <shapr> well, assuming that's acceptable, EuroHaskell 2005 will be June 22 - 24 in Gothenburg, Sweden
11:19:20 <shapr> raboof: http://www.hal2001.org/gfx/blikje.gif
11:19:55 <bourbaki> haha :)
11:20:08 <raboof> jep :)
11:20:15 <bourbaki> did anyone drink it?
11:20:27 * raboof did
11:20:34 <shapr> hm, isn't there a way to route an ssh connection through another box?
11:20:34 <raboof> not too special, some energy dring
11:20:39 <raboof> drink
11:20:58 <raboof> hum to bad they took the 'hal2001 is over!' picture away :)
11:20:58 <bourbaki> and did you feel like beeing hit by a gold brick wrapped in a slice of lemmon?
11:21:01 <thebug> ADD AN OLIVE
11:22:20 <raboof> actually i wonder whether there are plans for HEX2005 yet
11:24:15 <shapr> hm, isn't redhat 8.0 really old?
11:24:57 * an9n is away: Auto-away after 30 mins idle (gone at 4th Oct, 20:24:34)
11:27:10 <thebug> 4.2 is -old-, 8.0 is relatively old ;)
11:30:46 <shapr> I wonder if it's considered suicidal to install debian/unstable on a production webserver expected to get a larg number of hits.
11:33:14 * esap doesn't consider it suicidal. Though I've never done that, so I wouldn't know.
11:34:46 <mornfall> re
11:36:17 <thebug> unstable can work, you just need to be -very- careful updating it and keeping up with security issues
11:37:25 <shapr> ScannedInAvian has been debian/unstable for as long as it's been around, but it doesn't get a large number of hits.
11:39:18 <Jan_w> shapr: the links for Hate and Thank you are borken
11:39:25 <Jan_w> broken, that is :)
11:42:01 <shapr> shouldn't be any links to that at all
11:42:32 <shapr> where'd you find them?
11:57:24 <shapr> is there some way to turn RCS files ripped from a CVS repo into the actual files?
11:58:36 <shapr> @yow
11:58:36 <lambdabot> I want a VEGETARIAN BURRITO to go..  with EXTRA MSG!!
11:59:20 <thebug> huh?
11:59:41 <thebug> 'co' and 'ci' are the RCS checkin/checkout commands
11:59:41 <Jan_w> shapr: maybe put them in a cvs root and check them out? just guessing
12:00:19 <shapr> thebug: I can't create a lock in the /home/cvs  dir, but I can read the files
12:00:24 <shapr> so I grabbed the ones I wanted
12:00:31 <shapr> (darcs reflexes)
12:00:55 <shapr> still seems bizarre to me that I need write access to grab a copy of software in a repo
12:00:57 <thebug> shapr: should be able to retrieve revs from ,v files using co and ci
12:01:51 <shapr> ?
12:02:10 <shapr> rcs co Foo,v ?
12:02:19 <thebug> no 'rcs ...'
12:02:23 <thebug> just 'co Foo'
12:02:43 <shapr> oh neat
12:02:45 <shapr> thanks!
12:02:49 <thebug> :)
12:21:25 <Jan_w> shapr: hm i don't know, i read something about framing "hate" and "thank you" and maybe adding "reflection" later, but i can't find it anymore
12:21:54 <shapr> strange, I'll check it out.
12:27:20 <shapr> y0 stepcut, did you see House?
12:27:22 <stepcut> Anyone know of a library for associative lists in haskell? Data.List has lookup and elem, but I also want update and delete...
12:27:25 <stepcut> House ?
12:27:35 <stepcut> Full House ?
12:28:03 <shapr> http://www.cse.ogi.edu/~hallgren/House/
12:28:22 <stepcut> no, but I am looking now
12:28:44 <stepcut> looks neat, maybe I will play with it later today
12:28:57 <shapr> I sent an email that way, asking for sources.
12:29:01 <stepcut> I finally have grub on my machines...
12:29:04 <shapr> cool
12:30:32 <stepcut> I *could* use finate maps instead of assoc lists, but it might be nice to preserve order
12:30:48 <thebug> interesting ... it uses Gadgets ... I thought that was originally written for Oberon
12:31:05 <stepcut> actually, I bet kde does not preserve the order anyway, so...
12:31:49 * stepcut hacks is code to use FinateMaps istead of lists
12:32:21 <shapr> hoi Boegel
12:32:31 <Boegel> hello everyone
12:32:38 <Boegel> what's going on ? :)
12:33:01 <stepcut> (s/Finate/Finite/g)
12:34:03 <mattam> isn't an index :: Eq a => [a] -> a -> Num defined somewhere, and isn't there an Idx typeclass too ?
12:34:33 <Igloo> @type find
12:34:34 <lambdabot> bzzt
12:34:36 <stepcut> mattam, there is an index class Ix i believe
12:34:41 <Igloo> @type findElem
12:34:42 <lambdabot> bzzt
12:34:52 <shapr> @index find
12:34:52 <lambdabot> Data.List,List
12:34:53 <Igloo> Oh, something like that. Or maybe it's in the List module.
12:35:01 <shapr> @index findElem
12:35:01 <lambdabot> bzzt
12:35:13 <shapr> maybe the index should return type sigs?
12:35:18 <mattam> didn't see anything ending in -> Num in List
12:35:37 <Igloo> It would be -> Int (or there might only be Maybe Int)
12:35:42 <Igloo> @type List.find
12:35:43 <lambdabot> List.find :: forall a. (a -> Bool) -> [a] -> Maybe a
12:35:45 <shapr> trying to build greencard 3.01, "ghc-6.2.1: unrecognised flags: -fno-prune-tydecls"
12:35:57 <shapr> should I just kill that flag in the build file?
12:35:57 <mattam> oh the maybe...
12:36:06 <shapr> is there a greencard that is happy with 6.2.1?
12:36:27 <Igloo> elemIndex/elemIndices is what you want, anyway
12:36:28 <mattam> no, it isn't there
12:37:24 <mattam> @index elemIndex
12:37:24 <lambdabot> Data.List,List
12:38:35 * mattam slaps itself for looking in GHC.List only
12:38:53 <Igloo> As a general rule you should never look at GHC.*
12:39:40 <mattam> ok
12:39:49 <shapr> it is *so* time to create debs for greencard, HSX11, and HGL
12:39:56 <shapr> or maybe Cabal packages.
12:40:02 <mattam> HSX11 ?
12:40:25 <shapr> the X11 bindings for GHC
12:40:49 <shapr> http://www.reid-consulting-uk.ltd.uk/projects/HSX11.html
12:40:59 <mattam> raw bindings ? wow
12:41:42 <Igloo> shapr: Maybe finish c2hs first?  :-)
12:41:56 <mattam> i suppose greencard is now stable :)
12:42:05 <Igloo> HSX11 is in ghc-cvs. Possibly ghc6 too, I can't remember.
12:42:08 <shapr> Igloo: oh good point
12:42:53 <shapr> only in ghc-cvs
12:43:01 <shapr> but that's a good reason to stick with 6.3
12:44:28 <Boegel> I still need to finish my ray tracing algorithm :s
12:44:35 <Boegel> it's going quite slowly...
12:44:45 * Boegel hates himself for not moving on with that
13:33:25 * shapr hOps
13:36:28 <mattam> how do you convert an Int to an Integer ? :(
13:36:54 <tromp> fromInteger n :: Integer ?
13:36:58 <kristnjov> heh
13:37:45 <mattam> bah, that's misnamed
13:37:51 <shapr> fromIntegral ?
13:38:17 <tromp> @type fromInteger
13:38:18 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
13:38:44 <tromp> so that won't work for Ints
13:38:47 <mattam> see, it's goodly named
13:38:58 <shapr> @type fromIntegral
13:38:59 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
13:39:14 <mattam> ha
13:39:16 <tromp> better:)
13:39:31 <crackhead> where can I find information on Prelude functions....specifically 'foldr'
13:39:32 <crackhead> ?
13:39:58 <shapr> 'tour of the prelude'
13:40:07 <mattam> http://haskell.org/onlinereport/standard-prelude.html
13:40:08 <shapr> or you can look at the source
13:40:10 <tromp> the reference manual has annotated Prelude
13:40:14 <mattam> alternatively
13:40:43 <tromp> i just do vi /usr/share/hugs/lib/Prelude.hs
13:41:42 <crackhead> whoa....I think that's a little too deep
13:41:44 <kristnjov> vi is for the ones who consider themselves too elite for emacs :)
13:41:56 <shapr> really?
13:41:57 <crackhead> I just want to know what 'foldr' does
13:42:05 <tromp> nah, i'm too simpleminded for emacs:(
13:42:12 <shapr> crackhead: it rolls up your list like a rolled up mattress
13:42:22 <kristnjov> i'd use vi/vim/gvim if only i had the strength to learn it
13:42:28 <shapr> and while it's doing that, it repeatedly combines the first two items according to an operator
13:42:44 <shapr> crackhead: so, let's say "foldr1 (+) [1,1,1]"
13:42:54 <shapr> @eval foldr1 (+) [1,1,1]
13:42:54 <lambdabot> (line 1, column 9):
13:42:54 <lambdabot> unexpected "+"
13:42:54 <lambdabot> expecting simple term
13:43:01 <kristnjov> i guess you need a basecase, don't know about foldr1 though
13:43:08 <shapr> @eval foldr1 (\x y -> x + y) [1,1,1]
13:43:08 <lambdabot> 3
13:43:24 <kristnjov> foldr (+) 0 [1,1,2] = 1+1+2+0 = 4
13:43:28 <shapr> foldr1 says "start with the first two items"
13:43:36 <shapr> @eval foldr (\x y -> x + y) 0 [1,1,1]
13:43:37 <lambdabot> 3
13:43:46 <shapr> foldr takes an initial argument
13:44:37 <tromp> why didn't foldr1 (+) work?
13:44:46 <shapr> becuase @eval isn't real haskell
13:44:52 <shapr> it's just a simple lambda calculus interpreter
13:45:20 <shapr> that's why stuff like @eval (\x -> (x x)) (\x -> (x x)) doesn't explode
13:45:31 <tromp> 'i know much simpler ones:)
13:45:49 <shapr> @get-definition foldr
13:45:49 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
13:46:04 <crackhead> shapr: how does foldr (\x y -> x + y) 0 [1,1,1] work?
13:46:25 <crackhead> whoa...that was cool
13:46:34 <shapr> crackhead: it's like a rolled up pancake or something
13:46:38 <shapr> oh I have a good example
13:46:42 <shapr> there's a function max
13:46:51 <shapr> and max returns the largest of two arguments
13:46:54 <shapr> @eval max 1 2
13:46:54 <lambdabot> unbound variable: max
13:47:03 <shapr> anyway...
13:47:18 <shapr> if you want the largest item in an entire list
13:47:24 <shapr> you can fold max over the list
13:47:28 <crackhead> yea...actually I need to write a function maxList that uses foldr
13:47:37 <shapr> oh
13:47:48 <shapr> I'm not supposed to give out homework answers...
13:47:57 <shapr> so I'll go with something different, sum of a list of numbers
13:48:08 <shapr> maxList is simpler than sum of a list though :-)
13:48:27 <shapr> you have a function that takes in two args, and leaves out one result
13:48:30 <crackhead> hehe
13:48:34 <tromp> maxList is less clear on [] though:(
13:49:00 <crackhead> yea...I was thinking I would just return []
13:49:25 <sorje> Nothing on []? ;-)
13:49:40 <crackhead> huh?
13:49:54 <sorje> That's what Maybe is for, isn't it?
13:50:06 <crackhead> Maybe?
13:50:10 <crackhead> what's that?
13:50:19 <sorje> A datatype
13:50:26 <crackhead> hmmmmmmm
13:50:29 <shapr> Maybe is probably a bit too advanced for people learning about fold
13:50:30 <tromp> or you define it on Bounded types, then maxList [] = minbound
13:50:35 * crackhead brb
13:53:54 <shapr> foldr f z []      = z
13:53:57 <shapr> foldr f z (x:xs)  = f x (foldr f z xs)
13:54:05 <shapr> that's hugs' definition of foldr
13:54:22 <shapr> start with "foldr (+) 1 [1,1,1]"
13:55:18 <shapr> (+) 1 (foldr (+) 1 [1,1])
13:55:24 <sorje> Yes, possible. It's just that I've only just started too and expect everybody to know more than me. ;-)
13:55:54 <shapr> (+) 1 ((+) 1 (foldr (+) 1 [1])
13:56:21 <shapr> crackhead: can you guess the rest?
13:56:47 <kristnjov> demonstrating recursive stuff on irc is weird sometimes
13:56:50 <kristnjov> lots of parenthesis
13:57:19 <shapr> yup
13:57:59 <shapr> greetz wagle 
13:58:49 <wagle> client crashed with segmentation fault.  is there an irc client written in a type safe language?  8)
13:59:24 <sorje> there's sirc, I think it's written in perl
13:59:34 <Cale> kristnjov: still alive, I see -- did you see a doctor about that pain?
13:59:50 <kristnjov> Cale, what pain, i can't remember?
13:59:53 <kristnjov> oh yes
13:59:57 <kristnjov> no, i'm alright now
14:00:06 <kristnjov> although my back started hurting as hell this morning when i stepped into the car
14:00:14 <kristnjov> i'm hoping it's nothing serious
14:01:09 <crackhead> shapr: I'm back
14:03:04 <crackhead> shapr : I don't understand what you're trying to exemplify?
14:18:39 <crackhead> where do I find the prelude definitions?
14:19:13 <kristnjov> 6006|_3
14:19:30 <crackhead> err....I just read above
14:35:35 <crackhead> hmmm....so is foldr suppose to take a function as the first argument?
14:36:47 <shapr> crackhead: yes
14:36:49 <shapr> @type foldr
14:36:50 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
14:37:05 <shapr> foldr takes a function, an initial arg, and a list
14:37:34 <crackhead> hmmmm....how did you get all that info?
14:37:39 <shapr> what info?
14:38:19 <crackhead> that it  takes a function, an initial arg, and a list? I understand the list...but the other two are kinda hazy
14:38:38 <shapr> I learned it the same way you're learning it.
14:38:43 <crackhead> hehe
14:38:45 <crackhead> nice
14:38:48 <shapr> I got started with Python
14:38:56 <shapr> where map, reduce, and lambda is about all you get.
14:39:02 <shapr> I loved map
14:39:14 <shapr> map uses one function like a hammer on each item in the list
14:39:17 <crackhead> is that in haskell?
14:39:22 <shapr> yup
14:39:32 <shapr> @eval map (\x -> x + 1) [1,2,3,97]
14:39:33 <lambdabot> [2, 3, 4, 98]
14:39:45 <shapr> so, it's like using a hammer on a row of nails or something
14:39:51 <shapr> bam, bam, bam
14:39:52 <xerox> goodnight
14:40:00 <shapr> the function gets called on each thing in the list
14:40:02 <shapr> g'night xerox 
14:40:29 <shapr> and the resulting list is all the resulting items.
14:40:35 <crackhead> bam, bam, BAM, yea, yea, YEA.....ehhehahahhahehahha
14:40:54 <shapr> Python also has 'reduce'
14:40:56 <crackhead> nice....I think I'm beginning to like this
14:41:05 <shapr> if you have a function that takes two args, and return one arg
14:41:29 <shapr> you can successively apply that to 'the next two items' in a list
14:41:33 <shapr> until you only have one item left
14:41:47 <crackhead> huh?
14:42:06 <shapr> if you add two numbers, how many do you get back?
14:42:11 <crackhead> so then the answer to the first pair is used for the next pair?
14:42:16 <shapr> right
14:42:16 <crackhead> 1
14:42:20 <shapr> it's half of the next pair
14:42:37 <crackhead> hmmm
14:42:49 <shapr> you see why it's called a fold?
14:43:05 <crackhead> aaaaa
14:43:08 <shapr> you fold the list up over itself
14:43:20 <crackhead> what is the map called?
14:43:22 <shapr> map
14:43:24 <shapr> shockingly
14:43:42 <shapr> map does a lot more cool stuff in Haskell than it ever did in Python
14:43:54 <shapr> but that's besides the point
14:43:56 <crackhead> oh wait...is reduce a fold too
14:44:01 <shapr> you got it!
14:44:15 <crackhead> niiiiiiice
14:44:19 <shapr> reduce in Python is fold in Haskell
14:44:36 <crackhead> aaah.....ok
14:44:45 <shapr> the idea is to distil basic traversal patterns out into their own bits of code
14:44:46 <crackhead> man....lights are going off
14:45:19 <shapr> if you can do something to one item, then you have another bit of code that does that to every item in a list
14:45:34 <shapr> if you can combine two items, then you have another bit of code that combines all the items in a list
14:46:02 <shapr> similarly, if you have two lists, you have this bit of code called 'zip'
14:46:23 <shapr> and it takes two lists and ends up with one list
14:47:04 <crackhead> hmmmm
14:47:12 <shapr> so, you've foldr and foldl
14:47:17 <shapr> can you guess what the difference is?
14:47:25 <psi> what cool stuff can map do in haskell, that it can't do in python?
14:47:32 <crackhead> fold left or right?
14:47:37 <shapr> crackhead: correct!
14:47:58 <shapr> ok, here's another basic pattern: filter (x > 5) [1..9]
14:48:01 <shapr> what do you think it does?
14:48:26 <crackhead> returns a list with elements >5
14:48:30 <shapr> psi: ($) and partial application are missing from Python
14:48:34 <mattam> x is free in your code ...
14:48:40 <shapr> mattam: good point
14:48:49 <shapr> should have been (\x -> x > 5)
14:48:56 <shapr> crackhead: you got, it filters the list
14:48:56 <tromp> aka (>5)
14:49:36 <shapr> crackhead: other useful functions are head, which gives you the first element of a list, tail gives you the list without the first element
14:49:44 <psi> shapr: hm, i've never seen $ before
14:49:50 <shapr> take gives you the number of items you ask for
14:49:59 <shapr> drop drops the number of items you ask to drp
14:50:02 <psi> @type ($)
14:50:03 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
14:50:16 <shapr> @eval drop 5 [1,2,3,4,5,6,7]
14:50:16 <lambdabot> [6, 7]
14:50:22 <crackhead> so then for maxList...would I use a lambda expression for the function to foldr?
14:50:35 <shapr> crackhead: probably so
14:50:55 <shapr> crackhead: try it
14:51:23 <crackhead> @eval drop 5 [5,2,1,4,6,7]
14:51:27 <lambdabot> [7]
14:51:54 <crackhead> that wasn't what I expected
14:52:11 <shapr> the number is how many items to pull off the front of the list
14:52:24 <shapr> if you want to cut a list at a certain place, there's span and break
14:52:25 <crackhead> aaaah
14:53:07 <shapr> @eval zip [1,2,3] [5,6,7]
14:53:07 <lambdabot> [<<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>, <<EM Dynamic
14:53:07 <lambdabot> -> EM Dynamic>>]
14:53:12 <shapr> whoops
14:53:19 <crackhead> shapr: have you messed around with haskell and opengl?
14:53:28 <shapr> just a bit
14:53:40 <crackhead> what is that like?
14:54:08 <crackhead> ....or rather is the opengl functional?
14:54:14 <shapr> sort of
14:54:29 <crackhead> hmmmm....I might have to play with that later
14:54:43 <crackhead> ok....back to maxList. brb
14:55:12 <shapr> when you're wrapping something that's not very functional like OpenGL, you usually make a nearly exact mapping into Haskell that's obviously procedural, and then wrap it into a nice pretty package for users.
14:58:14 <crackhead> hmmm....so what does foldr1 do?
14:58:29 <shapr> it doesn't require the initial argument, it takes the first two items from the list.
14:59:06 <shapr> sometimes foldr1 is easier, and sometimes foldr is necessary.
14:59:23 <bourbaki> nightp
14:59:25 <bourbaki> nighto
14:59:29 <shapr> g'night bourbaki 
15:01:07 <psi> what's the use of $?
15:01:16 <shapr> psi: it's first class function application
15:01:51 <psi> hm
15:01:54 <psi> which means what?
15:02:06 <Oejet__> psi: f $ map g xs = f(map g xs)
15:02:09 <shapr> can you think of cases where you might "foldr1 (.)" over a list?
15:02:22 <Oejet__> psi, it saves parentesis.
15:02:46 <psi> Oejet__: ah!
15:02:46 <tuomov> shapr: unfortunately a lot of stuff doesn't seem to be done that way
15:02:55 <tuomov> e.g System.Posix is nowhere hear posix
15:03:13 <tuomov> Concurrent.crap is favoured over Posix select/poll almost everywhere
15:03:22 <Oejet__> psi: f $ g $ h $ i $ j x =f(g(h(i(j(x)))))
15:03:28 <shapr> I like Concurrent myself.
15:03:33 <tuomov> (that's the part of haskell I don't like)
15:03:40 <shapr> tuomov: you may like Yampa
15:03:51 <shapr> http://www.haskell.org/yampa/
15:03:58 <shapr> Yampa is heavy duty niftyness.
15:04:06 <psi> Oejet__: yep, thanks. i can see the usefulness :)
15:04:26 <shapr> Yampa uses arrows to get something a lot like select
15:05:01 <shapr> I'm still not sure if the arrow stuff is more efficient than select or not.
15:05:44 <tuomov> I just want a select()-based state machine around which the rest of the program is structured
15:05:48 <tuomov> and not complex concurrency shit
15:06:17 <shapr> Have you used arrows?
15:06:22 <tuomov> no, I'm a n00b
15:06:38 <shapr> lots of experienced people who don't use arrows :-)
15:06:56 <shapr> arrows are a lot like monads, but they do a lot more
15:07:06 <tuomov> yes, I've read a paper about arrows
15:07:14 <shapr> if you've played with a monadic parser, you may have noticed ..
15:07:26 <shapr> in that case..
15:07:36 <shapr> you don't need the arrows part 1 talk
15:07:37 <shapr> :-)
15:07:58 <shapr> did you see the resemblance between arrows and select?
15:08:33 <tuomov> no, I haven't thought about them that way
15:08:37 <shapr> as demonstrated in the parsing arrows via the exported list of "what I can parse"?
15:08:46 <tuomov> but indeed, arrows could be used to combine handlers for select output quite nicely..
15:09:49 <tuomov> but to do anything of the kind, you'd need decent System.Posix that worked just like the C-side functions (except for exceptions)
15:09:52 <shapr> Static property export as in the monadic parser means you don't call things that won't succeed.
15:10:03 <shapr> er "arrowdic" ?
15:10:55 <tuomov> now, select isn't even in System.Posix but in some extra chunk of code
15:10:58 <shapr> I don't know the difference between System.Posix and 'real' posix, but I'd like to hear specifics of what's missing, maybe I can fix some stuff.
15:11:07 <tuomov> and a lot of the calls retry over signals
15:11:22 <tuomov> so far, select and truncate at least
15:11:39 <tuomov> and most if not all calls I've looked at retry upon signal receipt
15:12:17 <tuomov> so it's not posix
15:12:46 <tuomov> but the signal part is difficult, and IMHO signals should be replaced with an event queue in most cases (all non-fatal signals)
15:13:49 <shapr> can you point me to a specific call?
15:14:20 <shapr> you mean System.Posix.Signals.installHandler ?
15:14:56 <tuomov> well e.g. Select.hSelect (though it's not in Posix.) itself retries
15:15:52 <tuomov> and there was other I looked at, but I don't remember which it was
15:16:10 <tuomov> but I think all of them retry, because signals are handled in different threads by System.Posix
15:16:26 <tuomov> and only once one has returned from a foreign call
15:17:40 <tuomov> stuff is wrapped inside throwErrnoIfMinus1Retry
15:17:46 <shapr> where is Select.hSelect ?
15:18:14 <tuomov> posix select, but for Handle:s and not Fd:s, as it should be...
15:18:43 <tuomov> it's in -package util iirc
15:18:56 <shapr> ah
15:20:29 <tuomov> in any case, it is very difficult to write posix programs with the current System.Posix
15:20:38 <shapr> how can it be improved?
15:20:50 <shapr> hiya jao
15:20:56 <jao> hey shapr 
15:20:58 <tuomov> add all that is missing
15:21:12 <tuomov> (and give everything their original names, please)
15:21:23 <tuomov> add decent select
15:21:37 <tuomov> signal part is a bit difficult
15:22:26 <tuomov> for my purposes, it would be enough to add a new default handler that works with an extended version of select that returns signals as well
15:22:41 <tuomov> as that's where I want to handle the signals
15:23:30 <tuomov> and then there are places that block for io, those should be removed or given the option to fail
15:24:39 <tuomov> there probably is such a select loop in the ghc libraries already, but there's no simple way to create such a low-level loop yourself; you're forced to use the Concurrent.stuff around it
15:24:58 <tuomov> create an extra layer of channels and so on
15:25:26 <tuomov> start a new reader thread for every Fd that then returns stuff through a channel
15:25:35 <shapr> the hSelect docs say that Concurrent lets you do I/O on multiple file handles concurrently by forking threads
15:25:43 <tuomov> yes, ugly
15:25:49 <tuomov> select is much prettier
15:25:53 <tuomov> I don't like threads
15:26:11 <shapr> http://www.haskell.org/ghc/docs/6.2.1/html/hslibs/select.html
15:26:22 <tuomov> in referentially non-transparent languages they're plain evil
15:26:26 <shapr> GHC threads are actually coroutines rather than full threads
15:26:36 <tuomov> but even in referentially transparent language I don't like it
15:27:39 <shapr> arrows look more sane than threads to me.
15:27:49 <shapr> but I'm not sure Yampa does all the same stuff that threads do.
15:29:08 <shapr> anyway, I think the Posix module is something I can improve, after some background reading.
15:29:33 <shapr> I don't know about the rest.
15:31:01 <tuomov> the Concurrent.stuff might be more ok if there was some Concurrent.mainloop that you should enter to use the stuff
15:31:07 <tuomov> and everything wouldn't so much depend on it
15:31:18 <tuomov> but it seems rather heavily integrated into all the libraries
15:32:58 <shapr> it is the standard way to do threads.
15:33:16 <tuomov> and I don't like it :(
15:33:28 <tuomov> too much policy
15:33:42 <tuomov> in core libraries
15:34:08 <shapr> if you come up with something better, I think it's likely the Simons would integrate it.
15:34:27 <shapr> they may not code up a better idea, but they seem very happy to accept patches.
15:45:01 <shapr> greetings godzilla
15:45:07 <shapr> welcome to our idyllic coastal town.
15:50:03 <crackhead> @type foldr1
15:50:04 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
15:50:27 <crackhead> is here any way to do that from inside hugs?
15:51:03 <shapr> yup
15:51:05 <shapr> :t foldr1
15:52:00 <crackhead> I'm confused about something
15:52:35 <shapr> ok, what?
15:52:56 <crackhead> a -> a -> a means that the function takes two args and returns one and all the args are of the same type...right?
15:53:25 <shapr> hiya thelsdj 
15:53:31 <shapr> crackhead: that's correct.
15:53:46 <shapr> though you don't really 'return' in a pure language
15:53:53 <shapr> you just evaluate
15:54:37 <crackhead> so then ...(a -> a -> a) -> [a] -> a.....means that it takes a function that takes two args as the first arg and a list as the second arg?
15:54:44 <crackhead> hmmmm...ok
15:55:00 <shapr> that's right.
15:55:19 <crackhead> so then would it be correct to say it evaluates to a single arg of the same type?
15:55:25 <crackhead> cool...thanks
15:56:31 <shapr> gutentag Joachim 
15:56:35 <crackhead> so what would you say instead of retrun?
15:56:40 <shapr> evaluate
15:56:45 <crackhead> hmmmmm
15:56:47 <shapr> it's like 1 + 1 doesn't return 2
15:56:50 <shapr> it evaluates to 2
15:57:00 <shapr> procedural programming really does return stuff
15:57:06 <shapr> but functional programming is like an equation
15:57:24 * crackhead 's light bulb gets a little brighter
16:04:53 <crackhead> @info max
16:04:55 <lambdabot> -- max is a method in class Ord
16:04:55 <lambdabot> max :: forall a. (Ord a) => a -> a -> a
16:05:06 <shapr> greetings boris
16:05:35 <crackhead> what is (Ord a) mean?
16:05:55 <tuomov> a is an orderable type
16:06:16 <shapr> it means that you can't get the max of two values unless there is some to order those two values
16:06:31 * shapr just found an emacs easter egg
16:06:33 <crackhead> hmmm...I guess I need to know what the => does
16:06:47 <crackhead> aaaah
16:06:53 <crackhead> VIM!!!!
16:06:57 <tuomov> it states a precondition
16:07:09 <crackhead> hmmm....nice
16:07:16 <tuomov> JED! JOE!
16:07:44 <shapr> LispM!
16:08:29 <crackhead> SED! AWK!
16:09:02 <shapr> actually, you can implement term rewriting systems with sed
16:13:57 <crackhead> dude!
16:14:07 <crackhead> I think I have maxList working
16:14:12 <shapr> yay!
16:14:16 <shapr> how did you write it?
16:14:24 <crackhead> can I paste here? it's only 3 lines
16:14:31 <shapr> sure, 3 lines is okay
16:14:43 <crackhead> maxList :: [Integer] -> Integer
16:14:43 <crackhead> maxList [a] = a
16:14:43 <crackhead> maxList (a:as) = foldr1 max as
16:15:07 <shapr> Personally, I think that's a good definition.
16:15:28 <tuomov> but it's broken
16:15:40 <phubuh> what about maxlist [1000, 1]?
16:15:53 <shapr> oh whoops
16:15:55 <tuomov> what happens to a of (a:as)
16:16:10 * shapr is getting sleepy
16:16:15 <crackhead> hmmmm
16:16:18 <crackhead> let me try
16:16:23 <tuomov> I just woke up it 21 :)
16:16:34 <shapr> I got up at 7:30
16:16:40 <shapr> I'm starting to fuzz out.
16:16:41 <crackhead> cap!
16:16:41 <tuomov> you can do it in two lines
16:16:47 <crackhead> doh...crap!
16:17:08 <crackhead> I haven't slept yet :)
16:17:25 <crackhead> been up for over 24 hrs
16:18:50 <crackhead> hmmmm....so how do I fix that?
16:20:10 <TheHunter> maxList as = foldr1 max as
16:20:59 <crackhead> hmmmmm
16:21:03 <crackhead> I see
16:21:25 <tuomov> you have just
16:21:34 <tuomov> maxList aas@(a:as) = foldr1 max (a:aas)
16:21:43 <tuomov> and thus not need the first rule
16:21:49 <tuomov> +could
16:22:08 <crackhead> whoa dude!
16:22:13 <crackhead> what the heck is  that?
16:22:19 <crackhead> aas@(a:as)
16:22:30 <tuomov> no what was that officially called..
16:22:32 <crackhead> ?
16:22:39 <shapr> named pattern?
16:22:42 <tuomov> but it means that aas is the name for what follows after it
16:22:43 <TheHunter> tuomov: why do you need the first rule at all?
16:23:03 <tuomov> TheHunter: for lists with just one entry
16:23:22 <tuomov> but in my alternative we just construct a new list that is ensured to have at least two entries
16:24:03 <TheHunter> foldr1 max [3] --> 3
16:24:09 <tuomov> ah
16:26:38 <crackhead> hmmmm....why would I ever really what to use the @ like that
16:26:48 <shapr> lots of reasons
16:27:07 <shapr> soon you'll get to algebraic types, which are a little bit like objects
16:27:07 <tuomov> compiler probably create a new object if you say (a:as) in the body
16:27:27 <tuomov> although I don't know; maybe they could optimise it away
16:27:40 <shapr> and you can match on the constructor, but still want the whole value
16:28:02 <tuomov> well, : is essentially a constructor
16:28:04 <shapr> data Primate = Person Name | Ape Name
16:28:16 <shapr> good point
16:29:20 <crackhead> hmmmm....is date like a type?
16:29:34 <shapr> er, you mean 'data' ?
16:29:51 <tuomov> data defines an algebraic data type
16:29:54 <shapr> data is the keyword for building a type
16:30:04 * shapr is slower than tuomov...
16:30:48 <tuomov> and that's actually the only way to define data types in haskell
16:30:55 <tuomov> classes are not classes as in C++ and so on
16:31:15 <tuomov> well s/define/define new/
16:31:26 <tuomov> there's newtype and type, but those are essentially just aliases
16:31:52 <tuomov> both of a different kind
16:33:34 <crackhead> hmmmm
16:48:15 <SyntaxLaptop> my blog is back in action: http://blog.syntaxpolice.org/isaac
17:00:41 <crackhead> @info elem
17:00:42 <lambdabot> -- elem is a variable
17:00:42 <lambdabot> infix 4 `elem`
17:00:42 <lambdabot> elem :: forall a. (Eq a) => a -> [a] -> Bool
17:01:17 <crackhead> @type elem
17:01:18 <lambdabot> elem :: forall a. (Eq a) => a -> [a] -> Bool
17:01:37 <crackhead> what does the (Eq a) mean?
17:02:05 <tuomov> that equality is defined for the type a
17:03:16 <crackhead> hmmm...why is that different than Ord?
17:03:32 <tuomov> You only have == defined
17:03:39 <tuomov> Ord implies Eq, though
17:03:53 <crackhead> you only have == defined for what?
17:04:00 <tuomov> a
17:04:23 <crackhead> Eq a?
17:04:27 <crackhead> or Ord a?
17:05:08 <tuomov> 'Eq a' or 'Ord a' simply means that the _type_ a is a member of the _type class_ Ord or Eq
17:05:25 <tuomov> i.e. it has defined for it the functions required on the definition of the type class
17:05:37 <tuomov> So if we have 
17:05:43 <tuomov> foo :: Eq a => ...
17:05:49 <tuomov> we require that == is defined for a
17:05:52 <tuomov> and if we have
17:05:57 <tuomov> foo :: Ord a => ...
17:06:20 <tuomov> we require that we can do all sorts of ordering comparisons (<, <=, >=, >, ==) between elements of a
17:06:44 <crackhead> aaaaahhh
17:06:52 <crackhead> sweeeet
17:08:04 <tuomov> e.g.
17:08:20 <tuomov> data Fruit = Banana | Orange 
17:08:20 <tuomov> instance Eq Fruit where
17:08:20 <tuomov>     Banana == Banana = True
17:08:20 <tuomov>     Orange == Orange = True
17:08:20 <tuomov>     _ == _ = False
17:08:50 <tuomov> now Fruit is a member of Eq, but not of Ord
17:09:26 <tuomov> (of course, I could just add 'deriving Eq' at the end of the data definition)
17:11:12 <crackhead> hmmmmm....that's cool
17:11:51 <crackhead> I haven't worked with the instance keyword yet
17:18:55 <stepcut> is there a version of !! that does throw an exception for out of bounds (returns Maybe a, or something)
17:21:24 <crackhead> what is !! anyway?
17:21:35 <Cale> !! is the list index operator
17:21:40 <tuomov> I don't think so, but I just used lookup & zip
17:21:53 <Cale> there isn't such a function in the prelude, but you can easily write one
17:22:03 <Igloo> !! will throw an exception, but you'll need to be in the IO monad to catch it I think
17:22:04 <tuomov> lnth n l = lookup n $ zip [0..] l
17:22:10 <stepcut> Cale: right, but if one *is* in the prelude, might as well use it
17:22:35 <stepcut> tuomov: thanks
17:22:38 <dons> don't have one, but you could catchJust it
17:23:36 <roconnor> @type (!!)
17:23:37 <lambdabot> (!!) :: forall a. [a] -> Int -> a
17:24:58 <stepcut> @type catchJust
17:24:59 <lambdabot> bzzt
17:25:10 <stepcut> @type Control.Exception.catchJust
17:25:11 <lambdabot> Control.Exception.catchJust :: forall a b.
17:25:11 <lambdabot> 			       (GHC.IOBase.Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO
17:25:11 <lambdabot> a
17:25:49 <stepcut> interesting
17:27:57 <dons> !! throws an error "Prelude.(!!) : a" for negative index and index too large
17:48:29 <crackhead> @info takeWhile
17:48:31 <lambdabot> -- takeWhile is a variable
17:48:31 <lambdabot> takeWhile :: forall a. (a -> Bool) -> [a] -> [a]
17:48:42 <crackhead> @info elem
17:48:43 <lambdabot> -- elem is a variable
17:48:43 <lambdabot> infix 4 `elem`
17:48:43 <lambdabot> elem :: forall a. (Eq a) => a -> [a] -> Bool
17:49:32 <crackhead> if takeWhile takes (a -> Bool) as the first argument...then I can't use elem as the first arg...can I?
17:50:23 <crackhead> since it's signature is a -> [a] -> Bool
17:50:37 <dons> flip elem applied. but depends on what you are trying to do
17:50:52 <crackhead> huh?
17:51:20 <crackhead> what do you mean by "flip elem applied"
17:51:30 <dons> @type flip elem []
17:51:31 <lambdabot> flip elem [] :: forall a. (Eq a) => a -> Bool
17:52:31 <dons> partially apply elem to the list you're interested in, and use flip to arrange the argument order
17:52:48 <crackhead> hmmm
17:53:09 <dons> haskell programming is just puzzle solving :)
17:53:18 <dons> you just have to match the types up, and you're done!
17:53:42 * crackhead confused on how I do that
17:54:20 <dons> I'm not sure why you are mixing elem and takeWhile
17:54:25 <crackhead> I'm suppose to use takeWhile/dropwhile and elem/notElem to implement words
17:54:30 <crackhead> @info words
17:54:31 <lambdabot> -- words is a variable
17:54:31 <lambdabot> words :: String -> [String]
17:54:36 <dons> you'd normally use something like (/= ' ')
17:55:55 <crackhead> yea.....it's for a class
18:10:42 <crackhead> words s
18:10:43 <crackhead>   | findSpace == [] = []
18:10:43 <crackhead>   | otherwise = w : words s''
18:10:43 <crackhead>   where
18:10:43 <crackhead>   (w, s'') = break isSpace findSpace
18:10:43 <crackhead>   findSpace = dropWhile isSpace s
18:11:05 <crackhead> could someonoe explain how the dropWhile works in that?
18:12:00 <crackhead> ...hmmmmm...I think  I might be confused by the (w, s'') also
18:12:31 <crackhead> @eval dropWhile isSpace "a b c d e"
18:12:31 <lambdabot> a b c d e
18:12:32 <wagle> there is another function named "break" that is associated
18:12:55 <crackhead> hmmmm
18:13:01 <wagle>  dropWhile isSpace "a b c d e" evals to "abcde"
18:13:20 <wagle> i think..  
18:13:45 <crackhead> @eval dropWhile isSpace "a b c d e" 
18:13:46 <lambdabot> a b c d e
18:14:10 <wagle>  dropWhile isSpace "    a b c d e" evals to "a b c d e"
18:14:12 <crackhead> hmmm....I wouldn't have expected that
18:14:34 <crackhead> @eval dropwhile isSpace "      a b c d e"
18:14:35 <lambdabot> unbound variable: dropwhile
18:14:47 <crackhead> @eval dropWhile isSpace "      a b c d e"
18:14:47 <lambdabot> a b c d e
18:14:50 <wagle> drop element of list while the condition is met.  then stop
18:15:08 <crackhead> aaaaaaah
18:20:39 <wagle> takeWhile p s ++ dropWhile p s == s
18:41:19 <crackhead> is there an equivalent to ! in haskell. something like !isSpace...where ! is like c/c++ not?
18:43:39 <dons> not
18:43:46 <dons> @type not
18:43:47 <lambdabot> not :: Bool -> Bool
18:43:53 <crackhead> hmmmm
18:45:28 <crackhead> takeWhile not isSpace "aaaa  aa a a a"
18:45:57 <crackhead> that doesn't seem to do what I want. Could you tell me what I'm doing wrong?
18:46:13 <dons> takeWhile (not isSpace) ...
18:46:15 <Pseudonym> What you've given takeWhile is three arguments.,
18:46:26 <Pseudonym> dons: takeWhile (not . isSpace)
18:46:31 <dons> hehe
18:46:38 <crackhead> what is the .?
18:46:44 <dons> crackhead: you should memorise most of http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:46:49 <Pseudonym> "not" is the first argument and "isSpace" is the second.
18:47:14 <crackhead> hehe....yea..I'm working on it
18:49:24 <Pseudonym> crackhead: If it helps, this might be more understandable.
18:49:26 <crackhead> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#compose 
18:49:31 <Pseudonym> takeWhile (\c -> not (isSpace c))
18:49:39 <crackhead> that seems to be a pretty good website
18:49:40 <Pseudonym> Basically, the dot is a shorthand for that.
18:50:00 <crackhead> hmmmmm....interesting
18:50:20 <dons> or even (\c -> not $ isSpace c)  death to parens!
18:50:56 <crackhead> whoa....what is $
18:51:15 <Pseudonym> Yuck.  I hate $.
18:51:19 <Pseudonym> It has the wrong associativity.
18:51:55 <dons> it is wonderful. you save an extra char at the end of the line
18:52:09 <dons> and it is absolutely nec. for: when (not bad) $ do
18:52:42 <dons> control flow constructs in general
18:53:00 <Pseudonym> My problem with it is this.
18:53:10 <Pseudonym> f $ g $ x == f (g x)
18:53:13 <Pseudonym> Where it should be:
18:53:19 <Pseudonym> f $ g $ x == f g x
18:53:37 <dons> yah. ok. that is reasonable.
18:53:40 <Pseudonym> If you want f (g x), you can use f . g $ x
18:53:50 <dons> you just want explicit space
18:54:02 <Pseudonym> But if I want f (g x) (h y), then I want to write f $ g x $ h y
18:54:12 <dons> yep.
18:54:16 <Pseudonym> This is especially important if you want to intermix $ and $!.
18:54:26 <dons> ah. true. $! can get a bit hairy
18:58:09 <Pseudonym> I'm often in the situation where I want to make one argument to a call strict.
18:58:26 <Pseudonym> Being able to write f x $! y $ z would be reall good
18:59:09 <Pseudonym> At the moment, my options are let y in y `seq` f x y z
18:59:16 <Pseudonym> Or something like that.
18:59:21 <Pseudonym> I can't really use $!.
18:59:31 <Pseudonym> This, I suppose: (f x $! y) z
18:59:40 <Pseudonym> But that obscures things quite a bit.
19:00:06 <dons> yep. I usually resort to seq too. this is not really satisfactory
19:33:20 <dons> oops. $ARGV[0] isn't defined in sh
19:34:45 <dons> nono. i'm not really writing in sh
21:50:15 <Pseudonym> http://andrew.bromage.org/fluid.mpeg
21:50:28 <Pseudonym> Looks much better than my last attempt.
23:11:57 <musasabi> morning
23:12:21 <bbls> hi
23:15:41 <musasabi> hellp
23:15:44 <musasabi> *hello
23:15:51 <bbls> hello world :)
