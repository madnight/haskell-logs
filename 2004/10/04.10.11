00:12:19 <shapr> good morning #haskell !
00:14:23 * shapr gives up and goes back to sleep
00:19:22 <heatsink> good mornign shapr
01:34:45 <musasabi> How is the performance of IOUArrays as compared to Ptrs ?
01:51:38 <dons> tumov: sent you a patch to get riot working with plugins external to the tree
01:52:12 <dons> tuomov, I beg your pardon :)
02:00:10 <kosmikus> dblhelix: 1400, according to jj
02:08:51 <dblhelix> kosmikus: ok, thanks
02:22:01 <tuomov> dons: seems to work. thanks.
02:22:11 <tuomov> but what's this deal with Makefile.in?
02:22:23 <tuomov> err Main.hs.in
02:24:15 <dons> has to get the ${PREFIX} somehow
02:24:36 <tuomov> I already pass -cpp to ghc.. it's cleaner imho
02:24:47 <dons> sure! that's better.
02:25:00 <dons> (I was very much just trying to get it working :)
02:26:19 <dons> but the framework is there now. just a matter of polishing and hiding the internals
02:26:50 <tuomov> (and another minor issue: foo' is a no-no, because jed syntax highlighting can't handle such strange syntax)
02:27:30 <dons> you can't have primes in jed!? not very haskellish...
02:27:45 <tuomov> same problem with matlab using ' for transpose and strings
02:27:48 <dons> ah.. so that explains your use of '_' as a suffix
02:27:54 <tuomov> and I think it is bad syntax..
02:28:36 <dons> nah.. you get bonus points from ghc if you use '  ;)
02:28:56 <tuomov> ' is cool to have as parts of names, but character should be something different then, imho
02:30:17 <dons> that's reasonable
02:30:48 <tuomov> of course, jed should be fixed to be able to handle such syntax nevertheless
02:31:07 <tuomov> I actually wrote such a patch once, but it never got integrated
02:31:23 <tuomov> admitted, it was an ugly kludge
02:32:11 <dons> I like this .riotrc as Haskell. it's cool. extension languages for free :)
02:33:06 <dons> just need more hooks into riot to play with now
02:33:56 <dons> riot-emacs ... (just joking)
02:34:04 <tuomov> what are these NOINLINE things in Main.hs.in?
02:34:43 <dons> they stop ghc inlining the unsafeperformio, collapsing it
02:34:57 <dons> it is essential to the global variables trick
02:35:24 <dons> otherwise you'd just get the same value back from the global vars each time
02:35:39 <musasabi> Is there a config-file library for Haskell?
02:36:14 <dons> musasabi: what kind of config-file?
02:36:35 <tuomov> hmm.. NO_LANGINFO_CODESET doesn't seem to be used anywhere
02:36:51 <musasabi> dons: I am thinking of a ini-style file, but as I don't have a specific format needed it can be something else too.
02:36:58 <dons> tuomov: ginsu/Ginsu/Locale.hsc
02:37:32 <dons> just to get it to compile on OpenBSD
02:38:57 <dons> musasabi: really simple config files can just use read() and show()
02:39:26 <musasabi> dons: they are not very good for end-users.
02:39:51 <dons> or you write a parser. or you use hs-plugins to just use haskell itself for the config file
02:40:24 <dons> if you use record syntax, then read and show are pretty convenient
02:41:11 <dons> C { v = "my value", u = 0x123 }
02:41:51 <crackhead> hello everyone :)
02:41:58 <musasabi> hmm that is true, but most of the rules would be list based..
02:42:29 <musasabi> that is the top level construct is a variable number of sections, all containing a variable number of options.
02:42:32 <kosmikus> hi there ... if have a few email addresses I'd like to verify -- if you know the address of one of the following people, please /msg me: Dean Herington, Markus Schnell, Humpus Ram, Alain Cremieux
02:43:13 <crackhead> I was wondering if anyone has any experience with the ghc compiler?
02:43:17 <dons> musasabi : ghc's package.conf files are read/showable. that's about as complex as I'd like to get with this style of config file
02:44:40 <dons> they're a list of record-syntax constructors, some of whose fields are lists
02:44:45 <dons> quite readable, I'd say
02:46:42 <crackhead> so if I have a program that I compile with ghc....can I just give it to someone else and they will be able to run it on there computer?
02:47:01 <crackhead> ...this is on OSX
02:47:19 <crackhead> so would someone else with OSX be able to run it?
02:47:27 <dons> probably, yes.
02:48:02 <dons> otherwise, what would binary distributions be good for?
02:48:27 <crackhead> do they need any other stuff like library files?
02:48:43 <dons> ldd a.out
02:48:48 <dons> tells you what they need
02:49:04 <crackhead> hmmm....nice
02:50:16 <crackhead> hmmmm...my mac doesn't have the ldd command
02:50:17 <crackhead> :(
02:50:50 <dons> sure it does. it's bsd. /usr/bin/ldd ? maybe it is in /sbin or such
02:56:13 <musasabi> crackhead: it should have quite few dependencies.
02:56:39 <musasabi> libgmp being the only nonstandard thing.
02:56:54 <crackhead> hmmmm...strange. I can't find ldd anywhere
02:58:46 <musasabi> objdump -x a.out | grep NEED
03:00:37 <shapr> dons: yo, what do you think about export .hc for an app?
03:02:49 <dons> they still need .hc for the libraries they use.
03:03:27 <dons> hang on, 'export .hc', what do you mean?
03:04:13 <crackhead> hmmm....looks like macosx doesn't have ldd. Instead it has a command called otool
03:05:15 <crackhead> musasabi :can't seem to find objdump either
03:07:45 <dons> time to go!
03:26:47 <tromp> g'afternoon
03:26:58 <crackhead> good morning :)
03:27:23 <mayhem> lo guys 
03:27:48 <mayhem> is there a better algorithm than the dominator/semi-dominator based one for SSA translation ?
05:00:15 <tromp> @index dataTypeOf
05:00:15 <lambdabot> Data.Generics,Data.Generics.Basics
05:03:26 <tromp> @length
05:03:27 <lambdabot> Sorry, I don't know the command "length", try "lambdabot: @listcommands
05:03:31 <tromp> @index length
05:03:32 <lambdabot> Data.List,GHC.List,Prelude,List
05:06:39 <shapr> yow!
05:31:24 <shapr> hoi Jan_w 
05:31:37 <Jan_w> shapr: goddag 
05:34:07 <Jan_w> is there a haskell function to get a sublist from a list from pos X until and with pos Y ?
05:34:19 <shapr> list slicing isn't standard
05:34:26 <shapr> but I've seen some code to do it somewhere
05:34:53 <Jan_w> well i can wrap a take and a drop in a function to do it
05:36:03 <mayhem> anyone experienced in functionnal dataflow analysis ?
05:43:59 <tromp> yes Jan, drop x . take (y-x+1)  is easy enough
05:44:02 <shapr> I *really* like Malcolm Wallace's post about the language shootout
05:44:10 <shapr> I think he has a really good point.
05:46:12 <tromp> the benchmarks are simply too naive. they shldnt repeat something 10 times
05:46:24 <shapr> heck yeah
05:46:36 <tromp> a good c compiler cld optimize that as well
05:46:42 <shapr> if we can statically optimize it away, I say we get credit for it.
05:47:17 <tromp> just make the benchmark actually compute something rather than waste cycles
05:48:05 <shapr> hoi wouter
05:48:13 <shapr> love the new look, nice brackets
05:48:22 <tromp> if haskell submissions can show the folly of poor benchmarks then all the better to expose them
05:48:43 <[wouter]> ah, the brackets are there as someone else registered "wouter"
05:48:49 <shapr> oh, I see
05:48:58 <[wouter]> at least until I come up with a better nick.
05:49:12 <tromp> at least now we know your length:)
05:49:14 <shapr> well, you could just use swierstra... but you might be mistaken for the other swierstra.
05:49:29 <tromp> @eval length [wouter]
05:49:30 <lambdabot> 1
05:49:36 * shapr blinks
05:49:43 <shapr> @eval joy "1 1 + ."
05:49:47 <lambdabot> unbound variable: unbound_variable_error
05:49:49 <shapr> whoops
05:49:51 <shapr> @eval joy "1 1 +"
05:49:54 <lambdabot> [2]
05:50:03 <shapr> right, I forget it's not a real Joy interpreter.
05:50:35 <shapr> data Swierstra = Swierstra Name ; wouter = Swierstra "wouter"
05:50:38 * shapr grins
05:51:40 <[wouter]> yep - too bad there's no functional dependency between first and last name
06:10:07 <tromp> @index findIndex
06:10:08 <lambdabot> Data.List,List
06:11:36 <shapr> tromp: I think you have it exactly right
06:11:42 <shapr> expose the poor benchmarks.
06:12:02 <tromp> and advertize lazyness while we're at it!
06:12:11 <shapr> right on
06:12:40 <tromp> i once wrote a "fhourstones" benchmark
06:13:39 <tromp> never ported to haskell though
06:13:53 <shapr> what does fhourstones do?
06:14:05 <tromp> it solves connect-4 positions
06:14:34 <tromp> seems to make a better benchmark than dhrystones
06:14:39 <shapr> ah
06:14:47 <Jan_w> any idea what a "network of processes" means in a haskell context ?
06:14:56 <shapr> buncha arrows?
06:15:04 <shapr> en m√§ngd arrower?
06:15:29 <Jan_w> shapr: ?
06:16:36 <shapr> as in, the easiest way to simulat a network of processes in a single program (imho) is to use arrows.
06:18:34 <shapr> is that the answer you were looking fo?
06:18:41 <shapr> "for"
06:19:20 <Jan_w> i am unformiliar with the concept "network of processes"
06:19:42 <shapr> CSP - communicating sequential processes
06:19:51 <shapr> google should turn up a bunch of stuff about that
06:19:57 <shapr> you may also want to check out the pi-calculus
06:19:58 <Jan_w> ok
06:20:17 <Jan_w> i thought maybe it rang some special bell in haskell context
06:21:05 <shapr> if it does, I don't know it.
06:21:21 <Jan_w> reading up
06:21:23 <Jan_w> thanks
06:21:32 <shapr> if you find something more than CSP, I want to hear :-)
06:21:45 <Jan_w> ok
06:27:41 <tromp> @index Q
06:27:42 <lambdabot> Graphics.UI.GLUT,Language.Haskell.THSyntax,Language.Haskell.THSyntax,Graphics
06:27:42 <lambdabot> Rendering.OpenGL,Graphics.Rendering.OpenGL.GL,Graphics.Rendering.OpenGL
06:27:42 <lambdabot> GL.CoordTrans
06:32:19 <kosmikus> shapr: got my mail?
06:33:29 <shapr> not yet...
06:33:33 * shapr checks
06:34:00 <shapr> ah, got it
06:34:05 <[wouter]> hi kosmikus
06:34:15 <kosmikus> good ... then the script could actually have worked correctly
06:34:20 <kosmikus> hi [wouter] 
06:34:27 <shapr> looks fine, want me to forward you what I got?
06:34:39 <kosmikus> no, I believe it, then
06:34:49 <[wouter]> have you found a job for next year yet?
06:35:16 <kosmikus> [wouter]: no, nothing for after April 15 ... why? do you have one for me?
06:35:39 <[wouter]> no - just interested.
06:36:17 <kosmikus> [wouter]: no bad news either, though ... everything still open
06:36:44 <shapr> kosmikus: are you looking for paying work? or more education?
06:36:52 <kosmikus> both :)
06:36:56 <[wouter]> kosmikus: no news isn't always good news, when it comes to looking for a job though.
06:36:57 <shapr> heh, ok
06:37:15 <kosmikus> I want to be paid for receiving more education ...
06:37:41 <kosmikus> well, but in principle, I'm open for real money as well, as long as the job is interesting
06:38:26 <[wouter]> and what will you be doing until April?
06:38:38 <kosmikus> [wouter]: I expect explicit notification of rejection for each of the three options I currently have
06:38:53 <kosmikus> [wouter]: I have a job at .uu.nl ;)
06:39:06 <[wouter]> kosmikus: ah - now I remember ;-)
06:51:10 * Igloo looks up - is lambdabot breaking lines on '.' and eating the '.'?
06:59:42 <shapr> could be
07:10:57 <tromp> @index getArgs
07:10:58 <lambdabot> System.Environment,System
07:12:59 <tromp> can ghc make an executable from a module other than Main?
07:13:20 <Igloo> See the -main-is flag
07:16:00 <tromp> isnt --make supposed to mnake an executable?
07:16:40 <Igloo> Not if you give it something with a .hs or .lhs extension
07:18:58 <tromp> if you have source that's not a Module, but has a main function, then what to use?
07:19:16 <tromp> or if the module is something other than Main?
07:22:11 <kosmikus> everything's a module; if you don't specify "module ... where", then it's implicitly Main
07:23:04 <basti_> re
08:03:35 <tromp> @index parseModule
08:03:53 <mento> @index parseModule
08:04:09 <tromp> wakeup, lambdabot:)
08:04:28 <mento> heh
08:05:22 <roconnor> lambdabot is computing busy beaver of 6.
08:07:34 <[wouter]> \quit leaving
08:07:38 <[wouter]> woops
08:15:12 <roconnor> hmmmm there should be a suitable definition of busy beaver for the lambda calculus.
08:16:17 <tromp> how bout max #headreductions for terms of size <= n ?
08:17:01 <roconnor> not bad, but we also want to make a large output.
08:17:24 <tromp> you can transform that to large output with extra constant
08:17:27 <basti_> then it should generate a term of type (lambda a (a (a (a (a a))))) maybe?
08:17:30 <roconnor> I guess we can try to produce the largest redex-free term
08:17:42 <basti_> mh or that
08:18:09 <roconnor> or maybe along basti_'s reasoning, and try to produce the largest church numeral.
08:18:16 <tromp> or you can take max normal form size for terms of size <= n
08:19:36 <roconnor> tromp, when you put it like that, it almost sounds like a problem that would already have a name.
08:20:03 <tromp> not that i know
08:20:27 <tromp> it only requires formal definition of size
08:21:36 <roconnor> number of nodes in parse tree.
08:21:48 <tromp> i prefer number of bits
08:21:56 <roconnor> hmmm... but a graph reducer could have a lot fewer nodes.
08:22:03 <tromp> easier to compare with other languages then
08:22:20 <roconnor> :-/
08:22:32 <roconnor> calculating entropy isn't easy.
08:23:00 <tromp> see my recent paper on binary lambda calculus
08:23:38 <tromp> it defines size of lambda term in bits:)
08:23:54 <roconnor> seems hard
08:23:59 <tromp> ^x.x is 4 bits
08:24:46 <tromp> ^x^y.x is 7 bits
08:25:45 <roconnor> Sounds relative to some arbitrary definition.
08:26:08 <tromp> it's a specific binary encoding of lambda terms
08:26:21 <tromp> what i thought was the simplest one
08:26:29 <roconnor> and a different definition would yield different numbers
08:27:00 <roconnor> can I see your paper?
08:27:05 <tromp> in fact, what i thought gives the smallest interpreter
08:27:20 <tromp> see http://homepages.cwi.nl/~tromp/cl/cl.html
08:30:50 <roconnor> I'm suprised you use ^to represent lambda.  I'd imagine most people use \ now-a-days, though I do admit that historically ^ seems like a better choice.
08:31:13 <tromp> i did use \ before
08:31:29 <tromp> my source was full of \\x\\y\\z ...
08:31:40 <tromp> i just got tired of escaping the \ in strings:(
08:32:31 <tromp> if there was an alternative string notation that didn't require escaping the `\`... i'd stick to that
08:32:32 <roconnor> *l*
08:32:44 <roconnor> that's the best reason.
08:33:22 <tromp> i've seen ^ used in a few other places
08:33:29 <tromp> some even use an infix version
08:33:41 <tromp> so that identity is not ^x.x but x^x
08:34:05 <roconnor> strange
08:34:25 <roconnor> ^x seems better
08:34:35 <roconnor> oh wait
08:35:02 <roconnor> Hmmm I totally forget the original notation.
08:37:55 <roconnor> :-/
08:38:24 <roconnor> all your strings end in 0?
08:38:37 <tromp> all term encodings do
08:39:10 <roconnor> there is one wasted bit.
08:39:14 <tromp> but i cant remove that 0, or the code would no longer be selfdelimiting
08:39:25 <roconnor> oh
08:39:27 <roconnor> hmmm
08:39:30 <roconnor> interesting
08:39:58 <tromp> if you read a coded term from a bitstream
08:40:14 <tromp> than without than 0, you'd need to recognize end-of-file instead
08:40:43 <tromp> and you couldnt put some other binary data right after the coded term
08:40:47 <roconnor> in any case, this definition of bits doesn't seem to get us any closer to comparing sizes in different langauges.
08:41:14 <tromp> java binaries are also easily measured in bits
08:41:41 <tromp> so you can compare with the maximum output of a 1000 bit java program
08:42:20 <roconnor> but the choice of encoding isn't inherent to the langauge.
08:42:31 <tromp> (actually java used bytecode, so just multiply by 8)
08:42:43 <tromp> with java is sure is inherent
08:42:56 <tromp> we're talking binaries, not source
08:43:36 <tromp> java binary format is formally specified
08:43:40 <roconnor> The java byte code could have been smaller while making the interpreter larger.
08:44:00 <monochrom> tee hee hee conservation of mass
08:44:04 <tromp> but it would no longer be java:(
08:44:15 <roconnor> only in a legal sense of the word
08:44:17 <tromp> it would no longer run on your JVM
08:45:00 <tromp> you can also compare to Chaitin's LISP
08:45:04 <roconnor> But I'm not sure US law should define Kolmogorov Complexity :-)
08:45:38 <tromp> still it's nice to see examples of concrete definitions
08:45:47 <roconnor> yes
08:46:17 <roconnor> hmmm
08:46:23 <roconnor> i see your point
08:47:13 <roconnor> Busy Beaver is defined arbitrarily too.  But we care about its rate of growth, not its value.
08:47:40 <roconnor> So maybe your definition of size of lambda terms is just as good as any other.
08:47:56 <tromp> it seems less arbitrary to me than turing machines
08:47:56 <roconnor> I was mistakenly thinking the actual values of 4 or 7 bits were important.
08:48:54 <tromp> chaitin started out studying program size complexity for turing machines
08:49:22 <tromp> but realized at some point the advantages of normalizing to bits
08:49:47 <roconnor> advantages?
08:50:10 <tromp> yes, to developing algorithmic information theory
08:50:41 <roconnor> doesn't seem very advantageous
08:51:31 <tromp> bits are the standard measure in information theory
08:52:49 <roconnor> sure, but any constant multiple of that number would probably due.
08:53:17 <tromp> sure, that wld be equivalant
08:53:45 <tromp> but states/symbols product is rather unwieldy in comparison
08:53:48 <roconnor> you could encode your de bruijn numbers as 1^(ln n)(n in base 2)
08:54:06 <tromp> chaitin wldn't have come up with Omega if he kept using that
08:54:11 <roconnor> that should make many programs smaller
08:54:28 <roconnor> Omega?
08:54:46 <tromp> my paper proposes such an efficient coding of integers
08:55:06 <tromp> but lambda terms are strongly biased towards small indices
08:55:25 <tromp> more importantly, i wanted to keep the interpreter simple
08:55:57 <tromp> it takes 450 bits just to decode a number in binary:(
08:56:14 <tromp> Omega is the famous halting probability
08:56:39 <roconnor> oh
08:59:25 <roconnor> Section 4 is very interesting
09:02:41 <tromp> glad you like it:)
09:03:27 <tromp> you'll probably enjoy chaitin's work
09:05:50 <roconnor> I have a question about computing convolutions of box functions. ... Think there is a channel on freenode for me?
09:06:04 <roconnor> do you want to hear it?
09:06:11 <Cale> sure
09:06:28 <roconnor> it's pretty simple.
09:06:38 <Cale> there's #math, btw
09:07:38 <roconnor> Let box[a](x) = 1/a for x in [-a/2, a/2] and 0 otherwise. ... straight forward box function with an integral of 1. 
09:07:51 <basti_> wavelets?
09:08:21 <roconnor> let f(x) = box[a[0]] * box [a[1]] * ... * box [a[n]]. where * is convolution.
09:08:34 <basti_> hmm
09:08:38 <roconnor> let f = box[a[0]] * box [a[1]] * ... * box [a[n]]. where * is convolution.
09:08:46 <basti_> you can convolute two boxes easily
09:09:09 <roconnor> I want to compute f, hopefully in an elegant manner.
09:09:38 <roconnor> I mean I know how to compute f by making piecewise polynomials, but I figure there is probably a simpiler way.
09:09:44 <basti_> hm.
09:10:01 <basti_> -?-
09:10:04 <basti_> go #math.
09:10:35 <roconnor> I'll try there. ... *l* they'll probably want to compute piecewise polynomials though. ;-)
09:10:45 <Cale> yeah
09:11:25 <basti_> i dont believe there's a simpler way
09:11:28 <roconnor> I want a haskell function to compute f (obligitory on topic comment)
09:11:36 <basti_> really.
09:11:57 <basti_> you could maybe factor out the convolutions before evaluation
09:11:57 <roconnor> There is a simple recursive definition given when all the widths are 1.
09:12:19 <roconnor> You get the B-spline curves and people in graphics talk about that a lot.
09:13:03 <roconnor> But I don't really understand why the CG algorithm works, so it is a bit hard to modify it.
09:14:03 <basti_> hmm
09:14:08 <basti_> what do you want to do anyway?
09:14:20 <basti_> imo B-Splines are not that fancy
09:14:58 <roconnor> B-Splines are not that fancy.  But they are a convolution of box functions.
09:15:12 <roconnor> I'm trying to build convex filters for work.
09:16:58 <basti_> ??convex filters??
09:17:03 * basti_ googlehunts.
09:18:01 * basti_ doesnt come to conclusive results.
09:18:01 <roconnor> I want a filter f such that 0 <= f(x) <= 1 for all x.
09:18:15 <roconnor> convex might not be quite the right word here.
09:18:26 <roconnor> but then again it might be apropriate.
09:18:31 <basti_> you mean a function that you want to convolve something with?
09:18:33 <Jan_w> shapr: http://www.cs.wwc.edu/~cs_dept/KU/PR/Haskell.html, read the section just above the definition of hamming 
09:18:46 <Jan_w> shapr: that's what I ment
09:18:51 <roconnor> yeah, my filter f will be convolved with my input image.
09:18:59 <basti_> ah.
09:19:14 <basti_> hmm
09:19:24 <basti_> you dont wont f's whose integral is 1 maybe?
09:19:36 <roconnor> I also want f to have an integral of 1.
09:19:41 <basti_> hmm okay.
09:19:49 <basti_> thats why you convolve these variable boxes.
09:19:55 <roconnor> yes
09:20:06 <basti_> how large will the filters be?
09:20:09 <roconnor> It will let me try out lots of filters without too mcuh work.
09:20:22 <basti_> i mean how "long" (area in this case)
09:21:05 <roconnor> The support of the functions won't be any more than a few thousand, but the width doesn't matter.
09:21:37 <basti_> why dont you just simply convolve discretely?
09:22:08 <roconnor> interesting.
09:22:24 <roconnor> I supspect the piecewise polynomial solution would be faster.
09:22:43 <basti_> i mean, you probably know which resolution image and filter would have...
09:22:48 <basti_> hm
09:23:02 <basti_> probably.
09:23:08 <basti_> if you do it the right way (tm)
09:28:23 <roconnor> OB Haskell:
09:28:24 <roconnor> BSpline 0 t = if (0 <= t && t <= 1) then 1 else 0
09:28:26 <roconnor> BSpline n t = t/n*(BSpline (n-1) t) + (n+1-t)/n*(BSpline (n-1) (t-1))
09:28:31 <roconnor> or something like that.
09:29:20 <roconnor> my point is that that doesn't deal with polynomials.
09:29:41 <roconnor> So I think I should be able to do something like that for my problem.
09:29:41 <basti_> hm
09:30:05 <basti_> yes i think you can do it, it would be not much different.
09:30:09 <basti_> hm
09:30:10 <basti_> or
09:30:11 <basti_> uhm
09:30:21 * basti_ is still jet lagged, fingers quicker than thoughts
09:30:45 <roconnor> I figure step 1 is to sort the boxes by width, and work from largest to smallest.
09:30:54 <basti_> hmm
09:31:12 <basti_> oof.
09:31:48 <basti_> will my condition get better when i smoke some weed?
09:32:08 <roconnor> no
09:32:14 <roconnor> but that doesn't mean you shouldnt.
09:32:52 <roconnor> I once tried making my AI homework more pleasent by drinking wine, but it actually became more difficult.
09:33:23 <sorje> But was it more pleasant?
09:33:49 <roconnor> not really.  I actually was just more frusterated.  I probably should have had more wine.
09:37:58 <tromp> @index mkQ
09:42:14 <roconnor> lambda bot is still computing busy beaver of 6.
10:07:57 <bourbaki> hi
10:09:23 <Lemmih> Hey
10:10:06 <bourbaki> greetings Lemmih :)
10:31:58 <tromp> @index cast
10:33:05 <ski> --- lambdabot :No such nick/channel
11:05:22 <musasabi> evening
11:05:34 <esap> evening
11:06:39 <Lemmih> Good evening.
11:07:31 <CosmicRay> good afternoon.
11:08:03 * ski says good afternoon
11:18:50 <dnz> values x:xs = map((x,False):) (values xs) ++ map((x,True):) (values xs)
11:18:53 <dnz> i get the error :
11:19:01 <dnz> Syntax error in declaration (unexpected
11:19:01 <dnz>  symbol ":") 
11:19:10 <dnz> Syntax error in declaration (unexpected
11:19:10 <dnz>  symbol ":") 
11:19:19 <dnz> oops.. doeble paste :/ sorry
11:19:44 <Igloo> values (x:xs) = ...
11:19:46 <ski> s/values x:xs = /values (x:xs) = /
11:19:54 <dnz> ok :)
11:21:21 <dnz> thx
11:33:06 <Jan_w> shapr: back?
11:47:17 <mento> what does "id" mean in "otherwise = id" ?
11:47:33 <musasabi> mento: id means identity.
11:47:45 <musasabi> mento: id :: a -> a ; id a = a
11:47:54 <mento> ok
11:48:07 <mento> it's a function, it aint a data type ?
11:48:09 <Jan_w> how is that helpfill ?
11:48:12 <musasabi> yes
11:48:15 <Jan_w> full
11:48:15 <mento> thx
11:48:34 <mento> you ask me ?
11:48:41 <mento> Jan_w
11:48:50 <Jan_w> mento: yea, it returns whatever you feed it ?
11:49:19 <Jan_w> in id :: a -> a ; id a = a its calling itself ?
11:49:23 <Jan_w> endless?
11:50:07 <Cale> huh?
11:50:08 <musasabi> no.
11:50:21 <Cale> id a = a means that it just returns its argument unchanged
11:50:25 <musasabi> Jan_w: it simply returns it's argument.
11:50:27 <Lemmih> Where's lambdabot?
11:50:39 <Cale> for example, id 6 = 6
11:50:59 <mento> I got it :D
11:51:01 <Jan_w> musasabi: oh, indeed, returns me the my previous question :) how is that helpfull , as in: what does it do ?
11:51:19 <mento> iter :: Int -> (a->a) -> (a->a)
11:51:19 <mento> iter n f 
11:51:19 <mento> 	| n>10 = f.iter(n-1) f
11:51:19 <mento> 	| otherwise = id
11:51:33 <mento> ..
11:51:38 <Cale> Jan_w: it's useful whenever you need a function that does nothing
11:52:12 <Jan_w> *pondering*
11:52:27 <musasabi> Jan_w: function composition and functions passed as argument mainly.
11:53:31 <Jan_w> musasabi: it will cause the recursion to "fall-through" a level ?
11:53:38 <Cale> perhaps in a call to a higher order function, you have the option to provide a function which does some transformation -- id could be passed to indicate that you don't want that transformation
11:53:57 <Jan_w> Cale: that's a good one
11:54:51 <mento> is that what happens in my code when n <= 10
11:56:02 <Jan_w> i see, very nice, never thought of that :)
11:58:09 <Jan_w> I'm just starting an exercise to create a solver that gives me all solutions for the classis chess-horse problem (has to visit every field exacly once)
11:58:20 <Jan_w> might be able to use that :)
11:58:56 <mento> I dont think I get it. Is this right: id f.f.f.f.f.f a ?
12:00:19 <Jan_w> mento only if f takes 1 arg a ?
12:00:31 <mento> yea
12:00:53 <Jan_w> I should think so, but also if indeed f :: a -> 
12:00:59 <Jan_w> f :: a -> a
12:02:09 <TheHunter> mento: you probably mean (f . f . f . f . f . f . id) a
12:02:43 <Jan_w> TheHunter: hm good point
12:02:50 <mento> I just dont know what happens here 
12:02:50 <mento> iter :: Int -> (a->a) -> (a->a)
12:02:50 <mento> iter n f 
12:02:50 <mento> 	| n>0 = f.iter(n-1) f
12:02:51 <mento> 	| otherwise = id
12:03:04 <mento> when n is less or equal to 0
12:03:07 <Jan_w> since f . g means f BEFORE g
12:03:08 <ski> TheHunter : the ". id" part is useless there
12:03:10 <mento> it goes f.f.f.f then what
12:03:43 <TheHunter> iter 1 => f . iter 0 f => f . id === f
12:03:54 <TheHunter> ski: I know.
12:04:03 <mento> thank you all
12:04:10 <Jan_w> ski: that was not the point :)
12:04:28 <TheHunter> iter 2 => f . iter 1 f => f . f . iter 0 f => f . f . id
12:05:04 <TheHunter> iter 2 (+1) 0 => ((+1) . (+1) . id) 0 => ((+1) . (+1)) 0 => (+1) 1 => 2
12:05:31 <mento> thx a lot!
12:05:34 <Jan_w> I'm just discovering infinate lists, pretty cool
12:05:35 <mento> thx
12:06:23 <Jan_w> there's a lot more to lazy evaluation than I thought
12:13:26 <Cale> f . g means "f following g"
12:13:42 <kristnjov> f . g is like f(g(...
12:14:47 <Jan_w> You're both absolutely right, sorry for bringing more confusion
12:22:07 <kristnjov> Jan_w, so do you have any updog?
12:22:31 <Jan_w> updog?
12:22:37 <kristnjov> yes, updog
12:22:47 <Jan_w> dict ("updog")
12:22:54 <kristnjov> hm?
12:23:29 <kristnjov> so do you?
12:23:42 <Jan_w> updog is not in my vocabulairy
12:23:49 * stepcut writes some crazy ass makefiles
12:23:53 <kristnjov> gah you programmers are hard to catch :/
12:23:58 <kristnjov> you're supposed to ask "what's updog?"
12:24:06 <kristnjov> and i'll go like "nothing much, how about you?" :/
12:24:17 <Jan_w> HAHAAHA
12:24:44 <Jan_w> kristnjov: gotta love those cotchas
12:25:26 <kristnjov> :\
12:25:38 <stepcut> kristnjov: what were you eating under there ??!
12:25:54 <Jan_w> stepcut: what's there ?
12:25:57 <Jan_w> ;)
12:26:05 <stepcut> Jan_w: haha
12:26:27 <stepcut> this ain't no holiday, but it always turns out this way
12:26:41 <Jan_w> i heard about a lawsuit, some guy insured some very expensive cigars against FIRE!
12:27:19 <Jan_w> so smoked them and claimed they "went up I a series of fires"
12:27:55 <stepcut> Jan_w: yes, I think he won, but the insurance company counter-sued him for insurance fraud
12:28:07 <mento> lol
12:28:16 <Jan_w> yes he won, got 14.000 dollar
12:28:36 <Jan_w> but they suit him for arson, he got 24.000 dollar fine and 6 moths jail
12:28:49 <stepcut> yeah, arson...
12:29:02 <Jan_w> they had HIS testimony saying HE smoked the cigars
12:29:10 <stepcut> hehe
12:29:13 <Jan_w> open and shut case :)
12:30:31 <Jan_w> so cool, they arrested him, right out of court, after he thought he just gained 14.000 dollars :)
12:31:51 <TheHunter> http://www.snopes.com/crime/clever/cigarson.asp
12:32:03 <Boegel> @seen mitchkov
12:32:26 <Boegel> ow, lambdabot isn't here ?
12:33:01 <Boegel> shapr: no lambdabot today ?
12:34:59 <Lemmih> Nope.
12:38:28 <Boegel> how come ? :s
12:41:06 <Lemmih> He was stressed so he took a day off golfing.
12:43:15 <thebug> Boegel: you do know that fn.n has seenserv ... /msg seenserv seen <nick> will get you the same thing as @seen <nick>
12:43:17 <Boegel> :o)
12:43:57 <Boegel> thanx the bug :)
12:44:25 <thebug> no problem
12:44:53 <thebug> the only diff between seenserv/@seen will be that seenserv is last seen on fn.n, @seen is last seen in #haskell
12:44:56 <Boegel> what does this type of error mean generally ?
12:44:56 <Boegel> ERROR "F:/THESIS/Haskell/rayCasting.hs":245 - Instance of Eq [(Double,Intersecti
12:44:56 <Boegel> on)] required for definition of closestIntersection
12:46:22 <Cale> Is Intersection in the class Eq?
12:46:39 <Boegel> err, no
12:46:41 <Boegel> should it be ?
12:47:06 <Cale> well, closestIntersection seems to compare lists of pairs of Doubles and Intersections for equality
12:47:15 <Boegel> no
12:47:19 <Boegel> I'll show it to you...
12:47:21 <Boegel> ERROR "F:/THESIS/Haskell/rayCasting.hs":245 - Instance of Eq [(Double,Intersecti
12:47:22 <Boegel> on)] required for definition of closestIntersection
12:47:25 <Boegel> ow wait :p
12:48:05 <Boegel> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
12:48:22 <Boegel> I don't think you need the definition of intersect, but if you do, tell me
12:48:56 <Boegel> I compare list with [], maybe that's it...
12:49:03 <Cale> yes, using ==
12:49:14 <Cale> which isn't defined unless there's an instance of Eq
12:49:30 <Cale> you could use "null list"
12:49:33 <Boegel> but why ?
12:49:53 <Boegel> I'm not comparing intersections, I'm comparing a list with []...
12:49:56 <Boegel> hmmz
12:50:23 <Lemmih> Because (==) is a member of the Eq class. You can't use (==) on a datatype without it being an instance of the class.
12:50:26 <Cale> You're comparing a list of type [(Double,Intersection)] with another list of type [(Double,Intersection)]
12:50:34 <Boegel> maybe it's just Haskell saying that if you use == in ANY case, you need to make sure an instance for every type used in the arguments is in the Eq class
12:50:36 <Boegel> is that right ?
12:50:47 <Cale> yes
12:50:49 <ski> == doesn't know here that it always get called with second arg [], so it thinks it needs to know how to compare such lists for equality, in general
12:51:04 <Boegel> ow okay
12:51:17 <Boegel> so I should just add the Intersection type to the Eq class properly then ?
12:51:59 <Cale> you could also use the null function
12:52:06 <Cale> Prelude> :t null
12:52:06 <Cale> null :: forall a. [a] -> Bool
12:52:38 <Boegel> so in stead of (list == []) I can use (null list)
12:52:41 <Boegel> no
12:52:44 <Boegel> (!null list)
12:52:50 <Boegel> no
12:52:54 <Boegel> (null list), sry :)
12:53:14 <Boegel> ok, I can do that, but at least I know now what caused the error
12:53:17 <Boegel> thanks :)
12:53:24 <Boegel> you guys really are a great help
12:53:34 <Boegel> if I were to figure these things out on my own :s
12:53:52 <Cale> It will all become obvious in time :)
12:54:29 <Boegel> how do you guys like my code ?
12:54:32 <Boegel> is it decent ?
13:07:02 <Deniz> hmm.. I havce problem compiling haskell-code wtith ghc under windows..
13:07:14 <Deniz> and the documentation help..
13:08:15 <Deniz> very noob question..
13:08:19 <Deniz> where do I find ghc -o main main.hs
13:08:25 <Deniz> d'oh..
13:08:30 <Deniz> where do I write : ghc -o main main.hs
13:08:36 <Deniz> im cmd.exe ?
13:08:38 <Deniz> :/
13:08:51 <Lemmih> Sure.
13:08:52 <Deniz> i'm really confused..
13:08:54 <Lor> The command prompt, yeah.
13:09:23 <Lor> (Of course you _could_ also use a real shell...)
13:10:10 <Lemmih> Deniz: Hugs is probably easier to use on a windows box.
13:10:43 <Deniz> it says.. 'ghc' is not recognized as an internal or external command, operable program or batch file..
13:10:59 <Deniz> no.. I have to use ghx.. gonna use wxHaskell
13:11:11 <Lemmih> Fix your PATH variable.
13:11:21 <Deniz> easy to say :D
13:11:29 <Deniz> how do I do taht ?
13:11:47 <Lemmih> I don't know. I've been using Linux the last couple of years.
13:12:06 <Lor> deniz, it might be worthwhile getting acquainted with the command line in general first, before delving into the details of using ghc.
13:12:27 <Lor> If you get a real shell, we might also be better able to advise you.
13:12:52 <Deniz> hmm.. 
13:12:58 <kristnjov> Deniz, have you cd'ed to the location of ghc.exe?
13:13:00 <Deniz> which shell is good for windows ?
13:13:46 <Lor> http://www.cygwin.com/
13:14:02 <Lor> That should give you all the standard unix tools on windows.
13:15:11 <Deniz> ok..
13:15:12 <Deniz> ncie
13:15:18 <joao> Hello
13:15:33 <Lemmih> Hey joao
13:15:36 * Lor is doesn't know squat about cygwin or windows, this is all just hearsay. :)
13:15:40 <joao> :)
13:15:45 <joao> What's up?
13:16:40 <Lemmih> Hacking while thinking of job opportunities.
13:17:02 <joao> Haskell job? :)
13:17:16 <thebug> Lor: not at all incorrect either ;)
13:17:54 <Lor> I'm really not sure how good an idea it is to recommend cygwin for a beginner.
13:21:29 <Deniz> hmm.. damn it.. i just have to use my gentoo machine then!! :/
13:24:02 <Lemmih> Deniz: It's not so hard. Just set the PATH and emacs will take care of the rest.
13:26:27 <Deniz> ok..
13:26:42 <Deniz> but it's alittle tricky in windows anyway :)
13:26:58 <Deniz> however.. g-night! and thanks for the help anyway..
13:31:09 <Lemmih> lambdabot: yay.
13:31:10 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:32:55 <mento> Isn't tail [] defined ? :S I get pattern match failure
13:34:04 <Lemmih> How would you define tail []?
13:34:24 <mento> no comment...
13:43:52 <Boegel> tail [] isn't defined no :)
13:44:00 <Boegel> it only works for non-empty lists
13:44:03 <Boegel> just like head
13:52:35 <mentomorph> Boegel: Got the rest of your msg from the logs.
13:56:38 <Boegel> mentomorph: which message?
13:57:15 <mentomorph> I was mento, got dissconnected. I just saw one part of ur last msg
13:57:36 <mentomorph> logs are good
13:58:12 <Boegel> :)
13:58:27 <Boegel> I'm having (another) problem with my Haskell code
13:59:05 <Boegel> Hugs says returns a type error, it wants (Int,Int,Int), and it get's [Color]
13:59:16 <Boegel> where Color is defined as (Int,Int,Int)
13:59:25 <Boegel> but the type of my function is this:
13:59:30 <Lor> So you are giving it a list of colors when it wants a single one.
13:59:32 <Boegel> rayTraceLine :: (Double,Double) -> Camera -> [Object] -> [Light] -> [Color]
13:59:38 <Boegel> so there's no type error if you ask me...
13:59:43 <Boegel> it gets what it should get...
14:00:06 <Lor> The reported location of the error may sometimes be a bit misleading.
14:00:07 <Lemmih> You've probably made a typo.
14:00:21 <mentomorph> check what you're returning just one more time :s
14:00:50 <Boegel> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
14:01:10 <Lemmih> OpenGL is getting on my nerves!
14:02:03 <Lemmih> Boegel: Is getColor returning a list?
14:02:18 <Boegel> no
14:02:27 <Boegel> but I did [getColor]
14:02:34 <Boegel> so that should be the same, right ?
14:03:02 <Lor> Boegel, the first alternative returns a color and not a list of colors.
14:03:17 <Lemmih> (ry == 0)     = getColor ...
14:03:33 <Boegel> yeah, okay
14:03:39 <Boegel> I fixed that, but the problem is lower
14:04:17 <Boegel> there's something wrong with the second alternative
14:05:31 <Boegel> ow wait :)
14:05:40 <Boegel> replacing : with ++ does the job
14:07:20 <Lor> Boegel, do the list items have to be in that exact order?
14:07:34 <Lor> It's clumsier and less efficient than the reverse order.
14:13:00 <Boegel> yes, they have to be in that order
14:13:09 <Boegel> I'm having a bigger problem now I'm afraid...
14:13:17 <Boegel> all my functions are done
14:13:24 <Boegel> but when I test it, I get this:
14:13:34 <Boegel> ERROR - C stack overflow
14:13:37 <Boegel> no fun :(
14:13:58 <Boegel> is there any way I can give Hugs more memory or something ?
14:14:45 <Lor> Sounds like a strictness problem.
14:15:26 <Boegel> meaning ?
14:15:32 <Lor> No, sorry, it's just that your code is not tail recursive
14:15:57 <Lor> Either turn your code tail recursive or build the list in the reverse order.
14:16:43 <Lor> foo x ++ [y] is usually a bad idea when compared to y : foo x
14:20:27 <Boegel> hmmz, okay, I see
14:20:45 <Boegel> Hugs has to store everything in its memory because I build the list like that...
14:22:19 <Lor> To get the _first_ element in the list, it has to recurse down to the _last_ rayTraceLine call.
14:22:27 <Boegel> uhu
14:22:32 <Boegel> I see
14:23:20 <Lor> Boegel, there's a great deal of duplication in your code. That should be taken as a warning sign that there's something wrong with it.
14:25:40 <Boegel> you mean I can avoid the two alternatives ?
14:25:40 <Lor> I don't quite see what it's supposed to do, anyway, since the value of ry is nowhere used.
14:26:02 <Lor> As it stands, the returned list has the same value in every element.
14:26:05 <Boegel> yes it is, in direc (where clause)
14:26:21 <Lor> Ah, right.
14:26:33 <Boegel> and with the recall of rayTraceLine i do (ry-1)
14:26:52 <Boegel> it makes a calculation for every element of a row
14:27:20 <Lor> What you really should do is map a function that depends on the value of ry, for all values of ry.
14:27:23 <Boegel> maybe I could use the 'map' function for that...
14:27:34 <Boegel> but anyway, it seems the work now
14:27:45 <Boegel> the image it produces will be backwards though I guess
14:27:50 <Boegel> but i'll fix that later :)
14:50:55 <mentomorph> Please! Does anyone have (online or not) some Exercises with solutions or Exams with solutions or Lectures except ppl from Chalmers university and Haskell.org. Thank you.
14:51:33 <monochrom> There are ppl outside chalmers and haskell.org?
14:51:59 <Boegel> monochrom: :o)
14:52:02 <Boegel> I'm going to bed
14:52:06 <Boegel> sleep tight everyone
14:52:36 <Jan_w> mentomorph: well i have some exercises, but no answers
14:52:52 * CosmicRay has looked at darcs
14:53:09 <CosmicRay> some concepts are nice but it sure looks difficult to get a sensible change history
14:53:56 <Jan_w> mentomorph: but mostly the exercises are from or related to "the craft of functional programming"
14:54:10 <Jan_w> (simon thompson)
14:54:28 <Jan_w> mentomorph: so you might buy the book :)
14:54:36 * Jan_w likes it
14:54:46 <mento> I have the book :D
14:55:18 <Jan_w> mento: well, it contains some good exercises
14:55:24 <mento> I've done like 70% of exercises too, but I'd like some more.I'm preparing for the exam.
14:55:49 <Jan_w> mento: what level ?
14:56:42 <monochrom> do 100% of the exercises
14:57:02 <mento> err, we've been jumping from chapter to chapter and we've done like 3/4ths of exercises on each gone trough chapter.
14:57:39 <Jan_w> did you cover chapters 5,6,7, 10,11,16 en 17 ?
14:57:49 <mento> not 11 and 16
14:58:15 <monochrom> Paul Hudak teaches haskell at Yale right?  Or is it Harvard?  Anyway find his course page and you may get something.
14:58:23 <mento> Do you know of any other univerity except Chalmers doing Haskell. Maybe ther's 
14:58:26 <mento> oh
14:58:31 <mento> ok
14:59:18 <Jan_w> mento: well, i do know of some exercises, but there in dutch :)
14:59:44 <Jan_w> excuse me, "ther're" :)
14:59:50 <shapr> they're ?
14:59:52 <mento> I'd be glad to try some duch :D
14:59:59 <Jan_w> well you get my drift
15:00:00 <mento> dutch
15:00:14 <Jan_w> mento: kidding right :)
15:00:33 <Jan_w> mento: learning dutch is probebly much harder that learning haskell :)
15:00:46 <Jan_w> mento: well anyway http://www.ict.hen.nl/Studie/Wijzer/wijzer.html?parent=10005042
15:00:49 <mento> I'd just like to go trough your code
15:00:54 <mento> thank you
15:01:04 <Jan_w> contains some execises
15:01:16 <Jan_w> but the first few only refer to the book
15:01:23 <shapr> mento: write a lambdabot plugin :-)
15:01:25 <shapr> @listmodules
15:01:25 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
15:01:25 <lambdabot> ,"dynamic","eval","hello","karma","more","quote","seen","state","system
15:01:25 <lambdabot> ,"topic","type"]
15:01:43 <Jan_w> from week 4 and up becomes more interesting
15:01:44 <Jan_w> :)
15:02:13 <Jan_w> I myself, i'm working on the week 6/7 exercises, with the horse-business :)
15:02:38 <mento> lol
15:02:42 <Jan_w> up-down permutations, list-of-succeses / backtracking etc...
15:04:28 <Jan_w> shapr: did you see the link i send you earlier on the network-of-processes ?
15:04:44 <shapr> nah, I'll scroll back
15:04:56 <mento> can I see it too, thx.
15:05:36 <shapr> Jan_w: this ? http://www.cs.wwc.edu/~cs_dept/KU/PR/Haskell.html 
15:05:40 <arjanb> heh functional programming at the hen?
15:05:54 <Jan_w> shapr: that was it
15:06:24 <Jan_w> find the hamming def. that's what I ment
15:07:04 <Jan_w> arjanb: yup
15:07:15 <Jan_w> arjanb: at the UT too ?
15:07:22 <Jan_w> arjanb: haskell also ?
15:08:06 <arjanb> no haskell :-( and it's only an optional course here
15:09:01 <Jan_w> arjanb: oh, well, when doing the security-specialization at the hen, it's a optional course too... i choose to do it
15:09:37 <Jan_w> But i think it was a good choise, and I like haskell a lot
15:09:40 <mento> Jan_w: Thx for the link, I find your Handouts usefull.
15:09:51 <Jan_w> mento: np
15:10:14 <Jan_w> mento: hope you like dutch :) haha
15:17:24 <Si\> Does anyone know if it's possible to have two mutually recursive modules A and B, with two data-types TA and TB, where TA contains a field of type TB and derives Data?
15:17:47 <shapr> last I heard, recursive modules requires building .hi files separately or something.
15:18:04 <Si\> Oh yes I've done that
15:18:38 <Si\> but I need to know if it's possible to recurse with deriving Data types, you can't include instances in the hi-boot
15:23:12 <Jan_w> shapr: is idleing/awaying recommended in this chan ? or even permitted ?
15:23:26 <shapr> well, if you want to hang around and not say anything, that's fine
15:23:41 <shapr> announcing that you're away gets annoying
15:23:50 <shapr> if you want to change your nick to show that you're away, I don't mind
15:23:58 <shapr> but there is already an irc feature to do that
15:24:00 <shapr> namely, /away
15:24:16 <shapr> if you do "/away getting food"
15:24:27 <shapr> then "/whois Jan_w" will show that
15:24:46 <monochrom> 99% of the time no one cares when you're away, when you're back, etc
15:24:48 <Jan_w> shapr: i know, just curious about the policy here
15:25:00 <shapr> there's no policy
15:25:07 <monochrom> those announcements are for childish people
15:25:17 <Jan_w> monochrom: i'd be suprise how anal some chans are about this
15:25:45 <Jan_w> glad to hear it isn't a problem here
15:26:08 <monochrom> "I'm away bathing"  "I'm back after 5 minutes 48.39293894839439 seconds"  "I'm listening to xyz.mp3 129.283784733kbps 3 minutes 46.09023000033 seconds"   Like, who cares?
15:26:12 <Jan_w> anyhow, i wish you all goodnight, happy hacking :)
15:26:23 <shapr> g'night Jan_w 
15:26:41 <monochrom> I'd prefer a channel to be anal about this.  Screens 99% of the dumb childish people.
15:35:21 <shapr> programmer: so, found anyone who'll do homework for money?
15:36:32 <shapr> Jan_w: I don't completely understand that hamming number code, that gets me interested.
15:36:34 <programmer> shapr you still think it is homework ;)
15:37:02 <shapr> well, either homework or that secret agent competition thingy
15:37:35 <Jan_w> shapr: i don't either, i understand the merge code, but not how the numbers and generated...
15:37:57 <shapr> programmer: anyway, it'd be less effort to learn enough haskell to do the code yourself.
15:39:48 <programmer> I prefer to stick to java
15:40:08 <Jan_w> programmer: are you insane :)
15:40:56 <shapr> The popular programming languages change, diversifying your knowledge portfolio is always worthwhile.
15:42:18 <Jan_w> programmer: this thing is, you need to wrap your mind around haskell
15:42:39 <Jan_w> programmer: it's not like OO programming at all
15:42:45 <monochrom> what is programmer trying to do?
15:43:22 <Jan_w> monochrom: trying very hard not to learn haskell when he has the change to do so :()
15:44:45 <mento> bah
15:44:53 <mento> "programmer"
15:45:02 <mento> jk
15:45:10 <shapr> mento: I agree with you
15:51:52 <monochrom> You may be able to avoid haskell, but you may be unable to avoid F#.
15:52:16 <monochrom> See http://www.cse.ogi.edu/~byron/ the first paragraph "Don Syme helped me ..."
15:53:01 <monochrom> F# is a .net functional language that begins to prove to run fast.  With the .net affiliation it may become inevitable.
16:13:56 <mento> some lectures: http://www.cogs.susx.ac.uk/users/ll42/Fun@Susx/
16:14:32 <Lemmih> F# is not a joke?
16:22:41 <Etaoin> F# exists.
16:23:14 <Lemmih> And it's not a joke?
16:24:11 <Etaoin> it a real piece of software that compiles to .NET CLR if that's what you mean.
16:26:50 <shapr> Btw people, unless programmer sends me a real actual specification, I think it's likely he's trying to get this homework done for him: http://www.soi.city.ac.uk/~ross/teaching/FP/cwk1.html
16:27:14 <shapr> this has been your public service announcement
16:37:07 <Jan_w> shapr: yup
16:38:03 <Jan_w> "This coursework is due on Monday 25th October, and is worth 8% of the marks for the module. " :)
16:38:42 <shapr> Jan_w: I said I could have the code to him by Oct 31st, and then suddenly there was a deadline of "the 25th\nI mean the 20th"
16:39:20 <SyntaxNinja> heh
16:39:36 <shapr> Anyway, I just sent an email containing the private chat log and related info to Ross Paterson, teacher of that course.
16:39:37 <SyntaxNinja> I suppose that there are good cheaters out there who we never catch on to :)
16:39:47 <SyntaxNinja> but it sure doesn't seem like it
16:40:02 <Jan_w> shapr: i said i'd fix the code for him right here and now, if he'd pay $100 using paypal, and suddenly the assignment was different and i'd email me :)
16:40:07 <shapr> well, that guy put so much effort into conning us that he could have learned monads by this time.
16:40:24 <shapr> Jan_w: yah, he said he'd send the money via paypal
16:40:47 <shapr> and that it had a $100 (proposed) payment 
16:40:48 <heatsink> Is there a library function to get the IEEE 754 representation of a float or double? I want to write some floats to a file and read them in C without doing data conversion on the C side...
16:40:54 <Jan_w> shapr: if i see money first, i'll do his homework :)
16:41:02 <shapr> I'd rather report him
16:41:11 <shapr> heatsink: no lib function, but I have some code to do it.
16:41:18 <Jan_w> shapr: is the right answer :)
16:41:27 <heatsink> shapr: do you start from decodeFloat?
16:41:32 <shapr> yes I did
16:41:45 <shapr> Jan_w: actually, I'd rather report him and have the money, but we can't have everything ;-)
16:42:00 <Jan_w> shapr: unfortunately, he used a anonymous hotmail, and aol. irc connection :)
16:42:11 <shapr> oh he gave you an email address?
16:42:23 <heatsink> You could put a time bomb in the code... after the 24th, it prints out "I'm a cheater" instead of the correct answer :)
16:42:25 <shapr> he gave me d.seeley@logica.com and claimed to be from Logica Design Limited
16:42:27 <Jan_w> shapr: he send me the assignment
16:42:35 <shapr> Jan_w: oh I want to see!
16:42:43 <CLxyz> damn, ibm laptops are expensive
16:43:02 <Jan_w> shapr: it's almost exactly liek the course assignment
16:43:05 <shapr> heatsink: Ross Paterson is second only to John Hughes in knowledge of arrows, I thought of sending him a totally arrow-based solution.
16:43:21 <Jan_w> shapr: i can forward it ? email ?
16:43:21 <heatsink> heh
16:43:35 <shapr> Jan_w: shae at scanned in avian dot com
16:43:50 <shapr> tmda will send you a "are you sure?" bounce if I don't have you whitelisted
16:44:36 <Jan_w> shapr: so you need my email ?
16:44:46 <shapr> or you can just reply to the bounce
16:44:54 <Jan_w> shapr: oh ok
16:45:23 <Jan_w> scannedinavian dot com or dot org ?
16:45:46 <shapr> dot com
16:45:56 <shapr> but dot org and dot net probably work too
16:46:39 <shapr> anyway, this guy got the name of his company wrong
16:46:47 <shapr> that's pretty sad. he's not even a good scammer.
16:46:52 <Jan_w> hehe
16:47:43 <Jan_w> shapr: that a pretty cool anti-span system
16:48:05 <SyntaxNinja> Jan_w: no it isn't don't use it!
16:48:23 <Jan_w> why not ?
16:48:25 <SyntaxNinja> it just makes spam someone else's problem
16:48:26 <shapr> it's http://tmda.sf.net/
16:48:33 <Jan_w> i love it already
16:48:33 <SyntaxNinja> it generates collatoral spam
16:48:56 <Jan_w> SEP, fine with me :)
16:49:15 <Jan_w> SyntaxNinja: only for people i don't know
16:49:29 <Jan_w> SyntaxNinja: or ISP's with I pay anyway
16:49:43 <SyntaxNinja> nono, so spammer A sends you a spam with GoodGuyB's address (which happens pretty often)
16:49:49 <SyntaxNinja> you dohn't know goodguy B, so it bounces to him
16:49:53 <SyntaxNinja> now he has to deal with YOUR spam.
16:49:54 <SyntaxNinja> not exactly fair.
16:50:58 <Jan_w> SyntaxNinja: i must admit, you have a point
16:51:11 <shapr> but if everyone uses it, no one sees it
16:51:35 <SyntaxNinja> if everyone used it, then no one would see anything. I've replied to your mails and gotten the bounce message, since you don't whitelist people you are sending mail to
16:51:36 <Jan_w> shapr: i the truth is, most people don't use it :)
16:51:39 <SyntaxNinja> but I love you anyway :)
16:52:05 <shapr> yah, I really should whitelist people I send to...
16:52:16 <shapr> sadly, all the swedish ISPs block port 25 outgoing
16:52:33 <shapr> and I haven't gotten around to doing SMTP via ssh or so
16:52:49 <Jan_w> shapr: heh, well it's REALLY easy
16:53:02 <Jan_w> i use ssh tunnels every day
16:53:11 <SyntaxNinja> shapr: you should just tell programmer that you still want the $100 :)
16:53:12 <shapr> to send email?
16:53:48 <Jan_w> shapr: to send email, to proxy my www, to connect to remote sql servers, etc etc..
16:55:08 <Jan_w> shapr: for starters, just use putty, and forward some localhost ports to a remote port... like localhost:25 -> somehost:25 
16:55:39 <Jan_w> and log in to someotherhostthatallowssshrelays
16:55:57 <Jan_w> set you're email client to localhost, and you're done
16:56:16 <Jan_w> 1 catch: you have to login before you can send email
16:56:38 <shapr> I use ssh-agent, so maybe I wouldn't have to login.
16:57:19 <Jan_w> ofcourse that could be delt with with the right software..i dunno what ssh-agent is, is maybe that would work
16:57:24 <Jan_w> shapr: got my email ?
16:57:59 <shapr> yes, looking at it now
16:58:24 <SyntaxNinja> how long was that guy hanging out here?
16:58:46 <Jan_w> it's the same allright, but if they wanted to teach vb programmers haskell, they could have used it
16:59:32 <Jan_w> call me gullable, but I don't dismiss the possibility that he's for real
17:00:12 <monochrom> vb people can take anything as long as it's .net
17:00:13 <Jan_w> why else go through so much trouble, for just such a simple assignment
17:00:31 <shapr> Jan_w: if he's for real, why would his spec quote so much of this assignment *and have the same deadline* ?
17:00:54 <Jan_w> true
17:01:09 <shapr> I just might be able to believe the quoted spec, but when he gave the same deadline, my bullshit meter choked to death
17:01:10 <Jan_w> oh well, w'll see
17:01:44 <Jan_w> weirdshit-o-meter [----!
17:02:26 <Jan_w> it's broken now.. normally looks like this: [--O---]  :)
17:04:46 <Jan_w> pff
17:05:00 <shapr> Jan_w: for more suspicious behaviour, this ms.doc file does not have any creator info
17:05:20 <shapr> but does have total editing time of one hour, thirty minutes, zero seconds.
17:06:13 <shapr> Jan_w: cute meter :-)
17:06:19 <Jan_w> well, i said it earlier, but this time i'll not lying
17:06:24 <Jan_w> good night :)
17:06:26 <shapr> g'night
17:06:30 * shapr goes to sleep also
17:06:45 <mento> good night
17:10:56 <SyntaxNinja> night shapr
17:11:04 <SyntaxNinja> night Jan_w
17:15:49 <mento> And look what I found. Solutions to exercises from THE book: http://www-lehre.inf.uos.de/~rfreund/craft_functional_programming
17:20:55 <monochrom> you will ace the exam.
17:21:36 <SyntaxNinja> cheaters never win... except in every way our society is structured ;)
17:21:42 <mento> hehe
17:22:04 * SyntaxNinja just barely avoids mentioning george bush
17:22:35 <monochrom> Just reading the solutions is already eye-opening.  "Wow I didn't know you could do *that* in Haskell!"  That is a good thing.
17:22:39 <Etaoin> or rather, doesn't avoid?
17:23:14 <SyntaxNinja> Etaoin: details ;)
17:23:35 <SyntaxNinja> at the time I typed "avoids" I still hadn't mentioned him
17:23:45 <mento> lol monochrom
17:55:36 <dons> good morning #haskell
17:56:08 <SyntaxNinja> hi dons
17:59:59 <dons> haskell makes me happy :)
18:00:18 <SyntaxNinja> dons: yay!
18:00:58 <dons> hehe
18:36:06 <mento> peace
19:32:27 <heatsink> I'm getting this type error when I rename a function... http://www.rafb.net/paste/results/EqnOht77.html
19:32:44 <heatsink> The top three lines compile, the bottom four lines won't
19:33:02 <heatsink> the assignment to y on line 7 produces an error
19:33:16 <heatsink> Why does haskell type this way?
19:35:17 <dons> t.hs:6:22:
19:35:17 <dons>     Couldn't match `Integer' against `Int'
19:35:18 <dons> ?
19:36:31 <heatsink> right
19:36:43 <dons> add -fno-monomorphism-restriction
19:36:51 <heatsink> okay
19:36:56 <heatsink> can I do that in hugs also?
19:37:09 <dons> don't know. works by default in nhc98
19:37:15 <heatsink> it works in ghc as well
19:38:36 <heatsink> Hmm, it works if I first declare toInt64 :: Integral a => a -> Integer
19:38:51 <dons> yep, just add a type constraint to stop it defaulting to a monomorphic type
19:39:08 <dons> it's to stop you getting more general types (hence worse performance) than you think you're getting
19:39:21 <dons> normally noone cares, until you see this kind of situation
19:39:30 <heatsink> oh, I'm glad there's a reason for it behaving this way
19:41:16 <dons> see the haskell98 report. slightly controversial
19:41:17 <dons> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
19:45:20 <heatsink> I never knew that I could write (,,) Int Int ([] String) as a type.
19:45:36 <dons> you can?
19:45:50 <heatsink> yup, it's in the haskell98 report.
19:45:51 <dons> looks like a sort-of Core type
19:46:00 <dons> it's just type application syntax, yeah?
19:46:24 <heatsink> yea
19:46:36 <dons> [] String is how it looks in ghc, if you use -fext-core and friends
19:46:47 <heatsink> hm
19:46:55 <Helicopter> what is "[] String" ?
19:47:00 <dons> [String]
19:47:06 <Helicopter> oh
19:47:24 <dons> [] type constructor applied to String type
19:47:34 <Helicopter> yeah it makes sense
19:47:54 <Helicopter> so is [String] syntactic sugar ?
19:48:32 <dons> hmm.. it would certainly be desugared to: [] String internally, so I guess it is sugar
19:49:24 <Helicopter> do greencard and hsc2hs serve the same purpose ?
19:49:52 <dons> nope. . 
21:21:27 <tuomov> hmm.. tmda only seems to send a message asking to send another message to an address given in the confirmation request..
21:21:35 <tuomov> Spammers will easily script their replies to that
21:21:50 <tuomov> What needs to be done is sent a challenge that only a human can answer
21:22:02 <tuomov> e.g. one of those images with obfuscated text
21:23:15 <tuomov> computational problems are not a solution either, because spammers have an armada of rooted windows boxes available to them
21:31:34 <dons> use aalib to encode some obfuscated text
21:33:24 <tuomov> aalib might indeed defy traditional ocr algorithms, at least for a while
21:34:35 <heatsink> oh, that's cool
21:34:54 <heatsink> That might come in handy for my curses-based HTML renderer ;)
21:37:53 <dons> tuomov: ps. some more polish on riot-hsplugins sent earlier today
21:38:02 <tuomov> yes, I applied them
21:39:13 <dons> ah yes. I see. I'm quite happy with this framework now. e.g. the Config.hs I toyed with shows the power of an expressive configuration language
21:39:43 <tuomov> I think we still need the riot binary to be a stub loader for all, config, ginsu and riot packages
21:40:17 <tuomov> I don't like loading stuff twice :)
21:40:47 <dons> sure. that's a fairly significant restructure probably -- i'll leave that to you
21:40:59 <tuomov> yeah, I'll probably do it one of these days
21:41:19 <dons> ghci follows this model. you rairly link in "(static)" modules, as it calls them
21:41:24 <dons> rarely
21:41:25 <tuomov> hmm.. cool.. apt-get install bb
21:43:01 <dons> and i'd like a keybinding to Main.reload, too, please :)
21:43:19 <dons> (though maybe I've spent too much time on riot-hacking for this month)
21:45:39 <dons> tuomov: my motivation. I originally wrote hs-plugins so I could use Haskell as the config language for a haskell-mutt
21:45:53 <dons> which I never got around to writing, in the end. hs-plugins took all my time
21:46:06 <tuomov> heh.
21:46:08 <dons> so riot was 85% of the way to haskell-mutt, it seems
21:46:55 <dons> I might yet do some profiling of riot. I have a suspicion if we used a Alex-generated lexer on the mboxes, we'd have a performance win
21:47:44 <tuomov> well, I haven't seen any performance problems yet with my db
21:48:09 <dons> no. it's got a very zippy ui, too.
21:48:10 <tuomov> and I think they're going to happen in the threading algorithm before anything else
21:48:45 <dons> hmm. well, -prof -auto-all is the way to find out :)
21:53:12 <dons> hmm. it may not be that much of a reorganisation. just load -package riot. jump to Main.main..
21:56:26 <tuomov> hmm.. or one might have all the hs-plugins stuff in the stub
21:56:32 <tuomov> and it would then pass the config to the real main
21:57:18 <tuomov> that way there could quite modularly be another main for those users who do not want to start compiling hs-plugins
21:57:29 <dons> that's even nicer
21:57:50 <dons> this is probably the general way to structure runtime-Haskell style programs
21:58:10 <dons> just a quick boot stub, then jump into the dynamic code
21:59:39 <dons> ok, so maybe I'll have a go at this tonight
22:02:48 <tuomov> there's the issue of command line parameters to the stub
22:03:17 <tuomov> if it didn't take any parameters, it could pass the config as IO ConfigAPI or something like that and then the real main would only load the config after it has processed command line parameters
22:03:24 <tuomov> but there's the -B now
22:03:48 <tuomov> so either command line processing should be in the stub (which would duplicate it) or the real main should be aware of this option
22:04:53 <tuomov> or hmm.. maybe getOpt allows removing recognised options, and the remaining could be passed to the real main along with the config
22:05:36 <dons> yes. that sounds reasonable. ghc's rts does this with +RTS flags
22:06:26 <tuomov> at least it returns a list of unrecognised options, but doesn't specify what exactly is there
22:06:56 <dons> so, how about Boot.hs does all hs-plugins specific stuff, and we use --main-is Boot.main when WITH_PLUGINS=1
22:07:43 <tuomov> --main-is?
22:07:50 <tuomov> ah, ghc option
22:07:59 <tuomov> but yes, something like that
22:08:41 <tuomov> that Boot.hs should be quite generic code
22:10:08 <dons> maybe need a normal Main.main, that uses import Config.hs to configure the global vars, and Main.dynamic_main that gets Config.hs from Boot.main
22:10:57 <tuomov> just Riot.main :: IO ConfigAPI -> [String] -> IO ()
22:11:17 <tuomov> then BootHS.main and BootNoHS.main
22:12:08 <tuomov> or something like that
22:12:24 <dons> ok. BootHS.main, BootHS.dynamic_main, and we use --main-is to distinguish which main to use, and they both call Riot.main
22:12:45 <dons> so Boot.hs contains the code for either using static Config.hs, or the dynloaded one
22:13:47 <dons> Boot.hs could be generic to almost any application of this style.
22:13:52 <tuomov> yes
22:13:58 * dons :)
22:14:24 <dons> ok. I'll proceed with this model
23:47:06 --- topic: '["Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - http://www.cis.upenn.edu/proj/plclub/contest/results.php#first"]'
23:47:06 --- topic: set by shapr on [Tue Sep 21 09:26:31 2004]
