00:00:09 <yaarg> and a2 > b1?
00:00:38 <heatsink> should be 'or'... but otherwise, you've got it.
00:00:44 <heatsink> Good work.
00:01:01 <yaarg> wow, thanks for helping
00:01:02 <yaarg> !
00:01:06 <yaarg> much apperciated
00:01:20 <heatsink> np ^_^
00:01:27 <yaarg> that shoudln't have taken me so long :(
00:01:43 <heatsink> what time is it?
00:01:49 <yaarg> 8.01am
00:01:57 <yaarg> (in the uk)
00:04:01 <yaarg> !( b2 < a1 or b1 < a2 ) returns true if the intervals intersect right? 
00:04:16 <heatsink> yes
00:04:21 <yaarg> woah
00:04:26 <yaarg> that was a good way of working it out
00:05:27 <heatsink> In math, you can definitely be more confident of your results when you figure out the right approach.
00:06:02 <heatsink> nighty.
00:06:05 <yaarg> nn
00:06:19 <heatsink>  /quite
01:01:19 * shapr yawns
01:01:37 <shapr> Good Morning #haskell!
01:01:40 <shapr> wazzup?
01:02:35 <ikegami--> yey
01:03:25 <Amadan> hello... after a longish pause, i return to haskell
01:03:34 <Amadan> and of course i have questions :)
01:03:37 <ikegami--> welcome back!
01:03:54 <Amadan> i'm trying to hack up a parsec parser
01:04:13 <shapr> Hiya Amadan! How's unicycling?
01:04:29 <Amadan> and i want a combinator like string "keyword", but case-insensitive
01:04:43 <Amadan> shapr: not good - chronic deficiency of time
01:04:53 <shapr> oh, I understand.
01:05:12 <shapr> @index istring
01:05:12 <lambdabot> bzzt
01:05:23 <shapr> hm, I thought there was an istring
01:05:26 <shapr> but maybe I wrote it myself.
01:05:36 <shapr> ah yes
01:05:42 <Amadan> shapr: i should prolly bring it to work, maybe then i'd get some cycle time...
01:05:45 <Amadan> :)
01:06:20 <shapr> Amadan: http://thunderbird.scannedinavian.com/~shae/ParsecTools.hs
01:06:58 <Amadan> :) thanks!
01:07:09 <shapr> I submitted those small extensions to Daan for inclusion into Parsec, and he seemed interested, but I don't think there's been a new release of Parsec in a geological age.
01:07:56 <shapr> I do like unicycling for mental relaxation. I got some new unicycle clothing yesterday that I haven't had the opportunity to try yet.
01:08:22 <Amadan> when you say unicycle clothing, i get funny pics in my brain
01:09:19 <shapr> In this case it's funny-looking soft padded thermal trousers like skiers use, and leg armor that covers my calf.
01:09:49 <Amadan> well, a uni with a pullover is a funnier pic :)
01:09:59 * shapr laughs
01:10:02 <Amadan> s/pullover/turtleneck/
01:10:23 <shapr> good point!
01:11:27 <Amadan> mmmmm.... leg armour.... (promise of a heaven to a uni rookie)
01:13:14 <shapr> My uni has spiked pedals for use in mud or snow, those can make holes in ankles. Especially when I try some of the crazier stunts.
01:13:45 <Amadan> getting *on* one is a crazier stunt where i cycle. :/
01:13:48 <shapr> Amadan: if you get bored and have lots of extra time, and want to watch some unicycling films: http://thunderbird.scannedinavian.com/~shae/unifilms/
01:14:30 <shapr> I've been working on using only one foot, idling, jumping, and more.
01:14:42 <Amadan> sure! ...oh great, now i can't wait for the lunch-break...
01:14:45 <shapr> :-)
01:16:23 <Amadan> is the guy in yogi.jpg really doing what i think he is? i mean levitating 20 ft from the ground? or just having a bit of a jump?
01:17:38 <shapr> He's just jumping down.
01:17:59 <Amadan> oh. okay then.
01:18:23 <shapr> He didn't actually land well enough to continue unicycling on that try, but he got it the next time he tried.
01:19:12 <Amadan> :) i mean, i can't jump on my (much better amortised) feet from half that height... i mean, i could, but only once.
01:19:42 <shapr> heh
01:19:48 * Matt-W waves
01:19:55 <shapr> hiya Matt-W 
01:21:08 <Matt-W> hi shapr
01:21:22 * Matt-W has a mad project he wants to do
01:21:27 <shapr> With my uni, I can only drop off a curb or slightly higher. That's it for me.
01:21:28 <shapr> Matt-W: what is it?
01:21:39 <Matt-W> It's probably been attempted before
01:21:58 <Matt-W> but some side of me fancies attempting to write a syntax-directed editor for haskell
01:22:19 <Matt-W> in Haskell, of course
01:22:55 <shapr> I don't know if anyone has tried it before. It definitely sounds like a fun project.
01:23:08 <Matt-W> well there doesn't seem to be anything on haskell.org about it
01:23:19 <Matt-W> I think the language syntax is mostly suitable for it
01:23:47 <Matt-W> I need to talk to a friend of mine, he wrote a syntax-directed editor for his final year compsci project, might be able to give me some pointers
01:26:00 * Matt-W sends email
01:27:45 <Matt-W> I think it's particularly important for me, as the only decent Haskell editor I've ever run into was haskell-mode for Emacs, and I can't use emacs anymore since I learned vim, I get too confused
01:30:07 <musasabi> home
01:32:09 <shapr> I like bringert's flashcard PalmOS app. It's good for studying languages.
02:03:50 * dblhelix is away: brb
02:33:40 * dblhelix is back (gone 00:29:50)
02:59:51 <vincenz> shapr: !
02:59:52 <musasabi> Is it possible to make all instances of typeclass X instances of typeclass Y?
03:00:12 <wli> yes
03:00:31 <wli> instance X t => Y t where ...
03:02:27 <Amadan> i have one more parsec question:
03:03:06 <musasabi> hmm that seems to need -fallow-undecidable-instances (or am I doing something wrong) ?
03:03:34 <musasabi> "instance Num t => Get_C t where ..."
03:05:51 <Amadan> how can i get the (set/get/update)State to work with input loaded from a file? i have:  do { contents <- readFile file; result <- runParser p (MyState []) file contents; case result of { Left err -> print err; Right xs -> print xs } }
03:06:14 <Amadan> it complains: Couldn't match `IO' against `Either ParseError'
03:15:47 <TheHunter> @type Text.ParserCombinators.Parsec.runParser
03:15:49 <lambdabot> Text.ParserCombinators.Parsec.runParser :: forall a tok st.
03:15:49 <lambdabot> 					   Text.ParserCombinators.Parsec.Prim.GenParser tok st a
03:15:49 <lambdabot> 					   -> st
03:15:49 <lambdabot> 					      -> Text.ParserCombinators.Parsec.Pos.SourceName
03:15:49 <lambdabot> 						 -> [tok]
03:15:50 <lambdabot> 						    -> Either
03:15:52 <lambdabot> 							   Text.ParserCombinators.Parsec.Error.ParseError
03:15:54 <lambdabot> 							   a
03:16:19 <TheHunter> Amadan, try let result = runParser ...
03:17:18 <Amadan> hmmm... thanks... at least it's a different error :)
03:17:37 <Amadan> it complains that it wants a Token, not a MyState as #2
03:18:47 <Amadan> i obviously don't understand the state example in parsec manual
03:18:54 <Amadan> back to the drawing board
03:20:24 * TheHunter can't concentrate atm because there is some japanese girl in the same room doing voip and he's just to polite to tell her to stfu.
03:21:19 <wolfman8k> schlieBen Sie das Bumsen!
03:22:21 <TheHunter> hmm, wolfman8k  i'm afraid that means something different...
03:22:39 <wolfman8k> oh?
03:22:47 <xerox> hello!
03:22:54 <wolfman8k> @info CCall
03:23:04 <wolfman8k> @type CCall
03:23:04 <TheHunter> bumsen = to hump
03:23:05 <lambdabot> bzzt
03:23:13 <wolfman8k> TheHunter: hm?
03:24:40 <TheHunter> wolfman8k: sure
03:24:47 <wolfman8k> TheHunter: so what does it mean?
03:25:37 <TheHunter> y'know f**k
03:25:53 <wolfman8k> i mean what does the phrase i said mean?
03:26:45 <TheHunter> something like "close the humping"
03:27:11 <wolfman8k> schlieBen Sie das Bumsen? <- "close the humping" ?
03:28:53 <TheHunter> well, it's not 100% perfect german, but i guess it'd be understood someway like that.
03:29:10 <wolfman8k> hm...
03:29:19 <wolfman8k> say it to her anyway
03:30:07 <wli> Is there an AOL Instant Messanger client in Haskell yet?
03:30:53 <wli> +written
03:33:18 <TheHunter> Amadan, let result = runParser p (MyState []) "foo" contents
03:39:09 * TheHunter is away: lunch
03:39:33 <Muad_Dibber> good morning all
03:40:25 <musasabi> morning (or lunch)
03:40:38 <Muad_Dibber> hehe
03:40:42 <Muad_Dibber> it is lunch time
03:40:49 <Muad_Dibber> but since i'm a lazy guy i just got up ;)
03:43:42 <xerox> .
03:43:44 <xerox> wops.
03:44:02 <Amadan> thanks, hunter
04:00:28 <musasabi> Hmm how can I type the following:
04:00:56 <musasabi> foo :: Eq a => a -> a -> Bool
04:01:30 <musasabi> bar = foo (Right "bar") fun
04:01:44 <musasabi> if fun is polymorphic..
04:02:32 <earthy> bar = (foo (Right "bar") fun)::Either a String -> Either a String -> Bool
04:03:14 <aleator> Anyone have example code with ForeignPtrs ?
04:05:15 <musasabi> aleator: e.g. darcs FastPackedString
04:10:24 * TheHunter is away: back
04:10:29 * TheHunter is away: back
04:10:33 * TheHunter is back (gone 00:00:04)
04:37:29 <eixei> heya guys
04:38:03 <xerox> yo
04:38:06 <eixei> wow, this channel gets bigger everytime I join
04:38:10 <aleator> musasabi: Thanks.
04:38:52 <eixei> has anyone in here implemented a TM simulator in haskell? *g*
04:40:02 <tromp> http://www.cs.mu.oz.au/330/project/tm.lhs
04:40:11 <eixei> cool :-)
04:40:44 <eixei> thanks tromp 
04:45:09 <aleator> More confusion with foreignptrs. How wrong is this: http://www.cc.jyu.fi/~aleator/snippet? 
04:46:51 <musasabi> That seems ok.
04:47:00 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/qdbm/Depot.hs is an another example.
04:52:12 * musasabi has some patches for MissingH..
04:54:35 <aleator> musasabi: thanks
05:10:32 <aleator> Is it safe to use unsafePerformIO with code that allocates stuff (in c) and creates foreignPtrs?
05:17:40 <musasabi> that sounds nasty - can you give an example?
05:24:09 <aleator> musasabi: I was thinking along the lines of adding unsafePerform to "newPath" in my previous snippet. 
05:26:36 <musasabi> aleator: that is not good design.
05:26:46 <musasabi> aleator: because identity is important.
05:26:58 <musasabi> aleator: why do you think e.g. newIORef is in IO?
05:28:49 <aleator> musasabi: suppose I was implementing, say matrices and operations, in C. could I produce haskell api that is outside IO? 
05:29:18 <musasabi> yes. if you knew what you were doing.
05:29:44 <musasabi> if you have mutating operations then identity is important and you want to keep creation inside IO.
05:31:01 <aleator> There are no mutating operations here.
05:31:27 <musasabi> aleator: if newFoo is pure then "myFun (newFoo 1) (newFoo 1)" can be rewritten as "let foo = newFoo 1 in myFun foo foo"
05:32:08 <aleator> musasabi: yes. Can it be pure if value of newFoo is something allocated in c?
05:32:49 <musasabi> yes that should be fine if you are really sure that the api is pure.
05:34:22 * dblhelix is away: ...
05:35:06 <aleator> I'm quite certain. I'm just storing things colours and readymade paths. Both of which are just collection of unchangeable values.
05:47:12 <musasabi> Please notify CosmicRay about http://www.cs.helsinki.fi/u/ekarttun/haskell/missingh.diff when he comes to irc (I will maybe be up later in the night again)
05:52:28 <np_hard> is this function in the haskell library anywhere? given a predicate p and a list of as, return ([a], [a]), where the first list are the elements of the list where p is true, and the second list where p is false
05:54:17 <np_hard> yep, looks like it
05:54:19 <np_hard> thanks :)
06:09:58 <Igloo> musasabi: It's normal to use otherwise rather than True in guards
06:30:10 * wli hunts for a usefully-packaged curses lib
06:34:44 <Darius> Don't you have one Igloo?  (Though perhaps not "usefully-packaged")
06:37:01 <Igloo> I do, if you're willing to restrict yourself to where TH works (although you can just get it to dump the code to a .hs file somewhere TH works for elsewhere). And not cabalised yet or anything, no
06:37:29 <wli> Igloo: I'm interested.
06:37:38 <wli> Igloo: What's "cabalised" ?
06:37:57 <Igloo> Was just finding the URL... http://urchin.earth.li/darcs/ian/hcurses
06:38:09 <Igloo> I assumed that's what "usefully-packaged" meant
06:38:21 <Igloo> http://www.haskell.org/cabal/
06:44:23 <Igloo> [13:46] < musasabi> Please notify CosmicRay about 
06:44:23 <Igloo>                     http://www.cs.helsinki.fi/u/ekarttun/haskell/missingh.diff 
06:44:23 <Igloo>                     when he comes to irc (I will maybe be up later in the night 
06:44:26 <Igloo>                     again)
06:45:40 <CosmicRay> thanks igloo
06:49:15 <CosmicRay> who is musasabi in real life?
06:49:51 <Igloo> Einar Karttunen, says whois
06:50:20 <lmbdwar> lo
06:50:51 <CosmicRay> ah.  silly me, thanks.
06:59:58 <shapr> vincenz!
07:00:55 <shapr> I am so tired my teeth hurt.
07:01:07 * shapr wonders if this happens to other people.
07:02:14 <CosmicRay> my head hurts if I don't get enough sleep
07:02:22 <CosmicRay> don't recall any teeth issues
07:02:26 <aleator> shapr: it does.
07:02:50 <CosmicRay> shapr: there's some stuff for you to darcs pull, btw
07:02:52 <shapr> It's weird because my teeth don't have any nerves, and they don't hurt in any other situation.
07:02:55 <shapr> awright, spiffy
07:03:44 <shapr> did you apply all my changes?
07:03:52 <shapr> I bet I can find this out myself somehow.
07:04:13 <shapr> aleator: I'm glad I'm not alone in the painful sleeplost teeth =)
07:04:36 <CosmicRay> shapr: I did
07:04:40 <Igloo> pull, then see if send wants to do anything
07:04:55 <shapr> ah, ok
07:04:59 <CosmicRay> shapr: I also added a little script that will darcs pull changes from both our repos
07:05:09 <CosmicRay> since I'm prone to forget both our urls :-)
07:05:10 <Igloo> Or I think you can do it without pulling by doing some sort of compare, but I forget how
07:05:19 <shapr> aha
07:05:21 <shapr> CosmicRay: neat
07:05:23 * Igloo wonders what it is that is being pulled, anyway
07:05:41 <CosmicRay> Igloo: http://darcs.complete.org/haskell-v8
07:05:55 <shapr> It's CosmicRay's Haskell book.
07:05:56 <Igloo> v8? I thought we were still working on 2  :-)
07:06:00 <Igloo> Ah
07:06:04 <CosmicRay> the "haskell for hackers" preliminary doc I mentioned in cafe the other day
07:06:27 <CosmicRay> Igloo: we're way ahead of you :-)
07:06:55 <shapr> The v8 part is quite cute, since the central analogy is Haskell as a 1971 Chevy Nova. As opposed to a 1983(?) fuel injected something.
07:07:09 <CosmicRay> pontiac 6000.
07:07:24 <CosmicRay> (1986) :-)
07:08:02 <shapr> Since I'm from Alabama, that makes a lot of intuitive sense to me. Birmingham, Alabama has the second highest ratio of cars per human.
07:08:09 <CosmicRay> heh
07:08:13 <CosmicRay> what's #1?
07:08:21 <shapr> Atlanta, Georgia is number one, but it doesn't beat Birmingham by much.
07:08:28 <CosmicRay> I wondered if it was atlanta
07:08:55 <CosmicRay> how did you get from .al.us to .se?
07:10:02 <np_hard> well
07:10:22 <Darius> Hey shapr, did you get that link I threw at you the other day?
07:10:24 <shapr> While growing up, I worked on 1980(?) Jaguar, 1940 Cadillac, 1973 Corvette, 1970 Ford Truck, 1978 Ford Fiesta, 1943(?) Austin-Healey, 1947 Dodge Truck, 1978 Dodge Van, and several others that I can't bring to mind at the moment.
07:10:27 <np_hard> I can't believe that I have made up a new useful HOF, so someone tell me which functions in the standard library do what I am doing.
07:10:31 <CosmicRay> wow.
07:10:36 <np_hard> is there a pasteboard?
07:10:44 <shapr> @wiki HaskellIrcPastePage
07:10:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:11:10 * Darius smiles at having thought up the obvious
07:13:08 <shapr> I've pulled/repaired/replaced transmissions, differentials, driveshafts, various flavors of shocks, brakes, tires, rims, starters, carborateurs, made minor repairs to control and power harnesses, worked with 6v and 12v electrical systems, etc etc
07:13:27 * CosmicRay is not very good at working with cars
07:13:33 <shapr> I got *really* tired of looking under the hood of a car. I no longer own a car, and haven't owned one in several years.
07:13:43 <wli> np_hard: HOF?
07:13:50 <CosmicRay> I wish I lived somewhere where I had no need for a car
07:13:52 <np_hard> higher order function
07:13:53 <wli> expand that acronym
07:13:55 <wli> ah
07:14:03 <np_hard> unravel :: (a -> Bool) -> [a] -> ([[a]], [[a]])
07:14:09 <wli> what's it do?
07:14:13 <np_hard> ravel :: [a] -> ([[a]], [[a]]) -> [a]
07:14:13 <shapr> CosmicRay: Come to Sweden, we have mass transportation and gorgeous blonde chix.
07:14:25 <np_hard> look at the paste page, I have posted the code
07:14:39 <CosmicRay> <g>
07:14:51 <np_hard> it arose from noting that "words" and "unwords" are not reciprocals
07:15:17 <np_hard> inverses?
07:15:18 <np_hard> whatever
07:15:45 <wli> np_hard: not clear to me what it does
07:15:51 <Igloo> Do you really mean [zero] not repeat zero?
07:16:15 <wli> I have a small lib of HOF's I use
07:16:18 <shapr> CosmicRay: On the downside, taxes here are stultifying.
07:16:20 <wli> it has crud like intertwine = ((concat.).) $ flip $ zipWith (flip (:) . (:[]))
07:16:27 <Igloo> When are these functions useful?
07:16:33 <np_hard> look at main
07:16:42 <shapr> is intertwine /= intersperse?
07:16:44 <np_hard> example, capitalizing every word in a string
07:16:49 <CosmicRay> shapr: yeah, but our president is Bush, so I think you're still better off :-)
07:16:53 <wli> shapr: yes
07:16:54 <np_hard> but preserving the whitespace that was there
07:17:05 <wli> @type ((concat.).) $ flip $ zipWith (flip (:) . (:[]))
07:17:06 <lambdabot> ((concat.).) $ flip $ zipWith (flip (:) . (:[])) :: forall b.
07:17:06 <lambdabot> 						    [b] -> [b] -> [b]
07:17:38 <shapr> np_hard: I also wish that (unwords . words) == id and same for un/lines.
07:18:04 <np_hard> that's what these do
07:18:11 <shapr> can you build them with foldr and unfoldr?
07:18:23 <np_hard> since we need purity, we have to pass the spaces as parameters and return values
07:18:26 <Igloo> shapr: I thought it was right that way round
07:18:38 <Igloo> Oh, no
07:18:55 <shapr> well, I wish they were always inverses of each other.
07:19:04 <wli> I have stuff like twine f g (x:xs) = f x : twine g f xs too
07:19:07 <shapr> (unwords . words) == (words . unwords) == id
07:19:29 <shapr> wli: do you have this lib online? I'd like to look at it.
07:19:56 <wli> http://holomorphy.com/~wli/public_html/scripts/Util.hs
07:20:23 <shapr> And if it's explicitly BSD licensed, I might be able to sneak it into CosmicRay's ExtraH lib.
07:20:46 <shapr> http://holomorphy.com/~wli/scripts/Util.hs
07:21:03 <wli> shapr: thanks; there's no license. I consider it "public domain"
07:21:30 <CosmicRay> shapr: indeed you might
07:21:30 <shapr> I think debian packages require explicit licensing.
07:21:38 <Darius> What the heck do you use twine for?
07:21:39 <wli> shapr: I can drop in a statement to that effect plus some "choose your own license out of several free ones" also.
07:21:43 <shapr> I wonder, does debian accept explicitly PD licensed code?
07:21:45 <CosmicRay> wli: If you place an explicit statement in there saying that, we could take it
07:21:55 <np_hard> shapr: look at the bottom of the paste page, i have wordsAndSpaces and unwordsAndSpaces which are ID, I believe
07:21:57 <CosmicRay> shapr: we do, but we have to know that it's public domain
07:21:59 <wli> Darius: I had a use for it when I devised it.
07:22:05 <np_hard> it behaves as I expect so far
07:22:28 <Igloo> You don't actually need the statement to be in the code, but it's nice
07:22:29 <wli> np_hard: what's an example of using ravel?
07:22:39 <CosmicRay> right
07:22:45 <np_hard> wordsAndSpaces and unwordsAndSpaces :
07:22:49 <np_hard> I updated the paste page
07:22:50 <wli> np_hard: thanks
07:22:51 <shapr> I'm always impressed by how much of my code turns into special or general cases of Prelude functions. I am regularly amazed at how much the Prelude can do.
07:22:54 <np_hard> unwordsAndSpaces wasn't there
07:23:25 <np_hard> i am just wondering if ravel / unravel has simpler implementations with prelude functions
07:23:51 <shapr> what about unfoldr?
07:24:20 <shapr> I think splitting a list by item can be done with unfoldr.
07:24:35 <shapr> I don't think you can split a list by several items at once with unfoldr.
07:25:06 <shapr> for example, 'split " - " "wubba - blubba - snubba"'
07:25:42 * shapr never did finish that unfoldr blog entry.
07:25:46 <np_hard> i was looking at something with unfoldr, inits or something
07:26:07 <np_hard> the big thing was the [a] -> [[a]] by groups
07:26:48 <np_hard> or from a string to a list of strings
07:26:50 <wli> shapr: http://holomorphy.com/~wli/public_html/scripts/Util.LICENSE
07:27:29 <wli> the one I've gotten the most mileage out of is cantor
07:27:45 <wli> cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs)
07:29:38 <wli> e.g. infiniteIntersect xs ys = map fst . filter (uncurry (==)) . cantor $ [[(x,y) | x <- xs] | y <- ys]
07:29:47 <CosmicRay> @index maybe
07:29:47 <lambdabot> Data.Maybe,Prelude,Maybe
07:33:11 <Darius> shapr: assuming the answer was no to my earlier question, here's the link again http://www.eecs.harvard.edu/~mdw/papers/regiment-dmsn04.pdf
07:36:12 <wli> shapr: intertwine takes 2 lists and the even elements of the result come from the first, and the odd elements of the result from the 2nd
07:36:33 <wli> even starts at 0
07:36:35 <shapr> ah, I see.
07:36:42 <shapr> Darius: thanks
07:36:59 <shapr> bringert: hey, flip is great, though there's some sort of infinite loop when using the scrollbar
07:37:19 <musasabi> evening
07:37:26 <shapr> hei musasabi 
07:37:53 <musasabi> hej shapr
07:38:06 <shapr> bringert: is it hard to read from a certain category of notes for the vocab pairs?
07:38:07 <bringert> shapr: I thought I had fixed that
07:38:30 <bringert> you mean the build-in PalmOS concept of categories?
07:38:39 <wli> shapr: intersperse x xs = tail $ intertwine (replicate (length xs) x) xs
07:38:41 <shapr> right
07:38:43 <bringert> shapr: which version do you get the scrolling loop in?
07:38:51 <shapr> um, I think the latest?
07:38:55 * shapr checks
07:39:03 <bringert> category support that should be easy enough
07:39:10 <bringert> how do you propose to use it?
07:39:47 <np_hard> wait a minute
07:40:21 <wli> (but only fot finite lists)
07:40:47 <wli> for infinite lists you get tail $ intertwine (repeat x) xs
07:41:35 <np_hard> nm, I thought List.groupBy could help in making unravel/ravel irrelevant, but it can't.
07:41:42 <Darius> When Google Desktop can index PDF and PS files, I will be much happier.  Also a linux version would be nice.
07:42:15 <Darius> Now someone here go make that happen.
07:43:02 <earthy> darius: have you heard about ht://Dig and pdf2text and ps2text?
07:43:20 <earthy> that gives you a fair approximation of what you want
07:43:44 <Darius> The latter two yes.  The first maybe, but recall nothing so let's say no.
07:44:26 <Darius> earthy: I've thought of that, but I don't really want to keep the text files around (I'm not sure how big they all would be) and it takes a -really- long time to convert them.
07:44:43 <musasabi> Why is Control.Monad.Error's mplus counterintuitive ?
07:45:10 <Darius> What does it do?
07:45:36 <musasabi> Darius: m `mplus` n = m `catch` \_ -> n
07:46:10 <Darius> What's the other option?
07:46:15 <Igloo> Why is that counterintuitive?
07:46:22 <Igloo> Note that's for IO only
07:46:39 <musasabi> use the original error if the second computation is not successfull
07:47:08 <Igloo> You'd have ot jump through hoops to do that
07:47:13 <shapr> bringert: I can't find a version other than in the Info section of the main palm thingy, which says v0.0
07:47:41 <Igloo> And it's not obviously better
07:48:10 <shapr> bringert: I take notes in swedish class where I define words and their definition. If flip could read from a notes category, then I could test myself on my notes immediately after entering them.
07:48:14 <Darius> Yes, the problem is that the answer is really "both" exceptions.
07:49:07 <Darius> I note this very cryptically and indirectly in the MonadError wiki page.
07:49:10 <wli> shapr: are you doing hircules?
07:49:49 <shapr> bringert: the only disadvantage I can see is that a single note has a pretty small max size, but if flip could transparently use all the separate notes in one category, that wouldn't be a problem
07:49:55 <shapr> wli: nah, juhp does hircules.
07:51:09 * shapr tries to build flip
07:51:19 <bringert> shapr: ah, now I get it
07:51:33 <bringert> btw, yeah, I should fix the verion info in the about dialog
07:51:45 <shapr> how do I get the about dialog?
07:52:02 <bringert> list view, menu, options, about
07:52:03 <bringert> I think
07:52:11 <bringert> but there is no version info there
07:52:17 <bringert> that's what I should fix
07:52:36 <bringert> so how would a note be interpreted as a set of word pairs?
07:53:12 <bringert> one pair / line, semicolon-separated or something like that?
07:53:46 <shapr> some definitions get longer than a line, maybe an ending and a word/definition separator?
07:53:46 <bringert> another cool feature (what I thought you meant at first) would be to let the words have categories
07:53:52 <shapr> word:def; ?
07:53:58 <bringert> hmm, yeah
07:53:59 <shapr> oh, that would be handy.
07:56:26 <shapr> of course, I was also trying to dream up a way to do morhpology flashcards =)
07:56:41 <wli> shapr: what kind of morphology flashcards?
07:56:59 <bringert> yeah, I have been thinking about that too
07:57:16 <shapr> I suck at conjugating swedish verbs, even though swedish is more regelbundet than english.
07:57:22 <bringert> maybe you could autogenerate cards on the desktop from a morphology
07:57:24 <shapr> um, rule bound, um, aha regular
07:58:00 <bringert> hehe, "rule bound". man, you're thinking in swedish by now
07:58:06 <wli> Igloo: will ghc-cvs in debian have what I need for curses?
07:58:09 <shapr> I've been practicing swedish all day :-)
07:58:25 <shapr> I was very amused when John Hughes had to ask you for the *english* word for "mess"
07:58:35 <Igloo> Ermm, probably. I take it 6.2.2 doesn't work then?
07:58:40 <bringert> heh
07:58:52 <xerox> xerox2, test
07:58:55 <wli> Igloo: not that I can tell
07:59:07 <tuomov> iiirc conjugations were relatively easy if you could remember the gender.. which is impossible :)
07:59:25 <bringert> btw, Markus defended his licentiate thesis today, it's about Functional Morphology and BNFC
07:59:28 <shapr> Just have to memorize gender, like in french.
07:59:51 <bringert> John started giving crazy examples of welsh morphology
07:59:56 <bringert> bizarre stuff
08:00:13 <bringert> yeah, gender in swedish is tough
08:00:35 <bringert> hard to know which gender they belong to
08:00:50 <shapr> welsh and gaelic barely have rules from what I've seen.
08:00:51 <tuomov> I've always disliked gender in the languages I've studied
08:00:58 <tuomov> (i.e. french and swedish)
08:00:59 <bringert> I am talking about words and grammatical gender, in case anyone misunderstood that last part
08:01:10 <Igloo> Looks like you're right. ghc-csv compiles it for me, though (although I have to give hsc2hs "-I .")
08:01:23 <bringert> german is bad too
08:01:29 <tuomov> yeah, but I haven't studied it
08:01:32 <shapr> I dunno, I always preferred wimmix from the international house in Birmingham.
08:02:03 <Darius> Perhaps an Error with a monoid as the error type would be appropriate, a `mplus` b = a `catch` \e1 -> b `catch` \e2 -> return (e1 `mappend` e2)
08:02:18 <shapr> People who spend time in countries other than their first country are often more interesting than those who don't.
08:02:48 <bringert> and interested
08:02:52 * shapr laughs
08:03:02 <tuomov> finnish otoh probably has zillion special case conjugations
08:03:23 * Darius is with tuomov on gender
08:03:26 <tuomov> although we do not have genders or even he/she distinction
08:03:37 <shapr> Finnish has seventeen cases, though only fifteen or sixteen are commonly used. But you can use them all at the same time. That's way scary.
08:04:00 <bringert> and apparantely about 10500 verbforms if you count some word formation morphology
08:04:03 <bringert> I heard today
08:04:05 <tuomov> it's not that multiple conjugations can be used, but there sometimes is no rule anymore to arrive at the proper form
08:04:26 <tuomov> maybe the two first letters are in common with the base form and a conjugated form
08:04:32 <bringert> what are the alternatives for space-efficient strings?
08:04:54 <shapr> I once calculated that there are 47 (49?) commonly derived forms of any given noun.
08:04:56 <musasabi> bringert: using FastPackedString from darcs is easy.
08:05:17 <wli> I've been trying to use abstract algebra and/or formal language theory to describe a more rigorous theory of patches than the darcs guy. I've not gotten very far. I probably don't know the math.
08:05:25 <bringert> musasabi: it's better than Data.PackedString?
08:05:29 <shapr> I wish we had a nice ropes implementation, but ropes is pretty close to ShowS
08:05:41 <musasabi> bringert: yep in most cases.
08:05:42 <wli> What's ropes?
08:05:45 <tuomov> I think that could be the most difficult thing for foreigners after having moved from the analytic prog^Wlanguage to synthetic language midnset
08:05:51 <shapr> um, that SGI thingy...
08:05:52 * shapr googles
08:05:57 <musasabi> wli: list of string chunks.
08:06:01 <musasabi> (or a tree)
08:06:16 <bringert> is there a library for string sharing?
08:06:35 <Igloo> Oh, speaking of packed strings, does anyone know about the code GHC generates?
08:06:43 <bringert> i.e. if there are several identical strings, you only keep one copy in the heap?
08:06:58 <bringert> Igloo: code for what?
08:07:02 <Igloo> In particular why it doesn't get near-C speed on things like endian-swapping Ptr Word32s
08:07:20 <Igloo> It's about a factor of 5 off IIRC
08:07:41 <shapr> wli: http://www.sgi.com/tech/stl/Rope.html
08:07:42 <musasabi> Igloo: it generates normal C string literials for ascii strings - otherwise it encodes them in utf-8.
08:08:03 <tromp> has anyone here got a really fast 64 bit machine?
08:08:12 <shapr> Would CSE keep only one copy of a string in the heap?
08:08:15 <Igloo> musasabi: No, I'm talking about Ptr Word32s, not Haskell Strings
08:08:40 <Igloo> shapr: Yes
08:08:45 <bringert> is FastPackedString similar in interface to PackedString?
08:08:51 <musasabi> Igloo: well the C ops probably reduce to optimized assembler for the processor..
08:08:57 <shapr> Is there a GHC switch that turns CSE on by default for either compilation or runtime?
08:09:14 <Igloo> musasabi: But GHC is going via gcc anyway...
08:09:23 * wli isn't generally very concerned about high-performance stuff in haskell
08:09:24 <Igloo> -O
08:09:35 * wli mostly wants code density for userspace
08:09:37 <shapr> oh, did you guys see the new deb that uses a genetic algorithm to evolve the set of arguments that gives the fastest code output from gcc?
08:09:50 <wli> and unless APL suddenly resurrects Haskell's where that's at
08:09:50 <musasabi> Igloo: Is the haskell implementation very different in speed vs a naive C implementation?
08:09:51 <CosmicRay> heh
08:10:00 <shapr> It claims to be generic enough to work for other languages, that would be fun to try for GHC.
08:10:01 <Igloo> musasabi: A factor of 5
08:10:07 <musasabi> hms
08:10:09 <CosmicRay> oh hey musasabi
08:10:15 <musasabi> CosmicRay: hello.
08:10:17 <CosmicRay> musasabi: I just dropped you an e-mail
08:10:31 <CosmicRay> musasabi: got your diff, applied it with some minor changes
08:10:32 <shapr> Mr. Karttunen Sir!
08:10:35 * shapr salutes
08:10:49 <CosmicRay> musasabi: and sent you what I did
08:11:03 * musasabi looks at his inbox
08:11:14 * shapr looks at lambdabot's inbox
08:11:51 <shapr> People keep trying to sell lambdabot erectile dysfunction assistance. I wonder if this causing his regular stack overflow.
08:12:07 <musasabi> CosmicRay: seems nice, true about interpolatingAccess
08:12:14 <Darius> lambdabot has an inbox?
08:12:28 <shapr> Sure, his darcs repo has its own user and email address.
08:12:30 <bringert> wli: I don't really care too much about near-C speed either most of the time, but getting memory-use down can be very important
08:12:57 <bringert> we are running into this problem where after parsing a 3M file takes up 200M memory
08:13:21 <bringert> thus the interest i space-efficient string representation
08:13:21 <wli> I don't run into trouble with that very often but my sample of tasks is relatively skewed.
08:13:26 * Igloo only cares because otherwise darcs will probably use a C SHA1 implementation, which would be a pity IMO
08:13:32 <shapr> I remember the last time a single $! took my memory usage from several gigabytes to 30 megabytes.
08:14:08 <musasabi> CosmicRay: would you like to have a go with the UDP module? I could contribute it next week (adapt the API) or just give you a link.
08:14:22 <CosmicRay> what does the UDP module do?
08:14:33 <wli> debian ghc-cvs doesn't have the gtk2 package
08:14:43 <musasabi> CosmicRay: I use it for UDP clients and servers.
08:14:52 <CosmicRay> a set of UDP utilities, basically?
08:14:56 <musasabi> yes.
08:15:02 <CosmicRay> sounds fitting
08:15:16 <CosmicRay> send me a diff or hack it up in arch and tell me where to find it
08:15:21 <CosmicRay> (do you use arch at all?)
08:15:23 <musasabi> bringert: I used the darcs string package in a few things and it works fine.
08:15:34 <Igloo> It probably ought to rebuild cleanly. Alternatively, just changing "import Language.Haskell.TH" to "import Language.Haskell.THSyntax" might be enough to make hcurses compile with 6.2.2
08:15:38 <CosmicRay> oh, what license do you have it under?
08:15:41 <shapr> Tom Lord is darcs' archenemy!
08:15:41 <musasabi> I don't currently use arch.
08:15:59 <musasabi> CosmicRay: BSD, if you want that can be released under something else too.
08:16:00 <CosmicRay> shapr: and he's also carpal tunnel's best friend.
08:16:06 * shapr snickers
08:16:22 <wli> whoa
08:16:25 <CosmicRay> musasabi: that's fine.  Just please note the license in a comment at the top of any files you add and update the COPYRIGHT file appropriately
08:16:27 <wli> hcurses is a big module
08:16:56 <shapr> Yi has some chunk of curses binding also, originally from Ginsu.
08:17:03 <Igloo> It is?
08:17:08 <shapr> actually, via Riot
08:17:16 <wli> Igloo: in terms of number of symbols exported
08:17:18 <tuomov> the module has been slightly modified in Riot
08:17:28 <bringert> musasabi: great, thanks, I'll try that
08:17:34 <shapr> right, that's why the via is good to mention.
08:17:34 <Igloo> Ah, right. Well, ncurses is a big library then  :-)
08:17:34 * Darius looked at HaskellIrcPastePage and was forced into removing extraneous parens in unravel'
08:17:43 <tuomov> there are a few additions iirc, and the version of getch in Ginsu didn't work with terminal size changes
08:17:56 <musasabi> CosmicRay: ok, I'll try to get it done tomorrow.
08:18:47 <tuomov> A standard ncurses package should perhaps be created..
08:19:06 <wli> that would help me out a bit
08:19:24 <CosmicRay> musasabi: great
08:19:27 <CosmicRay> Igloo: it is
08:19:42 <CosmicRay> tuomov: yes
08:19:49 <CosmicRay> tuomov: are you volunteering? :-)
08:20:23 <shapr> I see the need for a lot of standard packages, but I'm not willing to write them up myself :-)
08:20:54 <tuomov> I don't know if there's that much work in curses; just create a proper build system for it and wait for improvements from people
08:20:59 <shapr> I lack the focus to do so. But I seem to be able to hack on something for a few days at a time before being distracted.
08:21:13 <tuomov> but I should study how things are properly built with ghc..
08:21:25 <Igloo> I think having cabal and hackage up and working will give more focus
08:21:31 <CosmicRay> shapr: you could just send me diffs to MissingH :-)
08:21:38 <Igloo> At least one of the problems today is that the different variants are hard to find
08:22:07 <shapr> Is there a standard cabal compressed archive format?
08:22:17 <shapr> even something boring like tgz?
08:22:33 <Igloo> That's a good question. I don't think it's mentioned, but it would need to be portable enough
08:22:35 <CosmicRay> @seen syntaxninja
08:22:36 <lambdabot> I haven't seen syntaxninja
08:22:41 <CosmicRay> liar!
08:22:42 <shapr> would be nice to upload cabs to hackage and thereby create the package index
08:22:44 <musasabi> shapr: I think that is outside the spec of cabal.
08:22:47 <shapr> @seen SyntaxNinja
08:22:47 <lambdabot> I saw SyntaxNinja leaving #haskell 14 hours 40 minutes 24 seconds ago.
08:22:54 <CosmicRay> heh
08:23:00 <Igloo> .cab is probably a bad choice  :-)
08:23:01 <shapr> oh, kosmikus fixed the case sensitive issues, but I haven't applied the patches!
08:23:04 <CosmicRay> shapr: nicks are case-insensitive :-)
08:23:05 <CosmicRay> ah
08:23:12 <shapr> Igloo: oh, someone else is using that extension?
08:23:16 * shapr blinks innocently
08:23:17 <Igloo> Microsoft
08:23:20 <CosmicRay> heh
08:23:30 <shapr> Well, if they can embrace and extend, why can't we?
08:23:40 <CosmicRay> ah.
08:23:44 <shapr> oh hey, we could use the standard microsoft cab format, with OUR OWN CUSTOM EXTENSIONS!
08:23:49 <tuomov> hmm.. maybe I build system could be ripped from yi..
08:23:49 <CosmicRay> that reminds me.  We need gzip and bzip modules for haskell.
08:24:10 * Igloo has Haskell code for either de or inflate
08:24:19 <shapr> Igloo: you have it for both last I checked.
08:24:20 <Igloo> FFI to the C functions would be trivial too
08:24:22 <CosmicRay> tuomov: why don't you just use Cabal?
08:24:24 <Igloo> I do?
08:24:30 <CosmicRay> Igloo: Dude!  URL me!
08:24:31 <shapr> I'm pretty sure.
08:24:31 <Igloo> I didn't think I ever did compression
08:24:37 <shapr> hm, maybe so.
08:24:40 <tuomov> cosmicray: I only vaguely know what it is :)
08:24:44 <CosmicRay> if you have that, I could write a ZIP module for MissingH 
08:24:50 <CosmicRay> tuomov: www.haskell.org/cabal
08:24:50 * Igloo goes to find it
08:24:55 <shapr> I learned a lot about monads poring over your inflate code on my palm screen.
08:25:14 <CosmicRay> tuomov: It's pretty easy
08:25:25 <CosmicRay> tuomov: also, if you use Cabal, then yuo make it very easy for Debian folks to include your code
08:25:35 <CosmicRay> tuomov: if you need an example, you can see MissingH
08:25:40 <CosmicRay> tuomov: also Cabal itself has some examples
08:26:10 <CosmicRay> Igloo: I'm also preparing to leech some of your Crypto code :-)
08:26:22 <shapr> isn't all of Igloo's crypto code in cryptolib?
08:26:43 <CosmicRay> yes but licensing in cryptolib is a massive ambiguous mess
08:26:48 <shapr> oh :-(
08:26:58 <shapr> Did you ask Dominic about that?
08:27:02 <CosmicRay> I wanted to pull the whole thing into missingh but gave up because I couldn't track down proper copyright/license info for half the code there
08:27:04 <CosmicRay> yeah
08:27:05 <tuomov> there should also be some ncurses(w) configuration stuff... I hate autoconf
08:27:10 <CosmicRay> he said he'd fix it in a month or two IIRC
08:27:25 <shapr> I think I know almost all the authors of the code in cryptolib off the top of my head.
08:27:33 <shapr> I might be able to contact them.
08:27:43 <CosmicRay> shapr: half the problem is dominic's own code
08:27:49 <tuomov> the curses module depends on CWString... I wonder if that's worth packaging separately
08:28:05 <shapr> oh, because he did it while working for that british airline company and a university at the same time?
08:28:12 <CosmicRay> tuomov: ugh, autoconf.
08:28:22 <tuomov> and a few other things from ginsu
08:28:25 <wli> ghc-6.3: unknown package name: plugins
08:28:36 <shapr> you need to install hs-plugins
08:28:37 <tuomov> CWString, GenUtil, Locale
08:28:42 <CosmicRay> shapr: heh.  I don't know.  It's been awhile since I looked, but iirc, there was no copyright statement at all, but I could figure out from the docs that he wrote at least some ofi t
08:28:51 <shapr> wli: http://www.cse.unsw.edu.au/~dons/hs-plugins/index.html
08:28:57 <wli> E: Couldn't find package hs-plugins
08:29:07 <CosmicRay> anyway I didn't want to pollute MissingH with a rats nest of license problems
08:29:13 <CosmicRay> wli: I don't think it's been debianized
08:29:13 <shapr> sadly, hs-plugins doesn't have a deb yet.
08:29:13 <Igloo> What license did you want, CosmicRay?
08:29:17 <tuomov> locale stuff should probably go in some rather standard place
08:29:26 <CosmicRay> Igloo: anything GPL-compatible is fine
08:29:35 <CosmicRay> Igloo: IIRC you use a 3-clause BSD, which is just fine
08:29:36 <tuomov> perhaps in the ghc standard posix hierarchy even
08:29:39 <shapr> Would help so much anyway, because the hs-plugins code is improving at an amazing rate.
08:29:56 <shapr> alongside Yi, of course.
08:30:05 <CosmicRay> Igloo: I have bits of your Printf code already :-0
08:30:36 <CosmicRay> err, no you use the LGPL.  well that's fine too. :-)
08:30:47 * Igloo always ponders GPL vs BSD, but generally chooses the Haskell-community-friendly option over the Freeer (ETOOMANYES) one. Maybe I suck.
08:30:48 <wli> shapr: did the license thing work?
08:31:15 <CosmicRay> No, you don't suck.
08:31:26 * shapr quickly unit tests the license
08:31:42 <Igloo> Oh, hmm, could do that. Nah, if I make it BSD someone might be more likely to write deflate for me  :-)
08:31:52 <CosmicRay> I choose the GPL for my own work because I don't like the idea of a Microsoft, Sun, or Sco being able to take my Free Software, make it completely proprietary, without my consent or giving me a cent of their profits.
08:32:11 <tuomov> I'd be happy if microsoft ripped Ion :)
08:32:21 <wli> what's Ion?
08:32:26 <CosmicRay> If someone makes a profit off a Free Software program that uses my code, fine, but don't take away people's freedoms at the same time.
08:32:28 <tuomov> but for other projects without such goals as Ion, I use GPL
08:32:32 <Igloo> Well, for stuff like SHA (and, now I think about it, inflate) I'd rather Haskell code was used than someone just wrote an FFI interface to C code  :-)
08:32:34 <tuomov> wli: http://iki.fi/tuomov/ion/
08:32:46 <CosmicRay> OTOH I have no objection to others using BSD or LGPL if that isn't a concern for them
08:32:58 * musasabi uses BSD because I use my own work sometimes for GPL incompatible things (e.g. other BSD licenced projects)
08:33:02 <shapr> I prefer GPL for the same reason. I've been shafted by more than one company that employed me. I wrote code for them, they decided they were never gonna use it, and they still wouldn't release it so I could use it myself.
08:33:04 <tuomov> it used to be under the artistic license, but is LGPL these days
08:33:21 <CosmicRay> Igloo: I understand...  that's why I've offered to relicense any bits of MissingH under the LGPL or BSD, as required, to be added to fptools or Cabal
08:33:22 <wli> window mgr in Haskell?
08:33:28 <tuomov> no, C.
08:33:42 <shapr> very nice wm too, my favorite for some years.
08:33:59 <tuomov> I hadn't even heard of haskell when I first starting writing Ion, let alone PWM (1999) on which the first versions were based on
08:34:02 <shapr> ratpoison is just too minimal for me, I need to use the GIMP sometimes.
08:34:38 <musasabi> because if I make it GPL and many people contribute to it, then I loose the possiblity to use it in other free projects where I cannot import GPL'ed code.
08:34:49 <tuomov> anyway, Ion is a project to shatter the GUI hegemony, and I'd be happy if m$ adopted its approach
08:34:54 <wli> oh yeah
08:34:55 <shapr> oh speaking of which, there's a very experimental ion3 deb on the maintainer's people.debian.org page.
08:35:04 <tuomov> that goal is more important than software freedom in this case
08:35:06 <wli> the "theory of patches" I was trying to come up with
08:35:09 <CosmicRay> musasabi: either that or you can anally document the license on every bit of code like I do
08:35:12 <Igloo> Right, http://urchin.earth.li/darcs/ian/inflate
08:35:27 <wli> I modelled patches as context-sensitive productions
08:35:40 <CosmicRay> musasabi: if you look at certain bits of MissingH.Printf, you'll see instances where I segment a module into regions copyrighted by Ian and regions copyrighted by me
08:35:50 * Igloo doesn't have a testcase handy that isn't a GPG packet so I haven't tested it, but it used to work at least  :-)
08:36:03 <CosmicRay> Igloo: slick.
08:36:04 <wli> but I couldn't quite resolve "ordering"
08:36:14 <wli> e.g. the context may match multiple places
08:36:22 <shapr> wli: how so?
08:36:24 <wli> so you can try modelling it as a sequence
08:36:55 <shapr> the only important (I think) is where a patch cannot commute without being changed.
08:36:56 <wli> where the position the second acts on must follow the position the first acts on and so on
08:36:59 * Igloo suspects it's also not the fastest implementation in the world
08:37:12 <wli> shapr: hmm?
08:37:12 <CosmicRay> Igloo: It would be nice to have a (String -> String) wrapper around that, I think
08:37:46 <CosmicRay> I'm not quite sure how to handle the [Word32] output in those instances where the output is not a multiple of 4...  otoh I suspect the RFC would tell me and I could just hack it up
08:38:00 <shapr> a darcs repo of patches is like a factors of a (number / equation) or like multiple equations representing the same solution
08:38:02 <wli> shapr: well, once I describe what a patch is I can go about doing abstract algebra etc. on it
08:38:02 <musasabi> CosmicRay: yes, and I don't like that very much. And then there are times when I have to work with GPL incompatible free software licences. 
08:38:32 <shapr> you can move them around the same way you move something from one side of an equation to the other side
08:38:32 <Igloo> Hmm, yes, the interface is probably just what the other gpg stuff had and wanted
08:39:49 <shapr> it's too bad partially ordered monads haven't been added to GHC yet, because you could directly use those to implement patch theory.
08:40:06 <shapr> though honestly, I think an arrow implementation would be better
08:40:14 <shapr> faster at least
08:41:27 <wli> shapr: please describe this
08:41:32 <Igloo> Is partially ordered the same as commutative?
08:41:48 <wli> it sounds something like the opposite
08:42:20 <wli> shapr: I'm not aware of how arrows and/or partially ordered monads can model the patch theory presented
08:42:26 <shapr> I think a speedy arrow implementation of patches would let you factor each patch into 'collision types' so you could freely slide patches along a string where they don't conflict at all.
08:42:47 <shapr> Igloo: yes, commutative monads like SPJ mentioned in Hair Shirt Retrospective
08:42:48 <Igloo> You still need to alter them as they commute
08:43:06 <wli> well
08:43:15 <wli> I see interference graphs and antichains
08:43:33 <shapr> there's something like three level of 'sliding', commute with no changes, commute with changes, and bzzt thank you for playing.
08:43:48 <wli> defining commutation is also problematic
08:43:59 <wli> commuting with no changes is the easiest; pq=qp
08:44:03 <shapr> it's pretty straight forward if you look at the various patch types
08:44:11 <wli> pq=q'p' is not so easy
08:44:11 <shapr> you can't delete a file before you've created it...
08:44:12 <CosmicRay> Igloo: is the [Bit] component of the return value of inflate those bits that are left over after the last word32?
08:44:32 <wli> shapr: not so clear
08:44:42 <Igloo> Anyway, making the no-conflict case faster isn't solving the performance problem
08:45:06 <shapr> the performance problem is that you have to do zillions of comparisons each time you want to commute
08:45:10 <Igloo> CosmicRay: I think so. ISTR the RFC was a bit vague about what you were meant to do with them, whether they should all be 0 etc
08:45:37 <shapr> if you represent a patch with arrows, you can calculate the commutation properties once, and stick them on the arrow
08:45:45 <Igloo> But the problem is specifically when you have lots of conflicts
08:46:00 <shapr> the most expensive part of all this is the recursive comparisons and merges
08:46:07 <wli> shapr: well, the stuff you're going on about involves an understanding of that theory of patches I don't appear to have. For one, I don't see the modelling results you're describing anywhere (as trivial things I can intuit or written anywhere).
08:46:39 <shapr> wli: or alternatively, you understand patch theory just fine and I'm on another planet ;-)
08:47:36 <wli> I'm most concerned about hunk replacement
08:47:42 <wli> modelling that more precisely, that is
08:48:01 <shapr> I'm not sure that you can speed up the 'lots of conflicts' problem, but I do think you can speed up commutation dramatically.
08:48:42 <shapr> I think you'll be able to calculate commutative across many patches at once with a single operation, because the static properties of that set of patches will be visible all at the same time in the 'top level arrow'
08:48:43 <wli> shapr: just describing the arrow notion would help a lot
08:50:56 <bringert> shapr: when does the scrolling loop in flip happen?
08:51:44 <wli> I see that patches are something like arrows in a category of strings, and when a diagram commutes you have various kinds of products, but even in that case, you're stuck with a lot of choices from which I see nothing canonical
08:52:12 <wli> the notion of "same change" in particular is far too vague
08:53:38 <bringert> time for beer
08:54:11 <wli> There needs to be some criterion that at least narrows it down to a proper subset of the possible choices. And that's really what I'm trying to get a handle on.
08:55:37 <vincenz> re
08:57:42 <CosmicRay> Igloo: do you expect it could be a problem to convert that Word32 stuff to/from 8-bit Strings, given that a String is Unicode?
08:58:12 <wli> shapr: If pq=q'p' then q'=pq(p')^(-1), so supposing that p' is chosen to have some relationship to p (e.g. offsets, change of context, maybe more) you can construct q' if you can determine a p' that way. So you can sort of reduce the question to "how do I carry out a fuzzy reversion of a patch, or prove no such fuzzy reversion exists?"
08:58:15 <Igloo> CosmicRay: I'm need to try it on an example and see what the output is
08:58:53 <Igloo> If "abcd" is one Word32 then you'd need to split it up. If it's 4 then just converting to Char is probably the right thing to do
08:59:01 * Igloo suspects it's 1, though
08:59:51 <CosmicRay> yeah I'm figuring on splitting it up
08:59:52 <wli> shapr: do you agree with that?
09:00:00 * shapr reads
09:00:03 <vincenz> shapr: !
09:00:08 <shapr> vincenz: !
09:00:08 <vincenz> it's been a WHILE
09:00:14 <shapr> oh just a few months.
09:00:27 <vincenz> I was here all  along
09:00:27 <CosmicRay> Igloo: so when are you going to start on deflate? :-)
09:00:39 <vincenz> CosmicRay: s/on/to
09:00:42 <Igloo> Heh
09:00:54 <Igloo> I think a stupid deflate using only the default table should be simple
09:01:08 <CosmicRay> a good deflate :-)
09:01:29 <CosmicRay> Igloo: you realize what you've done now, right?  given me about 2 weeks of work porting zlib, gzip, zipfile, and tarfile from Python to Haskell :-)
09:01:40 <Igloo> If someone finds me a good description of a good deflate then I could probably be persuaded to do it once I've finished the darcs stuf I'm in the middle of
09:01:47 <Igloo> :-)
09:01:54 <CosmicRay> doesn't rfc1951 document it too?
09:01:55 <Igloo> Glad to help  :-)
09:02:16 <wli> shapr: The next step is to represent patches in a way that 2 patches that differ by whatever way we allow p, p' to differ are equivalent, or otherwise a fortiori mod out that equivalence.
09:02:32 <shapr> wli: that sounds right, though I can see that your view of patches is different from mine, so I'm not completely sure.
09:02:32 <Igloo> I could be wrong, but my intuition says that the decision about what table to use is the critical part of writing a good deflate
09:02:39 <CosmicRay> Igloo: I think OCaml's extlib may have one
09:02:55 * shapr googles for fortiori
09:03:02 <Igloo> And when to change table (At least, I /think/ you can change in the middle)
09:03:10 <CosmicRay> Igloo: nope, that have only inflate also.
09:06:15 <shapr> I think that modeling patches with arrows will scale down to modeling a single hunk, and up to modeling a static collection of patches. I forget the reason you can't commute hunks, but you might be able to at least merge patches into larger patches with arrow modeling.
09:07:03 <CosmicRay> good morning syntaxninja
09:07:21 <shapr> You could do the 'fully signed repo' right now if you're willing to double the space your _darcs/patches requires. Just keep the original signed patches and a matching 'darcs optimize' result.
09:07:44 <tuomov> You could just wrap the original patches ones they need to be modified
09:08:23 <shapr> how could you wrap them?
09:08:45 <tuomov> the modified patch is the original patch and patch to that
09:08:46 <shapr> I think you'de be forced to keep the signed original, no matter how much space that wastes.
09:08:53 <shapr> oh
09:09:07 <shapr> yah, that would work
09:09:25 <shapr> though it might now always be smaller than just changing the patch
09:09:29 <tuomov> in some cases that patch to patch could perhaps be verified to be correct
09:09:34 <shapr> er "might not always be smaller"
09:09:50 <shapr> that's an interesting point, might be a way to find darcs bugs at the same time
09:09:55 <tuomov> and in other cases perhaps we actually do not want a repo with a conflict to be verifiable
09:10:03 <tuomov> and a conflict resolution patch would fix the situation
09:10:11 <shapr> that is the new default, don't apply if you have a conflict
09:10:15 <shapr> I do like that myself
09:10:18 <shapr> hiya pesco!
09:10:22 <pesco> Hey!
09:10:31 <wli> shapr: well, the thing that's tripping me up is that the definition is very very loose
09:10:39 <shapr> of patch theory you mean?
09:10:47 <wli> shapr: yes
09:10:48 <shapr> I agree with that.
09:11:07 <tuomov> I'm pretty sure you can't formalise "same change" in any reasonable way
09:11:22 <shapr> I think the problem is that this first version of patch theory is being built bottom-up.
09:11:27 <wli> well, you have to
09:11:37 <wli> otherwise it's unimplementable
09:11:43 <shapr> I think you will be able to build a patch calculus once you have all the operations defined.
09:11:49 <SyntaxNinja> hi CosmicRay
09:12:06 <CosmicRay> SyntaxNinja: you were looking for me yesterday when I had to leave....
09:12:21 <shapr> but right now, we don't even know all the operations. Look at the oft-requested file permissions patch type, for example.
09:12:27 <wli> hunk replacement can be nailed down quite a bit.
09:13:50 <shapr> Same change for various hunk types can be written in stone, but if a patch (being immutable) includes multiple hunk types...
09:14:09 <wli> hunk replacement would be string replacement with some amount of leading and trailing context. Again, multiple string matches raises more problems.
09:14:12 <shapr> Hm, maybe it could be nailed down a lot more anyway.
09:14:29 <wli> you can just say composition of primitive patch types.
09:14:39 <shapr> yah, I just realized that.
09:15:22 <wli> the problem really centers around getting an adequate definition of "hunk replacement"
09:15:29 <Igloo> hunk replacement in darcs doesn't need context, it just needs the history of the file. Or are you talking about something else?
09:15:33 <shapr> Even so, there's a deeper theory behind patches. I'm pretty sure this fits into the theses by William Opdyke and Robert Brant that led up to the original refactoring browser.
09:15:49 <wli> theory of patches
09:16:01 <wli> shapr: okay, URL's/etc.?
09:16:09 * shapr googles
09:17:16 <shapr> citeseer is sooo sloow.
09:18:46 <marcot> Hello, what does a declaration like "import Language.Haskell230" means?
09:18:51 <marcot> Is it possible to group modules?
09:19:17 <Igloo> Language.Haskell230 means Language/Haskell230.hs
09:19:28 <SyntaxNinja> marcot: yes, there is now a hierarchical namespace. that's not in the haskell98 standard, though.
09:19:36 <wolfman8k> @info CCall
09:19:41 <wolfman8k> @type CCall
09:19:42 <lambdabot> bzzt
09:19:44 <Igloo> Is it not an amendment yet? ISTR it's close, anyway
09:19:44 <wolfman8k> #module CCall
09:19:48 <wolfman8k> @module CCall
09:19:48 <lambdabot> Sorry, I don't know the command "module", try "lambdabot: @listcommands
09:19:54 <wolfman8k> lambdabot: @listcommands
09:19:55 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
09:19:55 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
09:19:55 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
09:19:55 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
09:19:55 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
09:19:56 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
09:19:58 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
09:20:00 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
09:20:01 <shapr> Doh, Don Roberts and John Brant did the refactoring browser thesis. I'm sleepier than I thought.
09:20:02 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
09:20:05 <tuomov> hmm.. would a change be the same, if it is a "shift" of another change?
09:20:15 <marcot> So, it's just a directory thing or an thing from the language?
09:20:18 <tuomov> are there other cases where changes are "same"?
09:20:21 <wolfman8k> @all-dicts CCall
09:20:23 <lambdabot> No match for "CCall".
09:20:33 <wolfman8k> @eval 1 + 1
09:20:34 <lambdabot> 2
09:20:35 <Igloo> Looks like an old hslibs thing
09:20:37 <shapr> @index CCall
09:20:37 <lambdabot> Language.Haskell.THSyntax
09:20:43 <wolfman8k> :O
09:20:54 <wli> shapr: okay, citeseer has vanished off the face of the earth, now what?
09:21:00 <SyntaxNinja> Igloo: marcot: the only difference is that "." is now allowed in the module names, really. the behavior of the compilers search path isn't really a part of the language, I guess.
09:21:32 <shapr> wli: Don Roberts PhD thesis describes refactoring theory best that I know of, but later publications may summarize it better.
09:21:35 <Igloo> SyntaxNinja: It changes the meaning of Foo.Bar.baz
09:21:39 <shapr> I'm trying to find an url to his thesis even now.
09:21:42 <Igloo> As an expression
09:22:00 <wli> okay, thanks
09:22:24 * esap just tried and citeseer seems to work fine.
09:22:26 <shapr> wli: http://st-www.cs.uiuc.edu/~droberts/Thesis.ps from http://st-www.cs.uiuc.edu/~droberts/
09:22:31 <pesco> Eek, I made lambdabot take a dump!
09:22:42 <shapr> ?
09:22:56 <pesco> There's a command @dump so I called it.
09:23:00 <shapr> heh :-)
09:23:21 <shapr> that's part of Darius' EvalModule
09:23:31 <pesco> Ahm.
09:23:35 <musasabi> SyntaxNinja: btw when will you commit the cabal fix?
09:23:36 <shapr> dump saves the definitions file
09:23:52 <pesco> Ah, alright.
09:24:06 <marcot> Igloo sad that it was a directory stuff, but SyntaxNinja sad that it's possible to group modules. Is it something from the language?
09:24:48 <Igloo> (you mean "said")
09:24:56 <shapr> wli: refactoring theory verges on the metaphysical (and then veers back reconnects with domain specific languages) because refactoring is defined as "changes that don't affect meaning" and meaning is defined as "whatever makes your unit tests pass"
09:24:57 <Igloo> Is putting modules in a directory not grouping them?
09:25:15 <Igloo> There are also packages, which might be what you are looking for
09:25:40 <wli> shapr: sounds pretty smoky
09:25:41 <Igloo> SyntaxNinja: Do you know if anyone is planning on doing the cabal implementation work for nhc98 BTW?
09:26:22 <shapr> wli: I think I was the first person to connect the patch theory and refactoring ideas, but there's a thread with the same ideas taken even further on lambda-the-ultimate.org
09:26:27 <marcot> Igloo: sorry, my english is not very good.
09:26:54 <Igloo> No problem, just trying to help. No offence intended  :-)
09:26:55 <marcot> Igloo: where can I get documentation about packages?
09:26:57 <SyntaxNinja> Igloo: I'm planning to once I get some time :)
09:27:07 <shapr> In essence, if you can define a refactoring for your language in terms of patch theory, then you can apply a refactoring as a darcs patch, and it'll still work for code that's merged in from other repos.
09:27:10 <Igloo> To do it yourself, you mean?
09:27:16 <wli> shapr: sounds too semantically involved...
09:27:22 <marcot> Igloo: yes.
09:27:27 <SyntaxNinja> musasabi: which fix is that?
09:27:34 <shapr> wli: it is, but it would very much be worth it for a language-specific tool that uses darcs as a backend
09:27:36 <marcot> Igloo: Ok, you helped, I'll never say sad again. =)
09:27:40 <Igloo> (sorry, that was to SyntaxNinja)
09:27:49 <Igloo> marcot  :-)
09:28:02 <SyntaxNinja> musasabi: my laptop is broken; I have a huge patch from simonM and a smaller patch with libdir or something.
09:28:10 <SyntaxNinja> as soon as I get my laptop back, I'm going to be hacking away, and that should be any day now.
09:28:13 <Igloo> marcot: http://www.haskell.org/cabal/ might be what you are looking for, but it's not all done yet
09:28:26 <SyntaxNinja> most patches will _hopefully_ get applied by the end of the weekend.
09:28:30 <Igloo> marcot: Otherwise there should be stuff in the GHC documentation about its package support
09:28:47 <wli> shapr: I'm really looking for something far lower-level like literal patches...
09:28:59 <shapr> wli: along those same lines, I think parse tree macros in language-specific parser-based modes will be interesting. That's one improvement I think Yi will have over Emacs.
09:29:21 <SyntaxNinja> musasabi, Igloo, and others, sorry about outstanding patches and not being responsive to cabal stuff for the last week or two... 
09:29:32 <SyntaxNinja> I don't have a computer I can do free software work on :(
09:29:34 <Darius> shapr: For something completely out of the blue, you've probably heard of Croquet, no?
09:29:49 <shapr> yah, I played with the new Croquet recently.
09:29:54 <shapr> It's awesome =)
09:29:58 <Igloo> SyntaxNinja: Wasn't a complaint, just wondering if someone was actually planning on doing it  :-)
09:30:11 <SyntaxNinja> Igloo: it will have to get done if it goes into fptools :)
09:30:20 <shapr> If nvidia didn't suck so bad, I'd be using Croquet quite a bit.
09:30:36 <marcot> Igloo: but this syntax: "import Language.Haskell230" is a package syntax?
09:30:39 <Darius> If my computer didn't suck so bad, I might actually look at it.
09:30:43 * Igloo is just considering not using nhc98 for libraries given http://www.haskell.org//pipermail/nhc-users/2004-November/000155.html
09:30:53 <Igloo> marcot: No
09:31:02 <shapr> or if I could afford a new single-cpu computer... nvidia + smp = pain
09:31:05 <wli> shapr: well, I'm looking for something vastly different
09:31:12 <shapr> wli: what are you looking for?
09:31:19 <Igloo> It means Language/Haskell230.hs, but that could be relative to the current directory or the root directory of a package
09:31:41 <wli> shapr: A way to make a patch reordering tool for quilt
09:31:59 <wli> shapr: possibly merging too
09:32:08 <SyntaxNinja> meh. poor nhc guys need more hacking time.
09:32:09 <wli> shapr: allowing heavy supervision of the process
09:32:10 <shapr> What's quilt? google thinks only fabric.
09:32:24 <wli> shapr: debian has a pkg of it
09:32:25 <Igloo> Yeah  :-(
09:32:39 <shapr> ah, cool
09:32:54 <shapr> Why not just use darcs?
09:33:01 <wli> shapr: it's something like a version control system that does very little more than tracking a list of patches that can be fed to diff(1)
09:33:20 <wli> shapr: the patches themselves are objects that have to be presented in a careful fashion
09:33:24 <wli> shapr: for my purposes
09:33:47 <wli> shapr: so it matters a *lot* what the otherwise "internal" patches being tracked are
09:34:05 <wli> shapr: and very specifically the order they appear, which pieces are grouped together, and so on
09:34:17 <shapr> so, you need more commutation info than darcs currently offers?
09:34:25 <wli> shapr: not more
09:34:38 <wli> shapr: fine-grained control
09:34:53 <shapr> like what? darcs is pretty fine-grained already.
09:35:28 <wli> shapr: for instance, "upstream" will have a sequence of patches it just incorporated
09:35:48 <wli> shapr: and I'll have a sequence of patches against the baseline for that
09:36:11 <wli> shapr: So I need to stop in the middle of the merge process and play with the results
09:36:50 <wli> shapr: for instance, I grab the first one of my own, and try to commute it forward as far as possible
09:37:02 <shapr> forward meaning what?
09:37:24 <wli> shapr: so I get a "partial merge" of the two that I need to do things with, like look at the resulting source base and testing it
09:38:02 <wli> shapr: if darcs can do these things I'm not aware of it
09:38:29 <shapr> I don't understand what you want in enough detail to know if darcs does it.
09:38:57 <shapr> shall I describe it back to you?
09:39:05 <wli> shapr: okay, a "common baseline" is assumed. This is a collection of files in a state etc. that a sequence of patches applies to.
09:39:12 <shapr> ok
09:39:29 <shapr> the 'main' kernel repo, 2.6, 2.4, whatever?
09:39:48 <wli> shapr: so with this I get multiple sequences of patches, where the patches need to be carried around and the groupings of changes preserved and so on
09:40:19 <shapr> I've been dreaming of being able to pull the robert love patches from his darcs repo into my own to test the extra responsiveness.
09:40:31 <wli> shapr: like 2.6.10-rc2-bk5 and then 2.6.10-rc2-bk6 is a sequence of patches that carries 2.6.10-rc2-bk5 to 2.6.10-bk6, and I have some other series of patches vs. 2.6.10-rc2-bk5
09:40:56 <wli> shapr: so I want to selectively go halfway on both sequences of patches
09:41:03 <shapr> 'halfway' ?
09:41:04 <wli> shapr: for instance, I take the first of my own
09:41:35 <wli> shapr: I want to "inject" this into the mainline sequence of patches
09:41:44 <wli> shapr: it's not going to work completely
09:41:50 <wli> shapr: So I want a "partial result"
09:41:58 <tuomov> so you just pull patches from two repos
09:42:23 <tuomov> you have your changes in one, and the new upstream changes incorporated into another, and in a third repo you combine those
09:42:43 <tuomov> in whatever order you wish
09:42:48 <wli> shapr: for instance, if the first of my own commutes with the first mainline patch but none of the other mainline patches, I want to have the first patches from both, and then be able to inspect that
09:42:56 <shapr> I think you can try this immediately with the kernel repo already, either by 'faking it' and applying the patches in different darcs kernel repos, or by using one of the cvs -> darcs gateways
09:43:16 <wli> shapr: the end result after I do these by hand is a series of patches I can extract and post that applies to 2.6.10-rc2-bk6
09:43:33 <wli> AFAICT darcs is a black hole
09:43:38 <shapr> I'm not sure about that end result.
09:43:39 <wli> I can merge, but I can't pull them out
09:43:48 <wli> shapr: yes, that's why darcs isn't cutting it
09:43:56 <shapr> hm, I see what you mean.
09:44:05 <shapr> er wait
09:44:15 <shapr> can't you export a diff from tagged versions in darcs?
09:44:17 <shapr> or something like that?
09:44:36 <tuomov> you just create a patch bundle between the repo with just the upstream changes, and the the repo
09:44:43 <tuomov> s/the/new/
09:44:57 <shapr> that sounds workable
09:45:03 <wli> I have patch series 1 and patch series 2 vs. a common baseline. I need a patch series 3 that's "equivalent" and in 1:1 correspondence to patch series 2 that applies to the baseline plus patch series 1. And I need massive manual intervention.
09:45:37 <wli> It matters a lot what happens when the commutation doesn't work.
09:45:47 <shapr> right, I think you can do that with either diff'ing between tags or by exporting a patch bundle like tuomov said.
09:45:52 <tuomov> that can be done very conveniently as I described
09:45:59 <wli> That assumes the commutation works.
09:46:14 <shapr> darcs lets you use whatever you want to do merges
09:46:34 <jadrian> english question
09:46:44 <jadrian> if you have some data A
09:47:13 <jadrian> and you need to groups it with info
09:47:18 <wli> shapr: thus far I only understand what darcs does in the case where it all successfully commutes.
09:47:23 <jadrian> {A, cost of A, etc}
09:47:29 <wli> shapr: that is, for the "porting patch series"
09:47:31 <shapr> where it doesn't commute, you get to decide
09:47:32 <jadrian> to use as entries of an array for instance
09:47:50 <jadrian> would there be a std name for the record with A plus its info?
09:47:54 <wli> shapr: AFAICT it just barfs when they don't commute completely.
09:48:17 <tuomov> it creates markers that it didn't work, and you get to resolve it
09:48:19 <shapr> I would suggest that you force a conflict and specify your choice of editor as your merge tool, then you'll see how it does (or doesn't) work for you.
09:48:24 <jadrian> (probably not but I thought I'd check)
09:48:29 <CosmicRay> jadrian: I don't think so.  struct, record, class, object, etc. depending on your language, if I am understanding the question properly
09:48:51 <wli> shapr: the intermediate states have to be recoverable
09:49:00 <shapr> ?
09:49:11 <tuomov> of course, you can pull just the patches you want to
09:49:12 <wli> shapr: reordering the things may work syntactically but not semantically
09:49:21 <shapr> ah, yes
09:49:36 <wli> so you really do have to stop when there's "trouble", not do fuzzy merging etc.
09:50:05 <shapr> you will most likely run up against the problem of 'good patches' just like arch users have the difficulty of choosing 'good changesets'
09:50:06 <wli> and you need to stop in the middle
09:50:24 <wli> shapr: Now I don't know what you mean. What's a "good patch" mean?
09:50:24 <jadrian> CosmicRay: well in this case I have  Formulas, and a list  [Formula x FormulaInfo]
09:50:44 <jadrian> CosmicRay: where Formula x FormulaInfo is an record with a buch of stuff
09:50:45 <shapr> darcs can only check syntactic merge properties, but that's where 'darcs test' is really handy.
09:50:55 <CosmicRay> jadrian: you could just say you have a list of records
09:51:04 <jadrian> CosmicRay: yeah maybe...
09:51:15 <wli> shapr: well, it does most of the primitive operations internally
09:51:37 <wli> shapr: The porting procedure goes:
09:51:48 <wli> shapr: (in the absence of commutation problems)
09:52:37 <wli> shapr: commute the first local patch to after the mainline series, boot that on a machine to test it, commute the second one, etc. When that fails, commute halfway, backing out everything after.
09:52:54 <wli> shapr: repeat process for the remainder of the local series until the local series is exhausted
09:53:58 <tuomov> eh. so your local patches are huge chunks instead of fine-grained as darcs is usually used?
09:54:00 <wli> shapr: when commuting fails, you have to stop where it fails, drop all of mainline after it, test that, commute by hand, test that result, auto-commute as far as possible again, testing result where it fails, and so on
09:54:03 <shapr> patches commute in darcs, and are not splittable into multiple ptaches. But, you record patches yourself, so you end up choosing the content of each patch. If you record half of a O(1) scheduler in one patch, and half in another patch, they may commute syntactically, but problems *will* happen
09:54:12 <wli> tuomov: not huge per se
09:54:19 <wli> tuomov: they are meaningful
09:54:24 <wli> tuomov: so they have to be kept together
09:54:43 <shapr> so you somewhat get to define semantic commutation yourself by your choice of which changes make up a patch
09:55:25 <wli> shapr: well, I would say it as that certain "strings of changes" are not allowed to be reordered.
09:56:34 <tuomov> I don't see any problems with using darcs if you record all small meaningfull changes
09:56:37 <wli> say a "postable patch" is a sequence of primitive patches such that reordering its pieces is disallowed. e.g. when commuting patches, the pieces of the primitive patches have to remain contiguous in the sequence of primitive patches.
09:56:45 <shapr> I do wish I had a patch browser that would let me weld "stupid bugfix" patches onto the end of patches I've formerly recorded.
09:57:08 <tuomov> the recorded patches don't have to have anything to do with postable patches
09:58:44 <wli> The "postable patch" problem is pretty nasty though. It's a layer of state and/or structure that appears absent.
09:59:01 <shapr> so far, this sounds like something darcs can do, but I'm not totally sure.
09:59:20 <shapr> Anyway, I'll go unicycle and think about it. Maybe I'll have some brilliant realization.
09:59:30 <tuomov> this is exactly something that version control is meant for. of course it can do it.
10:13:18 <Cale> http://www.catandgirl.com/view.php?loc=176
10:17:54 <Darius> Thanks for reminding me of something.
10:18:41 <wli> well, if it can, then there's nothing to do
10:20:24 <trebligbsd> funny!
10:23:00 <tuomov> the only question is which is the most convenient way to do what you want
10:27:48 <Cale> hmm
10:32:00 <Cale> If I have type constructors m, n of kind * -> *, is there any way to form the type constructor of kind * -> * which is abstractly \a -> (m a, n a)?
10:34:18 <trebligbsd> can you say it in english?
10:34:22 <trebligbsd> you might understand it then.
10:35:13 <Darius> Not without having to wrap/unwrap a constructor
10:35:25 <Cale> okay
10:43:29 * Darius ponders implementing a CAM-like system in Haskell's type language.
10:44:45 <wli> Which of the various CAM's do you have in mind?
10:45:44 <Darius> Well unless you are wondering what TLA I was refering to, I thought there was only one CAM (though I heard something about a CAM2).
10:46:11 <wli> Darius: first one I think of is SCSI
10:48:13 <Darius> Ah, well CAM for me usually means Categorical Abstract Machine.  Essentially, the simply typed lambda calculus' cartesian closed categorical model
10:48:51 <wli> Darius: okay, that's different
11:06:51 * dblhelix is back (gone 05:32:29)
11:35:33 <CosmicRay> bwahahaha.  there is also a crc32 for haskell.
11:38:25 <CosmicRay> that's just about everything I need to implement gzip
11:39:11 <Igloo> gunzip, at least
11:39:25 <Igloo> Unless I missed something
11:39:34 <CosmicRay> sorry, I meant python's gzip module
11:39:54 <CosmicRay> to read stuff
11:39:55 <Igloo> Ah, what does that do then?
11:40:07 <CosmicRay> basically lets you open a gzip file as if it were a regular file
11:40:19 <CosmicRay> we can't quite do that in haskell because Handle is an opaque type
11:40:23 <Igloo> Ah, right
11:40:29 <CosmicRay> but I can at least provide functions that work on a String
11:40:33 <Igloo> Hmm
11:40:38 <CosmicRay> it'll be slow
11:40:42 <CosmicRay> but it'll be versatile
11:41:03 <CosmicRay> although it won't support seeking.
11:41:04 <CosmicRay> hrm.
11:43:04 <CosmicRay> what do you think i should do about that one?
11:43:21 <CosmicRay> a (String -> String) is useful if you're doing a stream processor
11:43:27 <CosmicRay> but not so great if you need random access
11:43:55 <Igloo> Well, Inflate it self can still be String -> String, you just need something on top of that if you want to keep the whole String around
11:44:16 <CosmicRay> well, it's that we might not want to keep the whole String around
11:44:22 <CosmicRay> let's say you have a 25MB gz file
11:44:27 <Igloo> But you can provide 2 functions
11:44:31 <CosmicRay> and you want to grab some data 1MB and 15MB in...
11:44:33 <Igloo> Oh, ISWYM
11:44:42 <Igloo> But gz isn't seekable anyway
11:44:57 <CosmicRay> well yes and no
11:45:07 <Igloo> Well, the files that inflate inflates aren't
11:45:17 <CosmicRay> it can be in certain circumstances
11:45:35 <CosmicRay> Python just simulates it by going back to the start of the file and reading the appropriate number of bytes from the decoded stream :-)
11:45:43 <CosmicRay> s/reading/discarding/
11:46:04 <mflux> "let's write a program that outputs a file backwards.. seek to the last bytete, read it, output it, seek to the previous.." ;)
11:46:07 <CosmicRay> I guess I could provide a little utility tthat does the same thing, given a seekable Handle on input
11:46:09 <Igloo> You can do that with something on top of the String -> String functino too
11:46:18 <CosmicRay> yup
11:46:25 <CosmicRay> ok, I'll just do a String -> String then.
11:46:37 <CosmicRay> it seems safe to split up a Word32 and store it in a Char, from what I've seen.
11:46:40 <CosmicRay> so all looks good.
11:46:46 <CosmicRay> (in 4 chars, that is)
11:47:03 <CosmicRay> Igloo: what other cool things do you have lying about that we don't know of? :-)
11:47:05 <Igloo> You presumably need to chop off 0-3 chars from the end too
11:47:17 <Igloo> Heh
11:47:39 <Igloo> Do you know of http://urchin.earth.li/~ian/minstrel/ ?
11:47:44 <CosmicRay> see, we've solved the www.haskell.org/libraries problem.
11:47:57 <CosmicRay> just delete that page and replace it with one that says: "Go to #haskell.  See shapr and Igloo."
11:47:58 <Igloo> What, ask me?  :-)
11:48:15 <Igloo> :-)
11:48:27 <CosmicRay> damn, you are full of cool code.
11:49:05 * Igloo thinks that's about it, apart from Some TH bits that aren't really useful and some gpg glue for the cryptolib+inflate stuff
11:49:33 <CosmicRay> your MD5 code is still on my list of stuff to steal :-)
11:50:22 * Igloo should look and see if that can benefit from any of the optimisation I did on darcs' SHA1
11:50:56 <raboof> you implemented those in haskell?
11:51:01 <Igloo> Yup
11:51:46 <raboof> besides being cool in its own, does it make sense to do that in a functional language instead of just calling C?
11:52:22 <CosmicRay> raboof: it makes it more portable and easier to build, for one
11:52:23 <Igloo> You gett the laziness for free
11:52:45 <Igloo> So you can inflate/md5/whatever in constant space
11:57:59 <CosmicRay> Hmm..  What would you call things like crc32, md5, sha, etc...  crypto?  hashing?  checksumming?
11:58:26 <Igloo> checksum, hash, hash. But I'd put at least the latter two in cryptolib
11:58:51 <CosmicRay> so you wouldn't group all three of them together in a hierarchical library?
11:59:06 <CosmicRay> Ie, Cksum.CRC32, Cksum.MD5, etc
11:59:21 <CosmicRay> yeah well there are licensing issues with cryptolib
11:59:24 <Igloo> Data.Hash.{MD5,SHA1} Data.Checksum.CRC32
11:59:28 <CosmicRay> hmm.
11:59:31 <CosmicRay> fair nuff.
11:59:35 <Igloo> But library name is independent of package name
11:59:47 <CosmicRay> right, I know
12:00:02 <CosmicRay> in fact I think they *are* in cryptolib
12:00:08 <Igloo> Well, there should be a standard cryptolib under some name with no license issues. I'd put them in that thing
12:00:15 <CosmicRay> yes.
12:00:22 <CosmicRay> gotcha.
12:00:28 <wnoise>   All three can be used for both hashing and checksumming, it's just that some are less secure for cryptographic hashing.  I wouldn't name them differently.
12:00:29 <CosmicRay> I'm putting them all in MissingH :-)
12:00:46 <Igloo> I'm struggling to think of a better package to put CRC32 in
12:01:08 <CosmicRay> wnoise: what might you suggest?
12:03:07 <CosmicRay> cryptolib just puts them all under Codec.Encryption
12:03:18 <CosmicRay> that seems misleading to me, for something like MD5 or SHA1
12:04:45 <Igloo> I'm sure Simon Marlow had them on his proposal, but I can't find it now
12:05:42 <CosmicRay> maybe they are all Signature functions?
12:06:03 <Igloo> Signature functions?
12:07:12 <CosmicRay> would you talk of having a crc32 signature, an md5 signature, a sha1 signatuer?
12:08:12 <Igloo> No, an RSA signature
12:08:36 <Igloo> Ah, http://www.haskell.org/~simonmar/libraries/layout.html - but they're not there any more
12:09:39 <wnoise> CosmicRay: probably Checksum.  I have seen all of them used to verify integrity.  For cryptographic hashing, only SHA1 might be acceptable.  For general hashing SHA1 and MD5 have ranges that are way too big.
12:09:45 <CosmicRay> http://web.archive.org/web/20031010125423/http://www.haskell.org/~simonmar/libraries/layout.html
12:10:40 <Igloo> The page is there, but MD5 and friends aren't
12:12:16 <wagle> signature is only one of their uses
12:12:25 <CosmicRay> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hslibs/util/Attic/MD5.lhs
12:12:35 <wagle> library provides mechanism, not policy?
12:12:40 <xerox> a question, why "data Quadruple a a b b = Quadruple a a b b" is incorrect?
12:13:06 <Riastradh> What's the point of the duplicated arguments to the Quadruple type constructor?
12:13:11 <TheHunter> xerox, you probably mean "data Quad a b = Quad a a b b"
12:13:16 <xerox> it's an exercise
12:13:30 <wagle> whats the error message?
12:13:42 <CosmicRay> pftt, it's distincly bad taste to ask for homework answers on IRC, imho
12:13:48 <xerox>     Conflicting definitions for `a'
12:13:48 <xerox>     In the data type declaration for `Quadruple'
12:13:51 <wnoise> On vulnerabilities in MD5: http://www.cryptography.com/cnews/hash.html
12:13:52 <xerox> same for b
12:14:03 <xerox> CosmicRay: book doesn't gives answers
12:14:07 <xerox> and it's not for school
12:14:15 <CosmicRay> ah, ok then.
12:14:18 <xerox> and i can't realize it by myself, i'm sorry
12:14:31 <CosmicRay> no that's ok.  I thought you were asking for help with a school assignment.
12:14:48 <xerox> it would be nice to do haskell at school, though :)
12:15:05 <CosmicRay> xerox: one day.... :-)
12:15:21 <xerox> data Quadruple a b = .. doesn't work either
12:16:29 <xerox> the text of the exercise is: "Write a datatype Quadruple which holds four elements. However the first two elements must be the same type and the last two elements must be the same type."
12:16:40 <xerox> and then make some functions using that type
12:16:52 <TheHunter> xerox, does too.
12:17:01 <pesco> And data Quad a b = Quad a a b b doesn't work?!
12:17:17 <wagle> data Q a b = Q a a b b
12:17:20 <wagle> works for me
12:17:36 <xerox> it does!
12:18:06 <xerox> it was the latter firstTwo :: (Quadruple a a b b) -> [a], to raise the errors
12:18:09 <xerox> thanks much
12:21:03 <Darius> CosmicRay: Quite a few schools use Haskell
12:21:20 <CosmicRay> @index word32ToInt
12:21:20 <lambdabot> bzzt
12:21:38 <Darius> fromIntegral (?)
12:21:59 <Oejet> CosmicRay: fromIntegral (w::Word32)::Int
12:22:04 <CosmicRay> thanks
12:23:46 <np_hard> I love this chart:
12:23:47 <np_hard> http://www.syncsort.com/sort/infosu.htm
12:25:05 <Oejet> np_hard: Hehehe.
12:26:07 <np_hard> look how much bigger the SyncSort bar is?
12:26:14 <np_hard> "Other methods" can't compete!
12:26:29 <np_hard> and if you aren't using SyncSort, guess which bar is yours?
12:26:39 <np_hard> Hint: it's not labeled "SyncSort!"
12:26:59 <np_hard> (apologies to anyone in #haskell and #emacs simultaneously, I just needed to share)
12:35:38 <Oejet> I can't see why things like "patented technologies" and "proprietary algorithms" can be strong selling points.  Guess it must sound good to some ears.
12:36:26 <CosmicRay> Igloo: should I be using http://urchin.earth.li/darcs/ian/inflate/Inflate.lhs or http://urchin.earth.li/~ian/systime/Inflate.lhs?
12:37:31 <np_hard> they reassure people that they are not paying too much for something they can get for less
12:38:26 <Oejet> So they cannot get it for less, because they cannot get it anywhere else?
12:40:17 <tuomov> or if they can, the vendor can get their asses sued off
12:41:40 <np_hard> why is that?
12:41:48 <np_hard> maybe people might think that
12:41:52 <np_hard> but I don't think it's true
12:42:14 <tuomov> marketdroid and management people live in a different world
12:42:23 <np_hard> that is certainly true
12:42:32 <np_hard> so do a lot of programmers :-/
12:42:40 <tuomov> they rather trust their counterparts from other companies than programmers
12:43:30 <CosmicRay> is there a lhs -> hs converter that preserves comments?
12:43:40 <CosmicRay> (unlit doesn't)
12:43:57 * np_hard works with a guy who thinks it is more convenient to access database columns in a 244-field view which has spreadsheet columns "A, B, C, .. AA, AB" etc. than it is to use the relational tables that are there
12:44:06 <wnoise> Not that I know of.  Why would you want to do that?
12:44:17 <Oejet> Write one, CosmicRay. :-)
12:44:51 <CosmicRay> Oejet: I think I'll exceed my stack size if I try to write one more thing as a prerequisite for this project :-)
12:45:14 <CosmicRay> wnoise: so I don't have to fool around with messing with my build scripts, mainly.
12:45:22 <np_hard> been a while since I have seen lhs but wouldn't that just be a couple lines in sed?
12:47:40 <CosmicRay> never mind, I'll jsut do it manually
12:48:57 <wnoise> yeah, sed -e 'g/^> /s/^> //' 
12:49:17 <np_hard> -- maybe ?
12:49:21 <wnoise> whoops, hit enter to soon
12:49:30 <CosmicRay> wnoise: this is the LaTeX-style lhs
12:49:40 <CosmicRay> wnoise: you have to find the stuff between \begin{code} and \end{code}
12:49:58 <wnoise> Ah.
12:50:30 <CosmicRay> @index InfM
12:50:30 <lambdabot> bzzt
12:51:22 <Darius> InfM is Igloo rolling his own Control.Monad.State, unless the monad operations are defined differently, which I doubt.
12:51:31 <CosmicRay> you're right
12:52:46 <CosmicRay> stupid haddock is having a fit with it
12:54:27 <Darius> Wait.  With a Latex style lhs wouldn't all the comments be in the code part, so keeping the comments would be the same as keeping the code? Or do you want to change the other parts to comments?
12:55:00 <CosmicRay> I meant changing the other parts to comments
12:56:02 <CosmicRay> Igloo: haddock is complaining of "parse error in pattern" on this line: extract_InfM :: InfM a -> (a, [Bit])
12:56:10 <CosmicRay> I have no idea why haddock specifically dislikes it
12:56:13 <Darius> :%s/\\begin{code}/-}/ :%s/\\end{code}/{- and perhaps add a {- to begin and a -} to end.
12:57:19 <wnoise> Well that's cheaper than the awk I was cooking up.
12:57:22 <wnoise> http://ofb.net/~wnoise/misc/unlitpreserve.awk
12:57:24 <CosmicRay> heh
12:57:49 <Igloo> Does haddock not unlit before trying to do anything?
12:58:13 <CosmicRay> I already did an unlit on this
12:58:21 <CosmicRay> I'm working from the result
12:58:21 <Igloo> Either Control.Monad.State didn't exist when I wrote that or I wanted it to work in nhc98 or somesuch
12:58:42 * Igloo has never looked at haddock so no idea why it's breaking
12:58:48 <Darius> Igloo: I figured as much.
12:58:49 <CosmicRay> the error appears to derive from simon's haskell source parser
12:59:02 <Igloo> Where did http://urchin.earth.li/~ian/systime/Inflate.lhs come from?
12:59:03 * Darius just likes to give people hard times.
12:59:39 <CosmicRay> google
13:02:02 <Igloo> They look the same to me except for the license
13:02:17 <Igloo> And explicit imports
13:02:37 <Igloo> Anyway, the darcs repo is the canonical location
13:10:22 <CosmicRay> ok.
13:10:24 <CosmicRay> got it.
13:11:24 <CosmicRay> hmm haddock's problem lies with get_bits
13:11:52 <CosmicRay>           need (i+1) (x:xs) = let (ys, zs) = need i xs in (x:ys, zs)
13:11:55 <CosmicRay> that's the line it doesn't like
13:12:26 <wnoise> Ah, the deprecated n+k pattern-matching.
13:12:32 <jadrian> :)
13:12:45 <CosmicRay> is this equivolent:
13:12:46 <TheHunter> it's not deprecated!
13:12:47 <CosmicRay>           need (i) (x:xs) = let (ys, zs) = need (i-1) xs in (x:ys, zs)
13:13:04 <stepcut> just unappreciated...
13:13:10 <Igloo> You can remove the parens around the i
13:13:18 <CosmicRay> right
13:13:22 <Igloo> But if it really can't cope with that, bugs should be filed!
13:13:22 <CosmicRay> but it means the same, right?
13:13:26 <Igloo> Yup
13:13:28 <CosmicRay> great.
13:13:33 <wnoise> Depends on what you mean by deprecated.  Most of the community thinks they're bad style, and having them in the language is a bad idea.
13:13:34 <Igloo> Oh, assuming 0 is handled above
13:13:40 <CosmicRay> it is
13:13:46 <CosmicRay>     where need 0 xs = ([], xs)
13:13:46 <CosmicRay>           need _ [] = error "get_bits: Don't have enough!"
13:13:46 <CosmicRay>           need i (x:xs) = let (ys, zs) = need (i-1) xs in (x:ys, zs)
13:14:11 <Igloo> wnoise: Yeah, but they're all wrong and I'm right
13:14:39 <wnoise> Igloo: Oh, well in that case ...
13:14:43 <TheHunter> wnoise, i disagree, and iirc Ralf Hinze, too.
13:15:01 <jadrian> TheHunter: why do you disagree? (just curious)
13:15:07 <TheHunter> it's just the natural way of handling natural numbers.
13:15:21 <CosmicRay> Igloo: so what are supposed to be in this list of ints that inflate takes?
13:15:28 <CosmicRay> and why is it an int instead of a word32 or something?
13:15:48 <TheHunter> you wouldn't give a way pattern matching for lists if there were some weird, rarely-occuring ambigoues cases.
13:16:20 <CosmicRay> itlooks like they just represent the chars...
13:16:41 <Igloo> http://urchin.earth.li/~ian/systime/TestInflate.lhs looks like both the Int and Word32s are just chars
13:16:53 <TheHunter> granted, integers are not real naturals, but they come very close.
13:16:53 <sjanssen_> is there a preferred way to concatenate a list of ShowS (mything :: [String -> String]) ?
13:17:11 <Igloo> The types will be like that because that's what the gpg stuff wanted and I hadn't got around to separating it out sensibly
13:17:12 <CosmicRay> interesting
13:17:16 <CosmicRay> the [Bit] is discarded
13:17:18 <TheHunter> ok gotta go
13:17:20 * TheHunter is away: I'm busy
13:17:25 <wnoise> TheHunter: but we don't have a Nat type, short of church-encoding.
13:18:29 <wnoise> And why should there be special magic syntax for naturals?  Now if you want to push views into the language...
13:19:29 <stepcut> mmm... magic syntax
13:20:17 <SyntaxNinja> syyynnnntaaaxxxx
13:20:28 <stepcut> magic syntax ninja
13:21:27 <Darius> CosmicRay, Igloo: negative numbers would need to throw errors technically...
13:22:38 <jadrian> I got a function that takes two term containers , ts and rs, and returns the list with all possible unifiers  between terms of both sides
13:22:56 <Darius> Congratulations.
13:22:57 <Igloo> Darius: The type is Word32  :-)
13:23:04 <jadrian> thank you, thank you :)
13:23:05 <jadrian> now
13:23:23 <Darius> Igloo: Wiley
13:23:37 <jadrian> I'm going to pick one unifier and try to use it, if it succeds it's done, otherwise I'll try the next one, and so on
13:23:41 <jadrian> now my question is
13:24:19 <jadrian> if I just pattern match the lazy list with  [] and (x:xs)
13:24:46 <jadrian> it will keep the term containers in memory even if there won't be any other unifiers to try, right?
13:26:01 <jadrian> but if I also pattern match with [x] too, it will proceed the unification process after finding one unification
13:26:10 <jadrian> am I right?
13:26:26 <jadrian> I can see 3 alternatives
13:27:02 <jadrian> make it completely lazy, so it will just try to get one unifier, use it and keep everything in memory until the next run
13:27:11 <jadrian> force the evaluation of all the unifiers
13:27:26 <jadrian> so the term containers could be garbage collected
13:28:32 <jadrian> and pattern match with a singleton, so it would at least try to see if there is no other unifier available, and in that case it would garbage collect them
13:28:48 <jadrian> (is there any flaw in my reasoning?)
13:29:54 <Igloo> If you are evaluating the head of the list and don't keep a reference to the tail then it, and the inputs, can be GCed
13:30:42 <jadrian> Igloo: I'll might use the tail if the computation on the head doesn't succed
13:30:44 <Igloo> If you need the tail too but want it to be GCed when there is only one element then you need to match on [x] before (x:xs), yes
13:30:45 * SyntaxNinja GCs Igloo's tail
13:30:55 <jadrian> Igloo: yeap
13:31:42 <jadrian> Igloo: Doing a DeepSec on the list would also result in garbage collecting the whole thing used to compute the tail, right?
13:32:16 <Igloo> Right
13:32:20 <jadrian> k thanks
14:14:58 <CosmicRay> w00t!
14:15:14 <CosmicRay> Igloo: I have a working gunzip prototype now.
14:15:20 <CosmicRay> Igloo: thanks for pointing me to inflate :-)
14:23:25 <SyntaxNinja> CosmicRay: is that in Haskell? 
14:23:32 <CosmicRay> SyntaxNinja: yes.
14:23:37 <SyntaxNinja> CosmicRay: because if so, wedefinitely need it in the cabal, along with zip
14:23:42 <SyntaxNinja> actually, I guess we really only need zip
14:23:45 <SyntaxNinja> or gzip
14:23:50 <CosmicRay> gzip is here
14:23:58 <SyntaxNinja>  /msg gzip come here
14:24:12 <CosmicRay> I'm aiming to port zip and tarfile from python yet.
14:24:19 <SyntaxNinja> where's gzip?
14:24:30 <CosmicRay> just checked into my arch tree for missingh
14:24:34 <CosmicRay> it is not done yet
14:24:40 <CosmicRay> but it does decompress a gzip file already.
14:24:40 <SyntaxNinja> I guess we need zip since windows users would want that
14:25:00 <tromp> there was an article in special issue journal "Functional Pearls" on a functional Burrows Wheeler transform
14:25:01 <CosmicRay> I have igloo's inflate in my tree
14:25:01 <SyntaxNinja> this is for ./setup sdist which right now does "system "gzip ..."
14:25:11 <CosmicRay> since we have that, it is just a matter of parsing the zip file format
14:25:11 <SyntaxNinja> "
14:25:13 <CosmicRay> which is not all that bad
14:25:17 <CosmicRay> I've already done it in Python
14:25:38 <CosmicRay> wrote my own zipfile because the standard one was too slow on 400MB zip files :-)
14:26:31 <SyntaxNinja> schveet
14:26:39 <CosmicRay> I think tarfile will be worse, really
14:26:44 <SyntaxNinja> ping me when you get it done, or patch cabal and send me the patch :)
14:26:50 <CosmicRay> heh
14:27:02 <CosmicRay> I'll post an announcement on the list
14:27:09 <CosmicRay> the general list
14:27:30 <CosmicRay> I'll try to remember to cc you :-)
14:27:43 <SyntaxNinja> thanks :)
14:27:51 <SyntaxNinja> you mean haskell@ or libraries@? :)
14:27:55 <CosmicRay> haskell@
14:28:48 <SyntaxNinja> it's pretty usual to announce libraries on the libraries list, fwiw.
14:29:37 <SyntaxNinja> the discussion about what goes into the  fptools library tree happens on there, so it's good to get awareness of your libraries onto that list
14:29:46 <CosmicRay> ok.
14:30:08 <Igloo> I thought nothing new was going in?
14:30:23 <Igloo> Or is it going in but not being put in compiler tarballs or something?
14:31:45 <CosmicRay> hey igloo, one thing we need for gunzip is to get at the data in the input after the inflation is done
14:32:03 <SyntaxNinja> Igloo: I'm speaking in general, but for instance if cabal needs unzip, then it should go in, same with this parsing library that he wrote.
14:32:06 <CosmicRay> I can't quite figure out what hack to make to get your code to return a "remainder of input" list
14:32:13 <CosmicRay> is is that what the [Bit] is?
14:32:21 <Igloo> I think so
14:32:25 <CosmicRay> ok.
14:32:32 <SyntaxNinja> I'll bbiab, I need to try to make-go my monitor
14:32:42 <CosmicRay> well this will be slow but I guess it'll work.
14:32:54 <CosmicRay> Igloo: one can cat gzipped files together and produce a valid result
14:32:58 <Igloo> It would probably be faster to drop n xs once you know the length
14:33:15 <CosmicRay> Igloo: the length is only stored *after* the compressed data in gzip
14:33:34 <CosmicRay> so I don't know where to read it until I've run through inflate anyway
14:33:51 <Igloo> But you won't have to convert the Bits back into Chars
14:34:08 <Igloo> OTOH it'll mean keeping the input around, so if that's an issue then there's a tradeoff
14:34:12 <CosmicRay> that is an issue
14:34:20 <CosmicRay> I'll just bang the bits back to chars for now
14:34:31 <CosmicRay> can optimize it later.
14:34:35 <CosmicRay> it's pretty rare to see such a file anyway.
14:35:01 <Igloo> It's not going to be blindingly fast anyway  :-)
14:35:13 <CosmicRay> true 
14:56:34 * stepcut figures out if he should use the ctk lazy lexer or parsec
14:58:08 <np_hard> rerehi
15:00:01 <SyntaxNinja> I don't think the resolution is quite right, but I'm bored messing with it
15:01:07 <stepcut> heh
15:01:20 <stepcut> shouldn't you be writing haskell code or something !?
15:01:26 <np_hard> has anyone here used SLIME for common lisp
15:01:28 <np_hard> ?
15:01:34 * Riastradh
15:02:05 * np_hard wants it for Haskell
15:02:06 <np_hard> :)
15:02:38 <Riastradh> Sorry, I'm already too busy writing a SLIME-like environment for Scheme48.
15:04:00 <np_hard> in emacs or standalone?
15:04:59 <Riastradh> I'm first rewriting Scheme48's built-in interactive environment so it can more easily be extended to support remote & other modes of interaction.
15:05:50 <Riastradh> Without an Emacs mode in the end, it would be almost useless, unless I were to make a full-fledged IDE around it.
15:06:20 <CosmicRay> @index toIntegral
15:06:20 <lambdabot> bzzt
15:06:21 <np_hard> you could be targeting some other environment
15:06:23 <CosmicRay> @index fromIntegral
15:06:23 <lambdabot> GHC.Real,Prelude
15:06:27 <np_hard> eclipse for example
15:06:30 <np_hard> [guffaw]
15:35:20 <shapr> lesson learned: hard packed snow might as well be ice for all the traction it affords
15:35:49 * shapr hops tiredly
15:35:53 <musasabi> lesson learned - port-wine tastes too good.
15:36:02 * shapr grins
15:36:24 <shapr> sake is my weakness
15:37:13 <blackdog> port's fine right up to the point you forget that it's port and start knocking it back like ordinary wine... :)
15:37:18 <musasabi> sake is passable warm, but I don't really like it.
15:37:46 <blackdog> shapr: can you recommend an interface for darcs in emacs?
15:37:53 <SyntaxNinja> M-x shell
15:37:55 <SyntaxNinja> ;)
15:38:03 <blackdog> :) Fair enough. 
15:38:26 <blackdog> I saw something called darcsum.el, but I wasn't going to risk it unless you lot were...
15:39:29 * SyntaxNinja doesn't actually know
15:39:38 * Riastradh has heard good things about darcsum.el, but he hasn't gotten a chance to use it.
15:44:56 <jadrian> IMO, KDEs Cervisia is pretty cool to browse CVS repositories, it's a shame it doesn't handle multiple revision systems
15:45:29 <jadrian> I use it all the time to see diffs between versions, Kompare output is quite nice
16:13:18 <wolfman8k> does ghc compiler output code that uses the malloc system call?
16:18:18 <musasabi> 1) malloc is not a system call 2) you can use malloc via ffi 3) ghc uses it's internal allocator 4) that maybe calls malloc on some platforms.
16:20:28 <wolfman8k> about 4: what happens if malloc fails?
16:21:29 <musasabi> wolfman8k: an out of heap exception should be thrown.
16:21:54 <musasabi> wolfman8k: in practise things like trashing and OOM-killer might strike sooner.
16:21:59 <wolfman8k> exceptions can be thrown from pure functions?
16:23:33 <jadrian> well error throws an exception... 
16:23:35 <jadrian> right?
16:23:46 <jadrian> it can be caught in the IO monad
16:24:19 <musasabi> wolfman8k: yes.
16:24:44 <jadrian> throw :: Exception -> a
16:25:32 <musasabi> "Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell" - http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/ is very good.
16:25:44 <wolfman8k> cool thanks
16:26:04 <jadrian> I've wondered before why this cannot be generalized
16:26:17 <jadrian> for instance for logging functions
16:26:37 <jadrian> you'd throw the values you want
16:26:50 <jadrian> they would change the semantics of your pure function
16:27:09 <jadrian> and then you'd catch them in a IO monad
16:27:38 <jadrian> could be useful for instance to count the number of times a certain function is applied
16:27:44 <musasabi> jadrian: read the paper.
16:28:06 <jadrian> musasabi: k, guess I should, thanks for the tip
16:28:33 <musasabi> (it explains iircs why that is not possible and I really have had too much port to be very sensible)
16:28:57 <jadrian> k :)
16:29:12 <wolfman8k> i read this paper before about this idea of having exceptions as values
16:30:18 <jadrian> hmmm the paper is not available there, but citeseer has it 
16:30:24 <musasabi> Well one has to think about Control.Exception and Control.Monad.Error as very different things on the semantic level. (of course they can be used for the same purpose)
16:31:28 <wolfman8k> btw, i tried building fudgets, but it says that i don't have module CCall
16:32:41 <jadrian> musasabi: I haven't even used Control.Monad.Error yet, I feel more confortable using an  "(Either Error) a" monad
16:33:13 <musasabi> jadrian: Either Error is precisely Control.Monad.Error ;)
16:33:54 <jadrian> musasabi: it is? hmm so throw is just Left and return is right?
16:34:06 <musasabi> wolfman8k: I tnink there are newer snapshots of fudget (marked unstable or something similar) that may work better, but I haven't used fudgets myself.
16:34:28 <wolfman8k> i tried a recent one from 2003, and an older one. both reported the same missing CCall module
16:34:58 <jadrian> musasabi: s/is right/is Right
16:35:35 <wolfman8k> brb going to the shitter
16:38:15 <musasabi> yes (throwError)
16:38:20 <musasabi> but => sleep
16:38:28 <jadrian> musasabi: but for instance, with (Either Error a) I can filter all Lefts
16:38:33 <jadrian> musasabi: k good night!
16:38:50 <musasabi> night.
16:44:16 <jadrian> eh got it
16:44:37 <jadrian> nice :)
16:45:16 <SyntaxNinja> they could hafve at least done that www.cnn.com/blah/blah@world-cnn.com/blah/blah trick ;)
16:45:44 <jadrian> SyntaxNinja: ?
16:45:44 <SyntaxNinja> er, sorry, wrong channel. thought this was #darcs
16:45:49 <jadrian> :)
16:45:50 <SyntaxNinja> sometimes its hard to tell the difference
16:52:37 <jadrian> not exactly useful
16:52:52 <wolfman8k> back
16:52:57 <jadrian> but it would make sense to define  instance MonadError () Maybe where 
16:57:59 <jadrian> besides catchError a isError function would be nice...
16:58:40 <jadrian> there seems to be no way to filter out all errors from a list
17:30:54 <CosmicRay> I'm trying to hack up a crc32 for gzip.  It differs from the standard posix crc32 algorithm in that it "The zip(1) crc; uses the posix crc polynomial with the high powers
17:30:54 <CosmicRay> in the lower checksum bits."
17:31:08 <CosmicRay> does anybody know what that means?
17:32:28 <CosmicRay> I can't really find a reference to polynomials in the checksum I have
17:32:39 <CosmicRay> unless perhaps it has something to do with the bug table of 256 word32s
17:34:05 <Igloo> Isn't the gzip format itself in an RFC too, or do I misremember?
17:34:14 <CosmicRay> it is
17:34:17 <CosmicRay> RFC1952
17:34:20 <arjanb> maybe it has a reversed bitorder in the checksum..
17:34:42 <CosmicRay> I'm looking at that.  It doesn't appear to be quite that simple, but it may yet hold.
17:34:49 <Igloo> Probably also easy enough to see what's going on in the C impl with gdb
17:35:08 <CosmicRay> Igloo: I've looked at the source for gzip
17:35:16 <CosmicRay> Igloo: it's heavily optimized and rather opaque to me
17:35:43 <CosmicRay> Igloo: there is a sample implementation in the rfc, however the algorithm is significantly different from that which I already have in haskell or C.
17:35:59 <CosmicRay> the C version uses the same 256-word table as the Haskell POSIX version
17:36:46 <Igloo> Do you not basically just need updcrc and maybe a setup/teardown function somewhere?
17:37:43 <CosmicRay> Igloo: that's what I would have thought
17:37:46 <CosmicRay> but here's what I have:
17:37:49 <CosmicRay> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/crypto/crc32.hs
17:38:09 <CosmicRay> the update function is intermixed with another one that appears to depend on the length of data already processed
17:38:15 <CosmicRay> which is a major difference from any other algorithm I've seen
17:39:29 <Igloo> Huh? That's not the same table I have
17:39:51 <CosmicRay> really?  that code produces the same result as cksum(1), which is POSIX checksum
17:39:57 <CosmicRay> and uses the same table as gzip
17:40:02 <CosmicRay> you have a crc32 algorithm in haskell?
17:40:20 <Igloo> I'm looking at gzip's util.c
17:40:21 * CosmicRay slaps self.  why didn't you ask igloo first? :-)
17:40:23 <Igloo> Which has
17:40:24 <CosmicRay> oh.
17:40:25 <CosmicRay> hmmmm
17:40:28 <Igloo> ulg crc_32_tab[] = {
17:40:28 <Igloo>   0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
17:40:30 <Igloo> ...
17:40:45 <CosmicRay> that's where I was looking.
17:40:55 <CosmicRay> I wonder why I thought it was the same, now.
17:41:40 <CosmicRay> sigh.
17:41:58 <CosmicRay> sorry to bother you, I'll try using that table and see what happens.
17:42:14 <Igloo> I seem to have an hlibs/crypto/crc32.hs
17:42:29 <Igloo> Is that where you started from?
17:42:33 <Igloo> Looks the same
17:42:39 <CosmicRay> that sounds like the same
17:42:48 <CosmicRay> I just googled for haskell crc32 and arrived at that sf cvs link
17:45:27 <CosmicRay> well, that made a difference.  it's not right yet but maybe it's closer.
17:46:00 * Igloo suspects it's actually a different algorithm
17:47:14 <CosmicRay> could be.
17:48:41 <CosmicRay> well, guess I'll go write my own.
17:58:57 <jadrian> I have [x0,..,xn] I'm going to sort it using the values [f(x1),..,f(xn)]
17:59:16 <jadrian> sortBy could be used by defining the appropriate compare function
17:59:33 <jadrian> but that would mean re-evaluating f(xi)
17:59:47 <jadrian> The obvious way seems to be 
17:59:57 <jadrian> zip xis with f(xis)
18:00:04 <jadrian> order by the 2nd field
18:00:22 <jadrian> and then unzip and get the 1st list
18:00:27 <jadrian> ...
18:01:08 <Igloo> Can f xi == f xj for any i /= j?
18:01:30 <jadrian> yeap
18:01:36 <jadrian> it's not injective
18:02:09 <Igloo> That's about the easiest then, yeah
18:02:24 <jadrian> and I'm always using this kind of pattern, with sort, insert, group
18:03:03 <CosmicRay> Igloo: yup, that got it.  it's working now.
18:03:18 <Igloo> Cool
18:03:20 <jadrian> since it's not in the libs I was wondering if there was a strightfowrard implementation that I'm missing
18:04:04 <Igloo> I suggest calling the module Foo.CRC32.GZip if the current one is Foo.CRC32
18:04:20 <CosmicRay> I have CRC32.POSIX and CRC32.GZip now
18:04:54 <Igloo> Ah, OK
18:05:16 <Igloo> I'd follow System.Posix's capitalisation, though
18:05:23 <CosmicRay> ok, will do, thanks
18:20:21 * jadrian wants parameterized modules :(
18:27:33 <Lemmih> mkFeature :: (GoodIdea a) => Research Paper -> Work -> Feature a
18:41:07 <jadrian> Lemmih: how about,  mbMkFeature :: (Idea a) => Research Paper -> Work -> Maybe (Feature a)
18:42:38 <Lemmih> (o:
18:54:51 <CosmicRay> igloo: have you ever benchmarked your inflate?
18:55:34 <Igloo> No idea
18:56:11 <Igloo> But it was designed to be simple and clearly correct, no fast. I very much doubt [Bit] is at all efficient, for example
18:56:30 <CosmicRay> that is a fine way to write things
18:57:03 <Igloo> Well, depends what you want them for  :-)
19:00:29 <CosmicRay> hmm, this is weird.  it expanded 40,612 more bytes than I put into this one file full of 10MB worth of \0
19:01:42 <Igloo> That's about 1 in 246. Is that the largest repeat in the table?
19:01:49 * TheHunter is back (gone 05:44:28)
19:02:18 <CosmicRay> hang on, I'm doing osme more checking here....
19:04:31 <CosmicRay> make that 40642.
19:04:41 <CosmicRay> user error (HUnit:expected: 10485760
19:04:41 <CosmicRay>  but got: 10526402)
19:04:46 <CosmicRay> would you like me to send you the file?
19:05:13 <CosmicRay> It's a .gz but I can strip the header off for you
19:05:39 <Igloo> OK, that's 1 in 258, which is the maximum
19:05:45 <TheHunter> wnoise, sorry about aborting that conversation so quickly. I'm not arguing against a Nat type and I really think views are a good idea, but as long as we don't have one of those, (n+1)-patterns do more good than harm.
19:07:08 <CosmicRay> Igloo: the reason I asked about the benchmarking is that it took a couple of minutes to process this the first time.  But I think it was because hunit was storing the whole thing, then running show in a 10MB string full of \NUL.  When I just ran the calculation on the length, it only took a couple of seconds.
19:07:35 <Igloo> Can you easily try files with 0 through 1000 zeroes and see which fail?
19:07:37 <CosmicRay> which is a good deal slower than C, but still quite respectable!
19:07:49 <mwc> What's a good article/tutorial if I'm tinerested in learning functional programming with Haskell?
19:07:53 <CosmicRay> hmm, I probably could.
19:08:08 <mwc> Found a lot of haskell tutorials taht claim they presume familiarty with functional prog
19:08:39 <CosmicRay> mwc: http://www.isi.edu/~hdaume/htut/
19:08:54 <CosmicRay> also, this one: http://www.merjis.com/developers/ocaml_tutorial/
19:09:13 <CosmicRay> that second one is for OCaml, but it will still show you some of the same concepts as you have in haskell
19:09:25 <wagle> igloo dump the listing of the directory into a list, and check the strings..  no need to do 1000 stat() syscalls
19:09:43 <CosmicRay> there aren't a lot of good intros to Haskell for people that are not familiar with functional programming already
19:09:44 <Igloo> wagle: Huh?
19:10:00 <mwc> CosmicRay: thanks, that's what I've been finding
19:10:00 <Igloo> wagle: We're talking about debugging a decompressor
19:10:06 <CosmicRay> wagle: we have to compress these varying-sized inputs with deflate before we can test them, and there is no deflate in haskell yet
19:10:15 <wagle> 19:07 < Igloo> Can you easily try files with 0 through 1000 zeroes and see 
19:10:15 <wagle>                which fail?
19:10:31 <Philippa> CosmicRay: I'm tempted to have a go at writing one which /starts/ with the IO monad
19:10:45 <Philippa> very, very twisted idea, I appreciate...
19:10:59 <CosmicRay> Philippa: you are the *third* person in the last 24 hours that has mentioned that to me
19:11:04 <Philippa> heh
19:11:09 <CosmicRay> Philippa: darcs pull http://darcs.complete.org/haskell-v8
19:11:12 <wagle> hmm.  i wokeup and thought you were looking for an availble suffix for a file name
19:11:16 <CosmicRay> Philippa: I already have 15 pages of that document done.
19:11:21 <Philippa> cool
19:11:32 <CosmicRay> Philippa: patches welcome
19:12:05 <CosmicRay> Philippa: apt-get install gtk-doc-tools sgml2x docbook-utils jade scons xpdf-utils to be able to build it
19:12:12 <CosmicRay> Philippa: then run "scons pdf" to build a pdf.
19:12:21 <Philippa> and if I'm not running Deviant?
19:12:35 <Igloo> You can download ISOs
19:12:40 <CosmicRay> <grin>
19:12:49 <CosmicRay> well it's docbook and latex stuff, you can probably find them in your distro
19:12:51 <Philippa> Igloo: I have an install on here...
19:12:52 <CosmicRay> or I can dcc you a pdf
19:12:57 <Philippa> pdf's prolly best for now
19:13:04 <Philippa> as I'm not even running a *nix-based OS
19:13:07 <CosmicRay> ok one min.
19:13:09 <Philippa> (I mean, I use LaTeX fine)
19:14:14 <Igloo> *sigh*, I think having my gf's music in minstrel will get me writing the filtering code sooner
19:14:39 <wnoise> TheHunter: That's okay, I had to go relatively quickly myself.  I actually don't like the idea of a builtin Nat type.  You either don't have operations like '-', or have to deal with the cases where the result is not representable as a Nat.
19:14:48 <CosmicRay> Philippa: this is extremely preliminary, and sucks in several ways
19:17:33 * Philippa nods - such is any "real" work though
19:17:36 <CosmicRay> @index system
19:17:37 <lambdabot> System.Cmd,System
19:17:57 <CosmicRay> @type System.Cmd.system
19:17:58 <lambdabot> System.Cmd.system :: String -> IO GHC.IOBase.ExitCode
19:18:17 <wnoise> TheHunter: I suppose you could only expose Succ and Zero, and build a maybeSubtract type operation.
19:18:25 <TheHunter> wnoise, on the other hand, there are quite a few functions whose "natural" domain are the naturals. Actually, the additional lazyness Nats provide is needed rarely, but that might be because nobody is used to them.
19:18:25 <Philippa> does MissingH include an unfoldM?
19:18:50 <TheHunter> wnoise, i really like the idea of views...
19:19:52 <wnoise> Oh, agreed, and there's also plenty whose range is the naturals.  Views would be neat, and get rid of my "special case" objection to n+k patterns.
19:20:41 <wagle> "views"?
19:20:54 <TheHunter> well, i'd be fine if there were only n+1 patterns.
19:21:35 <wnoise> http://www.haskell.org/development/views.html
19:21:36 <TheHunter> wagle, views allow you to do pattern matching in a way that doesn't represent the actual structure of a datatype.
19:22:04 <wli> use the bijection between naturals and integers?
19:22:21 <wagle> "pattern matching views"?  i wrote a reminder to figure out whatgg they were, but forget why i wanted to know
19:23:03 <wnoise> wli: what do you mean by that?
19:23:51 <CosmicRay> Igloo: all counts less than 260 work fine
19:23:55 <TheHunter> so you could define a view of the integers were you can pattern match (Succ n) and 0 (i'm not really sure you can do that with the proposoal, in any case there should be in error for negative ints)
19:24:13 <CosmicRay> Igloo: starting with a file containing 260 zeros, it gives too many results for, from a quick glance, every single instance
19:24:19 <wnoise> There's a homomorphic injection, but no "natural" bijection.  They're both infinite, so there's plenty of ways of constructing bijective maps between them, but not that preserve structure.
19:24:22 <CosmicRay> Igloo: for the file with 260 zeros, it yields 261
19:24:37 <CosmicRay> Igloo: for the file with 1000 zeros, it yields 1003
19:24:38 <Igloo> Can you give me the last right one and first wrong one please?
19:24:55 <CosmicRay> the file itself or its length?
19:25:08 <Igloo> The file (preferably just the bit to feed to Inflate)
19:25:18 * Philippa wonders what's wrong with defining views as separate types and using View classes w/toView funcs
19:25:25 <wagle> uncountably many bijections?
19:25:26 <CosmicRay> ok.  Just a bit while I write something to strip off the gzip header.
19:25:50 <wnoise> wagle: one of the standard examples is being able to pattern match complex numbers as either A + Bi or r exp (i theta) form.  Neither would actually have to be the real constructor...
19:25:50 <TheHunter> wli, actually almost any type has an countable range, and you can construct bijections between any two of them, so ther's no point in considering types "up to bijection"/
19:27:38 <wagle> wnoise: ooo!..  i've been wanting to do dimensional analysis, and wanted automatic conversion between units
19:27:40 <TheHunter> Philippa, the explicit use of the toView/fromView functions.
19:27:51 <jdrake> friends! Can anyone tell me the appropriate place to put something like the hugs graphics library? It doesn't seem to have a typical install instructions, and I don't want to put it under ~ like it says
19:28:12 <wli> maybe it is useless
19:28:35 <wagle> put it in the hugs lib directory?
19:29:11 <CosmicRay> igloo: shall I e-mail?
19:29:17 <jdrake> wagle, the only thing is I am not sure how that even works because there doesn't seem to be any other dylibs in there
19:29:23 <TheHunter> Philippa, uhh, sorry, i mean the fact that you can define an abstract interface that is accessible by pattern-matching for a datastructure without having to expose the implementation.
19:29:24 <Igloo> Unless web is easy for you
19:30:01 <CosmicRay> Igloo: http://www.complete.org/~jgoerzen/foo.zip
19:30:07 <TheHunter> wagle, automatic conversion of units is possible, if you have a firm understanding of the type system
19:30:13 <wagle> are pattern patching views implemented anywhere?
19:30:20 <Igloo> Ta
19:30:21 <CosmicRay> Igloo: there are two files in there.  z259 was the last successful one.  z260 was the first bad one.
19:30:40 <CosmicRay> Igloo: there will be 8 bytes of extra data at the end that are gzip data structures, but they shouldn't mess you up
19:30:46 <CosmicRay> Igloo: I have stripped off the gzip headers.
19:31:04 <wagle> TheHunter: i got it to sort of work, but way more dynamically than i wanted
19:31:20 <Igloo> OK, ta
19:31:39 <Philippa> TheHunter: you can define toView and then not expose any of the constructors, that good enough?
19:32:14 <wnoise> wagle: Oh, hmm.  Not sure how that'd work. For checking units using the type-system I'd use a n-tuple of integers (lifted to the type-level), where n is the number of different units you do dimensional analysis on.  I wouldn't worry about conversions.  And if you only care to do it at runtime, you don't lift it to the type system, and have a much saner implementation.  And I'd just use functions to inject feet into an SI based syst
19:32:14 <wnoise> em, or take them out, rather than views.  But I suppose that could work.
19:32:25 <TheHunter> Philippa, nope, doesn't feel right.
19:32:27 <Philippa> to go a step further, you could just accept anything that supports the relevant toView
19:32:34 <Philippa> is there more than a "feel right" to it?
19:33:28 <TheHunter> wnoise, i remeber something (oleg-style) on the mailing list in the thread "a sample revised prelude..."
19:33:34 <Philippa> (I ask seriously - the idea of implementing views themselves in Tyop gives me shivers in a bad way, it amounts to implicit casts, but the typeclass variant I could even add syntactic sugar for and the libraries'd lean towards it)
19:33:49 <wagle> i want to make it statically impossible to use feet at a unit of velocity..  and i want to make it statically impossible to accidentily use feet as centimeters
19:34:30 <wagle> its also half thought experiment...
19:34:51 <Philippa> I think I did the same thought experiment thinking in C++ a few years ago
19:35:22 <wagle> so i'm thinking i want type inequalities..  (howzat for avoiding saying the evil "subtype" word?)
19:35:27 <Philippa> heh
19:35:32 <wnoise> Implicit casts?  No.  Each view only corresponds to one type -- no conversions possible.
19:35:48 <wagle> Philippa: yeah..  i did one in java
19:35:55 <Philippa> it's still an implicit cast, just one with a fundep
19:36:14 <wnoise> I still don't see it.
19:36:36 <Philippa> from the data's format to that imposed by the view
19:38:19 <Philippa> heh. I really /really/ need to include a cookbook of Tyop tricks as an appendix when I finally submit the damn thing
19:38:22 <wagle> http://www.haskell.org/development/views.html is dated oct 23 1996?
19:39:26 <wnoise> I guess, but that's not all how I conceptualize it. It's just not privileging the constructors for taking it apart.
19:40:19 <Philippa> yeah, looking at it that way just makes the typing and so forth a PITA though
19:40:32 <wagle> where are view's implemented?
19:40:38 <Philippa> I've no idea
19:40:44 <wnoise> wagle: I don't believe they are.
19:40:48 <Philippa> I know they were later considered a bad idea for Haskell
19:41:11 <Philippa> I think the existance of a typeclass-based fix that's more powerful probably didn't help the case for them
19:41:29 <wli> what's the typeclass -based fix?
19:41:30 <TheHunter> views are certainly not the most important thing to implement in a functional language, but they can be neat in some cases, maybe (i'm never sure about such claims) improve modularity. But you can view them as syntactic sugar for pattern guards as well.
19:41:40 <wagle> then why do i want to figure them out?  8)
19:41:47 <Philippa> wli: variants on View-with-toView
19:42:26 <wnoise> well, almost everything in haskell can be viewed as syntactic sugar for the core language...
19:42:42 <TheHunter> wnoise, yeah, you're right.
19:43:26 <wagle> can a programmer directly code in the core language?  (by normal means)
19:43:49 <Philippa> wagle: depends what you consider it to be. For Core Haskell (cf Core ML), sure, it's a syntactic subset
19:43:52 <blackdog> Sure, ghc will compile .hcr files. :)
19:44:04 <TheHunter> oh, crap, I really gotta go to bed.
19:44:07 <Philippa> if you mean Core as in GHC's intermediate, yes but it's a snakepit
19:44:11 <Philippa> you too, huh? :-)
19:44:15 <blackdog> oh yes.
19:44:29 <TheHunter> good night everybody.
19:44:48 <blackdog> Philippa: what are you using external core for?
19:44:56 <wagle> i'm claiming syntactic sugar is an _alternate_ way for the programmer to express something..
19:45:07 <wagle> hmm..  programmer vs. compiler..
19:45:28 <Philippa> blackdog: I'm not, but I flicked through the docs and there're awkward bits
19:45:42 <wagle> its the programmer how uses syntactic sugar, not the compiler
19:45:44 <Philippa> was wondering how hard it'd be to compile Tyop to core
19:45:47 <wagle> s/how/who/
19:45:55 <Philippa> TH fixes all?
19:46:09 <wagle> TH can wrote core/
19:46:18 <wagle> TH can write core?
19:46:19 <Philippa> I really ought to get round to a quickie TH+monad transformers = cheap compiler hack
19:46:27 <Philippa> no, TH adds syntactic sugar :-)
19:46:53 <wagle> really?  i thought the claim was TH couldnt add new syntactic forms
19:47:16 <Philippa> FCVO "syntactic form" - you can do the equivalent of lisp macros, you just need to call 'em with a $
19:47:31 <Igloo> Aaarggh, they have viciously tricked me
19:47:41 <CosmicRay> oh?
19:48:16 <Igloo> For some reason 284 maps to 31 possibile values, not 32
19:48:20 <Philippa> you can reparse the AST into a different shape with it, so if you can get something to be valid concrete syntax, you're sorted
19:49:34 <wagle> i grow discouraged with the news that you couldnt even type in the examples from the original th paper, and am waiting to get energetic enough to beat my way through converting them to the current syntax
19:49:57 <Philippa> I did a little playing about purely with stuff I wanted to try
19:50:13 <Philippa> helps if you're willing to play with the ADTs that match the AST
19:50:19 <jdrake> I am getting that haskell school of expression book, hopefully it will be good
19:51:05 <Igloo> OK, if you pull now it'll hopefully be fixed
19:51:14 <CosmicRay> sweet
19:51:21 <CosmicRay> thanks much!
19:51:36 <wagle> jdrake: i also liked Haskell: The Craft of Functional Programming
19:52:08 <wagle> SoE seemed a little lightweight
19:52:22 <jdrake> wagle, in this case price is everything :-)
19:52:33 <CosmicRay> Igloo: nope, only an "initial checkin" patch there
19:52:33 <wagle> heh
19:52:40 <CosmicRay> hmm.
19:52:42 <CosmicRay> wait a set.
19:52:50 <Igloo> Oh, I didn't push to the public repo
19:52:54 <CosmicRay> ah
19:53:02 <Igloo> Try that
19:53:14 <CosmicRay> there we go
19:54:30 <jdrake> wagle, that book is 77,85$ and the soe is 32,86$
19:55:03 <wagle> yow
19:55:17 <CosmicRay> Igloo: you da man!  that fixed every single problem.
19:55:39 <jdrake> there is always this one... http://www.chapters.indigo.ca/item.asp?Item=978052127724&Catalog=Books&N=35+528236&Lang=en&Section=books&zxac=1  but it is only from 1992, so its a little dated
19:56:06 <Igloo> Well, thank you for writing a testsuite and finding a problem!
19:56:31 <jdrake> I don't see any other appropriate books anywhere near acceptable price range, and soe is on sale I suspect 
19:57:10 <jdrake> Chapters and Amazon both have that free shipping for 39,00$ or more, mine is 39,05$ :p
19:58:07 <coryb> heh
19:58:25 <jdrake> gives me a bunch of time to try to get the libraries I need for the thing to work on my machine because it doesn't seem to be made for mac
19:58:29 <coryb> the haskell school of expression book is one of the texts for the programming language paradigms class I'm taking
19:59:07 <jdrake> one thing that would be interesting is table based programming have you covered any of that?
20:08:58 * Igloo goes to bed
20:42:55 <CosmicRay> Igloo: you may want to play around with ghc +RTS -s and inflate
20:43:10 <CosmicRay> Igloo: it appears to require 208Mb to deflate 10Mb of zeros
20:44:02 <Darius> Well, if it's encoding bits as a Bool... that's not too surprising.
20:44:10 <Darius> (and using Strings)
20:44:22 <CosmicRay> but it's lazy
20:44:34 <Darius> true
20:44:41 <CosmicRay> so as soon as it's processed a given block, shouldn't th ememory be freed (as long as the caller doesn't store it?)
20:44:50 <CosmicRay> I'm just calling length on the list it returns
20:44:53 <Darius> (or is it really?)
20:45:26 <CosmicRay> I must admit the code is a bit opaque to me
20:46:11 <Darius> Well, calling length on the list just touches the spine and as the information likely needs at least some of the earlier bits to know even whether another is coming that might lead to large thunks and retention.
20:46:37 <Darius> how does it behave showing the bits (or deepSeqing)?
20:47:16 <CosmicRay> you want me to call show in a 100megabit list of bools?
20:47:24 <CosmicRay> I'm not quite sure I follow
20:48:01 <wagle> ugh.... 
20:50:12 <wagle> jpeg in haskell has the "ginormous list of bools" problem too
20:51:12 <heatsink> ginormous? whence comes this strange word?
20:51:44 <wagle> allegedly bluespec has some bit manipulation, but they went proprietary (and removed everything from the web) about 2 weeks before i tried to look into it this summer
20:52:03 <wagle> ginormous = gigantic + enormous
20:52:20 <wagle> blame Curt Lively..  its not my fault!
20:52:24 <heatsink> who?
20:53:16 <wagle> http://www.bio.indiana.edu/facultyresearch/faculty/Lively.html
20:53:19 <heatsink> I ask because "ginormous" seems to be less than a year old
20:53:40 <blackdog> no way. I heard that one when I was a kid...
20:54:02 <wagle> it was one of his favorite words in a graduate level evolution class he taught in 1995
20:54:23 <wagle> ENOBATTERY
20:54:33 <heatsink> ENOENT
20:55:19 <heatsink> Why do these words hide from me?
20:56:13 <Riastradh> They fear you.  To a word, you're a really intimidating kind of guy.
20:56:50 <Darius> CosmicRay: Sure why not? Except it will be printing False for quite a while (hence deepSeq may be better) it shouldn't be that bad.
20:58:09 <heatsink> My. This I have never noticed of myself. I shall try to be less fearsome.
20:58:23 <Darius> Or rather the question is whether it is that bad, but just Ctrl-C if it is.
20:58:58 <CosmicRay> Darius: isn't there a better way to test?
20:59:21 <CosmicRay> I could always do that, but it just seems inefficient...
21:00:18 <CosmicRay> actally, it is returning a list of Word32s
21:00:25 <CosmicRay> the Bool seems to be an internal thing only
21:00:34 <Darius> What does efficiency matter for a test, except that that's what we are looking for.  Show is just usually effectively a quick deepSeq instance
21:01:02 <CosmicRay> ok, will try it.
21:01:15 <Darius> But deepSeq would also work and would have no extraneous work.
21:01:26 <CosmicRay> arg, got to run
21:01:32 <CosmicRay> thanks for the input, will try it tomorrow.
21:21:26 <Darius> Anyone know how LtU works for posting a new topic.  The interface is obvious except it seems incomplete, like how does one specify a department or does some elf handle that, etc.
21:36:09 <monochrom> Normal users cannot post to departments, only the [one single] forum.
22:51:41 * stepcut lexes and parses
22:55:26 <Helic> yay for another mention of haskell at /.
23:01:17 <blackdog> The cabal's plan proceeds apace. I - wait, I didn't mean it! There is no cabal!
