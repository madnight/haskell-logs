00:00:09 <ibid> but ghc is a memory hog when compiling realistic-size happy parsers
00:00:29 <ibid> even when all productions are annotated with the semantic type
00:00:49 <ibid> other than that, i can't think of a reason why happy would suck
00:01:38 <dons> yep, compiling it is slow. but running it is fast ;)
00:01:48 <musasabi> morning
00:01:53 <dons> probably the huge tables it generates
00:02:40 <stuDale> I just started looking into  haskell, is ghc a good compiler to use?
00:02:50 <ibid> stuDale: for most uses, the best
00:02:53 <musasabi> stuDale: yes.
00:03:18 <stuDale> cool, thank you guys
00:45:30 <Itkovian> any people here using orcut? I have an account since a few months, but alas, it seems to be rather dead-ish, especially the haskell community :-(
00:47:09 <earthy> really? :)
00:49:11 <Itkovian> heh
00:49:50 <earthy> haskell stuff is on the mailinglists
00:50:03 <earthy> and here, ofcourse
00:50:17 <earthy> but goody, I didn't have any unread orkut messages. ;)
01:02:56 <ibid> Itkovian: orkut was a good toy for a few weeks, but when the novelty wore out, there is really no reason to use it
01:09:26 <Itkovian> yeah, well, I can see that :-)
01:12:05 <Itkovian> besides that it's mostly brazilian people in there ...
01:13:13 <aj> how do you implement a type that derives Show?
01:13:34 <musasabi> data Foo = Foo Int Bar deriving(Show)
01:14:43 <ibid> aj: what do you mean?
01:14:56 <ibid> (unless you mean what musasabi said, of course)
01:15:24 <ibid> i'm not sure what "implementing" a type means in this context
01:16:51 <aj> oh, yes, that is what i meant, cool
01:43:19 <boegel> gooooodmorning #haskell
01:48:05 <wli> sukria: it's in binutils
01:48:07 <wli> sukria: also
01:48:15 <wli> sukria: bochs may also be useful
01:57:16 <bourbaki> moin boegel
01:58:23 <boegel> hey bourbaki 
02:21:44 * shapr yawns
02:22:04 * kristnjov gasps
02:31:17 * vincenz boinks
02:32:45 * shapr bops
02:35:52 * heatsink lolls
02:36:01 * Maddas girns
02:37:44 * ibid sighs
03:01:22 * boegel joins
03:23:13 * Itkovian eats
03:34:42 * TheHunter is away: I'm busy
03:50:36 * boegel yawns again
05:41:57 <TheHunter> @moo
05:41:57 <lambdabot>          (__)
05:41:57 <lambdabot>          (oo)
05:41:57 <lambdabot>    /------\/
05:41:57 <lambdabot>   / |    ||
05:41:57 <lambdabot>  *  /\---/\
05:41:58 <lambdabot>     ~~   ~~
05:42:00 <lambdabot> ...."Have you mooed today?"...
05:46:56 <andersca> @arr
05:46:57 <lambdabot> Get out of me way, yeh landlubber
06:03:51 <shapr> @fortune
06:03:51 <lambdabot> "MOKE DAT YIGARETTE"
06:03:51 <lambdabot> 		-- "The Last Coin", James P. Blaylock
06:05:22 <Lemmih> Good evening, shapr.
06:05:27 <shapr> y0
06:05:33 <shapr> The hills are alivee.
06:06:54 <jak> hi shapr 
06:08:24 <boegel> Lemmih: evening ?
06:08:34 <boegel> shapr: with the sound of muuuuuuuuuuuuuuuuuuuuuusic
06:10:01 <Lemmih> boegel: Yes.
06:11:01 <boegel> Lemmih: I thought you were in France ?
06:11:21 <shapr> bringert went to Paris.
06:13:08 * Lemmih is Great Dane! (-:
06:18:55 * TheHunter is away: I'm busy
06:21:36 * shapr is here: I'm not busy!
06:21:53 * shapr is bored: somebody talk to me!
06:23:37 <Lemmih> shapr: How's code?
06:23:46 <boegel> hey shapr ;)
06:24:19 <Lemmih> And you should go unicycling while the sun is still shining.
06:27:18 <jak> does anybody know a cheap hotel in reading?
06:30:23 * wli thinks he has the kernel variable reporting thing down to a matter of GUI programming
06:31:25 <boegel> jak: search the net for Novotel
06:31:41 <jak> oh yes, good idea. 
06:31:51 <jak> I stayed in a Novotel in Portugal once.
06:31:55 <jak> (Lisbon)
06:32:37 <jak> they had nice shampoo
06:37:57 <boegel> jak: and should be a great reason to go back ;)
06:38:24 <jak> indeed. unfortunately no novotel in reading
06:46:21 <MegaMonad> ,"Definitions","del-definition","det","devils","dict","dict-help","dummy","dump","dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc","fortune","gazetteer","get-definition","goodbye","hello","hitchcock","index","info","jargon","join","karma","karma.
06:48:41 <Lemmih> MegaMonad: That greeting sucked.
06:48:47 <MegaMonad> Lemmih: And simply browsing through citeseer and it sucked.
06:49:38 <Lemmih> MegaMonad: A lambdabot copy-cat is what you are!
06:49:43 <MegaMonad> Lemmih: Is lambdabot the same file as a working copy is a cat ?
06:50:47 <shapr> Lemmih: man, we had an hour of sunlight today
06:51:13 <shapr> the sun has been gone for ... three hours I think.
06:51:52 <shapr> hoi tinus, hoe gaat het?
06:52:25 <tinus> hallo
06:52:29 <tinus> prima
06:52:32 <tinus> met jou ook?
06:52:37 <shapr> goed!
06:52:47 <tinus> mooi! :)
06:52:57 <shapr> So, are you learning Haskell?
06:53:11 <tinus> hmm, we use haskell at our uni
06:53:25 <tinus> so we use it for assignments
06:53:48 <shapr> Do you produce assignments or consume them?
06:53:49 <tinus> which is why i have to learn it :)
06:53:52 <tinus> consume :)
06:54:17 <shapr> If you like programming, I think you'll enjoy learning Haskell.
06:54:37 <shapr> It may not end up being your favorite language that you use all the time, but Haskell has many nifty tricks.
06:54:55 <tinus> i know
06:55:00 <shapr> Which university do you attend?
06:55:03 <tinus> i already know haskell for like, 2 years or so
06:55:07 <shapr> Oh, cool!
06:55:10 <tinus> University Utrecht
06:55:13 <shapr> I've only known Haskell for three years.
06:55:20 <shapr> Neat, do you know the Swierstras?
06:55:24 <tinus> well, I am not too good at it 
06:55:27 <tinus> yeah, i do
06:55:37 <tinus> he wrote the reader we use for this course :)
06:55:45 <tinus> and I've had class of him a few times
06:56:04 <shapr> Probably Doaitse Swierstra?
06:56:07 <tinus> but I actually only know one Swierstra
06:56:09 <tinus> indeed
06:56:17 <tinus> he has a son or so? :)
06:56:32 <shapr> My interactions with Wouter Swierstra imply that he's a nice person.
06:57:02 <shapr> Wouter definitely has cool glasses.
06:57:07 * shapr grins
06:57:07 <tinus> heh.
06:57:32 <shapr> So what sort of Haskell class are you taking now?
06:57:43 <tinus> Grammars and Parsing
06:57:55 <tinus> roughly translated
06:57:57 <shapr> Oh, I should probably introduce myself, I'm Shae Erisson, self-employed programmer and web developer.
06:58:16 <tinus> ah cool. where from?
06:58:18 <shapr> I think Haskell is good for commercial programming, though I haven't gotten so many Haskell jobs yet.
06:58:42 <shapr> Born in Alabama, USA, now living in the far north of Sweden.
06:58:55 <tinus> cool. what brought you there?
06:59:06 <xerox> love! ;-)
06:59:08 <shapr> I met this girl on ICQ (50,000 words omitted) and now I live in Sweden.
06:59:14 <tinus> wow!
06:59:20 <tinus> that is nice :)
06:59:29 <shapr> Yah, I like the internet.
06:59:38 <tinus> yeah, I've seen this happening quite often
06:59:54 <tinus> but not on this distance though :)
07:00:09 <shapr> Yeah, it was quite some distance.
07:00:19 <tinus> not just physically, I can image ....
07:00:24 <shapr> My first time visiting Europe, and I only left once to visit my family.
07:01:05 <shapr> So are you using the Attribute Grammars in your class?
07:01:20 <tinus> about the appliance of Haskell for commercial purposes ... I have actually seen it as a "prototype" language.
07:01:35 <tinus> Attribute Grammars?
07:01:43 <tinus> not sure what you mean ..
07:02:00 <shapr> Swierstra/Utrecht developed the attribute grammars.
07:02:08 <tinus> oh right
07:02:18 <shapr> Personally, they look a lot like arrow-style parsers to me, but I'm not yet sure if they're something else.
07:02:45 <shapr> I think the strengths of a prototype language are even more important for maintenance and bug fixing.
07:03:09 <shapr> Speed of change is the most important factor in an application.
07:03:14 <earthy> errrrr....
07:03:21 <tinus> well, see, i dont know a single "real-life" appliance of Haskell, personally.
07:03:27 <earthy> `developed the attribute grammars' is a falsehood
07:03:35 <shapr> earthy: oh sorry, what's the reality?
07:03:39 <earthy> Doaitse and Arthur do a nice implementation
07:03:48 <shapr> Arthur? Arthur who?
07:03:50 <earthy> but Attribute grammars were developed in the '60's by Knuth
07:03:53 <earthy> (Baars)
07:03:56 <shapr> oh
07:04:01 <tinus> yeah
07:04:08 <shapr> Thought you might mean Arthur van Leeuwen
07:04:09 <tinus> they refer to the Knuth grammers in this reader
07:04:10 <earthy> and Doaitse got enamored by them in the 70's.
07:04:32 <earthy> nah, Arthur van Leeuwen 's me. I don't tend to refer to me in the third person. :)
07:04:37 * shapr grins
07:04:44 <shapr> swiert: btw, do you have pix of your new glasses?
07:04:59 <tinus> earthy: your name rings a bell. where might I know you from?
07:05:02 <shapr> earthy: are you coming to estonia for ICFP?
07:05:52 <earthy> I might at that
07:06:02 <tinus> oh, Wouter Swierstra is actually here :)
07:06:02 <musasabi> Anyone knowing any good uses of Control.Concurrent.STM ?
07:06:11 <earthy> tinus: did you take Internetprogrammeren last year?
07:06:12 <shapr> musasabi: what is it?
07:06:19 <shapr> musasabi: is that the new Concurrent primitive?
07:06:26 <tinus> earthy: i did
07:06:27 <musasabi> shapr: yes.
07:06:33 <earthy> well, there you go
07:06:38 <musasabi> Software Transactional Memory.
07:06:49 <shapr> What does it do?
07:06:54 * shapr asks gogle
07:06:57 <shapr> google
07:07:22 <shapr> hm, hits on citeseer, acm, etc
07:07:30 * earthy whistles at the amount of extra data he suddenly has on tinus :)
07:07:30 <tinus> earthy: d'oh. indeed. Looking at your pic now :)
07:07:38 <tinus> earthy: hehe
07:08:15 <shapr> oh, is STM for journaling, ACID, etc?
07:08:34 <tinus> earthy: by last year you mean this year? Because I actually had INP by Jurriaan
07:08:38 <earthy> tinus: you might want to go play with the yampa arcade :)
07:08:54 <shapr> tinus: oh are you doing arrows stuff?
07:08:55 <earthy> tinus: I mean *last* year. as in year 2003/2004 block 2
07:09:20 <shapr> I recently patched Yampa Invaders to work with ghc 6.{2,3}
07:09:23 <earthy> (and yes, I know. I did say `extra data I suddenly have', did I not :))
07:09:33 <tinus> heh.
07:09:55 <tinus> earthy: then I must admit my memory is failing. either that or I visited too few courses ;)
07:10:10 <earthy> the latter, for I would've remembered your face. :)
07:10:11 <tinus> earthy: because I know you, but not from INP i think ...
07:10:15 <earthy> which I dont. :)
07:10:20 <tinus> :)
07:10:34 <tinus> shapr: define "arrows" stuff 
07:10:34 <shapr> tinus: nice postgresql banner
07:10:36 <musasabi> shapr: STM seems to be for performing multiple memory updates in an atomic fashion.
07:10:47 <tinus> haha, I am being scanned here :)
07:10:52 * earthy curses at the state monad's put
07:10:52 <tinus> shapr: thx ;)
07:10:53 <musasabi> simon marlow and panne are behind the commits...
07:10:54 <shapr> googlestalked =)
07:11:04 <Maddas> haha
07:11:42 <tinus> earthy: you give P&C nowadays?
07:11:48 <earthy> um.
07:11:57 <earthy> no, Wishnu still does. I assist though.
07:12:15 <shapr> tinus: very few people use arrows at this point, I'm interested in seeing more uses and applications of arrows.
07:13:32 <tinus> shapr: I am sorry, but I do not get your "arrow" reference. 
07:13:50 <shapr> arrows are the generalization of monads.
07:14:37 <kristnjov> seems like i have to get a grip on monads soon
07:14:50 <musasabi> The nomaware tutorial is quite good.
07:15:41 <earthy> arrows are a generalization of monads
07:15:45 <earthy> functors are another
07:15:58 <wli> I didn't find the nomaware tutorial to be all that great.
07:16:06 <earthy> it isn't
07:17:20 <jak> i thought school of expression was good for monads because it shows you how to use them without necessarily being able to write one yourself
07:18:13 <wli> I wonder if I'll have to write a monad tutorial myself just so one I can get something out of is out there.
07:19:08 * tinus reads up on monads
07:20:20 <shapr> I loved the nomaware tutorial, it brought together all the little pieces I had into a coherent whole.
07:20:54 <shapr> wli: want me to explain monads to you the way I understand them? think it'll help?
07:21:19 <wli> I think I need a large amount of detail. They're "hard" for me in some sense.
07:21:25 <tinus> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm is what I am reading atm
07:21:55 <wli> I think I need a fair number of realistic examples of how the different monads are used dissected in some detail.
07:22:12 <wli> Possibly more than one for each of the stock monads.
07:22:21 <wli> And at least one of winging a new kind of monad.
07:22:52 <wli> That kind of tutorial is what I'm relatively sure does not exist.
07:27:35 <shapr> Was that yes?
07:28:07 <Lemmih> I think people has made monads look a lot more complicated than they really are.
07:28:21 * boegel should really start working on his OO analysis project, but he totally doesn't feel like it
07:28:42 <wli> shapr: might as well give it a shot
07:28:44 * Itkovian thinks boegel can be glad the project has arrived early this year
07:29:23 * boegel 's defintion of early is october, not december :)
07:29:42 <boegel> was it that late last year Itkovian ?
07:30:06 <Itkovian> boegel: I have no idea, I know that it used to be given _after_ the holidays
07:30:13 <boegel> after :s
07:30:34 <boegel> we have to finish it before 17th Jan or so, so that would give us only 2 weeks
07:30:37 <boegel> that not much :)
07:30:43 <boegel> but at least then there's pressure
07:30:52 <boegel> no there's none :s
07:33:01 <shapr> ok, shapr's monads tutorial is: "Monads are an abstraction composed of three pieces, a partially filled in type, and two functions. One function fills a value into the type, the other function stick together two values of an already filled in type. And you have unit and commutative laws."
07:34:38 <shapr> The "fill in a value" function is called return. The "stick together two values" is called bind, but usually written >>=
07:35:01 <Itkovian> shapr: it is one thing to know that, quite another toi understand how to use it, imho
07:35:15 <shapr> I agree, so let's see some more.... First let's ask, what's the motivation of a monad?
07:35:28 <shapr> Like, why should I care?
07:35:39 <CosmicRay> I have a question about the syntax of a class.
07:35:41 <CosmicRay> I have this:
07:35:45 <CosmicRay> class HVFS a where
07:35:46 <CosmicRay> ....
07:35:49 <xerox> Because functions cannot return different things with the same argument
07:35:49 <CosmicRay>     vGetFileStatus :: HVFSStat b => a -> FilePath -> IO b
07:35:57 <CosmicRay> it seems to be causing me lots of trouble.
07:36:00 <shapr> xerox: monads don't change that
07:36:01 <xerox> Mathematecally speaking
07:36:02 <xerox> ?
07:36:14 <shapr> xerox: but it's a good try :-)
07:36:22 <xerox> :-)
07:36:24 <CosmicRay> I have defined an instance of this class, where vGetFileStatus properly returns a value that is an instanve of HVFSStat, but the compilar is barfing all over it.
07:36:27 <CosmicRay> any ideas?
07:36:38 <CosmicRay> (the error is "Cannot unify the type-signature variable b)
07:36:53 <shapr> One of the coolest parts of Haskell is lazy evaluation, but the downside is that you have no idea what will happens in what order.
07:37:29 <shapr> The original purpose of a monad is to let you guarantee that stuff happens in a certain order.
07:37:56 <shapr> It's about predictable ordering in the presence of non-strict evaluation.
07:39:05 * shapr wonders if this a good direction to continue explaining monads
07:39:13 * xerox only wonders
07:39:16 <xerox> *g*
07:39:42 <shapr> I like Cale's explanation of monads as containers - http://www.haskell.org/hawiki/MonadsAsContainers
07:40:34 <wli> I have a rather strong feeling that the conceptual notions are less of an issue than making adequate use of them, which can only be accomplished with practice and other grunt work.
07:40:36 <CosmicRay> shapr: any insight on my compiler error?
07:40:57 <wli> i.e. no 5-minute explanation will do
07:41:00 <shapr> In my opinion, the goal of the monadic interface is to make it easy to reason about code separately, and to allow those same conclusions to work once you stick together the pieces.
07:41:15 <shapr> wli: maybe so... have you looked at the maybe monad?
07:41:28 <shapr> CosmicRay: not at the moment, I'd have to try it myself
07:41:44 <CosmicRay> ok.
07:41:47 <shapr> wli: One view of monads is that you can take a type that represents something and make it 'active'
07:42:04 <shapr> The maybe type represents failure - data Maybe a = Just a | Nothing
07:42:37 <wli> Is there really supposed to be a magic bullet with which one can suddenly start winging new kinds of monads, whipping out monadic solutions to tons of problems, etc.?
07:42:50 <shapr> If you want to lookup an account number, it might not exist, in which case you evaluate to Nothing, otherwise it's (Just 42) or so.
07:43:05 <shapr> Yeah, once monads click in your head, it's no big deal.
07:43:29 <shapr> monads are just an abstraction, just a convention. They make it easy to structure programs.
07:43:35 <wli> Well, I have the basic notion that when you chain the things with >>= the first Nothing propagates to the end.
07:43:51 <shapr> They're an abstraction in the same way that objects in OOP are an abstraction.
07:44:04 <shapr> wli: that's pretty much it...
07:44:49 <aleator> shapr: do you have similar "nutshell tutorial" about arrows?
07:44:57 <shapr> In a procedural language you sometimes end up with a whole bunch of nested if then else statements. The maybe monad is that same structure, but the zillions of statements are abstracted away.
07:45:13 <shapr> aleator: I do, it's even shorter, and far less detailed because my understanding of arrows is vague.
07:45:18 <wli> well, I can do some of the basic stuff like I wrote one thing that uses ErrorT GMError IO for a G-machine bytecode interpreter
07:46:13 <shapr> aleator: Conceptually, arrows are verbs that have been turned into nouns.
07:46:37 <wli> And I have a notion that when you're modelling a state machine, your "new monad" to wing are the state transitions.
07:46:48 <wli> +methods
07:47:25 <shapr> Sounds right to me.
07:47:41 <wli> but things like "substitution is a monad" are far harder to work with adequately.
07:47:42 <aleator> shapr: if it turns verbs to nouns, what does it do to nouns?
07:48:08 <wli> you can sort of understand it by turning it into a state machine -like affair
07:48:14 <wli> but it's inferior to a true understanding
07:48:22 <CosmicRay> @type getSymbolicLinkStatus
07:48:24 <lambdabot> bzzt
07:48:26 <shapr> what kind of substitution?
07:48:31 <wli> syntactic
07:48:42 <shapr> er, like what?
07:49:20 <wli> terms states, substitutions the state transitions, >>= composition of substitutions, or some such
07:49:49 <shapr> Essentially, monads are just sequencing, a >>= b ensures that a happens before b. But another facet is that they're composition.
07:50:27 <shapr> One good approach to learnin is to follow the original community approach. Use of monads started with list comprehensions.
07:50:30 <wli> translating everything into state machine terms is inadequate because you can't read all the code that way
07:50:58 <wli> (you can, of course, always write it that way with enough contortions)
07:51:06 <shapr> I think the list monad was the first commonly understood usage.
07:51:21 <shapr> At the bottom, monads are just funny CPS.
07:51:29 <wli> yes, I caught that too
07:52:00 <shapr> But their value is more than CPS because the convention allows you to assume a bunch of stuff that makes it easier to structure your code.
07:53:39 <shapr> So, a monad is just an interface, a container, code that puts stuff into the container, and code that puts together two containers.
07:53:56 <shapr> With a list, that's [], :, and ++
07:54:57 <shapr> with maybe, that's Maybe a, Just, and (Just x) >>= f = f x ; Nothing >>= f = Nothing
07:56:08 <Itkovian> i'm off
07:56:12 <earthy> same here
07:56:14 <shapr> And I'm leving too...
07:57:11 * boegel watches as #haskell is running empty
07:57:21 <shapr> It's christmas, everyone is going home!
07:57:28 <wli> (++) hrm
07:58:20 <wli> I think (>>=) == concatMap
07:58:43 <shapr> the monad laws are left identity, right identity, and associativity.
07:58:52 <wli> sorry
07:58:55 <wli> I think (>>=) == flip concatMap
07:59:15 <shapr> @type flip concatMap
07:59:17 <lambdabot> flip concatMap :: forall a b. [a] -> (a -> [b]) -> [b]
07:59:24 <shapr> @type >>=
07:59:26 <lambdabot> bzzt
07:59:30 <shapr> @type (>>=)
07:59:31 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
07:59:43 <shapr> wli: notice the similarity in type sigs?
08:00:05 <wli> well, yes
08:00:19 <wli> m == [ ]
08:00:24 <shapr> yup
08:01:48 <wli> the problem you're faced with when trying to program is smoking out a monad
08:02:07 <kristnjov> or finding an ashtray to put your cigarette out in
08:02:09 <wli> back to the state machine
08:02:20 <wli> you've got a bag of transitions and some state
08:02:22 <shapr> I'd probably write the code first, and only switch to a monad when I actually see one.
08:02:28 <shapr> phone...
08:02:48 <kristnjov> "yer hey det are shapr.. ya yag can prata swenska.."
08:02:49 <wli> and the types don't line up
08:02:54 <vincenz> ..
08:04:46 <wli> I thought much the same
08:04:59 <wli> the trouble turned out to be I ended up writing ML with Haskell's type system
08:05:31 <wli> and never bothering with monads at all except where libraries forced it upon me
08:05:36 <wli> (i.e. IO)
08:05:58 <wli> but they are useful, I merely failed to make effective use of them
08:06:12 <wli> which is the substance of my claim that I need to learn how to use monads
08:10:00 <vincenz> why are monads so useful?
08:10:28 <vincenz> also, do you need special language support for monads or can you do them in any functional language?
08:11:26 <wli> to me it seems they are because they're higher-level abstractions, so they enable you to inherit a large amount of functionality relative to the amount of code required to use them.
08:11:45 <wli> vincenz: yes, either higher-order or dynamic types
08:12:42 <vincenz> inherit?
08:12:58 <wli> vincenz: in a figurative sense, not OO
08:13:07 <wli> vincenz: implement/acquire/get/do/etc.
08:15:36 <wli> vincenz: e.g. ErrorT on your type gets you error handling almost for free
08:18:09 <wli> vincenz: and ReaderT tacks a scopable environment onto things
08:19:35 <wli> vincenz: and WriterT tacks on a "log" of results accumulated over steps
08:20:53 <wli> so, I know all these things exist
08:20:58 <wli> I know what the vague concepts are
08:21:12 <wli> but when I break out an example
08:21:24 <wli> I'm hard-pressed to come up with a way to do anything with them.
08:21:44 <wli> e.g. labelling a tree by the sequence number according to in-order traversal
08:22:50 <wli> I'm completely stumped as to any effective way to do anything with monads in that case
08:23:30 <wli> where I can belt out an ML-ish solution about as fast as I can type
08:24:40 * vincenz is not a haskeller so..
08:24:45 <vincenz> like you I'm an mler
08:24:47 <vincenz> (ocaml)
08:25:04 <wli> there's another one
08:25:07 <wli> the 'o' side of ocaml
08:25:19 <vincenz> yeah, that's just oo
08:25:22 <wli> I never managed to do anything worthwhile with that.
08:25:27 <vincenz> I have :)
08:25:54 <wli> I force-fit it onto a few things a few times, but never really found it natural or useful.
08:26:00 <vincenz> well I did mixins
08:26:27 <wli> I did do wicked things in the module systems of both ML's though.
08:26:37 <wli> I grokked that completely and instantly.
08:26:38 <vincenz> like what?
08:26:57 <wli> Fully functorial programming out the wazoo, just about every time.
08:27:10 <vincenz> ah yeah that's easy
08:27:28 <vincenz> though I found little use for it
08:27:28 <wli> I miss functors, signatures, et al from ML
08:27:34 <vincenz> except when combined with oo
08:27:36 <vincenz> I made mixins 
08:28:03 <wli> I never found mixins useful.
08:28:46 <wli> Functors I got a lot of mileage out of by instantiating modules with different args all over the place.
08:28:59 <wli> higher-order functors, too
08:29:22 <wli> especially higher-order functors
08:29:49 <wli> I often wish Haskell would grow a similar module system.
08:33:50 <CosmicRay> @index tree
08:33:51 <lambdabot> bzzt
08:33:52 <CosmicRay> @index Tree
08:33:53 <lambdabot> Data.Graph,Data.Tree
08:37:38 <vincenz> wli: you know what mixins are?
08:38:06 <wli> vincenz: Multiple inheritance, I thought.
08:38:10 <vincenz> no
08:38:21 <vincenz> there's no need for multiple inheritance
08:38:30 <vincenz> but it allows for parametrizeable inheritance
08:38:40 <vincenz> aka when you're stacking functionality horizontally
08:38:43 <vincenz> mixins are great
08:39:00 <vincenz> for the rest I havent used the oo features much
08:39:09 <wli> vincenz: example?
08:39:17 <vincenz> example..
08:39:44 <vincenz> We use it, for example, to design memory allocators in C++
08:39:52 <vincenz> basically each layer has a free and a malloc
08:39:55 <vincenz> and they each do something small
08:39:57 <wli> vincenz: okay, show me that
08:40:00 <vincenz> can't
08:40:03 <vincenz> another example
08:40:05 <wli> vincenz: okay, then another example
08:40:07 <vincenz> is the tool that I use for tracing analysis
08:40:12 <vincenz> I have at the bottom layer
08:40:16 <vincenz> a finite state machine
08:40:25 <vincenz> that reads in, updates the environment a bit
08:40:31 <vincenz> and then depending on the packet/state
08:40:34 <vincenz> calls a certian method on itself
08:40:42 <vincenz> now depending on how much and what I want to analyze
08:40:48 <vincenz> I mixin the different layers that do different stuff
08:40:57 <vincenz> then each layer does
08:41:12 <vincenz>  method calculate a b = super#calculate a b; their own crap;
08:42:37 <vincenz> http://c2.com/cgi/wiki?MixIn
08:43:51 <wli> okay, abstract subclass
08:43:56 <vincenz> sort of
08:44:03 <vincenz> but the point is not polymorphism
08:44:04 <wli> well, that sums it up for me
08:44:09 <vincenz> but horiziontal layering of functionality
08:54:46 <Lemmih> Igloo: Around?
08:57:30 <Lemmih> It's not possible to splice matches in a case expression?
08:59:28 <musasabi> How can one automate building with hc-files?
08:59:57 <Igloo> It's not, sadly
09:00:33 <esap> horizontal layering can be done with universal quantification.
09:02:52 <esap> data Layer f g = Layer (forall a. f a -> g a)
09:02:53 <srid> hello all
09:03:12 <srid> can you share with me how did you first learn haskell and which book you followed, please?
09:03:42 <wli> srid: I read the haskell.org language and library specs on haskell.org and winged the rest
09:04:01 * esap also learned by reading the spec.
09:08:00 <srid> were you guys new to FP when learning haskell
09:08:01 <srid> ?
09:08:07 <wli> I was not.
09:08:19 <shapr> I was
09:08:28 * esap had read about lisp, but hadn't really understood FP at that point.
09:08:29 <wli> I knew Scheme, Common Lisp, and Standard ML
09:09:00 <wli> ocaml I learned about the same time as Haskell
09:09:28 <srid> ok, i am new to FP .. so thinking of how to learn haskell
09:09:36 * esap knew some scheme, some lisp and some ML, but couldn't design any real FP design with them.
09:09:57 <srid> esap: could you with haskell?
09:10:41 <esap> srid: well it took some time, but Haskell definitely helped with that.
09:11:30 <Lemmih> I wish I had the resolution to hack TH in GHC.
09:11:33 <esap> srid: I had lots of experience with C++ and OO design though, but not that much on design that is appropriate to FP.
09:11:43 <srid> TH?
09:11:54 <shapr> Template Haskell
09:12:03 * shapr will be your channel bot today...
09:12:16 <Lemmih> shapr: @moo
09:12:17 <srid> esap: is it possible to design an IDE in haskell say?
09:12:24 <shapr> um um...
09:12:31 * shapr quickly delegates
09:12:32 <shapr> @moo
09:12:33 <lambdabot>          (__)
09:12:33 <lambdabot>          (oo)
09:12:33 <lambdabot>    /------\/
09:12:33 <lambdabot>   / |    ||
09:12:33 <lambdabot>  *  /\---/\
09:12:33 <lambdabot>     ~~   ~~
09:12:35 <lambdabot> ...."Have you mooed today?"...
09:12:38 <thebug> @yow
09:12:41 <lambdabot> I'LL get it!!  It's probably a FEW of my ITALIAN GIRL-FRIENDS!!
09:12:52 <Lemmih> srid: Yes.
09:13:00 <esap> srid: Sure, though access to external libraries is sometimes somewhat hard. But it's doable.
09:17:42 <esap> srid: I would very much recommend Haskell for writing big applications, such as IDEs.
09:18:07 * Lemmih wants an IDE with cross module tab completion and darcs support.
09:18:14 <srid> i started with YAHT .. but somewhat boring ... .suggestions?
09:18:44 <aj> what's a good, standard way of doing a topological sort?
09:21:06 <esap> aj: depth-first search?
09:23:03 <aj> i was hoping for a function name :)
09:23:22 <esap> hehe :-)
09:23:52 <esap> Data.Graph.topSort
09:25:17 <vincenz> re
09:25:51 <vincenz> wli: you learned lisp as well? (besides scheme)
09:26:14 <aj> hrm
09:26:31 <aj> esap: thanks, that's what i was after
09:26:54 <wli> vincenz: yes, though I never got into the lore of CLOS or anything like that; more or less barebones language, not a whole lot of library knowledge
09:26:58 <aj> except now i wonder if i want a topSort or something that'll give me all valid permutations. hrm
09:27:21 <vincenz> wli: so which do you prefer?  scheme or lisp?
09:27:45 <ibid> scheme is lisp
09:27:45 <ibid> :)
09:27:48 <wli> Probably Scheme because it seems more regular.
09:27:52 <wli> Common Lisp
09:27:54 <wli> cmucl
09:27:59 <ibid> sure
09:28:36 <ibid> cl people often want to pretend that cl is the only lisp in existence, which irritates me enough to say the above occasionally :)
09:28:44 <vincenz> ibid: there are some fundamental differences
09:29:06 <vincenz> scheme is statically scoped, lisp is dynamically scoped
09:29:15 <vincenz> scheme has one namespace for functions and values, lisp has two
09:29:25 <wli> I'm not a "cl person"... I'm probably more of an "atypical polyglot C person"
09:29:25 <ibid> vincenz: you're assuming that scheme is not lisp :)
09:29:35 <vincenz> ibid: no I'm telling you what the differences are
09:29:50 <ibid> vincenz: your position requires the false assumption that scheme is not lisp
09:30:02 <vincenz> ibid: my position is based on the specs of lisp and scheme
09:30:11 <vincenz> lisp _is_ dynamically scoped
09:30:12 <ibid> there is no spec of lisp
09:30:17 <vincenz> fine common lisp
09:30:23 <ibid> that's better
09:30:24 <vincenz> that's what most people understand under lisp anyways
09:30:30 <vincenz> but your position is pointless
09:30:30 <ibid> 19:26  <ibid> cl people often want to pretend that cl is the only lisp in existence, which irritates me enough
09:30:34 <ibid>               to say the above occasionally :)
09:30:34 <vincenz> according to your way of thinking
09:30:39 <vincenz> java and c++ are both algol
09:30:44 <vincenz> and are therefore the same
09:30:46 <ibid> vincenz: no they're not
09:30:51 <vincenz> yes they are
09:31:02 <wli> Well, I personally don't have much of a stake in all this.
09:31:06 <ibid> you're putting words into my mouth, that's dishonest
09:31:16 <vincenz> no
09:31:21 <vincenz> I'm making an analogy based on what you said
09:31:26 <ibid> a false analogy
09:31:31 <vincenz> not true
09:31:36 <vincenz> I used to have your position
09:31:37 <vincenz> scheme is lisp
09:31:41 <ibid> based on a faulty understanding of my position
09:31:44 <vincenz> but after many flames, and some personal research
09:31:50 <wli> They can probably be technically differentiated but they're so very similar it's worth acknowledging some extremely close relationship.
09:31:51 <vincenz> I decided scheme is not lisp
09:32:02 <aj> okay, it's clearly time for pistols at dawn
09:32:04 <vincenz> wli: I do think that static vs dynamic scoping makes a big diff
09:32:06 <aj> choose your seconds!
09:32:07 <ibid> aj: :)
09:32:18 <vincenz> and the fact that there's two namespaces for lisp
09:32:23 <vincenz> means you cna't just pass a func and call it
09:32:24 <wli> vincenz: well, what cmucl implements is not what went around in '58
09:32:25 <ibid> i choose the 35th second of the next minute
09:32:31 <vincenz> you have to call this other function to say it's a funtion
09:32:45 <vincenz> hence
09:33:03 <vincenz> (lambda x (x x)) (lambda x (x x)) becomes in lisp
09:33:09 <wli> wow, this has turned into the IRC version of comp.lang.functional
09:33:10 <vincenz> (lambda x (funcall(x) x))
09:33:12 <vincenz> etc..
09:33:21 <ibid> vincenz: common lisp is the result of work to unify several dialects of lisp into one canonical dialect, one of which is the (then-current dialect of) scheme
09:33:30 <ibid> vincenz: hence, scheme is a lisp
09:33:40 <vincenz> is a dialect of lisp
09:33:52 <vincenz> and scheme has always been statically scoped
09:33:57 <vincenz> lisp has always been dynamically scoped
09:34:27 <ibid> lisp, without qualifiers, refers either to a 60's language no longer in use or to a family of languages, of which scheme and common lisp are the most popular ones
09:34:46 <ibid> vincenz: dynamic scope was a mistake, lisp was intended to be statically scoped
09:34:58 <ibid> vincenz: mccarthy is on record for having said so
09:35:03 <vincenz> hmm
09:35:05 <vincenz> that I did not know
09:35:10 <vincenz> my background is imperative languages
09:35:17 <vincenz> functional languages are an acquired taste
09:35:17 <Riastradh> Lisp was dynamically scoped because McCarthy didn't understand Church's papers when he first read them.
09:35:25 * esap wonders how you could build a useful type system to make dynamic scoping better behaved?
09:35:32 <ibid> vincenz: though people decided that the mistake is cool and didn't reverse it
09:35:39 <vincenz> I find it confusing
09:35:43 <Lemmih> Yay, it's dark outside.
09:35:43 <Riastradh> Lisp originally did not have separate variable & function namespaces.
09:35:43 * Lemmih puts on his hero suit and goes unicycling.
09:36:53 <Riastradh> ibid, usually, when referring to the original language, one writes 'LISP,' which I for some reason forgot to do in my last two messages; 'Lisp' typically, unless you're a Common Lisper, refers to the family of languages.
09:37:04 <shapr> d00d
09:37:21 <ibid> Riastradh: close enough to my position to make them virtually identical :)
09:37:58 <shapr> I like programming. My love of ditch digging is significantly less than my love of either dynamic or static whatever.
09:38:32 <vincenz> ibid: I don't want to continue this flame war, and I do agree that I find scheme lisp, but I was perpetuating what I've been told.  However do note "family of languages" just as algol is a family of languages, and hence c++ and java are algol like scheme is lisp
09:38:56 <vincenz> anyways
09:38:59 <vincenz> back to reading Pierce
09:39:07 <ibid> vincenz: the difference is that c++ and java were never described as algol dialects by their authors
09:39:39 <ibid> vincenz: but as i said, i'm just irritated by common lispers' habit of claiming that cl is the only lisp
09:39:42 * vincenz nods
09:39:46 <vincenz> I used to do that too 
09:39:47 <ibid> vincenz: it's not terribly important
09:40:16 <Riastradh> It would be much more accurate to say 'Scheme is _a_ Lisp.'
09:40:33 <ibid> true
09:40:49 <ibid> but the same applies to cl
09:43:00 <Riastradh> Correct.
09:43:28 <Riastradh> Scheme, by the way, was acknowledged to also be heavily influenced by Algol in block structuring/lexical scoping.
09:43:48 <ibid> true
09:44:43 <musasabi> shapr: ping.
09:44:48 <shapr> pong!
09:44:55 <shapr> did I miss a message to me?
09:45:49 <shapr> musasabi: ?
09:53:50 <musasabi> shapr: I was thinking about collecting a collection of example programs in haskell in a sensible format..
09:54:02 <shapr> follow the haddocks?
09:54:12 <shapr> maybe FundamentalConcepts on the wiki?
09:54:23 <shapr> I've been collecting type tricks the last few days.
09:54:28 <shapr> What format did you have in mind?
09:54:38 <musasabi> shapr: yes, somekind of hierachical organization would be nice.
09:55:21 <shapr> Also, FunctionalModellingExamples would allow people to 'export' some of their existing OOP understanding into Haskell.
09:56:08 <shapr> That is, pick a problem that has an existing simple Java/Python/whatever solution, then show how to turn that into idiomatic Haskell.
09:56:48 <shapr> And you'd want stuff going in the other direction as well, some common problem approaches used in Haskell work so badly in Java/Python/whatever that no one would consider them.
09:58:04 <shapr> I'd suggest including at least a pointer to Hudak's paper on advantages of Haskell... the one where he wrote the prototype using higher order functions that many programmers mistook for a specification rather than executable code.
09:58:31 <musasabi> hmm true that would be good.
09:59:29 <musasabi> maybe just link the code to the wiki.
10:00:07 <musasabi> Having a possiblity to add out-of-the-line code to the wiki would be nice. Does moin-moin have subpages?
10:00:18 <shapr> The only disadvantage of putting stuff on the wiki is the lack of a given license for wiki content.
10:00:28 <shapr> yes, subpages.
10:00:37 <shapr> Lots of really cool SubPage and Include features too.
10:01:07 <shapr> for example - http://www.scannedinavian.org/AvianWiki/ShaeErisson/ToDo
10:01:23 <shapr> That's my browser homepage
10:02:32 <vincenz> shapr: what do you use for your main website?
10:02:40 <shapr> which main website?
10:02:50 <vincenz> well remove all the stuff after org/...
10:02:52 <shapr> Halipeto for scannedinavian.org and PLog for scannedinavian.com
10:03:00 <shapr> Both Haskell apps of course.
10:03:06 <vincenz> got a blog in there?
10:03:11 <shapr> yup, dot com
10:03:19 <shapr> dot net isn't doing anything at the moment, but I have plans...
10:03:29 <vincenz> shapr: hmm..
10:03:34 <vincenz> shapr: so a haskell app?
10:03:41 <vincenz> meaning it's the server? or you still have apache
10:03:53 <shapr> at the moment, I'm using Halipeto to generate static html
10:03:58 <shapr> PLog also generates static html.
10:03:58 <vincenz> I meant for the blog
10:04:01 <vincenz> oh
10:04:05 <vincenz> basically cgi that changes it
10:04:23 <shapr> Lemmih is rapidly approaching the point of fully dynamic Halipeto, but I haven't kept up with his developments lately.
10:04:46 <shapr> I am going to need a real haskell web app server very soon.
10:04:55 <shapr> I know of at least three projects to do that, I need to see how they're all doing.
10:05:15 <vincenz> shapr: so basically the plog is a cgi-bin
10:05:29 <vincenz> also, I use python right now, all my pages are dynamically generated, is this overkill?
10:05:31 <shapr> nah, it's just an executable, I rsync the content
10:05:52 <shapr> Whether it's overkill or not depends on what you're doing with it.
10:05:55 * vincenz also should find a place to host his site, given that his bandwidth is limited and his ports are blocked until 1024
10:06:15 <musasabi> Would start putting stuff under ExampleCode in haskell wiki make sense and do you think that would be a good idea?
10:06:31 <vincenz> shapr: you pay for hostage?
10:06:46 <shapr> vincenz: I do not negotiate with terrorists or kidnappers!
10:06:49 * shapr snickers
10:06:55 <vincenz> hehe
10:07:14 <shapr> I'm trying to move to a new ISP right now for my colocated server.
10:07:21 * vincenz nods
10:07:27 <vincenz> prob is that my ISP only does pure html
10:07:28 <vincenz> :/
10:07:51 <vincenz> (And 3, imagine that, THREE, cgi-bins.... Current date, page-counter, and emailer)
10:07:59 <shapr> I'll either end up with a static IP at home on a 1megabit line, or I'll end up with a rackmount hosted somewhere in europe.
10:08:09 <vincenz> how much does that go for?
10:08:17 * vincenz has 10Mbit
10:08:19 <shapr> I'd be happy to sell you hosting once my server is up =)
10:08:27 * vincenz only has 1Gb upload/month tho
10:08:38 <shapr> I have unlimited bandwidth
10:08:45 <vincenz> :(
10:09:56 <shapr> like I said, I'll sell you hosting when I have a reliable ISP again.
10:10:08 <vincenz> nah I should prolly get my own
10:10:21 <shapr> It'll be a debian/unstable box, and I'll install whatever debs you want.
10:10:53 <shapr> Even OCaml!
10:10:55 * shapr grins
10:11:55 <vincenz> I just read your thing on diamonds and haskell
10:11:57 <vincenz> for me it's the same with ocaml
10:12:04 <shapr> musasabi: yah, I think it would work.
10:12:17 <shapr> vincenz: cool, you should use what works for you.
10:12:25 <vincenz> shapr: what do you do for a living?
10:13:08 <shapr> I build websites mostly
10:13:15 <vincenz> you work for yourslef?
10:14:01 <shapr> yup
10:14:22 <vincenz> must be difficult
10:14:39 <shapr> nah, it's awesome
10:15:00 <shapr> I even get paying Haskell work sometimes :-)
10:15:26 <shapr> hola arauko 
10:15:28 <vincenz> how do you manage to find clients?
10:16:07 <shapr> It's not hard, dynamic websites are easy to sell.
10:16:33 <vincenz> yeah but you gotta find clients
10:17:07 <shapr> Pick three midsized companies with offices near you, look at their existing websites. Write up a small prototype of something lots better, then walk into their office and ask 'em if they'll buy it off you.
10:17:29 <vincenz> hmm
10:17:36 <vincenz> what do you use as technologies?
10:17:51 <shapr> Mostly Zope and Plone, but I'm way tired of that, I'm switching to Haskell.
10:18:13 <vincenz> rolling your own?
10:18:19 <shapr> Not completely.
10:19:22 <shapr> I think part of the reason I'm cheap is that I can do all the development and maintenance myself. I can buy hardware, install, setup, and the company just sends money to keep everything rolling.
10:19:28 <arauko> Hoal shapr :-)
10:19:47 <vincenz> so you do the hosting?
10:19:50 <vincenz> it's not "install at client site"
10:19:53 <shapr> Not so far
10:20:00 * vincenz nods
10:20:09 <vincenz> do you think they would be interested in remote hosting tho
10:20:12 <shapr> So far all of my clients want the hardware at their own place, and that's fin eby me.
10:20:16 <vincenz> they might like to fiddle with what you sell them
10:20:20 <shapr> Some of them would if it were cheap enough.
10:20:44 <shapr> Another reason I'm cheap is that I really hate maintaining stuff, so I try to put up systems that the clients can easily maintain themselves.
10:20:52 <shapr> I like building new stuff, then I get bored.
10:21:10 <vincenz> yeah
10:21:22 <vincenz> but isn't websites mostly content and therefore mostly redoing same work
10:21:28 <shapr> Full content management systems like Plone let the clients do nearly everything themselves.
10:21:41 <vincenz> so what is your added value?
10:22:13 <shapr> I build the site, my clients do the content.
10:22:35 <shapr> They pay me to make 'deep changes' but not shallow content-only changes.
10:22:41 <vincenz> such as
10:23:10 <shapr> Plone is themable, but my clients rarely know enough themselves to create new skins, so when they need a new look, they ask us.
10:23:27 <shapr> When they need new functionality in the website, I either install an open source Plone plugin or write something for them.
10:23:34 <vincenz> ah
10:23:36 * vincenz nod
10:23:42 <vincenz> but are the dynamic parts that often used?
10:23:52 <shapr> Plugging Plone into a backend database takes a coupla hours to setup the database, create tables, and hook it up.
10:23:57 <shapr> Oh yes, very much so.
10:24:26 <shapr> We wrote a simplistic document management system for an EU project that was part of the website.
10:24:37 * vincenz nods
10:24:39 <vincenz> we
10:24:40 <vincenz> ?
10:24:48 <shapr> Sure, my fiancee is my boss.
10:24:50 <vincenz> oh
10:24:52 <vincenz> cool
10:24:57 <vincenz> must be nice to work with your partner
10:25:05 <shapr> I'm the geek, she's the language and business and people interface.
10:25:11 * vincenz nods
10:25:12 <shapr> It has its good and bad points.
10:25:29 <vincenz> she's a techie?
10:25:40 <shapr> She speaks about five and a half languages, she has long and positive history working with EU projects, and she's charming.
10:26:05 <shapr> She also uses mandrake and xemacs for most of her website work. She uses some other open source apps for her translation work.
10:27:03 <shapr> Recently we wrote a system to allow european and latin american companies and funding to find each other.
10:27:22 <vincenz> I see
10:27:32 <vincenz> I commend her on her choice of mandrake
10:27:38 <shapr> It wasn't very complicated, but it took awhile because everybody had to change their minds all the time and then change it back.
10:28:31 <shapr> She started with debian, but then she wanted something she could admin by herself, so she switched to mandrake.
10:30:14 <shapr> I like working at home. Shop in the daytime, code at night. I can work as long or as short as I want as long as stuff is done on time.
10:30:30 <vincenz> same here
10:30:42 <shapr> There's a lot of freedom in what I work on too. I just need to find customers who need something that I want to write :-)
10:31:02 <vincenz> does it pay well?
10:31:35 <shapr> Yeah, I guess it does. I have a lot of spare time to do whatever I want. That's the best pay for me.
10:32:23 <shapr> I tend to work for eighteen hours a day until I have a bunch of saved up cash, and then coast until I need more.
10:32:51 <shapr> I would hate to go back to the nine am to five pm codemonkey job.
10:32:57 <vincenz> odd
10:33:10 <vincenz> you can find enough clients to schedule upto eighteen hour pipelines?
10:33:16 <shapr> Sure
10:33:18 <vincenz> I would think the limit would be amount of work, not hours
10:33:27 <vincenz> but it takes some time to find clients
10:33:33 <vincenz> which means your pipeline is already allocated
10:33:37 <vincenz> based on what you promised the client
10:33:44 <shapr> I think we have about fifteen decent sized websites right now.
10:33:49 <vincenz> so how can working faster help?  you'll just terminate the ones you promised earlier
10:33:57 <shapr> huh?
10:34:08 <vincenz> you have to say in advance how long it will take no?
10:34:38 <shapr> No, we are given certain requirements. I say how long that will take, then my clients change their minds halfway through :-)
10:35:07 <shapr> My clients usually say "we need this website in two months, here's what it should do"
10:35:12 <vincenz> yes
10:35:17 <vincenz> so you have x clients at the moment
10:35:23 <vincenz> and let's say a load of 12 hours
10:35:27 <vincenz> ./day
10:35:34 <vincenz> now if you throttle to 18 hours
10:35:37 <vincenz> you'll just end earlier
10:35:42 <vincenz> I mean it takes time to find new clients...
10:35:57 <vincenz> it's not like you throttle today to 18 hours you'll just find a new client today to use in the 6 hours extra work time
10:36:07 <shapr> Our existing clients are partners in multiple EU projects, so they usually give us several websites to do at the same time.
10:36:40 <shapr> For example, I could do several days of work before if I felt like it, but I'd rather wait until January.
10:37:18 <vincenz> yes but if you do them now or in january
10:37:27 <vincenz> you have your clients now, if you do them now, you'll just end in advance
10:37:30 <vincenz> but that won't just give you more money
10:38:41 <shapr> Actually, we do websites quickly and cheaply compared to the IIS + ASP deals I've seen, so other partners in our EU Projects have started giving us other work.
10:39:04 <shapr> We got into this line of work accidentally, in fact.
10:40:13 <shapr> One partner of a project said they'd have the project website done before an audit, and ten days before the audit, they hadn't even started. So someone asked us if we could quickly make something to save their butt, and they liked what they got very much.
10:42:08 <shapr> There's a bunch of work I could be doing for several different websites, but those projects don't have any spare funding at the moment. So, there's a lot of possible work, and some of it will end up being funded, so we'll end up doing it.
10:43:29 <shapr> I firmly believe there's a lot of work waiting to be done, you just gotta find it.
10:43:51 <shapr> vincenz: anyway, have you written any Haskell?
10:44:00 <vincenz> no
10:44:05 <vincenz> should be easy tho
10:44:19 <shapr> I bet you'll like it nearly as much as OCaml. Maybe even more =)
10:44:54 <shapr> typeclasses are very sexy.
10:46:02 <shapr> vincenz: have you tried Yi?
10:46:16 <vincenz> Yi?
10:46:18 <vincenz> anyways you're right
10:46:22 <vincenz> I sometimes miss typeclass in ocaml
10:46:38 <shapr> yi - http://www.cse.unsw.edu.au/~dons/yi.html
10:47:12 <coven> couldn't match 'IO' against '[]' - how do i "typecast"? :\
10:47:14 <vincenz> shapr: heh, I once thought to build something like that in ocaml ;)
10:47:25 <vincenz> Can you dynamically load code with haskell?
10:47:28 <shapr> yup
10:47:39 <shapr> requires hs-plugins though
10:47:44 <shapr> coven: eh?
10:48:22 <coven> shapr, trying to use filter with/on getDirectoryContents 
10:48:47 <shapr> coven: do you know how to deal with IO ?
10:49:29 <vincenz> http://www.npc.de/ocaml/linkdb/link_editor_orig.cgi?edit_page=show&id=353
10:49:40 <shapr> vincenz: Yi can also edit its own core, and :reboot will save state, restart and come back to where you were in about 0.2 seconds
10:50:14 <vincenz> I just have this issue with haskell
10:50:19 <coven> shapr, in haskell? nopes
10:50:19 <shapr> what's the issue?
10:50:19 <vincenz> I always think it's gonna be slow
10:50:26 <shapr> vincenz: have you tried it?
10:50:30 <vincenz> no
10:50:35 <shapr> then how do you know? =)
10:50:43 <vincenz> presentiment
10:50:48 <vincenz> I didn't say I know
10:50:58 <vincenz> 19:43 < vincenz> I always think it's gonna be slow
10:51:00 <shapr> You could try it and see if you like it.
10:51:04 <vincenz> note the "think"
10:51:06 <vincenz> shapr: I know ocaml..
10:51:18 <vincenz> that's like learning flemish when you know dutch
10:51:31 <shapr> Yeah, and Haskell might be cooler than OCaml. Or it might suck. But you won't know till you try it.
10:51:47 <shapr> vincenz: there's a big difference between impure and pure FP.
10:51:52 <vincenz> shapr: I know
10:51:56 * vincenz is making a pure fp
10:52:03 <shapr> It'll stretch your brain. It's bigger than flemish to dutch.
10:52:20 <vincenz> I can't find useful applications for it
10:52:27 <vincenz> cause where I might use it, I can just go to ocaml
10:52:47 <vincenz> plus you have to write something in a lang to learn it
10:52:50 <shapr> Do you remember your attitude towards FP before you learned OCaml? I do =)
10:52:53 <vincenz> I have no project at the omment
10:53:00 <vincenz> shapr: I learned scheme before ocaml
10:53:01 <vincenz> ;)
10:53:17 <CosmicRay> shapr: mine was "what a great way to program, but I'd have to reinvent the wheel so many times porting Python's standard library"
10:53:26 <shapr> CosmicRay: heh
10:53:34 <CosmicRay> shapr: but ocaml was cool enough, and haskell even more, that I'm porting it twice :-)
10:53:41 <shapr> spiffy!
10:53:47 <CosmicRay> well I only ported a little to ocaml
10:53:56 <vincenz> shapr: one issue: I cant make simple experiments in hugs
10:54:00 <MegaMonad> Hi jesse98, how's the cloudy city?
10:54:02 <vincenz> you're not allowed to define stuff
10:54:06 <CosmicRay> I'm working on a Haskell version of SocketServer now
10:54:14 <CosmicRay> next will be a simple FTP server implementation in pure Haskell
10:54:14 <shapr> vincenz: use ghci
10:54:22 <vincenz> no package for mdk
10:54:25 <CosmicRay> which will be able to serve up real files or arbitrary tree structures
10:56:52 <CosmicRay> I'm pretty excited about that one
10:57:02 <vincenz> tree structures?
10:57:13 <vincenz> gonna use threads or synch-sockets?
10:57:23 <CosmicRay> I can imagine FTPing into a server, authenticating, and modifying ConfigParser data in real time
10:57:29 <CosmicRay> vincenz: forkIO threads
10:57:39 <vincenz> eww
10:57:39 <vincenz> fork
10:57:51 <CosmicRay> vincenz: this is not fork(2)
10:57:56 <vincenz> oh
10:58:01 <CosmicRay> vincenz: Haskell internally uses select() to simulate threads
10:58:07 <vincenz> aha
10:58:17 <vincenz> meaning you can't choose yourself 
10:58:19 <CosmicRay> vincenz: this is really slick.  You can turn any standard I/O code into asynchronous code with a call to forkIO
10:58:23 <CosmicRay> choose what?
10:58:29 <vincenz> between select and threads
10:58:31 <vincenz> real threads
10:59:03 <CosmicRay> haskell has at least three ways to do thread-like things
10:59:06 <CosmicRay> 1. forkIO threads
10:59:07 <CosmicRay> 2. fork
10:59:20 <CosmicRay> 3. "concurrent" threads (pthreads under the hood?)
10:59:23 <CosmicRay> 4. glasgow parallel haskell
10:59:33 <CosmicRay> I don't know if any of the first three are == #4
11:00:46 <CosmicRay> sorry, #3 should be "bound" threads
11:01:13 <CosmicRay> A bound thread is a haskell thread that is bound to an operating system thread.... To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like pthread_create or CreateThread. 
11:02:03 <CosmicRay> vincenz: make sense?
11:02:27 <shapr> vincenz: btw, theoretically speaking, non-strict languages are asymptotically faster than strict languages.
11:02:30 * vincenz nods
11:02:41 <CosmicRay> #1 is the coolest to me.  In every other language I've worked with, using select/poll requires a massive rewrite effort, with much more complex code.
11:02:42 <vincenz> shapr: under certain assumptions
11:02:51 <CosmicRay> with haskell, it's a forkio at the right place, and most of the code will work either way.
11:02:59 <Igloo> That's not true on real hardware
11:03:12 <CosmicRay> Igloo: are you speaking to shapr or to me?
11:03:16 <Igloo> shapr
11:03:17 <shapr> whoops, he's here, I'll shut up now.
11:03:20 <CosmicRay> heh
11:03:39 <Igloo> Me or Heff?
11:03:41 <CosmicRay> vincenz: you can define stuff in ghci
11:03:48 * shapr is just teasing
11:03:53 <vincenz> define stuff?
11:04:05 <Heffalump> top level definitions
11:04:07 <shapr> Igloo: I was talking about Okasaki's amortized non-strict algorithms.
11:04:08 <CosmicRay> <vincenz> shapr: one issue: I cant make simple experiments in hugs
11:04:12 <CosmicRay> <vincenz> you're not allowed to define stuff
11:04:12 <Heffalump> let foo = 5+3
11:04:22 <vincenz> CosmicRay: oh yes but you missed the continuation
11:04:26 <CosmicRay> in ghci, you can define things using the same way you would in a do loop
11:04:29 <vincenz> CosmicRay: shapr mentioned ghci
11:04:34 <vincenz> and I said ghci has no package for mdk
11:04:38 <vincenz> or rather
11:04:39 <Heffalump> mdk?
11:04:43 <vincenz> mdk has no package for ghci
11:04:45 <vincenz> mandrake
11:04:46 <Igloo> I thought he was a bit misleading in the talk I heard
11:04:46 <CosmicRay> vincenz: it's part of ghc
11:05:10 <jadrian> vincenz: the rpms in ghc webpage might work in Mandrake
11:05:11 <Heffalump> cosmicray: depending on how you build ghc, it's possible to not end up with ghci
11:05:20 <jadrian> vincenz: I'm using them in SuSE
11:05:26 <Igloo> He said the Haskell could be asymptotically faster than something else, and only later said only if you didn'tuse all the result (things from a priority queue, I think)
11:05:29 <CosmicRay> Heffalump: I agree, but I highly doubt they would break it in that way
11:05:34 <vincenz> [root@d5760ed0:vincenz]# urpmi ghc
11:05:34 <vincenz> no package named ghc
11:05:47 <CosmicRay> maybe it's ghc6
11:05:49 <Heffalump> cosmicray: well, you have do a multi-stage build to get ghci
11:05:55 <CosmicRay> or maybe you will want to download the debs from www.haskell.org
11:05:57 <Igloo> And of course you could write the other to be as fast, it would just be uglier
11:05:59 <CosmicRay> s/debs/rpms/
11:06:08 <vincenz> nope, nothing
11:06:18 <Igloo> Although I do agree with the general sentiment  :-)
11:06:24 <shapr> Igloo: um, I think the asymptotically faster part really does just work.
11:06:32 <vincenz> shapr: no it doesn't
11:06:44 <shapr> vincenz: how?
11:06:45 <vincenz> shapr: you assume you don't use certain calculations and hence the lazyness makes sure you don't execute them
11:06:52 <vincenz> but in typical code you don't write methods you don't use
11:06:55 <Igloo> If you write it to do the ordering strictly and don't use everything in the queue, yes
11:07:00 <vincenz> or rather, you don't typically calculate values you don't use
11:07:12 <vincenz> and in that case, memoization/lazy evaluation adds quite some overhead
11:07:16 <Heffalump> laziness is asymptotically better than pure strict functional programs in certain situations
11:07:33 <vincenz> Heffalump: situations which imho don't appear so often
11:07:45 <Igloo> Can you give an example?
11:08:08 <Heffalump> Igloo: Oege wrote a paper about it.
11:08:22 <Heffalump> I can't remember what the algorithm in question was.
11:08:37 <Heffalump> vincenz: true.
11:09:14 <jadrian> hmmm, can't you always implement the lazy algorithm in a strict setting?
11:09:17 <shapr> There are several examples in Rabhi and Lapalm where balanced trees etc are only balanced or whatever when the next request is made
11:09:29 <Heffalump> jadrian: not in the same time complexity if you don't have updatable references
11:09:34 <Heffalump> and note I said 'pure strict' above.
11:09:45 <jadrian> right
11:09:48 <vincenz> hmm
11:09:52 <shapr> And you can do that sort of stuff in a strict language as well, but it's natural in a non-strict language.
11:09:53 <vincenz> I missed that
11:10:11 <vincenz> well in non-pure strict, it's even a bigger gap
11:10:23 <vincenz> and hence the restrictions on situations when lazyness is better become bigger
11:11:17 <vincenz> basically with lazyness (assuming code will be executed), you replace multiple-executions by memoization
11:11:23 <vincenz> aka you move from computation to memory
11:11:24 <Heffalump> you can simulate laziness with not-pure strict code
11:11:32 <vincenz> oddly enough, my research works in the other direction
11:11:38 <shapr> In my opinion, non-strict is overall more expressive than strict, but overall more difficult to use because you have to think harder about what you're doing. It's worth it to me though.
11:11:38 <Heffalump> so non-pure strict is always just as expressive (asymptotically) as laziness
11:11:42 <vincenz> I replace memory by computation
11:12:03 <vincenz> Heffalump: except that lazyness built into the language means you'll have it everwhere, even where it's not needed, hence adding oerhead
11:12:07 <vincenz> overhead
11:12:12 <shapr> Oh have you read Wadler's CBN vs CBV paper?
11:12:20 * vincenz plans to add judicious memoization to his personal pure strict fp
11:12:26 <vincenz> well it won't be fully strict then but
11:13:50 <Igloo> That wouldn't make it non-strict
11:13:55 <vincenz> yes it would
11:14:11 <vincenz> memoization means some parts might not be executed as often as the value is requested
11:14:30 <vincenz> but in the setting of pure languages, that's not a problem
11:14:35 <vincenz> (pure functional)
11:14:46 * vincenz has almost worked out all the typing issues
11:14:57 <vincenz> then I'll write the formals about evaluation
11:15:00 <vincenz> and implement it with templates
11:15:02 <vincenz> :)
11:15:08 <shapr> sick
11:15:12 <vincenz> not really
11:15:15 <jadrian> not a problem in which sense? isn't that the cause for many space leaks?
11:15:16 <tuomov> http://wiki.ael.be/ion/index.php/RecentChanges
11:15:20 <tuomov> talk about wiki spamming..
11:15:21 * shapr beats vincenz with a copy of the C++ standard.
11:15:30 <vincenz> shapr: already read it, or at least hte parts I need
11:15:46 <tuomov> all 37 changes on the page are pr0n spam
11:15:56 <vincenz> wow
11:15:58 <jadrian> oh nevermind got it
11:16:01 <shapr> Yeah, but would you rather be beaten by a copy of the C++ standard, or the Haskell standard?
11:16:07 <shapr> greetz Darius 
11:16:13 <Darius> heya shapr
11:16:16 <vincenz> shapr: euhm... I _need_ to do it with templates
11:16:22 <shapr> tuomov: you know the antispam feature on moinmoin? It works great.
11:16:22 <vincenz> I need the functional language on top of c++
11:16:30 <shapr> vincenz: sick I tell you!
11:16:40 <vincenz> shapr: didn't I tell you the even sicker thing I did?
11:16:46 * shapr hides
11:16:55 <jdrake> I have completed my second 'major' function from the exercises in SOE and was wondering how my 'style' is, and if there are any improvements possible -> http://paste.lisp.org/display/4472  'regularPolygon'
11:16:57 <vincenz> I implemented functors in c++ (no biggie)
11:16:58 <shapr> Darius: any other thoughts on spoken concatenative?
11:17:01 <tuomov> well, I don't have a decent space to put a wiki myself in
11:17:05 <vincenz> then made a template that curries a functor
11:17:31 <tuomov> something needs to be done, though
11:17:39 <vincenz> x(c)(3)(4)(&Class::method)(5)
11:17:42 * shapr beats vincenz with a purely functional copy of the Microsoft Foundation Classes
11:17:54 <shapr> you need help man!
11:17:57 <vincenz> -> pass it a creator c, pass it the values to the constructor, pass it the method and tehn pass it the value to pass to the member
11:18:02 <vincenz> c being a factory
11:18:09 * shapr is feeling ill
11:18:11 <vincenz> yick
11:18:13 <vincenz> mfc
11:18:18 <shapr> I'm allergic to C++
11:18:23 <vincenz> I'm allergic to microsoft
11:18:26 <vincenz> c++ is ok
11:19:41 * CosmicRay is allergic to all of the above, plus perl and ragweed
11:20:33 <vincenz> I'm not allergic to perl, it's worse, it's like cryptonite to me
11:20:36 <Darius> shapr: Well string literals would be issue.
11:21:15 <tuomov> perl -p -i -e 's/.../.../g' is nice, but anything beyond that is overdosing
11:21:19 <shapr> lojban has a "foreign mark aoesnthau mark" sort of structure.
11:29:03 <Darius> shapr: Concatenative or not, an undo word should probably be reserved (and a redo as well), though that's more an editor issue (but the language may be closely bound to it's editor).
11:30:04 <CosmicRay> shapr: are you aware of any haskell code for working with paths, other than that in fptools cvs?  I'm specifically looking for abspath/normpath functions (eliminate double slashes, ., .., convert paths to absolute paths)
11:30:10 <aj> what's a decent way to uniq'ify a list?
11:30:14 <shapr> nub
11:30:21 <shapr> CosmicRay: nope, nothing.
11:30:23 <vincenz> aj:  sort it
11:30:26 <vincenz> aj: pour it into a set
11:30:33 <shapr> nub!
11:30:52 <aj> i've got Eq, i don't really want a Cmp
11:31:30 <Darius> @eval nub [1,5,3,8,8,1,3,0,13]
11:31:31 <lambdabot> [1, 5, 3, 8, 0, 13]
11:31:49 <aj> where's nub?
11:31:52 <CosmicRay> shapr: ah ha, I just discovered hsshellscript has what I want
11:31:55 <vincenz> @eval (\x.x x)(\x.x x)
11:32:01 <Lemmih> @index nub
11:32:02 <Darius> aj: (Data.)List
11:32:08 <CosmicRay> @eval system("echo hi")
11:32:13 <lambdabot> out of fuel - use @resume to continue
11:32:13 <lambdabot> Data.List,List
11:32:13 <lambdabot> unbound variable: system
11:32:19 <Spark> lol
11:32:21 <aj> perfect
11:32:22 <shapr> @eval, lesser of two
11:32:23 <lambdabot> Sorry, I don't know the command "eval,", try "lambdabot: @listcommands"
11:33:07 <CosmicRay> hmm.  I wonder what would happen if I @eval length (cycle [5])
11:33:28 <CosmicRay> shapr: do I have your permission to try? :-)
11:33:50 <shapr> try what?
11:34:00 <shapr> to break lambdabot? sure!
11:34:04 <CosmicRay> ok :-)
11:34:12 <CosmicRay> @eval length (cycle [5])
11:34:19 <vincenz> @resume
11:34:20 <shapr> There are security holes in lambdabot
11:34:29 <CosmicRay> I think I broke it.
11:34:34 <lambdabot> out of fuel - use @resume to continue
11:34:38 <CosmicRay> ah.
11:34:39 <vincenz> @resume
11:34:39 <CosmicRay> not so.
11:34:44 <vincenz> I'll stop
11:34:47 <CosmicRay> shapr: does it have a timeout?
11:34:48 * vincenz coughs
11:34:54 <lambdabot> out of fuel - use @resume to continue
11:34:56 <shapr> I even know of an interesting hole in the @type command.
11:34:57 <vincenz> shapr: you should lower the amount of fuel
11:35:04 <vincenz> shapr: and you should disable @resume
11:35:07 <shapr> I didn't write @eval, Darius did.
11:35:10 <vincenz> or it allows people to spam your cpu with what I did
11:35:13 <shapr> vincenz: no, it works fine.
11:35:16 <lambdabot> out of fuel - use @resume to continue
11:35:21 <shapr> vincenz: that's okay with me, it's very rare.
11:35:25 <vincenz> hm
11:35:38 * vincenz spams 100 lines of @...resume
11:35:41 * shapr grins
11:35:45 <CosmicRay> @eval cycle [5]
11:35:46 <vincenz> apparently it also matches inside lines
11:35:51 <Darius> CosmicRay: It counts variable references.
11:35:59 <vincenz> what is cycle?
11:36:02 <lambdabot> out of fuel - use @resume to continue
11:36:11 <CosmicRay> vincenz: makes an endless list out of the list you pass it in
11:36:17 <vincenz> @eval 1+1
11:36:17 <lambdabot> 2
11:36:22 <Darius> @get-definition cycle
11:36:22 <lambdabot> cycle = \l.fix (\x.l++x)
11:36:25 <CosmicRay> vincenz: for instance, cycle [1, 2, 3] -> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3..]
11:36:30 * vincenz nods
11:36:35 <CosmicRay> @eval repeat 1000 5
11:36:36 <lambdabot> type error
11:36:48 <shapr> The coolest thing about @eval is that it taught me just how close Haskell is to lambda calculus.
11:36:49 <CosmicRay> @eval repeat 1000 [5, 6]
11:36:50 <lambdabot> type error
11:36:57 <vincenz> shapr: how so?
11:36:57 <Darius> CosmicRay: replicate?
11:37:03 <CosmicRay> ah/
11:37:03 <shapr> I consider that a very powerful lesson.
11:37:08 <CosmicRay> @eval replicate 1000 5
11:37:17 <lambdabot> [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:17 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:17 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:17 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:17 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:18 <vincenz> shapr: because everything is syntactic sugar>?
11:37:18 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:20 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:21 <shapr> Many daily Haskell users mistake @eval for a full Haskell interpreter.
11:37:22 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:24 <lambdabot>  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
11:37:25 <CosmicRay> heh
11:37:26 <shapr> vincenz: yes.
11:37:26 <lambdabot> [33 @more lines]
11:37:34 <vincenz> shapr: it's not?
11:37:40 <shapr> vincenz: see? =)
11:37:48 <vincenz> why?
11:37:51 <vincenz> what doesn't it do?
11:37:55 <CosmicRay> vincenz: IO?
11:38:15 <Darius> Heck, I people kept using \x -> x so I finally added that to the parser.
11:38:18 <CosmicRay> @eval putStrLn "hi" >>= print
11:38:18 <lambdabot> (line 1, column 16):
11:38:18 <lambdabot> unexpected ">"
11:38:18 <lambdabot> expecting simple term
11:38:22 <Darius> @eval (\x.x) 1
11:38:22 <lambdabot> 1
11:38:24 <CosmicRay> monads, too.
11:38:27 <Darius> @eval (\x -> x) 
11:38:28 <lambdabot> <<EM Dynamic -> EM Dynamic>>
11:38:28 <Darius> @eval (\x -> x) 1
11:38:29 <lambdabot> 1
11:38:38 <CosmicRay> @eval putStrLn "hi" (>>=) print
11:38:38 <lambdabot> (line 1, column 16):
11:38:38 <lambdabot> unexpected ">"
11:38:38 <lambdabot> expecting simple term
11:38:45 <shapr> Eval is a neat demonstration of monad transformers as well.
11:38:54 <Darius> CosmicRay: Modulo lack of type classes (and types to boot) you can implement monads.
11:39:03 <Darius> @definitions State
11:39:04 <lambdabot> ["StateT"]
11:39:12 <CosmicRay> @eval replicate 5000 "unicycle"
11:39:12 <Darius> @definitions Monad
11:39:17 <vincenz> @eval (exit 0)
11:39:33 <lambdabot> out of fuel - use @resume to continue
11:39:33 <lambdabot> ["MonadError","MonadLP","MonadParser","MonadReader","MonadState","MonadWriter
11:39:33 <lambdabot> ,"MonadWriter_"]
11:39:33 <lambdabot> unbound variable: exit
11:39:38 <CosmicRay> rats.
11:39:43 <vincenz> @eval (quit 0)
11:39:44 <lambdabot> unbound variable: quit
11:39:53 <vincenz> crap
11:40:01 <Darius> vincenz: Nothing is running; there's nothing to exit.
11:40:02 <CosmicRay> @eval crap
11:40:03 <lambdabot> unbound variable: crap
11:40:07 <CosmicRay> MegaMonad: @eval crap
11:40:30 <MegaMonad> CosmicRay: So.. Now i'm just implementing all the union crap i have an alias called "nap" which is crap :p.
11:40:46 <shapr> MegaMonad: hei
11:40:49 <vincenz> @wen
11:40:49 <lambdabot> Sorry, I don't know the command "wen", try "lambdabot: @listcommands"
11:40:51 <vincenz> @zen
11:40:51 <MegaMonad> shapr: Hei liw, ltns.
11:40:52 <lambdabot> Sorry, I don't know the command "zen", try "lambdabot: @listcommands"
11:41:07 * vincenz should make a lambdabot in ocaml
11:41:13 <vincenz> if I just knew irc
11:41:15 <shapr> yeah, good idea
11:41:45 <vincenz> lambdacpp
11:42:29 <vincenz> the big deal is making it nicely extensible
11:42:34 <vincenz> and designing it well
11:42:43 <vincenz> but first... I need to know irc-protocol
11:42:58 <shapr> it's simple and very limited.
11:43:13 <shapr> lambdabot is just a typeclass with a method for each irc signal.
11:45:20 <vincenz> hmm
11:48:42 <vincenz> crap
11:49:32 <vincenz> fuck
11:49:44 <shapr> salut paf 
11:49:52 <vincenz> I just lost a whole bunch of code :(
11:50:00 <vincenz> something I assumed was in cvs and wasn't
11:50:05 <shapr> darcs!
11:50:07 * vincenz sniffs
11:50:17 <shapr> have you tried darcs?
11:50:21 <shapr> it's a lot easier to use than cvs
11:50:28 <vincenz> no I haven't tried it
11:50:31 <Heffalump> I think it's easier to lose stuff with darcs than cvs.
11:50:39 <vincenz> it's not losing stuff
11:50:42 <Heffalump> though I should try darcshive, that'd make it harder
11:50:44 <vincenz> it's doing rm -rf when it's not in cvs
11:50:51 <Heffalump> vincenz: yes, that kind of losing
11:50:52 <paf> shapr: hi
11:51:04 <Heffalump> it's easier to convince yourself that the patch has been sent elsewhere with darcs when it hasn't
11:51:10 <Heffalump> cos you typically have lots of repositories
11:51:10 <vincenz> anyways to undelete?
11:51:27 <paf> shapr: didn't try haskelldsp yesterday, worked on my thesis instead
11:54:29 <shapr> I have my repo on another box, and I have a cron job to pull my desktop.
11:54:53 * vincenz sighs deeply
11:55:05 <vincenz> WHY!
11:56:03 <Heffalump> shapr: I have problems with that kind of thing when I branch
11:58:30 * Darius wonders how Drupal handles people replying to a comment they preview but never post.
12:15:49 * jdrake begs #haskell for some unused infrared energy, its *COLD* up here
12:18:27 <basti_> where is up there?
12:19:15 <Darius> jdrake: You may find shapr rather unsympathetic...
12:20:08 * shapr is frozen solid
12:20:36 * CosmicRay hands shapr a quartz heater
12:20:39 <Darius> shapr: Don't you have that Duron or Opteron heating your house?
12:25:19 <Lemmih> Should the result from newCString be freed?
12:25:40 <shapr> Darius: true, dual athlon produces some heat.
12:40:12 <CosmicRay> make
12:41:15 <Lemmih> indeed
12:56:50 <CosmicRay> heh
12:56:53 <CosmicRay> oops ww
12:57:02 <CosmicRay> (to the make)
12:58:41 <jdrake> basti_, Canuckistan
12:59:14 <jdrake> Au revoir!
13:03:12 <vincenz> hmm
13:07:53 <Darius> shapr: Somewhat out of the blue; it'd be entertaining to see a guy walking down the street saying "dup pop swap dip" into his phone.
13:14:06 <shapr> heh
13:14:25 <paf> :)
13:15:38 <basti_> jdrake: !
13:16:40 * basti_ didnt get it but is sure it was important
13:19:24 <basti_> i made him go boom.
13:33:37 <Darius> Crap!
13:34:01 <shapr> ?
13:50:17 <TheHunter> how the hell am I supposed to test my code for space leaks in ghci?
13:50:39 <TheHunter> *Main> sum [0..1000000]
13:50:39 <TheHunter> *** Exception: stack overflow
13:51:32 <Itkovian> heh
13:52:33 <Riastradh> If some part of the memory overflows, you have a leak.
13:52:34 <TheHunter> sum is of course perfectly tail recursive and has the necessary strictness annotations.
13:53:01 <Riastradh> Or just a lot of data.
13:53:15 <TheHunter> Riastradh, it's a ghci thingy (i'd call it a bug)
13:54:19 <Riastradh> Oh, right, I think in some cases GHC won't optimize tail calls.
13:55:17 <jadrian> does it make a difference to use -Ox with ghci?
13:55:35 <TheHunter> warning: -O conflicts with --interactive; -O ignored.
13:56:13 <jadrian> hmm let me try
13:56:28 <jadrian> right, must have missed it before...
14:00:57 <Darius> Data.List.foldl' (+) 0 [0..1000000] works, so sum isn't as strict as it could be.
14:01:23 <TheHunter> wow.
14:01:38 <Darius> TheHunter: (-O would probably fix it) This, by the way, is likely the infamous foldl space leak.
14:01:48 <musasabi> TheHunter: space behaviour is different in 1) ghc -O2, 2), ghc, 3) ghci
14:02:03 <TheHunter> Darius, it's the sum function from the _libraries_.
14:02:33 <Darius> TheHunter: Apparently, it's not defined with foldl' for some reason.
14:05:18 <TheHunter> sum     l       = sum' l 0
14:05:18 <TheHunter>   where
14:05:18 <TheHunter>     sum' []     a = a
14:05:18 <TheHunter>     sum' (x:xs) a = sum' xs (a+x)
14:05:43 <TheHunter> ok, i'd call THAT a bug.
14:05:44 <kristnjov> the sum function still amazes me in words i cannot pronounce.
14:08:05 <TheHunter> oh, GHC's Data.List library is full of such crap.
14:08:09 <TheHunter> maximumBy cmp xs        =  foldl1 max xs
14:09:19 <arjanb> :(
14:10:25 <TheHunter> note to self: complain to libraries@ sometime.
14:12:22 <CosmicRay> oh joy.  portugese spam.
14:12:47 <Pseudonym> I had to clean a Brazilian off my server last night.
14:13:04 <Darius> TheHunter: It is possible for the foldl' version of sum to be too strict.
14:14:08 <Darius> TheHunter: And likely with strictness analysis the GHC definition of sum gets the best of both worlds, strict with Ints and such and non-strict when it doesn't know better.
14:15:58 <TheHunter> ah, I see, it's because of nonstrict Num instances.
14:18:17 <Darius> TheHunter: What you may want to complain about, is a -fstrictness-analysis flag that works in GHCi.
14:18:58 <TheHunter> TheHunter, well, i do appreciate the speed of a compile in ghci as opposed to ghc -O
14:19:21 <Darius> That's why it would be a flag, presumably off by default.
14:19:45 <TheHunter> OTOH, hugs defines
14:19:48 <TheHunter> sum               = foldl' (+) 0
14:20:51 <TheHunter> Darius, if someone shows me a sensible Num instances that is broke by
14:21:03 <TheHunter> sum' (x:xs) a = sum' xs $! a+x
14:21:24 <TheHunter> ping
14:21:32 <TheHunter> s/if/unless/
14:21:50 <CosmicRay> MegaMonad: hugs!
14:21:55 <Darius> One that creates expressions.
14:21:56 <MegaMonad> CosmicRay: Hmm. I'm not sure whether that's a hugs-bug?
14:22:00 <TheHunter> i'd prefer the stricter version.
14:22:03 <Darius> E.g. (+) = Plus
14:22:18 <Pseudonym> Darius, how is that broken by that definition?
14:22:47 <Pseudonym> Assuming a non-infinite list as input.
14:22:51 <Pseudonym> Or is that what you meant?
14:22:53 <Darius> Pseudonym: Throw in some simplification code too.
14:23:21 <TheHunter> Darius, grrr, you have a point.
14:23:25 <Pseudonym> Actually, I have a better example.  Linear fractional transformations.
14:24:20 <Darius> TheHunter: Since I'm pretty sure Hugs doesn't do strictness analysis, it's probably not too unreasonable for it to sacrifice semantics for the common case.
14:24:23 <Pseudonym> With LFTs, it makes sense for the list to be infinite.
14:25:33 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/exactreal/
14:25:45 <Pseudonym> EReal is a perfectly legitimate instance of Num.
14:26:08 <Pseudonym> Though not all of the operations are defined yet.
14:26:46 <Darius> Consider product with a Num instance that simplifies expressions and also includes simpifying multiplication by 0 to 0.  An undefined expression may never be evaluated if a later 0 kills it.
14:27:08 <TheHunter> Darius, yes, you're right.
14:27:19 <Pseudonym> But does 0 * undefined == 0?
14:27:36 <Pseudonym> It changes the semantics, but one could argue that if 0 * undefined == 0, that's not necessarily a well-defined Num.
14:28:16 <Pseudonym> In IEEE-754, 0 * undefined == undefined
14:28:25 <Pseudonym> where "undefined" is spelled "NaN"
14:28:41 <Pseudonym> To pick but one example.
14:28:47 <TheHunter> if you tell me ghc can't specialize a function to different definitions, i promise i'll shut up.
14:30:07 <Darius> It can specialize methods, I'm not sure what is does with functions beyond perhaps specializing wrappers.
14:30:27 <Pseudonym> You can produce specialised versions of functions.
14:30:54 <Pseudonym> {-# SPECIALIZE genericLength :: [a] -> Integer -}
14:30:57 <Pseudonym> Or something like that.
14:31:12 <TheHunter> yeah, but you probably can't specialize them strict for ints and doubles and non-strict for all other types.
14:31:28 <Pseudonym> No, but GHC can, I believe, analyse them separately.
14:31:46 <Pseudonym> So it can deduce that it's strict for Doubles.
14:31:47 <TheHunter> So we just have to live with the fact that sum blows up the stack in ghci.
14:32:15 <Pseudonym> Personally, I think the strict version of sum makes more sense.
14:32:28 <Pseudonym> Unfortunately the semantics are different than what's in the spec.
14:32:33 <Pseudonym> s/than/from/
14:33:08 <Darius> I need to reset. I'll be right back... hopefully.
14:41:13 <TheHunter> ok, Darius, Pseudonym. Thanks for your time.
14:44:04 <jadrian> wouldn't an easy way out be declare sum as a method of Num with a default instance?
14:44:38 <Pseudonym> No problem, FWIW.
14:44:47 <Pseudonym> jadrian: Oh, now there's a thought.
14:44:56 <Pseudonym> Trouble is, it's turtles all the way down.
14:45:07 <jadrian> yeap...
14:45:11 <Pseudonym> Now that we add sum, let's add product.
14:45:42 <Pseudonym> Now let's add exponentiation.
14:45:58 <Pseudonym> Now let's add code to compute fibonacci numbers.
14:46:11 <jadrian> hmmm that one's not in the libs ;)
14:46:33 <Pseudonym> No, if it was in the libs, there'd be nothing to each to first year students.
14:46:33 <jadrian> but yes you're right, maximum etc
14:46:42 <jadrian> :)
14:47:06 <Pseudonym> And gcd, of course.
14:47:45 <Pseudonym> Can you supply specific implementations for specialised instances?
14:48:01 <Pseudonym> Instances in the {-# SPECIALIZE -} sense.
14:48:16 <TheHunter> how bout maybeStrictPlus :: Num a => (a -> b) -> (a -> a -> a) -> b ?
14:48:24 <Darius> For specialized methods you already have...
14:48:55 <Pseudonym> No, I don't mean for typeclasses.
14:49:02 <Pseudonym> I mean for the SPECIALIZE pragma.
14:49:59 <TheHunter> hmm, you'd be actually doing the job of the strictness analyser...
14:51:10 <Pseudonym> I wouldn't.
14:51:27 <Pseudonym> Using a SPECIALIZE-like thing, you could use extra information.
14:51:40 <Pseudonym> For example, consider "product".
14:51:54 <Pseudonym> Some Nums have associative multiplication, but others don't.
14:52:05 <Pseudonym> Sorry, commutative.
14:52:12 <TheHunter> good point.
14:52:17 <Pseudonym> Hell, some Nums don't even have associative multiplication.
14:52:21 <Pseudonym> Octonions, for example.
14:52:29 <Darius> Combined with rewrite rules you can.
14:52:31 <TheHunter> or machine doubles...
14:52:36 <Pseudonym> Right.
14:52:54 <Pseudonym> Darius: Yes, but you're getting into the land where there are no guarantees about what code you end up with.
14:53:26 <Pseudonym> Haskell's pragmatics are difficult to comprehend as it is.
14:53:47 <Pseudonym> Ideally, you want some guarantee that the code that the compiler decides to generate makes the problem tractable.
14:53:56 <Pseudonym> Assuming that the input program was tractable to begin with.
14:54:31 <Pseudonym> After all, the reason why you want this behaviour in the first place is to improve something.
14:54:43 <Pseudonym> e.g. to make it run in constant space instead of blowing the stack
14:54:52 <Pseudonym> If that's what you want, you want it guaranteed.
14:54:54 <Darius> Pseudonym: So how would you go about it with guarantees providing specialized implementations?
14:55:21 <Pseudonym> If you could supply a specialised implementation, which the compiler _must_ use if it can...
14:56:23 <Pseudonym> Then it's guaranteed to be used under certain circumstances.
14:56:55 <Darius> Since you can only specialize by type (currently), and I believe rewrite rules always fire, it should always use your rule when it can (i.e. when it has the appropriate type).
15:15:10 * Darius wonders if he should use Java's hashCode for Strings or use his own...
15:16:35 * TheHunter thinks he is going to complain about Text.Show.Functions not exporting anything instead.
15:16:51 <jadrian> I know you're talking about much more then just "sum" now, but still on that subject, the more a think about it, the more I like the idea of having sum and product as methods of Num with default instance
15:17:39 <Pseudonym> Darius: Simple answer is that you shouldn't use Java. :-)
15:17:54 <Pseudonym> More seriously, if Java's hash function is crap, then all hope is lost.
15:18:06 <Darius> Pseudonym: If only that were an option... anyways, this is to implement something so that I can minimize my use of Java.
15:18:50 <Pseudonym> jadrian: Actually, I'd like to see it available for more than just Num.
15:19:00 <Pseudonym> If sum were its own typeclass, we wouldn't need concat.
15:19:28 <Darius> Pseudonym: We don't need concat as it is now.
15:19:57 <Pseudonym> True enough.
15:20:01 <jadrian> yeap
15:20:02 <jadrian> msum
15:20:10 <Darius> join
15:20:17 <Pseudonym> foldr (++) []
15:20:27 <Darius> @type join
15:20:28 <lambdabot> bzzt
15:20:34 <wagle> monskel?  haskadhahaha
15:20:38 <wagle> oops
15:20:40 <tuomov> "summing" lists is ugly
15:20:44 <Darius> @type Control.Monad.join
15:20:46 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
15:20:57 <tuomov> I don't like it all that + is overloaded for concat too
15:21:07 <Darius> tuomov: "concating" functions is pretty.
15:21:07 <wagle> someone fix lambdabot so it can find things that arent at "the top level"
15:21:14 <tuomov> you can't "foo" + "bar" - "bar"
15:21:25 <jadrian> msum is not as general as join but at least it reads better :)
15:21:34 <jadrian> you can read it like multiple sums 
15:21:46 <tuomov> (not unless you define strings as something completely different from what they're now; as the free algebra of them or something)
15:21:47 <jadrian> (even though its's wrong)
15:21:49 <Darius> Actually, join reads pretty well for concat.
15:22:10 <wagle> i mean, if you know enough to ask for Control.Monad.join, you already know the answer
15:22:11 <jadrian> oh 
15:22:14 <jadrian> yes it does
15:22:36 <Darius> wagle: Yes, but I wasn't doing it for my benefit.
15:22:52 <Darius> wagle: There's also @index which helps a bit.
15:22:55 <Darius> @index join
15:22:56 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
15:22:56 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
15:22:56 <lambdabot> State,Control.Monad.Writer,Monad
15:22:58 <wagle> i thought i'd gotten "halfway there" when i thought "join" when I wanted concat
15:24:25 <Darius> The only issue is if GHC doesn't deforest the definition of join for concat is rather wasteful.
15:28:59 <wagle> Darius: what do you mean?
15:30:44 <Darius> Actually, it should already be deforested so nevermind.
15:34:20 <NYRanger> hey all
15:36:55 <arjanb> hey
15:38:54 <jadrian> by the way this reminded me that Data.Monoid has  mempty, mappend, and mconcat with a default definition
15:39:23 <NYRanger> i am wondering, can entire software systems be written by a competent haskell programmer?
15:39:32 <NYRanger> i am looking to explore the world of functional programming
15:40:07 <Riastradh> Yes.
15:40:11 <jadrian> it seems the same situation as (+)/sum and (*)/product
15:41:40 <Pseudonym> Hmmm?
15:41:51 <Pseudonym> Sorry, was busy with something else and saw my name mentioned.
16:04:36 <vincenz> ok
16:04:38 <vincenz> shapr: ?
16:04:51 <vincenz> Darius: ?
16:05:39 <ddarius> I got dropped...
16:05:56 <vincenz> oh
16:05:57 <vincenz> well I was curious
16:06:04 <vincenz> how do I connect to irc?
16:07:12 <ddarius> I'm still missing context...
16:08:05 <vincenz> bot
16:08:12 <shapr> wha?
16:08:18 <shapr> oh
16:08:19 <vincenz> he protocol for connetion to irc
16:08:23 <shapr> read the irc RFC
16:08:36 <shapr> then look at the lambdabot sources to see how that differs from reality :-)
16:08:39 <vincenz> yeah but..
16:09:27 <vincenz> where do I get lambdabot?
16:10:30 <Heffalump> from the pixies
16:11:05 <shapr> lambdabot darcs repo, or http://www.scannedinavian.org/~shae/lbot2.1.tgz
16:11:57 <ddarius> It's 2.1?
16:12:14 * ddarius doesn't remember what it was before.
16:28:47 * Lemmih wonders what happened to the Hackage lambdabot module.
16:29:23 <Heffalump> what's Hackage, again?
16:38:26 <Darius> @wn pithy
16:38:33 <lambdabot> *** "pithy" wn "WordNet (r) 2.0"
16:38:33 <lambdabot> pithy
16:38:33 <lambdabot>      adj : concise and full of meaning; "welcomed her pithy comments";
16:38:33 <lambdabot>            "the peculiarly sardonic and sententious style in which
16:38:33 <lambdabot>            Don Luis composed his epigrams"- Hervey Allen [syn: {sententious
16:38:35 <lambdabot> ]
16:38:37 <lambdabot>      adv : in a pithy sententious manner; "she expressed herself
16:38:40 <lambdabot>            pithily" [syn: {sententiously}]
16:57:33 <Lemmih> Heffalump: A collection of meta information about Haskell packages.
16:59:13 <Lemmih> Welcome back SyntaxNinja .
16:59:35 <SyntaxNinja> hi Lemmih
16:59:46 <Heffalump> hi
16:59:54 * Heffalump lacks coherence, being a bit drunk
17:04:27 <Pseudonym> Don't drink and derive.
17:05:23 <Lemmih> What's the legal age for drinking in the US?
17:05:54 <Pseudonym> Higher than everywhere else in the world, I think.
17:06:42 <Riastradh> 21
17:08:43 <oasisbot> Muhaha
17:08:57 <Lemmih> oasisbot: @moo
17:09:27 <SyntaxNinja> Lemmih: but we can smoke, vote, and join the army at the age of 18.
17:09:46 <Darius> Lemmih: very impressive
17:09:54 <oasisbot> Lemmih: @moo to you
17:09:59 <Lemmih> Darius: ?
17:10:06 <Pseudonym> You can join the army but you can't drink?
17:10:12 <Darius> Lemmih: nevermind
17:10:13 <Pseudonym> So what's the fun of joining the army if you can't drink?
17:10:16 <CosmicRay> MegaMonad: @moo
17:10:25 <CosmicRay> Pseudonym: one can even be drafted into the army
17:10:26 <vincenz> hmmhmm
17:10:30 <MegaMonad> CosmicRay: What should @moo do?
17:10:31 <vincenz> time to write a IRC parser
17:10:32 <CosmicRay> Pseudonym: before being of legal drinking ago
17:10:34 <Lemmih> oasisbot: Not a lambdabot clone, eh?
17:10:37 <Heffalump> you can join the army before you can drink in this country too
17:10:38 <CosmicRay> vincenz: already exists
17:10:41 <Heffalump> 17/18, IIRC
17:10:42 <CosmicRay> vincenz: in at least two places
17:10:45 <Heffalump> or maybe 16/18.
17:10:47 <vincenz> ?
17:10:48 <vincenz> in ocaml?
17:10:51 <Darius> Pseudonym: Last time I checked legality never stopped someone from drinking.
17:10:51 <CosmicRay> oh
17:10:52 <CosmicRay> ocaml
17:10:54 <CosmicRay> why ocaml?
17:10:58 <vincenz> oasisbot is ocaml
17:11:07 <Pseudonym> True.
17:11:07 <vincenz> right now he just forwards console to irc
17:11:24 <Pseudonym> Is that the legal drinking age, or is it the legal selling-of-alcohol-to age?
17:11:42 <Pseudonym> Here, nobody can technically stop you drinking before age 18.
17:12:07 <Darius> Pseudonym: That doesn't make much sense (it's both here unless I'm dreadfully mistaken).
17:12:07 <Heffalump> the latter.
17:12:14 <Heffalump> the US has fucked-up laws
17:12:15 <Pseudonym> Right,.
17:12:22 <Pseudonym> Darius: It makes perfect sense.
17:12:23 <CosmicRay> Heffalump: I thought it was both
17:12:27 <Heffalump> where it's even illegal for parents to give their 20-year-old kids alcohol
17:12:39 <CosmicRay> Heffalump: I thought there was no age limit on that
17:12:44 <CosmicRay> oh well.
17:12:48 * CosmicRay doesn't really care
17:13:01 <Darius> Heffalump: It's illegal, but in most cases it'd be unenforceable.
17:13:05 <Pseudonym> There is a technical thing where below a certain age, giving a child alcohol is child abuse.
17:13:13 <Darius> Heffalump: The law is only that which is enforced.
17:13:13 <Pseudonym> e.g. giving it to toddlers
17:13:16 <Heffalump> I don't think there's a defined age here.
17:13:19 <Heffalump> but yeah, toddlers.
17:13:27 <Heffalump> darius: I've heard of cases where it was.
17:13:36 <Pseudonym> But, for example, there are plenty of churches which will give the eucharist, with alcohol, to adolescents.
17:13:43 <Pseudonym> Admittedly, it's only a sip, but still.
17:13:50 <Darius> Heffalump: I can imagine, which is why I said 'most'.
17:13:54 <SyntaxNinja> in the US, I think it is legal for a parent to give their children alcohol in their own home.
17:13:56 <CosmicRay> Pseudonym: younger than that even
17:14:03 <Pseudonym> There would be a freedom of religion issue there, I'd think.
17:14:03 <Heffalump> fear of enforcement also has an impact
17:14:12 <Heffalump> SyntaxNinja: I believe that's not the case.
17:14:37 <Riastradh> I, too, have heard that that's the case, Heffalump.
17:14:38 <Pseudonym> Now, of course things like driving while under the influence, or being drunk in public, is an offence no matter what age you are.
17:14:40 <Darius> Heffalump: Yes, true, but there comes a point where it's understood which laws are enforced.
17:14:43 <atom-z> heh, in the USA you can die for your country after age 18, but cannot drink until you are 21?!?
17:14:56 <Nioate> yup
17:14:58 <Pseudonym> atom-z: Correct.  You can only have other people kill you.
17:15:00 <Nioate> atom-z: 
17:15:13 <Pseudonym> You can also be executed for a crime committed while legally a child.
17:15:16 <SyntaxNinja> ahh, it's refreshing to see non US folks get a taste of the ironies of life that we're used to
17:15:52 <stepcut> Pseudonym: having other people kill you is only allowed in some cases 
17:15:53 <stepcut> ...
17:16:12 <Pseudonym> True.
17:16:43 * Darius is thinking about writing a program to generate Java code.
17:16:48 * Darius is a real Java programmer now.
17:16:58 <stepcut> Namely, if you want someone to kill you, then that is probably illegal (for you), but if you didn't want to be killed, then it probably is legal (for you) :p
17:17:25 <atom-z> the world's pretty screwed over anyway
17:19:17 <Lemmih> shapr: ping.
17:21:55 <atom-z> pong
17:24:47 <Riastradh> Lemmih, your ping missed.  Try aiming more carefully.
17:31:43 <Darius> *sigh* Why isn't there a method Integer add(Integer) in clasS Integer etc.
17:33:27 <wagle> what would is do?  modify the current integer?  do an implied new?
17:33:47 <arjanb> are you talking about java?
17:33:57 <dons> that's what it looks like ;)
17:33:59 <Darius> wagle: The return type suggests implied new, it is a garbage collected language.
17:34:07 <Darius> arjanb: yes
17:36:37 <Darius> wagle: Rather what I'd want is Integer and co. to implement an interface along the lines of Haskell's Num.
17:37:30 <wagle> might be different in 1.5, where i beleive that Object Integer and basetype integer interconvert freely
17:38:06 <Heffalump> basetype int
17:39:21 <Darius> That would help but unfortunately I can't use 1.5.  I'm not sure if the autoboxing applies to Number though.
17:39:57 <Darius> (or maybe the compiler doesn't care at all)
18:19:09 <vincenz> test
18:19:25 <vincenz> right now he just forwards console to irc
18:19:25 <vincenz> right now he just forwards console to irc
18:19:25 <vincenz> right now he just forwards console to irc
18:19:25 <vincenz> right now he just forwards console to irc
18:19:25 <vincenz> right now he just forwards console to irc
18:19:28 <vincenz> right now he just forwards console to irc
18:19:30 <vincenz> right now he just forwards console to irc
18:19:33 <vincenz> right now he just forwards console to irc
18:19:34 <arjanb> ?
18:19:35 <stepcut> how nice
18:19:36 <vincenz> right now he just forwards console to irc
18:19:38 <vincenz> ack
18:19:43 <stepcut> right now he just kicks your ass
18:19:50 <vincenz> sorry
18:19:53 <vincenz> up arrow and then enter
18:19:55 <stepcut> :p
18:19:56 <vincenz> but it was the wrong one
18:19:58 <vincenz> :/
19:04:15 <sjanssen> why does Num depend on Show and Read?
19:05:29 <arjanb> @info Num
19:05:31 <lambdabot> -- Num is a class
19:05:31 <lambdabot> class (Eq a, Show a) => Num a where {
19:05:31 <lambdabot>     (-) :: a -> a -> a {- has default method -};
19:05:31 <lambdabot>     (*) :: a -> a -> a;
19:05:31 <lambdabot>     (+) :: a -> a -> a;
19:05:31 <lambdabot>     negate :: a -> a {- has default method -};
19:05:34 <lambdabot>     signum :: a -> a;
19:05:36 <lambdabot>     abs :: a -> a;
19:05:37 <lambdabot>     fromInteger :: Integer -> a;
19:06:23 <sjanssen> sorry, not read
19:06:32 <sjanssen> but why Show?
19:06:40 <arjanb> i have no idea why..
19:24:28 <sh10151> same reason Char does I imagine
19:25:48 <MegaMonad> Greetings dash, yes parsec *is* sexy.
20:31:38 <NYRanger> hey guys, i was in here earlier.  I want to learn functional programming (way too tired of C/C++).  I've played around with some and they seem really cool but very new for me.  Where should I begin>
20:33:06 <Gahhh> haskell.org
20:33:15 <shammah> NYRanger, what languages do you already know?
20:33:37 <Gahhh> yay, MegaMonad is back
20:34:17 <NYRanger> shammah: know is a very weird word.  I have done C/C++/Java/PHP
20:34:31 <wli> NYRanger: Hard work. Rote drill. Practice practice practice.
20:34:52 <NYRanger> Java is probably my best cause i've actually done real stuff in it, C/C++ was mostly used by me for testing stuff, etc.  Never did hardcore C/C++ projects.
20:35:16 <Gahhh> NYRanger, there are some good online tutorials. There are also a few good books. Since you haven't done functional programming before, it's going to take a while to get used to. Be patient.
20:35:58 <NYRanger> my interest in functional programming comes from a teacher in college, who seems to be the best teacher and he is into ML.  He is bringing a course that has never been offered.  it will basically introduce people to Ada, Haskell, and Smalltalk.  Nobody in my college has even heard of it.  I have heard of all of them, but never done any.
20:36:53 <Riastradh> NYRanger, although it's not Haskell, you should read SICP <http://mitpress.mit.edu/sicp/>.
20:37:40 <shammah> I was about to suggest that you take a look at Ocaml, as a gentler introduction to functional programming than haskell.  But if you are going to be doing a course that includes haskell then by all means go download hugs or ghc (links on www.haskell.org) and try them out.
20:37:56 * shammah concurrs with riastradh, SICP is definately a good place to start.
20:38:11 <NYRanger> shammah: my teacher actually wrote a paper about MetaOCamlServer Pages
20:38:26 <Gahhh> I concur with Riastradh as well, but I couldnt read SICP. I just didn't have any time to spend on lisp.
20:38:26 <NYRanger> teacher=professor
20:40:32 <NYRanger> the SICP seems very very interesting.
20:41:08 <NYRanger> what are the limits/uses of Haskell?
20:41:25 <NYRanger> i know that might sound troll like, but I Just dont have an idea of how far haskell programs can go.
20:41:33 <Riastradh> NYRanger, ask yourself 'what are the limits/uses of C++?'
20:42:02 <Gahhh> Ugh
20:42:08 <Riastradh> If you can come up with a good, concise answer to that, please tell us so that we can have an idea of how you want us to answer your question.
20:42:40 <Gahhh> Riastradh, I think you know what he means.
20:42:56 <Riastradh> No, I really don't know what he means, or what sort of answer he's looking for.
20:43:00 <Gahhh> For example, you wouldnt tell me that perl is good for device driver development.
20:44:47 <aj> NYRanger: haskell is your regular functional programming language, but with extra features that you can implement serious programs in it
20:45:38 <aj> NYRanger: functional programming is good for complex, recursive algorithms; bad for having really strong control over what the computer's actually doing
20:46:11 * wli <-- does things where precise control over what the cpu is doing is an absolute requirement
20:46:34 <wli> interesting little debate wrt. in-kernel GC
20:46:45 <wli> various kernels have grossly unsound memory management
20:47:09 <Riastradh> Most memory management is grossly unsound.
20:47:09 <wli> GC'd kernels can pretty much get identical behavior
20:47:39 <Gahhh> wli, identical behavior or performance or both ?
20:48:44 <wli> probably both
20:48:52 <wli> I don't have proof of that assertion
20:48:59 <wli> it's merely an "expectation"
20:49:39 <wli> the strict accounting and very early resource availability/entitlement checks required for soundness are never done in practice
20:50:00 <wli> maybe a research kernel or two
20:50:07 <NYRanger> my teacher is all about this "type safety", what is that all about/
20:50:29 <Gahhh> NYRanger, you know C++. That doesnt mean anything ?
20:50:47 <wli> the attitude taken is that the sysadmin and/or privileged apps have to figure out resource control, and it's okay for the kernel to crash when some idiot forkbombs or whatever if there are no manual resource controls on it
20:50:52 <Gahhh> wli, now this is about the kernel's management of memory, right ? not the applications ?
20:50:58 <wli> yes, the kernel's
20:51:00 <NYRanger> Gahhh: I dont know C++ that well, but I dont like it it much...
20:51:51 <Gahhh> NYRanger, when you try to assign 'A' to a pointer to a double in C++, what do you get from the compiler ?
20:52:15 <NYRanger> Gahhh: i'm not sure but the compiler might catch that as a type mismatch or something like that.
20:55:04 <Gahhh> NYRanger, http://en.wikipedia.org/wiki/Type_safety explains it better than I can.
20:57:16 <NYRanger> thanks.
20:57:24 <Pseudonym> Anyone know anything about colour matching?
20:57:36 <NYRanger> i know this is inappropriate but how is Haskell diff from ML?
20:57:54 <Pseudonym> Trying to work out the normalisation factor for the CIE color matching functions.
20:57:55 <Gahhh> Pseudonym, anything to do with RGB values ?
20:58:01 <Pseudonym> Kind of.
20:58:02 <Gahhh> oh
20:58:09 <Pseudonym> I have a spectrum, and I want to convert to RGB.
20:58:24 <Gahhh> Pseudonym, I recommend the color FAQ
20:58:43 <Pseudonym> Ah, good idea.
20:58:51 <shammah> NYRanger, One immediate difference is haskell is non-strict while ML is strict.
20:59:23 <Gahhh> ML is also not pure, correct ?
20:59:28 <shammah> correct.
20:59:47 <shammah> Although ML is more pure than something like scheme or lisp.
20:59:48 <NYRanger> so how can it be strict and not pure? it seems those 2 would go together.
20:59:53 <Gahhh> When I was a beginner (ugh. I still am lol), those terms didn't mean much. I know what they mean now, tho.
20:59:55 <shammah> They are both strongly-typed.
21:00:29 <shammah> strict describes how arguments to functions are evaluated.  pure vs. non-pure describes the languages approach to issues such as referential transparency.
21:01:10 <Gahhh> NYRanger, strict and pure are not related. Since you know C++, did you know that when you say "if ( 1 || (func()) )", the func() may not be executed ? I think they call it "short-circuiting" in C.
21:01:31 <shammah> In Haskell the arguments to functions are evaluated 'on-demand', unlike C/C++/Java/ML/etc where they are evaluated before the body of the function is executed.
21:02:15 <shammah> As Gahhh notes, it's alot like boolean short-circuiting, only more general.
21:08:48 <Gahhh> Does anyone use GHCi from within Emacs on Windoze ? It pops up a command prompt that annoys me.
21:25:07 <monochrom> 0 ? 1/0 : 1  /* very cool C code */
21:25:34 <monochrom> let f _ = 10 in f (1/0)  -- very cool haskell code
21:25:54 <wli> well
21:26:16 <monochrom> head [10, 1/0]   --- cunning
21:29:37 <wli> let { primes = 2:3:5:[p | p <- [7,9..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 < p) primes)] ; cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs) } in take 10 . map fst . filter (uncurry (==)) . cantor $ [[(x,y) | x <- primes] | y <- [4*k+1 | k <- [0..]]] -- cooler Haskell code IMHO
21:31:42 <wli> a less trivial list subset of N than naturals equal to 1 mod 4 may be spiffier
21:31:54 <wli> but anyway, you get the idea
21:32:00 <wli> intersection of infinite lists
21:33:46 <wli> et { cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs) } in take 10 $ cantor [[(i,j) | j <- [0..]] | i <- [0..]] -- also cool even without intersections of infinite lists
21:34:13 <wli> the result is [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)]
21:48:12 <jdrake> Do you guys know if there are any answers to the exercises in soe?
21:49:36 <wli> there are other neato things around...
21:51:46 <wli> Algebra> (^3) + (^2) $ (2::Z)
21:51:46 <wli> 12
22:00:02 <wli> *Algebra> (^3) + ((4::Z) .*. (^2)) + ((3::Z) .*. id) + (const (1::Z)) $ (2::Z)
22:00:02 <wli> 31
22:00:43 <wli> the ::Z qualifiers may very well have something to do with why integer literals should be fromIntegral n
22:06:23 <wli> it would've been nice if the signature were map :: Functor f => (t -> t') -> f t -> f t'
22:12:06 <wli> class Zip z where
22:12:06 <wli>         fzip :: (t -> t' -> t'') -> z t -> z t' -> z t''
22:12:06 <wli> instance Zip [ ] where
22:12:06 <wli>         fzip = zipWith
22:12:06 <wli> instance Zip ((->) t) where
22:12:07 <wli>         fzip f g h = \x -> f (g x) (h x)
22:28:24 <wli> fzip3 f xs ys zs = fzip ($) (fzip f xs ys) zs
22:28:28 <wli> fzip4 f ws xs ys zs = fzip ($) (fzip3 f ws xs ys) zs
22:28:33 <wli> fzip5 f vs ws xs ys zs = fzip ($) (fzip4 f vs ws xs ys) zs
22:28:37 <wli> etc.
22:28:40 <wli> there is a pattern here
22:29:13 <wli> and that's not even the most general type for the things...
22:29:59 <wli> because of this:
22:30:03 <wli> class Applicative t t' t'' | t -> t', t -> t'' where
22:30:03 <wli>         ($) :: t -> t' -> t''
22:30:10 <wli> (used for polynomial evaluation)
22:35:05 <wli> makes me wonder why curry3/uncurry3 and higher aren't done
22:44:14 <wli> that's the sparc64 version
22:44:17 <wli> I just wrote a sparc32 version
22:44:36 <Gahhh> Hey Ninja. been to San Jose yet ?
22:47:07 <SyntaxNinja> Gahhh: yeah, I'm back home
22:47:23 <Gahhh> Weather's been horrible.
22:50:32 <SyntaxNinja> it was nicer in Monterrey than in Portland :)
22:50:41 * wli is in portland
22:51:21 <Gahhh> how's spam, wli
22:52:40 <Gahhh> For your enjoyment: http://mathworld.wolfram.com/ASSTheorem.html
22:53:26 <SyntaxNinja> wli: me too! :)
22:53:37 <wli> Gahhh: hell
23:23:46 <tintin> i am using emacs to type in my haskell programs i sometimes run into parser error with the compiler 
23:23:58 <tintin> how do i intend the code ?
23:24:09 <arauko> is Haskell a good choice to write compilers?
23:24:26 <andersca> yes
23:24:30 <andersca> arauko: definitely!!
23:24:42 <tintin> hmmz so it can be slow ?
23:24:57 <wli> FP languages are supposed to be relatively easy to write compilers compared to various other languages.
23:25:14 <arauko> interesting
23:25:27 <SyntaxNinja> arauko: GHC is written in Haskell.
23:25:38 <arauko> nice.
23:25:41 <andersca> hey SyntaxNinja 
23:25:44 <wli> 12:30 sounds good
23:25:55 <SyntaxNinja> heh
23:26:05 <Gahhh> tintin, probably a tabs vs spaces problem
23:26:17 * wli is attempting to resurrect sparc32 from the ashes
23:26:33 * wli is not getting far
23:26:39 <tintin> cant the emacs haskell mode handle it a bit better ? 
23:26:43 * Gahhh has an unused ultrasparc-10 in his cubicle
23:26:44 <SyntaxNinja> hi andersca
23:26:53 <tintin> goodluck wli 
23:27:01 <arauko> Can you recommend a good tutorial for a beginner to follow?
23:27:04 <SyntaxNinja> tintin: it has been abandoned for a while, but someone has taken it over, so it should get better soon.
23:27:13 <arauko> something that doesn't scare me off :-)
23:27:22 <tintin> so what do most of them use ?
23:27:25 <Gahhh> arauko, have you already seen the one at haskell.org or not ?
23:27:33 <tintin> Yet another haskell tutorial 
23:27:34 <SyntaxNinja> arauko: the cryptol compiler is also written in Haskell :) http://www.galois.com/cryptol.php
23:27:36 <Gahhh> tintin, I use emacs and I have it set to use spaces only
23:27:38 <arauko> Gahhh, yes, but there are lots of them.
23:27:39 <SyntaxNinja> @learning
23:27:39 <lambdabot> Sorry, I don't know the command "learning", try "lambdabot: @listcommands
23:27:50 <SyntaxNinja> @wiki LearningHaskell
23:27:50 <lambdabot> http://www.haskell.org/hawiki/LearningHaskell
23:28:00 <Gahhh> arauko, The Gentle Introduction is a good place to start
23:28:13 <arauko> yes, im there, but which one do you recommend ... ok Gahhh
23:28:20 <tintin> ooh but its not so gentle :)
23:28:42 <Gahhh> I don't know of any that is gentler
23:28:45 <SyntaxNinja> I like the gentle introduction... I have heard that YAHT is good, but never got around to looking at it since I had to give him my email address or soemthing
23:28:57 <tintin> yet another haskell tutorial ...
23:29:07 <tintin> its very gentle 
23:29:27 <tintin> SyntaxNinja: i could mail it to you :D
23:29:45 <Gahhh> then he has to give YOU his email address...
23:30:04 <tintin> thats exactly why i made him that offer :D
23:30:05 <arauko> :-P
23:30:12 <SyntaxNinja> hehe
23:30:19 <Gahhh> just DCC it heh
23:30:20 <SyntaxNinja> I was just being lazy I guess
23:30:34 <tintin> SyntaxNinja: i will dcc it to ya if ya want
23:31:09 <arauko> A Gentle Introduction to Haskell (http://www.haskell.org/tutorial/) -- Mmmm, gentle like a Metallica concert :)
23:31:14 <arauko> haha
23:31:27 <Gahhh> Metallica has been quite gentle recently imho
23:31:39 * wli ponders "The Rough Gide to Haskell"
23:31:42 <Gahhh> asyptotically equalt to Britney
23:31:45 <mflux> I think the first advice I heard from this channel was along the lines "don't believe anything that has 'gentle' in its name" [that it is]
23:32:27 <wli> (there is a series of travel books whose titles are "The Rough Guide to $COUNTRY")
23:32:35 <SyntaxNinja> heh
23:33:01 <SyntaxNinja> maybe a version of those "how to survive a plane wreck, how to dodge a machine gun" survival books
23:33:19 <wli> they weren't quite that rough
23:33:19 <Gahhh> "A Gentle Introduction to Self-Circumcision"
23:33:29 <wli> AFAICT there was no real justification for the name "rough"
23:35:35 <tintin> if anyone else wants the file Yet another haskell tutorial while i am at it i will dcc it ..
23:36:38 <Gahhh> how about a tutorial torrent tracker
23:37:01 <tindcc> nope cant do i have measly little bandwidth 
23:37:54 <arauko> Nothing like "Haskell for Dummies" ?
23:38:09 <tindcc> arauko: this is something like that 
23:38:33 <tindcc> yet another haskell tutorial is pretty much in that class ...
23:38:48 <arauko> im astonished, i found in a booksotre a book called "The holy bible for Dummies" 
23:38:58 <Gahhh> arauko, I think you are overly worried. None of them are that bad.
23:39:02 <arauko> i couldn't help laughing at that really haha
23:39:10 <Gahhh> arauko, it's not funny actually
23:39:25 <arauko> haha
23:39:38 <Gahhh> They could have used that book in the dark ages
23:39:43 <arauko> well, it makes me laugh , i don't know why though
23:40:04 <arauko> tindcc, thanks.
23:40:27 <Gahhh> arauko, I would have laughed, too, with a blashphemous aftertaste, tho
23:40:34 <tindcc> yeah its difficult to sign up and download that thing ... 
23:40:46 <arauko> tindcc, yeah?, hah, why?
23:41:14 <tindcc> you gotta give ur email id and whatnot i found it difficult from my text borwser :)
23:41:24 <arauko> oh
23:44:28 <arauko> http://www.haskell.org/humor/homework.html
23:44:30 <arauko> haha
