02:21:55 <shapr> good morning #haskell!
02:23:13 <dons> good morning shapr :)
02:23:35 <shapr> g'day dons, did you have a fun christmas?
02:24:01 <dons> yes. it was good. a nice break. and did more design on yi synhl too
02:24:07 <shapr> oohh
02:24:13 <dons> hopefully get some code in soon
02:24:18 <shapr> I want to hear about it.
02:24:30 <shapr> What's your conclusion?
02:24:57 <dons> well, I've worked out how to reenter the ghc parser
02:25:14 <dons> basically so we don't have to reparse the file every time something changes
02:25:32 <dons> you can just call parseIdentifier on the current string
02:25:39 <dons> so that should help
02:25:47 <shapr> yeah, it sounds good.
02:26:34 <shapr> Have you thought about displaying synhl?
02:27:07 <dons> well, I think we just traverse the syn tree, using position information to work out how to display stuff
02:27:20 <dons> only problem is that then the parser would have to record position information
02:28:16 <dons> another issue is that most lexers strip comments out
02:28:47 <dons> so do we knit them back in to the parse tree, or do somehing else?
02:28:54 <shapr> Yeah, I had to deal with that when I tried to write a refactoring browser long ago.
02:29:33 <shapr> I ended up modifying the existing parser to add comment parsing and a comment node type to the resulting tree.
02:30:02 <shapr> I was only dealing with one language, which made that easier.
02:30:20 <dons> yeah. and I think this would be easy enough to do to the ghc parser too.
02:33:46 <shapr> Can the ghc parser be extended to deal with other languages later? Or do you think the Yi general purpose parsing code will end up using something else, once the Haskell part works well?
02:34:19 <dons> the ghc parser will just be the Haskell parser plugin we use. I'll have to wrap it up in a nice interface
02:35:04 <dons> hmm. we could even implement a regex-hack lib for languages where regexes given reasonable lexical highlighting
02:35:07 <dons> e.g. sed
02:44:50 <shapr> I'm slowly learning how to make keymaps, seems to be the only way I'll ever get an emacs keymap done.
02:45:10 <shapr> er, slowly writing a tutorial on making keymaps.
02:45:25 <shapr> starting out with just an insertChar keymap and working my way up.
02:46:37 <shapr> Do you have a bibliography of documents you're perusing to learn stuff like undo, synhl, and incremental parsing?
02:55:05 <shapr> What's the difference between fix, mfix, fixIO, and fixpoint in general?
02:55:11 * shapr searches around.
02:55:56 <shapr> is fix necessarily tail recursive?
02:58:00 * shapr suspects so
02:58:53 <dblhelix> fix f = f (fix f): looks pretty tail recursive :)
03:00:34 * shapr reads http://www.haskell.org/hawiki/FixedPointCombinator
03:01:09 <dblhelix> mfix establishes a monadic recursion scheme
03:01:59 * shapr blows a fuse on http://www.haskell.org/hawiki/TyingTheKnot
03:04:11 <shapr> I don't really understand mdo.
03:04:27 <shapr> iterate a function until a value is returned.
03:04:32 <shapr> How is that different from fix by itself?
03:05:12 * shapr keeps reading.
03:05:57 <dons> shapr: the undo stuff is cited in Undo.hs, the syn hl stuff is in TODO, but  I'll put more refs up somewhere
03:06:33 <shapr> ok
03:12:54 <musasabi> What is the easy way of performing an IO action N times?
03:13:44 <musasabi> mapM_ foo [1..n], sequence_ (replicate n foo), and replicateM_ n foo seem all to fail.
03:17:24 <musasabi> sequence_ [(\_ -> foo) x | x <- [1..n]] does not help either :-(
03:23:31 <Cale> how does sequence_ (replicate n foo) not work?
03:24:02 <dons> replicateM_ n x   = sequence_ (replicate n x)
03:24:49 <musasabi> found the culprit.
03:25:03 <musasabi>           replicateM_ m (modifyIORef ref (\x -> let u = x+1 in u `seq` u))
03:25:29 <musasabi> This seems to overflow the stack, while the next one works:
03:25:31 <musasabi>           replicateM_ m (do { x <- readIORef ref; writeIORef ref $! x+1 })
03:26:11 <musasabi> now why is modifyIORef so lazy?
03:35:46 * ibid wrote a for function the other day for this purpose (no need for an intermediate list to map over)
03:54:29 * basti_ </christmas>
03:55:23 <ibid> oh no
03:55:29 <ibid> christmas ends on 6th of Jan
03:55:47 <basti_> not where i live.
03:55:55 <basti_> i hope.
03:56:06 <ibid> basti_: it's not a matter of where you live :)
03:56:16 <ibid> it might be a matter of which church, if any, you belong to
03:56:17 <basti_> hm.
03:56:25 <basti_> what if i dont? :)#
03:56:42 <ibid> i've been taught that christmas ends on epiphany, which is 6th of Jan
03:57:00 <ibid> basti_: i suppose you get to make up your own rules :)
03:57:20 <basti_> see. and then christmas ends when the christmas visit to my parents ends.
03:57:48 <ibid> heh :)
03:58:14 <ibid> hmm, is ":)#" a bearded man smiling, or what?
03:58:36 <basti_> no that was a typo
03:58:42 <ibid> heh
03:58:45 <basti_> i slipped from the return key
03:58:52 <ibid> hmm
03:59:06 <ibid> my # is in the opposite end of the keyboard from the return key
03:59:11 <ibid> (shift-3)
03:59:13 <basti_> mine is not.
03:59:15 <basti_> ;)
03:59:31 <basti_> right to ä, below +
03:59:47 <ibid> i have ' next to ä
03:59:55 <basti_> my ' is shift #
03:59:59 <ibid> and shift-' is *
04:00:06 <basti_> do you have a mac?
04:00:14 <ibid> my + is next to 0
04:00:15 <ibid> no
04:00:25 <basti_> but english keyboard?
04:00:33 <ibid> no :)
04:00:36 <basti_> but?
04:00:41 <ibid> finnish keyboard
04:00:49 <basti_> oh. is that standard there?
04:00:57 <ibid> supposed to be the same as the swedish keyboard
04:01:03 <ibid> basti_: yeah
04:01:22 <ibid> i suppose you have y where i have z?
04:01:29 <basti_> german is qwertz
04:01:36 <ibid> yeah
04:01:40 <ibid> finnish is qwerty
04:01:51 <basti_> and shift number is !"§$%&/()=
04:01:57 <basti_> and next to the 0 there is ß
04:02:05 <ibid> no such thing here :)
04:02:10 * basti_ grins
04:02:27 <ibid> next to 0 there is +, shift-+ is ? and altgr-+ is \
04:02:44 <basti_> actually im happy that we dont use a font that would seperate all the sounds.
04:02:52 <ibid> hmm?
04:03:03 <ibid> i don't think it's a matter of font :)
04:03:04 <basti_> our ? is in the same place
04:03:18 <basti_> no i mean, german has more vowel sounds than vowel characters
04:03:30 <ibid> yeah, that's not a matter of font :)
04:03:41 <basti_> well its not?
04:03:45 <basti_> i was thinking like IPA
04:04:00 <ibid> that's a character set issue, not a font issue
04:04:06 <basti_> okay.
04:04:09 * basti_ nods
04:04:09 <ibid> :)
04:04:34 <ibid> MegaMonad: i dreamed about buses today, and ended up not going to work :/
04:04:39 <MegaMonad> ibid: We could all be defined for you, but i work all the buses.
04:04:49 <ibid> MegaMonad: it was you all along!!!
04:04:55 <MegaMonad> ibid: Thanks, i worked on 1980(?) jaguar, 1940 cadillac, 1973 corvette, 1970 ford truck, 1978 ford fiesta, 1943(?) austin-healey, 1947 dodge truck, 1978 dodge van, and several others that i recommend \r if it is a pretty dumb i can't implement a monad is supposed to cheat.
04:05:22 <basti_> btw. whats the relation between funktors and monads?
04:05:41 <ibid> they are both category theory concepts?
04:05:42 <basti_> are monads a fancy notation for functor operations?
04:05:52 <ibid> no idea
04:05:55 <basti_> no i mean, "list" can be used monadically
04:06:04 <ibid> yes
04:06:23 <basti_> but its also a Coalgebra
04:06:38 <basti_> (that is, its structural function)
04:08:32 <basti_> i think there must be a sort of relation but putting it to words is beyond my capacities
04:10:05 <ibid> bus time, bbl
05:12:17 <shapr> man I love unicycling.
05:15:25 <shapr> I've been thinking of a new kind of serial connection. So far I've only come up with a name, shoetts.
05:15:28 * shapr snickers
05:15:44 <shapr> maybe a really lightweight udp connectionless thingy is a sandalet?
05:16:05 <basti_> ow.
05:16:46 <shapr> then there's the bootit, a super heavy duty ssh connection with extra checking?
06:09:30 <shapr> hiya isomer`
06:18:33 <isomer`> hi shapr! how goes?
06:24:10 <goron> MegaMonad: What's the weather like at your place?
06:24:16 <MegaMonad> goron: Is it possible to get my head around the i/o in python, that's why i dislike it, but fib 10 in my case.
06:24:40 <goron> MegaMonad: What's fib 10?
06:24:46 <MegaMonad> goron: Or "there are 10 people in the 10 commandments which i need to grab it off the homepage is currently mktime, which is probably in debian packages.
06:31:06 <musasabi> fib = fibonacci.
06:34:25 <goron> musasabi: I thought so. Oh, well, I think I understand it :D 
06:35:56 <goron> musasabi: He only doesn't use a measurement unit. 
06:36:18 <musasabi> true.
06:57:07 <shapr> isomer`: it's winter, there's code. How are you?
07:11:21 * goron is finally able to write an logical expression parser within the hour :D
07:12:03 <basti_> :)
07:12:05 <goron> an->a
07:12:14 <basti_> what type of parser?
07:12:45 <goron> Propositional (used an backtracking parser, because of it's clean API)
07:12:56 <goron> basti_: With priorities. 
07:13:03 <basti_> :)
07:13:12 <basti_> in an hour?
07:13:21 <goron> basti_: Yes.
07:13:31 <basti_> cool thing.
07:14:23 <ibid> what's a propositional parser?
07:14:50 * basti_ wonders too but didnt dare to ask. but priorities sure sounds nice.
07:15:02 <goron> ibid: It can parse strings like p->p and -(p \\/p)
07:15:10 <goron> ibid: Simple logic. 
07:15:39 <goron> ibid: The parser itself uses parser combinators. 
07:16:01 <ibid> ahh, it's a parser for propositional logic, not a propositional parser :)
07:16:17 <goron> ibid: Right :)
07:16:36 <basti_> ah.
07:16:41 <basti_> and what technique does it use?
07:16:49 <basti_> "recursion parser"?
07:16:50 <goron> ibid: I bet I can write a propositional parser too. But that takes more than one hour. 
07:17:05 <sam_> what does ~ mean as in ~(x:xs)?
07:17:12 <shapr> hiya skypp, learning Haskell?
07:17:24 <goron> sam_: Lazy pattern, I thought. 
07:17:36 <ibid> goron: okay, i ask again. what's a propositional parser? :)
07:18:14 <goron> ibid: Well, maybe I could transform the grammar to logic and then parse it ;)
07:18:59 <goron> ibid: That's what computers do al the time. 
07:19:04 <goron> al->all
07:19:14 * shapr hops
07:20:11 <goron> basti_: The list of answers technique. The name is different, but you get the idea.  
07:20:22 <basti_> yup.
07:23:06 <sam_> as in binds as needed? when is that needed?
07:23:27 <goron> sam_: The example used always is a server. 
07:24:01 <wolfman8k> MegaMonad: sup
07:24:03 <sam_> is there an online example you know of?
07:24:07 <MegaMonad> wolfman8k: I have a "class subtype sub sup" class with inj and prj functions..  It depends on how itworks.
07:24:21 <goron> sam_: It's in the language report (or not). It could also be in the Hal Daume III's tutorial.
07:25:38 <goron> sam_: http://www.haskell.org/tutorial/patterns.html
07:25:41 <shapr> hiya tojoko, how's code?
07:26:33 <tojoko> Hello shapr, very small - and that's not good for this time. ;)
07:26:58 <tojoko> 'cause i had to do haskell last year - but now i gotta learn prolog. 
07:27:03 <sam_> thanks goron
07:27:18 <tojoko> Was glad, that haskell worked on BeOS.
07:27:40 <shapr> Does prolog work on BeOS?
07:27:59 <Lunar^> shapr: pesco made a talk on Haskell at CCC in Berlin
07:29:08 <shapr> Lunar^: nifty! Were you there?
07:29:19 <shapr> Is the talk online?
07:29:20 <Lunar^> shapr: nope
07:29:20 <tojoko> shapr, i heard it does - but did not try it yet. Should do this in the next view days. But i don't like compiling to much, if i haven't done the code.
07:29:21 * shapr asks google
07:29:26 <Lunar^> http://www.scannedinavian.org/~pesco/
07:29:35 <Lunar^> but you should know that :)
07:29:53 <goron> Does anyone know anything about Combinatory Logics? And why most compilers don't use it?  
07:30:10 <shapr> yes, I've heard of that website ;-)
07:30:11 <tojoko> shapr, oh, from scandinavia.
07:30:32 <shapr> tojoko: I'm from Alabama, USA. But I live in Scandinavia.
07:30:41 <tojoko> Good choice.
07:30:55 <shapr> hei Defty 
07:31:15 <shapr> tojoko: I'm having a european adventure. It's been lasting for five years so far.
07:31:43 <sam_> thx
07:31:55 <tojoko> shapr, where have you been? Do you speak swedish? I know, it's not necessary in Sweden.
07:32:46 <shapr> I've been three years in Finland, two years in Sweden. I speak a passable amount of Swedish.
07:32:54 <shapr> hiya dottedmag 
07:33:37 <shapr> I haven't gotten around to learning logic languages yet. One day I will.
07:33:56 <tojoko> Is it difficult to learn?
07:34:29 <shapr> Swedish isn't hard to learn, especially if you already know German.
07:34:39 <shapr> Finnish is hard to learn, but also very nifty.
07:34:44 <tuomov> genders are difficult..
07:35:06 <tuomov> but if you know german, that shouldn't be a problem
07:35:13 <tuomov> at least swedish has "only" two genders
07:35:38 <shapr> Finnish only has one.
07:35:53 <shapr> Han on amerikalainen.
07:36:09 <basti_> german has dative and inversion =)
07:36:33 <tojoko> What are genders? Female, Male?
07:36:42 <basti_> yep
07:36:52 <tojoko> And what's inversion? Dative, btw, isn't often used.
07:37:04 <wli> Russian has dative, genitive, ablative, and the animate accusative...
07:37:09 <basti_> cool.
07:37:15 <wli> it also declines nouns extensively
07:37:26 <wli> perfective/imperfective aspects are also wildly different
07:37:43 <shapr> Finnish has seventeen things you can do to a word, and you can use lots of them at the same time. Happily, only fifteen of those things are in common use.
07:37:46 <basti_> inversion is when you can put a word on the beginning of a sentence to stress it.
07:38:17 <tuomov> shapr: and even less in spoken language
07:38:55 <tuomov> spoken finnish has been "corrupted" by analytical constructs from english and such
07:38:57 <tojoko> basti_, kannst Du mir ein Beispiel nennen? Ich check's net.
07:39:11 <shapr> tuomov: that's too bad.
07:39:20 <wli> The suffixes aren't that exciting, they're almost prepositions.
07:39:23 <basti_> "Lisa wirft den Ball" -"Den Ball wirft Lisa."
07:39:37 <basti_> that confuses english speakers to no end
07:40:31 <tojoko> Realy? Never spent a thought to that. Describes the same thing. But in the second sentence it's not important, what she throws, but Lisa does.
07:42:02 <basti_> might happen in more meaningful contexts though.
07:42:23 <basti_> as in, answers to question in conversation...
07:42:57 <basti_> "Ich habe -unverständlich- bestellt?" "Was hast du bestellt?" "Ein Taxi habe ich bestellt."
07:43:01 <wli> English has it too, in obscure/literary cases. Also, even passing knowledge of ancient languages (not even ability to read is required) will wipe most of that ignorance off the map.
07:43:02 <basti_> i didnt say it would be modern.
07:47:41 * shapr collects various date formats from the mailing list archives.
07:48:13 <goron> shapr: Are you still doing anything on Hackage?
07:49:23 <shapr> Lemmih is the author of Hackage.
07:49:29 <shapr> I haven't done anything to it lately.
07:49:57 <shapr> At the moment I'm hacking on curryspondence, trying to make it robust enough for real client use.
07:50:45 <goron> shapr: I thought it was on your server? 
07:51:09 <wli> The whole Latin/Greek/Hebrew/Sanskrit (no, Hebrew's not Indo-European, but it is associated with much the same kinds of scholarship) foursome.
07:51:22 <shapr> Yes, hackage is running on my server. I do what I can to encourage the use of Haskell :-)
07:52:04 <shapr> I thought you were referring to actual development of Hackage, in which case you should talk to Lemmih.
07:53:26 <goron> shapr: I was, but I figured Hackage only running instance that I know of is yours, so therefor the probability that you made it is high. ;) 
07:53:42 <shapr> Lemmih is writing up a bunch of nice code lately. The darcs repos for Hackage, Hacanon, haskellnehe, and Modhaskell are on my server - http://www.scannedinavian.org/cgi-bin/darcs.cgi
07:54:24 <shapr> goron: Flippi is also on my server, and written by Philippa rather than me - http://www.scannedinavian.org/cgi-bin/flippi/flippi
07:55:18 <shapr> I can't think of any other Haskell apps running on my server, but I may have forgotten some.
07:55:38 <shapr> well, maybe BLob
07:56:17 <shapr> My server will be changing physical location soon, so there may be some downtime.
07:58:09 <goron> shapr: Hacanon seems Haskell->C++ and C++->Haskell, right?
07:58:58 <shapr> yup
07:59:25 <sam__> haskellnehe?
08:00:04 <goron> shapr: Pretty useful when it does just that :)
08:01:05 <shapr> I haven't tried Hacanon yet, but I did recently find a cool C++ 3D lib that seems a good candidate.
08:01:22 <shapr> sam__: http://nehe.gamedev.net/lesson.asp?index=01
08:01:33 <wolfman8k> 3d?
08:01:52 <shapr> wolfman8k: http://xengine.sourceforge.net/
08:02:07 <wolfman8k> you are xengine author? :O
08:02:13 <shapr> no way, not me.
08:02:24 <shapr> I just found it and wanted to write a Haskell binding :-)
08:02:37 <wolfman8k> xengine is nice, but if you want a good 3d engine then ogre is the best
08:03:10 * shapr looks
08:04:22 <wolfman8k> but a 3d engine in pure haskell would totally rock sausages
08:04:44 <shapr> yeah it would.
08:04:57 <shapr> But I don't have the time or clue to write it, so I figured I'd bind to something else.
08:05:30 <tuomov> sigh.
08:05:34 <tuomov> wikipedia needs to be distributed
08:06:29 <wolfman8k> problem is that most 3d engines, even the really high level ones, still require to work with the low level api details if you want to do interesting work
08:10:00 <shapr> I think you could beat most of that problem with higher order functions.
08:10:36 <wolfman8k> yeah, with haskell you should be able to do some nice abstractions
08:10:51 <sam__> no doubt you could amke it elegant, but elegant and fast enough?
08:11:34 <goron> tuomov: Wikipedia is replicated. That's distributed too. :)
08:11:54 <shapr> sam__: sure, did you see Simon Marlow's OpenGL program that's as fast as the C version?
08:12:00 <wli> nice
08:12:03 <wli> URL?
08:12:12 <tuomov> goron: mirrors can't be edited
08:13:22 <goron> tuomov: That's true. But my point still holds (mirrors will update every x time). 
08:13:27 <shapr> It was on the ghc mailing list, I think. In essence, OpenGL performance is the limiting factor of a program, not whether it's Haskell or C.
08:13:42 <tuomov> it would be nice to have a fully functional wikipedia repository hosted in the local net
08:14:05 <tuomov> instead of waiting for minutes for it to load from the other side of the atlantic
08:14:31 <tuomov> at least mirrors should have an edit link to the main site
08:14:32 <wli> can't happen inside the US
08:14:51 <shapr> tuomov: darcs maybe could do it.
08:14:57 <shapr> We could always try it :-)
08:15:04 <wli> tuomov: can't happen inside the US
08:15:31 <wli> tuomov: media gag orders would shut it down
08:15:37 <tuomov> huh?
08:15:58 <wli> oddly, this in itself is covered in a wikipedia article...
08:16:20 <wli> one of the articles about 2004 presidential election irregularities
08:17:35 <shapr> I think I'll just load ghc-users into curryspondence and search it from there, it'll be a lot faster.
08:17:35 <sam__> shapr: what did it do?
08:18:57 <shapr> I think the OpenGL program was something like xscreensaver's quadrics?
08:19:05 <shapr> Maybe that's not the right name...
08:19:20 <shapr> Wasn't there a superquadrics xscreensaver?
08:19:25 <wli> quadrics are quadratic surfaces
08:19:34 <wli> e.g. x^2 + y^2 - z^2 = 1
08:20:03 <wli> it's also used to refer to higher-dimensional analogues though originally strictly for 3D
08:20:13 <wli> (clear from context most of the time)
08:21:18 <wli> (x-b)^t*A*(x-b) = c, where A is a symmetric matrix, b an n-vector like X, and c a real number > 0
08:27:09 <sam__> I don't know from xscreensavers
08:29:19 <shapr> gih, my date parsing still needs help.
08:30:55 <shapr> and I need to switch to using ilike instead of like.
08:34:15 <sond> shapr, do you know approx. when that message about OpenGL performance on the GHC mailing list was posted?
08:35:39 <shapr> No, I'm trying to find it at the moment. It's a nice way to see what I need to fix about curryspondence. - http://thunderbird.scannedinavian.com/cgi-bin/SearchML
08:35:50 <shapr> Answer is, lots of stuff.
08:37:48 <shapr> You can't depend on much of anything in the mailman mbox archives. They have duplicate message-id, date formats I've never seen, all sorts of nutty broken RFC2822 fields and formats.
08:39:54 <shapr> iirc, there are at least 11 message-ids that have at least one duplicate in one of the archives, and all told there's something like  15 messages that get dropped because of a duplicate ID already in the database.
08:46:12 <Lemmih> Argh! Makefiles makes me frustrated.
08:48:44 * shapr agrees
08:52:07 * dottedmag remembers the fight between myself and BSD's pmake.
08:55:15 <shapr> y0 Si\, how's code?
08:57:45 <sam__> choose closest mirror europe or america :\
08:59:07 <shapr> sam__: you could start your own down under mirror service.
09:10:01 <shapr> whoa, coolest date format yet - Mon, 16 Jun 03 15:03:45 ÃÃÂ¹ÃºÂ±ÃªÃÂ¼ÃÂ±Â¼Ã¤
09:10:05 <shapr> That must be KOI-8
09:12:13 <Lemmih> heh
09:12:22 <dottedmag> shapr: nope. can you send the original date in base64? i'll try to decode it
09:15:50 <shapr> oh, it's just a spam mail, it's probably invalid.
09:17:16 <dottedmag> shapr: I'm just interested
09:17:30 <dottedmag> no, I did not send this mail :)
09:17:51 <shapr> that's actually the whole field - Date: Fri, 30 May 03 15:02:23 ÃÃÂ¹ÃºÂ±ÃªÃÂ¼ÃÂ±Â¼Ã¤
09:18:15 <shapr> Also, those random chars are repeated twice in the same spam email, about a month apart
09:18:33 <shapr> so I'm guessing it's an error in the spam program, and that's actually part of the nearby memory.
09:32:29 <dottedmag> shapr: uuencode it. who knows how it was reencoded in irc?
09:32:59 <dottedmag> shapr: at least it looks like UTF-8, but it is not an UTF-8
09:40:26 <shapr> dottedmag: http://www.haskell.org/pipermail/haskell-cafe/2003-May/004431.html
09:40:28 <shapr> that's the actual message.
09:40:39 <shapr> You see that random stuff at the end of the date field?
09:42:20 <dottedmag> let me see...
09:42:42 <dottedmag> ah, yeah
09:43:18 <shapr> pflanze: are you related to TheHunter ?
09:43:22 <dottedmag> Yes, looks like completely random stuff.
09:44:05 <pflanze> shapr: no
09:44:13 <shapr> I really don't know how to make a date parser that drops random crap at the end of the field, maybe that's why it's there.
09:45:13 <dottedmag> shapr: may be it's the timezone name in some exotic encoding?
09:45:15 <shapr> pflanze: ok then, written any cool code lately? :-)
09:45:33 <pflanze> neither :) (except in perl)
09:46:21 <Lemmih> shapr: Hey shapr. Got 10mins to check out Hacanon?
09:46:23 <shapr> dottedmag: huh, I think you're right. Once you suggested that I tried GBK (Chinese Simplified)  and suddenly it shows up.
09:46:32 <shapr> Lemmih: maybe?
09:46:38 <Lemmih> I've added a very small test case.
09:47:32 <shapr> descriptive filenames :-)
09:47:43 * shapr runs make
09:48:05 <Lemmih> Oh, you will need gccxml from www.gccxml.org
09:49:01 <dottedmag> shapr: once I compiled kernel with LANG=ru_RU.KOI-R set up and then've seed pseudographics during boot: kernel displayed the compile time in KOI8-R before loading the corresponding console font ;)
09:49:04 <Lemmih> But just looking at Simple.hs will pretty much show how it works.
09:50:00 <shapr> sh: gccxml: command not found \n ghc-6.2.2: panic! (the `impossible' happened, GHC version 6.2.2): \n        Parse error: unexpected EOF
09:50:01 * shapr snickers
09:50:08 <Lemmih> shapr: Indeed.
09:50:38 <shapr> dottedmag: wow, that sounds screenshot-worthy.
09:51:35 <dottedmag> shapr: it was 2-3 years ago, when I was little, stupid and unaware about LC_* ;)
09:51:47 <shapr> Lemmih: that's nifty.
09:52:17 <shapr> Lemmih: so, crazy question... can I use this to do inline C in an .hs file?
09:52:21 <bourbaki> moin
09:52:28 <Lemmih> shapr: Nope.
09:52:48 <Lemmih> shapr: Well adding support for it would be easy but I don't see why.
09:53:07 <shapr> Just so everything can be in one file. I find that easier to deal with.
09:53:37 <Lemmih> Normally the header files would be in /usr/include
09:53:48 <dottedmag> shapr: I've got the 'Unable to create immutable header region.' error from the rpmbuild. And this error is surrounded with the 'if' and commented as '/* XXX can't happen */'
09:54:17 <shapr> Also, it seems that the ability to write inline C in a language is a plus for some people.
09:55:03 * shapr deletes 15,000 emails from his database and tries again with the new date parsing code.
09:55:20 <Lemmih> They can combine Hacanon and GreenCard to get that behaviour (-:
09:55:27 <shapr> I need to handle MIME and encodings soon.
09:55:36 <shapr> oh, that sounds cool.
09:57:19 <bourbaki> heh i might build some haskell bindings for the engine of the company im working at :D
09:57:41 <shapr> yay! my date parsing is working!!
09:57:51 * shapr hops frantastically
09:58:10 <bourbaki> date parsing?
09:58:26 <bourbaki> i wish i had a date ;)
09:58:45 <shapr> Date parsing in curryspondence - http://thunderbird.scannedinavian.com/cgi-bin/SearchML
09:58:56 <shapr> bourbaki: well, get off IRC and go find a cute chick ;-)
09:59:11 <dottedmag> bourbaki: yeah, 'date parsing' going to have the second meaning :-)
09:59:30 <shapr> I have a bunch of encoding errors. I wonder what that means.
09:59:31 <bourbaki> hehe
09:59:38 <bourbaki> i am known as mr second meaning
10:05:04 <shapr> Yay, curryspondence is much improved.
10:07:04 <shapr> msnbot suxx
10:10:57 <Lemmih> Yay. Money to shapr.
10:14:36 <goron> shapr: Aren't there other tools that do what Curryspondence does?
10:17:48 <wli> what's curryspondence?
10:23:25 <goron> wli: Mailman archive searchengine (and possibly more). 
10:28:59 <shapr> goron: not really, there's mail-archive.org and a few other websites that can search and display mailing lists, but I don't know of any open source programs that you can download to do it.
10:29:17 <Lemmih> Time to unicycle!
10:29:25 <shapr> Time for reindeer dinner!
10:29:40 <shapr> goron: do you know of other tools that already do that?
10:30:03 <shapr> goron: anyway, curryspondence was a three or four evening hack to try out WASH and HaskellDB, so it was worth the time I put into it.
10:30:42 <shapr> I've since decided that WASH is too much trouble, but HaskellDB I want to use for everything.
10:30:54 * shapr goes off to dinner.
10:31:30 <Lemmih> HaskellDB have some annoying limitations.
10:32:37 <goron> Lemmih: Then go patch it! 
10:33:35 <Lemmih> goron: I'm not sure there's a good way to solve it.
10:34:09 <musasabi> hmm?
10:34:50 <goron> Lemmih: Name a few. Documentation is one (at least some time ago). 
10:35:06 <Lemmih> goron: Every DB handles SQL differently.
10:35:59 <goron> Lemmih: Well, that's just a matter of writing multiple instances of some type class (I hope it's implemented that way). 
10:36:25 <goron> Lemmih: And that's more a problem of reality and not og HaskellDB.
10:36:31 <Lemmih> goron: No. HaskellDB only implements standard SQL.
10:36:43 <goron> Lemmih: That's SQL92?
10:37:20 <Lemmih> goron: Idonno, check the webpage.
10:37:21 <musasabi> You can work around that if your db supports things like views.
10:37:41 <musasabi> (the main problem being mysql which is broken in a multitude of ways)
10:38:10 <goron> musasabi: SO basically it's *unmaintained*.
10:38:39 <Lemmih> Anyhow, I'm off unicycling.
10:39:48 <musasabi> I would personally think that the largest problem is the lack of a proper record abstraction in Haskell.
10:40:20 <Lemmih> How so?
10:40:36 <musasabi> Of course there is oohaskell, haskelldb and trex - none of which is standard.
10:40:55 <goron> I can think of a million ways of how to implement it. 
10:41:02 <musasabi> Lemmih: e.g. having to define virtual fields for transformations.
10:41:41 <goron> musasabi: A join is a transformation in your vocabulary?
10:43:35 <Lemmih> I don't see why it's a problem that haskelldb isn't following the Haskell98 standard.
10:45:12 <musasabi> goron: projecting things e.g. with count.
10:45:31 <musasabi> Lemmih: having a common record abstraction would make things easier.
10:46:56 <Lemmih> musasabi: Yes, but it's not really a problem. HLists are fine except for the error messages.
10:48:24 <musasabi> except trying to mix HList and haskelldb records would most probably cause headache ;
10:49:32 <Lemmih> musasabi: eh... HaskellDB uses a slightly modified version of HLists.
10:52:39 <Lemmih> They are essentially the same except that HaskellDB also keeps a type corresponding to a DB column.
10:53:28 <goron> Where's the most recent version of HaskellDB? haskelldb.sf.net seems dead. 
10:53:38 <Lemmih> Dead?
10:53:56 <goron> Inactive
10:54:08 <goron> Or not?
10:54:48 <goron> The demo isn't working for months. 
10:55:22 <Lemmih> Just ignore the demo (-:
10:56:51 <Lemmih> I haven't ever seen that demo work. But Curryspondence and Hackage are both working.
10:57:40 <goron> Lemmih: I thought they used another version of HaskellDB. Well, you wrote Hackage, so you would know best :D
10:58:33 <Lemmih> Hackage should work with any recent version of HaskellDB.
10:59:17 <goron> I meant by dead that nobody maintains the code anymore. 
11:01:49 <Lemmih> I think bringert is actively maintaining it.
11:04:36 <goron> Who's bringert IRL?
11:05:08 <goron> Bjorn Bringert
11:05:09 <Lemmih> Bjorn Bringert from Chalmers (a university in sweden).
11:05:12 <goron> Thanks, SF
11:05:22 <goron> Thanks, Lemmih :)
11:06:04 <goron> Bjorn also infiltrates with our greatest enemies....
11:06:21 <Lemmih> Oh?
11:06:32 <goron> jmms
11:06:38 <Lemmih> jmms?
11:06:48 <goron> Java Multimedia System. 
11:30:07 <Philippa> 'lo
11:34:40 <Muad_Dibber> lo
11:36:29 * Philippa breathes a sigh of relief - no more spam on Flippi to clear up for now
11:48:40 <zamez> hi
11:49:53 <zamez> http://cvs.strcprstskrzkrk.co.uk/factorcss/ <-- I'd be interested in comments and improvements to my Haskell, thanks!
11:52:36 <ibid> well, it is good practice to actually include the license with the source :)
11:52:51 <ibid> and in the case of the mit license, include it verbatim at the start of every source file :)
11:53:34 <zamez> pfft, it's such a small amount of code, seems pointless
11:53:56 <ibid> it's not a matter of the amount of the code
11:53:58 <zamez> :>
11:54:23 <ibid> if you consider it worth publishing, you can make the effort of properly licensing it :)
11:55:32 <ibid> any particular reason you have the is_* functions in CSS?
11:55:55 <ibid> ahh, filter
11:55:58 <zamez> no, is there a better way?
11:55:59 <ibid> makes sense :)
11:56:02 <Philippa> zamez: take the licensing bit seriously, 'cos otherwise anybody decent has to assume they can't use the code
11:56:17 <ibid> Philippa: he does link to the license, the intent is clear
11:56:23 <zamez> ok
11:56:53 <Philippa> ibid: fair enough
11:56:56 <ibid> Philippa: i'm just worrying about the eventuality that the link disappears or becomes otherwise inaccessible :)
11:57:19 <arauko> Hello.
11:57:33 <Philippa> ibid: or worse yet, modified
11:58:33 <ibid> zamez: with filter is_* are completely appropriate, i was just worried that you might be using them in stead of pattern matching. you don't appear to, though
11:58:37 <ibid> Philippa: agreed'
11:59:15 <ibid> zamez: why eq_decl instead of instance Eq?
12:00:05 <ibid> zamez: nothing else jumps out of the screen for me
12:06:43 <zamez> thanks, I'll look at instance Eq
12:33:22 <Lemmih> HomelessClown ...
12:33:47 <HomelessClown> ?
13:19:26 <shapr> yow!
13:20:37 <shapr> I had an ALIBI!
13:20:37 <Lemmih> yav.
13:20:46 <Lemmih> And what's that?
13:20:55 <shapr> What's my alibi?
13:21:44 <Lemmih> Oh wait. I thought you were talking about some library.
13:27:35 <bourbaki> can i link a dll in haskell?
13:28:08 <Gahhh> wasnt there a thread on that in haskell-cafe recently ?
13:29:10 <bourbaki> oh i dont know what did they say?
13:29:56 <Gahhh> Well, somebody was complaining that haskell produced extra large executables since everything was cross-compiled in, ergo no shared libraries.
13:44:34 <Nioate> borism: you want to use a dll or link a dll written in haskell?
13:44:55 <borism_> i don't want dll, thank you
13:45:01 <Lemmih> hah
13:58:48 <bourbaki> i did :)
13:59:05 <bourbaki> i want to link the dll written in c++ at runtime
13:59:49 <CosmicRay> MegaMonad: good evening
13:59:54 <MegaMonad> CosmicRay: Especially given the temperature last week of evening reading and mark area's i don't have to type.
14:00:10 <CosmicRay> MegaMonad: it was cold, but now it's warmer.
14:00:15 <MegaMonad> CosmicRay: Lemme try it some thoughts ... Right now it's warmer.
14:00:26 <Lemmih> MegaMonad: So what do you think of C++?
14:00:32 <MegaMonad> Lemmih: Let me think that c is the i, and a chain of functions f,g in haskell unless you search by the press is a vessel that conveys blood from the arrows from one st thread leaking into another.
14:00:59 <musasabi> What is the goal of the C-- backend?
14:01:34 <Lemmih> Portability, I think.
14:02:01 <bourbaki> i could write a c interface to dlls
14:02:09 <bourbaki> and then link this in haskell
14:02:24 <CosmicRay> what is the "c-- backend"?
14:02:27 <musasabi> Lemmih: it would be good if a C-- frontend to gcc existed ;)
14:03:11 <Lemmih> CosmicRay: www.cminusminus.org
14:05:10 <CosmicRay> that is interesting
14:05:52 <Philippa> CosmicRay: you get a look over the stuff I sent you yet?
14:07:12 <CosmicRay> Philippa: not yet (vacation)
14:08:22 <Philippa> fair enough
14:09:45 <jadrian> hmm no unfoldM :-/
14:10:06 * jadrian will brb
14:13:29 <basti_> hi
14:13:33 <Lemmih> Yo
14:18:25 * basti_ put a chili on his deep frozen pizza
14:46:48 * boegel waves at everyone
14:47:25 <CosmicRay> hi boegel
14:48:25 <CosmicRay> I think it's just the two of us and MegaMonad right now
14:48:34 <heatsink> oh.
14:48:37 * basti_ stirs
14:48:45 <CosmicRay> or not
14:50:31 <musasabi> hello boegel
14:50:50 <boegel> CosmicRay, you're very wrong apparently ;)
14:51:21 <CosmicRay> I guess!
14:52:01 <wolfman8k> *burp*
14:56:51 <boegel> heya wolfman8k, any cool progress on your raytracer (or anything else cg)?
14:57:24 <wolfman8k> i've been experimenting with a bunch of shaders
14:57:28 <wolfman8k> here's a gradient shader: http://img133.exs.cx/img133/5049/haskellraytrace106ce.png
14:57:32 <wolfman8k> here's something weird: http://img63.exs.cx/img63/562/haskellraytrace117rb.png
14:57:36 <wolfman8k> here's random stripes: http://img137.exs.cx/img137/2624/haskellraytrace120xd.png
14:57:40 <wolfman8k> here's another weird one: http://img147.exs.cx/img147/5681/haskellraytrace134tc.png
14:57:46 <wolfman8k> here's 3d noise: http://img133.exs.cx/img133/1562/haskellraytrace140mp.png
14:57:52 <wolfman8k> and here is an example of shader composition: http://img157.exs.cx/img157/8803/haskellraytrace162ub.png
14:59:37 <boegel> wolfman8k, seen those already :p
14:59:42 <wolfman8k> oh
14:59:51 <desrt> pfft
14:59:53 <desrt> doom3 looks better
14:59:58 <boegel> wolfman8k, do you do 3D-stuff too ? like Maya, 3DS max and so on ?
15:00:22 <wolfman8k> a bit
15:00:34 <boegel> desrt: check this out -> http://www.cgnetworks.com/gallerycrits/594/594_1103529359.jpg
15:00:43 <boegel> wolfman8k, what do you work with ?
15:01:01 <desrt> boegel; if that was rendered with a haskell program i'm impressed
15:01:18 <wolfman8k> i used to do lots of lightwave and then 3dsmax, but since a few years ago i've seen the light that is free software and so i've only done a bit of blender lately
15:01:36 <boegel> desrt, it's not :p
15:01:48 <desrt> boegel; THEN IT SUCKS!
15:01:48 <desrt> :)
15:01:52 <wolfman8k> it's a lisp program! :P
15:01:53 <boegel> wolfman8k, I find blender quite hard
15:02:05 <desrt> mm
15:02:06 <wolfman8k> blender's actually pretty sweet, i've done a bit of python programming in it
15:02:07 <boegel> compared to 3dsmax that is
15:02:14 <bourbaki> hey boegel
15:02:14 <desrt> i have that strange nervousness that only comes with making a gigantic purchase
15:02:18 <bourbaki> i need your raytracer
15:02:27 * desrt just bought 2001FP
15:02:36 <bourbaki> and it needs to be so quick that i can render my game boegel:)
15:02:54 <bourbaki> desrt: is it like odysee 2001?
15:03:28 <desrt> no
15:03:32 <desrt> it's like a 20" LCD
15:03:33 <wolfman8k> bourbaki: weren't you going to use opengl for your game?
15:03:54 <bourbaki> wolfman8k: yes id like to but i dislike the interface to HOpenGL and what a propper wrapper
15:04:14 <desrt> http://accessories.dell.com/sna/ProductDetail.aspx?sku=320-1578&c=ca&l=en&cs=CADHS1&category_id=5194&first=true&page=productlisting.aspx
15:04:16 <bourbaki> but im thinking about to build some interface to a directx engine of a friend
15:04:22 <wolfman8k> isn't HOpenGL a direct interface to the c opengl api?
15:04:25 <bourbaki> its just that i cant load dlls
15:04:29 <bourbaki> yep
15:04:52 <desrt> now all i need is a videocard that can play doom at 1600x1200
15:04:54 <wolfman8k> so build a nice abstraction layer on top of hopengl in haskell :)
15:05:12 <boegel> bourbaki, you need MY raytracer to render stuff ?
15:05:25 <bourbaki> nah i think im gonna use the directx engine then i get a lot of cool things like shaders and such
15:05:30 <bourbaki> and top speed renderin
15:05:43 <boegel> bourbaki, okay, 'cause mine isn't top speed
15:05:44 <bourbaki> boegel: yes and it needs to be really fast :)
15:05:50 <boegel> but i have some cool shaders :p
15:06:18 <bourbaki> all i need is call updata simulation and render thing now
15:06:22 <boegel> perlin noise, thanks to someone here who advised me to check it out (I can't seem to remember who :p)
15:06:39 <bourbaki> has someone a simple example for linking a c object file?
15:06:52 <bourbaki> hehe
15:07:17 <bourbaki> id just like to use my topology thingy to triangulize my surfaces ...
15:07:31 * Philippa wants a good SDL binding for Haskell right now (for values of good including a clear, free-BSD-style rather than free-GPL-style license)
15:07:52 <wolfman8k> Philippa: i'm using Multimedia.SDL.Core
15:07:56 <bourbaki> Philippa: why not a good 3d engine?:)
15:07:58 <wolfman8k> Philippa: seems to work well and is complete
15:08:15 <Philippa> bourbaki: because I'm not after 3d atm
15:08:26 <Philippa> I did all that mess ages back, I'm still a regular in #flipcode for example
15:08:33 <Philippa> wolfman8k: GPLed last I checked
15:08:56 * boegel decides to go to bed
15:09:01 <boegel> g'night everyone
15:09:10 <wolfman8k> later
15:09:36 * Philippa has an intense hatred of game libraries and engines that're only available under the GPL
15:10:33 <bourbaki> Philippa: but it would be cool to have that in haskell for a function plotter or such
15:10:46 <Philippa> it just doesn't work in a content-heavy field, which games have been for a long, long time
15:11:03 <Philippa> bourbaki: the 3d, or just an SDL binding, any SDL binding?
15:11:49 <sond> where can i get Multimedia.SDL.Core? :)
15:11:50 <wolfman8k> Philippa: i actually can't find any information about the license of Multimedia.SDL.Core
15:12:00 <Philippa> wolfman8k: that's even worse (but check the source files)
15:12:03 <wolfman8k> Philippa: if you email the author he may tell you that it is LGPL or something :)
15:12:18 <Philippa> I say check the source files because they all say GPL
15:12:51 <Heffalump> no worse than them not existing at all :-)
15:13:03 <wolfman8k> Philippa: yep, the source files say GPL
15:13:25 <Philippa> Heffalump: except it discourages people from creating further bindings because "there're bindings already"
15:13:26 <wolfman8k> Philippa: but maybe the author would be willing to switch to LGPL if you request :)
15:13:35 <Philippa> I did a while back, I never received a response
15:13:49 <Heffalump> I guess so.
15:14:01 <wolfman8k> well, if he is dead then there is no longer any copyright :P
15:14:07 <Philippa> wolfman8k: wrong
15:14:21 <Philippa> besides, AFAIK Adrian Hey's still alive and kicking
15:20:15 <zamez> is there a 'read' equivalent that works on ".5" (as opposed to "0.5")?
15:24:24 <Darius> read . ('0':) or Parsec's float parsers may work as well.
15:24:48 <bourbaki> does someone of you happen to know how to compile an object file with VC .NET?
15:25:25 <Darius> Numeric.readFloat is probably the implementation of the read instance, but you can try it as well.
15:27:40 <arauko> data List a = Nil
15:27:41 <arauko>             | Cons a (List a)
15:27:57 <arauko> how do i use that data type?
15:29:23 <wagle> Cons 1 Nil
15:29:46 <wagle> Nil :: List Integer
15:30:05 <wagle> Cons 1 (Cons 2 Nil)
15:30:10 <wagle> x = Cons 1 x
15:30:16 <wagle> ...
15:30:43 <wagle> notice that it has to know what the type a is
15:31:05 <wagle> also you might add a "deriving Show" at the end of the declaration
15:32:52 <wli> deriving (Eq, Ord, Read, Show, Bounded, Enum)
15:33:07 <wli> derive everything you can unless there's a reason to hand-code one
15:34:34 <arauko> wagle, im still trying to understand datatypes, it means that all those expressions build List datatypes?
15:35:25 <wagle> arauko: yes..  some can be typed into your haskell interpreter directly (try it!)
15:35:40 <heatsink> yes, the data declaration makes the functions Nil and Cons
15:35:58 <wagle> arauko: the x = ... has to be put into a file, then loaded
15:36:12 <wagle> let x = ... in x 
15:36:13 <heatsink> or you can say let x = ... in x
15:36:24 <wagle> would have the same effect without the file
15:36:35 <wagle> heatsink: beat ya!  8-p
15:36:59 <heatsink> argh! I'll get you yet, wagle!
15:37:09 <arauko> Ah, thanks wagle
15:39:40 <arauko> The Cons and Nil expression are the data constructor 
15:39:48 <zamez> thanks Darius
15:44:23 <ibid> CosmicRay: ayh?
15:53:59 <shapr> @yow !
15:54:00 <lambdabot> I'm thinking about DIGITAL READ-OUT systems and
15:54:00 <lambdabot>  computer-generated IMAGE FORMATIONS..
15:54:45 <shapr> I have a lawyer but I want my ALIBI!
15:57:33 <Darius> hey shapr
15:57:50 <shapr> greetings Darius, how's code?
15:58:14 <Darius> Haven't been coding the last couple days.
15:58:21 <shapr> learning?
15:58:27 <shapr> eating food and being social? =)
15:58:32 <Darius> both.
15:58:49 <Darius> How was your "being social"?
15:59:26 <shapr> Nice, I called my relatives on your continent, and a friend from Belgium is visiting us now.
15:59:37 <shapr> What about you?
16:00:26 <Darius> Better than I was expecting.  I held my nephew for the first time and continued a bit of a family tradition.
16:00:33 <shapr> nifty :-)
16:03:02 <shapr> family and traditions is a pleasant thing.
16:05:35 <shapr> yay, curryspondence does ILIKE now instead of case-sensitive LIKE
16:06:53 <shapr> now to figure out the UNICODE problems
16:06:59 * Darius looks for a binary format for DSSSL.
16:21:10 <wli> proll?
16:22:38 <bourbaki> how do i pass a list from a ffi?
16:23:03 <musasabi> you pass an array.
16:23:16 <bourbaki> ok
16:23:25 <bourbaki> and how do i handle objects?
16:23:34 <bourbaki> a struct for example?
16:24:09 <musasabi> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.Array.html
16:24:27 <bourbaki> thx
16:24:31 <musasabi> bourbaki: just use a Ptr. (or ForeignPtr if you want finalizers)
16:25:26 <bourbaki> hm
16:25:42 <bourbaki> so the function on the haskell side looks like this
16:25:51 <bourbaki> foobar -> Ptr?
16:26:04 <bourbaki> and on the c side its a void*?
16:27:01 <musasabi> if you give the C prototype I can give the haskell one..
16:27:43 <musasabi> void* foobar(void*a); => foobar :: Ptr a -> IO (Ptr b)
16:28:31 <bourbaki> ok void* getstruct( int foobar) { mystruct* ret = (mystruct*)malloc(sizeof(mystruct)); return (void*)ret;}
16:29:08 <bourbaki> dos it have to be IO?
16:29:45 <Igloo> Is it necessary to cast it to void * for other reasons?
16:30:21 <bourbaki> well i dont think that mystruct isnt readable on the haskell side is it?
16:30:41 <Igloo> No, but that's no reason to cast it on the C side
16:30:45 <Darius> bourbaki: The FFI addendum is readily available (http://www.cse.unsw.edu.au/~chak/haskell/ffi/) and quite readable.
16:31:05 <Igloo> You can also use a dummy type on the Haskell side Ptr MyStruct to get some extra type checking
16:31:17 <musasabi> or even use newtypes.
16:32:24 <musasabi> (that is one part of the FFI I really like)
16:32:40 <bourbaki> how do i use the newtypes there?
16:33:29 <musasabi> newtype Foo = Foo (Ptr SomeDummyTypeWhichCouldBeInt)
16:34:15 <bourbaki> ok so this would map right towards the c struct then?
16:34:17 <Darius> musabi: The archetypical dummy type is ().
16:35:00 <bourbaki> but does it have to be IO Ptr b?
16:35:40 <Darius> bourbaki: No, but in most cases it should be.
16:36:09 <Darius> bourbaki: And this is one of those cases.
16:36:25 <bourbaki> and why is that?
16:36:42 <bourbaki> i wanted to do all the object management on the c side
16:36:56 <bourbaki> build a create and release function there and then plug in the pointers
16:38:21 <Darius> bourbaki: The function is not pure.
16:39:10 <bourbaki> ok but to be honest i dont really care ;)
16:39:30 <bourbaki> i mean what do i gain with IO there?
16:39:35 <bourbaki> gain that is
16:40:06 <ibid> bourbaki: you gain that your program works
16:40:21 <ibid> (or in other words: is not broken)
16:40:30 <Darius> bourbaki: Well, if the structure returned by the function is never mutated then it might be okay, if it is then you do care if you want to be certain your program, as ibid put it, works.
16:41:25 <bourbaki> hm mutated in what way?
16:41:45 <bourbaki> i mean what can i mutate that pointer to?
16:41:56 <Darius> bourbaki: The structure, not the pointer.
16:42:28 <bourbaki> hm can you explain to me why this is the case?
16:42:52 <bourbaki> i mean i would use function in the c interface to manipulate the pointers structure
16:43:34 <ibid> bourbaki: without IO, you have no easy way to determine in which order your actions would happen, and sometimes they may even left not done
16:43:59 <ibid> bourbaki: IO is the way to ensure that actions happen in the order you mean them to happen and as many times as you mean them to happen
16:44:12 <Darius> bourbaki: Everytime the function is called it creates a new structure.  If the function is pure the compiler is allowed to share or unshare occurences of the function at its discretion which equates to multiple structures or unwanted sharing of structures.
16:44:23 <dons> you may also have problems if the function gets inlined, leading to duplicate calls
16:44:30 <dons> ah, yes. as Darius said
16:44:57 <bourbaki> and why is that?
16:45:05 <ibid> bourbaki: because haskell is lazy
16:45:08 <bourbaki> i mean why does haskell behave to that in this way?
16:45:10 <bourbaki> ah ok
16:45:26 <ibid> bourbaki: and because the language is defined in such a way that leaving out IO means that the compiler may assume that there are no side-effects
16:45:32 <bourbaki> but i dont see why IO lets me get around this that way
16:45:44 <ibid> bourbaki: hence allowing the compiler to make more aggressive optimizations
16:46:20 <ibid> bourbaki: short answer: because IO is defined to do that
16:46:30 <ibid> bourbaki: longer answer involves the word "monad" :)
16:46:36 <bourbaki> so i always want to go to IO from foreign functions?
16:46:44 <ibid> bourbaki: that's the safe call
16:46:49 <bourbaki> ok i know what a monad is
16:47:00 <ibid> bourbaki: but there are situations where foreign functions can be non-IO
16:47:01 <dons> an IO a is actually IO (State# RealWorld -> (# State# RealWorld, a #))
16:47:17 <dons> so the threading of this state is how the sequencing is done
16:47:39 <bourbaki> ok so the state is my "sideeffect" ?
16:47:42 <dons> a bit like: let a = 1 in let b = 2 in let c ... which orders a ; b; c
16:47:49 <ibid> bourbaki: side-effect is the change of the state
16:48:06 <bourbaki> ok but when i render for example how is that mapped in IO?
16:48:10 <ibid> dons: it doesn't, really :)
16:48:22 <ibid> bourbaki: i don't understand the question
16:48:47 <bourbaki> i mean when i render thats a side effect
16:49:03 <bourbaki> and IO wraps that sideeffect somehow into the monad right?
16:49:05 <ibid> bourbaki: you know how regular IO works in haskell?
16:49:13 <bourbaki> no
16:49:14 <bourbaki> :)
16:49:22 <dons> ibid: well, I don't see that it hurts to think of it like that. unless you explain monads ;)
16:49:30 <ibid> bourbaki: IO is essentially just a way to force actions to not be reordered at will :)
16:49:45 <ibid> dons: but your example doesn't order them as you specified ;)
16:50:01 <dons> oh, dependency analysis, sure :)
16:50:02 <bourbaki> ok but i can do the order thing with a function as well cant i?
16:50:22 <bourbaki> i mean let cfun be my foreign function
16:50:28 <bourbaki> then i could do something like that
16:50:34 <ibid> dons: i mean, a, b, and c get bound to thunks, the lets have no effect on when they are forced
16:51:00 <bourbaki> h = cfun somevalue
16:51:14 <ibid> bourbaki: you're thinking eagerly, which is your mistake
16:51:21 <bourbaki> then h would just execute that function and if i use that h somewhere then it was in that order right?
16:51:30 <ibid> bourbaki: no
16:51:30 <dons> ibid: oh, that's what you mean. hence my ... ;)
16:51:52 <bourbaki> and why isnt there this ordering usually?
16:51:59 <ibid> bourbaki: because of laziness
16:52:08 <bourbaki> ah that was just what i wanted to ask
16:52:21 <bourbaki> and why does the lazyness makes me get rid of the order?
16:52:53 <bourbaki> sorry if these question seem a bit dumb but i havent thought about that alot yet
16:52:56 <dons> anyway >>= in IO is bound to bindIO which is roughly: case m x of (# new_s, a #) -> unIO (k a) new_s , so rewriting the former let-nest with cases might have been clearer :)
16:54:33 <ibid> bourbaki: when you write h = ..., it doesn't mean that the ... is computed and the value is bound to h, it just gives a name for the ...; now when the ... is computed depends on whether and when h is used and whether the thing that h is used in ever gets computed
16:54:40 <bourbaki> and why doesnt to the lazyness that nasty thing in IO?
16:54:43 <ibid> bourbaki: it's kinda messy, really
16:54:49 <ibid> bourbaki: because IO is defined so :)
16:55:09 <bourbaki> hm
16:55:33 <Lemmih> I found the Maybe monad very simple to understand.
16:55:36 <ibid> bourbaki: i could explain laziness to you in terms of thunks and forcing, which would give you a fairly good mental model, but irc is not a good medum for that
16:55:41 <bourbaki> but when i call some function it gets processed in the order i want it to right?
16:55:46 <ibid> bourbaki: no
16:56:04 <ibid> bourbaki: unless the function is a IO function
16:56:27 <bourbaki> where can i read in a single article why this is the case?
16:56:54 <ibid> bourbaki: you could just assume that haskell allows the compiler to reorder evaluation in funny ways as long as IO is not involved. that's not entirely accurate but it's a start
16:57:41 <bourbaki> ok i see the point and i kind of understand that just want to know why this exacly is the case
16:58:03 <bourbaki> cause to be honest i somehow hate to do all things in IO
16:58:21 <ibid> bourbaki: you don't have to do *all* things in IO, just those that need IO :)
16:58:41 <bourbaki> :)
16:58:59 <ibid> bourbaki: and sorry, i don't have any good reference on laziness handy
16:59:05 <ibid> maybe i'll write one someday
16:59:09 <ibid> but not today :)
16:59:11 <bourbaki> cool :)
17:08:50 <Lemmih> bourbaki: Do you understand why 'Nothing >>= error "Throw exception"' evaluates to Nothing without throwing the exception?
17:11:51 <bourbaki> no
17:13:50 <Lemmih> Just a >>= f = f a
17:14:00 <Lemmih> Nothing >>= f = Nothing
17:14:42 <bourbaki> and why is this so special?
17:15:16 <Lemmih> It's not special.
17:15:39 <Lemmih> But it's very convenient.
17:16:02 <ibid> i think Lemmih's *point* was that it's nothing special :)
17:16:15 <ibid> it's the same general principle at work there
17:16:31 <ibid> or simply:
17:16:36 <ibid> f x = 3
17:16:39 <bourbaki> so i use IO to get rid of errors?
17:16:45 <ibid> f (error "Foo")
17:16:52 <ibid> ==> 3, not error :)
17:16:54 <ibid> bourbaki: no
17:17:17 <Lemmih> For example, if you want to check a users account but you have to make sure the user exists then you can write this: do {user <- findUser database; userAccount user} :: Maybe Account
17:17:44 <ibid> Lemmih: aren't you going a little fast? :)
17:17:48 <Lemmih> Now you're 100% sure that userAccount will not be evaluated if you didn't find the user in the DB.
17:18:21 <ibid> MegaMonad: what is laziness?
17:18:27 <MegaMonad> ibid: But when i take the laziness in haskell really best suited?
17:18:38 <jadrian> I think bourbaki probably wants to use the Maybe instance of Monad Error 
17:18:52 <bourbaki> hm
17:18:54 <ibid> i don't
17:18:57 <jadrian> s/Monad Error"/Error Monad
17:19:05 <Lemmih> jadrian: Why?
17:19:12 <ibid> i think you two are just confusing bourbaki further :)
17:19:25 <jadrian> because he is trying to use Nothing to represent failure
17:19:30 <jadrian> and he wants to catch Nothings
17:19:31 <Lemmih> jadrian: The point is that it's simple.
17:19:44 <ibid> jadrian: bourbaki isn't doing that
17:19:49 <Lemmih> jadrian: It was an example.
17:20:03 <jadrian> oh then I misunderstood...
17:20:22 <ibid> jadrian: we were talking about why most foreign functions need to be IO
17:20:36 <ibid> jadrian: and then went to talk about laziness in general
17:21:26 <jadrian> right...
17:22:43 <jadrian> off-topic english question: why is it "a unifier" and not "an unifier"
17:23:09 <ibid> because the sound is a consonant
17:23:10 <wli> I could use help figuring out how to FFI up sys_epoll() in Linux
17:23:13 <ibid> the you-sound
17:23:30 <ibid> the first sound of unifier, that is
17:23:35 <jadrian> oh I didn't know that...
17:23:57 <ibid> jadrian: didn't know? how do you pronounce "unifier"?
17:24:18 <jadrian> ibid: you-nifier, that I know
17:24:35 <ibid> :)
17:24:47 <ibid> so what was it that you didn't know? just curious...
17:25:00 <jadrian> ibid: but I thought it would be "an" if the 1st *letter* was a vowel
17:25:10 <ibid> yeah, no, it's the first sound
17:25:20 <ibid> a common mistake i think
17:26:11 <ibid> jadrian: try pronouncing an unifier, it even feels weird :)
17:26:14 <jadrian> ibid: I didn't even know sounds had that classification too (at least in portuguese I've never heard of it). And I wouldn't expect an "you" sound to be a consonant... :-/
17:26:34 <jadrian> that explains why I always messed up the "a/an" so bad 
17:26:44 <ibid> jadrian: well, you is actually two sounds, i mean the first, obviously
17:27:02 <ibid> in finnish, it's the j sound
17:27:36 <jadrian> ibid: yes, but I usually associat consonat with letters that "have no sound" on their own and need to be associated with vowels
17:27:48 <jadrian> ibid: like n, m, t...
17:28:21 <ibid> jadrian: i believe it's primarily a sound classification, and the letters just inherit it :)
17:28:34 <ibid> jadrian: n has a sound without vowels :)
17:28:48 <jadrian> ibid: by the way is y vowel or consonant?
17:28:51 <ibid> jadrian: put your mouth in the n position and just continue blowing :)
17:28:59 <ibid> jadrian: in which language?
17:29:07 <jadrian> ibid: english
17:29:28 <ibid> jadrian: i don't know, for me it depends on the context :)
17:29:35 <jadrian> ok :)
17:29:45 <ibid> jadrian: well, the letter is pronounced "why" so i suppose it's a constant ;)
17:29:57 <ibid> jadrian: but i have no idea really
17:30:14 <wagle> _a_ unifier </native-speaker>
17:30:32 <ibid> jadrian: i believe the vowel/consonant difference is in whether the air is obstructed or unobstructed
17:30:42 <wagle> .. which isnt consistant with the rule i was taught in grade school
17:30:54 <ibid> wagle: that's was never in doubt; the question is *why* it's that way
17:31:18 <wagle> yeah.. thinking about that 
17:31:27 <ibid> jadrian: like in n, the tongue is "in the way"
17:31:52 <jadrian> wagle: by the way how is the rule you learned?
17:32:01 <ibid> wagle: for me, the simple rule is "is the first *sound* a vowel or a consonant", hasn't let me down yet
17:32:14 <ibid> not what i was thought either :)
17:32:17 <jadrian> ibid: yes, but it doesn't seem to be the case in the "you" sound
17:32:20 <wagle> n before vowels.  w and y might be vowels, or something like that
17:32:26 <ibid> jadrian: how so?
17:32:34 <jadrian> wagle: that's what I thought too...
17:33:09 <ibid> i just think "which finnish letter would fit the first sound, is that a vowel or consonant"
17:33:15 <ibid> fits the you case completely
17:33:16 <wagle> wow.. second grade or so..  o_O
17:33:21 <jadrian> ibid: nothing seems to be "in the way" when performing the "you" sound, I think
17:33:41 <ibid> jadrian: you is two sounds
17:33:58 <ibid> jadrian: you start with a consonant and then you move the tongue to a vowel position
17:34:09 <jadrian> hmmmm
17:34:29 <Darius> I think the rule might actually be the first letter, but as ibid pointed out it feels wrong when spoken, so whether or not that is the rule, in practice it goes by the sound.
17:34:31 <jadrian> probably I just don't know how to pronounce it correctly...
17:34:32 <ibid> with finnish letters, i'd write you as juu or jyy (actually, it's somewhere between u and y)
17:35:12 <Darius> A more extreme example is I say, "a 'U'" not 'an U', (again the 'y' sound at the beginning).
17:35:18 <CosmicRay> ibid: you were looking for me?
17:35:22 <ibid> CosmicRay: yeah
17:35:27 <ibid> CosmicRay: one second...
17:36:02 <ibid> i need to fix my other errors before i get again the error i wanted to bug you about...
17:36:34 <CosmicRay> heh ok
17:36:40 <CosmicRay> what package was this error in?
17:36:41 <ibid> yeah:
17:36:42 <ibid> Overlapping instance declarations:
17:36:42 <ibid>   In module MissingH.Printf.Types: PFType a
17:36:42 <ibid>   In module MissingH.Printf.Types: PFType Char
17:36:51 <CosmicRay> you need to use -fallow-overlapping-instances
17:37:04 <ibid> and where exactly is that documented? ;)
17:37:07 <CosmicRay> appropriate flags can be found in the Makefile
17:37:13 <ibid> in what makefile?
17:37:21 <CosmicRay> ah, are you using the deb?
17:37:25 <ibid> this is compiling my own program using your deb
17:37:39 <CosmicRay> hrm.  that *is* a documentation deficiency.
17:37:53 * CosmicRay will commit a fix right away.
17:37:57 <ibid> ok, thanks :)
17:38:21 <ibid> i'm also committing a use of internals
17:38:57 <ibid> you might want to consider promoting the PFType class to the external module
17:39:15 <ibid> i think others too might find it handy to define their own instances
17:39:16 <CosmicRay> to the external module?
17:39:20 <CosmicRay> oh.
17:39:34 <CosmicRay> MissingH does export the module it's in
17:39:47 <ibid> it's currently in ...Types, whose use in user programs is discouraged
17:39:49 <CosmicRay> (MissingH.Printf.Types)
17:39:52 <CosmicRay> ah.
17:39:52 <ibid> sure
17:39:56 <CosmicRay> I didn't know that was a convention.
17:40:12 <ibid> CosmicRay: you didn't know a convention you've written yourself?
17:40:29 <ibid> "This module is used internally by MissingH.Printf and is not intended to be used in your programs."
17:40:37 <CosmicRay> I thought you were saying that in general, modules named Types were not encouraged to be used :-)
17:40:42 <ibid> heh
17:40:42 <ibid> no
17:41:24 <ibid> in generating assembly, a printf is quite nice :)
17:41:25 <ibid> thanks
17:41:26 <ibid> for that
17:41:32 <CosmicRay> glad you found it useful
17:41:58 <CosmicRay> igloo wrote the hard parts
17:42:50 <ibid> sure :)
17:45:22 <ibid> hmmh, of course, it doesn't really behave like i expect it to :)
17:45:33 <bourbaki> and if i want to get a value out of my ptr then i would just build another funtcion like this? Ptr -> IO TheTypeIWantToReturn ?
17:45:46 <CosmicRay> ibid: oh?
17:45:57 <ibid> i defined
17:46:03 <ibid> putLine :: String -> IA32Monad ()
17:46:03 <ibid> putLine s = do (MS (GS { fh = fh }) (LS {})) <- get
17:46:03 <ibid> 	       liftIO $ hPutStrLn fh s
17:46:20 <ibid> and i use it
17:46:21 <ibid> putLinef "add %s, 15" r2'
17:46:22 <ibid> :)
17:46:30 <ibid> that screams :)
17:46:43 <ibid> hm, sorry
17:46:46 <CosmicRay> where is the printf?
17:46:48 <CosmicRay> ah.
17:46:51 <ibid> putLinef = putLine . vsprintf
17:46:59 <ibid> :)
17:47:12 <ibid> though i'm not very surprised about this
17:47:18 <ibid> sad, but not surprised :)'
17:47:34 <CosmicRay> hm, that should work.  what exactly is the scream?
17:47:51 <ibid> Couldn't match `IA32Monad ()' against `t -> t1'
17:48:00 <ibid> Probable cause: `putLinef' is applied to too many arguments in the call
17:48:00 <ibid> 	(putLinef "add %s, 15" r2')
17:48:12 <CosmicRay> did you provide a type definition for putLinef?
17:48:15 <ibid> no
17:48:20 <CosmicRay> that'll be the problem
17:48:34 <CosmicRay> I'm assuming it should be String -> String -> IA32Monad ()
17:48:45 <ibid> no
17:48:56 <ibid> it should be variable-argumented, really ;)
17:49:01 <CosmicRay> ah.
17:49:10 * CosmicRay ponders a sec.
17:49:18 <ibid> i was hoping haskell would just figure it out
17:49:26 <ibid> but i'm not really surprised that it didn't
17:50:15 <CosmicRay> if you look at the MissingH source, I had to declare a new typeclass to make that trick work with vfprintf
17:50:17 <ibid> i could just go with the list-argument version
17:50:27 <ibid> CosmicRay: yeah, i figured that
17:50:33 <CosmicRay> I don't know if I did that just because I was too stupid to figure out a better way, or if because it was truly the only way to do it
17:50:36 <ibid> sad, but not surprised, as i said :)
17:50:39 <CosmicRay> ibid: that is the easy option :-)
17:50:49 <CosmicRay> class IOPFRun a where
17:50:49 <CosmicRay>     iopfrun :: Handle -> ([Value] -> String) -> a
17:50:49 <CosmicRay> instance IOPFRun (IO ()) where
17:50:49 <CosmicRay>     iopfrun h f = hPutStr h $ pfrun f
17:50:49 <CosmicRay> instance (PFType a, IOPFRun b) => IOPFRun (a -> b) where
17:50:50 <CosmicRay>     iopfrun h f x = iopfrun h (\xs -> f (toValue x : xs))
17:51:07 <CosmicRay> vfprintf :: IOPFRun a => Handle -> String -> a
17:51:07 <CosmicRay> vfprintf h f = iopfrun h $ sprintf f
17:52:07 <CosmicRay> though this will plant you firmly into the "messing with Printf internals" territory :-)
17:52:12 <ibid> heh
17:52:28 <ibid> not really, if i define my own class :)
17:54:17 <CosmicRay> pfrun isn't exported except by Types, and I'm not sure so readily that it should be...  otoh perhaps there is some nice way to make this more generic.
17:54:37 <ibid> pfrun?
17:54:42 <CosmicRay> but by the same token, I don't have *any* inclination to mess with pfrun now that it's working
17:54:43 <ibid> ahh
17:54:48 <ibid> heh
17:55:22 <ibid> i'll just eat my vegetables and use the list version :)
17:55:26 <ibid> mm vegetables
17:55:26 <CosmicRay> :-)
17:55:31 <ibid> need to cook food :)
17:55:42 <ibid> (actually, microwave)
17:56:09 <CosmicRay> nothing like invisible radiation to warm things.
17:56:41 <ibid> :)
17:56:52 <CosmicRay> there is the convenience function named "v" that makes the list version not-so-bad
17:56:52 <ibid> well, regular oven does that too, in a sense
17:57:00 <ibid> though i suppose it's more tactile
17:57:07 <ibid> CosmicRay: so horribly named ;)
17:57:09 <CosmicRay> nah, can always see the fire or the heating element glowing :-)
17:57:18 <CosmicRay> heh
17:57:46 <CosmicRay> I could have been like Tom Lord and called it thatFunctionWhichTransformsCertainEntitiesIntoAValueButOnlyIfTheyreInTheRightClass
17:57:58 <ibid> i have my patented good-for-you microwave food
17:58:06 <CosmicRay> oh?
17:58:16 <ibid> well, relatively speaking, of course
17:58:22 <CosmicRay> heh
17:58:38 <CosmicRay> I got my wife a bread machine for christmas.  fascinating appliance, that.
17:58:59 <CosmicRay> nothing like chemistry and micro-organisms to make your bread rise... or not.
18:00:03 <ibid> i take a plate, a bag of frozen veggies (they sell them here in the correct size) and fill half of the plate with them, then i take my bag of microwave-friendly fries or some other frozen potatoes and fill a half of the remaining half with them; then i take some meat and put it in the remaining quarter.  microwave to taste and eat :)
18:00:05 <monochrom> He who gives his wife a tool for gift has no heart.  She who accepts it has no brain.  :)
18:00:37 <CosmicRay> ibid: hmm, sounds like a simple casserole. nice.
18:01:04 <ibid> CosmicRay: fast, simple and much better for you than many of the alternatives ;)
18:01:29 <CosmicRay> monochrom: she likes kitchen-related appliances.  I gave her a stand mixer for her birthday once.  She likes it because it's fast and stable.  My friends are impressed that it has a 350W motor :-)
18:01:55 <ibid> CosmicRay: is she one of those who forbid anybody else to step in her kingdom (read: the kitchen)? :)
18:02:32 <CosmicRay> ibid: not unless someone makes a mess without cleaning it up :-)
18:02:40 <ibid> :)
18:03:08 <monochrom> I said that under the influence of a subway ad of a department store.
18:03:22 <CosmicRay> heh
18:03:35 <CosmicRay> monochrom: I did also get her some Christmas-themed socks :-)
18:04:42 <monochrom> The ad shows several gifts to Her.  Jewellery "he loves me", handbag "he loves me", shoes "he loves me", iron "he loves me not".  
18:05:00 <CosmicRay> heh
18:05:24 <ibid> much simpler to live alone :)
18:05:26 <CosmicRay> monochrom: funny you should mention that; one of the other items on her Christmas list (which I didn't get her) is a close steamer (which replaces an iron, basically)
18:05:27 <CosmicRay> hehe
18:05:47 <CosmicRay> ibid: yeah, but now what are you going to do for an excuse to buy an appliance with a 350W motor? :-)
18:06:11 <ibid> CosmicRay: what would i do with such a thing? :)
18:06:24 <CosmicRay> I'm sure the geek in you could come up with some uses!
18:06:28 <ibid> heh
18:06:36 <ibid> i'm a *computer* geek
18:06:37 <ibid> :)
18:06:51 <CosmicRay> ahh, it would be the engineers that would want it, eh? :-)
18:06:51 <ibid> actually, a software geek
18:06:58 <ibid> i don't warm to anything with moving parts in it :)
18:07:20 <ibid> (unless it can be used to store or execute software;)
18:07:34 <CosmicRay> heh
18:07:39 <musasabi> gf are nice (got Okasaki's purely functional data structures for present) ^_^
18:07:52 <CosmicRay> I'm with you, mostly, but I'm not above the periodic purchase at thinkgeek.com :-)
18:07:54 <monochrom> My analytic engine could use a 350W motor.  It would run faster.
18:07:59 <CosmicRay> haha
18:08:14 <CosmicRay> musasabi: I got Haskell: The Craft of Functional Programming this year :-)
18:08:31 <ibid> i got a css book this year
18:08:35 <ibid> (from my father:)
18:08:52 <ibid> (but he's the kind of a person who asks people what they want:)
18:09:00 <CosmicRay> ibid: you *wanted* a css book? :-)
18:09:06 <monochrom> that's neat.
18:09:24 <ibid> CosmicRay: i wanted a book by that author, mostly
18:09:34 <ibid> CosmicRay: a css book in itself would be boring :)
18:09:49 <monochrom> beats people who buy you the generic useless play-safe gifts such as decorations.
18:10:15 <ibid> CosmicRay: i wanted to read something even vaguely useful that the guy has written
18:10:20 <ibid> he's unusually good
18:10:39 * CosmicRay tries to avoid html and everything associated with it as much as possible
18:10:54 <ibid> (jukka k. korpela, some of you may have heard of him even outside finland)
18:11:22 <tuomov> (and anyone in finland who hasn't heard of him may not call himself a geek)
18:11:41 <CosmicRay> whew, saved by geography :-)
18:12:21 <ibid> my mother gave me a long neck scarf and an anagram-poetry book
18:12:50 <ibid> my father gave me also "dictionary of pirates" (no, not arrr, but who when what where)
18:14:32 <ibid> i gave both of them linux books ;)
18:14:55 <CosmicRay> heh
18:15:28 <ibid> (yes, both have a real need for them)
18:16:05 <ibid> (my father tries to learn to sysadmin and my mother tries to learn to cope with the debian i installed her when her windows blew up:)
18:16:11 <CosmicRay> heh
18:16:40 <ibid> (installed remotely, no less)
18:17:52 <CosmicRay> really
18:17:57 <CosmicRay> you walked her through the installer?
18:18:20 <ibid> CosmicRay: no
18:18:49 <ibid> CosmicRay: i mailed her a damnsmalllinux cd, walked her through enabling ssh and i was in ;)
18:19:13 <ibid> installed dsl, and then upgraded to testing
18:19:36 <CosmicRay> sweet.
18:19:41 * CosmicRay bookmarks that
18:19:51 <CosmicRay> you may be interested in http://people.debian.org/~jgoerzen/dfs/
18:20:01 <CosmicRay> you could have told her: 1. insert cd, 2. type /etc/init.d/ssh start :-)
18:20:02 <ibid> mind you, i wouldn't leave anybody with dsl, and it leaves nasty stuff behind
18:20:25 <CosmicRay> well almost :-)
18:20:26 <ibid> CosmicRay: my primary problem was to get her something that would work on her old machine
18:20:36 <CosmicRay> that can be a trick.
18:21:12 <Gahhh> linux distros work perfectly on old hardware. It's the new hardware that is tricky.
18:21:27 <ibid> Gahhh: no, they don't
18:21:38 <ibid> Gahhh: modern linux distros have insane memory requirements'
18:21:45 <CosmicRay> Gahhh: it depends on what sort of old hardware we're talking about.
18:22:05 <CosmicRay> Gahhh: for instance, if your video card is EISA, very few will autodetect it, and some give you horrible fits if they can't
18:22:06 <ibid> how much memory does dfs need?
18:22:08 <Gahhh> but arent there a million minimalist distros alongside suse, mandrake, etc. ?
18:22:17 <ibid> Gahhh: that's what dsl is :)
18:22:27 <CosmicRay> ibid: I haven't tried, but I'd say it could probably work in 32M
18:22:33 <Gahhh> ah. I thought dsl was for digital subscriber line.
18:22:54 <ibid> Gahhh: heh, damnsmalllinux
18:23:28 <Gahhh> ibid, does she have xwindows with a browser now ?
18:23:37 <ibid> Gahhh: yes
18:24:04 <Gahhh> ibid, how much memory does that setup need ?
18:24:07 <CosmicRay> ibid: it starts up very little by default; the only tricky bit will be the initial ramdisk, which I think is about 8MB
18:24:10 <ibid> i've basically tried to not break the user experience that dsl created for her
18:24:27 <CosmicRay> so probably even less than 32m would work, but I haven't tested it with less than 64
18:24:43 <musasabi> getting internet connectivity is often the hardest part.
18:25:03 <ibid> Gahhh: her 32mb is enough to run dillo and sylpheed and some other programs
18:25:13 <ibid> Gahhh: firefox works but is really slow
18:25:13 <musasabi> ADSL adapters (PCI/USB) are quite problematic.
18:25:38 <CosmicRay> around here, usually one hooks the dsl up to an ethernet port
18:25:48 <ibid> here too
18:26:41 <musasabi> The ethernet<->DSL adapters are slightly more costy so folks without knowledge usually pick the cheaper alternative leading to nasty problems.
18:26:48 <ibid> there was a nasty x memory leak in her machine at some point
18:26:59 <ibid> seemed to go away when i upgraded the machine to 2.6 kernel
18:27:07 <CosmicRay> ibid: ouch, firefox sounds sickly in 32mb
18:27:10 <musasabi> but => sleep
18:27:20 <CosmicRay> ibid: have you tried Mosaic? :-)
18:27:30 <ibid> CosmicRay: isn't that nonfree :)
18:27:37 <ibid> CosmicRay: dillo works well enough
18:27:42 <CosmicRay> ibid: yeah but who cares anymore :-)
18:27:44 <ibid> CosmicRay: ssl is the biggest problem
18:27:49 <CosmicRay> ah
18:27:54 <CosmicRay> no ssl in dillo?
18:28:06 <ibid> apparently not
18:28:17 <ibid> there is a patch but it's said to be flaky
18:28:19 <CosmicRay> couldn't she just get a 64MB dimm or something? :-)
18:28:21 <ibid> haven't tried :)
18:28:48 <ibid> CosmicRay: hard to get memory that fits in that machine, i hear
18:29:01 <CosmicRay> ah, bummer
18:29:02 <ibid> CosmicRay: before the linux thing she asked around for a memory upgrade
18:29:18 <CosmicRay> is there a finland version of crucial.com?
18:29:25 <CosmicRay> I even tracked down ram for my alpha there
18:29:32 <ibid> no idea
18:29:55 <CosmicRay> what type of machine is it?
18:30:27 <ibid> anyway, i'm wondering, we're still doing the same things with our machines that we did five years ago; why is it that we now need insanely more memory to do it
18:30:33 <ibid> CosmicRay: what do you mean?
18:30:55 <Gahhh> ibid, I am not doing the same things.
18:30:59 <CosmicRay> ibid: manufacturer, model
18:31:11 <CosmicRay> ibid: I think it's because we're not quite doing the same things
18:31:13 <ibid> Gahhh: i am, more or less
18:31:22 <ibid> CosmicRay: ibm aptiva iirc
18:31:48 <CosmicRay> ibid: for instance, people using modern browsers expect javascript, popup blocking, cookie blocking, etc.
18:31:56 <CosmicRay> people expect anti-spam measures in e-mail readers
18:32:11 <CosmicRay> oh man, I remember working on aptivas
18:32:27 <ibid> well, anti-spam filters i can understand, but one could run them in servers :)
18:32:31 <CosmicRay> ibid: http://www.crucial.com/store/listmodel.asp?cat=RAM&mfr=IBM&productline=Aptiva&submit=Go
18:32:45 <ibid> popup blocking, cookie blocking etc are small things
18:32:49 <CosmicRay> ibid: get the model number and it will tell you what type of ram it needs.  you can then track it down online
18:32:51 <ibid> javascript worked five years ago
18:33:09 <CosmicRay> I suppose so..
18:33:15 <Gahhh> ibid, I didn't have 18 tabs open in firefox 5 years ago, tho
18:33:20 <CosmicRay> netscape was a memory hog too.
18:33:25 <CosmicRay> also crash-prone.
18:33:28 <ibid> Gahhh: that, yeah :)
18:33:58 <Gahhh> however, it is true that our usage of resources for desktop apps is not exponentially increasing.
18:35:21 <Gahhh> ...unless you have been gaming.
18:35:33 <CosmicRay> ibid: fwiw, I get lots of my memory from crucial, they have good prices in the US.  Looks like they charge $20 to ship to finland, but with the weak dollar, that may not hurt so much.  anyway, just wanted to point out that you may be able to upgrade it.
18:36:11 <ibid> CosmicRay: i don't like to shop from outside of eu, duties and taxes are nasty surprises
18:36:21 <CosmicRay> ibid: understandable
18:36:38 <ibid> anyway, i'm off
18:36:48 <ibid> need to get that health food prepared ;)
18:36:50 <ibid> bbl
18:36:57 <Gahhh> cu
19:23:59 <ibid> b :)
20:44:52 * shapr grumbles
20:45:32 <shapr> Do you ever suddenly snap awake after three hours sleep and realize you won't be sleepy again till noon?
