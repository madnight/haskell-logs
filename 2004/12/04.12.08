00:13:38 <blackdog> jadrian: yeah, that makes sense. I guess the problem is that you can pretty often add just one more op to a type... :)
00:14:43 <blackdog> dumb tex question: is there a simple way to read in a file from somewhere else? I don't want to inline my haskell code </thin justification for asking silly questions>
00:15:36 <tuomov> \input? \verbatiminput? \whateverprettyprinterinput?
00:17:59 <blackdog> ah, \input lambdatex
00:18:08 <blackdog> i ought to know that, i sit next to the guy who wrote it.
00:18:41 <blackdog> cheers tuomov. may all your function calls return safe and sound.
01:48:35 <basti_> email to service: "i get virii with my outlook express daily. I want to switch to thunderbird, I hope not to get any more then."
01:48:55 <kristnjov> :P
01:49:04 <basti_> just happened to a friend of mine
01:49:42 <basti_> astounding how people manage to confuse cause and effect ;)
01:54:58 <Amadan> my favourite personally witnessed helpdesk quote so far: "help, we're having a lecture and my powerpoint can't see my computer!"
01:55:47 <basti_> uh
02:34:14 <blackdog> Amadan: I got a call from a professor who wanted to know why he couldn't read a cd-rom in the school-maintained computers. It turned out that he didn't realise the cd needed to be in the drive for the mount script to work.  no friend-of-a-friend fooling here, I took the call...
02:38:55 <xerox> 'morning
02:40:02 <Amadan> :) okay, i have more, also from my helpdesk duty: "I got a message that I have a virus." "in email? which virus did it say?" "wait, i saw the name somewhere... ah yes, virus alert." (note, the conversation was not in english)
02:40:23 <Amadan> morning
02:42:11 <Amadan> also: "can i speak to mr. daemon?" "who?" "mr. mailer daemon. i've written an email that got mistakenly sent to his address, so i wanted to apologise."
02:42:40 <Amadan> and that from a scientific institute... :)
02:43:24 <blackdog> i think there's a mailer daemon which actually apologises when it can't get through. qmail, maybe? "Sorry things didn't work out", or something similar... sounds like it's breaking up with you. :)
02:44:35 <Amadan> megamonad: do you know the mailer daemon who breaks up with you when he emails you?
02:44:41 <MegaMonad> Amadan: I might not find interface file so the error that can hold (lots of) data for some (possibly most) ides it probably breaks on a list of emails?
02:45:42 <Amadan> megamonad: yes, i never liked those interface files.
02:45:48 <MegaMonad> Amadan: The interface would have liked to go into the ghc files on haskell.
02:46:15 <Amadan> this is uncanny. :)
02:47:41 <Amadan> oh, one more: "listen, what i said in the morning that the network doesn't work, we managed to fix it." "yeah? what was it?" "turns out my HD cable was not connected properly." "?!"
03:12:00 <xerox> kosmikus, are you here?
03:14:19 <kosmikus> yes
03:15:47 <xerox> kosmikus, hi! what about this: (that is the 'next' exercise, in the tutorial)
03:15:53 <xerox> elementsF t = foldBT (\l x r -> l ++ [x] ++ r) (\x -> x:[]) t
03:16:15 <xerox> a function that returns the elements of a BinaryTree using fold.
03:20:11 <kosmikus> looks ok
03:20:34 <kosmikus> (\x -> [x]) or even (:[]) are slightly shorter versions of (\x -> x:[])
03:21:14 <xerox> right, nice :)
03:23:21 <xerox> (:[]) didn't tought of something like that
03:34:35 <xerox> kosmikus, how can i call the list-like-fold i made yesterday? it can be worth it to keep?
03:39:58 <kosmikus> I'd call it crushrBT/crushlBT, or reducerBT/reducelBT ...
03:42:49 <xerox> nice one
03:45:09 <kosmikus> you might want to look at page 51 of http://www.cs.chalmers.se/~patrikj/poly/afp98/genprogintro.ps.gz for some explanation on the "crush" function
03:51:07 <xerox> i see
03:52:04 <kosmikus> your left and right variant allow a slightly more general type, but it's still essentially the same function
03:52:34 <kosmikus> Generic Haskell calls them reducer and reducel
04:00:24 <irce> %who
04:00:27 <irce> prkl
04:03:21 <xerox> :) lunch time, later!
04:48:40 <maihem> moin!
04:50:11 <Muad_Dibber> oi
05:21:16 <tromp> @index Int64
05:21:16 <lambdabot> Data.Int,Foreign,GHC.Int,Int
05:39:11 <TheHunter> MegaMonad, 'ssup?
05:39:17 <MegaMonad> TheHunter: Like necrodome, which i don't hate ite, and you're done!
05:49:26 <TheHunter> @eval "MegaMonad: hello!"
05:49:26 <lambdabot> MegaMonad: hello!
05:51:57 <TheHunter> MegaMonad: @eval "test"
05:52:03 <MegaMonad> TheHunter: Are you speaking of todo items, peter thiemann said i have to test it, but something is element of 2 given the function is executed, the plugin is plugged in, he had 4 exercises before (1 per week) and somehow it makes sense in my fixed-size table mapping word -> message id would allow me to test.
06:06:17 <musasabi> Is there any research into "safe" haskell?
06:06:27 <bringert> safe how?
06:06:42 <musasabi> Limiting the amount of changes untrusted code can make.
06:06:59 <musasabi> mainly no ffi and no Foreign.*
06:07:04 <bringert> like jvm sandboxing?
06:07:18 <bringert> and no IO
06:07:29 <musasabi> well IO is needed for too many things.
06:07:50 <musasabi> and in my case that would be handled by a special prelude.
06:07:57 <bringert> ah
06:20:49 <Itkovian> anybody using binutils >= 2.15.91.0.1
06:21:00 <Itkovian> ouch sorry wrong channel ;-)
06:21:21 <Muad_Dibber> lol
06:21:38 <Itkovian> a Good Thing I didn't post any erm, lewd remarks ;-)
06:22:25 <tuomov> so that megamonad would associate them with you?
06:22:36 <Itkovian> erm ... 
06:22:46 <Itkovian> it remembers stuff?
06:22:47 <Itkovian> eek.
06:23:45 <bringert> MegaMonad: what do you think about Itkovian?
06:23:51 <MegaMonad> bringert: Which in c if it doesn't make sense just a way to throw math content out of me i think about itkovian?
06:24:12 <Itkovian> heh
06:29:04 <earthy> Chitty Chitty Bang Bang
06:31:58 <earthy> (just trying to further confuse the chatterbot ;))
06:31:59 <tromp> @index even
06:31:59 <lambdabot> GHC.Real,Prelude
06:32:13 <earthy> GHC.Real,Prelude
06:32:19 <earthy> MegaMonad: @index odd
06:32:33 <MegaMonad> earthy: Ozone: need to see if it would have the odd ones have become odd, while the odd elements of the argument.
07:16:11 <musasabi> Is there any utility to tell the memory consumption of an object in haskell?
07:16:47 <musasabi> a function "sizeof a -> IO Int" would be ideal.
07:18:20 <Darius> Not really, though the FFI may have something that you can use and GHC's profiling support may be useful as well.
07:21:48 <Darius> @type Foreign.Storeable.sizeOf
07:21:49 <lambdabot> bzzt
07:21:57 <Darius> @type Foreign.Storable.sizeOf
07:21:58 <lambdabot> Foreign.Storable.sizeOf :: forall a.
07:21:58 <lambdabot> 			   (Foreign.Storable.Storable a) =>
07:21:58 <lambdabot> 			   a -> Int
07:22:52 <musasabi> but my head gives the answer for Storable things..
07:23:13 <musasabi> I am more interested in data definitions..
07:28:22 <Igloo> Why do you want to know?
07:36:05 <musasabi> Igloo: trying to select good datatypes to use for a few things and want to avoid refactoring things later on too much.
07:38:27 <CosmicRay> MegaMonad: good morning
07:38:33 <MegaMonad> CosmicRay: Yes. Which is a lot of changes that affect 1143f the time to check the definition of "gollumseyes.
07:38:45 <CosmicRay> wow.  that was a little odd.
07:39:00 <CosmicRay> megamonad appears to know a little of tolkein :-)
07:42:37 <CosmicRay> MegaMonad: gollum?
07:42:43 <MegaMonad> CosmicRay: Http://www.google.se/search?q=cache:fd9w3lukieoj:hltheses.elsnet.org/essli/shan.pdf+natural+language+monad&hl=en.
07:45:10 <Itkovian> MegaMonad: do you enjoy reading Tolkien?
07:45:16 <MegaMonad> Itkovian: Everyone i talk to talk me into the monadic interface can, because you enjoy reading tolkien?
07:45:39 <CosmicRay> hmm.
07:45:43 <CosmicRay> this would be interesting
07:45:46 <Itkovian> MegaMonad: who said I do?
07:45:48 <CosmicRay> train a megahal with LOTR as a brain
07:45:57 <MegaMonad> Itkovian: Failed to load interface for `multimedia.sdl.core.o: unknown symbol `_glutmainloop.
07:46:03 <CosmicRay> haha
07:46:05 <Itkovian> Thought so
07:47:24 <Itkovian> MegaMonad: for what do you need that glut stuff?
07:47:30 <MegaMonad> Itkovian: Place me on the network i need a typeable version of glut.
07:47:30 * Itkovian is being pathetic
07:47:38 <Itkovian> heh
07:50:56 <Itkovian> MegaMonad: are we free?
07:51:03 <MegaMonad> Itkovian: You could do free coroutining if that is so cool.
07:51:06 <bringert> MegaMonad: have you ever used OAA?
07:51:20 <MegaMonad> bringert: Lambdabot: you just apply the quotient space is used in math so far from optimal, at least it's not me, but i think i ever used oaa?
07:51:21 <bringert> MegaMonad: if so, how do you like its ICL parser?
07:51:27 <MegaMonad> bringert: That's me and i too dislike the whole parser is a monoid as the heirarchal libraries come in?
07:51:57 <Itkovian> MegaMonad: you are talking rubbish
07:52:04 <MegaMonad> Itkovian: Then why do you think is is that i in the fptools license to get me list comprehension syntax is what i'm talking rubbish.
07:55:23 <Itkovian> MegaMonad: i have no idea
07:55:29 <MegaMonad> Itkovian: Yes, i guess it started to understand the idea you mentioned it, but as it there's a pre-release of some academic institutions get automatic release of the idea of being ready for release, but now it matches the base container had.  Join :: m (m a) -> m a.
07:59:24 <Itkovian> going home. ttyl
08:09:16 <mattam> it's a little OT, but does anyone happen to know some site/paper listing a collection of pi-calculus bisimulations ?
08:13:29 <kristnjov> try mathworld
08:15:37 <tromp> @index or
08:15:37 <lambdabot> Data.List,GHC.List,Prelude,List
08:44:55 <boegel> hello everyone
08:45:21 <boegel> anybody here who knows anything about raytracing/refraction/stuff like that ?
08:45:25 <boegel> I have a question :)
08:46:20 <xerox> No, sorry. :(
08:47:14 <Darius> boegel: Just ask your question.
08:47:51 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/transp/
08:48:04 <boegel> this is the effect I get, and it's not want I want (clearly)
08:48:19 <boegel> I can't seem to find the bug that causes this... maybe there a logical explenation for it ?
08:51:40 <Darius> What happens with different indexes of refraction?
08:52:09 <boegel> let me try Darius 
08:56:05 <Darius> The clear sphere is perfectly in centered in front of the camera?
08:58:13 <boegel> Darius yes
08:58:21 <boegel> coordinates are (0,0,-200) 
08:58:33 <boegel> the view point is on the positive Z-axis (0,0,300)
08:58:52 <boegel> Darius, refresh to see the result with a different index
09:00:18 <boegel> (refresh again to get the link to the whole scene working :p)
09:00:48 <boegel> it's just like the bastard cuts a piece of out the refracted image
09:01:00 <Darius> Well that was unexpected.
09:01:47 <boegel> heh :)
09:02:23 <boegel> I've been working on it for quite a while now, and had to play with some stuff to get it working like this
09:02:46 <boegel> like 'mirroring' normals and such, depending on whether or not I'm tracing inside an object or not
09:03:16 <Darius> Yeah, that was one thing I was thinking of.
09:03:29 <boegel> I'm not sure if it's 100% correct...
09:03:52 <boegel> if I don't mirror the normals, I just get no refraction (I don't see the sphere behind the 'transparent' sphere)
09:04:05 <boegel> anyway, I _hate_ refraction :)
09:07:30 <Darius> Hmm, actually it bending the light in the same direction on entering and leaving (getting \_/ instead of ,-') could explain the first set of images.  I'm not sure about the last one though.
09:07:51 <Darius> It also seems consistent with the distortion of the green sphere.
09:08:39 <Darius> Though I haven't looked into crystal balls that often, so I'm not exactly readily familiar with how things look through them)
09:08:43 <boegel> Darius, you mean I only get \_/ on the right hand side then?
09:08:51 <boegel> because it seems ok on the left ?
09:09:05 <Darius> No, you are getting it on both sides.
09:09:48 <Darius> But it still doesn't work out, as the last picture shouldn't have that dot.
09:09:55 <boegel> Darius, what's wrong on the left side of the image?? I'm getting good refraction there, aren't I ?
09:12:06 <boegel> I'm off to dinner... I'll be back Darius , if you have any more pointers, please don't hesitate :)
09:12:09 <Igloo> Is that a dot dead centre hitting something at 90 degrees?
09:12:24 <Igloo> It could be a numerical error causing it to go off at some silly angle
09:12:34 <Darius> Wait, what color is that dot?
09:13:05 * Igloo would ignore it until everything else works
09:13:57 <boegel> Darius, the dot is (0,0,130)
09:14:06 <boegel> Igloo, that's the last thing I need to get working :)
09:14:31 <Igloo> Oh, I thought all the others were wrong too
09:14:34 <boegel> Igloo, that's possible, but that doesn't explain the rest of the artefact
09:14:51 <boegel> Igloo, all the others on the transp page are...
09:15:08 <boegel> but I mean, refraction is the only thing I need to get working, the rest is ok
09:15:33 <boegel> now I'm off to dinner :)
09:16:51 * Igloo can't visualise what the right answer is easily enough
09:17:26 <Igloo> Do you only have spheres? It would be easier to think about with a cuboid
09:18:28 <Darius> Well, the easy case is the dot in the middle.  It should just go straight through.  It's possible it's getting "refracted" back into the camera.
09:19:46 <Igloo> Points close to 90, 0 etc aren't ideal to check with
09:20:04 <Darius> Igloo: I know.  It's possible that they are two different problems.
09:21:21 <Darius> Igloo: Does the dot in the middle look black to you?
09:23:22 <Igloo> It's 0,0,130 RGB
09:26:18 <Darius> ok
09:26:33 * Darius misunderstood boegel the first time.
09:29:52 <ela> hi all ... is there a person who could help me with haskell? i'm trying to write the play tic-tac-toe  since 3 days but without success .. 
09:32:47 <ela> i just need a little help with creating a game tree .. please if someone has an idea let me know .. i'm really despaired .. :(
09:36:25 <Darius> ela: There's an old paper called "Why Functional Programming Matters" you may want to look at.
09:37:30 <ela> darius, thank you very much, i'll look for it on the net .. 
09:42:34 <boegel> Darius, the dot has color (0,0,130) because that's the diffuse color of the transparent sphere
09:42:58 <boegel> so it doesn't get any light influence, nor reflection or refraction...
09:43:13 <boegel> I'll figure out what the problem is behind that, but still, the other artefact :s
09:43:26 <boegel> you said it might be two problems ?
09:44:21 <boegel> hey wolfman8k 
09:44:44 <Darius> boegel: Yes.  Igloo is quite possibly right about numerical errors, but it wouldn't seem that numerical errors caused the whole circle in the middle.
09:44:49 <boegel> maybe you can help me... http://studwww.ugent.be/~kehoste/thesisPublic/transp/
09:45:02 <boegel> Darius, what does cause that then ?
09:45:21 <Igloo> boegel: Can you render cuboids?
09:45:27 <Darius> I don't know.
09:45:37 <boegel> and still, my refraction algo isn't complete yet... If I would place a light behind a transparent sphere, it wouldn't refract, but just block
09:45:54 <boegel> Igloo, no, I only have spheres and planes (for now)
09:46:04 <boegel> but I could give it a try one of these days...
09:46:17 <boegel> having planes already, it shouldn't be that hard, should it ?
09:46:36 <Darius> boegel: What do you do color-wise for rays that recurse to deeply? 
09:46:42 * Darius also only had planes and spheres.
09:46:57 * Darius was thinking about making cubes by intersecting planes as a first pass.
09:48:30 <Igloo> boegel: I think either cuboids or, perhaps better still, being able to draw the path of a given ray, would help tremendously. Although you want to have the camera in a different place from where the ray is fired, ideally
09:48:31 <Darius> Hmm, I might also have had infinite cylinders...
09:49:04 <Darius> Well, a simple solution would just have something spit out the points that a ray hits.
09:49:16 <Igloo> Bah, y'all are making me want to write a raytracer! Stoppit!
09:49:36 <Darius> They're fun to write... except refraction ;)
09:50:06 <Igloo> :-)
09:50:26 <Darius> I actually started to write another raytracer not too long ago using Common Lisp and geometric algebra.
09:50:30 <Muad_Dibber> Igloo, you know what i'd like to see done?
09:50:31 <Igloo> I guess to do it baguely efficiently in Haskell you'd have to spend most of your time in ST for things like antialiasing etc
09:50:50 <Igloo> What's that, Muad_Dibber?
09:50:59 <Muad_Dibber> a raytracer that can reads my mind
09:51:07 <Muad_Dibber> so i do not have to tell it what objects i want
09:51:08 * Igloo is trying to remember if I did actually write one at some point. I have half-memories of having done so
09:51:12 <Muad_Dibber> just ahve it project what i think :P
09:51:26 <Igloo> uh huh
10:03:54 <boegel> Darius, when a ray goes to deep, I just returns (0,0,0) as color instead of recursing further... (thus stopping the recursion without harming the result)
10:04:01 <wolfman8k> boegel
10:04:05 <boegel> Igloo, I think that would be overkill to tackle the problem
10:04:36 <Igloo> I think it would be cool anyway, though
10:04:37 <boegel> I'll probably have another try at showing intersection points + colors it traces through
10:04:39 <boegel> wolfman8k, ?
10:04:47 <wolfman8k> ?
10:04:53 <boegel> Igloo, it would, but I have other stuff to do to
10:05:09 <boegel> wolfman8k, you typed 'boegel', thus attracting my attention ;)
10:05:18 <Darius> A simple way to do it would be to trace the points on a single (selected) ray cast and then make a scene with small spheres at those points.
10:05:28 <wolfman8k> boegel: that was a response to you attracting my attention :)
10:05:49 <boegel> have you looked at the images I'm having trouble with ?
10:05:55 <wolfman8k> nein
10:05:56 <boegel> these: http://studwww.ugent.be/~kehoste/thesisPublic/transp ?
10:06:05 <boegel> maybe you could explain it...
10:06:20 <boegel> I have to go now though, I think I'll be back in 2.5 hours
10:06:48 <boegel> if you guys have any hints how i could easily tackle this problem, please don't hesitate :)
10:06:55 * boegel is out for now
10:18:50 <tromp> @index not
10:18:51 <lambdabot> Data.Bool,GHC.Base,Prelude
10:54:15 <tromp> @index isEmpty
10:54:15 <lambdabot> Text.PrettyPrint,Text.PrettyPrint.HughesPJ
11:15:25 * shapr hops
11:16:13 <shapr> it's oh so quiet... it's oh so still...
11:16:25 <Igloo> How's it going, shapr?
11:16:34 <shapr> Life is good, I took the day off.
11:16:35 <Igloo> Written anything exciting recently?
11:16:43 <shapr> Nah, just reading lately.
11:16:58 <Darius> Read anything exciting recently?
11:17:05 <wolfman8k> i have a question about monads...
11:17:25 <wolfman8k> are monads part of the haskell core language?
11:17:30 <shapr> I've been reading the baen.com/library collection. I'm nearly done :-/
11:17:41 <Darius> The are standard, but not primitive except for IO.
11:17:43 <shapr> wolfman8k: nah, monads are just an abstraction like objects.
11:17:57 <wolfman8k> shapr: so Monad is just a class like any other class that i can make?
11:18:01 <shapr> yup
11:18:06 <shapr> @info Monad
11:18:07 <lambdabot> -- Monad is a class
11:18:07 <lambdabot> class Monad m :: (* -> *) where {
11:18:07 <lambdabot>     (>>=) :: forall a b. m a -> (a -> m b) -> m b;
11:18:07 <lambdabot>     (>>) :: forall a b. m a -> m b -> m b {- has default method -};
11:18:07 <lambdabot>     return :: forall a. a -> m a;
11:18:08 <lambdabot>     fail :: forall a. String -> m a {- has default method -};
11:18:10 <lambdabot>     }
11:18:29 <wolfman8k> so the only thing special about monads is the special do syntax for them?
11:18:37 <shapr> You only need to make >>= and return to make your own monad.
11:18:37 <Darius> Yes.
11:19:10 <wolfman8k> is it possible to extend haskell's syntax to do similar things with my own classes?
11:19:18 <wolfman8k> like macros or something
11:19:22 <shapr> The monad interface is very flexible too. If you read the nomaware tutorial, you'll see how cool they can get.
11:19:35 <wolfman8k> i've read that i think... i also read about arrows
11:19:59 <shapr> arrows do more, but they're a bit harder to use.
11:20:25 <shapr> As for extending syntax, that usually requires a preprocessor. If there's another way to do it, I don't know it.
11:21:02 <shapr> Template Haskell gives you macros, but not syntax macros.
11:21:10 <wli> syntax? let's hope we're not in so much trouble that's necessary
11:22:22 <shapr> I haven't found a great need for syntax macros, but I may have missed some opporutunities.
11:22:39 <shapr> wolfman8k: have you found some good chances to use syntax macros?
11:23:22 <wolfman8k> arrows seem good for doing things that have a state that changes during some behavour
11:24:10 <shapr> I think arrows can do that, but they do a lot more also.
11:25:19 <shapr> The primary 'operational' differences between monads and arrows are that variable bindings in arrows go out of scope faster, and that arrows don't require execution to get useful information out of them.
11:25:38 <wolfman8k> what do you mean by execution?
11:26:14 <shapr> if you look at the type of >>= you'll see the only way to do anything with it is to execute it.
11:26:57 <shapr> You can usually tell which of several alternative parsers will succeed or not after the first few characters of input.
11:27:46 <shapr> But you still have to hang onto the whole input because the only way to tell if any of multiple alternative monadic parsers will fail is for them to call their own fail method
11:28:15 <shapr> That's actually exactly how arrows came about
11:28:56 <shapr> Swierstra and Duponcheel figured out that parsers that can export static information about what they can parse can be much more efficient than parsers that must be executed to give a return status
11:29:37 <wli> everything's just a parser anyway =)
11:29:43 <shapr> John Hughes puzzled the arrow interface out of that information, and wrote a cool paper about other neat tricks using the arrow interface .
11:30:44 <shapr> wolfman8k: monads are more like first-class actions, you push the button and something happens. arrows are more like first-class transformations, like a lens that changes how light behaves
11:31:44 <shapr> Sort of like turning a verb into a noun lets you manipulate that as a value.
11:31:48 * shapr isn't sure if that makes any sense.
11:32:08 <wolfman8k> my problem is that i don't know any math :/
11:32:13 <shapr> Oh, I don't either.
11:32:39 <shapr> But I don't think that makes monads or arrows any harder to understand.
11:33:17 <shapr> They're just neat tricks to make it easier to write programs. And they have equivalent patterns in the math world.
11:34:05 <wolfman8k> all the papers have a bunch of crazy equations though
11:34:13 <wolfman8k> that arrow one kept talking about category theory
11:34:35 <shapr> Right, but that's just showing you that there's a deeper connection between this useful pattern and the math world.
11:34:54 <shapr> You don't need to understand that connection to use the idea, or to understand the idea.
11:35:02 <Darius> Yes. One way of looking at monads is as simply good software engineering.
11:35:32 <Darius> If you write a bunch of state passing code, for example, you are likely to see patterns and likely to abstract them out.
11:35:40 <shapr> For example, the monad laws aren't laws, they're just good sense. a >>= (b >>= c) must work the same as (a >>= b) >>= c
11:36:29 <wolfman8k> so what would be better for doing a game of life simulation, monads or arrows?
11:36:40 <shapr> The whole idea of abstraction is to make reasoning about software pieces the same process whether those pieces are separate or plugged together.
11:37:38 <shapr> If software chunks suddenly change behaviour in unexpected ways when plugged together, I won't be able to predictably thing about how to design my programs.
11:38:17 <shapr> I don't think you need either monads or arrows for a game of life. You may want to use monads for IO to the GUI.
11:38:32 <shapr> hiya prabhu, are you really irc'ing as root?
11:38:32 <reffie> \o/
11:39:03 <shapr> hiya reffie 
11:39:06 <reffie> hi :P
11:39:12 <prabhu> yup
11:39:19 <wolfman8k> shapr: so there should be a function that takes as argument the board and returns as result the next state of the board?
11:39:19 <prabhu> actually i am in hurry
11:39:22 <xerox`> yo!
11:39:23 <reffie> yall should look at my super cool AES implementation in haskell :P
11:39:26 <shapr> prabhu: that's not very safe
11:39:36 <shapr> wolfman8k: sure, that's what I would do.
11:39:48 <shapr> reffie: what's the url?
11:39:48 <prabhu> yup but i had a problem and i was in hurry sorry
11:39:56 <reffie> shapr http://192.168.1.1/stuff/proj.lhs
11:39:58 <xerox`> *super cool*
11:40:01 <reffie> err
11:40:08 <reffie> shapr http://segfaulted.com/stuff/proj.lhs
11:40:48 <shapr> neat! are you going to lGPL that and donate it to the cryptolib project?
11:40:57 <reffie> probably not.
11:41:05 <reffie> it's a variant of AES
11:41:22 <shapr> ?
11:41:26 <reffie> [it has smaller field, grid and number of rounds]
11:41:29 <reffie> [less secure]
11:41:38 <mornfall> good day, shapr 
11:41:38 <shapr> But, someone else could upgrade it if you donated it.
11:41:43 <shapr> greetings mornfall 
11:41:59 <wolfman8k> "if you use debian heres a warning (atleast if you enter the debian channel): dont come in as root, you never hear the end of it, which was very annoying." --moron, 22-sep-04
11:42:12 <shapr> haha
11:42:27 <reffie> shapr do you have an url for cryptolib?
11:43:26 <shapr> http://www.haskell.org/crypto/ReadMe.html
11:44:13 <reffie> already has AES :P
11:46:09 <shapr> oh, huh
11:47:36 <CosmicRay> warning, though, there is a lot of license ambiguity in that package
11:47:55 <CosmicRay> if there wasn't, I would have pulled the whole thing into either debian or missingh already 
11:48:14 <CosmicRay> MegaMonad: do you have a license?
11:48:20 <MegaMonad> CosmicRay: That's me and i to add a license too.
11:51:21 <reffie> release early, release often
12:29:30 <ntfirewall> http://pastebin.com/127611 < i am getting this error > illegal left hand side datatype in binary tree
12:29:38 <ntfirewall> could someone please help
12:31:16 <Darius> Either remove Int from the left hand side, or make it a variable (and presumably replace the occurences of Int on the right hand side with that variable)
12:32:09 <ntfirewall> its type is Int
12:32:16 <ntfirewall> i cant change that
12:36:39 <Cale> ntfirewall: you probably want to define BTree a, not BTree Int
12:37:05 <Cale> i.e. data BTree a = ND | Leaf a | Node (BTree a) (BTree a) 
12:37:33 <Cale> then tree1 :: BTree Int is valid
12:38:07 <Cale> the other option is to define it without the Int on the left side (so your binary trees are restricted to Ints and not parametrised
12:38:35 <Cale> i.e. data BTree = ND | Leaf Int | Node BTree BTree 
12:38:54 <Cale> then tree1 :: BTree
12:39:02 <Darius> ntfirewall: Essentially, what you have written is like writing, int f(int 1){ return x + 1 } in C.
12:39:18 <Darius> (well, replace the x with 1)
12:39:37 <ntfirewall> data BTree a = Leaf a | Node (BTree a)(BTree a)
12:39:37 <ntfirewall>                deriving Show
12:39:37 <Darius> and add a semicolon.
12:39:43 <ntfirewall> i have done that 
12:39:44 <ntfirewall> but
12:39:55 <ntfirewall> tree1 :: Btree Int
12:39:56 <ntfirewall> tree1 = Node (Leaf 4) (Node (Leaf 2) (Leaf 1))
12:40:02 <ntfirewall> still dose not work
12:40:47 <Darius> In what way does it not work.
12:41:00 <Darius> Except that you have a typo.
12:41:08 <ntfirewall> it says 
12:41:22 <ntfirewall> undefined constructer Btree
12:41:48 <Darius> To quote ELIZA: And how does that make you feel?
12:41:55 <psi> you named it BTree didn't you
12:42:12 <ntfirewall> yes i have
12:42:17 <xerox> ntfirewall, are you reading Yet Another Haskell Tutorial ?
12:42:22 <ntfirewall> no 
12:42:27 <psi> not Btree
12:42:39 <ntfirewall> data BTree a = Leaf a | Node (BTree a)(BTree a)
12:42:39 <ntfirewall>                deriving Show
12:42:51 <ntfirewall> tree1 :: Btree Int
12:42:51 <ntfirewall> tree1 = Node ((Leaf 4) (Node (Leaf 2) (Leaf 1)))
12:43:02 <ntfirewall> that is the code 
12:43:31 <Darius> ntfirewall: Would you expect tree1 = Node ((Leaf 4) (Node (LFTHUOLE 2) (Leap 1))) to work?
12:43:31 <xerox> Hasn't Nodes to keep a value too?
12:44:05 <ntfirewall> i am supposed to use Leaf
12:44:16 <ntfirewall> Node and Leafs
12:46:43 <ntfirewall> i found the error
12:46:48 <ntfirewall> thanks
12:49:40 * boegel hops
12:49:56 <boegel> wolfman8k, did you look at my refraction bugs ?
12:50:29 <boegel> heya shapr 
12:50:47 <boegel> heya #haskell :p
12:54:16 <wolfman8k> boegel: yeah... i'm not sure what i'm looking at though
12:54:21 <wolfman8k> boegel: what's the thing in the middle?
12:57:08 <boegel> wolfman8k, you see a transparent sphere (base color blue, but almost completly transparent)
12:57:18 <boegel> a red sphere in front of it, a green one behind it
12:57:30 <boegel> the red one is reflected in the transparent one
12:57:42 <boegel> the green one is visible through the transparent one, partly
12:57:54 <boegel> but the artefacts in the center keep bugging me
12:59:32 <boegel> shapr, have you seen mitchkov lately ?
12:59:38 <boegel> @seen mitchkov
12:59:38 <lambdabot> I haven't seen mitchkov
13:05:10 <boegel> wolfman8k, ? :D
13:05:27 <wolfman8k> the pics look ok to me
13:05:42 <wolfman8k> you should try rendering some animations, to see how it looks in motion
13:05:42 <boegel> wolfman8k, which page are you looking at ? :)
13:06:24 <boegel> wolfman8k, I don't think that will be that easy:s
13:08:49 <wolfman8k> yep, that's the one
13:09:08 <wolfman8k> the glass ball seems a bit weird though
13:09:14 <boegel> and you think those images are normal ??
13:09:27 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/transp/trans2index.png
13:09:38 <boegel> the cutout isn't supposed to be there...
13:10:02 <boegel> wolfman8k, it's not really glass
13:10:14 <boegel> it's just a transparent sphere of some kind
13:11:28 <wolfman8k> your sure it's a sphere and not a donut?
13:12:29 <boegel> wolfman8k, yes :)
13:12:38 <boegel> and please don't make fun of my images :p
13:13:07 <Darius> boegel: What you don't think that your system couldn't just spontaneously generate support for torii?
13:14:08 <boegel> Darius, can it ?
13:14:19 <boegel> Darius, that would be cool :p
13:15:43 <CosmicRay> Darius: I bet MegaMonad could write such a thing :-)
13:15:57 <boegel> heh :)
13:16:06 <boegel> I don't know him, so I wouldn't know
13:16:16 <CosmicRay> MegaMonad: Could you spontaneously generate support for torii?
13:16:21 <CosmicRay> @wiki MegaMonad
13:16:22 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
13:16:22 <MegaMonad> CosmicRay: Not me, but the support for torii?
13:16:35 <CosmicRay> boegel; go there :-)
13:16:37 <Darius> Well, I guess you're wrong CosmicRay.
13:16:50 <CosmicRay> sigh.
13:16:59 <CosmicRay> MegaMonad: you've let us all down.
13:17:06 <MegaMonad> CosmicRay: If they're different, then there's an interesting intersection, don't you think? Is that on top of their code is easier in the haskell documentation pamphlets to demonstrators. Next to the uniq.
13:18:39 <boegel> sure MegaMonad :|
13:19:13 <CosmicRay> boegel: megamonad is an AI trained on the logs from this channel.  "To me java is a monomorphic type" was one of his better moments :-)
13:19:55 <boegel> CosmicRay, heh :)
13:20:12 <boegel> MegaMonad: how do I implement support for torii out of support for spheres
13:20:18 <MegaMonad> boegel: Spheres do in your tv dinner out of the cabalversion, or that it is the support for torii?
13:20:55 <Darius> I'm thinking "support for torii" is about the only words it has (strongly) associated with "torii"
13:21:01 <CosmicRay> probably so
13:21:09 <CosmicRay> that topic may not have been mentioned before today
13:21:30 <boegel> torii suck
13:21:37 <boegel> MegaMonad, do torii suck ?
13:21:43 <MegaMonad> boegel: I suck at all, you suck.
13:21:47 <boegel> :D
13:21:51 <CosmicRay> haha
13:21:57 <boegel> go MegaMonad !
13:22:44 <Philippa> MegaMonad, do you lick as well?
13:22:50 <MegaMonad> Philippa: I want me to install xmlrppc in ghc, i may not use any of us had ever written a lick of common patterns.
13:23:08 <boegel> MegaMonad, I bet you blow
13:23:14 <MegaMonad> boegel: Shapr: you bet there is to high level, and make sure you're only going to blow a lot you can use the debian distribution and is very old... It's a snake!
13:23:40 <CosmicRay> that should go on the wiki quotespage :-)
13:24:56 <CosmicRay> MegaMonad: does java suck?
13:25:02 <MegaMonad> CosmicRay: They suck at all, you suck.
13:25:08 <CosmicRay> pfft
13:25:13 <CosmicRay> MegaMonad: does java blow?
13:25:20 <MegaMonad> CosmicRay: I blow the stack to blow, no matter how it is a version control system if the length of data constructors.
13:25:20 <boegel> MegaMonad, suck you ! :p
13:25:26 <MegaMonad> boegel: I can think of ">>=" as "suck the output of p to be me right now.
13:25:46 <boegel> MegaMonad, who created you?
13:25:52 <MegaMonad> boegel: And if i send you a new file was created it wasn't three months. But too long, i must be attached to that if you meant me.
13:25:57 <boegel> beuh
13:26:00 <CosmicRay> boegel: you really need to read @wiki MegaMonad :-)
13:26:03 <CosmicRay> @wiki MegaMonad
13:26:04 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
13:26:11 <CosmicRay> boegel: all will be revealed :-)
13:26:14 <boegel> CosmicRay, I'm just playinh around :p
13:26:17 <CosmicRay> including some very funny quotes
13:26:18 <CosmicRay> ahh
13:26:28 <CosmicRay> I also like the conversation about sequencing noobs
13:26:32 <boegel> I know it's just a lookup system or so ;)
13:26:55 <CosmicRay> there's also a good deal of randomness involved in many instances
13:27:05 <CosmicRay> if you ask the same thing twice, you'll likely get two different answers
13:27:11 <CosmicRay> megamonad: who created you?
13:27:17 <MegaMonad> CosmicRay: Is there a way to me learning haskell? I'm reading "two dozen short lessons booklet told me i hadn't recently created an empty instance for tuples of the branches are in the final result.
13:27:30 <CosmicRay> well.
13:27:31 <earthy> megamonad: who created you?
13:27:42 <MegaMonad> earthy: Hmm, i find i like them in terms of those are essentially sequences of real eq code created, but not for me is that you?
13:27:51 <CosmicRay> heh
13:28:00 <earthy> (just checking ;))
13:28:05 <CosmicRay> MegaMonad: do you read -cafe?
13:28:12 <MegaMonad> CosmicRay: I want me to read http://poirot.cs.iastate.edu/tmp/test.hs.  It is called in soap/1.1 library and it asks to define preconditions outside the shop on the cafe list.
13:28:58 <CosmicRay> MegaMonad: any thoughts on iraq?
13:29:04 <MegaMonad> CosmicRay: And apply that reasoning on iraq ... I know, it even takes longer!
13:29:09 <CosmicRay> heh
13:29:33 <CosmicRay> MegaMonad: is Microsoft evil?
13:29:39 <MegaMonad> CosmicRay: Boegel bounces because he is evil evil evil.
13:29:45 <CosmicRay> haha
13:30:37 <boegel> lolz
13:30:44 <boegel> what do I have to do with M$ ? :p
13:30:53 <CosmicRay> we're all wondering that right about now
13:30:57 <CosmicRay> time for you to fess up! :-)
13:31:05 <CosmicRay> MegaMonad: is sun evil?
13:31:12 <MegaMonad> CosmicRay: Btw, i think he is evil evil evil.
13:31:21 <CosmicRay> MegaMonad: do you like sun?
13:31:27 <MegaMonad> CosmicRay: I dislike their mathematical apporach .. Nothing against you without having to serve in the sun came up with me.
13:32:41 <ntfirewall> is there example or a tutorial on paths?
13:32:53 <CosmicRay> paths as in filenames on your system?
13:33:10 <ntfirewall> no , paths as in trees
13:33:16 <CosmicRay> ah.
13:37:09 <Darius> "Morales, human triumph, just moments from the past.  Victories don't mean a thing if they don't last"
13:37:57 <wolfman8k> http://kse3.dyndns.org:1129/ak2k/op/ogre.jpg <- what is that place and what is rms doing?
13:42:45 <earthy> somehow that doesn't really look like rms
13:43:04 <earthy> but the pic is too blurry to really tell
13:45:19 <stepcut> so, is it correct to say haskell does not have variables ?
13:45:39 <basti_> °cough°
13:45:52 <Riastradh> No, stepcut.
13:46:48 <stepcut> what would be an example of a variable in haskell ?
13:47:06 <Riastradh> \x -> x    -- x is a variable
13:47:22 <stepcut> hrm
13:48:07 <stepcut> x is called a free lambda variable in that case ?
13:48:17 <Riastradh> No, x is a bound variable in the expression '\x -> x'.
13:48:31 <Riastradh> (In just the expression 'x', though, it is free, of course.)
13:48:59 <stepcut> a free variable is one that isn't bound then?, like \x y -> x, y is a free variable ?
13:49:27 <basti_> unbound variables don't happen in reality.
13:49:37 <Riastradh> No, stepcut.  y is a bound variable in that expression.
13:49:43 <Riastradh> The lambda binds it.
13:49:52 <basti_> except for human error
13:50:01 <stepcut> hrm
13:50:28 <stepcut> So haskell has variables, but not destructive updates of variables ?
13:50:35 <Riastradh> Correct.
13:50:46 <wolfman8k> earthy: i think it's from like 9 years ago or something
13:50:47 <Riastradh> It is an unfortunately very common misconception that 'variable' implies mutability.
13:50:56 <boegel> stepcut, \x -> x+y  , y is free
13:51:14 <stepcut> Riastradh: right, I think I had that misconception 5 mins ago :)
13:51:29 <stepcut> boegel: ah! a bug indeed :)
13:51:45 <Riastradh> No, it is just a free variable.
13:51:56 <stepcut> :(
13:52:06 <Riastradh> That term could be surrounded by '\y -> ...'.
13:52:16 <stepcut> oh yeah
13:53:10 <stepcut> in 'real' lambda calculus \y x -> x + y is written \y -> \x -> x + y, or something ?
13:53:31 <Riastradh> The lambda calculus deals with concepts & semantics.  The notation used is immaterial.
13:53:41 <xerox> \y.\x.x+y
13:53:44 <xerox> i think?
13:53:44 <Riastradh> Typically, a dot is used instead of an arrow.
13:54:01 <stepcut> ah yes 
13:54:25 <Riastradh> Writing more than one variable name between the lambda and the dot is a syntactic convenience, exercised by most people discussing the lambda calculus, for nested abstractions.
13:54:48 <stepcut> ok, next topic, isn't there a paper by Simon(?) about fast IO in haskell ?
13:58:45 <shrimpx> \xyz.x+y+z is also used
14:05:35 <wolfman8k> how come haskell doesn't use the full unicode charset so that it can use the real lambda character instead of \?
14:06:34 <tuomov> it's in the spec., but implementations are lagging
14:07:08 <wolfman8k> really?
14:07:10 <Darius> I don't think it's in the spec for the language syntax.
14:07:30 <Riastradh> Haskell is required to support a full Unicode character set.  Use of the lambda character as a substitute for \, however, is not specified.
14:07:31 <tuomov> hmmm.. lambda may infact not be..
14:07:38 <tuomov> but operators are
14:07:40 <Riastradh> Haskell implementations, rather.
14:11:52 <stepcut> wolfman8k: unicode is really hard, in part, because there is no standard for passing encodings around when doing IO. For example, if I open a file on the disk, how do I know what encoding to use ?
14:12:07 * boegel is going to bed
14:12:13 <boegel> sleep tight everyone
14:12:33 <waltz> g'night
14:12:39 <wolfman8k> stepcut: operating support for encoding querying. or just make everything unicode :)
14:12:51 * stepcut hands wolfman8k a Î»
14:12:57 <wolfman8k> alright!
14:12:57 <tuomov> s/unicode/utf8/
14:13:04 <tuomov> storing data in n-bit unicode is pointless
14:13:11 <wolfman8k> not if you live in japan
14:13:12 <tuomov> not going to happen in decades
14:13:17 <Riastradh> Unicode is vastly too complicated.
14:13:27 <wolfman8k> language is too complicated
14:13:34 <stepcut> wolfman8k: there are many unicode encodings though, so even if everything is unicode, you still need to know a bunch of stuff
14:13:36 <tuomov> utf8 is quite neat
14:13:51 <stepcut> brb
14:14:15 <tuomov> unicode processing is painful with all those compositions and multiple ways to present one character/glyph/whatever
14:14:33 <wolfman8k> yeah, multiple ways to present one character sucks
14:14:38 <wolfman8k> it makes searching impossible
14:36:58 <tromp> @index min
14:36:58 <lambdabot> GHC.Base,Prelude
14:37:36 <tromp> @type min
14:37:37 <lambdabot> min :: forall a. (Ord a) => a -> a -> a
14:43:36 <exnor> mmmm, Haskell
14:43:39 <exnor> it's been a while
14:45:18 <CosmicRay> whoa
14:45:22 * CosmicRay just discovered mod_haskell
14:45:34 <CosmicRay> http://losser.st-lab.cs.uu.nl/mod_haskell/]
14:45:43 <CosmicRay> strip off that bracket :-)
15:05:52 <Calister> g'evening
15:06:01 <Calister> well rather good morning ^_^
15:06:14 <xerox> shapr, do you know Scheme?
15:06:16 <xerox> (hi)
15:06:47 <Calister> :)
15:07:03 <xerox> (just to be a bit OT) (;
15:07:27 <Calister> ^_^
15:11:13 * Calister pokes shapr to wake him up
15:11:19 <Calister> it aint THAT late yet
15:19:59 <ela> good night @all and thx for help :)
15:20:16 <xerox> night ela 
15:24:47 <xerox> is there something like sarahbot's later-tell?
15:27:36 <ibid> xerox: /msg memoserv help
15:27:47 <xerox> Right.
15:28:07 <Calister> ./ms send nick msg *i think*
15:28:13 <Calister> didnt use memoserv in ages
15:28:40 <stepcut> hehe
15:30:50 <Calister> without a regged nick memoserv is useless ;p
15:48:01 <ntfirewall> mkhuff :: [(Char,Int)] -> [(HTree,Int)]
15:48:01 <ntfirewall> mkhuff (xs) = [(Leaf x,y) | x<-xs, y<-xs]
15:48:15 <ntfirewall> can some one please tell me what am i doing wrong here
15:49:17 <ntfirewall> i am trying to map Leaf to ('w',6) to give me (Leaf 'x', 6)
15:50:19 <psi> do you mean (x,y) <- xs?
15:50:25 <ntfirewall> to give me (Leaf 'w', 6) 
15:50:38 <ntfirewall> yes
15:50:49 <ntfirewall> x being char and y being int
15:51:29 <psi> ok. you can do as i typed, then
15:51:57 <ntfirewall> like this > [Leaf (x,y) | x<-xs, y<-xs]
15:52:36 <psi> [(Leaf x, y) | (x,y) <- xs]
15:53:12 <ntfirewall> thanks :)
15:53:36 <psi> i hope it works, at least :)
15:55:19 <ntfirewall> it does
15:55:28 <ntfirewall> thanks 
15:55:39 <psi> happy to help
16:01:01 <stepcut> anyone got a good flame on why haskell is better than python ?
16:03:17 <LittleDa1> what can I do if GHC falsely claims that something that (I think) is a type isn't a type in a constraint for a typeclass?
16:03:35 <mattam> the name's more famous among computer scientists ?
16:03:47 <LittleDa1> it says to activate -fallow-undecidable-instances, but I'm not sure if I want to do taht
16:04:27 <LittleDa1> because the way I've written the code, it shoudl be decidable
16:08:48 <Janni> G'evening
16:09:01 <LittleDa1> g'evening
16:09:17 <LittleDa1> no one's going to answer me or say i haven't given enough information or say I'm an idiot?
16:09:19 <Calister> rather good morning already ^_^
16:09:31 <Calister> i cant help :x
16:09:43 <Calister> ghc and me have a hate-relationship
16:11:14 <Igloo> People are more likely to help if you give things like the code and error message
16:15:56 <monochrom> You can paste your program at http://haskell.org/hawiki/HaskellIrcPastePage before speaking.
16:16:37 <monochrom> paste your error messages too
16:45:50 <xerox> A question: what's wrong with  [[x1, x2, x3] | (x1, x2, x3) <- ([1..3], [1..3], [1..3])] ? (I tried to replace [[x1, x2, x3] | x1 <- [1..3], x2 <- [1..3], x3 <- [1..3]])
16:46:41 <Darius> Generators must be lists.
16:47:07 <xerox> bingo, i hope.
16:47:34 <xerox> but this way: [[x1, x2, x3] | [x1, x2, x3] <- [[1..3], [1..3], [1..3]]]
16:47:40 <xerox> doesn't do the same thing..
16:48:11 <Darius> There's an extension that allows you to express what I assume you are trying to express called zip comprehensions, but in this case using a zip directly seems reasonable.
16:48:24 <xerox> how?
16:48:35 <xerox> @get-definition zip
16:48:35 <lambdabot> zip = zipWith Pair
16:49:03 <Darius> In fact, if all the lists are the same you might as well just use map.
16:49:39 <Darius> xerox: @get-definition refers to the definitions that lambdabot's @eval module uses (which is an untyped lambda calculus evaluator)
16:50:01 <xerox> @get-definition zipWith
16:50:01 <lambdabot> zipWith = \f l r.if null l || null r then [] else f (head l) (head r) :
16:50:01 <lambdabot> zipWith f (tail l) (tail r)
16:50:10 <xerox> yes i'm trying to figure out what zip does
16:50:15 <Darius> @type zip
16:50:17 <lambdabot> zip :: forall b a. [a] -> [b] -> [(a, b)]
16:50:22 <dons> zipWith :: (a->b->c) -> [a]->[b]->[c]
16:50:22 <dons> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:50:22 <dons> zipWith _ _      _      = []
16:51:00 <dons> zip :: [a] -> [b] -> [(a,b)]
16:51:00 <dons> zip (a:as) (b:bs) = (a,b) : zip as bs
16:51:00 <dons> zip _      _      = []
16:51:29 <Darius> Anyways, if all the lists are the same, you can just do: 'map (\x -> (x,x,x)) list' if there are three different lists you can use zipWith3 (\x y z -> (x,y,z)) l1 l2 l3
16:53:51 <xerox> mmmh
16:54:06 <xerox> i want to generate all the possible combinations
16:56:39 <Darius> Okay. Then your original solution was fine, except you probably would want triples and not three element lists.
16:57:15 <xerox> I just tought there was a more elegant solution, thank you :)
17:01:04 <Darius> It's hard to imagine a solution more elegant than [(x,y,z) | x <- [1..3], y <- [1..3], z <- [1..3]], though if you really did want three element lists sequence (replicate 3 [1..3]) should do it.
17:09:15 <Janni> xerox: There is another solution. If you have a look at ftp.rochel.dyndns.org/pub/JanniLib.hs and use the function "combine", then "combine (replicate 3 [1,2,3])" is what you'd like.
17:12:18 <Janni> BTW, this server is only online as long as I am...
17:15:15 <Darius> What's the definition of combine?
17:19:48 <Janni> Sorry, err combineBy (:)
17:20:23 <Janni> combine :: [[a]] -> [[a]]
17:20:29 <Janni> combineBy :: (a -> [a] -> [a]) -> [[a]] -> [[a]]
17:20:33 <Janni> combineBy f [] = []
17:20:36 <Janni> combineBy f [xs] = [ [x] | x <- xs ]
17:20:39 <Janni> combineBy f (xs:xss) = [ f x xs | x <- xs, xs <- combineBy f xss ]
17:22:21 <Janni> I don't think it's too easy to understand. If you try some examples it's not too hard either...
17:23:47 <Darius> @type let g f (xs:xss) -> do x <- xs; xs' <- g f xss;return $ f x xs in g
17:23:48 <lambdabot> bzzt
17:24:02 <Darius> @type let g f (xs:xss) -> do x <- xs; xs' <- g f xss;return $ f x xs' in g
17:24:03 <lambdabot> bzzt
17:24:07 <monochrom> Use { }'s
17:24:28 <Darius> @type let g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g
17:24:29 <lambdabot> let g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g :: forall
17:24:29 <lambdabot> t
17:24:29 <lambdabot> 									      m
17:24:29 <lambdabot> 									      a.
17:24:29 <lambdabot> 								       (Monad m) =>
17:24:29 <Calister> g'nite all
17:24:30 <lambdabot> 								       (t -> a -> a) -> [m t] -> m a
17:26:42 <Janni> Darius: Oh, that's neat. Thx.
17:27:20 * Janni is searching his little JanniLib for possible generalisations by using monads instead of lists...
17:28:57 <Darius> @type let g f [] = return [];g f [xs] = liftM (:[]) xs;g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g
17:28:58 <lambdabot> bzzt
17:29:13 <Darius> @type let g f [] = Control.Monad.mzero;g f [xs] = liftM (:[]) xs;g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g
17:29:15 <lambdabot> bzzt
17:30:02 <Darius> @index mzero
17:30:03 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
17:30:03 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
17:30:03 <lambdabot> State,Control.Monad.Writer,Monad
17:30:25 <Darius> @type let g f [] = Control.Monad.mzero;g f [xs] = Control.Monad.liftM (:[]) xs;g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g
17:30:27 <lambdabot> let g f [] = Control.Monad.mzero;g f [xs] = Control.Monad.liftM (:[]) xs
17:30:27 <lambdabot> g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in g :: forall
17:30:27 <lambdabot> a1
17:30:27 <lambdabot> 																		   m.
17:30:27 <lambdabot> 																	    (Control.Monad.MonadPlus m) =>
17:30:28 <lambdabot> 																	    (a1
17:30:30 <lambdabot> 																	     -> [a1]
17:30:32 <lambdabot> 																		-> [a1])
17:30:34 <lambdabot> 																	    -> [m a1]
17:31:44 <Darius> @type let g f [] = Control.Monad.mzero;g f [xs] = Control.Monad.liftM (:[]) xs;g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in \f -> g f []
17:31:45 <lambdabot> let g f [] = Control.Monad.mzero;g f [xs] = Control.Monad.liftM (:[]) xs
17:31:45 <lambdabot> g f (xs:xss) = do x <- xs; xs' <- g f xss;return $ f x xs' in \f -> g f
17:31:45 <lambdabot> [] :: forall a1
17:31:45 <lambdabot> 																			      m.
17:31:45 <lambdabot> 																		       (Control.Monad.MonadPlus m) =>
17:31:46 <lambdabot> 																		       (a1
17:31:48 <lambdabot> 																			-> [a1]
17:31:50 <lambdabot> 																			   -> [a1])
17:31:52 <lambdabot> 																		       -> m [a1]
17:36:21 <LittleDa1> I pasted the code for my the problem that I talked about an hour ago at http://haskell.org/hawiki/HaskellIrcPastePage
17:36:36 <LittleDa1> could anyone decipher the problem for me?
17:36:42 <LittleDa1> (the stuff after the comment isn't mine)
17:36:47 <Janni> Darius: That's a bit too neat for me, but thanks ;)
17:38:31 <Darius> The correspondence is simple, [] = mzero [x] = return x [f x ys| x <- xs,y <- ys] = do x <- xs;y <- ys;return $ f x y a++b = a `mplus` b
17:38:38 <Janni> LittleDa1: I don't know, what your problem was, but "tuple4 (Four a b c d) = d
17:38:43 <Janni> +is wrong.
17:38:57 <Janni> tuple4 (Four a b c d) = Just d    is right
17:39:14 <LittleDa1> what? when did I do anything like that?
17:39:28 <LittleDa1> my problem was that the compiler gave an error message that made no sense
17:39:30 <monochrom> Janni is looking at the bottom
17:39:32 <Janni> Sorry, wrong place...
17:39:38 <monochrom> where should we look?
17:39:48 <monochrom> the top one?
17:39:56 <LittleDa1> for my problem?
17:39:59 <monochrom> yes
17:40:02 <stepcut> LittleDa1: the one with the HCons ? Is that yours 
17:40:03 <stepcut> ?
17:40:06 <LittleDa1> yeah
17:40:17 <stepcut> did you try -fallow-undecidable-instances
17:40:18 <LittleDa1> except I didn't actually use the HList library, just HCons
17:40:39 <LittleDa1> shoudl I do that? I mean, shouldn't it be decidable?
17:41:10 <LittleDa1> I think I'm doing something wrong that's making it undecidable when it really shoudl be decidable
17:41:52 <stepcut> LittleDa1: Dunno, I could not figure out how to work around it other than using the flag
17:42:19 <stepcut> But then again I did have "Non-type variables in constraint" as the error says...
17:42:27 <Janni> Darius: May I use your definition of combineBy in my FAMOUS JanniLib? (It might be distributed to other persons from time to time
17:42:34 <stepcut> LittleDa1: if you figure it out, I would like to know 
17:42:40 <stepcut> brb
17:42:47 <Darius> Deciding whether something is decidable is undecidable.  GHC makes a conservative approximation for type classes.  If any of the heads are "complex" (i.e. of a form other than 'C a') it requires undecidable instances.
17:42:49 <LittleDa1> ok
17:43:14 <LittleDa1> oh
17:43:16 <Darius> Janni: Sure.
17:43:20 <LittleDa1> but isn't it decidable?
17:43:20 <monochrom> I have a bad feeling about all those datatypes you define.  I have a feeling some of them should be one datatype, and there should be no need for your typeclass.
17:43:48 <LittleDa1> well, I'm trying to use static typing in a concatenative language (ie forth-style)
17:43:54 <Darius> LittleDa1: "decidable" as in it will always terminate?
17:44:22 <LittleDa1> and if I have it be one datatype, the types of stuff won't be known until runtime
17:44:32 <LittleDa1> defeating the whole pupose
17:44:42 <LittleDa1> Darius: oh, I wasn't thinking in those terms
17:45:48 <LittleDa1> yeah, now it works
17:45:50 <LittleDa1> thanks
17:46:18 <LittleDa1> monochrom: also, I'm trying to steal Haskell's type system in the process
17:46:58 <monochrom> I think it will win an obfuscation contest.
17:47:34 <LittleDa1> that would be cool
17:48:50 <Darius> monochrom: Just switch the heads with the contexts and you have Prolog.
17:48:58 <monochrom> You can compete with http://www.cs.utoronto.ca/~trebla/humour/Nightmare.java
17:49:52 <LittleDa1> monochrom: that's cool
17:50:18 <LittleDa1> The thing is, I don't know how to express what I want to in a way that's not obfuscated
17:51:30 <monochrom> data H a = HNil | HCons a (H a)
17:51:41 <LittleDa1> but that's not heterogeneous
17:51:45 <LittleDa1> and it defeats the purpose
17:51:58 <LittleDa1> have you looked at HLists?
17:52:25 <monochrom> where is HLists?
17:52:59 <LittleDa1> I'll find it
17:53:00 <dons> google... ;)
17:53:07 <arjanb> http://homepages.cwi.nl/~ralf/HList/
17:53:19 <LittleDa1> there was an LTU thing about it not long ago
17:53:40 <LittleDa1> acutally it was about how HLists can be used to make an object system in Haskell
17:53:42 <Darius> monochrom: Exploiting the commutativity of sums, eh. (re Java)
17:54:29 <monochrom> no, exploiting exception handling as a syntax for pattern matching.
17:54:31 <Darius> @type Control.Monad.Error.catchError
17:54:32 <lambdabot> Control.Monad.Error.catchError :: forall m e a.
17:54:32 <lambdabot> 				  (Control.Monad.Error.MonadError e m) =>
17:54:32 <lambdabot> 				  m a -> (e -> m a) -> m a
17:55:16 <monochrom> try { x; } catch (Y y) { ... }  ~~~  case x of Y y -> ...
17:57:01 <monochrom> Does HList require -fallow-undecidable-instances ?
17:57:11 <LittleDa1> I think so
17:57:23 <LittleDa1> but the paper didn't mention that (or maybe it did, I just missed it)
17:59:14 <LittleDa1> so what cases would it be undecidable in?
18:00:29 <Darius> Undecidable instances essentially means that the type checker might not terminate when attempting to satisfy type class constraints.
18:00:43 <LittleDa1> but are there any known cases where it won't terminate?
18:00:53 <Darius> HList?
18:01:05 <LittleDa1> that terminates, AFAIK
18:01:20 <LittleDa1> I mean when do we positively know that it will not terminate
18:02:25 <Darius> It likely does terminate in all cases.  The compiler requiring -fallow-undecidable-instances doesn't mean that context reduction may not terminate in some case, it just means the compiler can't prove that it won't.
18:02:58 <LittleDa1> oh
18:03:17 <Darius> E.g. if you wrote quicksort at the type-level it would always terminate, but the compiler wouldn't be able to prove it.
18:04:49 <LittleDa1> that would win the haskell obfuscation contest
18:05:35 <dons> possibly. it's cerrtainly fun that you have to run such programs with ghci :t
18:06:00 <Darius> LittleDa1:  Actually it could be pretty clear.
18:06:19 <LittleDa1> oh yeah, that's the halting problem
18:10:15 <dons> here's a qs on the type level: http://www.cse.unsw.edu.au/~dons/qs.transcript
18:10:27 <dons> it was written by Roman Leshchinskiy
18:10:59 <dons> based on ideas in http://citeseer.nj.nec.com/hallgren00fun.html
18:11:37 <dons> it's quite understandable, once you get  the general idea, I think
18:12:28 <Darius> dons: It's quite understandable if you know Prolog.
18:12:42 <dons> yeah. that's true.
18:13:14 <dons> and a lot like isabelle/hol or twelf, too
18:13:41 <LittleDa1> well, my code isn't understandable even if you know prolog, despite it's use of typeclasses for a lot :)
18:13:53 <dons> now, writing say, tetris, on the type level -- that might win the contest..
18:14:48 <stepcut> hehe
18:15:15 <dons> sorry, Roman Lechtchinsky
18:17:00 <stepcut> monochrom: HList does not require -fallow-undecidable-instances, but some programs that use HList do
18:34:20 <eitherPichaLAPA> hi
18:35:26 <eitherPichaLAPA> hello
18:35:34 <Riastradh> Hi.
18:36:10 <eitherPichaLAPA> what is a high order cata?
18:36:28 <Riastradh> Cata?
18:36:49 <eitherPichaLAPA> catamorfism
18:36:59 <eitherPichaLAPA> hm
18:37:00 <eitherPichaLAPA> function
18:37:02 <Riastradh> Do you know what a catamorphism is?
18:37:05 <eitherPichaLAPA> what is a high order function?
18:37:29 <eitherPichaLAPA> yes
18:38:09 <Riastradh> I'm just curious: why do you ask?
18:38:58 <eitherPichaLAPA> because I need to know for a project
18:39:51 <Riastradh> For a homework project?
18:40:00 <eitherPichaLAPA> yes
18:42:04 <Riastradh> You didn't go over in class what higher-order functions are, though?
18:42:25 <eitherPichaLAPA> I don't remember!
18:42:46 <Riastradh> You don't remember what you went over in class?
18:43:19 <eitherPichaLAPA> I don't remember what is a higer-order func
18:43:40 <eitherPichaLAPA> is a point free func?
18:44:18 <Pseudonym> @foldoc higher-order function
18:44:20 <lambdabot> No match for "higher-order".
18:44:20 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP
18:44:20 <lambdabot> 03)"
18:44:20 <lambdabot> function
18:44:21 <lambdabot>      
18:44:23 <lambdabot>         1. <mathematics> (Or "map", "mapping") If D and C are sets
18:44:25 <lambdabot>         (the domain and codomain) then a function f from D to C,
18:44:27 <Pseudonym> Errr...
18:44:27 <lambdabot>         normally written "f : D -> C" is a subset of D x C such that:
18:44:29 <lambdabot> [25 @more lines]
18:44:31 <Pseudonym> @foldoc "higher-order function"
18:44:33 <lambdabot> *** "higherorder function" foldoc "The Free On-line Dictionary of Computing
18:44:35 <lambdabot> (27 SEP 03)"
18:44:37 <lambdabot> higher-order function
18:44:39 <lambdabot>      
18:44:41 <lambdabot>         (HOF) A function that can take one or more functions as
18:44:43 <lambdabot>         argument and/or return a function as its value.  E.g. map in
18:44:44 <Pseudonym> Ah, there we go.
18:44:45 <lambdabot>         (map f l) which returns the list of results of applying
18:44:47 <lambdabot>         function f to each of the elements of list l.  See also
18:44:49 <lambdabot> [3 @more lines]
18:44:55 <Pseudonym> @more
18:44:56 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
18:45:13 <eitherPichaLAPA> @1+1
18:45:13 <lambdabot> Sorry, I don't know the command "1+1", try "lambdabot: @listcommands"
18:45:32 <eitherPichaLAPA> @listcommands
18:45:32 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
18:45:32 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
18:45:32 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
18:45:32 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
18:45:32 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
18:45:34 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
18:45:36 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
18:45:38 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
18:45:40 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
18:45:47 <eitherPichaLAPA> @vera
18:45:57 <Pseudonym> eitherPichaLAPA: The last line is actually "See also {curried function}"
18:46:01 * Pseudonym shrugs
18:46:08 <Pseudonym> Did that answer your question, anyway?
18:46:08 <eitherPichaLAPA> thanks
18:46:17 <eitherPichaLAPA> yes
18:46:22 <eitherPichaLAPA> i remember now
18:47:07 <Darius> You know what a catamorphism is but you didn't remember what a higher order function was?
18:47:22 <eitherPichaLAPA> yes
18:48:40 <eitherPichaLAPA> foldr is a higher-order catamorphism?
18:49:17 <Pseudonym> @wn katamorphism
18:49:18 <lambdabot> *** "katamorphism" wn "WordNet (r) 2.0"
18:49:18 <lambdabot> katamorphism
18:49:18 <lambdabot>      n : metamorphism that occurs at or near the earth's surface;
18:49:18 <lambdabot>          breaks down complex minerals into simpler ones [ant: {anamorphism
18:49:19 <lambdabot> ]
18:49:23 <Pseudonym> Bet you didn't know THAT.
18:49:42 <Darius> @wn zygomorphism
18:49:43 <lambdabot> No match for "zygomorphism".
18:50:23 <eitherPichaLAPA> foldr is a higher-order catamorphism??
18:51:03 <Pseudonym> Aren't all catamorphisms higher-order?
18:51:41 <eitherPichaLAPA> but
18:52:04 <Riastradh> Pseudonym, would you consider 'sum' a catamorphism?  (It is, after all, just 'foldr (+) 0'.)
18:52:17 <Darius> Pseudonym: No.
18:52:28 <Darius> E.g. cataBool
18:52:50 <eitherPichaLAPA> my teacher asks specifically to do a higher order cata!
18:53:01 <Pseudonym> No, I meant the catamorphism pattern.
18:53:09 <Pseudonym> I see what you mean.
18:53:18 <Pseudonym> Personally, I find this terminology next to useless.
18:53:28 <Darius> There are two different things I can think of that might be higher order catamorphisms.
18:56:54 <eitherPichaLAPA> that are..
18:59:41 <Darius> Catamorphisms over exponential data structures or catamorphisms that return higher order functions.
19:00:39 * shrimpx sees "catamorphism" and quickly changes the channel
19:00:45 <monochrom> foldr (.) id [f, f, f, ...]
19:01:00 <Darius> mconcat [f, f, f, ...]
19:01:38 <Darius> and foldl would be better in that case.
19:01:49 <Darius> Well maybe.
19:02:08 <monochrom> foldr is the catamorphism for cons lists
19:02:20 <monochrom> foldl is the catamorphism for snoc lists.
19:02:23 <Darius> I know, but still pragmatics say foldl.
19:02:40 <monochrom> pragmatics ignore category theory.
19:03:27 <Darius> The only way an infinite composition of identical functions can terminate is if it's the constant function (I believe).
19:03:51 <monochrom> By ... I do not mean infinite list.
19:03:58 <Darius> So unless you want to support that case, foldl behaves better and (.) is associative.
19:04:57 <Darius> monochrom: I was saying if it were, if it isn't, because (.) is associative foldl seems to be a better choice.
19:05:20 <Pseudonym> monochrom: I dare you to locate one category theory text that contains the term "snoc lists".
19:05:45 <Darius> Pseudonym:  What do you consider a "category theory text" 'cause I may be able to do that.
19:06:03 <Pseudonym> Darius: I mean a book (e-books are permitted) primarily on category theory.
19:06:11 <CosmicRay> MegaMonad: snoc list?
19:06:15 <Pseudonym> It may, of course, be on the application of category theory to X.
19:06:17 <MegaMonad> CosmicRay: Ski: well in that list as an api, and the result list based on the trams.
19:07:04 <monochrom> whatever
19:07:42 <Pseudonym> BTW, there's no reason why you couldn't study programming language pragmatics categorically.
19:08:10 <Pseudonym> And there's probably a PhD waiting for the first person who tries it.
19:11:37 <monochrom> A catamorphism that is a function was sought.  One was given.  What is the matter with pragmatics, "better" (by what metric, by the way?), possible phd topic?
19:11:54 <Darius> Well, tail recursion is explored categorically in http://www-staff.it.uts.edu.au/~cbj/Publications/loops.html.
19:12:32 <Darius> How about better in space usage?
19:12:45 <monochrom> How about better in relevance?
19:17:14 <np_hard> snoc
19:30:10 <Pseudonym> This is probably very rude, because he knows mre than I do, but I find Erik Meijer mildly annoying at times.
19:31:03 * np_hard doesn't know who Erik Meijer is
19:31:16 <Pseudonym> He's one of the "bananas, lenses and barbed wire" guys.,
19:35:10 <Darius> Pseudonym: What provoked that remark?
19:37:00 <Pseudonym> Oh, the question about catamorphisms.
19:37:19 <Pseudonym> It's almost 15 years later and I _still_ don't know what the point is.
19:37:53 <Pseudonym> I did find this blog entry particularly annoying:
19:37:55 <Pseudonym> http://blogs.gotdotnet.com/emeijer/commentview.aspx/30391acc-49e2-4365-ad1d-2d287ef64460
19:38:29 <Pseudonym> You take the obvious way to represent codata in an OO language and say "but it's really functional programming in disguise!"
19:39:20 <Pseudonym> Coming soon to a compiler near you: Point-free C#.
19:39:33 * Pseudonym shudders
19:40:08 <monochrom> The best imperative programs are written in functional programming.
19:40:22 <Pseudonym> I'd disagree with that.
19:40:31 <Pseudonym> As a generalisation, anyway.
19:40:36 <Pseudonym> Some of the best are.
19:40:38 <monochrom> The best functional programs are written in imperative programming.
19:41:08 <Pseudonym> Most of the best imperative programs are impure.
19:41:20 <CosmicRay> monochrom: what does that mean?
19:41:26 <CosmicRay> "written in imperative programming"
19:41:36 <CosmicRay> isn't that an oxymoron?
19:41:41 <monochrom> That's an illusion.  x:=x+1 is a function from pre-state to post-state.
19:42:06 <CosmicRay> that's a modification to a memory address
19:42:22 <CosmicRay> in my old x86 assembler terms, MOV has no return value
19:42:27 <CosmicRay> it has only a side effect
19:42:58 <CosmicRay> at best, in C, you could claim it's the identity function with the side effect of modifying a memory address, imho
19:43:20 <monochrom> MOV AX,BX is a function from the machine state snapshot before to the machine state snapshot after.
19:43:34 <Riastradh> Pseudonym, aaaargh, why did you make me waste my time reading that garbage?
19:43:41 <Pseudonym> Ah, so what you're also saying is that the _worst_ imperative programs are written in functional programming.
19:43:44 <np_hard> hmm
19:43:45 <np_hard> there is a good paper
19:43:49 <Pseudonym> Riastradh: I did not hold an arrow to your head.
19:43:50 <np_hard> "The Laws of Programming"
19:44:08 <CosmicRay> monochrom: I think that is quite a stretch
19:44:19 <np_hard> http://portal.acm.org/citation.cfm?id=27651.27653
19:44:23 <np_hard> tony hoare et al
19:44:26 <Riastradh> Pseudonym, bah, it's a well-known fact that any URL posted to an IRC channel must be read by anyone present.
19:44:34 <CosmicRay> monochrom: and of course has the same problem as the notion that IO is a function from world to world
19:44:39 <lament> http://www.penisland.net
19:44:49 <CosmicRay> specifically that multiple copies cannot exist, etc.
19:44:55 <Pseudonym> lament: That's a real site?
19:45:10 <Riastradh> ...to a reasonable extent.
19:45:27 <lament> Pseudonym: Obviously you don't have to ask me, since you have to go there anyway
19:45:38 * Pseudonym is at w*rk
19:45:45 <Pseudonym> No way I'm going there.
19:45:45 <lament> Oh. Yeah, it's work-safe :)
19:46:06 * Pseudonym tries it in a text browser first
19:46:49 <lament> you don't trust me :(
19:46:52 <monochrom> If all your functions are of the same time S->S and all you can do is compose them (the ; in most imperative languages), there is no issue of multiple copies.
19:47:22 <Pseudonym> lament: No.  Sorry.
19:47:25 <lament> :(
19:47:27 <Pseudonym> What am I saying, no, I'm not sorry.
19:47:40 <monochrom> s/time/type/
19:47:46 * Pseudonym apologises for the poor grammar in that sentence, but what can you do
19:48:35 <lament> Imperative programmers are just stuck inside a monad
19:48:54 <Pseudonym> Actually, they're technically stuck in a Kleisli triple, not a monad as such.
19:49:04 <Pseudonym> In 1-categories the distinction isn't important.
19:49:23 <Pseudonym> In fact, I think in 1-categories the distinction doesn't exist.
19:49:55 * Riastradh really ought to read some of the introductory category theory material Pseudonym et al. pointed him to a while ago.
19:50:03 * Riastradh has been forgetting about it repeatedly.
19:50:07 <Darius> What's this?
19:51:06 <Pseudonym> I did?
19:51:35 <Riastradh> I believe you did.  This was many months ago.
19:51:48 <Pseudonym> Actually, I since found this:
19:51:49 <Pseudonym> http://www.maths.gla.ac.uk/~tl/ct/
19:52:52 <Pseudonym> Haven't worked through it yet, but it looks better than previously found material.
19:59:16 <Pseudonym> And it's in bite-sized chunks, which helps.
20:01:28 <monochrom> It has the topics I care and skips those I don't.
20:02:28 <Pseudonym> Oh, this also looks good:
20:02:32 <Pseudonym> http://www.maths.gla.ac.uk/~tl/categories/
20:02:45 <Pseudonym> The paper on the Yoneda Lemma is the best I've seen so far.
20:04:21 <segphault> Yoneda Lemma... sounds familiar. functor stuff?
20:07:06 * segphault glances at the paper
20:07:16 <Darius> Pseudonym: Have you read Daniele Turi's lecture notes?
20:09:46 * Darius really likes the explanation of Yoneda in http://www.dcs.ed.ac.uk/home/dt/CT/
20:10:11 <Pseudonym> Darius: No, but I've bookmarked it.
20:10:18 <Pseudonym> I have read the Saunders Mac Lane book.
20:10:44 <Pseudonym> Unfortunately I didn't know enough topology to grok some of it.
20:10:58 <Darius> Yes.  That's one of my problems.
20:11:53 <Pseudonym> One other thing that gets me, BTW.
20:12:23 <Pseudonym> People use underscore notation to describe functions where arguments need to be filled in.
20:12:29 <Pseudonym> Why don't they just use lambda notation?
20:13:08 <Pseudonym> Oh, I _have_ read these lecture notes.
20:13:08 <lament> yay fill in the box
20:13:12 <Pseudonym> Long time ago.
20:13:17 <lament> i did that in first grade!
20:13:27 <Pseudonym> Oh, you think this is bad?  You should read a a quantum field theory textbook.
20:13:29 <lament> [ ]  + 2 = 3
20:13:36 <Pseudonym> They play really fast and loose with the notation.
20:14:05 <Pseudonym> I find myself thinking "and these are geeks who wrote this?"
20:14:10 * monochrom modifies lament's exercise subtly
20:14:20 <monochrom> ([ ] + 2 = 3) ==> false
20:14:49 <Darius> Pseudonym: I have read papers that use a lambda notation.  Most of the time, the (-) notation isn't a problem (usually because there's only one (-)), but there have been a few times when its been ambiguous to me.
20:15:13 <Darius> And when they get to lettering their dashes, I start thinking just use lambda notation too.
20:15:26 <Pseudonym> Yes, true.
20:15:40 <Pseudonym> C[_,_] is where it starts getting unwieldy.
20:19:43 <jesse99> can someone tell me what "data Sheep = Sheep {name::String, mother::Maybe Sheep}" means? I cant find it in my book
20:19:59 <Pseudonym> It's a record definition.
20:20:08 <Darius> Anyways, night.
20:20:11 <Pseudonym> Night.
20:20:47 <Pseudonym> http://haskell.org/onlinereport/exps.html#sect3.15
20:20:49 <jesse99> ahh, my book just says see the haskell 98 report
20:20:54 <Pseudonym> :-)
20:20:59 <jesse99> thanks Pseudonym
20:21:11 <monochrom> Sheep has two fields, name and mother.
20:21:12 <Pseudonym> No problem.
20:38:44 <sjanssen> dons: have you ever tried making Yi with "make -j 2" ?
20:42:55 <dons> nope. how's it go?
20:43:56 <dons> doesn't work.
20:43:58 <sjanssen> it fails making Yi.o
20:44:05 <dons> dependencies get fouled up.
20:44:41 <dons> yep. I'll have a look.
20:44:59 <sjanssen> great, thought you should know
20:50:53 <jesse99> so, i'm getting a "Inferred type is not general enough" error where the expected type is "a -> b -> c" and the inferred type is "a -> a -> a"
20:51:24 <jesse99> why wouldnt a more specialized type match the more general one?
20:52:05 <Pseudonym> http://www.haskell.org/complex/why_does_haskell_matter.html
20:52:10 <Pseudonym> Quote from that:
20:52:25 <Pseudonym> "There is a paper by Paul Graham called Beating the Averages  describing his experience using Lisp, another functional language, for an upstart company."
20:52:52 <Pseudonym> I realise that English isn't Sebastian's first language, but it's still funny.
20:54:01 <monochrom> Oh English is hardly the first language of anyone's.
20:54:21 <SyntaxNinja> jesse99: what's the context?
20:54:28 <SyntaxNinja> a type class instance or something?
20:54:37 <jesse99> no, it's really simple
20:54:38 <jesse99> foo :: a -> a -> a
20:54:38 <jesse99> foo x y = x + y
20:54:39 <monochrom> a quarter of the world population has Chinese as first language.  I think no other language beats that.
20:54:44 <jesse99> and I call it like foo 2 4
20:54:59 <jesse99> well, thats a simpler case that fails similarlarly
20:54:59 <Pseudonym> Yup.
20:55:34 <monochrom> Not all types have +
20:55:43 <monochrom> True + False = ?
20:55:56 <jesse99> well, i'm calling it with ints
20:56:09 <SyntaxNinja> jesse99: the function's type is not as general as you're claiming it is. a -> a -> a is too general, when in reality the type is:
20:56:13 <SyntaxNinja> @type (+)
20:56:14 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
20:56:20 <jesse99> ah,, i see
20:56:20 <SyntaxNinja> meaning that a must be a num.
20:56:26 <SyntaxNinja> but that sounds different from your error above
20:56:35 <monochrom> Not very useful telling me you use ints.  Tell the computer.
20:56:40 <SyntaxNinja> monochrom: heh
20:56:44 <Nioate> your type declaration overrides whatever information might be inferred from the use of the function
20:56:45 <monochrom> Write foo :: Int -> Int -> Int
20:56:48 <SyntaxNinja> "Talk to the type system, man."
20:56:54 <monochrom> that's what you should tell the computer
20:57:05 <monochrom> You can tell me, but all you get is sympathy.
20:57:09 <jesse99> well, i'm just fooling around and I didnt want to overly constrain the function
20:57:20 <monochrom> You can't sell my sympathy for cash!
20:57:40 <SyntaxNinja> that's the most general type you can give it (Num a) => a -> a -> a, anything more general is too general.
20:57:47 <monochrom> foo :: (Num a) => a -> a -> a  is the most general you can get.
20:58:05 <SyntaxNinja> monochrom: but computers are so cold.
20:58:16 <monochrom> computers can be sold for cash
20:58:27 <monochrom> once you demonstrate it working
20:58:28 <Nioate> is there some secret reason "=>" is the symbol used there
20:58:37 <monochrom> by a program that compiles
20:58:50 <monochrom> It looks like "implies"
20:58:51 <Nioate> or I guess a better question is "how should I read '=>'"
20:59:30 <monochrom> "x => y" is usually read by most people (not just programmers) as: assume x, conclude y
21:00:03 <Nioate> I see
21:00:09 <Pseudonym> It's also a stronger-looking ->
21:00:23 <SyntaxNinja> MegaMonad: how do you read the "=>" symbol?
21:00:29 <MegaMonad> SyntaxNinja: But it's older code that's easy to print the value out of me i have a symbol in the state machine practice proggy a machine to try to dynamically loaded base package will be news, it will read it yet.
21:00:39 * SyntaxNinja nods sagely.
21:01:07 <Pseudonym> That suggests that (Num a) is _like_ a function argument, only it's not quite.
21:01:17 <Pseudonym> Internally, it is, kind of.
21:06:49 <Nioate> yay
21:17:46 <dons> sjanssen: try that. seems to work quite nicely with -j 4 on a 4 cpu server tested on
21:18:03 <dons> only a couple of little magic deps were missing
21:18:59 <sjanssen> yep, it works
21:19:02 <sjanssen> that was fast
21:21:45 <dons> just a 2 line patch
21:31:55 <Pseudonym> I've found that make -j (n+1) on an n-CPU machine is best.
21:32:15 <Pseudonym> That way, there's some work going on when some other compile is waiting on I/O.
21:32:43 <Pseudonym> Possibly this is more relevant for multi-pass compilers which dump state between passes.
21:33:22 <vegai> MegaMonad: good morning! How are the nuclear weapons working out for you?
21:33:27 <MegaMonad> vegai: What does it save me the first working version of punkbuster to your superior weapons.
21:33:47 <Riastradh> MegaMonad, I endofunctorialize your pseudomorphic categorical euphemisms!
21:33:53 <MegaMonad> Riastradh: All sorts of wonderful euphemisms for urination.  Hadn't heard that there were some parts of the categorical definition of my approach...
21:34:00 <Pseudonym> MegaMonad: I hear you're building a Illudium Q-36 Explosive Space Modulator.
21:34:06 <MegaMonad> Pseudonym: But i'm the same building with an explosive.
21:34:24 <Pseudonym> LOL!
21:34:32 <Pseudonym> A categorical approach for euphemism!
21:34:34 * Riastradh falls off of his couch.
21:34:57 * Pseudonym hurries off and patents the word "euphemorphism" before anyone else can
21:35:24 <dons> j n+1 for n = 4 was a bit faster than -j n
21:35:43 <Pseudonym> You probabably won't get any advantage for j n+2
21:37:34 <dons> hmm. still getting faster for n+2
21:37:39 <jdrake> moo
21:38:44 <SyntaxNinja> ria:you didn't like "all sorts of wonderful euphemisms for urination"?
21:39:09 <Riastradh> I fell off of my couch due to laughter, SyntaxNinja.
21:39:14 <SyntaxNinja> yeah
21:39:19 <vegai> NetBSD-2.0!
21:39:30 <Pseudonym> MegaMonad: NetBSD-2.0!
21:39:31 * SyntaxNinja deletes netbsd
21:39:36 <MegaMonad> Pseudonym: Which i think 2 to be done with 0x or 0x.
21:39:37 <SyntaxNinja> hi jdrake
21:39:47 <dons> n+3 flattened out, though
21:39:56 <Riastradh> MegaMonad, buffalo buffalo buffalo buffalo buffalo.
21:40:01 <MegaMonad> Riastradh: Buffalo buffalo buffalo.
21:40:06 <SyntaxNinja> ooh, he showed you!
21:40:07 <monochrom> You can patent a word?
21:40:16 <Riastradh> MegaMonad, buffalo buffalo buffalo buffalo buffalo!
21:40:19 <Pseudonym> MegaMonad: Can you patent a word?
21:40:24 <MegaMonad> Riastradh: Buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo.
21:40:24 <monochrom> I think you should trade-mark it instead...
21:40:30 <MegaMonad> Pseudonym: Hand me the other way around microsoft's patent, call them fixme's instead of a word.
21:40:39 <Pseudonym> Oooh, good idea!
21:40:41 <dons> ah, very wise
21:40:47 * Pseudonym patents the fixme "euphemorphism"
21:40:56 <vegai> MegaMonad: you are improving rapidly!
21:41:00 <Riastradh> MegaMonad, you speak FIXME's of wisdom!
21:41:02 <MegaMonad> vegai: This is me on a case-insensitive file systems is edit files, so... I'm always looking for an i with a definition, you have a :: data and you are improving rapidly!
21:41:08 <MegaMonad> Riastradh: Dash: don't get me some of the common wisdom is that the average attendee to get them all the way around microsoft's patent, call them fixme's instead of reader monads?
21:41:11 <vegai> MegaMonad: Ok, I'll take that back.
21:41:17 <MegaMonad> vegai: Ok, maybe it really is your trusty sidearm.  Its not perfect but its sort of like a neat idea but i don't know if you'll be able to learn elisp.
21:41:33 <Riastradh> MegaMonad: Hmmmm.  We might have problems overloading the word 'FIXME' too much.
21:41:33 <vegai> ;(
21:41:39 <MegaMonad> Riastradh: On the downside, xemacs doesn't have overloading in haskell, but all the problems of the word.
21:41:45 <vegai> oh well, I didn't care for elisp anyway
21:41:55 * Pseudonym patents the fixme "fixme".
21:42:06 <jdrake> curious: "Instance of Fractional Int required for definition of mean"  not sure what to do with this
21:42:14 * SyntaxNinja is scared of the conjunection of MegaMonad's "trusty sidearm" with vegai's ability to learn elisp.
21:42:21 <Pseudonym> MegaMonad: Is that a recursive black hole or a semi-Quine?
21:42:24 <Riastradh> MegaMonad, you're going to make me awaken the person sleeping in the next room over if you keep me laughing so hard.
21:42:30 <MegaMonad> Pseudonym: Getcolourfrompixelfromqtree is recursive in the hole is that copy on a given c program, because im suppose to write a quine in haskell.
21:42:36 <SyntaxNinja> jdrake: it's saying you're trying to divide an int, probably :)
21:42:36 <MegaMonad> Riastradh: I the next room of the list, then build ghc cvs tree of somethings down the tree at that point, we could perhaps be interesting to be laughing.
21:42:42 <SyntaxNinja> @type (/)
21:42:44 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
21:43:00 <SyntaxNinja> jdrake: and Int isn't a member of the Fractional typeclass
21:43:15 <jdrake> SyntaxNinja, I am not specifying int specifically
21:43:29 <jdrake> just trying to do this: mean l = (sum l) / (length l)
21:43:34 <Riastradh> MegaMonad, stop the insanity!  I'm about to die of excessive laughter here!
21:43:38 <SyntaxNinja> @type sum
21:43:40 <lambdabot> sum :: forall a. (Num a) => [a] -> a
21:43:41 <MegaMonad> Riastradh: You're more than fifty percent, i suspect it is really needed, only non-ccnuma hardware with sufficient insanity on the type level lambda abstraction, which as you can use any of the die.
21:43:44 <lambdabot> MegaMonad, I fear that you are replacing me in popularity.
21:43:44 <SyntaxNinja> er
21:43:47 <SyntaxNinja> @type length
21:43:48 <lambdabot> length :: forall a. [a] -> Int
21:43:58 <Riastradh> lambdabot, nyah, MegaMonad ignores you.
21:43:59 <SyntaxNinja> it's "inferring" the type "int" from your use of length.
21:44:02 <Riastradh> MegaMonad, do you ignore lambdabot?
21:44:09 <lambdabot> Damn.
21:44:17 <MegaMonad> Riastradh: Lambdabot is a good exercise for me is that you ignore lambdabot?
21:44:22 <jdrake> SyntaxNinja, what would be the best solution to this problem?
21:44:28 <SyntaxNinja> @type fromIntegral
21:44:30 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
21:44:40 <Riastradh> MegaMonad, what is a catamorphism?
21:44:40 <jdrake> pain in the ass
21:44:46 <MegaMonad> Riastradh: Magnet, n.  Something acted upon by a task and a catamorphism.
21:44:47 <Pseudonym> MegaMonad: Did you @moo today?
21:44:56 <SyntaxNinja> jdrake: or if you don't care about fractions you can use div
21:44:58 <MegaMonad> Pseudonym: Yes to nobuffering let me get my config if you are talking about doing dynloading / eval in the us in the day" when i talk to me like it's coming along anyway?  Is it a larger interop system called im2000 that's the problem to one but not with the following commands: ["eval","define","get-definition","goodbye","hello","hitchcock","jargon","join","karma","karma+","karma-","leave","listchans","listcommands","listmodules","lo
21:44:58 <MegaMonad> elude","quit","reconnect","resume.
21:44:58 <SyntaxNinja> @type div
21:45:00 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
21:45:09 <jdrake> I need fractions
21:45:09 <SyntaxNinja> we're going to need a megamonad channel if this keeps up
21:45:40 <Riastradh> OK, I'm out of here.  I'm having difficulty breathing, and I hear signs of that person stirring.
21:45:45 <Riastradh> MegaMonad: OK, I'm out of here.  I'm having difficulty breathing, and I hear signs of that person stirring.
21:45:46 <SyntaxNinja> then you have to convert the output of length.  would you rather length returned a num? I think that would be more painful
21:45:48 <SyntaxNinja> Riastradh:  l8r
21:45:51 <MegaMonad> Riastradh: Can i hear that the signs of that person stirring.
21:45:56 <Riastradh> Humph.
21:45:58 <Riastradh> (or: phew)
21:46:05 <Pseudonym> Fare well.
21:46:36 <SyntaxNinja> jdrake: you could always define your own "myLength" function that returns a Num :)
21:46:50 <SyntaxNinja> @type (fromIntegral . length)
21:46:51 <lambdabot> (fromIntegral . length) :: forall b a. (Num b) => [a] -> b
21:47:10 <SyntaxNinja> I think @type is my favorite lambdabot feature
21:47:22 <Pseudonym> MegaMonad: Is @type your favourite lambdabot feature?
21:47:28 <MegaMonad> Pseudonym: Lambdabot has a feature to make lambdabot do that sometimes.
21:47:49 <Pseudonym> Wouldn't be much of a feature if it didn't.
21:47:56 <SyntaxNinja> now he's spewing tautologies. 
21:48:05 <SyntaxNinja> MegaMonad: please avoid spewing tautologies.
21:48:11 <MegaMonad> SyntaxNinja: Now he's spewing tautologies.
21:48:13 <Pseudonym> MegaMonad: Is it a bug or a feature?
21:48:18 <MegaMonad> Pseudonym: You need a bug not a feature, not a feature.
21:48:27 <jdrake> i seem to be having trouble getting hugs to be able to assign anything 
21:48:38 <SyntaxNinja> jdrake: I should hope so! ;)  
21:48:48 <jdrake> i could swear I used it like that before
21:49:02 <SyntaxNinja> ghci lets you "let foo = bar" in the top level, but hugs doesn't
21:49:33 * SyntaxNinja saw hugs running on a "palmtop" zaurus computer today.
21:50:08 <jdrake> "Instance of Fractional Integer required for definition of mean" for mean [] = 0      any particular reason this might be?
21:50:29 <jdrake> the other relevant definitions: mean l = (sum l) / (length2 l)  and length2 = (fromIntegral . length)
21:51:53 <SyntaxNinja> nope. looks good to me. you must be having hugs problems.
21:52:01 <SyntaxNinja> did you hit 'save'? :)
21:52:08 <jdrake> yes many times
21:52:39 <SyntaxNinja> that code is correct.
21:52:42 <jdrake> ghci seems to work
21:52:44 <jdrake> hugs doesn't
21:55:38 <SyntaxNinja> I think it has something to do with how they determine the default types of the operators.
21:55:42 <SyntaxNinja> this is something I never quite understood
21:55:45 <SyntaxNinja> if you put type sigs in it'll work.
21:56:03 <SyntaxNinja> put a type in for the length2 function
21:57:20 <SyntaxNinja> or if you define length2 thusly: length2 a = fromIntegral (length a)
21:57:34 <jdrake> maybe it would be better to use ghci
21:57:54 <SyntaxNinja> hmm.
21:57:56 <SyntaxNinja> that's really strange.
21:58:09 <SyntaxNinja> length3 = fromIntegral . length
21:58:19 <SyntaxNinja> :t fromIntegral . length
21:58:19 <SyntaxNinja> fromIntegral . length :: Num a => [b] -> a
21:58:26 <SyntaxNinja> :t length3
21:58:26 <SyntaxNinja> length3 :: [a] -> Integer
21:58:35 <SyntaxNinja> does anyone grok that?
22:02:01 <SyntaxNinja> you should post about it on the Haskell mailing list :) or haskell-cafe.
22:02:40 <jdrake> my haskell book might come tomorrow
22:02:48 <SyntaxNinja> jdrake: which one did you get?
22:03:15 <jdrake> the multimedia one
22:03:23 * SyntaxNinja nods
22:03:45 <jdrake> it was the only one within acceptable price range, about 32,00$
22:05:25 <jdrake> i still haven't gotten the library it needs to work yet on my mac 
22:06:22 <SyntaxNinja> yeah, that's a bit of a PIA with the newer versions of hugs.
22:08:14 <jdrake> i can't get anything newer than feb2001 I think to work here from source, I have a binary of nov2002 I think
22:13:30 <jdrake> figures my first attempt doesn't work
22:18:35 <jdrake> stddev :: [Double] -> Double    stddev l = (map (\x -> x - (mean l)) l)    I get "Couldn't match `Double' against `[b]'" not sure exactly what is happening
22:19:11 <SyntaxNinja> well, it's saying that it expected to see a list of something, but got a single Double.
22:19:51 <jdrake> oh I see what you mean
22:20:15 <exnor> you probably want this  l = map (\x -> x - (mean l)) l
22:21:08 <SyntaxNinja> I heard a talk where the speaker claimed that experienced haskell programmers don't look at the type errors, they just look at the programs to find the error
22:21:15 <SyntaxNinja> and new haskell programmers don't understand the errors.
22:21:24 <exnor> haha
22:21:28 <exnor> that sounds about right
22:21:33 <jdrake> well they are a little different
22:21:40 <jdrake> I can usually get ocaml / sml errors
22:21:46 <dons> hmm. no I look at the type errors. usually they explain exactly what went wrong
22:21:57 <exnor> dons: pansy man.
22:22:12 * SyntaxNinja probably looks at the program first, and if that doesn't pan out really quickly, then I look at the type error
22:22:15 <dons> but I do know that new users tend to just keep modifying their programs without even looking at the position information
22:23:10 <jdrake> dons, I notice line numbers :p
22:23:17 <jdrake> stddev l = (sum (map (\x -> (square (x - (mean l)))) l)) / ((length2 l) - 1)
22:23:28 <jdrake> looks quite evil from here, too bad it doesn't work
22:23:37 <dons> I'm talking about real beginners.
22:23:39 <exnor> dear lord
22:23:49 <exnor> that looks like it can be done about 20 times nicer =P
22:24:13 <jdrake> the first thing I want to figure out is why I get 10 back from stddev [1,3,5,7,9]
22:24:23 <dons> the number of parens is a good heuristic for how bad the code is ;)
22:24:35 <exnor> dons: yeah, should always use the $ syntax ;)
22:24:45 <jdrake> dons, you don't use lisp i take it
22:24:57 <exnor> lisp isn't a real language
22:25:07 <exnor> it's just a bunch of ()'s put in some random order
22:26:38 <SyntaxNinja> I think dons' heuristic works for lisp code too ;)
22:27:21 <jdrake> I am trying to translate this into haskell: http://paste.lisp.org/display/4237
22:28:11 <exnor> jdrake: do it in steps
22:28:13 <exnor> like they have
22:28:25 <exnor> don't do it all in one function, and it'll be much easier
22:29:31 <exnor> actually, stuff that
22:29:43 <SyntaxNinja> jdrake: there's a 'let' keyword, so you can say 'let sample2 = ... in ...]
22:30:40 <exnor> blah l = sum(map (\x -> x* x) (stddev l))
22:30:48 <jdrake> exnor, that code is mine :-)
22:30:48 <SyntaxNinja> jdrake: also, there's a way to get something that looks more like that python code: let sample2 = [i * i | i <- sample1]
22:30:56 <exnor> / (blah)
22:31:03 <exnor> jdrake: good =)
22:31:10 <exnor> but it's better when I write it
22:31:36 <exnor> hmmm, yours doesn't use the stddev function though =P
22:31:38 <jdrake> exnor, I would like to see you write something nicer :-)
22:32:13 <exnor> hmmm, and if you have a square function, you can replace my lambda function
22:32:56 <jdrake> SyntaxNinja, can you explain that let sample2 
22:33:14 <exnor> blah l = (sum $ map square $ stddev l) / (length l - 1)
22:33:20 <exnor> oh, and you have to sqrt it ;)
22:33:28 <jdrake> i just remembered that :-)
22:33:54 <exnor> wow, haskell was so long ago
22:34:06 <jdrake> my code did work after all but short of the sqrt
22:34:11 <SyntaxNinja> jdrake: read it like "i times i such that i is a member of sample1"
22:34:12 <exnor> I forgot how list comprehension's work
22:34:32 <jdrake> Praise Lord Satan in his glory... : stddev l = sqrt ((sum (map (\x -> (square (x - (mean l)))) l)) / ((length2 l) - 1))
22:35:00 <exnor> yeah, that can be nicer =P
22:35:02 <jdrake> now I shall see if I can make it look nice
22:36:31 <jdrake> i usually see x:xs for the pattern in functions like length, is there a common one for just a list?
22:36:44 <jdrake> not separated 
22:37:00 <exnor> l
22:37:03 <exnor> :)
22:37:19 <jdrake> hmm, I guess that is why I chose it...
22:37:24 <exnor> yup
22:37:59 <jdrake> what is this $ syntax
22:38:13 <exnor> a ( b ) => a $ b
22:38:29 <exnor> it's like "put a ( here, and a ) at the end of this block"
22:38:34 <SyntaxNinja> jdrake: you can make it look much like your python code:
22:38:38 <dons> f $ x = f x
22:38:41 <SyntaxNinja> #wiki HaskellIrcPastePage
22:38:50 <SyntaxNinja> @wiki HaskellIrcPastePage
22:38:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:39:50 <dons> and maybe throw some 'where' into the function, to make it a bit easier to read
22:40:10 <jdrake> that code looks nice
22:40:51 * SyntaxNinja bows
22:46:16 * SyntaxNinja takes the liberty of trimming the IrcPastePage
22:48:46 <jdrake> ok, i have a nicer one now
22:49:17 <exnor> I claim SyntaxNinja's code is yucky =(
22:49:21 <exnor> way too imperitive
22:50:07 <SyntaxNinja> exnor: it's not imperitive, but that's probably not how I'd write it myself.  It's easier for newbies to learn that way, though, and they eventually learn when to use let and friends.
22:50:55 <jdrake> reload that nice page now my new version is there
22:51:33 <exnor> SyntaxNinja: ;)
22:52:40 <SyntaxNinja> jdrake: nice.
22:53:05 <SyntaxNinja> jdrake: can python's "for" thing do this: [(x,y) | x <- l1, y <- l2] (dot-product)?
22:53:42 <jdrake> i don't know for sure
22:53:46 <SyntaxNinja> jdrake: you should be able to et more generic types there, btw.
22:55:44 <Nioate> SyntaxNinja: yes
22:56:32 <Nioate> [(x,y) for x in l1 for y in l2]
22:58:32 * SyntaxNinja wonders if python got that idea from Haskell :)
22:58:40 <Nioate> that's what I understand
22:58:42 <exnor> what the...
22:58:50 <exnor> is "length2" really needed?
22:59:00 <exnor> oh ... casting it to double
22:59:01 <exnor> I see
22:59:14 <exnor> that's way dodgy =)
22:59:27 <Nioate> is there a clever way to build a finally function for MonadErrors?
22:59:29 <SyntaxNinja> cast! ha!
22:59:44 <exnor> SyntaxNinja: ;)
22:59:52 <SyntaxNinja> he didn't do something as brutish as casting, he merely coerced it
22:59:59 <exnor> uh huh...
23:00:16 <exnor> whatever you call it, it's changing one type to another =P
23:00:47 <SyntaxNinja> cast has this unsafe, run-time connotation to me.
23:06:23 <jdrake> SyntaxNinja, what more generic type would I use here?
23:06:52 <exnor> anything in the num class?
23:06:56 <exnor> that's a guess though
23:07:06 <jdrake> isn't Double in the Num class?
23:08:16 <exnor> yeah, but you should be able to structure it so it can work on any type in the num class
23:08:35 <exnor> umm... thing... poly... something... types
23:08:37 <exnor> wow
23:08:41 <exnor> it has been way to long.
23:09:10 <jdrake> my new function is ready: http://www.haskell.org/hawiki/HaskellIrcPastePage   now it stands on its own, without length2 as well
23:10:25 <SyntaxNinja> delete the type and see what type it gets
23:11:12 <jdrake> I am Floating now :-)
23:11:21 <jdrake> Is this version written fairly well?
23:11:32 <SyntaxNinja> now you can put the more generic type in for the sake of documentation
23:11:43 <exnor> hmmm
23:12:41 <SyntaxNinja> looks good to me. exnor may have a different aesthetic. 
23:13:22 <SyntaxNinja> btw:
23:13:24 <jdrake> i will listen to anyone's idea of aesthetics, as long as they are not perl programmers
23:13:25 <SyntaxNinja> @type (^)
23:13:27 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
23:13:55 <SyntaxNinja> we chased the perl programmers away long ago
23:14:23 <SyntaxNinja> apparently there's been some python programmers hiding in the woodwork stealing our ideas, though...
23:14:44 <jdrake> ok, we are down to 6 lines now (and posted)
23:15:09 <jdrake> is there a standard average function?
23:18:07 <SyntaxNinja> jdrake: the libraries are here.  Click "index" to view stuff alphabetically http://www.haskell.org/ghc/docs/latest/html/libraries/
23:18:29 <exnor> =O
23:18:36 <exnor> but perl is like... pwnage
23:18:46 <exnor> most of cat in about 12 characters
23:18:49 <exnor> can't beat that
23:19:28 <jdrake> now I need to get this program to accept a list from the command line
23:26:13 <SyntaxNinja> exnor: cat = getArgs >>= (sequence . (map readFile)) >>= (putStrLn . concat)
23:26:18 <SyntaxNinja> not bad
23:26:29 <SyntaxNinja> and not imperative at all!
23:27:57 <SyntaxNinja> cat2 = do a <- getArgs
23:27:57 <SyntaxNinja>           lines <- sequence $ map readFile a
23:27:57 <SyntaxNinja>           putStrLn $ concat line
23:29:00 * SyntaxNinja thinks cat without anything but composition is cooler than cat in 12 characters.
23:29:40 <Janni> G'morning.
23:31:52 <jdrake> http://thedailywtf.com/ShowPost.aspx?PostID=26245
23:42:05 <SyntaxNinja> @commands
23:42:05 <lambdabot> Sorry, I don't know the command "commands", try "lambdabot: @listcommands
23:42:08 <SyntaxNinja> @listcommands
23:42:09 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
23:42:09 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
23:42:09 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
23:42:09 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
23:42:09 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
23:42:09 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
23:42:11 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
23:42:13 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
23:42:15 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
23:43:41 <ex_nor> that had better have been written in haskell
23:43:48 <ex_nor> or I'd have to burn someone
23:44:19 <SyntaxNinja> @wiki LambdaBot
23:44:19 <lambdabot> http://www.haskell.org/hawiki/LambdaBot
23:44:41 <ex_nor> cool ;)
23:45:24 <Lemmih_> SyntaxNinja: It's not part of the official lambdabot yet.
23:48:16 <ex_nor> oh no, he'll turn all our matrices into scalars!
23:48:20 * ex_nor hides
23:55:18 <SyntaxNinja> 'nigh tall
23:55:20 <SyntaxNinja> MegaMonad: good night
23:55:33 <SyntaxNinja> *sigh*
23:55:41 <MegaMonad> SyntaxNinja: Mang, haskell is just too much effort.  Half the reason i want to admit he said that some day it was night, i got it.
23:58:57 <Nioate> I know how you feel MegaMonad 
