00:01:20 <Gahhh> Does the functional camp bash OOP in general ?
00:03:17 <Lemmih> I would like to think that we are above bashing but perhaps I'm deluding myself.
00:04:18 <Gahhh> ok, let me rephrase: Does the functional camp think FP > OOP, or do they think the two cannot be compared, maybe they can even be combined, etc.
00:04:36 <wli> well, I have the usual gibberish from the normal equations already
00:05:30 <jesse98> what does the ! mean in "data ParseError = ParseError !SourcePos [Message]"?
00:05:39 <wli> well, OOP has serious issues with foundations
00:05:45 <Gahhh> jesse98, strictness ?
00:05:48 <wli> apart from that I suppose it's not too big a deal
00:05:56 <wli> "just another paradigm
00:06:23 <jesse98> haskell uses that for a strictness annotation?
00:06:37 <wli> hmm, that was unexpected
00:06:46 <wli> the normal equations were not meaningless
00:07:02 <wli> it seems to mean the constant result was bad
00:07:26 <Gahhh> jesse98, yes
00:07:30 <wli> worse
00:07:34 <wli> zero doesn't work either
00:07:55 <Gahhh> wli, do you know the expected result ?
00:08:00 <wli> No.
00:08:05 <wli> But it means certain things
00:08:17 <wli> I need it to be a nonzero solution to homogeneous equations
00:08:30 <wli> and I need it to be orthogonal to a certain direction
00:08:30 <Gahhh> wli, you can download an SVD implementation in C and try that out first to see if it can really solve that system.
00:08:45 <wli> formatting headaches...
00:09:34 <wli> I was going to feed it to maple's SVD but got bogged down by formatting
00:09:55 <Itkovian> heh
00:10:06 <wli> I'm trying to fit an implicit cubic curve to some data
00:10:24 <Itkovian> wasn't that yesterday's task?
00:10:29 <wli> yes
00:10:38 <Itkovian> still no succes, eh?
00:10:38 <Gahhh> wli, I thought programs such as maple could read the data from files.
00:10:40 <wli> I did various things and the equtions cam eout as crap
00:10:46 <wli> they can read data from files
00:10:47 <Itkovian> hmm ...
00:10:50 <wli> what I got out was garbage
00:10:59 <Oeje1> Gahhh: Personally I like to bash Java.
00:11:15 <Gahhh> Oeje1, are you a java coder ?
00:11:26 <Itkovian> are those equations linear?
00:11:48 <Itkovian> Oeje1: I do most of my research for (J)VM's :-)
00:11:50 <sethk> Gahhh, I've done a lot of coding with Java, but I don't like the language at all.
00:12:08 <Gahhh> Itkovian, I think he's doing a linear combination of non-linear functions.
00:12:30 <Itkovian> ouch ... danger will robinson
00:12:54 <Gahhh> sethk, one can dislike a language just because of the comment delimiters. I was wondering about the OO paradigm in general.
00:13:09 <sethk> Gahhh, it is fatally flawed.
00:13:10 <Oeje1> Gahhh: We do many courses in Java at uni.  No real work though.
00:13:16 <Gahhh> Itkovian, not a big danger but his matrix is probably too large.
00:13:28 <wli> well
00:13:29 <sethk> Gahhh, with aspects, it is still fatally flawed, but a bit more manageable.
00:13:37 <wli> I'm expecting most of the data to just be filtered out
00:13:45 <wli> in fact I just want it to be
00:14:07 <wli> the whole reason I want SVD/etc. is so it acts as a filter
00:14:40 <Gahhh> wli, I think that is a bad idea. You will need to play with the threshold parameter.
00:14:53 <wli> what threshold parameter?
00:14:57 <Gahhh> sethk, I only heard about the aspect oriented paradigm.
00:15:02 <wli> for discarding singular values?
00:15:06 <Gahhh> wli, yes
00:15:15 <wli> well, yes, that's assumed
00:16:04 <Gahhh> wli, in my experience, it turned into a painful game of "remove this column", try this value, etc. took a long while.
00:16:24 <wli> I think I finally nailed it
00:16:38 <Gahhh> score 1 for SVD!
00:16:48 <wli> no, importing data into maple effectively
00:16:52 <Gahhh> oh
00:17:13 <wli> Gahhh: I'm expecting as much. I have a specific probability distribution I'm trying to model
00:17:29 <Itkovian> can't you use some other tool besides maple?
00:17:50 <Gahhh> Matlab or mathematica ?
00:17:55 <Itkovian> or R
00:18:00 <Gahhh> R does SVD ?
00:18:21 <Itkovian> sure it does :-)
00:18:26 <Gahhh> neato
00:18:31 <Itkovian> svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)
00:18:33 <Itkovian> :-)
00:18:47 <sethk> Gahhh, the flaw in the oo paradigm is what is referred to as "the tyranny of the primary decomposition."  Aspects attempt (with very limited success) to allow you to have a two dimensional decomposition.  Real life problems need an N dimensional decomposition, but two is a bit less bad than one.
00:18:47 <wli> I have R
00:18:48 <Itkovian> well, it says it does, I've never actually used it
00:18:48 <Gahhh> It's the same R we're talking about, right ? The statistics open-source stuff ?
00:19:22 <Itkovian> yes.
00:19:38 <Gahhh> Itkovian, cool.
00:19:47 * Itkovian has used R, just not the svd function (yet)
00:20:11 <Gahhh> Itkovian, have you used maxima or octave, etc. ?
00:20:38 * Itkovian thinks R is quite a useful tool, although he was warned by a SAS9sy) girl that there are some flaws in certain algorithm, of which he cannot recall the name (of the algorithms, not the girl) at this moment
00:20:51 <Gahhh> lol\
00:21:17 <Gahhh> I dont trust $a$$y g3rls
00:21:26 <Itkovian> I've used octave in the past ... has to brew some matlab excercises for the students and did not have a *nix version of matlab
00:21:36 <Itkovian> heh
00:21:44 <Itkovian> s/has/had/
00:21:57 <Itkovian> 'twas awful.
00:21:58 <Gahhh> sethk, what exactly is this primary decomposition ? Is it your first cut at the analysis stage ?
00:22:14 <Itkovian> those students didn't understand anything
00:22:31 <Gahhh> Itkovian, then it's a job well done. The prof never planned it that way.
00:22:37 <Itkovian> tell them to use vector-wise operations and they'd have a go at using loops. eek.
00:22:54 <Itkovian> The prof didn't give a damn how I prepared my stuff :-)
00:23:08 * Gahhh was a TA once
00:23:20 <Itkovian> did you end up with a PhD?
00:23:26 <Gahhh> no, M.S.
00:23:54 <Itkovian> so you were a TA while doing your MS?
00:23:54 <Gahhh> I wasnt overly excited by their research, and the job market was good enough.
00:23:58 <Gahhh> Yes
00:23:58 <Itkovian> ah.
00:24:00 <Itkovian> ic
00:24:16 <Gahhh> I was supposed to be an MS/PhD student. I quit right after getting the MS
00:24:17 * Itkovian has a paper to write by dec. 20th.
00:24:31 <sethk> Gahhh, the newer oo languages (everything newer than c++, although c# lets you cheat if you set a flag) have only single inheritence.  Thus your object tree has only one decomposition.  But real life problems can rarely be adequately modeled with a one dimensional tree.  Multiple inheritence problems, though, are even worse.  There are slews of papers describing all this is grusome detail, if you want the details.
00:25:21 <Gahhh> sethk, I see. Yeah I'd be interested in URL's of those papers.
00:25:52 <Gahhh> Itkovian, I hope you are 101% done by now.
00:26:09 <Itkovian> Erm no :-)
00:26:18 <wli> foundations in general are a problem though
00:26:25 <Itkovian> I knew there was something that I had to do this morning :-)
00:26:38 <sethk> Gahhh, a lot of them are ACM papers.  Do you have access?  You have to be a member, or have a library that has member access.
00:26:49 <Itkovian> I have ACM access ;-)
00:27:03 <Itkovian> so just gimme the stuff ... :-)
00:27:04 <Gahhh> sethk, I can find access, I believe
00:27:36 <sethk> Gahhh, look for a summary paper on the subject.  There are dozens of proposed solutions to the problems, but they are all hacks.
00:27:50 <Gahhh> sethk, I always found that the decision to not support multiple inheritance was rude, even though I wouldnt know how to use the feature right myself.
00:28:03 <jesse98> multiple dispatch in clos and dylan doesnt seem to be a hack
00:28:46 <sethk> Gahhh, you can't be successful with the modeling relationship inside out.  One should analyze the problem and choose the best model, not the other way around.  In the OO world everything is supposedly best modeled using the OO modeling ideas.  this is obvious nonsense, but very popular nonsense.
00:29:31 <Gahhh> sethk, it's buzzword fueled decision making. I am sure some problems are indeed best modelled by OO.
00:30:20 <sethk> Gahhh, some, yes.  but not all.  The point is still valid, reality should drive the model, not the other way around.
00:30:51 <Gahhh> sethk, no, we cannot let you do that. You definitely need all the Rational Tools suite to write your bash script, sorry.
00:30:54 <sethk> Gahhh, in fact, there are about two.  Half the textbooks use one (the banking example, which actually isn't terribly well modeled by OO) and I forget the other.
00:31:17 <sethk> Gahhh, I just got away from that!  I'll never go back.  Unless I need the money, of course.  :)
00:31:49 * Gahhh remembers seeing the device driver in OO and not being impressed at all
00:32:31 <Itkovian> money drive reality?
00:32:34 <Itkovian> *s
00:33:01 <Gahhh> Itkovian, what is your paper on ?
00:33:30 <sethk> Gahhh, most device driver development I've seen in the last couple of years is using straight C.  Which should tell you something.
00:34:19 <Gahhh> sethk, to be honest, most device drive writes are not CS'ers, they are EE's, and not truly well versed in anything above C. But still...
00:34:24 <Itkovian> Heh ... at them moment nothing much :-) it's for a small conference and it mostly a rework of stuff we did earlier on while bored, but which hasn;t got accepted anywhere yet.
00:34:59 <Itkovian> we have performance estimation stuff for C, and we're comparing C and Java to see if the estimation techniques may be valid for the latter (Java) too
00:35:14 <Gahhh> Itkovian, yay, flamewar stuff
00:35:15 <Itkovian> I admit it's a bit hairy ... I just want to get rid of it :-)
00:35:21 <Itkovian> lol
00:35:50 <sethk> Itkovian, are you using any of the compile-to-machine-code Java compilers?
00:36:05 <Gahhh> Itkovian, why bother, just download the powerpoint slides (or equivalent OOo versions) from java.sun.com and conclude that Java >= C
00:36:12 <Itkovian> I am wondering if the real coll stuff we're doing might be valid for a haskell like (say FP in general) language environment
00:36:48 <Itkovian> sethk: you mean ahead of time? nope. It's with a real VM.
00:37:11 <Gahhh> Itkovian, performance estimation via static analysis ?
00:37:47 <Itkovian> Gahhh: I rather disagree with that. Some code can obviously be optimized better, and as 80-90% of time is spent in hot code, optimisation may make up a lot, even make it faster than C, but the rest of the code is still worse ...
00:37:58 <sethk> Itkovian, I'm curious if IBM's compiler behaves as claimed.  I haven't had a chance to try it yet.
00:37:59 <Itkovian> Gahhh: well, yes and no :-)
00:38:17 <Itkovian> sethk: I mostly use the JikesRVM, not their production VM
00:38:21 <musasabi> Has anyone modelled network protocols as monads/arrows?
00:39:19 <musasabi> The more I think about it the more I move towards an oldfashioned "structure of functions which are in the IO monad approach".  
00:39:19 <Gahhh> Itkovian, doesn't the mere existence of a VM affect the estimation parameters ? Things like branch prediction, cache misses, etc.
00:39:24 <sethk> Itkovian, I'm curious about how close the best VMs get to conventionally compiled code.  It isn't a fair comparison, but I'm still curious.
00:39:33 <Itkovian> Gahhh: I'm not into flamewar stuff ... I think one needs to use the right tool for the job. As things stand, Java or Java-like languages can be used for lots of cool things. So can C, and so can Haskell. No big deal.
00:39:43 <sethk> Itkovian, also I'm interested in the performance of the C# VM vs. the Java VM.
00:39:52 <Itkovian> Gahhh: exactly. 
00:39:58 <Gahhh> Itkovian, I'd personally write in Java than in C.
00:41:12 <sethk> Gahhh, I wasn't saying that _I_ want to write in C.  Just observing that the device driver development world seems (from my admittedly unscientific sample) to be reverting back to C from c++.  That may be a bad idea; but it does seem to be a trend.
00:41:41 * musasabi thinks C++ can be nicer for device drivers - that is C++ without OO.
00:42:06 <Gahhh> sethk, nor did I think you meant that. I wwas just saying that what musasabi just said.
00:42:39 <musasabi> templates can be used for doing optimized things, and things like locks with implicit freeing based on scope are nice.
00:42:41 <Itkovian> sethk: I think the actual code delivered is very good.
00:43:07 <vegai> musasabi: won't the code be much harder to grasp when using those?
00:43:14 <Gahhh> One of the bigger problems of device driver development is synchronization with the files produced by the hardware folk.
00:43:40 <wli> importing data is pretty painful
00:43:45 <Itkovian> Speaking of templates, they can help out in programming, but they make a huge hog when compiled. We (our research group) found that in C++ programs you can easily throw out over 30% of the binary (statically compiled).
00:43:51 <musasabi> vegai: no, the C alternative is usually lots of preprocessor macros...
00:44:20 <Itkovian> And that was already optimized by the compiler, not debug info, etc.
00:44:43 <musasabi> and templates for things that reduce to a few instructions at max.
00:44:49 <musasabi> also polymorphism is nice.
00:45:03 <Gahhh> Itkovian, what do you mean ? A template function was linked in even though it wasnt being used ?
00:45:09 <sethk> musasabi, you have to remember, though, that C++ templates are not true templates, they are just complicated macros.
00:45:20 <sethk> Gahhh, that happens all the time.
00:45:31 <musasabi> sethk: of course, but they are lots better than C macros.
00:45:41 <sethk> Gahhh, some compilers are worse than others, but it is a common problem.
00:45:57 <sethk> musasabi, slightly.  They make debugging a nightmare, though.
00:46:04 <sethk> musasabi, as do all macros, for that matter.
00:46:11 <musasabi> true.
00:46:17 <Gahhh> musasabi, before we'd see polymorphism, we'd probably see a good case of inheritance. I have yet to see that in device drivers.
00:46:35 <Itkovian> I'd have to look up the details in the paper, I think it was pubshied at OOPSLA 2002 (look for 'sifting out the mud ...' by Desutter et al.)
00:47:14 * Itkovian happens to like C
00:47:20 * Itkovian hides
00:47:23 <sethk> Gahhh, I did see one case involving USB.
00:47:27 * Gahhh exposes Itkovian
00:47:58 * Itkovian rolls D20 -> 2 
00:48:06 * Itkovian hides once more in shadows
00:48:19 <wli> kernels meant for production use, at least at the moment, need some rather hard determinism
00:48:27 <wli> that is, in the execution model
00:49:23 <musasabi> currently I am playing around with using haskell to implement network stacks and it does not seem bad.
00:49:51 <musasabi> (binary things just suck, but that is quite expected)
00:50:13 <wli> musasabi: interesting
00:50:41 <Gahhh> The abstraction provided by OO is limited by the abstractness that exists in the underlying hardware, imho.
00:51:05 <wli> musasabi: not running into GC-related problems?
00:51:31 <wli> you have to understand... the number one problem I have to deal with is essentially kernel data structure proliferation...
00:52:14 <Gahhh> heh
00:52:30 <sethk> Gahhh, of course.  There are some things added to USB 2 that didn't exist in USB 1, which does provide a good case for inheritence.  I can't think of another.
00:52:43 <musasabi> wli: not really, but currently I am managing critical things in an explicit way, so that does not tell anything.
00:52:45 <wli> you could say that my entire job consists of debugging and fixing kernel data structure proliferation
00:53:03 <wli> musasabi: hmm, how do you do that in Haskell?
00:53:24 <wli> okay, I got the thing into maple
00:53:30 <wli> but it's still barfing
00:53:30 <musasabi> wli: use Ptrs and be very very carefull.
00:53:30 <Itkovian> groovy
00:53:42 <Gahhh> sethk, USB and USB2 are still exceptional examples. In my workplace, the hardware guys add/remove features from the next generation hardware left and right, and each device driver becomes ad hoc.
00:53:52 <Itkovian> wli: how large is your matrix exactly?
00:54:08 <wli> Itkovian: 2682 rows, 10 columns
00:54:19 <Itkovian> Gahhh: doesn't sound easy practivce to me
00:54:33 <sethk> Gahhh, I agree, I said it is the only case I can think of.
00:54:35 <Itkovian> sparse?
00:54:40 <wli> Itkovian: I'm really trying to get *ANY* kind of analytic understanding of what on earth this probability distribution is
00:54:43 <wli> Itkovian: no
00:54:48 <wli> Itkovian: it's least squares
00:54:53 <wli> Itkovian: so there's a sample etc.
00:55:02 <Gahhh> wli, he meant if the matrix is sparse
00:55:05 <wli> Itkovian: it's a large number of samples, so one expects more faithful results
00:55:31 <wli> Gahhh: "least squares" ~> "normal equations" ~> "dense matrix"
00:56:06 <Gahhh> wli, why use normal equations ? Use SVD on the verdetermined matrix 
00:56:16 <Gahhh> *overdetermined
00:56:34 <wli> Gahhh: um, least squares is implemented via SVD...
00:56:44 <Itkovian> lol
00:57:24 <Itkovian> If I get it right, you have 2682 samples at ten characteristics per sample?
00:57:32 <wli> Itkovian: yes
00:57:55 <wli> I'm actually "guessing" that this probability distribution takes on a certain form
00:58:30 <Gahhh> ok, afaik, the normal equations are the 10x10 matrix you can get from the other matrix. Then you can solve it any way you want (with or without SVD). If you pass the big matrix directly to SVD, it will give you a solution in the linear least squares sense.
00:59:05 <wli> doing A^tA is not numerically stable
00:59:13 <wli> passing the big matrix to SVD is better
00:59:20 <Gahhh> wli, that's what I was saying
00:59:28 <Gahhh> so you are passing the big matrix directly
00:59:32 <wli> what I'm doing is passing the big matrix to svd
01:00:02 <Gahhh> wli, are you using polynomials ?
01:00:16 <wli> implicit polynomial
01:00:49 <wli> f(x,y)=0 where deg(f) = (3,3)
01:00:55 <wli> feh
01:01:03 <wli> f(x,y)=0 where deg(f(z,z)) = 3
01:01:27 <wli> the answer will be a direction, not hard numbers
01:01:28 <Gahhh> well, I had success with polynomials with much higher degrees
01:01:33 <Gahhh> oh
01:01:58 <wli> because f(x,y)=0 generates the same curve as c*f(x,y)
01:02:19 <wli> also, the x and y are logscale
01:02:29 <Gahhh> eek
01:03:15 <wli> the reason why is because without logscale it looked a lot like an exponential function, but in logscale it looked like a polynomial curve
01:03:44 <wli> this is just sad
01:03:50 <wli> it should not take all day to do this garbage
01:04:04 <Gahhh> yeah it does. SVD is O(mn^2)
01:04:15 <wli> no to program it
01:04:31 <Itkovian> poor schmuck
01:04:32 <Itkovian> :-)
01:04:43 <Gahhh> well, I thought you meant maple was taking long to compute it
01:04:56 * Gahhh can program quicksort in O(1) time !
01:05:17 <wli> worse, maple's data importation is so awkward I'm remembering why I ditched it for coding it myself in Haskell in the first place.
01:05:58 <Itkovian> wli: how's your data stored in the file?
01:06:12 <wli> line-oriented
01:06:24 <Itkovian> can;t maple read a csv like file?
01:06:30 <wli> apparently not
01:06:38 <Itkovian> dang that bloody ";" is sitting on the wrong key all the time!
01:06:40 <wli> and once I actually coerce it into reading the stuff
01:06:57 <Gahhh> I had an SVD binary that accepted the matrix from stdin and produced the result to the stdout
01:07:05 <Itkovian> you can always mail me the file, I'll send you back the svd ;-)
01:07:27 <wli> it's some incredible PITA I've yet to resolve as to how to be able to do anything with the imported data
01:07:49 <wli> Itkovian: by what means? bear in mind SVD analyses are handwavy exercises in throwing out rows and fiddling with stuff by hand etc.
01:08:13 <sethk> what's Maple's purpose in life?  I'm not familiar with it.
01:08:17 <wli> after I get the SVD I have to cast out outliers and stuff by means I've not yet figured out
01:08:20 <wli> sethk: CAS
01:08:33 <Gahhh> sethk, it's a symbolic maths + numerical stuff application
01:08:51 <Itkovian> hmmm
01:09:12 <Gahhh> wli, if maple doesn't let you see the wj matrix and play around, it's not worth a dime as a CAS, imho
01:09:38 <wli> I've only ever seriously used it for doublechecking bonehead integrals
01:09:56 <Itkovian> maple can be good, but ones usually has to tell it in very specific terms what it needs to do
01:10:12 <wli> and the quality of the output is questionable, e.g. it doesn't understand sn(x,k), cn(x,k), etc. identities
01:10:40 * Gahhh saw it in Universal Soldier: The Return that there are computers that can converse with humans and start WW3 autonomously
01:11:39 <wli> Itkovian: incoming DCC
01:14:15 <tuomov> maple and matrices don't match.
01:14:26 <Itkovian> well, maybe that's true
01:14:33 <wli> so I've found
01:18:54 <wli> well, my first guess for anything is not going to be useful
01:19:01 <wli> so I'm going to have to figure out how to do this anyway
01:20:16 <shapr> Lemmih: pong
01:20:35 <Lemmih> shapr: Yay.
01:20:46 <shapr> wassup?
01:21:13 <Lemmih> shapr: mod_haskell is available from http://212.242.49.100/repo/haskell/mod_haskell
01:21:45 * shapr pops some popcorn kernels to symbolize released pressure for Linux developers.
01:21:57 <wli> you don't want to know
01:22:02 * shapr grins
01:22:38 <wli> a major major customer (numerous millions contract) is having major major problems right now... I can't do anything b/c it looks like userspace thus far
01:22:52 <Itkovian> Lemmih, are you sure about the url?
01:22:55 <wli> the pressure is immense
01:23:10 <shapr> wli: I hope it gets better :-/
01:23:13 <Itkovian> "desktop.sund.dk" cannot be found ...
01:23:14 <Lemmih> Itkovian: Yes.
01:23:17 <Itkovian> hmm
01:23:47 <Lemmih> Itkovian: It's a darcs archive and directory listing is not allowed.
01:24:33 <Itkovian> all right
01:24:56 <Itkovian> got it :-0
01:25:01 <Lemmih> (It makes me feel secure)
01:25:47 <Itkovian> yeah ... that's important :-)
01:26:32 <shapr> Lemmih: is modhaskell okay as a repo/user name?
01:27:08 <Lemmih> Sure.
01:27:12 <shapr> ok
01:28:08 <shapr> ok, it's up
01:32:38 <Lemmih> shapr: Thanks.
01:32:55 <Gahhh> is mod_haskell an apache module ?
01:33:24 <Lemmih> Gahhh: Yes. And it uses hs-plugins to load haskell code at runtime.
01:34:39 <Gahhh> Neat
01:35:01 <Gahhh> I must sleep per my operating manual. Nite #haskell.
01:36:00 <Lemmih> shapr: Did my mail bounce?
01:36:13 <Lemmih> shapr: Oh sorry. Forgot to sign it.
01:57:27 <wli> damn, that was easy
01:59:03 <Lemmih> What did you do?
01:59:16 <wli> Itkovian showed me what R can do
01:59:40 <Itkovian> yeah, well, let's hope the results are correct :-)
02:00:26 <Itkovian> brb
02:04:10 <wli> Now I have to figure out how to get anything to plot an implicit cubic curve
02:05:51 <Itkovian> eek.
02:07:27 <wli> I'm probably best off generating a scatterplot in Haskell again
02:11:00 <Lemmih> hey bringert.
02:23:01 <bringert> hi Lemmih
02:23:45 <Oeje1> hi bringert
02:23:58 <Lemmih> bringert: Niklas was very interested (-:
02:25:13 <bringert> great
02:57:14 <shapr> Lemmih: works?
03:00:09 <shapr> hiya balkan 
03:00:15 <balkan> hi there
03:00:26 <balkan> i have a question about Maybe
03:00:56 * shapr refrains from making all the obvious jokes
03:01:00 <shapr> Lemmih: whoops, more user error on my part.
03:01:13 <shapr> Lemmih: should work now
03:01:23 <balkan> why isn't Maybe defined as Maybe a = Nothing | a
03:01:49 <balkan> instead of Maybe a = Nothing | Just a
03:01:57 <Itkovian> because then you'd say that Maybe a could be the same as a?
03:02:15 <balkan> mind boggling...
03:02:26 <Itkovian> 'a' is a type ...
03:02:45 <Itkovian> correct me if I'm wrong
03:03:02 <balkan> I don't understand why a has to be wrapped in the Just a
03:03:14 <shapr> so you can tell it from the a by itself
03:03:19 <shapr> balkan: try it
03:03:31 <shapr> try using your definition of Maybe
03:03:55 <balkan> shapr: do you have a good test case?
03:04:02 <Itkovian> say 'a' == Int, theyn you'd have Maybe Int = Nothing | Int
03:04:34 <shapr> For one thing, how could you wrap a Maybe type into itself?
03:05:12 <shapr> data Maybe (Maybe Int) = Nothing | Int ?
03:05:15 <Itkovian> besides, isn't a constructor required in a 'data ...' definition?
03:05:36 <shapr> how could you tell which computation failed if one of the nested computations did fail?
03:05:46 <balkan> yes maybe i'm getting this wrong...
03:05:47 <Itkovian> true
03:06:06 <Itkovian> balkan: that wasn;t to you ...
03:06:17 <balkan> Itkovian: yes i know.
03:06:26 * Itkovian definitely has to get theis keyboard fixed and swap the ' and ; keys
03:06:26 * shapr throws lambdas at vincenz 
03:06:45 <shapr> Ok, I'm officially unhappy with WASH.
03:06:58 <Itkovian> maybe try BATH?
03:07:03 <shapr> Is HaXML or something else significantly better for generating markup?
03:07:14 <shapr> Itkovian >>= CARWASH
03:07:34 * shapr imagines Itkovian covered in suds
03:07:38 <shapr> kinky!
03:07:49 <Itkovian> eek!
03:08:05 <shapr> Anyway, I'm using WASH in curryspondence, and it pretty much sucks.
03:08:08 <balkan> would my definition of Maybe lead to a endless recursion?
03:08:10 <shapr> too much overhead
03:08:33 <shapr> balkan: it would definitely make it impossible to unwrap just one layer of Maybe at a time.
03:09:22 <shapr> With the current definition, you could return (Just Nothing) For a nested failure
03:09:28 <shapr> cheesy as that may sound :-)
03:09:48 <balkan> how would you define a type that can hold an integer or null? for instance a field from a database table?
03:10:21 <shapr> I'd using Maybe
03:10:31 <shapr> data Maybe Int = Just Int | Nothing
03:10:33 <Itkovian> Maybe is Just Cool
03:10:40 <shapr> In fact, that's close to what HaskellDB uses.
03:11:41 <shapr> greetings Thomas
03:11:57 <balkan> i would like to define it as   data Dbfield Int = Int| Nothing...but this seems wrong somehow...
03:12:05 <TheHunter> good morning Shae
03:12:20 <shapr> TheHunter: I recently realized just how fitting your irc nick is
03:12:56 <shapr> Isn't Jaeger == Hunter?
03:13:00 <Itkovian> yes
03:13:02 <TheHunter> yep.
03:13:16 <shapr> Learning Swedish is actually useful.
03:13:34 <shapr> It's surprisingly close to German and Dutch.
03:13:36 <Itkovian> so much for irc anonimity :-)
03:14:32 <shapr> It's hard to be anonymous. Plus the open source world functions mostly off of reputation anyway.
03:14:55 <shapr> TheHunter: do you have a blog? Have I already asked you this several times? :-)
03:16:19 <TheHunter> shapr, no, it's the first time. But I don't have a blog (though i sometimes think about it).
03:17:06 <shapr> I'd like to know what sort of papers you're reading lately.
03:17:32 <TheHunter> fwiw, it turned out that yesterday's callcc term can indeed be implemented using Control.Monad.Cont.callCC.
03:17:45 <Itkovian> shapr: I know.
03:17:46 <shapr> speaking of worthwhile blog entries...
03:18:00 <TheHunter> well, i'm currently reading Reynold's book.
03:18:02 * Itkovian searches on the floor for his reputation
03:18:07 <shapr> comparison of Cont to call/cc would be interesting to me.
03:18:12 <wli> reputation?
03:18:18 <shapr> Itkovian: you already have some reputation..
03:18:29 <Itkovian> albeit not a good one, prolly :-)
03:18:41 <shapr> wli: yeah, like "how many kernel hackers does it take to change a light bulb?"
03:18:52 <Itkovian> none
03:18:52 <wli> depends
03:19:06 <shapr> depends on what?
03:19:07 <wli> core hacker you need 3
03:19:16 <TheHunter> anyway, i've got some uni stuff to do.
03:19:20 <wli> 1 to audit all the drivers
03:19:27 <shapr> TheHunter: which Reynold?
03:19:35 <wli> 1 to change the vfs API
03:19:47 <wli> and the last 1 to permaveto ever changing the lightbulb
03:20:02 * shapr laughs
03:20:02 <wli> driver hackers you need a million
03:20:02 <Itkovian> well, luckily you're asking a kernel hacker, if it were up to some obscure Redmond company, they'd change all the electricity in the house :-)
03:20:02 <TheHunter> this one: http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/jcr/www/tpl.html
03:20:15 <shapr> wli: can I send this to lwn.net? :-)
03:20:19 <wli> shapr: sure
03:20:19 <vegai> depends on the kernel :)
03:20:27 <shapr> TheHunter: oooh, neat!
03:20:30 <earthy> itkovian: nah... they'd just make `dark' the new standard
03:20:33 <shapr> TheHunter: see, I really do want to read your blog.
03:20:46 <wli> essentially, you wait for some unspecified period of time for the million driver writers to eventually reimplement the lightbulb in the buggiest way possible
03:20:59 <earthy> and then you audit it? :P
03:21:09 <Itkovian> hehe
03:21:12 <wli> arch hackers, you need 20
03:21:28 <vegai> how about Hurd... :P
03:21:39 <Itkovian> TheHunter: have you read it?
03:21:55 <vegai> "You need one hurd hacker to change a light bulb, but he's nowhere to be found!" 
03:21:58 * vegai hides.
03:22:10 <wli> 1 for each 2 arches, to reimplement the lightbulb independently. The other 10 arches are unswept period and the API breaks. Then the other 10 arch hackers are needed to merge the 10 lightbulb implementations to a kernel less than 3 years behind mainline
03:22:45 <TheHunter> Itkovian, the first 12 chapters. Well, "read" is probably too much, I skimmed a lot of stuff.
03:22:54 <Itkovian> heh, and you liked it?
03:23:43 <TheHunter> i don't know, he's really pedantic, but when it comes to the interesting math, he always says it's "out of the scope" of the book.
03:24:04 <Itkovian> hmmm
03:24:16 <wli> VM hackers you don't have a specific number of kernel hackers needed to change a lightbulb, but rather, the set of VM hackers Linus and akpm are currently listening to. Then this set of kernel hackers will argue indefinitely about minute variations on the implementation of the lightbulb and various kinds of "holy penguin pee", while the lightbulb itself is never made functional, despite being independently reimplemented and NIH'd once for each kernel hacker in thi
03:24:41 * Itkovian goes to check the dept. library
03:24:44 <TheHunter> it's a nice introduction, though, and it covers many topics.
03:24:56 <wli> Lo-lan-do: well, Red Hat is an entirely different issue
03:25:03 <wli> Distro hackers are yet another story.
03:25:04 <shapr> wli: ECHAN
03:25:26 <shapr> I don't think lo-lan-do is on #haskell
03:25:44 * shapr googles for holy penguin pee
03:25:59 <shapr> whoa
03:26:07 <TheHunter> and i guess an introduction to programming language theory is necessarily quite tedious.
03:26:07 <wli> You need 2-3 hackers from each distro. They will each independently reimplement the lightbulb against each of their distro kernels, and bitch about it never being merged to mainline despite their refusal to even ever bother posting the patches. And they will all argue that all of their implementations are best, while none actually works.
03:26:09 <shapr> @jargon "holy penguin pee"
03:26:16 <lambdabot> No match for ""holy penguin pee"".
03:26:21 <shapr> @jargon holy penguin pee
03:26:24 <lambdabot> No match for "holy".
03:26:24 <lambdabot> No match for "penguin".
03:26:24 <lambdabot> No match for "pee".
03:26:27 * TheHunter is away: i'll be back in a few hours
03:26:35 <shapr> weird, it shows up on google.
03:26:50 <wli> And of course, none of these actual distro kernels resembles Linux in any respect beyond the name.
03:27:42 <shapr> TheHunter: I enjoy studying programming language theory. Have you read Patterns of Software? That's my latest personal fad. 
03:28:23 <shapr> I still wish for asymmetric multiprocessing. I'd like to be able to do SMP on one alpha and one intel at the same time.
03:28:36 <Itkovian> that would be cool :-)
03:28:41 <shapr> Even better, I'd like to do dynamic recompilation of the kernel when new CPU arches are hotplug'd
03:28:45 <Itkovian> two alphas would even be cooler
03:29:02 <wli> fs hackers, you need 5. 1 to break the on-disk format, 1 to corrupt pagecache data, 1 to race wildly with O_DIRECT, 1 to introduce livelocks and deadlocks, and 1 to complain that the lightbulb being broken is the VM's problem and a complex system of plugins and hooks allowing the interpretation of a language more complex than Haskell in-kernel is required to give the fs what it needs.
03:29:03 <shapr> alpha has great FPU, intel has good integer ops.
03:29:21 <wli> Needless to say, the fs hackers never actually get the lightbulb installed either.
03:29:30 <Itkovian> a ppc to toy around with would do well too
03:29:46 <wli> what's the Haskell kernel called again?
03:29:51 <shapr> GHC ;-)
03:30:07 <wli> shapr: no, there's a real kernel that runs on the bare metal written in Haskell somewhere
03:30:07 <shapr> actually just the RTS - runtime system
03:30:12 <shapr> oh hOp/House
03:30:17 <wli> shapr: house
03:30:26 <shapr> http://www.cse.ogi.edu/~hallgren/House/
03:31:01 <wli> shapr: how am I doing on humorous responses to "How many Linux kernel hackers does it take to change a lightbulb?"
03:31:02 <shapr> How does a Haskell programmer change a lightbulb? He doesn't. Lightbulbs are immutable. He just shadows the old lightbulb by installing a new one on top of it.
03:31:10 <shapr> wli: I think it's great :-)
03:31:36 <Lunar^> shapr: good one :)
03:31:58 * shapr grins
03:32:01 <Lemmih> shapr: Yay. It's working.
03:32:11 <shapr> Lemmih: finally... I'm still getting the occasional bounce
03:32:48 <shapr> Lemmih: I added your key to hacanon twice instead of once to hacanon and once to modhaskell, but I finally realized that.
03:32:56 <shapr> wli: one of your lines got cut off early
03:33:08 <shapr> the VM hackers
03:33:23 <shapr> despite being independently reimplemented and NIH'd once for each kernel hacker in thi...
03:33:37 <wli> scheduler hackers, you need 3: 1 to argue changing the lightbulb should never be done for reasons of cache warmth, 1 to argue the lightbulb shouldn't abuse the scheduler that way, and 1 to break 7 arches' bootstrap process with an irrelevant change that doesn't change the lightbulb
03:34:05 <vegai> and then Linus comes up and says "Just change the f***cking lightbulb already!"
03:34:14 <wli> shapr: "hacker in this set"
03:34:20 <shapr> ok
03:34:28 <wli> vegai: no, linus is the one spreading the holy penguin pee in the vm flamewars
03:34:54 <vegai> oh..
03:35:54 <wli> (substituting any given task for "changing a lightbulb", this joke may actually help explain why almost nothing ever gets done in Linux)
03:36:45 <shapr> I like the fs part best. Maybe because it mentions Haskell.
03:36:47 * shapr could be biased.
03:36:56 <wli> heh
03:37:30 * shapr adds this to his personal QuotesPage
03:38:01 <wli> Itkovian: hmm, looks like something went wrong
03:38:08 <wli> well, I'm well on my way to writing my own SVD anyway
03:38:17 <shapr> SVD?
03:38:22 <wli> Singular Value Decomposition
03:38:48 <wli> shapr: needed for statistical least squares stuff
03:39:00 <wli> btw
03:39:08 <wli> is there some bonehead plotting lib I can use?
03:39:25 <shapr> long thread about that on the list a month or two back, but it got so big I lost track
03:39:38 <wli> plotting library or least squares for stat stuff?
03:39:51 <shapr> just about plotting graphs at all from Haskell.
03:40:08 <wli> well, I've got a book on the PNG format but I don't have a DEFLATE thing
03:40:18 <shapr> Functional MetaPost was mentioned, several people said that it's easiest to just dump data and use gnuplot
03:40:37 <wli> yeah, I'll probably resort to dumping data and using gnuplot
03:40:56 <shapr> is DEFLATE like zlib?
03:40:59 <wli> but it sucks to not have a way to do it in a lib, esp. because gnuplot is severely limited in a number of respects
03:41:00 <wli> shapr: yes
03:41:26 <shapr> I know that CosmicRay was considering hacking Igloo's pure-haskell INFLATE implementation into a DEFLATE.
03:41:27 <wli> gnuplots limitations largely center around how much math you can do
03:42:18 <wli> plus you can do more "intelligent" things if you have full image generation from e.g. rgb data
03:42:41 <shapr> I would like to have real image libs.
03:43:32 <earthy> write some
03:43:48 <shapr> in my copious free time, sure
03:44:12 * earthy is planning to redo Helmut Dersch's Panorama Tools in Haskell some time
03:44:28 <earthy> problem being that I don't have some time :)
03:44:40 <earthy> and many more projects to fit in there
03:45:34 <shapr> ja, same here
03:45:38 <shapr> oj
03:46:21 <shapr> hiya jak 
03:59:18 <wli> I may be better off converting it to Weierstrass form, finding the positive y solution for a given x, back-transforming it, then polishing the result of that.
04:14:49 <Muad_Dibber> to uni
04:15:25 <wli> a*x^3+b*y^3 + ... can have y^3 eliminated with (x',y') = (b*y+x,a*y), with no cubic term, completing the square eliminates cross terms, so (c+d*x)*y^2+(e+f*x)*y + ... is reduced with (x',y') = (x, y + (e+f*x)/(2*(c+d*x)) (and this also eliminates the linear term in y), then a*y^2=b*x^3+c*x^2+... is reduced with (x',y') = (x+c/(2*b),y) to a*y^2 = b*x^3+c*x+d and then (x',y') = (4*a*b*x, 4*a*b^2*y) gets y^2=4*x^3-g_1*x-g_2
04:16:12 <wli> or something like that
04:19:34 <Itkovian> wli: i have atm 0.1474008000 x^3  - 1370.061997 x - 48461.99363, can that be correct?
04:22:20 <wli> Itkovian: hm?
04:31:16 <wli> Haskell was mathier than Standard ML.
04:31:20 <wli> feh
04:37:35 <shapr> On my list of Haskell things to learn soon: mdo, fixIO, arrows, yampa, multiparameter typeclasses, functional dependencies
04:38:00 <shapr> I should probably fill in HaskellConcepts webpages on the wiki
04:40:10 <shapr> I vaguely understand most of those already, but I'd like to have an exact understanding.
04:40:23 <shapr> Oh, I want to write a chapter for CosmicRay about type tricks.
04:40:32 <shapr> How to encode useful information into the typesystem
04:43:02 <irce> how should I do a cyclic list, ex cycliclist = [1,2,3] . + [1,1,1,1,1] cycliclist should give [3,4,4]   ?
04:43:28 * earthy doesn't even understand the question
04:44:05 <irce> (+ [1,1,1,1,1] cycliclist) -> [3,4,4] 
04:44:29 <irce> ah mod
04:45:07 * earthy still doesn't understand the question :)
04:47:29 <irce> sorry not prefix, infix i meant 
04:50:06 <irce> forget it 
04:50:12 <Itkovian> gotta go
04:50:14 <Itkovian> ttyl
04:51:00 <wli> looks more like linear algebra hmm
04:55:12 <earthy> yeah, looks like linear algebra
04:55:17 <earthy> but he's not saying
04:58:42 <kosmikus> never heard of a cyclic list in the context of linear algebra, though
05:04:26 <wli> I meant this elliptic curve stuff.
05:27:24 <Lemmih> Should the result of 'newCString' be freed manually?
05:28:33 <shapr> dang, I suddenly have HaskellDB questions and bringert just left for Paris.
05:31:01 <shapr> Lemmih: have you had trouble building the latest CVS haskellDB?
05:33:01 <Lemmih> One moment.
05:36:31 <Lemmih> Everything's fine for me.
05:38:32 <Lemmih> shapr: You can't build it anymore?
05:52:53 <wli> this SVD stuff is hurting me
05:57:32 <shapr> Lemmih: are you using the HSQL deb from CosmicRay?
05:57:43 <shapr> uni cycle list
05:57:47 * shapr cackles evilly
05:57:56 <kristnjov> i saw a unicycler at chalmers today
05:58:28 <shapr> Was probably Ulf
05:58:38 <kristnjov> i wouldn't know
05:58:46 <shapr> tall, skinny, short dark hair
05:58:46 <Lemmih> shapr: No.
05:58:52 <shapr> black thick looking unicycle?
05:59:16 <kristnjov> can't quite remember much more than that his hair was dark
05:59:22 <kristnjov> it was from far distance
05:59:50 <shapr> Sounds like Ulf Karlsson.
06:01:12 <irce> can somebody explain my error message -> http://otto-1.hopto.org/q.txt ?
06:04:16 <shapr> irce: have you tried adding parens?
06:05:03 <irce> yep
06:05:57 <shapr> around (amount <= 0) ?
06:06:19 <irce> yes. same error 
06:06:21 <shapr> if so, then amount isn't an Int
06:06:33 <shapr> right, the error message says that
06:06:40 <kristnjov> :P
06:06:54 <Lemmih> irce: "return ss"?
06:07:02 <Lemmih> @type return
06:07:03 <lambdabot> return :: forall m a. (Monad m) => a -> m a
06:07:39 <shapr> I'd like to go uniriding with Ulf Karlsson. I've swapped some emails with him, he sounds like a really cool guy.
06:07:42 <Lemmih> irce: 'return' in Haskell is nothing like 'return' in, for example, C.
06:07:57 <kristnjov> so how did you guys ever meet?
06:08:28 <shapr> I haven't met him. I saw him post to rec.sports.unicycling and discovered that he went to chalmers.
06:08:43 <shapr> He knows a bunch of people on #haskell 
06:09:02 <kristnjov> quite a coincidence that everyone i know of who unicycle are programmers
06:09:09 <wli> shapr: You could always go in for some curry
06:09:27 <wli> shapr: "Hotter than Haskell!" (flashing Jalapeno pepper logo)
06:09:57 <shapr> other unicycling programmers are Henry Baker, Francois Pinard, Ronny Scheur, Mark Stosberg
06:10:35 <shapr> Henry Baker is the father of linear programming, Francois Pinard did PyMacs
06:10:38 <Lemmih> And me (-:
06:10:42 <shapr> right! Lemmih too!
06:11:28 <kristnjov> word is that john hughes unicycles regularly
06:11:30 <kristnjov> oops, i lied
06:11:42 <shapr> I've seen him on a unicycle once.
06:12:01 <shapr> hiya retardo 
06:12:03 <Lemmih> It didn't look like he had done it before, however.
06:12:05 <irce> Lemmih: jep it was that, thanks. 
06:12:11 <kristnjov> i know i should be stunned about this huge "coincidence", but it kind of pisses me off that so many programmers enjoy unicycling.
06:12:16 <Lemmih> irce: No problem.
06:12:21 <retardo> Good morning shapr.
06:12:37 <shapr> why would it piss you off?
06:12:43 <retardo> kristnjov: Claude Shannon was also noted for unicycling.
06:13:07 <kristnjov> shapr, i don't know. it just does.
06:13:13 <shapr> so many programmers enjoy Java, but it doesn't piss me off.
06:13:18 <shapr> kristnjov: ok man, if it works for you.
06:13:22 <kristnjov> like the ozone layer, it pisses me off that we have to have the ozone layer.
06:13:28 <retardo> People actually *enjoy* Java?
06:13:38 <shapr> kristnjov: man, you need to some anger counseling =)
06:13:39 <kristnjov> i enjoy java! it's fun to create game applets.
06:13:45 <kristnjov> shapr, i know :/
06:13:56 <kristnjov> i flunked a test today, perhaps that's why.
06:14:04 <retardo> You flunked a unicycling test?
06:14:25 <kristnjov> no, but close, digital- and computer technique (directly translated)
06:14:27 <shapr> I get frustrated too, but I only apply that frustration where it helps.
06:15:05 <shapr> For example, I didn't do so well on my swedish test from last week, so everytime I get irritated about that, I study swedish for an hour.
06:16:22 <shapr> That way the source of my frustration is removed by useful application of the energy created by frustration. Sensible cycle, isn't it?
06:18:03 <shapr> I think that both positive and negative emotions are useful as fuel to push myself in the direction I want to go.
06:18:17 <kristnjov> ...or you could just go unicycle.
06:18:38 <kristnjov> anyways, i'm off to watching southpark and eating.
06:18:41 <shapr> ok
06:19:24 <shapr> I do the same thing with unicycling, I want to do all these cool tricks that seem so hard to even start. Everytime I get frustrated at my lack of progress I practice more.
06:19:49 <Lemmih> shapr: Sounds painful.
06:20:51 <shapr> It is sometimes. But I think unicycling is a lot like balancing on frustration and using it for useful purposes. I produce industrial amounts of frustration, I gotta do something with it.
06:21:02 <shapr> Might as well be something useful.
06:22:09 <Lemmih> Darcs is wonderful! Thanks again for hosting some of my projects, shapr.
06:22:22 <shapr> sure, happy I can help :-)
06:22:31 <shapr> if you want more projects hosted, ask me
06:23:13 <shapr> I'm happy to host code, it's one way I can contribute positively to the community.
06:28:45 <Lemmih> Btw, http://212.242.49.100/SimpleModule.hcgi is a Haskell module loaded with my mod_haskell Apache module (-:
06:30:24 <Itkovian> hi
06:30:32 <CosmicRay> good morning
06:30:55 <MegaMonad> *Remembering my manners* g'day shapr, g'day syntax.
06:31:09 <CosmicRay> heh
06:31:13 <shapr> heh!
06:31:17 <CosmicRay> MegaMonad: don't I get a greeting?
06:31:20 <shapr> did you do that?
06:31:27 <MegaMonad> CosmicRay: You might want you to get a greeting?
06:31:29 <CosmicRay> shapr: the bot came up with that
06:31:36 <shapr> wow, crazy
06:31:42 <CosmicRay> shapr: it's supposed to pick something greeting-like when it starts up
06:32:15 <CosmicRay> shapr: there's a file out there of keywords -- things like hello, welcome, etc.  It's supposed to take one at random and look up a suitable response
06:32:33 <shapr> neato
06:33:17 <CosmicRay> how it came up with this greeting, I don't know, unless g'day happens to be in that file (I didn't think it was)
06:33:29 <shapr> that's something blackdog once said.
06:33:47 <CosmicRay> yeah, it looked like a direct quote
06:34:36 <CosmicRay> I have a Haskell design philosophy question.
06:34:58 <CosmicRay> I often have a situation where I'm designing specialized components to do a more general task.
06:35:24 <CosmicRay> Examples could be: mail folder code (maildir, mbox, etc); configuration file parsing; protocol handlers for URL accesses; etc.
06:35:55 <CosmicRay> For some of these, I've used a data object with named fields, each one of them being a function that performs various tasks
06:36:03 <CosmicRay> so I get a standardized interface
06:36:20 <CosmicRay> and the advantage of this approach is that I can build a list containing all sorts of different data objects in it.
06:36:38 <CosmicRay> For others, I've used typeclasses, and made the different specialized components a member of the typeclass.
06:37:20 <CosmicRay> this seems to provide a cleaner interface, and one that is more readily extended (maybe I want to support IMAP folders, and support all its searching capabilities too)
06:37:54 <CosmicRay> OTOH, it's difficult/impossible to make a list of a bunch of different types of objects that are all members of the class.
06:38:02 <CosmicRay> what is the canonical way to do these things?
06:47:44 <tuomov> I'd use existentials, but it is a lot of work to make the wrapper instance
06:48:03 <CosmicRay> existentials?  
06:48:23 <shapr> you could use functions that all generate the same type
06:48:33 <tuomov> data AnyFoo = forall a. Foo a => AnyFoo a
06:48:41 <CosmicRay> ah.
06:48:53 <tuomov> then e.g.
06:49:00 <tuomov> class Foo a where
06:49:00 <tuomov>     a_value :: a -> Int
06:49:03 <tuomov> instance Foo AnyFoo where
06:49:03 <tuomov>     a_value (AnyFoo a) = a_value a
06:49:13 <tuomov> but writing that instance can be a lot of work
06:49:31 <CosmicRay> but what benefit does that give me over a generic typeclass?
06:49:48 <CosmicRay> I still can't store a bunch of AnyFoo a's in a list if a is different
06:50:00 <shapr> why do you want a list of a bunch of different objects?
06:50:04 <tuomov> You can store a bunch of AnyFoo:s in a list
06:50:30 <shapr> I think I tried this approach in the past, and found a more functional way of doing it.
06:50:30 <kosmikus> CosmicRay: note that AnyFoo does not have a type argument
06:50:32 <CosmicRay> shapr: one example: storing a list of logging handlers that should be called to process log messages
06:50:33 <tuomov> the actual type is not a parameter of AnyFoo
06:50:57 <CosmicRay> tuomov: hmm, I did miss that.  Is this a GHC extension?
06:51:08 <tuomov> yes, of course. that forall a. part
06:51:16 <CosmicRay> I ask because I don't recall seeing that syntax in the tutorials I've read
06:51:29 <CosmicRay> tuomov: it seems that in the past I could omit the forall bit and get the same result
06:51:37 <CosmicRay> tuomov: is this a case where it's really required?
06:51:46 <tuomov> here it is required
06:51:49 <shapr> can you use logging combinators?
06:52:24 <CosmicRay> shapr: hmm, I'm not quite sure how they'd apply to the problem... could you elaborate a bit?
06:52:46 <shapr> how do you use the list of logging handlers?
06:53:54 <CosmicRay> shapr: when a message is to be logged, it is passed to a logging manager for its particular type of message.  This message stores a list of handlers.  It compares the attributes of the incoming message (things like importance) to the rules defined for each handler, and then calls a handler function for each handler that should be dealing with the message
06:54:09 <CosmicRay> so, for instance, debug messages could be logged to syslog, but critical errors could be logged and displayed on stderr
06:55:24 <shapr> I think there's a better way to do that...
06:55:31 * shapr thinks
06:55:55 <CosmicRay> shapr: http://gopher.quux.org:70/devel/missingh/html/MissingH.Logging.Logger.html
06:56:04 <CosmicRay> the Python interface is more complete at present.
06:56:10 <CosmicRay> there's a link to it from that page
06:57:58 <CosmicRay> huh.
06:58:04 <CosmicRay> tuomov, look what I just found in my code:
06:58:08 <CosmicRay> data HandlerT = forall a. LogHandler a => HandlerT a
06:58:40 <CosmicRay> it must be too early for CosmicRay
07:00:59 <CosmicRay> I suspect I stumbled on that from somewhere and used it, without really understanding that it was an extension at the time.
07:05:03 <shapr> CosmicRay: I'd probably use a combinator structure.
07:05:08 <shapr> my first thought is of course, arrows!
07:05:21 <shapr> but combinators would work the same way, I suspect
07:05:39 <CosmicRay> shapr: well I am completely clueless about arrows so that's out for now
07:05:51 <CosmicRay> shapr: I'm not sure how a combinator structure would be useful here
07:06:03 <CosmicRay> I guess you're suggesting that each handler would have the knowledge about its parent handlers?
07:06:20 <CosmicRay> and do the "kicking upstairs" bit itself, eliminating the need for the more generic logger?
07:06:38 <shapr> no, not even that really.
07:07:32 * shapr thinks
07:07:51 <CosmicRay> there is another piece you may be missing from looking solely at the haddock page
07:07:58 <CosmicRay> the global logger really is.
07:08:09 <CosmicRay> iow, it's initialized at startup using unsafePerformIO
07:08:16 <shapr> yow
07:08:18 <CosmicRay> that is because we want to be able to log from anywhere
07:08:30 <shapr> can't you init in main?
07:08:47 <CosmicRay> No, because you can't modify a variable in haskell
07:09:02 <shapr> huh?
07:09:02 <CosmicRay> let me grab the code and show you
07:09:49 <CosmicRay> OK.  The "global logger" stores the configuration settings and handlers that are used for logging
07:09:53 <CosmicRay> it is an IOref
07:10:09 <shapr> couldn't you use a logger monad?
07:10:44 <CosmicRay> that wouldn't help this problem, because it is one of making settings available globally, without passing the log structure to every function
07:11:04 <CosmicRay> which, incidentally, couldn't solev the problem either, because being able to have a change take effect instantly on a global basis is a desirable property
07:11:13 <CosmicRay> let me give you a more concrete example.
07:11:17 <shapr> a logging monad would do that
07:11:36 <CosmicRay> I have some code in MissingH that does things that people may want logged
07:11:50 <CosmicRay> safeSystem, for instance, which runs a command and raises an exception if it terminates abnormally
07:12:06 <CosmicRay> I could log the command I'm running at DEBUG priority and the return value at, say, ERROR priority.
07:12:27 <CosmicRay> That's fine, but peolpe may use MissingH for a lot of different things, and some may not want to get those things logged.
07:13:00 <CosmicRay> So, they can tweak the settings for the MissingH.Cmd Logger, disabling logging there, and use updateGlobalLogger to make it take effect globally.
07:13:10 <CosmicRay> while still maintaining logging elsewhere.
07:13:16 <shapr> everytime you say global, I flinch
07:13:24 <CosmicRay> yeah I know
07:13:28 <shapr> I think you can do that just fine with a logging monad
07:13:34 <CosmicRay> how could that be done?
07:14:44 <shapr> I see what you mean about the subclassing of logging
07:14:47 <shapr> I'm not sure about that
07:14:52 <shapr> thing is, I've never needed that myself
07:15:00 <shapr> so I suspect there's another approach that's more functional
07:15:07 <CosmicRay> that could be
07:15:13 <shapr> with what you have right now, I could do substring compares 
07:15:24 <CosmicRay> that's basically what happens
07:15:26 <shapr> MissingH is a superset of MissingH.Cmd etc
07:15:31 <CosmicRay> exactly
07:15:34 <shapr> and that would work fine in a monad
07:15:43 <shapr> though it would be cheesy to do substring compares for subclassing messages
07:16:00 <CosmicRay> the trick is, though, making the configuration permeate down through everything without having to modify the functions themselves
07:16:02 <earthy> hm. Ralf didn't understand your question, CosmicRay
07:16:18 <shapr> you've got Ralf Laemell over your shoulder?
07:16:40 <CosmicRay> shapr: I posed the question to haskell-cafe too :-)
07:16:46 <shapr> oh
07:16:55 <shapr> man, I had a question for ralf....
07:17:15 <CosmicRay> shapr: I've used both the Python and Java logging systems before
07:17:23 <shapr> yah, me too
07:17:27 <CosmicRay> shapr: the Python one is really nice.  The Java one is, well, as nice as it can be given Java.
07:17:28 <shapr> but they're very oop
07:17:48 <CosmicRay> shapr: yes, but OTOH I've pretty well cloned the Python one in Haskell using type classes and data types.
07:18:10 <shapr> have you looked at ErrorLog.hs in Ginsu?
07:18:13 <CosmicRay> shapr: there are some missing features, but adding them requires only time, not solving a novel problem
07:18:36 <CosmicRay> I can't remember it specifically, but I seem to remember looking at it and concluding it wasn't versatile enough
07:18:39 <shapr> It just doesn't feel right to use unsafePerformIO, IORefs, etc
07:19:10 <CosmicRay> in my defense, this is the only place I've ever used unsafePerformIO, and it is used in exactly the same manner, and to solve the same problems, as fptools uses it
07:19:26 <shapr> yah, I'm not complaining :-)
07:19:26 <CosmicRay> of course this was the subject of that massive cafe discussion last month too :-)
07:19:34 <shapr> I only wish I could immediately think of a better way.
07:20:39 <shapr> ErrorLog looks pretty good
07:20:47 <CosmicRay> ErrorLog.hs seems to be doing approximately what I'm doing, without the hierarchy
07:20:49 <CosmicRay> but look at this:
07:20:56 <CosmicRay> ior = unsafePerformIO $ newMVar stderr
07:20:59 <CosmicRay> log_level = unsafePerformIO $ newMVar LogNotice
07:21:01 <CosmicRay> hPutStr_v = unsafePerformIO $ newMVar hPutStr
07:21:02 <shapr> yup
07:21:08 <CosmicRay> he's worse than me :-)
07:21:11 <shapr> :-)
07:21:15 <CosmicRay> but doing approximately the same thing
07:21:36 <CosmicRay> I have one master data structure that stores those three bits of data
07:22:16 <shapr> You may want to ask John how he'd do hierarchical errors in ErrorLog, he may have already thought up an elegant way to do it.
07:22:18 <CosmicRay> that has the advantage that modifying logger settings needs to occur in the IO monad only if the change is to be made globally
07:22:18 <shapr> Or I can ask him :-)
07:22:27 <shapr> hiya johs
07:22:38 <CosmicRay> shapr: does he irc?
07:22:46 <shapr> nah, he only does Gale
07:22:53 <CosmicRay> heh
07:23:00 <CosmicRay> I should have expected that.
07:23:23 --- topic: set to '["Due to shortages, there will be no lambdas this Xmas","Learning Haskell - http://www.haskell.org/learning.html","We put the Funk in Funktion","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004", "To me java is a monomorphic type"]' by shapr
07:24:15 <shapr> hm, all the cute quotes should be at the end
07:24:39 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004", "To me java is a monomorphic type","Due to shortages, there will be no lambdas this Xmas","We put the Funk in Funktion"]' by shapr
07:33:18 <CosmicRay> shapr: as for the use of this, I've found myself using it several times
07:33:26 <shapr> use of what?
07:33:32 <CosmicRay> shapr: the logging features
07:33:35 <shapr> oh
07:33:52 <CosmicRay> shapr: I've written several programs that are completely non-interactive and have no way to communicate errors save syslog
07:34:01 <CosmicRay> it's been useful for tracking things down
07:34:26 <dblhelix> MegaMonad: what will you be doing for Christmas?
07:34:33 <MegaMonad> dblhelix: To help defray its cost incurred in complying with obligations and charges imposed by the world, so stealing it randomly assembled in an upcoming eu project. If we have any thoughts on laziness and monads (at least i seem to have no idea what it was explained to me, and i also could need something else, you need a christmas present suggestion.
07:34:54 <CosmicRay> heh
07:34:57 * shapr grins
07:35:01 <dblhelix> ah, okay :)
07:35:09 <CosmicRay> megamonad likely knows little of christmas since his training began on 01/01/2004
07:35:45 <dblhelix> he seems to know just enough :)
07:35:57 <shapr> you only trained him on one year of logs?
07:36:26 <CosmicRay> shapr: yes.
07:36:31 <CosmicRay>   PID USER      PR  NI  VIRT  RES  SHR S PU %MEM    TIME+  COMMAND
07:36:32 <CosmicRay>  3793 jgoerzen  25   0  561m 559m 1516 S  0.0 63.3  15:52.16 megahal
07:36:32 <shapr> how long did it take?
07:36:37 <shapr> eek
07:36:46 <CosmicRay> IIRC about 45 minutes
07:36:52 <CosmicRay> I tried with the entire history back to 2001
07:36:57 <shapr> and?
07:37:01 <CosmicRay> but the training seemed to grow exponentially slower
07:37:18 <CosmicRay> by the time it hit 70%, it was taking 30 minutes to process 1%
07:37:19 <shapr> I wonder if a viterbi ontop of the HMM would help.
07:37:52 <CosmicRay> viterbi?
07:38:34 <shapr> it's an algorithm for tuning HMM
07:38:36 <shapr> sort of
07:38:42 <shapr> it finds the 'highest path' I think
07:39:15 <CosmicRay> ah.  well.  that's all beyond me, but hey, have at it :-)
07:39:45 <shapr> it's not hard, I learned it last week...
07:39:49 <shapr> and I only vaguely understand HMM
07:40:00 <shapr> it's just finding the most used path in a hidden markov model
07:40:21 <shapr> hm, that wouldn't be useful for conversation generation though, would it?
07:41:11 <wli> HMM?
07:41:22 <shapr> hidden markov model
07:41:52 <wli> Is that an AI thing?
07:42:06 * dblhelix only vaguely gets HMMs and has no idea how it's used for conversation generation
07:42:18 <dblhelix> but I'm curious
07:42:19 <shapr> sort of, yeah, you just figure out which words come after which others.. (I think)
07:42:27 <wli> oh, travesty stuff
07:42:42 <dblhelix> CosmicRay: can it be explained easily?
07:43:21 <shapr> CosmicRay: yes, explain it to us!
07:43:45 <CosmicRay> can what be explained?
07:43:47 <dblhelix> CosmicRay: would you mind?
07:43:50 <wli> stemming and other semantic stuff would help
07:44:01 <wli> particularly for e.g. interspersing of spaces between the letters of a word
07:44:12 <wli> and similar shenanigans (e.g. periods)
07:44:39 <dblhelix> CosmicRay: basicly how MegaMonad works and how HMMs play a rle
07:45:03 <CosmicRay> oh.  I really don't understand the markov models bit; I've never really researched it at all.
07:45:14 <CosmicRay> megamonad runs MegaHAL (megahal.alioth.debian.org)
07:45:28 <CosmicRay> it was an entry in the Loebner contest a few years back
07:45:38 <CosmicRay> it was one of the few pure-training bots there
07:45:53 <CosmicRay> a lot of them are crafted with various rules (the alice/aiml ones in particular)
07:46:07 <CosmicRay> megahal is instead fed conversations, then learns as it goes
07:46:32 <CosmicRay> there are no rule files, except for a few very simple ones: how to make a greeting, and pronoun conversions (i -> you, etc.)
07:47:13 <CosmicRay> that's why it's picked up on a little German and French in the channel
07:47:23 <shapr> bonjour MegaMonad 
07:47:27 <CosmicRay> but anyway, I have never studied the AI algorithms megahal uses internally
07:47:30 <CosmicRay> MegaMonad: bonjour
07:47:37 <wli> what algorithms does megahal use internally?
07:47:41 <MegaMonad> CosmicRay: Bonjour mij, comment a va?
07:47:48 <wli> (names only are needed)
07:47:58 <CosmicRay> wli: there's a page on it, one sec
07:48:00 <shapr> http://megahal.alioth.debian.org/How.html
07:48:09 * vegai guesses Markov chains
07:48:15 <CosmicRay> wli: http://megahal.alioth.debian.org/How.html
07:48:19 <CosmicRay> vegai: that's correct
07:48:22 <coven> won't map work for string-lists?
07:48:30 <CosmicRay> "two 4th-order Markov models"
07:48:40 <CosmicRay> coven: sure, that whould be no problem
07:48:46 <coven> hm 
07:48:53 <shapr> I think we pissed of lambdabot.
07:48:59 <CosmicRay> heh
07:49:06 <shapr> he's jealous.
07:49:10 <vegai> MegaMonad: what do you think of Markov chains?
07:49:18 <coven> then i don't understand why ghci is giving me "Non-exhaustive patterns in function <function_name>"
07:49:18 <MegaMonad> vegai: I think you'll be talked to me that much stuff into postmaster. So that arr cannot know so we can explain it rather be hacking on the chains.
07:49:21 <CosmicRay> wli: reading that page is as far as I've delved into how megahal works
07:49:27 <CosmicRay> coven: show us your code
07:49:48 <vegai> MegaMonad: how many Megahals does it require to change a lightbulb?
07:49:53 <MegaMonad> vegai: I think i'm going to change this instance' but you cant add something similar to pescos pipes, in some game values for which there are not quite sure i got from the first a of the rts doing the database matches the types that don't require it to the apartment all day long, i barely understand monads, and io is fine, but just keep evaluating and if it can get the lightbulb.
07:49:57 <vegai> whoa!
07:50:28 <shapr> MegaMonad: who's the lucky one?
07:50:35 <MegaMonad> shapr: I was lucky enough that the one we have a closer association between the old one.
07:50:59 <coven> i'm basically just mapping a string list to function temp where temp is: temp x = if (isSuffixOf "txt" x) then x else 0
07:51:26 <shapr> jak__: wireless?
07:51:31 <CosmicRay> coven: x and 0 are different types, no?
07:51:39 <coven> true
07:51:57 <CosmicRay> coven: that's illegal; the compiler won't be able to infer the return type of temp
07:52:49 <coven> hm k. but any other reason besides that why it would work with for example ["test.txt"] as parameter but would raise an exception with ["test.txt","test2.txt"] ?
07:52:53 <shapr> breakin the law!
07:52:55 <vegai> MegaMonad: are you psychotic?
07:52:59 <dblhelix> but why will it then complain on non-exhaustive patterns, which is more like a run-time error?
07:53:07 <MegaMonad> vegai: How would i do something like that, it occurred to me i was psychotic.
07:53:15 <CosmicRay> coven: no, I would think it would completely fail to compile at all
07:53:35 <shapr> MegaMonad: do you like vegai?
07:53:36 <coven> hhhm how would i solve that problem then ?
07:53:41 <MegaMonad> shapr: I think it's just me or another you need to know about vegai?
07:53:42 <dblhelix> coven: is isSuffixOf a function you implemented? how?
07:53:53 <coven> dblhelix part of Data.List
07:53:58 <CosmicRay> coven: when are you trying to do?
07:54:05 <shapr> MegaMonad: CosmicRay teases you regularly.
07:54:16 <CosmicRay> there are some great megahal quotes at:
07:54:17 <CosmicRay> http://megahal.alioth.debian.org/Classic.html
07:54:18 <wli> well, I have several issues to think about
07:54:22 <MegaMonad> shapr: Cosmicray: me too, but i think things ought to work with regularly.
07:54:26 <shapr> MegaMonad: give me your unicycle!
07:54:40 <CosmicRay> here's my favorite, and my apologies for the 8-line paste.
07:54:40 <wli> 1: discovering that "viagra" and "V.I.A.G.R.A." are the "same thing" in some sense
07:54:40 <MegaMonad> shapr: Bring: you have my unicycle, so i'm not sure my stuff in america...
07:54:43 <CosmicRay> MegaHAL
07:54:44 <CosmicRay>  HOW MANY ROADS MUST A MAN WALK DOWN
07:54:44 <CosmicRay>  BEFORE THEY CALL HIM A MAN
07:54:44 <CosmicRay>  HOW MANY SEAS MUST A WHITE DOVE SAIL
07:54:44 <CosmicRay>  BEFORE SHE SLEEPS IN THE SAND
07:54:44 <CosmicRay>  HOW MANY TIMES MUST THE CANNONBALLS FLY
07:54:46 <CosmicRay>  BEFORE THEY ARE FOREVER BANNED?
07:54:48 <CosmicRay>  THE ANSWER, MY FRIEND, IS BLOWING IN THE WIND
07:54:50 <CosmicRay>  THE ANSWER IS 42. 
07:55:03 <shapr> crazy
07:55:23 <CosmicRay> megahal actually generated that.  most of it is from an american protest song
07:55:30 <coven> CosmicRay, i'm trying to write a function that'll return a string list that only contains a given suffix (i've used txt in my example)
07:55:32 <CosmicRay> "42" obviously isn't :-)
07:55:45 <CosmicRay> coven: perhaps you want Data.List.filter
07:55:48 <CosmicRay> @type filter
07:55:49 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
07:56:06 <coven> probably =)
07:56:07 <dblhelix> MegaMonad: do you like to scrap some boilerplate?
07:56:34 <MegaMonad> dblhelix: Hardware issues. Seems to me that my mind pushes r.t., id like to scrap the theory derives from the boilerplate stuff anyway.
07:56:37 <wli> 2: figuring out that "hot XXX chicks" and "XXX hot chicks" are the same thing
07:57:08 <wli> 3: other variations on word order, fiddling around with characters, conjugation, and declension make equivalent phrases
07:57:32 <shapr> should be easy enough
07:57:40 <shapr> I bet HMM can do more than bayesian stats
07:57:40 <wli> shapr: seriously? do tell
07:57:50 <coven> CosmicRay, thanks, stupid me :)
07:58:00 <shapr> just do higher-order associations
07:58:08 <wli> shapr: well, I vaguely see some kind of morphology and semantic analysis coming into play
07:58:24 <shapr> if you can jump from viagra to dick to V.I.A.G.R.A. for example
07:58:35 * basti_ .o ( ? )
07:58:51 <shapr> add some visual fuzz so that spaces can be dropped and ascii art is understandable
07:58:56 <wli> I don't think I'll get that far
07:58:58 <shapr> same for punctuation
07:59:03 <wli> visual fuzz may be doable
07:59:12 <tuomov> hmm.. megahal could have trouble making correct sentences in finnish (conjugation)
07:59:16 <wli> but punctuation varies as far as how meaningful it is
07:59:25 <shapr> yeah, shapr has trouble making correct sentences in finnish =)
07:59:34 <shapr> three years of studying didn't help much ;-)
07:59:45 <CosmicRay> megamonad: who has trouble making correct sentences in finnish?
07:59:51 <MegaMonad> CosmicRay: If finnish is more correct would be to simply record calls to generate sentences.
07:59:56 <tuomov> MegaMonad: Kuinka suomi vntyy?
07:59:59 <wli> it's very meaningful when it delimits sentences; it's effectively a meaningful subdivision
08:00:03 <MegaMonad> tuomov: V x v -> v.
08:00:08 <CosmicRay> heh
08:00:10 <wli> chop up the thing into sentences
08:00:16 <wli> and clauses based on commas
08:00:22 <shapr> MegaMonad: puhutku suomea?
08:00:22 <dblhelix> MegaMonad: and what about Dutch?
08:00:31 <CosmicRay> wli: that's very difficult with IRC
08:00:33 <MegaMonad> shapr: Hei tooki, puhutko suomea?
08:00:34 <wli> but you're in trouble iwth acronyms and crap like "V.I.A.G.R.A."
08:00:39 <MegaMonad> dblhelix: I.e. Given a representative of everything and make you a secret.  I have looked a bit dutch, since my desktop at chalmers are indeed lamentable.
08:00:39 <CosmicRay> wli: since those are often omitted
08:00:44 <wli> CosmicRay: possibly
08:00:46 <coven> CosmicRay, it's still giving me the same error when i call the function with more than one element in the list :\
08:00:57 * TheHunter is back (gone 04:34:26)
08:00:59 <CosmicRay> coven: your function must be modified for filter
08:01:07 <CosmicRay> coven: because now it needs to return a bool
08:01:09 <wli> anyway, finding some way to feed it the gibberish and have it make sense of all that would help
08:01:14 <CosmicRay> it should be reduced to just the isSuffixOF bit
08:01:23 <shapr> bayesian stats can do a decent job of that already
08:01:49 <coven> that's what i did: temp [l] = filter (\x -> isSuffixOf "txt" x) [l]
08:02:19 <wli> shapr: you sure about that?
08:02:21 <CosmicRay> coven: but you're still calling it from map?
08:02:25 <coven> nope
08:02:29 <coven> calling it directly now
08:02:31 <dblhelix> coven: but now you only match a singleton list
08:02:34 <CosmicRay> covern: try ommitting the brackets around [l]
08:02:44 <CosmicRay> coven: you are matching a list with one element
08:02:53 <shapr> wli: yeah, bayesian stats can do a lot for classifying spam
08:02:55 <shapr> crm114 is better
08:03:01 <dblhelix> coven: or drop [l] at both sides of the eq. (eta-reduction)
08:03:06 <shapr> wli: http://crm114.sourceforge.net/
08:03:31 <shapr> guten abend cptchaos 
08:03:35 <wli> shapr: I'm looking a bit further than that, I don't think you can get orders-of-magnitude gains in accuracy without semantics
08:03:35 <coven> that did the trick
08:03:55 <CosmicRay> MegaMonad: guten morgen, herr monad.
08:03:57 <cptchaos> shapr: guten abend!
08:04:01 <MegaMonad> CosmicRay: Is there a monad monad.
08:04:23 <cptchaos> shapr: How are you?
08:04:24 <shapr> wli: have you read Paul Graham's Spam essays? I implemented his ideas in Haskell, and my first try got about 85% accuracy.
08:04:33 <shapr> bayesian statis are really simple too
08:04:35 <CosmicRay> shapr: sweet
08:04:39 <dblhelix> coven: but I really think you should figure out what is going on there, i.e. what's the difference between matching on [], [l], (a : as) and l
08:04:48 <wli> shapr: I'm talking about using these things to scour vast archives of spam where error rates of 0.1% will spuriously nullroute 100000 IP addresses
08:04:53 <shapr> oh
08:04:57 <wli> shapr: the standards are higher
08:05:12 <shapr> I'd suggest crm114 for that.
08:05:20 <wli> shapr: it has to be orders of magnitude above current
08:05:36 <wli> shapr: crm114 is online and gets 0.1% false positives etc.
08:05:41 <shapr> my first suggestion is to stop using a push protocol for email
08:05:42 <wli> shapr: this is offline
08:05:56 <shapr> hum
08:05:58 <wli> shapr: doesn't matter
08:06:13 <wli> shapr: this thing just scours archives, classifies, and the classification results are to be used elsewhere
08:06:20 <shapr> iirc, crm114 is offline as well
08:06:24 <wli> shapr: i.e. in inferring bad IP blocks
08:06:32 <shapr> bad IP blocks?
08:06:35 * shapr thinks
08:06:36 <wli> shapr: it operates with online/realtime efficiency constraints
08:06:45 <shapr> as for classification, I'd suggest you look at Hal Daume's work
08:06:47 <wli> shapr: yes, bad IP blocks as in "where the spam is coming from"
08:06:52 <wli> shapr: URL?
08:07:01 <shapr> www.isi.edu/~hdaume/ I think
08:07:02 * shapr checks
08:07:15 <shapr> whoa, he added a pic
08:07:47 <dblhelix> kosmikus: did you already come up with a gem name that starts with a 'c' for the upcoming GH release? :)
08:08:55 <wli> shapr: I don't really know anything about this stuff; I have a fairly basic understanding that semantics-oblivious methods are not breaking tight error bounds
08:09:13 <shapr> I don't think that's necessarily true
08:09:26 <shapr> but I'm no expert either.
08:09:33 <wli> shapr: I don't see error rates below 1/1000
08:09:54 <shapr> dblhelix: chrysoprase
08:10:11 <shapr> chalcedony
08:11:19 * dblhelix likes chrysoprase but has no idea of what it looks like
08:11:53 <shapr> @wn chrysoprase
08:11:54 <lambdabot> *** "chrysoprase" wn "WordNet (r) 2.0"
08:11:54 <lambdabot> chrysoprase
08:11:54 <lambdabot>      n : a green variety of chalcedony valued as a gemstone
08:12:16 <shapr> @wn carnelian
08:12:17 <lambdabot> *** "carnelian" wn "WordNet (r) 2.0"
08:12:17 <lambdabot> carnelian
08:12:17 <lambdabot>      n : a translucent red or orange variety of chalcedony [syn: {cornelian
08:12:19 <lambdabot> ]
08:12:26 <wli> there are more
08:12:31 <shapr> @wn chrysoberyl
08:12:33 <lambdabot> *** "chrysoberyl" wn "WordNet (r) 2.0"
08:12:35 <lambdabot> chrysoberyl
08:12:37 <lambdabot>      n : a rare hard yellow green mineral consisting of beryllium
08:12:39 <lambdabot>          aluminate in crystal form; used as a gemstone
08:12:45 <wli> a semantic search thing would also be helpful here
08:13:02 <dblhelix> beryl was already used for the second release :)
08:13:33 <shapr> @wn citrine cordierite
08:13:34 <dblhelix> wli: something like @search gem "c*"?
08:13:36 <lambdabot> *** "citrine" wn "WordNet (r) 2.0"
08:13:36 <lambdabot> citrine
08:13:36 <lambdabot>      n : semiprecious yellow quartz resembling topaz
08:13:37 <lambdabot> *** "cordierite" wn "WordNet (r) 2.0"
08:13:39 <lambdabot> cordierite
08:13:41 <lambdabot>      n : a blue mineral of magnesium and iron and aluminum and
08:13:43 <lambdabot>          silicon and oxygen; often used as a gemstone
08:14:05 <shapr> @wn cairngorm
08:14:06 <lambdabot> *** "cairngorm" wn "WordNet (r) 2.0"
08:14:06 <lambdabot> cairngorm
08:14:06 <lambdabot>      n : a smoky yellow or brown quartz [syn: {smoky quartz}]
08:14:12 <wli> dblhelix: well, first thing I thought of was auf Prolog: isA(Gem,['C|X])
08:14:14 <shapr> ok enough spamming!
08:14:48 * shapr goes to unicycle
08:14:51 <wli> dblhelix: what query language is that?
08:14:58 <dblhelix> yeah, we're probably frustrating the training of future bots anyway ;)
08:15:48 <wli> and how was it implemented?
08:16:22 <dblhelix> wli: I was just making up something ... use gem to search for, in entries that match "c*" (regex)
08:27:01 <vegai> hmm, wonder why lambdabot won't compile on my NetBSD...
08:30:31 <psi> i wonder why darcs won't compile on my netbsd
08:30:43 <vegai> hmm, that compiles fine here
08:30:51 <psi> configure is fine, but when i issue gmake it fails after a while with: /tmp/ghc26852.hc:10:18: term.h: No such file or directory
08:30:53 <vegai> haven't tried the latest one, though
08:31:22 <psi> plus a few other error message that I assume is a consequence from that error
08:31:51 <vegai> when compiling lambdabot's Main, ghc can't find modules that are in ./
08:32:11 <vegai> or .hi-files actually
08:32:58 <psi> vegai: do you have term.h in /usr/include? or from an external package?
08:33:14 <vegai> psi: /usr/pkg/include/term.h
08:34:14 <psi> from ncurses...
08:34:17 * psi installs
08:34:55 <psi> hm, i already had it installed :)
08:37:41 <wli> well, sure enough
08:37:55 <wli> I've got a cluster of singular values >= 100
08:38:03 <wli> and the rest are all <= 10^(-11)
08:38:17 <wli> <= 1e-11 even
08:39:47 <wli> I probably need to cook the SVD a bit and use those singular directions to generate something or some such
08:40:53 <wli> so something like a second pass where I take an unknown linear combination of those singular directions and do least squares on that
08:41:40 <psi> configure: WARNING: term.h: accepted by the compiler, rejected by the preprocessor!
08:41:43 <Itkovian> @seen boegel
08:41:43 <lambdabot> I haven't seen boegel
08:41:43 <psi> configure: WARNING: term.h: proceeding with the compiler's result
08:42:00 <psi> i guess that has something to do with it
08:43:59 <wli> either that or I need to weight things
08:49:04 <wli> still nothing remotely adequately reflecting the shape of the curve
09:08:34 * CosmicRay anxiously awaits the new year.  Then I will hopefully be free of this old AS/400 business!  It will be so nice to no longer have to deal with a machine that can't grok ASCII
09:08:49 <CosmicRay> oops ww
09:10:07 <CosmicRay> yo whee
09:10:12 <whee> hi
09:12:21 <Igloo> Are you changing job, or just losing the machine? What do you do, anyway?
09:13:26 <musasabi> CosmicRay: btw you were a gopher advocate? why?
09:14:06 <Igloo> s/a/the/
09:26:22 <CosmicRay> musasabi: yes
09:26:34 <CosmicRay> musasabi: simplicity and power, basically.
09:26:45 <CosmicRay> musasabi: it's very easy to write a gopher client or server
09:27:27 <CosmicRay> musasabi: also, the gopher protocol was originally designed to be a "global virtual filesystem".  people have imlemented features that let one, say, mount gopherspace in kde
09:27:43 <CosmicRay> it's similar in concept to a read-only webdav, but actually more powerful
09:27:52 <CosmicRay> since any given folder could contain files and folders from many different servers
09:28:02 <CosmicRay> and you don't have to know that on the client.
09:31:08 <CosmicRay> the other nice thing is that gopher has a standardized format for directory listings, where each entry includes filename and server info.
09:31:17 <CosmicRay> basic HTTP doesn't provide that, and FTP barely does
09:32:05 <CosmicRay> that means that you can reliably transform gopher into other things -- my gopherd can serve up gopherspace as WAP/WML for mobile phones, as HTTP for gopher-impaired browsers.  Others have written the folder view for KDE (I think there was even a kernal module at one time)
09:32:11 <CosmicRay> anyway, there's the gopher tour. :-)
09:33:56 <CosmicRay> I'll probably port pygopherd to haskell before long
09:34:10 <CosmicRay> it'll force me to implement mailbox and zip file support in missingh, so that's probably a good thing
09:34:28 <CosmicRay> anyway, why do you ask, musasabi?
09:34:52 <CosmicRay> oh, the other neat thing about gopher is that it can be used as a view into anything that can be viewed hierarchically
09:35:06 <CosmicRay> there are NNTP-to-gopher, mbox-to-gopher, Maildir-to-gopher, even dict-to-gopher gateways.
09:35:31 <CosmicRay> so, one could essentially mount a dictionary once a gopher client is available.
09:36:00 <CosmicRay> of course, one can do NNTP-to-web, mbox-to-web, etc.  but the web lacks the enforced standard representation that makes gopher so appealing
09:37:22 * CosmicRay afks: lunch
09:51:15 <musasabi> CosmicRay: the directory listing is good, but is there good support for mime types and the gopher+ spec seems complex.
09:53:38 <shapr> mmm, unicycling
09:54:19 * vincenz throws lambdas back at shapr 
09:54:41 <Lemmih> shapr: Did you learn anything new today?
09:54:53 <vincenz> lambdas always return?
09:55:09 <stepcut> ??
09:55:10 * xerox laughts sophistically.
10:28:35 <Muad_Dibber> good evening all
11:00:33 * CosmicRay returns
11:01:03 <CosmicRay> musasabi: basic gopher supports an early concept similar but not as powerful as MIME types
11:01:13 <stepcut> :p
11:01:16 <CosmicRay> musasabi: gopher+ is basically a set of extensions to add additional metadata
11:01:23 <CosmicRay> musasabi: mime types are one such piece of metadata
11:01:50 <CosmicRay> musasabi: other pieces include the sever including information about different views (eg, html, postscript, etc.) of a file
11:02:01 <CosmicRay> musasabi: similar to http content negotiation
11:02:09 <CosmicRay> musasabi: there is also support for arbitrary named blocks
11:02:23 <CosmicRay> musasabi: it's similar in concept to adding headers to a http result
11:02:39 <CosmicRay> musasabi: in practice, most gopher+ features are unimplemented, and there is only one gopher+ client in semi-wide use (umn gopher)
11:02:49 <CosmicRay> musasabi: some gopher servers do not use gopher+ at all
11:03:59 <CosmicRay> musasabi: gopher+ never attained standard status, since http basically eclipsed it before it was finalized
11:04:20 <CosmicRay> musasabi: you are correct; many view it as an overly-complex addition to a protocol designed with simplicity as a key feature
11:04:33 <CosmicRay> musasabi: although I would dare say it is still far simpler than http
11:11:20 * musasabi returns
11:12:45 <musasabi> So one has to either live without metainformation (or very few of it) or use a complex largely unimplemented protocol?
11:13:20 <stepcut> so, if a library is licensed under GPL/commercial license, and I have the GPL license, and I write haskell bindings for that library, what is the least restricted I can make my license ?
11:14:05 <Igloo> Probably GPL
11:14:17 <musasabi> stepcut: I would use a dual GPL/BSD license (I think that is legal)
11:14:30 <tuomov> I don't think the GPL viral part can apply to source-only distributions
11:14:45 <tuomov> only if you want to distribute binaries all parts must be GPL
11:14:46 <Igloo> Oh, wait, I think I'm confused
11:14:55 <musasabi> but note in all the documentation that the linked product using the library must be GPL.
11:15:01 <Igloo> GPL is the most restrictive. Public domain would be least restrictive AIUI
11:15:50 * Igloo thinks more, gets more confused, and remembers what I said yesterday about not trying to understand copyright things
11:16:18 <stepcut> so, I am just releasing my bindings as source. I will just make them public domain, but warn people that libmad itself has additional license restrictions...
11:16:20 <CosmicRay> musasabi: pretty much, though I'd say "more complex"
11:16:31 <stepcut> after all, my bindings *could* be used to bind to a libmad clone...
11:17:04 <CosmicRay> musasabi: gopher+ is in wide use on servers, but not so on clients
11:17:15 <CosmicRay> musasabi: otoh, most clients get along fine without it
11:17:17 <tuomov> are there actually gopher servers still?-)
11:17:37 <CosmicRay> tuomov: oh yes, gopher.floodgap.com has a list
11:17:47 * Heffalump appears
11:17:51 <CosmicRay> tuomov: cameron kaiser hosts veronica-2 there, so gopherspace is still searchable
11:18:05 <CosmicRay> tuomov: I run one of the top 10 gopher servers at quux.org :-)
11:18:24 <CosmicRay> tuomov: also one of the major free shell providers (lonestar, iirc) provides gopherspace for everyone
11:18:42 <CosmicRay> so new gophers are appearing at about the same rate they're disappearing
11:18:47 <musasabi> CosmicRay: can gopher serve arbitary binary files efficiently?
11:18:58 <CosmicRay> musasabi: yes
11:19:07 <CosmicRay> musasabi: they will simply stream them over the tcp connection
11:19:22 <CosmicRay> musasabi: when the connection closes, the file is sent.  similar to ftp or http 1.0
11:19:29 <CosmicRay> musasabi: though unlike ftp, no separate data connection is required
11:19:31 <musasabi> partial gets?
11:19:37 <CosmicRay> musasabi: no support for those
11:19:50 <musasabi> :-(
11:20:01 <musasabi> not suitable for serving large files then.
11:20:36 <CosmicRay> musasabi: probably not directly.  If you are writing a customized client, it would be trivial to add support for something like that into a gopher server and remain within spec
11:20:47 <CosmicRay> musasabi: though it would not be particularly convenient for users of standard clients
11:21:15 <CosmicRay> I'd still use ftp for a major download site, over both gopher and http
11:22:57 <CosmicRay> because although ftp the protocol sucks, it still is better for serious downloaders than http or gopher
11:23:12 <musasabi> ftp is quite broken for firewalls.
11:23:25 <CosmicRay> that's why I say ftp the protocol sucks
11:23:44 <CosmicRay> though passive mode ought to be Ok, and proxies exist for ftp in the remaining cases anyway
11:23:45 <Heffalump> why is it better than http for downloading?
11:24:13 <CosmicRay> Heffalump: because with smart clients you can do things like "get *.tar.gz" or recursive downloads
11:24:31 <CosmicRay> Heffalump: the only way to get a recursive download out of http is to have the server generate an index page for directories and then parse it.
11:24:37 <tuomov> I'd use bittorrent for a major download site..
11:25:21 <CosmicRay> tuomov: not so scalable if you're, say, a Debian mirror serving up 30,000 files, 80% of which are less than 10Mb in size, and 99% of which are less than 100Mb in size
11:25:27 <Igloo> I understand HTTP is more efficient as it reuses the connection
11:25:47 <tuomov> yeah, the files would have to be bigger
11:26:09 <tuomov> but with small files it doesn't really matter what the protocol is
11:26:17 <CosmicRay> Igloo: in practice, I don't think it makes that much of a difference.  FTP reuses the control connection but not the data connection
11:26:50 <CosmicRay> Igloo: http is probably marginally faster for broadband users and ftp marginally faster for modem users when transferring lots of tiny files
11:27:00 <CosmicRay> Igloo: for large files, the difference is probably going to be unnoticable
11:27:14 <Igloo> Why would FTP be faster for modem users?
11:27:28 <Igloo> The higher latency should amplify the multiple-connection issue, surely?
11:27:36 <CosmicRay> Igloo: because http's header/conversation overhead is larger
11:27:55 <Igloo> Hmm, that's true
11:27:55 <CosmicRay> Igloo: not if you've got a multitasking downloader
11:38:52 <shapr> Lemmih: I discovered the charm of downhill!
11:40:08 <Lemmih> shapr: As is gliding?
11:41:10 <shapr> I think "downhill" is finding something too steep to ride up, and going down instead. I found a snow-covered hill with steps, logs, roots, rocks, and everything covered in a deceptive layer of snow and slush. Riding down that is like a high-speed non-stop controlled crash.
11:41:21 <shapr> it's FUN
11:42:13 <shapr> I can't glide, but I can now idle just a little bit, and I getting asymptotically closer to one-footing.
11:44:59 <shapr> why doesn't anyone use one-to-many IPv6 multicast for file downloading?
11:45:08 <shapr> It's even more efficient than bittorrent.
11:45:37 <Heffalump> it requires everyone who wants it to be downloading at the same time?
11:45:56 <Heffalump> whereas *down*loading, by its nature, is initiated by the target
11:46:09 <shapr> nooo it doesn't
11:46:18 <shapr> make the multicast a ring
11:46:25 <shapr> just loop the multicast.
11:46:30 <mflux_> you could use bittorrent with multicasting
11:46:37 <Heffalump> mflux_: yeah
11:46:45 <Heffalump> shapr: and how do you know when to stop?
11:46:50 <shapr> you don't need to
11:46:54 <mflux_> so, assuming everyone could send multicast, all peers could send data to a group of other peers
11:47:12 <shapr> since multicast is publish-subscribe the router stops listening if no one is subscribed
11:47:26 <Heffalump> have you tried this out in practice?
11:47:30 <shapr> nope
11:47:36 <shapr> ghc doesn't support IPv6 yet :-(
11:47:51 <shapr> I of course wouldn't use a lesser language ;-)
11:48:07 * shapr peers down his elitist nose at lesser languages.
11:48:23 * stepcut peers at shapr
11:48:24 <Heffalump> what does it have to do with ghc?
11:48:33 <Heffalump> it's a libraries issue, surely
11:48:58 <shapr> Network doesn't support IPv6, only IPv4
11:49:01 <musasabi> shapr: btw I have sent a few ipv6 packets with my haskell thing ;p
11:49:05 <shapr> !
11:49:13 * shapr focusses on musasabi 
11:49:33 <Heffalump> still a libraries issue..
11:49:38 * stepcut focusses on the sun ... my eyes!!!
11:49:42 <Heffalump> you could make an IPv6 network library
11:49:49 * shapr quickly puts ray-bans on stepcut 
11:49:58 * stepcut prefers blue-blockers
11:50:10 <shapr> yes I could, but I haven't done it yet. And neither has anyone else.
11:50:19 <shapr> So, it's an issue, whatever the source of the issue.
11:50:34 <shapr> For issue 2, we'll be running a column on space leaks...
11:50:47 <musasabi> shapr: well it is using tun/tap so it isn't probably not exactly what you want. I think I will have time to package it up on christmas holiday.
11:50:52 <shapr> Sadly, that column keeps taking up the whole magazine.
11:51:17 * shapr snickers punnily
11:52:10 <CosmicRay> musasabi: it would be awesome if you integrated proper ipv6 support into ghc itself
11:52:16 <musasabi> hmm my qemu knoppix died, have to add some hardware to get a debian test machine with recent haskell toolchain :-(
11:52:18 <shapr> ok time to look at the GHC sources
11:52:29 <shapr> last time I looked it wasn't that complicated to add IPv6 support...
11:52:30 <CosmicRay> it shouldn't be a big deal for someone familiar with ffi
11:52:32 <shapr> I just never did it.
11:52:38 <CosmicRay> right, it's mostly just the setup code that differs
11:52:45 <CosmicRay> once you have an open socket it's basically the same as ipv4
11:52:54 <musasabi> CosmicRay: that would imply me liking the C api for these things.
11:53:13 <CosmicRay> musasabi: nah, just tolerating it long enough to making a better version in Haskell :-)
11:53:21 * shapr feeds beer to musasabi so that he will temporarily be able to sustain working with C
11:53:29 <CosmicRay> heh
11:53:41 <shapr> you'll need these funglasses
11:54:05 <shapr> sort of like sunglasses, but they make you falsely perceive that what you are working on is actually enjoyable.
11:54:20 <basti_> the one with the little grids in the lenses?
11:54:23 <basti_> that make rainbows?
11:54:26 <musasabi> Would anyone really really use an ipv6 binding?
11:54:29 <shapr> they're all the rage in the cubicles these days.
11:54:33 <shapr> I surely would.
11:54:35 <basti_> the mushroom ones?
11:54:56 <CosmicRay> musasabi: certainly
11:54:56 <shapr> basti_: actually they look a lot like those things horses wear when they're plowing.
11:55:04 <CosmicRay> musasabi: /whois me
11:55:06 <shapr> they're called "blinders" in english.
11:55:07 <musasabi> shapr: hmm, I'll have to think about it.
11:55:14 <basti_> attached to a big hat?
11:55:16 <musasabi> CosmicRay: ^_^
11:55:18 <basti_> with eyebrows?
11:55:25 <shapr> now that sounds interesting.
11:55:28 <CosmicRay> musasabi: type /whois cosmicray
11:55:34 <CosmicRay> --- [CosmicRay] (~jgoerzen@2002:4463:7269:1:20e:a6ff:fe66:c5a3) : John Goerzen
11:55:35 <CosmicRay> --- [CosmicRay] #haskell #debian-arm #Ocaml #emacs #debian-amd64 #debian-devel 
11:55:35 <CosmicRay> --- [CosmicRay] goethe.freenode.net :Hoofddorp, NL, EU
11:55:55 <Heffalump> some reverse DNS would be nicer ;-)
11:56:01 <shapr> aha
11:56:11 <CosmicRay> Heffalump: yes, well that is a tad tricky with ipv6 at the moment
11:56:12 * shapr looks at Socket.hsc
11:56:52 <CosmicRay> shapr: from memory, there is a new sockaddr structure for ipv6 and a few new library calls, mostly relating to dns (getaddrinfo iirc).  
11:56:56 <shapr> yup
11:57:10 <CosmicRay> those are essential because one must be able to receive ipv6 and ipv4 results from dns
11:58:16 <stepcut> anyone got a recommended channel logger (I run the irc server which hosts the channel, if that makes a difference)
11:58:54 * shapr reads http://jungla.dit.upm.es/~ecastro/IPv6-web/ipv6.html
11:59:15 <musasabi> well all the real issues are how to make the api interoperatible with ipv4.
11:59:27 <musasabi> e.g. how are we going to store addresses?
11:59:30 <shapr> that seems to be addressed
11:59:40 <musasabi> different constructors of same type of different types..
11:59:42 <musasabi> and so on.
12:00:41 <shapr> Gowilla: oh YEAH?
12:00:48 <Gowilla> cosmicray: nothing tricky about it at all :-p
12:01:03 <musasabi> How to make server apps robust with displaying/serializing client addresses that can be of multiple protos and so on.
12:01:04 * CosmicRay blinks
12:01:06 <Gowilla> shapr: YEAH! YOU NO GOOD PERL CODER YOU!
12:01:12 <shapr> yow
12:01:14 <shapr> that's below the belt!
12:01:16 <shapr> @yow !
12:01:16 <lambdabot> Gibble, Gobble, we ACCEPT YOU ---
12:01:27 <musasabi> The real issues are multiprotocol support not ipv6 in particular.
12:01:28 <shapr> He used the P word on me!
12:01:31 * shapr sniffles pitifully
12:01:41 * CosmicRay wonders whio gowilla is and what he wants from me :-)
12:01:43 <Gowilla> shapr writes perl, shapr writes perl, nananana
12:01:50 <CosmicRay> hehe
12:01:57 * shapr attacks Gowilla with a +2 ELEPHANT!
12:02:07 <CosmicRay> musasabi: the C api already supports that, and Network.Socket is mostly a clone of it.  I think it's already there.
12:02:09 <Gowilla> cosmicray: I'm demonstrating rDNS+IPv6
12:02:12 <musasabi> gowilla seems evil.
12:02:13 <Itkovian> luckily it isn;t a camel :-)
12:02:16 <CosmicRay> Gowilla: ahh
12:02:20 * Gowilla attacks shapr with a monkey wrench
12:02:29 <musasabi> CosmicRay: if you look at C programs you note that it is not so straightforward.
12:02:33 * Gowilla is a good friend of that nice chap Heffalump.
12:02:40 * shapr attacks Gowilla with a jar of hunny!
12:02:41 <CosmicRay> Gowilla: well you do have to pick the same way of doing that that irc does, and figure out how to get it delegated
12:02:49 <Gowilla> cosmicray: true.
12:03:02 <shapr> hah, the true weakness of every Heffalump!
12:03:04 <CosmicRay> musasabi: it's not that much worse than uniprotocol, and in fact with the getaddrinfo, probably not worse at all
12:03:14 * Gowilla throws nuts at shapr
12:03:16 <musasabi> CosmicRay: things like getpeername ;)
12:03:20 <shapr> mmm, cashews?
12:03:22 <Gowilla> anyway, my hostname says argue with me, not fight with me
12:03:27 <shapr> oh right
12:03:28 <Gowilla> ooh, cashews. I like cashews.
12:03:28 <shapr> oops
12:03:33 <shapr> I like cashews too.
12:03:38 <shapr> too bad they're so high in fat.
12:03:43 <Heffalump> so do I. Isn't it a coincidence?
12:03:53 <CosmicRay> musasabi: from just looking at it, we'd need a new SockAddrInet6 constructor for SockAddr, a new HostAddress type for ipv6 addresses, etc.
12:04:11 <CosmicRay> musasabi: that works with a sockaddr structure -- that is, it's been multiprotocol all alonig
12:04:21 <CosmicRay> musasabi: (both in C and Haskell
12:04:27 <musasabi> CosmicRay: no it does not very well.
12:04:33 <Heffalump> 'lo
12:04:37 <Philippa> evenin'
12:04:38 <shapr> Philippa: oh YEAH?
12:04:39 <CosmicRay> musasabi: how so?
12:04:40 <musasabi> CosmicRay: because you need to know the correct length..
12:04:49 * shapr attacks Philippa with an ISOMORPHISM!
12:05:06 <shapr> chick-chock! bang!
12:05:11 <CosmicRay> musasabi: right, you need to know what type of socket you're working with
12:05:19 <shapr> I swear, I could make a living as /dev/urandom
12:05:24 <Philippa> unfortunately, your attack appears to be isomorphic to a stuffed bunny
12:05:33 <Philippa> cute, mind
12:05:34 <CosmicRay> musasabi: my gues sis that Haskell's Socket object saves that off, since it appears to know whether it's an IPv4 or unix domain socket already
12:05:56 <musasabi> CosmicRay: precisely. but I don't want my code to care about things like that.
12:06:05 <Heffalump> shapr: if you were /dev/urandom, you'd be deterministic, and you're clearly not
12:06:11 <shapr> oh right
12:06:17 <shapr> is it /dev/random that's not deterministic?
12:06:19 <CosmicRay> musasabi: well if you are wearing your application developer hat, it shouldn't need to
12:06:26 <CosmicRay> musasabi: if you are wearing a ghc hacker hat, there's no way around it
12:06:58 <musasabi> actually there is.
12:07:03 <CosmicRay> oh?
12:07:24 <shapr> the url I pasted shows a way to make a generic address reference
12:07:31 <shapr> so it can be either IPv4 or IPv6
12:09:11 <shapr> fpbuild/libraries/network/Network/Socket.hsc
12:09:30 <shapr> type HostAddress = Word32
12:09:55 <musasabi> CosmicRay: iirc there is a way to query the socket type of a socket..
12:10:00 <CosmicRay> indeed it looks like it is saving off the family in the Socket object
12:10:24 <CosmicRay> data Socket
12:10:25 <CosmicRay>   = MkSocket
12:10:25 <CosmicRay>             CInt                 -- File Descriptor
12:10:25 <CosmicRay>             Family
12:10:25 <CosmicRay>             SocketType
12:10:25 <CosmicRay>             ProtocolNumber       -- Protocol Number
12:10:27 <CosmicRay>             (MVar SocketStatus)  -- Status Flag
12:11:33 <CosmicRay> shapr: that code is generic in that it could initialize itself to use ipv4 or ipv6
12:11:46 <CosmicRay> shapr: it is not generic in the sense that it could use either of them once it's running
12:11:53 <CosmicRay> shapr: though it is possible to do that
12:12:04 <shapr> great, how to fix?
12:12:19 <CosmicRay> shapr: sorry, by "that code", I meant the C code
12:12:27 <shapr> you mean "coud not use either" yes?
12:12:36 <CosmicRay> correct
12:13:07 <CosmicRay> the haskell side is mostly there.  you need the new sockaddr data structure, maybe some hacks to support different storage sizes, and the new name lookup functions
12:13:12 <musasabi> CosmicRay: and don't forget that there is no proper way of serializing a socket address in haskell (as got from the peer)
12:13:41 <CosmicRay> musasabi: that's a shame, there's no real reason SockAddr couldn't be an instance of Show
12:14:19 <CosmicRay> musasabi: I guess there is inet_ntoa out there
12:14:38 <CosmicRay> musasabi: though why it returns IO String instead of String is a puzzle.
12:15:59 <CosmicRay> shapr: the other trick is that you'll probably need a configure test for ipv6, incase support for non-ipv6-aware platforms is desirable
12:16:06 <CosmicRay> shapr: which is probably is, unfortunately.
12:16:21 <CosmicRay> shapr: though one of the simons said he'd write that if someone sent him a patch to do the rest.
12:17:34 <musasabi> CosmicRay: you would need a Read instance too...
12:17:49 <musasabi> I think I did those somewhere..
12:17:52 <CosmicRay> musasabi: I suppose so, and that should be trivial also
12:18:07 <CosmicRay> I did something very similar in pure haskell for my ftp client
12:18:22 <CosmicRay> it's not bad, there's nothing all that tricky about inet_ntoa for ipv4
12:19:08 <CosmicRay> and of course there is getnameinfo for ipv6 abnd ipv4 (NI_NUMERICHOST flag)
12:20:56 <CosmicRay> Heffalump: I got your e-mail about http
12:21:06 <CosmicRay> Heffalump: I will check it out now and will be happy to sponsor it if it looks good.
12:21:36 <CosmicRay> Heffalump: I'm fine with doing it as a sponsor with you in the maintainer field with the condition that you do apply for NM, and inform me if you decide to withdraw from that
12:22:42 <CosmicRay> Heffalump: does http not support hugs, or is there a reason hugs support isn't enabled?
12:25:49 <CosmicRay> Heffalump: your package looks fine otherwise.  For me to do an upload, I'll need a proper Debian source package (orig.tar.gz, diff.gz, and dsc) instead of a darcs repo
12:26:39 <CosmicRay> Heffalump: oh here's one other suggestion: how about publishing the haddock docs for it?
12:26:45 <CosmicRay> you could put them in /;usr/share/doc
12:27:20 <shapr> hej bisby 
12:27:24 <Heffalump> I had the impression Cabal's hugs support didn't work properly. I didn't look into it, though.
12:27:31 <bisby> look at this definition:
12:27:32 <bisby> (>>=) :: StateTrans s a ->
12:27:33 <Heffalump> And yes, haddock would be a good idea.
12:27:34 <bisby>          (a -> StateTrans s b) ->
12:27:35 <bisby>          StateTrans s b
12:27:48 <CosmicRay> Heffalump: it does work (I build Hugs versions of MissingH for instance)
12:28:02 <Heffalump> ah, ok. I'll give it a go then.
12:28:02 <CosmicRay> Heffalump: all you have to do is uncomment the hugs section in debian/control and dh_haskell will automatically see and process it
12:28:04 <bisby> and then there is a function:
12:28:06 <bisby> p >>= k  =  \s0 -> let (s1, a) = p s0
12:28:07 <bisby>                        q = k a
12:28:08 <bisby>                    in q s1
12:28:25 <Heffalump> yeah. I did try with nhc but that is missing the network library. No idea whether hugs has one or not.
12:28:35 <CosmicRay> Heffalump: don't bother with nhc, Cabal doesn't support it yet.
12:28:35 <bisby> is this function correct according to the type declaration?
12:28:41 <CosmicRay> Heffalump: I believe it does.
12:28:52 <Darius> bisby: You haven't defined StateTrans.
12:28:58 <bisby> sorry
12:28:59 <Heffalump> maybe I had nhc and hugs confused when I thought Cabal had problems, then.
12:29:07 <bisby> type StateTrans s a = s -> (s, a)
12:29:31 <Heffalump> do I need to GPG sign anything, or is there no point since I'm not a DD?
12:29:46 <marios> hello, im tryin to write a function that by given a list of strings of 1 or 2 characters each will return a list of list in the following way: given:["aa","cs","d","df","r",y"] will return [["aa","cs"],["d"],["df"],["r",y"]]   if the previous string has the same length is added on the same list otherwise on a different one, any ideas thank u
12:29:51 <Darius> bisby: Are you hiding the standard (>>=) otherwise you're likely to have issues.
12:29:54 <CosmicRay> Heffalump: it would be helpful but not required
12:30:08 <CosmicRay> Heffalump: do you understand what I mean when I say I need the proper source package?
12:30:09 <bisby> Darius: yes this is just an example from a tutorial.
12:30:15 <Heffalump> yes.
12:30:19 <CosmicRay> ok, great.
12:30:38 <CosmicRay> you'll probably want to make _darcs not appear in .diff.gz, though it's no big problem if it does, I suppose
12:30:39 <Heffalump> (though you can make it yourself trivially from the darcs repo, of course, but if you want me to send it to you that's fine)
12:30:48 <Heffalump> oh, good point
12:31:02 <Heffalump> DYM in the .tar.gz ?
12:31:11 <CosmicRay> Heffalump: both
12:31:11 <Heffalump> oh, hmm.
12:31:19 * Heffalump realises he wasn't quite understanding what you meant.
12:31:26 <CosmicRay> ok, let's backtrack a bit
12:31:33 <Heffalump> you want a original tarball and a Debianisation diff.
12:31:35 <bisby> shapr: hej, sg dig inte.
12:31:40 <bisby> sorry
12:31:44 <bisby> swedish
12:31:44 <CosmicRay> the orig.tar.gz is supposed to be the usptream source, basically unmodified, with perhaps a little directory renaming or something
12:31:51 <Heffalump> However, the whole lot ends up in  the same .tar.gz at the moment.
12:31:52 <CosmicRay> Heffalump: you definately don't want a _darcs in that file.
12:32:10 <Heffalump> since the upstream darcs repository has incorporated the debian/ directory I gave them
12:32:11 <CosmicRay> Heffalump: most debian packages ship with an orig.tar.gz and a diff.gz.
12:32:20 <CosmicRay> Heffalump: the diff.gz represents the Debian changes to the upstream
12:32:21 <CosmicRay> Heffalump: ahh.
12:32:25 <Heffalump> yes, I realise that
12:32:46 <Darius> @type let bind :: (s -> (s,a)) -> (a -> (s -> (s,b))) -> s -> (s,b); bind p k = \s0 -> let (s1, a) = p s0; q = k a in q s1
12:32:47 <Darius> @type let bind :: (s -> (s,a)) -> (a -> (s -> (s,b))) -> s -> (s,b); bind p k = \s0 -> let (s1, a) = p s0; q = k a in q s1 in bind
12:32:47 <lambdabot> bzzt
12:32:48 <lambdabot> let bind :: (s -> (s,a)) -> (a -> (s -> (s,b))) -> s -> (s,b); bind p k
12:32:48 <lambdabot> = \s0 -> let (s1, a) = p s0; q = k a in q s1 in bind :: forall b
12:32:48 <lambdabot> 																       s
12:32:48 <lambdabot> 																       a.
12:32:48 <lambdabot> 																(s
12:32:49 <Heffalump> but since upstream seems happy to accept stuff I do, there isn't a set of Debian changes.
12:32:50 <lambdabot> 																 -> (s,
12:32:52 <lambdabot> 																     a))
12:32:54 <lambdabot> 																-> (a
12:32:55 <CosmicRay> Heffalump: ok, well here's the deal
12:32:56 <lambdabot> 																    -> s
12:32:58 <lambdabot> [5 @more lines]
12:33:02 <Darius> bisby: lambdabot says yes.
12:33:02 <Heffalump> but I don't really want to make it Debian native (and remove the release number)
12:33:06 <CosmicRay> Heffalump: you can ship a tar.gz and no diff.gz; that's called a Debian native package
12:33:09 <bisby> Darius: the final s1 seems wrong to me
12:33:16 <musasabi> darcs dist is quite nice.
12:33:19 <Heffalump> can Debian native packages have a -1 release number?
12:33:38 <CosmicRay> Heffalump: I don't know if this is correct, but I think it is: if you do that, you must have no Debian release number, and you must be able to issue a new version number whenever required for Debian changes
12:33:54 <Darius> marios: Try groupBy length
12:33:58 <Heffalump> hmm.
12:34:10 <Darius> bisby: Why do you think so?
12:34:11 <CosmicRay> Heffalump: AFAIK no, because the same tar.gz is used for all versions of a package with the same upstream number
12:34:17 <Heffalump> ah, yes.
12:34:22 <Heffalump> hangon
12:34:27 <Heffalump> dpkg-buildpackage made haskell-http_0.4-1.tar.gz
12:34:35 <CosmicRay> Heffalump: but perhaps it now is a little different, I don't know
12:34:47 <Heffalump> Igloo might know, I'll ask him.
12:34:56 <CosmicRay> Heffalump: right.  If you happened to have a haskell-http-0.4.orig directory there, then it would have built an orig.tar.gz and a diff.gz
12:35:05 <Heffalump> right.
12:35:07 <CosmicRay> Heffalump: dpkg-buildpackage just looks at your directory structure and goes off that
12:35:16 <Heffalump> sure, but it chose to make a -1.tar.gz
12:35:24 <bisby> because what should be returned by (>>=) is a "StateTrans s b"
12:35:26 <Heffalump> it must have had some internal justification for doing so
12:35:44 <Heffalump> how do I specify that _darcs should be ignored?
12:35:54 <Heffalump> obviously I don't want it removed by clean :-)
12:36:01 <CosmicRay> Heffalump: that comes from debian/changelog
12:36:04 <Heffalump> I could do darcs dist and build from that, I guess.
12:36:18 <CosmicRay> Heffalump: there are some exclude options documented in dpkg-buildpackage(1)
12:36:30 <Darius> bisby: Notice the lambda abstraction.
12:36:35 <CosmicRay> I don't recall what they are right now, but you can find them there or in the source to tla-buildpackage
12:36:38 <Heffalump> oh. it decided I had a debian native package because it couldn't find a .orig.tar.gz, and then used the number in changelog to decide on the name of the .tar.gz
12:36:46 <CosmicRay> Heffalump: correct
12:37:07 <bisby> Darius: yes, but how can 
12:37:12 <CosmicRay> Heffalump: I've gotten myself in some trouble by uploading such packages before
12:37:25 <Heffalump> I'm coming to the conclusion that I should probably do darcs dist first, then make the proper packages from that.
12:37:33 <bisby> Darius: q s1 be StateTrans s b
12:37:39 <CosmicRay> Heffalump: that would probably be easiest
12:38:02 <Heffalump> oh, does tla-buildpackage make a source package that other people can then reproduce with dpkg-buildpackage?
12:38:07 <Darius> bisby: It isn't, it's a (s,b).
12:38:12 <CosmicRay> Heffalump: yes
12:38:16 <Heffalump> right.
12:38:29 <CosmicRay> Heffalump: it assumes a certain arch structure, and can build a proper orig.tar.gz out of arch
12:38:30 <Heffalump> so dpkg-buildpackage with the right options, or making a darcs-buildpackage, would do the same trick
12:38:32 <Darius> bisby: The lambda abstraction makes it a s -> (s,b).
12:38:36 <CosmicRay> Heffalump: yes
12:38:52 <CosmicRay> Heffalump: one trick, though, is that once you have an orig.tar.gz, you must not attempt to rebuilt it out of darcs or arch or whatever
12:38:56 <Heffalump> oh, does it figure out which patches (or arch equivalents) are mainline and which are debianisation?
12:38:59 <CosmicRay> Heffalump: you will arrive at a tar.gz with a different md5sum
12:39:01 <Heffalump> right.
12:39:05 <bisby> Darius: ok, i think i understand now. thx
12:39:08 <CosmicRay> Heffalump: basically, yes.
12:39:20 <Heffalump> hmm.
12:39:20 <CosmicRay> Heffalump: it's a little easier to do that with arch but it could be doable with darcs too
12:39:45 <Heffalump> I'm wondering if the people maintaining packages with darcs should get together and agree a common scheme for this.
12:40:30 <CosmicRay> Heffalump: or, if you come up with something that works and doesn't suck too badly, and write the code, it'll probably do :-0
12:40:33 <Heffalump> making the package Debian native is probably asking for trouble, in case Debian ends up needing something that isn't globally wanted.
12:40:38 <Heffalump> true :-)
12:40:42 <Heffalump> quicker, too :-)
12:40:54 <CosmicRay> Heffalump: right, and then there's the version numbering question too
12:41:01 <Heffalump> yeah.
12:41:06 <Heffalump> how do you handle that?
12:41:28 <CosmicRay> Heffalump: say there's a security bug, or some bug in debian/rules.  You may want to get a Debian release out right now, but you'd have to wait for upstream to integrate and announce 0.5 if you go the native package route
12:41:43 <CosmicRay> Heffalump: well if you are doing a normal (non-native) package, it's no big deal; you prepare 0.4-2
12:42:02 <Heffalump> right, but what if the upstream repo has some patches that aren't in a release yet?
12:42:03 <CosmicRay> Heffalump: that will consist of a new dsc and diff.gz file on the source side, and the dsc must refer to the same orig.tar.gz and same md5sum for it as your 0.4-1
12:42:16 <Heffalump> does tla-buildpackage figure out where the last released version of mainline stops?
12:42:30 <CosmicRay> Heffalump: oh, sorry, I thought you were still on the native package thing...
12:42:39 <CosmicRay> Heffalump: ok, this requires a small bit of arch background
12:42:50 <Heffalump> I know roughly how arch works.
12:42:55 <CosmicRay> Heffalump: arch has a notion of distinct branches.
12:42:56 <CosmicRay> ok
12:42:57 <Heffalump> You just use an arch tag?
12:43:05 <Heffalump> or whatever the foo-1 thing they do.
12:43:16 <CosmicRay> so basically, you maintain an upstream branch.  Every checkin on it corresponds to an upstream realse you want to package for debian
12:43:26 <Heffalump> ah, right.
12:43:31 <CosmicRay> I then use arch configs (basically the arch version of a tag) to keep track of which rev is which version
12:43:40 <Heffalump> yeah, I see.
12:43:45 <CosmicRay> you could maintain the upstream branch by importing tgz's or by branching off the upstream repo
12:43:46 <CosmicRay> whatever works.
12:43:55 <Heffalump> one problem with HTTP is that there doesn't actually seem to be an officially specified 0.4 version.
12:43:59 <CosmicRay> then you have a debian branch, which you maintain by periodically merging in from your upstream branch
12:44:03 <CosmicRay> heh
12:44:05 <Heffalump> the web page just says "Use the darcs repo"
12:44:06 <CosmicRay> that is an issue.
12:44:17 <CosmicRay> in those cases, people usually add the date to the upstream version number
12:44:23 <CosmicRay> ie. 0.4.20041214-1
12:44:27 <Heffalump> I think I can just take charge and specify one, though, unless bringert is still around.
12:44:34 <Heffalump> or I could do that, yeah.
12:44:45 <CosmicRay> or better, 0.4.darcs.20041214-1
12:44:53 <CosmicRay> something like that
12:45:10 <Heffalump> right.
12:45:27 <Heffalump> I think .darcs is unnecessary given that upstream is maintaining in darcs as the default
12:45:48 <CosmicRay> yeah, I just know that some people put .cvs. in the version nubmers for these things
12:45:58 <CosmicRay> it's not necessary but just helps indicate wtf there's this date in the version string
12:45:58 <Heffalump> hmm, true
12:46:04 <CosmicRay> it's no big deal of you omit it
12:46:11 <CosmicRay> do whatever you think makes the most sense
12:46:31 <CosmicRay> Heffalump: http://arch.debian.org/cgi-bin/archzoom.cgi/jgoerzen%40complete.org--debian?expand
12:46:39 <CosmicRay> Heffalump: that's my repository of stuff I use tla-buildpackage with
12:47:22 <CosmicRay> perl4caml is a good example.  You'll see 4 different upstream releases and 24 commits on my debian branch
12:47:22 <Heffalump> right, thanks
12:47:48 <Heffalump> actually, what I should do is think about this problem in terms of HaXml, where I don't have upstream commit privileges and which is maintained in CVS.
12:48:15 <CosmicRay> anyway, on the native package question: I think you're better off doing a normal (non-native) package, especially since you have to get your uploads sponsored (if, say, a security issue came up, somenoe may have to make a new debian version without waiting to contact you)
12:48:18 <Heffalump> if I can work out the right way to deal with that, the solution will probably trivially simplify to HTTP. Apart from the "no well-defined state of version 0.4" issue.
12:48:23 <CosmicRay> Heffalump: I have some situations like that with arch
12:48:26 <Heffalump> yeah, I agree.
12:48:33 <CosmicRay> Heffalump: I use cscvs to import it into arch
12:48:44 <CosmicRay> Heffalump: then periodically merge that into my "debian upstream" branch
12:48:51 <CosmicRay> Heffalump: then merge that into my debian package branch
12:49:09 <CosmicRay> though I could go straight into my debian upstream branch, I suppose
12:49:55 <Heffalump> depends on how much you trust the CVS import tool not to make a mess :-)
12:50:00 <CosmicRay> heh
12:50:18 <CosmicRay> I trust them about as far as I would trust any Perl-based CVS wrapper.... :-)
12:51:45 * musasabi notes that this sounds complex as opposed to the simple darcs way ;p
12:52:19 <Itkovian> I am trying to recall the neat monadic IO example to sort a file ...
12:52:31 <Itkovian> it was something of the sort:
12:52:34 <Heffalump> marios: is your question about class homework?
12:52:47 <Itkovian> readFile "in" >>= ... writeFile "out" ...
12:52:53 <musasabi> interact + lines + sort 
12:52:54 <Heffalump> musasabi: most of that merging and repository structure would be necessary with darcs too
12:53:01 <Itkovian> and somewhere it had the (unlines . sort . lines) in there
12:53:08 <musasabi> Heffalump: yes, but simpler
12:53:10 <Itkovian> musasabi: right
12:53:21 <Heffalump> musasabi: simpler how?
12:53:59 <musasabi> Heffalump: no branches but simple distinct repositories.
12:54:07 <Itkovian> musasabi: but interact is of type (String -> String) -> IO ()
12:54:10 <Heffalump> itkovian: readFile "in" >>= (writeFile "out" . unlines . sort . lines) would work, at a guess.
12:54:16 <Itkovian> right
12:54:19 <Itkovian> dang
12:54:22 <Heffalump> (not type checked, even :-)
12:54:38 <Itkovian> I was trying to use >>= twice, which is where I was mistaken
12:54:41 <Itkovian> thanks
12:54:42 <Heffalump> musasabi: arch branches are equivalent to darcs repos. I don't see the extra complication at that point.
12:55:00 <Heffalump> itkovian: you could do it with >>= twice, but you'd end up using liftM or something then
12:55:05 <Heffalump> which is a bit pointless
12:55:34 <Itkovian> ok
12:55:37 <Heffalump> readFile "in" >>= liftM (unlines . sort . lines) >>= writeFile "out"
12:55:38 <Itkovian> ic
12:55:40 <Heffalump> (again at a guess)
12:57:05 <Lor> Uh, surely you mean "return . unlines . sort . lines"?
12:57:24 <Heffalump> oh. umm. yes.
12:57:40 <Heffalump> I can type check things in my head, honest.
12:57:59 <Itkovian> sure you can
12:58:12 * Itkovian is a Monad newbie
12:58:41 <Lor> So, um, (readFile "in" >>= writeFile "out" . unlines . sort . lines)
12:58:44 <Heffalump> well, I'm an experienced Haskell programmer, so I expect to know what I'm talking about :-)
12:58:51 <Heffalump> lor: ok, what's wrong with that? :-)
12:58:59 <Lor> Hopefully nothing.
12:59:17 <Heffalump> ah, right
12:59:29 <Heffalump> I said that before, but with more brackets cos I wasn't sure of precedence :-)
12:59:41 <Lor> Yes, but I'm a lazy slob and don't read backlogs.
12:59:46 <Heffalump> I think the return one is nicer in terms of making dataflow explicit.
13:00:09 <Lor> I think (>>>) would be nicer than (.)
13:00:55 <Lor> readFile "in" >>= lines >>> sort >>> unlines >>> writeFile "out"
13:01:33 <Heffalump> ah, yes
13:01:41 <Heffalump> I was wondering if such a combinator existed
13:02:06 <Lor> In category theory it's written ";"
13:02:08 <Heffalump> have we analysed your problem for style enough yet, Itvorkian?
13:03:55 <Itkovian> sure thing!
13:04:10 <Itkovian> timtowtdi
13:04:13 * Itkovian ducks
13:04:25 <Heffalump> oh, Perl. You want shapr for that.
13:04:28 <Itkovian> lol
13:04:52 <Itkovian> yeah well, I'll get my +2 camel out of the barn in a moment
13:04:55 <Lor> timtwblttwtdi
13:04:56 <Darius> Heffalump: Haskell style does follow TIMTOWTDI as well as approaches to solving problems.
13:04:59 * Heffalump will try to get Itkovian's nickname right next time.
13:05:01 <Lor> timtoblttwtdi
13:05:13 <Itkovian> no problem
13:05:29 <Riastradh> That should be 'timtobfttwtdi,' Lor.
13:05:34 <Heffalump> darius: hmm, not really. There's sometimes alternate syntax - e.g. do vs >>=, list comprehensions versus explicit combinators, indentation versus { ; }
13:05:49 <Riastradh> Learn the distinction between 'less' & 'fewer!'
13:05:49 <Lor> Fair enough.
13:05:54 <Heffalump> but they're all locally equivalent, whereas Perl tends to emphasise having many globally different ways to do things
13:06:02 <Itkovian> hehe
13:07:00 * Itkovian is going to put another layer of varnish on his doorsteps
13:07:04 <Itkovian> brb
13:09:49 <musasabi> but $ not being part of syntax is evil.
13:10:22 <musasabi> (the thing on -cafe)
13:10:28 <Darius> no $ being part of syntax is evil.
13:11:42 <CosmicRay> btw what is it that happens if I omit the space after the $?
13:11:48 <CosmicRay> the compiler gives weird errors
13:12:25 <Darius> CosmicRay: This was some poor planning on GHC's part, it should work without -fglasgow-exts.
13:12:51 <CosmicRay> ok, but what is it that it thinks I'm trying to do?
13:12:59 <Darius> Template Haskell.
13:13:08 <CosmicRay> ah.
13:13:28 <Heffalump> darius: doesn't it?
13:13:38 <Heffalump> and doesn't -fnoth work?
13:14:16 <Darius> Heffalump: I haven't played with TH in a long time and I've always put spaces around ($) so it may have changed.
13:14:35 <Heffalump> I'm not sure either, I was just guessing.
13:14:54 <Darius> There were people complaining about it, so -fnoth (or somesuch) should work.
13:15:02 <Heffalump> it's not -fnoth.
13:15:05 <Heffalump> I'm not sure what it is :-)
13:20:02 <CosmicRay> it doesn't bother me.  I was just curious
13:20:13 <CosmicRay> oh oops, I forgot to reconnect megamonad!
13:20:23 <Heffalump> oh no, how will we survive!
13:20:47 <MegaMonad> Shapr: better way of making haskell.org are welcome.
13:21:20 <CosmicRay> MegaMonad: phew.  We were feeling all alone without a semi-intelligent bot here.
13:21:25 <MegaMonad> CosmicRay: All (1==) ([length x | x <- (group(sort pp))]) . . . I tried that many young women were computers, before it returns true, then the entire language decideable, and hence will be a of the bot to do it alone.
13:21:32 <vegai> what the...
13:21:32 <CosmicRay> emphasis on semi.
13:21:49 <CosmicRay> "I tried that many young women were computers, before it returns true."
13:21:50 <CosmicRay> hmm.
13:22:14 <CosmicRay> sounds liek there's been too much quoting of the matrix in here
13:22:56 <vegai> MegaMonad: how did you like the Architect Sketch in Matrix 2?
13:23:02 <MegaMonad> vegai: That's the sort of sketch of the matrix have to think of an idiot architect.
13:23:10 <CosmicRay> heh
13:23:22 <CosmicRay> vegai: so, how's your job as a directed graph  going? :-)
13:23:45 <vegai> heh, I don't know
13:23:54 <vegai> MegaMonad: how's my job as a directed graph going? 
13:24:00 <MegaMonad> vegai: Jerub: did you make graph an instance of a, but that was directed.
13:24:17 <vegai> he neither
13:24:28 <Itkovian> done
13:24:36 <vegai> MegaMonad: are you it, he, she, or perhaps ey?
13:24:42 <MegaMonad> vegai: I made that idea a while to load config.hs is distinctive of a vector type an odd sense of ownership by the type and have no problems assuming that ....", is ey some pharse i don't understand arrows, yes, screw code that takes the bark out of me to sleep.
13:24:59 <CosmicRay> heh
13:25:05 <CosmicRay> "screw code that takes the bark out of me to sleep".
13:25:06 <vegai> "screw code that takes the bark out of me to sleep." -- I concur
13:25:07 <CosmicRay> quotespage
13:25:08 <CosmicRay> heh
13:25:10 <vegai> ;)
13:26:44 <CosmicRay> MegaMonad: screw?
13:26:50 <MegaMonad> CosmicRay: Er.. I don't have to screw it up.
13:27:01 <CosmicRay> MegaMonad: no, but you did screw it up, didn't you?
13:27:07 <MegaMonad> CosmicRay: For me it's a way to screw in a long sequence of "yes?" "hello?" messages with about 400fps with 1000 polys.
13:27:21 <CosmicRay> heh
13:27:46 * Heffalump is going to get bored of that bot very soon
13:30:18 <boegel> hay everybody
13:30:57 <xerox> yay!
13:31:12 <Lor> grass.
13:31:22 <Heffalump> weed?
13:31:31 <boegel> you're supposed to reply 'hay doctor Nick'
13:31:48 <CosmicRay> boegel: excellent.  <twiddle fingers>
13:32:02 <CosmicRay> boegel: I thought it was "Hi, Norm!" :-)
13:32:14 <kristnjov> i'm sorry dr hibbert, i ate all your tongue depressors
13:32:33 <CosmicRay> <obnoxious laugh>
13:32:43 <kristnjov> he-he-he
13:32:45 <boegel> hehahohihahe
13:37:45 <CosmicRay> musasabi: I think you have inspired me to add Gopher support to MissingH. :-)
13:38:08 <boegel> I ask something here about parsers and Haskell the other day
13:38:27 <boegel> you guys said there are tools for generating parsers for a certain language
13:38:36 <boegel> did you mention Happy ? or was it something else ?
13:38:47 <musasabi> boegel: happy is a tool, parsec a library.
13:38:58 <boegel> musasabi: what's best ?
13:39:08 <CosmicRay> personally, I recommend parsec, but it depends on what your needs are
13:39:12 <CosmicRay> and what your performance requirements are
13:39:27 <musasabi> I use parsec for most stuff..
13:39:29 <Darius> boegel: I'm totally with CosmicRay (though personally I've never used Happy).
13:39:30 <boegel> wel, I guess performance is not that important
13:39:46 <musasabi> I think if this is slow migrate to happy, but I haven't had to do that yet.
13:39:53 <boegel> it's just to parse small 'scene description' files into a Scene type
13:40:07 <CosmicRay> boegel: well then I think you have a parsec endorsement
13:40:09 <boegel> files containing 20 lines of text orso
13:40:14 <musasabi> parsec.
13:40:18 <boegel> endorsement ?
13:40:26 <CosmicRay> suggestion
13:40:43 <boegel> oh okay
13:40:57 <boegel> and can you guys tell me why you prefere parsec over Happy then ?
13:41:15 <CosmicRay> it's far more versatile
13:41:27 <CosmicRay> a better fit for Haskell
13:41:36 <CosmicRay> and, imho, easier to use.
13:42:26 <boegel> CosmicRay: okay thanks
13:42:56 <boegel> my advisor suggested Happy to me, but he has never used a tool/library for parsing stuff in Haskell
13:43:24 <Darius> boegel: It meshes well with Haskell and is surprisingly easy to use.  But mainly I've used it because it's only a library and not a separate tool.
13:43:36 <boegel> Darius: I see
13:44:40 <Philippa> I like it because it's very very much like writing annotated EBNF, only better
13:45:04 <Philippa> plus the fact the parsers're first-class gives you a few neat tricks you can pull, one of which is going to be used in Flippi at some point
13:45:13 <Itkovian> @wiki HaskellIrcPastePage
13:45:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:45:23 <Heffalump> yeah, parser combinators are much nicer to work with than parser generators
13:45:35 <Heffalump> though make sure your grammar isn't left-recursive :-)
13:45:51 <Heffalump> unless parsec fixes that for you
13:45:58 <Philippa> Not that it matters /too/ much, as there're common combinators to catch those patterns anyway
13:46:07 <zamez> hi Heffalump
13:46:32 * Lor again advocates observable sharing, so a combinator library could detect recursion.
13:46:41 <Heffalump> hi zamez. LTNS :-)
13:46:45 <zamez> :>
13:47:10 <Philippa> Lor: arrow-based parser, have fun
13:47:15 * Heffalump whaps Lor around with a cluestick of referential transparency
13:47:20 <Heffalump> and yes, arrow-based parser.
13:47:23 <Lor> Bah, it's overappreciated.
13:47:25 <boegel> Philippa: I know a little bit of BNF, so that might help me
13:47:50 <Philippa> boegel: <|> is your choice operator, you do stuff in sequence by the usual monadic means
13:48:10 <zamez> anyone know of a CSS parser?
13:48:12 <Lor> That's not the point. You can have a completely static parser library, but still you need some way to detect recursion if you are to optimize it.
13:48:14 <Philippa> then you just return the (degenerate?) AST for what you've parsed
13:48:34 <Philippa> Lor: sure. Arrows'll get you all the data you need to do that
13:48:55 <Lor> Only if you use a manual fixpoint.
13:49:02 <boegel> Philippa: I'll read some docs / tuts on parsec, that will help me probably
13:49:03 <Heffalump> lor: arrows do that for you
13:49:19 <Lor> A fancy recursive proc notation might do that, but that's different.
13:49:20 <Philippa> boegel: TFM works fine
13:49:27 <CosmicRay> boegel: http://www.cs.uu.nl/~daan/download/parsec/parsec.html
13:49:32 <Heffalump> lor: yeah, that's what I meant.
13:49:45 <Philippa> if you want a little example code, the DeWikify module in Flippi is apparently reasonably idiomatic. I couldn't say, having written it
13:49:49 <Heffalump> zamez: I think there isn't one.
13:50:07 <Heffalump> since I've been looking at HTML parsers recently for screen-scraping and I didn't come across one
13:50:17 <zamez> ok
13:50:22 <Lor> The point is that list = item <|> ((.) <$> list <*> item) cannot be optimized in a reasonable way.
13:50:37 <zamez> I'm looking at Happy to write one
13:51:02 <Heffalump> http://www.haskell.org/libraries/#xml would be the obvious place to check.
13:51:18 <Heffalump> (and for one to be listed if there was one)
13:51:31 <CosmicRay> Heffalump: otoh, we know that page is no longer maintained
13:51:41 <boegel> CosmicRay: thanks
13:51:42 <Heffalump> oh?
13:51:44 <Heffalump> I didn't know that.
13:51:57 <CosmicRay> oh, there was a thread on cafe about replacing it with the wiki or cabal or whatever
13:52:32 <Heffalump> ah. For complicated reasons to do with a recent job and house move, I haven't read the mailing list for months.
14:01:28 * boegel his eyes or closing beyond his control
14:01:34 <boegel> s/or/are
14:01:41 <boegel> I think I need to get to bed :)
14:01:49 <boegel> g'night everyone
14:02:49 <marios> hello, im tryin to write a function that by given a list of strings of 1 or 2 characters each will return a list of list in the following way: given:["aa","cs","d","df","r",y"] will return [["aa","cs"],["d"],["df"],["r",y"]]   if the previous string has the same length is added on the same list otherwise on a different one, any ideas thank u
14:03:23 <marios> i ve tried groupBy but cant get it to work
14:04:38 <Heffalump> marios: is this homework of some form?
14:05:35 <CosmicRay> MegaMonad: solve our homework.
14:05:36 <marios> yes, im tryin to write a parser and this is a function i think it will be helpful
14:05:41 <MegaMonad> CosmicRay: I don't think i hosed a previous regex, then search, otherwise ask for homework and the solution is a homework problem.
14:06:08 <Heffalump> it sounds unlikely.
14:06:16 <Heffalump> that it'll help you write a parser, that is.
14:06:58 <Heffalump> but you really should look at groupBy more carefully.
14:07:10 <marios> k thanx
14:07:36 <Heffalump> it's a one-liner, including your example input
14:10:14 <marios> basically the output of my parser looks like:
14:11:25 <marios> [(3,"("),(1,"z0"),(1,"z1"),(1,"a"),(5,")"),(6,";"),(1,"z0"),(4,":"),(1,"a"),(1,"b"),(1,"c"),(0,"Eop")]
14:11:55 <marios> yeh its too complicated to explain now but thanx
14:12:41 <marios> maybe the way i thinkin of it its not the best ill let u know if i wont get anywhere
14:13:37 <Philippa> dammit, I just found a really good use for circular module dependencies
14:13:50 <Philippa> really good in the "I wrote it, then realised it contained one and there isn't really a good fix" sense
14:15:05 <Heffalump> you know there are ways of doing them with GHC?
14:17:00 <Philippa> yeah, I know
14:17:13 <Philippa> ah well, it's technically haskell 98, screw all the compilers that don't support it ;-)
14:17:37 <Pseudonym> I think you meant _fix_ all the compilers that don't support it.
14:17:45 <Philippa> feel free to
14:18:30 <Pseudonym> I already have a proposed semantic fix.
14:18:34 <Philippa> cool
14:18:34 * Pseudonym hasn't coded it, of course
14:18:35 <vegai> I think in most compilers, it's a feature that they don't support haskell98 ;P
14:18:47 <Philippa> vegai: in what regard?
14:18:50 <vegai> though perhaps you meant Haskell compilers exclusively..
14:18:58 <Philippa> ah, yeah :-)
14:19:18 <Pseudonym> The idea is that you generate the .hi file from the .hs file alone.
14:19:28 <Pseudonym> Using no semantic analysis of the .hs file.
14:19:46 <Pseudonym> If there's a type declaration on an exported symbol, you export that.  If it's not, you don't.
14:19:56 <Philippa> OK, yeah, can live with that for now
14:20:00 <Heffalump> do recursive modules require explicit type sigs?
14:20:09 <Pseudonym> Heffalump: Not exactly.
14:20:12 <Heffalump> if not, you're still not supporting haskell 98..
14:20:16 <Philippa> Pseudonym: how hard would it be to add that to GHC?
14:20:21 <Philippa> no, but that much'll do
14:20:39 <Philippa> I should have signiatures on the bits I'm exporting /anyway/
14:20:43 <Pseudonym> You only make it an error to _use_ a symbol which doesn't have an explicit type signature.
14:20:52 <Pseudonym> Much the same as lazy typeclass resolution.
14:21:07 <Philippa> anyway. .hi-boot here I come...
14:21:17 <Pseudonym> Heffalump: Actually, the H98 standard is silent on the topic of the semantics of modules.
14:21:22 <Philippa> Making Flippi support (static) plug-ins properly is proving... fun
14:21:39 <Pseudonym> I don't think it'd be that hard, personally.
14:21:47 <Pseudonym> The difficulty would be changing the .hi format.
14:21:57 <Pseudonym> But you could make the .hs -> .hi tool a separate program.
14:22:03 <Pseudonym> That would be easy to write.
14:22:06 <Philippa> or just generate a .hi-boot?
14:22:14 <Pseudonym> Maybe.
14:22:30 <Pseudonym> Dunno.  I avoid .hi-boots because they're a royal pain.
14:22:33 <Philippa> how much of GHC's internals would one need to understand to implement this?
14:22:38 <Pseudonym> Even though I want proper separate compilation.
14:22:51 <Philippa> where're the problems, beyond "you have to write the damn thing?"?
14:23:04 <Philippa> hrmm, the orphan module/instance thing?
14:23:29 <Pseudonym> The biggest problem is probably "groking the GHC source".
14:25:23 <Pseudonym> If only I had sufficient tuits.
14:25:36 <CosmicRay> careful.
14:25:43 <CosmicRay> that's a nasty typo waiting to happen.
14:26:10 <Pseudonym> Yes, I could write "Tutsi", instead.  And if there were any Hutu people on this channel, they might get offended.
14:26:10 <Heffalump> round tits doesn't have the same ring to it
14:26:41 <Philippa> yeah, it might be taken as a suggestion I should be the one to do it...
14:27:40 <Pseudonym>  Probably the semantics that you want is that you do this if there is no .hi-boot file.
14:27:45 <CosmicRay> shapr: hawiki is giving me 500 when I try to edit a page
14:28:46 <Philippa> Pseudonym: that was what I had in mind
14:28:55 * Pseudonym nods
14:28:56 <Philippa> aaanyway, .hi-boot written
14:29:23 <Pseudonym> As Fergus noted, GHC accepts the related language of Haskell 98 + .hi-boot files.
14:30:15 <Pseudonym> As opposed to Haskell 98.
14:31:08 <Heffalump> Haskell 98 + .hi-boot files + ghc command-line options.
14:31:44 <Heffalump> oh, Fergus has moved to Galois.
14:31:48 <Pseudonym> Yes.
14:32:17 <Pseudonym> Recursive modules and stack traces are his biggest annoyances so far.
14:33:41 <Heffalump> sadly it seems unlikely that HsDebug will get released.
14:44:47 <Darius> @listcommands
14:44:48 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
14:44:48 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
14:44:48 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
14:44:48 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
14:44:48 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
14:44:48 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
14:44:50 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
14:44:52 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
14:44:54 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
14:50:21 <shapr> CosmicRay: which page?
14:50:36 <CosmicRay> shapr: MegaMonad
14:50:44 <CosmicRay> shapr: I've had troubles with it taking *forever* to update, too (minutes)
14:51:07 <Pseudonym> MegaMonad: What's up with the wiki?
14:51:13 <MegaMonad> Pseudonym: Username249: it means, arrows are a) sharp pointy sticks  b) generalizations of monads  c) a mark to indicate domains are ok: http://en.wikipedia.org/wiki/library-related_commands_and_files might be useful to have kids someday.
14:51:23 <shapr> hmm
14:51:52 <shapr> oj crap
14:51:57 <shapr> not again :-(
14:52:15 <shapr> end_request: I/O error, dev 03:02 (hda), sector 12249464
14:52:23 <shapr> salut paf 
14:52:32 <shapr> seems like it's time to backup haskell.org and start over.
14:52:40 <Itkovian> shapr: do you ever sleep?
14:52:49 <shapr> Itkovian: I tried it once, but it wasn't much fun.
14:52:49 <Heffalump> what machine is that?
14:52:54 <Itkovian> heh
14:52:55 <shapr> www.haskell.org
14:52:59 <Heffalump> oh dear..
14:53:22 <Heffalump> is there somewhere to move it?
14:53:44 <shapr> um... not exactly
14:54:12 <shapr> paf: veux ta apprendre Haskell? :-)
14:54:17 <shapr> oops
14:54:19 <Pseudonym> Where is www.haskell.org exactly?
14:54:20 <Heffalump> do you at least have a backup?
14:54:32 <Heffalump> (or anyone else)
14:54:40 <Darius> shapr: Which version of Ion do you use?
14:54:41 <shapr> veux tu apprendre? or should that be veux t'apprendre ?
14:54:42 <shapr> dang
14:54:46 <shapr> Darius: ion3
14:54:57 <shapr> haskell.org is at yale.edu
14:55:04 <shapr> there are semi-regular backups last I heard
14:55:17 <shapr> paf: so, where are you from?
14:55:18 <Philippa> I got the impression I'd like Ion if I carried on using it and fixed a few borkages in my Debian install
14:55:35 <shapr> I like Ion. I think tuomov does too.
14:55:36 <Philippa> what I /really/ want is WMs for win32 though
14:55:43 <Igloo> I'd have thought Yale could find a replacement disk if you tell them it's dieing
14:55:44 <Philippa> I'd /hope/ tuomov does
14:55:55 <Darius> Philippa: That'd be nice.
14:55:59 <musasabi> Philippa: there is a solution.
14:56:15 <Philippa> musasabi: I am *not* booting a non-win32 OS as my main OS. I play too many games.
14:56:16 <Darius> shapr: Ion3 isn't in a darcs repo is it, or is it just the scripts?
14:56:17 <shapr> who's the boss of haskell.org? Peterson?
14:56:21 <Heffalump> I think so.
14:56:23 <musasabi> Philippa: putty + X server + fvwm + everything works (needs a fast lan)
14:56:25 * shapr sends email
14:56:34 <Philippa> heh
14:56:43 <monochrom> My friend prefers windowmaker
14:57:06 * Philippa wonders just how much you'd have to frig with windows to get it doing framed MDI windows and a framed desktop
14:58:09 <Philippa> I only really need the former, mind
14:58:14 <monochrom> basically anywhere between slapping cygwin + real window manager on top of it, to downright erasing it.
14:58:44 <Philippa> oh, I want to be able to do it with ordinary win32 apps...
14:58:59 <shapr> paf: have you written any Haskell code?
14:59:01 <Philippa> not /too/ desparately in fairness, I only really need it for my text editor 'cos I run everything maximised
14:59:03 <monochrom> right, few people want the most extreme solution.
15:00:16 <shapr> paf: the syntax isn't difficult
15:00:20 <shapr> @wiki HaskellDemo
15:00:20 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
15:00:55 * shapr suddenly wants a donut
15:01:05 <shapr> Krispy Kreme!
15:01:09 <KrispyKringle> haha
15:01:09 <KrispyKringle> hi
15:01:16 <shapr> hiya KrispyKringle
15:01:23 <KrispyKringle> (I don't know why everyone thinks that's what my nick is supposed to be, though ;)
15:01:32 <paf> is there bindings to GTK or some other GUI librairy in Haskell?
15:01:33 <KrispyKringle> how you doing, shapr 
15:01:47 <shapr> I'm hungry! How are you?
15:02:20 <KrispyKringle> bit sleepy. i've decided to learn haskell as a means of procrastinating from my real work, though, so it's all good ;)
15:02:23 <shapr> paf: yes, there's gtk1 gtk2 wxHaskell fltk and Tk
15:02:28 <KrispyKringle> figured i'd join the channel and check it out. 
15:02:49 <shapr> Haskell is a fascinating language. How do you want your language intro, rare, medium, or well done?
15:02:52 * Pseudonym figured KrispyKringle was some reference to Santa Claus
15:03:06 <monochrom> I want it well-ordered
15:03:09 <Pseudonym> And a potential chimney accident, presumably.
15:03:21 <KrispyKringle> Pseudonym: yeah, you got it. 
15:03:30 * shapr monadizes monochrom 
15:03:30 <Pseudonym> Oh.  I meant it as a joke.
15:03:37 <paf> Do you know if the DSP code there efficient? (haskelldsp.sourceforge.net)
15:03:41 <KrispyKringle> shapr: well, i used to know ocaml, so im not completely infamiliar with FP, at least. 
15:03:50 <paf> *is efficient?
15:03:51 <KrispyKringle> Pseudonym: me, too. but that is where the name originates. 
15:03:56 <Pseudonym> There you go.
15:04:01 <KrispyKringle> :P
15:04:17 <KrispyKringle> i have recently discovered the donuts, though. they're quite good. 
15:04:28 <shapr> paf: I haven't tried it. I don't know how efficient it is.
15:04:41 <Pseudonym> We don't have that brand of doughnuts here.
15:04:43 <shapr> KrispyKringle: Krispy Kreme used to be southeast USA only. Where are you?
15:04:50 <shapr> Have they expanded?
15:04:56 <Pseudonym> (Note archaic spelling of "doughnuts".)
15:05:14 <KrispyKringle> shapr: philadelphia. they don't have krispykreme shops here, but they have them in a few stores and supermarkets. 
15:05:44 <KrispyKringle> ive only had 'em a couple times, but they sure beat dunkin' donuts (though DD has great coffee). 
15:06:13 <shapr> Krispy Kreme has an incredible variety, and they taste sooo good.
15:06:18 <np_hard> krispy kreme has a deal with one of the petrol station chains in the USA
15:06:28 <shapr> I haven't had any of their doughnuts in the last six years...
15:06:34 <shapr> Now I want one!
15:06:45 <KrispyKringle> ive only had the traditional glazed. but they're quite good. 
15:06:59 <shapr> the flavor filled variety is nifty
15:07:05 <Pseudonym> Our major brand in Australia is "Donut King".
15:07:31 <Pseudonym> We believe that he is currently planning an alliance with Burger King.
15:07:40 <KrispyKringle> haha
15:07:44 * shapr snickers
15:08:25 <KrispyKringle> I like this language already. The syntax is more pleasing that OCaml's, and the people here like donuts. 
15:08:38 * shapr laughs
15:08:53 <np_hard> syntax more pleasing than ocaml ... setting expectations low, are we?
15:08:55 <shapr> Wow, I never thought donut love was one of Haskell's good points.
15:08:58 <monochrom> Wait til you see them in person and find out that they look like donuts too.
15:09:13 <paf> shapr: what compiler/interpreter do you use?
15:09:18 <KrispyKringle> np_hard: well, OCaml is my only other FP experience. 
15:09:30 <shapr> paf: I prefer GHC and GHCi, because they have more features.
15:09:42 <shapr> paf: I've used Hugs but the error messages aren't as good in my opinion.
15:09:46 <KrispyKringle> Y'all use DARCS, by chance?
15:09:47 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","Due to shortages, there will be no lambdas this Xmas","We put the Funk in Funktion","The people here like donuts"]' by Pseudonym
15:09:47 <paf> and where is that eigenvector function you told me about?
15:09:51 <np_hard> my FP experience is primarily in javascript and perl
15:09:58 <musasabi> ocaml syntax is something between horrible and abominable.
15:09:59 <shapr> paf: I would use Hugs if I had a Sharp Zaurus.
15:10:03 <np_hard> but I do mess around with haskell and scheme from time to time :)
15:10:19 <shapr> I think Pseudonym wrote some eigenvector code.
15:10:30 <KrispyKringle> musasabi: I believe that's why I stopped using it :P
15:10:33 <Heffalump> KrispyKringle: quite a few of us do
15:10:36 <Heffalump> (use darcs)
15:10:40 <shapr> Also, I think I've seen some eigenvector code in the HaskellDSP libraries themselves.
15:10:43 <KrispyKringle> Which is a shame, because it's actually a pretty nice language. 
15:10:51 <paf> shapr: a Sharp Zaurus?
15:10:52 <KrispyKringle> Heffalump: ah. Just wondering ;)
15:10:56 <Heffalump> see #darcs :-)
15:10:59 <Pseudonym> I did?
15:11:18 <shapr> paf: Sharp Zaurus is a palmtop computer the same size as the Palm organizers, but it runs Linux!
15:11:32 <Pseudonym> Estimating eigenvectors isn't fun.
15:11:44 <shapr> but it has very small amounts of memory, so I would use Hugs there.
15:11:44 <paf> wli was working on a SVD function yesterday, that's the same as calculating the eigenvectors.
15:11:44 <Pseudonym> Or eigenvalues, for that matter.
15:12:03 <shapr> KrispyKringle: I use darcs. I run the DarcsWiki too.
15:12:13 <KrispyKringle> shapr: ah. 
15:12:16 <KrispyKringle> just an idle question. 
15:12:47 <shapr> The recent darcs slashdot article was first time a server of mine got slashdotted.
15:12:58 <KrispyKringle> ah, it was on slashdot?
15:13:03 <Darius> KrispyKringle: Have you played with darcs at all?
15:13:06 <KrispyKringle> i discovered it a few months ago. 
15:13:09 <KrispyKringle> yeah, i like it, Darius. 
15:13:33 <KrispyKringle> nice and lightweight. I've been using it on pet projects.  I tried to use it on a small project with two other people and it got a bit bogged down, but I'm not really sure why. 
15:13:47 <shapr> paf: have you looked at the Haskell syntax much? It's not as simple as Scheme, I agree.
15:14:01 <paf> shapr: not really
15:14:07 * shapr whips up a Haskell Wiki backup.
15:15:05 <paf> shapr: I should to install GHC first.
15:15:11 <shapr> paf: The purely functional way of thinking is fun. I learned Scheme with SICP, but for now I prefer Haskell.
15:15:45 <Darius> shapr: Ah yes, someone was asking if you knew Scheme a couple days back.
15:15:49 <Philippa> yeah. I like the way most of my "serious" typing fuckups correspond to having made what would be a really serious logic error elsewhere
15:15:58 <paf> shapr: SICP's awesome
15:16:03 <shapr> Someone was asking whether *I* knew Scheme? Whatever for?
15:16:21 <shapr> Yes, SICP is one of the two books I recommend to all programmers.
15:16:26 <Philippa> heh, reminds me - anybody got a good suggestion for something my boyfriend could work through to learn both Haskell and programming?
15:16:32 <shapr> The other book being "The Pragmatic Programmer"
15:16:35 <Philippa> about first year undergrad w/no background kinda level
15:16:42 <shapr> Philippa: maybe the Haskell Road to Maths?
15:16:54 <Philippa> is that a good call if he doesn't want to do maths with it?
15:16:57 <shapr> maybe Yet Another Haskell Tutorial?
15:17:06 <shapr> I dunno, I haven't tried the Haskell Road yet.
15:17:07 <Philippa> btw, would you recommend me SICP given that I haven't read any real amount of it?
15:17:27 <shapr> yes, I'd recommend it to anyone who has had any interested in programming ever.
15:17:39 <shapr> I'd also recommend it to your boyfriend.
15:17:44 <Philippa> he really could use something that'll walk him through a couple of pseudo-sizable projects
15:17:46 <shapr> It's just gorgeous :-)
15:17:51 <Philippa> yeah, what little I saw made me tempted to hand him it
15:17:52 <Itkovian> what's SICP?
15:18:06 <shapr> Itkovian: http://mitpress.mit.edu/sicp/
15:18:09 <Itkovian> Serious Into to Computer Programming?
15:18:11 <shapr> it's free online
15:18:14 <Philippa> Structured Interpretation of Computer Programs or something, wasn't it?
15:18:19 <paf> yes
15:18:19 <Itkovian> ah
15:18:20 <Heffalump> Structure and Interpretation of Computer Programs.
15:18:23 <Itkovian> nice
15:19:06 <musasabi> btw anyone know a good simple introduction to eigenvectors (have to teach gf and having something on the web would be nice)
15:19:14 <Itkovian> ah lisp ...
15:19:20 <Itkovian> or something that resembles it
15:19:45 <Pseudonym> http://www.sosmath.com/matrix/eigen0/eigen0.html
15:20:04 <Itkovian> eigenvectors are just cool
15:20:20 <Itkovian> s/just cool/Just Cool/
15:20:28 <shapr> I should buy a copy of SICP for my mother for her birthday. She'd like it.
15:21:00 <musasabi> Explaining math to someone who does not like it while self liking to make cute formalisms is not allways easy.
15:21:39 <shapr> hiya yome 
15:21:47 <shapr> Lotsa montreal guys around here lately.
15:21:53 <zamez> does the Alex lexer generator not work with hugs?
15:22:01 <shapr> paf: Are you in university?
15:22:03 <yome> shapr, hi
15:22:09 <KrispyKringle> what's with all this teaching significant others about computer science?
15:22:42 <shapr> yome: Have you been here to #haskell before?
15:22:48 * shapr thinks so
15:22:51 <Philippa> KrispyKringle: he's a geek, and he'd probably actually enjoy talking shop with me if he knew WTF I was talking about
15:23:01 <KrispyKringle> haha
15:23:04 <KrispyKringle> ok
15:23:12 <KrispyKringle> what's he study, Philippa ?
15:23:16 <KrispyKringle> or do, as the case may be. 
15:23:20 <paf> shapr: yes
15:23:34 <shapr> paf: lemme guess, computer science?
15:23:41 <Philippa> in theory, microbiology. In practice, figuring out how to get his life running again after a bout of depression and some really major personal issues
15:23:56 <paf> shapr: EE
15:24:01 <shapr> oh neat
15:24:21 <KrispyKringle> Philippa: ah. Um, wish him luck from me on that. 
15:24:24 <shapr> What's the difference between EE and CS?
15:24:31 <shapr> I've always wondered that.
15:24:44 <Philippa> most compsci courses these days don't touch the physical engineering at all
15:24:57 <shapr> like, no electronics?
15:25:08 <Philippa> you go as low as machine code, learn what's relevant about CPU architecture at that level (pipelines, caches) and that's it
15:25:14 <yome> shapr, yes, I've been around a few times.  I was T.A. for a Haskell course and had a few questions...
15:25:38 <KrispyKringle> shapr: in my experience, they require some basic hardware, digital circuits, but that's it. 
15:26:15 <shapr> yow
15:26:16 <Itkovian> shapr: it depends what you study. when you take an engieering approach, you get down to the bottom of things ... when you take computer science as such, you don't
15:26:30 <Philippa> KrispyKringle: you're lucky. There was an optional "how to design" course here, about the level of "this is a flip-flop, this is a karnaugh(sp) diagram", that's it
15:26:38 <Itkovian> Engineering is 5 years, Cs used to be four, but now with the stupid bachelor/master stuff it'll be years as well
15:26:39 <Pseudonym> One of my favourite textbooks which I came across was for a digital design subject.
15:26:46 <Pseudonym> The first half of the book was theory.
15:26:51 <Itkovian> In Belgium, that is
15:26:54 <Pseudonym> The second half was "let's build a PDP-7".
15:26:57 <Philippa> hehehe
15:26:59 * Heffalump has been learning lots about CPU design lately
15:27:07 <KrispyKringle> Philippa: I haven't taken it yet, but I am required to take digital circuits and an accompanying lab. I'm not so into the real low level stuff, so I'm a tiny bit trepeditious. But I'm sure it's useful to know. 
15:27:10 <Philippa> I keep meaning to learn SystemC
15:27:15 <KrispyKringle> Philippa: are you a student?
15:27:17 <Philippa> labs? You lucky, lucky bastard
15:27:18 <Pseudonym> A PDP-7 is apparently the most complex machine you can really build in n hours a week for a semester.
15:27:18 <Philippa> yep
15:27:28 <Pseudonym> Out of MSI components, anyway.
15:27:46 <KrispyKringle> Philippa: lyeah, they use Xylinx to design a CPU, apparently. 
15:27:50 <wli> it'd be nice if there were a remotely tractable silicon compiler
15:28:01 <KrispyKringle> Supposed to be one of the more intense courses, though, perhaps alongside Operating Systems. 
15:28:04 <shapr> Huh, I got lucky. My father had an electronics book that went from transistor up to microprocessor in just a few pages.
15:28:09 <wli> verilog/vhdl are crappy
15:28:16 <shapr> Lava is really cool.
15:28:23 <zamez> should I be using ghc instead of hugs?
15:28:27 <shapr> I only wish it didn't require all the Xilinx tools.
15:28:33 <Pseudonym> zamez: Maybe.
15:28:35 <Heffalump> zamez: probably, yeah.
15:28:37 <shapr> zamez: I think hugs is preferred for the Sharp Zaurus.
15:28:38 <Heffalump> ghci is pretty good
15:28:42 <wli> lava is unobtainable and for all intents and purposes no longer exists
15:28:42 <Philippa> KrispyKringle: it's not too bad so long as you bear in mind you need to get things right before you build on them
15:28:45 <Heffalump> the only benefit of hugs is the quicker startup time
15:28:45 <Pseudonym> If your course uses hugs, you should use hugs.
15:28:50 <Pseudonym> But most people prefer GHCi.
15:28:54 <Philippa> the rest's just same old same old, you just have a mildly different set of abstractions AFAICT
15:29:00 <KrispyKringle> Philippa: i have poor impulse control. I tend not to plan ahead. 
15:29:02 <shapr> wli: Satnam Singh tells me otherwise... but admittedly, I haven't seen any results yet.
15:29:02 <monochrom> If you have already installed one of them, don't bother switching.
15:29:04 <KrispyKringle> (just kidding)
15:29:06 <Philippa> (until something weird like capacitance bites you in the arse)
15:29:06 <paf> shapr: when i try to ./configure ghc, it says GHC is required unless bootstrapping from .hc files. Why?
15:29:19 <shapr> paf: GHC is written in Haskell.
15:29:24 <zamez> I'm not taking a course, Pseudonym :>
15:29:31 <yome> paf, use the binary...
15:29:33 <wli> shapr: can you get lava?
15:29:34 <Philippa> er, gotta call pizza place, yell about the ice cream they failed to deliver. BRB.
15:29:35 <monochrom> If you haven't, I suggest ghc, unless you require hugs by way of Haskell School of Expressions.
15:29:40 <shapr> paf: are you using Linux, windows, or macos?
15:29:49 <paf> shapr: Linux
15:29:55 <shapr> paf: which distribution?
15:29:56 <wli> shapr: since the answer is "no", Ockham's razor does the rest
15:30:00 <shapr> heh
15:30:01 <paf> Fedora Core I
15:30:04 <shapr> wli: fair enough :-)
15:30:55 <shapr> paf: will redhat 9 rpms work on fc1?
15:31:05 <Heffalump> you could try asking Koen Claessen for Lava
15:31:12 <paf> shapr: I hope so, I'm downloading it..
15:31:18 <shapr> bah, I asked him for QuickCheck2, and haven't gotten anything.
15:31:33 <shapr> Anyway, I think Peter Gammie's project is the new Lava that Satnam Singh is talking about.
15:31:56 <wli> shapr: where is that?
15:32:24 <shapr> being designed... Pete's blog is http://gungnir.csbnet.se/~peteg/blog/
15:32:55 <shapr> I'll ask Satnam Singh what he was referring to when he said an open source Lava was on the way.
15:33:03 <Heffalump> when did he say that?
15:33:08 <musasabi> lava?
15:33:13 <shapr> six weeks ago I think
15:33:21 <Heffalump> that's promising, then
15:33:41 <shapr> I send him emails every once in awhile, I still want to program an FPGA coprocessor in Haskell.
15:33:46 <Heffalump> if he'd said that before he left Xilinx I'd have been suspicious :-)
15:34:05 <shapr> paf: how did you end up learning Scheme and Haskell? Is it part of your EE requirements?
15:34:05 <KrispyKringle> `so why does the aboutHaskell page recommend Hugs for beginners? 
15:34:22 <Heffalump> you want Fergus's job, then :-) [http://www.cs.mu.oz.au/~fjh/]
15:34:24 <paf> shapr: not at all
15:34:37 <Philippa> easier to build, used to be easier to use
15:34:44 <Heffalump> cos hugs used to be the beginners tool, but probably isn't now?
15:34:50 <paf> shapr: My roommate's a geek, and he's really convincing.
15:34:52 <shapr> Singh did say Xilinx he would release an open source Lava before he left Xilinx, but later emails seemed to ignore that :-)
15:34:58 <Philippa> and I think it used to have a few good libraries for doing pretty stuff for beginners
15:35:00 <shapr> paf: haha, cool!
15:35:05 <Philippa> the Haskell equivalent of an on-screen turtle
15:35:10 <Pseudonym> Hugs still runs on platforms that GHC doesn't.
15:35:20 <shapr> paf: Does your roommate also come to #haskell? Maybe I know this person?
15:35:32 <Philippa> Pseudonym: true
15:35:41 <wli> you mean Fergus Henderson is not far from me?
15:35:49 <Philippa> that doesn't necessarily make it a good beginner's choice except where that's an issue though
15:35:52 <shapr> I thought you were in VA?
15:35:54 <Heffalump> I doubt that's a significant advantage, since ghci runs on most common platforms.
15:35:59 <wli> moi? non
15:36:03 <wli> pdx
15:36:06 <paf> shapr: you saw him before
15:36:16 <Philippa> I guess one thing that used to hold was that Hugs didn't let you mess around with 'dangerous' ideas as much (unless you enabled the extensions ;-)
15:36:18 <shapr> paf: I've seen your roommate? In person?
15:36:28 <Heffalump> pdx?
15:36:33 <shapr> paf: Wolfgang Thaller?
15:36:42 <wli> heffalump: airport code
15:36:48 <Heffalump> ah. What for?
15:36:55 <Heffalump> Portland?
15:37:04 <wli> Heffalump: y
15:37:38 <shapr> wli: if you're in Portland, you should meet SyntaxNinja. He's just moved there and he's a really cool person.
15:37:45 <shapr> He's also working for Galois.
15:37:49 <Heffalump> why'd he move there? ah :-)
15:37:59 <Heffalump> is there anyone who doesn't work for Galois?
15:38:06 * shapr slowly raises his hand.
15:38:25 <Heffalump> apart from shapr and I, of course.
15:38:31 <monochrom> I work for my degree.
15:38:36 <shapr> I suspect that galois doesn't really need my skills :-)
15:38:42 * stepcut raises his hand
15:38:48 * Pseudonym raises his hand
15:38:50 * shapr raises stepcut's other hand
15:38:52 <tuomov> _o/
15:38:59 * Pseudonym lowers his foot
15:39:04 <Heffalump> I wonder if Oregon has any meteorolgy research
15:39:05 * stepcut wags his tail
15:39:13 * wli is a kernel hacker for Oracle (yes, the big database .com)
15:39:28 <shapr> wli: last I heard you were working for Big Blue.
15:39:33 <Pseudonym> Aaargh!  Wli is my competitor!
15:40:54 <shapr> Galois must be hopping.
15:41:04 <Heffalump> Pseudonym: competitor how?
15:41:07 <yome> shapr, hey, it seems I
15:41:09 <yome> oops
15:41:16 <wli> shapr: They screwed with me, so I walked. There's a longer story there if you need to hear it.
15:41:16 <Heffalump> is your uni being threatened by an Oracle monstrosity?
15:41:20 <yome> I'm the geek roommate... ;)
15:41:23 * Pseudonym is also in the database business
15:41:27 <shapr> yome: greetings geek roomie!
15:41:32 <Darius> Didn't Isaac used to work for Aetion?
15:41:55 <wli> Pseudonym: IIRC you do something rather different
15:42:01 <shapr> wli: I can understand that. I am happy to meet people who do not tolerate being screwed with.
15:42:04 <KrispyKringle> wli: I want to hear it, if you don't mind. :) IBM is potentially a prospective employer for me. 
15:42:09 <wli> Pseudonym: oracle will never do that kind of stuff worth a damn
15:42:12 <Heffalump> Pseudonym: I thought you developed stuff for a uni, though, rather than writing core database software
15:42:16 <KrispyKringle> (so I'd want to know if they're evil)
15:42:16 <shapr> Darius: yes, that's true.
15:42:21 <Pseudonym> wli: We write core database software.
15:42:25 * tuomov is in the out-of-job-trying-to-figure-out-what-to-do-next business
15:42:32 <Pseudonym> Text databases, admittedly, but still databases.
15:42:35 <Heffalump> ah
15:42:52 <Pseudonym> We used to be a university research project, we're now a wholly-owned company, more or less.
15:43:05 <Pseudonym> And the university is looking to sell us off right about now.
15:43:10 <shapr> paf: The only scary part is that there's more after Scheme and Haskell. Smalltalk and Joy and Forth and so many beautiful and elegant ways to express ideas. I am so happy I found programming!
15:43:13 <Heffalump> ARM are recruiting graduates if anyone is interested in C compiler hacking, btw..
15:43:36 <shapr> I'd work for SPJ & co for barely enough money to survive.
15:44:06 * Darius got/is held up writing a dynamic compiler because he doesn't feel like making a register allocator.
15:44:08 <paf> shapr: I looked at Smalltalk and forth too. Forth looks nice uControllers programming.
15:44:14 <Darius> (for the x86)
15:44:22 <shapr> hej bisby, vad hnder?
15:44:41 <paf> shapr: But I never wrote a line with these, I need more time.
15:44:44 <bisby> ska strax sova. 
15:44:55 <shapr> bra id, jag ocks
15:45:28 <Oeje1> Ocks jag.
15:45:44 <Heffalump> $$!$$!
15:45:46 <bisby> is this correct to sort a file:
15:45:47 <monochrom> Bear in mind IBM is large.  One group mistreating its member doesn't mean all other groups are equally bad.
15:45:48 <bisby> readFile 'in" >>= writeFile "out" . unlines . sort . lines
15:45:54 <shapr> paf: There are many beautiful and elegant ideas waiting. Programming is like the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
15:45:58 <Heffalump> bisby: it's one way, yes.
15:46:06 <Heffalump> were you listening to the conversation earlier? :-)
15:46:09 <Darius> Smalltalk is interesting to look at but it kind of pisses me off.  It makes me dislike aspects of OO from a different approach than most "OO" languages do.
15:46:10 <Pseudonym> That's so poetic.
15:46:22 <bisby> yes i was
15:46:34 <Pseudonym> Though if my server was fuelled by ideas, I wouldn't have such a big power bill.
15:46:40 * shapr laughs
15:46:47 <bisby> i'm trying to connect that line to the theory of the monad
15:47:00 <monochrom> The IBM Toronto lab is cool.  I have friends working there and some other friends worked there.  They all say it's a good working environment.
15:47:01 <Spark> thats what attracts me about compsci really
15:47:04 <Spark> computation = thinking
15:47:05 <Spark> :)
15:47:08 <shapr> Spark: yes!
15:47:11 <monochrom> But beware of the snow. :)
15:47:20 <Spark> we make the brains, everyone else makes the brawn
15:47:20 <shapr> Pseudonym: oh hey, did I already ask you for the real name of this "datics" idea?
15:47:22 <Spark> braun?
15:47:25 <paf> shapr: very poetic
15:47:29 <Itkovian> I  know a few people who stayed a while a IBM TJ Watson, and I didn;t hear any complaints...
15:47:35 <shapr> Spark: von braun? =) rocket science? 
15:47:38 <Pseudonym> shapr: Nope.
15:47:46 <shapr> Spark: that was very punny
15:47:48 <Pseudonym> What's datics?
15:47:49 * shapr steals that joke
15:48:03 <shapr> Pseudonym: best word I can find for the idea of "notions of computation"
15:48:12 <shapr> I've been writing about this in my blog
15:48:24 <shapr> slide rules, abaci, vedic maths, spoken cryptography
15:48:25 <tuomov> sigh. to try to get a job, or to try to start graduate (post-m.sc) studies, is too difficult a problem.
15:48:35 <shapr> My hypothesis is that programming is not for computers.
15:48:48 * stepcut programs people
15:49:01 <monochrom> bisby's program looks right.  I haven't checked operator precedence.
15:49:02 <shapr> Programming is just tools for manipulating ideas, and we happen to focus on the silicon oriented subset of that
15:49:07 <Darius> Instead computers should support bags of Doritos.
15:49:16 <shapr> stepcut: no matter how many times I try to debug my cats, they still crash.
15:49:35 <stepcut> shapr: did you see this article: http://www.kuro5hin.org/story/2004/12/12/152529/56
15:49:43 <Itkovian> monochrom: it is ok, if you replace the first ' with a "
15:50:03 <shapr> Pseudonym: anyway, datics is to data as physics is to the physical world
15:50:06 <monochrom> Heh yeah
15:50:22 <bisby> shouldn't that program return a function of the kind s->(s,a)?
15:50:26 <Pseudonym> Physics has two questions to answer about the physical world.
15:50:30 <Pseudonym> "What" and "why".
15:50:41 <Pseudonym> How would you relate this to "datics"?
15:50:46 <monochrom> No, IO () is the type
15:50:50 <shapr> Pseudonym: "how"
15:50:52 <Pseudonym> And more importantly, how do you distinguish datics from mathematics?
15:50:59 <shapr> I'm not sure I can.
15:51:00 <Spark> shapr: purely accidental im afraid, but im not going to admit that :)
15:51:41 <Darius> bisby: Crap, you've poked one of my sore points.  Monads are not state passing.
15:51:43 <monochrom> @type readFile "in" >>= writeFile "out" . unlines . sort . lines
15:51:44 <lambdabot> bzzt
15:51:45 <Spark> tuomov: a coin can solve all problems, no matter how difficult
15:51:47 <Spark> and its decidable :)
15:51:50 <Itkovian> bisby: if you look at the types it will become clear
15:51:57 <Spark> unsound, but decidable
15:51:57 <shapr> but then, how can you separate physics and math?
15:51:58 <Itkovian> @type readFile "lll"
15:51:59 <lambdabot> readFile "lll" :: IO String
15:52:06 <Itkovian> @type (>>=)
15:52:07 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
15:52:07 <tuomov> what if the coin lands on its side?
15:52:22 <Itkovian> @type (unlines . Data.List.sort . lines)
15:52:23 <lambdabot> (unlines . Data.List.sort . lines) :: String -> String
15:52:27 <Spark> you stop taking drugs
15:52:37 <Itkovian> @type writeFile "kkk" . unlines . Data.List.sort . lines
15:52:38 <lambdabot> writeFile "kkk" . unlines . Data.List.sort . lines :: String
15:52:38 <lambdabot> 						      -> IO ()
15:52:43 <shapr> Physics is a subset of math aimed at the physical world. Datics is a subset of math, aimed at how data interacts?
15:52:55 <bisby> Darius: what do you mean that i poked one of your sore points?
15:52:58 <monochrom> right, forgot sort is List.sort
15:52:58 <shapr> I dunno, "notions of computation" is the concept, but I don't have a great word for it.
15:53:15 <Pseudonym> The other problem is that physics is half experimental.
15:53:27 <shapr> programming is more than half experiment :-)
15:53:30 <Pseudonym> What is the experimental part of datics, if not tied ot physical machines?
15:53:33 <Pseudonym> Yes, it is.
15:53:34 <Itkovian> bisby: thus we go from IO String via IO String -> (String -> IO() ) -> IO ()
15:53:42 <shapr> datics can still be experimental
15:53:42 <Pseudonym> However, the experimentation is grounded in silicon.
15:53:56 <shapr> discover interactions, then automate them.
15:53:59 <Darius> bisby: A lot of people coming into Haskell identify monads with state passing and a lot of documents geared towards beginners reinforce this notion.
15:54:14 <Itkovian> true
15:54:29 * shapr agrees with Darius 
15:54:30 <bisby> Darius: you mean that's the wrong approach?
15:54:53 <shapr> it's like saying all cars are saab
15:54:58 <Itkovian> I think it is one approach, but there are other things they can be thought of
15:55:00 <Darius> bisby: Monads can be used for much more than state passing.  State passing is just one instance.
15:55:29 <Darius> bisby: And state passing is not "the idea" behind monads.
15:55:47 <shapr> stepcut: I like this article, thanks.
15:55:49 <bisby> Darius: so for the readFile example the state passing is not the ideal way to understand it?
15:55:57 <shapr> stepcut: this is another good instance of the idea of "notions of computation"
15:56:05 <monochrom> I am labouring to write some slides that explains monads starting from list comprehension.
15:56:34 <shapr> I'm looking for more of these examples. They're easy to find, but very few are documented from a perspective that makes it easy to discuss them as notions of computation.
15:56:37 <Darius> For IO, it's one possibility.  IO can be thought of as "passing the state of the world", but it isn't the only possibility nor necessarily the best.
15:56:59 <Darius> bisby: But IO is still again, only one instantiation of the Monad idea.
15:57:01 * Itkovian is off to bed
15:57:03 <Itkovian> gdnight
15:57:06 * shapr is on to bed
15:57:08 <Darius> bisby: And a rather odd one at that.
15:57:09 <monochrom> I actually agree with that, despite my comments some days ago.
15:57:14 <shapr> g'night Itkovian 
15:57:46 <bisby> Darius: do you know a web page that explains monads in a good way, for a beginner.
15:58:07 <monochrom> On the some vein, a FIFO queue doesn't have to be a list.  (Why can't it be a BST and a counter?)
15:58:09 <Darius> The nomaware one is pretty good.
15:58:43 <Darius> http://www.nomaware.com/monads/html/
15:59:02 <wli> isn't the normal imperative implementation a singly linked list with head and tail pointers?
15:59:32 <bisby> Darius: ok, i'm will spend the rest of this year trying to lean about monads from that page.
15:59:51 <shapr> bisby: bah, it'll only take you a few days at most.
15:59:54 <monochrom> normal implementations are besides the point.
16:00:19 * Darius doesn't really get what monochrom's point is...
16:00:29 <Darius> Oh
16:00:32 * Darius now he does
16:01:00 <bisby> maybe, i'm will do my best.
16:01:06 <monochrom> Although I have a pedagogical dilemma here.  How should I explain FIFO queues to newbies?  Should I write down the abstract axioms?  Should I just start with the linked list, the implementation that everyone loves?
16:01:32 <Darius> bisby: There are plenty of other ways of approaching monads than just the approach used in that tutorial
16:02:01 <bisby> Darius: yes, but where can i find those?
16:02:03 <Darius> monochrom: By analogy with real-life queues (?)
16:02:22 <shapr> monochrom: I'd use a physical analogy that everyone already knows. Maybe a toll bridge, ticket window, or something.
16:02:48 * vincenz throws a lambda at shapr 
16:02:55 * shapr ducks
16:03:03 * vincenz eeks as it flies back into his face
16:03:33 <monochrom> The queue is a familiar concept to everyone in modern society.  By the age of 3 we are all taught the politeness and protocol of lining up.  Mother points at a line-up and tells you, "child, that's called a line-up, we should do that because we are polite people."
16:04:03 <shapr> sounds good to me
16:04:25 <monochrom> Note that this boils down to pointing at a linked list with a fixed convention of adding at one end and removing at the other as "queue".
16:04:35 <vincenz> monochrom: you've never been to italy, have you?
16:04:41 <Pseudonym> A stack is actually more rare in nature than a queue.
16:04:50 <Darius> bisby: http://www.haskell.org/hawiki/UsingMonads and http://haskell.org/bookshelf/#monads are places to start
16:04:52 <Riastradh> What about pancakes, Pseudonym?
16:04:58 <shapr> pannkakor!
16:05:00 <wli> a functional priority queue might be spiffy to have
16:05:06 <Riastradh> wli, go read Okasaki.
16:05:11 <Pseudonym> I eat pancakes in the order that I want, not necessarily top-to-bottom.
16:05:13 <shapr> Riastradh: http://www.scannedinavian.org/~shae/kanin.jpg
16:05:15 <wli> well, I wrote one
16:05:20 <wli> just winging it
16:05:25 <Pseudonym> And they need not be stacked bottom-to-top in the order that they were cooked.
16:05:26 <vincenz> Pseudonym: top to bottom is best, you're eatin the hottest one
16:05:27 <wli> I meant rather as an example.
16:05:35 <monochrom> To explain the stack, your father brings you to a restaurant and point at that stack of pieces of papers containing orders.
16:05:36 <Riastradh> Fine, Pseudonym, so you have a random-access stack.
16:05:45 <Pseudonym> The top pancakes act as insulators for the pancakes underneath, though.
16:05:45 <vincenz> stack?
16:05:47 <vincenz> you mean array
16:05:53 <vincenz> or rather
16:05:55 <vincenz> linked list
16:05:55 <Riastradh> No, I mean stack.
16:05:59 <vincenz> stack implies top to bottom
16:05:59 <Pseudonym> The bottom ones retain heat better.
16:06:05 <vincenz> queue implies bottom to top
16:06:10 <vincenz> aka fifo
16:06:16 <vincenz> stack is lifo
16:06:21 <vincenz> random access would be a list
16:06:22 <Riastradh> Therefore, Pseudonym, you have to eat the top ones first before they get cold; the bottom one's will be OK until the end.
16:06:36 <wli> monochrom: 1st class vs. business class vs. cattle class airport boarding pass lines == Real Life (TM) priority queue example?
16:07:25 <monochrom> So, two of the most important, supposedly abstract data types, we learn them by looking at the normal implementations, not the properties.  And it seems it is the only way that gets through to the students.  But you know its shortcomings.  I don't know how to resolve this.
16:07:28 <shapr> salut viv 
16:07:29 <vincenz> wli: with exceptions such as old people and kids
16:07:45 <shapr> viv: comment a va?
16:07:51 <Riastradh> monochrom, why don't you use the real-life analogies?
16:08:19 <Darius> bisby: Reading "How to Declare an Imperative" is probably a good idea too.
16:08:25 <monochrom> I am not against that, Riastradh.  I am asking a question I don't know how to answer.
16:08:41 <vincenz> is it possible to create a linked list in a purely functional language?  more specifically a doubly linked one?
16:08:47 <shapr> viv: Mon monocycle est au taquet!
16:08:55 <Riastradh> Yes, vincenz.
16:09:18 <Riastradh> data DoubleList a = Nil | Link (DoubleList a) a (DoubleList a)
16:09:19 <shapr> I wonder if canadian french uses au taquet also
16:09:31 <vincenz> Riastradh: euhm
16:09:31 <shapr> anyway, time for sleep.
16:09:34 <Riastradh> Regular lists are built-in to almost all functional languages, including Haskell.
16:09:39 <vincenz> yes
16:09:48 <vincenz> but I mean wiht access times that you expect of a doubly linked list
16:09:49 <vincenz> meaning
16:09:53 <vincenz> O(1) removal
16:09:53 <shapr> paf: nice to meet you, I hope we get to chat more :-)
16:10:03 <wli> well
16:10:10 * shapr disappears
16:10:17 <wli> you will effectively need a functional interface to references to accomplish that
16:10:30 <vincenz> then it's not purely functional anymore
16:10:31 <Riastradh> No, you don't, wli.
16:10:35 <Riastradh> Laziness suffices.
16:10:47 <vincenz> doubly linked lists in ocaml were implemented with side-effects
16:10:48 <paf> shapr: i'll try some thing tonight, i'll tell you who it was some other day.
16:10:51 <wli> Riastradh: for O(1) removal doubly-linked lists?
16:10:51 <vincenz> (see extocamllib)
16:11:20 <Riastradh> let x = Link Nil 5 y; y = Link x 3 Nil in x  -- There, a two-element doubly-linked list.
16:11:45 <vincenz> Riastradh: O(1) removal..
16:11:46 <wli> Riastradh: can you show how to implement O(1) removal with that?
16:12:03 <vincenz> the whole idea behind doubly linked lists is exactly that O(1) mutations
16:12:23 <Riastradh> Oh, sorry, I thought that by 'that' you just meant doubly-linked lists, wli.
16:12:23 <vincenz> or people would use single linked lists
16:12:55 <Riastradh> You can still, of course, use IORefs or something, I'm sure.
16:13:12 * vincenz is not familiar with haskell
16:13:20 <wli> well, let's see
16:13:36 <vincenz> doesn't that imply non-purely-functional on some layer?
16:14:04 <wli> you get different cases depending on intensional equality
16:14:11 <Riastradh> Yes, because what you suggest, O(1) in-place removal, is inherently impure.
16:14:15 <Riastradh> The interface, however, is still pure.
16:14:26 <vincenz> Riastradh: they're inherently the reason behind doubly-linked-lists
16:14:42 <vincenz> double-linkage serves no other purpose
16:14:51 <vincenz> (only adds overhead)
16:15:08 <Darius> vincenz: It allows backward and forward traversals.
16:15:28 <vincenz> Darius: a minor issue
16:15:40 <vincenz> backward traversals is still O(N) for single linked lists
16:15:47 <wli> remove (List _ (List x xprev xnext) (List y yprev ynext)) = let { u = List x xprev v ; v = List y u ynext } in u?
16:15:49 <wli> no
16:15:56 <wli> that can't do
16:16:27 <wli> for one this doesn't work on a list of a single element
16:16:33 <Pseudonym> BRB
16:16:37 <vincenz> consider a circular list, where there's no 'head', the head is whatever you're holding at the moment
16:17:47 <wli> you basically have a handle and then a circular structure but you need intensional equality to decide whether to empty it or not
16:18:02 <bisby> Darius: ok, i've bookmarked your links. thx.
16:19:45 <wli> or otherwise some method of deciding equality for some trivial case of cyclic structures
16:21:47 <Riastradh> Why do you need any form of equality comparison?
16:22:03 <Darius> wli,vincenz: Given imperative mutation, how would you go about making a persistent doubly-linked list?
16:22:21 <vincenz> Darius: ?
16:22:30 <wli> Darius: persistent is another question...
16:22:35 <vincenz> prsistent is?
16:23:08 <Philippa> vincenz: hangs around between executions. Potentially, the most recent version hangs around even if some bastard yanks the plug at random
16:23:27 <Darius> vincenz: One of the reasons for different time complexities is in a purely functional languages all previous versions of a data structure are available.
16:23:29 <vincenz> I meant in this context
16:23:59 <vincenz> Darius: then it inherently becomes O(N)
16:24:15 <Darius> vincenz: Not necessarily.
16:24:26 <vincenz> how so?
16:25:23 <Darius> vincenz: It may in this case, but already a versioning approach may yield better efficiency.
16:25:34 <vincenz> versioning?
16:26:49 <vincenz> each item has multiple pointers?
16:26:58 <vincenz> with a hashtable version->set of pointers
16:27:29 <Darius> vincenz: You could simply mark deleted nodes as deleted in the next version.  The older version can ignore the mark and newer versions can honor it.
16:28:42 <vincenz> then it wouldn't really be O(N) where N is the abstract length of the current version
16:30:22 <Darius> vincenz: What wouldn't? and that's the point.
16:31:03 <vincenz> nm
16:51:55 <Sava> hiya, just a quick newbie question. Im writing a postorder traversal function (its the last question of an assignment, so i dont want a raw solution!) and it has the following definition:
16:51:56 <Sava> > post_order :: Eq a => [a] -> Gtree a -> ([a], [a])
16:52:23 <Sava> What exactly does the Eq a => [a] parameter mean? I havent come across it before...?
16:52:39 <Pseudonym> OK, that's not a parameter all on its own.
16:52:49 <Pseudonym> (Eq a) => is a context for the type that follows.
16:53:19 <Pseudonym> If you think about it as a logical implication, you can read it this way:
16:53:28 <Sava> so how is it different to post_order :: [a] -> Gtree a -> ([a],[a])
16:53:31 <Sava> ?
16:53:38 <Pseudonym> "If (Eq a), then post_order_ has type [a] -> Gtree a -> ([a],[a])"
16:54:13 <Pseudonym> The context in this case means that a must be comparable using equality.
16:54:26 <Pseudonym> i.e. == must work on objects of type a.
16:54:27 <Sava> ahh ok :)
16:54:38 <Sava> that makes sense to me (thats actually quite helpful), cheers :]
16:54:45 <Pseudonym> The difference is that in the other type, a need not have == defined on it.
16:54:47 <Pseudonym> Right.
16:55:01 <Sava> Iv basically taught myself everything i know about Haskell in the last 2 days =/ been quite hard work
16:55:22 <Pseudonym> Yeah, if you've never done functional programming before, it can be hard.
16:55:31 <Pseudonym> But the mathematical-like notation helps a lot.
16:55:41 <Sava> done a lot of C programming before, so find it quite difficult to adjust
16:55:55 <Sava> im getting there though :] im determined to finish this last question though lol
16:55:58 <wli> I'm used to flipping paradigms.
16:56:13 <Pseudonym> You're doing extremely well (or you're just very smart) if you're asking a question like that after two days, and understanding the answer.
16:56:13 <Sava> gonna be here all night me thinks :(
16:56:34 <Pseudonym> If you're very smart, stick around.  We like smart people.
16:56:36 <Pseudonym> And donuts.
16:56:37 <Sava> lol
16:56:39 <Sava> so i see!
16:57:07 <np_hard> i am not used to flipping paradigms
16:57:22 <np_hard> my javascript and perl code have distinctly functional flavor
16:57:40 <Pseudonym> All my code is multi-paradigm.
16:57:45 <Pseudonym> It helps that I don't touch Java.
16:57:59 <np_hard> python is still relatively untouched, the language is designed against a functional style
16:58:07 <Riastradh> My code uses the paradigms that suit it best.
16:58:09 <Sava> well, on sunday i spent maybe 2 hours trying to write a function that took a string in form base.ext and turned it into a data type File that has a string basename and string extension
16:58:22 <np_hard> i have shied away from java until i got a coworker interested in jython
16:58:22 <Sava> i like to think i could do it again in a little less than 2 hours this time lol
16:59:12 <wli> Pseudonym: how are you interfacing logic languages to functional languages/
16:59:13 <wli> Pseudonym: how are you interfacing logic languages to functional languages?
16:59:31 <Darius> Curry
17:01:18 <Darius> Or "Typed Logical Variables in Haskell", but multi-paradigm doesn't mean pan-paradigm.
17:04:01 <Pseudonym> wli: I'm not.
17:04:12 <Pseudonym> I am, however, doing logic programming in Haskell.
17:04:20 <Pseudonym> Strongly-moded, of course.
17:04:36 <Pseudonym> Actually, my Haskell code sometimes has a distinctly C++ flavour to it.
17:04:36 <wli> ever thought about mercury? it's got native logic programming
17:04:47 <Pseudonym> wli: I've thought about Mercury far too much, thankyou.
17:05:04 <wli> Pseudonym: I don't know what that means.
17:05:12 <Darius> hqh
17:05:17 <Darius> er heh
17:05:25 <Pseudonym> I rewrote Mercury's mode checker once upon a time.
17:05:33 <Pseudonym> I also wrote large slabs of the standard library.
17:05:41 <Pseudonym> Never again.
17:06:08 <Pseudonym> Mercury is a logic language with some functional syntax.
17:06:21 <Pseudonym> That's different from being a logic/functional language.
17:06:23 <Darius> Pseudonym: What is C++'s flavour (at least outside of C++).
17:06:42 <Pseudonym> Darius: I use lots of reified types and policy-based typeclasses.
17:06:54 <Darius> Ah, modern C++, I see.
17:06:57 <Pseudonym> Yes.
17:07:10 <Pseudonym> That sort of thing fits quite nicely with Haskell.
17:07:16 <Pseudonym> Or it would if we had true dependent types.
17:07:21 <wli> Pseudonym: whoa, I probably know your name from somewhere
17:07:21 <Pseudonym> But you can get 80% of the way there with fundeps.
17:07:29 <Darius> Well, C++ possibly has the most powerful type system of all even remotely mainstream languages.
17:07:45 <wli> Darius: sad comment about mainstream langs if so
17:07:54 <Pseudonym> wli: Any piece of code in the Mercury compiler with "bromage" on it was me.
17:07:56 <Darius> It'd actually be pretty cool if it wasn't an accident.
17:08:11 <Darius> wli: Most languages try to rein in their type systems.
17:08:12 <Pseudonym> I'm not sure that C++ has the most powerful type system.
17:08:14 <wli> Pseudonym: okay, I know who you are =)
17:08:17 <Pseudonym> It has the most complex type system.
17:08:20 <wli> Darius: not sure what you mean
17:08:22 <Pseudonym> wli: Good.  Who are you?
17:08:25 <Pseudonym> :-)
17:08:28 <Darius> (well of the ones that argubly have "advanced type systems")
17:08:42 <Darius> wli: Most like decidability.
17:08:44 <wli> Pseudonym: I'm "wli" everywhere I'd ever be known for doing anything.
17:08:49 <Pseudonym> Ah. :-)
17:09:11 * Pseudonym used to have the desk next to Fergus
17:09:37 <wli> Pseudonym: I've never done anything significant in mercury apart from utility -type stuff. I basically abuse these research languages as scripting languages for math geeks and don't do much large with them.
17:09:47 * Pseudonym laughs
17:09:57 <Pseudonym> Well, then, you can understand my biggest problem with Mercury, then.
17:09:58 <wli> dead serious
17:10:12 <Pseudonym> Have you ever looked at e.m?
17:10:14 <wli> Pseudonym: Not sure what that was supposed to be.
17:10:15 * np_hard used haskell for some simple code generation tasks at work
17:10:16 <Pseudonym> The example program.
17:10:26 <wli> Pseudonym: I can't say I have, no.
17:10:34 <np_hard> tab-separated file parsing, etc. the PackedString IO seems a bit slow
17:10:43 <Pseudonym> Well, take a look at it some time.
17:10:56 <Pseudonym> What is a simple thing to express in a functional language is horrible in Mercury.
17:11:08 <Pseudonym> And it's all because of the mode system.
17:11:17 <Pseudonym> Haskell, for example, has very simple dataflow.
17:11:31 <Pseudonym> Lazy evaluation complicates the operational semantics.
17:11:39 <Pseudonym> But the meaning is clear: Arguments go in, results come out.
17:11:58 <Pseudonym> Mercury requries you to declare that.
17:12:04 <Pseudonym> Including in higher-order data structures.
17:12:15 <Darius> np_hard: There's a FastString library in darcs that's allegedly faster.
17:12:27 <Pseudonym> Storing functions/predicates in data structures requires that the modes of those functions/predicates be declared.
17:12:36 <Pseudonym> In the definition of the data structure.
17:12:42 <wli> Pseudonym: mostly I use it for complex value/context -sensitive parsing problems
17:12:46 <Pseudonym> It makes programming that way very difficult.
17:13:13 <wli> Pseudonym: I don't try to use it where it would be easier to do things in e.g. Haskell
17:13:14 <Pseudonym> I think this is such a serious problem, in fact, that it means that Mercury is, unless you just want a modern 1976-era ML, useless.
17:13:29 <Pseudonym> Except as a proof-of-concept.
17:13:56 <Pseudonym> There are about two research hurdles yet to be overcome before Mercury is ready for general-purpose programming.
17:14:03 <Pseudonym> One is the mode system, the other is syntax.
17:14:24 <Pseudonym> Though the syntax issue isn't a huge hurdle.
17:14:27 <wli> Pseudonym: I don't know. I like having it around for the occasional problem that its execution model blows away in basically one step.
17:14:28 <Pseudonym> It's just work that someone has to do.
17:14:37 * Pseudonym nods
17:14:48 <Pseudonym> I wrote a logic programming monad for this precise purpose.
17:14:52 <wagle> whats the problem with the mode system?
17:15:08 <wli> Pseudonym: I have to confess it's rarer for it to be the easiest way to express things.
17:15:09 * Pseudonym points wagle to the above discussion of higher-order data structures
17:15:16 <Philippa> <Pseudonym> I'm not sure that C++ has the most powerful type system. <- give or take messing about with compilation unit issues, C++ appears to have the most powerful type system usefully possible in a programming language AFAICT (turing complete, capable of generating new values, capable of taking values into the type system). The syntax, however, makes brainfuck look pretty
17:15:16 <Pseudonym> Right.
17:15:30 * Pseudonym laughs
17:15:38 <Pseudonym> Well, H98's typeclasses are Turing-complete.
17:15:43 <wagle> Pseudonym: is there a short one-liner summary?
17:15:45 <Darius> Philippa: brainfuck isn't that bad.
17:15:52 <Philippa> they are? I know multiparm+fundeps is...
17:16:02 <wli> try whitespace =)
17:16:03 <Pseudonym> Oh, maybe that's it.
17:16:04 <Philippa> Darius: quite. I mean, there's even a good transliteration for orangutangs
17:16:07 <Pseudonym> Yes.
17:16:20 <Darius> Pseudonym: I'm going to have to get a release or fiddle with CVS or somesuch to see that example aren't I?
17:16:22 <Pseudonym> Though H98 + dependent types would also be sufficient.
17:16:26 <Philippa> wli: whitespace is poor. A real sadist would've used nothing but non-printable chars
17:16:31 <Pseudonym> Darius: Probably.
17:16:44 <Darius> Philippa: Heck, ML has worse syntax than brainfuck.
17:16:54 <Philippa> Pseudonym: funnily enough, this is one of the reasons I want to write Tyop. As a way of demonstrating why C++'s type system sucks
17:17:13 <Pseudonym> Mercury brings logic programming to where functional programming was in the mid-70s.
17:17:16 <wli> Pseudonym: btw, are you aware of any interfaces to obtainable databases for mercury, so e.g. mercury can be used as a query language etc.?
17:17:27 <wagle> Pseudonym: oh ok..  mercury is prolog with the i/o aritiess pre-declared?
17:17:30 <Pseudonym> wli: Only Aditi.
17:17:32 <Philippa> the aim is to infer the vast majority of the types likely to be used in a C++ program, and make it possible to usefully type many more things
17:17:47 <wli> Aditi: sounds like "no", since Aditi's not obtainable that I can tell
17:17:49 <Pseudonym> wagle: Not just that.  It's Prolog but strongly-typed, strongly-moded and strongly-deterministic.
17:17:51 <Pseudonym> Right.
17:17:58 <wagle> Pseudonym: or can so things be bidirectional?
17:18:06 <wagle> Pseudonym: or can some things be bidirectional?
17:18:09 <Pseudonym> Though I believe there is an ODBC library for W32.
17:18:16 <Darius> Philippa: Are there any online thingies about Tyop?
17:18:21 <Pseudonym> wagle: You can declare a predicate to have multiple modes.
17:18:30 <Pseudonym> Tie compiler generates separate code for each mode.
17:18:43 <Philippa> Darius: not really, it's mostly in my head. I think I left a half-arsed implementation missing all the good bits somewhere, it's WIP
17:18:48 <wagle> too much thinking, i would think
17:18:56 <Pseudonym> So if it's deterministic, it generates deterministic code.
17:19:03 <Philippa> I mean, all I need to add is the typeclass stuff, but that's a pretty serious "all I need to add"
17:19:13 <Philippa> actually no, it kinda wants support for n-rank polymorphism too
17:19:16 <wagle> i thnk of mode analysis in prolog as an optimization, not a way of thinking
17:19:35 <Pseudonym> Well in Mercury, it's part of the language, much like type analysis.
17:19:52 <wagle> explicit modes, or mode inference?
17:20:00 <Pseudonym> Both.
17:20:06 <wagle> ok
17:20:18 <Pseudonym> It's better if you declare explicit modes, though.
17:20:21 <Philippa> Darius: will get stuff up at some point, amongst other things when I've checked it's safe for me to do so (it's a uni project)
17:20:39 <Darius> Philippa: cool
17:20:39 <wagle> i like bidirectionality
17:20:57 <wli> Pseudonym: is the mercury project surviving/etc.? I have been vaguely hoping it would get somewhere, esp. the gcc front end stuff sounded promising
17:21:29 <wli> Pseudonym: basically because when I have found it to be most useful it was a PITA to do it in anything else
17:21:31 <Pseudonym> Dunno.
17:21:59 <wagle> wli: whats your reaction to curry?
17:22:10 * Pseudonym comes out in a rash
17:22:20 <Pseudonym> Chilli is okay, though.
17:22:32 <wli> wagle: would be nice if the runtime system and compilation and so on were more smoothly implemented
17:22:44 <KrispyKringle> So I'm confused. A list must be homogeneous, but it can be homogeneously tuples, which can, amongst each other, be heterogeneous in what they contain, allowing the list to have the appearance of heterogeneity, correct? 
17:22:54 <KrispyKringle> Should I think of this conceptually as a list of references to varied types?
17:23:02 <wli> never heard of chilli
17:23:11 <wagle> wli: whens the last time you checked?
17:23:18 <wli> wagle: prior to '00
17:23:36 <wli> wagle: or "years ago"
17:23:36 <wagle> tolmach's actively working on a version
17:23:54 <wli> wagle: don't recognize the name and can't guess of what the version might be
17:25:12 <wagle> i believe shrimpx (here) is working on it
17:27:18 <wagle> hmm..  i'm not finding a download.. 
17:27:32 <wagle> http://www.cs.pdx.edu/~apt/
17:29:23 <Darius> KrispyKringle: I'm thinking not correct.  I'm not quite sure what you're getting at.
17:29:33 <wli> hmm, how would one infer that 2 words are "different forms" of the same word?
17:29:56 <wli> I'm guessing there are stats methods
17:30:28 <wagle> wli: if you see shrimpx show up here, you might ask him about curry
17:31:17 <bourbaki> hi
17:31:59 <bourbaki> can you construct a simple recursion with just useing arrows?
17:32:53 <bourbaki> is there a graph implementation for graphs with non uniformly typed nodes?
17:33:42 <wagle> (1) i wish i'd figured out arrows by now (2) you seen Hlists?
17:34:18 <wli> well
17:34:21 <bourbaki> wagle yes ive seen hlists i just try to understand them right now :)
17:34:40 <bourbaki> the thing about the arrow thing is that i want to be able to do a recursion in a graph
17:35:20 <bourbaki> which is why i asked if its possible to use arrows only
17:35:39 <KrispyKringle> Darius: well, I'm correct to say that a list can be a list of tuples, and that each tuple can hold a different type from each other. 
17:35:41 <wagle> co-recursion?
17:35:43 <KrispyKringle> yes?
17:36:23 <KrispyKringle> ah, no. 
17:36:27 <KrispyKringle> I'm wrong. nevermind. 
17:36:38 <bourbaki> co recursion?
17:36:40 <KrispyKringle> So the type of the tuple in a list must be homogeneous. Got it. 
17:36:56 <KrispyKringle> (someone tell me I'm not off my nut here)
17:37:33 <Darius> Yes, same as everything else.  The components can obviously vary, but the corresponding components of each tuple must have the same type.
17:37:56 <KrispyKringle> thanks ;)
17:37:58 <Darius> I.e. [(True,1),(3,"hi")] is not type correct.
17:38:06 <KrispyKringle> yeah, i got it. Experimentation is everything. 
17:38:18 <KrispyKringle> Similar to what I remember of OCaml, minus the ugly syntax. 
17:38:33 <wagle> it occurs to me that graphs (cyclic ones anyway) arent well-founded, and hence recursion might possibly be problematic..  but i dont know enough to be more concrete..  making progress on grokking corecursion is on my joblist for today even..  8/
17:39:07 <Darius> KrispyKringle: The MLs would get more people if they changed their syntax.  Some people have said that they don't use an ML -only- because of the syntax.
17:39:24 <wli> recursion can be done
17:39:52 <wli> you essentially get it on a dfs/etc. search tree
17:40:36 <bourbaki> hm
17:40:42 <KrispyKringle> Darius: quite believable. Can I ask, or is this overly broad, what are the major differences between them and Haskell? OCaml is strict, isn't it?
17:40:52 <KrispyKringle> Strict evaluation, that is. 
17:40:57 <bourbaki> wli and how would you construct the recursion then?
17:41:03 <wagle> map the graph to a tree and recurse on it...
17:41:34 <bourbaki> and would that still be possible with arrows?
17:41:38 <wli> Keep a FiniteMap of visited nodes
17:42:19 <Darius> KrispyKringle: That's one.  Haskell is pure.  Haskell is pretty.  The addition of type classes but lack of a powerful module system (well with enough extensions Haskell is pretty close to having an even more powerful module system).
17:42:29 <wagle> i cant say anything about arrows..  but lots of people here should know something
17:42:31 <bourbaki> if its not possible with static graphs it wouldnt work with arrows anyway really
17:42:45 <Philippa> though it should be added that with all the extensions you have a really really powerful module system indeed
17:42:48 <KrispyKringle> Darius: i guess ill discover these as i learn haskell. thanks :)P
17:43:11 <Philippa> only it's part of the core language and type system instead
17:44:06 <KrispyKringle> i never knew or used ocaml enough to do more than a tiny bit with modules, and i forget most of what i knew ;)
17:44:24 <KrispyKringle> i was debating either relearning ocaml or learning haskell, and i figured, what the hell, try something new. 
17:44:30 <KrispyKringle> Had way too much C recently for my liking. 
17:45:00 <np_hard> what about erlang?
17:45:05 <np_hard> it had so much buzz a few years back
17:45:35 <KrispyKringle> i saw it on the web. 
17:45:36 <KrispyKringle> dunno. 
17:45:58 <KrispyKringle> im taking a course next semester thatll either be in ocaml or haskell, and I already know a tiny bit of ocaml (and the prof says he's thinking haskell at the moment), so i figured...
17:55:54 <vincenz> erlang...
17:57:07 <Darius> @type let _L = _L in _L
17:57:08 <lambdabot> let _L = _L in _L :: forall t. t
17:57:12 <KrispyKringle> so out of curiosity, what's the concensus on erlang?
17:58:04 <bourbaki> is HLIST in ghc 6.3.3 ?
17:58:53 <wagle> KrispyKringle: John Launchbury looked into erlang a couple years ago and thought it was pretty interesting..  especially the fault recovery system
17:59:04 <np_hard> KrispyKringle: I think it would be a boon for my current line of work but have no idea how to implement it or even sell it to management
17:59:06 <KrispyKringle> b
17:59:15 <KrispyKringle> d'oh. i keep typing in here instead of emacs. 
17:59:25 <KrispyKringle> np_hard: what's your current line of work?
17:59:50 <KrispyKringle> wagle: don't know anything about the fault recovery. just sorta browsed across it on the Internets real briefly. 
18:00:17 <np_hard> I work with server systems administration, monitoring, and performance management for a very large financial institution
18:00:39 <np_hard> who recently insourced many of these functions from IBM
18:00:50 <np_hard> who did a generally pisspoor job of it
18:01:16 <KrispyKringle> ah
18:01:38 <np_hard> if this works for telephone switches I don't see why it couldn't work for distributed systems management and monitoring
18:02:39 <KrispyKringle> what languages are currently used?
18:03:11 <np_hard> hah
18:03:29 <np_hard> most of it is unmanaged or manual
18:03:37 <np_hard> ssh or tivoli for remote execution
18:03:51 <np_hard> tivoli or hp openview/snmp for monitoring
18:04:04 <KrispyKringle> ah
18:04:05 <np_hard> for the monitoring that is done, anyway
18:04:32 <np_hard> basically big money for products that aren't used very effectively
18:05:09 <KrispyKringle> sounds about right, 
18:05:36 <KrispyKringle> So I talked to a guy at a career fair who worked at Merril Lynch (if I remember right). I asked him, you know, what do you think about your job?
18:05:40 <np_hard> we are talking about a multi-year project to get the level of management and monitoring that people want
18:05:45 <KrispyKringle> He said, ``Well, the pay is good, and the hours aren't bad...''
18:06:07 <np_hard> and that's with the purchased products. i think it'd be about the same with erlang, but cost much less
18:06:27 <KrispyKringle> What advantages has erlang over Haskel?
18:06:34 <np_hard> that is very true. management is particularly clueless about IT
18:06:53 <np_hard> though at least in finance they have a general handle of not wasting time or money
18:06:54 <KrispyKringle> right. My impression is that I'd rather, if I go corporate, but a programmer at a software company than a programmer at a financial company. 
18:06:57 <np_hard> once you spell it out to them
18:07:18 <KrispyKringle> How do you like it?
18:07:41 <KrispyKringle> If I can ask such a personal question ;)
18:08:14 <KrispyKringle> Ah, so it's designed for RT systems. 
18:08:32 <wagle> telecom
18:08:39 <np_hard> I like it quite a bit for now. I can see getting burned out on it in about 5-10 years.
18:09:03 <KrispyKringle> np_hard: I can see getting burned out of programming in that amount of time, anyway. But how long ahve you been working there?
18:09:09 <np_hard> yep, but I think those same design decisions for telecom would work for distributed systems management & monitoring
18:09:29 <np_hard> especially given that Tivoli seems to have a lot of Java crud in it, if Java works, then surely erlang would do fine :)
18:09:33 <KrispyKringle> I suppose my bias was just that, you know, I think I'd rather be one of the primary money makers rather than just sort of supporting the Big Dogs at a financial firm. 
18:09:41 <KrispyKringle> haha, true. 
18:09:46 <np_hard> one year as an employee, one year and  four months total
18:10:01 <KrispyKringle> Although in fact, don't confound "real time" with "fast". 
18:10:05 <np_hard> if I hit some roadblock I would probably take a hike pretty quickly
18:10:33 <KrispyKringle> Well, I wasn't talking promotions. Just that I'd rather be at a company where what I do is what the company does. 
18:10:52 <KrispyKringle> It's a sort of meaningless distinction, quite possibly, but one that seems important to me (I may be mistaken, though). 
18:11:15 <np_hard> that makes sense. I am twice removed from the business, since I write tools to help people manage IT.
18:11:23 <KrispyKringle> When I talk to recruiters from the investment banks, a lot of them say things like, "Well, the great thing about our company is you can work in IT here for a few years, and then become management." 
18:11:27 <np_hard> there are plenty of programmers that write stock trading programs, etc.
18:11:28 <KrispyKringle> Well, that sounds great, but I don't WANT to be management. 
18:11:44 <KrispyKringle> yeah, you've got a better position, then, no doubt. 
18:12:29 <np_hard> it's got a lot to recommend it
18:12:32 <np_hard> I like computers
18:12:39 <KrispyKringle> I should hope so ;)
18:12:49 <np_hard> I have a penchant for bizarre trivia about hardware, operating systems, etc.
18:13:11 <np_hard> so dealing with an environment with about 25 supported deployed OSes is an interesting challenge
18:13:31 <KrispyKringle> 25?
18:13:35 <KrispyKringle> Holy shit. What are they?
18:13:41 <KrispyKringle> I can't NAME 25 production OSes, I don't think. 
18:13:56 <np_hard> i was exaggerating a bit. OS and version combinations :)
18:14:20 <KrispyKringle> haha
18:14:20 <KrispyKringle> damn
18:14:57 <np_hard> windows NT 3.51, windows 98, windows 2000, windows XP, redhat linux, suse linux, hp-ux, aix 4, aix 5, vos, netware, next, i dunno
18:15:00 <KrispyKringle> I was thinking...Open, Free, NetBSD, Linux, WindowsNT, 2K, XP, 2K3, Solaris, AIX, IRIX, HP-UX, BSDi...
18:15:03 <KrispyKringle> I start to run out. 
18:15:04 <np_hard> you name it, it's probably deployed somewhere
18:15:13 <KrispyKringle> heh
18:15:14 <np_hard> dos
18:15:16 <KrispyKringle> VMS?
18:15:25 <KrispyKringle> wow, you got NEXT boxes?
18:15:41 <np_hard> i am sure there are some vms machines sitting around somewhere
18:15:49 <KrispyKringle> I've wanted a next box a bit ;)
18:15:54 <np_hard> yep, who else could afford them besides banks?
18:16:02 <np_hard> i haven't touched them in the flesh of course
18:16:09 <KrispyKringle> had a coworker with a SGI Indy he was gonna let me take, but honestly, what would I do with a 10 year old unix workstation?
18:16:09 <np_hard> but they are connected to the network somewhere
18:16:15 <KrispyKringle> that's cool, though. 
18:16:17 <np_hard> probably in Europe or some rot
18:16:19 <KrispyKringle> NEXT boxes were pretty. 
18:16:33 <KrispyKringle> I've heard AIX is common in banks, no?
18:16:48 <np_hard> yep
18:17:00 <np_hard> \especially for banks with other contracts with IBM
18:17:06 <np_hard> apparently the way this worked was...
18:17:43 <np_hard> bank management would ask for graphs about server usage from IBM, to determine when more servers needed to be purchased
18:18:00 <np_hard> IBM would provide them graphs and say "hey, looks like you need more servers!"
18:18:18 <np_hard> something queer is going on here...
18:18:20 <np_hard> :-D
18:18:46 <KrispyKringle> hahaha
18:19:14 <np_hard> but perhaps I have gone into too much detail
18:19:19 <np_hard> IBM is a fine company of course
18:19:26 <np_hard> like all vendors they are snakes
18:19:32 <np_hard> and not one of the friendly kinds.
18:21:35 <Sava> (sorry to interrupt) but am i ok to ask a quick haskell question?
18:21:57 <KrispyKringle> im sure. np_hard was just keeping me entertained with tails from the trenches. ;)
18:22:00 <Sava> its to do with traversing a tree
18:22:07 <Sava> well, il be quick and you can get back to it :]
18:22:10 <KrispyKringle> I don't know much about haskell, though, so I can't promise to help. 
18:22:16 <Sava> im quite new to haskell, find it quite hard =/
18:22:16 <Sava> one sec
18:22:44 <Sava> dont ask about the return type (because im essentially ignoring it atm)
18:22:47 <Sava> but..
18:22:48 <Sava> > post_order :: Eq a => [a] -> Gtree a -> ([a], [a])
18:22:48 <KrispyKringle> im just learning haskell for about the last 40 minutes, so I'm sure you've got the jump on me. :P
18:22:48 <Sava> > post_order visited tree
18:22:48 <Sava> >		| (children tree) /= [] = mapAccumL (post_order) visited (children tree)
18:22:48 <Sava> >		| ((children tree) == [] && (contains (info tree) visited)) = (visited , visited)		
18:22:50 <Sava> >		| (children tree) == [] && not (contains (info tree) visited) = (visited ++ [info tree], visited ++ [info tree])
18:23:42 <Sava> does that look like im even close? :P (info tree returns the data associated in that tree node)
18:24:00 <Sava> im not even sure if i can do things like (children tree) == []
18:24:07 <Sava> children tree is a list of trees btw
18:24:17 <Sava> one parent can have lots of kids =/
18:26:42 <KrispyKringle> So my impression from reading the first few pages of the tutorial is that you cannot redeclare. 
18:27:21 <KrispyKringle> Unlike in imperative languages, you cannot re-assign a variable, e.g. if you have x = 5, you cannot later have x = 6
18:27:42 <KrispyKringle> your statement above though appears to be wanting to do that, no? or is that the first declaration?
18:28:03 <KrispyKringle> I may be crazy. Like I said, I picked up the tutorial an hour or less ago, I'd say. 
18:28:24 <Sava> the problem i have
18:28:38 <Sava> is moving through each child, and passing a list of visited nodes to the next child
18:28:40 <Sava> if that makes sense
18:29:19 <KrispyKringle> ah. 
18:29:21 <Sava> since multiple trees are being read, its important that the same node is not included twice
18:29:42 <Sava> basically iv got a list of files, and its got to decide in what order everything needs to be compiled
18:29:56 <Sava> it reads a simple makefile and this function generates the compilation order
18:30:04 <Darius> Sava: How are multiple trees being read?  A post-order traversal of a tree should not see the same child twice.
18:30:10 <KrispyKringle> so you're recursing over a tree that has nodes with multiple parents and want to make sure you don't revisit a node, yes?
18:30:22 <KrispyKringle> it's not really a tree in that case :P
18:30:23 <Sava> tbh Darius im not even that sure myself anymore
18:30:24 <KrispyKringle> it's a graph 
18:30:33 <Sava> its an acyclic graph yeah
18:30:46 <KrispyKringle> a tree is a form of graph in which nodes all have a single parent, if I remember my data structures classes right ;)
18:30:49 <Sava> sorry, i really am talking rubbish atm
18:30:53 <KrispyKringle> (and is acyclic, as Sava said)
18:30:59 <KrispyKringle> yeah :P
18:31:02 <Sava> :P
18:31:11 <KrispyKringle> so anyway, you have a tag "visited" that you check and set if it's unset. 
18:31:13 <Darius> Sava: Probably the easiest thing to do, though possibly not the most efficient is to treat it as a tree and remove duplicates at the end.
18:31:25 <Sava> yeah thats what i was thinking too
18:31:27 <KrispyKringle> but if it's initially set to "false", you cannot re-assign it to "true" in haskell, can you?
18:31:43 <Darius> KrispyKringle: Not in any pleasant way.
18:32:18 <Sava>   - Example
18:32:18 <Sava> 	t = Gtree 1 [Gtree 2 [], Gtree 3 []], Gtree 4 [Gtree 2 []]
18:32:18 <Sava> 	Then postOrder should give [2,3,1,4], dropping the second '2'
18:32:18 <Sava> 	because we've already been there.
18:32:37 <Sava> i really shouldnt be working on this now lol
18:32:56 <Sava> i dont really have to even do it, but i hate being beaten by programming challenges =P
18:33:00 <KrispyKringle> haha
18:33:07 <KrispyKringle> where'd you get this one from? I've been looking for some. 
18:33:23 <Sava> its a uni assignment :p
18:33:32 <Sava> but iv done most of it, this is just the last bit
18:34:22 <Sava> i think Darius is right though
18:34:40 <Sava> if i can run through all of it as if it was a file, then call nub on it it should work
18:34:53 <KrispyKringle> ah
18:42:36 <KrispyKringle> well, it's been fun, but I ought to do at least a little real studying today. Nice talking to you all, and thanks for the pointers and help!
18:45:21 <Sava> gahhh
18:45:30 <Sava> wheneever i think im on a role with Haskell
18:45:45 <Sava> i get to a point when i think "hey, iv no idea how to do this bit!"
18:45:50 <Sava> then usually end up re-writing everything
18:48:01 <Philippa> the trick's to refactor rather than rewrite
18:48:45 <Sava> whenever i think im enjoying Haskell, i then realise that i dont like it at all ;)
18:49:08 <Sava> at least when im hacking away at C code or something i always feel like im making some form of progress ;)
18:51:03 <yrlnry> That's the funny thing about C.  To get anything at all done you have to write and write and write and write, so you always feel like you're accomplishing something, even when you're not.
18:51:56 <yrlnry> Perl has the same problem, on another level.  The language goes on forever, so you can study all the weird crap it does and feel like you're learning something, or get a cheerful feeling of expertise because you know the three circumstances in which (...) change the context from scalar to list or something.
18:52:46 <Sava> yup yup lol
18:52:50 <KrispyKringle> hahaha
18:52:55 <KrispyKringle> that's a very interesting point.
18:53:10 <Sava> iv always really enjoyed writing C++
18:53:16 <KrispyKringle> bleh
18:53:18 <KrispyKringle> :P
18:53:22 <Sava> :]
18:53:43 <Sava> gonna be writing some web services over christmas, im quite looking forward to it :]
18:53:52 <KrispyKringle> C can be fun because it's a challenge. But not because it's *good*. 
18:53:59 <KrispyKringle> imho
18:54:02 <Sava> lol, its better than *good* :P
18:54:37 <Pseudonym> C++ is a huge improvement on C.
18:54:43 <KrispyKringle> its so annoyingly low-level, though. 
18:54:53 <Pseudonym> Yes and no.
18:55:02 <KrispyKringle> dunno. C objects are useful, but again, not *good*. 
18:55:13 <KrispyKringle> er, C++
18:55:15 <Pseudonym> Once you've got the foundation, C++ programming is surprisingly pleasant.
18:55:23 <Pseudonym> Oh, objects aren't the most interesting part.
18:55:33 <KrispyKringle> which would you call the most interesting?
18:55:38 <Pseudonym> Writing reusable libraries.
18:55:49 <Pseudonym> Of which objects are but a small part.
18:55:51 <wagle> Pseudonym: where do you get that foundation for C++?
18:55:52 <KrispyKringle> well, fine, but it's the OO functionality that allows you to do that. 
18:56:01 <Pseudonym> wagle: Boost helps a lot.
18:56:29 <Pseudonym> Not completely.  C++, like Haskell, is a multi-paradigm language.
18:56:46 <Pseudonym> So templates, for example, are another feature which allow you to write reusable libraries.
18:57:02 <wagle> Pseudonym: yeah people tell me that you gotta select a good subset, and then life is good
18:57:12 <Pseudonym> But you have to be aware of most of it.
18:57:16 <KrispyKringle> ah. I haven't used them. 
18:57:23 <Pseudonym> Really, what you need is a suitable base layer.
18:57:30 <Pseudonym> The raw language itself isn't quite enough.
18:57:30 <KrispyKringle> I've only done a reasonably small amount in C++, and my C++ tends to look like C. 
18:57:36 <Pseudonym> You need some decent foundation libraries.
18:57:42 <Pseudonym> Boost is a start.
18:57:46 <KrispyKringle> what's boost?
18:57:50 <Pseudonym> www.boost.org
18:58:05 <KrispyKringle> cool. 
18:58:34 <np_hard> what about Java? :-D
18:59:19 * Pseudonym growls
18:59:40 <KrispyKringle> you dislike java?
18:59:52 <Pseudonym> Yes.
19:00:00 <KrispyKringle> why?
19:00:04 <Pseudonym> Actually, "dislike" is not the right word.
19:00:12 <Pseudonym> I want something like "loathe", but without the emotional investment.
19:00:16 <KrispyKringle> it's widely considered that java's OO is, well, better than C++'s ;)
19:00:29 <Pseudonym> But C++ is not an OO language.  It's a multi-paradigm language.
19:00:37 <Sava> Java is horrible
19:00:41 <KrispyKringle> so you feel java is too limited, or what do you dislike about it?
19:00:52 <Pseudonym> Yes, Java is too limited.
19:00:52 <np_hard> there is a java nut at work
19:00:57 <KrispyKringle> I can't say I really *like* Java, but it works. 
19:01:03 <Sava> its ok for some things, but there are times it just plain upsets me :P
19:01:06 <KrispyKringle> I don't like *most* programming languages I use, on some level. 
19:01:11 <np_hard> i think i caught him short, while working on getting Jython up and running
19:01:14 <Pseudonym> Oh, there are problems with all of them.
19:01:18 <Sava> Java 5 looks interesting
19:01:23 <Pseudonym> C++'s main problem is that it has to be backwards compatable with C.
19:01:24 <KrispyKringle> you mean 1.5?
19:01:29 <Sava> it has basically stolen templates from C++, which is a good thing
19:01:31 <KrispyKringle> 1.5 has some very interesting additions. 
19:01:32 <np_hard> "the point is to avoid using that godforsaken Java language!"
19:01:40 <Pseudonym> Yes, the latest Java is closer.
19:01:40 <KrispyKringle> halo time
19:01:50 <Sava> yeah, except the sun marketting guys thought "lets call it Java 5!"
19:01:59 <Sava> didnt they do that with Java 1.2 as well? *sigh*
19:02:01 <Pseudonym> The lack of generics was a pretty serious problem with older Javas.
19:02:26 <Pseudonym> There's only one benefit of Java that I can see, and that's that the Sun libraries are incredibly well designed.
19:02:28 <Pseudonym> Even AWT.
19:02:47 <Sava> i sorta agree
19:02:52 <Sava> with some things writing it in Java is verrry easy
19:02:57 <Sava> because its all there in the sun libraries
19:02:57 <Pseudonym> Yes.
19:02:59 <np_hard> except for the shitty ones, of course
19:03:03 <Pseudonym> Anything there's a Sun library for is easy. :-)
19:03:16 <np_hard> i dunno
19:03:22 <Sava> some are a bit weird
19:03:28 <np_hard> I always feel like Dark Helmet when using Java
19:03:29 <Pseudonym> What I really want is multi-language programming.
19:03:39 <Pseudonym> So I can write my GUI in Java, but my computation in Haskell.
19:03:41 <np_hard> "Why are you preparing? You're always preparing! Just go!"
19:03:43 <Sava> like having to create 50,000 different objects to do one thing
19:03:52 <Sava> GUI in Java???!?!!
19:03:54 <Sava> you madman!
19:03:55 <Pseudonym> Sure.
19:04:00 * np_hard was experimenting with Jython and Swing today
19:04:02 <Pseudonym> What would you rather use?  Smalltalk?
19:04:07 <Sava> gawd i hate swing
19:04:10 <Pseudonym> Smalltalk would also be a good choice.
19:04:16 <Pseudonym> Ah, I wasn't talking about Swing.
19:04:21 <np_hard> it seemed pretty straightforward to me
19:04:26 <Pseudonym> A simple GUI in raw AWT is very pleasant.
19:04:28 <np_hard> I didn't do much with it though
19:04:49 <Pseudonym> Mind you, I never did anything complex in AWT.
19:04:58 <Sava> for anything GUI i use the QT C++ libraries :]
19:05:20 <Sava> hello
19:05:38 <Pseudonym> There's one problem that I have with Qt.
19:05:41 <Sava> i am mikey
19:05:48 <Pseudonym> I used to hame more problems, but most of them have been fixed.
19:05:55 <Sava> ive got a tiny pecker
19:05:58 <Sava> lol
19:06:21 <Sava> sorry that was a drun k person
19:06:28 <Pseudonym> That's that there's an impedance mismatch between Qt and other C++ frameworks.
19:06:52 <np_hard> Sava: you are at university, eh?
19:06:58 <Sava> yes]#
19:07:00 <Pseudonym> For example, boost.signals and libsigc++ are converging.
19:07:02 <Sava> yes
19:07:14 <Sava> you?
19:07:15 <Pseudonym> But Qt still uses the bizarre MOC thing.
19:07:16 <np_hard> sava: they are getting drunk on a tuesday? must be a party school
19:07:50 <Pseudonym> Also, Qt uses its own threading model, so I can't mix that with other code which is already threaded.
19:08:02 <Pseudonym> Qt has a tendency of taking over in ways that other libraries don't.
19:08:02 <np_hard> MOC?
19:08:23 <Pseudonym> MOC = Meta Object Compiler
19:08:39 <Pseudonym> Any Qt-based thing needs to be run through another compiler in order to create metadata for it.
19:09:21 <Pseudonym> That includes anything that wants to communicate with a Qt widget via signals and slots.
19:09:33 <Pseudonym> So your non-GUI components need to be MOC'd too.
19:09:42 <Pseudonym> It's very inelegant.
19:10:17 <np_hard> that is funky
19:10:43 <Pseudonym> It's one approach to "scrap your boilerplate".
19:11:19 <Pseudonym> Boost.Signals and libsigc++ (and hence GTKmm) don't need that.
19:11:27 <Pseudonym> They seem to get along just fine without it.
19:13:03 <Darius> Qt with libsigc++ would've been nice.  Gtkmm2 looked like it, but wasn't ready at the time I was looking at it.
19:13:22 <Pseudonym> Yeah, I haven't looked close enough to comment.
19:13:41 <Pseudonym> Now what you need to do is take the free Qt, gut it and rework it on top of Boost.
19:13:42 <Darius> In general, I prefer library based approaches to framework based approaches.
19:13:47 <Pseudonym> Me too.
19:14:04 <Pseudonym> You can always provide a framework view of the library.
19:14:13 <Darius> Exactly.
19:14:26 <Pseudonym> Because frameworks are sometimes nice.
19:14:45 <Pseudonym> There are some kinds of frameworks which are okay, of course.  Unit testing frameworks tend to be fine just as they are.
19:14:46 <Darius> I agree.  But typically a general purpose GUI framework is too general purpose.
19:15:23 <Darius> They are fine if you want to do things the "standard" way (standard defined by them), but it's too hard to change things to work as you like.
19:16:07 <Darius> And often interoperability is difficult.
19:19:34 <Philippa> work as you like as a coder, or how you want the GUI to work?
19:19:51 <Philippa> the latter causes me big problems, the former is only an issue for me when the lib's badly designed (though invariably I find /some/ kind of bad design)
19:21:34 <Darius> Anyways, 'night.
19:23:16 * Philippa goes *click*
19:23:36 <Philippa> everybody else uses "framework" to mean "platform", don't they? As in, may-as-well-be-your-OS...
19:26:57 <shammah> no.  Framework and platform mean very different things.
19:27:46 <cm> y0
19:29:02 <np_hard> framework has the whole inversion of control going on
19:29:23 <shammah> A platform is generally considered a hardware/OS combination.  Occasionally an OS/compiler, or OS/vm combination.  Even more occasionally a hardware/OS/compiler or hardware/OS/vm combo.  But effectively it defines the 'target' for which your application is written.
19:30:56 <shammah> As np_hard just mentioned, a framework is a set of libraries and executable modules into which you 'plug' (however that is done) your code.  It generally defines the execution policies of your code, not mechanisms.
19:31:45 <np_hard> unix shell is a common component framework
19:31:54 <shammah> So a platform 'supports' concurrency.  While a platform 'utilises' concurrency.  The difference is that if you're writing for a framework that utilises concurrency you are concurrent regardless of your desires.
19:32:32 <np_hard> e.g. in unix you can be concurrent with $ c1 | c2 | c3 | c4 
19:32:33 <np_hard> :-D
19:33:44 <Philippa> shammah: the combinations you describe all amount to specifying the language and set of libraries you write to. IME frameworks tend to do exactly that too
19:33:48 <shammah> a J2EE Servlet or EJB container is a framework.  Linux/gcc-3.3.2 is a platform. 
19:34:14 <Philippa> I'm inclined to say J2EE is a platform too
19:35:33 <shammah> J2EE can be treated as a platform.  EJB2.0 is however not a platform.
19:35:41 <marios> im trying to write a function(s) which by given 2 items and a list replace all the first item where exist in the list with the second one (item might exist more than once), any ideas thanx  
19:35:47 <shammah> (at least not under any traditional defn of the term)
19:35:52 <np_hard> EJB isn't much of anything, I don't think
19:36:17 <shammah> np_hard, it is a convenient example of a framework though ;)
19:36:25 <np_hard> i like unix shell better
19:36:41 <np_hard> it's actually been used successfully :)
19:37:22 <Philippa> okay, so frameworks divide into platform specs (and I'm inclined to say the servlet framework is that) and mental masturbation that doesn't do anything then?
19:38:15 <bourbaki> can someone explain to me the loop in arrows?
19:38:19 <np_hard> c.l.l had a good quote on frameworks a couple months ago
19:38:52 <arjanb> marios: where do you get stuck?
19:40:13 <paf> Is greencard ok to use with ghc-6.2.2?
19:40:29 <np_hard> "Framework creation is typically practiced by people who still don't fully understand the problem domain, but have an unfortunate combination of arrogance and lack of introspective ability, so fail to realise that more exploration is needed."
19:40:38 <Philippa> heh
19:41:07 <KrispyKringle> hehe
19:41:12 <KrispyKringle> that's interesting, np_hard ;)
19:41:14 <Philippa> I remember suggesting in an argument on usenet that monads and associated datatypes frequently comprise frameworks insofar as the phrase is meaningful at all
19:42:15 <KrispyKringle> on the downside, you found yourself engaged in an argument on usenet. 
19:42:28 <np_hard> well, there are the frameworks where people have tackled the really hard, basic bits of a problem.
19:42:28 <KrispyKringle> ;)
19:42:35 <Philippa> so I was bored :-)
19:42:44 <KrispyKringle> we've all been there. 
19:42:45 <np_hard> then there are the frameworks where people have tackled the trivial, easy bits of a problem
19:42:59 <Philippa> the former're the sort of thing I think monads and arrows're good at
19:43:07 <bourbaki> trace :: ((b,d) -> (c,d)) -> b -> c; trace f b = let (c,d) = f (b,d) in c ... where does the d get fed back to f?
19:43:21 <np_hard> then there are the frameworks where both got tackled
19:43:38 <np_hard> posix shell is one of these last ones :)
19:44:01 <Philippa> one of the nice things with Haskell is that turning the former into both is fairly easy
19:44:18 <Philippa> 'cos you just spot the patterns of use for easy problems and oh look, the hard bits're done, the HOF drops out
19:44:29 <np_hard> yes
19:47:08 <bourbaki> cant anyone of you explain loop to me?
19:47:18 <Pseudonym> IME, frameworks should be application-specific.
19:47:38 <Pseudonym> So libraries should facilitate the creation of frameworks, not be frameworks in and of themselves.
19:48:09 <np_hard> better yet frameworks should be emergent
19:48:09 <Pseudonym> Unless the framework is the application, and the code that the programmer writes is plug-ins.
19:48:11 <np_hard> like Unix shell
19:48:26 <np_hard> or some lisp systems
19:48:58 <wagle> bourbaki: threads loop?
19:49:02 <Philippa> Pseudonym: funny that, I think Flippi's fast turning into a framework
19:49:07 <bourbaki> wagle no arrow loops
19:49:16 <wagle> darn
19:49:21 <Philippa> I just bashed on a system for adding plugins to the basic IO operations carried out on pages, metadata etc
19:49:23 <bourbaki> trace :: ((b,d) -> (c,d)) -> b -> c; trace f b = let (c,d) = f (b,d) in c
19:49:27 <Pseudonym> Yes, and that's actually the right thing for it to be.
19:49:37 <Pseudonym> Because Flippi _is_ the application.
19:49:43 <bourbaki> they say that the second value d of the function is fed back
19:49:47 <Philippa> yep. Customise at will :-)
19:49:52 <Pseudonym> Right.
19:49:54 <wagle> not _the_ application?
19:50:09 <Philippa> wagle: at this point. Though Shae's turning it into FLM...
19:50:15 <bourbaki> i dont even see where the d comes from at all :)
19:50:15 <Pseudonym> So it's actually more of a hard-and-soft-layer thing, where the soft layer just happens to be in the same language.
19:50:22 <Philippa> yep
19:50:45 <Philippa> might bung on hs-plugins at some point, but I'm not convinced of the utility
19:50:54 <wagle> bourbaki: where you getting that from?
19:50:58 <Pseudonym> Or, perhaps, in a DSL embedded in the same language.
19:51:12 <bourbaki> http://www.soi.city.ac.uk/~ross/papers/fop.ps.gz
19:51:25 <bourbaki> page 11
19:51:28 <Philippa> the equivalent functionality should be provided by the execution environment AFAICT - either I'm running inside hs-plugins already via a mod_haskell, or the whole lot's statically compiled or I'm being interpreted and you just alter Config.hs like any other config file
19:51:35 <paf> somebody knows/uses greencard or haskelldsp?
19:52:03 <Pseudonym> I dunno if anyone has mentioned it formally, but there's a continuum between frameworks and DSLs.
19:52:16 <Philippa> I sort of said it by saying what I said about monads and arrows
19:52:23 <Philippa> 'cos monads and arrows are basically DSLs sans syntax
19:52:24 * Pseudonym re-reads
19:52:30 <np_hard> kinda like unix shell
19:52:35 <bourbaki> DSL?
19:52:41 <Philippa> Domain Specific Language
19:52:41 <np_hard> domain-specific language
19:52:46 <bourbaki> ah i see
19:52:47 <Philippa> eg parsec is a language for writing parsers
19:52:48 <Pseudonym> Yes, I guess you did, though it depends on what the monad/arrow is, and how DS it is.
19:53:01 <Philippa> well yeah, but so does the link to frameworks more generally
19:53:02 <Pseudonym> But yes.
19:53:20 <Pseudonym> Oh, now there's a thought.
19:53:34 <Pseudonym> Monad transformers and arrow transformers could be viewed as stackable frameworks.
19:53:47 <Philippa> :-)
19:54:00 <Philippa> cf comment about platforms and frameworks earlier
19:54:06 <bourbaki> is the d in the loop a stable variable?
19:54:09 <Pseudonym> There's probably a PhD in that sentence, for someone who wants to expand it.
19:54:15 <Philippa> heh
19:54:21 <Philippa> I'm too lazy, or I'd have done it already
19:54:23 <wagle> bourbaki: cool!
19:54:24 <Pseudonym> :-)
19:54:34 <Philippa> OK, that and I haven't finished my undergrad course yet
19:54:36 <bourbaki> wagle have you got the answer :)?
19:54:56 <arjanb> bourbaki: the d is a recursive variable because it defined in terms of f and d itself
19:55:08 <wagle> the let (c, d) defines d
19:55:12 <Philippa> but yeah, this is one of a handful of reasons I'm rapidly coming to the conclusion that OO really can be killed dead by the application of techniques we already have combined the right way
19:55:32 <np_hard> are we killing OO dead?
19:55:38 <bourbaki> but let (c,d) = f (b,d)
19:55:38 <wagle> d is the second output of f
19:55:42 <np_hard> in some parts it never lived
19:55:43 <np_hard> :)
19:55:45 <Philippa> heh
19:55:49 <bourbaki> so d is defined as the output of the funtion
19:55:52 <wagle> bourbaki: haskell is lazy
19:56:13 <bourbaki> and where comes d from then?
19:57:03 <bourbaki> i mean in order to feed something back there needs to be at least one call to the function right?
19:57:27 <wagle> its the second output of f..  if f asks for the value of its second input, it needs to have already "produced" the value of its second output "first"
19:57:47 * cm transforms pizza to energy
19:57:55 <wagle> else it goes into an infinite loop
19:58:11 <wagle> you can define "x = x" in haskell..  
19:58:31 <wagle> but if you ask for the value of x, you go into an infinite loop
19:58:35 <bourbaki> hm i still dont get it really
19:58:43 <wagle> you can also define "x = 1 : x" in haskell
19:59:09 <wagle> if you ask for the value of that x, you get the infinite list of 1's
19:59:11 <bourbaki> i even dont see where the definition of trace is recursive
19:59:28 <bourbaki> or is it recursive in d ?
19:59:31 <wagle> f (x,y) = y : x
19:59:42 <wagle> f (x,y) = x : y
19:59:43 <wagle> i mean
19:59:45 <cm> :o)
20:00:00 <wagle> i think that will work
20:00:08 <Pseudonym> OO is important in the same way that imperative programming is important.
20:00:09 <bourbaki> and what will that do?
20:00:13 <Pseudonym> It's still handy to think that way.
20:00:21 <wagle> try it
20:00:35 <Pseudonym> Even if OO is provided in a library rather than in the language, people will still think that way for some kinds of problem.
20:00:42 <Pseudonym> So in that sense, OO won't be killed dead.
20:00:50 <bourbaki> got no haskell on this machine
20:01:22 <Pseudonym> I think what you, Philippa, are proving is that OO doesn't need to be provided natively.  It can be emulated using even more powerful features.
20:01:43 <Pseudonym> So you can still think in OO, but you don't have to feel bound by it.
20:01:49 <wagle> what?  its turing complete?
20:02:02 * wagle hides
20:02:18 <Pseudonym> Is that fair to say?
20:02:30 <cm> so ($) is harmful, uh.
20:02:45 <Pseudonym> It's kind of like how I can think imperatively while programming in monadic I/O, but I'm not bound by it.
20:03:28 <bourbaki> wagle and what should the type of that function be?
20:04:57 <Pseudonym> IMO there's a reason why OO and GUIs happened around the same time.  THey're made for each other.
20:05:05 <shammah> bourbaki, loop is a fixed-point operator, so as long as your function converges, you don't actually need to worry about the initial value of d.
20:05:07 <Riastradh> Pseudonym, what do you mean by 'OO' there?
20:05:18 <Pseudonym> I mean object-oriented modelling.
20:05:21 <Riastradh> Actors-style models?
20:05:25 <Pseudonym> Modern GUIs are well-modelled using OO techniques.
20:05:36 <bourbaki> shammah i still dont get it how d is ever defined
20:05:59 <Pseudonym> That might be a rude comment on modern GUIs, of course. :-)
20:06:06 <Philippa> Pseudonym: fair enough and no argument
20:06:08 <Riastradh> Yes, I know what the expansion is; however, the phrase 'object-oriented' alone has no meaning to me, and I'm wondering what you're referring to when you say it.
20:06:27 <bourbaki> wagle and what type signature has your f(x,y) = x : y thingy?
20:06:31 <shammah> bourbaki, have you ever used newtons method?
20:06:31 <Philippa> I mean, give me an action game style simulation problem and you bet your arse I'll reinvent OO if I don't have it...
20:06:33 <Pseudonym> I'm talking Booch-style object-oriented analysis and design.
20:06:38 <Pseudonym> Right.
20:06:43 <bourbaki> shammah for rootfinding?
20:06:51 <Riastradh> Booch-style?
20:07:02 <Philippa> for GUIs I'll invent a notion of widget, though it'll prolly look more like communicating processes than other views of objects
20:07:16 <wagle> my f was bad
20:07:25 <shammah> bourbaki, well for solving a suitable equation, rootfinding is one application.
20:07:32 <Pseudonym> http://c2.com/cgi/wiki?GradyBooch
20:07:37 * Philippa likes the pseudo-concurrency processes-and-channels view of OO. A lot. It's unto OO what FP is unto most imperative code, IYSWIM - explicit dataflow
20:07:38 <Riastradh> Philippa, there's a term for that: Actors.
20:07:55 <cm> yeah
20:07:57 <Pseudonym> If only Erlang had inheritance.
20:08:09 <Philippa> yeah. Most of my non-actor objects in OO langs are better off as something else one way or another
20:08:18 <Philippa> but everything's an object, no?
20:08:19 <Pseudonym> Actually, if only Erland had a decent type system.
20:08:20 <bourbaki> shammah i think i did once or twice but you have to have a starting d or point as such
20:08:26 <wagle> why did actors never take off?
20:08:44 <shammah> bourbaki, You understand that, as long as your function converges (under newtons method) you can pick *any* value for d?
20:08:45 <Philippa> wagle: tech. Plus they're associated with the sort of OO language that never really made it big
20:08:45 <Riastradh> wagle, that's like asking 'why did the lambda calculus never take off?'
20:08:47 <Pseudonym> Actors are alive and well.
20:09:19 <bourbaki> shammah erm that is for real valued functions only isnt it?
20:09:22 * yrlnry is away: zzz
20:09:22 <wagle> i always see actors discussed as extra material
20:09:31 <Pseudonym> They're mostly used in distributed systems, though, I think.
20:09:33 <Riastradh> Noone writes code in the lambda calculus; noone writes code with Hewitt's plain Actors language.  But lots of people use Actors-style models and lambda models.
20:09:38 <shammah> So in fact if you lift newtons-method into a higher-order function, so you define  newtons f -> use newtons method to find a solution for f.
20:09:39 <Pseudonym> Especially real-time distributed systems.
20:10:01 <Pseudonym> Or, I suppose, systems where latency is a problem.
20:10:15 <Philippa> yeah. A handful of actors makes sense for a lot of GUI apps though, and widgets-and-controllers-as-actors works
20:10:19 <Pseudonym> Actually, DCOM and CORBA are actor-based.
20:10:25 <Pseudonym> More or less.
20:10:27 <shammah> you don't need to pass an initial value to newtons, as ANY WILL DO.
20:10:31 <Philippa> you get a nice big explicit chain of control
20:10:33 <Pseudonym> And most object-oriented operating systems are.
20:10:36 <bourbaki> shammah maybe a sample application of loop would help me
20:10:49 <shammah> bourbaki, in the specific case of newtons yes, they have to be real valued functions. 
20:11:03 <bourbaki> and where does haskell get that any value for d get from?
20:11:07 <wagle> anyone know how to get bourbaki a haskell interpreter to try things on?
20:11:16 <shammah> but I'm trying to use a concrete example here (that you are already familiar with) to show you how a fixed-point operator works.  
20:11:29 <bourbaki> i just got logged in on a machine with an interpreter
20:11:45 <shammah> bourbaki, what paper are you reading on arrows which discusses loop?
20:11:50 <bourbaki> http://www.soi.city.ac.uk/~ross/papers/fop.ps.gz
20:11:52 <wagle> f (x, y) = (x, x : y)
20:11:53 <bourbaki> page 11
20:12:03 <wagle> oops
20:12:19 <wagle> nevermind that
20:13:12 <shammah> ahh yes, I've got that on my list of papers to read myself :)
20:13:19 <bourbaki> heh
20:13:50 <wagle> f, being lazy, can produce outputs before looking at all its inputs
20:14:33 <bourbaki> hm
20:14:35 <shammah> My introduction to arrows was http://haskell.cs.yale.edu/yale/papers/oxford02/
20:14:37 <Nioate> isn't an ArrowLoop conceptually similar to a MonadFix?
20:14:41 <Philippa> yep
20:14:44 <bourbaki> my mind refuses this concept
20:14:45 <shammah> Nioate, I believe so yes.
20:14:47 <Philippa> or rather, MonadFix is an instance of ArrowLoop
20:14:52 <Philippa> AIUI
20:14:55 <wagle> i need a whiteboard to draw that diagram in the paper on
20:14:56 <Philippa> (that, and ArrowApply)
20:14:58 <wagle> 8)
20:15:26 <bourbaki> ok if i define the input in terms of the output i get the recursion in
20:15:56 <bourbaki> but then i still need a d as a prior input if i want some loop on arbitrary functions
20:16:25 <wagle> f (x, y) = (x : y, x : y)
20:16:48 <wagle> trace f 'a'
20:17:02 <wagle> produces the infinite string of 'a''s
20:17:53 <wagle> f doesn't actually need the current value of its second input to produce its second output
20:18:11 <wagle> similarly: y = 'a' : y works
20:18:18 <bourbaki> but that entirely depends on the function
20:18:41 <bourbaki> its just the case here cause x is used for the second argument
20:18:45 <wagle> y = y  doesnt work
20:19:14 <bourbaki> anything where the second argument isnt dependant of the first is not feasable
20:19:18 <wagle> i dont think i'm giving you the best possible help heere
20:19:41 <wagle> bourbaki: like what?
20:20:15 <wagle> Main> trace id 'a'
20:20:15 <wagle> 'a'
20:20:19 <bourbaki> like f( x , y ) = (x : y, y)
20:20:34 <bourbaki> or f( x , y ) = (x : y, someconstant)
20:21:37 <wagle> that works, just goes into an infinite loop after the first element of the list
20:21:47 <wagle> Main> trace f 'a'
20:21:48 <wagle> "a
20:22:00 <bourbaki> ok lets do the id thing as an example
20:22:12 <bourbaki> let (c,d) = id(b,d) in c
20:23:10 <wagle> let (c,d) = id('a',d) in c
20:23:17 <bourbaki> right
20:23:21 <bourbaki> so
20:23:34 <wagle> so d = d
20:23:45 <wagle> but the value of d is never asked for
20:23:56 <bourbaki> ?
20:24:08 <wagle> let (c,d) = id('a',d) in c
20:24:12 <wagle> let (c,d) = ('a',d) in c
20:24:35 <wagle> let { c = 'a' ; d = d } in c
20:24:46 <bourbaki> ok
20:25:14 <bourbaki> and in the other case of your example ...
20:25:35 <bourbaki> let (c,d) = f('a',d) in c
20:26:24 <wagle> .. substitute
20:27:09 <bourbaki> sry had to turn off my clock
20:27:37 <wagle> f (x, y) = (x : y, y)
20:27:48 <wagle> let (c,d) = f('a',d) in c
20:27:58 <bourbaki> let (c,d) = ('a' : d, 'a' : d))
20:28:40 <wagle> d = 'a' : d
20:28:44 <bourbaki> so d = 'a' : d i see
20:28:55 <shammah> bourbaki, Take a look at that paper I mentioned, it uses loop in a specific arrow based combinator library.
20:29:14 <shammah> It might help. 
20:29:28 <Nioate> or let (c,d) = (d, 'a' : d))
20:29:38 <bourbaki> ok this seems to be entirely uninteresting to me though
20:29:51 <bourbaki> i mean what kind of interesting functions will that produce?
20:30:05 <wagle> bourbaki: but notice that c = 'a' : d where d = 'a' : d
20:30:36 <bourbaki> could i do a length that way?
20:31:01 <wagle> bourbaki: thats where i fall short..  someone above seemed to be suggesting that square root approx can be expressed
20:31:45 <bourbaki> shammah any idea?
20:31:55 <Pseudonym> Except that the server thread actually ran in the thread context of the client.
20:31:58 <wagle> the paper does go on to use trace
20:32:14 <Pseudonym> Hmmm.
20:33:06 <bourbaki> wagle which paper?
20:33:07 <wagle> hmm..  factorial..  fib...
20:33:21 <wagle> the fop.ps paper you got this from
20:33:52 <bourbaki> fib with loop? am i blind?
20:34:11 <wagle> i'm trying to do fact with trace
20:34:19 <wagle> its all streams
20:35:08 <wagle> bad time for a blood sugar crash..  8/
20:35:43 <bourbaki> f( [a], d ) = ( 1 + d, tail [a] ) ?
20:36:40 <bourbaki> wagle where did you get trace from anyway?
20:36:46 <bourbaki> import Arrow?
20:36:52 <Janni> G'morning.
20:36:54 <wagle> bourbaki: the paper
20:36:56 <bourbaki> moin
20:37:04 <bourbaki> wagle ah ok ;)
20:59:42 <bourbaki> can i somehow return a variable?
21:00:17 <bourbaki> f(x,y) = (1 + y, foo(tail x,y))
21:00:53 <bourbaki> foo(x,y) = if x > 0 y else 0
21:01:41 <dons> it will return the first argument if x > 0, is that what you mean?
21:01:57 <dons> sorry, the snd component of the argument
21:01:58 <bourbaki> i want to write a length with trace
21:02:18 <bourbaki> trace :: ((a,d) -> (b,d)) -> a -> b
21:02:18 <bourbaki> trace f a = let (c,d) = f (a,d) in c
21:02:19 * Philippa curses the lack of a partial order typeclass in Haskell
21:02:27 <Philippa> oh well
21:03:16 <wagle> Philippa: scratch that itch!
21:03:29 <Philippa> wagle: I'd have to rewrite the Prelude to make it look pretty though
21:03:44 <bourbaki> what do you want partial order for?
21:03:46 <Philippa> as the Right Thing involves Ord inheriting PartOrd
21:03:50 <Philippa> bourbaki: a partial ordering
21:03:57 <bourbaki> for what :)?
21:04:00 <Philippa> heh
21:04:05 <Pseudonym> Everyone wants to rewrite the Prelude, I think.
21:04:12 <bourbaki> not me
21:04:43 <Pseudonym> Do you want Ord inheriting from PartOrd?
21:04:46 <Pseudonym> Oh, yes, I guess you do.
21:04:48 <Philippa> in this particular case, so I can write succintly that an invariant type <= contravariant type, an invariant type <= a covariant type, and then take orderings on types based on something using that
21:04:51 <Philippa> right
21:04:57 <Philippa> otherwise I can't use <=
21:05:04 <Pseudonym> class PartOrd a where partCompare :: a -> a -> PartCompare
21:05:14 <Pseudonym> data PartCompare = LT | GT | EQ | INCOMPARABLE
21:05:15 <Philippa> oh, it can be a bool
21:05:26 <Philippa> just the <=, y'know?
21:05:28 <Philippa> but yeah
21:05:31 <Pseudonym> Yes.
21:05:46 <Philippa> of course, given supertyping, Ordered is a subtype of PartialOrdered
21:05:53 <Philippa> (everything but Incomparable)
21:06:09 <Pseudonym> class (PartOrd a) => Lattice a where { join :: a -> a -> a; meet :: a -> a -> a }
21:06:18 <Philippa> Ordering/PartialOrdering, even
21:06:31 <Philippa> right :-)
21:06:32 <jesse98> it really bugs me that there's no keyword marking out function definitions
21:06:45 <wagle> CPLattice?
21:06:46 <Philippa> jesse98: =
21:06:47 <bourbaki> oh theres a lattice in the prelude?
21:07:04 <Philippa> bourbaki: no, we're doing the typical "how would I rewrite the Prelude?" discussion
21:07:07 <wagle> join :: a -> a -> Maybe a?
21:07:24 <bourbaki> i think i have seen an implementation of lattice though somewhere
21:07:30 <Philippa> most likely
21:07:37 <Pseudonym> Not in the prelude.
21:07:41 <bourbaki> heh :)
21:07:44 <Pseudonym> @type join
21:07:45 <lambdabot> bzzt
21:07:51 <Philippa> I needed to keep the data defining the lattice somewhere mutable, so I had to implement it myself anyway
21:08:52 <wagle> ub :: a -> a -> [a]
21:09:32 <Philippa> is there a term for "those values that meet the conditions for an lub with the uniqueness condition removed"?
21:09:54 <Philippa> I may have a use for that one at some point
21:10:03 <wagle> i've seen that
21:10:34 <jdrake> what happens when a function has something like a -> b -> c -> ... -> y -> z -> ???
21:10:40 <wagle> maybe in priestly
21:10:59 <Philippa> jdrake: depends. t0, t1 etc are viable (my Tyop interpreter does that)
21:11:22 <jdrake> what about specifically in ghc
21:11:37 <Philippa> try it
21:11:41 <Philippa> (I've no idea)
21:11:59 <wagle> priestley, rather
21:12:22 <Philippa> :t (\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->\a->1)
21:12:27 <wagle> infinite type?
21:12:40 <Philippa> no, you can tell when an infinite type's being introduced
21:12:49 <Philippa> only happens by recursion
21:12:57 <wagle> i wasnt sure what he's asking
21:13:08 <Philippa> what the 27th type variable gets labelled
21:13:22 <wagle> ohhhhhhhhHHHHHhh
21:13:53 <Pseudonym> Philippa: I think so.  In recursion theory there isn't necessarily a unique greatest fixpoint to most functionals.
21:14:35 <wagle> , foo(tail x,y))
21:14:36 <Philippa> anyway, I should go to bed, I need to start getting up earlier
21:14:48 <wagle> a1 b1
21:14:55 <wagle> jdrake: 
21:14:58 <Philippa> and I'd like to be awake enough to deal with the shock tomorrow when a friend comes round and finds I've shaved my head
21:14:59 <bourbaki> wagle still on the length thingy?
21:15:19 <Philippa> GHCi 6.2.1 adopts the t1,t2 scheme anyway AFAICT
21:15:21 <bourbaki> shaved your head :)?
21:15:24 <wagle> bourbaki: i need food..  but if i get food, i'll be offline until tomorrow
21:15:30 <Philippa> yeah, felt like it last night
21:15:35 <bourbaki> hehehe
21:15:39 <Philippa> hell, it'll only take a couple of years to regrow...
21:15:40 <bourbaki> what for?
21:15:55 <bourbaki> i shave my head once a year
21:15:56 <wagle> jdrake: the type vars after x y z are a1 b1..
21:16:02 <bourbaki> like a sheep in the summer
21:16:08 <Philippa> figured my head was getting too hot what with it being winter'n'all :-) I'd better go buy a hat when I next go out
21:16:21 <bourbaki> or a wig ;)
21:16:32 <Philippa> nah, I was thinking army boots instead
21:16:42 <bourbaki> hehe
21:16:43 <wagle> cammies
21:16:48 <Pseudonym> But the set of greatest fixpoints has a Night.
21:17:20 <Philippa> wagle: I'll skip that for jeans and t-shirts and the like I can move in, but same difference IYSWIM
21:17:31 <Philippa> I'm not doing the army thing, just the butch dyke thing :-)
21:17:46 <wagle> black leather
21:17:51 <bourbaki> IYSWIN?
21:17:53 <Pseudonym> Nah, you're doing the geek girl who needs her pockets.
21:18:14 <Pseudonym> Men don't have handbags, they have pockets.
21:18:44 <wagle> piercings?
21:18:48 <Philippa> Pseudonym: shaved head, boots, tends to fancy other women...
21:19:05 <Pseudonym> OK, good point.
21:19:15 <Pseudonym> The last one is the important one.
21:19:15 <Philippa> OK, I'm bi, but with strong leanings
21:19:29 <Pseudonym> Without that, the "dyke" thing doesn't apply.
21:19:34 <Philippa> yeah
21:19:42 <Philippa> some'd claim it doesn't on account of being bi, but hey
21:20:27 <Pseudonym> "Dyke" is a state of mind.
21:20:31 <Pseudonym> Not a sexual orientation.
21:21:00 * Philippa nods
21:21:05 <wagle> whats lub of dyke and straight?
21:21:14 <Philippa> "fucks humans"
21:21:26 <wagle> haha
21:21:52 <Pseudonym> Actually, that's not a given either.
21:21:52 * wli puts Philippa on a motorcycle for the occasion
21:22:02 <wagle> i was more thinking that it might be hard to be successfully straight while all dyked out
21:22:06 <Pseudonym> It's perfectly possible to be a celibate dyke, or celibate and straight.
21:22:09 <Philippa> wagle: don't bet on it
21:22:17 <Philippa> Pseudonym: true
21:22:33 <Pseudonym> "Human" is probably the lub.
21:22:40 <Philippa> no, attracted to humans
21:22:45 <Pseudonym> Yes.
21:22:46 <Philippa> human includes asexuals
21:22:47 <Pseudonym> True.
21:23:14 <Pseudonym> What's the antonym of "asexual"?  No, it's not "sexual".
21:23:49 <jdrake> I should kick my ass about now, back in highschool about 7 or 8 years ago, I decided to take a summer school course environmental science instead of taking the grade 10 required science course. Sort of a technicality that my lazy ass used to get out of it. Now I might have to do that to do it for what I want.
21:23:49 <Philippa> "pansexual"?
21:24:01 <Philippa> (but that makes people think about goats)
21:24:18 <wagle> hermaphrodite?  (wrong, but..)
21:24:28 <wli> "pansexual" is too specific; the implication is effectively "not neuter".
21:24:28 <Philippa> wagle: wrong dimension, you're thinking sex rather than sexuality
21:24:55 <Philippa> wli: no, in this context asexual = no sexual attraction not no sex
21:24:57 <wli> maybe that's it, nonneuter
21:24:57 <wagle> Philippa: yeah, i know, but thought i'd throw it out for brainstorming value
21:25:17 * Pseudonym is thinking of all his Greek prepositions
21:25:21 <jdrake> I thought asexual was without gender
21:25:23 <wli> I'm not convinced there's an acronym for that.
21:25:29 <wli> er
21:25:30 <bourbaki> maybe you could put some more brain power from the sex thing into the length thing
21:25:30 <wli> antonym
21:26:05 <Pseudonym> I think "ensexual" is about the closest I can think of.
21:26:07 <Philippa> jdrake: gender != sex, first of all. 'asexual' doesn't imply 'has no sexes', some species are capable of both asexual and sexual reproduction
21:26:19 <Philippa> Pseudonym: what's the meaning you're after?
21:26:21 <Pseudonym> Or "consexual".
21:26:23 <wagle> sex > food > length
21:26:28 <Philippa> just "experiences sexual attraction"?
21:26:43 <Philippa> or "is sexually attracted to everything" (as opposed to nothing ala asexual)?
21:26:44 <Pseudonym> Uhm... I think so.
21:26:51 <Philippa> pansexual is the latter :-)
21:26:51 <Pseudonym> Someone who is a sexual being.
21:26:55 <Pseudonym> Right. :-)
21:27:00 <jdrake> Philippa, actually gender is 'sex', male and female is considered an answer to 'what sex are you'
21:27:02 <Philippa> plain 'sexual' makes sense
21:27:03 <cm> go back talking about FP ;-)
21:27:06 <jdrake> But I do see what you mean.
21:27:20 <Philippa> jdrake: gender and sex are only considered equivalent by the naive :-)
21:27:23 <jdrake> Asexual's opposite is sexual from what I am reading
21:27:24 <Pseudonym> cm: Actually, I was about to make a category theory joke.
21:27:34 <Pseudonym> We could introduce terms like "anasexual" and "catasexual".
21:27:37 <bourbaki> a is just like not
21:27:41 <wli> I suppose annelids uses fission in addition to self-fertilization and cross-fetilization
21:27:48 <bourbaki> asocial ie
21:27:50 <wli> don't forget parasexual and hylosexual
21:27:54 <Pseudonym> Right!
21:28:03 <cm> haha :)
21:28:08 <Pseudonym> And "monosexual", "episexual" and "isosexual".
21:28:13 <wli> sexual programming with bananas, lenses, envelopes, and barbed wire?
21:28:19 <Pseudonym> Kinky.
21:28:19 <cm> :)
21:28:21 <Philippa> monosexual is generally synonymous with wanker, hopefully that's what you mean?
21:28:26 <jdrake> Philippa, you are talking about semantics. Please read http://dictionary.reference.com/search?q=sex
21:28:41 <Philippa> jdrake: that's naive (amongst other things common) usage
21:28:43 <Pseudonym> jdrake: In what sense do you mean "semantics"?
21:28:52 <wagle> cosexual
21:28:55 <jdrake> Definition 1,2, and 3 are both what I am saying as one aspect of 'sex'
21:29:05 <Pseudonym> Oh, $DEITY.  What's the dual of sex?
21:29:12 <Philippa> Pseudonym: probably gender
21:29:13 <jdrake> 4 is the urge, 5 is the act, and 6 is the thing on the body
21:29:47 <wagle> initial or final?
21:29:47 <Philippa> jdrake: there are areas where usage #3 is considered strictly not part of sex
21:29:49 <jdrake> Pseudonym, a hermaphrodite by definition has both
21:29:55 <wli> genotype vs. phenotype?
21:30:07 <wagle> extended phenotype
21:30:12 <Philippa> (ignoring, perhaps, the physiological)
21:30:13 <wli> hermaphroditic != self-fertilization, though
21:30:19 <jdrake> Perhaps, but the usage is there and accepted
21:30:25 <Philippa> not by everybody
21:30:32 <Philippa> especially not by those whose sex and gender differ
21:30:37 <jdrake> Philippa, if it is in the dictionary it is common usage
21:30:38 <Pseudonym> Actually, I think that the term "asexual" is strictly speaking wrong.
21:30:48 <Philippa> jdrake: like I said, "naive" usage
21:30:49 <Pseudonym> "a" is a Greek alpha privatice, but "sexual" has a Latin root, doesn't it?
21:30:50 <wli> IIRC various mollusks are hermaphroditic without self-fertilization
21:30:50 <wagle> some hermaph plant self fert, some dont
21:30:54 <Pseudonym> privative
21:31:04 <Philippa> you'll find many other technically incorrect common usages in the dictionary
21:31:11 <jdrake> Philippa, none the less it is used
21:31:20 <Pseudonym> Should probably be "nonsexual".
21:31:28 <Philippa> jdrake: and liable to cause offence in the wrong situation
21:31:29 <wli> L. sexus
21:31:31 <bourbaki> non = a
21:31:42 <bourbaki> its just greek and latin
21:31:46 <Philippa> especially if you use it as crudely as "gender is sex"
21:31:51 <wagle> a = without, iirc
21:31:59 <Philippa> a statement which denies the identity of a fair number of people I know
21:32:05 <Pseudonym> alpha privative is a _translation_ of "non", but it's not "non".
21:32:38 <jdrake> Philippa, there is too much worry about causing offense these days
21:32:51 <Philippa> this is one I will not back down on
21:32:55 <Philippa> the statement is factually incorrect
21:33:05 <wli> Well, there's a decent-sized community that wants to build up some new descriptive distinctions, but they're not present in the history and etymology. Which is fine, I guess.
21:33:05 <Philippa> and in being incorrect causes outright damage to a significant number of people
21:33:20 <Philippa> it's not just "upsetting", it leads to decisions that culminate in causing suicide for many of them
21:33:25 <bourbaki> has anyone an idea on implementing length with trace?
21:33:48 <wli> bourbaki: what's trace?
21:33:54 <bourbaki> trace :: ((a,d) -> (b,d)) -> a -> b
21:33:54 <bourbaki> trace f a = let (c,d) = f (a,d) in c
21:33:58 <jdrake> Philippa, perhaps it will reduce the surplus population
21:34:01 <Pseudonym> Like most things in natural language, definition #3 is a generalisation.
21:34:05 <Philippa> well fuck you too
21:34:21 <Philippa> I just hope you end up on the receiving end of something similar
21:34:35 <Pseudonym> It works for most people, but there are areas where it breaks down.
21:34:41 <Pseudonym> It's liek the mathematician's concept of numbers.
21:34:54 <Philippa> and insisting on things where it breaks down is to say the least impolite
21:34:57 <Pseudonym> Most people have a working concept of numbers that doesn't work if you're a mathematician and need something more precise.
21:35:00 <bourbaki> i read all the words but it stops makeing sense
21:35:01 <Pseudonym> Yes.
21:35:07 <jdrake> Philippa, do you accept the wave of political correctness that has invaded society? It agree some is needed, but it seems to have gone very much too far.
21:35:19 <Philippa> jdrake: in this particular case, it is needed
21:35:25 <Pseudonym> jdrake: I don't think this is a political correctness issue.
21:35:31 <Pseudonym> I think this is an accuracy issue.
21:35:48 <Philippa> in this particular case, there is a 30% suicide rate in untreated individuals who're denied the distinction being made here
21:35:50 <Pseudonym> Some PC terms are euphemisms.
21:35:51 <jdrake> English is not known for accuracy
21:35:59 <Philippa> it's not just an accuracy issue, it's a life-and-death issue
21:35:59 <Pseudonym> This isn't a euphemism.
21:36:09 <Pseudonym> Philippa: I'm speaking linguistically. :-)
21:36:20 <Pseudonym> But I do take your point.
21:36:42 <Philippa> jdrake: the question is not what 'some' PC things are. It's what this particular thing is
21:36:50 <Pseudonym> Euphemism I have a problem with.  Accuracy I care about.
21:36:57 <Philippa> I agree a lot of stuff out there is just stupid. A fair amount of other stuff is important, however
21:36:59 <Pseudonym> Right, what Philippa said.
21:37:13 <Pseudonym> Like most things, there's a pendulum swing.
21:37:17 <Pseudonym> There was a time when nobody cared.
21:37:24 <Pseudonym> Now, some people care too much.
21:37:28 <bourbaki> important is to breath well if you think that life is important at all
21:37:37 <Pseudonym> Somewhere in the middle is where we should be.
21:37:50 <Philippa> that, and a few people've forgotten that however tiny your minority is you can still be a manipulative little shit
21:37:54 <wagle> need to get everyone beyond the words
21:37:59 <bourbaki> which it is not at all so its just important to distract yourself from thinking about it all the time
21:38:07 * Philippa would also like to strangle feminists who abuse the word 'rape' for propaganda value, for example
21:38:13 <Pseudonym> Yes, I agree with bourbaki there.
21:38:21 <Pseudonym> Caring only about words is missing the point.
21:38:25 <Pseudonym> That's caring too much.
21:38:35 <wagle> pc is about the words
21:38:39 <Pseudonym> If you're constantly watching your words, you miss the people they refer to.
21:38:49 <Philippa> yeah, it's the meaning of the statement "gender is sex" that I'm worried about
21:38:50 <bourbaki> so just distract yourself with my length prob and be nice since this will otherwise shorten your distraction time
21:38:53 <wagle> suicide as a result of the words is similar?
21:39:13 <bourbaki> communitacion is about convergeing
21:39:23 <Pseudonym> Actually, we don't have a good word for the distinction between "gender" and sex.
21:39:30 <bourbaki> there always is misunderstanding up to the convergeing point
21:39:44 <Pseudonym> "Gender" is a grammatical term, historically.  We don't have a good word for sexual identity.
21:40:04 <Philippa> Pseudonym: a lot of people consider it to be more than just sexual identity in a myriad of subtle ways, too
21:40:05 <Pseudonym> We don't have one, in particular, which adequately describes the nuances.
21:40:10 <Pseudonym> Sure.
21:40:22 <bourbaki> then just define them
21:40:25 <Pseudonym> The mere fact that the term "sexual identity" is also not a good term just underlines my point.
21:40:30 <wli> from L. generis, for "descent", "race", "kind", or (of course) "gender"
21:40:32 <jdrake> In english we could use 'it' as a pronoun but to anyone I know that reference would be offensive
21:40:43 <bourbaki> or use a decent language ;)
21:41:08 <Philippa> 'genderspace' as "the space of things people refer to by gender or similar concepts that're derived from loose associations with apparent sex" might work
21:41:15 <jdrake> how about lojban
21:41:42 <Philippa> jdrake: it will cause absolutely massive offence to somebody with a clear male or female gender identity. Most of the people I know whose identity is something else will suggest singular they atm
21:42:32 <bourbaki> ppl who get mad about words are fools imho
21:42:50 <Pseudonym> It's not words that people get mad about.
21:43:04 <Pseudonym> If I use a word which has connotations, it's the connotations that people get mad about.
21:43:07 <Pseudonym> Not the word itself.
21:43:08 <Philippa> sure. Meaning is another matter though, and 'it' has been used to dehumanise people in the past and thus carries that meaning when referring to a human being
21:43:13 <wagle> i think people get mad about the power of words
21:43:14 <Pseudonym> Right.
21:43:29 <Pseudonym> A word is just a sequence of letters or phonemes.
21:43:44 <wagle> umm
21:43:51 <Pseudonym> But it's like a scientists getting annoyed when people misuse scientific words.
21:44:04 <bourbaki> thats rediculous
21:44:14 <cm> nice pun :P
21:44:15 <bourbaki> he should explain and not go mad
21:44:26 <wli> In English, "gender" was originally used interchangeably with "sex", but that usage declined in favor of the grammatical use until the late 19th century, when it came into fashion to use it as a euphemism.
21:44:36 <Philippa> bourbaki: and when the person in question insists it's your problem?
21:44:41 <Pseudonym> There are only so many times you can explain before you get mad simply by having to explain.
21:44:45 <Philippa> as jdrake just did to me, incidentally
21:45:06 <Pseudonym> Sometimes, use the terms "stress" and "strain" interchangably in front of a physicist if you want to see what I mean.
21:45:13 <bourbaki> well i dont have problems apart the ones i accept and make myself
21:45:17 <Philippa> by attempting to reduce it to a 'PC' issue, a tactic I tend to have little respect for when it's used as an excuse for knowingly say something that is offensive for clear reasons beyond "I don't like that word"
21:45:17 * cm looks up strain
21:45:23 <bourbaki> which is why i keep hitting myself constantly
21:45:29 <Pseudonym> @wn stress
21:45:35 <lambdabot> *** "stress" wn "WordNet (r) 2.0"
21:45:35 <lambdabot> stress
21:45:35 <lambdabot>      n 1: the relative prominence of a syllable or musical note
21:45:35 <lambdabot>           (especially with regard to stress or pitch); "he put the
21:45:36 <lambdabot>           stress on the wrong syllable" [syn: {emphasis}, {accent}]
21:45:38 <lambdabot>      2: (psychology) a state of mental or emotional strain or
21:45:40 <lambdabot>         suspense; "he suffered from fatigue and emotional
21:45:42 <lambdabot>         tension"; "stress is a vasoconstrictor" [syn: {tension}, {tenseness
21:45:44 <lambdabot> [17 @more lines]
21:45:46 <Pseudonym> @more
21:45:46 <lambdabot> Sorry, I don't know the command "more", try "lambdabot: @listcommands"
21:45:49 <Pseudonym> Grrrr.
21:45:52 <wagle> Pseudonym: that like transposing freely while whistling near your friend who has absolute pitch?
21:45:53 <Philippa> remind me, is one twisting and the other linear?
21:46:02 <wli> I suspect the usage Philippa endorses will eventually become standard just because it actually allows one to make more fine-grained distinctions.
21:46:08 <Philippa> or was it something else? It's been more'n'half a decade ago
21:46:10 <Pseudonym> "PC" is itself an insult term.
21:46:14 <Pseudonym> We need a euphemism for "PC".
21:46:26 <Pseudonym> wagle: Kind of like that, yes.
21:46:40 <Pseudonym> Or like someone asking how you change the value of a variable in Haskell.
21:46:46 <wagle> hahaha
21:47:04 <bourbaki> somehow i feel pointd to some situations in books from authors like pratchett or adams
21:47:04 <Philippa> Pseudonym: it's a euphemism itself. It means doublespeak. *Especially* when used by somebody who actually believes in the underlying issues that're being buried under a wave of PC crap stopping people discussing them, something which does indeed happen
21:47:09 <Riastradh> English is a very precise language.  Using it inaccurately degrades its precision and inhibits certain meaningful communication.
21:47:18 <Philippa> bourbaki: funny that. Lotta trans people in pratchett fandom for some reason :-)
21:47:23 <wli> cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs)
21:47:33 <wli> I want a version of that that works with both finite and infinite lists
21:47:43 <jdrake> Philippa, just to note, the surplus population comment was a way of saying how stupid all of it seems
21:47:53 <Philippa> well fuck you. One of them's my boyfriend
21:48:16 <Philippa> you might wish to consider possibilities like that before joking about issues that cause that level of personal harm
21:48:36 <Pseudonym> The only surplus population is the B Ark.
21:48:40 <Philippa> heh
21:48:43 <bourbaki> i think you just should stop talking to each other
21:48:51 <bourbaki> and whats surplus anyway?
21:49:24 <jdrake> bourbaki, beyond what is needed, or beyond capacity. In human terms that is never taken well
21:49:47 <Philippa> nor, more generally, is the statement "let them die"
21:50:06 <cm> @wn PC
21:50:07 <lambdabot> *** "PC" wn "WordNet (r) 2.0"
21:50:07 <lambdabot> PC
21:50:07 <lambdabot>      n : a small digital computer based on a microprocessor and
21:50:07 <lambdabot>          designed to be used by one person at a time [syn: {personal
21:50:08 <lambdabot>          computer}, {microcomputer}]
21:50:08 <cm> *ducks* :)
21:50:27 <Pseudonym> It's interesting, actually.  THere are, undoubtedly, too many humans on the planet.  But I can't identify many specific individuals that should be removed from the face of the earth.
21:50:36 <wagle> so pc terms should be used only by one person at a time?
21:50:47 <Pseudonym> So finding a referrent for the term "surplus population" is difficult.
21:50:52 <Philippa> Pseudonym: reduced population growth will do the trick
21:50:57 <Pseudonym> Yes.
21:51:05 <cm> .oO(what does "PC" mean?)
21:51:20 <Riastradh> cm, 'politically correct.'
21:51:38 <Pseudonym> Or "program counter".
21:51:49 <wli> so
21:51:57 * cm hits Pseudonym with the stick of concurrency
21:52:01 <wli> I'm a bit stumped by these monadic interpreter thingies.
21:52:16 <wli> let's see
21:52:30 <Riastradh> You take a monad.  Then you take a language.
21:52:41 <Riastradh> Then you repeatedly hit the language with a monad until you feel it is interpreted well enough.
21:52:43 <wli> (I largely have in mind banging out interpreters for command languages and such on the fly.)
21:52:49 <wli> Riastradh: heeh
21:52:59 <jdrake> I have always seen the word 'sex' used in so many ways, that I see no problem associating it with gender - because I have always done so. When used in context as a gender (that is physical sexual identity) there should be no problem. Contexts such as medical forms are case in point, others such as marriage license sexual gender would be less important.
21:53:19 <Pseudonym> jdrake: And you're right for the overwhelming majority of cases.
21:53:31 <Philippa> jdrake: how about simply "how do I treat this person?"
21:53:46 <Pseudonym> Like for the overwhelming majority of cases, identifying a second with 1/86400 of a mean solar day works.
21:53:50 <Pseudonym> Unless you're a physicist.
21:54:01 <Philippa> incidentally, good medical forms will ask for sex rather than gender when that's what they mean, because in medical usage the terms are indeed distinct
21:54:06 <Philippa> if they want your sex, they should ask for that
21:54:09 <cm> pardon my ignorance -- how do you pronounce the beginning of "euphemism" in English? like the "eu" in "Europe"?
21:54:16 <Pseudonym> cm: Yes.
21:54:33 <bourbaki> the sex section on forms is also good for a joke always
21:54:47 <Pseudonym> "No thanks, had some this morning."
21:54:53 <bourbaki> right ;)
21:55:01 <bourbaki> frank drabin in naked gun
21:55:02 <wagle> "yes, please"
21:55:24 <bourbaki> frank: what did he wanted to do there?
21:55:33 <bourbaki> the other guy: sex frank?
21:55:37 <bourbaki> frank: no thanks
21:55:39 <wli> Philippa: Another good question is "What went wrong in Europe?"; the ancients seemed to have general decency in this area, and somewhere it all went to pot.
21:56:21 <Pseudonym> Some people like pot.
21:56:24 <Philippa> wli: eh?
21:56:27 <jdrake> Philippa, I have no problem identifying people by what part they feel they play. I play the part of a male both mentally and physically. I have had a teacher that was male physically but female mentally. Unfortunately this teacher was pressured by the college and ended up becoming male the next year. A year or two after I left the school the teacher had an physical attack happen.
21:56:43 <Philippa> jdrake: that's sad
21:57:04 <jdrake> It is, because this teacher was one of the best teachers they had in my opinion
21:57:16 <Philippa> thankfully, in the UK that wouldn't happen now, it'd be constructive dismissal
21:57:28 <Philippa> but I've seen a few folks get dragged back and forth by social conditions
21:57:42 <Philippa> incidentally, it tends to be a bit more than the part somebody plays
21:57:53 <wagle> "constructive dismissal"
21:57:54 <wagle> ?
21:57:55 <wli> In Amerikkka they'd be lucky not to get lynched. But I could probably use some monad help more than a review of what's wrong with the world.
21:58:21 <Pseudonym> Yes, monad help
21:58:23 <jdrake> wli, have you prayed to Monadia yet today?
21:58:27 <Pseudonym> Have you read the Mark Jones paper?
21:58:29 <Philippa> most of the TS folks I know actually have issues with their natural hormone balance, in that it doesn't work right for them
21:58:38 <wli> Pseudonym: several
21:58:51 <Philippa> wli: it depends where in the US
21:58:58 <wli> and springschool95.ps and marktoberdorf.dvi etc.
21:58:58 <Pseudonym> "Monad transformers and modular interpreters" is the one I'm thinking of.
21:58:59 <wagle> william harrison's got some stuff
21:59:07 <wli> Pseudonym: haven't seen that
21:59:13 <Philippa> the hard part in the US is when they hit about 18 and they realise what's going on and that they don't have the money to both get the medical care and go to uni/college...
21:59:22 <wagle> liang's three papers (one his dissertation)
21:59:25 <Pseudonym> wli: citeseer.ist.psu.edu/context/43556/14178 
21:59:49 <Pseudonym> Uhm...
21:59:53 <Pseudonym> That's a context one, actually.
22:00:26 <Pseudonym> It's on his publications page, anyway.
22:00:29 <Pseudonym> http://www.cse.ogi.edu/~mpj/pubs.html
22:00:35 <wli> well, I've scoured the net for stuff, so...
22:00:52 <wagle> i think mpj's is off a little, unless i got him to update it
22:01:18 <wli> the monadic interpreter paper isn't in mpj's pubs lists
22:01:19 <Pseudonym> SO what's your problem?
22:01:26 <Pseudonym> http://www.cse.ogi.edu/~mpj/pubs/modinterp.html
22:02:14 <wli> Pseudonym: basically, I can recite a bunch of stuff I've seen in papers forward and backward but I still can't work with the things effectively
22:02:36 <Philippa> wli: play with the stuff in the GHC libraries a little to build a custom monad for a while?
22:02:43 <Philippa> State + Error might be a good initial combination
22:02:46 <wagle> wli: http://www.cs.missouri.edu/~harrison/
22:03:12 <Philippa> monadic interpreters're just interpreters that use monads to implement all the interesting bits of the semantics
22:03:46 * Philippa suspects the vast majority of 'interesting' semantics decisions amount to which transformers to use in which order, as it were
22:03:55 <Philippa> though you may need to generalise to arrows
22:04:40 <wagle> Philippa: i want real type inequalities too
22:04:42 <wli> well, the main thing I want to do is build dumb command language things very very quickly
22:04:59 <Philippa> wli: what kinda commands?
22:05:21 <Philippa> if it's really just "do this, do that", then use whatever monads would make implementing routines involving the this and that easy to write
22:06:23 <wli> Philippa: it varies a lot, calculator-like ones look functional, query language -like ones look like logic, and shell -like ones look imperative. They're really stupider than they sound, though.
22:06:30 <bourbaki> ive got it!!!
22:06:55 <Philippa> wli: OK, that does sound like monads'd make sense - some form of list+state combo is often good for logic programming
22:07:19 <Pseudonym> I have a logic programming monad transformer handy if you want it.
22:07:30 <Philippa> is it just the transformers that don't really make sense, or is it monads in general in that context?
22:07:33 <Pseudonym> It even has if-then-else with soft cut.
22:08:00 <bourbaki> Pseudonym do you have a paper on that as well or just code cause i hate reading code
22:08:06 <wli> Philippa: well, it's more that I want to do lots of different tiny ones on-demand, not ones using aspects of all paradigms
22:08:12 <Pseudonym> Code, and the paper that it's based on.
22:08:27 <bourbaki> Pseudonym id be interested in the papers or the links
22:08:32 <Pseudonym> http://www.cs.mu.oz.au/~lee/papers/prune/
22:10:01 <wagle> Pseudonym: code?
22:10:44 <wli> They're mostly trivial and a lot won't even qualify as Turing-complete.
22:10:48 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/mtl/
22:10:51 <wli> one example is my permutation calculator
22:11:03 <wli> http://holomorphy.com/~wli/Permutation.hs
22:11:11 <Philippa> wli: monad transformers are, if you'll excuse my language, fucking wonderful for that kind of thing
22:11:23 <wli> Philippa: yeah, that's why I'm desperate to get my hands on them
22:11:55 <wagle> "domain specific languages" is a current buzzword
22:12:00 <bourbaki> has anyone ever done anything interesting with trace?
22:12:12 <bourbaki> now that i look at it my solution seems really trivial
22:12:16 <Pseudonym> bourbaki: You mean apart from debugging and finding interesting bugs?
22:12:19 <Philippa> wli: got a language/set of semantics you'd like done as an example?
22:12:24 <wli> wagle: they're basically that, but syntax matters a lot, so they can't really be represented as combinators in a Haskell toplevel
22:12:32 <Philippa> (preferably not one specified in Haskell already ;-)
22:12:37 <bourbaki> Pseudonym nope sec
22:12:45 <Philippa> wli: that just means they're not DS/E/Ls
22:12:48 * cm is excited to try hs-plugins in action
22:12:52 <wagle> not everyone pretends haskell syntax is a universal syntax
22:13:14 <bourbaki> Pseudonym http://rafb.net/paste/results/CKP2kB75.html
22:13:19 <wli> well, it's not a bad assumption from my POV, just not applicable to the situations I land in
22:13:22 <Philippa> yeah. It's nice if you want to use the DSL within Haskell code and the syntax is vaguely sane, but if the entire program's gonna be in the DSL it doesn't matter
22:13:46 <dons> cm: what are you using it to do
22:13:56 <Pseudonym> bourbaki: Ah, I thought you meant Debug.trace.
22:14:04 <bourbaki> nope
22:14:08 <wli> well, one I banged out recently (the Permutation.hs above) looks like:
22:14:09 <wli> 20> <(1 2),(1 2 3)>
22:14:09 <wli> {(), (1 2), (1 2 3), (1 3), (1 3 2), (2 3)}
22:14:17 <wli> 22> {(1 2)^2, (1 2 3)^2, (1 3)^2, (1 3 2)^2, (2 3)^2}
22:14:17 <wli> {(), (1 2 3), (1 3 2)}
22:14:26 <bourbaki> i mean the recursion ive done now is in bar entirely
22:14:38 <wli> vaguely like a castrated SETL 
22:14:43 <bourbaki> which lead the whole trace thing ad absurdum
22:15:47 <Philippa> wli: I'm not quite following that one. But looks like it's the sort of thing you'd do in the list monad, yeah?
22:15:50 <SyntaxNinja> y0
22:15:56 <cm> ghc-6.2: panic! -- heh
22:16:20 <cm> dons: "servlets" running on a Haskell web server
22:16:36 <dons> like Haskell Server Pages?
22:16:39 <cm> or well, checking out whether hs-plugins would suit my needs for that
22:16:42 <wli> curly braces for sets, angle brackets for sets generated by elements, juxtaposition of elements is permutation composition, juxtaposition of an element with a set is a coset, juxtaposition of sets x, y is [a `compose` b | a <- x, b <- y]
22:16:57 <bourbaki> can someone do a lenght with trace without useing lenght or redefineing that in an outer function?
22:17:04 <cm> dons: in its use of plugins?
22:17:14 <dons> I think so, yes.
22:17:19 <cm> most probably
22:17:32 <dons> they use it to evaluate Haskell scripts in the server -- is that the idea?
22:17:51 <wagle> length x = trace ? x
22:17:51 <wli> I've been meaning to add stuff like (set)^k (k an integer "power") to be [a1 `compose` (a2 `compose (... an)...) | a1 <- x1, a2 <- x2, ...]
22:17:52 <wagle> ?
22:18:05 <Philippa> wli: sounds like you're doing the lot in the list monad already?
22:18:08 <wli> where x1 ... xn are all identical for s^k
22:18:17 <Philippa> this probably isn't an example where a transformer'd buy you a more useful monad
22:18:21 <wli> Philippa: none of it is done in the list monad, which is why I'd rather have done it in the list monad
22:18:32 <cm> dons: i want to be able to reload components on the fly
22:18:38 <bourbaki> why is there a difference in
22:18:45 <wli> Philippa: or anything that effectively does all this work for me
22:18:50 <bourbaki> bar (l,x) = case (length l) of { 0 -> 0; _ -> bar((tail l), x);}
22:18:50 <bourbaki> f(x,y) = ( y,  1 + bar(x, y))
22:18:52 <bourbaki> and
22:18:58 <dons> ok. sounds appropriate to use hs-plugins.
22:19:04 <bourbaki> f(x,y) = ( y,  bar(x, y)) ?
22:19:23 <cm> dons: got any idea about ghc panic'ing: Loading package plugins ... linking ... /usr/local/lib/hs-plugins/HSplugins.o: unknown symbol `addDLL'
22:19:25 <bourbaki> bar (l,x) = case (length l) of { 0 -> 0; _ -> 1+bar((tail l), x);}
22:19:29 <dons> cm: pretty easy too. we use it in yi to reloadable config files written in Haskell
22:19:32 <Philippa> wli: the meat's in eval, right?
22:19:38 <dons> cm: you're using an old versionn of ghc
22:19:42 <wli> Philippa: yes
22:19:45 <dons> you need ghc-6.2.2 >=
22:20:02 <cm> dons: ah, thanks. using 6.2(.0)
22:20:16 <Philippa> about the only sensible thing I could see to do there is find a way to have it do the sort.nub thing automagically. But you'd lose the list comprehensions
22:20:26 <dons> hmm. I think that also means you are trying to load hs-plugins itself, dynamically (?)
22:20:27 <Philippa> (which're basically list monad stuff, 'cos same difference)
22:20:37 <dons> cm: so your plugin itself imports Plugins?
22:20:38 <wli> a "set monad" instead of a "list monad"
22:20:51 <cm> dons: just -package plugins
22:20:55 <Philippa> wli: right
22:20:57 <cm> "ghci -package plugins"
22:21:07 <dons> oh. ok. sure. ghc*i*8
22:21:13 <dons> ghci uses dynamic linking
22:21:20 <Philippa> which you'd probably implement by wrapping the list type. But atm it'd be more typing than it'd save
22:21:26 <dons> and you're loading the dynamic linker library ... dynamically.
22:21:27 <Philippa> eval's pretty tiny atm
22:21:35 <cm> yup that's what I'm doing
22:21:40 <dons> support for that made it into 6.2.2
22:21:52 <bourbaki> off to bed now nighto
22:21:52 <cm> awesome -- downloading :)
22:22:05 <Philippa> so you're probably getting as much out of it as you can atm. Would be different if you had some kind of state involved, say
22:22:08 <cm> hs-plugins looks really useful from what I see in the docs
22:22:23 <cm> and I'm thirsty but I don't know why :/
22:22:31 <dons> you'll probably want  to use the cvs snapshots, as they're getting close to release
22:22:47 <cm> of ghc, or hs-plugins?
22:22:54 <dons> and contain several bug fixes over 0.9.6 (of hs-plugins)
22:23:00 <cm> k
22:23:02 <dons> also, a better api.
22:23:11 <wagle> i've seen a set monad somewhere
22:23:14 <wli> Philippa: well, not everything is quite what it should be
22:23:34 <Philippa> what needs changing?
22:23:35 <wli> Philippa: for instance, the "set to a power" thing is natural but needs a raft of new code
22:24:04 <dons> cm: feel free to ask questions, or send email when I'm not online.
22:24:21 <Philippa> that looks like you could do it as a foldM or something - it'd interpret it as being in the List monad automagically, I'd have thought
22:24:22 <wli> and joins and intersections should be there too
22:24:38 <Philippa> join and intersect're existing list functions, right?
22:24:43 <wli> H `join` K would be basically <H `union` K>
22:24:45 <cm> dons: cheers, and thanks for the nice software
22:24:46 <wli> Philippa: not quite
22:24:54 <wli> Philippa: join is group-theoretic join
22:25:06 <Philippa> remind me of the difference? My maths is shockingly poor
22:25:25 <dons> is anyone else using hs-plugins for some unknown project that I don't know about? -- I have to come up with a funding proposal so I can keep working on it for another year or two...
22:25:28 <wli> Philippa: well, it's pretty easy, the angle brackets for groups generated by things are the key
22:26:00 <wli> Philippa: < x, y, z > is where you do all expressions involving x, y, and z until you no longer get unique results.
22:26:10 <Philippa> dons: I don't think it'll end up in Flippi sadly, I suspect it should be in whatever Flippi's running in instead
22:26:23 <dons> ah, ok. that seems reasonable
22:26:26 <cm> (i don't *need* hs-plugins at this stage of the project, but I just want to see whether I can make everything as dynamic as it should eventually be)
22:26:41 <wli> Philippa: So for 2 groups H, K, (sets, really), H `join` K would basically be < H `union` K > where union is an ordinary set-theoretic union
22:27:03 <Philippa> however, feel free to cite it as an example of a Haskell program that configures itself using Haskell code and thus can use being on top of a plug-in substrate
22:27:25 <Philippa> the current release just has the script interface atm, but the next release is looking to be one major upheaval in that regard
22:27:32 <dons> ah! it configures itself with haskell -- so that must be static atm?
22:27:34 <wli> Philippa: i.e. all possible products of things taken from the union of H and K
22:27:43 <Philippa> I mean, I just wrote a bunch of stuff so you can plug in transformers for the page IO routines
22:28:04 <Philippa> wli: intersect-then-powerset then?
22:28:14 <dons> ok. yeah, probably would be cool to have true plugins for it, lambdabot style (?)
22:28:20 <wagle> "transitive closure"
22:28:40 <wli> Philippa: well, the way I do it is to take the products of all pairs, nub, and iterate to convergence
22:28:52 <Philippa> fair enough
22:28:56 <wli> Philippa: (products are noncommutative so both orders are needed)
22:29:12 <Philippa> dons: indeed - which could be done simply by running Flippi under a plugin system with the config module as a separate package
22:29:45 <dons> yep. could the config module be a Yi-style reloadable module?
22:30:05 <dons> (i.e. haskell as an extension language)
22:30:18 <Philippa> probably, though I'd rather not put hs-plugins into Flippi itself
22:30:26 <Philippa> not while it's set up to run as a one-shot CGI
22:30:39 <Philippa> 'cos if the user wants that, they have runhugs or runghc
22:30:53 <dons> ah. that's a nice idea.
22:31:07 <jdrake> if I have a function, rectangle, that produces a '
22:31:10 <jdrake> oops
22:31:56 <jdrake> if I have a function, rectangle, that produces a Shape - should that shape be centred on 0,0 or should it be edged on 0,0
22:32:19 <wli> what's flippi?
22:32:40 <Philippa> wli: wiki clone written in haskell. Extremely lightweight, also somewhat lacking in features
22:32:46 <wagle> wli: permute "Philippa"
22:33:22 <wli> I suppose eliding the first vowel does it, too
22:33:30 <cm> I wonder how hard it would be to plug in Flippi into my web server
22:33:49 <cm> probably just a matter of passing the proper arguments to the cgi's "main", I guess?
22:33:53 * cm downloads FLippi
22:34:21 <Philippa> cm: yep
22:34:31 <Philippa> I can export the cgi value from Flippi.hs if you want
22:35:03 <Philippa> anyway, I've largely been hacking on Flippi's core functionality, it sprung support for metadata recently and is rapidly becoming more configurable
22:35:07 <cm> let me have a glance at the sources
22:35:09 <wagle> wli: i see google for "set monad" (w/ quotes), "bag monad", and (maybe) "group monad"
22:35:13 <Philippa> I'm actually going to end up with a pluggable wiki parser at this rate
22:35:23 <Philippa> at some point I'll have it parsing to an AST and have separate rendering plugins
22:37:17 <cm> is there a reason why you do "action <- return (parseParms qs) instead of let action = parseParms qs?
22:37:32 <cm> or just, case parseParms qs of 
22:37:32 <Philippa> habit
22:37:38 <cm> k
22:37:50 <Philippa> so no, not really, might even tweak it that way later on if I feel like it
22:38:11 <wagle> hers is more obviously a expression of monadic type
22:38:36 <cm> now let me see how long it takes to plug in Flippi :-)
22:39:14 <wagle> of course, i dont know the context
22:41:03 <Philippa> wagle: "we just got given a CGI environment, WTF are we going to do?"
22:41:12 <Philippa> top-level dispatch from a value to an IO action, IOW
22:43:02 <wagle> i like self-documenting code (when its appropriate)
22:43:44 <wli> hmm
22:43:51 <wli> set monads don't like the Eq constraint
22:44:21 <wli> data Set t = Set [t] deriving (Eq, Ord, Read, Show)
22:44:21 <wli> instance Functor Set where
22:44:21 <wli>         fmap f (Set xs) = Set . nub $ map f xs
22:44:21 <wli> instance Monad Set where
22:44:21 <wli>         return = Set . (:[])
22:44:21 <wli>         s >>= f = Set $ foldr union [] [xs | Set xs <- fmap f s]
22:44:43 <Philippa> wli: write it manually?
22:45:00 <wli> not sure what you mean
22:45:15 <Philippa> instance Eq (Set t) where ...
22:45:25 <wagle> data Eq t => Set t = Set [t] deriving ...
22:45:46 <Philippa> better yet, instance Eq t => Eq (Set t) where ...
22:46:17 <wagle> yeah.. i dunno if mine was sufficient
22:46:41 <wagle> no mine wasnt
22:47:00 <wagle> you need to write your own, since you have to consider permutations
22:47:34 <Pseudonym> Must away.  Nytol!
22:47:47 <jesse98> cool, my bbedit plugin now has a definition popup menu and color codes definition names
22:48:28 <Philippa> heh
22:48:44 <Philippa> I need some form of haskell tags app then I can have jump-to-definition in textpad
22:48:56 <wli> data Eq t => Set t = Set [t] ... doesn't seem to do it
22:49:06 <wli> nor does an explicit instance Eq t => Eq (Set t)
22:49:59 <wagle> deriving Eq for Set wont work..  it wont know that element order is not relevant
22:50:05 <wli> okay true
22:50:17 <wagle> the explicit instance for Eq should work
22:50:24 <Philippa> what's it complaining about with the explicit instance?
22:50:29 <wli> data Eq t => Set t = Set [t] deriving (Ord, Read, Show)
22:50:29 <wli> instance Eq t => Eq (Set t) where
22:50:29 <wli>         (Set xs) == (Set ys) = all (`elem` ys) xs && all (`elem` xs) ys
22:50:29 <wli> instance Functor Set where
22:50:29 <wli>         fmap f (Set xs) = Set . nub $ map f xs
22:50:29 <wli> instance Monad Set where 
22:50:31 <wli>         return = Set . (:[])
22:50:33 <wli>         (Set xs) >>= f = Set $ foldr union [] [ys | Set ys <- map f xs]
22:50:34 <wagle> but you gotta tell it how to compare
22:50:35 <wli> new version
22:50:42 <wli> okay, there's a long list of complaints
22:50:59 <wli> SetMonad.hs:11:
22:50:59 <wli>     Could not deduce (Eq a) from the context (Monad Set)
22:50:59 <wli>       arising from the pattern `Set xs' at SetMonad.hs:11
22:50:59 <wli>     Probable fix:
22:50:59 <wli>         Add (Eq a) to the class or instance method `>>='
22:50:59 <wli>     When checking the pattern: Set xs
22:50:59 <Philippa> start from the top?
22:51:02 <wli> that's one of them
22:52:00 <Philippa> eww
22:52:08 <Philippa> that looks... odd
22:52:13 <wli> they're all like that
22:52:20 <Philippa> more examples?
22:52:24 <Philippa> I mean, that one looks /broken/
22:52:27 <cm> Philippa: Internal Server Error, I'm gettin close ;-)
22:52:33 <cm> (currently passing an empty env array)
22:52:34 <Philippa> cm: heh
22:52:39 <wli> SetMonad.hs:8:
22:52:39 <wli>     Could not deduce (Eq a) from the context (Functor Set)
22:52:39 <wli>       arising from the pattern `Set xs' at SetMonad.hs:8
22:52:47 <wli>     Probable fix:
22:52:47 <wli>         Add (Eq a) to the class or instance method `fmap'
22:52:47 <wli>     When checking the pattern: Set xs
22:52:47 <wli>     In the definition of `fmap':
22:52:47 <wli>         fmap f (Set xs) = (Set . nub) $ (map f xs)
22:52:47 <wli>     In the definition for method `fmap'
22:52:50 <Philippa> an empty env array means you're getting exceptions inside flippi
22:53:01 <Philippa> the version on my HD catches them now
22:53:01 <wagle> get rid of my Eq t => on the data
22:53:12 <cm> Philippa: my server catches them as well ;-)
22:53:17 <cm> 500 Internal Server Error
22:53:17 <wli> wagle: looks the same
22:53:18 <cm> Maybe.fromJust: Nothing
22:53:23 <Philippa> yep
22:53:26 <Philippa> that'll be inside Flippi
22:53:30 <Philippa> doing a lookup on the env
22:53:34 <wli> wagle: no, slightly fewer errors
22:53:39 <wli> wagle: only complaining about the monads
22:53:40 <cm> Philippa: that's what the entire force evaluation thread was about on haskell-ml :/
22:53:51 <cm> got nice help there
22:53:52 <wli> no it still complains about functor too
22:53:56 <Philippa> it assumes the things it should always get from a CGI environment are there
22:54:03 <wagle> wli: i was trying to get it to derive Eq
22:54:33 <wagle> the instance Eq seems fine
22:54:44 <cm> Philippa: yeah, I'm just about to hack that in :-)
22:55:17 <Philippa> cm: if you pick a standard name for "innards of a Network.CGI wrapper" funcs, that would be cool
22:55:29 <wli> well, I'm all ears
22:55:42 <wli> (but otherwise stumped)
22:56:03 <wagle> ERROR wli.hs:5 - Undefined variable "nub"
22:56:09 <wli> import List
22:56:56 <wli> My .ghci has :set -fglasgow-exts :set -fallow-overlapping-instances :set -fallow-undecidable-instances :set -fno-monomorphism-restriction :set -funfolding-update-in-place :set +t :set -syslib data :set -syslib net :set -package gmp :set -package rts :set -package std :set -package lang :set -package concurrent :set -package data :set -package net :set -package posix :set -package text :set -package util :set -package hssource
22:57:02 <KrispyKringle> forgive me for asking basic questions, but can one escape newlines or otherwise do something to easily compose functions in ghci ?
22:57:38 <wli> KrispyKringle: incremental parsers are handy there
22:57:42 <wli> KrispyKringle: not that we have them
22:57:49 <wli> KrispyKringle: but c.f. zsh for an example
22:58:03 <Philippa> KrispyKringle: er, you don't generally need to escape them?
22:58:04 <wli> KrispyKringle: if you end a line in the middle of a syntactic construct zsh puts an implicit line continuation in
22:58:06 <KrispyKringle> so if i want to do more than toy around--if i want to write a function--i must use an external .hs?
22:58:15 <Philippa> ah
22:58:16 <Philippa> yes
22:58:17 <KrispyKringle> Philippa: sure you do. 
22:58:23 <KrispyKringle> thanks guys :)
22:58:28 <Philippa> KrispyKringle: you're playing with an interpreter, that's different :-)
22:58:45 <Philippa> basically, you do need a .hs for real work
22:58:47 <KrispyKringle> Philippa: i've just deduccted two geek-creds from my Nerd-O-Meter for you. ;)
22:58:50 <KrispyKringle> yeah, figures. 
22:59:20 <wli> well, either that or you get used to typing monster crud at the interpreter shell (c.f. moi)
22:59:21 <KrispyKringle> i was thinking maybe one could do, like, foo x = \
22:59:24 <KrispyKringle> whatever...
22:59:49 <KrispyKringle> well, with Emacs, and Emacs-shell, i can easily type into the .hs and reload it at the ghci shell in one go ;)
23:00:13 <Philippa> :r is your friend when working with ghci
23:00:36 <wli> actually incremental parsing for zsh-style syntax closure -based implicit line continuations and similar would be an interesting topic
23:00:52 <wli> but I seem to be having trouble with far more basic monads (i.e. still not getting anywhere with the set monad)
23:01:23 <KrispyKringle> but you don't need to do any actual parsing at the interpreter to implement this. you merely need to recognize that a newline is escaped and not do any parsing yet. 
23:01:26 <KrispyKringle> unless i'm mistaken. 
23:01:28 <KrispyKringle> which i may be.
23:01:31 <KrispyKringle>  it happens a lot. 
23:01:37 <wli> KrispyKringle: that's the more basic notion
23:01:42 <wli> KrispyKringle: explicit line continuation
23:01:47 <KrispyKringle> right. 
23:01:48 <wli> KrispyKringle: let me paste an example
23:01:50 <KrispyKringle> i see what you were saying. 
23:02:01 <Philippa> KrispyKringle: on the bright side, it doesn't need to be one line anyway
23:02:02 <KrispyKringle> i was just pointing out that it'd be trivial to implement it in a usable form. 
23:02:13 <Philippa> not in the screen space sense, at least
23:02:15 <KrispyKringle> Philippa: which? in the .hs, or in the interpreter?
23:02:18 <Philippa> it's just the editing that's a bitch
23:02:20 <wli> $ for f in /mnt/HS/*.hs
23:02:20 <wli> > do
23:02:20 <wli> > ls -l $f
23:02:20 <wli> > done
23:02:24 <wagle> it doesnt like the nub needed eq
23:02:40 <wli> the '$ ' prompt is $PS1, the first-level prompt
23:02:41 <KrispyKringle> wow!
23:02:46 <KrispyKringle> i didn't know zsh could do that. 
23:02:47 <wli> the '> ' is $PS2, the 2nd-level prompt
23:02:53 <KrispyKringle> i might have to switch fvrm bash. 
23:03:01 <KrispyKringle> from, even. i should also learn to type. 
23:03:09 <cm> Philippa: I will change my "startCGI" function to take a [(String,String)] -> IO Html
23:03:32 <KrispyKringle> of course, wli, being a functional programmer, wouldn't you rather write that out recursively? :P
23:03:41 <wli> when you fail to complete "for", "while", or other kinds of syntactic constructs on a given line, it implicitly continues the line, and changes the prompt to be an indicator of nesting level
23:03:52 <KrispyKringle> that's pretty damn slick. 
23:04:01 <KrispyKringle> this is zsh, right?
23:04:22 <wli> KrispyKringle: I'm not a functional programmer per se. I use whatever paradigm is appropriate for the task, and go searching for the language whose execution model is most suited to a given task when I go about a task. =)
23:04:31 <cm> Philippa: so that it plays fine with any Network.CGI-style cgi
23:04:37 <wli> KrispyKringle: yes, zsh
23:04:39 <cm> Philippa: wanna see a screenie? ;-)
23:04:46 <Philippa> cm: have both, but sure. And yeah
23:04:51 <wli> KrispyKringle: it had a precedent in tcsh IIRC
23:04:54 <KrispyKringle> ill emerge it now. 
23:04:56 <wli> KrispyKringle: but a much more crude one
23:05:13 <Philippa> wli: I'm an abuse-of-FP coder - it gives me a good starting point to frig with other notions
23:05:20 <KrispyKringle> wli: you responded to my FP joke far too seriously ;)
23:05:35 <KrispyKringle> its 2:05 AM my time. I can't talk shop with a straight face :P
23:05:44 <wli> one reason why this kind of incremental parsing is particularly interesting is because the extant implementations of it are obscenities worthy of crimes-against-humanity tribunals.
23:06:05 <wli> So a "properly constructed" form of the things would be rather helpful.
23:06:47 <cm> Philippa: mind you, nothing but the front page works (of course my lack of implementation, not your fault), but hey :-) http://www.unfinity.de/pla.png
23:06:49 <wli> wagle: well, I know that the Eq constraint is killing me
23:06:56 <wli> wagle: but I don't see any way around it
23:07:26 <musasabi> morning
23:07:27 <wagle> yeah
23:08:01 <cm> Philippa: I hope by tomorrow night it will be a matter of doing "import HTTP.CGI; startCGI cgi" and you are set
23:08:03 <wagle> i think the problem is that you need a List2Set function
23:08:05 <monochrom> List.union assumes Eq t too.
23:08:19 <musasabi> cm: imho a good cgi interface is not tied to html...
23:08:20 <KrispyKringle> wli: but in order to be able to do this, you must construct the grammar to be parsable without lookahead. Not every language can do this, aye?
23:08:32 <wagle> you shouldnt be able to apply the Set data constructor to just any list
23:08:33 <wli> monochrom: well, I need some way to say "this monad requires Eq"
23:08:34 <musasabi> but this is only because I want to serve non-html things.
23:08:36 <cm> musasabi: okay, go fix Network.CGI :)
23:08:57 <KrispyKringle> i mean, i have no idea whether haskell can or not. 
23:09:06 <wli> wagle: well, it's already got data Eq t => Set [t] ...
23:09:07 <wagle> i was first thinking you needed a nub :: Set a -> Set a
23:09:21 <cm> musasabi: this is only for interopability with Network.CGI-style CGIs
23:09:22 <wli> wagle: but that's going to require Eq a
23:09:49 <wli> KrispyKringle: you need to have rather strong forms of prediction
23:09:55 <musasabi> cm: ok, then. That is one reason I don't use Network.CGI
23:10:08 <cm> musasabi: i.e. just to be able to brag because Flippi runs with 2 lines of code ;)
23:10:23 <wagle> wli: i'm not thinking quickly..  need food and sleep
23:10:30 <wli> okay, other ideas?
23:10:48 <cm> musasabi: the real thing I want to do with flow is to toy around with a couple of web "framework" ideas
23:11:11 <cm> musasabi: so it's more of a unit test for the base layer (the HTTP modules), I guess ;)
23:11:17 <cm> (I totally agree, btw)
23:11:47 <Philippa> musasabi: I agree Network.CHI sucks, and a Flippi.CGI stand-in is kinda likely at some point (if only so I can generate RSS feeds)
23:12:08 <cm> Philippa: maybe we can agree on a sensible CGI interface at some point
23:12:19 <KrispyKringle> wli: strange forms of prediction? I'm not sure what you mean. If the grammar cannot be parsed without lookahead, which is fairly common in "full" languages, if I'm not mistaken, then you'd at least arrive at ambiguous situations. e.g.:
23:12:21 <cm> Philippa: or I'll just take whatever you would like to accept :-)
23:12:30 <cm> s/take/feed
23:12:46 <KrispyKringle> if I type `if (condition) { expr}', you don't know if I've finished the statement, or if there's an `else' statement. 
23:12:46 <wli> KrispyKringle: Not strange
23:12:48 <wli> KrispyKringle: "strong"
23:12:53 <KrispyKringle> ah, whoops :P
23:12:54 <cm> dons: thanks for "make register" :-)
23:13:01 <KrispyKringle> yes. 
23:13:09 <KrispyKringle> sorry. like i said, it's late here ;)
23:13:11 <wli> it's not tough to work out
23:13:21 <cm> good night
23:13:22 <musasabi> I used only to have a function to parse the params.
23:13:30 <wli> I'm stumped! I don't understand how to work around this Eq constraint crud! Help!
23:13:34 <KrispyKringle> it's not tough to work our per se, but like I said, many grammars are inherently ambiguous at 0 lookahead. 
23:13:48 <wli> KrispyKringle: yes, those can't have those kinds of parsers written for them
23:13:55 <KrispyKringle> that was all i was commenting :P
23:14:24 <wli> KrispyKringle: it's one reason why there are synchronizing tokens for arithmetic expressions in zsh
23:14:36 <Philippa> wli: I'm not even sure how the hell it's being inferred in the first place
23:14:50 <wli> $ echo $(( 2.5 *
23:14:50 <wli> > 0.75**3
23:14:50 <wli> > )) 
23:14:50 <wli> 1.0546875
23:15:00 <wli> Philippa: nub and union
23:15:13 <wli> Philippa: and elem
23:15:29 <wli> KrispyKringle: the $(( ... )) makes it work for arithmetic
23:15:34 <Philippa> ah. Yeah, you're screwed then
23:15:42 <wli> Can't be done or something?
23:16:19 * Philippa thinks
23:16:20 <wli> this is fscked, if you can't constrain the monad types there are going to be more problems than this, and more realistic ones
23:16:25 <Philippa> OK, it can be done
23:16:26 <wli> do arrows solve this?
23:16:34 <Philippa> but you need a way to say "if there's an eq, nub, if not id"
23:16:40 <musasabi> wli: no.
23:16:53 <Philippa> if there's no equality, you don't need to worry about equal elements :-)
23:17:40 <wli> maybe
23:17:58 <Philippa> so rig up a typeclass with an instance on any type and an instance on any type in Eq
23:18:11 <wagle> Set [1, 1] == Set [1]
23:18:11 <wagle> ?
23:19:00 <wagle> yes
23:19:04 <wagle> hmm
23:19:06 <wli> wagle: True
23:19:15 <KrispyKringle> wli: i gotcha. 
23:19:30 <jdrake> What would be an appropriate name (in haskell) for a function that converts polar coordinates to a Cartesian vertex
23:19:40 <wagle> i'm wondering if the nub optimization is "wrong" somehow
23:19:56 <wli> wagle: optimization?
23:20:11 <wagle> sure
23:20:29 <monochrom> if you don't nub, you may as well go back to lists.
23:20:30 <wagle> Set [1, 1] does == Set [1]
23:20:36 <wli> walge: yes
23:21:04 <wagle> nono, i'm not saying get rid of nub..  i'm just trying to rethink it
23:21:19 <Philippa> you can probably find a reasonable way to rewrite without the monad in this case
23:21:24 <musasabi> jdrake: polarToCartesian ?
23:21:36 <wli> yeah, it just doesn't lend well to my monadic interpreter angle
23:21:43 <wli> it's obviously going to be mostly useless for this trivial case
23:21:57 <Philippa> yeah, you ran up against an icky type system limitation because you're doing something specific enough a monad can't do the fun bits for you
23:21:59 <jdrake> Just wondering, not sure if blahToBleh would have been appropriate style
23:22:27 <monochrom> certainly beats ps2pdf
23:22:40 <musasabi> yes that is quite evil...
23:22:51 <musasabi> Supporting subkinds would be very cool.
23:23:12 <wli> musasabi: subkinds are what this needs?
23:23:38 <wagle> mu
23:24:13 * Philippa heads bedwards
23:24:19 <musasabi> wli: yes. (but note that that is just a word I use for naming subsets of objects satisfying a typelevel predicate)
23:24:48 <jdrake> Philippa, weren't you in britain?
23:24:54 <Philippa> ah. Hence the confusion, because it's a type-level thing not a kind-level one
23:24:56 <Philippa> jdrake: yep
23:24:58 <jdrake> I thought it would be near time to get up there
23:25:07 <Philippa> I'm also a compsci student, and on top of that term ended a few days ago
23:25:16 <jdrake> 7:24 i believe
23:25:21 <Philippa> and it's winter, which never does my sleep patterns any good 'cos there's no sunlight to regulate them
23:25:22 <jdrake> or maybe 6
23:25:26 <Philippa> the former
23:25:39 <jdrake> damn EST/EDT thing
23:25:51 <musasabi> but a kind is just a set of types with a relation to other kinds, no?
23:26:10 <wagle> problem if to restrict f in fmap f
23:26:19 <Philippa> no, it also has to conform to the kinding system
23:26:39 <wagle> problem is to restrict f in fmap f
23:26:44 <Philippa> which amongst other things means it never describes a type
23:26:54 <Philippa> any more than a type describes a value
23:27:01 <wagle> f :: (Eq a, Eq b) => a -> b
23:27:03 <musasabi> Philippa: yes.
23:27:15 <Philippa> similarly, dependant kinds aside, it never /contains/ a type
23:27:44 <musasabi> but types "belong" to certain kinds
23:28:05 <Philippa> sure. But as we want type-level behaviour for this entity, we're not talking about a kind
23:28:06 <wli> It sounds plausible that you could qualify * in kinding
23:28:18 <wli> e.g. a kind like (Eq *) -> (Eq *)
23:28:19 <wagle> Functor has no such restriction, so haskell "correctly" prevents you from assuming otherwise
23:28:47 <Philippa> wli: sure. Unless you're doing dependant kinding you'd not be able to use a type-level entity in the qualifier though
23:29:02 <Philippa> what you actually need is a bound on the type variable in Set
23:29:09 <jdrake> oh this is stupid, -1 can't be safely used as a number in a parameter without brackets can it
23:29:15 <wli> But the bound doesn't work
23:29:25 <Philippa> Set Eq t => t
23:30:08 <wli> I can't quite translate that to Haskell syntax
23:30:11 <Philippa> wli: that's because you can't specify such a bound on a parametric type's variables in Haskell
23:30:23 <jdrake> there seems to be a problem... polarToVertex ((acos (-1.0)) / 2.0) 2         ->   (-8.742278e-8,2.0)   (where polarToVertex theta r = (r * cos theta, r * sin theta))
23:30:35 <wli> isn't there a forall construction for this?
23:30:38 <Philippa> anyway, 'moff for real
23:30:52 <Philippa> might be worth a shot, but I think you'd just get a polymorphic value instead
23:30:53 <wli> I suspect the "screwed" answer is probably the end of it.
23:31:17 <wagle> no..  sorry i'm just really slow
23:32:01 <musasabi> The start would be to be able to say. "data a = Foo a => a" which would work.
23:32:14 * musasabi notes his typos
23:32:20 <musasabi> data Bar a = Foo a => a
23:32:29 <musasabi> data Bar a = Foo a => Bar a
23:32:34 <wli> either that or I hack dependent kinds and/or subkinding into ghc
23:32:39 <musasabi> (too early in the morning)
23:32:40 <Philippa> er, you want the context on the LHS
23:32:43 <wli> musasabi: that's accepted but means something else
23:32:47 <Philippa> it's part of the type, not the constructors
23:32:55 <musasabi> wli: yes, we don't want to make it an existential.
23:33:18 <wli> musasabi: data Eq t => Set t = Set [t] deriving (Ord, Read, Show) makes no observable difference
23:33:38 <musasabi> what we want to say is "Bar takes any type as an argument iff the type satisfies some predicates".
23:33:48 <musasabi> wli: yes, that does not work in haskell.
23:34:01 <Philippa> musasabi: it's actually just plain ol' bounded quantification
23:34:04 <wli> okay, now what do I do?
23:34:27 <wagle> define setnub
23:34:32 <Philippa> generally studied in subtyping, though if you think a mo membership of a typeclass is just being a subtype of (Class a => a)
23:35:01 <Philippa> anyway. Bed. Really.
23:35:12 <wagle> Philippa: no!  wait!
23:35:17 <wli> wagle: setnub can't be defined without Eq t
23:35:22 <wagle> Philippa: nm
23:35:50 <wagle> Philippa: 8-D
23:35:52 <wli> Well, I think we're at a place where we can say this can't be done directly.
23:36:04 <wagle> do you need fmap?
23:36:10 <wli> So the question of "wtf do I do instead?" arises.
23:36:16 <wli> wagle: for monad, yes
23:36:28 <wagle> Monad need Functor?
23:36:34 <jdrake> if 'cos PI/2' produces a value that is close to zero but off down to about 17 decimal places, but I desire it to return the correct answer of zero - what would be the options for doing so
23:36:36 <wli> yes
23:36:52 <wli> instance Functor f => Monad f where { ... }
23:36:53 <wagle> i thought that too, but didnt see it 
23:37:38 <wagle> hmm..  hugs doesnt have that, i think
23:38:51 <wli> hmm, ghc doesn't either
23:39:17 <wagle> maybe this is why they got rid of that..
23:39:28 <wli> probably not
23:39:47 <wli> that's a constraint on the monad constructor variable, which is visible in the class
23:39:54 <wagle> i think i've seen this problem before..  could well be (one of) the reason (s)
23:40:13 <wagle> hmm.. nm
23:40:56 <wli> well
23:41:12 <wli> something "out of the box" may need to happen
23:41:16 <wli> like a constructor class or something
23:41:17 <wagle> problem is that the Eq instance for Set doesn't restrict Set..  it just provides Eq on Sets when the elements are Eq
23:41:49 <wli> data Eq t => Set t = Set [t] deriving (Ord, Read, Show) doesn't cut it either
23:42:06 <wagle> yeah..  thats my current puzzle
23:42:14 <wagle> its just ignores that
23:42:43 <wagle> but thats the source of the trouble
23:43:25 <wli> well, there's some way to hack around this
23:43:30 <wli> because people actually get something done
23:43:32 <wli> so what do they do?
23:45:41 <wagle> i saw "set monad" and "bag monad" hits on google
23:45:51 <wli> yeah, they were useless
23:45:57 <wagle> oh well
23:46:05 <wli> I saw a set monad from wadler identical to the usual list monad
23:46:20 <wli> another one referred to a set monad but made no reference to its implementation
23:47:19 <desrt> uhm...
23:47:49 <desrt> sets require that their elements are Ord
23:47:59 <desrt> since it stores the elements in a binary tree
23:48:06 <desrt> this gives you Eq.
23:48:10 <wli> huh? where are you getting this from?
23:48:16 <desrt> mkSet :: forall a. (Ord a) => [a] -> Set a
23:48:17 <wagle> at this point, it's take me a while..  i gotta eat and sleep now..  will let you know if i think of anything
23:48:23 <wli> some specific implementation of Set?
23:48:34 <desrt> the Data.Set implementation
23:49:13 <desrt> in order to put something in a set you require Ord on that something.  this implies that you have Eq as well.  problem solved.
23:49:34 <monochrom> hahahahaha
23:49:53 <wli> desrt: sounds good, could you show me the Monad instance you wrote for it?
23:50:09 <desrt> wli; hm?
23:50:23 <wli> desrt: the discussion centers around defining a monad instance for Set
23:50:33 <wli> desrt: please show me your monad instance
23:50:39 <desrt> i thought you were asking how set is able to define Eq on itself
23:50:57 <wli> no, that's well-trodden territory for me
23:51:01 <desrt> 02:40 <wagle> problem is that the Eq instance for Set doesn't restrict Set..
23:51:01 <desrt>               it just provides Eq on Sets when the elements are Eq
23:51:03 <desrt> ah.
23:51:04 <wagle> problem is defining fmap
23:51:12 <wagle> (Functor Set)
23:51:33 <desrt> i wasn't tackling your problem, then, wli, but wagle's :)
23:52:00 <wagle> desrt's notion is of the form i was looking for though
23:52:40 <wagle> instead of Set (nub _), use mkset _
23:53:01 <wagle> but that still might not get there
23:54:42 <wagle> define a nub or mkset  instance for each type you use
23:56:14 <wli> I think I have a better idea.
23:56:24 <wagle> ok
23:58:50 <wagle> you cant put the nub in the Functor Set instance, but you can put it in wrappers
23:59:14 <musasabi> btw anyone understanding the OOHaskell slides?
23:59:34 <wagle> OHaskell, or OOHaskell?
23:59:54 <musasabi> particularly, why is the mutableX made a member of the record in the first point example.
