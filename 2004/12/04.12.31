00:28:24 <desrt> does injection imply total?
00:28:51 <desrt> mathworld nor wikipedia are particularly precise about stating it but they later make statements that make it seem like it must be true
00:30:53 <musasabi> injection means f(x) = f(y) => x = y
00:30:58 <desrt> right
00:31:09 <desrt> but must f(x) be defined for all x?
00:31:50 <musasabi> depends on x ;)
00:32:31 <desrt> take for example y = 1/x
00:32:46 <desrt> you have f(x) = f(y) -> x=y
00:32:48 <musasabi> If you say: f is a function from X to Y. Then that implies that for each x in X there is f(x).
00:33:03 <desrt> only if it's a total function
00:33:05 <desrt> it might be partial
00:34:15 <musasabi> g(x) = 1/x is a function from R\{0} -> R (we could as well claim a function from R\{0}->R\{0}.
00:34:41 <desrt> or we could claim it to be a function from R\{0} -> complex
00:34:51 <musasabi> yes.
00:34:54 <desrt> -or-
00:35:02 <desrt> we could claim it to be a partial function from R->R
00:36:17 <musasabi> yes.
00:36:31 <desrt> ok
00:36:34 <desrt> i guess what i should ask then
00:36:44 <desrt> does injection imply total?
00:36:56 <desrt> (taken in context of binary relations, not functions)
00:37:09 <musasabi> no.
00:37:15 <desrt> cool.
00:37:50 <desrt> so then
00:38:03 <musasabi> e.g. the mapping h: {0,1,2} -> {0,1,2}, h(0) = 0, h(1) = 1. Is clearly an injection, yet it is only a partial function.
00:38:10 <desrt> xRa && xRb -> a == b
00:38:22 <desrt> and if not xRa or not xRb then who cares
00:38:56 <desrt> ya.  that's what i was getting at.  wikipedia is confusing here
00:39:28 <desrt> "In mathematics, the term injection refers to an injective function."
00:39:32 <musasabi> well normally when speaking about injections it is assumed that the things are functions.
00:39:48 <desrt> and the way they desribe it they make no bones about it being a total function
00:39:58 <desrt> hmm
00:40:05 <musasabi> well a partial function is not a function.
00:40:13 <musasabi> function == total function.
00:40:17 <desrt> nod
00:40:47 <desrt> or more to the point, funtion == total deterministic relation
00:41:59 * desrt opens up dia and constructs a lattice
00:47:34 <desrt> arf.  it's non-planar.  evil.
01:25:35 * Lemmih wonders what the difference between OverlappingInstances and AllowOverlappingInstances is.
01:26:51 <Lemmih> Hmm. With GHC, both are the same but Hugs only accepts OverlappingInstances. (-:
02:00:20 <Lemmih> shapr: I've cabalized Hemplate (and its dependencies: HSQL, HaskellDB and HaXml).
03:48:18 <shapr> Lemmih: cool!
05:21:42 * shapr cackles evilly
05:21:48 <shapr> It's almost 2005!
05:23:00 * boegel wishes a happy new year to #haskell
05:30:55 * Darius will probably go to sleep and get up before it's 2005 here.
05:52:36 <bourbaki> moin
05:57:18 <vincenz> shapr: I'm off... happy new year!
05:58:44 <bourbaki> who is gonna be here on new yaer :)?
05:59:44 <musasabi> well I am on irc occasionally but we do have a party here...
06:01:31 <bourbaki> well i have been on irc on new year alot :) since im not a party animal and have a lot of work :)
06:01:50 <tuomov> so far it seems I'll be on irc..
06:09:20 <aj> so hey, can you do lazy parsing with parsec? by which i mean start acting on a file when it's only partially parsed, even though there might be errors later?
06:12:33 <dblhelix> aj : yes, you can
06:13:59 <aj> dblhelix: how?
06:15:39 <dblhelix> aj: i'm not as fluently with parsec as I used to be, but, in general, you can consume parts of the ast while other parts aren't evaluated yet, can't you?
06:17:09 <musasabi> and you can just skip over errors...
06:17:15 <musasabi> iirc
06:17:39 <aj> i do want to stop parsing as soon as i hit an error
06:18:01 <aj> but i can't see how i can pass in anything but a list of tokens like "[Char]" ?
06:31:46 <aj> sorry, i'm being confused; i want to interleve the reading IO, the parsing, and the acting IO
06:33:19 <aj> so if i've got "if true; then echo hello world; fi; ..." i want to "echo hello world" before i've even read the "..." part, if you see what i mean
07:01:23 <shapr> aj: should work
07:04:00 <aj> shapr: how?? :)
07:04:26 <aj> shapr: i can't see how i can start parsing before i've read everything
07:05:15 <shapr> in short, the monad laws allow you to do it.
07:06:31 <shapr> to be honest, lazily reading a file requires unsafePerformIO, but once you're over that moral quandary, you can just consume as much of the file as you need to parse the next bit.
07:07:16 <Igloo> parsec never returns anything lazily does it?
07:07:28 * shapr hadn't thought of that
07:07:31 <shapr> I don't know
07:07:38 <shapr> @index anyChar
07:07:39 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
07:07:53 <shapr> @type Text.ParserCombinators.Parsec.anyChar
07:07:55 <lambdabot> Text.ParserCombinators.Parsec.anyChar :: forall st.
07:07:55 <lambdabot> 					 Text.ParserCombinators.Parsec.Char.CharParser st Char
07:07:56 <Igloo> Oh, it's also used as a lexer IIRC, so maybe it can
07:08:12 * Igloo isn't familiar with enough with it to know, and is about to disappear
07:08:19 <shapr> I'm about to disappear too.
07:08:35 <shapr> New Year's dinner with wine and good french food.
07:08:41 <shapr> Too bad I don't like wine.
07:09:10 <aj> wouldn't be french food without wine!
07:09:16 <shapr> true enough
07:10:38 <shapr> oh wait
07:10:43 <shapr> I've done lazy parsing myself.
07:11:03 <shapr> hm, well... sort of
07:11:58 <shapr> aj: http://www.scannedinavian.org/~shae/MboxToDB.hs
07:12:33 <shapr> conts <- readFile (sysargs !! 0) ; let result = filter hasMsgid $ noMimes $ msgList $ mboxSplit conts
07:15:06 <shapr> conts ends up being the contents of really big mailman archives in mbox format. The haskell list archive is 33MB. With that lazy pipeline I just pasted my max memory usage is the RTS + the message datatype size for the largest message in the list. That's because only one message is in memory at any time.
07:15:14 <shapr> aj: is that the sort of thing you're asking about?
07:15:41 <aj> yeah, i don't see how that works though
07:16:12 <aj> i thought that you were in a monad would mean that all the reading (c <- readFile) would happen before the next bit...
07:16:35 <shapr> except that associativity lets you reorder computations.
07:17:34 <shapr> In essence, you get to interleave the operations like a zipper.
07:17:51 <aj> so does that just happen automatically?
07:17:52 <shapr> read a chunk of the file, parse it, stick it into a database, repeat
07:17:56 <shapr> sort of
07:18:08 <aj> hrm
07:18:15 <shapr> It's one way to exploit the non-strict nature of Haskell.
07:18:20 <aj> which is the "stick it in the database" bit?
07:18:49 <shapr> But you have to be careful to preserve the property that your functions can work on infinite list if you want to keep the advantages of a lazy pipeline.
07:18:54 <shapr> And some algorithms can't work that way.
07:19:13 <shapr> that code puts the mbox archives into a postgresql database
07:19:29 <shapr> here's the client side of that code - http://thunderbird.scannedinavian.com/cgi-bin/SearchML
07:19:44 <shapr> though I don't think I have the libraries list loaded in at the moment
07:19:48 <aj> hrm
07:19:50 <shapr> nor do I have the darcs lists yet :-)
07:19:54 <shapr> though I could easily do it.
07:20:51 <aj> so if i have {c <- readFile("/dev/zero"); doSomethingWith c}  doSomethingWith will actually do something, even though readFile("/dev/zero") will never terminate?
07:21:14 <shapr> If doSomethingWith can deal with infinite lists, then yes.
07:21:43 <shapr> for example, any algorithm that needs to see the end of a list won't work there... like "length"
07:21:52 <shapr> but something like "take" will work just fine.
07:21:57 <shapr> take 5 [1..]
07:22:06 <shapr> but length [1..] doesn't work so well.
07:23:46 <aj> Prelude IO> do { x <- hGetContents stdin; print $ take 5 x }
07:23:53 <aj> holy crap, that's awesome
07:24:47 <aj> okay, that makes life easy, i guess
07:25:51 <ibid> no, actually, it's not a monad effect really
07:26:36 <ibid> readFile and getContents are generally just gross kluges packaged up nicely
07:26:53 <aj> so how do you return lazily from a monad? if i just want "x" from  do { x <- foo; y <- bar; z <- blah; return MyType x y z } do i have to do anything special?
07:27:01 <aj> they are?
07:27:21 <ibid> yes
07:27:41 <ibid> to write an equivalent function yourself you need unsafeInterleaveIO
07:27:53 <ibid> which is Not Nice
07:28:00 <ibid> but it is convenient to be sure :)
07:29:10 <aj> @type unsafeInterleaveIO
07:29:11 <lambdabot> bzzt
07:29:19 <ibid> it's not a standard function
07:29:23 <aj> @index unsafeInterleaveIO
07:29:23 <lambdabot> GHC.IOBase,System.IO.Unsafe
07:33:53 <aj> so "unsafe" just means "if you modify the file before accessing the value you just read, you might get the modified value" ?
07:35:05 <ibid> unsafe means "you *really* need to know what you are doing"
07:36:12 <ibid> uIIO breaks the sequencing of IO actions that the IO monad enforces. you need to make sure that what you do will not do any funny things, and that's really nontrivial
07:36:26 <aj> hrm
07:36:34 <ibid> i suppose to be really sure about it you'd have to know how the compiler compiles the code
07:36:57 <aj> come on, i'm a c programmer, i can deal with undefined behaviour :)
07:36:59 <ibid> though uIIO isn't as bad as uPIO
07:37:05 <ibid> aj: :)
07:37:37 <ibid> aj: seen nasal demons lately? :)
07:37:48 <aj> deal with = avoid :)
07:37:50 <Darius> Haskell kicking butt at generics, http://www.osl.iu.edu/publications/pubs/2003/comparing_generic_programming03.pdf
07:40:06 <aj> yeah, haskell's sweet. if it didn't have a zombie-like addiction to EATING PEOPLE'S BRAINS it'd have taken over the world already
07:40:36 <Darius> Well according to that paper, Haskell is "widely used"
07:40:40 <ibid> aj: oh, btw, what i wrote above is specific to the IO monad. other monads may or may not provide more natural support for laziness
07:41:00 <ibid> aj: you've surely read the haskell retrospecive by spj? :) "avoiding success at all costs"?
07:41:31 <Darius> aj: If you haven't do so.  It's quite entertaining (assuming your brain has already been eatten by Haskell)
07:42:02 <shapr> aj: Haskell eats brains?
07:44:45 <aj> oh, does the C <-> Haskell interface suck or rock?
07:45:06 <ibid> it feels quite comfortable
07:45:24 <ibid> (given the vast difference between the two worlds)
07:45:34 <Darius> aj: To the extent that I've used it, it's seems pretty nice.
07:45:48 <ibid> of course, i haven't done anything grand with it
07:45:58 <Darius> aj: There is also a small army of tools to assist if the "raw" interface isn't nice enough for you.
07:46:10 <ibid> just interfacing one or two self-written c modules with haskell
07:46:40 <ibid> a squad? a platoon? a company? :)
07:46:58 <Darius> aj: From the way people talk here about FFIs in other languages, my impression is that Haskell has one of the nicests ones period.
07:47:22 <ibid> at least compared to JNI it's nice
07:48:11 <Darius> ibid: I hear compared to OCaml's it's quite nice as well, if anyone here wants to confirm or deny go ahead.
07:48:16 <ibid> i ga
07:48:24 <ibid> i haven't done any ocaml, i'm afraid
07:52:11 <Darius> Wow, you know you're a math geek if you ever play a game where "Player A begins by choosing a construction of the Complex numbers"
07:53:08 <aj> "Whenever we don't understand something, we toss it in the IO monad."
07:53:09 <aj> heh
07:54:03 <aj> hrm, i can't remember JNI, but i remember it being pretty mediocre, i might be wrong. python's is nice. perl's puts the devil to shame
07:54:18 <ibid> Darius: i choose cartesian pairs, with reals constructed using dedekind's cuts
07:56:25 <tintin> what makes Ocaml so fast ?
07:57:13 <tintin> or to put it better what makes it faster than Haskell
07:57:21 <Darius> ibid: You have to be a bit more specific, what's your (set-theoretic) definition of pairs and do the Dedekind cuts contain the real (if so, higher or lower set?)
07:57:33 <tintin> ?
07:58:35 <ibid> Darius: the standard ZFC pair, dedekind cuts contain only rationals, take the pair of higher and lower set :)
07:59:10 <ibid> do you want me to sketch a construction of the rationals and integers, too? :)
07:59:30 <Darius> Yes.
07:59:52 <ibid> hmm, my memory is getting rusty there, those aren't as interesting
08:00:03 <ibid> i suppose since is specified ZFC, i need to construct naturals too
08:01:48 <Darius> tintin: Nothing.
08:02:27 <ibid> well, rationals are pairs composed of an integer and a non-zero natural, the absolute values being relatively prime (if the integer is zero, then the natural is one)
08:03:24 <ibid> brute force: integers are pairs, the left element is 1 or 0 and the right element is a natural (if the natural is zero, then the left element is 0)
08:03:37 <ibid> zero is the empty set
08:03:45 <aj> "By the wellfoundedness axiom, this is a finite game."
08:03:48 <aj> omg, that's awesome
08:04:29 <ibid> iirc, successor of n is { n, { n } }
08:04:32 <ibid> happy? :)
08:04:40 <Darius> ibid: Well, to sketch the "game", it works as follows: Player B picks an element x0 \in C, A picks an element x1 \in x0, and so forth.  Apparently, aj has found the reference, or is a major math geek.
08:04:57 <ibid> heh
08:05:08 <ibid> can get really nasty with any construction :)
08:05:09 <aj> i dropped your quote into google :)
08:05:18 <Darius> aj: I imagine.
08:05:21 <ibid> is pen & paper allowed?
08:05:28 <ibid> or chalk and blackboard?
08:05:56 <Darius> ibid: Why not?
08:06:04 <ibid> Darius: it'd be nastier if not
08:07:06 <ibid> i suppose my construction would be nasty even for my first "real" turn :)
08:08:37 <ibid> Darius: is it required that a player be able to write a ZFC term denoting his set?
08:08:52 <ibid> if so, you need to specify the logic too
08:09:07 <aj> ibid: nah, that'd let the next player chear
08:09:32 <aj> ibid: but the next player has to be able to prove their term is a member/subset of the other
08:09:46 <Darius> ibid: You'd have to represent it some way, but you should be able to use the highest level of "abstraction" that you can, i.e. start with say, pi + 3i.
08:09:50 <ibid> and also that it is uniquely defined?
08:09:59 <aj> oh, hrm, definitely member, otherwise you could just say "0" and win
08:10:01 <aj> god, that's evil
08:11:07 <ibid> anybody played this game for real?
08:11:12 * Darius wonders about representing them as programs that produce them when run on accelerated Turing machine
08:11:21 <Darius> ibid: I'm sure, but not me.
08:11:50 <aj> ibid: playing it for real means the first player can force the second player to give up or prove the well founded axiom, no?
08:11:55 <Darius> Of course, I don't have a very high opinion of set theory.
08:12:11 <ibid> Darius: what's your thing then?
08:12:18 <ibid> in the sense of fom, that is?
08:14:03 <Darius> For foundations, I'd still lean towards set theory as I have yet to look deeply in how category theory provides it, but category theory does often avoid arbitrary constructions like these (which directly or indirectly is the reason the paper brought up the game).
08:14:59 <Darius> Also, the axiom of well-foundedness seems mildly irksome
08:15:22 <tintin> Darius: similar exceutables in Ocaml are reportedly faster than ones programmed in Haskell ... 
08:15:36 <tintin> so i was wondering where the difference lies ...
08:15:47 <Darius> tintin: In most cases, probably the programmer.
08:16:03 <Darius> tintin: Haskell is "trickier" to optimize than most languages.
08:19:34 <Darius> tintin: Certainly a naive translation of Haskell code from/to most other languages almost certainly produces less than optimal results.
08:21:57 <tintin> i remember a remark in YAKT which went something like if you want a faster executable and almost all the features of Haskell consider Ocaml ... 
08:22:36 <tintin> anyways i have no first hand knowledge so i think i will take your explanation for it until i can verify things myself 
08:25:52 <Darius> In a thoroughly out of date benchmark, http://www.ecs.soton.ac.uk/publications/rj/1995-1996/decsys/phh/hartel2.htm, GHC does extremely well, but only after being "heavily optimized" by people who know what they are doing.
08:26:45 <Darius> Luckily, I believe it was remarked that many of the optimizations were done by hand because they weren't yet added to the compiler.
08:29:12 <tintin> thats really interesting 
08:29:16 <tintin> tnx for all the information Darius 
08:33:23 <Darius> Has anyone ever done, f `map` xs?
08:35:19 <esap> One problem with optimizing Haskell code is that space usage is pretty hard to understand and control.
08:35:50 <jadrian> yeap
08:36:06 <TheHunter> Darius, all the time
08:36:24 <TheHunter> and it pisses me off that `fmap` doesn't have the same fixity as =<<.
08:36:57 <jadrian> I also feel kind of lost sometimes because have no idea wether some optimizations are worth doing or not
08:37:08 * esap sometimes uses `pam` (= flip fmap) in infix notation.
08:37:20 <jadrian> for instance fusion laws of maps and folds...
08:38:25 <jadrian> eg stuff like  map f . map g -> map (f .g )
08:38:36 <jadrian> or deforestation  of functions like
08:38:59 <TheHunter> can't you specify much of this stuff using rewrite rules (not that i ever tried)?
08:39:02 <jadrian>  last . take 10 . iterate f 
08:39:29 <jadrian> TheHunter: well this are very simple cases, just to illustrate what I'm talking about
08:39:40 <Darius> jadrian: If you are using GHC and standard functions (or syntax) GHC should deforest.  You could check it by checking the core but that's rather... verbose.
08:39:54 <jadrian> TheHunter: I'm talking about the generic case with more complicated structures
08:40:54 <tintin> is there a mode similar to pcl-cvs for gnu arch ?
08:40:56 <jadrian> Darius: yeap I've been trying to avoid looking at ghc source except for some simple stuff... most of the time I just assume it does 
08:40:57 <tintin> ,arch
08:41:02 <esap> Also, for some constructs, you can't really choose between using space or using time. The other alternative is just not available.
08:41:10 <tintin> woops wrong channel sorry about that 
08:41:11 <jadrian> Darius: or if it's a critical function I assume it doesn't :)
08:50:23 <samc_> TheHunter, why do you prefer =<<?
08:50:59 <TheHunter> samc_, because it behaves like function application.
08:51:17 <TheHunter> the monadic function being on the left and the monadic value on the right.
08:52:09 <samc_> ah yes, I see
08:52:38 <TheHunter> also, monadic function composition becomes easier: (=<<) f . g === \x -> do y <- g x; f y
08:52:41 <Darius> Hmm, the "Modules" slide of the Haskell retrospective looks to be a bit out of date...
08:53:27 <TheHunter> ok, i have a maximally stupid question: What does default (apperently a reserved word) mean?
08:53:57 <Darius> It's used for the hacky defaulting mechanism for numbers.
08:54:23 <TheHunter> is it in the report? or a ghc thingy?
08:55:34 <TheHunter> ok, it's in the report. Thanks Darius.
09:01:24 <TheHunter> hmm, doesn't seem very useful.
09:02:54 <Darius> You can add 'default ()' to the top of your modules and recompile and see how much it is or isn't helping, but it is clearly a hack.
09:03:25 <TheHunter> otoh, you get that info already with -Wall.
09:21:11 <lyceen> hello
09:21:59 <lyceen> can I port a php-application to a haskell-application?
09:23:33 <Darius> lyceen: Why wouldn't you?
09:23:52 <jesse_> its entirely possible... but it might not be the most straight forward thing
09:24:26 <lyceen> well yeah, how can i let it run on a webserver?
09:25:22 <jesse_> cgi
09:25:55 <Igloo> You might be interested in WASH, although it has some severe disadvantages in my book
09:26:04 <Heffalump> is there a standard cause for:
09:26:06 <Heffalump> /usr/lib/ghc-6.2.2/libHSrts.a(Main.o)(.text+0x10): In function `main':
09:26:06 <Heffalump> : undefined reference to `__stginit_ZCMain'
09:26:06 <Heffalump> /usr/lib/ghc-6.2.2/libHSrts.a(Main.o)(.text+0x36): In function `main':
09:26:06 <Heffalump> : undefined reference to `ZCMain_main_closure'
09:26:09 <Heffalump> ?
09:26:17 <Heffalump> (main does have type IO (), doesn't it?)
09:26:22 <Igloo> Yes
09:26:28 <lyceen> it has the type IO
09:26:34 <Igloo> Try removing .hi+.o and recompiling
09:26:35 <lyceen> lol ;)
09:26:47 <Heffalump> oh, yes, that's the standard cause
09:26:52 <Heffalump> I built the module without -main-is before
09:26:53 <Heffalump> ta
09:26:55 <lyceen> is there someone who has experience with cgi or wash?
09:27:51 <Darius> lyceen: There is also a mod_haskell, unfortunately it doesn't appear to be maintained but I think some people were talking about another version or resurrecting that version.
09:28:50 <lyceen> oh ok thanks
09:29:14 <lyceen> i was busy with a web-based strategy game in php, but now I want to do it in haskell
09:34:18 <lyceen> isn't there anybody interested in programming it?
09:34:43 <Igloo> I think most people here have their own projects to work on  :-)
09:35:11 * Igloo isn't really interested in web stuff with Haskell until there's a better implementation to work on anyway, I don't think
09:35:25 <lyceen> damn :)
09:35:40 <lyceen> www.momd.tk thats the early version of it
09:35:53 <Heffalump> implementation of what? HTML, HTTP, CGI?
09:36:09 <Heffalump> (by CGI I also mean mod_haskell type stuff)
09:36:30 <Igloo> CGI
09:36:36 <lyceen> or wash
09:36:38 <Darius> lyceen: http://www.haskell.org/libraries/ (has some links you may want to look at among other things, though there are other things floating around in various states of maintainedness, e.g. Haskell Server Pages).
09:36:43 <Heffalump> what's wrong with the CGI interface itself?
09:37:13 <Igloo> If WASH didn't use JS and you could tell it to jump to this state, rather than having to recompute, then I think I would be happy
09:37:28 <Igloo> I'm not sure what you mean?
09:37:43 <Heffalump> you can just make binaries that do CGI
09:37:52 <Heffalump> it's not a complicated interface and I think there's a library to do it
09:38:16 <Heffalump> or maybe use hws-wp and proxy
09:39:15 <Igloo> I'd prefer something higher level, but perhaps I'll look at that when I next want to do something
09:40:01 <lyceen> ok
09:43:13 <Heffalump> you want something that does state and session tracking for you?
09:43:45 * Heffalump thinks hws-wp and a continuation monad is called for, then.
09:43:45 <lyceen> yup
09:43:51 <lyceen> and database handling
09:44:08 <Igloo> Is hws-wp the Haskell server?
09:44:19 <Heffalump> yes
09:44:21 <Igloo> Hmm, I guess apache could proxy it
09:44:31 <Heffalump> Simon Marlow's server with Marvin's plugin addition
09:44:36 <Heffalump> yes, that's what I meant above.
09:44:39 <Igloo> And that can be done with .htaccess only, right?
09:45:03 <Heffalump> errm, not sure
09:45:09 <lyceen> can you use .htaccess for haskell?
09:45:15 <Heffalump> where'd you want to do it?
09:45:24 <Igloo> And a cronjob to autostart it when it breaks/on reboot. It'd work, but it's not entirely pleasant
09:45:36 <Heffalump> or are you just thinking generally about how an application would work?
09:45:46 <Igloo> Dunno. urchin/the probably. (I don't actually have a need ATM)
09:46:13 <Heffalump> well, on urchin you could definitely persuade the admins to add config if needed :-)
09:46:16 <Igloo> Also have the issue someone else can steal the port you choose
09:46:26 <Heffalump> hmm, true
09:46:27 <Igloo> Yeah, but I'd hate having to do that
09:46:42 <Heffalump> well, I'm assuming it'd be a once-only thing
09:46:53 <Heffalump> "delegate this entire URL space to this port, now forget about it"
09:47:10 <Heffalump> the port stealing issue can be handled by iptables, I think.
09:47:17 <Igloo> It can?
09:47:41 <Heffalump> can it detect the user the traffic is going _to_?
09:47:48 <Igloo> It would be irritating knowing I'd have to ask the admins if I wanted to change the path or anything, even if it never happened
09:47:50 <Heffalump> (if not then I'm wrong)
09:47:55 <Heffalump> true
09:48:15 <Heffalump> well, RewriteRules can be done in .htaccess, and that's all you need for a proxy
09:48:15 <Igloo> How would it help if it could?
09:48:35 <Heffalump> you'd need admin help again, but they could give you that port with some firewalling
09:48:44 <Igloo> I think the best answer you'd get would be httpd, anyway
09:48:55 <Heffalump> I guess accidental thiefs would get really confused then, though.
09:49:02 <Heffalump> httpd?
09:49:07 <Igloo> As the user
09:49:11 <Heffalump> ah
09:49:25 <Igloo> But the problem is that if someone binds to 0.0.0.0:myport then I can't also do so
09:49:34 <Igloo> Even if they don't get the traffic either it's no help
09:49:35 <Heffalump> ah, right, yeah
09:49:55 <Igloo> ACLs might be able to do it, although I suspect they're all-or-nothing
10:30:33 <samc_> whats a 'uniaue supply' monad?
10:30:39 <samc_> a=q
10:33:19 <Lemmih> A monad that helps you generate unique variables.
10:33:21 <Darius> samc_: Like Lisps' gensym
10:34:15 <samc_> unfamiliar
10:36:49 <Lemmih> Hey SyntaxNinja 
10:36:56 <Lemmih> SyntaxNinja: I have some questions about Cabal.
10:37:23 <SyntaxNinja> Lemmih: shoot
10:37:25 <Lemmih> And happy new year!
10:37:40 <Riastradh> Bah, you silly European!
10:37:54 <SyntaxNinja> Lemmih: you too!
10:38:01 <samc_> ok I get it now, thanks Lemmih, Darius
10:38:08 <Lemmih> Are the executables supposed to be built?
10:38:43 <SyntaxNinja> Lemmih: is that my cabal question? of course!
10:39:11 <Lemmih> Then I guess I must have missed something...
10:39:54 <Lemmih> I get "**Exception: Maybe.fromJust: Nothing." when I include information about executables.
10:40:55 <SyntaxNinja> any idea where? is this the 0.2 release, or the darcs repo?
10:41:07 <SyntaxNinja> you should never get that exception
10:41:51 <Lemmih> SyntaxNinja: I just build GHC from CVS some days ago.
10:43:06 <MegaMonad> G'day saz, what's going on?
10:43:17 <SyntaxNinja> MegaMonad: hi
10:43:17 <MegaMonad> SyntaxNinja: So the systems has an interesting link : http://news.bbc.co.uk/1/hi/world/europe/1566715.stm.
10:43:41 <samc_> MegaMonad: Happy New Year!
10:43:41 <MegaMonad> samc_: Yohanm: what you wrote last year as a strategy for combining components, it seems to be exchanged between programs, so it is imho the http library you can create a completely new haskell.org is down as more people on this new paper, i got distracted and never investigated fran in depth.
10:43:54 <SyntaxNinja> Lemmih: can I get a copy of your source tarball?
10:43:57 <Lemmih> Are there some binfo fields which are required? I'm only setting 'executable', 'executable-modules', 'main-is' and 'hs-source-dir'.
10:45:15 <Lemmih> SyntaxNinja: shapr is hosting a darcs repo of my code.
10:45:50 <Lemmih> http://www.ScannedInAvian.org/repos/hacanon
10:46:00 <SyntaxNinja> that should be fine, no other fields are required
10:48:26 <SyntaxNinja> bbiab'
11:10:10 <SyntaxNinja> Lemmih: I'm having trouble building this because of the dependeencies :(
11:10:20 <SyntaxNinja> I guess I'm being lazy...
11:10:50 <Lemmih> Oh that's right. I had to cabalize HaXml
11:11:31 <SyntaxNinja> Lemmih: I don't suppose you can construct a simple example that fails?
11:11:47 <Lemmih> I can try.
11:15:33 <Lemmih> I think 'main-is' is ignored.
11:15:49 <SyntaxNinja> I should destroy all "fromJust" uses
11:16:35 <Heffalump> oh
11:16:40 <Heffalump> I've cabalized HaXml too.
11:16:47 <Heffalump> I just have't done much with it cos of the problems I had.
11:16:49 <SyntaxNinja> Lemmih: is there a "Simple.h" in your Examples directory?  mind moving it and seeing what happens?
11:20:09 <Lemmih> Same problem after I renamed it to OldSimple.h
11:20:56 <SyntaxNinja> this happens during build?
11:21:17 <Lemmih> Yes.
11:22:39 <Lemmih> Using runghc gave a lot more information.
11:23:05 <Lemmih> /usr/bin/ghc -odir dist/build/Examples -hidir dist/build/Examples -o dist/build/Examples/Simple --make -iExamples*** Exception: Maybe.fromJust: Nothing
11:24:05 <SyntaxNinja> what happens if you run that line by itself?
11:25:26 <Lemmih> It doesn't specify a Haskell source file, so nothing useful I guess.
11:26:08 <SyntaxNinja> oh, I see.
11:28:36 <SyntaxNinja> can you paste to me the contents of ".setup-config" in private message?
11:32:48 <SyntaxNinja> Lemmih: can you re-run configure?
11:33:54 <SyntaxNinja> Lemmih: your .setup-config was out of date from your Package.Description file... 
11:34:02 <SyntaxNinja> I'll have it output a better error message for that...
11:34:04 <Lemmih> D'oh.
11:36:26 <SyntaxNinja> die fromJust die!
11:36:46 <SyntaxNinja> why bother with types anyway?
11:39:58 <Heffalump> lemmih: did you manage to get cabal to build all the executables in HaXml?
11:40:01 <Lemmih> Now I got another problem. I'm using HaXml version 1.12 but ghc tries to load HaXml-1.0 with --make.
11:40:28 <SyntaxNinja> why does it do that?
11:41:01 <SyntaxNinja> AFAIK, ghc can't yet handle multiple versions of things installed
11:41:19 <Lemmih> I've only installed HaXml-1.12
11:42:09 <Lemmih> Heffalump: No. Didn't knew Cabal could do that until recently.
11:43:01 <SyntaxNinja> Lemmih: so what, ghc uses -package HaXmL-1.0 ?
11:43:43 <Lemmih> No -package's at all. Only --make
11:43:58 <SyntaxNinja> so where does it get that version of HaXmL?
11:46:05 * jadrian knows barely nothing about compilers... :-|
11:46:15 <jadrian> so here goeas a very naive question...
11:47:08 <jadrian> if I have pre-compiled modules (.o files) can I somehow still use them in the interpreter?
11:47:29 <Darius> Yes.
11:48:02 <jadrian> so I could use them in the interpreter and still benifit from compiler optimizations?
11:48:06 <Heffalump> the interpreter certainly uses them when the .hs is around too.
11:48:14 <Heffalump> I don't know what it does if only the .o is around.
11:48:15 <Darius> jadrian: Presumably
11:48:23 <SyntaxNinja> I think ross patterson also cabalized HaXmL
11:48:26 <Heffalump> but look at what ghci says about a module when it loads it
11:48:31 <Heffalump> SyntaxNinja: oh dear..
11:48:39 <Heffalump> well, I do also have a .deb of it.
11:48:51 <Heffalump> But I need to sort out those issues with the executables before I can do much else with it
11:49:35 <SyntaxNinja> ross's version doesn't list the executables
11:49:38 <SyntaxNinja> what issues?
11:49:38 <jadrian> I'm asking this because instead of making an interface to run my programs, sometimes using the interpreter directly would be handier
11:49:58 <jadrian> but I'd like to keep the same efficiency
11:50:08 <SyntaxNinja> Lemmih: haxml-1.0 is in the fptools source tree. that's probably what's wrong, though I don't know why exactly.
11:50:12 <jadrian> as if I compiled the whole thing
11:50:46 <jadrian> so if I could just compile the core it would be great
11:52:27 <Heffalump> SyntaxNinja: the ones I emailed you about - the second executable in the same directory trying to reuse Main.o from the first, with bad results
11:52:32 <Heffalump> s/ones/one/
11:53:00 <SyntaxNinja> hm. I forgot about that.
11:53:21 <Heffalump> I did email you back, didn't I? [should I in general email libraries@ about this kind of thing, btw?]
11:53:44 <SyntaxNinja> Heffalump: either one
11:53:49 <Heffalump> 'k
11:54:26 <SyntaxNinja> presumably both module names are Main?
11:54:46 <Heffalump> they might be changed to that with -main-is
11:55:05 * Heffalump goes to look
11:55:26 <Heffalump> no, they are Main in source
11:56:03 <SyntaxNinja> yeah
11:56:23 <SyntaxNinja> one way to workaround it might be to rename the modules, but I'm not even sure that'll work, since I don't think cabal uses the --main-is flag
11:56:31 <SyntaxNinja> I'll get on that ASAP.
11:56:41 <SyntaxNinja> I guess the solution is to build them in different directories or something.
11:56:52 <Heffalump> but the sources are in the same directory to begin with
11:57:13 <Lemmih> Shouldn't the executables be compiled with -i$(LIB_HS_SOURCE_DIR)?
12:00:25 <SyntaxNinja> Lemmih: I don't know what that would have to do with it?
12:00:46 <SyntaxNinja> the problem is that ghc --make cares a lot about the names of the modules, and very little about the names of the source files, so if it finds that Main.o exists, then it's going to try to us eit.
12:03:02 <jadrian> Heffalump: hmmm it doesn't load if the .hs is not present, but yes it does use the .o file if it is there :)
12:03:28 <Lemmih> Well I was talking about my own problems (-: My executables aren't in the same place as the lib sources.
12:04:03 <jadrian> I had no idea it would use the .o if present, I thought we had to somehow load the .o instead of the .hs
12:05:02 <Darius> jadrian: If you put the .o files on the commandline it may load even without the .hs files.
12:05:50 <jadrian> Darius: ghci Test.hs Aux.o 
12:06:01 <jadrian> Darius: Test imports Aux, doesn't seem to work
12:06:22 <SyntaxNinja> Lemmih: what's LIB_HS_SOURCE_DIR?
12:06:41 <SyntaxNinja> avoid naming things Aux, because on windows that's an evil special file name, if i remember
12:07:14 <jadrian> Darius: oopss forgot the output     "Can't find module `Aux'"
12:08:21 <Heffalump> SyntaxNinja: one obvious workaround would be to delete Main.{o,hi} before building an executable, but it's an awful hack
12:08:46 <SyntaxNinja> Heffalump: yeah... maybe using main-is will help somehow...
12:08:47 <jadrian> Darius: or did you mean something else by "put the .o files on the commandline"
12:08:49 <SyntaxNinja> I guess not...
12:09:02 <Lemmih> SyntaxNinja: hsSourceDir from the library BuildInfo.
12:09:30 <Heffalump> oh, yes
12:09:51 <Heffalump> changing the module name and using -main-is would definitely fix it, because you don't get Main.{hs,o} then
12:09:58 <Heffalump> s/hs/hi/
12:11:04 <SyntaxNinja> Heffalump: right; I was trying to think of a solution where you won't have to change the module names, since that'll probably break hugs and nhc
12:11:14 <Heffalump> ah, is -main-is not generally supported?
12:11:26 <Heffalump> that should be an approved addendum to the language spec :-)
12:11:27 <SyntaxNinja> no, and it's kinda broken in some ghc versions as well
12:11:33 <SyntaxNinja> Heffalump: agreed. 
12:11:39 <SyntaxNinja> it would make life easier :)
12:11:55 <SyntaxNinja> of course, the workaround that you can implement in a few minutes is to move those main files into different directories :)
12:12:08 <Heffalump> that's nasty from the point of view of tracking upstream sources
12:12:15 <Heffalump> (unless they are willing to do that too)
12:12:31 <SyntaxNinja> Lemmih: hmmmmm. yeah, it's a bit confusing when the executables depend on the package itself...
12:13:07 <jadrian> hmmm but this is kind of weird, so if I didn't want one of my haskell libs to be open source, and I'd just want to provide the .o files, then other programs could link to them, but we couldn't test these programs in theinterpreter? I must be missing something here...
12:13:11 <SyntaxNinja> Lemmih: so it can't find the executrable-modules?
12:13:53 <Heffalump> jadrian: I think if you make a .so and .a file from it, you'd be able to use it
12:13:57 <Heffalump> cos that's how packages work
12:14:15 <jadrian> Heffalump: cool, let me check it out
12:14:18 <SyntaxNinja> jadrian: you might mess around with "ghc-pkg --auto-ghci-libs"... you could probably roll a package which just uses the .o and .hi files and the user can install just the binaries
12:14:18 <Lemmih> SyntaxNinja: Oh yes it can but it can't find the library sources.
12:14:29 * Heffalump is guessing a bit about precisely how packages work
12:14:35 <Heffalump> and you'll need the .hi too
12:14:41 <SyntaxNinja> Heffalump: I think you're wrong, actually, but I'm not sure
12:14:45 <SyntaxNinja> I think ghci needs the .o files
12:14:51 <Heffalump> oh, yeah, maybe that.
12:15:03 <Heffalump> the point is that packages work without having source, so it must be possible
12:15:15 <SyntaxNinja> jadrian: you could play with cabal, build a binary from that, then ship the users the "build" directory with the setup file
12:15:26 <SyntaxNinja> and if you really like that, then I'll be sure to implement "bdist" soon.
12:15:40 <SyntaxNinja> jadrian: then thed end users will say "ghci -package YourBinaryOnlyPackage Foo.hs"
12:15:45 <Heffalump> is cabal ever going to integrate with haddock? i.e. have a ./setup doc command?
12:15:55 <SyntaxNinja> Heffalump: probably :)
12:16:17 <Heffalump> good good :-)
12:16:51 <jadrian> SyntaxNinja: right, I've heard about Cabal a lot lately, just thought it might be overkill, but I will look into it soon 
12:17:21 <Heffalump> it's not overkill, it's really easy to use
12:17:25 <Heffalump> for simple stuff, that is
12:17:40 <SyntaxNinja> jadrian: but the interface might change soon, so be careful :)
12:17:41 <jadrian> is it included in ghc?
12:17:51 <jadrian> ok :)
12:17:53 <SyntaxNinja> well, the interface _will_ change, but it might not affect you.
12:18:02 <SyntaxNinja> jadrian: it's in CVS, but not in any release
12:18:07 <jadrian> right
12:18:11 <SyntaxNinja> but you can get it from http://www.haskell.org/cabal
12:18:35 <SyntaxNinja> jadrian: the nice thing about it is you don't have to understand how the interpreter deals with .o files :)
12:18:42 <SyntaxNinja> which is some kind of magic that only ghc-pkg understands ;)
12:18:57 <Heffalump> so how would distributing the build/ directory help him?
12:20:15 <SyntaxNinja> Heffalump: along with the setup program, then can just "./setup install" and it'll set up the ghci package for him.
12:20:56 <Heffalump> ah, right
12:21:04 <Heffalump> but he could just distribute a ghc package, then
12:21:12 * SyntaxNinja wonders whether some day someone will try to do a "bdist" for hugs and get mad when the users end up with the source code
12:21:44 <jadrian> brb
12:22:15 <SyntaxNinja> Heffalump: but then he'd have to tell his users "copy the files to this location, then run ghc-pkg --auto-ghci-libs -i < package.conf" or something
12:22:19 <jadrian> back
12:22:33 <jadrian> hmm wait I got another question about it then
12:22:54 <SyntaxNinja> jadrian: in the future, if your absence will be less than 36 seconds, you can feel free to leave without our permission.
12:23:01 <jadrian> lol
12:23:28 <jadrian> I decided to came back for this question before leaving :)
12:23:34 <jadrian> ok so ghci uses the .o files if they are available
12:24:18 <Heffalump> SyntaxNinja: hmm, true, I guess.
12:24:27 <jadrian> and I can create the .o files using differnt levels of optimization
12:24:27 <Heffalump> but what do users do with the results of bdist, then?
12:24:49 <SyntaxNinja> Heffalump: theoretically, then untar it and run "setup install"
12:24:55 <SyntaxNinja> but I don't remember if I ever implemented it
12:24:56 <jadrian> if I used Cabal could I also select the optimization level?
12:25:14 <SyntaxNinja> jadrian: not on a per-source-file basis.
12:25:16 <Darius> jadrian: As others have mentioned using a package should work for a binary distribution.  According to the documentation though, GHCi just doesn't look for .hi via the import paths apparently just to be annoying.
12:25:41 <Heffalump> .hi really ought to be a section in the .o
12:25:49 <Heffalump> I'm sure there's some good reason why it can't be, of course.
12:26:05 * Heffalump is a seeker after ghc6 debs for woody. Is there any light?
12:26:14 <jadrian> Darius: yeap I got that
12:26:40 <jadrian> Darius: I was just wondering about packages and optimization levels
12:26:42 <Igloo> .hi modification dates need to not change when the interface changes. .os must for linking to happen.
12:26:53 <jadrian> SyntaxNinja: so I'd define the optimization level for my package?
12:27:05 * Igloo might make some tonight or tomorrow
12:27:06 <SyntaxNinja> jadrian: you'd have to define it as a flag to ghc
12:27:17 <jadrian> SyntaxNinja: ah ok
12:27:19 <SyntaxNinja> Igloo: there aren't any in haskell-unsafe already?
12:27:26 <jadrian> thanks, I'm really gone now :)
12:27:27 <Igloo> Don't think so
12:27:40 * SyntaxNinja should have brought his work laptop home...
12:28:02 <Heffalump> igloo: Do you mean they need to not change when the interface doesn't change?
12:28:18 <Igloo> Yes, sorry
12:28:19 <Heffalump> (and good point, and thanks if you do re the debs for woody)
12:51:38 <Spark> hmm what is n-reduction in the lambda calculus?
12:52:35 <Cale> eta-reduction?
12:52:41 <Spark> is that an e?
12:52:49 <Spark> an n
12:52:51 <Spark> even (oops)
12:52:52 <Heffalump> eta looks something like an 'n'
12:52:56 <Cale> no, it's probably an eta
12:52:57 <Spark> ah right thats probably it then
12:53:04 <Heffalump> it's got a tail
12:53:12 <Spark> yeah
12:53:24 <Cale> \x . f x = f
12:53:28 <Heffalump> (\x -> F x) == F if x not free in F
12:53:35 <Cale> yes
12:53:41 <Cale> making that provision :)
12:54:30 <Spark> i dont get it :)
12:54:54 <Spark> (\x.(fx)) reduces to f, if x not free in f?
12:55:33 <Spark> does it not reduce if x is free in f
12:56:13 <Spark> thats really weird :)
12:56:48 <Spark> but to investigate it now would be foolish since im busy
13:01:05 <Heffalump> spark: it's like this:
13:01:15 <Heffalump> suppose f is some closed function
13:01:36 <Heffalump> then \x.fx means "take some parameter x, and pass it to f"
13:01:42 <SyntaxNinja> MegaMonad: what's the difference between n and eta?
13:01:44 <MegaMonad> SyntaxNinja: I have an n of a way to get around those older versions, but no haskeller uses eta.
13:01:57 <Heffalump> so you might as well have just said f as \x.fx
13:02:06 <Heffalump> but suppose f = gx for some g
13:02:23 <Heffalump> then \x.fx = \x.gxx which doesn't mean the same thing as gx at all.
13:02:36 <Heffalump> since x is free in one and not in the other
13:02:54 <Heffalump> it's basically the same issue as avoiding name capture during beta-reduction
13:03:03 <Spark> right
13:03:49 <Spark> so theres no substitution in this semantics?
13:06:37 <Darius> Spark: eta-conversion is usually in addition to beta-reduction.
13:06:54 <Spark> ahr ight
13:07:30 <Spark> so if M1 -> M2 with eta, also M1 -> M2 with beta?
13:07:48 <Darius> Spark: No.
13:08:05 <Darius> (\x.F x) doesn't beta-reduce.
13:08:15 <Spark> ah yes
13:09:12 <Spark> does it come up with 'more normal' normal forms?
13:15:39 <Darius> Actually, a common normal form for some uses is long-beta-eta normal form which is beta-reduced and eta-expanded.
13:23:05 <musasabi> out to look for rockets and new year =>
13:33:36 <Spark> doh
13:33:47 <Spark> my damn server rebooted :)
13:37:08 <ski> MegaMonad: How old are you ?
13:37:08 <MegaMonad> ski: I don't think so.  It looked like me, just like i said, old habits die hard.
13:37:20 <wli> \x.(\y.G) x beta reduces to \x.([y/x]G)
13:37:22 <ski> hmpf
13:37:53 <ski> wli : so ?
13:38:05 <wli> whether it beta reduces depends on F
13:38:06 <Heffalump> which is alpha-equivalent to \y.G
13:38:19 <Heffalump> so eta and beta reduction sometimes do the same things
13:38:58 <Darius> wli; Yes, the implication was that F was beta-normal.
13:39:11 <Darius> or rather F x was.
13:40:18 <Darius> Well, that was wrong.  How 'bout this, the implication is that it doesn't beta-reduce to F.
13:42:41 <Darius> And to make everyone happy, \F.\x.F x doesn't beta-reduce but does eta-reduce.
13:43:21 <Gahhh> MegaMonad: Happy New Year !
13:43:23 <MegaMonad> Gahhh: There's not a new dlist.  In the new year?
13:56:13 <Spark> the existing dlist will suffice
13:56:32 <zipper> what does haskell have planned for 2005?
13:56:37 <Lemmih> dons: How's yi?
13:56:38 <zipper> a new 2005 standard?
13:56:46 <zipper> haskell05?
13:57:10 <Lemmih> zipper: Well GHC 6.4 will come out in '05.
13:57:19 <zipper> sweet
13:57:25 <zipper> will it have existential types?
13:57:35 <wli> is there a post '98 standard of any kind already?
13:57:36 <Cale> It already does
13:57:39 <zipper> :O
13:57:57 <zipper> since when?
13:57:58 <Lemmih> zipper: The biggest change is that it only supports Cabal packages.
13:58:01 <Cale> 6.2
13:58:05 <zipper> sweet
13:58:06 <Cale> or perhaps earlier
13:58:32 <Cale> 6.4 will have "wobbly types"
13:58:39 <zipper> hm...
13:58:45 <wli> what are "wobbly types"
13:58:46 <Cale> Or Generalised Algebraic Data Types
13:58:53 <Darius> zipper: It's had local existential types for a long time.  And given that it has higher-rank types, free existentials can be made as well.
13:59:15 <tuomov> restricted data constructors
13:59:25 <Cale> http://research.microsoft.com/Users/simonpj/papers/gadt/
14:00:16 <zipper> cool, thanks
14:01:30 <zipper> anyone here about to hit the new year?
14:01:42 <tuomov> Hyv√§√§ uuttavuotta
14:01:47 <tuomov> \o_
14:02:06 <Lemmih> zipper: It's 11 pm in Denmark.
14:03:17 <wli> hmm, GADT's aren't something I've ever seen significant use made of in practice
14:03:46 <wli> I'd have considered template haskell a more plausible extension
14:04:12 <zipper> bah, i can't hold out any longer... "happy new year!" and good night everyone :)
14:04:17 <ibid> hyv‰‰ uutta vuotta!
14:04:21 <zipper> huh?
14:04:28 <Lemmih> zipper: Happy new year!
14:04:30 <zipper> :D
14:04:31 <ibid> "happy new year"
14:04:43 <Lemmih> Godt nytaar!
14:04:51 <wli> in comparison, GADT's appear to have come out of a vacuum
14:04:55 <Darius> wli: I actually did want exactly GADTs just before I heard of them, but not for anything particularly practical (at least immediately).
14:08:58 <wli> it seems that GADT's do make a great deal of sense though; it appears to merely admit more general injections into the type.
14:09:16 <wli> in a sense it could be considered a relatively conservative extension
14:09:41 <zipper> so are GADTs in any haskell compiler already?
14:09:43 <Spark> what is an algebraic data type?
14:10:17 <Spark> ah never mind, i cant concentrate on work, thats all :)
14:10:26 <tuomov> sum of products
14:10:49 <Spark> what are sum and product in the context of types then?
14:10:52 <Spark> union and intersection?
14:11:02 <wli> Spark: a sum is a "discriminated union"
14:11:08 <wli> Spark: or a "coproduct"
14:11:14 <tuomov> data Foo = Bar a b | Baz d e f
14:11:22 <tuomov> | = sum, a b = product
14:11:42 <Spark> hm right
14:11:43 <wli> Spark: a product is a "cartesion product" or a "tuple"
14:11:53 <wli> Spark: records are a kind of "labelled product"
14:12:18 <wli> "cartesian product" 
14:12:19 <Darius> zipper: They should be in CVSHEAD and they'll be in 6.4
14:12:32 <Spark> is a discriminated union the same as a tagged union?
14:12:37 <wli> Spark: yes
14:12:39 <Spark> excellent
14:12:44 <Spark> i just understood something new :)
14:12:46 <Spark> thanks
14:14:32 <Darius> Haskell data types go beyond sum of product types (e.g. exponentials with only positive recursive occurences) and beyond inductive types (exponentials with negative recursive occurences) allowing reflexive types.
14:15:32 <tuomov> what's pos/neg recursive?
14:16:39 <Darius> tuomov: If it occurs before an -> it's negated, so A -> B, A is a negative occurence, (A -> B) -> C, B is negative.
14:17:08 <Darius> tuomov: You can relate it to what you're given and what you must provide.
14:18:04 <tuomov> ah
14:18:27 <Spark> what are exponentials?
14:18:36 <tuomov> functions
14:18:38 <tuomov> afaik
14:19:02 <Spark> hm right, because they are phase types that reference two subtypes?
14:20:20 <Darius> Spark: I haven't heard of 'phase types', at least called as such.
14:20:24 <tuomov> a function a -> b can be thought of as an element of (product of b times a)
14:20:44 <tuomov> i.e b^a
14:21:15 <Spark> i think phrase types are types defined using other types
14:21:36 <Spark> i forget where i saw the word used, and never managed to work out for sure what it meant, but that meaning made sense in the contexts that i had seen it
14:21:54 <Spark> oh, a sort of function spaces thing
14:22:48 <Spark> tuomov: s/element/subset though isnt it?
14:23:33 <Spark> and the type of a function a->b is the powerset of b*a
14:23:38 <Spark> or do i need rewiring
14:23:55 <tuomov> no, element
14:24:14 <tuomov> you want an element in b for each element of a
14:24:28 <tuomov> so you have an a-fold product of b
14:24:43 <Darius> tuomov: I think you wanted "product of b a times"
14:24:46 <tuomov> and an element of that product specifies how to get to be from each a
14:25:39 <tuomov> Darius: a times, times a; is there a difference?
14:25:53 <Darius> b times a reads as b*a.
14:25:55 <tuomov> natural language is so ambiguous anyway
14:26:12 <Spark> ah yeah i read it as that
14:26:31 <Spark> so what is a set raised to the power of another set
14:26:40 <Darius> Also, more precise would be |a|.
14:26:50 <Spark> ah
14:26:58 <Spark> now it makes sense
14:27:09 <Darius> Spark: You were right that a function (in set theory) is a subset of the cartesian product of it's domain and codomain.
14:27:28 <Spark> this is like an equivelent expression
14:27:43 <Spark> and probably a more accurate one
14:28:04 <Spark> since it prescribes the uniqueness of the result of the function
14:28:09 <esap> I think there is a difference between the exponential and a subset of a cartesian product.
14:28:12 <Spark> so not equivelent at all :)
14:28:48 <tuomov> Darius: but |a| isn't necessarily finate
14:28:51 <Darius> esap: It's not an arbitrary subset, but it is a subset.
14:28:51 <tuomov> s/na/ni/
14:29:37 <Spark> the exponential is more like a sequence of members of the range, and an implicit mapping from the domain onto N
14:29:38 <Darius> tuomov: Yeah, that's why a-indexed product probably would have been better and it's a bit iffy to compare function spaces to products (in set theory) at the get-
14:29:41 <Darius> go.
14:30:23 <Spark> hmm what are function spaces exactly?
14:30:29 <Spark> one of the above definitions?
14:30:41 <tuomov> esap: a subset of a cartesian product would be a partial relation
14:30:48 <esap> darius: yes. The difference is that a subset of a cartesian product has expanded the representation of the function into lots of pairs [e.g. when space usage is not useful consideration]. A representation for exponential can be in such format where commonalities between those pairs have been used to improve the space usage of the representation.
14:30:50 <tuomov> while an element of an exponential is a total function
14:31:32 <Darius> Spark: A total functional relation, where a relation is as you said, a subset of a product.
14:31:54 <Spark> whats a total functional one?
14:32:28 <Darius> esap: Unless you define another application, etc. in Set Theory a function is a set of pairs (in it's typical formulation).
14:32:43 <esap> darius: That's because set theory doesn't need to optimize the space usage of functions.
14:33:33 <Darius> esap: In most cases I have qualified my description with (in set theory).  In programming for example, the set theoretic definition is ridiculous for the vast majority of uses.
14:34:51 <Darius> Spark: Assuming a binary relation ~ <= AxB, total means for every a in A, there exists a b such that a~b, functional means that that b is unique.
14:35:03 <Spark> ah ok
14:35:16 <Spark> thats a, erm injection or something?
14:35:34 <esap> darius: right. I'm thinking it's the difference between space-efficient and time-efficient representation. Functions happen to get easily so big that representing them as subset of the cartesian product is very likely not useful. But in theory, those could be done as just two different representations for functions. When the domain is very small (e.g. Bool), then the pair representation is pretty useful.
14:35:41 <tuomov> no, injection is the other way around
14:35:44 <Spark> ahh yes
14:36:00 <Spark> its retarded that i can get a computer science degree yet be confused about these terms :)
14:36:16 <tuomov> a function is an injection if in addtion to the above for each b in B there is at most one a such that a~b
14:36:51 <tuomov> it is a surjection if for each b in B there is some a such that a~b
14:37:12 <tuomov> it is a bijection if it is a surjection and injection; i.e. for earch b in B there is exactly in a such that a~b
14:37:20 <tuomov> s/in/one/
14:37:21 <zipper> what about functions that are invalid for certain values... like sqrt?
14:37:21 <esap> darius: another way of thinking about it is laziness. Exponentials are always lazy, and subset of cartesian product is always strict.
14:37:34 <Spark> zipper: thats partial
14:37:44 <zipper> partial?
14:38:10 <Spark> yep a partial function
14:38:22 <zipper> ok
14:38:34 <Darius> Spark: And once you get injective,surjective, and bijective down, you can confuse yourself further with monomorphism, epimorphism and isomorphism.
14:38:47 <Spark> heh
14:38:49 <Cale> zipper: or you can just say that they have a different domain
14:39:04 <Spark> do the lexical structure of the terms have anything to do with what they describe?
14:39:09 <tuomov> and also one-to-one and onto..
14:39:11 * esap got really confused about mono/epi/injective/surjective. They are pretty confusing concepts.
14:39:15 <Cale> for instance sqrt : [0,infinity) -> R
14:39:28 <Cale> esap: they're not that bad
14:39:32 <tuomov> I always forget which way mono/epi was..
14:39:35 <Spark> they need diagrams
14:39:42 <tuomov> mono was the equivalent of injection, right?-)
14:40:05 <Cale> tuomov: monomorphisms would be injective homomorphisms
14:40:22 <esap> When you think of them via duality, it's very strange that mono=injective but epi /= surjective :-)
14:40:33 <zipper> Cale: is it possible to convert a value from one domain to another? [-infinity,infinity] -> [0,infinity] ?
14:40:54 <Cale> what do you mean by "convert"?
14:41:04 <zipper> i don't know
14:41:06 <Darius> tuomov: One person's idea to remember was, mono-a-mono.
14:41:26 <Cale> There's a natural embedding of values from [0,infinity) -> (-infinity,infinity)
14:42:41 <zipper> and the other way?
14:42:48 <desrt> bijection!
14:42:56 <zipper> hm...
14:43:08 <desrt> Cale; is that over real?
14:43:14 <Cale> desrt: yeah
14:43:18 <desrt> i'm not seeing it
14:43:22 <Cale> I'm referring to the map sending x to x
14:43:38 <Cale> which is not a bijection, only an injection
14:43:42 <desrt> oh.  ok.
14:43:47 <Cale> (embedding is another term for injection)
14:44:02 <desrt> i thought you could also get (-inf, inf) into [0, inf)
14:44:09 <desrt> which doesn't make sense to me
14:44:22 <desrt> actually.  i take that back.  i just thought up a (lame) way
14:44:33 <tuomov> just e.g. shift positive values right by one and divide something by the negatives
14:44:39 <tuomov> plus something
14:45:02 <desrt> nod
14:45:25 <desrt> that's a good one.  mine was a lot more lame
14:46:35 <desrt> or just use e^x
14:46:44 <desrt> except that will never give you [0
14:46:45 <desrt> just (0
14:46:48 <Darius> desrt: There are a lot of ways, i.e. map everything < 0 to 0, we don't care about continuity.
14:47:26 <Cale> Darius: that would still be continuous even.
14:47:54 <desrt> Darius; but then it's not injective
14:47:59 <Darius> Actually, "a lot of ways" is a rather large understatement.
14:48:06 <Cale> yeah
14:48:06 <desrt> i'm thinking about a function that goes back and forth
14:48:18 <Cale> there are a huge number of bijections even
14:48:29 <desrt> s/huge/unlimited/
14:48:37 <tuomov> uncountable
14:48:48 <tuomov> take my example and vary the shift
14:48:55 <desrt> right.
14:49:03 <desrt> the shift could be irrational
14:49:04 <Cale> c^c functions.
14:49:25 <Cale> Where c = card(R)
14:49:39 <desrt> that seems like BS.
14:50:06 <Cale> hm?
14:50:23 <desrt> card(R) is already uncountably infinite
14:50:25 <tuomov> there are c^c function R->R so not really that surprising
14:50:27 <Cale> sure
14:51:09 <Cale> at least, I'm fairly sure it's c^c (where that's cardinal exponentiation)
14:51:10 <desrt> R bugs me.
14:51:37 <desrt> even Q is bothersome
14:51:49 <Cale> why?
14:51:55 <desrt> because it's not Z :)
14:52:04 <Cale> Z is the tricky one
14:52:18 <desrt> card(Q) = card(Z) * card(Z) ish?
14:52:22 <Cale> it's not a field, and you have to deal with primes and whatnot.
14:52:32 <Darius> |Q| = |Z|
14:52:34 <desrt> do fields have division?
14:52:36 <Cale> yeah but card(Z) * card(Z) = card(Z)
14:52:41 <Cale> yeah
14:52:49 <desrt> lame.
14:52:52 <Darius> desrt: Q should not bother you.
14:53:19 <tuomov> Q's just ordered pairs of Z
14:53:28 <desrt> tuomov; not exactly.
14:53:34 <tuomov> or equivalence relations thereof
14:53:41 <desrt> ya.  equality gets strange
14:53:44 <tuomov> s/rel/classes/
14:53:47 <desrt> since (1,2) == (2,4)
14:54:00 <Cale> I kind of like how comparability of cardinals is equivalent to the axiom of choice
14:54:10 <tuomov> but you get eq. classes everywhere in analysis
14:54:13 <tuomov> L^n etc.
14:54:23 <tuomov> but nobody things of them as such
14:54:33 <tuomov> g=k
14:54:35 * desrt doesn't care for analysis :)
14:55:15 <tuomov> analysis is nice to a point
14:55:47 <Cale> So if the axiom of choice fails, there are cardinals which are somehow "differently shaped" such that neither one can fit inside the other.
14:56:21 <desrt> Cale; does any such thing exist?
14:56:34 <desrt> like obviously R is bigger than Q....
14:56:39 <Darius> desrt: The more to the point question is, does anyone care?
14:56:40 <desrt> so you can have it one way...
14:56:46 <desrt> Darius; i do :)
14:56:49 <Darius> (with a limited view of "anyone").
14:57:04 * esap has a book by Shelah about cardinal arithmetic. I understand about the first three pages of it :-)
14:57:11 <Cale> desrt: If you assume the negation of the axiom of choice, then yes, there must be incomparable cardinals.
14:57:25 <desrt> Cale; without assuming strange things
14:57:31 <desrt> (which probably aren't true(?))
14:57:45 <Cale> Nothing is true in any absolute way
14:57:49 <tuomov> hmm.. interesting.. how do you get these incomparable cardinals?
14:58:01 <tuomov> or is it just an existential proof
14:58:13 <desrt> are there any 2 sets that we can describe axiomatically that are shape-incompatible?
14:58:30 <Cale> well, it just turns out that if you assume that for any two cardinals, a and b, that either a <= b, or b <= a, then you can prove the axiom of choice
14:58:48 <Cale> (without assuming AC beforehand, of course)
14:59:32 <Cale> desrt: well, not with the standard ZF axioms (we hope). Because if there were, then adding AC to them would give a contradiction
14:59:37 <tuomov> hmm.. excluded middle..
14:59:44 <Darius> For people who are interested in foundations for category theory, I'm currently reading a fairly entertaining paper called "Sets, Classes, and Categories"
15:00:11 <Cale> a <= b for cardinals a and b means that there's an injection mapping a to b.
15:00:54 <desrt> i don't understand what you mean by cardinals
15:01:19 <desrt> i could understand if you defined a<=b on sets to mean card(a)<=card(b)
15:01:45 <Darius> Wow, amazingly right on the page I'm on is the sentence, "in ZF the comparability of all cardinal's is equivalent to the Axiom of Choice (Hartog's Theorom)"
15:01:51 <desrt> and i also don't understand what you mean by injection mapping between cardinals
15:02:00 <Cale> Cardinal numbers are equivalence classes of sets under bijection.
15:02:05 <jadrian> tuomov:Darius:wli:  you were talking about algebraic data types and exponentials
15:02:13 <Cale> Well, that's one way to define them
15:02:25 <desrt> ah
15:02:36 <desrt> that only works on enumerable sets, though
15:02:45 <esap> darius: is it this one: http://philsci-archive.pitt.edu/archive/00001372/
15:02:49 <ski> MegaMonad: Happy new year, you new bot!
15:02:49 <MegaMonad> ski: What's the bot and the new year?
15:02:52 <jadrian> I've studied specification (gogrn material and such)
15:02:58 <jadrian> gogen
15:03:09 <Cale> So two sets A, B belong to the same cardinal class (or have the same cardinality) if there exists a bijection f : A -> B
15:03:12 <jadrian> but none of it included exponentials
15:03:34 <jadrian> do you know of any algebraic specification documents, that include exponentials?
15:03:46 <desrt> ski s (k (s i i)) (s (s (k s) k) (k (s i i)))
15:03:52 <Darius> esap: That or a version of it likely.
15:04:11 <Cale> and for two cardinal classes a, b, we say a <= b, if for any representative A of a, and any representative B of b, there is an injection A -> B
15:04:23 <desrt> Cale; ah.  this is sounding like complexity theory
15:04:28 <desrt> which the classes
15:04:31 <desrt> *with
15:04:37 <Cale> yeah
15:04:47 <jadrian> I've played with languages like Maude and CafeOBJ but because it doesn't map well functional languages because of the lack of "first order function" (exponentials)
15:04:54 <tuomov> eq.classes are everywhere
15:04:59 <Darius> jadrian: Most algebraic specifications stick to finitary signatures.
15:04:59 <desrt> so
15:05:12 <desrt> your axiom of choice says that <= on these classes is transative
15:05:26 <desrt> and namely, that a>b -> not(b>a)
15:05:28 <Cale> no, it's already transitive
15:05:34 <jadrian> Darius: yeap it seemed so...
15:05:49 <Cale> transitive means a <= b and b <= c implies a <= c
15:05:51 <tuomov> AC says <= is total, or something like that
15:05:56 <desrt> Cale; right
15:06:04 <desrt> i'm just looking for a way to say "they strictly form a line"
15:06:09 <desrt> and not a lattice
15:06:21 <ibid> AC implies that, it doesn't say that :)
15:06:24 <Darius> totally ordered
15:06:28 <Cale> it means that for any a and b, that a <= b or b <= a
15:06:36 <desrt> or both
15:06:38 <ibid> that's the continuum hypothesis
15:06:41 <jadrian> Darius: it kind of sucked because even with powerful module systems like CafeOBJ I really had trouble specifying some stuff that I expected to be simple
15:07:07 <desrt> complexity theory is the same way, right?
15:07:09 <tuomov> no, continuum hypothesis is that there's nothing between N_0 and c
15:07:12 <desrt> totally ordered
15:07:14 <Cale> CH doesn't say that
15:07:34 <Cale> CH says that there is no cardinal between card(N) and card(R)
15:07:46 <Cale> R = 2^N
15:07:52 <Darius> jadrian: When I read about OBJ3 Goguen was claiming that it could capture most (all?) higher-order function uses.  Whether it could or not, I don't know, but it seemed overly cumbersome to me.
15:07:58 <ibid> tuomov: ok, ch implies that too :) but it's closer
15:08:14 <jadrian> Darius: maybe he can... I couldn't or at least in no simple way...
15:08:54 <ibid> i find that the most succinct formulation of AC is s != 0 => choice(s) in s :)
15:09:10 <desrt> Cale; that's extremely annoying
15:09:23 <Cale> desrt: what is?
15:09:37 <desrt> that R and N are so far apart and nothing is between them
15:09:43 <Cale> hehe
15:09:52 <Cale> that's if you assume CH
15:09:58 <Cale> some people don't like CH
15:09:59 <Darius> desrt: What would you like between them?
15:10:07 <desrt> Darius; Q.5
15:10:22 <desrt> it's what happens when the rationals get a bit tipsy
15:10:25 <Cale> desrt: hmm?
15:10:29 <Cale> hehe
15:10:39 <Darius> desrt: It actually seems fairly reasonable as 2^N is the smallest infinite powerset I can think of.
15:10:53 <Cale> CH is undecidable anyway
15:10:57 <Darius> Though I haven't thrown much thought at it.
15:11:09 <Cale> So you can have it either way
15:11:14 <desrt> Darius; uh
15:11:15 <ibid> Cale: it's indepenent, not just undecidable
15:11:19 <desrt> N x {1,2}
15:11:21 <Cale> yeah
15:11:32 <ibid> Cale: undecidable would just mean that we can't know which way it is
15:11:39 <ibid> Cale: independent means that we get to choose :)
15:11:39 <desrt> or N x {1} even
15:11:43 <Cale> ibid: that's equivalent
15:11:46 <ibid> Cale: it's not
15:11:49 <Darius> desrt: Those aren't powersets.
15:11:56 <ibid> Cale: independency is much more powerful
15:12:10 <Cale> ibid: hmm?
15:12:17 <tuomov> hmmm..
15:12:18 * desrt becomes confused and annoyed
15:12:24 <tuomov> is this a matter of logic chosen?
15:12:34 <desrt> and N x N is?
15:12:47 <Cale> N x N has the same cardinality as N
15:12:47 <ibid> Cale: unless you use an archaic meaning of "undecidable" :)
15:13:01 <ibid> hm, and even not then
15:13:03 <desrt> Cale; obviously
15:13:21 <desrt> N has the smallest non-infinite cardinality, right?
15:13:25 <Cale> ibid: Undecidable to me means that there does not exist a proof of the statement or its negation from the axioms.
15:13:31 <desrt> smallest infinite, rather
15:13:39 <ibid> Cale: that's the archaic meaning
15:13:49 <tuomov> desrt: N_0 with a wiggly N
15:13:51 <ibid> Cale: modern meaning is that there is no algorithm that can decide the issue :)
15:13:53 <Cale> In which case I don't see how adding it, or its negation could cause any trouble.
15:13:54 <Darius> desrt: NxN is not a set of subsets.
15:14:00 <tuomov> desrt: is the standard way to write it
15:14:14 <Cale> ibid: I'm a mathematician :)
15:14:16 <Darius> (or perhaps more precisely, not a set of -all- the subsets of some set)
15:14:18 * desrt blinks at tuomov
15:14:24 <desrt> this is a confusing conversation :)
15:14:27 <Darius> nabla
15:14:35 <Darius> No, aleph
15:14:35 <ibid> Cale: most mathematicians don't know squat about logic :)
15:15:07 <ibid> Cale: i used to study math as a major, but my msc was heavily involved in logic, i've read a lot of that stuff :)
15:15:16 <Cale> Well, I've taken a course in mathematical logic, anyway.
15:15:18 * desrt uses ibid's statement to prove that NP can be solved in P
15:15:24 <ibid> Cale: i have, too
15:15:27 <tuomov> I have an M.Sc in math..
15:15:32 <ibid> desrt: hm?
15:15:55 <desrt> ibid; you gave ¬¨a in the presence of a :)
15:16:05 <jadrian> Darius: by the way, I also still have no idea how to specify simple recursive parameterized datatypes in OBJ languages, things like   RCC D = Atom D | Rec [RCC D] -> D.
15:16:06 <ibid> desrt: i did? where?
15:16:11 <desrt> 18:12 <ibid> Cale: most mathematicians don't know squat about logic :)
15:16:16 <ibid> desrt: and?
15:16:29 <desrt> oh damned english!
15:16:31 <desrt> foiled again
15:16:31 <Darius> jadrian: Me neither.  I only ever looked at OBJ3.
15:16:34 <ibid> :)
15:16:41 <desrt> the opposite of that statement is that they *do* know squat
15:16:45 <Spark> what does a large pi-like symbol mean, when applied to a set of things
15:16:48 <Spark> like a sigma
15:16:57 <tuomov> product
15:16:58 <Spark> is it the cartesian product of them all?
15:16:58 <Cale> Spark: product
15:16:58 <desrt> bastard :P
15:17:01 <Spark> okey dokey
15:17:12 <ibid> desrt: there are mathematicians who know a lot about it, but those tend to be fommers or logicians; most mathematicians aren't either
15:17:24 * desrt needs to go eat now
15:17:29 <desrt> (and take some asprin, probably) :)
15:17:32 <ibid> :)
15:17:38 * ibid should go to bed
15:17:41 <jadrian> Darius: it's easy if they are not parameterized, but otherwaise I see no way to do it. I tried in CafeOBJ but is should be more general than OBJ3
15:18:15 * jadrian has Maude on is todo list
15:18:32 * jadrian will probably try Coq first though
15:20:28 <Darius> What I'd like is a categorical proof assistant.
15:20:38 <ibid> Cale: if the theory is complete, then your undecidability is equivalent to independence (but usually model-theoretic arguments about independence are much nicer:)
15:24:49 * esap is trying to implement category theory :-)
15:28:31 <Darius> esap: Something Coq/Elf/Isabelle-like or something more like Charity/CPL or something like Burstall's Computational Category Theory?
15:29:20 <esap> darius: I'm thinking something like Charity. But actually I'm not far enough to make that big decisions :-)
15:30:06 <Darius> esap: What I want is something like Elf or Coq, something to do Category Theory in.
15:31:01 <jadrian> Darius: I like automated deduction, and wouldn't mind diving into Categories
15:31:32 <jadrian> Darius: I thought about automated deduction though, not proof assistant
15:32:22 <esap> darius: My motivation comes from being able to write software with it. So I want the result to run. But doing category theory in it will be big part of the thing.
15:32:31 <jadrian> Darius: by the way, do you know of good places for Phds in that kind of stuff?
15:32:43 <Darius> jadrian: Well the hard part (right now) seems to be the same, how to axiomatize category theory relatively independent of set theory.
15:33:00 <jadrian> Darius: right
15:33:13 <jadrian> Darius: do you recommend any papers on the subject?
15:35:33 <esap> darius: see http://www.kotiposti.net/epulkkin/TTree.txt . That contains current ideas about it.
15:36:27 <Darius> There are some papers on machine-checkable formalizations in most of the major theorem proovers/proof assistants.
15:37:47 * esap thinks probably half of it is wrong or unfinished.
15:38:46 <ski> esap : is that GADT ?
15:38:51 <esap> ski: yes.
15:38:59 <ski> interesting
15:39:40 <esap> Before GADT's the thing was very much worse, couldn't express anything without lots of comments. Now everything is part of the code.
15:39:43 <ski> hm, your cat type is parameterized by obj and arr types, it seems ?
15:40:23 <Darius> esap: You have looked at Burstall's Computational Category Theory right?
15:40:27 <esap> ski: yes, it's based on the way people normally describe categories, i.e. "category of abstract sets and mappings between sets"
15:40:53 <jadrian> Darius: but do you want to reason over categorical theories, or to have categories has the underlying formalism of a proof assistant?
15:41:13 <jadrian> s/has/as
15:41:21 <esap> darius: I don't remember him by name, so probably not :-)
15:41:31 <ski> esap : hmm, when i've been sketching cat type def, i've included obj and arr type as argument to the data constr. ..
15:41:37 <esap> darius: is it available online?
15:41:42 <Darius> jadrian: Have categories as the underlying formalism, which is why I haven't just used them.
15:41:52 <ski> (Darius : i've browsed through that ..)
15:42:12 <jadrian> Darius: right
15:42:42 <Darius> esap: It should be somewhere.
15:42:57 * ski 's tinkered a little around with trying to express cat basics in some kind of dep. type theory, i think
15:43:16 <Darius> ski: I translated the ML to Haskell (directly).
15:43:26 <ski> Darius : nice
15:44:17 <ski> esap : what is the definition of TCategory ?
15:44:42 <ski> (maybe it's later in same module ?)
15:45:14 <esap> ski: It is in the same module.
15:45:20 <ski> oki
15:45:47 <ski> oh
15:45:58 <ski> that was unexpected (for me)
15:46:49 <esap> ski: yea, I've been thinking about actually trying to find a better representation for the categories.
15:46:56 <ski> you're providing basic cats and basic composition of them into new ones ..
15:47:12 <esap> ski: yes.
15:49:32 <Darius> *sigh*  It seems as though though, that half of them are missing because of a bad CD-R.
15:49:32 <esap> Another thing I've been thinking TArrow is way too big currently. I should be able to find ways to build those from smaller primitives.
15:50:24 <esap> Some of them can be built based on adjunctions, but that's not simple either.
15:57:29 <Darius> esap: Here's the link if you didn't find it http://www.cs.man.ac.uk/~david/categories/index.html
15:58:21 <esap> darius: Yea, I found it.
16:00:21 <ski> esap : hm, i was more thinking of some def. similar to the usual math one ...
16:00:46 <ski> esap : something maybe like this http://www.mdstud.chalmers.se/~md9slj/CatTheory.txt
16:01:13 <ski> (that is of course not haskell ..)
16:02:51 <esap> ski: yea, clearly that can be used to describe the common category structure. But TCategory is more like trying to describe what categories exist [which is not captured by the common parts of all categories]
16:03:04 <ski> yeah
16:03:26 <ski> like an inductive def. maybe
16:04:07 <esap> ski: I do have the rest of the structure in TArrow and TObject. The laws are somewhat difficult things, I haven't yet figured out a good way to do them.
16:04:21 <Janni> Hi.
16:04:27 <ski> esap : you haven't written them in comments, then ?
16:04:30 <ski> hi jadrian
16:04:33 <ski> bah
16:04:36 <ski> hi Janni
16:05:43 <esap> ski: No, I should do that. Though most of it is very trivial, I could write them any time very easily.
16:05:47 <Darius> esap: Are you implementing something like Set with Haskell types and terms giving the interpretation of the objects and arrows?
16:07:14 <esap> darius: I'm planning on having a run-time system, which would provide intepretations. This is supposed to become a programming language. The EvalA is one way how the interpretation is visible. (see TArrow/TLambda)
16:07:55 <Darius> esap: But the programming language will be akin to working in Set (well a more computing friendly category).
16:08:22 * ski has imagined a CT based lang where one could express morphisms in e.g. topological cats with function syntax and get structure preservation for free ..
16:08:41 <esap> darius: yes, very much like that. I do have some ideas about actually having a separate description of that level, but those are not finished.
16:08:51 <ski> (where one could work in multiple cats and switch with functors and such ..)
16:09:15 <esap> darius: such that programmer could write his own.
16:09:36 <ski> esap : write his own Set, you mean ?
16:09:42 <esap> darius: But that goes into the details of the run-time system, which I haven't done very well currently.
16:09:52 <esap> ski: write something to work as intepretation of his programs.
16:10:23 <ski> ok
16:10:43 <Janni> Can I somehow simulate a function of the type  A or B or C or ... where A,B,C.. are instances of a specific class?
16:11:23 <ski> Janni : maybe with an existential datatype ?
16:11:26 <Janni> So that I have a "value" I can only operate with function defined in that class?
16:11:34 <esap> I've currently trying to build a core of a compiler such that I could have a syntax to parse that, and an intepreter for doing reductions. But all that is not finished.
16:12:13 <ski> Janni : but you don't need to recover what the instance type actually is, just being able to call type class methods on values of that type ?
16:12:47 <ski> esap : ok
16:13:00 <ski> esap : using the code you've shown ?
16:13:09 <ski> esap : or just feeling around ?
16:13:14 <Janni> ski: Yes
16:13:28 <esap> ski: yes, that's the parse tree part.
16:13:32 <ski> Janni : then it sound like existentials could do the job
16:13:40 <ski> esap : aha,ok
16:13:42 <Janni> ski: Thx. I'm already reading.
16:13:54 <Janni> (I mean about existential types)
16:14:08 <ski> Janni : yep (just ask if you wonder/need more info)
16:14:14 <Darius> @wiki ExistentialType I think the page is.  It likely also will be useful.
16:14:14 <lambdabot> http://www.haskell.org/hawiki/ExistentialType I think the page is.  It likely
16:14:14 <lambdabot> also will be useful.
16:14:22 <ski> esap : ok
16:14:32 <esap> ski: but note that the GADT provide a primitive type checking for it, so you can't just generate that from standard parsers [you need both parser and type checker to generate that]
16:15:03 <ski> esap : so you are going to have special conrete syntax for the usual categorical constructs (pullbacks, etc ...) ?
16:15:19 <ski> esap : to generate what ?
16:16:01 <esap> ski: I mean, to construct data for that parse tree, you must already know that it type checks [as far as GADTs can check]
16:16:25 <ski> yep
16:17:11 <ski> (iirc GF generates untyped parsetrees and typechecks later, filtering out)
16:17:13 <esap> ski: yes, I need to have separate syntax for it, that tree is not very easy to use. I've been thinking of just removing the type annotation from it, and then try to build syntax.
16:17:45 <esap> ski: But that's not very close to reality yet.
16:17:51 <ski> ok
16:18:21 <ski> hm, wondering, the user will not have to explicitely prove stuff for the system, right ?
16:18:37 <ski> (such as, this is really a pullback, etc..)
16:19:24 <esap> ski: well in one sense, he has to, since the program will not type check if it's not provable. But I'm trying to make it as simple as possible.
16:19:51 <ski> <ski> ... explicitely ...
16:20:03 <esap> ski: And the feel should be like programming language, not like theorem prover.
16:20:25 <ski> i was thinking of more like a proof assistant, in that case ?
16:20:54 <ski> umn s/ ?//
16:22:08 <esap> ski: User needs to explicitly give some indications of how to prove things, you can't do everything automatically. But I'm thinking it's possible to keep the information at minimum, and by being explicit about all of it [and put it into the syntax of the language] will make it easier to use.
16:22:48 <ski> ok
16:23:01 * esap uses Curry-Howard correpondence for the proof part.
16:23:17 <esap> so that terms are the proofs.
16:29:56 <ski> (was thinking because the user (or lib writer) won't construct the basic concepts (cat,functor,pullback, etc) by her-/him-self so don't have to have as many (any at all ?) proofs, because "builtin" into the basic concepts. just stick the lego together, not describe the building blocks up to quantum theory.. errr umm, something like that :)
16:31:05 <esap> ski: yea, but being able to build new building blocks is an important capability as well. I'm not planning on being able to cover for every need that will arise in future.
16:31:24 <ski> ok
16:31:43 <esap> ski: But of course, the basic stuff must be easy to use.
16:31:55 <ski> do you think you need some kind of more explicit representation of proff, then ?
16:32:00 <ski> proof*
16:32:17 <esap> ski: what do you mean 'more explicit'. I think it's explicit enough already :-)
16:32:30 <ski> hm
16:32:32 <ski> dunno
16:32:34 <esap> ski: The primitives are a different matter obviously
16:33:13 <ski> explicit like writing proof terms over type which is equality between morphisms, and such ..
16:33:34 <ski> hm, maybe i should've said 'lowlevel' (?)
16:33:35 <esap> ski: yea, I don't currently have a good way of doing commuting diagrams.
16:34:16 <esap> ski: Not in that parse tree at least. I think they would probably be some kind of annotations about which way to reduce first.
16:34:35 <ski> i guess one could do them as textual equations, but having visual (heh) diagrams in front of yeh could be more pretty-looking
16:34:35 <esap> ski: because commuting diagrams will somehow correspond to reductions, that is evaluation.
16:34:43 <ski> hmm
16:35:03 <ski> changing one path into another (commuting) one ?
16:35:33 <esap> ski: yes, something along those lines.
16:35:33 <ski> p0 o <f,g> = f   etc ...
16:35:37 <Janni> Is it somehow possible to make a data type that is completly mutable without using IORefs for every member?
16:36:00 <ski> Janni : what do you mean by 'completely mutable‰ ?
16:36:05 <esap> ski: But I'm not sure how to do that part, it's one of the least well described parts of category theory :-)
16:36:26 <ski> Janni : every element/constructor argument separately mutable ?
16:36:39 <Janni> I mean, "data A = X (IORef Y) | Z (IORef Int) (IORef Y) (IORef M); data Y = Y (IORef Int) ....." is not very nice
16:36:54 <ski> esap : using commuting diagrams as reductions ?
16:37:08 <Janni> ski: I think me mean the same
16:37:30 <esap> ski: or rather, transformations on the parse tree.
16:38:15 <esap> ski: but evaluation is clearly such transformation.
16:38:21 <ski> Janni : lemme check, it would not be useful to just have one IORef at top, and replacing whole structure every time ?
16:38:31 <ski> esap : mm
16:38:32 <esap> ski: at least in the theory. Intepretations are then different thing.
16:39:00 <Janni> ski: Exactly
16:39:06 <ski> (esap : i've sometimes wanted to define functions with '.' in haskell)
16:39:19 <Janni> Or isn't it inefficient to do so? (replacing the whole thing)
16:39:23 <ski> Janni : well, hm
16:39:25 <Janni> (if it is very big)
16:39:33 <ski> Janni : hm, that depends
16:39:43 <esap> ski: well '.' combines functions, it doesn't define them.
16:40:02 <Janni> You mean, only if it is inefficient to "find" my element?
16:40:56 <ski> esap : if we have p0,p1, we can define < , > by  p0 . <f,g> = f ; p1 . <f,g> = g
16:41:10 <ski> Janni : no
16:41:13 <Janni> I have a really big data structure which can be modified (edited) by the user.
16:41:37 <Janni> So I have IORefs quite everywhere in that structure.
16:41:46 <ski> Janni : depends on how expensive it it to reconstruct a modified value which then is written into the IORef cell
16:42:12 <esap> ski: yes, but it's not '.' that does the defining part. Ok I see what you mean, defining using equations. Pullbacks and equalizers can do that [but you need to implement the commuting diagrams!]
16:42:29 <Janni> ski: I mean the modification is quite small, e.g. set this Int from x to y...
16:43:18 <ski> esap : um right. i didn't mean '.' did the defining. i meant to define *with the help of* '.' ...
16:43:52 <ski> Janni : hm
16:46:28 <Janni> I mean, I can _live_ with the IORefs, but I wouldn't like to use them if there is a nicer solution.
16:46:57 <ski> Janni : i think i would at least initially go with just one IORef, unless it is too expensive, in which case i would add your IORef
16:48:10 <Janni> You mean, I should try if it is inefficient to replace the whole data structure?
16:48:30 <ski> yep
16:49:21 <ski> mayhaps the system notices that you use the data in a single-threaded way (if you indeed do so), and then optimises it with local update anyway
16:49:39 <ski> (but i don't know how likely that would be)
16:50:18 <ski> (Janni : something like Clean's uniqueness type system could express something like this more clearly)
17:47:15 <wagle> hey ski: the only reference to "anarchaic algebras" i can find with google are some logs of you mentioning them here..  where do i go to find out more?  (i'm chasing down a reference to them in the context of F-algebras in pierce's little category theory book)
17:47:39 <wagle> (the chatter was last feb..  8)
17:55:55 <SyntaxNinja> MegaMonad: the only reference to "anarchaic algebras" i can find with google are some logs of you mentioning them here..  where do i go to find out more?
17:55:55 <MegaMonad> SyntaxNinja: Are you thinking about algebras as in the acoustic sweet spot of the google page.
17:56:04 <SyntaxNinja> haha
18:06:32 <wagle> so true!
19:36:22 <ski> good new year bye
19:54:12 <musasabi> good new year (05:52)
20:12:37 <tintin> happy new year to all of you wonderful folks 
21:21:29 <MegaMonad> Hello what math and the previous rational to generate a list of times might make it local to one part of haskell does gadts is with the sms/instant messaging generation.
21:23:47 <CosmicRay> happy new year!
21:23:49 <CosmicRay> MegaMonad: any new year's resolutions?
21:23:51 <MegaMonad> CosmicRay: Last year's signs were great! --> Http://andersca.org/gallery/eurohaskell/p1010070.
21:24:16 <jesse__> CosmicRay, how can it be 12am there, its 11:30 here
21:24:28 <CosmicRay> it's actually 11:22PM here
21:24:33 <jesse__> ahh
21:24:36 <jesse__> k
21:24:41 <CosmicRay> but I know there are a lot of europeans here that are probably hung over right about now :-)
21:25:37 <CosmicRay> and here in the central time zone, the ball drops at 11PM anyway
21:26:26 <CosmicRay> jesse__: you must also be somewhere in the americas, or maybe new zealand... :-)
21:26:34 <jesse__> bah, ball shmall (i must have missed it)
21:26:45 <CosmicRay> heh
21:26:48 <jesse__> im in alabama
21:26:59 <CosmicRay> shouldn't it be 12:30 there?
21:27:09 <jesse__> nope, its central here too
21:27:16 <CosmicRay> huh
21:27:18 <jesse__> central is a big time zone
21:27:23 <CosmicRay> I didn't know the central zone went that far east
21:27:32 <CosmicRay> I'm in Kansas over here
21:28:05 <jesse__> yeah, i used to live in central texas, its in central too, durring daylight savings time it doesnt get dark there until 10pm
21:28:30 <CosmicRay> yup, same here
21:28:57 <CosmicRay> it was annoying living in Indiana, which never uses DST -- and is farther north.  daylight ends about 2 hours earlier.
21:30:18 <jesse__> its annoying living here right now, it gets dark at 5.... i leave at dark in the morning, and get home at dark at night
21:30:50 <jesse__> i dont see daylight durring the week
21:31:06 <CosmicRay> that would suck indeed.
21:32:36 <CosmicRay> MegaMonad: what sucks?
21:32:38 <MegaMonad> CosmicRay: Gtk sucks, so...
21:32:43 <CosmicRay> MegaMonad: what sucks?
21:32:44 <MegaMonad> CosmicRay: So why would "calling it again, sourceforge's download interface sucks.
21:32:54 <CosmicRay> MegaMonad: correct on both counts.  good for you.
21:32:56 <MegaMonad> CosmicRay: I'll read more of an expression?  :I seems to me it is correct, so that counts.
21:36:52 <Lemmih> Hey Sonarman.
21:37:22 <Sonarman> hi Lemmih
21:50:11 <jesse__> CosmicRay: your bot?
21:50:31 <CosmicRay> jesse__: MegaMonad is
21:50:40 <CosmicRay> jesse__: shapr runs lambdabot
21:50:45 <CosmicRay> @wiki MegaMonad
21:50:45 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
21:50:58 <CosmicRay> jesse__: some quotes and info at that url
21:50:59 * jesse__ looks
21:53:35 <jesse__> ive messed around with markov chains some, but your bot is doing something a little different
21:54:21 <CosmicRay> it is markov
21:54:29 <CosmicRay> jesse__: see http://megahal.alioth.debian.org
21:54:36 <CosmicRay> megahal is tne underlying engine
21:54:37 <jesse__> alright
21:54:42 <jesse__> k
22:35:29 <reffie> happy fucking new year
22:37:49 * Lemmih is really anxious do see how dons is implementing structual editing in yi.
22:42:09 <dons> Lemmih: no structural editing yet. why don't you send me some ideas to think about?
22:42:15 <Lemmih> s/do/to/
22:42:58 <dons> there's lots of literature on this too, which I haven't read much of yet
22:43:21 * Lemmih is reading a thesis about Proxima.
22:44:35 <dons> at cs.uu.nl ?
22:46:31 <dons> interesting "in-order" structure editing. 
22:46:38 <Lemmih> Are you asking if I'm studying at that university or if it's the paper by Martijn Schrage?
22:47:16 <dons> sorry, I was just googling "proxima editor" and wondering if I had the right link :)
22:48:49 <Lemmih> I would really like to see what you've done so far. Feeling like sending me a patch?
22:49:45 <dons> I've just been designing (on paper mostly) the syntax parser interface to the rest of the editor
22:50:04 <dons> no work has been done on editing the abs syn, for example
22:50:50 <dons> but I hopefully will get something comitted in a week or so
22:51:06 * dons notes that vim syn hl is 10,000 lines of C!
22:51:43 <Lemmih> He.
22:51:54 <reffie> he
22:52:23 <Cale> eh
22:52:34 <Lemmih> I'm losing characters... Stupid wireless keyboard.
22:53:05 <Cale> My keyboard isn't wireless, but it has started to lose g and b from time to time.
22:56:40 * Lemmih wants to be the first Haskeller to unicycle in '05 and leaves.
23:05:02 <desrt> Cale; that's because b and g are wireless standards
23:05:10 <desrt> non-wireless devices don't support them :)
